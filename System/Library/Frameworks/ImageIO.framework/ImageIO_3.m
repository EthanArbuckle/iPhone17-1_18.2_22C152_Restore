void sub_188714BCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,CGColorSpaceRef a36)
{
  uint64_t v36;

  IIOColorSpace::~IIOColorSpace(&a36);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)(v36 - 216));
  _Unwind_Resume(a1);
}

CGImageRef CGImageCreateCopyWithBitmapInfo(CGImageRef image, CGColor *a2, size_t a3, unint64_t a4, CGBitmapInfo a5, BOOL a6, CGColorRenderingIntent a7)
{
  if ((gIIODebugFlags & 0x400000000) != 0) {
    ImageIOLog("    %s\n", "CGImageCreateCopyWithBitmapInfo");
  }
  size_t Width = CGImageGetWidth(image);
  size_t Height = CGImageGetHeight(image);
  unint64_t BitsPerComponent = CGImageGetBitsPerComponent(image);
  int AlphaInfo = _ImageGetAlphaInfo(image);
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
  CGDataProviderSequentialCallbacks callbacks = *(CGDataProviderSequentialCallbacks *)byte_1ED4F09F8;
  if (_ImageIsFloat(image) != (unsigned __int16)(a5 & 0x100) >> 8 || CGImageGetDecode(image)) {
    return 0;
  }
  space = ColorSpace;
  CGImageRef v17 = 0;
  if (BitsPerComponent > 0x20 || ((1 << BitsPerComponent) & 0x100010100) == 0) {
    return v17;
  }
  if (a4 < (Width * a3 + 7) >> 3) {
    return 0;
  }
  CGBitmapInfo v42 = a5;
  unsigned int v18 = a5 & 0x1F;
  if (!_ValidAlphaInfo(BitsPerComponent, a3, space, v18)) {
    return 0;
  }
  CGColorRenderingIntent intent = a7;
  Mask = (CGImage *)CGImageGetMask();
  if (CGImageGetClipPath()
    || CGImageGetMaskingColors()
    || Mask
    && (BitsPerComponent != CGImageGetBitsPerComponent(Mask)
     || Width != CGImageGetWidth(Mask)
     || Height != CGImageGetHeight(Mask)))
  {
    return 0;
  }
  if (a2 && (AlphaInfo - 1) >= 4 && AlphaInfo != 7 && v18 - 1 < 7 && ((0x4Fu >> (v18 - 1)) & 1) != 0) {
    return 0;
  }
  BOOL shouldInterpolate = a6;
  size_t v43 = a3;
  size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(space);
  v21 = malloc_type_calloc(0xD8uLL, 1uLL, 0xE497A39EuLL);
  if (!v21) {
    return 0;
  }
  v22 = v21;
  size_t v23 = a4;
  v21[1] = 0;
  DataProvider = CGImageGetDataProvider(image);
  v22[6] = CGDataProviderRetain(DataProvider);
  if (Mask)
  {
    v25 = CGImageGetDataProvider(Mask);
    CGDataProviderRef v26 = CGDataProviderRetain(v25);
    v27 = Mask;
  }
  else
  {
    CGDataProviderRef v26 = 0;
    v27 = image;
  }
  v22[7] = v26;
  v22[11] = Width;
  v22[12] = Height;
  v22[13] = BitsPerComponent;
  v22[14] = NumberOfComponents;
  v22[15] = CGImageGetBitsPerPixel(image);
  v22[16] = CGImageGetBytesPerRow(image);
  *((_DWORD *)v22 + 34) = AlphaInfo;
  v22[18] = _ImageGetEndianInfo(image);
  v22[19] = v43;
  v22[20] = v23;
  *((_DWORD *)v22 + 42) = v18;
  v22[22] = v42 & 0x7000;
  v22[23] = CGImageGetBitsPerPixel(v27);
  if (Mask) {
    size_t BytesPerRow = CGImageGetBytesPerRow(Mask);
  }
  else {
    size_t BytesPerRow = 0;
  }
  v22[24] = BytesPerRow;
  *((_DWORD *)v22 + 50) = 7;
  v22[26] = _ImageGetEndianInfo(v27);
  v22[8] = a2;
  v22[9] = 0x3FF0000000000000;
  if (a2)
  {
    Components = CGColorGetComponents(a2);
    if (Components) {
      v22[9] = *(void *)Components;
    }
  }
  uint64_t v30 = v22[7];
  unsigned int v31 = *((_DWORD *)v22 + 42);
  if (v31 - 5 > 0xFFFFFFFD)
  {
    BOOL v32 = 0;
    if (v30) {
      goto LABEL_32;
    }
  }
  else
  {
    BOOL v32 = (*((_DWORD *)v22 + 34) - 3) < 2;
    if (v30) {
      goto LABEL_32;
    }
  }
  if ((*((_DWORD *)v22 + 34) - 1) > 1)
  {
    BOOL v33 = 0;
    goto LABEL_33;
  }
LABEL_32:
  BOOL v33 = v31 - 3 < 2;
LABEL_33:
  if (v31 <= 6 && ((1 << v31) & 0x61) != 0)
  {
    if (v32) {
      int v34 = 1;
    }
    else {
      int v34 = 2;
    }
    if ((*((_DWORD *)v22 + 34) - 1) >= 2) {
      int v35 = 0;
    }
    else {
      int v35 = 3;
    }
  }
  else
  {
    int v35 = 0;
    if (v32) {
      int v34 = 1;
    }
    else {
      int v34 = 2;
    }
  }
  if (v32 || v33) {
    int v36 = v34;
  }
  else {
    int v36 = v35;
  }
  *((_DWORD *)v22 + 20) = v36;
  v37 = CGDataProviderCreateSequential(v22, &callbacks);
  if (!v37)
  {
    alphaProviderReleaseInfo(v22);
    return 0;
  }
  v38 = v37;
  CGImageRef v17 = CGImageCreate(Width, Height, BitsPerComponent, v43, v23, space, v42, v37, 0, shouldInterpolate, intent);
  if (v17)
  {
    CGImageSetProperty();
    CGImageSetProperty();
    CGImageSetProperty();
  }
  CFRelease(v38);
  return v17;
}

CGImage *CGImageCreateCopyWithParameters(CGImage *a1, CGColor *a2, _OWORD *a3, unint64_t a4, unint64_t a5, unint64_t a6, size_t a7, unint64_t a8, CGColorSpace *a9, CGBitmapInfo a10, BOOL a11, CGColorRenderingIntent a12)
{
  kdebug_trace();
  IIOInitDebugFlags();
  uint64_t v18 = gIIODebugFlags;
  if ((unsigned __int16)gIIODebugFlags >> 14)
  {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateCopyWithParameters", 0, 0, -1, 0);
    uint64_t v18 = gIIODebugFlags;
  }
  if ((v18 & 0x400000000) != 0) {
    ImageIOLog("    %s\n", "CGImageCreateCopyWithParameters");
  }
  long long v19 = a3[1];
  *(_OWORD *)&v24.a = *a3;
  *(_OWORD *)&v24.c = v19;
  *(_OWORD *)&v24.tx = a3[2];
  v20 = CGImageCreateCopyWithParametersNew(a1, a2, &v24, a4, a5, a6, a7, a8, a9, a10, a11, a12, kCGInterpolationDefault, 0);
  kdebug_trace();
  return v20;
}

CGImage *CGImageCreateThumb(CGImage *a1, unint64_t a2)
{
  if ((gIIODebugFlags & 0x400000000) != 0) {
    ImageIOLog("    %s\n", "CGImageCreateThumb");
  }
  kdebug_trace();
  ThumbNew = CGImageCreateThumbNew(a1, a2, 0, -1, 1);
  kdebug_trace();
  return ThumbNew;
}

CGImage *CGImageCreateThumbNew(CGImage *a1, unint64_t a2, unsigned int a3, int a4, int a5)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  IIOInitDebugFlags();
  uint64_t v9 = gIIODebugFlags;
  if ((unsigned __int16)gIIODebugFlags >> 14)
  {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateThumbNew", 0, 0, -1, 0);
    uint64_t v9 = gIIODebugFlags;
  }
  if ((v9 & 0x400000000) != 0) {
    ImageIOLog("    %s\n", "CGImageCreateThumbNew");
  }
  CGColorSpaceRef v61 = 0;
  long long v60 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 8);
  BOOL v10 = a5 == 2;
  CFStringRef v11 = (const __CFString *)*MEMORY[0x1E4F1DC98];
  CGColorSpaceRef v58 = (CGColorSpaceRef)&unk_1ED4DFD58;
  CGColorSpaceRef space = CGColorSpaceCreateWithName(v11);
  size_t BitsPerComponent = CGImageGetBitsPerComponent(a1);
  if (!a1)
  {
    _cg_jpeg_mem_term("CGImageCreateThumbNew", 967, "*** ERROR: CGImageCreateThumbNew - input image is NULL\n");
LABEL_93:
    v45 = 0;
    goto LABEL_76;
  }
  if (!a2)
  {
    _cg_jpeg_mem_term("CGImageCreateThumbNew", 968, "*** ERROR: CGImageCreateThumbNew - maxSize is 0\n");
    goto LABEL_93;
  }
  size_t v13 = BitsPerComponent;
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(a1);
  CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
  int Type = CGColorSpaceGetType();
  CGColorRenderingIntent RenderingIntent = CGImageGetRenderingIntent(a1);
  BOOL IsOpaque = _ImageIsOpaque(a1);
  int v52 = _ImageAlphaPosition(a1);
  size_t Width = CGImageGetWidth(a1);
  size_t Height = CGImageGetHeight(a1);
  *(float *)v19.i32 = (float)a2;
  if (Width <= Height) {
    unint64_t v20 = Height;
  }
  else {
    unint64_t v20 = Width;
  }
  v18.f32[0] = *(float *)v19.i32 / (float)v20;
  v21.i64[0] = Width;
  v21.i64[1] = Height;
  int8x8_t v22 = (int8x8_t)vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vextq_s8(v21, v21, 8uLL), (uint64x2_t)v21));
  float32x2_t v23 = vcvt_f32_f64(vcvtq_f64_u64((uint64x2_t)v21));
  int8x16_t v24 = (int8x16_t)vcvtq_u64_f64(vcvtq_f64_f32((float32x2_t)vbsl_s8(v22, (int8x8_t)vrndm_f32(vmul_n_f32(v23, v18.f32[0])), (int8x8_t)vdup_lane_s32(v19, 0))));
  int8x16_t v25 = (int8x16_t)vdupq_n_s64(a2);
  int8x16_t v26 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v25, (uint64x2_t)v24), v24, v25);
  int8x16_t v27 = (int8x16_t)vcgtq_u64((uint64x2_t)v26, (uint64x2_t)vdupq_n_s64(1uLL));
  uint64x2_t v28 = (uint64x2_t)vsubq_s64((int64x2_t)vandq_s8(v26, v27), (int64x2_t)vmvnq_s8(v27));
  double v29 = v18.f32[0];
  unint64_t v30 = v28.u64[1];
  if (a3 - 9 > 0xFFFFFFF7)
  {
    v62[0] = v18.f32[0];
    if (a3 <= 4) {
      unint64_t v37 = v28.i64[0];
    }
    else {
      unint64_t v37 = v28.u64[1];
    }
    if (a3 > 4) {
      unint64_t v30 = v28.i64[0];
    }
    v62[1] = 0.0;
    v62[2] = 0.0;
    v62[3] = v18.f32[0];
    v62[4] = 0.0;
    v62[5] = 0.0;
    double v63 = (float)-v18.f32[0];
    uint64_t v64 = 0;
    uint64_t v65 = 0;
    double v66 = v18.f32[0];
    double v67 = (double)v37;
    uint64_t v68 = 0;
    double v69 = v63;
    uint64_t v70 = 0;
    uint64_t v71 = 0;
    double v72 = v63;
    double v73 = (double)v37;
    double v74 = (double)v30;
    double v75 = v18.f32[0];
    uint64_t v76 = 0;
    uint64_t v77 = 0;
    double v78 = v63;
    uint64_t v79 = 0;
    double v80 = (double)v30;
    uint64_t v81 = 0;
    double v82 = v63;
    double v83 = v63;
    uint64_t v84 = 0;
    double v85 = (double)v37;
    double v86 = (double)v30;
    uint64_t v87 = 0;
    double v88 = v63;
    double v89 = v18.f32[0];
    uint64_t v90 = 0;
    uint64_t v91 = 0;
    double v92 = (double)v30;
    uint64_t v93 = 0;
    double v94 = v18.f32[0];
    double v95 = v18.f32[0];
    long long v97 = 0u;
    long long v96 = 0u;
    double v98 = v18.f32[0];
    double v99 = v63;
    uint64_t v100 = 0;
    double v101 = (double)v37;
    uint64_t v102 = 0;
    v39 = &v62[6 * a3 - 6];
    double v29 = *v39;
    long long v60 = *(_OWORD *)(v39 + 1);
    CGFloat v38 = v39[3];
    float64x2_t v55 = *(float64x2_t *)(v39 + 4);
  }
  else
  {
    float64x2_t v31 = vcvtq_f64_f32(vmls_lane_f32(vcvt_f32_f64(vcvtq_f64_u64(v28)), v23, v18, 0));
    __asm { FMOV            V1.2D, #0.5 }
    float64x2_t v55 = vmulq_f64(v31, _Q1);
    unint64_t v37 = v28.i64[0];
    CGFloat v38 = v29;
  }
  if (a5 == 1)
  {
    CGColorSpaceRef v61 = CGColorSpaceRetain(space);
    CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(a1);
    v41 = 0;
    if (AlphaInfo) {
      CGBitmapInfo v42 = AlphaInfo;
    }
    else {
      CGBitmapInfo v42 = 5;
    }
    goto LABEL_22;
  }
  if (Model != kCGColorSpaceModelCMYK)
  {
    if (Model == kCGColorSpaceModelMonochrome)
    {
      CGBitmapInfo v42 = !IsOpaque;
      if (IsOpaque) {
        uint64_t v43 = 1;
      }
      else {
        uint64_t v43 = 2;
      }
      if (a5 != 2)
      {
        LOBYTE(v10) = 0;
        v41 = 0;
        CGColorSpaceRef v61 = CGColorSpaceRetain(ColorSpace);
        goto LABEL_62;
      }
      CGColorSpaceRef v61 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
      if ((gIIODebugFlags & 0x8000300000) != 0) {
        ImageIOLog("COL converting to GenericGrayGamma2.2\n");
      }
      v41 = 0;
      goto LABEL_57;
    }
    if (Model != kCGColorSpaceModelRGB || Type == 7)
    {
      v44 = CGColorSpaceRetain(ColorSpace);
      v41 = 0;
    }
    else
    {
      if (a5 == 2)
      {
        if (IIO_CGColorSpaceNameMatchesName(ColorSpace, v11))
        {
          CGColorSpaceRef v61 = CGColorSpaceRetain(space);
          if ((gIIODebugFlags & 0x8000300000) != 0) {
            ImageIOLog("COL original image is sRGB - not converting\n");
          }
        }
        else
        {
          if (!CGImageIsOptimizedForSharing())
          {
            if ((gIIODebugFlags & 0x8000300000) != 0) {
              ImageIOLog("COL image is outside sRGB - trying to use poppy profile\n");
            }
            v41 = IIO_CreateOutputPoppyProfileForImage(0, a1, &v61);
            if (!v61)
            {
              CGColorSpaceRef v61 = CGColorSpaceRetain(space);
              if ((gIIODebugFlags & 0x8000300000) != 0) {
                ImageIOLog("COL failed to create poppy profile - falling back to sRGB\n");
              }
            }
            BOOL v10 = 1;
LABEL_47:
            if (v52 == -1)
            {
              if (IsOpaque) {
                CGBitmapInfo v42 = 6;
              }
              else {
                CGBitmapInfo v42 = 2;
              }
              uint64_t v43 = 4;
              if (!v10)
              {
                LOBYTE(v10) = 0;
                goto LABEL_62;
              }
            }
            else
            {
              if (IsOpaque) {
                CGBitmapInfo v42 = 5;
              }
              else {
                CGBitmapInfo v42 = 1;
              }
              uint64_t v43 = 4;
              if (!v10) {
                goto LABEL_62;
              }
            }
            goto LABEL_57;
          }
          CGColorSpaceRef v50 = CGImageGetColorSpace(a1);
          CGColorSpaceRef v61 = (CGColorSpaceRef)CFRetain(v50);
          if ((gIIODebugFlags & 0x8000300000) != 0) {
            ImageIOLog("COL original image is already poppy - not converting\n");
          }
        }
        v41 = 0;
        BOOL v10 = 0;
        goto LABEL_47;
      }
      v44 = CGColorSpaceRetain(ColorSpace);
      v41 = 0;
      BOOL v10 = 0;
    }
    CGColorSpaceRef v61 = v44;
    goto LABEL_47;
  }
  if (a5 != 2)
  {
    LOBYTE(v10) = 0;
    v41 = 0;
    CGBitmapInfo v42 = 0;
    CGColorSpaceRef v61 = CGColorSpaceRetain(ColorSpace);
LABEL_22:
    uint64_t v43 = 4;
    goto LABEL_62;
  }
  CGColorSpaceRef v61 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBF0]);
  if ((gIIODebugFlags & 0x8000300000) != 0) {
    ImageIOLog("COL converting to GenericCMYK\n");
  }
  v41 = 0;
  CGBitmapInfo v42 = 0;
  uint64_t v43 = 4;
LABEL_57:
  if (a4 == -1)
  {
    if (CGImageGetBitsPerComponent(a1) > 0xF)
    {
      LOBYTE(v10) = 1;
      size_t v13 = 16;
      goto LABEL_62;
    }
    size_t v13 = CGImageGetBitsPerComponent(a1);
  }
  else
  {
    size_t v13 = a4;
  }
  LOBYTE(v10) = 1;
LABEL_62:
  v57.a = v29;
  *(_OWORD *)&v57.b = v60;
  v57.d = v38;
  *(float64x2_t *)&v57.tx = v55;
  v45 = CGImageCreateCopyWithParametersNew(a1, 0, &v57, v37, v30, v13, v13 * v43, v43 * v37 * (v13 >> 3), v61, v42, 1, RenderingIntent, kCGInterpolationDefault, v10);
  char v46 = !v10;
  if (!v45) {
    char v46 = 1;
  }
  if ((v46 & 1) == 0 && v41)
  {
    InputColorSpaceForOutputPoppyProfile = (CGColorSpace *)IIO_CreateInputColorSpaceForOutputPoppyProfile();
    if (InputColorSpaceForOutputPoppyProfile)
    {
      if ((gIIODebugFlags & 0x8000300000) != 0) {
        ImageIOLog("COL created  profile 'Apple Wide Color Sharing Profile'\n");
      }
      CopyWithCGColorSpaceRef ColorSpace = CGImageCreateCopyWithColorSpace(v45, InputColorSpaceForOutputPoppyProfile);
      if (CopyWithColorSpace) {
        CGImageRelease(v45);
      }
      else {
        CopyWithCGColorSpaceRef ColorSpace = v45;
      }
      CGColorSpaceRelease(InputColorSpaceForOutputPoppyProfile);
      v45 = CopyWithColorSpace;
    }
    goto LABEL_75;
  }
  if (v41) {
LABEL_75:
  }
    CFRelease(v41);
LABEL_76:
  if (v61) {
    CGColorSpaceRelease(v61);
  }
  IIOColorSpace::~IIOColorSpace(&v58);
  return v45;
}

void sub_188715A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,CGColorSpaceRef a27)
{
}

CGImage *CGImageCreateByScaling(CGImageRef image, unint64_t a2, size_t a3, CGInterpolationQuality a4)
{
  if (image)
  {
    CGImageGetBitsPerPixel(image);
    CGImageGetBitsPerComponent(image);
    CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
    CGColorSpaceGetModel(ColorSpace);
    CGImageGetImageProvider();
    CGImageGetContentHeadroom();
    CGImageGetBitmapInfo(image);
    CGImageGetWidth(image);
    CGImageGetHeight(image);
  }
  kdebug_trace();
  IIOInitDebugFlags();
  uint64_t v8 = gIIODebugFlags;
  if ((unsigned __int16)gIIODebugFlags >> 14)
  {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateByScaling", 0, 0, -1, 0);
    uint64_t v8 = gIIODebugFlags;
  }
  if ((v8 & 0x400000000) != 0) {
    ImageIOLog("    %s\n", "CGImageCreateByScaling");
  }
  if (!image)
  {
    LogError("CGImageCreateByScaling", 1247, "*** ERROR: image is NULL\n", decode);
LABEL_66:
    CGBitmapInfo v42 = 0;
    goto LABEL_61;
  }
  CFTypeID v9 = CFGetTypeID(image);
  if (v9 != CGImageGetTypeID())
  {
    LogError("CGImageCreateByScaling", 1248, "*** ERROR: image is not a CGImageRef\n");
    goto LABEL_66;
  }
  if (!a2 || !a3)
  {
    _cg_jpeg_mem_term("CGImageCreateByScaling", 1249, "*** ERROR: bad image size: %ld x %ld\n", a2, a3);
    goto LABEL_66;
  }
  BOOL v10 = CGImageGetColorSpace(image);
  if (!v10)
  {
    LogError("CGImageCreateByScaling", 1253, "*** ERROR: cannot get the colorSpace of the input image (%p)\n");
    goto LABEL_66;
  }
  BaseCGColorSpaceRef ColorSpace = v10;
  unint64_t v47 = a2;
  size_t count = a3;
  CGColorSpaceModel Model = CGColorSpaceGetModel(v10);
  unsigned int Width = CGImageGetWidth(image);
  unsigned int Height = CGImageGetHeight(image);
  int BytesPerRow = CGImageGetBytesPerRow(image);
  CGBitmapInfo BitmapInfo = CGImageGetBitmapInfo(image);
  CGImageGetAlphaInfo(image);
  uint64_t ImageProvider = CGImageGetImageProvider();
  int BitsPerComponent = CGImageGetBitsPerComponent(image);
  int BitsPerPixel = CGImageGetBitsPerPixel(image);
  CGColorSpaceGetNumberOfComponents(BaseColorSpace);
  uint64_t v17 = 0;
  if (a4 != kCGInterpolationNone && Model <= kCGColorSpaceModelRGB)
  {
    float32x2_t v18 = (char *)gCrashMessage;
    uint64_t v19 = CGImageGetImageProvider();
    unint64_t v20 = "IP";
    if (!v19) {
      unint64_t v20 = "DP";
    }
    snprintf(v18, 0x200uLL, "ImageIO: CGImageCreateByScaling: srcImage-(%s): w=%d  h=%d  rb=%d  bmi=0x%08x  bpc=%d  bpp=%d  csm=%d    dstW=%d  dstH=%d\n", v20, Width, Height, BytesPerRow, BitmapInfo, BitsPerComponent, BitsPerPixel, Model, v47, count);
    qword_1EB2BF498 = gCrashMessage;
    if (ImageProvider)
    {
      memset(v53, 0, sizeof(v53));
      uint64_t v54 = 0;
      IIODictionary::IIODictionary((IIODictionary *)v53);
      IIODictionary::setObjectForKey(v21, (const void *)*MEMORY[0x1E4F1CFD0], (const __CFString *)*MEMORY[0x1E4F1DD48]);
      uint64_t v17 = CGImageProviderCopyImageBlockSetWithOptions();
      if (v17 && CGImageBlockSetGetCount() == 1 && CGImageBlockSetGetImageBlock())
      {
        CGImageBlockSetGetPixelSize();
        CGImageBlockGetBytesPerRow();
        operator new();
      }
      IIODictionary::~IIODictionary((IIODictionary *)v53);
    }
    else
    {
      if (CGImageGetDataProvider(image))
      {
        CGImageGetBitsPerPixel(image);
        CGImageGetBitsPerComponent(image);
        CGImageGetBytesPerRow(image);
        operator new();
      }
      uint64_t v17 = 0;
    }
    qword_1EB2BF498 = 0;
  }
  *(_OWORD *)v53 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 8);
  if (CGColorSpaceGetType() == 7)
  {
    BaseCGColorSpaceRef ColorSpace = CGColorSpaceGetBaseColorSpace(BaseColorSpace);
    CFRetain(BaseColorSpace);
    int8x8_t v22 = BaseColorSpace;
  }
  else
  {
    int8x8_t v22 = 0;
  }
  float v23 = (float)Width;
  float v24 = (float)v47 / (float)Width;
  float v25 = (float)Height;
  float v26 = (float)count / (float)Height;
  if (v24 >= v26) {
    float v27 = (float)v47 / (float)Width;
  }
  else {
    float v27 = (float)count / (float)Height;
  }
  if ((float)(v27 * v25) > (float)(count + 1) || (float)(v27 * v23) > (float)(v47 + 1))
  {
    if (v24 <= v26) {
      float v27 = (float)v47 / (float)Width;
    }
    else {
      float v27 = (float)count / (float)Height;
    }
  }
  double v29 = v27;
  double v30 = (float)((float)v47 - (float)(v27 * v23)) * 0.5;
  double v31 = (float)((float)count - (float)(v27 * v25)) * 0.5;
  int AlphaInfo = _ImageGetAlphaInfo(image);
  if (!AlphaInfo)
  {
    if (CGColorSpaceGetModel(BaseColorSpace) == kCGColorSpaceModelRGB) {
      int AlphaInfo = 5;
    }
    else {
      int AlphaInfo = 0;
    }
  }
  if (AlphaInfo == 4) {
    int v33 = 2;
  }
  else {
    int v33 = AlphaInfo;
  }
  if (AlphaInfo == 3) {
    CGBitmapInfo v34 = 1;
  }
  else {
    CGBitmapInfo v34 = v33;
  }
  unsigned int v35 = CGImageGetBitsPerComponent(image);
  if (v35 <= 0x10) {
    unsigned int v36 = 16;
  }
  else {
    unsigned int v36 = v35;
  }
  if (v35 <= 8) {
    unint64_t v37 = 8;
  }
  else {
    unint64_t v37 = v36;
  }
  unsigned int MinimalPixelSize = _GetMinimalPixelSize(BaseColorSpace, v37, v34);
  v52.a = v29;
  unint64_t v39 = (MinimalPixelSize * v47 + 7) >> 3;
  *(_OWORD *)&v52.b = *(_OWORD *)v53;
  v52.d = v29;
  v52.tx = v30;
  v52.ty = v31;
  size_t v40 = MinimalPixelSize;
  CGColorRenderingIntent RenderingIntent = CGImageGetRenderingIntent(image);
  CGBitmapInfo v42 = CGImageCreateCopyWithParametersNew(image, 0, &v52, v47, count, v37, v40, v39, BaseColorSpace, v34, 1, RenderingIntent, a4, 0);
  if (v17) {
    CGImageBlockSetRelease();
  }
  if (v22) {
    CGColorSpaceRelease(v22);
  }
  if (v42)
  {
    CGImageGetBitsPerPixel(v42);
    CGImageGetBitsPerComponent(v42);
    uint64_t v43 = CGImageGetColorSpace(v42);
    CGColorSpaceGetModel(v43);
    CGImageGetImageProvider();
    CGImageGetContentHeadroom();
    CGImageGetBitmapInfo(v42);
  }
LABEL_61:
  kdebug_trace();
  return v42;
}

void sub_1887163D4(_Unwind_Exception *a1)
{
  uint64_t v3 = v1;
  MEMORY[0x18C11C0E0](v3, 0x1081C4078C9819ALL);
  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 144));
  _Unwind_Resume(a1);
}

void releaseBuffer(void *a1, void *a2)
{
}

CGImage *CGImageCreateByMatchingToColorSpace(CGImage *a1, CGColorSpace *a2)
{
  kdebug_trace();
  IIOInitDebugFlags();
  uint64_t v4 = gIIODebugFlags;
  if ((unsigned __int16)gIIODebugFlags >> 14)
  {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateByMatchingToColorSpace", 0, 0, -1, 0);
    uint64_t v4 = gIIODebugFlags;
  }
  if ((v4 & 0x400000000) != 0) {
    ImageIOLog("    %s\n", "CGImageCreateByMatchingToColorSpace");
  }
  v5 = 0;
  if (a1 && a2)
  {
    BOOL v6 = IIO_CGColorSpaceNameMatchesName(a2, (const __CFString *)*MEMORY[0x1E4F1DC98]);
    if (v6)
    {
      BOOL v7 = 0;
      size_t BitsPerComponent = 8;
    }
    else
    {
      BOOL v7 = CGColorSpaceUsesExtendedRange(a2);
      size_t BitsPerComponent = 0;
    }
    size_t Width = CGImageGetWidth(a1);
    size_t Height = CGImageGetHeight(a1);
    int AlphaInfo = _ImageGetAlphaInfo(a1);
    if (!AlphaInfo)
    {
      if (CGColorSpaceGetModel(a2) == kCGColorSpaceModelRGB) {
        int AlphaInfo = 5;
      }
      else {
        int AlphaInfo = 0;
      }
    }
    if (AlphaInfo == 3) {
      int v12 = 1;
    }
    else {
      int v12 = AlphaInfo;
    }
    if (v12 == 4) {
      int v13 = 2;
    }
    else {
      int v13 = v12;
    }
    if (v13 == 6)
    {
      if (CGColorSpaceGetModel(a2)) {
        int v13 = 6;
      }
      else {
        int v13 = 0;
      }
    }
    if (!v6) {
      size_t BitsPerComponent = CGImageGetBitsPerComponent(a1);
    }
    uint64_t v14 = 16;
    if (BitsPerComponent > 0x10) {
      uint64_t v14 = BitsPerComponent;
    }
    if (BitsPerComponent <= 8) {
      uint64_t v14 = 8;
    }
    int v15 = v13 | 0x2100;
    if (BitsPerComponent > 0x1F)
    {
      uint64_t v16 = BitsPerComponent;
    }
    else
    {
      int v15 = v13 | 0x1100;
      uint64_t v16 = 16;
    }
    BOOL v17 = !v7;
    if (v7) {
      CGBitmapInfo v18 = v15;
    }
    else {
      CGBitmapInfo v18 = v13;
    }
    if (v17) {
      unint64_t v19 = v14;
    }
    else {
      unint64_t v19 = v16;
    }
    size_t MinimalPixelSize = _GetMinimalPixelSize(a2, v19, v18);
    v23.a = 1.0;
    v23.b = 0.0;
    v23.c = 0.0;
    v23.d = 1.0;
    v23.tx = 0.0;
    v23.ty = 0.0;
    CGColorRenderingIntent RenderingIntent = CGImageGetRenderingIntent(a1);
    v5 = CGImageCreateCopyWithParametersNew(a1, 0, &v23, Width, Height, v19, MinimalPixelSize, (MinimalPixelSize * Width + 7) >> 3, a2, v18, 1, RenderingIntent, kCGInterpolationDefault, 1);
  }
  kdebug_trace();
  return v5;
}

unint64_t alphaProviderGetBytes(_DWORD *a1, _WORD *a2, unint64_t a3)
{
  unint64_t v3 = 0;
  if (a1 && a2 && a3)
  {
    LODWORD(v5) = a1[34];
    BOOL v6 = v5 < 7;
    unsigned int v7 = a1[42];
    if (v7 - 2 > 4) {
      uint64_t v8 = 0;
    }
    else {
      uint64_t v8 = qword_188990348[v7 - 2];
    }
    uint64_t v9 = 0;
    uint64_t v10 = *((void *)a1 + 14);
    if (v5 != 2 && v5 != 4)
    {
      if (v5 == 6) {
        uint64_t v9 = 0;
      }
      else {
        uint64_t v9 = (char)v10;
      }
    }
    uint64_t v11 = 0;
    if (v7 != 2 && v7 != 4)
    {
      if (v7 == 6) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = (char)v10;
      }
    }
    unint64_t v12 = *((void *)a1 + 13);
    uint64_t v13 = *((void *)a1 + 7);
    uint64_t v170 = *((void *)a1 + 14);
    uint64_t v183 = v11;
    size_t count = *((void *)a1 + 16);
    uint64_t v180 = v13;
    if ((v5 - 1) > 6) {
      unsigned int v172 = v13 != 0;
    }
    else {
      unsigned int v172 = (0x4Fu >> (v5 - 1)) | (v13 != 0);
    }
    size_t v173 = *((void *)a1 + 24);
    unint64_t v14 = *((void *)a1 + 15);
    unint64_t v15 = *((void *)a1 + 19);
    unint64_t v175 = *((void *)a1 + 20);
    BOOL v16 = v7 < 8;
    uint64_t v17 = *((void *)a1 + 18);
    int v18 = 2 * (v17 == 4096);
    if (v17 == 0x2000) {
      int v18 = 4;
    }
    if (v12 == 16) {
      v18 ^= 2u;
    }
    if (v12 == 32) {
      v18 ^= 4u;
    }
    unsigned int v171 = v18;
    if (v12 == 32) {
      int v19 = 4;
    }
    else {
      int v19 = 2 * (v12 == 16);
    }
    uint64_t v20 = *((void *)a1 + 22);
    unint64_t v21 = *((void *)a1 + 23);
    if (v20 == 4096) {
      v19 ^= 2u;
    }
    if (v20 == 0x2000) {
      v19 ^= 4u;
    }
    unsigned int v169 = v19;
    if (!*((void *)a1 + 2))
    {
      BOOL v22 = v5 < 7;
      unint64_t v23 = *((void *)a1 + 15);
      int v184 = a1[34];
      unint64_t v5 = *((void *)a1 + 13);
      unint64_t v24 = *((void *)a1 + 23);
      float v25 = malloc_type_calloc(count, 1uLL, 0xD9AB64FAuLL);
      unint64_t v21 = v24;
      unint64_t v12 = v5;
      LOBYTE(v5) = v184;
      unint64_t v14 = v23;
      BOOL v16 = v7 < 8;
      BOOL v6 = v22;
      *((void *)a1 + 2) = v25;
    }
    unint64_t v179 = v15 >> 3;
    if (v180 && !*((void *)a1 + 3))
    {
      BOOL v26 = v6;
      unint64_t v27 = v14;
      unint64_t v28 = v21;
      double v29 = malloc_type_calloc(v173, 1uLL, 0xE253FFC1uLL);
      unint64_t v21 = v28;
      unint64_t v14 = v27;
      BOOL v6 = v26;
      *((void *)a1 + 3) = v29;
    }
    unint64_t v30 = a3;
    unint64_t v31 = a3 / v179 * v179;
    if (a3 == a3 % v179)
    {
      return 0;
    }
    else
    {
      unint64_t v3 = 0;
      unsigned int v32 = 0x54u >> v5;
      unint64_t v33 = v12 >> 3;
      unint64_t v185 = v21 >> 3;
      unint64_t v178 = v14 >> 3;
      if ((v6 & v32) != 0) {
        unint64_t v34 = v12 >> 3;
      }
      else {
        unint64_t v34 = 0;
      }
      unint64_t v168 = v34;
      char v166 = v16 & (0x9Eu >> v7);
      unsigned int v167 = v172 & v16 & (0x9Eu >> v7);
      unint64_t v35 = *(void *)a1;
      unsigned int v36 = a2;
      unint64_t v37 = v175;
      do
      {
        unint64_t v38 = v35 / v37;
        if (v35 / v37 > *((void *)a1 + 12)) {
          break;
        }
        v182 = v36;
        if (!*((void *)a1 + 4)) {
          *((void *)a1 + 4) = CGAccessSessionCreate();
        }
        if (v180 && !*((void *)a1 + 5)) {
          *((void *)a1 + 5) = CGAccessSessionCreate();
        }
        unint64_t v39 = *((void *)a1 + 1);
        if (v38 + 1 < v39)
        {
          CGAccessSessionRewind();
          if (*((void *)a1 + 5)) {
            CGAccessSessionRewind();
          }
          *((void *)a1 + 1) = 0;
LABEL_55:
          while (count == CGAccessSessionGetBytes() && (!v180 || v173 == CGAccessSessionGetBytes()))
          {
            unint64_t v40 = *((void *)a1 + 1) + 1;
            *((void *)a1 + 1) = v40;
            if (v40 > v38)
            {
              if ((v171 & 2) != 0 && count >= 2)
              {
                v41 = (_WORD *)*((void *)a1 + 2);
                if (v41)
                {
                  size_t v42 = count >> 1;
                  do
                  {
                    _WORD *v41 = bswap32((unsigned __int16)*v41) >> 16;
                    ++v41;
                    --v42;
                  }
                  while (v42);
                }
              }
              if (v171 >= 4 && count >= 4)
              {
                uint64_t v43 = (unsigned int *)*((void *)a1 + 2);
                if (v43)
                {
                  size_t v44 = count >> 2;
                  do
                  {
                    *uint64_t v43 = bswap32(*v43);
                    ++v43;
                    --v44;
                  }
                  while (v44);
                }
              }
              goto LABEL_69;
            }
          }
          return v3;
        }
        if (v39 <= v38) {
          goto LABEL_55;
        }
LABEL_69:
        uint64_t v45 = *(void *)a1;
        unint64_t v37 = v175;
        unint64_t v46 = *(void *)a1 % v175;
        unint64_t v47 = v175 - v46;
        if (v30 < v175 - v46) {
          unint64_t v47 = v30;
        }
        unint64_t v48 = v46 % v179;
        if (v46 % v179)
        {
          v47 -= v48;
          *(void *)a1 = v48 + v45;
          v182 = (_WORD *)((char *)v182 + v48);
          v3 += v48;
          v30 -= v48;
          unint64_t v46 = (v48 + v45) % v175;
        }
        unint64_t v49 = v46 / v179;
        unint64_t v50 = v47 / v179 + v49;
        if (v50 >= *((void *)a1 + 11)) {
          unint64_t v51 = *((void *)a1 + 11);
        }
        else {
          unint64_t v51 = v50;
        }
        uint64_t v52 = *((void *)a1 + 2) + v49 * v178;
        if (v180) {
          v53 = (float *)(*((void *)a1 + 3) + v49 * v185);
        }
        else {
          v53 = (float *)(v52 + v9 * v33);
        }
        unint64_t v54 = v51 - v49;
        unint64_t v55 = v52 + v168;
        uint64_t v177 = v51;
        switch(v33)
        {
          case 4uLL:
            int v71 = a1[20];
            if (v167)
            {
              if (v51 != v49)
              {
                uint64_t v72 = 0;
                double v73 = v182;
                do
                {
                  float v74 = *v53;
                  if (v71 == 1)
                  {
                    if (v170)
                    {
                      uint64_t v75 = 0;
                      uint64_t v76 = v170;
                      do
                      {
                        *(float *)&v73[2 * v75 + 2 * v8] = v74 * *(float *)(v55 + 4 * v75);
                        ++v75;
                        --v76;
                      }
                      while (v76);
                    }
                  }
                  else if (v71 == 2)
                  {
                    if (v170)
                    {
                      uint64_t v77 = 0;
                      uint64_t v78 = v170;
                      do
                      {
                        float v79 = *(float *)(v55 + 4 * v77);
                        if (v74 <= v79) {
                          float v80 = 1.0;
                        }
                        else {
                          float v80 = v79 / v74;
                        }
                        *(float *)&v73[2 * v77++ + 2 * v8] = v80;
                        --v78;
                      }
                      while (v78);
                    }
                  }
                  else if (v170)
                  {
                    uint64_t v81 = 0;
                    uint64_t v82 = v170;
                    do
                    {
                      *(_DWORD *)&v73[2 * v81 + 2 * v8] = *(_DWORD *)(v55 + 4 * v81);
                      ++v81;
                      --v82;
                    }
                    while (v82);
                  }
                  *(float *)&v73[2 * v183] = v74;
                  v55 += v178;
                  v53 = (float *)((char *)v53 + v185);
                  double v73 = (_WORD *)((char *)v73 + v179);
                  ++v72;
                }
                while (v72 != v54);
              }
            }
            else if (v172)
            {
              if (v51 != v49)
              {
                uint64_t v95 = 0;
                if (v170) {
                  BOOL v96 = (v71 & 0xFFFFFFFE) == 2;
                }
                else {
                  BOOL v96 = 1;
                }
                char v97 = v96;
                double v98 = v182;
                do
                {
                  if (v71 == 1)
                  {
                    if (v170)
                    {
                      uint64_t v99 = 0;
                      uint64_t v100 = v170;
                      do
                      {
                        *(float *)&v98[2 * v99 + 2 * v8] = *(float *)(v55 + 4 * v99) * *v53;
                        ++v99;
                        --v100;
                      }
                      while (v100);
                    }
                  }
                  else if ((v97 & 1) == 0)
                  {
                    uint64_t v101 = 0;
                    uint64_t v102 = v170;
                    do
                    {
                      *(_DWORD *)&v98[2 * v101 + 2 * v8] = *(_DWORD *)(v55 + 4 * v101);
                      ++v101;
                      --v102;
                    }
                    while (v102);
                  }
                  v55 += v178;
                  v53 = (float *)((char *)v53 + v185);
                  double v98 = (_WORD *)((char *)v98 + v179);
                  ++v95;
                }
                while (v95 != v54);
              }
            }
            else if (v166)
            {
              if (v51 != v49)
              {
                uint64_t v136 = 0;
                v137 = v182;
                do
                {
                  if (v170)
                  {
                    uint64_t v138 = 0;
                    uint64_t v139 = v170;
                    do
                    {
                      *(_DWORD *)&v137[2 * v138 + 2 * v8] = *(_DWORD *)(v55 + 4 * v138);
                      ++v138;
                      --v139;
                    }
                    while (v139);
                  }
                  *(_DWORD *)&v137[2 * v183] = 1065353216;
                  v55 += v178;
                  v137 = (_WORD *)((char *)v137 + v179);
                  ++v136;
                }
                while (v136 != v54);
              }
            }
            else if (v51 != v49)
            {
              uint64_t v148 = 0;
              v149 = v182;
              do
              {
                if (v170)
                {
                  uint64_t v150 = 0;
                  uint64_t v151 = v170;
                  do
                  {
                    *(_DWORD *)&v149[2 * v150 + 2 * v8] = *(_DWORD *)(v55 + 4 * v150);
                    ++v150;
                    --v151;
                  }
                  while (v151);
                }
                v55 += v178;
                v149 = (_WORD *)((char *)v149 + v179);
                ++v148;
              }
              while (v148 != v54);
            }
            break;
          case 2uLL:
            int v83 = a1[20];
            if (v167)
            {
              if (v51 != v49)
              {
                uint64_t v84 = 0;
                double v85 = v182;
                do
                {
                  unsigned int v86 = *(unsigned __int16 *)v53;
                  if (v83 == 1)
                  {
                    if (v170)
                    {
                      uint64_t v87 = 0;
                      uint64_t v88 = v170;
                      do
                      {
                        v85[v87 + v8] = (0xFFFF * (v86 ^ 0xFFFF) + *(unsigned __int16 *)(v55 + 2 * v87) * v86) / 0xFFFF;
                        ++v87;
                        --v88;
                      }
                      while (v88);
                    }
                  }
                  else if (v83 == 2)
                  {
                    if (v170)
                    {
                      uint64_t v89 = 0;
                      uint64_t v90 = v170;
                      do
                      {
                        unsigned int v91 = *(unsigned __int16 *)(v55 + 2 * v89);
                        if (v86 <= v91) {
                          LOWORD(v92) = -1;
                        }
                        else {
                          unsigned int v92 = 0xFFFF * v91 / v86;
                        }
                        v85[v89 + v8] = v92;
                        ++v89;
                        --v90;
                      }
                      while (v90);
                    }
                  }
                  else if (v170)
                  {
                    uint64_t v93 = 0;
                    uint64_t v94 = v170;
                    do
                    {
                      v85[v93 + v8] = *(_WORD *)(v55 + 2 * v93);
                      ++v93;
                      --v94;
                    }
                    while (v94);
                  }
                  v85[v183] = v86;
                  v55 += v178;
                  v53 = (float *)((char *)v53 + v185);
                  double v85 = (_WORD *)((char *)v85 + v179);
                  ++v84;
                }
                while (v84 != v54);
              }
            }
            else if (v172)
            {
              if (v51 != v49)
              {
                uint64_t v103 = 0;
                v104 = v182;
                do
                {
                  switch(v83)
                  {
                    case 1:
                      if (v170)
                      {
                        uint64_t v105 = 0;
                        uint64_t v106 = v170;
                        do
                        {
                          v104[v105 + v8] = (*(unsigned __int16 *)v53 * *(unsigned __int16 *)(v55 + 2 * v105)
                                           - (*(unsigned __int16 *)v53 ^ 0xFFFF)
                                           + ((*(unsigned __int16 *)v53 ^ 0xFFFFu) << 16))
                                          / 0xFFFF;
                          ++v105;
                          --v106;
                        }
                        while (v106);
                      }
                      break;
                    case 2:
                      if (v170)
                      {
                        uint64_t v107 = 0;
                        uint64_t v108 = v170;
                        do
                        {
                          unsigned int v109 = *(unsigned __int16 *)(v55 + 2 * v107);
                          unsigned int v110 = *(unsigned __int16 *)v53;
                          if (v110 <= v109) {
                            LOWORD(v111) = -1;
                          }
                          else {
                            unsigned int v111 = 0xFFFF * v109 / v110;
                          }
                          v104[v107 + v8] = v111;
                          ++v107;
                          --v108;
                        }
                        while (v108);
                      }
                      break;
                    case 3:
                      if (v170)
                      {
                        uint64_t v112 = 0;
                        uint64_t v113 = v170;
                        do
                        {
                          unsigned int v114 = *(unsigned __int16 *)(v55 + 2 * v112);
                          unsigned int v115 = *(unsigned __int16 *)v53;
                          if (v115 <= v114) {
                            int v116 = 0xFFFF;
                          }
                          else {
                            int v116 = (unsigned __int16)(0xFFFF * v114 / v115);
                          }
                          v104[v112 + v8] = v116;
                          v104[v112 + v8] = (*(unsigned __int16 *)v53 * v116
                                           - (*(unsigned __int16 *)v53 ^ 0xFFFF)
                                           + ((*(unsigned __int16 *)v53 ^ 0xFFFFu) << 16))
                                          / 0xFFFF;
                          ++v112;
                          --v113;
                        }
                        while (v113);
                      }
                      break;
                    default:
                      if (v170)
                      {
                        uint64_t v117 = 0;
                        uint64_t v118 = v170;
                        do
                        {
                          v104[v117 + v8] = *(_WORD *)(v55 + 2 * v117);
                          ++v117;
                          --v118;
                        }
                        while (v118);
                      }
                      break;
                  }
                  v55 += v178;
                  v53 = (float *)((char *)v53 + v185);
                  v104 = (_WORD *)((char *)v104 + v179);
                  ++v103;
                }
                while (v103 != v54);
              }
            }
            else if (v166)
            {
              if (v51 != v49)
              {
                uint64_t v140 = 0;
                v141 = v182;
                do
                {
                  if (v170)
                  {
                    uint64_t v142 = 0;
                    uint64_t v143 = v170;
                    do
                    {
                      v141[v142 + v8] = *(_WORD *)(v55 + 2 * v142);
                      ++v142;
                      --v143;
                    }
                    while (v143);
                  }
                  v141[v183] = -1;
                  v55 += v178;
                  v141 = (_WORD *)((char *)v141 + v179);
                  ++v140;
                }
                while (v140 != v54);
              }
            }
            else if (v51 != v49)
            {
              uint64_t v152 = 0;
              v153 = v182;
              do
              {
                if (v170)
                {
                  uint64_t v154 = 0;
                  uint64_t v155 = v170;
                  do
                  {
                    v153[v154 + v8] = *(_WORD *)(v55 + 2 * v154);
                    ++v154;
                    --v155;
                  }
                  while (v155);
                }
                v55 += v178;
                v153 = (_WORD *)((char *)v153 + v179);
                ++v152;
              }
              while (v152 != v54);
            }
            break;
          case 1uLL:
            int v56 = a1[20];
            double v57 = *((double *)a1 + 9) * 255.0;
            int v58 = (int)v57;
            if (v167)
            {
              if (v51 != v49)
              {
                uint64_t v59 = 0;
                long long v60 = v182;
                do
                {
                  uint64_t v61 = *(unsigned __int8 *)v53;
                  if (v56 == 1)
                  {
                    if (v170)
                    {
                      uint64_t v62 = 0;
                      uint64_t v63 = v170;
                      do
                      {
                        *((unsigned char *)v60 + v62 + v8) = (257
                                                    * ((v61 ^ 0xFF) * v58
                                                     + *(unsigned __int8 *)(v55 + v62) * v61)
                                                    + 32896) >> 16;
                        ++v62;
                        --v63;
                      }
                      while (v63);
                    }
                  }
                  else if (v56 == 2)
                  {
                    if (v170)
                    {
                      uint64_t v64 = 0;
                      uint64_t v65 = v170;
                      do
                      {
                        uint64_t v66 = *(unsigned __int8 *)(v55 + v64);
                        int v67 = (int)v57;
                        if (v61 > v66)
                        {
                          unint64_t v68 = (unint64_t)(_inv_alpha[v61] * v66 + 0x8000) >> 16;
                          LOBYTE(v67) = ((255 - v68) >> 31) | v68;
                        }
                        *((unsigned char *)v60 + v64 + v8) = v67;
                        ++v64;
                        --v65;
                      }
                      while (v65);
                    }
                  }
                  else if (v170)
                  {
                    uint64_t v69 = 0;
                    uint64_t v70 = v170;
                    do
                    {
                      *((unsigned char *)v60 + v69 + v8) = *(unsigned char *)(v55 + v69);
                      ++v69;
                      --v70;
                    }
                    while (v70);
                  }
                  *((unsigned char *)v60 + v183) = v61;
                  ++v59;
                  v55 += v178;
                  v53 = (float *)((char *)v53 + v185);
                  long long v60 = (_WORD *)((char *)v60 + v179);
                }
                while (v59 != v54);
              }
            }
            else if (v172)
            {
              if (v51 != v49)
              {
                uint64_t v119 = 0;
                v120 = v182;
                do
                {
                  uint64_t v121 = *(unsigned __int8 *)v53;
                  switch(v56)
                  {
                    case 1:
                      if (v170)
                      {
                        uint64_t v122 = 0;
                        uint64_t v123 = v170;
                        do
                        {
                          *((unsigned char *)v120 + v122 + v8) = (257
                                                        * ((v121 ^ 0xFF) * v58
                                                         + *(unsigned __int8 *)(v55 + v122) * v121)
                                                        + 32896) >> 16;
                          ++v122;
                          --v123;
                        }
                        while (v123);
                      }
                      break;
                    case 2:
                      if (v170)
                      {
                        uint64_t v124 = 0;
                        uint64_t v125 = v170;
                        do
                        {
                          uint64_t v126 = *(unsigned __int8 *)(v55 + v124);
                          int v127 = (int)v57;
                          if (v121 > v126)
                          {
                            unint64_t v128 = (unint64_t)(_inv_alpha[v121] * v126 + 0x8000) >> 16;
                            LOBYTE(v127) = ((255 - v128) >> 31) | v128;
                          }
                          *((unsigned char *)v120 + v124 + v8) = v127;
                          ++v124;
                          --v125;
                        }
                        while (v125);
                      }
                      break;
                    case 3:
                      if (v170)
                      {
                        uint64_t v129 = 0;
                        uint64_t v130 = v170;
                        do
                        {
                          uint64_t v131 = *(unsigned __int8 *)(v55 + v129);
                          int v132 = (int)v57;
                          if (v121 > v131)
                          {
                            unint64_t v133 = _inv_alpha[v121] * v131 + 0x8000;
                            int v132 = (((255 - (v133 >> 16)) >> 31) | BYTE2(v133));
                          }
                          *((unsigned char *)v120 + v129 + v8) = (257
                                                        * ((v121 ^ 0xFF) * v58 + v132 * v121)
                                                        + 32896) >> 16;
                          ++v129;
                          --v130;
                        }
                        while (v130);
                      }
                      break;
                    default:
                      if (v170)
                      {
                        uint64_t v134 = 0;
                        uint64_t v135 = v170;
                        do
                        {
                          *((unsigned char *)v120 + v134 + v8) = *(unsigned char *)(v55 + v134);
                          ++v134;
                          --v135;
                        }
                        while (v135);
                      }
                      break;
                  }
                  ++v119;
                  v55 += v178;
                  v53 = (float *)((char *)v53 + v185);
                  v120 = (_WORD *)((char *)v120 + v179);
                }
                while (v119 != v54);
              }
            }
            else if (v166)
            {
              if (v51 != v49)
              {
                uint64_t v144 = 0;
                v145 = v182;
                do
                {
                  if (v170)
                  {
                    uint64_t v146 = 0;
                    uint64_t v147 = v170;
                    do
                    {
                      *((unsigned char *)v145 + v146 + v8) = *(unsigned char *)(v55 + v146);
                      ++v146;
                      --v147;
                    }
                    while (v147);
                  }
                  *((unsigned char *)v145 + v183) = -1;
                  ++v144;
                  v55 += v178;
                  v145 = (_WORD *)((char *)v145 + v179);
                }
                while (v144 != v54);
              }
            }
            else if (v51 != v49)
            {
              uint64_t v156 = 0;
              v157 = v182;
              do
              {
                if (v170)
                {
                  uint64_t v158 = 0;
                  uint64_t v159 = v170;
                  do
                  {
                    *((unsigned char *)v157 + v158 + v8) = *(unsigned char *)(v55 + v158);
                    ++v158;
                    --v159;
                  }
                  while (v159);
                }
                ++v156;
                v55 += v178;
                v157 = (_WORD *)((char *)v157 + v179);
              }
              while (v156 != v54);
            }
            break;
        }
        unint64_t v160 = v54 * v179;
        if ((v169 & 2) != 0 && v182 && v160 >= 2)
        {
          unint64_t v161 = v160 >> 1;
          v162 = v182;
          do
          {
            _WORD *v162 = bswap32((unsigned __int16)*v162) >> 16;
            ++v162;
            --v161;
          }
          while (v161);
        }
        if (v169 >= 4 && v182 && v160 >= 4)
        {
          unint64_t v163 = v160 >> 2;
          v164 = (unsigned int *)v182;
          do
          {
            unsigned int *v164 = bswap32(*v164);
            ++v164;
            --v163;
          }
          while (v163);
        }
        if (!v160)
        {
          _cg_jpeg_mem_term("alphaProviderGetBytes", 2315, "bytesRead == 0   (startPixel = %ld    stopPixel = %ld)\n", v49, v177);
          return v3;
        }
        unint64_t v35 = *(void *)a1 + v160;
        *(void *)a1 = v35;
        unsigned int v36 = (_WORD *)((char *)v182 + v160);
        v3 += v160;
        v30 -= v160;
      }
      while (v3 < v31);
    }
  }
  return v3;
}

uint64_t alphaProviderSkipForward(void *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  *a1 += a2;
  return a2;
}

void alphaProviderRewind(void *a1)
{
  if (a1)
  {
    if (a1[4]) {
      CGAccessSessionRelease();
    }
    a1[4] = 0;
    if (a1[5]) {
      CGAccessSessionRelease();
    }
    a1[5] = 0;
    uint64_t v2 = (void *)a1[2];
    if (v2) {
      free(v2);
    }
    a1[2] = 0;
    unint64_t v3 = (void *)a1[3];
    if (v3) {
      free(v3);
    }
    a1[3] = 0;
    *a1 = 0;
    a1[1] = 0;
  }
}

void alphaProviderReleaseInfo(void *a1)
{
  if (a1)
  {
    alphaProviderRewind(a1);
    uint64_t v2 = (const void *)a1[6];
    if (v2) {
      CFRelease(v2);
    }
    a1[6] = 0;
    unint64_t v3 = (const void *)a1[7];
    if (v3) {
      CFRelease(v3);
    }
    free(a1);
  }
}

uint64_t CGImageCreateCopyWithBitmapInfo_vImage(CGImageRef image, CGColor *a2, int a3, unint64_t a4, int a5, BOOL a6, unsigned int a7)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if ((gIIODebugFlags & 0x400000000) != 0) {
    ImageIOLog("    %s\n", "CGImageCreateCopyWithBitmapInfo_vImage");
  }
  v16[0] = CGImageGetBitsPerComponent(image);
  v16[1] = a3;
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
  CGColorSpaceRef v17 = ColorSpace;
  int v18 = a5;
  int v19 = 0;
  Decode = CGImageGetDecode(image);
  uint64_t v21 = a7;
  memset(v15, 0, sizeof(v15));
  memset(v22, 0, sizeof(v22));
  if (a2 && (CGColorGetColorSpace(a2), CGColorSpaceEqualToColorSpace()))
  {
    Components = CGColorGetComponents(a2);
  }
  else if (IIO_ConvertCGColorToColorComponents(a2, (uint64_t)ColorSpace))
  {
    Components = (const CGFloat *)v22;
  }
  else
  {
    Components = 0;
  }
  if (MEMORY[0x18C11D770](v15, v16, Components, image, 0)) {
    return 0;
  }
  else {
    return MEMORY[0x18C11DA20](v15, v16, 0, 0, 512, 0);
  }
}

uint64_t CGImageCreateCopyWithAlphaInfo(CGImage *a1, CGColor *a2, int a3)
{
  kdebug_trace();
  IIOInitDebugFlags();
  uint64_t v6 = gIIODebugFlags;
  if ((unsigned __int16)gIIODebugFlags >> 14)
  {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateCopyWithAlphaInfo", 0, 0, -1, 0);
    uint64_t v6 = gIIODebugFlags;
  }
  if ((v6 & 0x400000000) != 0) {
    ImageIOLog("    %s\n", "CGImageCreateCopyWithAlphaInfo");
  }
  CGImageGetWidth(a1);
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(a1);
  size_t BitsPerComponent = CGImageGetBitsPerComponent(a1);
  LODWORD(ColorSpace) = _GetMinimalPixelSize(ColorSpace, BitsPerComponent, a3);
  int v9 = _ImageGetNonAlphaInfo(a1) | a3;
  CGImageGetShouldInterpolate(a1);
  CGColorRenderingIntent RenderingIntent = CGImageGetRenderingIntent(a1);
  uint64_t CopyWithBitmapInfo_vImage = CGImageCreateCopyWithBitmapInfo_vImage(a1, a2, (int)ColorSpace, v11, v9, 0, RenderingIntent);
  kdebug_trace();
  return CopyWithBitmapInfo_vImage;
}

CFDataRef CGImageIOCreateXMPDataFromMetaData(CFDataRef a1)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageIOCreateXMPDataFromMetaData", 0, 0, -1, 0);
  }
  size_t size = 0;
  memset(v4, 0, sizeof(v4));
  IIODictionary::IIODictionary((IIODictionary *)v4);
  if (a1)
  {
    bufferXMPForImageProperties((IIODictionary *)v4, 0, (uint64_t *)&size);
    if ((uint64_t)size >= 1 && (uint64_t v2 = (unsigned __int8 *)malloc_type_malloc(size, 0x100004077774924uLL)) != 0)
    {
      bufferXMPForImageProperties((IIODictionary *)v4, v2, (uint64_t *)&size);
      a1 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v2, size);
      free(v2);
    }
    else
    {
      a1 = 0;
    }
  }
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v4);
  return a1;
}

void sub_188717A00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void bufferXMPForImageProperties(IIODictionary *a1, unsigned __int8 *a2, uint64_t *a3)
{
  unint64_t v5 = 0;
  CFIndex usedBufLen = 0;
  CFIndex v6 = 1;
  if (!a1 || !a3)
  {
LABEL_29:
    if (a2) {
      goto LABEL_35;
    }
    goto LABEL_33;
  }
  if (IIODictionary::containsKey(a1, @"Orientation"))
  {
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(a1, @"Orientation");
  }
  else
  {
    if (!IIODictionary::containsKeyGroup(a1, @"Orientation", @"{TIFF}"))
    {
      if (!IIODictionary::containsKeyGroup(a1, @"Orientation", @"{TIFF}"))
      {
        unint64_t v5 = 0;
        goto LABEL_32;
      }
      unsigned int Uint32ForKey = 0;
      int v9 = 0;
      goto LABEL_11;
    }
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKeyGroup(a1, @"Orientation", @"{TIFF}");
  }
  int v9 = 1;
  if ((IIODictionary::containsKeyGroup(a1, @"Orientation", @"{TIFF}") & 1) == 0)
  {
    int v10 = 0;
    CFDictionaryRef Uint32ForKeyGroup = 0;
    goto LABEL_12;
  }
LABEL_11:
  CFDictionaryRef Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(a1, @"StarRating", @"{IPTC}");
  int v10 = 1;
LABEL_12:
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  unint64_t v5 = Mutable;
  if (!Mutable) {
    goto LABEL_32;
  }
  CFStringAppend(Mutable, @"<x:xmpmeta xmlns:x=\"adobe:ns:meta/\" x:xmptk=\"XMP Core 4.4.0\">\n   <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\">\n");
  if (v9)
  {
    if (Uint32ForKey >= 8) {
      LODWORD(v14) = 8;
    }
    else {
      LODWORD(v14) = Uint32ForKey;
    }
    if (v14 <= 1) {
      uint64_t v14 = 1;
    }
    else {
      uint64_t v14 = v14;
    }
    CFStringRef v15 = CFStringCreateWithFormat(v12, 0, @"      <rdf:Description rdf:about=\"\" xmlns:tiff=\"http://ns.adobe.com/tiff/1.0/\">\n         <tiff:Orientation>%d</tiff:Orientation>\n      </rdf:Description>\n", v14);
    if (!v15) {
      goto LABEL_32;
    }
    CFStringRef v16 = v15;
    CFStringAppend(v5, v15);
    CFRelease(v16);
  }
  if (!v10) {
    goto LABEL_25;
  }
  CFStringRef v17 = CFStringCreateWithFormat(v12, 0, @"      <rdf:Description rdf:about=\"\" xmlns:xmp=\"http://ns.adobe.com/xap/1.0/\">\n         <xmp:Rating>%d</xmp:Rating>\n      </rdf:Description>\n", Uint32ForKeyGroup);
  if (!v17)
  {
LABEL_32:
    CFIndex v6 = 1;
    if (a2) {
      goto LABEL_35;
    }
LABEL_33:
    if (a3) {
      *a3 = v6;
    }
LABEL_35:
    if (!v5) {
      return;
    }
    goto LABEL_36;
  }
  CFStringRef v18 = v17;
  CFStringAppend(v5, v17);
  CFRelease(v18);
LABEL_25:
  CFStringAppend(v5, @"   </rdf:RDF>\n</x:xmpmeta>");
  if (!a2)
  {
    CFIndex usedBufLen = CFStringGetLength(v5);
    CFIndex v6 = usedBufLen + 1;
    goto LABEL_29;
  }
  v20.length = *a3;
  v20.location = 0;
  CFStringGetBytes(v5, v20, 0x8000100u, 0, 0, a2, *a3, &usedBufLen);
  if (usedBufLen < *a3) {
    a2[usedBufLen] = 0;
  }
LABEL_36:
  CFRelease(v5);
}

CFDataRef CGImageCopyJPEGData(CGImage *a1)
{
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCopyJPEGData", 0, 0, -1, 0);
  }

  return CGImageCopySourceData(a1, @"public.jpeg");
}

CFDataRef CGImageCopySourceData(CGImage *a1, const __CFString *a2)
{
  if (!a1) {
    return 0;
  }
  CFStringRef Property = (const __CFString *)CGImageGetProperty();
  if (!Property) {
    return 0;
  }
  Mutable = 0;
  if (CFEqual(Property, a2))
  {
    if (!CGImageGetProperty())
    {
LABEL_8:
      CFDataRef v9 = (const __CFData *)CGImageGetProperty();
      *(void *)buffer = 0;
      if (v9)
      {
        v13.location = 0;
        v13.length = 8;
        CFDataGetBytes(v9, v13, buffer);
        if (*(void *)buffer)
        {
          Source = (IIOImageRead *)CGImageSourceGetSource(*(uint64_t *)buffer);
          if (Source) {
            return IIOImageRead::copyData(Source);
          }
        }
      }
      return 0;
    }
    Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    CFIndex v6 = CGImageDestinationCreateWithData(Mutable, a2, 1uLL, 0);
    if (!v6
      || (v7 = v6, CGImageDestinationAddImage(v6, a1, 0), BOOL v8 = CGImageDestinationFinalize(v7), CFRelease(v7), !v8))
    {
      CFRelease(Mutable);
      goto LABEL_8;
    }
  }
  return Mutable;
}

CFDataRef CGImageCopyJPEGDataAndColorSpace(CGImage *a1, CGColorSpaceRef *a2)
{
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCopyJPEGDataAndColorSpace", 0, 0, -1, 0);
  }
  CFDataRef v4 = CGImageCopySourceData(a1, @"public.jpeg");
  if (v4)
  {
    if (!a2) {
      return v4;
    }
  }
  else
  {
    CFDataRef v4 = CGImageCopySourceData(a1, @"public.jpeg-2000");
    if (!a2) {
      return v4;
    }
  }
  *a2 = 0;
  if (!v4) {
    return v4;
  }
  *(void *)buffer = 0;
  CFDataRef Property = (const __CFData *)CGImageGetProperty();
  if (Property)
  {
    v42.location = 0;
    v42.length = 8;
    CFDataGetBytes(Property, v42, buffer);
    if (*(void *)buffer)
    {
      Properties = (IIODictionary *)IIOImagePlus::getProperties(*(IIOImagePlus **)(*(void *)buffer + 24));
      if (Properties)
      {
        unsigned int v7 = Properties;
        if (IIODictionary::containsKeyGroup(Properties, @"Gamma", @"{Exif}"))
        {
          if (IIODictionary::containsKeyGroup(v7, @"WhitePoint", @"{TIFF}")
            && IIODictionary::containsKeyGroup(v7, @"PrimaryChromaticities", @"{TIFF}"))
          {
            double FloatForKeyGroup = IIODictionary::getFloatForKeyGroup(v7, @"Gamma", @"{Exif}");
            float v36 = *(float *)&FloatForKeyGroup;
            CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(v7, @"WhitePoint", @"{TIFF}");
            memset(v40, 0, sizeof(v40));
            IIOArray::IIOArray((IIOArray *)v40, ObjectForKeyGroup);
            float FloatAtIndex = IIOArray::getFloatAtIndex((IIOArray *)v40, 0);
            float v11 = IIOArray::getFloatAtIndex((IIOArray *)v40, 1);
            CFDictionaryRef v12 = IIODictionary::getObjectForKeyGroup(v7, @"PrimaryChromaticities", @"{TIFF}");
            memset(v39, 0, sizeof(v39));
            IIOArray::IIOArray((IIOArray *)v39, v12);
            float v13 = IIOArray::getFloatAtIndex((IIOArray *)v39, 0);
            float v14 = IIOArray::getFloatAtIndex((IIOArray *)v39, 1);
            float v15 = IIOArray::getFloatAtIndex((IIOArray *)v39, 2);
            float v16 = IIOArray::getFloatAtIndex((IIOArray *)v39, 3);
            float v17 = IIOArray::getFloatAtIndex((IIOArray *)v39, 4);
            float v18 = IIOArray::getFloatAtIndex((IIOArray *)v39, 5);
            if (IIOChromaticitiesMatchAdobeRGB(FloatAtIndex, v11, v13, v14, v15, v16, v17, v18, v36))
            {
              int v19 = (CFStringRef *)MEMORY[0x1E4F1DB78];
            }
            else if (IIOChromaticitiesMatchSRGB(FloatAtIndex, v11, v13, v14, v15, v16, v17, v18, v37))
            {
              int v19 = (CFStringRef *)MEMORY[0x1E4F1DC98];
            }
            else
            {
              if (!IIOChromaticitiesMatchLinearSRGB(FloatAtIndex, v11, v13, v14, v15, v16, v17, v18, v38))
              {
LABEL_21:
                IIOArray::~IIOArray((IIOArray *)v39);
                IIOArray::~IIOArray((IIOArray *)v40);
                goto LABEL_22;
              }
              int v19 = (CFStringRef *)MEMORY[0x1E4F1DC88];
            }
            *a2 = CGColorSpaceCreateWithName(*v19);
            goto LABEL_21;
          }
        }
      }
    }
  }
LABEL_22:
  if (!*a2)
  {
    BytePtr = CFDataGetBytePtr(v4);
    unint64_t Length = CFDataGetLength(v4);
    if (Length >= 4 && *BytePtr == 255 && BytePtr[1] == 216 && Length >= 7)
    {
      unsigned int v22 = __rev16(*((unsigned __int16 *)BytePtr + 1));
      if (v22 != 65498)
      {
        unsigned int v23 = __rev16(*((unsigned __int16 *)BytePtr + 2));
        uint64_t v24 = 4;
        if (v22 == 65506)
        {
          uint64_t v25 = 6;
LABEL_36:
          if (v23 >= 0x11
            && v24 + (unint64_t)v23 < Length
            && !strncmp((const char *)&BytePtr[v25], "ICC_PROFILE", 0xBuLL)
            && v23 != 16)
          {
            CFDataRef v31 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &BytePtr[v24 + 16], v23 - 16);
            if (v31)
            {
              CFDataRef v32 = v31;
              unint64_t v33 = (CGColorSpace *)MEMORY[0x18C11AC10]();
              CGColorSpaceRef ColorSpace = CGImageGetColorSpace(a1);
              CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
              if (Model == CGColorSpaceGetModel(v33)) {
                *a2 = v33;
              }
              else {
                CGColorSpaceRelease(v33);
              }
              CFRelease(v32);
            }
          }
        }
        else
        {
          while (1)
          {
            uint64_t v26 = v24 + v23;
            uint64_t v24 = v26 + 2;
            if (v26 + 2 >= Length) {
              break;
            }
            unsigned int v27 = __rev16(*(unsigned __int16 *)&BytePtr[v26]);
            uint64_t v25 = v26 + 4;
            if (v26 + 4 >= Length || v27 == 65498) {
              break;
            }
            unsigned int v23 = BytePtr[v26 + 3] | (BytePtr[v24] << 8);
            if (v27 == 65506) {
              goto LABEL_36;
            }
          }
        }
      }
    }
  }
  return v4;
}

void sub_1887182CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

CGImageRef CreateImageFromMask(CGImage *a1)
{
  uint64_t v2 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
  if (CGImageGetBitsPerComponent(a1) != 8) {
    goto LABEL_17;
  }
  DataProvider = CGImageGetDataProvider(a1);
  if (!DataProvider) {
    goto LABEL_17;
  }
  CFDataRef v4 = CGDataProviderCopyData(DataProvider);
  if (!v4) {
    goto LABEL_17;
  }
  CFDataRef v5 = v4;
  BytePtr = CFDataGetBytePtr(v4);
  size_t Width = CGImageGetWidth(a1);
  size_t Height = CGImageGetHeight(a1);
  size_t BytesPerRow = CGImageGetBytesPerRow(a1);
  if (CFDataGetLength(v5) < BytesPerRow * Height
    || (size_t v10 = 2 * BytesPerRow, (v11 = (UInt8 *)malloc_type_calloc(2 * BytesPerRow, Height, 0x8186A6B4uLL)) == 0))
  {
    CFRelease(v5);
LABEL_17:
    CGImageRef v24 = 0;
    goto LABEL_18;
  }
  CFDictionaryRef v12 = v11;
  memcpy(v11, BytePtr, BytesPerRow * Height);
  CFRelease(v5);
  uint64_t v13 = Height - 1;
  if ((uint64_t)(Height - 1) >= 0)
  {
    float v14 = &v12[BytesPerRow * v13];
    uint64_t v15 = (uint64_t)&v12[2 * BytesPerRow * v13 - 1 + 2 * Width];
    do
    {
      if (((Width - 1) & 0x8000000000000000) == 0)
      {
        float v16 = (unsigned char *)v15;
        size_t v17 = Width;
        do
        {
          UInt8 v18 = v14[v17 - 1];
          *(v16 - 1) = 0;
          *float v16 = v18;
          v16 -= 2;
          --v17;
        }
        while (v17);
      }
      v14 -= BytesPerRow;
      v15 -= 2 * BytesPerRow;
    }
    while (v13-- >= 1);
  }
  CFDataRef v20 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v12, v10 * Height);
  if (v20)
  {
    CFDataRef v21 = v20;
    unsigned int v22 = CGDataProviderCreateWithCFData(v20);
    if (v22)
    {
      unsigned int v23 = v22;
      CGImageRef v24 = CGImageCreate(Width, Height, 8uLL, 0x10uLL, v10, v2, 3u, v22, 0, 1, kCGRenderingIntentDefault);
      CGImageSetProperty();
      CGImageSetProperty();
      CGDataProviderRelease(v23);
    }
    else
    {
      CGImageRef v24 = 0;
    }
    CFRelease(v21);
  }
  else
  {
    CGImageRef v24 = 0;
  }
  free(v12);
LABEL_18:
  CGColorSpaceRelease(v2);
  return v24;
}

CGImageRef Create1BitImageFromImageRefWithOrientation(CGImage *a1, int a2, unsigned int a3)
{
  CFIndex v6 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
  size_t Width = CGImageGetWidth(a1);
  size_t Height = CGImageGetHeight(a1);
  unint64_t v9 = Height;
  CGFloat v10 = 1.0;
  CGFloat v11 = 0.0;
  switch(a2)
  {
    case 2:
      double v12 = (double)Width;
      CGFloat v10 = -1.0;
      double v13 = 0.0;
      goto LABEL_4;
    case 3:
      double v12 = (double)Width;
      double v13 = (double)Height;
      CGFloat v14 = -1.0;
      CGFloat v15 = 0.0;
      CGFloat v10 = -1.0;
      break;
    case 4:
      double v13 = (double)Height;
      CGFloat v14 = -1.0;
      double v12 = 0.0;
      goto LABEL_7;
    case 5:
      double v12 = (double)Height;
      double v13 = (double)Width;
      CGFloat v11 = -1.0;
      CGFloat v14 = 0.0;
      CGFloat v15 = -1.0;
      goto LABEL_13;
    case 6:
      double v13 = (double)Width;
      CGFloat v15 = -1.0;
      CGFloat v11 = 1.0;
      double v12 = 0.0;
      goto LABEL_12;
    case 7:
      CGFloat v11 = 1.0;
      double v13 = 0.0;
      double v12 = 0.0;
      CGFloat v14 = 0.0;
      CGFloat v15 = 1.0;
      goto LABEL_13;
    case 8:
      double v12 = (double)Height;
      CGFloat v15 = 1.0;
      CGFloat v11 = -1.0;
      double v13 = 0.0;
LABEL_12:
      CGFloat v14 = 0.0;
LABEL_13:
      CGFloat v10 = 0.0;
      break;
    default:
      double v13 = 0.0;
      double v12 = 0.0;
LABEL_4:
      CGFloat v14 = 1.0;
LABEL_7:
      CGFloat v15 = 0.0;
      break;
  }
  if (a2 >= 5) {
    size_t v16 = Width;
  }
  else {
    size_t v16 = Height;
  }
  if (a2 >= 5) {
    size_t v17 = Height;
  }
  else {
    size_t v17 = Width;
  }
  UInt8 v18 = (char *)malloc_type_calloc(v17, v16, 0xA908F5DuLL);
  int v19 = CGBitmapContextCreate(v18, v17, v16, 8uLL, v17, v6, 0);
  if (!v19) {
    _cg_jpeg_mem_term("Create1BitImageFromImageRefWithOrientation", 3175, "*** ERROR: CGBitmapContextCreate returned NULL\n");
  }
  v33.size.width = (double)v17;
  v33.size.height = (double)v16;
  v33.origin.x = 0.0;
  v33.origin.y = 0.0;
  CGContextClearRect(v19, v33);
  transform.a = v10;
  transform.b = v15;
  transform.c = v11;
  transform.d = v14;
  transform.tx = v12;
  transform.ty = v13;
  CGContextConcatCTM(v19, &transform);
  v34.size.width = (double)Width;
  v34.size.height = (double)v9;
  v34.origin.x = 0.0;
  v34.origin.y = 0.0;
  CGContextDrawImage(v19, v34, a1);
  size_t v20 = (v17 + 7) >> 3;
  CFDataRef v21 = (char *)malloc_type_calloc(v20, v16, 0xB7165300uLL);
  if (v16)
  {
    for (uint64_t i = 0; i != v16; ++i)
    {
      if (v17)
      {
        int v23 = 0;
        CGImageRef v24 = &v18[i * v17];
        unsigned __int8 v25 = 0x80;
        size_t v26 = v17;
        unsigned int v27 = &v21[i * v20];
        do
        {
          if (v23 == 8)
          {
            ++v27;
            unsigned __int8 v25 = 0x80;
          }
          unsigned int v28 = *v24++;
          if (v28 > a3) {
            *v27 |= v25;
          }
          v25 >>= 1;
          if (v23 == 8) {
            int v23 = 1;
          }
          else {
            ++v23;
          }
          --v26;
        }
        while (v26);
      }
    }
  }
  double v29 = CGDataProviderCreateWithData(v21, v21, v20 * v16, (CGDataProviderReleaseDataCallback)_CGDataProviderReleaseDataCallback);
  CGImageRef v30 = CGImageCreate(v17, v16, 1uLL, 1uLL, (v17 + 7) >> 3, v6, 0, v29, 0, 0, kCGRenderingIntentDefault);
  CGImageSetProperty();
  CGImageSetProperty();
  CGDataProviderRelease(v29);
  CGContextRelease(v19);
  CGColorSpaceRelease(v6);
  if (v18) {
    free(v18);
  }
  return v30;
}

void _CGDataProviderReleaseDataCallback(void *a1, const void *a2)
{
  if (a1) {
    free(a1);
  }
}

BOOL CGImageIsInsideSRGB(void *a1)
{
  if (!a1)
  {
    LogError("CGImageIsInsideSRGB", 3285, "*** ERROR: CGImageIsInsideSRGB: image is nil\n");
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CGImageGetTypeID())
  {
    LogError("CGImageIsInsideSRGB", 3286, "*** ERROR: CGImageIsInsideSRGB: image is not a CGImageRef\n");
    return 0;
  }

  return CGImageIsInside_sRGB((CGImage *)a1);
}

BOOL CGImageIsInside_sRGB(CGImage *a1)
{
  unint64_t Width = CGImageGetWidth(a1);
  unint64_t Height = CGImageGetHeight(a1);
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(a1);
  double Current = CFAbsoluteTimeGetCurrent();
  if ((gIIODebugFlags & 0x400000000) != 0) {
    ImageIOLog("    %s\n", "CGImageIsInside_sRGB");
  }
  uint64_t Property = CGImageGetProperty();
  if (Property) {
    return Property == *MEMORY[0x1E4F1CFD0];
  }
  if (!IIO_CGColorSpaceNameMatchesName(ColorSpace, (const __CFString *)*MEMORY[0x1E4F1DC98]))
  {
    if (IIO_CGColorSpaceNameMatchesName(ColorSpace, (const __CFString *)*MEMORY[0x1E4F1DB90])
      || CGColorSpaceIsWideGamutRGB(ColorSpace))
    {
      CFStringRef v8 = (const __CFString *)*MEMORY[0x1E4F1DBE8];
      CGColorSpaceRef v19 = (CGColorSpaceRef)&unk_1ED4DFD58;
      CGColorSpaceRef space = CGColorSpaceCreateWithName(v8);
      unint64_t v9 = malloc_type_calloc(Height, 8 * Width, 0x8097B48BuLL);
      CGFloat v10 = CGBitmapContextCreate(v9, Width, Height, 0x10uLL, 8 * Width, space, 0x1105u);
      if (v10)
      {
        CGContextClear();
        v21.size.width = (double)Width;
        v21.size.height = (double)Height;
        v21.origin.x = 0.0;
        v21.origin.y = 0.0;
        CGContextDrawImage(v10, v21, a1);
        v18.data = v9;
        v18.height = Height;
        v18.width = Width;
        v18.rowBytes = 8 * Width;
        uint64_t v7 = FP16DataInZeroToOneRange(&v18);
        CGContextRelease(v10);
      }
      else
      {
        uint64_t v7 = 1;
      }
      free(v9);
      IIOColorSpace::~IIOColorSpace(&v19);
      goto LABEL_13;
    }
    if (IIO_CGColorSpaceNameMatchesName(ColorSpace, (const __CFString *)*MEMORY[0x1E4F1DBE8]))
    {
      if (CGImageGetImageProvider())
      {
        uint64_t v13 = CGImageProviderCopyImageBlockSetWithOptions();
        if (v13)
        {
          if (CGImageBlockSetGetCount())
          {
            CGImageBlockSetGetImageBlock();
            Data = (void *)CGImageBlockGetData();
            size_t BytesPerRow = CGImageBlockGetBytesPerRow();
            CGImageBlockGetRect();
            if (Data)
            {
              CGDataProviderRef DataProvider = 0;
              goto LABEL_27;
            }
          }
        }
      }
      else
      {
        uint64_t v13 = 0;
      }
      CGDataProviderRef DataProvider = CGImageGetDataProvider(a1);
      Data = (void *)CGDataProviderRetainBytePtr();
      if (!Data) {
        _cg_jpeg_mem_term("CGImageIsInside_sRGB", 3391, "*** CGDataProviderRetainBytePtr returned NULL\n");
      }
      CGDataProviderGetSizeOfData();
      size_t v17 = CGImageGetBytesPerRow(a1);
      if (!Data)
      {
        uint64_t v7 = 1;
        goto LABEL_29;
      }
      size_t BytesPerRow = v17;
LABEL_27:
      v18.data = Data;
      v18.height = Height;
      v18.width = Width;
      v18.rowBytes = BytesPerRow;
      uint64_t v7 = FP16DataInZeroToOneRange(&v18);
LABEL_29:
      if (v13) {
        CGImageBlockSetRelease();
      }
      if (DataProvider) {
        CGDataProviderReleaseBytePtr();
      }
      goto LABEL_13;
    }
  }
  uint64_t v7 = 1;
LABEL_13:
  if ((gIIODebugFlags & 0x20000000000) != 0)
  {
    CFAbsoluteTime v11 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("    CGImageIsInside_sRGB - %g ms\n", (v11 - Current) * 1000.0);
  }
  return v7;
}

void sub_188718C58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)va);
  _Unwind_Resume(a1);
}

uint64_t FP16DataInZeroToOneRange(vImage_Buffer *a1)
{
  if (!a1) {
    return 1;
  }
  data = (char *)a1->data;
  if (!a1->data) {
    return 1;
  }
  vImagePixelCount height = a1->height;
  if (!height) {
    return 1;
  }
  uint64_t v3 = 0;
  vImagePixelCount width = a1->width;
  size_t rowBytes = a1->rowBytes;
  uint64_t result = 1;
  do
  {
    if (width)
    {
      uint64_t v7 = 0;
      CFStringRef v8 = &data[rowBytes * v3];
      while (2)
      {
        for (uint64_t i = 0; i != 6; i += 2)
        {
          _H2 = *(_WORD *)&v8[i];
          __asm { FCVT            D2, H2 }
          if (_D2 > 1.003 || _D2 < -0.025)
          {
            if ((gIIODebugFlags & 0x8000300000) != 0) {
              ImageIOLog("COL FP16DataInZeroToOneRange: outSide [0..1] range at: [%d,%d] value: %g\n", v7, v3, _D2);
            }
            return 0;
          }
        }
        v8 += 8;
        if (++v7 != width) {
          continue;
        }
        break;
      }
    }
    ++v3;
  }
  while (v3 != height);
  return result;
}

uint64_t IIOImageCreateWithImageAndMaskInterleaved(CGImage *a1, IIODictionary *a2)
{
  memset(&dest, 0, sizeof(dest));
  memset(&newSrc, 0, sizeof(newSrc));
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  uint64_t Mask = CGImageGetMask();
  if (!Mask) {
    return 0;
  }
  CFDataRef v4 = (CGImage *)Mask;
  int BitsPerComponent = CGImageGetBitsPerComponent(a1);
  if (BitsPerComponent != 8) {
    _cg_jpeg_mem_term("IIOImageCreateWithImageAndMaskInterleaved", 3453, "*** NOTE: CGImage with mask will be converted from %dbpc to 8bpc\n", BitsPerComponent);
  }
  LODWORD(v15) = 3;
  v14[1] = CGImageGetColorSpace(a1);
  v14[0] = 0x2000000008;
  uint64_t v6 = MEMORY[0x18C11D770](&dest, v14, 0, a1, 0);
  uint64_t v7 = 0;
  vImage_Error v10 = v6;
  if (!v6)
  {
    *(void *)&long long v11 = __PAIR64__(v14[0], v14[0]);
    *((void *)&v11 + 1) = CGImageGetColorSpace(v4);
    LODWORD(v12) = 0;
    uint64_t v7 = 0;
    vImage_Error v10 = MEMORY[0x18C11D770](&newSrc, &v11, 0, v4, 0);
    if (!v10)
    {
      vImage_Error v8 = vImageOverwriteChannels_ARGB8888(&newSrc, &dest, &dest, 1u, 0x10u);
      if (v8 << 32) {
        _cg_jpeg_mem_term("IIOImageCreateWithImageAndMaskInterleaved", 3477, "*** ERROR: vImageOverwriteChannels_ARGB8888 failed - err= %d\n", v8);
      }
      vImage_Error v10 = vImageClipToAlpha_RGBA8888(&dest, &dest, 0x10u);
      uint64_t v7 = MEMORY[0x18C11DA20](&dest, v14, 0, 0, 0, &v10);
    }
  }
  if (dest.data) {
    free(dest.data);
  }
  if (newSrc.data) {
    free(newSrc.data);
  }
  return v7;
}

void GlobalPNGInfo::GlobalPNGInfo(GlobalPNGInfo *this)
{
  *(void *)this = &unk_1ED4DFBD0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 80), 0);
  *((void *)this + 8) = 0;
  *((unsigned char *)this + 72) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 14) = 0;
}

void sub_188718F64(_Unwind_Exception *exception_object)
{
  uint64_t v3 = v2;
  CFDataRef v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 16) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void GlobalPNGInfo::GlobalPNGInfo(GlobalPNGInfo *this, unsigned __int8 *a2, CFIndex a3)
{
  *(void *)this = &unk_1ED4DFBD0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 80), 0);
  *((void *)this + 8) = 0;
  uint64_t v6 = CFReadStreamCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  uint64_t v7 = v6;
  if (v6)
  {
    if (CFReadStreamOpen(v6))
    {
      GlobalPNGInfo::readFromStream((UInt8 *)this, v7);
      CFReadStreamClose(v7);
    }
    CFRelease(v7);
  }
}

void sub_188719048(_Unwind_Exception *exception_object)
{
  CFDataRef v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t GlobalPNGInfo::readFromStream(UInt8 *this, CFReadStreamRef stream)
{
  *(void *)CGColorSpaceRef v19 = 0;
  uint64_t v20 = 0;
  *(void *)vImage_Buffer v18 = 0;
  *(_DWORD *)buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) != 4) {
    return 4294967260;
  }
  if (*(_DWORD *)buffer != 1112493127) {
    return 0;
  }
  if (CFReadStreamRead(stream, this + 32, 28) != 28) {
    return 4294967260;
  }
  CFIndex v4 = CFReadStreamRead(stream, v18, 8);
  uint64_t result = 4294967260;
  if (v4 == 8 && *(uint64_t *)v18 >= 1)
  {
    CFIndex v6 = CFReadStreamRead(stream, v19, 8);
    uint64_t result = 4294967260;
    if (v6 == 8 && (*(void *)v19 & 0x8000000000000000) == 0)
    {
      CFIndex v7 = CFReadStreamRead(stream, (UInt8 *)&v20, 8);
      uint64_t result = 4294967260;
      if (v7 == 8
        && v20 >= 1
        && !__CFADD__(*(void *)v19, v20)
        && (unint64_t)(*(void *)v19 + v20) <= *(void *)v18)
      {
        std::vector<fcTL_CHUNK>::resize((uint64_t)(this + 8), *(unint64_t *)v18);
        if (v20 >= 1)
        {
          unint64_t v8 = *((void *)this + 1) + 34 * *(void *)v19;
          unint64_t v9 = v8 + 34 * v20;
          do
          {
            __int16 v16 = 0;
            *(_OWORD *)size_t size = 0u;
            long long v15 = 0u;
            if (CFReadStreamRead(stream, (UInt8 *)size, 34) != 34) {
              return 4294967260;
            }
            if ((size[1] & 0x8000000000000000) == 0
              && (v15 & 0x80000000) == 0
              && SHIDWORD(size[0]) >= 1
              && SLODWORD(size[1]) >= 1
              && HIDWORD(size[0]) + HIDWORD(size[1]) <= *((_DWORD *)this + 8)
              && LODWORD(size[1]) + (int)v15 <= *((_DWORD *)this + 9))
            {
              long long v10 = *(_OWORD *)size;
              long long v11 = v15;
              *(_WORD *)(v8 + 32) = v16;
              *(_OWORD *)unint64_t v8 = v10;
              *(_OWORD *)(v8 + 16) = v11;
              v8 += 34;
            }
          }
          while (v8 < v9);
        }
        if (CFReadStreamRead(stream, buffer, 4) == 4)
        {
          if (*(_DWORD *)buffer != 1179992675) {
            return 0;
          }
          size[0] = 0;
          if (CFReadStreamRead(stream, (UInt8 *)size, 8) == 8)
          {
            if (!size[0]) {
              return 0;
            }
            if (size[0] != *((_DWORD *)this + 12)) {
              return 0;
            }
            long long v12 = (UInt8 *)malloc_type_malloc(size[0], 0xBD7E960uLL);
            *((void *)this + 8) = v12;
            CFIndex v13 = CFReadStreamRead(stream, v12, size[0]);
            if (v13 == size[0]) {
              return 0;
            }
          }
        }
        return 4294967260;
      }
    }
  }
  return result;
}

void GlobalPNGInfo::~GlobalPNGInfo(GlobalPNGInfo *this)
{
  *(void *)this = &unk_1ED4DFBD0;
  CFTypeID v2 = (void *)*((void *)this + 8);
  if (v2 && *((unsigned char *)this + 72)) {
    free(v2);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 80));
  uint64_t v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
}

{
  uint64_t vars8;

  GlobalPNGInfo::~GlobalPNGInfo(this);

  JUMPOUT(0x18C11C0E0);
}

CFTypeRef GlobalPNGInfo::createDataRepresentation(GlobalPNGInfo *this, const CFRange *a2)
{
  CFIndex v4 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  if (!v4) {
    return 0;
  }
  CFDataRef v5 = v4;
  if (CFWriteStreamOpen(v4))
  {
    GlobalPNGInfo::writeToStream(this, v5, a2);
    CFTypeRef v6 = CFWriteStreamCopyProperty(v5, (CFStreamPropertyKey)*MEMORY[0x1E4F1D440]);
    CFWriteStreamClose(v5);
  }
  else
  {
    CFTypeRef v6 = 0;
  }
  CFRelease(v5);
  return v6;
}

uint64_t GlobalPNGInfo::writeToStream(GlobalPNGInfo *this, CFWriteStreamRef stream, const CFRange *a3)
{
  p_CFIndex length = &a3->length;
  if (a3->location + a3->length > 0xF0F0F0F0F0F0F0F1
                                 * ((uint64_t)(*((void *)this + 2) - *((void *)this + 1)) >> 1))
    return 4294967246;
  *(_DWORD *)buffer = 1112493127;
  CFWriteStreamWrite(stream, buffer, 4);
  CFWriteStreamWrite(stream, (const UInt8 *)this + 32, 28);
  *(void *)long long v12 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((void *)this + 2) - *((void *)this + 1)) >> 1);
  CFWriteStreamWrite(stream, v12, 8);
  CFWriteStreamWrite(stream, (const UInt8 *)a3, 8);
  CFWriteStreamWrite(stream, (const UInt8 *)p_length, 8);
  CFIndex length = a3->length;
  if (length >= 1)
  {
    unint64_t v9 = (const UInt8 *)(*((void *)this + 1) + 34 * a3->location);
    long long v10 = &v9[34 * length];
    do
    {
      CFWriteStreamWrite(stream, v9, 34);
      v9 += 34;
    }
    while (v9 < v10);
  }
  *(_DWORD *)buffer = 1179992675;
  CFWriteStreamWrite(stream, buffer, 4);
  *(void *)long long v11 = *((unsigned int *)this + 12);
  if (*(_DWORD *)v11 && !*((void *)this + 8)) {
    *(void *)long long v11 = 0;
  }
  CFWriteStreamWrite(stream, v11, 8);
  if (*(void *)v11) {
    CFWriteStreamWrite(stream, *((const UInt8 **)this + 8), *(CFIndex *)v11);
  }
  return 0;
}

void std::vector<fcTL_CHUNK>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 1);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<fcTL_CHUNK>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(void *)(a1 + 8) = *(void *)a1 + 34 * a2;
  }
}

uint64_t GlobalPNGInfo::currentBuffer(GlobalPNGInfo *this, unsigned int *a2)
{
  unint64_t v4 = (pthread_mutex_t *)((char *)this + 80);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 80));
  uint64_t v5 = *((void *)this + 8);
  if (a2) {
    *a2 = *((_DWORD *)this + 12);
  }
  pthread_mutex_unlock(v4);
  return v5;
}

uint64_t GlobalPNGInfo::setCurrentBuffer(GlobalPNGInfo *this, unsigned __int8 *a2, int a3, char a4)
{
  unint64_t v8 = (pthread_mutex_t *)((char *)this + 80);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 80));
  *((void *)this + 8) = a2;
  *((_DWORD *)this + 12) = a3;
  *((unsigned char *)this + 72) = a4;

  return pthread_mutex_unlock(v8);
}

uint64_t GlobalPNGInfo::currentBufferIndex(GlobalPNGInfo *this)
{
  unint64_t v2 = (pthread_mutex_t *)((char *)this + 80);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 80));
  uint64_t v3 = *((unsigned int *)this + 13);
  pthread_mutex_unlock(v2);
  return v3;
}

uint64_t GlobalPNGInfo::setCurrentBufferIndex(GlobalPNGInfo *this, int a2)
{
  unint64_t v4 = (pthread_mutex_t *)((char *)this + 80);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 80));
  *((_DWORD *)this + 13) = a2;

  return pthread_mutex_unlock(v4);
}

uint64_t GlobalPNGInfo::setCurrentBufferRowBytes(GlobalPNGInfo *this, int a2)
{
  unint64_t v4 = (pthread_mutex_t *)((char *)this + 80);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 80));
  *((_DWORD *)this + 14) = a2;

  return pthread_mutex_unlock(v4);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<fcTL_CHUNK>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x787878787878788) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(34 * a2);
}

void std::vector<fcTL_CHUNK>::__append(void **a1, unint64_t a2)
{
  CFTypeRef v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  CFIndex v7 = *(char **)(v4 - 8);
  if (0xF0F0F0F0F0F0F0F1 * ((v6 - v7) >> 1) >= a2)
  {
    if (a2)
    {
      size_t v13 = 34 * ((34 * a2 - 34) / 0x22) + 34;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xF0F0F0F0F0F0F0F1 * ((v7 - (unsigned char *)*a1) >> 1);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x787878787878787) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xF0F0F0F0F0F0F0F1 * ((v5 - (unsigned char *)*a1) >> 1);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x3C3C3C3C3C3C3C3) {
      unint64_t v11 = 0x787878787878787;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11) {
      long long v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<fcTL_CHUNK>>(v4, v11);
    }
    else {
      long long v12 = 0;
    }
    CGFloat v14 = &v12[34 * v8];
    long long v15 = &v12[34 * v11];
    size_t v16 = 34 * ((34 * a2 - 34) / 0x22) + 34;
    bzero(v14, v16);
    uint64_t v17 = &v14[v16];
    CGColorSpaceRef v19 = (char *)*a1;
    vImage_Buffer v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        long long v20 = *(_OWORD *)(v18 - 34);
        long long v21 = *(_OWORD *)(v18 - 18);
        *((_WORD *)v14 - 1) = *((_WORD *)v18 - 1);
        *(_OWORD *)(v14 - 18) = v21;
        *(_OWORD *)(v14 - 34) = v20;
        v14 -= 34;
        v18 -= 34;
      }
      while (v18 != v19);
      vImage_Buffer v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
    {
      operator delete(v18);
    }
  }
}

void IIO_Reader_GIF::createReadPlugin()
{
}

{
  operator new();
}

void sub_1887199C4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40D91773ABLL);
  _Unwind_Resume(a1);
}

void sub_188719A64(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40D91773ABLL);
  _Unwind_Resume(a1);
}

IIOImageRead *IIO_Reader_GIF::createGlobalInfoData(IIO_Reader_GIF *this, IIOImageReadSession *a2)
{
  uint64_t result = IIOImageReadSession::globalInfoForType(a2, *((_DWORD *)this + 6));
  if (result)
  {
    uint64_t v3 = result;
    v4.location = 0;
    v4.CFIndex length = GlobalGIFInfo::frameCount(result);
    return (IIOImageRead *)GlobalGIFInfo::createDataRepresentation(v3, &v4);
  }
  return result;
}

void IIO_Reader_GIF::updateGlobalInfo(IIO_Reader_GIF *this, IIOImageReadSession *a2, unsigned __int8 *a3)
{
}

void sub_188719B64(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4062D5A0A4);
  _Unwind_Resume(a1);
}

void IIO_Reader_GIF::deserializeGlobalInfo(IIO_Reader_GIF *this, unsigned __int8 *a2)
{
}

void sub_188719BE0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4062D5A0A4);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_GIF::updateSourceProperties(IIO_Reader_GIF *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  return IIO_Reader_GIF::parse(this, a2, a4, a6, 0, a3);
}

uint64_t IIO_Reader_GIF::parse(IIO_Reader_GIF *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5, IIODictionary *a6)
{
  int v114 = 0;
  v115[0] = 1;
  uint64_t v113 = 0;
  int v112 = 0;
  uint64_t v111 = 0;
  int v110 = 0;
  uint64_t v108 = 0;
  uint64_t v109 = 0;
  char v10 = IIOSkipMetadata(a3);
  unint64_t v11 = (unsigned __int16 *)_cg_DGifOpen((uint64_t)a2, (int (*)(uint64_t, _DWORD *, uint64_t))gifRead, (int *)v115);
  if (!v11)
  {
    unsigned int FrameCount = 0;
    unsigned int v16 = 0;
    CGImageSourceStatus v17 = kCGImageStatusIncomplete;
    if (a4) {
      goto LABEL_147;
    }
    goto LABEL_148;
  }
  unint64_t v68 = a4;
  long long v12 = IIOImageReadSession::globalInfoForType(a2, 1195984416);
  context = a6;
  if (!v12) {
    operator new();
  }
  size_t v13 = v12;
  if (a6)
  {
    char v69 = 0;
    int v67 = a5;
    if (v10)
    {
      unsigned int FrameCount = 0;
      theSet = 0;
    }
    else
    {
      theSet = CFSetCreateMutable(0, 0, MEMORY[0x1E4F1D548]);
      char v69 = 0;
      unsigned int FrameCount = 0;
    }
  }
  else
  {
    unsigned int FrameCount = GlobalGIFInfo::lastFrameCount(v12);
    if (FrameCount)
    {
      unint64_t ImageDescOffset = GlobalGIFInfo::lastImageDescOffset(v13);
      IIOImageReadSession::seek(a2, ImageDescOffset, 0);
    }
    if (*((unsigned char *)v13 + 217))
    {
      unsigned int FrameCount = GlobalGIFInfo::frameCount(v13);
      unsigned int v16 = 0;
      theSet = 0;
      int v79 = -1;
      if (!FrameCount) {
        goto LABEL_136;
      }
LABEL_124:
      if (GlobalGIFInfo::frameSizesMatchCanvasSize(v13, *v11, v11[1])) {
        goto LABEL_136;
      }
      if (GlobalGIFInfo::frameCount(v13) == 1 && !*v11 && !v11[1])
      {
        uint64_t v107 = 0;
        *(_OWORD *)uint64_t v105 = 0u;
        long long v106 = 0u;
        GlobalGIFInfo::getFrameInfoAtIndex(v13, 0, (uint64_t)v105);
        if (!(v105[4] | v105[5])) {
          *(_DWORD *)unint64_t v11 = *(_DWORD *)&v105[6];
        }
      }
      _cg_jpeg_mem_term("parse", 531, "canvas size doesn't match frame sizes\n");
      v105[0] = 0;
      v86[0] = 0;
      v83[0] = 0;
      unsigned __int16 v91 = 0;
      GlobalGIFInfo::getMinMaxFrames((uint64_t)v13, v105, v86, v83, &v91);
      int v55 = (__int16)*v11;
      int v56 = (__int16)v11[1];
      unint64_t v57 = 4 * v55 * (uint64_t)v56 * GlobalGIFInfo::frameCount(v13);
      unsigned int v58 = (__int16)v11[1] * (__int16)*v11;
      int v59 = v91 * v83[0];
      int v60 = GlobalGIFInfo::frameCount(v13);
      _cg_jpeg_mem_term("parse", 541, "      count: %d\n", v60);
      _cg_jpeg_mem_term("parse", 542, "canvas size: %d x %d      [%d]\n", (__int16)*v11, (__int16)v11[1], v58);
      _cg_jpeg_mem_term("parse", 543, "     memory: %lld\n", v57);
      *(void *)&double v61 = _cg_jpeg_mem_term("parse", 544, "  max frame: (%d, %d, %d, %d)   [%d]\n", v105[0], v86[0], v83[0], v91, v59).n128_u64[0];
      if (v57 < 0x3B9ACA01)
      {
        if (FrameCount < 0x2711 || v58 <= 100 * v59) {
          goto LABEL_136;
        }
        _cg_jpeg_mem_term("parse", 558, "framePixel vs. canvasPixel ratio looks suspicious\n", v61);
      }
      else
      {
        _cg_jpeg_mem_term("parse", 549, " too much memory\n", v61);
      }
      unsigned int FrameCount = 0;
      goto LABEL_136;
    }
    int v67 = a5;
    theSet = 0;
    char v69 = 1;
  }
  char v18 = 0;
  __int16 v81 = 0;
  int v72 = 0;
  CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  int v79 = -1;
  double v73 = a2;
  do
  {
    v115[0] = _cg_DGifGetRecordType((uint64_t)v11, &v114);
    if (!v115[0])
    {
      IIOImageReadSession::getSize(a2);
      _cg_jpeg_mem_term("parse", 227, "    GIF-ERROR: DGifGetRecordType (%d)  fileSize: %ld\n");
      goto LABEL_160;
    }
    int v19 = v114;
    switch(v114)
    {
      case 2:
        unint64_t v24 = IIOImageReadSession::seek(a2, 0, 1);
        if (v18)
        {
          int v25 = (unsigned __int16)v108;
          __int16 v26 = v109;
          __int16 v27 = WORD2(v109);
          if (HIDWORD(v109) == -1) {
            __int16 v28 = 8;
          }
          else {
            __int16 v28 = 10;
          }
          __int16 v82 = v28;
          int v29 = v81;
        }
        else
        {
          int v25 = 0;
          __int16 v26 = 0;
          __int16 v27 = 0;
          __int16 v81 = FrameCount;
          __int16 v82 = 0;
          int v29 = (__int16)FrameCount;
        }
        v115[0] = _cg_DGifGetImageDesc((uint64_t)v11);
        if (!v115[0])
        {
          IIOImageReadSession::getSize(a2);
          _cg_jpeg_mem_term("parse", 301, "    GIF-ERROR: DGifGetImageDesc (%d)   fileSize: %ld\n");
          goto LABEL_160;
        }
        float v37 = (int *)*((void *)v11 + 6);
        __int16 v78 = v26;
        if (v37) {
          int v76 = *v37;
        }
        else {
          LOWORD(v76) = 0;
        }
        int v38 = v11[16];
        int v39 = v11[17];
        int v80 = v11[19];
        __int16 v77 = v27;
        unsigned __int16 v75 = v11[18];
        int v40 = v29;
        BOOL v41 = !(v38 | v39) && v11[18] == (__int16)*v11 && v80 == (__int16)v11[1];
        char v74 = *((unsigned char *)v11 + 40);
        if (FrameCount >= 2 && !v25 && !v41)
        {
          uint64_t v107 = 0;
          *(_OWORD *)uint64_t v105 = 0u;
          long long v106 = 0u;
          GlobalGIFInfo::getFrameInfoAtIndex(v13, FrameCount - 2, (uint64_t)v105);
          __int16 v81 = WORD4(v106);
          int v40 = SWORD4(v106);
          LOWORD(v25) = 1;
        }
        if (v41)
        {
          if (FrameCount < 3)
          {
            int v42 = 0;
          }
          else
          {
            uint64_t v107 = 0;
            *(_OWORD *)uint64_t v105 = 0u;
            long long v106 = 0u;
            GlobalGIFInfo::getFrameInfoAtIndex(v13, FrameCount - 1, (uint64_t)v105);
            int v42 = BYTE4(v107) & 1;
          }
          if (v72 != 2) {
            int v42 = 0;
          }
          if ((v82 & 2) == 0 || v42)
          {
            int v40 = (__int16)(FrameCount - 1) & ~((__int16)(FrameCount - 1) >> 31);
            __int16 v81 = v40;
          }
        }
        int Code = _cg_DGifGetCode((uint64_t)v11, &v110, (uint64_t)&v111);
        v115[0] = Code;
        if (!Code)
        {
          _cg_jpeg_mem_term("parse", 347, "    GIF-ERROR: DGifGetCode (%d)\n");
LABEL_160:
          unsigned int v16 = -39;
LABEL_115:
          a5 = v67;
          if (FrameCount) {
            goto LABEL_124;
          }
          goto LABEL_136;
        }
        if (!FrameCount && !v111)
        {
          _cg_jpeg_mem_term("parse", 349, "    GIF-ERROR: frame[0] has no codeBlocks\n");
          unsigned int FrameCount = 0;
          unsigned int v16 = -50;
          a5 = v67;
          goto LABEL_136;
        }
        unint64_t v44 = v24;
        if (v111)
        {
          int v45 = 255;
          while (1)
          {
            int v46 = v45;
            int Code = _cg_DGifGetCodeNext((uint64_t)v11, (uint64_t)&v111);
            v115[0] = Code;
            if (!Code) {
              break;
            }
            int v45 = v46 + 255;
            if (!v111)
            {
              if (!FrameCount) {
                goto LABEL_81;
              }
              goto LABEL_75;
            }
          }
          int Error = _cg_GifLastError((uint64_t)v11);
          _cg_jpeg_mem_term("parse", 355, "    GIF-ERROR: DGifGetCodeNext (%d)\n", Error);
          int Code = -39;
          v115[0] = -39;
          if (FrameCount) {
            goto LABEL_75;
          }
        }
        else
        {
          int v46 = 255;
          if (FrameCount) {
            goto LABEL_75;
          }
        }
LABEL_81:
        GlobalGIFInfo::setSize((uint64_t)v13, (__int16)*v11, (__int16)v11[1]);
        int Code = v115[0];
LABEL_75:
        if (Code == 1)
        {
          *(void *)&long long v94 = v44;
          WORD4(v94) = v38;
          WORD5(v94) = v39;
          WORD6(v94) = v75;
          HIWORD(v94) = v80;
          __int16 v95 = v25;
          __int16 v96 = v78;
          __int16 v97 = v77;
          __int16 v98 = 0;
          int v99 = v40;
          __int16 v100 = v76;
          __int16 v101 = 0;
          int v102 = v46;
          __int16 v103 = v82 | ((4 * v74) | v41);
          __int16 v104 = 0;
          GlobalGIFInfo::setFrameInfoAtIndex((uint64_t)v13, &v94, FrameCount++);
          GlobalGIFInfo::setLastFrameCount((uint64_t)v13, FrameCount);
          a2 = v73;
          unint64_t v47 = IIOImageReadSession::seek(v73, 0, 1);
          if (v47 == -1) {
            goto LABEL_114;
          }
          GlobalGIFInfo::setLastImageDescOffset((uint64_t)v13, v47);
          if (v115[0] != 1) {
            goto LABEL_114;
          }
          char v18 = 0;
        }
        else
        {
          char v18 = 0;
          a2 = v73;
        }
        goto LABEL_111;
      case 3:
        unint64_t v30 = IIOImageReadSession::seek(a2, 0, 1);
        v115[0] = _cg_DGifGetExtension((uint64_t)v11, &v112, (uint64_t)&v113);
        if (!v115[0])
        {
          _cg_jpeg_mem_term("parse", 396, "    GIF-ERROR: DGifGetExtension (%d)\n");
          goto LABEL_160;
        }
        CFDataRef v31 = (char *)malloc_type_malloc(0, 0x8447595BuLL);
        if (v31)
        {
          CFDataRef v32 = v31;
          unint64_t v33 = 0;
          while (1)
          {
            if (!v113)
            {
              if (v112 == 255)
              {
                if (v33 >= 0xE)
                {
                  int v49 = strncmp(v32, gNetscape[0], 0xBuLL);
                  char v50 = v69;
                  if (v49) {
                    char v50 = 1;
                  }
                  if ((v50 & 1) == 0)
                  {
                    if (*((_WORD *)v32 + 6)) {
                      int v51 = *((unsigned __int16 *)v32 + 6) + 1;
                    }
                    else {
                      int v51 = 0;
                    }
                    IIONumber::IIONumber((IIONumber *)v93, v51);
                    IIODictionary::setObjectForKeyGroup(context, (uint64_t)v93, @"LoopCount", @"{GIF}");
                    IIONumber::~IIONumber((IIONumber *)v93);
                  }
                }
                if (v33 >= 0xB && !strncmp(v32, gICCMagic[0], 0xBuLL)) {
                  GlobalGIFInfo::setColorSyncProfileOffset((uint64_t)v13, v30);
                }
              }
              else if (v112 == 254)
              {
                if (theSet)
                {
                  CFStringRef v52 = CFStringCreateWithBytes(alloc, (const UInt8 *)v32, v33, 0x600u, 0);
                  if (v52)
                  {
                    CFStringRef v53 = v52;
                    CFSetAddValue(theSet, v52);
                    CFRelease(v53);
                  }
                }
              }
              else if (v112 == 249 {
                     && _cg_DGifExtensionToGCB(v33, (unsigned __int8 *)v32, (uint64_t)&v108) == 1)
              }
              {
                int v72 = (unsigned __int16)v108;
                char v18 = 1;
              }
              free(v32);
              goto LABEL_111;
            }
            uint64_t v34 = *v113;
            unint64_t v35 = v33 + v34;
            if (__CFADD__(v33, v34)) {
              break;
            }
            float v36 = (char *)reallocf(v32, v33 + v34);
            if (!v36)
            {
              _cg_jpeg_mem_term("parse", 410, "    GIF-ERROR: realloc(%d) failed\n", v33 + *v113);
              goto LABEL_114;
            }
            CFDataRef v32 = v36;
            memcpy(&v36[v33], v113 + 1, *v113);
            unint64_t v33 = v35;
            v115[0] = _cg_DGifGetExtensionNext((uint64_t)v11, (uint64_t)&v113);
            if (!v115[0])
            {
              _cg_jpeg_mem_term("parse", 416, "    GIF-ERROR: DGifGetExtensionNext (%d)\n", 0);
              unsigned int v16 = -39;
              a5 = v67;
              goto LABEL_123;
            }
          }
          unsigned int v16 = 0;
          a5 = v67;
LABEL_123:
          free(v32);
          if (!FrameCount) {
            goto LABEL_136;
          }
          goto LABEL_124;
        }
        goto LABEL_114;
      case 4:
        GlobalGIFInfo::setFinal((uint64_t)v13, 1);
        if (FrameCount != 1) {
          goto LABEL_110;
        }
        int v20 = (__int16)*v11;
        int v21 = (__int16)v11[1];
        if (v20 | v21)
        {
          unsigned int v23 = (__int16)v11[1];
          unsigned int v22 = (__int16)*v11;
          if (v11[16]) {
            goto LABEL_107;
          }
        }
        else
        {
          if (v11[16] || v11[17])
          {
            unsigned int v22 = 0;
            unsigned int v23 = 0;
            goto LABEL_107;
          }
          unsigned int v22 = (__int16)v11[18];
          unsigned int v23 = (__int16)v11[19];
        }
        if (!v11[17] && v22 > (__int16)v11[18])
        {
          unsigned int v54 = (__int16)v11[19];
          if (v23 > v54) {
            unsigned int v22 = (__int16)v11[18];
          }
          if (v23 >= v54) {
            unsigned int v23 = (__int16)v11[19];
          }
        }
LABEL_107:
        int v79 = 0;
        unsigned int FrameCount = 1;
        if (v22 != v20 && v23 != v21)
        {
          GlobalGIFInfo::setSize((uint64_t)v13, v22, v23);
LABEL_110:
          int v79 = 0;
        }
LABEL_111:
        int v19 = v114;
        break;
    }
  }
  while (v19 != 4);
  if (v69)
  {
LABEL_114:
    unsigned int v16 = 0;
    goto LABEL_115;
  }
  a5 = v67;
  if ((IIODictionary::containsKeyGroup(context, @"LoopCount", @"{GIF}") & 1) == 0)
  {
    IIONumber::IIONumber((IIONumber *)v92, 1);
    IIODictionary::setObjectForKeyGroup(context, (uint64_t)v92, @"LoopCount", @"{GIF}");
    IIONumber::~IIONumber((IIONumber *)v92);
  }
  unsigned int v16 = 0;
  if (FrameCount) {
    goto LABEL_124;
  }
LABEL_136:
  if (context)
  {
    if (*((void *)v11 + 2)) {
      uint64_t v62 = (const void **)MEMORY[0x1E4F1CFD0];
    }
    else {
      uint64_t v62 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    IIODictionary::setObjectForKeyGroup(context, *v62, @"HasGlobalColorMap", @"{GIF}");
    IIONumber::IIONumber((IIONumber *)v90, (__int16)*v11);
    IIODictionary::setObjectForKeyGroup(context, (uint64_t)v90, @"CanvasPixelWidth", @"{GIF}");
    IIONumber::~IIONumber((IIONumber *)v90);
    IIONumber::IIONumber((IIONumber *)v89, (__int16)v11[1]);
    IIODictionary::setObjectForKeyGroup(context, (uint64_t)v89, @"CanvasPixelHeight", @"{GIF}");
    IIONumber::~IIONumber((IIONumber *)v89);
    *(void *)unsigned int v86 = 0;
    uint64_t v87 = 0;
    uint64_t v88 = 0;
    IIOArray::IIOArray((IIOArray *)v86);
    for (unint64_t i = 0; i < GlobalGIFInfo::frameCount(v13); ++i)
    {
      uint64_t v107 = 0;
      *(_OWORD *)uint64_t v105 = 0u;
      long long v106 = 0u;
      GlobalGIFInfo::getFrameInfoAtIndex(v13, i, (uint64_t)v105);
      *(void *)int v83 = 0;
      uint64_t v84 = 0;
      uint64_t v85 = 0;
      IIODictionary::IIODictionary((IIODictionary *)v83);
      IIO_addDelayTimeToDictionary(WORD1(v106), (IIODictionary *)v83, 0);
      IIOArray::addObject((CFMutableArrayRef *)v86, v84);
      IIODictionary::~IIODictionary((IIODictionary *)v83);
    }
    IIODictionary::setObjectForKeyGroup(context, v87, @"FrameInfo", @"{GIF}");
    if (theSet)
    {
      gCommentIndex = 0;
      CFSetApplyFunction(theSet, (CFSetApplierFunction)GifSetApplier, context);
      CFRelease(theSet);
    }
    IIOArray::~IIOArray((IIOArray *)v86);
  }
  a4 = v68;
  CGImageSourceStatus v17 = v79;
  if (v68) {
LABEL_147:
  }
    *a4 = v17;
LABEL_148:
  if (a5) {
    *a5 = FrameCount;
  }
  if (v11) {
    _cg_DGifCloseFile((uint64_t)v11, 0);
  }
  if (v16 == -39 && FrameCount > 1) {
    return 0;
  }
  else {
    return v16;
  }
}

void sub_18871A910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
}

uint64_t IIO_Reader_GIF::getImageCount(IIO_Reader_GIF *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  return IIO_Reader_GIF::parse(this, a2, a3, a4, a5, 0);
}

void GifSetApplier(const void *a1, IIODictionary *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  long long v9 = 0u;
  long long v10 = 0u;
  *(_OWORD *)__str = 0u;
  long long v8 = 0u;
  int v4 = gCommentIndex++;
  snprintf(__str, 0x40uLL, "Comment %d", v4);
  CFStringRef v5 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], __str, 0x600u);
  if (v5)
  {
    CFStringRef v6 = v5;
    IIODictionary::setObjectForKeyGroup(a2, a1, v5, @"{GIF}");
    CFRelease(v6);
  }
}

uint64_t IIO_Reader_GIF::hasCustomImageCountProc(IIO_Reader_GIF *this)
{
  return 1;
}

uint64_t IIO_Reader_GIF::hasCustomSourcePropertiesProc(IIO_Reader_GIF *this)
{
  return 1;
}

uint64_t iioSkipCallback(int a1, IIOImageReadSession **a2)
{
  if (IIOImageReadSession::skipBytes(*a2, a1) == a1) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t iioRewindCallback(void *a1)
{
  return 0;
}

BOOL iioWriteCallback(void *__ptr, int a2, IIOImageWriteSession *this)
{
  size_t v4 = IIOImageWriteSession::putBytes(this, __ptr, a2);
  if (v4 != a2) {
    _cg_jpeg_mem_term("iioWriteCallback", 113, "wrote %ld bytes (expected: %ld)\n", v4, a2);
  }
  return v4 != a2;
}

void JPEGReadPlugin::JPEGReadPlugin(uint64_t a1, uint64_t a2)
{
}

uint64_t JPEGReadPlugin::loadDataFromXPCObject(JPEGReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_jpeg", &length);
    if (length == 56)
    {
      CFStringRef v6 = data;
      uint64_t result = 0;
      long long v7 = *v6;
      long long v8 = v6[1];
      long long v9 = v6[2];
      *((void *)this + 62) = *((void *)v6 + 6);
      *((_OWORD *)this + 29) = v8;
      *((_OWORD *)this + 30) = v9;
      *((_OWORD *)this + 28) = v7;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t JPEGReadPlugin::saveDataToXPCObject(JPEGReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_jpeg", (char *)this + 448, 0x38uLL);
  }
  return v4;
}

CFTypeRef JPEGReadPlugin::useNamedColorSpace(JPEGReadPlugin *this, CFTypeRef cf)
{
  uint64_t v4 = (const void *)*((void *)this + 55);
  if (v4) {
    CFRelease(v4);
  }
  CFTypeRef result = CFRetain(cf);
  *((void *)this + 55) = result;
  return result;
}

void JPEGWritePlugin::JPEGWritePlugin(JPEGWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, int a4)
{
  IIOWritePlugin::IIOWritePlugin(this, a2, a3, a4);
  *uint64_t v4 = &unk_1ED4E3A88;
}

CFDataRef JPEGWritePlugin::createLumaQuantizationTableFromImageIOQuality(JPEGWritePlugin *this, float a2, int a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  if (a2 >= 0.9944)
  {
    *(void *)&long long v10 = 0x101010101010101;
    *((void *)&v10 + 1) = 0x101010101010101;
    long long v14 = v10;
    long long v15 = v10;
    long long v12 = v10;
    long long v13 = v10;
  }
  else
  {
    float v3 = 0.0;
    double v4 = fminf(fmaxf(a2, 0.0), 1.0);
    if (v4 < 0.9944) {
      float v3 = 200.0 / (v4 * 32.0 * v4 * v4 + 1.0);
    }
    for (uint64_t i = 0; i != 64; ++i)
    {
      unsigned int v6 = i;
      if (a3) {
        unsigned int v6 = jpeg_zigzag_order[i];
      }
      float v7 = (float)((float)(v3
                         * (float)JPEGWritePlugin::createLumaQuantizationTableFromImageIOQuality(float,BOOL)::std_luma_quant_tbl[i])
                 / 100.0)
         + 0.5;
      float v8 = 255.0;
      if (v7 <= 255.0) {
        float v8 = (float)((float)(v3
      }
                           * (float)JPEGWritePlugin::createLumaQuantizationTableFromImageIOQuality(float,BOOL)::std_luma_quant_tbl[i])
                   / 100.0)
           + 0.5;
      if (v7 >= 1.0) {
        float v9 = v8;
      }
      else {
        float v9 = (float)(int)i;
      }
      *((unsigned char *)&v12 + v6) = (int)v9;
    }
  }
  return CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)&v12, 64);
}

CFDataRef JPEGWritePlugin::createChromaQuantizationTableFromImageIOQuality(JPEGWritePlugin *this, float a2, int a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  if (a2 >= 0.9944)
  {
    *(void *)&long long v10 = 0x101010101010101;
    *((void *)&v10 + 1) = 0x101010101010101;
    long long v14 = v10;
    long long v15 = v10;
    long long v12 = v10;
    long long v13 = v10;
  }
  else
  {
    float v3 = 0.0;
    double v4 = fminf(fmaxf(a2, 0.0), 1.0);
    if (v4 < 0.9944) {
      float v3 = 200.0 / (v4 * 32.0 * v4 * v4 + 1.0);
    }
    for (uint64_t i = 0; i != 64; ++i)
    {
      unsigned int v6 = i;
      if (a3) {
        unsigned int v6 = jpeg_zigzag_order[i];
      }
      float v7 = (float)((float)(v3
                         * (float)JPEGWritePlugin::createChromaQuantizationTableFromImageIOQuality(float,BOOL)::std_chroma_quant_tbl[i])
                 / 100.0)
         + 0.5;
      float v8 = 255.0;
      if (v7 <= 255.0) {
        float v8 = (float)((float)(v3
      }
                           * (float)JPEGWritePlugin::createChromaQuantizationTableFromImageIOQuality(float,BOOL)::std_chroma_quant_tbl[i])
                   / 100.0)
           + 0.5;
      if (v7 >= 1.0) {
        float v9 = v8;
      }
      else {
        float v9 = (float)(int)i;
      }
      *((unsigned char *)&v12 + v6) = (int)v9;
    }
  }
  return CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)&v12, 64);
}

char *JPEGWritePlugin::CreateExtendedXMPMarkerData(JPEGWritePlugin *this, const __CFData *a2, unsigned int a3, const __CFData *a4, const __CFData *a5, unint64_t *a6)
{
  unsigned int v9 = a2;
  BytePtr = CFDataGetBytePtr(this);
  size_t Length = CFDataGetLength(this);
  long long v13 = (char *)malloc_type_calloc(1uLL, Length + 75, 0x44339367uLL);
  long long v14 = v13;
  if (v13)
  {
    qmemcpy(v13, "http://ns.adobe.com/xmp/extension/", 34);
    long long v15 = CFDataGetBytePtr(a4);
    long long v16 = *((_OWORD *)v15 + 1);
    *(_OWORD *)(v14 + 35) = *(_OWORD *)v15;
    *(_OWORD *)(v14 + 51) = v16;
    *(_DWORD *)(v14 + 67) = bswap32(v9);
    *(_DWORD *)(v14 + 71) = bswap32(a3);
    memcpy(v14 + 75, BytePtr, Length);
    *(void *)a5 = Length + 75;
  }
  return v14;
}

uint64_t JPEGWritePlugin::WriteIPTCData(JPEGWritePlugin *this, IIOImageWriteSession *a2, IIOImagePixelDataProvider *a3, IIODictionary *a4)
{
  unint64_t v15 = 0;
  if (a3)
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a3, @"{IPTC}");
    if (ObjectForKey)
    {
      CFTypeID v7 = CFGetTypeID(ObjectForKey);
      if (v7 == CFDictionaryGetTypeID()) {
        operator new();
      }
    }
    if (IIODictionary::getCount(a3))
    {
      unsigned int v8 = IIODictionary::containsKeyGroup(a3, @"ColorSpace", @"{Exif}");
      if (v8) {
        LOBYTE(v8) = IIODictionary::getUint32ForKeyGroup(a3, @"ColorSpace", @"{Exif}") == 1;
      }
      unsigned int v9 = CreateIPTCDataFromProperties(v8, 0, &v15);
      if (v9 && v15)
      {
        long long v10 = v9;
        __int16 __ptr = -4609;
        char __ptr_2 = (unsigned __int16)(v15 + 2) >> 8;
        char __ptr_3 = v15 + 2;
        iioWriteCallback(&__ptr, 4, this);
        iioWriteCallback(v10, v15, this);
        free(v10);
      }
    }
  }
  return 0;
}

void sub_18871B204(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

uint64_t JPEGWritePlugin::WriteICCData(JPEGWritePlugin *this, IIOImageWriteSession *a2, unint64_t a3, CGColorSpace *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  strcpy((char *)v21, "ICC_PROFILE");
  v21[6] = 0;
  if ((unint64_t)a2 | a3)
  {
    SourceGeomCGColorSpaceRef ColorSpace = (CGColorSpace *)a3;
    if (!a3) {
      SourceGeomCGColorSpaceRef ColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
    }
    if (!IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E4F1DC98]))
    {
      if (a2)
      {
        Ref = (CGImage *)IIOImageSource::imageReadRef(a2);
        CGColorRenderingIntent RenderingIntent = CGImageGetRenderingIntent(Ref);
      }
      else
      {
        CGColorRenderingIntent RenderingIntent = kCGRenderingIntentDefault;
      }
      unsigned int v9 = CGColorSpaceCopyData(SourceGeomColorSpace, RenderingIntent);
      if (v9)
      {
        CFDataRef v10 = v9;
        BytePtr = (UInt8 *)CFDataGetBytePtr(v9);
        CFIndex Length = CFDataGetLength(v10);
        if (BytePtr)
        {
          unint64_t v13 = Length;
          if (Length)
          {
            int v14 = ((unint64_t)(Length + 65518) * (unsigned __int128)0x11012113324657uLL) >> 64;
            HIBYTE(v21[6]) = (v14 + ((Length + 65518 - v14) >> 1)) >> 15;
            LOBYTE(v21[6]) = 1;
            if (HIBYTE(v21[6]))
            {
              do
              {
                if (v13 >= 0xFFEF) {
                  uint64_t v15 = 65519;
                }
                else {
                  uint64_t v15 = v13;
                }
                __int16 __ptr = -7425;
                char __ptr_2 = (unsigned __int16)(v15 + 16) >> 8;
                char __ptr_3 = v15 + 16;
                iioWriteCallback(&__ptr, 4, this);
                iioWriteCallback(v21, 14, this);
                v13 -= v15;
                iioWriteCallback(BytePtr, v15, this);
                BytePtr += v15;
                unsigned int v16 = LOBYTE(v21[6]);
                ++LOBYTE(v21[6]);
              }
              while (v16 < HIBYTE(v21[6]));
            }
          }
        }
        CFRelease(v10);
      }
    }
  }
  return 0;
}

uint64_t JPEGWritePlugin::WriteExtendedXMPData(JPEGWritePlugin *this, IIOImageWriteSession *a2, IIODictionary *a3)
{
  CFTypeRef cf = 0;
  CFDataRef theData = 0;
  CFTypeRef v31 = 0;
  if (this && a2)
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a2, @"{MetaData}");
    if (ObjectForKey)
    {
      unsigned int v6 = ObjectForKey;
      CFRetain(ObjectForKey);
    }
    else
    {
      unsigned int v6 = (const void *)CGImageMetadataCreateFromLegacyProps(a2);
    }
    if (CGImageMetadataCreateExtendedXMPWithEXIFFiltered((const CGImageMetadata *)v6, &theData, (CFDataRef *)&cf, (CFDataRef *)&v31, 0))
    {
      unsigned int v8 = theData;
      if (theData)
      {
        CFIndex Length = CFDataGetLength(theData);
        unsigned int v8 = theData;
        if (Length >= 65501)
        {
          CFIndex v10 = CFDataGetLength(theData);
          LogError("WriteExtendedXMPData", 646, "xmpData size exceeds 64KB limit (%ld)\n", v10);
          CFRelease(theData);
          CFDataRef theData = 0;
          if (v6) {
            CFRelease(v6);
          }
          if (cf)
          {
            CFRelease(cf);
            CFTypeRef cf = 0;
          }
          goto LABEL_32;
        }
      }
      __int16 v27 = v6;
      int __ptr = 57855;
      uint64_t v29 = 0;
      XMPMarkerData = JPEGWritePlugin::CreateXMPMarkerData(v8, (const __CFData *)&v29, v7);
      if (XMPMarkerData)
      {
        long long v12 = XMPMarkerData;
        int v13 = v29;
        HIWORD(__ptr) = bswap32(v29 + 2) >> 16;
        iioWriteCallback(&__ptr, 4, this);
        iioWriteCallback(v12, v13, this);
        free(v12);
      }
      if (cf)
      {
        if (v31)
        {
          CFIndex v14 = CFDataGetLength((CFDataRef)cf);
          BytePtr = CFDataGetBytePtr((CFDataRef)cf);
          if (v14 >= 1)
          {
            unsigned int v16 = BytePtr;
            CFIndex v17 = 0;
            CFAllocatorRef v18 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
            uint64_t v19 = v14;
            do
            {
              if (v19 >= 65000) {
                CFIndex v20 = 65000;
              }
              else {
                CFIndex v20 = v19;
              }
              int v21 = CFDataCreate(v18, &v16[v17], v20);
              uint64_t v28 = 0;
              ExtendedXMPMarkerData = JPEGWritePlugin::CreateExtendedXMPMarkerData(v21, (const __CFData *)v14, v17, (const __CFData *)v31, (const __CFData *)&v28, v22);
              if (ExtendedXMPMarkerData)
              {
                unint64_t v24 = ExtendedXMPMarkerData;
                int v25 = v28;
                HIWORD(__ptr) = bswap32(v28 + 2) >> 16;
                iioWriteCallback(&__ptr, 4, this);
                iioWriteCallback(v24, v25, this);
                free(v24);
              }
              CFRelease(v21);
              v17 += 65000;
              v19 -= 65000;
            }
            while (v17 < v14);
          }
        }
      }
      unsigned int v6 = v27;
    }
    if (v6) {
      CFRelease(v6);
    }
  }
  if (theData) {
    CFRelease(theData);
  }
  if (cf) {
    CFRelease(cf);
  }
LABEL_32:
  if (v31) {
    CFRelease(v31);
  }
  return 0;
}

char *JPEGWritePlugin::CreateXMPMarkerData(JPEGWritePlugin *this, const __CFData *a2, unint64_t *a3)
{
  size_t v5 = CFDataGetLength(this) + 29;
  unsigned int v6 = (char *)malloc_type_calloc(1uLL, v5, 0x718DBCD5uLL);
  CFTypeID v7 = v6;
  if (v6)
  {
    qmemcpy(v6, "http://ns.adobe.com/xap/1.0/", 28);
    BytePtr = CFDataGetBytePtr(this);
    size_t Length = CFDataGetLength(this);
    memcpy(v7 + 29, BytePtr, Length);
    *(void *)a2 = v5;
  }
  return v7;
}

uint64_t JPEGWritePlugin::getEncodingHorizontalSubsamplingFactor(JPEGWritePlugin *this, IIODictionary *a2)
{
  float ImageIOCompressionQuality = JPEGWritePlugin::GetImageIOCompressionQuality(a2, a2);
  CFStringRef v4 = @"ChromaSubsamplingX";
  if (IIODictionary::containsKeyGroup(a2, @"ChromaSubsamplingX", @"{JPEG}"))
  {
    LODWORD(result) = IIODictionary::getUint32ForKeyGroup(a2, @"ChromaSubsamplingX", @"{JPEG}");
  }
  else if (IIODictionary::containsKey(a2, @"ChromaSubsamplingX") {
         || (CFStringRef v4 = @"kCGImageDestinationChromaSubSamplingX",
  }
             LODWORD(result) = IIODictionary::containsKey(a2, @"kCGImageDestinationChromaSubSamplingX"), result))
  {
    LODWORD(result) = IIODictionary::getUint32ForKey(a2, v4);
  }
  if (ImageIOCompressionQuality >= 0.9944) {
    unsigned int v6 = 1;
  }
  else {
    unsigned int v6 = 2;
  }
  if ((result - 1) >= 2) {
    return v6;
  }
  else {
    return result;
  }
}

float JPEGWritePlugin::GetImageIOCompressionQuality(JPEGWritePlugin *this, IIODictionary *a2)
{
  unsigned int v3 = IIODictionary::containsKey(this, @"kCGImageDestinationLossyCompressionQuality");
  LODWORD(FloatForKey) = 0.75;
  if (v3) {
    double FloatForKey = IIODictionary::getFloatForKey(this, @"kCGImageDestinationLossyCompressionQuality");
  }
  if (*(float *)&FloatForKey > 1.0) {
    *(float *)&double FloatForKey = 1.0;
  }
  if (*(float *)&FloatForKey < 0.0) {
    *(float *)&double FloatForKey = 0.0;
  }
  return *(float *)&FloatForKey;
}

uint64_t JPEGWritePlugin::getEncodingVerticalSubsamplingFactor(JPEGWritePlugin *this, IIODictionary *a2)
{
  float ImageIOCompressionQuality = JPEGWritePlugin::GetImageIOCompressionQuality(a2, a2);
  CFStringRef v4 = @"ChromaSubsamplingY";
  if (IIODictionary::containsKeyGroup(a2, @"ChromaSubsamplingY", @"{JPEG}"))
  {
    LODWORD(result) = IIODictionary::getUint32ForKeyGroup(a2, @"ChromaSubsamplingY", @"{JPEG}");
  }
  else if (IIODictionary::containsKey(a2, @"ChromaSubsamplingY") {
         || (CFStringRef v4 = @"kCGImageDestinationChromaSubSamplingY",
  }
             LODWORD(result) = IIODictionary::containsKey(a2, @"kCGImageDestinationChromaSubSamplingY"), result))
  {
    LODWORD(result) = IIODictionary::getUint32ForKey(a2, v4);
  }
  if (ImageIOCompressionQuality >= 0.9944) {
    unsigned int v6 = 1;
  }
  else {
    unsigned int v6 = 2;
  }
  if ((result - 1) >= 2) {
    return v6;
  }
  else {
    return result;
  }
}

uint64_t JPEGWritePlugin::JPEGQualityFromLossyCompressionQuality(JPEGWritePlugin *this, float a2)
{
  float v2 = 0.0;
  double v3 = fminf(fmaxf(a2, 0.0), 1.0);
  if (v3 < 0.9944 && (float v2 = 200.0 / (v3 * 32.0 * v3 * v3 + 1.0), v2 >= 100.0)) {
    double v4 = 5000.0 / v2;
  }
  else {
    double v4 = (200.0 - v2) * 0.5;
  }
  unsigned int v5 = (int)v4 & ~((int)v4 >> 31);
  if (v5 >= 0x64) {
    return 100;
  }
  else {
    return v5;
  }
}

void CGImagePluginInitThumbJPEGAtOffsetWithOptions(uint64_t a1, IIOImageReadSession *a2, int a3, uint64_t a4, const __CFDictionary *a5)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImagePluginInitThumbJPEGAtOffsetWithOptions", 0, 0, -1, a5);
  }
  memset(v34, 0, sizeof(v34));
  IIODictionary::IIODictionary((IIODictionary *)v34, a5);
  if (IIODictionary::containsKey((IIODictionary *)v34, @"kCGImageSourceCreateThumbnailFromImageAlways"))IIODictionary::getBoolForKey((IIODictionary *)v34, @"kCGImageSourceCreateThumbnailFromImageAlways"); {
  if (IIODictionary::containsKey((IIODictionary *)v34, @"kCGImageSourceCreateThumbnailFromImageIfAbsent"))IIODictionary::getBoolForKey((IIODictionary *)v34, @"kCGImageSourceCreateThumbnailFromImageIfAbsent");
  }
  if (IIODictionary::containsKey((IIODictionary *)v34, @"kCGImageSourceCreateThumbnailWithTransform"))IIODictionary::getBoolForKey((IIODictionary *)v34, @"kCGImageSourceCreateThumbnailWithTransform"); {
  IIODictionary::getUint32ForKey((IIODictionary *)v34, @"Orientation");
  }
  IIODictionary::getUint32ForKeyGroup((IIODictionary *)v34, @"Orientation", @"{TIFF}");
  if (IIODictionary::containsKey((IIODictionary *)v34, @"kCGImageSourceSubsampleFactor")) {
    IIODictionary::getUint32ForKey((IIODictionary *)v34, @"kCGImageSourceSubsampleFactor");
  }
  if (IIODictionary::containsKey((IIODictionary *)v34, @"kCGImageSourceDecodeRequest"))
  {
    CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v34, @"kCGImageSourceDecodeRequest");
    if (CFStringCompare(ObjectForKey, @"kCGImageSourceDecodeToHDR", 0)) {
      CFStringCompare(ObjectForKey, @"kCGImageSourceDecodeToSDR", 0);
    }
    if (IIODictionary::containsKeyGroup((IIODictionary *)v34, @"kCGGenerateFlexGTC", @"kCGImageSourceDecodeRequestOptions"))IIODictionary::getBoolForKeyGroup((IIODictionary *)v34, @"kCGGenerateFlexGTC", @"kCGImageSourceDecodeRequestOptions"); {
  }
    }
  if (!IIODictionary::getUint32ForKey((IIODictionary *)v34, @"kCGImageSourceThumbnailMaxPixelSize")) {
    IIODictionary::getUint32ForKey((IIODictionary *)v34, @"kCGImageDestinationImageMaxPixelSize");
  }
  kdebug_trace();
  CFIndex v10 = IIODictionary::getObjectForKey((IIODictionary *)v34, @"NamedColorSpace");
  if (a1) {
    uint64_t v11 = *(IIOImagePlus **)(a1 + 24);
  }
  else {
    uint64_t v11 = 0;
  }
  if (!IIO_ReaderHandler::UseAppleJPEG(v10)) {
    operator new();
  }
  if (!v11
    || (Options = (IIODictionary *)IIOImagePlus::getOptions(v11), (int v13 = Options) == 0)
    || !IIODictionary::containsKey(Options, @"kCGImageSourceDecodeRequest"))
  {
    operator new();
  }
  CFIndex v14 = (IIO_Reader_HEIF *)IIO_Reader::testHeaderSize(v11);
  CFStringRef v15 = (const __CFString *)IIODictionary::getObjectForKey(v13, @"kCGImageSourceDecodeRequest");
  CFStringRef v16 = v15;
  CFIndex v17 = "";
  if (v15)
  {
    CFComparisonResult v18 = CFStringCompare(v15, @"kCGImageSourceDecodeToSDR", 0);
    CFComparisonResult v19 = CFStringCompare(v16, @"kCGImageSourceDecodeToHDR", 0);
    if (v18) {
      CFIndex v20 = "";
    }
    else {
      CFIndex v20 = "SDR";
    }
    int v21 = "HDR";
    if (v19) {
      int v21 = "";
    }
    CFIndex v17 = v20;
    if (!v14) {
LABEL_52:
    }
      operator new();
  }
  else
  {
    int v21 = "";
    if (!v14) {
      goto LABEL_52;
    }
  }
  unint64_t v33 = v21;
  uint64_t v22 = 70;
  uint64_t v23 = 46;
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 340) & 0x40000) == 0) {
    uint64_t v22 = 46;
  }
  uint64_t v24 = 73;
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 352) & 0x40000) == 0) {
    uint64_t v24 = 46;
  }
  uint64_t v32 = v22;
  uint64_t v25 = 69;
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 336) & 0x40000) == 0) {
    uint64_t v25 = 46;
  }
  uint64_t v26 = 72;
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 348) & 0x40000) == 0) {
    uint64_t v26 = 46;
  }
  uint64_t v30 = v26;
  uint64_t v31 = v25;
  uint64_t v27 = 71;
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 344) & 0x40000) == 0) {
    uint64_t v27 = 46;
  }
  uint64_t v29 = v25;
  uint64_t v28 = 80;
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 380) & 0x40000) == 0) {
    uint64_t v28 = 46;
  }
  if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 356) & 0x40000) != 0) {
    uint64_t v23 = 74;
  }
  _cg_jpeg_mem_term("CGImagePluginInitThumbJPEGAtOffsetWithOptions", 975, "***  ImageIO: plugin changed from '%c%c%c%c' to '%c%c%c%c'    '%s%s'\n", v23, v28, v29, v27, v30, v31, v24, v32, v17, v33);
  kdebug_trace();
  IIO_Reader_HEIF::CreateGlobalHEIFInfoIfNeeded(v14, a2, a3);
  goto LABEL_52;
}

void sub_18871BFDC(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
}

void sub_18871C060(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImagePluginInitThumbJPEGAtOffset(uint64_t a1, IIOImageReadSession *a2, int a3, uint64_t a4)
{
}

void CGImagePluginInitJPEGAtOffset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImagePluginInitJPEGAtOffset", 0, 0, -1, 0);
  }
  unsigned int v8 = (IIO_ReaderHandler *)kdebug_trace();
  if (IIO_ReaderHandler::UseAppleJPEG(v8) && a7 != 1095389255 && a7 != 1279869514) {
    operator new();
  }
  operator new();
}

void sub_18871C27C(void *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40F933A5CALL);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18871C1D4);
}

void IIOPixelProvider::IIOPixelProvider(IIOPixelProvider *this, CGImageRef image, const vImage_CGImageFormat *a3, IIODictionary *a4)
{
  *(void *)this = &unk_1ED4E3E28;
  *((void *)this + 1) = image;
  *((_DWORD *)this + 13) = CGImageGetWidth(image);
  *((_DWORD *)this + 14) = CGImageGetHeight(*((CGImageRef *)this + 1));
  uint64_t v6 = *(void *)&a3->renderingIntent;
  long long v7 = *(_OWORD *)&a3->bitmapInfo;
  *((_OWORD *)this + 7) = *(_OWORD *)&a3->bitsPerComponent;
  *((_OWORD *)this + 8) = v7;
  *((void *)this + 18) = v6;
  operator new();
}

void sub_18871C408(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

const char *IIOPixelProvider::setupSrcFormat(IIOPixelProvider *this)
{
  uint64_t ImageProvider = CGImageGetImageProvider();
  *((void *)this + 2) = ImageProvider;
  if (ImageProvider)
  {
    int v3 = IIO_CGImageWrapsIOSurface(*((void *)this + 1), 1);
    if (*((unsigned char *)this + 177)) {
      BOOL v4 = v3 == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (!v4)
    {
      *((_DWORD *)this + 56) = 1;
      uint64_t result = (const char *)IIOPixelProvider::setupSrcFormatUsingIOSurface(this);
      goto LABEL_10;
    }
    *((void *)this + 2) = 0;
    *((void *)this + 3) = CGImageGetDataProvider(*((CGImageRef *)this + 1));
    *((_DWORD *)this + 56) = 3;
  }
  else
  {
    *((_DWORD *)this + 56) = 3;
    *((void *)this + 3) = CGImageGetDataProvider(*((CGImageRef *)this + 1));
  }
  uint64_t result = (const char *)IIOPixelProvider::setupSrcFormatUsingDataProvider(this);
LABEL_10:
  unsigned int v6 = *((_DWORD *)this + 43);
  if (v6 <= (*((_DWORD *)this + 13) * *((_DWORD *)this + 29)) >> 3 || v6 == 0) {
    unsigned int v8 = (*((_DWORD *)this + 13) * *((_DWORD *)this + 29)) >> 3;
  }
  else {
    unsigned int v8 = *((_DWORD *)this + 43);
  }
  *((_DWORD *)this + 41) = v8;
  if (!v8)
  {
    return LogError("setupSrcFormat", 111, "*** invalid _dstRowBytes (0)\n");
  }
  return result;
}

void IIOPixelProvider::~IIOPixelProvider(IIOPixelProvider *this)
{
  *(void *)this = &unk_1ED4E3E28;
  if (*((void *)this + 4)) {
    CGAccessSessionRelease();
  }
  float v2 = (const void *)*((void *)this + 5);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((void *)this + 8);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  BOOL v4 = (vImageConverter *)*((void *)this + 19);
  if (v4) {
    vImageConverter_Release(v4);
  }
}

{
  uint64_t vars8;

  IIOPixelProvider::~IIOPixelProvider(this);

  JUMPOUT(0x18C11C0E0);
}

size_t IIOPixelProvider::setupSrcFormatUsingDataProvider(IIOPixelProvider *this)
{
  *((_DWORD *)this + 18) = CGImageGetBitsPerComponent(*((CGImageRef *)this + 1));
  *((_DWORD *)this + 19) = CGImageGetBitsPerPixel(*((CGImageRef *)this + 1));
  *((void *)this + 10) = CGImageGetColorSpace(*((CGImageRef *)this + 1));
  *((_DWORD *)this + 22) = CGImageGetBitmapInfo(*((CGImageRef *)this + 1));
  *((void *)this + 12) = CGImageGetDecode(*((CGImageRef *)this + 1));
  *((_DWORD *)this + 26) = CGImageGetRenderingIntent(*((CGImageRef *)this + 1));
  *((_DWORD *)this + 23) = 0;
  *((_DWORD *)this + 42) = *((_DWORD *)this + 19) / *((_DWORD *)this + 18);
  size_t result = CGImageGetBytesPerRow(*((CGImageRef *)this + 1));
  *((_DWORD *)this + 40) = result;
  return result;
}

uint64_t IIOPixelProvider::setupSrcFormatUsingIOSurface(IIOPixelProvider *this)
{
  float v2 = (__IOSurface *)CGImageProviderCopyIOSurface();
  *((void *)this + 5) = v2;
  if (v2)
  {
    uint64_t result = IOSurfaceGetPixelFormat(v2);
    *((_DWORD *)this + 12) = result;
  }
  else
  {
    return IIOPixelProvider::setupSrcFormatUsingImageProvider(this);
  }
  return result;
}

uint64_t IIOPixelProvider::setupSrcFormatUsingImageProvider(IIOPixelProvider *this)
{
  unsigned int v2 = CGImageProviderGetComponentType() - 1;
  if (v2 <= 4) {
    *((_DWORD *)this + 18) = *(_DWORD *)&asc_188990630[4 * v2];
  }
  *((_DWORD *)this + 19) = 8 * CGImageProviderGetPixelSize();
  *((void *)this + 10) = CGImageProviderGetColorSpace();
  *((_DWORD *)this + 22) = CGImageGetBitmapInfo(*((CGImageRef *)this + 1));
  *((void *)this + 12) = CGImageGetDecode(*((CGImageRef *)this + 1));
  uint64_t result = CGImageGetRenderingIntent(*((CGImageRef *)this + 1));
  *((_DWORD *)this + 26) = result;
  *((_DWORD *)this + 23) = 0;
  *((_DWORD *)this + 42) = *((_DWORD *)this + 19) / *((_DWORD *)this + 18);
  return result;
}

__n128 IIOPixelProvider::createImageConverter(IIOPixelProvider *this)
{
  vImage_Error error = 0;
  vImageConverterRef v2 = vImageConverter_CreateWithCGImageFormat((const vImage_CGImageFormat *)((char *)this + 72), (const vImage_CGImageFormat *)((char *)this + 112), (const CGFloat *)this + 23, 0x100u, &error);
  *((void *)this + 19) = v2;
  if (error) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = v2 == 0;
  }
  if (v4)
  {
    unsigned int v5 = IIO_vImageErrorString(error);
    return _cg_jpeg_mem_term("createImageConverter", 194, "*** could not create vImageConverter: '%s'\n", v5);
  }
  return result;
}

uint64_t IIOPixelProvider::iterateOverImage(IIOPixelProvider *this, uint64_t a2, unsigned int a3, int a4, uint64_t a5)
{
  char v26 = 0;
  unsigned int v5 = *((_DWORD *)this + 14);
  if (v5 >= a3) {
    unsigned int v6 = a3;
  }
  else {
    unsigned int v6 = *((_DWORD *)this + 14);
  }
  if (v5 < a2 || v6 < a2) {
    return 4294967246;
  }
  LODWORD(v10) = a4;
  uint64_t v11 = a2;
  srcs.vImagePixelCount height = 0;
  dests.vImagePixelCount height = 0;
  if (!*((void *)this + 19))
  {
    *(void *)&double v13 = IIOPixelProvider::createImageConverter(this).n128_u64[0];
    if (!*((void *)this + 19))
    {
      ImageIOLog("*** could not create vImageConverter\n", v13);
      return 4294967246;
    }
  }
  CFIndex v14 = malloc_type_malloc((*((_DWORD *)this + 40) * v10), 0xC35F1C7uLL);
  vImagePixelCount v15 = *((unsigned int *)this + 13);
  srcs.data = v14;
  srcs.vImagePixelCount width = v15;
  int v16 = *((_DWORD *)this + 41);
  srcs.size_t rowBytes = *((unsigned int *)this + 40);
  CFIndex v17 = malloc_type_malloc((v16 * v10), 0xCE95637BuLL);
  vImagePixelCount v18 = *((unsigned int *)this + 13);
  dests.data = v17;
  dests.vImagePixelCount width = v18;
  dests.size_t rowBytes = *((unsigned int *)this + 41);
  if (v6 <= v11)
  {
    uint64_t v8 = 4294967246;
    goto LABEL_26;
  }
  while (1)
  {
    if ((int)v11 + (int)v10 <= v6) {
      vImagePixelCount v10 = v10;
    }
    else {
      vImagePixelCount v10 = v6 - v11;
    }
    srcs.vImagePixelCount height = v10;
    uint64_t v19 = IIOPixelProvider::fillSourceBuffer(this, v11, &srcs);
    if (v19)
    {
      uint64_t v8 = v19;
      _cg_jpeg_mem_term("iterateOverImage", 257, "*** ERROR: fillSourceBuffer failed [%d]\n", v19);
      goto LABEL_26;
    }
    if (*((unsigned char *)this + 178))
    {
      p_vImage_Buffer srcs = &srcs;
      goto LABEL_19;
    }
    dests.vImagePixelCount height = v10;
    p_vImage_Buffer srcs = &dests;
    vImage_Error v21 = iio_vImageConvert_AnyToAny(*((vImageConverterRef *)this + 19), &srcs, &dests, 0, 0x100u);
    uint64_t v8 = v21;
    if (v21) {
      break;
    }
LABEL_19:
    (*(void (**)(uint64_t, uint64_t, vImage_Buffer *, char *))(a5 + 16))(a5, v11, p_srcs, &v26);
    uint64_t v8 = 0;
    if (!v26)
    {
      uint64_t v11 = (v10 + v11);
      if (v11 < v6) {
        continue;
      }
    }
    goto LABEL_26;
  }
  uint64_t v22 = IIO_vImageErrorString((int)v21);
  _cg_jpeg_mem_term("iterateOverImage", 274, "*** ERROR: vImageConvert_AnyToAny failed: '%s'\n", v22);
LABEL_26:
  if (srcs.data) {
    free(srcs.data);
  }
  if (dests.data) {
    free(dests.data);
  }
  return v8;
}

uint64_t IIOPixelProvider::fillSourceBuffer(IIOPixelProvider *this, int a2, vImage_Buffer *a3)
{
  if (*((_DWORD *)this + 56) != 3) {
    return 0;
  }
  if (!*((void *)this + 4)) {
    *((void *)this + 4) = CGAccessSessionCreate();
  }
  uint64_t result = CGAccessSessionRewind();
  if (result)
  {
    uint64_t v7 = (*((_DWORD *)this + 40) * a2);
    if (CGAccessSessionSkipForward() == v7)
    {
      size_t v8 = a3->rowBytes * a3->height;
      if (v8 == CGAccessSessionGetBytes()) {
        return 0;
      }
      else {
        return 4294967257;
      }
    }
    return 0;
  }
  return result;
}

uint64_t IIOPixelProvider::enableIndexColorPassThrough(IIOPixelProvider *this)
{
  *((unsigned char *)this + 178) = 0;
  return 0;
}

void IIO_Reader_ETC::createReadPlugin()
{
}

{
  operator new();
}

void sub_18871CAF4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C406B42807ALL);
  _Unwind_Resume(a1);
}

void sub_18871CB94(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C406B42807ALL);
  _Unwind_Resume(a1);
}

BOOL IIO_Reader_ETC::isInDDSContainer(IIO_Reader_ETC *this, const unsigned __int8 *a2)
{
  return *a2 == 68 && a2[1] == 68 && a2[2] == 83 && a2[3] == 32 && a2[4] == 124 && !a2[5] && !a2[6] && !a2[7];
}

uint64_t IIO_Reader_ETC::getImageCount(IIO_Reader_ETC *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  if (a5) {
    *a5 = 1;
  }
  return 0;
}

uint64_t IIO_Reader_ETC::updateSourceProperties(IIO_Reader_ETC *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  return 0;
}

double TIFFReadPlugin::TIFFReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, char a5, int a6)
{
  uint64_t v7 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a6);
  *(void *)uint64_t v7 = &unk_1ED4E2D58;
  double result = 0.0;
  *(_OWORD *)(v7 + 440) = 0u;
  *(_OWORD *)(v7 + 456) = 0u;
  *(_OWORD *)(v7 + 472) = 0u;
  *(_OWORD *)(v7 + 488) = 0u;
  *(_OWORD *)(v7 + 504) = 0u;
  *(_OWORD *)(v7 + 520) = 0u;
  *(_OWORD *)(v7 + 536) = 0u;
  *(_OWORD *)(v7 + 552) = 0u;
  *(unsigned char *)(v7 + 566) = a5;
  return result;
}

void TIFFReadPlugin::TIFFReadPlugin(uint64_t a1, uint64_t a2)
{
}

void TIFFReadPlugin::~TIFFReadPlugin(TIFFReadPlugin *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)this = &unk_1ED4E2D58;
  uint64_t v9 = *((void *)this + 55);
  if (v9) {
    _cg_TIFFClose(v9, a2, a3, a4, a5, a6, a7, a8);
  }
  *((void *)this + 55) = 0;

  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  uint64_t vars8;

  TIFFReadPlugin::~TIFFReadPlugin(this, a2, a3, a4, a5, a6, a7, a8);

  JUMPOUT(0x18C11C0E0);
}

uint64_t TIFFReadPlugin::loadDataFromXPCObject(TIFFReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = (long long *)xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_tiff", &length);
    if (length == 128)
    {
      unsigned int v6 = data;
      uint64_t result = 0;
      long long v7 = v6[3];
      long long v9 = *v6;
      long long v8 = v6[1];
      *(_OWORD *)((char *)this + 472) = v6[2];
      *(_OWORD *)((char *)this + 488) = v7;
      *(_OWORD *)((char *)this + 440) = v9;
      *(_OWORD *)((char *)this + 456) = v8;
      long long v10 = v6[4];
      long long v11 = v6[5];
      long long v12 = v6[7];
      *(_OWORD *)((char *)this + 536) = v6[6];
      *(_OWORD *)((char *)this + 552) = v12;
      *(_OWORD *)((char *)this + 504) = v10;
      *(_OWORD *)((char *)this + 520) = v11;
      *((void *)this + 55) = 0;
    }
    else
    {
      _cg_jpeg_mem_term("loadDataFromXPCObject", 219, "*** ERROR: failed to load 'IMAGEIO_PLUGIN_DATA_TIFF'\n");
      return 4294967246;
    }
  }
  return result;
}

uint64_t TIFFReadPlugin::saveDataToXPCObject(TIFFReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_tiff", (char *)this + 440, 0x80uLL);
  }
  return v4;
}

void TIFFReadPlugin::isValidIFD(uint64_t a1, unint64_t a2, unsigned int a3, unint64_t a4, uint64_t a5, int a6)
{
  IIOScanner::seek((IIOScanner *)a2, a4);
  size_t IFDCount = IIOScanner::getIFDCount((IIOScanner *)a2);
  unint64_t v11 = IFDCount;
  if (IFDCount)
  {
    if (IFDCount >= 0x65)
    {
      _cg_jpeg_mem_term("isValidIFD", 260, "*** ERROR: invalid ifdCount (%lld)\n", IFDCount);
      ++*(_WORD *)(a5 + 4);
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
    }
    long long v12 = (unsigned __int16 *)malloc_type_calloc(IFDCount, 0x14uLL, 0x1000040A86A77D5uLL);
    uint64_t v13 = (uint64_t)v12;
    int v59 = v12;
    unint64_t v14 = v11;
    do
    {
      if (a3)
      {
        IIOScanner::getBigTiffTag(a2, v13);
      }
      else
      {
        unsigned int v61 = 0;
        unint64_t v60 = 0;
        IIOScanner::getTiffTag(a2, (uint64_t)&v60);
        if (*(_DWORD *)(a2 + 64))
        {
          CFStringRef v53 = __cxa_allocate_exception(4uLL);
          _DWORD *v53 = -1;
          __cxa_throw(v53, MEMORY[0x1E4FBA3A8], 0);
        }
        *(_DWORD *)uint64_t v13 = v60;
        *(void *)&long long v15 = HIDWORD(v60);
        *((void *)&v15 + 1) = v61;
        *(_OWORD *)(v13 + 4) = v15;
      }
      v13 += 20;
      --v14;
    }
    while (v14);
    if (a6) {
      unint64_t v16 = 0;
    }
    else {
      unint64_t v16 = *(void *)(a2 + 24);
    }
    if (v11 >= 2)
    {
      CFIndex v17 = v12 + 10;
      unsigned int v18 = *v12;
      unint64_t v19 = v11 - 1;
      do
      {
        unsigned int v21 = *v17;
        v17 += 10;
        unsigned int v20 = v21;
        if (v18 > v21) {
          ++*(_WORD *)a5;
        }
        unsigned int v18 = v20;
        --v19;
      }
      while (v19);
    }
    if (v11 != 1)
    {
      unint64_t v22 = 0;
      uint64_t v23 = v12;
      unint64_t v24 = v11;
      do
      {
        if (v22 < v11)
        {
          uint64_t v25 = &v12[10 * v22];
          int v28 = *v25;
          char v26 = v25 + 6;
          int v27 = v28;
          uint64_t v29 = v23;
          unint64_t v30 = v24;
          uint64_t v31 = v23;
          do
          {
            int v32 = *v31;
            v31 += 10;
            if (v27 == v32 && *v26 != *(void *)(v29 + 6)) {
              ++*(_WORD *)(a5 + 2);
            }
            uint64_t v29 = v31;
            --v30;
          }
          while (v30);
        }
        ++v22;
        --v24;
        v23 += 10;
      }
      while (v22 != v11 - 1);
    }
    if (v11 <= 1) {
      uint64_t v33 = 1;
    }
    else {
      uint64_t v33 = v11;
    }
    uint64_t v34 = (unint64_t *)(v12 + 2);
    uint64_t v35 = v33;
    do
    {
      int v36 = *((unsigned __int16 *)v34 - 2);
      BOOL v37 = (v36 - 256) > 0x28 || ((1 << v36) & 0x1001C6400C3) == 0;
      unsigned int v38 = v36 - 40961;
      if (v37 && v38 >= 3) {
        unint64_t v40 = 0xFFFFFFFFLL;
      }
      else {
        unint64_t v40 = 1;
      }
      if (*v34 > v40 && *v34 >= 5) {
        ++*(_WORD *)(a5 + 4);
      }
      uint64_t v34 = (unint64_t *)((char *)v34 + 20);
      --v35;
    }
    while (v35);
    unint64_t v55 = v16;
    unsigned int v56 = a3;
    BOOL v41 = v12;
    uint64_t v42 = 0;
    uint64_t v43 = (void *)(a5 + 16);
    do
    {
      int v44 = v59[10 * v42];
      if (v44 == 34665 || v44 == 40965 || v44 == 34853)
      {
        unint64_t v47 = *(void *)&v41[10 * v42 + 6];
        if (v47 == a4)
        {
          ++*(_WORD *)(a5 + 6);
        }
        else
        {
          unint64_t v60 = *(void *)&v41[10 * v42 + 6];
          unint64_t v48 = (void *)*v43;
          if (!*v43) {
            goto LABEL_65;
          }
          int v49 = (void *)(a5 + 16);
          do
          {
            unint64_t v50 = v48[4];
            BOOL v51 = v50 >= v47;
            if (v50 >= v47) {
              CFStringRef v52 = v48;
            }
            else {
              CFStringRef v52 = v48 + 1;
            }
            if (v51) {
              int v49 = v48;
            }
            unint64_t v48 = (void *)*v52;
          }
          while (*v52);
          if (v49 != v43 && v47 >= v49[4])
          {
            ++*(_WORD *)(a5 + 2);
          }
          else
          {
LABEL_65:
            std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t **)(a5 + 8), &v60, (uint64_t *)&v60);
            TIFFReadPlugin::isValidIFD(a1, a2, v56, v60, a5, (a6 + 1));
          }
        }
      }
      ++v42;
    }
    while (v42 != v33);
    free(v59);
    if (v55) {
      IIOScanner::seek((IIOScanner *)a2, v55);
    }
  }
}

void sub_18871D244(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
}

BOOL TIFFReadPlugin::isValidTIFF(TIFFReadPlugin *this)
{
  uint64_t v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  memset(v21, 0, sizeof(v21));
  IIOScanner::IIOScanner((IIOScanner *)v21, *((IIOImageReadSession **)this + 3));
  v20[0] = 0;
  v20[1] = 0;
  unint64_t v19 = (uint64_t *)v20;
  IIOScanner::seek((IIOScanner *)v21, *((void *)this + 24));
  int Val16 = IIOScanner::getVal16((IIOScanner *)v21);
  if (Val16 == 18761 || Val16 == 19789)
  {
    GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v21, Val16 == 18761);
    int v3 = IIOScanner::getVal16((IIOScanner *)v21);
    if (v3 == 43)
    {
      int v4 = IIOScanner::getVal16((IIOScanner *)v21);
      IIOScanner::skip((uint64_t)v21, 2);
    }
    else
    {
      int v4 = 4;
    }
    LODWORD(v22) = v4;
    uint64_t v16 = 0;
    long long v18 = 0u;
    CFIndex v17 = &v18;
    IIOScanner::seek((IIOScanner *)v21, *((void *)this + 24) + 4);
    if (v3 == 43) {
      IIOScanner::skip((uint64_t)v21, 4);
    }
    for (unint64_t i = IIOScanner::getTiffOffset((IIOScanner *)v21); ; unint64_t i = IIOScanner::getTiffOffset((IIOScanner *)v21))
    {
      unint64_t v15 = i;
      if (!i) {
        break;
      }
      unsigned int v6 = v20[0];
      if (v20[0])
      {
        long long v7 = v20;
        do
        {
          long long v8 = v6;
          long long v9 = v7;
          unint64_t v10 = v6[4];
          unint64_t v11 = v6 + 1;
          if (v10 >= i)
          {
            unint64_t v11 = v8;
            long long v7 = (void **)v8;
          }
          unsigned int v6 = (void *)*v11;
        }
        while (v6);
        if (v7 != v20)
        {
          if (v10 < i) {
            long long v8 = v9;
          }
          if (i >= v8[4])
          {
            ++HIWORD(v16);
            break;
          }
        }
      }
      std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(&v19, &v15, (uint64_t *)&v15);
      TIFFReadPlugin::isValidIFD((uint64_t)this, (unint64_t)v21, v3 == 43, v15, (uint64_t)&v16, 0);
      if (v24)
      {
        exception = __cxa_allocate_exception(4uLL);
        _DWORD *exception = -1;
        __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
      }
    }
    BOOL v12 = (HIWORD(v16) | WORD2(v16)) == 0;
    std::__tree<unsigned long long>::destroy((uint64_t)&v17, (void *)v18);
  }
  else
  {
    BOOL v12 = 0;
  }
  std::__tree<unsigned long long>::destroy((uint64_t)&v19, v20[0]);
  IIOScanner::~IIOScanner((IIOScanner *)v21);
  return v12;
}

uint64_t TIFFReadPlugin::initialize(IIOImageReadSession **this, IIODictionary *a2)
{
  int isValidTIFF = *((unsigned __int8 *)this + 355);
  if (isValidTIFF == 255)
  {
    int isValidTIFF = TIFFReadPlugin::isValidTIFF((TIFFReadPlugin *)this);
    *((unsigned char *)this + 355) = isValidTIFF;
  }
  if (isValidTIFF)
  {
    IIODictionary::getBoolForKey(this[6], @"kCGImageSourceShouldAllowFloat");
    IIOSkipMetadata(this[6]);
    IIOSkipXMP_and_IPTC(this[6]);
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(this[6], @"kCGImageSourceXMPSidecar");
    if (ObjectForKey)
    {
      CFGetTypeID(ObjectForKey);
      CFDataGetTypeID();
    }
    if (IIODictionary::containsKey(this[6], @"kCGImageSourceSubsampleFactor")) {
      IIODictionary::getUint32ForKey(this[6], @"kCGImageSourceSubsampleFactor");
    }
    unsigned int v5 = IIOImageReadSession::globalInfoForType(this[3], 1414088262);
    if (v5)
    {
      if (*((unsigned int *)this + 52) < (unint64_t)((uint64_t)(*((void *)v5 + 3) - *((void *)v5 + 2)) >> 3)) {
        operator new();
      }
      _cg_jpeg_mem_term("initialize", 537, "*** bad imageOffsets...\n");
    }
    else
    {
      _cg_jpeg_mem_term("initialize", 535, "*** globalInfoForType('TIFF') failed...\n");
    }
  }
  else
  {
    LogError("initialize", 521, "*** invalid TIFF file\n");
  }
  kdebug_trace();
  return 4294967246;
}

void sub_18871E010(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C40F2E54FF0);
  _Unwind_Resume(a1);
}

uint64_t TIFFReadPlugin::initPhotoshopThumbnail(TIFFReadPlugin *this, unint64_t a2, int64_t size, IIODictionary *a4)
{
  long long v7 = (unsigned __int8 *)malloc_type_malloc(size, 0xE800590EuLL);
  if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v7, a2, size) == size && size >= 6)
  {
    unint64_t v10 = (unint64_t)&v7[size];
    unint64_t v11 = v7 + 5;
    BOOL v12 = v7;
    do
    {
      if (strncmp((const char *)v12, "8BIM", 4uLL) || (unint64_t)(v12 + 12) >= v10) {
        break;
      }
      if ((*v11 | (v12[4] << 8)) == 0x40C)
      {
        if ((unint64_t)(v12 + 42) < v10 && v12[40] == 255 && v12[41] == 216) {
          CGImagePluginInitJPEGAtOffset(*((void *)this + 1), 0, v12 + 40 - v7 + a2, (v12[32] << 24) | ((unint64_t)v12[33] << 16) | ((unint64_t)v12[34] << 8) | v12[35], 1, 5000, 1953785973);
        }
        break;
      }
      v12 += _byteswap_ulong(*((_DWORD *)v12 + 2)) + (v12[11] & 1) + 12;
      unint64_t v11 = v12 + 5;
    }
    while ((unint64_t)(v12 + 5) < v10);
  }
  if (v7) {
    free(v7);
  }
  return 0;
}

void sub_18871E238(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t TIFFReadPlugin::updateTiffStruct(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!_cg_TIFFGetField(a2, 256, a3, a4, a5, a6, a7, a8, a1 + 448))
  {
    _cg_jpeg_mem_term("updateTiffStruct", 983, "*** ERROR: could not get TIFFTAG_IMAGEWIDTH\n", v100);
    return 4294967246;
  }
  if (!_cg_TIFFGetField(a2, 257, v10, v11, v12, v13, v14, v15, a1 + 452))
  {
    _cg_jpeg_mem_term("updateTiffStruct", 986, "*** ERROR: could not  get TIFFTAG_IMAGELENGTH\n", v101);
    return 4294967246;
  }
  long long v22 = (_WORD *)(a1 + 458);
  _cg_TIFFGetFieldDefaulted((uint64_t)a2, 258, v16, v17, v18, v19, v20, v21, (_DWORD *)(a1 + 458));
  _cg_TIFFGetFieldDefaulted((uint64_t)a2, 277, v23, v24, v25, v26, v27, v28, (_DWORD *)(a1 + 488));
  _cg_TIFFGetFieldDefaulted((uint64_t)a2, 284, v29, v30, v31, v32, v33, v34, (_DWORD *)(a1 + 466));
  _cg_TIFFGetFieldDefaulted((uint64_t)a2, 339, v35, v36, v37, v38, v39, v40, (_DWORD *)(a1 + 468));
  *(void *)(a1 + 480) = _cg_TIFFStripSize64((uint64_t)a2, v41, v42, v43, v44, v45, v46, v47);
  *(_DWORD *)(a1 + 556) = _cg_TIFFNumberOfStrips((uint64_t)a2, v48, v49, v50, v51, v52, v53, v54);
  *(void *)(a1 + 496) = _cg_TIFFScanlineSize64((uint64_t)a2, v55, v56, v57, v58, v59, v60, v61);
  if (*(_WORD *)(a1 + 468) == 3)
  {
    int v62 = (unsigned __int16)*v22;
    if (v62 != 16 && v62 != 32)
    {
      _cg_jpeg_mem_term("updateTiffStruct", 997, "*** floatingPoint TIFF - cannot handle %d bits/component\n");
      return 4294967246;
    }
  }
  unsigned int v63 = *(unsigned __int16 *)(a1 + 488);
  if (v63 >= 0x21)
  {
    _cg_jpeg_mem_term("updateTiffStruct", 999, "*** samplesPerPixel '%d' not supported (<=32)\n");
    return 4294967246;
  }
  unsigned int v64 = (unsigned __int16)*v22;
  if (v64 >= 0x21)
  {
    _cg_jpeg_mem_term("updateTiffStruct", 1000, "*** bitsPerComponent '%d' not supported (<=32)\n");
    return 4294967246;
  }
  unsigned __int16 v65 = v63 - *(_WORD *)(a1 + 462);
  if (v65 >= 0x21u)
  {
    _cg_jpeg_mem_term("updateTiffStruct", 1003, "*** realsamples '%d' not supported (<=32)\n");
    return 4294967246;
  }
  if (*v22 && !*(_WORD *)(a1 + 460)) {
    *(_WORD *)(a1 + 460) = v65 * v64;
  }
  int v66 = _cg_TIFFIsTiled(*(void *)(a1 + 440));
  *(unsigned char *)(a1 + 561) = v66 != 0;
  if (v66)
  {
    _cg_TIFFGetField(*(void **)(a1 + 440), 322, v67, v68, v69, v70, v71, v72, a1 + 516);
    _cg_TIFFGetField(*(void **)(a1 + 440), 323, v73, v74, v75, v76, v77, v78, a1 + 520);
    unsigned int v86 = *(_DWORD *)(a1 + 516);
    if ((v86 & 0xF) != 0)
    {
      _cg_jpeg_mem_term("updateTiffStruct", 1016, "*** ERROR: tileWidth %d is not a multiple of 16\n");
    }
    else
    {
      unsigned int v87 = *(_DWORD *)(a1 + 520);
      if ((v87 & 0xF) != 0)
      {
        _cg_jpeg_mem_term("updateTiffStruct", 1017, "*** ERROR: tileHeight %d is not a multiple of 16\n");
      }
      else if (v86 <= 0xF)
      {
        _cg_jpeg_mem_term("updateTiffStruct", 1018, "unexpected tileWidth: %d\n");
      }
      else if (v87 <= 0xF)
      {
        _cg_jpeg_mem_term("updateTiffStruct", 1019, "unexpected tileHeight: %d\n");
      }
      else
      {
        unint64_t v88 = _cg_TIFFTileSize64(*(void *)(a1 + 440), v79, v80, v81, v82, v83, v84, v85);
        *(void *)(a1 + 528) = v88;
        if (v88 <= *(void *)(a1 + 184))
        {
          uint64_t v96 = _cg_TIFFTileRowSize64(*(void *)(a1 + 440), v89, v90, v91, v92, v93, v94, v95);
          uint64_t result = 0;
          *(void *)(a1 + 504) = v96;
          return result;
        }
        _cg_jpeg_mem_term("updateTiffStruct", 1021, "unexpected tileSize: %ll  d\n", v88);
      }
    }
    return 4294967246;
  }
  _cg_TIFFGetFieldDefaulted((uint64_t)a2, 278, v67, v68, v69, v70, v71, v72, (_DWORD *)(a1 + 472));
  int v98 = *(_DWORD *)(a1 + 472);
  int v99 = *(_DWORD *)(a1 + 452);
  if (v98 == -1)
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 472) = v99;
  }
  else
  {
    if (v98 > v99) {
      _cg_jpeg_mem_term("updateTiffStruct", 1031, "*** NOTE: _tiff._tiffRowsPerStrip: %d   _tiff._tiffHeight: %d\n", *(_DWORD *)(a1 + 472), v99);
    }
    return 0;
  }
  return result;
}

uint64_t TIFFReadPlugin::sanityCheck(TIFFReadPlugin *this)
{
  unsigned int v2 = *((_DWORD *)this + 112);
  if (v2 <= 0x3E8)
  {
    unsigned int v3 = *((_DWORD *)this + 113);
    if (v3 <= 0x3E8) {
      return 0;
    }
  }
  else
  {
    unsigned int v3 = *((_DWORD *)this + 113);
    if (v2 > 0x30D40) {
      goto LABEL_6;
    }
  }
  if (v3 > 0x30D40)
  {
LABEL_6:
    LogError("sanityCheck", 1403, "image too large (%ld x %ld)\n");
    return 4294967246;
  }
  unint64_t Size = (unint64_t)IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  unsigned int v6 = *((_DWORD *)this + 112);
  uint64_t v7 = *((unsigned __int16 *)this + 229);
  unint64_t v8 = *((unsigned __int16 *)this + 244) * (unint64_t)v6 * v7;
  unint64_t v9 = (v8 + 7) >> 3;
  int v10 = *((unsigned __int16 *)this + 232);
  if (v10 == 1)
  {
    if (v9 > Size)
    {
      _cg_jpeg_mem_term("sanityCheck", 1415, "oneRow > imageSize (%ld > %ld)\n");
      return 4294967246;
    }
    if (v9 * *((unsigned int *)this + 113) > Size && *((_WORD *)this + 228) != 6)
    {
      _cg_jpeg_mem_term("sanityCheck", 1420, "oneRow * height > imageSize (%ld > %ld)\n");
      return 4294967246;
    }
  }
  if (*((unsigned char *)this + 561))
  {
    if (Size <= (*((_DWORD *)this + 113) + *((_DWORD *)this + 130) - 1)
               * ((v6 + *((_DWORD *)this + 129) - 1)
                / *((_DWORD *)this + 129))
               / *((_DWORD *)this + 130))
    {
      LogError("sanityCheck", 1430, "ERROR: too many tiles (%ld)\n");
      return 4294967246;
    }
    if (Size <= *(unsigned int *)(*((void *)this + 55) + 228))
    {
      LogError("sanityCheck", 1431, "ERROR: too many tiles (%ld)\n");
      return 4294967246;
    }
  }
  if (v10 == 5)
  {
    unint64_t v11 = (v8 + 7) / 0x1F40;
    if (v8 < 0x1F39) {
      unint64_t v11 = 1;
    }
    uint64_t v12 = *((unsigned int *)this + 113);
    if (Size < v11 * v12
      && *((unsigned char *)this + 341)
      && ((unint64_t)(float)((float)((float)v9 * (float)v12) / (float)Size) >> 4 > 0x270
       || v7 != 1))
    {
      return 4294967246;
    }
  }
  return 0;
}

uint64_t TIFFReadPlugin::updateSubsample(TIFFReadPlugin *this, unsigned int a2)
{
  *((_WORD *)this + 158) = 0;
  unsigned int v2 = *((_DWORD *)this + 112);
  unsigned int v3 = *((_DWORD *)this + 113);
  *((_DWORD *)this + 57) = v2;
  *((_DWORD *)this + 58) = v3;
  *((_DWORD *)this + 65) = v2;
  *((_DWORD *)this + 66) = v3;
  if (!a2)
  {
    unsigned int v4 = *((_DWORD *)this + 53);
    if (v4)
    {
      double v5 = (double)v2 / (double)v4;
      if (v5 <= (double)v3 / (double)v4) {
        double v5 = (double)v3 / (double)v4;
      }
      a2 = v5;
    }
    else
    {
      a2 = 0;
    }
  }
  if ((gIIODebugFlags & 0x200000000) != 0) {
    int v6 = 1;
  }
  else {
    int v6 = a2;
  }
  int v7 = *((unsigned __int16 *)this + 228);
  if (v7 == 6) {
    unsigned int v8 = 1;
  }
  else {
    unsigned int v8 = v6;
  }
  if (v2 >= v3) {
    unsigned int v9 = v3;
  }
  else {
    unsigned int v9 = v2;
  }
  if (v8 <= v9 && v8 >= 2)
  {
    unsigned __int16 v11 = *((_WORD *)this + 229);
    BOOL v12 = ((v11 - 8) & 0xFFF7) == 0
       && ((unsigned __int16 v13 = v7 - 3, v13 >= 8u) || ((0xE1u >> v13) & 1) == 0)
       && *((unsigned __int16 *)this + 244) - 1 < 5;
    if (!*((unsigned char *)this + 561)
      && *((_WORD *)this + 233) != 2
      && (*((_WORD *)this + 229) == 16 || *((_WORD *)this + 229) == 8)
      && v12)
    {
      if (*((unsigned char *)this + 216) == 3)
      {
        unsigned int v14 = *((_DWORD *)this + 53);
        if (v14)
        {
          if (v14 >= (v2 + 31) >> 5 && v14 >= (v3 + 31) >> 5)
          {
            if (v14 >= (v2 + 15) >> 4 && v14 >= (v3 + 15) >> 4)
            {
              if (v14 >= (v2 + 7) >> 3 && v14 >= (v3 + 7) >> 3)
              {
                if (v14 >= (v2 + 3) >> 2 && v14 >= (v3 + 3) >> 2)
                {
                  if (v14 >= (v2 + 1) >> 1)
                  {
                    if (v14 >= (v3 + 1) >> 1) {
                      unsigned int v15 = 1;
                    }
                    else {
                      unsigned int v15 = 2;
                    }
                  }
                  else
                  {
                    unsigned int v15 = 2;
                  }
                }
                else
                {
                  unsigned int v15 = 4;
                }
                goto LABEL_56;
              }
LABEL_52:
              unsigned int v15 = 8;
              goto LABEL_56;
            }
LABEL_50:
            unsigned int v15 = 16;
            goto LABEL_56;
          }
LABEL_48:
          unsigned int v15 = 32;
          goto LABEL_56;
        }
        unsigned int v15 = 1;
      }
      else if (v8 <= 0x7F)
      {
        if (v8 <= 0x3F)
        {
          if (v8 <= 0x1F)
          {
            if (v8 <= 0xF)
            {
              if (v8 <= 7)
              {
                if (v8 <= 3) {
                  unsigned int v15 = 2;
                }
                else {
                  unsigned int v15 = 4;
                }
                goto LABEL_56;
              }
              goto LABEL_52;
            }
            goto LABEL_50;
          }
          goto LABEL_48;
        }
        unsigned int v15 = 64;
      }
      else
      {
        unsigned int v15 = 128;
      }
LABEL_56:
      *((_WORD *)this + 158) = v15;
      *((_DWORD *)this + 65) = v2 / v15;
      *((_DWORD *)this + 66) = v3 / v15;
      *((_DWORD *)this + 67) = ((v2 * v11 * *((unsigned __int16 *)this + 244) + 7) >> 3) / v15;
    }
  }
  return 0;
}

uint64_t TIFFReadPlugin::handleColorSpace(TIFFReadPlugin *this, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  int v10 = 1380401696;
  unsigned int length = 0;
  int v11 = *((unsigned __int16 *)this + 244);
  int v12 = *((unsigned __int16 *)this + 231);
  *((_DWORD *)this + 81) = 0;
  int v13 = v11 - v12;
  switch(*((_WORD *)this + 228))
  {
    case 0:
    case 1:
      if (v13 != 1) {
        goto LABEL_5;
      }
      int v10 = 1196573017;
      goto LABEL_20;
    case 2:
LABEL_5:
      if (v13 == 3) {
        goto LABEL_20;
      }
      goto LABEL_17;
    case 3:
      if (v13 == 1) {
        goto LABEL_20;
      }
      goto LABEL_17;
    case 4:
    case 7:
      goto LABEL_17;
    case 5:
      if (v13 != 4) {
        goto LABEL_17;
      }
      int v10 = 1129142603;
      goto LABEL_20;
    case 6:
      if (v13 != 3) {
        goto LABEL_17;
      }
      int v14 = *((unsigned __int16 *)this + 232);
      if (v14 == 1) {
        goto LABEL_20;
      }
      if (v14 == 7)
      {
        *((_DWORD *)this + 81) = 1380401696;
        _cg_TIFFSetField(*((void *)this + 55), 65538, a3, a4, a5, a6, a7, a8, 1);
        *((_WORD *)this + 228) = 2;
        if (*((_DWORD *)this + 81)) {
          goto LABEL_21;
        }
      }
LABEL_17:
      _cg_jpeg_mem_term("handleColorSpace", 1117, "*** unsupported colormodel (0)\n");
      return 4294967246;
    case 8:
    case 9:
    case 0xA:
      if (v13 != 3) {
        goto LABEL_17;
      }
      int v10 = 1281450528;
LABEL_20:
      *((_DWORD *)this + 81) = v10;
LABEL_21:
      _cg_TIFFGetField(*((void **)this + 55), 34675, a3, a4, a5, a6, a7, a8, (uint64_t)&length);
      if (!length) {
        goto LABEL_74;
      }
      uint64_t v16 = (CGColorSpace *)CGColorSpaceCreateWithCopyOfData(0, length);
      *((void *)this + 20) = v16;
      CGColorSpaceModel Model = CGColorSpaceGetModel(v16);
      CGColorSpaceModel v18 = Model;
      int v19 = Model > kCGColorSpaceModelXYZ ? 1061109567 : dword_188990724[Model];
      if (v19 == *((_DWORD *)this + 81)) {
        goto LABEL_74;
      }
      unsigned int v20 = Model >> 24;
      uint64_t v21 = MEMORY[0x1E4F14390];
      if (Model < 0) {
        int v22 = __maskrune(Model >> 24, 0x40000uLL);
      }
      else {
        int v22 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v20 + 60) & 0x40000;
      }
      if (v22) {
        uint64_t v23 = v20;
      }
      else {
        uint64_t v23 = 46;
      }
      unsigned int v24 = v18 << 8 >> 24;
      if (v18 << 8 < 0) {
        int v25 = __maskrune(v18 << 8 >> 24, 0x40000uLL);
      }
      else {
        int v25 = *(_DWORD *)(v21 + 4 * v24 + 60) & 0x40000;
      }
      if (v25) {
        uint64_t v26 = v24;
      }
      else {
        uint64_t v26 = 46;
      }
      unsigned int v27 = (__int16)v18 >> 8;
      if (v18 << 16 < 0) {
        int v28 = __maskrune((__int16)v18 >> 8, 0x40000uLL);
      }
      else {
        int v28 = *(_DWORD *)(v21 + 4 * v27 + 60) & 0x40000;
      }
      if (v28) {
        uint64_t v29 = v27;
      }
      else {
        uint64_t v29 = 46;
      }
      if ((v18 << 24) <= 0x7F000000) {
        int v30 = *(_DWORD *)(v21 + 4 * (char)v18 + 60) & 0x40000;
      }
      else {
        int v30 = __maskrune((char)v18, 0x40000uLL);
      }
      if (v30) {
        uint64_t v31 = (char)v18;
      }
      else {
        uint64_t v31 = 46;
      }
      int v32 = *((_DWORD *)this + 81);
      unsigned int v33 = v32 >> 24;
      if (v32 < 0)
      {
        int v34 = __maskrune(v33, 0x40000uLL);
        int v32 = *((_DWORD *)this + 81);
      }
      else
      {
        int v34 = *(_DWORD *)(v21 + 4 * v33 + 60) & 0x40000;
      }
      if (v34) {
        uint64_t v35 = (v32 >> 24);
      }
      else {
        uint64_t v35 = 46;
      }
      unsigned int v36 = v32 << 8 >> 24;
      if (v32 << 8 < 0)
      {
        int v37 = __maskrune(v36, 0x40000uLL);
        int v32 = *((_DWORD *)this + 81);
      }
      else
      {
        int v37 = *(_DWORD *)(v21 + 4 * v36 + 60) & 0x40000;
      }
      if (v37) {
        uint64_t v38 = (v32 << 8 >> 24);
      }
      else {
        uint64_t v38 = 46;
      }
      unsigned int v39 = (__int16)v32 >> 8;
      if (v32 << 16 < 0)
      {
        int v40 = __maskrune(v39, 0x40000uLL);
        int v32 = *((_DWORD *)this + 81);
      }
      else
      {
        int v40 = *(_DWORD *)(v21 + 4 * v39 + 60) & 0x40000;
      }
      if (v40) {
        uint64_t v41 = ((__int16)v32 >> 8);
      }
      else {
        uint64_t v41 = 46;
      }
      if ((v32 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(v21 + 4 * (char)v32 + 60) & 0x40000) != 0) {
          goto LABEL_70;
        }
      }
      else if (__maskrune((char)v32, 0x40000uLL))
      {
LABEL_70:
        int v42 = *((_DWORD *)this + 81);
        goto LABEL_73;
      }
      LOBYTE(v42) = 46;
LABEL_73:
      LogError("handleColorSpace", 1153, "*** embeded '%c%c%c%c' ColorSync profile doesn't match image '%c%c%c%c'\n", v23, v26, v29, v31, v35, v38, v41, (char)v42);
      *((void *)this + 20) = 0;
LABEL_74:
      if (!*((void *)this + 20) && *((_DWORD *)this + 81) == 1380401696)
      {
        LOBYTE(length_4[0]) = 0;
        CGColorSpaceRef ColorSpaceFromMetadata = createColorSpaceFromMetadata(*((const __CFDictionary **)this + 8), a2, length_4);
        *((void *)this + 20) = ColorSpaceFromMetadata;
        if (LOBYTE(length_4[0])) {
          *((_WORD *)this + 164) = 1;
        }
        if (!ColorSpaceFromMetadata && *((_DWORD *)this + 81) == 1380401696)
        {
          CFDictionaryRef TopLevelTag = CGImageMetadataGetTopLevelTag(*((const __CFDictionary **)this + 8), @"http://ns.adobe.com/exif/1.0/", @"ColorSpace");
          if (TopLevelTag)
          {
            CFStringRef Value = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)TopLevelTag);
            if (Value)
            {
              if (CFStringGetIntValue(Value) == 1) {
                *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
              }
            }
          }
        }
      }
      if (*((_WORD *)this + 228) != 3) {
        goto LABEL_97;
      }
      unint64_t v46 = *((unsigned __int16 *)this + 229);
      if (v46 > 8)
      {
        _cg_jpeg_mem_term("handleColorSpace", 1223, "*** can't handle PHOTOMETRIC_PALETTE with more than 8 bit...\n");
        return 4294967246;
      }
      uint64_t v47 = (unsigned __int8 *)malloc_type_calloc(3uLL, 0x100uLL, 0x8A84BFADuLL);
      *(void *)&length_4[0] = 0;
      whitePoint[0] = 0.0;
      blackPoint[0] = 0.0;
      _cg_TIFFGetField(*((void **)this + 55), 320, v48, v49, v50, v51, v52, v53, (uint64_t)length_4);
      uint64_t v54 = *(unsigned __int16 **)&length_4[0];
      if (!*(void *)&length_4[0])
      {
        _cg_jpeg_mem_term("handleColorSpace", 1199, "*** ERROR: TIFFGetField 'TIFFTAG_COLORMAP' failed (paletteR is NULL)\n");
        return 4294967246;
      }
      CGFloat v55 = whitePoint[0];
      if (!*(void *)&whitePoint[0])
      {
        _cg_jpeg_mem_term("handleColorSpace", 1200, "*** ERROR: TIFFGetField 'TIFFTAG_COLORMAP' failed (paletteG is NULL)\n");
        return 4294967246;
      }
      CGFloat v56 = blackPoint[0];
      if (!*(void *)&blackPoint[0])
      {
        _cg_jpeg_mem_term("handleColorSpace", 1201, "*** ERROR: TIFFGetField 'TIFFTAG_COLORMAP' failed (paletteB is NULL)\n");
        return 4294967246;
      }
      uint64_t v57 = 0;
      uint64_t v58 = 1 << v46;
      do
      {
        unsigned int v59 = *v54++;
        uint64_t v60 = &v47[v57];
        *uint64_t v60 = ((255 - (((unint64_t)v59 + 128) >> 8)) >> 31) | ((unsigned __int16)(v59 + 128) >> 8);
        unsigned int v61 = (unsigned __int16)**(_WORD **)&v55;
        *(void *)&v55 += 2;
        v60[1] = ((255 - (((unint64_t)v61 + 128) >> 8)) >> 31) | ((unsigned __int16)(v61 + 128) >> 8);
        unsigned int v62 = (unsigned __int16)**(_WORD **)&v56;
        *(void *)&v56 += 2;
        v60[2] = ((255 - (((unint64_t)v62 + 128) >> 8)) >> 31) | ((unsigned __int16)(v62 + 128) >> 8);
        v57 += 3;
      }
      while (3 * (1 << v46) != v57);
      unsigned int v63 = (CGColorSpace *)*((void *)this + 20);
      if (!v63) {
        unsigned int v63 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
      }
      if ((unint64_t)(v58 - 1) >= 0xFF) {
        size_t v64 = 255;
      }
      else {
        size_t v64 = v58 - 1;
      }
      *((void *)this + 20) = CGColorSpaceCreateIndexed(v63, v64, v47);
      free(v47);
      CFRelease(v63);
LABEL_97:
      Lab = (CGColorSpace *)*((void *)this + 20);
      if (!Lab)
      {
        if (*((_DWORD *)this + 81) == 1281450528)
        {
          *(_OWORD *)whitePoint = xmmword_1889906C0;
          uint64_t v72 = 0x3FEA6594AF4F0D84;
          memset(blackPoint, 0, sizeof(blackPoint));
          length_4[0] = xmmword_1889906D8;
          length_4[1] = unk_1889906E8;
          Lab = CGColorSpaceCreateLab(whitePoint, blackPoint, (const CGFloat *)length_4);
          *((void *)this + 20) = Lab;
        }
        else
        {
          Lab = 0;
        }
      }
      if (!*((unsigned char *)this + 345) && !*((unsigned char *)this + 566)) {
        return 0;
      }
      if (Lab)
      {
        if (CGColorSpaceUsesExtendedRange(Lab)) {
          return 0;
        }
        CGColorSpaceRef Extended = CGColorSpaceCreateExtended(*((CGColorSpaceRef *)this + 20));
        CGColorSpaceRelease(*((CGColorSpaceRef *)this + 20));
        uint64_t result = 0;
        *((void *)this + 20) = Extended;
      }
      else
      {
        CGColorSpaceRef v66 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBE0]);
        uint64_t result = 0;
        *((void *)this + 20) = v66;
      }
      return result;
    default:
      if (*((unsigned __int16 *)this + 228) == 32845) {
        goto LABEL_20;
      }
      goto LABEL_17;
  }
}

uint64_t TIFFReadPlugin::calculateBlockCount(TIFFReadPlugin *this)
{
  uint64_t result = 0;
  int v3 = *((_DWORD *)this + 74);
  *((_DWORD *)this + 26) = 1;
  *((_DWORD *)this + 27) = v3;
  unsigned int v4 = *((_DWORD *)this + 113);
  if (v4 >= 0x801 && v4 * (unint64_t)*((unsigned int *)this + 112) > 0x400000)
  {
    int v5 = *((unsigned __int8 *)this + 552);
    if ((v5 - 2) < 2)
    {
      return 0;
    }
    else if ((v5 - 4) > 1)
    {
      return 4294967292;
    }
    else
    {
      uint64_t result = 0;
      unsigned int v6 = (*((_DWORD *)this + 130) + 2047) / *((_DWORD *)this + 130) * *((_DWORD *)this + 130);
      *((_DWORD *)this + 26) = (v4 + v6 - 1) / v6;
      *((_DWORD *)this + 27) = v6;
    }
  }
  return result;
}

uint64_t TIFFReadPlugin::loadTIFFStructure(TIFFReadPlugin *this, GlobalTIFFInfo *a2, IIOImageReadSession *a3)
{
  __int16 v4 = 0;
  if (a2
    && *((unsigned int *)this + 52) < (unint64_t)((uint64_t)(*((void *)a2 + 3) - *((void *)a2 + 2)) >> 3))
  {
    operator new();
  }
  return 0;
}

void sub_18871F3AC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C40F2E54FF0);
  _Unwind_Resume(a1);
}

uint64_t TIFFReadPlugin::decodeSubsampled(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v3 = *(unsigned int *)(a1 + 264);
  if (*(void *)(a1 + 360) < v3) {
    unint64_t v3 = *(void *)(a1 + 360);
  }
  unint64_t v4 = *(unsigned __int16 *)(a1 + 316);
  if (!*(_WORD *)(a1 + 316)) {
    return 4294967246;
  }
  *(void *)uint64_t v47 = *(unsigned int *)(a1 + 236);
  if (v3 <= v4)
  {
    unsigned int v7 = 2 * v4;
    unsigned int v6 = 2;
  }
  else
  {
    unsigned int v6 = v3 / v4;
    unsigned int v7 = v6 * v4;
  }
  int v8 = *(unsigned __int16 *)(a1 + 304);
  uint64_t v41 = *a3;
  unsigned int v49 = v6;
  int v42 = (unsigned __int8 *)malloc_type_malloc(v47[0] * (unint64_t)v7, 0x9CE2FDE8uLL);
  if (!v42) {
    return 4294967246;
  }
  unsigned int v9 = *(unsigned __int16 *)(a1 + 308);
  if (v9 == 4)
  {
    if (*(_WORD *)(a1 + 306) == 32)
    {
      if (*(unsigned char *)(a1 + 405)) {
        __int16 v10 = 1;
      }
      else {
        __int16 v10 = 3;
      }
    }
    else
    {
      __int16 v10 = 1;
    }
  }
  else
  {
    __int16 v10 = 0;
  }
  memset(v48, 0, sizeof(v48));
  if (*(unsigned __int16 *)(a1 + 244) >= v9) {
    __int16 v12 = v9;
  }
  else {
    __int16 v12 = *(_WORD *)(a1 + 244);
  }
  IIOSubsampler::IIOSubsampler((IIOSubsampler *)v48, *(_DWORD *)(a1 + 228), v47[0], (*(unsigned __int8 *)(a1 + 247) << 12) | (*(unsigned __int8 *)(a1 + 248) << 16) | ((*(unsigned char *)(a1 + 249) != 0) << 8) | *(unsigned __int8 *)(a1 + 246), *(_WORD *)(a1 + 240), v12, *(_WORD *)(a1 + 316), v10, *(_DWORD *)(a1 + 292), *(_DWORD *)(a1 + 300));
  unsigned int v17 = *(_DWORD *)(a1 + 232);
  if (v17)
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    unsigned int v40 = v7;
    unsigned int v45 = (v8 + 7) >> 3;
    while (1)
    {
      if (v18 + v7 >= v17)
      {
        unsigned int v20 = v17 - v18;
        unsigned int v49 = (v17 - v18) / *(unsigned __int16 *)(a1 + 316);
        if (!v49) {
          goto LABEL_45;
        }
      }
      else
      {
        unsigned int v20 = v7;
        if (!v49) {
          goto LABEL_45;
        }
      }
      uint64_t v44 = v19;
      unsigned int v43 = v20;
      uint64_t v21 = v20 + v18;
      if (v18 < v21) {
        break;
      }
LABEL_44:
      IIOSubsampler::subsample((IIOSubsampler *)v48, v42, v43, (unsigned __int8 *)(v41 + v44 * *(unsigned int *)(a1 + 300)), &v49);
      uint64_t v19 = v44 + v49;
      unsigned int v17 = *(_DWORD *)(a1 + 232);
      uint64_t v18 = v21;
      unsigned int v7 = v40;
      if (v21 >= v17) {
        goto LABEL_45;
      }
    }
    int v22 = v42;
    while (1)
    {
      int v23 = _cg_TIFFReadScanline(a2, v22, v18, 0, v13, v14, v15, v16);
      uint64_t v24 = *(unsigned __int16 *)(a1 + 244);
      size_t v25 = *(unsigned __int16 *)(a1 + 308);
      if (v24 > v25)
      {
        switch(v45)
        {
          case 1u:
            int v36 = *(_DWORD *)(a1 + 228);
            if (v36)
            {
              int v37 = v22;
              uint64_t v38 = v22;
              do
              {
                memmove(v37, v38, v25);
                v38 += v24;
                v37 += v25;
                --v36;
              }
              while (v36);
            }
            break;
          case 2u:
            int v31 = *(_DWORD *)(a1 + 228);
            if (v31)
            {
              size_t v32 = 2 * v25;
              uint64_t v33 = 2 * v24;
              int v34 = v22;
              uint64_t v35 = v22;
              do
              {
                memmove(v35, v34, v32);
                v35 += v32;
                v34 += v33;
                --v31;
              }
              while (v31);
            }
            break;
          case 4u:
            int v26 = *(_DWORD *)(a1 + 228);
            if (v26)
            {
              size_t v27 = 4 * v25;
              uint64_t v28 = 4 * v24;
              uint64_t v29 = v22;
              int v30 = v22;
              do
              {
                memmove(v30, v29, v27);
                v30 += v27;
                v29 += v28;
                --v26;
              }
              while (v26);
            }
            break;
        }
      }
      if (v23 == -1) {
        break;
      }
      v22 += *(void *)v47;
      uint64_t v18 = (v18 + 1);
      if (v18 == v21) {
        goto LABEL_44;
      }
    }
    _cg_jpeg_mem_term("decodeSubsampled", 1739, "*** ERROR: TIFFReadScanline returned -1\n");
    IIOSubsampler::~IIOSubsampler((IIOSubsampler *)v48);
    uint64_t v11 = 4294967246;
  }
  else
  {
LABEL_45:
    IIOSubsampler::~IIOSubsampler((IIOSubsampler *)v48);
    uint64_t v11 = 0;
  }
  free(v42);
  return v11;
}

void sub_18871F714(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  IIOSubsampler::~IIOSubsampler((IIOSubsampler *)va);
  _Unwind_Resume(a1);
}

uint64_t TIFFReadPlugin::decodeStripChunky(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v3 = *(void *)(a1 + 480);
  unint64_t v4 = *(unsigned int *)(a1 + 472);
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  if (!v4) {
    return 4294967246;
  }
  uint64_t v13 = malloc_type_malloc(v3, 0x5D5FB501uLL);
  if (*(unsigned __int16 *)(a1 + 456) == 32845)
  {
    uint64_t v14 = 0;
    goto LABEL_17;
  }
  uint64_t v62 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
  uint64_t v63 = v15;
  unsigned int v16 = *(unsigned __int16 *)(a1 + 244);
  if (v16 > *(unsigned __int16 *)(a1 + 308)) {
    LOWORD(v63) = *(_WORD *)(a1 + 308);
  }
  if (*(_WORD *)(a1 + 274) == 32 && *(_WORD *)(a1 + 272) == 8)
  {
    if (v16 == 3)
    {
      BYTE6(v62) = -1;
      BYTE4(v62) = 0;
      if (*(unsigned char *)(a1 + 405)) {
        char v17 = 2;
      }
      else {
        char v17 = 5;
      }
LABEL_15:
      BYTE5(v62) = v17;
      goto LABEL_16;
    }
    if (v16 == 4)
    {
      char v17 = 2;
      BYTE4(v62) = 2;
      if (!*(unsigned char *)(a1 + 405)) {
        char v17 = 3;
      }
      goto LABEL_15;
    }
  }
LABEL_16:
  uint64_t v14 = ImageIOPixelConverter::CreatePixelConverter(&v62);
LABEL_17:
  unsigned int v18 = *(_DWORD *)(a3 + 20);
  if (v18 >= *(_DWORD *)(a3 + 24))
  {
LABEL_59:
    uint64_t v51 = 0;
    if (!v14) {
      goto LABEL_61;
    }
  }
  else
  {
    uint64_t v19 = (v3 / v4);
    uint64_t v54 = a2;
    CGFloat v55 = v13;
    uint64_t v59 = v14;
    uint64_t v60 = a3;
    unint64_t v57 = v3;
    uint64_t v58 = v19;
    int v53 = v4;
    while (1)
    {
      uint64_t v20 = *(_DWORD *)(a1 + 472) ? _cg_TIFFComputeStrip(a2, v18, 0, v8, v9, v10, v11, v12) : 0;
      if (_cg_TIFFReadEncodedStrip(a2, v20, v13, -1, v9, v10, v11, v12) > v3) {
        break;
      }
      unsigned int v21 = v18 + v4;
      unsigned int v22 = *(_DWORD *)(a3 + 24);
      if (v18 + v4 >= v22) {
        unsigned int v23 = *(_DWORD *)(a3 + 24);
      }
      else {
        unsigned int v23 = v18 + v4;
      }
      unsigned int v61 = v23;
      if (v18 < v23)
      {
        unsigned int v56 = v18 + v4;
        uint64_t v24 = (_WORD *)(*(void *)a3 + (v18 - *(_DWORD *)(a3 + 20)) * *(_DWORD *)(a3 + 36));
        size_t v25 = (__int16 *)v13;
        do
        {
          if (*(unsigned __int16 *)(a1 + 456) == 32845)
          {
            int v26 = *(unsigned __int16 *)(a1 + 240);
            if (v26 == 16)
            {
              ConvertLineXYZToRGB<half>(v25, v24, *(_DWORD *)(a3 + 28));
            }
            else if (v26 == 32)
            {
              int v27 = *(unsigned __int16 *)(a1 + 272);
              if (v27 == 16)
              {
                int v34 = *(_DWORD *)(a3 + 28);
                if (v34)
                {
                  uint64_t v35 = v24;
                  int v36 = (float *)v25;
                  do
                  {
                    double v37 = *v36;
                    double v38 = v36[1];
                    double v39 = v36[2];
                    _D2 = v38 * -1.276 + v37 * 2.69 + v39 * -0.414;
                    __asm { FCVT            H2, D2 }
                    *uint64_t v35 = LOWORD(_D2);
                    _D2 = v38 * 1.978 + v37 * -1.022 + v39 * 0.044;
                    __asm { FCVT            H2, D2 }
                    _D0 = v38 * -0.224 + v37 * 0.061 + v39 * 1.163;
                    v35[1] = LOWORD(_D2);
                    __asm { FCVT            H0, D0 }
                    v35[2] = LOWORD(_D0);
                    v35[3] = COERCE_UNSIGNED_INT(1.0);
                    v36 += 3;
                    v35 += 4;
                    --v34;
                  }
                  while (v34);
                }
              }
              else if (v27 == 32)
              {
                ConvertLineXYZToRGB<float>((float *)v25, (float *)v24, *(_DWORD *)(a3 + 28));
              }
            }
          }
          else
          {
            uint64_t v28 = *(unsigned __int16 *)(a1 + 244);
            size_t v29 = *(unsigned __int16 *)(a1 + 308);
            if (v28 > v29)
            {
              int v30 = *(_DWORD *)(a1 + 228);
              if (v57 >= ((*(unsigned __int16 *)(a1 + 242) + 7) >> 3) * v30)
              {
                int v31 = *(unsigned __int16 *)(a1 + 240);
                if (v31 == 32)
                {
                  if (v30)
                  {
                    uint64_t v47 = v25;
                    uint64_t v48 = v25;
                    do
                    {
                      memmove(v47, v48, 4 * v29);
                      v48 += 2 * v28;
                      v47 += 2 * v29;
                      --v30;
                    }
                    while (v30);
                  }
                }
                else if (v31 == 16)
                {
                  if (v30)
                  {
                    unsigned int v49 = v25;
                    uint64_t v50 = v25;
                    do
                    {
                      memmove(v49, v50, 2 * v29);
                      v50 += v28;
                      v49 += v29;
                      --v30;
                    }
                    while (v30);
                  }
                }
                else if (v31 == 8 && v30)
                {
                  size_t v32 = v25;
                  uint64_t v33 = v25;
                  do
                  {
                    memmove(v32, v33, v29);
                    uint64_t v33 = (__int16 *)((char *)v33 + v28);
                    size_t v32 = (__int16 *)((char *)v32 + v29);
                    --v30;
                  }
                  while (v30);
                }
              }
            }
            uint64_t v14 = v59;
            a3 = v60;
            (*(void (**)(uint64_t, __int16 *, _WORD *, void))(*(void *)v59 + 24))(v59, v25, v24, *(unsigned int *)(v60 + 28));
            uint64_t v19 = v58;
          }
          uint64_t v24 = (_WORD *)((char *)v24 + *(unsigned int *)(a3 + 36));
          size_t v25 = (__int16 *)((char *)v25 + v19);
          ++v18;
        }
        while (v18 < v61);
        unsigned int v22 = *(_DWORD *)(a3 + 24);
        a2 = v54;
        uint64_t v13 = v55;
        size_t v3 = v57;
        LODWORD(v4) = v53;
        unsigned int v21 = v56;
      }
      unsigned int v18 = v21;
      if (v21 >= v22) {
        goto LABEL_59;
      }
    }
    uint64_t v51 = 4294967246;
    if (!v14) {
      goto LABEL_61;
    }
  }
  (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
LABEL_61:
  if (v13) {
    free(v13);
  }
  return v51;
}

float *ConvertLineXYZToRGB<float>(float *result, float *a2, int a3)
{
  for (; a3; --a3)
  {
    float v3 = result[1] * -1.276 + *result * 2.69 + result[2] * -0.414;
    *a2 = v3;
    float v4 = result[1] * 1.978 + *result * -1.022 + result[2] * 0.044;
    a2[1] = v4;
    float v5 = result[1] * -0.224 + *result * 0.061 + result[2] * 1.163;
    a2[2] = v5;
    result += 3;
    a2 += 3;
  }
  return result;
}

__int16 *ConvertLineXYZToRGB<half>(__int16 *result, _WORD *a2, int a3)
{
  for (; a3; --a3)
  {
    _H17 = *result;
    __asm { FCVT            D17, H17 }
    _H18 = result[1];
    __asm { FCVT            D18, H18 }
    double v11 = _D18 * -1.276 + _D17 * 2.69;
    LOWORD(_D18) = result[2];
    __asm { FCVT            D18, H18 }
    _D17 = v11 + _D18 * -0.414;
    __asm { FCVT            H17, D17 }
    *a2 = LOWORD(_D17);
    LOWORD(_D17) = *result;
    __asm { FCVT            D17, H17 }
    LOWORD(_D18) = result[1];
    __asm { FCVT            D18, H18 }
    double v16 = _D18 * 1.978 + _D17 * -1.022;
    LOWORD(_D18) = result[2];
    __asm { FCVT            D18, H18 }
    _D17 = v16 + _D18 * 0.044;
    __asm { FCVT            H17, D17 }
    a2[1] = LOWORD(_D17);
    LOWORD(_D17) = *result;
    __asm { FCVT            D17, H17 }
    LOWORD(_D18) = result[1];
    __asm { FCVT            D18, H18 }
    double v21 = _D18 * -0.224 + _D17 * 0.061;
    LOWORD(_D18) = result[2];
    __asm { FCVT            D18, H18 }
    _D17 = v21 + _D18 * 1.163;
    __asm { FCVT            H17, D17 }
    a2[2] = LOWORD(_D17);
    result += 3;
    a2 += 3;
  }
  return result;
}

uint64_t TIFFReadPlugin::decodeStripPlanar(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = a1;
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  unint64_t size = *(void *)(a1 + 480);
  int v6 = *(unsigned __int16 *)(a1 + 304);
  uint64_t v7 = *(unsigned __int16 *)(a1 + 308);
  unint64_t v49 = *(unsigned int *)(a1 + 472);
  int v8 = *((_DWORD *)a3 + 7);
  int v61 = 0;
  uint64_t v60 = 0;
  long long v62 = xmmword_1889906F8;
  int v63 = 4;
  if (*(_WORD *)(a1 + 274) == 32 && *(_WORD *)(a1 + 272) == 8 && !*(unsigned char *)(a1 + 405))
  {
    LODWORD(v62) = 2;
    DWORD2(v62) = 0;
  }
  int v59 = 0;
  LOWORD(v60) = 1542;
  BYTE2(v60) = 0;
  WORD2(v60) = 1;
  HIWORD(v60) = *(_WORD *)(a1 + 240);
  LOWORD(v61) = v6;
  uint64_t v9 = ImageIOPixelConverter::CreatePixelConverter(&v59);
  uint64_t v10 = (char *)malloc_type_malloc(size, 0xF9C3357DuLL);
  if (v10)
  {
    unsigned int v11 = (v6 + 7) >> 3;
    uint64_t v12 = malloc_type_malloc((v8 * v11 + 15) & 0xFFFFFFF0, 0x8000BF95uLL);
    unsigned int v18 = v12;
    if (v12 && (v20 = *((_DWORD *)a3 + 5), unsigned int v19 = *((_DWORD *)a3 + 6), v20 < v19))
    {
      int v47 = *(unsigned __int16 *)(v5 + 462);
      int v48 = *(unsigned __int16 *)(v5 + 488);
      uint64_t v58 = v12;
      if ((v48 - v47) <= 1) {
        uint64_t v21 = 1;
      }
      else {
        uint64_t v21 = (v48 - v47);
      }
      uint64_t v50 = v21;
      uint64_t v51 = a2;
      uint64_t v54 = v10;
      while (1)
      {
        unsigned int v55 = v20;
        unsigned int v22 = v20 + v49;
        if (v48 != v47) {
          break;
        }
LABEL_39:
        unsigned int v20 = v22;
        if (v22 >= v19) {
          goto LABEL_40;
        }
      }
      unsigned int v53 = v20 + v49;
      uint64_t v23 = 0;
      while (1)
      {
        uint64_t v56 = v23;
        uint64_t v24 = *(_DWORD *)(v5 + 472)
            ? _cg_TIFFComputeStrip(a2, v55, (unsigned __int16)v23, v13, v14, v15, v16, v17)
            : 0;
        unsigned int v25 = v53;
        if (_cg_TIFFReadEncodedStrip(a2, v24, v10, -1, v14, v15, v16, v17) > size) {
          break;
        }
        uint64_t v26 = v5;
        if (v53 >= *((_DWORD *)a3 + 6)) {
          unsigned int v25 = *((_DWORD *)a3 + 6);
        }
        unsigned int v18 = v58;
        if (v55 < v25)
        {
          uint64_t v57 = *((_DWORD *)&v62 + v56) * v11;
          unsigned int v27 = v55;
          uint64_t v28 = v54;
          do
          {
            (*(void (**)(uint64_t, char *, void *, void))(*(void *)v9 + 24))(v9, v28, v18, *(unsigned int *)(v26 + 448));
            uint64_t v29 = *a3;
            uint64_t v30 = *((_DWORD *)a3 + 9) * v27;
            if (v11 == 4)
            {
              int v39 = *((_DWORD *)a3 + 7);
              unsigned int v18 = v58;
              if (v39)
              {
                unsigned int v40 = (_DWORD *)(v29 + v57 + v30);
                uint64_t v41 = (int *)v58;
                do
                {
                  int v42 = *v41++;
                  *unsigned int v40 = v42;
                  v40 += v7;
                  --v39;
                }
                while (v39);
              }
            }
            else if (v11 == 2)
            {
              int v35 = *((_DWORD *)a3 + 7);
              unsigned int v18 = v58;
              if (v35)
              {
                int v36 = (_WORD *)(v29 + v57 + v30);
                double v37 = (__int16 *)v58;
                do
                {
                  __int16 v38 = *v37++;
                  *int v36 = v38;
                  v36 += v7;
                  --v35;
                }
                while (v35);
              }
            }
            else
            {
              unsigned int v18 = v58;
              if (v11 == 1)
              {
                int v31 = *((_DWORD *)a3 + 7);
                if (v31)
                {
                  size_t v32 = (unsigned char *)(v29 + v57 + v30);
                  uint64_t v33 = (char *)v58;
                  do
                  {
                    char v34 = *v33++;
                    *size_t v32 = v34;
                    v32 += v7;
                    --v31;
                  }
                  while (v31);
                }
              }
            }
            v28 += (size / v49);
            ++v27;
          }
          while (v27 < v25);
        }
        uint64_t v23 = v56 + 1;
        a2 = v51;
        uint64_t v5 = v26;
        uint64_t v10 = v54;
        if (v56 + 1 == v50)
        {
          unsigned int v19 = *((_DWORD *)a3 + 6);
          unsigned int v22 = v53;
          goto LABEL_39;
        }
      }
      uint64_t v43 = 4294967246;
      unsigned int v18 = v58;
    }
    else
    {
LABEL_40:
      uint64_t v43 = 0;
    }
  }
  else
  {
    uint64_t v43 = 0;
    unsigned int v18 = 0;
  }
  if (v9)
  {
    uint64_t v44 = v18;
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
    unsigned int v18 = v44;
  }
  if (v10)
  {
    unsigned int v45 = v18;
    free(v10);
    unsigned int v18 = v45;
  }
  if (v18) {
    free(v18);
  }
  return v43;
}

uint64_t TIFFReadPlugin::decodeTileChunky(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a2;
  size_t v11 = _cg_TIFFTileSize64(a2, a2, a3, a4, a5, a6, a7, a8);
  unsigned int v12 = *(_DWORD *)(a1 + 516);
  if (!v12) {
    return 4294967246;
  }
  size_t v13 = v11;
  int v14 = *(_DWORD *)(a1 + 448);
  int v15 = *(_DWORD *)(a1 + 504);
  int v16 = *(_DWORD *)(a1 + 520);
  int v48 = (char *)malloc_type_malloc(v11, 0x107749BFuLL);
  if (!v48) {
    return 4294967246;
  }
  uint64_t v17 = (v12 + v14 - 1) / v12 * v15;
  int v47 = (char *)malloc_type_malloc((v17 * v16), 0xD0DD013uLL);
  if (!v47)
  {
    uint64_t v21 = 4294967246;
    free(v48);
    return v21;
  }
  v49[0] = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
  v49[1] = v18;
  if (*(_WORD *)(a1 + 274) == 32 && *(_WORD *)(a1 + 272) == 8)
  {
    int v19 = *(unsigned __int16 *)(a1 + 244);
    if (v19 == 3)
    {
      BYTE6(v49[0]) = -1;
      BYTE4(v49[0]) = 0;
      if (!*(unsigned char *)(a1 + 405))
      {
LABEL_13:
        char v20 = 3;
        goto LABEL_14;
      }
      char v20 = 2;
LABEL_14:
      BYTE5(v49[0]) = v20;
      goto LABEL_15;
    }
    if (v19 == 4)
    {
      char v20 = 2;
      BYTE4(v49[0]) = 2;
      if (!*(unsigned char *)(a1 + 405)) {
        goto LABEL_13;
      }
      goto LABEL_14;
    }
  }
LABEL_15:
  uint64_t PixelConverter = ImageIOPixelConverter::CreatePixelConverter(v49);
  unsigned int v24 = *(_DWORD *)(a3 + 20);
  unsigned int v23 = *(_DWORD *)(a3 + 24);
  if (v24 >= v23)
  {
    uint64_t v21 = 0;
  }
  else
  {
    uint64_t v25 = PixelConverter;
    uint64_t v43 = v9;
    size_t v44 = v13;
    uint64_t v26 = &v47[(v17 * v16)];
    int v27 = *(_DWORD *)(a1 + 520);
    while (1)
    {
      unsigned int v28 = v27 + v24;
      unsigned int v46 = v24;
      unsigned int v29 = v23 - v24;
      unsigned int v30 = v28 <= v23 ? v27 : v29;
      if (*(_DWORD *)(a3 + 28)) {
        break;
      }
LABEL_28:
      if (v46 < v30 + v46)
      {
        uint64_t v40 = *(void *)a3 + (v46 - *(_DWORD *)(a3 + 20)) * *(_DWORD *)(a3 + 36);
        uint64_t v41 = v47;
        do
        {
          (*(void (**)(uint64_t, char *, uint64_t, void))(*(void *)v25 + 24))(v25, v41, v40, *(unsigned int *)(a3 + 28));
          v40 += *(unsigned int *)(a3 + 36);
          v41 += v17;
          --v30;
        }
        while (v30);
      }
      uint64_t v21 = 0;
      int v27 = *(_DWORD *)(a1 + 520);
      unsigned int v24 = v27 + v46;
      unsigned int v23 = *(_DWORD *)(a3 + 24);
      if (v27 + v46 >= v23) {
        goto LABEL_35;
      }
    }
    unsigned int v31 = 0;
    uint64_t v32 = 0;
    while (1)
    {
      bzero(v48, v44);
      if (_cg_TIFFReadTile(v9, (unsigned __int8 *)v48, v32, v46, 0, 0, v33, v34) == -1) {
        break;
      }
      uint64_t v35 = v31;
      size_t v36 = *(void *)(a1 + 504);
      unsigned int v45 = v31;
      if (v30)
      {
        int v37 = 0;
        __int16 v38 = v48;
        int v39 = &v47[v35];
        while (&v39[v36] <= v26)
        {
          memcpy(v39, v38, v36);
          size_t v36 = *(void *)(a1 + 504);
          v38 += v36;
          v39 += v17;
          if (++v37 >= v30) {
            goto LABEL_27;
          }
        }
        break;
      }
LABEL_27:
      uint64_t v32 = (*(_DWORD *)(a1 + 516) + v32);
      unsigned int v31 = v36 + v45;
      uint64_t v9 = v43;
      if (v32 >= *(_DWORD *)(a3 + 28)) {
        goto LABEL_28;
      }
    }
    uint64_t v21 = 4294967246;
  }
LABEL_35:
  free(v48);
  free(v47);
  return v21;
}

uint64_t TIFFReadPlugin::decodeTilePlanar(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  size_t size = *(void *)(a1 + 528);
  if (!size) {
    size_t size = *(void *)(a1 + 480);
  }
  unsigned int v5 = (*(unsigned __int16 *)(a1 + 304) + 7) >> 3;
  uint64_t v6 = *(unsigned __int16 *)(a1 + 308);
  unsigned int v7 = *(unsigned __int16 *)(a1 + 306) + 7;
  int v59 = 0;
  uint64_t v58 = 0;
  long long v60 = xmmword_1889906F8;
  int v61 = 4;
  if (*(_WORD *)(a1 + 274) == 32 && !*(unsigned char *)(a1 + 405))
  {
    LODWORD(v60) = 2;
    DWORD2(v60) = 0;
  }
  unsigned int v45 = v7 >> 3;
  if (*(_DWORD *)(a1 + 516) <= *(_DWORD *)(a1 + 448)) {
    int v8 = *(_DWORD *)(a1 + 448);
  }
  else {
    int v8 = *(_DWORD *)(a1 + 516);
  }
  if (v5 > 4 || ((1 << v5) & 0x16) == 0)
  {
    LogError("decodeTilePlanar", 2107, "*** ERROR: decodeTilePlanar cannot handle %d bytes/component (%5d bpp)\n", v5, v45);
    return 4294967246;
  }
  uint64_t v51 = (char *)malloc_type_malloc(size, 0xE340F833uLL);
  if (!v51) {
    return 4294967246;
  }
  uint64_t v56 = (int *)malloc_type_malloc((v8 * v45 + 15) & 0xFFFFFFF0, 0x66807B0FuLL);
  if (!v56)
  {
    free(v51);
    return 4294967246;
  }
  int v57 = 0;
  LOWORD(v58) = 1542;
  BYTE2(v58) = 0;
  WORD2(v58) = 1;
  HIWORD(v58) = *(_WORD *)(a1 + 240);
  LOWORD(v59) = *(_WORD *)(a1 + 304);
  BYTE2(v59) = 0;
  uint64_t v10 = ImageIOPixelConverter::CreatePixelConverter(&v57);
  uint64_t v11 = 0;
  unsigned int v13 = a3[5];
  unsigned int v12 = a3[6];
  if (v13 < v12)
  {
    uint64_t v14 = v10;
    int v15 = *(unsigned __int16 *)(a1 + 488);
    int v16 = *(unsigned __int16 *)(a1 + 462);
    unint64_t v47 = (unsigned __int16)(v15 - v16);
    unsigned int v17 = *(_DWORD *)(a1 + 520);
    uint64_t v54 = a3;
    unsigned int v18 = a3[7];
    unsigned int v19 = v18;
    int v43 = v16;
    int v44 = v15;
    while (1)
    {
      unsigned int v20 = v12 - v13;
      if (v17 + v13 <= v12) {
        unsigned int v20 = v17;
      }
      unsigned int v55 = v20;
      if (v19) {
        break;
      }
      v13 += v17;
LABEL_49:
      if (v13 >= v12)
      {
        uint64_t v11 = 0;
        goto LABEL_52;
      }
    }
    unsigned int v21 = 0;
    unsigned int v22 = *(_DWORD *)(a1 + 516);
    unsigned int v53 = v13;
    while (1)
    {
      unsigned int v23 = v22 + v21;
      unsigned int v24 = v22 + v21 <= v19 ? v22 : v19 - v21;
      if (v15 != v16) {
        break;
      }
LABEL_46:
      unsigned int v19 = v18;
      unsigned int v21 = v23;
      if (v23 >= v18)
      {
        unsigned int v17 = *(_DWORD *)(a1 + 520);
        unsigned int v12 = v54[6];
        v13 += v17;
        unsigned int v19 = v18;
        goto LABEL_49;
      }
    }
    uint64_t v25 = 0;
    unsigned int v50 = v21;
    uint64_t v46 = v21 * v45;
    while (1)
    {
      bzero(v51, size);
      uint64_t v52 = v25;
      if (_cg_TIFFReadTileWithSize(a2, (unsigned __int8 *)v51, size, v50, v53, 0, (unsigned __int16)v25, v26) == -1) {
        break;
      }
      if (v55)
      {
        unsigned int v27 = 0;
        unsigned int v28 = v51;
        unsigned int v29 = (_DWORD *)(*(void *)v54 + v46 + (v53 - v54[5]) * v54[9] + *((_DWORD *)&v60 + v52) * v5);
        do
        {
          (*(void (**)(uint64_t, char *, int *, void))(*(void *)v14 + 24))(v14, v28, v56, *(unsigned int *)(a1 + 516));
          if (v5 == 4)
          {
            if (v24)
            {
              __int16 v38 = v29;
              unsigned int v39 = v24;
              uint64_t v40 = v56;
              do
              {
                int v41 = *v40++;
                _DWORD *v38 = v41;
                v38 += v6;
                --v39;
              }
              while (v39);
            }
          }
          else if (v5 == 2)
          {
            if (v24)
            {
              uint64_t v34 = v29;
              unsigned int v35 = v24;
              size_t v36 = (__int16 *)v56;
              do
              {
                __int16 v37 = *v36++;
                *uint64_t v34 = v37;
                v34 += v6;
                --v35;
              }
              while (v35);
            }
          }
          else if (v5 == 1 && v24)
          {
            unsigned int v30 = v24;
            unsigned int v31 = v29;
            uint64_t v32 = (char *)v56;
            do
            {
              char v33 = *v32++;
              *unsigned int v31 = v33;
              v31 += v6;
              --v30;
            }
            while (v30);
          }
          v28 += *(void *)(a1 + 504);
          unsigned int v29 = (_DWORD *)((char *)v29 + v54[9]);
          ++v27;
        }
        while (v27 < v55);
      }
      uint64_t v25 = v52 + 1;
      unsigned int v13 = v53;
      if (v52 + 1 >= v47)
      {
        unsigned int v22 = *(_DWORD *)(a1 + 516);
        unsigned int v18 = v54[7];
        unsigned int v23 = v22 + v50;
        int v16 = v43;
        int v15 = v44;
        goto LABEL_46;
      }
    }
    LogError("decodeTilePlanar", 2142, "*** ERROR: TIFFReadTileWithSize failed\n");
    uint64_t v11 = 4294967246;
  }
LABEL_52:
  free(v51);
  free(v56);
  return v11;
}

uint64_t TIFFReadPlugin::decodeRGBAImage(uint64_t a1, void *a2, uint64_t a3)
{
  unsigned int v4 = *(_DWORD *)(a1 + 228);
  if (*(unsigned int *)(a1 + 236) * (unint64_t)v4 <= 0xF4240)
  {
    unint64_t v6 = *(void *)(a1 + 184);
    BOOL v7 = v6 >= 0x400;
    unint64_t v8 = *(unsigned int *)(a1 + 232) * (unint64_t)v4;
    unint64_t v9 = 300 * v6;
    uint64_t v5 = !v7 || v8 > v9;
  }
  else
  {
    uint64_t v5 = 1;
  }
  if ((_cg_TIFFReadRGBAImageOriented(a2, *(unsigned int *)(a3 + 28), *(unsigned int *)(a3 + 32), *(void *)a3, 1, v5) & 0x80000000) != 0) {
    return 4294967246;
  }
  v14.data = *(void **)a3;
  uint64_t v11 = *(void *)(a3 + 28);
  v12.i64[0] = v11;
  v12.i64[1] = HIDWORD(v11);
  *(int8x16_t *)&v14.vImagePixelCount height = vextq_s8(v12, v12, 8uLL);
  v14.size_t rowBytes = *(unsigned int *)(a3 + 36);
  vImagePermuteChannels_ARGB8888(&v14, &v14, TIFFReadPlugin::decodeRGBAImage(tiff *,IIODecodeInfo)::permuteMap, 0x10u);
  return 0;
}

uint64_t TIFFReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  uint64_t v84 = 0;
  uint64_t v85 = &v84;
  uint64_t v86 = 0x2000000000;
  int v87 = 0;
  uint64_t v81 = 0;
  uint64_t v82 = 0;
  unint64_t v83 = 0;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v8 = *((_DWORD *)this + 51);
    unsigned int v9 = v8 >> 24;
    uint64_t v10 = MEMORY[0x1E4F14390];
    if (v8 < 0)
    {
      int v11 = __maskrune(v9, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
    }
    if (v11) {
      uint64_t v12 = (v8 >> 24);
    }
    else {
      uint64_t v12 = 46;
    }
    unsigned int v13 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      int v14 = __maskrune(v13, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    }
    if (v14) {
      uint64_t v15 = (v8 << 8 >> 24);
    }
    else {
      uint64_t v15 = 46;
    }
    unsigned int v16 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      int v17 = __maskrune(v16, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = ((__int16)v8 >> 8);
    }
    else {
      uint64_t v18 = 46;
    }
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0) {
        goto LABEL_22;
      }
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_22:
      int v19 = *((_DWORD *)this + 51);
LABEL_25:
      ImageIOLog("  '%c%c%c%c' [%s] %s\n", v12, v15, v18, (char)v19, iioTypeStr[a3], "virtual OSStatus TIFFReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    LOBYTE(v19) = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  if (!*((unsigned char *)this + 414))
  {
    uint64_t v22 = 4294967115;
    goto LABEL_80;
  }
  unsigned int v20 = (IIOImageRead **)*((void *)this + 3);
  if (v20)
  {
    BOOL v21 = IIOImageReadSession::mapData(v20);
    unsigned int v20 = (IIOImageRead **)*((void *)this + 3);
  }
  else
  {
    BOOL v21 = 0;
  }
  unsigned int v30 = IIOImageReadSession::globalInfoForType((IIOImageReadSession *)v20, 1414088262);
  if (v30)
  {
    if (a3 == 3)
    {
      TIFFReadPlugin::calculateBlockCount(this);
      int BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
      uint64_t v72 = a4;
      *((_DWORD *)v85 + 6) = BlockArray;
      long long v78 = 0uLL;
      if (*((_DWORD *)this + 26))
      {
        unsigned int v33 = 0;
        unsigned int v34 = 0;
        while (1)
        {
          *(void *)&long long v79 = __PAIR64__(v33, v34);
          unsigned int v35 = *((_DWORD *)this + 27);
          unsigned int v36 = *((_DWORD *)this + 74);
          if (v35 + v33 > v36) {
            unsigned int v35 = v36 - v33;
          }
          v33 += v35;
          *((void *)&v79 + 1) = __PAIR64__(*((_DWORD *)this + 73), v33);
          unsigned int v37 = *((_DWORD *)this + 75);
          unint64_t v80 = __PAIR64__(v37, v35);
          memory_object_size_t v38 = v37 * (unint64_t)v35;
          unsigned int v39 = (void *)_ImageIO_Malloc(v38, *((void *)this + 48), (memory_object_size_t *)&v78 + 1, (uint64_t)kImageMalloc_TIFF_Data[0], *((_DWORD *)this + 108), 0, 0);
          *(void *)&long long v78 = v39;
          if (!v39) {
            break;
          }
          memset(v39, 255, v38);
          uint64_t v40 = v82;
          if ((unint64_t)v82 >= v83)
          {
            int v44 = v81;
            unint64_t v45 = 0xCCCCCCCCCCCCCCCDLL * ((v82 - v81) >> 3);
            unint64_t v46 = v45 + 1;
            if (v45 + 1 > 0x666666666666666) {
              std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
            }
            if (0x999999999999999ALL * ((uint64_t)(v83 - (void)v81) >> 3) > v46) {
              unint64_t v46 = 0x999999999999999ALL * ((uint64_t)(v83 - (void)v81) >> 3);
            }
            if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v83 - (void)v81) >> 3) >= 0x333333333333333) {
              unint64_t v47 = 0x666666666666666;
            }
            else {
              unint64_t v47 = v46;
            }
            if (v47)
            {
              int v48 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOThumbnailInfo>>((uint64_t)&v83, v47);
              int v44 = v81;
              uint64_t v40 = v82;
            }
            else
            {
              int v48 = 0;
            }
            unint64_t v49 = &v48[40 * v45];
            long long v50 = v78;
            long long v51 = v79;
            *((void *)v49 + 4) = v80;
            *(_OWORD *)unint64_t v49 = v50;
            *((_OWORD *)v49 + 1) = v51;
            if (v40 == v44)
            {
              unsigned int v55 = &v48[40 * v45];
            }
            else
            {
              uint64_t v52 = &v48[40 * v45];
              do
              {
                long long v53 = *(_OWORD *)(v40 - 40);
                long long v54 = *(_OWORD *)(v40 - 24);
                unsigned int v55 = v52 - 40;
                *((void *)v52 - 1) = *((void *)v40 - 1);
                *(_OWORD *)(v52 - 24) = v54;
                *(_OWORD *)(v52 - 40) = v53;
                v40 -= 40;
                v52 -= 40;
              }
              while (v40 != v44);
            }
            int v43 = v49 + 40;
            uint64_t v81 = v55;
            uint64_t v82 = v49 + 40;
            unint64_t v83 = (unint64_t)&v48[40 * v47];
            if (v44) {
              operator delete(v44);
            }
          }
          else
          {
            long long v41 = v78;
            long long v42 = v79;
            *((void *)v82 + 4) = v80;
            *(_OWORD *)uint64_t v40 = v41;
            *((_OWORD *)v40 + 1) = v42;
            int v43 = v40 + 40;
          }
          uint64_t v82 = v43;
          if (++v34 >= *((_DWORD *)this + 26)) {
            goto LABEL_61;
          }
        }
        BaseAddress = 0;
        a3 = 3;
        goto LABEL_67;
      }
LABEL_61:
      BaseAddress = 0;
      a3 = 3;
      a4 = v72;
      goto LABEL_63;
    }
    if (a3 != 1)
    {
      BaseAddress = 0;
      goto LABEL_63;
    }
    if (a4 && *a4)
    {
      IOSurfaceLock(*a4, 0, 0);
      BaseAddress = IOSurfaceGetBaseAddress(*a4);
      IOSurfaceGetHeight(*a4);
      IOSurfaceGetBytesPerRow(*a4);
LABEL_63:
      unint64_t v56 = 0xCCCCCCCCCCCCCCCDLL * ((v82 - v81) >> 3);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 1174405120;
      block[2] = ___ZN14TIFFReadPlugin14decodeImageImpEP18IIODecodeParameter12IIOImageTypePP11__IOSurfacePP10__CVBufferPP15CGImageBlockSet_block_invoke;
      block[3] = &unk_1ED4EFE60;
      block[5] = this;
      __p = 0;
      uint64_t v75 = 0;
      uint64_t v76 = 0;
      std::vector<IIODecodeInfo>::__init_with_size[abi:ne180100]<IIODecodeInfo*,IIODecodeInfo*>(&__p, v81, (uint64_t)v82, v56);
      uint64_t v77 = v30;
      block[4] = &v84;
      dispatch_apply(v56, 0, block);
      if (__p)
      {
        uint64_t v75 = __p;
        operator delete(__p);
      }
      if (*((_DWORD *)v85 + 6))
      {
        *((_DWORD *)this + 26) = 0;
      }
      else if (a3 == 3)
      {
        uint64_t v64 = (unsigned int *)v81;
        unsigned __int16 v65 = (unsigned int *)v82;
        if (v81 != v82)
        {
          CGColorSpaceRef v66 = (CGRect *)MEMORY[0x1E4F1DB20];
          do
          {
            LODWORD(v57) = v64[5];
            double v67 = (double)v57;
            LODWORD(v57) = v64[7];
            LODWORD(v58) = v64[8];
            double v68 = (double)v57;
            double v69 = (double)v58;
            v88.origin.x = 0.0;
            v88.origin.y = v67;
            v88.size.vImagePixelCount width = v68;
            v88.size.vImagePixelCount height = v69;
            *(void *)(*((void *)this + 12) + 8 * v64[4]) = IIOReadPlugin::createImageBlock(this, *(void **)v64, *((void *)v64 + 1), v88, v64[9], *((unsigned __int8 *)this + 343));
            if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *v66))
            {
              unint64_t v57 = 0;
            }
            else
            {
              v89.origin.x = 0.0;
              v89.origin.y = v67;
              v89.size.vImagePixelCount width = v68;
              v89.size.vImagePixelCount height = v69;
              *(CGRect *)&unint64_t v57 = CGRectUnion(*(CGRect *)((char *)this + 120), v89);
              double v67 = *(double *)&v58;
              double v68 = v70;
              double v69 = v71;
            }
            *((void *)this + 15) = v57;
            *((double *)this + 16) = v67;
            *((double *)this + 17) = v68;
            *((double *)this + 18) = v69;
            *(void *)uint64_t v64 = 0;
            v64 += 10;
          }
          while (v64 != v65);
        }
      }
      else if (a3 == 1)
      {
        IOSurfaceUnlock(*a4, 0, 0);
      }
      goto LABEL_67;
    }
  }
  else
  {
    _cg_jpeg_mem_term("decodeImageImp", 2286, "*** globalInfoForType('TIFF') failed...\n");
  }
  BaseAddress = 0;
LABEL_67:
  uint64_t v59 = *((void *)this + 55);
  if (v59)
  {
    _cg_TIFFClose(v59, v23, v24, v25, v26, v27, v28, v29);
    *((void *)this + 55) = 0;
  }
  if (a3 == 3 && BaseAddress)
  {
    long long v60 = (unint64_t *)v81;
    int v61 = (unint64_t *)v82;
    while (v60 != v61)
    {
      if (*v60) {
        _ImageIO_Free(*v60, v60[1]);
      }
      v60 += 5;
    }
  }
  if (v21)
  {
    uint64_t v62 = (const char **)*((void *)this + 3);
    if (v62) {
      IIOImageReadSession::unmapData(v62);
    }
  }
  uint64_t v22 = *((unsigned int *)v85 + 6);
LABEL_80:
  if (v81)
  {
    uint64_t v82 = v81;
    operator delete(v81);
  }
  _Block_object_dispose(&v84, 8);
  return v22;
}

void sub_188721038(_Unwind_Exception *a1)
{
  float v3 = *(void **)(v1 - 176);
  if (v3)
  {
    *(void *)(v1 - 168) = v3;
    operator delete(v3);
  }
  _Block_object_dispose((const void *)(v1 - 152), 8);
  _Unwind_Resume(a1);
}

void ___ZN14TIFFReadPlugin14decodeImageImpEP18IIODecodeParameter12IIOImageTypePP11__IOSurfacePP10__CVBufferPP15CGImageBlockSet_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(a1 + 48) + 40 * a2;
  uint64_t v5 = *(char **)v4;
  long long v6 = *(_OWORD *)(v4 + 8);
  vImagePixelCount v7 = *(unsigned int *)(v4 + 28);
  int v68 = *(_DWORD *)(v4 + 24);
  vImagePixelCount v8 = *(unsigned int *)(v4 + 32);
  size_t v9 = *(unsigned int *)(v4 + 36);
  long long v67 = v6;
  memset(v66, 0, sizeof(v66));
  uint64_t v10 = (IIOImageRead *)IIO_Reader::testHeaderSize(*(IIO_Reader **)(v3 + 24));
  IIOImageReadSession::IIOImageReadSession((IIOImageReadSession *)v66, v10);
  TIFFStructure = (void *)TIFFReadPlugin::loadTIFFStructure((TIFFReadPlugin *)v3, *(GlobalTIFFInfo **)(a1 + 72), (IIOImageReadSession *)v66);
  if (TIFFStructure)
  {
    switch(*(unsigned char *)(v3 + 552))
    {
      case 1:
        long long v60 = v5;
        long long v61 = v67;
        int v62 = v68;
        int v63 = v7;
        int v64 = v8;
        int v65 = v9;
        int v17 = TIFFReadPlugin::decodeSubsampled(v3, (uint64_t)TIFFStructure, (uint64_t *)&v60);
        goto LABEL_11;
      case 2:
        long long v54 = v5;
        long long v55 = v67;
        int v56 = v68;
        int v57 = v7;
        int v58 = v8;
        int v59 = v9;
        int v17 = TIFFReadPlugin::decodeStripChunky(v3, (uint64_t)TIFFStructure, (uint64_t)&v54);
        goto LABEL_11;
      case 3:
        int v48 = v5;
        long long v49 = v67;
        int v50 = v68;
        int v51 = v7;
        int v52 = v8;
        int v53 = v9;
        int v17 = TIFFReadPlugin::decodeStripPlanar(v3, (uint64_t)TIFFStructure, (uint64_t *)&v48);
        goto LABEL_11;
      case 4:
        long long v42 = v5;
        long long v43 = v67;
        int v44 = v68;
        int v45 = v7;
        int v46 = v8;
        int v47 = v9;
        int v17 = TIFFReadPlugin::decodeTileChunky(v3, (uint64_t)TIFFStructure, (uint64_t)&v42, v11, v12, v13, v14, v15);
        goto LABEL_11;
      case 5:
        unsigned int v36 = v5;
        long long v37 = v67;
        int v38 = v68;
        int v39 = v7;
        int v40 = v8;
        int v41 = v9;
        int v17 = TIFFReadPlugin::decodeTilePlanar(v3, (uint64_t)TIFFStructure, &v36);
        goto LABEL_11;
      case 6:
        unsigned int v30 = v5;
        long long v31 = v67;
        int v32 = v68;
        int v33 = v7;
        int v34 = v8;
        int v35 = v9;
        int v17 = TIFFReadPlugin::decodeRGBAImage(v3, TIFFStructure, (uint64_t)&v30);
LABEL_11:
        *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v17;
        break;
      default:
        LogError("decodeImageImp_block_invoke", 2382, "*** unknown decode mode [%d]\n", &v48);
        break;
    }
    if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)
      && *(_WORD *)(v3 + 306) == 32
      && *(_WORD *)(v3 + 304) == 8)
    {
      dest.data = v5;
      dest.vImagePixelCount height = v8;
      dest.vImagePixelCount width = v7;
      dest.size_t rowBytes = v9;
      if (*(unsigned char *)(v3 + 560))
      {
        if (*(unsigned char *)(v3 + 413)) {
          vImageUnpremultiplyData_RGBA8888(&dest, &dest, 0x10u);
        }
      }
      else
      {
        if (v8)
        {
          uint64_t v25 = 0;
          char v26 = 1;
          while (!v7)
          {
LABEL_24:
            if (++v25 == v8)
            {
              if ((v26 & 1) == 0) {
                *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = vImageOverwriteChannelsWithScalar_ARGB8888(0xFFu, &dest, &dest, 1u, 0x10u);
              }
              goto LABEL_27;
            }
          }
          uint64_t v27 = &v5[(v9 * v25)];
          int v28 = v7;
          while (!HIBYTE(*(_DWORD *)v27))
          {
            v26 &= *(_DWORD *)v27 == 0xFFFFFF;
            v27 += 4;
            if (!--v28) {
              goto LABEL_24;
            }
          }
        }
LABEL_27:
        if (*(unsigned char *)(v3 + 406) == 1) {
          vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
        }
      }
    }
    _cg_TIFFClose((uint64_t)TIFFStructure, v18, v19, v20, v21, v22, v23, v24);
  }
  else
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = -50;
  }
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)v66);
}

void sub_1887213A8(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    *(_DWORD *)(*(void *)(*(void *)(v2 + 32) + 8) + 24) = -50;
    __cxa_end_catch();
    JUMPOUT(0x188721360);
  }
  _Unwind_Resume(exception_object);
}

void *__copy_helper_block_e8_48c55_ZTSNSt3__16vectorI13IIODecodeInfoNS_9allocatorIS1_EEEE(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  uint64_t v2 = (void *)(a1 + 48);
  v2[2] = 0;
  return std::vector<IIODecodeInfo>::__init_with_size[abi:ne180100]<IIODecodeInfo*,IIODecodeInfo*>(v2, *(const void **)(a2 + 48), *(void *)(a2 + 56), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 56) - *(void *)(a2 + 48)) >> 3));
}

void __destroy_helper_block_e8_48c55_ZTSNSt3__16vectorI13IIODecodeInfoNS_9allocatorIS1_EEEE(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

uint64_t *std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  long long v6 = a1 + 1;
  uint64_t v5 = a1[1];
  if (v5)
  {
    unint64_t v7 = *a2;
    while (1)
    {
      while (1)
      {
        vImagePixelCount v8 = (uint64_t **)v5;
        unint64_t v9 = v5[4];
        if (v7 >= v9) {
          break;
        }
        uint64_t v5 = *v8;
        long long v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      uint64_t v5 = v8[1];
      if (!v5)
      {
        long long v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    vImagePixelCount v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

void *std::vector<IIODecodeInfo>::__init_with_size[abi:ne180100]<IIODecodeInfo*,IIODecodeInfo*>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    long long v6 = result;
    uint64_t result = std::vector<IIODecodeInfo>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_188721568(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<IIODecodeInfo>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667) {
    std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOThumbnailInfo>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[40 * v4];
  return result;
}

IIO_Reader *IIOReader_RawCamera::IIOReader_RawCamera(IIO_Reader *a1, uint64_t a2)
{
  IIO_Reader::IIO_Reader(a1, *(const __CFString *const **)a2, *(const char **)(a2 + 8), 1380013856, *(void *)(a2 + 16), *(void *)(a2 + 96));
  *(void *)uint64_t v4 = &unk_1ED4E4C60;
  *(_OWORD *)(v4 + 72) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(v4 + 88) = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(v4 + 104) = *(_OWORD *)(a2 + 56);
  *(void *)(v4 + 120) = 0;
  IIOReader_RawCamera::createRAWOSType(v4);
  return a1;
}

uint64_t IIOReader_RawCamera::isReaderForRAWImageFormat(IIOReader_RawCamera *this)
{
  return 1;
}

uint64_t IIOReader_RawCamera::callUpdateSourceProperties(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(a1 + 80);
  if (v7) {
    v7(a2, a3, a7);
  }
  return 0;
}

uint64_t IIOReader_RawCamera::callGetImageCount(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  if (a5) {
    *a5 = 0;
  }
  uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 88);
  if (v5) {
    return v5(a2, a4);
  }
  else {
    return 1;
  }
}

uint64_t IIOReader_RawCamera::compareOptions(IIOReader_RawCamera *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  uint64_t v3 = (uint64_t (*)(const __CFDictionary *, const __CFDictionary *))*((void *)this + 12);
  if (v3) {
    return v3(a2, a3);
  }
  else {
    return 1;
  }
}

uint64_t IIOReader_RawCamera::initImageAtOffset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(a1 + 104);
  if (!v4) {
    return 4294967246;
  }
  uint64_t v9 = *(void *)(a2 + 24);
  if (v9)
  {
    IIOImagePlus::setReadPluginType(v9, *(_DWORD *)(a1 + 24));
    uint64_t v4 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(a1 + 104);
  }
  if (v4(a2, a3, a4)) {
    return 0;
  }
  else {
    return 4294967246;
  }
}

uint64_t IIOReader_RawCamera::initThumbnail(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned int (**)(uint64_t, uint64_t, uint64_t))(a1 + 112);
  uint64_t v5 = 4294967245;
  if (v4)
  {
    if (v4(a2, a3, a4)) {
      return 0;
    }
    else {
      return 4294967245;
    }
  }
  return v5;
}

uint64_t IIOReader_RawCamera::canDecodeOOP(IIOReader_RawCamera *this)
{
  return 0;
}

uint64_t IIOReader_RawCamera::copyAuxiliaryDataInfo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 120);
  if (v4) {
    return v4(a2, a3, a4);
  }
  else {
    return 0;
  }
}

BOOL IIOReader_RawCamera::hasCustomImageCountProc(IIOReader_RawCamera *this)
{
  return *((void *)this + 11) != 0;
}

BOOL IIOReader_RawCamera::hasCustomSourcePropertiesProc(IIOReader_RawCamera *this)
{
  return *((void *)this + 10) != 0;
}

BOOL IIOReader_RawCamera::hasCustomThumbnailProc(IIOReader_RawCamera *this)
{
  return *((void *)this + 14) != 0;
}

BOOL IIOReader_RawCamera::hasCustomCompareOptionsProc(IIOReader_RawCamera *this)
{
  return *((void *)this + 12) != 0;
}

BOOL IIOReader_RawCamera::hasCustomCopyAuxiliaryDataProc(IIOReader_RawCamera *this)
{
  return *((void *)this + 15) != 0;
}

uint64_t TIFFInitOJPEG(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 != 6) {
    TIFFInitOJPEG_cold_1();
  }
  if (!_TIFFMergeFields(a1, ojpegFields, 7, a4, a5, a6, a7, a8))
  {
    uint64_t v25 = "Merging Old JPEG codec-specific tags failed";
LABEL_7:
    TIFFErrorExtR(a1, "TIFFInitOJPEG", v25, v10, v11, v12, v13, v14, v27);
    return 0;
  }
  uint64_t v15 = _TIFFmallocExt((void *)a1, 5776, v9, v10, v11, v12, v13, v14);
  if (!v15)
  {
    uint64_t v25 = "No space for OJPEG state block";
    goto LABEL_7;
  }
  unsigned int v16 = v15;
  _TIFFmemset(v15, 0, 0x1690uLL);
  *unsigned int v16 = a1;
  uint64_t v17 = 1;
  *((unsigned char *)v16 + 288) = 1;
  *((_WORD *)v16 + 146) = 514;
  _cg_TIFFSetField(a1, 530, v18, v19, v20, v21, v22, v23, 2);
  *(void *)(a1 + 952) = OJPEGFixupTags;
  *(void *)(a1 + 960) = OJPEGSetupDecode;
  *(void *)(a1 + 968) = OJPEGPreDecode;
  *(void *)(a1 + 1248) = OJPEGPostDecode;
  *(void *)(a1 + 1008) = OJPEGDecode;
  *(void *)(a1 + 1024) = OJPEGDecode;
  *(void *)(a1 + 1040) = OJPEGDecode;
  *(void *)(a1 + 976) = OJPEGSetupEncode;
  *(void *)(a1 + 992) = OJPEGPreEncode;
  *(void *)(a1 + 1000) = OJPEGPostEncode;
  *(void *)(a1 + 1016) = OJPEGEncode;
  *(void *)(a1 + 1032) = OJPEGEncode;
  *(void *)(a1 + 1048) = OJPEGEncode;
  *(void *)(a1 + 1072) = OJPEGCleanup;
  *(void *)(a1 + 1096) = v16;
  int8x16_t v24 = *(int8x16_t *)(a1 + 1280);
  *(void *)(a1 + 1288) = OJPEGVGetField;
  *(int8x16_t *)(v16 + 27) = vextq_s8(v24, v24, 8uLL);
  *(void *)(a1 + 1280) = OJPEGVSetField;
  v16[29] = *(void *)(a1 + 1296);
  *(void *)(a1 + 1296) = OJPEGPrintDir;
  *(_DWORD *)(a1 + 16) |= 0x20000u;
  return v17;
}

uint64_t OJPEGFixupTags()
{
  return 1;
}

uint64_t OJPEGSetupDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  TIFFWarningExtR(a1, "OJPEGSetupDecode", "Deprecated and troublesome old-style JPEG compression mode, please convert to new-style JPEG compression and notify vendor of writing software", a4, a5, a6, a7, a8, vars0);
  return 1;
}

uint64_t OJPEGPreDecode(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a2;
  uint64_t v10 = *(void *)(a1 + 1096);
  if (!*(unsigned char *)(v10 + 290)) {
    OJPEGSubsamplingCorrect(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  if (!*(unsigned char *)(v10 + 600))
  {
    uint64_t v28 = *(void *)(a1 + 1096);
    if (*(unsigned char *)(v28 + 600)) {
      OJPEGPreDecode_cold_7();
    }
    int v29 = *(_DWORD *)(a1 + 88);
    unsigned int v30 = *(_DWORD *)(a1 + 92);
    *(_DWORD *)(v28 + 248) = v29;
    *(_DWORD *)(v28 + 252) = v30;
    if ((*(unsigned char *)(a1 + 17) & 4) != 0)
    {
      int v29 = *(_DWORD *)(a1 + 100);
      unsigned int v31 = *(_DWORD *)(a1 + 104);
      unsigned int v32 = (v31 + v30 - 1) / v31 * v31;
    }
    else
    {
      unsigned int v31 = *(_DWORD *)(a1 + 132);
      if (v31 == -1) {
        unsigned int v31 = v30;
      }
      unsigned int v32 = v30;
    }
    *(_DWORD *)(v28 + 256) = v29;
    *(_DWORD *)(v28 + 260) = v31;
    *(_DWORD *)(v28 + 264) = v32;
    int v33 = *(unsigned __int16 *)(a1 + 130);
    if (v33 == 3)
    {
      *(_WORD *)(v28 + 268) = 3;
      if (*(_WORD *)(a1 + 170) != 1) {
        LOBYTE(v33) = 1;
      }
      *(unsigned char *)(v28 + 270) = v33;
    }
    else
    {
      if (v33 != 1)
      {
        TIFFErrorExtR(a1, "OJPEGReadHeaderInfo", "SamplesPerPixel %hhu not supported for this compression scheme", a4, a5, a6, a7, a8, *(unsigned char *)(v28 + 268));
        return 0;
      }
      *(_WORD *)(v28 + 268) = 1;
      *(unsigned char *)(v28 + 270) = 1;
      *(_WORD *)(v28 + 292) = 257;
    }
    if (v31 < v30)
    {
      unsigned int v70 = *(unsigned __int8 *)(v28 + 292);
      if (v70 > 4
        || ((1 << v70) & 0x16) == 0
        || (unsigned int v71 = *(unsigned __int8 *)(v28 + 293), v71 > 4)
        || ((1 << v71) & 0x16) == 0)
      {
        uint64_t v74 = "OJPEGReadHeaderInfo";
        uint64_t v75 = "Invalid subsampling values";
        goto LABEL_118;
      }
      unsigned int v72 = 8 * v71;
      unsigned int v73 = v31 / (8 * v71);
      if (v31 % v72)
      {
        uint64_t v74 = "OJPEGReadHeaderInfo";
        uint64_t v75 = "Incompatible vertical subsampling and image strip/tile length";
        goto LABEL_118;
      }
      *(_WORD *)(v28 + 472) = v73 * ((v29 + 8 * v70 - 1) / (8 * v70));
    }
    uint64_t result = OJPEGReadHeaderInfoSec(a1, a2, a3, a4, a5, a6, a7, a8);
    if (!result) {
      return result;
    }
    *(unsigned char *)(v28 + 504) = 1;
    *(void *)(v28 + 508) = *(void *)(v28 + 1608);
    uint64_t v85 = *(unsigned __int16 *)(v28 + 1648);
    *(void *)(v28 + 520) = *(void *)(v28 + 1624) - v85;
    *(void *)(v28 + 528) = *(void *)(v28 + 1640) + v85;
    *(unsigned char *)(v28 + 600) = 1;
  }
  if (!*(unsigned char *)(v10 + 32 * v8 + 504))
  {
    if (!v8) {
      OJPEGPreDecode_cold_1();
    }
    if (v8 >= 3) {
      OJPEGPreDecode_cold_2();
    }
    uint64_t v11 = *(void *)(a1 + 1096);
    if (!*(unsigned char *)(v11 + 504)) {
      OJPEGPreDecode_cold_3();
    }
    if (*(unsigned char *)(v11 + 32 * v8 + 504)) {
      OJPEGPreDecode_cold_6();
    }
    unsigned __int8 v12 = v8;
    do
      uint64_t v13 = v11 + 32 * --v12;
    while (!*(unsigned char *)(v13 + 504));
    *(unsigned char *)(v11 + 269) = v12;
    *(void *)(v11 + 1608) = *(void *)(v13 + 508);
    *(void *)(v11 + 1624) = *(void *)(v13 + 520);
    *(unsigned char *)(v11 + 1632) = 0;
    *(void *)(v11 + 1640) = *(void *)(v13 + 528);
    *(_WORD *)(v11 + 1648) = 0;
    *(void *)(v11 + 1656) = 0;
    if (v8 > v12)
    {
      unsigned __int8 v87 = 0;
      while (OJPEGReadByte(v11, &v87))
      {
        if (v87 == 255)
        {
          do
          {
            if (!OJPEGReadByte(v11, &v87)) {
              return 0;
            }
          }
          while (v87 == 255);
          if (v87 == 218)
          {
            ++*(unsigned char *)(v11 + 269);
            if (!OJPEGReadHeaderInfoSecStreamSos(a1, v14, v15, v16, v17, v18, v19, v20)) {
              return 0;
            }
            uint64_t v21 = *(unsigned __int8 *)(v11 + 269);
            uint64_t v22 = v11 + 32 * v21;
            *(unsigned char *)(v22 + 504) = 1;
            *(void *)(v22 + 508) = *(void *)(v11 + 1608);
            uint64_t v23 = *(unsigned __int16 *)(v11 + 1648);
            *(void *)(v22 + 520) = *(void *)(v11 + 1624) - v23;
            *(void *)(v22 + 528) = *(void *)(v11 + 1640) + v23;
            if (v21 >= v8) {
              goto LABEL_20;
            }
          }
        }
      }
      return 0;
    }
  }
LABEL_20:
  uint64_t v24 = 932;
  if ((*(unsigned char *)(a1 + 17) & 4) == 0) {
    uint64_t v24 = 884;
  }
  unsigned int v25 = *(_DWORD *)(a1 + v24);
  if (!*(unsigned char *)(v10 + 601))
  {
LABEL_28:
    *(unsigned char *)(v10 + 269) = v8;
    *(_WORD *)(v10 + 602) = v8;
    *(_DWORD *)(v10 + 604) = *(_DWORD *)(a1 + 224) * v8;
    if (*(unsigned char *)(v10 + 1632))
    {
      uint64_t v27 = *(void *)(v10 + 32 * v8 + 520);
      if (*(void *)(v10 + 1624) - *(unsigned __int16 *)(v10 + 1648) == v27)
      {
LABEL_42:
        uint64_t v35 = *(void *)(a1 + 1096);
        if (*(unsigned char *)(v35 + 608)) {
          return 0;
        }
        *(_DWORD *)(v35 + 3712) = 0;
        *(unsigned char *)(v35 + 474) = 0;
        _cg_jpeg_std_error(v35 + 616);
        *(void *)(v35 + 632) = OJPEGLibjpegJpegErrorMgrOutputMessage;
        *(void *)(v35 + 616) = OJPEGLibjpegJpegErrorMgrErrorExit;
        *(void *)(v35 + 792) = v35 + 616;
        *(void *)(v35 + 816) = a1;
        uint64_t result = jpeg_create_decompress_encap(v35, (char *)(v35 + 792));
        if (!result) {
          return result;
        }
        *(unsigned char *)(v35 + 608) = 1;
        *(void *)(v35 + 1464) = 0;
        *(void *)(v35 + 1472) = OJPEGLibjpegJpegSourceMgrInitSource;
        *(void *)(v35 + 1480) = OJPEGLibjpegJpegSourceMgrFillInputBuffer;
        *(void *)(v35 + 1488) = OJPEGLibjpegJpegSourceMgrSkipInputData;
        *(void *)(v35 + 1496) = OJPEGLibjpegJpegSourceMgrResyncToRestart;
        *(void *)(v35 + 1504) = OJPEGLibjpegJpegSourceMgrTermSource;
        *(void *)(v35 + 832) = v35 + 1456;
        uint64_t result = jpeg_read_header_encap(v35, v35 + 792);
        if (!result) {
          return result;
        }
        unsigned int v42 = *(unsigned __int8 *)(v35 + 270);
        if (*(unsigned char *)(v35 + 294) || v42 < 2)
        {
          *(void *)(v35 + 852) = 0;
          *(unsigned char *)(v35 + 609) = 1;
          *(_DWORD *)(v35 + 1600) = *(_DWORD *)(v35 + 256) * v42;
          *(_DWORD *)(v35 + 1604) = *(_DWORD *)(v35 + 260);
        }
        else
        {
          *(_DWORD *)(v35 + 884) = 1;
          *(_DWORD *)(v35 + 892) = 0;
          *(unsigned char *)(v35 + 609) = 0;
          if (!*(unsigned char *)(v35 + 1512))
          {
            if (*(void *)(v35 + 1544)) {
              OJPEGPreDecode_cold_5();
            }
            if (*(void *)(v35 + 1584)) {
              OJPEGPreDecode_cold_4();
            }
            unsigned int v43 = *(unsigned __int8 *)(v35 + 292);
            if (!*(unsigned char *)(v35 + 292)) {
              return 0;
            }
            int v44 = *(unsigned __int8 *)(v35 + 293);
            if (!*(unsigned char *)(v35 + 293)) {
              return 0;
            }
            unsigned int v45 = (*(_DWORD *)(v35 + 256) + 8 * v43 - 1) / (8 * v43) * 8 * v43;
            *(_DWORD *)(v35 + 1516) = v45;
            int v46 = 8 * v44;
            *(_DWORD *)(v35 + 1520) = v46;
            int v47 = v45 / v43;
            *(_DWORD *)(v35 + 1524) = v47;
            *(_DWORD *)(v35 + 1528) = 8;
            int v48 = v45 * v46;
            *(_DWORD *)(v35 + 1532) = v48;
            *(_DWORD *)(v35 + 1536) = 8 * v47;
            int64_t v49 = (v48 + 16 * v47);
            *(_DWORD *)(v35 + 1540) = v49;
            int v50 = _TIFFcallocExt((void *)a1, 1, v49, v37, v38, v39, v40, v41);
            *(void *)(v35 + 1544) = v50;
            if (v50)
            {
              *(void *)(v35 + 1552) = v50;
              int v52 = (char *)v50 + *(unsigned int *)(v35 + 1532);
              *(void *)(v35 + 1560) = v52;
              *(void *)(v35 + 1568) = &v52[*(unsigned int *)(v35 + 1536)];
              LODWORD(v52) = *(_DWORD *)(v35 + 1520) + 2 * *(_DWORD *)(v35 + 1528) + 3;
              *(_DWORD *)(v35 + 1576) = v52;
              int v53 = _TIFFmallocExt((void *)a1, 8 * v52, v51, a4, a5, a6, a7, a8);
              *(void *)(v35 + 1584) = v53;
              if (v53)
              {
                long long v54 = v53 + 3;
                void *v53 = v53 + 3;
                uint64_t v55 = *(unsigned int *)(v35 + 1520);
                v53[1] = *(void *)(v35 + 1584) + 8 * v55 + 24;
                uint64_t v56 = *(unsigned int *)(v35 + 1528);
                v53[2] = *(void *)(v35 + 1584) + 8 * v55 + 8 * v56 + 24;
                if (v55)
                {
                  unsigned int v57 = 0;
                  int v58 = *(_DWORD *)(v35 + 1516);
                  do
                  {
                    *v54++ = *(void *)(v35 + 1552) + v57;
                    v57 += v58;
                    --v55;
                  }
                  while (v55);
                }
                if (v56)
                {
                  unsigned int v59 = 0;
                  int v60 = *(_DWORD *)(v35 + 1524);
                  uint64_t v61 = v56;
                  do
                  {
                    *v54++ = *(void *)(v35 + 1560) + v59;
                    v59 += v60;
                    --v61;
                  }
                  while (v61);
                  unsigned int v62 = 0;
                  uint64_t v63 = 8 * v56;
                  do
                  {
                    *(void *)((char *)v54 + v61) = *(void *)(v35 + 1568) + v62;
                    v61 += 8;
                    v62 += v60;
                  }
                  while (v63 != v61);
                }
                unsigned int v64 = *(_DWORD *)(v35 + 256);
                unsigned int v65 = *(unsigned __int8 *)(v35 + 292);
                if (v64 % v65) {
                  int v66 = v64 / v65 + 1;
                }
                else {
                  int v66 = v64 / v65;
                }
                *(_DWORD *)(v35 + 1592) = v66;
                *(_DWORD *)(v35 + 1596) = 0;
                *(_DWORD *)(v35 + 12) = 0;
                unsigned int v67 = *(unsigned __int8 *)(v35 + 293);
                *(_DWORD *)(v35 + 1600) = (v67 * v65 + 2) * v66;
                unsigned int v68 = *(_DWORD *)(v35 + 260);
                if (v68 % v67) {
                  int v69 = v68 / v67 + 1;
                }
                else {
                  int v69 = v68 / v67;
                }
                *(_DWORD *)(v35 + 1604) = v69;
                *(unsigned char *)(v35 + 1512) = 1;
                goto LABEL_82;
              }
            }
            uint64_t v74 = "OJPEGWriteHeaderInfo";
LABEL_117:
            uint64_t v75 = "Out of memory";
LABEL_118:
            TIFFErrorExtR(a1, v74, v75, a4, a5, a6, a7, a8, v86);
            return 0;
          }
        }
LABEL_82:
        uint64_t result = jpeg_start_decompress_encap(v35, v35 + 792);
        if (!result) {
          return result;
        }
        if (*(_DWORD *)(v35 + 840) != *(_DWORD *)(v35 + 256))
        {
          TIFFErrorExtR(a1, "OJPEGWriteHeaderInfo", "jpeg_start_decompress() returned image_vImagePixelCount width = %u, expected %u", a4, a5, a6, a7, a8, *(_DWORD *)(v35 + 840));
          return 0;
        }
        if (*(void *)(v35 + 1208) != __PAIR64__(*(unsigned __int8 *)(v35 + 293), *(unsigned __int8 *)(v35 + 292)))
        {
          TIFFErrorExtR(a1, "OJPEGWriteHeaderInfo", "jpeg_start_decompress() returned max_h_samp_factor = %d and max_v_samp_factor = %d, expected %hhu and %hhu", a4, a5, a6, a7, a8, *(_DWORD *)(v35 + 1208));
          return 0;
        }
        *(unsigned char *)(v35 + 601) = 1;
        unsigned int v26 = *(_DWORD *)(v10 + 604);
        goto LABEL_86;
      }
    }
    else
    {
      uint64_t v27 = *(void *)(v10 + 32 * v8 + 520);
    }
    uint64_t v34 = v10 + 32 * v8;
    *(void *)(v10 + 1608) = *(void *)(v34 + 508);
    *(void *)(v10 + 1624) = v27;
    *(unsigned char *)(v10 + 1632) = 0;
    *(void *)(v10 + 1640) = *(void *)(v34 + 528);
    *(_WORD *)(v10 + 1648) = 0;
    *(void *)(v10 + 1656) = 0;
    goto LABEL_42;
  }
  if (*(unsigned __int16 *)(v10 + 602) != v8 || (unsigned int v26 = *(_DWORD *)(v10 + 604), v26 > v25))
  {
    if (*(unsigned char *)(v10 + 608)) {
      OJPEGLibjpegSessionAbort(a1);
    }
    *(unsigned char *)(v10 + 601) = 0;
    goto LABEL_28;
  }
LABEL_86:
  *(_DWORD *)(v10 + 1596) = 0;
  if (v26 >= v25)
  {
LABEL_109:
    uint64_t result = 1;
    *(_DWORD *)(v10 + 8) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v76 = *(void *)(a1 + 1096);
    if (*(unsigned char *)(v10 + 609))
    {
      if (!*(void *)(v76 + 5768))
      {
        uint64_t v77 = _TIFFmallocExt((void *)a1, *(unsigned int *)(v76 + 1600), a3, a4, a5, a6, a7, a8);
        *(void *)(v76 + 5768) = v77;
        if (!v77)
        {
          uint64_t v74 = "OJPEGPreDecodeSkipScanlines";
          goto LABEL_117;
        }
      }
      if (*(_DWORD *)(v76 + 1604))
      {
        int v78 = 0;
        while (1)
        {
          uint64_t result = jpeg_read_scanlines_encap(v76, v76 + 792, v76 + 5768);
          if (!result) {
            return result;
          }
          if (++v78 >= *(_DWORD *)(v76 + 1604)) {
            goto LABEL_108;
          }
        }
      }
      goto LABEL_108;
    }
    unsigned int v79 = *(_DWORD *)(v76 + 1604);
    int v80 = *(_DWORD *)(v76 + 1596);
    unsigned int v81 = *(_DWORD *)(v76 + 1528);
    if (v80)
    {
      if (v79 <= v81 - v80)
      {
        unsigned int v83 = v80 + v79;
        if (v83 == v81) {
          unsigned int v79 = 0;
        }
        else {
          unsigned int v79 = v83;
        }
LABEL_107:
        *(_DWORD *)(v76 + 1596) = v79;
        goto LABEL_108;
      }
      *(_DWORD *)(v76 + 1596) = 0;
      *(_DWORD *)(v76 + 12) = 0;
      v79 -= v81 - v80;
    }
    if (v79 >= v81) {
      break;
    }
LABEL_101:
    if (v79)
    {
      uint64_t result = jpeg_read_raw_data_encap(v76, v76 + 792, *(void *)(v76 + 1584), 8 * *(unsigned __int8 *)(v76 + 293));
      if (!result) {
        return result;
      }
      goto LABEL_107;
    }
LABEL_108:
    unsigned int v84 = *(_DWORD *)(v10 + 604) + 1;
    *(_DWORD *)(v10 + 604) = v84;
    if (v84 >= v25) {
      goto LABEL_109;
    }
  }
  while (1)
  {
    uint64_t result = jpeg_read_raw_data_encap(v76, v76 + 792, *(void *)(v76 + 1584), 8 * *(unsigned __int8 *)(v76 + 293));
    if (!result) {
      return result;
    }
    unsigned int v82 = *(_DWORD *)(v76 + 1528);
    v79 -= v82;
    if (v79 < v82) {
      goto LABEL_101;
    }
  }
}

uint64_t OJPEGPostDecode(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9 = *(void *)(result + 1096);
  if (v9)
  {
    unsigned int v10 = *(_DWORD *)(v9 + 604) + 1;
    *(_DWORD *)(v9 + 604) = v10;
    if (!(v10 % *(_DWORD *)(result + 224)))
    {
      if (!*(unsigned char *)(v9 + 608)) {
        OJPEGPostDecode_cold_1();
      }
      uint64_t result = OJPEGLibjpegSessionAbort(result);
      *(unsigned char *)(v9 + 601) = 0;
    }
  }
  else
  {
    uint64_t v11 = *(void *)(result + 1200);
    return TIFFErrorExt(v11, "OJPEGPostDecode", "Cannot perform PostDecode, OJPEGState is NULL", a4, a5, a6, a7, a8, a9);
  }
  return result;
}

uint64_t OJPEGDecode(uint64_t a1, char *a2, int64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(a1 + 1096);
  if (!*(_DWORD *)(v11 + 8))
  {
    bzero(a2, a3);
    uint64_t v18 = "Cannot decode: decoder not correctly initialized";
LABEL_9:
    TIFFErrorExtR(a1, "OJPEGDecode", v18, v13, v14, v15, v16, v17, v43);
    return 0;
  }
  if (!*(unsigned char *)(v11 + 608))
  {
    bzero(a2, a3);
    uint64_t v18 = "Cannot decode: libjpeg_session_active == 0";
    goto LABEL_9;
  }
  if (*(_DWORD *)(v11 + 12)) {
    goto LABEL_13;
  }
  if (!*(unsigned char *)(v11 + 609))
  {
    if (!(a3 % *(unsigned int *)(v11 + 1600)))
    {
      if (a3 < 1) {
        OJPEGDecode_cold_1();
      }
      int v23 = *(_DWORD *)(v11 + 1596);
      uint64_t v24 = a2;
      int64_t v25 = a3;
      while (1)
      {
        int v26 = *(unsigned __int8 *)(v11 + 293);
        if (!v23)
        {
          if (!jpeg_read_raw_data_encap(v11, v11 + 792, *(void *)(v11 + 1584), 8 * v26))
          {
            *(_DWORD *)(v11 + 12) = 1;
            goto LABEL_13;
          }
          int v23 = *(_DWORD *)(v11 + 1596);
          int v26 = *(unsigned __int8 *)(v11 + 293);
        }
        if (*(_DWORD *)(v11 + 1592))
        {
          unsigned int v27 = 0;
          uint64_t v28 = (*(_DWORD *)(v11 + 1524) * v23);
          int v29 = (char *)(*(void *)(v11 + 1568) + v28);
          unsigned int v30 = (char *)(*(void *)(v11 + 1560) + v28);
          unsigned int v31 = (char *)(*(void *)(v11 + 1552) + (v23 * v26 * *(_DWORD *)(v11 + 1516)));
          unsigned int v32 = v24;
          do
          {
            unsigned int v33 = *(unsigned __int8 *)(v11 + 293);
            unsigned int v34 = *(unsigned __int8 *)(v11 + 292);
            if (*(unsigned char *)(v11 + 293))
            {
              unsigned int v35 = 0;
              int v36 = *(unsigned __int8 *)(v11 + 292);
              uint64_t v37 = v31;
              do
              {
                if (v36)
                {
                  unsigned int v38 = 0;
                  do
                  {
                    char v39 = *v37++;
                    *v32++ = v39;
                    ++v38;
                    unsigned int v34 = *(unsigned __int8 *)(v11 + 292);
                  }
                  while (v38 < v34);
                  unsigned int v33 = *(unsigned __int8 *)(v11 + 293);
                  int v36 = *(unsigned __int8 *)(v11 + 292);
                }
                v37 += (*(_DWORD *)(v11 + 1516) - v36);
                ++v35;
              }
              while (v35 < v33);
            }
            v31 += v34;
            char v40 = *v30++;
            *unsigned int v32 = v40;
            char v41 = *v29++;
            v32[1] = v41;
            v32 += 2;
            ++v27;
          }
          while (v27 < *(_DWORD *)(v11 + 1592));
          int v23 = *(_DWORD *)(v11 + 1596);
        }
        if (v23 + 1 == *(_DWORD *)(v11 + 1528)) {
          int v23 = 0;
        }
        else {
          ++v23;
        }
        *(_DWORD *)(v11 + 1596) = v23;
        int64_t v42 = *(unsigned int *)(v11 + 1600);
        v24 += v42;
        uint64_t result = 1;
        BOOL v22 = v25 <= v42;
        v25 -= v42;
        if (v22) {
          return result;
        }
      }
    }
    unsigned __int8 v12 = "OJPEGDecodeRaw";
LABEL_12:
    TIFFErrorExtR(a1, v12, "Fractional scanline not read", a4, a5, a6, a7, a8, v43);
    goto LABEL_13;
  }
  if (a3 % *(unsigned int *)(v11 + 1600))
  {
    unsigned __int8 v12 = "OJPEGDecodeScanlines";
    goto LABEL_12;
  }
  if (a3 <= 0) {
    OJPEGDecode_cold_2();
  }
  int v44 = a2;
  int64_t v20 = a3;
  while (jpeg_read_scanlines_encap(v11, v11 + 792, (uint64_t)&v44))
  {
    int64_t v21 = *(unsigned int *)(v11 + 1600);
    v44 += v21;
    BOOL v22 = v20 <= v21;
    v20 -= v21;
    if (v22) {
      return 1;
    }
  }
LABEL_13:
  bzero(a2, a3);
  return 0;
}

uint64_t OJPEGSetupEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  TIFFErrorExtR(a1, "OJPEGSetupEncode", "OJPEG encoding not supported; use new-style JPEG compression instead",
    a4,
    a5,
    a6,
    a7,
    a8,
    vars0);
  return 0;
}

uint64_t OJPEGPreEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  TIFFErrorExtR(a1, "OJPEGPreEncode", "OJPEG encoding not supported; use new-style JPEG compression instead",
    a4,
    a5,
    a6,
    a7,
    a8,
    vars0);
  return 0;
}

uint64_t OJPEGPostEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  TIFFErrorExtR(a1, "OJPEGPostEncode", "OJPEG encoding not supported; use new-style JPEG compression instead",
    a4,
    a5,
    a6,
    a7,
    a8,
    vars0);
  return 0;
}

uint64_t OJPEGEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  TIFFErrorExtR(a1, "OJPEGEncode", "OJPEG encoding not supported; use new-style JPEG compression instead",
    a4,
    a5,
    a6,
    a7,
    a8,
    vars0);
  return 0;
}

void *OJPEGCleanup(void *result)
{
  uint64_t v1 = result[137];
  if (v1)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(v1 + 224);
    result[161] = *(void *)(v1 + 216);
    result[160] = v3;
    result[162] = *(void *)(v1 + 232);
    uint64_t v4 = *(char **)(v1 + 376);
    if (v4) {
      _TIFFfreeExt((uint64_t)result, v4);
    }
    uint64_t v5 = *(char **)(v1 + 384);
    if (v5) {
      _TIFFfreeExt((uint64_t)v2, v5);
    }
    long long v6 = *(char **)(v1 + 392);
    if (v6) {
      _TIFFfreeExt((uint64_t)v2, v6);
    }
    uint64_t v7 = *(char **)(v1 + 400);
    if (v7) {
      _TIFFfreeExt((uint64_t)v2, v7);
    }
    unsigned int v8 = *(char **)(v1 + 408);
    if (v8) {
      _TIFFfreeExt((uint64_t)v2, v8);
    }
    uint64_t v9 = *(char **)(v1 + 416);
    if (v9) {
      _TIFFfreeExt((uint64_t)v2, v9);
    }
    unsigned int v10 = *(char **)(v1 + 424);
    if (v10) {
      _TIFFfreeExt((uint64_t)v2, v10);
    }
    uint64_t v11 = *(char **)(v1 + 432);
    if (v11) {
      _TIFFfreeExt((uint64_t)v2, v11);
    }
    unsigned __int8 v12 = *(char **)(v1 + 440);
    if (v12) {
      _TIFFfreeExt((uint64_t)v2, v12);
    }
    uint64_t v13 = *(char **)(v1 + 448);
    if (v13) {
      _TIFFfreeExt((uint64_t)v2, v13);
    }
    uint64_t v14 = *(char **)(v1 + 456);
    if (v14) {
      _TIFFfreeExt((uint64_t)v2, v14);
    }
    uint64_t v15 = *(char **)(v1 + 464);
    if (v15) {
      _TIFFfreeExt((uint64_t)v2, v15);
    }
    if (*(unsigned char *)(v1 + 608)) {
      OJPEGLibjpegSessionAbort((uint64_t)v2);
    }
    uint64_t v16 = *(char **)(v1 + 1544);
    if (v16) {
      _TIFFfreeExt((uint64_t)v2, v16);
    }
    uint64_t v17 = *(char **)(v1 + 1584);
    if (v17) {
      _TIFFfreeExt((uint64_t)v2, v17);
    }
    uint64_t v18 = *(char **)(v1 + 5768);
    if (v18) {
      _TIFFfreeExt((uint64_t)v2, v18);
    }
    _TIFFfreeExt((uint64_t)v2, (char *)v1);
    v2[137] = 0;
    return (void *)_TIFFSetDefaultCompressionState((uint64_t)v2);
  }
  return result;
}

uint64_t OJPEGVGetField(uint64_t a1, char *a2, _DWORD **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v14 = (void **)a3;
  uint64_t v8 = *(void *)(a1 + 1096);
  switch((int)a2)
  {
    case 512:
      __int16 v9 = *(unsigned __int8 *)(v8 + 288);
      goto LABEL_16;
    case 513:
      uint64_t v10 = *(void *)(v8 + 272);
      goto LABEL_12;
    case 514:
      uint64_t v10 = *(void *)(v8 + 280);
      goto LABEL_12;
    case 515:
      __int16 v9 = *(_WORD *)(v8 + 472);
      goto LABEL_16;
    case 519:
      uint64_t v14 = (void **)(a3 + 1);
      **a3 = *(unsigned __int8 *)(v8 + 295);
      uint64_t v10 = v8 + 304;
      goto LABEL_12;
    case 520:
      uint64_t v14 = (void **)(a3 + 1);
      **a3 = *(unsigned __int8 *)(v8 + 296);
      uint64_t v10 = v8 + 328;
      goto LABEL_12;
    case 521:
      uint64_t v14 = (void **)(a3 + 1);
      **a3 = *(unsigned __int8 *)(v8 + 297);
      uint64_t v10 = v8 + 352;
LABEL_12:
      **uint64_t v14 = v10;
      goto LABEL_17;
    case 530:
      if (!*(unsigned char *)(v8 + 290)) {
        OJPEGSubsamplingCorrect(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
      }
      uint64_t v13 = (_WORD **)v14++;
      **uint64_t v13 = *(unsigned __int8 *)(v8 + 292);
      __int16 v9 = *(unsigned __int8 *)(v8 + 293);
LABEL_16:
      *(_WORD *)*uint64_t v14 = v9;
LABEL_17:
      uint64_t result = 1;
      break;
    default:
      uint64_t v11 = *(uint64_t (**)(void))(v8 + 216);
      uint64_t result = v11();
      break;
  }
  return result;
}

uint64_t OJPEGVSetField(uint64_t a1, int a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 1096);
  switch(a2)
  {
    case 512:
      *(unsigned char *)(v9 + 288) = *a3;
      goto LABEL_28;
    case 513:
      *(void *)(v9 + 272) = *(void *)a3;
      goto LABEL_28;
    case 514:
      *(void *)(v9 + 280) = *(void *)a3;
      goto LABEL_28;
    case 515:
      *(_WORD *)(v9 + 472) = *a3;
      goto LABEL_28;
    case 519:
      uint64_t v12 = *a3;
      if (!v12) {
        goto LABEL_28;
      }
      if (v12 >= 4)
      {
        uint64_t v13 = "JpegQTables tag has incorrect count";
        goto LABEL_18;
      }
      *(unsigned char *)(v9 + 295) = v12;
      uint64_t v18 = (uint64_t *)*((void *)a3 + 1);
      uint64_t v19 = (void *)(v9 + 304);
      do
      {
        uint64_t v20 = *v18++;
        *v19++ = v20;
        --v12;
      }
      while (v12);
      goto LABEL_28;
    case 520:
      uint64_t v14 = *a3;
      if (!v14) {
        goto LABEL_28;
      }
      if (v14 >= 4)
      {
        uint64_t v13 = "JpegDcTables tag has incorrect count";
        goto LABEL_18;
      }
      *(unsigned char *)(v9 + 296) = v14;
      int64_t v21 = (uint64_t *)*((void *)a3 + 1);
      BOOL v22 = (void *)(v9 + 328);
      do
      {
        uint64_t v23 = *v21++;
        *v22++ = v23;
        --v14;
      }
      while (v14);
      goto LABEL_28;
    case 521:
      uint64_t v15 = *a3;
      if (!v15) {
        goto LABEL_28;
      }
      if (v15 < 4)
      {
        *(unsigned char *)(v9 + 297) = v15;
        uint64_t v24 = (uint64_t *)*((void *)a3 + 1);
        int64_t v25 = (void *)(v9 + 352);
        do
        {
          uint64_t v26 = *v24++;
          *v25++ = v26;
          --v15;
        }
        while (v15);
LABEL_28:
        uint64_t result = (uint64_t)TIFFFieldWithTag((void *)a1, a2);
        if (result)
        {
          unint64_t v27 = *(unsigned __int16 *)(result + 24);
          uint64_t result = 1;
          *(_DWORD *)(a1 + ((v27 >> 3) & 0x1FFC) + 72) |= 1 << v27;
          *(_DWORD *)(a1 + 16) |= 8u;
        }
      }
      else
      {
        uint64_t v13 = "JpegAcTables tag has incorrect count";
LABEL_18:
        TIFFErrorExtR(a1, "OJPEGVSetField", v13, a4, a5, a6, a7, a8, v28);
        return 0;
      }
      return result;
    case 530:
      *(unsigned char *)(v9 + 291) = 1;
      int v16 = *a3;
      *(unsigned char *)(v9 + 292) = *a3;
      unsigned int v17 = a3[2];
      *(unsigned char *)(v9 + 293) = v17;
      *(_WORD *)(a1 + 336) = v16;
      *(_WORD *)(a1 + 338) = v17;
      goto LABEL_28;
    default:
      uint64_t v10 = *(uint64_t (**)(void))(v9 + 224);
      return v10();
  }
}

uint64_t OJPEGPrintDir(uint64_t result, FILE *__stream, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 1096);
  if (!v3) {
    OJPEGPrintDir_cold_1();
  }
  uint64_t v6 = result;
  int v7 = *(_DWORD *)(result + 80);
  if ((v7 & 4) != 0)
  {
    uint64_t result = fprintf(__stream, "  JpegInterchangeFormat: %llu\n", *(void *)(v3 + 272));
    int v7 = *(_DWORD *)(v6 + 80);
    if ((v7 & 8) == 0)
    {
LABEL_4:
      if ((v7 & 0x10) == 0) {
        goto LABEL_5;
      }
      goto LABEL_16;
    }
  }
  else if ((v7 & 8) == 0)
  {
    goto LABEL_4;
  }
  uint64_t result = fprintf(__stream, "  JpegInterchangeFormatLength: %llu\n", *(void *)(v3 + 280));
  int v7 = *(_DWORD *)(v6 + 80);
  if ((v7 & 0x10) == 0)
  {
LABEL_5:
    if ((v7 & 0x20) == 0) {
      goto LABEL_6;
    }
    goto LABEL_20;
  }
LABEL_16:
  fwrite("  JpegQTables:", 0xEuLL, 1uLL, __stream);
  if (*(unsigned char *)(v3 + 295))
  {
    unint64_t v9 = 0;
    do
      fprintf(__stream, " %llu", *(void *)(v3 + 304 + 8 * v9++));
    while (v9 < *(unsigned __int8 *)(v3 + 295));
  }
  uint64_t result = fputc(10, __stream);
  int v7 = *(_DWORD *)(v6 + 80);
  if ((v7 & 0x20) == 0)
  {
LABEL_6:
    if ((v7 & 0x40) == 0) {
      goto LABEL_7;
    }
    goto LABEL_24;
  }
LABEL_20:
  fwrite("  JpegDcTables:", 0xFuLL, 1uLL, __stream);
  if (*(unsigned char *)(v3 + 296))
  {
    unint64_t v10 = 0;
    do
      fprintf(__stream, " %llu", *(void *)(v3 + 328 + 8 * v10++));
    while (v10 < *(unsigned __int8 *)(v3 + 296));
  }
  uint64_t result = fputc(10, __stream);
  int v7 = *(_DWORD *)(v6 + 80);
  if ((v7 & 0x40) == 0)
  {
LABEL_7:
    if ((v7 & 0x80) == 0) {
      goto LABEL_8;
    }
    goto LABEL_28;
  }
LABEL_24:
  fwrite("  JpegAcTables:", 0xFuLL, 1uLL, __stream);
  if (*(unsigned char *)(v3 + 297))
  {
    unint64_t v11 = 0;
    do
      fprintf(__stream, " %llu", *(void *)(v3 + 352 + 8 * v11++));
    while (v11 < *(unsigned __int8 *)(v3 + 297));
  }
  uint64_t result = fputc(10, __stream);
  int v7 = *(_DWORD *)(v6 + 80);
  if ((v7 & 0x80) == 0)
  {
LABEL_8:
    if ((v7 & 0x100) == 0) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
LABEL_28:
  uint64_t result = fprintf(__stream, "  JpegProc: %hhu\n", *(unsigned __int8 *)(v3 + 288));
  if ((*(_DWORD *)(v6 + 80) & 0x100) != 0) {
LABEL_9:
  }
    uint64_t result = fprintf(__stream, "  JpegRestartInterval: %hu\n", *(unsigned __int16 *)(v3 + 472));
LABEL_10:
  uint64_t v8 = *(uint64_t (**)(uint64_t, FILE *, uint64_t))(v3 + 232);
  if (v8)
  {
    return v8(v6, __stream, a3);
  }
  return result;
}

uint64_t OJPEGSubsamplingCorrect(uint64_t result, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(result + 1096);
  if (*(unsigned char *)(v8 + 290)) {
    OJPEGSubsamplingCorrect_cold_1();
  }
  uint64_t v9 = result;
  if (*(_WORD *)(result + 130) != 3
    || ((int v10 = *(unsigned __int16 *)(result + 122), v10 != 6) ? (v11 = v10 == 10) : (v11 = 1), !v11))
  {
    if (*(unsigned char *)(v8 + 291)) {
      uint64_t result = TIFFWarningExtR(result, "OJPEGSubsamplingCorrect", "Subsampling tag not appropriate for this Photometric and/or SamplesPerPixel", a4, a5, a6, a7, a8, v22);
    }
    *(_WORD *)(v8 + 292) = 257;
    *(unsigned char *)(v8 + 294) = 0;
    goto LABEL_14;
  }
  int v12 = *(unsigned __int8 *)(v8 + 292);
  int v13 = *(unsigned __int8 *)(v8 + 293);
  *(_WORD *)(v8 + 289) = 257;
  uint64_t result = OJPEGReadHeaderInfoSec(result, a2, a3, a4, a5, a6, a7, a8);
  int v19 = *(unsigned __int8 *)(v8 + 294);
  if (*(unsigned char *)(v8 + 294))
  {
    *(_WORD *)(v8 + 292) = 257;
    *(unsigned char *)(v8 + 289) = 0;
    if (v12 != 1) {
      goto LABEL_23;
    }
    LOBYTE(v12) = 1;
    LOBYTE(v20) = 1;
    goto LABEL_16;
  }
  int v20 = *(unsigned __int8 *)(v8 + 292);
  *(unsigned char *)(v8 + 289) = 0;
  if (v20 == v12)
  {
LABEL_16:
    if (v19) {
      BOOL v21 = 1;
    }
    else {
      BOOL v21 = *(unsigned __int8 *)(v8 + 293) == v13;
    }
    if (v21) {
      goto LABEL_23;
    }
  }
  if (*(unsigned char *)(v8 + 291)) {
    uint64_t result = TIFFWarningExtR(v9, "OJPEGSubsamplingCorrect", "Subsampling inside JPEG data [%hhu,%hhu] does not match subsampling tag values [%hhu,%hhu]; assuming subs"
  }
               "ampling inside JPEG data is correct",
               v14,
               v15,
               v16,
               v17,
               v18,
               v20);
  else {
    uint64_t result = TIFFWarningExtR(v9, "OJPEGSubsamplingCorrect", "Subsampling tag is not set, yet subsampling inside JPEG data [%hhu,%hhu] does not match default values [2,2]; assuming subsampling inside JPEG data is correct",
  }
               v14,
               v15,
               v16,
               v17,
               v18,
               v20);
LABEL_23:
  if (!*(unsigned char *)(v8 + 294)
    || (!*(unsigned char *)(v8 + 291)
      ? (uint64_t result = TIFFWarningExtR(v9, "OJPEGSubsamplingCorrect", "Subsampling tag is not set, yet subsampling inside JPEG data does not match default values [2,2] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampl"
                    "ing inside JPEG decompression",
                    v14,
                    v15,
                    v16,
                    v17,
                    v18,
                    v22))
      : (uint64_t result = TIFFWarningExtR(v9, "OJPEGSubsamplingCorrect", "Subsampling inside JPEG data does not match subsampling tag values [%hhu,%hhu] (nor any other values allowed in TIFF); assuming subsampling inside JPEG data is correct and desubsampling inside JPEG decompression",
                    v14,
                    v15,
                    v16,
                    v17,
                    v18,
                    v12)),
        !*(unsigned char *)(v8 + 294)))
  {
    if (*(unsigned __int8 *)(v8 + 292) < *(unsigned __int8 *)(v8 + 293)) {
      uint64_t result = TIFFWarningExtR(v9, "OJPEGSubsamplingCorrect", "Subsampling values [%hhu,%hhu] are not allowed in TIFF", v14, v15, v16, v17, v18, *(unsigned char *)(v8 + 292));
    }
  }
LABEL_14:
  *(unsigned char *)(v8 + 290) = 1;
  return result;
}

uint64_t OJPEGReadHeaderInfoSec(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void *)(a1 + 1096);
  unsigned __int16 v87 = 0;
  unint64_t v10 = *(void *)(v9 + 240);
  if (!v10)
  {
    unint64_t v10 = (*(uint64_t (**)(void))(a1 + 1240))(*(void *)(a1 + 1200));
    *(void *)(v9 + 240) = v10;
  }
  unint64_t v11 = *(void *)(v9 + 272);
  if (v11)
  {
    if (v10 <= v11)
    {
      *(void *)(v9 + 272) = 0;
      *(void *)(v9 + 280) = 0;
    }
    else
    {
      uint64_t v12 = *(void *)(v9 + 280);
      BOOL v13 = __CFADD__(v12, v11);
      if (!v12 || v13 || v12 + v11 > v10) {
        *(void *)(v9 + 280) = v10 - v11;
      }
    }
  }
  __int16 v14 = 0;
  *(void *)(v9 + 1608) = 0;
  *(_DWORD *)(v9 + 1616) = *(_DWORD *)(a1 + 228);
  *(void *)(v9 + 1640) = 0;
  *(_WORD *)(v9 + 1648) = 0;
  while (2)
  {
    if (!v14)
    {
      uint64_t result = OJPEGReadBufferFill(v9);
      if (!result) {
        return result;
      }
      __int16 v14 = *(_WORD *)(v9 + 1648);
      if (!v14) {
        OJPEGReadHeaderInfoSec_cold_1();
      }
    }
    uint64_t v16 = *(unsigned __int8 **)(v9 + 1656);
    unsigned __int8 v88 = *v16;
    if (v88 == 255)
    {
      *(void *)(v9 + 1656) = v16 + 1;
      *(_WORD *)(v9 + 1648) = v14 - 1;
LABEL_19:
      uint64_t result = OJPEGReadByte(v9, &v88);
      if (!result) {
        return result;
      }
      int v17 = v88;
      switch(v88)
      {
        case 0xC0u:
        case 0xC1u:
        case 0xC3u:
          uint64_t v18 = *(void *)(a1 + 1096);
          if (*(unsigned char *)(v18 + 475))
          {
            int v46 = "OJPEGReadHeaderInfoSecStreamSof";
LABEL_147:
            uint64_t v61 = "Corrupt JPEG data";
            goto LABEL_194;
          }
          if (!*(unsigned char *)(v18 + 289)) {
            *(unsigned char *)(v18 + 476) = v88;
          }
          v91.i16[0] = 0;
          if (!OJPEGReadWord(v18, &v91)) {
            return 0;
          }
          if (v91.u16[0] <= 0xAu) {
            goto LABEL_143;
          }
          uint64_t v19 = (unsigned __int16)(v91.i16[0] - 8) / 3u;
          int v20 = *(unsigned __int8 *)(v18 + 289);
          if (v91.i16[0] - 8 != 3 * ((unsigned __int16)((unsigned __int16)(v91.i16[0] - 8) / 0x18000u) >> 1)) {
            goto LABEL_144;
          }
          if (!*(unsigned char *)(v18 + 289) && v19 != *(unsigned __int8 *)(v18 + 268))
          {
            int v46 = "OJPEGReadHeaderInfoSecStreamSof";
            uint64_t v61 = "JPEG compressed data indicates unexpected number of samples";
            goto LABEL_194;
          }
          unsigned __int8 v90 = 0;
          if (!OJPEGReadByte(v18, &v90)) {
            return 0;
          }
          if (v90 != 8)
          {
            if (!*(unsigned char *)(v18 + 289))
            {
              int v46 = "OJPEGReadHeaderInfoSecStreamSof";
              uint64_t v61 = "JPEG compressed data indicates unexpected number of bits per sample";
              goto LABEL_194;
            }
            return 0;
          }
          if (*(unsigned char *)(v18 + 289))
          {
            OJPEGReadSkip(v18, 4u);
          }
          else
          {
            unsigned __int16 v89 = 0;
            if (!OJPEGReadWord(v18, &v89)) {
              return 0;
            }
            if (*(_DWORD *)(v18 + 252) > v89 && *(_DWORD *)(v18 + 264) > v89)
            {
              int v46 = "OJPEGReadHeaderInfoSecStreamSof";
              uint64_t v61 = "JPEG compressed data indicates unexpected height";
              goto LABEL_194;
            }
            *(_DWORD *)(v18 + 484) = v89;
            if (!OJPEGReadWord(v18, &v89)) {
              return 0;
            }
            unsigned int v33 = *(_DWORD *)(v18 + 256);
            if (*(_DWORD *)(v18 + 248) > v89 && v33 > v89)
            {
              int v46 = "OJPEGReadHeaderInfoSecStreamSof";
              uint64_t v61 = "JPEG compressed data indicates unexpected width";
              goto LABEL_194;
            }
            if (v33 < v89)
            {
              int v46 = "OJPEGReadHeaderInfoSecStreamSof";
              uint64_t v61 = "JPEG compressed data image width exceeds expected image width";
              goto LABEL_194;
            }
            *(_DWORD *)(v18 + 480) = v89;
          }
          if (!OJPEGReadByte(v18, &v90)) {
            return 0;
          }
          if (v19 != v90)
          {
LABEL_143:
            int v20 = *(unsigned __int8 *)(v18 + 289);
LABEL_144:
            if (!v20)
            {
              int v46 = "OJPEGReadHeaderInfoSecStreamSof";
              uint64_t v61 = "Corrupt SOF marker in JPEG data";
              goto LABEL_194;
            }
            return 0;
          }
          if (!OJPEGReadByte(v18, &v90)) {
            return 0;
          }
          uint64_t v34 = 0;
          while (2)
          {
            if (!*(unsigned char *)(v18 + 289)) {
              *(unsigned char *)(v18 + v34 + 488) = v90;
            }
            if (!OJPEGReadByte(v18, &v90)) {
              return 0;
            }
            if (*(unsigned char *)(v18 + 289))
            {
              unsigned __int8 v35 = v90;
              if (v34)
              {
                if (v90 == 17) {
                  goto LABEL_83;
                }
              }
              else
              {
                *(unsigned char *)(v18 + 292) = v90 >> 4;
                *(unsigned char *)(v18 + 293) = v35 & 0xF;
              }
              *(unsigned char *)(v18 + 294) = 1;
            }
            else
            {
              int v36 = v90;
              *(unsigned char *)(v18 + v34 + 491) = v90;
              if (!*(unsigned char *)(v18 + 294))
              {
                if (v34)
                {
                  if (v36 != 17) {
                    goto LABEL_150;
                  }
                }
                else if ((*(unsigned __int8 *)(v18 + 293) | (16 * *(unsigned __int8 *)(v18 + 292))) != v36)
                {
LABEL_150:
                  int v46 = "OJPEGReadHeaderInfoSecStreamSof";
                  uint64_t v61 = "JPEG compressed data indicates unexpected subsampling values";
                  goto LABEL_194;
                }
              }
            }
LABEL_83:
            if (!OJPEGReadByte(v18, &v90)) {
              return 0;
            }
            if (*(unsigned char *)(v18 + 289))
            {
              if (++v34 == v19) {
                goto LABEL_101;
              }
LABEL_88:
              if (!OJPEGReadByte(v18, &v90)) {
                return 0;
              }
              continue;
            }
            break;
          }
          *(unsigned char *)(v18 + v34++ + 494) = v90;
          if (v34 != v19) {
            goto LABEL_88;
          }
          *(unsigned char *)(v18 + 475) = 1;
LABEL_101:
          if (*(unsigned char *)(v9 + 289)) {
            return 1;
          }
LABEL_102:
          if (v17 == 218) {
            break;
          }
LABEL_25:
          __int16 v14 = *(_WORD *)(v9 + 1648);
          continue;
        case 0xC4u:
          uint64_t v21 = *(void *)(a1 + 1096);
          v91.i16[0] = 0;
          if (!OJPEGReadWord(v21, &v91)) {
            return 0;
          }
          __int16 v23 = v91.i16[0];
          unsigned __int16 v24 = v91.i16[0] - 2;
          if (v91.u16[0] <= 2u)
          {
            if (!*(unsigned char *)(v21 + 289))
            {
              int v46 = "OJPEGReadHeaderInfoSecStreamDht";
              uint64_t v61 = "Corrupt DHT marker in JPEG data";
              goto LABEL_194;
            }
            return 0;
          }
          if (*(unsigned char *)(v21 + 289))
          {
            OJPEGReadSkip(v21, (unsigned __int16)(v91.i16[0] - 2));
            goto LABEL_25;
          }
          int v37 = v91.u16[0] + 6;
          unsigned int v38 = _TIFFmallocExt((void *)a1, v91.u16[0] + 6, v22, a4, a5, a6, a7, a8);
          if (!v38)
          {
            int v46 = "OJPEGReadHeaderInfoSecStreamDht";
LABEL_152:
            uint64_t v61 = "Out of memory";
            goto LABEL_194;
          }
          char v39 = (char *)v38;
          *(_DWORD *)unsigned int v38 = v37;
          *((_WORD *)v38 + 2) = -15105;
          *((unsigned char *)v38 + 6) = HIBYTE(v23);
          *((unsigned char *)v38 + 7) = v23;
          char v40 = (unsigned __int8 *)(v38 + 1);
          if (!OJPEGReadBlock(v21, v24, (char *)v38 + 8)) {
            goto LABEL_198;
          }
          uint64_t v41 = *v40;
          if ((v41 & 0xF0) == 0x10)
          {
            uint64_t v44 = v41 & 0xF;
            if (v44 < 4)
            {
              uint64_t v45 = v21 + 8 * v44;
              a2 = *(char **)(v45 + 440);
              if (a2) {
                _TIFFfreeExt(a1, a2);
              }
              char v43 = (char **)(v45 + 440);
              goto LABEL_108;
            }
          }
          else if ((v41 & 0xF0) == 0 && v41 < 4)
          {
            uint64_t v42 = v21 + 8 * v41;
            a2 = *(char **)(v42 + 408);
            if (a2) {
              _TIFFfreeExt(a1, a2);
            }
            char v43 = (char **)(v42 + 408);
LABEL_108:
            *char v43 = v39;
            goto LABEL_25;
          }
          TIFFErrorExtR(a1, "OJPEGReadHeaderInfoSecStreamDht", "Corrupt DHT marker in JPEG data", a4, a5, a6, a7, a8, v86);
LABEL_198:
          uint64_t v62 = a1;
          uint64_t v63 = v39;
          goto LABEL_199;
        case 0xD8u:
          goto LABEL_25;
        case 0xDAu:
          if (*(unsigned char *)(v9 + 289)) {
            return 1;
          }
          if (*(unsigned char *)(v9 + 269)) {
            OJPEGReadHeaderInfoSec_cold_2();
          }
          uint64_t result = OJPEGReadHeaderInfoSecStreamSos(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
          if (result) {
            goto LABEL_113;
          }
          return result;
        case 0xDBu:
          uint64_t v25 = *(void *)(a1 + 1096);
          v91.i16[0] = 0;
          if (!OJPEGReadWord(v25, &v91)) {
            return 0;
          }
          unsigned __int16 v26 = v91.i16[0] - 2;
          if (v91.u16[0] <= 2u)
          {
            if (*(unsigned char *)(v25 + 289)) {
              return 0;
            }
LABEL_161:
            int v46 = "OJPEGReadHeaderInfoSecStreamDqt";
            uint64_t v61 = "Corrupt DQT marker in JPEG data";
            goto LABEL_194;
          }
          if (*(unsigned char *)(v25 + 289))
          {
            OJPEGReadSkip(v25, (unsigned __int16)(v91.i16[0] - 2));
            goto LABEL_102;
          }
          while (1)
          {
            if (v26 <= 0x40u) {
              goto LABEL_161;
            }
            unint64_t v27 = (char *)_TIFFmallocExt((void *)a1, 73, a3, a4, a5, a6, a7, a8);
            if (!v27) {
              break;
            }
            char v28 = v27;
            *(_DWORD *)unint64_t v27 = 73;
            *((_DWORD *)v27 + 1) = 1124129791;
            int v29 = v27 + 8;
            if (!OJPEGReadBlock(v25, 65, v27 + 8)) {
              goto LABEL_154;
            }
            uint64_t v30 = *v29 & 0xF;
            if (v30 >= 4)
            {
              TIFFErrorExtR(a1, "OJPEGReadHeaderInfoSecStreamDqt", "Corrupt DQT marker in JPEG data", a4, a5, a6, a7, a8, v86);
LABEL_154:
              uint64_t v62 = a1;
              uint64_t v63 = v28;
LABEL_199:
              _TIFFfreeExt(v62, v63);
              return 0;
            }
            uint64_t v31 = v25 + 8 * v30;
            a2 = *(char **)(v31 + 376);
            if (a2) {
              _TIFFfreeExt(a1, a2);
            }
            *(void *)(v31 + 376) = v28;
            v26 -= 65;
            if (!v26) {
              goto LABEL_102;
            }
          }
          int v46 = "OJPEGReadHeaderInfoSecStreamDqt";
          goto LABEL_152;
        case 0xDDu:
          uint64_t v32 = *(void *)(a1 + 1096);
          v91.i16[0] = 0;
          if (!OJPEGReadWord(v32, &v91)) {
            return 0;
          }
          if (v91.u16[0] != 4)
          {
            int v46 = "OJPEGReadHeaderInfoSecStreamDri";
            uint64_t v61 = "Corrupt DRI marker in JPEG data";
            goto LABEL_194;
          }
          if (!OJPEGReadWord(v32, &v91)) {
            return 0;
          }
          *(_WORD *)(v32 + 472) = v91.i16[0];
          goto LABEL_25;
        case 0xE0u:
        case 0xE1u:
        case 0xE2u:
        case 0xE3u:
        case 0xE4u:
        case 0xE5u:
        case 0xE6u:
        case 0xE7u:
        case 0xE8u:
        case 0xE9u:
        case 0xEAu:
        case 0xEBu:
        case 0xECu:
        case 0xEDu:
        case 0xEEu:
        case 0xEFu:
        case 0xFEu:
          uint64_t result = OJPEGReadWord(v9, &v87);
          if (!result) {
            return result;
          }
          if (v87 > 1u)
          {
            if (v87 != 2) {
              OJPEGReadSkip(v9, (unsigned __int16)(v87 - 2));
            }
            goto LABEL_25;
          }
          if (*(unsigned char *)(v9 + 289)) {
            return 0;
          }
          int v46 = "OJPEGReadHeaderInfoSec";
          goto LABEL_147;
        case 0xFFu:
          goto LABEL_19;
        default:
          TIFFErrorExtR(a1, "OJPEGReadHeaderInfoSec", "Unknown marker type %hhu in JPEG data", a4, a5, a6, a7, a8, v88);
          return 0;
      }
    }
    break;
  }
LABEL_113:
  if (*(unsigned char *)(v9 + 289) || *(unsigned char *)(v9 + 475)) {
    return 1;
  }
  uint64_t v47 = *(void *)(a1 + 1096);
  if (!*(void *)(v47 + 304))
  {
    int v46 = "OJPEGReadHeaderInfoSecTablesQTable";
LABEL_193:
    uint64_t v61 = "Missing JPEG tables";
    goto LABEL_194;
  }
  *(unsigned char *)(v47 + 1632) = 0;
  unsigned int v48 = *(unsigned __int8 *)(v47 + 268);
  if (*(unsigned char *)(v47 + 268))
  {
    unint64_t v49 = 0;
    uint64_t v50 = -1;
    while (1)
    {
      uint64_t v51 = v47 + 8 * v49;
      uint64_t v52 = *(void *)(v51 + 304);
      if (!v52) {
        break;
      }
      if (v49)
      {
        unint64_t v53 = v49 - 1;
        if (v52 == *(void *)(v47 + 8 * (v49 - 1) + 304)) {
          goto LABEL_134;
        }
        if (v49 >= 2)
        {
          uint64_t v54 = 0;
          do
          {
            if (v52 == *(void *)(v47 + 304 + 8 * v54))
            {
              int v46 = "OJPEGReadHeaderInfoSecTablesQTable";
              uint64_t v61 = "Corrupt JpegQTables tag value";
              goto LABEL_194;
            }
            ++v54;
          }
          while (v50 != v54);
        }
      }
      uint64_t v55 = (char *)_TIFFmallocExt((void *)a1, 73, a3, a4, a5, a6, a7, a8);
      if (!v55)
      {
        int v46 = "OJPEGReadHeaderInfoSecTablesQTable";
        goto LABEL_152;
      }
      char v39 = v55;
      *(_DWORD *)uint64_t v55 = 73;
      *((_DWORD *)v55 + 1) = 1124129791;
      v55[8] = v49;
      (*(void (**)(void, void, void))(a1 + 1224))(*(void *)(a1 + 1200), *(void *)(v51 + 304), 0);
      if ((*(unsigned int (**)(void, char *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), v39 + 9, 64) != 64) {
        goto LABEL_198;
      }
      uint64_t v56 = v47 + 8 * v49;
      a2 = *(char **)(v56 + 376);
      if (a2) {
        _TIFFfreeExt(a1, a2);
      }
      *(void *)(v56 + 376) = v39;
      *(unsigned char *)(v47 + v49 + 494) = v49;
      unsigned int v48 = *(unsigned __int8 *)(v47 + 268);
LABEL_135:
      ++v49;
      ++v50;
      if (v49 >= v48) {
        goto LABEL_136;
      }
    }
    unint64_t v53 = v49 - 1;
LABEL_134:
    *(unsigned char *)(v47 + 494 + v49) = *(unsigned char *)(v47 + 494 + v53);
    goto LABEL_135;
  }
LABEL_136:
  *(unsigned char *)(v9 + 476) = -64;
  unint64_t v57 = *(unsigned __int8 *)(v9 + 268);
  if (*(unsigned char *)(v9 + 268))
  {
    unint64_t v58 = 0;
    do
    {
      *(unsigned char *)(v9 + 488 + v58) = v58;
      ++v58;
    }
    while (v58 < v57);
    *(unsigned char *)(v9 + 491) = *(unsigned char *)(v9 + 293) | (16 * *(unsigned char *)(v9 + 292));
    if (v57 >= 2)
    {
      uint64_t v59 = 492;
      do
      {
        *(unsigned char *)(v9 + v59) = 17;
        unint64_t v60 = v59 - 490;
        ++v59;
      }
      while (v60 < v57);
    }
  }
  else
  {
    *(unsigned char *)(v9 + 491) = *(unsigned char *)(v9 + 293) | (16 * *(unsigned char *)(v9 + 292));
  }
  *(_DWORD *)(v9 + 480) = *(_DWORD *)(v9 + 256);
  *(_DWORD *)(v9 + 484) = *(_DWORD *)(v9 + 264);
  *(unsigned char *)(v9 + 475) = 1;
  uint64_t v64 = *(void *)(a1 + 1096);
  if (!*(void *)(v64 + 328))
  {
    int v46 = "OJPEGReadHeaderInfoSecTablesDcTable";
    goto LABEL_193;
  }
  *(unsigned char *)(v64 + 1632) = 0;
  unsigned int v65 = *(unsigned __int8 *)(v64 + 268);
  if (*(unsigned char *)(v64 + 268))
  {
    unint64_t v66 = 0;
    uint8x16_t v91 = 0uLL;
    uint64_t v67 = -1;
    while (1)
    {
      a2 = *(char **)(v64 + 8 * v66 + 328);
      if (!a2) {
        break;
      }
      if (v66)
      {
        unint64_t v68 = v66 - 1;
        if (a2 == *(char **)(v64 + 8 * (v66 - 1) + 328)) {
          goto LABEL_185;
        }
        if (v66 >= 2)
        {
          uint64_t v69 = 0;
          while (a2 != *(char **)(v64 + 328 + 8 * v69))
          {
            if (v67 == ++v69) {
              goto LABEL_176;
            }
          }
          int v46 = "OJPEGReadHeaderInfoSecTablesDcTable";
          uint64_t v61 = "Corrupt JpegDcTables tag value";
LABEL_194:
          TIFFErrorExtR(a1, v46, v61, a4, a5, a6, a7, a8, v86);
          return 0;
        }
      }
LABEL_176:
      (*(void (**)(void))(a1 + 1224))(*(void *)(a1 + 1200));
      if ((*(unsigned int (**)(void, uint8x16_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v91, 16) != 16)return 0; {
      uint16x8_t v76 = vmovl_high_u8(v91);
      }
      uint16x8_t v77 = vmovl_u8(*(uint8x8_t *)v91.i8);
      v77.i32[0] = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v77.i8, *(uint16x4_t *)v76.i8), (int32x4_t)vaddl_high_u16(v77, v76)));
      uint64_t v78 = v77.u32[0];
      __int32 v79 = v77.i32[0] + 25;
      int v80 = (char *)_TIFFmallocExt((void *)a1, (v77.i32[0] + 25), v70, v71, v72, v73, v74, v75);
      if (!v80)
      {
        int v46 = "OJPEGReadHeaderInfoSecTablesDcTable";
        goto LABEL_152;
      }
      char v39 = v80;
      uint64_t v81 = 0;
      *(_DWORD *)int v80 = v79;
      *((_WORD *)v80 + 2) = -15105;
      v80[6] = (unsigned __int16)(v78 + 19) >> 8;
      v80[7] = v78 + 19;
      v80[8] = v66;
      do
      {
        v80[v81 + 9] = v91.i8[v81];
        ++v81;
      }
      while (v81 != 16);
      if (v78 != (*(unsigned int (**)(void, char *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), v80 + 25, v78))goto LABEL_198; {
      uint64_t v82 = v64 + 8 * v66;
      }
      a2 = *(char **)(v82 + 408);
      if (a2) {
        _TIFFfreeExt(a1, a2);
      }
      *(void *)(v82 + 408) = v39;
      *(unsigned char *)(v64 + v66 + 500) = 16 * v66;
      unsigned int v65 = *(unsigned __int8 *)(v64 + 268);
LABEL_186:
      ++v66;
      ++v67;
      if (v66 >= v65) {
        goto LABEL_187;
      }
    }
    unint64_t v68 = v66 - 1;
LABEL_185:
    *(unsigned char *)(v64 + 500 + v66) = *(unsigned char *)(v64 + 500 + v68);
    goto LABEL_186;
  }
LABEL_187:
  uint64_t result = OJPEGReadHeaderInfoSecTablesAcTable(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (!result) {
    return result;
  }
  unint64_t v83 = *(unsigned __int8 *)(v9 + 268);
  if (v83 < 2) {
    return 1;
  }
  uint64_t v84 = 498;
  uint64_t result = 1;
  do
  {
    *(unsigned char *)(v9 + v84) = v84 + 15;
    unint64_t v85 = v84 - 496;
    ++v84;
  }
  while (v85 < v83);
  return result;
}

uint64_t OJPEGReadByte(uint64_t a1, unsigned char *a2)
{
  if (!*(_WORD *)(a1 + 1648))
  {
    uint64_t result = OJPEGReadBufferFill(a1);
    if (!result) {
      return result;
    }
    if (!*(_WORD *)(a1 + 1648)) {
      OJPEGReadByte_cold_1();
    }
  }
  *a2 = *(unsigned char *)(*(void *)(a1 + 1656))++;
  --*(_WORD *)(a1 + 1648);
  return 1;
}

uint64_t OJPEGReadWord(uint64_t a1, _WORD *a2)
{
  unsigned __int8 v5 = 0;
  uint64_t result = OJPEGReadByte(a1, &v5);
  if (result)
  {
    *a2 = v5 << 8;
    uint64_t result = OJPEGReadByte(a1, &v5);
    if (result)
    {
      *a2 |= v5;
      return 1;
    }
  }
  return result;
}

uint64_t OJPEGReadSkip(uint64_t result, unsigned int a2)
{
  unsigned int v2 = *(unsigned __int16 *)(result + 1648);
  if (v2 >= a2) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = *(unsigned __int16 *)(result + 1648);
  }
  *(void *)(result + 1656) += v3;
  *(_WORD *)(result + 1648) = v2 - v3;
  if (v2 < a2)
  {
    unsigned __int16 v4 = a2 - v3;
    unint64_t v5 = *(void *)(result + 1640);
    if (v5 < v4) {
      unsigned __int16 v4 = *(void *)(result + 1640);
    }
    *(void *)(result + 1624) += v4;
    *(void *)(result + 1640) = v5 - v4;
    *(unsigned char *)(result + 1632) = 0;
  }
  return result;
}

uint64_t OJPEGReadHeaderInfoSecStreamSos(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned __int8 **)(a1 + 1096);
  if (v8[289]) {
    OJPEGReadHeaderInfoSecStreamSos_cold_1();
  }
  if (!v8[475]) {
    goto LABEL_13;
  }
  unsigned __int16 v14 = 0;
  uint64_t result = OJPEGReadWord((uint64_t)v8, &v14);
  if (!result) {
    return result;
  }
  if (2 * v8[270] + 6 != v14) {
    goto LABEL_13;
  }
  unsigned __int8 v13 = 0;
  uint64_t result = OJPEGReadByte((uint64_t)v8, &v13);
  if (!result) {
    return result;
  }
  if (v13 == v8[270])
  {
    if (v13)
    {
      uint64_t v11 = 0;
      while (1)
      {
        uint64_t result = OJPEGReadByte((uint64_t)v8, &v13);
        if (!result) {
          break;
        }
        v8[v11 + 497 + v8[269]] = v13;
        uint64_t result = OJPEGReadByte((uint64_t)v8, &v13);
        if (!result) {
          break;
        }
        v8[v11++ + 500 + v8[269]] = v13;
        if (v11 >= v8[270]) {
          goto LABEL_12;
        }
      }
    }
    else
    {
LABEL_12:
      OJPEGReadSkip((uint64_t)v8, 3u);
      return 1;
    }
  }
  else
  {
LABEL_13:
    TIFFErrorExtR(a1, "OJPEGReadHeaderInfoSecStreamSos", "Corrupt SOS marker in JPEG data", a4, a5, a6, a7, a8, v12);
    return 0;
  }
  return result;
}

uint64_t OJPEGReadHeaderInfoSecTablesAcTable(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void *)(a1 + 1096);
  if (*(void *)(v9 + 352))
  {
    *(unsigned char *)(v9 + 1632) = 0;
    unsigned int v10 = *(unsigned __int8 *)(v9 + 268);
    if (*(unsigned char *)(v9 + 268))
    {
      unint64_t v11 = 0;
      uint8x16_t v32 = 0uLL;
      while (1)
      {
        uint64_t v12 = *(void *)(v9 + 8 * v11 + 352);
        if (!v12) {
          break;
        }
        if (v11)
        {
          int64_t v13 = v11 - 1;
          if (v12 == *(void *)(v9 + 8 * (v11 - 1) + 352)) {
            goto LABEL_20;
          }
          if (v11 >= 2)
          {
            uint64_t v14 = 0;
            while (v12 != *(void *)(v9 + 8 * v14 + 352))
            {
              if (v13 <= ++v14) {
                goto LABEL_11;
              }
            }
            uint64_t v31 = "Corrupt JpegAcTables tag value";
            goto LABEL_25;
          }
        }
LABEL_11:
        (*(void (**)(void))(a1 + 1224))(*(void *)(a1 + 1200));
        if ((*(unsigned int (**)(void, uint8x16_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v32, 16) != 16)return 0; {
        uint16x8_t v21 = vmovl_high_u8(v32);
        }
        uint16x8_t v22 = vmovl_u8(*(uint8x8_t *)v32.i8);
        v22.i32[0] = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v22.i8, *(uint16x4_t *)v21.i8), (int32x4_t)vaddl_high_u16(v22, v21)));
        uint64_t v23 = v22.u32[0];
        __int32 v24 = v22.i32[0] + 25;
        uint64_t v25 = (char *)_TIFFmallocExt((void *)a1, (v22.i32[0] + 25), v15, v16, v17, v18, v19, v20);
        if (!v25)
        {
          uint64_t v31 = "Out of memory";
          goto LABEL_25;
        }
        unsigned __int16 v26 = v25;
        uint64_t v27 = 0;
        *(_DWORD *)uint64_t v25 = v24;
        *((_WORD *)v25 + 2) = -15105;
        v25[6] = (unsigned __int16)(v23 + 19) >> 8;
        v25[7] = v23 + 19;
        v25[8] = v11 | 0x10;
        do
        {
          v25[v27 + 9] = v32.i8[v27];
          ++v27;
        }
        while (v27 != 16);
        if (v23 != (*(unsigned int (**)(void, char *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), v25 + 25, v23))
        {
          _TIFFfreeExt(a1, v26);
          return 0;
        }
        uint64_t v28 = v9 + 8 * v11;
        int v29 = *(char **)(v28 + 440);
        if (v29) {
          _TIFFfreeExt(a1, v29);
        }
        *(void *)(v28 + 440) = v26;
        *(unsigned char *)(v9 + v11 + 500) |= v11;
        unsigned int v10 = *(unsigned __int8 *)(v9 + 268);
LABEL_21:
        if (++v11 >= v10) {
          return 1;
        }
      }
      int64_t v13 = v11 - 1;
LABEL_20:
      *(unsigned char *)(v9 + 500 + v11) |= *(unsigned char *)(v9 + 500 + v13) & 0xF;
      goto LABEL_21;
    }
    return 1;
  }
  else
  {
    uint64_t v31 = "Missing JPEG tables";
LABEL_25:
    TIFFErrorExtR(a1, "OJPEGReadHeaderInfoSecTablesAcTable", v31, a4, a5, a6, a7, a8, v32.i8[0]);
    return 0;
  }
}

uint64_t OJPEGReadBufferFill(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 1640);
  if (!v2)
  {
    do
    {
      *(unsigned char *)(a1 + 1632) = 0;
      int v3 = *(_DWORD *)(a1 + 1608);
      if (v3 == 2)
      {
        uint64_t v5 = *(unsigned int *)(a1 + 1612);
        if (v5 == *(_DWORD *)(a1 + 1616))
        {
          unint64_t v4 = 0;
          *(_DWORD *)(a1 + 1608) = 3;
        }
        else
        {
          uint64_t v6 = TIFFGetStrileOffsetWithErr(*(void *)a1, v5);
          *(void *)(a1 + 1624) = v6;
          if (v6)
          {
            uint64_t v7 = TIFFGetStrileByteCountWithErr(*(void *)a1, *(unsigned int *)(a1 + 1612));
            unint64_t v8 = *(void *)(a1 + 1624);
            unint64_t v9 = *(void *)(a1 + 240);
            if (v9 <= v8)
            {
              *(void *)(a1 + 1624) = 0;
            }
            else if (!v7 || (*(void *)(a1 + 1640) = v7, __CFADD__(v7, v8)) || v8 + v7 > v9)
            {
              *(void *)(a1 + 1640) = v9 - v8;
            }
          }
          ++*(_DWORD *)(a1 + 1612);
          unint64_t v2 = *(void *)(a1 + 1640);
          unint64_t v4 = v2;
        }
      }
      else if (v3 == 1)
      {
        unint64_t v4 = 0;
        *(_DWORD *)(a1 + 1608) = 2;
      }
      else
      {
        if (v3) {
          return 0;
        }
        unint64_t v4 = *(void *)(a1 + 272);
        if (v4)
        {
          *(void *)(a1 + 1624) = v4;
          unint64_t v2 = *(void *)(a1 + 280);
          *(void *)(a1 + 1640) = v2;
          unint64_t v4 = v2;
        }
        *(_DWORD *)(a1 + 1608) = 1;
      }
    }
    while (!v4);
  }
  if (!*(unsigned char *)(a1 + 1632))
  {
    (*(void (**)(void, void, void))(*(void *)a1 + 1224))(*(void *)(*(void *)a1 + 1200), *(void *)(a1 + 1624), 0);
    *(unsigned char *)(a1 + 1632) = 1;
    unint64_t v2 = *(void *)(a1 + 1640);
  }
  if (v2 >= 0x800) {
    uint64_t v10 = 2048;
  }
  else {
    uint64_t v10 = (unsigned __int16)v2;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)a1 + 1208))(*(void *)(*(void *)a1 + 1200), a1 + 1664, v10);
  if (result)
  {
    if (result <= 0) {
      OJPEGReadBufferFill_cold_1();
    }
    if ((unint64_t)result >= 0x801) {
      OJPEGReadBufferFill_cold_2();
    }
    unint64_t v12 = *(void *)(a1 + 1640);
    BOOL v13 = v12 >= result;
    unint64_t v14 = v12 - result;
    if (!v13) {
      OJPEGReadBufferFill_cold_3();
    }
    *(_WORD *)(a1 + 1648) = result;
    *(void *)(a1 + 1656) = a1 + 1664;
    *(void *)(a1 + 1640) = v14;
    *(void *)(a1 + 1624) += result;
    return 1;
  }
  return result;
}

uint64_t OJPEGReadBlock(uint64_t a1, int a2, char *__dst)
{
  if (!a2) {
    OJPEGReadBlock_cold_1();
  }
  unsigned __int16 v4 = a2;
  unsigned __int16 v6 = *(_WORD *)(a1 + 1648);
  do
  {
    if (!v6)
    {
      uint64_t result = OJPEGReadBufferFill(a1);
      if (!result) {
        return result;
      }
      unsigned __int16 v6 = *(_WORD *)(a1 + 1648);
      if (!v6) {
        OJPEGReadBlock_cold_2();
      }
    }
    if (v4 >= v6) {
      size_t v8 = v6;
    }
    else {
      size_t v8 = v4;
    }
    _TIFFmemcpy(__dst, *(const void **)(a1 + 1656), v8);
    *(void *)(a1 + 1656) += v8;
    unsigned __int16 v6 = *(_WORD *)(a1 + 1648) - v8;
    *(_WORD *)(a1 + 1648) = v6;
    v4 -= v8;
    __dst += v8;
  }
  while (v4);
  return 1;
}

uint64_t OJPEGLibjpegSessionAbort(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1096);
  if (!*(unsigned char *)(v1 + 608)) {
    OJPEGLibjpegSessionAbort_cold_1();
  }
  uint64_t result = _cg_jpeg_destroy(v1 + 792);
  *(unsigned char *)(v1 + 608) = 0;
  return result;
}

uint64_t OJPEGLibjpegJpegErrorMgrOutputMessage(uint64_t *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  (*(void (**)(uint64_t *, _OWORD *))(*a1 + 24))(a1, v8);
  return TIFFWarningExtR(a1[3], "LibJpeg", "%s", v2, v3, v4, v5, v6, (char)v8);
}

void OJPEGLibjpegJpegErrorMgrErrorExit(uint64_t *a1)
{
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  (*(void (**)(uint64_t *, _OWORD *))(*a1 + 24))(a1, v7);
  TIFFErrorExtR(a1[3], "LibJpeg", "%s", v2, v3, v4, v5, v6, (char)v7);
  siglongjmp((int *)(*(void *)(a1[3] + 1096) + 16), 1);
}

uint64_t jpeg_create_decompress_encap(uint64_t a1, char *a2)
{
  uint64_t v3 = 0;
  if (!sigsetjmp((int *)(a1 + 16), 0))
  {
    _cg_jpeg_CreateDecompress(a2, 90, 664);
    return 1;
  }
  return v3;
}

uint64_t OJPEGLibjpegJpegSourceMgrFillInputBuffer(uint64_t a1)
{
  uint64_t v1 = 0;
  unsigned int v2 = 0;
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(void *)(v3 + 1096);
  while (2)
  {
    unsigned int v5 = *(_DWORD *)(v4 + 3712);
    if (v5 >= 0x13) {
      OJPEGLibjpegJpegSourceMgrFillInputBuffer_cold_1();
    }
    switch(v5)
    {
      case 0u:
        uint64_t v15 = *(void *)(v3 + 1096);
        uint64_t v1 = (_WORD *)(v15 + 3716);
        *(_WORD *)(v15 + 3716) = -9985;
        int v16 = *(_DWORD *)(v15 + 3712) + 1;
        goto LABEL_44;
      case 1u:
        uint64_t v6 = *(void *)(v3 + 1096);
        uint64_t v7 = *(_DWORD **)(v6 + 376);
        if (!v7) {
          goto LABEL_29;
        }
        goto LABEL_28;
      case 2u:
        uint64_t v6 = *(void *)(v3 + 1096);
        uint64_t v7 = *(_DWORD **)(v6 + 384);
        if (!v7) {
          goto LABEL_29;
        }
        goto LABEL_28;
      case 3u:
        uint64_t v6 = *(void *)(v3 + 1096);
        uint64_t v7 = *(_DWORD **)(v6 + 392);
        if (!v7) {
          goto LABEL_29;
        }
        goto LABEL_28;
      case 4u:
        uint64_t v6 = *(void *)(v3 + 1096);
        uint64_t v7 = *(_DWORD **)(v6 + 400);
        if (!v7) {
          goto LABEL_29;
        }
        goto LABEL_28;
      case 5u:
        uint64_t v6 = *(void *)(v3 + 1096);
        uint64_t v7 = *(_DWORD **)(v6 + 408);
        if (!v7) {
          goto LABEL_29;
        }
        goto LABEL_28;
      case 6u:
        uint64_t v6 = *(void *)(v3 + 1096);
        uint64_t v7 = *(_DWORD **)(v6 + 416);
        if (!v7) {
          goto LABEL_29;
        }
        goto LABEL_28;
      case 7u:
        uint64_t v6 = *(void *)(v3 + 1096);
        uint64_t v7 = *(_DWORD **)(v6 + 424);
        if (!v7) {
          goto LABEL_29;
        }
        goto LABEL_28;
      case 8u:
        uint64_t v6 = *(void *)(v3 + 1096);
        uint64_t v7 = *(_DWORD **)(v6 + 432);
        if (!v7) {
          goto LABEL_29;
        }
        goto LABEL_28;
      case 9u:
        uint64_t v6 = *(void *)(v3 + 1096);
        uint64_t v7 = *(_DWORD **)(v6 + 440);
        if (!v7) {
          goto LABEL_29;
        }
        goto LABEL_28;
      case 0xAu:
        uint64_t v6 = *(void *)(v3 + 1096);
        uint64_t v7 = *(_DWORD **)(v6 + 448);
        if (v7) {
          goto LABEL_28;
        }
        goto LABEL_29;
      case 0xBu:
        uint64_t v6 = *(void *)(v3 + 1096);
        uint64_t v7 = *(_DWORD **)(v6 + 456);
        if (!v7) {
          goto LABEL_29;
        }
        goto LABEL_28;
      case 0xCu:
        uint64_t v6 = *(void *)(v3 + 1096);
        uint64_t v7 = *(_DWORD **)(v6 + 464);
        if (!v7) {
          goto LABEL_29;
        }
LABEL_28:
        unsigned int v2 = *v7 - 4;
        uint64_t v1 = v7 + 1;
        LODWORD(v7) = v2;
        goto LABEL_29;
      case 0xDu:
        uint64_t v6 = *(void *)(v3 + 1096);
        LODWORD(v7) = *(unsigned __int16 *)(v6 + 472);
        if (*(_WORD *)(v6 + 472))
        {
          uint64_t v1 = (_WORD *)(v6 + 3716);
          *(_DWORD *)(v6 + 3716) = 67165695;
          *(unsigned char *)(v6 + 3720) = BYTE1(v7);
          *(unsigned char *)(v6 + 3721) = (_BYTE)v7;
          unsigned int v2 = 6;
          LODWORD(v7) = 6;
        }
LABEL_29:
        ++*(_DWORD *)(v6 + 3712);
        goto LABEL_30;
      case 0xEu:
        uint64_t v8 = *(void *)(v3 + 1096);
        uint64_t v9 = *(unsigned __int8 *)(v8 + 270);
        if (v9 >= 0x53) {
          OJPEGLibjpegJpegSourceMgrFillInputBuffer_cold_2();
        }
        uint64_t v1 = (_WORD *)(v8 + 3716);
        *(unsigned char *)(v8 + 3716) = -1;
        *(unsigned char *)(v8 + 3717) = *(unsigned char *)(v8 + 476);
        *(unsigned char *)(v8 + 3718) = 0;
        int v10 = 3 * v9;
        *(unsigned char *)(v8 + 3719) = 3 * v9 + 8;
        *(unsigned char *)(v8 + 3720) = 8;
        *(_WORD *)(v8 + 3721) = bswap32(*(unsigned __int16 *)(v8 + 484)) >> 16;
        int v11 = *(_DWORD *)(v8 + 480);
        *(unsigned char *)(v8 + 3723) = BYTE1(v11);
        *(unsigned char *)(v8 + 3724) = v11;
        *(unsigned char *)(v8 + 3725) = v9;
        if (v9)
        {
          unint64_t v12 = (char *)(*(unsigned __int8 *)(v8 + 269) + v8 + 494);
          BOOL v13 = (unsigned char *)(v8 + 3728);
          do
          {
            *(v13 - 2) = *(v12 - 6);
            *(v13 - 1) = *(v12 - 3);
            char v14 = *v12++;
            *BOOL v13 = v14;
            v13 += 3;
            --v9;
          }
          while (v9);
        }
        unsigned int v2 = v10 + 10;
        goto LABEL_62;
      case 0xFu:
        uint64_t v8 = *(void *)(v3 + 1096);
        uint64_t v19 = *(unsigned __int8 *)(v8 + 270);
        if (v19 >= 0x7D) {
          OJPEGLibjpegJpegSourceMgrFillInputBuffer_cold_3();
        }
        uint64_t v1 = (_WORD *)(v8 + 3716);
        *(_WORD *)(v8 + 3716) = -9473;
        *(unsigned char *)(v8 + 3718) = 0;
        int v20 = 2 * v19;
        *(unsigned char *)(v8 + 3719) = 2 * v19 + 6;
        *(unsigned char *)(v8 + 3720) = v19;
        if (v19)
        {
          uint16x8_t v21 = (char *)(*(unsigned __int8 *)(v8 + 269) + v8 + 500);
          uint16x8_t v22 = (unsigned char *)(v8 + 3722);
          uint64_t v23 = v19;
          do
          {
            *(v22 - 1) = *(v21 - 3);
            char v24 = *v21++;
            unsigned char *v22 = v24;
            v22 += 2;
            --v23;
          }
          while (v23);
          uint64_t v25 = 2 * v19;
        }
        else
        {
          uint64_t v25 = 0;
        }
        uint64_t v34 = v8 + v25;
        *(_WORD *)(v34 + 3721) = 16128;
        *(unsigned char *)(v34 + 3723) = 0;
        unsigned int v2 = v20 + 8;
LABEL_62:
        ++*(_DWORD *)(v8 + 3712);
        goto LABEL_63;
      case 0x10u:
        uint64_t v26 = *(void *)(v3 + 1096);
        unsigned int v2 = *(unsigned __int16 *)(v26 + 1648);
        if (!*(_WORD *)(v26 + 1648))
        {
          if (!OJPEGReadBufferFill(*(void *)(v3 + 1096)))
          {
            TIFFErrorExtR(v3, "LibJpeg", "Premature end of JPEG data", v27, v28, v29, v30, v31, v36);
            siglongjmp((int *)(*(void *)(v3 + 1096) + 16), 1);
          }
          unsigned int v2 = *(unsigned __int16 *)(v26 + 1648);
          if (!*(_WORD *)(v26 + 1648)) {
            OJPEGLibjpegJpegSourceMgrFillInputBuffer_cold_4();
          }
        }
        uint64_t v1 = *(_WORD **)(v26 + 1656);
        *(_WORD *)(v26 + 1648) = 0;
        if (*(void *)(v26 + 1640)) {
          goto LABEL_63;
        }
        int v32 = *(_DWORD *)(v26 + 1608);
        if (v32 == 3) {
          goto LABEL_65;
        }
        if (v32 == 2)
        {
          if (*(_DWORD *)(v26 + 1612) >= *(_DWORD *)(v26 + 1616)) {
LABEL_65:
          }
            int v33 = 18;
          else {
            int v33 = 17;
          }
          *(_DWORD *)(v26 + 3712) = v33;
        }
LABEL_63:
        *(void *)(v4 + 1464) = v2;
        *(void *)(v4 + 1456) = v1;
        return 1;
      case 0x11u:
        uint64_t v15 = *(void *)(v3 + 1096);
        uint64_t v1 = (_WORD *)(v15 + 3716);
        *(unsigned char *)(v15 + 3716) = -1;
        int v17 = *(unsigned __int8 *)(v15 + 474);
        *(unsigned char *)(v15 + 3717) = v17 - 48;
        if (v17 == 7) {
          char v18 = 0;
        }
        else {
          char v18 = v17 + 1;
        }
        *(unsigned char *)(v15 + 474) = v18;
        int v16 = 16;
LABEL_44:
        *(_DWORD *)(v15 + 3712) = v16;
        goto LABEL_46;
      case 0x12u:
        uint64_t v1 = (_WORD *)(*(void *)(v3 + 1096) + 3716);
        *uint64_t v1 = -9729;
LABEL_46:
        unsigned int v2 = 2;
        goto LABEL_63;
      default:
        LODWORD(v7) = 0;
LABEL_30:
        if (v7) {
          goto LABEL_63;
        }
        continue;
    }
  }
}

void OJPEGLibjpegJpegSourceMgrSkipInputData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 24);
  TIFFErrorExtR(v8, "LibJpeg", "Unexpected error", a4, a5, a6, a7, a8, v9);
  siglongjmp((int *)(*(void *)(v8 + 1096) + 16), 1);
}

void OJPEGLibjpegJpegSourceMgrResyncToRestart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 24);
  TIFFErrorExtR(v8, "LibJpeg", "Unexpected error", a4, a5, a6, a7, a8, v9);
  siglongjmp((int *)(*(void *)(v8 + 1096) + 16), 1);
}

uint64_t jpeg_read_header_encap(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  if (!sigsetjmp((int *)(a1 + 16), 0))
  {
    uint64_t v3 = 1;
    _cg_jpeg_read_header(a2, 1);
  }
  return v3;
}

uint64_t jpeg_start_decompress_encap(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  if (!sigsetjmp((int *)(a1 + 16), 0))
  {
    _cg_jpeg_start_decompress(a2);
    return 1;
  }
  return v3;
}

uint64_t jpeg_read_raw_data_encap(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v7 = 0;
  if (!sigsetjmp((int *)(a1 + 16), 0))
  {
    _cg_jpeg_read_raw_data(a2, a3, a4);
    return 1;
  }
  return v7;
}

uint64_t jpeg_read_scanlines_encap(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = 0;
  if (!sigsetjmp((int *)(a1 + 16), 0))
  {
    uint64_t v5 = 1;
    _cg_jpeg_read_scanlines(a2, a3, 1);
  }
  return v5;
}

uint64_t IIOImageWriteSession::getPosition(IIOImageWriteSession *this)
{
  return *((void *)this + 8);
}

size_t IIOImageWriteSession::getBytes(IIOImageWriteSession *this, void *__ptr, size_t a3)
{
  size_t v6 = *((void *)this + 7);
  uint64_t v5 = *((void *)this + 8);
  size_t v7 = v5 + a3;
  size_t v8 = v6 - v5;
  if (v7 <= v6) {
    size_t v9 = a3;
  }
  else {
    size_t v9 = v8;
  }
  int v10 = (FILE *)*((void *)this + 4);
  if (v10)
  {
    size_t v9 = fread(__ptr, 1uLL, v9, v10);
  }
  else
  {
    int v11 = (__CFData *)*((void *)this + 3);
    if (v11)
    {
      MutableBytePtr = CFDataGetMutableBytePtr(v11);
      memcpy(__ptr, &MutableBytePtr[*((void *)this + 8)], v9);
    }
    else if (*((void *)this + 2))
    {
      LogError("getBytes", 306, "*** ERROR: does not work for CGDataConsumers\n");
      return 0;
    }
  }
  *((void *)this + 8) += v9;
  return v9;
}

uint64_t _CGImageWriteSessionCopyDebugDesc(const void *a1)
{
  return 0;
}

uint64_t CGImageWriteSessionCreateWithConsumer(uint64_t a1)
{
  if (a1) {
    operator new();
  }
  return 0;
}

void sub_188724D5C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C408329B462);
  _Unwind_Resume(a1);
}

uint64_t _cg_TIFFWriteScanline(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = a3;
  int v12 = *(_DWORD *)(a1 + 16);
  if ((v12 & 0x40) == 0)
  {
    if (!TIFFWriteCheck(a1, 0, "TIFFWriteScanline", a4, a5, a6, a7, a8)) {
      return 0xFFFFFFFFLL;
    }
    int v12 = *(_DWORD *)(a1 + 16);
  }
  if ((v12 & 0x10) == 0 || !*(void *)(a1 + 1120))
  {
    if (!TIFFWriteBufferSetup(a1, 0, -1, a4, a5, a6, a7, a8)) {
      return 0xFFFFFFFFLL;
    }
    int v12 = *(_DWORD *)(a1 + 16);
  }
  *(_DWORD *)(a1 + 16) = v12 | 0x100000;
  unsigned int v13 = *(_DWORD *)(a1 + 92);
  int v14 = *(unsigned __int16 *)(a1 + 170);
  if (v13 <= v9)
  {
    if (v14 == 2)
    {
      uint64_t v15 = "Can not change \"ImageLength\" when using separate planes";
LABEL_39:
      TIFFErrorExtR(a1, "TIFFWriteScanline", v15, a4, a5, a6, a7, a8, v22);
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)(a1 + 92) = v9 + 1;
    goto LABEL_15;
  }
  if (v14 != 2)
  {
LABEL_15:
    unsigned int v16 = v9 / *(_DWORD *)(a1 + 132);
    goto LABEL_16;
  }
  if (*(unsigned __int16 *)(a1 + 130) <= a4)
  {
    TIFFErrorExtR(a1, "TIFFWriteScanline", "%lu: Sample out of range, max %lu", a4, a5, a6, a7, a8, a4);
    return 0xFFFFFFFFLL;
  }
  unsigned int v16 = v9 / *(_DWORD *)(a1 + 132) + *(_DWORD *)(a1 + 224) * a4;
LABEL_16:
  if (v16 >= *(_DWORD *)(a1 + 228) && !TIFFGrowStrips(a1, "TIFFWriteScanline", a3, a4, a5, a6, a7, a8)) {
    return 0xFFFFFFFFLL;
  }
  if (v16 == *(_DWORD *)(a1 + 884))
  {
LABEL_19:
    unsigned int v17 = *(_DWORD *)(a1 + 876);
    if (v17 != v9)
    {
      if (v17 > v9)
      {
        unsigned int v17 = *(_DWORD *)(a1 + 132) * (v16 % *(_DWORD *)(a1 + 224));
        *(_DWORD *)(a1 + 876) = v17;
        *(void *)(a1 + 1152) = *(void *)(a1 + 1120);
      }
      if (!(*(unsigned int (**)(uint64_t, void))(a1 + 1064))(a1, v9 - v17)) {
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)(a1 + 876) = v9;
    }
    (*(void (**)(uint64_t, uint64_t, void))(a1 + 1248))(a1, a2, *(void *)(a1 + 1104));
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t))(a1 + 1016))(a1, a2, *(void *)(a1 + 1104), a4);
    *(_DWORD *)(a1 + 876) = v9 + 1;
    return result;
  }
  if (TIFFFlushData(a1, a2, a3, a4, a5, a6, a7, a8))
  {
    *(_DWORD *)(a1 + 884) = v16;
    unsigned int v19 = *(_DWORD *)(a1 + 224);
    if (v13 <= v9 && v16 >= v19)
    {
      unsigned int v19 = 0;
      unsigned int v20 = *(_DWORD *)(a1 + 92);
      unsigned int v21 = *(_DWORD *)(a1 + 132);
      if (v20 < -v21) {
        unsigned int v19 = (v20 + v21 - 1) / v21;
      }
      *(_DWORD *)(a1 + 224) = v19;
    }
    if (!v19)
    {
      uint64_t v15 = "Zero strips per image";
      goto LABEL_39;
    }
    *(_DWORD *)(a1 + 876) = *(_DWORD *)(a1 + 132) * (v16 % v19);
    if ((*(unsigned char *)(a1 + 16) & 0x20) == 0)
    {
      if (!(*(unsigned int (**)(uint64_t))(a1 + 976))(a1)) {
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)(a1 + 16) |= 0x20u;
    }
    *(void *)(a1 + 1160) = 0;
    *(void *)(a1 + 1152) = *(void *)(a1 + 1120);
    *(void *)(a1 + 888) = 0;
    if ((*(unsigned int (**)(uint64_t, uint64_t))(a1 + 992))(a1, a4))
    {
      *(_DWORD *)(a1 + 16) |= 0x1000u;
      goto LABEL_19;
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t TIFFWriteCheck(uint64_t a1, int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)(a1 + 12))
  {
    int v12 = "File not open for writing";
    goto LABEL_9;
  }
  if (((*(_DWORD *)(a1 + 16) >> 10) & 1) != a2)
  {
    if (a2) {
      int v12 = "Can not write tiles to a striped image";
    }
    else {
      int v12 = "Can not write scanlines to a tiled image";
    }
    goto LABEL_9;
  }
  _TIFFFillStriles(a1);
  if ((*(unsigned char *)(a1 + 72) & 2) == 0)
  {
    int v12 = "Must set \"ImageWidth\" before writing data";
LABEL_9:
    TIFFErrorExtR(a1, a3, v12, a4, a5, a6, a7, a8, v16);
    return 0;
  }
  if (!*(void *)(a1 + 232) && !TIFFSetupStrips(a1, v10, v11, a4, a5, a6, a7, a8))
  {
    *(_DWORD *)(a1 + 228) = 0;
    if ((*(_DWORD *)(a1 + 16) & 0x400) != 0) {
      uint64_t v15 = "tile";
    }
    else {
      uint64_t v15 = "strip";
    }
    TIFFErrorExtR(a1, a3, "No space for %s arrays", a4, a5, a6, a7, a8, (char)v15);
    return 0;
  }
  if ((*(unsigned char *)(a1 + 17) & 4) != 0)
  {
    uint64_t result = _cg_TIFFTileSize(a1, v10, v11, a4, a5, a6, a7, a8);
    *(void *)(a1 + 936) = result;
    if (!result) {
      return result;
    }
  }
  else
  {
    *(void *)(a1 + 936) = -1;
  }
  uint64_t result = _cg_TIFFScanlineSize(a1, v10, v11, a4, a5, a6, a7, a8);
  *(void *)(a1 + 1104) = result;
  if (result)
  {
    int v14 = *(_DWORD *)(a1 + 16);
    *(_DWORD *)(a1 + 16) = v14 | 0x40;
    if (!*(_WORD *)(a1 + 256)
      || *(void *)(a1 + 264)
      || *(_WORD *)(a1 + 258)
      || *(void *)(a1 + 272)
      || !*(_WORD *)(a1 + 288)
      || *(void *)(a1 + 296)
      || *(_WORD *)(a1 + 290))
    {
      return 1;
    }
    uint64_t result = 1;
    if (!*(void *)(a1 + 304) && (v14 & 8) == 0)
    {
      TIFFForceStrileArrayWriting(a1);
      return 1;
    }
  }
  return result;
}

uint64_t TIFFWriteBufferSetup(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a3;
  uint64_t v11 = *(char **)(a1 + 1120);
  if (v11)
  {
    if ((*(unsigned char *)(a1 + 17) & 2) != 0)
    {
      _TIFFfreeExt(a1, v11);
      *(_DWORD *)(a1 + 16) &= ~0x200u;
    }
    *(void *)(a1 + 1120) = 0;
  }
  if (v8 == -1)
  {
    if ((*(unsigned char *)(a1 + 17) & 4) != 0) {
      uint64_t v13 = *(void *)(a1 + 936);
    }
    else {
      uint64_t v13 = _cg_TIFFStripSize(a1, (uint64_t)v11, a3, a4, a5, a6, a7, a8);
    }
    uint64_t v14 = v13 / 10;
    if (v13 >= ((v13 / 10) ^ 0x7FFFFFFFFFFFFFFFLL)) {
      uint64_t v14 = 0;
    }
    uint64_t v15 = v14 + v13;
    if (v15 <= 0x2000) {
      uint64_t v8 = 0x2000;
    }
    else {
      uint64_t v8 = v15;
    }
  }
  else if (a2)
  {
    unsigned int v12 = *(_DWORD *)(a1 + 16) & 0xFFFFFDFF;
LABEL_18:
    *(void *)(a1 + 1120) = a2;
    *(void *)(a1 + 1128) = v8;
    *(void *)(a1 + 1160) = 0;
    *(void *)(a1 + 1152) = a2;
    uint64_t result = 1;
    *(_DWORD *)(a1 + 16) = v12 | 0x10;
    return result;
  }
  char v16 = _TIFFmallocExt((void *)a1, v8, a3, a4, a5, a6, a7, a8);
  if (v16)
  {
    a2 = v16;
    unsigned int v12 = *(_DWORD *)(a1 + 16) | 0x200;
    goto LABEL_18;
  }
  TIFFErrorExtR(a1, "TIFFWriteBufferSetup", "No space for output buffer", v17, v18, v19, v20, v21, v23);
  return 0;
}

uint64_t TIFFGrowStrips(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a1 + 170) != 1) {
    TIFFGrowStrips_cold_1();
  }
  uint64_t v10 = (char *)_TIFFreallocExt((void *)a1, *(char **)(a1 + 232), 8 * (*(_DWORD *)(a1 + 228) + 1), a4, a5, a6, a7, a8);
  char v16 = (char *)_TIFFreallocExt((void *)a1, *(char **)(a1 + 240), 8 * (*(_DWORD *)(a1 + 228) + 1), v11, v12, v13, v14, v15);
  char v22 = v16;
  if (v10) {
    BOOL v23 = v16 == 0;
  }
  else {
    BOOL v23 = 1;
  }
  if (v23)
  {
    if (v10) {
      _TIFFfreeExt(a1, v10);
    }
    if (v22) {
      _TIFFfreeExt(a1, v22);
    }
    *(_DWORD *)(a1 + 228) = 0;
    TIFFErrorExtR(a1, a2, "No space to expand strip arrays", v17, v18, v19, v20, v21, v25);
    return 0;
  }
  else
  {
    *(void *)(a1 + 232) = v10;
    *(void *)(a1 + 240) = v16;
    _TIFFmemset(&v10[8 * *(unsigned int *)(a1 + 228)], 0, 8uLL);
    _TIFFmemset((void *)(*(void *)(a1 + 240) + 8 * *(unsigned int *)(a1 + 228)), 0, 8uLL);
    ++*(_DWORD *)(a1 + 228);
    *(_DWORD *)(a1 + 16) |= 8u;
    return 1;
  }
}

uint64_t _TIFFReserveLargeEnoughWriteBuffer(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 240) + 8 * a2);
  if (!v8) {
    return 1;
  }
  if (*(void *)(a1 + 1128) > v8 + 5) {
    return 1;
  }
  uint64_t result = TIFFWriteBufferSetup(a1, 0, (v8 + 1028) & 0xFFFFFFFFFFFFFC00, a4, a5, a6, a7, a8);
  if (result) {
    return 1;
  }
  return result;
}

uint64_t TIFFAppendToStrip(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v11 = *(void *)(a1 + 888);
  uint64_t v12 = a2;
  if (v11)
  {
    uint64_t v13 = *(void *)(a1 + 232);
    if (*(void *)(v13 + 8 * a2))
    {
      uint64_t v14 = -1;
      goto LABEL_15;
    }
    uint64_t v15 = 0;
    BOOL v16 = 1;
  }
  else
  {
    *(void *)(a1 + 896) = 0;
    uint64_t v15 = *(void *)(*(void *)(a1 + 232) + 8 * a2);
    BOOL v16 = v15 == 0;
  }
  if (!*(_DWORD *)(a1 + 228)) {
    TIFFAppendToStrip_cold_1();
  }
  unint64_t v17 = *(void *)(*(void *)(a1 + 240) + 8 * v12);
  if (v17 < a4) {
    BOOL v16 = 1;
  }
  if (!v17 || v16)
  {
    uint64_t v19 = (*(uint64_t (**)(void, void, uint64_t))(a1 + 1224))(*(void *)(a1 + 1200), 0, 2);
    uint64_t v13 = *(void *)(a1 + 232);
    uint64_t v18 = *(void *)(a1 + 240);
    *(void *)(v13 + 8 * v12) = v19;
    *(_DWORD *)(a1 + 16) |= 0x200000u;
  }
  else
  {
    if (!_TIFFSeekOK(a1, v15))
    {
      int v47 = *(_DWORD *)(a1 + 876);
      char v22 = "Seek error at scanline %lu";
      goto LABEL_45;
    }
    uint64_t v13 = *(void *)(a1 + 232);
    uint64_t v18 = *(void *)(a1 + 240);
    *(void *)(a1 + 896) = *(void *)(v18 + 8 * v12) + *(void *)(v13 + 8 * v12);
    uint64_t v19 = *(void *)(v13 + 8 * v12);
  }
  *(void *)(a1 + 888) = v19;
  uint64_t v14 = *(void *)(v18 + 8 * v12);
  *(void *)(v18 + 8 * v12) = 0;
  unint64_t v11 = *(void *)(a1 + 888);
LABEL_15:
  if ((*(unsigned char *)(a1 + 18) & 8) != 0) {
    unint64_t v20 = v11 + a4;
  }
  else {
    unint64_t v20 = (v11 + a4);
  }
  if (v20 < v11 || v20 < a4)
  {
LABEL_22:
    char v22 = "Maximum TIFF file size exceeded";
LABEL_45:
    TIFFErrorExtR(a1, "TIFFAppendToStrip", v22, a4, a5, a6, a7, a8, v47);
    return 0;
  }
  unint64_t v23 = *(void *)(a1 + 896);
  if (v23)
  {
    if (v20 > v23)
    {
      unint64_t v24 = *(void *)(*(void *)(a1 + 240) + 8 * v12);
      if (v24)
      {
        if (v24 >= 0x100000) {
          uint64_t v25 = 0x100000;
        }
        else {
          uint64_t v25 = *(void *)(*(void *)(a1 + 240) + 8 * v12);
        }
        uint64_t v48 = *(void *)(v13 + 8 * v12);
        uint64_t v26 = (*(uint64_t (**)(void, void, uint64_t))(a1 + 1224))(*(void *)(a1 + 1200), 0, 2);
        uint64_t v28 = v26;
        if ((*(unsigned char *)(a1 + 18) & 8) != 0 || !((v24 + a4 + v26) >> 32))
        {
          uint64_t v29 = (char *)_TIFFmallocExt((void *)a1, v25, v27, a4, a5, a6, a7, a8);
          if (v29)
          {
            uint64_t v30 = v29;
            uint64_t v31 = 0;
            *(_DWORD *)(a1 + 16) |= 0x200000u;
            uint64_t v32 = *(void *)(a1 + 240);
            *(void *)(*(void *)(a1 + 232) + 8 * v12) = v28;
            *(void *)(v32 + 8 * v12) = 0;
            while (1)
            {
              if (!_TIFFSeekOK(a1, v48 + v31))
              {
LABEL_48:
                int v46 = "Seek error";
                goto LABEL_51;
              }
              if ((*(uint64_t (**)(void, char *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), v30, v25) != v25)
              {
                int v46 = "Cannot read";
                goto LABEL_51;
              }
              if (!_TIFFSeekOK(a1, v28 + v31)) {
                goto LABEL_48;
              }
              if ((*(uint64_t (**)(void, char *, uint64_t))(a1 + 1216))(*(void *)(a1 + 1200), v30, v25) != v25) {
                break;
              }
              *(void *)(*(void *)(a1 + 240) + 8 * v12) += v25;
              v31 += v25;
              if (v24 == v31)
              {
                _TIFFfreeExt(a1, v30);
                unint64_t v20 = v28 + a4 + v31;
                goto LABEL_39;
              }
            }
            int v46 = "Cannot write";
LABEL_51:
            TIFFErrorExtR(a1, "TIFFAppendToStrip", v46, v33, v34, v35, v36, v37, v47);
            _TIFFfreeExt(a1, v30);
            return 0;
          }
          char v22 = "No space for output buffer";
          goto LABEL_45;
        }
        goto LABEL_22;
      }
    }
  }
LABEL_39:
  if ((*(uint64_t (**)(void, uint64_t, unint64_t))(a1 + 1216))(*(void *)(a1 + 1200), a3, a4) != a4)
  {
    TIFFErrorExtR(a1, "TIFFAppendToStrip", "Write error at scanline %lu", v38, v39, v40, v41, v42, *(_DWORD *)(a1 + 876));
    return 0;
  }
  *(void *)(a1 + 888) = v20;
  uint64_t v43 = *(void *)(a1 + 240);
  unint64_t v44 = *(void *)(v43 + 8 * v12) + a4;
  *(void *)(v43 + 8 * v12) = v44;
  if (v44 != v14) {
    *(_DWORD *)(a1 + 16) |= 0x200000u;
  }
  return 1;
}

uint64_t _cg_TIFFWriteTile(uint64_t a1, unsigned __int8 *a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a6;
  unsigned int v9 = a5;
  if (!TIFFCheckTile(a1, a3, a4, a5, a6, a6, a7, a8)) {
    return -1;
  }
  unsigned int v14 = _cg_TIFFComputeTile(a1, a3, a4, v9, v8);

  return _cg_TIFFWriteEncodedTile(a1, v14, a2, -1, v15, v16, v17, v18);
}

uint64_t _cg_TIFFWriteEncodedTile(uint64_t a1, unsigned int a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a1 + 16) & 0x40) == 0
    && !TIFFWriteCheck(a1, 1, "TIFFWriteEncodedTile", a4, a5, a6, a7, a8))
  {
    return -1;
  }
  if (*(_DWORD *)(a1 + 228) <= a2)
  {
    char v37 = a2;
    unint64_t v23 = "Tile %lu out of range, max %lu";
    goto LABEL_16;
  }
  int v12 = *(_DWORD *)(a1 + 16);
  if ((v12 & 0x10) == 0 || !*(void *)(a1 + 1120))
  {
    uint64_t v13 = -1;
    if (!TIFFWriteBufferSetup(a1, 0, -1, a4, a5, a6, a7, a8)) {
      return v13;
    }
    int v12 = *(_DWORD *)(a1 + 16);
  }
  *(_DWORD *)(a1 + 16) = v12 | 0x100000;
  *(_DWORD *)(a1 + 932) = a2;
  *(void *)(a1 + 888) = 0;
  if (!_TIFFReserveLargeEnoughWriteBuffer(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8)) {
    return -1;
  }
  *(void *)(a1 + 1160) = 0;
  *(void *)(a1 + 1152) = *(void *)(a1 + 1120);
  unsigned int v14 = *(_DWORD *)(a1 + 92);
  unsigned int v15 = *(_DWORD *)(a1 + 104);
  if (v14 >= -v15) {
    goto LABEL_14;
  }
  unsigned int v16 = v14 - 1;
  BOOL v17 = __CFADD__(v16, v15);
  unsigned int v18 = v16 + v15;
  if (v17
    || (*(_DWORD *)(a1 + 876) = a2 % (v18 / v15) * v15,
        unsigned int v19 = *(_DWORD *)(a1 + 88),
        unsigned int v20 = *(_DWORD *)(a1 + 100),
        v19 >= -v20)
    || (v21 = v19 - 1, BOOL v17 = __CFADD__(v21, v20), v22 = v21 + v20, v17))
  {
LABEL_14:
    unint64_t v23 = "Zero tiles";
LABEL_16:
    TIFFErrorExtR(a1, "TIFFWriteEncodedTile", v23, a4, a5, a6, a7, a8, v37);
    return -1;
  }
  *(_DWORD *)(a1 + 928) = a2 % (v22 / v20) * v20;
  int v25 = *(_DWORD *)(a1 + 16);
  if ((v25 & 0x20) == 0)
  {
    if (!(*(unsigned int (**)(uint64_t))(a1 + 976))(a1)) {
      return -1;
    }
    int v25 = *(_DWORD *)(a1 + 16) | 0x20;
  }
  *(_DWORD *)(a1 + 16) = v25 & 0xFFFFEFFF;
  if (*(void *)(a1 + 936) < a4 || a4 < 1) {
    uint64_t v13 = *(void *)(a1 + 936);
  }
  else {
    uint64_t v13 = a4;
  }
  if (*(_WORD *)(a1 + 120) != 1)
  {
    uint64_t v31 = (unsigned __int16)(a2 / *(_DWORD *)(a1 + 224));
    if ((*(unsigned int (**)(uint64_t, uint64_t))(a1 + 992))(a1, v31))
    {
      (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(a1 + 1248))(a1, a3, v13);
      if ((*(unsigned int (**)(uint64_t, unsigned __int8 *, uint64_t, uint64_t))(a1 + 1048))(a1, a3, v13, v31))
      {
        if ((*(unsigned int (**)(uint64_t))(a1 + 1000))(a1))
        {
          if ((*(_DWORD *)(a1 + 16) & (*(unsigned __int16 *)(a1 + 126) | 0x100)) == 0) {
            TIFFReverseBits(*(unsigned __int8 **)(a1 + 1120), *(void *)(a1 + 1160));
          }
          int64_t v36 = *(void *)(a1 + 1160);
          if (v36 < 1 || TIFFAppendToStrip(a1, a2, *(void *)(a1 + 1120), v36, v32, v33, v34, v35))
          {
            *(void *)(a1 + 1160) = 0;
            *(void *)(a1 + 1152) = *(void *)(a1 + 1120);
            return v13;
          }
        }
      }
    }
    return -1;
  }
  (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(a1 + 1248))(a1, a3, v13);
  if ((*(_DWORD *)(a1 + 16) & (*(unsigned __int16 *)(a1 + 126) | 0x100)) == 0) {
    TIFFReverseBits(a3, v13);
  }
  if (v13 >= 1 && !TIFFAppendToStrip(a1, a2, (uint64_t)a3, v13, v27, v28, v29, v30)) {
    return -1;
  }
  return v13;
}

uint64_t TIFFSetupStrips(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = *(_DWORD *)(a1 + 72);
  if ((*(unsigned char *)(a1 + 17) & 4) != 0)
  {
    if ((v9 & 4) == 0 || *(_DWORD *)(a1 + 92))
    {
      unsigned int v10 = _cg_TIFFNumberOfTiles(a1, a2, a3, a4, a5, a6, a7, a8);
      goto LABEL_9;
    }
  }
  else if ((v9 & 0x20000) == 0 || *(_DWORD *)(a1 + 92))
  {
    unsigned int v10 = _cg_TIFFNumberOfStrips(a1, a2, a3, a4, a5, a6, a7, a8);
    goto LABEL_9;
  }
  unsigned int v10 = *(unsigned __int16 *)(a1 + 130);
LABEL_9:
  *(_DWORD *)(a1 + 224) = v10;
  *(_DWORD *)(a1 + 228) = v10;
  if ((*(unsigned char *)(a1 + 18) & 8) != 0) {
    unsigned int v11 = 0x10000000;
  }
  else {
    unsigned int v11 = 0x20000000;
  }
  if (v10 >= v11)
  {
    TIFFErrorExtR(a1, "TIFFSetupStrips", "Too large Strip/Tile Offsets/ByteCounts arrays", a4, a5, a6, a7, a8, v18);
    return 0;
  }
  else
  {
    if (*(_WORD *)(a1 + 170) == 2) {
      *(_DWORD *)(a1 + 224) = v10 / *(unsigned __int16 *)(a1 + 130);
    }
    *(void *)(a1 + 232) = _TIFFCheckMalloc((const char **)a1, v10, 8, (uint64_t)"for \"StripOffsets\" array", a5, a6, a7, a8);
    unsigned int v16 = _TIFFCheckMalloc((const char **)a1, *(unsigned int *)(a1 + 228), 8, (uint64_t)"for \"StripByteCounts\" array", v12, v13, v14, v15);
    uint64_t result = 0;
    *(void *)(a1 + 240) = v16;
    if (*(void *)(a1 + 232))
    {
      if (v16)
      {
        _TIFFmemset(*(void **)(a1 + 232), 0, 8 * *(unsigned int *)(a1 + 228));
        _TIFFmemset(*(void **)(a1 + 240), 0, 8 * *(unsigned int *)(a1 + 228));
        *(_DWORD *)(a1 + 72) |= 0x3000000u;
        return 1;
      }
    }
  }
  return result;
}

uint64_t TIFFFlushData1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 1160);
  if (v8 < 1) {
    return 1;
  }
  int v10 = *(_DWORD *)(a1 + 16);
  if ((v10 & 0x100000) == 0) {
    return 1;
  }
  if (((unsigned __int16)v10 & (*(_WORD *)(a1 + 126) | 0x100)) == 0)
  {
    TIFFReverseBits(*(unsigned __int8 **)(a1 + 1120), v8);
    int v10 = *(_DWORD *)(a1 + 16);
    uint64_t v8 = *(void *)(a1 + 1160);
  }
  BOOL v12 = (v10 & 0x400) == 0;
  uint64_t v13 = 932;
  if (v12) {
    uint64_t v13 = 884;
  }
  uint64_t result = TIFFAppendToStrip(a1, *(_DWORD *)(a1 + v13), *(void *)(a1 + 1120), v8, a5, a6, a7, a8);
  *(void *)(a1 + 1160) = 0;
  *(void *)(a1 + 1152) = *(void *)(a1 + 1120);
  return result;
}

void IIO_Reader_PSD::createReadPlugin()
{
}

{
  operator new();
}

void sub_188725CD4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40B24B63D4);
  _Unwind_Resume(a1);
}

void sub_188725D74(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40B24B63D4);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PSD::initThumbnail(IIO_Reader *a1, uint64_t a2, int a3, int a4)
{
  memset(v10, 0, sizeof(v10));
  int v7 = IIO_Reader::osType(a1);
  PSDReadPlugin::PSDReadPlugin((uint64_t)v10, a2, a3, 0, v7);
  IIOReadPlugin::setDecodeMode((uint64_t)v10, 2);
  IIOReadPlugin::setDestMaxPixelSize((uint64_t)v10, a4);
  uint64_t inited = PSDReadPlugin::initThumbnail((PSDReadPlugin *)v10);
  PSDReadPlugin::~PSDReadPlugin((PSDReadPlugin *)v10);
  return inited;
}

void sub_188725E5C(void *a1)
{
}

void sub_188725E6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t IIO_Reader_PSD::deserializeGlobalInfo(IIO_Reader_PSD *this, unsigned __int8 *a2)
{
  return 0;
}

uint64_t IIO_Reader_PSD::hasCustomThumbnailProc(IIO_Reader_PSD *this)
{
  return 1;
}

uint64_t CreateMD5FromIIMBlock(void *a1, CC_LONG a2, unsigned __int8 *a3)
{
  memset(&v7, 0, sizeof(v7));
  CC_MD5_Init(&v7);
  CC_MD5_Update(&v7, a1, a2);
  return CC_MD5_Final(a3, &v7);
}

__CFString *CreateMD5StringFromIIMBlock(void *a1, CC_LONG a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  *(void *)uint64_t v5 = 0;
  uint64_t v6 = 0;
  CreateMD5FromIIMBlock(a1, a2, v5);
  Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 16);
  if (Mutable)
  {
    for (uint64_t i = 0; i != 16; ++i)
      CFStringAppendFormat(Mutable, 0, @"%02X", v5[i]);
  }
  return Mutable;
}

uint64_t SizeOfIPTCData(IIODictionary *a1)
{
  uint64_t context = 0;
  if (a1
    && (CFDictionaryRef v1 = (const __CFDictionary *)*((void *)a1 + 1)) != 0
    && (CFDictionaryApplyFunction(v1, (CFDictionaryApplierFunction)ApplierSizeOfIPTC, &context), context))
  {
    return context + 15;
  }
  else
  {
    return 0;
  }
}

void ApplierSizeOfIPTC(const __CFString *a1, const __CFString *cf, void *a3)
{
  if (a1 && cf && a3)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFStringGetTypeID())
    {
      for (uint64_t i = &byte_1E53C6770; CFStringCompare(a1, **((CFStringRef **)i - 2), 0); i += 24)
      {
        if (!*i) {
          return;
        }
      }
      SizeOfIPTCEntry(cf, a3);
    }
    else
    {
      CFTypeID v9 = CFGetTypeID(cf);
      if (v9 == CFArrayGetTypeID())
      {
        for (j = &byte_1E53C6768; CFStringCompare(a1, **((CFStringRef **)j - 1), 0); j += 24)
        {
          if (!j[8]) {
            return;
          }
        }
        if (*j)
        {
          v16.unsigned int length = CFArrayGetCount((CFArrayRef)cf);
          v16.location = 0;
          CFArrayApplyFunction((CFArrayRef)cf, v16, (CFArrayApplierFunction)SizeOfIPTCEntry, a3);
        }
      }
      else
      {
        CFTypeID v12 = CFGetTypeID(cf);
        CFStringRef v13 = CFCopyTypeIDDescription(v12);
        memset(v18, 0, sizeof(v18));
        IIOString::IIOString((IIOString *)v18, a1);
        memset(v17, 0, sizeof(v17));
        IIOString::IIOString((IIOString *)v17, v13);
        uint64_t v14 = (const char *)IIOString::utf8String((IIOString *)v18);
        uint64_t v15 = (const char *)IIOString::utf8String((IIOString *)v17);
        _cg_jpeg_mem_term("ApplierSizeOfIPTC", 188, "*** ApplierSizeOfIPTC - skipping '%s' -- '%s'\n", v14, v15);
        CFRelease(v13);
        IIOString::~IIOString((IIOString *)v17);
        IIOString::~IIOString((IIOString *)v18);
      }
    }
  }
}

void sub_1887261E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void WriteIPTCData(CFDictionaryRef *a1, unsigned __int8 *a2)
{
  if (a1)
  {
    if (a2)
    {
      *(void *)a2 = 0x47251B03005A011CLL;
      *((_DWORD *)a2 + 2) = 540;
      *((_WORD *)a2 + 6) = 2;
      a2[14] = 2;
      v2[0] = 0;
      v2[1] = a2 + 15;
      CFDictionaryApplyFunction(a1[1], (CFDictionaryApplierFunction)ApplierWriteIPTC, v2);
    }
  }
}

__n128 ApplierWriteIPTC(const __CFString *a1, const __CFString *cf, char *a3)
{
  if (!a1 || !cf) {
    return result;
  }
  CFTypeID v6 = CFGetTypeID(cf);
  if (CFStringGetTypeID() != v6)
  {
    if (CFArrayGetTypeID() == v6)
    {
      for (uint64_t i = &byte_1E53C6768; CFStringCompare(a1, **((CFStringRef **)i - 1), 0); i += 24)
      {
        if (!i[8]) {
          return result;
        }
      }
    }
    else
    {
      if (CFDictionaryGetTypeID() != v6)
      {
        if (v6 != CFNumberGetTypeID())
        {
          return _cg_jpeg_mem_term("ApplierWriteIPTC", 289, "*** ApplierWriteIPTC - does not handle non-strings / non-arrays\n");
        }
        return result;
      }
      for (uint64_t i = &byte_1E53C6768; CFStringCompare(a1, **((CFStringRef **)i - 1), 0); i += 24)
      {
        if (!i[8]) {
          return result;
        }
      }
    }
    if (*i)
    {
      *a3 = *(i - 16);
      v13.unsigned int length = CFArrayGetCount((CFArrayRef)cf);
      v13.location = 0;
      CFArrayApplyFunction((CFArrayRef)cf, v13, (CFArrayApplierFunction)WriteIPTCEntry, a3);
    }
    return result;
  }
  for (j = &iptcInfo; CFStringCompare(a1, **((CFStringRef **)j + 1), 0); j += 24)
  {
    if (!j[24]) {
      return result;
    }
  }
  *a3 = *j;

  WriteIPTCEntry(cf, (unsigned char **)a3);
  return result;
}

void ReadIPTCProps(IIODictionary *a1, unsigned char *a2, unint64_t a3)
{
  unint64_t v3 = a3;
  uint64_t v4 = a2;
  if (a3 >= 6)
  {
    CFStringEncoding encoding = 0;
    size_t v5 = 0;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    unint64_t v7 = 5;
    do
    {
      if (v4[v5] != 28) {
        break;
      }
      uint64_t v8 = &v4[v5];
      int v9 = v4[v5 + 1];
      if ((v9 - 1) > 1) {
        break;
      }
      int v10 = v8[2];
      unint64_t v11 = __rev16(*(unsigned __int16 *)(v8 + 3));
      size_t v12 = v11 + v7 <= v3 ? v11 : v3 - v7;
      if (v9 == 1 && v10 == 90 && v12 == 3)
      {
        if (v4[v7] != 27) {
          goto LABEL_42;
        }
        int v13 = v4[v5 + 6];
        if (v13 == 47)
        {
          BOOL v14 = v4[v5 + 7] == 65;
          CFStringEncoding v15 = encoding;
          int v16 = 513;
        }
        else
        {
          if (v13 != 37) {
            goto LABEL_42;
          }
          BOOL v14 = v4[v5 + 7] == 71;
          CFStringEncoding v15 = encoding;
          int v16 = 134217984;
        }
        if (v14) {
          CFStringEncoding v15 = v16;
        }
        CFStringEncoding encoding = v15;
      }
      else
      {
        if (v9 == 1) {
          goto LABEL_42;
        }
        if (v10 != 25
          || v12 != 6
          || v5 + 12 > 6
          || (unsigned int v17 = v4[v7], v17 < 0x35)
          || ((char v18 = &v4[v5], v19 = *(_DWORD *)(v18 + 6), v20 = *((unsigned __int16 *)v18 + 5), v19 == 1635013408)
            ? (BOOL v21 = v20 == 114)
            : (BOOL v21 = 0),
              !v21))
        {
          unsigned int v22 = &v4[v7];
          int v23 = 3;
          unint64_t v24 = &byte_1E53C6770;
          while (1)
          {
            if (v23 == v10)
            {
              size_t v25 = strnlen(v22, v12);
              if (v12 >= v25) {
                CFIndex v26 = v25;
              }
              else {
                CFIndex v26 = v12;
              }
              CFStringRef v27 = CFStringCreateWithBytes(v6, (const UInt8 *)v22, v26, encoding, 1u);
              if (!v27)
              {
LABEL_37:
                uint64_t v4 = a2;
                unint64_t v3 = a3;
                goto LABEL_42;
              }
              CFStringRef v28 = v27;
              uint64_t v29 = (const __CFString **)*((void *)v24 - 2);
              if (*(v24 - 8))
              {
                CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(a1, *v29, @"{IPTC}");
                if (!ObjectForKeyGroup)
                {
                  CFDictionaryRef ObjectForKeyGroup = CFArrayCreateMutable(v6, 0, MEMORY[0x1E4F1D510]);
                  IIODictionary::setObjectForKeyGroup(a1, ObjectForKeyGroup, *v29, @"{IPTC}");
                  CFRelease(ObjectForKeyGroup);
                }
                memset(v38, 0, sizeof(v38));
                IIOArray::IIOArray((IIOArray *)v38, ObjectForKeyGroup);
                IIOArray::addObject(v38, v28);
                IIOArray::~IIOArray((IIOArray *)v38);
              }
              else
              {
                IIODictionary::setObjectForKeyGroup(a1, v27, *v29, @"{IPTC}");
              }
              CFRelease(v28);
            }
            int v31 = *v24;
            v24 += 24;
            int v23 = v31;
            if (!v31) {
              goto LABEL_37;
            }
          }
        }
        IIONumber::IIONumber((IIONumber *)v39, v17 - 48);
        IIODictionary::setObjectForKeyGroup(a1, (uint64_t)v39, @"StarRating", @"{IPTC}");
        IIONumber::~IIONumber((IIONumber *)v39);
      }
LABEL_42:
      size_t v5 = v12 + v7;
      v7 += v12 + 5;
    }
    while (v7 < v3);
  }
  MD5StringFromIIMBlock = CreateMD5StringFromIIMBlock(v4, v3);
  if (MD5StringFromIIMBlock)
  {
    uint64_t v33 = MD5StringFromIIMBlock;
    IIODictionary::setObjectForKeyGroup(a1, MD5StringFromIIMBlock, @"iptcComputedMD5", @"{IPTC}");
    CFRelease(v33);
  }
}

void sub_188726738(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

CGImageMetadata *CreateMetadataFromIPTCDatabuffer(unsigned char *a1, unint64_t a2)
{
  memset(v7, 0, sizeof(v7));
  IIODictionary::IIODictionary((IIODictionary *)v7);
  ReadIPTCProps((IIODictionary *)v7, a1, a2);
  uint64_t v4 = (CGImageMetadata *)CGImageMetadataCreateFromLegacyProps((IIODictionary *)v7);
  size_t v5 = v4;
  if (v4) {
    CGImageMetadataSetValueWithPath(v4, 0, @"iio:hasIIM", (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v7);
  return v5;
}

void sub_1887267E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImagePluginReadRawIPTCProps(__CFDictionary *a1, unsigned char *a2, unint64_t a3)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImagePluginReadRawIPTCProps", 0, 0, -1, 0);
  }
  memset(v6, 0, sizeof(v6));
  IIODictionary::IIODictionary((IIODictionary *)v6, a1);
  ReadIPTCProps((IIODictionary *)v6, a2, a3);
  IIODictionary::~IIODictionary((IIODictionary *)v6);
}

void sub_1887268A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

__CFArray *CreateIIMHashArrayForIIMBlock(void *a1, CC_LONG a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    memset(&v10, 0, sizeof(v10));
    *(void *)md = 0;
    uint64_t v12 = 0;
    CC_MD5_Init(&v10);
    CC_MD5_Update(&v10, a1, a2);
    CC_MD5_Final(md, &v10);
    for (uint64_t i = 0; i != 16; ++i)
    {
      CFNumberRef v7 = CFNumberCreate(v4, kCFNumberCharType, &md[i]);
      if (v7)
      {
        CFNumberRef v8 = v7;
        CFArrayAppendValue(Mutable, v7);
        CFRelease(v8);
      }
    }
  }
  return Mutable;
}

char *CreateIPTCDataFromProperties(char a1, IIODictionary *a2, unint64_t *a3)
{
  if (a2)
  {
    uint64_t v6 = SizeOfIPTCData(a2);
    if (v6) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  if (a1) {
    return 0;
  }
LABEL_7:
  uint64_t v8 = v6 & 1;
  uint64_t v9 = v6 + v8;
  CC_MD5_CTX v10 = (unsigned __int8 *)malloc_type_calloc(v6 + v8 + 54, 1uLL, 0xE8B19911uLL);
  CFNumberRef v7 = v10;
  if (v10)
  {
    *((_DWORD *)v10 + 4) = 67390793;
    *(_OWORD *)CC_MD5_CTX v10 = *(_OWORD *)"Photoshop 3.0";
    *((_WORD *)v10 + 12) = bswap32(v6) >> 16;
    WriteIPTCData((CFDictionaryRef *)a2, v10 + 26);
    IIMHashArrayForIIMBlock = CreateIIMHashArrayForIIMBlock(v7 + 26, v6);
    if (!IIMHashArrayForIIMBlock)
    {
      char v18 = (char *)&v7[v6 + v8];
      *(void *)(v18 + 46) = 0;
      *(void *)(v18 + 38) = 0;
      if (!a3) {
        return (char *)v7;
      }
      goto LABEL_15;
    }
    CFArrayRef v12 = IIMHashArrayForIIMBlock;
    CFIndex v13 = 0;
    BOOL v14 = (char *)&v7[v9 + 26];
    *(void *)BOOL v14 = 0x25044D494238;
    *((_DWORD *)v14 + 2) = 0x10000000;
    uint64_t v15 = (uint64_t)&v7[v6 + 38 + v8];
    do
    {
      char valuePtr = 0;
      CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v12, v13);
      if (CFNumberGetValue(ValueAtIndex, kCFNumberCharType, &valuePtr)) {
        *(unsigned char *)(v15 + v13) = valuePtr;
      }
      ++v13;
    }
    while (v13 != 16);
    CFRelease(v12);
  }
  if (a3) {
LABEL_15:
  }
    *a3 = v9 + 54;
  return (char *)v7;
}

uint64_t SizeOfIPTCEntry(const __CFString *a1, void *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  uint64_t result = CFStringGetTypeID();
  if (v4 == result)
  {
    v7.unsigned int length = CFStringGetLength(a1);
    CFIndex usedBufLen = 0;
    v7.location = 0;
    uint64_t result = CFStringGetBytes(a1, v7, 0x8000100u, 0x3Fu, 0, 0, 0, &usedBufLen);
    if (usedBufLen) {
      *a2 += usedBufLen + 5;
    }
  }
  return result;
}

uint64_t WriteIPTCEntry(const __CFString *a1, unsigned char **a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  uint64_t result = CFStringGetTypeID();
  if (v4 == result)
  {
    CFIndex Length = CFStringGetLength(a1);
    CFIndex usedBufLen = 0;
    v8.location = 0;
    v8.unsigned int length = Length;
    uint64_t result = CFStringGetBytes(a1, v8, 0x8000100u, 0x3Fu, 0, 0, 0, &usedBufLen);
    if (usedBufLen)
    {
      *a2[1] = 28;
      a2[1][1] = 2;
      a2[1][2] = *(unsigned char *)a2;
      a2[1][3] = BYTE1(usedBufLen);
      a2[1][4] = usedBufLen;
      v9.location = 0;
      v9.unsigned int length = Length;
      uint64_t result = CFStringGetBytes(a1, v9, 0x8000100u, 0x3Fu, 0, a2[1] + 5, 0xFFFFLL, 0);
      a2[1] += usedBufLen + 5;
    }
  }
  return result;
}

uint64_t RGBE_ReadHeader(FILE *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    *(_DWORD *)a4 = 0;
    *(unsigned char *)(a4 + 4) = 0;
    __asm { FMOV            V0.2S, #1.0 }
    *(void *)(a4 + 20) = _D0;
  }
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  *(_OWORD *)size_t v25 = 0u;
  long long v26 = 0u;
  int v24 = 0;
  if (!fgets(v25, 128, a1)) {
    goto LABEL_51;
  }
  if (!a4 || v25[0] != 35 || v25[1] != 63) {
    goto LABEL_15;
  }
  uint64_t v12 = 0;
  *(_DWORD *)a4 |= 1u;
  uint64_t v13 = MEMORY[0x1E4F14390];
  do
  {
    unsigned int v14 = v25[v12 + 2];
    if (!v25[v12 + 2]) {
      break;
    }
    if ((v14 & 0x80000000) != 0)
    {
      if (__maskrune(v25[v12 + 2], 0x4000uLL)) {
        break;
      }
    }
    else if ((*(_DWORD *)(v13 + 4 * v14 + 60) & 0x4000) != 0)
    {
      break;
    }
    *(unsigned char *)(a4 + 4 + v12++) = v14;
  }
  while (v12 != 15);
  *(unsigned char *)(a4 + v12 + 4) = 0;
  if (!fgets(v25, 128, a1)) {
    goto LABEL_51;
  }
  while (1)
  {
LABEL_15:
    if (v25[0] == 10 || v25[0] == 0)
    {
      int v20 = (FILE *)*MEMORY[0x1E4F143C8];
      BOOL v21 = "no FORMAT specifier found";
LABEL_39:
      fprintf(v20, "RGBE bad file format: %s\n", v21);
      return 0xFFFFFFFFLL;
    }
    if (*(void *)v25 == 0x333D54414D524F46
      && *(void *)&v25[8] == 0x6C725F7469622D32
      && (void)v26 == 0xA656267725F65)
    {
      int v22 = 8;
      goto LABEL_42;
    }
    if (*(void *)v25 == 0x663D54414D524F46 && *(void *)&v25[6] == 0xA74616F6C663DLL) {
      break;
    }
    if (a4)
    {
      if (sscanf(v25, "GAMMA=%g", &v24) == 1)
      {
        *(_DWORD *)(a4 + 20) = v24;
        int v19 = 2;
LABEL_35:
        *(_DWORD *)a4 |= v19;
        goto LABEL_36;
      }
      if (sscanf(v25, "EXPOSURE=%g", &v24) == 1)
      {
        *(_DWORD *)(a4 + 24) = v24;
        int v19 = 4;
        goto LABEL_35;
      }
    }
LABEL_36:
    if (!fgets(v25, 128, a1)) {
      goto LABEL_51;
    }
  }
  int v22 = 16;
LABEL_42:
  *(_DWORD *)a4 |= v22;
  while (fgets(v25, 128, a1))
  {
    if (v25[0] == 10)
    {
      if (!fgets(v25, 128, a1)) {
        break;
      }
      if (sscanf(v25, "-Y %d +X %d", a3, a2) <= 1
        && sscanf(v25, "+X %d +Y %d", a2, a3) <= 1
        && sscanf(v25, "+Y %d +X %d", a3, a2) <= 1)
      {
        int v20 = (FILE *)*MEMORY[0x1E4F143C8];
        BOOL v21 = "missing image size specifier";
        goto LABEL_39;
      }
      return 0;
    }
  }
LABEL_51:
  perror("RGBE read error");
  return 0xFFFFFFFFLL;
}

uint64_t RGBE_ReadPixels(FILE *__stream, uint64_t a2, int a3)
{
  if (a3 < 1) {
    return 0;
  }
  uint64_t v10 = v3;
  uint64_t v11 = v4;
  int __ptr = 0;
  int v7 = a3 + 1;
  while (fread(&__ptr, 4uLL, 1uLL, __stream))
  {
    rgbe2float((float *)a2, (float *)(a2 + 4), (float *)(a2 + 8), &__ptr);
    *(_DWORD *)(a2 + 12) = 1065353216;
    --v7;
    a2 += 16;
    if (v7 <= 1) {
      return 0;
    }
  }
  perror("RGBE read error");
  return 0xFFFFFFFFLL;
}

void rgbe2float(float *a1, float *a2, float *a3, unsigned char *a4)
{
  if (a4[3])
  {
    float v8 = ldexp(1.0, a4[3] - 136);
    LOBYTE(v9) = *a4;
    *(float *)&unsigned int v10 = v8 * (float)v9;
    *a1 = *(float *)&v10;
    LOBYTE(v10) = a4[1];
    *(float *)&unsigned int v11 = v8 * (float)v10;
    *a2 = *(float *)&v11;
    LOBYTE(v11) = a4[2];
    *a3 = v8 * (float)v11;
  }
  else
  {
    *a3 = 0.0;
    *a2 = 0.0;
    *a1 = 0.0;
  }
}

uint64_t RGBE_ReadPixels_RLE(FILE *__stream, uint64_t a2, unsigned int a3, int a4)
{
  int v4 = a4;
  if (a3 - 0x8000 < 0xFFFF8008)
  {
    int v8 = a4 * a3;
    goto LABEL_3;
  }
  if (a4 < 1)
  {
    unsigned int v10 = 0;
LABEL_41:
    free(v10);
    return 0;
  }
  unsigned int v10 = 0;
  int __ptr = 0;
  __int16 v26 = 0;
  size_t v11 = 4 * a3;
  uint64_t v12 = 2 * a3;
  uint64_t v25 = 3 * a3;
  while (1)
  {
    if (!fread(&__ptr, 4uLL, 1uLL, __stream))
    {
LABEL_42:
      free(v10);
      perror("RGBE read error");
      return 0xFFFFFFFFLL;
    }
    BOOL v13 = __ptr == 2 && BYTE1(__ptr) == 2;
    if (!v13 || SBYTE2(__ptr) < 0) {
      break;
    }
    if ((HIBYTE(__ptr) | (BYTE2(__ptr) << 8)) != a3)
    {
LABEL_38:
      free(v10);
      fprintf((FILE *)*MEMORY[0x1E4F143C8], "RGBE bad file format: %s\n");
      return 0xFFFFFFFFLL;
    }
    if (!v10)
    {
      unsigned int v10 = (char *)malloc_type_malloc(v11, 0x5C5D87ABuLL);
      if (!v10)
      {
        fprintf((FILE *)*MEMORY[0x1E4F143C8], "RGBE error: %s\n");
        return 0xFFFFFFFFLL;
      }
    }
    uint64_t v23 = v12;
    size_t v24 = v11;
    uint64_t v14 = 0;
    uint64_t v15 = v10;
    do
    {
      int v16 = &v10[++v14 * a3];
      while (v15 < v16)
      {
        if (!fread(&v26, 2uLL, 1uLL, __stream)) {
          goto LABEL_42;
        }
        unsigned int v17 = v26;
        uint64_t v18 = v16 - v15;
        if (v26 < 0x81u)
        {
          if (!(_BYTE)v26 || v18 < v26) {
            goto LABEL_38;
          }
          *v15++ = HIBYTE(v26);
          if (v17 >= 2)
          {
            size_t v20 = v17 - 1;
            if (!fread(v15, v20, 1uLL, __stream)) {
              goto LABEL_42;
            }
            v15 += v20;
          }
        }
        else
        {
          if (v18 < v26 - 128) {
            goto LABEL_38;
          }
          int v19 = v26 - 127;
          do
          {
            *v15++ = HIBYTE(v26);
            --v19;
          }
          while (v19 > 1);
        }
      }
    }
    while (v14 != 4);
    uint64_t v21 = 0;
    uint64_t v12 = v23;
    do
    {
      LOBYTE(__ptr) = v10[v21];
      BYTE1(__ptr) = v10[a3 + v21];
      BYTE2(__ptr) = v10[(v23 + v21)];
      HIBYTE(__ptr) = v10[v25 + v21];
      rgbe2float((float *)a2, (float *)(a2 + 4), (float *)(a2 + 8), &__ptr);
      *(_DWORD *)(a2 + 12) = 1065353216;
      a2 += 16;
      ++v21;
    }
    while (a3 != v21);
    BOOL v22 = __OFSUB__(v4--, 1);
    size_t v11 = v24;
    if ((v4 < 0) ^ v22 | (v4 == 0)) {
      goto LABEL_41;
    }
  }
  rgbe2float((float *)a2, (float *)(a2 + 4), (float *)(a2 + 8), &__ptr);
  *(_DWORD *)(a2 + 12) = 1065353216;
  a2 += 16;
  free(v10);
  int v8 = v4 * a3 - 1;
LABEL_3:

  return RGBE_ReadPixels(__stream, a2, v8);
}

size_t ImageIOSIMD_GetVectorLevelName(unint64_t a1, char *__str, size_t __size)
{
  if (!__size) {
    return -1;
  }
  if (!a1) {
    return snprintf(__str, __size, "<scalar only>");
  }
  if (a1 > 0x20) {
    return snprintf(__str, __size, "<invalid value>");
  }
  uint64_t v8 = 0;
  size_t v7 = 0;
  while (1)
  {
    if (1 << v8 > a1)
    {
LABEL_22:
      size_t v13 = __size - 1;
      if (v7 < __size - 1) {
        size_t v13 = v7;
      }
      __str[v13] = 0;
      return v7;
    }
    if (((1 << v8) & a1) != 0) {
      break;
    }
    ++v8;
LABEL_21:
    if (v8 == 6) {
      goto LABEL_22;
    }
  }
  if (!v7)
  {
LABEL_16:
    unsigned int v11 = snprintf(&__str[v7], __size - v7, "%s", ImageIOSIMD_GetVectorLevelName::kVectorLevelNames[++v8]);
    if ((v11 & 0x80000000) != 0) {
      goto LABEL_22;
    }
    size_t v12 = v11;
    if (v11 >= __size - v7) {
      size_t v12 = __size - v7;
    }
    v7 += v12;
    goto LABEL_21;
  }
  unsigned int v9 = snprintf(&__str[v7], __size - v7, " | ");
  if ((v9 & 0x80000000) == 0)
  {
    size_t v10 = v9;
    if (v9 >= __size - v7) {
      size_t v10 = __size - v7;
    }
    v7 += v10;
    goto LABEL_16;
  }
  size_t v15 = __size - 1;
  if (v7 < __size - 1) {
    size_t v15 = v7;
  }
  __str[v15] = 0;
  return (int)v7;
}

uint64_t ImageIOSIMD_GetVectorLevel()
{
  if (ImageIOSIMD_GetVectorLevel::vectorPredicate != -1) {
    dispatch_once(&ImageIOSIMD_GetVectorLevel::vectorPredicate, &__block_literal_global_9);
  }
  return vectorLevel;
}

uint64_t ImageIOSIMD_GetHardwareVectorLevel()
{
  if (ImageIOSIMD_GetHardwareVectorLevel::hardwarePredicate != -1) {
    dispatch_once(&ImageIOSIMD_GetHardwareVectorLevel::hardwarePredicate, &__block_literal_global_13);
  }
  return ImageIOSIMD_GetHardwareVectorLevel::hardwareLevel;
}

void ImageIOSIMD_SetVectorLevel(uint64_t a1)
{
  if (ImageIOSIMD_GetVectorLevel::vectorPredicate != -1) {
    dispatch_once(&ImageIOSIMD_GetVectorLevel::vectorPredicate, &__block_literal_global_9);
  }
  if (vectorLevel != a1)
  {
    if (ImageIOSIMD_GetHardwareVectorLevel::hardwarePredicate != -1) {
      dispatch_once(&ImageIOSIMD_GetHardwareVectorLevel::hardwarePredicate, &__block_literal_global_13);
    }
    vectorLevel = ImageIOSIMD_GetHardwareVectorLevel::hardwareLevel & a1;
  }
}

uint64_t WebPReadPlugin::WebPReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(void *)uint64_t result = &unk_1ED4E2E80;
  *(_WORD *)(result + 436) = 0;
  return result;
}

void WebPReadPlugin::WebPReadPlugin(uint64_t a1, uint64_t a2)
{
}

void WebPReadPlugin::~WebPReadPlugin(WebPReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t WebPReadPlugin::loadDataFromXPCObject(WebPReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_webp", &length);
    if (length == 2)
    {
      uint64_t v6 = data;
      uint64_t result = 0;
      *((_WORD *)this + 218) = *v6;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t WebPReadPlugin::saveDataToXPCObject(WebPReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_webp", (char *)this + 436, 2uLL);
  }
  return v4;
}

uint64_t WebPReadPlugin::handleChunks(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = 0;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v44 = 0u;
  int v4 = IIOSkipMetadata(*(IIODictionary **)(a1 + 48));
  int v5 = IIOSkipXMP_and_IPTC(*(IIODictionary **)(a1 + 48));
  uint64_t v6 = WebPDemuxInternal(a2, 0, 0, 263);
  if (!v6) {
    return 0;
  }
  size_t v7 = v6;
  if (WebPDemuxGetChunk((uint64_t)v6, "ICCP", 1, (uint64_t)&v44))
  {
    _cg_jpeg_mem_term("handleChunks", 98, "ICCP: %p [%ld]\n", *((const void **)&v44 + 1), (void)v45);
    *(void *)(a1 + 160) = CGColorSpaceCreateWithCopyOfData(*((UInt8 **)&v44 + 1), v45);
    _cg_jpeg_mem_term(&v44, v8, v9);
  }
  uint64_t Chunk = WebPDemuxGetChunk((uint64_t)v7, "EXIF", 1, (uint64_t)&v44);
  if (Chunk)
  {
    _cg_jpeg_mem_term("handleChunks", 107, "EXIF: %p [%ld]\n", *((const void **)&v44 + 1), (void)v45);
    MetadataFromDatabuffer = (void *)CreateMetadataFromDatabuffer(*((const char **)&v44 + 1), v45);
    if (MetadataFromDatabuffer)
    {
      uint64_t v14 = MetadataFromDatabuffer;
      if (v4)
      {
        TagWithPath = CGImageMetadataGetTagWithPath(MetadataFromDatabuffer, 0, @"tiff:Orientation");
        if (TagWithPath) {
          CGImageMetadataAddTag(*(void *)(a1 + 64), TagWithPath);
        }
      }
      else
      {
        CGImageMetadataMerge(*(void *)(a1 + 64), (uint64_t)MetadataFromDatabuffer, *(IIODictionary **)(a1 + 48));
      }
      CFRelease(v14);
    }
    _cg_jpeg_mem_term(&v44, v12, v13);
  }
  if (((v4 | v5) & 1) == 0)
  {
    uint64_t Chunk = WebPDemuxGetChunk((uint64_t)v7, "XMP ", 1, (uint64_t)&v44);
    if (Chunk)
    {
      uint64_t MetadataFromXMPBuffer = CreateMetadataFromXMPBuffer(*((const char **)&v44 + 1), v45);
      if (MetadataFromXMPBuffer)
      {
        int v19 = (const void *)MetadataFromXMPBuffer;
        CGImageMetadataMerge(*(void *)(a1 + 64), MetadataFromXMPBuffer, *(IIODictionary **)(a1 + 48));
        CFRelease(v19);
      }
      _cg_jpeg_mem_term(&v44, v17, v18);
    }
  }
  if (*(unsigned char *)(a1 + 436))
  {
    *(_OWORD *)uint64_t v42 = 0u;
    long long v43 = 0u;
    *(_OWORD *)uint64_t v40 = 0u;
    long long v41 = 0u;
    *(_OWORD *)uint64_t v39 = 0u;
    WebPDemuxGetFrame((uint64_t)v7, *(_DWORD *)(a1 + 208) + 1, (uint64_t)v39);
    int v20 = v40[2];
    if (v40[2] >= 11) {
      int v21 = v40[2];
    }
    else {
      int v21 = 100;
    }
    BOOL v22 = *(IIODictionary **)(a1 + 56);
    IIONumber::IIONumber((IIONumber *)v38, (double)v21 / 1000.0);
    IIODictionary::setObjectForKeyGroup(v22, (uint64_t)v38, @"DelayTime", @"{WebP}");
    IIONumber::~IIONumber((IIONumber *)v38);
    uint64_t v23 = *(IIODictionary **)(a1 + 56);
    IIONumber::IIONumber((IIONumber *)v37, (double)v20 / 1000.0);
    IIODictionary::setObjectForKeyGroup(v23, (uint64_t)v37, @"UnclampedDelayTime", @"{WebP}");
    IIONumber::~IIONumber((IIONumber *)v37);
    if (*(unsigned char *)(a1 + 437))
    {
      size_t v24 = *(IIODictionary **)(a1 + 56);
      IIONumber::IIONumber((IIONumber *)v36, v39[2]);
      IIODictionary::setObjectForKeyGroup(v24, (uint64_t)v36, @"xOffset", @"{WebP}");
      IIONumber::~IIONumber((IIONumber *)v36);
      uint64_t v25 = *(IIODictionary **)(a1 + 56);
      IIONumber::IIONumber((IIONumber *)v35, v39[3]);
      IIODictionary::setObjectForKeyGroup(v25, (uint64_t)v35, @"yOffset", @"{WebP}");
      IIONumber::~IIONumber((IIONumber *)v35);
      __int16 v26 = *(IIODictionary **)(a1 + 56);
      IIONumber::IIONumber((IIONumber *)v34, v40[0]);
      IIODictionary::setObjectForKeyGroup(v26, (uint64_t)v34, @"width", @"{WebP}");
      IIONumber::~IIONumber((IIONumber *)v34);
      long long v27 = *(IIODictionary **)(a1 + 56);
      IIONumber::IIONumber((IIONumber *)v33, v40[1]);
      IIODictionary::setObjectForKeyGroup(v27, (uint64_t)v33, @"height", @"{WebP}");
      IIONumber::~IIONumber((IIONumber *)v33);
      long long v28 = *(IIODictionary **)(a1 + 56);
      IIONumber::IIONumber((IIONumber *)v32, v40[3]);
      IIODictionary::setObjectForKeyGroup(v28, (uint64_t)v32, @"disposeOp", @"{WebP}");
      IIONumber::~IIONumber((IIONumber *)v32);
      long long v29 = *(IIODictionary **)(a1 + 56);
      IIONumber::IIONumber((IIONumber *)v31, v42[3]);
      IIODictionary::setObjectForKeyGroup(v29, (uint64_t)v31, @"blendOp", @"{WebP}");
      IIONumber::~IIONumber((IIONumber *)v31);
    }
  }
  WebPDemuxDelete(v7);
  return Chunk;
}

void sub_188727D1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t WebPReadPlugin::initialize(IIOImageReadSession **this, IIODictionary *a2)
{
  unint64_t v20 = 0;
  int v21 = 0;
  int v19 = 0;
  uint64_t v18 = 0;
  memset(v17, 0, sizeof(v17));
  if (!IIOImageReadSession::isFinal(this[3])) {
    goto LABEL_18;
  }
  uint64_t v3 = this[6];
  if (v3) {
    LOBYTE(v3) = IIODictionary::getBoolForKey(v3, @"IIO_SKIP_WEBP_COMPOSING");
  }
  *((unsigned char *)this + 437) = (_BYTE)v3;
  int v4 = IIOImageReadSession::retainBytePointer(this[3], (const __CFData **)&v21, 0);
  if (v4)
  {
    BytePtr = (const UInt8 *)v4;
    uint64_t v6 = 0;
  }
  else
  {
    CFDataRef v7 = IIOImageReadSession::copyData((IIOImageRead **)this[3]);
    if (!v7)
    {
LABEL_18:
      uint64_t v6 = 4294967246;
LABEL_29:
      kdebug_trace();
      return v6;
    }
    uint64_t v6 = (uint64_t)v7;
    BytePtr = CFDataGetBytePtr(v7);
  }
  int v19 = BytePtr;
  unint64_t Size = (unint64_t)IIOImageReadSession::getSize(this[3]);
  unint64_t v20 = Size;
  if (WebPGetFeaturesInternal((uint64_t)BytePtr, Size, (uint64_t)v17, 521)) {
    goto LABEL_16;
  }
  int v9 = v17[0];
  int v10 = DWORD1(v17[0]);
  if (SLODWORD(v17[0]) >= 0x4000 || SDWORD1(v17[0]) >= 0x4000)
  {
    _cg_jpeg_mem_term("initialize", 210, "*** ERROR: 'WebP' bad dimension: %d x %d\n");
    goto LABEL_16;
  }
  int v11 = DWORD2(v17[0]);
  if (DWORD2(v17[0])) {
    int v12 = 4;
  }
  else {
    int v12 = 3;
  }
  if (80000 * Size < DWORD1(v17[0]) * LODWORD(v17[0]) * v12)
  {
    _cg_jpeg_mem_term("initialize", 216, "*** ERROR: fileSize: %ld   canvas: %d x %d --> malformed image? (factor: %g)\n");
LABEL_16:
    if (v6)
    {
      CFRelease((CFTypeRef)v6);
      goto LABEL_18;
    }
    char v14 = 0;
    uint64_t v6 = 4294967246;
    goto LABEL_25;
  }
  *((unsigned char *)this + 436) = HIDWORD(v17[0]) != 0;
  if (v11) {
    char v13 = 3;
  }
  else {
    char v13 = 5;
  }
  *((unsigned char *)this + 246) = v13;
  *((_DWORD *)this + 57) = v9;
  *((_DWORD *)this + 58) = v10;
  *((_WORD *)this + 122) = 4;
  *((_DWORD *)this + 59) = 4 * v9;
  *((_DWORD *)this + 60) = 2097160;
  *((_DWORD *)this + 81) = 1380401696;
  this[20] = 0;
  *((_WORD *)this + 172) = 0;
  *((unsigned char *)this + 346) = 0;
  WebPReadPlugin::handleChunks((uint64_t)this, (uint64_t)&v19);
  char v14 = 1;
  *((_WORD *)this + 188) = 1;
  if (v6)
  {
    CFRelease((CFTypeRef)v6);
    return 0;
  }
LABEL_25:
  if (BytePtr)
  {
    size_t v15 = (IIOImageRead **)this[3];
    if (v15) {
      IIOImageReadSession::releaseBytePointer(v15, v21);
    }
  }
  if ((v14 & 1) == 0) {
    goto LABEL_29;
  }
  return v6;
}

uint64_t WebPReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12) {
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2);
  }
  if (v2 == 1) {
    return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

uint64_t WebPReadPlugin::decodeAnimatedWebP(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 246)) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = *(unsigned char *)(a1 + 404) == 1;
  }
  BOOL v29 = v6;
  int v7 = *(_DWORD *)(a1 + 300);
  int v35 = 0;
  memset(v34, 0, sizeof(v34));
  WebPAnimDecoderOptionsInitInternal(v34, 263);
  if (*(unsigned char *)(a1 + 404) == 1) {
    int v8 = 8;
  }
  else {
    int v8 = 1;
  }
  LODWORD(v34[0]) = v8;
  int v9 = WebPAnimDecoderNewInternal(a2, (int *)v34, 263);
  int v12 = (void **)v9;
  if (v9)
  {
    int v33 = 0;
    memset(v32, 0, sizeof(v32));
    if (WebPAnimDecoderGetInfo((uint64_t)v9, (uint64_t)v32))
    {
      if (*(void *)&v32[0] != *(void *)(a1 + 292))
      {
        uint64_t v27 = 4294967246;
        goto LABEL_29;
      }
      unint64_t v13 = 0;
      while (WebPAnimDecoderHasMoreFrames((BOOL)v12))
      {
        uint64_t v31 = 0;
        int v30 = 0;
        if (!WebPAnimDecoderGetNext((uint64_t)v12, &v31, &v30)) {
          break;
        }
        unint64_t v14 = *(unsigned int *)(a1 + 208);
        if (v13 == v14)
        {
          uint64_t v15 = DWORD1(v32[0]);
          if (v29)
          {
            if (DWORD1(v32[0]))
            {
              unsigned int v16 = 0;
              unsigned int v17 = 0;
              uint64_t v18 = v31;
              size_t v19 = (4 * LODWORD(v32[0]));
              do
              {
                memcpy((void *)(a3 + v17), (const void *)(v18 + v16), v19);
                v17 += v7;
                v16 += v19;
                --v15;
              }
              while (v15);
            }
          }
          else if (DWORD1(v32[0]))
          {
            uint64_t v20 = 0;
            uint64_t v21 = v31;
            int v22 = v32[0];
            do
            {
              if (v22)
              {
                uint64_t v23 = (unsigned char *)(a3 + (v7 * v20));
                size_t v24 = (unsigned char *)(v21 + (4 * v20 * v22));
                int v25 = v22;
                do
                {
                  *uint64_t v23 = *v24;
                  v23[1] = v24[1];
                  v23[2] = v24[2];
                  v23 += 3;
                  v24 += 4;
                  --v25;
                }
                while (v25);
              }
              ++v20;
            }
            while (v20 != v15);
          }
          unint64_t v14 = *(unsigned int *)(a1 + 208);
        }
        if (v13++ >= v14)
        {
          uint64_t v27 = 0;
          goto LABEL_29;
        }
      }
    }
  }
  uint64_t v27 = 4294967243;
LABEL_29:
  WebPAnimDecoderDelete(v12, v10, v11);
  return v27;
}

uint64_t WebPReadPlugin::decodeWebP(uint64_t a1, uint64_t *a2, void *a3, uint64_t a4)
{
  if (*(unsigned char *)(a1 + 246))
  {
    uint64_t v6 = *a2;
    uint64_t v7 = a2[1];
    int v8 = *(_DWORD *)(a1 + 300);
    if (*(unsigned char *)(a1 + 405)) {
      WebPDecodeRGBAInto(v6, v7, (uint64_t)a3, a4, v8);
    }
    else {
      WebPDecodeBGRAInto(v6, v7, (uint64_t)a3, a4, v8);
    }
    if (*(unsigned char *)(a1 + 406) == 1)
    {
      vImagePixelCount v9 = *(unsigned int *)(a1 + 296);
      v12.data = a3;
      v12.vImagePixelCount height = v9;
      size_t v10 = *(unsigned int *)(a1 + 300);
      v12.vImagePixelCount width = *(unsigned int *)(a1 + 292);
      v12.size_t rowBytes = v10;
      vImagePremultiplyData_RGBA8888(&v12, &v12, 0x10u);
    }
  }
  else
  {
    WebPDecodeRGBInto(*a2, a2[1], (uint64_t)a3, a4, *(_DWORD *)(a1 + 300));
  }
  return 0;
}

uint64_t WebPReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  memory_object_size_t v38 = 0;
  *((_DWORD *)this + 52) = *((void *)a2 + 9);
  if ((gIIODebugFlags & 0x20000) == 0) {
    goto LABEL_26;
  }
  int v8 = *((_DWORD *)this + 51);
  unsigned int v9 = v8 >> 24;
  uint64_t v10 = MEMORY[0x1E4F14390];
  if (v8 < 0)
  {
    int v11 = __maskrune(v9, 0x40000uLL);
    int v8 = *((_DWORD *)this + 51);
  }
  else
  {
    int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
  }
  if (v11) {
    uint64_t v12 = (v8 >> 24);
  }
  else {
    uint64_t v12 = 46;
  }
  unsigned int v13 = v8 << 8 >> 24;
  if (v8 << 8 < 0)
  {
    int v14 = __maskrune(v13, 0x40000uLL);
    int v8 = *((_DWORD *)this + 51);
  }
  else
  {
    int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
  }
  if (v14) {
    uint64_t v15 = (v8 << 8 >> 24);
  }
  else {
    uint64_t v15 = 46;
  }
  unsigned int v16 = (__int16)v8 >> 8;
  if (v8 << 16 < 0)
  {
    int v17 = __maskrune(v16, 0x40000uLL);
    int v8 = *((_DWORD *)this + 51);
  }
  else
  {
    int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  }
  if (v17) {
    uint64_t v18 = ((__int16)v8 >> 8);
  }
  else {
    uint64_t v18 = 46;
  }
  if ((v8 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0) {
      goto LABEL_22;
    }
LABEL_24:
    uint64_t v19 = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v8, 0x40000uLL)) {
    goto LABEL_24;
  }
LABEL_22:
  uint64_t v19 = *((char *)this + 204);
LABEL_25:
  ImageIOLog("  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus WebPReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  uint64_t v20 = (IIOImageRead **)*((void *)this + 3);
  if (v20) {
    BOOL v21 = IIOImageReadSession::mapData(v20);
  }
  else {
    BOOL v21 = 0;
  }
  if (a3 == 3)
  {
    uint64_t BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v28) = *((_DWORD *)this + 73);
    double v27 = (double)v28;
    unsigned int v29 = *((_DWORD *)this + 74);
    double v26 = (double)v29;
    memory_object_size_t v25 = *((unsigned int *)this + 75) * (unint64_t)v29;
    BaseAddress = (void *)_ImageIO_Malloc(v25, *((void *)this + 48), &v38, (uint64_t)kImageMalloc_WEBP_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1)
    {
      uint64_t BlockArray = 0;
      BaseAddress = 0;
      goto LABEL_39;
    }
    if (!a4 || !*a4)
    {
      uint64_t BlockArray = 0;
      if (!v21) {
        return BlockArray;
      }
      goto LABEL_46;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    size_t Height = IOSurfaceGetHeight(*a4);
    uint64_t BlockArray = 0;
    memory_object_size_t v25 = IOSurfaceGetBytesPerRow(*a4) * Height;
    memory_object_size_t v38 = v25;
    double v26 = 0.0;
    double v27 = 0.0;
  }
  if (!BaseAddress) {
    goto LABEL_39;
  }
  bzero(BaseAddress, v25);
  uint64_t v30 = (*(uint64_t (**)(IIOReadPlugin *, void *, memory_object_size_t))(*(void *)this + 120))(this, BaseAddress, v25);
  if (v30)
  {
    uint64_t BlockArray = v30;
    *((_DWORD *)this + 26) = 0;
    goto LABEL_39;
  }
  if (a3 == 3)
  {
    uint64_t v33 = 0;
    v39.origin.x = 0.0;
    v39.origin.y = 0.0;
    v39.size.vImagePixelCount width = v27;
    v39.size.vImagePixelCount height = v26;
    **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v25, v39, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
    if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E4F1DB20]))
    {
      uint64_t v34 = 0;
    }
    else
    {
      v40.origin.x = 0.0;
      v40.origin.y = 0.0;
      v40.size.vImagePixelCount width = v27;
      v40.size.vImagePixelCount height = v26;
      *(CGRect *)(&v34 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v40);
      uint64_t v33 = v35;
      double v27 = v36;
      double v26 = v37;
    }
    uint64_t BlockArray = 0;
    BaseAddress = 0;
    *((void *)this + 15) = v33;
    *((void *)this + 16) = v34;
    *((double *)this + 17) = v27;
    *((double *)this + 18) = v26;
LABEL_39:
    if (!a4) {
      goto LABEL_42;
    }
    goto LABEL_40;
  }
  IOSurfaceUnlock(*a4, 0, 0);
  uint64_t BlockArray = 0;
LABEL_40:
  if (*a4) {
    IOSurfaceUnlock(*a4, 0, 0);
  }
LABEL_42:
  if (a3 == 3 && BaseAddress) {
    _ImageIO_Free((unint64_t)BaseAddress, v38);
  }
  if (v21)
  {
LABEL_46:
    uint64_t v31 = (const char **)*((void *)this + 3);
    if (v31) {
      IIOImageReadSession::unmapData(v31);
    }
  }
  return BlockArray;
}

uint64_t WebPReadPlugin::decodeImageData(IIOImageReadSession **this, unsigned __int8 *a2, uint64_t a3)
{
  unsigned int v13 = 0;
  uint64_t v6 = IIOImageReadSession::retainBytePointer(this[3], (const __CFData **)&v13, 0);
  if (v6)
  {
    BytePtr = (const UInt8 *)v6;
    CFDataRef v8 = 0;
  }
  else
  {
    CFDataRef v9 = IIOImageReadSession::copyData((IIOImageRead **)this[3]);
    if (!v9) {
      return 0;
    }
    CFDataRef v8 = v9;
    BytePtr = CFDataGetBytePtr(v9);
  }
  v14[0] = (uint64_t)BytePtr;
  v14[1] = (uint64_t)IIOImageReadSession::getSize(this[3]);
  if (*((unsigned char *)this + 436))
  {
    uint64_t v10 = WebPReadPlugin::decodeAnimatedWebP((uint64_t)this, (uint64_t)v14, (uint64_t)a2);
    if (v10) {
      _cg_jpeg_mem_term("decodeImageData", 489, "*** ERROR: decodeAnimatedWebP failed\n");
    }
  }
  else
  {
    WebPReadPlugin::decodeWebP((uint64_t)this, v14, a2, a3);
    uint64_t v10 = 0;
  }
  if (v8)
  {
    CFRelease(v8);
  }
  else if (BytePtr)
  {
    int v11 = (IIOImageRead **)this[3];
    if (v11) {
      IIOImageReadSession::releaseBytePointer(v11, v13);
    }
  }
  return v10;
}

void BCWritePlugin::BCWritePlugin(BCWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, char a4)
{
  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 1111695392);
  *(void *)uint64_t v5 = &unk_1ED4DF608;
  *(void *)(v5 + 48) = 0;
  *(unsigned char *)(v5 + 56) = 0;
  *(unsigned char *)(v5 + 57) = a4;
  *(void *)(v5 + 64) = 0;
}

void BCWritePlugin::BCWritePlugin(IIOWritePlugin *a1, IIOImageWriteSession *a2, IIOImageDestination *a3, uint64_t a4)
{
  IIOWritePlugin::IIOWritePlugin(a1, a2, a3, 1111695392);
  *(void *)uint64_t v5 = &unk_1ED4DF608;
  *(void *)(v5 + 48) = 0;
  *(_WORD *)(v5 + 56) = 0;
  *(void *)(v5 + 64) = a4;
}

void BCWritePlugin::~BCWritePlugin(BCWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

const __CFDictionary *BCWritePlugin::handleProperties(BCWritePlugin *this, IIODictionary *a2)
{
  *((void *)this + 5) = 0;
  if (IIODictionary::containsKey(a2, @"kCGImagePropertyBCFormat")) {
    *((_DWORD *)this + 12) = IIODictionary::getUint32ForKey(a2, @"kCGImagePropertyBCFormat");
  }
  if (IIODictionary::containsKey(a2, @"kCGImageDestinationLossyCompressionQuality"))
  {
    double FloatForKey = IIODictionary::getFloatForKey(a2, @"kCGImageDestinationLossyCompressionQuality");
    float v5 = 0.0;
    if (*(float *)&FloatForKey >= 0.0)
    {
      float v5 = *(float *)&FloatForKey;
      if (*(float *)&FloatForKey > 1.0) {
        float v5 = 1.0;
      }
    }
    float v6 = (1.0 - v5) * 0.0032;
    *((float *)this + 13) = v6;
  }
  else
  {
    *((_DWORD *)this + 13) = 978433815;
  }
  CFDictionaryRef result = IIODictionary::containsKey(a2, @"kCGImagePropertyBCWeightChannelsEqually");
  if (result)
  {
    CFDictionaryRef result = IIODictionary::getUint32ForKey(a2, @"kCGImagePropertyBCWeightChannelsEqually");
    if (result) {
      *((void *)this + 5) |= 0x40uLL;
    }
  }
  return result;
}

uint64_t BCWritePlugin::writeOneImage(BCWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t BCWritePlugin::writeOne(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  BCWritePlugin::handleProperties((BCWritePlugin *)this, a3);
  unsigned int AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a2);
  __int16 BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(a2);
  IIOImageSource::imageReadRef(a2);
  CGImageGetImageProvider();
  uint64_t v8 = *MEMORY[0x1E4F1CFD0];
  uint64_t Property = CGImageProviderGetProperty();
  if (v8 == Property && (CFNumberRef v11 = (const __CFNumber *)CGImageProviderGetProperty()) != 0)
  {
    IIONumber::IIONumber((IIONumber *)&src, v11);
    int v10 = IIONumber::uint32Num((IIONumber *)&src);
    IIONumber::~IIONumber((IIONumber *)&src);
  }
  else
  {
    int v10 = 4;
  }
  if (AlphaInfo >= 7)
  {
    _cg_jpeg_mem_term("writeOne", 202, "### alpha not handled: %X\n", AlphaInfo);
    at_alpha_t v12 = at_alpha_opaque;
  }
  else
  {
    at_alpha_t v12 = dword_188990A68[AlphaInfo];
  }
  SourceGeomCGColorSpaceRef ColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  CGColorSpaceModel Model = CGColorSpaceGetModel(SourceGeomColorSpace);
  int Error = _cg_GifLastError((uint64_t)a2);
  unsigned int v49 = v10;
  if (Model == kCGColorSpaceModelRGB)
  {
    uint64_t v18 = 10;
    if ((BitmapInfo & 0x100) == 0) {
      uint64_t v18 = 7;
    }
    if (Error == 16) {
      at_texel_format_t v17 = v18;
    }
    else {
      at_texel_format_t v17 = at_texel_format_rgba8_unorm;
    }
    goto LABEL_20;
  }
  if (Model)
  {
    at_texel_format_t v17 = at_texel_format_invalid;
LABEL_20:
    int v16 = 1;
    goto LABEL_24;
  }
  if (Error == 16)
  {
    int v16 = 0;
    if (AlphaInfo) {
      at_texel_format_t v17 = at_texel_format_la16_unorm;
    }
    else {
      at_texel_format_t v17 = at_texel_format_l16_unorm;
    }
  }
  else
  {
    int v16 = 0;
    if (AlphaInfo) {
      at_texel_format_t v17 = at_texel_format_la8_unorm;
    }
    else {
      at_texel_format_t v17 = at_texel_format_l8_unorm;
    }
  }
LABEL_24:
  int v19 = *((_DWORD *)this + 12);
  uint64_t v50 = Property;
  uint64_t v51 = v8;
  if (v19 <= 35918)
  {
    at_block_format_t v20 = at_block_format_bc1;
    if (v19 > 33778)
    {
      if ((v19 - 35916) < 2) {
        goto LABEL_51;
      }
      if (v19 == 33779)
      {
LABEL_42:
        at_block_format_t v20 = at_block_format_bc3;
        goto LABEL_51;
      }
      int v21 = 35918;
    }
    else
    {
      if ((v19 - 33776) < 2) {
        goto LABEL_51;
      }
      if (!v19)
      {
        if (v17 - 1 <= 3)
        {
          at_block_format_t v20 = qword_188990A88[v17 - 1];
          goto LABEL_51;
        }
        goto LABEL_48;
      }
      int v21 = 33778;
    }
    if (v19 == v21)
    {
      at_block_format_t v20 = at_block_format_bc2;
      goto LABEL_51;
    }
LABEL_50:
    at_block_format_t v20 = at_block_format_invalid;
    goto LABEL_51;
  }
  if (v19 > 36491)
  {
    if ((v19 - 36492) >= 2)
    {
      if (v19 == 36494)
      {
        at_block_format_t v20 = at_block_format_bc6;
        goto LABEL_51;
      }
      if (v19 == 36495)
      {
        at_block_format_t v20 = at_block_format_bc6u;
        goto LABEL_51;
      }
      goto LABEL_50;
    }
LABEL_48:
    at_block_format_t v20 = at_block_format_bc7;
    goto LABEL_51;
  }
  switch(v19)
  {
    case 36283:
      at_block_format_t v20 = at_block_format_bc4;
      break;
    case 36284:
      at_block_format_t v20 = at_block_format_bc4s;
      break;
    case 36285:
      at_block_format_t v20 = at_block_format_bc5;
      break;
    case 36286:
      at_block_format_t v20 = at_block_format_bc5s;
      break;
    default:
      if (v19 == 35919) {
        goto LABEL_42;
      }
      goto LABEL_50;
  }
LABEL_51:
  unsigned int v22 = IIOImageSource::count(a2);
  unsigned int v23 = IIO_Reader::testHeaderSize(a2);
  if (*((unsigned char *)this + 57))
  {
    if (v16)
    {
      if (IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E4F1DB90]))
      {
        unsigned int v24 = 3;
      }
      else if (IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E4F1DB78]))
      {
        unsigned int v24 = 2;
      }
      else
      {
        unsigned int v24 = 1;
      }
    }
    else
    {
      unsigned int v24 = 0;
    }
    int v25 = *((_DWORD *)this + 12);
    if (!v25)
    {
      if (v20 - 33 > 9) {
        int v25 = 0;
      }
      else {
        int v25 = dword_188990AA8[v20 - 33];
      }
      *((_DWORD *)this + 12) = v25;
    }
    KTXWritePlugin::writeKTXHeader(this[2], v22, v23, 0, v24, AlphaInfo, 0, 1, 0, v25, 0, 1);
  }
  double v26 = at_encoder_create(v17, v12, v20, v12, 0);
  double v27 = v26;
  if (!v26)
  {
    uint64_t v35 = 0;
    uint64_t v42 = 0;
    goto LABEL_77;
  }
  unint64_t v53 = this;
  BOOL is_compression_monolithic = at_encoder_is_compression_monolithic(v26, at_flags_default);
  uint64_t v29 = IIOImagePlus::sourceImageProvider(a2);
  size_t v30 = v29;
  *(void *)&src.validSize.z = 0;
  uint64_t v31 = v23;
  if (v51 == v50 && !is_compression_monolithic)
  {
    uint64_t v32 = v49;
    do
    {
      uint64_t v31 = v32;
      char v33 = v32 * v22;
      v32 *= 2;
    }
    while ((v33 & 0xF) != 0);
  }
  uint64_t v34 = v31 * v29;
  uint64_t v35 = malloc_type_malloc(v31 * v29, 0x12B15185uLL);
  src.texels = 0;
  *(void *)&src.validSize.x = __PAIR64__(v23, v22);
  src.validSize.z = 1;
  src.size_t rowBytes = v30;
  src.sliceBytes = 0;
  *(void *)&v57.x = __PAIR64__(v23, v22);
  v57.z = 1;
  unint64_t block_counts = (unint64_t)at_encoder_get_block_counts(v27, v57);
  unsigned int v37 = block_counts;
  unint64_t v38 = HIDWORD(block_counts);
  block_size_t size = at_encoder_get_block_size(v27);
  size_t v40 = v38 * v37 * block_size;
  dest.size_t rowBytes = v37 * block_size;
  dest.sliceBytes = v40;
  long long v41 = (char *)malloc_type_calloc(v40, 1uLL, 0xADA0ED5AuLL);
  uint64_t v42 = v41;
  if (v40) {
    BOOL v43 = v41 == 0;
  }
  else {
    BOOL v43 = 1;
  }
  if (v43)
  {
    LogError("writeOne", 359, "*** could not allocate dest buffer [%d bytes]\n", v40);
    goto LABEL_77;
  }
  size_t v52 = v40;
  dest.blocks = v41;
  if (!v23)
  {
LABEL_91:
    uint64_t v48 = v53[8];
    if (v48)
    {
      if ((*(uint64_t (**)(void))(*((void *)v48 + 1) + 24))() != v52
        || (*(unsigned int (**)(void))(*((void *)v53[8] + 1) + 64))())
      {
        goto LABEL_100;
      }
    }
    else if (*((unsigned char *)v53 + 57))
    {
      int __ptr = v52;
      if (IIOImageWriteSession::putBytes(v53[2], &__ptr, 4uLL) != 4) {
        goto LABEL_100;
      }
      IIOImageWriteSession::putBytes(v53[2], v42, v52);
    }
LABEL_77:
    uint64_t v44 = 0;
    if (!v27) {
      goto LABEL_79;
    }
    goto LABEL_78;
  }
  unsigned int v46 = 0;
  at_flags_t v47 = (at_flags_t)v53[5];
  while (1)
  {
    if (v31 + (unint64_t)v46 > v23)
    {
      uint64_t v31 = v23 - v46;
      uint64_t v34 = v30 * v31;
    }
    src.validSize.y = v31;
    src.texels = v35;
    if (IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v35) != v34)
    {
      LogError("writeOne", 384, "failed to read %ld bytes\n");
      goto LABEL_100;
    }
    dest.blocks = &v42[dest.rowBytes * (v46 >> 2)];
    if (at_encoder_compress_texels(v27, &src, &dest, *((float *)v53 + 13), v47) < 0.0) {
      break;
    }
    v46 += v31;
    if (v46 >= v23) {
      goto LABEL_91;
    }
  }
  LogError("writeOne", 394, "*** ERROR: at_encoder_compress_texels: %g (%ld)\n");
LABEL_100:
  uint64_t v44 = 4294967246;
  if (v27) {
LABEL_78:
  }
    CFRelease(v27);
LABEL_79:
  if (v42) {
    free(v42);
  }
  if (v35) {
    free(v35);
  }
  return v44;
}

void sub_188728FEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t BCWritePlugin::GetVkFormat(uint64_t this, IIODictionary *a2)
{
  if (this)
  {
    int v2 = (IIODictionary *)this;
    this = (uint64_t)IIODictionary::containsKey((IIODictionary *)this, @"kCGImagePropertyBCFormat");
    if (this)
    {
      int Uint32ForKey = IIODictionary::getUint32ForKey(v2, @"kCGImagePropertyBCFormat");
      if (Uint32ForKey > 36282)
      {
        switch(Uint32ForKey)
        {
          case 36492:
            this = 145;
            break;
          case 36493:
            this = 146;
            break;
          case 36494:
            this = 144;
            break;
          case 36495:
            this = 143;
            break;
          default:
LABEL_15:
            this = 0;
            break;
        }
      }
      else
      {
        int v4 = Uint32ForKey - 33776;
        if (Uint32ForKey > 0x8DBA)
        {
          switch(Uint32ForKey)
          {
            case 35916:
              this = 132;
              break;
            case 35917:
              this = 134;
              break;
            case 35918:
              this = 136;
              break;
            case 35919:
              this = 138;
              break;
            default:
              goto LABEL_15;
          }
        }
        else
        {
          this = 131;
          switch(v4)
          {
            case 0:
              return this;
            case 1:
              this = 133;
              break;
            case 2:
              this = 135;
              break;
            case 3:
              this = 137;
              break;
            default:
              JUMPOUT(0);
          }
        }
      }
    }
  }
  return this;
}

void IIO_Writer_BC::~IIO_Writer_BC(IIO_Writer_BC *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIO_Writer_BC::write(IIO_Writer_BC *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v9 = 0;
  long long v8 = 0u;
  memset(v7, 0, sizeof(v7));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v7, a2, a3, 1111695392);
  uint64_t v9 = 0;
  *(void *)&v7[0] = &unk_1ED4DF608;
  *(void *)&long long v8 = 0;
  WORD4(v8) = 0;
  uint64_t v3 = IIOWritePlugin::writeAll((IIOImageDestination **)v7);
  _cg_jpeg_mem_term(v7, v4, v5);
  return v3;
}

void sub_1887292A8(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t TIFFPredictorInit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 1096);
  if (!v8) {
    TIFFPredictorInit_cold_1();
  }
  uint64_t v10 = 1;
  if (_TIFFMergeFields(a1, predictFields, 1, a4, a5, a6, a7, a8))
  {
    int8x16_t v16 = *(int8x16_t *)(a1 + 1280);
    *(void *)(a1 + 1288) = PredictorVGetField;
    *(int8x16_t *)(v8 + 88) = vextq_s8(v16, v16, 8uLL);
    *(void *)(a1 + 1280) = PredictorVSetField;
    *(void *)(v8 + 104) = *(void *)(a1 + 1296);
    *(void *)(a1 + 1296) = PredictorPrintDir;
    *(void *)(v8 + 112) = *(void *)(a1 + 960);
    *(void *)(a1 + 960) = PredictorSetupDecode;
    *(void *)(v8 + 120) = *(void *)(a1 + 976);
    *(void *)(a1 + 976) = PredictorSetupEncode;
    *(_DWORD *)uint64_t v8 = 1;
    *(void *)(v8 + 48) = 0;
    *(void *)(v8 + 80) = 0;
  }
  else
  {
    TIFFErrorExtR(a1, "TIFFPredictorInit", "Merging Predictor codec-specific tags failed", v11, v12, v13, v14, v15, v18);
    return 0;
  }
  return v10;
}

uint64_t PredictorVGetField(uint64_t a1, int a2, _WORD **a3)
{
  uint64_t v3 = *(void *)(a1 + 1096);
  if (!v3 || !*(void *)(v3 + 96)) {
    return 0;
  }
  if (a2 != 317) {
    return (*(uint64_t (**)(void))(v3 + 88))();
  }
  **a3 = *(_DWORD *)v3;
  return 1;
}

uint64_t PredictorVSetField(uint64_t a1, int a2, unsigned __int16 *a3)
{
  uint64_t v3 = *(void *)(a1 + 1096);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = *(uint64_t (**)(void))(v3 + 96);
  if (!v4) {
    return 0;
  }
  if (a2 != 317) {
    return v4();
  }
  *(_DWORD *)uint64_t v3 = *a3;
  *(_DWORD *)(a1 + 80) |= 4u;
  *(_DWORD *)(a1 + 16) |= 8u;
  return 1;
}

uint64_t PredictorPrintDir(uint64_t result, FILE *__stream, uint64_t a3)
{
  uint64_t v5 = result;
  float v6 = *(_DWORD **)(result + 1096);
  if ((*(unsigned char *)(result + 80) & 4) != 0)
  {
    fwrite("  Predictor: ", 0xDuLL, 1uLL, __stream);
    int v7 = *v6;
    if (*v6 == 3)
    {
      uint64_t v8 = "floating point predictor ";
      size_t v9 = 25;
    }
    else if (v7 == 2)
    {
      uint64_t v8 = "horizontal differencing ";
      size_t v9 = 24;
    }
    else
    {
      if (v7 != 1)
      {
LABEL_9:
        CFDictionaryRef result = fprintf(__stream, "%d (0x%x)\n", *v6, *v6);
        goto LABEL_10;
      }
      uint64_t v8 = "none ";
      size_t v9 = 5;
    }
    fwrite(v8, v9, 1uLL, __stream);
    goto LABEL_9;
  }
LABEL_10:
  uint64_t v10 = (uint64_t (*)(uint64_t, FILE *, uint64_t))*((void *)v6 + 13);
  if (v10)
  {
    return v10(v5, __stream, a3);
  }
  return result;
}

uint64_t PredictorSetupDecode(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 1096);
  uint64_t result = (*(uint64_t (**)(void))(v2 + 112))();
  if (result)
  {
    uint64_t result = PredictorSetup(a1, v4, v5, v6, v7, v8, v9, v10);
    if (result)
    {
      if (*(_DWORD *)v2 == 3)
      {
        *(void *)(v2 + 80) = fpAcc;
        int8x16_t v16 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 1008);
        if (v16 != PredictorDecodeRow)
        {
          *(void *)(v2 + 56) = v16;
          *(void *)(a1 + 1008) = PredictorDecodeRow;
          *(void *)(v2 + 64) = *(void *)(a1 + 1024);
          *(void *)(a1 + 1024) = PredictorDecodeTile;
          *(void *)(v2 + 72) = *(void *)(a1 + 1040);
          *(void *)(a1 + 1040) = PredictorDecodeTile;
        }
        if ((*(unsigned char *)(a1 + 16) & 0x80) == 0) {
          return 1;
        }
      }
      else
      {
        if (*(_DWORD *)v2 != 2) {
          return 1;
        }
        HIDWORD(v12) = *(unsigned __int16 *)(a1 + 116);
        LODWORD(v12) = HIDWORD(v12) - 8;
        unsigned int v11 = v12 >> 3;
        if (v11 <= 7 && ((0x8Bu >> v11) & 1) != 0) {
          *(void *)(v2 + 80) = off_1ED4F0A20[v11];
        }
        uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 1008);
        if (v13 != PredictorDecodeRow)
        {
          *(void *)(v2 + 56) = v13;
          *(void *)(a1 + 1008) = PredictorDecodeRow;
          *(void *)(v2 + 64) = *(void *)(a1 + 1024);
          *(void *)(a1 + 1024) = PredictorDecodeTile;
          *(void *)(v2 + 72) = *(void *)(a1 + 1040);
          *(void *)(a1 + 1040) = PredictorDecodeTile;
        }
        if ((*(unsigned char *)(a1 + 16) & 0x80) == 0) {
          return 1;
        }
        uint64_t v14 = *(uint64_t (**)(uint64_t, void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v2 + 80);
        uint64_t v15 = swabHorAcc16;
        if ((char *)v14 != (char *)horAcc16)
        {
          uint64_t v15 = swabHorAcc32;
          if ((char *)v14 != (char *)horAcc32)
          {
            uint64_t v15 = swabHorAcc64;
            if (v14 != horAcc64) {
              return 1;
            }
          }
        }
        *(void *)(v2 + 80) = v15;
      }
      *(void *)(a1 + 1248) = _TIFFNoPostDecode;
      return 1;
    }
  }
  return result;
}

uint64_t PredictorSetupEncode(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 1096);
  uint64_t result = (*(uint64_t (**)(void))(v2 + 120))();
  if (result)
  {
    uint64_t result = PredictorSetup(a1, v4, v5, v6, v7, v8, v9, v10);
    if (result)
    {
      if (*(_DWORD *)v2 == 3)
      {
        *(void *)(v2 + 48) = fpDiff;
        int8x16_t v16 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 1016);
        if (v16 != PredictorEncodeRow)
        {
          *(void *)(v2 + 24) = v16;
          *(void *)(a1 + 1016) = PredictorEncodeRow;
          *(void *)(v2 + 32) = *(void *)(a1 + 1032);
          *(void *)(a1 + 1032) = PredictorEncodeTile;
          *(void *)(v2 + 40) = *(void *)(a1 + 1048);
          *(void *)(a1 + 1048) = PredictorEncodeTile;
        }
        return 1;
      }
      if (*(_DWORD *)v2 == 2)
      {
        HIDWORD(v12) = *(unsigned __int16 *)(a1 + 116);
        LODWORD(v12) = HIDWORD(v12) - 8;
        unsigned int v11 = v12 >> 3;
        if (v11 <= 7 && ((0x8Bu >> v11) & 1) != 0) {
          *(void *)(v2 + 48) = off_1ED4F0A60[v11];
        }
        uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 1016);
        if (v13 != PredictorEncodeRow)
        {
          *(void *)(v2 + 24) = v13;
          *(void *)(a1 + 1016) = PredictorEncodeRow;
          *(void *)(v2 + 32) = *(void *)(a1 + 1032);
          *(void *)(a1 + 1032) = PredictorEncodeTile;
          *(void *)(v2 + 40) = *(void *)(a1 + 1048);
          *(void *)(a1 + 1048) = PredictorEncodeTile;
        }
        if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
        {
          uint64_t v14 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v2 + 48);
          if (v14 == horDiff16)
          {
            uint64_t v15 = swabHorDiff16;
            goto LABEL_19;
          }
          if (v14 == horDiff32)
          {
            uint64_t v15 = swabHorDiff32;
            goto LABEL_19;
          }
          if (v14 == horDiff64)
          {
            uint64_t v15 = swabHorDiff64;
LABEL_19:
            *(void *)(v2 + 48) = v15;
            *(void *)(a1 + 1248) = _TIFFNoPostDecode;
          }
        }
      }
      return 1;
    }
  }
  return result;
}

uint64_t TIFFPredictorCleanup(void *a1)
{
  CFDictionaryRef v1 = (void *)a1[137];
  if (!v1) {
    TIFFPredictorCleanup_cold_1();
  }
  uint64_t v2 = v1[12];
  a1[161] = v1[11];
  a1[160] = v2;
  uint64_t v3 = v1[14];
  a1[162] = v1[13];
  a1[120] = v3;
  a1[122] = v1[15];
  return 1;
}

BOOL PredictorSetup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(unsigned int **)(a1 + 1096);
  uint64_t v9 = *v8;
  if (v9 == 1) {
    return v9;
  }
  if (v9 == 3)
  {
    if (*(_WORD *)(a1 + 118) == 3)
    {
      HIDWORD(v13) = *(unsigned __int16 *)(a1 + 116);
      LODWORD(v13) = (HIDWORD(v13) << 16) - 0x100000;
      int v14 = (1 << (v13 >> 19)) & 0x47;
      if ((unsigned __int16)(v13 >> 19) <= 6u && v14 != 0) {
        goto LABEL_15;
      }
      TIFFErrorExtR(a1, "PredictorSetup", "Floating point \"Predictor\" not supported with %hu-bit samples", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 116));
    }
    else
    {
      TIFFErrorExtR(a1, "PredictorSetup", "Floating point \"Predictor\" not supported with %hu data format", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 118));
    }
    return 0;
  }
  if (v9 != 2)
  {
    TIFFErrorExtR(a1, "PredictorSetup", "\"Predictor\" value %d not supported", a4, a5, a6, a7, a8, *v8);
    return 0;
  }
  HIDWORD(v10) = *(unsigned __int16 *)(a1 + 116);
  LODWORD(v10) = (HIDWORD(v10) << 16) - 0x80000;
  int v11 = (1 << (v10 >> 19)) & 0x8B;
  if ((unsigned __int16)(v10 >> 19) > 7u || v11 == 0)
  {
    TIFFErrorExtR(a1, "PredictorSetup", "Horizontal differencing \"Predictor\" not supported with %hu-bit samples", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 116));
    return 0;
  }
LABEL_15:
  if (*(_WORD *)(a1 + 170) == 1) {
    uint64_t v16 = *(unsigned __int16 *)(a1 + 130);
  }
  else {
    uint64_t v16 = 1;
  }
  *((void *)v8 + 1) = v16;
  if ((*(unsigned char *)(a1 + 17) & 4) != 0) {
    uint64_t v17 = _cg_TIFFTileRowSize(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else {
    uint64_t v17 = _cg_TIFFScanlineSize(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  *((void *)v8 + 2) = v17;
  return v17 != 0;
}

uint64_t horAcc8(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8x8_t a9, uint8x8_t a10)
{
  uint64_t v10 = *(void *)(*(void *)(a1 + 1096) + 8);
  if (a3 % v10)
  {
    TIFFErrorExtR(a1, "horAcc8", "%s", a4, a5, a6, a7, a8, (char)"(cc%stride)!=0");
    return 0;
  }
  uint64_t v12 = a3 - v10;
  if (a3 <= v10) {
    return 1;
  }
  if (v10 != 4)
  {
    if (v10 == 3)
    {
      if (a3 >= 4)
      {
        uint64_t v13 = 0;
        int v14 = a2[2];
        int v15 = a2[1];
        int v16 = *a2;
        do
        {
          uint64_t v17 = &a2[v13];
          v16 += a2[v13 + 3];
          void v17[3] = v16;
          v15 += a2[v13 + 4];
          v17[4] = v15;
          v14 += a2[v13 + 5];
          v17[5] = v14;
          uint64_t v18 = v13 + 6;
          v13 += 3;
        }
        while (v18 < a3);
      }
    }
    else
    {
      do
      {
        if (v10)
        {
          if (v10 != 1)
          {
            if (v10 != 2)
            {
              if (v10 >= 5)
              {
                unint64_t v19 = v10 - 3;
                do
                {
                  a2[v10] += *a2;
                  ++a2;
                  --v19;
                }
                while (v19 > 1);
              }
              a2[v10] += *a2;
              unsigned __int8 v21 = a2[1];
              at_block_format_t v20 = a2 + 1;
              v20[v10] += v21;
              a2 = v20 + 1;
            }
            a2[v10] += *a2;
            ++a2;
          }
          a2[v10] += *a2;
          ++a2;
        }
        BOOL v22 = v12 <= v10;
        v12 -= v10;
      }
      while (!v22);
    }
    return 1;
  }
  if (a3 < 5) {
    return 1;
  }
  a9.i32[0] = *(_DWORD *)a2;
  int32x4_t v23 = (int32x4_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a9));
  uint64_t v24 = 4;
  uint64_t result = 1;
  do
  {
    a10.i32[0] = *(_DWORD *)&a2[v24];
    int16x8_t v25 = (int16x8_t)vmovl_u8(a10);
    int32x4_t v23 = (int32x4_t)vaddw_u16((uint32x4_t)v23, *(uint16x4_t *)v25.i8);
    *(int16x4_t *)v25.i8 = vmovn_s32(v23);
    a10 = (uint8x8_t)vmovn_s16(v25);
    *(_DWORD *)&a2[v24] = a10.i32[0];
    v24 += 4;
  }
  while (v24 < a3);
  return result;
}

uint64_t horAcc16(uint64_t a1, _WORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 1096) + 8);
  if (a3 >= 0) {
    uint64_t v9 = a3;
  }
  else {
    uint64_t v9 = a3 + 1;
  }
  if (a3 % (2 * v8))
  {
    TIFFErrorExtR(a1, "horAcc16", "%s", a4, a5, a6, a7, a8, (char)"cc%(2*stride))!=0");
    return 0;
  }
  else
  {
    uint64_t v11 = v9 >> 1;
    BOOL v12 = v11 <= v8;
    uint64_t v13 = v11 - v8;
    if (!v12)
    {
      while (2)
      {
        switch(v8)
        {
          case 0:
            goto LABEL_15;
          case 1:
            goto LABEL_14;
          case 2:
            goto LABEL_13;
          case 3:
            goto LABEL_12;
          case 4:
            goto LABEL_11;
          default:
            if (v8 >= 5)
            {
              unint64_t v14 = v8 - 3;
              do
              {
                a2[v8] += *a2;
                ++a2;
                --v14;
              }
              while (v14 > 1);
            }
LABEL_11:
            a2[v8] += *a2;
            ++a2;
LABEL_12:
            a2[v8] += *a2;
            ++a2;
LABEL_13:
            a2[v8] += *a2;
            ++a2;
LABEL_14:
            a2[v8] += *a2;
            ++a2;
LABEL_15:
            BOOL v12 = v13 <= v8;
            v13 -= v8;
            if (!v12) {
              continue;
            }
            return 1;
        }
      }
    }
    return 1;
  }
}

uint64_t horAcc32(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 1096) + 8);
  uint64_t v9 = a3 + 3;
  if (a3 >= 0) {
    uint64_t v9 = a3;
  }
  if (a3 % (4 * v8))
  {
    TIFFErrorExtR(a1, "horAcc32", "%s", a4, a5, a6, a7, a8, (char)"cc%(4*stride))!=0");
    return 0;
  }
  else
  {
    uint64_t v11 = v9 >> 2;
    BOOL v12 = v11 <= v8;
    uint64_t v13 = v11 - v8;
    if (!v12)
    {
      while (2)
      {
        switch(v8)
        {
          case 0:
            goto LABEL_14;
          case 1:
            goto LABEL_13;
          case 2:
            goto LABEL_12;
          case 3:
            goto LABEL_11;
          case 4:
            goto LABEL_10;
          default:
            if (v8 >= 5)
            {
              unint64_t v14 = v8 - 3;
              do
              {
                a2[v8] += *a2;
                ++a2;
                --v14;
              }
              while (v14 > 1);
            }
LABEL_10:
            a2[v8] += *a2;
            ++a2;
LABEL_11:
            a2[v8] += *a2;
            ++a2;
LABEL_12:
            a2[v8] += *a2;
            ++a2;
LABEL_13:
            a2[v8] += *a2;
            ++a2;
LABEL_14:
            BOOL v12 = v13 <= v8;
            v13 -= v8;
            if (!v12) {
              continue;
            }
            return 1;
        }
      }
    }
    return 1;
  }
}

uint64_t horAcc64(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 1096) + 8);
  uint64_t v9 = a3 + 7;
  if (a3 >= 0) {
    uint64_t v9 = a3;
  }
  if (a3 % (8 * v8))
  {
    TIFFErrorExtR(a1, "horAcc64", "%s", a4, a5, a6, a7, a8, (char)"cc%(8*stride))!=0");
    return 0;
  }
  else
  {
    uint64_t v11 = v9 >> 3;
    BOOL v12 = v11 <= v8;
    uint64_t v13 = v11 - v8;
    if (!v12)
    {
      while (2)
      {
        switch(v8)
        {
          case 0:
            goto LABEL_14;
          case 1:
            goto LABEL_13;
          case 2:
            goto LABEL_12;
          case 3:
            goto LABEL_11;
          case 4:
            goto LABEL_10;
          default:
            if (v8 >= 5)
            {
              unint64_t v14 = v8 - 3;
              do
              {
                a2[v8] += *a2;
                ++a2;
                --v14;
              }
              while (v14 > 1);
            }
LABEL_10:
            a2[v8] += *a2;
            ++a2;
LABEL_11:
            a2[v8] += *a2;
            ++a2;
LABEL_12:
            a2[v8] += *a2;
            ++a2;
LABEL_13:
            a2[v8] += *a2;
            ++a2;
LABEL_14:
            BOOL v12 = v13 <= v8;
            v13 -= v8;
            if (!v12) {
              continue;
            }
            return 1;
        }
      }
    }
    return 1;
  }
}

uint64_t PredictorDecodeRow(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 1096);
  if (!v3) {
    PredictorDecodeRow_cold_1();
  }
  uint64_t v4 = *(uint64_t (**)(void))(v3 + 56);
  if (!v4) {
    PredictorDecodeRow_cold_2();
  }
  if (!*(void *)(v3 + 80)) {
    PredictorDecodeRow_cold_3();
  }
  uint64_t result = v4();
  if (result)
  {
    uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v3 + 80);
    return v9(a1, a2, a3);
  }
  return result;
}

uint64_t PredictorDecodeTile(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void **)(a1 + 1096);
  if (!v3) {
    PredictorDecodeTile_cold_1();
  }
  uint64_t v4 = (uint64_t (*)(void))v3[9];
  if (!v4) {
    PredictorDecodeTile_cold_2();
  }
  uint64_t result = v4();
  if (result)
  {
    uint64_t v14 = v3[2];
    if (v14 <= 0) {
      PredictorDecodeTile_cold_3();
    }
    if (a3 % v14)
    {
      TIFFErrorExtR(a1, "PredictorDecodeTile", "%s", v9, v10, v11, v12, v13, (char)"occ0%rowsize != 0");
      return 0;
    }
    else
    {
      if (!v3[10]) {
        PredictorDecodeTile_cold_4();
      }
      if (a3 < 1)
      {
        return 1;
      }
      else
      {
        while (1)
        {
          uint64_t result = ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v3[10])(a1, a2, v14);
          if (!result) {
            break;
          }
          a3 -= v14;
          a2 += v14;
          if (a3 <= 0) {
            return 1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t swabHorAcc16(uint64_t a1, _WORD *a2, uint64_t a3)
{
  if (a3 >= 0) {
    uint64_t v6 = a3;
  }
  else {
    uint64_t v6 = a3 + 1;
  }
  TIFFSwabArrayOfShort((uint64_t)a2, v6 >> 1);

  return horAcc16(a1, a2, a3, v7, v8, v9, v10, v11);
}

uint64_t swabHorAcc32(uint64_t a1, __int32 *a2, uint64_t a3, uint8x8_t a4)
{
  TIFFSwabArrayOfLong(a2, a3 / 4, a4);

  return horAcc32(a1, a2, a3, v7, v8, v9, v10, v11);
}

uint64_t swabHorAcc64(uint64_t a1, int8x8_t *a2, uint64_t a3)
{
  TIFFSwabArrayOfLong8(a2, a3 / 8);

  return horAcc64(a1, a2, a3, v6, v7, v8, v9, v10);
}

uint64_t fpAcc(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *(unsigned __int16 *)(a1 + 116);
  if (v8 < 8) {
    return 0;
  }
  uint64_t v11 = *(void *)(*(void *)(a1 + 1096) + 8);
  uint64_t v12 = v8 >> 3;
  if (a3 % (uint64_t)(v11 * (v8 >> 3)))
  {
    TIFFErrorExtR(a1, "fpAcc", "%s", a4, a5, a6, a7, a8, (char)"cc%(bps*stride))!=0");
    return 0;
  }
  uint64_t result = (uint64_t)_TIFFmallocExt((void *)a1, a3, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    int v15 = (char *)result;
    uint64_t v16 = a3 / v12;
    if (v11 < a3)
    {
      uint64_t v17 = a2;
      uint64_t v18 = a3;
      while (2)
      {
        switch(v11)
        {
          case 0:
            goto LABEL_17;
          case 1:
            goto LABEL_16;
          case 2:
            goto LABEL_15;
          case 3:
            goto LABEL_14;
          case 4:
            goto LABEL_13;
          default:
            if (v11 >= 5)
            {
              unint64_t v19 = v11 - 3;
              do
              {
                v17[v11] += *v17;
                ++v17;
                --v19;
              }
              while (v19 > 1);
            }
LABEL_13:
            v17[v11] += *v17;
            ++v17;
LABEL_14:
            v17[v11] += *v17;
            ++v17;
LABEL_15:
            v17[v11] += *v17;
            ++v17;
LABEL_16:
            v17[v11] += *v17;
            ++v17;
LABEL_17:
            v18 -= v11;
            if (v18 <= v11) {
              break;
            }
            continue;
        }
        break;
      }
    }
    _TIFFmemcpy((void *)result, a2, a3);
    if (v16 >= 1)
    {
      uint64_t v20 = 0;
      if (v12 <= 1) {
        uint64_t v21 = 1;
      }
      else {
        uint64_t v21 = v12;
      }
      do
      {
        uint64_t v22 = v21;
        int32x4_t v23 = a2;
        unsigned int v24 = v12 - 1;
        do
        {
          *v23++ = v15[v20 + v16 * v24--];
          --v22;
        }
        while (v22);
        ++v20;
        a2 += v12;
      }
      while (v20 != v16);
    }
    _TIFFfreeExt(a1, v15);
    return 1;
  }
  return result;
}

uint64_t horDiff8(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8x8_t a9, uint8x8_t a10)
{
  uint64_t v10 = *(void *)(*(void *)(a1 + 1096) + 8);
  if (a3 % v10)
  {
    TIFFErrorExtR(a1, "horDiff8", "%s", a4, a5, a6, a7, a8, (char)"(cc%stride)!=0");
    return 0;
  }
  else
  {
    uint64_t v12 = a3 - v10;
    if (a3 > v10)
    {
      if (v10 == 4)
      {
        __int32 v22 = *(_DWORD *)a2;
        uint64_t v21 = (__int32 *)(a2 + 4);
        a9.i32[0] = v22;
        int16x8_t v23 = (int16x8_t)vmovl_u8(a9);
        uint64_t v24 = v12 + 4;
        do
        {
          a10.i32[0] = *v21;
          a10 = (uint8x8_t)vmovl_u8(a10).u64[0];
          *(int16x4_t *)v23.i8 = vsub_s16((int16x4_t)a10, *(int16x4_t *)v23.i8);
          *v21++ = vmovn_s16(v23).u32[0];
          v24 -= 4;
          *(uint8x8_t *)v23.i8 = a10;
        }
        while (v24 > 4);
      }
      else if (v10 == 3)
      {
        char v13 = *a2;
        char v14 = a2[1];
        uint64_t v15 = v12 + 3;
        uint64_t v16 = a2 + 5;
        char v17 = a2[2];
        do
        {
          char v18 = *(v16 - 2);
          *(v16 - 2) = v18 - v13;
          char v19 = *(v16 - 1);
          *(v16 - 1) = v19 - v14;
          char v20 = *v16;
          v15 -= 3;
          *v16 -= v17;
          v16 += 3;
          char v13 = v18;
          char v14 = v19;
          char v17 = v20;
        }
        while (v15 > 3);
      }
      else
      {
        int16x8_t v25 = &a2[v12 - 1];
        do
        {
          if (v10)
          {
            if (v10 != 1)
            {
              if (v10 != 2)
              {
                if (v10 >= 5)
                {
                  uint64_t v26 = 0;
                  do
                  {
                    v25[v10 + v26] -= v25[v26];
                    --v26;
                  }
                  while ((unint64_t)(v10 + v26 - 3) > 1);
                  v25 += v26;
                }
                v25[v10] -= *v25;
                char v28 = *(v25 - 1);
                double v27 = v25 - 1;
                v27[v10] -= v28;
                int16x8_t v25 = v27 - 1;
              }
              v25[v10] -= *v25;
              --v25;
            }
            v25[v10] -= *v25;
            --v25;
          }
          BOOL v29 = v12 <= v10;
          v12 -= v10;
        }
        while (!v29);
      }
    }
    return 1;
  }
}

uint64_t horDiff16(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 1096) + 8);
  if (a3 >= 0) {
    uint64_t v9 = a3;
  }
  else {
    uint64_t v9 = a3 + 1;
  }
  if (a3 % (2 * v8))
  {
    TIFFErrorExtR(a1, "horDiff8", "%s", a4, a5, a6, a7, a8, (char)"(cc%(2*stride))!=0");
    return 0;
  }
  else
  {
    uint64_t v11 = v9 >> 1;
    BOOL v12 = v11 <= v8;
    uint64_t v13 = v11 - v8;
    if (!v12)
    {
      char v14 = (_WORD *)(a2 + 2 * v13 - 2);
      while (2)
      {
        switch(v8)
        {
          case 0:
            goto LABEL_16;
          case 1:
            goto LABEL_15;
          case 2:
            goto LABEL_14;
          case 3:
            goto LABEL_13;
          case 4:
            goto LABEL_12;
          default:
            if (v8 >= 5)
            {
              unint64_t v15 = v8 - 3;
              do
              {
                v14[v8] -= *v14;
                --v14;
                --v15;
              }
              while (v15 > 1);
            }
LABEL_12:
            v14[v8] -= *v14;
            --v14;
LABEL_13:
            v14[v8] -= *v14;
            --v14;
LABEL_14:
            v14[v8] -= *v14;
            --v14;
LABEL_15:
            v14[v8] -= *v14;
            --v14;
LABEL_16:
            BOOL v12 = v13 <= v8;
            v13 -= v8;
            if (!v12) {
              continue;
            }
            return 1;
        }
      }
    }
    return 1;
  }
}

uint64_t horDiff32(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 1096) + 8);
  uint64_t v9 = a3 + 3;
  if (a3 >= 0) {
    uint64_t v9 = a3;
  }
  if (a3 % (4 * v8))
  {
    TIFFErrorExtR(a1, "horDiff32", "%s", a4, a5, a6, a7, a8, (char)"(cc%(4*stride))!=0");
    return 0;
  }
  else
  {
    uint64_t v11 = v9 >> 2;
    BOOL v12 = v11 <= v8;
    uint64_t v13 = v11 - v8;
    if (!v12)
    {
      char v14 = (_DWORD *)(a2 + 4 * v13 - 4);
      while (2)
      {
        switch(v8)
        {
          case 0:
            goto LABEL_15;
          case 1:
            goto LABEL_14;
          case 2:
            goto LABEL_13;
          case 3:
            goto LABEL_12;
          case 4:
            goto LABEL_11;
          default:
            if (v8 >= 5)
            {
              unint64_t v15 = v8 - 3;
              do
              {
                v14[v8] -= *v14;
                --v14;
                --v15;
              }
              while (v15 > 1);
            }
LABEL_11:
            v14[v8] -= *v14;
            --v14;
LABEL_12:
            v14[v8] -= *v14;
            --v14;
LABEL_13:
            v14[v8] -= *v14;
            --v14;
LABEL_14:
            v14[v8] -= *v14;
            --v14;
LABEL_15:
            BOOL v12 = v13 <= v8;
            v13 -= v8;
            if (!v12) {
              continue;
            }
            return 1;
        }
      }
    }
    return 1;
  }
}

uint64_t horDiff64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(*(void *)(a1 + 1096) + 8);
  uint64_t v9 = a3 + 7;
  if (a3 >= 0) {
    uint64_t v9 = a3;
  }
  if (a3 % (8 * v8))
  {
    TIFFErrorExtR(a1, "horDiff64", "%s", a4, a5, a6, a7, a8, (char)"(cc%(8*stride))!=0");
    return 0;
  }
  else
  {
    uint64_t v11 = v9 >> 3;
    BOOL v12 = v11 <= v8;
    uint64_t v13 = v11 - v8;
    if (!v12)
    {
      char v14 = (void *)(a2 + 8 * v13 - 8);
      while (2)
      {
        switch(v8)
        {
          case 0:
            goto LABEL_15;
          case 1:
            goto LABEL_14;
          case 2:
            goto LABEL_13;
          case 3:
            goto LABEL_12;
          case 4:
            goto LABEL_11;
          default:
            if (v8 >= 5)
            {
              unint64_t v15 = v8 - 3;
              do
              {
                v14[v8] -= *v14;
                --v14;
                --v15;
              }
              while (v15 > 1);
            }
LABEL_11:
            v14[v8] -= *v14;
            --v14;
LABEL_12:
            v14[v8] -= *v14;
            --v14;
LABEL_13:
            v14[v8] -= *v14;
            --v14;
LABEL_14:
            v14[v8] -= *v14;
            --v14;
LABEL_15:
            BOOL v12 = v13 <= v8;
            v13 -= v8;
            if (!v12) {
              continue;
            }
            return 1;
        }
      }
    }
    return 1;
  }
}

uint64_t PredictorEncodeRow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 1096);
  if (!v4) {
    PredictorEncodeRow_cold_1();
  }
  uint64_t v5 = *(uint64_t (**)(void))(v4 + 48);
  if (!v5) {
    PredictorEncodeRow_cold_2();
  }
  if (!*(void *)(v4 + 24)) {
    PredictorEncodeRow_cold_3();
  }
  uint64_t result = v5();
  if (result)
  {
    uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v4 + 24);
    return v11(a1, a2, a3, a4);
  }
  return result;
}

uint64_t PredictorEncodeTile(void *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (void *)a1[137];
  if (!v8) {
    PredictorEncodeTile_cold_1();
  }
  if (!v8[6]) {
    PredictorEncodeTile_cold_2();
  }
  if (!v8[5]) {
    PredictorEncodeTile_cold_3();
  }
  uint64_t v13 = (char *)_TIFFmallocExt(a1, a3, a3, a4, a5, a6, a7, a8);
  if (!v13)
  {
    TIFFErrorExtR((uint64_t)a1, "PredictorEncodeTile", "Out of memory allocating %lld byte temp buffer.", v14, v15, v16, v17, v18, a3);
    return 0;
  }
  char v19 = v13;
  memcpy(v13, a2, a3);
  uint64_t v25 = v8[2];
  if (v25 <= 0) {
    PredictorEncodeTile_cold_4();
  }
  if (a3 % v25)
  {
    TIFFErrorExtR((uint64_t)a1, "PredictorEncodeTile", "%s", v20, v21, v22, v23, v24, (char)"(cc0%rowsize)!=0");
    _TIFFfreeExt((uint64_t)a1, v19);
    return 0;
  }
  if (a3 >= 1)
  {
    double v27 = v19;
    uint64_t v28 = a3;
    do
    {
      ((void (*)(void *, char *, uint64_t))v8[6])(a1, v27, v25);
      v28 -= v25;
      v27 += v25;
    }
    while (v28 > 0);
  }
  uint64_t v29 = ((uint64_t (*)(void *, char *, uint64_t, uint64_t))v8[5])(a1, v19, a3, a4);
  _TIFFfreeExt((uint64_t)a1, v19);
  return v29;
}

uint64_t swabHorDiff16(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = horDiff16(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    if (a3 >= 0) {
      uint64_t v11 = a3;
    }
    else {
      uint64_t v11 = a3 + 1;
    }
    TIFFSwabArrayOfShort(a2, v11 >> 1);
    return 1;
  }
  return result;
}

uint64_t swabHorDiff32(uint64_t a1, __int32 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = horDiff32(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    TIFFSwabArrayOfLong(a2, a3 / 4, v11);
    return 1;
  }
  return result;
}

uint64_t swabHorDiff64(uint64_t a1, int8x8_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = horDiff64(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    TIFFSwabArrayOfLong8(a2, a3 / 8);
    return 1;
  }
  return result;
}

uint64_t fpDiff(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(*(void *)(a1 + 1096) + 8);
  unint64_t v10 = *(unsigned __int16 *)(a1 + 116);
  uint64_t v11 = v10 >> 3;
  if (a3 % (uint64_t)(v9 * (v10 >> 3)))
  {
    TIFFErrorExtR(a1, "fpDiff", "%s", a4, a5, a6, a7, a8, (char)"(cc%(bps*stride))!=0");
    return 0;
  }
  else
  {
    int64_t v13 = a3;
    uint64_t result = (uint64_t)_TIFFmallocExt((void *)a1, a3, a3, a4, a5, a6, a7, a8);
    if (result)
    {
      uint64_t v15 = (char *)result;
      uint64_t v16 = v13 / v11;
      _TIFFmemcpy((void *)result, a2, v13);
      if (v13 / v11 >= 1)
      {
        uint64_t v17 = 0;
        if (v11 <= 1) {
          uint64_t v18 = 1;
        }
        else {
          uint64_t v18 = v11;
        }
        char v19 = v15;
        do
        {
          if (v10 >= 8)
          {
            uint64_t v20 = v18;
            uint64_t v21 = v19;
            unsigned int v22 = v11 - 1;
            do
            {
              char v23 = *v21++;
              a2[v17 + v16 * v22--] = v23;
              --v20;
            }
            while (v20);
          }
          ++v17;
          v19 += v11;
        }
        while (v17 != v16);
      }
      _TIFFfreeExt(a1, v15);
      if (v9 < v13)
      {
        uint64_t v24 = &a2[v13 + ~v9];
        while (2)
        {
          switch(v9)
          {
            case 0:
              goto LABEL_24;
            case 1:
              goto LABEL_23;
            case 2:
              goto LABEL_22;
            case 3:
              goto LABEL_21;
            case 4:
              goto LABEL_20;
            default:
              if (v9 >= 5)
              {
                uint64_t v25 = 0;
                do
                {
                  v24[v9 + v25] -= v24[v25];
                  --v25;
                }
                while ((unint64_t)(v9 + v25 - 3) > 1);
                v24 += v25;
              }
LABEL_20:
              v24[v9] -= *v24;
              --v24;
LABEL_21:
              v24[v9] -= *v24;
              --v24;
LABEL_22:
              v24[v9] -= *v24;
              --v24;
LABEL_23:
              v24[v9] -= *v24;
              --v24;
LABEL_24:
              v13 -= v9;
              if (v13 <= v9) {
                return 1;
              }
              continue;
          }
        }
      }
      return 1;
    }
  }
  return result;
}

void IIO_Reader_RAD::createReadPlugin()
{
}

{
  operator new();
}

void sub_18872AF5C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C404E2D70ECLL);
  _Unwind_Resume(a1);
}

void sub_18872AFFC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C404E2D70ECLL);
  _Unwind_Resume(a1);
}

BOOL IIO_Reader_RAD::testHeader(uint64_t a1, unsigned char *a2)
{
  return *a2 == 35
      && a2[1] == 63
      && (a2[2] == 82
       && a2[3] == 65
       && a2[4] == 68
       && a2[5] == 73
       && a2[6] == 65
       && a2[7] == 78
       && a2[8] == 67
       && a2[9] == 69
       || a2[2] == 82 && a2[3] == 71 && a2[4] == 66 && a2[5] == 69);
}

uint64_t IIO_Reader_RAD::compareOptions(IIO_Reader_RAD *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  memset(v8, 0, sizeof(v8));
  IIODictionary::IIODictionary((IIODictionary *)v8, a2);
  memset(v7, 0, sizeof(v7));
  IIODictionary::IIODictionary((IIODictionary *)v7, a3);
  BOOL BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v8, @"kCGImageSourceShouldAllowFloat");
  uint64_t v5 = BoolForKey ^ IIODictionary::getBoolForKey((IIODictionary *)v7, @"kCGImageSourceShouldAllowFloat") ^ 1u;
  IIODictionary::~IIODictionary((IIODictionary *)v7);
  IIODictionary::~IIODictionary((IIODictionary *)v8);
  return v5;
}

void sub_18872B168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

BOOL _cg_TIFFWriteDirectory(uint64_t a1)
{
  return TIFFWriteDirectorySec(a1, 1, 1u, 0);
}

BOOL TIFFWriteDirectorySec(uint64_t a1, int a2, unsigned int a3, void *a4)
{
  if (!*(_DWORD *)(a1 + 12)) {
    return 1;
  }
  _TIFFFillStriles(a1);
  if (!a3) {
    goto LABEL_13;
  }
  int v15 = *(_DWORD *)(a1 + 16);
  if ((v15 & 0x1000) != 0)
  {
    *(_DWORD *)(a1 + 16) = v15 & 0xFFFFEFFF;
    if (!(*(unsigned int (**)(uint64_t))(a1 + 1000))(a1))
    {
      uint64_t v183 = "Error post-encoding before directory write";
LABEL_420:
      TIFFErrorExtR(a1, "TIFFWriteDirectorySec", v183, v9, v10, (uint64_t)v11, v12, v13, v225);
      return 0;
    }
  }
  (*(void (**)(uint64_t))(a1 + 1056))(a1);
  int v17 = *(_DWORD *)(a1 + 16);
  if (*(uint64_t *)(a1 + 1160) < 1 || (v17 & 0x40) == 0) {
    goto LABEL_9;
  }
  if (!TIFFFlushData1(a1, v16, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13))
  {
    uint64_t v183 = "Error flushing data before directory write";
    goto LABEL_420;
  }
  int v17 = *(_DWORD *)(a1 + 16);
LABEL_9:
  if ((v17 & 0x200) != 0)
  {
    uint64_t v18 = *(char **)(a1 + 1120);
    if (v18)
    {
      _TIFFfreeExt(a1, v18);
      *(void *)(a1 + 1160) = 0;
      uint8x8_t v14 = 0;
      *(_OWORD *)(a1 + 1120) = 0u;
      *(_OWORD *)(a1 + 1136) = 0u;
      int v17 = *(_DWORD *)(a1 + 16);
    }
  }
  *(_DWORD *)(a1 + 16) = v17 & 0xFFFFFFAF;
LABEL_13:
  unsigned int v226 = a3;
  char v19 = (_DWORD *)(a1 + 72);
  if ((*(unsigned char *)(a1 + 72) & 0x80) != 0 && *(unsigned __int16 *)(a1 + 120) == 32946) {
    TIFFWarningExtR(a1, "TIFFWriteDirectorySec", "Creating TIFF with legacy Deflate codec identifier, COMPRESSION_ADOBE_DEFLATE is more widely supported", v9, v10, (uint64_t)v11, v12, v13, v225);
  }
  uint64_t v20 = 0;
  LODWORD(v21) = 0;
  v229 = a4;
  int v230 = a2;
  while (1)
  {
    unsigned int v228 = v21;
    unsigned int v231 = 0;
    if (v20)
    {
      if (!a2) {
        goto LABEL_211;
      }
    }
    else
    {
      *(void *)(a1 + 432) = 0;
      if (!a2) {
        goto LABEL_211;
      }
    }
    int v22 = *v19;
    if ((*v19 & 2) != 0)
    {
      if (!TIFFWriteDirectoryTagShortLong(a1, &v231, v20, 256, *(_DWORD *)(a1 + 88), v14)
        || !TIFFWriteDirectoryTagShortLong(a1, &v231, v20, 257, *(_DWORD *)(a1 + 92), v23))
      {
        goto LABEL_428;
      }
      int v22 = *v19;
    }
    if ((v22 & 4) != 0)
    {
      if (!TIFFWriteDirectoryTagShortLong(a1, &v231, v20, 322, *(_DWORD *)(a1 + 100), v14)
        || !TIFFWriteDirectoryTagShortLong(a1, &v231, v20, 323, *(_DWORD *)(a1 + 104), v24))
      {
        goto LABEL_428;
      }
      int v22 = *v19;
    }
    if ((v22 & 8) != 0)
    {
      if (!TIFFWriteDirectoryTagRational(a1, &v231, v20, 282, v10, (uint64_t)v11, v12, v13, *(float *)(a1 + 160))|| !TIFFWriteDirectoryTagRational(a1, &v231, v20, 283, v25, v26, v27, v28, *(float *)(a1 + 164)))
      {
        goto LABEL_428;
      }
      int v22 = *v19;
    }
    if ((v22 & 0x10) != 0)
    {
      if (!TIFFWriteDirectoryTagRational(a1, &v231, v20, 286, v10, (uint64_t)v11, v12, v13, *(float *)(a1 + 172))|| !TIFFWriteDirectoryTagRational(a1, &v231, v20, 287, v29, v30, v31, v32, *(float *)(a1 + 176)))
      {
        goto LABEL_428;
      }
      int v22 = *v19;
    }
    if ((v22 & 0x20) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedLong(a1, &v231, v20, 254, *(_DWORD *)(a1 + 112), v14)) {
        goto LABEL_428;
      }
      int v22 = *v19;
    }
    if ((v22 & 0x40) != 0)
    {
      if (!TIFFWriteDirectoryTagShortPerSample(a1, &v231, v20, 258, *(_WORD *)(a1 + 116), (uint64_t)v11, v12, v13))goto LABEL_428; {
      int v22 = *v19;
      }
    }
    if ((v22 & 0x80) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 259, *(_WORD *)(a1 + 120))) {
        goto LABEL_428;
      }
      int v22 = *v19;
    }
    if ((v22 & 0x100) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 262, *(_WORD *)(a1 + 122))) {
        goto LABEL_428;
      }
      int v22 = *v19;
    }
    if ((v22 & 0x200) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 263, *(_WORD *)(a1 + 124))) {
        goto LABEL_428;
      }
      int v22 = *v19;
    }
    if ((v22 & 0x400) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 266, *(_WORD *)(a1 + 126))) {
        goto LABEL_428;
      }
      int v22 = *v19;
    }
    if ((v22 & 0x8000) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 274, *(_WORD *)(a1 + 128))) {
        goto LABEL_428;
      }
      int v22 = *v19;
    }
    if ((v22 & 0x10000) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 277, *(_WORD *)(a1 + 130))) {
        goto LABEL_428;
      }
      int v22 = *v19;
    }
    if ((v22 & 0x20000) != 0)
    {
      if (!TIFFWriteDirectoryTagShortLong(a1, &v231, v20, 278, *(_DWORD *)(a1 + 132), v14)) {
        goto LABEL_428;
      }
      int v22 = *v19;
    }
    if ((v22 & 0x40000) != 0)
    {
      if (!TIFFWriteDirectoryTagShortPerSample(a1, &v231, v20, 280, *(_WORD *)(a1 + 136), (uint64_t)v11, v12, v13))goto LABEL_428; {
      int v22 = *v19;
      }
    }
    if ((v22 & 0x80000) != 0)
    {
      if (!TIFFWriteDirectoryTagShortPerSample(a1, &v231, v20, 281, *(_WORD *)(a1 + 138), (uint64_t)v11, v12, v13))goto LABEL_428; {
      int v22 = *v19;
      }
    }
    if ((v22 & 0x100000) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 284, *(_WORD *)(a1 + 170))) {
        goto LABEL_428;
      }
      int v22 = *v19;
    }
    if ((v22 & 0x400000) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 296, *(_WORD *)(a1 + 168))) {
        goto LABEL_428;
      }
      int v22 = *v19;
    }
    if ((v22 & 0x800000) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShortArray(a1, &v231, v20, 297, 2, a1 + 180)) {
        goto LABEL_428;
      }
      int v22 = *v19;
    }
    if ((v22 & 0x1000000) != 0)
    {
      uint64_t v33 = (*(unsigned char *)(a1 + 17) & 4) != 0 ? 325 : 279;
      if (!TIFFWriteDirectoryTagLongLong8Array(a1, &v231, v20, v33, *(unsigned int *)(a1 + 228), *(int8x8_t **)(a1 + 240), v12, v13))
      {
LABEL_428:
        if (v20) {
          goto LABEL_429;
        }
        return 0;
      }
    }
    if ((*((unsigned char *)v19 + 3) & 2) != 0)
    {
      if ((*(unsigned char *)(a1 + 17) & 4) != 0)
      {
        uint64_t v34 = *(unsigned int *)(a1 + 228);
        uint64_t v11 = *(int8x8_t **)(a1 + 232);
        uint64_t v35 = a1;
        double v36 = v20;
        uint64_t v37 = 324;
      }
      else
      {
        uint64_t v11 = *(int8x8_t **)(a1 + 232);
        if (!v11) {
          goto LABEL_90;
        }
        uint64_t v34 = *(unsigned int *)(a1 + 228);
        uint64_t v35 = a1;
        double v36 = v20;
        uint64_t v37 = 273;
      }
      if (!TIFFWriteDirectoryTagLongLong8Array(v35, &v231, v36, v37, v34, v11, v12, v13)) {
        goto LABEL_428;
      }
    }
LABEL_90:
    int v38 = *v19;
    if ((*v19 & 0x4000000) == 0) {
      goto LABEL_95;
    }
    CGRect v39 = v19;
    __int16 v40 = *(_WORD *)(a1 + 116);
    unint64_t v41 = 2 * (3 << v40);
    if (v20)
    {
      uint64_t v42 = (char *)_TIFFmallocExt((void *)a1, v41, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
      if (!v42)
      {
        v209 = "TIFFWriteDirectoryTagColormap";
        goto LABEL_474;
      }
      uint64_t v48 = v42;
      _TIFFmemcpy(v42, *(const void **)(a1 + 184), 2 * (1 << v40));
      _TIFFmemcpy(&v48[2 * (1 << v40)], *(const void **)(a1 + 192), 2 * (1 << v40));
      _TIFFmemcpy(&v48[2 * (2 << v40)], *(const void **)(a1 + 200), 2 * (1 << v40));
      int v49 = TIFFWriteDirectoryTagCheckedShortArray(a1, &v231, v20, 320, (3 << v40), (uint64_t)v48);
      _TIFFfreeExt(a1, v48);
      if (!v49) {
        goto LABEL_429;
      }
      char v19 = v39;
      int v38 = *v39;
LABEL_95:
      if (v38 < 0) {
        goto LABEL_96;
      }
      goto LABEL_104;
    }
    unint64_t v50 = 4;
    if ((*(unsigned char *)(a1 + 18) & 8) != 0) {
      unint64_t v50 = 8;
    }
    if (v41 > v50) {
      *(void *)(a1 + 432) += v41;
    }
    ++v231;
    char v19 = v39;
    if (v38 < 0)
    {
LABEL_96:
      if (*(_WORD *)(a1 + 212))
      {
        v233.i16[0] = 0;
        __at_texel_region_t src = 0;
        _cg_TIFFGetFieldDefaulted(a1, 338, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13, &v233);
        if (!TIFFWriteDirectoryTagCheckedShortArray(a1, &v231, v20, 338, v233.u16[0], __src)) {
          goto LABEL_428;
        }
      }
    }
LABEL_104:
    int v51 = *(_DWORD *)(a1 + 76);
    if (v51)
    {
      if (!TIFFWriteDirectoryTagShortPerSample(a1, &v231, v20, 339, *(_WORD *)(a1 + 118), (uint64_t)v11, v12, v13))goto LABEL_428; {
      int v51 = *(_DWORD *)(a1 + 76);
      }
    }
    if ((v51 & 2) != 0)
    {
      if (!TIFFWriteDirectoryTagSampleformatArray(a1, &v231, v20, 340, *(unsigned __int16 *)(a1 + 130), *(void *)(a1 + 144), v12, v13))goto LABEL_428; {
      int v51 = *(_DWORD *)(a1 + 76);
      }
    }
    if ((v51 & 4) != 0)
    {
      if (!TIFFWriteDirectoryTagSampleformatArray(a1, &v231, v20, 341, *(unsigned __int16 *)(a1 + 130), *(void *)(a1 + 152), v12, v13))goto LABEL_428; {
      int v51 = *(_DWORD *)(a1 + 76);
      }
    }
    if ((v51 & 8) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedLong(a1, &v231, v20, 32997, *(_DWORD *)(a1 + 96), v14)) {
        goto LABEL_428;
      }
      int v51 = *(_DWORD *)(a1 + 76);
    }
    if ((v51 & 0x10) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedLong(a1, &v231, v20, 32998, *(_DWORD *)(a1 + 108), v14)) {
        goto LABEL_428;
      }
      int v51 = *(_DWORD *)(a1 + 76);
    }
    if ((v51 & 0x20) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShortArray(a1, &v231, v20, 321, 2, a1 + 208)) {
        goto LABEL_428;
      }
      int v51 = *(_DWORD *)(a1 + 76);
    }
    if ((v51 & 0x80) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShortArray(a1, &v231, v20, 530, 2, a1 + 336)) {
        goto LABEL_428;
      }
      int v51 = *(_DWORD *)(a1 + 76);
    }
    if ((v51 & 0x100) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 531, *(_WORD *)(a1 + 340))) {
        goto LABEL_428;
      }
      int v51 = *(_DWORD *)(a1 + 76);
    }
    if ((v51 & 0x200) != 0)
    {
      if (!TIFFWriteDirectoryTagRationalArray(a1, &v231, v20, 532, 6, *(void *)(a1 + 368), v12, v13))goto LABEL_428; {
      int v51 = *(_DWORD *)(a1 + 76);
      }
    }
    if ((v51 & 0x1000) != 0)
    {
      unint64_t v52 = 0;
      __int16 v53 = *(_WORD *)(a1 + 116);
      uint64_t v54 = 1 << v53;
      int v55 = *(unsigned __int16 *)(a1 + 130) - *(unsigned __int16 *)(a1 + 212);
      do
      {
        if (!*(void *)(a1 + 8 * v52 + 344))
        {
          TIFFWarningExtR(a1, "TIFFWriteDirectoryTagTransferfunction", "Too few TransferFunctions provided. Tag not written to file", v9, v10, (uint64_t)v11, v12, v13, v225);
          goto LABEL_156;
        }
        if (v55 < 2) {
          break;
        }
        BOOL v56 = v52++ > 1;
      }
      while (!v56);
      at_size_t v57 = v19;
      if (v55 < 2)
      {
        int v58 = 1;
      }
      else if (_TIFFmemcmp(*(const void **)(a1 + 344), *(const void **)(a1 + 360), 2 * v54))
      {
        int v58 = 3;
      }
      else if (_TIFFmemcmp(*(const void **)(a1 + 344), *(const void **)(a1 + 352), 2 * v54))
      {
        int v58 = 3;
      }
      else
      {
        int v58 = 1;
      }
      unint64_t v59 = 2 * (v58 << v53);
      if (v20)
      {
        unint64_t v60 = (char *)_TIFFmallocExt((void *)a1, v59, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
        if (!v60)
        {
          v209 = "TIFFWriteDirectoryTagTransferfunction";
LABEL_474:
          TIFFErrorExtR(a1, v209, "Out of memory", v43, v44, v45, v46, v47, v225);
          goto LABEL_429;
        }
        uint64_t v61 = v60;
        _TIFFmemcpy(v60, *(const void **)(a1 + 344), 2 * (1 << v53));
        if (v58 != 1)
        {
          _TIFFmemcpy(&v61[2 * (1 << v53)], *(const void **)(a1 + 352), 2 * (1 << v53));
          _TIFFmemcpy(&v61[2 * (2 << v53)], *(const void **)(a1 + 360), 2 * (1 << v53));
        }
        int v62 = TIFFWriteDirectoryTagCheckedShortArray(a1, &v231, v20, 301, (v58 << v53), (uint64_t)v61);
        _TIFFfreeExt(a1, v61);
        char v19 = v57;
        if (!v62) {
          goto LABEL_429;
        }
      }
      else
      {
        unint64_t v63 = 4;
        if ((*(unsigned char *)(a1 + 18) & 8) != 0) {
          unint64_t v63 = 8;
        }
        if (v59 > v63) {
          *(void *)(a1 + 432) += v59;
        }
        ++v231;
        char v19 = v57;
      }
    }
LABEL_156:
    int v64 = *(_DWORD *)(a1 + 76);
    if ((v64 & 0x4000) != 0)
    {
      if (!TIFFWriteDirectoryTagAscii(a1, &v231, v20, 333, *(unsigned int *)(a1 + 376), *(void *)(a1 + 384)))goto LABEL_428; {
      int v64 = *(_DWORD *)(a1 + 76);
      }
    }
    if ((v64 & 0x40000) != 0)
    {
      if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, 334, *(_WORD *)(a1 + 392))) {
        goto LABEL_428;
      }
      int v64 = *(_DWORD *)(a1 + 76);
    }
    if ((v64 & 0x20000) != 0)
    {
      uint64_t v10 = *(unsigned __int16 *)(a1 + 320);
      if (*(_WORD *)(a1 + 320))
      {
        uint64_t v65 = *(void *)(a1 + 904);
        if ((*(unsigned char *)(a1 + 18) & 8) != 0)
        {
          int v74 = TIFFWriteDirectoryTagCheckedIfd8Array(a1, &v231, v20, 330, v10, *(int8x8_t **)(a1 + 328));
        }
        else
        {
          unint64_t v66 = (__int32 *)_TIFFmallocExt((void *)a1, 4 * *(unsigned __int16 *)(a1 + 320), (uint64_t)v8, v9, *(unsigned __int16 *)(a1 + 320), (uint64_t)v11, v12, v13);
          if (!v66)
          {
            v206 = "TIFFWriteDirectoryTagSubifd";
            goto LABEL_476;
          }
          unint64_t v68 = (char *)v66;
          uint64_t v69 = *(unsigned __int16 *)(a1 + 320);
          if (*(_WORD *)(a1 + 320))
          {
            unsigned int v70 = 0;
            uint64_t v71 = *(uint64_t **)(a1 + 328);
            uint64_t v72 = v66;
            do
            {
              if (!v71) {
                TIFFWriteDirectorySec_cold_14();
              }
              uint64_t v73 = *v71;
              if (HIDWORD(*v71))
              {
                TIFFErrorExtR(a1, "TIFFWriteDirectoryTagSubifd", "Illegal value for SubIFD tag", v9, v69, (uint64_t)v11, v12, v13, v225);
                goto LABEL_426;
              }
              ++v71;
              *v72++ = v73;
              ++v70;
            }
            while (v70 < v69);
          }
          int v74 = TIFFWriteDirectoryTagCheckedIfdArray(a1, &v231, v20, 330, v69, v66, v67);
          _TIFFfreeExt(a1, v68);
        }
        if (v20)
        {
          if (!v74) {
            goto LABEL_429;
          }
          *(_DWORD *)(a1 + 16) |= 0x2000u;
          int v75 = *(unsigned __int16 *)(a1 + 320);
          *(_WORD *)(a1 + 912) = v75;
          if (v75 == 1) {
            uint64_t v76 = 0;
          }
          else {
            uint64_t v76 = v65;
          }
          *(void *)(a1 + 920) = v76;
        }
        else if (!v74)
        {
          return 0;
        }
      }
    }
    if ((*(unsigned char *)(a1 + 78) & 0x20) != 0) {
      TIFFWarning("TIFFWriteRichIPTCTag", "Unimplemented.", (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13, v225);
    }
    if (*(void *)(a1 + 1264))
    {
      uint64_t v77 = 0;
      unsigned int v78 = 1;
      do
      {
        __int32 v79 = *(unsigned int **)(*(void *)(a1 + 1256) + 8 * v77);
        unint64_t v80 = *((unsigned __int16 *)v79 + 12);
        if v80 >= 0x42 && ((*(_DWORD *)((char *)v19 + ((v80 >> 3) & 0x1FFC)) >> v80))
        {
          int v81 = v79[5];
          if (v81 > 5)
          {
            if (v81 == 6)
            {
              LODWORD(__src) = 0;
              if (v79[2] != 4) {
                TIFFWriteDirectorySec_cold_10();
              }
              if (*((_WORD *)v79 + 2) != 1) {
                TIFFWriteDirectorySec_cold_9();
              }
              if (*((unsigned char *)v79 + 27)) {
                TIFFWriteDirectorySec_cold_8();
              }
              _cg_TIFFGetField((void *)a1, *v79, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13, (uint64_t)&__src);
              if (!TIFFWriteDirectoryTagCheckedLong(a1, &v231, v20, *(unsigned __int16 *)v79, __src, v83)) {
                goto LABEL_428;
              }
            }
            else
            {
              if (v81 != 40)
              {
LABEL_449:
                char v200 = TIFFFieldTag(v79);
                TIFFErrorExtR(a1, "TIFFWriteDirectorySec", "Cannot write tag %u (%s)", v201, v202, v203, v204, v205, v200);
                goto LABEL_478;
              }
              v233.i32[0] = 0;
              __at_texel_region_t src = 0;
              if (v79[2] != 7) {
                TIFFWriteDirectorySec_cold_13();
              }
              if (*((__int16 *)v79 + 2) != -3) {
                TIFFWriteDirectorySec_cold_12();
              }
              if (*((unsigned char *)v79 + 27) != 1) {
                TIFFWriteDirectorySec_cold_11();
              }
              _cg_TIFFGetField((void *)a1, *v79, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13, (uint64_t)&v233);
              if (!TIFFWriteDirectoryTagUndefinedArray(a1, &v231, v20, *(unsigned __int16 *)v79, v233.u32[0], __src))goto LABEL_428; {
            }
              }
          }
          else if (v81 == 1)
          {
            __at_texel_region_t src = 0;
            if (v79[2] != 2) {
              TIFFWriteDirectorySec_cold_4();
            }
            if (*((__int16 *)v79 + 2) != -1) {
              TIFFWriteDirectorySec_cold_3();
            }
            if (*((unsigned char *)v79 + 27)) {
              TIFFWriteDirectorySec_cold_2();
            }
            _cg_TIFFGetField((void *)a1, *v79, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13, (uint64_t)&__src);
            size_t v82 = strlen((const char *)__src);
            if (!TIFFWriteDirectoryTagAscii(a1, &v231, v20, *(unsigned __int16 *)v79, v82, __src)) {
              goto LABEL_428;
            }
          }
          else
          {
            if (v81 != 4) {
              goto LABEL_449;
            }
            LOWORD(__src) = 0;
            if (v79[2] != 3) {
              TIFFWriteDirectorySec_cold_7();
            }
            if (*((_WORD *)v79 + 2) != 1) {
              TIFFWriteDirectorySec_cold_6();
            }
            if (*((unsigned char *)v79 + 27)) {
              TIFFWriteDirectorySec_cold_5();
            }
            _cg_TIFFGetField((void *)a1, *v79, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13, (uint64_t)&__src);
            if (!TIFFWriteDirectoryTagCheckedShort(a1, &v231, v20, *(unsigned __int16 *)v79, __src)) {
              goto LABEL_428;
            }
          }
        }
        uint64_t v77 = v78;
        BOOL v56 = *(void *)(a1 + 1264) > (unint64_t)v78++;
      }
      while (v56);
    }
LABEL_211:
    if (*(_DWORD *)(a1 + 408))
    {
      uint64_t v84 = 0;
      v227 = v19;
      while (1)
      {
        uint64_t v85 = *(void *)(a1 + 416);
        char v86 = (unsigned int *)(v85 + 24 * v84);
        uint64_t v87 = *(void *)v86;
        uint64_t v88 = **(unsigned __int16 **)v86;
        uint64_t v89 = v86[2];
        switch(*(_DWORD *)(*(void *)v86 + 8))
        {
          case 1:
            if (!TIFFWriteDirectoryTagByteArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(void *)(v85 + 24 * v84 + 16)))goto LABEL_428; {
            goto LABEL_321;
            }
          case 2:
            if (!TIFFWriteDirectoryTagAscii(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(void *)(v85 + 24 * v84 + 16)))goto LABEL_428; {
            goto LABEL_321;
            }
          case 3:
            if (!TIFFWriteDirectoryTagCheckedShortArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(void *)(v85 + 24 * v84 + 16)))goto LABEL_428; {
            goto LABEL_321;
            }
          case 4:
            if (!TIFFWriteDirectoryTagCheckedLongArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(__int32 **)(v85 + 24 * v84 + 16), v14))goto LABEL_428; {
            goto LABEL_321;
            }
          case 5:
            int Size = TIFFFieldSetGetSize(v87);
            uint64_t v91 = *(void *)(a1 + 416) + 24 * v84;
            uint64_t v92 = *(double **)(v91 + 16);
            if (Size != 8)
            {
              int v134 = Size;
              if (!TIFFWriteDirectoryTagRationalArray(a1, &v231, v20, v88, v89, *(void *)(v91 + 16), v12, v13))goto LABEL_428; {
              if (v134 != 4)
              }
                TIFFErrorExtR(a1, "TIFFLib: _TIFFWriteDirectorySec()", "Rational2Double: .set_field_type is not 4 but %d", v9, v10, (uint64_t)v11, v12, v13, v134);
              goto LABEL_321;
            }
            unint64_t v93 = 4 * (2 * v89);
            if (!v20)
            {
              unint64_t v148 = 4;
              if ((*(unsigned char *)(a1 + 18) & 8) != 0) {
                unint64_t v148 = 8;
              }
              if (v93 > v148) {
                *(void *)(a1 + 432) += v93;
              }
              ++v231;
              goto LABEL_321;
            }
            uint64_t v94 = (__int32 *)_TIFFmallocExt((void *)a1, v93, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
            if (!v94)
            {
              v209 = "TIFFWriteDirectoryTagCheckedRationalDoubleArray";
              goto LABEL_474;
            }
            __int16 v97 = v94;
            if (v89)
            {
              int v98 = v89;
              int v99 = v94;
              do
              {
                double v100 = *v92++;
                DoubleToRational(v99, v99 + 1, v100, v95, v43, v44, v45, v46, v47, v225);
                v99 += 2;
                --v98;
              }
              while (v98);
            }
            if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
              TIFFSwabArrayOfLong(v97, (2 * v89), v96);
            }
            uint64_t v101 = (8 * v89);
            uint64_t v102 = a1;
            __int16 v103 = v20;
            uint64_t v104 = v88;
            uint64_t v105 = 5;
            goto LABEL_248;
          case 6:
            if (!TIFFWriteDirectoryTagSbyteArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(void *)(v85 + 24 * v84 + 16)))goto LABEL_428; {
            goto LABEL_321;
            }
          case 7:
            if (!TIFFWriteDirectoryTagUndefinedArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(void *)(v85 + 24 * v84 + 16)))goto LABEL_428; {
            goto LABEL_321;
            }
          case 8:
            if (!TIFFWriteDirectoryTagSshortArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(void *)(v85 + 24 * v84 + 16)))goto LABEL_428; {
            goto LABEL_321;
            }
          case 9:
            if (!TIFFWriteDirectoryTagCheckedSlongArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(__int32 **)(v85 + 24 * v84 + 16), v14))goto LABEL_428; {
            goto LABEL_321;
            }
          case 0xA:
            int v106 = TIFFFieldSetGetSize(v87);
            uint64_t v107 = *(float **)(*(void *)(a1 + 416) + 24 * v84 + 16);
            unint64_t v108 = 4 * (2 * v89);
            if (v106 != 8)
            {
              int v135 = v106;
              if (v20)
              {
                uint64_t v136 = (__int32 *)_TIFFmallocExt((void *)a1, v108, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
                if (!v136)
                {
                  v209 = "TIFFWriteDirectoryTagCheckedSrationalArray";
                  goto LABEL_474;
                }
                uint64_t v138 = v136;
                if (v89)
                {
                  int v139 = v89;
                  uint64_t v140 = v136;
                  do
                  {
                    float v141 = *v107++;
                    DoubleToSrational(v140, v140 + 1, v141);
                    v140 += 2;
                    --v139;
                  }
                  while (v139);
                }
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  TIFFSwabArrayOfLong(v138, (2 * v89), v137);
                }
                int v142 = TIFFWriteDirectoryTagData(a1, &v231, v20, v88, 10, v89, (8 * v89), (uint64_t)v138);
                _TIFFfreeExt(a1, (char *)v138);
                char v19 = v227;
                if (!v142) {
                  goto LABEL_428;
                }
              }
              else
              {
                unint64_t v150 = 4;
                if ((*(unsigned char *)(a1 + 18) & 8) != 0) {
                  unint64_t v150 = 8;
                }
                if (v108 > v150) {
                  *(void *)(a1 + 432) += v108;
                }
                ++v231;
                char v19 = v227;
              }
              if (v135 != 4) {
                TIFFErrorExtR(a1, "TIFFLib: _TIFFWriteDirectorySec()", "Rational2Double: .set_field_type is not 4 but %d", v9, v10, (uint64_t)v11, v12, v13, v135);
              }
              goto LABEL_321;
            }
            if (!v20)
            {
              unint64_t v149 = 4;
              if ((*(unsigned char *)(a1 + 18) & 8) != 0) {
                unint64_t v149 = 8;
              }
              if (v108 > v149) {
                *(void *)(a1 + 432) += v108;
              }
              ++v231;
              char v19 = v227;
              goto LABEL_321;
            }
            uint64_t v109 = (__int32 *)_TIFFmallocExt((void *)a1, v108, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
            if (!v109)
            {
              v209 = "TIFFWriteDirectoryTagCheckedSrationalDoubleArray";
              goto LABEL_474;
            }
            __int16 v97 = v109;
            if (v89)
            {
              int v111 = v89;
              int v112 = v109;
              do
              {
                double v113 = *(double *)v107;
                v107 += 2;
                DoubleToSrational(v112, v112 + 1, v113);
                v112 += 2;
                --v111;
              }
              while (v111);
            }
            if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
              TIFFSwabArrayOfLong(v97, (2 * v89), v110);
            }
            uint64_t v101 = (8 * v89);
            uint64_t v102 = a1;
            __int16 v103 = v20;
            uint64_t v104 = v88;
            uint64_t v105 = 10;
LABEL_248:
            int v114 = TIFFWriteDirectoryTagData(v102, &v231, v103, v104, v105, v89, v101, (uint64_t)v97);
            _TIFFfreeExt(a1, (char *)v97);
            char v19 = v227;
            goto LABEL_294;
          case 0xB:
            if (!TIFFWriteDirectoryTagFloatArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(__int32 **)(v85 + 24 * v84 + 16), v14))goto LABEL_428; {
            goto LABEL_321;
            }
          case 0xC:
            if (!TIFFWriteDirectoryTagDoubleArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(int8x8_t **)(v85 + 24 * v84 + 16)))goto LABEL_428; {
            goto LABEL_321;
            }
          case 0xD:
            if (!TIFFWriteDirectoryTagCheckedIfdArray(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], *(__int32 **)(v85 + 24 * v84 + 16), v14))goto LABEL_428; {
            goto LABEL_321;
            }
          case 0x10:
            unsigned int v115 = *(int8x8_t **)(v85 + 24 * v84 + 16);
            if (!v20)
            {
              uint64_t v143 = a1;
              uint64_t v144 = 0;
LABEL_299:
              int v147 = TIFFWriteDirectoryTagCheckedLong8Array(v143, &v231, v144, **(unsigned __int16 **)v86, v86[2], v115, v12, v13);
              goto LABEL_302;
            }
            if ((*(unsigned char *)(a1 + 18) & 8) != 0)
            {
              uint64_t v143 = a1;
              uint64_t v144 = v20;
              goto LABEL_299;
            }
            int v116 = (__int32 *)_TIFFmallocExt((void *)a1, 4 * v89, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
            if (!v116)
            {
              v209 = "TIFFWriteDirectoryTagLong8Array";
              goto LABEL_474;
            }
            unint64_t v68 = (char *)v116;
            if (v89)
            {
              uint64_t v118 = 0;
              while (1)
              {
                int8x8_t v119 = v115[v118];
                if (HIDWORD(*(void *)&v119)) {
                  break;
                }
                v116[v118++] = v119.i32[0];
                if (v89 == v118) {
                  goto LABEL_262;
                }
              }
              TIFFErrorExtR(a1, "TIFFWriteDirectoryTagLong8Array", "Attempt to write unsigned long value %llu larger than 0xFFFFFFFF for tag %d in Classic TIFF file. TIFF file writing aborted", v43, v44, v45, v46, v47, *(void *)&v115[v118]);
              goto LABEL_426;
            }
LABEL_262:
            int v120 = TIFFWriteDirectoryTagCheckedLongArray(a1, &v231, v20, v88, v89, v116, v117);
LABEL_272:
            int v114 = v120;
            uint64_t v126 = a1;
            int v127 = v68;
            goto LABEL_280;
          case 0x11:
            uint64_t v121 = *(int8x8_t **)(v85 + 24 * v84 + 16);
            if (!v20)
            {
              uint64_t v145 = a1;
              uint64_t v146 = 0;
              goto LABEL_301;
            }
            if ((*(unsigned char *)(a1 + 18) & 8) != 0)
            {
              uint64_t v145 = a1;
              uint64_t v146 = v20;
LABEL_301:
              int v147 = TIFFWriteDirectoryTagCheckedSlong8Array(v145, &v231, v146, **(unsigned __int16 **)v86, v86[2], v121, v12, v13);
LABEL_302:
              if (!v147) {
                goto LABEL_428;
              }
              goto LABEL_321;
            }
            uint64_t v122 = (__int32 *)_TIFFmallocExt((void *)a1, 4 * v89, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
            if (!v122)
            {
              v209 = "TIFFWriteDirectoryTagSlong8Array";
              goto LABEL_474;
            }
            unint64_t v68 = (char *)v122;
            if (v89)
            {
              uint64_t v124 = 0;
              while (1)
              {
                uint64_t v125 = (uint64_t)v121[v124];
                if (v125 >= 0x80000000)
                {
                  TIFFErrorExtR(a1, "TIFFWriteDirectoryTagSlong8Array", "Attempt to write signed long value %lli larger than 0x7FFFFFFF (2147483647) for tag %d in Classic TIFF file. TIFF writing to file aborted", v43, v44, v45, v46, v47, *(void *)&v121[v124]);
                  goto LABEL_426;
                }
                if (v125 <= (uint64_t)0xFFFFFFFF7FFFFFFFLL) {
                  break;
                }
                v122[v124++] = v125;
                if (v89 == v124) {
                  goto LABEL_271;
                }
              }
              TIFFErrorExtR(a1, "TIFFWriteDirectoryTagSlong8Array", "Attempt to write signed long value %lli smaller than 0x80000000 (-2147483648) for tag %d in Classic TIFF file. TIFF writing to file aborted", v43, v44, v45, v46, v47, *(void *)&v121[v124]);
LABEL_426:
              uint64_t v184 = a1;
              unint64_t v185 = v68;
LABEL_427:
              _TIFFfreeExt(v184, v185);
              goto LABEL_428;
            }
LABEL_271:
            int v120 = TIFFWriteDirectoryTagCheckedSlongArray(a1, &v231, v20, v88, v89, v122, v123);
            goto LABEL_272;
          case 0x12:
            unint64_t v128 = *(int8x8_t **)(v85 + 24 * v84 + 16);
            if ((*(unsigned char *)(a1 + 18) & 8) != 0)
            {
              int v114 = TIFFWriteDirectoryTagCheckedIfd8Array(a1, &v231, v20, **(unsigned __int16 **)v86, v86[2], v128);
            }
            else
            {
              uint64_t v129 = (__int32 *)_TIFFmallocExt((void *)a1, 4 * v89, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
              if (!v129)
              {
                v206 = "TIFFWriteDirectoryTagIfdIfd8Array";
                goto LABEL_476;
              }
              uint64_t v131 = v129;
              if (v89)
              {
                uint64_t v132 = 0;
                while (1)
                {
                  int8x8_t v133 = v128[v132];
                  if (HIDWORD(*(void *)&v133)) {
                    break;
                  }
                  v129[v132++] = v133.i32[0];
                  if (v89 == v132) {
                    goto LABEL_279;
                  }
                }
                TIFFErrorExtR(a1, "TIFFWriteDirectoryTagIfdIfd8Array", "Attempt to write value larger than 0xFFFFFFFF in Classic TIFF file.", v9, v10, (uint64_t)v11, v12, v13, v225);
                uint64_t v184 = a1;
                unint64_t v185 = (char *)v131;
                goto LABEL_427;
              }
LABEL_279:
              int v114 = TIFFWriteDirectoryTagCheckedIfdArray(a1, &v231, v20, v88, v89, v129, v130);
              uint64_t v126 = a1;
              int v127 = (char *)v131;
LABEL_280:
              _TIFFfreeExt(v126, v127);
            }
LABEL_294:
            if (!v114) {
              goto LABEL_428;
            }
LABEL_321:
            if (++v84 >= (unint64_t)*(unsigned int *)(a1 + 408)) {
              goto LABEL_322;
            }
            break;
          default:
            TIFFWriteDirectorySec_cold_1();
        }
      }
    }
LABEL_322:
    if (v20) {
      break;
    }
    uint64_t v151 = v231;
    if ((*(_DWORD *)(a1 + 16) & 0x80000) != 0) {
      int v152 = 20;
    }
    else {
      int v152 = 12;
    }
    if ((*(_DWORD *)(a1 + 16) & 0x80000) != 0) {
      int v153 = 16;
    }
    else {
      int v153 = 6;
    }
    *(void *)(a1 + 432) += v153 + v231 * v152;
    uint64_t v154 = (char *)_TIFFmallocExt((void *)a1, 32 * v151, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
    a2 = v230;
    if (!v154)
    {
      uint64_t v183 = "Out of memory";
      goto LABEL_420;
    }
    uint64_t v20 = (unsigned __int16 *)v154;
    if (!v230)
    {
      unint64_t v156 = *(void *)(a1 + 440);
      uint64_t v155 = v229;
      if (!v156 || *(void *)(a1 + 432) > v156)
      {
        *(void *)(a1 + 24) = ((*(uint64_t (**)(void, void, uint64_t))(a1 + 1224))(*(void *)(a1 + 1200), 0, 2)+ 1) & 0xFFFFFFFFFFFFFFFELL;
        if (!v229) {
          goto LABEL_400;
        }
        goto LABEL_399;
      }
      goto LABEL_398;
    }
    uint64_t v155 = v229;
    if (*(void *)(a1 + 24))
    {
      if (*(void *)(a1 + 432) > *(void *)(a1 + 440))
      {
        _TIFFfreeExt(a1, v154);
        return TIFFRewriteDirectorySec(a1, v226, v229) != 0;
      }
LABEL_398:
      if (!v155) {
        goto LABEL_400;
      }
      goto LABEL_399;
    }
    uint64_t v157 = (*(uint64_t (**)(void, void, uint64_t))(a1 + 1224))(*(void *)(a1 + 1200), 0, 2);
    *(void *)(a1 + 24) = (v157 + 1) & 0xFFFFFFFFFFFFFFFELL;
    int v159 = *(_DWORD *)(a1 + 16);
    if ((v159 & 0x2000) != 0)
    {
      if ((v159 & 0x80000) != 0)
      {
        __at_texel_region_t src = (v157 + 1) & 0xFFFFFFFFFFFFFFFELL;
        if ((v159 & 0x80) != 0) {
          v158.n128_u64[0] = (unint64_t)TIFFSwabLong8((int8x8_t *)&__src);
        }
        (*(void (**)(void, void, void, __n128))(a1 + 1224))(*(void *)(a1 + 1200), *(void *)(a1 + 920), 0, v158);
        if ((*(uint64_t (**)(void, unint64_t *, uint64_t))(a1 + 1216))(*(void *)(a1 + 1200), &__src, 8) != 8)goto LABEL_387; {
        __int16 v175 = *(_WORD *)(a1 + 912) - 1;
        }
        *(_WORD *)(a1 + 912) = v175;
        if (!v175) {
          goto LABEL_395;
        }
        uint64_t v169 = *(void *)(a1 + 920) + 8;
LABEL_386:
        *(void *)(a1 + 920) = v169;
LABEL_396:
        int v176 = 1;
      }
      else
      {
        LODWORD(__src) = (v157 + 1) & 0xFFFFFFFE;
        if ((v159 & 0x80) != 0) {
          v158.n128_u64[0] = (unint64_t)TIFFSwabLong((__int32 *)&__src, (uint8x8_t)v158.n128_u64[0]);
        }
        (*(void (**)(void, void, void, __n128))(a1 + 1224))(*(void *)(a1 + 1200), *(void *)(a1 + 920), 0, v158);
        if ((*(uint64_t (**)(void, unint64_t *, uint64_t))(a1 + 1216))(*(void *)(a1 + 1200), &__src, 4) == 4)
        {
          __int16 v168 = *(_WORD *)(a1 + 912) - 1;
          *(_WORD *)(a1 + 912) = v168;
          if (v168)
          {
            uint64_t v169 = *(void *)(a1 + 920) + 4;
            goto LABEL_386;
          }
LABEL_395:
          *(_DWORD *)(a1 + 16) &= ~0x2000u;
          goto LABEL_396;
        }
LABEL_387:
        uint64_t v166 = a1;
        unsigned int v167 = "TIFFLinkDirectory";
        uint64_t v8 = "Error writing SubIFD directory link";
LABEL_394:
        TIFFErrorExtR(v166, v167, v8, v9, v10, (uint64_t)v11, v12, v13, v225);
        int v176 = 0;
      }
LABEL_397:
      if (!v176) {
        goto LABEL_428;
      }
      goto LABEL_398;
    }
    if ((v159 & 0x80000) != 0)
    {
      __at_texel_region_t src = (v157 + 1) & 0xFFFFFFFFFFFFFFFELL;
      if ((v159 & 0x80) != 0) {
        v158.n128_u64[0] = (unint64_t)TIFFSwabLong8((int8x8_t *)&__src);
      }
      if (*(void *)(a1 + 864))
      {
        if (*(void *)(a1 + 40)) {
          uint64_t v170 = *(void *)(a1 + 40);
        }
        else {
          uint64_t v170 = *(void *)(a1 + 864);
        }
        while (1)
        {
          int8x8_t v233 = 0;
          uint64_t v232 = 0;
          if (!_TIFFSeekOK(a1, v170)
            || (*(uint64_t (**)(void, int8x8_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v233, 8) != 8)
          {
            uint64_t v8 = "Error fetching directory count";
            goto LABEL_389;
          }
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            v171.n128_u64[0] = (unint64_t)TIFFSwabLong8(&v233);
          }
          if (*(void *)&v233 >> 16)
          {
            uint64_t v8 = "Sanity check on tag count failed, likely corrupt TIFF";
            goto LABEL_389;
          }
          uint64_t v172 = v170 + 20 * *(void *)&v233 + 8;
          (*(void (**)(void, uint64_t, void, __n128))(a1 + 1224))(*(void *)(a1 + 1200), v172, 0, v171);
          if ((*(uint64_t (**)(void, uint64_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v232, 8) != 8) {
            break;
          }
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            v173.n128_u64[0] = (unint64_t)TIFFSwabLong8((int8x8_t *)&v232);
          }
          uint64_t v170 = v232;
          if (!v232)
          {
            (*(void (**)(void, uint64_t, void, __n128))(a1 + 1224))(*(void *)(a1 + 1200), v172, 0, v173);
            uint64_t v174 = (*(uint64_t (**)(void, unint64_t *, uint64_t))(a1 + 1216))(*(void *)(a1 + 1200), &__src, 8);
            uint64_t v8 = "Error writing directory link";
            if (v174 != 8) {
              goto LABEL_389;
            }
            *(void *)(a1 + 40) = *(void *)(a1 + 24);
            if (!v229) {
              goto LABEL_400;
            }
LABEL_399:
            *uint64_t v155 = *(void *)(a1 + 24);
            goto LABEL_400;
          }
        }
        uint64_t v8 = "Error fetching directory link";
LABEL_389:
        TIFFErrorExtR(a1, "TIFFLinkDirectory", v8, v9, v10, (uint64_t)v11, v12, v13, v225);
        int v176 = 0;
        goto LABEL_397;
      }
      uint64_t v178 = *(void *)(a1 + 24);
      *(void *)(a1 + 864) = v178;
      *(void *)(a1 + 40) = v178;
      (*(void (**)(void, uint64_t, void, __n128))(a1 + 1224))(*(void *)(a1 + 1200), 8, 0, v158);
      if ((*(uint64_t (**)(void, unint64_t *, uint64_t))(a1 + 1216))(*(void *)(a1 + 1200), &__src, 8) == 8)goto LABEL_396; {
LABEL_393:
      }
      unsigned int v167 = *(const char **)a1;
      uint64_t v166 = a1;
      uint64_t v8 = "Error writing TIFF header";
      goto LABEL_394;
    }
    LODWORD(__src) = (v157 + 1) & 0xFFFFFFFE;
    if ((v159 & 0x80) != 0) {
      v158.n128_u64[0] = (unint64_t)TIFFSwabLong((__int32 *)&__src, (uint8x8_t)v158.n128_u64[0]);
    }
    unsigned int v160 = *(_DWORD *)(a1 + 860);
    if (!v160)
    {
      uint64_t v177 = *(void *)(a1 + 24);
      *(_DWORD *)(a1 + 860) = v177;
      *(void *)(a1 + 40) = v177;
      (*(void (**)(void, uint64_t, void, __n128))(a1 + 1224))(*(void *)(a1 + 1200), 4, 0, v158);
      if ((*(uint64_t (**)(void, unint64_t *, uint64_t))(a1 + 1216))(*(void *)(a1 + 1200), &__src, 4) == 4)goto LABEL_396; {
      goto LABEL_393;
      }
    }
    uint64_t v161 = *(void *)(a1 + 40);
    if (v161) {
      uint64_t v162 = v161;
    }
    else {
      uint64_t v162 = v160;
    }
    LOWORD(v232) = 0;
    v233.i32[0] = 0;
    if (!_TIFFSeekOK(a1, v162))
    {
LABEL_355:
      uint64_t v8 = "Error fetching directory count";
LABEL_356:
      uint64_t v166 = a1;
      unsigned int v167 = "TIFFLinkDirectory";
      goto LABEL_394;
    }
    while (1)
    {
      if ((*(uint64_t (**)(void, uint64_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v232, 2) != 2) {
        goto LABEL_355;
      }
      unint64_t v163 = v19;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabShort(&v232);
      }
      int v164 = v162 + 2;
      (*(void (**)(void, void, void))(a1 + 1224))(*(void *)(a1 + 1200), v162 + 2 + 12 * (unsigned __int16)v232, 0);
      if ((*(uint64_t (**)(void, int8x8_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v233, 4) != 4)
      {
        uint64_t v8 = "Error fetching directory link";
        char v19 = v163;
        goto LABEL_356;
      }
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        v165.n128_u64[0] = (unint64_t)TIFFSwabLong((__int32 *)&v233, (uint8x8_t)v165.n128_u64[0]);
      }
      uint64_t v162 = v233.u32[0];
      if (!v233.i32[0]) {
        break;
      }
      LOWORD(v232) = 0;
      v233.i32[0] = 0;
      char v19 = v163;
      if (!_TIFFSeekOK(a1, v162)) {
        goto LABEL_355;
      }
    }
    (*(void (**)(void, void, void, __n128))(a1 + 1224))(*(void *)(a1 + 1200), v164 + 12 * (unsigned __int16)v232, 0, v165);
    uint64_t v182 = (*(uint64_t (**)(void, unint64_t *, uint64_t))(a1 + 1216))(*(void *)(a1 + 1200), &__src, 4);
    uint64_t v8 = "Error writing directory link";
    char v19 = v163;
    if (v182 != 4) {
      goto LABEL_356;
    }
    *(void *)(a1 + 40) = *(void *)(a1 + 24);
    if (v229) {
      goto LABEL_399;
    }
LABEL_400:
    unint64_t v179 = *(void *)(a1 + 24);
    if ((*(unsigned char *)(a1 + 18) & 8) != 0)
    {
      unint64_t v21 = 20 * v231 + 16;
      unint64_t v180 = v179 + v21;
    }
    else
    {
      unint64_t v21 = 12 * v231 + 6;
      unint64_t v180 = (v179 + v21);
    }
    *(void *)(a1 + 904) = v180;
    if (v180 < v179 || v180 < v21)
    {
      v206 = "TIFFWriteDirectorySec";
      v207 = "Maximum TIFF file size exceeded";
      goto LABEL_477;
    }
    if (v180) {
      *(void *)(a1 + 904) = v180 + 1;
    }
    if (v230) {
      ++*(_DWORD *)(a1 + 880);
    }
  }
  if (!v230 || (*(unsigned char *)(a1 + 78) & 2) == 0 || *(void *)(a1 + 920)) {
    goto LABEL_435;
  }
  if (!v231)
  {
LABEL_484:
    v206 = "TIFFWriteDirectorySec";
    v207 = "Cannot find SubIFD tag";
    goto LABEL_477;
  }
  int v216 = 0;
  v217 = v20;
  while (*v217 != 330)
  {
    ++v216;
    v217 += 16;
    if (v231 == v216) {
      goto LABEL_484;
    }
  }
  uint64_t v223 = 20;
  if ((*(_DWORD *)(a1 + 16) & 0x80000) != 0) {
    int v224 = 20;
  }
  else {
    int v224 = 12;
  }
  if ((*(_DWORD *)(a1 + 16) & 0x80000) == 0) {
    uint64_t v223 = 10;
  }
  *(void *)(a1 + 920) = v223 + *(void *)(a1 + 24) + (v216 * v224);
LABEL_435:
  v189 = (int8x8_t *)_TIFFmallocExt((void *)a1, v228, (uint64_t)v8, v9, v10, (uint64_t)v11, v12, v13);
  if (!v189)
  {
    v206 = "TIFFWriteDirectorySec";
LABEL_476:
    v207 = "Out of memory";
LABEL_477:
    TIFFErrorExtR(a1, v206, v207, v9, v10, (uint64_t)v11, v12, v13, v225);
LABEL_478:
    if (!v20) {
      return 0;
    }
LABEL_429:
    uint64_t v186 = a1;
    v187 = (char *)v20;
    goto LABEL_430;
  }
  v191 = (char *)v189;
  int v192 = *(_DWORD *)(a1 + 16);
  if ((v192 & 0x80000) != 0)
  {
    unsigned int v210 = v231;
    int8x8_t *v189 = (int8x8_t)v231;
    if ((v192 & 0x80) != 0) {
      TIFFSwabLong8(v189);
    }
    if (v210)
    {
      unsigned int v211 = 0;
      v212 = v191 + 10;
      v213 = v20 + 1;
      do
      {
        *((_WORD *)v212 - 1) = *(v213 - 1);
        if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
        {
          TIFFSwabShort(v212 - 2);
          int v214 = *(_DWORD *)(a1 + 16);
          *(_WORD *)v212 = *v213;
          if ((v214 & 0x80) != 0) {
            TIFFSwabShort(v212);
          }
        }
        else
        {
          *(_WORD *)v212 = *v213;
        }
        _TIFFmemcpy(v212 + 2, v213 + 3, 8uLL);
        if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
          TIFFSwabLong8((int8x8_t *)(v212 + 2));
        }
        _TIFFmemcpy(v212 + 10, v213 + 7, 8uLL);
        ++v211;
        v212 += 20;
        v213 += 16;
      }
      while (v211 < v231);
      v215 = (int8x8_t *)(v212 - 2);
    }
    else
    {
      v215 = (int8x8_t *)(v191 + 8);
    }
    _TIFFmemcpy(v215, (const void *)(a1 + 32), 8uLL);
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabLong8(v215);
    }
  }
  else
  {
    LODWORD(__src) = 0;
    unsigned int v193 = v231;
    v189->i16[0] = v231;
    if ((v192 & 0x80) != 0) {
      TIFFSwabShort(v189);
    }
    if (v193)
    {
      unsigned int v194 = 0;
      v195 = v20 + 1;
      v196 = v191 + 6;
      do
      {
        *((_WORD *)v196 - 2) = *(v195 - 1);
        if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
        {
          TIFFSwabShort(v196 - 4);
          int v197 = *(_DWORD *)(a1 + 16);
          *((_WORD *)v196 - 1) = *v195;
          if ((v197 & 0x80) != 0) {
            TIFFSwabShort(v196 - 2);
          }
        }
        else
        {
          *((_WORD *)v196 - 1) = *v195;
        }
        LODWORD(__src) = *(void *)(v195 + 3);
        _TIFFmemcpy(v196, &__src, 4uLL);
        if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
          TIFFSwabLong((__int32 *)v196, v198);
        }
        _TIFFmemcpy(v196 + 4, v195 + 7, 4uLL);
        ++v194;
        v195 += 16;
        v196 += 12;
      }
      while (v194 < v231);
      v199 = v196 - 4;
    }
    else
    {
      v199 = v191 + 2;
    }
    LODWORD(__src) = *(void *)(a1 + 32);
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabLong((__int32 *)&__src, v190);
    }
    _TIFFmemcpy(v199, &__src, 4uLL);
  }
  _TIFFfreeExt(a1, (char *)v20);
  if (_TIFFSeekOK(a1, *(void *)(a1 + 24))
    && (*(uint64_t (**)(void, char *, void))(a1 + 1216))(*(void *)(a1 + 1200), v191, v228) == v228)
  {
    _TIFFfreeExt(a1, v191);
    if (v226)
    {
      _cg_TIFFFreeDirectory(a1);
      *(_DWORD *)(a1 + 16) &= 0xFFDFFFF7;
      (*(void (**)(uint64_t))(a1 + 1072))(a1);
      TIFFCreateDirectory(a1);
    }
    else
    {
      *(void *)(a1 + 440) = *(void *)(a1 + 432);
    }
    return 1;
  }
  TIFFErrorExtR(a1, "TIFFWriteDirectorySec", "IO error writing directory", v218, v219, v220, v221, v222, v225);
  uint64_t v186 = a1;
  v187 = v191;
LABEL_430:
  _TIFFfreeExt(v186, v187);
  return 0;
}

BOOL TIFFRewriteDirectory(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return TIFFRewriteDirectorySec(a1, 1u, 0, a4, a5, a6, a7, a8);
}

BOOL TIFFRewriteDirectorySec(uint64_t a1, unsigned int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = *(void *)(a1 + 24);
  if (!v9)
  {
    return TIFFWriteDirectorySec(a1, 1, 1u, 0);
  }
  if ((*(unsigned char *)(a1 + 18) & 8) != 0)
  {
    uint64_t v14 = *(void *)(a1 + 864);
    if (v14 == v9)
    {
      *(void *)(a1 + 864) = 0;
      *(void *)(a1 + 24) = 0;
      (*(void (**)(void, uint64_t, void))(a1 + 1224))(*(void *)(a1 + 1200), 8, 0);
      if ((*(uint64_t (**)(void, uint64_t, uint64_t))(a1 + 1216))(*(void *)(a1 + 1200), a1 + 864, 8) == 8)
      {
LABEL_45:
        _TIFFRemoveEntryFromDirectoryListByOffset(a1, v9);
        return TIFFWriteDirectorySec(a1, 1, a2, a3);
      }
      goto LABEL_11;
    }
    uint64_t v18 = "Error fetching directory count";
    while (1)
    {
      uint64_t v37 = 0;
      int8x8_t v38 = 0;
      if (!_TIFFSeekOK(a1, v14)
        || (*(uint64_t (**)(void, int8x8_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v38, 8) != 8)
      {
        break;
      }
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        v19.n128_u64[0] = (unint64_t)TIFFSwabLong8(&v38);
      }
      if (*(void *)&v38 >> 16)
      {
        uint64_t v18 = "Sanity check on tag count failed, likely corrupt TIFF";
        break;
      }
      uint64_t v20 = v14 + 20 * *(void *)&v38 + 8;
      (*(void (**)(void, uint64_t, void, __n128))(a1 + 1224))(*(void *)(a1 + 1200), v20, 0, v19);
      if ((*(uint64_t (**)(void, uint64_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v37, 8) != 8)
      {
LABEL_46:
        uint64_t v18 = "Error fetching directory link";
        break;
      }
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        v21.n128_u64[0] = (unint64_t)TIFFSwabLong8((int8x8_t *)&v37);
      }
      if (v37 == *(void *)(a1 + 24))
      {
        uint64_t v36 = 0;
        (*(void (**)(void, uint64_t, void, __n128))(a1 + 1224))(*(void *)(a1 + 1200), v20, 0, v21);
        if ((*(uint64_t (**)(void, uint64_t *, uint64_t))(a1 + 1216))(*(void *)(a1 + 1200), &v36, 8) == 8)
        {
          *(void *)(a1 + 24) = 0;
          *(void *)(a1 + 40) = 0;
          int v27 = 5;
        }
        else
        {
          TIFFErrorExtR(a1, "TIFFRewriteDirectory", "Error writing directory link", v22, v23, v24, v25, v26, v35);
          int v27 = 1;
        }
        if (v27 == 5) {
          goto LABEL_45;
        }
        return 0;
      }
      uint64_t v14 = v37;
    }
  }
  else
  {
    uint64_t v12 = *(unsigned int *)(a1 + 860);
    if (v9 == v12)
    {
      *(_DWORD *)(a1 + 860) = 0;
      *(void *)(a1 + 24) = 0;
      (*(void (**)(void, uint64_t, void))(a1 + 1224))(*(void *)(a1 + 1200), 4, 0);
      if ((*(uint64_t (**)(void, uint64_t, uint64_t))(a1 + 1216))(*(void *)(a1 + 1200), a1 + 860, 4) == 4) {
        goto LABEL_45;
      }
LABEL_11:
      int v15 = *(const char **)a1;
      uint64_t v16 = "Error updating TIFF header";
LABEL_14:
      uint64_t v17 = a1;
      goto LABEL_49;
    }
    if (HIDWORD(v9))
    {
      int v15 = "TIFFRewriteDirectory";
      uint64_t v16 = "tif->tif_diroff exceeds 32 bit range allowed for Classic TIFF";
      goto LABEL_14;
    }
    uint64_t v18 = "Error fetching directory count";
    while (1)
    {
      LOWORD(v36) = 0;
      v38.i32[0] = 0;
      if (!_TIFFSeekOK(a1, v12)
        || (*(uint64_t (**)(void, uint64_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v36, 2) != 2)
      {
        break;
      }
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabShort(&v36);
      }
      (*(void (**)(void, void, void))(a1 + 1224))(*(void *)(a1 + 1200), v12 + 2 + 12 * (unsigned __int16)v36, 0);
      if ((*(uint64_t (**)(void, int8x8_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v38, 4) != 4) {
        goto LABEL_46;
      }
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        v28.n128_u64[0] = (unint64_t)TIFFSwabLong((__int32 *)&v38, (uint8x8_t)v28.n128_u64[0]);
      }
      if (*(void *)(a1 + 24) == v38.u32[0])
      {
        LODWORD(v37) = 0;
        (*(void (**)(void, void, void, __n128))(a1 + 1224))(*(void *)(a1 + 1200), v12 + 2 + 12 * (unsigned __int16)v36, 0, v28);
        if ((*(uint64_t (**)(void, uint64_t *, uint64_t))(a1 + 1216))(*(void *)(a1 + 1200), &v37, 4) == 4)
        {
          *(void *)(a1 + 24) = 0;
          *(void *)(a1 + 40) = 0;
          int v34 = 3;
        }
        else
        {
          TIFFErrorExtR(a1, "TIFFRewriteDirectory", "Error writing directory link", v29, v30, v31, v32, v33, v35);
          int v34 = 1;
        }
        if (v34 != 3) {
          return 0;
        }
        goto LABEL_45;
      }
      LODWORD(v12) = v38.i32[0];
    }
  }
  int v15 = "TIFFRewriteDirectory";
  uint64_t v17 = a1;
  uint64_t v16 = (char *)v18;
LABEL_49:
  TIFFErrorExtR(v17, v15, v16, a4, a5, a6, a7, a8, v35);
  return 0;
}

uint64_t _TIFFRewriteField(uint64_t a1, int a2, unsigned int a3, int64_t a4, const void *a5)
{
  v103[3] = *(int8x8_t *)MEMORY[0x1E4F143B8];
  unsigned __int16 v101 = 0;
  unsigned __int16 v100 = 0;
  int8x8_t v98 = 0;
  int64_t v99 = 0;
  TIFFFindField((void *)a1, a2, 0);
  if ((*(unsigned char *)(a1 + 17) & 8) != 0)
  {
    __n128 v28 = "Memory mapped files not currently supported for this operation.";
    goto LABEL_167;
  }
  uint64_t v15 = *(void *)(a1 + 24);
  if (!v15)
  {
    __n128 v28 = "Attempt to reset field on directory not already on disk.";
    goto LABEL_167;
  }
  if (!_TIFFSeekOK(a1, v15)) {
    goto LABEL_166;
  }
  __int16 v102 = 0;
  memset(v103, 0, 20);
  uint64_t v16 = *(void *)(a1 + 24);
  if ((*(unsigned char *)(a1 + 18) & 8) != 0)
  {
    int8x8_t v97 = 0;
    if ((*(uint64_t (**)(void, int8x8_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v97, 8) == 8)
    {
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        int8x8_t v24 = TIFFSwabLong8(&v97);
      }
      __int16 v102 = v97.i16[0];
      uint64_t v25 = v16 + 8;
      uint64_t v26 = 20;
      if (v97.i16[0])
      {
LABEL_9:
        while ((*(uint64_t (**)(void, int8x8_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), v103, v26) == v26)
        {
          int v27 = v103[0].u16[0];
          unsigned __int16 v101 = v103[0].i16[0];
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
          {
            TIFFSwabShort(&v101);
            int v27 = v101;
          }
          if (v27 != a2)
          {
            v25 += v26;
            if (v102) {
              continue;
            }
          }
          goto LABEL_22;
        }
        TIFFErrorExtR(a1, "TIFFResetField", "%s: Can not read TIFF directory entry.", v19, v20, v21, v22, v23, *(void *)a1);
        return 0;
      }
      goto LABEL_21;
    }
LABEL_28:
    TIFFErrorExtR(a1, "TIFFResetField", "%s: Can not read TIFF directory count", v19, v20, v21, v22, v23, *(void *)a1);
    return 0;
  }
  if ((*(uint64_t (**)(void, __int16 *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v102, 2) != 2) {
    goto LABEL_28;
  }
  if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
    TIFFSwabShort(&v102);
  }
  uint64_t v25 = v16 + 2;
  uint64_t v26 = 12;
  if (v102) {
    goto LABEL_9;
  }
LABEL_21:
  int v27 = v101;
LABEL_22:
  if (v27 == a2)
  {
    unsigned __int16 v100 = v103[0].u16[1];
    int v29 = *(_DWORD *)(a1 + 16);
    if ((v29 & 0x80) != 0)
    {
      TIFFSwabShort(&v100);
      int v29 = *(_DWORD *)(a1 + 16);
    }
    if ((v29 & 0x80000) != 0)
    {
      int64_t v99 = *(int64_t *)((char *)v103 + 4);
      if ((v29 & 0x80) != 0)
      {
        TIFFSwabLong8((int8x8_t *)&v99);
        int v35 = *(_DWORD *)(a1 + 16);
        int8x8_t v30 = *(int8x8_t *)((char *)&v103[1] + 4);
        int8x8_t v98 = *(int8x8_t *)((char *)&v103[1] + 4);
        if ((v35 & 0x80) != 0)
        {
          TIFFSwabLong8(&v98);
          int8x8_t v30 = v98;
        }
LABEL_37:
        if (*(void *)&v30 || v99 || v100)
        {
LABEL_46:
          if (TIFFDataWidth(a3) != 8 || (*(unsigned char *)(a1 + 18) & 8) != 0)
          {
            if (a3 == 18)
            {
              unsigned int v36 = v100;
              BOOL v37 = v100 == 13;
              int v38 = 18;
            }
            else
            {
              if (a3 != 17)
              {
                unsigned int v34 = a3;
                if (a3 == 16 && v100 <= 0x10u && ((1 << v100) & 0x10018) != 0) {
                  unsigned int v34 = v100;
                }
                goto LABEL_67;
              }
              unsigned int v36 = v100;
              BOOL v37 = v100 == 9;
              int v38 = 17;
            }
            if (v37) {
              unsigned int v34 = v36;
            }
            else {
              unsigned int v34 = v38;
            }
          }
          else if (a3 == 18)
          {
            unsigned int v34 = 13;
          }
          else if (a3 == 17)
          {
            unsigned int v34 = 9;
          }
          else
          {
            unsigned int v34 = a3;
            if (a3 == 16)
            {
              if (v100 == 3) {
                unsigned int v34 = 3;
              }
              else {
                unsigned int v34 = 4;
              }
            }
          }
LABEL_67:
          int v39 = TIFFDataWidth(v34);
          uint64_t result = (uint64_t)_TIFFCheckMalloc((const char **)a1, a4, v39, (uint64_t)"for field buffer.", v40, v41, v42, v43);
          if (!result) {
            return result;
          }
          uint64_t v45 = (int8x8_t *)result;
          if (v34 == a3)
          {
            int v46 = TIFFDataWidth(a3);
            memcpy(v45, a5, v46 * a4);
            goto LABEL_70;
          }
          if (a3 == 17 && v34 == 9)
          {
            if (a4 < 1) {
              goto LABEL_70;
            }
            uint64_t v47 = 0;
            while (1)
            {
              uint64_t v48 = *((void *)a5 + v47);
              *(_DWORD *)(result + 4 * v47) = v48;
              if (v48 != (int)v48) {
                goto LABEL_94;
              }
              if (a4 == ++v47) {
                goto LABEL_70;
              }
            }
          }
          if (a3 == 16 && v34 == 4 || a3 == 18 && v34 == 13)
          {
            if (a4 < 1) {
              goto LABEL_70;
            }
            uint64_t v58 = 0;
            while (1)
            {
              unint64_t v59 = *((void *)a5 + v58);
              *(_DWORD *)(result + 4 * v58) = v59;
              if (HIDWORD(v59)) {
                break;
              }
              if (a4 == ++v58) {
                goto LABEL_70;
              }
            }
LABEL_94:
            _TIFFfreeExt(a1, (char *)result);
            __n128 v28 = "Value exceeds 32bit range of output type.";
            goto LABEL_167;
          }
          if (a3 == 16 && v34 == 3)
          {
            if (a4 >= 1)
            {
              uint64_t v69 = 0;
              while (1)
              {
                unint64_t v70 = *((void *)a5 + v69);
                *(_WORD *)(result + 2 * v69) = v70;
                if (v70 >= 0x10000) {
                  break;
                }
                if (a4 == ++v69) {
                  goto LABEL_70;
                }
              }
              _TIFFfreeExt(a1, (char *)result);
              __n128 v28 = "Value exceeds 16bit range of output type.";
              goto LABEL_167;
            }
LABEL_70:
            if ((int)TIFFDataWidth(v34) >= 2 && (*(unsigned char *)(a1 + 16) & 0x80) != 0)
            {
              if (TIFFDataWidth(v34) == 2)
              {
                TIFFSwabArrayOfShort((uint64_t)v45, a4);
              }
              else if (TIFFDataWidth(v34) == 4)
              {
                TIFFSwabArrayOfLong((__int32 *)v45, a4, v68);
              }
              else if (TIFFDataWidth(v34) == 8)
              {
                TIFFSwabArrayOfLong8(v45, a4);
              }
            }
            int v71 = *(_DWORD *)(a1 + 16);
            uint64_t v72 = (int)TIFFDataWidth(v34) * a4;
            if ((v71 & 0x80000) != 0)
            {
              if (v72 <= 8)
              {
                int v73 = 0;
                int8x8_t v74 = (int8x8_t)(v25 + 12);
                goto LABEL_117;
              }
            }
            else if (v72 <= 4)
            {
              int v73 = 0;
              int8x8_t v74 = (int8x8_t)(v25 + 8);
LABEL_117:
              int8x8_t v98 = v74;
              goto LABEL_119;
            }
            int v73 = 1;
LABEL_119:
            if (a2 > 323)
            {
              if (a2 == 325)
              {
LABEL_128:
                if (!*(void *)(a1 + 296) && !*(_WORD *)(a1 + 290) && !*(void *)(a1 + 304))
                {
                  int v75 = (int64_t *)(a1 + 296);
                  uint64_t v76 = (_WORD *)(a1 + 290);
LABEL_138:
                  *uint64_t v76 = v34;
                  *int v75 = a4;
                }
LABEL_139:
                if (v99 == a4 && v100 == (unsigned __int16)v34)
                {
                  if (_TIFFSeekOK(a1, *(void *)&v98))
                  {
                    uint64_t v77 = *(uint64_t (**)(uint64_t, int8x8_t *, int64_t))(a1 + 1216);
                    uint64_t v78 = *(void *)(a1 + 1200);
                    int v79 = TIFFDataWidth(v34);
                    uint64_t v80 = v77(v78, v45, v79 * a4);
                    int64_t v81 = (int)TIFFDataWidth(v34) * a4;
                    _TIFFfreeExt(a1, (char *)v45);
                    if (v80 == v81) {
                      return 1;
                    }
                    goto LABEL_147;
                  }
                  _TIFFfreeExt(a1, (char *)v45);
                }
                else
                {
                  if (v73)
                  {
                    int8x8_t v98 = (int8x8_t)(*(uint64_t (**)(void, void, uint64_t))(a1 + 1224))(*(void *)(a1 + 1200), 0, 2);
                    size_t v82 = *(uint64_t (**)(uint64_t, int8x8_t *, int64_t))(a1 + 1216);
                    uint64_t v83 = *(void *)(a1 + 1200);
                    int v84 = TIFFDataWidth(v34);
                    uint64_t v85 = v82(v83, v45, v84 * a4);
                    if (v85 != (int)TIFFDataWidth(v34) * a4)
                    {
                      _TIFFfreeExt(a1, (char *)v45);
LABEL_147:
                      __n128 v28 = "Error writing directory link";
                      goto LABEL_167;
                    }
                  }
                  else if ((int)TIFFDataWidth(v34) * a4 == 4)
                  {
                    v97.i32[0] = 0;
                    TIFFDataWidth(v34);
                    __memcpy_chk();
                    int8x8_t v98 = (int8x8_t)v97.u32[0];
                  }
                  else
                  {
                    TIFFDataWidth(v34);
                    __memcpy_chk();
                  }
                  _TIFFfreeExt(a1, (char *)v45);
                  unsigned __int16 v100 = v34;
                  int64_t v99 = a4;
                  v103[0].i16[1] = v34;
                  int v87 = *(_DWORD *)(a1 + 16);
                  if ((v87 & 0x80) != 0)
                  {
                    TIFFSwabShort((unsigned char *)v103 + 2);
                    int v87 = *(_DWORD *)(a1 + 16);
                  }
                  if ((v87 & 0x80000) != 0)
                  {
                    *(int8x8_t *)((char *)v103 + 4) = (int8x8_t)v99;
                    if ((v87 & 0x80) != 0)
                    {
                      TIFFSwabLong8((int8x8_t *)((char *)v103 + 4));
                      int v90 = *(_DWORD *)(a1 + 16);
                      *(int8x8_t *)((char *)&v103[1] + 4) = v98;
                      if ((v90 & 0x80) != 0) {
                        TIFFSwabLong8((int8x8_t *)((char *)&v103[1] + 4));
                      }
                    }
                    else
                    {
                      *(int8x8_t *)((char *)&v103[1] + 4) = v98;
                    }
                  }
                  else
                  {
                    v103[0].i32[1] = v99;
                    if ((v87 & 0x80) != 0)
                    {
                      int8x8_t v88 = TIFFSwabLong((__int32 *)v103 + 1, v86);
                      int v89 = *(_DWORD *)(a1 + 16);
                      v103[1].i32[0] = v98.i32[0];
                      if ((v89 & 0x80) != 0) {
                        TIFFSwabLong((__int32 *)&v103[1], (uint8x8_t)v88);
                      }
                    }
                    else
                    {
                      v103[1].i32[0] = v98.i32[0];
                    }
                  }
                  if (_TIFFSeekOK(a1, v25))
                  {
                    if ((*(uint64_t (**)(void, int8x8_t *, uint64_t))(a1 + 1216))(*(void *)(a1 + 1200), v103, v26) == v26)return 1; {
                    TIFFErrorExtR(a1, "TIFFResetField", "%s: Can not write TIFF directory entry.", v91, v92, v93, v94, v95, *(void *)a1);
                    }
                    return 0;
                  }
                }
LABEL_166:
                uint64_t v96 = *(void *)a1;
                __n128 v28 = "%s: Seek error accessing TIFF directory";
                goto LABEL_167;
              }
              if (a2 != 324) {
                goto LABEL_139;
              }
            }
            else if (a2 != 273)
            {
              goto LABEL_127;
            }
            if (!*(void *)(a1 + 264) && !*(_WORD *)(a1 + 258) && !*(void *)(a1 + 272))
            {
              int v75 = (int64_t *)(a1 + 264);
              uint64_t v76 = (_WORD *)(a1 + 258);
              goto LABEL_138;
            }
LABEL_127:
            if (a2 != 279) {
              goto LABEL_139;
            }
            goto LABEL_128;
          }
          __n128 v28 = "Unhandled type conversion.";
LABEL_167:
          TIFFErrorExtR(a1, "TIFFResetField", v28, v10, v11, v12, v13, v14, v96);
          return 0;
        }
        if (a2 == 324 || a2 == 273)
        {
          if ((*(_DWORD *)(a1 + 16) & 0x80000) != 0) {
            __int16 v33 = 16;
          }
          else {
            __int16 v33 = 4;
          }
          goto LABEL_45;
        }
        if (a2 == 279 && a4 > 1)
        {
          unint64_t v49 = _cg_TIFFStripSize64(a1, v17, v18, v19, v20, v21, v22, v23);
          if (!_WriteAsType(a1, v49, 0xFFFFFFFFuLL))
          {
            unint64_t v57 = _cg_TIFFStripSize64(a1, v50, v51, v52, v53, v54, v55, v56);
            goto LABEL_134;
          }
        }
        else
        {
          __int16 v33 = 16;
          if (a2 != 325 || a4 <= 1) {
            goto LABEL_45;
          }
          unint64_t v60 = _cg_TIFFTileSize64(a1, v17, v18, v19, v20, v21, v22, v23);
          if (!_WriteAsType(a1, v60, 0xFFFFFFFFuLL))
          {
            unint64_t v57 = _cg_TIFFTileSize64(a1, v61, v62, v63, v64, v65, v66, v67);
LABEL_134:
            if (_WriteAsType(a1, v57, 0xFFFFuLL)) {
              __int16 v33 = 4;
            }
            else {
              __int16 v33 = 3;
            }
            goto LABEL_45;
          }
        }
        __int16 v33 = 16;
LABEL_45:
        unsigned __int16 v100 = v33;
        goto LABEL_46;
      }
      int8x8_t v30 = *(int8x8_t *)((char *)&v103[1] + 4);
    }
    else
    {
      v97.i32[0] = v103[0].i32[1];
      if ((v29 & 0x80) != 0)
      {
        int8x8_t v31 = TIFFSwabLong((__int32 *)&v97, (uint8x8_t)v24);
        int v32 = *(_DWORD *)(a1 + 16);
        int64_t v99 = v97.u32[0];
        v30.i32[0] = v103[1].i32[0];
        v97.i32[0] = v103[1].i32[0];
        if ((v32 & 0x80) != 0)
        {
          TIFFSwabLong((__int32 *)&v97, (uint8x8_t)v31);
          v30.i32[0] = v97.i32[0];
        }
      }
      else
      {
        int64_t v99 = v103[0].u32[1];
        v30.i32[0] = v103[1].i32[0];
      }
      int8x8_t v30 = (int8x8_t)v30.u32[0];
    }
    int8x8_t v98 = v30;
    goto LABEL_37;
  }
  TIFFErrorExtR(a1, "TIFFResetField", "%s: Could not find tag %hu.", v19, v20, v21, v22, v23, *(void *)a1);
  return 0;
}

uint64_t TIFFWriteDirectoryTagShortLong(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, unsigned __int32 a5, uint8x8_t a6)
{
  if (HIWORD(a5)) {
    return TIFFWriteDirectoryTagCheckedLong(a1, a2, a3, a4, a5, a6);
  }
  else {
    return TIFFWriteDirectoryTagCheckedShort(a1, a2, a3, a4, a5);
  }
}

uint64_t TIFFWriteDirectoryTagRational(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a9 >= 0.0)
  {
    if (a3)
    {
      DoubleToRational(&v16, &v17, a9, (uint64_t)a3, a4, a5, a6, a7, a8, 0);
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        int8x8_t v15 = TIFFSwabLong(&v16, v14);
        TIFFSwabLong(&v17, (uint8x8_t)v15);
      }
      return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 5, 1, 8, (uint64_t)&v16);
    }
    else
    {
      *(void *)(a1 + 432) += ~*(_WORD *)(a1 + 18) & 8;
      ++*a2;
      return 1;
    }
  }
  else
  {
    TIFFErrorExtR(a1, "TIFFWriteDirectoryTagCheckedRational", "Negative value is illegal", a4, a5, a6, a7, a8, v16);
    return 0;
  }
}

uint64_t TIFFWriteDirectoryTagShortPerSample(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, __int16 a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = *(unsigned __int16 *)(a1 + 130);
  if (a3)
  {
    uint8x8_t v14 = (char *)_TIFFmallocExt((void *)a1, 2 * *(unsigned __int16 *)(a1 + 130), (uint64_t)a3, a4, *(unsigned __int16 *)(a1 + 130), a6, a7, a8);
    if (v14)
    {
      uint64_t v20 = v14;
      if (*(_WORD *)(a1 + 130))
      {
        unsigned int v21 = 0;
        uint64_t v22 = v14;
        do
        {
          *(_WORD *)uint64_t v22 = a5;
          v22 += 2;
          ++v21;
          uint64_t v23 = *(unsigned __int16 *)(a1 + 130);
        }
        while (v21 < v23);
      }
      else
      {
        uint64_t v23 = 0;
      }
      uint64_t v25 = TIFFWriteDirectoryTagCheckedShortArray(a1, a2, a3, a4, v23, (uint64_t)v14);
      _TIFFfreeExt(a1, v20);
      return v25;
    }
    else
    {
      TIFFErrorExtR(a1, "TIFFWriteDirectoryTagShortPerSample", "Out of memory", v15, v16, v17, v18, v19, v26);
      return 0;
    }
  }
  else
  {
    return TIFFWriteDirectoryTagCheckedShortArray(a1, a2, 0, a4, v12, 0);
  }
}

uint64_t TIFFWriteDirectoryTagLongLong8Array(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, int8x8_t *__src, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)(a1 + 424))
  {
    if (a3)
    {
      return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 0, 0, 0, 0);
    }
    else
    {
      ++*a2;
      return 1;
    }
  }
  if ((*(unsigned char *)(a1 + 18) & 8) != 0)
  {
    if (a4 == 279 && a5 >= 2)
    {
      unint64_t v15 = _cg_TIFFStripSize64(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, (uint64_t)__src, a7, a8);
    }
    else
    {
      if (a4 != 325 || a5 < 2) {
        goto LABEL_15;
      }
      unint64_t v15 = _cg_TIFFTileSize64(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, (uint64_t)__src, a7, a8);
    }
    if (_WriteAsType(a1, v15, 0xFFFFFFFFuLL))
    {
LABEL_15:
      return TIFFWriteDirectoryTagCheckedLong8Array(a1, a2, a3, a4, a5, __src, a7, a8);
    }
  }
  uint64_t v16 = a5;
  if (a4 == 279 && a5 >= 2)
  {
    unint64_t v17 = _cg_TIFFStripSize64(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, (uint64_t)__src, a7, a8);
  }
  else
  {
    if (a4 != 325 || a5 < 2) {
      goto LABEL_25;
    }
    unint64_t v17 = _cg_TIFFTileSize64(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, (uint64_t)__src, a7, a8);
  }
  if (!_WriteAsType(a1, v17, 0xFFFFuLL))
  {
    int8x8_t v31 = (char *)_TIFFmallocExt((void *)a1, 2 * a5, (uint64_t)a3, a4, a5, (uint64_t)__src, a7, a8);
    if (v31)
    {
      int v32 = v31;
      uint64_t v33 = 0;
      while (1)
      {
        unint64_t v34 = (unint64_t)__src[v33];
        if (v34 >= 0x10000) {
          break;
        }
        *(_WORD *)&v31[2 * v33++] = v34;
        if (v16 == v33)
        {
          uint64_t v28 = TIFFWriteDirectoryTagCheckedShortArray(a1, a2, a3, a4, v16, (uint64_t)v31);
          uint64_t v29 = a1;
          int8x8_t v30 = v32;
          goto LABEL_36;
        }
      }
      TIFFErrorExtR(a1, "TIFFWriteDirectoryTagLongLong8Array", "Attempt to write value larger than 0xFFFF in SHORT array.", v19, v20, v21, v22, v23, v37);
      uint64_t v35 = a1;
      unsigned int v36 = v32;
      goto LABEL_40;
    }
LABEL_37:
    TIFFErrorExtR(a1, "TIFFWriteDirectoryTagLongLong8Array", "Out of memory", v19, v20, v21, v22, v23, v37);
    return 0;
  }
LABEL_25:
  uint64_t v18 = (__int32 *)_TIFFmallocExt((void *)a1, 4 * a5, (uint64_t)a3, a4, a5, (uint64_t)__src, a7, a8);
  if (!v18) {
    goto LABEL_37;
  }
  uint64_t v25 = v18;
  if (a5)
  {
    uint64_t v26 = 0;
    while (1)
    {
      int8x8_t v27 = __src[v26];
      if (HIDWORD(*(void *)&v27)) {
        break;
      }
      v18[v26++] = v27.i32[0];
      if (a5 == v26) {
        goto LABEL_30;
      }
    }
    TIFFErrorExtR(a1, "TIFFWriteDirectoryTagLongLong8Array", "Attempt to write value larger than 0xFFFFFFFF in LONG array.", v19, v20, v21, v22, v23, v37);
    uint64_t v35 = a1;
    unsigned int v36 = (char *)v25;
LABEL_40:
    _TIFFfreeExt(v35, v36);
    return 0;
  }
LABEL_30:
  uint64_t v28 = TIFFWriteDirectoryTagCheckedLongArray(a1, a2, a3, a4, a5, v18, v24);
  uint64_t v29 = a1;
  int8x8_t v30 = (char *)v25;
LABEL_36:
  _TIFFfreeExt(v29, v30);
  return v28;
}

uint64_t TIFFWriteDirectoryTagSampleformatArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (int8x8_t *)a6;
  uint8x8_t v14 = (__int32 *)_TIFFmallocExt((void *)a1, 8 * a5, (uint64_t)a3, a4, a5, a6, a7, a8);
  if (v14)
  {
    uint64_t v21 = v14;
    uint64_t v22 = a5;
    int v23 = *(unsigned __int16 *)(a1 + 118);
    switch(v23)
    {
      case 1:
        unsigned int v28 = *(unsigned __int16 *)(a1 + 116);
        if (v28 > 8)
        {
          if (v28 >= 0x11)
          {
            if (a5)
            {
              uint8x8_t v20 = (uint8x8_t)0x41EFFFFFFFE00000;
              uint64_t v42 = (unsigned int *)v14;
              do
              {
                double v43 = *(double *)v8;
                if (*(double *)v8 >= 0.0)
                {
                  unsigned int v44 = v43;
                  if (v43 > 4294967300.0) {
                    unsigned int v44 = -1;
                  }
                }
                else
                {
                  unsigned int v44 = 0;
                }
                *v42++ = v44;
                ++v8;
                --v22;
              }
              while (v22);
            }
            uint64_t v26 = TIFFWriteDirectoryTagCheckedLongArray(a1, a2, a3, a4, a5, v14, v20);
          }
          else
          {
            if (a5)
            {
              unsigned int v36 = v14;
              do
              {
                double v37 = *(double *)v8;
                if (*(double *)v8 >= 0.0)
                {
                  int v38 = (int)v37;
                  if (v37 > 65535.0) {
                    LOWORD(v38) = -1;
                  }
                }
                else
                {
                  LOWORD(v38) = 0;
                }
                *(_WORD *)unsigned int v36 = v38;
                unsigned int v36 = (__int32 *)((char *)v36 + 2);
                ++v8;
                --v22;
              }
              while (v22);
            }
            uint64_t v26 = TIFFWriteDirectoryTagCheckedShortArray(a1, a2, a3, a4, a5, (uint64_t)v14);
          }
        }
        else
        {
          if (a5)
          {
            uint64_t v29 = v14;
            do
            {
              double v30 = *(double *)v8;
              if (*(double *)v8 >= 0.0)
              {
                int v31 = (int)v30;
                if (v30 > 255.0) {
                  LOBYTE(v31) = -1;
                }
              }
              else
              {
                LOBYTE(v31) = 0;
              }
              *(unsigned char *)uint64_t v29 = v31;
              uint64_t v29 = (__int32 *)((char *)v29 + 1);
              ++v8;
              --v22;
            }
            while (v22);
          }
          uint64_t v26 = TIFFWriteDirectoryTagByteArray(a1, a2, a3, a4, a5, (uint64_t)v14);
        }
        break;
      case 2:
        unsigned int v32 = *(unsigned __int16 *)(a1 + 116);
        if (v32 > 8)
        {
          if (v32 >= 0x11)
          {
            if (a5)
            {
              uint8x8_t v20 = (uint8x8_t)0x41DFFFFFFFC00000;
              uint64_t v45 = v14;
              do
              {
                double v46 = *(double *)v8;
                if (*(double *)v8 <= 2147483650.0)
                {
                  int v47 = (int)v46;
                  if (v46 < -2147483650.0) {
                    int v47 = 0x80000000;
                  }
                }
                else
                {
                  int v47 = 0x7FFFFFFF;
                }
                *v45++ = v47;
                ++v8;
                --v22;
              }
              while (v22);
            }
            uint64_t v26 = TIFFWriteDirectoryTagCheckedSlongArray(a1, a2, a3, a4, a5, v14, v20);
          }
          else
          {
            if (a5)
            {
              int v39 = v14;
              do
              {
                double v40 = *(double *)v8;
                if (*(double *)v8 <= 32767.0)
                {
                  int v41 = (int)v40;
                  if (v40 < -32768.0) {
                    LOWORD(v41) = 0x8000;
                  }
                }
                else
                {
                  LOWORD(v41) = 0x7FFF;
                }
                *(_WORD *)int v39 = v41;
                int v39 = (__int32 *)((char *)v39 + 2);
                ++v8;
                --v22;
              }
              while (v22);
            }
            uint64_t v26 = TIFFWriteDirectoryTagSshortArray(a1, a2, a3, a4, a5, (uint64_t)v14);
          }
        }
        else
        {
          if (a5)
          {
            uint64_t v33 = v14;
            do
            {
              double v34 = *(double *)v8;
              if (*(double *)v8 <= 127.0)
              {
                int v35 = (int)v34;
                if (v34 < -128.0) {
                  LOBYTE(v35) = 0x80;
                }
              }
              else
              {
                LOBYTE(v35) = 127;
              }
              *(unsigned char *)uint64_t v33 = v35;
              uint64_t v33 = (__int32 *)((char *)v33 + 1);
              ++v8;
              --v22;
            }
            while (v22);
          }
          uint64_t v26 = TIFFWriteDirectoryTagSbyteArray(a1, a2, a3, a4, a5, (uint64_t)v14);
        }
        break;
      case 3:
        if (*(unsigned __int16 *)(a1 + 116) > 0x20u)
        {
          uint64_t v26 = TIFFWriteDirectoryTagDoubleArray(a1, a2, a3, a4, a5, v8);
        }
        else
        {
          if (a5)
          {
            uint8x8_t v24 = v14;
            do
            {
              int8x8_t v25 = *v8++;
              *(float *)v20.i32 = _TIFFClampDoubleToFloat(*(double *)&v25);
              *v24++ = v20.i32[0];
              --v22;
            }
            while (v22);
          }
          uint64_t v26 = TIFFWriteDirectoryTagFloatArray(a1, a2, a3, a4, a5, v21, v20);
        }
        break;
      default:
        uint64_t v27 = 0;
LABEL_66:
        _TIFFfreeExt(a1, (char *)v21);
        return v27;
    }
    uint64_t v27 = v26;
    goto LABEL_66;
  }
  TIFFErrorExtR(a1, "TIFFWriteDirectoryTagSampleformatArray", "Out of memory", v15, v16, v17, v18, v19, v49);
  return 0;
}

uint64_t TIFFWriteDirectoryTagRationalArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (2 * a5);
  unint64_t v11 = 4 * v10;
  if (a3)
  {
    uint64_t v12 = (float *)a6;
    uint64_t v16 = (__int32 *)_TIFFmallocExt((void *)a1, v11, (uint64_t)a3, a4, a5, a6, a7, a8);
    if (v16)
    {
      uint8x8_t v24 = v16;
      if (a5)
      {
        int v25 = a5;
        uint64_t v26 = v16;
        do
        {
          float v27 = *v12++;
          DoubleToRational(v26, v26 + 1, v27, v17, v18, v19, v20, v21, v22, v31);
          v26 += 2;
          --v25;
        }
        while (v25);
      }
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabArrayOfLong(v24, v10, v23);
      }
      uint64_t v28 = TIFFWriteDirectoryTagData(a1, a2, a3, a4, 5, a5, (8 * a5), (uint64_t)v24);
      _TIFFfreeExt(a1, (char *)v24);
      return v28;
    }
    else
    {
      TIFFErrorExtR(a1, "TIFFWriteDirectoryTagCheckedRationalArray", "Out of memory", v18, v19, v20, v21, v22, v31);
      return 0;
    }
  }
  else
  {
    unint64_t v30 = 8;
    if ((*(unsigned char *)(a1 + 18) & 8) == 0) {
      unint64_t v30 = 4;
    }
    if (v11 > v30) {
      *(void *)(a1 + 432) += v11;
    }
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagAscii(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t __src)
{
  if (a3) {
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 2, a5, a5, __src);
  }
  unint64_t v7 = 8;
  if ((*(unsigned char *)(a1 + 18) & 8) == 0) {
    unint64_t v7 = 4;
  }
  if (v7 < a5) {
    *(void *)(a1 + 432) += (a5 & 1) + a5;
  }
  ++*a2;
  return 1;
}

uint64_t TIFFWriteDirectoryTagUndefinedArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t __src)
{
  if (a3) {
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 7, a5, a5, __src);
  }
  unint64_t v7 = 8;
  if ((*(unsigned char *)(a1 + 18) & 8) == 0) {
    unint64_t v7 = 4;
  }
  if (v7 < a5) {
    *(void *)(a1 + 432) += (a5 & 1) + a5;
  }
  ++*a2;
  return 1;
}

uint64_t TIFFWriteDirectoryTagByteArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t __src)
{
  if (a3) {
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 1, a5, a5, __src);
  }
  unint64_t v7 = 8;
  if ((*(unsigned char *)(a1 + 18) & 8) == 0) {
    unint64_t v7 = 4;
  }
  if (v7 < a5) {
    *(void *)(a1 + 432) += (a5 & 1) + a5;
  }
  ++*a2;
  return 1;
}

uint64_t TIFFWriteDirectoryTagSbyteArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t __src)
{
  if (a3) {
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 6, a5, a5, __src);
  }
  unint64_t v7 = 8;
  if ((*(unsigned char *)(a1 + 18) & 8) == 0) {
    unint64_t v7 = 4;
  }
  if (v7 < a5) {
    *(void *)(a1 + 432) += (a5 & 1) + a5;
  }
  ++*a2;
  return 1;
}

uint64_t TIFFWriteDirectoryTagSshortArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t __src)
{
  if ((a5 & 0x80000000) != 0) {
    TIFFWriteDirectoryTagSshortArray_cold_1();
  }
  if (a3)
  {
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabArrayOfShort(__src, a5);
    }
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 8, a5, (2 * a5), __src);
  }
  else
  {
    unint64_t v13 = 2 * a5;
    unint64_t v14 = 8;
    if ((*(unsigned char *)(a1 + 18) & 8) == 0) {
      unint64_t v14 = 4;
    }
    if (v13 > v14) {
      *(void *)(a1 + 432) += v13;
    }
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagFloatArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, __int32 *__src, uint8x8_t a7)
{
  if (a5 >> 30) {
    TIFFWriteDirectoryTagFloatArray_cold_1();
  }
  if (a3)
  {
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabArrayOfLong(__src, a5, a7);
    }
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 11, a5, (4 * a5), (uint64_t)__src);
  }
  else
  {
    unint64_t v14 = 4 * a5;
    unint64_t v15 = 8;
    if ((*(unsigned char *)(a1 + 18) & 8) == 0) {
      unint64_t v15 = 4;
    }
    if (v14 > v15) {
      *(void *)(a1 + 432) += v14;
    }
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagDoubleArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, int8x8_t *__src)
{
  if (a5 >> 29) {
    TIFFWriteDirectoryTagDoubleArray_cold_1();
  }
  if (a3)
  {
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabArrayOfLong8(__src, a5);
    }
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 12, a5, (8 * a5), (uint64_t)__src);
  }
  else
  {
    unint64_t v13 = 8 * a5;
    unint64_t v14 = 8;
    if ((*(unsigned char *)(a1 + 18) & 8) == 0) {
      unint64_t v14 = 4;
    }
    if (v13 > v14) {
      *(void *)(a1 + 432) += v13;
    }
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedShort(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, __int16 a5)
{
  if (a3)
  {
    __at_texel_region_t src = a5;
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabShort(&__src);
    }
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 3, 1, 2, (uint64_t)&__src);
  }
  else
  {
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedLong(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, __int32 a5, uint8x8_t a6)
{
  if (a3)
  {
    __at_texel_region_t src = a5;
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabLong(&__src, a6);
    }
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 4, 1, 4, (uint64_t)&__src);
  }
  else
  {
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagData(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t __n, uint64_t __src)
{
  unsigned int v9 = __n;
  uint64_t v12 = *a2;
  if (v12)
  {
    uint64_t v13 = 0;
    unint64_t v14 = a3;
    while (1)
    {
      unsigned int v15 = *v14;
      v14 += 16;
      BOOL v16 = v15 > a4;
      if (v15 == a4) {
        TIFFWriteDirectoryTagData_cold_1();
      }
      if (v16) {
        break;
      }
      if (v12 == ++v13)
      {
        LODWORD(v13) = *a2;
        goto LABEL_11;
      }
    }
    if (v12 > v13)
    {
      uint64_t v17 = &a3[16 * v12];
      uint64_t v18 = &a3[16 * (v12 - 1)];
      do
      {
        long long v19 = *(_OWORD *)v18;
        long long v20 = *((_OWORD *)v18 + 1);
        v18 -= 16;
        *(_OWORD *)uint64_t v17 = v19;
        *((_OWORD *)v17 + 1) = v20;
        v17 -= 16;
        LODWORD(v12) = v12 - 1;
      }
      while (v12 > v13);
    }
  }
  else
  {
    LODWORD(v13) = 0;
  }
LABEL_11:
  uint64_t v21 = (int8x8_t *)&a3[16 * v13];
  v21->i16[0] = a4;
  v21->i16[1] = a5;
  v21[1] = (int8x8_t)a6;
  _OWORD v21[2] = 0;
  uint64_t v22 = v21 + 2;
  int v23 = *(_DWORD *)(a1 + 16);
  if ((v23 & 0x80000) != 0) {
    unsigned int v24 = 8;
  }
  else {
    unsigned int v24 = 4;
  }
  if (v24 >= __n)
  {
    if (!__n || !__src) {
      goto LABEL_27;
    }
    size_t v29 = __n;
    unint64_t v30 = v22;
    char v31 = (__int32 *)__src;
LABEL_26:
    _TIFFmemcpy(v30, v31, v29);
LABEL_27:
    ++*a2;
    return 1;
  }
  unint64_t v25 = *(void *)(a1 + 904);
  if ((v23 & 0x80000) != 0) {
    unint64_t v26 = v25 + __n;
  }
  else {
    unint64_t v26 = (v25 + __n);
  }
  if (v26 >= v25 && v26 >= __n)
  {
    if (!_TIFFSeekOK(a1, *(void *)(a1 + 904))) {
      goto LABEL_35;
    }
    if ((v9 & 0x80000000) != 0)
    {
      uint64_t v28 = "libtiff does not allow writing more than 2147483647 bytes in a tag";
      goto LABEL_37;
    }
    if ((*(uint64_t (**)(void, uint64_t, void))(a1 + 1216))(*(void *)(a1 + 1200), __src, v9) != v9)
    {
LABEL_35:
      uint64_t v28 = "IO error writing tag data";
      goto LABEL_37;
    }
    *(void *)(a1 + 904) = (v26 & 1) + v26;
    int v34 = *(_DWORD *)(a1 + 16);
    if ((v34 & 0x80000) != 0)
    {
      int8x8_t *v22 = (int8x8_t)v25;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabLong8(v22);
      }
      goto LABEL_27;
    }
    __int32 v36 = v25;
    if ((v34 & 0x80) != 0) {
      TIFFSwabLong(&v36, v33);
    }
    char v31 = &v36;
    unint64_t v30 = v22;
    size_t v29 = 4;
    goto LABEL_26;
  }
  uint64_t v28 = "Maximum TIFF file size exceeded";
LABEL_37:
  TIFFErrorExtR(a1, "TIFFWriteDirectoryTagData", v28, a4, a5, a6, __n, __src, v35);
  return 0;
}

_DWORD *DoubleToRational(_DWORD *result, int *a2, double a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10)
{
  unint64_t v11 = result;
  if (a3 < 0.0)
  {
    *a2 = 0;
    *uint64_t result = 0;
    return (_DWORD *)TIFFErrorExt(0, "TIFFLib: DoubleToRational()", " Negative Value for Unsigned Rational given.", a5, a6, a7, a8, a9, a10);
  }
  if (a3 > 4294967300.0)
  {
    *uint64_t result = -1;
    *a2 = 0;
    return result;
  }
  if ((double)a3 == a3)
  {
    *uint64_t result = a3;
    int v13 = 1;
LABEL_11:
    *a2 = v13;
    return result;
  }
  if (a3 < 2.32830644e-10)
  {
    *uint64_t result = 0;
    int v13 = -1;
    goto LABEL_11;
  }
  unint64_t v26 = 0;
  unint64_t v27 = 0;
  unint64_t v24 = 0;
  unint64_t v25 = 0;
  ToRationalEuclideanGCD(0, 0, &v27, &v26, a3);
  uint64_t result = (_DWORD *)ToRationalEuclideanGCD(0, 1, &v25, &v24, a3);
  int v19 = v26;
  int v20 = v27;
  int v21 = v24;
  if (HIDWORD(v27) || HIDWORD(v26) || HIDWORD(v25) || HIDWORD(v24))
  {
    TIFFErrorExt(0, "TIFFLib: DoubleToRational()", " Num or Denom exceeds ULONG: val=%14.6f, num=%12llu, denom=%12llu | num2=%12llu, denom2=%12llu", v14, v15, v16, v17, v18, SLOBYTE(a3));
    __assert_rtn("DoubleToRational", "tif_dirwrite.c", 2811, "0");
  }
  double v22 = vabdd_f64(a3, (double)v27 / (double)v26);
  double v23 = vabdd_f64(a3, (double)v25 / (double)v24);
  if (v22 >= v23) {
    int v20 = v25;
  }
  *unint64_t v11 = v20;
  if (v22 >= v23) {
    int v19 = v21;
  }
  *a2 = v19;
  return result;
}

unint64_t ToRationalEuclideanGCD(int a1, int a2, unint64_t *a3, unint64_t *a4, double a5)
{
  unint64_t v5 = 0x3FFFFFFFFFFFFFFFLL;
  if (a2) {
    unint64_t v5 = 0x3FFFFFFFLL;
  }
  double v6 = (double)v5;
  unint64_t v7 = 0x7FFFFFFFLL;
  if (!a1) {
    unint64_t v7 = 0xFFFFFFFFLL;
  }
  double v8 = floor(a5);
  if (v6 <= a5 || v8 == a5)
  {
    unint64_t v10 = 1;
  }
  else
  {
    unint64_t v10 = 1;
    do
    {
      v10 *= 2;
      a5 = a5 + a5;
      double v11 = floor(a5);
    }
    while (a5 < v6 && a5 != v11 && v10 < v5);
  }
  unsigned int v14 = 0;
  unint64_t v15 = 0;
  uint64_t v16 = 0;
  unint64_t v17 = (unint64_t)a5;
  uint64_t v18 = 1;
  uint64_t v19 = 1;
  while (1)
  {
    unint64_t result = v10;
    unint64_t v21 = v17 / v10;
    unint64_t v22 = v18 + v21 * v15;
    if (v22 >= v7) {
      break;
    }
    unint64_t v23 = v16 + v21 * v19;
    if (v14 <= 0x3E)
    {
      unint64_t v10 = v17 - v21 * result;
      ++v14;
      unint64_t v17 = result;
      uint64_t v18 = v15;
      unint64_t v15 = v22;
      uint64_t v16 = v19;
      uint64_t v19 = v23;
      if (v10) {
        continue;
      }
    }
    goto LABEL_27;
  }
  unint64_t v24 = (v7 - v18) / v15;
  if (v21 <= 2 * v24)
  {
    unint64_t v22 = v18 + v24 * v15;
    unint64_t v23 = v16 + v24 * v19;
  }
  else
  {
    unint64_t v23 = v19;
    unint64_t v22 = v15;
  }
LABEL_27:
  while (v23 > v7 || v22 > v7)
  {
    v23 >>= 1;
    v22 >>= 1;
  }
  *a3 = v23;
  *a4 = v22;
  return result;
}

uint64_t TIFFWriteDirectoryTagCheckedShortArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, uint64_t __src)
{
  if ((a5 & 0x80000000) != 0) {
    TIFFWriteDirectoryTagCheckedShortArray_cold_1();
  }
  if (a3)
  {
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabArrayOfShort(__src, a5);
    }
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 3, a5, (2 * a5), __src);
  }
  else
  {
    unint64_t v13 = 2 * a5;
    unint64_t v14 = 8;
    if ((*(unsigned char *)(a1 + 18) & 8) == 0) {
      unint64_t v14 = 4;
    }
    if (v13 > v14) {
      *(void *)(a1 + 432) += v13;
    }
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedLong8Array(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, int8x8_t *__src, uint64_t a7, uint64_t a8)
{
  if (a5 >> 29) {
    TIFFWriteDirectoryTagCheckedLong8Array_cold_1();
  }
  int v9 = *(_DWORD *)(a1 + 16);
  if ((v9 & 0x80000) != 0)
  {
    if (a3)
    {
      if ((v9 & 0x80) != 0) {
        TIFFSwabArrayOfLong8(__src, a5);
      }
      return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 16, a5, (8 * a5), (uint64_t)__src);
    }
    else
    {
      if (a5 >= 2) {
        *(void *)(a1 + 432) += 8 * a5;
      }
      ++*a2;
      return 1;
    }
  }
  else
  {
    TIFFErrorExtR(a1, "TIFFWriteDirectoryTagCheckedLong8Array", "LONG8 not allowed for ClassicTIFF", a4, a5, (uint64_t)__src, a7, a8, v16);
    return 0;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedLongArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, __int32 *__src, uint8x8_t a7)
{
  if (a5 >> 30) {
    TIFFWriteDirectoryTagCheckedLongArray_cold_1();
  }
  if (a3)
  {
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabArrayOfLong(__src, a5, a7);
    }
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 4, a5, (4 * a5), (uint64_t)__src);
  }
  else
  {
    unint64_t v14 = 4 * a5;
    unint64_t v15 = 8;
    if ((*(unsigned char *)(a1 + 18) & 8) == 0) {
      unint64_t v15 = 4;
    }
    if (v14 > v15) {
      *(void *)(a1 + 432) += v14;
    }
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedIfdArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, __int32 *__src, uint8x8_t a7)
{
  if (a5 >> 30) {
    TIFFWriteDirectoryTagCheckedIfdArray_cold_1();
  }
  if (a3)
  {
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabArrayOfLong(__src, a5, a7);
    }
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 13, a5, (4 * a5), (uint64_t)__src);
  }
  else
  {
    unint64_t v14 = 4 * a5;
    unint64_t v15 = 8;
    if ((*(unsigned char *)(a1 + 18) & 8) == 0) {
      unint64_t v15 = 4;
    }
    if (v14 > v15) {
      *(void *)(a1 + 432) += v14;
    }
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedIfd8Array(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, int8x8_t *__src)
{
  if (a5 >> 29) {
    TIFFWriteDirectoryTagCheckedIfd8Array_cold_1();
  }
  int v7 = *(_DWORD *)(a1 + 16);
  if ((v7 & 0x80000) == 0) {
    TIFFWriteDirectoryTagCheckedIfd8Array_cold_2();
  }
  if (a3)
  {
    if ((v7 & 0x80) != 0) {
      TIFFSwabArrayOfLong8(__src, a5);
    }
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 18, a5, (8 * a5), (uint64_t)__src);
  }
  else
  {
    if (a5 >= 2) {
      *(void *)(a1 + 432) += 8 * a5;
    }
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedSlongArray(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, __int32 *__src, uint8x8_t a7)
{
  if (a5 >> 30) {
    TIFFWriteDirectoryTagCheckedSlongArray_cold_1();
  }
  if (a3)
  {
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabArrayOfLong(__src, a5, a7);
    }
    return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 9, a5, (4 * a5), (uint64_t)__src);
  }
  else
  {
    unint64_t v14 = 4 * a5;
    unint64_t v15 = 8;
    if ((*(unsigned char *)(a1 + 18) & 8) == 0) {
      unint64_t v15 = 4;
    }
    if (v14 > v15) {
      *(void *)(a1 + 432) += v14;
    }
    ++*a2;
    return 1;
  }
}

uint64_t TIFFWriteDirectoryTagCheckedSlong8Array(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, uint64_t a4, uint64_t a5, int8x8_t *__src, uint64_t a7, uint64_t a8)
{
  if (a5 >> 29) {
    TIFFWriteDirectoryTagCheckedSlong8Array_cold_1();
  }
  int v9 = *(_DWORD *)(a1 + 16);
  if ((v9 & 0x80000) != 0)
  {
    if (a3)
    {
      if ((v9 & 0x80) != 0) {
        TIFFSwabArrayOfLong8(__src, a5);
      }
      return TIFFWriteDirectoryTagData(a1, a2, a3, a4, 17, a5, (8 * a5), (uint64_t)__src);
    }
    else
    {
      if (a5 >= 2) {
        *(void *)(a1 + 432) += 8 * a5;
      }
      ++*a2;
      return 1;
    }
  }
  else
  {
    TIFFErrorExtR(a1, "TIFFWriteDirectoryTagCheckedSlong8Array", "SLONG8 not allowed for ClassicTIFF", a4, a5, (uint64_t)__src, a7, a8, v16);
    return 0;
  }
}

_DWORD *DoubleToSrational(_DWORD *result, int *a2, double a3)
{
  uint64_t v4 = result;
  if (a3 >= 0.0) {
    double v5 = a3;
  }
  else {
    double v5 = -a3;
  }
  if (a3 >= 0.0) {
    int v6 = 1;
  }
  else {
    int v6 = -1;
  }
  if (v5 <= 2147483650.0)
  {
    if (v5 == (double)(int)v5)
    {
      *unint64_t result = (int)(v5 * (double)v6);
      int v7 = 1;
    }
    else if (v5 >= 4.65661288e-10)
    {
      unint64_t v21 = 0;
      unint64_t v19 = 0;
      unint64_t v20 = 0;
      unint64_t v18 = 0;
      ToRationalEuclideanGCD(1, 0, &v21, &v20, v5);
      unint64_t result = (_DWORD *)ToRationalEuclideanGCD(1, 1, &v19, &v18, v5);
      int v13 = v21;
      int v7 = v20;
      int v14 = v18;
      if (v21 >> 31 || v20 >> 31 || v19 >> 31 || v18 >> 31)
      {
        double v17 = v5 * (double)v6;
        TIFFErrorExt(0, "TIFFLib: DoubleToSrational()", " Num or Denom exceeds LONG: val=%14.6f, num=%12llu, denom=%12llu | num2=%12llu, denom2=%12llu", v8, v9, v10, v11, v12, SLOBYTE(v17));
        __assert_rtn("DoubleToSrational", "tif_dirwrite.c", 2887, "0");
      }
      double v15 = vabdd_f64(v5, (double)v21 / (double)v20);
      double v16 = vabdd_f64(v5, (double)v19 / (double)v18);
      if (v15 >= v16) {
        int v13 = v19;
      }
      *uint64_t v4 = v6 * v13;
      if (v15 >= v16) {
        int v7 = v14;
      }
    }
    else
    {
      *unint64_t result = 0;
      int v7 = 0x7FFFFFFF;
    }
  }
  else
  {
    int v7 = 0;
    *unint64_t result = 0x7FFFFFFF;
  }
  *a2 = v7;
  return result;
}

uint64_t _WriteAsType(uint64_t a1, unint64_t a2, unint64_t a3)
{
  int v3 = *(unsigned __int16 *)(a1 + 120);
  uint64_t result = 1;
  if (v3 > 34886)
  {
    if ((v3 - 50000) < 3 || v3 == 34887 || v3 == 34925) {
      return a2 >= a3 / 0xA;
    }
  }
  else
  {
    if (v3 > 6)
    {
      if ((v3 - 7) >= 2 && v3 != 32946) {
        return result;
      }
      return a2 >= a3 / 0xA;
    }
    if (v3 == 1) {
      return a2 > a3;
    }
    if (v3 == 5) {
      return a2 >= a3 / 0xA;
    }
  }
  return result;
}

void ATXReadPlugin::ATXReadPlugin(uint64_t a1, uint64_t a2)
{
}

uint64_t ATXReadPlugin::loadDataFromXPCObject(ATXReadPlugin *this, void *a2)
{
  uint64_t DataFromXPCObject = CommonASTCReadPlugin::loadDataFromXPCObject(this, a2);
  if (!DataFromXPCObject)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_atx", &length);
    if (length == 152)
    {
      uint64_t DataFromXPCObject = 0;
      long long v6 = data[1];
      *(_OWORD *)((char *)this + 488) = *data;
      *(_OWORD *)((char *)this + 504) = v6;
      long long v7 = data[2];
      long long v8 = data[3];
      long long v9 = data[5];
      *(_OWORD *)((char *)this + 552) = data[4];
      *(_OWORD *)((char *)this + 568) = v9;
      *(_OWORD *)((char *)this + 520) = v7;
      *(_OWORD *)((char *)this + 536) = v8;
      long long v10 = data[6];
      long long v11 = data[7];
      long long v12 = data[8];
      *((void *)this + 79) = *((void *)data + 18);
      *(_OWORD *)((char *)this + 600) = v11;
      *(_OWORD *)((char *)this + 616) = v12;
      *(_OWORD *)((char *)this + 584) = v10;
    }
    else
    {
      uint64_t DataFromXPCObject = 4294967246;
    }
    (*(void (**)(void, void *))(**((void **)this + 59) + 16))(*((void *)this + 59), a2);
  }
  return DataFromXPCObject;
}

uint64_t ATXReadPlugin::saveDataToXPCObject(ATXReadPlugin *this, void *a2)
{
  uint64_t v4 = CommonASTCReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4)
  {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_atx", (char *)this + 488, 0x98uLL);
    (*(void (**)(void, void *))(**((void **)this + 59) + 24))(*((void *)this + 59), a2);
  }
  return v4;
}

__n128 __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 40) = &unk_1ED4DE450;
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  long long v4 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 93) = *(_OWORD *)(a2 + 93);
  *(_OWORD *)(a1 + 64) = v3;
  *(_OWORD *)(a1 + 80) = v4;
  *(__n128 *)(a1 + 48) = result;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
}

vImage_Error ATXReadPlugin::decodeImageData(ATXReadPlugin *this, unsigned __int8 *a2)
{
  if (*((void *)this + 73) || *((void *)this + 76)) {
    return ATXReadPlugin::decodeImageData420f(this, a2);
  }
  if (*((void *)this + 72)) {
    return ATXReadPlugin::decodeImageDataASTC(this, a2);
  }
  return 4294967292;
}

vImage_Error ATXReadPlugin::decodeImageData420f(ATXReadPlugin *this, unsigned __int8 *a2)
{
  vImagePixelCount v4 = *((unsigned int *)this + 73);
  vImagePixelCount v5 = *((unsigned int *)this + 74);
  size_t v6 = *((unsigned int *)this + 75);
  int v27 = 197121;
  int v26 = 66051;
  size_t v7 = *((unsigned int *)this + 150);
  size_t v8 = *((unsigned int *)this + 149);
  unint64_t v9 = v7 * (unint64_t)v8;
  if ((v9 & 0xFFFFFFFF00000000) != 0)
  {
    _cg_jpeg_mem_term("decodeImageData420f", 600, "*** ERROR: lumaPlaneSize overflow [%ld * %ld]\n");
    return 4294967292;
  }
  unint64_t v10 = *((unsigned int *)this + 156) * (unint64_t)*((unsigned int *)this + 155);
  if ((v10 & 0xFFFFFFFF00000000) != 0)
  {
    _cg_jpeg_mem_term("decodeImageData420f", 603, "*** ERROR: chromaPlaneSize overflow [%ld * %ld]\n");
    return 4294967292;
  }
  int v11 = *((unsigned __int8 *)this + 405);
  long long v12 = (unsigned __int8 *)malloc_type_calloc(v7, v8, 0x67AE71A9uLL);
  if (*((unsigned char *)this + 632))
  {
    int v13 = (unsigned __int8 *)malloc_type_malloc(*((unsigned int *)this + 151), 0x22EEF814uLL);
    size_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v13, *((void *)this + 73) + 8, *((unsigned int *)this + 151));
    if (BytesAtOffset == *((_DWORD *)this + 151))
    {
      IIOReadPlugin::decodeLZFSEIntoBuffer(this, v13, BytesAtOffset, v12, v9);
      goto LABEL_8;
    }
    _cg_jpeg_mem_term("decodeImageData420f", 614, "*** luma-lzfseBuffer-getBytesAtOffset failed: expected: %ld   got: %ld\n");
LABEL_30:
    double v15 = 0;
    goto LABEL_32;
  }
  if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v12, *((void *)this + 73), v9) != v9)
  {
    _cg_jpeg_mem_term("decodeImageData420f", 620, "*** luma-getBytesAtOffset failed: expected: %ld   got: %ld\n");
    goto LABEL_30;
  }
  int v13 = 0;
LABEL_8:
  double v15 = (unsigned __int8 *)malloc_type_calloc(*((unsigned int *)this + 156), *((unsigned int *)this + 155), 0x39919F84uLL);
  if (*((unsigned char *)this + 632))
  {
    int v13 = (unsigned __int8 *)reallocf(v13, *((unsigned int *)this + 157));
    size_t v16 = IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v13, *((void *)this + 76) + 8, *((unsigned int *)this + 157));
    if (v16 == *((_DWORD *)this + 157))
    {
      IIOReadPlugin::decodeLZFSEIntoBuffer(this, v13, v16, v15, v10);
      goto LABEL_12;
    }
    _cg_jpeg_mem_term("decodeImageData420f", 632, "*** chroma-lzfseBuffer-getBytesAtOffset failed: expected: %ld   got: %ld\n");
  }
  else
  {
    if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v15, *((void *)this + 76), v10) == v10)
    {
LABEL_12:
      if (v13) {
        free(v13);
      }
      uint64_t v17 = *((void *)this + 74);
      v18.i64[0] = v17;
      v18.i64[1] = HIDWORD(v17);
      *(int8x16_t *)&srcYp.vImagePixelCount height = vextq_s8(v18, v18, 8uLL);
      srcYp.size_t rowBytes = *((unsigned int *)this + 150);
      dest.size_t rowBytes = v6;
      srcCbCr.data = v15;
      uint64_t v19 = *((void *)this + 77);
      v18.i64[0] = v19;
      v18.i64[1] = HIDWORD(v19);
      *(int8x16_t *)&srcCbCr.vImagePixelCount height = vextq_s8(v18, v18, 8uLL);
      srcCbCr.size_t rowBytes = *((unsigned int *)this + 156);
      srcYp.data = v12;
      dest.vImagePixelCount height = v5;
      dest.vImagePixelCount width = v4;
      dest.data = a2;
      if (ATXReadPlugin::decodeImageData420f(unsigned char *,unsigned long)::YpCbCrToARGBCreate != -1) {
        dispatch_once(&ATXReadPlugin::decodeImageData420f(unsigned char *,unsigned long)::YpCbCrToARGBCreate, &__block_literal_global_10);
      }
      if (v11) {
        unint64_t v20 = &v27;
      }
      else {
        unint64_t v20 = &v26;
      }
      vImage_Error v21 = vImageConvert_420Yp8_CbCr8ToARGB8888(&srcYp, &srcCbCr, &dest, &ATXReadPlugin::decodeImageData420f(unsigned char *,unsigned long)::conversion, (const uint8_t *)v20, 0xFFu, 0);
      if (!v12) {
        goto LABEL_21;
      }
      goto LABEL_20;
    }
    _cg_jpeg_mem_term("decodeImageData420f", 638, "*** chroma-getBytesAtOffset failed: expected: %ld   got: %ld\n");
  }
LABEL_32:
  vImage_Error v21 = 4294967292;
  if (v12) {
LABEL_20:
  }
    free(v12);
LABEL_21:
  if (v15) {
    free(v15);
  }
  return v21;
}

uint64_t ATXReadPlugin::decodeImageDataASTC(ATXReadPlugin *this, unsigned __int8 *a2)
{
  vImagePixelCount v4 = (void *)*((void *)this + 59);
  if (v4) {
  vImagePixelCount v5 = *((unsigned int *)this + 65);
  }
  vImagePixelCount v6 = *((unsigned int *)this + 66);
  size_t v7 = *((unsigned int *)this + 75);
  v10.data = a2;
  v10.vImagePixelCount height = v6;
  v10.vImagePixelCount width = v5;
  v10.size_t rowBytes = v7;
  size_t v8 = (IIOImageReadSession *)*((void *)this + 3);
  if (v8) {
    return ASTCTextureImp::decodeASTCtoRGBX((ASTCTextureImp *)v4, v8, &v10, *((unsigned __int8 *)this + 310), *((unsigned char *)this + 405) == 0);
  }
  else {
    return 4294967292;
  }
}

__n128 ___ZN13ATXReadPlugin19decodeImageData420fEPhm_block_invoke()
{
  vImage_YpCbCrPixelRange pixelRange = *(vImage_YpCbCrPixelRange *)ymmword_188990DC8;
  *(_OWORD *)&matrix.Yp = xmmword_188990DE8;
  matrix.Cb_B = 1.772;
  vImage_Error v0 = vImageConvert_YpCbCrToARGB_GenerateConversion(&matrix, &pixelRange, &ATXReadPlugin::decodeImageData420f(unsigned char *,unsigned long)::conversion, kvImage422YpCbYpCr8, kvImageARGB8888, 0);
  if (v0)
  {
    vImage_Error v2 = v0;
    long long v3 = IIO_vImageErrorString(v0);
    return _cg_jpeg_mem_term("decodeImageData420f_block_invoke", 675, "*** ERROR: vImageConvert_YpCbCrToARGB_GenerateConversion returned %ld (%s)\n", v2, v3);
  }
  return result;
}

vImage_Error ATXReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  memory_object_size_t v40 = 0;
  if ((gIIODebugFlags & 0x20000) == 0) {
    goto LABEL_26;
  }
  int v8 = *((_DWORD *)this + 51);
  unsigned int v9 = v8 >> 24;
  uint64_t v10 = MEMORY[0x1E4F14390];
  if (v8 < 0)
  {
    int v11 = __maskrune(v9, 0x40000uLL);
    int v8 = *((_DWORD *)this + 51);
  }
  else
  {
    int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
  }
  if (v11) {
    uint64_t v12 = (v8 >> 24);
  }
  else {
    uint64_t v12 = 46;
  }
  unsigned int v13 = v8 << 8 >> 24;
  if (v8 << 8 < 0)
  {
    int v14 = __maskrune(v13, 0x40000uLL);
    int v8 = *((_DWORD *)this + 51);
  }
  else
  {
    int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
  }
  if (v14) {
    uint64_t v15 = (v8 << 8 >> 24);
  }
  else {
    uint64_t v15 = 46;
  }
  unsigned int v16 = (__int16)v8 >> 8;
  if (v8 << 16 < 0)
  {
    int v17 = __maskrune(v16, 0x40000uLL);
    int v8 = *((_DWORD *)this + 51);
  }
  else
  {
    int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  }
  if (v17) {
    uint64_t v18 = ((__int16)v8 >> 8);
  }
  else {
    uint64_t v18 = 46;
  }
  if ((v8 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0) {
      goto LABEL_22;
    }
LABEL_24:
    uint64_t v19 = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v8, 0x40000uLL)) {
    goto LABEL_24;
  }
LABEL_22:
  uint64_t v19 = *((char *)this + 204);
LABEL_25:
  ImageIOLog("  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus ATXReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  unint64_t v20 = (IIOImageRead **)*((void *)this + 3);
  if (v20) {
    BOOL v21 = IIOImageReadSession::mapData(v20);
  }
  else {
    BOOL v21 = 0;
  }
  if (a3 == 3)
  {
    vImage_Error BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v28) = *((_DWORD *)this + 73);
    double v27 = (double)v28;
    unsigned int v29 = *((_DWORD *)this + 74);
    double v26 = (double)v29;
    memory_object_size_t v25 = *((unsigned int *)this + 75) * (unint64_t)v29;
    BaseAddress = (void *)_ImageIO_Malloc(v25, *((void *)this + 48), &v40, (uint64_t)kImageMalloc_ATX_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4) {
      goto LABEL_51;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    size_t Height = IOSurfaceGetHeight(*a4);
    vImage_Error BlockArray = 0;
    memory_object_size_t v25 = IOSurfaceGetBytesPerRow(*a4) * Height;
    memory_object_size_t v40 = v25;
    double v26 = 0.0;
    double v27 = 0.0;
  }
  if (!BaseAddress) {
    goto LABEL_52;
  }
  memset(BaseAddress, 255, v25);
  if (*((void *)this + 73) || *((void *)this + 76))
  {
    vImage_Error BlockArray = ATXReadPlugin::decodeImageData420f(this, (unsigned __int8 *)BaseAddress);
    goto LABEL_39;
  }
  if (!*((void *)this + 72))
  {
LABEL_39:
    if (BlockArray) {
      goto LABEL_40;
    }
    goto LABEL_49;
  }
  vImage_Error BlockArray = ATXReadPlugin::decodeImageDataASTC(this, (unsigned __int8 *)BaseAddress);
  if (BlockArray)
  {
LABEL_40:
    *((_DWORD *)this + 26) = 0;
    if (a3 == 3)
    {
      _ImageIO_Free((unint64_t)BaseAddress, v40);
      if (!v21) {
        return BlockArray;
      }
      goto LABEL_53;
    }
LABEL_52:
    if (!v21) {
      return BlockArray;
    }
    goto LABEL_53;
  }
  if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 152) == 8 && *((unsigned char *)this + 406) == 1)
  {
    vImagePixelCount v30 = *((unsigned int *)this + 74);
    dest.data = BaseAddress;
    dest.vImagePixelCount height = v30;
    size_t v31 = *((unsigned int *)this + 75);
    dest.vImagePixelCount width = *((unsigned int *)this + 73);
    dest.size_t rowBytes = v31;
    vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
  }
LABEL_49:
  if (a3 != 3)
  {
    IOSurfaceUnlock(*a4, 0, 0);
LABEL_51:
    vImage_Error BlockArray = 0;
    goto LABEL_52;
  }
  uint64_t v34 = 0;
  v41.origin.x = 0.0;
  v41.origin.y = 0.0;
  v41.size.vImagePixelCount width = v27;
  v41.size.vImagePixelCount height = v26;
  **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v25, v41, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
  if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E4F1DB20]))
  {
    uint64_t v35 = 0;
  }
  else
  {
    v42.origin.x = 0.0;
    v42.origin.y = 0.0;
    v42.size.vImagePixelCount width = v27;
    v42.size.vImagePixelCount height = v26;
    *(CGRect *)(&v35 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v42);
    uint64_t v34 = v36;
    double v27 = v37;
    double v26 = v38;
  }
  vImage_Error BlockArray = 0;
  *((void *)this + 15) = v34;
  *((void *)this + 16) = v35;
  *((double *)this + 17) = v27;
  *((double *)this + 18) = v26;
  if (v21)
  {
LABEL_53:
    unsigned int v32 = (const char **)*((void *)this + 3);
    if (v32) {
      IIOImageReadSession::unmapData(v32);
    }
  }
  return BlockArray;
}

void setByteArray(void *a1, char **a2, const void *a3, int64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v13 = *a2;
  if (v13)
  {
    _TIFFfreeExt((uint64_t)a1, v13);
    *a2 = 0;
  }
  if (a3)
  {
    uint64_t v20 = _TIFFMultiplySSize(0, a4, a5, 0, a5, a6, a7, a8);
    if (v20)
    {
      BOOL v21 = (char *)_TIFFmallocExt(a1, v20, v14, v15, v16, v17, v18, v19);
      *a2 = v21;
      if (!v21) {
        return;
      }
    }
    else
    {
      BOOL v21 = *a2;
      if (!*a2) {
        return;
      }
    }
    _TIFFmemcpy(v21, a3, v20);
  }
}

void _TIFFsetByteArrayExt(void *a1, char **a2, const void *a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void _TIFFsetShortArrayExt(void *a1, char **a2, const void *a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

uint64_t _cg_TIFFSetField(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return TIFFVSetField(a1, a2, (uint64_t)&a9);
}

uint64_t TIFFVSetField(uint64_t a1, uint64_t a2, uint64_t a3)
{
  vImagePixelCount v6 = TIFFFindField((void *)a1, a2, 0);
  if (!v6)
  {
    TIFFErrorExtR(a1, "TIFFSetField", "%s: Unknown %stag %u", v7, v8, v9, v10, v11, *(void *)a1);
    return 0;
  }
  if (a2 != 257 && (*(unsigned char *)(a1 + 16) & 0x40) != 0 && !*((unsigned char *)v6 + 26))
  {
    TIFFErrorExtR(a1, "TIFFSetField", "%s: Cannot modify tag \"%s\" while writing", v7, v8, v9, v10, v11, *(void *)a1);
    return 0;
  }
  uint64_t v12 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 1280);

  return v12(a1, a2, a3);
}

uint64_t _cg_TIFFGetField(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  return TIFFVGetField(a1, a2, (uint64_t)&a9);
}

uint64_t TIFFVGetField(void *a1, uint64_t a2, uint64_t a3)
{
  vImagePixelCount v6 = TIFFFindField(a1, a2, 0);
  if (!v6
    || !WORD1(a2)
    && ((*(_DWORD *)((char *)a1 + ((*((unsigned __int16 *)v6 + 12) >> 3) & 0x1FFCLL) + 72) >> *((_WORD *)v6 + 12)) & 1) == 0)
  {
    return 0;
  }
  uint64_t v7 = (uint64_t (*)(void *, uint64_t, uint64_t))a1[161];

  return v7(a1, a2, a3);
}

void _cg_TIFFFreeDirectory(uint64_t a1)
{
  _TIFFmemset((void *)(a1 + 72), 0, 0x10uLL);
  vImage_Error v2 = *(char **)(a1 + 144);
  if (v2)
  {
    _TIFFfreeExt(a1, v2);
    *(void *)(a1 + 144) = 0;
  }
  long long v3 = *(char **)(a1 + 152);
  if (v3)
  {
    _TIFFfreeExt(a1, v3);
    *(void *)(a1 + 152) = 0;
  }
  vImagePixelCount v4 = *(char **)(a1 + 184);
  if (v4)
  {
    _TIFFfreeExt(a1, v4);
    *(void *)(a1 + 184) = 0;
  }
  vImagePixelCount v5 = *(char **)(a1 + 192);
  if (v5)
  {
    _TIFFfreeExt(a1, v5);
    *(void *)(a1 + 192) = 0;
  }
  vImagePixelCount v6 = *(char **)(a1 + 200);
  if (v6)
  {
    _TIFFfreeExt(a1, v6);
    *(void *)(a1 + 200) = 0;
  }
  uint64_t v7 = *(char **)(a1 + 216);
  if (v7)
  {
    _TIFFfreeExt(a1, v7);
    *(void *)(a1 + 216) = 0;
  }
  uint64_t v8 = *(char **)(a1 + 328);
  if (v8)
  {
    _TIFFfreeExt(a1, v8);
    *(void *)(a1 + 328) = 0;
  }
  uint64_t v9 = *(char **)(a1 + 384);
  if (v9)
  {
    _TIFFfreeExt(a1, v9);
    *(void *)(a1 + 384) = 0;
  }
  uint64_t v10 = *(char **)(a1 + 368);
  if (v10)
  {
    _TIFFfreeExt(a1, v10);
    *(void *)(a1 + 368) = 0;
  }
  uint64_t v11 = *(char **)(a1 + 344);
  if (v11)
  {
    _TIFFfreeExt(a1, v11);
    *(void *)(a1 + 344) = 0;
  }
  uint64_t v12 = *(char **)(a1 + 352);
  if (v12)
  {
    _TIFFfreeExt(a1, v12);
    *(void *)(a1 + 352) = 0;
  }
  unsigned int v13 = *(char **)(a1 + 360);
  if (v13)
  {
    _TIFFfreeExt(a1, v13);
    *(void *)(a1 + 360) = 0;
  }
  uint64_t v14 = *(char **)(a1 + 232);
  if (v14)
  {
    _TIFFfreeExt(a1, v14);
    *(void *)(a1 + 232) = 0;
  }
  uint64_t v15 = *(char **)(a1 + 240);
  if (v15)
  {
    _TIFFfreeExt(a1, v15);
    *(void *)(a1 + 240) = 0;
  }
  *(_DWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 76) &= 0xFFFFFE7F;
  int v16 = *(_DWORD *)(a1 + 408);
  if (v16 >= 1)
  {
    uint64_t v17 = 0;
    uint64_t v18 = 16;
    do
    {
      uint64_t v19 = *(char **)(*(void *)(a1 + 416) + v18);
      if (v19)
      {
        _TIFFfreeExt(a1, v19);
        int v16 = *(_DWORD *)(a1 + 408);
      }
      ++v17;
      v18 += 24;
    }
    while (v17 < v16);
  }
  *(_DWORD *)(a1 + 408) = 0;
  uint64_t v20 = *(char **)(a1 + 416);
  if (v20)
  {
    _TIFFfreeExt(a1, v20);
    *(void *)(a1 + 416) = 0;
  }
  BOOL v21 = *(char **)(a1 + 400);
  if (v21)
  {
    _TIFFfreeExt(a1, v21);
    *(void *)(a1 + 400) = 0;
  }
  _TIFFmemset((void *)(a1 + 256), 0, 0x20uLL);
  _TIFFmemset((void *)(a1 + 288), 0, 0x20uLL);
  *(void *)(a1 + 432) = 0;
  *(void *)(a1 + 440) = 0;
  unint64_t v22 = *(char **)(a1 + 456);
  if (v22)
  {
    _TIFFfreeExt(a1, v22);
    *(void *)(a1 + 456) = 0;
    *(_DWORD *)(a1 + 448) = 0;
  }
}

uint64_t TIFFCreateDirectory(uint64_t a1)
{
  *(void *)(a1 + 888) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 876) = -1;
  *(_DWORD *)(a1 + 884) = -1;
  return 0;
}

uint64_t TIFFDefaultDirectory(uint64_t a1)
{
  vImage_Error v2 = (void *)(a1 + 72);
  long long v3 = _TIFFGetFields();
  _TIFFSetupFields(a1, (uint64_t)v3, v4, v5, v6, v7, v8, v9, v22);
  _TIFFmemset(v2, 0, 0x188uLL);
  *(void *)(a1 + 124) = 0x1000100010001;
  *(void *)(a1 + 132) = 0x10000FFFFFFFFLL;
  *(_DWORD *)(a1 + 168) = 65538;
  *(_OWORD *)(a1 + 96) = xmmword_188990E10;
  *(_DWORD *)(a1 + 336) = 131074;
  *(_WORD *)(a1 + 340) = 1;
  *(void *)(a1 + 1248) = _TIFFNoPostDecode;
  *(void *)(a1 + 1272) = 0;
  *(void *)(a1 + 1280) = _TIFFVSetField;
  *(void *)(a1 + 1288) = _TIFFVGetField;
  *(void *)(a1 + 1296) = 0;
  *(_WORD *)(a1 + 120) = 1;
  *(void *)(a1 + 112) = 0x1000100000000;
  *(_WORD *)(a1 + 212) = 0;
  *(void *)(a1 + 216) = 0;
  unint64_t v16 = *(void *)(a1 + 1320);
  if (v16)
  {
    uint64_t v17 = 0;
    uint64_t v18 = (void *)(a1 + 1312);
    unsigned int v19 = 1;
    do
    {
      if (*(_DWORD *)(*v18 + 24 * v17 + 4))
      {
        _TIFFfreeExt(a1, *(char **)(*v18 + 24 * v17 + 16));
        unint64_t v16 = *(void *)(a1 + 1320);
      }
      uint64_t v17 = v19;
    }
    while (v16 > v19++);
    _TIFFfreeExt(a1, *(char **)(a1 + 1312));
    *uint64_t v18 = 0;
    *(void *)(a1 + 1320) = 0;
  }
  if (_TIFFextender) {
    _TIFFextender(a1);
  }
  _cg_TIFFSetField(a1, 259, v10, v11, v12, v13, v14, v15, 1);
  *(_DWORD *)(a1 + 16) &= 0xFFFFFBF7;
  return 1;
}

uint64_t _TIFFVSetField(uint64_t a1, int a2, unsigned __int16 *a3)
{
  v208 = a3;
  unsigned int v207 = 0;
  uint64_t v6 = TIFFFindField((void *)a1, a2, 0);
  if (!v6) {
    return 0;
  }
  uint64_t v12 = (uint64_t)v6;
  uint64_t v13 = (unsigned char *)(a1 + 72);
  int v14 = *((unsigned __int16 *)v6 + 12);
  if (v14 == 65) {
    int v15 = 0;
  }
  else {
    int v15 = a2;
  }
  if (v15 <= 319)
  {
    switch(v15)
    {
      case 254:
        unint64_t v16 = v208;
        v208 += 4;
        *(_DWORD *)(a1 + 112) = *(_DWORD *)v16;
        goto LABEL_158;
      case 256:
        uint64_t v50 = v208;
        v208 += 4;
        *(_DWORD *)(a1 + 88) = *(_DWORD *)v50;
        goto LABEL_158;
      case 257:
        uint64_t v51 = v208;
        v208 += 4;
        *(_DWORD *)(a1 + 92) = *(_DWORD *)v51;
        goto LABEL_158;
      case 258:
        uint64_t v52 = v208;
        v208 += 4;
        int v53 = *(_DWORD *)v52;
        *(_WORD *)(a1 + 116) = v53;
        if ((*(unsigned char *)(a1 + 16) & 0x80) == 0) {
          goto LABEL_158;
        }
        uint64_t v17 = 1;
        if ((unsigned __int16)v53 > 0x1Fu)
        {
          if ((unsigned __int16)v53 == 32) {
            goto LABEL_164;
          }
          if ((unsigned __int16)v53 == 64 || (unsigned __int16)v53 == 128)
          {
            uint64_t v54 = (uint64_t (*)())_TIFFSwab64BitData;
            goto LABEL_175;
          }
        }
        else
        {
          switch((unsigned __int16)v53)
          {
            case 8u:
              uint64_t v54 = _TIFFNoPostDecode;
              goto LABEL_175;
            case 0x10u:
              goto LABEL_163;
            case 0x18u:
              uint64_t v54 = (uint64_t (*)())_TIFFSwab24BitData;
              goto LABEL_175;
          }
        }
        goto LABEL_159;
      case 259:
        int v71 = v208;
        v208 += 4;
        int v72 = *(_DWORD *)v71;
        if ((*v13 & 0x80) == 0) {
          goto LABEL_68;
        }
        if (*(unsigned __int16 *)(a1 + 120) == (unsigned __int16)v72) {
          goto LABEL_158;
        }
        (*(void (**)(uint64_t))(a1 + 1072))(a1);
        *(_DWORD *)(a1 + 16) &= ~0x20u;
LABEL_68:
        uint64_t v17 = TIFFSetCompressionScheme(a1, (unsigned __int16)v72);
        if (!v17) {
          return v17;
        }
        *(_WORD *)(a1 + 120) = v72;
        goto LABEL_159;
      case 262:
        uint64_t v55 = v208;
        v208 += 4;
        *(_WORD *)(a1 + 122) = *(_DWORD *)v55;
        goto LABEL_158;
      case 263:
        uint64_t v56 = v208;
        v208 += 4;
        *(_WORD *)(a1 + 124) = *(_DWORD *)v56;
        goto LABEL_158;
      case 266:
        unint64_t v57 = v208;
        v208 += 4;
        int v58 = *(_DWORD *)v57;
        if ((unsigned __int16)v58 - 3 < 0xFFFFFFFE) {
          goto LABEL_140;
        }
        *(_WORD *)(a1 + 126) = v58;
        goto LABEL_158;
      case 274:
        int v73 = v208;
        v208 += 4;
        int v74 = *(_DWORD *)v73;
        if ((unsigned __int16)v74 - 9 < 0xFFFFFFF8) {
          goto LABEL_140;
        }
        *(_WORD *)(a1 + 128) = v74;
        goto LABEL_158;
      case 277:
        unint64_t v59 = v208;
        v208 += 4;
        int v60 = *(_DWORD *)v59;
        int v61 = (unsigned __int16)*(_DWORD *)v59;
        if (!(unsigned __int16)*(_DWORD *)v59) {
          goto LABEL_140;
        }
        if (*(unsigned __int16 *)(a1 + 130) != (unsigned __int16)v60)
        {
          if (*(void *)(a1 + 144))
          {
            TIFFWarningExtR(a1, "_TIFFVSetField", "SamplesPerPixel tag value is changing, but SMinSampleValue tag was read with a different value. Canceling it", v7, v8, v9, v10, v11, v205);
            *(_DWORD *)(a1 + 76) &= ~2u;
            _TIFFfreeExt(a1, *(char **)(a1 + 144));
            *(void *)(a1 + 144) = 0;
          }
          if (*(void *)(a1 + 152))
          {
            TIFFWarningExtR(a1, "_TIFFVSetField", "SamplesPerPixel tag value is changing, but SMaxSampleValue tag was read with a different value. Canceling it", v7, v8, v9, v10, v11, v205);
            *(_DWORD *)(a1 + 76) &= ~4u;
            _TIFFfreeExt(a1, *(char **)(a1 + 152));
            *(void *)(a1 + 152) = 0;
          }
          if (*(void *)(a1 + 344))
          {
            int v62 = *(unsigned __int16 *)(a1 + 212);
            if ((v61 - v62) >= 2 && *(unsigned __int16 *)(a1 + 130) - v62 <= 1)
            {
              TIFFWarningExtR(a1, "_TIFFVSetField", "SamplesPerPixel tag value is changing, but TransferFunction was read with a different value. Canceling it", v7, v8, v9, v10, v11, v205);
              *(_DWORD *)(a1 + 76) &= ~0x1000u;
              _TIFFfreeExt(a1, *(char **)(a1 + 344));
              *(void *)(a1 + 344) = 0;
            }
          }
        }
        *(_WORD *)(a1 + 130) = v60;
        goto LABEL_158;
      case 278:
        int v75 = v208;
        v208 += 4;
        unsigned int v76 = *(_DWORD *)v75;
        if (!v76) {
          goto LABEL_133;
        }
        unsigned int v77 = *(_DWORD *)(a1 + 92);
        if (v76 > v77 && v77 != 0) {
          unsigned int v76 = *(_DWORD *)(a1 + 92);
        }
        *(_DWORD *)(a1 + 132) = v76;
        if ((*(unsigned char *)(a1 + 72) & 4) == 0)
        {
          *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 88);
          *(_DWORD *)(a1 + 104) = v76;
        }
        goto LABEL_158;
      case 280:
        uint64_t v63 = v208;
        v208 += 4;
        *(_WORD *)(a1 + 136) = *(_DWORD *)v63;
        goto LABEL_158;
      case 281:
        int v79 = v208;
        v208 += 4;
        *(_WORD *)(a1 + 138) = *(_DWORD *)v79;
        goto LABEL_158;
      case 282:
        uint64_t v80 = (double *)v208;
        v208 += 4;
        if (*v80 < 0.0) {
          goto LABEL_84;
        }
        *(float *)(a1 + 160) = _TIFFClampDoubleToFloat(*v80);
        goto LABEL_158;
      case 283:
        int64_t v81 = (double *)v208;
        v208 += 4;
        if (*v81 < 0.0)
        {
LABEL_84:
          TIFFFieldWithTag((void *)a1, a2);
          TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Bad value %f for \"%s\" tag", v130, v131, v132, v133, v134, *(void *)a1);
          return 0;
        }
        *(float *)(a1 + 164) = _TIFFClampDoubleToFloat(*v81);
        break;
      case 284:
        uint64_t v64 = v208;
        v208 += 4;
        int v65 = *(_DWORD *)v64;
        if ((unsigned __int16)v65 - 3 < 0xFFFFFFFE) {
          goto LABEL_140;
        }
        *(_WORD *)(a1 + 170) = v65;
        goto LABEL_158;
      case 286:
        uint64_t v66 = (double *)v208;
        v208 += 4;
        *(float *)(a1 + 172) = _TIFFClampDoubleToFloat(*v66);
        goto LABEL_158;
      case 287:
        uint64_t v67 = (double *)v208;
        v208 += 4;
        *(float *)(a1 + 176) = _TIFFClampDoubleToFloat(*v67);
        goto LABEL_158;
      case 296:
        uint8x8_t v68 = v208;
        v208 += 4;
        int v69 = *(_DWORD *)v68;
        if ((unsigned __int16)v69 - 4 < 0xFFFFFFFD) {
          goto LABEL_140;
        }
        *(_WORD *)(a1 + 168) = v69;
        goto LABEL_158;
      case 297:
        unint64_t v70 = v208;
        v208 += 4;
        *(_WORD *)(a1 + 180) = *(_DWORD *)v70;
        v208 = v70 + 8;
        *(_WORD *)(a1 + 182) = *((_DWORD *)v70 + 2);
        goto LABEL_158;
      case 301:
        unint64_t v82 = 0;
        if (*(unsigned __int16 *)(a1 + 130) - *(unsigned __int16 *)(a1 + 212) <= 1) {
          int v83 = 1;
        }
        else {
          int v83 = 3;
        }
        unsigned int v207 = v83;
        int v84 = (char **)(a1 + 344);
        do
        {
          uint64_t v85 = (const void **)v208;
          v208 += 4;
          uint64_t v17 = 1;
          setByteArray((void *)a1, v84, *v85, 1 << *(_WORD *)(a1 + 116), 2, v9, v10, v11);
          ++v82;
          ++v84;
        }
        while (v82 < v207);
        goto LABEL_159;
      default:
        goto LABEL_125;
    }
    goto LABEL_158;
  }
  if (v15 > 530)
  {
    if (v15 > 32994)
    {
      switch(v15)
      {
        case 32995:
          vImagePixelCount v30 = v208;
          v208 += 4;
          LODWORD(v30) = (unsigned __int16)*(_DWORD *)v30;
          *(_WORD *)(a1 + 212) = v30 != 0;
          uint64_t v17 = 1;
          if (!v30) {
            goto LABEL_159;
          }
          LOWORD(__src) = 1;
          memory_object_size_t v25 = (char **)(a1 + 216);
          p_at_texel_region_t src = &__src;
          unint64_t v28 = (void *)a1;
          int64_t v29 = 1;
LABEL_15:
          uint64_t v31 = 2;
          goto LABEL_30;
        case 32996:
          CGRect v42 = v208;
          v208 += 4;
          int v43 = *(_DWORD *)v42;
          if ((v43 & 0xFFFC) == 0)
          {
            *(_WORD *)(a1 + 118) = 0x3000100020004uLL >> (16 * v43);
            goto LABEL_158;
          }
LABEL_140:
          TIFFFieldWithTag((void *)a1, a2);
          uint64_t v129 = *(const char **)a1;
          goto LABEL_141;
        case 32997:
          unsigned int v44 = v208;
          v208 += 4;
          *(_DWORD *)(a1 + 96) = *(_DWORD *)v44;
          goto LABEL_158;
        case 32998:
          uint64_t v45 = v208;
          v208 += 4;
          int v46 = *(_DWORD *)v45;
          if (v46)
          {
            *(_DWORD *)(a1 + 108) = v46;
            goto LABEL_158;
          }
LABEL_133:
          TIFFFieldWithTag((void *)a1, a2);
          uint64_t v129 = *(const char **)a1;
LABEL_141:
          TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Bad value %u for \"%s\" tag", v124, v125, v126, v127, v128, (char)v129);
          return 0;
        default:
          if (v15 == 33723)
          {
            uint64_t v48 = v208;
            v208 += 4;
            int64_t v29 = *(unsigned int *)v48;
            *(_DWORD *)(a1 + 396) = v29;
            memory_object_size_t v25 = (char **)(a1 + 400);
            v208 = v48 + 8;
            p_at_texel_region_t src = (unint64_t *)*((void *)v48 + 1);
            uint64_t v17 = 1;
            unint64_t v28 = 0;
            uint64_t v31 = 1;
LABEL_30:
            setByteArray(v28, v25, p_src, v29, v31, v9, v10, v11);
            goto LABEL_159;
          }
          if (v15 != 65563) {
            goto LABEL_125;
          }
          double v38 = v208;
          v208 += 4;
          int v39 = *v38;
          int v40 = *(_DWORD *)(a1 + 16);
          if (v39 == 1) {
            unsigned int v41 = v40 | 0x400000;
          }
          else {
            unsigned int v41 = v40 & 0xFFBFFFFF;
          }
LABEL_157:
          *(_DWORD *)(a1 + 16) = v41;
          break;
      }
      goto LABEL_158;
    }
    if (v15 == 531)
    {
      int v47 = v208;
      v208 += 4;
      *(_WORD *)(a1 + 340) = *(_DWORD *)v47;
      goto LABEL_158;
    }
    if (v15 == 532)
    {
      unsigned int v32 = (char **)(a1 + 368);
      uint8x8_t v33 = (const void **)v208;
      v208 += 4;
      uint64_t v34 = *v33;
      uint64_t v35 = (void *)a1;
      int64_t v36 = 6;
      uint64_t v37 = 4;
LABEL_124:
      setByteArray(v35, v32, v34, v36, v37, v9, v10, v11);
      goto LABEL_158;
    }
LABEL_125:
    if (!*((_WORD *)v6 + 12))
    {
      TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Ignored %stag \"%s\" (not supported by libtiff)", v7, v8, v9, v10, v11, *(void *)a1);
      return 0;
    }
    if (v14 != 65)
    {
      TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Invalid %stag \"%s\" (not supported by codec)", v7, v8, v9, v10, v11, *(void *)a1);
      return 0;
    }
    int v112 = *(_DWORD *)(a1 + 408);
    double v113 = *(char **)(a1 + 416);
    if (v112 < 1)
    {
LABEL_131:
      int v116 = v112 + 1;
      *(_DWORD *)(a1 + 408) = v116;
      uint8x8_t v117 = _TIFFreallocExt((void *)a1, v113, 24 * v116, v7, v8, v9, v10, v11);
      if (!v117)
      {
        TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Failed to allocate space for list of custom values", v118, v119, v120, v121, v122, *(void *)a1);
        return 0;
      }
      *(void *)(a1 + 416) = v117;
      uint8x8_t v123 = &v117[3 * *(int *)(a1 + 408)];
      *(v123 - 3) = v12;
      unsigned int v115 = v123 - 3;
      v115[2] = 0;
      *((_DWORD *)v115 + 2) = 0;
    }
    else
    {
      uint64_t v114 = *(unsigned int *)(a1 + 408);
      unsigned int v115 = *(void **)(a1 + 416);
      while (*(_DWORD *)*v115 != a2)
      {
        v115 += 3;
        if (!--v114) {
          goto LABEL_131;
        }
      }
      uint8x8_t v137 = (char *)v115[2];
      if (v137)
      {
        _TIFFfreeExt(a1, v137);
        v115[2] = 0;
      }
    }
    int Size = TIFFFieldSetGetSize(v12);
    if (!Size)
    {
      TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Bad field type %d for \"%s\"", v139, v140, v141, v142, v143, *(void *)a1);
      return 0;
    }
    if (*(_DWORD *)(v12 + 8) == 2)
    {
      if (*(unsigned char *)(v12 + 27))
      {
        if (*(__int16 *)(v12 + 6) != -3) {
          _TIFFVSetField_cold_1();
        }
        uint64_t v144 = v208;
        v208 += 4;
        unsigned int v145 = *(_DWORD *)v144;
        v208 = v144 + 8;
        uint64_t v146 = (const char *)*((void *)v144 + 1);
        goto LABEL_181;
      }
      uint64_t v151 = (const char **)v208;
      v208 += 4;
      uint64_t v146 = *v151;
      size_t v152 = strlen(*v151);
      unsigned int v145 = v152 + 1;
      if (!((v152 + 1) >> 31))
      {
LABEL_181:
        *((_DWORD *)v115 + 2) = v145;
        setByteArray((void *)a1, (char **)v115 + 2, v146, v145, 1, v141, v142, v143);
        uint64_t v17 = 1;
        goto LABEL_159;
      }
      TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Too long string value for \"%s\". Maximum supported is 2147483647 bytes", v153, v154, v141, v142, v143, *(void *)a1);
      return 0;
    }
    int v147 = Size;
    int v148 = *(__int16 *)(v12 + 6);
    int v149 = *(unsigned __int16 *)(v12 + 6);
    if (*(unsigned char *)(v12 + 27))
    {
      unint64_t v150 = (int *)v208;
      v208 += 4;
      int v148 = *v150;
      goto LABEL_178;
    }
    if (v149 != 0xFFFF)
    {
      if (v149 == 65534)
      {
        int v148 = *(unsigned __int16 *)(a1 + 130);
      }
      else if (v149 == 65533)
      {
        goto LABEL_185;
      }
LABEL_178:
      *((_DWORD *)v115 + 2) = v148;
      if (!v148)
      {
        TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Null count for \"%s\" (type %d, writecount %d, passcount %d)", v139, v140, v141, v142, v143, *(void *)a1);
        return 0;
      }
      goto LABEL_186;
    }
LABEL_185:
    int v148 = 1;
    *((_DWORD *)v115 + 2) = 1;
LABEL_186:
    uint64_t v155 = _TIFFCheckMalloc((const char **)a1, v148, Size, (uint64_t)"custom tag binary object", v140, v141, v142, v143);
    v115[2] = v155;
    if (v155)
    {
      unint64_t v156 = v155;
      if (*(_DWORD *)v12 == 336 && !strcmp(*(const char **)(v12 + 32), "DotRange"))
      {
        unsigned int v167 = v208;
        v208 += 4;
        LOWORD(__src) = *(_DWORD *)v167;
        v208 = v167 + 8;
        WORD1(__src) = *((_DWORD *)v167 + 2);
        __int16 v168 = (void *)v115[2];
        size_t v169 = 4;
LABEL_234:
        _TIFFmemcpy(v168, &__src, v169);
        goto LABEL_158;
      }
      if (*(unsigned char *)(v12 + 27) || *(unsigned __int16 *)(v12 + 6) > 0xFFFCu || (int v157 = *((_DWORD *)v115 + 2), v157 >= 2))
      {
        __n128 v158 = (const void **)v208;
        v208 += 4;
        _TIFFmemcpy(v156, *v158, *((int *)v115 + 2) * (uint64_t)v147);
        if ((*(unsigned char *)(a1 + 18) & 8) != 0) {
          goto LABEL_158;
        }
        int v164 = *(_DWORD *)(*v115 + 8);
        if (v164 == 17)
        {
          uint64_t v170 = *((unsigned int *)v115 + 2);
          if ((int)v170 < 1) {
            goto LABEL_158;
          }
          uint64_t v171 = 0;
          while (1)
          {
            uint64_t v172 = *(void *)(v115[2] + 8 * v171);
            if (v172 != (int)v172) {
              break;
            }
            ++v171;
            uint64_t v17 = 1;
            if (v170 == v171) {
              goto LABEL_159;
            }
          }
          TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Bad SLONG8 value %lli at %d. array position for \"%s\" tag %d in ClassicTIFF. Tag won't be written to file", v159, v160, v161, v162, v163, *(void *)a1);
        }
        else
        {
          if (v164 != 16) {
            goto LABEL_158;
          }
          uint64_t v165 = *((unsigned int *)v115 + 2);
          if ((int)v165 < 1) {
            goto LABEL_158;
          }
          uint64_t v166 = 0;
          while (!HIDWORD(*(void *)(v115[2] + 8 * v166)))
          {
            ++v166;
            uint64_t v17 = 1;
            if (v165 == v166) {
              goto LABEL_159;
            }
          }
          TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Bad LONG8 value %llu at %d. array position for \"%s\" tag %d in ClassicTIFF. Tag won't be written to file", v159, v160, v161, v162, v163, *(void *)a1);
        }
      }
      else
      {
        if (v157 != 1) {
          _TIFFVSetField_cold_3();
        }
        switch(*(_DWORD *)(v12 + 8))
        {
          case 1:
          case 6:
          case 7:
            __n128 v173 = v208;
            v208 += 4;
            LOBYTE(__src) = *(_DWORD *)v173;
            goto LABEL_233;
          case 3:
          case 8:
            uint64_t v184 = v208;
            v208 += 4;
            LOWORD(__src) = *(_DWORD *)v184;
            goto LABEL_233;
          case 4:
          case 9:
          case 0xD:
            uint64_t v182 = v208;
            v208 += 4;
            LODWORD(__src) = *(_DWORD *)v182;
            goto LABEL_233;
          case 5:
          case 0xA:
            if (v147 == 8) {
              goto LABEL_226;
            }
            uint8x8_t v198 = (double *)v208;
            v208 += 4;
            float v199 = *v198;
            *(float *)&__at_texel_region_t src = v199;
            _TIFFmemcpy(v156, &__src, v147);
            if (v147 != 4) {
              TIFFErrorExtR(a1, "_TIFFVSetField", "Rational2Double: .set_field_type in not 4 but %d", v200, v201, v202, v203, v204, v147);
            }
            goto LABEL_158;
          case 0xB:
            v191 = (double *)v208;
            v208 += 4;
            LODWORD(__src) = _TIFFClampDoubleToFloat(*v191);
            goto LABEL_233;
          case 0xC:
LABEL_226:
            uint64_t v183 = v208;
            v208 += 4;
            __at_texel_region_t src = *(void *)v183;
LABEL_233:
            __int16 v168 = v156;
            size_t v169 = v147;
            goto LABEL_234;
          case 0x10:
          case 0x12:
            unint64_t v185 = v208;
            v208 += 4;
            __at_texel_region_t src = *(void *)v185;
            _TIFFmemcpy(v156, &__src, v147);
            if ((*(unsigned char *)(a1 + 18) & 8) != 0 || !HIDWORD(__src)) {
              goto LABEL_158;
            }
            TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Bad LONG8 or IFD8 value %llu for \"%s\" tag %d in ClassicTIFF. Tag won't be written to file", v186, v187, v188, v189, v190, *(void *)a1);
            break;
          case 0x11:
            int v192 = v208;
            v208 += 4;
            __at_texel_region_t src = *(void *)v192;
            _TIFFmemcpy(v156, &__src, v147);
            if ((*(unsigned char *)(a1 + 18) & 8) != 0 || __src == (int)__src) {
              goto LABEL_158;
            }
            TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Bad SLONG8 value %lli for \"%s\" tag %d in ClassicTIFF. Tag won't be written to file", v193, v194, v195, v196, v197, *(void *)a1);
            break;
          default:
            _TIFFmemset(v156, 0, v147);
            return 0;
        }
      }
      uint64_t v174 = *(unsigned int *)(a1 + 408);
      if ((int)v174 < 1) {
LABEL_217:
      }
        _TIFFVSetField_cold_2();
      uint64_t v175 = 0;
      uint64_t v176 = *(void *)(a1 + 416);
      uint64_t v177 = 16;
      while (**(_DWORD **)(v176 + v177 - 16) != a2)
      {
        ++v175;
        v177 += 24;
        if (v174 == v175) {
          goto LABEL_217;
        }
      }
      uint64_t v178 = *(char **)(v176 + v177);
      if (v178)
      {
        _TIFFfreeExt(a1, v178);
        *(void *)(v176 + v177) = 0;
        LODWORD(v174) = *(_DWORD *)(a1 + 408);
      }
      int v179 = v174 - 1;
      *(_DWORD *)(a1 + 408) = v179;
      if (v179 > (int)v175)
      {
        uint64_t v180 = v177 - 16;
        do
        {
          uint64_t v17 = 0;
          uint64_t v181 = *(void *)(a1 + 416) + v180;
          ++v175;
          *(_OWORD *)uint64_t v181 = *(_OWORD *)(v181 + 24);
          *(void *)(v181 + 16) = *(void *)(v181 + 40);
          v180 += 24;
        }
        while (v175 < *(int *)(a1 + 408));
        return v17;
      }
    }
    return 0;
  }
  switch(v15)
  {
    case 320:
      uint64_t v17 = 1;
      uint64_t v18 = 1 << *(_WORD *)(a1 + 116);
      unsigned int v19 = (const void **)v208;
      v208 += 4;
      int64_t v20 = v18;
      setByteArray((void *)a1, (char **)(a1 + 184), *v19, v18, 2, v9, v10, v11);
      BOOL v21 = (const void **)v208;
      v208 += 4;
      setByteArray((void *)a1, (char **)(a1 + 192), *v21, v20, 2, v22, v23, v24);
      memory_object_size_t v25 = (char **)(a1 + 200);
      double v26 = v208;
      v208 += 4;
      p_at_texel_region_t src = *(unint64_t **)v26;
      unint64_t v28 = (void *)a1;
      int64_t v29 = v20;
      goto LABEL_15;
    case 321:
      uint8x8_t v86 = v208;
      v208 += 4;
      *(_WORD *)(a1 + 208) = *(_DWORD *)v86;
      v208 = v86 + 8;
      *(_WORD *)(a1 + 210) = *((_DWORD *)v86 + 2);
      break;
    case 322:
      int v87 = v208;
      v208 += 4;
      int v88 = *(_DWORD *)v87;
      if ((*(_DWORD *)v87 & 0xF) == 0) {
        goto LABEL_155;
      }
      if (*(_DWORD *)(a1 + 12)) {
        goto LABEL_133;
      }
      TIFFWarningExtR(a1, *(const char **)a1, "Nonstandard tile width %u, convert file", v7, v8, v9, v10, v11, v88);
LABEL_155:
      *(_DWORD *)(a1 + 100) = v88;
      goto LABEL_156;
    case 323:
      int v89 = v208;
      v208 += 4;
      int v90 = *(_DWORD *)v89;
      if ((*(_DWORD *)v89 & 0xF) == 0) {
        goto LABEL_98;
      }
      if (*(_DWORD *)(a1 + 12)) {
        goto LABEL_133;
      }
      TIFFWarningExtR(a1, *(const char **)a1, "Nonstandard tile length %u, convert file", v7, v8, v9, v10, v11, v90);
LABEL_98:
      *(_DWORD *)(a1 + 104) = v90;
LABEL_156:
      unsigned int v41 = *(_DWORD *)(a1 + 16) | 0x400;
      goto LABEL_157;
    case 324:
    case 325:
    case 326:
    case 327:
    case 328:
    case 329:
    case 331:
    case 332:
    case 335:
    case 336:
    case 337:
      goto LABEL_125;
    case 330:
      if ((*(unsigned char *)(a1 + 17) & 0x20) == 0)
      {
        uint64_t v91 = v208;
        v208 += 4;
        int v92 = *(_DWORD *)v91;
        *(_WORD *)(a1 + 320) = *(_DWORD *)v91;
        unsigned int v32 = (char **)(a1 + 328);
        v208 = v91 + 8;
        uint64_t v34 = (const void *)*((void *)v91 + 1);
        int64_t v36 = (unsigned __int16)v92;
        goto LABEL_123;
      }
      TIFFErrorExtR(a1, "_TIFFVSetField", "%s: Sorry, cannot nest SubIFDs", v7, v8, v9, v10, v11, *(void *)a1);
      return 0;
    case 333:
      uint64_t v93 = v208;
      v208 += 4;
      unsigned int v94 = *v93;
      unsigned int v207 = v94;
      v208 = v93 + 8;
      uint64_t v95 = (const void *)*((void *)v93 + 1);
      uint64_t v17 = countInkNamesString((void *)a1, v94, (unint64_t)v95, v7, v8, v9, v10, v11);
      if (!v17) {
        return v17;
      }
      setByteArray((void *)a1, (char **)(a1 + 384), v95, v207, 1, v96, v97, v98);
      *(_DWORD *)(a1 + 376) = v207;
      int v104 = *(_DWORD *)(a1 + 76);
      if ((v104 & 0x40000) != 0)
      {
        if (*(unsigned __int16 *)(a1 + 392) != v17)
        {
          TIFFErrorExtR(a1, "_TIFFVSetField", "Warning %s; Tag %s:\n"
            "  Value %hu of NumberOfInks is different from the number of inks %hu.\n"
            "  -> NumberOfInks value adapted to %hu",
            v99,
            v100,
            v101,
            v102,
            v103,
            *(void *)a1);
          *(_WORD *)(a1 + 392) = v17;
        }
      }
      else
      {
        *(_WORD *)(a1 + 392) = v17;
        *(_DWORD *)(a1 + 76) = v104 | 0x40000;
      }
      if ((*(unsigned char *)(a1 + 74) & 1) != 0 && v17 != *(unsigned __int16 *)(a1 + 130)) {
        TIFFErrorExtR(a1, "_TIFFVSetField", "Warning %s; Tag %s:\n  Value %hu of NumberOfInks is different from the SamplesPerPixel value %hu",
      }
          v99,
          v100,
          v101,
          v102,
          v103,
          *(void *)a1);
      break;
    case 334:
      uint64_t v105 = v208;
      v208 += 4;
      int v106 = *(_DWORD *)v105;
      int v107 = (unsigned __int16)*(_DWORD *)v105;
      if ((*(unsigned char *)(a1 + 77) & 0x40) == 0)
      {
        *(_WORD *)(a1 + 392) = v106;
        if ((*(unsigned char *)(a1 + 74) & 1) != 0 && v107 != *(unsigned __int16 *)(a1 + 130)) {
          TIFFErrorExtR(a1, "_TIFFVSetField", "Warning %s; Tag %s:\n  Value %u of NumberOfInks is different from the SamplesPerPixel value %hu",
        }
            v7,
            v8,
            v9,
            v10,
            v11,
            *(void *)a1);
        break;
      }
      if (v107 == *(unsigned __int16 *)(a1 + 392)) {
        break;
      }
      TIFFErrorExtR(a1, "_TIFFVSetField", "Error %s; Tag %s:\n"
        "  It is not possible to set the value %u for NumberOfInks\n"
        "  which is different from the number of inks in the InkNames tag (%hu)",
        v7,
        v8,
        v9,
        v10,
        v11,
        *(void *)a1);
      return 0;
    case 338:
      if (!setExtraSamples(a1, a3, &v207, v7, v8, v9, v10, v11)) {
        goto LABEL_140;
      }
      break;
    case 339:
      unint64_t v108 = v208;
      v208 += 4;
      int v109 = *(_DWORD *)v108;
      if ((unsigned __int16)v109 - 7 < 0xFFFFFFFA) {
        goto LABEL_140;
      }
      *(_WORD *)(a1 + 118) = v109;
      if ((unsigned __int16)v109 == 5
        && *(_WORD *)(a1 + 116) == 32
        && *(__int32 *(**)(uint8x8_t, uint64_t, __int32 *, uint64_t))(a1 + 1248) == _TIFFSwab32BitData)
      {
LABEL_163:
        uint64_t v54 = (uint64_t (*)())_TIFFSwab16BitData;
LABEL_175:
        *(void *)(a1 + 1248) = v54;
        break;
      }
      if ((unsigned __int16)v109 - 5 <= 1
        && *(_WORD *)(a1 + 116) == 64
        && *(int8x8_t *(**)(uint64_t, int8x8_t *, uint64_t))(a1 + 1248) == _TIFFSwab64BitData)
      {
LABEL_164:
        uint64_t v54 = (uint64_t (*)())_TIFFSwab32BitData;
        goto LABEL_175;
      }
      break;
    case 340:
      unsigned int v32 = (char **)(a1 + 144);
      goto LABEL_120;
    case 341:
      unsigned int v32 = (char **)(a1 + 152);
LABEL_120:
      if ((*(unsigned char *)(a1 + 18) & 0x40) == 0)
      {
        uint8x8_t v110 = (double *)v208;
        v208 += 4;
        setDoubleArrayOneValue((void *)a1, v32, *(unsigned __int16 *)(a1 + 130), v7, v8, v9, v10, v11, *v110);
        break;
      }
      int v111 = (const void **)v208;
      v208 += 4;
      uint64_t v34 = *v111;
      int64_t v36 = *(unsigned __int16 *)(a1 + 130);
LABEL_123:
      uint64_t v35 = (void *)a1;
      uint64_t v37 = 8;
      goto LABEL_124;
    default:
      if (v15 != 530) {
        goto LABEL_125;
      }
      char v49 = v208;
      v208 += 4;
      *(_WORD *)(a1 + 336) = *(_DWORD *)v49;
      v208 = v49 + 8;
      *(_WORD *)(a1 + 338) = *((_DWORD *)v49 + 2);
      break;
  }
LABEL_158:
  uint64_t v17 = 1;
LABEL_159:
  int v135 = TIFFFieldWithTag((void *)a1, a2);
  if (v135) {
    *(_DWORD *)&v13[((unint64_t)*((unsigned __int16 *)v135 + 12) >> 3) & 0x1FFC] |= 1 << *((_WORD *)v135 + 12);
  }
  *(_DWORD *)(a1 + 16) |= 8u;
  return v17;
}

uint64_t _TIFFVGetField(uint64_t a1, int a2, double ***a3)
{
  uint64_t result = (uint64_t)TIFFFindField((void *)a1, a2, 0);
  if (result)
  {
    uint64_t v11 = result;
    int v12 = *(unsigned __int16 *)(result + 24);
    if (v12 == 65) {
      int v13 = 0;
    }
    else {
      int v13 = a2;
    }
    if (v13 <= 530)
    {
      switch(v13)
      {
        case 254:
          int v23 = *(_DWORD *)(a1 + 112);
          goto LABEL_59;
        case 255:
        case 260:
        case 261:
        case 264:
        case 265:
        case 267:
        case 268:
        case 269:
        case 270:
        case 271:
        case 272:
        case 275:
        case 276:
        case 285:
        case 288:
        case 289:
        case 290:
        case 291:
        case 292:
        case 293:
        case 294:
        case 295:
        case 298:
        case 299:
        case 300:
        case 302:
        case 303:
        case 304:
        case 305:
        case 306:
        case 307:
        case 308:
        case 309:
        case 310:
        case 311:
        case 312:
        case 313:
        case 314:
        case 315:
        case 316:
        case 317:
        case 318:
        case 319:
        case 326:
        case 327:
        case 328:
        case 329:
        case 331:
        case 332:
        case 335:
        case 336:
        case 337:
          goto LABEL_21;
        case 256:
          int v23 = *(_DWORD *)(a1 + 88);
          goto LABEL_59;
        case 257:
          int v23 = *(_DWORD *)(a1 + 92);
          goto LABEL_59;
        case 258:
          __int16 v15 = *(_WORD *)(a1 + 116);
          goto LABEL_82;
        case 259:
          __int16 v15 = *(_WORD *)(a1 + 120);
          goto LABEL_82;
        case 262:
          __int16 v15 = *(_WORD *)(a1 + 122);
          goto LABEL_82;
        case 263:
          __int16 v15 = *(_WORD *)(a1 + 124);
          goto LABEL_82;
        case 266:
          __int16 v15 = *(_WORD *)(a1 + 126);
          goto LABEL_82;
        case 273:
        case 324:
          _TIFFFillStriles(a1);
          **a3 = *(double **)(a1 + 232);
          uint64_t v14 = *(void *)(a1 + 232);
          return v14 != 0;
        case 274:
          __int16 v15 = *(_WORD *)(a1 + 128);
          goto LABEL_82;
        case 277:
          __int16 v15 = *(_WORD *)(a1 + 130);
          goto LABEL_82;
        case 278:
          int v23 = *(_DWORD *)(a1 + 132);
          goto LABEL_59;
        case 279:
        case 325:
          _TIFFFillStriles(a1);
          **a3 = *(double **)(a1 + 240);
          uint64_t v14 = *(void *)(a1 + 240);
          return v14 != 0;
        case 280:
          __int16 v15 = *(_WORD *)(a1 + 136);
          goto LABEL_82;
        case 281:
          __int16 v15 = *(_WORD *)(a1 + 138);
          goto LABEL_82;
        case 282:
          int v24 = *(_DWORD *)(a1 + 160);
          goto LABEL_50;
        case 283:
          int v24 = *(_DWORD *)(a1 + 164);
          goto LABEL_50;
        case 284:
          __int16 v15 = *(_WORD *)(a1 + 170);
          goto LABEL_82;
        case 286:
          int v24 = *(_DWORD *)(a1 + 172);
          goto LABEL_50;
        case 287:
          int v24 = *(_DWORD *)(a1 + 176);
LABEL_50:
          *(_DWORD *)*a3 = v24;
          return 1;
        case 296:
          __int16 v15 = *(_WORD *)(a1 + 168);
          goto LABEL_82;
        case 297:
          memory_object_size_t v25 = a3++;
          *(_WORD *)__int32 *v25 = *(_WORD *)(a1 + 180);
          __int16 v15 = *(_WORD *)(a1 + 182);
          goto LABEL_82;
        case 301:
          double v26 = a3;
          unint64_t v57 = a3 + 1;
          **double v26 = *(double **)(a1 + 344);
          if (*(unsigned __int16 *)(a1 + 130) - *(unsigned __int16 *)(a1 + 212) >= 2)
          {
            double v27 = v57;
            a3 = (double ***)(v57 + 1);
            *char *v27 = *(void *)(a1 + 352);
            unint64_t v16 = *(double **)(a1 + 360);
            goto LABEL_101;
          }
          **unint64_t v57 = 0;
          *v57[1] = 0;
          break;
        case 320:
          **a3 = *(double **)(a1 + 184);
          unint64_t v28 = a3 + 1;
          a3 += 2;
          **unint64_t v28 = *(void *)(a1 + 192);
          unint64_t v16 = *(double **)(a1 + 200);
          goto LABEL_101;
        case 321:
          int64_t v29 = a3++;
          *(_WORD *)*int64_t v29 = *(_WORD *)(a1 + 208);
          __int16 v15 = *(_WORD *)(a1 + 210);
          goto LABEL_82;
        case 322:
          int v23 = *(_DWORD *)(a1 + 100);
          goto LABEL_59;
        case 323:
          int v23 = *(_DWORD *)(a1 + 104);
          goto LABEL_59;
        case 330:
          vImagePixelCount v30 = a3++;
          *(_WORD *)*vImagePixelCount v30 = *(_WORD *)(a1 + 320);
          unint64_t v16 = *(double **)(a1 + 328);
          goto LABEL_101;
        case 333:
          unint64_t v16 = *(double **)(a1 + 384);
          goto LABEL_101;
        case 334:
          __int16 v15 = *(_WORD *)(a1 + 392);
          goto LABEL_82;
        case 338:
          uint64_t v31 = a3++;
          *(_WORD *)*uint64_t v31 = *(_WORD *)(a1 + 212);
          unint64_t v16 = *(double **)(a1 + 216);
          goto LABEL_101;
        case 339:
          __int16 v15 = *(_WORD *)(a1 + 118);
          goto LABEL_82;
        case 340:
          unint64_t v16 = *(double **)(a1 + 144);
          if ((*(unsigned char *)(a1 + 18) & 0x40) != 0) {
            goto LABEL_101;
          }
          double v32 = *v16;
          unint64_t v33 = *(unsigned __int16 *)(a1 + 130);
          if (v33 >= 2)
          {
            uint64_t v34 = v16 + 1;
            unint64_t v35 = v33 - 1;
            do
            {
              double v36 = *v34++;
              double v37 = v36;
              if (v36 < v32) {
                double v32 = v37;
              }
              --v35;
            }
            while (v35);
          }
          goto LABEL_78;
        case 341:
          unint64_t v16 = *(double **)(a1 + 152);
          if ((*(unsigned char *)(a1 + 18) & 0x40) != 0) {
            goto LABEL_101;
          }
          double v32 = *v16;
          unint64_t v38 = *(unsigned __int16 *)(a1 + 130);
          if (v38 >= 2)
          {
            int v39 = v16 + 1;
            unint64_t v40 = v38 - 1;
            do
            {
              double v41 = *v39++;
              double v42 = v41;
              if (v41 > v32) {
                double v32 = v42;
              }
              --v40;
            }
            while (v40);
          }
LABEL_78:
          *(double *)*a3 = v32;
          return 1;
        default:
          if (v13 != 530) {
            goto LABEL_21;
          }
          uint64_t v18 = a3++;
          *(_WORD *)*uint64_t v18 = *(_WORD *)(a1 + 336);
          __int16 v15 = *(_WORD *)(a1 + 338);
          goto LABEL_82;
      }
      return 1;
    }
    if (v13 > 32994)
    {
      switch(v13)
      {
        case 32995:
          __int16 v15 = *(_WORD *)(a1 + 212) == 1 && **(_WORD **)(a1 + 216) == 1;
          goto LABEL_82;
        case 32996:
          switch(*(_WORD *)(a1 + 118))
          {
            case 1:
              BOOL v21 = *a3;
              __int16 v22 = 2;
              goto LABEL_86;
            case 2:
              uint64_t result = 1;
              *(_WORD *)*a3 = 1;
              return result;
            case 3:
              BOOL v21 = *a3;
              __int16 v22 = 3;
LABEL_86:
              *(_WORD *)BOOL v21 = v22;
              break;
            case 4:
              *(_WORD *)*a3 = 0;
              return 1;
            default:
              return 1;
          }
          return 1;
        case 32997:
          int v23 = *(_DWORD *)(a1 + 96);
          goto LABEL_59;
        case 32998:
          int v23 = *(_DWORD *)(a1 + 108);
LABEL_59:
          *(_DWORD *)*a3 = v23;
          return 1;
        default:
          if (v13 != 33723) {
            goto LABEL_21;
          }
          uint64_t v17 = a3++;
          *(_DWORD *)*uint64_t v17 = *(_DWORD *)(a1 + 396);
          unint64_t v16 = *(double **)(a1 + 400);
          goto LABEL_101;
      }
    }
    if (v13 != 531)
    {
      if (v13 == 532)
      {
        unint64_t v16 = *(double **)(a1 + 368);
LABEL_101:
        **a3 = v16;
        return 1;
      }
LABEL_21:
      if (v12 == 65)
      {
        uint64_t v19 = *(unsigned int *)(a1 + 408);
        if ((int)v19 >= 1)
        {
          for (uint64_t i = (_WORD **)(*(void *)(a1 + 416) + 16); *(_DWORD *)*(i - 2) != a2; i += 3)
          {
            uint64_t result = 0;
            if (!--v19) {
              return result;
            }
          }
          if (*(unsigned char *)(v11 + 27))
          {
            int v43 = *((_DWORD *)i - 2);
            unsigned int v44 = a3++;
            if (*(__int16 *)(v11 + 4) == -3) {
              *(_DWORD *)unsigned __int16 *v44 = v43;
            }
            else {
              *(_WORD *)unsigned __int16 *v44 = v43;
            }
LABEL_100:
            unint64_t v16 = (double *)*i;
            goto LABEL_101;
          }
          if (*(_DWORD *)v11 != 336 || strcmp(*(const char **)(v11 + 32), "DotRange"))
          {
            int v45 = *(_DWORD *)(v11 + 8);
            if (v45 != 2 && *(unsigned __int16 *)(v11 + 4) <= 0xFFFCu)
            {
              int v46 = *((_DWORD *)i - 2);
              if (v46 < 2)
              {
                if (v46 == 1)
                {
                  uint64_t result = 0;
                  int v47 = *i;
                  switch(v45)
                  {
                    case 1:
                    case 6:
                    case 7:
                      *(unsigned char *)*a3 = *v47;
                      return 1;
                    case 3:
                    case 8:
                      __int16 v15 = *(_WORD *)v47;
                      goto LABEL_82;
                    case 4:
                    case 9:
                    case 13:
                      int v23 = *(_DWORD *)v47;
                      goto LABEL_59;
                    case 5:
                    case 10:
                      int Size = TIFFFieldSetGetSize(v11);
                      if (Size == 8) {
                        goto LABEL_108;
                      }
                      *(_DWORD *)*a3 = *(_DWORD *)v47;
                      if (Size != 4) {
                        TIFFErrorExtR(a1, "_TIFFVGetField", "Rational2Double: .set_field_type in not 4 but %d", v51, v52, v53, v54, v55, Size);
                      }
                      return 1;
                    case 11:
                      int v24 = *(_DWORD *)v47;
                      goto LABEL_50;
                    case 12:
LABEL_108:
                      double v32 = *(double *)v47;
                      goto LABEL_78;
                    case 16:
                    case 17:
                    case 18:
                      unint64_t v16 = *(double **)v47;
                      goto LABEL_101;
                    default:
                      return result;
                  }
                }
                _TIFFVGetField_cold_1();
              }
            }
            goto LABEL_100;
          }
          uint64_t v48 = (uint64_t)*i;
          char v49 = a3++;
          *(_WORD *)*char v49 = **i;
          __int16 v15 = *(_WORD *)(v48 + 2);
LABEL_82:
          *(_WORD *)*a3 = v15;
          return 1;
        }
      }
      else
      {
        TIFFErrorExtR(a1, "_TIFFVGetField", "%s: Invalid %stag \"%s\" (not supported by codec)", v6, v7, v8, v9, v10, *(void *)a1);
      }
      return 0;
    }
    __int16 v15 = *(_WORD *)(a1 + 340);
    goto LABEL_82;
  }
  return result;
}

uint64_t TIFFAdvanceDirectory(uint64_t a1, uint64_t *a2, void *a3, unsigned int *a4)
{
  if (!_TIFFCheckDirNumberAndOffset(a1, *a4, *a2))
  {
    TIFFErrorExtR(a1, "TIFFAdvanceDirectory", "Starting directory %u at offset 0x%llx (%llu) might cause an IFD loop", v8, v9, v10, v11, v12, *a4);
    uint64_t result = 0;
    *a2 = 0;
    *a4 = 0;
    return result;
  }
  int v13 = *(_DWORD *)(a1 + 16);
  if ((v13 & 0x800) == 0)
  {
    if ((v13 & 0x80000) == 0)
    {
      unsigned __int16 __dst = 0;
      v39.i32[0] = 0;
      if (_TIFFSeekOK(a1, *a2)
        && (*(uint64_t (**)(void, unsigned __int16 *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &__dst, 2) == 2)
      {
        if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
          TIFFSwabShort(&__dst);
        }
        uint64_t v14 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a1 + 1224))(*(void *)(a1 + 1200), 12 * __dst, 1);
        if (a3) {
          *a3 = v14;
        }
        if ((*(uint64_t (**)(void, int8x8_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v39, 4) == 4)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            TIFFSwabLong((__int32 *)&v39, v20);
          }
          uint64_t v21 = v39.u32[0];
          *a2 = v39.u32[0];
          goto LABEL_59;
        }
        goto LABEL_49;
      }
      goto LABEL_30;
    }
    int8x8_t v39 = 0;
    if (!_TIFFSeekOK(a1, *a2)
      || (*(uint64_t (**)(void, int8x8_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v39, 8) != 8)
    {
      goto LABEL_30;
    }
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      v25.n128_u64[0] = (unint64_t)TIFFSwabLong8(&v39);
    }
    if (*(void *)&v39 >= 0x10000uLL)
    {
LABEL_30:
      unint64_t v38 = "/Library/Caches/com.apple.xbs/Sources/ImageIO/FileFormats/libTIFF/tif_dir.c";
      double v27 = "%s:%d: %s: Error fetching directory count";
LABEL_31:
      TIFFErrorExtR(a1, "TIFFAdvanceDirectory", v27, v8, v9, v10, v11, v12, (char)v38);
      return 0;
    }
    uint64_t v30 = (*(uint64_t (**)(void, uint64_t, uint64_t, __n128))(a1 + 1224))(*(void *)(a1 + 1200), 20 * *(void *)&v39, 1, v25);
    if (a3) {
      *a3 = v30;
    }
    if ((*(uint64_t (**)(void, uint64_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), a2, 8) != 8)
    {
LABEL_49:
      TIFFErrorExtR(a1, "TIFFAdvanceDirectory", "%s: Error fetching directory link", v15, v16, v17, v18, v19, *(void *)a1);
      return 0;
    }
    goto LABEL_56;
  }
  unint64_t v23 = *a2;
  if ((v13 & 0x80000) == 0)
  {
    unsigned __int16 __dst = 0;
    v39.i32[0] = 0;
    if (v23 > 0x7FFFFFFFFFFFFFFDLL || (unint64_t v24 = v23 + 2, (int64_t)(v23 + 2) > *(void *)(a1 + 1176)))
    {
      TIFFErrorExtR(a1, "TIFFAdvanceDirectory", "%s:%d: %s: Error fetching directory count", v8, v9, v10, v11, v12, (char)"/Library/Caches/com.apple.xbs/Sources/ImageIO/FileFormats/libTIFF/tif_dir.c");
      *a2 = 0;
      return 0;
    }
    _TIFFmemcpy(&__dst, (const void *)(*(void *)(a1 + 1168) + v23), 2uLL);
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabShort(&__dst);
    }
    unint64_t v28 = v24 + 12 * __dst;
    if (v28 <= 0x7FFFFFFFFFFFFFFBLL && (int64_t)(v28 + 4) <= *(void *)(a1 + 1176))
    {
      if (a3) {
        *a3 = v28;
      }
      _TIFFmemcpy(&v39, (const void *)(*(void *)(a1 + 1168) + v28), 4uLL);
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabLong((__int32 *)&v39, v29);
      }
      *a2 = v39.u32[0];
      goto LABEL_58;
    }
LABEL_52:
    double v27 = "Error fetching directory link";
    goto LABEL_31;
  }
  int8x8_t v39 = 0;
  if (v23 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_30;
  }
  unint64_t v26 = v23 + 8;
  if ((int64_t)(v23 + 8) > *(void *)(a1 + 1176)) {
    goto LABEL_30;
  }
  _TIFFmemcpy(&v39, (const void *)(*(void *)(a1 + 1168) + v23), 8uLL);
  if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
    TIFFSwabLong8(&v39);
  }
  if (*(void *)&v39 >= 0x10000uLL)
  {
    double v27 = "Sanity check on directory count failed";
    goto LABEL_31;
  }
  if (v26 > 0x7FFFFFFFFFFFFFF7 - 20 * *(void *)&v39) {
    goto LABEL_52;
  }
  unint64_t v31 = 20 * *(void *)&v39 + v26;
  if ((int64_t)(v31 + 8) > *(void *)(a1 + 1176)) {
    goto LABEL_52;
  }
  if (a3) {
    *a3 = v31;
  }
  _TIFFmemcpy(a2, (const void *)(*(void *)(a1 + 1168) + v31), 8uLL);
LABEL_56:
  if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
    TIFFSwabLong8((int8x8_t *)a2);
  }
LABEL_58:
  uint64_t v21 = *a2;
LABEL_59:
  if (v21)
  {
    unsigned int v32 = *a4 + 1;
    *a4 = v32;
    if (!_TIFFCheckDirNumberAndOffset(a1, v32, v21))
    {
      TIFFWarningExtR(a1, "TIFFAdvanceDirectory", "the next directory %u at offset 0x%llx (%llu) might be an IFD loop. Treating directory %d as last directory", v33, v34, v35, v36, v37, *a4);
      *a2 = 0;
      --*a4;
    }
  }
  return 1;
}

uint64_t _cg_TIFFSetDirectory(uint64_t a1, unsigned int a2)
{
  uint64_t v12 = 0;
  unsigned int v11 = 0;
  if (!*(_DWORD *)(a1 + 64) || (_TIFFCleanupIFDOffsetAndNumberMaps(a1), !*(_DWORD *)(a1 + 64)))
  {
    if (_TIFFGetOffsetFromDirNumber(a1, a2, &v12))
    {
      *(void *)(a1 + 32) = v12;
      *(_DWORD *)(a1 + 64) = 0;
LABEL_26:
      *(_DWORD *)(a1 + 880) = a2 - 1;
      return _cg_TIFFReadDirectory(a1);
    }
  }
  unsigned int v4 = *(_DWORD *)(a1 + 880);
  if (a2 >= v4 && (uint64_t v5 = *(void *)(a1 + 24)) != 0 && !*(_DWORD *)(a1 + 64))
  {
    uint64_t v12 = *(void *)(a1 + 24);
    unsigned int v11 = v4;
    int v6 = 1;
    a2 -= v4;
  }
  else
  {
    int v6 = 0;
    if ((*(unsigned char *)(a1 + 18) & 8) != 0) {
      uint64_t v5 = *(void *)(a1 + 864);
    }
    else {
      uint64_t v5 = *(unsigned int *)(a1 + 860);
    }
    uint64_t v12 = v5;
  }
  *(_DWORD *)(a1 + 64) = 0;
  BOOL v7 = a2 != 0;
  if (a2 && v5)
  {
    unsigned int v8 = a2 - 1;
    while (1)
    {
      uint64_t result = TIFFAdvanceDirectory(a1, &v12, 0, &v11);
      if (!result) {
        break;
      }
      uint64_t v5 = v12;
      BOOL v10 = v8-- != 0;
      BOOL v7 = v10;
      if (!v10 || !v12) {
        goto LABEL_22;
      }
    }
  }
  else
  {
LABEL_22:
    uint64_t result = 0;
    if (!v7 && v5)
    {
      *(void *)(a1 + 32) = v5;
      if (v6) {
        a2 += *(_DWORD *)(a1 + 880);
      }
      goto LABEL_26;
    }
  }
  return result;
}

char *setDoubleArrayOneValue(void *a1, char **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  uint64_t v9 = a3;
  int v13 = *a2;
  if (v13) {
    _TIFFfreeExt((uint64_t)a1, v13);
  }
  uint64_t result = (char *)_TIFFmallocExt(a1, 8 * v9, a3, a4, a5, a6, a7, a8);
  *a2 = result;
  if (result && v9)
  {
    do
      *(double *)&result[8 * v9-- - 8] = a9;
    while (v9);
  }
  return result;
}

uint64_t setExtraSamples(uint64_t a1, unsigned __int16 *a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a2;
  *a3 = v8;
  if (v8 > *(unsigned __int16 *)(a1 + 130)) {
    return 0;
  }
  uint64_t v9 = (const void *)*((void *)a2 + 1);
  if (v8 && v9 == 0) {
    return 0;
  }
  if (v8)
  {
    uint64_t v13 = v8;
    uint64_t v14 = (_WORD *)*((void *)a2 + 1);
    do
    {
      unsigned int v15 = (unsigned __int16)*v14;
      if (v15 >= 3)
      {
        if (v15 != 999) {
          return 0;
        }
        *uint64_t v14 = 2;
      }
      ++v14;
      --v13;
    }
    while (v13);
  }
  if (*(void *)(a1 + 344))
  {
    int v16 = *(unsigned __int16 *)(a1 + 130);
    if ((v16 - v8) >= 2 && v16 - *(unsigned __int16 *)(a1 + 212) <= 1)
    {
      TIFFWarningExtR(a1, "setExtraSamples", "ExtraSamples tag value is changing, but TransferFunction was read with a different value. Canceling it", a4, a5, a6, a7, a8, v18);
      *(_DWORD *)(a1 + 76) &= ~0x1000u;
      _TIFFfreeExt(a1, *(char **)(a1 + 344));
      *(void *)(a1 + 344) = 0;
      LODWORD(v8) = *(unsigned __int16 *)a3;
    }
  }
  *(_WORD *)(a1 + 212) = v8;
  setByteArray((void *)a1, (char **)(a1 + 216), v9, v8, 2, a6, a7, a8);
  return 1;
}

uint64_t countInkNamesString(void *a1, unsigned int a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int16 v8 = 0;
  if (a2)
  {
    unint64_t v9 = a3 + a2;
    while (a3 < v9)
    {
      unint64_t v10 = v9 - a3++;
      while (*(unsigned char *)(a3 - 1))
      {
        ++a3;
        if (!--v10) {
          goto LABEL_10;
        }
      }
      ++v8;
      if (a3 >= v9) {
        return v8;
      }
    }
  }
LABEL_10:
  TIFFErrorExtR((uint64_t)a1, "TIFFSetField", "%s: Invalid InkNames value; no null at given buffer end location %u, after %hu ink",
    a4,
    a5,
    a6,
    a7,
    a8,
    *a1);
  return 0;
}

void IIO_Reader_ICNS::createReadPlugin()
{
}

{
  operator new();
}

void sub_1887331D4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C401A854BDCLL);
  _Unwind_Resume(a1);
}

void sub_188733274(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C401A854BDCLL);
  _Unwind_Resume(a1);
}

IIOImageRead *IIO_Reader_ICNS::createGlobalInfoData(IIO_Reader_ICNS *this, IIOImageReadSession *a2)
{
  uint64_t result = IIOImageReadSession::globalInfoForType(a2, 1229147731);
  if (result)
  {
    return (IIOImageRead *)GlobalICNSInfo::createDataRepresentation(result);
  }
  return result;
}

void IIO_Reader_ICNS::updateGlobalInfo(IIO_Reader_ICNS *this, IIOImageReadSession *a2, unsigned __int8 *a3)
{
}

void sub_188733358(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x20C40A759441BLL);
  _Unwind_Resume(a1);
}

GlobalICNSInfo *globalICNSInfoReleaseProc(GlobalICNSInfo *result)
{
  if (result)
  {
    GlobalICNSInfo::~GlobalICNSInfo(result);
    JUMPOUT(0x18C11C0E0);
  }
  return result;
}

uint64_t IIO_Reader_ICNS::updateSourceProperties(IIO_Reader_ICNS *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  char v33 = 0;
  *(_DWORD *)unsigned int v32 = 0;
  unsigned __int16 v8 = IIOImageReadSession::globalInfoForType(a2, 1229147731);
  unint64_t v9 = v8;
  if (!v8) {
    operator new();
  }
  IIO_Reader_ICNS::extractImageInfo(v8, (void **)v8, a2);
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v29);
  CFMutableArrayRef v26 = 0;
  value = 0;
  uint64_t v28 = 0;
  IIOArray::IIOArray((IIOArray *)&v26);
  IIODictionary::setObjectForKey((IIODictionary *)&v29, value, @"Images");
  for (unsigned int i = 0; i < GlobalICNSInfo::icnsImageCount(v9); ++i)
  {
    uint64_t v25 = 0;
    *(_OWORD *)unint64_t v23 = 0u;
    long long v24 = 0u;
    long long v22 = 0u;
    GlobalICNSInfo::getICNSImageInfoAtIndex(v9, i, (uint64_t)&v22);
    *(_DWORD *)unsigned int v32 = bswap32(v24);
    v20[0] = 0;
    v20[1] = 0;
    uint64_t v21 = 0;
    IIOString::IIOString((IIOString *)v20, v32);
    uint64_t v17 = 0;
    char v18 = 0;
    uint64_t v19 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v17);
    IIODictionary::setObjectForKey((IIODictionary *)&v17, v21, @"IconType");
    IIONumber::IIONumber((IIONumber *)v15, LOWORD(v23[1]));
    IIODictionary::setObjectForKey((IIODictionary *)&v17, v16, @"PixelWidth");
    IIONumber::~IIONumber((IIONumber *)v15);
    IIONumber::IIONumber((IIONumber *)v15, WORD1(v23[1]));
    IIODictionary::setObjectForKey((IIODictionary *)&v17, v16, @"PixelHeight");
    IIONumber::~IIONumber((IIONumber *)v15);
    if (BYTE1(v25) == 2) {
      int v11 = 144;
    }
    else {
      int v11 = 72;
    }
    IIONumber::IIONumber((IIONumber *)v15, v11);
    IIODictionary::setObjectForKey((IIODictionary *)&v17, v16, @"DPIWidth");
    IIONumber::~IIONumber((IIONumber *)v15);
    if (BYTE1(v25) == 2) {
      int v12 = 144;
    }
    else {
      int v12 = 72;
    }
    IIONumber::IIONumber((IIONumber *)v15, v12);
    IIODictionary::setObjectForKey((IIODictionary *)&v17, v16, @"DPIHeight");
    IIONumber::~IIONumber((IIONumber *)v15);
    IIOArray::addObject(&v26, v18);
    IIODictionary::~IIODictionary((IIODictionary *)&v17);
    IIOString::~IIOString((IIOString *)v20);
  }
  int Count = IIOArray::getCount((IIOArray *)&v26);
  IIONumber::IIONumber((IIONumber *)&v22, Count);
  IIODictionary::setObjectForKey((IIODictionary *)&v29, v23[0], @"ImageCount");
  IIONumber::~IIONumber((IIONumber *)&v22);
  IIODictionary::setObjectForKey(a3, v30, @"{FileContents}");
  IIOArray::~IIOArray((IIOArray *)&v26);
  IIODictionary::~IIODictionary((IIODictionary *)&v29);
  return 0;
}

void sub_18873366C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x20C40A759441BLL);
  _Unwind_Resume(a1);
}

__n128 IIO_Reader_ICNS::extractImageInfo(IIO_Reader_ICNS *this, void **a2, IIOImageReadSession *a3)
{
  v45[2] = *MEMORY[0x1E4F143B8];
  if (!GlobalICNSInfo::icnsImageCount((GlobalICNSInfo *)a2)
    && IIOImageReadSession::isFinal(a3))
  {
    uint64_t v44 = 0;
    v45[0] = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    uint64_t v43 = 0;
    v45[1] = 0;
    IIOImageReadSession::rewind((uint64_t)a3);
    unsigned int v39 = 0;
    IIOImageReadSession::getBytes(a3, &v39, 4uLL);
    unsigned int v6 = v39;
    unsigned int v39 = bswap32(v39);
    if (v6 != 1936614249)
    {
      __n128 result = _cg_jpeg_mem_term("extractImageInfo", 194, "*** bad 'icns' - does not start with 'icns'\n");
      if (!a2) {
        return result;
      }
      goto LABEL_51;
    }
    IIOImageReadSession::skipBytes(a3, 4);
    uint64_t v7 = MEMORY[0x1E4F14390];
    do
    {
      if (IIOImageReadSession::getBytes(a3, &v44, 4uLL) != 4) {
        break;
      }
      LODWORD(v44) = bswap32(v44);
      if (IIOImageReadSession::getBytes(a3, (unsigned char *)&v44 + 4, 4uLL) != 4) {
        break;
      }
      unsigned int v8 = bswap32(HIDWORD(v44));
      HIDWORD(v44) = v8;
      if (v8 < 9) {
        break;
      }
      HIDWORD(v44) = v8 - 8;
      uint64_t v9 = IIO_Reader::minimumFileSize(a3);
      if (HIDWORD(v44) >= 0x10)
      {
        if (IIOImageReadSession::getBytes(a3, v45, 0x10uLL) != 16) {
          break;
        }
        ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler((IIO_ReaderHandler *)0x10);
        uint64_t v13 = IIO_ReaderHandler::readerForType(ReaderHandler, 1347307296);
        memset(v38, 0, sizeof(v38));
        uint64_t v14 = (IIO_ReaderHandler *)(*(uint64_t (**)(IIO_Reader *, void *, uint64_t, void, void *))(*(void *)v13 + 16))(v13, v45, 16, 0, v38);
        if (v14)
        {
          char v11 = 2;
        }
        else
        {
          unsigned int v15 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v14);
          int v16 = IIO_ReaderHandler::readerForType(v15, 1246769696);
          memset(v37, 0, sizeof(v37));
          char v11 = (*(unsigned int (**)(IIO_Reader *, void *, uint64_t, void, void *))(*(void *)v16 + 16))(v16, v45, 16, 0, v37)? 4: 1;
        }
        uint64_t v10 = 16;
      }
      else
      {
        uint64_t v10 = 0;
        char v11 = 1;
      }
      ICNSInfoTable = (__int16 *)GetICNSInfoTable();
      int v18 = v44;
      if (*ICNSInfoTable == -1)
      {
LABEL_21:
        if (v44 != 1414480672 && v44 != 1768842863)
        {
          unsigned int v21 = (int)v44 >> 24;
          if ((v44 & 0x80000000) != 0)
          {
            int v22 = __maskrune(v21, 0x40000uLL);
            int v18 = v44;
            unsigned int v21 = (int)v44 >> 24;
          }
          else
          {
            int v22 = *(_DWORD *)(v7 + 4 * v21 + 60) & 0x40000;
          }
          if (v22) {
            uint64_t v26 = v21;
          }
          else {
            uint64_t v26 = 46;
          }
          unsigned int v27 = v18 << 8 >> 24;
          if (v18 << 8 < 0)
          {
            int v28 = __maskrune(v27, 0x40000uLL);
            int v18 = v44;
            unsigned int v27 = (int)(v44 << 8) >> 24;
          }
          else
          {
            int v28 = *(_DWORD *)(v7 + 4 * v27 + 60) & 0x40000;
          }
          if (v28) {
            uint64_t v29 = v27;
          }
          else {
            uint64_t v29 = 46;
          }
          unsigned int v30 = (__int16)v18 >> 8;
          if (v18 << 16 < 0)
          {
            int v31 = __maskrune(v30, 0x40000uLL);
            int v18 = v44;
            unsigned int v30 = (__int16)v44 >> 8;
          }
          else
          {
            int v31 = *(_DWORD *)(v7 + 4 * v30 + 60) & 0x40000;
          }
          if (v31) {
            uint64_t v32 = v30;
          }
          else {
            uint64_t v32 = 46;
          }
          unsigned int v33 = (char)v18;
          if ((v18 << 24) <= 0x7F000000)
          {
            int v34 = *(_DWORD *)(v7 + 4 * (char)v18 + 60) & 0x40000;
          }
          else
          {
            int v34 = __maskrune((char)v18, 0x40000uLL);
            unsigned int v33 = (char)v44;
          }
          if (v34) {
            uint64_t v35 = v33;
          }
          else {
            uint64_t v35 = 46;
          }
          _cg_jpeg_mem_term("extractImageInfo", 277, "did not handle '%c%c%c%c' -- not found in ICNSInfoTable\n", v26, v29, v32, v35);
        }
      }
      else
      {
        uint64_t v19 = ICNSInfoTable + 16;
        while (v44 != *(_DWORD *)v19)
        {
          int v20 = v19[12];
          v19 += 28;
          if (v20 == -1) {
            goto LABEL_21;
          }
        }
        long long v24 = *((_OWORD *)v19 - 1);
        long long v23 = *(_OWORD *)v19;
        uint64_t v25 = *((void *)v19 + 2);
        long long v40 = *((_OWORD *)v19 - 2);
        *((void *)&v41 + 1) = *((void *)&v24 + 1);
        uint64_t v43 = v25;
        long long v42 = v23;
        *((void *)&v40 + 1) = v9;
        *(void *)&long long v41 = HIDWORD(v44);
        BYTE2(v43) = v11;
        GlobalICNSInfo::addICNSInfo(a2, (__int16 *)&v40);
      }
      uint64_t v36 = IIOImageReadSession::skipBytes(a3, HIDWORD(v44) - v10);
    }
    while (v36 == (IIOImageRead *)(HIDWORD(v44) - v10));
    if (a2) {
LABEL_51:
    }
      GlobalICNSInfo::sortInfo(a2);
  }
  return result;
}

uint64_t IIO_Reader_ICNS::getImageCount(IIO_Reader_ICNS *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  uint64_t v7 = IIOImageReadSession::globalInfoForType(a2, 1229147731);
  unsigned int v8 = v7;
  if (!v7) {
    operator new();
  }
  IIO_Reader_ICNS::extractImageInfo(v7, (void **)v7, a2);
  unsigned int v9 = GlobalICNSInfo::icnsImageCount(v8);
  if (a5) {
    *a5 = v9;
  }
  return 0;
}

void sub_188733BD4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x20C40A759441BLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_ICNS::hasCustomImageCountProc(IIO_Reader_ICNS *this)
{
  return 1;
}

uint64_t IIO_Reader_ICNS::hasCustomSourcePropertiesProc(IIO_Reader_ICNS *this)
{
  return 1;
}

uint64_t GetSizeForTiffType(uint64_t result)
{
  __n128 result = result;
  switch((int)result)
  {
    case 0:
      return result;
    case 1:
    case 2:
    case 6:
    case 7:
      return 1;
    case 3:
    case 8:
      return 2;
    case 4:
    case 9:
    case 11:
    case 13:
      return 4;
    case 5:
    case 10:
    case 12:
    case 16:
    case 17:
    case 18:
      return 8;
    case 14:
    case 15:
      goto LABEL_7;
    default:
      if (result == 32775) {
        return 8;
      }
LABEL_7:
      _cg_jpeg_mem_term("GetSizeForTiffType", 145, "*** ERROR: tag with unknown type [%d]\n", result);
      return 0;
  }
}

void ReadExifVers(uint64_t a1, uint64_t a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7)
{
  char v16 = 0;
  if (*(_DWORD *)(a7 + 4) == 4)
  {
    *(_DWORD *)cStr = *(_DWORD *)(a7 + 8);
    CFStringRef v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cStr, 0x600u);
    if (v12)
    {
      CFStringRef v13 = v12;
      CGImageMetadataTagRef v14 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeString, v12);
      CFRelease(v13);
      if (v14)
      {
        CGImageMetadataAddTagWithKey(a1, a6, v14);
        CFRelease(v14);
      }
    }
  }
}

void ReadGPSVers(uint64_t a1, uint64_t a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, unsigned __int8 *a7)
{
  CFStringRef v12 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%d.%d.%d.%d", a7[8], a7[9], a7[10], a7[11]);
  if (v12)
  {
    CFStringRef v13 = v12;
    CGImageMetadataTagRef v14 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeString, v12);
    CFRelease(v13);
    if (v14)
    {
      CGImageMetadataAddTagWithKey(a1, a6, v14);
      CFRelease(v14);
    }
  }
}

void ReadGPSCoords(uint64_t a1, IIOImageReadSession *this, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v15 = *(unsigned int *)(a7 + 8);
  if (a9)
  {
    uint64_t v16 = bswap32(v15);
    *(_DWORD *)(a7 + 8) = v16;
    if (IIOImageReadSession::getBytesAtOffset(this, &v29, v16 + a8, 0x18uLL) != 24) {
      return;
    }
    for (uint64_t i = 0; i != 24; i += 4)
      *(_DWORD *)((char *)&v29 + i) = bswap32(*(_DWORD *)((char *)&v29 + i));
  }
  else if (IIOImageReadSession::getBytesAtOffset(this, &v29, v15 + a8, 0x18uLL) != 24)
  {
    return;
  }
  if (*(_WORD *)a7 == 7)
  {
    double v19 = 0.0;
    double v20 = 0.0;
    if (HIDWORD(v29))
    {
      LODWORD(v20) = v29;
      double v17 = (double)HIDWORD(v29);
      double v20 = (double)*(unint64_t *)&v20 / (double)HIDWORD(v29);
    }
    if (HIDWORD(v30))
    {
      LODWORD(v19) = v30;
      double v17 = (double)HIDWORD(v30);
      double v19 = (double)*(unint64_t *)&v19 / (double)HIDWORD(v30);
    }
    if (HIDWORD(v31))
    {
      LODWORD(v17) = v31;
      double v21 = (double)*(unint64_t *)&v17 / (double)HIDWORD(v31);
      if (v21 > 3600.0)
      {
        double v20 = v20 + (double)(uint64_t)(v21 / 3600.0);
        double v21 = v21 - (double)(3600 * (uint64_t)(v21 / 3600.0));
      }
      if (v21 > 60.0)
      {
        uint64_t v22 = (uint64_t)(v21 / 60.0);
        double v19 = v19 + (double)v22;
        double v21 = v21 - (double)(60 * v22);
        if (v19 > 60.0)
        {
          double v20 = v20 + (double)(uint64_t)(v19 / 60.0);
          double v19 = v19 - (double)(60 * (uint64_t)(v19 / 60.0));
        }
      }
    }
    else
    {
      double v21 = 0.0;
    }
    if (v20 > 23.0) {
      double v20 = v20 + -23.0;
    }
    CFStringRef v26 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%.2ld:%.2ld:%05.2f", (uint64_t)v20, (uint64_t)v19, *(void *)&v21);
  }
  else
  {
    double v23 = 0.0;
    if (v29) {
      BOOL v24 = HIDWORD(v29) == 0;
    }
    else {
      BOOL v24 = 1;
    }
    double v25 = 0.0;
    if (!v24) {
      double v25 = (double)v29 / (double)HIDWORD(v29);
    }
    if (v30 && HIDWORD(v30)) {
      double v23 = (double)v30 / (double)HIDWORD(v30);
    }
    if (v31 && HIDWORD(v31)) {
      double v23 = v23 + (double)v31 / ((double)HIDWORD(v31) * 60.0);
    }
    if (v25 > 180.0) {
      double v25 = 180.0;
    }
    CFStringRef v26 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%ld,%g", (uint64_t)v25, v23 + (v25 - (double)(uint64_t)v25) * 60.0);
  }
  CFStringRef v27 = v26;
  if (v26)
  {
    CGImageMetadataTagRef v28 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeString, v26);
    CFRelease(v27);
    if (v28)
    {
      CGImageMetadataAddTagWithKey(a1, a6, v28);
      CFRelease(v28);
    }
  }
}

void ReadUserComment(int a1, IIOImageReadSession *this, int a3, int a4, int a5, int a6, uint64_t a7, uint64_t a8, char a9)
{
  if (*(_DWORD *)(a7 + 4) > 8u)
  {
    int Size = IIOImageReadSession::getSize(this);
    size_t v13 = *(unsigned int *)(a7 + 4);
    if ((unint64_t)Size <= v13)
    {
      _cg_jpeg_mem_term("ReadUserComment", 1203, "*** ERROR: tag-count too big: %d    image-size: %ld\n");
    }
    else
    {
      CGImageMetadataTagRef v14 = malloc_type_malloc(v13, 0x8368BCDBuLL);
      unsigned int v15 = *(_DWORD *)(a7 + 8);
      if (a9)
      {
        unsigned int v15 = bswap32(v15);
        *(_DWORD *)(a7 + 8) = v15;
      }
      IIOImageReadSession::getBytesAtOffset(this, v14, a8 + v15, *(unsigned int *)(a7 + 4));
      if (*(void *)v14 == *(void *)ReadUserComment(CGImageMetadata *,IIOImageReadSession *,__CFString const*,__CFString const*,__CFString const*,CGImageMetadataTagKey *,tag_entry *,unsigned long,BOOL)::asciiCode) {
        operator new();
      }
      if (*(void *)v14 == *(void *)ReadUserComment(CGImageMetadata *,IIOImageReadSession *,__CFString const*,__CFString const*,__CFString const*,CGImageMetadataTagKey *,tag_entry *,unsigned long,BOOL)::jisCode) {
        operator new();
      }
      if (*(void *)v14 == *(void *)ReadUserComment(CGImageMetadata *,IIOImageReadSession *,__CFString const*,__CFString const*,__CFString const*,CGImageMetadataTagKey *,tag_entry *,unsigned long,BOOL)::uniCode) {
        operator new();
      }
      free(v14);
    }
  }
  else
  {
    _cg_jpeg_mem_term("ReadUserComment", 1195, "*** ERROR: tag-count: %d too small\n");
  }
}

void sub_18873444C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0xF1C40AFE2EBACLL);
  _Unwind_Resume(a1);
}

void ReadComponentsConfiguration(uint64_t a1, uint64_t a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7)
{
  uint64_t v12 = a7 + 8;
  CFMutableArrayRef v17 = 0;
  CFTypeRef value = 0;
  uint64_t v19 = 0;
  IIOArray::IIOArray((IIOArray *)&v17);
  for (uint64_t i = 0; i != 4; ++i)
  {
    IIOString::IIOString((IIOString *)v15, 0, @"%d", *(unsigned __int8 *)(v12 + i));
    IIOArray::addObject(&v17, v16);
    IIOString::~IIOString((IIOString *)v15);
  }
  CGImageMetadataTagRef v14 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeArrayOrdered, value);
  if (v14)
  {
    CGImageMetadataAddTagWithKey(a1, a6, v14);
    CFRelease(v14);
  }
  IIOArray::~IIOArray((IIOArray *)&v17);
}

void sub_188734560(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

__n128 ReadDeviceSettings(uint64_t a1, IIOImageReadSession *this, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, char a9)
{
  unint64_t v9 = *(unsigned int *)(a7 + 4);
  if (v9 <= 4)
  {
    return _cg_jpeg_mem_term("ReadDeviceSettings", 1289, "*** tagsize (%d) too small\n");
  }
  else if ((unint64_t)IIOImageReadSession::getSize(this) <= v9)
  {
    IIOImageReadSession::getSize(this);
    return _cg_jpeg_mem_term("ReadDeviceSettings", 1290, "*** tagsize (%d) larger than filesize (%d)\n");
  }
  else
  {
    int v18 = (unsigned __int8 *)malloc_type_malloc(*(unsigned int *)(a7 + 4), 0x65DDCCCAuLL);
    if (v18)
    {
      double v20 = v18;
      unsigned int v21 = *(_DWORD *)(a7 + 8);
      if (a9)
      {
        unsigned int v21 = bswap32(v21);
        *(_DWORD *)(a7 + 8) = v21;
      }
      unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(this, v18, a8 + v21, *(unsigned int *)(a7 + 4));
      if (BytesAtOffset == *(_DWORD *)(a7 + 4))
      {
        uint64_t v37 = 0;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v33 = 0u;
        long long v34 = 0u;
        IIOScanner::IIOScanner((IIOScanner *)&v33, v20, BytesAtOffset, a9 ^ 1);
        int Val16 = IIOScanner::getVal16((IIOScanner *)&v33);
        int v24 = IIOScanner::getVal16((IIOScanner *)&v33);
        if ((v24 * Val16) < *(_DWORD *)(a7 + 4))
        {
          CFMutableArrayRef v30 = 0;
          CFTypeRef value = 0;
          uint64_t v32 = 0;
          IIOArray::IIOArray((IIOArray *)&v30);
          for (uint64_t i = (const char *)IIOScanner::getString((IIOScanner *)&v33);
                i && *i >= 8;
                uint64_t i = (const char *)IIOScanner::getString((IIOScanner *)&v33))
          {
            IIOString::IIOString((IIOString *)v28, i);
            IIOArray::addObject(&v30, v29);
            IIOString::~IIOString((IIOString *)v28);
            if (*((void *)&v34 + 1) < (unint64_t)*(unsigned int *)(a7 + 4)
              && !*(unsigned char *)(*((void *)&v33 + 1) + *((void *)&v34 + 1)))
            {
              IIOScanner::getVal8((IIOScanner *)&v33);
            }
          }
          if (IIOArray::getCount((IIOArray *)&v30) != v24 * Val16)
          {
            unsigned int Count = IIOArray::getCount((IIOArray *)&v30);
            _cg_jpeg_mem_term("ReadDeviceSettings", 1323, "*** tag 0xA40B --> cols=%d  rows=%d   #of strings: %d\n", Val16, v24, Count);
          }
          CGImageMetadataTagRef v27 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeArrayOrdered, value);
          if (v27)
          {
            CGImageMetadataAddTagWithKey(a1, a6, v27);
            CFRelease(v27);
          }
          IIOArray::~IIOArray((IIOArray *)&v30);
        }
        IIOScanner::~IIOScanner((IIOScanner *)&v33);
      }
      free(v20);
    }
  }
  return result;
}

void sub_1887347F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  IIOArray::~IIOArray((IIOArray *)va);
  IIOScanner::~IIOScanner((IIOScanner *)va1);
  _Unwind_Resume(a1);
}

void ReadSceneType(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, char a9)
{
  if (*(_DWORD *)(a7 + 4) == 1 && *(_WORD *)(a7 + 2) == 7) {
    ReadMetadataByte(a1, a2, a3, a4, a5, a6, 0, a7, a8, a9);
  }
}

void ReadMetadataByte(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, int a7, uint64_t a8, uint64_t a9, char a10)
{
  size_t v15 = *(unsigned int *)(a8 + 4);
  if (v15 <= 4)
  {
    CFMutableArrayRef v17 = 0;
    uint64_t v19 = (unsigned int *)(a8 + 8);
    LODWORD(v18) = *(_DWORD *)(a8 + 4);
    goto LABEL_8;
  }
  CFMutableArrayRef v17 = (unsigned int *)malloc_type_calloc(v15, 1uLL, 0x6E2833ECuLL);
  unint64_t v18 = *(unsigned int *)(a8 + 4);
  uint64_t v19 = (unsigned int *)(a8 + 8);
  if (v18 < 5) {
    goto LABEL_8;
  }
  unsigned int v20 = *v19;
  if (a10)
  {
    unsigned int v20 = bswap32(v20);
    *uint64_t v19 = v20;
  }
  unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v17, a9 + v20, v18);
  uint64_t v19 = v17;
  unint64_t v18 = *(unsigned int *)(a8 + 4);
  if (BytesAtOffset == v18)
  {
LABEL_8:
    BOOL v22 = v18 <= 1 && a7 == 0;
    double v23 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
    if (v22)
    {
      if (!v18) {
        goto LABEL_29;
      }
      long long v33 = a6;
      CFStringRef name = a5;
      uint64_t v32 = a1;
      double v25 = 0;
      CGImageMetadataType v26 = kCGImageMetadataTypeString;
    }
    else
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      double v25 = Mutable;
      if (!*(_DWORD *)(a8 + 4))
      {
        if (!Mutable) {
          goto LABEL_29;
        }
        long long v33 = a6;
        CFStringRef name = a5;
        uint64_t v32 = a1;
        CGImageMetadataType v26 = kCGImageMetadataTypeArrayOrdered;
        goto LABEL_26;
      }
      long long v33 = a6;
      CFStringRef name = a5;
      uint64_t v32 = a1;
      CGImageMetadataType v26 = kCGImageMetadataTypeArrayOrdered;
    }
    unint64_t v27 = 0;
    CFAllocatorRef v28 = *v23;
    do
    {
      CFStringRef v29 = CFStringCreateWithFormat(v28, 0, @"%d", *((unsigned __int8 *)v19 + v27));
      if ((a7 & 1) != 0 || (unint64_t v30 = *(unsigned int *)(a8 + 4), v30 >= 2))
      {
        CFArrayAppendValue(v25, v29);
        CFRelease(v29);
        CFStringRef v29 = 0;
        unint64_t v30 = *(unsigned int *)(a8 + 4);
      }
      ++v27;
    }
    while (v27 < v30);
    if (!v25)
    {
      if (!v29) {
        goto LABEL_29;
      }
      CGImageMetadataTagRef v31 = CGImageMetadataTagCreate(a3, a4, name, v26, v29);
      goto LABEL_27;
    }
LABEL_26:
    CGImageMetadataTagRef v31 = CGImageMetadataTagCreate(a3, a4, name, v26, v25);
    CFStringRef v29 = (CFStringRef)v25;
LABEL_27:
    CFRelease(v29);
    if (v31)
    {
      CGImageMetadataAddTagWithKey(v32, v33, v31);
      CFRelease(v31);
    }
  }
LABEL_29:
  if (v17)
  {
    free(v17);
  }
}

void ReadArtist(void *a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, unsigned __int8 a9)
{
  if (!*(_DWORD *)(a7 + 4)) {
    return;
  }
  if (*(_WORD *)(a7 + 2) != 2) {
    return;
  }
  ASCIIString = (const char *)ReadAndCreateASCIIString(a2, (unsigned __int16 *)a7, a8, a9);
  if (!ASCIIString) {
    return;
  }
  size_t v15 = (char *)ASCIIString;
  CFAllocatorRef v16 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v17 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ASCIIString, 0x8000100u);
  if (v17)
  {
    CFStringRef v18 = v17;
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(v16, v17, @"; ");
    if (!ArrayBySeparatingStrings) {
      goto LABEL_22;
    }
    TagWithPath = (CGImageMetadataTag *)CGImageMetadataGetTagWithPath(a1, 0, @"dc:creator");
    if (!TagWithPath
      || (uint64_t v21 = (uint64_t)TagWithPath, CGImageMetadataTagGetType(TagWithPath) != kCGImageMetadataTypeArrayOrdered))
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(v16, 1, MEMORY[0x1E4F1D510]);
      if (CFArrayGetCount(ArrayBySeparatingStrings) >= 1)
      {
        CFIndex v28 = 0;
        do
        {
          CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v28);
          CFArraySetValueAtIndex(Mutable, v28++, ValueAtIndex);
        }
        while (v28 < CFArrayGetCount(ArrayBySeparatingStrings));
      }
      CGImageMetadataTagRef v30 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeArrayOrdered, Mutable);
      if (v30)
      {
        CGImageMetadataTagRef v31 = v30;
        CGImageMetadataAddTagWithKey((uint64_t)a1, a6, v30);
        CFRelease(v31);
      }
      goto LABEL_23;
    }
    CFArrayRef Value = (const __CFArray *)CGImageMetadataTagGetValue(v21);
    if (Value && (CFArrayRef v23 = Value, v24 = CFGetTypeID(Value), v24 == CFArrayGetTypeID()))
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutableCopy(v16, 0, v23);
      if (CFArrayGetCount(ArrayBySeparatingStrings) >= 1)
      {
        CFIndex v26 = 0;
        do
        {
          unint64_t v27 = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v26);
          CFArrayAppendValue(Mutable, v27);
          ++v26;
        }
        while (v26 < CFArrayGetCount(ArrayBySeparatingStrings));
      }
      CGImageMetadataTagSetValue(v21, (const __CFString *)Mutable);
    }
    else
    {
LABEL_22:
      CFMutableArrayRef Mutable = 0;
    }
LABEL_23:
    free(v15);
    CFRelease(v18);
    if (ArrayBySeparatingStrings) {
      CFRelease(ArrayBySeparatingStrings);
    }
    if (Mutable)
    {
      CFRelease(Mutable);
    }
    return;
  }

  free(v15);
}

void *ReadAndCreateASCIIString(IIOImageReadSession *a1, unsigned __int16 *a2, uint64_t a3, int a4)
{
  int Size = IIOImageReadSession::getSize(a1);
  unint64_t v9 = *((unsigned int *)a2 + 1);
  if ((unint64_t)Size < v9)
  {
    _cg_jpeg_mem_term("ReadAndCreateASCIIString", 970, "p->count: %ld > rrefSize: %ld\n", *((unsigned int *)a2 + 1), Size);
    return 0;
  }
  uint64_t v11 = malloc_type_malloc(v9 + 1, 0xB35469C1uLL);
  uint64_t v10 = v11;
  if (v11)
  {
    v11[*((unsigned int *)a2 + 1)] = 0;
    unint64_t v12 = *((unsigned int *)a2 + 1);
    size_t v13 = (unsigned int *)(a2 + 4);
    if (v12 <= 4)
    {
      memmove(v11, v13, *((unsigned int *)a2 + 1));
      return v10;
    }
    unsigned int v14 = *v13;
    if (a4)
    {
      unsigned int v14 = bswap32(v14);
      *size_t v13 = v14;
    }
    unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a1, v11, a3 + v14, v12);
    uint64_t v16 = *((unsigned int *)a2 + 1);
    if (BytesAtOffset != v16)
    {
      LogWarning("ReadAndCreateASCIIString", 994, "Unable to read ASCII TIFF Tag #%d with reported length (%u)\n", *a2, v16);
      free(v10);
      return 0;
    }
  }
  return v10;
}

void ReadCopyright(CGImageMetadata *a1, IIOImageReadSession *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9)
{
  if (*(_DWORD *)(a7 + 4))
  {
    if (*(_WORD *)(a7 + 2) == 2)
    {
      ASCIIString = (const char *)ReadAndCreateASCIIString(a2, (unsigned __int16 *)a7, a8, a9);
      if (ASCIIString)
      {
        uint64_t v11 = (char *)ASCIIString;
        CFStringRef v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ASCIIString, 0x8000100u);
        if (v12)
        {
          CFStringRef v13 = v12;
          CGImageMetadataSetValueWithPath(a1, 0, @"dc:rights[x-default]", v12);
          CFRelease(v13);
        }
        free(v11);
      }
    }
  }
}

void ReadImageDescription(CGImageMetadata *a1, IIOImageReadSession *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9)
{
  if (*(_DWORD *)(a7 + 4))
  {
    if (*(_WORD *)(a7 + 2) == 2)
    {
      ASCIIString = (const char *)ReadAndCreateASCIIString(a2, (unsigned __int16 *)a7, a8, a9);
      if (ASCIIString)
      {
        uint64_t v11 = (char *)ASCIIString;
        CFStringRef v12 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ASCIIString, 0x8000100u);
        if (v12)
        {
          CFStringRef v13 = v12;
          CGImageMetadataSetValueWithPath(a1, 0, @"dc:description[x-default]", v12);
          CFRelease(v13);
        }
        free(v11);
      }
    }
  }
}

__n128 ReadDateTime(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, unsigned __int8 a9)
{
  int v9 = *(_DWORD *)(a7 + 4);
  if ((v9 - 21) <= 0xFFFFFFFD) {
    return _cg_jpeg_mem_term("ReadDateTime", 1515, "Bad dataTime length: %d (expected 20)\n", *(_DWORD *)(a7 + 4));
  }
  if (*(_WORD *)(a7 + 2) == 2)
  {
    if (v9 == 19) {
      _cg_jpeg_mem_term("ReadDateTime", 1519, "Bad dataTime length: 19 (expected 20) missing null termination?\n");
    }
    ASCIIString = (const char *)ReadAndCreateASCIIString(a2, (unsigned __int16 *)a7, a8, a9);
    if (ASCIIString)
    {
      unsigned int v20 = (char *)ASCIIString;
      CFStringRef v21 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ASCIIString, 0x8000100u);
      if (v21)
      {
        CFStringRef v22 = v21;
        CFStringRef XMPDateTimeFromEXIFDateTime = CreateXMPDateTimeFromEXIFDateTime(v21);
        if (XMPDateTimeFromEXIFDateTime)
        {
          CFStringRef v24 = XMPDateTimeFromEXIFDateTime;
          CGImageMetadataTagRef v25 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeString, XMPDateTimeFromEXIFDateTime);
          if (v25)
          {
            CGImageMetadataTagRef v26 = v25;
            CGImageMetadataAddTagWithKey(a1, a6, v25);
            CFRelease(v26);
          }
          CFRelease(v24);
        }
        CFRelease(v22);
      }
      free(v20);
    }
  }
  else
  {
    return _cg_jpeg_mem_term("ReadDateTime", 1516, "Bad dataTime format (tiff_ASCII)\n");
  }
  return result;
}

__n128 ReadOffsetTime(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, unsigned __int8 a9)
{
  if (*(_DWORD *)(a7 + 4) != 7) {
    return _cg_jpeg_mem_term("ReadOffsetTime", 1564, "Bad dataOffsetTime length: %d (expected 7)\n", *(_DWORD *)(a7 + 4));
  }
  if (*(_WORD *)(a7 + 2) == 2)
  {
    ASCIIString = (const char *)ReadAndCreateASCIIString(a2, (unsigned __int16 *)a7, a8, a9);
    if (ASCIIString)
    {
      uint64_t v16 = (char *)ASCIIString;
      CFStringRef v17 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ASCIIString, 0x8000100u);
      if (v17)
      {
        CFStringRef v18 = v17;
        CGImageMetadataTagRef v19 = CGImageMetadataTagCreate(a3, a4, a5, kCGImageMetadataTypeString, v17);
        if (v19)
        {
          CGImageMetadataTagRef v20 = v19;
          CGImageMetadataAddTagWithKey(a1, a6, v19);
          CFRelease(v20);
        }
        CFRelease(v18);
      }
      free(v16);
    }
  }
  else
  {
    return _cg_jpeg_mem_term("ReadOffsetTime", 1565, "Bad dataOffsetTime format (tiff_ASCII)\n");
  }
  return result;
}

void ReadFlash(void *a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, char a9)
{
  if (*(_DWORD *)(a7 + 4) == 1 && *(_WORD *)(a7 + 2) == 3)
  {
    ReadMetadataShort((uint64_t)a1, a2, a3, a4, a5, a6, 0, a7, a8, a9);
    TagWithPath = CGImageMetadataGetTagWithPath(a1, 0, @"exif:Flash");
    if (TagWithPath)
    {
      uint64_t v11 = (uint64_t)TagWithPath;
      CFStringRef Value = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)TagWithPath);
      IntCFStringRef Value = CFStringGetIntValue(Value);
      XMPFlashStructFromInt = CreateXMPFlashStructFromInt(IntValue);
      if (XMPFlashStructFromInt)
      {
        CFStringRef v15 = (const __CFString *)XMPFlashStructFromInt;
        CGImageMetadataTagSetValueType(v11, 6);
        CGImageMetadataTagSetValue(v11, v15);
        CFRelease(v15);
      }
    }
  }
}

void ReadFileSource(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, char a9)
{
  if (*(_DWORD *)(a7 + 4) == 1 && *(_WORD *)(a7 + 2) == 7) {
    ReadMetadataByte(a1, a2, a3, a4, a5, a6, 0, a7, a8, a9);
  }
}

void ReadPhotoshopImageResourceTag(uint64_t a1, IIOImageReadSession *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  size_t v10 = *(unsigned int *)(a7 + 4);
  if ((v10 - 20001) > 0xFFFFB1E8)
  {
    unsigned int v14 = malloc_type_calloc(v10, 1uLL, 0xAB6CB84AuLL);
    unint64_t v16 = *(unsigned int *)(a7 + 4);
    LODWORD(v15) = *(_DWORD *)(a7 + 8);
    unsigned int v17 = bswap32(v15);
    if (a9) {
      uint64_t v15 = v17;
    }
    else {
      uint64_t v15 = v15;
    }
    if (IIOImageReadSession::getBytesAtOffset(a2, v14, v15 + a8, *(unsigned int *)(a7 + 4)) == v16) {
      ReadPhotoshopImageResource(a1, (uint64_t)v14, v16);
    }
    if (v14)
    {
      free(v14);
    }
  }
  else
  {
    LogError("ReadPhotoshopImageResourceTag", 1657, "*** ERROR: Skipping Photoshop Image Resources block, size is %d\n", *(_DWORD *)(a7 + 4));
  }
}

__n128 ReadCompositeTimes(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a9) {
    *(_DWORD *)(a7 + 8) = bswap32(*(_DWORD *)(a7 + 8));
  }
  if (*(_WORD *)(a7 + 2) == 7)
  {
    if (*(_DWORD *)(a7 + 4) <= 0x39u) {
      return _cg_jpeg_mem_term("ReadCompositeTimes", 1716, "*** ERROR: count < fixedSize + sizeof(uint16_t) [%d < %d]", *(_DWORD *)(a7 + 4), 58);
    }
    CFStringRef v33 = a3;
    CFStringRef v34 = a4;
    CFStringRef name = a5;
    uint64_t v31 = a1;
    uint64_t v32 = a6;
    CFStringRef v12 = (unsigned int *)malloc_type_calloc(0x38uLL, 1uLL, 0xF0A6139AuLL);
    int v36 = 0;
    CFAllocatorRef v13 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    IIOImageReadSession::getBytesAtOffset(a2, v12, *(unsigned int *)(a7 + 8) + a8, 0x38uLL);
    if (a9)
    {
      for (uint64_t i = 0; i != 14; ++i)
        v12[i] = bswap32(v12[i]);
    }
    for (uint64_t j = 0; j != 14; j += 2)
    {
      CFStringRef v17 = CFStringCreateWithFormat(v13, 0, @"%u/%u", v12[j], v12[j + 1]);
      CFArrayAppendValue(Mutable, v17);
      CFRelease(v17);
    }
    IIOImageReadSession::getBytesAtOffset(a2, (unsigned char *)&v36 + 2, a8 + *(unsigned int *)(a7 + 8) + 56, 2uLL);
    unsigned int v18 = HIWORD(v36);
    if (a9)
    {
      unsigned int v18 = __rev16(HIWORD(v36));
      HIWORD(v36) = v18;
    }
    CFStringRef v19 = CFStringCreateWithFormat(v13, 0, @"%d", v18);
    CFArrayAppendValue(Mutable, v19);
    CFRelease(v19);
    if (HIWORD(v36))
    {
      IIOImageReadSession::getBytesAtOffset(a2, &v36, a8 + *(unsigned int *)(a7 + 8) + 58, 2uLL);
      unsigned int v20 = (unsigned __int16)v36;
      if (a9)
      {
        unsigned int v20 = __rev16((unsigned __int16)v36);
        LOWORD(v36) = v20;
      }
      CFStringRef v21 = CFStringCreateWithFormat(v13, 0, @"%d", v20);
      CFArrayAppendValue(Mutable, v21);
      CFRelease(v21);
      if ((*(_DWORD *)(a7 + 4) - 56) - 4 != 8 * (unsigned __int16)v36) {
        goto LABEL_27;
      }
      unint64_t v22 = 8 * (unsigned __int16)v36;
      if ((unsigned __int16)v36 >= 8u) {
        CFStringRef v12 = (unsigned int *)reallocf(v12, 8 * (unsigned __int16)v36);
      }
    }
    else
    {
      if (*(_DWORD *)(a7 + 4) != 60) {
        goto LABEL_27;
      }
      unint64_t v22 = 0;
    }
    IIOImageReadSession::getBytesAtOffset(a2, v12, a8 + *(unsigned int *)(a7 + 8) + 60, v22);
    int v23 = (unsigned __int16)v36;
    if (!a9) {
      goto LABEL_24;
    }
    if ((_WORD)v36)
    {
      uint64_t v24 = 2 * (unsigned __int16)v36;
      CGImageMetadataTagRef v25 = v12;
      do
      {
        unsigned int *v25 = bswap32(*v25);
        ++v25;
        --v24;
      }
      while (v24);
LABEL_24:
      if (v23)
      {
        unint64_t v26 = 0;
        unint64_t v27 = v12 + 1;
        do
        {
          CFStringRef v28 = CFStringCreateWithFormat(v13, 0, @"%u/%u", *(v27 - 1), *v27, v31, v32, v33, v34, name);
          CFArrayAppendValue(Mutable, v28);
          CFRelease(v28);
          ++v26;
          v27 += 2;
        }
        while (v26 < (unsigned __int16)v36);
      }
    }
LABEL_27:
    if (Mutable)
    {
      CGImageMetadataTagRef v29 = CGImageMetadataTagCreate(v33, v34, name, kCGImageMetadataTypeArrayOrdered, Mutable);
      CFRelease(Mutable);
      if (v29)
      {
        CGImageMetadataAddTagWithKey(v31, v32, v29);
        CFRelease(v29);
      }
    }
    free(v12);
  }
  return result;
}

void ReadTiffMetadata(IIOImageReadSession *a1, CGImageMetadata *a2, unint64_t a3, unsigned int a4, const __CFData *a5, char a6)
{
  CGMutableImageMetadataRef MetadataFromDatablock = CreateMetadataFromDatablock(a1, tagdefsIFD0, a3, a4, a5, a6);
  if (MetadataFromDatablock)
  {
    CGMutableImageMetadataRef v8 = MetadataFromDatablock;
    CGImageMetadataMerge((uint64_t)a2, (uint64_t)MetadataFromDatablock, 0);
    CFRelease(v8);
  }
}

uint64_t SRationalApprox(double a1, int *a2, unsigned int *a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t result = RationalApprox(a1, 0x7FFFFFFFLL, &v7, &v6);
  *a2 = v7;
  *a3 = v6;
  return result;
}

uint64_t CreateExifBufferFromPropertiesTIFF(IIODictionary *a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t *a5)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  bzero(v8, 0x9A0uLL);
  if (a1 && IIODictionary::getObjectForKey(a1, @"{Exif}")) {
    operator new();
  }
  if (a5) {
    *a5 = 0;
  }
  return 0;
}

void sub_188735D80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t CreateGPSBufferFromPropertiesTIFF(IIODictionary *a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t *a5, unint64_t *a6)
{
  return _CreateGPSBufferFromPropertiesTIFF(a1, a4, 0, a5, (BOOL)a5, a6);
}

uint64_t _CreateGPSBufferFromPropertiesTIFF(IIODictionary *a1, unint64_t a2, unint64_t a3, void *a4, BOOL a5, unint64_t *a6)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  bzero(v9, 0x420uLL);
  if (a1 && IIODictionary::getObjectForKey(a1, @"{GPS}")) {
    operator new();
  }
  if (a4) {
    *a4 = 0;
  }
  return 0;
}

void sub_188736124(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

uint64_t CreateGPSBufferFromPropertiesTIFFNew(IIODictionary *a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t *a6)
{
  return _CreateGPSBufferFromPropertiesTIFF(a1, a4, a5, a6, a5, a6);
}

CFStringRef ___ZL27CreateMetadataFromDatablockP19IIOImageReadSessionPK6tagdefmmbPK8__CFDataj_block_invoke_2()
{
  CFStringRef result = (const __CFString *)malloc_type_malloc(0x58uLL, 0x2004093837F09uLL);
  uint64_t v1 = (uint64_t)result;
  if (result)
  {
    uint64_t v2 = 0;
    long long v3 = (const __CFString ***)&off_1E53C6CA0;
    do
    {
      unsigned int v4 = *(v3 - 3);
      if (v4) {
        CFStringRef result = *v4;
      }
      else {
        CFStringRef result = 0;
      }
      uint64_t v5 = *v3;
      if (*v3)
      {
        CFStringRef v6 = 0;
        if (result && *v5)
        {
          CFStringRef result = (const __CFString *)CGImageMetadataTagKeyCreate(result, *v5);
          CFStringRef v6 = result;
        }
      }
      else
      {
        CFStringRef v6 = 0;
      }
      *(void *)(v1 + v2) = v6;
      v2 += 8;
      v3 += 7;
    }
    while (v2 != 88);
  }
  IFD1TagKeys = v1;
  return result;
}

CFStringRef ___ZL27CreateMetadataFromDatablockP19IIOImageReadSessionPK6tagdefmmbPK8__CFDataj_block_invoke_4()
{
  CFStringRef result = (const __CFString *)malloc_type_malloc(0x100uLL, 0x2004093837F09uLL);
  uint64_t v1 = (uint64_t)result;
  if (result)
  {
    uint64_t v2 = 0;
    long long v3 = (const __CFString ***)&off_1ED4B4868;
    do
    {
      unsigned int v4 = *(v3 - 4);
      if (v4) {
        CFStringRef result = *v4;
      }
      else {
        CFStringRef result = 0;
      }
      uint64_t v5 = *v3;
      if (*v3 || (uint64_t v5 = *(v3 - 1)) != 0)
      {
        CFStringRef v6 = 0;
        if (result && *v5)
        {
          CFStringRef result = (const __CFString *)CGImageMetadataTagKeyCreate(result, *v5);
          CFStringRef v6 = result;
        }
      }
      else
      {
        CFStringRef v6 = 0;
      }
      *(void *)(v1 + v2) = v6;
      v3 += 7;
      v2 += 8;
    }
    while (v2 != 256);
  }
  GPSTagKeys = v1;
  return result;
}

void call_RAWCamera_readMakerNoteProps(uint64_t a1, IIODictionary *a2, uint64_t a3, uint64_t a4, char a5)
{
  uint64_t v15 = a1;
  unsigned int v14 = a2;
  uint64_t v13 = a3;
  uint64_t v12 = 0;
  uint64_t v11 = a4;
  unsigned __int8 v10 = a5 & 1;
  IIONumber::IIONumber((IIONumber *)v9, a4);
  IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v9, @"MakerNoteSize", @"{MakerNoteInfo}");
  IIONumber::~IIONumber((IIONumber *)v9);
  if (gReadMakerNoteProps)
  {
    CFStringRef v6 = (void (*)(uint64_t, uint64_t, uint64_t, uint64_t, void))gReadMakerNoteProps;
    uint64_t v7 = v15;
    uint64_t v8 = IIOImageSource::cf(v14);
    v6(v7, v8, v13, v12, v10);
  }
  IIODictionary::removeObjectForKey(v14, @"{MakerNoteInfo}");
}

void ReadMetadataSRtnl(uint64_t a1, IIOImageReadSession *a2, const __CFString *a3, const __CFString *a4, const __CFString *a5, const void *a6, int a7, uint64_t a8, char a9)
{
  unint64_t v16 = (unsigned int *)malloc_type_calloc(*(unsigned int *)(a8 + 4), 8uLL, 0xFF299D4DuLL);
  unsigned int v17 = *(_DWORD *)(a8 + 8);
  if (a9)
  {
    unsigned int v17 = bswap32(v17);
    *(_DWORD *)(a8 + 8) = v17;
  }
  unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v16, v17, (8 * *(_DWORD *)(a8 + 4)));
  unsigned int v19 = *(_DWORD *)(a8 + 4);
  if (BytesAtOffset == 8 * v19)
  {
    if ((v19 & 0x7FFFFFFF) != 0 && a9)
    {
      unint64_t v20 = 0;
      do
      {
        v16[v20] = bswap32(v16[v20]);
        ++v20;
        unsigned int v19 = *(_DWORD *)(a8 + 4);
      }
      while (v20 < 2 * v19);
    }
    BOOL v21 = v19 <= 1 && a7 == 0;
    unint64_t v22 = (const __CFAllocator **)MEMORY[0x1E4F1CF80];
    if (v21)
    {
      if (!v19) {
        goto LABEL_30;
      }
      uint64_t v37 = a1;
      CFStringRef prefix = a4;
      CFStringRef v36 = a5;
      CGImageMetadataTagRef v25 = a6;
      uint64_t v24 = 0;
      int v26 = 1;
    }
    else
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
      uint64_t v24 = Mutable;
      if (!*(_DWORD *)(a8 + 4))
      {
        if (!Mutable) {
          goto LABEL_30;
        }
        CGImageMetadataType v33 = kCGImageMetadataTypeArrayOrdered;
        CFStringRef v32 = a3;
        goto LABEL_27;
      }
      uint64_t v37 = a1;
      CFStringRef prefix = a4;
      CFStringRef v36 = a5;
      CGImageMetadataTagRef v25 = a6;
      int v26 = 3;
    }
    CGImageMetadataType type = v26;
    unint64_t v27 = 0;
    CFAllocatorRef v28 = *v22;
    CGImageMetadataTagRef v29 = v16 + 1;
    do
    {
      CFStringRef v30 = CFStringCreateWithFormat(v28, 0, @"%d/%d", *(v29 - 1), *v29);
      if ((a7 & 1) != 0 || (unint64_t v31 = *(unsigned int *)(a8 + 4), v31 >= 2))
      {
        CFArrayAppendValue(v24, v30);
        CFRelease(v30);
        CFStringRef v30 = 0;
        unint64_t v31 = *(unsigned int *)(a8 + 4);
      }
      v29 += 2;
      ++v27;
    }
    while (v27 < v31);
    a6 = v25;
    a4 = prefix;
    if (!v24)
    {
      a1 = v37;
      if (!v30) {
        goto LABEL_30;
      }
      CGImageMetadataTagRef v34 = CGImageMetadataTagCreate(a3, prefix, v36, type, v30);
      goto LABEL_28;
    }
    a5 = v36;
    a1 = v37;
    CFStringRef v32 = a3;
    CGImageMetadataType v33 = type;
LABEL_27:
    CGImageMetadataTagRef v34 = CGImageMetadataTagCreate(v32, a4, a5, v33, v24);
    CFStringRef v30 = (CFStringRef)v24;
LABEL_28:
    CFRelease(v30);
    if (v34)
    {
      CGImageMetadataAddTagWithKey(a1, a6, v34);
      CFRelease(v34);
    }
  }
LABEL_30:

  free(v16);
}

uint64_t ___ZL16validValueForKeyPK6tagdefPKv_block_invoke(uint64_t a1, const __CFString *cf)
{
  CFTypeID v4 = CFGetTypeID(cf);
  uint64_t result = CFStringGetTypeID();
  if (v4 == result)
  {
    uint64_t result = CFStringGetLength(cf);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += result + 2;
  }
  return result;
}

void ___ZL18WriteValueForTagIDPKvmttbPh_block_invoke(void *a1, CFTypeRef cf, uint64_t a3, unsigned char *a4)
{
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 == CFStringGetTypeID())
  {
    memset(v16, 0, sizeof(v16));
    IIOString::IIOString((IIOString *)v16, cf);
    int v8 = *(_DWORD *)(*(void *)(a1[4] + 8) + 24);
    unint64_t v9 = IIOString::length((IIOString *)v16) + v8;
    unint64_t v10 = a1[5];
    if (v10 <= v9)
    {
      *a4 = 1;
    }
    else
    {
      int v11 = *(_DWORD *)(*(void *)(a1[4] + 8) + 24);
      unsigned int v12 = IIOString::length((IIOString *)v16);
      uint64_t v13 = a1[6];
      uint64_t v14 = *(unsigned int *)(*(void *)(a1[4] + 8) + 24);
      uint64_t v15 = (const char *)IIOString::utf8String((IIOString *)v16);
      *(_DWORD *)(*(void *)(a1[4] + 8) + 24) += snprintf((char *)(v13 + v14), v10 - (v12 + v11), "%s", v15);
      *(_DWORD *)(*(void *)(a1[4] + 8) + 24) += 2;
    }
    IIOString::~IIOString((IIOString *)v16);
  }
}

void sub_1887367B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIO_Reader_PVR::createReadPlugin()
{
}

{
  operator new();
}

void sub_188736838(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40E35DA6A8);
  _Unwind_Resume(a1);
}

void sub_1887368D8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40E35DA6A8);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PVR::updateSourceProperties(IIO_Reader_PVR *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  return 4294967246;
}

uint64_t IIO_Reader_PVR::getImageCount(IIO_Reader_PVR *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  unsigned int Size = IIOImageReadSession::getSize(a2);
  uint64_t v27 = 0;
  IIOImageReadSession::getBytesAtOffset(a2, &v27, 0x2CuLL, 4uLL);
  int v11 = v27;
  LODWORD(v27) = bswap32(v27);
  if (v11 == 559044176)
  {
    int v26 = 0;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v23 = 0u;
    IIOImageReadSession::getBytesAtOffset(a2, &v23, 0, 0x34uLL);
    if (DWORD2(v23) <= Size && DWORD1(v23) <= Size)
    {
      uint64_t v12 = 0;
      int v13 = HIDWORD(v23);
      if (HIDWORD(v23) <= 1) {
        int v13 = 1;
      }
      goto LABEL_12;
    }
    _cg_jpeg_mem_term("getImageCount", 169, "*** invalid PVR file: size: %d x %d  (fileSize: %d)\n");
    goto LABEL_18;
  }
  unint64_t BytesAtOffset = (IIO_ReaderHandler *)IIOImageReadSession::getBytesAtOffset(a2, &v27, 0, 4uLL);
  int v15 = v27;
  LODWORD(v27) = bswap32(v27);
  if (v15 == 55727696)
  {
    int v26 = 0;
    long long v24 = 0u;
    long long v25 = 0u;
    long long v23 = 0u;
    IIOImageReadSession::getBytesAtOffset(a2, &v23, 0, 0x34uLL);
    if (HIDWORD(v24) > Size || DWORD2(v24) > Size)
    {
      _cg_jpeg_mem_term("getImageCount", 190, "*** invalid PVR file: size: %d x %d  (fileSize: %d)\n");
    }
    else if (DWORD1(v25) >= 0x11)
    {
      _cg_jpeg_mem_term("getImageCount", 194, "*** bad numberOfSurfaces count [%d]\n");
    }
    else
    {
      unint64_t v16 = DWORD2(v25);
      if ((unint64_t)IIOImageReadSession::getSize(a2) >= v16)
      {
        uint64_t v12 = 0;
        int v13 = HIDWORD(v25);
LABEL_12:
        HIDWORD(v27) = v13;
        goto LABEL_21;
      }
      IIOImageReadSession::getSize(a2);
      _cg_jpeg_mem_term("getImageCount", 195, "*** bad numberOfFaces count [%d]  size: %d\n");
    }
    goto LABEL_18;
  }
  unsigned int v17 = (__CFString **)*((void *)this + 1);
  if (v17 == kCGImageTypeIdentifierKTX)
  {
    ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(BytesAtOffset);
    int v19 = 1263818784;
  }
  else
  {
    if (v17 != kCGImageTypeIdentifierKTX2)
    {
LABEL_18:
      uint64_t v12 = 4294967246;
      goto LABEL_21;
    }
    ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(BytesAtOffset);
    int v19 = 1263818802;
  }
  unint64_t v20 = IIO_ReaderHandler::readerForType(ReaderHandler, v19);
  uint64_t v12 = (*(uint64_t (**)(IIO_Reader *, IIOImageReadSession *, IIODictionary *, CGImageSourceStatus *, char *))(*(void *)v20 + 32))(v20, a2, a3, a4, (char *)&v27 + 4);
LABEL_21:
  unsigned int v21 = HIDWORD(v27);
  if (HIDWORD(v27) > Size)
  {
    _cg_jpeg_mem_term("getImageCount", 218, "*** invalid PVR file: MipMapunsigned int Count = %d  (fileSize: %d)\n", HIDWORD(v27), Size);
    unsigned int v21 = 0;
  }
  if (a5) {
    *a5 = v21;
  }
  return v12;
}

uint64_t IIO_Reader_PVR::hasCustomImageCountProc(IIO_Reader_PVR *this)
{
  return 1;
}

uint64_t IIO_Reader_PVR::hasCustomSourcePropertiesProc(IIO_Reader_PVR *this)
{
  return 1;
}

uint64_t _cg_TIFFComputeStrip(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 132);
  if (!v8)
  {
    TIFFErrorExt(*(void *)(a1 + 1200), "TIFFComputeStrip", "Unexpected rowsperstrip: %lu", a4, a5, a6, a7, a8, 0);
    return 0;
  }
  uint64_t v9 = a2 / v8;
  if (*(_WORD *)(a1 + 170) == 2)
  {
    if (*(unsigned __int16 *)(a1 + 130) > a3) {
      return v9 + *(_DWORD *)(a1 + 224) * a3;
    }
    TIFFErrorExtR(a1, "TIFFComputeStrip", "%lu: Sample out of range, max %lu", a4, a5, a6, a7, a8, a3);
    return 0;
  }
  return v9;
}

uint64_t _cg_TIFFNumberOfStrips(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 132);
  if (v8 == -1)
  {
    uint64_t v9 = 1;
  }
  else
  {
    if (!v8)
    {
      TIFFWarningExtR(a1, "TIFFNumberOfStrips", "RowsPerStrip is zero", a4, a5, a6, a7, a8, vars0);
      return 0;
    }
    uint64_t v9 = 0;
    unsigned int v10 = *(_DWORD *)(a1 + 92);
    if (v10 < -v8) {
      uint64_t v9 = (v8 + v10 - 1) / v8;
    }
  }
  if (*(_WORD *)(a1 + 170) != 2) {
    return v9;
  }
  unsigned int v11 = *(unsigned __int16 *)(a1 + 130);

  return _TIFFMultiply32(a1, v9, v11, "TIFFNumberOfStrips", a5, a6, a7, a8);
}

unint64_t TIFFVStripSize64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a2;
  if (a2 == -1) {
    unsigned int v8 = *(_DWORD *)(a1 + 92);
  }
  if (*(_WORD *)(a1 + 170) == 1 && *(_WORD *)(a1 + 122) == 6 && (*(unsigned char *)(a1 + 17) & 0x40) == 0)
  {
    int v39 = 0;
    if (*(_WORD *)(a1 + 130) == 3)
    {
      _cg_TIFFGetFieldDefaulted(a1, 530, a3, a4, a5, a6, a7, a8, &v39);
      if ((unsigned __int16)v39 <= 4u && ((1 << v39) & 0x16) != 0)
      {
        BOOL v10 = HIWORD(v39) == 4 || HIWORD(v39) - 3 >= 0xFFFFFFFE;
        BOOL v11 = !v10;
        if (HIWORD(v39) && !v11)
        {
          unsigned int v12 = *(_DWORD *)(a1 + 88);
          if (v12 >= -(unsigned __int16)v39) {
            unint64_t v13 = 0;
          }
          else {
            unint64_t v13 = ((unsigned __int16)v39 + v12 - 1) / (unsigned __int16)v39;
          }
          if (v8 < -HIWORD(v39)) {
            unint64_t v21 = (v8 + HIWORD(v39) - 1) / HIWORD(v39);
          }
          else {
            unint64_t v21 = 0;
          }
          unint64_t v22 = _TIFFMultiply64(a1, v13, HIWORD(v39) * (unsigned __int16)v39 + 2, "TIFFVStripSize64", a5, a6, a7, a8);
          char v27 = _TIFFMultiply64(a1, v22, *(unsigned __int16 *)(a1 + 116), "TIFFVStripSize64", v23, v24, v25, v26);
          unint64_t v32 = _TIFFMultiply64(a1, v22, *(unsigned __int16 *)(a1 + 116), "TIFFVStripSize64", v28, v29, v30, v31);
          if ((v27 & 7) != 0) {
            unint64_t v37 = (v32 >> 3) + 1;
          }
          else {
            unint64_t v37 = v32 >> 3;
          }
          return _TIFFMultiply64(a1, v37, v21, "TIFFVStripSize64", v33, v34, v35, v36);
        }
      }
      char v38 = v39;
      unint64_t v20 = "Invalid YCbCr subsampling (%dx%d)";
    }
    else
    {
      unint64_t v20 = "Invalid td_samplesperpixel value";
    }
    TIFFErrorExtR(a1, "TIFFVStripSize64", v20, a4, a5, a6, a7, a8, v38);
    return 0;
  }
  unint64_t v14 = _cg_TIFFScanlineSize64(a1, a2, a3, a4, a5, a6, a7, a8);

  return _TIFFMultiply64(a1, v8, v14, "TIFFVStripSize64", v15, v16, v17, v18);
}

unint64_t _cg_TIFFScanlineSize64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  if (*(_WORD *)(a1 + 170) != 1)
  {
    unint64_t v18 = *(unsigned int *)(a1 + 88);
    unint64_t v19 = *(unsigned __int16 *)(a1 + 116);
    goto LABEL_24;
  }
  if (*(_WORD *)(a1 + 122) != 6)
  {
    unsigned int v20 = *(_DWORD *)(a1 + 88);
LABEL_23:
    unint64_t v18 = _TIFFMultiply64(v8, v20, *(unsigned __int16 *)(v8 + 130), "TIFFScanlineSize64", a5, a6, a7, a8);
    unint64_t v19 = *(unsigned __int16 *)(v8 + 116);
    a1 = v8;
LABEL_24:
    unint64_t result = (_TIFFMultiply64(a1, v18, v19, "TIFFScanlineSize64", a5, a6, a7, a8) + 7) >> 3;
    if (result) {
      return result;
    }
    goto LABEL_25;
  }
  if (*(_WORD *)(a1 + 130) != 3 || (*(unsigned char *)(a1 + 17) & 0x40) != 0)
  {
    unsigned int v20 = *(_DWORD *)(a1 + 88);
    unsigned __int16 v31 = 0;
    _cg_TIFFGetFieldDefaulted(a1, 530, a3, a4, a5, a6, a7, a8, &v31);
    if (v31 >= 2u)
    {
      unsigned int v21 = 0;
      if (v20 < -v31) {
        unsigned int v21 = (v20 + v31 - 1) / v31;
      }
      unsigned int v20 = v21 * v31;
    }
    goto LABEL_23;
  }
  int v32 = 0;
  _cg_TIFFGetFieldDefaulted(a1, 530, a3, a4, a5, a6, a7, a8, &v32);
  if ((unsigned __int16)v32 > 4u
    || ((1 << v32) & 0x16) == 0
    || (HIWORD(v32) != 4 ? (BOOL v14 = HIWORD(v32) - 3 >= 0xFFFFFFFE) : (BOOL v14 = 1),
        v14 ? (char v15 = 0) : (char v15 = 1),
        !HIWORD(v32) || (v15 & 1) != 0))
  {
    uint64_t v23 = "Invalid YCbCr subsampling";
    goto LABEL_26;
  }
  unsigned int v16 = *(_DWORD *)(v8 + 88);
  if (v16 >= -(unsigned __int16)v32) {
    unint64_t v17 = 0;
  }
  else {
    unint64_t v17 = ((unsigned __int16)v32 + v16 - 1) / (unsigned __int16)v32;
  }
  unint64_t v24 = _TIFFMultiply64(v8, v17, HIWORD(v32) * (unsigned __int16)v32 + 2, "TIFFScanlineSize64", v10, v11, v12, v13);
  unint64_t v29 = _TIFFMultiply64(v8, v24, *(unsigned __int16 *)(v8 + 116), "TIFFScanlineSize64", v25, v26, v27, v28);
  unint64_t result = ((v29 + 7) >> 3) / HIWORD(v32);
  if (!result)
  {
LABEL_25:
    uint64_t v23 = "Computed scanline size is zero";
LABEL_26:
    TIFFErrorExtR(v8, "TIFFScanlineSize64", v23, v9, v10, v11, v12, v13, v30);
    return 0;
  }
  return result;
}

uint64_t TIFFVStripSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = TIFFVStripSize64(a1, a2, a3, a4, a5, a6, a7, a8);

  return _TIFFCastUInt64ToSSize(a1, v9, "TIFFVStripSize", v10, v11, v12, v13, v14);
}

unint64_t _cg_TIFFStripSize64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 132);
  unsigned int v9 = *(_DWORD *)(a1 + 92);
  if (v8 >= v9) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = v8;
  }
  return TIFFVStripSize64(a1, v10, a3, a4, a5, a6, a7, a8);
}

uint64_t _cg_TIFFStripSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = *(_DWORD *)(a1 + 132);
  unsigned int v10 = *(_DWORD *)(a1 + 92);
  if (v9 >= v10) {
    uint64_t v11 = v10;
  }
  else {
    uint64_t v11 = v9;
  }
  unint64_t v12 = TIFFVStripSize64(a1, v11, a3, a4, a5, a6, a7, a8);

  return _TIFFCastUInt64ToSSize(a1, v12, "TIFFStripSize", v13, v14, v15, v16, v17);
}

uint64_t _TIFFDefaultStripSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((int)a2 <= 0)
  {
    unint64_t v8 = _cg_TIFFScanlineSize64(a1, a2, a3, a4, a5, a6, a7, a8);
    if (v8 <= 1) {
      unint64_t v9 = 1;
    }
    else {
      unint64_t v9 = v8;
    }
    if (v9 <= 0x2000) {
      return 0x2000u / (unsigned __int16)v9;
    }
    else {
      return 1;
    }
  }
  return a2;
}

uint64_t _cg_TIFFScanlineSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = _cg_TIFFScanlineSize64(a1, a2, a3, a4, a5, a6, a7, a8);

  return _TIFFCastUInt64ToSSize(a1, v9, "TIFFScanlineSize", v10, v11, v12, v13, v14);
}

void ICOWritePlugin::ICOWritePlugin(ICOWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 1229147936);
  *long long v3 = &unk_1ED4E13D8;
}

void ICOWritePlugin::~ICOWritePlugin(ICOWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t ICOWritePlugin::writeOneImage(ICOWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t ICOWritePlugin::writeAll(IIOImageDestination **this)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  long long v50 = 0u;
  long long v51 = 0u;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long __base = 0u;
  long long v23 = 0u;
  __int16 v21 = 0;
  int __ptr = 0;
  Imageunsigned int Count = IIOWritePlugin::getImageCount(this);
  if (ImageCount >= 0xC) {
    uint64_t v3 = 12;
  }
  else {
    uint64_t v3 = ImageCount;
  }
  if (!v3) {
    goto LABEL_22;
  }
  unint64_t v4 = 0;
  size_t v5 = 0;
  do
  {
    PixelDataProviderAtIndex = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v4);
    uint64_t Ref = IIOImageSource::imageReadRef(PixelDataProviderAtIndex);
    unint64_t v8 = (IIOImageSource **)&__base + 5 * v5;
    *unint64_t v8 = PixelDataProviderAtIndex;
    v8[1] = (IIOImageSource *)Ref;
    v8[2] = (IIOImageSource *)IIOWritePlugin::getPropertiesAtIndex(this, v4);
    uint64_t v9 = IIOImageSource::count(PixelDataProviderAtIndex);
    if (v9 == IIO_Reader::testHeaderSize(PixelDataProviderAtIndex))
    {
      if ((unint64_t)(v9 - 16) <= 0x38 && ((1 << (v9 - 16)) & 0x101000100010101) != 0
        || v9 == 256
        || v9 == 128)
      {
        *((_DWORD *)&v23 + 10 * v5++ + 2) = v9;
      }
      else
      {
        LogError("writeAll", 97, "*** unsupported ICO image size (%d x %d) - expected: 16, 32, 48, 128, or 256\n");
      }
    }
    else
    {
      LogError("writeAll", 101, "*** cannot create non-square ICO image (%d x %d)\n");
    }
    ++v4;
  }
  while (v3 != v4);
  if (v5
    && (qsort_b(&__base, v5, 0x28uLL, &__block_literal_global_12),
        int __ptr = 0x10000,
        __int16 v21 = v5,
        IIOImageWriteSession::putBytes(this[2], &__ptr, 6uLL) == 6))
  {
    uint64_t v10 = malloc_type_calloc(0x10uLL, v5, 0xB31454C3uLL);
    uint64_t v11 = v10;
    if (v10)
    {
      uint64_t v12 = 0;
      uint64_t v13 = v10 + 1;
      uint64_t v14 = (char *)&v23 + 8;
      do
      {
        char v15 = *v14;
        v14 += 40;
        *((unsigned char *)v13 - 4) = v15;
        *((unsigned char *)v13 - 3) = v15;
        *((_WORD *)v13 - 1) = 0;
        v13[1] = 0;
        v13[2] = 0;
        *uint64_t v13 = 2097153;
        v13 += 4;
        ++v12;
      }
      while (v5 != v12);
      *(void *)&long long v24 = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      operator new();
    }
  }
  else
  {
LABEL_22:
    uint64_t v11 = 0;
  }
  for (uint64_t i = 32; i != 512; i += 40)
  {
    uint64_t v17 = *(const void **)((char *)&__base + i);
    if (v17)
    {
      unint64_t v18 = v11;
      CFRelease(v17);
      uint64_t v11 = v18;
    }
  }
  if (v11) {
    free(v11);
  }
  return 4294967246;
}

void sub_1887377E0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C408329B462);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14ICOWritePlugin8writeAllEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(_DWORD *)(a2 + 24);
  unsigned int v4 = *(_DWORD *)(a3 + 24);
  BOOL v5 = v3 >= v4;
  if (v3 <= v4) {
    unsigned int v6 = 0;
  }
  else {
    unsigned int v6 = -1;
  }
  if (v5) {
    return v6;
  }
  else {
    return 1;
  }
}

uint64_t ICOWritePlugin::writeOne(ICOWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967292;
}

void IIO_Writer_HEIF::~IIO_Writer_HEIF(IIO_Writer_HEIF *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Writer_HEIF::createWritePlugin(IIO_Writer_HEIF *this, void *a2, IIOImageDestination *a3)
{
  CFStringRef v3 = (const __CFString *)IIOImageDestination::utType(a3);
  if (CFStringCompare(v3, @"public.jpeg", 0)
    && CFStringCompare(v3, @"public.avci", 0)
    && CFStringCompare(v3, @"public.heic", 0))
  {
    if (CFStringCompare(v3, @"public.heics", 0)) {
      CFStringCompare(v3, @"public.heif", 0);
    }
  }
  operator new();
}

void sub_18873798C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4048BCCD8ELL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Writer_HEIF::write(IIO_Writer_HEIF *this, void *a2, void *a3)
{
  uint64_t v3 = (*(uint64_t (**)(IIO_Writer_HEIF *, void *, void *))(*(void *)this + 8))(this, a2, a3);
  uint64_t v4 = v3;
  if (!v3) {
    return 4294967246;
  }
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
  (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  return v5;
}

uint64_t IIO_Writer_HEIF::canWriteDepth(IIO_Writer_HEIF *this)
{
  return 1;
}

void IIOReadPlugin::IIOReadPlugin(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_1ED4DFDB8;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(void *)(a1 + 424) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 392) = 0u;
  *(_OWORD *)(a1 + 408) = 0u;
  if (IIO_XPCServer())
  {
    *(unsigned char *)(a1 + 40) = 0;
    *(_OWORD *)(a1 + 24) = 0u;
    *(_OWORD *)(a1 + 8) = 0u;
    if (a2)
    {
      if (*(void *)(a2 + 24))
      {
        *(unsigned char *)(a1 + 40) = 1;
        operator new();
      }
    }
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  abort();
}

void sub_188737D4C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C40DD5C407ELL);
  _Unwind_Resume(a1);
}

uint64_t IIOReadPlugin::initialize(IIOReadPlugin *this, IIODictionary *a2)
{
  int v2 = *((_DWORD *)this + 51);
  unsigned int v3 = v2 >> 24;
  uint64_t v4 = MEMORY[0x1E4F14390];
  if (v2 < 0) {
    int v5 = __maskrune(v2 >> 24, 0x40000uLL);
  }
  else {
    int v5 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v3 + 60) & 0x40000;
  }
  unsigned int v6 = v2 << 8 >> 24;
  if (v2 << 8 < 0) {
    int v7 = __maskrune(v2 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v7 = *(_DWORD *)(v4 + 4 * v6 + 60) & 0x40000;
  }
  unsigned int v8 = (__int16)v2 >> 8;
  if (v2 << 16 < 0) {
    int v9 = __maskrune((__int16)v2 >> 8, 0x40000uLL);
  }
  else {
    int v9 = *(_DWORD *)(v4 + 4 * v8 + 60) & 0x40000;
  }
  if ((v2 << 24) <= 0x7F000000) {
    int v10 = *(_DWORD *)(v4 + 4 * (char)v2 + 60) & 0x40000;
  }
  else {
    int v10 = __maskrune((char)v2, 0x40000uLL);
  }
  if (v9) {
    uint64_t v11 = v8;
  }
  else {
    uint64_t v11 = 46;
  }
  if (v7) {
    uint64_t v12 = v6;
  }
  else {
    uint64_t v12 = 46;
  }
  if (v5) {
    uint64_t v13 = v3;
  }
  else {
    uint64_t v13 = 46;
  }
  if (v10) {
    uint64_t v14 = (char)v2;
  }
  else {
    uint64_t v14 = 46;
  }
  _cg_jpeg_mem_term("initialize", 544, "*** [%c%c%c%c] plugin did not implement 'initialize' ***\n", v13, v12, v11, v14);
  return 4294967240;
}

uint64_t IIOReadPlugin::copyAuxiliaryDataInfo(IIOReadPlugin *this, unsigned int a2, const __CFString *a3, IIODictionary *a4)
{
  return 0;
}

CGFloat IIOReadPlugin::optInForBandedDecoding(IIOReadPlugin *this, CGRect a2)
{
  if (*((unsigned char *)this + 408) != 1 && (*((_DWORD *)this + 59) * *((_DWORD *)this + 58)) >> 24)
  {
    *((_DWORD *)this + 92) = a2.size.width;
    unsigned int v2 = *((_DWORD *)this + 75);
    if (a2.size.height * (double)v2 >= 16777216.0)
    {
      BOOL v5 = v2 >= 0x1000001;
      unint64_t height = (0x1000000 / v2 + 7) & 0x3FFFFF8;
      double v6 = fmin(a2.size.height, 32.0);
      if (v5) {
        unint64_t height = (unint64_t)v6;
      }
      if (!height) {
        goto LABEL_12;
      }
      unint64_t v4 = *((void *)this + 45);
      if (v4 < 2)
      {
        unint64_t v8 = (unint64_t)(a2.size.height / (double)height);
        if (a2.size.height > (double)(height * v8))
        {
          unint64_t v9 = v8 + 1;
          CGFloat v10 = a2.size.height / (double)v9;
          unint64_t height = (unint64_t)v10 - 1;
          unint64_t v11 = (unint64_t)v10 * v9;
          do
          {
            CGFloat v12 = (double)v11;
            LODWORD(height) = height + 1;
            v11 += v9;
          }
          while (a2.size.height > v12);
        }
        goto LABEL_12;
      }
    }
    else
    {
      unint64_t height = (unint64_t)a2.size.height;
      unint64_t v4 = *((void *)this + 45);
      if (v4 < 2) {
        goto LABEL_12;
      }
    }
    unint64_t height = (v4 + height - 1) / v4 * v4;
LABEL_12:
    *((_DWORD *)this + 93) = height;
    *((_DWORD *)this + 74) = height;
    unsigned int v7 = (a2.origin.y / (double)height);
    a2.origin.x = (a2.origin.y
                 + a2.size.height
                 - (double)(height * v7)
                 + (double)(height - 1))
                / (double)height;
    *((_DWORD *)this + 26) = a2.origin.x;
    *((_DWORD *)this + 28) = v7;
    *((_DWORD *)this + 29) = a2.origin.x + v7;
  }
  return a2.origin.x;
}

void IIOReadPlugin::updateTempColorSpace(IIOReadPlugin *this)
{
  memset(v5, 0, sizeof(v5));
  IIODictionary::IIODictionary((IIODictionary *)v5, *((__CFDictionary **)this + 19));
  if (IIODictionary::containsKey((IIODictionary *)v5, @"TEMP_COLORSPACE"))
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v5, @"TEMP_COLORSPACE");
    CGColorSpaceRef v3 = CGColorSpaceCreateWithPropertyList(ObjectForKey);
    if (v3)
    {
      CGColorSpaceRelease(*((CGColorSpaceRef *)this + 20));
      *((void *)this + 20) = v3;
      if (CGColorSpaceContainsFlexGTCInfo())
      {
        *(_WORD *)((char *)this + 351) = 1;
        unint64_t v4 = (const void *)*((void *)this + 21);
        if (v4) {
          CFRelease(v4);
        }
        *((void *)this + 21) = CGColorSpaceCopyFlexGTCInfo();
      }
    }
  }
  IIODictionary::~IIODictionary((IIODictionary *)v5);
}

void sub_1887380FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOReadPlugin::getColorSpace(IIOReadPlugin *this)
{
  return *((void *)this + 20);
}

uint64_t IIOReadPlugin::getColorSpaceModel(IIOReadPlugin *this)
{
  return *((unsigned int *)this + 80);
}

uint64_t ___ZN13IIOReadPlugin17readOnlyRequestedEv_block_invoke()
{
  return _cg_jpeg_mem_term("readOnlyRequested_block_invoke", 717, "*** dDebugBlockSet was set - ignoring 'kCGImageBlockMarkAsReadOnlyRequest'\n");
}

uint64_t IIOReadPlugin::determinePixelType(IIOReadPlugin *this, CGColorSpaceModel a2, unsigned int a3)
{
  unsigned __int8 v3 = -1;
  switch(a2)
  {
    case kCGColorSpaceModelMonochrome:
      BOOL v4 = a3 >= 7;
      char v5 = 8 * a3;
      unint64_t v6 = 0x7080708070806;
      goto LABEL_7;
    case kCGColorSpaceModelRGB:
      BOOL v4 = a3 >= 7;
      char v5 = 8 * a3;
      unint64_t v6 = 0x4020402040200;
      goto LABEL_7;
    case kCGColorSpaceModelCMYK:
      BOOL v4 = a3 >= 7;
      char v5 = 8 * a3;
      unint64_t v6 = 0xA0B0A0B0A0B09;
      goto LABEL_7;
    case kCGColorSpaceModelLab:
      BOOL v4 = a3 >= 7;
      char v5 = 8 * a3;
      unint64_t v6 = 0xF100F100F100ELL;
      goto LABEL_7;
    case kCGColorSpaceModelIndexed:
      BOOL v4 = a3 >= 7;
      char v5 = 8 * a3;
      unint64_t v6 = 0xD0D0D0D0D0D0CLL;
LABEL_7:
      unint64_t v7 = v6 >> v5;
      if (v4) {
        unsigned __int8 v3 = -1;
      }
      else {
        unsigned __int8 v3 = v7;
      }
      break;
    default:
      return v3;
  }
  return v3;
}

uint64_t IIOReadPlugin::createPixelConverter(IIOReadPlugin *this)
{
  v3[0] = (*(uint64_t (**)(IIOReadPlugin *))(*(void *)this + 56))(this);
  v3[1] = v1;
  return ImageIOPixelConverter::CreatePixelConverter(v3);
}

unint64_t IIOReadPlugin::getPixelConverterCreationParams(IIOReadPlugin *this)
{
  uint64_t v2 = *((unsigned int *)this + 80);
  unsigned int v3 = *((unsigned __int8 *)this + 246);
  if (*((unsigned char *)this + 246)) {
    unint64_t v4 = (unint64_t)*((unsigned __int8 *)this + 240) << 48;
  }
  else {
    unint64_t v4 = 0;
  }
  char v5 = (IIOReadPlugin *)IIOReadPlugin::determinePixelType(this, (CGColorSpaceModel)*((_DWORD *)this + 80), *((unsigned __int8 *)this + 310));
  unsigned __int8 v6 = v5;
  if (v5 == 2)
  {
    if (*((unsigned char *)this + 404) == 1) {
      unsigned __int8 v6 = 3;
    }
    else {
      unsigned __int8 v6 = 2;
    }
  }
  return v4 | ((unint64_t)v6 << 40) | (IIOReadPlugin::determinePixelType(v5, (CGColorSpaceModel)v2, v3) << 32) | v2;
}

uint64_t IIOReadPlugin::createFlexGTCInfo(IIOReadPlugin *this, IIODictionary *a2, const __CFDictionary **a3)
{
  return 4294967292;
}

const char *IIOReadPlugin::debugGeometry(uint64_t a1, long long *a2, IIODictionary *this)
{
  if (a2)
  {
    if (this
      && IIODictionary::containsKey(this, @"kImageIOInfoHeader_createImageProviderWithBitmapInfo"))
    {
      unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(this, @"kImageIOInfoHeader_createImageProviderWithBitmapInfo");
    }
    else
    {
      unsigned int Uint32ForKey = *((_DWORD *)a2 + 16) | *((_DWORD *)a2 + 15);
    }
  }
  else
  {
    unsigned int Uint32ForKey = 0;
  }
  ImageIOLog("                             x     y     w     h       rb   bpp   bpc    #c     a        bmi   bitmapInfo\n");
  ImageIOLog("           -----------   ----- ----- ----- -----   ------   ---   ---   ---   ---   --------   ---------------------\n");
  if (a2)
  {
    int v7 = *((_DWORD *)a2 + 10);
    unsigned int v8 = v7 >> 24;
    uint64_t v9 = MEMORY[0x1E4F14390];
    if (v7 < 0)
    {
      int v10 = __maskrune(v8, 0x40000uLL);
      int v7 = *((_DWORD *)a2 + 10);
    }
    else
    {
      int v10 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v8 + 60) & 0x40000;
    }
    if (v10) {
      uint64_t v11 = (v7 >> 24);
    }
    else {
      uint64_t v11 = 46;
    }
    unsigned int v12 = v7 << 8 >> 24;
    if (v7 << 8 < 0)
    {
      int v13 = __maskrune(v12, 0x40000uLL);
      int v7 = *((_DWORD *)a2 + 10);
    }
    else
    {
      int v13 = *(_DWORD *)(v9 + 4 * v12 + 60) & 0x40000;
    }
    if (v13) {
      uint64_t v14 = (v7 << 8 >> 24);
    }
    else {
      uint64_t v14 = 46;
    }
    unsigned int v15 = (__int16)v7 >> 8;
    if (v7 << 16 < 0)
    {
      int v16 = __maskrune(v15, 0x40000uLL);
      int v7 = *((_DWORD *)a2 + 10);
    }
    else
    {
      int v16 = *(_DWORD *)(v9 + 4 * v15 + 60) & 0x40000;
    }
    if (v16) {
      uint64_t v17 = ((__int16)v7 >> 8);
    }
    else {
      uint64_t v17 = 46;
    }
    if ((v7 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v9 + 4 * (char)v7 + 60) & 0x40000) != 0) {
        goto LABEL_28;
      }
    }
    else if (__maskrune((char)v7, 0x40000uLL))
    {
LABEL_28:
      uint64_t v18 = *((char *)a2 + 40);
LABEL_31:
      long long v46 = *a2;
      uint64_t v20 = *((void *)a2 + 3);
      uint64_t v19 = *((void *)a2 + 4);
      uint64_t v21 = *((void *)a2 + 2);
      int v22 = *((_DWORD *)a2 + 15);
      long long v23 = IIO_BitmapInfoStringSmall(Uint32ForKey);
      ImageIOLog("           iPlus '%c%c%c%c'              %5d %5d   %6d   %3d   %3d         %3d   %08X   %s\n", v11, v14, v17, v18, v46, DWORD2(v46), v19, v20, v21, v22, Uint32ForKey, v23);
      goto LABEL_32;
    }
    uint64_t v18 = 46;
    goto LABEL_31;
  }
LABEL_32:
  int v47 = *(unsigned __int16 *)(a1 + 242);
  int v24 = *(unsigned __int16 *)(a1 + 240);
  int v25 = *(unsigned __int16 *)(a1 + 244);
  int v26 = *(unsigned __int8 *)(a1 + 246);
  unsigned int v27 = (*(unsigned __int8 *)(a1 + 248) << 16) | (*(unsigned __int8 *)(a1 + 247) << 12) | ((*(unsigned char *)(a1 + 249) != 0) << 8) | v26;
  int v28 = *(_DWORD *)(a1 + 220);
  int v29 = *(_DWORD *)(a1 + 224);
  int v30 = *(_DWORD *)(a1 + 228);
  int v31 = *(_DWORD *)(a1 + 232);
  int v32 = *(_DWORD *)(a1 + 236);
  long long v33 = IIO_BitmapInfoStringSmall(v27);
  ImageIOLog("             _inputGeo   %5d %5d %5d %5d   %6d   %3d   %3d   %3d   %3d   %08X   %s\n", v28, v29, v30, v31, v32, v47, v24, v25, v26, v27, v33);
  int v34 = *(unsigned __int16 *)(a1 + 274);
  int v35 = *(unsigned __int16 *)(a1 + 272);
  int v36 = *(unsigned __int16 *)(a1 + 276);
  int v37 = *(unsigned __int8 *)(a1 + 278);
  unsigned int v38 = (*(unsigned __int8 *)(a1 + 280) << 16) | (*(unsigned __int8 *)(a1 + 279) << 12) | ((*(unsigned char *)(a1 + 281) != 0) << 8) | v37;
  int v39 = *(_DWORD *)(a1 + 252);
  int v40 = *(_DWORD *)(a1 + 256);
  int v41 = *(_DWORD *)(a1 + 260);
  int v42 = *(_DWORD *)(a1 + 264);
  int v43 = *(_DWORD *)(a1 + 268);
  long long v44 = IIO_BitmapInfoStringSmall(v38);
  return ImageIOLog("           _decodedGeo   %5d %5d %5d %5d   %6d   %3d   %3d   %3d   %3d   %08X   %s\n", v39, v40, v41, v42, v43, v34, v35, v36, v37, v38, v44);
}

uint64_t IIOReadPlugin::canCreateChromaSubsampledIOSurface(IIOReadPlugin *this)
{
  return 0;
}

uint64_t IIOReadPlugin::getPixelFormat(IIOReadPlugin *this)
{
  int v2 = (*(uint64_t (**)(IIOReadPlugin *))(*(void *)this + 40))(this);
  int v3 = *((_DWORD *)this + 81);
  if (v3 == 1196573017)
  {
    uint64_t v5 = 1278226488;
    int v6 = *((unsigned __int16 *)this + 152);
    if (v6 == 8) {
      goto LABEL_37;
    }
    if (v6 == 32)
    {
      uint64_t v5 = 1278226534;
      goto LABEL_37;
    }
    if (v6 != 16)
    {
      _cg_jpeg_mem_term("getPixelFormat", 1503, " GRAY - bitdepth %d not handled\n");
      goto LABEL_36;
    }
    if (*((unsigned char *)this + 345)) {
      uint64_t v5 = 1278226536;
    }
    else {
      uint64_t v5 = 1278226742;
    }
  }
  else
  {
    if (v3 != 1380401696)
    {
      if (v3 < 0)
      {
        __maskrune(v3 >> 24, 0x40000uLL);
        int v3 = *((_DWORD *)this + 81);
      }
      if (v3 << 8 < 0)
      {
        __maskrune(v3 << 8 >> 24, 0x40000uLL);
        int v3 = *((_DWORD *)this + 81);
      }
      if (v3 << 16 < 0)
      {
        __maskrune((__int16)v3 >> 8, 0x40000uLL);
        int v3 = *((_DWORD *)this + 81);
      }
      if ((v3 << 24) > 0x7F000000) {
        __maskrune((char)v3, 0x40000uLL);
      }
      _cg_jpeg_mem_term("getPixelFormat", 1508, " colormodel '%c%c%c%c' not handled\n");
      goto LABEL_36;
    }
    unsigned int v4 = *((unsigned __int16 *)this + 152);
    if (v4 > 0xF)
    {
      uint64_t v5 = 1380410945;
      if (v4 != 16)
      {
        if (v4 == 32) {
          goto LABEL_37;
        }
LABEL_18:
        _cg_jpeg_mem_term("getPixelFormat", 1483, " RGB - bitdepth %d not handled\n");
LABEL_36:
        uint64_t v5 = 0;
        goto LABEL_37;
      }
      if (*((unsigned char *)this + 345)) {
        uint64_t v5 = 1380411457;
      }
      else {
        uint64_t v5 = 1815491698;
      }
    }
    else
    {
      if (v4 != 8)
      {
        if (v4 == 10)
        {
          if (v2)
          {
            uint64_t v5 = 2019963440;
            goto LABEL_37;
          }
          _cg_jpeg_mem_term("getPixelFormat", 1470, " RGB - bitdepth %d not handled\n");
          goto LABEL_36;
        }
        goto LABEL_18;
      }
      if (v2) {
        uint64_t v5 = 875704422;
      }
      else {
        uint64_t v5 = 1111970369;
      }
    }
  }
LABEL_37:
  int v7 = *((_DWORD *)this + 84);
  if (v5 != v7)
  {
    uint64_t v8 = MEMORY[0x1E4F14390];
    uint64_t v9 = MEMORY[0x1E4F14390] + 60;
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 60 + 4 * BYTE3(v5)) & 0x40000) != 0) {
      uint64_t v10 = BYTE3(v5);
    }
    else {
      uint64_t v10 = 46;
    }
    unsigned int v11 = WORD1(v5) & 0x77;
    if ((*(_DWORD *)(v9 + 4 * v11) & 0x40000) != 0) {
      uint64_t v12 = v11;
    }
    else {
      uint64_t v12 = 46;
    }
    unsigned int v13 = (v5 >> 8) & 0x7F;
    if ((*(_DWORD *)(v9 + 4 * v13) & 0x40000) != 0) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 46;
    }
    if ((*(_DWORD *)(v9 + 4 * (v5 & 0x7F)) & 0x40000) != 0) {
      uint64_t v15 = v5 & 0x7F;
    }
    else {
      uint64_t v15 = 46;
    }
    unsigned int v16 = v7 >> 24;
    if (v7 < 0)
    {
      int v17 = __maskrune(v16, 0x40000uLL);
      int v7 = *((_DWORD *)this + 84);
    }
    else
    {
      int v17 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v16 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = (v7 >> 24);
    }
    else {
      uint64_t v18 = 46;
    }
    unsigned int v19 = v7 << 8 >> 24;
    if (v7 << 8 < 0)
    {
      int v20 = __maskrune(v19, 0x40000uLL);
      int v7 = *((_DWORD *)this + 84);
    }
    else
    {
      int v20 = *(_DWORD *)(v8 + 4 * v19 + 60) & 0x40000;
    }
    if (v20) {
      uint64_t v21 = (v7 << 8 >> 24);
    }
    else {
      uint64_t v21 = 46;
    }
    unsigned int v22 = (__int16)v7 >> 8;
    if (v7 << 16 < 0)
    {
      int v23 = __maskrune(v22, 0x40000uLL);
      int v7 = *((_DWORD *)this + 84);
    }
    else
    {
      int v23 = *(_DWORD *)(v8 + 4 * v22 + 60) & 0x40000;
    }
    if (v23) {
      uint64_t v24 = ((__int16)v7 >> 8);
    }
    else {
      uint64_t v24 = 46;
    }
    if ((v7 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v8 + 4 * (char)v7 + 60) & 0x40000) != 0) {
        goto LABEL_70;
      }
    }
    else if (__maskrune((char)v7, 0x40000uLL))
    {
LABEL_70:
      uint64_t v25 = *((char *)this + 336);
LABEL_73:
      _cg_jpeg_mem_term("getPixelFormat", 1511, " pixelFormat: '%c%c%c%c'   _rpd.pixelFormat: '%c%c%c%c'\n", v10, v12, v14, v15, v18, v21, v24, v25);
      return v5;
    }
    uint64_t v25 = 46;
    goto LABEL_73;
  }
  return v5;
}

void IIOReadPlugin::printRequests(IIOReadPlugin *this, const __CFDictionary *a2)
{
  if (*((unsigned char *)this + 414)) {
    int v3 = "true";
  }
  else {
    int v3 = "false";
  }
  ImageIOLog("    reqAreValid: %s\n", v3);
  int v4 = *((_DWORD *)this + 100);
  unsigned int v5 = v4 >> 24;
  uint64_t v6 = MEMORY[0x1E4F14390];
  if (v4 < 0)
  {
    int v7 = __maskrune(v5, 0x40000uLL);
    int v4 = *((_DWORD *)this + 100);
  }
  else
  {
    int v7 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v5 + 60) & 0x40000;
  }
  if (v7) {
    uint64_t v8 = (v4 >> 24);
  }
  else {
    uint64_t v8 = 46;
  }
  unsigned int v9 = v4 << 8 >> 24;
  if (v4 << 8 < 0)
  {
    int v10 = __maskrune(v9, 0x40000uLL);
    int v4 = *((_DWORD *)this + 100);
  }
  else
  {
    int v10 = *(_DWORD *)(v6 + 4 * v9 + 60) & 0x40000;
  }
  if (v10) {
    uint64_t v11 = (v4 << 8 >> 24);
  }
  else {
    uint64_t v11 = 46;
  }
  unsigned int v12 = (__int16)v4 >> 8;
  if (v4 << 16 < 0)
  {
    int v13 = __maskrune(v12, 0x40000uLL);
    int v4 = *((_DWORD *)this + 100);
  }
  else
  {
    int v13 = *(_DWORD *)(v6 + 4 * v12 + 60) & 0x40000;
  }
  if (v13) {
    uint64_t v14 = ((__int16)v4 >> 8);
  }
  else {
    uint64_t v14 = 46;
  }
  if ((v4 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v6 + 4 * (char)v4 + 60) & 0x40000) != 0) {
      goto LABEL_24;
    }
  }
  else if (__maskrune((char)v4, 0x40000uLL))
  {
LABEL_24:
    uint64_t v15 = *((char *)this + 400);
    goto LABEL_27;
  }
  uint64_t v15 = 46;
LABEL_27:
  ImageIOLog("    format:      %c%c%c%c\n", v8, v11, v14, v15);
  if (*((unsigned char *)this + 412)) {
    unsigned int v16 = "true";
  }
  else {
    unsigned int v16 = "false";
  }
  ImageIOLog("    wantsFloat:  %s\n", v16);
  ImageIOLog("    requests:    BGRx8       RGBX8888    premult     readOnly    single      addrAlign   addrAlign   cache\n");
  memset(&v18, 0, sizeof(v18));
  std::string::basic_string[abi:ne180100]<0>(&v18, "                 ");
  std::string::append(&v18, off_1E53C6FF8[*((char *)this + 404) + 1]);
  std::string::append(&v18, off_1E53C6FF8[*((char *)this + 405) + 1]);
  std::string::append(&v18, off_1E53C6FF8[*((char *)this + 406) + 1]);
  std::string::append(&v18, off_1E53C6FF8[*((char *)this + 407) + 1]);
  std::string::append(&v18, off_1E53C6FF8[*((char *)this + 408) + 1]);
  std::string::append(&v18, off_1E53C6FF8[*((char *)this + 409) + 1]);
  std::string::append(&v18, off_1E53C6FF8[*((char *)this + 410) + 1]);
  std::string::append(&v18, off_1E53C6FF8[*((char *)this + 411) + 1]);
  if ((v18.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int v17 = &v18;
  }
  else {
    int v17 = (std::string *)v18.__r_.__value_.__r.__words[0];
  }
  ImageIOLog("%s\n", (const char *)v17);
  if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v18.__r_.__value_.__l.__data_);
  }
}

void sub_188738CC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IIOReadPlugin::setIPlus(IIOReadPlugin *this, IIOImagePlus *a2, IIOImageReadSession *a3)
{
  *((void *)this + 2) = a2;
  *((void *)this + 3) = a3;
  uint64_t result = IIO_Reader::testHeaderSize(a3);
  *((void *)this + 4) = result;
  return result;
}

uint64_t IIOReadPlugin::validateReadPluginData(IIOReadPlugin *this)
{
  if (!IIOGeometry::isValid((IIOReadPlugin *)((char *)this + 220))) {
    return 4294967246;
  }
  uint64_t v2 = 4294967246;
  if (IIOGeometry::isValid((IIOReadPlugin *)((char *)this + 252)))
  {
    if (IIOGeometry::isValid((IIOReadPlugin *)((char *)this + 284))) {
      return 0;
    }
    else {
      return 4294967246;
    }
  }
  return v2;
}

uint64_t IIOReadPlugin::loadDataFromXPCObject(IIOReadPlugin *this, xpc_object_t xdict)
{
  size_t length = 0;
  data = xpc_dictionary_get_data(xdict, "iio_xpc_plugin_data", &length);
  if (length != 248) {
    return 4294967246;
  }
  long long v4 = *data;
  long long v5 = data[1];
  long long v6 = data[2];
  *(_OWORD *)((char *)this + 232) = data[3];
  *(_OWORD *)((char *)this + 216) = v6;
  *(_OWORD *)((char *)this + 200) = v5;
  *(_OWORD *)((char *)this + 184) = v4;
  long long v7 = data[4];
  long long v8 = data[5];
  long long v9 = data[7];
  *(_OWORD *)((char *)this + 280) = data[6];
  *(_OWORD *)((char *)this + 296) = v9;
  *(_OWORD *)((char *)this + 264) = v8;
  *(_OWORD *)((char *)this + 248) = v7;
  long long v10 = data[8];
  long long v11 = data[9];
  long long v12 = data[11];
  *(_OWORD *)((char *)this + 344) = data[10];
  *(_OWORD *)((char *)this + 360) = v12;
  *(_OWORD *)((char *)this + 312) = v10;
  *(_OWORD *)((char *)this + 328) = v11;
  long long v13 = data[12];
  long long v14 = data[13];
  long long v15 = data[14];
  *((void *)this + 53) = *((void *)data + 30);
  *(_OWORD *)((char *)this + 392) = v14;
  *(_OWORD *)((char *)this + 408) = v15;
  *(_OWORD *)((char *)this + 376) = v13;
  uint64_t PluginData = IIOReadPlugin::validateReadPluginData(this);
  if (IIO_XPCServer()) {
    *((_DWORD *)this + 108) = xpc_dictionary_copy_mach_send();
  }
  return PluginData;
}

uint64_t IIOReadPlugin::saveDataToXPCObject(IIOReadPlugin *this, void *a2)
{
  if ((IIO_XPCServer() & 1) == 0)
  {
    if (IIOReadPlugin::saveDataToXPCObject(void *)::onceToken != -1) {
      dispatch_once(&IIOReadPlugin::saveDataToXPCObject(void *)::onceToken, &__block_literal_global_87);
    }
    xpc_dictionary_set_mach_send();
  }
  return 0;
}

const char *___ZN13IIOReadPlugin19saveDataToXPCObjectEPv_block_invoke()
{
  uint64_t result = (const char *)task_create_identity_token(*MEMORY[0x1E4F14960], (task_id_token_t *)&IIOReadPlugin::saveDataToXPCObject(void *)::tok);
  if (result)
  {
    uint64_t v1 = mach_error_string((mach_error_t)result);
    return LogError("saveDataToXPCObject_block_invoke", 1902, "*** ERROR: task_create_identity_token: %s", v1);
  }
  return result;
}

uint64_t IIOReadPlugin::addImageBlocksToXPCObject(IIOReadPlugin *this, void *a2)
{
  int v3 = (const void *)*((void *)this + 12);
  if (*((_DWORD *)this + 26) && v3)
  {
    xpc_object_t empty = xpc_array_create_empty();
    if (*((_DWORD *)this + 26))
    {
      unint64_t v5 = 0;
      do
      {
        long long v6 = (void *)*((void *)this + 12);
        if (v6[v5])
        {
          uint64_t BytesPerRow = CGImageBlockGetBytesPerRow();
          CGImageBlockGetRect();
          double v9 = v8;
          double v11 = v10;
          double v13 = v12;
          double v15 = v14;
          Data = (void *)CGImageBlockGetData();
          size_t v17 = (unint64_t)(v15 * (double)BytesPerRow);
          xpc_object_t v18 = xpc_dictionary_create_empty();
          xpc_object_t v19 = xpc_shmem_create(Data, v17);
          if (v19)
          {
            int v20 = v19;
            xpc_dictionary_set_value(v18, "iio_xpc_cb_decode_image_buffer", v19);
            xpc_dictionary_set_uint64(v18, "iio_xpc_cb_decode_image_buffer_size", v17);
            xpc_release(v20);
          }
          iio_xpc_dictionary_addCGRect(v18, "iio_xpc_cb_block_cgrect", v9, v11, v13, v15);
          xpc_dictionary_set_uint64(v18, "iio_xpc_cb_block_rowbytes", BytesPerRow);
          CGImageBlockRelease();
          xpc_array_append_value(empty, v18);
          xpc_release(v18);
        }
        else
        {
          LogError("addImageBlocksToXPCObject", 1929, "*** ERROR: _blockArray: %p    _blockArray[%d]: %p\n", v6, v5, 0);
        }
        ++v5;
      }
      while (v5 < *((unsigned int *)this + 26));
    }
    xpc_object_t v21 = iio_xpc_add_callback_dict(a2);
    xpc_dictionary_set_value(v21, "iio_xpc_cb_blockset", empty);
    xpc_release(empty);
    uint64_t v22 = 0;
  }
  else
  {
    LogError("addImageBlocksToXPCObject", 1918, "*** ERROR: _blockCount is 0   (_blockArray: %p)\n", v3);
    uint64_t v22 = 4294967243;
  }
  int v23 = (void *)*((void *)this + 12);
  if (v23) {
    free(v23);
  }
  *((void *)this + 12) = 0;
  *((_DWORD *)this + 26) = 0;
  return v22;
}

xpc_object_t IIOReadPlugin::createImageBlockSetFromXPCObject(uint64_t a1, void *a2, const void *a3, uint64_t a4)
{
  xpc_object_t result = iio_xpc_get_callback_dict(a2);
  if (!result) {
    return result;
  }
  xpc_object_t value = xpc_dictionary_get_value(result, "iio_xpc_cb_blockset");
  size_t count = xpc_array_get_count(value);
  *(_DWORD *)(a1 + 104) = count;
  if (!count)
  {
    ImageIOLog("*** ERROR: _blockCount == 0 -- decode failed?\n");
    return 0;
  }
  if (IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, count)) {
    return 0;
  }
  uint64_t v30 = a4;
  int v31 = a3;
  if (*(_DWORD *)(a1 + 104))
  {
    size_t v10 = 0;
    double v11 = 0.0;
    double v12 = 0.0;
    double v13 = 0.0;
    double v14 = 0.0;
    while (1)
    {
      xpc_object_t v15 = xpc_array_get_value(value, v10);
      double v16 = iio_xpc_dictionary_get_CGRect(v15, "iio_xpc_cb_block_cgrect");
      CGFloat v20 = v16;
      CGFloat v21 = v17;
      double v22 = v18;
      double v23 = v19;
      if (v10)
      {
        v33.origin.x = v11;
        v33.origin.y = v12;
        v33.size.vImagePixelCount width = v13;
        v33.size.unint64_t height = v14;
        v35.origin.x = v20;
        v35.origin.y = v21;
        v35.size.vImagePixelCount width = v22;
        v35.size.unint64_t height = v23;
        *(CGRect *)&double v16 = CGRectUnion(v33, v35);
      }
      double v14 = v19;
      double v11 = v16;
      double v12 = v17;
      double v13 = v18;
      uint64_t uint64 = xpc_dictionary_get_uint64(v15, "iio_xpc_cb_block_rowbytes");
      xpc_object_t v25 = xpc_dictionary_get_value(v15, "iio_xpc_cb_decode_image_buffer");
      uint64_t v26 = xpc_dictionary_get_uint64(v15, "iio_xpc_cb_decode_image_buffer_size");
      if (v22 * v23 > (double)v26 || v23 * (double)uint64 > (double)v26) {
        break;
      }
      if (v25)
      {
        uint64_t v27 = v26;
        if (v26)
        {
          region = 0;
          size_t v28 = xpc_shmem_map(v25, &region);
          if (region)
          {
            if (v28 >= v27)
            {
              _ImageIO_AccreditMemory((uint64_t)region, v28);
              v34.origin.x = v20;
              v34.origin.y = v21;
              v34.size.vImagePixelCount width = v22;
              v34.size.unint64_t height = v23;
              *(void *)(*(void *)(a1 + 96) + 8 * v10) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, region, v28, v34, uint64, 1);
            }
          }
        }
      }
      ++v10;
      unint64_t v29 = *(unsigned int *)(a1 + 104);
      if (v10 >= v29) {
        return (xpc_object_t)IIOReadPlugin::imageBlockSetCreate(a1, v30, v29, v13, v14, v11, v12, v13, v14, *(void *)(a1 + 96), v31);
      }
    }
    return 0;
  }
  unint64_t v29 = 0;
  double v14 = 0.0;
  double v13 = 0.0;
  double v12 = 0.0;
  double v11 = 0.0;
  return (xpc_object_t)IIOReadPlugin::imageBlockSetCreate(a1, v30, v29, v13, v14, v11, v12, v13, v14, *(void *)(a1 + 96), v31);
}

uint64_t IIOReadPlugin::debugBlockSetAlpha(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result = CGImageProviderGetAlphaInfo();
  int v56 = result;
  if (*(_DWORD *)(a1 + 320) != 1) {
    return result;
  }
  if ((result - 1) < 2)
  {
    if (!a3) {
      return result;
    }
    goto LABEL_9;
  }
  if (*(unsigned char *)(a1 + 404) == 1 && a3 != 0)
  {
LABEL_9:
    int v6 = 0;
    uint64_t v7 = 0;
    char v8 = 1;
    do
    {
      CGImageBlockGetRect();
      double v10 = v9;
      double v12 = v11;
      double v14 = v13;
      double v16 = v15;
      uint64_t Data = CGImageBlockGetData();
      uint64_t result = CGImageBlockGetBytesPerRow();
      unsigned int v18 = v12;
      double v19 = v12 + v16;
      int v51 = v6;
      if (v19 > (double)v18)
      {
        int v54 = result;
        uint64_t v55 = Data;
        unsigned int v20 = v10;
        double v21 = v10 + v14;
        unsigned int v52 = v20;
        unsigned int v53 = v18;
        double v22 = (double)v20;
        unsigned int v23 = v18;
        do
        {
          if (v21 > v22)
          {
            unsigned int v24 = v52;
            xpc_object_t v25 = (unsigned int *)(Data + (v23 - v53) * v54);
            do
            {
              unsigned int v27 = *v25++;
              unsigned __int8 v26 = v27;
              unsigned int v28 = v27 >> 8;
              unsigned int v29 = HIWORD(v27);
              unsigned int v30 = HIBYTE(v27);
              unsigned int v31 = v27;
              char v32 = BYTE1(v27);
              char v33 = BYTE2(v27);
              if (v56 == 2) {
                unsigned int v34 = v31;
              }
              else {
                unsigned int v34 = v30;
              }
              if (v56 == 2)
              {
                LOBYTE(v29) = v32;
                LOBYTE(v28) = v33;
                unsigned __int8 v26 = v30;
              }
              unsigned int v35 = v29;
              unsigned int v36 = v28;
              unsigned int v37 = v26;
              if (v29 > v34 || v28 > v34 || v26 > v34)
              {
                if (v8) {
                  puts("*** BAD premultiplied alpha data R, G, and B values should be smaller than Alpha");
                }
                uint64_t v40 = 60;
                if (v37 <= v34) {
                  uint64_t v41 = 32;
                }
                else {
                  uint64_t v41 = 60;
                }
                uint64_t v49 = v41;
                if (v37 <= v34) {
                  uint64_t v42 = 32;
                }
                else {
                  uint64_t v42 = 62;
                }
                uint64_t v48 = v42;
                if (v36 <= v34) {
                  uint64_t v43 = 32;
                }
                else {
                  uint64_t v43 = 60;
                }
                uint64_t v47 = v43;
                if (v36 <= v34) {
                  uint64_t v44 = 32;
                }
                else {
                  uint64_t v44 = 62;
                }
                if (v35 <= v34) {
                  uint64_t v40 = 32;
                }
                uint64_t v46 = v44;
                if (v35 <= v34) {
                  uint64_t v45 = 32;
                }
                else {
                  uint64_t v45 = 62;
                }
                uint64_t result = printf("[%3d:%3d]  %c%02X%c  %c%02X%c   %c%02X%c   %02X\n", v24, v23, v45, v35, v40, v46, v36, v47, v48, v37, v49, v34);
                if (v7 > 98)
                {
                  return puts("*** BAD premultiplied alpha (stopped logging after 100 bad pixels)");
                }
                char v8 = 0;
                ++v7;
              }
              ++v24;
            }
            while (v21 > (double)v24);
          }
          ++v23;
          uint64_t Data = v55;
        }
        while (v19 > (double)v23);
      }
      int v6 = v51 + 1;
    }
    while ((v51 + 1) < a3);
  }
  return result;
}

uint64_t IIOReadPlugin::copyImageBlockSet(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 204);
  unsigned int v2 = v1 >> 24;
  uint64_t v3 = MEMORY[0x1E4F14390];
  if (v1 < 0) {
    int v4 = __maskrune(v1 >> 24, 0x40000uLL);
  }
  else {
    int v4 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v2 + 60) & 0x40000;
  }
  unsigned int v5 = v1 << 8 >> 24;
  if (v1 << 8 < 0) {
    int v6 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v6 = *(_DWORD *)(v3 + 4 * v5 + 60) & 0x40000;
  }
  unsigned int v7 = (__int16)v1 >> 8;
  if (v1 << 16 < 0) {
    int v8 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
  }
  else {
    int v8 = *(_DWORD *)(v3 + 4 * v7 + 60) & 0x40000;
  }
  if ((v1 << 24) <= 0x7F000000) {
    int v9 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
  }
  else {
    int v9 = __maskrune((char)v1, 0x40000uLL);
  }
  if (v8) {
    uint64_t v10 = v7;
  }
  else {
    uint64_t v10 = 46;
  }
  if (v6) {
    uint64_t v11 = v5;
  }
  else {
    uint64_t v11 = 46;
  }
  if (v4) {
    uint64_t v12 = v2;
  }
  else {
    uint64_t v12 = 46;
  }
  if (v9) {
    uint64_t v13 = (char)v1;
  }
  else {
    uint64_t v13 = 46;
  }
  _cg_jpeg_mem_term("copyImageBlockSet", 2125, "*** [%c%c%c%c] plugin did not implement 'copyImageBlockSet' ***\n", v12, v11, v10, v13);
  return 0;
}

uint64_t IIOReadPlugin::decodeImageImp(uint64_t a1)
{
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    int v1 = *(_DWORD *)(a1 + 204);
    unsigned int v2 = v1 >> 24;
    uint64_t v3 = MEMORY[0x1E4F14390];
    if (v1 < 0) {
      int v4 = __maskrune(v1 >> 24, 0x40000uLL);
    }
    else {
      int v4 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v2 + 60) & 0x40000;
    }
    if (v4) {
      uint64_t v5 = v2;
    }
    else {
      uint64_t v5 = 46;
    }
    unsigned int v6 = v1 << 8 >> 24;
    if (v1 << 8 < 0) {
      int v7 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v7 = *(_DWORD *)(v3 + 4 * v6 + 60) & 0x40000;
    }
    if (v7) {
      uint64_t v8 = v6;
    }
    else {
      uint64_t v8 = 46;
    }
    unsigned int v9 = (__int16)v1 >> 8;
    if (v1 << 16 < 0) {
      int v10 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
    }
    else {
      int v10 = *(_DWORD *)(v3 + 4 * v9 + 60) & 0x40000;
    }
    if (v10) {
      uint64_t v11 = v9;
    }
    else {
      uint64_t v11 = 46;
    }
    if ((v1 << 24) <= 0x7F000000) {
      int v12 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
    }
    else {
      int v12 = __maskrune((char)v1, 0x40000uLL);
    }
    if (v12) {
      uint64_t v13 = (char)v1;
    }
    else {
      uint64_t v13 = 46;
    }
    ImageIOLog("*** [%c%c%c%c] plugin does not implement 'decodeImageImp' ***\n", v5, v8, v11, v13);
  }
  return 4294967240;
}

uint64_t IIOReadPlugin::convertBlockSetToSDR(uint64_t a1, uint64_t a2)
{
  IIO_LoadHEIFSymbols();
  if (CGImageBlockSetGetCount() == 1)
  {
    Componentint Type = CGImageBlockSetGetComponentType();
    int ImageBlock = CGImageBlockSetGetImageBlock();
    CGImageBlockGetRect();
    unint64_t v7 = (unint64_t)v6;
    unint64_t v9 = (unint64_t)v8;
    switch(ComponentType)
    {
      case 2:
        int v10 = 1815491698;
        break;
      case 4:
        int v10 = 1380410945;
        break;
      case 5:
        int v10 = 1380411457;
        break;
      default:
        LogError("convertBlockSetToSDR", 2522, "*** ERROR: unhandled componentType '%d'\n", ComponentType);
        int v10 = 0;
        break;
    }
    uint64_t v18 = 0;
    double v19 = 0;
    uint64_t v20 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v18);
    IOSurfaceWithFormat = IIO_CreateIOSurfaceWithFormat(v7, v9, 0, v10, 0, 0);
    int v12 = IIO_CreateIOSurfaceWithFormat(v7, v9, 0, v10, 0, 0);
    IIO_IOSurfaceSetAlpha(IOSurfaceWithFormat, (CGImageAlphaInfo)*(unsigned __int8 *)(a1 + 310));
    uint64_t v13 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DB90]);
    CFPropertyListRef v14 = CGColorSpaceCopyPropertyList(*(CGColorSpaceRef *)(a1 + 160));
    double v15 = (CFStringRef *)MEMORY[0x1E4F2F068];
    if (v14)
    {
      IOSurfaceSetValue(IOSurfaceWithFormat, (CFStringRef)*MEMORY[0x1E4F2F068], v14);
      CFRelease(v14);
    }
    CFPropertyListRef v16 = CGColorSpaceCopyPropertyList(v13);
    if (v16)
    {
      IOSurfaceSetValue(v12, *v15, v16);
      CFRelease(v16);
    }
    CGColorSpaceRelease(v13);
    IIO_CGImageBlockSetToIOSurface(ImageBlock, IOSurfaceWithFormat);
    if (!IIOCallConvertHDRData(IOSurfaceWithFormat, v12, v19)) {
      IIO_IOSurfaceToCGImageBlockSet(v12);
    }
    if (IOSurfaceWithFormat) {
      CFRelease(IOSurfaceWithFormat);
    }
    if (v12) {
      CFRelease(v12);
    }
    IIODictionary::~IIODictionary((IIODictionary *)&v18);
  }
  return a2;
}

void sub_188739AB0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_CGImageBlockSetToIOSurface(int a1, IOSurfaceRef buffer)
{
  if (!IOSurfaceLock(buffer, 0, 0))
  {
    CGImageBlockGetRect();
    unint64_t v4 = (unint64_t)v3;
    unint64_t BytesPerRow = CGImageBlockGetBytesPerRow();
    uint64_t Data = (char *)CGImageBlockGetData();
    IOSurfaceGetWidth(buffer);
    IOSurfaceGetHeight(buffer);
    size_t v7 = IOSurfaceGetBytesPerRow(buffer);
    BaseAddress = (char *)IOSurfaceGetBaseAddress(buffer);
    unint64_t v9 = BaseAddress;
    if (BytesPerRow == v7)
    {
      memcpy(BaseAddress, Data, BytesPerRow * v4);
    }
    else
    {
      if (BytesPerRow >= v7) {
        size_t v10 = v7;
      }
      else {
        size_t v10 = BytesPerRow;
      }
      for (; v4; --v4)
      {
        memcpy(v9, Data, v10);
        v9 += v7;
        Data += BytesPerRow;
      }
    }
    IOSurfaceUnlock(buffer, 0, 0);
  }
  return 0;
}

uint64_t IIO_IOSurfaceToCGImageBlockSet(__IOSurface *a1)
{
  if (!IOSurfaceLock(a1, 0, 0))
  {
    CGImageBlockGetRect();
    unint64_t v3 = (unint64_t)v2;
    unint64_t BytesPerRow = CGImageBlockGetBytesPerRow();
    uint64_t Data = (char *)CGImageBlockGetData();
    IOSurfaceGetWidth(a1);
    IOSurfaceGetHeight(a1);
    size_t v6 = IOSurfaceGetBytesPerRow(a1);
    BaseAddress = (char *)IOSurfaceGetBaseAddress(a1);
    if (BytesPerRow == v6)
    {
      memcpy(Data, BaseAddress, BytesPerRow * v3);
    }
    else
    {
      if (BytesPerRow >= v6) {
        size_t v8 = v6;
      }
      else {
        size_t v8 = BytesPerRow;
      }
      for (; v3; --v3)
      {
        memcpy(Data, BaseAddress, v8);
        BaseAddress += v6;
        Data += BytesPerRow;
      }
    }
    IOSurfaceUnlock(a1, 0, 0);
  }
  return 0;
}

uint64_t IIOReadPlugin::decodeImageIntoIOSurface(IIOReadPlugin *this, IIODecodeParameter *a2, __IOSurface *a3)
{
  IOSurfaceRef v4 = a3;
  if (a3) {
    return IIOReadPlugin::callDecodeImage((uint64_t)this, (uint64_t)a2, 1, &v4, 0, 0);
  }
  else {
    return 4294967292;
  }
}

uint64_t IIOReadPlugin::createIOSurface(IIOReadPlugin *this)
{
  return 0;
}

uint64_t IIOReadPlugin::createCVPixelBuffer(IIOReadPlugin *this)
{
  return 0;
}

uint64_t IIOReadPlugin::copyImageBlockSetImp(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 204);
  unsigned int v2 = v1 >> 24;
  uint64_t v3 = MEMORY[0x1E4F14390];
  if (v1 < 0) {
    int v4 = __maskrune(v1 >> 24, 0x40000uLL);
  }
  else {
    int v4 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v2 + 60) & 0x40000;
  }
  unsigned int v5 = v1 << 8 >> 24;
  if (v1 << 8 < 0) {
    int v6 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v6 = *(_DWORD *)(v3 + 4 * v5 + 60) & 0x40000;
  }
  unsigned int v7 = (__int16)v1 >> 8;
  if (v1 << 16 < 0) {
    int v8 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
  }
  else {
    int v8 = *(_DWORD *)(v3 + 4 * v7 + 60) & 0x40000;
  }
  if ((v1 << 24) <= 0x7F000000) {
    int v9 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
  }
  else {
    int v9 = __maskrune((char)v1, 0x40000uLL);
  }
  if (v8) {
    uint64_t v10 = v7;
  }
  else {
    uint64_t v10 = 46;
  }
  if (v6) {
    uint64_t v11 = v5;
  }
  else {
    uint64_t v11 = 46;
  }
  if (v4) {
    uint64_t v12 = v2;
  }
  else {
    uint64_t v12 = 46;
  }
  if (v9) {
    uint64_t v13 = (char)v1;
  }
  else {
    uint64_t v13 = 46;
  }
  _cg_jpeg_mem_term("copyImageBlockSetImp", 2659, "*** [%c%c%c%c] plugin did not implement 'copyImageBlockSetImp' ***\n", v12, v11, v10, v13);
  return 0;
}

uint64_t IIOReadPlugin::decodeImageData(IIOReadPlugin *this, unsigned __int8 *a2)
{
  int v2 = *((_DWORD *)this + 51);
  unsigned int v3 = v2 >> 24;
  uint64_t v4 = MEMORY[0x1E4F14390];
  if (v2 < 0) {
    int v5 = __maskrune(v2 >> 24, 0x40000uLL);
  }
  else {
    int v5 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v3 + 60) & 0x40000;
  }
  unsigned int v6 = v2 << 8 >> 24;
  if (v2 << 8 < 0) {
    int v7 = __maskrune(v2 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v7 = *(_DWORD *)(v4 + 4 * v6 + 60) & 0x40000;
  }
  unsigned int v8 = (__int16)v2 >> 8;
  if (v2 << 16 < 0) {
    int v9 = __maskrune((__int16)v2 >> 8, 0x40000uLL);
  }
  else {
    int v9 = *(_DWORD *)(v4 + 4 * v8 + 60) & 0x40000;
  }
  if ((v2 << 24) <= 0x7F000000) {
    int v10 = *(_DWORD *)(v4 + 4 * (char)v2 + 60) & 0x40000;
  }
  else {
    int v10 = __maskrune((char)v2, 0x40000uLL);
  }
  if (v9) {
    uint64_t v11 = v8;
  }
  else {
    uint64_t v11 = 46;
  }
  if (v7) {
    uint64_t v12 = v6;
  }
  else {
    uint64_t v12 = 46;
  }
  if (v5) {
    uint64_t v13 = v3;
  }
  else {
    uint64_t v13 = 46;
  }
  if (v10) {
    uint64_t v14 = (char)v2;
  }
  else {
    uint64_t v14 = 46;
  }
  _cg_jpeg_mem_term("decodeImageData", 2691, "*** [%c%c%c%c] plugin did not implement 'decodeImageData' ***\n", v13, v12, v11, v14);
  return 4294967240;
}

void IIOReadPlugin::debugWriteImageBlocks(IIOReadPlugin *this, const void *a2, size_t a3, uint64_t a4, double a5, double a6, size_t a7, uint64_t a8, int a9)
{
  if (a2)
  {
    uint64_t v18 = ImageIOTempDirPath();
    if (v18)
    {
      double v19 = (const char *)v18;
      size_t __nitems = a3;
      int v20 = *((_DWORD *)this + 51);
      unsigned int v21 = v20 >> 24;
      uint64_t v22 = MEMORY[0x1E4F14390];
      if (v20 < 0) {
        int v23 = __maskrune(v20 >> 24, 0x40000uLL);
      }
      else {
        int v23 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v21 + 60) & 0x40000;
      }
      if (v23) {
        uint64_t v24 = v21;
      }
      else {
        uint64_t v24 = 46;
      }
      uint64_t v47 = v24;
      unsigned int v25 = v20 << 8 >> 24;
      uint64_t v46 = a4;
      if (v20 << 8 < 0) {
        int v26 = __maskrune(v20 << 8 >> 24, 0x40000uLL);
      }
      else {
        int v26 = *(_DWORD *)(v22 + 4 * v25 + 60) & 0x40000;
      }
      size_t v27 = a7;
      if (v26) {
        uint64_t v28 = v25;
      }
      else {
        uint64_t v28 = 46;
      }
      unsigned int v29 = (__int16)v20 >> 8;
      uint64_t v30 = v22;
      if (v20 << 16 < 0)
      {
        uint64_t v32 = v28;
        int v31 = __maskrune((__int16)v20 >> 8, 0x40000uLL);
        uint64_t v28 = v32;
      }
      else
      {
        int v31 = *(_DWORD *)(v22 + 4 * v29 + 60) & 0x40000;
      }
      if (v31) {
        uint64_t v33 = v29;
      }
      else {
        uint64_t v33 = 46;
      }
      unsigned int v34 = (char)v20;
      if ((v20 << 24) <= 0x7F000000)
      {
        int v37 = *(_DWORD *)(v30 + 4 * (char)v20 + 60) & 0x40000;
      }
      else
      {
        __darwin_ct_rune_t v35 = (char)v20;
        uint64_t v36 = v28;
        int v37 = __maskrune(v35, 0x40000uLL);
        uint64_t v28 = v36;
      }
      size_t v38 = v27;
      uint64_t v48 = 0;
      if (v37) {
        uint64_t v39 = v34;
      }
      else {
        uint64_t v39 = 46;
      }
      asprintf(&v48, "%s/ImageBlock#%ld '%c%c%c%c' <%p>,w=%g,h=%g,rb=%ld,cs=%ld,bpc=%ld,bmi=%08X,i=%ld.br2", v19, v46, v47, v28, v33, v39, this, a5, a6, v27, *((int *)this + 80), a8, a9, *((unsigned int *)this + 52));
      uint64_t v40 = fopen(v48, "w");
      if (v40)
      {
        uint64_t v41 = v40;
        ImageIOLog("==================================================================================\n");
        ImageIOLog("=== Writing image block to '%s'\n", v48);
        ImageIOLog("==================================================================================\n");
        fwrite(a2, v38, __nitems, v41);
        fclose(v41);
      }
      else
      {
        LogError("debugWriteImageBlocks", 2831, "ERROR: can't write image block to '%s'\n", v48);
        int v42 = *__error();
        uint64_t v43 = __error();
        uint64_t v44 = strerror(*v43);
        LogError("debugWriteImageBlocks", 2832, "       vImage_Error error = %d (%s)\n", v42, v44);
      }
      if (v48) {
        free(v48);
      }
    }
  }
}

uint64_t IIOReadPlugin::copyIOSurface(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 204);
  unsigned int v2 = v1 >> 24;
  uint64_t v3 = MEMORY[0x1E4F14390];
  if (v1 < 0) {
    int v4 = __maskrune(v1 >> 24, 0x40000uLL);
  }
  else {
    int v4 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v2 + 60) & 0x40000;
  }
  unsigned int v5 = v1 << 8 >> 24;
  if (v1 << 8 < 0) {
    int v6 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v6 = *(_DWORD *)(v3 + 4 * v5 + 60) & 0x40000;
  }
  unsigned int v7 = (__int16)v1 >> 8;
  if (v1 << 16 < 0) {
    int v8 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
  }
  else {
    int v8 = *(_DWORD *)(v3 + 4 * v7 + 60) & 0x40000;
  }
  if ((v1 << 24) <= 0x7F000000) {
    int v9 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
  }
  else {
    int v9 = __maskrune((char)v1, 0x40000uLL);
  }
  if (v8) {
    uint64_t v10 = v7;
  }
  else {
    uint64_t v10 = 46;
  }
  if (v6) {
    uint64_t v11 = v5;
  }
  else {
    uint64_t v11 = 46;
  }
  if (v4) {
    uint64_t v12 = v2;
  }
  else {
    uint64_t v12 = 46;
  }
  if (v9) {
    uint64_t v13 = (char)v1;
  }
  else {
    uint64_t v13 = 46;
  }
  _cg_jpeg_mem_term("copyIOSurface", 2964, "*** [%c%c%c%c] plugin did not implement 'copyIOSurface' ***\n", v12, v11, v10, v13);
  return 0;
}

uint64_t IIOReadPlugin::copyIOSurfaceImp(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 204);
  unsigned int v2 = v1 >> 24;
  uint64_t v3 = MEMORY[0x1E4F14390];
  if (v1 < 0) {
    int v4 = __maskrune(v1 >> 24, 0x40000uLL);
  }
  else {
    int v4 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v2 + 60) & 0x40000;
  }
  unsigned int v5 = v1 << 8 >> 24;
  if (v1 << 8 < 0) {
    int v6 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v6 = *(_DWORD *)(v3 + 4 * v5 + 60) & 0x40000;
  }
  unsigned int v7 = (__int16)v1 >> 8;
  if (v1 << 16 < 0) {
    int v8 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
  }
  else {
    int v8 = *(_DWORD *)(v3 + 4 * v7 + 60) & 0x40000;
  }
  if ((v1 << 24) <= 0x7F000000) {
    int v9 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
  }
  else {
    int v9 = __maskrune((char)v1, 0x40000uLL);
  }
  if (v8) {
    uint64_t v10 = v7;
  }
  else {
    uint64_t v10 = 46;
  }
  if (v6) {
    uint64_t v11 = v5;
  }
  else {
    uint64_t v11 = 46;
  }
  if (v4) {
    uint64_t v12 = v2;
  }
  else {
    uint64_t v12 = 46;
  }
  if (v9) {
    uint64_t v13 = (char)v1;
  }
  else {
    uint64_t v13 = 46;
  }
  _cg_jpeg_mem_term("copyIOSurfaceImp", 2975, "*** [%c%c%c%c] plugin did not implement 'copyIOSurfaceImp' ***\n", v12, v11, v10, v13);
  return 4294967240;
}

uint64_t IIOReadPlugin::copyIOSurface420f(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 204);
  unsigned int v2 = v1 >> 24;
  uint64_t v3 = MEMORY[0x1E4F14390];
  if (v1 < 0) {
    int v4 = __maskrune(v1 >> 24, 0x40000uLL);
  }
  else {
    int v4 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v2 + 60) & 0x40000;
  }
  unsigned int v5 = v1 << 8 >> 24;
  if (v1 << 8 < 0) {
    int v6 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v6 = *(_DWORD *)(v3 + 4 * v5 + 60) & 0x40000;
  }
  unsigned int v7 = (__int16)v1 >> 8;
  if (v1 << 16 < 0) {
    int v8 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
  }
  else {
    int v8 = *(_DWORD *)(v3 + 4 * v7 + 60) & 0x40000;
  }
  if ((v1 << 24) <= 0x7F000000) {
    int v9 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
  }
  else {
    int v9 = __maskrune((char)v1, 0x40000uLL);
  }
  if (v8) {
    uint64_t v10 = v7;
  }
  else {
    uint64_t v10 = 46;
  }
  if (v6) {
    uint64_t v11 = v5;
  }
  else {
    uint64_t v11 = 46;
  }
  if (v4) {
    uint64_t v12 = v2;
  }
  else {
    uint64_t v12 = 46;
  }
  if (v9) {
    uint64_t v13 = (char)v1;
  }
  else {
    uint64_t v13 = 46;
  }
  _cg_jpeg_mem_term("copyIOSurface420f", 2986, "*** [%c%c%c%c] plugin did not implement 'copyIOSurfaceCallback420f' ***\n", v12, v11, v10, v13);
  return 0;
}

uint64_t IIOReadPlugin::copyIOSurfaceSet(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 204);
  unsigned int v2 = v1 >> 24;
  uint64_t v3 = MEMORY[0x1E4F14390];
  if (v1 < 0) {
    int v4 = __maskrune(v1 >> 24, 0x40000uLL);
  }
  else {
    int v4 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v2 + 60) & 0x40000;
  }
  unsigned int v5 = v1 << 8 >> 24;
  if (v1 << 8 < 0) {
    int v6 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v6 = *(_DWORD *)(v3 + 4 * v5 + 60) & 0x40000;
  }
  unsigned int v7 = (__int16)v1 >> 8;
  if (v1 << 16 < 0) {
    int v8 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
  }
  else {
    int v8 = *(_DWORD *)(v3 + 4 * v7 + 60) & 0x40000;
  }
  if ((v1 << 24) <= 0x7F000000) {
    int v9 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
  }
  else {
    int v9 = __maskrune((char)v1, 0x40000uLL);
  }
  if (v8) {
    uint64_t v10 = v7;
  }
  else {
    uint64_t v10 = 46;
  }
  if (v6) {
    uint64_t v11 = v5;
  }
  else {
    uint64_t v11 = 46;
  }
  if (v4) {
    uint64_t v12 = v2;
  }
  else {
    uint64_t v12 = 46;
  }
  if (v9) {
    uint64_t v13 = (char)v1;
  }
  else {
    uint64_t v13 = 46;
  }
  _cg_jpeg_mem_term("copyIOSurfaceSet", 2996, "*** [%c%c%c%c] plugin did not implement 'copyIOSurfaceSet' ***\n", v12, v11, v10, v13);
  return 0;
}

void IIOReadPlugin::debugWriteIOSurface(IIOReadPlugin *this, __IOSurface *a2)
{
  char v3 = IIO_XPCServer();
  if (a2)
  {
    if ((v3 & 1) == 0)
    {
      int v4 = 0;
      asprintf(&v4, "*/IOSurface-%d.br2", 0);
      ImageIOLog("==================================================================================\n");
      ImageIOLog("=== Writing IOSurfaceRef to '%s'\n", v4);
      ImageIOLog("==================================================================================\n");
      free(v4);
    }
  }
}

uint64_t IIOReadPlugin::copyImageTextureData(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 204);
  unsigned int v2 = v1 >> 24;
  uint64_t v3 = MEMORY[0x1E4F14390];
  if (v1 < 0) {
    int v4 = __maskrune(v1 >> 24, 0x40000uLL);
  }
  else {
    int v4 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v2 + 60) & 0x40000;
  }
  unsigned int v5 = v1 << 8 >> 24;
  if (v1 << 8 < 0) {
    int v6 = __maskrune(v1 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v6 = *(_DWORD *)(v3 + 4 * v5 + 60) & 0x40000;
  }
  unsigned int v7 = (__int16)v1 >> 8;
  if (v1 << 16 < 0) {
    int v8 = __maskrune((__int16)v1 >> 8, 0x40000uLL);
  }
  else {
    int v8 = *(_DWORD *)(v3 + 4 * v7 + 60) & 0x40000;
  }
  if ((v1 << 24) <= 0x7F000000) {
    int v9 = *(_DWORD *)(v3 + 4 * (char)v1 + 60) & 0x40000;
  }
  else {
    int v9 = __maskrune((char)v1, 0x40000uLL);
  }
  if (v8) {
    uint64_t v10 = v7;
  }
  else {
    uint64_t v10 = 46;
  }
  if (v6) {
    uint64_t v11 = v5;
  }
  else {
    uint64_t v11 = 46;
  }
  if (v4) {
    uint64_t v12 = v2;
  }
  else {
    uint64_t v12 = 46;
  }
  if (v9) {
    uint64_t v13 = (char)v1;
  }
  else {
    uint64_t v13 = 46;
  }
  _cg_jpeg_mem_term("copyImageTextureData", 3028, "*** [%c%c%c%c] plugin did not implement 'copyImageTextureData' ***\n", v12, v11, v10, v13);
  return 0;
}

uint64_t IIOReadPlugin::decodeLZFSEIntoBuffer(IIOReadPlugin *this, unsigned __int8 *a2, size_t a3, unsigned __int8 *a4, unint64_t a5)
{
  if (!a3) {
    return 0;
  }
  memset(&v13, 0, sizeof(v13));
  if (compression_stream_init(&v13, COMPRESSION_STREAM_DECODE, COMPRESSION_LZFSE)) {
    return 0;
  }
  unint64_t v10 = 0;
  v13.src_ptr = a2;
  v13.src_size_t size = a3;
  while (a5 > v10)
  {
    v13.dst_ptr = &a4[v10];
    v13.dst_size_t size = a5 - v10;
    compression_status v11 = compression_stream_process(&v13, 0);
    if (v11 == COMPRESSION_STATUS_ERROR) {
      break;
    }
    unint64_t v10 = v13.dst_ptr - a4;
    if (v11 == COMPRESSION_STATUS_END)
    {
      uint64_t v9 = 1;
      goto LABEL_10;
    }
  }
  uint64_t v9 = 0;
LABEL_10:
  compression_stream_destroy(&v13);
  return v9;
}

uint64_t IIOReadPlugin::textureDataLockData(IIOReadPlugin *this, unint64_t a2, unint64_t a3, unint64_t *a4, unint64_t *a5, unint64_t *a6)
{
  *a4 = 0;
  *a5 = 0;
  *a6 = 0;
  return 0;
}

uint64_t IIOReadPlugin::getCachedTile(IIOReadPlugin *this, double a2)
{
  LODWORD(a2) = *((_DWORD *)this + 71);
  double v3 = (double)*(unint64_t *)&a2;
  LODWORD(a2) = *((_DWORD *)this + 72);
  double v4 = (double)*(unint64_t *)&a2;
  LODWORD(a2) = *((_DWORD *)this + 73);
  double v5 = (double)*(unint64_t *)&a2;
  LODWORD(a2) = *((_DWORD *)this + 74);
  double v6 = (double)*(unint64_t *)&a2;
  uint64_t v12 = 0;
  compression_stream v13 = &v12;
  uint64_t v14 = 0x2000000000;
  int v15 = 0;
  if ((gIIODebugFlags & 0x300) == 0x100 || (gIIODebugFlags & 0x400000000000) != 0) {
    ImageIOLog("::: getCachedTile  request: rect=(%5g, %5g, %5g, %5g)\n", v3, v4, v5, v6);
  }
  uint64_t v8 = *((void *)this + 4);
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 0x40000000;
  v11[2] = ___ZN13IIOReadPlugin13getCachedTileEv_block_invoke;
  v11[3] = &unk_1E53C7038;
  *(double *)&v11[6] = v3;
  *(double *)&v11[7] = v4;
  *(double *)&UInt8 v11[8] = v5;
  *(double *)&v11[9] = v6;
  v11[4] = &v12;
  v11[5] = this;
  IIOImageRead::enumerateCacheKeysWithBlock(v8, (uint64_t)v11);
  uint64_t v9 = (*((_DWORD *)this + 26) - *((_DWORD *)v13 + 6));
  _Block_object_dispose(&v12, 8);
  return v9;
}

void sub_18873AAEC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void ___ZN13IIOReadPlugin13getCachedTileEv_block_invoke(uint64_t a1, _DWORD *a2, double a3, double a4)
{
  uint64_t v8 = *(void *)(a1 + 40);
  LODWORD(a3) = a2[2];
  LODWORD(a4) = a2[3];
  double v9 = (double)*(unint64_t *)&a3;
  double v10 = (double)*(unint64_t *)&a4;
  LODWORD(a3) = a2[4];
  LODWORD(a4) = a2[5];
  double v11 = (double)*(unint64_t *)&a3;
  double v12 = (double)*(unint64_t *)&a4;
  if ((gIIODebugFlags & 0x300) == 0x100 || (gIIODebugFlags & 0x400000000000) != 0) {
    ImageIOLog(":::                checking rect=(%5g, %5g, %5g, %5g)\n", v9, v10, (double)*(unint64_t *)&a3, (double)*(unint64_t *)&a4);
  }
  v39.origin.double x = v9;
  v39.origin.double y = v10;
  v39.size.double width = v11;
  v39.size.double height = v12;
  if (CGRectEqualToRect(*(CGRect *)(a1 + 48), v39))
  {
    uint64_t v36 = 0;
    LODWORD(v4) = *(_DWORD *)(v8 + 284);
    LODWORD(v14) = *(_DWORD *)(v8 + 288);
    double y = (double)v14;
    LODWORD(v5) = *(_DWORD *)(v8 + 292);
    LODWORD(v14) = *(_DWORD *)(v8 + 296);
    double v17 = (double)v14;
    LODWORD(v15) = *(_DWORD *)(v8 + 232);
    double v18 = (double)v15;
    if (y + v17 <= v18) {
      double height = v17;
    }
    else {
      double height = v18 - y;
    }
    if ((gIIODebugFlags & 0x300) == 0x100 || (gIIODebugFlags & 0x400000000000) != 0) {
      ImageIOLog(":::          found matching rect=(%5g, %5g, %5g, %5g)\n", v9, v10, v11, v12);
    }
    unsigned int v21 = a2[9];
    int v22 = *(_DWORD *)(v8 + 300);
    if (v21 != v22)
    {
      _cg_jpeg_mem_term("getCachedTile_block_invoke", 3232, "*** cannot use cached tile: cached-rb: %d   blockGeo-rb:%d\n", a2[9], v22);
      return;
    }
    double x = (double)v4;
    double width = (double)v5;
    if (*(_DWORD *)(v8 + 400) == a2[6])
    {
      if (!IIOImageRead::getCachedImageBlockData(*(void *)(v8 + 32), a2, &v36)) {
        return;
      }
      v37.origin.double x = (double)v4;
      v37.origin.double y = y;
      v37.size.double width = (double)v5;
      v37.size.double height = height;
      int ImageBlock = IIOReadPlugin::createImageBlock((IIOReadPlugin *)v8, v36, 0, v37, *(unsigned int *)(v8 + 300), 1);
    }
    else
    {
      if (*(_WORD *)(v8 + 242) != 32) {
        return;
      }
      if (*(_WORD *)(v8 + 240) != 8) {
        return;
      }
      if (*(_DWORD *)(v8 + 320) != 1) {
        return;
      }
      memory_object_size_t v35 = 0;
      memory_object_offset_t v26 = _ImageIO_Malloc(*(unsigned int *)(v8 + 296) * (unint64_t)v21, *(void *)(v8 + 384), &v35, (uint64_t)"ImageIOGetCachedBlocks", *(_DWORD *)(v8 + 432), 0, 0);
      if (!v26) {
        return;
      }
      size_t v27 = (void *)v26;
      if (!IIOImageRead::getCachedImageBlockData(*(void *)(v8 + 32), a2, &v36)) {
        return;
      }
      vImagePixelCount v28 = *(unsigned int *)(v8 + 296);
      src.data = v36;
      src.double height = v28;
      vImagePixelCount v29 = *(unsigned int *)(v8 + 292);
      size_t v30 = a2[9];
      dest.data = v27;
      dest.double height = v28;
      size_t v31 = *(unsigned int *)(v8 + 300);
      dest.double width = v29;
      dest.size_t rowBytes = v31;
      src.double width = v29;
      src.size_t rowBytes = v30;
      *(_DWORD *)permuteMap = 50331906;
      if (v30 < 4 * (int)v29) {
        return;
      }
      vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0x10u);
      if (*(unsigned __int8 *)(v8 + 246) - 3 <= 1)
      {
        if (*(unsigned char *)(v8 + 404))
        {
          if (*(unsigned char *)(v8 + 404) == 1) {
            vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
          }
        }
        else
        {
          vImageUnpremultiplyData_RGBA8888(&dest, &dest, 0x10u);
        }
      }
      CGImageReadSessionReleaseCachedImageBlockData(v36);
      int ImageBlock = IIO_ImageBlockCreate((unint64_t)v27, *(unsigned int *)(v8 + 300), 0, (double)v4, y, (double)v5, height);
    }
    *(void *)(*(void *)(v8 + 96) + 8 * *(unsigned int *)(v8 + 112)) = ImageBlock;
    if (!CGRectEqualToRect(*(CGRect *)(v8 + 120), *MEMORY[0x1E4F1DB20]))
    {
      v40.origin.double x = (double)v4;
      v40.origin.double y = y;
      v40.size.double width = (double)v5;
      v40.size.double height = height;
      CGRect v38 = CGRectUnion(*(CGRect *)(v8 + 120), v40);
      double x = v38.origin.x;
      double y = v38.origin.y;
      double width = v38.size.width;
      double height = v38.size.height;
    }
    *(double *)(v8 + 120) = x;
    *(double *)(v8 + 128) = y;
    *(double *)(v8 + 136) = width;
    *(double *)(v8 + 144) = height;
    if ((gIIODebugFlags & 0x300) == 0x100 || (gIIODebugFlags & 0x400000000000) != 0) {
      ImageIOLog("::: cache  hit:      rect=(%5d, %5d, %5d, %5d)   rb=%d   imageData=%p\n", *(_DWORD *)(v8 + 284), *(_DWORD *)(v8 + 288), *(_DWORD *)(v8 + 292), *(_DWORD *)(v8 + 296), *(_DWORD *)(v8 + 300), v36);
    }
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
}

void IIOReadPlugin::CreateRecodeProperties(IIOReadPlugin *this, IIOImageSource *a2, IIODictionary *a3, IIOImageDestination *a4, IIODictionary *a5, CGImageMetadata **a6)
{
  *(void *)a5 = CGImageMetadataCreateMutable();
  operator new();
}

void sub_18873AF4C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

void IIOReadPlugin::CleanupRecodeProperties(IIOReadPlugin *this, IIODictionary *a2)
{
  if (this)
  {
    if ((IIODictionary::containsKey(this, @"{Exif}") & 1) == 0)
    {
      uint64_t v14 = 0;
      xpc_object_t value = 0;
      CFPropertyListRef v16 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v14);
      IIODictionary::setObjectForKey(this, value, @"{Exif}");
      if (IIODictionary::containsKey(this, @"PixelWidth"))
      {
        CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(this, @"PixelWidth");
        IIODictionary::setObjectForKey((IIODictionary *)&v14, ObjectForKey, @"PixelXDimension");
      }
      if (IIODictionary::containsKey(this, @"PixelHeight"))
      {
        CFDictionaryRef v4 = IIODictionary::getObjectForKey(this, @"PixelHeight");
        IIODictionary::setObjectForKey((IIODictionary *)&v14, v4, @"PixelYDimension");
      }
      IIODictionary::~IIODictionary((IIODictionary *)&v14);
    }
    if (IIODictionary::containsKey(this, @"{TIFF}"))
    {
      int Uint32ForKey = IIODictionary::getUint32ForKey(this, @"Orientation");
      int Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(this, @"Orientation", @"{TIFF}");
      _cg_jpeg_mem_term("CleanupRecodeProperties", 3834, "IIOReadPlugin::CleanupRecodeProperties:  top: %d  tiff: %d\n", Uint32ForKey, Uint32ForKeyGroup);
      if (Uint32ForKey) {
        BOOL v7 = Uint32ForKeyGroup == 0;
      }
      else {
        BOOL v7 = 0;
      }
      if (v7)
      {
        IIONumber::IIONumber((IIONumber *)&v14, Uint32ForKey);
        IIODictionary::setObjectForKeyGroup(this, v16, @"Orientation", @"{TIFF}");
        goto LABEL_28;
      }
      if (Uint32ForKey) {
        BOOL v8 = 1;
      }
      else {
        BOOL v8 = Uint32ForKeyGroup == 0;
      }
      if (!v8)
      {
        IIONumber::IIONumber((IIONumber *)&v14, Uint32ForKeyGroup);
        IIODictionary::setObjectForKey(this, v16, @"Orientation");
LABEL_28:
        IIONumber::~IIONumber((IIONumber *)&v14);
      }
    }
    else
    {
      uint64_t v14 = 0;
      xpc_object_t value = 0;
      CFPropertyListRef v16 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v14);
      IIODictionary::setObjectForKey(this, value, @"{TIFF}");
      if (IIODictionary::containsKey(this, @"DPIWidth"))
      {
        CFDictionaryRef v9 = IIODictionary::getObjectForKey(this, @"DPIWidth");
        IIODictionary::setObjectForKey((IIODictionary *)&v14, v9, @"XResolution");
      }
      if (IIODictionary::containsKey(this, @"DPIHeight"))
      {
        CFDictionaryRef v10 = IIODictionary::getObjectForKey(this, @"DPIHeight");
        IIODictionary::setObjectForKey((IIODictionary *)&v14, v10, @"YResolution");
      }
      if (IIODictionary::getCount((IIODictionary *)&v14))
      {
        IIONumber::IIONumber((IIONumber *)v12, 2);
        IIODictionary::setObjectForKey((IIODictionary *)&v14, v13, @"ResolutionUnit");
        IIONumber::~IIONumber((IIONumber *)v12);
      }
      if (IIODictionary::containsKey(this, @"Orientation"))
      {
        CFDictionaryRef v11 = IIODictionary::getObjectForKey(this, @"Orientation");
        IIODictionary::setObjectForKey((IIODictionary *)&v14, v11, @"Orientation");
      }
      IIODictionary::~IIODictionary((IIODictionary *)&v14);
    }
  }
}

void sub_18873B250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

FILE *IIOImageReadSession::createFILE(IIOImageReadSession *this)
{
  unsigned int v2 = funopen(this, (int (__cdecl *)(void *, char *, int))imagereader_readfn, 0, (fpos_t (__cdecl *)(void *, fpos_t, int))imagereader_seekfn, (int (__cdecl *)(void *))imagereader_closefn);
  double v3 = v2;
  if (v2)
  {
    if ((gIIODebugFlags & 0x200000000000) != 0) {
      ImageIOLog(">>> CGImageReadSessionCreateFILE: [%p] funopen FILE* %p\n", this, v2);
    }
    CFDictionaryRef v4 = (const void *)*((void *)this + 1);
    if (v4) {
      CFRetain(v4);
    }
  }
  return v3;
}

unint64_t imagereader_readfn(IIOImageReadSession *a1, char *a2, int a3)
{
  return IIOImageReadSession::getBytes(a1, a2, a3);
}

uint64_t imagereader_closefn(void *a1)
{
  if (a1)
  {
    uint64_t v1 = (const void *)a1[1];
    if (v1) {
      CFRelease(v1);
    }
  }
  return 0;
}

uint64_t IIOImageReadSession::setOffset(uint64_t this, uint64_t a2)
{
  *(void *)(this + 40) = a2;
  return this;
}

size_t *IIOImageReadSession::addDataToXPCDictionary(IIOImageReadSession *this, void *a2, void **a3)
{
  uint64_t result = (size_t *)*((void *)this + 4);
  if (result) {
    return (size_t *)IIOImageRead::addDataToXPCDict(result, a2, a3);
  }
  return result;
}

const __CFData *IIOImageReadSession::copyData(IIOImageRead **this)
{
  return IIOImageRead::copyData(this[4]);
}

char *IIOImageReadSession::copySourceInfo(IIOImageRead **this)
{
  return IIOImageRead::copySourceInfo(this[4]);
}

uint64_t IIOImageReadSession::shouldExposeMultiFrameContents(IIOImageRead **this)
{
  return IIOImageRead::shouldExposeMultiFrameContents(this[4]);
}

uint64_t IIOImageReadSession::useImageSequence(IIOImageRead **this)
{
  return IIOImageRead::useImageSequence(this[4]);
}

uint64_t CGImageReadSessionGetTypeID()
{
  if (CGImageReadSessionGetTypeID::once != -1) {
    dispatch_once(&CGImageReadSessionGetTypeID::once, &__block_literal_global_14);
  }
  return CGImageReadSessionGetTypeID::id;
}

CFStringRef _CGImageReadSessionCopyDebugDesc(void *cf)
{
  if (cf) {
    uint64_t v2 = cf[3];
  }
  else {
    uint64_t v2 = 0;
  }
  CFAllocatorRef v3 = CFGetAllocator(cf);
  return CFStringCreateWithFormat(v3, 0, @"<CGImageReadSessionRef %p>{offset=%lld}%s", cf, *(void *)(v2 + 40), "");
}

CFIndex CGImageReadSessionGetSize(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 24)) != 0 && (v2 = *(IIOImageRead **)(v1 + 32)) != 0) {
    return IIOImageRead::getSize(v2);
  }
  else {
    return 0;
  }
}

BOOL CGImageReadSessionIsFinal(uint64_t a1)
{
  return a1
      && (uint64_t v1 = *(void *)(a1 + 24)) != 0
      && (uint64_t v2 = *(IIOImageRead **)(v1 + 32)) != 0
      && IIOImageRead::isFinal(v2);
}

const UInt8 *CGImageReadSessionGetBytePointer(uint64_t a1, const __CFData **a2)
{
  if (a1 && a2 && (uint64_t v2 = *(void *)(a1 + 24)) != 0 && (v3 = *(IIOImageRead **)(v2 + 32)) != 0) {
    return IIOImageRead::retainBytePointer(v3, a2, 0);
  }
  else {
    return 0;
  }
}

void CGImageReadSessionReleaseBytePointer(uint64_t a1, const void *a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2)
    {
      CFAllocatorRef v3 = *(IIOImageRead **)(v2 + 32);
      if (v3) {
        IIOImageRead::releaseBytePointer(v3, a2);
      }
    }
  }
}

unint64_t CGImageReadSessionGetBytesAtOffset(uint64_t a1, unsigned char *a2, unint64_t a3, unint64_t a4)
{
  if (a1 && (uint64_t v4 = *(void *)(a1 + 24)) != 0 && (v5 = *(IIOImageRead **)(v4 + 32)) != 0) {
    return IIOImageRead::getBytesAtOffset(v5, a2, a3, a4);
  }
  else {
    return 0;
  }
}

char *CGImageReadSessionCopySourceInfo(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void *)(a1 + 24)) != 0 && (v2 = *(IIOImageRead **)(v1 + 32)) != 0) {
    return IIOImageRead::copySourceInfo(v2);
  }
  else {
    return 0;
  }
}

FILE *CGImageReadSessionCreateFILE(void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = (const void *)a1[3];
  CFAllocatorRef v3 = funopen(v2, (int (__cdecl *)(void *, char *, int))imagereader_readfn, 0, (fpos_t (__cdecl *)(void *, fpos_t, int))imagereader_seekfn, (int (__cdecl *)(void *))imagereader_closefn);
  uint64_t v4 = v3;
  if (v3)
  {
    if ((gIIODebugFlags & 0x200000000000) != 0) {
      ImageIOLog(">>> CGImageReadSessionCreateFILE: [%p] funopen FILE* %p\n", v2, v3);
    }
    CFRetain(a1);
  }
  return v4;
}

uint64_t jinit_arith_decoder(uint64_t a1)
{
  uint64_t result = (**(uint64_t (***)(void))(a1 + 8))();
  *(void *)(a1 + 624) = result;
  *(void *)uint64_t result = start_pass_0;
  *(void *)(result + 16) = finish_pass;
  *(_OWORD *)(result + 304) = 0u;
  *(_OWORD *)(result + 320) = 0u;
  *(_OWORD *)(result + 272) = 0u;
  *(_OWORD *)(result + 288) = 0u;
  *(_OWORD *)(result + 240) = 0u;
  *(_OWORD *)(result + 256) = 0u;
  *(_OWORD *)(result + 208) = 0u;
  *(_OWORD *)(result + 224) = 0u;
  *(_OWORD *)(result + 176) = 0u;
  *(_OWORD *)(result + 192) = 0u;
  *(_OWORD *)(result + 144) = 0u;
  *(_OWORD *)(result + 160) = 0u;
  *(_OWORD *)(result + 112) = 0u;
  *(_OWORD *)(result + 128) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  *(_OWORD *)(result + 96) = 0u;
  *(unsigned char *)(result + 336) = 113;
  if (*(_DWORD *)(a1 + 316))
  {
    uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, (uint64_t)*(int *)(a1 + 56) << 8);
    *(void *)(a1 + 192) = result;
    if (*(int *)(a1 + 56) >= 1)
    {
      int v3 = 0;
      *(void *)&long long v4 = -1;
      *((void *)&v4 + 1) = -1;
      do
      {
        *(_OWORD *)(result + 224) = v4;
        *(_OWORD *)(result + 240) = v4;
        *(_OWORD *)(result + 192) = v4;
        *(_OWORD *)(result + 208) = v4;
        *(_OWORD *)(result + 160) = v4;
        *(_OWORD *)(result + 176) = v4;
        *(_OWORD *)(result + 128) = v4;
        *(_OWORD *)(result + 144) = v4;
        *(_OWORD *)(result + 96) = v4;
        *(_OWORD *)(result + 112) = v4;
        *(_OWORD *)(result + 64) = v4;
        *(_OWORD *)(result + 80) = v4;
        *(_OWORD *)(result + 32) = v4;
        *(_OWORD *)(result + 48) = v4;
        *(_OWORD *)uint64_t result = v4;
        *(_OWORD *)(result + 16) = v4;
        result += 256;
        ++v3;
      }
      while (v3 < *(_DWORD *)(a1 + 56));
    }
  }
  return result;
}

uint64_t start_pass_0(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 624);
  int v3 = *(_DWORD *)(result + 540);
  if (*(_DWORD *)(result + 316))
  {
    int v4 = *(_DWORD *)(result + 544);
    if (v3)
    {
      if (v4 < v3 || v4 > *(_DWORD *)(result + 568) || *(_DWORD *)(result + 448) != 1) {
        goto LABEL_18;
      }
    }
    else if (v4)
    {
      goto LABEL_18;
    }
    int v7 = *(_DWORD *)(result + 548);
    if (v7)
    {
      int v8 = v7 - 1;
      if (v8 != *(_DWORD *)(result + 552)) {
        goto LABEL_18;
      }
    }
    else
    {
      int v8 = *(_DWORD *)(result + 552);
    }
    if (v8 < 14)
    {
LABEL_19:
      LODWORD(v6) = *(_DWORD *)(v1 + 448);
      if ((int)v6 >= 1)
      {
        uint64_t v10 = 0;
        do
        {
          uint64_t v11 = *(int *)(*(void *)(v1 + 8 * v10 + 456) + 4);
          double v12 = (_DWORD *)(*(void *)(v1 + 192) + (v11 << 8));
          int v13 = *(_DWORD *)(v1 + 540);
          if (v13 && (*v12 & 0x80000000) != 0)
          {
            uint64_t v14 = *(void *)v1;
            *(_DWORD *)(v14 + 40) = 118;
            *(_DWORD *)(v14 + 48) = v11;
            *(_DWORD *)(*(void *)v1 + 52) = 0;
            uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v1 + 8))(v1, 0xFFFFFFFFLL);
            int v13 = *(_DWORD *)(v1 + 540);
          }
          if (v13 <= *(_DWORD *)(v1 + 544))
          {
            uint64_t v15 = v13;
            do
            {
              if (*(_DWORD *)(v1 + 548) != (v12[v15] & ~((int)v12[v15] >> 31)))
              {
                uint64_t v16 = *(void *)v1;
                *(_DWORD *)(v16 + 40) = 118;
                *(_DWORD *)(v16 + 48) = v11;
                *(_DWORD *)(*(void *)v1 + 52) = v15;
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v1 + 8))(v1, 0xFFFFFFFFLL);
              }
              v12[v15] = *(_DWORD *)(v1 + 552);
            }
            while (v15++ < *(int *)(v1 + 544));
          }
          ++v10;
          uint64_t v6 = *(int *)(v1 + 448);
        }
        while (v10 < v6);
      }
      int v18 = *(_DWORD *)(v1 + 540);
      if (*(_DWORD *)(v1 + 548))
      {
        if (v18) {
          double v19 = decode_mcu_AC_refine_0;
        }
        else {
          double v19 = decode_mcu_DC_refine_0;
        }
      }
      else if (v18)
      {
        double v19 = decode_mcu_AC_first_0;
      }
      else
      {
        double v19 = decode_mcu_DC_first_0;
      }
      *(void *)(v2 + 8) = v19;
      goto LABEL_38;
    }
LABEL_18:
    uint64_t v9 = *(void *)result;
    *(_DWORD *)(v9 + 40) = 17;
    *(_DWORD *)(v9 + 48) = v3;
    *(_DWORD *)(*(void *)result + 52) = *(_DWORD *)(result + 544);
    *(_DWORD *)(*(void *)result + 56) = *(_DWORD *)(result + 548);
    *(_DWORD *)(*(void *)result + 60) = *(_DWORD *)(result + 552);
    uint64_t result = (**(uint64_t (***)(uint64_t))result)(result);
    goto LABEL_19;
  }
  if (v3
    || *(_DWORD *)(result + 548)
    || *(_DWORD *)(result + 552)
    || (int v33 = *(_DWORD *)(result + 544), v33 <= 63) && v33 != *(_DWORD *)(result + 568))
  {
    uint64_t v5 = *(void *)result;
    *(_DWORD *)(v5 + 40) = 125;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(v5 + 8))(result, 0xFFFFFFFFLL);
  }
  *(void *)(v2 + 8) = decode_mcu_0;
  LODWORD(v6) = *(_DWORD *)(v1 + 448);
LABEL_38:
  if ((int)v6 >= 1)
  {
    for (uint64_t i = 0; i < *(int *)(v1 + 448); ++i)
    {
      uint64_t v21 = *(void *)(v1 + 8 * i + 456);
      if (!*(_DWORD *)(v1 + 316)) {
        goto LABEL_43;
      }
      if (*(_DWORD *)(v1 + 540)) {
        goto LABEL_51;
      }
      if (!*(_DWORD *)(v1 + 548))
      {
LABEL_43:
        unsigned int v22 = *(_DWORD *)(v21 + 20);
        if (v22 >= 0x10)
        {
          uint64_t v23 = *(void *)v1;
          *(_DWORD *)(v23 + 40) = 50;
          *(_DWORD *)(v23 + 48) = v22;
          (**(void (***)(uint64_t))v1)(v1);
        }
        uint64_t v24 = v2 + 8 * (int)v22;
        uint64_t v26 = *(void *)(v24 + 80);
        unsigned int v25 = (uint64_t *)(v24 + 80);
        uint64_t result = v26;
        if (!v26)
        {
          uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(v1 + 8))(v1, 1, 64);
          uint64_t *v25 = result;
        }
        *(_OWORD *)(result + 32) = 0u;
        *(_OWORD *)(result + 48) = 0u;
        *(_OWORD *)uint64_t result = 0u;
        *(_OWORD *)(result + 16) = 0u;
        uint64_t v27 = v2 + 4 * i;
        *(_DWORD *)(v27 + 44) = 0;
        *(_DWORD *)(v27 + 60) = 0;
        if (*(_DWORD *)(v1 + 316))
        {
          if (*(_DWORD *)(v1 + 540)) {
            goto LABEL_51;
          }
        }
        else if (*(_DWORD *)(v1 + 568))
        {
LABEL_51:
          unsigned int v28 = *(_DWORD *)(v21 + 24);
          if (v28 >= 0x10)
          {
            uint64_t v29 = *(void *)v1;
            *(_DWORD *)(v29 + 40) = 50;
            *(_DWORD *)(v29 + 48) = v28;
            (**(void (***)(uint64_t))v1)(v1);
          }
          uint64_t v30 = v2 + 8 * (int)v28;
          uint64_t v32 = *(void *)(v30 + 208);
          size_t v31 = (uint64_t *)(v30 + 208);
          uint64_t result = v32;
          if (!v32)
          {
            uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(v1 + 8))(v1, 1, 256);
            *size_t v31 = result;
          }
          *(_OWORD *)(result + 224) = 0u;
          *(_OWORD *)(result + 240) = 0u;
          *(_OWORD *)(result + 192) = 0u;
          *(_OWORD *)(result + 208) = 0u;
          *(_OWORD *)(result + 160) = 0u;
          *(_OWORD *)(result + 176) = 0u;
          *(_OWORD *)(result + 128) = 0u;
          *(_OWORD *)(result + 144) = 0u;
          *(_OWORD *)(result + 96) = 0u;
          *(_OWORD *)(result + 112) = 0u;
          *(_OWORD *)(result + 64) = 0u;
          *(_OWORD *)(result + 80) = 0u;
          *(_OWORD *)(result + 32) = 0u;
          *(_OWORD *)(result + 48) = 0u;
          *(_OWORD *)uint64_t result = 0u;
          *(_OWORD *)(result + 16) = 0u;
        }
      }
    }
  }
  *(void *)(v2 + 24) = 0;
  *(void *)(v2 + 32) = 0;
  *(_DWORD *)(v2 + 40) = -16;
  *(_DWORD *)(v2 + 76) = *(_DWORD *)(v1 + 372);
  return result;
}

uint64_t decode_mcu_DC_first_0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    int v4 = *(_DWORD *)(v3 + 76);
    if (!v4)
    {
      process_restart_0((uint64_t *)a1);
      int v4 = *(_DWORD *)(v3 + 76);
    }
    *(_DWORD *)(v3 + 76) = v4 - 1;
  }
  if (*(_DWORD *)(v3 + 40) == -1 || *(int *)(a1 + 496) < 1) {
    return 1;
  }
  uint64_t v5 = 0;
  while (1)
  {
    uint64_t v6 = *(_WORD **)(a2 + 8 * v5);
    uint64_t v7 = *(int *)(a1 + 4 * v5 + 500);
    uint64_t v8 = *(int *)(*(void *)(a1 + 8 * v7 + 456) + 20);
    uint64_t v9 = v3 + 8 * v8;
    uint64_t v12 = *(void *)(v9 + 80);
    uint64_t v11 = (void *)(v9 + 80);
    uint64_t v10 = v12;
    uint64_t v13 = v3 + 4 * v7;
    uint64_t v15 = *(int *)(v13 + 60);
    uint64_t v14 = (int *)(v13 + 60);
    uint64_t v16 = v10 + v15;
    if (arith_decode(a1, (unsigned char *)(v10 + v15))) {
      break;
    }
    *uint64_t v14 = 0;
    int v20 = *(_DWORD *)(v3 + 4 * v7 + 44);
LABEL_30:
    *uint64_t v6 = v20 << *(_DWORD *)(a1 + 552);
    if (++v5 >= *(int *)(a1 + 496)) {
      return 1;
    }
  }
  unsigned int v17 = arith_decode(a1, (unsigned char *)(v16 + 1));
  int v18 = (unsigned char *)(v16 + v17 + 2);
  if (!arith_decode(a1, v18))
  {
    int v19 = 0;
    goto LABEL_16;
  }
  int v18 = (unsigned char *)(*v11 + 20);
  int v19 = 1;
  if (!arith_decode(a1, v18))
  {
LABEL_16:
    if (v19 >= (int)((unint64_t)(1 << *(unsigned char *)(a1 + v8 + 324)) >> 1))
    {
      int v21 = 4 * v17 + 4;
      if (v19 > (int)((unint64_t)(1 << *(unsigned char *)(a1 + v8 + 340)) >> 1)) {
        int v21 = 4 * v17 + 12;
      }
    }
    else
    {
      int v21 = 0;
    }
    *uint64_t v14 = v21;
    if (v19 >= 2)
    {
      uint64_t v23 = v18 + 14;
      int v22 = v19;
      do
      {
        if (arith_decode(a1, v23)) {
          int v24 = v19 >> 1;
        }
        else {
          int v24 = 0;
        }
        v22 |= v24;
        BOOL v25 = v19 > 3;
        v19 >>= 1;
      }
      while (v25);
    }
    else
    {
      int v22 = v19;
    }
    int v26 = ~v22;
    if (!v17) {
      int v26 = v22 + 1;
    }
    uint64_t v27 = v3 + 4 * v7;
    int v20 = *(_DWORD *)(v27 + 44) + v26;
    *(_DWORD *)(v27 + 44) = v20;
    goto LABEL_30;
  }
  while (1)
  {
    v19 *= 2;
    if (v19 == 0x8000) {
      break;
    }
    if (!arith_decode(a1, ++v18)) {
      goto LABEL_16;
    }
  }
  uint64_t v28 = *(void *)a1;
  *(_DWORD *)(v28 + 40) = 117;
  (*(void (**)(uint64_t, uint64_t))(v28 + 8))(a1, 0xFFFFFFFFLL);
  *(_DWORD *)(v3 + 40) = -1;
  return 1;
}

uint64_t decode_mcu_AC_first_0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    int v5 = *(_DWORD *)(v4 + 76);
    if (!v5)
    {
      process_restart_0((uint64_t *)a1);
      int v5 = *(_DWORD *)(v4 + 76);
    }
    *(_DWORD *)(v4 + 76) = v5 - 1;
  }
  if (*(_DWORD *)(v4 + 40) != -1)
  {
    uint64_t v6 = *(void *)(a1 + 560);
    uint64_t v7 = *(int *)(*(void *)(a1 + 456) + 24);
    int v8 = *(_DWORD *)(a1 + 540) - 1;
    uint64_t v9 = (uint64_t *)(v4 + 8 * v7 + 208);
    uint64_t v28 = *a2;
    int v26 = (unsigned __int8 *)(a1 + v7 + 356);
    uint64_t v27 = v6;
    do
    {
      uint64_t v10 = *v9;
      if (arith_decode(a1, (unsigned char *)(*v9 + 3 * v8))) {
        break;
      }
      uint64_t v11 = (unsigned char *)(v10 + 3 * v8 + 2);
      uint64_t v12 = (int *)(v6 + 4 * (v8 + 1));
      while (1)
      {
        int v13 = v8 + 1;
        if (arith_decode(a1, v11 - 1)) {
          break;
        }
        v11 += 3;
        ++v12;
        ++v8;
        if (v13 >= *(_DWORD *)(a1 + 544)) {
          goto LABEL_32;
        }
      }
      int v14 = arith_decode(a1, (unsigned char *)(v4 + 336));
      if (arith_decode(a1, v11))
      {
        if (arith_decode(a1, v11))
        {
          uint64_t v15 = *v9;
          uint64_t v16 = 217;
          if (v8 < *v26) {
            uint64_t v16 = 189;
          }
          unsigned int v17 = (unsigned char *)(v15 + v16 + 14);
          int v18 = 2;
          if (arith_decode(a1, (unsigned char *)(v15 + v16)))
          {
            while (1)
            {
              v18 *= 2;
              if (v18 == 0x8000) {
                break;
              }
              int v19 = arith_decode(a1, v17 - 13);
              ++v17;
              if (!v19)
              {
                if (!v18) {
                  goto LABEL_28;
                }
                goto LABEL_20;
              }
            }
LABEL_32:
            uint64_t v24 = *(void *)a1;
            *(_DWORD *)(v24 + 40) = 117;
            (*(void (**)(uint64_t, uint64_t))(v24 + 8))(a1, 0xFFFFFFFFLL);
            *(_DWORD *)(v4 + 40) = -1;
            return 1;
          }
LABEL_20:
          int v20 = v18;
          do
          {
            if (arith_decode(a1, v17)) {
              int v21 = v20 >> 1;
            }
            else {
              int v21 = 0;
            }
            v18 |= v21;
            BOOL v22 = v20 > 3;
            v20 >>= 1;
          }
          while (v22);
        }
        else
        {
          int v18 = 1;
        }
      }
      else
      {
        int v18 = 0;
      }
LABEL_28:
      int v23 = ~v18;
      if (!v14) {
        int v23 = v18 + 1;
      }
      uint64_t v6 = v27;
      *(_WORD *)(v28 + 2 * *v12) = v23 << *(_DWORD *)(a1 + 552);
      int v8 = v13;
    }
    while (v13 < *(_DWORD *)(a1 + 544));
  }
  return 1;
}

uint64_t decode_mcu_DC_refine_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    int v5 = *(_DWORD *)(v4 + 76);
    if (!v5)
    {
      process_restart_0((uint64_t *)a1);
      int v5 = *(_DWORD *)(v4 + 76);
    }
    *(_DWORD *)(v4 + 76) = v5 - 1;
  }
  if (*(int *)(a1 + 496) >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = (unsigned char *)(v4 + 336);
    int v8 = 1 << *(_DWORD *)(a1 + 552);
    do
    {
      if (arith_decode(a1, v7)) {
        **(_WORD **)(a2 + 8 * v6) |= v8;
      }
      ++v6;
    }
    while (v6 < *(int *)(a1 + 496));
  }
  return 1;
}

uint64_t decode_mcu_AC_refine_0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    int v5 = *(_DWORD *)(v4 + 76);
    if (!v5)
    {
      process_restart_0((uint64_t *)a1);
      int v5 = *(_DWORD *)(v4 + 76);
    }
    *(_DWORD *)(v4 + 76) = v5 - 1;
  }
  if (*(_DWORD *)(v4 + 40) != -1)
  {
    uint64_t v6 = *(void *)(a1 + 560);
    uint64_t v7 = *a2;
    int v24 = 1 << *(_DWORD *)(a1 + 552);
    uint64_t v8 = *(int *)(a1 + 544);
    do
    {
      if (*(_WORD *)(v7 + 2 * *(int *)(v6 + 4 * v8))) {
        break;
      }
      --v8;
    }
    while (v8);
    int v9 = *(_DWORD *)(a1 + 540) - 1;
    uint64_t v10 = (uint64_t *)(v4 + 8 * *(int *)(*(void *)(a1 + 456) + 24) + 208);
    uint64_t v11 = v6 + 4;
    do
    {
      uint64_t v12 = *v10;
      int v13 = 3 * v9;
      if (v9 >= (int)v8 && arith_decode(a1, (unsigned char *)(v12 + v13))) {
        break;
      }
      uint64_t v14 = v13;
      uint64_t v15 = v9++;
      for (uint64_t i = (unsigned char *)(v12 + v14 + 2); ; i += 3)
      {
        uint64_t v17 = *(int *)(v11 + 4 * v15);
        if (*(_WORD *)(v7 + 2 * v17)) {
          break;
        }
        if (arith_decode(a1, i - 1))
        {
          int v18 = (__int16 *)(v7 + 2 * v17);
          int v21 = arith_decode(a1, (unsigned char *)(v4 + 336));
          __int16 v20 = v24;
          if (v21) {
            __int16 v20 = -(__int16)v24;
          }
          goto LABEL_23;
        }
        ++v15;
        ++v9;
        if (v15 >= *(int *)(a1 + 544))
        {
          uint64_t v22 = *(void *)a1;
          *(_DWORD *)(v22 + 40) = 117;
          (*(void (**)(uint64_t, uint64_t))(v22 + 8))(a1, 0xFFFFFFFFLL);
          *(_DWORD *)(v4 + 40) = -1;
          return 1;
        }
      }
      if (!arith_decode(a1, i)) {
        continue;
      }
      int v18 = (__int16 *)(v7 + 2 * v17);
      int v19 = *v18;
      __int16 v20 = v19 < 0 ? v19 - v24 : v19 + v24;
LABEL_23:
      *int v18 = v20;
    }
    while (*(_DWORD *)(a1 + 544) > v9);
  }
  return 1;
}

uint64_t decode_mcu_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    int v5 = *(_DWORD *)(v4 + 76);
    if (!v5)
    {
      process_restart_0((uint64_t *)a1);
      int v5 = *(_DWORD *)(v4 + 76);
    }
    *(_DWORD *)(v4 + 76) = v5 - 1;
  }
  if (*(_DWORD *)(v4 + 40) == -1 || *(int *)(a1 + 496) < 1) {
    return 1;
  }
  uint64_t v6 = 0;
  uint64_t v49 = *(void *)(a1 + 560);
  uint64_t v48 = a2;
  while (1)
  {
    long long v50 = *(_WORD **)(a2 + 8 * v6);
    uint64_t v7 = *(int *)(a1 + 4 * v6 + 500);
    uint64_t v8 = *(void *)(a1 + 8 * v7 + 456);
    uint64_t v9 = *(int *)(v8 + 20);
    uint64_t v10 = v4 + 8 * v9;
    uint64_t v13 = *(void *)(v10 + 80);
    uint64_t v12 = (void *)(v10 + 80);
    uint64_t v11 = v13;
    uint64_t v14 = v4 + 4 * v7;
    uint64_t v16 = *(int *)(v14 + 60);
    uint64_t v15 = (int *)(v14 + 60);
    uint64_t v17 = v11 + v16;
    if (arith_decode(a1, (unsigned char *)(v11 + v16))) {
      break;
    }
    *uint64_t v15 = 0;
    int v21 = *(_DWORD *)(v4 + 4 * v7 + 44);
LABEL_30:
    *long long v50 = v21;
    if (*(_DWORD *)(a1 + 568))
    {
      int v29 = 0;
      uint64_t v30 = *(int *)(v8 + 24);
      size_t v31 = (uint64_t *)(v4 + 8 * v30 + 208);
      uint64_t v46 = (unsigned __int8 *)(a1 + v30 + 356);
      do
      {
        uint64_t v32 = *v31;
        if (arith_decode(a1, (unsigned char *)(*v31 + 3 * v29))) {
          break;
        }
        int v33 = (unsigned char *)(v32 + 3 * v29 + 2);
        unsigned int v34 = (int *)(v49 + 4 * (v29 + 1));
        while (1)
        {
          int v35 = v29 + 1;
          if (arith_decode(a1, v33 - 1)) {
            break;
          }
          v33 += 3;
          ++v34;
          ++v29;
          if (v35 >= *(_DWORD *)(a1 + 568)) {
            goto LABEL_58;
          }
        }
        int v47 = arith_decode(a1, (unsigned char *)(v4 + 336));
        if (arith_decode(a1, v33))
        {
          if (arith_decode(a1, v33))
          {
            uint64_t v36 = *v31;
            uint64_t v37 = 217;
            if (v29 < *v46) {
              uint64_t v37 = 189;
            }
            CGRect v38 = (unsigned char *)(v36 + v37 + 14);
            int v39 = 2;
            if (arith_decode(a1, (unsigned char *)(v36 + v37)))
            {
              while (1)
              {
                v39 *= 2;
                if (v39 == 0x8000) {
                  goto LABEL_58;
                }
                int v40 = arith_decode(a1, v38 - 13);
                ++v38;
                if (!v40)
                {
                  if (!v39) {
                    goto LABEL_53;
                  }
                  break;
                }
              }
            }
            int v41 = v39;
            do
            {
              if (arith_decode(a1, v38)) {
                int v42 = v41 >> 1;
              }
              else {
                LOWORD(v42) = 0;
              }
              LOWORD(v39) = v42 | v39;
              BOOL v26 = v41 > 3;
              v41 >>= 1;
            }
            while (v26);
          }
          else
          {
            LOWORD(v39) = 1;
          }
        }
        else
        {
          LOWORD(v39) = 0;
        }
LABEL_53:
        __int16 v43 = ~(_WORD)v39;
        if (!v47) {
          __int16 v43 = v39 + 1;
        }
        v50[*v34] = v43;
        int v29 = v35;
      }
      while (v35 < *(_DWORD *)(a1 + 568));
    }
    ++v6;
    a2 = v48;
    if (v6 >= *(int *)(a1 + 496)) {
      return 1;
    }
  }
  unsigned int v18 = arith_decode(a1, (unsigned char *)(v17 + 1));
  int v19 = (unsigned char *)(v17 + v18 + 2);
  if (!arith_decode(a1, v19))
  {
    int v20 = 0;
    goto LABEL_16;
  }
  int v19 = (unsigned char *)(*v12 + 20);
  int v20 = 1;
  if (!arith_decode(a1, v19))
  {
LABEL_16:
    if (v20 >= (int)((unint64_t)(1 << *(unsigned char *)(a1 + v9 + 324)) >> 1))
    {
      int v22 = 4 * v18 + 4;
      if (v20 > (int)((unint64_t)(1 << *(unsigned char *)(a1 + v9 + 340)) >> 1)) {
        int v22 = 4 * v18 + 12;
      }
    }
    else
    {
      int v22 = 0;
    }
    *uint64_t v15 = v22;
    if (v20 >= 2)
    {
      int v24 = v19 + 14;
      int v23 = v20;
      do
      {
        if (arith_decode(a1, v24)) {
          int v25 = v20 >> 1;
        }
        else {
          int v25 = 0;
        }
        v23 |= v25;
        BOOL v26 = v20 > 3;
        v20 >>= 1;
      }
      while (v26);
    }
    else
    {
      int v23 = v20;
    }
    int v27 = ~v23;
    if (!v18) {
      int v27 = v23 + 1;
    }
    uint64_t v28 = v4 + 4 * v7;
    int v21 = *(_DWORD *)(v28 + 44) + v27;
    *(_DWORD *)(v28 + 44) = v21;
    goto LABEL_30;
  }
  while (1)
  {
    v20 *= 2;
    if (v20 == 0x8000) {
      break;
    }
    if (!arith_decode(a1, ++v19)) {
      goto LABEL_16;
    }
  }
LABEL_58:
  uint64_t v44 = *(void *)a1;
  *(_DWORD *)(v44 + 40) = 117;
  (*(void (**)(uint64_t, uint64_t))(v44 + 8))(a1, 0xFFFFFFFFLL);
  *(_DWORD *)(v4 + 40) = -1;
  return 1;
}

uint64_t process_restart_0(uint64_t *a1)
{
  uint64_t v2 = a1[78];
  uint64_t result = (*(uint64_t (**)(void))(a1[77] + 16))();
  if (!result)
  {
    uint64_t v4 = *a1;
    *(_DWORD *)(v4 + 40) = 25;
    uint64_t result = (*(uint64_t (**)(uint64_t *))v4)(a1);
  }
  if (*((int *)a1 + 112) >= 1)
  {
    for (uint64_t i = 0; i < *((int *)a1 + 112); ++i)
    {
      uint64_t v6 = a1[i + 57];
      if (!*((_DWORD *)a1 + 79)) {
        goto LABEL_8;
      }
      if (*((_DWORD *)a1 + 135)) {
        goto LABEL_10;
      }
      if (!*((_DWORD *)a1 + 137))
      {
LABEL_8:
        uint64_t v7 = *(_OWORD **)(v2 + 8 * *(int *)(v6 + 20) + 80);
        v7[2] = 0uLL;
        void v7[3] = 0uLL;
        *uint64_t v7 = 0uLL;
        v7[1] = 0uLL;
        uint64_t v8 = v2 + 4 * i;
        *(_DWORD *)(v8 + 44) = 0;
        *(_DWORD *)(v8 + 60) = 0;
        if (!*((_DWORD *)a1 + 79))
        {
          if (!*((_DWORD *)a1 + 142)) {
            continue;
          }
LABEL_10:
          uint64_t v9 = *(_OWORD **)(v2 + 8 * *(int *)(v6 + 24) + 208);
          v9[14] = 0uLL;
          v9[15] = 0uLL;
          v9[12] = 0uLL;
          v9[13] = 0uLL;
          v9[10] = 0uLL;
          v9[11] = 0uLL;
          v9[8] = 0uLL;
          v9[9] = 0uLL;
          v9[6] = 0uLL;
          v9[7] = 0uLL;
          v9[4] = 0uLL;
          v9[5] = 0uLL;
          v9[2] = 0uLL;
          v9[3] = 0uLL;
          *uint64_t v9 = 0uLL;
          v9[1] = 0uLL;
          continue;
        }
        if (*((_DWORD *)a1 + 135)) {
          goto LABEL_10;
        }
      }
    }
  }
  *(void *)(v2 + 24) = 0;
  *(void *)(v2 + 32) = 0;
  *(_DWORD *)(v2 + 40) = -16;
  *(_DWORD *)(v2 + 76) = *((_DWORD *)a1 + 93);
  return result;
}

uint64_t arith_decode(uint64_t a1, unsigned char *a2)
{
  uint64_t v3 = *(void *)(a1 + 624);
  uint64_t v4 = *(void *)(v3 + 32);
  if (v4 >= 0x8000)
  {
    int v6 = *(_DWORD *)(v3 + 40);
  }
  else
  {
    int v6 = *(_DWORD *)(v3 + 40);
    do
    {
      int v7 = v6--;
      *(_DWORD *)(v3 + 40) = v6;
      if (v7 <= 0)
      {
        if (*(_DWORD *)(a1 + 572))
        {
          unsigned int byte = 0;
        }
        else
        {
          unsigned int byte = get_byte((uint64_t *)a1);
          if (byte == 255)
          {
            do
              int v9 = get_byte((uint64_t *)a1);
            while (v9 == 255);
            if ((_BYTE)v9)
            {
              int v10 = v9;
              unsigned int byte = 0;
              *(_DWORD *)(a1 + 572) = v10;
            }
            else
            {
              unsigned int byte = 255;
            }
          }
          int v6 = *(_DWORD *)(v3 + 40);
        }
        *(void *)(v3 + 24) = byte | (*(void *)(v3 + 24) << 8);
        *(_DWORD *)(v3 + 40) = v6 + 8;
        int v13 = v6 + 9;
        BOOL v11 = v6 == -9;
        BOOL v12 = v6 <= -9;
        v6 += 8;
        if (v12)
        {
          *(_DWORD *)(v3 + 40) = v13;
          int v6 = v13;
          if (v11)
          {
            int v6 = 0;
            *(void *)(v3 + 32) = 0x8000;
          }
        }
      }
      uint64_t v4 = 2 * *(void *)(v3 + 32);
      *(void *)(v3 + 32) = v4;
    }
    while (v4 < 0x8000);
  }
  unsigned int v14 = *a2;
  uint64_t v15 = jpeg_aritab[v14 & 0x7F];
  uint64_t v16 = v15 >> 16;
  uint64_t v17 = v4 - (v15 >> 16);
  *(void *)(v3 + 32) = v17;
  uint64_t v18 = v17 << v6;
  uint64_t v19 = *(void *)(v3 + 24);
  BOOL v20 = __OFSUB__(v19, v18);
  uint64_t v21 = v19 - v18;
  if (v21 < 0 == v20)
  {
    *(void *)(v3 + 24) = v21;
    *(void *)(v3 + 32) = v16;
    char v22 = v14 & 0x80;
    if (v17 >= v16) {
      goto LABEL_26;
    }
LABEL_24:
    *a2 = v22 ^ BYTE1(v15);
    return v14 >> 7;
  }
  if (v17 < 0x8000)
  {
    char v22 = v14 & 0x80;
    if (v17 < v16)
    {
LABEL_26:
      *a2 = v22 ^ v15;
      v14 ^= 0x80u;
      return v14 >> 7;
    }
    goto LABEL_24;
  }
  return v14 >> 7;
}

uint64_t get_byte(uint64_t *a1)
{
  uint64_t v1 = (unsigned __int8 **)a1[5];
  if (!v1[1] && !((unsigned int (*)(void))v1[3])())
  {
    uint64_t v3 = *a1;
    *(_DWORD *)(v3 + 40) = 25;
    (*(void (**)(uint64_t *))v3)(a1);
  }
  uint64_t v4 = *v1;
  uint64_t v5 = (uint64_t)(v1[1] - 1);
  ++*v1;
  v1[1] = (unsigned __int8 *)v5;
  return *v4;
}

void IIO_WriterHandler::~IIO_WriterHandler(IIO_WriterHandler *this)
{
  *(void *)this = &unk_1ED4E4150;
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + 2) = v2;
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1ED4E4150;
  uint64_t v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + 2) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x18C11C0E0);
}

CFMutableArrayRef IIO_WriterHandler::copyImageFormats(IIO_WriterHandler *this, const __CFString *a2)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  for (uint64_t i = (IIO_Writer **)*((void *)this + 1); i != *((IIO_Writer ***)this + 2); ++i)
  {
    CFStringRef v6 = (const __CFString *)IIO_Writer::utType(*i);
    if (CFEqual(v6, a2))
    {
      (*(void (**)(IIO_Writer *, CFMutableArrayRef))(*(void *)*i + 32))(*i, Mutable);
      return Mutable;
    }
  }
  return Mutable;
}

void png_set_cHRM_fixed(void (**a1)(void), uint64_t a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10)
{
  if (a1 && a2)
  {
    v12[0] = a5;
    v12[1] = a6;
    v12[2] = a7;
    v12[3] = a8;
    v12[4] = a9;
    v12[5] = a10;
    v12[6] = a3;
    v12[7] = a4;
    if (png_colorspace_set_chromaticities(a1, a2 + 52, v12, 2)) {
      *(_WORD *)(a2 + 126) |= 0x10u;
    }
    png_colorspace_sync_info((uint64_t)a1, a2);
  }
}

void _cg_png_set_cHRM(void (**a1)(void), uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  int v19 = png_fixed(a1, (uint64_t)"cHRM White X", a3);
  int v20 = png_fixed(a1, (uint64_t)"cHRM White Y", a4);
  int v21 = png_fixed(a1, (uint64_t)"cHRM Red X", a5);
  int v22 = png_fixed(a1, (uint64_t)"cHRM Red Y", a6);
  int v23 = png_fixed(a1, (uint64_t)"cHRM Green X", a7);
  int v24 = png_fixed(a1, (uint64_t)"cHRM Green Y", a8);
  int v25 = png_fixed(a1, (uint64_t)"cHRM Blue X", a9);
  int v26 = png_fixed(a1, (uint64_t)"cHRM Blue Y", a10);
  png_set_cHRM_fixed(a1, a2, v19, v20, v21, v22, v23, v24, v25, v26);
}

void png_set_gAMA_fixed(uint64_t a1, uint64_t a2, int a3)
{
  if (a1 && a2)
  {
    png_colorspace_set_gamma(a1, a2 + 52, a3);
    png_colorspace_sync_info(a1, a2);
  }
}

void _cg_png_set_gAMA(void (**a1)(void), uint64_t a2, double a3)
{
  int v5 = png_fixed(a1, (uint64_t)"png_set_gAMA", a3);

  png_set_gAMA_fixed((uint64_t)a1, a2, v5);
}

void *png_set_hIST(void *result, uint64_t a2, const void *a3)
{
  if (!result || !a2) {
    return result;
  }
  uint64_t v4 = result;
  if (*(unsigned __int16 *)(a2 + 32) - 257 <= 0xFFFFFEFF)
  {
    int v5 = "Invalid palette size, hIST allocation skipped";
LABEL_11:
    return (void *)png_warning((uint64_t)v4, v5);
  }
  png_free_data((uint64_t)result, a2, 8u, 0);
  uint64_t result = png_malloc_warn(v4, 0x200uLL);
  *(void *)(a2 + 256) = result;
  if (!result)
  {
    int v5 = "Insufficient memory for hIST chunk data";
    goto LABEL_11;
  }
  if (*(_WORD *)(a2 + 32)) {
    uint64_t result = memcpy(result, a3, 2 * *(unsigned __int16 *)(a2 + 32));
  }
  *(_DWORD *)(a2 + 300) |= 8u;
  *(_DWORD *)(a2 + 8) |= 0x40u;
  return result;
}

uint64_t png_set_oFFs(uint64_t result, uint64_t a2, int a3, int a4, char a5)
{
  if (result)
  {
    if (a2)
    {
      *(_DWORD *)(a2 + 212) = a3;
      *(_DWORD *)(a2 + 216) = a4;
      *(unsigned char *)(a2 + 220) = a5;
      *(_DWORD *)(a2 + 8) |= 0x100u;
    }
  }
  return result;
}

void png_set_pCAL_sized(void *a1, uint64_t a2, char *__s, int a4, int a5, unsigned int a6, unsigned int a7, const char *a8, const char **a9)
{
  if (!a1) {
    return;
  }
  if (!a2) {
    return;
  }
  if (!__s) {
    return;
  }
  if (!a8) {
    return;
  }
  uint64_t v17 = a9;
  if ((int)a7 >= 1 && !a9) {
    return;
  }
  size_t v18 = strlen(__s);
  if (a6 >= 4)
  {
    int v19 = "Invalid pCAL equation type";
LABEL_27:
    png_chunk_report((uint64_t)a1, v19, 1);
    return;
  }
  if (a7 > 0xFF)
  {
    int v19 = "Invalid pCAL parameter count";
    goto LABEL_27;
  }
  size_t v33 = v18;
  int v32 = a5;
  if (a7)
  {
    uint64_t v20 = a7;
    while (*v17)
    {
      size_t v21 = strlen(*v17);
      if (!png_check_fp_string((uint64_t)*v17, v21)) {
        break;
      }
      ++v17;
      if (!--v20) {
        goto LABEL_17;
      }
    }
    int v19 = "Invalid format for pCAL parameter";
    goto LABEL_27;
  }
LABEL_17:
  int v22 = png_malloc_warn(a1, v33 + 1);
  *(void *)(a2 + 264) = v22;
  if (!v22)
  {
    int v19 = "Insufficient memory for pCAL purpose";
    goto LABEL_27;
  }
  memcpy(v22, __s, v33 + 1);
  *(_DWORD *)(a2 + 300) |= 0x80u;
  *(_DWORD *)(a2 + 272) = a4;
  *(_DWORD *)(a2 + 276) = v32;
  *(unsigned char *)(a2 + 296) = a6;
  size_t v23 = strlen(a8) + 1;
  int v24 = png_malloc_warn(a1, v23);
  *(void *)(a2 + 280) = v24;
  if (v24)
  {
    memcpy(v24, a8, v23);
    int v25 = png_malloc_warn(a1, 8 * a7);
    *(void *)(a2 + 288) = v25;
    *(unsigned char *)(a2 + 297) = a7;
    if (v25)
    {
      bzero(v25, 8 * a7);
      if ((int)a7 < 1)
      {
LABEL_24:
        *(_DWORD *)(a2 + 8) |= 0x400u;
        return;
      }
      unint64_t v26 = 0;
      uint64_t v27 = 8 * a7;
      while (1)
      {
        size_t v28 = strlen(a9[v26 / 8]) + 1;
        int v29 = png_malloc_warn(a1, v28);
        if (!v29) {
          break;
        }
        uint64_t v30 = v29;
        memcpy(v29, a9[v26 / 8], v28);
        *(void *)(*(void *)(a2 + 288) + v26) = v30;
        v26 += 8;
        if (v27 == v26) {
          goto LABEL_24;
        }
      }
      size_t v31 = "Insufficient memory for pCAL parameter";
    }
    else
    {
      size_t v31 = "Insufficient memory for pCAL params";
    }
  }
  else
  {
    size_t v31 = "Insufficient memory for pCAL units";
  }

  png_warning((uint64_t)a1, v31);
}

void (**png_set_sCAL_sized(void (**result)(void), uint64_t a2, int a3, char *__s, const char *a5))(void)
{
  if (!result || !a2) {
    return result;
  }
  char v6 = a3;
  int v7 = result;
  if ((a3 - 3) <= 0xFFFFFFFD)
  {
    uint64_t v16 = "Invalid sCAL unit";
LABEL_22:
    _cg_png_error(v7, v16);
  }
  if (!__s
    || (size_t v10 = strlen(__s)) == 0
    || *__s == 45
    || (size_t v11 = v10, !png_check_fp_string((uint64_t)__s, v10)))
  {
    uint64_t v16 = "Invalid sCAL width";
    goto LABEL_22;
  }
  if (!a5 || (v12 = strlen(a5)) == 0 || *a5 == 45 || (size_t v13 = v12, !png_check_fp_string((uint64_t)a5, v12)))
  {
    uint64_t v16 = "Invalid sCAL height";
    goto LABEL_22;
  }
  *(unsigned char *)(a2 + 332) = v6;
  unsigned int v14 = png_malloc_warn(v7, v11 + 1);
  *(void *)(a2 + 336) = v14;
  if (v14)
  {
    memcpy(v14, __s, v11 + 1);
    uint64_t v15 = png_malloc_warn(v7, v13 + 1);
    *(void *)(a2 + 344) = v15;
    if (v15)
    {
      uint64_t result = (void (**)(void))memcpy(v15, a5, v13 + 1);
      *(_DWORD *)(a2 + 300) |= 0x100u;
      *(_DWORD *)(a2 + 8) |= 0x4000u;
      return result;
    }
    png_free((uint64_t)v7, *(void **)(a2 + 336));
    *(void *)(a2 + 336) = 0;
  }

  return (void (**)(void))png_warning((uint64_t)v7, "Memory allocation failed while processing sCAL");
}

void (**_cg_png_set_PLTE(void (**result)(void), uint64_t a2, const void *a3, unsigned int a4))(void)
{
  if (!result || !a2) {
    return result;
  }
  int v7 = result;
  if (*(unsigned char *)(a2 + 37) == 3)
  {
    if ((a4 & 0x80000000) != 0 || 1 << *(unsigned char *)(a2 + 36) < (int)a4)
    {
      uint64_t v8 = "Invalid palette length";
      goto LABEL_20;
    }
  }
  else if (a4 > 0x100)
  {
    return (void (**)(void))png_warning((uint64_t)result, "Invalid palette length");
  }
  if (!a3 && a4 || !a4 && ((_BYTE)result[95] & 1) == 0)
  {
    uint64_t v8 = "Invalid palette";
LABEL_20:
    _cg_png_error(result, v8);
  }
  png_free_data((uint64_t)result, a2, 0x1000u, 0);
  uint64_t result = png_calloc(v7, 0x300uLL);
  int v9 = result;
  v7[46] = (void (*)(void))result;
  if (a4) {
    uint64_t result = (void (**)(void))memcpy(result, a3, 3 * a4);
  }
  *(void *)(a2 + 24) = v9;
  *((_WORD *)v7 + 188) = a4;
  *(_WORD *)(a2 + 32) = a4;
  *(_DWORD *)(a2 + 300) |= 0x1000u;
  *(_DWORD *)(a2 + 8) |= 8u;
  return result;
}

uint64_t png_set_sBIT(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (result && a2)
  {
    if (a3)
    {
      *(_DWORD *)(a2 + 176) = *(_DWORD *)a3;
      *(unsigned char *)(a2 + 180) = *(unsigned char *)(a3 + 4);
      *(_DWORD *)(a2 + 8) |= 2u;
    }
  }
  return result;
}

uint64_t _cg_png_set_text(void (**a1)(void), uint64_t a2, uint64_t a3, signed int a4)
{
  uint64_t result = png_set_text_2(a1, a2, a3, a4);
  if (result) {
    _cg_png_error(a1, "Insufficient memory to store text");
  }
  return result;
}

void _cg_png_set_tRNS(uint64_t a1, uint64_t a2, const void *a3, unsigned int a4, uint64_t a5)
{
  if (a1 && a2)
  {
    if (a3)
    {
      png_free_data(a1, a2, 0x2000u, 0);
      if (a4 - 1 >= 0x100)
      {
        size_t v10 = *(void (***)(void))(a2 + 184);
      }
      else
      {
        size_t v10 = png_malloc((void (**)(void))a1, 0x100uLL);
        *(void *)(a2 + 184) = v10;
        memcpy(v10, a3, a4);
        *(_DWORD *)(a2 + 300) |= 0x2000u;
        *(_DWORD *)(a2 + 8) |= 0x10u;
      }
      *(void *)(a1 + 520) = v10;
    }
    if (a5)
    {
      unsigned int v11 = *(unsigned __int8 *)(a2 + 36);
      if (v11 <= 0xF)
      {
        unsigned int v12 = ~(-1 << v11);
        if (*(unsigned char *)(a2 + 37) == 2)
        {
          if (*(unsigned __int16 *)(a5 + 2) > v12 || *(unsigned __int16 *)(a5 + 4) > v12) {
            goto LABEL_19;
          }
          unsigned int v13 = *(unsigned __int16 *)(a5 + 6);
        }
        else
        {
          if (*(unsigned char *)(a2 + 37)) {
            goto LABEL_20;
          }
          unsigned int v13 = *(unsigned __int16 *)(a5 + 8);
        }
        if (v13 > v12) {
LABEL_19:
        }
          png_warning(a1, "tRNS chunk has out-of-range samples for bit_depth");
      }
LABEL_20:
      *(void *)(a2 + 192) = *(void *)a5;
      *(_WORD *)(a2 + 200) = *(_WORD *)(a5 + 8);
      if (a4 <= 1) {
        __int16 v14 = 1;
      }
      else {
        __int16 v14 = a4;
      }
      *(_WORD *)(a2 + 34) = v14;
      goto LABEL_24;
    }
    *(_WORD *)(a2 + 34) = a4;
    if (a4)
    {
LABEL_24:
      *(_DWORD *)(a2 + 300) |= 0x2000u;
      *(_DWORD *)(a2 + 8) |= 0x10u;
    }
  }
}

void png_set_sPLT(void (**a1)(void), uint64_t a2, uint64_t a3, signed int a4)
{
  if (!a3) {
    return;
  }
  if (!a1) {
    return;
  }
  if (!a2) {
    return;
  }
  int v6 = a4;
  if (a4 < 1) {
    return;
  }
  uint64_t v7 = a3;
  signed int v8 = *(_DWORD *)(a2 + 328);
  int v9 = png_realloc_array(a1, *(const void **)(a2 + 320), v8, a4, 0x28uLL);
  if (!v9)
  {
    png_chunk_report((uint64_t)a1, "too many sPLT chunks", 1);
    return;
  }
  size_t v10 = v9;
  png_free((uint64_t)a1, *(void **)(a2 + 320));
  *(void *)(a2 + 320) = v10;
  *(_DWORD *)(a2 + 328) = v8 + v6;
  *(_DWORD *)(a2 + 300) |= 0x20u;
  unsigned int v11 = &v10[40 * v8];
  while (1)
  {
    unsigned int v12 = *(const char **)v7;
    if (!*(void *)v7 || !*(void *)(v7 + 24))
    {
      png_app_error((uint64_t)a1, "png_set_sPLT: invalid sPLT");
      goto LABEL_13;
    }
    v11[16] = *(unsigned char *)(v7 + 16);
    size_t v13 = strlen(v12) + 1;
    __int16 v14 = png_malloc_base((uint64_t)a1, v13);
    *(void *)unsigned int v11 = v14;
    *((void *)v11 + 1) = v13;
    if (!v14) {
      goto LABEL_19;
    }
    memcpy(v14, *(const void **)v7, v13);
    uint64_t v15 = png_malloc_array(a1, *(_DWORD *)(v7 + 32), 0xAuLL);
    *((void *)v11 + 3) = v15;
    uint64_t v16 = *(unsigned int *)(v7 + 32);
    *((_DWORD *)v11 + 8) = v16;
    if (!v15) {
      break;
    }
    memcpy(v15, *(const void **)(v7 + 24), 10 * v16);
    *(_DWORD *)(a2 + 8) |= 0x2000u;
    ++v8;
    v11 += 40;
    v7 += 40;
LABEL_13:
    if (!--v6) {
      goto LABEL_21;
    }
  }
  png_free((uint64_t)a1, *(void **)v11);
  *(void *)unsigned int v11 = 0;
  *((void *)v11 + 1) = 0;
LABEL_19:
  if (v6 >= 1) {
    png_chunk_report((uint64_t)a1, "sPLT out of memory", 1);
  }
LABEL_21:
  *(_DWORD *)(a2 + 328) = v8;
}

uint64_t _cg_png_set_acTL(uint64_t a1, _DWORD *a2, int a3, int a4)
{
  if (a1 && a2)
  {
    if (a3)
    {
      if (a3 < 0)
      {
        int v5 = "Ignoring attempt to set acTL with num_frames > 2^31-1";
      }
      else
      {
        if ((a4 & 0x80000000) == 0)
        {
          a2[90] = a3;
          a2[91] = a4;
          a2[2] |= 0x20000u;
          return 1;
        }
        int v5 = "Ignoring attempt to set acTL with num_plays > 2^31-1";
      }
    }
    else
    {
      int v5 = "Ignoring attempt to set acTL with num_frames zero";
    }
  }
  else
  {
    int v5 = "Call to png_set_acTL() with NULL png_ptr or info_ptr ignored";
  }
  png_warning(a1, v5);
  return 0;
}

uint64_t png_set_next_frame_fcTL(uint64_t a1, uint64_t a2, int a3, int a4, int a5, int a6, __int16 a7, __int16 a8, unsigned __int8 a9, unsigned __int8 a10)
{
  if (a1 && a2)
  {
    char v18 = a10;
    png_ensure_fcTL_is_valid(a1, a3, a4, a5, a6, 0, 0, a9, a10);
    if (a10 == 1)
    {
      if ((*(unsigned char *)(a1 + 391) & 4) != 0 || _cg_png_get_valid(a1, a2, 0x10u))
      {
        char v18 = 1;
      }
      else
      {
        png_warning(a1, "PNG_BLEND_OP_OVER is meaningless and wasteful for opaque images, ignored");
        char v18 = 0;
      }
    }
    *(_DWORD *)(a2 + 368) = a3;
    *(_DWORD *)(a2 + 372) = a4;
    *(_DWORD *)(a2 + 376) = a5;
    *(_DWORD *)(a2 + 380) = a6;
    *(_WORD *)(a2 + 384) = a7;
    *(_WORD *)(a2 + 386) = a8;
    *(unsigned char *)(a2 + 388) = a9;
    *(unsigned char *)(a2 + 389) = v18;
    *(_DWORD *)(a2 + 8) |= 0x40000u;
    return 1;
  }
  else
  {
    png_warning(a1, "Call to png_set_fcTL() with NULL png_ptr or info_ptr ignored");
    return 0;
  }
}

uint64_t png_ensure_fcTL_is_valid(uint64_t result, int a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, unsigned int a8, unsigned __int8 a9)
{
  if (a2 <= 0) {
    _cg_png_error((void (**)(void))result, "invalid width in fcTL (> 2^31-1)");
  }
  if (a3 <= 0) {
    _cg_png_error((void (**)(void))result, "invalid height in fcTL (> 2^31-1)");
  }
  if (a4 < 0) {
    _cg_png_error((void (**)(void))result, "invalid x_offset in fcTL (> 2^31-1)");
  }
  if (a5 < 0) {
    _cg_png_error((void (**)(void))result, "invalid y_offset in fcTL (> 2^31-1)");
  }
  if ((a4 + a2) > *(_DWORD *)(result + 776) || (a5 + a3) > *(_DWORD *)(result + 780)) {
    _cg_png_error((void (**)(void))result, "dimensions of a frame are greater thanthe ones in IHDR");
  }
  if (a8 >= 3) {
    _cg_png_error((void (**)(void))result, "invalid dispose_op in fcTL");
  }
  if (a9 >= 2u) {
    _cg_png_error((void (**)(void))result, "invalid blend_op in fcTL");
  }
  return result;
}

uint64_t _cg_png_set_num_frames_read(uint64_t result, uint64_t a2, int a3)
{
  if (result) {
    *(_DWORD *)(result + 784) = a3;
  }
  return result;
}

uint64_t _cg_png_set_next_seq_num(uint64_t result, uint64_t a2, int a3)
{
  if (result) {
    *(_DWORD *)(result + 772) = a3;
  }
  return result;
}

void IIO_Writer_GIF::~IIO_Writer_GIF(IIO_Writer_GIF *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIO_Writer_GIF::write(IIO_Writer_GIF *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  GIFWritePlugin::GIFWritePlugin((GIFWritePlugin *)v5, a2, a3);
  uint64_t v3 = GIFWritePlugin::writeAll((GIFWritePlugin *)v5);
  GIFWritePlugin::~GIFWritePlugin((GIFWritePlugin *)v5);
  return v3;
}

void sub_18873D8CC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void PDFWritePlugin::PDFWritePlugin(PDFWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 1346651680);
  *uint64_t v3 = &unk_1ED4E2BF0;
  v3[6] = 0;
  v3[7] = 0;
  v3[5] = 0;
}

void PDFWritePlugin::~PDFWritePlugin(PDFWritePlugin *this, uint64_t a2, const char *a3)
{
  *(void *)this = &unk_1ED4E2BF0;
  uint64_t v4 = (const void *)*((void *)this + 6);
  if (v4) {
    CFRelease(v4);
  }
  int v5 = (const void *)*((void *)this + 7);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)*((void *)this + 5);
  if (v6) {
    CFRelease(v6);
  }

  _cg_jpeg_mem_term(this, a2, a3);
}

{
  uint64_t vars8;

  PDFWritePlugin::~PDFWritePlugin(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t PDFWritePlugin::writeOneImage(CGContextRef *this, CGImageRef image, IIODictionary *a3, IIODictionary *a4)
{
  mediaBox.origin.double x = 0.0;
  mediaBox.origin.double y = 0.0;
  if (this[6])
  {
    double Width = (double)CGImageGetWidth(image);
    mediaBox.size.double width = Width;
    size_t Height = CGImageGetHeight(image);
    double v10 = (double)Height;
    mediaBox.size.double height = (double)Height;
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    mediaBox.size: %g x %g\n", Width, (double)Height);
    }
    if (IIODictionary::containsKey(a3, @"DPIHeight"))
    {
      if (IIODictionary::containsKey(a3, @"DPIWidth"))
      {
        double FloatForKey = IIODictionary::getFloatForKey(a3, @"DPIWidth");
        float v12 = *(float *)&FloatForKey;
        double v13 = IIODictionary::getFloatForKey(a3, @"DPIHeight");
        double v14 = v10 / *(float *)&v13 * 72.0;
        mediaBox.size.double width = Width / v12 * 72.0;
        mediaBox.size.double height = v14;
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("    mediaBox.size: %g x %g\n", Width / v12 * 72.0, v14);
        }
      }
    }
    CGContextBeginPage(this[6], &mediaBox);
    memset(v20, 0, sizeof(v20));
    IIODictionary::IIODictionary((IIODictionary *)v20);
    if (IIODictionary::containsKey(a4, @"kCGImageDestinationLossyCompressionQuality"))
    {
      double v15 = IIODictionary::getFloatForKey(a4, @"kCGImageDestinationLossyCompressionQuality");
      if (*(float *)&v15 > 1.0 || *(float *)&v15 < 0.0) {
        float v17 = 0.8;
      }
      else {
        float v17 = *(float *)&v15;
      }
    }
    else
    {
      float v17 = 0.8;
    }
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    qualityVal: %g\n", v17);
    }
    IIONumber::IIONumber((IIONumber *)v19, v17);
    IIODictionary::setObjectForKey((uint64_t)v20, (uint64_t)v19, @"kCGImageDestinationLossyCompressionQuality");
    IIONumber::~IIONumber((IIONumber *)v19);
    if ((CGContextDrawImageWithOptions() & 1) == 0)
    {
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("    CGContextDrawImageWithOptions failed -- falling back to CGContextDrawImage\n");
      }
      CGContextDrawImage(this[6], mediaBox, image);
    }
    IIODictionary::~IIODictionary((IIODictionary *)v20);
    CGContextEndPage(this[6]);
  }
  else
  {
    _cg_jpeg_mem_term("writeOneImage", 52, "*** _context is NULL\n", a4);
  }
  return 0;
}

void sub_18873DC50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t PDFWritePlugin::writeOne(PDFWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

CGContextRef PDFWritePlugin::setup(PDFWritePlugin *this)
{
  long long v4 = xmmword_1ED4F0AE0;
  *((void *)this + 7) = 0;
  uint64_t v2 = CGDataConsumerCreate(*((void **)this + 2), (const CGDataConsumerCallbacks *)&v4);
  *((void *)this + 5) = v2;
  CGContextRef result = CGPDFContextCreate(v2, 0, *((CFDictionaryRef *)this + 7));
  *((void *)this + 6) = result;
  return result;
}

void PDFWritePlugin::done(CGContextRef *this)
{
}

__CFString *CopyProfileFromParams(IIODictionary *a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a1, @"kCGImageCopyFileSetProfile");
  uint64_t v2 = (__CFString *)ObjectForKey;
  if (!ObjectForKey) {
    return v2;
  }
  CFTypeID v3 = CFGetTypeID(ObjectForKey);
  if (v3 != CFDataGetTypeID())
  {
    CFTypeID v5 = CFGetTypeID(v2);
    if (v5 == CFStringGetTypeID())
    {
      bzero(buffer, 0x400uLL);
      if (CFStringGetCString(v2, buffer, 1024, 0x8000100u))
      {
        memset(&v12, 0, sizeof(v12));
        if (!stat(buffer, &v12))
        {
          st_size_t size = v12.st_size;
          if (v12.st_size)
          {
            CFMutableArrayRef Mutable = CFDataCreateMutable(0, v12.st_size);
            uint64_t v2 = (__CFString *)Mutable;
            if (Mutable)
            {
              CFDataSetLength(Mutable, st_size);
              int v8 = open(buffer, 0, 438);
              int v9 = v8;
              if ((gIIODebugFlags & 0x200000000000) != 0) {
                ImageIOLog(">>> %s: opening file [%d] '%s'\n", "CopyProfileFromParams", v8, buffer);
              }
              if (v9)
              {
                MutableBytePtr = CFDataGetMutableBytePtr((CFMutableDataRef)v2);
                read(v9, MutableBytePtr, st_size);
                if ((gIIODebugFlags & 0x200000000000) != 0) {
                  ImageIOLog("<<< %s: closing file [%d] '%s'\n", "CopyProfileFromParams", v9, buffer);
                }
                close(v9);
              }
            }
            return v2;
          }
        }
      }
    }
    else if (v2 == (__CFString *)*MEMORY[0x1E4F1D260])
    {
      unsigned int v11 = CFDataCreateMutable(0, 0);
      uint64_t v2 = (__CFString *)v11;
      if (v11) {
        CFDataSetLength(v11, 0);
      }
      return v2;
    }
    return 0;
  }

  return (__CFString *)CFRetain(v2);
}

CFDictionaryRef CopyOrientationFromParams(IIODictionary *a1, _WORD *a2)
{
  CFDictionaryRef result = IIODictionary::containsKey(a1, @"kCGImageCopyFileSetOrientation");
  if (result)
  {
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(a1, @"kCGImageCopyFileSetOrientation");
    if (a2)
    {
      if (Uint32ForKey - 9 >= 0xFFFFFFF8) {
        __int16 v6 = Uint32ForKey;
      }
      else {
        __int16 v6 = 0;
      }
      *a2 = v6;
      return (const __CFDictionary *)1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL CopyDateTimeFromParams(IIODictionary *a1, char *a2)
{
  if (!IIODictionary::containsKey(a1, @"kCGImageCopyFileSetDateTime")) {
    return 1;
  }
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a1, @"kCGImageCopyFileSetDateTime");
  IIOString::IIOString((IIOString *)v9, ObjectForKey);
  CFTypeID v5 = (const char *)IIOString::utf8String((IIOString *)v9);
  strncpy(a2, v5, 0x14uLL);
  IIOString::~IIOString((IIOString *)v9);
  if (strlen(a2) == 19)
  {
    for (uint64_t i = 0; i != 20; ++i)
    {
      int v7 = a2[i];
      if (v7 < a10000000000000[i] || v7 > a29991939295959[i]) {
        *a2 = 0;
      }
    }
    return *a2 != 0;
  }
  else
  {
    BOOL result = 0;
    *a2 = 0;
  }
  return result;
}

void sub_18873E070(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t copyIPTCDictFromParams(IIODictionary *a1)
{
  if (a1)
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a1, @"kCGImageCopyFileSetIPTC");
    if ((unint64_t)ObjectForKey | (unint64_t)IIODictionary::getObjectForKey(a1, @"kCGImageCopyFileSetKeywords"))operator new(); {
  }
    }
  return 0;
}

void sub_18873E248(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

__CFData *copyIPTCFromParams(IIODictionary *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = (IIODictionary *)copyIPTCDictFromParams(a1);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = (CFDictionaryRef *)v1;
  CFIndex v3 = SizeOfIPTCData(v1);
  if (v3)
  {
    CFIndex v4 = v3;
    CFMutableArrayRef Mutable = CFDataCreateMutable(0, v3);
    __int16 v6 = Mutable;
    if (Mutable)
    {
      CFDataSetLength(Mutable, v4);
      MutableBytePtr = CFDataGetMutableBytePtr(v6);
      if (MutableBytePtr) {
        WriteIPTCData(v2, MutableBytePtr);
      }
    }
  }
  else
  {
    __int16 v6 = 0;
  }
  (*((void (**)(CFDictionaryRef *))*v2 + 1))(v2);
  return v6;
}

void CopyJPEGXMPFromXMPParams(IIODictionary *a1, CFDataRef *a2, CFDataRef *a3, CFDataRef *a4)
{
  if (a2)
  {
    if (a3)
    {
      if (a4)
      {
        *a2 = 0;
        *a3 = 0;
        *a4 = 0;
        if (a1)
        {
          CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a1, @"kCGImageCopyFileSetXMP");
          if (ObjectForKey)
          {
            int v8 = ObjectForKey;
            CFTypeID v9 = CFGetTypeID(ObjectForKey);
            if (v9 == CFArrayGetTypeID())
            {
              double v10 = CGImageMetadataCreateFromMetadataProperties(v8);
              if (v10)
              {
                unsigned int v11 = v10;
                CGImageMetadataCreateSerializedDataAndExtendedData(v10, a2, a3, a4);
                CFRelease(v11);
              }
            }
            else
            {
              LogError("CopyJPEGXMPFromXMPParams", 721, "*** ERROR: value for kCGImageCopyFileSetXMP must be a CFArray");
            }
          }
        }
      }
    }
  }
}

uint64_t CopyXMPFromIPTCParams(IIODictionary *a1)
{
  if (a1 && copyIPTCDictFromParams(a1)) {
    operator new();
  }
  return 0;
}

void sub_18873E51C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

BOOL CGImageCopyFileWithParametersOLD(__CFString *a1, const __CFString *a2, IIODictionary *a3)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  *(_WORD *)int v75 = 0;
  BOOL v74 = 0;
  unsigned __int16 v73 = 0;
  BOOL v72 = 0;
  v76[0] = 0;
  v76[1] = 0;
  int v77 = 0;
  if (!a1) {
    return 0;
  }
  CFTypeID v6 = CFGetTypeID(a1);
  if (v6 != CFStringGetTypeID() && v6 != CFDataGetTypeID() && v6 != CGDataProviderGetTypeID()) {
    return 0;
  }
  if (a2)
  {
    CFTypeID v7 = CFGetTypeID(a2);
    if (v7 == CFStringGetTypeID())
    {
      CFIndex MaximumSizeOfFileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(a2);
      CFTypeID v9 = (std::__fs::filesystem::path *)malloc_type_malloc(MaximumSizeOfFileSystemRepresentation, 0x1AF28F41uLL);
      CFStringGetFileSystemRepresentation(a2, (char *)v9, MaximumSizeOfFileSystemRepresentation);
      goto LABEL_13;
    }
    return 0;
  }
  if (v6 != CFStringGetTypeID()) {
    return 0;
  }
  CFIndex v10 = CFStringGetMaximumSizeOfFileSystemRepresentation(a1);
  CFTypeID v9 = (std::__fs::filesystem::path *)malloc_type_malloc(v10 + 6, 0xDDB13DC9uLL);
  CFStringGetFileSystemRepresentation(a1, (char *)v9, v10);
  unsigned int v11 = strrchr((char *)v9, 47);
  if (v11) {
    stat v12 = v11 + 1;
  }
  else {
    stat v12 = (char *)v9;
  }
  size_t v13 = strlen(v12);
  memmove(v12 + 1, v12, v13 + 1);
  *stat v12 = 46;
  strcat((char *)v9, "-XXXX");
  mktemp((char *)v9);
LABEL_13:
  if (v6 == CFStringGetTypeID())
  {
    CFURLRef v14 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, kCFURLPOSIXPathStyle, 0);
    double v15 = (const void *)CGImageReadCreateWithURL(0, v14, (unsigned __int8 *)1, 0, 0);
    CFRelease(v14);
    if (!v15) {
      goto LABEL_131;
    }
LABEL_21:
    Source = (IIOImageRead *)CGImageSourceGetSource((uint64_t)v15);
    unint64_t Size = IIOImageRead::getSize(Source);
    if (Size < 0xC || (size_t v19 = Size, (v20 = CGImageReadSessionCreate((uint64_t)v15)) == 0))
    {
      CFRelease(v15);
      goto LABEL_131;
    }
    size_t v21 = (const void *)v20;
    int v22 = (IIOImageReadSession *)CGImageSourceGetSource(v20);
    FILE = IIOImageReadSession::createFILE(v22);
    if (!FILE)
    {
      BOOL v28 = 0;
LABEL_44:
      CFRelease(v15);
      CFRelease(v21);
      if (!v9) {
        return v28;
      }
      goto LABEL_45;
    }
    int v24 = FILE;
    uint8x8_t v68 = v21;
    int v25 = fopen((const char *)v9, "wb");
    if (!v25)
    {
      fclose(v24);
      BOOL v28 = 0;
LABEL_43:
      size_t v21 = v68;
      goto LABEL_44;
    }
    unint64_t v26 = v25;
    flockfile(v24);
    flockfile(v26);
    int v69 = CopyProfileFromParams(a3);
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a3, @"kCGImageCopyFileSetIPTC");
    CFTypeRef cf = copyIPTCFromParams(a3);
    CFDataRef v70 = (const __CFData *)CopyXMPFromIPTCParams(a3);
    CopyOrientationFromParams(a3, &v73);
    uint64_t v27 = (char *)v76;
    if (CopyDateTimeFromParams(a3, (char *)v76))
    {
      int v66 = LOBYTE(v76[0]);
      if (!LOBYTE(v76[0])) {
        uint64_t v27 = 0;
      }
      int __ptr = 0;
      if (fread(&__ptr, 1uLL, 4uLL, v24) == 4)
      {
        if (__ptr != 255 || BYTE1(__ptr) != 216 || BYTE2(__ptr) != 255)
        {
          BOOL v32 = __ptr == 77 && BYTE1(__ptr) == 77;
          char v33 = v32;
          if (v32 && !BYTE2(__ptr) && HIBYTE(__ptr) == 42) {
            goto LABEL_90;
          }
          BOOL v34 = __ptr == 73 && BYTE1(__ptr) == 73;
          BOOL v35 = v34;
          if (v34 && BYTE2(__ptr) == 42 && !HIBYTE(__ptr)) {
            goto LABEL_90;
          }
          BOOL v36 = BYTE2(__ptr) == 82 && v35;
          if (v36 && HIBYTE(__ptr) == 79) {
            goto LABEL_90;
          }
          if (BYTE2(__ptr) != 79) {
            char v33 = 0;
          }
          char v37 = HIBYTE(__ptr) == 82 ? v33 : 0;
          BOOL v38 = HIBYTE(__ptr) == 83 && v36;
          if ((v37 & 1) != 0
            || v38
            || ((BOOL v28 = 0, BYTE2(__ptr) == 85) ? (v39 = v35) : (v39 = 0), v39 && !HIBYTE(__ptr)))
          {
LABEL_90:
            uint64_t v63 = v27;
            int v29 = cf;
            if (!CopyTiffFile(v19, v24, v26, (unsigned __int8 *)&__ptr, (const __CFData *)v69, &v75[1], cf, ObjectForKey, v75, v70, &v74, v73, &v72, v63))
            {
              int v40 = v66;
              if ((!cf || v75[1]) && (!v70 || v75[0]) && (!v66 || v72) && v73 && !v74)
              {
                fclose(v26);
                int v41 = (UInt8 *)malloc_type_malloc(v19, 0x3BA9C566uLL);
                if (v41)
                {
                  int v42 = v41;
                  fseek(v24, 0, 0);
                  if (fread(v42, 1uLL, v19, v24) == v19)
                  {
                    CFAllocatorRef v43 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
                    CFDataRef v44 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v42, v19);
                    if (v44)
                    {
                      CFDataRef v45 = v44;
                      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v43, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                      if (Mutable)
                      {
                        int v47 = Mutable;
                        CFDictionaryRef v48 = IIODictionary::getObjectForKey(a3, @"kCGImageCopyFileSetOrientation");
                        CFDictionaryAddValue(v47, @"Orientation", v48);
                        EXIFJPEGuint64_t Data = CGImageCreateEXIFJPEGData(0, (uint64_t)v45, 0, v47);
                        if (EXIFJPEGData)
                        {
                          CFDataRef v50 = (const __CFData *)EXIFJPEGData;
                          int v51 = fopen((const char *)v9, "wb");
                          if (v51)
                          {
                            unsigned int v52 = v51;
                            BytePtr = (__CFDictionary *)CFDataGetBytePtr(v50);
                            size_t Length = CFDataGetLength(v50);
                            fwrite(BytePtr, Length, 1uLL, v52);
                            fclose(v52);
                            BOOL v74 = 1;
                            int v29 = cf;
                          }
                          CFRelease(v50);
                        }
                        CFRelease(v47);
                      }
                      CFRelease(v45);
                    }
                  }
                  free(v42);
                }
                unint64_t v26 = 0;
                int v40 = v66;
              }
              CFDataRef v31 = v70;
              if (v29 && !v75[1] || v70 && !v75[0] || v73 && !v74)
              {
                BOOL v28 = 0;
              }
              else
              {
                if (v40) {
                  BOOL v54 = !v72;
                }
                else {
                  BOOL v54 = 0;
                }
                BOOL v28 = !v54;
              }
              uint64_t v30 = v69;
              if (!v69) {
                goto LABEL_37;
              }
              goto LABEL_36;
            }
            BOOL v28 = 0;
LABEL_35:
            uint64_t v30 = v69;
            CFDataRef v31 = v70;
            if (!v69)
            {
LABEL_37:
              if (v31) {
                CFRelease(v31);
              }
              if (v29) {
                CFRelease(v29);
              }
              fclose(v24);
              if (v26) {
                fclose(v26);
              }
              goto LABEL_43;
            }
LABEL_36:
            CFRelease(v30);
            goto LABEL_37;
          }
LABEL_34:
          int v29 = cf;
          goto LABEL_35;
        }
        LogError("CGImageCopyFileWithParametersOLD", 1571, " ERROR: CGImageCopyFileWithParametersOLD - skipping 'JPEG' case\n");
      }
    }
    BOOL v28 = 0;
    goto LABEL_34;
  }
  if (v6 == CFDataGetTypeID())
  {
    uint64_t v16 = CGImageReadCreateWithData(0, (IIOImageRead *)a1, (__CFData *)1);
  }
  else
  {
    if (v6 != CGDataProviderGetTypeID()) {
      goto LABEL_131;
    }
    uint64_t v16 = CGImageReadCreateWithProvider(0, (IIOImageRead *)a1, (CGDataProvider *)1);
  }
  double v15 = (const void *)v16;
  if (v16) {
    goto LABEL_21;
  }
LABEL_131:
  BOOL v28 = 0;
  if (!v9) {
    return v28;
  }
LABEL_45:
  if (v28)
  {
    if (a2)
    {
      BOOL v28 = 1;
    }
    else
    {
      CFIndex v55 = CFStringGetMaximumSizeOfFileSystemRepresentation(a1);
      int v56 = (std::__fs::filesystem::path *)malloc_type_malloc(v55, 0xA2160716uLL);
      CFStringGetFileSystemRepresentation(a1, (char *)v56, v55);
      rename(v9, v56, v57);
      BOOL v28 = v58 == 0;
      if (v58)
      {
        unint64_t v59 = __error();
        int v60 = strerror(*v59);
        int v61 = __error();
        LogError("CGImageCopyFileWithParametersOLD", 1701, "*** ImageIO: rename (\"%s\" to \"%s\") failed: '%s' (%d)\n", (const char *)v9, (const char *)v56, v60, *v61);
        unlink((const char *)v9);
      }
      free(v56);
    }
  }
  else
  {
    unlink((const char *)v9);
    BOOL v28 = 0;
  }
  free(v9);
  return v28;
}

uint64_t CopyTiffFile(uint64_t a1, __sFILE *a2, __sFILE *a3, unsigned __int8 *a4, const __CFData *a5, BOOL *a6, const __CFData *a7, const __CFDictionary *a8, BOOL *a9, const __CFData *a10, BOOL *a11, unsigned __int16 a12, BOOL *a13, char *a14)
{
  MEMORY[0x1F4188790](a1, a2);
  CFDictionaryRef v216 = v15;
  CFDataRef v16 = v14;
  char v18 = v17;
  CFDataRef v20 = v19;
  int v22 = v21;
  int v24 = v23;
  unint64_t v26 = v25;
  unint64_t v220 = v27;
  uint64_t v228 = *MEMORY[0x1E4F143B8];
  int v28 = *v21;
  BOOL v222 = v28 == 77;
  if (v14)
  {
    int Length = CFDataGetLength(v14);
    if (a10) {
      goto LABEL_3;
    }
LABEL_6:
    signed int v29 = 0;
    if (v20) {
      goto LABEL_4;
    }
    goto LABEL_7;
  }
  int Length = 0;
  if (!a10) {
    goto LABEL_6;
  }
LABEL_3:
  signed int v29 = CFDataGetLength(a10);
  if (v20)
  {
LABEL_4:
    signed int v30 = CFDataGetLength(v20);
    goto LABEL_8;
  }
LABEL_7:
  signed int v30 = 0;
LABEL_8:
  if (Length)
  {
    BytePtr = CFDataGetBytePtr(v16);
    if (v29) {
      goto LABEL_10;
    }
LABEL_13:
    CFDataRef v31 = 0;
    if (v30) {
      goto LABEL_11;
    }
LABEL_14:
    BOOL v32 = 0;
    goto LABEL_15;
  }
  BytePtr = 0;
  if (!v29) {
    goto LABEL_13;
  }
LABEL_10:
  CFDataRef v31 = CFDataGetBytePtr(a10);
  if (!v30) {
    goto LABEL_14;
  }
LABEL_11:
  BOOL v32 = CFDataGetBytePtr(v20);
LABEL_15:
  uint64_t v225 = 0;
  long long v223 = 0u;
  long long v224 = 0u;
  if (fwrite(v22, 1uLL, 4uLL, v24) != 4) {
    return 4294967276;
  }
  LODWORD(__ptr) = 0;
  if (fread(&__ptr, 1uLL, 4uLL, v26) != 4) {
    goto LABEL_93;
  }
  v215 = v31;
  uint64_t v33 = 0;
  unsigned int v34 = bswap32(__ptr);
  if (v28 == 77) {
    unint64_t v35 = v34;
  }
  else {
    unint64_t v35 = __ptr;
  }
  if (v35 < 8 || v35 >= v220) {
    return v33;
  }
  unsigned int v214 = v35;
  if (fseek(v26, v35, 0)) {
    return 4294967257;
  }
  LOWORD(__ptr) = 0;
  if (fread(&__ptr, 1uLL, 2uLL, v26) != 2)
  {
LABEL_93:
    if ((v26->_flags & 0x20) != 0) {
      return 4294967257;
    }
    else {
      return 4294967277;
    }
  }
  unsigned int v36 = bswap32((unsigned __int16)__ptr) >> 16;
  if (v222) {
    unsigned int v37 = v36;
  }
  else {
    unsigned int v37 = (unsigned __int16)__ptr;
  }
  if ((unsigned __int16)(v37 - 512) < 0xFE03u) {
    return 0;
  }
  signed int v209 = v29;
  size_t v38 = 12 * (unsigned __int16)v37;
  BOOL v39 = (char *)malloc_type_malloc(v38, 0xDE515FAuLL);
  if (!v39) {
    return 0;
  }
  int v40 = v39;
  if (fread(v39, 1uLL, v38, v26) == v38)
  {
    signed int v213 = v30;
    LODWORD(__ptr) = 0;
    if (fread(&__ptr, 1uLL, 4uLL, v26) == 4)
    {
      int v195 = v38;
      v206 = v24;
      v208 = v32;
      char v205 = v18;
      int v41 = (unsigned int *)v40;
      int v42 = 0;
      int v43 = 0;
      int v44 = 0;
      int v45 = 0;
      uint64_t v46 = 0;
      unsigned int v47 = 0;
      LODWORD(v48) = 0;
      unsigned int v210 = (char *)v41;
      unsigned int v49 = __ptr;
      unsigned int v50 = bswap32(__ptr);
      if (v222) {
        unsigned int v49 = v50;
      }
      unsigned int v196 = v49;
      __int16 v51 = v37;
      do
      {
        BOOL v52 = v20 != 0;
        --v51;
        unsigned int v53 = *(unsigned __int16 *)v41;
        unsigned int v54 = bswap32(v53) >> 16;
        if (v222) {
          LOWORD(v53) = v54;
        }
        unsigned int v55 = *((unsigned __int16 *)v41 + 1);
        unsigned int v56 = bswap32(v55) >> 16;
        if (v222) {
          LOWORD(v55) = v56;
        }
        unsigned int v57 = v41[1];
        unsigned int v58 = v41[2];
        __int16 v59 = bswap32(v57);
        if (v222) {
          LOWORD(v57) = v59;
        }
        unsigned int v60 = bswap32(v58);
        if (v222) {
          unsigned int v58 = v60;
        }
        v45 |= (unsigned __int16)v53 == 274;
        v44 |= (unsigned __int16)v53 == 33723;
        v43 |= (unsigned __int16)v53 == 34675;
        v42 |= (unsigned __int16)v53 == 700;
        if ((unsigned __int16)v53 != 34675) {
          BOOL v52 = 0;
        }
        if (v30 == 0 && v52) {
          uint64_t v46 = (__int16 *)v41;
        }
        if ((_WORD)v57) {
          BOOL v61 = (unsigned __int16)v55 == 4;
        }
        else {
          BOOL v61 = 0;
        }
        if (v61 && (unsigned __int16)v53 == 34665) {
          uint64_t v48 = v58;
        }
        else {
          uint64_t v48 = v48;
        }
        if ((unsigned __int16)v57 == 20 && (unsigned __int16)v55 == 2 && (unsigned __int16)v53 == 306) {
          unsigned int v47 = v58;
        }
        v41 += 3;
      }
      while (v51);
      if (v48)
      {
        if (fseek(v26, v48, 0))
        {
          unsigned int v207 = 0;
          uint8x8_t v86 = 0;
          v217 = 0;
          uint64_t v33 = 4294967257;
        }
        else
        {
          LOWORD(__ptr) = 0;
          if (fread(&__ptr, 1uLL, 2uLL, v26) == 2)
          {
            unsigned int v65 = bswap32((unsigned __int16)__ptr) >> 16;
            if (v222) {
              unsigned __int16 v66 = v65;
            }
            else {
              unsigned __int16 v66 = __ptr;
            }
            if ((unsigned __int16)(v66 - 512) >= 0xFE03u)
            {
              size_t v67 = 12 * v66;
              uint8x8_t v68 = (unsigned __int16 *)malloc_type_malloc(v67, 0x86AACC8EuLL);
              if (v68)
              {
                float v199 = v68;
                if (fread(v68, 1uLL, v67, v26) != v67)
                {
                  unsigned int v207 = 0;
                  uint8x8_t v86 = 0;
                  v217 = 0;
                  if ((v26->_flags & 0x20) != 0) {
                    uint64_t v33 = 4294967257;
                  }
                  else {
                    uint64_t v33 = 4294967277;
                  }
                  int v40 = v210;
                  uint64_t v172 = v199;
LABEL_359:
                  free(v172);
LABEL_360:
                  int v87 = v207;
                  if (!v40) {
                    goto LABEL_101;
                  }
                  goto LABEL_100;
                }
                unsigned int v69 = 0;
                unsigned int v70 = 0;
                int v71 = v199;
                do
                {
                  --v66;
                  unsigned int v72 = *v71;
                  unsigned int v73 = bswap32(v72) >> 16;
                  if (v222) {
                    LOWORD(v72) = v73;
                  }
                  unsigned int v74 = v71[1];
                  unsigned int v75 = bswap32(v74) >> 16;
                  if (v222) {
                    LOWORD(v74) = v75;
                  }
                  unsigned int v76 = *((_DWORD *)v71 + 1);
                  unsigned int v77 = *((_DWORD *)v71 + 2);
                  __int16 v78 = bswap32(v76);
                  if (v222) {
                    LOWORD(v76) = v78;
                  }
                  unsigned int v79 = bswap32(v77);
                  if (v222) {
                    unsigned int v77 = v79;
                  }
                  BOOL v80 = (unsigned __int16)v72 == 36867;
                  BOOL v81 = (unsigned __int16)v76 == 20;
                  BOOL v82 = (unsigned __int16)v72 == 36868;
                  BOOL v83 = (unsigned __int16)v74 == 2;
                  BOOL v84 = (unsigned __int16)v74 == 2 && v80;
                  if (!v83) {
                    BOOL v82 = 0;
                  }
                  if (v84 && v81) {
                    unsigned int v70 = v77;
                  }
                  if (v82 && v81) {
                    unsigned int v69 = v77;
                  }
                  v71 += 6;
                }
                while (v66);
                signed int v30 = v213;
LABEL_108:
                unsigned int v186 = v69;
                unsigned int v187 = v70;
                int v88 = v47 | v70 | v69;
                BOOL v212 = v88 != 0;
                if (v88) {
                  BOOL v89 = 0;
                }
                else {
                  BOOL v89 = a14 != 0;
                }
                int v90 = ((a12 != 0) & (v45 ^ 1))
                    - (v46 != 0)
                    + ((BytePtr != 0) & (v44 ^ 1))
                    + ((v208 != 0) & (v43 ^ 1))
                    + ((v215 != 0) & (v42 ^ 1))
                    + v89;
                unsigned int v203 = v37 + v90;
                __size_t size = 12 * (unsigned __int16)(v37 + v90);
                int v191 = v90;
                if (v90 < 1)
                {
                  unsigned int v193 = v214;
                  uint64_t v91 = v210;
                }
                else
                {
                  uint64_t v91 = (char *)reallocf(v210, __size);
                  unsigned int v193 = v220;
                  v220 += (__size + 6);
                }
                int v92 = &v91[12 * (unsigned __int16)v37];
                uint64_t v93 = v92 + 12;
                unsigned int v94 = v92 + 24;
                if (v46)
                {
                  *uint64_t v46 = -1;
                }
                else
                {
                  uint64_t v95 = v92 + 36;
                  uint64_t v46 = (__int16 *)&v91[12 * (unsigned __int16)v37];
                  v92 += 12;
                  uint64_t v93 = v94;
                  unsigned int v94 = v95;
                }
                *(void *)&long long v223 = v46;
                *((void *)&v223 + 1) = v92;
                *(void *)&long long v224 = v93;
                *((void *)&v224 + 1) = v94;
                if ((a12 == 0) | v45 & 1)
                {
                  unsigned int v96 = 0;
                }
                else
                {
                  if (v222) {
                    __int16 v97 = 4609;
                  }
                  else {
                    __int16 v97 = 274;
                  }
                  *uint64_t v46 = v97;
                  unsigned int v96 = 1;
                }
                if (!((BytePtr == 0) | v44 & 1))
                {
                  uint64_t v98 = v96++;
                  uint64_t v99 = *(__int16 **)((unint64_t)&v223 | (8 * v98));
                  if (v222) {
                    __int16 v100 = -17533;
                  }
                  else {
                    __int16 v100 = -31813;
                  }
                  *uint64_t v99 = v100;
                }
                uint64_t v101 = v206;
                if (!((v215 == 0) | v42 & 1))
                {
                  uint64_t v102 = (__int16 *)*((void *)&v223 + v96++);
                  if (v222) {
                    __int16 v103 = -17406;
                  }
                  else {
                    __int16 v103 = 700;
                  }
                  *uint64_t v102 = v103;
                }
                int v40 = v91;
                if (!((v208 == 0) | v43 & 1))
                {
                  int v104 = (__int16 *)*((void *)&v223 + v96++);
                  if (v222) {
                    __int16 v105 = 29575;
                  }
                  else {
                    __int16 v105 = -30861;
                  }
                  __int16 *v104 = v105;
                }
                CFDictionaryRef v106 = v216;
                char v107 = v212;
                if (!a14) {
                  char v107 = 1;
                }
                if ((v107 & 1) == 0)
                {
                  unint64_t v108 = (__int16 *)*((void *)&v223 + v96);
                  if (v222) {
                    __int16 v109 = 12801;
                  }
                  else {
                    __int16 v109 = 306;
                  }
                  *unint64_t v108 = v109;
                }
                if ((unsigned __int16)v37 <= (unsigned __int16)v203) {
                  size_t v110 = (unsigned __int16)v203;
                }
                else {
                  size_t v110 = (unsigned __int16)v37;
                }
                qsort_r(v91, v110, 0xCuLL, &v222, (int (__cdecl *)(void *, const void *, const void *))sortifd);
                unsigned int v111 = v203;
                if ((_WORD)v203)
                {
                  unsigned int v194 = 0;
                  signed int v198 = 0;
                  unsigned int v189 = 0;
                  unsigned int v207 = 0;
                  int v112 = 0;
                  v217 = 0;
                  uint64_t v185 = 0;
                  unsigned int v188 = 0;
                  unsigned int v192 = 0;
                  unsigned int v197 = 0;
                  unsigned int v204 = 0;
                  unsigned int v184 = bswap32(v30);
                  unsigned int v190 = bswap32(v209);
                  uint64_t v201 = (Length + 3) >> 2;
                  unsigned int v200 = bswap32(v201);
                  unsigned __int16 v211 = __rev16(a12);
                  double v113 = v40 + 8;
                  while (1)
                  {
                    BOOL v114 = v222;
                    unsigned int v115 = *((unsigned __int16 *)v113 - 4);
                    unsigned int v116 = bswap32(v115) >> 16;
                    if (v222) {
                      LOWORD(v115) = v116;
                    }
                    if (a12 && (unsigned __int16)v115 == 274)
                    {
                      BOOL v117 = !v222;
                      if (v222) {
                        __int16 v118 = 768;
                      }
                      else {
                        __int16 v118 = 3;
                      }
                      *((_WORD *)v113 - 3) = v118;
                      if (v114) {
                        int v119 = 0x1000000;
                      }
                      else {
                        int v119 = 1;
                      }
                      *((_DWORD *)v113 - 1) = v119;
                      unsigned __int16 v120 = a12;
                      if (!v117) {
                        unsigned __int16 v120 = v211;
                      }
                      *(_WORD *)double v113 = v120;
                      uint64_t v121 = a11;
                      if (!a11) {
                        goto LABEL_196;
                      }
LABEL_195:
                      *uint64_t v121 = 1;
                      goto LABEL_196;
                    }
                    if (a14) {
                      BOOL v122 = (unsigned __int16)v115 == 306;
                    }
                    else {
                      BOOL v122 = 0;
                    }
                    char v123 = v212;
                    if (!v122) {
                      char v123 = 1;
                    }
                    if (v123)
                    {
                      if (!BytePtr || (unsigned __int16)v115 != 33723)
                      {
                        if (v215 && (unsigned __int16)v115 == 700)
                        {
                          BOOL v134 = !v222;
                          if (v222) {
                            __int16 v135 = 256;
                          }
                          else {
                            __int16 v135 = 1;
                          }
                          *((_WORD *)v113 - 3) = v135;
                          unsigned int v136 = v190;
                          if (v134) {
                            unsigned int v136 = v209;
                          }
                          *((_DWORD *)v113 - 1) = v136;
                          unint64_t v137 = v220;
                          unsigned int v138 = bswap32(v220);
                          if (v134) {
                            unsigned int v138 = v220;
                          }
                          *(_DWORD *)double v113 = v138;
                          if (a9) {
                            *a9 = 1;
                          }
                          unsigned int v197 = v220;
                          unsigned int v139 = v209;
                          goto LABEL_221;
                        }
                        if (v208 && (unsigned __int16)v115 == 34675)
                        {
                          BOOL v140 = !v222;
                          if (v222) {
                            __int16 v141 = 1792;
                          }
                          else {
                            __int16 v141 = 7;
                          }
                          *((_WORD *)v113 - 3) = v141;
                          if (v140) {
                            unsigned int v142 = v30;
                          }
                          else {
                            unsigned int v142 = v184;
                          }
                          unint64_t v137 = v220;
                          unsigned int v143 = bswap32(v220);
                          if (v140) {
                            unsigned int v143 = v220;
                          }
                          *((_DWORD *)v113 - 1) = v142;
                          *(_DWORD *)double v113 = v143;
                          unsigned int v139 = v30;
                          unsigned int v192 = v220;
LABEL_221:
                          unint64_t v220 = v137 + v139;
                          xpc_object_t value = 0;
                        }
                        else
                        {
                          xpc_object_t value = 0;
                          if (v106 && (unsigned __int16)v115 == 270)
                          {
                            if (!CFDictionaryGetValueIfPresent(v106, @"Caption/Abstract", (const void **)&value)) {
                              goto LABEL_196;
                            }
                            if (v217) {
                              free(v217);
                            }
                            IIOString::IIOString((IIOString *)&__ptr, value);
                            UTF8String = (const char *)IIOString::createUTF8String((IIOString *)&__ptr);
                            IIOString::~IIOString((IIOString *)&__ptr);
                            if (!UTF8String)
                            {
                              v217 = 0;
                              goto LABEL_196;
                            }
                            int v155 = strlen(UTF8String);
                            unsigned int v147 = v155 + 1;
                            BOOL v156 = v222;
                            unsigned int v157 = bswap32(v155 + 1);
                            if (!v222) {
                              unsigned int v157 = v155 + 1;
                            }
                            *((_DWORD *)v113 - 1) = v157;
                            v217 = (char *)UTF8String;
                            unsigned int v189 = v155 + 1;
                            if (v147 > 4)
                            {
                              unint64_t v158 = v220;
                              unsigned int v159 = bswap32(v220);
                              BOOL v160 = !v156;
                              LODWORD(v185) = v220;
                              goto LABEL_261;
                            }
                            goto LABEL_236;
                          }
                        }
                        if ((unsigned __int16)v115 != 315 || v106 == 0)
                        {
                          if ((unsigned __int16)v115 != 33432
                            || !v106
                            || !CFDictionaryGetValueIfPresent(v106, @"CopyrightNotice", (const void **)&value))
                          {
                            goto LABEL_196;
                          }
                          if (v207) {
                            free(v207);
                          }
                          IIOString::IIOString((IIOString *)&__ptr, value);
                          UTF8String = (const char *)IIOString::createUTF8String((IIOString *)&__ptr);
                          IIOString::~IIOString((IIOString *)&__ptr);
                          if (!UTF8String)
                          {
                            unsigned int v207 = 0;
                            goto LABEL_196;
                          }
                          int v146 = strlen(UTF8String);
                          unsigned int v147 = v146 + 1;
                          BOOL v148 = v222;
                          unsigned int v149 = bswap32(v146 + 1);
                          if (!v222) {
                            unsigned int v149 = v146 + 1;
                          }
                          *((_DWORD *)v113 - 1) = v149;
                          unsigned int v207 = (char *)UTF8String;
                          signed int v198 = v146 + 1;
                          if (v147 > 4)
                          {
                            unint64_t v158 = v220;
                            unsigned int v159 = bswap32(v220);
                            BOOL v160 = !v148;
                            HIDWORD(v185) = v220;
                            goto LABEL_261;
                          }
LABEL_236:
                          strlcpy(v113, UTF8String, 4uLL);
                          goto LABEL_196;
                        }
                        if (CFDictionaryGetValueIfPresent(v106, @"Byline", (const void **)&value))
                        {
                          if (v112) {
                            free(v112);
                          }
                          IIOString::IIOString((IIOString *)&__ptr, value);
                          uint64_t v151 = (const char *)IIOString::createUTF8String((IIOString *)&__ptr);
                          IIOString::~IIOString((IIOString *)&__ptr);
                          if (v151)
                          {
                            int v152 = strlen(v151);
                            unsigned int v147 = v152 + 1;
                            BOOL v153 = v222;
                            unsigned int v154 = bswap32(v152 + 1);
                            if (!v222) {
                              unsigned int v154 = v152 + 1;
                            }
                            *((_DWORD *)v113 - 1) = v154;
                            unsigned int v194 = v152 + 1;
                            if (v147 > 4)
                            {
                              int v112 = (char *)v151;
                              unint64_t v158 = v220;
                              unsigned int v159 = bswap32(v220);
                              BOOL v160 = !v153;
                              unsigned int v188 = v220;
LABEL_261:
                              if (v160) {
                                unsigned int v161 = v158;
                              }
                              else {
                                unsigned int v161 = v159;
                              }
                              *(_DWORD *)double v113 = v161;
                              unint64_t v220 = v158 + v147;
                              goto LABEL_196;
                            }
                            int v112 = (char *)v151;
                            strlcpy(v113, v151, 4uLL);
                          }
                          else
                          {
                            int v112 = 0;
                          }
                        }
                        goto LABEL_196;
                      }
                      BOOL v124 = !v222;
                      if (v222) {
                        __int16 v125 = 1024;
                      }
                      else {
                        __int16 v125 = 4;
                      }
                      *((_WORD *)v113 - 3) = v125;
                      if (v114) {
                        unsigned int v126 = v200;
                      }
                      else {
                        unsigned int v126 = (Length + 3) >> 2;
                      }
                      unsigned int v127 = bswap32(v220);
                      if (v124) {
                        unsigned int v127 = v220;
                      }
                      *((_DWORD *)v113 - 1) = v126;
                      *(_DWORD *)double v113 = v127;
                      unsigned int v204 = v220;
                      unint64_t v128 = v220 + v201;
                      uint64_t v129 = v205;
                    }
                    else
                    {
                      BOOL v130 = !v222;
                      if (v222) {
                        __int16 v131 = 512;
                      }
                      else {
                        __int16 v131 = 2;
                      }
                      *((_WORD *)v113 - 3) = v131;
                      if (v114) {
                        int v132 = 335544320;
                      }
                      else {
                        int v132 = 20;
                      }
                      unsigned int v133 = bswap32(v220);
                      if (v130) {
                        unsigned int v133 = v220;
                      }
                      *((_DWORD *)v113 - 1) = v132;
                      *(_DWORD *)double v113 = v133;
                      unsigned int v47 = v220;
                      unint64_t v128 = v220 + 20;
                      uint64_t v129 = a13;
                    }
                    uint64_t v121 = v129;
                    unint64_t v220 = v128;
                    if (v129) {
                      goto LABEL_195;
                    }
LABEL_196:
                    --v111;
                    v113 += 12;
                    if (!(_WORD)v111) {
                      goto LABEL_266;
                    }
                  }
                }
                unsigned int v204 = 0;
                unsigned int v197 = 0;
                unsigned int v192 = 0;
                uint64_t v185 = 0;
                unsigned int v188 = 0;
                v217 = 0;
                int v112 = 0;
                unsigned int v207 = 0;
                unsigned int v189 = 0;
                signed int v198 = 0;
                unsigned int v194 = 0;
LABEL_266:
                if (fseek(v26, 8, 0)) {
                  goto LABEL_365;
                }
                unsigned int v162 = bswap32(v193);
                if (v222) {
                  unsigned int v163 = v162;
                }
                else {
                  unsigned int v163 = v193;
                }
                LODWORD(__ptr) = v163;
                if (fwrite(&__ptr, 1uLL, 4uLL, v101) != 4) {
                  goto LABEL_356;
                }
                int v164 = v214 - 8;
                if (v214 != 8)
                {
                  bzero(&__ptr, 0x4000uLL);
                  while (1)
                  {
                    int v165 = v164 >= 2048 ? 2048 : v164;
                    uint64_t v166 = v165;
                    if (fread(&__ptr, 1uLL, v165, v26) != v165) {
                      break;
                    }
                    size_t v167 = fwrite(&__ptr, 1uLL, v165, v101);
                    signed int v30 = v213;
                    if (v167 != v166) {
                      goto LABEL_356;
                    }
                    v164 -= v166;
                    if (!v164) {
                      goto LABEL_279;
                    }
                  }
                  if ((v26->_flags & 0x20) != 0) {
                    uint64_t v33 = 4294967257;
                  }
                  else {
                    uint64_t v33 = 4294967277;
                  }
                  goto LABEL_357;
                }
LABEL_279:
                if (v191 <= 0)
                {
                  if (fseek(v26, (v195 + 6), 1)) {
                    goto LABEL_365;
                  }
                  unsigned int v173 = bswap32(v203) >> 16;
                  if (v222) {
                    __int16 v174 = v173;
                  }
                  else {
                    __int16 v174 = v203;
                  }
                  LOWORD(__ptr) = v174;
                  if (fwrite(&__ptr, 1uLL, 2uLL, v101) != 2 || fwrite(v40, 1uLL, __size, v101) != __size) {
                    goto LABEL_356;
                  }
                  unsigned int v175 = bswap32(v196);
                  unsigned int v176 = v222 ? v175 : v196;
                  LODWORD(__ptr) = v176;
                  if (fwrite(&__ptr, 1uLL, 4uLL, v101) != 4) {
                    goto LABEL_356;
                  }
                  if (v191 < 0)
                  {
                    int v227 = 0;
                    uint64_t __ptr = 0;
                    if (fwrite(&__ptr, 1uLL, 0xCuLL, v101) != 12) {
                      goto LABEL_356;
                    }
                  }
                  uint64_t v33 = copyRemainder(v26, v101);
                  uint8x8_t v86 = v112;
                  if (v33) {
                    goto LABEL_358;
                  }
                }
                else
                {
                  uint64_t v33 = copyRemainder(v26, v101);
                  uint8x8_t v86 = v112;
                  if (v33) {
                    goto LABEL_358;
                  }
                  unsigned int v168 = bswap32(v203) >> 16;
                  if (v222) {
                    __int16 v169 = v168;
                  }
                  else {
                    __int16 v169 = v203;
                  }
                  LOWORD(__ptr) = v169;
                  if (fwrite(&__ptr, 1uLL, 2uLL, v101) != 2 || fwrite(v40, 1uLL, __size, v101) != __size) {
                    goto LABEL_356;
                  }
                  unsigned int v170 = bswap32(v196);
                  if (v222) {
                    unsigned int v171 = v170;
                  }
                  else {
                    unsigned int v171 = v196;
                  }
                  LODWORD(__ptr) = v171;
                  uint8x8_t v86 = v112;
                  if (fwrite(&__ptr, 1uLL, 4uLL, v101) != 4) {
                    goto LABEL_366;
                  }
                }
                uint64_t v177 = v215;
                if (BytePtr)
                {
                  if (fseek(v101, v204, 0)) {
                    goto LABEL_365;
                  }
                  if (fwrite(BytePtr, 1uLL, Length, v101) != Length) {
                    goto LABEL_356;
                  }
                  BYTE2(__ptr) = 0;
                  LOWORD(__ptr) = 0;
                  if ((-Length & 3) != 0 && fwrite(&__ptr, 1uLL, -Length & 3, v101) != (-Length & 3)) {
                    goto LABEL_356;
                  }
                  if (v205) {
                    *char v205 = 1;
                  }
                  uint64_t v177 = v215;
                  uint8x8_t v86 = v112;
                }
                if (!v177)
                {
LABEL_324:
                  if (v208)
                  {
                    if (fseek(v101, v192, 0)) {
                      goto LABEL_365;
                    }
                    uint8x8_t v86 = v112;
                    if (fwrite(v208, 1uLL, v30, v101) != v30) {
                      goto LABEL_366;
                    }
                  }
                  unsigned int v178 = v198;
                  if (a14 && (v47 || v187 || v186))
                  {
                    if (v47)
                    {
                      if (fseek(v101, v47, 0)) {
                        goto LABEL_365;
                      }
                      size_t v179 = fwrite(a14, 1uLL, 0x14uLL, v101);
                      uint8x8_t v86 = v112;
                      unsigned int v178 = v198;
                      if (v179 != 20) {
                        goto LABEL_366;
                      }
                    }
                    if (v187)
                    {
                      if (fseek(v101, v187, 0)) {
                        goto LABEL_365;
                      }
                      size_t v180 = fwrite(a14, 1uLL, 0x14uLL, v101);
                      uint8x8_t v86 = v112;
                      unsigned int v178 = v198;
                      if (v180 != 20) {
                        goto LABEL_366;
                      }
                    }
                    if (v186)
                    {
                      if (fseek(v101, v186, 0)) {
                        goto LABEL_365;
                      }
                      size_t v181 = fwrite(a14, 1uLL, 0x14uLL, v101);
                      uint8x8_t v86 = v112;
                      unsigned int v178 = v198;
                      if (v181 != 20) {
                        goto LABEL_366;
                      }
                    }
                    if (a13) {
                      *a13 = 1;
                    }
                  }
                  if (!v217 || v189 < 5)
                  {
LABEL_346:
                    if (!v86 || v194 < 5) {
                      goto LABEL_350;
                    }
                    if (fseek(v101, v188, 0))
                    {
                      uint64_t v33 = 4294967257;
                      goto LABEL_358;
                    }
                    size_t v183 = fwrite(v86, 1uLL, (int)v194, v101);
                    uint8x8_t v86 = v112;
                    unsigned int v178 = v198;
                    if (v183 == v194)
                    {
LABEL_350:
                      uint64_t v33 = 0;
                      if (v207 && v178 >= 5)
                      {
                        if (!fseek(v101, HIDWORD(v185), 0))
                        {
                          if (fwrite(v207, 1uLL, v198, v101) == v198) {
                            uint64_t v33 = 0;
                          }
                          else {
                            uint64_t v33 = 4294967276;
                          }
                          goto LABEL_357;
                        }
                        goto LABEL_365;
                      }
LABEL_358:
                      uint64_t v172 = v199;
                      if (!v199) {
                        goto LABEL_360;
                      }
                      goto LABEL_359;
                    }
LABEL_366:
                    uint64_t v33 = 4294967276;
                    goto LABEL_358;
                  }
                  if (!fseek(v101, v185, 0))
                  {
                    size_t v182 = fwrite(v217, 1uLL, (int)v189, v101);
                    uint8x8_t v86 = v112;
                    unsigned int v178 = v198;
                    if (v182 != v189) {
                      goto LABEL_366;
                    }
                    goto LABEL_346;
                  }
LABEL_365:
                  uint64_t v33 = 4294967257;
                  goto LABEL_357;
                }
                if (fseek(v101, v197, 0)) {
                  goto LABEL_365;
                }
                if (fwrite(v177, 1uLL, v209, v101) == v209)
                {
                  uint8x8_t v86 = v112;
                  if (a9) {
                    *a9 = 1;
                  }
                  goto LABEL_324;
                }
LABEL_356:
                uint64_t v33 = 4294967276;
LABEL_357:
                uint8x8_t v86 = v112;
                goto LABEL_358;
              }
            }
            unsigned int v207 = 0;
            uint8x8_t v86 = 0;
            v217 = 0;
            uint64_t v33 = 0;
          }
          else
          {
            unsigned int v207 = 0;
            uint8x8_t v86 = 0;
            v217 = 0;
            if ((v26->_flags & 0x20) != 0) {
              uint64_t v33 = 4294967257;
            }
            else {
              uint64_t v33 = 4294967277;
            }
          }
        }
        int v40 = v210;
        goto LABEL_360;
      }
      float v199 = 0;
      unsigned int v70 = 0;
      unsigned int v69 = 0;
      goto LABEL_108;
    }
  }
  v217 = 0;
  uint8x8_t v86 = 0;
  int v87 = 0;
  if ((v26->_flags & 0x20) != 0) {
    uint64_t v33 = 4294967257;
  }
  else {
    uint64_t v33 = 4294967277;
  }
LABEL_100:
  free(v40);
LABEL_101:
  if (v217) {
    free(v217);
  }
  if (v86) {
    free(v86);
  }
  if (v87) {
    free(v87);
  }
  return v33;
}

void sub_188740038(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
}

uint64_t sortifd(unsigned char *a1, unsigned __int16 *a2, unsigned __int16 *a3)
{
  unsigned int v3 = bswap32(*a2) >> 16;
  if (*a1) {
    unsigned __int16 v4 = v3;
  }
  else {
    unsigned __int16 v4 = *a2;
  }
  unsigned int v5 = *a3;
  unsigned int v6 = bswap32(v5) >> 16;
  if (*a1) {
    LOWORD(v5) = v6;
  }
  return v4 - (unsigned __int16)v5;
}

uint64_t copyRemainder(__sFILE *a1, __sFILE *a2)
{
  MEMORY[0x1F4188790](a1, a2);
  unsigned int v3 = v2;
  unsigned int v5 = v4;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  bzero(__ptr, 0x1000uLL);
  while (1)
  {
    unsigned int v6 = fread(__ptr, 1uLL, 0x1000uLL, v5);
    unsigned int v7 = v6;
    size_t v8 = v6;
    if (v6 <= 0xFFFuLL) {
      break;
    }
    if (fwrite(__ptr, 1uLL, v6, v3) != v6) {
      return 4294967276;
    }
  }
  if (!feof(v5)) {
    return 4294967277;
  }
  if (fwrite(__ptr, 1uLL, v8, v3) == v7) {
    return 0;
  }
  return 4294967276;
}

uint64_t IIO_BytesPerPixelForPixelFormatPlane0(int a1)
{
  if (a1 > 1380411456)
  {
    if (a1 > 1932996148)
    {
      if (a1 > 2019963439)
      {
        if (a1 <= 2019963955)
        {
          if (a1 == 2019963440) {
            return 2;
          }
          int v5 = 2019963442;
        }
        else
        {
          if (a1 == 2019963956 || a1 == 2037741158) {
            return 2;
          }
          int v5 = 2037741171;
        }
      }
      else
      {
        if (a1 <= 2016686639)
        {
          if (a1 == 1932996149) {
            return 2;
          }
          int v3 = 1999843442;
          goto LABEL_50;
        }
        if (a1 == 2016686640 || a1 == 2016686642) {
          return 2;
        }
        int v5 = 2016687156;
      }
    }
    else
    {
      uint64_t result = 8;
      if (a1 <= 1751410031)
      {
        if (a1 > 1650943795)
        {
          if (a1 != 1650943796)
          {
            if (a1 != 1717855600)
            {
              int v3 = 1717856627;
              goto LABEL_50;
            }
            return 4;
          }
          return 2;
        }
        if (a1 == 1380411457) {
          return result;
        }
        int v3 = 1647534392;
LABEL_50:
        if (a1 == v3) {
          return 4;
        }
        goto LABEL_62;
      }
      if (a1 <= 1815162993)
      {
        if (a1 == 1751410032) {
          return 2;
        }
        int v5 = 1751411059;
      }
      else
      {
        if (a1 == 1815162994) {
          return 4;
        }
        if (a1 == 1815491698) {
          return result;
        }
        int v5 = 1919379252;
      }
    }
    goto LABEL_60;
  }
  if (a1 > 875704949)
  {
    if (a1 <= 1278226735)
    {
      if (a1 <= 875836533)
      {
        if (a1 == 875704950) {
          return 1;
        }
        int v4 = 875836518;
      }
      else
      {
        if (a1 == 875836534) {
          return 1;
        }
        if (a1 == 1111970369) {
          return 4;
        }
        int v4 = 1278226488;
      }
      goto LABEL_44;
    }
    if (a1 > 1278555700)
    {
      if (a1 == 1278555701 || a1 == 1279340600) {
        return 2;
      }
      int v3 = 1380401729;
      goto LABEL_50;
    }
    if (a1 == 1278226736) {
      return 2;
    }
    int v5 = 1278226742;
LABEL_60:
    if (a1 == v5) {
      return 2;
    }
    goto LABEL_62;
  }
  if (a1 <= 843264103)
  {
    if (a1 <= 825306676)
    {
      if (a1 == 16) {
        return 2;
      }
      if (a1 == 32) {
        return 4;
      }
LABEL_62:
      unsigned int v6 = a1 >> 24;
      uint64_t v7 = MEMORY[0x1E4F14390];
      if (a1 < 0) {
        int v8 = __maskrune(a1 >> 24, 0x40000uLL);
      }
      else {
        int v8 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v6 + 60) & 0x40000;
      }
      if (v8) {
        uint64_t v9 = v6;
      }
      else {
        uint64_t v9 = 46;
      }
      unsigned int v10 = a1 << 8 >> 24;
      if (a1 << 8 < 0) {
        int v11 = __maskrune(a1 << 8 >> 24, 0x40000uLL);
      }
      else {
        int v11 = *(_DWORD *)(v7 + 4 * v10 + 60) & 0x40000;
      }
      if (v11) {
        uint64_t v12 = v10;
      }
      else {
        uint64_t v12 = 46;
      }
      unsigned int v13 = (__int16)a1 >> 8;
      if (a1 << 16 < 0) {
        int v14 = __maskrune((__int16)a1 >> 8, 0x40000uLL);
      }
      else {
        int v14 = *(_DWORD *)(v7 + 4 * v13 + 60) & 0x40000;
      }
      if (v14) {
        uint64_t v15 = v13;
      }
      else {
        uint64_t v15 = 46;
      }
      if ((a1 << 24) <= 0x7F000000) {
        int v16 = *(_DWORD *)(v7 + 4 * (char)a1 + 60) & 0x40000;
      }
      else {
        int v16 = __maskrune((char)a1, 0x40000uLL);
      }
      if (v16) {
        uint64_t v17 = (char)a1;
      }
      else {
        uint64_t v17 = 46;
      }
      LogError("IIO_BytesPerPixelForPixelFormatPlane0", 140, "*** IIO_BytesPerPixelForPixelFormatPlane0 - '%c%c%c%c' not handled\n", v9, v12, v15, v17);
      return 1;
    }
    if (a1 == 825306677) {
      return 2;
    }
    int v5 = 825437747;
    goto LABEL_60;
  }
  if (a1 <= 875704421)
  {
    if (a1 == 843264104) {
      return 4;
    }
    int v3 = 843264310;
    goto LABEL_50;
  }
  if (a1 == 875704422 || a1 == 875704438) {
    return 1;
  }
  int v4 = 875704934;
LABEL_44:
  if (a1 != v4) {
    goto LABEL_62;
  }
  return 1;
}

uint64_t IIO_FillGeometry420(int a1, unsigned int a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  double v10 = a4;
  unint64_t v12 = (unint64_t)a6;
  unint64_t v13 = (unint64_t)a7;
  double v14 = (double)((unint64_t)a7 + (unint64_t)a5 + ~(((unint64_t)a5 - 1) % (unint64_t)a7));
  *(double *)a3 = (double)((unint64_t)a6
                         + (unint64_t)a4
                         + ~(((unint64_t)a4 - 1) % (unint64_t)a6));
  *(double *)(a3 + 8) = v14;
  unsigned int v15 = IIO_BytesPerPixelForPixelFormatPlane0(a1);
  double v16 = (double)v15;
  unsigned int v17 = (*(double *)a3 * (double)v15);
  if (v17 % a2) {
    int v18 = a2 - v17 % a2;
  }
  else {
    int v18 = 0;
  }
  int v19 = v18 + v17;
  *(_DWORD *)(a3 + 16) = v15;
  *(_DWORD *)(a3 + 20) = v19;
  if (v10 <= 0.0 || a5 <= 0.0)
  {
    _cg_jpeg_mem_term("IIO_FillGeometry420", 226, "*** ERROR: bad dimension (%d x %d) for creating a '420f' surface\n");
    return 4294967246;
  }
  if (v19 < 0)
  {
    _cg_jpeg_mem_term("IIO_FillGeometry420", 227, "*** ERROR: IOSurface does not support rowBytes larger than INT32_MAX");
    return 4294967246;
  }
  if (a1 <= 875836517)
  {
    if (a1 <= 875704933)
    {
      if (a1 != 875704422)
      {
        int v20 = 875704438;
        goto LABEL_21;
      }
      goto LABEL_22;
    }
    if (a1 == 875704934 || a1 == 875704950)
    {
      double v10 = (double)(unint64_t)((v10 + 1.0) * 0.5);
      goto LABEL_18;
    }
LABEL_27:
    _cg_jpeg_mem_term("IIO_FillGeometry420", 246, "*** unhandled pixel format\n");
    return 4294967246;
  }
  if (a1 > 2016686639)
  {
    if (a1 != 2019963440)
    {
      int v20 = 2016686640;
LABEL_21:
      if (a1 == v20) {
        goto LABEL_22;
      }
      goto LABEL_27;
    }
LABEL_22:
    double v10 = (double)(unint64_t)((v10 + 1.0) * 0.5);
    *(double *)(a3 + 24) = v10;
    *(double *)(a3 + 32) = (double)(unint64_t)((a5 + 1.0) * 0.5);
    double v14 = (double)((unint64_t)((a5 + 1.0) * 0.5) + v13 + ~(((unint64_t)((a5 + 1.0) * 0.5) - 1) % v13));
    goto LABEL_23;
  }
  if (a1 != 875836518 && a1 != 875836534) {
    goto LABEL_27;
  }
LABEL_18:
  *(double *)(a3 + 24) = v10;
  *(double *)(a3 + 32) = a5;
LABEL_23:
  uint64_t result = 0;
  double v22 = (double)((unint64_t)(v10 + v10) + v12 + ~(((unint64_t)(v10 + v10) - 1) % v12));
  *(double *)(a3 + 40) = v22;
  *(double *)(a3 + 48) = v14;
  unsigned int v23 = (v16 * v22);
  if (v23 % a2) {
    int v24 = a2 - v23 % a2;
  }
  else {
    int v24 = 0;
  }
  *(_DWORD *)(a3 + 56) = v24 + v23;
  return result;
}

uint64_t CIF10MIN(void)
{
  return 384;
}

uint64_t CIF10MAX(void)
{
  return 895;
}

uint64_t IIOAlignRowBytes(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2 - 1;
  if (!a2) {
    uint64_t v2 = 15;
  }
  return (v2 + a1) & ~v2;
}

void IIO_CreateIOSurfaceProperties()
{
}

void sub_188740F5C(_Unwind_Exception *a1)
{
}

__IOSurface *IIO_CreateSurfaceWithFormat(int a1, int a2, int a3, CGColorSpace *a4)
{
  if (a1 > 1380401728)
  {
    if (a1 > 1380411456)
    {
      if (a1 == 1815491698 || a1 == 1380411457)
      {
        int v8 = 8;
        goto LABEL_18;
      }
    }
    else
    {
      if (a1 == 1380401729)
      {
LABEL_16:
        int v8 = 4;
        goto LABEL_18;
      }
      if (a1 == 1380410945)
      {
        int v8 = 16;
        goto LABEL_18;
      }
    }
    goto LABEL_23;
  }
  if (a1 <= 1278226487)
  {
    if (a1 != 843264056)
    {
      if (a1 != 1111970369) {
        goto LABEL_23;
      }
      goto LABEL_16;
    }
LABEL_12:
    int v8 = 2;
    goto LABEL_18;
  }
  if (a1 != 1278226488)
  {
    if (a1 == 1278226742) {
      goto LABEL_12;
    }
LABEL_23:
    unsigned int v12 = a1 >> 24;
    uint64_t v13 = MEMORY[0x1E4F14390];
    if (a1 < 0) {
      int v14 = __maskrune(a1 >> 24, 0x40000uLL);
    }
    else {
      int v14 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x40000;
    }
    if (v14) {
      uint64_t v15 = v12;
    }
    else {
      uint64_t v15 = 46;
    }
    unsigned int v16 = a1 << 8 >> 24;
    if (a1 << 8 < 0) {
      int v17 = __maskrune(a1 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = v16;
    }
    else {
      uint64_t v18 = 46;
    }
    unsigned int v19 = (__int16)a1 >> 8;
    if (a1 << 16 < 0) {
      int v20 = __maskrune((__int16)a1 >> 8, 0x40000uLL);
    }
    else {
      int v20 = *(_DWORD *)(v13 + 4 * v19 + 60) & 0x40000;
    }
    if (v20) {
      uint64_t v21 = v19;
    }
    else {
      uint64_t v21 = 46;
    }
    if ((a1 << 24) <= 0x7F000000) {
      int v22 = *(_DWORD *)(v13 + 4 * (char)a1 + 60) & 0x40000;
    }
    else {
      int v22 = __maskrune((char)a1, 0x40000uLL);
    }
    if (v22) {
      uint64_t v23 = (char)a1;
    }
    else {
      uint64_t v23 = 46;
    }
    LogError("IIO_CreateSurfaceWithFormat", 628, "*** ERROR: Unexpected pixelFormat '%c%c%c%c'\n", v15, v18, v21, v23);
    return 0;
  }
  int v8 = 1;
LABEL_18:
  uint64_t v29 = 0;
  CFDictionaryRef v30 = 0;
  uint64_t v31 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v29);
  IIONumber::IIONumber((IIONumber *)v28, a2);
  IIODictionary::setObjectForKey((uint64_t)&v29, (uint64_t)v28, (const void *)*MEMORY[0x1E4F2F2C0]);
  IIONumber::~IIONumber((IIONumber *)v28);
  IIONumber::IIONumber((IIONumber *)v27, a3);
  IIODictionary::setObjectForKey((uint64_t)&v29, (uint64_t)v27, (const void *)*MEMORY[0x1E4F2F0E8]);
  IIONumber::~IIONumber((IIONumber *)v27);
  IIONumber::IIONumber((IIONumber *)v26, a1);
  IIODictionary::setObjectForKey((uint64_t)&v29, (uint64_t)v26, (const void *)*MEMORY[0x1E4F2F150]);
  IIONumber::~IIONumber((IIONumber *)v26);
  IIONumber::IIONumber((IIONumber *)v25, v8);
  IIODictionary::setObjectForKey((uint64_t)&v29, (uint64_t)v25, (const void *)*MEMORY[0x1E4F2EFD8]);
  IIONumber::~IIONumber((IIONumber *)v25);
  IIODictionary::setObjectForKey((IIODictionary *)&v29, (const void *)*MEMORY[0x1E4F1CFC8], (const __CFString *)*MEMORY[0x1E4F2F148]);
  IIONumber::IIONumber((IIONumber *)v24, (v8 * a2 + 15) & 0xFFFFFFF0);
  IIODictionary::setObjectForKey((uint64_t)&v29, (uint64_t)v24, (const void *)*MEMORY[0x1E4F2EFE0]);
  IIONumber::~IIONumber((IIONumber *)v24);
  uint64_t v9 = IOSurfaceCreate(v30);
  double v10 = v9;
  if (a4 && v9) {
    IIO_IOSurfaceAddColorSpace(v9, a4);
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v29);
  return v10;
}

void sub_188741474(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v5 - 72));
  _Unwind_Resume(a1);
}

void IIO_IOSurfaceAddColorSpace(__IOSurface *a1, CGColorSpaceRef space)
{
  if (space)
  {
    CFDataRef v4 = CGColorSpaceCopyICCData(space);
    if (v4)
    {
      CFDataRef v5 = v4;
      IOSurfaceSetValue(a1, (CFStringRef)*MEMORY[0x1E4F2F0F0], v4);
      CFRelease(v5);
    }
    CFPropertyListRef v6 = CGColorSpaceCopyPropertyList(space);
    if (v6)
    {
      uint64_t v7 = v6;
      IOSurfaceSetValue(a1, (CFStringRef)*MEMORY[0x1E4F2F068], v6);
      CFRelease(v7);
    }
    IOSurfaceSetBulkAttachments2();
    IOSurfaceSetValue(a1, (CFStringRef)*MEMORY[0x1E4F2F2C8], (CFTypeRef)*MEMORY[0x1E4F2F2D8]);
  }
}

__IOSurface *IIO_CreateBiPlanarIOSurfaceWithFormat(int a1, CGSize a2, CGSize a3, unsigned int a4, unsigned __int8 *a5, unsigned int a6, uint64_t a7, unsigned int a8, uint64_t a9, uint64_t a10, BOOL a11, task_t a12, int *a13)
{
  double height = a3.height;
  double width = a3.width;
  double v19 = a2.height;
  double v20 = a2.width;
  uint64_t v75 = 0;
  CFDictionaryRef v76 = 0;
  uint64_t v77 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v75);
  uint64_t v72 = 0;
  unsigned int v73 = 0;
  uint64_t v74 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v72);
  uint64_t v69 = 0;
  unsigned int v70 = 0;
  uint64_t v71 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v69);
  CFMutableArrayRef v66 = 0;
  size_t v67 = 0;
  uint64_t v68 = 0;
  IIOArray::IIOArray((IIOArray *)&v66);
  memory_object_size_t v65 = 0;
  long long v63 = 0u;
  *(_OWORD *)uint64_t v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  if (IIO_FillGeometry420(a1, a4, (uint64_t)&v61, v20, v19, width, height)) {
    goto LABEL_33;
  }
  IIONumber::IIONumber((IIONumber *)v60, v20);
  IIODictionary::setObjectForKey((uint64_t)&v75, (uint64_t)v60, (const void *)*MEMORY[0x1E4F2F2C0]);
  IIONumber::~IIONumber((IIONumber *)v60);
  IIONumber::IIONumber((IIONumber *)v59, v19);
  IIODictionary::setObjectForKey((uint64_t)&v75, (uint64_t)v59, (const void *)*MEMORY[0x1E4F2F0E8]);
  IIONumber::~IIONumber((IIONumber *)v59);
  IIONumber::IIONumber((IIONumber *)v58, a1);
  IIODictionary::setObjectForKey((uint64_t)&v75, (uint64_t)v58, (const void *)*MEMORY[0x1E4F2F150]);
  IIONumber::~IIONumber((IIONumber *)v58);
  IIONumber::IIONumber((IIONumber *)v57, v20);
  int v22 = (const void *)*MEMORY[0x1E4F2F258];
  IIODictionary::setObjectForKey((uint64_t)&v72, (uint64_t)v57, (const void *)*MEMORY[0x1E4F2F258]);
  IIONumber::~IIONumber((IIONumber *)v57);
  IIONumber::IIONumber((IIONumber *)v56, v19);
  uint64_t v23 = (const void *)*MEMORY[0x1E4F2F220];
  IIODictionary::setObjectForKey((uint64_t)&v72, (uint64_t)v56, (const void *)*MEMORY[0x1E4F2F220]);
  IIONumber::~IIONumber((IIONumber *)v56);
  int v24 = v62;
  IIONumber::IIONumber((IIONumber *)v55, v62);
  int v25 = (const void *)*MEMORY[0x1E4F2F170];
  IIODictionary::setObjectForKey((uint64_t)&v72, (uint64_t)v55, (const void *)*MEMORY[0x1E4F2F170]);
  IIONumber::~IIONumber((IIONumber *)v55);
  IIONumber::IIONumber((IIONumber *)v54, a7);
  unint64_t v26 = (const void *)*MEMORY[0x1E4F2F240];
  IIODictionary::setObjectForKey((uint64_t)&v72, (uint64_t)v54, (const void *)*MEMORY[0x1E4F2F240]);
  IIONumber::~IIONumber((IIONumber *)v54);
  uint64_t v27 = DWORD1(v62);
  IIONumber::IIONumber((IIONumber *)v53, SDWORD1(v62));
  int v28 = (const void *)*MEMORY[0x1E4F2F178];
  IIODictionary::setObjectForKey((uint64_t)&v72, (uint64_t)v53, (const void *)*MEMORY[0x1E4F2F178]);
  IIONumber::~IIONumber((IIONumber *)v53);
  double v29 = (double)a8;
  if (!a8) {
    double v29 = *((double *)&v61 + 1) * (double)v27;
  }
  uint64_t v30 = v29;
  if ((v30 & 0x80000000) != 0)
  {
    _cg_jpeg_mem_term("IIO_CreateBiPlanarIOSurfaceWithFormat", 702, "*** IOSurface does not support luma planeSize larger than INT32_MAX");
LABEL_33:
    BOOL v39 = 0;
LABEL_21:
    if (v39) {
      int v40 = 0;
    }
    else {
      int v40 = -50;
    }
    goto LABEL_27;
  }
  IIONumber::IIONumber((IIONumber *)v52, v29);
  uint64_t v31 = (const void *)*MEMORY[0x1E4F2F248];
  IIODictionary::setObjectForKey((uint64_t)&v72, (uint64_t)v52, (const void *)*MEMORY[0x1E4F2F248]);
  IIONumber::~IIONumber((IIONumber *)v52);
  IIOArray::addObject(&v66, v73);
  IIONumber::IIONumber((IIONumber *)v51, *((double *)&v62 + 1));
  IIODictionary::setObjectForKey((uint64_t)&v69, (uint64_t)v51, v22);
  IIONumber::~IIONumber((IIONumber *)v51);
  IIONumber::IIONumber((IIONumber *)v50, *(double *)&v63);
  IIODictionary::setObjectForKey((uint64_t)&v69, (uint64_t)v50, v23);
  IIONumber::~IIONumber((IIONumber *)v50);
  IIONumber::IIONumber((IIONumber *)v49, 2 * v24);
  IIODictionary::setObjectForKey((uint64_t)&v69, (uint64_t)v49, v25);
  IIONumber::~IIONumber((IIONumber *)v49);
  if (a9) {
    uint64_t v32 = a9;
  }
  else {
    uint64_t v32 = v30;
  }
  IIONumber::IIONumber((IIONumber *)v48, v32);
  IIODictionary::setObjectForKey((uint64_t)&v69, (uint64_t)v48, v26);
  IIONumber::~IIONumber((IIONumber *)v48);
  unsigned int v33 = v64[2];
  IIONumber::IIONumber((IIONumber *)v47, v64[2]);
  IIODictionary::setObjectForKey((uint64_t)&v69, (uint64_t)v47, v28);
  IIONumber::~IIONumber((IIONumber *)v47);
  double v34 = *(double *)v64 * (double)v33;
  unsigned int v35 = v34;
  if ((v34 & 0x80000000) != 0)
  {
    _cg_jpeg_mem_term("IIO_CreateBiPlanarIOSurfaceWithFormat", 717, "IOSurface does not support chroma planeSize larger than INT32_MAX");
    goto LABEL_33;
  }
  IIONumber::IIONumber((IIONumber *)v46, v34);
  IIODictionary::setObjectForKey((uint64_t)&v69, (uint64_t)v46, v31);
  IIONumber::~IIONumber((IIONumber *)v46);
  memory_object_size_t v36 = v35 + v30;
  if ((v36 & 0x80000000) != 0)
  {
    _cg_jpeg_mem_term("IIO_CreateBiPlanarIOSurfaceWithFormat", 720, "IOSurface does not support allocSize larger than INT32_MAX");
    goto LABEL_33;
  }
  IIOArray::addObject(&v66, v70);
  IIODictionary::setObjectForKey((IIODictionary *)&v75, v67, (const __CFString *)*MEMORY[0x1E4F2F238]);
  if (a5)
  {
    unsigned int v37 = 0;
    uint64_t v38 = a6;
  }
  else
  {
    if (!a11)
    {
      unsigned int v37 = 0;
      goto LABEL_18;
    }
    unsigned int v37 = (unsigned __int8 *)_ImageIO_Malloc(v36, 4, &v65, (uint64_t)kImageMalloc_IOSurface_Data, a12, 0, 0);
    uint64_t v38 = v65;
    a5 = v37;
  }
  if (a5 && v38)
  {
    IIONumber::IIONumber((IIONumber *)v44, v27);
    IIODictionary::setObjectForKey((IIODictionary *)&v75, value, (const __CFString *)*MEMORY[0x1E4F2EFE0]);
    IIONumber::~IIONumber((IIONumber *)v44);
    IIONumber::IIONumber((IIONumber *)v44, v38);
    IIODictionary::setObjectForKey((IIODictionary *)&v75, value, (const __CFString *)*MEMORY[0x1E4F2EFB8]);
    IIONumber::~IIONumber((IIONumber *)v44);
    IIONumber::IIONumber((IIONumber *)v44, (uint64_t)a5);
    IIODictionary::setObjectForKey((IIODictionary *)&v75, value, (const __CFString *)*MEMORY[0x1E4F2F040]);
    IIONumber::~IIONumber((IIONumber *)v44);
  }
LABEL_18:
  BOOL v39 = IOSurfaceCreate(v76);
  if (v39)
  {
    if (v37)
    {
      IIONumber::IIONumber((IIONumber *)v44, v65);
      IOSurfaceSetValue(v39, @"iosurface_plane_datasize", value);
      IIONumber::~IIONumber((IIONumber *)v44);
      IOSurfaceSetValue(v39, @"com.apple.ImageIO.ImageIO_Malloced", (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
    }
    goto LABEL_21;
  }
  LogError("IIO_CreateBiPlanarIOSurfaceWithFormat", 763, "*** ERROR: IOSurfaceCreate failed (kIOSurfaceClientAddress)\n");
  if (v37) {
    _ImageIO_Free((unint64_t)v37, v65);
  }
  BOOL v39 = 0;
  int v40 = -50;
LABEL_27:
  if (a13) {
    *a13 = v40;
  }
  IIOArray::~IIOArray((IIOArray *)&v66);
  IIODictionary::~IIODictionary((IIODictionary *)&v69);
  IIODictionary::~IIODictionary((IIODictionary *)&v72);
  IIODictionary::~IIODictionary((IIODictionary *)&v75);
  return v39;
}

void sub_188741BAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  IIONumber::~IIONumber((IIONumber *)va);
  IIOArray::~IIOArray((IIOArray *)(v3 - 216));
  IIODictionary::~IIODictionary((IIODictionary *)(v3 - 192));
  IIODictionary::~IIODictionary((IIODictionary *)(v3 - 168));
  IIODictionary::~IIODictionary((IIODictionary *)(v3 - 144));
  _Unwind_Resume(a1);
}

__IOSurface *IIO_CreateIOSurfaceWithFormatAndBuffer(unint64_t a1, unint64_t a2, unint64_t a3, int a4, unsigned __int8 *a5, uint64_t a6, BOOL a7, uint64_t a8)
{
  task_t v8 = a8;
  BOOL v9 = a7;
  unint64_t v12 = a3;
  v76[0] = 0;
  int v15 = a3 + 15;
  if (((a3 + 15) & 0xFFFFFFF0) != a3)
  {
    unsigned int v16 = a4 >> 24;
    uint64_t v17 = MEMORY[0x1E4F14390];
    if (a4 < 0)
    {
      uint64_t v19 = MEMORY[0x1E4F14390];
      int v18 = __maskrune(a4 >> 24, 0x40000uLL);
      uint64_t v17 = v19;
    }
    else
    {
      int v18 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v16 + 60) & 0x40000;
    }
    task_t v66 = v8;
    if (v18) {
      uint64_t v20 = v16;
    }
    else {
      uint64_t v20 = 46;
    }
    unsigned int v21 = a4 << 8 >> 24;
    unint64_t v22 = a1;
    if (a4 << 8 < 0)
    {
      uint64_t v24 = v17;
      int v23 = __maskrune(a4 << 8 >> 24, 0x40000uLL);
      uint64_t v17 = v24;
    }
    else
    {
      int v23 = *(_DWORD *)(v17 + 4 * v21 + 60) & 0x40000;
    }
    if (v23) {
      uint64_t v25 = v21;
    }
    else {
      uint64_t v25 = 46;
    }
    unsigned int v26 = (__int16)a4 >> 8;
    uint64_t v27 = a5;
    if (a4 << 16 < 0)
    {
      uint64_t v29 = v17;
      int v28 = __maskrune((__int16)a4 >> 8, 0x40000uLL);
      uint64_t v17 = v29;
    }
    else
    {
      int v28 = *(_DWORD *)(v17 + 4 * v26 + 60) & 0x40000;
    }
    unsigned int v30 = v15 & 0xFFFFFFF0;
    if (v28) {
      uint64_t v31 = v26;
    }
    else {
      uint64_t v31 = 46;
    }
    if ((a4 << 24) <= 0x7F000000) {
      int v32 = *(_DWORD *)(v17 + 4 * (char)a4 + 60) & 0x40000;
    }
    else {
      int v32 = __maskrune((char)a4, 0x40000uLL);
    }
    if (v32) {
      uint64_t v33 = (char)a4;
    }
    else {
      uint64_t v33 = 46;
    }
    _cg_jpeg_mem_term("IIO_CreateIOSurfaceWithFormatAndBuffer", 798, "*** IIO_CreateIOSurfaceWithFormatAndBuffer: '%c%c%c%c':  rowBytes: %d   alignedRowBytes: %d\n", v20, v25, v31, v33, v12, v30);
    a5 = v27;
    a1 = v22;
    BOOL v9 = a7;
    task_t v8 = v66;
  }
  if (a4 <= 1380410944)
  {
    if (a4 > 1278226487)
    {
      if (a4 == 1278226488)
      {
        unsigned int v35 = 1;
        goto LABEL_45;
      }
      int v34 = 1380401729;
    }
    else
    {
      if (a4 == 875704422) {
        goto LABEL_42;
      }
      int v34 = 1111970369;
    }
LABEL_40:
    if (a4 == v34)
    {
      unsigned int v35 = 4;
      goto LABEL_45;
    }
    goto LABEL_65;
  }
  if (a4 <= 1815162993)
  {
    if (a4 == 1380410945)
    {
      unsigned int v35 = 16;
      goto LABEL_45;
    }
    if (a4 != 1380411457)
    {
LABEL_65:
      unsigned int v46 = a4 >> 24;
      if (a4 < 0) {
        int v47 = __maskrune(a4 >> 24, 0x40000uLL);
      }
      else {
        int v47 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v46 + 60) & 0x40000;
      }
      if (v47) {
        uint64_t v55 = v46;
      }
      else {
        uint64_t v55 = 46;
      }
      unsigned int v56 = a4 << 8 >> 24;
      if (a4 << 8 < 0) {
        int v57 = __maskrune(a4 << 8 >> 24, 0x40000uLL);
      }
      else {
        int v57 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v56 + 60) & 0x40000;
      }
      if (v57) {
        uint64_t v58 = v56;
      }
      else {
        uint64_t v58 = 46;
      }
      unsigned int v59 = (__int16)a4 >> 8;
      if (a4 << 16 < 0) {
        int v60 = __maskrune((__int16)a4 >> 8, 0x40000uLL);
      }
      else {
        int v60 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v59 + 60) & 0x40000;
      }
      if (v60) {
        uint64_t v61 = v59;
      }
      else {
        uint64_t v61 = 46;
      }
      if ((a4 << 24) <= 0x7F000000) {
        int v62 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)a4 + 60) & 0x40000;
      }
      else {
        int v62 = __maskrune((char)a4, 0x40000uLL);
      }
      if (v62) {
        uint64_t v63 = (char)a4;
      }
      else {
        uint64_t v63 = 46;
      }
      _cg_jpeg_mem_term("IIO_CreateIOSurfaceWithFormatAndBuffer", 827, "*** pixelFormat: '%c%c%c%c' not handled\n", v55, v58, v61, v63);
      BiPlanarIOSurfaceWithFormat = 0;
LABEL_109:
      uint64_t v38 = a5;
      if (a5) {
        return BiPlanarIOSurfaceWithFormat;
      }
LABEL_110:
      if (v38 && !BiPlanarIOSurfaceWithFormat) {
        _ImageIO_Free((unint64_t)v38, v76[0]);
      }
      return BiPlanarIOSurfaceWithFormat;
    }
    goto LABEL_37;
  }
  if (a4 == 2019963440)
  {
LABEL_42:
    v73[0] = 0;
    v77.double width = (double)a1;
    v77.double height = (double)a2;
    v78.double width = 16.0;
    v78.double height = 16.0;
    BiPlanarIOSurfaceWithFormat = IIO_CreateBiPlanarIOSurfaceWithFormat(a4, v77, v78, 0x10u, 0, 0, 0, 0, 0, a8, v9, v8, v73);
    goto LABEL_109;
  }
  if (a4 != 1815491698)
  {
    int v34 = 1815162994;
    goto LABEL_40;
  }
LABEL_37:
  unsigned int v35 = 8;
LABEL_45:
  if (a5 || !v9)
  {
    v76[0] = a6;
    uint64_t v38 = a5;
  }
  else
  {
    if (!v12) {
      unint64_t v12 = (v35 * a1 + 15) & 0xFFFFFFFFFFFFFFF0;
    }
    if (!is_mul_ok(a2, v12)) {
      return 0;
    }
    a6 = a2 * v12;
    memory_object_offset_t v37 = _ImageIO_Malloc(a2 * v12, 0, v76, (uint64_t)kImageMalloc_IOSurface_Data, v8, 0, 0);
    if (!v37) {
      return 0;
    }
    uint64_t v38 = (unsigned __int8 *)v37;
  }
  *(void *)unsigned int v73 = 0;
  CFDictionaryRef v74 = 0;
  uint64_t v75 = 0;
  IIODictionary::IIODictionary((IIODictionary *)v73);
  IIONumber::IIONumber((IIONumber *)v71, a1);
  IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E4F2F2C0]);
  IIONumber::~IIONumber((IIONumber *)v71);
  IIONumber::IIONumber((IIONumber *)v71, a2);
  IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E4F2F0E8]);
  IIONumber::~IIONumber((IIONumber *)v71);
  IIONumber::IIONumber((IIONumber *)v71, a4);
  IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E4F2F150]);
  IIONumber::~IIONumber((IIONumber *)v71);
  IIONumber::IIONumber((IIONumber *)v71, v35);
  IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E4F2EFD8]);
  IIONumber::~IIONumber((IIONumber *)v71);
  IIONumber::IIONumber((IIONumber *)v71, 2);
  IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E4F2F100]);
  IIONumber::~IIONumber((IIONumber *)v71);
  int v39 = a5 != 0 || v9;
  unsigned int v67 = v35;
  if (v39 == 1)
  {
    v76[0] = a6;
    IIONumber::IIONumber((IIONumber *)v71, v12);
    IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E4F2EFE0]);
    IIONumber::~IIONumber((IIONumber *)v71);
    IIONumber::IIONumber((IIONumber *)v71, a6);
    IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E4F2EFB8]);
    IIONumber::~IIONumber((IIONumber *)v71);
    IIONumber::IIONumber((IIONumber *)v71, (uint64_t)v38);
    IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E4F2F040]);
    IIONumber::~IIONumber((IIONumber *)v71);
    IIONumber::IIONumber((IIONumber *)v71, 0);
    IIODictionary::setObjectForKey((IIODictionary *)v73, value, (const __CFString *)*MEMORY[0x1E4F2F240]);
    int v40 = a2;
    IIONumber::~IIONumber((IIONumber *)v71);
  }
  else
  {
    int v40 = a2;
    a6 = 0;
    LODWORD(v12) = 0;
  }
  int v41 = IOSurfaceCreate(v74);
  BiPlanarIOSurfaceWithFormat = v41;
  if (v41)
  {
    if (v39) {
      IOSurfaceSetValue(v41, @"com.apple.ImageIO.ImageIO_Malloced", (CFTypeRef)*MEMORY[0x1E4F1CFD0]);
    }
  }
  else
  {
    LODWORD(v42) = HIBYTE(a4);
    uint64_t v43 = MEMORY[0x1E4F14390];
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * HIBYTE(a4) + 60) & 0x40000) != 0) {
      uint64_t v42 = v42;
    }
    else {
      uint64_t v42 = 46;
    }
    uint64_t v69 = v42;
    unsigned int v44 = a4 << 8 >> 24;
    if (a4 << 8 < 0) {
      int v45 = __maskrune(a4 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v45 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v44 + 60) & 0x40000;
    }
    if (v45) {
      uint64_t v48 = v44;
    }
    else {
      uint64_t v48 = 46;
    }
    uint64_t v65 = v48;
    unsigned int v49 = (__int16)a4 >> 8;
    if (a4 << 16 < 0)
    {
      int v51 = __maskrune((__int16)a4 >> 8, 0x40000uLL);
      uint64_t v50 = v43;
    }
    else
    {
      uint64_t v50 = v43;
      int v51 = *(_DWORD *)(v43 + 4 * v49 + 60) & 0x40000;
    }
    if ((a4 << 24) <= 0x7F000000) {
      int v52 = *(_DWORD *)(v50 + 4 * (char)a4 + 60) & 0x40000;
    }
    else {
      int v52 = __maskrune((char)a4, 0x40000uLL);
    }
    if (v51) {
      uint64_t v53 = v49;
    }
    else {
      uint64_t v53 = 46;
    }
    if (v52) {
      uint64_t v54 = (char)a4;
    }
    else {
      uint64_t v54 = 46;
    }
    LogError("IIO_CreateIOSurfaceWithFormatAndBuffer", 887, "*** ERROR: IOSurfaceCreate '%c%c%c%c' failed - clientAddress: %p allocSize: 0x%08lx  size: %d x %d  rb: %d [0x%08x]  bpp: %d\n", v69, v65, v53, v54, v38, a6, a1, v40, v12, v12, v67);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v73);
  if (!a5) {
    goto LABEL_110;
  }
  return BiPlanarIOSurfaceWithFormat;
}

void sub_188742488(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v17 - 120));
  _Unwind_Resume(a1);
}

__IOSurface *IIO_CreateIOSurfaceWithFormat(unint64_t a1, unint64_t a2, unint64_t a3, int a4, BOOL a5, uint64_t a6)
{
  return IIO_CreateIOSurfaceWithFormatAndBuffer(a1, a2, a3, a4, 0, 0, a5, a6);
}

void IIO_CreateOutputSurfaceWithFormat()
{
}

void sub_1887425A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void IIO_CreateIOSurfaceWithPixelBufferAttributes(const __CFDictionary *a1)
{
  memset(v1, 0, sizeof(v1));
  IIODictionary::IIODictionary((IIODictionary *)v1, a1);
  IIODictionary::getUint32ForKey((IIODictionary *)v1, *(const __CFString **)gIIO_kCVPixelBufferWidthKey);
  IIODictionary::getUint32ForKey((IIODictionary *)v1, *(const __CFString **)gIIO_kCVPixelBufferHeightKey);
  IIODictionary::getUint32ForKey((IIODictionary *)v1, *(const __CFString **)gIIO_kCVPixelBufferPixelFormatTypeKey);
  IIO_CreateIOSurfaceProperties();
}

void sub_1887427A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  IIOString::~IIOString((IIOString *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

__IOSurface *IIO_CreateIOSurfaceFromImage(CGImage *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  int64_t BitsPerComponent = CGImageGetBitsPerComponent(a1);
  CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(a1);
  CGBitmapInfo v6 = CGImageGetBitmapInfo(a1) & 0xF00;
  if (BitsPerComponent > 15)
  {
    if (BitsPerComponent == 16) {
      goto LABEL_14;
    }
    if (BitsPerComponent != 32)
    {
LABEL_16:
      _cg_jpeg_mem_term("IIO_CreateIOSurfaceFromImage", 1255, "*** ERROR: unhandled bitDepth '%d'\n", BitsPerComponent);
      unsigned int v7 = 0;
      goto LABEL_17;
    }
    size_t Width = CGImageGetWidth(a1);
    size_t Height = CGImageGetHeight(a1);
    size_t BytesPerRow = CGImageGetBytesPerRow(a1);
    IOSurfaceWithFormatAndBuffer = IIO_CreateIOSurfaceWithFormatAndBuffer(Width, Height, BytesPerRow, 1380410945, 0, 0, 0, a2);
    if (!IOSurfaceWithFormatAndBuffer)
    {
      _cg_jpeg_mem_term("IIO_create_RGfA_IOSurfaceFromImage", 1148, "*** ERROR: failed to create IOSurface from image data provider(%p)\n", a1);
      return IOSurfaceWithFormatAndBuffer;
    }
    CGDataProviderRef DataProvider = CGImageGetDataProvider(a1);
    size_t v13 = IOSurfaceGetHeight(IOSurfaceWithFormatAndBuffer);
    size_t v14 = IOSurfaceGetBytesPerRow(IOSurfaceWithFormatAndBuffer);
    if (IOSurfaceLock(IOSurfaceWithFormatAndBuffer, 0, 0))
    {
LABEL_56:
      CGColorSpaceRef ColorSpace = CGImageGetColorSpace(a1);
      IIO_IOSurfaceAddColorSpace(IOSurfaceWithFormatAndBuffer, ColorSpace);
      return IOSurfaceWithFormatAndBuffer;
    }
    BaseAddress = (char *)IOSurfaceGetBaseAddress(IOSurfaceWithFormatAndBuffer);
    if (CGDataProviderGetSizeOfData() == -1)
    {
      size_t v35 = v13;
      size_t Length = BytesPerRow * Height;
      uint64_t v20 = (UInt8 *)malloc_type_malloc(BytesPerRow * Height, 0x160625F2uLL);
      CGDataProviderRewind();
      CGDataProviderGetBytes();
      CFDataRef v17 = 0;
      BytePtr = v20;
    }
    else
    {
      CFDataRef v16 = CGDataProviderCopyData(DataProvider);
      if (!v16)
      {
LABEL_55:
        IOSurfaceUnlock(IOSurfaceWithFormatAndBuffer, 0, 0);
        goto LABEL_56;
      }
      CFDataRef v17 = v16;
      size_t v35 = v13;
      BytePtr = CFDataGetBytePtr(v16);
      size_t Length = CFDataGetLength(v17);
      uint64_t v20 = 0;
    }
    if (BytePtr && Length)
    {
      if (v14 * v35 == BytesPerRow * Height)
      {
        memcpy(BaseAddress, BytePtr, Length);
      }
      else
      {
        if (BytesPerRow >= v14) {
          size_t v33 = v14;
        }
        else {
          size_t v33 = BytesPerRow;
        }
        for (; Height; --Height)
        {
          memcpy(BaseAddress, BytePtr, v33);
          BytePtr += BytesPerRow;
          BaseAddress += v14;
        }
      }
    }
    if (v20) {
      free(v20);
    }
    if (v17) {
      CFRelease(v17);
    }
    goto LABEL_55;
  }
  if (BitsPerComponent == 8)
  {
    CGColorSpaceRef v29 = CGImageGetColorSpace(a1);
    unsigned int v30 = (CGColorSpace *)CFRetain(v29);
    uint64_t v31 = v30;
    if (v30 && CGColorSpaceGetModel(v30) != kCGColorSpaceModelRGB)
    {
      CGColorSpaceRelease(v31);
      CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
    }
    CGImageAlphaInfo v32 = CGImageGetAlphaInfo(a1);
    _AlphaPosition(v32);
    operator new();
  }
  if (BitsPerComponent != 10) {
    goto LABEL_16;
  }
  if (AlphaInfo == kCGImageAlphaNone)
  {
    unsigned int v7 = 1815162994;
LABEL_17:
    LODWORD(v23) = HIBYTE(v7);
    uint64_t v24 = MEMORY[0x1E4F14390] + 60;
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 60 + 4 * HIBYTE(v7)) & 0x40000) != 0) {
      uint64_t v23 = v23;
    }
    else {
      uint64_t v23 = 46;
    }
    LODWORD(v25) = HIWORD(v7) & 0x31;
    if ((*(_DWORD *)(v24 + 4 * v25) & 0x40000) != 0) {
      uint64_t v25 = v25;
    }
    else {
      uint64_t v25 = 46;
    }
    LODWORD(v26) = (v7 >> 8) & 0x30;
    if ((*(_DWORD *)(v24 + 4 * v26) & 0x40000) != 0) {
      uint64_t v26 = v26;
    }
    else {
      uint64_t v26 = 46;
    }
    LODWORD(v27) = v7 & 0x72;
    if ((*(_DWORD *)(v24 + 4 * v27) & 0x40000) != 0) {
      uint64_t v27 = v27;
    }
    else {
      uint64_t v27 = 46;
    }
    _cg_jpeg_mem_term("IIO_CreateIOSurfaceFromImage", 1279, "*** ERROR: unhandled pixelFormat: '%c%c%c%c'\n", v23, v25, v26, v27);
    return 0;
  }
LABEL_14:
  if (v6 == 256)
  {
    int v21 = 1380411457;
    unint64_t v22 = a1;
  }
  else
  {
    unint64_t v22 = a1;
    int v21 = 1815491698;
  }

  return IIO_create_RGhA_IOSurfaceFromImage(v22, v21, a2);
}

void sub_188742D40(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C4054C77265);
  _Unwind_Resume(a1);
}

__IOSurface *IIO_create_RGhA_IOSurfaceFromImage(CGImage *a1, int a2, uint64_t a3)
{
  size_t Width = CGImageGetWidth(a1);
  size_t Height = CGImageGetHeight(a1);
  size_t BytesPerRow = CGImageGetBytesPerRow(a1);
  IOSurfaceWithFormatAndBuffer = IIO_CreateIOSurfaceWithFormatAndBuffer(Width, Height, BytesPerRow, a2, 0, 0, 0, a3);
  if (IOSurfaceWithFormatAndBuffer)
  {
    CGDataProviderRef DataProvider = CGImageGetDataProvider(a1);
    size_t v11 = IOSurfaceGetHeight(IOSurfaceWithFormatAndBuffer);
    size_t v12 = IOSurfaceGetBytesPerRow(IOSurfaceWithFormatAndBuffer);
    if (IOSurfaceLock(IOSurfaceWithFormatAndBuffer, 0, 0))
    {
LABEL_22:
      CGColorSpaceRef ColorSpace = CGImageGetColorSpace(a1);
      IIO_IOSurfaceAddColorSpace(IOSurfaceWithFormatAndBuffer, ColorSpace);
      return IOSurfaceWithFormatAndBuffer;
    }
    BaseAddress = (char *)IOSurfaceGetBaseAddress(IOSurfaceWithFormatAndBuffer);
    if (CGDataProviderGetSizeOfData() == -1)
    {
      size_t v22 = v11;
      size_t Length = BytesPerRow * Height;
      int v18 = (UInt8 *)malloc_type_malloc(BytesPerRow * Height, 0xAE52A0EBuLL);
      CGDataProviderRewind();
      CGDataProviderGetBytes();
      CFDataRef v15 = 0;
      BytePtr = v18;
      if (!v18) {
        goto LABEL_17;
      }
    }
    else
    {
      CFDataRef v14 = CGDataProviderCopyData(DataProvider);
      if (!v14)
      {
LABEL_21:
        IOSurfaceUnlock(IOSurfaceWithFormatAndBuffer, 0, 0);
        goto LABEL_22;
      }
      CFDataRef v15 = v14;
      size_t v22 = v11;
      BytePtr = CFDataGetBytePtr(v14);
      size_t Length = CFDataGetLength(v15);
      int v18 = 0;
      if (!BytePtr)
      {
LABEL_17:
        if (v18) {
          free(v18);
        }
        if (v15) {
          CFRelease(v15);
        }
        goto LABEL_21;
      }
    }
    if (Length)
    {
      if (v12 * v22 == BytesPerRow * Height)
      {
        memcpy(BaseAddress, BytePtr, Length);
      }
      else
      {
        if (BytesPerRow >= v12) {
          size_t v19 = v12;
        }
        else {
          size_t v19 = BytesPerRow;
        }
        for (; Height; --Height)
        {
          memcpy(BaseAddress, BytePtr, v19);
          BytePtr += BytesPerRow;
          BaseAddress += v12;
        }
      }
    }
    goto LABEL_17;
  }
  _cg_jpeg_mem_term("IIO_create_RGhA_IOSurfaceFromImage", 1055, "*** ERROR: failed to create IOSurface from image data provider(%p)\n", a1);
  return IOSurfaceWithFormatAndBuffer;
}

__IOSurface *IIO_CreateIOSurfaceFromBlockSet(uint64_t a1, const __CFDictionary *a2)
{
  uint64_t v31 = 0;
  CFDictionaryRef v32 = 0;
  uint64_t v33 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v31);
  memset(v30, 0, sizeof(v30));
  IIODictionary::IIODictionary((IIODictionary *)v30, a2);
  if (CGImageBlockSetGetCount() != 1)
  {
    LogError("IIO_CreateIOSurfaceFromBlockSet", 1307, "   _createIOSurfaceFromBlockSet != 1");
    goto LABEL_38;
  }
  uint64_t Property = CGImageBlockSetGetProperty();
  if (Property) {
    BOOL v4 = Property == *MEMORY[0x1E4F1CFD0];
  }
  else {
    BOOL v4 = 1;
  }
  int v5 = v4;
  Componentint Type = CGImageBlockSetGetComponentType();
  Pixelunint64_t Size = CGImageBlockSetGetPixelSize();
  unsigned int v8 = 1380411457;
  int v9 = PixelSize;
  if (ComponentType == 5)
  {
    BOOL BoolForKey = 0;
  }
  else
  {
    if (ComponentType != 2)
    {
      if (ComponentType == 1)
      {
        if (PixelSize == 4)
        {
          BOOL BoolForKey = 0;
          unsigned int v8 = 1111970369;
          goto LABEL_18;
        }
        _cg_jpeg_mem_term("IIO_CreateIOSurfaceFromBlockSet", 1328, "*** ERROR can't handle RGB-888 input (pixelSize=%d) (componentType=%d)\n");
      }
      else
      {
        _cg_jpeg_mem_term("IIO_CreateIOSurfaceFromBlockSet", 1357, "*** ERROR can't handle non-RGBA input (pixelSize=%d) (componentType=%d)\n");
      }
LABEL_38:
      CFDataRef v16 = 0;
      goto LABEL_39;
    }
    BOOL BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v30, @"kCGImageSourceShouldAllowFloat");
    if (BoolForKey) {
      unsigned int v8 = 1380411457;
    }
    else {
      unsigned int v8 = 1815491698;
    }
  }
LABEL_18:
  CGImageBlockSetGetImageBlock();
  CGImageBlockGetRect();
  double v12 = v11;
  double v14 = v13;
  IIONumber::IIONumber((IIONumber *)&src, v8);
  IIODictionary::setObjectForKey((IIODictionary *)&v31, (const void *)src.width, (const __CFString *)*MEMORY[0x1E4F2F150]);
  IIONumber::~IIONumber((IIONumber *)&src);
  IIONumber::IIONumber((IIONumber *)&src, v12);
  IIODictionary::setObjectForKey((IIODictionary *)&v31, (const void *)src.width, (const __CFString *)*MEMORY[0x1E4F2F2C0]);
  IIONumber::~IIONumber((IIONumber *)&src);
  IIONumber::IIONumber((IIONumber *)&src, v14);
  IIODictionary::setObjectForKey((IIODictionary *)&v31, (const void *)src.width, (const __CFString *)*MEMORY[0x1E4F2F0E8]);
  IIONumber::~IIONumber((IIONumber *)&src);
  unsigned int BytesPerRow = CGImageBlockGetBytesPerRow();
  IIONumber::IIONumber((IIONumber *)&src, BytesPerRow);
  IIODictionary::setObjectForKey((IIODictionary *)&v31, (const void *)src.width, (const __CFString *)*MEMORY[0x1E4F2EFE0]);
  IIONumber::~IIONumber((IIONumber *)&src);
  IIONumber::IIONumber((IIONumber *)&src, v9);
  IIODictionary::setObjectForKey((IIODictionary *)&v31, (const void *)src.width, (const __CFString *)*MEMORY[0x1E4F2EFD8]);
  IIONumber::~IIONumber((IIONumber *)&src);
  CFDataRef v16 = IOSurfaceCreate(v32);
  if (!v16)
  {
    LODWORD(v19) = HIBYTE(v8);
    uint64_t v20 = MEMORY[0x1E4F14390] + 60;
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 60 + 4 * HIBYTE(v8)) & 0x40000) != 0) {
      uint64_t v19 = v19;
    }
    else {
      uint64_t v19 = 46;
    }
    LODWORD(v21) = HIWORD(v8) & 0x77;
    BOOL v4 = (*(_DWORD *)(v20 + 4 * v21) & 0x40000) == 0;
    LODWORD(v22) = (v8 >> 8) & 0x7E;
    int v23 = *(_DWORD *)(v20 + 4 * v22);
    int v24 = *(_DWORD *)(v20 + 4 * (v8 & 0x73));
    if (v4) {
      uint64_t v21 = 46;
    }
    else {
      uint64_t v21 = v21;
    }
    if ((v23 & 0x40000) != 0) {
      uint64_t v22 = v22;
    }
    else {
      uint64_t v22 = 46;
    }
    if ((v24 & 0x40000) != 0) {
      uint64_t v25 = v8 & 0x73;
    }
    else {
      uint64_t v25 = 46;
    }
    LogError("IIO_CreateIOSurfaceFromBlockSet", 1434, "*** IOSurfaceCreate failed for '%c%c%c%c' (%d x %d   rb:%d)\n", v19, v21, v22, v25, v12, v14, BytesPerRow);
    goto LABEL_38;
  }
  uint64_t Data = (void *)CGImageBlockGetData();
  if (!IOSurfaceLock(v16, 0, 0))
  {
    BaseAddress = IOSurfaceGetBaseAddress(v16);
    if (BaseAddress)
    {
      if (BoolForKey)
      {
        src.data = Data;
        src.double height = v14;
        src.double width = 4 * v12;
        src.size_t rowBytes = BytesPerRow;
        dest.data = BaseAddress;
        dest.double height = src.height;
        dest.double width = src.width;
        dest.size_t rowBytes = BytesPerRow;
        vImageConvert_16Uto16F(&src, &dest, 0);
      }
      else if (v9 == 4 && !v5)
      {
        *(_DWORD *)permuteMap = 50331906;
        src.data = Data;
        src.double height = v14;
        src.double width = v12;
        src.size_t rowBytes = BytesPerRow;
        dest.data = BaseAddress;
        dest.double height = src.height;
        dest.double width = src.width;
        dest.size_t rowBytes = BytesPerRow;
        vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0x10u);
      }
      else
      {
        memcpy(BaseAddress, Data, BytesPerRow * v14);
      }
    }
    IOSurfaceUnlock(v16, 0, 0);
  }
LABEL_39:
  IIODictionary::~IIODictionary((IIODictionary *)v30);
  IIODictionary::~IIODictionary((IIODictionary *)&v31);
  return v16;
}

void sub_18874337C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v17 - 120));
  _Unwind_Resume(a1);
}

uint64_t IIO_IOSurfaceGetAlpha(__IOSurface *a1)
{
  IIO_LoadJPEGSymbols();
  if (!a1)
  {
    unsigned int v5 = 0;
    uint64_t v4 = 0;
    int v3 = 0;
    if ((gIIODebugFlags & 0x40000000000) == 0) {
      return v4;
    }
    goto LABEL_50;
  }
  signed int PixelFormat = IOSurfaceGetPixelFormat(a1);
  int v3 = PixelFormat;
  uint64_t v4 = 0;
  if (PixelFormat > 1815162993)
  {
    if (PixelFormat <= 2016687155)
    {
      if (PixelFormat <= 1999843441)
      {
        if (PixelFormat != 1815162994)
        {
          int v6 = 1983066168;
          goto LABEL_33;
        }
      }
      else if (PixelFormat != 1999843442)
      {
        if (PixelFormat == 2016686640) {
          goto LABEL_48;
        }
        int v6 = 2016686642;
        goto LABEL_33;
      }
LABEL_39:
      uint64_t v4 = 5;
      goto LABEL_48;
    }
    if (PixelFormat > 2019963955)
    {
      if (PixelFormat == 2019963956 || PixelFormat == 2037741158) {
        goto LABEL_48;
      }
      int v6 = 2037741171;
    }
    else
    {
      if (PixelFormat == 2016687156 || PixelFormat == 2019963440) {
        goto LABEL_48;
      }
      int v6 = 2019963442;
    }
LABEL_33:
    if (PixelFormat == v6) {
      goto LABEL_48;
    }
LABEL_34:
    CFDictionaryRef v7 = IOSurfaceCopyAllValues(a1);
    if (!v7)
    {
      uint64_t v4 = 0;
      goto LABEL_48;
    }
    CFDictionaryRef v8 = v7;
    memset(v23, 0, sizeof(v23));
    IIODictionary::IIODictionary((IIODictionary *)v23, v7);
    uint64_t v4 = 0;
    if (IOSurfaceGetBulkAttachments()) {
      goto LABEL_47;
    }
    if (IIODictionary::containsKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelIsOpaque)&& IIODictionary::getBoolForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelIsOpaque))
    {
      IIODictionary::~IIODictionary((IIODictionary *)v23);
      goto LABEL_39;
    }
    if (IIODictionary::containsKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelModeKey))
    {
      CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCVImageBufferAlphaChannelModeKey);
      if (CFEqual(ObjectForKey, *(CFStringRef *)gIIO_kCVImageBufferAlphaChannelMode_PremultipliedAlpha))
      {
        LogError("IIO_IOSurfaceGetAlpha", 1954, "*** ERROR: IOSurface kCVImageBufferAlphaChannelMode_PremultipliedAlpha, but keys.premultipliedAlpha = %d\n", 0);
        uint64_t v4 = 1;
        goto LABEL_47;
      }
      if (CFEqual(ObjectForKey, *(CFStringRef *)gIIO_kCVImageBufferAlphaChannelMode_StraightAlpha))
      {
        LogError("IIO_IOSurfaceGetAlpha", 1960, "*** ERROR: IOSurface kCVImageBufferAlphaChannelMode_StraightAlpha, but keys.premultipliedAlpha = %d\n", 0);
        uint64_t v4 = 3;
        goto LABEL_47;
      }
    }
    uint64_t v4 = 0;
LABEL_47:
    CFRelease(v8);
    IIODictionary::~IIODictionary((IIODictionary *)v23);
    goto LABEL_48;
  }
  if (PixelFormat <= 1278226487)
  {
    if (PixelFormat <= 846624120)
    {
      if (PixelFormat == 24) {
        goto LABEL_48;
      }
      int v6 = 846624102;
    }
    else
    {
      if (PixelFormat == 846624121 || PixelFormat == 875704422) {
        goto LABEL_48;
      }
      int v6 = 875704438;
    }
    goto LABEL_33;
  }
  if (PixelFormat > 1278226735)
  {
    if (PixelFormat == 1278226736 || PixelFormat == 1278226742) {
      goto LABEL_48;
    }
    int v6 = 1714630712;
    goto LABEL_33;
  }
  if ((PixelFormat - 1278226488) > 0x30
    || ((1 << (PixelFormat - 56)) & 0x1400000000001) == 0)
  {
    goto LABEL_34;
  }
LABEL_48:
  if ((gIIODebugFlags & 0x40000000000) == 0) {
    return v4;
  }
  unsigned int v5 = v3 >> 24;
  if (v3 < 0)
  {
    int v10 = __maskrune(v3 >> 24, 0x40000uLL);
    goto LABEL_52;
  }
LABEL_50:
  int v10 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v5 + 60) & 0x40000;
LABEL_52:
  if (v10) {
    uint64_t v11 = v5;
  }
  else {
    uint64_t v11 = 46;
  }
  unsigned int v12 = v3 << 8 >> 24;
  uint64_t v13 = MEMORY[0x1E4F14390];
  if (v3 << 8 < 0) {
    int v14 = __maskrune(v3 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v14 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x40000;
  }
  if (v14) {
    uint64_t v15 = v12;
  }
  else {
    uint64_t v15 = 46;
  }
  unsigned int v16 = (__int16)v3 >> 8;
  if (v3 << 16 < 0) {
    int v17 = __maskrune((__int16)v3 >> 8, 0x40000uLL);
  }
  else {
    int v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
  }
  if (v17) {
    uint64_t v18 = v16;
  }
  else {
    uint64_t v18 = 46;
  }
  if ((v3 << 24) <= 0x7F000000) {
    int v19 = *(_DWORD *)(v13 + 4 * (char)v3 + 60) & 0x40000;
  }
  else {
    int v19 = __maskrune((char)v3, 0x40000uLL);
  }
  if (v19) {
    uint64_t v20 = (char)v3;
  }
  else {
    uint64_t v20 = 46;
  }
  uint64_t v21 = IIO_AlphaInfoString(v4);
  ImageIOLog("  IIO_IOSurfaceGetAlpha <IOSurface:  %p> '%c%c%c%c' -  alpha:%s\n", a1, v11, v15, v18, v20, v21);
  return v4;
}

void sub_1887438C8(_Unwind_Exception *a1)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 104));
  _Unwind_Resume(a1);
}

uint64_t IIO_IOSurfaceSetAlpha(__IOSurface *a1, CGImageAlphaInfo a2)
{
  int v19 = 0;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  uint64_t v11 = 116;
  if (IOSurfaceGetBulkAttachments())
  {
    int v19 = 0;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v12 = 0u;
  }
  if (a2 - 1 <= 1)
  {
    BYTE4(v18) = 2;
    uint64_t v4 = &gIIO_kCVImageBufferAlphaChannelMode_PremultipliedAlpha;
LABEL_7:
    unsigned int v5 = (CFTypeRef *)*v4;
    int v6 = &gIIO_kCVImageBufferAlphaChannelModeKey;
LABEL_8:
    IOSurfaceSetValue(a1, *(CFStringRef *)*v6, *v5);
    goto LABEL_9;
  }
  if (a2 - 3 <= 1)
  {
    BYTE4(v18) = 1;
    uint64_t v4 = &gIIO_kCVImageBufferAlphaChannelMode_StraightAlpha;
    goto LABEL_7;
  }
  BYTE4(v18) = 0;
  if (a2)
  {
    int v6 = &gIIO_kCVImageBufferAlphaChannelIsOpaque;
    unsigned int v5 = (CFTypeRef *)MEMORY[0x1E4F1CFD0];
    goto LABEL_8;
  }
LABEL_9:
  IOSurfaceSetBulkAttachments2();
  memset(&__p, 0, sizeof(__p));
  std::string::basic_string[abi:ne180100]<0>(&__p, "IIO_IOSurfaceSetAlpha ");
  CFDictionaryRef v7 = IIO_AlphaInfoString(a2);
  std::string::append(&__p, v7);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  IIO_IOSurfaceLogAlphaInfo(a1, (const char *)p_p);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  return 0;
}

void sub_188743A4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

vImage_Error IIO_IOSurfacePremultiply(__IOSurface *a1)
{
  int Alpha = IIO_IOSurfaceGetAlpha(a1);
  OSType PixelFormat = IOSurfaceGetPixelFormat(a1);
  if (Alpha != 3) {
    return -50;
  }
  int v4 = PixelFormat;
  if (IOSurfaceLock(a1, 0, 0)) {
    return -50;
  }
  vImagePixelCount Width = IOSurfaceGetWidth(a1);
  vImagePixelCount Height = IOSurfaceGetHeight(a1);
  size_t BytesPerRow = IOSurfaceGetBytesPerRow(a1);
  v11.data = IOSurfaceGetBaseAddress(a1);
  v11.double height = Height;
  v11.double width = Width;
  v11.size_t rowBytes = BytesPerRow;
  if (v4 <= 1380411456)
  {
    if (v4 == 1111970369 || v4 == 1380401729)
    {
      vImage_Error v10 = vImagePremultiplyData_RGBA8888(&v11, &v11, 0x10u);
      goto LABEL_13;
    }
LABEL_15:
    IOSurfaceUnlock(a1, 0, 0);
    return -50;
  }
  if (v4 == 1380411457)
  {
    vImage_Error v10 = vImagePremultiplyData_RGBA16F(&v11, &v11, 0x10u);
  }
  else
  {
    if (v4 != 1815491698) {
      goto LABEL_15;
    }
    vImage_Error v10 = vImagePremultiplyData_RGBA16U(&v11, &v11, 0x10u);
  }
LABEL_13:
  vImage_Error v5 = v10;
  IOSurfaceUnlock(a1, 0, 0);
  if (!v5) {
    IIO_IOSurfaceSetAlpha(a1, kCGImageAlphaPremultipliedLast);
  }
  return v5;
}

vImage_Error IIOSurfaceCopyAlphaValuesFromSource(__IOSurface *a1, __IOSurface *a2)
{
  int Alpha = IIO_IOSurfaceGetAlpha(a1);
  IIO_IOSurfaceGetAlpha(a2);
  vImage_Error v5 = 0;
  if (!Alpha || Alpha == 5) {
    return v5;
  }
  signed int PixelFormat = IOSurfaceGetPixelFormat(a1);
  signed int v7 = IOSurfaceGetPixelFormat(a2);
  int v8 = v7;
  if (PixelFormat <= 1380411456)
  {
    if (PixelFormat != 1111970369)
    {
      unsigned __int16 v9 = 16961;
      goto LABEL_8;
    }
LABEL_9:
    if (v7 > 1380411456)
    {
      if (v7 == 1380411457) {
        goto LABEL_15;
      }
      int v10 = 1815491698;
    }
    else
    {
      if (v7 == 1111970369) {
        goto LABEL_15;
      }
      int v10 = 1380401729;
    }
    if (v7 == v10)
    {
LABEL_15:
      vImagePixelCount Width = IOSurfaceGetWidth(a1);
      vImagePixelCount v12 = IOSurfaceGetWidth(a2);
      size_t Height = IOSurfaceGetHeight(a1);
      IOSurfaceGetHeight(a2);
      size_t BytesPerRow = IOSurfaceGetBytesPerRow(a1);
      size_t v15 = IOSurfaceGetBytesPerRow(a2);
      unsigned int v16 = IIO_BitsPerComponentForPixelFormat(PixelFormat);
      unsigned int v17 = IIO_BitsPerComponentForPixelFormat(v8);
      long long v18 = malloc_type_malloc(BytesPerRow, 0x9550678BuLL);
      uint64_t v64 = malloc_type_malloc(v15, 0xFFBE2A92uLL);
      if (IOSurfaceLock(a1, 1u, 0))
      {
        vImage_Error v5 = 0;
LABEL_111:
        free(v18);
        free(v64);
        return v5;
      }
      size_t v66 = Height;
      vImage_Error v5 = 0;
      if (!IOSurfaceLock(a2, 0, 0))
      {
        int v19 = v18;
        int v20 = v16;
        size_t __n = (unint64_t)v17 >> 3;
        BaseAddress = (char *)IOSurfaceGetBaseAddress(a1);
        uint64_t v21 = (char *)IOSurfaceGetBaseAddress(a2);
        unint64_t v22 = (unint64_t)v16 >> 3;
        *(_OWORD *)&src.data = xmmword_18898C840;
        src.double width = Width;
        src.size_t rowBytes = BytesPerRow;
        *(_OWORD *)&origSrc.data = xmmword_18898C840;
        origSrc.double width = v12;
        origSrc.size_t rowBytes = v15;
        __vImage_Buffer src = v19;
        dest.data = v19;
        dest.double height = 1;
        dest.double width = Width;
        dest.size_t rowBytes = v22 * Width;
        newSrc.data = v64;
        newSrc.double height = 1;
        newSrc.double width = v12;
        newSrc.size_t rowBytes = __n * v12;
        if (v66)
        {
          int v23 = v21;
          uint64_t v24 = 0;
          vImage_Error v5 = 0;
          BOOL v26 = v22 == 1 && __n == 2;
          BOOL v62 = v26;
          BOOL v28 = v22 == 2 && __n == 1;
          BOOL v59 = v28;
          if (BytesPerRow >= v15) {
            size_t v29 = v15;
          }
          else {
            size_t v29 = BytesPerRow;
          }
          size_t __na = v29;
          while (1)
          {
            src.data = &BaseAddress[v24 * BytesPerRow];
            origSrc.data = &v23[v24 * v15];
            if (v20 == 16)
            {
              vImageExtractChannel_ARGB16U(&src, &dest, 3, 0x10u);
            }
            else if (v20 == 8)
            {
              vImageExtractChannel_ARGB8888(&src, &dest, 3, 0x10u);
            }
            else
            {
              _cg_jpeg_mem_term("IIOSurfaceCopyAlphaValuesFromSource", 1754, "*** ERROR: bpcSrc '%d' not handled\n", v20);
            }
            if (v20 == v17)
            {
              memcpy(v64, __src, __na);
            }
            else
            {
              if (v62)
              {
                vImage_Error v30 = vImageConvert_Planar8To16U(&dest, &newSrc, 0x10u);
              }
              else
              {
                if (!v59)
                {
                  _cg_jpeg_mem_term("IIOSurfaceCopyAlphaValuesFromSource", 1772, "*** ERROR: combination of bpcSrc '%d' and bpcDst '%d' not handled\n", v20, v17);
                  goto LABEL_48;
                }
                vImage_Error v30 = vImageConvert_16UToPlanar8(&dest, &newSrc, 0x10u);
              }
              vImage_Error v5 = v30;
            }
LABEL_48:
            if (v17 == 16)
            {
              vImagePixelCount v31 = Width;
              if (Width)
              {
                CFDictionaryRef v32 = (char *)origSrc.data + 6;
                uint64_t v33 = (__int16 *)v64;
                do
                {
                  __int16 v34 = *v33++;
                  *CFDictionaryRef v32 = v34;
                  v32 += 4;
                  --v31;
                }
                while (v31);
              }
            }
            else if (v17 == 8)
            {
              vImage_Error v5 = vImageOverwriteChannels_ARGB8888(&newSrc, &origSrc, &origSrc, 1u, 0x10u);
            }
            else
            {
              _cg_jpeg_mem_term("IIOSurfaceCopyAlphaValuesFromSource", 1791, "*** ERROR: bpcDst '%d' not handled\n", v17);
            }
            if (++v24 == v66) {
              goto LABEL_109;
            }
          }
        }
        vImage_Error v5 = 0;
LABEL_109:
        IOSurfaceUnlock(a2, 0, 0);
        long long v18 = __src;
      }
      IOSurfaceUnlock(a1, 1u, 0);
      goto LABEL_111;
    }
    unsigned int v35 = HIBYTE(PixelFormat);
    goto LABEL_61;
  }
  if (PixelFormat == 1815491698) {
    goto LABEL_9;
  }
  unsigned __int16 v9 = 26689;
LABEL_8:
  if (PixelFormat == (v9 | 0x52470000)) {
    goto LABEL_9;
  }
  unsigned int v35 = PixelFormat >> 24;
  if ((PixelFormat & 0x80000000) == 0)
  {
LABEL_61:
    int v36 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v35 + 60) & 0x40000;
    goto LABEL_62;
  }
  int v36 = __maskrune(PixelFormat >> 24, 0x40000uLL);
LABEL_62:
  if (v36) {
    uint64_t v37 = v35;
  }
  else {
    uint64_t v37 = 46;
  }
  unsigned int v38 = PixelFormat << 8 >> 24;
  uint64_t v39 = MEMORY[0x1E4F14390];
  if (PixelFormat << 8 < 0) {
    int v40 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
  }
  else {
    int v40 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v38 + 60) & 0x40000;
  }
  if (v40) {
    uint64_t v41 = v38;
  }
  else {
    uint64_t v41 = 46;
  }
  unsigned int v42 = (__int16)PixelFormat >> 8;
  if (PixelFormat << 16 < 0) {
    int v43 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
  }
  else {
    int v43 = *(_DWORD *)(v39 + 4 * v42 + 60) & 0x40000;
  }
  if (v43) {
    uint64_t v44 = v42;
  }
  else {
    uint64_t v44 = 46;
  }
  if ((PixelFormat << 24) <= 0x7F000000) {
    int v45 = *(_DWORD *)(v39 + 4 * (char)PixelFormat + 60) & 0x40000;
  }
  else {
    int v45 = __maskrune((char)PixelFormat, 0x40000uLL);
  }
  if (v45) {
    uint64_t v46 = (char)PixelFormat;
  }
  else {
    uint64_t v46 = 46;
  }
  unsigned int v47 = v8 >> 24;
  if (v8 < 0) {
    int v48 = __maskrune(v8 >> 24, 0x40000uLL);
  }
  else {
    int v48 = *(_DWORD *)(v39 + 4 * v47 + 60) & 0x40000;
  }
  if (v48) {
    uint64_t v49 = v47;
  }
  else {
    uint64_t v49 = 46;
  }
  unsigned int v50 = v8 << 8 >> 24;
  if (v8 << 8 < 0) {
    int v51 = __maskrune(v8 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v51 = *(_DWORD *)(v39 + 4 * v50 + 60) & 0x40000;
  }
  if (v51) {
    uint64_t v52 = v50;
  }
  else {
    uint64_t v52 = 46;
  }
  unsigned int v53 = (__int16)v8 >> 8;
  if (v8 << 16 < 0) {
    int v54 = __maskrune((__int16)v8 >> 8, 0x40000uLL);
  }
  else {
    int v54 = *(_DWORD *)(v39 + 4 * v53 + 60) & 0x40000;
  }
  if (v54) {
    uint64_t v55 = v53;
  }
  else {
    uint64_t v55 = 46;
  }
  if ((v8 << 24) <= 0x7F000000) {
    int v56 = *(_DWORD *)(v39 + 4 * (char)v8 + 60) & 0x40000;
  }
  else {
    int v56 = __maskrune((char)v8, 0x40000uLL);
  }
  if (v56) {
    uint64_t v57 = (char)v8;
  }
  else {
    uint64_t v57 = 46;
  }
  LogError("IIOSurfaceCopyAlphaValuesFromSource", 1806, "*** ERROR: 'IIOSurfaceCopyAlphaValuesFromSource' - cannot copy values from '%c%c%c%c' surface to '%c%c%c%c' surface\n", v37, v41, v44, v46, v49, v52, v55, v57);
  return 4294967246;
}

uint64_t IIO_BitsPerComponentForPixelFormat(int a1)
{
  uint64_t result = 16;
  if (a1 > 1647534391)
  {
    if (a1 > 1815491697)
    {
      if (a1 == 1815491698) {
        return result;
      }
      int v3 = 1999843442;
    }
    else
    {
      if (a1 == 1647534392) {
        return 10;
      }
      int v3 = 1815162994;
    }
    if (a1 != v3) {
      goto LABEL_17;
    }
    return 10;
  }
  if (a1 > 1380401728)
  {
    if (a1 != 1380401729)
    {
      if (a1 == 1380411457) {
        return result;
      }
      goto LABEL_17;
    }
    return 8;
  }
  if (a1 == 32 || a1 == 1111970369) {
    return 8;
  }
LABEL_17:
  unsigned int v4 = a1 >> 24;
  uint64_t v5 = MEMORY[0x1E4F14390];
  if (a1 < 0) {
    int v6 = __maskrune(a1 >> 24, 0x40000uLL);
  }
  else {
    int v6 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v4 + 60) & 0x40000;
  }
  if (v6) {
    uint64_t v7 = v4;
  }
  else {
    uint64_t v7 = 46;
  }
  unsigned int v8 = a1 << 8 >> 24;
  if (a1 << 8 < 0) {
    int v9 = __maskrune(a1 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v9 = *(_DWORD *)(v5 + 4 * v8 + 60) & 0x40000;
  }
  if (v9) {
    uint64_t v10 = v8;
  }
  else {
    uint64_t v10 = 46;
  }
  unsigned int v11 = (__int16)a1 >> 8;
  if (a1 << 16 < 0) {
    int v12 = __maskrune((__int16)a1 >> 8, 0x40000uLL);
  }
  else {
    int v12 = *(_DWORD *)(v5 + 4 * v11 + 60) & 0x40000;
  }
  if (v12) {
    uint64_t v13 = v11;
  }
  else {
    uint64_t v13 = 46;
  }
  if ((a1 << 24) <= 0x7F000000) {
    int v14 = *(_DWORD *)(v5 + 4 * (char)a1 + 60) & 0x40000;
  }
  else {
    int v14 = __maskrune((char)a1, 0x40000uLL);
  }
  if (v14) {
    uint64_t v15 = (char)a1;
  }
  else {
    uint64_t v15 = 46;
  }
  LogError("IIO_BitsPerComponentForPixelFormat", 71, "*** IIO_BitsPerComponentForPixelFormat - '%c%c%c%c' not handled\n", v7, v10, v13, v15);
  return 0;
}

uint64_t IIO_IOSurfaceCopyColorSpace(__IOSurface *a1)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  signed int PixelFormat = IOSurfaceGetPixelFormat(a1);
  IIO_LoadJPEGSymbols();
  uint64_t ColorSpaceFromAttachments = CGColorSpaceCopyFromIOSurface();
  if (!ColorSpaceFromAttachments)
  {
    CFTypeRef v4 = IOSurfaceCopyValue(a1, (CFStringRef)*MEMORY[0x1E4F2F0F0]);
    if (!v4 || (uint64_t v5 = v4, ColorSpaceFromAttachments = MEMORY[0x18C11AC10](), CFRelease(v5), !ColorSpaceFromAttachments))
    {
      CFTypeRef v6 = IOSurfaceCopyValue(a1, (CFStringRef)*MEMORY[0x1E4F2F128]);
      memset(v67, 0, sizeof(v67));
      IIOString::IIOString((IIOString *)v67, v6);
      if (v6) {
        CFRelease(v6);
      }
      int v7 = 1;
      if (PixelFormat > 1279340599)
      {
        if ((PixelFormat - 1279340600) <= 0x30
          && ((1 << (PixelFormat - 56)) & 0x1400000000001) != 0
          || PixelFormat == 1279340854)
        {
          goto LABEL_17;
        }
        int v8 = 1279342648;
      }
      else
      {
        if ((PixelFormat - 1278226488) <= 0x30
          && ((1 << (PixelFormat - 56)) & 0x1400000000001) != 0
          || PixelFormat == 1278226736)
        {
          goto LABEL_17;
        }
        int v8 = 1278226742;
      }
      if (PixelFormat != v8) {
        int v7 = 0;
      }
LABEL_17:
      int v9 = 1;
      if (PixelFormat <= 1380410944)
      {
        if (PixelFormat > 1279340645)
        {
          if (PixelFormat == 1279340646) {
            goto LABEL_30;
          }
          int v10 = 1279340648;
        }
        else
        {
          if (PixelFormat == 1278226534) {
            goto LABEL_30;
          }
          int v10 = 1278226536;
        }
      }
      else if (PixelFormat <= 1751527983)
      {
        if (PixelFormat == 1380410945) {
          goto LABEL_30;
        }
        int v10 = 1380411457;
      }
      else
      {
        if (PixelFormat == 1751527984 || PixelFormat == 1751527986) {
          goto LABEL_30;
        }
        int v10 = 1751528500;
      }
      if (PixelFormat != v10)
      {
        int v9 = 0;
        if (v7) {
          goto LABEL_31;
        }
        goto LABEL_63;
      }
LABEL_30:
      if (v7)
      {
LABEL_31:
        if ((gIIODebugFlags & 0x8000300000) != 0)
        {
          unsigned int v11 = (const char *)IIOString::utf8String((IIOString *)v67);
          unsigned int v12 = PixelFormat >> 24;
          if (PixelFormat < 0) {
            int v13 = __maskrune(PixelFormat >> 24, 0x40000uLL);
          }
          else {
            int v13 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x40000;
          }
          if (v13) {
            uint64_t v14 = v12;
          }
          else {
            uint64_t v14 = 46;
          }
          unsigned int v15 = PixelFormat << 8 >> 24;
          if (PixelFormat << 8 < 0) {
            int v16 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
          }
          else {
            int v16 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v15 + 60) & 0x40000;
          }
          if (v16) {
            uint64_t v17 = v15;
          }
          else {
            uint64_t v17 = 46;
          }
          unsigned int v18 = (__int16)PixelFormat >> 8;
          if (PixelFormat << 16 < 0) {
            int v19 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
          }
          else {
            int v19 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v18 + 60) & 0x40000;
          }
          if (v19) {
            uint64_t v20 = v18;
          }
          else {
            uint64_t v20 = 46;
          }
          if ((PixelFormat << 24) <= 0x7F000000) {
            int v21 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)PixelFormat + 60) & 0x40000;
          }
          else {
            int v21 = __maskrune((char)PixelFormat, 0x40000uLL);
          }
          if (v21) {
            uint64_t v22 = (char)PixelFormat;
          }
          else {
            uint64_t v22 = 46;
          }
          size_t Width = IOSurfaceGetWidth(a1);
          size_t Height = IOSurfaceGetHeight(a1);
          uint64_t v25 = "GenericGrayGamma2_2";
          if (v9) {
            uint64_t v25 = "ExtendedLinearGray";
          }
          ImageIOLog("*** NOTE: IOSurface '%s' [%c%c%c%c] %ldx%ld has no kIOSurfaceColorSpace/kIOSurfaceICCProfile - using %s\n", v11, v14, v17, v20, v22, Width, Height, v25);
        }
        BOOL v26 = (CFStringRef *)MEMORY[0x1E4F1DBD0];
        if (!v9) {
          BOOL v26 = (CFStringRef *)MEMORY[0x1E4F1DC00];
        }
        CGColorSpaceRef v27 = CGColorSpaceCreateWithName(*v26);
LABEL_131:
        uint64_t ColorSpaceFromAttachments = (uint64_t)v27;
        goto LABEL_132;
      }
LABEL_63:
      int v66 = 0;
      long long v64 = 0u;
      long long v65 = 0u;
      long long v62 = 0u;
      long long v63 = 0u;
      long long v60 = 0u;
      long long v61 = 0u;
      long long v59 = 0u;
      uint64_t v58 = 116;
      if (IOSurfaceGetBulkAttachments())
      {
LABEL_100:
        if ((gIIODebugFlags & 0x8000300000) != 0)
        {
          uint64_t v37 = (const char *)IIOString::utf8String((IIOString *)v67);
          unsigned int v38 = PixelFormat >> 24;
          uint64_t v39 = MEMORY[0x1E4F14390];
          if (PixelFormat < 0) {
            int v40 = __maskrune(PixelFormat >> 24, 0x40000uLL);
          }
          else {
            int v40 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v38 + 60) & 0x40000;
          }
          if (v40) {
            uint64_t v41 = v38;
          }
          else {
            uint64_t v41 = 46;
          }
          unsigned int v42 = PixelFormat << 8 >> 24;
          if (PixelFormat << 8 < 0) {
            int v43 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
          }
          else {
            int v43 = *(_DWORD *)(v39 + 4 * v42 + 60) & 0x40000;
          }
          if (v43) {
            uint64_t v44 = v42;
          }
          else {
            uint64_t v44 = 46;
          }
          unsigned int v45 = (__int16)PixelFormat >> 8;
          if (PixelFormat << 16 < 0) {
            int v46 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
          }
          else {
            int v46 = *(_DWORD *)(v39 + 4 * v45 + 60) & 0x40000;
          }
          if (v46) {
            uint64_t v47 = v45;
          }
          else {
            uint64_t v47 = 46;
          }
          if ((PixelFormat << 24) <= 0x7F000000) {
            int v48 = *(_DWORD *)(v39 + 4 * (char)PixelFormat + 60) & 0x40000;
          }
          else {
            int v48 = __maskrune((char)PixelFormat, 0x40000uLL);
          }
          if (v48) {
            uint64_t v49 = (char)PixelFormat;
          }
          else {
            uint64_t v49 = 46;
          }
          size_t v50 = IOSurfaceGetWidth(a1);
          size_t v51 = IOSurfaceGetHeight(a1);
          uint64_t v52 = "SRGB";
          if (v9) {
            uint64_t v52 = "ExtendedLinearSRGB";
          }
          ImageIOLog("*** NOTE: IOSurface '%s' [%c%c%c%c] %ldx%ld has no kIOSurfaceColorSpace/kIOSurfaceICCProfile - using %s\n", v37, v41, v44, v47, v49, v50, v51, v52);
        }
        unsigned int v53 = (CFStringRef *)MEMORY[0x1E4F1DBE0];
        if (!v9) {
          unsigned int v53 = (CFStringRef *)MEMORY[0x1E4F1DC98];
        }
        CGColorSpaceRef v27 = CGColorSpaceCreateWithName(*v53);
        goto LABEL_131;
      }
      uint64_t v55 = 0;
      uint64_t v56 = 0;
      uint64_t v57 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v55);
      if (DWORD1(v62))
      {
        IIONumber::IIONumber((IIONumber *)&bytes, (double)(int)v62 / (double)SDWORD1(v62));
        IIODictionary::setObjectForKey((IIODictionary *)&v55, v84, *(const __CFString **)gIIO_kCVImageBufferGammaLevelKey);
        IIONumber::~IIONumber((IIONumber *)&bytes);
      }
      StringForIntegerCodePoint = (const void *)gFunc_CVYCbCrMatrixGetStringForIntegerCodePoint(BYTE10(v62));
      if (StringForIntegerCodePoint) {
        IIODictionary::setObjectForKey((IIODictionary *)&v55, StringForIntegerCodePoint, *(const __CFString **)gIIO_kCVImageBufferYCbCrMatrixKey);
      }
      size_t v29 = (const void *)gFunc_CVColorPrimariesGetStringForIntegerCodePoint(BYTE11(v62));
      if (v29) {
        IIODictionary::setObjectForKey((IIODictionary *)&v55, v29, *(const __CFString **)gIIO_kCVImageBufferColorPrimariesKey);
      }
      vImage_Error v30 = (const void *)gFunc_CVTransferFunctionGetStringForIntegerCodePoint(BYTE12(v62));
      if (v30)
      {
        IIODictionary::setObjectForKey((IIODictionary *)&v55, v30, *(const __CFString **)gIIO_kCVImageBufferTransferFunctionKey);
      }
      else if (BYTE12(v62) == 2 && DWORD1(v62))
      {
        IIODictionary::setObjectForKey((IIODictionary *)&v55, *(const void **)gIIO_kCVImageBufferTransferFunction_UseGamma, *(const __CFString **)gIIO_kCVImageBufferTransferFunctionKey);
      }
      unsigned int v31 = BYTE13(v62) - 1;
      if (v31 <= 6) {
        IIODictionary::setObjectForKey((IIODictionary *)&v55, **(const void ***)off_1E53C7130[(char)v31], *(const __CFString **)gIIO_kCVImageBufferChromaLocationTopFieldKey);
      }
      unsigned int v32 = BYTE14(v62) - 1;
      if (v32 <= 6) {
        IIODictionary::setObjectForKey((IIODictionary *)&v55, **(const void ***)off_1E53C7130[(char)v32], *(const __CFString **)gIIO_kCVImageBufferChromaLocationBottomFieldKey);
      }
      unsigned int v33 = HIBYTE(v62) - 1;
      if (v33 <= 2) {
        IIODictionary::setObjectForKey((IIODictionary *)&v55, **(const void ***)off_1E53C7168[(char)v33], *(const __CFString **)gIIO_kCVImageBufferChromaSubsamplingKey);
      }
      if ((_WORD)v63
        && WORD1(v63)
        && WORD2(v63)
        && WORD3(v63)
        && WORD4(v63)
        && WORD5(v63)
        && WORD6(v63)
        && HIWORD(v63)
        && v64)
      {
        UInt8 bytes = BYTE1(v63);
        char v69 = v63;
        char v70 = BYTE3(v63);
        char v71 = BYTE2(v63);
        char v72 = BYTE5(v63);
        char v73 = BYTE4(v63);
        char v74 = BYTE7(v63);
        char v75 = BYTE6(v63);
        char v76 = BYTE9(v63);
        char v77 = BYTE8(v63);
        char v78 = BYTE11(v63);
        char v79 = BYTE10(v63);
        char v80 = BYTE13(v63);
        char v81 = BYTE12(v63);
        char v82 = HIBYTE(v63);
        char v83 = BYTE14(v63);
        LOBYTE(v84) = BYTE3(v64);
        BYTE1(v84) = BYTE2(v64);
        BYTE2(v84) = BYTE1(v64);
        BYTE3(v84) = v64;
        HIDWORD(v84) = bswap32(DWORD1(v64));
        CFDataRef v34 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &bytes, 24);
        IIODictionary::setObjectForKey((IIODictionary *)&v55, v34, *(const __CFString **)gIIO_kCVImageBufferMasteringDisplayColorVolumeKey);
        CFRelease(v34);
      }
      if (WORD4(v64) && WORD5(v64))
      {
        UInt8 bytes = BYTE9(v64);
        char v69 = BYTE8(v64);
        char v70 = BYTE11(v64);
        char v71 = BYTE10(v64);
        CFDataRef v35 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &bytes, 4);
        IIODictionary::setObjectForKey((IIODictionary *)&v55, v35, *(const __CFString **)gIIO_kCVImageBufferContentLightLevelInfoKey);
        CFRelease(v35);
      }
      if (BYTE4(v65) == 1)
      {
        int v36 = &gIIO_kCVImageBufferAlphaChannelMode_StraightAlpha;
      }
      else
      {
        if (BYTE4(v65) != 2) {
          goto LABEL_99;
        }
        int v36 = &gIIO_kCVImageBufferAlphaChannelMode_PremultipliedAlpha;
      }
      IIODictionary::setObjectForKey((IIODictionary *)&v55, *(const void **)gIIO_kCVImageBufferAlphaChannelModeKey, *(const __CFString **)*v36);
LABEL_99:
      uint64_t ColorSpaceFromAttachments = gFunc_CVImageBufferCreateColorSpaceFromAttachments(v56);
      IIODictionary::~IIODictionary((IIODictionary *)&v55);
      if (ColorSpaceFromAttachments)
      {
LABEL_132:
        IIOString::~IIOString((IIOString *)v67);
        return ColorSpaceFromAttachments;
      }
      goto LABEL_100;
    }
  }
  return ColorSpaceFromAttachments;
}

void sub_188744D5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  IIONumber::~IIONumber((IIONumber *)(v9 - 112));
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIOString::~IIOString((IIOString *)(v9 - 136));
  _Unwind_Resume(a1);
}

uint64_t IIO_CreateIOSurfaceContext(__IOSurface *a1, CGColorSpace *a2)
{
  signed int PixelFormat = IOSurfaceGetPixelFormat(a1);
  if (PixelFormat == 1111970369)
  {
    uint64_t v6 = 8194;
    uint64_t v7 = 8;
    uint64_t v8 = 32;
LABEL_8:
    size_t Width = IOSurfaceGetWidth(a1);
    size_t Height = IOSurfaceGetHeight(a1);
    return MEMORY[0x1F40DA7C0](a1, Width, Height, v7, v8, a2, v6);
  }
  signed int v5 = PixelFormat;
  if (PixelFormat == 1815491698)
  {
    uint64_t v6 = 4097;
    goto LABEL_7;
  }
  if (PixelFormat == 1380411457)
  {
    uint64_t v6 = 4353;
LABEL_7:
    uint64_t v7 = 16;
    uint64_t v8 = 64;
    goto LABEL_8;
  }
  unsigned int v11 = PixelFormat >> 24;
  uint64_t v12 = MEMORY[0x1E4F14390];
  if (PixelFormat < 0) {
    int v13 = __maskrune(PixelFormat >> 24, 0x40000uLL);
  }
  else {
    int v13 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v11 + 60) & 0x40000;
  }
  if (v13) {
    uint64_t v14 = v11;
  }
  else {
    uint64_t v14 = 46;
  }
  unsigned int v15 = v5 << 8 >> 24;
  if (v5 << 8 < 0) {
    int v16 = __maskrune(v5 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v16 = *(_DWORD *)(v12 + 4 * v15 + 60) & 0x40000;
  }
  if (v16) {
    uint64_t v17 = v15;
  }
  else {
    uint64_t v17 = 46;
  }
  unsigned int v18 = (__int16)v5 >> 8;
  if (v5 << 16 < 0) {
    int v19 = __maskrune((__int16)v5 >> 8, 0x40000uLL);
  }
  else {
    int v19 = *(_DWORD *)(v12 + 4 * v18 + 60) & 0x40000;
  }
  if (v19) {
    uint64_t v20 = v18;
  }
  else {
    uint64_t v20 = 46;
  }
  if ((v5 << 24) <= 0x7F000000) {
    int v21 = *(_DWORD *)(v12 + 4 * (char)v5 + 60) & 0x40000;
  }
  else {
    int v21 = __maskrune((char)v5, 0x40000uLL);
  }
  if (v21) {
    uint64_t v22 = (char)v5;
  }
  else {
    uint64_t v22 = 46;
  }
  _cg_jpeg_mem_term("IIO_CreateIOSurfaceContext", 2068, "*** Unsupported pixel format %c%c%c%c\n", v14, v17, v20, v22);
  return 0;
}

__IOSurface *IIO_CreateIOSurfaceWithAlphaFlattened(__IOSurface *a1, CGImageAlphaInfo a2)
{
  OSType PixelFormat = IOSurfaceGetPixelFormat(a1);
  int v5 = PixelFormat;
  if (PixelFormat != 1380401729 && PixelFormat != 1111970369) {
    return 0;
  }
  uint64_t v6 = (CGColorSpace *)CGColorSpaceCopyFromIOSurface();
  size_t Width = IOSurfaceGetWidth(a1);
  size_t Height = IOSurfaceGetHeight(a1);
  size_t BytesPerRow = IOSurfaceGetBytesPerRow(a1);
  SurfaceWithFormat = IIO_CreateSurfaceWithFormat(v5, Width, Height, v6);
  CGColorSpaceRelease(v6);
  if (SurfaceWithFormat)
  {
    size_t v11 = IOSurfaceGetBytesPerRow(SurfaceWithFormat);
    IOSurfaceIncrementUseCount(SurfaceWithFormat);
    if (!IOSurfaceLock(a1, 1u, 0))
    {
      BaseAddress = IOSurfaceGetBaseAddress(a1);
      if (!IOSurfaceLock(SurfaceWithFormat, 0, 0))
      {
        uint64_t v14 = IOSurfaceGetBaseAddress(SurfaceWithFormat);
        if (BaseAddress)
        {
          if (v14)
          {
            rgbaSrc.data = BaseAddress;
            rgbaSrc.double height = Height;
            rgbaSrc.double width = Width;
            rgbaSrc.size_t rowBytes = BytesPerRow;
            rgbaDst.data = v14;
            rgbaDst.double height = Height;
            rgbaDst.double width = Width;
            rgbaDst.size_t rowBytes = v11;
            *(_DWORD *)rgbaBackgroundColorPtr = -16777216;
            vImageFlatten_RGBA8888(&rgbaSrc, &rgbaDst, rgbaBackgroundColorPtr, a2 - 1 < 2, 0);
            IOSurfaceUnlock(SurfaceWithFormat, 0, 0);
            IOSurfaceUnlock(a1, 1u, 0);
            return SurfaceWithFormat;
          }
        }
      }
      IOSurfaceUnlock(a1, 1u, 0);
    }
    CFRelease(SurfaceWithFormat);
    return 0;
  }
  return SurfaceWithFormat;
}

uint64_t _cg_png_write_flush(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(_DWORD *)(result + 308) < *(_DWORD *)(result + 288))
    {
      png_compress_IDAT(result, 0, 0, 2);
      *(_DWORD *)(v1 + 444) = 0;
      return png_flush(v1);
    }
  }
  return result;
}

void (**_cg_png_write_frame_head(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned int a4, unsigned int a5, int a6, int a7, uint64_t a8, unsigned __int16 a9, Bytef a10, unsigned __int8 a11))(void)
{
  if ((a2[10] & 2) == 0) {
    _cg_png_error((void (**)(void))a1, "png_write_frame_head(): acTL not set");
  }
  png_write_reset(a1);
  uint64_t result = (void (**)(void))png_write_reinit(a1, a2, a4, a5);
  if (*(_DWORD *)(a1 + 812) || (*(unsigned char *)(a1 + 768) & 1) == 0)
  {
    return png_write_fcTL(a1, a4, a5, a6, a7, a8, a9, a10, a11);
  }
  return result;
}

uint64_t _cg_png_write_frame_tail(uint64_t result)
{
  return result;
}

size_t (*_cg_TIFFSetWarningHandler(size_t (*a1)(const char *a1, const char *a2, va_list a3)))(const char *a1, const char *a2, va_list a3)
{
  uint64_t v1 = _TIFFwarningHandler;
  _TIFFwarningHandler = a1;
  return v1;
}

const char *TIFFWarning(const char *result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v10 = result;
  if (_TIFFwarningHandler) {
    uint64_t result = (const char *)_TIFFwarningHandler(result, a2, &a9);
  }
  if (_TIFFwarningHandlerExt) {
    return (const char *)_TIFFwarningHandlerExt(0, v10, a2, &a9);
  }
  return result;
}

uint64_t TIFFWarningExtR(uint64_t result, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11 = result;
  if (!result
    || !*(void *)(result + 1344)
    || (uint64_t result = (*(uint64_t (**)(uint64_t, void, const char *, const char *, char *))(result + 1344))(result, *(void *)(result + 1352), a2, a3, &a9), !result))
  {
    if (_TIFFwarningHandler) {
      uint64_t result = _TIFFwarningHandler(a2, a3, &a9);
    }
    if (_TIFFwarningHandlerExt)
    {
      if (v11) {
        uint64_t v12 = *(void *)(v11 + 1200);
      }
      else {
        uint64_t v12 = 0;
      }
      return ((uint64_t (*)(uint64_t, const char *, const char *, char *))_TIFFwarningHandlerExt)(v12, a2, a3, &a9);
    }
  }
  return result;
}

void CGImagePluginReadRawXMPProps(const __CFDictionary *a1, const char *a2, uint64_t a3)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImagePluginReadRawXMPProps", 0, 0, -1, 0);
  }
  BOOL v6 = 0;
  if (a1 && (const __CFDictionary *)*MEMORY[0x1E4F1D260] != a1) {
    BOOL v6 = CFDictionaryGetValue(a1, @"XMP_FROM_SIDECAR") != 0;
  }

  CGImagePluginReadRawXMPPropsInternal(a1, a2, a3, 0, 0, v6);
}

void CGImagePluginReadRawXMPPropsInternal(__CFDictionary *a1, const char *a2, uint64_t a3, const char *a4, unint64_t a5, int a6)
{
  if (a6)
  {
    MetadataFromXMPSidecaruint64_t Data = CreateMetadataFromXMPSidecarData(a2, a3);
    uint64_t v8 = (const void *)MetadataFromXMPSidecarData;
    int v9 = 16;
  }
  else
  {
    MetadataFromXMPSidecaruint64_t Data = CreateMetadataFromExtendedXMPData(a2, a3, a4);
    uint64_t v8 = (const void *)MetadataFromXMPSidecarData;
    int v9 = 8;
  }
  metadataSetSource(MetadataFromXMPSidecarData, v9);
  if (v8)
  {
    CFDictionaryAddValue(a1, @"{XMP}", v8);
    CFDictionaryAddValue(a1, @"needsPostProcessing", (const void *)*MEMORY[0x1E4F1CFD0]);
    CFRelease(v8);
  }
  else
  {
    int v10 = (const void *)*MEMORY[0x1E4F1CFD0];
    CFDictionaryAddValue(a1, @"needsPostProcessing", v10);
  }
}

void CGImagePluginReadRawXMPSidecarProps(__CFDictionary *a1, const char *a2, uint64_t a3)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImagePluginReadRawXMPSidecarProps", 0, 0, -1, 0);
  }

  CGImagePluginReadRawXMPPropsInternal(a1, a2, a3, 0, 0, 1);
}

void HEIFGroup::~HEIFGroup(HEIFGroup *this)
{
  *(void *)this = &unk_1ED4E5FB8;
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1ED4E5FB8;
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x18C11C0E0);
}

uint64_t HEIFGroup::setLeftImage(HEIFGroup *this, int a2)
{
  if (*((_DWORD *)this + 4) != 1937007986)
  {
    CFTypeRef v4 = "*** ERROR cannot add left image to non 'ster' group";
LABEL_7:
    puts(v4);
    return 4294967246;
  }
  if (*((_DWORD *)this + 5) != -1)
  {
    CFTypeRef v4 = "*** ERROR left image was already set";
    goto LABEL_7;
  }
  uint64_t result = 0;
  *((_DWORD *)this + 5) = a2;
  return result;
}

uint64_t HEIFGroup::setRightImage(HEIFGroup *this, int a2)
{
  if (*((_DWORD *)this + 4) != 1937007986)
  {
    CFTypeRef v4 = "*** ERROR cannot add right image to non 'ster' group";
LABEL_7:
    puts(v4);
    return 4294967246;
  }
  if (*((_DWORD *)this + 6) != -1)
  {
    CFTypeRef v4 = "*** ERROR right image was already set";
    goto LABEL_7;
  }
  uint64_t result = 0;
  *((_DWORD *)this + 6) = a2;
  return result;
}

uint64_t HEIFGroup::setMonoImage(HEIFGroup *this, int a2)
{
  if (*((_DWORD *)this + 4) != 1937007986)
  {
    CFTypeRef v4 = "*** ERROR cannot add mono image to non 'ster' group";
LABEL_7:
    puts(v4);
    return 4294967246;
  }
  if (*((_DWORD *)this + 7) != -1)
  {
    CFTypeRef v4 = "*** ERROR mono image was already set";
    goto LABEL_7;
  }
  uint64_t result = 0;
  *((_DWORD *)this + 7) = a2;
  return result;
}

uint64_t HEIFGroup::setOtherImage(HEIFGroup *this, int a2)
{
  if (*((_DWORD *)this + 4) == 1634497650)
  {
    CFTypeRef v4 = (char *)this + 64;
    unint64_t v5 = *((void *)this + 8);
    BOOL v6 = (char *)*((void *)this + 7);
    if ((unint64_t)v6 >= v5)
    {
      uint64_t v8 = (char *)*((void *)this + 6);
      uint64_t v9 = (v6 - v8) >> 2;
      if ((unint64_t)(v9 + 1) >> 62) {
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v10 = v5 - (void)v8;
      unint64_t v11 = (uint64_t)(v5 - (void)v8) >> 1;
      if (v11 <= v9 + 1) {
        unint64_t v11 = v9 + 1;
      }
      if (v10 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v12 = v11;
      }
      if (v12)
      {
        int v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)v4, v12);
        uint64_t v8 = (char *)*((void *)this + 6);
        BOOL v6 = (char *)*((void *)this + 7);
      }
      else
      {
        int v13 = 0;
      }
      uint64_t v14 = &v13[4 * v9];
      unsigned int v15 = &v13[4 * v12];
      *(_DWORD *)uint64_t v14 = a2;
      uint64_t v7 = v14 + 4;
      while (v6 != v8)
      {
        int v16 = *((_DWORD *)v6 - 1);
        v6 -= 4;
        *((_DWORD *)v14 - 1) = v16;
        v14 -= 4;
      }
      *((void *)this + 6) = v14;
      *((void *)this + 7) = v7;
      *((void *)this + 8) = v15;
      if (v8) {
        operator delete(v8);
      }
    }
    else
    {
      *(_DWORD *)BOOL v6 = a2;
      uint64_t v7 = v6 + 4;
    }
    uint64_t result = 0;
    *((void *)this + 7) = v7;
  }
  else
  {
    puts("*** ERROR cannot add other-image to non 'altr' group");
    return 4294967246;
  }
  return result;
}

void HEIFWritePlugin::HEIFWritePlugin(HEIFWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, int a4)
{
  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 1212500294);
  *uint64_t v7 = &unk_1ED4E3220;
  _OWORD v7[12] = 0;
  v7[13] = 0;
  v7[14] = 0;
  IIO_LoadHEIFSymbols();
  *((_DWORD *)this + 10) = a4;
  *((void *)this + 6) = IIOImageDestination::getDepthArray(a3);
  *((void *)this + 7) = 0;
  CFStringRef v8 = (const __CFString *)IIOImageDestination::utType(a3);
  CFComparisonResult v9 = CFStringCompare(v8, @"public.heics", 0);
  *((unsigned char *)this + 125) = v9 == kCFCompareEqualTo;
  if (v9 == kCFCompareEqualTo && (gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("seq  _creatingHEIFSequence: YES\n");
  }
  *((unsigned char *)this + 124) = 0;
  *((_DWORD *)this + 16) = -1;
  *((_DWORD *)this + 30) = 0;
}

void sub_188745A54(_Unwind_Exception *a1, uint64_t a2, const char *a3)
{
  BOOL v6 = *v4;
  if (*v4)
  {
    *(void *)(v3 + 104) = v6;
    operator delete(v6);
  }
  _cg_jpeg_mem_term(v3, a2, a3);
  _Unwind_Resume(a1);
}

void HEIFWritePlugin::~HEIFWritePlugin(HEIFWritePlugin *this, uint64_t a2, const char *a3)
{
  *(void *)this = &unk_1ED4E3220;
  CFTypeRef v4 = (void *)*((void *)this + 12);
  unint64_t v5 = (void *)*((void *)this + 13);
  if (v4 != v5)
  {
    do
    {
      if (*v4) {
        (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
      }
      ++v4;
    }
    while (v4 != v5);
    CFTypeRef v4 = (void *)*((void *)this + 12);
  }
  *((void *)this + 13) = v4;
  if (*((void *)this + 7))
  {
    gFunc_CMPhotoCompressionSessionReleaseHardwareResources();
    CFRelease(*((CFTypeRef *)this + 7));
    *((void *)this + 7) = 0;
    CFTypeRef v4 = (void *)*((void *)this + 12);
  }
  if (v4)
  {
    *((void *)this + 13) = v4;
    operator delete(v4);
  }

  _cg_jpeg_mem_term(this, a2, a3);
}

{
  uint64_t vars8;

  HEIFWritePlugin::~HEIFWritePlugin(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

CFDataRef HEIFWritePlugin::createExifData(HEIFWritePlugin *this, IIODictionary *a2)
{
  CFIndex length = 0;
  ExifBufferFromPropertiesJPEG = (const UInt8 *)CreateExifBufferFromPropertiesJPEG(a2, 0, 0, 0, 0, @"public.jpeg", (unint64_t *)&length);
  if (ExifBufferFromPropertiesJPEG)
  {
    uint64_t v3 = (UInt8 *)ExifBufferFromPropertiesJPEG;
    CFDataRef v4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ExifBufferFromPropertiesJPEG, length);
    free(v3);
  }
  else
  {
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("*** HEIFWritePlugin::createExifData - no Exif data???\n");
    }
    return 0;
  }
  return v4;
}

CFDataRef HEIFWritePlugin::createXMPData(HEIFWritePlugin *this, IIODictionary *a2)
{
  CFTypeRef cf = 0;
  CFDataRef v9 = 0;
  CFTypeRef v7 = 0;
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a2, @"{MetaData}");
  if (ObjectForKey)
  {
    unint64_t v5 = ObjectForKey;
    CFRetain(ObjectForKey);
    goto LABEL_4;
  }
  unint64_t v5 = (const CGImageMetadata *)CGImageMetadataCreateFromLegacyProps(a2);
  if (v5)
  {
LABEL_4:
    if ((CGImageMetadataCreateExtendedXMPWithEXIFFiltered(v5, &v9, (CFDataRef *)&cf, (CFDataRef *)&v7, 1) & 1) == 0&& *((unsigned char *)this + 36))
    {
      _cg_jpeg_mem_term("createXMPData", 411, "*** HEIFWritePlugin::createXMPData - CGImageMetadataCreateExtendedXMPWithEXIFFiltered failed\n");
    }
    CFRelease(v5);
    goto LABEL_8;
  }
  if (*((unsigned char *)this + 36)) {
    _cg_jpeg_mem_term("createXMPData", 411, "*** HEIFWritePlugin::createXMPData - CGImageMetadataCreateExtendedXMPWithEXIFFiltered failed\n");
  }
LABEL_8:
  if (cf) {
    CFRelease(cf);
  }
  if (v7) {
    CFRelease(v7);
  }
  return v9;
}

uint64_t HEIFWritePlugin::writeOneImage(HEIFWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

void HEIFWritePlugin::updateHEIFProperties(HEIFWritePlugin *this, IIODictionary *a2, IIODictionary *a3)
{
  CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(a3, @"CameraExtrinsics", @"{HEIF}");
  memset(v18, 0, sizeof(v18));
  IIODictionary::IIODictionary((IIODictionary *)v18, ObjectForKeyGroup);
  if (IIODictionary::containsKey((IIODictionary *)v18, @"Position"))
  {
    uint64_t v15 = 0;
    CFTypeRef value = 0;
    uint64_t v17 = 0;
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v18, @"Position");
    IIOArray::IIOArray((IIOArray *)&v15, ObjectForKey);
    if (IIOArray::getCount((IIOArray *)&v15) == 3) {
      IIODictionary::setObjectForKey(a2, value, @"ExtrinsicsPosition");
    }
    else {
      _cg_jpeg_mem_term("updateHEIFProperties", 456, "*** ERROR: CameraExtrinsics/Position should be a CFArray with 3 entries of type 'double'\n");
    }
    IIOArray::~IIOArray((IIOArray *)&v15);
  }
  if (IIODictionary::containsKey((IIODictionary *)v18, @"Rotation"))
  {
    uint64_t v15 = 0;
    CFTypeRef value = 0;
    uint64_t v17 = 0;
    CFDictionaryRef v7 = IIODictionary::getObjectForKey((IIODictionary *)v18, @"Rotation");
    IIOArray::IIOArray((IIOArray *)&v15, v7);
    if (IIOArray::getCount((IIOArray *)&v15) == 9) {
      IIODictionary::setObjectForKey(a2, value, @"ExtrinsicsRotation");
    }
    else {
      _cg_jpeg_mem_term("updateHEIFProperties", 465, "*** ERROR: CameraExtrinsics/Rotation should be a CFArray with 9 entries of type 'double'\n");
    }
    IIOArray::~IIOArray((IIOArray *)&v15);
  }
  if (IIODictionary::containsKey((IIODictionary *)v18, @"CoordinateSystemID"))
  {
    int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v18, @"CoordinateSystemID");
    IIONumber::IIONumber((IIONumber *)&v15, Uint32ForKey);
    IIODictionary::setObjectForKey(a2, v17, @"CoordinateSystemID");
    IIONumber::~IIONumber((IIONumber *)&v15);
  }
  CFDictionaryRef v9 = IIODictionary::getObjectForKeyGroup(a3, @"CameraModel", @"{HEIF}");
  uint64_t v15 = 0;
  CFTypeRef value = 0;
  uint64_t v17 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v15, v9);
  if (IIODictionary::containsKey((IIODictionary *)&v15, @"Intrinsics"))
  {
    uint64_t v12 = 0;
    int v13 = 0;
    uint64_t v14 = 0;
    CFDictionaryRef v10 = IIODictionary::getObjectForKey((IIODictionary *)&v15, @"Intrinsics");
    IIOArray::IIOArray((IIOArray *)&v12, v10);
    if (IIOArray::getCount((IIOArray *)&v12) == 9) {
      IIODictionary::setObjectForKey(a2, v13, @"IntrinsicsMatrix");
    }
    else {
      _cg_jpeg_mem_term("updateHEIFProperties", 484, "*** ERROR: CameraModel/Intrinsics should be a CFArray with 9 entries of type 'double'\n");
    }
    IIOArray::~IIOArray((IIOArray *)&v12);
  }
  if (IIODictionary::containsKey((IIODictionary *)&v15, @"ModelType"))
  {
    CFDictionaryRef v11 = IIODictionary::getObjectForKey((IIODictionary *)&v15, @"ModelType");
    IIODictionary::setObjectForKey(a2, v11, @"ModelType");
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v15);
  IIODictionary::~IIODictionary((IIODictionary *)v18);
}

void sub_188745FFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

__n128 HEIFWritePlugin::updateHardwareEncodeOptions(HEIFWritePlugin *this, IIODictionary *a2, IIODictionary *a3)
{
  int v6 = IIO_HardwareEncoderDefaultValue();
  if (!IIODictionary::containsKey(a3, @"kCGImageDestinationEnableRestrictedEncoding")
    || !IIODictionary::getBoolForKey(a3, @"kCGImageDestinationEnableRestrictedEncoding"))
  {
    if (v6 == -1)
    {
      if (!IIODictionary::containsKey(a3, @"kCGImageDestinationUseHardwareAcceleration")) {
        goto LABEL_12;
      }
      if (IIODictionary::getBoolForKey(a3, @"kCGImageDestinationUseHardwareAcceleration"))
      {
LABEL_9:
        _cg_jpeg_mem_term("updateHardwareEncodeOptions", 553, "    setting kCMPhotoCompressionOption_ForceHighSpeed to true\n");
        uint64_t v8 = &gIIO_kCMPhotoCompressionOption_ForceHighSpeed;
LABEL_11:
        IIODictionary::setObjectForKey(a2, (const void *)*MEMORY[0x1E4F1CFD0], *(const __CFString **)*v8);
        goto LABEL_12;
      }
    }
    else if (v6)
    {
      if (v6 != 1) {
        goto LABEL_12;
      }
      goto LABEL_9;
    }
    _cg_jpeg_mem_term("updateHardwareEncodeOptions", 557, "    setting kCMPhotoCompressionOption_PreferSoftwareCodec to true\n");
    uint64_t v8 = &gIIO_kCMPhotoCompressionOption_PreferSoftwareCodec;
    goto LABEL_11;
  }
LABEL_12:
  if (*((unsigned char *)this + 36))
  {
    return _cg_jpeg_mem_term("updateHardwareEncodeOptions", 563, "    done setting HW options\n");
  }
  return result;
}

CFDataRef HEIFWritePlugin::createISO5_ContentLightLevelInfoData(HEIFWritePlugin *this, CFDataRef a2, IIODictionary *a3)
{
  *(_DWORD *)UInt8 bytes = 0;
  if (IIODictionary::containsKey(a3, @"ContentLightLevelInfo"))
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a3, @"ContentLightLevelInfo");
    memset(v8, 0, sizeof(v8));
    IIODictionary::IIODictionary((IIODictionary *)v8, ObjectForKey);
    *(_WORD *)UInt8 bytes = bswap32(IIODictionary::getUint32ForKey((IIODictionary *)v8, @"MaxContentLightLevel")) >> 16;
    *(_WORD *)&bytes[2] = bswap32(IIODictionary::getUint32ForKey((IIODictionary *)v8, @"MaxPicAverageLightLevel")) >> 16;
    a2 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 4);
    IIODictionary::~IIODictionary((IIODictionary *)v8);
  }
  else if (a2)
  {
    CGImageGetContentHeadroom();
    if (v6 <= 0.0)
    {
      return 0;
    }
    else
    {
      *(_WORD *)UInt8 bytes = __rev16((int)(float)(v6 * 203.0));
      *(_WORD *)&bytes[2] = 0x4000;
      return CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 4);
    }
  }
  return a2;
}

void sub_1887462E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

CFDataRef HEIFWritePlugin::createISO5_MasteringDisplayColorVolumeData(HEIFWritePlugin *this, CGImage *a2, IIODictionary *a3)
{
  *(void *)UInt8 bytes = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  CFDataRef v4 = 0;
  if (IIODictionary::containsKey(a3, @"MasteringDisplayColorVolume"))
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a3, @"MasteringDisplayColorVolume");
    memset(v7, 0, sizeof(v7));
    IIODictionary::IIODictionary((IIODictionary *)v7, ObjectForKey);
    *(_WORD *)UInt8 bytes = bswap32(IIODictionary::getUint32ForKey((IIODictionary *)v7, @"DisplayPrimariesXG")) >> 16;
    *(_WORD *)&bytes[2] = bswap32(IIODictionary::getUint32ForKey((IIODictionary *)v7, @"DisplayPrimariesYG")) >> 16;
    *(_WORD *)&UInt8 bytes[4] = bswap32(IIODictionary::getUint32ForKey((IIODictionary *)v7, @"DisplayPrimariesXB")) >> 16;
    *(_WORD *)&bytes[6] = bswap32(IIODictionary::getUint32ForKey((IIODictionary *)v7, @"DisplayPrimariesYB")) >> 16;
    LOWORD(v9) = bswap32(IIODictionary::getUint32ForKey((IIODictionary *)v7, @"DisplayPrimariesXR")) >> 16;
    WORD1(v9) = bswap32(IIODictionary::getUint32ForKey((IIODictionary *)v7, @"DisplayPrimariesYR")) >> 16;
    WORD2(v9) = bswap32(IIODictionary::getUint32ForKey((IIODictionary *)v7, @"WhitePointX")) >> 16;
    HIWORD(v9) = bswap32(IIODictionary::getUint32ForKey((IIODictionary *)v7, @"WhitePointY")) >> 16;
    LODWORD(v10) = bswap32(IIODictionary::getUint32ForKey((IIODictionary *)v7, @"MaxDisplayMasteringLuminance"));
    HIDWORD(v10) = bswap32(IIODictionary::getUint32ForKey((IIODictionary *)v7, @"MinDisplayMasteringLuminance"));
    CFDataRef v4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 24);
    IIODictionary::~IIODictionary((IIODictionary *)v7);
  }
  return v4;
}

void sub_18874649C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

CFDataRef HEIFWritePlugin::createISO5_AmbientViewingEnvironmentData(HEIFWritePlugin *this, CGImage *a2, IIODictionary *a3)
{
  *(void *)UInt8 bytes = 0;
  CFDataRef v4 = 0;
  if (IIODictionary::containsKey(a3, @"AmbientViewingEnvironment"))
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a3, @"AmbientViewingEnvironment");
    memset(v7, 0, sizeof(v7));
    IIODictionary::IIODictionary((IIODictionary *)v7, ObjectForKey);
    *(_DWORD *)UInt8 bytes = bswap32(IIODictionary::getUint32ForKey((IIODictionary *)v7, @"AmbientIlluminance"));
    *(_WORD *)&UInt8 bytes[4] = bswap32(IIODictionary::getUint32ForKey((IIODictionary *)v7, @"AmbientLightX")) >> 16;
    *(_WORD *)&bytes[6] = bswap32(IIODictionary::getUint32ForKey((IIODictionary *)v7, @"AmbientLightY")) >> 16;
    CFDataRef v4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 8);
    IIODictionary::~IIODictionary((IIODictionary *)v7);
  }
  return v4;
}

void sub_188746590(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t HEIFWritePlugin::writeImageAtIndex(HEIFWritePlugin *this, IIOImagePixelDataProvider *a2, CGImage *a3, const __CFDictionary **a4, IIODictionary *a5, int a6, uint64_t *a7)
{
  uint64_t v187 = 0;
  v188[0] = 0;
  uint64_t v185 = 0;
  uint64_t v186 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v185);
  uint64_t v184 = 0;
  if (a2)
  {
    uint64_t BytesPerRow = IIOImagePlus::sourceImageProvider(a2);
    vImagePixelCount Width = IIOImageSource::count(a2);
    vImagePixelCount Height = IIO_Reader::testHeaderSize(a2);
    CGBitmapInfo BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(a2);
    uint64_t Ref = (CGImage *)IIOImageSource::imageReadRef(a2);
    CGColorSpaceRef space = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  }
  else
  {
    if (!a3)
    {
      uint64_t v23 = 4294967246;
      goto LABEL_265;
    }
    uint64_t BytesPerRow = CGImageGetBytesPerRow(a3);
    vImagePixelCount Width = CGImageGetWidth(a3);
    vImagePixelCount Height = CGImageGetHeight(a3);
    CGBitmapInfo BitmapInfo = CGImageGetBitmapInfo(a3);
    CGColorSpaceRef space = CGImageGetColorSpace(a3);
    uint64_t Ref = a3;
  }
  size_t BitsPerComponent = CGImageGetBitsPerComponent(Ref);
  if (BitsPerComponent > 0xF) {
    int v13 = (BitmapInfo >> 8) & 1;
  }
  else {
    int v13 = 0;
  }
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)a4, @"Depth");
  if (Uint32ForKey) {
    size_t v15 = Uint32ForKey;
  }
  else {
    size_t v15 = BitsPerComponent;
  }
  if (BitsPerComponent < v15)
  {
    _cg_jpeg_mem_term("writeImageAtIndex", 750, "*** imageProperties-bitDepth: %d    bpc: %d  -- using: %d bit/component\n", v15, BitsPerComponent, BitsPerComponent);
    LODWORD(v15) = BitsPerComponent;
  }
  CGColorSpaceModel Model = CGColorSpaceGetModel(space);
  if (IIODictionary::getBoolForKey((IIODictionary *)a4, @"PrimaryImage") && !*((unsigned char *)this + 124))
  {
    int v147 = 1;
    *((unsigned char *)this + 124) = 1;
  }
  else
  {
    int v147 = 0;
  }
  if (IIODictionary::containsKey((IIODictionary *)a4, @"kCGImageSourceEnableRestrictedDecoding"))
  {
    BOOL BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)a4, @"kCGImageSourceEnableRestrictedDecoding");
    if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild())
    {
      uint64_t v17 = "";
      if (BoolForKey) {
        uint64_t v17 = "";
      }
      ImageIOLog(" %s EnableRestrictedDecoding  | %s:%d\n", v17, "writeImageAtIndex", 774);
    }
  }
  else
  {
    if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild()) {
      ImageIOLog("  EnableRestrictedDecoding  | %s:%d\n", "writeImageAtIndex", 777);
    }
    LOBYTE(BoolForKey) = 0;
  }
  float v19 = -1.0;
  if (IIODictionary::containsKey((IIODictionary *)a4, @"kCGImageDestinationLossyCompressionQuality"))
  {
    v18.n128_f64[0] = IIODictionary::getFloatForKey((IIODictionary *)a4, @"kCGImageDestinationLossyCompressionQuality");
    if (v18.n128_f32[0] > 1.0 || v18.n128_f32[0] < 0.0) {
      float v19 = -1.0;
    }
    else {
      float v19 = v18.n128_f32[0];
    }
  }
  int v158 = BitmapInfo & 0x1F;
  if (BoolForKey || !IIO_CGImageWrapsIOSurface((uint64_t)Ref, 1))
  {
    uint64_t v23 = 4294967246;
  }
  else
  {
    CGImageGetImageProvider();
    if (*MEMORY[0x1E4F1CFD0] == CGImageProviderGetProperty())
    {
      LogError("writeImageAtIndex", 798, "*** ERROR: HEIF saving failed - input image cannot be decoded ('kCMPhotoError_XPCError'\n");
      uint64_t v23 = 4294967246;
      if (!v188[0]) {
        goto LABEL_265;
      }
      goto LABEL_262;
    }
    if (Model == kCGColorSpaceModelRGB)
    {
      if ((v158 - 1) < 4 || v158 == 7 || v19 == 1.0)
      {
        if (v13) {
          int v21 = 1380411457;
        }
        else {
          int v21 = 1815491698;
        }
        if (BitsPerComponent <= 8) {
          int v22 = 1111970369;
        }
        else {
          int v22 = v21;
        }
      }
      else if (BitsPerComponent < 9 || *((_DWORD *)this + 10) == 1785750887)
      {
        int v22 = 875704422;
      }
      else
      {
        int v22 = 2019963440;
        size_t BitsPerComponent = 10;
      }
    }
    else
    {
      int v22 = 0;
    }
    memset(&dest, 0, 24);
    IIODictionary::IIODictionary((IIODictionary *)&dest);
    IIONumber::IIONumber((IIONumber *)permuteMap, v22);
    IIODictionary::setObjectForKey((IIODictionary *)&dest, v183, @"kCGImageSurfaceFormatRequest");
    IIONumber::~IIONumber((IIONumber *)permuteMap);
    BOOL v28 = (__IOSurface *)CGImageProviderCopyIOSurface();
    IIO_IOSurfaceLogAlphaInfo(v28, "writeImageAtIndex surface:");
    CGImageAlphaInfo Alpha = IIO_IOSurfaceGetAlpha(v28);
    if (v158 != Alpha)
    {
      vImage_Error v30 = IIO_AlphaInfoString(v158);
      unsigned int v31 = IIO_AlphaInfoString(Alpha);
      _cg_jpeg_mem_term("writeImageAtIndex", 842, "*** NOTE: image-alpha: %s   surface-alpha: %s\n", v30, v31);
    }
    if (v28)
    {
      if ((Alpha - 1 < 4 || Alpha == kCGImageAlphaOnly)
        && *((_DWORD *)this + 10) == 1785750887
        && (IOSurfaceWithAlphaFlattened = IIO_CreateIOSurfaceWithAlphaFlattened(v28, Alpha)) != 0)
      {
        CFRelease(v28);
      }
      else
      {
        IOSurfaceWithAlphaFlattened = v28;
      }
      uint64_t v33 = gFunc_CVPixelBufferCreateWithIOSurface(*MEMORY[0x1E4F1CF80], IOSurfaceWithAlphaFlattened, 0, v188);
      uint64_t v23 = v33;
      if (v33)
      {
        _cg_jpeg_mem_term("writeImageAtIndex", 862, "*** CVPixelBufferCreateWithIOSurface - err=%d\n", v33);
      }
      else
      {
        uint64_t v144 = v33;
        unsigned int v145 = IOSurfaceWithAlphaFlattened;
        signed int PixelFormat = IOSurfaceGetPixelFormat(IOSurfaceWithAlphaFlattened);
        signed int v35 = PixelFormat;
        unsigned int v36 = PixelFormat >> 24;
        uint64_t v37 = MEMORY[0x1E4F14390];
        if (PixelFormat < 0) {
          int v38 = __maskrune(PixelFormat >> 24, 0x40000uLL);
        }
        else {
          int v38 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v36 + 60) & 0x40000;
        }
        if (v38) {
          uint64_t v121 = v36;
        }
        else {
          uint64_t v121 = 46;
        }
        BOOL v156 = (void *)v121;
        unsigned int v122 = v35 << 8 >> 24;
        if (v35 << 8 < 0) {
          int v123 = __maskrune(v35 << 8 >> 24, 0x40000uLL);
        }
        else {
          int v123 = *(_DWORD *)(v37 + 4 * v122 + 60) & 0x40000;
        }
        if (v123) {
          uint64_t v124 = v122;
        }
        else {
          uint64_t v124 = 46;
        }
        uint64_t v151 = v124;
        unsigned int v125 = (__int16)v35 >> 8;
        if (v35 << 16 < 0) {
          int v146 = __maskrune(v125, 0x40000uLL);
        }
        else {
          int v146 = *(_DWORD *)(v37 + 4 * v125 + 60) & 0x40000;
        }
        unsigned int v126 = (char)v35;
        if ((v35 << 24) <= 0x7F000000)
        {
          int v127 = *(_DWORD *)(v37 + 4 * (char)v35 + 60) & 0x40000;
        }
        else
        {
          int v127 = __maskrune((char)v35, 0x40000uLL);
          unsigned int v126 = (char)v35;
        }
        if (v146) {
          uint64_t v128 = ((__int16)v35 >> 8);
        }
        else {
          uint64_t v128 = 46;
        }
        if (v127) {
          uint64_t v129 = v126;
        }
        else {
          uint64_t v129 = 46;
        }
        _cg_jpeg_mem_term("writeImageAtIndex", 868, "*** CVPixelBufferCreateWithIOSurface: '%c%c%c%c'\n", v156, v151, v128, v129);
        uint64_t BytesPerRow = gFunc_CVPixelBufferGetBytesPerRow(v188[0]);
        uint64_t v23 = v144;
        IOSurfaceWithAlphaFlattened = v145;
      }
      CFRelease(IOSurfaceWithAlphaFlattened);
    }
    else
    {
      uint64_t v23 = 4294967246;
    }
    IIODictionary::~IIODictionary((IIODictionary *)&dest);
  }
  if (v188[0])
  {
    int v155 = 0;
    if (!v23) {
      goto LABEL_111;
    }
LABEL_259:
    if (a7) {
      *a7 = v184;
    }
    goto LABEL_261;
  }
  unint64_t v24 = Height * (unint64_t)BytesPerRow;
  if ((v24 & 0xFFFFFFFF00000000) != 0)
  {
LABEL_298:
    int v155 = 0;
    goto LABEL_261;
  }
  int v155 = malloc_type_malloc(v24, 0xF84B252DuLL);
  if (!v155)
  {
    __n128 v18 = _cg_jpeg_mem_term("writeImageAtIndex", 889, "*** could not allocate outputBuffer [%d x %d]\n", Height, Width);
    goto LABEL_298;
  }
  if (a2)
  {
    IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v155);
    size_t appleflags = _cg_png_get_appleflags((uint64_t)a2);
  }
  else
  {
    size_t appleflags = CGImageGetBitsPerPixel(a3);
    if (CGImageGetData() != Height)
    {
      __n128 v18 = _cg_jpeg_mem_term("writeImageAtIndex", 900, "*** could not get image data [%d x %d]  rb: %d\n", Height, Width, BytesPerRow);
      goto LABEL_261;
    }
  }
  if (Model == kCGColorSpaceModelRGB)
  {
    if ((v158 - 1) < 4 || v158 == 7)
    {
      uint64_t v27 = 1111970369;
      if (BitsPerComponent != 8)
      {
        if (appleflags == 64)
        {
          if ((BitmapInfo & 0x100) != 0) {
            uint64_t v27 = 1380411457;
          }
          else {
            uint64_t v27 = 1815491698;
          }
          goto LABEL_105;
        }
        uint64_t v27 = 0;
      }
    }
    else if (BitsPerComponent == 8)
    {
      uint64_t v27 = 24;
    }
    else
    {
      uint64_t v27 = 1815491698;
    }
    if (appleflags == 32)
    {
      if (*((_DWORD *)this + 10) == 1785750887)
      {
        if (_AlphaPosition(v158) == 1) {
          goto LABEL_103;
        }
      }
      else if (_AlphaPosition(v158) == 1)
      {
LABEL_103:
        dest.data = v155;
        dest.double height = Height;
        dest.double width = Width;
        dest.size_t rowBytes = BytesPerRow;
        *(_DWORD *)permuteMap = 50331906;
        vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0);
        uint64_t v27 = 1111970369;
        goto LABEL_105;
      }
    }
    if (v27) {
      goto LABEL_105;
    }
LABEL_66:
    LogError("writeImageAtIndex", 974, "*** ERROR: pixelFormat was not set for:  bpc:%d   bpp:%d\n", BitsPerComponent, appleflags);
    uint64_t v27 = 0;
    goto LABEL_105;
  }
  if (Model)
  {
    LogError("writeImageAtIndex", 943, "*** ERROR: unsupported colorSpaceModel (%d)\n", Model);
    goto LABEL_66;
  }
  if ((BitmapInfo & 0x1F) != 0) {
    unsigned int v26 = 843264056;
  }
  else {
    unsigned int v26 = 1278226488;
  }
  if (BitsPerComponent == 8) {
    uint64_t v27 = v26;
  }
  else {
    uint64_t v27 = v26 + 254;
  }
LABEL_105:
  uint64_t v39 = gFunc_CVPixelBufferCreateWithBytes(*MEMORY[0x1E4F1CF80], Width, Height, v27, v155, BytesPerRow, CVPixelBufferReleaseImageBlock, v155, v186, v188);
  uint64_t v23 = v39;
  if (v39)
  {
    int v40 = IIOCMErrorString(v39);
    uint64_t v41 = MEMORY[0x1E4F14390];
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * BYTE3(v27) + 60) & 0x40000) != 0) {
      uint64_t v42 = BYTE3(v27);
    }
    else {
      uint64_t v42 = 46;
    }
    unsigned int v43 = (int)(v27 << 8) >> 24;
    if (((v27 << 8) & 0x80000000) != 0) {
      int v44 = __maskrune((int)(v27 << 8) >> 24, 0x40000uLL);
    }
    else {
      int v44 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v43 + 60) & 0x40000;
    }
    if (v44) {
      uint64_t v68 = v43;
    }
    else {
      uint64_t v68 = 46;
    }
    unsigned int v69 = (__int16)v27 >> 8;
    if (((v27 << 16) & 0x80000000) != 0) {
      int v70 = __maskrune((__int16)v27 >> 8, 0x40000uLL);
    }
    else {
      int v70 = *(_DWORD *)(v41 + 4 * v69 + 60) & 0x40000;
    }
    if (v27 << 24 <= 0x7F000000u) {
      int v71 = *(_DWORD *)(v41 + 4 * (char)v27 + 60) & 0x40000;
    }
    else {
      int v71 = __maskrune((char)v27, 0x40000uLL);
    }
    if (v70) {
      uint64_t v72 = v69;
    }
    else {
      uint64_t v72 = 46;
    }
    if (v71) {
      uint64_t v73 = (char)v27;
    }
    else {
      uint64_t v73 = 46;
    }
    __n128 v18 = _cg_jpeg_mem_term("writeImageAtIndex", 982, "*** ERROR: CVPixelBufferCreateWithBytes err = %s [%d]  '%c%c%c%c'\n", v40, v23, v42, v68, v72, v73);
    goto LABEL_259;
  }
LABEL_111:
  CFStringRef Name = CGColorSpaceGetName(space);
  if (Name && CFEqual(Name, @"kCGColorSpaceDeviceRGB"))
  {
    CFStringRef v49 = (const __CFString *)*MEMORY[0x1E4F1DC98];
    dest.data = &unk_1ED4DFD58;
    dest.double height = 0;
    dest.double height = (vImagePixelCount)CGColorSpaceCreateWithName(v49);
    gFunc_CVBufferSetAttachment(v188[0], *(void *)gIIO_kCVImageBufferCGColorSpaceKey, dest.height, 1);
    IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)&dest);
  }
  else
  {
    HasOpaqueAlphaFromPixeluint64_t Data = (HEIFWritePlugin *)gFunc_CVBufferSetAttachment(v188[0], *(void *)gIIO_kCVImageBufferCGColorSpaceKey, space, 1);
  }
  if (!a6) {
    HasOpaqueAlphaFromPixeluint64_t Data = (HEIFWritePlugin *)HEIFWritePlugin::prepareHEIFWriting(this, v47, v48);
  }
  if ((v158 - 1) < 4 || v158 == 7)
  {
    LOBYTE(dest.data) = 0;
    if (gFunc_CMPhotoImageHasOpaqueAlphaFromPixelData)
    {
      HasOpaqueAlphaFromPixeluint64_t Data = (HEIFWritePlugin *)gFunc_CMPhotoImageHasOpaqueAlphaFromPixelData(v188[0], &dest);
      if (!HasOpaqueAlphaFromPixelData)
      {
        if (LOBYTE(dest.data))
        {
          size_t v50 = getprogname();
          size_t v51 = IIO_AlphaInfoString(v158);
          HasOpaqueAlphaFromPixeluint64_t Data = (HEIFWritePlugin *)LogError("writeImageAtIndex", 1025, " ERROR: '%s' is trying to save an opaque image (%dx%d) with '%s'. This would unnecessarily increase the file size and will double (!!!) the required memory when decoding the image --> ignoring alpha.\n ", v50, Width, Height, v51);
          int v158 = 5;
        }
      }
    }
  }
  if (v158 == 3)
  {
    uint64_t v52 = &gIIO_kCVImageBufferAlphaChannelMode_StraightAlpha;
  }
  else
  {
    if (v158 != 1) {
      goto LABEL_128;
    }
    uint64_t v52 = &gIIO_kCVImageBufferAlphaChannelMode_PremultipliedAlpha;
  }
  HasOpaqueAlphaFromPixeluint64_t Data = (HEIFWritePlugin *)gFunc_CVBufferSetAttachment(v188[0], *(void *)gIIO_kCVImageBufferAlphaChannelModeKey, *(void *)*v52, 1);
LABEL_128:
  ISO5_ContentLightLevelInfouint64_t Data = HEIFWritePlugin::createISO5_ContentLightLevelInfoData(HasOpaqueAlphaFromPixelData, Ref, (IIODictionary *)a4);
  uint64_t v55 = ISO5_ContentLightLevelInfoData;
  if (ISO5_ContentLightLevelInfoData)
  {
    gFunc_CVBufferSetAttachment(v188[0], *(void *)gIIO_kCVImageBufferContentLightLevelInfoKey, ISO5_ContentLightLevelInfoData, 1);
    CFRelease(v55);
  }
  ISO5_MasteringDisplayColorVolumeuint64_t Data = HEIFWritePlugin::createISO5_MasteringDisplayColorVolumeData(ISO5_ContentLightLevelInfoData, v54, (IIODictionary *)a4);
  if (ISO5_MasteringDisplayColorVolumeData)
  {
    gFunc_CVBufferSetAttachment(v188[0], *(void *)gIIO_kCVImageBufferMasteringDisplayColorVolumeKey, ISO5_MasteringDisplayColorVolumeData, 1);
    CFRelease(ISO5_MasteringDisplayColorVolumeData);
  }
  uint64_t v57 = IIODictionary::containsKey((IIODictionary *)a4, @"ContentColorVolume");
  ISO5_AmbientViewingEnvironmentuint64_t Data = HEIFWritePlugin::createISO5_AmbientViewingEnvironmentData(v57, v58, (IIODictionary *)a4);
  if (ISO5_AmbientViewingEnvironmentData)
  {
    gFunc_CVBufferSetAttachment(v188[0], *(void *)gIIO_kCVImageBufferAmbientViewingEnvironmentKey, ISO5_AmbientViewingEnvironmentData, 1);
    CFRelease(ISO5_AmbientViewingEnvironmentData);
  }
  memset(&dest, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)&dest);
  if (v15 == 8) {
    int v60 = 8;
  }
  else {
    int v60 = 10;
  }
  IIONumber::IIONumber((IIONumber *)permuteMap, v60);
  IIODictionary::setObjectForKey((IIODictionary *)&dest, v183, *(const __CFString **)gIIO_kCMPhotoCompressionOption_BitDepth);
  IIONumber::~IIONumber((IIONumber *)permuteMap);
  IIONumber::IIONumber((IIONumber *)v180, *((_DWORD *)this + 10));
  IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v180, *(const void **)gIIO_kCMPhotoCompressionOption_CodecType);
  IIONumber::~IIONumber((IIONumber *)v180);
  if (*((_DWORD *)this + 10) == 1752589105
    && IIODictionary::containsKeyGroup((IIODictionary *)a4, @"TileWidth", @"{TIFF}")
    && IIODictionary::containsKeyGroup((IIODictionary *)a4, @"TileLength", @"{TIFF}"))
  {
    unsigned int Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup((IIODictionary *)a4, @"TileWidth", @"{TIFF}");
    unsigned int v62 = IIODictionary::getUint32ForKeyGroup((IIODictionary *)a4, @"TileLength", @"{TIFF}");
    BOOL v63 = (Uint32ForKeyGroup & 0x7F) != 0 || Uint32ForKeyGroup == 0;
    unsigned int v64 = (Uint32ForKeyGroup + 127) & 0xFFFFFF80;
    if (!v63) {
      unsigned int v64 = Uint32ForKeyGroup;
    }
    BOOL v65 = (v62 & 0x3F) != 0 || v62 == 0;
    unsigned int v66 = (v62 + 63) & 0xFFFFFFC0;
    if (!v65) {
      unsigned int v66 = v62;
    }
    if (v64)
    {
      if (v66)
      {
        v189.double width = (double)v64;
        v189.double height = (double)v66;
        CFDictionaryRef DictionaryRepresentation = CGSizeCreateDictionaryRepresentation(v189);
        if (DictionaryRepresentation)
        {
          IIODictionary::setObjectForKey((IIODictionary *)&dest, DictionaryRepresentation, *(const __CFString **)gIIO_kCMPhotoCompressionOption_Tiling);
          CFRelease(DictionaryRepresentation);
        }
      }
    }
  }
  if (v19 != -1.0)
  {
    if (*((_DWORD *)this + 10) == 1785750887)
    {
      IIONumber::IIONumber((IIONumber *)v179, 3);
      IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v179, *(const void **)gIIO_kCMPhotoCompressionOption_QualityControllerType);
      IIONumber::~IIONumber((IIONumber *)v179);
      memset(permuteMap, 0, sizeof(permuteMap));
      size_t v183 = 0;
      IIODictionary::IIODictionary((IIODictionary *)permuteMap);
      IIONumber::IIONumber((IIONumber *)v178, v19);
      IIODictionary::setObjectForKey((uint64_t)permuteMap, (uint64_t)v178, *(const void **)gIIO_kCMPhotoQualityControllerParameter_QualityValue);
      IIONumber::~IIONumber((IIONumber *)v178);
      IIODictionary::setObjectForKey((IIODictionary *)&dest, *(const void **)&permuteMap[8], *(const __CFString **)gIIO_kCMPhotoCompressionOption_QualityControllerParameters);
      if (v19 == 1.0)
      {
        IIONumber::IIONumber((IIONumber *)v176, 3);
        IIODictionary::setObjectForKey((IIODictionary *)&dest, value, *(const __CFString **)gIIO_kCMPhotoCompressionOption_Subsampling);
        IIONumber::~IIONumber((IIONumber *)v176);
      }
    }
    else
    {
      if (v19 >= 1.0)
      {
        IIONumber::IIONumber((IIONumber *)permuteMap, 3);
        IIODictionary::setObjectForKey((IIODictionary *)&dest, v183, *(const __CFString **)gIIO_kCMPhotoCompressionOption_Subsampling);
        IIONumber::~IIONumber((IIONumber *)permuteMap);
        IIONumber::IIONumber((IIONumber *)v173, 6);
        IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v173, *(const void **)gIIO_kCMPhotoCompressionOption_QualityControllerType);
        IIONumber::~IIONumber((IIONumber *)v173);
        goto LABEL_179;
      }
      IIONumber::IIONumber((IIONumber *)v175, 3);
      IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v175, *(const void **)gIIO_kCMPhotoCompressionOption_QualityControllerType);
      IIONumber::~IIONumber((IIONumber *)v175);
      memset(permuteMap, 0, sizeof(permuteMap));
      size_t v183 = 0;
      IIODictionary::IIODictionary((IIODictionary *)permuteMap);
      IIONumber::IIONumber((IIONumber *)v174, v19);
      IIODictionary::setObjectForKey((uint64_t)permuteMap, (uint64_t)v174, *(const void **)gIIO_kCMPhotoQualityControllerParameter_QualityValue);
      IIONumber::~IIONumber((IIONumber *)v174);
      IIODictionary::setObjectForKey((IIODictionary *)&dest, *(const void **)&permuteMap[8], *(const __CFString **)gIIO_kCMPhotoCompressionOption_QualityControllerParameters);
    }
    IIODictionary::~IIODictionary((IIODictionary *)permuteMap);
  }
LABEL_179:
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)a4, @"kCGImageDestinationEnableRGBToYUVDithering");
  CFDictionaryRef v75 = ObjectForKey;
  if (ObjectForKey)
  {
    CFTypeID v76 = CFGetTypeID(ObjectForKey);
    if (v76 == CFBooleanGetTypeID()) {
      IIODictionary::setObjectForKey((IIODictionary *)&dest, v75, *(const __CFString **)gIIO_kCMPhotoCompressionOption_RGBToYUVDithering);
    }
  }
  if (v147) {
    IIODictionary::setObjectForKey((IIODictionary *)&dest, (const void *)*MEMORY[0x1E4F1CFD0], *(const __CFString **)gIIO_kCMPhotoCompressionOption_PrimaryImage);
  }
  if (*((_DWORD *)this + 10) == 1752589105)
  {
    if (a4 && IIODictionary::containsKey((IIODictionary *)a4, @"Orientation")) {
      int v77 = IIODictionary::getUint32ForKey((IIODictionary *)a4, @"Orientation");
    }
    else {
      int v77 = 1;
    }
    IIONumber::IIONumber((IIONumber *)v172, v77);
    IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v172, *(const void **)gIIO_kCMPhotoCompressionOption_ImageOrientation);
    IIONumber::~IIONumber((IIONumber *)v172);
  }
  char v78 = IIODictionary::containsKey((IIODictionary *)a4, @"{HEIF}");
  if (v78) {
    HEIFWritePlugin::updateHEIFProperties(v78, (IIODictionary *)&dest, (IIODictionary *)a4);
  }
  __n128 updated = HEIFWritePlugin::updateHardwareEncodeOptions(this, (IIODictionary *)&dest, (IIODictionary *)a4);
  uint64_t v80 = *((void *)this + 7);
  if (!*((unsigned char *)this + 125))
  {
    uint64_t v23 = gFunc_CMPhotoCompressionSessionAddImage(v80, dest.height, v188[0], &v184, updated);
    if ((gIIODebugFlags & 0x30000) == 0) {
      goto LABEL_220;
    }
    char v83 = (const void *)*((void *)this + 7);
    PixelFormatint Type = gFunc_CVPixelBufferGetPixelFormatType(v188[0]);
    unsigned int v85 = PixelFormatType >> 24;
    if (PixelFormatType < 0) {
      int v86 = __maskrune(v85, 0x40000uLL);
    }
    else {
      int v86 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v85 + 60) & 0x40000;
    }
    if (v86) {
      int v87 = gFunc_CVPixelBufferGetPixelFormatType(v188[0]) & 0xFF000000;
    }
    else {
      int v87 = 771751936;
    }
    signed int v88 = gFunc_CVPixelBufferGetPixelFormatType(v188[0]) << 8;
    unsigned int v89 = v88 >> 24;
    if (v88 < 0) {
      int v90 = __maskrune(v89, 0x40000uLL);
    }
    else {
      int v90 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v89 + 60) & 0x40000;
    }
    if (v90) {
      unsigned int v91 = gFunc_CVPixelBufferGetPixelFormatType(v188[0]) >> 16;
    }
    else {
      LOBYTE(v91) = 46;
    }
    int v92 = gFunc_CVPixelBufferGetPixelFormatType(v188[0]);
    int v93 = v92 << 16;
    unsigned int v94 = (__int16)v92 >> 8;
    if (v93 < 0) {
      int v95 = __maskrune(v94, 0x40000uLL);
    }
    else {
      int v95 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v94 + 60) & 0x40000;
    }
    if (v95) {
      unsigned int v96 = gFunc_CVPixelBufferGetPixelFormatType(v188[0]) >> 8;
    }
    else {
      LOBYTE(v96) = 46;
    }
    int v97 = gFunc_CVPixelBufferGetPixelFormatType(v188[0]);
    if ((v97 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v97 + 60) & 0x40000) != 0) {
        goto LABEL_216;
      }
    }
    else if (__maskrune((char)v97, 0x40000uLL))
    {
LABEL_216:
      char v98 = gFunc_CVPixelBufferGetPixelFormatType(v188[0]);
LABEL_219:
      ImageIOLog("    CMPhotoCompressionSessionAddImage: [session:%p] '%c%c%c%c' err=%d\n", v83, (v87 >> 24), (char)v91, (char)v96, v98, v23);
      goto LABEL_220;
    }
    char v98 = 46;
    goto LABEL_219;
  }
  uint64_t v81 = *((int *)this + 16);
  long long v170 = *(_OWORD *)((char *)this + 68);
  uint64_t v171 = *(void *)((char *)this + 84);
  uint64_t v82 = gFunc_CMPhotoCompressionSessionAddImageToSequence(v80, v81, &v170, dest.height, v188[0], &v184);
  uint64_t v23 = v82;
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("seq CMPhotoCompressionSessionAddImageToSequence: [session:%p]  seq:%d  img:%d  err=%d\n", *((const void **)this + 7), *((_DWORD *)this + 16), v184, v82);
  }
LABEL_220:
  if (v23 == -15474)
  {
    IIONumber::IIONumber((IIONumber *)permuteMap, 5);
    IIODictionary::setObjectForKey((IIODictionary *)&dest, v183, *(const __CFString **)gIIO_kCMPhotoCompressionOption_Subsampling);
    IIONumber::~IIONumber((IIONumber *)permuteMap);
    IIODictionary::removeObjectForKey((IIODictionary *)&dest, *(const __CFString **)gIIO_kCMPhotoCompressionOption_QualityControllerType);
    IIONumber::IIONumber((IIONumber *)v169, 3);
    IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v169, *(const void **)gIIO_kCMPhotoCompressionOption_QualityControllerType);
    IIONumber::~IIONumber((IIONumber *)v169);
    memset(permuteMap, 0, sizeof(permuteMap));
    size_t v183 = 0;
    IIODictionary::IIODictionary((IIODictionary *)permuteMap);
    IIONumber::IIONumber((IIONumber *)v168, v19);
    IIODictionary::setObjectForKey((uint64_t)permuteMap, (uint64_t)v168, *(const void **)gIIO_kCMPhotoQualityControllerParameter_QualityValue);
    IIONumber::~IIONumber((IIONumber *)v168);
    IIODictionary::setObjectForKey((IIODictionary *)&dest, *(const void **)&permuteMap[8], *(const __CFString **)gIIO_kCMPhotoCompressionOption_QualityControllerParameters);
    uint64_t v100 = *((void *)this + 7);
    if (*((unsigned char *)this + 125))
    {
      uint64_t v101 = *((int *)this + 16);
      long long v166 = *(_OWORD *)((char *)this + 68);
      uint64_t v167 = *(void *)((char *)this + 84);
      uint64_t v102 = gFunc_CMPhotoCompressionSessionAddImageToSequence(v100, v101, &v166, dest.height, v188[0], &v184);
      uint64_t v23 = v102;
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("seq CMPhotoCompressionSessionAddImageToSequence: [session:%p]  seq:%d  img:%d  err=%d\n", *((const void **)this + 7), *((_DWORD *)this + 16), v184, v102);
      }
    }
    else
    {
      uint64_t v103 = gFunc_CMPhotoCompressionSessionAddImage(v100, dest.height, v188[0], &v184, v99);
      uint64_t v23 = v103;
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("    CMPhotoCompressionSessionAddImage (420f): [session:%p]  err=%d\n", *((const void **)this + 7), v103);
      }
    }
    IIODictionary::~IIODictionary((IIODictionary *)permuteMap);
  }
  if (v23)
  {
    if (*((unsigned char *)this + 125)) {
      BOOL v130 = "CMPhotoCompressionSessionAddImageToSequence";
    }
    else {
      BOOL v130 = "CMPhotoCompressionSessionAddImage";
    }
    __int16 v131 = IIOCMErrorString(v23);
    int v132 = *((_DWORD *)this + 10);
    unsigned int v133 = v132 >> 24;
    if (v132 < 0)
    {
      int v134 = __maskrune(v133, 0x40000uLL);
      int v132 = *((_DWORD *)this + 10);
    }
    else
    {
      int v134 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v133 + 60) & 0x40000;
    }
    if (v134) {
      uint64_t v135 = (v132 >> 24);
    }
    else {
      uint64_t v135 = 46;
    }
    unsigned int v136 = v132 << 8 >> 24;
    if (v132 << 8 < 0)
    {
      int v137 = __maskrune(v136, 0x40000uLL);
      int v132 = *((_DWORD *)this + 10);
    }
    else
    {
      int v137 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v136 + 60) & 0x40000;
    }
    if (v137) {
      uint64_t v138 = (v132 << 8 >> 24);
    }
    else {
      uint64_t v138 = 46;
    }
    unsigned int v139 = (__int16)v132 >> 8;
    if (v132 << 16 < 0)
    {
      int v140 = __maskrune(v139, 0x40000uLL);
      int v132 = *((_DWORD *)this + 10);
    }
    else
    {
      int v140 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v139 + 60) & 0x40000;
    }
    if (v140) {
      uint64_t v141 = ((__int16)v132 >> 8);
    }
    else {
      uint64_t v141 = 46;
    }
    if ((v132 << 24) <= 0x7F000000) {
      int v142 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v132 + 60) & 0x40000;
    }
    else {
      int v142 = __maskrune((char)v132, 0x40000uLL);
    }
    if (v142) {
      uint64_t v143 = *((char *)this + 40);
    }
    else {
      uint64_t v143 = 46;
    }
    LogError("writeImageAtIndex", 1236, "*** %s: err = %s [%d]    (codec: '%c%c%c%c')\n", v130, v131, v23, v135, v138, v141, v143);
    IIODictionary::~IIODictionary((IIODictionary *)&dest);
  }
  else
  {
    if ((v158 | 2) == 3)
    {
      memset(permuteMap, 0, sizeof(permuteMap));
      size_t v183 = 0;
      IIODictionary::IIODictionary((IIODictionary *)permuteMap);
      int v104 = gFunc_CMPhotoCompressionSessionAddAuxiliaryImage(*((void *)this + 7), v184, 3, 0, *(void *)&permuteMap[8], v188[0], 0);
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("    CMPhotoCompressionSessionAddAuxiliaryImage: [session:%p]  err=%d\n", *((const void **)this + 7), v104);
      }
      IIODictionary::~IIODictionary((IIODictionary *)permuteMap);
    }
    IIODictionary::~IIODictionary((IIODictionary *)&dest);
    BOOL v105 = IIODictionary::getBoolForKey((IIODictionary *)a4, @"kCGImageDestinationEmbedThumbnail");
    if (v105)
    {
      *(void *)permuteMap = 320;
      int v106 = gFunc_CMPhotoDetermineMIAFCompliantThumbnailMaxPixelSize(permuteMap, (float)Width, (float)Height);
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("    CMPhotoDetermineMIAFCompliantThumbnailMaxPixelSize: [session:%p] size:%u err:%d\n", *((const void **)this + 7), *(_DWORD *)permuteMap, v106);
      }
      memset(&dest, 0, 24);
      IIODictionary::IIODictionary((IIODictionary *)&dest);
      IIONumber::IIONumber((IIONumber *)v165, *(int *)permuteMap);
      IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v165, *(const void **)gIIO_kCMPhotoCompressionOption_MaxPixelSize);
      IIONumber::~IIONumber((IIONumber *)v165);
      IIONumber::IIONumber((IIONumber *)v164, *((_DWORD *)this + 10));
      IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v164, *(const void **)gIIO_kCMPhotoCompressionOption_CodecType);
      IIONumber::~IIONumber((IIONumber *)v164);
      IIODictionary::setObjectForKey((IIODictionary *)&dest, (const void *)*MEMORY[0x1E4F1CFD0], *(const __CFString **)gIIO_kCMPhotoCompressionOption_ForceHighSpeed);
      int v107 = gFunc_CMPhotoCompressionSessionAddThumbnail(*((void *)this + 7), v184, dest.height, v188[0]);
      int v108 = v107;
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("    CMPhotoCompressionSessionAddThumbnail: [session:%p]  img:%d  err=%d\n", *((const void **)this + 7), v184, v107);
      }
      if (v108)
      {
        __int16 v109 = IIOCMErrorString(v108);
        _cg_jpeg_mem_term("writeImageAtIndex", 1271, "*** CMPhotoCompressionSessionAddThumbnail  err = %s [%d]\n", v109, v108);
      }
      IIODictionary::~IIODictionary((IIODictionary *)&dest);
    }
    if (a4)
    {
      Exifuint64_t Data = HEIFWritePlugin::createExifData((HEIFWritePlugin *)v105, (IIODictionary *)a4);
      if (ExifData)
      {
        int v111 = gFunc_CMPhotoCompressionSessionAddExif (*((void *)this + 7), v184, 0, ExifData);
        int v112 = v111;
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("    CMPhotoCompressionSessionAddExif: [session:%p]  img:%d  err=%d\n", *((const void **)this + 7), v184, v111);
        }
        if (v112)
        {
          double v113 = IIOCMErrorString(v112);
          _cg_jpeg_mem_term("writeImageAtIndex", 1290, "*** CMPhotoCompressionSessionAddExif  err = %s [%d]\n", v113, v112);
          IIO_CFShow(a4[1], 2, "imageProperties");
        }
        CFRelease(ExifData);
      }
      XMPuint64_t Data = HEIFWritePlugin::createXMPData(this, (IIODictionary *)a4);
      if (XMPData)
      {
        int v115 = gFunc_CMPhotoCompressionSessionAddXMP(*((void *)this + 7), v184, 0, XMPData);
        int v116 = v115;
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("    CMPhotoCompressionSessionAddXMP: [session:%p]  img:%d  err=%d\n", *((const void **)this + 7), v184, v115);
        }
        if (v116)
        {
          BOOL v117 = IIOCMErrorString(v116);
          _cg_jpeg_mem_term("writeImageAtIndex", 1312, "*** CMPhotoCompressionSessionAddXMP  err = %s [%d]\n", v117, v116);
          IIO_CFShow(a4[1], 2, "imageProperties");
        }
        CFRelease(XMPData);
      }
    }
    uint64_t v23 = HEIFWritePlugin::writeAuxImages(this, a6, v184);
    if (!v23)
    {
      HEIFWritePlugin::writeAlternateImage(this, a6, v184);
      CFStringRef v118 = @"UnclampedDelayTime";
      if ((IIODictionary::containsKeyGroup((IIODictionary *)a4, @"UnclampedDelayTime", @"{HEICS}") & 1) != 0|| (CFStringRef v118 = @"DelayTime", IIODictionary::containsKeyGroup((IIODictionary *)a4, @"DelayTime", @"{HEICS}")))
      {
        double DoubleForKeyGroup = IIODictionary::getDoubleForKeyGroup((IIODictionary *)a4, v118, @"{HEICS}");
      }
      else
      {
        double DoubleForKeyGroup = 0.1;
      }
      memset(&dest, 0, 24);
      gFunc_CMTimeMake(&dest, (uint64_t)(DoubleForKeyGroup * 1000.0), 1000);
      long long v162 = *(_OWORD *)((char *)this + 68);
      uint64_t v163 = *(void *)((char *)this + 84);
      long long v160 = *(_OWORD *)&dest.data;
      vImagePixelCount v161 = dest.width;
      gFunc_CMTimeAdd(permuteMap, &v162, &v160);
      uint64_t v23 = 0;
      __n128 v18 = *(__n128 *)permuteMap;
      *(_OWORD *)((char *)this + 68) = *(_OWORD *)permuteMap;
      *(void *)((char *)this + 84) = v183;
      goto LABEL_259;
    }
    __n128 v18 = _cg_jpeg_mem_term("writeImageAtIndex", 1323, "*** ERROR: failed to write aux images...");
  }
LABEL_261:
  if (v188[0])
  {
LABEL_262:
    gFunc_CVPixelBufferRelease(v18);
    goto LABEL_265;
  }
  if (v155) {
    free(v155);
  }
LABEL_265:
  IIODictionary::~IIODictionary((IIODictionary *)&v185);
  return v23;
}

void sub_1887481A8(_Unwind_Exception *a1)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 136));
  _Unwind_Resume(a1);
}

void CVPixelBufferReleaseImageBlock(void *a1, const void *a2)
{
  if (a1) {
    free(a1);
  }
}

uint64_t HEIFWritePlugin::prepareHEIFWriting(HEIFWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3)
{
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v23);
  if (IIOWritePlugin::getImageCount((IIOImageDestination **)this) >= 2) {
    IIODictionary::setObjectForKey((IIODictionary *)&v23, (const void *)*MEMORY[0x1E4F1CFD0], *(const __CFString **)gIIO_kCMPhotoCompressionSessionOption_UseCodecSessionPool);
  }
  CFDataRef v4 = (const void **)((char *)this + 56);
  uint64_t v5 = gFunc_CMPhotoCompressionSessionCreate(*MEMORY[0x1E4F1CF80], v24, (char *)this + 56);
  uint64_t v6 = v5;
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    CMPhotoCompressionSessionCreate: [session:%p]  err=%d\n", *v4, v5);
  }
  if (v6 || !*v4)
  {
    CFDictionaryRef v11 = IIOCMErrorString(v6);
    _cg_jpeg_mem_term("prepareHEIFWriting", 1663, "*** CMPhotoCompressionSessionCreate: err = %s [%d]\n", v11, v6);
  }
  else
  {
    uint64_t v20 = 0;
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v20);
    IIONumber::IIONumber((IIONumber *)v19, 1);
    IIODictionary::setObjectForKey((uint64_t)&v20, (uint64_t)v19, *(const void **)gIIO_kCMPhotoCompressionContainerOption_BackingType);
    IIONumber::~IIONumber((IIONumber *)v19);
    if (*((_DWORD *)this + 10) == 1785750887)
    {
      IIONumber::IIONumber((IIONumber *)v18, 1);
      CFDictionaryRef v7 = (IIONumber *)v18;
      IIODictionary::setObjectForKey((uint64_t)&v20, (uint64_t)v18, *(const void **)gIIO_kCMPhotoCompressionContainerOption_Format);
    }
    else
    {
      IIONumber::IIONumber((IIONumber *)v17, 0);
      CFDictionaryRef v7 = (IIONumber *)v17;
      IIODictionary::setObjectForKey((uint64_t)&v20, (uint64_t)v17, *(const void **)gIIO_kCMPhotoCompressionContainerOption_Format);
    }
    IIONumber::~IIONumber(v7);
    uint64_t v8 = gFunc_CMPhotoCompressionSessionOpenEmptyContainer(*v4, v21);
    uint64_t v6 = v8;
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    CMPhotoCompressionSessionOpenEmptyContainer: [session:%p]  err=%d\n", *v4, v8);
    }
    if (v6)
    {
      uint64_t v12 = IIOCMErrorString(v6);
      _cg_jpeg_mem_term("prepareHEIFWriting", 1689, "*** CMPhotoCompressionSessionOpenEmptyContainer: err = %s [%d]\n", v12, v6);
    }
    else if (*((unsigned char *)this + 125))
    {
      uint64_t v16 = 0;
      uint64_t started = gFunc_CMPhotoCompressionSessionStartImageSequence(*v4, 0, &v16);
      uint64_t v6 = started;
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("seq CMPhotoCompressionSessionStartImageSequence: [session:%p]  seq:%d  err=%d\n", *v4, v16, started);
      }
      if (v6)
      {
        int v13 = IIOCMErrorString(v6);
        _cg_jpeg_mem_term("prepareHEIFWriting", 1696, "*** CMPhotoCompressionSessionStartImageSequence: err = %s [%d]\n", v13, v6);
      }
      else
      {
        *((_DWORD *)this + 16) = v16;
        gFunc_CMTimeMake(&v14, 0, 1000);
        *(_OWORD *)((char *)this + 68) = v14;
        *(void *)((char *)this + 84) = v15;
      }
    }
    else
    {
      uint64_t v6 = 0;
    }
    IIODictionary::~IIODictionary((IIODictionary *)&v20);
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v23);
  return v6;
}

void sub_188748650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v8 - 80));
  IIODictionary::~IIODictionary((IIODictionary *)(v8 - 56));
  _Unwind_Resume(a1);
}

uint64_t HEIFWritePlugin::writeAuxImages(HEIFWritePlugin *this, int a2, uint64_t a3)
{
  CFArrayRef v4 = (const __CFArray *)*((void *)this + 6);
  if (!v4) {
    return 0;
  }
  memset(v51, 0, 24);
  CFDictionaryRef v7 = IIOArray::IIOArray((IIOArray *)v51, v4);
  unsigned int Count = IIOArray::getCount(v7);
  if (!Count)
  {
    uint64_t v10 = 0;
    goto LABEL_47;
  }
  CFIndex v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = Count;
  while (1)
  {
    ObjectAtIndedouble x = IIOArray::getObjectAtIndex((IIOArray *)v51, v9);
    memset(v50, 0, sizeof(v50));
    int v13 = IIODictionary::IIODictionary((IIODictionary *)v50, ObjectAtIndex);
    CFDictionaryRef Uint32ForKey = IIODictionary::getUint32ForKey(v13, "AuxiliaryImageType");
    CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v50, "AuxiliaryImageURN");
    BOOL BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v50, "customMetadata");
    uint64_t v47 = 0;
    uint64_t v48 = 0;
    uint64_t v49 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v47);
    uint64_t v46 = 0;
    if (IIODictionary::getUint32ForKey((IIODictionary *)v50, @"ImageIndex") != a2
      || ObjectForKey
      && CFEqual(@"kCGImageAuxiliaryDataTypeISOGainMap", ObjectForKey))
    {
      goto LABEL_36;
    }
    CFStringRef v17 = @"kCGImageAuxiliaryDataTypeDisparity";
    if (Uint32ForKey == 1) {
      goto LABEL_22;
    }
    if (Uint32ForKey == 5)
    {
      CFStringRef v17 = @"kCGImageAuxiliaryDataTypePortraitEffectsMatte";
LABEL_22:
      CFDictionaryRef v28 = IIODictionary::getObjectForKey((IIODictionary *)v50, v17);
      goto LABEL_23;
    }
    CFStringRef v17 = @"kCGImageAuxiliaryDataTypeDepth";
    if (Uint32ForKey == 2) {
      goto LABEL_22;
    }
    if (ObjectForKey)
    {
      CFComparisonResult v18 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_Alpha, ObjectForKey, 0);
      CFStringRef v19 = @"kCGImageAuxiliaryDataTypeAlpha";
      if (v18 == kCFCompareEqualTo) {
        goto LABEL_39;
      }
      CFComparisonResult v20 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_Depth, ObjectForKey, 0);
      CFStringRef v19 = @"kCGImageAuxiliaryDataTypeDepth";
      if (v20 == kCFCompareEqualTo) {
        goto LABEL_39;
      }
      CFComparisonResult v21 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_PortraitEffectsMatte, ObjectForKey, 0);
      CFStringRef v19 = @"kCGImageAuxiliaryDataTypePortraitEffectsMatte";
      if (v21 == kCFCompareEqualTo) {
        goto LABEL_39;
      }
      CFComparisonResult v22 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte, ObjectForKey, 0);
      CFStringRef v19 = @"kCGImageAuxiliaryDataTypeSemanticSegmentationSkinMatte";
      if (v22 == kCFCompareEqualTo) {
        goto LABEL_39;
      }
      CFComparisonResult v23 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte, ObjectForKey, 0);
      CFStringRef v19 = @"kCGImageAuxiliaryDataTypeSemanticSegmentationHairMatte";
      if (v23 == kCFCompareEqualTo) {
        goto LABEL_39;
      }
      CFComparisonResult v24 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte, ObjectForKey, 0);
      CFStringRef v19 = @"kCGImageAuxiliaryDataTypeSemanticSegmentationTeethMatte";
      if (v24 == kCFCompareEqualTo) {
        goto LABEL_39;
      }
      CFComparisonResult v25 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte, ObjectForKey, 0);
      CFStringRef v19 = @"kCGImageAuxiliaryDataTypeSemanticSegmentationGlassesMatte";
      if (v25
        && (CFComparisonResult v26 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte, ObjectForKey, 0), v19 = @"kCGImageAuxiliaryDataTypeSemanticSegmentationSkyMatte", v26)&& (v27 = CFStringCompare(*(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap, ObjectForKey, 0), v19 = @"kCGImageAuxiliaryDataTypeHDRGainMap", v27))
      {
        CFDictionaryRef v28 = 0;
      }
      else
      {
LABEL_39:
        CFDictionaryRef v28 = IIODictionary::getObjectForKey((IIODictionary *)v50, v19);
      }
      if (BoolForKey) {
        CFDictionaryRef v28 = IIODictionary::getObjectForKey((IIODictionary *)v50, ObjectForKey);
      }
      IIODictionary::setObjectForKey((IIODictionary *)&v47, ObjectForKey, *(const __CFString **)gIIO_kCMPhotoCompressionOption_AuxiliaryImageCustomTypeURN);
    }
    else
    {
      CFDictionaryRef v28 = 0;
    }
LABEL_23:
    if (!BoolForKey) {
      break;
    }
    uint64_t v43 = 0;
    uint64_t v44 = 0;
    uint64_t v45 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v43);
    uint64_t v40 = 0;
    uint64_t v41 = 0;
    uint64_t v42 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v40);
    CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup((IIODictionary *)v50, @"kCGImageAuxiliaryDataInfoData", ObjectForKey);
    IIODictionary::setObjectForKey((IIODictionary *)&v43, ObjectForKeyGroup, *(const __CFString **)gIIO_kCMPhotoCustomMetadata_Data);
    IIODictionary::setObjectForKey((IIODictionary *)&v43, ObjectForKey, *(const __CFString **)gIIO_kCMPhotoCustomMetadata_URI);
    uint64_t v30 = gFunc_CMPhotoCompressionSessionAddCustomMetadata(*((void *)this + 7), a3, v41, v44);
    uint64_t v10 = v30;
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    CMPhotoCompressionSessionAddCustomMetadata: [session:%p]  img:%d  err=%d\n", *((const void **)this + 7), a3, v30);
    }
    if (v10)
    {
      unsigned int v31 = IIOCMErrorString(v10);
      _cg_jpeg_mem_term("writeAuxImages", 1469, "*** CMPhotoCompressionSessionAddCustomMetadata  err = %s [%d]\n", v31, v10);
      int v32 = 5;
    }
    else
    {
      int v32 = 0;
    }
    IIODictionary::~IIODictionary((IIODictionary *)&v40);
    IIODictionary::~IIODictionary((IIODictionary *)&v43);
    if (v10)
    {
      IIODictionary::~IIODictionary((IIODictionary *)&v47);
      IIODictionary::~IIODictionary((IIODictionary *)v50);
      if ((v32 | 4) != 4) {
        goto LABEL_47;
      }
      goto LABEL_37;
    }
LABEL_36:
    IIODictionary::~IIODictionary((IIODictionary *)&v47);
    IIODictionary::~IIODictionary((IIODictionary *)v50);
LABEL_37:
    if (v11 == ++v9) {
      goto LABEL_47;
    }
  }
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v33 = IIODictionary::IIODictionary((IIODictionary *)&v43, v28);
  CFDictionaryRef PixelBufferFromAuxiliaryDataInfo = HEIFWritePlugin::createPixelBufferFromAuxiliaryDataInfo(v33, (IIODictionary *)&v43, v34);
  CFDictionaryRef v36 = IIODictionary::getObjectForKey((IIODictionary *)&v43, @"kCGImageAuxiliaryDataInfoMetadata");
  uint64_t v10 = gFunc_CMPhotoCompressionSessionAddAuxiliaryImage(*((void *)this + 7), a3, Uint32ForKey, v36, v48, PixelBufferFromAuxiliaryDataInfo, &v46);
  gFunc_CVPixelBufferRelease(v37);
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    CMPhotoCompressionSessionAddAuxiliaryImage: [session:%p]  img:%d  err=%d\n", *((const void **)this + 7), a3, v10);
  }
  if (!v10)
  {
    IIODictionary::~IIODictionary((IIODictionary *)&v43);
    goto LABEL_36;
  }
  int v38 = IIOCMErrorString(v10);
  _cg_jpeg_mem_term("writeAuxImages", 1484, "*** Error: CMPhotoCompressionSessionAddAuxiliaryImage  err = %s [%d]\n", v38, v10);
  IIODictionary::~IIODictionary((IIODictionary *)&v43);
  IIODictionary::~IIODictionary((IIODictionary *)&v47);
  IIODictionary::~IIODictionary((IIODictionary *)v50);
LABEL_47:
  IIOArray::~IIOArray((IIOArray *)v51);
  return v10;
}

void sub_188748CB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a29);
  IIODictionary::~IIODictionary((IIODictionary *)(v29 - 160));
  IIODictionary::~IIODictionary((IIODictionary *)(v29 - 136));
  IIOArray::~IIOArray((IIOArray *)(v29 - 112));
  _Unwind_Resume(a1);
}

uint64_t HEIFWritePlugin::writeAlternateImage(HEIFWritePlugin *this, int a2, uint64_t a3)
{
  CFArrayRef v4 = (const __CFArray *)*((void *)this + 6);
  if (v4)
  {
    memset(v46, 0, 24);
    uint64_t v5 = IIOArray::IIOArray((IIOArray *)v46, v4);
    unsigned int Count = IIOArray::getCount(v5);
    if (Count)
    {
      unsigned int v7 = 0;
      CFTypeRef value = (void *)*MEMORY[0x1E4F1CFC8];
      CFStringRef name = (const __CFString *)*MEMORY[0x1E4F1DC50];
      do
      {
        ObjectAtIndedouble x = IIOArray::getObjectAtIndex((IIOArray *)v46, v7);
        memset(v45, 0, sizeof(v45));
        CFIndex v9 = IIODictionary::IIODictionary((IIODictionary *)v45, ObjectAtIndex);
        CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(v9, "AuxiliaryImageURN");
        memset(v44, 0, sizeof(v44));
        IIODictionary::IIODictionary((IIODictionary *)v44);
        if (IIODictionary::getUint32ForKey((IIODictionary *)v45, @"ImageIndex") == a2
          && ObjectForKey
          && CFEqual(@"kCGImageAuxiliaryDataTypeISOGainMap", ObjectForKey))
        {
          CFDictionaryRef v11 = IIODictionary::getObjectForKey((IIODictionary *)v45, @"kCGImageAuxiliaryDataTypeISOGainMap");
          memset(v43, 0, sizeof(v43));
          uint64_t v12 = IIODictionary::IIODictionary((IIODictionary *)v43, v11);
          CFDictionaryRef v13 = IIODictionary::getObjectForKey(v12, @"kCGImageAuxiliaryDataInfoMetadata");
          long long v14 = IIODictionary::getObjectForKey((IIODictionary *)v43, @"kCGImageAuxiliaryDataInfoColorSpace");
          CFDictionaryRef PixelBufferFromAuxiliaryDataInfo = HEIFWritePlugin::createPixelBufferFromAuxiliaryDataInfo(v14, (IIODictionary *)v43, v15);
          if (v13)
          {
            CFTypeRef cf = 0;
            if (!CGImageCreateFlexRangeDictionary((uint64_t)v13, &cf)) {
              operator new();
            }
          }
          int v17 = *((_DWORD *)this + 10);
          CFTypeRef cf = 0;
          uint64_t v41 = 0;
          uint64_t v42 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&cf);
          IIODictionary::setObjectForKey((IIODictionary *)&cf, value, *(const __CFString **)gIIO_kCMPhotoCompressionOption_ApplyTransform);
          IIONumber::IIONumber((IIONumber *)v39, v17);
          IIODictionary::setObjectForKey((uint64_t)&cf, (uint64_t)v39, *(const void **)gIIO_kCMPhotoCompressionOption_CodecType);
          IIONumber::~IIONumber((IIONumber *)v39);
          IIONumber::IIONumber((IIONumber *)v38, 3);
          IIODictionary::setObjectForKey((uint64_t)&cf, (uint64_t)v38, *(const void **)gIIO_kCMPhotoCompressionOption_QualityControllerType);
          IIONumber::~IIONumber((IIONumber *)v38);
          uint64_t v35 = 0;
          CFDictionaryRef v36 = 0;
          uint64_t v37 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v35);
          IIONumber::IIONumber((IIONumber *)v34, 0.9);
          IIODictionary::setObjectForKey((uint64_t)&v35, (uint64_t)v34, *(const void **)gIIO_kCMPhotoQualityControllerParameter_QualityValue);
          IIONumber::~IIONumber((IIONumber *)v34);
          IIODictionary::setObjectForKey((IIODictionary *)&cf, v36, *(const __CFString **)gIIO_kCMPhotoCompressionOption_QualityControllerParameters);
          uint64_t v31 = 0;
          uint64_t v32 = 0;
          uint64_t v33 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v31);
          CGColorSpaceRef v29 = (CGColorSpaceRef)&unk_1ED4DFD58;
          CGColorSpaceRef v30 = 0;
          if (v14) {
            CGColorSpaceRef v18 = CGColorSpaceRetain(v14);
          }
          else {
            CGColorSpaceRef v18 = CGColorSpaceCreateWithName(name);
          }
          CGColorSpaceRef v30 = v18;
          IIODictionary::setObjectForKey((IIODictionary *)&v31, v18, *(const __CFString **)gIIO_kCMPhotoCompressionOption_ColorSpace);
          CFDictionaryRef v19 = IIODictionary::getObjectForKey((IIODictionary *)v43, @"kCGImageAuxiliaryDataInfoMeteorPlusMetadata");
          uint64_t v28 = 0;
          int v20 = gFunc_CMPhotoCompressionSessionAddTmapImageOneShot(*((void *)this + 7), a3, v41, v32, PixelBufferFromAuxiliaryDataInfo, 0, v19 != 0, v19, &v28);
          int v21 = v20;
          if (v20)
          {
            CFComparisonResult v22 = IIOCMErrorString(v20);
            _cg_jpeg_mem_term("writeAlternateImage", 1576, "*** Error: CMPhotoCompressionSessionAddTmapImageOneShot  err = %s [%d]\n", v22, v21);
          }
          else if (PixelBufferFromAuxiliaryDataInfo)
          {
            CFRelease(PixelBufferFromAuxiliaryDataInfo);
          }
          IIOColorSpace::~IIOColorSpace(&v29);
          IIODictionary::~IIODictionary((IIODictionary *)&v31);
          IIODictionary::~IIODictionary((IIODictionary *)&v35);
          IIODictionary::~IIODictionary((IIODictionary *)&cf);
          IIODictionary::~IIODictionary((IIODictionary *)v43);
          IIODictionary::~IIODictionary((IIODictionary *)v44);
          IIODictionary::~IIODictionary((IIODictionary *)v45);
          if (v21) {
            break;
          }
        }
        else
        {
          IIODictionary::~IIODictionary((IIODictionary *)v44);
          IIODictionary::~IIODictionary((IIODictionary *)v45);
        }
        ++v7;
      }
      while (v7 < Count);
    }
    IIOArray::~IIOArray((IIOArray *)v46);
  }
  return 0;
}

void sub_1887491A8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 200));
  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 176));
  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 152));
  IIOArray::~IIOArray((IIOArray *)(v2 - 128));
  _Unwind_Resume(a1);
}

const __CFDictionary *HEIFWritePlugin::createPixelBufferFromAuxiliaryDataInfo(HEIFWritePlugin *this, IIODictionary *a2, IIODictionary *a3)
{
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a2, @"kCGImageAuxiliaryDataInfoData");
  CFDictionaryRef v5 = IIODictionary::getObjectForKey(a2, @"kCGImageAuxiliaryDataInfoDataDescription");
  CFDictionaryRef v6 = IIODictionary::getObjectForKey(a2, @"kCGImageAuxiliaryDataInfoImage");
  CFDictionaryRef v7 = IIODictionary::getObjectForKey(a2, @"kCGImageAuxiliaryDataInfoPixelBuffer");
  CFDictionaryRef v8 = IIODictionary::getObjectForKey(a2, @"kCGImageAuxiliaryDataInfoIOSurface");
  CFDictionaryRef v21 = 0;
  if (v7)
  {
    CFDictionaryRef v21 = v7;
    CFRetain(v7);
  }
  else if (v8)
  {
    int v9 = gFunc_CVPixelBufferCreateWithIOSurface(0, v8, 0, &v21);
    if (v9)
    {
      IIOCMErrorString(v9);
      LogError("createPixelBufferFromAuxiliaryDataInfo", 1615, "*** Error: CVPixelBufferCreateWithIOSurface  err = %s [%d]\n");
    }
  }
  else if (v6)
  {
    LogError("createPixelBufferFromAuxiliaryDataInfo", 1621, "*** Not supported yet");
  }
  else
  {
    if (ObjectForKey) {
      BOOL v11 = v5 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11)
    {
      memset(v20, 0, sizeof(v20));
      IIODictionary::IIODictionary((IIODictionary *)v20, v5);
      unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v20, @"Width");
      unsigned int v13 = IIODictionary::getUint32ForKey((IIODictionary *)v20, @"Height");
      unsigned int v14 = IIODictionary::getUint32ForKey((IIODictionary *)v20, @"BytesPerRow");
      CFDictionaryRef v15 = IIODictionary::getUint32ForKey((IIODictionary *)v20, @"PixelFormat");
      BytePtr = CFDataGetBytePtr(ObjectForKey);
      int v17 = gFunc_CVPixelBufferCreateWithBytes(*MEMORY[0x1E4F1CF80], Uint32ForKey, v13, v15, BytePtr, v14, 0, 0, 0, &v21);
      int v18 = v17;
      if (v17)
      {
        CFDictionaryRef v19 = IIOCMErrorString(v17);
        LogError("createPixelBufferFromAuxiliaryDataInfo", 1637, "*** Error: CVPixelBufferCreateWithBytes  err = %s [%d]\n", v19, v18);
      }
      IIODictionary::~IIODictionary((IIODictionary *)v20);
    }
  }
  return v21;
}

void sub_1887494E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t HEIFWritePlugin::completeHEIFWriting(HEIFWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3)
{
  v34[0] = 0;
  if (*((unsigned char *)this + 125))
  {
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("seq CMPhotoCompressionSessionEndImageSequence:   [session:%p]  seq:%d\n", *((const void **)this + 7), *((_DWORD *)this + 16));
    }
    gFunc_CMPhotoCompressionSessionEndImageSequence(*((void *)this + 7), *((int *)this + 16), 0);
  }
  CFDictionaryRef v5 = (uint64_t *)*((void *)this + 12);
  for (uint64_t i = (uint64_t *)*((void *)this + 13); v5 != i; ++v5)
  {
    uint64_t v33 = -1;
    uint64_t v6 = *(unsigned int *)(*v5 + 16);
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v30);
    gFunc_CMPhotoCompressionSessionAddGroup(*((void *)this + 7), 0, v6, &v33);
    if (v6 == 1937007986)
    {
      gFunc_CMPhotoCompressionSessionAddImageHandleToGroup(*((void *)this + 7), 0, *(int *)(*v5 + 20), v33);
      gFunc_CMPhotoCompressionSessionAddImageHandleToGroup(*((void *)this + 7), 0, *(int *)(*v5 + 24), v33);
      uint64_t v7 = *v5;
      uint64_t v8 = *(unsigned int *)(*v5 + 28);
      if ((v8 & 0x80000000) == 0)
      {
        gFunc_CMPhotoCompressionSessionAddImageHandleToGroup(*((void *)this + 7), 0, v8, v33);
        IIONumber::IIONumber((IIONumber *)v29, *(_DWORD *)(*v5 + 32));
        IIODictionary::setObjectForKey((uint64_t)&v30, (uint64_t)v29, *(const void **)gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_MonoImageLocation);
        IIONumber::~IIONumber((IIONumber *)v29);
        uint64_t v7 = *v5;
      }
      IIONumber::IIONumber((IIONumber *)v27, *(_DWORD *)(v7 + 40));
      IIODictionary::setObjectForKey((IIODictionary *)&v30, value, *(const __CFString **)gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_DisparityAdjustment);
      IIONumber::~IIONumber((IIONumber *)v27);
    }
    else
    {
      uint64_t v9 = *v5;
      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 0x40000000;
      CFComparisonResult v23 = ___ZN15HEIFWritePlugin19completeHEIFWritingEP25IIOImagePixelDataProviderP13IIODictionary_block_invoke;
      CFComparisonResult v24 = &__block_descriptor_tmp_18;
      CFComparisonResult v25 = this;
      uint64_t v26 = v33;
      for (uint64_t j = *(unsigned int **)(v9 + 48); j != *(unsigned int **)(v9 + 56); ++j)
        v23((uint64_t)v22, *j);
    }
    if (gFunc_CMPhotoCompressionSessionAddGroupProperties) {
      ((void (*)(void, void, uint64_t, uint64_t))gFunc_CMPhotoCompressionSessionAddGroupProperties)(*((void *)this + 7), 0, v33, v31);
    }
    IIODictionary::~IIODictionary((IIODictionary *)&v30);
  }
  uint64_t v30 = 0;
  v27[0] = 0;
  int v11 = gFunc_CMPhotoCompressionSessionCloseContainerAndCopyBacking(*((void *)this + 7), v27, &v30, v34);
  int v13 = v11;
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    CMPhotoCompressionSessionCloseContainerAndCopyBacking: [session:%p]  err=%d\n", *((const void **)this + 7), v11);
  }
  if (v13)
  {
    unsigned int v14 = IIOCMErrorString(v13);
    __n128 v12 = _cg_jpeg_mem_term("completeHEIFWriting", 1769, "*** CMPhotoCompressionSessionCloseContainerAndCopyBacking  err = %s [%d]\n", v14, v13);
  }
  else if (v27[0] == 1)
  {
    BytePtr = CFDataGetBytePtr((CFDataRef)v34[0]);
    size_t Length = CFDataGetLength((CFDataRef)v34[0]);
    IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), BytePtr, Length);
  }
  uint64_t v17 = gFunc_CMPhotoCompressionSessionInvalidate(*((void *)this + 7), v12);
  uint64_t v19 = v17;
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    CMPhotoCompressionSessionInvalidate: [session:%p]  err=%d\n", *((const void **)this + 7), v17);
  }
  if (v19)
  {
    int v20 = IIOCMErrorString(v19);
    __n128 v18 = _cg_jpeg_mem_term("completeHEIFWriting", 1793, "*** CMPhotoCompressionSessionInvalidate  err = %s [%d]\n", v20, v19);
  }
  if (v34[0]) {
    CFRelease(v34[0]);
  }
  if (*((void *)this + 7))
  {
    gFunc_CMPhotoCompressionSessionReleaseHardwareResources(v18);
    CFRelease(*((CFTypeRef *)this + 7));
    *((void *)this + 7) = 0;
  }
  return v19;
}

void sub_1887498DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va1, a12);
  va_start(va, a12);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t ___ZN15HEIFWritePlugin19completeHEIFWritingEP25IIOImagePixelDataProviderP13IIODictionary_block_invoke(uint64_t a1, unsigned int a2)
{
  return gFunc_CMPhotoCompressionSessionAddImageHandleToGroup(*(void *)(*(void *)(a1 + 32) + 56), 0, a2, *(void *)(a1 + 40));
}

uint64_t HEIFWritePlugin::writeAll(IIOImageDestination **this)
{
  Imageunsigned int Count = IIOWritePlugin::getImageCount(this);
  if (ImageCount)
  {
    unint64_t v3 = 0;
    uint64_t v4 = ImageCount;
    while (1)
    {
      PixelDataProviderAtIndedouble x = IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v3);
      PropertiesAtIndedouble x = (IIODictionary *)IIOWritePlugin::getPropertiesAtIndex(this, v3);
      ContainerProperties = (IIODictionary *)IIOWritePlugin::getContainerProperties(this);
      uint64_t v8 = ContainerProperties;
      if (ContainerProperties)
      {
        unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(ContainerProperties, @"capacity");
        if (!PixelDataProviderAtIndex) {
          goto LABEL_7;
        }
      }
      else
      {
        unsigned int Uint32ForKey = 1;
        if (!PixelDataProviderAtIndex)
        {
LABEL_7:
          SourceImageAtIndedouble x = IIOWritePlugin::getSourceImageAtIndex(this, v3);
          goto LABEL_8;
        }
      }
      SourceImageAtIndedouble x = 0;
LABEL_8:
      *(void *)CFComparisonResult v25 = 0;
      uint64_t result = (*((uint64_t (**)(IIOImageDestination **, uint64_t, uint64_t, IIODictionary *, IIODictionary *, unint64_t, int *))*this
                + 5))(this, PixelDataProviderAtIndex, SourceImageAtIndex, PropertiesAtIndex, v8, v3, v25);
      if (result) {
        return result;
      }
      if (IIODictionary::containsKey(PropertiesAtIndex, @"{Groups}"))
      {
        int Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(PropertiesAtIndex, @"GroupIndex", @"{Groups}");
        CFStringRef ObjectForKeyGroup = (const __CFString *)IIODictionary::getObjectForKeyGroup(PropertiesAtIndex, @"GroupType", @"{Groups}");
        if (ObjectForKeyGroup)
        {
          CFStringRef v16 = ObjectForKeyGroup;
          if (CFStringCompare(ObjectForKeyGroup, @"StereoPair", 0))
          {
            CFStringCompare(v16, @"Alternate", 0);
          }
          else
          {
            if (IIODictionary::getBoolForKeyGroup(PropertiesAtIndex, @"GroupImageIsLeftImage", @"{Groups}"))
            {
              int v17 = 0;
            }
            else if (IIODictionary::getBoolForKeyGroup(PropertiesAtIndex, @"GroupImageIsRightImage", @"{Groups}"))
            {
              int v17 = 1;
            }
            else if (IIODictionary::getBoolForKeyGroup(PropertiesAtIndex, @"GroupImageIsMonoscopicImage", @"{Groups}"))
            {
              int v17 = 2;
            }
            else
            {
              int v17 = v3;
            }
            __n128 v18 = HEIFWritePlugin::addGroupItem((uint64_t)this, Uint32ForKeyGroup, 1937007986, v25[0], v17);
            if (v18)
            {
              uint64_t v19 = v18;
              unsigned int v20 = IIODictionary::getUint32ForKeyGroup(PropertiesAtIndex, @"GroupImageBaseline", @"{Groups}");
              unsigned int v21 = IIODictionary::getUint32ForKeyGroup(PropertiesAtIndex, @"GroupImageDisparityAdjustment", @"{Groups}");
              if (v20) {
                *((_DWORD *)v19 + 9) = v20;
              }
              if (v21) {
                *((_DWORD *)v19 + 10) = v21;
              }
              CFStringRef v22 = (const __CFString *)IIODictionary::getObjectForKeyGroup(PropertiesAtIndex, @"GroupImageIndexMonoscopicImageLocation", @"{Groups}");
              if (v22)
              {
                CFStringRef v23 = v22;
                if (CFStringCompare(v22, @"Left", 0))
                {
                  if (CFStringCompare(v23, @"Right", 0))
                  {
                    if (CFStringCompare(v23, @"Center", 0)) {
                      int v24 = 0;
                    }
                    else {
                      int v24 = 3;
                    }
                  }
                  else
                  {
                    int v24 = 2;
                  }
                }
                else
                {
                  int v24 = 1;
                }
                *((_DWORD *)v19 + 8) = v24;
              }
            }
          }
        }
      }
      if (v3 == Uint32ForKey - 1) {
        HEIFWritePlugin::completeHEIFWriting((HEIFWritePlugin *)this, v12, v13);
      }
      if (v4 == ++v3) {
        return 0;
      }
    }
  }
  return 4294967246;
}

HEIFGroup *HEIFWritePlugin::addGroupItem(uint64_t a1, int a2, int a3, int a4, int a5)
{
  for (uint64_t i = *(HEIFGroup ***)(a1 + 96); ; ++i)
  {
    if (i == *(HEIFGroup ***)(a1 + 104)) {
      operator new();
    }
    uint64_t v6 = *i;
    if (*((_DWORD *)*i + 2) == a2) {
      break;
    }
  }
  if (a3 == 1634497650)
  {
    int v7 = HEIFGroup::setOtherImage(v6, a4);
  }
  else
  {
    if (a3 != 1937007986) {
      return v6;
    }
    if (a5 == 2)
    {
      int v7 = HEIFGroup::setMonoImage(v6, a4);
    }
    else if (a5 == 1)
    {
      int v7 = HEIFGroup::setRightImage(v6, a4);
    }
    else
    {
      if (a5) {
        return v6;
      }
      int v7 = HEIFGroup::setLeftImage(v6, a4);
    }
  }
  if (v7) {
    *((_DWORD *)v6 + 3) = -1;
  }
  return v6;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(4 * a2);
}

uint64_t TIFFInitPackBits(void *a1)
{
  a1[126] = PackBitsDecode;
  a1[128] = PackBitsDecode;
  a1[130] = PackBitsDecode;
  a1[124] = PackBitsPreEncode;
  a1[125] = PackBitsPostEncode;
  a1[127] = PackBitsEncode;
  a1[129] = PackBitsEncodeChunk;
  a1[131] = PackBitsEncodeChunk;
  return 1;
}

uint64_t PackBitsDecode(uint64_t a1, char *__b, int64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = *(unsigned __int8 **)(a1 + 1152);
  uint64_t v12 = *(void *)(a1 + 1160);
LABEL_2:
  uint64_t v13 = 0;
  uint64_t v14 = v12;
  while (1)
  {
    uint64_t v15 = v13;
    if (v14 < 1 || a3 < 1) {
      break;
    }
    uint64_t v16 = (char)v11[v13];
    if ((v16 & 0x8000000000000000) == 0)
    {
      int64_t v20 = v11[v13];
      if (v16 >= a3)
      {
        TIFFWarningExtR(a1, "PackBitsDecode", "Discarding %lld bytes to avoid buffer overrun", a4, a5, a6, a7, a8, v16 - a3 + 1);
        int64_t v20 = a3 - 1;
      }
      size_t v17 = v20 + 1;
      if (v14 > v20 + 1)
      {
        _TIFFmemcpy(__b, &v11[v15 + 1], v20 + 1);
        v11 += v20 + v15 + 2;
        uint64_t v12 = v12 - v20 - v15 - 2;
        goto LABEL_15;
      }
      uint64_t v27 = ~v15 + v12;
LABEL_21:
      TIFFWarningExtR(a1, "PackBitsDecode", "Terminating PackBitsDecode due to lack of data.", a4, a5, a6, a7, a8, v28);
      *(void *)(a1 + 1152) = &v11[v15 + 1];
      *(void *)(a1 + 1160) = v27;
LABEL_17:
      bzero(__b, a3);
      TIFFErrorExtR(a1, "PackBitsDecode", "Not enough data for scanline %u", v21, v22, v23, v24, v25, *(_DWORD *)(a1 + 876));
      return 0;
    }
    ++v13;
    --v14;
    if (v16 != -128)
    {
      size_t v17 = 1 - v16;
      if (1 - v16 > (unint64_t)a3)
      {
        TIFFWarningExtR(a1, "PackBitsDecode", "Discarding %lld bytes to avoid buffer overrun", a4, a5, a6, a7, a8, 1 - v16 - a3);
        size_t v17 = a3;
      }
      if (v12 != v13)
      {
        __n128 v18 = &v11[v13];
        int v19 = *v18;
        int v11 = v18 + 1;
        v12 += ~v13;
        memset(__b, v19, v17);
LABEL_15:
        __b += v17;
        a3 -= v17;
        goto LABEL_2;
      }
      uint64_t v27 = 0;
      goto LABEL_21;
    }
  }
  *(void *)(a1 + 1152) = &v11[v13];
  *(void *)(a1 + 1160) = v14;
  if (a3 >= 1) {
    goto LABEL_17;
  }
  return 1;
}

uint64_t PackBitsPreEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = (uint64_t)_TIFFmallocExt((void *)a1, 8, a3, a4, a5, a6, a7, a8);
  *(void *)(a1 + 1096) = result;
  if (result)
  {
    if ((*(unsigned char *)(a1 + 17) & 4) != 0) {
      uint64_t v17 = _cg_TIFFTileRowSize(a1, v10, v11, v12, v13, v14, v15, v16);
    }
    else {
      uint64_t v17 = _cg_TIFFScanlineSize(a1, v10, v11, v12, v13, v14, v15, v16);
    }
    **(void **)(a1 + 1096) = v17;
    return 1;
  }
  return result;
}

uint64_t PackBitsPostEncode(uint64_t a1)
{
  uint64_t v1 = *(char **)(a1 + 1096);
  if (v1) {
    _TIFFfreeExt(a1, v1);
  }
  return 1;
}

uint64_t PackBitsEncode(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (char *)a1[144];
  if (a3 < 1)
  {
    uint64_t v28 = a1[144];
    goto LABEL_44;
  }
  uint64_t v10 = a3;
  uint64_t v11 = (unsigned __int8 *)a2;
  int v12 = 0;
  uint64_t v13 = 0;
  unint64_t v14 = a1[140] + a1[141];
  do
  {
    int v15 = *v11;
    if ((unint64_t)v10 < 2)
    {
      uint64_t v10 = 0;
      uint64_t v17 = 1;
      ++v11;
    }
    else
    {
      uint64_t v16 = v10 - 1;
      uint64_t v17 = 1;
      while (v15 == v11[v17])
      {
        ++v17;
        if (!--v16)
        {
          uint64_t v17 = v10;
          v11 += v10;
          uint64_t v10 = 0;
          goto LABEL_10;
        }
      }
      v11 += v17;
      uint64_t v10 = v16;
    }
    while (1)
    {
      while (1)
      {
LABEL_10:
        if ((unint64_t)(v9 + 2) >= v14)
        {
          uint64_t v18 = a1[145];
          if ((v12 & 0xFFFFFFFD) == 1)
          {
            a1[145] = &v13[v18 - a1[144]];
            uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
            if (!result) {
              return result;
            }
            uint64_t v20 = v9 - v13;
            uint64_t v9 = (char *)a1[144];
            if (v20 < 1)
            {
              uint64_t v13 = (char *)a1[144];
            }
            else
            {
              unint64_t v21 = v20 + 1;
              do
              {
                char v22 = *v13++;
                *v9++ = v22;
                --v21;
              }
              while (v21 > 1);
              uint64_t v13 = (char *)a1[144];
            }
          }
          else
          {
            a1[145] = &v9[v18 - a1[144]];
            uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
            if (!result) {
              return result;
            }
            uint64_t v9 = (char *)a1[144];
          }
        }
        if (v12 != 3) {
          break;
        }
        int v12 = 2;
        if (v17 == 1 && *(v9 - 2) == 255)
        {
          unsigned int v23 = *v13;
          if (v23 <= 0x7D)
          {
            unsigned int v24 = v23 + 2;
            *uint64_t v13 = v24;
            int v12 = v24 != 127;
            *(v9 - 2) = *(v9 - 1);
          }
        }
      }
      if (v12 == 2)
      {
        if (v17 < 2)
        {
LABEL_37:
          *uint64_t v9 = 0;
          uint64_t v25 = v9 + 1;
          int v12 = 1;
          uint64_t v26 = 2;
          uint64_t v13 = v9;
          goto LABEL_41;
        }
        if ((unint64_t)v17 < 0x81)
        {
LABEL_38:
          *uint64_t v9 = 1 - v17;
          uint64_t v25 = v9 + 1;
          uint64_t v26 = 2;
          int v12 = 2;
          goto LABEL_41;
        }
        goto LABEL_32;
      }
      if (v12 != 1)
      {
        if (v17 < 2) {
          goto LABEL_37;
        }
        if ((unint64_t)v17 <= 0x80) {
          goto LABEL_38;
        }
LABEL_32:
        int v12 = 2;
        goto LABEL_36;
      }
      if (v17 < 2)
      {
        int v27 = (*v13)++ + 1;
        int v12 = v27 != 127;
        uint64_t v26 = 1;
        uint64_t v25 = v9;
        goto LABEL_41;
      }
      if ((unint64_t)v17 <= 0x80) {
        break;
      }
      int v12 = 3;
LABEL_36:
      *uint64_t v9 = -127;
      v9[1] = v15;
      v9 += 2;
      v17 -= 128;
    }
    *uint64_t v9 = 1 - v17;
    uint64_t v25 = v9 + 1;
    int v12 = 3;
    uint64_t v26 = 2;
LABEL_41:
    v9 += v26;
    char *v25 = v15;
  }
  while (v10 > 0);
  uint64_t v28 = a1[144];
LABEL_44:
  a1[145] += &v9[-v28];
  a1[144] = v9;
  return 1;
}

uint64_t PackBitsEncodeChunk(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 >= 1)
  {
    uint64_t v8 = a3;
    uint64_t v11 = **(void **)(a1 + 1096);
    do
    {
      if (v8 >= v11) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v8;
      }
      PackBitsEncode((void *)a1, a2, v12, 0, a5, a6, a7, a8);
      a2 += v12;
      BOOL v13 = v8 <= v12;
      v8 -= v12;
    }
    while (!v13);
  }
  return 1;
}

uint64_t LibJPEGReadPlugin::LibJPEGReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, char a6, int a7, uint64_t a8, int a9)
{
  JPEGReadPlugin::JPEGReadPlugin(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  *uint64_t v10 = &unk_1ED4E4170;
  bzero(v10 + 63, 0x23C8uLL);
  return a1;
}

void LibJPEGReadPlugin::LibJPEGReadPlugin(uint64_t a1, uint64_t a2)
{
}

void LibJPEGReadPlugin::~LibJPEGReadPlugin(LibJPEGReadPlugin *this)
{
  *(void *)this = &unk_1ED4E4170;
  _cg_jpeg_destroy_decompress((char *)this + 504);
  if (*((void *)this + 153)) {
    *((void *)this + 153) = 0;
  }

  JPEGReadPlugin::~JPEGReadPlugin(this);
}

{
  uint64_t vars8;

  LibJPEGReadPlugin::~LibJPEGReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t LibJPEGReadPlugin::loadDataFromXPCObject(LibJPEGReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_libjpeg", &length);
    if (length == 9160)
    {
      memcpy((char *)this + 504, data, 0x23C8uLL);
      uint64_t v6 = _cg_jpeg_std_error((uint64_t)this + 9272);
      uint64_t result = 0;
      *((void *)this + 68) = (char *)this + 1168;
      *((void *)this + 63) = v6;
      *((void *)this + 64) = 0;
      *((void *)this + 1159) = errorExit;
      *((void *)this + 1161) = outputMessage;
      *((void *)this + 147) = 0;
      *((void *)this + 149) = fill_input_buffer;
      *((void *)this + 148) = init_source;
      *((void *)this + 146) = (char *)this + 1264;
      *((void *)this + 151) = _cg_jpeg_resync_to_restart;
      *((void *)this + 150) = skip_input_data;
      *((void *)this + 152) = term_source;
      *((void *)this + 153) = *((void *)this + 3);
      *((void *)this + 155) = *((void *)this + 24);
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

void errorExit(uint64_t *a1)
{
  uint64_t v1 = *a1;
  (*(void (**)(uint64_t *))(*a1 + 16))(a1);
  siglongjmp((int *)(v1 + 176), 1);
}

const char *outputMessage(const char *result)
{
  uint64_t v1 = result;
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)result;
  if (*(_DWORD *)(*(void *)result + 40) == 120)
  {
    if (outputMessage(jpeg_common_struct *)::didWarn_JWRN_HIT_MARKER) {
      return result;
    }
    outputMessage(jpeg_common_struct *)::didWarn_JWRN_HIT_MARKER = 1;
  }
  uint64_t v4 = 0;
  memset(v3, 0, sizeof(v3));
  (*(void (**)(const char *, _OWORD *))(v2 + 24))(result, v3);
  uint64_t result = LogError(0, 0, "libJPEG", " %s\n", v3);
  if (*(_DWORD *)(*(void *)v1 + 40) == 116) {
    *(unsigned char *)(*(void *)v1 + 44) = 1;
  }
  return result;
}

uint64_t fill_input_buffer(uint64_t a1, uint64_t a2)
{
  v3.n128_f64[0] = MEMORY[0x1F4188790](a1, a2);
  uint64_t v4 = v2;
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = v2[5];
  if (!v5 || !*(void *)(v5 + 56))
  {
    uint64_t v6 = *v2;
    *(_DWORD *)(v6 + 40) = 43;
    (*(void (**)(uint64_t *, __n128))v6)(v2, v3);
    if (!*(void *)(v5 + 56))
    {
      uint64_t v7 = *v4;
      *(_DWORD *)(v7 + 40) = 43;
      (*(void (**)(uint64_t *))v7)(v4);
    }
  }
  unint64_t v8 = *(void *)(v5 + 88);
  if (!v8)
  {
LABEL_11:
    bzero(__dst, 0x1F42uLL);
    uint64_t v11 = *(void *)(v5 + 8);
    if (v11) {
      memcpy(__dst, *(const void **)v5, *(void *)(v5 + 8));
    }
    uint64_t v12 = (unsigned char *)(v5 + 96);
    size_t Bytes = IIOImageReadSession::getBytes(*(IIOImageReadSession **)(v5 + 56), (unsigned char *)(v5 + 96), 0xFA0uLL);
    int v14 = *(unsigned __int8 *)(v5 + 96);
    if (!*(unsigned char *)(v5 + 96) || (v14 != 238 ? (BOOL v15 = v14 == 2) : (BOOL v15 = 1), v15))
    {
      if (*(unsigned __int8 *)(v5 + 97) == 216
        && *(unsigned __int8 *)(v5 + 98) == 255
        && *(unsigned __int8 *)(v5 + 99) == 219
        && IIOImageReadSession::seek(*(IIOImageReadSession **)(v5 + 56), 0, 1) == *(void *)(v5 + 72) + Bytes)
      {
        *uint64_t v12 = -1;
      }
    }
    if (Bytes > 0xF9F)
    {
      if (Bytes == 4000)
      {
        uint64_t result = 1;
        size_t v16 = 4000;
        goto LABEL_32;
      }
      if ((Bytes & 0x8000000000000000) != 0) {
        return 0;
      }
    }
    else if (*(unsigned char *)(v5 + 64) {
           || (IIOImageReadSession::isFinal(*(IIOImageReadSession **)(v5 + 56)) & 1) != 0)
    }
    {
      *(_WORD *)(v5 + Bytes + 96) = -9729;
      size_t v16 = Bytes + 2;
      uint64_t result = 1;
LABEL_32:
      *(void *)uint64_t v5 = v12;
      *(void *)(v5 + 8) = v16;
      return result;
    }
    memcpy(&__dst[v11], (const void *)(v5 + 96), Bytes);
    size_t v16 = Bytes + v11;
    memcpy((void *)(v5 + 96), __dst, v16);
    uint64_t result = 0;
    goto LABEL_32;
  }
  while (1)
  {
    uint64_t v9 = v8 >= 0xFA0 ? 4000 : v8;
    uint64_t result = (uint64_t)IIOImageReadSession::skipBytes(*(IIOImageReadSession **)(v5 + 56), v9);
    if (!result) {
      return result;
    }
    unint64_t v8 = *(void *)(v5 + 88) - result;
    *(void *)(v5 + 88) = v8;
    if (!v8) {
      goto LABEL_11;
    }
  }
}

const char *init_source(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 40);
  if (v1 && (uint64_t v2 = (IIOImageReadSession *)v1[7]) != 0)
  {
    uint64_t result = (const char *)IIOImageReadSession::seek(v2, v1[9], 0);
    v1[11] = 0;
    *uint64_t v1 = v1 + 12;
    v1[1] = 0;
  }
  else
  {
    return LogError("init_source", 259, "*** ImageIO - libJPEG nil-'source'cinfo->src'\n");
  }
  return result;
}

uint64_t skip_input_data(uint64_t result, unint64_t a2)
{
  uint64_t v2 = *(void **)(result + 40);
  unint64_t v3 = v2[1];
  unint64_t v4 = v3 - a2;
  if (v3 <= a2)
  {
    unint64_t v4 = 0;
    unint64_t v5 = a2 - v3;
  }
  else
  {
    unint64_t v5 = 0;
    *v2 += a2;
  }
  v2[1] = v4;
  v2[11] += v5;
  return result;
}

uint64_t LibJPEGReadPlugin::saveDataToXPCObject(LibJPEGReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_libjpeg", (char *)this + 504, 0x23C8uLL);
  }
  return v4;
}

CGMutableImageMetadataRef LibJPEGReadPlugin::readAPP13(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t ***)(a2 + 408);
  if (!v2) {
    return 0;
  }
  while (1)
  {
    uint64_t v4 = *((unsigned int *)v2 + 4);
    if (*((unsigned __int8 *)v2 + 8) == 237 && v4 >= 0xF)
    {
      uint64_t v6 = v2[3];
      if (*v6 == 0x6F68736F746F6850 && *((_WORD *)v6 + 4) == 8304) {
        break;
      }
    }
    uint64_t v2 = (uint64_t **)*v2;
    if (!v2) {
      return 0;
    }
  }
  CGMutableImageMetadataRef Mutable = CGImageMetadataCreateMutable();
  ReadPhotoshopImageResource((uint64_t)Mutable, (uint64_t)v6 + 14, v4 - 14);
  if (Mutable)
  {
    TagWithPath = CGImageMetadataGetTagWithPath(Mutable, 0, @"iio:PSIRClippingPath");
    if (TagWithPath)
    {
      uint64_t v11 = (uint64_t)TagWithPath;
      CFStringRef Value = (const CGPath *)CGImageMetadataTagGetValue((uint64_t)TagWithPath);
      if (Value)
      {
        BOOL v13 = *(IIOImagePlus **)(a1 + 16);
        int v14 = CGPathRetain(Value);
        IIOImagePlus::setClipPath(v13, v14);
      }
      CGImageMetadataRemoveTag((uint64_t)Mutable, v11);
    }
  }
  return Mutable;
}

const __CFDictionary *LibJPEGReadPlugin::readExifData(int a1, uint64_t a2, IIODictionary *a3)
{
  uint64_t v4 = *(uint64_t **)(a2 + 408);
  if (v4)
  {
    CFDictionaryRef MetadataFromDatabuffer = 0;
    do
    {
      if (*((unsigned __int8 *)v4 + 8) == 225 && *((_DWORD *)v4 + 4) >= 0xBu)
      {
        uint64_t v7 = (unsigned char *)v4[3];
        if (*v7 == 69 && v7[1] == 120 && v7[2] == 105 && v7[3] == 102 && !v7[4] && !v7[5])
        {
          IIOMetadataFlagsFromImageSourceOptions(a3);
          CFDictionaryRef MetadataFromDatabuffer = (const __CFDictionary *)CreateMetadataFromDatabuffer((const char *)(v4[3] + 6), (*((_DWORD *)v4 + 4) - 6));
        }
      }
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  else
  {
    CFDictionaryRef MetadataFromDatabuffer = 0;
  }
  if (*(_DWORD *)(a2 + 376))
  {
    CFDictionaryRef TopLevelTag = CGImageMetadataGetTopLevelTag(MetadataFromDatabuffer, @"http://ns.apple.com/ImageIO/1.0/", @"JPEGInterchangeFormat");
    if (TopLevelTag)
    {
      uint64_t v9 = (uint64_t)TopLevelTag;
      CFStringRef Value = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)TopLevelTag);
      IntCFStringRef Value = CFStringGetIntValue(Value);
      uint64_t v12 = *(IIOImageReadSession **)(*(void *)(a2 + 40) + 56);
      unsigned __int16 v21 = 0;
      IIOImageReadSession::getBytesAtOffset(v12, &v21, IntValue, 2uLL);
      if (v21 != 55551 && v21 != 65496)
      {
        uint64_t v13 = (IntValue + 18);
        IIOImageReadSession::getBytesAtOffset(v12, &v21, (int)v13, 2uLL);
        if (v21 == 65496 || v21 == 55551)
        {
          CFStringRef v14 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%d", v13);
          if (v14)
          {
            CFStringRef v15 = v14;
            CGImageMetadataTagSetValue(v9, v14);
            CFRelease(v15);
          }
        }
        else
        {
          CFDictionaryRef v16 = CGImageMetadataGetTopLevelTag(MetadataFromDatabuffer, @"http://ns.apple.com/ImageIO/1.0/", @"JPEGInterchangeFormat");
          CGImageMetadataRemoveTag((uint64_t)MetadataFromDatabuffer, (uint64_t)v16);
          CFDictionaryRef v17 = CGImageMetadataGetTopLevelTag(MetadataFromDatabuffer, @"http://ns.apple.com/ImageIO/1.0/", @"JPEGInterchangeFormatLength");
          CGImageMetadataRemoveTag((uint64_t)MetadataFromDatabuffer, (uint64_t)v17);
          CFDictionaryRef v18 = CGImageMetadataGetTopLevelTag(MetadataFromDatabuffer, @"http://ns.apple.com/ImageIO/1.0/", @"JPEGInterchangeFormatWidth");
          CGImageMetadataRemoveTag((uint64_t)MetadataFromDatabuffer, (uint64_t)v18);
          CFDictionaryRef v19 = CGImageMetadataGetTopLevelTag(MetadataFromDatabuffer, @"http://ns.apple.com/ImageIO/1.0/", @"JPEGInterchangeFormatHeight");
          CGImageMetadataRemoveTag((uint64_t)MetadataFromDatabuffer, (uint64_t)v19);
        }
      }
    }
  }
  return MetadataFromDatabuffer;
}

uint64_t LibJPEGReadPlugin::startDecompressing(uint64_t a1, int a2)
{
  uint64_t v4 = a1 + 504;
  _cg_jpeg_CreateDecompress((char *)(a1 + 504), 90, 664);
  *(void *)(a1 + 544) = a1 + 1168;
  uint64_t result = _cg_jpeg_read_header(v4, 1);
  int v6 = *(unsigned __int16 *)(a1 + 316);
  if (*(_WORD *)(a1 + 316))
  {
    *(_DWORD *)(a1 + 600) = 1;
    int v7 = 8;
    *(_DWORD *)(a1 + 576) = 8;
    unsigned int v8 = v6 - 2;
    if (v8 <= 6) {
      int v7 = dword_188991100[(__int16)v8];
    }
    *(_DWORD *)(a1 + 572) = v7;
  }
  *(_DWORD *)(a1 + 568) = a2;
  if (*(int *)(a1 + 540) >= 202)
  {
    return _cg_jpeg_start_decompress(v4);
  }
  return result;
}

uint64_t LibJPEGReadPlugin::readXMPData(uint64_t a1, uint64_t a2, CFDataRef theData)
{
  if (!theData)
  {
    int v7 = *(uint64_t **)(a2 + 408);
    long long v32 = 0u;
    long long v33 = 0u;
    if (!v7) {
      return 0;
    }
    char v8 = 0;
    uint64_t v9 = 0;
    size_t v10 = 0;
    uint64_t v11 = 0;
    unsigned int v12 = 0;
    uint64_t v13 = 0;
    while (1)
    {
      if (*((unsigned __int8 *)v7 + 8) == 225)
      {
        unsigned int v14 = *((_DWORD *)v7 + 4);
        if (v14 >= 0x1E)
        {
          uint64_t v15 = v7[3];
          if (*(void *)v15 == 0x6E2F2F3A70747468
            && *(void *)(v15 + 8) == 0x2E65626F64612E73
            && *(void *)(v15 + 16) == 0x2F7061782F6D6F63)
          {
            int v20 = *(unsigned __int8 *)(v15 + 29);
            CFDictionaryRef v19 = (const char *)(v15 + 29);
            unsigned int v21 = v14 - 29;
            if (v20 == 60)
            {
              uint64_t v13 = v19;
              unsigned int v12 = v21;
            }
            goto LABEL_36;
          }
          size_t v18 = v14 - 75;
          if (v14 >= 0x4B && !strcmp((const char *)v7[3], "http://ns.adobe.com/xmp/extension/")) {
            break;
          }
        }
      }
LABEL_36:
      int v7 = (uint64_t *)*v7;
      if (!v7)
      {
        if (v11 && v10 && v9 == v10 && v13 && v12)
        {
          MetadataFromExtendedXMPuint64_t Data = CreateMetadataFromExtendedXMPData(v13, v12, v11);
          goto LABEL_58;
        }
        if (v13 && v12)
        {
          uint64_t result = CreateMetadataFromXMPBuffer(v13, v12);
          MetadataFromExtendedXMPuint64_t Data = result;
          if (!v11) {
            return result;
          }
        }
        else
        {
          MetadataFromExtendedXMPuint64_t Data = 0;
          uint64_t result = 0;
          if (!v11) {
            return result;
          }
        }
LABEL_58:
        free(v11);
        return MetadataFromExtendedXMPData;
      }
    }
    uint64_t v28 = v9;
    char v22 = v11;
    long long v30 = *(_OWORD *)(v15 + 35);
    long long v31 = *(_OWORD *)(v15 + 51);
    size_t v23 = bswap32(*(_DWORD *)(v15 + 67));
    unsigned int v24 = *(_DWORD *)(v15 + 71);
    if (v8)
    {
      unint64_t v25 = v10;
    }
    else
    {
      long long v32 = *(_OWORD *)(v15 + 35);
      long long v33 = *(_OWORD *)(v15 + 51);
      if ((unint64_t)IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24)) <= v23)
      {
        _cg_jpeg_mem_term("readXMPData", 1316, "*** ERROR bad extendedLength: %d\n", v23);
        char v8 = 0;
        goto LABEL_41;
      }
      unint64_t v25 = v23;
      size_t v10 = v23;
      char v22 = (char *)malloc_type_calloc(1uLL, v23, 0x9658313AuLL);
      if (!v22)
      {
        uint64_t v11 = 0;
        char v8 = 0;
        goto LABEL_45;
      }
    }
    if ((unint64_t)IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24)) <= v25)
    {
      _cg_jpeg_mem_term("readXMPData", 1322, "*** ERROR bad extendedLength: %d\n");
    }
    else
    {
      unsigned int v26 = bswap32(v24);
      if (v26 < v10)
      {
        uint64_t v11 = v22;
        if (!__CFADD__(v18, v26))
        {
          char v8 = 1;
          uint64_t v9 = v28;
          if ((unint64_t)v32 ^ (unint64_t)v30 | *((void *)&v32 + 1) ^ *((void *)&v30 + 1) | (unint64_t)v33 ^ (unint64_t)v31 | *((void *)&v33 + 1) ^ *((void *)&v31 + 1))
          {
            size_t v23 = v10;
          }
          else if (v23 == v10 && v18 + v26 <= v10)
          {
            memcpy(&v11[v26], (const void *)(v7[3] + 75), v18);
            uint64_t v9 = v28 + v18;
          }
          else
          {
            size_t v23 = v10;
          }
          goto LABEL_35;
        }
        char v8 = 1;
        size_t v23 = v10;
LABEL_45:
        uint64_t v9 = v28;
LABEL_35:
        size_t v10 = v23;
        goto LABEL_36;
      }
      _cg_jpeg_mem_term("readXMPData", 1323, "*** ERROR bad chunkOffset: %d\n");
    }
    char v8 = 1;
    size_t v23 = v10;
LABEL_41:
    uint64_t v11 = v22;
    goto LABEL_45;
  }
  BytePtr = (const char *)CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);

  return CreateMetadataFromXMPSidecarData(BytePtr, Length);
}

void LibJPEGReadPlugin::readQualityPropertiesFromJPEG(uint64_t a1, uint64_t a2, IIODictionary *a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 4, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      int v7 = Mutable;
      CFIndex v8 = 0;
      uint64_t v9 = (const void *)*MEMORY[0x1E4F1D260];
      do
        CFArraySetValueAtIndex(v7, v8++, v9);
      while (v8 != 4);
      long long v23 = 0u;
      long long v24 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      *(_OWORD *)UInt8 bytes = 0u;
      long long v18 = 0u;
      if (*(int *)(a2 + 56) >= 1)
      {
        uint64_t v10 = 0;
        do
        {
          CFIndex v11 = *(unsigned int *)(*(void *)(a2 + 304) + 96 * v10 + 16);
          if (v11 <= 3)
          {
            uint64_t v12 = *(void *)(a2 + 8 * v11 + 200);
            if (v12)
            {
              if (CFArrayGetValueAtIndex(v7, *(unsigned int *)(*(void *)(a2 + 304) + 96 * v10 + 16)) == v9)
              {
                for (uint64_t i = 0; i != 128; i += 2)
                  *(_WORD *)&bytes[i] = *(_WORD *)(v12 + i);
                CFDataRef v14 = CFDataCreate(v5, bytes, 128);
                if (v14)
                {
                  CFArraySetValueAtIndex(v7, v11, v14);
                  CFRelease(v14);
                }
              }
            }
          }
          ++v10;
        }
        while (v10 < *(int *)(a2 + 56));
      }
      IIODictionary::setObjectForKeyGroup(a3, v7, @"Quantization", @"{JPEG}");
      CFRelease(v7);
    }
    if (*(_DWORD *)(a2 + 56) == 3)
    {
      IIONumber::IIONumber((IIONumber *)v16, *(_DWORD *)(*(void *)(a2 + 304) + 8));
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v16, @"ChromaSubsamplingX", @"{JPEG}");
      IIONumber::~IIONumber((IIONumber *)v16);
      IIONumber::IIONumber((IIONumber *)v15, *(_DWORD *)(*(void *)(a2 + 304) + 12));
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v15, @"ChromaSubsamplingY", @"{JPEG}");
      IIONumber::~IIONumber((IIONumber *)v15);
    }
  }
}

void sub_18874B600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t LibJPEGReadPlugin::validateJPEG(IIOImageReadSession **this)
{
  uint64_t v4 = 0;
  memset(v3, 0, sizeof(v3));
  IIOScanner::IIOScanner((IIOScanner *)v3, this[3]);
  GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v3, 0);
  IIOScanner::seek((IIOScanner *)v3, 2uLL);
  while (IIOScanner::getVal16((IIOScanner *)v3) != 65498)
  {
    unsigned int Val16 = IIOScanner::getVal16((IIOScanner *)v3);
    IIOScanner::skip((uint64_t)v3, Val16 - 2);
  }
  IIOScanner::~IIOScanner((IIOScanner *)v3);
  return 0;
}

void sub_18874B6C0(void *a1)
{
}

void sub_18874B6D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t LibJPEGReadPlugin::initialize(LibJPEGReadPlugin *this, IIODictionary *a2)
{
  uint64_t v246 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *((void *)this + 8);
  uint64_t v232 = (IIODictionary *)*((void *)this + 7);
  uint64_t v4 = (IIODictionary *)*((void *)this + 6);
  if (IIODictionary::getBoolForKey(v4, @"kCGImageSourceUseCoreImage"))
  {
    if (GetCIProc(void)::onceToken != -1) {
      dispatch_once(&GetCIProc(void)::onceToken, &__block_literal_global_16);
    }
    BOOL v5 = g_ciGetCGImageRefFromYCbCrData != 0;
  }
  else
  {
    BOOL v5 = 0;
  }
  BOOL v6 = v5;
  int v231 = IIOSkipMetadata(v4);
  char v230 = IIOSkipXMP_and_IPTC(v4);
  if (IIODictionary::containsKey(v4, @"kCGImageSourceXMPSidecar")) {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(v4, @"kCGImageSourceXMPSidecar");
  }
  else {
    CFDictionaryRef ObjectForKey = 0;
  }
  CFDictionaryRef v8 = ObjectForKey;
  int v229 = *((_DWORD *)this + 113);
  if (IIODictionary::containsKey(v4, @"kCGImageSourceSubsampleFactor")) {
    unint64_t Uint32ForKey = IIODictionary::getUint32ForKey(v4, @"kCGImageSourceSubsampleFactor");
  }
  else {
    unint64_t Uint32ForKey = 0;
  }
  unsigned int v10 = IIODictionary::containsKey(v4, @"kCGImageSourceColorTransform");
  if (v10) {
    uint64_t v11 = IIODictionary::getUint32ForKey(v4, @"kCGImageSourceColorTransform");
  }
  else {
    uint64_t v11 = -1;
  }
  uint64_t v12 = v11;
  int v13 = *((unsigned __int8 *)this + 216);
  if (v13 == 1) {
    goto LABEL_26;
  }
  uint64_t v233 = v3;
  uint64_t v235 = v11;
  unsigned int v237 = v10;
  BOOL v239 = v6;
  CFDataRef v14 = (IIOImageReadSession *)*((void *)this + 3);
  unint64_t v15 = *((void *)this + 24);
  unint64_t v16 = *((void *)this + 58);
  unint64_t Size = IIOImageReadSession::getSize(v14);
  bzero(&v242[1], 0x410uLL);
  v242[0] = v14;
  if (!v15 && IIOImageReadSession::isFinal(v14))
  {
    LOWORD(v241[0]) = 0;
    long long v18 = IIOImageReadSession::getSize(v14);
    IIOImageReadSession::getBytesAtOffset(v14, v241, (unint64_t)v18 - 2, 2uLL);
    int v19 = LOWORD(v241[0]);
    LOWORD(v241[0]) = __rev16(LOWORD(v241[0]));
    if (v19 != 55807)
    {
      long long v20 = IIOImageReadSession::getSize(v14);
      IIOImageReadSession::getBytesAtOffset(v14, v241, (unint64_t)v20 - 3, 2uLL);
      if (LOWORD(v241[0]) != 55807) {
        return 4294967246;
      }
    }
LABEL_20:
    BOOL v6 = v239;
    unsigned int v10 = v237;
    uint64_t v12 = v235;
    uint64_t v3 = v233;
    goto LABEL_26;
  }
  if (!v16 || Size == (IIOImageRead *)-1)
  {
    if (IIOImageReadSession::seek(v14, v15, 0) != v15) {
      return 4294967246;
    }
    unint64_t Bytes = IIOImageReadSession::getBytes(v14, (unsigned char *)v243 + 8, 0x400uLL);
    if (!Bytes) {
      return 4294967246;
    }
    int v31 = BYTE8(v243[0]);
    uint64_t v32 = 1;
    unint64_t v33 = Bytes - 1;
    v242[1] = (IIOImageReadSession *)1;
    *(void *)&v243[0] = Bytes - 1;
    if (Bytes == 1)
    {
      unint64_t v34 = IIOImageReadSession::getBytes(v242[0], (unsigned char *)v243 + 8, 0x400uLL);
      if (!v34) {
        return 4294967246;
      }
      unint64_t v33 = v34;
      uint64_t v32 = 0;
    }
    unint64_t v35 = v33;
    int v36 = *(unsigned __int8 *)(((unint64_t)v242 | v32) + 0x18);
    v242[1] = (IIOImageReadSession *)(v32 + 1);
    *(void *)&v243[0] = v33 - 1;
    BOOL v37 = (v31 + 1) <= 1u || v31 == 2;
    if (!v37 || v36 != 216) {
      return 4294967246;
    }
    unint64_t v38 = v33 - 1;
    uint64_t v39 = v32 + 1;
    if (v35 == 1)
    {
      unint64_t v40 = IIOImageReadSession::getBytes(v242[0], (unsigned char *)v243 + 8, 0x400uLL);
      v242[1] = 0;
      *(void *)&v243[0] = v40;
      if (!v40) {
        return 4294967246;
      }
      uint64_t v39 = 0;
      unint64_t v38 = v40;
    }
    int v41 = *(unsigned __int8 *)(((unint64_t)v242 | v39) + 0x18);
    v242[1] = (IIOImageReadSession *)(v39 + 1);
    *(void *)&v243[0] = v38 - 1;
    if (v38 == 1)
    {
      unint64_t v58 = IIOImageReadSession::getBytes(v242[0], (unsigned char *)v243 + 8, 0x400uLL);
      v242[1] = 0;
      *(void *)&v243[0] = v58;
      if (!v58) {
        return 4294967246;
      }
      uint64_t v43 = 0;
      unint64_t v42 = v58;
    }
    else
    {
      unint64_t v42 = v38 - 1;
      uint64_t v43 = v39 + 1;
    }
    unint64_t v59 = v42;
    int v60 = *(unsigned __int8 *)(((unint64_t)v242 | v43) + 0x18);
    long long v61 = (IIOImageReadSession *)(v43 + 1);
    unint64_t v62 = v59 - 1;
    v242[1] = v61;
    *(void *)&v243[0] = v62;
    if (v41 == 255 && v60)
    {
      BOOL v63 = v61;
      unint64_t v64 = v62;
      int v65 = v60;
      while (1)
      {
        if ((v65 - 208) < 9 || v65 == 218)
        {
          do
          {
            unint64_t v66 = v64;
            unint64_t v67 = v64;
            uint64_t v68 = v63;
            if (!v66)
            {
              unint64_t v69 = IIOImageReadSession::getBytes(v242[0], (unsigned char *)v243 + 8, 0x400uLL);
              v242[1] = 0;
              *(void *)&v243[0] = v69;
              if (!v69) {
                return 4294967246;
              }
              uint64_t v68 = 0;
              unint64_t v67 = v69;
            }
            int v70 = *((unsigned __int8 *)v68 + (void)v243 + 8);
            v242[1] = (IIOImageReadSession *)((char *)v68 + 1);
            *(void *)&v243[0] = v67 - 1;
            if (v67 == 1)
            {
              unint64_t v73 = IIOImageReadSession::getBytes(v242[0], (unsigned char *)v243 + 8, 0x400uLL);
              v242[1] = 0;
              *(void *)&v243[0] = v73;
              if (!v73) {
                return 4294967246;
              }
              uint64_t v72 = 0;
              unint64_t v71 = v73;
            }
            else
            {
              unint64_t v71 = v67 - 1;
              uint64_t v72 = (uint64_t)v68 + 1;
            }
            unint64_t v74 = v71;
            int v75 = *((unsigned __int8 *)v243 + v72 + 8);
            BOOL v63 = (IIOImageReadSession *)(v72 + 1);
            unint64_t v76 = v74 - 1;
            v242[1] = (IIOImageReadSession *)(v72 + 1);
            *(void *)&v243[0] = v74 - 1;
            if (v75 == 255)
            {
              unint64_t v77 = v74 - 1;
              if (v74 == 1)
              {
                unint64_t v78 = IIOImageReadSession::getBytes(v242[0], (unsigned char *)v243 + 8, 0x400uLL);
                v242[1] = 0;
                *(void *)&v243[0] = v78;
                if (!v78) {
                  return 4294967246;
                }
                unint64_t v77 = v78;
                BOOL v63 = 0;
              }
              int v79 = *((unsigned __int8 *)v63 + (void)v243 + 8);
              BOOL v63 = (IIOImageReadSession *)((char *)v63 + 1);
              v242[1] = v63;
              *(void *)&v243[0] = v77 - 1;
              unint64_t v76 = v77 - 1;
              int v75 = v79;
              int v80 = 255;
            }
            else
            {
              int v80 = v70;
            }
            BOOL v81 = v80 != 255 || v75 == 0;
            unint64_t v64 = v76;
          }
          while (v81);
          int v82 = 0;
          int v65 = v75;
        }
        else
        {
          if (v65 == 217) {
            goto LABEL_20;
          }
          if (!v64)
          {
            unint64_t v84 = IIOImageReadSession::getBytes(v242[0], (unsigned char *)v243 + 8, 0x400uLL);
            v242[1] = 0;
            *(void *)&v243[0] = v84;
            if (!v84) {
              return 4294967246;
            }
            unint64_t v64 = v84;
            BOOL v63 = 0;
          }
          int v85 = *((unsigned __int8 *)v63 + (void)v243 + 8);
          unint64_t v86 = v64 - 1;
          v242[1] = (IIOImageReadSession *)((char *)v63 + 1);
          *(void *)&v243[0] = v86;
          if (v86)
          {
            unint64_t v87 = v86;
            signed int v88 = (char *)v63 + 1;
          }
          else
          {
            unint64_t v89 = IIOImageReadSession::getBytes(v242[0], (unsigned char *)v243 + 8, 0x400uLL);
            v242[1] = 0;
            *(void *)&v243[0] = v89;
            if (!v89) {
              return 4294967246;
            }
            signed int v88 = 0;
            unint64_t v87 = v89;
          }
          unint64_t v90 = v87 - 1;
          unint64_t v91 = (int)((bswap32(v85 | (v88[(void)v243 + 8] << 8)) >> 16) - 2);
          if (v90 >= v91)
          {
            unint64_t v92 = v90 - v91;
            v242[1] = (IIOImageReadSession *)&v88[v91 + 1];
            *(void *)&v243[0] = v92;
          }
          else
          {
            v242[1] = 0;
            *(void *)&v243[0] = 0;
            if (IIOImageReadSession::skipBytes(v242[0], (int)v91 - (int)v90) != (IIOImageRead *)((int)v91 - (int)v90)) {
              return 4294967246;
            }
            unint64_t v92 = *(void *)&v243[0];
          }
          if (v92)
          {
            int v93 = v242[1];
          }
          else
          {
            unint64_t v94 = IIOImageReadSession::getBytes(v242[0], (unsigned char *)v243 + 8, 0x400uLL);
            v242[1] = 0;
            *(void *)&v243[0] = v94;
            if (!v94) {
              return 4294967246;
            }
            int v93 = 0;
            unint64_t v92 = v94;
          }
          int v95 = *((unsigned __int8 *)v93 + (void)v243 + 8);
          v242[1] = (IIOImageReadSession *)((char *)v93 + 1);
          *(void *)&v243[0] = v92 - 1;
          if (v92 == 1)
          {
            unint64_t v98 = IIOImageReadSession::getBytes(v242[0], (unsigned char *)v243 + 8, 0x400uLL);
            v242[1] = 0;
            *(void *)&v243[0] = v98;
            if (!v98) {
              return 4294967246;
            }
            int v97 = 0;
            unint64_t v96 = v98;
          }
          else
          {
            unint64_t v96 = v92 - 1;
            int v97 = (char *)v93 + 1;
          }
          int v99 = v97[(void)v243 + 8];
          BOOL v63 = (IIOImageReadSession *)(v97 + 1);
          unint64_t v100 = v96 - 1;
          v242[1] = (IIOImageReadSession *)(v97 + 1);
          *(void *)&v243[0] = v100;
          if (v95 == 255)
          {
            int v65 = v99;
            int v82 = 0;
          }
          else
          {
            int v82 = -1;
          }
          unint64_t v76 = v100;
        }
        int v83 = v82;
        unint64_t v64 = v76;
        if (v83) {
          return 4294967246;
        }
      }
    }
    return 4294967246;
  }
  uint64_t result = 4294967246;
  unsigned int v10 = v237;
  if ((unint64_t)Size > v15)
  {
    BOOL v22 = (unint64_t)Size - v15 >= v16;
    BOOL v6 = v239;
    uint64_t v12 = v235;
    uint64_t v3 = v233;
    if (v22)
    {
LABEL_26:
      if (IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), *((void *)this + 24), 0) != *((void *)this + 24)) {
        return 4294967246;
      }
      if ((gIIODebugFlags & 0x80000000) == 0 && Uint32ForKey <= 1) {
        *((unsigned char *)this + 348) = 1;
      }
      if (sigsetjmp((int *)this + 2362, 0))
      {
        _cg_jpeg_mem_term("initialize", 1548, "sigsetjmp");
        _cg_jpeg_destroy_decompress((char *)this + 504);
        if (*((void *)this + 153)) {
          *((void *)this + 153) = 0;
        }
        return 4294967246;
      }
      CFDataRef theData = v8;
      uint64_t v236 = v12;
      BOOL v240 = v6;
      _cg_jpeg_CreateDecompress((char *)this + 504, 90, 664);
      *((void *)this + 63) = _cg_jpeg_std_error((uint64_t)this + 9272);
      *((void *)this + 1159) = errorExit;
      *((void *)this + 1161) = outputMessage;
      *((void *)this + 148) = init_source;
      *((void *)this + 149) = fill_input_buffer;
      *((void *)this + 150) = skip_input_data;
      *((void *)this + 151) = _cg_jpeg_resync_to_restart;
      *((void *)this + 152) = term_source;
      *((void *)this + 146) = (char *)this + 1264;
      *((void *)this + 147) = 0;
      long long v23 = (IIOImageReadSession *)*((void *)this + 3);
      *((void *)this + 153) = v23;
      *((unsigned char *)this + 1232) = v13 != 1;
      *((void *)this + 155) = *((void *)this + 24);
      long long v24 = (IIOImageRead *)*((void *)this + 58);
      if (!v24) {
        long long v24 = IIOImageReadSession::getSize(v23);
      }
      *((void *)this + 156) = v24;
      *((void *)this + 68) = (char *)this + 1168;
      if (v229 == 1297108768 || v229 == 1346981191 || !*((void *)this + 24))
      {
        _cg_jpeg_save_markers((void *)this + 63, 226, 0xFFFFu);
        _cg_jpeg_save_markers((void *)this + 63, 225, 0xFFFFu);
        _cg_jpeg_save_markers((void *)this + 63, 225, 0xFFFFu);
        _cg_jpeg_save_markers((void *)this + 63, 237, 0xFFFFu);
        _cg_jpeg_save_markers((void *)this + 63, 254, 0xFFFFu);
      }
      int v25 = v231;
      char v26 = v230;
      int header = _cg_jpeg_read_header((uint64_t)this + 504, 1);
      if (header == 1)
      {
        unsigned int v44 = v10;
        uint64_t v45 = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
        unint64_t v46 = IIO_Reader::minimumFileSize(*((IIO_Reader **)this + 3));
        uint64_t result = LibJPEGReadPlugin::validateJPEG((IIOImageReadSession **)this);
        if (result) {
          return result;
        }
        IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), v46, 0);
        if (v46 > (unint64_t)v45)
        {
          int v47 = Uint32ForKey;
LABEL_258:
          uint64_t result = *((void *)this + 2);
          if (result)
          {
            IIOImagePlus::setJpegProvider(result, v47);
            return 0;
          }
          return result;
        }
        CFDictionaryRef v228 = (const __CFDictionary *)v3;
        if (*(unsigned char *)(*((void *)this + 63) + 44)) {
          uint64_t v49 = 0;
        }
        else {
          uint64_t v49 = Uint32ForKey;
        }
        BOOL BoolForKey = IIODictionary::getBoolForKey(v4, @"kCGImageSourceAddJPEGQualityInformation");
        if (BoolForKey) {
          LibJPEGReadPlugin::readQualityPropertiesFromJPEG(BoolForKey, (uint64_t)this + 504, v232);
        }
        int v50 = 1;
        uint64_t v48 = 0;
        unsigned int v10 = v44;
        int v25 = v231;
        char v26 = v230;
      }
      else
      {
        if (!header)
        {
          if (!*((void *)this + 24))
          {
            readJFIFData((uint64_t)this + 504, v232);
            if (v231)
            {
              CGColorSpaceRef v29 = (const void *)copyRenderingInfo((uint64_t)this + 504);
              CGImageMetadataMerge(v3, (uint64_t)v29, 0);
              if (!v29) {
                return 4294967246;
              }
            }
            else
            {
              Exifuint64_t Data = LibJPEGReadPlugin::readExifData(v28, (uint64_t)this + 504, v4);
              CGImageMetadataMerge(v3, (uint64_t)ExifData, v4);
              if (v230)
              {
                CGMutableImageMetadataRef v105 = 0;
                CGColorSpaceRef v29 = 0;
              }
              else
              {
                CGMutableImageMetadataRef APP13 = LibJPEGReadPlugin::readAPP13((uint64_t)this, (uint64_t)this + 504);
                XMPuint64_t Data = LibJPEGReadPlugin::readXMPData((uint64_t)this, (uint64_t)this + 504, theData);
                CGImageMetadataMerge(v3, (uint64_t)APP13, v4);
                CGImageMetadataMerge(v3, XMPData, v4);
                CGMutableImageMetadataRef v105 = APP13;
                CGColorSpaceRef v29 = (const void *)XMPData;
              }
              if (ExifData) {
                CFRelease(ExifData);
              }
              if (v105) {
                CFRelease(v105);
              }
              if (!v29) {
                return 4294967246;
              }
            }
            CFRelease(v29);
          }
          return 4294967246;
        }
        CFDictionaryRef v228 = (const __CFDictionary *)v3;
        uint64_t v48 = 4294967246;
        uint64_t v49 = Uint32ForKey;
        int v50 = 0;
      }
      int v52 = *((_DWORD *)this + 141) - 1;
      if (v52 >= 5)
      {
        LogError("initialize", 1704, "Unsupported jpeg colorspace %d\n", *((_DWORD *)this + 141));
        goto LABEL_76;
      }
      int v53 = dword_1889910EC[v52];
      *((_DWORD *)this + 2414) = v53;
      *((_DWORD *)this + 142) = v53;
      uint64_t v54 = *((unsigned int *)this + 138);
      uint64_t v55 = *((unsigned int *)this + 139);
      *((void *)this + 60) = v54;
      *((void *)this + 61) = v55;
      int v56 = *((unsigned __int16 *)this + 280);
      if (v49 >= 2)
      {
        if ((unint64_t)v49 < 8)
        {
          if ((unint64_t)v49 < 4) {
            uint64_t v57 = 2;
          }
          else {
            uint64_t v57 = 4;
          }
        }
        else
        {
          uint64_t v57 = 8;
        }
        *((_WORD *)this + 158) = v57;
        uint64_t v49 = v57;
        goto LABEL_162;
      }
      if (*((unsigned __int8 *)this + 216) >= 2u)
      {
        unsigned int v101 = *((_DWORD *)this + 53);
        if (v101)
        {
          if (v54 <= v55) {
            unsigned int v102 = v55;
          }
          else {
            unsigned int v102 = v54;
          }
          if (v101 >= v102) {
            unsigned int v101 = v102;
          }
          *((_DWORD *)this + 53) = v101;
          if (v101 <= (v54 + 7) >> 3 || v101 <= (v55 + 7) >> 3)
          {
            __int16 v103 = 8;
          }
          else if (v101 <= (v54 + 3) >> 2 || v101 <= (v55 + 3) >> 2)
          {
            __int16 v103 = 4;
          }
          else
          {
            if (v101 > (v54 + 1) >> 1 && v101 > (v55 + 1) >> 1) {
              goto LABEL_162;
            }
            __int16 v103 = 2;
          }
        }
        else
        {
          __int16 v103 = 1;
        }
        *((_WORD *)this + 158) = v103;
      }
LABEL_162:
      unint64_t v227 = v49;
      unsigned int v108 = *((unsigned __int16 *)this + 158);
      unsigned int v109 = v108 - 2;
      if (v108 >= 2)
      {
        *((_DWORD *)this + 150) = 1;
        int v110 = 8;
        *((_DWORD *)this + 144) = 8;
        if (v109 <= 6) {
          int v110 = dword_188991100[(__int16)v109];
        }
        *((_DWORD *)this + 143) = v110;
        LODWORD(v54) = (v108 - 1 + v54) / v108;
        LODWORD(v55) = (v108 - 1 + v55) / v108;
      }
      if ((double)(v54 * v55) / (double)*((unint64_t *)this + 23) < 1000.0)
      {
        *((_DWORD *)this + 57) = v54;
        *((_DWORD *)this + 58) = v55;
        *((_WORD *)this + 120) = 8;
        *((_WORD *)this + 121) = 8 * v56;
        *((_WORD *)this + 122) = v56;
        int v111 = v54 * v56;
        *((_DWORD *)this + 59) = v111;
        *((unsigned char *)this + 246) = 0;
        *((unsigned char *)this + 344) = 0;
        *((unsigned char *)this + 346) = 0;
        *((_DWORD *)this + 67) = v111;
        *((void *)this + 45) = 1;
        readJFIFData((uint64_t)this + 504, v232);
        int v226 = v25;
        if (v25)
        {
          if (!*((void *)this + 2)) {
            goto LABEL_180;
          }
          uint64_t v113 = copyRenderingInfo((uint64_t)this + 504);
          uint64_t Metadata = IIOImagePlus::getMetadata(*((IIOImagePlus **)this + 2));
          CGImageMetadataMerge(Metadata, v113, 0);
          int v115 = (const void *)v113;
          if (!v113) {
            goto LABEL_180;
          }
        }
        else
        {
          unsigned int v238 = v10;
          CFDictionaryRef v116 = LibJPEGReadPlugin::readExifData(v112, (uint64_t)this + 504, v4);
          uint64_t v117 = *((void *)this + 8);
          CGImageMetadataMerge(v117, (uint64_t)v116, v4);
          if (v26)
          {
            CGMutableImageMetadataRef v118 = 0;
            int v119 = 0;
          }
          else
          {
            CGMutableImageMetadataRef v120 = LibJPEGReadPlugin::readAPP13((uint64_t)this, (uint64_t)this + 504);
            uint64_t v121 = LibJPEGReadPlugin::readXMPData((uint64_t)this, (uint64_t)this + 504, theData);
            CGImageMetadataMerge(v117, (uint64_t)v120, v4);
            CGImageMetadataMerge(v117, v121, v4);
            CGMutableImageMetadataRef v118 = v120;
            int v119 = (const void *)v121;
          }
          unsigned int v10 = v238;
          if (v116) {
            CFRelease(v116);
          }
          if (v118) {
            CFRelease(v118);
          }
          int v115 = v119;
          if (!v119)
          {
LABEL_180:
            if (!*((_DWORD *)this + 223) || *((_DWORD *)this + 140) != 4 || *((unsigned char *)this + 896) == 1) {
              goto LABEL_193;
            }
            if (*((unsigned char *)this + 896))
            {
              if (v10 && (v236 != 1 || *((_DWORD *)this + 141) == 5)) {
                goto LABEL_193;
              }
            }
            else
            {
              if (v236 == 1) {
                char v122 = 0;
              }
              else {
                char v122 = v10;
              }
              if (v122)
              {
LABEL_193:
                if (*((_DWORD *)this + 205)) {
                  IIODictionary::setObjectForKeyGroup(v232, (const void *)*MEMORY[0x1E4F1CFD0], @"IsProgressive", @"{JFIF}");
                }
                int v123 = *((_DWORD *)this + 2414);
                switch(v123)
                {
                  case 1:
                    int v124 = 1196573017;
                    break;
                  case 2:
                    int v124 = 1380401696;
                    break;
                  case 4:
                    int v124 = 1129142603;
                    break;
                  default:
                    goto LABEL_202;
                }
                *((_DWORD *)this + 81) = v124;
LABEL_202:
                unsigned int v125 = (uint64_t **)*((void *)this + 114);
                if (!v125) {
                  goto LABEL_230;
                }
                unint64_t v126 = 0;
                unint64_t v127 = 0;
                uint64_t v128 = 0;
                do
                {
                  unint64_t v129 = v127;
                  unint64_t v130 = v126;
                  if (*((unsigned __int8 *)v125 + 8) == 226
                    && (uint64_t v131 = *((unsigned int *)v125 + 4), v131 >= 0xF)
                    && ((int v132 = v125[3],
                         uint64_t v133 = *v132,
                         uint64_t v134 = *(uint64_t *)((char *)v132 + 3),
                         v133 == 0x464F52505F434349)
                      ? (BOOL v135 = v134 == 0x454C49464F52505FLL)
                      : (BOOL v135 = 0),
                        v135))
                  {
                    uint64_t v137 = v131 - 14;
                    size_t v138 = v131 - 14;
                    if (v128)
                    {
                      if (v129 > 13 - v131) {
                        goto LABEL_229;
                      }
                      unsigned int v139 = (unsigned int *)reallocf(v128, v137 + v129);
                    }
                    else
                    {
                      unsigned int v139 = (unsigned int *)malloc_type_malloc(v131 - 14, 0x55127D9DuLL);
                    }
                    int v140 = v139;
                    if (!v139) {
                      goto LABEL_230;
                    }
                    memcpy((char *)v139 + v130, (char *)v125[3] + 14, v138);
                    v130 += v137;
                    unint64_t v129 = v130;
                    unsigned int v136 = v140;
                  }
                  else
                  {
                    unsigned int v136 = v128;
                  }
                  unsigned int v125 = (uint64_t **)*v125;
                  unint64_t v126 = v130;
                  unint64_t v127 = v129;
                  uint64_t v128 = v136;
                }
                while (v125);
                if (!v136) {
                  goto LABEL_230;
                }
                if (v129 >= 0x80)
                {
                  unsigned int v141 = v136[9];
                  unint64_t v142 = bswap32(*v136);
                  if (v129 < v142) {
                    LogError("readICCData", 865, "Embedded profile header length is greater than data length.\n");
                  }
                  if (v141 == 1886610273)
                  {
                    if (v130 >= v142)
                    {
                      uint64_t v143 = CGColorSpaceCreateWithCopyOfData((UInt8 *)v136, v130);
                      free(v136);
                      CGColorSpaceRef v144 = (CGColorSpaceRef)v143;
                      if (v143) {
                        goto LABEL_248;
                      }
LABEL_230:
                      int v145 = *((_DWORD *)this + 81);
                      if (v145 == 1380401696)
                      {
                        LOBYTE(v242[0]) = 0;
                        CGColorSpaceRef ColorSpaceFromMetadata = createColorSpaceFromMetadata(v228, v226, v242);
                        if (LOBYTE(v242[0])) {
                          *((_WORD *)this + 164) = 1;
                        }
                        CGColorSpaceRef v144 = ColorSpaceFromMetadata;
                        if (ColorSpaceFromMetadata) {
                          goto LABEL_248;
                        }
                        int v145 = *((_DWORD *)this + 81);
                      }
                      switch(v145)
                      {
                        case 1129142603:
                          uint64_t v151 = (CFStringRef *)MEMORY[0x1E4F1DBF0];
                          goto LABEL_247;
                        case 1196573017:
                          uint64_t v151 = (CFStringRef *)MEMORY[0x1E4F1DC00];
                          goto LABEL_247;
                        case 1380401696:
                          CFDictionaryRef TopLevelTag = CGImageMetadataGetTopLevelTag(v228, @"http://ns.adobe.com/exif/1.0/", @"ColorSpace");
                          if (!TopLevelTag
                            || (CFStringRef Value = (const __CFString *)CGImageMetadataTagGetValue((uint64_t)TopLevelTag)) == 0)
                          {
                            uint64_t v151 = (CFStringRef *)MEMORY[0x1E4F1DC98];
                            goto LABEL_247;
                          }
                          IntCFStringRef Value = CFStringGetIntValue(Value);
                          unint64_t v150 = (CFStringRef *)MEMORY[0x1E4F1DC98];
                          uint64_t v151 = (CFStringRef *)MEMORY[0x1E4F1DC98];
                          if (IntValue != 1)
                          {
LABEL_247:
                            CGColorSpaceRef v144 = CGColorSpaceCreateWithName(*v151);
                            break;
                          }
                          CGColorSpaceRef v144 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
                          if (!v144)
                          {
                            uint64_t v151 = v150;
                            goto LABEL_247;
                          }
                          break;
                        default:
                          CGColorSpaceRef v144 = 0;
                          break;
                      }
LABEL_248:
                      if (!v240
                        || *((void *)this + 24)
                        || !*((unsigned char *)this + 341)
                        || *((unsigned char *)this + 216) != 1
                        || v227
                        || *((_DWORD *)this + 141) != 3
                        || *((int *)this + 230) > 2
                        || *((int *)this + 231) > 2)
                      {
                        if (*((unsigned char *)this + 341) || *((unsigned char *)this + 216) != 1)
                        {
                          *((void *)this + 20) = v144;
                          _cg_jpeg_destroy_decompress((char *)this + 504);
                          *((unsigned char *)this + 9661) = 0;
                          *((_WORD *)this + 188) = 1;
                        }
                        else
                        {
                          *((void *)this + 20) = v144;
                          *((unsigned char *)this + 9661) = 1;
                          *((unsigned char *)this + 448) = 2;
                          *((_WORD *)this + 188) = 1;
                        }
                        int v152 = (IIOImagePlus *)*((void *)this + 2);
                        if (v152 && IIOImagePlus::sourceImageProvider(v152)) {
                          CGImageProviderSetProperty();
                        }
                        int v47 = v227;
                        goto LABEL_258;
                      }
                      CGColorSpaceRef v153 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
                      memset(v245, 0, 128);
                      memset(v244, 0, sizeof(v244));
                      memset(v243, 0, sizeof(v243));
                      *(_OWORD *)v242 = 0u;
                      v241[0] = v242;
                      v241[1] = v244;
                      v241[2] = v245;
                      unsigned int v154 = (unsigned int *)*((void *)this + 101);
                      double v155 = 0.0;
                      if (*((_DWORD *)this + 230) == 2)
                      {
                        if (*((_DWORD *)this + 231) == 1) {
                          double v155 = 0.5;
                        }
                        else {
                          double v155 = 0.0;
                        }
                      }
                      CGColorSpaceRef space = v153;
                      *((_DWORD *)this + 149) = 1;
                      uint64_t v156 = v154[11];
                      size_t v157 = v154[12];
                      size_t v158 = ImageIOAlignRowBytes(v156, 0x10uLL);
                      unsigned int v159 = (char *)malloc_type_calloc(v158, v157 + 15, 0x281BD07EuLL);
                      long long v160 = v159;
                      if (v159)
                      {
                        size_t v224 = v157;
                        data = v159;
                        uint64_t v161 = v154[35];
                        size_t v162 = v154[36];
                        size_t v163 = ImageIOAlignRowBytes(v161, 0x10uLL);
                        size_t v222 = v162;
                        int v164 = (char *)malloc_type_calloc(v163, v162 + 15, 0xE739715AuLL);
                        int v165 = v164;
                        if (!v164)
                        {
                          uint64_t v185 = 0;
                          int v195 = 0;
                          uint64_t v187 = 0;
                          CGImageRef v196 = 0;
                          CGImageRef v169 = 0;
                          CGImageRef v197 = 0;
                          unsigned int v193 = 0;
                          unsigned int v190 = 0;
                          long long v160 = data;
                          goto LABEL_302;
                        }
                        size_t v221 = v161;
                        size_t width = v156;
                        v217 = v164;
                        size_t v166 = v154[60];
                        size_t v219 = v154[59];
                        unsigned int v200 = v154;
                        size_t v167 = ImageIOAlignRowBytes(v219, 0x10uLL);
                        size_t v220 = v166;
                        unsigned int v168 = (CGImage *)malloc_type_calloc(v167, v166 + 15, 0x2864B59CuLL);
                        CGImageRef v169 = v168;
                        if (!v168)
                        {
                          uint64_t v185 = 0;
                          int v195 = 0;
                          uint64_t v187 = 0;
                          CGImageRef v196 = 0;
                          CGImageRef v197 = 0;
                          unsigned int v193 = 0;
                          unsigned int v190 = 0;
                          long long v160 = data;
                          int v165 = v217;
                          goto LABEL_302;
                        }
                        size_t v214 = v158;
                        v215 = v168;
                        size_t bytesPerRow = v163;
                        unsigned int v170 = 8 * *((_DWORD *)this + 231);
                        unsigned int v212 = 8 * v200[3];
                        unsigned int v210 = 8 * v200[27];
                        unsigned int v211 = v200[3];
                        unsigned int v209 = v200[27];
                        unsigned int v207 = v200[51];
                        unsigned int v208 = 8 * v207;
                        _cg_jpeg_start_decompress((uint64_t)this + 504);
                        if (v212 <= 1) {
                          uint64_t v171 = 1;
                        }
                        else {
                          uint64_t v171 = v212;
                        }
                        if (v210 <= 1) {
                          uint64_t v172 = 1;
                        }
                        else {
                          uint64_t v172 = v210;
                        }
                        if (v208 <= 1) {
                          uint64_t v173 = 1;
                        }
                        else {
                          uint64_t v173 = v208;
                        }
                        uint64_t v205 = v171;
                        uint64_t v204 = v172;
                        uint64_t v203 = v173;
                        do
                        {
                          unsigned int v174 = *((_DWORD *)this + 168);
                          if (v174 >= *((_DWORD *)this + 161)) {
                            break;
                          }
                          if (v211)
                          {
                            unsigned int v175 = v242;
                            uint64_t v176 = v205;
                            uint64_t v177 = 0;
                            do
                            {
                              *v175++ = (IIOImageReadSession *)&v160[v158 * (v177 + (int)(v174 * v212 / v170))];
                              ++v177;
                              --v176;
                            }
                            while (v176);
                          }
                          if (v209)
                          {
                            uint64_t v178 = v204;
                            size_t v179 = v244;
                            uint64_t v180 = 0;
                            do
                            {
                              *v179++ = &v165[v163 * (v180 + (int)(v174 * v210 / v170))];
                              ++v180;
                              --v178;
                            }
                            while (v178);
                          }
                          if (v207)
                          {
                            uint64_t v181 = (int)(v174 * v208 / v170);
                            uint64_t v182 = v203;
                            size_t v183 = v245;
                            uint64_t v184 = 0;
                            do
                            {
                              *v183++ = (char *)v169 + v167 * (v184 + v181);
                              ++v184;
                              --v182;
                            }
                            while (v182);
                          }
                        }
                        while (_cg_jpeg_read_raw_data((uint64_t)this + 504, (uint64_t)v241, v170) >= v170);
                        _cg_jpeg_destroy_decompress((char *)this + 504);
                        uint64_t v185 = 0;
                        long long v160 = data;
                        CGDataProviderRef v186 = CGDataProviderCreateWithData(0, data, v158 * v224, (CGDataProviderReleaseDataCallback)releaseData);
                        if (v186)
                        {
                          CFTypeRef cf = v186;
                          uint64_t v187 = 0;
                          int v165 = v217;
                          CGDataProviderRef v188 = CGDataProviderCreateWithData(0, v217, v163 * v222, (CGDataProviderReleaseDataCallback)releaseData);
                          if (v188)
                          {
                            CGSize v189 = v188;
                            int v165 = 0;
                            unsigned int v190 = v215;
                            CGDataProviderRef v191 = CGDataProviderCreateWithData(0, v215, v167 * v220, (CGDataProviderReleaseDataCallback)releaseData);
                            if (v191)
                            {
                              provider = v191;
                              CGImageRef v206 = CGImageCreate(width, v224, 8uLL, 8uLL, v214, space, 0, cf, 0, 1, kCGRenderingIntentDefault);
                              CGImageRef v169 = CGImageCreate(v221, v222, 8uLL, 8uLL, bytesPerRow, space, 0, v189, 0, 1, kCGRenderingIntentDefault);
                              CGImageRef v192 = CGImageCreate(v219, v220, 8uLL, 8uLL, v167, space, 0, provider, 0, 1, kCGRenderingIntentDefault);
                              if (v206 && v169)
                              {
                                if (v192)
                                {
                                  CGImageSetProperty();
                                  CGImageSetProperty();
                                  CGImageSetProperty();
                                  CGImageSetProperty();
                                  CGImageSetProperty();
                                  CGImageSetProperty();
                                  unsigned int v193 = 0;
                                  CGImageRefFromYCbCruint64_t Data = (CGImage *)g_ciGetCGImageRefFromYCbCrData(v206, v169, v192, v144, 0, v155, 0.0);
                                  if (CGImageRefFromYCbCrData)
                                  {
                                    unsigned int v193 = CGImageRefFromYCbCrData;
                                    IIOImagePlus::setImage(*((CGImageRef **)this + 2), CGImageRefFromYCbCrData);
                                    uint64_t v185 = cf;
                                    int v195 = v189;
                                    uint64_t v187 = provider;
                                    CGImageRef v196 = v206;
                                    CGImageRef v197 = v192;
                                    int v165 = 0;
                                    unsigned int v190 = 0;
                                    long long v160 = 0;
                                  }
                                  else
                                  {
                                    uint64_t v185 = cf;
                                    int v195 = v189;
                                    uint64_t v187 = provider;
                                    CGImageRef v196 = v206;
                                    CGImageRef v197 = v192;
                                    long long v160 = 0;
                                    int v165 = 0;
                                    unsigned int v190 = 0;
                                  }
                                  goto LABEL_302;
                                }
                                uint64_t v185 = cf;
                                int v195 = v189;
                              }
                              else
                              {
                                uint64_t v185 = cf;
                                int v195 = v189;
                              }
                              uint64_t v187 = provider;
                              CGImageRef v196 = v206;
                              CGImageRef v197 = v192;
                              unsigned int v193 = 0;
                              long long v160 = 0;
                              int v165 = 0;
                              unsigned int v190 = 0;
                            }
                            else
                            {
                              uint64_t v185 = cf;
                              int v195 = v189;
                              CGImageRef v196 = 0;
                              CGImageRef v169 = 0;
                              CGImageRef v197 = 0;
                              unsigned int v193 = 0;
                              long long v160 = 0;
                              uint64_t v187 = 0;
                            }
LABEL_302:
                            uint64_t v202 = v190;
                            CGImageRef v198 = v197;
                            float v199 = v195;
                            if (space) {
                              CGColorSpaceRelease(space);
                            }
                            if (v193) {
                              CFRelease(v193);
                            }
                            if (v196) {
                              CFRelease(v196);
                            }
                            if (v185) {
                              CFRelease(v185);
                            }
                            if (v160) {
                              free(v160);
                            }
                            if (v169) {
                              CFRelease(v169);
                            }
                            if (v199) {
                              CFRelease(v199);
                            }
                            if (v165) {
                              free(v165);
                            }
                            if (v198) {
                              CFRelease(v198);
                            }
                            if (v187) {
                              CFRelease(v187);
                            }
                            if (v202) {
                              free(v202);
                            }
                            int v47 = 0;
                            goto LABEL_258;
                          }
                          int v195 = 0;
                          uint64_t v185 = cf;
                          CGImageRef v196 = 0;
                          CGImageRef v169 = 0;
                          CGImageRef v197 = 0;
                          unsigned int v193 = 0;
                          long long v160 = 0;
                        }
                        else
                        {
                          int v195 = 0;
                          uint64_t v187 = 0;
                          CGImageRef v196 = 0;
                          CGImageRef v169 = 0;
                          CGImageRef v197 = 0;
                          unsigned int v193 = 0;
                          int v165 = v217;
                        }
                        unsigned int v190 = v215;
                        goto LABEL_302;
                      }
                      uint64_t v185 = 0;
                      int v195 = 0;
                      uint64_t v187 = 0;
                      CGImageRef v196 = 0;
                      CGImageRef v169 = 0;
                      CGImageRef v197 = 0;
                      unsigned int v193 = 0;
                      int v165 = 0;
                      unsigned int v190 = 0;
                      goto LABEL_302;
                    }
                  }
                  else
                  {
                    LogError("readICCData", 867, "Embedded profile signature is not valid.\n");
                  }
                }
                uint64_t v128 = v136;
LABEL_229:
                free(v128);
                goto LABEL_230;
              }
            }
            *((unsigned char *)this + 346) = 1;
            goto LABEL_193;
          }
        }
        CFRelease(v115);
        goto LABEL_180;
      }
      _cg_jpeg_mem_term("initialize", 1761, "malformed JPEG?\n");
LABEL_76:
      int v47 = v49;
      uint64_t result = v48;
      if (!v50) {
        return result;
      }
      goto LABEL_258;
    }
  }
  return result;
}

void readJFIFData(uint64_t a1, IIODictionary *a2)
{
  if (a1 && a2 && *(_DWORD *)(a1 + 376))
  {
    CFMutableArrayRef v18 = 0;
    int v19 = 0;
    uint64_t v20 = 0;
    IIOArray::IIOArray((IIOArray *)&v18);
    IIONumber::IIONumber((IIONumber *)v16, *(unsigned __int8 *)(a1 + 380));
    IIOArray::addObject(&v18, v17);
    IIONumber::~IIONumber((IIONumber *)v16);
    IIONumber::IIONumber(v4, *(unsigned __int8 *)(a1 + 381) >> 4);
    IIOArray::addObject(&v18, v17);
    IIONumber::~IIONumber((IIONumber *)v16);
    IIONumber::IIONumber(v5, *(unsigned char *)(a1 + 381) & 0xF);
    IIOArray::addObject(&v18, v17);
    IIONumber::~IIONumber((IIONumber *)v16);
    IIODictionary::setObjectForKeyGroup(a2, v19, @"JFIFVersion", @"{JFIF}");
    IIOArray::~IIOArray((IIOArray *)&v18);
    IIONumber::IIONumber((IIONumber *)v15, *(unsigned __int16 *)(a1 + 384));
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v15, @"XDensity", @"{JFIF}");
    IIONumber::~IIONumber((IIONumber *)v15);
    IIONumber::IIONumber((IIONumber *)v14, *(unsigned __int16 *)(a1 + 386));
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v14, @"YDensity", @"{JFIF}");
    IIONumber::~IIONumber((IIONumber *)v14);
    IIONumber::IIONumber((IIONumber *)v13, *(unsigned __int8 *)(a1 + 382));
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v13, @"DensityUnit", @"{JFIF}");
    IIONumber::~IIONumber((IIONumber *)v13);
    int v7 = *(unsigned __int8 *)(a1 + 382);
    if (v7 == 2)
    {
      LOWORD(v6) = *(_WORD *)(a1 + 384);
      *(double *)&unint64_t v10 = (double)v6 * 2.54;
      float v8 = *(double *)&v10;
      LOWORD(v10) = *(_WORD *)(a1 + 386);
      float v9 = (double)v10 * 2.54;
    }
    else
    {
      float v8 = 0.0;
      float v9 = 0.0;
      if (v7 == 1)
      {
        LOWORD(v6) = *(_WORD *)(a1 + 384);
        float v8 = (float)v6;
        LOWORD(v6) = *(_WORD *)(a1 + 386);
        float v9 = (float)v6;
      }
    }
    if (ValidDPI(v8) && ValidDPI(v9))
    {
      IIONumber::IIONumber((IIONumber *)v12, v8);
      IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v12, @"DPIWidth");
      IIONumber::~IIONumber((IIONumber *)v12);
      IIONumber::IIONumber((IIONumber *)v11, v9);
      IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v11, @"DPIHeight");
      IIONumber::~IIONumber((IIONumber *)v11);
    }
  }
}

void sub_18874D2B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t copyRenderingInfo(uint64_t a1)
{
  uint64_t v1 = *(uint64_t **)(a1 + 408);
  if (!v1) {
    return 0;
  }
  uint64_t result = 0;
  do
  {
    if (*((unsigned __int8 *)v1 + 8) == 225)
    {
      unsigned int v3 = *((_DWORD *)v1 + 4);
      if (v3 >= 0xB)
      {
        uint64_t v4 = v1[3];
        if (*(unsigned char *)v4 == 69
          && *(unsigned char *)(v4 + 1) == 120
          && *(unsigned char *)(v4 + 2) == 105
          && *(unsigned char *)(v4 + 3) == 102
          && !*(unsigned char *)(v4 + 4)
          && !*(unsigned char *)(v4 + 5))
        {
          uint64_t result = CreateMetadataFromDatabuffer((const char *)(v4 + 6), v3 - 6);
        }
      }
    }
    uint64_t v1 = (uint64_t *)*v1;
  }
  while (v1);
  return result;
}

void releaseData(void *a1, void *a2)
{
}

uint64_t LibJPEGReadPlugin::copyImageBlockSetJPEGTiles(uint64_t a1, const void *a2, const void *a3, const __CFDictionary *a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  double v16 = a6;
  double v17 = a5;
  int v110 = 0;
  unsigned int v109 = 0;
  unint64_t v108 = 0;
  CFTypeRef value = 0;
  if (a3)
  {
    CGImageProviderGetSize();
    double v20 = v19;
    double v22 = v21;
    Pixelunint64_t Size = CGImageProviderGetPixelSize();
    double v24 = v22;
  }
  else
  {
    LODWORD(a5) = *(_DWORD *)(a1 + 292);
    double v20 = (double)*(unint64_t *)&a5;
    LODWORD(a6) = *(_DWORD *)(a1 + 296);
    double v24 = (double)*(unint64_t *)&a6;
    if (*(_WORD *)(a1 + 308) == 3)
    {
      if (*(unsigned char *)(a1 + 310)) {
        Pixelunint64_t Size = 4;
      }
      else {
        Pixelunint64_t Size = 3;
      }
    }
    else
    {
      Pixelunint64_t Size = *(unsigned __int16 *)(a1 + 308);
    }
  }
  double v103 = v24;
  if (a4) {
    CFDictionaryGetValueIfPresent(a4, (const void *)*MEMORY[0x1E4F1DD50], (const void **)&value);
  }
  double v94 = a8;
  double v25 = a8;
  double v26 = a7;
  double v27 = v16;
  double v28 = v17;
  if (value)
  {
    char valuePtr = 0;
    double v29 = a7;
    double v30 = a10;
    double v31 = a9;
    double v32 = v25;
    double v93 = v16;
    double v33 = v26;
    double v34 = v27;
    CFNumberGetValue((CFNumberRef)value, kCFNumberLongType, &valuePtr);
    double v28 = v17;
    double v27 = v34;
    double v26 = v33;
    double v16 = v93;
    double v25 = v32;
    a9 = v31;
    a10 = v30;
    a7 = v29;
    if (valuePtr <= 0x40) {
      unsigned int v35 = 64;
    }
    else {
      unsigned int v35 = valuePtr;
    }
  }
  else
  {
    unsigned int v35 = 256;
  }
  double v36 = (double)(v35 - 1);
  unsigned int v37 = ((v17 + a7 + v36) / (double)v35);
  unsigned int v38 = (v16 / (double)v35);
  unsigned int v39 = ((v16 + v94 + v36) / (double)v35);
  *(_DWORD *)(a1 + 292) = v35;
  *(_DWORD *)(a1 + 296) = v35;
  *(_DWORD *)(a1 + 300) = v35 * PixelSize;
  unsigned int v40 = (v37 - (v17 / (double)v35)) * (v39 - v38);
  *(_DWORD *)(a1 + 104) = v40;
  *(_WORD *)(a1 + 316) = 1;
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, v28, v27, v26, v25, a9, a10);
  double v41 = (double)PixelSize;
  *(_DWORD *)(a1 + 236) = ((unint64_t)(a7 * (double)PixelSize) + 15) & 0xFFFFFFF0;
  uint32x2_t v42 = vmin_u32((uint32x2_t)vdup_n_s32(v35), *(uint32x2_t *)(a1 + 228));
  *(uint32x2_t *)(a1 + 292) = v42;
  *(_DWORD *)(a1 + 300) = v42.i32[0] * PixelSize;
  *(_DWORD *)(a1 + 104) = v40;
  if (sigsetjmp((int *)(a1 + 9448), 0))
  {
    _cg_jpeg_mem_term("copyImageBlockSetJPEGTiles", 2302, "sigsetjmp");
    uint64_t v43 = 0;
    int v44 = 0;
    goto LABEL_74;
  }
  unsigned int v100 = v39;
  unsigned int v101 = v37;
  unsigned int v102 = (v17 / (double)v35);
  uint64_t v45 = a1 + 504;
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
  unint64_t v46 = *(IIOImageRead ***)(a1 + 24);
  if (v46) {
    LODWORD(v46) = IIOImageReadSession::mapData(v46);
  }
  int v47 = (int)v46;
  _cg_jpeg_destroy_decompress(a1 + 504);
  LibJPEGReadPlugin::startDecompressing(a1, *(_DWORD *)(a1 + 9656));
  *(void *)(a1 + 9648) = -1;
  if (*(_DWORD *)(a1 + 540) != 205)
  {
    uint64_t v43 = 0;
    *(_DWORD *)(a1 + 104) = 0;
    int v44 = v47;
    goto LABEL_74;
  }
  unsigned int v48 = (v16 / (double)v35);
  unint64_t v49 = ImageIOAlignRowBytes(*(_DWORD *)(a1 + 640) * PixelSize, 0x10uLL);
  unsigned int v109 = malloc_type_malloc(v49 * *(unsigned int *)(a1 + 296), 0xC0C0BF88uLL);
  uint64_t v104 = (uint64_t)a3;
  int v99 = v47;
  if (!v38) {
    goto LABEL_27;
  }
  int v50 = v35 * v38;
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    skipping rows %4d through %4d\n", 0, v35 * v38);
  }
  char valuePtr = (char *)v109;
  if (v50)
  {
    do
    {
      int scanlines = _cg_jpeg_read_scanlines(a1 + 504, (uint64_t)&valuePtr, 1);
      --v50;
    }
    while (v50);
    BOOL v52 = scanlines == 1;
    unsigned int v48 = (v16 / (double)v35);
  }
  else
  {
LABEL_27:
    BOOL v52 = 0;
  }
  if (v100 <= v38)
  {
LABEL_70:
    uint64_t v43 = 0;
    if (v104 && *(_DWORD *)(a1 + 104)) {
      uint64_t v43 = IIOReadPlugin::imageBlockSetCreate(a1, v104, *(unsigned int *)(a1 + 104), v20, v103, *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(void *)(a1 + 96), a2);
    }
    int v44 = v99;
    goto LABEL_74;
  }
  uint64_t v98 = v35;
  uint64_t v97 = PixelSize;
  unsigned int v53 = v48;
  char v54 = v52;
  uint64_t v55 = 0;
  while (1)
  {
    unsigned int v95 = v35;
    unsigned int v96 = v53;
    unsigned int v56 = *(_DWORD *)(a1 + 296);
    unsigned int v57 = v56 * v96;
    double v58 = (double)(v56 * v96);
    int v59 = *(_DWORD *)(a1 + 292);
    if ((double)v56 + v58 <= v103) {
      double v60 = (double)v56;
    }
    else {
      double v60 = v103 - (double)v57;
    }
    double y = v60 + v58;
    unsigned int v62 = (v60 + v58);
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("                   reading rows: %d ... %d\n", v57, v62 - 1);
    }
    if (v57 < v62)
    {
      unsigned int v63 = v57;
      uint64_t v64 = 0;
      while (1)
      {
        char valuePtr = (char *)v109 + v64;
        if (_cg_jpeg_read_scanlines(v45, (uint64_t)&valuePtr, 1) != 1) {
          goto LABEL_55;
        }
        ++v63;
        v64 += v49;
        if (v63 >= v62) {
          goto LABEL_41;
        }
      }
    }
    if (v54) {
      break;
    }
LABEL_55:
    if (v96 + 1 < *(_DWORD *)(a1 + 116)) {
      *(_DWORD *)(a1 + 104) = v96 + 1 - *(_DWORD *)(a1 + 112);
    }
    uint64_t v80 = v95 - v57;
    if (v80)
    {
      unsigned int v81 = v95 - v57;
      LODWORD(y) = v59;
      double v82 = (double)*(unint64_t *)&y;
      unsigned int v83 = (v41 * (double)*(unint64_t *)&y);
      *(_DWORD *)(a1 + 300) = v83;
      if ((gIIODebugFlags & 0x30000) != 0)
      {
        ImageIOLog("                     valid rows: %ld\n", v80);
        unsigned int v83 = *(_DWORD *)(a1 + 300);
      }
      double v84 = (double)v80;
      v113.origin.double x = 0.0;
      v113.origin.double y = v58;
      v113.size.double width = v82;
      v113.size.CGFloat height = (double)v80;
      *(void *)(*(void *)(a1 + 96) + 8 * v55) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v110, v108, v113, v83, 0);
      if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E4F1DB20]))
      {
        uint64_t v85 = 0;
      }
      else
      {
        v115.origin.double x = 0.0;
        v115.origin.double y = v58;
        v115.size.double width = v82;
        v115.size.CGFloat height = (double)v80;
        *(CGRect *)&uint64_t v85 = CGRectUnion(*(CGRect *)(a1 + 120), v115);
        double v58 = v87;
        double v82 = v88;
        double v84 = v89;
      }
      char v79 = 0;
      ++v55;
      *(void *)(a1 + 120) = v85;
      *(double *)(a1 + 128) = v58;
      *(double *)(a1 + 136) = v82;
      *(double *)(a1 + 144) = v84;
    }
    else
    {
      int v86 = *(_DWORD *)(a1 + 104);
      if (v86) {
        *(_DWORD *)(a1 + 104) = v86 - 1;
      }
      _ImageIO_Free((unint64_t)v110, v108);
      int v110 = 0;
      char v79 = 0;
      unsigned int v81 = 0;
    }
LABEL_69:
    unsigned int v35 = v81;
    char v54 = v79;
    unsigned int v53 = v96 + 1;
    if (v96 + 1 == v100) {
      goto LABEL_70;
    }
  }
LABEL_41:
  if (v101 <= v102)
  {
    char v79 = 1;
LABEL_63:
    unsigned int v81 = v95;
    goto LABEL_69;
  }
  uint64_t v65 = v102;
  uint64_t v66 = v55;
  while (1)
  {
    uint64_t v67 = v65;
    uint64_t v68 = v65 * v98;
    double x = (double)(unint64_t)(v65 * v98);
    LODWORD(y) = *(_DWORD *)(a1 + 292);
    double v70 = (double)*(unint64_t *)&y;
    double width = x + v70 <= v20 ? v70 : v20 - x;
    unsigned int v72 = (width * v41);
    int v110 = (void *)_ImageIO_Malloc(*(unsigned int *)(a1 + 296) * (unint64_t)v72, *(void *)(a1 + 384), &v108, (uint64_t)kImageMalloc_LIBJPEG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
    if (!v110) {
      break;
    }
    uint64_t v73 = v45;
    if (v60 > 0.0)
    {
      unsigned int v74 = 0;
      uint64_t v75 = v68 * v97;
      unsigned int v76 = 0;
      do
      {
        memcpy((char *)v110 + v74, (char *)v109 + v49 * v76++ + v75, (width * v41));
        v74 += v72;
      }
      while (v60 > (double)v76);
    }
    *(_DWORD *)(a1 + 300) = v72;
    v111.origin.double x = x;
    v111.origin.double y = v58;
    v111.size.double width = width;
    v111.size.CGFloat height = v60;
    *(void *)(*(void *)(a1 + 96) + 8 * v66) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v110, v108, v111, (width * v41), 0);
    if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E4F1DB20]))
    {
      double y = v58;
      CGFloat height = v60;
    }
    else
    {
      v114.size.CGFloat height = v60;
      v114.origin.double y = v58;
      v114.origin.double x = x;
      v114.size.double width = width;
      CGRect v112 = CGRectUnion(*(CGRect *)(a1 + 120), v114);
      double x = v112.origin.x;
      double width = v112.size.width;
      double y = v112.origin.y;
      CGFloat height = v112.size.height;
    }
    uint64_t v45 = v73;
    uint64_t v78 = v66 + 1;
    *(double *)(a1 + 120) = x;
    *(double *)(a1 + 128) = y;
    *(double *)(a1 + 136) = width;
    *(CGFloat *)(a1 + 144) = height;
    uint64_t v65 = v67 + 1;
    ++v66;
    if (v67 + 1 == v101)
    {
      char v79 = 1;
      uint64_t v55 = v78;
      goto LABEL_63;
    }
  }
  int v44 = v99;
  uint64_t v43 = 0;
LABEL_74:
  int v90 = v44;
  if (v109) {
    free(v109);
  }
  if (v90)
  {
    unint64_t v91 = *(const char ***)(a1 + 24);
    if (v91) {
      IIOImageReadSession::unmapData(v91);
    }
  }
  return v43;
}

uint64_t LibJPEGReadPlugin::copyImageBlockSetProgressive(uint64_t a1, const void *a2, const void *a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  double v11 = a8;
  double v14 = a9;
  uint64_t v75 = 0;
  unint64_t v74 = 0;
  if (a3)
  {
    double v17 = a8;
    double v18 = a7;
    double v19 = a5;
    double v20 = a4;
    CGImageProviderGetSize();
    double v22 = v21;
    double v69 = v23;
    Pixelunint64_t Size = CGImageProviderGetPixelSize();
    a4 = v20;
    a5 = v19;
    a7 = v18;
    a8 = v17;
    double v14 = a9;
    unsigned int v25 = PixelSize;
    double v26 = v69;
  }
  else
  {
    LODWORD(v9) = *(_DWORD *)(a1 + 292);
    double v22 = (double)v9;
    LODWORD(v9) = *(_DWORD *)(a1 + 296);
    double v26 = (double)v9;
    if (*(_WORD *)(a1 + 308) == 3)
    {
      if (*(unsigned char *)(a1 + 310)) {
        unsigned int v25 = 4;
      }
      else {
        unsigned int v25 = 3;
      }
    }
    else
    {
      unsigned int v25 = *(unsigned __int16 *)(a1 + 308);
    }
  }
  double v27 = v22;
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, a4, a5, a6, a7, a8, v14);
  unsigned int v28 = *(unsigned __int16 *)(a1 + 316);
  __int16 v29 = *(_WORD *)(a1 + 316);
  uint64_t v30 = *(void *)(a1 + 228);
  unsigned int v72 = a2;
  if (!*(unsigned char *)(a1 + 348)) {
    goto LABEL_28;
  }
  if (v28 <= 1) {
    uint64_t v31 = 1;
  }
  else {
    uint64_t v31 = *(unsigned __int16 *)(a1 + 316);
  }
  unint64_t v32 = v31 * (unint64_t)v22;
  unint64_t v33 = v31 * (unint64_t)v26;
  if (v11 > (double)(v32 >> 3) || a9 > (double)(v33 >> 3))
  {
    if (v11 <= (double)(v32 >> 2) && a9 <= (double)(v33 >> 2))
    {
      if (v28 == 4)
      {
        int v37 = 8;
        goto LABEL_29;
      }
      __int16 v39 = 4;
      uint64_t v40 = 4;
      uint64_t v41 = 3;
      goto LABEL_36;
    }
    if (v11 <= (double)(v32 >> 1) && a9 <= (double)(v33 >> 1) && v28 != 2)
    {
      __int16 v39 = 2;
      uint64_t v40 = 2;
      uint64_t v41 = 1;
      goto LABEL_36;
    }
LABEL_28:
    int v37 = *(unsigned __int16 *)(a1 + 316);
LABEL_29:
    int v38 = 0;
    goto LABEL_37;
  }
  if (v28 == 8)
  {
    int v37 = 8;
    goto LABEL_29;
  }
  uint64_t v40 = 8;
  uint64_t v41 = 7;
  __int16 v39 = 8;
LABEL_36:
  *(_WORD *)(a1 + 316) = v39;
  uint64_t v42 = (uint64_t)(v32 + v41) / v40;
  double v27 = (double)v42;
  uint64_t v43 = (uint64_t)(v33 + v41) / v40;
  double v26 = (double)v43;
  int v38 = 1;
  *(_DWORD *)(a1 + 228) = v42;
  *(_DWORD *)(a1 + 232) = v43;
  int v37 = 8;
LABEL_37:
  unsigned int v44 = *(_DWORD *)(a1 + 572);
  if (v44) {
    unsigned int v45 = *(_DWORD *)(a1 + 576) / v44;
  }
  else {
    unsigned int v45 = 1;
  }
  if (v45 <= 1) {
    unsigned int v46 = 1;
  }
  else {
    unsigned int v46 = v45;
  }
  unsigned int v47 = *(_DWORD *)(a1 + 552);
  if (v46 <= v47) {
    unsigned int v48 = v47 / v46;
  }
  else {
    unsigned int v48 = 1;
  }
  unsigned int v49 = *(_DWORD *)(a1 + 560);
  unint64_t v50 = v49 * (unint64_t)v48;
  if ((v50 & 0xFFFFFFFF00000000) == 0)
  {
    if (v37 || (unsigned int v51 = *(_DWORD *)(a1 + 300), v50 <= v51))
    {
      unsigned int v52 = ((unint64_t)(a6 * (double)v25) + 15) & 0xFFFFFFF0;
      *(_DWORD *)(a1 + 300) = v52;
      uint64_t v75 = (void *)_ImageIO_Malloc(*(unsigned int *)(a1 + 296) * (unint64_t)v52, *(void *)(a1 + 384), &v74, (uint64_t)kImageMalloc_LIBJPEG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
      unsigned int v53 = (char *)v75;
      if (sigsetjmp((int *)(a1 + 9448), 0))
      {
        _cg_jpeg_mem_term("copyImageBlockSetProgressive", 2617, "sigsetjmp\n");
        if (v75 && *(_DWORD *)(a1 + 9312) == 20 && *(_DWORD *)(a1 + 540) == 205) {
          uint64_t v75 = 0;
        }
      }
      else
      {
        _cg_jpeg_destroy_decompress(a1 + 504);
        int v54 = *(_DWORD *)(a1 + 9656);
        _cg_jpeg_CreateDecompress((char *)(a1 + 504), 90, 664);
        *(void *)(a1 + 544) = a1 + 1168;
        _cg_jpeg_read_header(a1 + 504, 1);
        unsigned int v55 = *(unsigned __int16 *)(a1 + 316);
        BOOL v56 = v55 >= 2;
        unsigned int v57 = v55 - 2;
        if (v56)
        {
          *(_DWORD *)(a1 + 600) = 1;
          int v58 = 8;
          *(_DWORD *)(a1 + 576) = 8;
          if (v57 <= 6) {
            int v58 = dword_188991100[(__int16)v57];
          }
          *(_DWORD *)(a1 + 572) = v58;
        }
        *(_DWORD *)(a1 + 568) = v54;
        *(_DWORD *)(a1 + 592) = 1;
        if (*(int *)(a1 + 540) >= 202) {
          _cg_jpeg_start_decompress(a1 + 504);
        }
        if (!*(unsigned char *)(a1 + 9660))
        {
          uint64_t v66 = (unsigned char *)(a1 + 9660);
          while (_cg_jpeg_consume_input((uint64_t *)(a1 + 504)))
          {
            int v67 = *(_DWORD *)(a1 + 540);
            if (v67 == 202)
            {
              if (!_cg_jpeg_start_decompress(a1 + 504)) {
                break;
              }
              int v67 = *(_DWORD *)(a1 + 540);
            }
            if (v67 == 208)
            {
              if (!_cg_jpeg_finish_output(a1 + 504)) {
                break;
              }
              int v67 = *(_DWORD *)(a1 + 540);
            }
            if (v67 == 207)
            {
              if (!_cg_jpeg_start_output(a1 + 504, *(_DWORD *)(a1 + 676))) {
                break;
              }
              int v67 = *(_DWORD *)(a1 + 540);
            }
            if (v67 == 205)
            {
              for (unint64_t i = *(unsigned int *)(a1 + 672); i < *(unsigned int *)(a1 + 644); unint64_t i = *(unsigned int *)(a1 + 672))
              {
                uint64_t v73 = &v53[i * (((unint64_t)(a6 * (double)v25) + 15) & 0xFFFFFFF0)];
                if (!_cg_jpeg_read_scanlines(a1 + 504, (uint64_t)&v73, 1)) {
                  goto LABEL_63;
                }
              }
              _cg_jpeg_finish_output(a1 + 504);
            }
            if (_cg_jpeg_input_complete(a1 + 504))
            {
              if (*(_DWORD *)(a1 + 676) == *(_DWORD *)(a1 + 684))
              {
                *uint64_t v66 = 1;
                _cg_jpeg_destroy_decompress(a1 + 504);
                if (*(void *)(a1 + 1224)) {
                  *(void *)(a1 + 1224) = 0;
                }
              }
            }
            if (*v66) {
              break;
            }
          }
        }
      }
    }
    else
    {
      _cg_jpeg_mem_term("copyImageBlockSetProgressive", 2593, "*** ERROR: unexpected JPEG dimension: %d x %d (%d components) - blockSize: %d x %d (rb: %d)\n", v47, *(_DWORD *)(a1 + 556), v49, *(_DWORD *)(a1 + 292), *(_DWORD *)(a1 + 296), v51);
    }
  }
LABEL_63:
  if (!v75) {
    goto LABEL_69;
  }
  *(_DWORD *)(a1 + 104) = 1;
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, 1uLL);
  BOOL v59 = CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E4F1DB20]);
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  double v62 = v27;
  double v63 = v26;
  if (!v59)
  {
    v77.origin.double x = 0.0;
    v77.origin.double y = 0.0;
    v77.size.double width = v27;
    v77.size.CGFloat height = v26;
    *(CGRect *)&uint64_t v60 = CGRectUnion(*(CGRect *)(a1 + 120), v77);
  }
  *(void *)(a1 + 120) = v60;
  *(void *)(a1 + 128) = v61;
  *(double *)(a1 + 136) = v62;
  *(double *)(a1 + 144) = v63;
  v76.origin.double x = 0.0;
  v76.origin.double y = 0.0;
  v76.size.double width = v27;
  v76.size.CGFloat height = v26;
  **(void **)(a1 + 96) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v75, v74, v76, *(unsigned int *)(a1 + 300), 0);
  if (!a3)
  {
LABEL_69:
    uint64_t v64 = 0;
    if (!v38) {
      goto LABEL_71;
    }
    goto LABEL_70;
  }
  uint64_t v64 = IIOReadPlugin::imageBlockSetCreate(a1, (uint64_t)a3, *(unsigned int *)(a1 + 104), v27, v26, *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(void *)(a1 + 96), v72);
  if (v38)
  {
LABEL_70:
    *(_WORD *)(a1 + 316) = v29;
    *(void *)(a1 + 228) = v30;
  }
LABEL_71:
  if (a3) {
    IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
  }
  return v64;
}

uint64_t LibJPEGReadPlugin::copyImageBlockSetStandard(uint64_t a1, const void *a2, const void *a3, const __CFDictionary *a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  double v16 = a6;
  double v17 = a5;
  int v152 = 0;
  uint64_t v151 = 0;
  memory_object_size_t v150 = 0;
  uint64_t v20 = a1 + 504;
  HIDWORD(a5) = 0;
  long long v148 = 0u;
  long long v149 = 0u;
  if (a3)
  {
    CGImageProviderGetSize();
    double v22 = v21;
    double v24 = v23;
    Pixelunint64_t Size = CGImageProviderGetPixelSize();
  }
  else
  {
    LODWORD(a5) = *(_DWORD *)(a1 + 292);
    double v22 = (double)*(unint64_t *)&a5;
    LODWORD(a6) = *(_DWORD *)(a1 + 296);
    double v24 = (double)*(unint64_t *)&a6;
    if (*(_WORD *)(a1 + 308) == 3)
    {
      if (*(unsigned char *)(a1 + 310)) {
        Pixelunint64_t Size = 4;
      }
      else {
        Pixelunint64_t Size = 3;
      }
    }
    else
    {
      Pixelunint64_t Size = *(unsigned __int16 *)(a1 + 308);
    }
  }
  uint64_t v26 = 0;
  __int16 v27 = 0;
  if (a7 == 0.0)
  {
    BOOL v28 = 0;
    int v29 = 0;
    goto LABEL_165;
  }
  BOOL v28 = 0;
  int v29 = 0;
  if (a8 == 0.0) {
    goto LABEL_165;
  }
  double v136 = a9;
  if (a4)
  {
    CFTypeRef value = 0;
    CFDictionaryGetValueIfPresent(a4, (const void *)*MEMORY[0x1E4F1DD50], (const void **)&value);
    if (value)
    {
      uint64_t v26 = LibJPEGReadPlugin::copyImageBlockSetJPEGTiles(a1, a2, a3, a4, v17, v16, a7, a8, a9, a10);
      if (v26)
      {
        int v29 = 0;
        __int16 v27 = 0;
        BOOL v28 = 0;
        goto LABEL_165;
      }
    }
  }
  double v137 = a10;
  unsigned int v30 = *(unsigned __int16 *)(a1 + 316);
  if (*(unsigned char *)(a1 + 348))
  {
    int v31 = *(unsigned __int16 *)(a1 + 308);
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("RB  multi-res: original subsampleFactor: %d\n", *(unsigned __int16 *)(a1 + 316));
    }
    long long v32 = *(_OWORD *)(a1 + 300);
    long long v148 = *(_OWORD *)(a1 + 284);
    long long v149 = v32;
    if (v30 <= 1) {
      uint64_t v33 = 1;
    }
    else {
      uint64_t v33 = v30;
    }
    uint64_t v34 = v33;
    unint64_t v35 = v33 * (unint64_t)v22;
    unint64_t v36 = v34 * (unint64_t)v24;
    if (a9 > (double)(v35 >> 3) || a10 > (double)(v36 >> 3))
    {
      if (a9 > (double)(v35 >> 2) || a10 > (double)(v36 >> 2))
      {
        if (a9 <= (double)(v35 >> 1) && a10 <= (double)(v36 >> 1) && v30 != 2)
        {
          if ((uint64_t)(v35 + 1) >= 0) {
            uint64_t v40 = v35 + 1;
          }
          else {
            uint64_t v40 = v35 + 2;
          }
          uint64_t v41 = v40 >> 1;
          double v42 = (double)v41;
          if ((uint64_t)(v36 + 1) >= 0) {
            uint64_t v43 = v36 + 1;
          }
          else {
            uint64_t v43 = v36 + 2;
          }
          uint64_t v44 = v43 >> 1;
          double v45 = (double)v44;
          *(_WORD *)(a1 + 316) = 2;
          *(_DWORD *)(a1 + 292) = v41;
          *(_DWORD *)(a1 + 296) = v44;
          *(_DWORD *)(a1 + 300) = ((v41 << (2 * (v31 != 1))) + 15) & 0xFFFFFFF0;
          if ((gIIODebugFlags & 0x30000) != 0) {
            ImageIOLog("RB  multi-res: new subsampleFactor 2:  rb=%d\n");
          }
          goto LABEL_58;
        }
      }
      else if (v30 != 4)
      {
        uint64_t v53 = v35 + 3;
        uint64_t v54 = v35 + 6;
        if (v53 >= 0) {
          uint64_t v54 = v53;
        }
        uint64_t v55 = v36 + 3;
        uint64_t v56 = v36 + 6;
        if (v55 >= 0) {
          uint64_t v56 = v55;
        }
        uint64_t v57 = v54 >> 2;
        double v42 = (double)v57;
        uint64_t v58 = v56 >> 2;
        double v45 = (double)v58;
        *(_WORD *)(a1 + 316) = 4;
        *(_DWORD *)(a1 + 292) = v57;
        *(_DWORD *)(a1 + 296) = v58;
        *(_DWORD *)(a1 + 300) = ((v57 << (2 * (v31 != 1))) + 15) & 0xFFFFFFF0;
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("RB  multi-res: new subsampleFactor 4:  rb=%d\n");
        }
        goto LABEL_58;
      }
    }
    else if (v30 != 8)
    {
      uint64_t v46 = v35 + 7;
      uint64_t v47 = v35 + 14;
      if (v46 >= 0) {
        uint64_t v47 = v46;
      }
      uint64_t v48 = v36 + 7;
      uint64_t v49 = v36 + 14;
      if (v48 >= 0) {
        uint64_t v49 = v48;
      }
      uint64_t v50 = v47 >> 3;
      double v42 = (double)v50;
      uint64_t v51 = v49 >> 3;
      double v45 = (double)v51;
      *(_WORD *)(a1 + 316) = 8;
      *(_DWORD *)(a1 + 292) = v50;
      *(_DWORD *)(a1 + 296) = v51;
      *(_DWORD *)(a1 + 300) = ((v50 << (2 * (v31 != 1))) + 15) & 0xFFFFFFF0;
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("RB  multi-res: new subsampleFactor 8:  rb=%d\n");
      }
LABEL_58:
      int v52 = 1;
      goto LABEL_59;
    }
  }
  int v52 = 0;
  double v45 = v24;
  double v42 = v22;
LABEL_59:
  int v59 = v52;
  __int16 v27 = v30;
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, v17, v16, a7, a8, v136, v137);
  CGImageProviderGetPixelSize();
  if ((ImageIOShouldAllowFullsizeDecode() & 1) == 0 && *(unsigned char *)(a1 + 408) == 1)
  {
    _cg_jpeg_mem_term("copyImageBlockSetStandard", 2902, "Rejecting singleton request - image is too large");
    goto LABEL_180;
  }
  *(_DWORD *)(a1 + 300) = ((unint64_t)(v42 * (double)PixelSize) + 15) & 0xFFFFFFF0;
  int v60 = *(_DWORD *)(a1 + 112);
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("                      blockSize: {%d, %d}\n", *(_DWORD *)(a1 + 292), *(_DWORD *)(a1 + 296));
  }
  if (sigsetjmp((int *)(a1 + 9448), 0))
  {
    _cg_jpeg_mem_term("copyImageBlockSetStandard", 2927, "sigsetjmp");
    goto LABEL_65;
  }
  unsigned int v62 = *(_DWORD *)(a1 + 572);
  if (v62) {
    unsigned int v63 = *(_DWORD *)(a1 + 576) / v62;
  }
  else {
    unsigned int v63 = 1;
  }
  if (v63 <= 1) {
    unsigned int v64 = 1;
  }
  else {
    unsigned int v64 = v63;
  }
  uint64_t v65 = *(unsigned int *)(a1 + 552);
  if (v64 <= v65) {
    unsigned int v66 = v65 / v64;
  }
  else {
    unsigned int v66 = 1;
  }
  unint64_t v67 = *(unsigned int *)(a1 + 560) * (unint64_t)v66;
  if ((v67 & 0xFFFFFFFF00000000) != 0)
  {
LABEL_180:
    uint64_t v26 = 0;
    BOOL v28 = 0;
    goto LABEL_164;
  }
  if (v67 > *(_DWORD *)(a1 + 300) && *(unsigned __int16 *)(a1 + 316) <= 1u)
  {
    _cg_jpeg_mem_term("copyImageBlockSetStandard", 2942, "*** ERROR: unexpected JPEG dimension: %d x %d (%d components) - blockSize: %d x %d (rb: %d)\n", v65);
LABEL_65:
    BOOL v61 = 0;
LABEL_66:
    if (!v152)
    {
      uint64_t v26 = 0;
      BOOL v28 = v61;
      goto LABEL_164;
    }
    _ImageIO_Free((unint64_t)v152, v150);
    BOOL v28 = v61;
    int v29 = v59;
    uint64_t v26 = 0;
    goto LABEL_165;
  }
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
  if (!IIOReadPlugin::getCachedBlocks((IIOReadPlugin *)a1, v68, v69, v70))
  {
    BOOL v73 = 0;
    goto LABEL_160;
  }
  unint64_t v71 = *(IIOImageRead ***)(a1 + 24);
  if (v71) {
    BOOL v72 = IIOImageReadSession::mapData(v71);
  }
  else {
    BOOL v72 = 0;
  }
  BOOL v74 = v72;
  _cg_jpeg_destroy_decompress(v20);
  LibJPEGReadPlugin::startDecompressing(a1, *(_DWORD *)(a1 + 9656));
  *(void *)(a1 + 9648) = -1;
  if (*(_DWORD *)(a1 + 540) != 205)
  {
    uint64_t v26 = 0;
    *(_DWORD *)(a1 + 104) = 0;
    BOOL v28 = v74;
    goto LABEL_164;
  }
  uint64_t v151 = malloc_type_malloc(*(unsigned int *)(a1 + 236), 0xD9BBBB4uLL);
  int v76 = *(_DWORD *)(a1 + 112);
  int v142 = v60;
  if (v76)
  {
    int v77 = *(_DWORD *)(a1 + 296) * v76;
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    skipping rows %4d through %4d\n", 0, v77);
    }
    if (v77)
    {
      int v143 = v59;
      for (int i = 0; i != v77; ++i)
      {
        int scanlines = _cg_jpeg_read_scanlines(v20, (uint64_t)&v151, 1);
        BOOL v80 = scanlines == 1;
        if (scanlines != 1) {
          _cg_jpeg_mem_term("copyImageBlockSetStandard", 2991, "*** jpeg_read_scanlines at row %d\n", i);
        }
      }
      char v81 = v80;
      int v59 = v143;
      int v60 = v142;
    }
    else
    {
      char v81 = 0;
    }
  }
  else
  {
    char v81 = 0;
  }
  uint64_t v146 = v20;
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    ImageIOLog("                     startBlock: %d\n", *(_DWORD *)(a1 + 112));
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("                       endBlock: %d\n", *(_DWORD *)(a1 + 116));
    }
  }
  unsigned int v82 = *(_DWORD *)(a1 + 112);
  if (v82 >= *(_DWORD *)(a1 + 116))
  {
LABEL_143:
    BOOL v73 = v74;
    uint64_t v20 = v146;
    goto LABEL_160;
  }
  uint64_t v83 = 0;
  uint64_t v84 = *(unsigned int *)(a1 + 112);
  int v144 = v59;
  __int16 v145 = v27;
  BOOL v141 = v74;
  while (1)
  {
    char v85 = v81;
    uint64_t v86 = v84;
    unsigned int v140 = v82;
    int v87 = v84;
    uint64_t v88 = (v84 - v60);
    uint64_t v89 = v88;
    if (*(void *)(*(void *)(a1 + 96) + 8 * v88)) {
      _cg_jpeg_mem_term("copyImageBlockSetStandard", 3015, "*** _blockArray[%d] was cached - and already allocated\n", v88);
    }
    uint64_t v138 = v89;
    unsigned int v90 = *(_DWORD *)(a1 + 296);
    unsigned int v91 = v90 * v87;
    double v92 = (double)(v90 * v87);
    LODWORD(v75) = *(_DWORD *)(a1 + 556);
    double v93 = (double)v75;
    if ((double)v90 + v92 <= v93) {
      double v94 = (double)v90;
    }
    else {
      double v94 = v93 - (double)v91;
    }
    unint64_t v95 = *(int *)(a1 + 648);
    if (!is_mul_ok(*(unsigned int *)(a1 + 640), v95)
      || (unint64_t v96 = *(unsigned int *)(a1 + 640) * v95, v97 = *(unsigned int *)(a1 + 644), !is_mul_ok(v97, v96)))
    {
      uint64_t v26 = 0;
      BOOL v28 = v141;
      int v29 = v144;
      __int16 v27 = v145;
      uint64_t v20 = v146;
      goto LABEL_165;
    }
    int v98 = *(_DWORD *)(a1 + 296);
    int v99 = a2;
    int v100 = *(_DWORD *)(a1 + 292);
    unint64_t v101 = *(unsigned int *)(a1 + 300) * (unint64_t)v90;
    memory_object_size_t v102 = v97 * v96;
    if (v97 * v96 <= v101) {
      memory_object_size_t v102 = *(unsigned int *)(a1 + 300) * (unint64_t)v90;
    }
    else {
      _cg_jpeg_mem_term("copyImageBlockSetStandard", 3037, "*** ERROR: libJPEGBufferSize > imageDataBufferSize   (%lld > %lld)\n", v102, v101);
    }
    int v152 = (char *)_ImageIO_Malloc(v102, *(void *)(a1 + 384), &v150, (uint64_t)kImageMalloc_LIBJPEG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
    if (!v152)
    {
      BOOL v61 = v141;
      uint64_t v20 = v146;
      int v59 = v144;
      __int16 v27 = v145;
      goto LABEL_66;
    }
    int v135 = v87;
    char v103 = v85;
    uint64_t v139 = v86;
    uint64_t v104 = v152;
    double v105 = v94 + v92;
    unsigned int v106 = (v94 + v92);
    if (*(unsigned __int16 *)(a1 + 316) >= 2u)
    {
      if (*(_DWORD *)(a1 + 644) >= (v94 + v92)) {
        unsigned int v106 = (v94 + v92);
      }
      else {
        unsigned int v106 = *(_DWORD *)(a1 + 644);
      }
    }
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("                   reading rows: %d ... %d\n", v91, v106 - 1);
    }
    LODWORD(v105) = v100;
    double v107 = (double)*(unint64_t *)&v105;
    if (v91 >= v106)
    {
      uint64_t v114 = v83;
      a2 = v99;
      BOOL v74 = v141;
      int v60 = v142;
      if ((v103 & 1) == 0) {
        goto LABEL_145;
      }
LABEL_134:
      unint64_t v115 = *(unsigned int *)(a1 + 300);
      uint64_t v116 = v114;
      goto LABEL_137;
    }
    unint64_t v108 = (unint64_t)&v104[v102];
    unint64_t v109 = *(unsigned int *)(a1 + 300);
    CFTypeRef value = v152;
    if ((unint64_t)v152 < v108) {
      break;
    }
    char v113 = v103;
LABEL_136:
    a2 = v99;
    BOOL v74 = v141;
    int v60 = v142;
    uint64_t v116 = v83;
    unint64_t v115 = v109;
    if ((v113 & 1) == 0) {
      goto LABEL_145;
    }
LABEL_137:
    uint64_t v83 = v116;
    v153.origin.double x = 0.0;
    v153.origin.double y = (double)v91;
    v153.size.double width = v107;
    v153.size.CGFloat height = v94;
    *(void *)(*(void *)(a1 + 96) + 8 * v138) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v152, v150, v153, v115, *(unsigned __int8 *)(a1 + 343));
    int v59 = v144;
    __int16 v27 = v145;
    if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E4F1DB20]))
    {
      uint64_t v117 = 0;
    }
    else
    {
      v155.origin.double x = 0.0;
      v155.origin.double y = v92;
      v155.size.double width = v107;
      v155.size.CGFloat height = v94;
      *(CGRect *)(&v75 - 2) = CGRectUnion(*(CGRect *)(a1 + 120), v155);
      double v92 = v118;
      double v107 = *(double *)&v75;
      double v94 = v119;
    }
    *(void *)(a1 + 120) = v117;
    *(double *)(a1 + 128) = v92;
    *(double *)(a1 + 136) = v107;
    *(double *)(a1 + 144) = v94;
    uint64_t v84 = v139 + 1;
    unsigned int v82 = v140 + 1;
    char v81 = 1;
    if (v139 + 1 >= (unint64_t)*(unsigned int *)(a1 + 116)) {
      goto LABEL_143;
    }
  }
  uint64_t v110 = 1;
  while (_cg_jpeg_read_scanlines(v146, (uint64_t)&value, 1) == 1)
  {
    if (*(unsigned char *)(a1 + 341))
    {
      uint64_t v111 = *(void *)(a1 + 16);
      if (v111) {
        IIOImagePlus::setStatus(v111, (CGImageSourceStatus)-6);
      }
      *(unsigned char *)(a1 + 343) = 0;
    }
    if (v98 * v140 + v110 >= v106)
    {
      uint64_t v114 = v106 - 1;
      a2 = v99;
      BOOL v74 = v141;
      int v60 = v142;
      goto LABEL_134;
    }
    unint64_t v109 = *(unsigned int *)(a1 + 300);
    CFTypeRef value = &v152[v110 * v109];
    int v112 = ++v110;
    if ((unint64_t)value >= v108)
    {
      uint64_t v83 = v112 + v98 * v140 - 2;
      char v113 = 1;
      goto LABEL_136;
    }
  }
  LODWORD(v83) = v110 + v98 * v140 - 1;
  a2 = v99;
  BOOL v74 = v141;
LABEL_145:
  int v120 = v83;
  BOOL v73 = v74;
  if (v83 <= v91) {
    unsigned int v121 = 0;
  }
  else {
    unsigned int v121 = v91;
  }
  if ((v135 + 1) < *(_DWORD *)(a1 + 116)) {
    *(_DWORD *)(a1 + 104) = v135 + 1 - *(_DWORD *)(a1 + 112);
  }
  uint64_t v20 = v146;
  int v59 = v144;
  __int16 v27 = v145;
  if (v120 == v121)
  {
    int v122 = *(_DWORD *)(a1 + 104);
    if (v122) {
      *(_DWORD *)(a1 + 104) = v122 - 1;
    }
    _ImageIO_Free((unint64_t)v152, v150);
    int v152 = 0;
  }
  else
  {
    uint64_t v123 = v120 - v121;
    double v124 = (double)v123;
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("                     valid rows: %ld\n", v123);
    }
    v154.origin.double x = 0.0;
    v154.origin.double y = v92;
    v154.size.double width = v107;
    v154.size.CGFloat height = v124;
    *(void *)(*(void *)(a1 + 96) + 8 * v138) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v152, v150, v154, *(unsigned int *)(a1 + 300), 0);
    if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E4F1DB20]))
    {
      uint64_t v125 = 0;
    }
    else
    {
      v156.origin.double x = 0.0;
      v156.origin.double y = v92;
      v156.size.double width = v107;
      v156.size.CGFloat height = v124;
      *(CGRect *)&uint64_t v125 = CGRectUnion(*(CGRect *)(a1 + 120), v156);
      double v92 = v126;
      double v107 = v127;
      double v124 = v128;
    }
    *(void *)(a1 + 120) = v125;
    *(double *)(a1 + 128) = v92;
    *(double *)(a1 + 136) = v107;
    *(double *)(a1 + 144) = v124;
  }
LABEL_160:
  uint64_t v26 = 0;
  if (a3 && *(_DWORD *)(a1 + 104)) {
    uint64_t v26 = IIOReadPlugin::imageBlockSetCreate(a1, (uint64_t)a3, *(unsigned int *)(a1 + 104), v42, v45, *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(void *)(a1 + 96), a2);
  }
  BOOL v28 = v73;
LABEL_164:
  int v29 = v59;
LABEL_165:
  uint64_t v129 = v26;
  int v130 = v29;
  BOOL v131 = v28;
  _cg_jpeg_destroy_decompress(v20);
  if (v151) {
    free(v151);
  }
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("<<< copyImageBlockSetJPEG\n\n");
  }
  if (a3) {
    IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
  }
  if (v130)
  {
    long long v132 = v149;
    *(_OWORD *)(a1 + 284) = v148;
    *(_OWORD *)(a1 + 300) = v132;
    *(_WORD *)(a1 + 316) = v27;
  }
  if (v131)
  {
    uint64_t v133 = *(const char ***)(a1 + 24);
    if (v133) {
      IIOImageReadSession::unmapData(v133);
    }
  }
  return v129;
}

uint64_t LibJPEGReadPlugin::copyImageBlockSetImp(uint64_t a1, const void *a2, const void *a3, uint64_t a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  *(unsigned char *)(a1 + 343) = 0;
  if (a4) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 448) == 2) {
    return LibJPEGReadPlugin::copyImageBlockSetProgressive(a1, a2, a3, a5, a6, a7, a8, a9, a10);
  }
  return LibJPEGReadPlugin::copyImageBlockSetStandard(a1, a2, a3, 0, a5, a6, a7, a8, a9, a10);
}

void sub_18874F064(void *a1)
{
}

uint64_t LibJPEGReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v10 = *((_DWORD *)this + 51);
    unsigned int v11 = v10 >> 24;
    uint64_t v12 = MEMORY[0x1E4F14390];
    if (v10 < 0)
    {
      int v13 = __maskrune(v11, 0x40000uLL);
      int v10 = *((_DWORD *)this + 51);
    }
    else
    {
      int v13 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v11 + 60) & 0x40000;
    }
    if (v13) {
      uint64_t v14 = (v10 >> 24);
    }
    else {
      uint64_t v14 = 46;
    }
    unsigned int v15 = v10 << 8 >> 24;
    if (v10 << 8 < 0)
    {
      int v16 = __maskrune(v15, 0x40000uLL);
      int v10 = *((_DWORD *)this + 51);
    }
    else
    {
      int v16 = *(_DWORD *)(v12 + 4 * v15 + 60) & 0x40000;
    }
    if (v16) {
      uint64_t v17 = (v10 << 8 >> 24);
    }
    else {
      uint64_t v17 = 46;
    }
    unsigned int v18 = (__int16)v10 >> 8;
    if (v10 << 16 < 0)
    {
      int v19 = __maskrune(v18, 0x40000uLL);
      int v10 = *((_DWORD *)this + 51);
    }
    else
    {
      int v19 = *(_DWORD *)(v12 + 4 * v18 + 60) & 0x40000;
    }
    if (v19) {
      uint64_t v20 = ((__int16)v10 >> 8);
    }
    else {
      uint64_t v20 = 46;
    }
    if ((v10 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v12 + 4 * (char)v10 + 60) & 0x40000) != 0) {
        goto LABEL_22;
      }
    }
    else if (__maskrune((char)v10, 0x40000uLL))
    {
LABEL_22:
      uint64_t v21 = *((char *)this + 204);
LABEL_25:
      ImageIOLog("  '%c%c%c%c' [%s] %s\n", v14, v17, v20, v21, iioTypeStr[a3], "virtual OSStatus LibJPEGReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    uint64_t v21 = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  if (a3 != 3) {
    return 4294967246;
  }
  uint64_t v22 = *((void *)a2 + 1);
  uint64_t v23 = *((void *)a2 + 2);
  double v24 = *((double *)a2 + 3);
  double v25 = *((double *)a2 + 4);
  double v26 = *((double *)a2 + 5);
  double v27 = *((double *)a2 + 6);
  double v28 = *((double *)a2 + 7);
  double v29 = *((double *)a2 + 8);
  Xmpuint64_t Data = _APP1XMP::getXmpData(a2);
  uint64_t v31 = (*(uint64_t (**)(IIOReadPlugin *, uint64_t, uint64_t, uint64_t, double, double, double, double, double, double))(*(void *)this + 208))(this, v22, v23, XmpData, v24, v25, v26, v27, v28, v29);
  if (!a6) {
    return 4294967246;
  }
  uint64_t v32 = v31;
  uint64_t result = 0;
  *a6 = v32;
  return result;
}

const char *___ZL9GetCIProcv_block_invoke()
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  strcpy(__path, "/System/Library/Frameworks/QuartzCore.framework/QuartzCore");
  vImage_Error v0 = dlopen(__path, 257);
  if (v0)
  {
    uint64_t result = (const char *)dlsym(v0, "CICreateCGImageRefFromYCbCrData");
    g_ciGetCGImageRefFromYCbCruint64_t Data = (uint64_t (*)(void, void, void, void, void, double, double))result;
  }
  else
  {
    uint64_t v2 = dlerror();
    return LogError("GetCIProc_block_invoke", 573, "cannot access 'QuartzCore.framework' - %s\n", v2);
  }
  return result;
}

unint64_t *unpack_etc2_block(unint64_t *result, uint64_t a2)
{
  unint64_t v2 = *result;
  HIDWORD(v17) = HIDWORD(*result);
  unsigned int v3 = v2 >> 25;
  *(_DWORD *)a2 = 0;
  *(unsigned char *)(a2 + 11) = (v2 & 0x2000000) != 0;
  *(unsigned char *)(a2 + 10) = BYTE3(v2) & 1;
  *(unsigned char *)(a2 + 8) = v2 >> 29;
  *(unsigned char *)(a2 + 9) = (v2 >> 26) & 7;
  if (((v2 >> 25) & 1) == 0)
  {
    uint32x2_t v4 = (uint32x2_t)vdup_n_s32(v2);
    v5.i32[0] = v2 >> 20;
    v5.i32[1] = WORD1(v2);
    int8x8_t v6 = vorr_s8(vorr_s8(vand_s8((int8x8_t)vshl_u32(v4, (uint32x2_t)0x800000004), (int8x8_t)0xF0000000F00), vand_s8((int8x8_t)vshl_u32(v4, (uint32x2_t)0xFFFFFFFCFFFFFFF8), (int8x8_t)0xF0000000F0)), vand_s8(v5, (int8x8_t)0xF0000000FLL));
    *(_WORD *)(a2 + 6) = v6.i16[2];
    *(_WORD *)(a2 + 4) = v6.i16[0];
LABEL_3:
    int v7 = 1;
    goto LABEL_21;
  }
  *(_WORD *)(a2 + 4) = ((_WORD)v2 << 7) & 0x7C00 | ((unsigned __int16)v2 >> 6) & 0xFFE0 | (v2 >> 19) & 0x1F;
  *(_WORD *)(a2 + 6) = ((_WORD)v2 << 6) & 0x1C0 | (v2 >> 5) & 0x38 | BYTE2(v2) & 7;
  if ((v2 & 4) != 0) {
    int v8 = -8;
  }
  else {
    int v8 = 0;
  }
  if ((v2 & 0x40000) != 0) {
    int v9 = -8;
  }
  else {
    int v9 = 0;
  }
  if ((v2 >> 3) + (v2 & 7) + v8 <= 0x1F)
  {
    if (((v2 >> 8) & 4) != 0) {
      int v11 = -8;
    }
    else {
      int v11 = 0;
    }
    if (((unsigned __int16)v2 >> 11) + ((v2 >> 8) & 7) + v11 <= 0x1F)
    {
      if (((v2 >> 19) & 0x1F) + (WORD1(v2) & 7) + v9 > 0x1F)
      {
        *(_DWORD *)a2 = 3;
        *(unsigned char *)(a2 + 4) = (v2 >> 1) & 0x3F;
        *(unsigned char *)(a2 + 5) = ((_BYTE)v2 << 6) & 0x40 | (v2 >> 9) & 0x3F;
        *(unsigned char *)(a2 + 6) = BYTE2(v2) & 0x18 | ((v2 & 0x80000000) != 0) | (v2 >> 3) & 0x20 | (v2 >> 15) & 6;
        *(unsigned char *)(a2 + 7) = v3 & 0x3E | BYTE3(v2) & 1;
        *(unsigned char *)(a2 + 8) = (v2 >> 33) & 0x7F;
        *(unsigned char *)(a2 + 9) = (v2 >> 27) & 0x20 | (v2 >> 43) & 0x1F;
        *(unsigned char *)(a2 + 10) = (v2 >> 37) & 0x38 | (v2 >> 53) & 7;
        *(unsigned char *)(a2 + 11) = (v2 >> 46) & 0x7C | (v2 >> 62);
        *(unsigned char *)(a2 + 12) = HIBYTE(v2) & 0x3F;
        return result;
      }
      goto LABEL_3;
    }
    *(_DWORD *)a2 = 2;
    unsigned int v12 = (32 * v2) & 0xF00 | (16 * ((v2 >> 12) & 1 | (2 * (v2 & 7)))) | (v2 >> 8) & 8 | (v2 >> 7) & 6 | (v2 >> 23) & 1;
    *(_WORD *)(a2 + 4) = (32 * v2) & 0xF00 | (16 * ((v2 >> 12) & 1 | (2 * (v2 & 7)))) | (v2 >> 8) & 8 | (v2 >> 7) & 6 | (v2 >> 23) & 1;
    unsigned int v13 = (v2 >> 11) & 0xF00 | (16 * ((v2 >> 15) & 0xE | (v2 >> 31))) | (v2 >> 27) & 0xF;
    *(_WORD *)(a2 + 6) = (v2 >> 11) & 0xF00 | (16
                                                           * ((v2 >> 15) & 0xE | (v2 >> 31))) | (v2 >> 27) & 0xF;
    unsigned int v14 = BYTE3(v2) & 4 | (v2 >> 23) & 2;
    *(unsigned char *)(a2 + 8) = v14;
    if (v12 >= v13)
    {
      int v7 = 0;
      *(unsigned char *)(a2 + 8) = v14 | 1;
    }
    else
    {
      int v7 = 0;
    }
  }
  else
  {
    int v7 = 0;
    *(_DWORD *)a2 = 1;
    HIDWORD(v10) = v2 & 3 | (4 * ((v2 >> 3) & 3));
    LODWORD(v10) = v2 << 16;
    *(_WORD *)(a2 + 4) = v10 >> 24;
    *(_WORD *)(a2 + 6) = (v2 >> 12) & 0xFF0 | (v2 >> 28);
    *(unsigned char *)(a2 + 8) = v3 & 6 | BYTE3(v2) & 1;
  }
LABEL_21:
  for (uint64_t i = 0; i != 16; ++i)
  {
    uint64_t v16 = (((unsigned __int8 *)&v17 - (i >> 3))[7] >> (i & 7)) & 1 | (2
                                                                                  * ((((unsigned __int8 *)&v17
                                                                                     - (i >> 3))[5] >> (i & 7)) & 1u));
    if (v7) {
      LOBYTE(v16) = etc_selector_unscramble[v16];
    }
    *(unsigned char *)(a2 + 14 + i) = v16;
  }
  return result;
}

void decode_etc2(uint64_t a1, __n128 *a2, int32x4_t a3, int32x4_t a4, double a5, __n128 a6)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  int8x8_t v6 = a2;
  switch(*(_DWORD *)a1)
  {
    case 0:
      unsigned long long v101 = 0u;
      unsigned long long v102 = 0u;
      if (*(unsigned char *)(a1 + 11))
      {
        unint64_t v8 = *(unsigned __int8 *)(a1 + 8);
        if (v8 >= 8) {
          decode_etc2();
        }
        unsigned int v9 = *(unsigned __int16 *)(a1 + 4);
        int32x2_t v10 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v9), (uint32x2_t)0xFFFFFFF6FFFFFFFBLL), (int8x8_t)0x1F0000001FLL);
        v11.i64[0] = 0xFF000000FFLL;
        v11.i64[1] = 0xFF000000FFLL;
        unsigned long long v101 = *(_OWORD *)&vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(vaddq_s32(vdupq_n_s32((8 * v10.i32[0]) | ((unsigned __int32)v10.i32[0] >> 2)), etc_intensity_modifiers[v8]), (int32x4_t)0), v11), 0x10uLL), (int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(vaddq_s32(vdupq_n_s32((v9 >> 2) & 7 | (8 * (v9 & 0x1F))), etc_intensity_modifiers[v8]), (int32x4_t)0), v11), 0x18uLL)),
                             (int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(vaddq_s32(vdupq_n_s32((8 * v10.i32[1]) | ((unsigned __int32)v10.i32[1] >> 2)), etc_intensity_modifiers[v8]), (int32x4_t)0), v11), 8uLL)) | __PAIR128__(0xFF000000FFLL, 0xFF000000FFLL);
        unint64_t v12 = *(unsigned __int8 *)(a1 + 9);
        if (v12 >= 8) {
          decode_etc2();
        }
        int v13 = v9 & 0x1F;
        unsigned int v14 = *(unsigned __int16 *)(a1 + 6);
        if ((v14 & 4) != 0) {
          int v15 = -8;
        }
        else {
          int v15 = 0;
        }
        int8x8_t v16 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v14), (uint32x2_t)0xFFFFFFFAFFFFFFFDLL), (int8x8_t)0x700000007);
        int32x2_t v17 = vadd_s32((int32x2_t)vorr_s8((int8x8_t)(*(void *)&vcgt_u32((uint32x2_t)v16, (uint32x2_t)0x300000003) & 0xFFFFFFF8FFFFFFF8), v16), v10);
        int v18 = (v15 & 0xFFFFFFF8 | v14 & 7) + v13;
        if ((v17.i32[0] | v18 | v17.i32[1]) >= 0x20)
        {
          int32x2_t v17 = vmin_s32(vmax_s32(v17, 0), (int32x2_t)0x1F0000001FLL);
          v18 &= ~(v18 >> 31);
          if (v18 >= 31) {
            int v18 = 31;
          }
        }
        unsigned int v19 = (8 * v17.i32[0]) | (v17.i32[0] >> 2);
        int32x4_t v23 = etc_intensity_modifiers[v12];
        int32x4_t v20 = vaddq_s32(v23, vdupq_n_s32((8 * v17.i32[1]) | ((unsigned __int32)v17.i32[1] >> 2)));
        int32x4_t v21 = vaddq_s32(v23, vdupq_n_s32(v19));
        int32x4_t v22 = vaddq_s32(v23, vdupq_n_s32((8 * v18) | (v18 >> 2)));
        v23.i32[3] = 0;
        v24.i64[0] = 0xFF000000FFLL;
        v24.i64[1] = 0xFF000000FFLL;
        unsigned long long v102 = *(_OWORD *)&vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(v21, (int32x4_t)0), v24), 0x10uLL), (int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(v22, (int32x4_t)0), v24), 0x18uLL)), (int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(v20, (int32x4_t)0), v24), 8uLL)) | __PAIR128__(0xFF000000FFLL, 0xFF000000FFLL);
      }
      else
      {
        get_abs_subblock_palette(*(unsigned __int16 *)(a1 + 4), *(unsigned __int8 *)(a1 + 8), (__n128 *)&v101);
        get_abs_subblock_palette(*(unsigned __int16 *)(a1 + 6), *(unsigned __int8 *)(a1 + 9), (__n128 *)&v102);
      }
      uint64_t v91 = 0;
      uint64_t v92 = 14;
      v93.i64[0] = 0xFF000000FFLL;
      v93.i64[1] = 0xFF000000FFLL;
      float32x4_t v94 = (float32x4_t)vdupq_n_s32(0x3B808081u);
      do
      {
        uint64_t v95 = 0;
        uint64_t v96 = v92;
        do
        {
          if (*(_DWORD *)a1) {
            decode_etc2();
          }
          if (*(unsigned char *)(a1 + 10)) {
            int v97 = v91;
          }
          else {
            int v97 = v95;
          }
          unsigned int v98 = *((_DWORD *)&v101 + 4 * ((v97 & 0xFFFFFFFE) != 0) + *(unsigned __int8 *)(a1 + v96));
          *(uint32x2_t *)v23.i8 = vshl_u32((uint32x2_t)vdup_n_s32(v98), (uint32x2_t)0xFFFFFFF0FFFFFFF8);
          v23.i32[2] = v98;
          uint32x4_t v99 = vshrq_n_u32((uint32x4_t)v23, 0x18uLL);
          v23.i32[3] = v98;
          int32x4_t v100 = (int32x4_t)vandq_s8((int8x16_t)v23, v93);
          v100.i32[2] = v99.i32[2];
          int32x4_t v23 = (int32x4_t)vmulq_f32(vcvtq_f32_s32(v100), v94);
          v6[v95++] = (__n128)v23;
          v96 += 4;
        }
        while (v95 != 4);
        ++v91;
        ++v92;
        v6 += 4;
      }
      while (v91 != 4);
      break;
    case 1:
      uint64_t v25 = 0;
      int v26 = etc_th_distances[*(unsigned __int8 *)(a1 + 8)];
      unsigned int v27 = *(unsigned __int16 *)(a1 + 4);
      unsigned int v28 = (v27 >> 4 << 16) & 0xFF0FFFFF | (v27 >> 4 << 20) | (((v27 >> 8) & 0xF) << 8) & 0xFFFF0FFF | (((v27 >> 8) & 0xF) << 12) | ((v27 & 0xF) << 24) | (v27 << 28);
      unsigned int v29 = *(unsigned __int16 *)(a1 + 6);
      int v30 = (v29 >> 8) & 0xF | (16 * ((v29 >> 8) & 0xF));
      int v31 = (v29 >> 4) | (16 * (v29 >> 4));
      int v32 = v29 & 0xF | (16 * (v29 & 0xF));
      int v33 = (v30 + v26) & ~((v30 + v26) >> 31);
      if (v33 >= 255) {
        int v33 = 255;
      }
      int v34 = (v31 + v26) & ~((v31 + v26) >> 31);
      if (v34 >= 255) {
        int v34 = 255;
      }
      int v35 = (v34 << 16) | (v33 << 8);
      int v36 = (v32 + v26) & ~((v32 + v26) >> 31);
      if (v36 >= 255) {
        int v36 = 255;
      }
      LODWORD(v101) = v28 | 0xFF;
      DWORD1(v101) = v35 | (v36 << 24) | 0xFF;
      int v37 = (v30 << 8) | (v31 << 16) | (v32 << 24) | 0xFF;
      int v38 = v30 - v26;
      int v39 = v31 - v26;
      int v40 = v32 - v26;
      int v41 = v38 & ~(v38 >> 31);
      if (v41 >= 255) {
        int v41 = 255;
      }
      int v42 = v39 & ~(v39 >> 31);
      if (v42 >= 255) {
        int v42 = 255;
      }
      int v43 = (v42 << 16) | (v41 << 8);
      int v44 = v40 & ~(v40 >> 31);
      if (v44 >= 255) {
        int v44 = 255;
      }
      DWORD2(v101) = v37;
      HIDWORD(v101) = v43 | (v44 << 24) | 0xFF;
      uint64_t v45 = a1 + 14;
      v46.i64[0] = 0xFF000000FFLL;
      v46.i64[1] = 0xFF000000FFLL;
      float32x4_t v47 = (float32x4_t)vdupq_n_s32(0x3B808081u);
      do
      {
        uint64_t v48 = 0;
        uint64_t v49 = v6;
        do
        {
          a6.n128_u64[0] = (unint64_t)vshl_u32((uint32x2_t)vdup_n_s32(*((_DWORD *)&v101 + *(unsigned __int8 *)(v45 + v48))), (uint32x2_t)0xFFFFFFF0FFFFFFF8);
          a6.n128_u32[2] = *((_DWORD *)&v101 + *(unsigned __int8 *)(v45 + v48));
          uint32x4_t v50 = vshrq_n_u32((uint32x4_t)a6, 0x18uLL);
          a6.n128_u32[3] = a6.n128_u32[2];
          int32x4_t v51 = (int32x4_t)vandq_s8((int8x16_t)a6, v46);
          v51.i32[2] = v50.i32[2];
          a6 = (__n128)vmulq_f32(vcvtq_f32_s32(v51), v47);
          *v49++ = a6;
          v48 += 4;
        }
        while (v48 != 16);
        ++v25;
        ++v45;
        v6 += 4;
      }
      while (v25 != 4);
      break;
    case 2:
      uint64_t v52 = 0;
      uint64_t v53 = (const float *)&etc_th_distances[*(unsigned __int8 *)(a1 + 8)];
      a3.i32[0] = *(unsigned __int16 *)(a1 + 4);
      a4.i32[0] = a3.i32[0];
      a4.i32[1] = *(unsigned __int16 *)(a1 + 6);
      a3.i32[1] = a4.i32[1];
      v54.i64[0] = 0xF0000000FLL;
      v54.i64[1] = 0xF0000000FLL;
      uint16x4_t v55 = (uint16x4_t)vmovn_s32((int32x4_t)vandq_s8((int8x16_t)vshlq_u32((uint32x4_t)vzip1q_s32(a3, a3), (uint32x4_t)xmmword_188991150), v54));
      int32x4_t v60 = (int32x4_t)vmull_u16(v55, (uint16x4_t)0x11001100110011);
      *(int32x2_t *)a4.i8 = vmul_s32((int32x2_t)vand_s8(*(int8x8_t *)a4.i8, (int8x8_t)0xF0000000FLL), (int32x2_t)0x1100000011);
      int32x4_t v56 = vzip1q_s32(a4, a4);
      int32x4_t v57 = vrev64q_s32(v60);
      int32x4_t v58 = (int32x4_t)vld1q_dup_f32(v53);
      int32x4_t v59 = vtrn2q_s32(vrev64q_s32((int32x4_t)vmlal_u16((uint32x4_t)v58, v55, (uint16x4_t)0x11001100110011)), vsubq_s32(v60, v58));
      v60.i32[3] = 0;
      v61.i64[0] = 0xFF000000FFLL;
      v61.i64[1] = 0xFF000000FFLL;
      unsigned long long v101 = *(_OWORD *)&vorrq_s8(vorrq_s8((int8x16_t)vshlq_u32((uint32x4_t)vminq_s32(vmaxq_s32(v59, (int32x4_t)0), v61), (uint32x4_t)xmmword_188991170), (int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(vtrn2q_s32(vrev64q_s32(vaddq_s32(v56, v58)), vsubq_s32(v56, v58)), (int32x4_t)0), v61), 0x18uLL)), (int8x16_t)vshlq_u32((uint32x4_t)vminq_s32(vmaxq_s32(vtrn2q_s32(vrev64q_s32(vaddq_s32(v57, v58)), vsubq_s32(v57, v58)), (int32x4_t)0), v61),
                                        (uint32x4_t)xmmword_188991160)) | __PAIR128__(0xFF000000FFLL, 0xFF000000FFLL);
      uint64_t v62 = a1 + 14;
      float32x4_t v63 = (float32x4_t)vdupq_n_s32(0x3B808081u);
      do
      {
        uint64_t v64 = 0;
        uint64_t v65 = (int32x4_t *)v6;
        do
        {
          *(uint32x2_t *)v60.i8 = vshl_u32((uint32x2_t)vdup_n_s32(*((_DWORD *)&v101 + *(unsigned __int8 *)(v62 + v64))), (uint32x2_t)0xFFFFFFF0FFFFFFF8);
          v60.i32[2] = *((_DWORD *)&v101 + *(unsigned __int8 *)(v62 + v64));
          uint32x4_t v66 = vshrq_n_u32((uint32x4_t)v60, 0x18uLL);
          v60.i32[3] = v60.i32[2];
          int32x4_t v67 = (int32x4_t)vandq_s8((int8x16_t)v60, (int8x16_t)v61);
          v67.i32[2] = v66.i32[2];
          int32x4_t v60 = (int32x4_t)vmulq_f32(vcvtq_f32_s32(v67), v63);
          *v65++ = v60;
          v64 += 4;
        }
        while (v64 != 16);
        ++v52;
        ++v62;
        v6 += 4;
      }
      while (v52 != 4);
      break;
    case 3:
      uint64_t v68 = 0;
      int v69 = (4 * *(unsigned __int8 *)(a1 + 4)) | (*(unsigned __int8 *)(a1 + 4) >> 4);
      int v70 = (2 * *(unsigned __int8 *)(a1 + 5)) | (*(unsigned __int8 *)(a1 + 5) >> 6);
      int v71 = (4 * *(unsigned __int8 *)(a1 + 6)) | (*(unsigned __int8 *)(a1 + 6) >> 4);
      int v72 = ((4 * *(unsigned __int8 *)(a1 + 10)) | (*(unsigned __int8 *)(a1 + 10) >> 4)) - v69;
      int v73 = ((2 * *(unsigned __int8 *)(a1 + 11)) | (*(unsigned __int8 *)(a1 + 11) >> 6)) - v70;
      int v74 = ((4 * *(unsigned __int8 *)(a1 + 12)) | (*(unsigned __int8 *)(a1 + 12) >> 4)) - v71;
      int32x4_t v75 = vmulq_s32(vdupq_n_s32(((4 * *(unsigned __int8 *)(a1 + 7)) | (*(unsigned __int8 *)(a1 + 7) >> 4)) - v69), (int32x4_t)xmmword_18898C3A0);
      int32x4_t v76 = vmulq_s32(vdupq_n_s32(((2 * *(unsigned __int8 *)(a1 + 8)) | (*(unsigned __int8 *)(a1 + 8) >> 6)) - v70), (int32x4_t)xmmword_18898C3A0);
      int32x4_t v77 = vmulq_s32(vdupq_n_s32(((4 * *(unsigned __int8 *)(a1 + 9)) | (*(unsigned __int8 *)(a1 + 9) >> 4)) - v71), (int32x4_t)xmmword_18898C3A0);
      unsigned int v78 = (4 * v71) | 2;
      unsigned int v79 = (4 * v70) | 2;
      float32x4_t v80 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      __asm { FMOV            V19.4S, #1.0 }
      unsigned int v86 = (4 * v69) | 2;
      do
      {
        float32x4_t v87 = vminnmq_f32(vmaxnmq_f32(vdivq_f32(vcvtq_f32_s32(vshrq_n_s32(vaddq_s32(vdupq_n_s32(v86), v75), 2uLL)), v80), (float32x4_t)0), _Q19);
        float32x4_t v88 = vminnmq_f32(vmaxnmq_f32(vdivq_f32(vcvtq_f32_s32(vshrq_n_s32(vaddq_s32(vdupq_n_s32(v79), v76), 2uLL)), v80), (float32x4_t)0), _Q19);
        float32x4_t v89 = vminnmq_f32(vmaxnmq_f32(vdivq_f32(vcvtq_f32_s32(vshrq_n_s32(vaddq_s32(vdupq_n_s32(v78), v77), 2uLL)), v80), (float32x4_t)0), _Q19);
        unsigned int v90 = (float *)&a2[v68];
        vst4q_f32(v90, *(float32x4x4_t *)(&_Q19 - 3));
        v68 += 4;
        v78 += v74;
        v79 += v73;
        v86 += v72;
      }
      while (v68 != 16);
      break;
    default:
      decode_etc2();
  }
}

uint64_t nv::decompress_eac(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v14[2] = *MEMORY[0x1E4F143B8];
  if (a3 >= 4) {
    nv::decompress_eac();
  }
  uint64_t v13 = 0;
  v14[0] = 0;
  *(_DWORD *)((char *)v14 + 7) = 0;
  uint64_t result = unpack_eac_block(a1, &v13);
  unsigned int v6 = 0;
  uint64_t v7 = 0;
  int v8 = (8 * v13) | 4;
  if (BYTE1(v13)) {
    int v9 = 8 * BYTE1(v13);
  }
  else {
    int v9 = 1;
  }
  int32x2_t v10 = (char *)&eac_intensity_modifiers + 32 * BYTE2(v13);
  do
  {
    int v11 = v8 + v9 * *(_DWORD *)&v10[4 * *((unsigned __int8 *)&v14[-1] + (v7 & 0xC) + (v6 >> 2) + 3)];
    int v12 = v11 & ~(v11 >> 31);
    if (v12 >= 2047) {
      int v12 = 2047;
    }
    *(float *)(a2 + 4 * a3 + 4 * v7) = (float)((32 * v12) | (v12 >> 6)) / 65535.0;
    v7 += 4;
    ++v6;
  }
  while (v7 != 64);
  return result;
}

uint64_t unpack_eac_block(uint64_t result, unsigned char *a2)
{
  *a2 = *(void *)result;
  a2[2] = *(unsigned char *)(result + 1) & 0xF;
  a2[1] = (unsigned __int16)*(_DWORD *)result >> 12;
  unint64_t v2 = __ROR8__(*(void *)result, 56) & 0xFF000000FFLL | ((unint64_t)BYTE2(*(void *)result) << 40) | (*(void *)result >> 8) & 0xFF000000 | (*(void *)result >> 24) & 0xFF0000 | (*(void *)result >> 40) & 0xFF00;
  unsigned int v3 = a2 + 3;
  for (uint64_t i = 45; i != -3; i -= 3)
    *v3++ = (v2 >> i) & 7;
  return result;
}

float nv::decompress_etc_eac(uint64_t a1, __n128 *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  memset(v18, 0, sizeof(v18));
  unpack_etc2_block((unint64_t *)(a1 + 8), (uint64_t)v18);
  decode_etc2((uint64_t)v18, a2, v4, v5, v6, v7);
  uint64_t v16 = 0;
  v17[0] = 0;
  *(_DWORD *)((char *)v17 + 7) = 0;
  unpack_eac_block(a1, &v16);
  unsigned int v8 = 0;
  uint64_t v9 = 0;
  int v10 = v16;
  int v11 = BYTE1(v16);
  int v12 = (char *)&eac_intensity_modifiers + 32 * BYTE2(v16);
  do
  {
    int v13 = v10 + *(_DWORD *)&v12[4 * *((unsigned __int8 *)&v17[-1] + ((v9 * 4) & 0xC) + (v8 >> 2) + 3)] * v11;
    int v14 = v13 & ~(v13 >> 31);
    if (v14 >= 255) {
      int v14 = 255;
    }
    float result = (float)v14 / 255.0;
    a2[v9++].n128_f32[3] = result;
    ++v8;
  }
  while (v9 != 16);
  return result;
}

uint64_t nv::DecompressETC_EAC(int a1, unsigned int a2, unsigned int a3, unint64_t *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = 0;
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  switch(a1)
  {
    case 14:
      goto LABEL_9;
    case 15:
      LODWORD(v6) = 0;
      unsigned int v39 = (a2 + 3) >> 2;
      unsigned int v9 = (a3 + 3) >> 2;
      goto LABEL_7;
    case 16:
      LODWORD(v6) = 1;
LABEL_9:
      unsigned int v39 = (a2 + 3) >> 2;
      unsigned int v9 = (a3 + 3) >> 2;
      int32x2_t v10 = (int32x2_t)v6;
      goto LABEL_10;
    case 17:
    case 18:
    case 19:
      unsigned int v39 = (a2 + 3) >> 2;
      unsigned int v9 = (a3 + 3) >> 2;
      LODWORD(v6) = 1;
      if (a1 == 17) {
        goto LABEL_7;
      }
      int32x2_t v10 = (int32x2_t)0x100000001;
      if (a1 == 18)
      {
LABEL_10:
        unsigned int v11 = 8;
      }
      else if (a1 == 19)
      {
LABEL_7:
        int32x2_t v10 = vdup_n_s32(v6);
        unsigned int v11 = 16;
        LODWORD(v6) = 1;
      }
      else
      {
        unsigned int v11 = 0;
      }
      uint64_t v44 = v11;
      if (v11 > a5) {
        return 0;
      }
      if (!v9) {
        return 1;
      }
      unsigned int v12 = 0;
      uint64_t v13 = 0;
      unsigned int v42 = a1 & 0xFFFFFFFD;
      unint64_t v14 = a2;
      unint64_t v15 = a3;
      int v38 = 16 * a2;
      int v16 = 4 * a2;
      uint64_t v37 = v9;
      int8x8_t v17 = (int8x8_t)vcltz_s32(vshl_n_s32(v10, 0x1FuLL));
      int v43 = a1;
      break;
    default:
      return v6;
  }
  while (1)
  {
    unsigned int v41 = v12;
    uint64_t v40 = v13;
    if (v39) {
      break;
    }
LABEL_41:
    uint64_t v13 = v40 + 1;
    unsigned int v12 = v41 + v38;
    if (v40 + 1 == v37) {
      return 1;
    }
  }
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 4 * v13;
  while (1)
  {
    memset(&v45, 0, 256);
    if (a1 == 16 || a1 == 13)
    {
LABEL_19:
      memset(v46, 0, sizeof(v46));
      unpack_etc2_block(a4, (uint64_t)v46);
      decode_etc2((uint64_t)v46, &v45, v21, v22, v23, v24);
      goto LABEL_20;
    }
    if (v42 == 17)
    {
      nv::decompress_etc_eac((uint64_t)a4, &v45);
      goto LABEL_20;
    }
    if (a1 == 18) {
      goto LABEL_19;
    }
    if (a1 == 15)
    {
      nv::decompress_eac((uint64_t)a4, (uint64_t)&v45, 0);
      uint64_t v34 = (uint64_t)a4 + (v44 >> 1);
      unsigned int v35 = 1;
      goto LABEL_40;
    }
    if (a1 != 14) {
      return 0;
    }
    uint64_t v34 = (uint64_t)a4;
    unsigned int v35 = 0;
LABEL_40:
    nv::decompress_eac(v34, (uint64_t)&v45, v35);
LABEL_20:
    uint64_t v25 = 0;
    int v26 = &v45.n128_u64[1];
    unsigned int v27 = v12;
    a1 = v43;
    do
    {
      uint64_t v28 = 0;
      unsigned int v29 = (int8x8_t *)v26;
      unsigned int v30 = v27;
      do
      {
        if (v18 + v28 < v14 && v25 + v20 < v15)
        {
          float v32 = *(float *)&v29[-1].i32[1];
          uint64_t v33 = a6 + 4 * v30;
          if (!v6) {
            float v32 = 0.0;
          }
          *(_DWORD *)uint64_t v33 = v29[-1].i32[0];
          *(float *)(v33 + 4) = v32;
          *(int8x8_t *)(v33 + 8) = vbsl_s8(v17, *v29, (int8x8_t)0x3F80000000000000);
        }
        ++v28;
        v30 += 4;
        v29 += 2;
      }
      while (v28 != 4);
      ++v25;
      v27 += v16;
      v26 += 8;
    }
    while (v25 != 4);
    a4 = (unint64_t *)((char *)a4 + v44);
    ++v19;
    v12 += 16;
    v18 += 4;
    if (v19 == v39) {
      goto LABEL_41;
    }
  }
}

__n128 get_abs_subblock_palette(unsigned int a1, unsigned int a2, __n128 *a3)
{
  if (a2 >= 8) {
    get_abs_subblock_palette();
  }
  int32x4_t v3 = etc_intensity_modifiers[a2];
  v4.i64[0] = 0xFF000000FFLL;
  v4.i64[1] = 0xFF000000FFLL;
  __n128 result = (__n128)(*(_OWORD *)&vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(vaddq_s32(v3, vdupq_n_s32((a1 >> 4) | (16* (a1 >> 4)))), (int32x4_t)0), v4), 0x10uLL), (int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(vaddq_s32(v3, vdupq_n_s32((a1 >> 8) & 0xF | (16 * ((a1 >> 8) & 0xF)))), (int32x4_t)0), v4),
                                                 8uLL)),
                                  (int8x16_t)vshlq_n_s32(vminq_s32(vmaxq_s32(vaddq_s32(v3, vdupq_n_s32(a1 & 0xF | (16 * (a1 & 0xF)))), (int32x4_t)0), v4), 0x18uLL)) | __PAIR128__(0xFF000000FFLL, 0xFF000000FFLL));
  *a3 = result;
  return result;
}

BOOL isPowerOf2(uint64_t a1)
{
  return a1 && (a1 & (a1 - 1)) == 0;
}

double PVRReadPlugin::PVRReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(void *)uint64_t v5 = &unk_1ED4E0A08;
  double result = 0.0;
  *(_OWORD *)(v5 + 440) = 0u;
  *(_OWORD *)(v5 + 456) = 0u;
  *(_OWORD *)(v5 + 472) = 0u;
  *(_OWORD *)(v5 + 488) = 0u;
  *(_OWORD *)(v5 + 504) = 0u;
  *(_OWORD *)(v5 + 520) = 0u;
  *(_OWORD *)(v5 + 536) = 0u;
  *(_OWORD *)(v5 + 552) = 0u;
  *(void *)(v5 + 568) = 0;
  return result;
}

void PVRReadPlugin::PVRReadPlugin(uint64_t a1, uint64_t a2)
{
}

void PVRReadPlugin::~PVRReadPlugin(PVRReadPlugin *this)
{
  *(void *)this = &unk_1ED4E0A08;
  uint64_t v2 = *((void *)this + 70);
  if (v2) {
    (**(void (***)(void))(v2 + 8))();
  }

  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  uint64_t vars8;

  PVRReadPlugin::~PVRReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t PVRReadPlugin::loadDataFromXPCObject(PVRReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_pvr", &length);
    if (length == 136)
    {
      uint64_t v6 = data;
      uint64_t result = 0;
      long long v7 = v6[5];
      long long v8 = v6[6];
      uint64_t v9 = *((void *)v6 + 16);
      *(_OWORD *)((char *)this + 552) = v6[7];
      *(_OWORD *)((char *)this + 440) = *v6;
      long long v10 = v6[1];
      long long v11 = v6[2];
      long long v12 = v6[4];
      *(_OWORD *)((char *)this + 488) = v6[3];
      *(_OWORD *)((char *)this + 504) = v12;
      *(_OWORD *)((char *)this + 456) = v10;
      *(_OWORD *)((char *)this + 472) = v11;
      *((void *)this + 71) = v9;
      *(_OWORD *)((char *)this + 520) = v7;
      *(_OWORD *)((char *)this + 536) = v8;
      *((void *)this + 70) = 0;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t PVRReadPlugin::saveDataToXPCObject(PVRReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_pvr", (char *)this + 440, 0x88uLL);
  }
  return v4;
}

void PVRReadPlugin::addImageTypeIdentifier(PVRReadPlugin *this, CGImage *a2, const __CFString *a3, int a4)
{
  if (*((unsigned char *)this + 496))
  {
    CGImageSetProperty();
    IIOString::IIOString((IIOString *)v6, 0x4B545820u);
  }
  else
  {
    CGImageSetProperty();
    IIOString::IIOString((IIOString *)v6, *((_DWORD *)this + 51));
  }
  CGImageSetProperty();
  IIOString::~IIOString((IIOString *)v6);
  IIONumber::IIONumber((IIONumber *)v6, a4);
  CGImageSetProperty();
  IIONumber::~IIONumber((IIONumber *)v6);
}

void sub_188750770(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t PVRReadPlugin::validateV2Header(uint64_t a1, _DWORD *a2)
{
  int v4 = a2[4];
  if (*a2 == 52 || *a2 == 44)
  {
    if (a2[6])
    {
      unint64_t v5 = a2[5];
      if ((unint64_t)IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24)) > v5)
      {
        unint64_t v6 = a2[12];
        if ((unint64_t)IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24)) > v6)
        {
          if ((v4 & 0xFE) != 0x18 && (a2[6] & 7) != 0)
          {
            _cg_jpeg_mem_term("validateV2Header", 163, "*** invalid bits/pixel: %d");
          }
          else
          {
            if (v4 - 22) < 0x1Du && ((0x10000023u >> (v4 - 22))) {
              return 1;
            }
            int v8 = a2[7];
            int v7 = a2[8];
            if ((v7 & v8) != 0)
            {
              _cg_jpeg_mem_term("validateV2Header", 166, "*** red/green masks overlap: r:0x%08X g:0x%08X");
            }
            else
            {
              int v9 = a2[9];
              if ((v9 & v8) != 0)
              {
                _cg_jpeg_mem_term("validateV2Header", 167, "*** red/blue masks overlap: r:0x%08X b:0x%08X");
              }
              else
              {
                if ((v9 & v7) == 0) {
                  return 1;
                }
                _cg_jpeg_mem_term("validateV2Header", 168, "*** green/blue masks overlap: g:0x%08X b:0x%08X");
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

uint64_t PVRReadPlugin::validateV3Header(uint64_t a1, _DWORD *a2)
{
  if (a2[9] >= 0x11u)
  {
    _cg_jpeg_mem_term("validateV3Header", 181, "*** bad numberOfSurfaces count [%d]\n");
  }
  else
  {
    unint64_t v4 = a2[10];
    if ((unint64_t)IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24)) < v4)
    {
      IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24));
      _cg_jpeg_mem_term("validateV3Header", 182, "*** bad numberOfFaces count [%d]  size: %d\n");
    }
    else if (a2[4] >= 2u)
    {
      _cg_jpeg_mem_term("validateV3Header", 183, "*** bad colorSpace [%d]\n");
    }
    else if (a2[8] >= 0x11u)
    {
      _cg_jpeg_mem_term("validateV3Header", 184, "*** bad depth [%d]\n");
    }
    else
    {
      unint64_t v5 = a2[12];
      if ((unint64_t)IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24)) >= v5) {
        return 1;
      }
      IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24));
      _cg_jpeg_mem_term("validateV3Header", 185, "*** bad metadataSize [%d]  size: %d\n");
    }
  }
  return 0;
}

uint64_t PVRReadPlugin::calculateOffsetToRequestedImage(PVRReadPlugin *this, uint64_t a2)
{
  unsigned int v4 = *((_DWORD *)this + 117);
  unsigned int v5 = *((_DWORD *)this + 116);
  int v6 = *((unsigned __int16 *)this + 275);
  unsigned int v7 = *((_DWORD *)this + 52);
  if (v7)
  {
    unsigned int v8 = 0;
    int v9 = *((_DWORD *)this + 121);
    unsigned int v17 = *((_DWORD *)this + 116);
    do
    {
      unsigned int v10 = (v4 * v6) >> 3;
      if (v9)
      {
        int v11 = 0;
        unsigned int v12 = v4;
        do
        {
          uint64_t v13 = v10 * v5;
          printf("#%d  mm:%d    size: %dx%d    imgSize: %d\n", v8, v11, v12, v5, v10 * v5);
          a2 += v13;
          v12 >>= 1;
          v5 >>= 1;
          int v6 = *((unsigned __int16 *)this + 275);
          ++v11;
          unsigned int v10 = (v12 * v6) >> 3;
        }
        while (v9 != v11);
        unsigned int v7 = *((_DWORD *)this + 52);
        unsigned int v5 = v17;
      }
      ++v8;
    }
    while (v8 < v7);
  }
  else
  {
    unsigned int v10 = (v4 * v6) >> 3;
  }
  if (*((_WORD *)this + 159))
  {
    unsigned int v14 = 0;
    do
    {
      uint64_t v15 = v10 * v5;
      printf("   mm:%d    size: %dx%d    imgSize: %d\n", v14, v4, v5, v10 * v5);
      a2 += v15;
      v4 >>= 1;
      v5 >>= 1;
      unsigned int v10 = (v4 * *((unsigned __int16 *)this + 275)) >> 3;
      ++v14;
    }
    while (v14 < *((unsigned __int16 *)this + 159));
  }
  return a2;
}

uint64_t PVRReadPlugin::initialize(PVRReadPlugin *this, IIODictionary *a2)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  unsigned int v68 = 0;
  if (!*((unsigned char *)this + 341)) {
    goto LABEL_157;
  }
  IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &v68, 0x2CuLL, 4uLL);
  unsigned int v68 = bswap32(v68);
  *((_WORD *)this + 159) = 0;
  unsigned int v3 = IIODictionary::containsKey(*((IIODictionary **)this + 6), @"kCGImageSourceMipmapLevel");
  unsigned int v4 = (IIODictionary *)*((void *)this + 6);
  if (v3)
  {
    LOWORD(v5) = (unsigned __int16)IIODictionary::getUint32ForKey(v4, @"kCGImageSourceMipmapLevel");
  }
  else
  {
    if (!IIODictionary::containsKey(v4, @"kCGImageSourceSubsampleFactor")) {
      goto LABEL_10;
    }
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(*((IIODictionary **)this + 6), @"kCGImageSourceSubsampleFactor");
    if (Uint32ForKey) {
      double v7 = log2((double)Uint32ForKey);
    }
    else {
      double v7 = 0.0;
    }
    int v5 = (int)v7;
  }
  *((_WORD *)this + 159) = v5;
LABEL_10:
  if (v68 != 1347834401)
  {
    IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &v68, 0, 4uLL);
    unsigned int v16 = v68;
    unsigned int v68 = bswap32(v68);
    if (v16 != 55727696)
    {
      int v29 = *((_DWORD *)this + 51);
      if (v29 == 1261588566)
      {
        *((_DWORD *)this + 123) = -1;
        long long v78 = 0u;
        long long v79 = 0u;
        long long v76 = 0u;
        long long v77 = 0u;
        long long v75 = 0u;
        unint64_t Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
        if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &v75, *((void *)this + 24), 0x50uLL) != 80)
        {
          _cg_jpeg_mem_term("initialize", 640, "*** ERROR: PVR failed to read KTX2 header (%d bytes) expected: %d\n");
          goto LABEL_157;
        }
        if (!IsKTX2Header(&v75)) {
          goto LABEL_157;
        }
        if ((unint64_t)Size <= v77)
        {
          _cg_jpeg_mem_term("initialize", 645, "*** ERROR: Invalid numberOfArrayElements (%d).");
          goto LABEL_157;
        }
        if ((unint64_t)Size <= v78)
        {
          _cg_jpeg_mem_term("initialize", 646, "*** ERROR: Invalid dfdOffset (%d).");
          goto LABEL_157;
        }
        if ((unint64_t)Size <= DWORD1(v78))
        {
          _cg_jpeg_mem_term("initialize", 647, "*** ERROR: Invalid dfdLength (%d).");
          goto LABEL_157;
        }
        if ((unint64_t)Size <= DWORD2(v78))
        {
          _cg_jpeg_mem_term("initialize", 648, "*** ERROR: Invalid kvdOffset (%d).");
          goto LABEL_157;
        }
        if ((unint64_t)Size <= HIDWORD(v78))
        {
          _cg_jpeg_mem_term("initialize", 649, "*** ERROR: Invalid kvdLength (%d).");
          goto LABEL_157;
        }
        if ((unint64_t)v79 >= (unint64_t)Size)
        {
          _cg_jpeg_mem_term("initialize", 650, "*** ERROR: Invalid scgdOffset (%d).");
          goto LABEL_157;
        }
        if (*((void *)&v79 + 1) >= (unint64_t)Size)
        {
          _cg_jpeg_mem_term("initialize", 651, "*** ERROR: Invalid scgdLength (%d).");
          goto LABEL_157;
        }
        uint64_t v74 = 0;
        long long v72 = 0u;
        long long v73 = 0u;
        long long v71 = 0u;
        int8x16_t v69 = 0u;
        memset(v70, 0, sizeof(v70));
        uint64_t v67 = 0;
        if (CreateKtxStream((uint64_t)&v69, *((IIOImageReadSession **)this + 3))) {
          goto LABEL_157;
        }
        if (ktxTexture2_CreateFromStream(&v69, 0, &v67))
        {
          _cg_jpeg_mem_term("initialize", 660, "*** ERROR: ktxTexture2_CreateFromStream failed [%d]\n");
          goto LABEL_157;
        }
        *((void *)this + 70) = v67;
        int v34 = HIDWORD(v75);
        unsigned int v35 = DWORD2(v77);
        *((_DWORD *)this + 142) = HIDWORD(v75);
        *((unsigned char *)this + 497) = 1;
        if (v35 >= 0x14)
        {
          _cg_jpeg_mem_term("initialize", 667, "unexpected numberOfMipmapLevels == %d\n");
          goto LABEL_157;
        }
        if (DWORD1(v77) >= 0x14)
        {
          _cg_jpeg_mem_term("initialize", 668, "unexpected numberOfMipmapLevels == %d\n");
          goto LABEL_157;
        }
        if (HIDWORD(v76))
        {
          _cg_jpeg_mem_term("initialize", 669, "unexpected pixelDepth == %d\n");
          goto LABEL_157;
        }
        if (!DWORD2(v76))
        {
          _cg_jpeg_mem_term("initialize", 670, "unexpected pixelHeight == %d\n");
          goto LABEL_157;
        }
        int v30 = DWORD1(v76);
        if (!DWORD1(v76))
        {
          _cg_jpeg_mem_term("initialize", 671, "unexpected pixelWidth == %d\n");
          goto LABEL_157;
        }
        unsigned int v36 = v34 - 1000054000;
        if (v36 >= 8) {
          int v37 = 0;
        }
        else {
          int v37 = dword_188991438[v36];
        }
        *((_DWORD *)this + 131) = v37;
        *((unsigned char *)this + 344) = 0;
        *((_DWORD *)this + 57) = v30;
        *((_DWORD *)this + 58) = v30;
      }
      else
      {
        if (v29 != 1263556178) {
          goto LABEL_77;
        }
        long long v71 = 0u;
        int8x16_t v69 = 0u;
        memset(v70, 0, sizeof(v70));
        *((_DWORD *)this + 123) = -1;
        if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &v69, *((void *)this + 24), 0x40uLL) != 64)
        {
          _cg_jpeg_mem_term("initialize", 596, "*** ERROR: PVR failed to read KTX header (%d bytes) expected: %d\n");
          goto LABEL_157;
        }
        *((unsigned char *)this + 496) = 1;
        SwapKTXHeader(&v69);
        if (DWORD2(v71) >= 0x14)
        {
          _cg_jpeg_mem_term("initialize", 601, "unexpected numberOfMipmapLevels == %d\n");
          goto LABEL_157;
        }
        if (DWORD1(v71) >= 0x14)
        {
          _cg_jpeg_mem_term("initialize", 602, "unexpected numberOfMipmapLevels == %d\n");
          goto LABEL_157;
        }
        if (HIDWORD(v70[1]))
        {
          _cg_jpeg_mem_term("initialize", 603, "unexpected pixelDepth == %d\n");
          goto LABEL_157;
        }
        if (!DWORD2(v70[1]))
        {
          _cg_jpeg_mem_term("initialize", 604, "unexpected pixelHeight == %d\n");
          goto LABEL_157;
        }
        int v30 = DWORD1(v70[1]);
        if (!DWORD1(v70[1]))
        {
          _cg_jpeg_mem_term("initialize", 605, "unexpected pixelWidth == %d\n");
          goto LABEL_157;
        }
        __int32 v31 = v69.i32[3];
        *((_DWORD *)this + 131) = HIDWORD(v70[0]);
        *((unsigned char *)this + 344) = v31 == 67305985;
        *((_DWORD *)this + 57) = v30;
        *((_DWORD *)this + 58) = v30;
        *((void *)this + 24) = HIDWORD(v71) + 64;
      }
      *((unsigned char *)this + 498) = 1;
      *((_WORD *)this + 122) = 4;
      *((_DWORD *)this + 59) = 4 * v30;
      *((_DWORD *)this + 60) = 2097160;
      *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
      *((_DWORD *)this + 81) = 1380401696;
      *((_WORD *)this + 123) = 3;
      goto LABEL_77;
    }
    LODWORD(v71) = 0;
    memset(v70, 0, sizeof(v70));
    int8x16_t v69 = 0u;
    if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &v69, 0, 0x34uLL) != 52)
    {
      _cg_jpeg_mem_term("initialize", 398, "*** ERROR: PVR failed to read v3 header (%d bytes) expected: %d\n");
      goto LABEL_157;
    }
    if ((PVRReadPlugin::validateV3Header((uint64_t)this, &v69) & 1) == 0)
    {
      _cg_jpeg_mem_term("initialize", 401, "*** invalid PVR3 header\n");
      goto LABEL_157;
    }
    int v17 = DWORD2(v70[1]);
    *((_DWORD *)this + 122) = v71;
    *((unsigned char *)this + 496) = 0;
    long long v18 = v70[1];
    *(_OWORD *)((char *)this + 456) = v70[0];
    *(_OWORD *)((char *)this + 472) = v18;
    *(int8x16_t *)((char *)this + 440) = v69;
    *((_DWORD *)this + 123) = 3;
    *((_DWORD *)this + 120) = v17;
    unsigned int v19 = *((unsigned __int16 *)this + 159);
    unsigned int v20 = *((_DWORD *)this + 121);
    if (v20 <= v19)
    {
      *((_WORD *)this + 159) = v20 - 1;
      unsigned int v19 = (unsigned __int16)(v20 - 1);
    }
    *(int32x2_t *)((char *)this + 228) = vrev64_s32((int32x2_t)vshl_u32(*(uint32x2_t *)((char *)v70 + 8), (uint32x2_t)vneg_s32(vdup_n_s32(v19))));
    *((unsigned char *)this + 548) = -1;
    *((unsigned char *)this + 520) = -1;
    *((_DWORD *)this + 60) = 2097160;
    *((_WORD *)this + 122) = 4;
    *((_DWORD *)this + 81) = 1380401696;
    unsigned __int32 v21 = v69.u32[3];
    if (!v69.i32[3])
    {
      __int8 v32 = v69.i8[8];
      *((unsigned char *)this + 520) = v69.i8[8];
      *((unsigned char *)this + 498) = (v32 & 0xFEu) < 6;
      *((unsigned char *)this + 246) = 3;
LABEL_146:
      *((_DWORD *)this + 59) = 4 * *((_DWORD *)this + 57);
      *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
LABEL_147:
      int v66 = *((unsigned __int16 *)this + 121);
      if (v66 == 16)
      {
        *((unsigned char *)this + 247) = 1;
      }
      else if (v66 == 32)
      {
        *((unsigned char *)this + 247) = 0;
      }
      goto LABEL_77;
    }
    *((unsigned char *)this + 498) = 0;
    unsigned int v22 = v69.u32[2];
    unsigned int v23 = v21;
    unsigned int v24 = BYTE1(v21);
    unsigned int v25 = BYTE2(v21);
    unsigned __int32 v26 = HIBYTE(v21);
    unsigned int v27 = HIBYTE(v21) + v21 + BYTE1(v21) + BYTE2(v21);
    *((_WORD *)this + 275) = v27;
    if (v27 >= 9)
    {
      if (v27 >= 0x11)
      {
        if (v27 >= 0x21)
        {
          if (v27 >= 0x41)
          {
            if (v27 >= 0x81)
            {
              _cg_jpeg_mem_term("initialize", 453, "*** ERROR: bad _bitsPerPixel: %d for RGBA channels (%d,%d,%d,%d)\n");
              goto LABEL_157;
            }
            __int16 v28 = 128;
          }
          else
          {
            __int16 v28 = 64;
          }
        }
        else
        {
          __int16 v28 = 32;
        }
      }
      else
      {
        __int16 v28 = 16;
      }
    }
    else
    {
      __int16 v28 = 8;
    }
    int v60 = bswap32(v22);
    *((_WORD *)this + 275) = v28;
    *((_DWORD *)this + 138) = -1;
    if (v60 <= 1912602623)
    {
      if (v60 > 1650946559)
      {
        if (v60 == 1650946560)
        {
          *((unsigned char *)this + 548) = 1;
          *((unsigned char *)this + 554) = v23;
          *((unsigned char *)this + 553) = v24;
          *((unsigned char *)this + 552) = v25;
          if (v25 == v24)
          {
            unsigned int v61 = v23;
            unsigned int v62 = v25;
            if (v23 == v24) {
              goto LABEL_132;
            }
          }
          _cg_jpeg_mem_term("initialize", 516, "*** ERROR unsupported 'bgr'-bitDepth: %d-%d-%d\n");
          goto LABEL_157;
        }
        if (v60 == 1650946657 || v60 == 1650946680)
        {
          *((unsigned char *)this + 548) = 3;
          *((unsigned char *)this + 554) = v23;
          *((unsigned char *)this + 553) = v24;
          *((unsigned char *)this + 552) = v25;
          *((unsigned char *)this + 555) = v26;
          *((unsigned char *)this + 246) = 3;
          if (v25 == v24)
          {
            unsigned int v61 = v23;
            unsigned int v62 = v23;
            if (v24 == v23) {
              goto LABEL_132;
            }
          }
          _cg_jpeg_mem_term("initialize", 538, "*** ERROR unsupported 'bgra/bgrx'-bitDepth: %d-%d-%d\n");
          goto LABEL_157;
        }
        goto LABEL_131;
      }
      if (v60 != 1633838962)
      {
        int v63 = 1634887522;
LABEL_114:
        if (v60 == v63)
        {
          *((unsigned char *)this + 548) = 2;
          *((unsigned char *)this + 555) = v23;
          *((unsigned char *)this + 552) = v24;
          *((unsigned char *)this + 553) = v25;
          *((unsigned char *)this + 554) = v26;
          *((unsigned char *)this + 246) = 4;
          if (v24 == v25)
          {
            unsigned int v61 = v24;
            unsigned int v62 = v24;
            if (v25 == v26) {
              goto LABEL_132;
            }
          }
          _cg_jpeg_mem_term("initialize", 495, "*** ERROR unsupported 'argb/xrgb'-bitDepth: %d-%d-%d\n");
          goto LABEL_157;
        }
LABEL_131:
        _cg_jpeg_mem_term("initialize", 542, "*** ERROR unsupported 'v3Header.pixelFormatLo' 0x%08X\n", v22);
        unsigned int v62 = *((unsigned __int8 *)this + 552);
        unsigned int v61 = *((unsigned __int8 *)this + 553);
LABEL_132:
        if (v62 - 9 < 0xF6)
        {
          if (v61 <= 8)
          {
            _cg_jpeg_mem_term("initialize", 549, "*** _greenBits don't match _redBits  [0x%02X vs 0x%02X]\n");
            goto LABEL_157;
          }
          if (*((unsigned __int8 *)this + 554) <= 8u)
          {
            _cg_jpeg_mem_term("initialize", 551, "*** _blueBits don't match _redBits [0x%02X vs 0x%02X]\n");
            goto LABEL_157;
          }
        }
        if (v61 - 9 <= 0xF5 && *((unsigned __int8 *)this + 554) <= 8u)
        {
          _cg_jpeg_mem_term("initialize", 556, "*** _blueBits don't match _greenBits [0x%02X vs 0x%02X]\n");
          goto LABEL_157;
        }
        unsigned int v23 = v62;
LABEL_138:
        if (v23 != 255 && v23 - 8 >= 0x19)
        {
          _cg_jpeg_mem_term("initialize", 560, "*** _redBits out of range  [0x%02X]\n");
          goto LABEL_157;
        }
        if (v61 != 255 && v61 - 8 >= 0x19)
        {
          _cg_jpeg_mem_term("initialize", 562, "*** _greenBits out of range  [0x%02X]\n");
          goto LABEL_157;
        }
        int v64 = *((unsigned __int8 *)this + 554);
        if (v64 != 255 && (v64 - 8) >= 0x19)
        {
          _cg_jpeg_mem_term("initialize", 564, "*** _blueBits out of range  [0x%02X]\n");
          goto LABEL_157;
        }
        int v65 = *((_DWORD *)this + 81);
        if (v65 == 1196573017)
        {
          *((_DWORD *)this + 59) = *((_DWORD *)this + 57);
          *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
          *(_DWORD *)((char *)this + 242) = 65544;
          goto LABEL_77;
        }
        if (v65 != 1380401696) {
          goto LABEL_147;
        }
        goto LABEL_146;
      }
    }
    else
    {
      if (v60 <= 1919378039)
      {
        if (v60 == 1912602624)
        {
          *((unsigned char *)this + 548) = 6;
          *(_DWORD *)((char *)this + 242) = 65544;
          *((_DWORD *)this + 81) = 1196573017;
          *((unsigned char *)this + 552) = v23;
          *(_WORD *)((char *)this + 553) = -1;
          unsigned int v61 = 255;
          *((unsigned char *)this + 555) = -1;
          goto LABEL_138;
        }
        if (v60 == 1919377920)
        {
          *((unsigned char *)this + 548) = 0;
          *((unsigned char *)this + 552) = v23;
          *((unsigned char *)this + 553) = v24;
          *((unsigned char *)this + 554) = v25;
          if (v23 != v24 || v24 != v25)
          {
            _cg_jpeg_mem_term("initialize", 481, "*** ERROR unsupported 'rgb'-bitDepth: %d-%d-%d\n");
            goto LABEL_157;
          }
          *((unsigned char *)this + 557) = 3;
          *((_WORD *)this + 122) = 4;
          *((unsigned char *)this + 246) = 5;
          unsigned int v61 = v24;
          unsigned int v62 = v23;
          goto LABEL_132;
        }
        if (v60 != 1919378017) {
          goto LABEL_131;
        }
        goto LABEL_118;
      }
      if (v60 == 1919378040)
      {
LABEL_118:
        *((unsigned char *)this + 548) = 2;
        *((unsigned char *)this + 552) = v23;
        *((unsigned char *)this + 553) = v24;
        *((unsigned char *)this + 554) = v25;
        *((unsigned char *)this + 555) = v26;
        *((unsigned char *)this + 246) = 3;
        if (v23 == v24)
        {
          unsigned int v61 = v23;
          unsigned int v62 = v23;
          if (v24 == v25) {
            goto LABEL_132;
          }
        }
        _cg_jpeg_mem_term("initialize", 507, "*** ERROR unsupported 'rgba/rgbx'-bitDepth: %d-%d-%d\n");
LABEL_157:
        kdebug_trace();
        return 4294967246;
      }
      if (v60 != 2019714930)
      {
        int v63 = 2020763490;
        goto LABEL_114;
      }
    }
    *((unsigned char *)this + 548) = 5;
    *((unsigned char *)this + 555) = v23;
    *((unsigned char *)this + 554) = v24;
    *((unsigned char *)this + 553) = v25;
    *((unsigned char *)this + 552) = v26;
    *((unsigned char *)this + 246) = 4;
    if (v26 == v25)
    {
      unsigned int v61 = v24;
      unsigned int v62 = v24;
      if (v25 == v24) {
        goto LABEL_132;
      }
    }
    _cg_jpeg_mem_term("initialize", 527, "*** ERROR unsupported 'abgr/xbgr'-bitDepth: %d-%d-%d\n");
    goto LABEL_157;
  }
  LODWORD(v71) = 0;
  memset(v70, 0, sizeof(v70));
  int8x16_t v69 = 0u;
  if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &v69, 0, 0x34uLL) != 52)
  {
    _cg_jpeg_mem_term("initialize", 302, "*** ERROR: PVR failed to read v2 header (%d bytes) expected: %d\n");
    goto LABEL_157;
  }
  if ((PVRReadPlugin::validateV2Header((uint64_t)this, &v69) & 1) == 0)
  {
    _cg_jpeg_mem_term("initialize", 305, "*** invalid PVR2 header\n");
    goto LABEL_157;
  }
  *((_DWORD *)this + 110) = 1;
  *((_DWORD *)this + 115) = 0;
  *(void *)((char *)this + 452) = 0;
  *(void *)((char *)this + 444) = 0;
  unsigned __int32 v9 = v69.u32[1];
  unsigned __int32 v8 = v69.u32[2];
  *((void *)this + 58) = *(uint64_t *)((char *)v69.i64 + 4);
  *((_DWORD *)this + 119) = v71;
  __int16 v10 = WORD4(v70[0]);
  unsigned __int32 v11 = v69.u32[3];
  *((_DWORD *)this + 118) = DWORD2(v70[0]);
  *((_DWORD *)this + 120) = 0;
  if (v11 <= 1) {
    unsigned __int32 v11 = 1;
  }
  *((_DWORD *)this + 121) = v11;
  *(_OWORD *)((char *)this + 500) = *(_OWORD *)((char *)v70 + 12);
  *((void *)this + 61) = 0x200000000;
  *((unsigned char *)this + 496) = 0;
  unsigned __int32 v12 = *((unsigned __int16 *)this + 159);
  if (v11 <= v12)
  {
    __int16 v13 = v11 - 1;
    *((_WORD *)this + 159) = v13;
    LOBYTE(v12) = v13;
  }
  *((_DWORD *)this + 57) = v8 >> v12;
  *((_DWORD *)this + 58) = v9 >> v12;
  *((_WORD *)this + 275) = v10;
  unsigned __int8 v14 = v70[0];
  *((unsigned char *)this + 520) = v70[0];
  *((unsigned char *)this + 498) = (v14 < 0x1Au) & (0x3003000u >> v14);
  if (v14 <= 0x29u)
  {
    switch(v14)
    {
      case 0x16u:
        goto LABEL_21;
      case 0x17u:
        *((unsigned char *)this + 246) = 3;
        *((_WORD *)this + 120) = 8;
        __int16 v15 = 2;
        goto LABEL_66;
      case 0x1Bu:
LABEL_21:
        *((unsigned char *)this + 246) = 0;
        *((_WORD *)this + 120) = 8;
        __int16 v15 = 1;
LABEL_66:
        *((_WORD *)this + 122) = v15;
        *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
        int v38 = 1196573017;
LABEL_69:
        *((_DWORD *)this + 81) = v38;
        goto LABEL_70;
    }
    goto LABEL_67;
  }
  if (v14 - 42 < 2)
  {
    *((unsigned char *)this + 246) = 3;
    *((_WORD *)this + 120) = 16;
    *((_WORD *)this + 122) = 4;
LABEL_68:
    *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
    int v38 = 1380401696;
    goto LABEL_69;
  }
  if (v14 != 50)
  {
LABEL_67:
    *((_WORD *)this + 120) = 8;
    *((_DWORD *)this + 61) = 196612;
    goto LABEL_68;
  }
  *((unsigned char *)this + 246) = 3;
  *((_WORD *)this + 120) = 16;
  *((_WORD *)this + 122) = 4;
  *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBE8]);
  *((_DWORD *)this + 81) = 1380401696;
  *((unsigned char *)this + 247) = 1;
  *((unsigned char *)this + 249) = 1;
LABEL_70:
  int v39 = *((unsigned __int16 *)this + 121);
  if (v39 == 16)
  {
    int v40 = 1;
    *((unsigned char *)this + 247) = 1;
  }
  else if (v39 == 32)
  {
    int v40 = 0;
    *((unsigned char *)this + 247) = 0;
  }
  else
  {
    int v40 = *((unsigned __int8 *)this + 247);
  }
  __int16 v41 = *((_WORD *)this + 120);
  unsigned __int16 v42 = *((_WORD *)this + 122) * v41;
  *((_WORD *)this + 121) = v42;
  int v43 = v42;
  unint64_t v45 = *((unsigned int *)this + 57);
  unint64_t v44 = *((unsigned int *)this + 58);
  unsigned int v46 = (v45 * v43) >> 3;
  *((_DWORD *)this + 59) = v46;
  *((_DWORD *)this + 65) = v45;
  *((_DWORD *)this + 66) = v44;
  *((_DWORD *)this + 67) = v46;
  *((_WORD *)this + 136) = v41;
  int v47 = (v40 << 12) | (*((unsigned __int8 *)this + 248) << 16);
  LOBYTE(v46) = *((unsigned char *)this + 249) != 0;
  *((unsigned char *)this + 278) = *((unsigned char *)this + 246) & 0x1F;
  *((unsigned char *)this + 279) = v40 & 7;
  *((unsigned char *)this + 280) = BYTE2(v47) & 0xF;
  *((unsigned char *)this + 281) = v46;
  *((unsigned char *)this + 350) = 1;
  unint64_t v48 = *((void *)this + 23);
  if (v48 <= v45)
  {
    _cg_jpeg_mem_term("initialize", 383, "*** unexpected image size: %d x %d\n");
    goto LABEL_157;
  }
  if (v48 <= v44)
  {
    _cg_jpeg_mem_term("initialize", 384, "*** unexpected image size: %d x %d\n");
    goto LABEL_157;
  }
LABEL_77:
  unsigned int v49 = *((_DWORD *)this + 57);
  int v50 = *((_DWORD *)this + 58);
  if (v49 == v50)
  {
    int8x8_t v51 = (int8x8_t)vdup_n_s32(v49);
  }
  else
  {
    _cg_jpeg_mem_term("initialize", 696, "*** NOTE: non-square PVR - %d x %d\n", *((_DWORD *)this + 57), v50);
    int8x8_t v51 = *(int8x8_t *)((char *)this + 228);
  }
  int8x8_t v52 = vbic_s8((int8x8_t)vceqz_s32((int32x2_t)vand_s8(v51, (int8x8_t)vadd_s32((int32x2_t)v51, (int32x2_t)-1))), (int8x8_t)vceqz_s32((int32x2_t)v51));
  unsigned int v53 = v51.i32[0];
  unsigned int v54 = v51.u32[1];
  if ((v52.i32[0] & v52.i32[1] & 1) == 0)
  {
    _cg_jpeg_mem_term("initialize", 702, "*** NOTE: non-power-of-2 PVR - %d x %d\n", v51.i32[0], v51.i32[1]);
    unsigned int v53 = *((_DWORD *)this + 57);
    unsigned int v54 = *((_DWORD *)this + 58);
  }
  if (v53 < 8 || v54 <= 7)
  {
    LogError("initialize", 706, "*** ERROR: can't handle PVR - %d x %d (too small)\n");
    goto LABEL_157;
  }
  if (v53 > 0x1000 || v54 > 0x1000)
  {
    LogError("initialize", 710, "*** ERROR: can't handle PVR - %d x %d (too small)\n");
    goto LABEL_157;
  }
  if (*((_WORD *)this + 120) == 8 && *((_WORD *)this + 121) == 32)
  {
    *((_WORD *)this + 138) = 4;
    *((_DWORD *)this + 68) = 2097160;
  }
  *((unsigned char *)this + 344) = 0;
  *((unsigned char *)this + 346) = 0;
  int v55 = *((unsigned __int8 *)this + 247);
  int v56 = (v55 << 12) | (*((unsigned __int8 *)this + 248) << 16);
  BOOL v57 = *((unsigned char *)this + 249) != 0;
  *((unsigned char *)this + 278) = *((unsigned char *)this + 246) & 0x1F;
  *((unsigned char *)this + 279) = v55 & 7;
  *((unsigned char *)this + 280) = BYTE2(v56) & 0xF;
  *((unsigned char *)this + 281) = v57;
  *((unsigned char *)this + 350) = 1;
  *((_WORD *)this + 188) = 1;
  int v58 = IIO_Reader::minimumFileSize(*((IIO_Reader **)this + 3));
  uint64_t result = 0;
  *((_DWORD *)this + 50) = v58;
  return result;
}

uint64_t PVRReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12) {
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2);
  }
  if (v2 == 1) {
    return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

uint64_t PVRReadPlugin::decodeImageDataPVR(PVRReadPlugin *this, unsigned __int8 *a2)
{
  unsigned int v5 = *((_DWORD *)this + 57);
  unsigned int v4 = *((_DWORD *)this + 58);
  if (!*((_WORD *)this + 275))
  {
    unint64_t v6 = *((unsigned __int8 *)this + 520);
    if (v6 <= 3) {
      *((_WORD *)this + 275) = 0x4000400020002uLL >> (16 * v6);
    }
  }
  int v7 = *((unsigned __int8 *)this + 405);
  unint64_t v8 = PVRReadPlugin::calculateOffsetToRequestedImage(this, 52);
  unsigned int v9 = (v5 * *((unsigned __int16 *)this + 275)) >> 3;
  __int16 v10 = (unsigned __int8 *)malloc_type_calloc(v4 * (unint64_t)v9, 1uLL, 0xC6DE5CCCuLL);
  if (!v10) {
    return 4294967246;
  }
  unsigned __int32 v11 = v10;
  if (*((_DWORD *)this + 51) != 1261588566)
  {
    unint64_t v13 = v9 * v4;
    unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v10, v8, v13);
    if (BytesAtOffset) {
      BOOL v15 = BytesAtOffset == v13;
    }
    else {
      BOOL v15 = 0;
    }
    if (!v15) {
      goto LABEL_25;
    }
    goto LABEL_14;
  }
  LODWORD(dest.data) = *((_DWORD *)this + 52);
  *(void **)((char *)&dest.data + 4) = v10;
  *(_OWORD *)((char *)&dest.height + 4) = v4 * (unint64_t)v9;
  uint64_t v12 = *((void *)this + 70);
  if (!v12)
  {
    LogFault("decodeImageDataPVR", 906, "*** _pvr._ktxTexture is NULL\n");
    goto LABEL_25;
  }
  if (!(*(unsigned int (**)(void))(*(void *)(v12 + 8) + 40))())
  {
    unint64_t v13 = v9 * v4;
LABEL_14:
    memset(&dest, 0, sizeof(dest));
    int v16 = decodePVRTC(&dest, v11, v13, *((unsigned __int16 *)this + 275), *((_DWORD *)this + 52), v5, v4);
    data = dest.data;
    if (v16) {
      BOOL v18 = dest.data == 0;
    }
    else {
      BOOL v18 = 1;
    }
    if (!v18)
    {
      uint64_t height_low = LODWORD(dest.height);
      if (*((_WORD *)this + 153) == 32 && !v7)
      {
        *(_DWORD *)permuteMap = 50331906;
        vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
        data = dest.data;
      }
      size_t rowBytes = *((unsigned int *)this + 75);
      if (dest.rowBytes < rowBytes) {
        size_t rowBytes = dest.rowBytes;
      }
      memcpy(a2, data, rowBytes * height_low);
      free(data);
      uint64_t v21 = 0;
      goto LABEL_26;
    }
  }
LABEL_25:
  uint64_t v21 = 4294967246;
LABEL_26:
  free(v11);
  return v21;
}

uint64_t PVRReadPlugin::decodeImageDataV2(PVRReadPlugin *this, unsigned __int8 *a2)
{
  int v2 = *((unsigned __int8 *)this + 520);
  switch(*((unsigned char *)this + 520))
  {
    case 0:
      operator new();
    case 1:
      operator new();
    case 2:
      operator new();
    case 3:
      operator new();
    case 4:
      operator new();
    case 5:
      operator new();
    case 6:
    case 7:
    case 8:
    case 9:
    case 0xA:
    case 0xB:
    case 0xC:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x18:
    case 0x19:
    case 0x1C:
    case 0x1D:
    case 0x1E:
    case 0x1F:
    case 0x20:
    case 0x21:
    case 0x22:
    case 0x23:
    case 0x24:
    case 0x25:
    case 0x26:
    case 0x27:
    case 0x28:
    case 0x29:
      break;
    case 0x10:
      operator new();
    case 0x11:
      operator new();
    case 0x12:
      operator new();
    case 0x13:
      operator new();
    case 0x14:
      operator new();
    case 0x15:
      operator new();
    case 0x16:
      operator new();
    case 0x17:
      operator new();
    case 0x1A:
      operator new();
    case 0x1B:
      operator new();
    case 0x2A:
      operator new();
    case 0x2B:
      operator new();
    default:
      if (v2 == 50) {
        operator new();
      }
      return result;
  }
  _cg_jpeg_mem_term("decodeImageDataV2", 1104, "*** ERROR: PVRV2 PixelFormat '%02X' not handled", v2);
  return 4294967294;
}

void sub_188752774(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C401865CEE3);
  _Unwind_Resume(a1);
}

uint64_t PVRReadPlugin::decodeImageDataV3(PVRReadPlugin *this, unsigned __int8 *a2)
{
  if (*((unsigned __int8 *)this + 548) != 255) {
    operator new();
  }
  if (*((unsigned __int8 *)this + 520) <= 5u) {
    _cg_jpeg_mem_term("decodeImageDataV3", 1181, "*** PVRTC -- should be handled by: copyImageBlockSetPVR\n");
  }
  return 4294967293;
}

void sub_188752ABC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C401865CEE3);
  _Unwind_Resume(a1);
}

uint64_t PVRReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  memory_object_size_t v46 = 0;
  int v9 = *((_DWORD *)this + 73);
  if ((gIIODebugFlags & 0x20000) == 0) {
    goto LABEL_26;
  }
  int v10 = *((_DWORD *)this + 51);
  unsigned int v11 = v10 >> 24;
  uint64_t v12 = MEMORY[0x1E4F14390];
  if (v10 < 0)
  {
    int v13 = __maskrune(v11, 0x40000uLL);
    int v10 = *((_DWORD *)this + 51);
  }
  else
  {
    int v13 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v11 + 60) & 0x40000;
  }
  if (v13) {
    uint64_t v14 = (v10 >> 24);
  }
  else {
    uint64_t v14 = 46;
  }
  unsigned int v15 = v10 << 8 >> 24;
  if (v10 << 8 < 0)
  {
    int v16 = __maskrune(v15, 0x40000uLL);
    int v10 = *((_DWORD *)this + 51);
  }
  else
  {
    int v16 = *(_DWORD *)(v12 + 4 * v15 + 60) & 0x40000;
  }
  if (v16) {
    uint64_t v17 = (v10 << 8 >> 24);
  }
  else {
    uint64_t v17 = 46;
  }
  unsigned int v18 = (__int16)v10 >> 8;
  if (v10 << 16 < 0)
  {
    int v19 = __maskrune(v18, 0x40000uLL);
    int v10 = *((_DWORD *)this + 51);
  }
  else
  {
    int v19 = *(_DWORD *)(v12 + 4 * v18 + 60) & 0x40000;
  }
  if (v19) {
    uint64_t v20 = ((__int16)v10 >> 8);
  }
  else {
    uint64_t v20 = 46;
  }
  if ((v10 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v12 + 4 * (char)v10 + 60) & 0x40000) != 0) {
      goto LABEL_22;
    }
LABEL_24:
    LOBYTE(v21) = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v10, 0x40000uLL)) {
    goto LABEL_24;
  }
LABEL_22:
  int v21 = *((_DWORD *)this + 51);
LABEL_25:
  ImageIOLog("  '%c%c%c%c' [%s] %s\n", v14, v17, v20, (char)v21, iioTypeStr[a3], "virtual OSStatus PVRReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  unsigned int v22 = (IIOImageRead **)*((void *)this + 3);
  if (v22)
  {
    BOOL v23 = IIOImageReadSession::mapData(v22);
    unsigned int v22 = (IIOImageRead **)*((void *)this + 3);
  }
  else
  {
    BOOL v23 = 0;
  }
  IIOImageReadSession::rewind((uint64_t)v22);
  if (*((unsigned char *)this + 498))
  {
    char v24 = 1;
LABEL_37:
    *((unsigned char *)this + 556) = v24;
    goto LABEL_38;
  }
  if (*((_DWORD *)this + 123) != 2)
  {
    char v24 = 3;
    goto LABEL_37;
  }
  *((unsigned char *)this + 556) = 2;
  if (*((_DWORD *)this + 75) <= (*((_DWORD *)this + 118) * v9) >> 3) {
    unsigned int v25 = (*((_DWORD *)this + 118) * v9) >> 3;
  }
  else {
    unsigned int v25 = *((_DWORD *)this + 75);
  }
  *((_DWORD *)this + 75) = v25;
LABEL_38:
  if (a3 == 3)
  {
    uint64_t BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v4) = *((_DWORD *)this + 73);
    unsigned int v31 = *((_DWORD *)this + 74);
    memory_object_size_t v30 = *((unsigned int *)this + 75) * (unint64_t)v31;
    memory_object_offset_t v32 = _ImageIO_Malloc(v30, *((void *)this + 48), &v46, (uint64_t)kImageMalloc_PVR_Data[0], *((_DWORD *)this + 108), 0, 0);
    if (!v32) {
      goto LABEL_67;
    }
    BaseAddress = (void *)v32;
    double v33 = (double)v4;
    double v26 = (double)v31;
  }
  else
  {
    double v26 = 0.0;
    if (a3 == 1)
    {
      if (!a4 || !*a4)
      {
LABEL_66:
        uint64_t BlockArray = 0;
        goto LABEL_67;
      }
      IOSurfaceLock(*a4, 0, 0);
      BaseAddress = IOSurfaceGetBaseAddress(*a4);
      size_t Height = IOSurfaceGetHeight(*a4);
      uint64_t BlockArray = 0;
      memory_object_size_t v30 = IOSurfaceGetBytesPerRow(*a4) * Height;
      memory_object_size_t v46 = v30;
    }
    else
    {
      memory_object_size_t v30 = 0;
      BaseAddress = 0;
      uint64_t BlockArray = 0;
    }
    double v33 = 0.0;
  }
  bzero(BaseAddress, v30);
  int v34 = *((unsigned __int8 *)this + 556);
  switch(v34)
  {
    case 3:
      uint64_t v35 = PVRReadPlugin::decodeImageDataV3(this, (unsigned __int8 *)BaseAddress);
      break;
    case 2:
      uint64_t v35 = PVRReadPlugin::decodeImageDataV2(this, (unsigned __int8 *)BaseAddress);
      break;
    case 1:
      uint64_t v35 = PVRReadPlugin::decodeImageDataPVR(this, (unsigned __int8 *)BaseAddress);
      break;
    default:
      goto LABEL_54;
  }
  uint64_t BlockArray = v35;
LABEL_54:
  if (BlockArray)
  {
    *((_DWORD *)this + 26) = 0;
    if (a3 == 3 && BaseAddress)
    {
      _ImageIO_Free((unint64_t)BaseAddress, v46);
      if (!v23) {
        return BlockArray;
      }
      goto LABEL_68;
    }
LABEL_67:
    if (!v23) {
      return BlockArray;
    }
    goto LABEL_68;
  }
  if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 152) == 8 && *((unsigned char *)this + 406) == 1)
  {
    vImagePixelCount v36 = *((unsigned int *)this + 74);
    dest.data = BaseAddress;
    dest.CGFloat height = v36;
    size_t v37 = *((unsigned int *)this + 75);
    dest.double width = *((unsigned int *)this + 73);
    dest.size_t rowBytes = v37;
    vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
  }
  if (a3 != 3)
  {
    if (a3 == 1) {
      IOSurfaceUnlock(*a4, 0, 0);
    }
    goto LABEL_66;
  }
  uint64_t v40 = 0;
  v47.origin.double x = 0.0;
  v47.origin.double y = 0.0;
  v47.size.double width = v33;
  v47.size.CGFloat height = v26;
  **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v30, v47, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
  if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E4F1DB20]))
  {
    uint64_t v41 = 0;
  }
  else
  {
    v48.origin.double x = 0.0;
    v48.origin.double y = 0.0;
    v48.size.double width = v33;
    v48.size.CGFloat height = v26;
    *(CGRect *)(&v41 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v48);
    uint64_t v40 = v42;
    double v33 = v43;
    double v26 = v44;
  }
  uint64_t BlockArray = 0;
  *((void *)this + 15) = v40;
  *((void *)this + 16) = v41;
  *((double *)this + 17) = v33;
  *((double *)this + 18) = v26;
  if (v23)
  {
LABEL_68:
    int v38 = (const char **)*((void *)this + 3);
    if (v38) {
      IIOImageReadSession::unmapData(v38);
    }
  }
  return BlockArray;
}

uint64_t ASTCTextureImp::loadDataFromXPCObject(ASTCTextureImp *this, xpc_object_t xdict)
{
  size_t length = 0;
  data = xpc_dictionary_get_data(xdict, "iio_xpc_plugin_data_astc_imp", &length);
  if (length == 232)
  {
    long long v4 = *data;
    long long v5 = data[2];
    *((_OWORD *)this + 2) = data[1];
    *((_OWORD *)this + 3) = v5;
    *((_OWORD *)this + 1) = v4;
    long long v6 = data[3];
    long long v7 = data[4];
    long long v8 = data[6];
    *((_OWORD *)this + 6) = data[5];
    *((_OWORD *)this + 7) = v8;
    *((_OWORD *)this + 4) = v6;
    *((_OWORD *)this + 5) = v7;
    long long v9 = data[7];
    long long v10 = data[8];
    long long v11 = data[10];
    *((_OWORD *)this + 10) = data[9];
    *((_OWORD *)this + 11) = v11;
    *((_OWORD *)this + 8) = v9;
    *((_OWORD *)this + 9) = v10;
    long long v12 = data[11];
    long long v13 = data[12];
    long long v14 = data[13];
    *((void *)this + 30) = *((void *)data + 28);
    *((_OWORD *)this + 13) = v13;
    *((_OWORD *)this + 14) = v14;
    *((_OWORD *)this + 12) = v12;
    pthread_mutex_init((pthread_mutex_t *)((char *)this + 168), 0);
    *((void *)this + 7) = 0;
    *((_DWORD *)this + 58) = 0;
    *((void *)this + 30) = 0;
    *((void *)this + 9) = 0;
    *((void *)this + 10) = 0;
    *((void *)this + 16) = 0;
    *((void *)this + 17) = 0;
    *((void *)this + 15) = 0;
  }
  return 0;
}

uint64_t ASTCTextureImp::saveDataToXPCObject(ASTCTextureImp *this, void *a2)
{
  return 0;
}

uint64_t ASTCTextureImp::set_needs_hdr(uint64_t this, char a2)
{
  *(unsigned char *)(this + 42) = a2;
  return this;
}

uint64_t ASTCTextureImp::createDecodedDataFromLZFSECompressedData(ASTCTextureImp *this, IIOImageReadSession *a2, unsigned __int8 *a3, size_t a4, unsigned __int8 **a5, uint8_t **a6)
{
  *a5 = 0;
  *a6 = 0;
  if (a4)
  {
    size_t v8 = a4;
    memset(&v14, 0, sizeof(v14));
    if (compression_stream_init(&v14, COMPRESSION_STREAM_DECODE, COMPRESSION_LZFSE) == COMPRESSION_STATUS_OK)
    {
      v14.src_ptr = a3;
      v14.src_size_t size = v8;
      long long v10 = malloc_type_malloc(v8, 0x75FE6B69uLL);
      long long v11 = 0;
      while (1)
      {
        if ((unint64_t)v11 >= v8)
        {
          v8 += v8 >> 1;
          long long v10 = reallocf(v10, v8);
        }
        v14.dst_ptr = &v11[(void)v10];
        v14.dst_size_t size = v8 - (void)v11;
        compression_status v12 = compression_stream_process(&v14, 0);
        if (v12 == COMPRESSION_STATUS_ERROR) {
          break;
        }
        long long v11 = (uint8_t *)(v14.dst_ptr - (uint8_t *)v10);
        if (v12 == COMPRESSION_STATUS_END)
        {
          compression_stream_destroy(&v14);
          uint64_t result = 0;
          *a5 = (unsigned __int8 *)v10;
          *a6 = v11;
          return result;
        }
      }
      free(v10);
      compression_stream_destroy(&v14);
    }
  }
  return 4294967243;
}

uint64_t ASTCTextureImp::BlockFormatForASTCBlockSize(ASTCTextureImp *this, char a2)
{
  unsigned int v2 = (a2 | (16 * (_BYTE)this));
  if (v2 > 0x87)
  {
    if ((a2 | (16 * (_BYTE)this)) > 0xC9u)
    {
      uint64_t v11 = 14;
      if (v2 != 204) {
        uint64_t v11 = 0;
      }
      if (v2 == 202) {
        return 13;
      }
      else {
        return v11;
      }
    }
    else
    {
      uint64_t result = 0;
      switch(v2)
      {
        case 0xA5u:
          uint64_t result = 9;
          break;
        case 0xA6u:
          uint64_t result = 10;
          break;
        case 0xA7u:
        case 0xA9u:
          return result;
        case 0xA8u:
          uint64_t result = 11;
          break;
        case 0xAAu:
          uint64_t result = 12;
          break;
        default:
          if (v2 == 136) {
            uint64_t result = 8;
          }
          else {
            uint64_t result = 0;
          }
          break;
      }
    }
  }
  else
  {
    uint64_t v3 = 6;
    uint64_t v4 = 7;
    if (v2 != 134) {
      uint64_t v4 = 0;
    }
    if (v2 != 133) {
      uint64_t v3 = v4;
    }
    uint64_t v5 = 4;
    uint64_t v6 = 5;
    if (v2 != 102) {
      uint64_t v6 = 0;
    }
    if (v2 != 101) {
      uint64_t v5 = v6;
    }
    if ((a2 | (16 * (_BYTE)this)) <= 0x84u) {
      uint64_t v3 = v5;
    }
    uint64_t v7 = 1;
    uint64_t v8 = 2;
    uint64_t v9 = 3;
    if (v2 != 85) {
      uint64_t v9 = 0;
    }
    if (v2 != 84) {
      uint64_t v8 = v9;
    }
    if (v2 != 68) {
      uint64_t v7 = v8;
    }
    if ((a2 | (16 * (_BYTE)this)) <= 0x64u) {
      return v7;
    }
    else {
      return v3;
    }
  }
  return result;
}

uint64_t ASTCTextureImp::HDRBlockFormat(ASTCTextureImp *this, at_block_format_t a2)
{
  if ((unint64_t)this - 1 >= 0xE) {
    return 0;
  }
  else {
    return (uint64_t)this + 16;
  }
}

uint64_t ASTCTextureImp::MetalFormatForVulkanFormat(ASTCTextureImp *this)
{
  int v1 = this - 157;
  uint64_t result = 204;
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      uint64_t result = 186;
      break;
    case 2:
      uint64_t result = 205;
      break;
    case 3:
      uint64_t result = 187;
      break;
    case 4:
      uint64_t result = 206;
      break;
    case 5:
      uint64_t result = 188;
      break;
    case 6:
      uint64_t result = 207;
      break;
    case 7:
      uint64_t result = 189;
      break;
    case 8:
      uint64_t result = 208;
      break;
    case 9:
      uint64_t result = 190;
      break;
    case 10:
      uint64_t result = 210;
      break;
    case 11:
      uint64_t result = 192;
      break;
    case 12:
      uint64_t result = 211;
      break;
    case 13:
      uint64_t result = 193;
      break;
    case 14:
      uint64_t result = 212;
      break;
    case 15:
      uint64_t result = 194;
      break;
    case 16:
      uint64_t result = 213;
      break;
    case 17:
      uint64_t result = 195;
      break;
    case 18:
      uint64_t result = 214;
      break;
    case 19:
      uint64_t result = 196;
      break;
    case 20:
      uint64_t result = 215;
      break;
    case 21:
      uint64_t result = 197;
      break;
    case 22:
      uint64_t result = 216;
      break;
    case 23:
      uint64_t result = 198;
      break;
    case 24:
      uint64_t result = 217;
      break;
    case 25:
      uint64_t result = 199;
      break;
    case 26:
      uint64_t result = 218;
      break;
    case 27:
      uint64_t result = 200;
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t ASTCTextureImp::cacheImmediately(ASTCTextureImp *this, IIOImageReadSession *a2, const __CFDictionary *a3, CGImage *a4)
{
  uint64_t v6 = (pthread_mutex_t *)((char *)this + 168);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 168));
  if (!*((void *)this + 10))
  {
    if (*((unsigned char *)this + 41))
    {
      if (*((unsigned char *)this + 40)) {
        LogError("cacheImmediately", 751, "*** pre-twiddled LZFSE compressed ASTC is not supported\n");
      }
      else {
        ASTCTextureImp::createTwiddledDataFromTwiddled(this, a2);
      }
    }
    else if (*((unsigned char *)this + 40))
    {
      ASTCTextureImp::createTwiddledDataFromLinearLZFSE(this, a2, 0);
    }
    else
    {
      ASTCTextureImp::createTwiddledDataFromLinear(this, a2, 0);
    }
  }

  return pthread_mutex_unlock(v6);
}

void ASTCTextureImp::createLinearDataFromLinear(ASTCTextureImp *this, IIOImageReadSession *a2)
{
  uint64_t v3 = *((void *)this + 15);
  if (v3
    || (*((void *)this + 15) = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)this + 16, 1),
        uint64_t v5 = (const void *)IIOImageSource::cf(a2),
        *((void *)this + 17) = v5,
        CFRetain(v5),
        (uint64_t v3 = *((void *)this + 15)) != 0))
  {
    *((void *)this + 7) = v3 + *((void *)this + 14);
    *((unsigned char *)this + 43) = 1;
  }
  else
  {
    _cg_jpeg_mem_term("createLinearDataFromLinear", 979, "*** Can't access image data\n");
    *((void *)this + 7) = 0;
  }
}

uint64_t ASTCTextureImp::decodeRGBXFromLinear(ASTCTextureImp *this, IIOImageReadSession *a2, vImage_Buffer *a3, at_alpha_t a4, at_block_format_t a5, at_texel_format_t a6)
{
  unsigned int v31 = 0;
  compression_status v12 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v31, 0);
  unint64_t Size = IIOImageReadSession::getSize(a2);
  uint64_t v14 = *((void *)this + 14);
  unint64_t v15 = (unint64_t)Size - v14;
  if ((uint64_t)Size - v14 <= 0)
  {
    IIOImageReadSession::getSize(a2);
    _cg_jpeg_mem_term("decodeRGBXFromLinear", 1159, "*** ERROR: truncated file? (fileSize: %lld  textureOffset: %lld\n)\n");
    goto LABEL_25;
  }
  if (v15 < (unint64_t)(float)((float)(*((float *)this + 9)
                                             * (float)(*((_DWORD *)this + 26) * *((_DWORD *)this + 25)))
                                     * 0.125))
  {
    _cg_jpeg_mem_term("decodeRGBXFromLinear", 1162, "*** bad input data (input size: %ld  bytesNeeded: %d  (%d x %d) bpp: %g)\n");
    goto LABEL_25;
  }
  if (v12)
  {
    int v16 = (char *)v12 + v14;
    if ((v16 & 0xF) == 0)
    {
      unsigned int v18 = 0;
      goto LABEL_10;
    }
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v31);
    unsigned int v31 = 0;
  }
  int v16 = malloc_type_malloc(v15, 0xA55E2EA2uLL);
  unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v16, *((void *)this + 14), v15);
  if (v15 == BytesAtOffset)
  {
    unsigned int v18 = v16;
    if (!v16)
    {
      _cg_jpeg_mem_term("decodeRGBXFromLinear", 1186, "*** tempLinearBuffer is nil\n");
LABEL_25:
      uint64_t v27 = 4294967246;
      goto LABEL_19;
    }
LABEL_10:
    int v19 = at_encoder_create(a6, a4, a5, a4, 0);
    if (!v19)
    {
      uint64_t v27 = 4294967246;
      if (!v18) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
    uint64_t v20 = v19;
    vImagePixelCount height = a3->height;
    dest.texels = a3->data;
    size_t rowBytes = a3->rowBytes;
    dest.validSize.double x = a3->width;
    dest.validSize.double y = height;
    *((_DWORD *)&dest.validSize + 3) = 0;
    dest.size_t rowBytes = rowBytes;
    dest.validSize.z = 1;
    dest.sliceunint64_t Bytes = 0;
    *(void *)&v32.double x = *(void *)&dest.validSize.x;
    v32.z = 1;
    unint64_t block_counts = (unint64_t)at_encoder_get_block_counts(v19, v32);
    unint64_t v24 = HIDWORD(block_counts);
    src.blocks = v16;
    unsigned int v25 = block_counts;
    src.size_t rowBytes = at_encoder_get_block_size(v20) * block_counts;
    src.sliceunint64_t Bytes = v24 * (unint64_t)v25 * at_encoder_get_block_size(v20);
    if (v15 >= src.sliceBytes)
    {
      at_error_t v26 = at_encoder_decompress_texels(v20, &src, &dest, at_flags_default);
      if (v26 == at_error_success)
      {
        uint64_t v27 = 0;
LABEL_15:

        if (!v18) {
          goto LABEL_19;
        }
LABEL_18:
        free(v18);
        goto LABEL_19;
      }
      LogError("decodeRGBXFromLinear", 1226, "at_encoder_decompress_texels returned: %ld\n", v26);
    }
    uint64_t v27 = 4294967246;
    goto LABEL_15;
  }
  _cg_jpeg_mem_term("decodeRGBXFromLinear", 1183, "got: %ld expected: %ld\n", BytesAtOffset, v15);
  uint64_t v27 = 4294967246;
  unsigned int v18 = v16;
  if (v16) {
    goto LABEL_18;
  }
LABEL_19:
  if (v31) {
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v31);
  }
  return v27;
}

uint64_t ASTCTextureImp::decodeRGBXFromMemory(ASTCTextureImp *this, void *a2, size_t a3, vImage_Buffer *a4, uint64_t texelAlphaType, at_block_format_t blockType, at_texel_format_t texelType)
{
  if (!a2)
  {
    _cg_jpeg_mem_term("decodeRGBXFromMemory", 1257, "*** srcBuffer is nil\n", a4, texelAlphaType, blockType, texelType);
    return 4294967246;
  }
  long long v10 = at_encoder_create(texelType, (at_alpha_t)texelAlphaType, blockType, (at_alpha_t)texelAlphaType, 0);
  if (!v10) {
    return 4294967246;
  }
  uint64_t v11 = v10;
  vImagePixelCount height = a4->height;
  dest.texels = a4->data;
  size_t rowBytes = a4->rowBytes;
  dest.validSize.double x = a4->width;
  dest.validSize.double y = height;
  *((_DWORD *)&dest.validSize + 3) = 0;
  dest.size_t rowBytes = rowBytes;
  dest.validSize.z = 1;
  dest.sliceunint64_t Bytes = 0;
  *(void *)&v22.double x = *(void *)&dest.validSize.x;
  v22.z = 1;
  unint64_t block_counts = (unint64_t)at_encoder_get_block_counts(v10, v22);
  unsigned int v15 = block_counts;
  unint64_t v16 = HIDWORD(block_counts);
  src.blocks = a2;
  src.size_t rowBytes = at_encoder_get_block_size(v11) * block_counts;
  src.sliceunint64_t Bytes = v16 * (unint64_t)v15 * at_encoder_get_block_size(v11);
  if (src.sliceBytes > a3)
  {

    return 4294967246;
  }
  at_error_t v18 = at_encoder_decompress_texels(v11, &src, &dest, at_flags_default);
  if (v18)
  {
    LogError("decodeRGBXFromMemory", 1292, "at_encoder_decompress_texels returned: %ld\n", v18);
    uint64_t v17 = 4294967246;
  }
  else
  {
    uint64_t v17 = 0;
  }

  return v17;
}

uint64_t ASTCTextureImp::decodeRGBXFromLinearLZFSE(ASTCTextureImp *this, IIOImageReadSession *a2, vImage_Buffer *a3, at_alpha_t a4, at_block_format_t a5, at_texel_format_t a6)
{
  uint64_t v42 = 0;
  compression_status v12 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v42, 0);
  unint64_t Size = IIOImageReadSession::getSize(a2);
  if (v12)
  {
    unsigned int v15 = 0;
    uint64_t v16 = *((void *)this + 6);
    uint64_t v17 = (unsigned __int8 *)v12 + v16;
    uint64_t v18 = *((unsigned int *)this + 11);
  }
  else
  {
    unsigned int v15 = (unsigned __int8 *)malloc_type_malloc(*((unsigned int *)this + 11), 0xC0A2AC22uLL);
    unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v15, *((void *)this + 6), *((unsigned int *)this + 11));
    uint64_t v18 = *((unsigned int *)this + 11);
    if (BytesAtOffset != v18)
    {
      _cg_jpeg_mem_term("decodeRGBXFromLinearLZFSE", 1332, "got: %ld expected: %ld\n", BytesAtOffset, v18);
LABEL_7:
      uint64_t v21 = 4294967246;
      if (!v15) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }
    uint64_t v16 = *((void *)this + 6);
    uint64_t v17 = v15;
  }
  *((void *)this + 8) = 0;
  uint64_t v20 = (size_t *)((char *)this + 64);
  if (v16 + v18 > (unint64_t)Size)
  {
    LogError("decodeRGBXFromLinearLZFSE", 1340, "*** bad file ***  (fileSize: %ld   compressedDataOffset: %ld   compressedSize: %ld\n", Size, v16, v18);
    goto LABEL_7;
  }
  blockint Type = a5;
  BOOL v23 = (void *)*((void *)this + 7);
  if (v23) {
    free(v23);
  }
  *((void *)this + 7) = 0;
  DecodedDataFromLZFSECompresseduint64_t Data = ASTCTextureImp::createDecodedDataFromLZFSECompressedData((ASTCTextureImp *)v23, v13, v17, *((unsigned int *)this + 11), (unsigned __int8 **)this + 7, (uint8_t **)this + 8);
  if (DecodedDataFromLZFSECompressedData)
  {
    uint64_t v21 = DecodedDataFromLZFSECompressedData;
    if (!v15) {
      goto LABEL_9;
    }
LABEL_8:
    free(v15);
    goto LABEL_9;
  }
  unsigned int v25 = at_encoder_create(a6, a4, a5, a4, 0);
  if (v25)
  {
    at_error_t v26 = v25;
    vImagePixelCount height = a3->height;
    dest.texels = a3->data;
    size_t rowBytes = a3->rowBytes;
    dest.validSize.double x = a3->width;
    dest.validSize.double y = height;
    *((_DWORD *)&dest.validSize + 3) = 0;
    dest.size_t rowBytes = rowBytes;
    dest.validSize.z = 1;
    dest.sliceunint64_t Bytes = 0;
    unsigned int v29 = height;
    *(void *)&v43.double x = *(void *)&dest.validSize.x;
    v43.z = 1;
    unint64_t block_counts = (unint64_t)at_encoder_get_block_counts(v25, v43);
    unint64_t v31 = HIDWORD(block_counts);
    src.blocks = (void *)*((void *)this + 7);
    unsigned int v32 = block_counts;
    src.size_t rowBytes = at_encoder_get_block_size(v26) * block_counts;
    src.sliceunint64_t Bytes = v31 * (unint64_t)v32 * at_encoder_get_block_size(v26);
    float v33 = (float)*((unint64_t *)this + 8);
    float v34 = (float)(a3->height * a3->width);
    if ((float)((float)(ASTCBitsPerPixel(*((unsigned __int8 *)this + 28), *((unsigned __int8 *)this + 32)) * v34)
               * 0.125) > v33)
    {
      _cg_jpeg_mem_term("decodeRGBXFromLinearLZFSE", 1373, "*** bad linearDataSize: %d for image: %dx%d\n", *v20, a3->width, a3->height);
    }
    else
    {
      outunint64_t Size = 0;
      *(void *)&v44.double x = *(void *)&dest.validSize.x;
      v44.z = 1;
      v35.bits = at_block_get_features(blockType, &src, v44, Size, &outSize, at_flags_default).bits;
      if (outSize > *v20)
      {
        size_t v36 = *v20 / src.rowBytes * ((v35.bits >> 22) & 0xFFF);
        if (v36 >= 0xFFFFFFFF) {
          LODWORD(v36) = -1;
        }
        if (v36 >= v29) {
          LODWORD(v36) = v29;
        }
        dest.validSize.double y = v36;
      }
      at_error_t v37 = at_encoder_decompress_texels(v26, &src, &dest, at_flags_default);
      if (v37) {
        LogError("decodeRGBXFromLinearLZFSE", 1389, "at_encoder_decompress_texels returned: %ld\n", v37);
      }
    }
  }
  uint64_t v21 = 0;
  if (v15) {
    goto LABEL_8;
  }
LABEL_9:
  if (v42) {
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v42);
  }
  return v21;
}

uint64_t ASTCTextureImp::decodeRGBXFromTwiddled(ASTCTextureImp *this, IIOImageReadSession *a2, vImage_Buffer *a3, at_alpha_t a4, at_block_format_t a5, at_texel_format_t a6)
{
  uint64_t v14 = 0;
  if (IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v14, 0)) {
LABEL_2:
  }
    operator new();
  unint64_t Size = IIOImageReadSession::getSize(a2);
  uint64_t v9 = (IIOImageRead *)*((void *)this + 14);
  unint64_t v10 = Size - v9;
  if (Size != v9)
  {
    uint64_t v11 = malloc_type_malloc(Size - v9, 0x3AF8B7C8uLL);
    unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v11, *((void *)this + 14), v10);
    if (v10 == BytesAtOffset)
    {
      if (v11) {
        goto LABEL_2;
      }
    }
    else
    {
      _cg_jpeg_mem_term("decodeRGBXFromTwiddled", 1446, "got: %ld expected: %ld\n", BytesAtOffset, v10);
      if (v11) {
        free(v11);
      }
    }
  }
  if (v14) {
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v14);
  }
  return 0;
}

void sub_188754018(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

uint64_t ASTCTextureImp::decodeASTCtoRGBX(ASTCTextureImp *this, IIOImageReadSession *a2, vImage_Buffer *a3, int a4, int a5)
{
  if (ASTCTextureImp::decodeASTCtoRGBX(IIOImageReadSession *,vImage_Buffer *,CGImageAlphaInfo,BOOL)::once != -1) {
    dispatch_once(&ASTCTextureImp::decodeASTCtoRGBX(IIOImageReadSession *,vImage_Buffer *,CGImageAlphaInfo,BOOL)::once, &__block_literal_global_91);
  }
  if (a4 > 2) {
    at_alpha_t v10 = at_alpha_not_premultiplied;
  }
  else {
    at_alpha_t v10 = dword_188991658[a4];
  }
  uint64_t v11 = (pthread_mutex_t *)((char *)this + 168);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 168));
  compression_status v12 = (ASTCTextureImp *)ASTCTextureImp::BlockFormatForASTCBlockSize((ASTCTextureImp *)*((unsigned __int8 *)this + 28), *((unsigned char *)this + 32));
  at_block_format_t v14 = (at_block_format_t)v12;
  if (a5) {
    at_texel_format_t v15 = at_texel_format_bgra8_unorm;
  }
  else {
    at_texel_format_t v15 = at_texel_format_rgba8_unorm;
  }
  if (*((unsigned char *)this + 42))
  {
    at_block_format_t v14 = ASTCTextureImp::HDRBlockFormat(v12, v13);
    at_texel_format_t v15 = at_texel_format_rgba16_float;
  }
  if (!*((unsigned char *)this + 41))
  {
    if (*((unsigned char *)this + 40))
    {
      if ((gIIODebugFlags & 0x20000) != 0) {
        ImageIOLog("  'ASTC' %d: decodeRGBXFromLinearLZFSE [%d x %d]\n", 1599, *((_DWORD *)this + 25), *((_DWORD *)this + 26));
      }
      unsigned int v17 = ASTCTextureImp::decodeRGBXFromLinearLZFSE(this, a2, a3, v10, v14, v15);
      if (v17)
      {
        unsigned int v16 = v17;
        _cg_jpeg_mem_term("decodeASTCtoRGBX", 1603, "*** ERROR: decodeRGBXFromLinearLZFSE failed [%d]\n");
        goto LABEL_29;
      }
    }
    else
    {
      if ((gIIODebugFlags & 0x20000) != 0) {
        ImageIOLog("  'ASTC' %d: decodeRGBXFromLinear [%d x %d]\n", 1591, *((_DWORD *)this + 25), *((_DWORD *)this + 26));
      }
      unsigned int v19 = ASTCTextureImp::decodeRGBXFromLinear(this, a2, a3, v10, v14, v15);
      if (v19)
      {
        unsigned int v16 = v19;
        _cg_jpeg_mem_term("decodeASTCtoRGBX", 1595, "*** ERROR: decodeRGBXFromLinear failed [%d]\n", v19);
        goto LABEL_29;
      }
    }
    goto LABEL_38;
  }
  if (!*((unsigned char *)this + 40))
  {
    if (!ASTCTextureImp::decodeASTCtoRGBX(IIOImageReadSession *,vImage_Buffer *,CGImageAlphaInfo,BOOL)::gUntwiddle) {
      goto LABEL_14;
    }
    if ((gIIODebugFlags & 0x20000) != 0) {
      ImageIOLog("  'ASTC' %d: decodeRGBXFromTwiddled [%d x %d]\n", 1613, *((_DWORD *)this + 25), *((_DWORD *)this + 26));
    }
    unsigned int v18 = ASTCTextureImp::decodeRGBXFromTwiddled(this, a2, a3, v10, v14, v15);
    if (v18)
    {
      unsigned int v16 = v18;
      _cg_jpeg_mem_term("decodeASTCtoRGBX", 1616, "*** ERROR: decodeRGBXFromTwiddled failed [%d]\n");
      goto LABEL_29;
    }
LABEL_38:
    uint64_t v24 = 0;
    goto LABEL_37;
  }
  LogError("decodeASTCtoRGBX", 1621, "*** pre-twiddled LZFSE compressed ASTC is not supported\n");
LABEL_14:
  unsigned int v16 = -50;
LABEL_29:
  vImagePixelCount height = a3->height;
  if (height)
  {
    data = (char *)a3->data;
    vImagePixelCount width = a3->width;
    size_t rowBytes = a3->rowBytes;
    do
    {
      if (width) {
        memset_pattern16(data, &unk_188991670, 4 * width);
      }
      data += rowBytes;
      --height;
    }
    while (height);
  }
  if (ASTCTextureImp::decodeASTCtoRGBX(IIOImageReadSession *,vImage_Buffer *,CGImageAlphaInfo,BOOL)::gUntwiddle) {
    uint64_t v24 = v16;
  }
  else {
    uint64_t v24 = 0;
  }
LABEL_37:
  pthread_mutex_unlock(v11);
  return v24;
}

__n128 ___ZN14ASTCTextureImp16decodeASTCtoRGBXEP19IIOImageReadSessionP13vImage_Buffer16CGImageAlphaInfob_block_invoke()
{
  ASTCTextureImp::decodeASTCtoRGBX(IIOImageReadSession *,vImage_Buffer *,CGImageAlphaInfo,BOOL)::gUntwiddle = IOPreferencesGetBoolean("ImageIO_untwiddle_for_CG", 1, 0);
  if ((ASTCTextureImp::decodeASTCtoRGBX(IIOImageReadSession *,vImage_Buffer *,CGImageAlphaInfo,BOOL)::gUntwiddle & 1) == 0)
  {
    return _cg_jpeg_mem_term("decodeASTCtoRGBX_block_invoke", 1563, "*** ATX pre-twiddled data will show up as blue rects\n");
  }
  return result;
}

uint64_t ASTCTextureImp::decodeASTCtoRGBX(ASTCTextureImp *this, void *a2, size_t a3, vImage_Buffer *a4, unsigned int a5, int a6)
{
  if (a5 > 2) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = dword_188991658[a5];
  }
  compression_status v12 = (pthread_mutex_t *)((char *)this + 168);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 168));
  at_block_format_t v13 = (ASTCTextureImp *)ASTCTextureImp::BlockFormatForASTCBlockSize((ASTCTextureImp *)*((unsigned __int8 *)this + 28), *((unsigned char *)this + 32));
  if (a6) {
    at_texel_format_t v15 = at_texel_format_bgra8_unorm;
  }
  else {
    at_texel_format_t v15 = at_texel_format_rgba8_unorm;
  }
  if (*((unsigned char *)this + 42))
  {
    at_block_format_t v13 = (ASTCTextureImp *)ASTCTextureImp::HDRBlockFormat(v13, v14);
    at_texel_format_t v15 = at_texel_format_rgba16_float;
  }
  uint64_t v16 = ASTCTextureImp::decodeRGBXFromMemory(v13, a2, a3, a4, v11, (at_block_format_t)v13, v15);
  if (v16)
  {
    vImagePixelCount height = a4->height;
    if (height)
    {
      data = (char *)a4->data;
      vImagePixelCount width = a4->width;
      size_t rowBytes = a4->rowBytes;
      do
      {
        if (width) {
          memset_pattern16(data, &unk_188991670, 4 * width);
        }
        data += rowBytes;
        --height;
      }
      while (height);
    }
  }
  pthread_mutex_unlock(v12);
  return v16;
}

void TXMPMeta<std::string>::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD **)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)(a1 + 8) = v3;
  WXMPMeta_IncrementRefCount_1(v3);

  WXMPMeta_DecrementRefCount_1(v2);
}

void *TXMPMeta<std::string>::TXMPMeta(void *a1, uint64_t a2)
{
  *a1 = &unk_1ED4E5BD8;
  a1[1] = a2;
  WXMPMeta_IncrementRefCount_1(a2);
  return a1;
}

void sub_18875459C(void *a1)
{
  __cxa_begin_catch(a1);
  WXMPMeta_DecrementRefCount_1(*(_DWORD **)(v1 + 8));
  *(void *)(v1 + 8) = 0;
  __cxa_rethrow();
}

void sub_1887545B4(_Unwind_Exception *a1)
{
}

void TXMPMeta<std::string>::~TXMPMeta(uint64_t a1)
{
  TXMPMeta<std::string>::~TXMPMeta(a1);

  JUMPOUT(0x18C11C0E0);
}

BOOL TXMPMeta<std::string>::RegisterNamespace(XMPMeta *a1, char *a2, uint64_t a3)
{
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPMeta_RegisterNamespace_1(a1, a2, a3, (uint64_t (*)(uint64_t, void, void))TXMPMeta<std::string>::SetClientString, (unsigned int *)v6);
  if (*(void *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v5 = *(void *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((unsigned char *)exception + 16) = 0;
  }
  return v7 != 0;
}

BOOL TXMPMeta<std::string>::GetProperty(uint64_t a1, unsigned char *a2, unsigned char *a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  WXMPMeta_GetProperty_1(*(void *)(a1 + 8), a2, a3, a4, a5, (void (*)(uint64_t, uint64_t, void))TXMPMeta<std::string>::SetClientString, (uint64_t)v8);
  if (*(void *)&v8[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v7 = *(void *)&v8[0];
    *(_DWORD *)exception = v9;
    exception[1] = v7;
    *((unsigned char *)exception + 16) = 0;
  }
  return v9 != 0;
}

BOOL TXMPMeta<std::string>::GetArrayItem(uint64_t a1, unsigned char *a2, unsigned char *a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPMeta_GetArrayItem_1(*(void *)(a1 + 8), a2, a3, a4, a5, a6, (void (*)(uint64_t, uint64_t, void))TXMPMeta<std::string>::SetClientString, (uint64_t)v9);
  if (*(void *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v8 = *(void *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
    *((unsigned char *)exception + 16) = 0;
  }
  return v10 != 0;
}

void TXMPMeta<std::string>::SetProperty(uint64_t a1, unsigned char *a2, unsigned char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPMeta_SetProperty_1(*(void *)(a1 + 8), a2, a3, a4, a5, v7);
  if (*(void *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v6 = *(void *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::AppendArrayItem(uint64_t a1, unsigned char *a2, unsigned char *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  WXMPMeta_AppendArrayItem_1(*(void *)(a1 + 8), a2, a3, a4, a5, a6, v8);
  if (*(void *)&v8[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v7 = *(void *)&v8[0];
    *(_DWORD *)exception = v9;
    exception[1] = v7;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SetStructField(uint64_t a1, char *a2, char *a3, char *a4, char *a5, const char *a6, uint64_t a7)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPMeta_SetStructField_1(*(void *)(a1 + 8), a2, a3, a4, a5, a6, a7, v9);
  if (*(void *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v8 = *(void *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SetQualifier(uint64_t a1, unsigned char *a2, unsigned char *a3, unsigned char *a4, unsigned char *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPMeta_SetQualifier_1(*(void *)(a1 + 8), a2, a3, a4, a5, a6, a7, v9);
  if (*(void *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v8 = *(void *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::DeleteProperty(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  WXMPMeta_DeleteProperty_1(*(void *)(a1 + 8), a2, a3, v5);
  if (*(void *)&v5[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v4 = *(void *)&v5[0];
    *(_DWORD *)exception = v6;
    exception[1] = v4;
    *((unsigned char *)exception + 16) = 0;
  }
}

BOOL TXMPMeta<std::string>::DoesPropertyExist(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPMeta_DoesPropertyExist_1(*(void *)(a1 + 8), a2, a3, (uint64_t)v6);
  if (*(void *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v5 = *(void *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((unsigned char *)exception + 16) = 0;
  }
  return v7 != 0;
}

BOOL TXMPMeta<std::string>::GetProperty_Bool(uint64_t a1, const char *a2, const char *a3, unsigned char *a4, unsigned int *a5)
{
  BOOL v12 = 0;
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  WXMPMeta_GetProperty_Bool_1(*(void *)(a1 + 8), a2, a3, &v12, a5, (uint64_t)v10);
  if (*(void *)&v10[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v9 = *(void *)&v10[0];
    *(_DWORD *)exception = v11;
    exception[1] = v9;
    *((unsigned char *)exception + 16) = 0;
  }
  int v6 = v11;
  if (a4 && v11) {
    *a4 = v12;
  }
  return v6 != 0;
}

BOOL TXMPMeta<std::string>::GetProperty_Int(uint64_t a1, const char *a2, const char *a3, int *a4, unsigned int *a5)
{
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  WXMPMeta_GetProperty_Int_1(*(void *)(a1 + 8), a2, a3, a4, a5, (uint64_t)v8);
  if (*(void *)&v8[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v7 = *(void *)&v8[0];
    *(_DWORD *)exception = v9;
    exception[1] = v7;
    *((unsigned char *)exception + 16) = 0;
  }
  return v9 != 0;
}

BOOL TXMPMeta<std::string>::GetProperty_Date(uint64_t a1, unsigned char *a2, unsigned char *a3, long long *a4, int *a5)
{
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  WXMPMeta_GetProperty_Date_1(*(void *)(a1 + 8), a2, a3, a4, a5, (uint64_t)v8);
  if (*(void *)&v8[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v7 = *(void *)&v8[0];
    *(_DWORD *)exception = v9;
    exception[1] = v7;
    *((unsigned char *)exception + 16) = 0;
  }
  return v9 != 0;
}

void TXMPMeta<std::string>::SetProperty_Bool(uint64_t a1, const char *a2, const char *a3, int a4, uint64_t a5)
{
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPMeta_SetProperty_Bool_1(*(void *)(a1 + 8), a2, a3, a4, a5, v7);
  if (*(void *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v6 = *(void *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SetProperty_Int(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPMeta_SetProperty_Int_1(*(void *)(a1 + 8), a2, a3, a4, a5, v7);
  if (*(void *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v6 = *(void *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SetProperty_Int64(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPMeta_SetProperty_Int64_1(*(void *)(a1 + 8), a2, a3, a4, a5, v7);
  if (*(void *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v6 = *(void *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SetProperty_Float(uint64_t a1, const char *a2, const char *a3, uint64_t a4, double a5)
{
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPMeta_SetProperty_Float_1(*(void *)(a1 + 8), a2, a3, a4, v7, a5);
  if (*(void *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v6 = *(void *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SetProperty_Date(uint64_t a1, unsigned char *a2, unsigned char *a3, long long *a4, uint64_t a5)
{
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPMeta_SetProperty_Date_1(*(void *)(a1 + 8), a2, a3, a4, a5, v7);
  if (*(void *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v6 = *(void *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((unsigned char *)exception + 16) = 0;
  }
}

BOOL TXMPMeta<std::string>::GetLocalizedText(uint64_t a1, unsigned char *a2, unsigned char *a3, const char *a4, unsigned char *a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  uint64_t v12 = 0;
  memset(v11, 0, sizeof(v11));
  WXMPMeta_GetLocalizedText_1(*(void *)(a1 + 8), a2, a3, a4, a5, a6, a7, a8, (void (*)(uint64_t, uint64_t, void))TXMPMeta<std::string>::SetClientString, (uint64_t)v11);
  if (*(void *)&v11[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v10 = *(void *)&v11[0];
    *(_DWORD *)exception = v12;
    exception[1] = v10;
    *((unsigned char *)exception + 16) = 0;
  }
  return v12 != 0;
}

void TXMPMeta<std::string>::SetLocalizedText(uint64_t a1, unsigned char *a2, unsigned char *a3, const char *a4, unsigned char *a5, const char *a6, uint64_t a7)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPMeta_SetLocalizedText_1(*(void *)(a1 + 8), a2, a3, a4, a5, a6, a7, v9);
  if (*(void *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v8 = *(void *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SerializeToBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, const char *a6, uint64_t a7)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPMeta_SerializeToBuffer_1(*(void *)(a1 + 8), a2, a3, a4, a5, a6, a7, (void (*)(uint64_t, void *, uint64_t))TXMPMeta<std::string>::SetClientString, v9);
  if (*(void *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v8 = *(void *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPMeta<std::string>::SerializeToBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void TXMPMeta<std::string>::Clone(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = 0;
  memset(v2, 0, sizeof(v2));
  WXMPMeta_Clone_1(*(void *)(a1 + 8), a2, v2);
}

uint64_t TXMPMeta<std::string>::CountArrayItems(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPMeta_CountArrayItems_1(*(void *)(a1 + 8), a2, a3, (uint64_t)v6);
  if (*(void *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v5 = *(void *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((unsigned char *)exception + 16) = 0;
  }
  return v7;
}

uint64_t WrapErrorNotify(uint64_t (*a1)(void *, uint64_t, uint64_t, const char *), void *a2, uint64_t a3, uint64_t a4, const char *a5)
{
  return a1(a2, a3, a4, a5);
}

void sub_188755044(void *a1)
{
}

void TXMPIterator<std::string>::~TXMPIterator(uint64_t a1)
{
  TXMPIterator<std::string>::~TXMPIterator(a1);

  JUMPOUT(0x18C11C0E0);
}

void TXMPUtils<std::string>::ComposeArrayItemPath(char *a1, char *a2, int a3, uint64_t a4)
{
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPUtils_ComposeArrayItemPath_1(a1, a2, a3, a4, (void (*)(uint64_t, std::string *, uint64_t))TXMPUtils<std::string>::SetClientString, v6);
  if (*(void *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v5 = *(void *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPUtils<std::string>::SetClientString()
{
}

void TXMPUtils<std::string>::ComposeStructFieldPath(char *a1, char *a2, char *a3, unsigned char *a4, uint64_t a5)
{
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPUtils_ComposeStructFieldPath_1(a1, a2, a3, a4, a5, (void (*)(uint64_t, std::string *, uint64_t))TXMPUtils<std::string>::SetClientString, v7);
  if (*(void *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v6 = *(void *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPUtils<std::string>::ConvertFromFloat(const char *a1, uint64_t a2, double a3)
{
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  WXMPUtils_ConvertFromFloat_1(a1, a2, (void (*)(uint64_t, std::string *, uint64_t))TXMPUtils<std::string>::SetClientString, v5, a3);
  if (*(void *)&v5[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v4 = *(void *)&v5[0];
    *(_DWORD *)exception = v6;
    exception[1] = v4;
    *((unsigned char *)exception + 16) = 0;
  }
}

BOOL TXMPUtils<std::string>::ConvertToBool(XMPUtils *a1)
{
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  WXMPUtils_ConvertToBool_1(a1, (uint64_t)v4);
  if (*(void *)&v4[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v3 = *(void *)&v4[0];
    *(_DWORD *)exception = v5;
    exception[1] = v3;
    *((unsigned char *)exception + 16) = 0;
  }
  return v5 != 0;
}

BOOL TXMPUtils<std::string>::ConvertToBool(char *a1)
{
  if (a1[23] < 0) {
    a1 = *(char **)a1;
  }
  return TXMPUtils<std::string>::ConvertToBool((XMPUtils *)a1);
}

uint64_t TXMPUtils<std::string>::ConvertToDate(char *a1, uint64_t a2)
{
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t result = WXMPUtils_ConvertToDate_1(a1, a2, v5);
  if (*(void *)&v5[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v4 = *(void *)&v5[0];
    *(_DWORD *)exception = v6;
    exception[1] = v4;
    *((unsigned char *)exception + 16) = 0;
  }
  return result;
}

uint64_t TXMPUtils<std::string>::ConvertToUTCTime(uint64_t a1)
{
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  uint64_t result = WXMPUtils_ConvertToUTCTime_1(a1, v4);
  if (*(void *)&v4[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v3 = *(void *)&v4[0];
    *(_DWORD *)exception = v5;
    exception[1] = v3;
    *((unsigned char *)exception + 16) = 0;
  }
  return result;
}

void TXMPUtils<std::string>::PackageForJPEG(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPUtils_PackageForJPEG_1(*(const std::string **)(a1 + 8), a2, a3, a4, (void (*)(uint64_t, void *, uint64_t))TXMPUtils<std::string>::SetClientString, v6);
  if (*(void *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v5 = *(void *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPUtils<std::string>::MergeFromJPEG(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  WXMPUtils_MergeFromJPEG_1(*(void *)(a1 + 8), *(void *)(a2 + 8), v4);
  if (*(void *)&v4[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v3 = *(void *)&v4[0];
    *(_DWORD *)exception = v5;
    exception[1] = v3;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPUtils<std::string>::CatenateArrayItems(uint64_t a1, char *a2, unsigned char *a3, char *a4, const char *a5, unsigned int a6, uint64_t a7)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPUtils_CatenateArrayItems_1(*(void **)(a1 + 8), a2, a3, a4, a5, a6, a7, (void (*)(uint64_t, std::string *, uint64_t))TXMPUtils<std::string>::SetClientString, v9);
  if (*(void *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v8 = *(void *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPUtils<std::string>::SeparateArrayItems(uint64_t a1, XMPMeta *a2, char *a3, const char *a4, char *a5)
{
  if (!a1)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    exception[1] = "Null output SXMPMeta pointer";
    goto LABEL_6;
  }
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPUtils_SeparateArrayItems_1(*(void *)(a1 + 8), a2, a3, a4, a5, v7);
  if (*(void *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v6 = *(void *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
LABEL_6:
    *((unsigned char *)exception + 16) = 0;
  }
}

{
  if (a5[23] < 0) {
    a5 = *(char **)a5;
  }
  TXMPUtils<std::string>::SeparateArrayItems(a1, a2, a3, a4, a5);
}

void TXMPUtils<std::string>::RemoveProperties(uint64_t a1, XMPMeta *a2, char *a3, const char *a4)
{
  if (!a1)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    exception[1] = "Null output SXMPMeta pointer";
    goto LABEL_6;
  }
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPUtils_RemoveProperties_1(*(void *)(a1 + 8), a2, a3, a4, v6);
  if (*(void *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v5 = *(void *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
LABEL_6:
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPUtils<std::string>::DuplicateSubtree(uint64_t a1, uint64_t a2, XMPMeta *a3, char *a4, char *a5, char *a6, const char *a7)
{
  if (!a2)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 4;
    exception[1] = "Null output SXMPMeta pointer";
    goto LABEL_6;
  }
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  WXMPUtils_DuplicateSubtree_1(*(void *)(a1 + 8), *(void *)(a2 + 8), a3, a4, a5, a6, a7, v9);
  if (*(void *)&v9[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v8 = *(void *)&v9[0];
    *(_DWORD *)exception = v10;
    exception[1] = v8;
LABEL_6:
    *((unsigned char *)exception + 16) = 0;
  }
}

uint64_t TXMPFiles<std::string>::~TXMPFiles(uint64_t a1)
{
  *(void *)a1 = &unk_1ED4E6048;
  WXMPFiles_DecrementRefCount_1(*(_DWORD **)(a1 + 8));
  *(void *)(a1 + 8) = 0;
  return a1;
}

void TXMPFiles<std::string>::~TXMPFiles(uint64_t a1)
{
  TXMPFiles<std::string>::~TXMPFiles(a1);

  JUMPOUT(0x18C11C0E0);
}

BOOL TXMPFiles<std::string>::OpenFile(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  WXMPFiles_OpenFile_2(*(void *)(a1 + 8), a2, a3, a4, (uint64_t)v7);
  if (*(void *)&v7[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v6 = *(void *)&v7[0];
    *(_DWORD *)exception = v8;
    exception[1] = v6;
    *((unsigned char *)exception + 16) = 0;
  }
  return v8 != 0;
}

void TXMPFiles<std::string>::CloseFile(uint64_t a1, char a2)
{
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  WXMPFiles_CloseFile_1(*(void *)(a1 + 8), a2, v4);
  if (*(void *)&v4[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v3 = *(void *)&v4[0];
    *(_DWORD *)exception = v5;
    exception[1] = v3;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPFiles<std::string>::PutXMP(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  WXMPFiles_PutXMP_1(*(void *)(a1 + 8), *(void *)(a2 + 8), 0, 0, v4);
  if (*(void *)&v4[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v3 = *(void *)&v4[0];
    *(_DWORD *)exception = v5;
    exception[1] = v3;
    *((unsigned char *)exception + 16) = 0;
  }
}

void TXMPFiles<std::string>::PutXMP(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  WXMPFiles_PutXMP_1(*(void *)(a1 + 8), 0, a2, a3, v5);
  if (*(void *)&v5[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v4 = *(void *)&v5[0];
    *(_DWORD *)exception = v6;
    exception[1] = v4;
    *((unsigned char *)exception + 16) = 0;
  }
}

BOOL TXMPFiles<std::string>::CanPutXMP(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  WXMPFiles_CanPutXMP_1(*(void *)(a1 + 8), *(void *)(a2 + 8), 0, 0, (uint64_t)v5);
  if (*(void *)&v5[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v4 = *(void *)&v5[0];
    *(_DWORD *)exception = v6;
    exception[1] = v4;
    *((unsigned char *)exception + 16) = 0;
  }
  return v6 != 0;
}

BOOL TXMPFiles<std::string>::CanPutXMP(uint64_t a1, const char *a2, uint64_t a3)
{
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  WXMPFiles_CanPutXMP_1(*(void *)(a1 + 8), 0, a2, a3, (uint64_t)v6);
  if (*(void *)&v6[0])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    uint64_t v5 = *(void *)&v6[0];
    *(_DWORD *)exception = v7;
    exception[1] = v5;
    *((unsigned char *)exception + 16) = 0;
  }
  return v7 != 0;
}

uint64_t CreateMetadataFromXMPSidecarData(const char *a1, uint64_t a2)
{
  return CreateMetadataFromXMPBufferInternal(a1, a2, 0);
}

uint64_t CreateMetadataFromExtendedXMPData(const char *a1, uint64_t a2, const char *a3)
{
  kdebug_trace();
  uint64_t MetadataFromXMPBufferInternal = CreateMetadataFromXMPBufferInternal(a1, a2, a3);
  kdebug_trace();
  return MetadataFromXMPBufferInternal;
}

uint64_t CreateSXMPMetaFromMetadata(const CGImageMetadata *a1)
{
  if (a1)
  {
    CFTypeID v1 = CFGetTypeID(a1);
    if (v1 == CGImageMetadataGetTypeID()) {
      operator new();
    }
  }
  return 0;
}

void sub_188756194()
{
}

void sub_1887561A0()
{
}

uint64_t getDefaultMetadataValueTypeForProperty(CGImageMetadataTag *a1)
{
  uint64_t Source = CGImageSourceGetSource((uint64_t)a1);
  uint64_t v2 = *(unsigned int *)(Source + 40);
  if ((v2 + 1) <= 1)
  {
    uint64_t v3 = *(const void **)(Source + 48);
    CFTypeID v4 = CFGetTypeID(v3);
    if (v4 == CFBooleanGetTypeID()) {
      return 1;
    }
    CFTypeID v5 = CFGetTypeID(v3);
    if (v5 == CFNumberGetTypeID()) {
      return 1;
    }
    CFTypeID v6 = CFGetTypeID(v3);
    if (v6 == CFStringGetTypeID())
    {
      return 1;
    }
    else
    {
      CFTypeID v8 = CFGetTypeID(v3);
      if (v8 == CFArrayGetTypeID())
      {
        return 3;
      }
      else
      {
        CFTypeID v9 = CFGetTypeID(v3);
        if (v9 == CFDictionaryGetTypeID()) {
          return 6;
        }
        else {
          return v2;
        }
      }
    }
  }
  return v2;
}

void serializeArrayPropertyValue(uint64_t a1, char *a2, const char *a3, char *a4, const void *a5, unsigned int a6)
{
  if (a2)
  {
    if (a4)
    {
      if (a5)
      {
        CFTypeID v6 = CFGetTypeID(a5);
        if (v6 == CFArrayGetTypeID())
        {
          CFIndex Count = CFArrayGetCount((CFArrayRef)a5);
          if (Count >= 1)
          {
            CFIndex v7 = 0;
            while (1)
            {
              CFNumberRef ValueAtIndex = (CGImageMetadataTag *)CFArrayGetValueAtIndex((CFArrayRef)a5, v7);
              CFTypeID v9 = ValueAtIndex;
              if (ValueAtIndex) {
                break;
              }
LABEL_53:
              if (++v7 == Count) {
                return;
              }
            }
            CFTypeID v10 = CFGetTypeID(ValueAtIndex);
            if (v10 == CGImageMetadataTagGetTypeID())
            {
              uint64_t Source = CGImageSourceGetSource((uint64_t)v9);
              uint64_t v12 = IIOString::IIOString((IIOString *)&v54, *(const void **)(Source + 16));
              UTF8String = (char *)IIOString::createUTF8String(v12);
              IIOString::~IIOString((IIOString *)&v54);
              at_texel_format_t v15 = IIOString::IIOString(v14, *(const void **)(Source + 24));
              uint64_t v16 = (char *)IIOString::createUTF8String(v15);
              IIOString::~IIOString((IIOString *)&v54);
              unsigned int v17 = *(const void **)(Source + 48);
              if (v17)
              {
                DefaultMetadataValueTypeForuint64_t Property = getDefaultMetadataValueTypeForProperty(v9);
                unsigned int v19 = *(const void **)(Source + 56);
                if (v19)
                {
                  CFTypeID v20 = CFGetTypeID(v19);
                  if (v20 != CFArrayGetTypeID()) {
                    unsigned int v19 = 0;
                  }
                }
                int v21 = DefaultMetadataValueTypeForProperty - 1;
                CFStringRef v47 = 0;
                uint64_t v22 = 512;
                switch(v21)
                {
                  case 0:
                    goto LABEL_19;
                  case 1:
                    goto LABEL_44;
                  case 2:
                    uint64_t v22 = 1536;
                    goto LABEL_44;
                  case 3:
                    uint64_t v22 = 2560;
                    goto LABEL_44;
                  case 4:
                    uint64_t v22 = 4608;
LABEL_44:
                    unsigned int v54 = 0;
                    uint64_t v55 = 0;
                    uint64_t v56 = 0;
                    TXMPMeta<std::string>::AppendArrayItem(a1, a2, a4, a6, 0, v22);
                    TXMPUtils<std::string>::ComposeArrayItemPath(UTF8String, a4, v7 + 1, (uint64_t)&v54);
                    if (v56 >= 0) {
                      at_size_t v43 = (void **)&v54;
                    }
                    else {
                      at_size_t v43 = v54;
                    }
                    serializeArrayPropertyValue(a1, a2, v16, v43, v17, v22);
                    break;
                  case 5:
                    unsigned int v54 = 0;
                    uint64_t v55 = 0;
                    uint64_t v56 = 0;
                    TXMPMeta<std::string>::AppendArrayItem(a1, a2, a4, a6, 0, 256);
                    TXMPUtils<std::string>::ComposeArrayItemPath(UTF8String, a4, v7 + 1, (uint64_t)&v54);
                    if (v56 >= 0) {
                      at_size_t v44 = (char *)&v54;
                    }
                    else {
                      at_size_t v44 = (char *)v54;
                    }
                    serializeStructPropertyValue(a1, a2, v16, v44, v17);
                    break;
                  default:
                    goto LABEL_49;
                }
                if (SHIBYTE(v56) < 0)
                {
                  operator delete(v54);
                  if (!UTF8String)
                  {
LABEL_51:
                    if (v16) {
                      free(v16);
                    }
                    goto LABEL_53;
                  }
LABEL_50:
                  free(UTF8String);
                  goto LABEL_51;
                }
              }
            }
            else
            {
              CFTypeID v23 = CFGetTypeID(v9);
              if (v23 == CFStringGetTypeID())
              {
                uint64_t v16 = strdup(a3);
                UTF8String = strdup(a2);
                unsigned int v19 = 0;
                CFStringRef v47 = 0;
                unsigned int v17 = v9;
              }
              else
              {
                CFTypeID v24 = CFGetTypeID(v9);
                if (v24 != CFNumberGetTypeID())
                {
                  CFTypeID v38 = CFGetTypeID(v9);
                  if (v38 != CFDictionaryGetTypeID())
                  {
                    CFTypeID v39 = CFGetTypeID(v9);
                    CFStringRef v40 = CFCopyTypeIDDescription(v39);
                    unsigned int v54 = 0;
                    uint64_t v55 = 0;
                    uint64_t v56 = 0;
                    uint64_t v41 = IIOString::IIOString((IIOString *)&v54, v40);
                    uint64_t v42 = (const char *)IIOString::utf8String(v41);
                    LogError("serializeArrayPropertyValue", 1686, "Array element has unsupported type '%s', skipping.\n", v42);
                    CFRelease(v40);
                    IIOString::~IIOString((IIOString *)&v54);
                  }
                  goto LABEL_53;
                }
                uint64_t v16 = strdup(a3);
                UTF8String = strdup(a2);
                unsigned int v19 = 0;
                CFStringRef v47 = CFStringCreateWithFormat(0, 0, @"%@", v9);
                unsigned int v17 = v47;
              }
LABEL_19:
              unsigned int v25 = IIOString::IIOString((IIOString *)&v54, v17);
              at_error_t v26 = IIOString::createUTF8String(v25);
              IIOString::~IIOString((IIOString *)&v54);
              if (v26)
              {
                TXMPMeta<std::string>::AppendArrayItem(a1, a2, a4, a6, (uint64_t)v26, 0);
                if (v19 && (CFIndex v27 = CFArrayGetCount((CFArrayRef)v19), v27 >= 1))
                {
                  CFIndex v28 = 0;
                  while (1)
                  {
                    unsigned int v29 = CFArrayGetValueAtIndex((CFArrayRef)v19, v28);
                    uint64_t v30 = CGImageSourceGetSource((uint64_t)v29);
                    if (!v29) {
                      break;
                    }
                    unint64_t v31 = (const void **)v30;
                    CFTypeID v32 = CFGetTypeID(v29);
                    if (v32 != CGImageMetadataTagGetTypeID()) {
                      break;
                    }
                    float v33 = IIOString::IIOString((IIOString *)&v54, v31[6]);
                    float v34 = IIOString::createUTF8String(v33);
                    IIOString::~IIOString((IIOString *)&v54);
                    if (v34)
                    {
                      unsigned int v54 = 0;
                      uint64_t v55 = 0;
                      uint64_t v56 = 0;
                      TXMPUtils<std::string>::ComposeArrayItemPath(a2, a4, v7 + 1, (uint64_t)&v54);
                      IIOString::IIOString((IIOString *)v53, v31[2]);
                      at_block_features_t v35 = IIOString::createUTF8String((IIOString *)v53);
                      IIOString::~IIOString((IIOString *)v53);
                      IIOString::IIOString((IIOString *)v53, v31[4]);
                      size_t v36 = IIOString::createUTF8String((IIOString *)v53);
                      IIOString::~IIOString((IIOString *)v53);
                      if (v56 >= 0) {
                        at_error_t v37 = (void **)&v54;
                      }
                      else {
                        at_error_t v37 = v54;
                      }
                      TXMPMeta<std::string>::SetQualifier(a1, a2, v37, v35, v36, (uint64_t)v34, 0);
                      if (v35) {
                        free(v35);
                      }
                      if (v36) {
                        free(v36);
                      }
                      free(v34);
                      if (SHIBYTE(v56) < 0) {
                        operator delete(v54);
                      }
                    }
                    if (v27 == ++v28) {
                      goto LABEL_36;
                    }
                  }
                  LogMetadata("serializeArrayPropertyValue", 1717, "Qualifier at index %d for tag %s/%s is not a CGImageMetadataTagRef, skipping.\n", v28, a2, a4);
                }
                else
                {
LABEL_36:
                  free(v26);
                }
              }
              if (v47) {
                CFRelease(v47);
              }
            }
LABEL_49:
            if (!UTF8String) {
              goto LABEL_51;
            }
            goto LABEL_50;
          }
        }
      }
    }
  }
}

void sub_1887568D4(_Unwind_Exception *a1)
{
}

void serializeStructPropertyValue(uint64_t a1, const char *a2, const char *a3, char *a4, const void *a5)
{
  if (a2)
  {
    if (a4)
    {
      if (a5)
      {
        CFTypeID v8 = CFGetTypeID(a5);
        if (v8 == CFDictionaryGetTypeID())
        {
          CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          unsigned int v54 = (char *)a2;
          CFStringRef cf = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
          CFStringRef v50 = CFStringCreateWithCString(v9, a3, 0x8000100u);
          CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a5);
          CFTypeID v10 = (const void **)malloc_type_malloc(8 * Count, 0x6004044C4A2DFuLL);
          values = (void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
          CFDictionaryGetKeysAndValues((CFDictionaryRef)a5, v10, (const void **)values);
          int8x8_t v52 = v10;
          if (Count >= 1)
          {
            uint64_t v11 = 0;
            while (1)
            {
              uint64_t v12 = values[v11];
              if (!v12) {
                break;
              }
              CFTypeID v13 = CFGetTypeID(v12);
              CFTypeID TypeID = CGImageMetadataTagGetTypeID();
              at_texel_format_t v15 = (CGImageMetadataTag *)values[v11];
              if (v13 != TypeID) {
                goto LABEL_15;
              }
              uint64_t Source = (void *)CGImageSourceGetSource((uint64_t)values[v11]);
              unsigned int v17 = (const void *)Source[6];
              if (v17)
              {
                DefaultMetadataValueTypeForuint64_t Property = getDefaultMetadataValueTypeForProperty(v15);
                CFStringRef v19 = (CFStringRef)Source[2];
                CFStringRef v20 = (CFStringRef)Source[3];
                int v21 = (const void *)Source[7];
                if (v21)
                {
                  CFTypeID v22 = CFGetTypeID(v21);
                  if (v22 == CFArrayGetTypeID()) {
                    CFArrayRef v23 = (const __CFArray *)v21;
                  }
                  else {
                    CFArrayRef v23 = 0;
                  }
                }
                else
                {
                  CFArrayRef v23 = 0;
                }
LABEL_17:
                unsigned int v25 = IIOString::IIOString((IIOString *)&v59, v19);
                UTF8String = (XMPMeta *)IIOString::createUTF8String(v25);
                IIOString::~IIOString((IIOString *)&v59);
                CFIndex v28 = IIOString::IIOString(v27, v20);
                unsigned int v29 = (char *)IIOString::createUTF8String(v28);
                IIOString::~IIOString((IIOString *)&v59);
                if (v19)
                {
                  int32x4_t v59 = 0;
                  uint64_t v60 = 0;
                  uint64_t v61 = 0;
                  if (UTF8String)
                  {
                    if (v29)
                    {
                      TXMPMeta<std::string>::RegisterNamespace(UTF8String, v29, (uint64_t)&v59);
                      if (SHIBYTE(v61) < 0) {
                        operator delete(v59);
                      }
                    }
                  }
                }
                uint64_t v30 = IIOString::IIOString((IIOString *)&v59, v52[v11]);
                unint64_t v31 = (char *)IIOString::createUTF8String(v30);
                IIOString::~IIOString((IIOString *)&v59);
                if (!v31) {
                  goto LABEL_62;
                }
                if ((DefaultMetadataValueTypeForProperty - 2) < 4)
                {
                  int32x4_t v59 = 0;
                  uint64_t v60 = 0;
                  uint64_t v61 = 0;
                  if ((DefaultMetadataValueTypeForProperty - 3) > 2) {
                    uint64_t v33 = 512;
                  }
                  else {
                    uint64_t v33 = dword_188991770[DefaultMetadataValueTypeForProperty - 3];
                  }
                  TXMPMeta<std::string>::SetStructField(a1, v54, a4, (char *)UTF8String, v31, 0, v33);
                  TXMPUtils<std::string>::ComposeStructFieldPath(v54, a4, (char *)UTF8String, v31, (uint64_t)&v59);
                  if (v61 >= 0) {
                    CFStringRef v47 = &v59;
                  }
                  else {
                    CFStringRef v47 = (void **)v59;
                  }
                  serializeArrayPropertyValue(a1, v54, v29, v47, v17, v33);
                  goto LABEL_56;
                }
                if (DefaultMetadataValueTypeForProperty == 6)
                {
                  int32x4_t v59 = 0;
                  uint64_t v60 = 0;
                  uint64_t v61 = 0;
                  TXMPMeta<std::string>::SetStructField(a1, v54, a4, (char *)UTF8String, v31, 0, 256);
                  TXMPUtils<std::string>::ComposeStructFieldPath(v54, a4, (char *)UTF8String, v31, (uint64_t)&v59);
                  if (v61 >= 0) {
                    CGRect v48 = &v59;
                  }
                  else {
                    CGRect v48 = (void **)v59;
                  }
                  serializeStructPropertyValue(a1, v54, v29, v48, v17);
LABEL_56:
                  if (SHIBYTE(v61) < 0)
                  {
                    operator delete(v59);
                    if (!UTF8String) {
                      goto LABEL_59;
                    }
                    goto LABEL_58;
                  }
                }
                else if (DefaultMetadataValueTypeForProperty == 1)
                {
                  float v34 = IIOString::IIOString(v32, v17);
                  at_block_features_t v35 = (const char *)IIOString::createUTF8String(v34);
                  IIOString::~IIOString((IIOString *)&v59);
                  if (v35) {
                    TXMPMeta<std::string>::SetStructField(a1, v54, a4, (char *)UTF8String, v31, v35, 0);
                  }
                  unsigned int v49 = (char *)v35;
                  if (v23)
                  {
                    CFIndex v36 = CFArrayGetCount(v23);
                    if (v36 >= 1)
                    {
                      for (CFIndex i = 0; i != v36; ++i)
                      {
                        CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(v23, i);
                        uint64_t v39 = CGImageSourceGetSource((uint64_t)ValueAtIndex);
                        if (ValueAtIndex
                          && (CFStringRef v40 = (const void **)v39,
                              CFTypeID v41 = CFGetTypeID(ValueAtIndex),
                              v41 == CGImageMetadataTagGetTypeID()))
                        {
                          uint64_t v42 = IIOString::IIOString((IIOString *)&v59, v40[6]);
                          at_size_t v43 = IIOString::createUTF8String(v42);
                          IIOString::~IIOString((IIOString *)&v59);
                          if (v43)
                          {
                            int32x4_t v59 = 0;
                            uint64_t v60 = 0;
                            uint64_t v61 = 0;
                            TXMPUtils<std::string>::ComposeStructFieldPath(v54, a4, (char *)UTF8String, v31, (uint64_t)&v59);
                            IIOString::IIOString((IIOString *)v58, v40[2]);
                            at_size_t v44 = IIOString::createUTF8String((IIOString *)v58);
                            IIOString::~IIOString((IIOString *)v58);
                            IIOString::IIOString((IIOString *)v58, v40[4]);
                            unint64_t v45 = IIOString::createUTF8String((IIOString *)v58);
                            IIOString::~IIOString((IIOString *)v58);
                            if (v61 >= 0) {
                              memory_object_size_t v46 = &v59;
                            }
                            else {
                              memory_object_size_t v46 = (void **)v59;
                            }
                            TXMPMeta<std::string>::SetQualifier(a1, v54, v46, v44, v45, (uint64_t)v43, 0);
                            if (v44) {
                              free(v44);
                            }
                            if (v45) {
                              free(v45);
                            }
                            free(v43);
                            if (SHIBYTE(v61) < 0) {
                              operator delete(v59);
                            }
                          }
                        }
                        else
                        {
                          LogMetadata("serializeStructPropertyValue", 1945, "Qualifier at index %d for tag %s/%s is not a CGImageMetadataTagRef, skipping.\n", i, v54, a4);
                        }
                      }
                    }
                  }
                  if (v49)
                  {
                    free(v49);
                    if (!UTF8String) {
                      goto LABEL_59;
                    }
LABEL_58:
                    free(UTF8String);
LABEL_59:
                    if (v29) {
                      free(v29);
                    }
                    free(v31);
                    goto LABEL_62;
                  }
                }
                if (UTF8String) {
                  goto LABEL_58;
                }
                goto LABEL_59;
              }
LABEL_62:
              if (++v11 == Count) {
                goto LABEL_71;
              }
            }
            at_texel_format_t v15 = 0;
LABEL_15:
            CFTypeID v24 = CFGetTypeID(v15);
            if (v24 == CFStringGetTypeID())
            {
              CFArrayRef v23 = 0;
              unsigned int v17 = values[v11];
              DefaultMetadataValueTypeForuint64_t Property = 1;
              CFStringRef v20 = v50;
              CFStringRef v19 = cf;
              goto LABEL_17;
            }
            LogError("serializeStructPropertyValue", 1896, "Struct field has unsupported type, skipping.\n");
            goto LABEL_62;
          }
LABEL_71:
          if (cf) {
            CFRelease(cf);
          }
          if (v50) {
            CFRelease(v50);
          }
          if (values) {
            free(values);
          }
          if (v52) {
            free(v52);
          }
        }
      }
    }
  }
}

#error "188756FF8: call analysis failed (funcsize=22)"

void sub_188757020(_Unwind_Exception *a1)
{
}

uint64_t SerializeMetadataForJPEGXMP(const CGImageMetadata *a1, char **a2, void *a3, char **a4, void *a5, char **a6, void *a7)
{
  if (a3) {
    *a3 = 0;
  }
  if (a5)
  {
    *a5 = 0;
    if (a3)
    {
      if (a1 && a7)
      {
        at_block_features_t v35 = 0;
        uint64_t v36 = 0;
        uint64_t v37 = 0;
        CFTypeID v32 = 0;
        uint64_t v33 = 0;
        uint64_t v34 = 0;
        std::string __p = 0;
        uint64_t v30 = 0;
        uint64_t v31 = 0;
        IIO_InitializeXMPToolkit();
        SXMPMetaFromuint64_t Metadata = CreateSXMPMetaFromMetadata(a1);
        uint64_t v15 = SXMPMetaFromMetadata;
        if (SXMPMetaFromMetadata)
        {
          TXMPUtils<std::string>::PackageForJPEG(SXMPMetaFromMetadata, (uint64_t)&v35, (uint64_t)&v32, (uint64_t)&__p);
          (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
          if (v37 >= 0) {
            uint64_t v16 = HIBYTE(v37);
          }
          else {
            uint64_t v16 = v36;
          }
          unsigned int v17 = (char *)malloc_type_malloc(v16 + 1, 0x100004077774924uLL);
          if (v37 >= 0) {
            unsigned int v18 = (const char *)&v35;
          }
          else {
            unsigned int v18 = (const char *)v35;
          }
          CFStringRef v19 = strncpy(v17, v18, v16 + 1);
          v19[v16] = 0;
          *a3 = v16 + 1;
          *a2 = v19;
          if (v34 >= 0) {
            uint64_t v20 = HIBYTE(v34);
          }
          else {
            uint64_t v20 = v33;
          }
          int v21 = (char *)malloc_type_malloc(v20 + 1, 0x100004077774924uLL);
          if (v34 >= 0) {
            CFTypeID v22 = (const char *)&v32;
          }
          else {
            CFTypeID v22 = (const char *)v32;
          }
          CFArrayRef v23 = strncpy(v21, v22, v20 + 1);
          v23[v20] = 0;
          *a5 = v20 + 1;
          *a4 = v23;
          if (v31 >= 0) {
            uint64_t v24 = HIBYTE(v31);
          }
          else {
            uint64_t v24 = v30;
          }
          unsigned int v25 = (char *)malloc_type_malloc(v24 + 1, 0x100004077774924uLL);
          if (v31 >= 0) {
            p_p = (const char *)&__p;
          }
          else {
            p_p = (const char *)__p;
          }
          CFIndex v27 = strncpy(v25, p_p, v24 + 1);
          v27[v24] = 0;
          *a7 = v24 + 1;
          *a6 = v27;
        }
        IIO_TerminateXMPToolkit();
        if (SHIBYTE(v31) < 0) {
          operator delete(__p);
        }
        if (SHIBYTE(v34) < 0) {
          operator delete(v32);
        }
        if (SHIBYTE(v37) < 0) {
          operator delete(v35);
        }
      }
    }
  }
  return 0;
}

BOOL IIO_XMPMeta_ErrorCallback(void *a1, int a2, int a3, const char *a4)
{
  if (!a2) {
    ++*a1;
  }
  return a2 == 0;
}

const char *___ZL35CreateMetadataFromXMPBufferInternalPKcmS0_mj_block_invoke()
{
  uint64_t result = getenv("IIO_SkipExtendedXMP");
  if (result) {
    uint64_t result = (const char *)atoi(result);
  }
  gIIO_SkipExtendedXMP = (int)result;
  return result;
}

void std::vector<std::string>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

uint64_t std::vector<std::string>::__push_back_slow_path<std::string const&>(uint64_t *a1, long long *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  __v.__end_cap_.__value_ = (std::allocator<std::string> *)(a1 + 2);
  if (v9) {
    CFTypeID v10 = (std::string *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v7, v9);
  }
  else {
    CFTypeID v10 = 0;
  }
  std::__split_buffer<std::string>::pointer end = v10 + v4;
  __v.__first_ = v10;
  __v.__begin_ = end;
  __v.__end_ = end;
  __v.__end_cap_.__value_ = &v10[v9];
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(end, *(const std::string::value_type **)a2, *((void *)a2 + 1));
    std::__split_buffer<std::string>::pointer end = __v.__end_;
  }
  else
  {
    long long v12 = *a2;
    end->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&end->__r_.__value_.__l.__data_ = v12;
  }
  __v.__end_ = end + 1;
  std::vector<std::string>::__swap_out_circular_buffer((std::vector<std::string> *)a1, &__v);
  uint64_t v13 = a1[1];
  std::__split_buffer<std::string>::~__split_buffer(&__v);
  return v13;
}

void sub_1887574C0(_Unwind_Exception *a1, std::__split_buffer<std::string> *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
}

void std::vector<std::string>::__swap_out_circular_buffer(std::vector<std::string> *this, std::__split_buffer<std::string> *__v)
{
  std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>((uint64_t)&this->__end_cap_, (uint64_t)this->__end_, (uint64_t)this->__end_, (uint64_t)this->__begin_, (uint64_t)this->__begin_, (uint64_t)__v->__begin_, (uint64_t)__v->__begin_);
  __v->__begin_ = v4;
  begin = this->__begin_;
  this->__begin_ = v4;
  __v->__begin_ = begin;
  std::__split_buffer<std::string>::pointer end = this->__end_;
  this->__end_ = __v->__end_;
  __v->__end_ = end;
  CFTypeRef value = this->__end_cap_.__value_;
  this->__end_cap_.__value_ = __v->__end_cap_.__value_;
  __v->__end_cap_.__value_ = value;
  __v->__first_ = __v->__begin_;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::string>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>,std::reverse_iterator<std::string*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  uint64_t v13 = 0;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      long long v10 = *(_OWORD *)(a3 - 24);
      *(void *)(v9 - 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      *(void *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((void *)&v15 + 1) = v9;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::string>,std::reverse_iterator<std::string*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 24;
  }
}

void std::__split_buffer<std::string>::~__split_buffer(std::__split_buffer<std::string> *this)
{
  if (this->__first_) {
    operator delete(this->__first_);
  }
}

void std::__split_buffer<std::string>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      unint64_t v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        unint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

void *ICOReadPlugin::ICOReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result = (void *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *uint64_t result = &unk_1ED4DFC30;
  return result;
}

void ICOReadPlugin::ICOReadPlugin(uint64_t a1, uint64_t a2)
{
}

void ICOReadPlugin::~ICOReadPlugin(ICOReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t ICOReadPlugin::loadDataFromXPCObject(ICOReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_ico", &length);
    if (length == 8)
    {
      CFTypeID v6 = data;
      uint64_t result = 0;
      *((void *)this + 55) = *v6;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t ICOReadPlugin::saveDataToXPCObject(ICOReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_ico", (char *)this + 440, 8uLL);
  }
  return v4;
}

uint64_t ICOReadPlugin::initialize(IIOImageReadSession **this, IIODictionary *a2)
{
  __dst[0] = 0;
  __int16 v67 = 0;
  int v66 = 0;
  uint64_t v65 = 0;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v61, this[3]);
  if (!*((unsigned char *)this + 341)
    || (unsigned int v54 = a2, IIOScanner::getBytes((IIOScanner *)&v61, &v66, 6uLL), v4 = v67, !(_BYTE)v67)
    || *((_DWORD *)this + 52) >= v67)
  {
    uint64_t v28 = 4294967246;
    goto LABEL_93;
  }
  unint64_t v5 = (unsigned __int16 *)malloc_type_calloc(v67, 0x10uLL, 0x1000040451B5BE8uLL);
  if (IIOScanner::getBytes((IIOScanner *)&v61, v5, 16 * v4) != 16 * v4)
  {
    char v52 = 0;
    uint64_t v28 = 4294967246;
    goto LABEL_90;
  }
  uint64_t v6 = 0;
  unsigned int v7 = (16 * v4) | 6;
  long long __base = v5;
  unint64_t v8 = (__int16 *)(v5 + 3);
  do
  {
    if (BYTE2(v66) == 2)
    {
      uint64_t v9 = (uint64_t)this[7];
      IIONumber::IIONumber((IIONumber *)v60, (unsigned __int16)*(v8 - 1));
      IIODictionary::setObjectForKey(v9, (uint64_t)v60, @"hotspotX");
      IIONumber::~IIONumber((IIONumber *)v60);
      uint64_t v10 = (uint64_t)this[7];
      IIONumber::IIONumber((IIONumber *)v59, (unsigned __int16)*v8);
      IIODictionary::setObjectForKey(v10, (uint64_t)v59, @"hotspotY");
      IIONumber::~IIONumber((IIONumber *)v59);
      *(_DWORD *)(v8 - 1) = 65537;
      unsigned int v11 = 1;
    }
    else
    {
      unsigned int v11 = (unsigned __int16)*v8;
    }
    int v12 = *((unsigned __int8 *)v8 - 6);
    int v13 = *((unsigned __int8 *)v8 - 5);
    if (v12 | v13)
    {
      BOOL v16 = (v12 - 12) > 0xFFFFFFF4 || (v13 - 12) > 0xFFFFFFF4;
      if (v16
        || v11 > 0x20
        || ((1 << v11) & 0x101000113) == 0
        || (unint64_t v17 = *(unsigned int *)(v8 + 1), v17 < 0x28)
        || (unint64_t v18 = *(unsigned int *)(v8 + 3), v18 < v7)
        || (unint64_t)v62 < v18)
      {
        _cg_jpeg_mem_term("initialize", 188, "*** ERROR: ICO#%2d - bad dimension (%3dx%3d) | bitDepth (%6d) | offset (%10ld) - skipping\n", v6, v12, v13, v11, *(unsigned int *)(v8 + 3));
        goto LABEL_40;
      }
      if (!v11 && *((unsigned char *)v8 - 6) && *((unsigned char *)v8 - 5))
      {
        int v19 = 4 * v13;
        uint64_t v20 = 4 * v13 * ((v12 + 31) >> 5);
        uint64_t v21 = v20 + 40;
        if (v20 + 40 + v20 >= v17)
        {
          *unint64_t v8 = 1;
          goto LABEL_41;
        }
        if ((unint64_t)(v19 * ((2 * v12 + 31) >> 5)) + v21 - 120 >= v17)
        {
          __int16 v22 = 2;
LABEL_47:
          *unint64_t v8 = v22;
          goto LABEL_41;
        }
        if (v21 + (unint64_t)(v19 * ((4 * v12 + 31) >> 5) + 64) >= v17)
        {
          __int16 v22 = 4;
          goto LABEL_47;
        }
        if (v21 + (unint64_t)(v19 * ((8 * v12 + 31) >> 5) + 1024) >= v17)
        {
          __int16 v22 = 8;
          goto LABEL_47;
        }
        if (v21 + (unint64_t)(v19 * ((24 * v12 + 31) >> 5)) < v17)
        {
          if (v21 + (unint64_t)(4 * v12 * v13) < v17)
          {
            _cg_jpeg_mem_term("initialize", 218, "*** ERROR: skipping bad ICO#%d - [2]\n", v6);
            goto LABEL_40;
          }
          __int16 v22 = 32;
          goto LABEL_47;
        }
        *unint64_t v8 = 24;
      }
    }
    else
    {
      if (v11 > 0x20 || ((1 << v11) & 0x101000113) == 0)
      {
        unint64_t v15 = *(unsigned int *)(v8 + 3);
LABEL_39:
        _cg_jpeg_mem_term("initialize", 172, "*** ERROR: ICO#%2d - bad dimension (%3dx%3d) | bitDepth (%6d) | offset (%10ld) - skipping\n", v6, 0, 0, v11, v15);
LABEL_40:
        *(void *)(v8 - 3) = 0;
        *(void *)(v8 + 1) = 0;
        goto LABEL_41;
      }
      unint64_t v15 = *(unsigned int *)(v8 + 3);
      if (*(_DWORD *)(v8 + 1) < 0x28u || v15 < v7 || (unint64_t)v62 < v15) {
        goto LABEL_39;
      }
    }
LABEL_41:
    ++v6;
    v8 += 8;
  }
  while (v4 != v6);
  qsort_b(v5, v4, 0x10uLL, &__block_literal_global_19);
  uint64_t v23 = *((unsigned int *)this + 52);
  uint64_t v24 = &v5[8 * v23];
  unsigned int v25 = (unsigned int *)(v24 + 6);
  size_t BytesAtOffset = IIOScanner::getBytesAtOffset((IIOScanner *)&v61, __dst, *((unsigned int *)v24 + 3), 4uLL);
  v27.i32[0] = __dst[0];
  if (vmovn_s16((int16x8_t)vmovl_u8(v27)).u32[0] == 1196314761 && BytesAtOffset == 4)
  {
    IIONumber::IIONumber((IIONumber *)&v56, 1347307296);
    IIODictionary::setObjectForKey(v54, value[0], @"NEW_PLUGIN_ostype");
    IIONumber::~IIONumber((IIONumber *)&v56);
    IIONumber::IIONumber((IIONumber *)&v56, *v25);
    IIODictionary::setObjectForKey(v54, value[0], @"NEW_PLUGIN_dataOffset");
    IIONumber::~IIONumber((IIONumber *)&v56);
    IIONumber::IIONumber((IIONumber *)&v56, *(unsigned __int8 *)v24);
    IIODictionary::setObjectForKey(v54, value[0], @"NEW_PLUGIN_expectedWidth");
    IIONumber::~IIONumber((IIONumber *)&v56);
    IIONumber::IIONumber((IIONumber *)&v56, HIBYTE(v5[8 * v23]));
    IIODictionary::setObjectForKey(v54, value[0], @"NEW_PLUGIN_expectedHeight");
    IIONumber::~IIONumber((IIONumber *)&v56);
    uint64_t v28 = 4294967247;
    goto LABEL_53;
  }
  unsigned int v29 = *(_DWORD *)&v5[8 * v23 + 4];
  uint64_t v28 = 4294967246;
  if (v29 < 0x29) {
    goto LABEL_53;
  }
  uint64_t v30 = *v25;
  if (!v30) {
    goto LABEL_53;
  }
  uint64_t v58 = 0;
  long long v56 = 0u;
  *(_OWORD *)CFTypeRef value = 0u;
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v61, &v56, v30, 0x28uLL) != 40)
  {
LABEL_100:
    uint64_t v28 = 4294967246;
LABEL_53:
    free(v5);
    goto LABEL_93;
  }
  unsigned int v31 = DWORD2(v56) >> 1;
  uint64_t v32 = HIWORD(v56);
  uint64_t v33 = v5;
  if (DWORD1(v56) <= *(unsigned __int8 *)v24) {
    int v34 = *(unsigned __int8 *)v24;
  }
  else {
    int v34 = DWORD1(v56);
  }
  if (v31 <= HIBYTE(__base[8 * v23])) {
    uint64_t v35 = HIBYTE(v33[8 * v23]);
  }
  else {
    uint64_t v35 = v31;
  }
  if (v34 && (v34 - 12) >= 0xF5)
  {
    _cg_jpeg_mem_term("initialize", 286, "*** ERROR: unsupported width: %d\n");
LABEL_99:
    unint64_t v5 = __base;
    goto LABEL_100;
  }
  if (v35 && (v35 - 12) > 0xF4)
  {
    uint64_t v36 = "*** ERROR: unsupported height: %d\n";
    uint64_t v37 = 287;
    uint64_t v32 = v35;
LABEL_98:
    _cg_jpeg_mem_term("initialize", v37, v36, v32);
    goto LABEL_99;
  }
  uint64_t v36 = "*** ERROR: unsupported bpp: %d\n";
  uint64_t v37 = 288;
  if (HIWORD(v56) > 0x20u || ((1 << SBYTE14(v56)) & 0x101000112) == 0) {
    goto LABEL_98;
  }
  CFTypeID v38 = 0;
  LODWORD(v39) = 0;
  *((_DWORD *)this + 57) = v34;
  *((_DWORD *)this + 58) = v35;
  if ((int)v32 <= 7)
  {
    if (v32 != 1 && v32 != 4) {
      goto LABEL_87;
    }
    goto LABEL_77;
  }
  switch(v32)
  {
    case 0x20:
      LODWORD(v39) = 0;
      CFTypeID v38 = 0;
      this[34] = (IIOImageReadSession *)0x3000400200008;
      *((_DWORD *)this + 59) = 4 * v34;
      *((_DWORD *)this + 60) = 2097160;
      *((_WORD *)this + 122) = 4;
      *((unsigned char *)this + 246) = 3;
      *((unsigned char *)this + 350) = 1;
      this[20] = 0;
      break;
    case 0x18:
      LODWORD(v39) = 0;
      CFTypeID v38 = 0;
      *((_DWORD *)this + 59) = (3 * v34 + 7) & 0xFFFFFFF8;
      *((_DWORD *)this + 60) = 1572872;
      *((_WORD *)this + 122) = 3;
      this[34] = (IIOImageReadSession *)0x5000400200008;
      *((_DWORD *)this + 67) = (4 * v34 + 15) & 0x7FFFFFF0;
      *((unsigned char *)this + 350) = 1;
      this[20] = 0;
      *((unsigned char *)this + 246) = 0;
      break;
    case 8:
LABEL_77:
      uint64_t v39 = 4 << v32;
      if (v29 > (4 << v32) + 40)
      {
        CFTypeID v38 = (unsigned __int8 *)malloc_type_calloc(4 << v32, 1uLL, 0xBC705827uLL);
        if (IIOScanner::getBytesAtOffset((IIOScanner *)&v61, v38, (v30 + 40), 4 << v32) == v39)
        {
          uint64_t v40 = 0;
          CFTypeID v41 = v38 + 1;
          uint64_t v42 = v38 + 2;
          do
          {
            unsigned __int8 v43 = v41[v40];
            unsigned __int8 v44 = v38[v40];
            *(v42 - 2) = v41[v40 + 1];
            *(v42 - 1) = v43;
            *uint64_t v42 = v44;
            v42 += 3;
            v40 += 4;
          }
          while (4 * (1 << v32) != v40);
          unint64_t v45 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
          this[20] = CGColorSpaceCreateIndexed(v45, (1 << v32) - 1, v38);
          CGColorSpaceRelease(v45);
          *((_WORD *)this + 121) = v32;
          *((_WORD *)this + 120) = v32;
          *((_WORD *)this + 122) = 1;
          *((_DWORD *)this + 59) = ((v34 * v32 + 31) >> 3) & 0x1FFFFFFC;
          if (v32 == 1) {
            char v46 = 1;
          }
          else {
            char v46 = 2;
          }
          *((_DWORD *)this + 67) = v34 << v46;
          *((_DWORD *)this + 68) = 1048584;
          *((_WORD *)this + 138) = 2;
          *((unsigned char *)this + 278) = 3;
          break;
        }
        unint64_t v5 = __base;
        goto LABEL_104;
      }
      uint64_t v28 = 4294967246;
      unint64_t v5 = __base;
      goto LABEL_53;
  }
LABEL_87:
  *((_DWORD *)this + 81) = 1380401696;
  *((unsigned char *)this + 344) = 0;
  *((unsigned char *)this + 346) = 0;
  int v47 = v56 + v39;
  CGRect v48 = (IIOImageReadSession *)(v56 + v39 + v30);
  this[24] = v48;
  this[55] = (IIOImageReadSession *)(v29 - v47);
  unsigned int v49 = this[23];
  if (v49 > v48)
  {
    uint64_t v50 = 0;
    uint64_t v28 = 0;
    char v51 = 1;
    this[45] = (IIOImageReadSession *)1;
    *((_WORD *)this + 188) = 1;
    char v52 = 1;
    unint64_t v5 = __base;
    if (v38) {
      goto LABEL_89;
    }
    goto LABEL_90;
  }
  _cg_jpeg_mem_term("initialize", 376, "bad offset %d > fileSize %d\n", v48, v49);
  unint64_t v5 = __base;
LABEL_104:
  char v51 = 0;
  char v52 = 0;
  uint64_t v50 = 4294967246;
  uint64_t v28 = 4294967246;
  if (v38)
  {
LABEL_89:
    free(v38);
    char v52 = v51;
    uint64_t v28 = v50;
  }
LABEL_90:
  if (v5) {
    free(v5);
  }
  if ((v52 & 1) == 0) {
LABEL_93:
  }
    kdebug_trace();
  IIOScanner::~IIOScanner((IIOScanner *)&v61);
  return v28;
}

void sub_188758120(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t ___ZN13ICOReadPlugin10initializeEP13IIODictionary_block_invoke(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  unsigned int v3 = *a2;
  if (!*a2) {
    unsigned int v3 = 256;
  }
  if (*a3) {
    unsigned int v4 = *a3;
  }
  else {
    unsigned int v4 = 256;
  }
  unsigned int v5 = *((unsigned __int16 *)a2 + 3);
  unsigned int v6 = *((unsigned __int16 *)a3 + 3);
  if (v5 < v6) {
    return 1;
  }
  if (v5 > v6) {
    return 0xFFFFFFFFLL;
  }
  BOOL v8 = v3 >= v4;
  if (v3 <= v4) {
    unsigned int v9 = 0;
  }
  else {
    unsigned int v9 = -1;
  }
  if (v8) {
    return v9;
  }
  else {
    return 1;
  }
}

uint64_t ICOReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12) {
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2);
  }
  if (v2 == 1) {
    return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

uint64_t ICOReadPlugin::decodeImageData(ICOReadPlugin *this, IIOBitStream *a2, void *a3)
{
  uint64_t v4 = *((unsigned int *)this + 57);
  uint64_t v3 = *((unsigned int *)this + 58);
  uint64_t v5 = *((unsigned int *)this + 59);
  unint64_t v6 = ((unint64_t)(v4 + 31) >> 3) & 0x3FFFFFFC;
  if (*((_WORD *)this + 121) == 32) {
    unint64_t v6 = 0;
  }
  unint64_t v48 = v6;
  size_t v7 = (v6 + v5) * v3;
  size_t v8 = *((void *)this + 55);
  if (v8 < v7)
  {
    _cg_jpeg_mem_term("decodeImageData", 451, "*** _ico._length: %d   length: %d\n", v8, v7);
    return 4294967246;
  }
  uint64_t v47 = *((unsigned int *)this + 75);
  int v12 = (IIOBitStream *)malloc_type_calloc(v7, 1uLL, 0xA43BFE77uLL);
  if (!v12) {
    return 4294967246;
  }
  int v13 = v12;
  uint64_t v49 = 0;
  if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v12, *((void *)this + 24), v7) <= v7)
  {
    unint64_t v15 = (IIOBitStream *)((char *)v13 + v5 * (unint64_t)v3);
    unsigned int v16 = *((unsigned __int16 *)this + 121);
    if (v16 <= 7)
    {
      uint64_t v17 = v5;
      uint64_t IIOBitStream = IIOBitStream::CreateIIOBitStream(v13, (void *)(v5 * (unint64_t)v3), "r", v14);
      uint64_t v20 = IIOBitStream::CreateIIOBitStream(v15, (void *)(v48 * (unint64_t)v3), "r", v19);
      uint64_t v22 = IIOBitStream::CreateIIOBitStream(a2, a3, "w", v21);
      if (v3)
      {
        unsigned __int8 v43 = v13;
        uint64_t v23 = 0;
        while (1)
        {
          (*(void (**)(uint64_t, uint64_t))(*(void *)IIOBitStream + 32))(IIOBitStream, v23 * v17);
          (*(void (**)(uint64_t, unint64_t))(*(void *)v20 + 32))(v20, v23 * v48);
          (*(void (**)(uint64_t, uint64_t))(*(void *)v22 + 32))(v22, (~v23 + v3) * v47);
          uint64_t v24 = v4;
          if (v4) {
            break;
          }
LABEL_18:
          if (++v23 == v3)
          {
            uint64_t v27 = 0;
            goto LABEL_30;
          }
        }
        while (1)
        {
          uint64_t v25 = (*(uint64_t (**)(uint64_t, void, char *))(*(void *)IIOBitStream + 24))(IIOBitStream, *((unsigned __int16 *)this + 120), (char *)&v49 + 4);
          if (v25) {
            break;
          }
          uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v20 + 24))(v20, 1, &v49);
          if (v25) {
            break;
          }
          uint64_t v25 = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v22 + 16))(v22, *((unsigned __int16 *)this + 152), HIDWORD(v49));
          if (v25) {
            break;
          }
          uint64_t v26 = v49 ? 0 : 0xFFFFFFFFLL;
          uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v22 + 16))(v22, 8, v26);
          if (v25) {
            break;
          }
          if (!--v24) {
            goto LABEL_18;
          }
        }
        uint64_t v27 = v25;
LABEL_30:
        int v13 = v43;
      }
      else
      {
        uint64_t v27 = 0;
        if (!IIOBitStream)
        {
LABEL_32:
          if (!v20) {
            goto LABEL_34;
          }
          goto LABEL_33;
        }
      }
      (*(void (**)(uint64_t))(*(void *)IIOBitStream + 8))(IIOBitStream);
      goto LABEL_32;
    }
    if (v16 == 8)
    {
      uint64_t v20 = IIOBitStream::CreateIIOBitStream((IIOBitStream *)((char *)v13 + v5 * (unint64_t)v3), (void *)(v48 * (unint64_t)v3), "r", v14);
      if (v3)
      {
        uint64_t v45 = v5;
        uint64_t v30 = 0;
        while (1)
        {
          (*(void (**)(uint64_t, unint64_t))(*(void *)v20 + 32))(v20, v30 * v48);
          if (v4) {
            break;
          }
LABEL_45:
          if (++v30 == v3)
          {
            uint64_t v27 = 0;
            uint64_t v22 = 0;
            goto LABEL_33;
          }
        }
        unsigned int v31 = (unsigned __int8 *)a2 + (~v30 + v3) * v47;
        uint64_t v32 = (unsigned __int8 *)v13 + v30 * v45;
        uint64_t v33 = v4;
        while (1)
        {
          uint64_t v34 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v20 + 24))(v20, 1, &v49);
          if (v34) {
            break;
          }
          unsigned __int8 v35 = *v32++;
          *unsigned int v31 = v35;
          if (v49) {
            char v36 = 0;
          }
          else {
            char v36 = -1;
          }
          v31[1] = v36;
          v31 += 2;
          if (!--v33) {
            goto LABEL_45;
          }
        }
        uint64_t v27 = v34;
        uint64_t v22 = 0;
        goto LABEL_33;
      }
    }
    else
    {
      if (v16 != 24)
      {
        if (v16 == 32)
        {
          if (v3)
          {
            uint64_t v28 = (unsigned __int8 *)a2 + (v3 - 1) * v47;
            unsigned int v29 = v13;
            do
            {
              memcpy(v28, v29, 4 * v4);
              unsigned int v29 = (IIOBitStream *)((char *)v29 + v5);
              v28 -= v47;
              --v3;
            }
            while (v3);
          }
        }
        else
        {
          _cg_jpeg_mem_term("decodeImageData", 559, "*** _rpd._inputGeo.bitsPerPixel [%d] not handled\n", *((unsigned __int16 *)this + 121));
        }
        uint64_t v27 = 0;
        goto LABEL_57;
      }
      uint64_t v20 = IIOBitStream::CreateIIOBitStream((IIOBitStream *)((char *)v13 + v5 * (unint64_t)v3), (void *)(v48 * (unint64_t)v3), "r", v14);
      if (v3)
      {
        unsigned __int8 v44 = v13;
        uint64_t v46 = v5;
        uint64_t v37 = 0;
        while (1)
        {
          (*(void (**)(uint64_t, unint64_t))(*(void *)v20 + 32))(v20, v37 * v48);
          if (v4) {
            break;
          }
LABEL_53:
          if (++v37 == v3)
          {
            uint64_t v27 = 0;
            uint64_t v22 = 0;
            int v13 = v44;
            goto LABEL_33;
          }
        }
        CFTypeID v38 = (unsigned __int8 *)a2 + (~v37 + v3) * v47;
        uint64_t v39 = (unsigned __int8 *)v44 + v37 * v46;
        uint64_t v40 = v4;
        while (1)
        {
          uint64_t v41 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v20 + 24))(v20, 1, &v49);
          if (v41) {
            break;
          }
          unsigned __int8 *v38 = *v39;
          v38[1] = v39[1];
          v38[2] = v39[2];
          void v38[3] = -1;
          v39 += 3;
          v38 += 4;
          if (!--v40) {
            goto LABEL_53;
          }
        }
        uint64_t v27 = v41;
        uint64_t v22 = 0;
        int v13 = v44;
        goto LABEL_33;
      }
    }
    uint64_t v22 = 0;
    uint64_t v27 = 0;
    if (!v20)
    {
LABEL_34:
      if (v22) {
        (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
      }
      goto LABEL_57;
    }
LABEL_33:
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
    goto LABEL_34;
  }
  uint64_t v27 = 4294967246;
LABEL_57:
  free(v13);
  return v27;
}

uint64_t ICOReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  memory_object_size_t v41 = 0;
  if ((gIIODebugFlags & 0x20000) == 0) {
    goto LABEL_26;
  }
  int v8 = *((_DWORD *)this + 51);
  unsigned int v9 = v8 >> 24;
  uint64_t v10 = MEMORY[0x1E4F14390];
  if (v8 < 0)
  {
    int v11 = __maskrune(v9, 0x40000uLL);
    int v8 = *((_DWORD *)this + 51);
  }
  else
  {
    int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
  }
  if (v11) {
    uint64_t v12 = (v8 >> 24);
  }
  else {
    uint64_t v12 = 46;
  }
  unsigned int v13 = v8 << 8 >> 24;
  if (v8 << 8 < 0)
  {
    int v14 = __maskrune(v13, 0x40000uLL);
    int v8 = *((_DWORD *)this + 51);
  }
  else
  {
    int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
  }
  if (v14) {
    uint64_t v15 = (v8 << 8 >> 24);
  }
  else {
    uint64_t v15 = 46;
  }
  unsigned int v16 = (__int16)v8 >> 8;
  if (v8 << 16 < 0)
  {
    int v17 = __maskrune(v16, 0x40000uLL);
    int v8 = *((_DWORD *)this + 51);
  }
  else
  {
    int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  }
  if (v17) {
    uint64_t v18 = ((__int16)v8 >> 8);
  }
  else {
    uint64_t v18 = 46;
  }
  if ((v8 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0) {
      goto LABEL_22;
    }
LABEL_24:
    uint64_t v19 = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v8, 0x40000uLL)) {
    goto LABEL_24;
  }
LABEL_22:
  uint64_t v19 = *((char *)this + 204);
LABEL_25:
  ImageIOLog("  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus ICOReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  uint64_t v20 = (IIOImageRead **)*((void *)this + 3);
  if (v20) {
    BOOL v21 = IIOImageReadSession::mapData(v20);
  }
  else {
    BOOL v21 = 0;
  }
  if (a3 == 3)
  {
    uint64_t BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v28) = *((_DWORD *)this + 73);
    double v27 = (double)v28;
    unsigned int v29 = *((_DWORD *)this + 74);
    double v26 = (double)v29;
    memory_object_size_t v25 = *((unsigned int *)this + 75) * (unint64_t)v29;
    BaseAddress = (void *)_ImageIO_Malloc(v25, *((void *)this + 48), &v41, (uint64_t)kImageMalloc_ICO_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4) {
      goto LABEL_48;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    size_t Height = IOSurfaceGetHeight(*a4);
    uint64_t BlockArray = 0;
    memory_object_size_t v25 = IOSurfaceGetBytesPerRow(*a4) * Height;
    memory_object_size_t v41 = v25;
    double v26 = 0.0;
    double v27 = 0.0;
  }
  if (!BaseAddress) {
    goto LABEL_49;
  }
  memset(BaseAddress, 255, v25);
  uint64_t BlockArray = (*(uint64_t (**)(IIOReadPlugin *, void *, memory_object_size_t))(*(void *)this + 120))(this, BaseAddress, v25);
  if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 152) == 8)
  {
    vImagePixelCount v30 = *((unsigned int *)this + 74);
    dest.data = BaseAddress;
    dest.vImagePixelCount height = v30;
    size_t v31 = *((unsigned int *)this + 75);
    dest.vImagePixelCount width = *((unsigned int *)this + 73);
    dest.size_t rowBytes = v31;
    if (*((unsigned char *)this + 405))
    {
      *(_DWORD *)permuteMap = 50331906;
      vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
    }
    if (*((unsigned char *)this + 406) == 1) {
      vImagePremultiplyData_RGBA8888(&dest, &dest, 0);
    }
  }
  if (BlockArray)
  {
    *((_DWORD *)this + 26) = 0;
    if (a3 == 3)
    {
      _ImageIO_Free((unint64_t)BaseAddress, v41);
      if (!v21) {
        return BlockArray;
      }
      goto LABEL_50;
    }
LABEL_49:
    if (!v21) {
      return BlockArray;
    }
    goto LABEL_50;
  }
  if (a3 != 3)
  {
    IOSurfaceUnlock(*a4, 0, 0);
LABEL_48:
    uint64_t BlockArray = 0;
    goto LABEL_49;
  }
  uint64_t v34 = 0;
  v42.origin.double x = 0.0;
  v42.origin.double y = 0.0;
  v42.size.vImagePixelCount width = v27;
  v42.size.vImagePixelCount height = v26;
  **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v25, v42, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
  if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E4F1DB20]))
  {
    uint64_t v35 = 0;
  }
  else
  {
    v43.origin.double x = 0.0;
    v43.origin.double y = 0.0;
    v43.size.vImagePixelCount width = v27;
    v43.size.vImagePixelCount height = v26;
    *(CGRect *)(&v35 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v43);
    uint64_t v34 = v36;
    double v27 = v37;
    double v26 = v38;
  }
  uint64_t BlockArray = 0;
  *((void *)this + 15) = v34;
  *((void *)this + 16) = v35;
  *((double *)this + 17) = v27;
  *((double *)this + 18) = v26;
  if (v21)
  {
LABEL_50:
    uint64_t v32 = (const char **)*((void *)this + 3);
    if (v32) {
      IIOImageReadSession::unmapData(v32);
    }
  }
  return BlockArray;
}

const char *IIODebug_ShowBacktrace(int a1)
{
  v8[128] = *(void **)MEMORY[0x1E4F143B8];
  bzero(v8, 0x400uLL);
  memset(&v7, 0, sizeof(v7));
  uint64_t result = (const char *)backtrace(v8, 128);
  if ((int)result < a1 || a1 < 1) {
    int v4 = 1;
  }
  else {
    int v4 = a1;
  }
  if (v4 < (int)result)
  {
    int v5 = (int)result;
    unint64_t v6 = (const void **)&v8[v4];
    do
    {
      if (dladdr(*v6, &v7)) {
        uint64_t result = ImageIOLog("%1.*s<%s+%ld>\n");
      }
      else {
        uint64_t result = ImageIOLog("%1.*s%08lx\n");
      }
      ++v4;
      ++v6;
    }
    while (v5 != v4);
  }
  return result;
}

const char *LogSurfaceFormat(__IOSurface *a1, const char *a2, const char *a3, int a4)
{
  signed int PixelFormat = IOSurfaceGetPixelFormat(a1);
  size_t Width = IOSurfaceGetWidth(a1);
  size_t Height = IOSurfaceGetHeight(a1);
  unsigned int v7 = PixelFormat >> 24;
  uint64_t v8 = MEMORY[0x1E4F14390];
  if (PixelFormat < 0) {
    int v9 = __maskrune(PixelFormat >> 24, 0x40000uLL);
  }
  else {
    int v9 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v7 + 60) & 0x40000;
  }
  unsigned int v10 = PixelFormat << 8 >> 24;
  if (PixelFormat << 8 < 0) {
    int v11 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
  }
  else {
    int v11 = *(_DWORD *)(v8 + 4 * v10 + 60) & 0x40000;
  }
  unsigned int v12 = (__int16)PixelFormat >> 8;
  if (PixelFormat << 16 < 0) {
    int v13 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
  }
  else {
    int v13 = *(_DWORD *)(v8 + 4 * v12 + 60) & 0x40000;
  }
  if ((PixelFormat << 24) <= 0x7F000000) {
    int v14 = *(_DWORD *)(v8 + 4 * (char)PixelFormat + 60) & 0x40000;
  }
  else {
    int v14 = __maskrune((char)PixelFormat, 0x40000uLL);
  }
  if (v13) {
    uint64_t v15 = v12;
  }
  else {
    uint64_t v15 = 46;
  }
  if (v11) {
    uint64_t v16 = v10;
  }
  else {
    uint64_t v16 = 46;
  }
  if (v9) {
    uint64_t v17 = v7;
  }
  else {
    uint64_t v17 = 46;
  }
  if (v14) {
    uint64_t v18 = (char)PixelFormat;
  }
  else {
    uint64_t v18 = 46;
  }
  return ImageIOLog("  %s:%d - %s %ldx%ld - '%c%c%c%c'\n", a3, a4, a2, Width, Height, v17, v16, v15, v18);
}

const char *LogPixelFormat(int a1, const char *a2, int a3)
{
  unsigned int v5 = a1 >> 24;
  uint64_t v6 = MEMORY[0x1E4F14390];
  if (a1 < 0) {
    int v7 = __maskrune(a1 >> 24, 0x40000uLL);
  }
  else {
    int v7 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v5 + 60) & 0x40000;
  }
  unsigned int v8 = a1 << 8 >> 24;
  if (a1 << 8 < 0) {
    int v9 = __maskrune(a1 << 8 >> 24, 0x40000uLL);
  }
  else {
    int v9 = *(_DWORD *)(v6 + 4 * v8 + 60) & 0x40000;
  }
  unsigned int v10 = (__int16)a1 >> 8;
  if (a1 << 16 < 0) {
    int v11 = __maskrune((__int16)a1 >> 8, 0x40000uLL);
  }
  else {
    int v11 = *(_DWORD *)(v6 + 4 * v10 + 60) & 0x40000;
  }
  if ((a1 << 24) <= 0x7F000000) {
    int v12 = *(_DWORD *)(v6 + 4 * (char)a1 + 60) & 0x40000;
  }
  else {
    int v12 = __maskrune((char)a1, 0x40000uLL);
  }
  if (v11) {
    uint64_t v13 = v10;
  }
  else {
    uint64_t v13 = 46;
  }
  if (v9) {
    uint64_t v14 = v8;
  }
  else {
    uint64_t v14 = 46;
  }
  if (v7) {
    uint64_t v15 = v5;
  }
  else {
    uint64_t v15 = 46;
  }
  if (v12) {
    uint64_t v16 = (char)a1;
  }
  else {
    uint64_t v16 = 46;
  }
  return ImageIOLog("  %s:%d - '%c%c%c%c'\n", a2, a3, v15, v14, v13, v16);
}

void ImageIODebugOptionsDictionary(const __CFDictionary *a1)
{
  if (a1)
  {
    if (CFDictionaryGetCount(a1) < 1)
    {
      ImageIOLog("    options: ()\n");
    }
    else
    {
      ImageIOLog("    options:\n");
      CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)OptionsApplyFunction, 0);
    }
  }
}

void OptionsApplyFunction(const void *a1, const void *a2, uint64_t a3)
{
  memset(v36, 0, sizeof(v36));
  IIOString::IIOString((IIOString *)v36, a1);
  if (a3 >= 4) {
    uint64_t v5 = 4;
  }
  else {
    uint64_t v5 = a3;
  }
  if (a2)
  {
    CFTypeID v6 = CFGetTypeID(a2);
    if (v6 == CFStringGetTypeID())
    {
      uint64_t v33 = 0;
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      IIOString::IIOString((IIOString *)&v33, a2);
      int v7 = (const char *)*((void *)&gIndents + v5);
      unsigned int v8 = (const char *)IIOString::utf8String((IIOString *)v36);
      int v9 = (const char *)IIOString::utf8String((IIOString *)&v33);
      ImageIOLog("      %s%s: %s\n", v7, v8, v9);
      IIOString::~IIOString((IIOString *)&v33);
    }
    else
    {
      CFTypeID v10 = CFGetTypeID(a2);
      if (v10 == CFNumberGetTypeID())
      {
        uint64_t v33 = 0;
        uint64_t v34 = 0;
        uint64_t v35 = 0;
        if (CFNumberIsFloatType((CFNumberRef)a2))
        {
          IIONumber::IIONumber((IIONumber *)&v33, (const __CFNumber *)a2);
          int v11 = (const char *)*((void *)&gIndents + v5);
          int v12 = (const char *)IIOString::utf8String((IIOString *)v36);
          float v13 = IIONumber::floatNum((IIONumber *)&v33);
          ImageIOLog("      %s%s: %g\n", v11, v12, v13);
        }
        else
        {
          IIONumber::IIONumber((IIONumber *)&v33, (const __CFNumber *)a2);
          uint64_t v22 = (const char *)*((void *)&gIndents + v5);
          uint64_t v23 = (const char *)IIOString::utf8String((IIOString *)v36);
          unint64_t v24 = IIONumber::uint64Num((IIONumber *)&v33);
          ImageIOLog("      %s%s: %ld\n", v22, v23, v24);
        }
        IIONumber::~IIONumber((IIONumber *)&v33);
      }
      else
      {
        CFTypeID v14 = CFGetTypeID(a2);
        if (v14 == CFBooleanGetTypeID())
        {
          int Value = CFBooleanGetValue((CFBooleanRef)a2);
          uint64_t v16 = (const char *)*((void *)&gIndents + v5);
          uint64_t v17 = (const char *)IIOString::utf8String((IIOString *)v36);
          uint64_t v18 = "true";
          if (!Value) {
            uint64_t v18 = "false";
          }
          ImageIOLog("      %s%s: %s\n", v16, v17, v18);
        }
        else
        {
          CFTypeID v19 = CFGetTypeID(a2);
          if (v19 == CFArrayGetTypeID())
          {
            uint64_t v20 = (const char *)*((void *)&gIndents + v5);
            BOOL v21 = (const char *)IIOString::utf8String((IIOString *)v36);
            ImageIOLog("      %s%s\n", v20, v21);
            v37.size_t length = CFArrayGetCount((CFArrayRef)a2);
            v37.location = 0;
            CFArrayApplyFunction((CFArrayRef)a2, v37, (CFArrayApplierFunction)OptionsArrayApplyFunction, (void *)(v5 + 1));
          }
          else
          {
            CFTypeID v25 = CFGetTypeID(a2);
            if (v25 == CFDictionaryGetTypeID())
            {
              double v26 = (const char *)*((void *)&gIndents + v5);
              double v27 = (const char *)IIOString::utf8String((IIOString *)v36);
              ImageIOLog("      %s%s\n", v26, v27);
              CFDictionaryApplyFunction((CFDictionaryRef)a2, (CFDictionaryApplierFunction)OptionsApplyFunction, (void *)(v5 + 2));
            }
            else
            {
              CFTypeID v28 = CFGetTypeID(a2);
              CFTypeID TypeID = CFNullGetTypeID();
              vImagePixelCount v30 = (const char *)*((void *)&gIndents + v5);
              if (v28 == TypeID)
              {
                size_t v31 = (const char *)IIOString::utf8String((IIOString *)v36);
                ImageIOLog("      %s%s: kCFNull\n", v30, v31);
              }
              else
              {
                uint64_t v32 = (const char *)IIOString::utf8String((IIOString *)v36);
                ImageIOLog("      %s%s: ", v30, v32);
                CFShow(a2);
              }
            }
          }
        }
      }
    }
  }
  IIOString::~IIOString((IIOString *)v36);
}

void sub_188759404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void ImageIODebugOptions(int a1, const char *a2, const char *a3, CFTypeRef cf, const char *a5, uint64_t a6, const __CFDictionary *a7)
{
  if (!cf)
  {
    if (a5)
    {
LABEL_7:
      if (a6 < 0) {
        ImageIOLog("%s   %s - '%s'\n");
      }
      else {
        ImageIOLog("%s   %s[%ld] - '%s'\n");
      }
LABEL_17:
      CFStringRef v14 = 0;
      goto LABEL_20;
    }
LABEL_12:
    if (a6 < 0) {
      ImageIOLog("%s   %s\n");
    }
    else {
      ImageIOLog("%s   %s[%ld]\n");
    }
    goto LABEL_17;
  }
  CFStringRef v13 = CFCopyDescription(cf);
  CFStringRef v14 = v13;
  if (!a5)
  {
    if (v13)
    {
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      IIOString::IIOString((IIOString *)&v17, v13);
      uint64_t v16 = (const char *)IIOString::utf8String((IIOString *)&v17);
      if (a6 < 0) {
        ImageIOLog("%s   %s  %s\n", a2, a3, v16);
      }
      else {
        ImageIOLog("%s   %s[%ld]  %s\n", a2, a3, a6, v16);
      }
      goto LABEL_19;
    }
    goto LABEL_12;
  }
  if (!v13) {
    goto LABEL_7;
  }
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  IIOString::IIOString((IIOString *)&v17, v13);
  uint64_t v15 = (const char *)IIOString::utf8String((IIOString *)&v17);
  if (a6 < 0) {
    ImageIOLog("%s   %s - '%s' - '%s'\n", a2, a3, v15, a5);
  }
  else {
    ImageIOLog("%s   %s[%ld] - '%s' - '%s'\n", a2, a3, a6, v15, a5);
  }
LABEL_19:
  IIOString::~IIOString((IIOString *)&v17);
LABEL_20:
  if (a1 >= 2) {
    ImageIODebugOptionsDictionary(a7);
  }
  if (v14) {
    CFRelease(v14);
  }
}

void sub_1887595F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

const char *IIODebugOrientation(const char *result, int a2, IIODictionary *this)
{
  if ((gIIODebugFlags & 0x2000000000000) != 0)
  {
    if (this)
    {
      if (IIODictionary::containsKey(this, @"Orientation"))
      {
        unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(this, @"Orientation");
        if ((IIODictionary::containsKeyGroup(this, @"Orientation", @"{TIFF}") & 1) == 0)
        {
          if (Uint32ForKey) {
            return ImageIOLog("%s %s:%d - Orientation top: %d\n");
          }
          return ImageIOLog("%s %s:%d - Orientation not found in dictionary\n");
        }
        unsigned int Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(this, @"Orientation", @"{TIFF}");
        if (Uint32ForKey)
        {
          if (Uint32ForKeyGroup) {
            return ImageIOLog("%s %s:%d - Orientation top+tiff: %d / %d\n");
          }
          return ImageIOLog("%s %s:%d - Orientation top: %d\n");
        }
        goto LABEL_10;
      }
      if (IIODictionary::containsKeyGroup(this, @"Orientation", @"{TIFF}"))
      {
        unsigned int Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(this, @"Orientation", @"{TIFF}");
LABEL_10:
        if (Uint32ForKeyGroup) {
          return ImageIOLog("%s %s:%d - Orientation tiff: %d\n");
        }
      }
    }
    return ImageIOLog("%s %s:%d - Orientation not found in dictionary\n");
  }
  return result;
}

void OptionsArrayApplyFunction(const void *a1, uint64_t a2)
{
  if (a2 >= 4) {
    uint64_t v3 = 4;
  }
  else {
    uint64_t v3 = a2;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFStringGetTypeID())
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    IIOString::IIOString((IIOString *)&v18, a1);
    uint64_t v5 = (const char *)*((void *)&gIndents + v3);
    CFTypeID v6 = (const char *)IIOString::utf8String((IIOString *)&v18);
    ImageIOLog("      %s %s\n", v5, v6);
    IIOString::~IIOString((IIOString *)&v18);
  }
  else
  {
    CFTypeID v7 = CFGetTypeID(a1);
    if (v7 == CFNumberGetTypeID())
    {
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      uint64_t v20 = 0;
      if (CFNumberIsFloatType((CFNumberRef)a1))
      {
        IIONumber::IIONumber((IIONumber *)&v18, (const __CFNumber *)a1);
        unsigned int v8 = (const char *)*((void *)&gIndents + v3);
        float v9 = IIONumber::floatNum((IIONumber *)&v18);
        ImageIOLog("      %s %g\n", v8, v9);
      }
      else
      {
        IIONumber::IIONumber((IIONumber *)&v18, (const __CFNumber *)a1);
        uint64_t v15 = (const char *)*((void *)&gIndents + v3);
        unint64_t v16 = IIONumber::uint64Num((IIONumber *)&v18);
        ImageIOLog("      %s %ld\n", v15, v16);
      }
      IIONumber::~IIONumber((IIONumber *)&v18);
    }
    else
    {
      CFTypeID v10 = CFGetTypeID(a1);
      if (v10 == CFBooleanGetTypeID())
      {
        int Value = CFBooleanGetValue((CFBooleanRef)a1);
        int v12 = "true";
        if (!Value) {
          int v12 = "false";
        }
        ImageIOLog("      %s %s\n", *((const char **)&gIndents + v3), v12);
      }
      else
      {
        CFTypeID v13 = CFGetTypeID(a1);
        if (v13 == CFArrayGetTypeID())
        {
          ImageIOLog("      %s\n", *((const char **)&gIndents + v3));
          v14.size_t length = CFArrayGetCount((CFArrayRef)a1);
          v14.location = 0;
          CFArrayApplyFunction((CFArrayRef)a1, v14, (CFArrayApplierFunction)OptionsArrayApplyFunction, (void *)(v3 + 1));
        }
        else
        {
          CFTypeID v17 = CFGetTypeID(a1);
          if (v17 == CFDictionaryGetTypeID())
          {
            CFDictionaryApplyFunction((CFDictionaryRef)a1, (CFDictionaryApplierFunction)OptionsApplyFunction, (void *)(v3 + 1));
          }
          else
          {
            CFShow(a1);
          }
        }
      }
    }
  }
}

void sub_1887599F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void flush_fn(uint64_t a1)
{
  io_ptr = (const void *)_cg_png_get_io_ptr(a1);

  CFRelease(io_ptr);
}

void handle_write_error(uint64_t a1, const char *a2)
{
  if (a2)
  {
    if (*a2) {
      LogError("handle_write_error", 113, "%s\n", a2);
    }
  }
  exception = __cxa_allocate_exception(4uLL);
  _DWORD *exception = -1;
  __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
}

void PNGWritePlugin::reduceFrame(PNGWritePlugin *this, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 *a4, int a5, unsigned int *a6, unsigned int *a7, unsigned int *a8, unsigned int *a9)
{
  unsigned int v13 = *a8;
  unsigned int v14 = v13 - 1;
  unsigned int v15 = *a9;
  unsigned int v16 = *a9 - 1;
  if (v13 >= 2) {
    unsigned int v17 = 2;
  }
  else {
    unsigned int v17 = v13;
  }
  if (v15 >= 2) {
    int v18 = 2;
  }
  else {
    int v18 = *a9;
  }
  if (a5 == 4)
  {
    uint64_t v36 = a7;
    CFRange v37 = a6;
    unsigned int v54 = v13;
    int v55 = v18;
    unsigned int v53 = v17;
    unsigned int v38 = *a9;
    bzero(a4, *((void *)this + 8));
    unsigned int v15 = v38;
    unsigned int v17 = v53;
    unsigned int v13 = v54;
    int v18 = v55;
    a6 = v37;
    a7 = v36;
    unsigned int v39 = *a9;
    if (!*a9)
    {
LABEL_57:
      *a6 = v13 >> 1;
      *a7 = v15 >> 1;
      *a8 = v17;
      goto LABEL_58;
    }
    int v19 = 0;
    unsigned int v40 = 0;
    unsigned int v21 = 0;
    unsigned int v22 = 0;
    unsigned int v41 = *a8;
    do
    {
      if (v41)
      {
        unsigned int v42 = 0;
        do
        {
          int v44 = *(_DWORD *)a2;
          a2 += 4;
          int v43 = v44;
          int v46 = *(_DWORD *)a3;
          a3 += 4;
          int v45 = v46;
          unsigned int v47 = v46 | v43;
          if (v42 >= v14) {
            unsigned int v48 = v14;
          }
          else {
            unsigned int v48 = v42;
          }
          if (v42 <= v22) {
            unsigned int v49 = v22;
          }
          else {
            unsigned int v49 = v42;
          }
          if (v40 >= v16) {
            unsigned int v50 = v16;
          }
          else {
            unsigned int v50 = v40;
          }
          if (v40 <= v21) {
            unsigned int v51 = v21;
          }
          else {
            unsigned int v51 = v40;
          }
          if (v43 != v45 && HIBYTE(v47) != 0)
          {
            unsigned int v14 = v48;
            unsigned int v16 = v50;
            unsigned int v22 = v49;
            unsigned int v21 = v51;
            ++v19;
          }
          *(_DWORD *)a4 = v43;
          a4 += 4;
          ++v42;
          unsigned int v41 = *a8;
        }
        while (v42 < *a8);
        unsigned int v39 = *a9;
      }
      ++v40;
    }
    while (v40 < v39);
  }
  else
  {
    if (a5 != 3 || !v15) {
      goto LABEL_57;
    }
    int v19 = 0;
    unsigned int v20 = 0;
    unsigned int v21 = 0;
    unsigned int v22 = 0;
    unsigned int v23 = *a9;
    unsigned int v24 = v13;
    do
    {
      if (v24)
      {
        unsigned int v25 = 0;
        do
        {
          int v26 = (a2[2] << 16) | (a2[1] << 8);
          int v27 = *a2;
          a2 += 3;
          int v28 = v26 | v27;
          int v29 = (a3[2] << 16) | (a3[1] << 8);
          int v30 = *a3;
          a3 += 3;
          int v31 = v29 | v30;
          if (v25 >= v14) {
            unsigned int v32 = v14;
          }
          else {
            unsigned int v32 = v25;
          }
          if (v25 <= v22) {
            unsigned int v33 = v22;
          }
          else {
            unsigned int v33 = v25;
          }
          if (v20 >= v16) {
            unsigned int v34 = v16;
          }
          else {
            unsigned int v34 = v20;
          }
          if (v20 <= v21) {
            unsigned int v35 = v21;
          }
          else {
            unsigned int v35 = v20;
          }
          if (v28 != v31)
          {
            unsigned int v14 = v32;
            unsigned int v16 = v34;
            unsigned int v22 = v33;
            unsigned int v21 = v35;
            ++v19;
          }
          *(_WORD *)a4 = v31;
          a4[2] = BYTE2(v31);
          a4 += 3;
          ++v25;
          unsigned int v24 = *a8;
        }
        while (v25 < *a8);
        unsigned int v23 = *a9;
      }
      ++v20;
    }
    while (v20 < v23);
  }
  if (!v19) {
    goto LABEL_57;
  }
  *a6 = v14;
  *a7 = v16;
  *a8 = v22 - v14 + 1;
  int v18 = v21 - v16 + 1;
LABEL_58:
  *a9 = v18;
}

uint64_t PNGWritePlugin::writeAPNGFrame(PNGWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3)
{
  unsigned int v68 = 0;
  __int16 v67 = 0;
  uint64_t Ref = IIOImageSource::imageReadRef(a2);
  CGImageGetImageProvider();
  unsigned int v7 = IIOImageSource::count(a2);
  unsigned int v8 = IIO_Reader::testHeaderSize(a2);
  uint64_t v9 = IIOImagePlus::sourceImageProvider(a2);
  uint64_t Property = CGImageProviderGetProperty();
  if (Property) {
    BOOL v11 = Property == *MEMORY[0x1E4F1CFD0];
  }
  else {
    BOOL v11 = 0;
  }
  image = (CGImage *)Ref;
  if (!v11) {
    goto LABEL_5;
  }
  LODWORD(v12) = *((unsigned char *)this + 124) == 0;
  uint64_t v13 = v9;
  if (*((unsigned char *)this + 124))
  {
LABEL_9:
    *((unsigned char *)this + 123) = 0;
    goto LABEL_10;
  }
  if (v9 == v7)
  {
    uint64_t v13 = 3 * v7;
    goto LABEL_9;
  }
LABEL_5:
  LODWORD(v12) = 0;
  uint64_t v13 = v9;
LABEL_10:
  uint64_t v14 = v8;
  uint64_t v15 = v9 * v8;
  if (IIOImagePixelDataProvider::hasAlpha(a2)
    || *((unsigned char *)this + 121)
    || (IIOImagePixelDataProvider::srcFormat(a2, (uint64_t)v63), DWORD1(v63[0]) != 24))
  {
    int v58 = 0;
    unint64_t v62 = v9 * v8;
  }
  else
  {
    _cg_png_set_appleflags((uint64_t)a2, 32);
    uint64_t v9 = 4 * v7;
    unint64_t v62 = v8 * (unint64_t)v9;
    int v58 = 1;
  }
  size_t size = v13 * v8;
  if (*((unsigned char *)this + 36))
  {
    ImageIOLog("            bufferSize:  %d\n", v62);
    ImageIOLog("           dstRowbytes:  %d\n", v13);
    ImageIOLog("              rowbytes:  %d\n", v9);
    ImageIOLog("    expandIndexedToRGB:  %d\n", v12);
    ImageIOLog("        expandRGB2RGBA:  %d\n", v58);
    ImageIOLog("      _optimizeForSize:  %d\n", *((unsigned __int8 *)this + 123));
  }
  char v59 = (char)v12;
  unsigned int v60 = v8;
  if (*((_DWORD *)this + 18) >= 2u && !*((void *)this + 7))
  {
    *((void *)this + 8) = size;
    *((void *)this + 7) = malloc_type_malloc(size, 0xDB24162FuLL);
  }
  unsigned int v68 = (char *)malloc_type_malloc(v62, 0x363948A8uLL);
  __int16 v67 = (unsigned __int8 *)malloc_type_malloc(size, 0x1E2BDCDCuLL);
  CFStringRef v16 = @"UnclampedDelayTime";
  if ((IIODictionary::containsKeyGroup(a3, @"UnclampedDelayTime", @"{PNG}") & 1) != 0
    || (CFStringRef v16 = @"DelayTime", IIODictionary::containsKeyGroup(a3, @"DelayTime", @"{PNG}")))
  {
    double DoubleForKeyGroup = IIODictionary::getDoubleForKeyGroup(a3, v16, @"{PNG}");
  }
  else
  {
    double DoubleForKeyGroup = 0.1;
  }
  *(void *)int v66 = 0;
  unsigned int v18 = v60;
  unsigned int v64 = v60;
  unsigned int v65 = v7;
  uint64_t Bytes = IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v68);
  if (Bytes != v15)
  {
    _cg_jpeg_mem_term("writeAPNGFrame", 1337, "    iPixelDataProvider->getBytes - expected: %d  got: %d\n", v15, Bytes);
    uint64_t v52 = 0;
    goto LABEL_60;
  }
  if (v58)
  {
    memset(v63, 0, sizeof(v63));
    IIOPixelConverterRGB::IIOPixelConverterRGB((uint64_t)v63, 0, 3, 8u, 8, 8, 0, 2, 8u, 0, 0);
    malloc_type_malloc(4 * v7, 0xF145935EuLL);
    uint64_t v54 = 3 * v7;
    unint64_t v55 = 4 * (v7 & 0x3FFFFFFF) * (unint64_t)(v60 - 1);
    for (unint64_t i = v54 * (unint64_t)(v60 - 1); ; i -= v54)
    {
      IIOPixelConverterRGB::convertRow((IIOPixelConverterRGB *)v63, (unsigned __int8 *)&v68[i], (unsigned __int8 *)&v68[v55], v7);
      v55 -= 4 * v7;
    }
  }
  if (v12)
  {
    CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
    BaseCGColorSpaceRef ColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
    size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(BaseColorSpace);
    ColorTableCFIndex Count = CGColorSpaceGetColorTableCount(ColorSpace);
    int v12 = (uint8_t *)malloc_type_calloc(NumberOfComponents, ColorTableCount, 0xFFB506BFuLL);
    CGColorSpaceGetColorTable(ColorSpace, v12);
    if (v14)
    {
      for (uint64_t j = 0; j != v14; ++j)
      {
        if (v7)
        {
          unsigned int v25 = &v67[j * v13];
          unsigned int v26 = v7;
          int v27 = (unsigned __int8 *)&v68[j * v9];
          do
          {
            int v28 = *v27++;
            int v29 = &v12[3 * v28];
            unsigned __int8 *v25 = *v29;
            v25[1] = v29[1];
            int v25[2] = v29[2];
            v25 += 3;
            --v26;
          }
          while (v26);
        }
      }
    }
    free(v12);
    unsigned int v18 = v60;
    LOBYTE(v12) = v59;
  }
  if (*((_DWORD *)this + 19) && *((unsigned char *)this + 123) && !*((unsigned char *)this + 124))
  {
    PNGWritePlugin::reduceFrame(this, (unsigned __int8 *)v68, *((unsigned __int8 **)this + 7), v67, 4, &v66[1], v66, &v65, &v64);
    if (*((unsigned char *)this + 36))
    {
      ImageIOLog("            orig-frame:  {%6d, %6d, %6d, %6d}\n", 0, 0, v7, v18);
      ImageIOLog("         reduced-frame:  {%6d, %6d, %6d, %6d}\n", v66[1], v66[0], v65, v64);
    }
    if (v12) {
      goto LABEL_46;
    }
    goto LABEL_42;
  }
  if ((v12 & 1) == 0)
  {
    if (v62 >= size) {
      size_t v30 = v13 * v14;
    }
    else {
      size_t v30 = v62;
    }
    memcpy(v67, v68, v30);
LABEL_42:
    if (v62 >= *((void *)this + 8)) {
      size_t v31 = *((void *)this + 8);
    }
    else {
      size_t v31 = v62;
    }
    memcpy(*((void **)this + 7), v68, v31);
  }
LABEL_46:
  uint64_t v32 = v64;
  uint64_t v33 = v66[0];
  unsigned int v34 = v66[1];
  _cg_png_write_frame_head(*((void *)this + 5), *((unsigned __int8 **)this + 6), 0, v65, v64, v66[1], v66[0], (int)(DoubleForKeyGroup * 1000.0), 0x3E8u, 0, 0);
  if (v32)
  {
    uint64_t v35 = 0;
    uint64_t v36 = 4 * v34 + v13 * v33;
    CFRange v37 = &v67[v36];
    uint64_t v38 = v7;
    uint64_t v39 = 4 * v7;
    unsigned int v40 = &v67[2 * v7 - 1 + v36];
    unsigned int v41 = &v67[v36 - 1 + v7];
    do
    {
      if (*((unsigned char *)this + 122))
      {
        if (*((unsigned char *)this + 84) == 4)
        {
          if (v38)
          {
            uint64_t v42 = 0;
            int v43 = v41;
            do
            {
              unsigned int v44 = *v43--;
              unint64_t v45 = 3 * ((unint64_t)v44 >> 4);
              int v46 = (char *)&v37[v39 + v42];
              *(v46 - 4) = *(unsigned char *)(*((void *)this + 14) + v45);
              *(v46 - 3) = *(unsigned char *)(v45 + *((void *)this + 14) + 1);
              *(v46 - 2) = *(unsigned char *)(v45 + *((void *)this + 14) + 2);
              *(v46 - 1) = v44 & 0xF | (16 * v44);
              v42 -= 4;
            }
            while (v39 + v42);
          }
        }
        else if (v38)
        {
          uint64_t v47 = 0;
          unsigned int v48 = v40;
          do
          {
            uint64_t v49 = *(v48 - 1);
            char v50 = *v48;
            v48 -= 2;
            v49 *= 3;
            unsigned int v51 = (char *)&v37[v39 + v47];
            *(v51 - 4) = *(unsigned char *)(*((void *)this + 14) + v49);
            *(v51 - 3) = *(unsigned char *)(v49 + *((void *)this + 14) + 1);
            *(v51 - 2) = *(unsigned char *)(v49 + *((void *)this + 14) + 2);
            *(v51 - 1) = v50;
            v47 -= 4;
          }
          while (v39 + v47);
        }
      }
      _cg_png_write_row_sized(*((void *)this + 5), v37);
      ++v35;
      v37 += v13;
      v40 += v13;
      v41 += v13;
    }
    while (v35 != v32);
  }
  _cg_png_write_frame_tail(*((void *)this + 5));
  uint64_t v52 = 1;
LABEL_60:
  if (v67) {
    free(v67);
  }
  if (v68) {
    free(v68);
  }
  return v52;
}

void sub_18875A3E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  IIOPixelConverterRGB::~IIOPixelConverterRGB((IIOPixelConverterRGB *)va);
  _Unwind_Resume(a1);
}

uint64_t PNGWritePlugin::writeOneImage(PNGWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t imagePNG_write_error_break(uint64_t a1)
{
  LogError("imagePNG_write_error_break", 90, "*** ERROR: imagePNG_write_error_break\n");
  *gCrashMessage = 0;
  uint64_t result = snprintf(gCrashMessage, 0x200uLL, "*** ERROR: PNG-writeAll  %dx%d  bpc: %d  cs: %d", *(_DWORD *)(a1 + 280), *(_DWORD *)(a1 + 284), *(unsigned __int8 *)(a1 + 392), *(unsigned __int8 *)(a1 + 391));
  qword_1EB2BF498 = gCrashMessage;
  return result;
}

uint64_t PNGWritePlugin::WriteImageWithSession(PNGWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, IIOImagePixelDataProvider *a4, IIODictionary *a5, IIODictionary *a6)
{
  long long v18 = 0u;
  long long v19 = 0u;
  memset(v17, 0, sizeof(v17));
  long long v15 = 0u;
  long long v16 = 0u;
  memset(v14, 0, sizeof(v14));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v14, this, a2, 1347307296);
  *(void *)&v17[0] = 0;
  DWORD2(v17[0]) = 1;
  *(void *)((char *)v17 + 12) = 0;
  BYTE4(v17[1]) = 0;
  *(_DWORD *)((char *)&v19 + 9) = 1;
  *((void *)&v15 + 1) = 0;
  long long v16 = 0uLL;
  *(void *)&v14[0] = &unk_1ED4E2C38;
  *((void *)&v18 + 1) = 0;
  *(void *)&long long v19 = 0;
  PNGWritePlugin::writePrologue((PNGWritePlugin *)v14, a3, a4);
  uint64_t v8 = PNGWritePlugin::writePNG((PNGWritePlugin *)v14, a3, a4);
  PNGWritePlugin::writeEpilogue((PNGWritePlugin *)v14, v9, v10);
  PNGWritePlugin::~PNGWritePlugin((PNGWritePlugin *)v14, v11, v12);
  return v8;
}

void sub_18875A5A0(void *a1)
{
}

uint64_t PNGWritePlugin::writeOne(PNGWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967292;
}

uint64_t _TIFFNoRowEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 0xFFFFFFFFLL;
}

uint64_t TIFFNoEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(unsigned __int16 *)(a1 + 120);
  uint64_t v9 = &registeredCODECS;
  while (1)
  {
    uint64_t v9 = (uint64_t *)*v9;
    if (!v9) {
      break;
    }
    uint64_t v10 = v9[1];
    if (*(unsigned __int16 *)(v10 + 8) == v8)
    {
      uint64_t v11 = *(void *)v10;
      return TIFFErrorExtR(a1, *(const char **)a1, "%s %s encoding is not implemented", a4, a5, a6, a7, a8, v11);
    }
  }
  LOBYTE(v11) = (_BYTE)_TIFFBuiltinCODECS;
  if (_TIFFBuiltinCODECS)
  {
    if ((unsigned __int16)word_1ED4B4630 == v8) {
      return TIFFErrorExtR(a1, *(const char **)a1, "%s %s encoding is not implemented", a4, a5, a6, a7, a8, v11);
    }
    for (unint64_t i = &word_1ED4B4648; ; i += 12)
    {
      uint64_t v11 = *((void *)i - 1);
      if (!v11) {
        break;
      }
      int v13 = (unsigned __int16)*i;
      if (v13 == v8) {
        return TIFFErrorExtR(a1, *(const char **)a1, "%s %s encoding is not implemented", a4, a5, a6, a7, a8, v11);
      }
    }
  }
  return TIFFErrorExtR(a1, *(const char **)a1, "Compression scheme %hu %s encoding is not implemented", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 120));
}

uint64_t _TIFFNoStripEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 0xFFFFFFFFLL;
}

uint64_t _TIFFNoTileEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 0xFFFFFFFFLL;
}

uint64_t _TIFFNoRowDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 0;
}

uint64_t TIFFNoDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(unsigned __int16 *)(a1 + 120);
  uint64_t v9 = &registeredCODECS;
  while (1)
  {
    uint64_t v9 = (uint64_t *)*v9;
    if (!v9) {
      break;
    }
    uint64_t v10 = v9[1];
    if (*(unsigned __int16 *)(v10 + 8) == v8)
    {
      uint64_t v11 = *(void *)v10;
      return TIFFErrorExtR(a1, *(const char **)a1, "%s %s decoding is not implemented", a4, a5, a6, a7, a8, v11);
    }
  }
  LOBYTE(v11) = (_BYTE)_TIFFBuiltinCODECS;
  if (_TIFFBuiltinCODECS)
  {
    if ((unsigned __int16)word_1ED4B4630 == v8) {
      return TIFFErrorExtR(a1, *(const char **)a1, "%s %s decoding is not implemented", a4, a5, a6, a7, a8, v11);
    }
    for (unint64_t i = &word_1ED4B4648; ; i += 12)
    {
      uint64_t v11 = *((void *)i - 1);
      if (!v11) {
        break;
      }
      int v13 = (unsigned __int16)*i;
      if (v13 == v8) {
        return TIFFErrorExtR(a1, *(const char **)a1, "%s %s decoding is not implemented", a4, a5, a6, a7, a8, v11);
      }
    }
  }
  return TIFFErrorExtR(a1, *(const char **)a1, "Compression scheme %hu %s decoding is not implemented", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 120));
}

uint64_t _TIFFNoStripDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 0;
}

uint64_t _TIFFNoTileDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return 0;
}

uint64_t _TIFFNoSeek(const char **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  TIFFErrorExtR((uint64_t)a1, *a1, "Compression algorithm does not support random access", a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t _TIFFNoPreCode()
{
  return 1;
}

uint64_t _TIFFSetDefaultCompressionState(uint64_t result)
{
  *(void *)(result + 952) = _TIFFNoFixupTags;
  *(_DWORD *)(result + 944) = 1;
  *(void *)(result + 960) = _TIFFtrue;
  *(void *)(result + 968) = _TIFFNoPreCode;
  *(void *)(result + 1008) = _TIFFNoRowDecode;
  *(void *)(result + 1024) = _TIFFNoStripDecode;
  *(void *)(result + 1040) = _TIFFNoTileDecode;
  *(_DWORD *)(result + 984) = 1;
  *(void *)(result + 976) = _TIFFtrue;
  *(void *)(result + 992) = _TIFFNoPreCode;
  *(void *)(result + 1000) = _TIFFtrue;
  *(void *)(result + 1016) = _TIFFNoRowEncode;
  *(void *)(result + 1032) = _TIFFNoStripEncode;
  *(void *)(result + 1048) = _TIFFNoTileEncode;
  *(void *)(result + 1056) = _TIFFvoid;
  *(void *)(result + 1064) = _TIFFNoSeek;
  *(void *)(result + 1072) = _TIFFvoid;
  *(void *)(result + 1080) = _TIFFDefaultStripSize;
  *(void *)(result + 1088) = _TIFFDefaultTileSize;
  *(_DWORD *)(result + 16) &= 0xFFFDFEFF;
  return result;
}

uint64_t _TIFFNoFixupTags()
{
  return 1;
}

uint64_t _TIFFtrue()
{
  return 1;
}

uint64_t TIFFSetCompressionScheme(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = &registeredCODECS;
  while (1)
  {
    CFTypeID v4 = (uint64_t *)*v4;
    if (!v4) {
      break;
    }
    uint64_t v5 = (char **)v4[1];
    if (*((unsigned __int16 *)v5 + 4) == (unsigned __int16)a2) {
      goto LABEL_4;
    }
  }
  if (!_TIFFBuiltinCODECS)
  {
LABEL_11:
    _TIFFSetDefaultCompressionState(a1);
    return 1;
  }
  uint64_t v5 = &_TIFFBuiltinCODECS;
  while (*((unsigned __int16 *)v5 + 4) != (unsigned __int16)a2)
  {
    int v8 = v5[3];
    v5 += 3;
    if (!v8) {
      goto LABEL_11;
    }
  }
LABEL_4:
  _TIFFSetDefaultCompressionState(a1);
  CFTypeID v6 = v5[2];

  return ((uint64_t (*)(uint64_t, uint64_t))v6)(a1, a2);
}

char **_cg_TIFFFindCODEC(int a1)
{
  uint64_t v1 = &registeredCODECS;
  while (1)
  {
    uint64_t v1 = (uint64_t *)*v1;
    if (!v1) {
      break;
    }
    unint64_t i = (char **)v1[1];
    if (*((unsigned __int16 *)i + 4) == a1) {
      return i;
    }
  }
  unint64_t i = (char **)_TIFFBuiltinCODECS;
  if (_TIFFBuiltinCODECS)
  {
    for (unint64_t i = &_TIFFBuiltinCODECS; *((unsigned __int16 *)i + 4) != a1; i += 3)
    {
      if (!i[3]) {
        return 0;
      }
    }
  }
  return i;
}

uint64_t IIOSavePermissionsToXPCObject(void *a1)
{
  if (gPermissionsChanged == 1)
  {
    xpc_object_t v1 = iio_xpc_add_permission_dict(a1);
    if (v1) {
      xpc_dictionary_set_uint64(v1, "iio_xpc_permission_data", gPermissions);
    }
  }
  return 0;
}

uint64_t IIOSaveAllowedTypesToXPCObject(void *a1)
{
  if (gAllowedTypesChanged == 1)
  {
    xpc_object_t v1 = iio_xpc_add_permission_dict(a1);
    if (v1) {
      iio_xpc_dictionary_add_CFDictionary(v1, "iio_xpc_permission_allowed_types_array");
    }
  }
  return 0;
}

uint64_t IIOXPCUpdatePermissions(void *a1)
{
  xpc_object_t permission_dict = iio_xpc_get_permission_dict(a1);
  if (!permission_dict) {
    return 0;
  }
  int uint64 = xpc_dictionary_get_uint64(permission_dict, "iio_xpc_permission_data");
  int v3 = uint64;
  if ((uint64 & 1) == 0) {
    return 0;
  }
  char v6 = gPermissions ^ uint64;
  if (((gPermissions ^ uint64) & 2) != 0)
  {
    uint64_t v4 = IIODisableRAWDecoding();
    IIOXPCLog(" RAWDecoding disabled\n");
    char v6 = gPermissions ^ v3;
    if (((gPermissions ^ v3) & 4) == 0) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  uint64_t v4 = 0;
  if (((gPermissions ^ uint64) & 4) != 0)
  {
LABEL_9:
    uint64_t v4 = IIODisableMetadataParsing();
    IIOXPCLog(" MetadataParsing disabled\n");
    char v6 = gPermissions ^ v3;
  }
LABEL_10:
  if ((v6 & 8) == 0)
  {
    if ((v6 & 0x10) == 0) {
      goto LABEL_12;
    }
LABEL_15:
    uint64_t v4 = IIOEnableRestrictedDecoding();
    IIOXPCLog(" RestrictedDecoding enabled\n");
    if (((gPermissions ^ v3) & 0x20) == 0) {
      return v4;
    }
    goto LABEL_16;
  }
  uint64_t v4 = IIODisableHardwareDecoding();
  IIOXPCLog(" HardwareDecoding disabled\n");
  char v6 = gPermissions ^ v3;
  if (((gPermissions ^ v3) & 0x10) != 0) {
    goto LABEL_15;
  }
LABEL_12:
  if ((v6 & 0x20) == 0) {
    return v4;
  }
LABEL_16:
  uint64_t v7 = IIODisableCaching();
  IIOXPCLog(" caching disabled\n");
  return v7;
}

uint64_t IIODisableRAWDecoding()
{
  kdebug_trace();
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2000000000;
  int v6 = -50;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __IIODisableRAWDecoding_block_invoke;
  block[3] = &unk_1E53C71B0;
  block[4] = &v3;
  if (IIODisableRAWDecoding::onceToken != -1) {
    dispatch_once(&IIODisableRAWDecoding::onceToken, block);
  }
  uint64_t v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t IIODisableMetadataParsing()
{
  kdebug_trace();
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2000000000;
  int v6 = -50;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __IIODisableMetadataParsing_block_invoke;
  block[3] = &unk_1E53C71D8;
  block[4] = &v3;
  if (IIODisableMetadataParsing::onceToken != -1) {
    dispatch_once(&IIODisableMetadataParsing::onceToken, block);
  }
  uint64_t v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t IIODisableCaching()
{
  kdebug_trace();
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2000000000;
  int v6 = -50;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = __IIODisableCaching_block_invoke;
  block[3] = &unk_1E53C7250;
  block[4] = &v3;
  if (IIODisableCaching::onceToken != -1) {
    dispatch_once(&IIODisableCaching::onceToken, block);
  }
  uint64_t v0 = *((unsigned int *)v4 + 6);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t IIOXPCUpdateAllowableTypes(void *a1)
{
  if (gAllowedTypesChanged) {
    return 0;
  }
  xpc_object_t permission_dict = iio_xpc_get_permission_dict(a1);
  if (!permission_dict) {
    return 0;
  }
  if (!xpc_dictionary_get_array(permission_dict, "iio_xpc_permission_allowed_types_array")) {
    return 0;
  }
  int v2 = (const void *)_CFXPCCreateCFObjectFromXPCObject();
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  uint64_t v4 = IIODecodingSetAllowableTypes(v2);
  IIOXPCLog(" AllowableTypes updated\n");
  CFRelease(v3);
  return v4;
}

uint64_t __IIODisableRAWDecoding_block_invoke(IIO_ReaderHandler *a1)
{
  xpc_object_t v1 = a1;
  if ((gIIODebugFlags & 0x4000000000000) != 0)
  {
    a1 = (IIO_ReaderHandler *)IIO_OSAppleInternalBuild();
    if (a1) {
      a1 = (IIO_ReaderHandler *)ImageIOLog(" CGImageSourceDisableRAWDecoding - RAW formats will no longer be handled in this process\n");
    }
  }
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(a1);
  uint64_t result = IIO_ReaderHandler::disableRAWPlugins(ReaderHandler);
  *(_DWORD *)(*(void *)(*((void *)v1 + 4) + 8) + 24) = result;
  if (!*(_DWORD *)(*(void *)(*((void *)v1 + 4) + 8) + 24))
  {
    gPermissions &= ~2uLL;
    gPermissionsChanged = 1;
  }
  return result;
}

uint64_t __IIODisableMetadataParsing_block_invoke(uint64_t result)
{
  uint64_t v1 = result;
  if ((gIIODebugFlags & 0x4000000000000) != 0)
  {
    uint64_t result = IIO_OSAppleInternalBuild();
    if (result) {
      uint64_t result = (uint64_t)ImageIOLog("   CGImageSourceDisableMetadataParsing - image metadata will no longer be handled in this process\n");
    }
  }
  gPermissions &= ~4uLL;
  gPermissionsChanged = 1;
  *(_DWORD *)(*(void *)(*(void *)(v1 + 32) + 8) + 24) = 0;
  return result;
}

uint64_t __IIODisableCaching_block_invoke(uint64_t result)
{
  uint64_t v1 = result;
  if ((gIIODebugFlags & 0x4000000000000) != 0)
  {
    uint64_t result = IIO_OSAppleInternalBuild();
    if (result) {
      uint64_t result = (uint64_t)ImageIOLog(" CGImageSourceDisableCaching - caching is disabled for this process\n");
    }
  }
  gPermissionsChanged = 0;
  *(_DWORD *)(*(void *)(*(void *)(v1 + 32) + 8) + 24) = 0;
  return result;
}

BOOL onlyspaces(unsigned __int8 *a1)
{
  do
  {
    int v2 = *a1++;
    int v1 = v2;
  }
  while (v2 == 32);
  return v1 == 0;
}

uint64_t stringType(unsigned __int8 *a1, int a2)
{
  char v2 = 0;
  if (!a2) {
    return v2 & 1;
  }
  while (1)
  {
    int v3 = a2--;
    while (((char)*a1 & 0x80000000) == 0)
    {
      ++a1;
      --a2;
      if (!--v3) {
        return v2 & 1;
      }
    }
    int v4 = *a1;
    if ((v4 + 2) < 0xC2u) {
      break;
    }
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v5;
      char v7 = v5++ + 2;
      --a2;
    }
    while (((v4 << v7) & 0x80) != 0);
    if (v3 < (int)v5 + 1) {
      break;
    }
    uint64_t v8 = 0;
    int v9 = v4 & ~(-1 << (6 - v5));
    uint64_t v10 = v6 + 1;
    do
    {
      unsigned int v11 = a1[++v8] & 0x3F | (v9 << 6);
      int v9 = v11;
    }
    while (v10 != v8);
    if (HIWORD(v11) > 0x10u || v11 < stringType::vmin[v5 + 1]) {
      break;
    }
    a1 += v5 + 1;
    char v2 = 1;
    if (!a2) {
      return v2 & 1;
    }
  }
  return 2;
}

void IIO_Reader_HEIF::createReadPlugin()
{
}

void sub_18875B1B8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40319A8D7BLL);
  _Unwind_Resume(a1);
}

void IIO_Reader_HEIF::createReadPlugin(uint64_t a1)
{
}

void sub_18875B284(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40319A8D7BLL);
  _Unwind_Resume(a1);
}

IIOImageRead *IIO_Reader_HEIF::createGlobalInfoData(IIO_Reader_HEIF *this, IIOImageReadSession *a2)
{
  uint64_t result = IIOImageReadSession::globalInfoForType(a2, 1212500294);
  if (result)
  {
    return (IIOImageRead *)GlobalHEIFInfo::createDataRepresentation(result);
  }
  return result;
}

void IIO_Reader_HEIF::updateGlobalInfo(IIO_Reader_HEIF *this, IIOImageReadSession *a2, unsigned __int8 *a3)
{
}

void sub_18875B368(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40D222D63DLL);
  _Unwind_Resume(a1);
}

BOOL IIO_Reader_HEIF::addBasicProperties(IIO_Reader_HEIF *this, unsigned __int8 *a2, unsigned int a3, __CFDictionary *a4, unsigned int *a5, const __CFData **a6)
{
  CFTypeRef v43 = 0;
  IIO_LoadHEIFSymbols();
  int v11 = IIOCreateCMPhotoDecompressionSession((uint64_t)&v43);
  if (v11)
  {
    int v12 = v11;
    int v13 = IIOCMErrorString(v11);
    _cg_jpeg_mem_term("addBasicProperties", 370, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v13, v12);
    return 0;
  }
  else
  {
    CFTypeRef v42 = 0;
    int v41 = 0;
    CFDataRef v15 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    if (v15)
    {
      CFDataRef v16 = v15;
      int v17 = gFunc_CMPhotoDecompressionSessionCreateContainer(v43, 0, v15, &v41, &v42);
      if (v17)
      {
        int v18 = v17;
        long long v19 = IIOCMErrorString(v17);
        _cg_jpeg_mem_term("addBasicProperties", 385, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v19, v18);
        BOOL v14 = 0;
      }
      else
      {
        CFDictionaryRef v40 = 0;
        int v20 = gFunc_CMPhotoDecompressionContainerCreateDictionaryDescription(v42, &v40);
        BOOL v14 = v20 == 0;
        if (v20)
        {
          int v21 = v20;
          unsigned int v22 = IIOCMErrorString(v20);
          _cg_jpeg_mem_term("addBasicProperties", 395, "*** CMPhotoDecompressionContainerCreateDictionaryDescription  err = %s [%d]\n", v22, v21);
        }
        else
        {
          memset(v39, 0, sizeof(v39));
          IIODictionary::IIODictionary((IIODictionary *)v39, a4);
          IIODictionary::IIODictionary((IIODictionary *)v38, v40);
          CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v38, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_MainImages);
          IIODictionary::~IIODictionary((IIODictionary *)v38);
          if (ObjectForKey && CFArrayGetCount(ObjectForKey) >= 1)
          {
            CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(ObjectForKey, 0);
            memset(v38, 0, sizeof(v38));
            IIODictionary::IIODictionary((IIODictionary *)v38, ValueAtIndex);
            CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup((IIODictionary *)v38, @"Width", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
            IIODictionary::setObjectForKey((IIODictionary *)v39, ObjectForKeyGroup, @"PixelXDimension");
            CFDictionaryRef v26 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v38, @"Height", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
            IIODictionary::setObjectForKey((IIODictionary *)v39, v26, @"PixelYDimension");
            CFDictionaryRef v27 = IIODictionary::getObjectForKey((IIODictionary *)v38, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_ThumbnailImages);
            CFDictionaryRef v28 = (const __CFDictionary *)CFArrayGetValueAtIndex(v27, 0);
            memset(v37, 0, sizeof(v37));
            IIODictionary::IIODictionary((IIODictionary *)v37, v28);
            CFDictionaryRef v29 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v37, @"Width", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
            IIODictionary::setObjectForKey((IIODictionary *)v39, v29, @"ThumbnailWidth");
            CFDictionaryRef v30 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v37, @"Height", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
            IIODictionary::setObjectForKey((IIODictionary *)v39, v30, @"ThumbnailHeight");
            int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v37, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DataLength);
            int v32 = IIODictionary::getUint32ForKey((IIODictionary *)v37, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DataOffset);
            IIONumber::IIONumber((IIONumber *)v35, Uint32ForKey);
            IIODictionary::setObjectForKey((IIODictionary *)v39, value, @"ThumbnailSize");
            IIONumber::~IIONumber((IIONumber *)v35);
            IIONumber::IIONumber((IIONumber *)v35, v32);
            IIODictionary::setObjectForKey((IIODictionary *)v39, value, @"ThumbnailOffset");
            IIONumber::~IIONumber((IIONumber *)v35);
            if (a6)
            {
              unsigned int v34 = 0;
              v35[0] = 0;
              if (!gFunc_CMPhotoDecompressionContainerCopyExifForIndexWithOptions(v42, 0, 0, 0, &v34, v35))
              {
                if (v35[0])
                {
                  *a6 = (const __CFData *)v35[0];
                  *a5 = v34;
                }
              }
            }
            IIODictionary::~IIODictionary((IIODictionary *)v37);
            IIODictionary::~IIODictionary((IIODictionary *)v38);
          }
          CFRelease(v40);
          IIODictionary::~IIODictionary((IIODictionary *)v39);
        }
        CFRelease(v42);
      }
      CFRelease(v16);
    }
    else
    {
      BOOL v14 = 0;
    }
    CFRelease(v43);
  }
  return v14;
}

void sub_18875B79C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va2, a8);
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)va2);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_HEIF::updateSourceProperties(IIO_Reader_HEIF *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  IIO_LoadHEIFSymbols();
  uint64_t v8 = IIOImageReadSession::globalInfoForType(a2, 1212500294);
  if (!v8) {
    operator new();
  }
  uint64_t v9 = (*(uint64_t (**)(IIO_Reader_HEIF *, IIOImageRead *, IIOImageReadSession *, void))(*(void *)this + 272))(this, v8, a2, 0);
  uint64_t v83 = v9;
  if (v9)
  {
    LogError("updateSourceProperties", 745, "*** ERROR: extractImageInfo failed: %d\n", v9);
  }
  else
  {
    int NumberOfAuxImages = HEIFMainImage::getNumberOfAuxImages(v8);
    float32x4_t v87 = v8;
    if (NumberOfAuxImages)
    {
      int v11 = NumberOfAuxImages;
      float32x4_t v88 = this;
      CFMutableArrayRef v111 = 0;
      int v112 = 0;
      uint64_t v113 = 0;
      IIOArray::IIOArray((IIOArray *)&v111);
      unsigned int v12 = 0;
      uint64_t v13 = @"Alternate";
      do
      {
        HEIFAuxImageAtIndedouble x = (HEIFGroupItem *)HEIFMainImage::getHEIFAuxImageAtIndex(v8, v12);
        if (HEIFAuxImageAtIndex)
        {
          CFMutableArrayRef v108 = 0;
          unint64_t v109 = 0;
          uint64_t v110 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v108);
          GroupPictureIndexListCFIndex Count = HEIFGroupItem::getGroupPictureIndexListCount(HEIFAuxImageAtIndex);
          Groupint Type = HEIFGroupItem::getGroupType(HEIFAuxImageAtIndex);
          if (GroupType == 1634497650)
          {
            IIODictionary::setObjectForKey((IIODictionary *)&v108, v13, @"GroupType");
            CFMutableArrayRef v105 = 0;
            unsigned int v106 = 0;
            double v107 = 0;
            IIOArray::IIOArray((IIOArray *)&v105);
            if (GroupPictureIndexListCount)
            {
              for (unsigned int i = 0; i != GroupPictureIndexListCount; ++i)
              {
                GroupPictureIndexAtIndedouble x = HEIFGroupItem::getGroupPictureIndexAtIndex(HEIFAuxImageAtIndex, i);
                IIONumber::IIONumber((IIONumber *)&v102, GroupPictureIndexAtIndex);
                IIOArray::addObject(&v105, v104);
                IIONumber::~IIONumber((IIONumber *)&v102);
              }
            }
            IIODictionary::setObjectForKey((IIODictionary *)&v108, v106, @"GroupImages");
            IIOArray::~IIOArray((IIOArray *)&v105);
          }
          else if (GroupType == 1937007986 && (GroupPictureIndexListCount & 0xFFFFFFFE) == 2)
          {
            IIODictionary::setObjectForKey((IIODictionary *)&v108, @"StereoPair", @"GroupType");
            int v17 = HEIFGroupItem::getGroupPictureIndexAtIndex(HEIFAuxImageAtIndex, 0);
            IIONumber::IIONumber((IIONumber *)&v105, v17);
            IIODictionary::setObjectForKey((IIODictionary *)&v108, v107, @"GroupImageIndexLeft");
            IIONumber::~IIONumber((IIONumber *)&v105);
            int v18 = HEIFGroupItem::getGroupPictureIndexAtIndex(HEIFAuxImageAtIndex, 1u);
            IIONumber::IIONumber((IIONumber *)&v105, v18);
            IIODictionary::setObjectForKey((IIODictionary *)&v108, v107, @"GroupImageIndexRight");
            IIONumber::~IIONumber((IIONumber *)&v105);
            if (GroupPictureIndexListCount == 3)
            {
              int v19 = HEIFGroupItem::getGroupPictureIndexAtIndex(HEIFAuxImageAtIndex, 2u);
              IIONumber::IIONumber((IIONumber *)&v105, v19);
              IIODictionary::setObjectForKey((IIODictionary *)&v108, v107, @"GroupImageIndexMonoscopic");
              IIONumber::~IIONumber((IIONumber *)&v105);
              MonoscopicImageLocationString = HEIFGroupItem::getMonoscopicImageLocationString(HEIFAuxImageAtIndex);
              if (MonoscopicImageLocationString) {
                IIODictionary::setObjectForKey((IIODictionary *)&v108, MonoscopicImageLocationString, @"GroupImageIndexMonoscopicImageLocation");
              }
            }
            if (HEIFGroupItem::hasDisparityAdjustment(HEIFAuxImageAtIndex))
            {
              int DisparityAdjustment = HEIFGroupItem::getDisparityAdjustment(HEIFAuxImageAtIndex);
              IIONumber::IIONumber((IIONumber *)&v105, DisparityAdjustment);
              IIODictionary::setObjectForKey((IIODictionary *)&v108, v107, @"GroupImageDisparityAdjustment");
              IIONumber::~IIONumber((IIONumber *)&v105);
            }
            StereoAggressorCFIndex Count = HEIFGroupItem::getStereoAggressorCount(HEIFAuxImageAtIndex);
            if (StereoAggressorCount)
            {
              unsigned int v23 = v13;
              CFMutableArrayRef v105 = 0;
              unsigned int v106 = 0;
              double v107 = 0;
              IIOArray::IIOArray((IIOArray *)&v105);
              for (unsigned int j = 0; j != StereoAggressorCount; ++j)
              {
                StereoAggressorAtIndedouble x = (IIOImageSource *)HEIFGroupItem::getStereoAggressorAtIndex(HEIFAuxImageAtIndex, j);
                CFMutableArrayRef v102 = 0;
                uint64_t v103 = 0;
                uint64_t v104 = 0;
                IIODictionary::IIODictionary((IIODictionary *)&v102);
                CFDictionaryRef v26 = (const void *)IIOImageSource::cf(StereoAggressorAtIndex);
                IIODictionary::setObjectForKey((IIODictionary *)&v102, v26, @"Type");
                if (IIOImageSource::imageReadRef(StereoAggressorAtIndex))
                {
                  uint64_t Ref = (const void *)IIOImageSource::imageReadRef(StereoAggressorAtIndex);
                  IIODictionary::setObjectForKey((IIODictionary *)&v102, Ref, @"SubTypeURI");
                }
                if (HEIFStereoAggressor::hasSeverity(StereoAggressorAtIndex))
                {
                  Severitdouble y = HEIFStereoAggressor::getSeverity(StereoAggressorAtIndex);
                  IIONumber::IIONumber((IIONumber *)&v99, Severity);
                  IIODictionary::setObjectForKey((IIODictionary *)&v102, v101, @"Severity");
                  IIONumber::~IIONumber((IIONumber *)&v99);
                }
                IIOArray::addObject(&v105, v103);
                IIODictionary::~IIODictionary((IIODictionary *)&v102);
              }
              IIODictionary::setObjectForKey((IIODictionary *)&v108, v106, @"GroupImageStereoAggressors");
              uint64_t v13 = v23;
              IIOArray::~IIOArray((IIOArray *)&v105);
            }
          }
          int IsAnonymous = TIFFFieldIsAnonymous((uint64_t)HEIFAuxImageAtIndex);
          IIONumber::IIONumber((IIONumber *)&v105, IsAnonymous);
          IIODictionary::setObjectForKey((IIODictionary *)&v108, v107, @"GroupIndex");
          IIONumber::~IIONumber((IIONumber *)&v105);
          IIOArray::addObject(&v111, v109);
          IIODictionary::~IIODictionary((IIODictionary *)&v108);
        }
        ++v12;
      }
      while (v12 != v11);
      IIODictionary::setObjectForKey(a3, v112, @"{Groups}");
      IIOArray::~IIOArray((IIOArray *)&v111);
      this = v88;
    }
    if (GlobalHEIFInfo::hasHEIFSequence(v8) && IIOImageRead::trustedURL(v8))
    {
      int NumberOfMainImages = GlobalHEIFInfo::getNumberOfMainImages(v8);
      if (NumberOfMainImages)
      {
        int v33 = NumberOfMainImages;
        CFMutableArrayRef v111 = 0;
        int v112 = 0;
        uint64_t v113 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v111);
        IIODictionary::setObjectForKey(v34, (const void *)*MEMORY[0x1E4F1CFD0], @"CanAnimate");
        HEIFMainImageAtIndedouble x = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v8, 0);
        int v36 = HEIFMainImage::width(HEIFMainImageAtIndex);
        int v37 = HEIFMainImage::height(HEIFMainImageAtIndex);
        ColorSpaceCFStringRef Name = (const void *)HEIFMainImage::getColorSpaceName(HEIFMainImageAtIndex);
        if (v36)
        {
          IIONumber::IIONumber((IIONumber *)&v108, v36);
          IIODictionary::setObjectForKey((IIODictionary *)&v111, v110, @"CanvasPixelWidth");
          IIONumber::~IIONumber((IIONumber *)&v108);
        }
        if (v37)
        {
          IIONumber::IIONumber((IIONumber *)&v108, v37);
          IIODictionary::setObjectForKey((IIODictionary *)&v111, v110, @"CanvasPixelHeight");
          IIONumber::~IIONumber((IIONumber *)&v108);
        }
        if (ColorSpaceName) {
          IIODictionary::setObjectForKey((IIODictionary *)&v111, ColorSpaceName, @"NamedColorSpace");
        }
        CFMutableArrayRef v108 = 0;
        unint64_t v109 = 0;
        uint64_t v110 = 0;
        IIOArray::IIOArray((IIOArray *)&v108);
        for (unsigned int k = 0; k != v33; ++k)
        {
          CFDictionaryRef v40 = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v8, k);
          double FrameDuration = HEIFMainImage::getFrameDuration(v40);
          CFMutableArrayRef v105 = 0;
          unsigned int v106 = 0;
          double v107 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v105);
          IIONumber::IIONumber((IIONumber *)v98, FrameDuration);
          IIODictionary::setObjectForKey((uint64_t)&v105, (uint64_t)v98, @"DelayTime");
          IIONumber::~IIONumber((IIONumber *)v98);
          IIOArray::addObject(&v108, v106);
          IIODictionary::~IIODictionary((IIODictionary *)&v105);
        }
        IIODictionary::setObjectForKey((IIODictionary *)&v111, v109, @"FrameInfo");
        CFTypeRef v42 = &kCGImagePropertyAVISDictionary;
        if (*((_DWORD *)this + 6) != 1096173907) {
          CFTypeRef v42 = &kCGImagePropertyHEICSDictionary;
        }
        CFStringRef v43 = *v42;
        IIODictionary::setObjectForKey(a3, v112, *v42);
        IIONumber::IIONumber((IIONumber *)v97, 0);
        IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v97, @"LoopCount", v43);
        IIONumber::~IIONumber((IIONumber *)v97);
        IIOArray::~IIOArray((IIOArray *)&v108);
        IIODictionary::~IIODictionary((IIODictionary *)&v111);
      }
    }
    else
    {
      CFMutableArrayRef v111 = 0;
      int v112 = 0;
      uint64_t v113 = 0;
      IIOArray::IIOArray((IIOArray *)&v111);
      int v44 = GlobalHEIFInfo::getNumberOfMainImages(v8);
      IIONumber::IIONumber((IIONumber *)&v108, v44);
      IIODictionary::setObjectForKeyGroup(a3, v110, @"ImageCount", @"{FileContents}");
      IIONumber::~IIONumber((IIONumber *)&v108);
      if (GlobalHEIFInfo::hasHEIFSequence(v8))
      {
        char v85 = (void *)*MEMORY[0x1E4F1CFD0];
        IIODictionary::setObjectForKey(a3, (const void *)*MEMORY[0x1E4F1CFD0], @"CanAnimate");
      }
      else
      {
        IIODictionary::setObjectForKey(a3, (const void *)*MEMORY[0x1E4F1CFC8], @"CanAnimate");
        char v85 = (void *)*MEMORY[0x1E4F1CFD0];
      }
      char v45 = 0;
      for (unsigned int m = 0; m < GlobalHEIFInfo::getNumberOfMainImages(v8); ++m)
      {
        int v46 = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v8, m);
        CFMutableArrayRef v108 = 0;
        unint64_t v109 = 0;
        uint64_t v110 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v108);
        int v47 = HEIFMainImage::width(v46);
        int v48 = HEIFMainImage::height(v46);
        int v49 = *((_DWORD *)v46 + 38);
        char v50 = (const void *)HEIFMainImage::getColorSpaceName(v46);
        BOOL v51 = a5
           && IIODictionary::containsKey(a5, @"kCGImageSourceAddHEIFContainerItemID")
           && IIODictionary::getBoolForKey(a5, @"kCGImageSourceAddHEIFContainerItemID");
        IIONumber::IIONumber((IIONumber *)&v105, m);
        IIODictionary::setObjectForKey((IIODictionary *)&v108, v107, @"ImageIndex");
        IIONumber::~IIONumber((IIONumber *)&v105);
        if (v47)
        {
          IIONumber::IIONumber(v52, v47);
          IIODictionary::setObjectForKey((IIODictionary *)&v108, v107, @"Width");
          IIONumber::~IIONumber((IIONumber *)&v105);
        }
        if (v48)
        {
          IIONumber::IIONumber(v52, v48);
          IIODictionary::setObjectForKey((IIODictionary *)&v108, v107, @"Height");
          IIONumber::~IIONumber((IIONumber *)&v105);
        }
        if (v49)
        {
          IIONumber::IIONumber(v52, v49);
          IIODictionary::setObjectForKey((IIODictionary *)&v108, v107, @"Orientation");
          IIONumber::~IIONumber((IIONumber *)&v105);
        }
        if (v50) {
          IIODictionary::setObjectForKey((IIODictionary *)&v108, v50, @"NamedColorSpace");
        }
        if (v51)
        {
          int FrameCount = GlobalGIFInfo::lastFrameCount(v46);
          IIONumber::IIONumber((IIONumber *)v96, FrameCount);
          IIODictionary::setObjectForKey((uint64_t)&v108, (uint64_t)v96, @"ContainerItemID");
          IIONumber::~IIONumber((IIONumber *)v96);
        }
        CFMutableArrayRef v105 = 0;
        unsigned int v106 = 0;
        double v107 = 0;
        IIOArray::IIOArray((IIOArray *)&v105);
        for (unsigned int n = 0; n < HEIFMainImage::getNumberOfThumbnailImages(v46); ++n)
        {
          CFMutableArrayRef v102 = 0;
          uint64_t v103 = 0;
          uint64_t v104 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v102);
          HEIFThumbnailImageAtIndedouble x = (HEIFGroupItem *)HEIFMainImage::getHEIFThumbnailImageAtIndex(v46, n);
          int v56 = HEIFGroupItem::getGroupType(HEIFThumbnailImageAtIndex);
          int v57 = TIFFFieldIsAnonymous((uint64_t)HEIFThumbnailImageAtIndex);
          int v58 = IIO_Reader::osType(HEIFThumbnailImageAtIndex);
          int v59 = HEIFThumbnailImage::dataLength(HEIFThumbnailImageAtIndex);
          if (v56)
          {
            IIONumber::IIONumber((IIONumber *)&v99, v56);
            IIODictionary::setObjectForKey((IIODictionary *)&v102, v101, @"Width");
            IIONumber::~IIONumber((IIONumber *)&v99);
          }
          if (v57)
          {
            IIONumber::IIONumber((IIONumber *)&v99, v57);
            IIODictionary::setObjectForKey((IIODictionary *)&v102, v101, @"Height");
            IIONumber::~IIONumber((IIONumber *)&v99);
          }
          if (v58)
          {
            IIONumber::IIONumber((IIONumber *)&v99, v58);
            IIODictionary::setObjectForKey((IIODictionary *)&v102, v101, @"ThumbnailOffset");
            IIONumber::~IIONumber((IIONumber *)&v99);
            IIONumber::IIONumber(v60, v59);
            IIODictionary::setObjectForKey((IIODictionary *)&v102, v101, @"ThumbnailSize");
            IIONumber::~IIONumber((IIONumber *)&v99);
          }
          if (v49)
          {
            IIONumber::IIONumber((IIONumber *)&v99, v49);
            IIODictionary::setObjectForKey((IIODictionary *)&v102, v101, @"Orientation");
            IIONumber::~IIONumber((IIONumber *)&v99);
          }
          IIOArray::addObject(&v105, v103);
          IIODictionary::~IIODictionary((IIODictionary *)&v102);
        }
        IIODictionary::setObjectForKey((IIODictionary *)&v108, v106, @"ThumbnailImages");
        CFMutableArrayRef v102 = 0;
        uint64_t v103 = 0;
        uint64_t v104 = 0;
        IIOArray::IIOArray((IIOArray *)&v102);
        for (iunsigned int i = 0; ii < HEIFMainImage::getNumberOfAuxImages(v46); ++ii)
        {
          CFMutableArrayRef v99 = 0;
          int32x4_t v100 = 0;
          unsigned long long v101 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v99);
          unint64_t v62 = (HEIFAuxImage *)HEIFMainImage::getHEIFAuxImageAtIndex(v46, ii);
          unsigned int v63 = HEIFAuxImage::auxiliaryType(v62);
          unsigned int v64 = v63;
          if (v63 < 6 || v63 == 99)
          {
            int v65 = HEIFGroupItem::getGroupType(v62);
            int v66 = TIFFFieldIsAnonymous((uint64_t)v62);
            int v67 = HEIFGroupItem::getDisparityAdjustment(v62);
            int v68 = HEIFAuxImage::auxiliaryPixelFormat(v62);
            if (v65)
            {
              IIONumber::IIONumber((IIONumber *)&v93, v65);
              IIODictionary::setObjectForKey((IIODictionary *)&v99, v95, @"Width");
              IIONumber::~IIONumber((IIONumber *)&v93);
            }
            if (v66)
            {
              IIONumber::IIONumber((IIONumber *)&v93, v66);
              IIODictionary::setObjectForKey((IIODictionary *)&v99, v95, @"Height");
              IIONumber::~IIONumber((IIONumber *)&v93);
            }
            if (v67)
            {
              IIONumber::IIONumber((IIONumber *)&v93, v67);
              IIODictionary::setObjectForKey((IIODictionary *)&v99, v95, @"Orientation");
              IIONumber::~IIONumber((IIONumber *)&v93);
            }
            if (v68)
            {
              IIONumber::IIONumber((IIONumber *)&v93, v68);
              IIODictionary::setObjectForKey((IIODictionary *)&v99, v95, @"PixelFormat");
              IIONumber::~IIONumber((IIONumber *)&v93);
            }
            int8x16_t v69 = @"kCGImageAuxiliaryDataTypeDisparity";
            switch(v64)
            {
              case 1u:
                goto LABEL_102;
              case 2u:
                int8x16_t v69 = @"kCGImageAuxiliaryDataTypeDepth";
                goto LABEL_102;
              case 3u:
                goto LABEL_104;
              case 4u:
                goto LABEL_90;
              case 5u:
                int8x16_t v69 = @"kCGImageAuxiliaryDataTypePortraitEffectsMatte";
                goto LABEL_102;
              default:
                if (v64 == 99)
                {
LABEL_90:
                  uint64_t Size = IIOImageWriteSession::getSize(v62);
                  if (Size) {
                    CFStringRef v71 = (const __CFString *)Size;
                  }
                  else {
                    CFStringRef v71 = @"unknown URN";
                  }
                  CFComparisonResult v72 = CFStringCompare(v71, *(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte, 0);
                  int8x16_t v69 = @"kCGImageAuxiliaryDataTypeSemanticSegmentationSkinMatte";
                  if (v72 == kCFCompareEqualTo) {
                    goto LABEL_102;
                  }
                  CFComparisonResult v73 = CFStringCompare(v71, *(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte, 0);
                  int8x16_t v69 = @"kCGImageAuxiliaryDataTypeSemanticSegmentationHairMatte";
                  if (v73 == kCFCompareEqualTo) {
                    goto LABEL_102;
                  }
                  CFComparisonResult v74 = CFStringCompare(v71, *(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte, 0);
                  int8x16_t v69 = @"kCGImageAuxiliaryDataTypeSemanticSegmentationTeethMatte";
                  if (v74
                    && (v75 = CFStringCompare(v71, *(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte, 0), int8x16_t v69 = @"kCGImageAuxiliaryDataTypeSemanticSegmentationGlassesMatte", v75)&& (v76 = CFStringCompare(v71, *(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte, 0), int8x16_t v69 = @"kCGImageAuxiliaryDataTypeSemanticSegmentationSkyMatte", v76))
                  {
                    if (CFStringCompare(v71, *(CFStringRef *)gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap, 0))
                    {
                      IIODictionary::setObjectForKey((IIODictionary *)&v99, v71, @"AuxiliaryDataType");
                    }
                    else
                    {
                      IIODictionary::setObjectForKey((IIODictionary *)&v99, @"kCGImageAuxiliaryDataTypeHDRGainMap", @"AuxiliaryDataType");
                      float v77 = HEIFAuxImage::meteorHeadroomFromMakerNote(v62);
                      if (v77 != 0.0 || (float v77 = HEIFAuxImage::meteorHeadroomFromProperties(v62), v77 != 0.0))
                      {
                        IIONumber::IIONumber((IIONumber *)&v93, v77);
                        IIODictionary::setObjectForKey((IIODictionary *)&v99, v95, @"HDRHeadroom");
                        IIONumber::~IIONumber((IIONumber *)&v93);
                      }
                    }
                  }
                  else
                  {
LABEL_102:
                    IIODictionary::setObjectForKey((IIODictionary *)&v99, v69, @"AuxiliaryDataType");
                  }
                }
                else
                {
                  _cg_jpeg_mem_term("updateSourceProperties", 1052, "*** ERROR: auxType %d is not handled", v64);
                }
LABEL_104:
                IIOArray::addObject(&v102, v100);
                break;
            }
          }
          IIODictionary::~IIODictionary((IIODictionary *)&v99);
        }
        uint64_t v8 = v87;
        if (IIOArray::getCount((IIOArray *)&v102))
        {
          IIODictionary::setObjectForKey((IIODictionary *)&v108, v103, @"AuxiliaryData");
          char v45 = 1;
        }
        CFMutableArrayRef v99 = 0;
        int32x4_t v100 = 0;
        unsigned long long v101 = 0;
        IIOArray::IIOArray((IIOArray *)&v99);
        int v78 = HEIFGroupItem::getStereoAggressorCount(v46);
        if (v78)
        {
          IIODictionary::setObjectForKey((IIODictionary *)&v108, v85, @"FlexRange");
          for (junsigned int j = 0; jj != v78; ++jj)
          {
            uint64_t v93 = 0;
            float32x4_t v94 = 0;
            uint64_t v95 = 0;
            IIODictionary::IIODictionary((IIODictionary *)&v93);
            uint64_t v90 = 0;
            uint64_t v91 = 0;
            uint64_t v92 = 0;
            IIODictionary::IIODictionary((IIODictionary *)&v90);
            HEIFAlternateImageAtIndedouble x = (HEIFAlternateImage *)HEIFMainImage::getHEIFAlternateImageAtIndex(v46, jj);
            HEIFAlternateImage::addInfoToProperties(HEIFAlternateImageAtIndex, (IIODictionary *)&v93);
            IIOArray::addObject(&v99, v94);
            HEIFAlternateImage::addAsAuxImageToProperties(HEIFAlternateImageAtIndex, (IIODictionary *)&v90);
            if ((v45 & 1) == 0) {
              IIODictionary::setObjectForKey((IIODictionary *)&v108, v103, @"AuxiliaryData");
            }
            IIOArray::addObject(&v102, v91);
            IIODictionary::~IIODictionary((IIODictionary *)&v90);
            IIODictionary::~IIODictionary((IIODictionary *)&v93);
            char v45 = 1;
          }
        }
        if (IIOArray::getCount((IIOArray *)&v99)) {
          IIODictionary::setObjectForKey((IIODictionary *)&v108, v100, @"DerivationDetails");
        }
        IIOArray::addObject(&v111, v109);
        IIOArray::~IIOArray((IIOArray *)&v99);
        IIOArray::~IIOArray((IIOArray *)&v102);
        IIOArray::~IIOArray((IIOArray *)&v105);
        IIODictionary::~IIODictionary((IIODictionary *)&v108);
      }
      IIODictionary::setObjectForKeyGroup(a3, v112, @"Images", @"{FileContents}");
      if (GlobalHEIFInfo::getNumberOfMainImages(v8) >= 2)
      {
        PrimaryImageIndedouble x = GlobalHEIFInfo::getPrimaryImageIndex(v8);
        IIONumber::IIONumber((IIONumber *)&v108, PrimaryImageIndex);
        IIODictionary::setObjectForKey(a3, v110, @"PrimaryImage");
        IIONumber::~IIONumber((IIONumber *)&v108);
      }
      IIOArray::~IIOArray((IIOArray *)&v111);
    }
  }
  return v83;
}

void sub_18875C9B8(_Unwind_Exception *a1)
{
  IIONumber::~IIONumber((IIONumber *)(v1 - 152));
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 128));
  _Unwind_Resume(a1);
}

HEIFMainImage *IIO_Reader_HEIF::initThumbnail(CFStringRef **a1, uint64_t a2, unsigned int a3, unint64_t a4)
{
  IIO_LoadHEIFSymbols();
  Sessiounsigned int n = CGImagePluginGetSession(a2);
  uint64_t Source = (IIOImageReadSession *)CGImageSourceGetSource(Session);
  uint64_t v10 = IIOImageReadSession::globalInfoForType(Source, 1212500294);
  if (!v10) {
    operator new();
  }
  uint64_t v11 = ((uint64_t (*)(CFStringRef **, IIOImageRead *, IIOImageReadSession *, void))(*a1)[34])(a1, v10, Source, 0);
  if (v11)
  {
    uint64_t v13 = (HEIFMainImage *)v11;
    LogError("initThumbnail", 1178, "*** ERROR: extractImageInfo failed: %d\n", v11);
  }
  else
  {
    HEIFMainImageAtIndedouble x = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v10, a3);
    uint64_t v13 = HEIFMainImageAtIndex;
    if (HEIFMainImageAtIndex)
    {
      if (HEIFMainImage::width(HEIFMainImageAtIndex) < a4
        && HEIFMainImage::height(v13) < a4)
      {
        int v14 = HEIFMainImage::width(v13);
        int v15 = HEIFMainImage::height(v13);
        LogError("initThumbnail", 1185, "*** ERROR: kCGImageSourceThumbnailMaxPixelSize: %d is larger than image-dimension: %dx%d\n", a4, v14, v15);
        unsigned int v16 = HEIFMainImage::width(v13);
        if (v16 <= HEIFMainImage::height(v13)) {
          HEIFMainImage::height(v13);
        }
        else {
          HEIFMainImage::width(v13);
        }
      }
      HEIFThumbnailImageAtIndedouble x = (HEIFThumbnailImage *)HEIFMainImage::getHEIFThumbnailImageAtIndex(v13, 0);
      if (HEIFThumbnailImageAtIndex)
      {
        int v18 = HEIFThumbnailImageAtIndex;
        uint64_t v13 = (HEIFMainImage *)HEIFThumbnailImage::dataLength(HEIFThumbnailImageAtIndex);
        IIO_Reader::osType(v18);
        Groupint Type = HEIFGroupItem::getGroupType(v18);
        if (GroupType <= TIFFFieldIsAnonymous((uint64_t)v18)) {
          TIFFFieldIsAnonymous((uint64_t)v18);
        }
        else {
          HEIFGroupItem::getGroupType(v18);
        }
        if (v13)
        {
          CFStringCompare(*a1[1], @"public.jpeg", 0);
          operator new();
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return v13;
}

void sub_18875CF90(void *a1)
{
}

BOOL IIO_Reader_HEIF::canScaleThumbnailToFinalSize(IIO_Reader_HEIF *this)
{
  return IIO_Reader::osType(this) != 1212500307;
}

void IIO_Reader_HEIF::CreateGlobalHEIFInfoIfNeeded(IIO_Reader_HEIF *this, IIOImageReadSession *a2, int a3)
{
  int v4 = (int)a2;
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(this);
  char v7 = IIO_ReaderHandler::readerForUTType(ReaderHandler, @"public.heic");
  if (v7)
  {
    uint64_t v8 = v7;
    int v13 = 0;
    memset(v12, 0, sizeof(v12));
    IIODictionary::IIODictionary((IIODictionary *)v12);
    IIONumber::IIONumber((IIONumber *)v10, v4);
    IIODictionary::setObjectForKey((IIODictionary *)v12, value, @"JPEGOffset");
    IIONumber::~IIONumber((IIONumber *)v10);
    IIONumber::IIONumber((IIONumber *)v10, a3);
    IIODictionary::setObjectForKey((IIODictionary *)v12, value, @"JPEGLength");
    IIONumber::~IIONumber((IIONumber *)v10);
    int v9 = (*(uint64_t (**)(IIO_Reader *, IIO_Reader_HEIF *, void *, void, int *))(*(void *)v8 + 32))(v8, this, v12, 0, &v13);
    if (v9) {
      _cg_jpeg_mem_term("CreateGlobalHEIFInfoIfNeeded", 1352, "*** ERROR: CreateGlobalHEIFInfoIfNeeded: err: %d\n", v9);
    }
    IIODictionary::~IIODictionary((IIODictionary *)v12);
  }
}

void sub_18875D13C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_HEIF::hasCustomSourcePropertiesProc(IIO_Reader_HEIF *this)
{
  return 1;
}

uint64_t IIO_Reader_HEIF::hasCustomThumbnailProc(IIO_Reader_HEIF *this)
{
  return 1;
}

uint64_t IIO_Reader_HEIF::canCreateCustomThumbnailSizes(IIO_Reader_HEIF *this)
{
  return 1;
}

uint64_t IIO_Reader_HEIF::canApplyTransform(IIO_Reader_HEIF *this)
{
  return 1;
}

void IIO_Reader_PDF::createReadPlugin()
{
}

{
  operator new();
}

void sub_18875D1F4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40F65F68CCLL);
  _Unwind_Resume(a1);
}

void sub_18875D294(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40F65F68CCLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PDF::updateSourceProperties(IIO_Reader_PDF *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  *a6 = kCGImageStatusIncomplete;
  if (!IIOImageReadSession::isFinal(a2)) {
    return 4294967246;
  }
  uint64_t v51 = 0;
  memset(v50, 0, sizeof(v50));
  IIOScanner::IIOScanner((IIOScanner *)v50, a2);
  BOOL v49 = 0;
  uint64_t v8 = CreateSessionPDFRef((off_t *)v50, &v49);
  int v9 = v8;
  if (v8)
  {
    BOOL IsEncrypted = CGPDFDocumentIsEncrypted(v8);
    uint64_t v11 = (const void *)*MEMORY[0x1E4F1CFD0];
    unsigned int v12 = (const void *)*MEMORY[0x1E4F1CFC8];
    if (IsEncrypted) {
      int v13 = (const void *)*MEMORY[0x1E4F1CFD0];
    }
    else {
      int v13 = (const void *)*MEMORY[0x1E4F1CFC8];
    }
    IIODictionary::setObjectForKeyGroup(a3, v13, @"IsEncrypted", @"{PDF}");
    if (CGPDFDocumentIsUnlocked(v9)) {
      int v14 = v11;
    }
    else {
      int v14 = v12;
    }
    IIODictionary::setObjectForKeyGroup(a3, v14, @"IsUnlocked", @"{PDF}");
    char AccessPermissions = CGPDFDocumentGetAccessPermissions(v9);
    if (AccessPermissions) {
      unsigned int v16 = v11;
    }
    else {
      unsigned int v16 = v12;
    }
    IIODictionary::setObjectForKeyGroup(a3, v16, @"AllowsLowQualityPrinting", @"{PDF}");
    if ((AccessPermissions & 2) != 0) {
      int v17 = v11;
    }
    else {
      int v17 = v12;
    }
    IIODictionary::setObjectForKeyGroup(a3, v17, @"AllowsHighQualityPrinting", @"{PDF}");
    if ((AccessPermissions & 4) != 0) {
      int v18 = v11;
    }
    else {
      int v18 = v12;
    }
    IIODictionary::setObjectForKeyGroup(a3, v18, @"AllowsDocumentChanges", @"{PDF}");
    if ((AccessPermissions & 8) != 0) {
      int v19 = v11;
    }
    else {
      int v19 = v12;
    }
    IIODictionary::setObjectForKeyGroup(a3, v19, @"AllowsDocumentAssembly", @"{PDF}");
    if ((AccessPermissions & 0x10) != 0) {
      int v20 = v11;
    }
    else {
      int v20 = v12;
    }
    IIODictionary::setObjectForKeyGroup(a3, v20, @"AllowsContentCopying", @"{PDF}");
    if ((AccessPermissions & 0x20) != 0) {
      int v21 = v11;
    }
    else {
      int v21 = v12;
    }
    IIODictionary::setObjectForKeyGroup(a3, v21, @"AllowsContentAccessibility", @"{PDF}");
    if ((AccessPermissions & 0x40) != 0) {
      unsigned int v22 = v11;
    }
    else {
      unsigned int v22 = v12;
    }
    IIODictionary::setObjectForKeyGroup(a3, v22, @"AllowsCommenting", @"{PDF}");
    if (AccessPermissions < 0) {
      unsigned int v23 = v11;
    }
    else {
      unsigned int v23 = v12;
    }
    IIODictionary::setObjectForKeyGroup(a3, v23, @"AllowsFormFieldEntry", @"{PDF}");
    CFDictionaryRef v24 = (const __CFDictionary *)CGPDFDocumentCopyInfoDictionary();
    if (v24)
    {
      CFLocaleRef v25 = CFLocaleCopyCurrent();
      CFAllocatorRef v26 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFDictionaryRef v27 = CFDateFormatterCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v25, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
      CFDateFormatterSetFormat(v27, @"yyyy:MM:dd HH:mm:ss");
      memset(v48, 0, sizeof(v48));
      IIODictionary::IIODictionary((IIODictionary *)v48, v24);
      CFStringRef v28 = (const __CFString *)*MEMORY[0x1E4F1DE40];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E4F1DE40]))
      {
        CFDateRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v48, v28);
        CFStringRef StringWithDate = CFDateFormatterCreateStringWithDate(v26, v27, ObjectForKey);
        IIODictionary::setObjectForKeyGroup(a3, StringWithDate, @"ModificationDate", @"{PDF}");
        CFRelease(StringWithDate);
      }
      CFStringRef v31 = (const __CFString *)*MEMORY[0x1E4F1DE28];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E4F1DE28]))
      {
        CFDateRef v32 = IIODictionary::getObjectForKey((IIODictionary *)v48, v31);
        CFStringRef v33 = CFDateFormatterCreateStringWithDate(v26, v27, v32);
        IIODictionary::setObjectForKeyGroup(a3, v33, @"CreationDate", @"{PDF}");
        CFRelease(v33);
      }
      CFRelease(v25);
      CFRelease(v27);
      CFStringRef v34 = (const __CFString *)*MEMORY[0x1E4F1DE48];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E4F1DE48]))
      {
        CFDictionaryRef v35 = IIODictionary::getObjectForKey((IIODictionary *)v48, v34);
        IIODictionary::setObjectForKeyGroup(a3, v35, @"Producer", @"{PDF}");
      }
      CFStringRef v36 = (const __CFString *)*MEMORY[0x1E4F1DE30];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E4F1DE30]))
      {
        CFDictionaryRef v37 = IIODictionary::getObjectForKey((IIODictionary *)v48, v36);
        IIODictionary::setObjectForKeyGroup(a3, v37, @"Creator", @"{PDF}");
      }
      CFStringRef v38 = (const __CFString *)*MEMORY[0x1E4F1DE38];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E4F1DE38]))
      {
        CFDictionaryRef v39 = IIODictionary::getObjectForKey((IIODictionary *)v48, v38);
        IIODictionary::setObjectForKeyGroup(a3, v39, @"Keywords", @"{PDF}");
      }
      CFStringRef v40 = (const __CFString *)*MEMORY[0x1E4F1DE50];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E4F1DE50]))
      {
        CFDictionaryRef v41 = IIODictionary::getObjectForKey((IIODictionary *)v48, v40);
        IIODictionary::setObjectForKeyGroup(a3, v41, @"Subject", @"{PDF}");
      }
      CFStringRef v42 = (const __CFString *)*MEMORY[0x1E4F1DE20];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E4F1DE20]))
      {
        CFDictionaryRef v43 = IIODictionary::getObjectForKey((IIODictionary *)v48, v42);
        IIODictionary::setObjectForKeyGroup(a3, v43, @"Author", @"{PDF}");
      }
      CFStringRef v44 = (const __CFString *)*MEMORY[0x1E4F1DE58];
      if (IIODictionary::containsKey((IIODictionary *)v48, (const __CFString *)*MEMORY[0x1E4F1DE58]))
      {
        CFDictionaryRef v45 = IIODictionary::getObjectForKey((IIODictionary *)v48, v44);
        IIODictionary::setObjectForKeyGroup(a3, v45, @"Title", @"{PDF}");
      }
      CFRelease(v24);
      IIODictionary::~IIODictionary((IIODictionary *)v48);
    }
    CGPDFDocumentRelease(v9);
    uint64_t v46 = 0;
  }
  else
  {
    if (v49) {
      IIODictionary::setObjectForKeyGroup(a3, (const void *)*MEMORY[0x1E4F1CFD0], @"IsLocked", @"{PDF}");
    }
    uint64_t v46 = 4294967246;
  }
  IIOScanner::~IIOScanner((IIOScanner *)v50);
  return v46;
}

void sub_18875D7A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t IIO_Reader_PDF::getImageCount(IIO_Reader_PDF *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  *a4 = kCGImageStatusIncomplete;
  if (!IIOImageReadSession::isFinal(a2)) {
    return 4294967246;
  }
  uint64_t v13 = 0;
  memset(v12, 0, sizeof(v12));
  IIOScanner::IIOScanner((IIOScanner *)v12, a2);
  SessionPDFuint64_t Ref = CreateSessionPDFRef((off_t *)v12, 0);
  int v9 = SessionPDFRef;
  if (SessionPDFRef)
  {
    if (a5) {
      *a5 = CGPDFDocumentGetNumberOfPages(SessionPDFRef);
    }
    CGPDFDocumentRelease(v9);
    uint64_t v10 = 0;
    *a4 = kCGImageStatusComplete;
  }
  else
  {
    uint64_t v10 = 4294967246;
  }
  IIOScanner::~IIOScanner((IIOScanner *)v12);
  return v10;
}

void sub_18875D8B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL IIO_Reader_PDF::compareOptions(IIO_Reader_PDF *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  memset(v11, 0, sizeof(v11));
  IIODictionary::IIODictionary((IIODictionary *)v11, a2);
  memset(v10, 0, sizeof(v10));
  IIODictionary::IIODictionary((IIODictionary *)v10, a3);
  float v4 = 0.0;
  if (IIODictionary::containsKey((IIODictionary *)v11, @"kCGImageSourceRasterizationDPI"))
  {
    double FloatForKey = IIODictionary::getFloatForKey((IIODictionary *)v11, @"kCGImageSourceRasterizationDPI");
    float v4 = *(float *)&FloatForKey;
  }
  unsigned int v6 = IIODictionary::containsKey((IIODictionary *)v10, @"kCGImageSourceRasterizationDPI");
  LODWORD(v7) = 0;
  if (v6) {
    double v7 = IIODictionary::getFloatForKey((IIODictionary *)v10, @"kCGImageSourceRasterizationDPI");
  }
  BOOL v8 = v4 == *(float *)&v7;
  IIODictionary::~IIODictionary((IIODictionary *)v10);
  IIODictionary::~IIODictionary((IIODictionary *)v11);
  return v8;
}

void sub_18875D988(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PDF::hasCustomImageCountProc(IIO_Reader_PDF *this)
{
  return 1;
}

uint64_t IIO_Reader_PDF::hasCustomCompareOptionsProc(IIO_Reader_PDF *this)
{
  return 1;
}

uint64_t IIO_Reader_PDF::hasCustomSourcePropertiesProc(IIO_Reader_PDF *this)
{
  return 1;
}

__CFString *_CGImageMetadataCopyFormattingDescription(CFDictionaryRef *cf, const __CFDictionary *a2)
{
  CFMutableArrayRef Mutable = 0;
  if (cf && (CFDictionaryRef *)*MEMORY[0x1E4F1D260] != cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (CGImageMetadataGetTypeID::once != -1) {
      dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
    }
    if (v4 == CGImageMetadataGetTypeID::id && cf[3])
    {
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
      CFStringAppend(Mutable, @"(\n");
      int64_t Count = CFDictionaryGetCount(cf[3]);
      uint64_t v13 = (const void **)malloc_type_calloc(8uLL, Count, 0xF211B383uLL);
      int v14 = (const void **)malloc_type_calloc(8uLL, Count, 0xA3A68BAAuLL);
      CFDictionaryGetKeysAndValues(cf[3], v13, v14);
      if (Count >= 1)
      {
        double v7 = v14;
        do
        {
          CFStringRef v8 = CFStringCreateWithFormat(v5, 0, @"%@", *v7);
          if (v8)
          {
            CFStringRef v9 = v8;
            MutableCopdouble y = CFStringCreateMutableCopy(v5, 0, v8);
            if (MutableCopy)
            {
              uint64_t v11 = (__CFString *)MutableCopy;
              v15.size_t length = CFStringGetLength(MutableCopy);
              v15.locatiounsigned int n = 0;
              CFStringFindAndReplace(v11, @"\n", @"\n        ", v15, 0);
              CFStringAppendFormat(Mutable, 0, @"    %@\n", v11);
              CFRelease(v11);
            }
            CFRelease(v9);
          }
          ++v7;
          --Count;
        }
        while (Count);
      }
      CFStringAppend(Mutable, @"\n"));
      if (v13) {
        free(v13);
      }
      if (v14) {
        free(v14);
      }
    }
    else
    {
      return 0;
    }
  }
  return Mutable;
}

CFStringRef _CGImageMetadataCopyDescription(CFDictionaryRef *cf)
{
  uint64_t v1 = 0;
  if (cf && (CFDictionaryRef *)*MEMORY[0x1E4F1D260] != cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (CGImageMetadataGetTypeID::once != -1) {
      dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
    }
    if (v3 == CGImageMetadataGetTypeID::id)
    {
      int v4 = IIO_OSAppleInternalBuild();
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      if (!v4) {
        return CFStringCreateWithFormat(v5, 0, @"<CGImageMetadata %p> %@", cf, cf);
      }
      CFMutableArrayRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 9999);
      uint64_t v1 = Mutable;
      if (!cf[3]) {
        goto LABEL_25;
      }
      CFStringAppendFormat(Mutable, 0, @"<CGImageMetadata: %p> (\n"), cf;
      CFIndex Count = CFDictionaryGetCount(cf[3]);
      int64_t v8 = Count;
      CFStringRef v9 = "s";
      if (Count == 1) {
        CFStringRef v9 = "";
      }
      CFStringAppendFormat(v1, 0, @"    %d tag%s\n", Count, v9);
      uint64_t v10 = (const void **)malloc_type_calloc(8uLL, v8, 0xA4FA6ADDuLL);
      CFDictionaryGetKeysAndValues(cf[3], v10, 0);
      v28[0] = (uint64_t (*)(uint64_t, uint64_t))compareCGImageMetadataTagKey;
      unint64_t v11 = 126 - 2 * __clz(v8);
      if (v8) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = 0;
      }
      std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CGImageMetadataTagKey const*,CGImageMetadataTagKey const*),CGImageMetadataTagKey**,false>((uint64_t)v10, (char *)&v10[v8], v28, v12, 1);
      if (v8 < 1)
      {
        CFStringAppendFormat(v1, 0, @"\n"));
        if (!v10) {
          goto LABEL_25;
        }
      }
      else
      {
        CFDictionaryRef v27 = v10;
        do
        {
          int Value = CFDictionaryGetValue(cf[3], *v10);
          CFStringRef v14 = CFStringCreateWithFormat(v5, 0, @"%@", Value);
          if (v14)
          {
            CFStringRef v15 = v14;
            MutableCopdouble y = CFStringCreateMutableCopy(v5, 0, v14);
            if (MutableCopy)
            {
              int v17 = (__CFString *)MutableCopy;
              v29.size_t length = CFStringGetLength(MutableCopy);
              v29.locatiounsigned int n = 0;
              CFStringFindAndReplace(v17, @"\n", @"\n        ", v29, 0);
              IIOString::IIOString((IIOString *)v28, v17);
              CFStringRef v18 = IIOString::utf8String((IIOString *)v28);
              CFStringAppendFormat(v1, 0, @"    %s\n", v18);
              IIOString::~IIOString((IIOString *)v28);
              CFRelease(v17);
            }
            CFRelease(v15);
          }
          ++v10;
          --v8;
        }
        while (v8);
        CFStringAppendFormat(v1, 0, @"\n"));
        uint64_t v10 = v27;
      }
      free(v10);
LABEL_25:
      CFIndex Length = CFStringGetLength(v1);
      CFStringRef v21 = CFStringCreateMutableCopy(v5, Length, v1);
      if (v21)
      {
        unsigned int v22 = (__CFString *)v21;
        v30.size_t length = CFStringGetLength(v21);
        v30.locatiounsigned int n = 0;
        CFStringFindAndReplace(v22, @"\\n", @"\n", v30, 1uLL);
        v31.size_t length = CFStringGetLength(v22);
        v31.locatiounsigned int n = 0;
        CFStringFindAndReplace(v22, @"\\\"", @"\"", v31, 1uLL);
        v32.size_t length = CFStringGetLength(v22);
        v32.locatiounsigned int n = 0;
        CFStringFindAndReplace(v22, @"\\\\", @"\\", v32, 1uLL);
        CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
        if (CStringPtr) {
          CFDictionaryRef v24 = CStringPtr;
        }
        else {
          CFDictionaryRef v24 = "<<<BAD-STRING>>>";
        }
        CFStringRef v25 = CFStringCreateWithCString(v5, v24, 0xBFFu);
        if (v25)
        {
          CFStringRef v26 = v25;
          CFStringReplaceAll(v1, v25);
          CFRelease(v26);
        }
        CFRelease(v22);
      }
      return v1;
    }
    return 0;
  }
  return v1;
}

void sub_18875DF80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageMetadataCreateImmutableCopy(uint64_t a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (CGImageMetadataGetTypeID::once != -1) {
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v4 = Instance;
  if (Instance)
  {
    *(unsigned char *)(Instance + 16) = 0;
    MutableCopdouble y = CFDictionaryCreateMutableCopy(v2, 0, *(CFDictionaryRef *)(a1 + 24));
    *(void *)(v4 + 24) = MutableCopy;
    CFDictionaryApplyFunction(MutableCopy, (CFDictionaryApplierFunction)makeTagsImmutableDictionaryApplier, 0);
    CFDictionaryRef v6 = *(const __CFDictionary **)(a1 + 40);
    if (v6) {
      *(void *)(v4 + 40) = CFDictionaryCreateMutableCopy(v2, 0, v6);
    }
    CFDictionaryRef v7 = *(const __CFDictionary **)(a1 + 32);
    if (v7) {
      *(void *)(v4 + 32) = CFDictionaryCreateMutableCopy(v2, 0, v7);
    }
    CFDictionaryRef v8 = *(const __CFDictionary **)(a1 + 48);
    if (v8) {
      *(void *)(v4 + 48) = CFDictionaryCreateMutableCopy(v2, 0, v8);
    }
    CFStringRef v9 = *(const __CFString **)(a1 + 56);
    if (v9) {
      *(void *)(v4 + 56) = CFStringCreateCopy(v2, v9);
    }
    CFStringRef v10 = *(const __CFString **)(a1 + 64);
    if (v10) {
      *(void *)(v4 + 64) = CFStringCreateCopy(v2, v10);
    }
    initRecursivePthread_mutex((pthread_mutex_t *)(v4 + 72));
    pthread_mutex_init((pthread_mutex_t *)(v4 + 136), 0);
    initRecursivePthread_mutex((pthread_mutex_t *)(v4 + 208));
  }
  return v4;
}

void makeTagsImmutableDictionaryApplier(const void *a1, CFTypeRef cf, void *a3)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CGImageMetadataTagGetTypeID())
    {
      uint64_t Source = CGImageSourceGetSource((uint64_t)cf);
      *(unsigned char *)(Source + 64) = 0;
      CFDictionaryRef v6 = *(const void **)(Source + 48);
      if (v6)
      {
        CFTypeID v7 = CFGetTypeID(v6);
        CFTypeID TypeID = CFArrayGetTypeID();
        CFArrayRef v9 = *(const __CFArray **)(Source + 48);
        if (v7 == TypeID)
        {
          v10.size_t length = CFArrayGetCount(*(CFArrayRef *)(Source + 48));
          v10.locatiounsigned int n = 0;
          CFArrayApplyFunction(v9, v10, (CFArrayApplierFunction)makeTagsImmutableArrayApplier, 0);
        }
        else if (v9)
        {
          CFTypeID v11 = CFGetTypeID(*(CFTypeRef *)(Source + 48));
          if (v11 == CFDictionaryGetTypeID())
          {
            CFDictionaryRef v12 = *(const __CFDictionary **)(Source + 48);
            CFDictionaryApplyFunction(v12, (CFDictionaryApplierFunction)makeTagsImmutableDictionaryApplier, 0);
          }
        }
      }
    }
  }
}

CGImageMetadataTagRef CGImageMetadataCopyTagWithPath(CGImageMetadataRef metadata, CGImageMetadataTagRef parent, CFStringRef path)
{
  IIOInitDebugFlags();
  if ((~gIIODebugFlags & 0x3000) == 0)
  {
    IIOString::IIOString((IIOString *)v11, path);
    CFDictionaryRef v6 = (const char *)IIOString::utf8String((IIOString *)v11);
    ImageIODebugOptions(3, "A", "CGImageMetadataCopyTagWithPath", 0, v6, -1, 0);
    IIOString::~IIOString((IIOString *)v11);
  }
  if (!metadata) {
    goto LABEL_9;
  }
  CFTypeID v7 = CFGetTypeID(metadata);
  if (CGImageMetadataGetTypeID::once != -1) {
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
  }
  if (v7 == CGImageMetadataGetTypeID::id)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 72));
    TagWithPath = CGImageMetadataGetTagWithPath(metadata, parent, path);
    if (TagWithPath) {
      CFArrayRef v9 = CGImageMetadataTagCopy((uint64_t)TagWithPath);
    }
    else {
      CFArrayRef v9 = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 72));
  }
  else
  {
LABEL_9:
    LogMetadata("CGImageMetadataCopyTagWithPath", 578, "metadata is NULL or not a CGImageMetadataRef");
    return 0;
  }
  return v9;
}

void sub_18875E31C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t __CGImageMetadataGetTagWithPath_block_invoke(uint64_t result, CFTypeRef cf, uint64_t a3, unsigned char *a4)
{
  if (cf)
  {
    uint64_t v6 = result;
    CFTypeID v7 = CFGetTypeID(cf);
    uint64_t result = CGImageMetadataTagGetTypeID();
    if (v7 == result)
    {
      uint64_t result = CGImageSourceGetSource((uint64_t)cf);
      CFArrayRef v8 = *(const __CFArray **)(result + 56);
      if (v8)
      {
        uint64_t result = CFArrayGetCount(*(CFArrayRef *)(result + 56));
        if (result >= 1)
        {
          uint64_t v9 = result;
          CFIndex v10 = 0;
          while (1)
          {
            CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v8, v10);
            CFStringRef DefaultString = (const __CFString *)CGImageMetadataGetDefaultString(ValueAtIndex);
            uint64_t result = CFStringCompare(DefaultString, *(CFStringRef *)(v6 + 48), 0);
            if (!result) {
              break;
            }
            if (v9 == ++v10) {
              goto LABEL_10;
            }
          }
          *(void *)(*(void *)(*(void *)(v6 + 32) + 8) + 24) = cf;
          *(unsigned char *)(*(void *)(*(void *)(v6 + 40) + 8) + 24) = 1;
        }
LABEL_10:
        if (*(unsigned char *)(*(void *)(*(void *)(v6 + 40) + 8) + 24)) {
          *a4 = 1;
        }
      }
    }
  }
  return result;
}

uint64_t __CGImageMetadataGetTagWithPath_block_invoke_2(uint64_t result, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID(cf);
    uint64_t result = CGImageMetadataTagGetTypeID();
    if (v4 == result)
    {
      uint64_t Source = CGImageSourceGetSource((uint64_t)cf);
      uint64_t result = CFStringCompare(*(CFStringRef *)(Source + 24), *(CFStringRef *)(v3 + 40), 0);
      if (!result)
      {
        uint64_t result = CFStringCompare(*(CFStringRef *)(Source + 32), *(CFStringRef *)(v3 + 48), 0);
        if (!result) {
          *(void *)(*(void *)(*(void *)(v3 + 32) + 8) + 24) = cf;
        }
      }
    }
  }
  return result;
}

CFStringRef CGImageMetadataCopyStringValueWithPath(CGImageMetadataRef metadata, CGImageMetadataTagRef parent, CFStringRef path)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataCopyStringValueWithPath", 0, 0, -1, 0);
  }
  if (!metadata) {
    return 0;
  }
  CFTypeID v6 = CFGetTypeID(metadata);
  if (CGImageMetadataGetTypeID::once != -1) {
    dispatch_once(&CGImageMetadataGetTypeID::once, &__block_literal_global_21);
  }
  if (v6 != CGImageMetadataGetTypeID::id) {
    return 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)metadata + 72));
  TagWithPath = CGImageMetadataGetTagWithPath(metadata, parent, path);
  if (TagWithPath && (CFStringRef DefaultString = (const __CFString *)CGImageMetadataGetDefaultString(TagWithPath)) != 0) {
    Copdouble y = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], DefaultString);
  }
  else {
    Copdouble y = 0;
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)metadata + 72));
  return Copy;
}

void *CGImageMetadataGetStringValueWithPath(void *a1, void *a2, const __CFString *a3)
{
  uint64_t result = CGImageMetadataGetTagWithPath(a1, a2, a3);
  if (result)
  {
    return (void *)CGImageMetadataGetDefaultString(result);
  }
  return result;
}

uint64_t __CGImageMetadataSetValueWithPath_block_invoke(uint64_t result, CFTypeRef cf, uint64_t a3, unsigned char *a4)
{
  if (cf)
  {
    uint64_t v6 = result;
    CFTypeID v7 = CFGetTypeID(cf);
    uint64_t result = CGImageMetadataTagGetTypeID();
    if (v7 == result)
    {
      uint64_t Source = CGImageSourceGetSource((uint64_t)cf);
      uint64_t result = CFStringCompare(*(CFStringRef *)(Source + 24), *(CFStringRef *)(v6 + 48), 0);
      if (!result)
      {
        uint64_t result = CFStringCompare(*(CFStringRef *)(Source + 32), *(CFStringRef *)(v6 + 56), 0);
        if (!result)
        {
          uint64_t result = (uint64_t)CFRetain(cf);
          *(void *)(*(void *)(*(void *)(v6 + 32) + 8) + 24) = result;
          *(unsigned char *)(*(void *)(*(void *)(v6 + 40) + 8) + 24) = 1;
          *a4 = 1;
        }
      }
    }
  }
  return result;
}

void __CGImageMetadataRemoveTagWithPath_block_invoke(int a1, CFTypeRef cf, uint64_t a3)
{
  if (cf)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CGImageMetadataTagGetTypeID())
    {
      CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"[%ld]", a3);
      if (v6)
      {
        CFStringRef v7 = v6;
        CGImageMetadataTagSetName((uint64_t)cf, v6);
        CFRelease(v7);
      }
    }
  }
}

uint64_t __CGImageMetadataRemoveTagWithPath_block_invoke_2(uint64_t result, CFTypeRef cf, uint64_t a3, unsigned char *a4)
{
  if (cf)
  {
    uint64_t v7 = result;
    CFTypeID v8 = CFGetTypeID(cf);
    uint64_t result = CGImageMetadataTagGetTypeID();
    if (v8 == result)
    {
      uint64_t result = *(void *)(CGImageSourceGetSource((uint64_t)cf) + 56);
      if (result)
      {
        v11[0] = MEMORY[0x1E4F143A8];
        v11[1] = 0x40000000;
        _OWORD v11[2] = __CGImageMetadataRemoveTagWithPath_block_invoke_3;
        void v11[3] = &unk_1E53C7310;
        uint64_t v9 = *(void *)(v7 + 64);
        uint64_t v14 = a3;
        uint64_t v15 = v9;
        long long v10 = *(_OWORD *)(v7 + 48);
        long long v12 = *(_OWORD *)(v7 + 32);
        long long v13 = v10;
        uint64_t result = IIOArrayEnumerateUsingBlock(result, (uint64_t)v11);
        if (*(unsigned char *)(*(void *)(*(void *)(v7 + 40) + 8) + 24)) {
          *a4 = 1;
        }
      }
    }
  }
  return result;
}

void __CGImageMetadataRemoveTagWithPath_block_invoke_3(uint64_t a1, const void *a2, uint64_t a3, unsigned char *a4)
{
  CFStringRef DefaultString = (const __CFString *)CGImageMetadataGetDefaultString(a2);
  if (CFEqual(DefaultString, *(CFStringRef *)(a1 + 48)))
  {
    CFAllocatorRef v7 = CFGetAllocator(*(CFTypeRef *)(a1 + 56));
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 56));
    MutableCopdouble y = CFArrayCreateMutableCopy(v7, Count, *(CFArrayRef *)(a1 + 56));
    if (MutableCopy)
    {
      CFStringRef v10 = (const __CFString *)MutableCopy;
      CFArrayRemoveValueAtIndex(MutableCopy, *(void *)(a1 + 64));
      IIOMetadata_Tag::setValue(*(IIOMetadata_Tag **)(a1 + 72), v10);
      CFRelease(*(CFTypeRef *)(a1 + 56));
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    *a4 = 1;
  }
}

void __CGImageMetadataRemoveTagWithPath_block_invoke_4(uint64_t a1, CFTypeRef cf, CFIndex a3)
{
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CGImageMetadataTagGetTypeID())
    {
      uint64_t Source = CGImageSourceGetSource((uint64_t)cf);
      if (CFEqual(*(CFStringRef *)(Source + 24), *(CFStringRef *)(a1 + 40))
        && CFEqual(*(CFStringRef *)(Source + 32), *(CFStringRef *)(a1 + 48)))
      {
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 56), a3);
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      }
    }
  }
}

CGImageMetadataTagRef CGImageMetadataCopyTagMatchingImageProperty(CGImageMetadataRef metadata, CFStringRef dictionaryName, CFStringRef propertyName)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataCopyTagMatchingImageProperty", 0, 0, -1, 0);
  }
  uint64_t v12 = 0;
  long long v13 = &v12;
  uint64_t v14 = 0x2000000000;
  uint64_t v15 = 0;
  if (dictionaryName)
  {
    CFTypeID v6 = CFGetTypeID(dictionaryName);
    CFTypeID TypeID = CFStringGetTypeID();
    if (propertyName)
    {
      if (v6 == TypeID)
      {
        CFTypeID v8 = CFGetTypeID(propertyName);
        if (v8 == CFStringGetTypeID())
        {
          v11[0] = MEMORY[0x1E4F143A8];
          v11[1] = 0x40000000;
          _OWORD v11[2] = __CGImageMetadataCopyTagMatchingImageProperty_block_invoke;
          void v11[3] = &unk_1E53C7388;
          v11[6] = propertyName;
          v11[7] = metadata;
          void v11[4] = &v12;
          v11[5] = dictionaryName;
          XMPMappingIterateUsingBlock((uint64_t)v11);
        }
      }
    }
  }
  uint64_t v9 = (CGImageMetadataTag *)v13[3];
  _Block_object_dispose(&v12, 8);
  return v9;
}

void sub_18875EAE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __CGImageMetadataCopyTagMatchingImageProperty_block_invoke(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = CFStringCompare(*(CFStringRef *)(a1 + 40), **(CFStringRef **)a2, 0);
  if (!result)
  {
    uint64_t result = CFStringCompare(*(CFStringRef *)(a1 + 48), **(CFStringRef **)(a2 + 8), 0);
    if (!result)
    {
      pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 56) + 72));
      uint64_t v7 = *(void *)(a1 + 56);
      if (v7)
      {
        CFDictionaryRef v8 = *(const __CFDictionary **)(v7 + 24);
        if (v8)
        {
          uint64_t v9 = **(void **)(a2 + 24);
          key[1] = **(void **)(a2 + 32);
          key[2] = 0;
          key[0] = v9;
          int Value = CFDictionaryGetValue(v8, key);
          if (Value) {
            *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CGImageMetadataTagCopy((uint64_t)Value);
          }
        }
      }
      uint64_t result = pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 56) + 72));
      *a3 = 1;
    }
  }
  return result;
}

BOOL CGImageMetadataSetValueMatchingImageProperty(CGMutableImageMetadataRef metadata, CFStringRef dictionaryName, CFStringRef propertyName, CFTypeRef value)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataSetValueMatchingImageProperty", 0, 0, -1, 0);
  }
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2000000000;
  char v17 = 0;
  if (dictionaryName)
  {
    CFTypeID v8 = CFGetTypeID(dictionaryName);
    CFTypeID TypeID = CFStringGetTypeID();
    if (propertyName)
    {
      if (v8 == TypeID)
      {
        CFTypeID v10 = CFGetTypeID(propertyName);
        if (v10 == CFStringGetTypeID())
        {
          v13[0] = MEMORY[0x1E4F143A8];
          v13[1] = 0x40000000;
          v13[2] = __CGImageMetadataSetValueMatchingImageProperty_block_invoke;
          v13[3] = &unk_1E53C73D8;
          v13[4] = &v14;
          v13[5] = dictionaryName;
          v13[6] = propertyName;
          v13[7] = metadata;
          v13[8] = value;
          XMPMappingIterateUsingBlock((uint64_t)v13);
        }
      }
    }
  }
  char v11 = *((unsigned char *)v15 + 24);
  _Block_object_dispose(&v14, 8);
  return v11;
}

void sub_18875ED14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __CGImageMetadataSetValueMatchingImageProperty_block_invoke(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  if (CFEqual(*(CFStringRef *)(a1 + 40), **(CFStringRef **)a2)
    && CFEqual(*(CFStringRef *)(a1 + 48), **(CFStringRef **)(a2 + 8)))
  {
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v7 = CGImageMetadataDefaultPrefixForNamespace(**(const __CFString ***)(a2 + 24));
    CFStringRef v8 = CFStringCreateWithFormat(v6, 0, @"%@:%@", v7, **(void **)(a2 + 32));
    if (v8)
    {
      CFStringRef v9 = v8;
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CGImageMetadataSetValueWithPath(*(CGMutableImageMetadataRef *)(a1 + 56), 0, v8, *(CFTypeRef *)(a1 + 64));
      CFRelease(v9);
    }
    *a3 = 1;
  }
}

CFStringRef CGImageMetadataTagKeyCopyDescription(void *a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@%@", *a1, a1[1]);
}

unint64_t compareCGImageMetadataTagKey(CFStringRef *a1, CFStringRef *a2)
{
  CFComparisonResult v4 = CFStringCompare(*a1, *a2, 0x61uLL);
  if (v4 < 0) {
    return 1;
  }
  if (v4) {
    return 0;
  }
  return (unint64_t)CFStringCompare(a1[1], a2[1], 0x61uLL) >> 63;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CGImageMetadataTagKey const*,CGImageMetadataTagKey const*),CGImageMetadataTagKey**,false>(uint64_t result, char *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  CFTypeID v10 = (char *)result;
LABEL_2:
  char v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    CFTypeID v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = a2 - v11;
    unint64_t v15 = (a2 - v11) >> 3;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t result = (*a3)(*((void *)a2 - 1), *(void *)v11);
          if (result)
          {
            uint64_t v22 = *(void *)v11;
            *(void *)char v11 = *((void *)a2 - 1);
            *((void *)a2 - 1) = v22;
          }
          break;
        case 3uLL:
          uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v11, (void *)v11 + 1, (void *)a2 - 1, (unsigned int (**)(void))a3);
          break;
        case 4uLL:
          uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v11, (void *)v11 + 1, (void *)v11 + 2, (void *)a2 - 1, (unsigned int (**)(void))a3);
          break;
        case 5uLL:
          uint64_t result = std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v11, (void *)v11 + 1, (void *)v11 + 2, (void *)v11 + 3, (void *)a2 - 1, (unsigned int (**)(void))a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 191) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **,IIOTag **>(v11, a2, (uint64_t *)a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    char v17 = &v11[8 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x401)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v11, &v11[8 * (v15 >> 1)], (void *)a2 - 1, (unsigned int (**)(void))a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((void *)v11 + 1, (void *)v17 - 1, (void *)a2 - 2, (unsigned int (**)(void))a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((void *)v11 + 2, &v11[8 * v16 + 8], (void *)a2 - 3, (unsigned int (**)(void))a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((void *)v17 - 1, v17, &v11[8 * v16 + 8], (unsigned int (**)(void))a3);
      uint64_t v18 = *(void *)v11;
      *(void *)char v11 = *(void *)v17;
      *(void *)char v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(&v11[8 * (v15 >> 1)], v11, (void *)a2 - 1, (unsigned int (**)(void))a3);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (((*a3)(*((void *)v11 - 1), *(void *)v11) & 1) == 0)
    {
      uint64_t result = (uint64_t)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,IIOTag **,BOOL (*&)(IIOTag *,IIOTag *)>((uint64_t *)v11, (uint64_t *)a2, a3);
      char v11 = (char *)result;
      goto LABEL_19;
    }
LABEL_14:
    int v19 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,IIOTag **,BOOL (*&)(IIOTag *,IIOTag *)>((uint64_t *)v11, (uint64_t *)a2, a3);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGImageMetadataTagKey const*,CGImageMetadataTagKey const*),CGImageMetadataTagKey**>(v11, v19, (unsigned int (**)(void))a3);
    char v11 = (char *)(v19 + 1);
    uint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGImageMetadataTagKey const*,CGImageMetadataTagKey const*),CGImageMetadataTagKey**>(v19 + 1, a2, (unsigned int (**)(void))a3);
    if (result)
    {
      a4 = -v13;
      a2 = (char *)v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      uint64_t result = std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(CGImageMetadataTagKey const*,CGImageMetadataTagKey const*),CGImageMetadataTagKey**,false>(v10, v19, a3, -v13, a5 & 1);
      char v11 = (char *)(v19 + 1);
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((uint64_t)v11, (uint64_t *)a2, a3);
  }
  else
  {
    return std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((uint64_t)v11, a2, a3);
  }
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(CGImageMetadataTagKey const*,CGImageMetadataTagKey const*),CGImageMetadataTagKey**>(void *a1, void *a2, unsigned int (**a3)(void))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (((unsigned int (*)(void, void))*a3)(*(a2 - 1), *a1))
      {
        uint64_t v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      CFStringRef v9 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a1 + 2, a3);
      CFTypeID v10 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    if (((unsigned int (*)(void, void))*a3)(*v10, *v9))
    {
      uint64_t v13 = *v10;
      uint64_t v14 = v11;
      while (1)
      {
        unint64_t v15 = (char *)a1 + v14;
        *(void *)((char *)a1 + v14 + 24) = *(void *)((char *)a1 + v14 + 16);
        if (v14 == -16) {
          break;
        }
        v14 -= 8;
        if ((((uint64_t (*)(uint64_t, void))*a3)(v13, *((void *)v15 + 1)) & 1) == 0)
        {
          unint64_t v16 = (void *)((char *)a1 + v14 + 24);
          goto LABEL_12;
        }
      }
      unint64_t v16 = a1;
LABEL_12:
      *unint64_t v16 = v13;
      if (++v12 == 8) {
        return v10 + 1 == a2;
      }
    }
    CFStringRef v9 = v10;
    v11 += 8;
    if (++v10 == a2) {
      return 1;
    }
  }
}

uint64_t makeTagsImmutableArrayApplier(CFTypeRef cf, void *a2, void *a3)
{
  return makeTagsImmutableDictionaryApplier(cf, cf, a3);
}

void ___ZL46CGImageMetadataEnumerateTagsUsingBlockInternalPK15CGImageMetadataPK10__CFStringP13IIODictionaryU13block_pointerFbS4_P18CGImageMetadataTagE_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@[%ld]", *(void *)(a1 + 40), a3);
  if (v6)
  {
    CFStringRef v7 = v6;
    CGImageMetadataGetTagWithPath(*(void **)(a1 + 48), 0, v6);
    if ((*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))())
    {
      if (*(unsigned char *)(a1 + 64)) {
        CGImageMetadataEnumerateTagsUsingBlockInternal(*(void *)(a1 + 48), v7, *(void *)(a1 + 56), *(void *)(a1 + 32));
      }
      CFRelease(v7);
    }
    else
    {
      CFRelease(v7);
      *a4 = 1;
    }
  }
}

void ___ZL46CGImageMetadataEnumerateTagsUsingBlockInternalPK15CGImageMetadataPK10__CFStringP13IIODictionaryU13block_pointerFbS4_P18CGImageMetadataTagE_block_invoke_2(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  TagWithPath = CGImageMetadataGetTagWithPath(*(void **)(a1 + 40), a2, @"?xml:lang");
  uint64_t Source = CGImageSourceGetSource((uint64_t)TagWithPath);
  if (TagWithPath)
  {
    CFStringRef v8 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@[%@]", *(void *)(a1 + 48), *(void *)(Source + 48));
    if (v8)
    {
      CFStringRef v9 = v8;
      char v10 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
      CFRelease(v9);
      if ((v10 & 1) == 0) {
        *a4 = 1;
      }
    }
  }
}

uint64_t TIFFInitDumpMode(void *a1)
{
  a1[119] = DumpFixupTags;
  a1[126] = DumpModeDecode;
  a1[128] = DumpModeDecode;
  a1[130] = DumpModeDecode;
  a1[127] = DumpModeEncode;
  a1[129] = DumpModeEncode;
  a1[131] = DumpModeEncode;
  a1[133] = DumpModeSeek;
  return 1;
}

uint64_t DumpFixupTags()
{
  return 1;
}

uint64_t DumpModeDecode(uint64_t a1, char *__dst, int64_t __n, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int64_t v10 = *(void *)(a1 + 1160);
  if (v10 >= __n)
  {
    if (*(char **)(a1 + 1152) != __dst)
    {
      _TIFFmemcpy(__dst, *(const void **)(a1 + 1152), __n);
      unsigned __int16 __dst = *(char **)(a1 + 1152);
      int64_t v10 = *(void *)(a1 + 1160);
    }
    *(void *)(a1 + 1152) = &__dst[__n];
    *(void *)(a1 + 1160) = v10 - __n;
    return 1;
  }
  else
  {
    TIFFErrorExtR(a1, "DumpModeDecode", "Not enough data for scanline %u, expected a request for at most %lld bytes, got a request for %lld bytes", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 876));
    return 0;
  }
}

uint64_t DumpModeEncode(void *a1, uint64_t __src, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a3 < 1) {
    return 1;
  }
  uint64_t v8 = a3;
  CFStringRef v9 = (char *)__src;
  while (1)
  {
    uint64_t v11 = a1[145];
    uint64_t v12 = a1[141];
    if (v11 + v8 <= v12) {
      int64_t v13 = v8;
    }
    else {
      int64_t v13 = v12 - v11;
    }
    if (v13 <= 0) {
      DumpModeEncode_cold_1();
    }
    uint64_t v14 = (char *)a1[144];
    if (v14 == v9)
    {
      unint64_t v15 = v9;
    }
    else
    {
      _TIFFmemcpy(v14, v9, v13);
      unint64_t v15 = (char *)a1[144];
      uint64_t v11 = a1[145];
      uint64_t v12 = a1[141];
    }
    a1[144] = &v15[v13];
    uint64_t v16 = v11 + v13;
    a1[145] = v16;
    if (v16 >= v12)
    {
      uint64_t result = TIFFFlushData1((uint64_t)a1, __src, a3, a4, a5, a6, a7, a8);
      if (!result) {
        break;
      }
    }
    v9 += v13;
    BOOL v18 = v8 <= v13;
    v8 -= v13;
    if (v18) {
      return 1;
    }
  }
  return result;
}

uint64_t DumpModeSeek(void *a1, unsigned int a2)
{
  uint64_t v2 = a1[138] * a2;
  a1[144] += v2;
  a1[145] -= v2;
  return 1;
}

void releaseGlobalInfoJP2(void *a1)
{
  if (a1) {
    free(a1);
  }
}

uint64_t GlobalJP2Info::GlobalJP2Info(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  uint64_t v3 = *(unsigned int *)(a2 + 4);
  *(_DWORD *)(a1 + 4) = v3;
  *(void *)(a1 + 8) = 0;
  if (*(void *)(a2 + 8)) {
    BOOL v4 = v3 >> 30 == 0;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    size_t v6 = 4 * v3;
    CFStringRef v7 = malloc_type_malloc(4 * v3, 0x35BE2623uLL);
    *(void *)(a1 + 8) = v7;
    memcpy(v7, *(const void **)(a2 + 8), v6);
  }
  return a1;
}

void GlobalJP2Info::~GlobalJP2Info(void **this)
{
}

double JP2ReadPlugin::JP2ReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(void *)uint64_t v5 = &unk_1ED4E0190;
  double result = 0.0;
  *(_OWORD *)(v5 + 440) = 0u;
  *(_OWORD *)(v5 + 456) = 0u;
  *(_OWORD *)(v5 + 472) = 0u;
  *(_OWORD *)(v5 + 488) = 0u;
  *(_OWORD *)(v5 + 504) = 0u;
  *(_OWORD *)(v5 + 520) = 0u;
  *(_OWORD *)(v5 + 536) = 0u;
  *(_OWORD *)(v5 + 552) = 0u;
  *(_OWORD *)(v5 + 568) = 0u;
  *(_OWORD *)(v5 + 584) = 0u;
  *(_OWORD *)(v5 + 600) = 0u;
  *(_OWORD *)(v5 + 616) = 0u;
  *(void *)(v5 + 632) = 0;
  return result;
}

void JP2ReadPlugin::JP2ReadPlugin(uint64_t a1, uint64_t a2)
{
}

void JP2ReadPlugin::~JP2ReadPlugin(JP2ReadPlugin *this)
{
  *(void *)this = &unk_1ED4E0190;
  _cg_JP2TearDownDecompressor((void *)this + 55);
  uint64_t v2 = (const void *)*((void *)this + 67);
  if (v2) {
    CFRelease(v2);
  }

  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  uint64_t vars8;

  JP2ReadPlugin::~JP2ReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t JP2ReadPlugin::loadDataFromXPCObject(JP2ReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_jp2", &length);
    size_t v6 = length;
    if (length < 0xC8)
    {
      return 4294967246;
    }
    else
    {
      CFStringRef v7 = data;
      uint64_t result = 0;
      *(_OWORD *)((char *)this + 440) = *(_OWORD *)v7;
      long long v8 = *((_OWORD *)v7 + 1);
      long long v9 = *((_OWORD *)v7 + 2);
      long long v10 = *((_OWORD *)v7 + 4);
      *(_OWORD *)((char *)this + 488) = *((_OWORD *)v7 + 3);
      *(_OWORD *)((char *)this + 504) = v10;
      *(_OWORD *)((char *)this + 456) = v8;
      *(_OWORD *)((char *)this + 472) = v9;
      long long v11 = *((_OWORD *)v7 + 5);
      long long v12 = *((_OWORD *)v7 + 6);
      long long v13 = *((_OWORD *)v7 + 8);
      *(_OWORD *)((char *)this + 552) = *((_OWORD *)v7 + 7);
      *(_OWORD *)((char *)this + 568) = v13;
      *(_OWORD *)((char *)this + 520) = v11;
      *(_OWORD *)((char *)this + 536) = v12;
      long long v14 = *((_OWORD *)v7 + 9);
      long long v15 = *((_OWORD *)v7 + 10);
      long long v16 = *((_OWORD *)v7 + 11);
      *((void *)this + 79) = *((void *)v7 + 24);
      *(_OWORD *)((char *)this + 600) = v15;
      *(_OWORD *)((char *)this + 616) = v16;
      *(_OWORD *)((char *)this + 584) = v14;
      *((void *)this + 55) = *((void *)this + 3);
      *((void *)this + 58) = MyRead;
      *((void *)this + 59) = MySeek;
      *((void *)this + 60) = 0;
      *((void *)this + 57) = *((void *)this + 24);
      *((_DWORD *)this + 122) = 0;
      *((void *)this + 62) = 0;
      *((void *)this + 67) = 0;
      *((void *)this + 73) = 0;
      *((void *)this + 74) = 0;
      if (v6 != 200)
      {
        CFDataRef v17 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v7 + 200, v6 - 200);
        uint64_t result = 0;
        *((void *)this + 67) = v17;
      }
    }
  }
  return result;
}

unint64_t MySeek(IIOImageReadSession *a1, unint64_t a2)
{
  return IIOImageReadSession::seek(a1, a2, 0);
}

uint64_t JP2ReadPlugin::saveDataToXPCObject(JP2ReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4)
  {
    uint64_t v27 = *((void *)this + 79);
    long long v5 = *(_OWORD *)((char *)this + 616);
    long long v25 = *(_OWORD *)((char *)this + 600);
    long long v26 = v5;
    long long v6 = *(_OWORD *)((char *)this + 552);
    *(_OWORD *)CFDataRef theData = *(_OWORD *)((char *)this + 536);
    long long v22 = v6;
    long long v7 = *(_OWORD *)((char *)this + 584);
    long long v23 = *(_OWORD *)((char *)this + 568);
    long long v24 = v7;
    long long v8 = *(_OWORD *)((char *)this + 488);
    long long v17 = *(_OWORD *)((char *)this + 472);
    long long v18 = v8;
    long long v9 = *(_OWORD *)((char *)this + 520);
    long long v19 = *(_OWORD *)((char *)this + 504);
    long long v20 = v9;
    CFDataRef v10 = theData[0];
    theData[0] = 0;
    memset(v16, 0, sizeof(v16));
    long long v17 = 0u;
    long long v18 = 0u;
    long long v24 = 0uLL;
    if (v10) {
      CFIndex v11 = CFDataGetLength(v10) + 200;
    }
    else {
      CFIndex v11 = 200;
    }
    CFMutableArrayRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v11);
    CFDataAppendBytes(Mutable, (const UInt8 *)v16, 200);
    if (v10)
    {
      BytePtr = CFDataGetBytePtr(v10);
      CFIndex Length = CFDataGetLength(v10);
      CFDataAppendBytes(Mutable, BytePtr, Length);
    }
    iio_xpc_dictionary_add_CFData(a2, "iio_xpc_plugin_data_jp2", Mutable);
    CFRelease(Mutable);
  }
  return v4;
}

BOOL JP2ReadPlugin::hasNoLength(JP2ReadPlugin *this, int a2)
{
  return (a2 - 65328) < 0x10 || (a2 - 65426) < 2 || a2 == 65359 || a2 == 65497;
}

CGColorSpaceRef JP2ReadPlugin::createColorSpaceForJP2(uint64_t a1, uint64_t a2, int a3)
{
  CGColorSpaceRef v5 = 0;
  int v6 = *(_DWORD *)(a2 + 80);
  if (v6 <= 99)
  {
    int v7 = v6 - 12;
    long long v8 = (CFStringRef *)MEMORY[0x1E4F1DBF0];
    switch(v7)
    {
      case 0:
        goto LABEL_12;
      case 4:
      case 6:
        goto LABEL_3;
      case 5:
        goto LABEL_11;
      default:
        goto LABEL_13;
    }
    goto LABEL_13;
  }
  uint64_t v9 = *(void *)(a2 + 96);
  switch(v6)
  {
    case 'd':
      CGColorSpaceRef v5 = (CGColorSpaceRef)MEMORY[0x18C11AC10](v9);
      if (v5) {
        goto LABEL_16;
      }
LABEL_11:
      long long v8 = (CFStringRef *)MEMORY[0x1E4F1DC00];
      goto LABEL_12;
    case 'e':
      CGColorSpaceRef v5 = (CGColorSpaceRef)MEMORY[0x18C11AC10](v9);
      if (v5) {
        goto LABEL_16;
      }
      goto LABEL_3;
    case 'f':
      uint64_t v10 = *(void *)(a2 + 88);
      CGColorSpaceRef v5 = (CGColorSpaceRef)MEMORY[0x18C11AC10](v9);
      if (v5) {
        goto LABEL_16;
      }
      if ((unint64_t)(v10 - 1) <= 3)
      {
        long long v8 = (CFStringRef *)qword_1E53C7448[v10 - 1];
        goto LABEL_12;
      }
LABEL_3:
      long long v8 = (CFStringRef *)MEMORY[0x1E4F1DC98];
LABEL_12:
      CGColorSpaceRef v5 = CGColorSpaceCreateWithName(*v8);
      break;
  }
LABEL_13:
  if (!v5 && a3) {
    CGColorSpaceRef v5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
  }
LABEL_16:
  if (!*(unsigned char *)(a2 + 179)) {
    return v5;
  }
  int v11 = 1380401696;
  uint64_t v21 = 0;
  int v12 = *(_DWORD *)(a2 + 80);
  if (v12 > 99)
  {
    if (v12 == 100) {
      goto LABEL_28;
    }
    if (v12 != 102) {
      goto LABEL_29;
    }
    if (*(void *)(a2 + 88) == 1) {
      int v11 = 1196573017;
    }
    else {
      int v11 = 1380401696;
    }
    if (!v5)
    {
LABEL_35:
      if (v11 == 1129142603)
      {
        long long v14 = (CFStringRef *)MEMORY[0x1E4F1DBF0];
      }
      else if (v11 == 1196573017)
      {
        long long v14 = (CFStringRef *)MEMORY[0x1E4F1DC00];
      }
      else
      {
        long long v14 = (CFStringRef *)MEMORY[0x1E4F1DC98];
      }
      long long v13 = CGColorSpaceCreateWithName(*v14);
      if (!v13) {
        return v5;
      }
      goto LABEL_41;
    }
  }
  else
  {
    if (v12 != 12)
    {
      if (v12 != 17)
      {
LABEL_29:
        if (!v5) {
          goto LABEL_35;
        }
        goto LABEL_30;
      }
LABEL_28:
      int v11 = 1196573017;
      goto LABEL_29;
    }
    int v11 = 1129142603;
    if (!v5) {
      goto LABEL_35;
    }
  }
LABEL_30:
  long long v13 = (CGColorSpace *)CFRetain(v5);
  if (!v13) {
    goto LABEL_35;
  }
LABEL_41:
  int NumberOfComponents = CGColorSpaceGetNumberOfComponents(v13);
  Palette = (unsigned __int8 *)_cg_JP2GetPalette(a2, NumberOfComponents, (_DWORD *)&v21 + 1, (int *)&v21);
  if (Palette)
  {
    long long v17 = Palette;
    size_t v18 = (int)v21;
    if (CGColorSpaceGetNumberOfComponents(v13) <= v18)
    {
      CGColorSpaceRef Indexed = CGColorSpaceCreateIndexed(v13, SHIDWORD(v21) - 1, v17);
      if (v5) {
        CGColorSpaceRelease(v5);
      }
    }
    else
    {
      CGColorSpaceRef Indexed = v5;
    }
    free(v17);
    CGColorSpaceRef v5 = Indexed;
  }
  CFRelease(v13);
  return v5;
}

uint64_t JP2ReadPlugin::validateJ2K(JP2ReadPlugin *this, IIOScanner *a2, unint64_t a3, BOOL *a4)
{
  __dst[1] = *MEMORY[0x1E4F143B8];
  unint64_t v7 = *((void *)a2 + 3);
  if (a4) {
    *a4 = 0;
  }
  unint64_t v8 = v7 + a3;
  if (v7 < v7 + a3)
  {
    char v9 = 0;
    char v10 = 0;
    char v11 = 0;
    unint64_t v12 = 0;
    unint64_t v22 = a3 + 10;
    uint64_t v23 = 0;
    while (1)
    {
      unsigned int Val16 = (JP2ReadPlugin *)IIOScanner::getVal16(a2);
      int v14 = (int)Val16;
      if (!Val16) {
        goto LABEL_45;
      }
      if (JP2ReadPlugin::hasNoLength(Val16, (int)Val16))
      {
        if (v14 == 65427)
        {
          if (v12 + 1 < 0xF) {
            goto LABEL_49;
          }
          uint64_t v15 = v12 - 14;
LABEL_33:
          char v9 = 1;
          goto LABEL_40;
        }
        uint64_t v15 = 0;
      }
      else
      {
        long long v16 = (JP2ReadPlugin *)IIOScanner::getVal16(a2);
        if (v16 < 2) {
          goto LABEL_49;
        }
        uint64_t v15 = v16 - 2;
        switch(v14)
        {
          case 65424:
            __dst[0] = 0;
            IIOScanner::copyBytes(a2, __dst, 8uLL);
            IIOScanner::skip((uint64_t)a2, 8);
            if (BYTE6(__dst[0]) == 255) {
              goto LABEL_49;
            }
            uint64_t v18 = *((void *)a2 + 3);
            if (*(_DWORD *)((char *)__dst + 2))
            {
              unint64_t v12 = bswap32(*(unsigned int *)((char *)__dst + 2));
            }
            else
            {
              if (v18 + 10 > a3)
              {
LABEL_49:
                char v20 = 0;
                return v20 & 1;
              }
              unint64_t v12 = v22 - v18;
            }
            IIOScanner::seek(a2, v18 - 8);
            goto LABEL_40;
          case 65362:
            unint64_t v19 = *((void *)a2 + 3);
            if (!JP2ReadPlugin::checkCodingStyleDefaultBox(v16, a2)) {
              goto LABEL_49;
            }
            IIOScanner::seek(a2, v19);
LABEL_29:
            char v10 = 1;
            goto LABEL_40;
          case 65361:
            unint64_t v17 = *((void *)a2 + 3);
            if (!JP2ReadPlugin::checkImageTileSizeBox(v16, a2)) {
              goto LABEL_49;
            }
            IIOScanner::seek(a2, v17);
LABEL_30:
            char v11 = 1;
            goto LABEL_40;
        }
        if (v12)
        {
          if (v12 < 5) {
            goto LABEL_49;
          }
          unint64_t v12 = v12 - v16 - 2;
        }
      }
      if (v14 > 65371)
      {
        switch(v14)
        {
          case 65372:
            LOBYTE(v23) = 1;
            break;
          case 65427:
            goto LABEL_33;
          case 65497:
            if (a4) {
              *a4 = 1;
            }
            goto LABEL_45;
        }
      }
      else
      {
        switch(v14)
        {
          case 65359:
            BYTE4(v23) = 1;
            break;
          case 65361:
            goto LABEL_30;
          case 65362:
            goto LABEL_29;
        }
      }
LABEL_40:
      if (v15) {
        IIOScanner::skip((uint64_t)a2, v15);
      }
      if (*((void *)a2 + 3) >= v8) {
        goto LABEL_45;
      }
    }
  }
  uint64_t v23 = 0;
  char v11 = 0;
  char v10 = 0;
  char v9 = 0;
LABEL_45:
  char v20 = BYTE4(v23) & v11 & v10 & v23 & v9;
  return v20 & 1;
}

BOOL JP2ReadPlugin::checkImageTileSizeBox(JP2ReadPlugin *this, IIOScanner *a2)
{
  return (IIOScanner::getVal8(a2) & 0x7F) - 1 < 0x26;
}

uint64_t JP2ReadPlugin::checkCodingStyleDefaultBox(JP2ReadPlugin *this, IIOScanner *a2)
{
  IIOScanner::getVal8(a2);
  unsigned int Val8 = IIOScanner::getVal8(a2);
  int Val16 = IIOScanner::getVal16(a2);
  IIOScanner::getVal8(a2);
  unsigned int v5 = IIOScanner::getVal8(a2);
  unsigned int v6 = IIOScanner::getVal8(a2);
  IIOScanner::getVal8(a2);
  IIOScanner::getVal8(a2);
  if (Val8 >= 5) {
    *(void *)&double v7 = _cg_jpeg_mem_term("checkCodingStyleDefaultBox", 1201, "*** ERROR: unexpected 'Progression order for the SGcod, SPcoc, and Ppoc parameters' (%d)\n", Val8).n128_u64[0];
  }
  if (Val16)
  {
    if (v5 >= 0x21)
    {
      _cg_jpeg_mem_term("checkCodingStyleDefaultBox", 1207, "*** ERROR: bad 'COD NumDecompositionLevels' (%d)\n", v7);
    }
    else if (v6 >= 0xFE)
    {
      _cg_jpeg_mem_term("checkCodingStyleDefaultBox", 1210, "*** ERROR: bad 'COD CodeBlockWidth' (%d)\n", v7);
    }
    else
    {
      if ((v6 + 2) < 0xBu) {
        return 1;
      }
      _cg_jpeg_mem_term("checkCodingStyleDefaultBox", 1211, "*** ERROR: bad 'COD CodeBlockWidth' (%d)\n", v7);
    }
  }
  else
  {
    _cg_jpeg_mem_term("checkCodingStyleDefaultBox", 1204, "*** ERROR: bad 'COD NumberOfLayers' (%d)\n", v7);
  }
  return 0;
}

BOOL JP2ReadPlugin::checkFileTypeBox(JP2ReadPlugin *this, IIOScanner *a2, int a3)
{
  if ((a3 & 3) != 0)
  {
    _cg_jpeg_mem_term("checkFileTypeBox", 923, "*** ERROR: bad JP2 FileBox size [%lld]\n");
  }
  else
  {
    int Val32 = IIOScanner::getVal32(a2);
    if (Val32 == 1785737760 || (int v6 = Val32, Val32 == 1785755680))
    {
      int v7 = IIOScanner::getVal32(a2);
      if (v7)
      {
        int v8 = v7;
        if (v7 != 1785737760)
        {
          unsigned int v9 = v7 >> 24;
          if (v7 < 0) {
            int v10 = __maskrune(v7 >> 24, 0x40000uLL);
          }
          else {
            int v10 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
          }
          if (v10) {
            uint64_t v11 = v9;
          }
          else {
            uint64_t v11 = 46;
          }
          unsigned int v12 = v8 << 8 >> 24;
          if (v8 << 8 < 0) {
            int v13 = __maskrune(v8 << 8 >> 24, 0x40000uLL);
          }
          else {
            int v13 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x40000;
          }
          if (v13) {
            uint64_t v14 = v12;
          }
          else {
            uint64_t v14 = 46;
          }
          unsigned int v15 = (__int16)v8 >> 8;
          if (v8 << 16 < 0) {
            int v16 = __maskrune((__int16)v8 >> 8, 0x40000uLL);
          }
          else {
            int v16 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v15 + 60) & 0x40000;
          }
          if (v16) {
            uint64_t v17 = v15;
          }
          else {
            uint64_t v17 = 46;
          }
          if ((v8 << 24) <= 0x7F000000) {
            int v18 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v8 + 60) & 0x40000;
          }
          else {
            int v18 = __maskrune((char)v8, 0x40000uLL);
          }
          if (v18) {
            uint64_t v19 = (char)v8;
          }
          else {
            uint64_t v19 = 46;
          }
          LogWarning("checkFileTypeBox", 935, "*** NOTE: JPEG2000 - bad minorVersion? [0x%08X] '%c%c%c%c'\n", v8, v11, v14, v17, v19);
        }
      }
      unsigned int v20 = a3 - 8;
      if ((a3 - 8) >= 4)
      {
        unsigned int v21 = v20 >> 2;
        if (v20 >> 2 <= 1) {
          int v22 = 1;
        }
        else {
          int v22 = v20 >> 2;
        }
        if (IIOScanner::getVal32(a2) == 1785737760) {
          return 1;
        }
        unsigned int v24 = 0;
        int v25 = v22 - 1;
        while (v25 != v24)
        {
          ++v24;
          if (IIOScanner::getVal32(a2) == 1785737760) {
            return v24 < v21;
          }
        }
      }
      _cg_jpeg_mem_term("checkFileTypeBox", 952, "*** ERROR: CompatibleBrands does not contain 'jp2 '\n");
    }
    else
    {
      if (Val32 < 0) {
        __maskrune(Val32 >> 24, 0x40000uLL);
      }
      if (v6 << 8 < 0) {
        __maskrune(v6 << 8 >> 24, 0x40000uLL);
      }
      if (v6 << 16 < 0) {
        __maskrune((__int16)v6 >> 8, 0x40000uLL);
      }
      if ((v6 << 24) > 0x7F000000) {
        __maskrune((char)v6, 0x40000uLL);
      }
      _cg_jpeg_mem_term("checkFileTypeBox", 927, "*** ERROR: bad majorBrand '%c%c%c%c' [%08X]\n");
    }
  }
  return 0;
}

uint64_t JP2ReadPlugin::checkJP2HeaderBox(JP2ReadPlugin *this, IIOScanner *a2, uint64_t a3)
{
  uint64_t v5 = *((void *)a2 + 3);
  int Val32 = IIOScanner::getVal32(a2);
  int v7 = (JP2ReadPlugin *)IIOScanner::getVal32(a2);
  unsigned int v17 = 0;
  if (v7 == 1768449138)
  {
    if (Val32 == 22)
    {
      uint64_t result = JP2ReadPlugin::checkImageHeaderBox(v7, a2);
      if (!result) {
        return result;
      }
      uint64_t v9 = *((void *)a2 + 3);
      int v10 = IIOScanner::getVal32(a2);
      if (v10)
      {
        LODWORD(v11) = v10;
        char v12 = 0;
        unint64_t v13 = v5 + a3;
        do
        {
          uint64_t v14 = (JP2ReadPlugin *)IIOScanner::getVal32(a2);
          if (v14 == 1668246642)
          {
            uint64_t v11 = v11;
            if ((JP2ReadPlugin::checkColorSpecificationBox(v14, a2, v11, &v17) & 1) == 0) {
              return 0;
            }
            char v12 = 1;
          }
          else
          {
            if (v14 == 1885564018)
            {
              uint64_t result = JP2ReadPlugin::checkPaletteBox(v14, a2, v15, v17);
              if (!result) {
                return result;
              }
            }
            uint64_t v11 = v11;
          }
          if (v13 <= v9 + v11) {
            break;
          }
          IIOScanner::seek(a2, v9 + v11);
          uint64_t v9 = *((void *)a2 + 3);
          LODWORD(v11) = IIOScanner::getVal32(a2);
        }
        while (v11);
        if (v12) {
          return 1;
        }
      }
      _cg_jpeg_mem_term("checkJP2HeaderBox", 1020, "*** ERROR: JP2HeaderBox: ihdr has no ColorSpecificationBox\n");
    }
    else
    {
      _cg_jpeg_mem_term("checkJP2HeaderBox", 976, "*** ERROR: JP2HeaderBox: ihdr marker has wrong size (%d)\n");
    }
  }
  else
  {
    int v16 = (int)v7;
    if ((v7 & 0x80000000) != 0) {
      __maskrune((int)v7 >> 24, 0x40000uLL);
    }
    if (v16 << 8 < 0) {
      __maskrune(v16 << 8 >> 24, 0x40000uLL);
    }
    if (v16 << 16 < 0) {
      __maskrune((__int16)v16 >> 8, 0x40000uLL);
    }
    if ((v16 << 24) > 0x7F000000) {
      __maskrune((char)v16, 0x40000uLL);
    }
    _cg_jpeg_mem_term("checkJP2HeaderBox", 975, "*** ERROR: JP2HeaderBox - expected 'ihdr' marker, got '%c%c%c%c' [%08X]\n");
  }
  return 0;
}

uint64_t JP2ReadPlugin::checkImageHeaderBox(JP2ReadPlugin *this, IIOScanner *a2)
{
  int Val32 = IIOScanner::getVal32(a2);
  int v4 = IIOScanner::getVal32(a2);
  int Val16 = IIOScanner::getVal16(a2);
  int Val8 = IIOScanner::getVal8(a2);
  int v7 = IIOScanner::getVal8(a2);
  IIOScanner::getVal8(a2);
  unsigned int v8 = IIOScanner::getVal8(a2);
  if (Val32)
  {
    if (v4)
    {
      if ((Val16 - 16385) <= 0xFFFFBFFF)
      {
        _cg_jpeg_mem_term("checkImageHeaderBox", 1043, "*** ERROR: invalid JP2: numberOfComponents == %d\n");
      }
      else if ((Val8 - 39) > 0xFFFFFFD9 || Val16 == 255)
      {
        if (v7 == 7)
        {
          if (v8 < 2) {
            return 1;
          }
          _cg_jpeg_mem_term("checkImageHeaderBox", 1046, "*** ERROR: invalid JP2: interlectualProperty == %d\n");
        }
        else
        {
          _cg_jpeg_mem_term("checkImageHeaderBox", 1045, "*** ERROR: invalid JP2: compression == %d\n");
        }
      }
      else
      {
        _cg_jpeg_mem_term("checkImageHeaderBox", 1044, "*** ERROR: invalid JP2: numberOfComponents == %d\n");
      }
    }
    else
    {
      _cg_jpeg_mem_term("checkImageHeaderBox", 1042, "*** ERROR: invalid JP2: height == 0\n");
    }
  }
  else
  {
    _cg_jpeg_mem_term("checkImageHeaderBox", 1041, "*** ERROR: invalid JP2: width == 0\n");
  }
  return 0;
}

uint64_t JP2ReadPlugin::checkColorSpecificationBox(JP2ReadPlugin *this, IIOScanner *a2, uint64_t a3, unsigned int *a4)
{
  int Val8 = IIOScanner::getVal8(a2);
  if (a3 == 15 && (Val8 - 3) <= 0xFFFFFFFD)
  {
    _cg_jpeg_mem_term("checkColorSpecificationBox", 1063, "*** ERROR: invalid JP2: colorSpecMethod == %d\n", v8);
    return 0;
  }
  if (Val8 != 1)
  {
    unsigned int v13 = 0;
    if (!a4) {
      return 1;
    }
LABEL_9:
    *a4 = v13;
    return 1;
  }
  IIOScanner::skip((uint64_t)a2, 2);
  int Val32 = IIOScanner::getVal32(a2);
  int v10 = Val32 - 1;
  if ((Val32 - 1) >= 0x18 || ((0xFFFD0Du >> v10) & 1) == 0)
  {
    *(void *)&double v11 = _cg_jpeg_mem_term("checkColorSpecificationBox", 1100, "*** ERROR: unsupported colorSpace (%d)\n", Val32).n128_u64[0];
    _cg_jpeg_mem_term("checkColorSpecificationBox", 1103, "*** ERROR: invalid JP2 colorSpace: %d\n", v11);
    return 0;
  }
  unsigned int v13 = dword_1889918B8[v10];
  if (a4) {
    goto LABEL_9;
  }
  return 1;
}

uint64_t JP2ReadPlugin::checkPaletteBox(JP2ReadPlugin *this, IIOScanner *a2, unint64_t a3, unsigned int a4)
{
  if (a4 < 0x15 && ((0x130001u >> a4) & 1) != 0) {
    return 1;
  }
  _cg_jpeg_mem_term("checkPaletteBox", 1132, "*** ERROR: invalid JP2: PaletteBox for non-RGB/non-Grayscale image (cs: %d)\n", a4);
  return 0;
}

BOOL JP2ReadPlugin::checkContinousCodestreamBox(JP2ReadPlugin *this, IIOScanner *a2)
{
  if (IIOScanner::getVal16(a2) == 65359)
  {
    while (1)
    {
      int Val16 = IIOScanner::getVal16(a2);
      uint64_t v4 = *((void *)a2 + 3);
      uint64_t v5 = (JP2ReadPlugin *)IIOScanner::getVal16(a2);
      unsigned int v6 = v5;
      if (Val16 <= 65361)
      {
        if (Val16 == 65361)
        {
          BOOL result = JP2ReadPlugin::checkImageTileSizeBox(v5, a2);
          if (!result) {
            return result;
          }
        }
      }
      else if (Val16 == 65362)
      {
        if ((JP2ReadPlugin::checkCodingStyleDefaultBox(v5, a2) & 1) == 0) {
          return 0;
        }
      }
      else
      {
        BOOL result = 1;
        if (Val16 == 65427 || Val16 == 65497) {
          return result;
        }
      }
      IIOScanner::seek(a2, v4 + v6);
    }
  }
  _cg_jpeg_mem_term("checkContinousCodestreamBox", 1230, "*** ERROR: invalid JP2: CodestreamBox missing SOC\n");
  return 1;
}

uint64_t JP2ReadPlugin::validateJP2(JP2ReadPlugin *this, IIOScanner *a2)
{
  unint64_t v3 = *((void *)a2 + 2);
  uint64_t v4 = *((void *)a2 + 3);
  int Val32 = IIOScanner::getVal32(a2);
  if (v4 + 3 >= v3) {
    goto LABEL_53;
  }
  LODWORD(v6) = Val32;
  uint64_t v22 = 0;
  char v24 = 0;
  char v23 = 0;
  do
  {
    Val64 = (JP2ReadPlugin *)IIOScanner::getVal32(a2);
    int v8 = (int)Val64;
    if (v6 == 1)
    {
      Val64 = (JP2ReadPlugin *)IIOScanner::getVal64(a2);
      uint64_t v6 = (uint64_t)Val64;
    }
    else
    {
      uint64_t v6 = v6;
    }
    if (v8 > 1785737826)
    {
      if (v8 == 1785737827)
      {
        if (!JP2ReadPlugin::checkContinousCodestreamBox(Val64, a2)) {
          return 0;
        }
        LOBYTE(v22) = 1;
      }
      else if (v8 == 1785737832)
      {
        if ((JP2ReadPlugin::checkJP2HeaderBox(this, a2, v6) & 1) == 0) {
          return 0;
        }
        BYTE4(v22) = 1;
      }
    }
    else if (v8 == 1718909296)
    {
      if (!JP2ReadPlugin::checkFileTypeBox(Val64, a2, v6)) {
        return 0;
      }
      char v24 = 1;
    }
    else if (v8 == 1783636000)
    {
      if (IIOScanner::getVal32(a2) != 218793738) {
        return 0;
      }
      char v23 = 1;
    }
    if (v6 + v4 == v3) {
      break;
    }
    if (v6 + v4 > v3)
    {
      unsigned int v9 = v8 >> 24;
      int v10 = v8 < 0 ? __maskrune(v8 >> 24, 0x40000uLL) : *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
      uint64_t v11 = v10 ? v9 : 46;
      unsigned int v12 = v8 << 8 >> 24;
      int v13 = v8 << 8 < 0
          ? __maskrune(v8 << 8 >> 24, 0x40000uLL)
          : *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x40000;
      uint64_t v14 = v13 ? v12 : 46;
      unsigned int v15 = (__int16)v8 >> 8;
      int v16 = v8 << 16 < 0
          ? __maskrune((__int16)v8 >> 8, 0x40000uLL)
          : *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v15 + 60) & 0x40000;
      uint64_t v17 = v16 ? v15 : 46;
      int v18 = (v8 << 24) <= 0x7F000000
          ? *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v8 + 60) & 0x40000
          : __maskrune((char)v8, 0x40000uLL);
      uint64_t v19 = v18 ? (char)v8 : 46;
      _cg_jpeg_mem_term("validateJP2", 1327, "*** ERROR: marker '%c%c%c%c' length (%d) at offset (%d [0x%04X]) larger than fileSize(%d)\n", v11, v14, v17, v19, v6, v4, v4, v3);
      if (v8 != 1785737827) {
        break;
      }
    }
    IIOScanner::seek(a2, v6 + v4);
    if (!v6) {
      break;
    }
    uint64_t v4 = *((void *)a2 + 3);
    LODWORD(v6) = IIOScanner::getVal32(a2);
  }
  while (v4 + 3 < v3);
  if (v23)
  {
    if (v24)
    {
      if ((v22 & 0x100000000) != 0)
      {
        if (v22) {
          return 1;
        }
        _cg_jpeg_mem_term("validateJP2", 1344, "*** ERROR: no ContinousCodestreamBox\n");
      }
      else
      {
        _cg_jpeg_mem_term("validateJP2", 1343, "*** ERROR: no JP2HeaderBox\n");
      }
    }
    else
    {
      _cg_jpeg_mem_term("validateJP2", 1342, "*** ERROR: no FileTypeBox\n");
    }
  }
  else
  {
LABEL_53:
    _cg_jpeg_mem_term("validateJP2", 1341, "*** ERROR: no SignatureBox\n");
  }
  return 0;
}

uint64_t JP2ReadPlugin::isValidJP2000(JP2ReadPlugin *this)
{
  BOOL v10 = 0;
  uint64_t Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  IIOScanner::IIOScanner((IIOScanner *)v8, *((IIOImageReadSession **)this + 3));
  GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v8, 0);
  IIOScanner::seek((IIOScanner *)v8, *((void *)this + 24));
  int Val16 = IIOScanner::getVal16((IIOScanner *)v8);
  IIOScanner::seek((IIOScanner *)v8, *((void *)this + 24));
  if (Val16 == 65359)
  {
    uint64_t v4 = JP2ReadPlugin::validateJ2K(this, (IIOScanner *)v8, (unint64_t)Size, &v10);
    uint64_t v5 = v4;
    if (v10) {
      int v6 = 0;
    }
    else {
      int v6 = v4;
    }
    if (v6 == 1)
    {
      if (IIOImageReadSession::isFinal(*((IIOImageReadSession **)this + 3)))
      {
        _cg_jpeg_mem_term("isValidJP2000", 1373, "*** ERROR: missing EOC maker for final JPEG2000\n");
        uint64_t v5 = 0;
      }
      else
      {
        uint64_t v5 = 1;
      }
    }
  }
  else
  {
    uint64_t v5 = JP2ReadPlugin::validateJP2(this, (IIOScanner *)v8);
  }
  IIOScanner::~IIOScanner((IIOScanner *)v8);
  return v5;
}

void sub_1887611A4(void *a1)
{
}

void sub_1887611B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t JP2ReadPlugin::initialize(JP2ReadPlugin *this, IIODictionary *a2)
{
  uint64_t v4 = (IIODictionary *)*((void *)this + 6);
  IIODictionary::getUint32ForKey(a2, @"NEW_PLUGIN_expectedWidth");
  IIODictionary::getUint32ForKey(a2, @"NEW_PLUGIN_expectedHeight");
  if (JP2ReadPlugin::isValidJP2000(this))
  {
    unint64_t v5 = *((void *)this + 24);
    if (v5)
    {
      IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), v5, 0);
      uint64_t v6 = *((void *)this + 24);
    }
    else
    {
      uint64_t v6 = 0;
    }
    *((_OWORD *)this + 28) = 0u;
    *((_OWORD *)this + 29) = 0u;
    *((void *)this + 78) = 0;
    *((_OWORD *)this + 37) = 0u;
    *((_OWORD *)this + 38) = 0u;
    *((_OWORD *)this + 35) = 0u;
    *((_OWORD *)this + 36) = 0u;
    *((_OWORD *)this + 33) = 0u;
    *((_OWORD *)this + 34) = 0u;
    *((_OWORD *)this + 31) = 0u;
    *((_OWORD *)this + 32) = 0u;
    *((_OWORD *)this + 30) = 0u;
    int v7 = (IIOImageReadSession *)*((void *)this + 3);
    *((void *)this + 55) = v7;
    *((void *)this + 57) = v6;
    *((void *)this + 58) = MyRead;
    *((void *)this + 59) = MySeek;
    if (!IIOImageReadSession::globalInfoForType(v7, 1246769696))
    {
      int v8 = malloc_type_calloc(1uLL, 0x10uLL, 0x1010040449DF08BuLL);
      v8[1] = 0;
      IIOImageReadSession::setGlobalInfo(*((IIOImageRead ***)this + 3), 1246769696, v8, releaseGlobalInfoJP2);
    }
    *((unsigned char *)this + 617) = 0;
    if (IIODictionary::containsKey(v4, @"kCGImageSourceSubsampleFactor")) {
      *((void *)this + 76) = IIODictionary::getUint32ForKey(v4, @"kCGImageSourceSubsampleFactor");
    }
    *((void *)this + 75) = *((unsigned int *)this + 53);
    _cg_JP2SetupDecompressor((uint64_t)this + 440, (uint64_t)this + 440);
  }
  LogError("initialize", 1415, "*** invalid JPEG2000 file ***\n");
  kdebug_trace();
  return 4294967246;
}

void sub_1887617F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t JP2ReadPlugin::decodeJP2Block(JP2ReadPlugin *this, void *a2, CGRect a3)
{
  unint64_t v3 = (void *)((char *)this + 440);
  *((void *)this + 74) = a2;
  *((_DWORD *)this + 122) = 0;
  if (*((unsigned char *)this + 618))
  {
    IIOImageReadSession::rewind(*((void *)this + 3));
    _cg_JP2ResetSource(v3);
  }
  return _cg_JP2DecompressBlock((uint64_t)v3, (int)a3.origin.x, (int)a3.origin.y, (int)a3.size.width, (int)a3.size.height);
}

void sub_188761898(void *a1)
{
}

uint64_t JP2ReadPlugin::decodeJP2Prog(JP2ReadPlugin *this, void *a2, CGRect a3)
{
  if (IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1246769696))
  {
    IIOImageReadSession::rewind(*((void *)this + 3));
    _cg_JP2ResetSource((void *)this + 55);
  }
  LogError("decodeJP2Prog", 1730, "globalInfo is NULL\n");
  return 2;
}

void JP2ReadPlugin::fixPremultipliedData(JP2ReadPlugin *this, CGRect a2, unsigned __int8 *a3)
{
  uint64_t v3 = *((void *)this + 66);
  if ((v3 | 2) == 3)
  {
    uint64_t v5 = *((void *)this + 70);
    if ((v5 & 0xE0000000) == 0)
    {
      double height = a2.size.height;
      double width = a2.size.width;
      unint64_t v9 = *((unsigned __int16 *)this + 121);
      BOOL v10 = malloc_type_calloc((8 * v5), 1uLL, 0xBF0D5265uLL);
      if (v10)
      {
        unint64_t v11 = *((void *)this + 70);
        if (v11)
        {
          uint64_t v12 = *((void *)this + 69) >> 3;
          uint64_t v13 = *((void *)this + 70);
          uint64_t v14 = v10;
          do
          {
            *v14++ = a3;
            a3 += v12;
            --v13;
          }
          while (v13);
        }
        if (width * height > 0.0)
        {
          int v15 = 0;
          unint64_t v16 = v11;
          do
          {
            if (v16)
            {
              unint64_t v17 = 0;
              unsigned int v18 = *(unsigned __int8 *)v10[v3];
              do
              {
                uint64_t v19 = (unsigned char *)v10[v17];
                if (v18 < *v19)
                {
                  *uint64_t v19 = v18;
                  uint64_t v19 = (unsigned char *)v10[v17];
                  unint64_t v11 = *((void *)this + 70);
                }
                v10[v17++] = &v19[v9 >> 3];
                unint64_t v16 = v11;
              }
              while (v11 > v17);
            }
            ++v15;
          }
          while (width * height > (double)v15);
        }
        free(v10);
      }
    }
  }
}

void JP2ReadPlugin::decodeBlocks(uint64_t a1)
{
  uint64_t v2 = (IIOImageRead *)IIO_Reader::testHeaderSize(*(IIO_Reader **)(a1 + 24));
  memset(v22, 0, sizeof(v22));
  IIOImageReadSession::IIOImageReadSession((IIOImageReadSession *)v22, v2);
  long long v3 = *(_OWORD *)(a1 + 616);
  long long v19 = *(_OWORD *)(a1 + 600);
  long long v20 = v3;
  uint64_t v21 = *(void *)(a1 + 632);
  long long v4 = *(_OWORD *)(a1 + 552);
  *(_OWORD *)CFStringRef cf = *(_OWORD *)(a1 + 536);
  long long v16 = v4;
  long long v5 = *(_OWORD *)(a1 + 584);
  long long v17 = *(_OWORD *)(a1 + 568);
  long long v18 = v5;
  long long v6 = *(_OWORD *)(a1 + 488);
  long long v11 = *(_OWORD *)(a1 + 472);
  long long v12 = v6;
  long long v7 = *(_OWORD *)(a1 + 520);
  long long v13 = *(_OWORD *)(a1 + 504);
  long long v14 = v7;
  long long v8 = *(_OWORD *)(a1 + 456);
  v9[1] = *(void *)(a1 + 448);
  long long v10 = v8;
  v9[0] = v22;
  if (IIO_XPCServer())
  {
    *((void *)&v10 + 1) = MyRead;
    *(void *)&long long v11 = MySeek;
    *((void *)&v11 + 1) = 0;
  }
  cf[0] = 0;
  _cg_JP2SetupDecompressor((uint64_t)v9, (uint64_t)v9);
}

void sub_188761BFC(_Unwind_Exception *a1)
{
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)(v1 - 112));
  _Unwind_Resume(a1);
}

uint64_t JP2ReadPlugin::decodeImageImpProgressive(IIOReadPlugin *this, IIODecodeParameter *a2, int a3)
{
  memory_object_size_t v88 = 0;
  *((_WORD *)this + 158) = *((void *)this + 76);
  if ((gIIODebugFlags & 0x20000) == 0) {
    goto LABEL_26;
  }
  int v6 = *((_DWORD *)this + 51);
  unsigned int v7 = v6 >> 24;
  uint64_t v8 = MEMORY[0x1E4F14390];
  if (v6 < 0)
  {
    int v9 = __maskrune(v7, 0x40000uLL);
    int v6 = *((_DWORD *)this + 51);
  }
  else
  {
    int v9 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v7 + 60) & 0x40000;
  }
  if (v9) {
    uint64_t v10 = (v6 >> 24);
  }
  else {
    uint64_t v10 = 46;
  }
  unsigned int v11 = v6 << 8 >> 24;
  if (v6 << 8 < 0)
  {
    int v12 = __maskrune(v11, 0x40000uLL);
    int v6 = *((_DWORD *)this + 51);
  }
  else
  {
    int v12 = *(_DWORD *)(v8 + 4 * v11 + 60) & 0x40000;
  }
  if (v12) {
    uint64_t v13 = (v6 << 8 >> 24);
  }
  else {
    uint64_t v13 = 46;
  }
  unsigned int v14 = (__int16)v6 >> 8;
  if (v6 << 16 < 0)
  {
    int v15 = __maskrune(v14, 0x40000uLL);
    int v6 = *((_DWORD *)this + 51);
  }
  else
  {
    int v15 = *(_DWORD *)(v8 + 4 * v14 + 60) & 0x40000;
  }
  if (v15) {
    uint64_t v16 = ((__int16)v6 >> 8);
  }
  else {
    uint64_t v16 = 46;
  }
  if ((v6 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v8 + 4 * (char)v6 + 60) & 0x40000) != 0) {
      goto LABEL_22;
    }
LABEL_24:
    LOBYTE(v17) = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v6, 0x40000uLL)) {
    goto LABEL_24;
  }
LABEL_22:
  int v17 = *((_DWORD *)this + 51);
LABEL_25:
  ImageIOLog("  '%c%c%c%c' [%s] %s\n", v10, v13, v16, (char)v17, iioTypeStr[a3], "OSStatus JP2ReadPlugin::decodeImageImpProgressive(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  uint64_t v18 = *((void *)this + 63);
  unsigned int v19 = *((_DWORD *)this + 128);
  *((_DWORD *)this + 73) = v18;
  *((_DWORD *)this + 74) = v19;
  double v20 = *((double *)a2 + 3);
  double v21 = *((double *)a2 + 4);
  int v22 = (int)(v20 / (double)v18);
  int v23 = (int)(v21 / (double)v19);
  int v24 = (int)((v20 + *((double *)a2 + 5) + (double)v18 + -1.0) / (double)v18);
  int v78 = (int)((v21 + *((double *)a2 + 6) + (double)v19 + -1.0) / (double)v19);
  size_t v25 = ((v78 - v23) * (v24 - v22));
  *((_DWORD *)this + 26) = v25;
  unsigned int BlockArray = IIOReadPlugin::allocateBlockArray(this, v25);
  uint64_t v27 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1246769696);
  if (!v27) {
    return 4294967246;
  }
  CFStringRef v28 = v27;
  CFRange v29 = (void *)*((void *)v27 + 1);
  size_t v30 = *((unsigned int *)this + 26);
  unsigned int v76 = BlockArray;
  if (v29)
  {
    if (v30 > *((_DWORD *)v28 + 1))
    {
      free(v29);
      *((void *)v28 + 1) = malloc_type_calloc(4uLL, *((unsigned int *)this + 26), 0x2FB63F98uLL);
    }
  }
  else
  {
    *((void *)v28 + 1) = malloc_type_calloc(4uLL, v30, 0x19F13AF4uLL);
    *((_DWORD *)v28 + 1) = *((_DWORD *)this + 26);
  }
  char v85 = 0;
  unsigned int v86 = 0;
  float32x4_t v87 = 0;
  if (v78 <= v23) {
LABEL_73:
  }
    JP2ReadPlugin::decodeBlocks((uint64_t)this);
  uint64_t v32 = 0;
  CFStringRef v33 = (CGRect *)MEMORY[0x1E4F1DB20];
  int v77 = v22;
  while (v24 <= v22)
  {
    uint64_t v44 = v32;
LABEL_72:
    ++v23;
    uint64_t v32 = v44;
    int v22 = v77;
    if (v23 == v78) {
      goto LABEL_73;
    }
  }
  int v34 = v22;
  while (1)
  {
    unsigned int v35 = *((_DWORD *)this + 73);
    double x = (double)(v35 * v34);
    unsigned int v37 = *((_DWORD *)this + 74);
    double y = (double)(v37 * v23);
    unint64_t v39 = *((void *)this + 64);
    double v40 = (double)*((unint64_t *)this + 63);
    if ((double)v35 + x <= v40) {
      double width = (double)v35;
    }
    else {
      double width = v40 - x;
    }
    if ((double)v37 + y <= (double)v39) {
      double height = (double)v37;
    }
    else {
      double height = (double)v39 - y;
    }
    double v43 = width * (double)(*((unsigned __int16 *)this + 121) >> 3);
    *((_DWORD *)this + 75) = (unint64_t)v43;
    uint64_t v44 = (v32 + 1);
    *((_DWORD *)this + 28) = v32;
    *((_DWORD *)this + 29) = v44;
    int CachedTile = IIOReadPlugin::getCachedTile(this, v43);
    int v46 = CachedTile;
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("     numberOfBlocksLeftToDecode: %d\n", CachedTile);
    }
    if (!v46) {
      goto LABEL_67;
    }
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("JP2: Decoding blockArrayIndex: %d, blockIndex: %d  = (%d, %d)\n", v32, v34 + v23 * ((v18 + (unint64_t)v18 - 1) / v18), v34, v23);
    }
    if (!is_mul_ok((unint64_t)height, *((unsigned int *)this + 75))) {
      break;
    }
    memory_object_offset_t v47 = _ImageIO_Malloc((unint64_t)height * *((unsigned int *)this + 75), *((void *)this + 48), &v88, (uint64_t)kImageMalloc_JP2_Data[0], *((_DWORD *)this + 108), 0, 0);
    if (!v47) {
      break;
    }
    *((unsigned char *)this + 618) = 1;
    uint64_t v48 = *((unsigned int *)this + 75);
    *(void *)&long long v79 = (int)v32;
    *((double *)&v79 + 1) = x;
    *(double *)&long long v80 = y;
    *((double *)&v80 + 1) = width;
    *(double *)&long long v81 = height;
    *((void *)&v81 + 1) = v47;
    *(void *)&long long v82 = v48;
    *((void *)&v82 + 1) = v88;
    long long v83 = 0uLL;
    uint64_t v84 = 0;
    BOOL v49 = v86;
    if (v86 >= v87)
    {
      unint64_t v55 = v85;
      uint64_t v56 = 0x2E8BA2E8BA2E8BA3 * ((v86 - v85) >> 3);
      unint64_t v57 = v56 + 1;
      if ((unint64_t)(v56 + 1) > 0x2E8BA2E8BA2E8BALL) {
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      }
      if (0x5D1745D1745D1746 * ((v87 - v85) >> 3) > v57) {
        unint64_t v57 = 0x5D1745D1745D1746 * ((v87 - v85) >> 3);
      }
      if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((v87 - v85) >> 3)) >= 0x1745D1745D1745DLL) {
        unint64_t v58 = 0x2E8BA2E8BA2E8BALL;
      }
      else {
        unint64_t v58 = v57;
      }
      v89[4] = &v87;
      if (v58)
      {
        int v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIODecodeFrameParams>>((uint64_t)&v87, v58);
        unint64_t v55 = v85;
        BOOL v49 = v86;
      }
      else
      {
        int v59 = 0;
      }
      unsigned int v60 = &v59[88 * v56];
      long long v61 = v80;
      *(_OWORD *)unsigned int v60 = v79;
      *((_OWORD *)v60 + 1) = v61;
      long long v62 = v81;
      long long v63 = v82;
      long long v64 = v83;
      *((void *)v60 + 10) = v84;
      *((_OWORD *)v60 + 3) = v63;
      *((_OWORD *)v60 + 4) = v64;
      *((_OWORD *)v60 + 2) = v62;
      if (v49 == (_OWORD *)v55)
      {
        int v67 = &v59[88 * v56];
      }
      else
      {
        int v65 = v49;
        int v66 = &v59[88 * v56];
        do
        {
          int v67 = v66 - 88;
          long long v68 = *(_OWORD *)((char *)v65 - 88);
          *(_OWORD *)(v66 - 72) = *(_OWORD *)((char *)v65 - 72);
          *(_OWORD *)(v66 - 88) = v68;
          long long v69 = *(_OWORD *)((char *)v65 - 56);
          long long v70 = *(_OWORD *)((char *)v65 - 40);
          long long v71 = *(_OWORD *)((char *)v65 - 24);
          *((void *)v66 - 1) = *((void *)v65 - 1);
          *(_OWORD *)(v66 - 24) = v71;
          *(_OWORD *)(v66 - 40) = v70;
          *(_OWORD *)(v66 - 56) = v69;
          int v65 = (_OWORD *)((char *)v65 - 88);
          v66 -= 88;
        }
        while (v65 != (_OWORD *)v55);
      }
      uint64_t v54 = v60 + 88;
      char v85 = v67;
      unsigned int v86 = v60 + 88;
      CFComparisonResult v72 = v87;
      float32x4_t v87 = &v59[88 * v58];
      v89[2] = v49;
      v89[3] = v72;
      v89[0] = v55;
      v89[1] = v55;
      std::__split_buffer<IIODecodeFrameParams>::~__split_buffer((uint64_t)v89);
    }
    else
    {
      long long v50 = v80;
      *(_OWORD *)unsigned int v86 = v79;
      v49[1] = v50;
      long long v51 = v81;
      long long v52 = v82;
      long long v53 = v83;
      *((void *)v49 + 10) = v84;
      v49[3] = v52;
      v49[4] = v53;
      void v49[2] = v51;
      uint64_t v54 = (char *)v49 + 88;
    }
    unsigned int v86 = v54;
    IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)&v79);
LABEL_67:
    if (!CGRectEqualToRect(*(CGRect *)((char *)this + 120), *v33))
    {
      v91.origin.double x = x;
      v91.origin.double y = y;
      v91.size.double width = width;
      v91.size.double height = height;
      CGRect v90 = CGRectUnion(*(CGRect *)((char *)this + 120), v91);
      double x = v90.origin.x;
      double y = v90.origin.y;
      double width = v90.size.width;
      double height = v90.size.height;
    }
    *((double *)this + 15) = x;
    *((double *)this + 16) = y;
    *((double *)this + 17) = width;
    *((double *)this + 18) = height;
    ++v34;
    LODWORD(v32) = v32 + 1;
    if (v34 == v24) {
      goto LABEL_72;
    }
  }
  CFComparisonResult v73 = v85;
  CFComparisonResult v74 = v86;
  while (v73 != v74)
  {
    unint64_t v75 = *((void *)v73 + 5);
    if (v75) {
      _ImageIO_Free(v75, *((void *)v73 + 7));
    }
    v73 += 88;
  }
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("<<< copyImageBlockSetJP2Prog\n");
  }
  *(void *)&long long v79 = &v85;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100]((void ***)&v79);
  return v76;
}

void sub_188762360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void **a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  a18 = (void **)&a29;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](&a18);
  _Unwind_Resume(a1);
}

uint64_t JP2ReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  memory_object_size_t v48 = 0;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v8 = *((_DWORD *)this + 51);
    unsigned int v9 = v8 >> 24;
    uint64_t v10 = MEMORY[0x1E4F14390];
    if (v8 < 0)
    {
      int v11 = __maskrune(v9, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
    }
    if (v11) {
      uint64_t v12 = (v8 >> 24);
    }
    else {
      uint64_t v12 = 46;
    }
    unsigned int v13 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      int v14 = __maskrune(v13, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    }
    if (v14) {
      uint64_t v15 = (v8 << 8 >> 24);
    }
    else {
      uint64_t v15 = 46;
    }
    unsigned int v16 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      int v17 = __maskrune(v16, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = ((__int16)v8 >> 8);
    }
    else {
      uint64_t v18 = 46;
    }
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0) {
        goto LABEL_22;
      }
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_22:
      int v19 = *((_DWORD *)this + 51);
LABEL_25:
      ImageIOLog("  '%c%c%c%c' [%s] %s\n", v12, v15, v18, (char)v19, iioTypeStr[a3], "virtual OSStatus JP2ReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    LOBYTE(v19) = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  int v20 = *((unsigned __int16 *)this + 153);
  if (v20 == 8)
  {
    if (*((_WORD *)this + 152) == 8)
    {
      int v21 = *((_DWORD *)this + 73);
      goto LABEL_32;
    }
  }
  else if (v20 == 24 && *((_WORD *)this + 152) == 8)
  {
    int v21 = 3 * *((_DWORD *)this + 73);
LABEL_32:
    *((_DWORD *)this + 75) = v21;
  }
  if (!*((unsigned char *)this + 414) || *((unsigned char *)this + 410) == 1 && *((_DWORD *)this + 75) % *((_DWORD *)this + 98)) {
    return 4294967115;
  }
  if (!*((void *)this + 62)) {
    _cg_JP2SetupDecompressor((uint64_t)this + 440, (uint64_t)this + 440);
  }
  *((_WORD *)this + 158) = *((void *)this + 76);
  unsigned int v23 = *((_DWORD *)this + 126);
  unsigned int v24 = *((_DWORD *)this + 128);
  *((_DWORD *)this + 73) = v23;
  *((_DWORD *)this + 74) = v24;
  size_t v25 = (IIOImageRead **)*((void *)this + 3);
  if (v25)
  {
    BOOL v26 = IIOImageReadSession::mapData(v25);
    unsigned int v23 = *((_DWORD *)this + 73);
    unsigned int v24 = *((_DWORD *)this + 74);
  }
  else
  {
    BOOL v26 = 0;
  }
  if (a3 == 3)
  {
    uint64_t BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    unsigned int v30 = *((_DWORD *)this + 75);
    if (v30 <= *((_DWORD *)this + 59)) {
      unsigned int v30 = *((_DWORD *)this + 59);
    }
    memory_object_size_t v29 = *((unsigned int *)this + 74) * (unint64_t)v30;
    BaseAddress = (void *)_ImageIO_Malloc(v29, *((void *)this + 48), &v48, (uint64_t)kImageMalloc_JP2_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4) {
      goto LABEL_80;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    size_t Height = IOSurfaceGetHeight(*a4);
    uint64_t BlockArray = 0;
    memory_object_size_t v29 = IOSurfaceGetBytesPerRow(*a4) * Height;
    memory_object_size_t v48 = v29;
  }
  if (!BaseAddress) {
    goto LABEL_81;
  }
  double v31 = (double)v23;
  double v32 = (double)v24;
  memset(BaseAddress, 255, v29);
  int v33 = *((unsigned __int8 *)this + 632);
  if (v33 == 2)
  {
    uint64_t BlockArray = JP2ReadPlugin::decodeImageImpProgressive(this, a2, a3);
LABEL_59:
    if (!BlockArray)
    {
LABEL_78:
      if (a3 == 3)
      {
        uint64_t v42 = 0;
        v50.origin.double x = 0.0;
        v50.origin.double y = 0.0;
        v50.size.double width = (double)v23;
        v50.size.double height = (double)v24;
        **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v29, v50, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
        if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E4F1DB20]))
        {
          uint64_t v43 = 0;
        }
        else
        {
          v51.origin.double x = 0.0;
          v51.origin.double y = 0.0;
          v51.size.double width = (double)v23;
          v51.size.double height = (double)v24;
          *(CGRect *)(&v43 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v51);
          uint64_t v42 = v44;
          double v31 = v45;
          double v32 = v46;
        }
        uint64_t BlockArray = 0;
        *((void *)this + 15) = v42;
        *((void *)this + 16) = v43;
        *((double *)this + 17) = v31;
        *((double *)this + 18) = v32;
LABEL_81:
        if (!v26) {
          return BlockArray;
        }
        goto LABEL_82;
      }
      IOSurfaceUnlock(*a4, 0, 0);
LABEL_80:
      uint64_t BlockArray = 0;
      goto LABEL_81;
    }
    goto LABEL_60;
  }
  if (v33 != 1) {
    goto LABEL_59;
  }
  v49.origin.double x = 0.0;
  v49.origin.double y = 0.0;
  v49.size.double width = (double)v23;
  v49.size.double height = (double)v24;
  uint64_t BlockArray = JP2ReadPlugin::decodeJP2Block(this, BaseAddress, v49);
  if (!BlockArray)
  {
    int v34 = (void *)((char *)this + 292);
    if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 121) == 24 && *((_DWORD *)this + 81) == 1380401696)
    {
      ImageIOPixelConverter::ExpandRGB888ToARGB8888((ImageIOPixelConverter *)BaseAddress, v29, *((_DWORD *)this + 73), *((_DWORD *)this + 74), *((_DWORD *)this + 75));
    }
    else
    {
      size_t v35 = *((unsigned int *)this + 67);
      unsigned int v36 = *((_DWORD *)this + 75);
      if (v35 != v36) {
        ImageIOPixelConverter::AdjustRowBytes((ImageIOPixelConverter *)BaseAddress, v29, *((_DWORD *)this + 73), *((_DWORD *)this + 74), v35, v36);
      }
    }
    dest.data = BaseAddress;
    v37.i64[0] = *v34;
    v37.i64[1] = HIDWORD(*v34);
    *(int8x16_t *)&dest.double height = vextq_s8(v37, v37, 8uLL);
    dest.size_t rowBytes = *((unsigned int *)this + 75);
    if (*((_WORD *)this + 153) != 32) {
      goto LABEL_76;
    }
    int v38 = *((unsigned __int16 *)this + 152);
    if (*((_WORD *)this + 121) == 24)
    {
      if (v38 != 8) {
        goto LABEL_76;
      }
      if (*((_DWORD *)this + 81) == 1380401696)
      {
        if (!*((unsigned char *)this + 405)) {
          goto LABEL_76;
        }
        unint64_t v39 = (const uint8_t *)&JP2ReadPlugin::decodeImageImp(IIODecodeParameter *,IIOImageType,__IOSurface **,__CVBuffer **,CGImageBlockSet **)::permuteMap;
        goto LABEL_75;
      }
    }
    else if (v38 != 8)
    {
      goto LABEL_76;
    }
    if (*((_DWORD *)this + 100) != 1111970392) {
      goto LABEL_76;
    }
    unint64_t v39 = (const uint8_t *)&JP2ReadPlugin::decodeImageImp(IIODecodeParameter *,IIOImageType,__IOSurface **,__CVBuffer **,CGImageBlockSet **)::permuteMap;
LABEL_75:
    vImagePermuteChannels_ARGB8888(&dest, &dest, v39, 0x10u);
LABEL_76:
    if (*((unsigned char *)this + 406) == 1) {
      vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
    }
    goto LABEL_78;
  }
LABEL_60:
  *((_DWORD *)this + 26) = 0;
  if (a3 == 3)
  {
    _ImageIO_Free((unint64_t)BaseAddress, v48);
    goto LABEL_81;
  }
  if (!v26) {
    return BlockArray;
  }
LABEL_82:
  double v40 = (const char **)*((void *)this + 3);
  if (v40) {
    IIOImageReadSession::unmapData(v40);
  }
  return BlockArray;
}

void _TIFFFax3fillruns(uint64_t a1, unsigned int *a2, unsigned int *a3, unsigned int a4)
{
  long long v5 = a3;
  int v6 = a2;
  if (((a3 - a2) & 4) != 0)
  {
    *a3 = 0;
    long long v5 = a3 + 1;
  }
  if (v5 > a2)
  {
    unsigned int v8 = 0;
    while (1)
    {
      unsigned int v9 = *v6;
      if (*v6 > a4 || *v6 + v8 > a4)
      {
        unsigned int v9 = a4 - v8;
        *int v6 = a4 - v8;
      }
      if (v9) {
        break;
      }
LABEL_31:
      unsigned int v20 = v6[1];
      if (v20 > a4 || v20 + v8 > a4)
      {
        unsigned int v20 = a4 - v8;
        v6[1] = a4 - v8;
      }
      if (!v20) {
        goto LABEL_57;
      }
      int v22 = (unsigned char *)(a1 + (v8 >> 3));
      char v23 = v8 & 7;
      if (v20 <= 8 - (v8 & 7))
      {
        unsigned int v30 = _TIFFFax3fillruns__fillmasks[v20] >> v23;
      }
      else
      {
        if ((v8 & 7) != 0)
        {
          *v22++ |= 0xFFu >> v23;
          v20 -= 8 - (v8 & 7);
        }
        if (v20 >= 8)
        {
          unsigned int v24 = v20 >> 3;
          if (v20 < 0x80) {
            goto LABEL_50;
          }
          if ((v22 & 7) != 0)
          {
            char v25 = v22 ^ 7;
            unint64_t v26 = (v22 ^ 7) & 7;
            unint64_t v27 = v24 - 1;
            if (v26 >= v27) {
              unint64_t v26 = v27;
            }
            unint64_t v28 = v26 + 1;
            memset(v22, 255, v26 + 1);
            v22 += v28;
            if (v27 >= (v25 & 7u)) {
              unsigned int v24 = v27 - (v25 & 7);
            }
            else {
              unsigned int v24 = 0;
            }
          }
          memset(v22, 255, 8 * ((v24 >> 3) - 1) + 8);
          v22 += 8 * (v24 >> 3);
          v24 &= 7u;
          if (v24)
          {
LABEL_50:
            uint64_t v29 = v24;
            memset(v22, 255, v24);
          }
          else
          {
            uint64_t v29 = 0;
          }
          v22 += v29;
          v20 &= 7u;
        }
        if (!v20) {
          goto LABEL_56;
        }
        unsigned int v30 = 0xFF00u >> v20;
      }
      *v22 |= v30;
LABEL_56:
      v8 += v6[1];
LABEL_57:
      v6 += 2;
      if (v6 >= v5) {
        goto LABEL_62;
      }
    }
    int v11 = (unsigned char *)(a1 + (v8 >> 3));
    unsigned int v12 = 8 - (v8 & 7);
    if (v9 <= v12)
    {
      unsigned int v19 = *v11 & ~(_TIFFFax3fillruns__fillmasks[v9] >> (v8 & 7));
    }
    else
    {
      if ((v8 & 7) != 0)
      {
        *v11++ &= -1 << v12;
        v9 -= v12;
      }
      if (v9 >= 8)
      {
        unsigned int v13 = v9 >> 3;
        if (v9 < 0x80) {
          goto LABEL_24;
        }
        if ((v11 & 7) != 0)
        {
          char v14 = v11 ^ 7;
          unint64_t v15 = (v11 ^ 7) & 7;
          unint64_t v16 = v13 - 1;
          if (v15 >= v16) {
            unint64_t v15 = v16;
          }
          unint64_t v17 = v15 + 1;
          bzero(v11, v15 + 1);
          v11 += v17;
          if (v16 >= (v14 & 7u)) {
            unsigned int v13 = v16 - (v14 & 7);
          }
          else {
            unsigned int v13 = 0;
          }
        }
        bzero(v11, 8 * ((v13 >> 3) - 1) + 8);
        v11 += 8 * (v13 >> 3);
        v13 &= 7u;
        if (v13)
        {
LABEL_24:
          uint64_t v18 = v13;
          bzero(v11, v13);
        }
        else
        {
          uint64_t v18 = 0;
        }
        v11 += v18;
        v9 &= 7u;
      }
      if (!v9) {
        goto LABEL_30;
      }
      unsigned int v19 = *v11 & (0xFFu >> v9);
    }
    *int v11 = v19;
LABEL_30:
    v8 += *v6;
    goto LABEL_31;
  }
  unsigned int v8 = 0;
LABEL_62:
  if (v8 != a4) {
    _TIFFFax3fillruns_cold_1();
  }
}

uint64_t TIFFInitCCITTFax3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!InitCCITTFax3(a1, a2, a3, a4, a5, a6, a7, a8)) {
    return 1;
  }
  if (_TIFFMergeFields(a1, fax3Fields, 1, v9, v10, v11, v12, v13)) {
    return _cg_TIFFSetField(a1, 0x10000, v14, v15, v16, v17, v18, v19, 1);
  }
  TIFFErrorExtR(a1, "TIFFInitCCITTFax3", "Merging CCITT Fax 3 codec-specific tags failed", v15, v16, v17, v18, v19, v21);
  return 0;
}

uint64_t InitCCITTFax3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!_TIFFMergeFields(a1, faxFields, 5, a4, a5, a6, a7, a8))
  {
    unint64_t v26 = "Merging common CCITT Fax codec-specific tags failed";
LABEL_8:
    TIFFErrorExtR(a1, "InitCCITTFax3", v26, v10, v11, v12, v13, v14, v27);
    return 0;
  }
  uint64_t v15 = _TIFFmallocExt((void *)a1, 160, v9, v10, v11, v12, v13, v14);
  *(void *)(a1 + 1096) = v15;
  if (!v15)
  {
    unint64_t v26 = "No space for state block";
    goto LABEL_8;
  }
  _TIFFmemset(v15, 0, 0xA0uLL);
  uint64_t v22 = *(void *)(a1 + 1096);
  int v23 = *(_DWORD *)(a1 + 12);
  *(_DWORD *)uint64_t v22 = v23;
  int8x16_t v24 = *(int8x16_t *)(a1 + 1280);
  *(void *)(a1 + 1288) = Fax3VGetField;
  *(int8x16_t *)(v22 + 40) = vextq_s8(v24, v24, 8uLL);
  *(void *)(a1 + 1280) = Fax3VSetField;
  *(void *)(v22 + 56) = *(void *)(a1 + 1296);
  *(void *)(a1 + 1296) = Fax3PrintDir;
  *(_DWORD *)(v22 + 32) = 0;
  if (!v23) {
    *(_DWORD *)(a1 + 16) |= 0x100u;
  }
  *(void *)(v22 + 96) = 0;
  _cg_TIFFSetField(a1, 65540, v16, v17, v18, v19, v20, v21, (uint64_t)_TIFFFax3fillruns);
  *(void *)(*(void *)(a1 + 1096) + 136) = 0;
  *(void *)(a1 + 952) = Fax3FixupTags;
  *(void *)(a1 + 960) = Fax3SetupState;
  *(void *)(a1 + 968) = Fax3PreDecode;
  *(void *)(a1 + 1008) = Fax3Decode1D;
  *(void *)(a1 + 1024) = Fax3Decode1D;
  *(void *)(a1 + 1040) = Fax3Decode1D;
  *(void *)(a1 + 976) = Fax3SetupState;
  *(void *)(a1 + 992) = Fax3PreEncode;
  *(void *)(a1 + 1000) = Fax3PostEncode;
  *(void *)(a1 + 1016) = Fax3Encode;
  *(void *)(a1 + 1032) = Fax3Encode;
  *(void *)(a1 + 1048) = Fax3Encode;
  *(void *)(a1 + 1056) = Fax3Close;
  *(void *)(a1 + 1072) = Fax3Cleanup;
  return 1;
}

uint64_t TIFFInitCCITTFax4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (InitCCITTFax3((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8))
  {
    if (_TIFFMergeFields((uint64_t)a1, fax4Fields, 1, v9, v10, v11, v12, v13))
    {
      a1[126] = Fax4Decode;
      a1[128] = Fax4Decode;
      a1[130] = Fax4Decode;
      a1[127] = Fax4Encode;
      a1[129] = Fax4Encode;
      a1[131] = Fax4Encode;
      a1[125] = Fax4PostEncode;
      return _cg_TIFFSetField((uint64_t)a1, 0x10000, v14, v15, v16, v17, v18, v19, 1);
    }
    TIFFErrorExtR((uint64_t)a1, "TIFFInitCCITTFax4", "Merging CCITT Fax 4 codec-specific tags failed", v15, v16, v17, v18, v19, v21);
  }
  return 0;
}

uint64_t Fax4Decode(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a1;
  uint64_t v9 = a1[137];
  if (a3 % *(void *)(v9 + 8))
  {
    TIFFErrorExtR((uint64_t)a1, "Fax4Decode", "Fractional scanlines cannot be read", a4, a5, a6, a7, a8, v130);
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = (_DWORD *)a3;
  unsigned int v12 = *(_DWORD *)(v9 + 72);
  int v11 = *(_DWORD *)(v9 + 76);
  int v13 = *(_DWORD *)(v9 + 80);
  uint64_t v14 = a1[144];
  uint64_t v15 = a1[145];
  if (a3 < 1)
  {
    int8x16_t v24 = (unsigned __int8 *)a1[144];
    goto LABEL_202;
  }
  unint64_t v16 = v14 + v15;
  uint64_t v17 = &TIFFFaxMainTable;
  uint64_t v18 = *(unsigned int *)(v9 + 16);
  uint64_t v19 = TIFFFaxWhiteTable;
  uint64_t v20 = *(void *)(v9 + 64);
  uint64_t v21 = (((int)v18 + 7) >> 3);
  int v23 = *(unsigned int **)(v9 + 112);
  uint64_t v22 = *(void *)(v9 + 120);
  int8x16_t v24 = (unsigned __int8 *)a1[144];
  uint64_t v140 = v20;
  unint64_t v141 = v16;
  uint64_t v139 = v18;
LABEL_5:
  uint64_t v142 = a2;
  if ((int)v18 < 1)
  {
    LODWORD(v29) = 0;
    double v32 = (_DWORD *)v22;
    goto LABEL_149;
  }
  uint64_t v25 = v21;
  int v26 = v13;
  int v27 = 0;
  int i = 0;
  uint64_t v29 = 0;
  double v31 = v23 + 1;
  uint64_t v30 = *v23;
  double v32 = (_DWORD *)v22;
LABEL_7:
  uint64_t v33 = *(unsigned int *)(v9 + 104);
  if ((unint64_t)v32 >= v22 + 4 * v33) {
    goto LABEL_210;
  }
  if (v11 <= 6)
  {
    if ((unint64_t)v24 >= v16)
    {
      if (!v11)
      {
LABEL_203:
        unint64_t v118 = v22;
        LODWORD(v113) = v10;
LABEL_204:
        int v119 = v25;
        int v67 = v32;
        goto LABEL_206;
      }
      int v11 = 7;
    }
    else
    {
      unsigned int v34 = *v24++;
      v12 |= *(unsigned __int8 *)(v20 + v34) << v11;
      v11 += 8;
    }
  }
  uint64_t v35 = v12 & 0x7F;
  int v36 = *((unsigned __int8 *)&TIFFFaxMainTable + 8 * v35 + 1);
  v11 -= v36;
  v12 >>= v36;
  switch(8 * v35)
  {
    case 0:
    case 0x400:
    case 0x424:
      *v32++ = v18 - v29;
      uint64_t v113 = v10;
      if (v11 > 3)
      {
        uint64_t v114 = v25;
        int v67 = v32;
      }
      else if ((unint64_t)v24 >= v16)
      {
        if (!v11)
        {
          unint64_t v118 = v22;
          goto LABEL_204;
        }
        uint64_t v114 = v25;
        int v67 = v32;
        int v11 = 4;
      }
      else
      {
        uint64_t v114 = v25;
        int v67 = v32;
        unsigned int v115 = *v24++;
        v12 |= *(unsigned __int8 *)(v20 + v115) << v11;
        v11 += 8;
      }
      if ((v12 & 0xF) != 0)
      {
        uint64_t v116 = v22;
        Fax3Unexpected("Fax4Decode", (uint64_t)a1, *(_DWORD *)(v9 + 152), v29, v16, v22, (uint64_t)&TIFFFaxMainTable, (uint64_t)TIFFFaxWhiteTable);
        uint64_t v22 = v116;
      }
      v11 -= 4;
      v12 >>= 4;
      int v13 = 1;
      uint64_t v21 = v114;
      uint64_t v10 = v113;
      goto LABEL_144;
    case 8:
    case 0x11:
    case 0x18:
    case 0x21:
    case 0x28:
    case 0x31:
    case 0x38:
    case 0x48:
    case 0x51:
    case 0x58:
    case 0x61:
    case 0x68:
    case 0x71:
    case 0x78:
    case 0x88:
    case 0x91:
    case 0x98:
    case 0xA1:
    case 0xA8:
    case 0xB1:
    case 0xB8:
    case 0xC8:
    case 0xD1:
    case 0xD8:
    case 0xE1:
    case 0xE8:
    case 0xF1:
    case 0xF8:
    case 0x104:
    case 0x108:
    case 0x111:
    case 0x118:
    case 0x121:
    case 0x128:
    case 0x131:
    case 0x138:
    case 0x148:
    case 0x151:
    case 0x158:
    case 0x161:
    case 0x168:
    case 0x171:
    case 0x178:
    case 0x188:
    case 0x191:
    case 0x198:
    case 0x1A1:
    case 0x1A8:
    case 0x1B1:
    case 0x1B8:
    case 0x1C8:
    case 0x1D1:
    case 0x1D8:
    case 0x1E1:
    case 0x1E8:
    case 0x1F1:
    case 0x1F8:
    case 0x208:
    case 0x211:
    case 0x218:
    case 0x221:
    case 0x228:
    case 0x231:
    case 0x238:
    case 0x248:
    case 0x251:
    case 0x258:
    case 0x261:
    case 0x268:
    case 0x271:
    case 0x278:
    case 0x288:
    case 0x291:
    case 0x298:
    case 0x2A1:
    case 0x2A8:
    case 0x2B1:
    case 0x2B8:
    case 0x2C8:
    case 0x2D1:
    case 0x2D8:
    case 0x2E1:
    case 0x2E8:
    case 0x2F1:
    case 0x2F8:
    case 0x304:
    case 0x308:
    case 0x311:
    case 0x318:
    case 0x321:
    case 0x328:
    case 0x331:
    case 0x338:
    case 0x348:
    case 0x351:
    case 0x358:
    case 0x361:
    case 0x368:
    case 0x371:
    case 0x378:
    case 0x388:
    case 0x391:
    case 0x398:
    case 0x3A1:
    case 0x3A8:
    case 0x3B1:
    case 0x3B8:
    case 0x3C8:
    case 0x3D1:
    case 0x3D8:
    case 0x3E1:
    case 0x3E8:
    case 0x3F1:
    case 0x3F8:
    case 0x40CLL:
      if (v32 == (_DWORD *)v22 || (int)v30 > (int)v29) {
        goto LABEL_57;
      }
      long long v53 = &v23[v33];
      uint64_t v54 = v31 + 1;
      do
      {
        if (v54 >= v53) {
          goto LABEL_210;
        }
        uint64_t v30 = *(v54 - 1) + v30 + *v54;
        v54 += 2;
      }
      while ((int)v30 <= (int)v29);
      double v31 = v54 - 1;
LABEL_57:
      *double v32 = i + v27 + v30;
      if (v31 >= &v23[*(unsigned int *)(v9 + 104)]) {
        goto LABEL_210;
      }
      int i = 0;
      ++v32;
      int v56 = *v31++;
      int v55 = v56;
      uint64_t v29 = v30;
      goto LABEL_67;
    case 9:
    case 0x14:
    case 0x19:
    case 0x29:
    case 0x34:
    case 0x39:
    case 0x40:
    case 0x49:
    case 0x54:
    case 0x59:
    case 0x69:
    case 0x74:
    case 0x79:
    case 0x89:
    case 0x94:
    case 0x99:
    case 0xA9:
    case 0xB4:
    case 0xB9:
    case 0xC0:
    case 0xC9:
    case 0xD4:
    case 0xD9:
    case 0xE9:
    case 0xF4:
    case 0xF9:
    case 0x109:
    case 0x114:
    case 0x119:
    case 0x129:
    case 0x134:
    case 0x139:
    case 0x140:
    case 0x149:
    case 0x154:
    case 0x159:
    case 0x169:
    case 0x174:
    case 0x179:
    case 0x189:
    case 0x194:
    case 0x199:
    case 0x1A9:
    case 0x1B4:
    case 0x1B9:
    case 0x1C0:
    case 0x1C9:
    case 0x1D4:
    case 0x1D9:
    case 0x1E9:
    case 0x1F4:
    case 0x1F9:
    case 0x209:
    case 0x214:
    case 0x219:
    case 0x229:
    case 0x234:
    case 0x239:
    case 0x240:
    case 0x249:
    case 0x254:
    case 0x259:
    case 0x269:
    case 0x274:
    case 0x279:
    case 0x289:
    case 0x294:
    case 0x299:
    case 0x2A9:
    case 0x2B4:
    case 0x2B9:
    case 0x2C0:
    case 0x2C9:
    case 0x2D4:
    case 0x2D9:
    case 0x2E9:
    case 0x2F4:
    case 0x2F9:
    case 0x309:
    case 0x314:
    case 0x319:
    case 0x329:
    case 0x334:
    case 0x339:
    case 0x340:
    case 0x349:
    case 0x354:
    case 0x359:
    case 0x369:
    case 0x374:
    case 0x379:
    case 0x389:
    case 0x394:
    case 0x399:
    case 0x3A9:
    case 0x3B4:
    case 0x3B9:
    case 0x3C0:
    case 0x3C9:
    case 0x3D4:
    case 0x3D9:
    case 0x3E9:
    case 0x3F4:
    case 0x3F9:
      if (v32 == (_DWORD *)v22 || (int)v30 > (int)v29) {
        goto LABEL_20;
      }
      int8x16_t v37 = v31 + 1;
      do
      {
        if (v37 >= &v23[v33]) {
          goto LABEL_210;
        }
        LODWORD(v30) = *(v37 - 1) + v30 + *v37;
        v37 += 2;
      }
      while ((int)v30 <= (int)v29);
      double v31 = v37 - 1;
LABEL_20:
      if (v31 + 1 >= &v23[v33]) {
        goto LABEL_210;
      }
      unsigned int v38 = *v31;
      unsigned int v39 = v31[1];
      v31 += 2;
      uint64_t v29 = v38 + v30;
      i += v27 + v29;
      uint64_t v30 = v29 + v39;
      goto LABEL_77;
    case 0x10:
    case 0x50:
    case 0x80:
    case 0x90:
    case 0xD0:
    case 0x100:
    case 0x110:
    case 0x150:
    case 0x190:
    case 0x1D0:
    case 0x210:
    case 0x250:
    case 0x280:
    case 0x290:
    case 0x2D0:
    case 0x310:
    case 0x350:
    case 0x390:
    case 0x3D0:
    case 0x411:
    case 0x41CLL:
    case 0x429:
      if (v32 == (_DWORD *)v22 || (int)v30 > (int)v29) {
        goto LABEL_74;
      }
      long long v61 = &v23[v33];
      long long v62 = v31 + 1;
      do
      {
        if (v62 >= v61) {
          goto LABEL_210;
        }
        LODWORD(v30) = *(v62 - 1) + v30 + *v62;
        v62 += 2;
      }
      while ((int)v30 <= (int)v29);
      double v31 = v62 - 1;
LABEL_74:
      int v63 = *((_DWORD *)&TIFFFaxMainTable + 2 * v35 + 1);
      if ((int)v30 >= v63 + (int)v29)
      {
        int v64 = v30 + v27 - v63;
        *v32++ = v64 + i;
        uint64_t v29 = (v64 + v29);
        int v65 = *--v31;
        uint64_t v30 = (v30 - v65);
        goto LABEL_76;
      }
      int v67 = v32;
      unsigned int v136 = v25;
      int v133 = v26;
      uint64_t v111 = v22;
      Fax3Unexpected("Fax4Decode", (uint64_t)a1, *(_DWORD *)(v9 + 152), v29, v16, v22, (uint64_t)&TIFFFaxMainTable, (uint64_t)TIFFFaxWhiteTable);
LABEL_186:
      uint64_t v22 = v111;
      int v13 = v133;
      uint64_t v21 = v136;
      goto LABEL_144;
    case 0x20:
    case 0x60:
    case 0x84:
    case 0xA0:
    case 0xE0:
    case 0x120:
    case 0x160:
    case 0x184:
    case 0x1A0:
    case 0x1E0:
    case 0x220:
    case 0x260:
    case 0x284:
    case 0x2A0:
    case 0x2E0:
    case 0x320:
    case 0x360:
    case 0x384:
    case 0x3A0:
    case 0x3E0:
      if (((v32 - v22) & 4) != 0)
      {
        while (1)
        {
          if (v11 > 12) {
            goto LABEL_49;
          }
          if ((unint64_t)v24 >= v16)
          {
            if (!v11) {
              goto LABEL_203;
            }
            int v11 = 13;
          }
          else
          {
            v12 |= *(unsigned __int8 *)(v20 + *v24) << v11;
            if (v11 > 4)
            {
              v11 += 8;
            }
            else
            {
              if ((unint64_t)(v24 + 1) < v16)
              {
                uint64_t v47 = v24[1];
                v24 += 2;
                v12 |= *(unsigned __int8 *)(v20 + v47) << (v11 + 8);
                v11 += 16;
                goto LABEL_49;
              }
              int v11 = 13;
            }
            ++v24;
          }
LABEL_49:
          uint64_t v48 = v12 & 0x1FFF;
          CGRect v49 = (unsigned __int8 *)&TIFFFaxBlackTable[2 * v48];
          int v50 = v49[1];
          v11 -= v50;
          v12 >>= v50;
          int v51 = *v49;
          if ((v51 - 10) >= 2)
          {
            if (v51 != 8)
            {
              uint64_t v87 = v22;
              memory_object_size_t v88 = v10;
              uint64_t v89 = v25;
              int v67 = v32;
LABEL_140:
              int v131 = v26;
              uint64_t v91 = (uint64_t)a1;
LABEL_143:
              TIFFErrorExtR(v91, "Fax4Decode", "Bad code word at line %u of %s %u (x %u)", v18, v16, v22, (uint64_t)&TIFFFaxMainTable, (uint64_t)TIFFFaxWhiteTable, *(_DWORD *)(v9 + 152));
              int v13 = v131;
              uint64_t v21 = v89;
              uint64_t v10 = v88;
              uint64_t v22 = v87;
              goto LABEL_144;
            }
            int v74 = TIFFFaxBlackTable[2 * v48 + 1];
            *double v32 = v74 + i;
            int v67 = v32 + 1;
            uint64_t v29 = (v74 + v29);
            int i = 0;
            while (2)
            {
              if (v11 > 11) {
                goto LABEL_105;
              }
              if ((unint64_t)v24 >= v16)
              {
                if (v11)
                {
                  int v11 = 12;
                  goto LABEL_105;
                }
LABEL_205:
                unint64_t v118 = v22;
                LODWORD(v113) = v10;
                int v119 = v25;
LABEL_206:
                int v120 = v26;
                goto LABEL_207;
              }
              v12 |= *(unsigned __int8 *)(v20 + *v24) << v11;
              if (v11 > 3)
              {
                v11 += 8;
              }
              else
              {
                if ((unint64_t)(v24 + 1) < v16)
                {
                  uint64_t v75 = v24[1];
                  v24 += 2;
                  v12 |= *(unsigned __int8 *)(v20 + v75) << (v11 + 8);
                  v11 += 16;
                  goto LABEL_105;
                }
                int v11 = 12;
              }
              ++v24;
LABEL_105:
              uint64_t v76 = v12 & 0xFFF;
              int v77 = (unsigned __int8 *)&TIFFFaxWhiteTable[2 * v76];
              int v78 = v77[1];
              v11 -= v78;
              v12 >>= v78;
              int v79 = *v77;
              if (v79 == 9 || v79 == 11)
              {
                int v81 = TIFFFaxWhiteTable[2 * v76 + 1];
                uint64_t v29 = (v81 + v29);
                i += v81;
                continue;
              }
              break;
            }
            if (v79 != 7)
            {
              uint64_t v87 = v22;
              memory_object_size_t v88 = v10;
              uint64_t v89 = v25;
              goto LABEL_142;
            }
            if ((unint64_t)v67 >= v22 + 4 * (unint64_t)*(unsigned int *)(v9 + 104)) {
              goto LABEL_210;
            }
            long long v82 = (char *)&TIFFFaxWhiteTable[2 * v76];
LABEL_117:
            int v83 = *((_DWORD *)v82 + 1);
            *int v67 = v83 + i;
            uint64_t v29 = (v83 + v29);
            v32 += 2;
            if (v32 != (_DWORD *)v22)
            {
              if ((int)v30 <= (int)v29 && (int)v30 < (int)v18)
              {
                char v85 = v31 + 1;
                while (v85 < &v23[*(unsigned int *)(v9 + 104)])
                {
                  uint64_t v30 = *(v85 - 1) + v30 + *v85;
                  v85 += 2;
                  if ((int)v30 > (int)v29 || (int)v30 >= (int)v18)
                  {
                    int i = 0;
                    double v31 = v85 - 1;
                    goto LABEL_77;
                  }
                }
                uint64_t v121 = a1[150];
                goto LABEL_211;
              }
LABEL_76:
              int i = 0;
              goto LABEL_77;
            }
            int i = 0;
            double v32 = (_DWORD *)v22;
LABEL_77:
            int v27 = -(int)v29;
            if ((int)v29 >= (int)v18)
            {
              if (!i)
              {
                unsigned int v8 = a1;
                int v13 = v26;
                uint64_t v21 = v25;
                goto LABEL_149;
              }
              int v13 = v26;
              uint64_t v21 = v25;
              if (i + (int)v29 >= (int)v18) {
                goto LABEL_199;
              }
              if (v11 > 0) {
                goto LABEL_195;
              }
              if ((unint64_t)v24 < v16)
              {
                unsigned int v90 = *v24++;
                v12 |= *(unsigned __int8 *)(v20 + v90) << v11;
                v11 += 8;
                goto LABEL_195;
              }
              if (v11)
              {
                int v11 = 1;
LABEL_195:
                if ((v12 & 1) == 0)
                {
                  uint64_t v112 = v22;
                  int v67 = v32;
                  unsigned int v137 = v25;
                  int v134 = v26;
LABEL_197:
                  Fax3Unexpected("Fax4Decode", (uint64_t)a1, *(_DWORD *)(v9 + 152), v29, v16, v22, (uint64_t)&TIFFFaxMainTable, (uint64_t)TIFFFaxWhiteTable);
                  int v13 = v134;
                  uint64_t v21 = v137;
                  uint64_t v22 = v112;
LABEL_144:
                  if (i)
                  {
                    uint64_t v20 = v140;
                    unint64_t v16 = v141;
                    if ((unint64_t)v67 >= v22 + 4 * (unint64_t)*(unsigned int *)(v9 + 104)) {
                      goto LABEL_210;
                    }
                    *int v67 = i;
                    double v32 = v67 + 1;
                    unsigned int v8 = a1;
                  }
                  else
                  {
                    unsigned int v8 = a1;
                    uint64_t v20 = v140;
                    unint64_t v16 = v141;
                    double v32 = v67;
                  }
                  uint64_t v18 = v139;
LABEL_149:
                  if (v29 == v18) {
                    goto LABEL_173;
                  }
                  unint64_t v92 = v22;
                  long long v132 = v10;
                  uint64_t v93 = v32;
                  unsigned int v135 = v21;
                  int v94 = v18;
                  int v95 = v13;
                  uint64_t v96 = "Line length mismatch";
                  if (v29 < v18) {
                    uint64_t v96 = "Premature EOL";
                  }
                  TIFFWarningExtR((uint64_t)v8, "Fax4Decode", "%s at line %u of %s %u (got %u, expected %u)", v18, v16, v22, (uint64_t)v17, (uint64_t)v19, (char)v96);
                  BOOL v97 = (int)v29 > v94;
                  if ((int)v29 <= v94)
                  {
                    int v13 = v95;
                    uint64_t v21 = v135;
                    uint64_t v20 = v140;
                    unint64_t v16 = v141;
                    double v32 = v93;
                    uint64_t v18 = v139;
                    uint64_t v10 = v132;
                    uint64_t v22 = v92;
                  }
                  else
                  {
                    double v32 = v93;
                    uint64_t v22 = v92;
                    if ((unint64_t)v93 <= v92)
                    {
                      int v13 = v95;
                      uint64_t v21 = v135;
                      uint64_t v20 = v140;
                      unint64_t v16 = v141;
                      uint64_t v18 = v139;
                    }
                    else
                    {
                      unsigned int v98 = v93 - 1;
                      CFMutableArrayRef v99 = v93 - 1;
                      int v13 = v95;
                      uint64_t v20 = v140;
                      unint64_t v16 = v141;
                      uint64_t v18 = v139;
                      do
                      {
                        int v100 = *v99--;
                        LODWORD(v29) = v29 - v100;
                        BOOL v97 = (int)v29 > (int)v139;
                        BOOL v101 = (int)v29 > (int)v139 && (unint64_t)v98 > v92;
                        unsigned int v98 = v99;
                      }
                      while (v101);
                      double v32 = v99 + 1;
                      uint64_t v21 = v135;
                    }
                    uint64_t v10 = v132;
                  }
                  if ((int)v29 < (int)v18)
                  {
                    if (((v32 - v22) & 4) == 0) {
                      goto LABEL_167;
                    }
                    if ((unint64_t)v32 < v22 + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
                    {
                      *v32++ = 0;
LABEL_167:
                      if ((unint64_t)v32 < v22 + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
                      {
                        *v32++ = v18 - (v29 & ~((int)v29 >> 31));
                        goto LABEL_173;
                      }
                    }
LABEL_239:
                    uint64_t v121 = v8[150];
                    goto LABEL_211;
                  }
                  if (!v97)
                  {
LABEL_173:
                    uint64_t v102 = v142;
                  }
                  else
                  {
                    uint64_t v102 = v142;
                    if ((unint64_t)v32 >= v22 + 4 * (unint64_t)*(unsigned int *)(v9 + 104)) {
                      goto LABEL_239;
                    }
                    *double v32 = v18;
                    if ((unint64_t)(v32 + 1) >= v22 + 4 * (unint64_t)*(unsigned int *)(v9 + 104)) {
                      goto LABEL_239;
                    }
                    v32[1] = 0;
                    v32 += 2;
                    uint64_t v18 = v139;
                    uint64_t v21 = v135;
                  }
                  if (!v13)
                  {
                    if ((int)v21 <= (int)v10)
                    {
                      uint64_t v103 = v24;
                      uint64_t v104 = v10;
                      uint64_t v105 = v21;
                      unsigned int v106 = v32;
                      uint64_t v107 = v18;
                      uint64_t v108 = v22;
                      uint64_t v109 = v102;
                      (*(void (**)(void))(v9 + 88))();
                      if ((unint64_t)v106 >= v108 + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
                      {
                        uint64_t v121 = a1[150];
                        goto LABEL_211;
                      }
                      int v13 = 0;
                      *unsigned int v106 = 0;
                      uint64_t v22 = *(void *)(v9 + 112);
                      int v23 = *(unsigned int **)(v9 + 120);
                      *(void *)(v9 + 112) = v23;
                      *(void *)(v9 + 120) = v22;
                      uint64_t v110 = *(void *)(v9 + 8);
                      a2 = v109 + v110;
                      ++*(_DWORD *)(v9 + 152);
                      uint64_t v10 = (_DWORD *)((char *)v104 - v110);
                      uint64_t v20 = v140;
                      unint64_t v16 = v141;
                      uint64_t v21 = v105;
                      int8x16_t v24 = v103;
                      uint64_t v17 = &TIFFFaxMainTable;
                      uint64_t v19 = TIFFFaxWhiteTable;
                      uint64_t v18 = v107;
                      unsigned int v8 = a1;
                      if ((uint64_t)v104 <= v110)
                      {
                        int v13 = 0;
                        uint64_t v14 = a1[144];
                        uint64_t v15 = a1[145];
LABEL_202:
                        *(_DWORD *)(v9 + 72) = v12;
                        *(_DWORD *)(v9 + 76) = v11;
                        *(_DWORD *)(v9 + 80) = v13;
                        v8[145] = v14 - (void)v24 + v15;
                        v8[144] = v24;
                        return 1;
                      }
                      goto LABEL_5;
                    }
LABEL_253:
                    TIFFErrorExtR((uint64_t)v8, "Fax4Decode", "Buffer overrun detected : %lld bytes available, %d bits needed", v18, v16, v22, (uint64_t)v17, (uint64_t)v19, (char)v10);
                    return 0xFFFFFFFFLL;
                  }
                  if (v11 > 12) {
                    goto LABEL_252;
                  }
                  goto LABEL_242;
                }
                --v11;
                v12 >>= 1;
LABEL_199:
                if ((unint64_t)v32 >= v22 + 4 * (unint64_t)*(unsigned int *)(v9 + 104)) {
                  goto LABEL_210;
                }
                *v32++ = i;
                unsigned int v8 = a1;
                goto LABEL_149;
              }
              unint64_t v118 = v22;
              LODWORD(v113) = v10;
              int v119 = v25;
              int v67 = v32;
              int v120 = v26;
LABEL_207:
              TIFFWarningExtR((uint64_t)a1, "Fax4Decode", "Premature EOF at line %u of %s %u (x %u)", v18, v16, v22, (uint64_t)&TIFFFaxMainTable, (uint64_t)TIFFFaxWhiteTable, *(_DWORD *)(v9 + 152));
              if (i)
              {
                if ((unint64_t)v67 >= v118 + 4 * *(unsigned int *)(v9 + 104)) {
                  goto LABEL_210;
                }
                int v13 = v120;
                LODWORD(v21) = v119;
                *int v67 = i;
                double v32 = v67 + 1;
              }
              else
              {
                int v13 = v120;
                double v32 = v67;
                LODWORD(v21) = v119;
              }
              uint64_t v18 = v139;
              unsigned int v8 = a1;
              if (v29 == v139)
              {
                int v11 = 0;
                unint64_t v16 = v141;
                uint64_t v102 = v142;
                uint64_t v20 = v140;
                LODWORD(v10) = v113;
                uint64_t v22 = v118;
                goto LABEL_242;
              }
              uint64_t v10 = v32;
              int v138 = v21;
              int v122 = v13;
              Fax3BadLength("Fax4Decode", (uint64_t)a1, *(unsigned int *)(v9 + 152), v29, v139, v22, (uint64_t)v17, (uint64_t)v19);
              BOOL v123 = (int)v29 > (int)v139;
              if ((int)v29 <= (int)v139)
              {
                int v13 = v122;
                LODWORD(v21) = v138;
                uint64_t v20 = v140;
                unint64_t v16 = v141;
                double v32 = v10;
                uint64_t v18 = v139;
                LODWORD(v10) = v113;
                uint64_t v22 = v118;
              }
              else
              {
                double v32 = v10;
                uint64_t v22 = v118;
                if ((unint64_t)v10 <= v118)
                {
                  int v13 = v122;
                  LODWORD(v21) = v138;
                  uint64_t v20 = v140;
                  unint64_t v16 = v141;
                  uint64_t v18 = v139;
                  LODWORD(v10) = v113;
                }
                else
                {
                  double v124 = v10 - 1;
                  uint64_t v125 = v10 - 1;
                  int v13 = v122;
                  uint64_t v20 = v140;
                  unint64_t v16 = v141;
                  uint64_t v18 = v139;
                  LODWORD(v10) = v113;
                  do
                  {
                    int v126 = *v125--;
                    LODWORD(v29) = v29 - v126;
                    BOOL v123 = (int)v29 > (int)v139;
                    BOOL v127 = (int)v29 > (int)v139 && (unint64_t)v124 > v118;
                    double v124 = v125;
                  }
                  while (v127);
                  double v32 = v125 + 1;
                  LODWORD(v21) = v138;
                }
              }
              if ((int)v29 >= (int)v18)
              {
                if (!v123)
                {
                  int v11 = 0;
                  goto LABEL_241;
                }
                uint64_t v102 = v142;
                if ((unint64_t)v32 >= v22 + 4 * (unint64_t)*(unsigned int *)(v9 + 104)) {
                  goto LABEL_239;
                }
                *double v32 = v18;
                if ((unint64_t)(v32 + 1) >= v22 + 4 * (unint64_t)*(unsigned int *)(v9 + 104)) {
                  goto LABEL_239;
                }
                int v11 = 0;
                v32[1] = 0;
                v32 += 2;
                uint64_t v18 = v139;
                LODWORD(v21) = v138;
              }
              else
              {
                if (((v32 - v22) & 4) != 0)
                {
                  if ((unint64_t)v32 >= v22 + 4 * (unint64_t)*(unsigned int *)(v9 + 104)) {
                    goto LABEL_239;
                  }
                  *v32++ = 0;
                }
                if ((unint64_t)v32 >= v22 + 4 * (unint64_t)*(unsigned int *)(v9 + 104)) {
                  goto LABEL_239;
                }
                int v11 = 0;
                *v32++ = v18 - (v29 & ~((int)v29 >> 31));
LABEL_241:
                uint64_t v102 = v142;
              }
LABEL_242:
              if ((unint64_t)v24 >= v16)
              {
                if (v11) {
                  int v11 = 13;
                }
                else {
                  int v11 = 0;
                }
              }
              else
              {
                v12 |= *(unsigned __int8 *)(v20 + *v24) << v11;
                if (v11 > 4)
                {
                  v11 += 8;
                }
                else
                {
                  if ((unint64_t)(v24 + 1) < v16)
                  {
                    uint64_t v128 = v24[1];
                    v24 += 2;
                    v12 |= *(unsigned __int8 *)(v20 + v128) << (v11 + 8);
                    v11 += 16;
                    goto LABEL_252;
                  }
                  int v11 = 13;
                }
                ++v24;
              }
LABEL_252:
              if ((int)v21 <= (int)v10)
              {
                int v129 = v13;
                (*(void (**)(uint64_t, uint64_t, _DWORD *, uint64_t, unint64_t))(v9 + 88))(v102, v22, v32, v18, v16);
                *(_DWORD *)(v9 + 72) = v12 >> 13;
                *(_DWORD *)(v9 + 76) = v11 - 13;
                *(_DWORD *)(v9 + 80) = v129;
                v8[145] += v8[144] - (void)v24;
                v8[144] = v24;
                if (*(_DWORD *)(v9 + 152)) {
                  return 1;
                }
                else {
                  return 0xFFFFFFFFLL;
                }
              }
              goto LABEL_253;
            }
            goto LABEL_7;
          }
          int v52 = TIFFFaxBlackTable[2 * v48 + 1];
          uint64_t v29 = (v52 + v29);
          i += v52;
        }
      }
      while (1)
      {
        if (v11 > 11) {
          goto LABEL_33;
        }
        if ((unint64_t)v24 >= v16)
        {
          if (!v11) {
            goto LABEL_203;
          }
          int v11 = 12;
        }
        else
        {
          v12 |= *(unsigned __int8 *)(v20 + *v24) << v11;
          if (v11 > 3)
          {
            v11 += 8;
          }
          else
          {
            if ((unint64_t)(v24 + 1) < v16)
            {
              uint64_t v40 = v24[1];
              v24 += 2;
              v12 |= *(unsigned __int8 *)(v20 + v40) << (v11 + 8);
              v11 += 16;
              goto LABEL_33;
            }
            int v11 = 12;
          }
          ++v24;
        }
LABEL_33:
        uint64_t v41 = v12 & 0xFFF;
        uint64_t v42 = (unsigned __int8 *)&TIFFFaxWhiteTable[2 * v41];
        int v43 = v42[1];
        v11 -= v43;
        v12 >>= v43;
        int v44 = *v42;
        if (v44 != 9 && v44 != 11) {
          break;
        }
        int v46 = TIFFFaxWhiteTable[2 * v41 + 1];
        uint64_t v29 = (v46 + v29);
        i += v46;
      }
      if (v44 != 7)
      {
        uint64_t v87 = v22;
        memory_object_size_t v88 = v10;
        uint64_t v89 = v25;
        int v67 = v32;
LABEL_142:
        int v131 = v26;
        uint64_t v91 = (uint64_t)a1;
        goto LABEL_143;
      }
      int v66 = TIFFFaxWhiteTable[2 * v41 + 1];
      *double v32 = v66 + i;
      int v67 = v32 + 1;
      uint64_t v29 = (v66 + v29);
      for (int i = 0; ; i += v73)
      {
        if (v11 > 12) {
          goto LABEL_91;
        }
        if ((unint64_t)v24 >= v16)
        {
          if (!v11) {
            goto LABEL_205;
          }
          int v11 = 13;
        }
        else
        {
          v12 |= *(unsigned __int8 *)(v20 + *v24) << v11;
          if (v11 > 4)
          {
            v11 += 8;
          }
          else
          {
            if ((unint64_t)(v24 + 1) < v16)
            {
              uint64_t v68 = v24[1];
              v24 += 2;
              v12 |= *(unsigned __int8 *)(v20 + v68) << (v11 + 8);
              v11 += 16;
              goto LABEL_91;
            }
            int v11 = 13;
          }
          ++v24;
        }
LABEL_91:
        uint64_t v69 = v12 & 0x1FFF;
        long long v70 = (unsigned __int8 *)&TIFFFaxBlackTable[2 * v69];
        int v71 = v70[1];
        v11 -= v71;
        v12 >>= v71;
        int v72 = *v70;
        if ((v72 - 10) >= 2) {
          break;
        }
        int v73 = TIFFFaxBlackTable[2 * v69 + 1];
        uint64_t v29 = (v73 + v29);
      }
      if (v72 != 8)
      {
        uint64_t v87 = v22;
        memory_object_size_t v88 = v10;
        uint64_t v89 = v25;
        goto LABEL_140;
      }
      if ((unint64_t)v67 < v22 + 4 * (unint64_t)*(unsigned int *)(v9 + 104))
      {
        long long v82 = (char *)&TIFFFaxBlackTable[2 * v69];
        goto LABEL_117;
      }
LABEL_210:
      uint64_t v121 = a1[150];
LABEL_211:
      TIFFErrorExt(v121, "Fax4Decode", "Buffer overflow at line %u of %s %u", v18, v16, v22, (uint64_t)v17, (uint64_t)v19, *(_DWORD *)(v9 + 152));
      return 0xFFFFFFFFLL;
    case 0x30:
    case 0x41:
    case 0x70:
    case 0xB0:
    case 0xC1:
    case 0xF0:
    case 0x130:
    case 0x141:
    case 0x170:
    case 0x180:
    case 0x1B0:
    case 0x1C1:
    case 0x1F0:
    case 0x230:
    case 0x241:
    case 0x270:
    case 0x2B0:
    case 0x2C1:
    case 0x2F0:
    case 0x300:
    case 0x330:
    case 0x341:
    case 0x370:
    case 0x380:
    case 0x3B0:
    case 0x3C1:
    case 0x3F0:
    case 0x409:
    case 0x419:
      if (v32 == (_DWORD *)v22 || (int)v30 > (int)v29) {
        goto LABEL_65;
      }
      unint64_t v57 = &v23[v33];
      unint64_t v58 = v31 + 1;
      do
      {
        if (v58 >= v57) {
          goto LABEL_210;
        }
        LODWORD(v30) = *(v58 - 1) + v30 + *v58;
        v58 += 2;
      }
      while ((int)v30 <= (int)v29);
      double v31 = v58 - 1;
LABEL_65:
      int v59 = *((_DWORD *)&TIFFFaxMainTable + 2 * v35 + 1);
      *double v32 = i + v27 + v30 + v59;
      if (v31 >= &v23[*(unsigned int *)(v9 + 104)]) {
        goto LABEL_210;
      }
      int i = 0;
      uint64_t v29 = (v59 + v30);
      ++v32;
      int v60 = *v31++;
      int v55 = v60;
LABEL_67:
      uint64_t v30 = (v55 + v30);
      goto LABEL_77;
    case 0x81:
    case 0x181:
    case 0x200:
    case 0x281:
    case 0x381:
    case 0x421:
    case 0x431:
      *double v32 = v18 - v29;
      int v67 = v32 + 1;
      unsigned int v136 = v25;
      int v133 = v26;
      uint64_t v111 = v22;
      Fax3Extension("Fax4Decode", (uint64_t)a1, *(_DWORD *)(v9 + 152), v29, v16, v22, (uint64_t)&TIFFFaxMainTable, (uint64_t)TIFFFaxWhiteTable);
      goto LABEL_186;
    default:
      uint64_t v112 = v22;
      int v67 = v32;
      unsigned int v137 = v25;
      int v134 = v26;
      goto LABEL_197;
  }
}

uint64_t Fax4Encode(void *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1[137];
  if (a3 % *(void *)(v9 + 8))
  {
    TIFFErrorExtR((uint64_t)a1, "Fax4Encode", "Fractional scanlines cannot be written", a4, a5, a6, a7, a8, v15);
    return 0;
  }
  else
  {
    uint64_t v11 = a3;
    if (a3 < 1)
    {
      return 1;
    }
    else
    {
      while (1)
      {
        uint64_t result = Fax3Encode2DRow(a1, a2, *(char **)(v9 + 136), *(unsigned int *)(v9 + 16), a5, a6, a7, a8);
        if (!result) {
          break;
        }
        _TIFFmemcpy(*(void **)(v9 + 136), a2, *(void *)(v9 + 8));
        uint64_t v13 = *(void *)(v9 + 8);
        a2 += v13;
        BOOL v14 = v11 <= v13;
        v11 -= v13;
        if (v14) {
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t Fax4PostEncode(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1[137];
  uint64_t v10 = 1;
  Fax3PutBits(a1, 1, 12, a4, a5, a6, a7, a8);
  Fax3PutBits(a1, 1, 12, v11, v12, v13, v14, v15);
  if (*(_DWORD *)(v9 + 76) != 8)
  {
    if (a1[145] < a1[141] || TIFFFlushData1((uint64_t)a1, v16, v17, v18, v19, v20, v21, v22))
    {
      char v23 = *(_DWORD *)(v9 + 72);
      int8x16_t v24 = (unsigned char *)a1[144];
      a1[144] = v24 + 1;
      *int8x16_t v24 = v23;
      ++a1[145];
      *(void *)(v9 + 72) = 0x800000000;
    }
    else
    {
      return 0;
    }
  }
  return v10;
}

uint64_t TIFFInitCCITTRLE(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = InitCCITTFax3((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    a1[126] = Fax3DecodeRLE;
    a1[128] = Fax3DecodeRLE;
    a1[130] = Fax3DecodeRLE;
    return _cg_TIFFSetField((uint64_t)a1, 0x10000, v10, v11, v12, v13, v14, v15, 7);
  }
  return result;
}

uint64_t Fax3DecodeRLE(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[137];
  if (a3 % *(void *)(v8 + 8))
  {
    TIFFErrorExtR((uint64_t)a1, "Fax3DecodeRLE", "Fractional scanlines cannot be read", a4, a5, a6, a7, a8, v63);
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = a3;
  unsigned int v12 = *(_DWORD *)(v8 + 72);
  int v11 = *(_DWORD *)(v8 + 76);
  int v13 = *(_DWORD *)(v8 + 80);
  uint64_t v14 = a1[144];
  uint64_t v15 = a1[145];
  if (a3 < 1)
  {
    uint64_t v21 = (unsigned __int8 *)a1[144];
LABEL_83:
    *(_DWORD *)(v8 + 72) = v12;
    *(_DWORD *)(v8 + 76) = v11;
    *(_DWORD *)(v8 + 80) = v13;
    a1[145] = v14 - (void)v21 + v15;
    a1[144] = v21;
    return 1;
  }
  int v64 = *(_DWORD *)(v8 + 80);
  int v67 = a1;
  uint64_t v17 = *(unsigned int *)(v8 + 16);
  uint64_t v18 = *(void *)(v8 + 64);
  unint64_t v19 = v14 + v15;
  int v66 = *(_DWORD *)(v8 + 4);
  uint64_t v20 = *(int **)(v8 + 120);
  uint64_t v21 = (unsigned __int8 *)a1[144];
  uint64_t v70 = a1[137];
  uint64_t v65 = v18;
  while (2)
  {
    uint64_t v68 = v10;
    uint64_t v69 = a2;
    int v22 = 0;
    char v23 = v20;
    while (2)
    {
      int v24 = 0;
      while (2)
      {
        if (v11 > 11) {
          goto LABEL_18;
        }
        if ((unint64_t)v21 >= v19)
        {
          if (v11)
          {
            int v11 = 12;
            goto LABEL_18;
          }
LABEL_79:
          uint64_t v51 = v8;
          TIFFWarningExtR((uint64_t)v67, "Fax3DecodeRLE", "Premature EOF at line %u of %s %u (x %u)", a4, a5, a6, a7, a8, *(_DWORD *)(v8 + 152));
          if (v24)
          {
            uint64_t v52 = v51;
            if (v23 >= &v20[*(unsigned int *)(v51 + 104)]) {
              goto LABEL_110;
            }
            *v23++ = v24;
          }
          else
          {
            uint64_t v52 = v51;
          }
          if (v22 == v17)
          {
LABEL_86:
            uint64_t v53 = v69;
LABEL_87:
            uint64_t v54 = (_DWORD *)v52;
            (*(void (**)(uint64_t, int *, int *, uint64_t))(v52 + 88))(v53, v20, v23, v17);
            v54[18] = v12;
            v54[19] = 0;
            v54[20] = v64;
            v67[145] += v67[144] - (void)v21;
            v67[144] = v21;
            return 0xFFFFFFFFLL;
          }
          int v55 = "Line length mismatch";
          if (v22 < v17) {
            int v55 = "Premature EOL";
          }
          TIFFWarningExtR((uint64_t)v67, "Fax3DecodeRLE", "%s at line %u of %s %u (got %u, expected %u)", a4, a5, a6, a7, a8, (char)v55);
          BOOL v56 = v22 > (int)v17;
          if (v22 <= (int)v17 || v23 <= v20)
          {
            uint64_t v52 = v70;
          }
          else
          {
            unint64_t v57 = v23 - 1;
            unint64_t v58 = v23 - 1;
            uint64_t v52 = v70;
            do
            {
              int v59 = *v58--;
              v22 -= v59;
              BOOL v56 = v22 > (int)v17;
              BOOL v60 = v22 > (int)v17 && v57 > v20;
              unint64_t v57 = v58;
            }
            while (v60);
            char v23 = v58 + 1;
          }
          if (v22 >= (int)v17)
          {
            if (!v56) {
              goto LABEL_86;
            }
            uint64_t v53 = v69;
            if (v23 < &v20[*(unsigned int *)(v52 + 104)])
            {
              *char v23 = v17;
              if (v23 + 1 < &v20[*(unsigned int *)(v52 + 104)])
              {
                v23[1] = 0;
                v23 += 2;
                goto LABEL_87;
              }
            }
          }
          else
          {
            if (((v23 - v20) & 4) != 0)
            {
              if (v23 >= &v20[*(unsigned int *)(v52 + 104)]) {
                goto LABEL_110;
              }
              *v23++ = 0;
            }
            if (v23 < &v20[*(unsigned int *)(v52 + 104)])
            {
              *v23++ = v17 - (v22 & ~(v22 >> 31));
              goto LABEL_86;
            }
          }
LABEL_110:
          uint64_t v61 = v67[150];
          int v62 = *(_DWORD *)(v52 + 152);
          goto LABEL_111;
        }
        v12 |= *(unsigned __int8 *)(v18 + *v21) << v11;
        if (v11 > 3)
        {
          v11 += 8;
        }
        else
        {
          if ((unint64_t)(v21 + 1) < v19)
          {
            uint64_t v25 = v21[1];
            v21 += 2;
            v12 |= *(unsigned __int8 *)(v18 + v25) << (v11 + 8);
            v11 += 16;
            goto LABEL_18;
          }
          int v11 = 12;
        }
        ++v21;
LABEL_18:
        uint64_t v26 = v12 & 0xFFF;
        int v27 = BYTE1(TIFFFaxWhiteTable[2 * v26]);
        v11 -= v27;
        v12 >>= v27;
        switch(8 * v26)
        {
          case 0:
          case 0x24:
            goto LABEL_42;
          case 1:
          case 0x14:
          case 0x2CLL:
          case 0x30:
            int v28 = TIFFFaxWhiteTable[2 * v26 + 1];
            v22 += v28;
            v24 += v28;
            continue;
          case 8:
          case 0x10:
          case 0x18:
          case 0x20:
          case 0x28:
            if (v23 >= &v20[*(unsigned int *)(v8 + 104)]) {
              goto LABEL_98;
            }
            int v29 = TIFFFaxWhiteTable[2 * v26 + 1];
            int v30 = v29 + v24;
            double v31 = v23;
            *v23++ = v29 + v24;
            v22 += v29;
            if (v22 >= (int)v17) {
              goto LABEL_49;
            }
            int v24 = 0;
            break;
          default:
            uint64_t v39 = (uint64_t)v67;
            goto LABEL_47;
        }
        break;
      }
      while (1)
      {
        if (v11 > 12) {
          goto LABEL_33;
        }
        if ((unint64_t)v21 >= v19)
        {
          if (!v11) {
            goto LABEL_79;
          }
          int v11 = 13;
        }
        else
        {
          v12 |= *(unsigned __int8 *)(v18 + *v21) << v11;
          if (v11 > 4)
          {
            v11 += 8;
          }
          else
          {
            if ((unint64_t)(v21 + 1) < v19)
            {
              uint64_t v32 = v21[1];
              v21 += 2;
              v12 |= *(unsigned __int8 *)(v18 + v32) << (v11 + 8);
              v11 += 16;
              goto LABEL_33;
            }
            int v11 = 13;
          }
          ++v21;
        }
LABEL_33:
        uint64_t v33 = v12 & 0x1FFF;
        unsigned int v34 = (unsigned __int8 *)&TIFFFaxBlackTable[2 * v33];
        int v35 = v34[1];
        v11 -= v35;
        v12 >>= v35;
        int v36 = *v34;
        if ((v36 - 10) >= 2) {
          break;
        }
        int v37 = TIFFFaxBlackTable[2 * v33 + 1];
        v22 += v37;
        v24 += v37;
      }
      if (v36 == 12)
      {
LABEL_42:
        int v64 = 1;
        if (!v24)
        {
LABEL_48:
          uint64_t v8 = v70;
          break;
        }
LABEL_43:
        uint64_t v8 = v70;
        if (v23 < &v20[*(unsigned int *)(v70 + 104)])
        {
          *v23++ = v24;
          break;
        }
        goto LABEL_98;
      }
      if (v36 != 8)
      {
        uint64_t v39 = (uint64_t)v67;
LABEL_47:
        TIFFErrorExtR(v39, "Fax3DecodeRLE", "Bad code word at line %u of %s %u (x %u)", a4, a5, a6, a7, a8, *(_DWORD *)(v8 + 152));
        if (!v24) {
          goto LABEL_48;
        }
        goto LABEL_43;
      }
      if (v23 >= &v20[*(unsigned int *)(v8 + 104)]) {
        goto LABEL_98;
      }
      int v38 = TIFFFaxBlackTable[2 * v33 + 1];
      char v23 = v31 + 2;
      v31[1] = v38 + v24;
      v22 += v38;
      if (v22 < (int)v17)
      {
        if (!((v38 + v24) | v30)) {
          char v23 = v31;
        }
        continue;
      }
      break;
    }
LABEL_49:
    if (v22 == v17)
    {
      uint64_t v41 = v68;
      uint64_t v40 = v69;
      goto LABEL_72;
    }
    uint64_t v42 = "Line length mismatch";
    if (v22 < v17) {
      uint64_t v42 = "Premature EOL";
    }
    TIFFWarningExtR((uint64_t)v67, "Fax3DecodeRLE", "%s at line %u of %s %u (got %u, expected %u)", a4, a5, a6, a7, a8, (char)v42);
    BOOL v43 = v22 > (int)v17;
    if (v22 > (int)v17 && v23 > v20)
    {
      int v44 = v23 - 1;
      double v45 = v23 - 1;
      do
      {
        int v46 = *v45--;
        v22 -= v46;
        BOOL v43 = v22 > (int)v17;
        BOOL v47 = v22 > (int)v17 && v44 > v20;
        int v44 = v45;
      }
      while (v47);
      char v23 = v45 + 1;
    }
    uint64_t v8 = v70;
    uint64_t v41 = v68;
    if (v22 < (int)v17)
    {
      if (((v23 - v20) & 4) == 0) {
        goto LABEL_65;
      }
      if (v23 >= &v20[*(unsigned int *)(v70 + 104)]) {
        goto LABEL_98;
      }
      *v23++ = 0;
LABEL_65:
      if (v23 >= &v20[*(unsigned int *)(v70 + 104)]) {
        goto LABEL_98;
      }
      *v23++ = v17 - (v22 & ~(v22 >> 31));
LABEL_71:
      uint64_t v40 = v69;
LABEL_72:
      (*(void (**)(uint64_t, int *, int *, uint64_t))(v8 + 88))(v40, v20, v23, v17);
      if ((v66 & 4) != 0)
      {
        char v49 = v11 & 7;
        v11 &= 0xFFFFFFF8;
        v12 >>= v49;
      }
      else if ((v66 & 8) != 0)
      {
        char v48 = v11 & 0xF;
        v11 &= 0xFFFFFFF0;
        v12 >>= v48;
        v21 += (v11 == 0) & v21;
      }
      uint64_t v8 = v70;
      uint64_t v18 = v65;
      uint64_t v50 = *(void *)(v70 + 8);
      a2 = v40 + v50;
      ++*(_DWORD *)(v70 + 152);
      BOOL v47 = v41 <= v50;
      uint64_t v10 = v41 - v50;
      if (v47)
      {
        a1 = v67;
        uint64_t v14 = v67[144];
        uint64_t v15 = v67[145];
        int v13 = v64;
        goto LABEL_83;
      }
      continue;
    }
    break;
  }
  if (!v43) {
    goto LABEL_71;
  }
  if (v23 < &v20[*(unsigned int *)(v70 + 104)])
  {
    *char v23 = v17;
    if (v23 + 1 < &v20[*(unsigned int *)(v70 + 104)])
    {
      v23[1] = 0;
      v23 += 2;
      goto LABEL_71;
    }
  }
LABEL_98:
  uint64_t v61 = v67[150];
  int v62 = *(_DWORD *)(v8 + 152);
LABEL_111:
  TIFFErrorExt(v61, "Fax3DecodeRLE", "Buffer overflow at line %u of %s %u", a4, a5, a6, a7, a8, v62);
  return 0xFFFFFFFFLL;
}

uint64_t TIFFInitCCITTRLEW(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = InitCCITTFax3((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    a1[126] = Fax3DecodeRLE;
    a1[128] = Fax3DecodeRLE;
    a1[130] = Fax3DecodeRLE;
    return _cg_TIFFSetField((uint64_t)a1, 0x10000, v10, v11, v12, v13, v14, v15, 11);
  }
  return result;
}

uint64_t Fax3VGetField(uint64_t a1, int a2, void **a3)
{
  uint64_t v3 = *(void *)(a1 + 1096);
  if (!v3) {
    Fax3VGetField_cold_1();
  }
  if (a2 > 327)
  {
    switch(a2)
    {
      case 328:
        int v4 = *(_DWORD *)(v3 + 24);
        break;
      case 65540:
        **a3 = *(void *)(v3 + 88);
        return 1;
      case 65536:
        int v4 = *(_DWORD *)(v3 + 4);
        break;
      default:
        goto LABEL_17;
    }
LABEL_14:
    *(_DWORD *)*a3 = v4;
    return 1;
  }
  if ((a2 - 292) < 2)
  {
    int v4 = *(_DWORD *)(v3 + 32);
    goto LABEL_14;
  }
  if (a2 == 326)
  {
    int v4 = *(_DWORD *)(v3 + 28);
    goto LABEL_14;
  }
  if (a2 == 327)
  {
    *(_WORD *)*a3 = *(_WORD *)(v3 + 20);
    return 1;
  }
LABEL_17:
  int v6 = *(uint64_t (**)(void))(v3 + 40);

  return v6();
}

uint64_t Fax3VSetField(uint64_t a1, int a2, _DWORD *a3)
{
  uint64_t v3 = *(void *)(a1 + 1096);
  if (!v3) {
    Fax3VSetField_cold_1();
  }
  int v4 = *(uint64_t (**)(void))(v3 + 48);
  if (!v4) {
    Fax3VSetField_cold_2();
  }
  if (a2 <= 326)
  {
    switch(a2)
    {
      case 292:
        if (*(_WORD *)(a1 + 120) != 3) {
          goto LABEL_18;
        }
        break;
      case 293:
        if (*(_WORD *)(a1 + 120) != 4) {
          goto LABEL_18;
        }
        break;
      case 326:
        *(_DWORD *)(v3 + 28) = *a3;
LABEL_18:
        uint64_t result = (uint64_t)TIFFFieldWithTag((void *)a1, a2);
        if (result)
        {
          unint64_t v7 = *(unsigned __int16 *)(result + 24);
          uint64_t result = 1;
          *(_DWORD *)(a1 + ((v7 >> 3) & 0x1FFC) + 72) |= 1 << v7;
          *(_DWORD *)(a1 + 16) |= 8u;
        }
        return result;
      default:
        goto LABEL_25;
    }
    *(_DWORD *)(v3 + 32) = *a3;
    goto LABEL_18;
  }
  if (a2 >= 0x10000)
  {
    if (a2 == 65540)
    {
      *(void *)(v3 + 88) = *(void *)a3;
    }
    else
    {
      if (a2 != 0x10000) {
        goto LABEL_25;
      }
      *(_DWORD *)(v3 + 4) = *a3;
    }
    return 1;
  }
  if (a2 == 327)
  {
    *(_WORD *)(v3 + 20) = *a3;
    goto LABEL_18;
  }
  if (a2 == 328)
  {
    *(_DWORD *)(v3 + 24) = *a3;
    goto LABEL_18;
  }
LABEL_25:

  return v4();
}

uint64_t Fax3PrintDir(uint64_t result, FILE *__stream, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 1096);
  if (!v3) {
    Fax3PrintDir_cold_1();
  }
  uint64_t v6 = result;
  int v7 = *(_DWORD *)(result + 80);
  if ((v7 & 0x200) == 0)
  {
    if ((v7 & 8) == 0) {
      goto LABEL_4;
    }
    goto LABEL_20;
  }
  if (*(_WORD *)(result + 120) == 4)
  {
    fwrite("  Group 4 Options:", 0x12uLL, 1uLL, __stream);
    if ((*(unsigned char *)(v3 + 32) & 2) == 0) {
      goto LABEL_19;
    }
    uint64_t v9 = " ";
    goto LABEL_18;
  }
  fwrite("  Group 3 Options:", 0x12uLL, 1uLL, __stream);
  int v10 = *(_DWORD *)(v3 + 32);
  uint64_t v9 = " ";
  if (v10)
  {
    fprintf(__stream, "%s2-d encoding", " ");
    int v10 = *(_DWORD *)(v3 + 32);
    uint64_t v9 = "+";
    if ((v10 & 4) == 0)
    {
LABEL_17:
      if ((v10 & 2) == 0) {
        goto LABEL_19;
      }
      goto LABEL_18;
    }
  }
  else if ((v10 & 4) == 0)
  {
    goto LABEL_17;
  }
  fprintf(__stream, "%sEOL padding", v9);
  uint64_t v9 = "+";
  if ((*(_DWORD *)(v3 + 32) & 2) != 0) {
LABEL_18:
  }
    fprintf(__stream, "%suncompressed data", v9);
LABEL_19:
  uint64_t result = fprintf(__stream, " (%u = 0x%x)\n", *(_DWORD *)(v3 + 32), *(_DWORD *)(v3 + 32));
  int v7 = *(_DWORD *)(v6 + 80);
  if ((v7 & 8) == 0)
  {
LABEL_4:
    if ((v7 & 4) == 0) {
      goto LABEL_5;
    }
    goto LABEL_31;
  }
LABEL_20:
  fwrite("  Fax Data:", 0xBuLL, 1uLL, __stream);
  int v11 = *(unsigned __int16 *)(v3 + 20);
  if (v11 == 2)
  {
    uint64_t v12 = " uncorrected errors";
    size_t v13 = 19;
  }
  else if (v11 == 1)
  {
    uint64_t v12 = " receiver regenerated";
    size_t v13 = 21;
  }
  else
  {
    if (*(_WORD *)(v3 + 20)) {
      goto LABEL_30;
    }
    uint64_t v12 = " clean";
    size_t v13 = 6;
  }
  fwrite(v12, v13, 1uLL, __stream);
LABEL_30:
  uint64_t result = fprintf(__stream, " (%hu = 0x%hx)\n", *(unsigned __int16 *)(v3 + 20), *(unsigned __int16 *)(v3 + 20));
  int v7 = *(_DWORD *)(v6 + 80);
  if ((v7 & 4) == 0)
  {
LABEL_5:
    if ((v7 & 0x10) == 0) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
LABEL_31:
  uint64_t result = fprintf(__stream, "  Bad Fax Lines: %u\n", *(_DWORD *)(v3 + 28));
  if ((*(_DWORD *)(v6 + 80) & 0x10) != 0) {
LABEL_6:
  }
    uint64_t result = fprintf(__stream, "  Consecutive Bad Fax Lines: %u\n", *(_DWORD *)(v3 + 24));
LABEL_7:
  uint64_t v8 = *(uint64_t (**)(uint64_t, FILE *, uint64_t))(v3 + 56);
  if (v8)
  {
    return v8(v6, __stream, a3);
  }
  return result;
}

uint64_t Fax3FixupTags()
{
  return 1;
}

uint64_t Fax3SetupState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a1 + 116) != 1)
  {
    uint64_t v12 = "Fax3SetupState";
    size_t v13 = "Bits/sample must be 1 for Group 3/4 encoding/decoding";
LABEL_34:
    TIFFErrorExtR(a1, v12, v13, a4, a5, a6, a7, a8, v31);
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 1096);
  if ((*(unsigned char *)(a1 + 17) & 4) != 0)
  {
    int64_t v10 = _cg_TIFFTileRowSize(a1, a2, a3, a4, a5, a6, a7, a8);
    int v11 = (unsigned int *)(a1 + 100);
  }
  else
  {
    int64_t v10 = _cg_TIFFScanlineSize(a1, a2, a3, a4, a5, a6, a7, a8);
    int v11 = (unsigned int *)(a1 + 88);
  }
  uint64_t v14 = *v11;
  if (v10 >= (uint64_t)((unint64_t)(v14 + 7) >> 3))
  {
    *(void *)(v9 + 8) = v10;
    *(_DWORD *)(v9 + 16) = v14;
    BOOL v15 = (*(unsigned char *)(v9 + 32) & 1) != 0 || *(unsigned __int16 *)(a1 + 120) == 4;
    *(void *)(v9 + 96) = 0;
    if ((v14 + 1) >= 0xFFFFFFE0) {
      int v16 = 0;
    }
    else {
      int v16 = (v14 & 0xFFFFFFE0) + 32;
    }
    int v17 = 2 * v16;
    if (v16 < 0) {
      int v17 = 0;
    }
    if (v15) {
      int v16 = v17;
    }
    *(_DWORD *)(v9 + 104) = v16;
    if (!v16 || v16 < 0 || (v16 & 0x7FFFFFFE) == 0)
    {
      uint64_t v12 = *(const char **)a1;
      char v31 = v14;
      size_t v13 = "Row pixels integer overflow (rowpixels %u)";
      goto LABEL_34;
    }
    uint64_t result = (uint64_t)_TIFFCheckMalloc((const char **)a1, (2 * v16), 4, (uint64_t)"for Group 3/4 run arrays", a5, a6, a7, a8);
    *(void *)(v9 + 96) = result;
    if (!result) {
      return result;
    }
    int v19 = *(_DWORD *)(v9 + 104);
    if (v19 < 0) {
      size_t v20 = 0;
    }
    else {
      size_t v20 = 4 * (2 * v19);
    }
    bzero((void *)result, v20);
    uint64_t v27 = 0;
    uint64_t v28 = *(void *)(v9 + 96);
    *(void *)(v9 + 120) = v28;
    if (v15) {
      uint64_t v27 = v28 + 4 * *(unsigned int *)(v9 + 104);
    }
    *(void *)(v9 + 112) = v27;
    if (*(_WORD *)(a1 + 120) == 3 && (*(unsigned char *)(v9 + 32) & 1) != 0)
    {
      *(void *)(a1 + 1008) = Fax3Decode2D;
      *(void *)(a1 + 1024) = Fax3Decode2D;
      *(void *)(a1 + 1040) = Fax3Decode2D;
    }
    uint64_t v29 = *(void *)(a1 + 1096);
    if (v15)
    {
      int v30 = _TIFFmallocExt((void *)a1, v10, v21, v22, v23, v24, v25, v26);
      *(void *)(v29 + 136) = v30;
      if (!v30)
      {
        uint64_t v12 = "Fax3SetupState";
        size_t v13 = "No space for Group 3/4 reference line";
        goto LABEL_34;
      }
    }
    else
    {
      *(void *)(v29 + 136) = 0;
    }
    return 1;
  }
  TIFFErrorExtR(a1, "Fax3SetupState", "Inconsistent number of bytes per row : rowbytes=%lld rowpixels=%u", a4, a5, a6, a7, a8, v10);
  return 0;
}

uint64_t Fax3PreDecode(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1096);
  if (!v1) {
    Fax3PreDecode_cold_1();
  }
  *(void *)(v1 + 72) = 0;
  *(_DWORD *)(v1 + 80) = 0;
  *(void *)(v1 + 64) = TIFFGetBitRevTable(*(unsigned __int16 *)(a1 + 126) != 2);
  uint64_t v2 = *(void *)(v1 + 96);
  *(void *)(v1 + 120) = v2;
  if (*(void *)(v1 + 112))
  {
    uint64_t v3 = (void *)(v2 + 4 * *(unsigned int *)(v1 + 104));
    *(void *)(v1 + 112) = v3;
    *uint64_t v3 = *(unsigned int *)(v1 + 16);
  }
  *(_DWORD *)(v1 + 152) = 0;
  return 1;
}

uint64_t Fax3Decode1D(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[137];
  if (a3 % *(void *)(v8 + 8))
  {
    TIFFErrorExtR((uint64_t)a1, "Fax3Decode1D", "Fractional scanlines cannot be read", a4, a5, a6, a7, a8, v63);
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = a3;
  unsigned int v12 = *(_DWORD *)(v8 + 72);
  int v11 = *(_DWORD *)(v8 + 76);
  int v13 = *(_DWORD *)(v8 + 80);
  uint64_t v14 = a1[144];
  uint64_t v15 = a1[145];
  if (a3 < 1)
  {
    uint64_t v21 = (unsigned __int8 *)a1[144];
    goto LABEL_100;
  }
  int v67 = a1;
  uint64_t v17 = *(unsigned int *)(v8 + 16);
  uint64_t v18 = *(void *)(v8 + 64);
  unint64_t v19 = v14 + v15;
  size_t v20 = *(int **)(v8 + 120);
  uint64_t v21 = (unsigned __int8 *)a1[144];
  uint64_t v68 = v17;
  uint64_t v69 = v20;
  while (2)
  {
    if (v13) {
      goto LABEL_22;
    }
    while (1)
    {
      if (v11 > 10) {
        goto LABEL_19;
      }
      if ((unint64_t)v21 >= v19)
      {
        if (!v11)
        {
          int v13 = 0;
LABEL_106:
          uint64_t v52 = v67;
          if (v17)
          {
            TIFFWarningExtR((uint64_t)v67, "Fax3Decode1D", "%s at line %u of %s %u (got %u, expected %u)", v17, a5, a6, a7, a8, (char)"Premature EOL");
            uint64_t v17 = v68;
            int v54 = *(_DWORD *)(v8 + 104);
            if ((int)v68 < 1)
            {
              size_t v20 = v69;
              if (!v54) {
                goto LABEL_139;
              }
              *uint64_t v69 = v68;
              if (*(_DWORD *)(v8 + 104) <= 1u) {
                goto LABEL_139;
              }
              uint64_t v53 = v69 + 2;
              v69[1] = 0;
            }
            else
            {
              size_t v20 = v69;
              if (!v54) {
                goto LABEL_139;
              }
              *uint64_t v69 = v68;
              uint64_t v53 = v69 + 1;
            }
          }
          else
          {
            uint64_t v53 = v20;
          }
          goto LABEL_143;
        }
        int v11 = 11;
      }
      else
      {
        v12 |= *(unsigned __int8 *)(v18 + *v21) << v11;
        if (v11 > 2)
        {
          v11 += 8;
        }
        else
        {
          if ((unint64_t)(v21 + 1) < v19)
          {
            uint64_t v22 = v21[1];
            v21 += 2;
            v12 |= *(unsigned __int8 *)(v18 + v22) << (v11 + 8);
            v11 += 16;
            goto LABEL_19;
          }
          int v11 = 11;
        }
        ++v21;
      }
LABEL_19:
      if ((v12 & 0x7FF) == 0) {
        break;
      }
      --v11;
      v12 >>= 1;
    }
    while (1)
    {
LABEL_22:
      if (v11 <= 7)
      {
        if ((unint64_t)v21 >= v19)
        {
          if (!v11) {
            goto LABEL_106;
          }
          int v11 = 8;
        }
        else
        {
          unsigned int v23 = *v21++;
          v12 |= *(unsigned __int8 *)(v18 + v23) << v11;
          v11 += 8;
        }
      }
      if ((_BYTE)v12) {
        break;
      }
      v11 -= 8;
      v12 >>= 8;
    }
    uint64_t v65 = a2;
    uint64_t v66 = v10;
    if ((v12 & 1) == 0)
    {
      do
      {
        char v24 = v12;
        --v11;
        v12 >>= 1;
      }
      while ((v24 & 2) == 0);
    }
    int v25 = 0;
    --v11;
    v12 >>= 1;
    uint64_t v26 = v20;
    while (2)
    {
      int v27 = 0;
      while (2)
      {
        if (v11 <= 11)
        {
          if ((unint64_t)v21 < v19)
          {
            v12 |= *(unsigned __int8 *)(v18 + *v21) << v11;
            if (v11 > 3)
            {
              v11 += 8;
            }
            else
            {
              if ((unint64_t)(v21 + 1) < v19)
              {
                uint64_t v28 = v21[1];
                v21 += 2;
                v12 |= *(unsigned __int8 *)(v18 + v28) << (v11 + 8);
                v11 += 16;
                goto LABEL_42;
              }
              int v11 = 12;
            }
            ++v21;
            goto LABEL_42;
          }
          if (v11)
          {
            int v11 = 12;
            goto LABEL_42;
          }
          unsigned int v34 = v26;
LABEL_102:
          uint64_t v52 = v67;
          TIFFWarningExtR((uint64_t)v67, "Fax3Decode1D", "Premature EOF at line %u of %s %u (x %u)", v17, a5, a6, a7, a8, *(_DWORD *)(v8 + 152));
          if (v27)
          {
            if (v34 < &v69[*(unsigned int *)(v8 + 104)])
            {
              *unsigned int v34 = v27;
              uint64_t v53 = v34 + 1;
              goto LABEL_115;
            }
LABEL_139:
            uint64_t v62 = v52[150];
            goto LABEL_140;
          }
          uint64_t v53 = v34;
LABEL_115:
          if (v25 == v68)
          {
            int v13 = 0;
            a2 = v65;
            uint64_t v10 = v66;
            size_t v20 = v69;
            goto LABEL_143;
          }
          int v55 = v53;
          BOOL v56 = "Premature EOL";
          if (v25 >= v68) {
            BOOL v56 = "Line length mismatch";
          }
          TIFFWarningExtR((uint64_t)v67, "Fax3Decode1D", "%s at line %u of %s %u (got %u, expected %u)", v68, a5, a6, a7, a8, (char)v56);
          uint64_t v17 = v68;
          BOOL v57 = v25 > (int)v68;
          if (v25 <= (int)v68)
          {
            size_t v20 = v69;
            uint64_t v53 = v55;
          }
          else
          {
            size_t v20 = v69;
            uint64_t v53 = v55;
            if (v55 > v69)
            {
              unint64_t v58 = v55 - 1;
              int v59 = v55 - 1;
              do
              {
                int v60 = *v59--;
                v25 -= v60;
                BOOL v57 = v25 > (int)v68;
                BOOL v61 = v25 > (int)v68 && v58 > v69;
                unint64_t v58 = v59;
              }
              while (v61);
              uint64_t v53 = v59 + 1;
            }
          }
          if (v25 >= (int)v68)
          {
            if (!v57)
            {
              int v13 = 0;
              goto LABEL_142;
            }
            a2 = v65;
            uint64_t v10 = v66;
            if (v53 >= &v20[*(unsigned int *)(v8 + 104)]) {
              goto LABEL_139;
            }
            int *v53 = v68;
            if (v53 + 1 >= &v20[*(unsigned int *)(v8 + 104)]) {
              goto LABEL_139;
            }
            int v13 = 0;
            v53[1] = 0;
            v53 += 2;
          }
          else
          {
            if (((v53 - v20) & 4) != 0)
            {
              if (v53 >= &v20[*(unsigned int *)(v8 + 104)]) {
                goto LABEL_139;
              }
              *v53++ = 0;
            }
            if (v53 >= &v20[*(unsigned int *)(v8 + 104)]) {
              goto LABEL_139;
            }
            int v13 = 0;
            *v53++ = v68 - (v25 & ~(v25 >> 31));
LABEL_142:
            a2 = v65;
            uint64_t v10 = v66;
          }
LABEL_143:
          (*(void (**)(uint64_t, int *, int *))(v8 + 88))(a2, v20, v53);
          *(_DWORD *)(v8 + 72) = v12;
          *(_DWORD *)(v8 + 76) = 0;
          *(_DWORD *)(v8 + 80) = v13;
          v52[145] += v52[144] - (void)v21;
          v52[144] = v21;
          if (v10 < *((unsigned int *)v52 + 22)) {
            return 1;
          }
          else {
            return 0xFFFFFFFFLL;
          }
        }
LABEL_42:
        uint64_t v29 = v12 & 0xFFF;
        int v30 = *((unsigned __int8 *)&TIFFFaxWhiteTable + 8 * v29 + 1);
        v11 -= v30;
        v12 >>= v30;
        switch(8 * v29)
        {
          case 0:
          case 0x24:
            goto LABEL_68;
          case 1:
          case 0x14:
          case 0x2CLL:
          case 0x30:
            int v31 = *((_DWORD *)&TIFFFaxWhiteTable + 2 * v29 + 1);
            v25 += v31;
            v27 += v31;
            continue;
          case 8:
          case 0x10:
          case 0x18:
          case 0x20:
          case 0x28:
            if (v26 >= &v20[*(unsigned int *)(v8 + 104)]) {
              goto LABEL_127;
            }
            int v32 = *((_DWORD *)&TIFFFaxWhiteTable + 2 * v29 + 1);
            int v33 = v32 + v27;
            *uint64_t v26 = v32 + v27;
            unsigned int v34 = v26 + 1;
            v25 += v32;
            if (v25 >= (int)v17) {
              goto LABEL_98;
            }
            int v27 = 0;
            break;
          default:
            uint64_t v42 = v26;
            TIFFErrorExtR((uint64_t)v67, "Fax3Decode1D", "Bad code word at line %u of %s %u (x %u)", v17, a5, a6, a7, a8, *(_DWORD *)(v8 + 152));
            uint64_t v26 = v42;
            uint64_t v17 = v68;
            size_t v20 = v69;
            int v43 = 0;
            goto LABEL_69;
        }
        break;
      }
      while (2)
      {
        if (v11 > 12) {
          goto LABEL_57;
        }
        if ((unint64_t)v21 >= v19)
        {
          if (!v11) {
            goto LABEL_102;
          }
          int v11 = 13;
        }
        else
        {
          v12 |= *(unsigned __int8 *)(v18 + *v21) << v11;
          if (v11 > 4)
          {
            v11 += 8;
          }
          else
          {
            if ((unint64_t)(v21 + 1) < v19)
            {
              uint64_t v35 = v21[1];
              v21 += 2;
              v12 |= *(unsigned __int8 *)(v18 + v35) << (v11 + 8);
              v11 += 16;
              goto LABEL_57;
            }
            int v11 = 13;
          }
          ++v21;
        }
LABEL_57:
        uint64_t v36 = v12 & 0x1FFF;
        int v37 = (unsigned __int8 *)&TIFFFaxBlackTable + 8 * v36;
        int v38 = v37[1];
        v11 -= v38;
        v12 >>= v38;
        int v39 = *v37;
        if ((v39 - 10) < 2)
        {
          int v40 = *((_DWORD *)&TIFFFaxBlackTable + 2 * v36 + 1);
          v25 += v40;
          v27 += v40;
          continue;
        }
        break;
      }
      if (v39 == 12)
      {
        ++v26;
LABEL_68:
        int v43 = 1;
LABEL_69:
        int v64 = v43;
        if (v27)
        {
          if (v26 >= &v20[*(unsigned int *)(v8 + 104)]) {
            goto LABEL_127;
          }
          *v26++ = v27;
        }
        unsigned int v34 = v26;
        goto LABEL_73;
      }
      if (v39 != 8)
      {
        TIFFErrorExtR((uint64_t)v67, "Fax3Decode1D", "Bad code word at line %u of %s %u (x %u)", v17, a5, a6, a7, a8, *(_DWORD *)(v8 + 152));
        uint64_t v17 = v68;
        size_t v20 = v69;
        int v43 = 0;
        uint64_t v26 = v34;
        goto LABEL_69;
      }
      if (v34 >= &v20[*(unsigned int *)(v8 + 104)]) {
        goto LABEL_127;
      }
      int v41 = *((_DWORD *)&TIFFFaxBlackTable + 2 * v36 + 1);
      unsigned int v34 = v26 + 2;
      v26[1] = v41 + v27;
      v25 += v41;
      if (v25 < (int)v17)
      {
        if ((v41 + v27) | v33) {
          v26 += 2;
        }
        continue;
      }
      break;
    }
LABEL_98:
    int v64 = 0;
LABEL_73:
    if (v25 == v17) {
      goto LABEL_95;
    }
    int v44 = "Premature EOL";
    if (v25 >= v17) {
      int v44 = "Line length mismatch";
    }
    TIFFWarningExtR((uint64_t)v67, "Fax3Decode1D", "%s at line %u of %s %u (got %u, expected %u)", v17, a5, a6, a7, a8, (char)v44);
    BOOL v45 = v25 > (int)v68;
    if (v25 <= (int)v68)
    {
      int v46 = v69;
    }
    else
    {
      int v46 = v69;
      if (v34 > v69)
      {
        BOOL v47 = v34 - 1;
        char v48 = v34 - 1;
        do
        {
          int v49 = *v48--;
          v25 -= v49;
          BOOL v45 = v25 > (int)v68;
          BOOL v50 = v25 > (int)v68 && v47 > v69;
          BOOL v47 = v48;
        }
        while (v50);
        unsigned int v34 = v48 + 1;
      }
    }
    if (v25 >= (int)v68)
    {
      if (v45)
      {
        if (v34 >= &v46[*(unsigned int *)(v8 + 104)]) {
          goto LABEL_127;
        }
        *unsigned int v34 = v68;
        if (v34 + 1 >= &v46[*(unsigned int *)(v8 + 104)]) {
          goto LABEL_127;
        }
        v34[1] = 0;
        v34 += 2;
      }
LABEL_95:
      (*(void (**)(uint64_t, int *, int *, uint64_t))(v8 + 88))(v65, v69, v34, v68);
      uint64_t v17 = v68;
      size_t v20 = v69;
      uint64_t v51 = *(void *)(v8 + 8);
      a2 = v65 + v51;
      ++*(_DWORD *)(v8 + 152);
      uint64_t v10 = v66 - v51;
      int v13 = v64;
      if (v66 <= v51)
      {
        a1 = v67;
        uint64_t v14 = v67[144];
        uint64_t v15 = v67[145];
LABEL_100:
        *(_DWORD *)(v8 + 72) = v12;
        *(_DWORD *)(v8 + 76) = v11;
        *(_DWORD *)(v8 + 80) = v13;
        a1[145] = v14 - (void)v21 + v15;
        a1[144] = v21;
        return 1;
      }
      continue;
    }
    break;
  }
  if (((v34 - v46) & 4) == 0) {
    goto LABEL_89;
  }
  if (v34 < &v46[*(unsigned int *)(v8 + 104)])
  {
    *v34++ = 0;
LABEL_89:
    if (v34 < &v46[*(unsigned int *)(v8 + 104)])
    {
      *v34++ = v68 - (v25 & ~(v25 >> 31));
      goto LABEL_95;
    }
  }
LABEL_127:
  uint64_t v62 = v67[150];
LABEL_140:
  TIFFErrorExt(v62, "Fax3Decode1D", "Buffer overflow at line %u of %s %u", v17, a5, a6, a7, a8, *(_DWORD *)(v8 + 152));
  return 0xFFFFFFFFLL;
}

uint64_t Fax3PreEncode(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1096);
  if (!v1) {
    Fax3PreEncode_cold_1();
  }
  *(void *)(v1 + 72) = 0x800000000;
  *(_DWORD *)(v1 + 128) = 0;
  uint64_t v3 = *(void **)(v1 + 136);
  if (v3) {
    _TIFFmemset(v3, 0, *(void *)(v1 + 8));
  }
  if (*(unsigned char *)(v1 + 32))
  {
    float v6 = *(float *)(a1 + 164);
    if (*(_WORD *)(a1 + 168) == 3) {
      float v6 = v6 * 2.54;
    }
    if (v6 <= 150.0) {
      int v4 = 2;
    }
    else {
      int v4 = 4;
    }
    int v5 = v4 - 1;
  }
  else
  {
    int v4 = 0;
    int v5 = 0;
  }
  *(_DWORD *)(v1 + 144) = v5;
  *(_DWORD *)(v1 + 148) = v4;
  *(_DWORD *)(v1 + 152) = 0;
  return 1;
}

uint64_t Fax3PostEncode(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[137];
  if (*(_DWORD *)(v8 + 76) == 8) {
    return 1;
  }
  if (a1[145] < a1[141] || (uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8), result))
  {
    char v11 = *(_DWORD *)(v8 + 72);
    unsigned int v12 = (unsigned char *)a1[144];
    a1[144] = v12 + 1;
    *unsigned int v12 = v11;
    ++a1[145];
    *(void *)(v8 + 72) = 0x800000000;
    return 1;
  }
  return result;
}

uint64_t Fax3Encode(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1[137];
  if (a3 % *(void *)(v9 + 8))
  {
    TIFFErrorExtR((uint64_t)a1, "Fax3Encode", "Fractional scanlines cannot be written", a4, a5, a6, a7, a8, v31);
    return 0;
  }
  uint64_t v11 = a3;
  if (a3 < 1) {
    return 1;
  }
  unsigned int v12 = (char *)a2;
  while ((*(unsigned char *)(v9 + 4) & 2) != 0)
  {
LABEL_36:
    if ((*(unsigned char *)(v9 + 32) & 1) == 0)
    {
      uint64_t result = Fax3Encode1DRow(a1, (uint64_t)v12, *(_DWORD *)(v9 + 16), a4, a5, a6, a7, a8);
      if (!result) {
        return result;
      }
      goto LABEL_46;
    }
    if (*(_DWORD *)(v9 + 128))
    {
      uint64_t result = Fax3Encode2DRow(a1, v12, *(char **)(v9 + 136), *(unsigned int *)(v9 + 16), a5, a6, a7, a8);
      if (!result) {
        return result;
      }
      int v28 = *(_DWORD *)(v9 + 144) - 1;
      *(_DWORD *)(v9 + 144) = v28;
      if (!v28) {
        goto LABEL_45;
      }
    }
    else
    {
      uint64_t result = Fax3Encode1DRow(a1, (uint64_t)v12, *(_DWORD *)(v9 + 16), a4, a5, a6, a7, a8);
      if (!result) {
        return result;
      }
      *(_DWORD *)(v9 + 128) = 1;
      if (!*(_DWORD *)(v9 + 144))
      {
LABEL_45:
        *(_DWORD *)(v9 + 128) = 0;
        *(_DWORD *)(v9 + 144) = *(_DWORD *)(v9 + 148) - 1;
        goto LABEL_46;
      }
    }
    _TIFFmemcpy(*(void **)(v9 + 136), v12, *(void *)(v9 + 8));
LABEL_46:
    uint64_t v29 = *(void *)(v9 + 8);
    v12 += v29;
    uint64_t result = 1;
    BOOL v30 = v11 <= v29;
    v11 -= v29;
    if (v30) {
      return result;
    }
  }
  uint64_t v13 = a1[137];
  int v15 = *(_DWORD *)(v13 + 72);
  int v14 = *(_DWORD *)(v13 + 76);
  if ((*(unsigned char *)(v13 + 32) & 4) == 0 || v14 == 4) {
    goto LABEL_23;
  }
  int v16 = v14 < 4 ? 4 : -4;
  unsigned int v17 = v16 + v14;
  if (v16 + v14 <= v14)
  {
    if (v17 >= 9) {
      Fax3Encode_cold_2();
    }
  }
  else
  {
    uint64_t v18 = a1[145];
    do
    {
      if (v18 >= a1[141])
      {
        uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
        if (!result) {
          return result;
        }
      }
      v17 -= v14;
      unint64_t v19 = (unsigned char *)a1[144];
      a1[144] = v19 + 1;
      *unint64_t v19 = v15;
      uint64_t v18 = a1[145] + 1;
      a1[145] = v18;
      int v14 = 8;
      LOBYTE(v15) = 0;
    }
    while (v17 > 8);
    LOBYTE(v15) = 0;
  }
  v14 -= v17;
  if (v14)
  {
LABEL_23:
    if (*(unsigned char *)(v13 + 32))
    {
      unsigned int v22 = (*(_DWORD *)(v13 + 128) == 0) | 2;
      unsigned int v21 = 13;
    }
    else
    {
      unsigned int v21 = 12;
      unsigned int v22 = 1;
    }
    if (v21 <= v14) {
      Fax3Encode_cold_1();
    }
    uint64_t v23 = a1[145];
    do
    {
      if (v23 >= a1[141])
      {
        uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
        if (!result) {
          return result;
        }
      }
      v21 -= v14;
      char v24 = (unsigned char *)a1[144];
      a1[144] = v24 + 1;
      *char v24 = (v22 >> v21) | v15;
      uint64_t v23 = a1[145] + 1;
      a1[145] = v23;
      int v14 = 8;
      LOBYTE(v15) = 0;
    }
    while (v21 > 8);
    int v25 = 8 - v21;
    int v26 = (_msbmask[v21] & v22) << (8 - v21);
    if (v21 == 8)
    {
      if (v23 >= a1[141])
      {
        uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
        if (!result) {
          return result;
        }
      }
      int v27 = (unsigned char *)a1[144];
      a1[144] = v27 + 1;
      unsigned char *v27 = v26;
      ++a1[145];
      int v25 = 8;
      int v26 = 0;
    }
    *(_DWORD *)(v13 + 72) = v26;
    *(_DWORD *)(v13 + 76) = v25;
    goto LABEL_36;
  }
  if (a1[145] < a1[141] || (uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8), result))
  {
    size_t v20 = (unsigned char *)a1[144];
    a1[144] = v20 + 1;
    unsigned char *v20 = v15;
    ++a1[145];
    int v14 = 8;
    LOBYTE(v15) = 0;
    goto LABEL_23;
  }
  return result;
}

double Fax3Close(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[137];
  if ((*(unsigned char *)(v8 + 4) & 1) == 0 && a1[144])
  {
    if (*(unsigned char *)(v8 + 32))
    {
      uint64_t v11 = (*(_DWORD *)(v8 + 128) == 0) | 2u;
      uint64_t v10 = 13;
    }
    else
    {
      uint64_t v10 = 12;
      uint64_t v11 = 1;
    }
    int v12 = 6;
    do
    {
      Fax3PutBits(a1, v11, v10, a4, a5, a6, a7, a8);
      --v12;
    }
    while (v12);
    if (a1[145] < a1[141] || TIFFFlushData1((uint64_t)a1, v13, v14, a4, a5, a6, a7, a8))
    {
      char v16 = *(_DWORD *)(v8 + 72);
      unsigned int v17 = (unsigned char *)a1[144];
      a1[144] = v17 + 1;
      *unsigned int v17 = v16;
      ++a1[145];
      *(void *)&double result = 0x800000000;
      *(void *)(v8 + 72) = 0x800000000;
    }
  }
  return result;
}

uint64_t Fax3Cleanup(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 1096);
  if (!v1) {
    Fax3Cleanup_cold_1();
  }
  uint64_t v3 = v1[6];
  *(void *)(a1 + 1288) = v1[5];
  *(void *)(a1 + 1280) = v3;
  *(void *)(a1 + 1296) = v1[7];
  int v4 = (char *)v1[12];
  if (v4) {
    _TIFFfreeExt(a1, v4);
  }
  int v5 = (char *)v1[17];
  if (v5) {
    _TIFFfreeExt(a1, v5);
  }
  _TIFFfreeExt(a1, *(char **)(a1 + 1096));
  *(void *)(a1 + 1096) = 0;

  return _TIFFSetDefaultCompressionState(a1);
}

uint64_t Fax3Decode2D(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1;
  uint64_t v9 = a1[137];
  if (a3 % *(void *)(v9 + 8))
  {
    TIFFErrorExtR((uint64_t)a1, "Fax3Decode2D", "Fractional scanlines cannot be read", a4, (uint64_t)a5, a6, a7, a8, v154);
    return 0xFFFFFFFFLL;
  }
  uint64_t v11 = a3;
  unsigned int v13 = *(_DWORD *)(v9 + 72);
  int v12 = *(_DWORD *)(v9 + 76);
  int v14 = *(_DWORD *)(v9 + 80);
  uint64_t v15 = a1[144];
  uint64_t v16 = a1[145];
  if (a3 < 1)
  {
    unsigned int v22 = (unsigned __int8 *)a1[144];
    goto LABEL_285;
  }
  unint64_t v18 = v15 + v16;
  uint64_t v19 = *(unsigned int *)(v9 + 16);
  uint64_t v20 = *(void *)(v9 + 64);
  unsigned int v21 = *(int **)(v9 + 120);
  unsigned int v22 = (unsigned __int8 *)a1[144];
  uint64_t v161 = v19;
  while (2)
  {
    if (!v14)
    {
      while (1)
      {
        if (v12 > 10) {
          goto LABEL_19;
        }
        if ((unint64_t)v22 >= v18)
        {
          if (!v12)
          {
            int v14 = 0;
LABEL_287:
            if (v19)
            {
LABEL_288:
              unsigned int v136 = v21;
              TIFFWarningExtR((uint64_t)v8, "Fax3Decode2D", "%s at line %u of %s %u (got %u, expected %u)", v19, (uint64_t)a5, a6, a7, a8, (char)"Premature EOL");
              uint64_t v19 = v161;
              int v137 = *(_DWORD *)(v9 + 104);
              if ((int)v161 < 1)
              {
                if (v137)
                {
                  unsigned int v21 = v136;
                  *unsigned int v136 = v161;
                  if (*(_DWORD *)(v9 + 104) > 1u)
                  {
                    int v138 = v136 + 2;
                    v136[1] = 0;
                    goto LABEL_342;
                  }
                }
              }
              else if (v137)
              {
                unsigned int v21 = v136;
                *unsigned int v136 = v161;
                int v138 = v136 + 1;
                goto LABEL_342;
              }
              goto LABEL_336;
            }
LABEL_341:
            int v138 = v21;
            goto LABEL_342;
          }
          int v12 = 11;
        }
        else
        {
          v13 |= *(unsigned __int8 *)(v20 + *v22) << v12;
          if (v12 > 2)
          {
            v12 += 8;
          }
          else
          {
            if ((unint64_t)(v22 + 1) < v18)
            {
              uint64_t v23 = v22[1];
              v22 += 2;
              v13 |= *(unsigned __int8 *)(v20 + v23) << (v12 + 8);
              v12 += 16;
              goto LABEL_19;
            }
            int v12 = 11;
          }
          ++v22;
        }
LABEL_19:
        if ((v13 & 0x7FF) == 0) {
          goto LABEL_22;
        }
        --v12;
        v13 >>= 1;
      }
    }
    while (1)
    {
LABEL_22:
      if (v12 <= 7)
      {
        if ((unint64_t)v22 >= v18)
        {
          if (!v12) {
            goto LABEL_287;
          }
          int v12 = 8;
        }
        else
        {
          unsigned int v24 = *v22++;
          v13 |= *(unsigned __int8 *)(v20 + v24) << v12;
          v12 += 8;
        }
      }
      if ((_BYTE)v13) {
        break;
      }
      v12 -= 8;
      v13 >>= 8;
    }
    if ((v13 & 1) == 0)
    {
      do
      {
        char v25 = v13;
        --v12;
        v13 >>= 1;
      }
      while ((v25 & 2) == 0);
    }
    unsigned int v26 = v13 >> 1;
    int v27 = v12 - 1;
    if (v12 <= 1)
    {
      if ((unint64_t)v22 >= v18)
      {
        if (v12 == 1)
        {
          int v14 = 0;
          v13 >>= 1;
          if (v19) {
            goto LABEL_288;
          }
          goto LABEL_341;
        }
        int v27 = 1;
      }
      else
      {
        unsigned int v28 = *v22++;
        v26 |= *(unsigned __int8 *)(v20 + v28) << v27;
        int v27 = v12 + 7;
      }
    }
    int v12 = v27 - 1;
    unsigned int v13 = v26 >> 1;
    uint64_t v159 = a2;
    if (v26)
    {
      uint64_t v31 = 0;
      uint64_t v89 = v21;
      uint64_t v158 = v11;
LABEL_163:
      int v90 = 0;
      while (2)
      {
        if (v12 > 11) {
          goto LABEL_174;
        }
        if ((unint64_t)v22 >= v18)
        {
          if (!v12)
          {
            uint64_t v139 = v89;
            uint64_t v140 = v21;
            goto LABEL_297;
          }
          int v12 = 12;
          goto LABEL_174;
        }
        v13 |= *(unsigned __int8 *)(v20 + *v22) << v12;
        if (v12 > 3)
        {
          v12 += 8;
        }
        else
        {
          if ((unint64_t)(v22 + 1) < v18)
          {
            uint64_t v91 = v22[1];
            v22 += 2;
            v13 |= *(unsigned __int8 *)(v20 + v91) << (v12 + 8);
            v12 += 16;
            goto LABEL_174;
          }
          int v12 = 12;
        }
        ++v22;
LABEL_174:
        uint64_t v92 = v13 & 0xFFF;
        int v93 = *((unsigned __int8 *)&TIFFFaxWhiteTable + 8 * v92 + 1);
        v12 -= v93;
        v13 >>= v93;
        switch(8 * v92)
        {
          case 0:
          case 0x24:
            int v109 = 1;
            goto LABEL_203;
          case 1:
          case 0x14:
          case 0x2CLL:
          case 0x30:
            int v94 = *((_DWORD *)&TIFFFaxWhiteTable + 2 * v92 + 1);
            uint64_t v31 = (v94 + v31);
            v90 += v94;
            continue;
          case 8:
          case 0x10:
          case 0x18:
          case 0x20:
          case 0x28:
            if (v89 >= &v21[*(unsigned int *)(v9 + 104)]) {
              goto LABEL_314;
            }
            int v95 = *((_DWORD *)&TIFFFaxWhiteTable + 2 * v92 + 1);
            int v96 = v95 + v90;
            *uint64_t v89 = v95 + v90;
            a5 = v89 + 1;
            uint64_t v31 = (v95 + v31);
            if ((int)v31 >= (int)v19) {
              goto LABEL_264;
            }
            int v90 = 0;
            break;
          default:
            char v155 = *(_DWORD *)(v9 + 152);
            uint64_t v105 = v21;
            uint64_t v106 = v20;
            uint64_t v107 = v9;
            uint64_t v108 = v89;
            TIFFErrorExtR((uint64_t)a1, "Fax3Decode2D", "Bad code word at line %u of %s %u (x %u)", v19, (uint64_t)a5, a6, a7, a8, v155);
            uint64_t v89 = v108;
            uint64_t v9 = v107;
            uint64_t v20 = v106;
            unsigned int v21 = v105;
            uint64_t v19 = v161;
            int v109 = 0;
            goto LABEL_203;
        }
        break;
      }
      while (1)
      {
        if (v12 > 12) {
          goto LABEL_189;
        }
        if ((unint64_t)v22 >= v18)
        {
          if (!v12)
          {
            uint64_t v140 = v21;
            uint64_t v139 = v89 + 1;
LABEL_297:
            TIFFWarningExtR((uint64_t)a1, "Fax3Decode2D", "Premature EOF at line %u of %s %u (x %u)", v19, (uint64_t)a5, a6, a7, a8, *(_DWORD *)(v9 + 152));
            if (v90)
            {
              uint64_t v19 = v161;
              if (v139 >= &v140[*(unsigned int *)(v9 + 104)]) {
                goto LABEL_314;
              }
              unsigned int v21 = v140;
              *uint64_t v139 = v90;
              int v138 = v139 + 1;
            }
            else
            {
              LODWORD(v19) = v161;
              unsigned int v21 = v140;
              int v138 = v139;
            }
            uint64_t v8 = a1;
            if (v31 == v19) {
              goto LABEL_338;
            }
            int v143 = v138;
            int v144 = v21;
            Fax3BadLength("Fax3Decode2D", (uint64_t)a1, *(unsigned int *)(v9 + 152), v31, v161, a6, a7, a8);
            uint64_t v19 = v161;
            BOOL v145 = (int)v31 > (int)v161;
            if ((int)v31 <= (int)v161) {
              goto LABEL_325;
            }
            unsigned int v21 = v144;
            int v138 = v143;
            if (v143 > v144)
            {
              uint64_t v146 = v143 - 1;
              int v147 = v143 - 1;
              do
              {
                int v148 = *v147--;
                LODWORD(v31) = v31 - v148;
                BOOL v145 = (int)v31 > (int)v161;
                BOOL v149 = (int)v31 > (int)v161 && v146 > v144;
                uint64_t v146 = v147;
              }
              while (v149);
LABEL_324:
              int v138 = v147 + 1;
            }
LABEL_326:
            if ((int)v31 >= (int)v19)
            {
              if (!v145) {
                goto LABEL_338;
              }
              a2 = v159;
              if (v138 < &v21[*(unsigned int *)(v9 + 104)])
              {
                *int v138 = v19;
                if (v138 + 1 < &v21[*(unsigned int *)(v9 + 104)])
                {
                  int v14 = 0;
                  v138[1] = 0;
                  v138 += 2;
                  goto LABEL_342;
                }
              }
            }
            else
            {
              if (((v138 - v21) & 4) != 0)
              {
                if (v138 >= &v21[*(unsigned int *)(v9 + 104)]) {
                  goto LABEL_336;
                }
                *v138++ = 0;
              }
              if (v138 < &v21[*(unsigned int *)(v9 + 104)])
              {
                int v14 = 0;
                *v138++ = v19 - (v31 & ~((int)v31 >> 31));
                goto LABEL_339;
              }
            }
LABEL_336:
            uint64_t v150 = v8[150];
            goto LABEL_337;
          }
          int v12 = 13;
        }
        else
        {
          v13 |= *(unsigned __int8 *)(v20 + *v22) << v12;
          if (v12 > 4)
          {
            v12 += 8;
          }
          else
          {
            if ((unint64_t)(v22 + 1) < v18)
            {
              uint64_t v97 = v22[1];
              v22 += 2;
              v13 |= *(unsigned __int8 *)(v20 + v97) << (v12 + 8);
              v12 += 16;
              goto LABEL_189;
            }
            int v12 = 13;
          }
          ++v22;
        }
LABEL_189:
        uint64_t v98 = v13 & 0x1FFF;
        CFMutableArrayRef v99 = (unsigned __int8 *)&TIFFFaxBlackTable + 8 * v98;
        int v100 = v99[1];
        v12 -= v100;
        v13 >>= v100;
        int v101 = *v99;
        if ((v101 - 10) >= 2)
        {
          if (v101 == 12)
          {
            int v109 = 1;
            ++v89;
          }
          else
          {
            if (v101 == 8)
            {
              if (a5 >= &v21[*(unsigned int *)(v9 + 104)]) {
                goto LABEL_314;
              }
              int v103 = *((_DWORD *)&TIFFFaxBlackTable + 2 * v98 + 1);
              a5 = v89 + 2;
              v89[1] = v103 + v90;
              uint64_t v31 = (v103 + v31);
              if ((int)v31 < (int)v19)
              {
                if ((v103 + v90) | v96) {
                  v89 += 2;
                }
                goto LABEL_163;
              }
LABEL_264:
              int v109 = 0;
LABEL_207:
              int v156 = v109;
              uint64_t v8 = a1;
              if (v31 == v19) {
                goto LABEL_259;
              }
              uint64_t v112 = a5;
              uint64_t v113 = v21;
              uint64_t v114 = "Premature EOL";
              if (v31 >= v19) {
                uint64_t v114 = "Line length mismatch";
              }
              TIFFWarningExtR((uint64_t)a1, "Fax3Decode2D", "%s at line %u of %s %u (got %u, expected %u)", v19, (uint64_t)a5, a6, a7, a8, (char)v114);
              uint64_t v19 = v161;
              BOOL v115 = (int)v31 > (int)v161;
              if ((int)v31 <= (int)v161) {
                goto LABEL_248;
              }
              unsigned int v21 = v113;
              a5 = v112;
              if (v112 > v113)
              {
                uint64_t v116 = v112 - 1;
                uint64_t v117 = v112 - 1;
                do
                {
                  int v118 = *v117--;
                  LODWORD(v31) = v31 - v118;
                  BOOL v115 = (int)v31 > (int)v161;
                  BOOL v119 = (int)v31 > (int)v161 && v116 > v113;
                  uint64_t v116 = v117;
                }
                while (v119);
LABEL_247:
                a5 = v117 + 1;
              }
LABEL_249:
              if ((int)v31 >= (int)v19)
              {
                if (!v115) {
                  goto LABEL_259;
                }
                uint64_t v128 = v159;
                if (a5 < &v21[*(unsigned int *)(v9 + 104)])
                {
                  *a5 = v19;
                  if (a5 + 1 < &v21[*(unsigned int *)(v9 + 104)])
                  {
                    a5[1] = 0;
                    a5 += 2;
                    goto LABEL_260;
                  }
                }
              }
              else if (((a5 - v21) & 4) != 0)
              {
                if (a5 < &v21[*(unsigned int *)(v9 + 104)])
                {
                  *a5++ = 0;
                  goto LABEL_253;
                }
              }
              else
              {
LABEL_253:
                if (a5 < &v21[*(unsigned int *)(v9 + 104)])
                {
                  *a5++ = v19 - (v31 & ~((int)v31 >> 31));
                  goto LABEL_259;
                }
              }
              goto LABEL_336;
            }
            uint64_t v110 = v21;
            uint64_t v111 = v89 + 1;
            Fax3Unexpected("Fax3Decode2D", (uint64_t)a1, *(_DWORD *)(v9 + 152), v31, (uint64_t)a5, a6, a7, a8);
            unsigned int v21 = v110;
            uint64_t v19 = v161;
            int v109 = 0;
            uint64_t v89 = v111;
          }
LABEL_203:
          if (v90)
          {
            if (v89 >= &v21[*(unsigned int *)(v9 + 104)]) {
              goto LABEL_314;
            }
            *v89++ = v90;
          }
          a5 = v89;
          goto LABEL_207;
        }
        int v102 = *((_DWORD *)&TIFFFaxBlackTable + 2 * v98 + 1);
        uint64_t v31 = (v102 + v31);
        v90 += v102;
      }
    }
    if ((int)v19 < 1)
    {
      int v104 = 0;
      LODWORD(v31) = 0;
      a5 = v21;
      goto LABEL_237;
    }
    int v29 = 0;
    int i = 0;
    uint64_t v31 = 0;
    int v32 = *(unsigned int **)(v9 + 112);
    unsigned int v34 = v32 + 1;
    uint64_t v33 = *v32;
    a5 = v21;
LABEL_38:
    uint64_t v35 = *(unsigned int *)(v9 + 104);
    if (a5 >= &v21[v35]) {
      goto LABEL_314;
    }
    if (v12 <= 6)
    {
      if ((unint64_t)v22 >= v18)
      {
        if (!v12) {
          goto LABEL_295;
        }
        int v12 = 7;
      }
      else
      {
        unsigned int v36 = *v22++;
        v13 |= *(unsigned __int8 *)(v20 + v36) << v12;
        v12 += 8;
      }
    }
    uint64_t v37 = v13 & 0x7F;
    int v38 = *((unsigned __int8 *)&TIFFFaxMainTable + 8 * v37 + 1);
    v12 -= v38;
    v13 >>= v38;
    switch(8 * v37)
    {
      case 0:
      case 0x400:
      case 0x424:
        *a5++ = v19 - v31;
        size_t v157 = a5;
        if (v12 <= 3)
        {
          if ((unint64_t)v22 >= v18)
          {
            if (!v12) {
              goto LABEL_295;
            }
            int v12 = 4;
          }
          else
          {
            unsigned int v134 = *v22++;
            v13 |= *(unsigned __int8 *)(v20 + v134) << v12;
            v12 += 8;
          }
        }
        if ((v13 & 0xF) != 0)
        {
          unsigned int v135 = v21;
          Fax3Unexpected("Fax3Decode2D", (uint64_t)a1, *(_DWORD *)(v9 + 152), v31, (uint64_t)a5, a6, a7, a8);
          unsigned int v21 = v135;
        }
        v12 -= 4;
        v13 >>= 4;
        int v123 = 1;
        goto LABEL_231;
      case 8:
      case 0x11:
      case 0x18:
      case 0x21:
      case 0x28:
      case 0x31:
      case 0x38:
      case 0x48:
      case 0x51:
      case 0x58:
      case 0x61:
      case 0x68:
      case 0x71:
      case 0x78:
      case 0x88:
      case 0x91:
      case 0x98:
      case 0xA1:
      case 0xA8:
      case 0xB1:
      case 0xB8:
      case 0xC8:
      case 0xD1:
      case 0xD8:
      case 0xE1:
      case 0xE8:
      case 0xF1:
      case 0xF8:
      case 0x104:
      case 0x108:
      case 0x111:
      case 0x118:
      case 0x121:
      case 0x128:
      case 0x131:
      case 0x138:
      case 0x148:
      case 0x151:
      case 0x158:
      case 0x161:
      case 0x168:
      case 0x171:
      case 0x178:
      case 0x188:
      case 0x191:
      case 0x198:
      case 0x1A1:
      case 0x1A8:
      case 0x1B1:
      case 0x1B8:
      case 0x1C8:
      case 0x1D1:
      case 0x1D8:
      case 0x1E1:
      case 0x1E8:
      case 0x1F1:
      case 0x1F8:
      case 0x208:
      case 0x211:
      case 0x218:
      case 0x221:
      case 0x228:
      case 0x231:
      case 0x238:
      case 0x248:
      case 0x251:
      case 0x258:
      case 0x261:
      case 0x268:
      case 0x271:
      case 0x278:
      case 0x288:
      case 0x291:
      case 0x298:
      case 0x2A1:
      case 0x2A8:
      case 0x2B1:
      case 0x2B8:
      case 0x2C8:
      case 0x2D1:
      case 0x2D8:
      case 0x2E1:
      case 0x2E8:
      case 0x2F1:
      case 0x2F8:
      case 0x304:
      case 0x308:
      case 0x311:
      case 0x318:
      case 0x321:
      case 0x328:
      case 0x331:
      case 0x338:
      case 0x348:
      case 0x351:
      case 0x358:
      case 0x361:
      case 0x368:
      case 0x371:
      case 0x378:
      case 0x388:
      case 0x391:
      case 0x398:
      case 0x3A1:
      case 0x3A8:
      case 0x3B1:
      case 0x3B8:
      case 0x3C8:
      case 0x3D1:
      case 0x3D8:
      case 0x3E1:
      case 0x3E8:
      case 0x3F1:
      case 0x3F8:
      case 0x40CLL:
        if (a5 == v21 || (int)v33 > (int)v31) {
          goto LABEL_88;
        }
        int v55 = &v32[v35];
        BOOL v56 = v34 + 1;
        do
        {
          if (v56 >= v55) {
            goto LABEL_314;
          }
          uint64_t v33 = *(v56 - 1) + v33 + *v56;
          v56 += 2;
        }
        while ((int)v33 <= (int)v31);
        unsigned int v34 = v56 - 1;
LABEL_88:
        *a5 = i + v29 + v33;
        if (v34 >= &v32[*(unsigned int *)(v9 + 104)]) {
          goto LABEL_314;
        }
        int i = 0;
        ++a5;
        int v58 = *v34++;
        int v57 = v58;
        uint64_t v31 = v33;
        goto LABEL_98;
      case 9:
      case 0x14:
      case 0x19:
      case 0x29:
      case 0x34:
      case 0x39:
      case 0x40:
      case 0x49:
      case 0x54:
      case 0x59:
      case 0x69:
      case 0x74:
      case 0x79:
      case 0x89:
      case 0x94:
      case 0x99:
      case 0xA9:
      case 0xB4:
      case 0xB9:
      case 0xC0:
      case 0xC9:
      case 0xD4:
      case 0xD9:
      case 0xE9:
      case 0xF4:
      case 0xF9:
      case 0x109:
      case 0x114:
      case 0x119:
      case 0x129:
      case 0x134:
      case 0x139:
      case 0x140:
      case 0x149:
      case 0x154:
      case 0x159:
      case 0x169:
      case 0x174:
      case 0x179:
      case 0x189:
      case 0x194:
      case 0x199:
      case 0x1A9:
      case 0x1B4:
      case 0x1B9:
      case 0x1C0:
      case 0x1C9:
      case 0x1D4:
      case 0x1D9:
      case 0x1E9:
      case 0x1F4:
      case 0x1F9:
      case 0x209:
      case 0x214:
      case 0x219:
      case 0x229:
      case 0x234:
      case 0x239:
      case 0x240:
      case 0x249:
      case 0x254:
      case 0x259:
      case 0x269:
      case 0x274:
      case 0x279:
      case 0x289:
      case 0x294:
      case 0x299:
      case 0x2A9:
      case 0x2B4:
      case 0x2B9:
      case 0x2C0:
      case 0x2C9:
      case 0x2D4:
      case 0x2D9:
      case 0x2E9:
      case 0x2F4:
      case 0x2F9:
      case 0x309:
      case 0x314:
      case 0x319:
      case 0x329:
      case 0x334:
      case 0x339:
      case 0x340:
      case 0x349:
      case 0x354:
      case 0x359:
      case 0x369:
      case 0x374:
      case 0x379:
      case 0x389:
      case 0x394:
      case 0x399:
      case 0x3A9:
      case 0x3B4:
      case 0x3B9:
      case 0x3C0:
      case 0x3C9:
      case 0x3D4:
      case 0x3D9:
      case 0x3E9:
      case 0x3F4:
      case 0x3F9:
        if (a5 == v21 || (int)v33 > (int)v31) {
          goto LABEL_51;
        }
        int v39 = v34 + 1;
        do
        {
          if (v39 >= &v32[v35]) {
            goto LABEL_314;
          }
          LODWORD(v33) = *(v39 - 1) + v33 + *v39;
          v39 += 2;
        }
        while ((int)v33 <= (int)v31);
        unsigned int v34 = v39 - 1;
LABEL_51:
        if (v34 + 1 >= &v32[v35]) {
          goto LABEL_314;
        }
        unsigned int v40 = *v34;
        unsigned int v41 = v34[1];
        v34 += 2;
        uint64_t v31 = v40 + v33;
        i += v29 + v31;
        uint64_t v33 = v31 + v41;
        goto LABEL_108;
      case 0x10:
      case 0x50:
      case 0x80:
      case 0x90:
      case 0xD0:
      case 0x100:
      case 0x110:
      case 0x150:
      case 0x190:
      case 0x1D0:
      case 0x210:
      case 0x250:
      case 0x280:
      case 0x290:
      case 0x2D0:
      case 0x310:
      case 0x350:
      case 0x390:
      case 0x3D0:
      case 0x411:
      case 0x41CLL:
      case 0x429:
        if (a5 == v21 || (int)v33 > (int)v31) {
          goto LABEL_105;
        }
        char v63 = &v32[v35];
        int v64 = v34 + 1;
        do
        {
          if (v64 >= v63) {
            goto LABEL_314;
          }
          LODWORD(v33) = *(v64 - 1) + v33 + *v64;
          v64 += 2;
        }
        while ((int)v33 <= (int)v31);
        unsigned int v34 = v64 - 1;
LABEL_105:
        int v65 = *((_DWORD *)&TIFFFaxMainTable + 2 * v37 + 1);
        if ((int)v33 >= v65 + (int)v31)
        {
          int v66 = v33 + v29 - v65;
          *a5++ = v66 + i;
          uint64_t v31 = (v66 + v31);
          int v67 = *--v34;
          uint64_t v33 = (v33 - v67);
          goto LABEL_107;
        }
        size_t v157 = a5;
        int v133 = v21;
        Fax3Unexpected("Fax3Decode2D", (uint64_t)a1, *(_DWORD *)(v9 + 152), v31, (uint64_t)a5, a6, a7, a8);
LABEL_271:
        unsigned int v21 = v133;
        int v123 = 0;
        goto LABEL_231;
      case 0x20:
      case 0x60:
      case 0x84:
      case 0xA0:
      case 0xE0:
      case 0x120:
      case 0x160:
      case 0x184:
      case 0x1A0:
      case 0x1E0:
      case 0x220:
      case 0x260:
      case 0x284:
      case 0x2A0:
      case 0x2E0:
      case 0x320:
      case 0x360:
      case 0x384:
      case 0x3A0:
      case 0x3E0:
        if (((a5 - v21) & 4) != 0)
        {
          while (1)
          {
            if (v12 > 12) {
              goto LABEL_80;
            }
            if ((unint64_t)v22 >= v18)
            {
              if (!v12) {
                goto LABEL_295;
              }
              int v12 = 13;
            }
            else
            {
              v13 |= *(unsigned __int8 *)(v20 + *v22) << v12;
              if (v12 > 4)
              {
                v12 += 8;
              }
              else
              {
                if ((unint64_t)(v22 + 1) < v18)
                {
                  uint64_t v49 = v22[1];
                  v22 += 2;
                  v13 |= *(unsigned __int8 *)(v20 + v49) << (v12 + 8);
                  v12 += 16;
                  goto LABEL_80;
                }
                int v12 = 13;
              }
              ++v22;
            }
LABEL_80:
            uint64_t v50 = v13 & 0x1FFF;
            uint64_t v51 = (unsigned __int8 *)&TIFFFaxBlackTable + 8 * v50;
            int v52 = v51[1];
            v12 -= v52;
            v13 >>= v52;
            int v53 = *v51;
            if ((v53 - 10) >= 2) {
              break;
            }
            int v54 = *((_DWORD *)&TIFFFaxBlackTable + 2 * v50 + 1);
            uint64_t v31 = (v54 + v31);
            i += v54;
          }
          if (v53 != 8)
          {
            size_t v157 = a5;
            int v120 = v21;
LABEL_226:
            uint64_t v122 = (uint64_t)a1;
            goto LABEL_229;
          }
          int v76 = *((_DWORD *)&TIFFFaxBlackTable + 2 * v50 + 1);
          *a5 = v76 + i;
          uint64_t v69 = a5 + 1;
          uint64_t v31 = (v76 + v31);
          int i = 0;
          while (2)
          {
            if (v12 > 11) {
              goto LABEL_136;
            }
            if ((unint64_t)v22 >= v18)
            {
              if (!v12)
              {
LABEL_310:
                uint64_t v142 = v21;
                unint64_t v141 = v69;
                goto LABEL_311;
              }
              int v12 = 12;
            }
            else
            {
              v13 |= *(unsigned __int8 *)(v20 + *v22) << v12;
              if (v12 > 3)
              {
                v12 += 8;
              }
              else
              {
                if ((unint64_t)(v22 + 1) < v18)
                {
                  uint64_t v77 = v22[1];
                  v22 += 2;
                  v13 |= *(unsigned __int8 *)(v20 + v77) << (v12 + 8);
                  v12 += 16;
                  goto LABEL_136;
                }
                int v12 = 12;
              }
              ++v22;
            }
LABEL_136:
            uint64_t v78 = v13 & 0xFFF;
            int v79 = (unsigned __int8 *)&TIFFFaxWhiteTable + 8 * v78;
            int v80 = v79[1];
            v12 -= v80;
            v13 >>= v80;
            int v81 = *v79;
            if (v81 == 9 || v81 == 11)
            {
              int v83 = *((_DWORD *)&TIFFFaxWhiteTable + 2 * v78 + 1);
              uint64_t v31 = (v83 + v31);
              i += v83;
              continue;
            }
            break;
          }
          if (v81 != 7)
          {
            int v120 = v21;
            size_t v157 = a5 + 1;
            goto LABEL_228;
          }
          if (v69 >= &v21[*(unsigned int *)(v9 + 104)]) {
            goto LABEL_314;
          }
          uint64_t v84 = (char *)&TIFFFaxWhiteTable + 8 * v78;
LABEL_148:
          int v85 = *((_DWORD *)v84 + 1);
          *uint64_t v69 = v85 + i;
          uint64_t v31 = (v85 + v31);
          a5 += 2;
          if (a5 != v21)
          {
            if ((int)v33 <= (int)v31 && (int)v33 < (int)v19)
            {
              uint64_t v87 = v34 + 1;
              while (v87 < &v32[*(unsigned int *)(v9 + 104)])
              {
                uint64_t v33 = *(v87 - 1) + v33 + *v87;
                v87 += 2;
                if ((int)v33 > (int)v31 || (int)v33 >= (int)v19)
                {
                  int i = 0;
                  unsigned int v34 = v87 - 1;
                  goto LABEL_108;
                }
              }
              uint64_t v150 = a1[150];
              goto LABEL_337;
            }
LABEL_107:
            int i = 0;
            goto LABEL_108;
          }
          int i = 0;
          a5 = v21;
LABEL_108:
          int v29 = -(int)v31;
          if ((int)v31 >= (int)v19)
          {
            if (!i)
            {
              int v104 = 0;
              goto LABEL_235;
            }
            if (i + (int)v31 >= (int)v19) {
              goto LABEL_282;
            }
            if (v12 > 0) {
              goto LABEL_279;
            }
            if ((unint64_t)v22 < v18)
            {
              unsigned int v121 = *v22++;
              v13 |= *(unsigned __int8 *)(v20 + v121) << v12;
              v12 += 8;
              goto LABEL_279;
            }
            if (v12)
            {
              int v12 = 1;
LABEL_279:
              if ((v13 & 1) == 0)
              {
LABEL_280:
                size_t v157 = a5;
                int v120 = v21;
                Fax3Unexpected("Fax3Decode2D", (uint64_t)a1, *(_DWORD *)(v9 + 152), v31, (uint64_t)a5, a6, a7, a8);
                goto LABEL_230;
              }
              --v12;
              v13 >>= 1;
LABEL_282:
              if (a5 >= &v21[*(unsigned int *)(v9 + 104)]) {
                goto LABEL_314;
              }
              int v104 = 0;
LABEL_234:
              *a5++ = i;
LABEL_235:
              uint64_t v8 = a1;
LABEL_237:
              uint64_t v158 = v11;
              int v156 = v104;
              if (v31 != v19)
              {
                uint64_t v112 = a5;
                uint64_t v113 = v21;
                double v124 = "Premature EOL";
                if (v31 >= v19) {
                  double v124 = "Line length mismatch";
                }
                TIFFWarningExtR((uint64_t)v8, "Fax3Decode2D", "%s at line %u of %s %u (got %u, expected %u)", v19, (uint64_t)a5, a6, a7, a8, (char)v124);
                uint64_t v19 = v161;
                BOOL v115 = (int)v31 > (int)v161;
                if ((int)v31 > (int)v161)
                {
                  unsigned int v21 = v113;
                  a5 = v112;
                  if (v112 > v113)
                  {
                    uint64_t v125 = v112 - 1;
                    uint64_t v117 = v112 - 1;
                    do
                    {
                      int v126 = *v117--;
                      LODWORD(v31) = v31 - v126;
                      BOOL v115 = (int)v31 > (int)v161;
                      BOOL v127 = (int)v31 > (int)v161 && v125 > v113;
                      uint64_t v125 = v117;
                    }
                    while (v127);
                    goto LABEL_247;
                  }
                  goto LABEL_249;
                }
LABEL_248:
                unsigned int v21 = v113;
                a5 = v112;
                goto LABEL_249;
              }
LABEL_259:
              uint64_t v128 = v159;
LABEL_260:
              int v129 = v21;
              char v130 = a5;
              (*(void (**)(uint64_t))(v9 + 88))(v128);
              if (v130 < &v129[*(unsigned int *)(v9 + 104)]) {
                *char v130 = 0;
              }
              int8x16_t v131 = *(int8x16_t *)(v9 + 112);
              *(int8x16_t *)(v9 + 112) = vextq_s8(v131, v131, 8uLL);
              uint64_t v132 = *(void *)(v9 + 8);
              a2 = v128 + v132;
              ++*(_DWORD *)(v9 + 152);
              unsigned int v21 = (int *)v131.i64[0];
              uint64_t v11 = v158 - v132;
              uint64_t v19 = v161;
              int v14 = v156;
              if (v158 <= v132)
              {
                uint64_t v15 = v8[144];
                uint64_t v16 = v8[145];
LABEL_285:
                *(_DWORD *)(v9 + 72) = v13;
                *(_DWORD *)(v9 + 76) = v12;
                *(_DWORD *)(v9 + 80) = v14;
                v8[145] = v15 - (void)v22 + v16;
                v8[144] = v22;
                return 1;
              }
              continue;
            }
LABEL_295:
            unint64_t v141 = a5;
            uint64_t v142 = v21;
LABEL_311:
            TIFFWarningExtR((uint64_t)a1, "Fax3Decode2D", "Premature EOF at line %u of %s %u (x %u)", v19, (uint64_t)a5, a6, a7, a8, *(_DWORD *)(v9 + 152));
            if (i)
            {
              uint64_t v19 = v161;
              if (v141 >= &v142[*(unsigned int *)(v9 + 104)]) {
                goto LABEL_314;
              }
              unsigned int v21 = v142;
              int *v141 = i;
              int v138 = v141 + 1;
            }
            else
            {
              int v138 = v141;
              LODWORD(v19) = v161;
              unsigned int v21 = v142;
            }
            uint64_t v8 = a1;
            if (v31 != v19)
            {
              int v143 = v138;
              int v144 = v21;
              Fax3BadLength("Fax3Decode2D", (uint64_t)a1, *(unsigned int *)(v9 + 152), v31, v161, a6, a7, a8);
              uint64_t v19 = v161;
              BOOL v145 = (int)v31 > (int)v161;
              if ((int)v31 > (int)v161)
              {
                unsigned int v21 = v144;
                int v138 = v143;
                if (v143 > v144)
                {
                  uint64_t v151 = v143 - 1;
                  int v147 = v143 - 1;
                  do
                  {
                    int v152 = *v147--;
                    LODWORD(v31) = v31 - v152;
                    BOOL v145 = (int)v31 > (int)v161;
                    BOOL v153 = (int)v31 > (int)v161 && v151 > v144;
                    uint64_t v151 = v147;
                  }
                  while (v153);
                  goto LABEL_324;
                }
                goto LABEL_326;
              }
LABEL_325:
              unsigned int v21 = v144;
              int v138 = v143;
              goto LABEL_326;
            }
LABEL_338:
            int v14 = 0;
LABEL_339:
            a2 = v159;
LABEL_342:
            (*(void (**)(uint64_t, int *, int *))(v9 + 88))(a2, v21, v138);
            *(_DWORD *)(v9 + 72) = v13;
            *(_DWORD *)(v9 + 76) = 0;
            *(_DWORD *)(v9 + 80) = v14;
            v8[145] += v8[144] - (void)v22;
            v8[144] = v22;
            return 0xFFFFFFFFLL;
          }
          goto LABEL_38;
        }
        while (1)
        {
          if (v12 > 11) {
            goto LABEL_64;
          }
          if ((unint64_t)v22 >= v18)
          {
            if (!v12) {
              goto LABEL_295;
            }
            int v12 = 12;
          }
          else
          {
            v13 |= *(unsigned __int8 *)(v20 + *v22) << v12;
            if (v12 > 3)
            {
              v12 += 8;
            }
            else
            {
              if ((unint64_t)(v22 + 1) < v18)
              {
                uint64_t v42 = v22[1];
                v22 += 2;
                v13 |= *(unsigned __int8 *)(v20 + v42) << (v12 + 8);
                v12 += 16;
                goto LABEL_64;
              }
              int v12 = 12;
            }
            ++v22;
          }
LABEL_64:
          uint64_t v43 = v13 & 0xFFF;
          int v44 = (unsigned __int8 *)&TIFFFaxWhiteTable + 8 * v43;
          int v45 = v44[1];
          v12 -= v45;
          v13 >>= v45;
          int v46 = *v44;
          if (v46 != 9 && v46 != 11) {
            break;
          }
          int v48 = *((_DWORD *)&TIFFFaxWhiteTable + 2 * v43 + 1);
          uint64_t v31 = (v48 + v31);
          i += v48;
        }
        if (v46 != 7)
        {
          size_t v157 = a5;
          int v120 = v21;
LABEL_228:
          uint64_t v122 = (uint64_t)a1;
LABEL_229:
          TIFFErrorExtR(v122, "Fax3Decode2D", "Bad code word at line %u of %s %u (x %u)", v19, (uint64_t)a5, a6, a7, a8, *(_DWORD *)(v9 + 152));
LABEL_230:
          int v123 = 0;
          unsigned int v21 = v120;
LABEL_231:
          if (i)
          {
            a5 = v157;
            uint64_t v19 = v161;
            if (v157 >= &v21[*(unsigned int *)(v9 + 104)]) {
              goto LABEL_314;
            }
            int v104 = v123;
            goto LABEL_234;
          }
          uint64_t v8 = a1;
          uint64_t v19 = v161;
          a5 = v157;
          int v104 = v123;
          goto LABEL_237;
        }
        int v68 = *((_DWORD *)&TIFFFaxWhiteTable + 2 * v43 + 1);
        *a5 = v68 + i;
        uint64_t v69 = a5 + 1;
        uint64_t v31 = (v68 + v31);
        for (int i = 0; ; i += v75)
        {
          if (v12 > 12) {
            goto LABEL_122;
          }
          if ((unint64_t)v22 >= v18)
          {
            if (!v12) {
              goto LABEL_310;
            }
            int v12 = 13;
          }
          else
          {
            v13 |= *(unsigned __int8 *)(v20 + *v22) << v12;
            if (v12 > 4)
            {
              v12 += 8;
            }
            else
            {
              if ((unint64_t)(v22 + 1) < v18)
              {
                uint64_t v70 = v22[1];
                v22 += 2;
                v13 |= *(unsigned __int8 *)(v20 + v70) << (v12 + 8);
                v12 += 16;
                goto LABEL_122;
              }
              int v12 = 13;
            }
            ++v22;
          }
LABEL_122:
          uint64_t v71 = v13 & 0x1FFF;
          int v72 = (unsigned __int8 *)&TIFFFaxBlackTable + 8 * v71;
          int v73 = v72[1];
          v12 -= v73;
          v13 >>= v73;
          int v74 = *v72;
          if ((v74 - 10) >= 2) {
            break;
          }
          int v75 = *((_DWORD *)&TIFFFaxBlackTable + 2 * v71 + 1);
          uint64_t v31 = (v75 + v31);
        }
        if (v74 != 8)
        {
          int v120 = v21;
          size_t v157 = a5 + 1;
          goto LABEL_226;
        }
        if (v69 < &v21[*(unsigned int *)(v9 + 104)])
        {
          uint64_t v84 = (char *)&TIFFFaxBlackTable + 8 * v71;
          goto LABEL_148;
        }
LABEL_314:
        uint64_t v150 = a1[150];
LABEL_337:
        TIFFErrorExt(v150, "Fax3Decode2D", "Buffer overflow at line %u of %s %u", v19, (uint64_t)a5, a6, a7, a8, *(_DWORD *)(v9 + 152));
        return 0xFFFFFFFFLL;
      case 0x30:
      case 0x41:
      case 0x70:
      case 0xB0:
      case 0xC1:
      case 0xF0:
      case 0x130:
      case 0x141:
      case 0x170:
      case 0x180:
      case 0x1B0:
      case 0x1C1:
      case 0x1F0:
      case 0x230:
      case 0x241:
      case 0x270:
      case 0x2B0:
      case 0x2C1:
      case 0x2F0:
      case 0x300:
      case 0x330:
      case 0x341:
      case 0x370:
      case 0x380:
      case 0x3B0:
      case 0x3C1:
      case 0x3F0:
      case 0x409:
      case 0x419:
        if (a5 == v21 || (int)v33 > (int)v31) {
          goto LABEL_96;
        }
        int v59 = &v32[v35];
        int v60 = v34 + 1;
        do
        {
          if (v60 >= v59) {
            goto LABEL_314;
          }
          LODWORD(v33) = *(v60 - 1) + v33 + *v60;
          v60 += 2;
        }
        while ((int)v33 <= (int)v31);
        unsigned int v34 = v60 - 1;
LABEL_96:
        int v61 = *((_DWORD *)&TIFFFaxMainTable + 2 * v37 + 1);
        *a5 = i + v29 + v33 + v61;
        if (v34 >= &v32[*(unsigned int *)(v9 + 104)]) {
          goto LABEL_314;
        }
        int i = 0;
        uint64_t v31 = (v61 + v33);
        ++a5;
        int v62 = *v34++;
        int v57 = v62;
LABEL_98:
        uint64_t v33 = (v57 + v33);
        goto LABEL_108;
      case 0x81:
      case 0x181:
      case 0x200:
      case 0x281:
      case 0x381:
      case 0x421:
      case 0x431:
        *a5 = v19 - v31;
        size_t v157 = a5 + 1;
        int v133 = v21;
        Fax3Extension("Fax3Decode2D", (uint64_t)a1, *(_DWORD *)(v9 + 152), v31, (uint64_t)(a5 + 1), a6, a7, a8);
        goto LABEL_271;
      default:
        goto LABEL_280;
    }
  }
}

uint64_t Fax3Unexpected(const char *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return TIFFErrorExtR(a2, a1, "Bad code word at line %u of %s %u (x %u)", a4, a5, a6, a7, a8, a3);
}

uint64_t Fax3BadLength(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = "Line length mismatch";
  if (a4 < a5) {
    uint64_t v8 = "Premature EOL";
  }
  return TIFFWarningExtR(a2, a1, "%s at line %u of %s %u (got %u, expected %u)", a4, a5, a6, a7, a8, (char)v8);
}

uint64_t Fax3Extension(const char *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return TIFFErrorExtR(a2, a1, "Uncompressed data (not supported) at line %u of %s %u (x %u)", a4, a5, a6, a7, a8, a3);
}

uint64_t Fax3Encode1DRow(void *a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = 0;
  int v48 = (_DWORD *)a1[137];
  do
  {
    int v12 = a3 - v11;
    if ((int)(a3 - v11) < 1)
    {
      uint64_t v16 = 0;
      goto LABEL_39;
    }
    unsigned int v13 = (unsigned char *)(a2 + (v11 >> 3));
    int v14 = v11 & 7;
    if ((v11 & 7) != 0)
    {
      unsigned int v15 = zeroruns[(*v13 << v14) & 0xFELL];
      if (8 - v14 < v15) {
        unsigned int v15 = 8 - v14;
      }
      if (v15 >= v12) {
        uint64_t v16 = v12;
      }
      else {
        uint64_t v16 = v15;
      }
      if ((v16 + v14) < 8) {
        goto LABEL_39;
      }
      v12 -= v16;
      ++v13;
    }
    else
    {
      uint64_t v16 = 0;
    }
    if (v12 < 128)
    {
      unsigned int v17 = v13;
      goto LABEL_26;
    }
    if ((v13 & 7) != 0)
    {
      unsigned int v17 = &v13[-(v13 & 7) + 8];
      int v18 = -(int)v16;
      uint64_t v19 = v13 + 1;
      do
      {
        if (*v13)
        {
          int v24 = zeroruns[*v13];
          goto LABEL_38;
        }
        v12 -= 8;
        ++v13;
        v18 -= 8;
      }
      while ((unint64_t)(v19++ & 7));
      uint64_t v16 = -v18;
      if (v12 + 8 > 71) {
        goto LABEL_22;
      }
LABEL_26:
      int v21 = v12;
      if (v12 < 8)
      {
LABEL_32:
        if (v12 >= 1)
        {
          int v23 = zeroruns[*(unsigned __int8 *)v17];
          if (v12 >= v23) {
            int v12 = v23;
          }
          uint64_t v16 = (v12 + v16);
        }
        goto LABEL_39;
      }
      goto LABEL_27;
    }
    unsigned int v17 = v13;
LABEL_22:
    int v21 = v12;
    while (!*v17)
    {
      uint64_t v16 = (v16 + 64);
      int v12 = v21 - 64;
      ++v17;
      BOOL v22 = v21 <= 127;
      v21 -= 64;
      if (v22) {
        goto LABEL_26;
      }
    }
LABEL_27:
    int v18 = -(int)v16;
    while (!*(unsigned char *)v17)
    {
      int v12 = v21 - 8;
      unsigned int v17 = (void *)((char *)v17 + 1);
      v18 -= 8;
      BOOL v22 = v21 <= 15;
      v21 -= 8;
      if (v22)
      {
        uint64_t v16 = -v18;
        goto LABEL_32;
      }
    }
    int v24 = zeroruns[*(unsigned __int8 *)v17];
LABEL_38:
    uint64_t v16 = (v24 - v18);
LABEL_39:
    uint64_t result = putspan(a1, v16, (uint64_t)L"\b5", a4, a5, a6, a7, a8);
    if (!result) {
      return result;
    }
    int v28 = v16 + v11;
    int v29 = a3 - v28;
    if (a3 <= v28) {
      break;
    }
    if (v29 < 1)
    {
      uint64_t v33 = 0;
      goto LABEL_78;
    }
    BOOL v30 = (unsigned __int8 *)(a2 + (v28 >> 3));
    int v31 = v28 & 7;
    if ((v28 & 7) != 0)
    {
      unsigned int v32 = oneruns[(*v30 << v31) & 0xFELL];
      if (8 - v31 < v32) {
        unsigned int v32 = 8 - v31;
      }
      if (v32 >= v29) {
        uint64_t v33 = v29;
      }
      else {
        uint64_t v33 = v32;
      }
      if ((v33 + v31) < 8) {
        goto LABEL_78;
      }
      v29 -= v33;
      ++v30;
    }
    else
    {
      uint64_t v33 = 0;
    }
    if (v29 < 128)
    {
      unsigned int v34 = v30;
      goto LABEL_65;
    }
    if ((v30 & 7) != 0)
    {
      unsigned int v34 = &v30[-(v30 & 7) + 8];
      int v35 = -(int)v33;
      unsigned int v36 = v30 + 1;
      do
      {
        uint64_t v37 = *v30;
        if (v37 != 255)
        {
          int v42 = oneruns[v37];
          goto LABEL_77;
        }
        v29 -= 8;
        ++v30;
        v35 -= 8;
      }
      while ((unint64_t)(v36++ & 7));
      uint64_t v33 = -v35;
      if (v29 + 8 > 71) {
        goto LABEL_61;
      }
LABEL_65:
      int v39 = v29;
      if (v29 < 8)
      {
LABEL_71:
        if (v29 >= 1)
        {
          int v41 = oneruns[*v34];
          if (v29 >= v41) {
            int v29 = v41;
          }
          uint64_t v33 = (v29 + v33);
        }
        goto LABEL_78;
      }
      goto LABEL_66;
    }
    unsigned int v34 = v30;
LABEL_61:
    int v39 = v29;
    while (*(void *)v34 == -1)
    {
      uint64_t v33 = (v33 + 64);
      int v29 = v39 - 64;
      v34 += 8;
      BOOL v22 = v39 <= 127;
      v39 -= 64;
      if (v22) {
        goto LABEL_65;
      }
    }
LABEL_66:
    int v35 = -(int)v33;
    while (1)
    {
      uint64_t v40 = *v34;
      if (v40 != 255) {
        break;
      }
      int v29 = v39 - 8;
      ++v34;
      v35 -= 8;
      BOOL v22 = v39 <= 15;
      v39 -= 8;
      if (v22)
      {
        uint64_t v33 = -v35;
        goto LABEL_71;
      }
    }
    int v42 = oneruns[v40];
LABEL_77:
    uint64_t v33 = (v42 - v35);
LABEL_78:
    uint64_t result = putspan(a1, v33, (uint64_t)&TIFFFaxBlackCodes, a4, a5, a6, a7, a8);
    if (!result) {
      return result;
    }
    int v11 = v33 + v28;
  }
  while (v11 < a3);
  int v43 = v48[1];
  if ((v43 & 0xC) == 0) {
    return 1;
  }
  if (v48[19] == 8)
  {
LABEL_85:
    if ((v43 & 8) != 0)
    {
      int v46 = (unsigned char *)a1[144];
      if (v46)
      {
        if (a1[145] >= a1[141])
        {
          uint64_t result = TIFFFlushData1((uint64_t)a1, v26, v27, a4, a5, a6, a7, a8);
          if (!result) {
            return result;
          }
          int v46 = (unsigned char *)a1[144];
        }
        int v47 = v48[18];
        a1[144] = v46 + 1;
        *int v46 = v47;
        ++a1[145];
        *((void *)v48 + 9) = 0x800000000;
      }
    }
    return 1;
  }
  if (a1[145] < a1[141] || (uint64_t result = TIFFFlushData1((uint64_t)a1, v26, v27, a4, a5, a6, a7, a8), result))
  {
    char v44 = v48[18];
    int v45 = (unsigned char *)a1[144];
    a1[144] = v45 + 1;
    unsigned char *v45 = v44;
    ++a1[145];
    *((void *)v48 + 9) = 0x800000000;
    int v43 = v48[1];
    goto LABEL_85;
  }
  return result;
}

uint64_t Fax3Encode2DRow(void *a1, char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a4;
  unsigned int v12 = 0;
  if ((int)a4 < 1 || *a2 < 0) {
    goto LABEL_29;
  }
  if (a4 < 0x80)
  {
    unsigned int v12 = 0;
    unsigned int v13 = a2;
    int v18 = a4;
  }
  else
  {
    unsigned int v12 = 0;
    if ((a2 & 7) == 0)
    {
      unsigned int v13 = a2;
      int v17 = a4;
LABEL_13:
      while (!*(void *)v13)
      {
        v12 += 64;
        int v18 = v17 - 64;
        v13 += 8;
        BOOL v19 = v17 <= 127;
        v17 -= 64;
        if (v19) {
          goto LABEL_16;
        }
      }
      goto LABEL_17;
    }
    unsigned int v13 = &a2[-(a2 & 7) + 8];
    int v14 = a2 + 1;
    unsigned int v15 = a2;
    do
    {
      if (*v15)
      {
        int v21 = zeroruns[*v15];
        goto LABEL_28;
      }
      v12 += 8;
      ++v15;
      BOOL v16 = (v14++ & 7) == 0;
    }
    while (!v16);
    int v17 = a4 - v12;
    int v18 = a4 - v12;
    if ((int)(a4 - v12 + 8) > 71) {
      goto LABEL_13;
    }
  }
LABEL_16:
  int v17 = v18;
  if (v18 >= 8)
  {
LABEL_17:
    int v20 = -v12;
    while (!*v13)
    {
      int v18 = v17 - 8;
      ++v13;
      v20 -= 8;
      BOOL v19 = v17 <= 15;
      v17 -= 8;
      if (v19)
      {
        unsigned int v12 = -v20;
        goto LABEL_22;
      }
    }
    unsigned int v12 = zeroruns[*v13] - v20;
    goto LABEL_29;
  }
LABEL_22:
  if (v18 >= 1)
  {
    int v21 = zeroruns[*v13];
    if (v18 < v21) {
      int v21 = v18;
    }
LABEL_28:
    v12 += v21;
  }
LABEL_29:
  unsigned int v22 = 0;
  if ((int)a4 >= 1 && (*a3 & 0x80000000) == 0)
  {
    if (a4 < 0x80)
    {
      unsigned int v22 = 0;
      int v23 = a3;
      int v27 = a4;
    }
    else
    {
      unsigned int v22 = 0;
      if ((a3 & 7) == 0)
      {
        int v23 = a3;
        int v26 = a4;
LABEL_41:
        while (!*(void *)v23)
        {
          v22 += 64;
          int v27 = v26 - 64;
          v23 += 8;
          BOOL v19 = v26 <= 127;
          v26 -= 64;
          if (v19) {
            goto LABEL_44;
          }
        }
LABEL_45:
        int v28 = -v22;
        while (!*v23)
        {
          int v27 = v26 - 8;
          ++v23;
          v28 -= 8;
          BOOL v19 = v26 <= 15;
          v26 -= 8;
          if (v19)
          {
            unsigned int v22 = -v28;
            goto LABEL_50;
          }
        }
        unsigned int v22 = zeroruns[*v23] - v28;
        goto LABEL_57;
      }
      int v23 = &a3[-(a3 & 7) + 8];
      int v24 = a3 + 1;
      char v25 = a3;
      do
      {
        if (*v25)
        {
          int v29 = zeroruns[*v25];
          goto LABEL_56;
        }
        v22 += 8;
        ++v25;
        BOOL v16 = (v24++ & 7) == 0;
      }
      while (!v16);
      int v26 = a4 - v22;
      int v27 = a4 - v22;
      if ((int)(a4 - v22 + 8) > 71) {
        goto LABEL_41;
      }
    }
LABEL_44:
    int v26 = v27;
    if (v27 < 8)
    {
LABEL_50:
      if (v27 >= 1)
      {
        int v29 = zeroruns[*v23];
        if (v27 < v29) {
          int v29 = v27;
        }
LABEL_56:
        v22 += v29;
      }
      goto LABEL_57;
    }
    goto LABEL_45;
  }
LABEL_57:
  int v30 = 0;
  while (1)
  {
    unsigned int v31 = v8;
    int v32 = v8 - v22;
    if (v8 <= v22) {
      goto LABEL_130;
    }
    int v33 = v22 & 7;
    unsigned int v34 = &a3[(int)v22 >> 3];
    if ((a3[(unint64_t)v22 >> 3] >> (v22 & 7 ^ 7)))
    {
      if (v32 < 1) {
        goto LABEL_76;
      }
      if ((v22 & 7) != 0)
      {
        unsigned int v35 = oneruns[(*v34 << v33) & 0xFELL];
        if (8 - v33 < v35) {
          unsigned int v35 = 8 - v33;
        }
        if (v35 >= v32) {
          unsigned int v35 = v8 - v22;
        }
        if (v35 + v33 < 8) {
          goto LABEL_129;
        }
        v32 -= v35;
        ++v34;
      }
      else
      {
        unsigned int v35 = 0;
      }
      if (v32 < 128)
      {
        unsigned int v36 = v34;
        goto LABEL_100;
      }
      if ((v34 & 7) != 0)
      {
        unsigned int v36 = &v34[-(v34 & 7) + 8];
        int v37 = -v35;
        int v38 = v34 + 1;
        do
        {
          uint64_t v39 = *v34;
          if (v39 != 255)
          {
            int v47 = oneruns[v39];
            goto LABEL_128;
          }
          v32 -= 8;
          ++v34;
          v37 -= 8;
        }
        while ((unint64_t)(v38++ & 7));
        unsigned int v35 = -v37;
        if (v32 + 8 > 71) {
          goto LABEL_96;
        }
LABEL_100:
        int v44 = v32;
        if (v32 >= 8) {
          goto LABEL_101;
        }
LABEL_106:
        if (v32 >= 1)
        {
          int v46 = oneruns[*v36];
LABEL_123:
          if (v32 >= v46) {
            int v32 = v46;
          }
          v35 += v32;
          goto LABEL_129;
        }
        goto LABEL_129;
      }
      unsigned int v36 = v34;
LABEL_96:
      int v44 = v32;
      while (*(void *)v36 == -1)
      {
        v35 += 64;
        int v32 = v44 - 64;
        v36 += 8;
        BOOL v19 = v44 <= 127;
        v44 -= 64;
        if (v19) {
          goto LABEL_100;
        }
      }
LABEL_101:
      int v37 = -v35;
      while (1)
      {
        uint64_t v45 = *v36;
        if (v45 != 255) {
          break;
        }
        int v32 = v44 - 8;
        ++v36;
        v37 -= 8;
        BOOL v19 = v44 <= 15;
        v44 -= 8;
        if (v19)
        {
          unsigned int v35 = -v37;
          goto LABEL_106;
        }
      }
      int v47 = oneruns[v45];
LABEL_128:
      unsigned int v35 = v47 - v37;
      goto LABEL_129;
    }
    if (v32 < 1)
    {
LABEL_76:
      unsigned int v35 = 0;
      goto LABEL_129;
    }
    if ((v22 & 7) != 0)
    {
      unsigned int v35 = zeroruns[(*v34 << v33) & 0xFELL];
      if (8 - v33 < v35) {
        unsigned int v35 = 8 - v33;
      }
      if (v35 >= v32) {
        unsigned int v35 = v8 - v22;
      }
      if (v35 + v33 < 8) {
        goto LABEL_129;
      }
      v32 -= v35;
      ++v34;
    }
    else
    {
      unsigned int v35 = 0;
    }
    if (v32 < 128)
    {
      int v41 = v34;
    }
    else
    {
      if ((v34 & 7) == 0)
      {
        int v41 = v34;
LABEL_111:
        int v48 = v32;
        while (!*(void *)v41)
        {
          v35 += 64;
          int v32 = v48 - 64;
          v41 += 8;
          BOOL v19 = v48 <= 127;
          v48 -= 64;
          if (v19) {
            goto LABEL_115;
          }
        }
LABEL_116:
        int v37 = -v35;
        while (!*v41)
        {
          int v32 = v48 - 8;
          ++v41;
          v37 -= 8;
          BOOL v19 = v48 <= 15;
          v48 -= 8;
          if (v19)
          {
            unsigned int v35 = -v37;
            goto LABEL_121;
          }
        }
        int v47 = zeroruns[*v41];
        goto LABEL_128;
      }
      int v41 = &v34[-(v34 & 7) + 8];
      int v37 = -v35;
      int v42 = v34 + 1;
      do
      {
        if (*v34)
        {
          int v47 = zeroruns[*v34];
          goto LABEL_128;
        }
        v32 -= 8;
        ++v34;
        v37 -= 8;
      }
      while ((unint64_t)(v42++ & 7));
      unsigned int v35 = -v37;
      if (v32 + 8 > 71) {
        goto LABEL_111;
      }
    }
LABEL_115:
    int v48 = v32;
    if (v32 >= 8) {
      goto LABEL_116;
    }
LABEL_121:
    if (v32 >= 1)
    {
      int v46 = zeroruns[*v41];
      goto LABEL_123;
    }
LABEL_129:
    unsigned int v31 = v35 + v22;
LABEL_130:
    if (v31 < v12)
    {
      uint64_t result = Fax3PutBits(a1, 1, 4, a4, a5, a6, a7, a8);
      goto LABEL_220;
    }
    unsigned int v50 = v22 - v12;
    if (v22 >= v12 && v50 < 4) {
      goto LABEL_134;
    }
    if (v22 < v12)
    {
      unsigned int v51 = v12 - v22;
      if (v51 < 4)
      {
        unsigned int v50 = -v51;
LABEL_134:
        uint64_t result = Fax3PutBits(a1, vcodes[3 * v50 + 10], vcodes[3 * v50 + 9], a4, a5, a6, a7, a8);
        int v30 = v12;
        if (!result) {
          return result;
        }
        goto LABEL_221;
      }
    }
    unsigned int v31 = v8;
    int v52 = v8 - v12;
    if (v8 > v12)
    {
      int v53 = v12 & 7;
      int v54 = &a2[(int)v12 >> 3];
      if ((a2[(unint64_t)v12 >> 3] >> (v12 & 7 ^ 7)))
      {
        if (v52 >= 1)
        {
          if ((v12 & 7) != 0)
          {
            unsigned int v55 = oneruns[(*v54 << v53) & 0xFELL];
            if (8 - v53 < v55) {
              unsigned int v55 = 8 - v53;
            }
            if (v55 >= v52) {
              unsigned int v55 = v8 - v12;
            }
            if (v55 + v53 >= 8)
            {
              v52 -= v55;
              ++v54;
              goto LABEL_159;
            }
LABEL_211:
            unsigned int v31 = v55 + v12;
            goto LABEL_212;
          }
          unsigned int v55 = 0;
LABEL_159:
          if (v52 < 128)
          {
            BOOL v56 = v54;
            goto LABEL_189;
          }
          if ((v54 & 7) == 0)
          {
            BOOL v56 = v54;
LABEL_185:
            int v66 = v52;
            while (*(void *)v56 == -1)
            {
              v55 += 64;
              int v52 = v66 - 64;
              v56 += 8;
              BOOL v19 = v66 <= 127;
              v66 -= 64;
              if (v19) {
                goto LABEL_189;
              }
            }
            goto LABEL_190;
          }
          BOOL v56 = &v54[-(v54 & 7) + 8];
          int v57 = -v55;
          int v58 = v54 + 1;
          do
          {
            uint64_t v59 = *v54;
            if (v59 != 255)
            {
              int v68 = oneruns[v59];
              goto LABEL_210;
            }
            v52 -= 8;
            ++v54;
            v57 -= 8;
          }
          while ((unint64_t)(v58++ & 7));
          unsigned int v55 = -v57;
          if (v52 + 8 > 71) {
            goto LABEL_185;
          }
LABEL_189:
          int v66 = v52;
          if (v52 >= 8)
          {
LABEL_190:
            int v57 = -v55;
            while (1)
            {
              uint64_t v67 = *v56;
              if (v67 != 255) {
                break;
              }
              int v52 = v66 - 8;
              ++v56;
              v57 -= 8;
              BOOL v19 = v66 <= 15;
              v66 -= 8;
              if (v19)
              {
                unsigned int v55 = -v57;
                goto LABEL_195;
              }
            }
            int v68 = oneruns[v67];
LABEL_210:
            unsigned int v55 = v68 - v57;
            goto LABEL_211;
          }
LABEL_195:
          if (v52 < 1) {
            goto LABEL_211;
          }
          int v65 = oneruns[*v56];
LABEL_197:
          if (v52 >= v65) {
            int v52 = v65;
          }
          v55 += v52;
          goto LABEL_211;
        }
      }
      else if (v52 >= 1)
      {
        if ((v12 & 7) != 0)
        {
          unsigned int v55 = zeroruns[(*v54 << v53) & 0xFELL];
          if (8 - v53 < v55) {
            unsigned int v55 = 8 - v53;
          }
          if (v55 >= v52) {
            unsigned int v55 = v8 - v12;
          }
          if (v55 + v53 < 8) {
            goto LABEL_211;
          }
          v52 -= v55;
          ++v54;
        }
        else
        {
          unsigned int v55 = 0;
        }
        if (v52 < 128)
        {
          int v61 = v54;
LABEL_176:
          int v64 = v52;
          if (v52 < 8)
          {
LABEL_182:
            if (v52 < 1) {
              goto LABEL_211;
            }
            int v65 = zeroruns[*v61];
            goto LABEL_197;
          }
        }
        else
        {
          if ((v54 & 7) != 0)
          {
            int v61 = &v54[-(v54 & 7) + 8];
            int v57 = -v55;
            int v62 = v54 + 1;
            do
            {
              if (*v54)
              {
                int v68 = zeroruns[*v54];
                goto LABEL_210;
              }
              v52 -= 8;
              ++v54;
              v57 -= 8;
            }
            while ((unint64_t)(v62++ & 7));
            unsigned int v55 = -v57;
            if (v52 + 8 <= 71) {
              goto LABEL_176;
            }
          }
          else
          {
            int v61 = v54;
          }
          int v64 = v52;
          while (!*(void *)v61)
          {
            v55 += 64;
            int v52 = v64 - 64;
            v61 += 8;
            BOOL v19 = v64 <= 127;
            v64 -= 64;
            if (v19) {
              goto LABEL_176;
            }
          }
        }
        int v57 = -v55;
        while (!*v61)
        {
          int v52 = v64 - 8;
          ++v61;
          v57 -= 8;
          BOOL v19 = v64 <= 15;
          v64 -= 8;
          if (v19)
          {
            unsigned int v55 = -v57;
            goto LABEL_182;
          }
        }
        int v68 = zeroruns[*v61];
        goto LABEL_210;
      }
      unsigned int v55 = 0;
      goto LABEL_211;
    }
LABEL_212:
    uint64_t result = Fax3PutBits(a1, 1, 3, a4, a5, a6, a7, a8);
    if (!result) {
      return result;
    }
    if (v30 + v12 && ((a2[(unint64_t)v30 >> 3] >> (~(_BYTE)v30 & 7)) & 1) != 0)
    {
      uint64_t result = putspan(a1, v12 - v30, (uint64_t)&TIFFFaxBlackCodes, v69, v70, v71, v72, v73);
      if (!result) {
        return result;
      }
      uint64_t v79 = v31 - v12;
      int v80 = a1;
      int v81 = L"\b5";
    }
    else
    {
      uint64_t result = putspan(a1, v12 - v30, (uint64_t)L"\b5", v69, v70, v71, v72, v73);
      if (!result) {
        return result;
      }
      uint64_t v79 = v31 - v12;
      int v80 = a1;
      int v81 = (const __int16 *)&TIFFFaxBlackCodes;
    }
    uint64_t result = putspan(v80, v79, (uint64_t)v81, v74, v75, v76, v77, v78);
LABEL_220:
    int v30 = v31;
    if (!result) {
      return result;
    }
LABEL_221:
    int v82 = v8 - v30;
    if (v8 <= v30) {
      return 1;
    }
    int v83 = v30 & 7;
    uint64_t v84 = (uint64_t)v30 >> 3;
    int v85 = &a2[v30 >> 3];
    int v86 = (1 << (v30 & 7 ^ 7)) & a2[(unint64_t)v30 >> 3];
    if (v86)
    {
      if (v82 < 1)
      {
        unsigned int v87 = 0;
LABEL_240:
        unsigned int v12 = v87 + v30;
LABEL_296:
        if (v82 < 1)
        {
          unsigned int v103 = 0;
LABEL_313:
          int v105 = v103 + v30;
          goto LABEL_369;
        }
        int v102 = &a3[v84];
        if ((v30 & 7) != 0)
        {
          unsigned int v103 = zeroruns[(*v102 << v83) & 0xFELL];
          if (8 - v83 < v103) {
            unsigned int v103 = 8 - v83;
          }
          if (v103 >= v82) {
            unsigned int v103 = v8 - v30;
          }
          if (v103 + v83 < 8) {
            goto LABEL_313;
          }
          v82 -= v103;
          ++v102;
        }
        else
        {
          unsigned int v103 = 0;
        }
        if (v82 < 128)
        {
          uint64_t v106 = v102;
        }
        else
        {
          if ((v102 & 7) == 0)
          {
            uint64_t v106 = v102;
LABEL_335:
            int v114 = v82;
            while (!*(void *)v106)
            {
              v103 += 64;
              int v82 = v114 - 64;
              v106 += 8;
              BOOL v19 = v114 <= 127;
              v114 -= 64;
              if (v19) {
                goto LABEL_339;
              }
            }
LABEL_340:
            int v107 = -v103;
            while (!*v106)
            {
              int v82 = v114 - 8;
              ++v106;
              v107 -= 8;
              BOOL v19 = v114 <= 15;
              v114 -= 8;
              if (v19)
              {
                unsigned int v103 = -v107;
                goto LABEL_345;
              }
            }
            int v116 = zeroruns[*v106];
            goto LABEL_367;
          }
          uint64_t v106 = &v102[-(v102 & 7) + 8];
          int v107 = -v103;
          uint64_t v108 = v102 + 1;
          do
          {
            if (*v102)
            {
              int v116 = zeroruns[*v102];
              goto LABEL_367;
            }
            v82 -= 8;
            ++v102;
            v107 -= 8;
          }
          while ((unint64_t)(v108++ & 7));
          unsigned int v103 = -v107;
          if (v82 + 8 > 71) {
            goto LABEL_335;
          }
        }
LABEL_339:
        int v114 = v82;
        if (v82 >= 8) {
          goto LABEL_340;
        }
LABEL_345:
        if (v82 < 1) {
          goto LABEL_368;
        }
        int v115 = zeroruns[*v106];
        goto LABEL_362;
      }
      if ((v30 & 7) != 0)
      {
        unsigned int v87 = oneruns[(*v85 << v83) & 0xFELL];
        if (8 - v83 < v87) {
          unsigned int v87 = 8 - v83;
        }
        if (v87 >= v82) {
          unsigned int v87 = v8 - v30;
        }
        if (v87 + v83 < 8) {
          goto LABEL_240;
        }
        int v88 = v82 - v87;
        ++v85;
      }
      else
      {
        unsigned int v87 = 0;
        int v88 = v8 - v30;
      }
      if (v88 < 128)
      {
        uint64_t v89 = v85;
      }
      else
      {
        if ((v85 & 7) == 0)
        {
          uint64_t v89 = v85;
LABEL_262:
          int v97 = v88;
          while (*(void *)v89 == -1)
          {
            v87 += 64;
            int v88 = v97 - 64;
            v89 += 8;
            BOOL v19 = v97 <= 127;
            v97 -= 64;
            if (v19) {
              goto LABEL_266;
            }
          }
LABEL_267:
          int v90 = -v87;
          while (1)
          {
            uint64_t v98 = *v89;
            if (v98 != 255) {
              break;
            }
            int v88 = v97 - 8;
            ++v89;
            v90 -= 8;
            BOOL v19 = v97 <= 15;
            v97 -= 8;
            if (v19)
            {
              unsigned int v87 = -v90;
              goto LABEL_272;
            }
          }
          int v100 = oneruns[v98];
          goto LABEL_294;
        }
        uint64_t v89 = &v85[-(v85 & 7) + 8];
        int v90 = -v87;
        uint64_t v91 = v85 + 1;
        do
        {
          uint64_t v92 = *v85;
          if (v92 != 255)
          {
            int v100 = oneruns[v92];
            goto LABEL_294;
          }
          v88 -= 8;
          ++v85;
          v90 -= 8;
        }
        while ((unint64_t)(v91++ & 7));
        unsigned int v87 = -v90;
        if (v88 + 8 > 71) {
          goto LABEL_262;
        }
      }
LABEL_266:
      int v97 = v88;
      if (v88 >= 8) {
        goto LABEL_267;
      }
LABEL_272:
      if (v88 < 1) {
        goto LABEL_295;
      }
      int v99 = oneruns[*v89];
    }
    else
    {
      if (v82 < 1)
      {
        unsigned int v87 = 0;
LABEL_250:
        unsigned int v12 = v87 + v30;
        goto LABEL_304;
      }
      if ((v30 & 7) != 0)
      {
        unsigned int v87 = zeroruns[(*v85 << v83) & 0xFELL];
        if (8 - v83 < v87) {
          unsigned int v87 = 8 - v83;
        }
        if (v87 >= v82) {
          unsigned int v87 = v8 - v30;
        }
        if (v87 + v83 < 8) {
          goto LABEL_250;
        }
        int v88 = v82 - v87;
        ++v85;
      }
      else
      {
        unsigned int v87 = 0;
        int v88 = v8 - v30;
      }
      if (v88 < 128)
      {
        int v94 = v85;
      }
      else
      {
        if ((v85 & 7) == 0)
        {
          int v94 = v85;
LABEL_277:
          int v101 = v88;
          while (!*(void *)v94)
          {
            v87 += 64;
            int v88 = v101 - 64;
            v94 += 8;
            BOOL v19 = v101 <= 127;
            v101 -= 64;
            if (v19) {
              goto LABEL_281;
            }
          }
LABEL_282:
          int v90 = -v87;
          while (!*v94)
          {
            int v88 = v101 - 8;
            ++v94;
            v90 -= 8;
            BOOL v19 = v101 <= 15;
            v101 -= 8;
            if (v19)
            {
              unsigned int v87 = -v90;
              goto LABEL_287;
            }
          }
          int v100 = zeroruns[*v94];
LABEL_294:
          unsigned int v87 = v100 - v90;
          goto LABEL_295;
        }
        int v94 = &v85[-(v85 & 7) + 8];
        int v90 = -v87;
        int v95 = v85 + 1;
        do
        {
          if (*v85)
          {
            int v100 = zeroruns[*v85];
            goto LABEL_294;
          }
          v88 -= 8;
          ++v85;
          v90 -= 8;
        }
        while ((unint64_t)(v95++ & 7));
        unsigned int v87 = -v90;
        if (v88 + 8 > 71) {
          goto LABEL_277;
        }
      }
LABEL_281:
      int v101 = v88;
      if (v88 >= 8) {
        goto LABEL_282;
      }
LABEL_287:
      if (v88 < 1) {
        goto LABEL_295;
      }
      int v99 = zeroruns[*v94];
    }
    if (v88 < v99) {
      int v99 = v88;
    }
    v87 += v99;
LABEL_295:
    unsigned int v12 = v87 + v30;
    if (v86) {
      goto LABEL_296;
    }
LABEL_304:
    if (v82 < 1)
    {
      unsigned int v103 = 0;
LABEL_323:
      int v105 = v103 + v30;
LABEL_377:
      int v119 = v8 - v105;
      if ((int)(v8 - v105) < 1)
      {
LABEL_385:
        unsigned int v122 = 0;
        goto LABEL_438;
      }
      int v123 = &a3[v105 >> 3];
      int v124 = v105 & 7;
      if ((v105 & 7) == 0)
      {
        unsigned int v122 = 0;
LABEL_396:
        if (v119 < 128)
        {
          char v130 = v123;
        }
        else
        {
          if ((v123 & 7) == 0)
          {
            char v130 = v123;
LABEL_420:
            int v137 = v119;
            while (!*(void *)v130)
            {
              v122 += 64;
              int v119 = v137 - 64;
              v130 += 8;
              BOOL v19 = v137 <= 127;
              v137 -= 64;
              if (v19) {
                goto LABEL_424;
              }
            }
LABEL_425:
            int v126 = -v122;
            while (!*v130)
            {
              int v119 = v137 - 8;
              ++v130;
              v126 -= 8;
              BOOL v19 = v137 <= 15;
              v137 -= 8;
              if (v19)
              {
                unsigned int v122 = -v126;
                goto LABEL_430;
              }
            }
            int v136 = zeroruns[*v130];
LABEL_437:
            unsigned int v122 = v136 - v126;
            goto LABEL_438;
          }
          char v130 = &v123[-(v123 & 7) + 8];
          int v126 = -v122;
          int8x16_t v131 = v123 + 1;
          do
          {
            if (*v123)
            {
              int v136 = zeroruns[*v123];
              goto LABEL_437;
            }
            v119 -= 8;
            ++v123;
            v126 -= 8;
          }
          while ((unint64_t)(v131++ & 7));
          unsigned int v122 = -v126;
          if (v119 + 8 > 71) {
            goto LABEL_420;
          }
        }
LABEL_424:
        int v137 = v119;
        if (v119 >= 8) {
          goto LABEL_425;
        }
LABEL_430:
        if (v119 < 1) {
          goto LABEL_438;
        }
        int v135 = zeroruns[*v130];
LABEL_432:
        if (v119 >= v135) {
          int v119 = v135;
        }
        v122 += v119;
        goto LABEL_438;
      }
      unsigned int v122 = zeroruns[(*v123 << v124) & 0xFELL];
      if (8 - v124 < v122) {
        unsigned int v122 = 8 - v124;
      }
      if (v122 >= v119) {
        unsigned int v122 = v8 - v105;
      }
      if (v122 + v124 >= 8)
      {
        v119 -= v122;
        ++v123;
        goto LABEL_396;
      }
      goto LABEL_438;
    }
    int v104 = &a3[v84];
    if ((v30 & 7) != 0)
    {
      unsigned int v103 = oneruns[(*v104 << v83) & 0xFELL];
      if (8 - v83 < v103) {
        unsigned int v103 = 8 - v83;
      }
      if (v103 >= v82) {
        unsigned int v103 = v8 - v30;
      }
      if (v103 + v83 < 8) {
        goto LABEL_323;
      }
      v82 -= v103;
      ++v104;
    }
    else
    {
      unsigned int v103 = 0;
    }
    if (v82 < 128)
    {
      uint64_t v110 = (unsigned __int8 *)v104;
    }
    else
    {
      if ((v104 & 7) == 0)
      {
        uint64_t v110 = (unsigned __int8 *)v104;
LABEL_350:
        int v117 = v82;
        while (*(void *)v110 == -1)
        {
          v103 += 64;
          int v82 = v117 - 64;
          v110 += 8;
          BOOL v19 = v117 <= 127;
          v117 -= 64;
          if (v19) {
            goto LABEL_354;
          }
        }
LABEL_355:
        int v107 = -v103;
        while (1)
        {
          uint64_t v118 = *v110;
          if (v118 != 255) {
            break;
          }
          int v82 = v117 - 8;
          ++v110;
          v107 -= 8;
          BOOL v19 = v117 <= 15;
          v117 -= 8;
          if (v19)
          {
            unsigned int v103 = -v107;
            goto LABEL_360;
          }
        }
        int v116 = oneruns[v118];
LABEL_367:
        unsigned int v103 = v116 - v107;
        goto LABEL_368;
      }
      uint64_t v110 = (unsigned __int8 *)&v104[-(v104 & 7) + 8];
      int v107 = -v103;
      uint64_t v111 = (unsigned __int8 *)(v104 + 1);
      do
      {
        uint64_t v112 = *v104;
        if (v112 != 255)
        {
          int v116 = oneruns[v112];
          goto LABEL_367;
        }
        v82 -= 8;
        ++v104;
        v107 -= 8;
      }
      while ((unint64_t)(v111++ & 7));
      unsigned int v103 = -v107;
      if (v82 + 8 > 71) {
        goto LABEL_350;
      }
    }
LABEL_354:
    int v117 = v82;
    if (v82 >= 8) {
      goto LABEL_355;
    }
LABEL_360:
    if (v82 < 1) {
      goto LABEL_368;
    }
    int v115 = oneruns[*v110];
LABEL_362:
    if (v82 >= v115) {
      int v82 = v115;
    }
    v103 += v82;
LABEL_368:
    int v105 = v103 + v30;
    if (!v86) {
      goto LABEL_377;
    }
LABEL_369:
    int v119 = v8 - v105;
    if ((int)(v8 - v105) < 1) {
      goto LABEL_385;
    }
    int v120 = &a3[v105 >> 3];
    int v121 = v105 & 7;
    if ((v105 & 7) == 0)
    {
      unsigned int v122 = 0;
      goto LABEL_387;
    }
    unsigned int v122 = oneruns[(*v120 << v121) & 0xFELL];
    if (8 - v121 < v122) {
      unsigned int v122 = 8 - v121;
    }
    if (v122 >= v119) {
      unsigned int v122 = v8 - v105;
    }
    if (v122 + v121 >= 8)
    {
      v119 -= v122;
      ++v120;
LABEL_387:
      if (v119 < 128)
      {
        uint64_t v125 = (unsigned __int8 *)v120;
      }
      else
      {
        if ((v120 & 7) == 0)
        {
          uint64_t v125 = (unsigned __int8 *)v120;
LABEL_405:
          int v133 = v119;
          while (*(void *)v125 == -1)
          {
            v122 += 64;
            int v119 = v133 - 64;
            v125 += 8;
            BOOL v19 = v133 <= 127;
            v133 -= 64;
            if (v19) {
              goto LABEL_409;
            }
          }
LABEL_410:
          int v126 = -v122;
          while (1)
          {
            uint64_t v134 = *v125;
            if (v134 != 255) {
              break;
            }
            int v119 = v133 - 8;
            ++v125;
            v126 -= 8;
            BOOL v19 = v133 <= 15;
            v133 -= 8;
            if (v19)
            {
              unsigned int v122 = -v126;
              goto LABEL_415;
            }
          }
          int v136 = oneruns[v134];
          goto LABEL_437;
        }
        uint64_t v125 = (unsigned __int8 *)&v120[-(v120 & 7) + 8];
        int v126 = -v122;
        BOOL v127 = (unsigned __int8 *)(v120 + 1);
        do
        {
          uint64_t v128 = *v120;
          if (v128 != 255)
          {
            int v136 = oneruns[v128];
            goto LABEL_437;
          }
          v119 -= 8;
          ++v120;
          v126 -= 8;
        }
        while ((unint64_t)(v127++ & 7));
        unsigned int v122 = -v126;
        if (v119 + 8 > 71) {
          goto LABEL_405;
        }
      }
LABEL_409:
      int v133 = v119;
      if (v119 >= 8) {
        goto LABEL_410;
      }
LABEL_415:
      if (v119 < 1) {
        goto LABEL_438;
      }
      int v135 = oneruns[*v125];
      goto LABEL_432;
    }
LABEL_438:
    unsigned int v22 = v122 + v105;
  }
}

uint64_t putspan(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a2;
  uint64_t v11 = a1[137];
  int v12 = *(_DWORD *)(v11 + 72);
  unsigned int v13 = *(_DWORD *)(v11 + 76);
  if ((int)a2 < 2624)
  {
LABEL_14:
    if (v9 >= 64)
    {
      unsigned int v21 = (v9 >> 6) + 63;
      uint64_t v22 = a3 + 6 * v21;
      int v24 = *(__int16 *)(v22 + 4);
      int v23 = (__int16 *)(v22 + 4);
      if ((v9 & 0xFFFFFFC0) != v24) {
        putspan_cold_3();
      }
      char v25 = (unsigned __int16 *)(a3 + 6 * v21);
      unsigned int v26 = v25[1];
      unsigned int v27 = *v25;
      if (v13 < v27)
      {
        uint64_t v28 = a1[145];
        char v29 = v12;
        while (1)
        {
          if (v28 >= a1[141])
          {
            uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
            if (!result) {
              return result;
            }
          }
          int v12 = 0;
          v27 -= v13;
          int v30 = (unsigned char *)a1[144];
          a1[144] = v30 + 1;
          *int v30 = (v26 >> v27) | v29;
          uint64_t v28 = a1[145] + 1;
          a1[145] = v28;
          unsigned int v13 = 8;
          char v29 = 0;
          if (v27 <= 8) {
            goto LABEL_23;
          }
        }
      }
      if (v27 >= 9) {
        putspan_cold_2();
      }
LABEL_23:
      v13 -= v27;
      v12 |= (_msbmask[v27] & v26) << v13;
      if (!v13)
      {
        if (a1[145] >= a1[141])
        {
          uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
          if (!result) {
            return result;
          }
        }
        unsigned int v31 = (unsigned char *)a1[144];
        a1[144] = v31 + 1;
        *unsigned int v31 = v12;
        ++a1[145];
        unsigned int v13 = 8;
        int v12 = 0;
      }
      v9 -= *v23;
    }
    int v32 = (unsigned __int16 *)(a3 + 6 * v9);
    unsigned int v33 = v32[1];
    unsigned int v34 = *v32;
    if (v13 >= v34)
    {
      if (v34 >= 9) {
        putspan_cold_1();
      }
LABEL_35:
      int v38 = v13 - v34;
      int v39 = ((_msbmask[v34] & v33) << (v13 - v34)) | v12;
      if (v13 == v34)
      {
        if (a1[145] >= a1[141])
        {
          uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
          if (!result) {
            return result;
          }
        }
        uint64_t v40 = (unsigned char *)a1[144];
        a1[144] = v40 + 1;
        *uint64_t v40 = v39;
        ++a1[145];
        int v38 = 8;
        int v39 = 0;
      }
      *(_DWORD *)(v11 + 72) = v39;
      *(_DWORD *)(v11 + 76) = v38;
      return 1;
    }
    uint64_t v35 = a1[145];
    char v36 = v12;
    while (1)
    {
      if (v35 >= a1[141])
      {
        uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
        if (!result) {
          break;
        }
      }
      int v12 = 0;
      v34 -= v13;
      int v37 = (unsigned char *)a1[144];
      a1[144] = v37 + 1;
      unsigned char *v37 = (v33 >> v34) | v36;
      uint64_t v35 = a1[145] + 1;
      a1[145] = v35;
      unsigned int v13 = 8;
      char v36 = 0;
      if (v34 <= 8) {
        goto LABEL_35;
      }
    }
  }
  else
  {
    while (1)
    {
      unsigned int v14 = *(unsigned __int16 *)(a3 + 620);
      unsigned int v15 = *(unsigned __int16 *)(a3 + 618);
      if (v13 < v15) {
        break;
      }
      if (v15 >= 9) {
        putspan_cold_4();
      }
LABEL_9:
      v13 -= v15;
      v12 |= (_msbmask[v15] & v14) << v13;
      if (!v13)
      {
        if (a1[145] >= a1[141])
        {
          uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
          if (!result) {
            return result;
          }
        }
        int v20 = (unsigned char *)a1[144];
        a1[144] = v20 + 1;
        unsigned char *v20 = v12;
        ++a1[145];
        unsigned int v13 = 8;
        int v12 = 0;
      }
      v9 -= *(__int16 *)(a3 + 622);
      if (v9 <= 2623) {
        goto LABEL_14;
      }
    }
    uint64_t v16 = a1[145];
    char v17 = v12;
    while (1)
    {
      if (v16 >= a1[141])
      {
        uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
        if (!result) {
          break;
        }
      }
      int v12 = 0;
      v15 -= v13;
      BOOL v19 = (unsigned char *)a1[144];
      a1[144] = v19 + 1;
      *BOOL v19 = (v14 >> v15) | v17;
      uint64_t v16 = a1[145] + 1;
      a1[145] = v16;
      unsigned int v13 = 8;
      char v17 = 0;
      if (v15 <= 8) {
        goto LABEL_9;
      }
    }
  }
  return result;
}

uint64_t Fax3PutBits(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a3;
  unsigned int v9 = a2;
  uint64_t v11 = a1[137];
  int v12 = *(_DWORD *)(v11 + 72);
  unsigned int v13 = *(_DWORD *)(v11 + 76);
  if (v13 >= a3)
  {
    if (a3 >= 9) {
      Fax3PutBits_cold_1();
    }
LABEL_8:
    int v19 = v13 - v8;
    BOOL v18 = v13 == v8;
    int v20 = ((_msbmask[v8] & v9) << (v13 - v8)) | v12;
    if (v18)
    {
      if (a1[145] >= a1[141])
      {
        uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
        if (!result) {
          return result;
        }
      }
      unsigned int v21 = (unsigned char *)a1[144];
      a1[144] = v21 + 1;
      unsigned char *v21 = v20;
      ++a1[145];
      int v19 = 8;
      int v20 = 0;
    }
    *(_DWORD *)(v11 + 72) = v20;
    *(_DWORD *)(v11 + 76) = v19;
    return 1;
  }
  uint64_t v14 = a1[145];
  int v15 = *(_DWORD *)(v11 + 72);
  while (1)
  {
    if (v14 >= a1[141])
    {
      uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
      if (!result) {
        return result;
      }
    }
    int v12 = 0;
    v8 -= v13;
    char v17 = (unsigned char *)a1[144];
    a1[144] = v17 + 1;
    *char v17 = (v9 >> v8) | v15;
    uint64_t v14 = a1[145] + 1;
    a1[145] = v14;
    unsigned int v13 = 8;
    LOBYTE(v15) = 0;
    if (v8 <= 8) {
      goto LABEL_8;
    }
  }
}

void IIOIncrementIdentifyCallCount()
{
}

void IIOIncrementImageCountCallCount()
{
}

void IIOIncrementSourcePropertiesCallCount()
{
}

void IIOIncrementInitImageCallCount()
{
}

void IIOIncrementCopyIOSurfaceCallCount()
{
}

xpc_object_t IIOProcessEvent(_xpc_connection_s *a1, void *a2)
{
  if (!gRunningInXPCService) {
    return 0;
  }
  xpc_object_t source_dict = iio_xpc_get_source_dict(a2);
  uint64_t uint64 = xpc_dictionary_get_uint64(a2, "iio_xpc_message_id");
  uint64_t v6 = xpc_dictionary_get_uint64(a2, "iio_xpc_transacion_id");
  IIOXPCUpdatePermissions(a2);
  IIOXPCUpdateAllowableTypes(a2);
  if (source_dict) {
    int v7 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_ostype");
  }
  else {
    int v7 = 774778414;
  }
  switch(uint64)
  {
    case 1uLL:
      kdebug_trace();
      IIOXPCLog(" XPC_READPLUGIN_IDENTIFY [%lld]\n", v6);
      ReaderHandler = (os_unfair_lock_s *)IIO_ReaderHandler::GetReaderHandler(v8);
      v36[0] = MEMORY[0x1E4F143A8];
      v36[1] = 0x40000000;
      v36[2] = __IIOProcessEvent_block_invoke;
      void v36[3] = &__block_descriptor_tmp_9_1;
      v36[4] = v6;
      int v37 = v7;
      IIO_ReaderHandler::xpcTestHeader(ReaderHandler, (int)a1, a2, (uint64_t)v36);
      return 0;
    case 2uLL:
      kdebug_trace();
      IIOXPCLog(" XPC_READPLUGIN_IMAGECOUNT [%lld]\n", v6);
      uint64_t v11 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v10);
      v34[0] = MEMORY[0x1E4F143A8];
      v34[1] = 0x40000000;
      CFTypeRef v34[2] = __IIOProcessEvent_block_invoke_2;
      void v34[3] = &__block_descriptor_tmp_12_1;
      v34[4] = v6;
      int v35 = v7;
      IIO_ReaderHandler::xpcGetImageCount(v11, a1, a2, (uint64_t)v34);
      return 0;
    case 3uLL:
      kdebug_trace();
      IIOXPCLog(" XPC_READPLUGIN_SOURCEPROPERTIES [%lld]\n", v6);
      unsigned int v13 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v12);
      v32[0] = MEMORY[0x1E4F143A8];
      v32[1] = 0x40000000;
      _OWORD v32[2] = __IIOProcessEvent_block_invoke_3;
      v32[3] = &__block_descriptor_tmp_15_1;
      char v32[4] = v6;
      int v33 = v7;
      IIO_ReaderHandler::xpcUpdateSourceProperties(v13, a1, a2, (uint64_t)v32);
      return 0;
    case 4uLL:
      kdebug_trace();
      IIOXPCLog(" XPC_READPLUGIN_INITIMAGE [%lld]\n", v6);
      int v15 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v14);
      v30[0] = MEMORY[0x1E4F143A8];
      v30[1] = 0x40000000;
      v30[2] = __IIOProcessEvent_block_invoke_4;
      void v30[3] = &__block_descriptor_tmp_18;
      v30[4] = v6;
      int v31 = v7;
      IIO_ReaderHandler::xpcInitImage(v15, a1, a2, (uint64_t)v30);
      return 0;
    case 5uLL:
      kdebug_trace();
      IIOXPCLog(" XPC_READPLUGIN_DEBUG [%lld]\n", v6);
      repldouble y = xpc_dictionary_create_reply(a2);
      xpc_object_t v17 = reply;
      if (reply)
      {
        xpc_object_t v18 = iio_xpc_add_message_dict(reply);
        iio_xpc_dictionary_add_databuffer(v18, "iio_xpc_msg_call_counts", &gCallCounts, 0x30uLL);
      }
      IIOXPCLog(" XPC_READPLUGIN_DEBUG [%lld]\n", v6);
      break;
    case 6uLL:
      kdebug_trace();
      IIOXPCLog(" XPC_READPLUGIN_DECODE_IMAGE [%lld]\n", v6);
      int v20 = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v19);
      v28[0] = MEMORY[0x1E4F143A8];
      v28[1] = 0x40000000;
      v28[2] = __IIOProcessEvent_block_invoke_5;
      v28[3] = &__block_descriptor_tmp_23;
      v28[4] = v6;
      int v29 = v7;
      IIO_ReaderHandler::xpcDecodeImage(v20, a1, a2, (uint64_t)v28);
      return 0;
    case 8uLL:
      kdebug_trace();
      IIOXPCLog(" XPC_READPLUGIN_WAKEUP [%lld]\n", v6);
      if (gRunningInXPCService)
      {
        gIIODebugFlags = xpc_dictionary_get_uint64(a2, "iio_xpc_msg_debugflags");
        xpc_dictionary_get_uint64(a2, "iio_xpc_msg_pid");
        double Current = CFAbsoluteTimeGetCurrent();
        if (IIO_ReaderHandler::GetReaderHandler(v23))
        {
          CFAbsoluteTime v24 = CFAbsoluteTimeGetCurrent();
          IIOXPCLog("    IIO_ReaderHandler::buildPluginList: %g ms\n", (v24 - Current) * 1000.0);
        }
        xpc_object_t v25 = xpc_dictionary_create_reply(a2);
        xpc_object_t v17 = v25;
        if (v25)
        {
          xpc_object_t v26 = iio_xpc_add_message_dict(v25);
          double v27 = CFAbsoluteTimeGetCurrent();
          xpc_dictionary_set_double(v26, "iio_xpc_msg_wakeup_time", v27);
          iio_xpc_dictionary_set_error_code(v26, 0);
        }
      }
      else
      {
        xpc_object_t v17 = 0;
      }
      IIOXPCLog(" XPC_READPLUGIN_WAKEUP [%lld]\n", v6);
      break;
    default:
      IIOXPCLog(" message [%d] not handled...\n", uint64);
      return 0;
  }
  kdebug_trace();
  return v17;
}

uint64_t __IIOProcessEvent_block_invoke(uint64_t a1)
{
  IIOXPCLog(" XPC_READPLUGIN_IDENTIFY [%lld]\n", *(void *)(a1 + 32));

  return kdebug_trace();
}

uint64_t __IIOProcessEvent_block_invoke_2(uint64_t a1)
{
  IIOXPCLog(" XPC_READPLUGIN_IMAGECOUNT [%lld]\n", *(void *)(a1 + 32));

  return kdebug_trace();
}

uint64_t __IIOProcessEvent_block_invoke_3(uint64_t a1)
{
  IIOXPCLog(" XPC_READPLUGIN_SOURCEPROPERTIES [%lld]\n", *(void *)(a1 + 32));

  return kdebug_trace();
}

uint64_t __IIOProcessEvent_block_invoke_4(uint64_t a1)
{
  IIOXPCLog(" XPC_READPLUGIN_INITIMAGE [%lld]\n", *(void *)(a1 + 32));

  return kdebug_trace();
}

uint64_t __IIOProcessEvent_block_invoke_5(uint64_t a1)
{
  IIOXPCLog(" XPC_READPLUGIN_DECODE_IMAGE [%lld]\n", *(void *)(a1 + 32));

  return kdebug_trace();
}

void UpdateRunningInXPCService()
{
  if (UpdateRunningInXPCService::onceToken != -1) {
    dispatch_once(&UpdateRunningInXPCService::onceToken, &__block_literal_global_29_0);
  }
}

void __UpdateRunningInXPCService_block_invoke()
{
  gRunningInXPCService = 1;
}

void sub_188769900(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40BDB929D5);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_ASTC::updateSourceProperties(__CFString ***this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  if (this[1] != kCGImageTypeIdentifierKTX) {
    return 4294967246;
  }
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler((IIO_ReaderHandler *)this);
  unsigned int v8 = *(uint64_t (**)(void))(*(void *)IIO_ReaderHandler::readerForType(ReaderHandler, 1263818784) + 56);

  return v8();
}

uint64_t IIO_Reader_ASTC::hasCustomSourcePropertiesProc(IIO_Reader_ASTC *this)
{
  return 1;
}

void ImageIO_dumpImageData(const char *a1, const void *a2)
{
  ImageIOLog("  dumping image-%04ld to file '%s'\n", gFileIndex, a1);
  CFShow(a2);
  uint64_t v6 = 0;
  pid_t v4 = getpid();
  uint64_t v5 = gFileIndex++;
  asprintf(&v6, "*/IIO-%d-%04ld-%s.br2", v4, v5, a1);
  CGImageDumpToFile();
  free(v6);
}

void ImageIO_saveImageData(const char *a1, CFDataRef theData)
{
  if (!theData) {
    return;
  }
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  __fileCFStringRef name = 0;
  if (Length < 21) {
    return;
  }
  size_t v6 = Length;
  unsigned int v7 = *BytePtr;
  if (v7 > 0x4C)
  {
    if (*BytePtr > 0x88u)
    {
      if (v7 == 137)
      {
        if (BytePtr[1] == 80 && BytePtr[2] == 78 && BytePtr[3] == 71)
        {
          unsigned int v8 = "png";
          goto LABEL_78;
        }
      }
      else if (v7 == 255 && BytePtr[1] == 216 && BytePtr[2] == 255)
      {
        unsigned int v8 = "jpg";
        goto LABEL_78;
      }
    }
    else
    {
      if (v7 == 77)
      {
        if (BytePtr[1] != 77) {
          goto LABEL_45;
        }
        goto LABEL_36;
      }
      if (v7 == 105 && BytePtr[1] == 99 && BytePtr[2] == 110 && BytePtr[3] == 115)
      {
        unsigned int v8 = "icns";
        goto LABEL_78;
      }
    }
LABEL_45:
    int v9 = BytePtr[4];
    if (v9 == 102 && BytePtr[5] == 116)
    {
      if (BytePtr[6] == 121
        && BytePtr[7] == 112
        && BytePtr[8] == 104
        && BytePtr[9] == 101
        && BytePtr[10] == 105
        && BytePtr[11] == 99)
      {
        unsigned int v8 = "heic";
        goto LABEL_78;
      }
      if (BytePtr[6] == 121
        && BytePtr[7] == 112
        && BytePtr[8] == 109
        && BytePtr[9] == 115
        && BytePtr[10] == 102
        && BytePtr[11] == 49)
      {
        unsigned int v8 = "heics";
        goto LABEL_78;
      }
    }
    if (v7 == 171 && BytePtr[1] == 75 && BytePtr[2] == 84 && BytePtr[3] == 88)
    {
      unsigned int v8 = "KTX";
    }
    else if (v9 == 74 && BytePtr[5] == 88 && BytePtr[6] == 76 && BytePtr[7] == 32)
    {
      unsigned int v8 = "JXL";
    }
    else if (v7 == 65 && BytePtr[1] == 65)
    {
      unsigned int v8 = "data";
      if (BytePtr[2] == 80 && BytePtr[3] == 76) {
        unsigned int v8 = "ATX";
      }
    }
    else
    {
      unsigned int v8 = "data";
    }
    goto LABEL_78;
  }
  if (*BytePtr > 0x46u)
  {
    if (v7 == 71)
    {
      if (BytePtr[1] == 73 && BytePtr[2] == 70 && BytePtr[3] == 56)
      {
        unsigned int v8 = "gif";
        goto LABEL_78;
      }
      goto LABEL_45;
    }
    if (v7 != 73 || BytePtr[1] != 73) {
      goto LABEL_45;
    }
LABEL_36:
    unsigned int v8 = "tif";
    goto LABEL_78;
  }
  if (!*BytePtr)
  {
    if (!BytePtr[1]
      && !BytePtr[2]
      && BytePtr[3] == 12
      && BytePtr[4] == 106
      && BytePtr[5] == 80
      && BytePtr[8] == 13
      && BytePtr[9] == 10)
    {
      unsigned int v8 = "jp2";
      goto LABEL_78;
    }
    goto LABEL_45;
  }
  if (v7 != 56 || BytePtr[1] != 66 || BytePtr[2] != 80 || BytePtr[3] != 83) {
    goto LABEL_45;
  }
  unsigned int v8 = "psd";
LABEL_78:
  uint64_t v10 = (const char *)ImageIOTempDirPath();
  pid_t v11 = getpid();
  uint64_t v12 = gFileIndex++;
  asprintf(&__filename, "%s/IIO-%d-%04ld-%s.%s", v10, v11, v12, a1, v8);
  ImageIOLog("  writing imagedata to '%s'\n", __filename);
  unsigned int v13 = fopen(__filename, "w");
  if (v13)
  {
    uint64_t v14 = v13;
    CFLog();
    fwrite(BytePtr, v6, 1uLL, v14);
    fclose(v14);
  }
  else
  {
    __error();
    int v15 = __error();
    strerror(*v15);
    CFLog();
  }
  free(__filename);
}

uint64_t ImageIOTempDirPath()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  uint64_t result = ImageIOTempDirPath::tempDirPath;
  if (!ImageIOTempDirPath::tempDirPath)
  {
    bzero(v1, 0x400uLL);
    if (confstr(65537, v1, 0x400uLL)) {
      asprintf((char **)&ImageIOTempDirPath::tempDirPath, "%s", v1);
    }
    return ImageIOTempDirPath::tempDirPath;
  }
  return result;
}

uint64_t IIO_HardwareEncoderDefaultValue()
{
  if (IIO_HardwareEncoderDefaultValue::onceToken != -1) {
    dispatch_once(&IIO_HardwareEncoderDefaultValue::onceToken, &__block_literal_global_44);
  }
  return IIO_HardwareEncoderDefaultValue::hwEncoderDefaultValue;
}

void sub_18876A098(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

long long *CGGetImageIOVersion()
{
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGGetImageIOVersion", 0, 0, -1, 0);
  }
  if (CGGetImageIOVersion::onceToken != -1) {
    dispatch_once(&CGGetImageIOVersion::onceToken, &__block_literal_global_52);
  }
  return &CGGetImageIOVersion::gIIOVersion;
}

double __CGGetImageIOVersion_block_invoke()
{
  BundleWithIdentifier = CFBundleGetBundleWithIdentifier(@"com.apple.ImageIO");
  if (BundleWithIdentifier)
  {
    ValueForInfoDictionaryKedouble y = CFBundleGetValueForInfoDictionaryKey(BundleWithIdentifier, (CFStringRef)*MEMORY[0x1E4F1D020]);
    if (ValueForInfoDictionaryKey)
    {
      memset(v4, 0, sizeof(v4));
      IIOString::IIOString((IIOString *)v4, ValueForInfoDictionaryKey);
      uint64_t v3 = (const char *)IIOString::utf8String((IIOString *)v4);
      strncpy((char *)&CGGetImageIOVersion::gIIOVersion, v3, 0x20uLL);
      IIOString::~IIOString((IIOString *)v4);
    }
  }
  if (!(_BYTE)CGGetImageIOVersion::gIIOVersion)
  {
    double result = *(double *)"unknown";
    CGGetImageIOVersion::gIIOVersiounsigned int n = *(_OWORD *)"unknown";
    unk_1E90FF7B8 = unk_188992142;
  }
  return result;
}

void sub_18876A1CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void TIFFCleanup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 12)) {
    TIFFFlush(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  (*(void (**)(uint64_t))(a1 + 1072))(a1);
  _cg_TIFFFreeDirectory(a1);
  _TIFFCleanupIFDOffsetAndNumberMaps(a1);
  while (1)
  {
    uint64_t v14 = *(void *)(a1 + 1304);
    if (!v14) {
      break;
    }
    *(void *)(a1 + 1304) = *(void *)v14;
    _TIFFfreeExt(a1, *(char **)(v14 + 16));
    _TIFFfreeExt(a1, (char *)v14);
  }
  int v15 = *(char **)(a1 + 1120);
  if (v15 && (*(unsigned char *)(a1 + 17) & 2) != 0) {
    _TIFFfreeExt(a1, v15);
  }
  if ((*(unsigned char *)(a1 + 17) & 8) != 0) {
    (*(void (**)(void, void, void))(a1 + 1192))(*(void *)(a1 + 1200), *(void *)(a1 + 1168), *(void *)(a1 + 1176));
  }
  if (*(void *)(a1 + 1256) && *(void *)(a1 + 1264))
  {
    uint64_t v16 = 0;
    unsigned int v17 = 1;
    do
    {
      uint64_t v18 = *(void *)(*(void *)(a1 + 1256) + 8 * v16);
      if (*(void *)(v18 + 32) && *(_WORD *)(v18 + 24) == 65 && TIFFFieldIsAnonymous(v18))
      {
        _TIFFfreeExt(a1, *(char **)(v18 + 32));
        _TIFFfreeExt(a1, (char *)v18);
      }
      uint64_t v16 = v17;
      BOOL v19 = *(void *)(a1 + 1264) > (unint64_t)v17++;
    }
    while (v19);
    _TIFFfreeExt(a1, *(char **)(a1 + 1256));
  }
  unint64_t v20 = *(void *)(a1 + 1320);
  if (v20)
  {
    uint64_t v21 = 0;
    unsigned int v22 = 1;
    do
    {
      uint64_t v23 = *(void *)(a1 + 1312);
      if (*(_DWORD *)(v23 + 24 * v21 + 4))
      {
        _TIFFfreeExt(a1, *(char **)(v23 + 24 * v21 + 16));
        unint64_t v20 = *(void *)(a1 + 1320);
      }
      uint64_t v21 = v22;
      BOOL v19 = v20 > v22++;
    }
    while (v19);
    _TIFFfreeExt(a1, *(char **)(a1 + 1312));
  }
  if (*(void *)(a1 + 1376)) {
    TIFFErrorExtR(a1, "TIFFCleanup", "tif_cur_cumulated_mem_CFAllocatorRef alloc = %llu whereas it should be 0", v9, v10, v11, v12, v13, *(void *)(a1 + 1376));
  }

  _TIFFfreeExt(0, (char *)a1);
}

void _TIFFCleanupIFDOffsetAndNumberMaps(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2)
  {
    TIFFHashSetDestroy(v2);
    *(void *)(a1 + 48) = 0;
  }
  uint64_t v3 = *(void *)(a1 + 56);
  if (v3)
  {
    TIFFHashSetDestroy(v3);
    *(void *)(a1 + 56) = 0;
  }
}

uint64_t _cg_TIFFClose(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (result)
  {
    uint64_t v9 = *(uint64_t (**)(uint64_t))(result + 1232);
    uint64_t v8 = *(void *)(result + 1200);
    TIFFCleanup(result, (uint64_t)v9, a3, a4, a5, a6, a7, a8);
    return v9(v8);
  }
  return result;
}

long long *GetPBMLookupTable(void)
{
  if (GetPBMLookupTable(void)::onceToken != -1) {
    dispatch_once(&GetPBMLookupTable(void)::onceToken, &__block_literal_global_24);
  }
  return &gPBMLookupTable;
}

double ___Z17GetPBMLookupTablev_block_invoke()
{
  *(void *)&long long v0 = -1;
  *((void *)&v0 + 1) = -1;
  xmmword_1E91065A8 = v0;
  unk_1E91065B8 = v0;
  xmmword_1E9106588 = v0;
  unk_1E9106598 = v0;
  xmmword_1E9106568 = v0;
  unk_1E9106578 = v0;
  xmmword_1E9106548 = v0;
  unk_1E9106558 = v0;
  xmmword_1E9106528 = v0;
  unk_1E9106538 = v0;
  xmmword_1E9106508 = v0;
  unk_1E9106518 = v0;
  xmmword_1E91064E8 = v0;
  *(_OWORD *)&qword_1E91064F8 = v0;
  gPBMLookupTable = v0;
  unk_1E91064D8 = v0;
  BYTE3(xmmword_1E91064E8) = -2;
  BYTE13(gPBMLookupTable) = -3;
  *(_WORD *)((char *)&gPBMLookupTable + 9) = -771;
  LOBYTE(xmmword_1E91064E8) = -3;
  BYTE13(xmmword_1E91064E8) = 45;
  double result = 7.9499289e-275;
  qword_1E91064F8 = 0x706050403020100;
  word_1E9106500 = 2312;
  return result;
}

_DWORD *png_save_uint_32(_DWORD *result, unsigned int a2)
{
  *double result = bswap32(a2);
  return result;
}

uint64_t png_write_PLTE(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v3 = a3;
  int v6 = *(unsigned __int8 *)(a1 + 391);
  if (v6 == 3)
  {
    if (*(_DWORD *)(a1 + 760) & 1 | a3) {
      BOOL v7 = 1 << *(unsigned char *)(a1 + 392) >= a3;
    }
    else {
      BOOL v7 = 0;
    }
    if (!v7) {
      _cg_png_error((void (**)(void))a1, "Invalid number of colors in palette");
    }
    goto LABEL_11;
  }
  if (a3 <= 0x100 && *(_DWORD *)(a1 + 760) & 1 | a3)
  {
    if ((v6 & 2) != 0)
    {
LABEL_11:
      memset(v10, 0, 3);
      *(_WORD *)(a1 + 376) = a3;
      _cg_png_write_chunk_header(a1, 1347179589);
      for (; v3; --v3)
      {
        LOBYTE(v10[0]) = *(unsigned char *)a2;
        *(_WORD *)((char *)v10 + 1) = *(_WORD *)(a2 + 1);
        _cg_png_write_chunk_data(a1, (Bytef *)v10, 3);
        a2 += 3;
      }
      uint64_t result = _cg_png_write_chunk_end(a1);
      *(_DWORD *)(a1 + 76) |= 2u;
      return result;
    }
    uint64_t v8 = "Ignoring request to write a PLTE chunk in grayscale PNG";
  }
  else
  {
    uint64_t v8 = "Invalid number of colors in palette";
  }

  return png_warning(a1, v8);
}

uint64_t png_write_fdAT(uint64_t a1, Bytef *a2, uint64_t a3)
{
  _cg_png_write_chunk_header(a1, 1717846356);
  unsigned int v7 = bswap32(*(_DWORD *)(a1 + 772));
  _cg_png_write_chunk_data(a1, (Bytef *)&v7, 4);
  _cg_png_write_chunk_data(a1, a2, a3);
  uint64_t result = _cg_png_write_chunk_end(a1);
  ++*(_DWORD *)(a1 + 772);
  return result;
}

void (**png_write_gAMA_fixed(void (**a1)(void), unsigned int a2))(void)
{
  unsigned int v3 = bswap32(a2);
  return _cg_png_write_complete_chunk(a1, 1732332865, (Bytef *)&v3, 4uLL);
}

uint64_t png_write_sPLT(void (**a1)(void), uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  memset(v18, 0, sizeof(v18));
  __int16 v17 = 0;
  uint64_t v16 = 0;
  pid_t v4 = (Bytef *)(a2 + 16);
  if (*(unsigned char *)(a2 + 16) == 8) {
    uint64_t v5 = 6;
  }
  else {
    uint64_t v5 = 10;
  }
  int v6 = png_check_keyword((uint64_t)a1, *(unsigned __int8 **)a2, v18);
  if (!v6) {
    _cg_png_error(a1, "sPLT: invalid keyword");
  }
  int v7 = v6;
  _cg_png_write_chunk_header((uint64_t)a1, 1934642260);
  _cg_png_write_chunk_data((uint64_t)a1, (Bytef *)v18, (v7 + 1));
  _cg_png_write_chunk_data((uint64_t)a1, v4, 1);
  if (*(int *)(a2 + 32) >= 1)
  {
    uint64_t v8 = (unsigned __int16 *)(*(void *)(a2 + 24) + 4);
    do
    {
      uint64_t v9 = v8 - 2;
      if (*v4 == 8)
      {
        LOBYTE(v16) = *(v8 - 2);
        BYTE1(v16) = *((unsigned char *)v8 - 2);
        BYTE2(v16) = *(unsigned char *)v8;
        unsigned __int16 v10 = v8[1];
        uint64_t v11 = (__int16 *)&v16 + 2;
        uint64_t v12 = (char *)&v16 + 3;
        uint64_t v13 = (char *)&v16 + 5;
      }
      else
      {
        LOWORD(v16) = __rev16(*(v8 - 2));
        WORD1(v16) = bswap32(*(v8 - 1)) >> 16;
        WORD2(v16) = bswap32(*v8) >> 16;
        unsigned __int16 v10 = v8[1];
        BYTE6(v16) = HIBYTE(v10);
        uint64_t v12 = (char *)&v16 + 7;
        uint64_t v11 = &v17;
        uint64_t v13 = (char *)&v17 + 1;
      }
      *uint64_t v12 = v10;
      unsigned __int16 v14 = v8[2];
      *(unsigned char *)uint64_t v11 = HIBYTE(v14);
      *uint64_t v13 = v14;
      _cg_png_write_chunk_data((uint64_t)a1, (Bytef *)&v16, v5);
      v8 += 5;
    }
    while ((unint64_t)(v9 + 5) < *(void *)(a2 + 24) + 10 * *(int *)(a2 + 32));
  }
  return _cg_png_write_chunk_end((uint64_t)a1);
}

void (**png_write_sBIT(uint64_t a1, unsigned __int8 *a2, int a3))(void)
{
  int v11 = 0;
  if ((a3 & 2) != 0)
  {
    if (a3 == 3) {
      unsigned int v4 = 8;
    }
    else {
      unsigned int v4 = *(unsigned __int8 *)(a1 + 393);
    }
    if (*a2) {
      BOOL v5 = v4 >= *a2;
    }
    else {
      BOOL v5 = 0;
    }
    if (!v5) {
      goto LABEL_21;
    }
    unsigned int v6 = a2[1];
    if (!a2[1]) {
      goto LABEL_21;
    }
    if (v4 < v6) {
      goto LABEL_21;
    }
    unsigned int v7 = a2[2];
    if (!a2[2] || v4 < v7) {
      goto LABEL_21;
    }
    LOBYTE(v11) = *a2;
    BYTE1(v11) = v6;
    unint64_t v3 = 3;
    BYTE2(v11) = v7;
    if ((a3 & 4) == 0) {
      return _cg_png_write_complete_chunk((void (**)(void))a1, 1933723988, (Bytef *)&v11, v3);
    }
    goto LABEL_19;
  }
  if (a2[3] && a2[3] <= *(unsigned __int8 *)(a1 + 393))
  {
    LOBYTE(v11) = a2[3];
    unint64_t v3 = 1;
    if ((a3 & 4) == 0) {
      return _cg_png_write_complete_chunk((void (**)(void))a1, 1933723988, (Bytef *)&v11, v3);
    }
LABEL_19:
    unsigned int v8 = a2[4];
    if (!a2[4] || v8 > *(unsigned __int8 *)(a1 + 393)) {
      goto LABEL_21;
    }
    unsigned __int16 v10 = (unsigned char *)((unint64_t)&v11 | v3++);
    *unsigned __int16 v10 = v8;
    return _cg_png_write_complete_chunk((void (**)(void))a1, 1933723988, (Bytef *)&v11, v3);
  }
LABEL_21:

  return (void (**)(void))png_warning(a1, "Invalid sBIT depth specified");
}

void (**png_write_cHRM_fixed(void (**a1)(void), unsigned int *a2))(void)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  long long v5 = 0u;
  long long v6 = 0u;
  png_save_int_32(&v5, a2[6]);
  png_save_int_32((char *)&v5 + 4, a2[7]);
  png_save_int_32((char *)&v5 + 8, *a2);
  png_save_int_32((unint64_t)&v5 | 0xC, a2[1]);
  png_save_int_32(&v6, a2[2]);
  png_save_int_32((char *)&v6 + 4, a2[3]);
  png_save_int_32((char *)&v6 + 8, a2[4]);
  png_save_int_32((char *)&v6 + 12, a2[5]);
  return _cg_png_write_complete_chunk(a1, 1665684045, (Bytef *)&v5, 0x20uLL);
}

void (**png_write_tRNS(uint64_t a1, Bytef *a2, unsigned __int16 *a3, int a4, int a5))(void)
{
  __int16 v17 = 0;
  int v16 = 0;
  if (!a5)
  {
    signed int v6 = a3[4];
    if (1 << *(unsigned char *)(a1 + 392) <= v6)
    {
      long long v5 = "Ignoring attempt to write tRNS chunk out-of-range for bit_depth";
      goto LABEL_21;
    }
    LOWORD(v16) = __rev16(v6);
    unint64_t v7 = 2;
    return _cg_png_write_complete_chunk((void (**)(void))a1, 1951551059, (Bytef *)&v16, v7);
  }
  if (a5 == 2)
  {
    unsigned int v8 = a3[1];
    unsigned int v9 = v8 >> 8;
    LOWORD(v16) = __rev16(v8);
    unsigned int v10 = a3[2];
    unsigned int v11 = v10 >> 8;
    HIWORD(v16) = __rev16(v10);
    unsigned int v12 = a3[3];
    __int16 v17 = __rev16(v12);
    int v13 = v11 | (v12 >> 8) | v9;
    if (*(unsigned char *)(a1 + 392) == 8 && v13 != 0)
    {
      long long v5 = "Ignoring attempt to write 16-bit tRNS chunk when bit_depth is 8";
      goto LABEL_21;
    }
    unint64_t v7 = 6;
    return _cg_png_write_complete_chunk((void (**)(void))a1, 1951551059, (Bytef *)&v16, v7);
  }
  if (a5 != 3)
  {
    long long v5 = "Can't write tRNS with an alpha channel";
    goto LABEL_21;
  }
  if (a4 < 1 || *(unsigned __int16 *)(a1 + 376) < a4)
  {
    long long v5 = "Invalid number of transparent colors specified";
LABEL_21:
    return (void (**)(void))png_app_warning(a1, v5);
  }

  return _cg_png_write_complete_chunk((void (**)(void))a1, 1951551059, a2, a4);
}

void (**png_write_bKGD(uint64_t a1, unsigned __int8 *a2, int a3))(void)
{
  __int16 v16 = 0;
  int v15 = 0;
  if (a3 != 3)
  {
    if ((a3 & 2) != 0)
    {
      unsigned int v7 = *((unsigned __int16 *)a2 + 1);
      unsigned int v8 = v7 >> 8;
      LOWORD(v15) = __rev16(v7);
      unsigned int v9 = *((unsigned __int16 *)a2 + 2);
      unsigned int v10 = v9 >> 8;
      HIWORD(v15) = __rev16(v9);
      unsigned int v11 = *((unsigned __int16 *)a2 + 3);
      __int16 v16 = __rev16(v11);
      int v12 = v10 | (v11 >> 8) | v8;
      if (*(unsigned char *)(a1 + 392) == 8 && v12 != 0)
      {
        unsigned int v4 = "Ignoring attempt to write 16-bit bKGD chunk when bit_depth is 8";
        goto LABEL_19;
      }
      unint64_t v6 = 6;
    }
    else
    {
      signed int v5 = *((unsigned __int16 *)a2 + 4);
      if (1 << *(unsigned char *)(a1 + 392) <= v5)
      {
        unsigned int v4 = "Ignoring attempt to write bKGD chunk out-of-range for bit_depth";
        goto LABEL_19;
      }
      LOWORD(v15) = __rev16(v5);
      unint64_t v6 = 2;
    }
    return _cg_png_write_complete_chunk((void (**)(void))a1, 1649100612, (Bytef *)&v15, v6);
  }
  if (!*(_WORD *)(a1 + 376) && (*(unsigned char *)(a1 + 760) & 1) != 0)
  {
    LOBYTE(v3) = *a2;
    goto LABEL_17;
  }
  unsigned int v3 = *a2;
  if (*(unsigned __int16 *)(a1 + 376) > v3)
  {
LABEL_17:
    LOBYTE(v15) = v3;
    unint64_t v6 = 1;
    return _cg_png_write_complete_chunk((void (**)(void))a1, 1649100612, (Bytef *)&v15, v6);
  }
  unsigned int v4 = "Invalid background palette index";
LABEL_19:

  return (void (**)(void))png_warning(a1, v4);
}

uint64_t png_write_hIST(uint64_t a1, unsigned __int16 *a2, int a3)
{
  if (*(unsigned __int16 *)(a1 + 376) >= a3)
  {
    LODWORD(v5) = a3;
    char v9 = 0;
    __int16 v8 = 0;
    _cg_png_write_chunk_header(a1, 1749635924);
    if ((int)v5 >= 1)
    {
      uint64_t v5 = v5;
      do
      {
        unsigned int v7 = *a2++;
        __int16 v8 = bswap32(v7) >> 16;
        _cg_png_write_chunk_data(a1, (Bytef *)&v8, 2);
        --v5;
      }
      while (v5);
    }
    return _cg_png_write_chunk_end(a1);
  }
  else
  {
    return png_warning(a1, "Invalid number of histogram entries specified");
  }
}

uint64_t png_write_tEXt(void (**a1)(void), unsigned __int8 *a2, char *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  memset(v10, 0, sizeof(v10));
  int v5 = png_check_keyword((uint64_t)a1, a2, v10);
  if (!v5)
  {
    __int16 v8 = "tEXt: invalid keyword";
LABEL_11:
    _cg_png_error(a1, v8);
  }
  int v6 = v5;
  if (a3 && *a3)
  {
    size_t v7 = strlen(a3);
    if (v7 > (2147483646 - v6))
    {
      __int16 v8 = "tEXt: text too long";
      goto LABEL_11;
    }
  }
  else
  {
    size_t v7 = 0;
  }
  _cg_png_write_chunk_header((uint64_t)a1, 1950701684);
  _cg_png_write_chunk_data((uint64_t)a1, (Bytef *)v10, (v6 + 1));
  if (v7) {
    _cg_png_write_chunk_data((uint64_t)a1, (Bytef *)a3, v7);
  }
  return _cg_png_write_chunk_end((uint64_t)a1);
}

uint64_t png_write_zTXt(uint64_t a1, unsigned __int8 *a2, char *a3, int a4)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a4)
  {
    memset(v14, 0, 81);
    bzero(v13, 0x408uLL);
    int v8 = png_check_keyword(a1, a2, v14);
    if (v8)
    {
      v14[v8 + 1] = 0;
      uint64_t v9 = (v8 + 2);
      if (a3) {
        size_t v10 = strlen(a3);
      }
      else {
        size_t v10 = 0;
      }
      v12[0] = a3;
      v12[1] = v10;
      v13[0] = 0;
      if (!png_text_compress(a1, 2052348020, (uint64_t)v12, v9))
      {
        _cg_png_write_chunk_header(a1, 2052348020);
        _cg_png_write_chunk_data(a1, v14, v9);
        png_write_compressed_data_out(a1, (uint64_t)v12);
        return _cg_png_write_chunk_end(a1);
      }
      uint64_t v11 = *(const char **)(a1 + 144);
    }
    else
    {
      uint64_t v11 = "zTXt: invalid keyword";
    }
LABEL_15:
    _cg_png_error((void (**)(void))a1, v11);
  }
  if (a4 != -1)
  {
    uint64_t v11 = "zTXt: invalid compression type";
    goto LABEL_15;
  }

  return png_write_tEXt((void (**)(void))a1, a2, a3);
}

uint64_t png_write_iTXt(uint64_t a1, int a2, unsigned __int8 *a3, char *a4, char *a5, char *a6)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  __int16 v28 = 0;
  memset(v27, 0, sizeof(v27));
  bzero(v26, 0x408uLL);
  int v12 = png_check_keyword(a1, a3, v27);
  if (!v12)
  {
    CFAbsoluteTime v24 = "iTXt: invalid keyword";
    goto LABEL_26;
  }
  char v13 = a2 + 1;
  if ((a2 + 1) >= 4)
  {
    CFAbsoluteTime v24 = "iTXt: invalid compression";
    goto LABEL_26;
  }
  int v14 = v12;
  v27[v12 + 1] = 0x1000100u >> (8 * v13);
  v27[v12 + 2] = 0;
  uint64_t v15 = (v12 + 3);
  if (!a4) {
    a4 = "";
  }
  unint64_t v16 = strlen(a4) + 1;
  if (!a5) {
    a5 = "";
  }
  unint64_t v17 = strlen(a5) + 1;
  if (!a6) {
    a6 = "";
  }
  int v18 = v15 + v16;
  if (v16 > (2147483644 - v14)) {
    int v18 = 0x7FFFFFFF;
  }
  unint64_t v19 = v18 ^ 0x7FFFFFFFu;
  int v20 = v18 + v17;
  if (v17 <= v19) {
    int v21 = v20;
  }
  else {
    int v21 = 0x7FFFFFFF;
  }
  size_t v22 = strlen(a6);
  v25[0] = a6;
  v25[1] = v22;
  v26[0] = 0;
  if ((v13 & 1) == 0)
  {
    if (v22 <= (v21 ^ 0x7FFFFFFFu))
    {
      v26[0] = v22;
      goto LABEL_18;
    }
    CFAbsoluteTime v24 = "iTXt: uncompressed text too long";
LABEL_26:
    _cg_png_error((void (**)(void))a1, v24);
  }
  if (png_text_compress(a1, 1767135348, (uint64_t)v25, v21))
  {
    CFAbsoluteTime v24 = *(const char **)(a1 + 144);
    goto LABEL_26;
  }
LABEL_18:
  _cg_png_write_chunk_header(a1, 1767135348);
  _cg_png_write_chunk_data(a1, v27, v15);
  _cg_png_write_chunk_data(a1, (Bytef *)a4, v16);
  _cg_png_write_chunk_data(a1, (Bytef *)a5, v17);
  if (v13) {
    png_write_compressed_data_out(a1, (uint64_t)v25);
  }
  else {
    _cg_png_write_chunk_data(a1, (Bytef *)a6, v26[0]);
  }
  return _cg_png_write_chunk_end(a1);
}

void (**png_write_oFFs(void (**a1)(void), uint64_t a2, uint64_t a3, int a4))(void)
{
  char v4 = a4;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a4 >= 2) {
    png_warning((uint64_t)a1, "Unrecognized unit type for oFFs chunk");
  }
  char v10 = 0;
  uint64_t v9 = 0;
  png_save_int_32(&v9, a2);
  png_save_int_32((char *)&v9 + 4, a3);
  char v10 = v4;
  return _cg_png_write_complete_chunk(a1, 1866876531, (Bytef *)&v9, 9uLL);
}

uint64_t png_write_pCAL(void (**a1)(void), unsigned __int8 *a2, unsigned int a3, unsigned int a4, int a5, int a6, const char *a7, const char **a8)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (a5 >= 4)
  {
    int v35 = "Unrecognized equation type for pCAL chunk";
    goto LABEL_18;
  }
  char v12 = a5;
  __int16 v44 = 0;
  uint64_t v43 = 0;
  memset(v42, 0, sizeof(v42));
  int v15 = png_check_keyword((uint64_t)a1, a2, v42);
  if (!v15)
  {
    int v35 = "pCAL: invalid keyword";
LABEL_18:
    _cg_png_error(a1, v35);
  }
  unsigned int v37 = a3;
  unsigned int v38 = a4;
  char v40 = v12;
  uint64_t v16 = (v15 + 1);
  int v41 = (Bytef *)a7;
  size_t v17 = strlen(a7);
  if (a6) {
    size_t v18 = v17 + 1;
  }
  else {
    size_t v18 = v17;
  }
  uint64_t v36 = v18;
  uint64_t v19 = v16 + v18 + 10;
  int v20 = png_malloc(a1, 8 * a6);
  uint64_t v21 = a6;
  uint64_t v22 = (a6 - 1);
  int v39 = (uint64_t *)v20;
  if (a6 >= 1)
  {
    uint64_t v23 = a6;
    CFAbsoluteTime v24 = a8;
    xpc_object_t v25 = v20;
    do
    {
      xpc_object_t v26 = *v24++;
      size_t v27 = strlen(v26);
      BOOL v28 = v22-- != 0;
      if (v28) {
        size_t v29 = v27 + 1;
      }
      else {
        size_t v29 = v27;
      }
      *v25++ = (void (*)(void))v29;
      v19 += v27 + v28;
      --v23;
    }
    while (v23);
  }
  _cg_png_write_chunk_header((uint64_t)a1, 1883455820);
  _cg_png_write_chunk_data((uint64_t)a1, (Bytef *)v42, v16);
  png_save_int_32(&v43, v37);
  png_save_int_32((char *)&v43 + 4, v38);
  LOBYTE(v44) = v40;
  HIBYTE(v44) = a6;
  _cg_png_write_chunk_data((uint64_t)a1, (Bytef *)&v43, 10);
  _cg_png_write_chunk_data((uint64_t)a1, v41, v36);
  if (a6 >= 1)
  {
    int v30 = v39;
    do
    {
      int v32 = (Bytef *)*a8++;
      int v31 = v32;
      uint64_t v33 = *v30++;
      _cg_png_write_chunk_data((uint64_t)a1, v31, v33);
      --v21;
    }
    while (v21);
  }
  png_free((uint64_t)a1, v39);
  return _cg_png_write_chunk_end((uint64_t)a1);
}

void (**png_write_sCAL_s(void (**a1)(void), Bytef a2, char *__s, const char *a4))(void)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  size_t v7 = strlen(__s);
  size_t v8 = strlen(a4);
  unint64_t v9 = v7 + v8 + 2;
  if (v9 < 0x41)
  {
    size_t v11 = v8;
    memset(&v12[1], 0, 63);
    v12[0] = a2;
    __memcpy_chk();
    memcpy(&v12[v7 + 2], a4, v11);
    return _cg_png_write_complete_chunk(a1, 1933787468, v12, v9);
  }
  else
  {
    return (void (**)(void))png_warning((uint64_t)a1, "Can't write sCAL (buffer too small)");
  }
}

void (**png_write_tIME(void (**a1)(void), unsigned __int16 *a2))(void)
{
  int v2 = *((unsigned __int8 *)a2 + 2);
  if ((v2 - 13) >= 0xFFFFFFF4
    && (int v3 = *((unsigned __int8 *)a2 + 3), (v3 - 32) >= 0xFFFFFFE1)
    && (unsigned int v4 = *((unsigned __int8 *)a2 + 4), v4 <= 0x17)
    && (unsigned int v5 = *((unsigned __int8 *)a2 + 6), v5 < 0x3D))
  {
    unsigned __int16 v7 = *a2;
    v8[0] = HIBYTE(*a2);
    v8[1] = v7;
    _OWORD v8[2] = v2;
    void v8[3] = v3;
    _OWORD v8[4] = v4;
    v8[5] = *((unsigned char *)a2 + 5);
    v8[6] = v5;
    return _cg_png_write_complete_chunk(a1, 1950960965, v8, 7uLL);
  }
  else
  {
    return (void (**)(void))png_warning((uint64_t)a1, "Invalid time specified for tIME chunk");
  }
}

void (**png_write_acTL(uint64_t a1, int a2, int a3))(void)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)(a1 + 808) = a2;
  int v3 = a2 - (*(_DWORD *)(a1 + 768) & 1);
  v5[0] = HIBYTE(v3);
  v5[1] = BYTE2(v3);
  _OWORD v5[2] = BYTE1(v3);
  void v5[3] = v3;
  v5[4] = HIBYTE(a3);
  v5[5] = BYTE2(a3);
  v5[6] = BYTE1(a3);
  v5[7] = a3;
  return _cg_png_write_complete_chunk((void (**)(void))a1, 1633899596, v5, 8uLL);
}

void (**png_write_fcTL(uint64_t a1, int a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, Bytef a8, unsigned __int8 a9))(void)
{
  __int16 v10 = a7;
  __int16 v11 = a6;
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int v17 = *(_DWORD *)(a1 + 812);
  if (a5 | a4 && !v17)
  {
    int v20 = "x and/or y offset for the first frame aren't 0";
    goto LABEL_9;
  }
  if (!v17 && (*(_DWORD *)(a1 + 776) != a2 || *(_DWORD *)(a1 + 780) != a3))
  {
    int v20 = "width and/or height in the first frame's fcTL don't match the ones in IHDR";
LABEL_9:
    _cg_png_error((void (**)(void))a1, v20);
  }
  png_ensure_fcTL_is_valid(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  int v18 = *(_DWORD *)(a1 + 772);
  v21[0] = HIBYTE(v18);
  v21[1] = BYTE2(v18);
  _OWORD v21[2] = BYTE1(v18);
  v21[3] = v18;
  v21[4] = HIBYTE(a2);
  v21[5] = BYTE2(a2);
  v21[6] = BYTE1(a2);
  v21[7] = a2;
  _WORD v21[8] = HIBYTE(a3);
  v21[9] = BYTE2(a3);
  v21[10] = BYTE1(a3);
  v21[11] = a3;
  v21[12] = HIBYTE(a4);
  v21[13] = BYTE2(a4);
  v21[14] = BYTE1(a4);
  v21[15] = a4;
  v21[16] = HIBYTE(a5);
  v21[17] = BYTE2(a5);
  v21[18] = BYTE1(a5);
  v21[19] = a5;
  v21[20] = HIBYTE(v11);
  v21[21] = v11;
  v21[22] = HIBYTE(v10);
  v21[23] = v10;
  v21[24] = a8;
  v21[25] = a9;
  uint64_t result = _cg_png_write_complete_chunk((void (**)(void))a1, 1717785676, v21, 0x1AuLL);
  ++*(_DWORD *)(a1 + 772);
  return result;
}

uint64_t png_do_write_interlace(uint64_t result, unsigned __int8 *__dst, int a3)
{
  if (a3 > 5) {
    return result;
  }
  uint64_t v4 = result;
  unint64_t v5 = *(unsigned __int8 *)(result + 19);
  if (v5 == 4)
  {
    unsigned int v14 = *(_DWORD *)result;
    uint64_t v7 = a3;
    unsigned int v8 = png_do_write_interlace_png_pass_start[a3];
    if (*(_DWORD *)result <= v8) {
      goto LABEL_34;
    }
    int v9 = 0;
    int v15 = png_do_write_interlace_png_pass_inc[a3];
    int v16 = 4 * v8;
    unsigned int v17 = png_do_write_interlace_png_pass_start[a3];
    int v18 = 4;
    uint64_t v13 = __dst;
    do
    {
      uint64_t result = ~v16 & 4;
      v9 |= ((__dst[(unint64_t)v17 >> 1] >> (~(_BYTE)v16 & 4)) & 0xF) << v18;
      if (v18)
      {
        v18 -= 4;
      }
      else
      {
        *v13++ = v9;
        int v18 = 4;
        int v9 = 0;
      }
      v17 += v15;
      v16 += 4 * v15;
    }
    while (v17 < v14);
    if (v18 == 4) {
      goto LABEL_34;
    }
    goto LABEL_28;
  }
  if (v5 == 2)
  {
    unsigned int v19 = *(_DWORD *)result;
    uint64_t v7 = a3;
    unsigned int v8 = png_do_write_interlace_png_pass_start[a3];
    if (*(_DWORD *)result <= v8) {
      goto LABEL_34;
    }
    int v9 = 0;
    int v20 = png_do_write_interlace_png_pass_inc[a3];
    int v21 = 2 * v8;
    unsigned int v22 = png_do_write_interlace_png_pass_start[a3];
    int v23 = 6;
    uint64_t v13 = __dst;
    do
    {
      uint64_t result = ~v21 & 6;
      v9 |= ((__dst[(unint64_t)v22 >> 2] >> (~(_BYTE)v21 & 6)) & 3) << v23;
      if (v23)
      {
        v23 -= 2;
      }
      else
      {
        *v13++ = v9;
        int v23 = 6;
        int v9 = 0;
      }
      v22 += v20;
      v21 += 2 * v20;
    }
    while (v22 < v19);
    if (v23 == 6) {
      goto LABEL_34;
    }
    goto LABEL_28;
  }
  if (v5 != 1)
  {
    unsigned int v24 = *(_DWORD *)result;
    uint64_t v7 = a3;
    unsigned int v8 = png_do_write_interlace_png_pass_start[a3];
    if (*(_DWORD *)result > v8)
    {
      size_t v25 = v5 >> 3;
      int v26 = png_do_write_interlace_png_pass_inc[a3];
      unsigned int v27 = png_do_write_interlace_png_pass_start[a3];
      BOOL v28 = __dst;
      do
      {
        size_t v29 = &__dst[v25 * (unint64_t)v27];
        if (v28 != v29) {
          uint64_t result = (uint64_t)memcpy(v28, v29, v25);
        }
        v28 += v25;
        v27 += v26;
      }
      while (v27 < v24);
    }
    goto LABEL_34;
  }
  unsigned int v6 = *(_DWORD *)result;
  uint64_t v7 = a3;
  unsigned int v8 = png_do_write_interlace_png_pass_start[a3];
  if (*(_DWORD *)result > v8)
  {
    int v9 = 0;
    int v10 = png_do_write_interlace_png_pass_inc[a3];
    unsigned int v11 = png_do_write_interlace_png_pass_start[a3];
    int v12 = 7;
    uint64_t v13 = __dst;
    do
    {
      v9 |= ((__dst[(unint64_t)v11 >> 3] >> (~(_BYTE)v11 & 7)) & 1) << v12;
      if (v12)
      {
        --v12;
      }
      else
      {
        *v13++ = v9;
        int v12 = 7;
        int v9 = 0;
      }
      v11 += v10;
    }
    while (v11 < v6);
    if (v12 != 7) {
LABEL_28:
    }
      *uint64_t v13 = v9;
  }
LABEL_34:
  unsigned int v30 = (*(_DWORD *)v4 + ~v8 + png_do_write_interlace_png_pass_inc[v7]) / png_do_write_interlace_png_pass_inc[v7];
  *(_DWORD *)uint64_t v4 = v30;
  unint64_t v31 = *(unsigned __int8 *)(v4 + 19);
  unint64_t v32 = (v31 * v30 + 7) >> 3;
  unint64_t v33 = (v31 >> 3) * (unint64_t)v30;
  if (v31 < 8) {
    unint64_t v33 = v32;
  }
  *(void *)(v4 + 8) = v33;
  return result;
}

unint64_t png_setup_up_row(void *a1, unint64_t a2, unint64_t a3, int a4)
{
  uint64_t v8 = a1[42];
  *(unsigned char *)uint64_t v8 = 2;
  __int16 CPUCapabilities = AppleGetCPUCapabilities();
  if (a4 == 4 && (CPUCapabilities & 0x100) != 0) {
    return png_write_filter_row_up_neon((int8x16_t *)(a1[41] + 1), (int8x16_t *)(v8 + 1), (int8x16_t *)(a1[40] + 1), a2, v10, v11, v12, v13);
  }
  unint64_t result = 0;
  if (a2)
  {
    int v15 = (char *)(a1[41] + 1);
    int v16 = (char *)(a1[40] + 1);
    unsigned int v17 = (unsigned __int8 *)(v8 + 1);
    unint64_t v18 = a2 - 1;
    do
    {
      char v20 = *v15++;
      char v19 = v20;
      char v21 = *v16++;
      unsigned __int8 v22 = v19 - v21;
      int v23 = (char)v22;
      *v17++ = v22;
      unsigned int v24 = v22;
      LODWORD(v25) = 256 - v22;
      if (v23 >= 0) {
        uint64_t v25 = v24;
      }
      else {
        uint64_t v25 = v25;
      }
      result += v25;
    }
    while (result <= a3 && v18-- != 0);
  }
  return result;
}

uint64_t png_write_reset(uint64_t result)
{
  *(_DWORD *)(result + 308) = 0;
  *(unsigned char *)(result + 389) = 0;
  *(_DWORD *)(result + 76) &= ~4u;
  return result;
}

uint64_t png_write_reinit(uint64_t a1, unsigned __int8 *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v7 = *(_DWORD *)(a1 + 776);
  if (*(_DWORD *)(a1 + 812))
  {
    if (v7 < a3) {
      goto LABEL_10;
    }
  }
  else if (v7 != a3 || *(_DWORD *)(a1 + 780) != a4)
  {
    int32x4_t v12 = "width and/or height in the first frame's fcTL don't match the ones in IHDR";
LABEL_12:
    _cg_png_error((void (**)(void))a1, v12);
  }
  if (*(_DWORD *)(a1 + 780) < a4)
  {
LABEL_10:
    int32x4_t v12 = "width and/or height for a frame greater thanthe ones in IHDR";
    goto LABEL_12;
  }
  uint64_t result = _cg_png_set_IHDR(a1, (uint64_t)a2, a3, a4, a2[36], a2[37], a2[40], a2[38], a2[39]);
  *(_DWORD *)(a1 + 280) = a3;
  *(_DWORD *)(a1 + 284) = a4;
  unint64_t v9 = *(unsigned __int8 *)(a1 + 394);
  BOOL v10 = v9 >= 8;
  unint64_t v11 = (v9 >> 3) * (unint64_t)a3;
  if (!v10) {
    unint64_t v11 = (*(unsigned __int8 *)(a1 + 394) * (unint64_t)a3 + 7) >> 3;
  }
  *(void *)(a1 + 296) = v11;
  *(_DWORD *)(a1 + 292) = a3;
  return result;
}

uint64_t _cg_TIFFReadScanline(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = a3;
  if (!TIFFCheckRead(a1, 0, a3, a4, a5, a6, a7, a8)) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)(a1 + 92) <= v9)
  {
    TIFFErrorExtR(a1, *(const char **)a1, "%u: Row out of range, max %u", v13, v14, v15, v16, v17, v9);
LABEL_7:
    size_t v20 = _cg_TIFFScanlineSize(a1, v19, v12, v13, v14, v15, v16, v17);
    bzero(a2, v20);
    return 0xFFFFFFFFLL;
  }
  if (*(_WORD *)(a1 + 170) == 2)
  {
    if (*(unsigned __int16 *)(a1 + 130) <= a4)
    {
      TIFFErrorExtR(a1, *(const char **)a1, "%hu: Sample out of range, max %hu", v13, v14, v15, v16, v17, a4);
      goto LABEL_7;
    }
    uint64_t v18 = v9 / *(_DWORD *)(a1 + 132) + *(_DWORD *)(a1 + 224) * a4;
  }
  else
  {
    uint64_t v18 = v9 / *(_DWORD *)(a1 + 132);
  }
  if (v18 != *(_DWORD *)(a1 + 884) && !TIFFFillStrip(a1, v18, v12, v13, v14, v15, v16, v17)) {
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 876) > v9)
  {
    if (!*(void *)(a1 + 1136)) {
      goto LABEL_31;
    }
    if ((*(void *)(a1 + 1128) & 0x8000000000000000) != 0)
    {
      *(_DWORD *)(a1 + 884) = -1;
      if ((*(unsigned char *)(a1 + 17) & 2) == 0)
      {
        TIFFErrorExtR(a1, "TIFFFillStripPartial", "Data buffer too small to hold part of strip %d", v13, v14, v15, v16, v17, v18);
        goto LABEL_7;
      }
    }
    *(void *)(a1 + 1136) = 0;
    *(void *)(a1 + 1144) = 0;
    uint64_t v23 = TIFFGetStrileOffset(a1, v18);
    if (!_TIFFSeekOK(a1, *(void *)(a1 + 1136) + *(void *)(a1 + 1144) + v23))
    {
      TIFFErrorExtR(a1, "TIFFFillStripPartial", "Seek error at scanline %u, strip %d", v24, v25, v26, v27, v28, *(_DWORD *)(a1 + 876));
      goto LABEL_7;
    }
    unint64_t v29 = *(void *)(a1 + 1128) & ~(*(uint64_t *)(a1 + 1128) >> 63);
    if (v29 > TIFFGetStrileByteCount(a1, v18) - (*(void *)(a1 + 1136) + *(void *)(a1 + 1144))) {
      unint64_t v29 = TIFFGetStrileByteCount(a1, v18) - (*(void *)(a1 + 1136) + *(void *)(a1 + 1144));
    }
    if ((*(unsigned char *)(a1 + 18) & 0x80) != 0) {
      _cg_TIFFReadScanline_cold_2();
    }
    if (!TIFFReadAndRealloc(a1, v29, 0, 1, 0, "TIFFFillStripPartial", v30, v31)) {
      goto LABEL_7;
    }
    *(void *)(a1 + 1136) += *(void *)(a1 + 1144);
    *(void *)(a1 + 1144) = v29;
    *(void *)(a1 + 1160) = v29;
    unint64_t v32 = *(unsigned __int8 **)(a1 + 1120);
    *(void *)(a1 + 1152) = v32;
    int v33 = *(_DWORD *)(a1 + 16);
    if (((unsigned __int16)v33 & (*(_WORD *)(a1 + 126) | 0x100)) == 0)
    {
      if ((v33 & 0x800000) != 0) {
        _cg_TIFFReadScanline_cold_1();
      }
      TIFFReverseBits(v32, v29);
    }
    if (*(_WORD *)(a1 + 120) == 7
      && (unint64_t v34 = *(void *)(a1 + 1160), v34 < TIFFGetStrileByteCount(a1, v18))
      && TIFFJPEGIsFullStripRequired(a1))
    {
      int v35 = TIFFFillStrip(a1, v18, v12, v13, v14, v15, v16, v17);
    }
    else
    {
LABEL_31:
      int v35 = TIFFStartStrip(a1, v18, v12, v13, v14, v15, v16, v17);
    }
    if (!v35) {
      goto LABEL_7;
    }
  }
  int v36 = *(_DWORD *)(a1 + 876);
  if (v9 != v36)
  {
    if (!(*(unsigned int (**)(uint64_t, void))(a1 + 1064))(a1, v9 - v36)) {
      goto LABEL_7;
    }
    *(_DWORD *)(a1 + 876) = v9;
  }
  int v37 = (*(uint64_t (**)(uint64_t, void *, void, uint64_t))(a1 + 1008))(a1, a2, *(void *)(a1 + 1104), a4);
  *(_DWORD *)(a1 + 876) = v9 + 1;
  uint64_t v21 = 0xFFFFFFFFLL;
  if (v37)
  {
    int v38 = v37;
    (*(void (**)(uint64_t, void *, void))(a1 + 1248))(a1, a2, *(void *)(a1 + 1104));
    if (v38 < 1) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 1;
    }
  }
  return v21;
}

uint64_t TIFFCheckRead(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 12) == 1)
  {
    uint64_t v8 = *(const char **)a1;
    unsigned int v9 = "File not open for reading";
  }
  else
  {
    if (((*(_DWORD *)(a1 + 16) >> 10) & 1) == a2) {
      return 1;
    }
    if (a2) {
      unsigned int v9 = "Can not read tiles from a striped image";
    }
    else {
      unsigned int v9 = "Can not read scanlines from a tiled image";
    }
    uint64_t v8 = *(const char **)a1;
  }
  TIFFErrorExtR(a1, v8, v9, a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t _cg_TIFFReadEncodedStrip(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int16 v22 = 0;
  Stripuint64_t Size = TIFFReadEncodedStripGetStripSize((_DWORD *)a1, a2, &v22, a4, a5, a6, a7, a8);
  size_t v19 = StripSize;
  if (StripSize != -1)
  {
    if (StripSize > a4 || a4 == -1 || *(_WORD *)(a1 + 120) != 1 || (*(_DWORD *)(a1 + 16) & 0x20800) != 0)
    {
      if (StripSize > a4 && a4 != -1) {
        size_t v19 = a4;
      }
      if (TIFFFillStrip(a1, a2, v13, v14, v15, v16, v17, v18))
      {
        if ((*(int (**)(uint64_t, void *, size_t, void))(a1 + 1024))(a1, a3, v19, v22) >= 1)
        {
LABEL_13:
          (*(void (**)(uint64_t, void *, size_t))(a1 + 1248))(a1, a3, v19);
          return v19;
        }
      }
      else
      {
        bzero(a3, v19);
      }
    }
    else if (TIFFReadRawStrip1(a1, a2, a3, StripSize, "TIFFReadEncodedStrip") == StripSize)
    {
      if ((*(_DWORD *)(a1 + 16) & (*(unsigned __int16 *)(a1 + 126) | 0x100)) == 0) {
        TIFFReverseBits((unsigned __int8 *)a3, v19);
      }
      goto LABEL_13;
    }
    return -1;
  }
  return v19;
}

uint64_t TIFFReadEncodedStripGetStripSize(_DWORD *a1, unsigned int a2, _WORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!TIFFCheckRead((uint64_t)a1, 0, (uint64_t)a3, a4, a5, a6, a7, a8)) {
    return -1;
  }
  if (a1[57] <= a2)
  {
    TIFFErrorExtR((uint64_t)a1, "TIFFReadEncodedStrip", "%u: Strip out of range, max %u", v12, v13, v14, v15, v16, a2);
    return -1;
  }
  unsigned int v17 = a1[33];
  unsigned int v18 = a1[23];
  if (v17 >= v18) {
    unsigned int v17 = a1[23];
  }
  if (!v17)
  {
    TIFFErrorExtR((uint64_t)a1, "TIFFReadEncodedStrip", "rowsperstrip is zero", v12, v13, v14, v15, v16, v25);
    return -1;
  }
  unsigned int v19 = v18 / v17;
  if (v18 % v17) {
    ++v19;
  }
  int v20 = a2 / v19;
  int v21 = a2 % v19;
  if (a3) {
    *a3 = v20;
  }
  unsigned int v22 = v18 - v21 * v17;
  if (v22 >= v17) {
    uint64_t v23 = v17;
  }
  else {
    uint64_t v23 = v22;
  }
  uint64_t result = TIFFVStripSize((uint64_t)a1, v23, v11, v12, v13, v14, v15, v16);
  if (!result) {
    return -1;
  }
  return result;
}

uint64_t TIFFReadRawStrip1(uint64_t a1, uint64_t a2, void *a3, size_t a4, const char *a5)
{
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x20000) != 0) {
    TIFFReadRawStrip1_cold_1();
  }
  uint64_t v11 = TIFFGetStrileOffset(a1, a2);
  if ((v5 & 0x800) != 0)
  {
    if (v11 < 0)
    {
      uint64_t v27 = 0;
      size_t v31 = 0;
    }
    else
    {
      uint64_t v27 = TIFFGetStrileOffset(a1, a2);
      int64_t v28 = *(void *)(a1 + 1176);
      if ((uint64_t)(v27 + a4) <= v28) {
        size_t v29 = a4;
      }
      else {
        size_t v29 = v28 - v27;
      }
      if (v27 <= (uint64_t)(a4 ^ 0x7FFFFFFFFFFFFFFFLL)) {
        size_t v30 = v29;
      }
      else {
        size_t v30 = 0;
      }
      if (v28 >= v27) {
        size_t v31 = v30;
      }
      else {
        size_t v31 = 0;
      }
    }
    if (v31 != a4)
    {
      TIFFErrorExtR(a1, a5, "Read error at scanline %u, strip %u; got %lld bytes, expected %lld",
        v12,
        v13,
        v14,
        v15,
        v16,
        *(_DWORD *)(a1 + 876));
      return -1;
    }
    _TIFFmemcpy(a3, (const void *)(*(void *)(a1 + 1168) + v27), a4);
  }
  else
  {
    if (!_TIFFSeekOK(a1, v11))
    {
      TIFFErrorExtR(a1, a5, "Seek error at scanline %u, strip %u", v17, v18, v19, v20, v21, *(_DWORD *)(a1 + 876));
      return -1;
    }
    if ((*(uint64_t (**)(void, void *, size_t))(a1 + 1208))(*(void *)(a1 + 1200), a3, a4) != a4)
    {
      TIFFErrorExtR(a1, a5, "Read error at scanline %u; got %lld bytes, expected %lld",
        v22,
        v23,
        v24,
        v25,
        v26,
        *(_DWORD *)(a1 + 876));
      return -1;
    }
  }
  return a4;
}

uint64_t TIFFFillStrip(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a1 + 18) & 2) == 0)
  {
    uint64_t v10 = TIFFGetStrileByteCount(a1, a2);
    int64_t v18 = v10;
    if (v10 <= 0)
    {
      TIFFErrorExtR(a1, "TIFFFillStrip", "Invalid strip byte count %llu, strip %u", v13, v14, v15, v16, v17, v10);
      return 0;
    }
    if ((unint64_t)v10 > 0x100000)
    {
      unint64_t v19 = _cg_TIFFStripSize(a1, v11, v12, v13, v14, v15, v16, v17);
      if (v19)
      {
        if (v19 < (v18 - 4096) / 0xAuLL)
        {
          uint64_t v20 = 10 * v19 + 4096;
          TIFFErrorExtR(a1, "TIFFFillStrip", "Too large strip byte count %llu, strip %u. Limiting to %llu", v13, v14, v15, v16, v17, v18);
          int64_t v18 = v20;
        }
      }
    }
    int v21 = *(_DWORD *)(a1 + 16);
    if ((v21 & 0x800) != 0)
    {
      if ((unint64_t)v18 > *(void *)(a1 + 1176)
        || TIFFGetStrileOffset(a1, a2) > (unint64_t)(*(void *)(a1 + 1176) - v18))
      {
        TIFFGetStrileOffset(a1, a2);
        TIFFErrorExtR(a1, "TIFFFillStrip", "Read error on strip %u; got %llu bytes, expected %llu",
          v23,
          v24,
          v25,
          v26,
          v27,
          a2);
        *(_DWORD *)(a1 + 884) = -1;
        return 0;
      }
      int v21 = *(_DWORD *)(a1 + 16);
      if ((v21 & 0x800) != 0 && ((unsigned __int16)v21 & (*(_WORD *)(a1 + 126) | 0x100)) != 0)
      {
        if ((v21 & 0x200) != 0)
        {
          size_t v30 = *(char **)(a1 + 1120);
          if (v30)
          {
            _TIFFfreeExt(a1, v30);
            *(void *)(a1 + 1120) = 0;
            int v21 = *(_DWORD *)(a1 + 16);
          }
        }
        *(_DWORD *)(a1 + 16) = v21 & 0xFFFFFDFF;
        *(void *)(a1 + 1128) = v18;
        uint64_t v31 = *(void *)(a1 + 1168);
        *(void *)(a1 + 1120) = v31 + TIFFGetStrileOffset(a1, a2);
        *(void *)(a1 + 1136) = 0;
        *(void *)(a1 + 1144) = v18;
        *(_DWORD *)(a1 + 16) |= 0x800000u;
        goto LABEL_33;
      }
    }
    int64_t v22 = *(void *)(a1 + 1128);
    if (v18 > v22)
    {
      *(_DWORD *)(a1 + 884) = -1;
      if ((v21 & 0x200) == 0)
      {
        TIFFErrorExtR(a1, "TIFFFillStrip", "Data buffer too small to hold strip %u", v13, v14, v15, v16, v17, a2);
        return 0;
      }
    }
    if ((v21 & 0x800000) != 0)
    {
      int64_t v22 = 0;
      *(_DWORD *)(a1 + 884) = -1;
      v21 &= ~0x800000u;
      *(_OWORD *)(a1 + 1120) = 0u;
      *(_DWORD *)(a1 + 16) = v21;
    }
    if ((v21 & 0x800) != 0)
    {
      if (v18 > v22 && !TIFFReadBufferSetup(a1, 0, v18, v13, v14, v15, v16, v17)) {
        return 0;
      }
      uint64_t v28 = TIFFReadRawStrip1(a1, a2, *(void **)(a1 + 1120), v18, "TIFFFillStrip");
    }
    else
    {
      uint64_t v28 = TIFFReadRawStripOrTile2(a1, a2, 1, v18, "TIFFFillStrip");
    }
    if (v28 != v18) {
      return 0;
    }
    *(void *)(a1 + 1136) = 0;
    *(void *)(a1 + 1144) = v18;
    if ((*(_DWORD *)(a1 + 16) & (*(unsigned __int16 *)(a1 + 126) | 0x100)) == 0) {
      TIFFReverseBits(*(unsigned __int8 **)(a1 + 1120), v18);
    }
  }
LABEL_33:

  return TIFFStartStrip(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t _TIFFReadEncodedStripAndAllocBuffer(uint64_t a1, uint64_t a2, void *a3, size_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a5;
  uint64_t v12 = (void *)*a3;
  if (!v12)
  {
    unsigned __int16 v37 = 0;
    Stripuint64_t Size = TIFFReadEncodedStripGetStripSize((_DWORD *)a1, a2, &v37, a4, a5, a6, a7, a8);
    if (StripSize != -1)
    {
      if (StripSize <= v8 || v8 == -1) {
        uint64_t v8 = StripSize;
      }
      if (TIFFFillStrip(a1, a2, v16, v17, v18, v19, v20, v21))
      {
        size_t v29 = _TIFFmallocExt((void *)a1, a4, v23, v24, v25, v26, v27, v28);
        *a3 = v29;
        if (v29)
        {
          _TIFFmemset(v29, 0, a4);
          if ((*(int (**)(uint64_t, void, uint64_t, void))(a1 + 1024))(a1, *a3, v8, v37) >= 1)
          {
            (*(void (**)(uint64_t, void, uint64_t))(a1 + 1248))(a1, *a3, v8);
            return v8;
          }
        }
        else
        {
          size_t v30 = (const char *)TIFFFileName(a1);
          TIFFErrorExtR(a1, v30, "No space for strip buffer", v31, v32, v33, v34, v35, v36);
        }
      }
    }
    return -1;
  }

  return _cg_TIFFReadEncodedStrip(a1, a2, v12, a5, a5, a6, a7, a8);
}

uint64_t TIFFReadBufferSetup(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 16);
  if ((v8 & 0x20000) != 0) {
    TIFFReadBufferSetup_cold_1();
  }
  *(_DWORD *)(a1 + 16) = v8 & 0xFF7FFFFF;
  uint64_t v12 = *(char **)(a1 + 1120);
  if (v12)
  {
    uint64_t v13 = (void *)(a1 + 1120);
    if ((v8 & 0x200) != 0) {
      _TIFFfreeExt(a1, v12);
    }
    *uint64_t v13 = 0;
    *(void *)(a1 + 1128) = 0;
  }
  if (a2)
  {
    *(void *)(a1 + 1128) = a3;
    *(void *)(a1 + 1120) = a2;
    *(_DWORD *)(a1 + 16) &= ~0x200u;
    return 1;
  }
  else
  {
    unint64_t v16 = (a3 + 1023) & 0xFFFFFFFFFFFFFC00;
    *(void *)(a1 + 1128) = v16;
    if (v16)
    {
      uint64_t v14 = 1;
      uint64_t v17 = _TIFFcallocExt((void *)a1, 1, v16, a4, a5, a6, a7, a8);
      *(void *)(a1 + 1120) = v17;
      *(_DWORD *)(a1 + 16) |= 0x200u;
      if (!v17)
      {
        TIFFErrorExtR(a1, "TIFFReadBufferSetup", "No space for data buffer at scanline %u", v18, v19, v20, v21, v22, *(_DWORD *)(a1 + 876));
        uint64_t v14 = 0;
        *(void *)(a1 + 1128) = 0;
      }
    }
    else
    {
      TIFFErrorExtR(a1, "TIFFReadBufferSetup", "Invalid buffer size", a4, a5, a6, a7, a8, v23);
      return 0;
    }
  }
  return v14;
}

uint64_t TIFFReadRawStripOrTile2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5)
{
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x800) != 0) {
    TIFFReadRawStripOrTile2_cold_2();
  }
  if ((v5 & 0x20000) != 0) {
    TIFFReadRawStripOrTile2_cold_1();
  }
  uint64_t v11 = TIFFGetStrileOffset(a1, a2);
  if (_TIFFSeekOK(a1, v11))
  {
    if (TIFFReadAndRealloc(a1, a4, 0, a3, a2, a5, v15, v16)) {
      return a4;
    }
    else {
      return -1;
    }
  }
  else
  {
    if (a3) {
      TIFFErrorExtR(a1, a5, "Seek error at scanline %u, strip %u", v12, v13, v14, v15, v16, *(_DWORD *)(a1 + 876));
    }
    else {
      TIFFErrorExtR(a1, a5, "Seek error at row %u, col %u, tile %u", v12, v13, v14, v15, v16, *(_DWORD *)(a1 + 876));
    }
    return -1;
  }
}

uint64_t TIFFStartStrip(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = *(_DWORD *)(a1 + 16);
  if ((v10 & 0x20) == 0)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(a1 + 960))(a1);
    if (!result) {
      return result;
    }
    int v10 = *(_DWORD *)(a1 + 16) | 0x20;
    *(_DWORD *)(a1 + 16) = v10;
  }
  *(_DWORD *)(a1 + 884) = a2;
  unsigned int v12 = *(_DWORD *)(a1 + 224);
  if (v12)
  {
    *(_DWORD *)(a1 + 876) = *(_DWORD *)(a1 + 132) * (a2 % v12);
    *(_DWORD *)(a1 + 16) = v10 & 0xFFEFFFFF;
    if ((v10 & 0x20000) != 0)
    {
      *(_OWORD *)(a1 + 1152) = 0u;
    }
    else
    {
      *(void *)(a1 + 1152) = *(void *)(a1 + 1120);
      uint64_t v13 = *(void *)(a1 + 1144);
      if (v13 < 1)
      {
        *(void *)(a1 + 1160) = TIFFGetStrileByteCount(a1, a2);
        unsigned int v12 = *(_DWORD *)(a1 + 224);
      }
      else
      {
        *(void *)(a1 + 1160) = v13;
      }
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, void))(a1 + 968))(a1, (unsigned __int16)(a2 / v12));
    if (result) {
      return 1;
    }
    else {
      *(_DWORD *)(a1 + 884) = -1;
    }
  }
  else
  {
    TIFFErrorExt(*(void *)(a1 + 1200), "TIFFStartStrip", "Zero strips per image", a4, a5, a6, a7, a8, v14);
    return 0;
  }
  return result;
}

uint64_t _cg_TIFFReadTileWithSize(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = a5;
  unsigned int v11 = a4;
  if (!TIFFCheckRead(a1, 1, a3, a4, a5, a6, a7, a8)
    || !TIFFCheckTile(a1, v11, v10, a6, a7, v15, v16, v17))
  {
    return -1;
  }
  uint64_t v18 = _cg_TIFFComputeTile(a1, v11, v10, a6, a7);

  return TIFFReadEncodedTile(a1, v18, a2, a3, v19, v20, v21, v22);
}

uint64_t TIFFReadEncodedTile(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int64_t v12 = *(void *)(a1 + 936);
  if (!TIFFCheckRead(a1, 1, (uint64_t)a3, a4, a5, a6, a7, a8)) {
    return -1;
  }
  if (*(_DWORD *)(a1 + 228) <= a2)
  {
    TIFFErrorExtR(a1, "TIFFReadEncodedTile", "%u: Tile out of range, max %u", v14, v15, v16, v17, v18, a2);
    return -1;
  }
  if (a4 != -1 && *(_WORD *)(a1 + 120) == 1 && v12 <= a4 && (*(_DWORD *)(a1 + 16) & 0x20800) == 0)
  {
    if (TIFFReadRawTile1(a1, a2, a3, v12, "TIFFReadEncodedTile") == v12)
    {
      if ((*(_DWORD *)(a1 + 16) & (*(unsigned __int16 *)(a1 + 126) | 0x100)) == 0) {
        TIFFReverseBits(a3, v12);
      }
      goto LABEL_14;
    }
    return -1;
  }
  if (v12 >= a4) {
    int64_t v19 = a4;
  }
  else {
    int64_t v19 = v12;
  }
  if (a4 != -1) {
    int64_t v12 = v19;
  }
  if (!TIFFFillTile(a1, a2, v13, v14, v15, v16, v17, v18))
  {
    bzero(a3, v12);
    return -1;
  }
  if (!(*(unsigned int (**)(uint64_t, unsigned __int8 *, int64_t, void))(a1 + 1040))(a1, a3, v12, (unsigned __int16)(a2 / *(_DWORD *)(a1 + 224))))return -1; {
LABEL_14:
  }
  (*(void (**)(uint64_t, unsigned __int8 *, int64_t))(a1 + 1248))(a1, a3, v12);
  return v12;
}

uint64_t _cg_TIFFReadTile(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _cg_TIFFReadTileWithSize(a1, a2, -1, a3, a4, a5, a6, a8);
}

uint64_t TIFFReadRawTile1(uint64_t a1, uint64_t a2, void *a3, size_t a4, const char *a5)
{
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x20000) != 0) {
    TIFFReadRawTile1_cold_1();
  }
  uint64_t v11 = TIFFGetStrileOffset(a1, a2);
  if ((v5 & 0x800) != 0)
  {
    if (TIFFGetStrileOffset(a1, a2) < 0 || (int64_t v27 = *(void *)(a1 + 1176), v28 = v27 - v11, v27 < v11))
    {
      int64_t v28 = 0;
    }
    else if ((a4 & 0x8000000000000000) == 0 && (v11 & 0x8000000000000000) == 0 && (uint64_t)(v11 + a4) <= v27)
    {
      goto LABEL_16;
    }
    if (v28 != a4)
    {
      TIFFErrorExtR(a1, a5, "Read error at row %u, col %u, tile %u; got %lld bytes, expected %lld",
        v22,
        v23,
        v24,
        v25,
        v26,
        *(_DWORD *)(a1 + 876));
      return -1;
    }
LABEL_16:
    _TIFFmemcpy(a3, (const void *)(*(void *)(a1 + 1168) + v11), a4);
    return a4;
  }
  if (!_TIFFSeekOK(a1, v11))
  {
    TIFFErrorExtR(a1, a5, "Seek error at row %u, col %u, tile %u", v12, v13, v14, v15, v16, *(_DWORD *)(a1 + 876));
    return -1;
  }
  if ((*(uint64_t (**)(void, void *, size_t))(a1 + 1208))(*(void *)(a1 + 1200), a3, a4) != a4)
  {
    TIFFErrorExtR(a1, a5, "Read error at row %u, col %u; got %lld bytes, expected %lld",
      v17,
      v18,
      v19,
      v20,
      v21,
      *(_DWORD *)(a1 + 876));
    return -1;
  }
  return a4;
}

uint64_t TIFFFillTile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(a1 + 18) & 2) == 0)
  {
    uint64_t v10 = TIFFGetStrileByteCount(a1, a2);
    int64_t v18 = v10;
    if (v10 <= 0)
    {
      TIFFErrorExtR(a1, "TIFFFillTile", "%llu: Invalid tile byte count, tile %u", v13, v14, v15, v16, v17, v10);
      return 0;
    }
    if ((unint64_t)v10 > 0x100000)
    {
      unint64_t v19 = _cg_TIFFTileSize(a1, v11, v12, v13, v14, v15, v16, v17);
      if (v19)
      {
        if (v19 < (v18 - 4096) / 0xAuLL)
        {
          uint64_t v20 = 10 * v19 + 4096;
          TIFFErrorExtR(a1, "TIFFFillTile", "Too large tile byte count %llu, tile %u. Limiting to %llu", v13, v14, v15, v16, v17, v18);
          int64_t v18 = v20;
        }
      }
    }
    int v21 = *(_DWORD *)(a1 + 16);
    if ((v21 & 0x800) != 0)
    {
      if ((unint64_t)v18 > *(void *)(a1 + 1176)
        || TIFFGetStrileOffset(a1, a2) > (unint64_t)(*(void *)(a1 + 1176) - v18))
      {
        *(_DWORD *)(a1 + 932) = -1;
        return 0;
      }
      int v21 = *(_DWORD *)(a1 + 16);
      if ((v21 & 0x800) != 0 && ((unsigned __int16)v21 & (*(_WORD *)(a1 + 126) | 0x100)) != 0)
      {
        if ((v21 & 0x200) != 0)
        {
          uint64_t v26 = *(char **)(a1 + 1120);
          if (v26)
          {
            _TIFFfreeExt(a1, v26);
            *(void *)(a1 + 1120) = 0;
            int v21 = *(_DWORD *)(a1 + 16);
          }
        }
        *(_DWORD *)(a1 + 16) = v21 & 0xFFFFFDFF;
        *(void *)(a1 + 1128) = v18;
        uint64_t v27 = *(void *)(a1 + 1168);
        *(void *)(a1 + 1120) = v27 + TIFFGetStrileOffset(a1, a2);
        *(void *)(a1 + 1136) = 0;
        *(void *)(a1 + 1144) = v18;
        *(_DWORD *)(a1 + 16) |= 0x800000u;
        goto LABEL_34;
      }
    }
    int64_t v22 = *(void *)(a1 + 1128);
    if (v18 > v22)
    {
      *(_DWORD *)(a1 + 932) = -1;
      if ((v21 & 0x200) == 0)
      {
        TIFFErrorExtR(a1, "TIFFFillTile", "Data buffer too small to hold tile %u", v13, v14, v15, v16, v17, a2);
        return 0;
      }
    }
    if ((v21 & 0x800000) != 0)
    {
      int64_t v22 = 0;
      *(_DWORD *)(a1 + 932) = -1;
      v21 &= ~0x800000u;
      *(_OWORD *)(a1 + 1120) = 0u;
      *(_DWORD *)(a1 + 16) = v21;
    }
    if ((v21 & 0x800) != 0)
    {
      if (v18 > v22 && !TIFFReadBufferSetup(a1, 0, v18, v13, v14, v15, v16, v17)) {
        return 0;
      }
      uint64_t v23 = TIFFReadRawTile1(a1, a2, *(void **)(a1 + 1120), v18, "TIFFFillTile");
    }
    else
    {
      uint64_t v23 = TIFFReadRawStripOrTile2(a1, a2, 0, v18, "TIFFFillTile");
    }
    if (v23 != v18) {
      return 0;
    }
    *(void *)(a1 + 1136) = 0;
    *(void *)(a1 + 1144) = v18;
    uint64_t v24 = *(unsigned __int8 **)(a1 + 1120);
    if (v24 && (*(_DWORD *)(a1 + 16) & (*(unsigned __int16 *)(a1 + 126) | 0x100)) == 0) {
      TIFFReverseBits(v24, v18);
    }
  }
LABEL_34:

  return TIFFStartTile(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t _TIFFReadTileAndAllocBuffer(uint64_t a1, unsigned __int8 **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = a5;
  unsigned int v11 = a4;
  if (!TIFFCheckRead(a1, 1, a3, a4, a5, a6, a7, a8)
    || !TIFFCheckTile(a1, v11, v10, a6, a7, v15, v16, v17))
  {
    return -1;
  }
  uint64_t v18 = _cg_TIFFComputeTile(a1, v11, v10, a6, a7);

  return _TIFFReadEncodedTileAndAllocBuffer(a1, v18, a2, a3, -1, v19, v20, v21);
}

uint64_t _TIFFReadEncodedTileAndAllocBuffer(uint64_t a1, uint64_t a2, unsigned __int8 **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = *a3;
  if (!v12)
  {
    uint64_t v15 = *(void *)(a1 + 936);
    if (!TIFFCheckRead(a1, 1, 0, a4, a5, a6, a7, a8)) {
      return -1;
    }
    if (*(_DWORD *)(a1 + 228) <= a2)
    {
      uint64_t v35 = "_TIFFReadEncodedTileAndAllocBuffer";
      char v48 = a2;
      char v36 = "%u: Tile out of range, max %u";
      goto LABEL_14;
    }
    if (!TIFFFillTile(a1, a2, v16, v17, v18, v19, v20, v21)) {
      return -1;
    }
    int v28 = *(unsigned __int16 *)(a1 + 120);
    switch(v28)
    {
      case 50002:
        if (*(_WORD *)(a1 + 170) == 1) {
          uint64_t v38 = 25000 * *(unsigned __int16 *)(a1 + 130);
        }
        else {
          uint64_t v38 = 25000;
        }
        break;
      case 50000:
        uint64_t v38 = 33000;
        break;
      case 1:
        if (*(void *)(a1 + 1128) != v15)
        {
          size_t v29 = (const char *)TIFFFileName(a1);
          TIFFErrorExtR(a1, v29, "Invalid tile byte count for tile %u. Expected %llu, got %llu", v30, v31, v32, v33, v34, a2);
          return -1;
        }
        goto LABEL_27;
      default:
        BOOL v39 = v28 == 34925;
        uint64_t v38 = 1000;
        if (v39) {
          uint64_t v38 = 7000;
        }
        break;
    }
    if (a4 >= 100000001 && *(void *)(a1 + 1128) < v15 / v38)
    {
      char v40 = (const char *)TIFFFileName(a1);
      TIFFErrorExtR(a1, v40, "Likely invalid tile byte count for tile %u. Uncompressed tile size is %llu, compressed one is %llu", v41, v42, v43, v44, v45, a2);
      return -1;
    }
LABEL_27:
    int v46 = (unsigned __int8 *)_TIFFmallocExt((void *)a1, a4, v22, v23, v24, v25, v26, v27);
    *a3 = v46;
    if (v46)
    {
      _TIFFmemset(v46, 0, a4);
      if (v15 >= a5) {
        uint64_t v47 = a5;
      }
      else {
        uint64_t v47 = v15;
      }
      if (a5 == -1) {
        uint64_t v37 = v15;
      }
      else {
        uint64_t v37 = v47;
      }
      if ((*(unsigned int (**)(uint64_t, unsigned __int8 *, uint64_t, void))(a1 + 1040))(a1, *a3, v37, (unsigned __int16)(a2 / *(_DWORD *)(a1 + 224))))
      {
        (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(a1 + 1248))(a1, *a3, v37);
        return v37;
      }
      return -1;
    }
    uint64_t v35 = (const char *)TIFFFileName(a1);
    char v36 = "No space for tile buffer";
LABEL_14:
    TIFFErrorExtR(a1, v35, v36, v17, v18, v19, v20, v21, v48);
    return -1;
  }

  return TIFFReadEncodedTile(a1, a2, v12, a5, a5, a6, a7, a8);
}

uint64_t TIFFStartTile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = *(_DWORD *)(a1 + 16);
  if ((v10 & 0x20) == 0)
  {
    if (!(*(unsigned int (**)(uint64_t))(a1 + 960))(a1)) {
      return 0;
    }
    int v10 = *(_DWORD *)(a1 + 16) | 0x20;
    *(_DWORD *)(a1 + 16) = v10;
  }
  *(_DWORD *)(a1 + 932) = a2;
  unsigned int v11 = *(_DWORD *)(a1 + 100);
  if (!v11)
  {
    uint64_t v18 = "Zero tilewidth";
    goto LABEL_11;
  }
  unsigned int v12 = *(_DWORD *)(a1 + 88);
  if (v12 >= -v11
    || (unsigned int v13 = v11 + v12 - 1, v11 > v13)
    || (unsigned int v14 = a2 % (v13 / v11),
        unsigned int v15 = *(_DWORD *)(a1 + 104),
        *(_DWORD *)(a1 + 876) = v15 * v14,
        unsigned int v16 = *(_DWORD *)(a1 + 92),
        v16 >= -v15)
    || (unsigned int v17 = v15 + v16 - 1, v15 > v17))
  {
    uint64_t v18 = "Zero tiles";
LABEL_11:
    TIFFErrorExtR(a1, "TIFFStartTile", v18, a4, a5, a6, a7, a8, v23);
    return 0;
  }
  *(_DWORD *)(a1 + 928) = a2 % (v17 / v15) * v11;
  *(_DWORD *)(a1 + 16) = v10 & 0xFFEFFFFF;
  if ((v10 & 0x20000) != 0)
  {
    *(_OWORD *)(a1 + 1152) = 0u;
  }
  else
  {
    *(void *)(a1 + 1152) = *(void *)(a1 + 1120);
    uint64_t v20 = *(void *)(a1 + 1144);
    if (v20 < 1) {
      *(void *)(a1 + 1160) = TIFFGetStrileByteCount(a1, a2);
    }
    else {
      *(void *)(a1 + 1160) = v20;
    }
  }
  uint64_t v21 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 968);
  uint64_t v22 = (unsigned __int16)(a2 / *(_DWORD *)(a1 + 224));

  return v21(a1, v22);
}

uint64_t _TIFFSwab16BitData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    _TIFFSwab16BitData_cold_1();
  }
  if (a3 >= 0) {
    uint64_t v4 = a3;
  }
  else {
    uint64_t v4 = a3 + 1;
  }
  return TIFFSwabArrayOfShort(a2, v4 >> 1);
}

uint64_t _TIFFSwab24BitData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 != 3 * (a3 / 3)) {
    _TIFFSwab24BitData_cold_1();
  }
  return TIFFSwabArrayOfTriples(a2, a3 / 3);
}

__int32 *_TIFFSwab32BitData(uint8x8_t a1, uint64_t a2, __int32 *a3, uint64_t a4)
{
  if ((a4 & 3) != 0) {
    _TIFFSwab32BitData_cold_1();
  }
  return TIFFSwabArrayOfLong(a3, a4 / 4, a1);
}

int8x8_t *_TIFFSwab64BitData(uint64_t a1, int8x8_t *a2, uint64_t a3)
{
  if ((a3 & 7) != 0) {
    _TIFFSwab64BitData_cold_1();
  }
  return TIFFSwabArrayOfLong8(a2, a3 / 8);
}

uint64_t TIFFReadAndRealloc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  uint64_t v12 = 0;
  uint64_t v13 = a3 + a2;
  unsigned int v14 = (uint64_t *)(a1 + 1120);
  uint64_t v15 = 0x100000;
  do
  {
    if (a2 <= v12) {
      return 1;
    }
    BOOL v17 = v15 < 1048576000 && a2 - v12 >= v15;
    uint64_t v18 = *(void *)(a1 + 1128);
    BOOL v19 = v13 > v18;
    if (v17 && v19) {
      uint64_t v20 = 10 * v15;
    }
    else {
      uint64_t v20 = v15;
    }
    if (v17 && v19) {
      uint64_t v21 = v15;
    }
    else {
      uint64_t v21 = a2 - v12;
    }
    uint64_t v22 = v12 + a3 + v21;
    if (v22 <= v18)
    {
      uint64_t result = *v14;
      if (!*v14) {
        return result;
      }
    }
    else
    {
      if ((*(unsigned char *)(a1 + 17) & 2) == 0) {
        TIFFReadAndRealloc_cold_1();
      }
      unint64_t v23 = (v22 + 1023) & 0xFFFFFFFFFFFFFC00;
      *(void *)(a1 + 1128) = v23;
      if (!v23)
      {
        uint64_t v31 = "Invalid buffer size";
        goto LABEL_28;
      }
      uint64_t result = (uint64_t)_TIFFreallocExt((void *)a1, *(char **)(a1 + 1120), v23, a4, a5, (uint64_t)a6, a7, a8);
      if (!result)
      {
        TIFFErrorExtR(a1, a6, "No space for data buffer at scanline %u", v25, v26, v27, v28, v29, *(_DWORD *)(a1 + 876));
        _TIFFfreeExt(a1, *(char **)(a1 + 1120));
        uint64_t result = 0;
        *unsigned int v14 = 0;
        v14[1] = 0;
        return result;
      }
      *unsigned int v14 = result;
    }
    uint64_t v30 = (*(uint64_t (**)(void, uint64_t, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), result + a3 + v12, v21);
    v12 += v30;
    uint64_t v15 = v20;
  }
  while (v30 == v21);
  bzero((void *)(*(void *)(a1 + 1120) + a3 + v12), *(void *)(a1 + 1128) - a3 - v12);
  if (v8)
  {
    TIFFErrorExtR(a1, a6, "Read error at scanline %u; got %lld bytes, expected %lld",
      a4,
      a5,
      (uint64_t)a6,
      a7,
      a8,
      *(_DWORD *)(a1 + 876));
    return 0;
  }
  int v32 = *(_DWORD *)(a1 + 876);
  uint64_t v31 = "Read error at row %u, col %u, tile %u; got %lld bytes, expected %lld";
LABEL_28:
  TIFFErrorExtR(a1, a6, v31, a4, a5, (uint64_t)a6, a7, a8, v32);
  return 0;
}

void IIO_Reader_WebP::createReadPlugin()
{
}

{
  operator new();
}

void sub_18876DA48(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4011B95214);
  _Unwind_Resume(a1);
}

void sub_18876DAE8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4011B95214);
  _Unwind_Resume(a1);
}

BOOL IIO_Reader_WebP::testHeader(uint64_t a1, unsigned char *a2)
{
  return *a2 == 82
      && a2[1] == 73
      && a2[2] == 70
      && a2[3] == 70
      && a2[8] == 87
      && a2[9] == 69
      && a2[10] == 66
      && a2[11] == 80;
}

uint64_t IIO_Reader_WebP::validateVP8_VP8L(IIO_Reader_WebP *this, IIOScanner *a2, unsigned int a3, int a4)
{
  uint64_t v4 = *((void *)a2 + 3);
  if (v4 + (unint64_t)a3 - 8 > *((void *)a2 + 2))
  {
    _cg_jpeg_mem_term("validateVP8_VP8L", 80, "*** ERROR: bad 'VP8/VP8L' chunkSize\n");
    return 1;
  }
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  WebPGetFeaturesInternal(*((void *)a2 + 1) + v4 - 8, a3, (uint64_t)v13, 521);
  if (*((unsigned char *)this + 116))
  {
    ++*((_DWORD *)this + (a4 != 1448097824) + 22);
    if (a4 == 1448097868)
    {
      char v8 = *((unsigned char *)this + 117);
      if (v8)
      {
        _cg_jpeg_mem_term("validateVP8_VP8L", 90, "ERROR: VP8L and ALPH sub-chunks in ANMF are not allowed\n");
        char v8 = 1;
      }
    }
    else
    {
      char v8 = 0;
    }
    if (*(void *)&v13[0] != *(void *)((char *)this + 108))
    {
      _cg_jpeg_mem_term("validateVP8_VP8L", 95, "ERROR: frame size VP8/VP8L sub-chunk does not match ANMF header frame size\n");
      int v12 = *((unsigned __int8 *)this + 119);
      unsigned int v11 = (char *)this + 119;
      if (!v12)
      {
LABEL_19:
        uint64_t result = 0;
        *unsigned int v11 = 1;
        return result;
      }
LABEL_18:
      _cg_jpeg_mem_term("validateVP8_VP8L", 101, "ERROR: more than one VP8/VP8L chunks in ANMF are not allowed\n");
      goto LABEL_19;
    }
    if (*((unsigned char *)this + 119))
    {
      unsigned int v11 = (char *)this + 119;
      goto LABEL_18;
    }
    *((unsigned char *)this + 119) = 1;
    if ((v8 & 1) == 0) {
      goto LABEL_24;
    }
    return 0;
  }
  if (*((_DWORD *)this + 13) || *((_DWORD *)this + 14))
  {
    *(void *)&double v7 = _cg_jpeg_mem_term("validateVP8_VP8L", 111, "*** ERROR: multiple VP8/VP8L chunks not allowed\n").n128_u64[0];
    int v9 = 0;
  }
  else
  {
    int v9 = 1;
  }
  if (*((_DWORD *)this + 17) || *((_DWORD *)this + 18))
  {
    _cg_jpeg_mem_term("validateVP8_VP8L", 117, "*** ERROR: VP8/VP8L and ANIM/ANMF chunks are not allowed\n", v7);
    return 0;
  }
  if (!v9) {
    return 0;
  }
LABEL_24:
  ++*((_DWORD *)this + 26);
  return 1;
}

BOOL IIO_Reader_WebP::validateALPH(IIO_Reader_WebP *this, IIOScanner *a2)
{
  if (*((unsigned char *)this + 116))
  {
    ++*((_DWORD *)this + 24);
    BOOL v3 = *((unsigned char *)this + 118) == 0;
    if (*((unsigned char *)this + 118)) {
      _cg_jpeg_mem_term("validateALPH", 153, "*** ERROR: more than one ALPH sub-chunks in an ANMF chunk\n");
    }
    *((unsigned char *)this + 118) = 1;
    if (*((unsigned char *)this + 119))
    {
      _cg_jpeg_mem_term("validateALPH", 160, "*** ERROR: ALPHA sub-chunk detected after VP8 sub-chunk in an ANMF chunk\n");
      return 0;
    }
  }
  else
  {
    if (*((_DWORD *)this + 17) || *((_DWORD *)this + 18))
    {
      _cg_jpeg_mem_term("validateALPH", 168, "*** ERROR: ALPHA chunk and ANIM/ANMF chunk are both detected\n");
      BOOL v3 = 0;
    }
    else
    {
      BOOL v3 = 1;
    }
    if (!*((_DWORD *)this + 15))
    {
      _cg_jpeg_mem_term("validateALPH", 173, "*** ERROR: ALPHA chunk detected before VP8X chunk\n");
      BOOL v3 = 0;
    }
    if (*((_DWORD *)this + 13))
    {
      _cg_jpeg_mem_term("validateALPH", 178, "*** ERROR: ALPHA chunk detected after VP8 chunk\n");
      BOOL v3 = 0;
    }
    if (*((_DWORD *)this + 16))
    {
      _cg_jpeg_mem_term("validateALPH", 183, "*** ERROR: Multiple ALPHA chunks detected\n");
      return 0;
    }
  }
  return v3;
}

BOOL IIO_Reader_WebP::validateANMF(IIO_Reader_WebP *this, IIOScanner *a2, unsigned int a3)
{
  BOOL v6 = *((unsigned char *)this + 116) == 0;
  if (*((unsigned char *)this + 116)) {
    _cg_jpeg_mem_term("validateANMF", 211, "ERROR: nested ANMF chunks are not allowed\n");
  }
  if (!*((_DWORD *)this + 17))
  {
    _cg_jpeg_mem_term("validateANMF", 216, "*** ERROR: ANMF without ANIM are not allowed\n");
    BOOL v6 = 0;
  }
  if (a3 > 0x10)
  {
    IIOScanner::getVal24(a2);
    IIOScanner::getVal24(a2);
    *((_DWORD *)this + 27) = IIOScanner::getVal24(a2) + 1;
    *((_DWORD *)this + 28) = IIOScanner::getVal24(a2) + 1;
    IIOScanner::getVal24(a2);
    *((void *)this + 11) = 0;
    *((_DWORD *)this + 24) = 0;
    *((_WORD *)this + 59) = 0;
  }
  else
  {
    _cg_jpeg_mem_term("validateANMF", 232, "*** ERROR: ANMF chunk size too small (%d)\n", a3);
    BOOL v6 = 0;
  }
  *((unsigned char *)this + 116) = 1;
  return v6;
}

BOOL IIO_Reader_WebP::validateICCP(IIO_Reader_WebP *this, IIOScanner *a2)
{
  int v3 = *((_DWORD *)this + 15);
  BOOL v4 = v3 != 0;
  if (!v3) {
    _cg_jpeg_mem_term("validateICCP", 260, "*** ERROR: ICCP chunk detected before VP8X chunk.");
  }
  if (*((_DWORD *)this + 13) || *((_DWORD *)this + 14) || *((_DWORD *)this + 17))
  {
    _cg_jpeg_mem_term("validateICCP", 267, "*** ERROR: ICCP chunk detected after image data.");
    return 0;
  }
  return v4;
}

BOOL IIO_Reader_WebP::validateWebP(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v64 = 0;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v60, *(unsigned __int8 **)a3, *(void *)(a3 + 8), 1);
  *(_OWORD *)(a1 + 52) = 0u;
  int v5 = (_DWORD *)(a1 + 52);
  *(_DWORD *)(a1 + 84) = 0;
  *(_OWORD *)(a1 + 68) = 0u;
  *(void *)(a1 + 100) = 0;
  *(_WORD *)(a1 + 116) = 0;
  BOOL v6 = IIOScanner::getOSType((IIOScanner *)&v60) == 1380533830;
  unsigned int Val32 = IIOScanner::getVal32((IIOScanner *)&v60);
  unint64_t v8 = Val32 + 8;
  if (Val32 >= 0xFFFFFFF8)
  {
    unint64_t v11 = _cg_jpeg_mem_term("validateWebP", 316, "*** ERROR: bad webp header\n").n128_u64[0];
    goto LABEL_85;
  }
  if ((unint64_t)v61 >= v8)
  {
    if ((unint64_t)v61 > v8)
    {
      _cg_jpeg_mem_term("validateWebP", 322, "*** webP contains additional data (%d bytes) - original: '%d'   new: '%d'\n", v61 - v8, v61, Val32 + 8);
      if ((unint64_t)v61 > v8) {
        *(void *)&long long v61 = v8;
      }
    }
  }
  else
  {
    LOBYTE(v6) = 0;
  }
  if (IIOScanner::getOSType((IIOScanner *)&v60) != 1464156752 || !v6)
  {
    BOOL v6 = 0;
    unint64_t v11 = _cg_jpeg_mem_term("validateWebP", 329, "*** ERROR: bad webp header\n").n128_u64[0];
    goto LABEL_85;
  }
  OSint Type = IIOScanner::getOSType((IIOScanner *)&v60);
  BOOL v12 = 1;
  while (1)
  {
    if (!OSType)
    {
      BOOL v6 = v12;
      goto LABEL_85;
    }
    unsigned int v13 = IIOScanner::getVal32((IIOScanner *)&v60);
    uint64_t v15 = *((void *)&v61 + 1) - 8;
    unsigned int v16 = v13 + 8;
    if (v13 >= 0xFFFFFFF8 || *(void *)(a3 + 8) <= (unint64_t)v16) {
      break;
    }
    uint64_t v17 = (v16 & 1) + v16;
    if (v15 + v17 > (unint64_t)v61)
    {
      unsigned int v39 = OSType >> 24;
      if (OSType < 0) {
        int v40 = __maskrune(OSType >> 24, 0x40000uLL);
      }
      else {
        int v40 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v39 + 60) & 0x40000;
      }
      if (v40) {
        uint64_t v50 = v39;
      }
      else {
        uint64_t v50 = 46;
      }
      unsigned int v51 = OSType << 8 >> 24;
      if (OSType << 8 < 0) {
        int v52 = __maskrune(OSType << 8 >> 24, 0x40000uLL);
      }
      else {
        int v52 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v51 + 60) & 0x40000;
      }
      if (v52) {
        uint64_t v53 = v51;
      }
      else {
        uint64_t v53 = 46;
      }
      unsigned int v54 = (__int16)OSType >> 8;
      if (OSType << 16 < 0) {
        int v55 = __maskrune((__int16)OSType >> 8, 0x40000uLL);
      }
      else {
        int v55 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v54 + 60) & 0x40000;
      }
      if ((OSType << 24) <= 0x7F000000) {
        int v56 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)OSType + 60) & 0x40000;
      }
      else {
        int v56 = __maskrune((char)OSType, 0x40000uLL);
      }
      if (v55) {
        uint64_t v57 = v54;
      }
      else {
        uint64_t v57 = 46;
      }
      if (v56) {
        uint64_t v58 = (char)OSType;
      }
      else {
        uint64_t v58 = 46;
      }
      unint64_t v11 = _cg_jpeg_mem_term("validateWebP", 344, "*** ERROR: bad chunk size [%d,%d] for '%c%c%c%c' (%d bytes)\n", v15, v17, v50, v53, v57, v58, v61).n128_u64[0];
      goto LABEL_138;
    }
    if (OSType <= 1229144911)
    {
      if (OSType > 1095650629)
      {
        if (OSType == 1095650630)
        {
          BOOL v23 = IIO_Reader_WebP::validateANMF((IIO_Reader_WebP *)a1, (IIOScanner *)&v60, (v16 & 1) + v16);
          *(_DWORD *)(a1 + 100) = v17 - 24;
          ++*(_DWORD *)(a1 + 72);
          LODWORD(v17) = 24;
          BOOL v12 = v23;
          goto LABEL_53;
        }
        if (OSType != 1163413830) {
          goto LABEL_56;
        }
        ++*(_DWORD *)(a1 + 80);
        goto LABEL_34;
      }
      if (OSType != 1095520328)
      {
        if (OSType == 1095649613)
        {
          if (v17 != 14) {
            unint64_t v11 = _cg_jpeg_mem_term("validateANIM", 197, "*** ERROR: corrupt ANIM chunk (%d bytes, expected: %d)\n", (v16 & 1) + v16, 14).n128_u64[0];
          }
          BOOL v12 = v17 == 14;
          ++*(_DWORD *)(a1 + 68);
          goto LABEL_44;
        }
LABEL_56:
        unsigned int v25 = OSType >> 24;
        if (OSType < 0) {
          int v26 = __maskrune(OSType >> 24, 0x40000uLL);
        }
        else {
          int v26 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v25 + 60) & 0x40000;
        }
        if (v26) {
          uint64_t v27 = v25;
        }
        else {
          uint64_t v27 = 46;
        }
        unsigned int v28 = OSType << 8 >> 24;
        uint64_t v59 = v27;
        if (OSType << 8 < 0) {
          int v29 = __maskrune(OSType << 8 >> 24, 0x40000uLL);
        }
        else {
          int v29 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v28 + 60) & 0x40000;
        }
        if (v29) {
          uint64_t v30 = v28;
        }
        else {
          uint64_t v30 = 46;
        }
        unsigned int v31 = (__int16)OSType >> 8;
        if (OSType << 16 < 0) {
          int v32 = __maskrune((__int16)OSType >> 8, 0x40000uLL);
        }
        else {
          int v32 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v31 + 60) & 0x40000;
        }
        if ((OSType << 24) <= 0x7F000000) {
          int v33 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)OSType + 60) & 0x40000;
        }
        else {
          int v33 = __maskrune((char)OSType, 0x40000uLL);
        }
        if (v32) {
          uint64_t v34 = v31;
        }
        else {
          uint64_t v34 = 46;
        }
        if (v33) {
          uint64_t v35 = (char)OSType;
        }
        else {
          uint64_t v35 = 46;
        }
        unint64_t v11 = _cg_jpeg_mem_term("validateWebP", 389, "*** ERROR: unknown chunk '%c%c%c%c' at offset 0x%08x  size: %d\n", v59, v30, v34, v35, v15, v17).n128_u64[0];
        if (!v17) {
          BOOL v12 = 0;
        }
        int v5 = (_DWORD *)(a1 + 52);
        goto LABEL_44;
      }
      char v18 = IIO_Reader_WebP::validateALPH((IIO_Reader_WebP *)a1, v14);
      ++*(_DWORD *)(a1 + 64);
      goto LABEL_43;
    }
    if (OSType <= 1448097867)
    {
      if (OSType == 1229144912)
      {
        char v18 = IIO_Reader_WebP::validateICCP((IIO_Reader_WebP *)a1, v14);
        ++*(_DWORD *)(a1 + 76);
      }
      else
      {
        if (OSType != 1448097824) {
          goto LABEL_56;
        }
        char v18 = IIO_Reader_WebP::validateVP8_VP8L((IIO_Reader_WebP *)a1, (IIOScanner *)&v60, (v16 & 1) + v16, 1448097824);
        ++*v5;
      }
      goto LABEL_43;
    }
    if (OSType == 1448097868)
    {
      char v18 = IIO_Reader_WebP::validateVP8_VP8L((IIO_Reader_WebP *)a1, (IIOScanner *)&v60, (v16 & 1) + v16, 1448097868);
      ++*(_DWORD *)(a1 + 56);
LABEL_43:
      BOOL v12 = v18;
      goto LABEL_44;
    }
    if (OSType != 1448097880)
    {
      if (OSType != 1481461792) {
        goto LABEL_56;
      }
      ++*(_DWORD *)(a1 + 84);
LABEL_34:
      BOOL v12 = 1;
      goto LABEL_44;
    }
    if (*v5 || *(_DWORD *)(a1 + 56) || (int v19 = *(_DWORD *)(a1 + 60)) != 0)
    {
      unint64_t v11 = _cg_jpeg_mem_term("validateVP8X", 136, "*** ERROR: 'VP8X' - not allowed - VP8/VP8L/VP8X already present\n").n128_u64[0];
      BOOL v12 = 0;
      int v19 = *(_DWORD *)(a1 + 60);
    }
    else
    {
      BOOL v12 = 1;
    }
    *(_DWORD *)(a1 + 60) = v19 + 1;
LABEL_44:
    if (*(unsigned char *)(a1 + 116))
    {
      unsigned int v20 = *(_DWORD *)(a1 + 100);
      BOOL v21 = v20 >= v17;
      int v22 = v20 - v17;
      if (v22)
      {
        if (v22 != 0 && v21) {
          *(_DWORD *)(a1 + 100) = v22;
        }
      }
      else
      {
        if (!*(unsigned char *)(a1 + 119))
        {
          unint64_t v11 = _cg_jpeg_mem_term("validateWebP", 401, "*** ERROR: no VP8/VP8L chunk detected in ANMF chunk\n", *(double *)&v11).n128_u64[0];
          BOOL v12 = 0;
        }
        *(unsigned char *)(a1 + 116) = 0;
      }
    }
LABEL_53:
    BOOL v6 = v12;
    if (!v12) {
      goto LABEL_85;
    }
    unint64_t v24 = v15 + v17;
    if (v24 >= (unint64_t)v61) {
      goto LABEL_85;
    }
    IIOScanner::seek((IIOScanner *)&v60, v24);
    OSint Type = IIOScanner::getOSType((IIOScanner *)&v60);
  }
  unsigned int v37 = OSType >> 24;
  if (OSType < 0) {
    int v38 = __maskrune(OSType >> 24, 0x40000uLL);
  }
  else {
    int v38 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v37 + 60) & 0x40000;
  }
  if (v38) {
    uint64_t v41 = v37;
  }
  else {
    uint64_t v41 = 46;
  }
  unsigned int v42 = OSType << 8 >> 24;
  if (OSType << 8 < 0) {
    int v43 = __maskrune(OSType << 8 >> 24, 0x40000uLL);
  }
  else {
    int v43 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v42 + 60) & 0x40000;
  }
  if (v43) {
    uint64_t v44 = v42;
  }
  else {
    uint64_t v44 = 46;
  }
  unsigned int v45 = (__int16)OSType >> 8;
  if (OSType << 16 < 0) {
    int v46 = __maskrune((__int16)OSType >> 8, 0x40000uLL);
  }
  else {
    int v46 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v45 + 60) & 0x40000;
  }
  if ((OSType << 24) <= 0x7F000000) {
    int v47 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)OSType + 60) & 0x40000;
  }
  else {
    int v47 = __maskrune((char)OSType, 0x40000uLL);
  }
  if (v46) {
    uint64_t v48 = v45;
  }
  else {
    uint64_t v48 = 46;
  }
  if (v47) {
    uint64_t v49 = (char)OSType;
  }
  else {
    uint64_t v49 = 46;
  }
  unint64_t v11 = _cg_jpeg_mem_term("validateWebP", 339, "*** ERROR: bad chunk size [%d,%d] for '%c%c%c%c' (%d bytes)\n", v15, v16, v41, v44, v48, v49, v61).n128_u64[0];
LABEL_138:
  BOOL v6 = 0;
LABEL_85:
  if (!*(_DWORD *)(a1 + 104))
  {
    _cg_jpeg_mem_term("validateWebP", 427, "*** ERROR: no VP8/VP8L chunk detected\n", *(double *)&v11);
    BOOL v6 = 0;
  }
  IIOScanner::~IIOScanner((IIOScanner *)&v60);
  return v6;
}

void sub_18876E820(void *a1)
{
  __cxa_begin_catch(a1);
  *(_DWORD *)(v1 + 104) = 0;
  __cxa_end_catch();
  JUMPOUT(0x18876E548);
}

void sub_18876E878(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_WebP::getImageCount(IIO_Reader_WebP *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  unsigned int v20 = 0;
  int v19 = 0;
  memset(v18, 0, sizeof(v18));
  if (a5) {
    *a5 = 0;
  }
  os_unfair_lock_lock((os_unfair_lock_t)&IIO_Reader_WebP::getImageCount(IIOImageReadSession *,IIODictionary *,CGImageSourceStatus *,unsigned int *)::mutex);
  WebPAnimDecoderOptionsInitInternal(v18, 263);
  unint64_t v8 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v20, 0);
  if (v8)
  {
    BytePtr = (const UInt8 *)v8;
    CFDataRef v10 = 0;
  }
  else
  {
    CFDataRef v11 = IIOImageReadSession::copyData((IIOImageRead **)a2);
    if (!v11) {
      return 0;
    }
    CFDataRef v10 = v11;
    BytePtr = CFDataGetBytePtr(v11);
  }
  v17[0] = BytePtr;
  v17[1] = IIOImageReadSession::getSize(a2);
  BOOL v12 = WebPDemuxInternal((uint64_t)v17, 0, 0, 263);
  if (v12)
  {
    uint64_t v14 = (unsigned int *)v12;
    BOOL v15 = IIO_Reader_WebP::validateWebP((uint64_t)this, v13, (uint64_t)v17);
    if (a5 && v15) {
      *a5 = WebPDemuxGetI(v14, 5);
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&IIO_Reader_WebP::getImageCount(IIOImageReadSession *,IIODictionary *,CGImageSourceStatus *,unsigned int *)::mutex);
    WebPDemuxDelete(v14);
    if (v10) {
      goto LABEL_12;
    }
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&IIO_Reader_WebP::getImageCount(IIOImageReadSession *,IIODictionary *,CGImageSourceStatus *,unsigned int *)::mutex);
    if (v10)
    {
LABEL_12:
      CFRelease(v10);
      return 0;
    }
  }
  if (a2 && BytePtr) {
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v20);
  }
  return 0;
}

uint64_t IIO_Reader_WebP::updateSourceProperties(IIO_Reader_WebP *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  unsigned int v45 = 0;
  int v44 = 0;
  memset(v43, 0, sizeof(v43));
  uint64_t v41 = 0;
  uint64_t Size = 0;
  WebPAnimDecoderOptionsInitInternal(v43, 263);
  unint64_t v8 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v45, 0);
  if (v8)
  {
    BytePtr = (const UInt8 *)v8;
    unsigned int v20 = a3;
    CFDataRef v10 = 0;
  }
  else
  {
    CFDataRef v11 = IIOImageReadSession::copyData((IIOImageRead **)a2);
    if (!v11) {
      return 0;
    }
    CFDataRef v10 = v11;
    unsigned int v20 = a3;
    BytePtr = CFDataGetBytePtr(v11);
  }
  uint64_t v41 = BytePtr;
  uint64_t Size = IIOImageReadSession::getSize(a2);
  BOOL v12 = (unsigned int *)WebPDemuxInternal((uint64_t)&v41, 0, 0, 263);
  unsigned int v13 = WebPDemuxGetI(v12, 5);
  int v14 = WebPDemuxGetI(v12, 1);
  int v15 = WebPDemuxGetI(v12, 2);
  unsigned int v21 = WebPDemuxGetI(v12, 3);
  uint64_t v38 = 0;
  unsigned int v39 = 0;
  uint64_t v40 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v38);
  IIONumber::IIONumber((IIONumber *)v37, v14);
  IIODictionary::setObjectForKey((uint64_t)&v38, (uint64_t)v37, @"CanvasPixelWidth");
  IIONumber::~IIONumber((IIONumber *)v37);
  IIONumber::IIONumber((IIONumber *)v36, v15);
  IIODictionary::setObjectForKey((uint64_t)&v38, (uint64_t)v36, @"CanvasPixelHeight");
  IIONumber::~IIONumber((IIONumber *)v36);
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v31 = 0u;
  CFMutableArrayRef v28 = 0;
  CFTypeRef value = 0;
  uint64_t v30 = 0;
  IIOArray::IIOArray((IIOArray *)&v28);
  if (v13)
  {
    for (unsigned int i = 1; i <= v13; ++i)
    {
      WebPDemuxGetFrame((uint64_t)v12, i, (uint64_t)&v31);
      uint64_t v25 = 0;
      int v26 = 0;
      uint64_t v27 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v25);
      int v17 = DWORD2(v32);
      if (SDWORD2(v32) >= 11) {
        int v18 = DWORD2(v32);
      }
      else {
        int v18 = 100;
      }
      IIONumber::IIONumber((IIONumber *)v24, (double)v18 / 1000.0);
      IIODictionary::setObjectForKey((uint64_t)&v25, (uint64_t)v24, @"DelayTime");
      IIONumber::~IIONumber((IIONumber *)v24);
      IIONumber::IIONumber((IIONumber *)v23, (double)v17 / 1000.0);
      IIODictionary::setObjectForKey((uint64_t)&v25, (uint64_t)v23, @"UnclampedDelayTime");
      IIONumber::~IIONumber((IIONumber *)v23);
      IIOArray::addObject(&v28, v26);
      IIODictionary::~IIODictionary((IIODictionary *)&v25);
    }
  }
  IIODictionary::setObjectForKey((IIODictionary *)&v38, value, @"FrameInfo");
  IIONumber::IIONumber((IIONumber *)v22, v21);
  IIODictionary::setObjectForKey((uint64_t)&v38, (uint64_t)v22, @"LoopCount");
  IIONumber::~IIONumber((IIONumber *)v22);
  IIODictionary::setObjectForKey(v20, v39, @"{WebP}");
  if (v12) {
    WebPDemuxDelete(v12);
  }
  if (v10)
  {
    CFRelease(v10);
  }
  else if (a2 && BytePtr)
  {
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v45);
  }
  IIOArray::~IIOArray((IIOArray *)&v28);
  IIODictionary::~IIODictionary((IIODictionary *)&v38);
  return 0;
}

void sub_18876ECDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIOArray::~IIOArray((IIOArray *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)(v4 - 200));
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_WebP::hasCustomImageCountProc(IIO_Reader_WebP *this)
{
  return 1;
}

uint64_t IIO_Reader_WebP::hasCustomSourcePropertiesProc(IIO_Reader_WebP *this)
{
  return 1;
}

void IIOImageDestination::IIOImageDestination(IIOImageDestination *this, CGDataConsumer *a2, IIO_Writer *a3, const __CFString *a4, uint64_t a5, IIODictionary *a6)
{
  *(void *)this = &unk_1ED4E4C20;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  IIOImageDestination::setup(this, 2);
  uint64_t v11 = CGImageWriteSessionCreateWithConsumer((uint64_t)a2);
  *((void *)this + 2) = v11;
  *((void *)this + 3) = CGImageSourceGetSource(v11);
  *((void *)this + 8) = a3;
  *((void *)this + 9) = IIO_Writer::utType(a3);
  *((void *)this + 5) = a5;
  IIOImageDestination::setProperties(this, a6);
}

void sub_18876EE24(_Unwind_Exception *exception_object)
{
  uint64_t v4 = (void *)v1[16];
  if (v4)
  {
    v1[17] = v4;
    operator delete(v4);
  }
  int v5 = *v2;
  if (*v2)
  {
    v1[14] = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IIOImageDestination::resizeImageMaxPixelSize(IIOImageDestination *this)
{
  return *((void *)this + 23);
}

uint64_t IIOImageDestination::getDepthArray(IIOImageDestination *this)
{
  return *((void *)this + 19);
}

uint64_t IIOImageDestination::utType(IIOImageDestination *this)
{
  return *((void *)this + 9);
}

uint64_t IIOImageDestination::createPixelDataProviderForExtendedRange(uint64_t a1, CGImage *a2, uint64_t a3, uint64_t a4, int a5, IIODictionary *a6)
{
  double Current = CFAbsoluteTimeGetCurrent();
  IIO_LoadHEIFSymbols();
  if ((gIIODebugFlags & 0x300000) != 0) {
    ImageIOLog("  %s - input is extended range\n", "createPixelDataProviderForExtendedRange");
  }
  if (CFEqual(*(CFStringRef *)(a1 + 72), @"com.apple.atx")
    || !CGImageIsInside_sRGB(a2))
  {
    CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a6, @"kCGImageDestinationEncodeRequest");
    CFStringRef v13 = ObjectForKey;
    if (!ObjectForKey
      || (CFStringCompare(ObjectForKey, @"kCGImageDestinationEncodeToISOHDR", 0),
          CFStringCompare(v13, @"kCGImageDestinationEncodeToISOGainmap", 0),
          (CFStringRef ObjectForKeyGroup = (const __CFString *)IIODictionary::getObjectForKeyGroup(a6, @"kCGTargetColorSpace", @"kCGImageDestinationEncodeRequestOptions")) == 0)|| !CGColorSpaceCreateWithName(ObjectForKeyGroup))
    {
      CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DB90]);
    }
    operator new();
  }
  if ((gIIODebugFlags & 0x8000300000) != 0) {
    ImageIOLog("COL extended range image is inside sRGB -- converting to 8-bit\n");
  }
  if ((gIIODebugFlags & 0x300000) != 0) {
    ImageIOLog("  CGImageCreateByConvertingExtendedSRGBToColorspace\n");
  }
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(a2);
  CopyWithStandardRange = CGColorSpaceCreateCopyWithStandardRange(ColorSpace);
  uint64_t v17 = (CGImage *)CGImageCreateByConvertingExtendedSRGBToColorspace(a2, CopyWithStandardRange, 0);
  uint64_t v18 = 0;
  if ((a5 & 0x1A000) == 0 && v17)
  {
    size_t BitsPerComponent = CGImageGetBitsPerComponent(v17);
    CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(v17);
    CGBitmapInfo BitmapInfo = CGImageGetBitmapInfo(v17);
    int v22 = BitmapInfo | 5;
    if (AlphaInfo) {
      int v22 = BitmapInfo;
    }
    *(_DWORD *)(a3 + 16) = v22;
    *(void *)(a3 + 8) = CopyWithStandardRange;
    if (BitsPerComponent == 32)
    {
      if ((gIIODebugFlags & 0x8000300000) != 0)
      {
        ImageIOLog("COL extended-sRGB 32-bit --> P3 16-bit\n");
        goto LABEL_25;
      }
    }
    else
    {
      if (BitsPerComponent != 16)
      {
        if ((gIIODebugFlags & 0x8000300000) != 0) {
          ImageIOLog("COL extended-sRGB-%d --> P3 8-bit\n", BitsPerComponent);
        }
        *(void *)a3 = 0x2000000008;
        goto LABEL_30;
      }
      if ((gIIODebugFlags & 0x8000300000) != 0)
      {
        ImageIOLog("COL extended-sRGB-16 --> P3 16-bit\n");
LABEL_25:
        int v22 = *(_DWORD *)(a3 + 16);
      }
    }
    *(void *)a3 = 0x4000000010;
    *(_DWORD *)(a3 + 16) = v22 & 0xFFFF80FF | 0x1000;
LABEL_30:
    uint64_t v18 = CGImagePixelDataProviderCreate((uint64_t)v17, a3);
    CGImageRelease(v17);
  }
  CGColorSpaceRelease(CopyWithStandardRange);
  if ((gIIODebugFlags & 0x20000000000) != 0)
  {
    CFAbsoluteTime v23 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("    IIOImageDestination::createPixelDataProviderForExtendedRange - %g ms\n", (v23 - Current) * 1000.0);
  }
  return v18;
}

void sub_18876F7E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  IIONumber::~IIONumber((IIONumber *)&a29);
  IIODictionary::~IIODictionary((IIODictionary *)(v29 - 152));
  _Unwind_Resume(a1);
}

CGImage *IIOImageDestination::createCGImageConforming(uint64_t a1, CGImageRef image, unint64_t a3, CGColor *a4, uint64_t a5)
{
  uint64_t v164 = *MEMORY[0x1E4F143B8];
  size_t Width = CGImageGetWidth(image);
  unint64_t Height = CGImageGetHeight(image);
  size_t BitsPerComponent = CGImageGetBitsPerComponent(image);
  size_t BitsPerPixel = CGImageGetBitsPerPixel(image);
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
  CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
  unsigned int Type = CGColorSpaceGetType();
  uint64_t v11 = CGImageGetDecode(image);
  int AlphaInfo = _ImageGetAlphaInfo(image);
  uint64_t EndianInfo = _ImageGetEndianInfo(image);
  int IsFloat = _ImageIsFloat(image);
  memset(&v134, 0, sizeof(v134));
  double Current = CFAbsoluteTimeGetCurrent();
  CFStringRef v13 = *(const __CFString **)(a1 + 72);
  if (v13) {
    BOOL v14 = CFEqual(v13, @"public.jpeg");
  }
  else {
    BOOL v14 = 0;
  }
  CopyWithCGColorSpaceRef ColorSpace = 0;
  if ((a5 & 0x7F000000) == 0 || (a5 & 0x1FF00) == 0 || !image || (a5 & 0x7F) == 0) {
    goto LABEL_333;
  }
  if ((gIIODebugFlags & 0x10000000000) != 0)
  {
    ImageIOLog("CGImageDestination - CGImageCreateConforming\n");
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      ImageIOLog("--------------------------------------------\n");
      if ((gIIODebugFlags & 0x10000000000) != 0) {
        ImageIOLog("           writerMode: %s [0x%X]\n", IIO_WriterModeString(CGImagePluginWriteModes)::output, a5);
      }
    }
  }
  unsigned int v16 = Type;
  if (Type == 7)
  {
    CGColorSpaceRef ColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
    unsigned int v16 = CGColorSpaceGetType();
    CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
  }
  unsigned int v17 = IIOImageDestination::adjustWriteModesForWriter(a1, a5, BitsPerComponent, Model, AlphaInfo, *(_DWORD *)(a1 + 40), ColorSpace, 0);
  unsigned int v18 = v17;
  if ((gIIODebugFlags & 0x10000000000) != 0) {
    ImageIOLog("       new writerMode: %s [0x%X]\n", IIO_WriterModeString(CGImagePluginWriteModes)::output, v17);
  }
  if ((a5 & 0x10) != 0 && Type == 7 && Model == kCGColorSpaceModelRGB
    || ((v128 = 0, (a5 & 1) == 0) ? (BOOL v19 = Model == kCGColorSpaceModelRGB) : (BOOL v19 = 0),
        !v19 ? (char v20 = 0) : (char v20 = 1),
        Type != 7 && (v20 & 1) == 0))
  {
    int v128 = 1;
  }
  CGColorSpaceRef space = ColorSpace;
  size_t v126 = Width;
  if ((gIIODebugFlags & 0x10000000000) != 0)
  {
    ImageIOLog("            csIndexed: %d\n", Type == 7);
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      unsigned int v21 = IIO_ColorModelString(Model);
      ImageIOLog("              csModel: %d = %s\n", Model, v21);
      if ((gIIODebugFlags & 0x10000000000) != 0) {
        ImageIOLog("            indexedOK: %d\n", v128);
      }
    }
  }
  if (((Type == 7) & (a5 >> 4)) != 0) {
    unsigned int v22 = v18 & 0xF9FFFFFF;
  }
  else {
    unsigned int v22 = v18;
  }
  BOOL v23 = Model != kCGColorSpaceModelRGB || (a5 & 0x11) == 0;
  BOOL v27 = 1;
  if (v23 && ((Model == kCGColorSpaceModelCMYK) & (a5 >> 1)) == 0)
  {
    BOOL v24 = (a5 & 8) != 0 && v16 == 5;
    BOOL v25 = !v24;
    BOOL v26 = Model || (a5 & 0x24) == 0;
    if (v26 && v25) {
      BOOL v27 = 0;
    }
  }
  if (Model != kCGColorSpaceModelDeviceN || v27 || BitsPerComponent != 1 || (v22 & 0x100) == 0)
  {
    BOOL v114 = !v27;
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      uint64_t v29 = "no <<<";
      if (v27) {
        uint64_t v29 = "yes";
      }
      ImageIOLog("         spaceModelOK: %s\n", v29);
    }
    if (v16 <= 5 && ((1 << v16) & 0x27) != 0 || (v31 = 0, int v30 = v22 & 0x40000, (v22 & 0x40000) != 0) && v16 != 9)
    {
      int v30 = v22 & 0x40000;
      int v31 = 1;
    }
    if (v16 == 6) {
      int v32 = v31;
    }
    else {
      int v32 = 1;
    }
    if (v30) {
      int v33 = v32;
    }
    else {
      int v33 = 1;
    }
    int v124 = v31 | v33 ^ 1;
    if (Model == kCGColorSpaceModelRGB)
    {
      unint64_t v34 = BitsPerComponent;
    }
    else
    {
      unint64_t v34 = BitsPerComponent;
      if ((v33 & 1) == 0) {
        int v124 = (Model & 0xFFFFFFFD) == 0;
      }
    }
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      long long v35 = "no <<<";
      if (v124) {
        long long v35 = "yes";
      }
      ImageIOLog("          spaceTypeOK: %s\n", v35);
    }
    if (BitsPerComponent == 1 && (v22 & 0x100) != 0) {
      goto LABEL_106;
    }
    if (BitsPerComponent == 2 && (v22 & 0x200) != 0) {
      goto LABEL_106;
    }
    if (BitsPerComponent == 4 && (v22 & 0x400) != 0) {
      goto LABEL_106;
    }
    if (BitsPerComponent == 8 && (v22 & 0x800) != 0) {
      goto LABEL_106;
    }
    if (BitsPerComponent == 16 && (v22 & 0x1000) != 0) {
      goto LABEL_106;
    }
    if (BitsPerComponent == 16 && (v22 & 0x4000) != 0) {
      goto LABEL_106;
    }
    if (BitsPerComponent == 16 && (v22 & 0x10000) != 0) {
      goto LABEL_106;
    }
    int v36 = IsFloat ^ 1;
    if (BitsPerComponent == 32 && (v22 & 0x2000) != 0 && !v36) {
      goto LABEL_106;
    }
    if ((v22 & 0x8000) == 0 || BitsPerComponent != 32) {
      LOBYTE(v36) = 1;
    }
    if ((v36 & 1) == 0) {
LABEL_106:
    }
      int v120 = 1;
    else {
      int v120 = 0;
    }
    BOOL v119 = v27;
    if ((gIIODebugFlags & 0x10000000000) != 0
      && (ImageIOLog("          bitsPerComp: %d\n", v34), (gIIODebugFlags & 0x10000000000) != 0))
    {
      uint64_t v49 = "no <<<";
      if (v120) {
        uint64_t v49 = "yes";
      }
      ImageIOLog("              depthOK: %s\n", v49);
      BOOL v38 = ((1 << (AlphaInfo + 24)) & v22 & 0x7F000000) != 0;
      if ((gIIODebugFlags & 0x10000000000) != 0) {
        ImageIOLog("              alphaOK: %d\n", ((1 << (AlphaInfo + 24)) & v22 & 0x7F000000) != 0);
      }
    }
    else
    {
      BOOL v38 = ((1 << (AlphaInfo + 24)) & v22 & 0x7F000000) != 0;
    }
    if (BitsPerComponent == 1 && !EndianInfo && (v22 & 0x100) != 0) {
      goto LABEL_155;
    }
    if (BitsPerComponent == 2 && !EndianInfo && (v22 & 0x200) != 0) {
      goto LABEL_155;
    }
    if (BitsPerComponent == 4 && !EndianInfo && (v22 & 0x400) != 0) {
      goto LABEL_155;
    }
    if (BitsPerComponent == 8 && !EndianInfo && (v22 & 0x800) != 0) {
      goto LABEL_155;
    }
    BOOL v39 = BitsPerComponent != 16;
    if (BitsPerComponent == 16 && EndianInfo == 12288 && (v22 & 0x1000) != 0) {
      goto LABEL_155;
    }
    if (BitsPerComponent == 16 && !EndianInfo && (v22 & 0x1000) != 0) {
      goto LABEL_155;
    }
    if (EndianInfo != 4096) {
      BOOL v39 = 1;
    }
    if (!v39 && (v22 & 0x4000) != 0) {
      goto LABEL_155;
    }
    int v40 = IsFloat ^ 1;
    BOOL v41 = BitsPerComponent != 32;
    if (BitsPerComponent == 32 && EndianInfo == 0x4000 && (v22 & 0x2000) != 0 && !v40) {
      goto LABEL_155;
    }
    BOOL v43 = BitsPerComponent != 32 || EndianInfo != 0;
    if ((v22 & 0x2000) == 0) {
      BOOL v43 = 1;
    }
    if ((v43 | v40) != 1) {
      goto LABEL_155;
    }
    if (EndianInfo != 0x2000) {
      BOOL v41 = 1;
    }
    if ((v22 & 0x8000) == 0) {
      BOOL v41 = 1;
    }
    if ((v41 | v40) != 1)
    {
LABEL_155:
      int v45 = 1;
    }
    else
    {
      char v44 = !v14;
      if (BitsPerComponent != 8) {
        char v44 = 1;
      }
      if ((v44 & 1) != 0 || (EndianInfo | 0x2000) != 0x2000) {
        int v45 = 0;
      }
      else {
        int v45 = (v22 >> 11) & 1;
      }
    }
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      ImageIOLog("          bitsPerComp: %d\n", v34);
      if ((gIIODebugFlags & 0x10000000000) != 0)
      {
        ImageIOLog("           endianInfo: %d [%p]\n", EndianInfo, (const void *)EndianInfo);
        if ((gIIODebugFlags & 0x10000000000) != 0)
        {
          int v46 = "no <<<";
          if (v45) {
            int v46 = "yes";
          }
          ImageIOLog("             endianOK: %s\n", v46);
        }
      }
    }
    int v116 = v45;
    if (v11)
    {
      BOOL v47 = *v11 == 1.0 && v11[1] == 0.0;
      if (*v11 == 0.0)
      {
        unsigned int v48 = v11[1] == 1.0;
        if (Model) {
          goto LABEL_177;
        }
      }
      else
      {
        unsigned int v48 = 0;
        if (Model) {
          goto LABEL_177;
        }
      }
    }
    else
    {
      BOOL v47 = 0;
      unsigned int v48 = 1;
      if (Model) {
        goto LABEL_177;
      }
    }
    unsigned int v50 = v47 & (a5 >> 5);
    if (BitsPerComponent == 1) {
      unsigned int v50 = 1;
    }
    unsigned int v48 = v50 | v48 & (a5 >> 2);
LABEL_177:
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      unsigned int v51 = "no <<<";
      if (v48) {
        unsigned int v51 = "yes";
      }
      ImageIOLog("             decodeOK: %s\n", v51);
    }
    Hasuint64_t Mask = _ImageHasMask();
    BOOL v53 = HasMask;
    if ((gIIODebugFlags & 0x10000000000) != 0) {
      ImageIOLog("               maskOK: %d\n", !HasMask);
    }
    unsigned int v54 = CGImageGetColorSpace(image);
    size_t MinimalPixelSize = _GetMinimalPixelSize(v54, v34, AlphaInfo);
    size_t v56 = MinimalPixelSize;
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      uint64_t v57 = "yes";
      if (BitsPerPixel != MinimalPixelSize) {
        uint64_t v57 = "no <<<";
      }
      ImageIOLog("                bppOK: %s\n", v57);
    }
    long long v58 = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 16);
    *(_OWORD *)&v134.a = *MEMORY[0x1E4F1DAB8];
    *(_OWORD *)&v134.c = v58;
    *(_OWORD *)&v134.tdouble x = *(_OWORD *)(MEMORY[0x1E4F1DAB8] + 32);
    unint64_t v59 = a3 - 2;
    if (a3 - 2 <= 6)
    {
      v135[0] = 0xBFF0000000000000;
      v135[1] = 0;
      v135[2] = 0;
      v135[3] = 0x3FF0000000000000;
      unint64_t v60 = Height;
      *(double *)&v135[4] = (double)v126;
      long long v136 = xmmword_18898F550;
      uint64_t v137 = 0;
      uint64_t v138 = 0;
      unint64_t v139 = 0xBFF0000000000000;
      double v140 = (double)v126;
      double v141 = (double)Height;
      uint64_t v143 = 0;
      uint64_t v144 = 0;
      uint64_t v142 = 0x3FF0000000000000;
      long long v145 = xmmword_18898F570;
      long long v147 = xmmword_18898F550;
      long long v148 = xmmword_18898F570;
      double v146 = (double)Height;
      double v149 = (double)Height;
      double v150 = (double)v126;
      long long v151 = xmmword_18898F550;
      uint64_t v154 = 0;
      uint64_t v152 = 0x3FF0000000000000;
      uint64_t v153 = 0;
      double v155 = (double)v126;
      long long v156 = xmmword_18898F560;
      long long v158 = 0u;
      long long v159 = 0u;
      uint64_t v157 = 0x3FF0000000000000;
      uint64_t v160 = 0x3FF0000000000000;
      long long v161 = xmmword_18898F570;
      double v162 = (double)Height;
      uint64_t v163 = 0;
      long long v61 = (long long *)&v135[6 * v59];
      long long v62 = v61[2];
      long long v64 = *v61;
      long long v63 = v61[1];
      if (a3 <= 4) {
        size_t v65 = v126;
      }
      else {
        size_t v65 = Height;
      }
      if (a3 > 4) {
        unint64_t v60 = v126;
      }
      unint64_t Height = v60;
      size_t v126 = v65;
      *(_OWORD *)&v134.c = v63;
      *(_OWORD *)&v134.tdouble x = v62;
      *(_OWORD *)&v134.a = v64;
    }
    unint64_t v122 = a3 - 2;
    if ((gIIODebugFlags & 0x10000000000) != 0)
    {
      int v66 = "yes";
      if (v59 < 7) {
        int v66 = "no";
      }
      ImageIOLog("             orientOK: %s\n", v66);
      unint64_t v59 = v122;
    }
    int v67 = v48 ^ 1;
    int v68 = v128 & v119 & v124 & v120;
    char v69 = v116;
    int v113 = v68 ^ 1;
    if (v59 >= 7
      && ((v67 | v53) & 1) == 0
      && ((v68 ^ 1) & 1) == 0
      && v38
      && ((v116 ^ 1) & 1) == 0
      && BitsPerPixel == v56)
    {
      int v112 = v67;
      int BitmapInfo = _ImageGetBitmapInfo(image);
      if (BitmapInfo == CGImageGetBitmapInfo(image))
      {
        CopyWithCGColorSpaceRef ColorSpace = CGImageRetain(image);
      }
      else
      {
        size_t v111 = CGImageGetBitsPerComponent(image);
        size_t v110 = CGImageGetBitsPerPixel(image);
        size_t bytesPerRow = CGImageGetBytesPerRow(image);
        CGColorSpaceRef v71 = CGImageGetColorSpace(image);
        CGBitmapInfo v72 = _ImageGetBitmapInfo(image);
        CGDataProviderRef DataProvider = CGImageGetDataProvider(image);
        decode = CGImageGetDecode(image);
        BOOL shouldInterpolate = CGImageGetShouldInterpolate(image);
        CGColorRenderingIntent RenderingIntent = CGImageGetRenderingIntent(image);
        uint64_t v77 = v71;
        char v69 = v116;
        CopyWithCGColorSpaceRef ColorSpace = CGImageCreate(v126, Height, v111, v110, bytesPerRow, v77, v72, DataProvider, decode, shouldInterpolate, RenderingIntent);
        CGImageSetProperty();
        CGImageSetProperty();
      }
      int v67 = v112;
      if (CopyWithColorSpace)
      {
        CFMutableArrayRef v28 = 0;
        goto LABEL_327;
      }
      unint64_t v34 = BitsPerComponent;
      if ((gIIODebugFlags & 0x10000000000) != 0)
      {
        ImageIOLog("*** CGImageCreate failed\n");
        int v67 = v112;
      }
    }
    int v78 = v67;
    if (_ImageIsOpaque(image))
    {
      unint64_t v79 = BitsPerComponent;
      unsigned int v80 = Type;
      BOOL v81 = v119;
      if ((v22 & 0x40000000) != 0 && BitsPerPixel > 8)
      {
        int v82 = 0;
        int v83 = 6;
      }
      else if ((v22 & 0x20000000) != 0 && BitsPerPixel > 8)
      {
        int v82 = 0;
        int v83 = 5;
      }
      else if ((v22 & 0x1000000) != 0)
      {
        int v83 = 0;
        int v82 = 0;
      }
      else
      {
        int v82 = 0;
        if ((v22 & 0x8000000) != 0)
        {
          int v83 = 3;
        }
        else if ((v22 & 0x10000000) != 0)
        {
          int v83 = 4;
        }
        else if ((v22 & 0x2000000) != 0)
        {
          int v83 = 1;
        }
        else
        {
          int v83 = 2;
        }
      }
    }
    else
    {
      unsigned int v84 = AlphaInfo - 3;
      unint64_t v79 = BitsPerComponent;
      unsigned int v80 = Type;
      BOOL v81 = v119;
      if ((v22 & 0x2000000) != 0 && v84 > 0xFFFFFFFD)
      {
        int v83 = 1;
      }
      else if ((v22 & 0x4000000) != 0 && v84 > 0xFFFFFFFD)
      {
        int v83 = 2;
      }
      else if ((v22 & 0x8000000) != 0)
      {
        int v83 = 3;
      }
      else
      {
        if ((v22 & 0x2000000) != 0) {
          int v85 = 1;
        }
        else {
          int v85 = 2;
        }
        if ((v22 & 0x10000000) != 0) {
          int v83 = 4;
        }
        else {
          int v83 = v85;
        }
        if ((v22 & 0x16000000) == 0)
        {
          if ((v22 & 0x40000000) != 0 && BitsPerPixel > 8)
          {
            int v83 = 6;
          }
          else if (((BitsPerPixel > 8) & (v22 >> 29)) != 0)
          {
            int v83 = 5;
          }
          else
          {
            int v83 = 0;
          }
        }
      }
      if ((v22 & 0x1E000000) != 0) {
        int v82 = 0;
      }
      else {
        int v82 = a4;
      }
    }
    if ((v120 & 1) == 0)
    {
      if ((v22 & 0x1FF00) == 0x2000) {
        goto LABEL_256;
      }
      char v86 = IsFloat;
      if ((v22 & 0xA000) == 0) {
        char v86 = 0;
      }
      if (v86)
      {
LABEL_256:
        unint64_t v34 = 32;
      }
      else if (v79 < 9 || (unint64_t v34 = 16, v22 != 0x4000) && (v22 & 0x11000) == 0)
      {
        unint64_t v34 = 8;
      }
    }
    if ((v69 & 1) == 0)
    {
      if (v34 == 16 && (v22 & 0x4000) != 0)
      {
        int v87 = 4096;
      }
      else
      {
        BOOL v88 = (v22 & 0x8000) != 0 && v34 == 32;
        int v89 = IsFloat ^ 1;
        if (!v88) {
          int v89 = 1;
        }
        if (v89) {
          int v87 = 0;
        }
        else {
          int v87 = 0x2000;
        }
      }
      LODWORD(EndianInfo) = v87;
    }
    CGBitmapInfo v90 = EndianInfo | v83;
    if (v34 == 32) {
      CGBitmapInfo v90 = EndianInfo | v83 | 0x100;
    }
    CGBitmapInfo v132 = v90;
    int v91 = v128;
    if (v80 != 7) {
      int v91 = 0;
    }
    if (((v114 | v124 ^ 1) & 1) == 0 && v91)
    {
      uint64_t v92 = v82;
      int v93 = CGImageGetColorSpace(image);
      CFMutableArrayRef v28 = CGColorSpaceRetain(v93);
      unint64_t v94 = v126;
      if ((a5 & 2) != 0) {
        goto LABEL_305;
      }
      goto LABEL_304;
    }
    unint64_t v94 = v126;
    if (((v114 | v124 ^ 1) & 1) == 0)
    {
      uint64_t v92 = v82;
      CGColorSpaceRef v97 = CGColorSpaceRetain(space);
      goto LABEL_303;
    }
    char v95 = !v81;
    if (Model != kCGColorSpaceModelCMYK) {
      char v95 = 1;
    }
    if ((v95 & 1) == 0)
    {
      uint64_t v92 = v82;
      int v96 = (CFStringRef *)MEMORY[0x1E4F1DBF0];
LABEL_302:
      CGColorSpaceRef v97 = CGColorSpaceCreateWithName(*v96);
LABEL_303:
      CFMutableArrayRef v28 = v97;
      if ((a5 & 2) != 0) {
        goto LABEL_305;
      }
      goto LABEL_304;
    }
    if (Model) {
      BOOL v98 = 0;
    }
    else {
      BOOL v98 = v81;
    }
    int v96 = (CFStringRef *)MEMORY[0x1E4F1DC00];
    if (!v98)
    {
      if ((a5 & 1) != 0 && v79 >= 8)
      {
        uint64_t v92 = v82;
        int v96 = (CFStringRef *)MEMORY[0x1E4F1DC98];
        goto LABEL_302;
      }
      if ((a5 & 2) == 0 || v79 <= 7)
      {
        uint64_t v92 = v82;
        if ((a5 & 4) == 0)
        {
          CFMutableArrayRef v28 = 0;
          if ((a5 & 2) != 0)
          {
LABEL_305:
            if (a5 & 4 | Model)
            {
LABEL_307:
              size_t v99 = _GetMinimalPixelSize(v28, v34, v83);
              unint64_t v100 = (v99 * v94 + 7) >> 3;
              uint64_t v101 = gIIODebugFlags;
              if (v122 >= 7 && ((v113 | v78) & 1) == 0)
              {
                if ((gIIODebugFlags & 0x10000000000) != 0)
                {
                  ImageIOLog("CGImageCreateCopyWithBitmapInfo\n");
                  if ((gIIODebugFlags & 0x10000000000) != 0)
                  {
                    ImageIOLog("        newbits/Pixel: %zd\n", v99);
                    if ((gIIODebugFlags & 0x10000000000) != 0)
                    {
                      ImageIOLog("         newbytes/Row: %zd\n", v100);
                      if ((gIIODebugFlags & 0x10000000000) != 0) {
                        ImageIOLog("        newBitmapInfo: %d\n", v132);
                      }
                    }
                  }
                }
                BOOL v102 = CGImageGetShouldInterpolate(image);
                CGColorRenderingIntent v103 = CGImageGetRenderingIntent(image);
                CopyWithint BitmapInfo = CGImageCreateCopyWithBitmapInfo(image, v92, v99, v100, v132, v102, v103);
                if (CopyWithBitmapInfo)
                {
                  CopyWithCGColorSpaceRef ColorSpace = CopyWithBitmapInfo;
LABEL_327:
                  CGImageSetProperty();
                  if ((gIIODebugFlags & 0x10000000000) != 0)
                  {
                    if (CopyWithColorSpace == image) {
                      ImageIOLog("CGImageCreateConforming - newImage == input image\n");
                    }
                    else {
                      ImageIOLog("CGImageCreateConforming - newImage:\n");
                    }
                  }
                  goto LABEL_331;
                }
                uint64_t v101 = gIIODebugFlags;
                if ((gIIODebugFlags & 0x10000000000) != 0)
                {
                  ImageIOLog("*** CGImageCreateCopyWithBitmapInfo failed\n");
                  uint64_t v101 = gIIODebugFlags;
                }
              }
              if ((v101 & 0x10000000000) != 0)
              {
                ImageIOLog("CGImageCreateCopyWithParametersNew\n");
                if ((gIIODebugFlags & 0x10000000000) != 0)
                {
                  ImageIOLog("                 size: %zd x %zd\n", v94, Height);
                  if ((gIIODebugFlags & 0x10000000000) != 0)
                  {
                    ImageIOLog("        newbits/Pixel: %zd\n", v99);
                    if ((gIIODebugFlags & 0x10000000000) != 0)
                    {
                      ImageIOLog("         newbytes/Row: %zd\n", v100);
                      if ((gIIODebugFlags & 0x10000000000) != 0)
                      {
                        ImageIOLog("        newBitmapInfo: %d\n", v132);
                        if ((gIIODebugFlags & 0x10000000000) != 0) {
                          ImageIOLog("        newcolorspace: ");
                        }
                      }
                    }
                  }
                }
                CFShow(v28);
              }
              CGAffineTransform v133 = v134;
              BOOL v105 = CGImageGetShouldInterpolate(image);
              CGColorRenderingIntent v106 = CGImageGetRenderingIntent(image);
              CopyWithCGColorSpaceRef ColorSpace = CGImageCreateCopyWithParametersNew(image, v92, &v133, v94, Height, v34, v99, v100, v28, v132, v105, v106, kCGInterpolationDefault, 0);
              if (!CopyWithColorSpace)
              {
                if ((gIIODebugFlags & 0x10000000000) != 0) {
                  ImageIOLog("*** CGImageCreateCopyWithParametersNew failed\n");
                }
                goto LABEL_331;
              }
              goto LABEL_327;
            }
LABEL_306:
            CFMutableArrayRef v28 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
            goto LABEL_307;
          }
LABEL_304:
          if (Model == kCGColorSpaceModelCMYK) {
            goto LABEL_306;
          }
          goto LABEL_305;
        }
        goto LABEL_302;
      }
      int v96 = (CFStringRef *)MEMORY[0x1E4F1DBF0];
    }
    uint64_t v92 = v82;
    CFMutableArrayRef v28 = CGColorSpaceCreateWithName(*v96);
    goto LABEL_305;
  }
  CFMutableArrayRef v28 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
  CopyWithCGColorSpaceRef ColorSpace = CGImageCreateCopyWithColorSpace(image, v28);
  if (CopyWithColorSpace) {
    goto LABEL_327;
  }
LABEL_331:
  if (v28) {
    CGColorSpaceRelease(v28);
  }
LABEL_333:
  if ((gIIODebugFlags & 0x20000000000) != 0)
  {
    CFAbsoluteTime v107 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("    IIOImageDestination::createCGImageConforming - %g ms\n", (v107 - Current) * 1000.0);
  }
  return CopyWithColorSpace;
}

BOOL IIOImageDestination::copyImageSource(CFStringRef *this, CGImageSourceRef isrc, IIODictionary *a3, BOOL a4, __CFError **a5)
{
  uint64_t v15 = 0;
  CFStringRef Type = CGImageSourceGetType(isrc);
  if (!Type)
  {
    IIOLogAndCreateError(&v15, (const __CFString *)*MEMORY[0x1E4F1D158], -50, "copyImageSource", 1940, "CGImageDestinationCopyImageSource: source is corrupt\n");
    goto LABEL_10;
  }
  if (CFStringCompare(Type, this[9], 0))
  {
    IIOLogAndCreateError(&v15, (const __CFString *)*MEMORY[0x1E4F1D158], -50, "copyImageSource", 1942, "image destination UTType does not match image source UTType\n");
LABEL_10:
    BOOL updated = 0;
    if (!a5) {
      return updated;
    }
    goto LABEL_6;
  }
  uint64_t Source = (IIOImageSource *)CGImageSourceGetSource((uint64_t)isrc);
  memset(v14, 0, sizeof(v14));
  IIOMetadataUpdater::IIOMetadataUpdater((IIOMetadataUpdater *)v14, Source, (IIOImageDestination *)this, a3, a4);
  BOOL updated = IIOMetadataUpdater::updateDestination((IIOImageSource **)v14, &v15);
  if (updated) {
    *((unsigned char *)this + 224) = 1;
  }
  IIOMetadataUpdater::~IIOMetadataUpdater((IIOMetadataUpdater *)v14);
  if (a5) {
LABEL_6:
  }
    *a5 = v15;
  return updated;
}

void sub_188770A38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

double IIOImageDestination::handlePerFrameGIFSaving(IIOImageDestination *this, CGImage *a2, IIODictionary *a3)
{
  if (*((void *)this + 6) != 1) {
    goto LABEL_9;
  }
  unsigned int v6 = IIODictionary::containsKey(*((IIODictionary **)this + 11), @"HasGlobalColorMap");
  double v7 = (IIODictionary *)*((void *)this + 11);
  if (v6) {
    goto LABEL_3;
  }
  if (IIODictionary::containsKeyGroup(v7, @"HasGlobalColorMap", @"{GIF}"))
  {
    uint64_t v10 = (IIODictionary *)*((void *)this + 11);
LABEL_6:
    unsigned __int8 BoolForKeyGroup = IIODictionary::getBoolForKeyGroup(v10, @"HasGlobalColorMap", @"{GIF}");
    goto LABEL_7;
  }
  if (!IIODictionary::containsKey(a3, @"HasGlobalColorMap"))
  {
    if (!IIODictionary::containsKeyGroup(a3, @"HasGlobalColorMap", @"{GIF}"))
    {
      uint64_t v11 = (char *)this + 223;
      if (!*((unsigned char *)this + 223))
      {
        uint64_t v15 = (IIODictionary *)*((void *)this + 11);
        if (v15)
        {
          unsigned int v16 = IIODictionary::containsKey(v15, @"HasGlobalColorMap");
          unsigned int v17 = (IIODictionary *)*((void *)this + 11);
          if (v16)
          {
            *((unsigned char *)this + 222) = !IIODictionary::getBoolForKey(v17, @"HasGlobalColorMap");
            *((unsigned char *)this + 223) = 1;
          }
          else if (IIODictionary::containsKey(v17, @"{GIF}"))
          {
            CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a3, @"{GIF}");
            if (ObjectForKey)
            {
              memset(v19, 0, sizeof(v19));
              IIODictionary::IIODictionary((IIODictionary *)v19, ObjectForKey);
              if (IIODictionary::containsKey((IIODictionary *)v19, @"HasGlobalColorMap"))
              {
                *((unsigned char *)this + 222) = !IIODictionary::getBoolForKey((IIODictionary *)v19, @"HasGlobalColorMap");
                *((unsigned char *)this + 223) = 1;
              }
              IIODictionary::~IIODictionary((IIODictionary *)v19);
            }
          }
        }
      }
      goto LABEL_8;
    }
    uint64_t v10 = a3;
    goto LABEL_6;
  }
  double v7 = a3;
LABEL_3:
  unsigned __int8 BoolForKeyGroup = IIODictionary::getBoolForKey(v7, @"HasGlobalColorMap");
LABEL_7:
  *((unsigned char *)this + 223) = 1;
  uint64_t v11 = (char *)this + 223;
  *((unsigned char *)this + 222) = BoolForKeyGroup ^ 1;
LABEL_8:
  if (!*((unsigned char *)this + 222))
  {
    if (*v11)
    {
      uint64_t v13 = *((void *)this + 5);
      size_t v14 = CGImageGetWidth(a2) * v13;
      if (v14 * CGImageGetHeight(a2) >= 0x5F5E101)
      {
        *((_WORD *)this + 111) = 257;
        LogWarning("handlePerFrameGIFSaving", 2330, "*** NOTE: Global colormap was requested when saving GIF, but memory exceeds limit. Enabling local colormaps.\n");
      }
    }
  }
LABEL_9:
  if (*((unsigned char *)this + 222) && *((unsigned char *)this + 223))
  {
    uint64_t v12 = (const void *)IIO_Writer::utType(*((IIO_Writer **)this + 8));
    IIODebugCallbackPriv(v12, "write");
    IIO_Reader::osType(*((IIO_Reader **)this + 8));
    kdebug_trace();
    if ((***((unsigned int (****)(void))this + 8))()) {
      *((unsigned char *)this + 223) = 0;
    }
    IIO_Reader::osType(*((IIO_Reader **)this + 8));
    kdebug_trace();
    if (!*((unsigned char *)this + 223)) {
      _cg_jpeg_mem_term("handlePerFrameGIFSaving", 2353, "*** failed to write GIF frame #%d\n", *((void *)this + 7));
    }
    IIOImageDestination::setPixelProviderAtIndex((uint64_t)this, 0, *((void *)this + 7));
    IIOImageDestination::setImagePropertiesAtIndex(this, 0, *((void *)this + 7));
    *(void *)&double result = IIOImageDestination::setSourceImageAtIndex(this, 0, *((void *)this + 7)).n128_u64[0];
  }
  return result;
}

void sub_188770D60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void IIOImageDestination::handlePerFrameHEICSSaving(IIOImageDestination *this, CGImage *a2, IIODictionary *a3)
{
  if (*((void *)this + 6) == 1)
  {
    *((_WORD *)this + 111) = 257;
    if (!*((void *)this + 4)) {
      *((void *)this + 4) = (*(uint64_t (**)(void, void, IIOImageDestination *))(**((void **)this + 8)
    }
                                                                                               + 8))(*((void *)this + 8), *((void *)this + 3), this);
  }
  uint64_t v4 = (const void *)IIO_Writer::utType(*((IIO_Writer **)this + 8));
  IIODebugCallbackPriv(v4, "write");
  uint64_t v5 = *((void *)this + 7);
  PixelProviderAtIndedouble x = IIOImageDestination::getPixelProviderAtIndex((CFArrayRef *)this, v5);
  ImagePropertiesAtIndedouble x = IIOImageDestination::getImagePropertiesAtIndex(this, v5);
  if ((*(unsigned int (**)(void, uint64_t, void, uint64_t, void, uint64_t, void))(**((void **)this + 4)
                                                                                                 + 40))(*((void *)this + 4), PixelProviderAtIndex, 0, ImagePropertiesAtIndex, *((void *)this + 11), v5, 0))
  {
    BOOL v8 = 1;
  }
  else
  {
    BOOL v8 = *((unsigned char *)this + 223) == 0;
  }
  char v9 = !v8;
  *((unsigned char *)this + 223) = v9;
  if (v8) {
    _cg_jpeg_mem_term("handlePerFrameHEICSSaving", 2389, "*** failed to write HEICS frame #%d\n", *((void *)this + 7));
  }
  IIOImageDestination::setPixelProviderAtIndex((uint64_t)this, 0, v5);
  __n128 v10 = IIOImageDestination::setImagePropertiesAtIndex(this, 0, v5);
  if (v5 == *((void *)this + 5) - 1)
  {
    uint64_t v11 = *(void (**)(__n128))(**((void **)this + 4) + 48);
    v11(v10);
  }
}

uint64_t IIOImageDestination::createCreateSDRandHDRGainMapFromHDR(IIOImageDestination *this, CGImageRef image, void **a3, CGImage **a4, IIODictionary *a5)
{
  CFTypeRef v21 = 0;
  CFDictionaryRef v22 = 0;
  if ((gIIODebugFlags & 0x300000) != 0) {
    ImageIOLog("  %s \n", "createCreateSDRandHDRGainMapFromHDR");
  }
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
  if (CGColorSpaceUsesITUR_2100TF(ColorSpace) || CGColorSpaceUsesExtendedRange(ColorSpace))
  {
    if (CGImageGetImageProvider() && CGImageProviderGetCallbackVersion() >= 2)
    {
      uint64_t v18 = 0;
      BOOL v19 = 0;
      uint64_t v20 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v18);
      IIONumber::IIONumber((IIONumber *)v17, 2019963440);
      IIODictionary::setObjectForKey((uint64_t)&v18, (uint64_t)v17, @"kCGImageSurfaceFormatRequest");
      IIONumber::~IIONumber((IIONumber *)v17);
      IOSurfaceFromImage = (__IOSurface *)CGImageProviderCopyIOSurface();
      if (!IOSurfaceFromImage)
      {
        _cg_jpeg_mem_term("createCreateSDRandHDRGainMapFromHDR", 3119, "*** ERROR: failed to get IOSurface from image (%p)\n", image);
        IIODictionary::~IIODictionary((IIODictionary *)&v18);
        return 4294967292;
      }
      IIODictionary::~IIODictionary((IIODictionary *)&v18);
    }
    else
    {
      IOSurfaceFromImage = IIO_CreateIOSurfaceFromImage(image, 0);
    }
    IIO_LoadHEIFSymbols();
    uint64_t v18 = 0;
    BOOL v19 = 0;
    uint64_t v20 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v18);
    int Width = IOSurfaceGetWidth(IOSurfaceFromImage);
    IIONumber::IIONumber((IIONumber *)v16, Width);
    IIODictionary::setObjectForKey((uint64_t)&v18, (uint64_t)v16, *(const void **)gIIO_kCVPixelBufferWidthKey);
    IIONumber::~IIONumber((IIONumber *)v16);
    int Height = IOSurfaceGetHeight(IOSurfaceFromImage);
    IIONumber::IIONumber((IIONumber *)v15, Height);
    IIODictionary::setObjectForKey((uint64_t)&v18, (uint64_t)v15, *(const void **)gIIO_kCVPixelBufferHeightKey);
    IIONumber::~IIONumber((IIONumber *)v15);
    OSType PixelFormat = IOSurfaceGetPixelFormat(IOSurfaceFromImage);
    IIONumber::IIONumber((IIONumber *)v14, PixelFormat);
    IIODictionary::setObjectForKey((uint64_t)&v18, (uint64_t)v14, *(const void **)gIIO_kCVPixelBufferPixelFormatTypeKey);
    IIONumber::~IIONumber((IIONumber *)v14);
    IIODictionary::setObjectForKey((IIODictionary *)&v18, ColorSpace, *(const __CFString **)gIIO_kCVImageBufferCGColorSpaceKey);
    uint64_t v12 = IIOCreatePixelBufferAttributesForHDRType(1, v19, a3[1], &v22);
    if (!v12) {
      IIO_CreateIOSurfaceWithPixelBufferAttributes(v22);
    }
    LogError("createCreateSDRandHDRGainMapFromHDR", 3140, "*** ERROR: failed to create output pixel buffer attributes (%d)\n", v12);
    if (IOSurfaceFromImage) {
      CFRelease(IOSurfaceFromImage);
    }
    if (v22) {
      CFRelease(v22);
    }
    if (v21) {
      CFRelease(v21);
    }
    IIODictionary::~IIODictionary((IIODictionary *)&v18);
  }
  else
  {
    _cg_jpeg_mem_term("createCreateSDRandHDRGainMapFromHDR", 3100, "*** ERROR: input image is not HDR\n");
    return 4294967246;
  }
  return v12;
}

void sub_1887715FC(_Unwind_Exception *a1)
{
  IIONumber::~IIONumber((IIONumber *)(v1 - 168));
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 144));
  _Unwind_Resume(a1);
}

void IIOImageDestination::addAuxiliaryDataInfo(IIOImageDestination *this, const __CFString *a2, const void **a3)
{
  if (CFEqual(@"kCGImageAuxiliaryDataTypeDisparity", a2))
  {
    int v9 = 0;
    CFStringRef v6 = 0;
    int v10 = 1;
    goto LABEL_35;
  }
  if (CFEqual(@"kCGImageAuxiliaryDataTypeDepth", a2))
  {
    int v9 = 0;
    CFStringRef v6 = 0;
    int v10 = 2;
    goto LABEL_35;
  }
  if (CFEqual(@"kCGImageAuxiliaryDataTypeAlpha", a2))
  {
    int v9 = 0;
    CFStringRef v6 = 0;
    int v10 = 3;
    goto LABEL_35;
  }
  if (CFEqual(@"kCGImageAuxiliaryDataTypePortraitEffectsMatte", a2))
  {
    int v9 = 0;
    CFStringRef v6 = 0;
    int v10 = 5;
    goto LABEL_35;
  }
  if (CFEqual(@"kCGImageAuxiliaryDataTypeSemanticSegmentationSkinMatte", a2))
  {
    int v7 = 0;
    char v8 = 1;
    uint64_t v11 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte;
LABEL_27:
    int v9 = 0;
    CFStringRef v6 = *(const __CFString **)*v11;
    goto LABEL_28;
  }
  if (CFEqual(@"kCGImageAuxiliaryDataTypeSemanticSegmentationHairMatte", a2))
  {
    int v7 = 0;
    char v8 = 1;
    uint64_t v11 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte;
    goto LABEL_27;
  }
  if (CFEqual(@"kCGImageAuxiliaryDataTypeSemanticSegmentationTeethMatte", a2))
  {
    int v7 = 0;
    char v8 = 1;
    uint64_t v11 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte;
    goto LABEL_27;
  }
  if (CFEqual(@"kCGImageAuxiliaryDataTypeSemanticSegmentationGlassesMatte", a2))
  {
    char v8 = 0;
    int v7 = 1;
    uint64_t v11 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte;
    goto LABEL_27;
  }
  if (CFEqual(@"kCGImageAuxiliaryDataTypeSemanticSegmentationSkyMatte", a2))
  {
    char v8 = 0;
    int v7 = 2;
    uint64_t v11 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte;
    goto LABEL_27;
  }
  if (CFEqual(@"kCGImageAuxiliaryDataTypeHDRGainMap", a2))
  {
    char v8 = 0;
    int v7 = 3;
    uint64_t v11 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap;
    goto LABEL_27;
  }
  CFStringRef v6 = @"kCGImageAuxiliaryDataTypeISOGainMap";
  if (CFStringCompare(@"kCGImageAuxiliaryDataTypeISOGainMap", a2, 0))
  {
    if (!IIO_OSAppleInternalBuild()
      || !CFStringHasPrefix(a2, @"http:")
      && !CFStringHasPrefix(a2, @"https:")
      && !CFStringHasPrefix(a2, @"urn:"))
    {
      goto LABEL_61;
    }
    int v7 = 0;
    char v8 = 1;
    CFStringRef v6 = a2;
    int v9 = 1;
LABEL_28:
    if (v6)
    {
      CFComparisonResult v12 = CFStringCompare(v6, @"FIG_STRING_SYMBOL_NOT_FOUND", 0);
      if (v12) {
        char v13 = 1;
      }
      else {
        char v13 = v8;
      }
      if (v13)
      {
        if (v12)
        {
          int v10 = 4;
          goto LABEL_35;
        }
      }
      else
      {
        LogError("addAuxiliaryDataInfo", 4392, "*** ERROR: addAuxiliaryDataInfo - MediaToolbox symbol not found [%d]\n", v7);
      }
    }
LABEL_61:
    CFMutableArrayRef v30 = 0;
    uint64_t v31 = 0;
    uint64_t v32 = 0;
    CFDictionaryRef v22 = IIOString::IIOString((IIOString *)&v30, a2);
    BOOL v23 = (const char *)IIOString::utf8String(v22);
    LogError("addAuxiliaryDataInfo", 4474, "*** ERROR: unsupported auxiliaryDataType: '%s'\n", v23);
    goto LABEL_62;
  }
  int v9 = 0;
  int v10 = 98;
LABEL_35:
  IIOImageDestination::swapWriterIfNeeded((IIO_Writer **)this, 0, 1);
  uint64_t v14 = *((void *)this + 8);
  if (!v14)
  {
    unsigned int v17 = "*** ERROR: depth/disparity is not supported on this platform\n";
    int v18 = 4406;
    goto LABEL_57;
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)v14 + 40))(v14) & 1) == 0)
  {
    BOOL v19 = (const void *)IIO_Writer::utType(*((IIO_Writer **)this + 8));
    uint64_t v20 = IIOString::IIOString((IIOString *)&v30, v19);
    CFTypeRef v21 = (const char *)IIOString::utf8String(v20);
    LogError("addAuxiliaryDataInfo", 4412, "*** ERROR: can't add depth/disparity to '%s'\n", v21);
LABEL_62:
    IIOString::~IIOString((IIOString *)&v30);
    return;
  }
  if (*((unsigned char *)this + 226))
  {
    if ((IIODictionary::containsKey((IIODictionary *)a3, @"kCGImageAuxiliaryDataInfoData") & 1) != 0
      || (IIODictionary::containsKey((IIODictionary *)a3, @"kCGImageAuxiliaryDataInfoImage") & 1) != 0
      || (IIODictionary::containsKey((IIODictionary *)a3, @"kCGImageAuxiliaryDataInfoPixelBuffer") & 1) != 0|| (IIODictionary::containsKey((IIODictionary *)a3, @"kCGImageAuxiliaryDataInfoIOSurface") & 1) != 0)
    {
      int v15 = 1;
    }
    else
    {
      LogError("addAuxiliaryDataInfo", 4432, "*** ERROR: 'auxiliaryDataInfoDictionary' is missing 'kCGImageAuxiliaryDataInfoData' key\n");
      int v15 = 0;
    }
    if ((IIODictionary::containsKey((IIODictionary *)a3, @"kCGImageAuxiliaryDataInfoDataDescription") & 1) == 0&& IIODictionary::containsKey((IIODictionary *)a3, @"kCGImageAuxiliaryDataInfoData"))
    {
      LogError("addAuxiliaryDataInfo", 4438, "*** ERROR: 'auxiliaryDataInfoDictionary' is missing 'kCGImageAuxiliaryDataInfoDataDescription' key\n");
      int v15 = 0;
    }
    if ((IIODictionary::containsKey((IIODictionary *)a3, @"kCGImageAuxiliaryDataInfoMetadata") & 1) == 0) {
      _cg_jpeg_mem_term("addAuxiliaryDataInfo", 4443, "*** 'auxiliaryDataInfoDictionary' is missing (optional) 'kCGImageAuxiliaryDataInfoMetadata' key\n");
    }
    if (v15)
    {
      CFMutableArrayRef Mutable = (__CFArray *)*((void *)this + 19);
      if (!Mutable)
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
        *((void *)this + 19) = Mutable;
      }
      CFMutableArrayRef v30 = 0;
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      IIOArray::IIOArray((IIOArray *)&v30, Mutable);
      uint64_t v27 = 0;
      CFMutableArrayRef v28 = 0;
      uint64_t v29 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v27);
      IIODictionary::setObjectForKey((IIODictionary *)&v27, a3[1], a2);
      IIONumber::IIONumber((IIONumber *)v26, *((_DWORD *)this + 14));
      IIODictionary::setObjectForKey((uint64_t)&v27, (uint64_t)v26, @"ImageIndex");
      IIONumber::~IIONumber((IIONumber *)v26);
      IIONumber::IIONumber((IIONumber *)v25, v10);
      IIODictionary::setObjectForKey((uint64_t)&v27, (uint64_t)v25, "AuxiliaryImageType");
      IIONumber::~IIONumber((IIONumber *)v25);
      IIONumber::IIONumber((IIONumber *)v24, v9);
      IIODictionary::setObjectForKey((uint64_t)&v27, (uint64_t)v24, "customMetadata");
      IIONumber::~IIONumber((IIONumber *)v24);
      if (v6) {
        IIODictionary::setObjectForKey((IIODictionary *)&v27, v6, "AuxiliaryImageURN");
      }
      IIOArray::addObject(&v30, v28);
      IIODictionary::~IIODictionary((IIODictionary *)&v27);
      IIOArray::~IIOArray((IIOArray *)&v30);
    }
    return;
  }
  unsigned int v17 = "*** ERROR: please add an image before calling CGImageDestinationAddAuxiliaryDataInfo\n";
  int v18 = 4419;
LABEL_57:

  LogError("addAuxiliaryDataInfo", v18, v17);
}

void sub_188771D0C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIOArray::~IIOArray((IIOArray *)(v2 - 88));
  _Unwind_Resume(a1);
}

uint64_t IIOImageDestination::createCreateSDRandISOGainMapFromHDR(IIOImageDestination *this, CGImageRef image, void **a3, CGImage **a4, IIODictionary *a5)
{
  CFTypeRef v22 = 0;
  CFDictionaryRef v23 = 0;
  CFTypeRef v21 = 0;
  if ((gIIODebugFlags & 0x300000) != 0) {
    ImageIOLog("  %s\n", "createCreateSDRandISOGainMapFromHDR");
  }
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
  if (CGColorSpaceUsesITUR_2100TF(ColorSpace) || CGColorSpaceUsesExtendedRange(ColorSpace))
  {
    if (CGImageGetImageProvider() && CGImageProviderGetCallbackVersion() >= 2)
    {
      uint64_t v18 = 0;
      BOOL v19 = 0;
      uint64_t v20 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v18);
      IIONumber::IIONumber((IIONumber *)v17, 2019963440);
      IIODictionary::setObjectForKey((uint64_t)&v18, (uint64_t)v17, @"kCGImageSurfaceFormatRequest");
      IIONumber::~IIONumber((IIONumber *)v17);
      IOSurfaceFromImage = (__IOSurface *)CGImageProviderCopyIOSurface();
      if (!IOSurfaceFromImage)
      {
        _cg_jpeg_mem_term("createCreateSDRandISOGainMapFromHDR", 2955, "*** ERROR: failed to get IOSurface from image (%p)\n", image);
        IIODictionary::~IIODictionary((IIODictionary *)&v18);
        return 4294967292;
      }
      IIODictionary::~IIODictionary((IIODictionary *)&v18);
    }
    else
    {
      IOSurfaceFromImage = IIO_CreateIOSurfaceFromImage(image, 0);
    }
    IIO_LoadHEIFSymbols();
    uint64_t v18 = 0;
    BOOL v19 = 0;
    uint64_t v20 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v18);
    int Width = IOSurfaceGetWidth(IOSurfaceFromImage);
    IIONumber::IIONumber((IIONumber *)v16, Width);
    IIODictionary::setObjectForKey((uint64_t)&v18, (uint64_t)v16, *(const void **)gIIO_kCVPixelBufferWidthKey);
    IIONumber::~IIONumber((IIONumber *)v16);
    int Height = IOSurfaceGetHeight(IOSurfaceFromImage);
    IIONumber::IIONumber((IIONumber *)v15, Height);
    IIODictionary::setObjectForKey((uint64_t)&v18, (uint64_t)v15, *(const void **)gIIO_kCVPixelBufferHeightKey);
    IIONumber::~IIONumber((IIONumber *)v15);
    OSType PixelFormat = IOSurfaceGetPixelFormat(IOSurfaceFromImage);
    IIONumber::IIONumber((IIONumber *)v14, PixelFormat);
    IIODictionary::setObjectForKey((uint64_t)&v18, (uint64_t)v14, *(const void **)gIIO_kCVPixelBufferPixelFormatTypeKey);
    IIONumber::~IIONumber((IIONumber *)v14);
    IIODictionary::setObjectForKey((IIODictionary *)&v18, ColorSpace, *(const __CFString **)gIIO_kCVImageBufferCGColorSpaceKey);
    uint64_t v12 = IIOCreatePixelBufferAttributesForHDRType(1, v19, a3[1], &v23);
    if (!v12) {
      IIO_CreateIOSurfaceWithPixelBufferAttributes(v23);
    }
    LogError("createCreateSDRandISOGainMapFromHDR", 2975, "*** ERROR: failed to create output pixel buffer attributes (%d)\n", v12);
    if (v21) {
      CFRelease(v21);
    }
    if (IOSurfaceFromImage) {
      CFRelease(IOSurfaceFromImage);
    }
    if (v23) {
      CFRelease(v23);
    }
    if (v22) {
      CFRelease(v22);
    }
    IIODictionary::~IIODictionary((IIODictionary *)&v18);
  }
  else
  {
    _cg_jpeg_mem_term("createCreateSDRandISOGainMapFromHDR", 2939, "*** ERROR: input image is not HDR\n");
    return 4294967246;
  }
  return v12;
}

void sub_18877250C(_Unwind_Exception *a1)
{
  IIONumber::~IIONumber((IIONumber *)(v1 - 176));
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 152));
  _Unwind_Resume(a1);
}

uint64_t IIOImageDestination::updatePreserveGainMapFlag(IIOImageDestination *this, IIOImageSource *a2, IIODictionary *a3)
{
  *((unsigned char *)this + 218) = -1;
  if (IIODictionary::containsKey(a3, @"kCGImageDestinationPreserveGainMap"))
  {
    BOOL BoolForKey = IIODictionary::getBoolForKey(a3, @"kCGImageDestinationPreserveGainMap");
    *((unsigned char *)this + 218) = 0;
    if (BoolForKey)
    {
      Properties = (IIODictionary *)IIOImageSource::getProperties(a2, 0);
      if (Properties)
      {
        CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(Properties, @"Images", @"{FileContents}");
        if (ObjectForKeyGroup)
        {
          CFArrayRef v9 = ObjectForKeyGroup;
          if (CFArrayGetCount(ObjectForKeyGroup))
          {
            CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v9, 0);
            if (ValueAtIndex)
            {
              CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(ValueAtIndex, @"AuxiliaryData");
              if (Value)
              {
                CFArrayRef v12 = Value;
                CFIndex Count = CFArrayGetCount(Value);
                if (Count < 1)
                {
LABEL_15:
                  char v19 = 0;
                }
                else
                {
                  CFIndex v14 = Count;
                  CFIndex v15 = 0;
                  while (1)
                  {
                    CFDictionaryRef v16 = (const __CFDictionary *)CFArrayGetValueAtIndex(v12, v15);
                    if (v16)
                    {
                      CFStringRef v17 = (const __CFString *)CFDictionaryGetValue(v16, @"AuxiliaryDataType");
                      if (v17)
                      {
                        CFStringRef v18 = v17;
                        if (CFEqual(v17, @"kCGImageAuxiliaryDataTypeHDRGainMap")
                          || CFEqual(v18, @"kCGImageAuxiliaryDataTypeISOGainMap"))
                        {
                          break;
                        }
                      }
                    }
                    if (v14 == ++v15) {
                      goto LABEL_15;
                    }
                  }
                  char v19 = 1;
                }
                *((unsigned char *)this + 218) = v19;
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

uint64_t IIOImageDestination::createImageFromSource(CGImageSourceRef *this, size_t a2, IIODictionary *a3, IIODictionary *a4, CGImage **a5)
{
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(a3, @"kCGImageSourceSubsampleFactor");
  BOOL BoolForKey = IIODictionary::getBoolForKey(a3, @"kCGImageSourceEnableRestrictedDecoding");
  unsigned int v11 = IIODictionary::getUint32ForKey(a3, @"kCGImageDestinationImageMaxPixelSize");
  uint64_t v28 = 0;
  CFDictionaryRef options = 0;
  uint64_t v30 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v28);
  IIODictionary::setObjectForKey((IIODictionary *)&v28, (const void *)*MEMORY[0x1E4F1CFC8], @"kCGImageSourceUseHardwareAcceleration");
  if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild()) {
    ImageIOLog("  UseHardwareAcceleration  | %s:%d\n", "createImageFromSource", 3257);
  }
  if (BoolForKey) {
    IIODictionary::setObjectForKey((IIODictionary *)&v28, (const void *)*MEMORY[0x1E4F1CFD0], @"kCGImageSourceEnableRestrictedDecoding");
  }
  if (!v11) {
    goto LABEL_33;
  }
  IIONumber::IIONumber((IIONumber *)v26, v11);
  IIODictionary::setObjectForKey((IIODictionary *)&v28, value, @"kCGImageDestinationImageMaxPixelSize");
  IIONumber::~IIONumber((IIONumber *)v26);
  ImageAtIndedouble x = CGImageSourceCreateImageAtIndex(this[20], a2, options);
  size_t Width = CGImageGetWidth(ImageAtIndex);
  size_t Height = CGImageGetHeight(ImageAtIndex);
  if (ImageAtIndex) {
    CFRelease(ImageAtIndex);
  }
  if (Width >= Height) {
    size_t v15 = Height;
  }
  else {
    size_t v15 = Width;
  }
  if (v11 < v15 >> 3)
  {
    unsigned int v16 = 8;
    goto LABEL_16;
  }
  if (v11 < v15 >> 2)
  {
    unsigned int v16 = 4;
LABEL_16:
    if (v16 > Uint32ForKey) {
      unsigned int Uint32ForKey = v16;
    }
    goto LABEL_26;
  }
  BOOL v17 = v11 >= v15 >> 1;
  if (v17) {
    unsigned int v18 = 0;
  }
  else {
    unsigned int v18 = 2;
  }
  if (v18 <= Uint32ForKey) {
    unsigned int v18 = Uint32ForKey;
  }
  if (!v17) {
    unsigned int Uint32ForKey = v18;
  }
LABEL_26:
  if (*((unsigned char *)this + 219) != 1
    || (uint64_t v19 = IIOImageSource::reader(*((IIOImageSource **)this[20] + 3)),
        !(*(unsigned int (**)(uint64_t))(*(void *)v19 + 208))(v19)))
  {
LABEL_33:
    if (Uint32ForKey)
    {
      IIONumber::IIONumber((IIONumber *)v26, Uint32ForKey);
      IIODictionary::setObjectForKey((IIODictionary *)&v28, value, @"kCGImageSourceSubsampleFactor");
      IIONumber::~IIONumber((IIONumber *)v26);
      CFDictionaryRef v22 = options;
    }
    else
    {
      CFDictionaryRef v22 = 0;
    }
    ThumbnailAtIndedouble x = CGImageSourceCreateImageAtIndex(this[20], a2, v22);
    goto LABEL_37;
  }
  IIODictionary::setObjectForKey((IIODictionary *)&v28, @"kCGImageSourceDecodeToHDR", @"kCGImageSourceDecodeRequest");
  if (Uint32ForKey)
  {
    IIONumber::IIONumber((IIONumber *)v26, Uint32ForKey);
    IIODictionary::setObjectForKey((IIODictionary *)&v28, value, @"kCGImageSourceSubsampleFactor");
    IIONumber::~IIONumber((IIONumber *)v26);
  }
  IIONumber::IIONumber((IIONumber *)v26, v11);
  IIODictionary::setObjectForKey((IIODictionary *)&v28, value, @"kCGImageSourceThumbnailMaxPixelSize");
  IIONumber::~IIONumber((IIONumber *)v26);
  IIODictionary::setObjectForKey((IIODictionary *)&v28, (const void *)*MEMORY[0x1E4F1CFD0], @"kCGImageSourceCreateThumbnailFromImageAlways");
  if (IIODictionary::containsKey(a3, @"kCGImageSourceCreateThumbnailWithTransform"))
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a3, @"kCGImageSourceCreateThumbnailWithTransform");
    IIODictionary::setObjectForKey((IIODictionary *)&v28, ObjectForKey, @"kCGImageSourceCreateThumbnailWithTransform");
    IIONumber::IIONumber((IIONumber *)v25, 1);
    IIODictionary::setObjectForKey((uint64_t)a4, (uint64_t)v25, @"Orientation");
    IIONumber::~IIONumber((IIONumber *)v25);
  }
  ThumbnailAtIndedouble x = CGImageSourceCreateThumbnailAtIndex(this[20], a2, options);
LABEL_37:
  *a5 = ThumbnailAtIndex;
  IIODictionary::~IIODictionary((IIODictionary *)&v28);
  return 0;
}

void sub_188772B04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

void IIOImageDestination::updateDateTime(IIOImageDestination *this, IIODictionary *a2, IIODictionary *a3)
{
  if (a2)
  {
    if (a3)
    {
      if (IIODictionary::containsKey(a2, @"{IPTC}"))
      {
        CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a3, @"DateTimeDigitized");
        if (ObjectForKey
          || (CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKeyGroup(a3, @"DateTimeDigitized", @"{Exif}")) != 0)
        {
          CFStringRef IPTCDateStringWithXMPDateTimeString = CreateIPTCDateStringWithXMPDateTimeString(ObjectForKey);
          CFStringRef IPTCTimeStringWithXMPDateTimeString = CreateIPTCTimeStringWithXMPDateTimeString(ObjectForKey);
          IIODictionary::setObjectForKeyGroup(a2, IPTCDateStringWithXMPDateTimeString, @"DateCreated", @"{IPTC}");
          IIODictionary::setObjectForKeyGroup(a2, IPTCDateStringWithXMPDateTimeString, @"DigitalCreationDate", @"{IPTC}");
          IIODictionary::setObjectForKeyGroup(a2, IPTCTimeStringWithXMPDateTimeString, @"TimeCreated", @"{IPTC}");
          IIODictionary::setObjectForKeyGroup(a2, IPTCTimeStringWithXMPDateTimeString, @"DigitalCreationTime", @"{IPTC}");
        }
      }
    }
  }
}

uint64_t IIOImageDestination::addImageFromSource(IIOImageDestination *this, CFTypeRef cf, unint64_t a3, IIODictionary *a4)
{
  if (*((void *)this + 2))
  {
    if (*((void *)this + 8))
    {
      if (a4)
      {
        if (*((unsigned char *)this + 225))
        {
          LogError("addImageFromSource", 3378, "*** ERROR: image destination was already finalized\n", a4);
        }
        else
        {
          if (!*((unsigned char *)this + 224))
          {
            *((void *)this + 20) = CFRetain(cf);
            uint64_t Source = (IIOImageSource *)CGImageSourceGetSource((uint64_t)cf);
            if ((gIIODebugFlags & 0x2000000000000) != 0) {
              IIODebugOrientation("addImageFromSource", 3384, a4);
            }
            if (IIODictionary::containsKey(a4, @"kCGImageDestinationImageMaxPixelSize")) {
              IIODictionary::getUint32ForKey(a4, @"kCGImageDestinationImageMaxPixelSize");
            }
            IIOImageDestination::updatePreserveGainMapFlag(this, Source, a4);
            if (*((unsigned char *)this + 218) == 1)
            {
              IIODictionary::removeObjectForKey(a4, @"kCGImageDestinationCreateHDRGainMap");
              IIODictionary::removeObjectForKey(a4, @"kCGImageSourceDecodeRequest");
            }
            IIOImageDestination::updateCreateHDRGainMapFlag(this, 0, a4);
            operator new();
          }
          LogError("addImageFromSource", 3379, "*** ERROR: CGImageDestinationAddImageFromSource call is not allowed for this image destination (destination was updated with CGImageDestinationCopyImageSource)\n", a4);
        }
      }
      else
      {
        LogError("addImageFromSource", 3377, "*** ERROR: image properties are NULL\n", 0);
      }
    }
    else
    {
      LogError("addImageFromSource", 3376, "*** ERROR: image destination format unknown\n", a4);
    }
  }
  else
  {
    LogError("addImageFromSource", 3375, "*** ERROR: cannot add image from source - invalid image destination\n", a4);
  }
  return 0;
}

void sub_188773314(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

void dictionaryApplier(const void *key, const __CFDictionary *a2, CFMutableDictionaryRef theDict)
{
  if (theDict)
  {
    if ((const __CFDictionary *)*MEMORY[0x1E4F1D260] == a2)
    {
      CFDictionaryRemoveValue(theDict, key);
    }
    else
    {
      CFArrayRef Value = (void *)CFDictionaryGetValue(theDict, key);
      if (Value
        && (v7 = Value, CFTypeID v8 = CFGetTypeID(Value), v8 == CFDictionaryGetTypeID())
        && (CFTypeID v9 = CFGetTypeID(a2), v9 == CFDictionaryGetTypeID()))
      {
        CFDictionaryApplyFunction(a2, (CFDictionaryApplierFunction)dictionaryApplier, v7);
      }
      else
      {
        CFDictionarySetValue(theDict, key, a2);
      }
    }
  }
}

void IIOImageDestination::preserveGainMapFromSource(IIOImageDestination *this, CGImageSourceRef isrc, size_t index, CFStringRef auxiliaryImageDataType, IIODictionary *a5, IIODictionary *a6)
{
  CFDictionaryRef v10 = CGImageSourceCopyAuxiliaryDataInfoAtIndex(isrc, index, auxiliaryImageDataType);
  if (v10)
  {
    CFDictionaryRef v11 = v10;
    size_t v65 = this;
    CFStringRef v66 = auxiliaryImageDataType;
    if (CFStringCompare(auxiliaryImageDataType, @"kCGImageAuxiliaryDataTypeHDRGainMap", 0)) {
      unsigned int v12 = 1179408416;
    }
    else {
      unsigned int v12 = 1294674720;
    }
    kdebug_trace();
    CFDataRef v13 = (const __CFData *)CFDictionaryGetValue(v11, @"kCGImageAuxiliaryDataInfoData");
    CFDictionaryRef v14 = (const __CFDictionary *)CFDictionaryGetValue(v11, @"kCGImageAuxiliaryDataInfoDataDescription");
    CFDictionaryRef cf = v11;
    size_t v15 = (void *)CFDictionaryGetValue(v11, @"kCGImageAuxiliaryDataInfoMetadata");
    memset(v79, 0, 24);
    int v67 = v14;
    IIODictionary::IIODictionary((IIODictionary *)v79, v14);
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(a5, @"PixelWidth");
    unsigned int v17 = IIODictionary::getUint32ForKey(a5, @"PixelHeight");
    unsigned int v68 = IIODictionary::getUint32ForKey(a5, @"Orientation");
    unsigned int v18 = IIODictionary::getUint32ForKey((IIODictionary *)v79, @"Width");
    unsigned int v19 = IIODictionary::getUint32ForKey((IIODictionary *)v79, @"Height");
    CFTypeRef value = v15;
    unsigned int v20 = IIODictionary::getUint32ForKey((IIODictionary *)v79, @"BytesPerRow");
    if (Uint32ForKey <= v17) {
      uint64_t v21 = v17;
    }
    else {
      uint64_t v21 = Uint32ForKey;
    }
    if (a6)
    {
      unsigned int v22 = IIODictionary::containsKey(a6, @"kCGImageDestinationImageMaxPixelSize");
      uint64_t v23 = v21;
      if (v22) {
        uint64_t v23 = IIODictionary::getUint32ForKey(a6, @"kCGImageDestinationImageMaxPixelSize");
      }
      BOOL v24 = v23 == v21;
      if (v68 == 1) {
        unsigned int v69 = 0;
      }
      else {
        unsigned int v69 = IIODictionary::containsKey(a6, @"kCGImageSourceCreateThumbnailWithTransform");
      }
    }
    else
    {
      unsigned int v69 = 0;
      BOOL v24 = 1;
    }
    int v25 = IIODictionary::getUint32ForKey((IIODictionary *)v79, @"PixelFormat");
    int v26 = v25;
    if (v25 == 1278226488)
    {
      BytePtr = CFDataGetBytePtr(v13);
      uint64_t v28 = (UInt8 *)BytePtr;
      if (v24)
      {
        uint64_t v29 = 0;
        LODWORD(v30) = v18;
        LODWORD(v31) = v19;
        unsigned int v32 = v20;
        int v33 = (void *)BytePtr;
      }
      else
      {
        unsigned int v43 = IIODictionary::getUint32ForKey(a6, @"kCGImageDestinationImageMaxPixelSize");
        double v44 = (double)v43 / (double)v17;
        if ((double)v43 / (double)Uint32ForKey < v44) {
          double v44 = (double)v43 / (double)Uint32ForKey;
        }
        vImagePixelCount v30 = (v44 * (double)Uint32ForKey) >> 1;
        vImagePixelCount v31 = (v44 * (double)v17) >> 1;
        unsigned int v32 = (v30 + 15) & 0xFFFFFFF0;
        int v33 = malloc_type_malloc(v32 * v31, 0xA439E897uLL);
        src.data = v28;
        src.double height = v19;
        src.double width = v18;
        src.size_t rowBytes = v20;
        dest.data = v33;
        dest.double height = v31;
        dest.double width = v30;
        dest.size_t rowBytes = v32;
        vImage_Error v45 = vImageScale_Planar8(&src, &dest, 0, 0x20u);
        if (v45) {
          _cg_jpeg_mem_term("preserveGainMapFromSource", 3651, "*** ERROR: vImageScale_Planar8 failed: %ld\n", v45);
        }
        uint64_t v29 = v33;
      }
      if (v69)
      {
        long long v63 = v29;
        if (v68 <= 4) {
          vImagePixelCount v46 = v30;
        }
        else {
          vImagePixelCount v46 = v31;
        }
        if (v68 <= 4) {
          vImagePixelCount v47 = v31;
        }
        else {
          vImagePixelCount v47 = v30;
        }
        unsigned int v48 = (v46 + 15) & 0xFFFFFFF0;
        uint64_t v49 = malloc_type_malloc(v48 * v47, 0x5E9AAA77uLL);
        src.data = v33;
        src.double height = v31;
        src.double width = v30;
        src.size_t rowBytes = v32;
        dest.data = v49;
        dest.double height = v47;
        dest.double width = v46;
        dest.size_t rowBytes = v48;
        uint8_t v50 = 2;
        switch(v68)
        {
          case 2u:
            vImageHorizontalReflect_Planar8(&src, &dest, 0x10u);
            int v33 = v49;
            break;
          case 3u:
            goto LABEL_76;
          case 4u:
            vImageVerticalReflect_Planar8(&src, &dest, 0x10u);
            int v33 = v49;
            break;
          case 5u:
            unint64_t v60 = malloc_type_malloc(v48 * v47, 0x6F209E3CuLL);
            v76.data = v60;
            v76.double height = v47;
            v76.double width = v46;
            v76.size_t rowBytes = (v46 + 15) & 0xFFFFFFF0;
            vImageRotate90_Planar8(&src, &v76, 3u, 0, 0x10u);
            vImageHorizontalReflect_Planar8(&v76, &dest, 0x10u);
            goto LABEL_74;
          case 6u:
            uint8_t v50 = 3;
            goto LABEL_76;
          case 7u:
            unint64_t v60 = malloc_type_malloc(v48 * v47, 0x1C5E7518uLL);
            v76.data = v60;
            v76.double height = v47;
            v76.double width = v46;
            v76.size_t rowBytes = (v46 + 15) & 0xFFFFFFF0;
            vImageRotate90_Planar8(&src, &v76, 1u, 0, 0x10u);
            vImageHorizontalReflect_Planar8(&v76, &dest, 0x10u);
LABEL_74:
            free(v60);
            int v33 = v49;
            break;
          case 8u:
            uint8_t v50 = 1;
LABEL_76:
            vImageRotate90_Planar8(&src, &dest, v50, 0, 0x10u);
            int v33 = v49;
            break;
          default:
            break;
        }
        LODWORD(v30) = v46;
        LODWORD(v31) = v47;
        unsigned int v32 = (v46 + 15) & 0xFFFFFFF0;
        uint64_t v29 = v63;
      }
      else
      {
        uint64_t v49 = 0;
      }
      memset(&src, 0, 24);
      IIODictionary::IIODictionary((IIODictionary *)&src, v67);
      if ((!v24 | v69) == 1)
      {
        IIONumber::IIONumber((IIONumber *)v75, v30);
        IIODictionary::setObjectForKey((uint64_t)&src, (uint64_t)v75, @"Width");
        IIONumber::~IIONumber((IIONumber *)v75);
        IIONumber::IIONumber((IIONumber *)v74, v31);
        IIODictionary::setObjectForKey((uint64_t)&src, (uint64_t)v74, @"Height");
        IIONumber::~IIONumber((IIONumber *)v74);
        IIONumber::IIONumber((IIONumber *)v73, v32);
        IIODictionary::setObjectForKey((uint64_t)&src, (uint64_t)v73, @"BytesPerRow");
        IIONumber::~IIONumber((IIONumber *)v73);
        IIONumber::IIONumber((IIONumber *)v72, 1278226488);
        IIODictionary::setObjectForKey((uint64_t)&src, (uint64_t)v72, @"PixelFormat");
        IIONumber::~IIONumber((IIONumber *)v72);
      }
      CFDataRef v61 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v33, v32 * v31);
      if (v61)
      {
        memset(&dest, 0, 24);
        IIODictionary::IIODictionary((IIODictionary *)&dest);
        IIODictionary::setObjectForKey(v62, (const void *)src.height, @"kCGImageAuxiliaryDataInfoDataDescription");
        IIODictionary::setObjectForKey((IIODictionary *)&dest, value, @"kCGImageAuxiliaryDataInfoMetadata");
        IIODictionary::setObjectForKey((IIODictionary *)&dest, v61, @"kCGImageAuxiliaryDataInfoData");
        IIOImageDestination::addAuxiliaryDataInfo(v65, v66, (const void **)&dest.data);
        CFRelease(v61);
        IIODictionary::~IIODictionary((IIODictionary *)&dest);
      }
      if (v29) {
        free(v29);
      }
      if (v49) {
        free(v49);
      }
      IIODictionary::~IIODictionary((IIODictionary *)&src);
    }
    else
    {
      uint64_t v34 = MEMORY[0x1E4F14390];
      uint64_t v35 = MEMORY[0x1E4F14390] + 60;
      if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 60 + 4 * HIBYTE(v12)) & 0x40000) != 0) {
        uint64_t v36 = HIBYTE(v12);
      }
      else {
        uint64_t v36 = 46;
      }
      LODWORD(v37) = HIWORD(v12) & 0x6F;
      if ((*(_DWORD *)(v35 + 4 * v37) & 0x40000) != 0) {
        uint64_t v37 = v37;
      }
      else {
        uint64_t v37 = 46;
      }
      uint64_t v70 = v37;
      unsigned int v38 = (v12 >> 8) & 0x7B;
      if ((*(_DWORD *)(v35 + 4 * v38) & 0x40000) != 0) {
        uint64_t v39 = v38;
      }
      else {
        uint64_t v39 = 46;
      }
      if ((*(unsigned char *)(MEMORY[0x1E4F14390] + 190) & 4) != 0) {
        uint64_t v40 = 32;
      }
      else {
        uint64_t v40 = 46;
      }
      unsigned int v41 = v25 >> 24;
      if (v25 < 0) {
        int v42 = __maskrune(v25 >> 24, 0x40000uLL);
      }
      else {
        int v42 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v41 + 60) & 0x40000;
      }
      if (v42) {
        uint64_t v51 = v41;
      }
      else {
        uint64_t v51 = 46;
      }
      unsigned int v52 = v26 << 8 >> 24;
      if (v26 << 8 < 0) {
        int v53 = __maskrune(v26 << 8 >> 24, 0x40000uLL);
      }
      else {
        int v53 = *(_DWORD *)(v34 + 4 * v52 + 60) & 0x40000;
      }
      if (v53) {
        uint64_t v54 = v52;
      }
      else {
        uint64_t v54 = 46;
      }
      unsigned int v55 = (__int16)v26 >> 8;
      if (v26 << 16 < 0) {
        int v56 = __maskrune((__int16)v26 >> 8, 0x40000uLL);
      }
      else {
        int v56 = *(_DWORD *)(v34 + 4 * v55 + 60) & 0x40000;
      }
      if ((v26 << 24) <= 0x7F000000) {
        int v57 = *(_DWORD *)(v34 + 4 * (char)v26 + 60) & 0x40000;
      }
      else {
        int v57 = __maskrune((char)v26, 0x40000uLL);
      }
      if (v56) {
        uint64_t v58 = v55;
      }
      else {
        uint64_t v58 = 46;
      }
      if (v57) {
        uint64_t v59 = (char)v26;
      }
      else {
        uint64_t v59 = 46;
      }
      _cg_jpeg_mem_term("preserveGainMapFromSource", 3752, "*** ERROR: preserveGainMapFromSource for '%c%c%c%c' - unhandled pixelformat: '%c%c%c%c'\n", v36, v70, v39, v40, v51, v54, v58, v59);
    }
    CFRelease(cf);
    IIODictionary::~IIODictionary((IIODictionary *)v79);
  }
}

void sub_188773C10(_Unwind_Exception *a1)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 112));
  _Unwind_Resume(a1);
}

uint64_t IIOImageDestination::addImageAndMetadata(IIOImageDestination *this, CGImage *a2, const CGImageMetadata *a3, IIODictionary *a4)
{
  if (*((void *)this + 2))
  {
    if (*((unsigned char *)this + 225))
    {
      LogError("addImageAndMetadata", 3768, "*** ERROR: image destination was already finalized\n", a4);
    }
    else
    {
      if (!*((unsigned char *)this + 224)) {
        operator new();
      }
      LogError("addImageAndMetadata", 3769, "*** ERROR: CGImageDestinationAddImageAndMetadata call is not allowed for this image destination (destination was updated with CGImageDestinationCopyImageSource)\n", a4);
    }
  }
  else
  {
    LogError("addImageAndMetadata", 3767, "*** ERROR: cannot add image and metadata - invalid image destination\n", a4);
  }
  return 4294967246;
}

void sub_188773E94(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

uint64_t IIOImageDestination::finalizeUsingPixelProvider(IIOImageDestination *this)
{
  *((unsigned char *)this + 216) = 0;
  IIOImageWriteSession::seek(*((IIOImageWriteSession **)this + 3), 0, 0);
  uint64_t v2 = (CGImageSource *)*((void *)this + 20);
  if (v2) {
    *((void *)this + 21) = CGImageSourceCreateImageAtIndex(v2, 0, 0);
  }
  ImagePropertiesAtIndedouble x = (IIOImageDestination *)IIOImageDestination::getImagePropertiesAtIndex(this, 0);
  if (!ImagePropertiesAtIndex)
  {
    int v13 = 0;
    size_t v15 = (CGImageRef *)((char *)this + 168);
    CFDictionaryRef v14 = (CGImage *)*((void *)this + 21);
    unint64_t v16 = *((void *)this + 23);
    goto LABEL_26;
  }
  uint64_t v5 = ImagePropertiesAtIndex;
  int OptimizeForSharing = IIOImageDestination::GetOptimizeForSharing(ImagePropertiesAtIndex, 0, v4);
  BOOL BoolForKey = IIODictionary::getBoolForKey(v5, @"kCGImageSourceCreateThumbnailWithTransform");
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFTypeID v8 = "off";
    if (OptimizeForSharing) {
      CFTypeID v8 = "on";
    }
    ImageIOLog("COL finalizing image [%p] with optimizeColorForSharing turned %s\n", *((const void **)this + 21), v8);
  }
  if (BoolForKey)
  {
    unsigned int v9 = IIOGetExifOrientation(v5, 0);
    BOOL v10 = v9 > 1;
    if (v9 <= 1) {
      unsigned int v11 = 1;
    }
    else {
      unsigned int v11 = v9;
    }
    if ((gIIODebugFlags & 0x2000000000000) != 0)
    {
      unsigned int v12 = "NO";
      if (v9 > 1) {
        unsigned int v12 = "YES";
      }
      ImageIOLog("%s finalize: bakeInOrientation-%s:  %d\n", "-o- ", v12, v11);
      if ((gIIODebugFlags & 0x2000000000000) != 0)
      {
        IIODebugOrientation("finalizeUsingPixelProvider", 3845, v5);
        if ((OptimizeForSharing & 1) == 0) {
          goto LABEL_17;
        }
        goto LABEL_22;
      }
    }
  }
  else
  {
    BOOL v10 = 0;
    unsigned int v11 = 1;
  }
  if (OptimizeForSharing)
  {
LABEL_22:
    size_t v15 = (CGImageRef *)((char *)this + 168);
    CFDictionaryRef v14 = (CGImage *)*((void *)this + 21);
    unint64_t v16 = *((void *)this + 23);
    int v13 = 2;
    if (v10) {
      goto LABEL_23;
    }
LABEL_26:
    ThumbNew = CGImageCreateThumbNew(v14, v16, 0, -1, v13);
    if (!ThumbNew) {
      ThumbNew = CGImageRetain(*v15);
    }
    unsigned int v17 = ThumbNew;
    goto LABEL_29;
  }
LABEL_17:
  int v13 = 0;
  size_t v15 = (CGImageRef *)((char *)this + 168);
  CFDictionaryRef v14 = (CGImage *)*((void *)this + 21);
  unint64_t v16 = *((void *)this + 23);
  if (!v10) {
    goto LABEL_26;
  }
LABEL_23:
  unsigned int v17 = CGImageCreateThumbNew(v14, v16, v11, -1, v13);
  if (v17)
  {
    IIODictionary::removeObjectForKey(v5, @"Orientation");
    CFStringRef ObjectForKey = IIODictionary::getObjectForKey(v5, @"{TIFF}");
    if (ObjectForKey) {
      CFDictionaryRemoveValue(ObjectForKey, @"Orientation");
    }
  }
LABEL_29:
  uint64_t v20 = HEIFAuxImage::auxiliaryPixelFormat(*((HEIFAuxImage **)this + 8));
  PixelDataProviderConforming = (const void *)IIOImageDestination::createPixelDataProviderConforming((uint64_t)this, v17, 1, 0, 0, v20, 0);
  if (PixelDataProviderConforming)
  {
    unsigned int v22 = PixelDataProviderConforming;
    IIOImageDestination::setPixelProviderAtIndex((uint64_t)this, PixelDataProviderConforming, 0);
    CFRelease(v22);
  }
  else
  {
    _cg_jpeg_mem_term("finalizeUsingPixelProvider", 3874, "*** createPixelDataProviderConforming failed (nil)\n");
  }
  CGImageRelease(v17);
  if (*v15)
  {
    CGImageRelease(*v15);
    *size_t v15 = 0;
  }
  return 0;
}

uint64_t IIOImageDestination::finalizeUsingAppleJPEGRecode(IIOImageDestination *this)
{
  uint64_t Source = (IIOImageDestination *)CGImageSourceGetSource(*((void *)this + 20));
  if ((gIIODebugFlags & 0xC) != 0) {
    double Current = CFAbsoluteTimeGetCurrent();
  }
  else {
    double Current = 0.0;
  }
  kdebug_trace();
  int v5 = AppleJPEGReadPlugin::IIORecodeAppleJPEG_to_JPEG(this, Source, v4);
  kdebug_trace();
  if (v5)
  {
    if ((gIIODebugFlags & 0xC) != 0)
    {
      CFAbsoluteTime v6 = CFAbsoluteTimeGetCurrent();
      ImageIOLog("    'jpeg' RecodeAppleJPEG  \ttime: %g ms\n", (v6 - Current) * 1000.0);
    }
    return 0;
  }
  else
  {
    uint64_t v7 = 4294967246;
    LogWarning("finalizeUsingAppleJPEGRecode", 3922, "*** NOTE: CGImageDestinationRecodeJPEG failed [%d] - falling back to full transcode\n", -50);
  }
  return v7;
}

uint64_t IIOImageDestination::finalizeUsingHEIFRecode(IIOImageDestination *this)
{
  uint64_t Source = (IIOImageDestination *)CGImageSourceGetSource(*((void *)this + 20));
  kdebug_trace();
  uint64_t v3 = HEIFReadPlugin::IIORecodeHEIF_to_JPEG(this, Source, (IIOImageSource *)*((unsigned int *)this + 49));
  kdebug_trace();
  if (v3)
  {
    if (v3 == -15470) {
      LogError("finalizeUsingHEIFRecode", 3949, "*** ERROR: media server is NOT running [kCMPhotoError_XPCError / -15470]\n");
    }
    else {
      _cg_jpeg_mem_term("finalizeUsingHEIFRecode", 3957, "*** NOTE: CMPhotoDecompressionContainerJFIFTranscode failed [0x%08X] - falling back to full transcode\n", v3);
    }
  }
  return v3;
}

CGColorSpaceRef IIOImageDestination::getResizeSourceColorSpace(IIOImageDestination *this)
{
  uint64_t v2 = (CGImage *)*((void *)this + 21);
  if (v2)
  {
    return CGImageGetColorSpace(v2);
  }
  else
  {
    uint64_t Source = (IIOImageSource *)CGImageSourceGetSource(*((void *)this + 20));
    if (Source && (ImagePlus = (IIOImagePlus *)IIOImageSource::getImagePlus(Source, 0)) != 0)
    {
      return (CGColorSpaceRef)IIOImagePlus::getSourceGeomColorSpace(ImagePlus);
    }
    else
    {
      return 0;
    }
  }
}

uint64_t IIOImageDestination::getSourceImageAtIndex(IIOImageDestination *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 13);
  unint64_t v3 = (*((void *)this + 14) - v2) >> 3;
  if (v3 > a2) {
    return *(void *)(v2 + 8 * a2);
  }
  _cg_jpeg_mem_term("getSourceImageAtIndex", 4184, "getSourceImageAtIndex index (%d) larger than vector size (%d)\n", a2, v3);
  return 0;
}

CFTypeID CGImageDestinationGetTypeID(void)
{
  if (CGImageDestinationGetTypeID::once != -1) {
    dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_25);
  }
  return CGImageDestinationGetTypeID::id;
}

CFStringRef _CGImageDestinationCopyDescription(void *a1)
{
  if (a1)
  {
    uint64_t v2 = a1[3];
    if (v2)
    {
      unint64_t v3 = *(IIO_Writer **)(v2 + 64);
      if (v3)
      {
        uint64_t v4 = IIO_Writer::utType(v3);
        if (v4) {
          return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CGImageDestination: %p> %p '%@'", a1, v2, v4);
        }
      }
    }
  }
  else
  {
    uint64_t v2 = 0;
  }
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CGImageDestination: %p> %p", a1, v2);
}

CFMutableArrayRef CGImageDestinationCopyImageFormats(const __CFString *a1)
{
  kdebug_trace();
  IIOInitDebugFlags();
  uint64_t v2 = (IIO_WriterHandler *)((unsigned __int16)gIIODebugFlags >> 14);
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((int)v2, "S", "CGImageDestinationCopyImageFormats", 0, 0, -1, 0);
  }
  WriterHandler = (IIO_WriterHandler *)IIO_WriterHandler::GetWriterHandler(v2);
  CFMutableArrayRef v4 = IIO_WriterHandler::copyImageFormats(WriterHandler, a1);
  kdebug_trace();
  return v4;
}

CGImageDestinationRef CGImageDestinationCreateWithDataConsumer(CGDataConsumerRef consumer, CFStringRef type, size_t count, CFDictionaryRef options)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  IIOInitDebugFlags();
  if (consumer)
  {
    if (type)
    {
      if (!count) {
        LogError("CGImageDestinationCreateWithDataConsumer", 4809, "*** ERROR: CGImageDestinationCreateWithDataConsumer: invalid capacity (%zu)\n", 0);
      }
      CFTypeID v8 = CFGetTypeID(consumer);
      if (v8 == CGDataConsumerGetTypeID())
      {
        CFTypeID v9 = CFGetTypeID(type);
        if (v9 == CFStringGetTypeID())
        {
          if (options)
          {
            CFTypeID v10 = CFGetTypeID(options);
            if (v10 != CFDictionaryGetTypeID())
            {
              LogError("CGImageDestinationCreateWithDataConsumer", 4814, "*** ERROR: CGImageDestinationCreateWithDataConsumer: options parameter is not a CFDictionaryRef - ignoring\n");
              CFDictionaryRef options = 0;
            }
          }
          if ((gIIODebugFlags & 0x3000) != 0)
          {
            long long v18 = 0u;
            long long v19 = 0u;
            *(_OWORD *)buffer = 0u;
            long long v17 = 0u;
            CFStringGetCString(type, buffer, 64, 0x600u);
            unsigned int v11 = (gIIODebugFlags >> 12) & 3;
            if (v11) {
              ImageIODebugOptions(v11, "A", "CGImageDestinationCreateWithDataConsumer", 0, buffer, -1, options);
            }
          }
          memset(buffer, 0, sizeof(buffer));
          *(void *)&long long v17 = 0;
          unsigned int v12 = IIODictionary::IIODictionary((IIODictionary *)buffer, options);
          WriterHandler = (IIO_WriterHandler *)IIO_WriterHandler::GetWriterHandler(v12);
          if (IIO_WriterHandler::findWriterForType(WriterHandler, type, (const __CFString *)count, (IIODictionary *)buffer, v14))
          {
            operator new();
          }
          IIODictionary::~IIODictionary((IIODictionary *)buffer);
          LogError("CGImageDestinationCreateWithDataConsumer", 4830, "*** ERROR: CGImageDestinationCreateWithDataConsumer: failed to create 'CGImageDestinationRef'\n");
        }
        else
        {
          LogError("CGImageDestinationCreateWithDataConsumer", 4811, "*** ERROR: CGImageDestinationCreateWithDataConsumer: type is not a CFStringRef\n");
        }
      }
      else
      {
        LogError("CGImageDestinationCreateWithDataConsumer", 4810, "*** ERROR: CGImageDestinationCreateWithDataConsumer: dataConsumer is not a CGDataConsumerRef\n");
      }
    }
    else
    {
      LogError("CGImageDestinationCreateWithDataConsumer", 4807, "*** ERROR: CGImageDestinationCreateWithDataConsumer: type is nil\n");
    }
  }
  else
  {
    LogError("CGImageDestinationCreateWithDataConsumer", 4806, "*** ERROR: CGImageDestinationCreateWithDataConsumer: dataConsumer is nil\n");
  }
  if ((gIIODebugFlags & 0x800000000000) != 0) {
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "CGImageDestinationCreateWithDataConsumer", 4833, "could not create CGImageDestinationRef");
  }
  kdebug_trace();
  kdebug_trace();
  return 0;
}

void sub_188774900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  MEMORY[0x18C11C0E0](v5, 0x10E1C40255C1624);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImageDestinationSetProperties(CGImageDestinationRef idst, CFDictionaryRef properties)
{
  kdebug_trace();
  unsigned int v4 = (gIIODebugFlags >> 12) & 3;
  if (v4) {
    ImageIODebugOptions(v4, "A", "CGImageDestinationSetProperties", idst, 0, -1, properties);
  }
  if (idst)
  {
    CFTypeID v5 = CFGetTypeID(idst);
    if (CGImageDestinationGetTypeID::once != -1) {
      dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_25);
    }
    if (v5 == CGImageDestinationGetTypeID::id)
    {
      if (properties)
      {
        CFTypeID v6 = CFGetTypeID(properties);
        if (v6 != CFDictionaryGetTypeID())
        {
          LogError("CGImageDestinationSetProperties", 4957, "*** ERROR: CGImageDestinationSetProperties: properties parameter is not a CFDictionaryRef - ignoring\n");
          properties = 0;
        }
      }
      uint64_t v7 = (IIOImageDestination *)*((void *)idst + 3);
      if (v7)
      {
        memset(v9, 0, sizeof(v9));
        IIODictionary::IIODictionary((IIODictionary *)v9, properties);
        IIOImageDestination::setProperties(v7, (IIODictionary *)v9);
        CFTypeID v8 = (IIO_Reader *)*((void *)v7 + 8);
        if (v8) {
          IIO_Reader::osType(v8);
        }
        IIODictionary::~IIODictionary((IIODictionary *)v9);
      }
    }
    else
    {
      LogError("CGImageDestinationSetProperties", 4954, "*** ERROR: CGImageDestinationSetProperties: type is not a CGImageDestinationRef\n");
    }
  }
  else
  {
    LogError("CGImageDestinationSetProperties", 4953, "*** ERROR: CGImageDestinationSetProperties: destination is nil\n");
  }
  kdebug_trace();
}

void sub_188774AE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImageDestinationAddImageAndMetadata(CGImageDestinationRef idst, CGImageRef image, CGImageMetadataRef metadata, CFDictionaryRef options)
{
  memset(v18, 0, sizeof(v18));
  IIODictionary::IIODictionary((IIODictionary *)v18, options);
  if (image)
  {
    CGImageGetWidth(image);
    CGImageGetHeight(image);
  }
  IIOPackDstInputInfo((IIODictionary *)v18);
  if (image)
  {
    CGImageGetBitsPerPixel(image);
    CGImageGetBitsPerComponent(image);
    CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
    CGColorSpaceGetModel(ColorSpace);
    CGImageGetImageProvider();
    CGImageGetContentHeadroom();
    CGImageGetBitmapInfo(image);
  }
  kdebug_trace();
  unsigned int v9 = (gIIODebugFlags >> 12) & 3;
  if (v9) {
    ImageIODebugOptions(v9, "A", "CGImageDestinationAddImageAndMetadata", idst, 0, -1, options);
  }
  if (idst) {
    int v10 = 5165;
  }
  else {
    int v10 = 5164;
  }
  if (idst) {
    unsigned int v11 = "*** ERROR: CGImageDestinationAddImageAndMetadata: image is nil\n";
  }
  else {
    unsigned int v11 = "*** ERROR: CGImageDestinationAddImageAndMetadata: destination is nil\n";
  }
  if (!idst || !image) {
    goto LABEL_31;
  }
  CFTypeID v12 = CFGetTypeID(idst);
  if (CGImageDestinationGetTypeID::once != -1) {
    dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_25);
  }
  if (v12 != CGImageDestinationGetTypeID::id)
  {
    LogError("CGImageDestinationAddImageAndMetadata", 5166, "*** ERROR: CGImageDestinationAddImageAndMetadata: destination is not a CGImageDestinationRef\n");
    goto LABEL_32;
  }
  CFTypeID v13 = CFGetTypeID(image);
  if (v13 != CGImageGetTypeID())
  {
    unsigned int v11 = "*** ERROR: CGImageDestinationAddImageAndMetadata: image is not a CGImageRef\n";
    int v10 = 5167;
LABEL_31:
    LogError("CGImageDestinationAddImageAndMetadata", v10, v11);
    goto LABEL_32;
  }
  if (metadata)
  {
    CFTypeID v14 = CFGetTypeID(metadata);
    if (v14 != CGImageMetadataGetTypeID())
    {
      LogError("CGImageDestinationAddImageAndMetadata", 5170, "*** ERROR: CGImageDestinationAddImageAndMetadata: metadata parameter is not a CGImageMetadataRef - ignoring\n");
      metadata = 0;
    }
  }
  if (options)
  {
    CFTypeID v15 = CFGetTypeID(options);
    if (v15 != CFDictionaryGetTypeID()) {
      LogError("CGImageDestinationAddImageAndMetadata", 5175, "*** ERROR: CGImageDestinationAddImageAndMetadata: options parameter is not a CFDictionaryRef - ignoring\n");
    }
  }
  uint64_t v16 = *((void *)idst + 3);
  if (v16)
  {
    IIOImageDestination::addImageAndMetadata(*((IIOImageDestination **)idst + 3), image, metadata, (IIODictionary *)v18);
    long long v17 = *(IIO_Reader **)(v16 + 64);
    if (v17) {
      IIO_Reader::osType(v17);
    }
  }
LABEL_32:
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v18);
}

void sub_188774DEC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

BOOL CGImageDestinationCopyImageSource(CGImageDestinationRef idst, CGImageSourceRef isrc, CFDictionaryRef options, CFErrorRef *err)
{
  CFDictionaryRef v5 = options;
  memset(v16, 0, sizeof(v16));
  IIODictionary::IIODictionary((IIODictionary *)v16, options);
  IIOPackDstInputInfo((IIODictionary *)v16);
  kdebug_trace();
  IIOInitDebugFlags();
  unsigned int v8 = (gIIODebugFlags >> 12) & 3;
  if (v8) {
    ImageIODebugOptions(v8, "A", "CGImageDestinationCopyImageSource", idst, 0, -1, v5);
  }
  if (!idst)
  {
    IIOLogAndCreateError(err, (const __CFString *)*MEMORY[0x1E4F1D158], -50, "CGImageDestinationCopyImageSource", 5209, "CGImageDestinationCopyImageSource: destination is nil\n");
LABEL_20:
    BOOL v13 = 0;
    goto LABEL_21;
  }
  if (!isrc)
  {
    IIOLogAndCreateError(err, (const __CFString *)*MEMORY[0x1E4F1D158], -50, "CGImageDestinationCopyImageSource", 5210, "CGImageDestinationCopyImageSource: source is nil\n");
    goto LABEL_20;
  }
  CFTypeID v9 = CFGetTypeID(idst);
  if (CGImageDestinationGetTypeID::once != -1) {
    dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_25);
  }
  if (v9 != CGImageDestinationGetTypeID::id)
  {
    IIOLogAndCreateError(err, (const __CFString *)*MEMORY[0x1E4F1D158], -50, "CGImageDestinationCopyImageSource", 5211, "*** ERROR: CGImageDestinationCopyImageSource: destination is not a CGImageDestinationRef\n");
    goto LABEL_20;
  }
  CFTypeID v10 = CFGetTypeID(isrc);
  if (v10 != CGImageSourceGetTypeID())
  {
    IIOLogAndCreateError(err, (const __CFString *)*MEMORY[0x1E4F1D158], -50, "CGImageDestinationCopyImageSource", 5212, "*** ERROR: CGImageDestinationCopyImageSource: source is not a CGImageSourceRef\n");
    goto LABEL_20;
  }
  if (v5)
  {
    CFTypeID v11 = CFGetTypeID(v5);
    if (v11 != CFDictionaryGetTypeID())
    {
      LogError("CGImageDestinationCopyImageSource", 5215, "*** ERROR: CGImageDestinationCopyImageSource: options parameter is not a CFDictionaryRef - ignoring\n");
      CFDictionaryRef v5 = 0;
    }
  }
  uint64_t v12 = *((void *)idst + 3);
  if (!v12) {
    goto LABEL_20;
  }
  BOOL v13 = IIOImageDestination::copyImageSource(*((CFStringRef **)idst + 3), isrc, (IIODictionary *)v16, v5 != 0, err);
  CFTypeID v14 = *(IIO_Reader **)(v12 + 64);
  if (v14) {
    IIO_Reader::osType(v14);
  }
LABEL_21:
  if ((gIIODebugFlags & 0x800000000000) != 0 && !v13) {
    ImageIOLog(" ISSUE: %s:%d:  %s\n", "CGImageDestinationCopyImageSource", 5229, "could not copy from imageSource");
  }
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v16);
  return v13;
}

void sub_188775054(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImageDestinationAddAuxiliaryDataInfo(CGImageDestinationRef idst, CFStringRef auxiliaryImageDataType, CFDictionaryRef auxiliaryDataInfoDictionary)
{
  IIOInitDebugFlags();
  if (auxiliaryImageDataType
    && CFStringCompare(auxiliaryImageDataType, @"kCGImageAuxiliaryDataTypeHDRGainMap", 0))
  {
    CFStringCompare(auxiliaryImageDataType, @"kCGImageAuxiliaryDataTypeISOGainMap", 0);
  }
  kdebug_trace();
  if ((gIIODebugFlags & 0x3000) != 0)
  {
    BOOL v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    IIOString::IIOString((IIOString *)&v13, auxiliaryImageDataType);
    unsigned int v6 = (gIIODebugFlags >> 12) & 3;
    if (v6)
    {
      uint64_t v7 = (const char *)IIOString::utf8String((IIOString *)&v13);
      ImageIODebugOptions(v6, "A", "CGImageDestinationAddAuxiliaryDataInfo", idst, v7, -1, 0);
    }
    IIOString::~IIOString((IIOString *)&v13);
  }
  if (idst)
  {
    if (auxiliaryImageDataType)
    {
      if (auxiliaryDataInfoDictionary)
      {
        CFTypeID v8 = CFGetTypeID(idst);
        if (CGImageDestinationGetTypeID::once != -1) {
          dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_25);
        }
        if (v8 == CGImageDestinationGetTypeID::id)
        {
          CFTypeID v9 = CFGetTypeID(auxiliaryImageDataType);
          if (v9 == CFStringGetTypeID())
          {
            CFTypeID v10 = CFGetTypeID(auxiliaryDataInfoDictionary);
            if (v10 == CFDictionaryGetTypeID())
            {
              CFTypeID v11 = (IIOImageDestination *)*((void *)idst + 3);
              if (v11)
              {
                BOOL v13 = 0;
                uint64_t v14 = 0;
                uint64_t v15 = 0;
                IIODictionary::IIODictionary((IIODictionary *)&v13, auxiliaryDataInfoDictionary);
                IIOImageDestination::addAuxiliaryDataInfo(v11, auxiliaryImageDataType, &v13);
                uint64_t v12 = (IIO_Reader *)*((void *)v11 + 8);
                if (v12) {
                  IIO_Reader::osType(v12);
                }
                IIODictionary::~IIODictionary((IIODictionary *)&v13);
              }
            }
            else
            {
              LogError("CGImageDestinationAddAuxiliaryDataInfo", 5279, "*** ERROR: CGImageDestinationAddAuxiliaryDataInfo: auxiliaryDataInfoDictionary is not a CFDictionaryRef\n");
            }
          }
          else
          {
            LogError("CGImageDestinationAddAuxiliaryDataInfo", 5278, "*** ERROR: CGImageDestinationAddAuxiliaryDataInfo: auxiliaryDataType is not a CFStringRef\n");
          }
        }
        else
        {
          LogError("CGImageDestinationAddAuxiliaryDataInfo", 5277, "*** ERROR: CGImageDestinationAddAuxiliaryDataInfo: destination is not a CGImageDestinationRef\n");
        }
      }
      else
      {
        LogError("CGImageDestinationAddAuxiliaryDataInfo", 5276, "*** ERROR: CGImageDestinationAddAuxiliaryDataInfo: auxiliaryDataInfoDictionary is nil\n");
      }
    }
    else
    {
      LogError("CGImageDestinationAddAuxiliaryDataInfo", 5275, "*** ERROR: CGImageDestinationAddAuxiliaryDataInfo: auxiliaryDataType is nil\n");
    }
  }
  else
  {
    LogError("CGImageDestinationAddAuxiliaryDataInfo", 5274, "*** ERROR: CGImageDestinationAddAuxiliaryDataInfo: destination is nil\n");
  }
  kdebug_trace();
}

void sub_188775318(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void CGImageDestinationAddImageWithMetadata(CGImageDestinationRef idst, CGImageRef image, __CFArray *a3)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageDestinationAddImageWithMetadata", 0, 0, -1, 0);
  }
  keys[0] = @"{MetaData}";
  if (a3 && (unsigned int v6 = CGImageMetadataCreateFromMetadataProperties(a3)) != 0)
  {
    uint64_t v7 = v6;
    values = v6;
    CFDictionaryRef v8 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFRelease(v7);
    CGImageDestinationAddImage(idst, image, v8);
    if (v8) {
      CFRelease(v8);
    }
  }
  else
  {
    CGImageDestinationAddImage(idst, image, 0);
  }
}

void CGImageDestinationAddImageFromSourceWithMetadata(CGImageDestinationRef idst, CGImageSourceRef isrc, size_t index, __CFArray *a4)
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageDestinationAddImageFromSourceWithMetadata", 0, 0, -1, 0);
  }
  keys[0] = @"{MetaData}";
  if (a4 && (CFDictionaryRef v8 = CGImageMetadataCreateFromMetadataProperties(a4)) != 0)
  {
    CFTypeID v9 = v8;
    values = v8;
    CFDictionaryRef v10 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    CFRelease(v9);
    CGImageDestinationAddImageFromSource(idst, isrc, index, v10);
    if (v10) {
      CFRelease(v10);
    }
  }
  else
  {
    CGImageDestinationAddImageFromSource(idst, isrc, index, 0);
  }
}

uint64_t TIFFInitNeXT(void *a1)
{
  a1[121] = NeXTPreDecode;
  a1[126] = NeXTDecode;
  a1[128] = NeXTDecode;
  a1[130] = NeXTDecode;
  return 1;
}

uint64_t NeXTPreDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a1 + 116) == 2) {
    return 1;
  }
  TIFFErrorExtR(a1, "NeXTPreDecode", "Unsupported BitsPerSample = %hu", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 116));
  return 0;
}

uint64_t NeXTDecode(uint64_t a1, char *__b, int64_t __len, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = __len;
  CFTypeID v9 = __b;
  if (__len >= 1) {
    memset(__b, 255, __len);
  }
  int64_t v11 = *(void *)(a1 + 1104);
  if (v8 % v11)
  {
    TIFFErrorExtR(a1, "NeXTDecode", "Fractional scanlines cannot be read", a4, a5, a6, a7, a8, v37);
    return 0;
  }
  uint64_t i = *(void *)(a1 + 1160);
  uint64_t v14 = *(unsigned __int8 **)(a1 + 1152);
  if (i < 1 || v8 < 1)
  {
LABEL_44:
    *(void *)(a1 + 1152) = v14;
    *(void *)(a1 + 1160) = i;
    return 1;
  }
  while (1)
  {
    uint64_t v16 = v14 + 1;
    unsigned int v15 = *v14;
    uint64_t v17 = i - 1;
    if (v15 != 64) {
      break;
    }
    if ((unint64_t)i < 5
      || ((uint64_t v18 = __rev16(*(unsigned __int16 *)(v14 + 1)),
           size_t v19 = __rev16(*(unsigned __int16 *)(v14 + 3)),
           size_t v20 = v19 + 4,
           i > v19 + 4)
        ? (BOOL v21 = (uint64_t)(v19 + v18) <= v11)
        : (BOOL v21 = 0),
          !v21))
    {
LABEL_45:
      TIFFErrorExtR(a1, "NeXTDecode", "Not enough data for scanline %u", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 876));
      return 0;
    }
    _TIFFmemcpy(&v9[v18], v14 + 5, v19);
    uint64_t v14 = &v16[v20];
    uint64_t i = v17 - v20;
LABEL_41:
    if (i >= 1)
    {
      v9 += v11;
      BOOL v21 = v8 <= v11;
      v8 -= v11;
      if (!v21) {
        continue;
      }
    }
    goto LABEL_44;
  }
  if (!*v14)
  {
    if (i <= v11) {
      goto LABEL_45;
    }
    _TIFFmemcpy(v9, v14 + 1, v11);
    uint64_t v14 = &v16[v11];
    uint64_t i = v17 - v11;
    goto LABEL_41;
  }
  unsigned int v22 = 0;
  int64_t v23 = 0;
  if ((*(unsigned char *)(a1 + 17) & 4) != 0) {
    uint64_t v24 = 100;
  }
  else {
    uint64_t v24 = 88;
  }
  unsigned int v25 = *(_DWORD *)(a1 + v24);
  int v26 = v9;
  for (uint64_t i = v17; ; --i)
  {
    BOOL v27 = v22 < v25;
    BOOL v28 = v23 < v11;
    unint64_t v29 = v15 & 0x3F;
    if ((v15 & 0x3F) != 0 && v22 < v25 && v23 < v11)
    {
      unsigned int v30 = v15 >> 6;
      int v31 = 4 * (v15 >> 6);
      int v32 = 16 * (v15 >> 6);
      char v33 = v15 & 0xC0;
      do
      {
        unsigned int v34 = v22 + 1;
        switch(v22 & 3)
        {
          case 1u:
            char v35 = *v26 | v32;
            goto LABEL_31;
          case 2u:
            char v35 = *v26 | v31;
LABEL_31:
            *int v26 = v35;
            break;
          case 3u:
            *v26++ |= v30;
            ++v23;
            break;
          default:
            *int v26 = v33;
            break;
        }
        BOOL v27 = v34 < v25;
        BOOL v28 = v23 < v11;
        ++v22;
        if (v29 < 2) {
          break;
        }
        if (v34 >= v25) {
          break;
        }
        --v29;
      }
      while (v23 < v11);
    }
    if (!v27)
    {
      uint64_t v14 = v16;
      goto LABEL_41;
    }
    if (!v28) {
      break;
    }
    if (!i) {
      goto LABEL_45;
    }
    unsigned int v36 = *v16++;
    unsigned int v15 = v36;
  }
  TIFFErrorExtR(a1, "NeXTDecode", "Invalid data for scanline %u", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 876));
  return 0;
}

size_t png_default_read_data(size_t result, void *__ptr, size_t a3)
{
  if (result)
  {
    unsigned int v4 = (void (**)(void))result;
    double result = fread(__ptr, 1uLL, a3, *(FILE **)(result + 40));
    if (result != a3) {
      _cg_png_error(v4, "Read Error");
    }
  }
  return result;
}

void *MPOReadPlugin::MPOReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  double result = (void *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *double result = &unk_1ED4E03E0;
  return result;
}

void MPOReadPlugin::MPOReadPlugin(uint64_t a1, uint64_t a2)
{
}

void MPOReadPlugin::~MPOReadPlugin(MPOReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t MPOReadPlugin::loadDataFromXPCObject(MPOReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_mpo", &length);
    if (length == 1)
    {
      unsigned int v6 = data;
      uint64_t result = 0;
      *((unsigned char *)this + 436) = *v6;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t MPOReadPlugin::saveDataToXPCObject(MPOReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_mpo", (char *)this + 436, 1uLL);
  }
  return v4;
}

uint64_t MPOReadPlugin::initialize(MPOReadPlugin *this, IIODictionary *a2)
{
  uint64_t v4 = (IIODictionary *)*((void *)this + 7);
  CFDictionaryRef v5 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1297108768);
  if (v5)
  {
    unsigned int v6 = v5;
    unsigned int v7 = *((_DWORD *)this + 52);
    if (v7 < GlobalMPOInfo::getEntryCount(v5))
    {
      EntryAtIndedouble x = (_MPEntry *)GlobalMPOInfo::getEntryAtIndex(v6, *((_DWORD *)this + 52));
      if (EntryAtIndex)
      {
        CFTypeID v9 = EntryAtIndex;
        unsigned int v10 = _MPEntry::imageSize(EntryAtIndex);
        uint64_t v11 = _MPEntry::imageOffset(v9);
        uint64_t v12 = v11;
        if (v11)
        {
          uint64_t v11 = IIOImageSource::cf(v6);
          v12 += v11;
        }
        if (IIO_ReaderHandler::UseAppleJPEG((IIO_ReaderHandler *)v11)) {
          IIONumber::IIONumber((IIONumber *)v17, 1246774599);
        }
        else {
          IIONumber::IIONumber((IIONumber *)v17, 1279938631);
        }
        IIODictionary::setObjectForKey(a2, value, @"NEW_PLUGIN_ostype");
        IIONumber::~IIONumber((IIONumber *)v17);
        IIONumber::IIONumber((IIONumber *)v17, v12);
        IIODictionary::setObjectForKey(a2, value, @"NEW_PLUGIN_dataOffset");
        IIONumber::~IIONumber((IIONumber *)v17);
        IIONumber::IIONumber((IIONumber *)v17, v10);
        IIODictionary::setObjectForKey(a2, value, @"NEW_PLUGIN_dataSize");
        IIONumber::~IIONumber((IIONumber *)v17);
        uint64_t Metadata = GlobalMPOInfo::getMetadata(v6);
        if (Metadata)
        {
          CFArrayRef v15 = (const __CFArray *)Metadata;
          if (GlobalMPOInfo::getEntryCount(v6) >= 2)
          {
            CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(v15, *((unsigned int *)this + 52));
            if (ValueAtIndex) {
              IIODictionary::setObjectForKey(v4, ValueAtIndex, @"{MPO}");
            }
          }
          if (_MPEntry::isLargeThumbnail(v9)) {
            IIODictionary::setObjectForKey(v4, (const void *)*MEMORY[0x1E4F1CFD0], @"kCGImageSourceAddMetadataFromPrimaryImage");
          }
        }
      }
    }
  }
  else
  {
    _cg_jpeg_mem_term("initialize", 91, "could not get globalMPOInfo\n");
  }
  kdebug_trace();
  kdebug_trace();
  return 4294967247;
}

void sub_188775D20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void IIO_Reader_AppleJPEG::createReadPlugin()
{
}

{
  operator new();
}

void sub_188775DA8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40F933A5CALL);
  _Unwind_Resume(a1);
}

void sub_188775E64(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40F933A5CALL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_AppleJPEG::initThumbnail(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t Source = (IIOImagePlus *)CGImageSourceGetSource(a2);
  Properties = (IIODictionary *)IIOImagePlus::getProperties(Source);
  Sessiounsigned int n = CGImagePluginGetSession(a2);
  CFTypeID v9 = (IIOImageReadSession *)CGImageSourceGetSource(Session);
  if (!Session) {
    return 4294967245;
  }
  unsigned int v10 = v9;
  unint64_t Size = (unint64_t)IIOImageReadSession::getSize(v9);
  uint64_t v70 = 0;
  uint64_t v12 = IIOImageReadSession::retainBytePointer(v10, (const __CFData **)&v70, 0);
  BOOL v13 = v12;
  if (v12)
  {
    uint64_t v14 = (unsigned __int8 *)v12;
  }
  else
  {
    uint64_t v14 = (unsigned __int8 *)malloc_type_malloc(0x1000uLL, 0x882CE9D2uLL);
    unint64_t Size = IIOImageReadSession::getBytesAtOffset(v10, v14, 0, 0x1000uLL);
  }
  if (Size < 0x1000 || *v14 != 255 || v14[1] != 216) {
    goto LABEL_17;
  }
  if (v14[2] == 255 && v14[3] == 224) {
    unint64_t v16 = __rev16(*((unsigned __int16 *)v14 + 2)) + 4;
  }
  else {
    unint64_t v16 = 2;
  }
  if (v16 < Size - 10)
  {
    if (v14[v16] != 255) {
      goto LABEL_17;
    }
    uint64_t v17 = &v14[v16];
    if (v14[v16 + 1] != 225) {
      goto LABEL_17;
    }
    unsigned int v18 = *((unsigned __int16 *)v17 + 1);
    if (strncmp((const char *)v17 + 4, "Exif", 4uLL)) {
      goto LABEL_17;
    }
    unint64_t v22 = (unint64_t)&v14[Size];
    unint64_t v19 = v16 + 10;
    int64_t v23 = &v14[v16 + 10];
    int v24 = *v23;
    if (v24 == 77)
    {
      if (v23[1] != 77 || v23[2]) {
        goto LABEL_18;
      }
      unsigned int v25 = v18;
      uint64_t v20 = 0;
      if (v23[3] != 42) {
        goto LABEL_45;
      }
    }
    else
    {
      if (v24 != 73 || v23[1] != 73 || v23[2] != 42) {
        goto LABEL_18;
      }
      unsigned int v25 = v18;
      uint64_t v20 = 0;
      if (v23[3]) {
        goto LABEL_45;
      }
    }
    if ((unint64_t)(v23 + 8) <= v22)
    {
      uint64_t v20 = 0;
      LODWORD(v26) = *((_DWORD *)v23 + 1);
      unsigned int v27 = bswap32(v26);
      unint64_t v26 = v24 == 77 ? v27 : v26;
      if (v26 >= 8 && (unint64_t)__rev16(v25) - 4 >= v26)
      {
        BOOL v28 = &v23[v26];
        unint64_t v29 = (unsigned __int16 *)(v28 + 2);
        if ((unint64_t)(v28 + 2) <= v22)
        {
          unsigned int v30 = *(unsigned __int16 *)v28;
          unsigned int v31 = bswap32(v30) >> 16;
          if (v24 == 77) {
            unsigned int v32 = v31;
          }
          else {
            unsigned int v32 = v30;
          }
          if ((Size - v16 - v26 - 12) / 0xC <= (unsigned __int16)v32) {
            goto LABEL_18;
          }
          if ((_WORD)v32)
          {
            int v65 = v24;
            do
            {
              if ((unint64_t)(v29 + 1) <= v22)
              {
                unsigned int v33 = *v29;
                unsigned int v34 = bswap32(v33) >> 16;
                if (v24 == 77) {
                  LOWORD(v33) = v34;
                }
              }
              else
              {
                LOWORD(v33) = 0;
              }
              if ((unint64_t)(v29 + 2) <= v22)
              {
                unsigned int v35 = bswap32(v29[1]) >> 16;
                if (v24 != 77) {
                  LOWORD(v35) = v29[1];
                }
              }
              else
              {
                LOWORD(v35) = 0;
              }
              if ((unint64_t)(v29 + 4) <= v22)
              {
                unsigned int v36 = *((_DWORD *)v29 + 1);
                __int16 v37 = bswap32(v36);
                if (v24 == 77) {
                  LOWORD(v36) = v37;
                }
                if ((unsigned __int16)v33 == 274
                  && (unsigned __int16)v35 == 3
                  && (unsigned __int16)v36 == 1
                  && (unint64_t)(v29 + 5) <= v22)
                {
                  unsigned int v39 = v29[4];
                  unsigned int v40 = bswap32(v39) >> 16;
                  if (v24 == 77) {
                    LOWORD(v39) = v40;
                  }
                  if ((unsigned __int16)(v39 - 1) <= 7u)
                  {
                    unsigned int v66 = v32;
                    int v67 = (unsigned __int16)v39;
                    IIONumber::IIONumber((IIONumber *)v69, (unsigned __int16)v39);
                    IIODictionary::setObjectForKey((uint64_t)Properties, (uint64_t)v69, @"Orientation");
                    IIONumber::~IIONumber((IIONumber *)v69);
                    IIONumber::IIONumber((IIONumber *)v68, v67);
                    IIODictionary::setObjectForKeyGroup(Properties, (uint64_t)v68, @"Orientation", @"{TIFF}");
                    IIONumber::~IIONumber((IIONumber *)v68);
                    int v24 = v65;
                    unint64_t v22 = (unint64_t)&v14[Size];
                    unsigned int v32 = v66;
                  }
                }
              }
              --v32;
              v29 += 6;
            }
            while ((_WORD)v32);
          }
        }
        else if (Size - v16 - v26 - 12 < 0xC)
        {
          goto LABEL_18;
        }
        if ((unint64_t)(v29 + 2) > v22) {
          goto LABEL_18;
        }
        unsigned int v41 = *(_DWORD *)v29;
        unsigned int v42 = bswap32(*(_DWORD *)v29);
        if (v24 == 77) {
          unsigned int v41 = v42;
        }
        if (!v41) {
          goto LABEL_18;
        }
        unint64_t v43 = v19 + v41;
        if (v70)
        {
          if (Size <= v43 + 2) {
            goto LABEL_18;
          }
          uint64_t v14 = (unsigned __int8 *)v13 + v43;
          int64_t BytesAtOffset = Size - v43;
        }
        else
        {
          int v45 = v24;
          int64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(v10, v14, v43, 0x1000uLL);
          if ((unint64_t)BytesAtOffset < 2) {
            goto LABEL_18;
          }
          int v24 = v45;
        }
        if (BytesAtOffset >= 2)
        {
          unsigned int v46 = *(unsigned __int16 *)v14;
          unsigned int v47 = bswap32(v46) >> 16;
          if (v24 == 77) {
            unsigned int v46 = v47;
          }
          if ((BytesAtOffset - 2) / 0xCuLL > (unsigned __int16)v46 && (unsigned __int16)v46 != 0)
          {
            uint64_t v49 = 0;
            uint64_t v21 = 0;
            uint64_t v20 = 0;
            unint64_t v50 = (unint64_t)&v14[BytesAtOffset];
            do
            {
              uint64_t v51 = &v14[v49];
              unsigned int v52 = &v14[v49 + 4];
              if ((unint64_t)v52 <= v50)
              {
                unsigned int v53 = *((unsigned __int16 *)v51 + 1);
                unsigned int v54 = bswap32(v53) >> 16;
                if (v24 == 77) {
                  LOWORD(v53) = v54;
                }
              }
              else
              {
                LOWORD(v53) = 0;
              }
              unsigned int v55 = (unsigned int *)(v51 + 6);
              if ((unint64_t)(v51 + 6) <= v50)
              {
                unsigned int v57 = *(unsigned __int16 *)v52;
                unsigned int v56 = bswap32(v57) >> 16;
                if (v24 != 77) {
                  LOWORD(v56) = v57;
                }
              }
              else
              {
                LOWORD(v56) = 0;
              }
              uint64_t v58 = (unsigned int *)&v14[v49 + 10];
              if ((unint64_t)v58 <= v50)
              {
                unsigned int v59 = *v55;
                __int16 v60 = bswap32(v59);
                if (v24 != 77) {
                  __int16 v60 = v59;
                }
                if ((unsigned __int16)v53 == 513 && (unsigned __int16)v56 == 4 && v60 == 1)
                {
                  if ((unint64_t)&v14[v49 + 14] <= v50)
                  {
                    unsigned int v61 = *v58;
                    unsigned int v63 = bswap32(v61);
                    if (v24 == 77) {
                      unsigned int v61 = v63;
                    }
                  }
                  else
                  {
                    unsigned int v61 = 0;
                  }
                  uint64_t v20 = v61;
                }
                else if ((unsigned __int16)v53 == 514 && (unsigned __int16)v56 == 4 && v60 == 1)
                {
                  if ((unint64_t)&v14[v49 + 14] <= v50)
                  {
                    unsigned int v62 = *v58;
                    unsigned int v64 = bswap32(v62);
                    if (v24 == 77) {
                      unsigned int v62 = v64;
                    }
                  }
                  else
                  {
                    unsigned int v62 = 0;
                  }
                  uint64_t v21 = v62;
                }
              }
              --v46;
              v49 += 12;
            }
            while ((_WORD)v46);
            goto LABEL_19;
          }
        }
        goto LABEL_18;
      }
    }
LABEL_45:
    uint64_t v21 = 0;
    goto LABEL_19;
  }
  _cg_jpeg_mem_term("initThumbnail", 371, "*** ERROR: bad APP marker offset (%ld)\n", v16);
LABEL_17:
  unint64_t v19 = 0;
LABEL_18:
  uint64_t v20 = 0;
  uint64_t v21 = 0;
LABEL_19:
  if (v70)
  {
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)v10, v70);
  }
  else if (v14)
  {
    free(v14);
  }
  uint64_t result = 4294967245;
  if (v20)
  {
    if (v21) {
      CGImagePluginInitThumbJPEGAtOffset(a2, (IIOImageReadSession *)(v20 + v19), v21, a4);
    }
  }
  return result;
}

void sub_1887764A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_AppleJPEG::canCreateCustomThumbnailSizes(IIO_Reader_AppleJPEG *this)
{
  return 1;
}

uint64_t png_colorspace_set_rgb_coefficients(uint64_t result)
{
  if (*(unsigned char *)(result + 753) || (*(_WORD *)(result + 1074) & 2) == 0) {
    return result;
  }
  int v1 = *(_DWORD *)(result + 1040);
  if (v1 < 0) {
    goto LABEL_46;
  }
  int v2 = *(_DWORD *)(result + 1052);
  int v3 = *(_DWORD *)(result + 1064);
  int v4 = v2 + v1 + v3;
  if (v4 < 1) {
    goto LABEL_46;
  }
  if (v1)
  {
    double v5 = (double)v1 * 32768.0 / (double)v4 + 0.5;
    double v6 = floor(v5);
    BOOL v7 = v6 <= 2147483650.0 && v6 >= -2147483650.0;
    unsigned int v8 = vcvtmd_s64_f64(v5);
    if (v7) {
      int v1 = v8;
    }
    if (v2 < 0) {
LABEL_46:
    }
      _cg_png_error((void (**)(void))result, "internal error handling cHRM->XYZ");
  }
  else
  {
    BOOL v7 = 1;
    if (v2 < 0) {
      goto LABEL_46;
    }
  }
  if (!v7 || v1 < 0 || v1 > 0x8000) {
    goto LABEL_46;
  }
  if (v2)
  {
    double v9 = (double)v2 * 32768.0 / (double)v4 + 0.5;
    double v10 = floor(v9);
    BOOL v11 = v10 <= 2147483650.0 && v10 >= -2147483650.0;
    unsigned int v12 = vcvtmd_s64_f64(v9);
    if (v11) {
      int v2 = v12;
    }
    if (v3 < 0) {
      goto LABEL_46;
    }
  }
  else
  {
    BOOL v11 = 1;
    if (v3 < 0) {
      goto LABEL_46;
    }
  }
  if (!v11 || v2 < 0 || v2 > 0x8000) {
    goto LABEL_46;
  }
  if (v3)
  {
    double v13 = (double)v3 * 32768.0 / (double)v4 + 0.5;
    double v14 = floor(v13);
    if (v14 > 2147483650.0 || v14 < -2147483650.0) {
      goto LABEL_46;
    }
    unsigned int v16 = vcvtmd_s64_f64(v13);
    if (v16 > 0x8000) {
      goto LABEL_46;
    }
  }
  else
  {
    unsigned int v16 = 0;
  }
  unsigned int v17 = v2 + v1 + v16;
  if (v17 > 0x8001) {
    goto LABEL_46;
  }
  if (v17 == 32769)
  {
    int v18 = -1;
LABEL_36:
    if (v2 < v1 || v2 < v16)
    {
      if (v1 < v2 || v1 < v16) {
        v16 += v18;
      }
      else {
        v1 += v18;
      }
    }
    else
    {
      v2 += v18;
    }
    goto LABEL_43;
  }
  if (!(v17 >> 15))
  {
    int v18 = 1;
    goto LABEL_36;
  }
LABEL_43:
  if (v2 + v1 + v16 != 0x8000) {
    _cg_png_error((void (**)(void))result, "internal error handling cHRM coefficients");
  }
  *(_WORD *)(result + 754) = v1;
  *(_WORD *)(result + 756) = v2;
  return result;
}

uint64_t png_muldiv(int *a1, int a2, int a3, int a4)
{
  if (!a4) {
    return 0;
  }
  int v4 = 0;
  if (!a2 || !a3) {
    goto LABEL_10;
  }
  double v5 = floor((double)a2 * (double)a3 / (double)a4 + 0.5);
  if (v5 > 2147483650.0 || v5 < -2147483650.0) {
    return 0;
  }
  int v4 = (int)v5;
LABEL_10:
  *a1 = v4;
  return 1;
}

uint64_t png_check_fp_number(uint64_t a1, unint64_t a2, unsigned int *a3, unint64_t *a4)
{
  unsigned int v4 = *a3;
  unint64_t v5 = *a4;
  if (*a4 < a2)
  {
    while (2)
    {
      int v6 = 4;
      switch(*(unsigned char *)(a1 + v5))
      {
        case '+':
          goto LABEL_4;
        case '-':
          int v6 = 132;
          goto LABEL_4;
        case '.':
          int v6 = 16;
          goto LABEL_4;
        case '0':
          int v6 = 8;
          goto LABEL_4;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          int v6 = 264;
          goto LABEL_4;
        case 'E':
          int v6 = 32;
LABEL_4:
          int v7 = v6 & 0x3C | v4 & 3;
          switch(v7)
          {
            case 4:
              if ((v4 & 0x3C) == 0)
              {
                v4 |= v6;
                break;
              }
              goto LABEL_27;
            case 5:
            case 7:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
              goto LABEL_27;
            case 6:
              if ((v4 & 0x3C) == 0)
              {
                v4 |= 4u;
                break;
              }
              goto LABEL_27;
            case 8:
              if ((v4 & 0x10) != 0) {
                unsigned int v4 = v4 & 0x180 | 0x11;
              }
              goto LABEL_15;
            case 9:
LABEL_15:
              v4 |= v6 | 0x40;
              break;
            case 10:
              v4 |= 0x48u;
              break;
            case 16:
              if ((v4 & 0x10) != 0) {
                goto LABEL_27;
              }
              int v8 = v4 & 0x1C0 | v6 | 1;
              int v9 = v6 | v4;
              if ((v4 & 8) != 0) {
                unsigned int v4 = v9;
              }
              else {
                unsigned int v4 = v8;
              }
              break;
            default:
              if (v7 != 32 && v7 != 33 || (v4 & 8) == 0) {
                goto LABEL_27;
              }
              unsigned int v4 = v4 & 0x1C0 | 2;
              break;
          }
          if (a2 != ++v5) {
            continue;
          }
          unint64_t v5 = a2;
          break;
        default:
          goto LABEL_27;
      }
      break;
    }
  }
LABEL_27:
  *a3 = v4;
  *a4 = v5;
  return (v4 >> 3) & 1;
}

uint64_t png_check_fp_string(uint64_t a1, unint64_t a2)
{
  unsigned int v6 = 0;
  unint64_t v5 = 0;
  uint64_t result = png_check_fp_number(a1, a2, &v6, &v5);
  if (result)
  {
    if (v5 == a2 || !*(unsigned char *)(a1 + v5)) {
      return v6;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t png_fixed(void (**a1)(void), uint64_t a2, double a3)
{
  double v3 = floor(a3 * 100000.0 + 0.5);
  if (v3 > 2147483650.0 || v3 < -2147483650.0) {
    png_fixed_error(a1, a2);
  }
  return (int)v3;
}

unsigned int png_reciprocal2(int a1, int a2)
{
  if (a1
    && a2
    && ((double v2 = 1.0e15 / (double)a1 / (double)a2 + 0.5, v3 = floor(v2), v3 <= 2147483650.0)
      ? (BOOL v4 = v3 < -2147483650.0)
      : (BOOL v4 = 1),
        !v4))
  {
    return vcvtmd_s64_f64(v2);
  }
  else
  {
    return 0;
  }
}

uint64_t png_gamma_8bit_correct(uint64_t result, int a2)
{
  if ((result - 1) <= 0xFD) {
    LOBYTE(result) = vcvtmd_s64_f64(pow((double)(int)result / 255.0, (double)a2 * 0.00001) * 255.0 + 0.5);
  }
  return result;
}

uint64_t png_gamma_correct(uint64_t a1, int a2, int a3)
{
  unsigned int v3 = a2 - 1;
  if (*(unsigned char *)(a1 + 392) == 8)
  {
    if (v3 <= 0xFD) {
      LOBYTE(a2) = vcvtmd_s64_f64(pow((double)a2 / 255.0, (double)a3 * 0.00001) * 255.0 + 0.5);
    }
    LOWORD(a2) = a2;
  }
  else if (v3 <= 0xFFFD)
  {
    LOWORD(a2) = vcvtmd_s64_f64(pow((double)a2 / 65535.0, (double)a3 * 0.00001) * 65535.0 + 0.5);
  }
  return (unsigned __int16)a2;
}

void png_build_gamma_table(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 456) || *(void *)(a1 + 464))
  {
    png_warning(a1, "gamma table being rebuilt");
    png_destroy_gamma_table(a1);
  }
  if (a2 > 8)
  {
    if ((*(unsigned char *)(a1 + 391) & 2) != 0)
    {
      unsigned int v9 = *(unsigned __int8 *)(a1 + 504);
      if (*(unsigned __int8 *)(a1 + 505) > v9) {
        unsigned int v9 = *(unsigned __int8 *)(a1 + 505);
      }
      if (*(unsigned __int8 *)(a1 + 506) > v9) {
        unsigned int v9 = *(unsigned __int8 *)(a1 + 506);
      }
    }
    else
    {
      unsigned int v9 = *(unsigned __int8 *)(a1 + 507);
    }
    unsigned int v10 = v9 - 1;
    unsigned __int8 v11 = 16 - v9;
    if (v10 >= 0xF) {
      unsigned __int8 v11 = 0;
    }
    char v12 = v11;
    if (v11 <= 5u) {
      char v12 = 5;
    }
    int v13 = *(_DWORD *)(a1 + 88) & 0x4000400;
    if (v13) {
      unsigned __int8 v11 = v12;
    }
    if ((v11 & 0xF8) != 0) {
      int v14 = 8;
    }
    else {
      int v14 = v11;
    }
    *(_DWORD *)(a1 + 448) = v14;
    int v15 = *(_DWORD *)(a1 + 452);
    unsigned int v16 = (double *)&unk_188990000;
    if (v13)
    {
      if (v15 < 1)
      {
        double v21 = 1.0;
      }
      else
      {
        double v17 = (double)*(int *)(a1 + 1000) * 0.00001 * (double)v15 + 0.5;
        double v18 = floor(v17);
        int v19 = vcvtmd_s64_f64(v17);
        if (v18 < -2147483650.0 || v18 > 2147483650.0) {
          double v21 = 0.0;
        }
        else {
          double v21 = (double)v19 * 0.00001;
        }
      }
      char v26 = 8 - v14;
      uint64_t v27 = (1 << (8 - v14));
      BOOL v28 = png_calloc((void (**)(void))a1, 8 * v27);
      *(void *)(a1 + 464) = v28;
      unint64_t v29 = (void (***)(void))v28;
      do
      {
        *v29++ = png_malloc((void (**)(void))a1, 0x200uLL);
        --v27;
      }
      while (v27);
      unsigned int v30 = 0;
      int v31 = 0;
      unsigned int v32 = 0xFFu >> v14;
      do
      {
        unsigned int v33 = vcvtmd_s64_f64(pow((double)((unsigned __int16)(257 * v31) + 128) / 65535.0, v21) * 65535.0 + 0.5);
        unsigned int v34 = ((v33 << (16 - v14)) - v33 + 0x8000) / 0xFFFF;
        if (v30 <= v34)
        {
          do
          {
            *((_WORD *)v28[v30 & v32] + (v30 >> v26)) = 257 * v31;
            ++v30;
          }
          while (v34 + 1 != v30);
          unsigned int v30 = v34 + 1;
        }
        ++v31;
      }
      while (v31 != 255);
      unsigned int v16 = (double *)&unk_188990000;
      if (v30 < 256 << v26)
      {
        do
        {
          *((_WORD *)v28[v30 & v32] + (v30 >> v26)) = -1;
          ++v30;
        }
        while (256 << v26 != v30);
      }
    }
    else
    {
      if (v15 < 1)
      {
        int v47 = 100000;
      }
      else
      {
        int v22 = *(_DWORD *)(a1 + 1000);
        if (!v22
          || ((double v23 = 1.0e15 / (double)v22 / (double)v15 + 0.5, v24 = floor(v23), v24 <= 2147483650.0)
            ? (BOOL v25 = v24 < -2147483650.0)
            : (BOOL v25 = 1),
              v25))
        {
          int v47 = 0;
        }
        else
        {
          int v47 = vcvtmd_s64_f64(v23);
        }
      }
      png_build_16bit_table((void (**)(void))a1, (void (***)(void))(a1 + 464), v14, v47);
    }
    if ((*(_DWORD *)(a1 + 88) & 0x600080) != 0)
    {
      double v48 = 1.0e10 / (double)*(int *)(a1 + 1000) + 0.5;
      double v49 = floor(v48);
      double v50 = v16[354];
      BOOL v51 = v49 < -2147483650.0 || v49 > v50;
      unsigned int v52 = vcvtmd_s64_f64(v48);
      if (v51) {
        int v53 = 0;
      }
      else {
        int v53 = v52;
      }
      png_build_16bit_table((void (**)(void))a1, (void (***)(void))(a1 + 496), v14, v53);
      int v54 = *(_DWORD *)(a1 + 452);
      if (v54 < 1)
      {
        int v59 = *(_DWORD *)(a1 + 1000);
      }
      else
      {
        double v55 = 1.0e10 / (double)v54 + 0.5;
        double v56 = floor(v55);
        BOOL v57 = v56 < -2147483650.0 || v56 > v50;
        unsigned int v58 = vcvtmd_s64_f64(v55);
        if (v57) {
          int v59 = 0;
        }
        else {
          int v59 = v58;
        }
      }
      png_build_16bit_table((void (**)(void))a1, (void (***)(void))(a1 + 488), v14, v59);
    }
  }
  else
  {
    int v4 = *(_DWORD *)(a1 + 452);
    if (v4 < 1)
    {
      int v35 = 100000;
    }
    else
    {
      int v5 = *(_DWORD *)(a1 + 1000);
      if (!v5
        || ((double v6 = 1.0e15 / (double)v5 / (double)v4 + 0.5, v7 = floor(v6), v7 <= 2147483650.0)
          ? (BOOL v8 = v7 < -2147483650.0)
          : (BOOL v8 = 1),
            v8))
      {
        int v35 = 0;
      }
      else
      {
        int v35 = vcvtmd_s64_f64(v6);
      }
    }
    png_build_8bit_table((void (**)(void))a1, (void (***)(void))(a1 + 456), v35);
    if ((*(_DWORD *)(a1 + 88) & 0x600080) != 0)
    {
      double v36 = 1.0e10 / (double)*(int *)(a1 + 1000) + 0.5;
      double v37 = floor(v36);
      BOOL v38 = v37 < -2147483650.0 || v37 > 2147483650.0;
      unsigned int v39 = vcvtmd_s64_f64(v36);
      if (v38) {
        int v40 = 0;
      }
      else {
        int v40 = v39;
      }
      png_build_8bit_table((void (**)(void))a1, (void (***)(void))(a1 + 480), v40);
      int v41 = *(_DWORD *)(a1 + 452);
      if (v41 < 1)
      {
        int v46 = *(_DWORD *)(a1 + 1000);
      }
      else
      {
        double v42 = 1.0e10 / (double)v41 + 0.5;
        double v43 = floor(v42);
        BOOL v44 = v43 < -2147483650.0 || v43 > 2147483650.0;
        unsigned int v45 = vcvtmd_s64_f64(v42);
        if (v44) {
          int v46 = 0;
        }
        else {
          int v46 = v45;
        }
      }
      png_build_8bit_table((void (**)(void))a1, (void (***)(void))(a1 + 472), v46);
    }
  }
}

void png_build_8bit_table(void (**a1)(void), void (***a2)(void), int a3)
{
  int v5 = png_malloc(a1, 0x100uLL);
  double v6 = v5;
  *a2 = v5;
  if ((a3 - 95000) > 0x2710)
  {
    for (uint64_t i = 0; i != 256; ++i)
    {
      if ((i - 1) > 0xFD) {
        char v11 = i;
      }
      else {
        char v11 = vcvtmd_s64_f64(pow((double)(int)i / 255.0, (double)a3 * 0.00001) * 255.0 + 0.5);
      }
      *((unsigned char *)v6 + i) = v11;
    }
  }
  else
  {
    uint64_t v7 = 0;
    int8x16_t v8 = (int8x16_t)xmmword_18898F090;
    v9.i64[0] = 0x1010101010101010;
    v9.i64[1] = 0x1010101010101010;
    do
    {
      *(int8x16_t *)&v5[v7] = v8;
      v7 += 2;
      int8x16_t v8 = vaddq_s8(v8, v9);
    }
    while (v7 != 32);
  }
}

void png_build_16bit_table(void (**a1)(void), void (***a2)(void), int a3, int a4)
{
  unsigned int v7 = 8 - a3;
  int v8 = ~(-1 << (16 - a3));
  double v43 = 1.0 / (double)v8;
  int v9 = 1 << (15 - a3);
  uint64_t v39 = (1 << (8 - a3));
  char v11 = png_calloc(a1, 8 * v39);
  uint64_t v12 = 0;
  *a2 = v11;
  unsigned int v13 = a4 - 95000;
  double v14 = (double)a4 * 0.00001;
  uint32x4_t v42 = (uint32x4_t)vdupq_n_s32(v7);
  float64x2_t v41 = (float64x2_t)vdupq_n_s64(0x40EFFFE000000000uLL);
  __asm { FMOV            V0.2D, #0.5 }
  float64x2_t v40 = _Q0;
  do
  {
    uint64_t v20 = png_malloc(a1, 0x200uLL);
    double v21 = v20;
    v11[v12] = (void (*)(void))v20;
    if (v13 > 0x2710)
    {
      uint64_t v24 = 0;
      int32x4_t v44 = vdupq_n_s32(v12);
      uint32x4_t v25 = (uint32x4_t)xmmword_18898C3A0;
      uint32x4_t v26 = (uint32x4_t)xmmword_1889AA6D0;
      do
      {
        int32x4_t v50 = (int32x4_t)v26;
        int32x4_t v51 = (int32x4_t)v25;
        int32x4_t v27 = vaddq_s32((int32x4_t)vshlq_u32(v26, v42), v44);
        int32x4_t v28 = vaddq_s32((int32x4_t)vshlq_u32(v25, v42), v44);
        v29.i64[0] = v28.u32[0];
        v29.i64[1] = v28.u32[1];
        float64x2_t v30 = vcvtq_f64_u64(v29);
        v29.i64[0] = v28.u32[2];
        v29.i64[1] = v28.u32[3];
        float64x2_t v31 = vcvtq_f64_u64(v29);
        v29.i64[0] = v27.u32[0];
        v29.i64[1] = v27.u32[1];
        float64x2_t v32 = vcvtq_f64_u64(v29);
        v29.i64[0] = v27.u32[2];
        v29.i64[1] = v27.u32[3];
        float64x2_t v53 = vmulq_n_f64(v32, v43);
        float64x2_t v54 = vmulq_n_f64(vcvtq_f64_u64(v29), v43);
        float64x2_t v52 = vmulq_n_f64(v31, v43);
        float64x2_t v48 = vmulq_n_f64(v30, v43);
        long double v49 = pow(v48.f64[0], v14);
        long double v47 = pow(v48.f64[1], v14);
        v48.f64[0] = pow(v52.f64[0], v14);
        v52.f64[0] = pow(v52.f64[1], v14);
        long double v46 = pow(v53.f64[0], v14);
        long double v45 = pow(v53.f64[1], v14);
        v53.f64[0] = pow(v54.f64[0], v14);
        long double v33 = pow(v54.f64[1], v14);
        *(long double *)v55.val[2].i64 = v46;
        *(long double *)&v55.val[2].i64[1] = v45;
        *(long double *)v55.val[1].i64 = v49;
        *(long double *)&v55.val[1].i64[1] = v47;
        v34.f64[0] = v53.f64[0];
        v34.f64[1] = v33;
        v35.f64[0] = v48.f64[0];
        v35.f64[1] = v52.f64[0];
        v55.val[0].i64[1] = *(void *)&v41.f64[1];
        float64x2_t v36 = vmlaq_f64(v40, v41, v35);
        float64x2_t v37 = vmlaq_f64(v40, v41, v34);
        float64x2_t v38 = vrndmq_f64(vmlaq_f64(v40, v41, (float64x2_t)v55.val[1]));
        *(int32x2_t *)v55.val[1].i8 = vmovn_s64(vcvtq_s64_f64(vrndmq_f64(v36)));
        *(int32x2_t *)v55.val[3].i8 = vmovn_s64(vcvtq_s64_f64(vrndmq_f64(v37)));
        *(int32x2_t *)v55.val[0].i8 = vmovn_s64(vcvtq_s64_f64(v38));
        *(int32x2_t *)v55.val[2].i8 = vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vmlaq_f64(v40, v41, (float64x2_t)v55.val[2]))));
        *(int8x16_t *)&v21[v24] = vqtbl4q_s8(v55, (int8x16_t)xmmword_1889AA6E0);
        *(void *)&v36.f64[0] = 0x800000008;
        *(void *)&v36.f64[1] = 0x800000008;
        uint32x4_t v25 = (uint32x4_t)vaddq_s32(v51, (int32x4_t)v36);
        uint32x4_t v26 = (uint32x4_t)vaddq_s32(v50, (int32x4_t)v36);
        v24 += 2;
      }
      while (v24 != 64);
    }
    else
    {
      for (uint64_t i = 0; i != 256; ++i)
      {
        unsigned int v23 = (i << v7) + v12;
        if (a3) {
          unsigned int v23 = (v9 - v23 + (v23 << 16)) / v8;
        }
        *((_WORD *)v20 + i) = v23;
      }
    }
    ++v12;
  }
  while (v12 != v39);
}

void TIFFWritePlugin::TIFFWritePlugin(TIFFWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 1414088262);
  *unsigned int v3 = &unk_1ED4E3CA0;
}

void TIFFWritePlugin::~TIFFWritePlugin(TIFFWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t TIFFWritePlugin::writeICCData(uint64_t a1, uint64_t a2, CGColorSpace *a3, int a4)
{
  int v5 = CGColorSpaceCopyData(a3, a4);
  if (!v5) {
    return 4294967246;
  }
  CFDataRef v6 = v5;
  BytePtr = CFDataGetBytePtr(v5);
  CFIndex Length = CFDataGetLength(v6);
  uint64_t v15 = 4294967246;
  if (BytePtr && Length)
  {
    _cg_TIFFSetField(a2, 34675, v9, v10, v11, v12, v13, v14, Length);
    uint64_t v15 = 0;
  }
  CFRelease(v6);
  return v15;
}

uint64_t TIFFWritePlugin::writeIPTCData(int a1, int a2, IIODictionary *this)
{
  if (this && IIODictionary::getObjectForKey(this, @"{IPTC}")) {
    operator new();
  }
  return 0;
}

void sub_188777638(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

uint64_t TIFFWritePlugin::writeXMPData(int a1, uint64_t a2, IIODictionary *this)
{
  if (this)
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(this, @"{MetaData}");
    if (ObjectForKey)
    {
      CFDataRef v6 = ObjectForKey;
      CFRetain(ObjectForKey);
    }
    else
    {
      CFDataRef v6 = (const CGImageMetadata *)CGImageMetadataCreateFromLegacyProps(this);
    }
    CFDataRef XMPWithEXIFFiltered = CGImageMetadataCreateXMPWithEXIFFiltered(v6);
    CFDataRef v8 = XMPWithEXIFFiltered;
    if (XMPWithEXIFFiltered)
    {
      BytePtr = CFDataGetBytePtr(XMPWithEXIFFiltered);
      CFIndex Length = CFDataGetLength(v8);
      if (BytePtr && Length != 0) {
        _cg_TIFFSetField(a2, 700, v11, v12, v13, v14, v15, v16, Length);
      }
    }
    if (v6) {
      CFRelease(v6);
    }
    if (v8) {
      CFRelease(v8);
    }
  }
  return 0;
}

uint64_t TIFFWritePlugin::fixScanlineForCIELab(TIFFWritePlugin *this, char *a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  unint64_t v5 = (a5 * (unint64_t)a4) >> 3;
  if (a3 && a5 == 8)
  {
    CFDataRef v6 = a2 + 2;
    do
    {
      *(v6 - 1) ^= 0x80u;
      *v6 ^= 0x80u;
      v6 += v5;
      --a3;
    }
    while (a3);
  }
  else if (a3 && a5 == 16)
  {
    unsigned int v7 = a2 + 4;
    do
    {
      *(v7 - 1) ^= 0x8000u;
      *v7 ^= 0x8000u;
      unsigned int v7 = (_WORD *)((char *)v7 + v5);
      --a3;
    }
    while (a3);
  }
  return 0;
}

uint64_t TIFFWritePlugin::writeOneImage(TIFFWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t TIFFWritePlugin::writeOne(uint64_t a1, uint64_t a2, IIOImageReadSession **a3, IIOImagePixelDataProvider *this, IIODictionary *a5)
{
  uint64_t v365 = *MEMORY[0x1E4F143B8];
  int AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(this);
  v343 = this;
  __int16 BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(this);
  unint64_t v360 = 0;
  unint64_t v361 = 0;
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    int v11 = *(_DWORD *)(a1 + 32);
    unsigned int v12 = v11 >> 24;
    uint64_t v13 = MEMORY[0x1E4F14390];
    if (v11 < 0)
    {
      int v14 = __maskrune(v12, 0x40000uLL);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    else
    {
      int v14 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x40000;
    }
    if (v14) {
      uint64_t v15 = (v11 >> 24);
    }
    else {
      uint64_t v15 = 46;
    }
    unsigned int v16 = v11 << 8 >> 24;
    if (v11 << 8 < 0)
    {
      int v17 = __maskrune(v16, 0x40000uLL);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    else
    {
      int v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = (v11 << 8 >> 24);
    }
    else {
      uint64_t v18 = 46;
    }
    unsigned int v19 = (__int16)v11 >> 8;
    if (v11 << 16 < 0)
    {
      int v20 = __maskrune(v19, 0x40000uLL);
      int v11 = *(_DWORD *)(a1 + 32);
    }
    else
    {
      int v20 = *(_DWORD *)(v13 + 4 * v19 + 60) & 0x40000;
    }
    if (v20) {
      uint64_t v21 = ((__int16)v11 >> 8);
    }
    else {
      uint64_t v21 = 46;
    }
    if ((v11 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000) != 0) {
        goto LABEL_22;
      }
    }
    else if (__maskrune((char)v11, 0x40000uLL))
    {
LABEL_22:
      int v22 = *(_DWORD *)(a1 + 32);
LABEL_25:
      ImageIOLog("  '%c%c%c%c' TIFFWritePlugin::writeOne\n", v15, v18, v21, (char)v22);
      goto LABEL_26;
    }
    LOBYTE(v22) = 46;
    goto LABEL_25;
  }
LABEL_26:
  uint64_t v23 = IIOImagePlus::sourceImageProvider(v343);
  SourceGeomCGColorSpaceRef ColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(v343);
  uint64_t v25 = 4294967246;
  size_t __n_4 = v23;
  if (!v23) {
    return v25;
  }
  uint32x4_t v26 = SourceGeomColorSpace;
  if (!SourceGeomColorSpace) {
    return v25;
  }
  __int16 v348 = BitmapInfo;
  unsigned __int16 NumberOfComponents = CGColorSpaceGetNumberOfComponents(SourceGeomColorSpace);
  CGColorSpaceModel Model = CGColorSpaceGetModel(v26);
  int Type = CGColorSpaceGetType();
  if (Type != 7)
  {
    v344 = v26;
    if (Model != kCGColorSpaceModelRGB)
    {
      uint64x2_t v29 = a3;
      char v346 = 0;
      v339 = 0;
      ColorTableCFIndex Count = 0;
      uint64_t Uint32ForKeyGroup = 0;
      uint64_t v34 = 0;
      goto LABEL_48;
    }
    if (IIODictionary::containsKeyGroup(a5, @"TileWidth", @"{TIFF}")) {
      uint64_t Uint32ForKeyGroup = (uint64_t)IIODictionary::getUint32ForKeyGroup(a5, @"TileWidth", @"{TIFF}");
    }
    else {
      uint64_t Uint32ForKeyGroup = 0;
    }
    if (IIODictionary::containsKeyGroup(a5, @"TileLength", @"{TIFF}"))
    {
      CFDictionaryRef v35 = IIODictionary::getUint32ForKeyGroup(a5, @"TileLength", @"{TIFF}");
      uint64_t v34 = (uint64_t)v35;
      v339 = 0;
      if (!Uint32ForKeyGroup || !v35)
      {
        char v346 = 1;
        uint64x2_t v29 = a3;
        ColorTableCFIndex Count = 0;
        goto LABEL_47;
      }
      uint64x2_t v29 = a3;
      v339 = 0;
      ColorTableCFIndex Count = 0;
      BOOL v36 = ((v35 | Uint32ForKeyGroup) & 0xF) == 0;
      if (((v35 | Uint32ForKeyGroup) & 0xF) != 0) {
        uint64_t v37 = 256;
      }
      else {
        uint64_t v37 = Uint32ForKeyGroup;
      }
      uint64_t Uint32ForKeyGroup = v37;
      if (v36) {
        uint64_t v34 = v35;
      }
      else {
        uint64_t v34 = 256;
      }
    }
    else
    {
      uint64x2_t v29 = a3;
      v339 = 0;
      ColorTableCFIndex Count = 0;
      uint64_t v34 = 0;
    }
    char v346 = 1;
LABEL_47:
    CGColorSpaceModel Model = kCGColorSpaceModelRGB;
    goto LABEL_48;
  }
  uint64x2_t v29 = a3;
  BaseCGColorSpaceRef ColorSpace = CGColorSpaceGetBaseColorSpace(v26);
  size_t v31 = CGColorSpaceGetNumberOfComponents(BaseColorSpace);
  ColorTableCFIndex Count = CGColorSpaceGetColorTableCount(v26);
  v339 = (uint8_t *)malloc_type_malloc(ColorTableCount * v31, 0x100004077774924uLL);
  CGColorSpaceGetColorTable(v26, v339);
  long double v33 = CGColorSpaceGetBaseColorSpace(v26);
  CGColorSpaceGetType();
  v344 = v33;
  CGColorSpaceModel Model = CGColorSpaceGetModel(v33);
  uint64_t Uint32ForKeyGroup = 0;
  uint64_t v34 = 0;
  char v346 = 1;
LABEL_48:
  uint64_t v38 = IIOImageSource::count(v343);
  uint64_t v39 = IIO_Reader::testHeaderSize(v343);
  unsigned int v353 = v38;
  _cg_TIFFSetField(a2, 256, v40, v41, v42, v43, v44, v45, v38);
  uint64_t v342 = v39;
  _cg_TIFFSetField(a2, 257, v46, v47, v48, v49, v50, v51, v39);
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    ImageIOLog("\n");
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    TIFFTAG_IMAGEWIDTH/TIFFTAG_IMAGEHEIGHT: %dx%d\n", v38, v39);
    }
  }
  _cg_TIFFSetField(a2, 284, v52, v53, v54, v55, v56, v57, 1);
  if (AlphaInfo) {
    unsigned __int16 v64 = NumberOfComponents + 1;
  }
  else {
    unsigned __int16 v64 = NumberOfComponents;
  }
  uint64_t v65 = v64;
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("                   TIFFTAG_SAMPLESPERPIXEL: %d\n", v64);
  }
  unsigned int v66 = v65;
  _cg_TIFFSetField(a2, 277, v58, v59, v60, v61, v62, v63, v65);
  unsigned int v73 = v353;
  v352 = v29;
  if (IIODictionary::containsKey(a5, @"Orientation")) {
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(a5, @"Orientation");
  }
  else {
    unsigned int Uint32ForKey = 1;
  }
  if (Uint32ForKey - 9 < 0xFFFFFFF8) {
    int v75 = 1;
  }
  else {
    int v75 = Uint32ForKey;
  }
  _cg_TIFFSetField(a2, 274, v67, v68, v69, v70, v71, v72, (unsigned __int16)v75);
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("                       TIFFTAG_ORIENTATION: %d\n", v75);
  }
  uint64_t v341 = v34;
  unint64_t v362 = 0;
  v363[0] = 0;
  if (AlphaInfo)
  {
    __int16 v82 = AlphaInfo == 3 ? 2 : 1;
    LOWORD(v364[0]) = v82;
    _cg_TIFFSetField(a2, 338, v76, v77, v78, v79, v80, v81, 1);
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("                      TIFFTAG_EXTRASAMPLES: %d\n", LOWORD(v364[0]));
    }
  }
  unsigned __int16 __n = _cg_GifLastError((uint64_t)v343);
  _cg_TIFFSetField(a2, 258, v83, v84, v85, v86, v87, v88, __n);
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("                     TIFFTAG_BITSPERSAMPLE: %d\n", __n);
  }
  uint64_t v95 = 3;
  if ((v348 & 0x100) != 0) {
    int v96 = 3;
  }
  else {
    int v96 = 1;
  }
  if ((v348 & 0x100) == 0) {
    uint64_t v95 = 1;
  }
  _cg_TIFFSetField(a2, 339, v89, v90, v91, v92, v93, v94, v95);
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("                      TIFFTAG_SAMPLEFORMAT: %d\n", v96);
  }
  if (Type == 7) {
    uint64_t v103 = 3;
  }
  else {
    uint64_t v103 = 2;
  }
  if ((v346 & 1) == 0)
  {
    if (Model == kCGColorSpaceModelLab)
    {
      uint64_t v103 = 8;
    }
    else if (Model == kCGColorSpaceModelCMYK)
    {
      uint64_t v103 = 5;
    }
    else if (Model)
    {
      uint64_t v103 = 2;
    }
    else
    {
      uint64_t v103 = IIOImageSource::reader(v343) == 0;
    }
  }
  _cg_TIFFSetField(a2, 262, v97, v98, v99, v100, v101, v102, v103);
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("                       TIFFTAG_PHOTOMETRIC: %d\n", v103);
  }
  unsigned __int16 v104 = (unsigned __int16)IIODictionary::getUint32ForKeyGroup(a5, @"Compression", @"{TIFF}");
  if (v341) {
    BOOL v111 = Uint32ForKeyGroup == 0;
  }
  else {
    BOOL v111 = 1;
  }
  if (v111) {
    unsigned __int16 v112 = v104;
  }
  else {
    unsigned __int16 v112 = 1;
  }
  if (v112 > 7u)
  {
    if (v112 == 8 || v112 == 32773) {
      goto LABEL_106;
    }
LABEL_103:
    if (Model == kCGColorSpaceModelMonochrome && __n == 1 && v66 == 1) {
      goto LABEL_106;
    }
    goto LABEL_107;
  }
  if (v112 == 5)
  {
LABEL_106:
    _cg_TIFFSetField(a2, 259, v105, v106, v107, v108, v109, v110, v112);
    goto LABEL_107;
  }
  if (v112 != 7) {
    goto LABEL_103;
  }
  unsigned __int16 v112 = 1;
  if (__n == 8 && Model < kCGColorSpaceModelCMYK)
  {
    unsigned __int16 v112 = 7;
    goto LABEL_106;
  }
LABEL_107:
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("                       TIFFTAG_COMPRESSION: %d\n", v112);
  }
  _cg_TIFFSetField(a2, 266, v105, v106, v107, v108, v109, v110, 1);
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("                         TIFFTAG_FILLORDER: %d\n", 1);
  }
  if (__n == 8 && v112 == 5)
  {
    _cg_TIFFSetField(a2, 317, v114, v115, v116, v117, v118, v119, 2);
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("                         TIFFTAG_PREDICTOR: %d\n", 2);
    }
  }
  if (_cg_TIFFScanlineSize(a2, v113, v114, v115, v116, v117, v118, v119) > __n_4) {
    goto LABEL_244;
  }
  if (Uint32ForKeyGroup) {
    BOOL v126 = v341 == 0;
  }
  else {
    BOOL v126 = 1;
  }
  int v127 = v126;
  int v349 = v127;
  if (v126)
  {
    if (__n < 2u)
    {
      if ((unsigned __int16)(v112 - 3) > 1u) {
        TIFFWritePlugin::writeOne(v112, __n);
      }
      _cg_TIFFSetField(a2, 278, v120, v121, v122, v123, v124, v125, v342);
      char v131 = BYTE2(gIIODebugFlags);
      LODWORD(v130) = v342;
    }
    else
    {
      unint64_t v128 = 0x20000 / __n_4;
      unint64_t v129 = (0x20000 / __n_4) & 0x3FFF8;
      if (((0x20000 / __n_4) & 0x3FFF8) == 0) {
        LODWORD(v129) = 8;
      }
      if (v112 == 7) {
        LODWORD(v128) = v129;
      }
      if (v128 <= 1) {
        uint64_t v130 = 1;
      }
      else {
        uint64_t v130 = v128;
      }
      _cg_TIFFSetField(a2, 278, v120, v121, v122, v123, v124, v125, v130);
      char v131 = BYTE2(gIIODebugFlags);
    }
    if ((v131 & 3) != 0) {
      ImageIOLog("                      TIFFTAG_ROWSPERSTRIP: %d\n", v130);
    }
  }
  if (IIODictionary::containsKey(a5, @"DPIWidth")
    && IIODictionary::containsKey(a5, @"DPIHeight"))
  {
    double FloatForKey = IIODictionary::getFloatForKey(a5, @"DPIWidth");
    float v133 = *(float *)&FloatForKey;
    double v134 = IIODictionary::getFloatForKey(a5, @"DPIHeight");
    float v135 = *(float *)&v134;
    *(double *)&uint64_t v136 = v133;
    _cg_TIFFSetField(a2, 282, v137, v138, v139, v140, v141, v142, v136);
    *(double *)&uint64_t v143 = v135;
    _cg_TIFFSetField(a2, 283, v144, v145, v146, v147, v148, v149, v143);
    _cg_TIFFSetField(a2, 296, v150, v151, v152, v153, v154, v155, 2);
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("   TIFFTAG_XRESOLUTION/TIFFTAG_YRESOLUTION: %g %g\n", *(double *)&v136, *(double *)&v143);
    }
  }
  else
  {
    if (IIODictionary::containsKeyGroup(a5, @"ResolutionUnit", @"{TIFF}")) {
      uint64_t v168 = IIODictionary::getUint32ForKeyGroup(a5, @"ResolutionUnit", @"{TIFF}");
    }
    else {
      uint64_t v168 = 2;
    }
    _cg_TIFFSetField(a2, 296, v162, v163, v164, v165, v166, v167, v168);
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("                    TIFFTAG_RESOLUTIONUNIT: %d\n", v168);
    }
    if (IIODictionary::containsKeyGroup(a5, @"DPIWidth", @"{TIFF}"))
    {
      if (IIODictionary::containsKeyGroup(a5, @"DPIHeight", @"{TIFF}"))
      {
        double FloatForKeyGroup = IIODictionary::getFloatForKeyGroup(a5, @"DPIWidth", @"{TIFF}");
        float v170 = *(float *)&FloatForKeyGroup;
        double v171 = IIODictionary::getFloatForKeyGroup(a5, @"DPIHeight", @"{TIFF}");
        float v172 = *(float *)&v171;
        *(double *)&uint64_t v173 = v170;
        _cg_TIFFSetField(a2, 282, v174, v175, v176, v177, v178, v179, v173);
        *(double *)&uint64_t v180 = v172;
        _cg_TIFFSetField(a2, 283, v181, v182, v183, v184, v185, v186, v180);
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("   TIFFTAG_XRESOLUTION/TIFFTAG_YRESOLUTION: %d %d\n", v173, v180);
        }
      }
    }
  }
  if (Type == 7)
  {
    if (ColorTableCount > 0x100 || (1 << *(_WORD *)(a2 + 116)) > 0x100)
    {
      _cg_jpeg_mem_term("writeOne", 538, "bitsPerSample: %d  colorTableCount: %d\n", *(unsigned __int16 *)(a2 + 116), ColorTableCount);
      goto LABEL_244;
    }
    memset(v364, 0, sizeof(v364));
    memset(&v363[1], 0, 1024);
    if (ColorTableCount)
    {
      uint64_t v187 = (char *)&v363[1] + 1;
      CGDataProviderRef v188 = (char *)&v363[65] + 1;
      CGSize v189 = (char *)(v339 + 2);
      unsigned int v190 = (char *)v364 + 1;
      do
      {
        char v191 = *(v189 - 2);
        *unsigned int v190 = v191;
        *(v190 - 1) = v191;
        char v192 = *(v189 - 1);
        *CGDataProviderRef v188 = v192;
        *(v188 - 1) = v192;
        char v193 = *v189;
        v189 += 3;
        unsigned char *v187 = v193;
        *(v187 - 1) = v193;
        v187 += 2;
        v188 += 2;
        v190 += 2;
        --ColorTableCount;
      }
      while (ColorTableCount);
    }
    _cg_TIFFSetField(a2, 320, v156, v157, v158, v159, v160, v161, (uint64_t)v364);
  }
  if (IIODictionary::containsKeyGroup(a5, @"DocumentName", @"{TIFF}"))
  {
    CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(a5, @"DocumentName", @"{TIFF}");
    IIOString::IIOString((IIOString *)v364, ObjectForKeyGroup);
    CFStringRef v195 = IIOString::utf8String((IIOString *)v364);
    _cg_TIFFSetField(a2, 269, v196, v197, v198, v199, v200, v201, (uint64_t)v195);
    IIOString::~IIOString((IIOString *)v364);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v364, ObjectForKeyGroup);
      uint64_t v202 = (const char *)IIOString::utf8String((IIOString *)v364);
      ImageIOLog("                      TIFFTAG_DOCUMENTNAME: %s\n", v202);
      IIOString::~IIOString((IIOString *)v364);
    }
  }
  if (IIODictionary::containsKeyGroup(a5, @"ImageDescription", @"{TIFF}"))
  {
    CFDictionaryRef v203 = IIODictionary::getObjectForKeyGroup(a5, @"ImageDescription", @"{TIFF}");
    IIOString::IIOString((IIOString *)v364, v203);
    CFStringRef v204 = IIOString::utf8String((IIOString *)v364);
    _cg_TIFFSetField(a2, 270, v205, v206, v207, v208, v209, v210, (uint64_t)v204);
    IIOString::~IIOString((IIOString *)v364);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v364, v203);
      unsigned int v211 = (const char *)IIOString::utf8String((IIOString *)v364);
      ImageIOLog("                  TIFFTAG_IMAGEDESCRIPTION: %s\n", v211);
      IIOString::~IIOString((IIOString *)v364);
    }
  }
  if (IIODictionary::containsKeyGroup(a5, @"Make", @"{TIFF}"))
  {
    CFDictionaryRef v212 = IIODictionary::getObjectForKeyGroup(a5, @"Make", @"{TIFF}");
    IIOString::IIOString((IIOString *)v364, v212);
    CFStringRef v213 = IIOString::utf8String((IIOString *)v364);
    _cg_TIFFSetField(a2, 271, v214, v215, v216, v217, v218, v219, (uint64_t)v213);
    IIOString::~IIOString((IIOString *)v364);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v364, v212);
      size_t v220 = (const char *)IIOString::utf8String((IIOString *)v364);
      ImageIOLog("                              TIFFTAG_MAKE: %s\n", v220);
      IIOString::~IIOString((IIOString *)v364);
    }
  }
  if (IIODictionary::containsKeyGroup(a5, @"Model", @"{TIFF}"))
  {
    CFDictionaryRef v221 = IIODictionary::getObjectForKeyGroup(a5, @"Model", @"{TIFF}");
    IIOString::IIOString((IIOString *)v364, v221);
    CFStringRef v222 = IIOString::utf8String((IIOString *)v364);
    _cg_TIFFSetField(a2, 272, v223, v224, v225, v226, v227, v228, (uint64_t)v222);
    IIOString::~IIOString((IIOString *)v364);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v364, v221);
      int v229 = (const char *)IIOString::utf8String((IIOString *)v364);
      ImageIOLog("                             TIFFTAG_MODEL: %s\n", v229);
      IIOString::~IIOString((IIOString *)v364);
    }
  }
  if (IIODictionary::containsKeyGroup(a5, @"Software", @"{TIFF}"))
  {
    CFDictionaryRef v230 = IIODictionary::getObjectForKeyGroup(a5, @"Software", @"{TIFF}");
    IIOString::IIOString((IIOString *)v364, v230);
    CFStringRef v231 = IIOString::utf8String((IIOString *)v364);
    _cg_TIFFSetField(a2, 305, v232, v233, v234, v235, v236, v237, (uint64_t)v231);
    IIOString::~IIOString((IIOString *)v364);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v364, v230);
      unsigned int v238 = (const char *)IIOString::utf8String((IIOString *)v364);
      ImageIOLog("                          TIFFTAG_SOFTWARE: %s\n", v238);
      IIOString::~IIOString((IIOString *)v364);
    }
  }
  if (IIODictionary::containsKeyGroup(a5, @"Artist", @"{TIFF}"))
  {
    CFDictionaryRef v239 = IIODictionary::getObjectForKeyGroup(a5, @"Artist", @"{TIFF}");
    IIOString::IIOString((IIOString *)v364, v239);
    CFStringRef v240 = IIOString::utf8String((IIOString *)v364);
    _cg_TIFFSetField(a2, 315, v241, v242, v243, v244, v245, v246, (uint64_t)v240);
    IIOString::~IIOString((IIOString *)v364);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v364, v239);
      v247 = (const char *)IIOString::utf8String((IIOString *)v364);
      ImageIOLog("                            TIFFTAG_ARTIST: %s\n", v247);
      IIOString::~IIOString((IIOString *)v364);
    }
  }
  if (IIODictionary::containsKeyGroup(a5, @"HostComputer", @"{TIFF}"))
  {
    CFDictionaryRef v248 = IIODictionary::getObjectForKeyGroup(a5, @"HostComputer", @"{TIFF}");
    IIOString::IIOString((IIOString *)v364, v248);
    CFStringRef v249 = IIOString::utf8String((IIOString *)v364);
    _cg_TIFFSetField(a2, 316, v250, v251, v252, v253, v254, v255, (uint64_t)v249);
    IIOString::~IIOString((IIOString *)v364);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v364, v248);
      v256 = (const char *)IIOString::utf8String((IIOString *)v364);
      ImageIOLog("                      TIFFTAG_HOSTCOMPUTER: %s\n", v256);
      IIOString::~IIOString((IIOString *)v364);
    }
  }
  if (IIODictionary::containsKeyGroup(a5, @"Copyright", @"{TIFF}"))
  {
    CFDictionaryRef v257 = IIODictionary::getObjectForKeyGroup(a5, @"Copyright", @"{TIFF}");
    IIOString::IIOString((IIOString *)v364, v257);
    CFStringRef v258 = IIOString::utf8String((IIOString *)v364);
    _cg_TIFFSetField(a2, 33432, v259, v260, v261, v262, v263, v264, (uint64_t)v258);
    IIOString::~IIOString((IIOString *)v364);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v364, v257);
      v265 = (const char *)IIOString::utf8String((IIOString *)v364);
      ImageIOLog("                         TIFFTAG_COPYRIGHT: %s\n", v265);
      IIOString::~IIOString((IIOString *)v364);
    }
  }
  int v266 = IIODictionary::containsKeyGroup(a5, @"DateTime", @"{TIFF}");
  if (v266)
  {
    CFDictionaryRef v267 = IIODictionary::getObjectForKeyGroup(a5, @"DateTime", @"{TIFF}");
    IIOString::IIOString((IIOString *)v364, v267);
    CFStringRef v268 = IIOString::utf8String((IIOString *)v364);
    _cg_TIFFSetField(a2, 306, v269, v270, v271, v272, v273, v274, (uint64_t)v268);
    IIOString::~IIOString((IIOString *)v364);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      IIOString::IIOString((IIOString *)v364, v267);
      v275 = (const char *)IIOString::utf8String((IIOString *)v364);
      ImageIOLog("                          TIFFTAG_DATETIME: %s\n", v275);
      IIOString::~IIOString((IIOString *)v364);
    }
  }
  TIFFWritePlugin::writeIPTCData(v266, a2, a5);
  BOOL BoolForKey = IIODictionary::getBoolForKey(a5, @"kCGImageMetadataShouldExcludeXMP");
  if (!BoolForKey) {
    TIFFWritePlugin::writeXMPData(BoolForKey, a2, a5);
  }
  uint64_t Ref = (CGImage *)IIOImageSource::imageReadRef(v343);
  uint64_t RenderingIntent = CGImageGetRenderingIntent(Ref);
  TIFFWritePlugin::writeICCData(RenderingIntent, a2, v344, RenderingIntent);
  unint64_t v279 = myTIFFSeekProc(v29, 0, 2);
  v363[0] = 0;
  uint64_t ExifBufferFromPropertiesTIFF = CreateExifBufferFromPropertiesTIFF(a5, v353, v342, v279, v363);
  if (v363[0])
  {
    v287 = (void *)ExifBufferFromPropertiesTIFF;
    if (ExifBufferFromPropertiesTIFF)
    {
      if (_cg_TIFFSetField(a2, 34665, v281, v282, v283, v284, v285, v286, v279)) {
        myTIFFWriteProc(v352, v287, v363[0]);
      }
      free(v287);
    }
  }
  unint64_t v288 = myTIFFSeekProc(v352, 0, 2);
  unint64_t v362 = 0;
  uint64_t v290 = CreateGPSBufferFromPropertiesTIFF(a5, v353, v342, v288, &v362, v289);
  if (v362)
  {
    v297 = (void *)v290;
    if (v290)
    {
      if (_cg_TIFFSetField(a2, 34853, v291, v292, v293, v294, v295, v296, v288)) {
        myTIFFWriteProc(v352, v297, v362);
      }
      free(v297);
    }
  }
  if (v349)
  {
    v298 = IIOImagePixelDataProvider::createEncodingTempBuffer(v343, &v361, &v360);
    int v299 = v342;
    if (v342)
    {
      unsigned int v300 = 0;
      unint64_t v301 = v361;
      while (1)
      {
        if (v301 + v300 > v342)
        {
          unint64_t v360 = __n_4 * (v299 - v300);
          unint64_t v361 = v299 - v300;
        }
        uint64_t Bytes = IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))v343, v298);
        if (Bytes != v360)
        {
          _cg_jpeg_mem_term("writeOne", 703, "CGImagePixelDataProviderGetBytes returned: %ld - expected: %ld\n", Bytes, v360);
          int v299 = v342;
          goto LABEL_214;
        }
        unint64_t v301 = v361;
        if (v361) {
          break;
        }
LABEL_208:
        v300 += v301;
        int v299 = v342;
        if (v300 >= v342) {
          goto LABEL_214;
        }
      }
      unint64_t v307 = 0;
      v308 = (char *)v298;
      while (1)
      {
        if (v103 == 8) {
          TIFFWritePlugin::fixScanlineForCIELab((TIFFWritePlugin *)Bytes, v308, v353, v66, __n);
        }
        uint64_t Bytes = _cg_TIFFWriteScanline(a2, (uint64_t)v308, v300 + v307, 0, v303, v304, v305, v306);
        if ((Bytes & 0x80000000) != 0) {
          goto LABEL_245;
        }
        ++v307;
        v308 += __n_4;
        unint64_t v301 = v361;
        if (v361 <= v307) {
          goto LABEL_208;
        }
      }
    }
    unsigned int v300 = 0;
LABEL_214:
    if (v300 != v299 || !_cg_TIFFWriteDirectory(a2))
    {
LABEL_245:
      uint64_t v25 = 4294967246;
      v311 = v339;
      goto LABEL_246;
    }
    goto LABEL_241;
  }
  unsigned int v309 = (__n + 7) >> 3;
  int v345 = v309 * v66;
  unint64_t v310 = Uint32ForKeyGroup * (unint64_t)(v309 * v66);
  v311 = v339;
  if ((v310 & 0xFFFFFFFF00000000) == 0)
  {
    unint64_t v312 = v310 * (unint64_t)v341;
    if ((v312 & 0xFFFFFFFF00000000) == 0)
    {
      unsigned int v338 = Uint32ForKeyGroup * v309 * v66;
      unint64_t v360 = (__n_4 * v341);
      if (((__n_4 * (unint64_t)v341) & 0xFFFFFFFF00000000) == 0)
      {
        size_t v347 = v312;
        v313 = (char *)malloc_type_malloc(v312, 0xD29E41A2uLL);
        v351 = (char *)malloc_type_malloc((__n_4 * v341), 0xB8721C3uLL);
        _cg_TIFFSetField(a2, 322, v314, v315, v316, v317, v318, v319, Uint32ForKeyGroup);
        _cg_TIFFSetField(a2, 323, v320, v321, v322, v323, v324, v325, v341);
        unsigned int v326 = v342;
        if (v342)
        {
          unsigned int v327 = 0;
          int v328 = Uint32ForKeyGroup * v309 * v66;
          LODWORD(v354) = v341;
          do
          {
            unsigned int v340 = v327 + v341;
            if (v327 + v341 > v326)
            {
              uint64_t v354 = v326 - v327;
              unint64_t v360 = __n_4 * v354;
              bzero(v313, v347);
            }
            IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))v343, v351);
            if (v73)
            {
              int v331 = 0;
              unsigned int v332 = 0;
              unsigned int __na = v338;
              do
              {
                unsigned int v333 = v332 + Uint32ForKeyGroup;
                if (v332 + Uint32ForKeyGroup > v73)
                {
                  unsigned int __na = (v73 - v332) * v345;
                  bzero(v313, v347);
                }
                if (v354)
                {
                  int v334 = 0;
                  uint64_t v335 = v354;
                  v336 = &v351[v331];
                  do
                  {
                    memcpy(&v313[v334], v336, __na);
                    v334 += v328;
                    v336 += __n_4;
                    --v335;
                  }
                  while (v335);
                }
                unsigned int v73 = v353;
                if (_cg_TIFFWriteTile(a2, (unsigned __int8 *)v313, v332, v327, 0, 0, v329, v330) == -1) {
                  LogError("writeOne", 792, "*** TIFFWriteTile returned: %d\n", -1);
                }
                v331 += v328;
                v332 += Uint32ForKeyGroup;
              }
              while (v333 < v353);
            }
            v327 += v341;
            unsigned int v326 = v342;
          }
          while (v340 < v342);
        }
        if (v313) {
          free(v313);
        }
        if (v351) {
          free(v351);
        }
        v298 = 0;
        if (!_cg_TIFFWriteDirectory(a2)) {
          goto LABEL_245;
        }
LABEL_241:
        v311 = v339;
        uint64_t v25 = 0;
        goto LABEL_246;
      }
LABEL_244:
      v298 = 0;
      goto LABEL_245;
    }
  }
  v298 = 0;
  uint64_t v25 = 4294967246;
LABEL_246:
  if (v311) {
    free(v311);
  }
  if (v298) {
    free(v298);
  }
  return v25;
}

void sub_188778DF4(_Unwind_Exception *a1)
{
}

uint64_t TIFFWritePlugin::writeAll(IIOImageDestination **this)
{
  if (IIOWritePlugin::getImageCount(this)) {
    operator new();
  }
  return 4294967246;
}

void sub_188779008(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C40F2E54FF0);
  _Unwind_Resume(a1);
}

uint64_t TIFFWritePlugin::writeOne(TIFFWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967292;
}

void IIO_ReaderHandler::~IIO_ReaderHandler(IIO_ReaderHandler *this)
{
  *(void *)this = &unk_1ED4E4130;
  uint64_t v1 = (void **)((char *)this + 16);
  std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::~__hash_table((uint64_t)this + 40);
  double v2 = v1;
  std::vector<std::unique_ptr<IIO_Reader>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

{
  void **v2;
  void **v3;

  *(void *)this = &unk_1ED4E4130;
  double v2 = (void **)((char *)this + 16);
  std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::~__hash_table((uint64_t)this + 40);
  unsigned int v3 = v2;
  std::vector<std::unique_ptr<IIO_Reader>>::__destroy_vector::operator()[abi:ne180100](&v3);
  MEMORY[0x18C11C0E0](this, 0x10A1C40EEBF52FBLL);
}

IIO_Reader *IIO_ReaderHandler::readerForUTTypeAndOSType(IIO_ReaderHandler *this, const __CFString *a2, int a3)
{
  unsigned int v3 = (IIO_Reader **)*((void *)this + 2);
  int v4 = (IIO_Reader **)*((void *)this + 3);
  if (v3 == v4) {
    return 0;
  }
  while (1)
  {
    CFStringRef v7 = (const __CFString *)IIO_Reader::utType(*v3);
    if (CFEqual(v7, a2) && IIO_Reader::osType(*v3) == a3) {
      break;
    }
    if (++v3 == v4) {
      return 0;
    }
  }
  return *v3;
}

__CFString *IIO_ReaderHandler::typeForPathExtension(IIO_ReaderHandler *this, CFStringRef theString)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  long long v6 = xmmword_1889AA7F2;
  char v7 = 0;
  if (!theString || !CFStringGetCString(theString, (char *)&v6 + 1, 15, 0x600u)) {
    return 0;
  }
  if (strcasecmp((const char *)&v6, ".tif"))
  {
    int v4 = (IIO_Reader **)*((void *)this + 2);
    unsigned int v3 = (IIO_Reader **)*((void *)this + 3);
    while (v4 != v3)
    {
      if ((*(unsigned int (**)(IIO_Reader *, long long *))(*(void *)*v4 + 144))(*v4, &v6)) {
        return (__CFString *)IIO_Reader::utType(*v4);
      }
      ++v4;
    }
    return 0;
  }
  if (IIO_ReaderHandler::readerForUTType(this, @"public.tiff")) {
    return @"public.tiff";
  }
  else {
    return 0;
  }
}

IIO_Reader *IIO_ReaderHandler::typeFromDataAtPath(IIO_ReaderHandler *a1, const __CFString *a2, __CFString *a3, uint64_t a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    LogError("typeFromDataAtPath", 507, "*** ERROR: path parameter is nil\n");
    return 0;
  }
  bzero(v23, 0x400uLL);
  size_t v8 = *((void *)a1 + 1);
  uint64_t v9 = malloc_type_malloc(v8, 0x74EBB83BuLL);
  if (!v9) {
    return 0;
  }
  uint64_t v10 = v9;
  if (!_CFStringGetFileSystemRepresentation()) {
    goto LABEL_15;
  }
  int v11 = open(v23, 0, 0);
  int v12 = v11;
  if ((gIIODebugFlags & 0x200000000000) != 0) {
    ImageIOLog(">>> %s: opening file [%d] '%s'\n", "typeFromDataAtPath", v11, v23);
  }
  if (v12 < 0)
  {
LABEL_15:
    unsigned int v19 = 0;
  }
  else
  {
    ssize_t v13 = pread(v12, v10, v8, 0);
    if (v13 < 1)
    {
      unsigned int v19 = 0;
    }
    else
    {
      unint64_t v14 = v13;
      if (!a3 && (*(_DWORD *)(a4 + 16) & 2) != 0)
      {
        CFURLRef v15 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, kCFURLPOSIXPathStyle, 0);
        if (v15)
        {
          CFURLRef v16 = v15;
          CFStringRef v17 = CFURLCopyPathExtension(v15);
          if (v17)
          {
            CFStringRef v18 = v17;
            a3 = IIO_ReaderHandler::typeForPathExtension(a1, v17);
            CFRelease(v18);
          }
          else
          {
            a3 = 0;
          }
          CFRelease(v16);
        }
        else
        {
          a3 = 0;
        }
      }
      long long v21 = *(_OWORD *)a4;
      uint64_t v22 = *(void *)(a4 + 16);
      unsigned int v19 = IIO_ReaderHandler::typeForBytes((IIO_Reader ***)a1, (uint64_t)v10, v14, a3, &v21);
    }
    if ((gIIODebugFlags & 0x200000000000) != 0) {
      ImageIOLog("<<< %s: closing file [%d] '%s'\n", "typeFromDataAtPath", v12, v23);
    }
    close(v12);
  }
  free(v10);
  return v19;
}

IIO_Reader *IIO_ReaderHandler::typeFromURL(IIO_ReaderHandler *a1, const void *a2, __CFString *a3, long long *a4)
{
  if (!a2)
  {
    LogError("typeFromURL", 571, "*** Error: url parameter is nil\n");
    return 0;
  }
  CFTypeID v8 = CFURLGetTypeID();
  if (v8 != CFGetTypeID(a2))
  {
    LogError("typeFromURL", 572, "*** Error: url parameter is not a CFURLRef\n");
    return 0;
  }
  CFStringRef v9 = CFURLCopyPathExtension((CFURLRef)a2);
  if (!a3) {
    a3 = IIO_ReaderHandler::typeForPathExtension(a1, v9);
  }
  CFStringRef v10 = IIO_CFURLCopyResolvedFileSystemPath((const __CFURL *)a2);
  if (v10)
  {
    CFStringRef v11 = v10;
    long long v18 = *a4;
    uint64_t v19 = *((void *)a4 + 2);
    int v12 = IIO_ReaderHandler::typeFromDataAtPath(a1, v10, a3, (uint64_t)&v18);
    CFRelease(v11);
    if (!v9) {
      return v12;
    }
    goto LABEL_12;
  }
  CGDataProviderRef v13 = CGDataProviderCreateWithURL((CFURLRef)a2);
  if (v13)
  {
    unint64_t v14 = v13;
    long long v16 = *a4;
    uint64_t v17 = *((void *)a4 + 2);
    int v12 = IIO_ReaderHandler::typeForDataProvider((uint64_t)a1, (uint64_t)v13, 0, (uint64_t)&v16, 0);
    CGDataProviderRelease(v14);
    if (!v9) {
      return v12;
    }
    goto LABEL_12;
  }
  int v12 = 0;
  if (v9) {
LABEL_12:
  }
    CFRelease(v9);
  return v12;
}

IIO_Reader *IIO_ReaderHandler::typeForDataProvider(uint64_t a1, uint64_t a2, __CFString *a3, uint64_t a4, BOOL *a5)
{
  if (!a2)
  {
    LogError("typeForDataProvider", 634, "*** ERROR: provider parameter is nil\n");
    return 0;
  }
  if (a5) {
    *a5 = 1;
  }
  size_t v9 = *(void *)(a1 + 8);
  CFStringRef v10 = malloc_type_malloc(v9, 0x9854BEEFuLL);
  if (!v10) {
    return 0;
  }
  CFStringRef v11 = v10;
  BytesAtPositiounsigned int n = CGDataProviderGetBytesAtPosition();
  if (a5) {
    *a5 = BytesAtPosition < v9;
  }
  long long v15 = *(_OWORD *)a4;
  uint64_t v16 = *(void *)(a4 + 16);
  CGDataProviderRef v13 = IIO_ReaderHandler::typeForBytes((IIO_Reader ***)a1, (uint64_t)v11, BytesAtPosition, a3, &v15);
  free(v11);
  return v13;
}

void ___ZN17IIO_ReaderHandler18copySupportedTypesEv_block_invoke(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      unint64_t v5 = *(CFMutableArrayRef **)(a1 + 32);
      IIOArray::addObject(v5, cf);
    }
  }
}

uint64_t IIO_ReaderHandler::disableRAWPlugins(IIO_ReaderHandler *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 2);
  if (v1 != *((uint64_t **)this + 3))
  {
    do
    {
      if ((*(unsigned int (**)(void))(*(void *)*v1 + 152))())
      {
        std::__unwrap_and_dispatch[abi:ne180100]<std::__overload<std::__move_loop<std::_ClassicAlgPolicy>,std::__move_trivial>,std::unique_ptr<IIO_Reader> *,std::unique_ptr<IIO_Reader> *,std::unique_ptr<IIO_Reader> *,0>(v1 + 1, *((uint64_t **)this + 3), v1);
        CFTypeID v4 = v3;
        unint64_t v5 = (uint64_t *)*((void *)this + 3);
        if (v5 != v3)
        {
          do
          {
            uint64_t v7 = *--v5;
            uint64_t v6 = v7;
            uint64_t *v5 = 0;
            if (v7) {
              (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
            }
          }
          while (v5 != v4);
        }
        *((void *)this + 3) = v4;
      }
      else
      {
        ++v1;
        CFTypeID v4 = (uint64_t *)*((void *)this + 3);
      }
    }
    while (v1 != v4);
  }
  return 0;
}

uint64_t IIO_ReaderHandler::xpcQueueForReader(os_unfair_lock_s *this, IIO_Reader *a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = a2;
  if (IIO_ReaderHandler::xpcQueueForReader(IIO_Reader *)::poolSizeCheck != -1) {
    dispatch_once(&IIO_ReaderHandler::xpcQueueForReader(IIO_Reader *)::poolSizeCheck, &__block_literal_global_53);
  }
  unsigned int v3 = this + 20;
  os_unfair_lock_lock(this + 20);
  CFTypeID v4 = this + 10;
  unint64_t v5 = (char *)std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::find<IIO_Reader *>(&this[10]._os_unfair_lock_opaque, &v39);
  if (!v5)
  {
    *(_OWORD *)__str = 0u;
    long long v42 = 0u;
    unint64_t v5 = std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__emplace_unique_key_args<IIO_Reader *,IIO_Reader *&,IIO_ReaderHandler::QueuePool>((uint64_t)v4, &v39, (uint64_t *)&v39, (long long *)__str);
    v40[0] = (void **)__str;
    std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__destroy_vector::operator()[abi:ne180100](v40);
  }
  uint64_t v6 = *((void *)v5 + 3);
  uint64_t v7 = v5 + 24;
  unint64_t v8 = (*((void *)v5 + 4) - v6) >> 4;
  if (v8 < IIO_ReaderHandler::xpcQueueForReader(IIO_Reader *)::gPoolSize)
  {
    bzero(__str, 0x400uLL);
    if (!v39)
    {
      snprintf(__str, 0x400uLL, "com.apple.ImageIOXPCService.General.%zu");
LABEL_30:
      dispatch_workloop_t v24 = dispatch_workloop_create(__str);
      unint64_t v25 = *((void *)v5 + 5);
      uint32x4_t v26 = (dispatch_workloop_t *)*((void *)v5 + 4);
      if ((unint64_t)v26 >= v25)
      {
        uint64_t v29 = ((uint64_t)v26 - *v7) >> 4;
        unint64_t v30 = v29 + 1;
        if ((unint64_t)(v29 + 1) >> 60) {
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v31 = v25 - *v7;
        if (v31 >> 3 > v30) {
          unint64_t v30 = v31 >> 3;
        }
        if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v32 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v32 = v30;
        }
        int v40[4] = (void **)(v5 + 40);
        if (v32) {
          long double v33 = (void **)std::__allocate_at_least[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>>((uint64_t)(v5 + 40), v32);
        }
        else {
          long double v33 = 0;
        }
        uint64_t v34 = &v33[2 * v29];
        v40[0] = v33;
        v40[1] = v34;
        void v40[3] = &v33[2 * v32];
        CFDictionaryRef v35 = (void *)MEMORY[0x1E4F147B0];
        *uint64_t v34 = v24;
        v34[1] = v35;
        v40[2] = v34 + 2;
        std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__swap_out_circular_buffer((uint64_t *)v5 + 3, v40);
        int32x4_t v28 = (void *)*((void *)v5 + 4);
        std::__split_buffer<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::~__split_buffer((uint64_t)v40);
      }
      else
      {
        int32x4_t v27 = MEMORY[0x1E4F147B0];
        *uint32x4_t v26 = v24;
        v26[1] = v27;
        int32x4_t v28 = v26 + 2;
        *((void *)v5 + 4) = v26 + 2;
      }
      *((void *)v5 + 4) = v28;
      uint64_t v6 = *((void *)v5 + 3);
      unint64_t v8 = ((uint64_t)v28 - v6) >> 4;
      goto LABEL_43;
    }
    CFStringRef v9 = (const __CFString *)IIO_Reader::utType(v39);
    CFStringGetCStringPtr(v9, 0x600u);
    int v10 = IIO_Reader::osType(v39);
    unsigned int v11 = v10 >> 24;
    uint64_t v12 = MEMORY[0x1E4F14390];
    if (v10 < 0) {
      int v13 = __maskrune(v11, 0x40000uLL);
    }
    else {
      int v13 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v11 + 60) & 0x40000;
    }
    if (v13) {
      uint64_t v14 = ((int)IIO_Reader::osType(v39) >> 24);
    }
    else {
      uint64_t v14 = 46;
    }
    signed int v15 = IIO_Reader::osType(v39) << 8;
    unsigned int v16 = v15 >> 24;
    if (v15 < 0) {
      int v17 = __maskrune(v16, 0x40000uLL);
    }
    else {
      int v17 = *(_DWORD *)(v12 + 4 * v16 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = ((int)(IIO_Reader::osType(v39) << 8) >> 24);
    }
    else {
      uint64_t v18 = 46;
    }
    int v19 = IIO_Reader::osType(v39);
    int v20 = v19 << 16;
    unsigned int v21 = (__int16)v19 >> 8;
    if (v20 < 0) {
      int v22 = __maskrune(v21, 0x40000uLL);
    }
    else {
      int v22 = *(_DWORD *)(v12 + 4 * v21 + 60) & 0x40000;
    }
    if (v22) {
      IIO_Reader::osType(v39);
    }
    int v23 = IIO_Reader::osType(v39);
    if ((v23 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v12 + 4 * (char)v23 + 60) & 0x40000) == 0) {
        goto LABEL_29;
      }
    }
    else if (!__maskrune((char)v23, 0x40000uLL))
    {
LABEL_29:
      snprintf(__str, 0x400uLL, "com.apple.ImageIOXPCService.'%c%c%c%c'.%s%s%zu", v14, v18);
      goto LABEL_30;
    }
    IIO_Reader::osType(v39);
    goto LABEL_29;
  }
LABEL_43:
  unint64_t v36 = (*((void *)v5 + 6) + 1) % v8;
  *((void *)v5 + 6) = v36;
  uint64_t v37 = *(void *)(v6 + 16 * v36);
  os_unfair_lock_unlock(v3);
  return v37;
}

void sub_188779C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  std::__split_buffer<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN17IIO_ReaderHandler17xpcQueueForReaderEP10IIO_Reader_block_invoke()
{
  size_t v1 = 4;
  return sysctlbyname("hw.activecpu", &IIO_ReaderHandler::xpcQueueForReader(IIO_Reader *)::gPoolSize, &v1, 0, 0);
}

void IIO_ReaderHandler::xpcReply(int a1, xpc_connection_t connection, xpc_object_t message, uint64_t a4)
{
  if (message)
  {
    xpc_connection_send_message(connection, message);
    xpc_release(message);
  }
  if (a4)
  {
    uint64_t v6 = *(void (**)(uint64_t))(a4 + 16);
    v6(a4);
  }
}

uint64_t IIO_ReaderHandler::xpcTestHeader(os_unfair_lock_s *a1, int a2, xpc_object_t original, uint64_t a4)
{
  if (!xpc_dictionary_create_reply(original)) {
    return (*(uint64_t (**)(uint64_t, void))(a4 + 16))(a4, 0);
  }
  xpc_retain(original);
  IIO_ReaderHandler::xpcQueueForReader(a1, 0);
  return xpc_dictionary_handoff_reply();
}

void ___ZN17IIO_ReaderHandler13xpcTestHeaderEP17_xpc_connection_sPvU13block_pointerFvPjE_block_invoke(uint64_t a1)
{
  double v2 = *(IIO_Reader ****)(a1 + 40);
  xpc_object_t source_dict = iio_xpc_get_source_dict(*(void **)(a1 + 48));
  xpc_object_t v4 = iio_xpc_add_message_dict(*(void **)(a1 + 56));
  xpc_object_t v5 = iio_xpc_add_source_dict(*(void **)(a1 + 56));
  unsigned int v31 = 0;
  int v32 = 774778414;
  size_t length = 0;
  if (!source_dict
    || ((uint64_t v6 = v5, (data = xpc_dictionary_get_data(source_dict, "iio_xpc_src_header_data", &length)) != 0)
      ? (BOOL v8 = length == 0)
      : (BOOL v8 = 1),
        v8))
  {
    iio_xpc_dictionary_set_error_code(v4, 0xFFFFFA86);
    int v10 = 0;
  }
  else
  {
    uint64_t v11 = (uint64_t)data;
    string = xpc_dictionary_get_string(source_dict, "iio_xpc_src_hint_string");
    uint64_t uint64 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_file_size");
    __n128 v28 = 0uLL;
    uint64_t v29 = 0;
    iio_xpc_get_IIOHeaderOptions_from_xpcObj(source_dict, "iio_xpc_src_header_options", &v28);
    size_t v14 = length;
    if (string)
    {
      IIOString::IIOString((IIOString *)v26, string);
      signed int v15 = v27;
    }
    else
    {
      signed int v15 = 0;
    }
    __n128 v24 = v28;
    uint64_t v25 = v29;
    unsigned int v16 = IIO_ReaderHandler::readerForBytesImp(v2, v11, v14, v15, uint64, v24.n128_u64, 0, (int *)&v31);
    if (string) {
      IIOString::~IIOString((IIOString *)v26);
    }
    if (v16)
    {
      int v17 = (const void *)IIO_Reader::utType(v16);
      LODWORD(v18) = IIO_Reader::osType(v16);
      int v32 = v18;
      IIOIncrementIdentifyCallCount();
      uint64_t v18 = v18;
      int v10 = &v32;
    }
    else
    {
      int v10 = 0;
      int v17 = 0;
      uint64_t v18 = 774778414;
    }
    memset(v23, 0, sizeof(v23));
    IIOString::IIOString((IIOString *)v23, v17);
    if (v17)
    {
      int v19 = (const char *)IIOString::utf8String((IIOString *)v23);
      xpc_dictionary_set_string(v6, "iio_xpc_src_utitype", v19);
    }
    else
    {
      xpc_dictionary_set_string(v6, "iio_xpc_src_utitype", "unknown");
    }
    xpc_dictionary_set_uint64(v6, "iio_xpc_src_ostype", v18);
    iio_xpc_dictionary_set_error_code(v4, v31);
    IIOString::~IIOString((IIOString *)v23);
  }
  unsigned int v21 = *(void **)(a1 + 56);
  int v20 = *(_xpc_connection_s **)(a1 + 64);
  v22[0] = MEMORY[0x1E4F143A8];
  v22[1] = 0x40000000;
  void v22[2] = ___ZN17IIO_ReaderHandler13xpcTestHeaderEP17_xpc_connection_sPvU13block_pointerFvPjE_block_invoke_2;
  v22[3] = &unk_1E53CBC20;
  _OWORD v22[4] = *(void *)(a1 + 32);
  v22[5] = v10;
  IIO_ReaderHandler::xpcReply(v9, v20, v21, (uint64_t)v22);
  xpc_release(*(xpc_object_t *)(a1 + 48));
}

void sub_18877A09C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if (v23) {
    IIOString::~IIOString((IIOString *)&a23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN17IIO_ReaderHandler13xpcTestHeaderEP17_xpc_connection_sPvU13block_pointerFvPjE_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t ___ZN17IIO_ReaderHandler13xpcTestHeaderEP17_xpc_connection_sPvU13block_pointerFvPjE_block_invoke_3(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void IIO_ReaderHandler::xpcGetImageCount(IIO_ReaderHandler *a1, _xpc_connection_s *a2, xpc_object_t original, uint64_t a4)
{
  repldouble y = xpc_dictionary_create_reply(original);
  int v9 = reply;
  if (reply)
  {
    xpc_object_t source_dict = iio_xpc_get_source_dict(original);
    xpc_object_t v11 = iio_xpc_add_message_dict(v9);
    if (source_dict)
    {
      string = xpc_dictionary_get_string(source_dict, "iio_xpc_src_utitype");
      int uint64 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_ostype");
      v15[0] = 0;
      v15[1] = 0;
      unsigned int v16 = 0;
      IIOString::IIOString((IIOString *)v15, string);
      size_t v14 = IIO_ReaderHandler::readerForUTTypeAndOSType(a1, v16, uint64);
      IIOString::~IIOString((IIOString *)v15);
      if (v14)
      {
        xpc_retain(original);
        IIO_ReaderHandler::xpcQueueForReader((os_unfair_lock_s *)a1, v14);
        xpc_dictionary_handoff_reply();
        return;
      }
    }
    iio_xpc_dictionary_set_error_code(v11, 0xFFFFFA85);
  }
  IIO_ReaderHandler::xpcReply((int)reply, a2, v9, a4);
}

void sub_18877A254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void ___ZN17IIO_ReaderHandler16xpcGetImageCountEP17_xpc_connection_sPvU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  unsigned int v2 = (*(uint64_t (**)(void, void, void, void))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72));
  iio_xpc_dictionary_set_error_code(*(void **)(a1 + 80), v2);
  IIO_ReaderHandler::xpcReply(v3, *(xpc_connection_t *)(a1 + 56), *(xpc_object_t *)(a1 + 72), *(void *)(a1 + 32));
  xpc_object_t v4 = *(void **)(a1 + 64);

  xpc_release(v4);
}

void IIO_ReaderHandler::xpcUpdateSourceProperties(IIO_ReaderHandler *a1, _xpc_connection_s *a2, xpc_object_t original, uint64_t a4)
{
  repldouble y = xpc_dictionary_create_reply(original);
  int v9 = reply;
  if (reply)
  {
    xpc_object_t source_dict = iio_xpc_get_source_dict(original);
    xpc_object_t v11 = iio_xpc_add_message_dict(v9);
    if (source_dict)
    {
      string = xpc_dictionary_get_string(source_dict, "iio_xpc_src_utitype");
      int uint64 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_ostype");
      v15[0] = 0;
      v15[1] = 0;
      unsigned int v16 = 0;
      IIOString::IIOString((IIOString *)v15, string);
      size_t v14 = IIO_ReaderHandler::readerForUTTypeAndOSType(a1, v16, uint64);
      IIOString::~IIOString((IIOString *)v15);
      if (v14)
      {
        xpc_retain(original);
        IIO_ReaderHandler::xpcQueueForReader((os_unfair_lock_s *)a1, v14);
        xpc_dictionary_handoff_reply();
        return;
      }
    }
    iio_xpc_dictionary_set_error_code(v11, 0xFFFFFA84);
  }
  IIO_ReaderHandler::xpcReply((int)reply, a2, v9, a4);
}

void sub_18877A454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void ___ZN17IIO_ReaderHandler25xpcUpdateSourcePropertiesEP17_xpc_connection_sPvU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  unsigned int v2 = (*(uint64_t (**)(void, void, void, void))(**(void **)(a1 + 48) + 64))(*(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72));
  iio_xpc_dictionary_set_error_code(*(void **)(a1 + 80), v2);
  IIO_ReaderHandler::xpcReply(v3, *(xpc_connection_t *)(a1 + 56), *(xpc_object_t *)(a1 + 72), *(void *)(a1 + 32));
  xpc_object_t v4 = *(void **)(a1 + 64);

  xpc_release(v4);
}

void IIO_ReaderHandler::xpcInitImage(IIO_ReaderHandler *a1, _xpc_connection_s *a2, xpc_object_t original, uint64_t a4)
{
  repldouble y = xpc_dictionary_create_reply(original);
  int v9 = reply;
  if (reply)
  {
    xpc_object_t source_dict = iio_xpc_get_source_dict(original);
    xpc_object_t v11 = iio_xpc_add_message_dict(v9);
    if (source_dict)
    {
      string = xpc_dictionary_get_string(source_dict, "iio_xpc_src_utitype");
      int uint64 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_ostype");
      v15[0] = 0;
      v15[1] = 0;
      unsigned int v16 = 0;
      IIOString::IIOString((IIOString *)v15, string);
      size_t v14 = IIO_ReaderHandler::readerForUTTypeAndOSType(a1, v16, uint64);
      IIOString::~IIOString((IIOString *)v15);
      if (v14)
      {
        xpc_retain(original);
        IIO_ReaderHandler::xpcQueueForReader((os_unfair_lock_s *)a1, v14);
        xpc_dictionary_handoff_reply();
        return;
      }
    }
    iio_xpc_dictionary_set_error_code(v11, 0xFFFFFA83);
  }
  IIO_ReaderHandler::xpcReply((int)reply, a2, v9, a4);
}

void sub_18877A654(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void ___ZN17IIO_ReaderHandler12xpcInitImageEP17_xpc_connection_sPvU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  unsigned int v2 = (*(uint64_t (**)(void, void, void, void))(**(void **)(a1 + 48) + 256))(*(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72));
  iio_xpc_dictionary_set_error_code(*(void **)(a1 + 80), v2);
  IIO_ReaderHandler::xpcReply(v3, *(xpc_connection_t *)(a1 + 56), *(xpc_object_t *)(a1 + 72), *(void *)(a1 + 32));
  xpc_object_t v4 = *(void **)(a1 + 64);

  xpc_release(v4);
}

void IIO_ReaderHandler::xpcDecodeImage(IIO_ReaderHandler *a1, _xpc_connection_s *a2, xpc_object_t original, uint64_t a4)
{
  repldouble y = xpc_dictionary_create_reply(original);
  int v9 = reply;
  if (reply)
  {
    xpc_object_t source_dict = iio_xpc_get_source_dict(original);
    xpc_object_t v11 = iio_xpc_add_message_dict(v9);
    if (source_dict)
    {
      string = xpc_dictionary_get_string(source_dict, "iio_xpc_src_utitype");
      int uint64 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_ostype");
      v15[0] = 0;
      v15[1] = 0;
      unsigned int v16 = 0;
      IIOString::IIOString((IIOString *)v15, string);
      size_t v14 = IIO_ReaderHandler::readerForUTTypeAndOSType(a1, v16, uint64);
      IIOString::~IIOString((IIOString *)v15);
      if (v14)
      {
        xpc_retain(original);
        IIO_ReaderHandler::xpcQueueForReader((os_unfair_lock_s *)a1, v14);
        xpc_dictionary_handoff_reply();
        return;
      }
    }
    iio_xpc_dictionary_set_error_code(v11, 0xFFFFFA80);
  }
  IIO_ReaderHandler::xpcReply((int)reply, a2, v9, a4);
}

void sub_18877A85C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void ___ZN17IIO_ReaderHandler14xpcDecodeImageEP17_xpc_connection_sPvU13block_pointerFvvE_block_invoke(uint64_t a1)
{
  unsigned int v2 = (*(uint64_t (**)(void, void, void, void))(**(void **)(a1 + 48) + 264))(*(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72));
  iio_xpc_dictionary_set_error_code(*(void **)(a1 + 80), v2);
  IIO_ReaderHandler::xpcReply(v3, *(xpc_connection_t *)(a1 + 56), *(xpc_object_t *)(a1 + 72), *(void *)(a1 + 32));
  xpc_object_t v4 = *(void **)(a1 + 64);

  xpc_release(v4);
}

void std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  unsigned int v2 = *a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, *v2);
    int v3 = **a1;
    operator delete(v3);
  }
}

uint64_t std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__base_destruct_at_end[abi:ne180100](uint64_t result, void *a2)
{
  uint64_t v3 = result;
  xpc_object_t v4 = *(void **)(result + 8);
  if (v4 != a2)
  {
    xpc_object_t v5 = *(void **)(result + 8);
    do
    {
      uint64_t v6 = *(v5 - 2);
      v5 -= 2;
      uint64_t result = v6;
      void *v5 = 0;
      if (v6) {
        uint64_t result = ((uint64_t (*)(void))*(v4 - 1))();
      }
      xpc_object_t v4 = v5;
    }
    while (v5 != a2);
  }
  *(void *)(v3 + 8) = a2;
  return result;
}

void std::vector<std::unique_ptr<IIO_Reader>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  unsigned int v2 = *a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<IIO_Reader>>::__clear[abi:ne180100](v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void *std::vector<std::unique_ptr<IIO_Reader>>::__clear[abi:ne180100](void *result)
{
  size_t v1 = result;
  unsigned int v2 = (void *)*result;
  uint64_t v3 = (void *)result[1];
  while (v3 != v2)
  {
    xpc_object_t v4 = (void *)*--v3;
    uint64_t result = v4;
    *uint64_t v3 = 0;
    if (v4) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  v1[1] = v2;
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__deallocate_node(a1, *(char **)(a1 + 16));
  unsigned int v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__deallocate_node(uint64_t a1, char *a2)
{
  if (a2)
  {
    unsigned int v2 = a2;
    do
    {
      uint64_t v3 = *(char **)v2;
      xpc_object_t v4 = (void **)(v2 + 24);
      std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__destroy_vector::operator()[abi:ne180100](&v4);
      operator delete(v2);
      unsigned int v2 = v3;
    }
    while (v3);
  }
}

void *std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<IIO_Reader>>,std::reverse_iterator<std::unique_ptr<IIO_Reader>*>>::operator()[abi:ne180100](void *result)
{
  size_t v1 = *(void ***)(result[2] + 8);
  unsigned int v2 = *(void ***)(result[1] + 8);
  while (v1 != v2)
  {
    uint64_t result = *v1;
    *size_t v1 = 0;
    if (result) {
      uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
    ++v1;
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::find<IIO_Reader *>(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  BOOL v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  uint64_t result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

char *std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__emplace_unique_key_args<IIO_Reader *,IIO_Reader *&,IIO_ReaderHandler::QueuePool>(uint64_t a1, void *a2, uint64_t *a3, long long *a4)
{
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  unint64_t v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  unint64_t v10 = *(void *)(a1 + 8);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v12 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10) {
        unint64_t v12 = v9 % v10;
      }
    }
    else
    {
      unint64_t v12 = v9 & (v10 - 1);
    }
    int v13 = *(void ***)(*(void *)a1 + 8 * v12);
    if (v13)
    {
      size_t v14 = (char *)*v13;
      if (*v13)
      {
        do
        {
          unint64_t v15 = *((void *)v14 + 1);
          if (v15 == v9)
          {
            if (*((void *)v14 + 2) == *a2) {
              return v14;
            }
          }
          else
          {
            if (v11.u32[0] > 1uLL)
            {
              if (v15 >= v10) {
                v15 %= v10;
              }
            }
            else
            {
              v15 &= v10 - 1;
            }
            if (v15 != v12) {
              break;
            }
          }
          size_t v14 = *(char **)v14;
        }
        while (v14);
      }
    }
  }
  else
  {
    unint64_t v12 = 0;
  }
  unsigned int v16 = (void *)(a1 + 16);
  size_t v14 = (char *)operator new(0x38uLL);
  uint64_t v17 = *a3;
  *((void *)v14 + 1) = v9;
  *((void *)v14 + 2) = v17;
  long long v18 = *a4;
  *(void *)a4 = 0;
  *((void *)a4 + 1) = 0;
  uint64_t v19 = *((void *)a4 + 2);
  uint64_t v20 = *((void *)a4 + 3);
  *((void *)a4 + 2) = 0;
  *(void *)size_t v14 = 0;
  *(_OWORD *)(v14 + 24) = v18;
  *((void *)v14 + 5) = v19;
  *((void *)v14 + 6) = v20;
  float v21 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v22 = *(float *)(a1 + 32);
  if (!v10 || (float)(v22 * (float)v10) < v21)
  {
    BOOL v23 = 1;
    if (v10 >= 3) {
      BOOL v23 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v10);
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      size_t v26 = v25;
    }
    else {
      size_t v26 = v24;
    }
    std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__rehash<true>(a1, v26);
    unint64_t v10 = *(void *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10) {
        unint64_t v12 = v9 % v10;
      }
      else {
        unint64_t v12 = v9;
      }
    }
    else
    {
      unint64_t v12 = (v10 - 1) & v9;
    }
  }
  uint64_t v27 = *(void *)a1;
  __n128 v28 = *(void **)(*(void *)a1 + 8 * v12);
  if (v28)
  {
    *(void *)size_t v14 = *v28;
LABEL_38:
    *__n128 v28 = v14;
    goto LABEL_39;
  }
  *(void *)size_t v14 = *v16;
  *unsigned int v16 = v14;
  *(void *)(v27 + 8 * v12) = v16;
  if (*(void *)v14)
  {
    unint64_t v29 = *(void *)(*(void *)v14 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v29 >= v10) {
        v29 %= v10;
      }
    }
    else
    {
      v29 &= v10 - 1;
    }
    __n128 v28 = (void *)(*(void *)a1 + 8 * v29);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return v14;
}

void sub_18877AEDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__do_rehash<true>(a1, prime);
    }
  }
}

void std::__hash_table<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::__unordered_map_hasher<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::hash<IIO_Reader *>,std::equal_to<IIO_Reader *>,true>,std::__unordered_map_equal<IIO_Reader *,std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,std::equal_to<IIO_Reader *>,std::hash<IIO_Reader *>,true>,std::allocator<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      uint64_t v11 = (void *)*v7;
      if (*v7)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2) {
              v12 %= a2;
            }
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(void *)(*(void *)a1 + 8 * v12))
            {
              *(void *)(*(void *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *uint64_t v7 = *v11;
            *uint64_t v11 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * v12) = v11;
            uint64_t v11 = v7;
          }
          unint64_t v12 = v8;
LABEL_24:
          uint64_t v7 = v11;
          uint64_t v11 = (void *)*v11;
          unint64_t v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    unint64_t v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<IIO_Reader *,IIO_ReaderHandler::QueuePool>,void *>>>::operator()[abi:ne180100](uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    unint64_t v3 = __p + 3;
    std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  if (__p) {
    operator delete(__p);
  }
}

uint64_t std::vector<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  uint64_t v13 = 0;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 16);
    do
    {
      uint64_t v9 = *(a3 - 2);
      a3 -= 2;
      *a3 = 0;
      *uint64_t v8 = v9;
      v8[1] = a3[1];
      *((void *)&v15 + 1) = v8;
      v7 -= 16;
      v8 -= 2;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  LOBYTE(v13) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

uint64_t std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  size_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v15 = v3;
  uint64_t v16 = v2;
  uint64_t v17 = v3;
  uint64_t v18 = v2;
  uint64_t v4 = *a1;
  uint64_t v5 = (uint64_t *)a1[1];
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  uint64_t v10 = v7;
  uint64_t v11 = v6;
  uint64_t v12 = v7;
  uint64_t v13 = v6;
  return std::__allocator_destroy[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>,std::reverse_iterator<std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>>(v4, (uint64_t)v14, (uint64_t)v9);
}

uint64_t std::__allocator_destroy[abi:ne180100]<std::allocator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>,std::reverse_iterator<std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>,std::reverse_iterator<std::reverse_iterator<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = *(void *)(a2 + 32); i != *(void *)(a3 + 32); *(void *)(a2 + 32) = i)
  {
    uint64_t result = *(void *)i;
    *(void *)uint64_t i = 0;
    if (result) {
      uint64_t result = (*(uint64_t (**)(void))(i + 8))();
    }
    uint64_t i = *(void *)(a2 + 32) + 16;
  }
  return result;
}

uint64_t std::__split_buffer<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__split_buffer<std::unique_ptr<dispatch_queue_s,void (*)(dispatch_object_s *)>>::__destruct_at_end[abi:ne180100](uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  if (v2 != a2)
  {
    uint64_t v4 = result;
    do
    {
      *(void *)(v4 + 16) = v2 - 16;
      uint64_t result = *(void *)(v2 - 16);
      *(void *)(v2 - 16) = 0;
      if (result) {
        uint64_t result = (*(uint64_t (**)(void))(v2 - 8))();
      }
      uint64_t v2 = *(void *)(v4 + 16);
    }
    while (v2 != a2);
  }
  return result;
}

uint64_t CreateKtxStream(uint64_t a1, IIOImageReadSession *this)
{
  if (!a1) {
    return 11;
  }
  IIOImageReadSession::setOffset((uint64_t)this, 0);
  uint64_t result = 0;
  *(void *)(a1 + 64) = this;
  *(_DWORD *)(a1 + 56) = 3;
  *(void *)a1 = IIOktxStream_read;
  *(void *)(a1 + 8) = IIOktxStream_skip;
  *(void *)(a1 + 16) = IIOktxStream_write;
  *(void *)(a1 + 24) = IIOktxStream_getpos;
  *(void *)(a1 + 32) = IIOktxStream_setpos;
  *(void *)(a1 + 40) = IIOktxStream_getsize;
  *(void *)(a1 + 48) = IIOktxStream_destruct;
  *(unsigned char *)(a1 + 96) = 0;
  return result;
}

uint64_t IIOktxStream_read(uint64_t a1, unsigned char *a2, unint64_t a3)
{
  if (!a1) {
    return 11;
  }
  uint64_t v3 = *(IIOImageReadSession **)(a1 + 64);
  if (!v3) {
    return 11;
  }
  if (IIOImageReadSession::getBytes(v3, a2, a3) == a3) {
    return 0;
  }
  return 7;
}

uint64_t IIOktxStream_skip(uint64_t a1, unint64_t a2)
{
  if (!a1) {
    return 11;
  }
  uint64_t v2 = *(IIOImageReadSession **)(a1 + 64);
  if (!v2) {
    return 11;
  }
  if (IIOImageReadSession::seek(v2, a2, 1) == -1) {
    return 7;
  }
  return 0;
}

uint64_t IIOktxStream_write(uint64_t a1)
{
  if (!a1) {
    return 11;
  }
  if (*(void *)(a1 + 64)) {
    return 10;
  }
  return 11;
}

uint64_t IIOktxStream_getpos(uint64_t a1, uint64_t *a2)
{
  uint64_t result = 11;
  if (a1 && a2)
  {
    uint64_t v5 = *(IIO_Reader **)(a1 + 64);
    if (v5)
    {
      uint64_t v6 = IIO_Reader::minimumFileSize(v5);
      uint64_t result = 0;
      *a2 = v6;
    }
    else
    {
      return 11;
    }
  }
  return result;
}

uint64_t IIOktxStream_setpos(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return 11;
  }
  uint64_t v2 = *(void *)(a1 + 64);
  if (!v2) {
    return 11;
  }
  IIOImageReadSession::setOffset(v2, a2);
  return 0;
}

uint64_t IIOktxStream_getsize(uint64_t a1, IIOImageRead **a2)
{
  uint64_t result = 11;
  if (a1 && a2)
  {
    uint64_t v5 = *(IIOImageReadSession **)(a1 + 64);
    if (v5)
    {
      unint64_t Size = IIOImageReadSession::getSize(v5);
      uint64_t result = 0;
      *a2 = Size;
    }
    else
    {
      return 11;
    }
  }
  return result;
}

uint64_t TIFFInitPixarLog(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 != 32909) {
    TIFFInitPixarLog_cold_1();
  }
  if (!_TIFFMergeFields((uint64_t)a1, pixarlogFields, 2, a4, a5, a6, a7, a8))
  {
    uint64_t v98 = "Merging PixarLog codec-specific tags failed";
LABEL_43:
    TIFFErrorExtR((uint64_t)a1, "TIFFInitPixarLog", v98, v10, v11, v12, v13, v14, v99);
    return 0;
  }
  uint64_t v15 = _TIFFmallocExt(a1, 336, v9, v10, v11, v12, v13, v14);
  a1[137] = v15;
  if (!v15)
  {
    uint64_t v98 = "No space for PixarLog state block";
    goto LABEL_43;
  }
  uint64_t v16 = v15;
  _TIFFmemset(v15, 0, 0x150uLL);
  *((_DWORD *)v16 + 54) = 0;
  a1[119] = PixarLogFixupTags;
  a1[120] = PixarLogSetupDecode;
  a1[121] = PixarLogPreDecode;
  a1[126] = PixarLogDecode;
  a1[128] = PixarLogDecode;
  a1[130] = PixarLogDecode;
  a1[122] = PixarLogSetupEncode;
  a1[124] = PixarLogPreEncode;
  a1[125] = PixarLogPostEncode;
  a1[127] = PixarLogEncode;
  a1[129] = PixarLogEncode;
  a1[131] = PixarLogEncode;
  a1[132] = PixarLogClose;
  a1[134] = PixarLogCleanup;
  v16[34] = a1[161];
  a1[161] = PixarLogVGetField;
  v16[35] = a1[160];
  a1[160] = PixarLogVSetField;
  v16[33] = -1;
  *((_DWORD *)v16 + 65) = 0;
  TIFFPredictorInit((uint64_t)a1, v17, v18, v19, v20, v21, v22, v23);
  LogK1 = 1132068864;
  LogK2 = 1125411269;
  unint64_t v30 = (char *)_TIFFmallocExt(a1, 54600, v24, v25, v26, v27, v28, v29);
  uint64_t v37 = (char *)_TIFFmallocExt(a1, 0x8000, v31, v32, v33, v34, v35, v36);
  uint64_t v44 = (char *)_TIFFmallocExt(a1, 512, v38, v39, v40, v41, v42, v43);
  uint64_t v51 = _TIFFmallocExt(a1, 8196, v45, v46, v47, v48, v49, v50);
  uint64_t v58 = (char *)_TIFFmallocExt(a1, 4098, v52, v53, v54, v55, v56, v57);
  uint64_t v65 = (char *)_TIFFmallocExt(a1, 2049, v59, v60, v61, v62, v63, v64);
  unsigned int v66 = v65;
  if (v30 && v37 && v44 && v51 && v58 && v65)
  {
    uint64_t v67 = 0;
    uint64x2_t v68 = (uint64x2_t)vdupq_n_s64(0xFAuLL);
    int64x2_t v69 = (int64x2_t)xmmword_18898C840;
    int64x2_t v70 = vdupq_n_s64(2uLL);
    do
    {
      if (vmovn_s64((int64x2_t)vcgtq_u64(v68, (uint64x2_t)v69)).u8[0])
      {
        float v71 = (double)(int)(v67 * 2) * 0.0000732625556;
        *(float *)&v51[v67] = v71;
      }
      if (vmovn_s64((int64x2_t)vcgtq_u64((uint64x2_t)vdupq_n_s64(0xFAuLL), *(uint64x2_t *)&v69)).i32[1])
      {
        float v72 = (double)((int)(v67 * 2) + 1) * 0.0000732625556;
        *((float *)&v51[v67] + 1) = v72;
      }
      ++v67;
      int64x2_t v69 = vaddq_s64(v69, v70);
    }
    while (v67 != 125);
    unint64_t v73 = 0;
    float64x2_t v100 = (float64x2_t)vdupq_n_s64(0x3F70624DD2F1A9FCuLL);
    do
    {
      int32x2_t v74 = vadd_s32(vdup_n_s32(v73), (int32x2_t)0xFB000000FALL);
      v75.i64[0] = v74.i32[0];
      v75.i64[1] = v74.i32[1];
      __double x = vmulq_f64(vcvtq_f64_s64(v75), v100);
      long double v101 = exp(__x.f64[1]);
      v76.f64[0] = exp(__x.f64[0]);
      if (v73 <= 0x705)
      {
        v76.f64[1] = v101;
        uint64_t v77 = (float *)&v51[v73 / 2];
        float v78 = 0.006737947 * v76.f64[0];
        v77[250] = v78;
        float v79 = vmuld_lane_f64(0.006737947, v76, 1);
        v77[251] = v79;
      }
      v73 += 2;
    }
    while (v73 != 1798);
    uint64_t v80 = 0;
    *((_DWORD *)v51 + 2048) = *((_DWORD *)v51 + 2047);
    do
    {
      double v81 = *((float *)v51 + v80);
      double v82 = v81 * 65535.0 + 0.5;
      if (v82 >= 65535.0) {
        double v82 = 65535.0;
      }
      *(_WORD *)&v58[2 * v80] = (int)v82;
      double v83 = v81 * 255.0 + 0.5;
      if (v83 >= 255.0) {
        double v83 = 255.0;
      }
      v66[v80++] = (int)v83;
    }
    while (v80 != 2049);
    uint64_t v84 = 0;
    int v85 = 0;
    do
    {
      if ((double)(int)v84 * 0.0000732625556 * ((double)(int)v84 * 0.0000732625556) > (float)(*((float *)v51 + v85)
                                                                                             * *((float *)v51 + v85 + 1)))
        ++v85;
      *(_WORD *)&v30[2 * v84++] = v85;
    }
    while (v84 != 27300);
    uint64_t v86 = 0;
    int v87 = 0;
    do
    {
      float v88 = *((float *)v51 + v87);
      uint64_t v89 = v87 + 1;
      do
      {
        float v90 = *((float *)v51 + v89++);
        BOOL v91 = (double)(int)v86 / 16383.0 * ((double)(int)v86 / 16383.0) <= (float)(v88 * v90);
        float v88 = v90;
      }
      while (!v91);
      int v87 = v89 - 2;
      *(_WORD *)&v37[2 * v86++] = v87;
    }
    while (v86 != 0x4000);
    uint64_t v92 = 0;
    int v93 = 0;
    do
    {
      float v94 = *((float *)v51 + v93);
      uint64_t v95 = v93 + 1;
      do
      {
        float v96 = *((float *)v51 + v95++);
        BOOL v91 = (double)(int)v92 / 255.0 * ((double)(int)v92 / 255.0) <= (float)(v94 * v96);
        float v94 = v96;
      }
      while (!v91);
      int v93 = v95 - 2;
      *(_WORD *)&v44[2 * v92++] = v93;
    }
    while (v92 != 256);
    Fltsize_t size = 1179994112;
    v16[36] = v51;
    v16[37] = v58;
    v16[38] = v66;
    v16[39] = v30;
    uint64_t result = 1;
    v16[40] = v37;
    v16[41] = v44;
  }
  else
  {
    if (v30) {
      _TIFFfreeExt((uint64_t)a1, v30);
    }
    if (v37) {
      _TIFFfreeExt((uint64_t)a1, v37);
    }
    if (v44) {
      _TIFFfreeExt((uint64_t)a1, v44);
    }
    if (v51) {
      _TIFFfreeExt((uint64_t)a1, (char *)v51);
    }
    if (v58) {
      _TIFFfreeExt((uint64_t)a1, v58);
    }
    if (v66) {
      _TIFFfreeExt((uint64_t)a1, v66);
    }
    *((_OWORD *)v16 + 19) = 0u;
    *((_OWORD *)v16 + 20) = 0u;
    *((_OWORD *)v16 + 18) = 0u;
    return 1;
  }
  return result;
}

uint64_t PixarLogFixupTags()
{
  return 1;
}

uint64_t PixarLogSetupDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 1096);
  if (!v8) {
    PixarLogSetupDecode_cold_1();
  }
  if (*(unsigned char *)(v8 + 260)) {
    return 1;
  }
  unsigned int v10 = *(_DWORD *)(a1 + 132);
  unsigned int v11 = *(_DWORD *)(a1 + 92);
  if (v10 >= v11) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = v10;
  }
  *(void *)(a1 + 1248) = _TIFFNoPostDecode;
  if (*(_WORD *)(a1 + 170) == 1) {
    unsigned int v13 = *(unsigned __int16 *)(a1 + 130);
  }
  else {
    unsigned int v13 = 1;
  }
  *(_WORD *)(v8 + 256) = v13;
  int64_t v14 = _TIFFMultiplySSize(0, v13, *(unsigned int *)(a1 + 88), 0, a5, a6, a7, a8);
  int64_t v19 = _TIFFMultiplySSize(0, v14, v12, 0, v15, v16, v17, v18);
  unint64_t v24 = _TIFFMultiplySSize(0, v19, 2, 0, v20, v21, v22, v23);
  if ((v24 & 0x8000000000000000) != 0) {
    PixarLogSetupDecode_cold_2();
  }
  uint64_t v31 = v24 + 2 * *(unsigned __int16 *)(v8 + 256);
  if (v24) {
    BOOL v32 = *(unsigned __int16 *)(v8 + 256) == 0;
  }
  else {
    BOOL v32 = 1;
  }
  if (v32 || ((2 * *(unsigned __int16 *)(v8 + 256)) ^ 0x7FFFFFFFFFFFFFFFuLL) < v24 || v31 == 0) {
    return 0;
  }
  uint64_t result = (uint64_t)_TIFFmallocExt((void *)a1, v31, v25, v26, v27, v28, v29, v30);
  *(void *)(v8 + 248) = result;
  if (!result) {
    return result;
  }
  *(void *)(v8 + 240) = v31;
  uint64_t v36 = (void *)(v8 + 240);
  if (*(_DWORD *)(v8 + 264) != -1
    || (uint64_t v37 = (char *)result, v38 = PixarLogGuessDataFmt(a1 + 72), *(_DWORD *)(v8 + 264) = v38, v38 != -1))
  {
    if (inflateInit_((z_streamp)(v8 + 128), "1.2.12", 112))
    {
      _TIFFfreeExt(a1, *(char **)(v8 + 248));
      *uint64_t v36 = 0;
      *(void *)(v8 + 248) = 0;
      uint64_t v44 = *(const char **)(v8 + 176);
      if (!v44) {
        uint64_t v44 = "(null)";
      }
      TIFFErrorExtR(a1, "PixarLogSetupDecode", "%s", v39, v40, v41, v42, v43, (char)v44);
      return 0;
    }
    *(_DWORD *)(v8 + 260) |= 1u;
    return 1;
  }
  _TIFFfreeExt(a1, v37);
  *uint64_t v36 = 0;
  *(void *)(v8 + 248) = 0;
  TIFFErrorExtR(a1, "PixarLogSetupDecode", "PixarLog compression can't handle bits depth/data format combination (depth: %hu)", v45, v46, v47, v48, v49, *(_WORD *)(a1 + 116));
  return 0;
}

BOOL PixarLogPreDecode(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[137];
  if (!v8) {
    PixarLogPreDecode_cold_1();
  }
  *(void *)(v8 + 128) = a1[140];
  uint64_t v9 = (z_stream *)(v8 + 128);
  unint64_t v10 = a1[145];
  v9->avail_iunsigned int n = v10;
  if (!HIDWORD(v10)) {
    return inflateReset(v9) == 0;
  }
  TIFFErrorExtR((uint64_t)a1, "PixarLogPreDecode", "ZLib cannot deal with buffers this size", a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t PixarLogDecode(uint64_t a1, char *a2, size_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, _WORD *a8)
{
  uint64_t v11 = *(void *)(a1 + 1096);
  unsigned int v12 = *(_DWORD *)(v11 + 264);
  if (v12 - 2 < 3)
  {
    uint64_t v13 = a3 >> 1;
  }
  else
  {
    uint64_t v13 = a3;
    if (v12 >= 2)
    {
      if (v12 != 5)
      {
        TIFFErrorExtR(a1, "PixarLogDecode", "%hu bit input not supported in PixarLog", a4, a5, a6, a7, (uint64_t)a8, *(_WORD *)(a1 + 116));
        goto LABEL_150;
      }
      uint64_t v13 = a3 >> 2;
    }
  }
  *(void *)(v11 + 128) = *(void *)(a1 + 1152);
  int v14 = *(unsigned __int16 *)(v11 + 256);
  int v15 = *(_DWORD *)(a1 + 88);
  *(_DWORD *)(v11 + 136) = *(void *)(a1 + 1160);
  *(void *)(v11 + 152) = *(void *)(v11 + 248);
  *(_DWORD *)(v11 + 160) = 2 * v13;
  if (((unint64_t)v13 >> 31))
  {
    uint64_t v16 = "ZLib cannot deal with buffers this size";
  }
  else if (2 * v13 <= *(void *)(v11 + 240))
  {
    int v17 = v15 * v14;
    while (1)
    {
      int v18 = inflate((z_streamp)(v11 + 128), 1);
      if (v18) {
        break;
      }
      if (!*(_DWORD *)(v11 + 160)) {
        goto LABEL_20;
      }
    }
    if (v18 == 1)
    {
      if (*(_DWORD *)(v11 + 160))
      {
        TIFFErrorExtR(a1, "PixarLogDecode", "Not enough data at scanline %u (short %u bytes)", a4, a5, a6, a7, (uint64_t)a8, *(_DWORD *)(a1 + 876));
        goto LABEL_150;
      }
LABEL_20:
      *(void *)(a1 + 1152) = *(void *)(v11 + 128);
      *(void *)(a1 + 1160) = *(unsigned int *)(v11 + 136);
      int64_t v19 = *(unsigned __int16 **)(v11 + 248);
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabArrayOfShort(*(void *)(v11 + 248), v13);
      }
      uint64_t v20 = v13 % v17;
      if (v20)
      {
        TIFFWarningExtR(a1, "PixarLogDecode", "stride %d is not a multiple of sample count, %lld, data truncated.", a4, a5, a6, a7, (uint64_t)a8, v17);
        v13 -= v20;
      }
      if (v13 >= 1)
      {
        uint64_t v21 = 0;
        uint64_t v22 = 2 * v17;
        uint64_t v23 = v19 + 5;
        v24.i64[0] = 0x700000007;
        v24.i64[1] = 0x700000007;
        float32x4_t v25 = (float32x4_t)vdupq_n_s32(0x453FF000u);
        uint64_t v26 = v19 + 7;
        v27.i64[0] = 0xFFFFLL;
        v27.i64[1] = 0xFFFFLL;
        v28.i64[0] = 0x4500000045000000;
        v28.i64[1] = 0x4500000045000000;
        while (1)
        {
          switch(*(_DWORD *)(v11 + 264))
          {
            case 0:
              uint64_t v29 = *(unsigned __int16 *)(v11 + 256);
              uint64_t v30 = v17;
              int v31 = v17 - v29;
              if (v17 < (int)v29) {
                goto LABEL_144;
              }
              uint64_t v32 = *(void *)(v11 + 304);
              if (v29 == 3)
              {
                a4 = *v19 & 0x7FF;
                *a2 = *(unsigned char *)(v32 + a4);
                uint64_t v96 = v19[1] & 0x7FF;
                a2[1] = *(unsigned char *)(v32 + v96);
                uint64_t v97 = v19[2] & 0x7FF;
                a2[2] = *(unsigned char *)(v32 + v97);
                uint64_t v30 = v17;
                if (v17 < 4) {
                  goto LABEL_144;
                }
                uint64_t v98 = a2 + 5;
                char v99 = v23;
                unsigned int v100 = v17 + 3;
                do
                {
                  a4 = a4 + *(v99 - 2);
                  *(v98 - 2) = *(unsigned char *)(v32 + (a4 & 0x7FF));
                  LODWORD(v96) = v96 + *(v99 - 1);
                  *(v98 - 1) = *(unsigned char *)(v32 + (v96 & 0x7FF));
                  int v101 = *v99;
                  v99 += 3;
                  LODWORD(v97) = v97 + v101;
                  a5 = *(unsigned __int8 *)(v32 + (v97 & 0x7FF));
                  *uint64_t v98 = a5;
                  v98 += 3;
                  v100 -= 3;
                }
                while (v100 > 6);
              }
              else if (v29 == 4)
              {
                a5 = *v19 & 0x7FF;
                *a2 = *(unsigned char *)(v32 + a5);
                a4 = v19[1] & 0x7FF;
                a2[1] = *(unsigned char *)(v32 + a4);
                uint64_t v33 = v19[2] & 0x7FF;
                a2[2] = *(unsigned char *)(v32 + v33);
                uint64_t v34 = v19[3] & 0x7FF;
                a2[3] = *(unsigned char *)(v32 + v34);
                uint64_t v30 = v17;
                if (v17 < 5) {
                  goto LABEL_144;
                }
                uint64_t v35 = a2 + 7;
                uint64_t v36 = v26;
                unsigned int v37 = v17 + 4;
                do
                {
                  a5 = a5 + *(v36 - 3);
                  *(v35 - 3) = *(unsigned char *)(v32 + (a5 & 0x7FF));
                  a4 = a4 + *(v36 - 2);
                  *(v35 - 2) = *(unsigned char *)(v32 + (a4 & 0x7FF));
                  LODWORD(v33) = v33 + *(v36 - 1);
                  *(v35 - 1) = *(unsigned char *)(v32 + (v33 & 0x7FF));
                  int v38 = *v36;
                  v36 += 4;
                  LODWORD(v34) = v34 + v38;
                  a6 = *(unsigned __int8 *)(v32 + (v34 & 0x7FF));
                  *uint64_t v35 = a6;
                  v35 += 4;
                  v37 -= 4;
                }
                while (v37 > 8);
              }
              else
              {
                unsigned int v102 = v29 + 1;
                uint64_t v103 = a2;
                a4 = (uint64_t)v19;
                do
                {
                  __int16 v104 = *(_WORD *)a4;
                  a4 += 2;
                  a5 = *(unsigned __int8 *)(v32 + (v104 & 0x7FF));
                  *v103++ = a5;
                  --v102;
                }
                while (v102 > 1);
                uint64_t v30 = v17;
                if (v31 < 1) {
                  goto LABEL_144;
                }
                do
                {
                  int v105 = v29 + 1;
                  do
                  {
                    a6 = *(unsigned __int16 *)(a4 + 2 * v29);
                    *(_WORD *)(a4 + 2 * v29) = a6 + *(_WORD *)a4;
                    __int16 v106 = *(_WORD *)a4;
                    a4 += 2;
                    a5 = *(unsigned __int8 *)(v32 + (v106 & 0x7FF));
                    *v103++ = a5;
                    --v105;
                  }
                  while (v105 > 1);
                  BOOL v107 = __OFSUB__(v31, v29);
                  v31 -= v29;
                }
                while (!((v31 < 0) ^ v107 | (v31 == 0)));
              }
              goto LABEL_92;
            case 1:
              uint64_t v39 = *(unsigned __int16 *)(v11 + 256);
              uint64_t v30 = v17;
              int v40 = v17 - v39;
              if (v17 < (int)v39) {
                goto LABEL_144;
              }
              uint64_t v41 = *(void *)(v11 + 304);
              if (v39 == 3)
              {
                *a2 = 0;
                uint64_t v108 = v19[2] & 0x7FF;
                uint64_t v109 = v19[1] & 0x7FF;
                char v110 = *(unsigned char *)(v41 + v109);
                a4 = *v19 & 0x7FF;
                char v111 = *(unsigned char *)(v41 + a4);
                a2[1] = *(unsigned char *)(v41 + v108);
                a2[2] = v110;
                a2[3] = v111;
                uint64_t v30 = v17;
                if (v17 < 4) {
                  goto LABEL_144;
                }
                unsigned __int16 v112 = a2 + 7;
                uint64_t v113 = v23;
                unsigned int v114 = v17 + 3;
                do
                {
                  *(v112 - 3) = 0;
                  LODWORD(v108) = v108 + *v113;
                  a5 = *(unsigned __int8 *)(v41 + (v108 & 0x7FF));
                  LODWORD(v109) = v109 + *(v113 - 1);
                  a6 = *(unsigned __int8 *)(v41 + (v109 & 0x7FF));
                  a4 = a4 + *(v113 - 2);
                  a7 = *(unsigned __int8 *)(v41 + (a4 & 0x7FF));
                  *(v112 - 2) = a5;
                  *(v112 - 1) = a6;
                  *unsigned __int16 v112 = a7;
                  v112 += 4;
                  v114 -= 3;
                  v113 += 3;
                }
                while (v114 > 6);
                goto LABEL_92;
              }
              if (v39 == 4)
              {
                v42.i32[0] = *(void *)v19 & 0x7FF07FF;
                v42.i16[2] = HIDWORD(*(void *)v19) & 0x7FF;
                v42.i16[3] = v42.i16[2];
                char v43 = *(unsigned char *)(v41 + v42.u16[2]);
                char v44 = *(unsigned char *)(v41 + v42.u16[1]);
                char v45 = *(unsigned char *)(v41 + (*(void *)v19 & 0x7FFLL));
                *a2 = v43;
                a2[1] = v43;
                a2[2] = v44;
                a2[3] = v45;
                uint64_t v30 = v17;
                if (v17 < 5) {
                  goto LABEL_144;
                }
                int8x16_t v46 = (int8x16_t)vmovl_u16(v42);
                uint64_t v47 = a2 + 7;
                unsigned int v48 = v17 + 4;
                uint64_t v49 = 4;
                do
                {
                  int8x16_t v46 = (int8x16_t)vaddw_u16((uint32x4_t)v46, *(uint16x4_t *)&v19[v49]);
                  int8x16_t v50 = vandq_s8(v46, v24);
                  char v51 = *(unsigned char *)(v41 + v50.u32[2]);
                  a4 = *(unsigned __int8 *)(v41 + v50.u32[1]);
                  a5 = *(unsigned __int8 *)(v41 + v50.u32[0]);
                  *(v47 - 3) = *(unsigned char *)(v41 + v50.u32[3]);
                  *(v47 - 2) = v51;
                  *(v47 - 1) = a4;
                  *uint64_t v47 = a5;
                  v47 += 4;
                  v49 += 4;
                  v48 -= 4;
                }
                while (v48 > 8);
                goto LABEL_92;
              }
              unsigned int v115 = v39 + 1;
              uint64_t v116 = a2;
              a4 = (uint64_t)v19;
              do
              {
                __int16 v117 = *(_WORD *)a4;
                a4 += 2;
                a5 = *(unsigned __int8 *)(v41 + (v117 & 0x7FF));
                *v116++ = a5;
                --v115;
              }
              while (v115 > 1);
              uint64_t v30 = v17;
              if (v40 >= 1)
              {
                do
                {
                  int v118 = v39 + 1;
                  do
                  {
                    a6 = *(unsigned __int16 *)(a4 + 2 * v39);
                    *(_WORD *)(a4 + 2 * v39) = a6 + *(_WORD *)a4;
                    __int16 v119 = *(_WORD *)a4;
                    a4 += 2;
                    a5 = *(unsigned __int8 *)(v41 + (v119 & 0x7FF));
                    *v116++ = a5;
                    --v118;
                  }
                  while (v118 > 1);
                  BOOL v107 = __OFSUB__(v40, v39);
                  v40 -= v39;
                }
                while (!((v40 < 0) ^ v107 | (v40 == 0)));
LABEL_92:
                uint64_t v30 = v17;
              }
LABEL_144:
              a2 += v30;
              v21 += v17;
              int64_t v19 = (unsigned __int16 *)((char *)v19 + v22);
              uint64_t v23 = (unsigned __int16 *)((char *)v23 + v22);
              uint64_t v26 = (unsigned __int16 *)((char *)v26 + v22);
              if (v21 >= v13) {
                return 1;
              }
              break;
            case 2:
              uint64_t v52 = *(unsigned __int16 *)(v11 + 256);
              uint64_t v30 = 2 * v17;
              int v53 = v17 - v52;
              if (v17 < (int)v52) {
                goto LABEL_144;
              }
              if (v52 == 3)
              {
                *(_WORD *)a2 = *v19;
                *((_WORD *)a2 + 1) = v19[1];
                *((_WORD *)a2 + 2) = v19[2];
                uint64_t v30 = 2 * v17;
                if (v17 < 4) {
                  goto LABEL_144;
                }
                uint64_t v120 = 0;
                int v121 = v19[2];
                int v122 = v19[1];
                unsigned int v123 = v17 + 3;
                int v124 = *v19;
                do
                {
                  a5 = (uint64_t)&a2[v120 * 2 + 6];
                  v124 += v23[v120 - 2];
                  *(_WORD *)a5 = v124 & 0x7FF;
                  v122 += v23[v120 - 1];
                  a6 = v122 & 0x7FF;
                  *(_WORD *)(a5 + 2) = v122 & 0x7FF;
                  v121 += v23[v120];
                  a4 = v121 & 0x7FF;
                  *(_WORD *)(a5 + 4) = v121 & 0x7FF;
                  v123 -= 3;
                  v120 += 3;
                }
                while (v123 > 6);
              }
              else if (v52 == 4)
              {
                *(_WORD *)a2 = *v19;
                *((_WORD *)a2 + 1) = v19[1];
                *((_WORD *)a2 + 2) = v19[2];
                *((_WORD *)a2 + 3) = v19[3];
                uint64_t v30 = 2 * v17;
                if (v17 < 5) {
                  goto LABEL_144;
                }
                uint64_t v54 = 0;
                int v55 = v19[3];
                int v56 = v19[2];
                int v57 = v19[1];
                unsigned int v58 = v17 + 4;
                LODWORD(a4) = *v19;
                do
                {
                  a6 = (uint64_t)&a2[v54 * 2 + 8];
                  a4 = a4 + v26[v54 - 3];
                  *(_WORD *)a6 = a4 & 0x7FF;
                  v57 += v26[v54 - 2];
                  *(_WORD *)(a6 + 2) = v57 & 0x7FF;
                  v56 += v26[v54 - 1];
                  a7 = v56 & 0x7FF;
                  *(_WORD *)(a6 + 4) = v56 & 0x7FF;
                  v55 += v26[v54];
                  a5 = v55 & 0x7FF;
                  *(_WORD *)(a6 + 6) = v55 & 0x7FF;
                  v58 -= 4;
                  v54 += 4;
                }
                while (v58 > 8);
              }
              else
              {
                uint64_t v125 = 0;
                unsigned int v126 = v52 + 1;
                do
                {
                  *(_WORD *)&a2[v125 * 2] = v19[v125] & 0x7FF;
                  ++v125;
                  --v126;
                }
                while (v126 > 1);
                uint64_t v30 = 2 * v17;
                if (v53 < 1) {
                  goto LABEL_144;
                }
                int v127 = &v19[v125];
                unint64_t v128 = &a2[v125 * 2];
                do
                {
                  int v129 = v52 + 1;
                  do
                  {
                    a5 = v127[v52];
                    v127[v52] = a5 + *v127;
                    __int16 v130 = *v127++;
                    a4 = v130 & 0x7FF;
                    *(_WORD *)unint64_t v128 = a4;
                    v128 += 2;
                    --v129;
                  }
                  while (v129 > 1);
                  BOOL v107 = __OFSUB__(v53, v52);
                  v53 -= v52;
                }
                while (!((v53 < 0) ^ v107 | (v53 == 0)));
              }
              goto LABEL_131;
            case 3:
              uint64_t v59 = *(unsigned __int16 *)(v11 + 256);
              uint64_t v30 = 2 * v17;
              int v60 = v17 - v59;
              if (v17 < (int)v59) {
                goto LABEL_144;
              }
              uint64_t v61 = *(void *)(v11 + 288);
              if (v59 == 3)
              {
                uint64_t v131 = *v19 & 0x7FF;
                uint64_t v132 = v19[1] & 0x7FF;
                float v133 = *(float *)(v61 + 4 * v132) * 2048.0;
                uint64_t v134 = v19[2] & 0x7FF;
                float v135 = *(float *)(v61 + 4 * v134);
                *(_WORD *)a2 = (int)fminf(*(float *)(v61 + 4 * v131) * 2048.0, 3071.0);
                *((_WORD *)a2 + 1) = (int)fminf(v133, 3071.0);
                *((_WORD *)a2 + 2) = (int)fminf(v135 * 2048.0, 3071.0);
                uint64_t v30 = 2 * v17;
                if (v17 < 4) {
                  goto LABEL_144;
                }
                uint64_t v136 = 0;
                LODWORD(a4) = v17 + 3;
                do
                {
                  a6 = (uint64_t)&a2[v136 * 2 + 10];
                  LODWORD(v131) = v131 + v19[v136 + 3];
                  LODWORD(v132) = v132 + v19[v136 + 4];
                  a7 = v132 & 0x7FF;
                  float v137 = *(float *)(v61 + 4 * a7) * 2048.0;
                  LODWORD(v134) = v134 + v19[v136 + 5];
                  float v138 = *(float *)(v61 + 4 * (v134 & 0x7FF)) * 2048.0;
                  *(_WORD *)(a6 - 4) = (int)fminf(*(float *)(v61 + 4 * (v131 & 0x7FF)) * 2048.0, 3071.0);
                  *(_WORD *)(a6 - 2) = (int)fminf(v137, 3071.0);
                  a5 = (int)fminf(v138, 3071.0);
                  *(_WORD *)a6 = a5;
                  a4 = (a4 - 3);
                  v136 += 3;
                }
                while (a4 > 6);
              }
              else if (v59 == 4)
              {
                v62.i32[0] = *(void *)v19 & 0x7FF07FF;
                v62.i16[2] = HIDWORD(*(void *)v19) & 0x7FF;
                v62.i16[3] = v62.i16[2];
                uint64_t v63 = (__int32 *)(v61 + 4 * v62.u16[1]);
                int8x16_t v64 = (int8x16_t)vmovl_u16(v62);
                v65.i64[0] = v64.u32[2];
                v65.i64[1] = v64.u32[3];
                float32x4_t v66 = (float32x4_t)vandq_s8(v65, v27);
                uint64_t v67 = (__int32 *)(v61 + 4 * v66.i64[0]);
                v66.i32[0] = *(_DWORD *)(v61 + 4 * (*(void *)v19 & 0x7FFLL));
                v66.i32[1] = *v63;
                uint64x2_t v68 = (__int32 *)(v61 + 4 * v66.i64[1]);
                v66.i32[2] = *v67;
                v66.i32[3] = *v68;
                *(int16x4_t *)a2 = vmovn_s32((int32x4_t)vcvtq_u32_f32(vminnmq_f32(vmulq_f32(v66, v28), v25)));
                uint64_t v30 = 2 * v17;
                if (v17 < 5) {
                  goto LABEL_144;
                }
                unsigned int v69 = v17 + 4;
                uint64_t v70 = 4;
                do
                {
                  int8x16_t v64 = (int8x16_t)vaddw_u16((uint32x4_t)v64, *(uint16x4_t *)&v19[v70]);
                  float32x4_t v71 = (float32x4_t)vandq_s8(v64, v24);
                  a4 = v61 + 4 * v71.u32[2];
                  v71.i32[0] = *(_DWORD *)(v61 + 4 * v71.u32[0]);
                  v71.i32[1] = *(_DWORD *)(v61 + 4 * v71.u32[1]);
                  v71.i32[2] = *(_DWORD *)a4;
                  v71.i32[3] = *(_DWORD *)(v61 + 4 * v71.u32[3]);
                  *(int16x4_t *)&a2[v70 * 2] = vmovn_s32((int32x4_t)vcvtq_u32_f32(vminnmq_f32(vmulq_f32(v71, v28), v25)));
                  v70 += 4;
                  v69 -= 4;
                }
                while (v69 > 8);
              }
              else
              {
                uint64_t v139 = 0;
                unsigned int v140 = v59 + 1;
                do
                {
                  a4 = (int)fminf(*(float *)(v61 + 4 * (v19[v139] & 0x7FF)) * 2048.0, 3071.0);
                  *(_WORD *)&a2[v139 * 2] = a4;
                  ++v139;
                  --v140;
                }
                while (v140 > 1);
                uint64_t v30 = 2 * v17;
                if (v60 < 1) {
                  goto LABEL_144;
                }
                uint64_t v141 = &a2[v139 * 2];
                uint64_t v142 = &v19[v139];
                do
                {
                  LODWORD(a4) = v59 + 1;
                  do
                  {
                    a6 = v142[v59];
                    unsigned __int16 v143 = a6 + *v142;
                    v142[v59] = v143;
                    a5 = (int)fminf(*(float *)(v61 + 4 * (v143 & 0x7FF)) * 2048.0, 3071.0);
                    *(_WORD *)uint64_t v141 = a5;
                    v141 += 2;
                    ++v142;
                    a4 = (a4 - 1);
                  }
                  while ((int)a4 > 1);
                  BOOL v107 = __OFSUB__(v60, v59);
                  v60 -= v59;
                }
                while (!((v60 < 0) ^ v107 | (v60 == 0)));
              }
              goto LABEL_131;
            case 4:
              uint64_t v72 = *(unsigned __int16 *)(v11 + 256);
              uint64_t v30 = 2 * v17;
              int v73 = v17 - v72;
              if (v17 < (int)v72) {
                goto LABEL_144;
              }
              uint64_t v74 = *(void *)(v11 + 296);
              if (v72 == 3)
              {
                uint64_t v144 = *v19 & 0x7FF;
                *(_WORD *)a2 = *(_WORD *)(v74 + 2 * v144);
                uint64_t v145 = v19[1] & 0x7FF;
                *((_WORD *)a2 + 1) = *(_WORD *)(v74 + 2 * v145);
                uint64_t v146 = v19[2] & 0x7FF;
                *((_WORD *)a2 + 2) = *(_WORD *)(v74 + 2 * v146);
                uint64_t v30 = 2 * v17;
                if (v17 < 4) {
                  goto LABEL_144;
                }
                uint64_t v147 = 0;
                LODWORD(a4) = v17 + 3;
                do
                {
                  LODWORD(v144) = v144 + v19[v147 + 3];
                  a7 = (uint64_t)&a2[v147 * 2 + 10];
                  *(_WORD *)(a7 - 4) = *(_WORD *)(v74 + 2 * (v144 & 0x7FF));
                  LODWORD(v145) = v145 + v19[v147 + 4];
                  a6 = *(unsigned __int16 *)(v74 + 2 * (v145 & 0x7FF));
                  *(_WORD *)(a7 - 2) = a6;
                  LODWORD(v146) = v146 + v19[v147 + 5];
                  a5 = *(unsigned __int16 *)(v74 + 2 * (v146 & 0x7FF));
                  *(_WORD *)a7 = a5;
                  a4 = (a4 - 3);
                  v147 += 3;
                }
                while (a4 > 6);
                goto LABEL_131;
              }
              if (v72 == 4)
              {
                uint64_t v75 = *v19 & 0x7FF;
                *(_WORD *)a2 = *(_WORD *)(v74 + 2 * v75);
                uint64_t v76 = v19[1] & 0x7FF;
                *((_WORD *)a2 + 1) = *(_WORD *)(v74 + 2 * v76);
                uint64_t v77 = v19[2] & 0x7FF;
                *((_WORD *)a2 + 2) = *(_WORD *)(v74 + 2 * v77);
                uint64_t v78 = v19[3] & 0x7FF;
                *((_WORD *)a2 + 3) = *(_WORD *)(v74 + 2 * v78);
                uint64_t v30 = 2 * v17;
                if (v17 < 5) {
                  goto LABEL_144;
                }
                uint64_t v79 = 0;
                a4 = (uint64_t)(a2 + 14);
                LODWORD(a5) = v17 + 4;
                do
                {
                  LODWORD(v75) = v75 + v19[v79 + 4];
                  a8 = (_WORD *)(a4 + v79 * 2);
                  *(a8 - 3) = *(_WORD *)(v74 + 2 * (v75 & 0x7FF));
                  LODWORD(v76) = v76 + v19[v79 + 5];
                  *(a8 - 2) = *(_WORD *)(v74 + 2 * (v76 & 0x7FF));
                  LODWORD(v77) = v77 + v19[v79 + 6];
                  a7 = *(unsigned __int16 *)(v74 + 2 * (v77 & 0x7FF));
                  *(a8 - 1) = a7;
                  LODWORD(v78) = v78 + v19[v79 + 7];
                  a6 = *(unsigned __int16 *)(v74 + 2 * (v78 & 0x7FF));
                  *a8 = a6;
                  a5 = (a5 - 4);
                  v79 += 4;
                }
                while (a5 > 8);
                goto LABEL_131;
              }
              uint64_t v148 = 0;
              unsigned int v149 = v72 + 1;
              do
              {
                a4 = *(unsigned __int16 *)(v74 + 2 * (v19[v148] & 0x7FF));
                *(_WORD *)&a2[v148 * 2] = a4;
                ++v148;
                --v149;
              }
              while (v149 > 1);
              uint64_t v30 = 2 * v17;
              if (v73 >= 1)
              {
                uint64_t v150 = &a2[v148 * 2];
                uint64_t v151 = &v19[v148];
                do
                {
                  LODWORD(a4) = v72 + 1;
                  do
                  {
                    a6 = v151[v72];
                    v151[v72] = a6 + *v151;
                    __int16 v152 = *v151++;
                    a5 = *(unsigned __int16 *)(v74 + 2 * (v152 & 0x7FF));
                    *(_WORD *)uint64_t v150 = a5;
                    v150 += 2;
                    a4 = (a4 - 1);
                  }
                  while ((int)a4 > 1);
                  BOOL v107 = __OFSUB__(v73, v72);
                  v73 -= v72;
                }
                while (!((v73 < 0) ^ v107 | (v73 == 0)));
LABEL_131:
                uint64_t v30 = 2 * v17;
                goto LABEL_144;
              }
              goto LABEL_144;
            case 5:
              uint64_t v80 = *(unsigned __int16 *)(v11 + 256);
              uint64_t v30 = 4 * v17;
              int v81 = v17 - v80;
              if (v17 < (int)v80) {
                goto LABEL_144;
              }
              uint64_t v82 = *(void *)(v11 + 288);
              if (v80 == 3)
              {
                uint64_t v153 = *v19 & 0x7FF;
                uint64_t v154 = v19[1] & 0x7FF;
                int v155 = *(_DWORD *)(v82 + 4 * v154);
                uint64_t v156 = v19[2] & 0x7FF;
                int v157 = *(_DWORD *)(v82 + 4 * v156);
                *(_DWORD *)a2 = *(_DWORD *)(v82 + 4 * v153);
                *((_DWORD *)a2 + 1) = v155;
                *((_DWORD *)a2 + 2) = v157;
                uint64_t v30 = 4 * v17;
                if (v17 < 4) {
                  goto LABEL_144;
                }
                uint64_t v158 = a2 + 20;
                uint64_t v159 = v23;
                LODWORD(a4) = v17 + 3;
                do
                {
                  LODWORD(v153) = v153 + *(v159 - 2);
                  LODWORD(v154) = v154 + *(v159 - 1);
                  int v160 = *(_DWORD *)(v82 + 4 * (v154 & 0x7FF));
                  int v161 = *v159;
                  v159 += 3;
                  LODWORD(v156) = v156 + v161;
                  a5 = v156 & 0x7FF;
                  int v162 = *(_DWORD *)(v82 + 4 * a5);
                  *(v158 - 2) = *(_DWORD *)(v82 + 4 * (v153 & 0x7FF));
                  *(v158 - 1) = v160;
                  *uint64_t v158 = v162;
                  v158 += 3;
                  a4 = (a4 - 3);
                }
                while (a4 > 6);
                goto LABEL_143;
              }
              if (v80 == 4)
              {
                v83.i32[0] = *(void *)v19 & 0x7FF07FF;
                v83.i16[2] = HIDWORD(*(void *)v19) & 0x7FF;
                v83.i16[3] = v83.i16[2];
                int v84 = *(_DWORD *)(v82 + 4 * v83.u16[1]);
                int8x16_t v85 = (int8x16_t)vmovl_u16(v83);
                v86.i64[0] = v85.u32[2];
                v86.i64[1] = v85.u32[3];
                int8x16_t v87 = vandq_s8(v86, v27);
                v87.i32[0] = *(_DWORD *)(v82 + 4 * v87.i64[0]);
                int v88 = *(_DWORD *)(v82 + 4 * v87.i64[1]);
                *(_DWORD *)a2 = *(_DWORD *)(v82 + 4 * (*(void *)v19 & 0x7FFLL));
                *((_DWORD *)a2 + 1) = v84;
                *((_DWORD *)a2 + 2) = v87.i32[0];
                *((_DWORD *)a2 + 3) = v88;
                uint64_t v30 = 4 * v17;
                if (v17 < 5) {
                  goto LABEL_144;
                }
                uint64_t v89 = a2 + 28;
                unsigned int v90 = v17 + 4;
                uint64_t v91 = 4;
                do
                {
                  int8x16_t v85 = (int8x16_t)vaddw_u16((uint32x4_t)v85, *(uint16x4_t *)&v19[v91]);
                  int8x16_t v92 = vandq_s8(v85, v24);
                  int v93 = *(_DWORD *)(v82 + 4 * v92.u32[0]);
                  int v94 = *(_DWORD *)(v82 + 4 * v92.u32[1]);
                  v92.i32[0] = *(_DWORD *)(v82 + 4 * v92.u32[2]);
                  int v95 = *(_DWORD *)(v82 + 4 * v92.u32[3]);
                  *(v89 - 3) = v93;
                  *(v89 - 2) = v94;
                  *(v89 - 1) = v92.i32[0];
                  *uint64_t v89 = v95;
                  v91 += 4;
                  v89 += 4;
                  v90 -= 4;
                }
                while (v90 > 8);
                goto LABEL_143;
              }
              unsigned int v163 = v80 + 1;
              uint64_t v164 = a2;
              a4 = (uint64_t)v19;
              do
              {
                __int16 v165 = *(_WORD *)a4;
                a4 += 2;
                a5 = v165 & 0x7FF;
                *v164++ = *(_DWORD *)(v82 + 4 * a5);
                --v163;
              }
              while (v163 > 1);
              uint64_t v30 = 4 * v17;
              if (v81 >= 1)
              {
                do
                {
                  int v166 = v80 + 1;
                  do
                  {
                    a6 = *(unsigned __int16 *)(a4 + 2 * v80);
                    *(_WORD *)(a4 + 2 * v80) = a6 + *(_WORD *)a4;
                    __int16 v167 = *(_WORD *)a4;
                    a4 += 2;
                    a5 = v167 & 0x7FF;
                    *v164++ = *(_DWORD *)(v82 + 4 * a5);
                    --v166;
                  }
                  while (v166 > 1);
                  BOOL v107 = __OFSUB__(v81, v80);
                  v81 -= v80;
                }
                while (!((v81 < 0) ^ v107 | (v81 == 0)));
LABEL_143:
                uint64_t v30 = 4 * v17;
                goto LABEL_144;
              }
              goto LABEL_144;
            default:
              TIFFErrorExtR(a1, "PixarLogDecode", "Unsupported bits/sample: %hu", a4, a5, a6, a7, (uint64_t)a8, *(_WORD *)(a1 + 116));
              goto LABEL_150;
          }
        }
      }
      return 1;
    }
    if (v18 == -3)
    {
      TIFFErrorExtR(a1, "PixarLogDecode", "Decoding error at scanline %u, %s", a4, a5, a6, a7, (uint64_t)a8, *(_DWORD *)(a1 + 876));
      goto LABEL_150;
    }
    CGImageRef v169 = *(const char **)(v11 + 176);
    if (!v169) {
      CGImageRef v169 = "(null)";
    }
    char v170 = (char)v169;
    uint64_t v16 = "ZLib error: %s";
  }
  else
  {
    uint64_t v16 = "sp->stream.avail_out > sp->tbuf_size";
  }
  TIFFErrorExtR(a1, "PixarLogDecode", v16, a4, a5, a6, a7, (uint64_t)a8, v170);
LABEL_150:
  bzero(a2, a3);
  return 0;
}

uint64_t PixarLogSetupEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 1096);
  if (!v8) {
    PixarLogSetupEncode_cold_1();
  }
  if (*(_WORD *)(a1 + 170) == 1) {
    unsigned int v10 = *(unsigned __int16 *)(a1 + 130);
  }
  else {
    unsigned int v10 = 1;
  }
  *(_WORD *)(v8 + 256) = v10;
  int64_t v11 = _TIFFMultiplySSize(0, v10, *(unsigned int *)(a1 + 88), 0, a5, a6, a7, a8);
  int64_t v16 = _TIFFMultiplySSize(0, v11, *(unsigned int *)(a1 + 132), 0, v12, v13, v14, v15);
  uint64_t result = _TIFFMultiplySSize(0, v16, 2, 0, v17, v18, v19, v20);
  if (result)
  {
    uint64_t result = (uint64_t)_TIFFmallocExt((void *)a1, result, v22, v23, v24, v25, v26, v27);
    *(void *)(v8 + 248) = result;
    if (result)
    {
      if (*(_DWORD *)(v8 + 264) == -1 && (int v28 = PixarLogGuessDataFmt(a1 + 72), *(_DWORD *)(v8 + 264) = v28, v28 == -1))
      {
        TIFFErrorExtR(a1, "PixarLogSetupEncode", "PixarLog compression can't handle %hu bit linear encodings", v29, v30, v31, v32, v33, *(_WORD *)(a1 + 116));
      }
      else
      {
        if (!deflateInit_((z_streamp)(v8 + 128), *(_DWORD *)(v8 + 268), "1.2.12", 112))
        {
          *(_DWORD *)(v8 + 260) |= 1u;
          return 1;
        }
        uint64_t v39 = *(const char **)(v8 + 176);
        if (!v39) {
          uint64_t v39 = "(null)";
        }
        TIFFErrorExtR(a1, "PixarLogSetupEncode", "%s", v34, v35, v36, v37, v38, (char)v39);
      }
      return 0;
    }
  }
  return result;
}

BOOL PixarLogPreEncode(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[137];
  if (!v8) {
    PixarLogPreEncode_cold_1();
  }
  *(void *)(v8 + 152) = a1[140];
  unint64_t v9 = a1[141];
  *(_DWORD *)(v8 + 160) = v9;
  if (!HIDWORD(v9)) {
    return deflateReset((z_streamp)(v8 + 128)) == 0;
  }
  TIFFErrorExtR((uint64_t)a1, "PixarLogPreEncode", "ZLib cannot deal with buffers this size", a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t PixarLogPostEncode(void *a1)
{
  uint64_t v2 = a1[137];
  *(_DWORD *)(v2 + 136) = 0;
  while (1)
  {
    unsigned int v3 = deflate((z_streamp)(v2 + 128), 4);
    if (v3 > 1) {
      break;
    }
    unsigned int v11 = v3;
    uint64_t v12 = a1[141] - *(unsigned int *)(v2 + 160);
    if (v12)
    {
      a1[145] = v12;
      uint64_t result = TIFFFlushData1((uint64_t)a1, v4, v5, v6, v7, v8, v9, v10);
      if (!result) {
        return result;
      }
      *(void *)(v2 + 152) = a1[140];
      *(_DWORD *)(v2 + 160) = a1[141];
    }
    if (v11 == 1) {
      return 1;
    }
  }
  uint64_t v14 = *(const char **)(v2 + 176);
  if (!v14) {
    uint64_t v14 = "(null)";
  }
  TIFFErrorExtR((uint64_t)a1, "PixarLogPostEncode", "ZLib error: %s", v6, v7, v8, v9, v10, (char)v14);
  return 0;
}

uint64_t PixarLogEncode(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void **)(a1 + 1096);
  unsigned int v9 = *((_DWORD *)v8 + 66);
  if (v9 - 2 < 3)
  {
    a3 = (unint64_t)a3 >> 1;
  }
  else if (v9 >= 2)
  {
    if (v9 != 5) {
      goto LABEL_183;
    }
    a3 = (unint64_t)a3 >> 2;
  }
  uint64_t v10 = *(_DWORD *)(a1 + 88) * *((unsigned __int16 *)v8 + 128);
  if (a3 > *(unsigned int *)(a1 + 132) * v10)
  {
    unsigned int v11 = "Too many input bytes provided";
LABEL_184:
    TIFFErrorExtR(a1, "PixarLogEncode", v11, a4, a5, a6, a7, a8, v135);
    return 0;
  }
  unsigned int v140 = (void *)a1;
  uint64_t v141 = v8[31];
  if (a3 >= 1)
  {
    if (v9 <= 5 && ((1 << v9) & 0x31) != 0)
    {
      uint64_t v13 = 0;
      uint64_t v147 = 2 * v10;
      float v14 = *(float *)&Fltsize;
      double v15 = *(float *)&LogK1;
      float v137 = *(float *)&LogK2;
      uint64_t v142 = 4 * v10;
      unsigned int v139 = v10 + 4;
      unsigned int v138 = v10 + 3;
      int64_t v16 = (_WORD *)v8[31];
      uint64_t v150 = (_WORD *)(v141 + 14);
      unsigned int v149 = (_WORD *)(v141 + 10);
      HIDWORD(v17) = 1084226560;
      uint64_t v145 = a3;
      uint64_t v146 = *(void **)(a1 + 1096);
      unsigned int v144 = *((_DWORD *)v8 + 66);
      uint64_t v143 = *(_DWORD *)(a1 + 88) * *((unsigned __int16 *)v8 + 128);
      double v136 = *(float *)&LogK1;
      while (1)
      {
        uint64_t v151 = a2;
        uint64_t v148 = v13;
        if (v9 == 4)
        {
          int v24 = *((unsigned __int16 *)v8 + 128);
          uint64_t v19 = v147;
          uint64_t v20 = v10;
          if ((int)v10 >= v24)
          {
            uint64_t v25 = v146[40];
            if (v24 == 3)
            {
              __int16 v65 = *(_WORD *)(v25 + (((unint64_t)*a2 >> 1) & 0x7FFE));
              *int64_t v16 = v65;
              __int16 v66 = *(_WORD *)(v25 + (((unint64_t)a2[1] >> 1) & 0x7FFE));
              v16[1] = v66;
              __int16 v67 = *(_WORD *)(v25 + (((unint64_t)a2[2] >> 1) & 0x7FFE));
              _OWORD v16[2] = v67;
              uint64_t v19 = v147;
              uint64_t v20 = v143;
              if ((int)v143 >= 4)
              {
                uint64_t v68 = 0;
                unsigned int v69 = a2 + 3;
                unsigned int v70 = v138;
                do
                {
                  float32x4_t v71 = &v16[v68];
                  __int16 v72 = *(_WORD *)(v25 + (((unint64_t)v69[v68] >> 1) & 0x7FFE));
                  v71[3] = (v72 - v65) & 0x7FF;
                  __int16 v73 = *(_WORD *)(v25 + (((unint64_t)v69[v68 + 1] >> 1) & 0x7FFE));
                  v71[4] = (v73 - v66) & 0x7FF;
                  __int16 v74 = *(_WORD *)(v25 + (((unint64_t)v69[v68 + 2] >> 1) & 0x7FFE));
                  v70 -= 3;
                  v71[5] = (v74 - v67) & 0x7FF;
                  v68 += 3;
                  __int16 v67 = v74;
                  __int16 v66 = v73;
                  __int16 v65 = v72;
                }
                while (v70 > 6);
                goto LABEL_77;
              }
            }
            else
            {
              if (v24 != 4)
              {
                uint64_t v75 = 0;
                unsigned int v76 = v24 + 1;
                do
                {
                  v16[v75] = *(_WORD *)(v25 + (((unint64_t)a2[v75] >> 1) & 0x7FFE));
                  ++v75;
                  --v76;
                }
                while (v76 > 1);
                uint64_t v20 = v143;
                int v77 = v143 - v24;
                uint64_t v19 = v147;
                if ((int)v143 - v24 < 1) {
                  goto LABEL_171;
                }
                uint64_t v78 = &v16[v75];
                uint64_t v79 = &a2[v75];
                do
                {
                  int v80 = v24 + 1;
                  do
                  {
                    *v78++ = (*(_WORD *)(v25 + (((unint64_t)*v79 >> 1) & 0x7FFE))
                            - *(_WORD *)(v25 + (((unint64_t)v79[-v24] >> 1) & 0x7FFE))) & 0x7FF;
                    ++v79;
                    --v80;
                  }
                  while (v80 > 1);
                  BOOL v64 = __OFSUB__(v77, v24);
                  v77 -= v24;
                }
                while (!((v77 < 0) ^ v64 | (v77 == 0)));
LABEL_77:
                uint64_t v19 = v147;
LABEL_170:
                uint64_t v20 = v143;
                goto LABEL_171;
              }
              __int16 v26 = *(_WORD *)(v25 + (((unint64_t)*a2 >> 1) & 0x7FFE));
              *int64_t v16 = v26;
              __int16 v27 = *(_WORD *)(v25 + (((unint64_t)a2[1] >> 1) & 0x7FFE));
              v16[1] = v27;
              __int16 v28 = *(_WORD *)(v25 + (((unint64_t)a2[2] >> 1) & 0x7FFE));
              _OWORD v16[2] = v28;
              __int16 v29 = *(_WORD *)(v25 + (((unint64_t)a2[3] >> 1) & 0x7FFE));
              void v16[3] = v29;
              uint64_t v19 = v147;
              uint64_t v20 = v143;
              if ((int)v143 >= 5)
              {
                uint64_t v30 = 0;
                uint64_t v31 = a2 + 4;
                unsigned int v32 = v139;
                do
                {
                  uint64_t v33 = &v16[v30];
                  __int16 v34 = *(_WORD *)(v25 + (((unint64_t)v31[v30] >> 1) & 0x7FFE));
                  v33[4] = (v34 - v26) & 0x7FF;
                  __int16 v35 = *(_WORD *)(v25 + (((unint64_t)v31[v30 + 1] >> 1) & 0x7FFE));
                  v33[5] = (v35 - v27) & 0x7FF;
                  __int16 v36 = *(_WORD *)(v25 + (((unint64_t)v31[v30 + 2] >> 1) & 0x7FFE));
                  v33[6] = (v36 - v28) & 0x7FF;
                  __int16 v37 = *(_WORD *)(v25 + (((unint64_t)v31[v30 + 3] >> 1) & 0x7FFE));
                  v32 -= 4;
                  v30 += 4;
                  v33[7] = (v37 - v29) & 0x7FF;
                  __int16 v29 = v37;
                  __int16 v28 = v36;
                  __int16 v27 = v35;
                  __int16 v26 = v34;
                }
                while (v32 > 8);
                goto LABEL_77;
              }
            }
          }
        }
        else if (v9 == 5)
        {
          int v18 = *((unsigned __int16 *)v8 + 128);
          uint64_t v19 = v142;
          uint64_t v20 = v10;
          if ((int)v10 >= v18)
          {
            uint64_t v21 = v146[39];
            if (v18 == 3)
            {
              LODWORD(v17) = *(_DWORD *)a2;
              double v52 = 0.0;
              double v53 = 0.0;
              if (*(float *)a2 >= 0.0)
              {
                if (*(float *)&v17 >= 2.0)
                {
                  double v53 = 2047.0;
                  if (*(float *)&v17 <= 24.2)
                  {
                    long double v17 = log((float)(*(float *)&v17 * v137));
                    double v53 = v15 * v17 + 0.5;
                  }
                }
                else
                {
                  *(float *)&long double v17 = v14 * *(float *)&v17;
                  LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                  double v53 = (double)*(unint64_t *)&v17;
                }
              }
              int v97 = (int)v53;
              *int64_t v16 = (int)v53;
              LODWORD(v17) = v151[1];
              if (*(float *)&v17 >= 0.0)
              {
                if (*(float *)&v17 >= 2.0)
                {
                  double v52 = 2047.0;
                  if (*(float *)&v17 <= 24.2)
                  {
                    long double v17 = log((float)(*(float *)&v17 * v137));
                    double v52 = v15 * v17 + 0.5;
                  }
                }
                else
                {
                  *(float *)&long double v17 = v14 * *(float *)&v17;
                  LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                  double v52 = (double)*(unint64_t *)&v17;
                }
              }
              int v98 = (int)v52;
              v16[1] = (int)v52;
              LODWORD(v17) = v151[2];
              double v99 = 0.0;
              if (*(float *)&v17 >= 0.0)
              {
                if (*(float *)&v17 >= 2.0)
                {
                  double v99 = 2047.0;
                  if (*(float *)&v17 <= 24.2)
                  {
                    long double v17 = log((float)(*(float *)&v17 * v137));
                    double v99 = v15 * v17 + 0.5;
                  }
                }
                else
                {
                  *(float *)&long double v17 = v14 * *(float *)&v17;
                  LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                  double v99 = (double)*(unint64_t *)&v17;
                }
              }
              int v100 = (int)v99;
              _OWORD v16[2] = (int)v99;
              uint64_t v19 = v142;
              uint64_t v20 = v143;
              if ((int)v143 < 4) {
                goto LABEL_171;
              }
              double v101 = *(float *)&LogK1;
              float v102 = *(float *)&LogK2;
              uint64_t v103 = v151 + 5;
              __int16 v104 = v149;
              unsigned int v105 = v138;
              do
              {
                LODWORD(v17) = *(v103 - 2);
                double v106 = 0.0;
                double v107 = 0.0;
                if (*(float *)&v17 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    double v107 = 2047.0;
                    if (*(float *)&v17 <= 24.2)
                    {
                      long double v17 = log((float)(v102 * *(float *)&v17));
                      double v107 = v101 * v17 + 0.5;
                    }
                  }
                  else
                  {
                    *(float *)&long double v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    double v107 = (double)*(unint64_t *)&v17;
                  }
                }
                int v108 = (int)v107;
                *(v104 - 2) = ((int)v107 - v97) & 0x7FF;
                LODWORD(v17) = *(v103 - 1);
                if (*(float *)&v17 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    double v106 = 2047.0;
                    if (*(float *)&v17 <= 24.2)
                    {
                      long double v17 = log((float)(v102 * *(float *)&v17));
                      double v106 = v101 * v17 + 0.5;
                    }
                  }
                  else
                  {
                    *(float *)&long double v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    double v106 = (double)*(unint64_t *)&v17;
                  }
                }
                *(v104 - 1) = ((int)v106 - v98) & 0x7FF;
                LODWORD(v17) = *v103;
                double v109 = 0.0;
                if (*(float *)v103 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    double v109 = 2047.0;
                    if (*(float *)&v17 <= 24.2)
                    {
                      long double v17 = log((float)(v102 * *(float *)&v17));
                      double v109 = v101 * v17 + 0.5;
                    }
                  }
                  else
                  {
                    *(float *)&long double v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    double v109 = (double)*(unint64_t *)&v17;
                  }
                }
                _WORD *v104 = ((int)v109 - v100) & 0x7FF;
                v104 += 3;
                v105 -= 3;
                v103 += 3;
                int v100 = (int)v109;
                int v98 = (int)v106;
                LOWORD(v97) = v108;
              }
              while (v105 > 6);
LABEL_169:
              uint64_t v19 = v142;
              goto LABEL_170;
            }
            if (v18 != 4)
            {
              double v54 = *(float *)&LogK1;
              float v55 = *(float *)&LogK2;
              unsigned int v56 = v18 + 1;
              int v57 = v16;
              unsigned int v58 = a2;
              do
              {
                LODWORD(v17) = *v58;
                double v59 = 0.0;
                if (*(float *)v58 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    if (*(float *)&v17 <= 24.2)
                    {
                      long double v17 = log((float)(v55 * *(float *)&v17));
                      double v59 = v54 * v17 + 0.5;
                    }
                    else
                    {
                      double v59 = 2047.0;
                    }
                  }
                  else
                  {
                    *(float *)&long double v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    double v59 = (double)*(unint64_t *)&v17;
                  }
                }
                *v57++ = (int)v59;
                ++v58;
                --v56;
              }
              while (v56 > 1);
              uint64_t v20 = v143;
              int v60 = v143 - v18;
              uint64_t v19 = v142;
              if ((int)v143 - v18 >= 1)
              {
                do
                {
                  int v61 = v18 + 1;
                  do
                  {
                    LODWORD(v17) = *v58;
                    double v62 = 0.0;
                    double v63 = 0.0;
                    if (*(float *)v58 >= 0.0)
                    {
                      if (*(float *)&v17 >= 2.0)
                      {
                        if (*(float *)&v17 <= 24.2)
                        {
                          long double v17 = log((float)(v55 * *(float *)&v17));
                          double v63 = v54 * v17 + 0.5;
                        }
                        else
                        {
                          double v63 = 2047.0;
                        }
                      }
                      else
                      {
                        *(float *)&long double v17 = v14 * *(float *)&v17;
                        LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                        double v63 = (double)*(unint64_t *)&v17;
                      }
                    }
                    LODWORD(v17) = v58[-v18];
                    if (*(float *)&v17 >= 0.0)
                    {
                      if (*(float *)&v17 >= 2.0)
                      {
                        if (*(float *)&v17 <= 24.2)
                        {
                          long double v17 = log((float)(v55 * *(float *)&v17));
                          double v62 = v54 * v17 + 0.5;
                        }
                        else
                        {
                          double v62 = 2047.0;
                        }
                      }
                      else
                      {
                        *(float *)&long double v17 = v14 * *(float *)&v17;
                        LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                        double v62 = (double)*(unint64_t *)&v17;
                      }
                    }
                    *v57++ = ((int)v63 - (int)v62) & 0x7FF;
                    ++v58;
                    --v61;
                  }
                  while (v61 > 1);
                  BOOL v64 = __OFSUB__(v60, v18);
                  v60 -= v18;
                }
                while (!((v60 < 0) ^ v64 | (v60 == 0)));
                uint64_t v19 = v142;
                uint64_t v20 = v143;
                double v15 = v136;
              }
              goto LABEL_171;
            }
            LODWORD(v17) = *(_DWORD *)a2;
            double v22 = 0.0;
            double v23 = 0.0;
            if (*(float *)a2 >= 0.0)
            {
              if (*(float *)&v17 >= 2.0)
              {
                if (*(float *)&v17 <= 24.2)
                {
                  long double v17 = log((float)(*(float *)&v17 * v137));
                  double v23 = v15 * v17 + 0.5;
                }
                else
                {
                  double v23 = 2047.0;
                }
              }
              else
              {
                *(float *)&long double v17 = v14 * *(float *)&v17;
                LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                double v23 = (double)*(unint64_t *)&v17;
              }
            }
            int v110 = (int)v23;
            *int64_t v16 = (int)v23;
            LODWORD(v17) = v151[1];
            if (*(float *)&v17 >= 0.0)
            {
              if (*(float *)&v17 >= 2.0)
              {
                if (*(float *)&v17 <= 24.2)
                {
                  long double v17 = log((float)(*(float *)&v17 * v137));
                  double v22 = v15 * v17 + 0.5;
                }
                else
                {
                  double v22 = 2047.0;
                }
              }
              else
              {
                *(float *)&long double v17 = v14 * *(float *)&v17;
                LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                double v22 = (double)*(unint64_t *)&v17;
              }
            }
            int v111 = (int)v22;
            v16[1] = (int)v22;
            LODWORD(v17) = v151[2];
            double v112 = 0.0;
            double v113 = 0.0;
            if (*(float *)&v17 >= 0.0)
            {
              if (*(float *)&v17 >= 2.0)
              {
                if (*(float *)&v17 <= 24.2)
                {
                  long double v17 = log((float)(*(float *)&v17 * v137));
                  double v113 = v15 * v17 + 0.5;
                }
                else
                {
                  double v113 = 2047.0;
                }
              }
              else
              {
                *(float *)&long double v17 = v14 * *(float *)&v17;
                LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                double v113 = (double)*(unint64_t *)&v17;
              }
            }
            int v114 = (int)v113;
            _OWORD v16[2] = (int)v113;
            LODWORD(v17) = v151[3];
            if (*(float *)&v17 >= 0.0)
            {
              if (*(float *)&v17 >= 2.0)
              {
                if (*(float *)&v17 <= 24.2)
                {
                  long double v17 = log((float)(*(float *)&v17 * v137));
                  double v112 = v15 * v17 + 0.5;
                }
                else
                {
                  double v112 = 2047.0;
                }
              }
              else
              {
                *(float *)&long double v17 = v14 * *(float *)&v17;
                LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                double v112 = (double)*(unint64_t *)&v17;
              }
            }
            int v115 = (int)v112;
            void v16[3] = (int)v112;
            uint64_t v19 = v142;
            uint64_t v20 = v143;
            if ((int)v143 >= 5)
            {
              double v116 = *(float *)&LogK1;
              float v117 = *(float *)&LogK2;
              int v118 = v150;
              __int16 v119 = v151 + 7;
              unsigned int v120 = v139;
              do
              {
                LODWORD(v17) = *(v119 - 3);
                double v121 = 0.0;
                double v122 = 0.0;
                if (*(float *)&v17 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    if (*(float *)&v17 <= 24.2)
                    {
                      long double v17 = log((float)(v117 * *(float *)&v17));
                      double v122 = v116 * v17 + 0.5;
                    }
                    else
                    {
                      double v122 = 2047.0;
                    }
                  }
                  else
                  {
                    *(float *)&long double v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    double v122 = (double)*(unint64_t *)&v17;
                  }
                }
                int v123 = (int)v122;
                *(v118 - 3) = ((int)v122 - v110) & 0x7FF;
                LODWORD(v17) = *(v119 - 2);
                if (*(float *)&v17 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    if (*(float *)&v17 <= 24.2)
                    {
                      long double v17 = log((float)(v117 * *(float *)&v17));
                      double v121 = v116 * v17 + 0.5;
                    }
                    else
                    {
                      double v121 = 2047.0;
                    }
                  }
                  else
                  {
                    *(float *)&long double v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    double v121 = (double)*(unint64_t *)&v17;
                  }
                }
                int v110 = (int)v121;
                *(v118 - 2) = ((int)v121 - v111) & 0x7FF;
                LODWORD(v17) = *(v119 - 1);
                double v124 = 0.0;
                double v125 = 0.0;
                if (*(float *)&v17 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    if (*(float *)&v17 <= 24.2)
                    {
                      long double v17 = log((float)(v117 * *(float *)&v17));
                      double v125 = v116 * v17 + 0.5;
                    }
                    else
                    {
                      double v125 = 2047.0;
                    }
                  }
                  else
                  {
                    *(float *)&long double v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    double v125 = (double)*(unint64_t *)&v17;
                  }
                }
                int v111 = (int)v125;
                *(v118 - 1) = ((int)v125 - v114) & 0x7FF;
                LODWORD(v17) = *v119;
                if (*(float *)v119 >= 0.0)
                {
                  if (*(float *)&v17 >= 2.0)
                  {
                    if (*(float *)&v17 <= 24.2)
                    {
                      long double v17 = log((float)(v117 * *(float *)&v17));
                      double v124 = v116 * v17 + 0.5;
                    }
                    else
                    {
                      double v124 = 2047.0;
                    }
                  }
                  else
                  {
                    *(float *)&long double v17 = v14 * *(float *)&v17;
                    LOWORD(v17) = *(_WORD *)(v21 + 2 * (int)*(float *)&v17);
                    double v124 = (double)*(unint64_t *)&v17;
                  }
                }
                *int v118 = ((int)v124 - v115) & 0x7FF;
                v118 += 4;
                v120 -= 4;
                v119 += 4;
                int v115 = (int)v124;
                LOWORD(v114) = v111;
                LOWORD(v111) = v110;
                LOWORD(v110) = v123;
              }
              while (v120 > 8);
              goto LABEL_169;
            }
          }
        }
        else
        {
          uint64_t v38 = *((unsigned __int16 *)v8 + 128);
          uint64_t v19 = v10;
          uint64_t v20 = v10;
          if ((int)v10 >= (int)v38)
          {
            uint64_t v39 = v146[41];
            if (v38 == 3)
            {
              __int16 v81 = *(_WORD *)(v39 + 2 * *(unsigned __int8 *)a2);
              *int64_t v16 = v81;
              __int16 v82 = *(_WORD *)(v39 + 2 * *((unsigned __int8 *)a2 + 1));
              v16[1] = v82;
              __int16 v83 = *(_WORD *)(v39 + 2 * *((unsigned __int8 *)a2 + 2));
              _OWORD v16[2] = v83;
              uint64_t v20 = v143;
              uint64_t v19 = v143;
              if ((int)v143 >= 4)
              {
                int v84 = (unsigned __int8 *)a2 + 5;
                int8x16_t v85 = v149;
                unsigned int v86 = v138;
                do
                {
                  __int16 v87 = *(_WORD *)(v39 + 2 * *(v84 - 2));
                  *(v85 - 2) = (v87 - v81) & 0x7FF;
                  __int16 v88 = *(_WORD *)(v39 + 2 * *(v84 - 1));
                  *(v85 - 1) = (v88 - v82) & 0x7FF;
                  unsigned int v89 = *v84;
                  v84 += 3;
                  __int16 v90 = *(_WORD *)(v39 + 2 * v89);
                  *int8x16_t v85 = (v90 - v83) & 0x7FF;
                  v85 += 3;
                  v86 -= 3;
                  __int16 v83 = v90;
                  __int16 v82 = v88;
                  __int16 v81 = v87;
                }
                while (v86 > 6);
                goto LABEL_81;
              }
            }
            else
            {
              if (v38 != 4)
              {
                unsigned int v91 = v38 + 1;
                int8x16_t v92 = v16;
                int v93 = (unsigned __int8 *)a2;
                do
                {
                  unsigned int v94 = *v93++;
                  *v92++ = *(_WORD *)(v39 + 2 * v94);
                  --v91;
                }
                while (v91 > 1);
                uint64_t v20 = v143;
                int v95 = v143 - v38;
                uint64_t v19 = v143;
                if ((int)v143 - (int)v38 >= 1)
                {
                  do
                  {
                    int v96 = v38 + 1;
                    do
                    {
                      *v92++ = (*(_WORD *)(v39 + 2 * *v93) - *(_WORD *)(v39 + 2 * v93[-v38])) & 0x7FF;
                      ++v93;
                      --v96;
                    }
                    while (v96 > 1);
                    BOOL v64 = __OFSUB__(v95, v38);
                    v95 -= v38;
                  }
                  while (!((v95 < 0) ^ v64 | (v95 == 0)));
                  uint64_t v19 = v143;
                }
                goto LABEL_171;
              }
              __int16 v40 = *(_WORD *)(v39 + 2 * *(unsigned __int8 *)a2);
              *int64_t v16 = v40;
              __int16 v41 = *(_WORD *)(v39 + 2 * *((unsigned __int8 *)a2 + 1));
              v16[1] = v41;
              __int16 v42 = *(_WORD *)(v39 + 2 * *((unsigned __int8 *)a2 + 2));
              _OWORD v16[2] = v42;
              __int16 v43 = *(_WORD *)(v39 + 2 * *((unsigned __int8 *)a2 + 3));
              void v16[3] = v43;
              uint64_t v20 = v143;
              uint64_t v19 = v143;
              if ((int)v143 >= 5)
              {
                char v44 = v150;
                char v45 = (unsigned __int8 *)a2 + 7;
                unsigned int v46 = v139;
                do
                {
                  __int16 v47 = *(_WORD *)(v39 + 2 * *(v45 - 3));
                  *(v44 - 3) = (v47 - v40) & 0x7FF;
                  __int16 v48 = *(_WORD *)(v39 + 2 * *(v45 - 2));
                  *(v44 - 2) = (v48 - v41) & 0x7FF;
                  __int16 v49 = *(_WORD *)(v39 + 2 * *(v45 - 1));
                  *(v44 - 1) = (v49 - v42) & 0x7FF;
                  unsigned int v50 = *v45;
                  v45 += 4;
                  __int16 v51 = *(_WORD *)(v39 + 2 * v50);
                  _WORD *v44 = (v51 - v43) & 0x7FF;
                  v44 += 4;
                  v46 -= 4;
                  __int16 v43 = v51;
                  __int16 v42 = v49;
                  __int16 v41 = v48;
                  __int16 v40 = v47;
                }
                while (v46 > 8);
LABEL_81:
                uint64_t v20 = v143;
                uint64_t v19 = v143;
              }
            }
          }
        }
LABEL_171:
        a2 = (unsigned __int16 *)((char *)v151 + v19);
        uint64_t v13 = v148 + v20;
        int64_t v16 = (_WORD *)((char *)v16 + v147);
        uint64_t v150 = (_WORD *)((char *)v150 + v147);
        unsigned int v149 = (_WORD *)((char *)v149 + v147);
        LODWORD(a3) = v145;
        uint64_t v8 = v146;
        unsigned int v9 = v144;
        uint64_t v10 = v20;
        if (v148 + v20 >= v145) {
          goto LABEL_172;
        }
      }
    }
LABEL_183:
    __int16 v135 = *(_WORD *)(a1 + 116);
    unsigned int v11 = "%hu bit input not supported in PixarLog";
    goto LABEL_184;
  }
LABEL_172:
  v8[16] = v141;
  *((_DWORD *)v8 + 34) = 2 * a3;
  if ((a3 & 0x80000000) != 0)
  {
    unsigned int v11 = "ZLib cannot deal with buffers this size";
    a1 = (uint64_t)v140;
    goto LABEL_184;
  }
  while (!deflate((z_streamp)(v8 + 16), 0))
  {
    if (!*((_DWORD *)v8 + 40))
    {
      v140[145] = v140[141];
      uint64_t result = TIFFFlushData1((uint64_t)v140, v126, v127, v128, v129, v130, v131, v132);
      if (!result) {
        return result;
      }
      v8[19] = v140[140];
      *((_DWORD *)v8 + 40) = v140[141];
    }
    if (!*((_DWORD *)v8 + 34)) {
      return 1;
    }
  }
  uint64_t v134 = (const char *)v8[22];
  if (!v134) {
    uint64_t v134 = "(null)";
  }
  TIFFErrorExtR((uint64_t)v140, "PixarLogEncode", "Encoder error: %s", v128, v129, v130, v131, v132, (char)v134);
  return 0;
}

uint64_t PixarLogClose(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 1096);
  if (!v1) {
    PixarLogClose_cold_1();
  }
  if (*(unsigned char *)(v1 + 260)) {
    *(_DWORD *)(result + 116) = 65544;
  }
  return result;
}

uint64_t PixarLogCleanup(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1096);
  if (!v1) {
    PixarLogCleanup_cold_1();
  }
  TIFFPredictorCleanup((void *)a1);
  uint64_t v3 = *(void *)(v1 + 280);
  *(void *)(a1 + 1288) = *(void *)(v1 + 272);
  *(void *)(a1 + 1280) = v3;
  uint64_t v4 = *(char **)(v1 + 312);
  if (v4) {
    _TIFFfreeExt(a1, v4);
  }
  uint64_t v5 = *(char **)(v1 + 320);
  if (v5) {
    _TIFFfreeExt(a1, v5);
  }
  uint64_t v6 = *(char **)(v1 + 328);
  if (v6) {
    _TIFFfreeExt(a1, v6);
  }
  uint64_t v7 = *(char **)(v1 + 288);
  if (v7) {
    _TIFFfreeExt(a1, v7);
  }
  uint64_t v8 = *(char **)(v1 + 296);
  if (v8) {
    _TIFFfreeExt(a1, v8);
  }
  unsigned int v9 = *(char **)(v1 + 304);
  if (v9) {
    _TIFFfreeExt(a1, v9);
  }
  if (*(unsigned char *)(v1 + 260))
  {
    uint64_t v10 = (z_stream *)(v1 + 128);
    if (*(_DWORD *)(a1 + 12)) {
      deflateEnd(v10);
    }
    else {
      inflateEnd(v10);
    }
  }
  unsigned int v11 = *(char **)(v1 + 248);
  if (v11) {
    _TIFFfreeExt(a1, v11);
  }
  _TIFFfreeExt(a1, (char *)v1);
  *(void *)(a1 + 1096) = 0;

  return _TIFFSetDefaultCompressionState(a1);
}

uint64_t PixarLogVGetField(uint64_t a1, int a2, _DWORD **a3)
{
  uint64_t v3 = *(void *)(a1 + 1096);
  if (a2 == 65549)
  {
    int v4 = *(_DWORD *)(v3 + 264);
    goto LABEL_5;
  }
  if (a2 == 65558)
  {
    int v4 = *(_DWORD *)(v3 + 268);
LABEL_5:
    **a3 = v4;
    return 1;
  }
  return (*(uint64_t (**)(void))(v3 + 272))();
}

uint64_t PixarLogVSetField(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 1096);
  if (a2 == 65549)
  {
    unsigned int v18 = *a3;
    *(_DWORD *)(v9 + 264) = *a3;
    if (v18 <= 5)
    {
      _cg_TIFFSetField(a1, 258, (uint64_t)a3, a4, a5, a6, a7, a8, *(unsigned int *)&asc_1889AA8E8[4 * v18]);
      _cg_TIFFSetField(a1, 339, v19, v20, v21, v22, v23, v24, dword_1889AA900[v18]);
    }
    if ((*(unsigned char *)(a1 + 17) & 4) != 0) {
      uint64_t v25 = _cg_TIFFTileSize(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    }
    else {
      uint64_t v25 = -1;
    }
    *(void *)(a1 + 936) = v25;
    *(void *)(a1 + 1104) = _cg_TIFFScanlineSize(a1, a2, (uint64_t)a3, a4, a5, a6, a7, a8);
    return 1;
  }
  if (a2 == 65558)
  {
    int v10 = *a3;
    *(_DWORD *)(v9 + 268) = *a3;
    if (*(_DWORD *)(a1 + 12) && (*(unsigned char *)(v9 + 260) & 1) != 0 && deflateParams((z_streamp)(v9 + 128), v10, 0))
    {
      int64_t v16 = *(const char **)(v9 + 176);
      if (!v16) {
        int64_t v16 = "(null)";
      }
      TIFFErrorExtR(a1, "PixarLogVSetField", "ZLib error: %s", v11, v12, v13, v14, v15, (char)v16);
      return 0;
    }
    return 1;
  }
  __int16 v26 = *(uint64_t (**)(void))(v9 + 280);

  return v26();
}

uint64_t PixarLogGuessDataFmt(uint64_t a1)
{
  int v1 = *(unsigned __int16 *)(a1 + 46);
  int v2 = *(unsigned __int16 *)(a1 + 44);
  uint64_t result = 0xFFFFFFFFLL;
  switch(v2)
  {
    case 8:
      int v5 = v1 != 4 && v1 != 1;
      return (v5 << 31 >> 31);
    case 9:
    case 10:
    case 13:
    case 14:
    case 15:
      return result;
    case 11:
      BOOL v7 = v1 == 1 || v1 == 4;
      unsigned int v8 = 2;
      goto LABEL_24;
    case 12:
      BOOL v7 = (((_WORD)v1 - 2) & 0xFFFD) == 0;
      unsigned int v8 = 3;
      goto LABEL_24;
    case 16:
      BOOL v7 = v1 == 1 || v1 == 4;
      unsigned int v8 = 4;
LABEL_24:
      if (v7) {
        uint64_t result = v8;
      }
      else {
        uint64_t result = 0xFFFFFFFFLL;
      }
      break;
    default:
      if (v1 == 3) {
        unsigned int v6 = 5;
      }
      else {
        unsigned int v6 = -1;
      }
      if (v2 == 32) {
        uint64_t result = v6;
      }
      else {
        uint64_t result = 0xFFFFFFFFLL;
      }
      break;
  }
  return result;
}

void IIO_Reader_TIFF::createReadPlugin()
{
}

{
  operator new();
}

void sub_18877E25C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40EBDE314ALL);
  _Unwind_Resume(a1);
}

void sub_18877E300(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40EBDE314ALL);
  _Unwind_Resume(a1);
}

IIOImageRead *IIO_Reader_TIFF::createGlobalInfoData(IIO_Reader_TIFF *this, IIOImageReadSession *a2)
{
  uint64_t result = IIOImageReadSession::globalInfoForType(a2, *((_DWORD *)this + 6));
  if (result)
  {
    return (IIOImageRead *)GlobalTIFFInfo::createDataRepresentation(result);
  }
  return result;
}

void IIO_Reader_TIFF::updateGlobalInfo(IIO_Reader_TIFF *this, IIOImageReadSession *a2, unsigned __int8 *a3)
{
}

void sub_18877E3EC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1091C4016865251);
  _Unwind_Resume(a1);
}

void IIO_Reader_TIFF::deserializeGlobalInfo(IIO_Reader_TIFF *this, unsigned __int8 *a2)
{
}

void sub_18877E468(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1091C4016865251);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_TIFF::getImageCount(IIO_Reader_TIFF *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  unsigned int v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v15 = 0;
  int64_t v16 = 0;
  uint64_t v17 = 0;
  uint64_t v14 = 0;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v10, a2);
  SetupTIFFErrorHandler();
  if ((unint64_t)v11 >= 9)
  {
    char v6 = IIOScanner::getVal16((IIOScanner *)&v10) != 19789;
    GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)&v10, v6);
    int Val16 = IIOScanner::getVal16((IIOScanner *)&v10);
    if ((Val16 & 0xFFFE) == 0x2A)
    {
      if (Val16 == 43)
      {
        int v8 = IIOScanner::getVal16((IIOScanner *)&v10);
        IIOScanner::skip((uint64_t)&v10, 2);
      }
      else
      {
        int v8 = 4;
      }
      LODWORD(v12) = v8;
      operator new();
    }
  }
  if (a5) {
    *a5 = 0;
  }
  IIOScanner::~IIOScanner((IIOScanner *)&v10);
  if (v15)
  {
    int64_t v16 = v15;
    operator delete(v15);
  }
  if (v18)
  {
    uint64_t v19 = v18;
    operator delete(v18);
  }
  if (v21)
  {
    uint64_t v22 = v21;
    operator delete(v21);
  }
  return 4294967246;
}

void sub_18877EF20(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  __cxa_begin_catch(a1);
  *(void *)(v17 - 128) = *(void *)(v17 - 136);
  __cxa_end_catch();
  JUMPOUT(0x18877EEECLL);
}

void sub_18877EF94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  IIOScanner::~IIOScanner((IIOScanner *)&a33);
  __int16 v35 = *(void **)(v33 - 160);
  if (v35)
  {
    *(void *)(v33 - 152) = v35;
    operator delete(v35);
  }
  __int16 v36 = *(void **)(v33 - 136);
  if (v36)
  {
    *(void *)(v33 - 128) = v36;
    operator delete(v36);
  }
  __int16 v37 = *(void **)(v33 - 112);
  if (v37)
  {
    *(void *)(v33 - 104) = v37;
    operator delete(v37);
  }
  _Unwind_Resume(a1);
}

void IIO_Reader_TIFF::initThumbnail()
{
}

void sub_18877F098(void *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40EBDE314ALL);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x18877F084);
}

uint64_t IIO_Reader_TIFF::compareOptions(IIO_Reader_TIFF *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  memset(v19, 0, sizeof(v19));
  IIODictionary::IIODictionary((IIODictionary *)v19, a2);
  memset(v18, 0, sizeof(v18));
  IIODictionary::IIODictionary((IIODictionary *)v18, a3);
  BOOL BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v19, @"kCGImageSourceShouldAllowFloat");
  if (BoolForKey == IIODictionary::getBoolForKey((IIODictionary *)v18, @"kCGImageSourceShouldAllowFloat")
    && ((Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v19, @"kCGImageSourceSubsampleFactor"), v7 = IIODictionary::getUint32ForKey((IIODictionary *)v18, @"kCGImageSourceSubsampleFactor"), Uint32ForKey <= 1)? (v8 = 1): (v8 = Uint32ForKey), v7 <= 1 ? (int v9 = 1) : (int v9 = v7), v8 == v9&& (ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v19, @"kCGImageSourceXMPSidecar"), v11 = IIODictionary::getObjectForKey((IIODictionary *)v18, @"kCGImageSourceXMPSidecar"), (ObjectForKey != 0) == (v11 != 0))&& (!ObjectForKey || !v11 || CFEqual(ObjectForKey, v11))&& (v12 = IIOSkipMetadata((IIODictionary *)v19), ((v12 ^ 1 | IIOSkipMetadata((IIODictionary *)v18)) & 1) != 0)))
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"kCGImageSourceDecodeRequest");
    CFStringRef v14 = (const __CFString *)CFDictionaryGetValue(a3, @"kCGImageSourceDecodeRequest");
    if (Value && v14) {
      BOOL v15 = CFEqual(Value, v14);
    }
    else {
      BOOL v15 = ((unint64_t)Value | (unint64_t)v14) == 0;
    }
    uint64_t v16 = v15;
  }
  else
  {
    uint64_t v16 = 0;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v18);
  IIODictionary::~IIODictionary((IIODictionary *)v19);
  return v16;
}

void sub_18877F280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

uint64_t IIO_Reader_TIFF::hasCustomImageCountProc(IIO_Reader_TIFF *this)
{
  return 1;
}

uint64_t IIO_Reader_TIFF::hasCustomCompareOptionsProc(IIO_Reader_TIFF *this)
{
  return 1;
}

uint64_t IIO_Reader_TIFF::hasCustomThumbnailProc(IIO_Reader_TIFF *this)
{
  return 1;
}

char *std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  unsigned int v7 = result;
  uint64_t v8 = *((void *)result + 2);
  int v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *unsigned int v7 = 0;
      v7[1] = 0;
      _OWORD v7[2] = 0;
    }
    if (a4 >> 61) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<unsigned long long>::__vallocate[abi:ne180100](v7, v11);
    long long v13 = (char *)v7[1];
    int v12 = (void **)(v7 + 1);
    int v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      unsigned int v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  int v12 = (void **)(result + 8);
  CFStringRef v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    int v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    unsigned int v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *int v12 = &v9[v17];
  return result;
}

char *std::vector<unsigned long long>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    char v6 = result;
    uint64_t result = std::vector<unsigned long long>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_18877F490(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AppleJPEGWritePlugin::get_encoding_format(AppleJPEGWritePlugin *this, IIODictionary *a2)
{
  int EncodingHorizontalSubsamplingFactor = JPEGWritePlugin::getEncodingHorizontalSubsamplingFactor(this, a2);
  uint64_t result = JPEGWritePlugin::getEncodingVerticalSubsamplingFactor(this, a2);
  if (EncodingHorizontalSubsamplingFactor == 2 && result == 2) {
    return 3;
  }
  if (EncodingHorizontalSubsamplingFactor == 1 && result == 1) {
    return 0;
  }
  if ((EncodingHorizontalSubsamplingFactor != 2 || result != 1)
    && (EncodingHorizontalSubsamplingFactor != 1 || result != 2))
  {
    _cg_jpeg_mem_term("get_encoding_format", 133, "Unsupported chroma subsampling combination: H=%d,V=%d - using 4:2:0\n", EncodingHorizontalSubsamplingFactor, result);
    return 3;
  }
  return result;
}

void AppleJPEGWritePlugin::~AppleJPEGWritePlugin(AppleJPEGWritePlugin *this)
{
  JPEGWritePlugin::~JPEGWritePlugin(this);

  JUMPOUT(0x18C11C0E0);
}

__IOSurface *AppleJPEGWritePlugin::createJpegDataFromIOSurface(AppleJPEGWritePlugin *this, __IOSurface *a2, IIODictionary *a3)
{
  uint64_t v16 = 0;
  IIO_LoadCMPhotoSymbols();
  if (a2)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v13);
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    DoubleForKedouble y = 0.75;
    if (IIODictionary::containsKey(a3, @"kCGImageDestinationLossyCompressionQuality")) {
      DoubleForKedouble y = IIODictionary::getDoubleForKey(a3, @"kCGImageDestinationLossyCompressionQuality");
    }
    LumaQuantizationTableFromImageIOQualitdouble y = JPEGWritePlugin::createLumaQuantizationTableFromImageIOQuality(this, DoubleForKey, 0);
    ChromaQuantizationTableFromImageIOQualitdouble y = JPEGWritePlugin::createChromaQuantizationTableFromImageIOQuality(this, DoubleForKey, 0);
    CFArrayAppendValue(Mutable, LumaQuantizationTableFromImageIOQuality);
    CFArrayAppendValue(Mutable, ChromaQuantizationTableFromImageIOQuality);
    CFRelease(LumaQuantizationTableFromImageIOQuality);
    CFRelease(ChromaQuantizationTableFromImageIOQuality);
    IIONumber::IIONumber((IIONumber *)v12, 2);
    IIODictionary::setObjectForKey((uint64_t)&v13, (uint64_t)v12, *(const void **)gIIO_kCMPhotoCompressionOption_QualityControllerType);
    IIONumber::~IIONumber((IIONumber *)v12);
    IIODictionary::setObjectForKey((IIODictionary *)&v13, Mutable, *(const __CFString **)gIIO_kCMPhotoCompressionOption_QualityControllerParameters);
    CFRelease(Mutable);
    int v10 = gFunc_CMPhotoCompressionCreateDataContainerFromImage(v14, a2, 0, 0, 1, &v16);
    if (v10 && (gIIODebugFlags & 0x1000000000) != 0) {
      ImageIOLog("H   ERROR: Hardware encode failed: err=%d\n", v10);
    }
    a2 = v16;
    IIODictionary::~IIODictionary((IIODictionary *)&v13);
  }
  return a2;
}

void sub_18877F758(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t AppleJPEGWritePlugin::copyIOSurfaceFromPixelProvider(AppleJPEGWritePlugin *this, IIOImagePixelDataProvider *a2)
{
  uint64_t Ref = IIOImageSource::imageReadRef(a2);
  if (_ImageHasMask()) {
    goto LABEL_2;
  }
  uint64_t Property = (const void *)CGImageGetProperty();
  if (Property)
  {
    uint64_t v6 = (uint64_t)Property;
    IIOFrameBufferRetain(Property);
    return v6;
  }
  CGImageGetImageProvider();
  if (!Ref
    || (memset(&dest, 0, 24),
        IIODictionary::IIODictionary((IIODictionary *)&dest),
        IIONumber::IIONumber((IIONumber *)v9, 875704422),
        IIODictionary::setObjectForKey((uint64_t)&dest, (uint64_t)v9, @"kCGImageSurfaceFormatRequest"),
        IIONumber::~IIONumber((IIONumber *)v9),
        uint64_t v6 = CGImageProviderCopyIOSurface(),
        IIODictionary::~IIODictionary((IIODictionary *)&dest),
        !v6))
  {
LABEL_2:
    int BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(a2);
    if (BitmapInfo == 8198 || BitmapInfo == 5)
    {
      IIOImageSource::count(a2);
      IIO_Reader::testHeaderSize(a2);
      IIOImagePlus::sourceImageProvider(a2);
      IIO_CreateOutputSurfaceWithFormat();
    }
    return 0;
  }
  return v6;
}

void sub_18877F9CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t AppleJPEGWritePlugin::writeOneImage(AppleJPEGWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t AppleJPEGWritePlugin::writeOne(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  uint64_t v66 = qword_1ED4F0B60;
  long long v64 = 0u;
  long long v65 = xmmword_1ED4F0B50;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  uint64_t v57 = 0;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  *(_OWORD *)__int16 v48 = 0u;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v43 = 0u;
  int AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a2);
  SourceGeomCGColorSpaceRef ColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  CGColorSpaceModel Model = CGColorSpaceGetModel(SourceGeomColorSpace);
  __int16 __ptr = -9985;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  __int16 v41 = 0;
  if (!applejpeg_encode_create())
  {
    _cg_jpeg_mem_term("writeOne", 375, "*** ERROR: applejpeg_encode_create returned NULL\n");
LABEL_75:
    uint64_t v22 = 4294967246;
    goto LABEL_62;
  }
  applejpeg_encode_options_init();
  if (!IIODictionary::getObjectForKeyGroup(a3, @"Quantization", @"{JPEG}"))
  {
    LODWORD(v59) = 0;
    float ImageIOCompressionQuality = JPEGWritePlugin::GetImageIOCompressionQuality(a3, v9);
    LumaQuantizationTableFromImageIOQualitdouble y = JPEGWritePlugin::createLumaQuantizationTableFromImageIOQuality((JPEGWritePlugin *)this, ImageIOCompressionQuality, 0);
    BytePtr = CFDataGetBytePtr(LumaQuantizationTableFromImageIOQuality);
    *((void *)&v59 + 1) = BytePtr;
    if (Model == kCGColorSpaceModelRGB)
    {
      ChromaQuantizationTableFromImageIOQualitdouble y = JPEGWritePlugin::createChromaQuantizationTableFromImageIOQuality((JPEGWritePlugin *)this, ImageIOCompressionQuality, 0);
      BytePtr = CFDataGetBytePtr(ChromaQuantizationTableFromImageIOQuality);
LABEL_14:
      CFDataRef theData = 0;
      goto LABEL_15;
    }
LABEL_13:
    ChromaQuantizationTableFromImageIOQualitdouble y = 0;
    goto LABEL_14;
  }
  QuantizationTableFromPropertiesForComponentIndedouble x = createQuantizationTableFromPropertiesForComponentIndex(a3, 0);
  LumaQuantizationTableFromImageIOQualitdouble y = QuantizationTableFromPropertiesForComponentIndex;
  if (QuantizationTableFromPropertiesForComponentIndex)
  {
    LODWORD(v59) = 0;
    BytePtr = CFDataGetBytePtr(QuantizationTableFromPropertiesForComponentIndex);
    *((void *)&v59 + 1) = BytePtr;
    if (Model == kCGColorSpaceModelRGB)
    {
      ChromaQuantizationTableFromImageIOQualitdouble y = createQuantizationTableFromPropertiesForComponentIndex(a3, 1u);
      CFDataRef theData = createQuantizationTableFromPropertiesForComponentIndex(a3, 2u);
      if (ChromaQuantizationTableFromImageIOQuality && !theData) {
        CFDataRef theData = (const __CFData *)CFRetain(ChromaQuantizationTableFromImageIOQuality);
      }
      if (ChromaQuantizationTableFromImageIOQuality && theData)
      {
        *(void *)&long long v60 = CFDataGetBytePtr(ChromaQuantizationTableFromImageIOQuality);
        BytePtr = CFDataGetBytePtr(theData);
LABEL_16:
        *((void *)&v60 + 1) = BytePtr;
        goto LABEL_18;
      }
      BytePtr = (const UInt8 *)*((void *)&v59 + 1);
LABEL_15:
      *(void *)&long long v60 = BytePtr;
      goto LABEL_16;
    }
    goto LABEL_13;
  }
  ChromaQuantizationTableFromImageIOQualitdouble y = 0;
  CFDataRef theData = 0;
LABEL_18:
  if (IIODictionary::getBoolForKeyGroup(a3, @"IsProgressive", @"{JFIF}")) {
    HIDWORD(v61) = 1;
  }
  LODWORD(v58) = 1;
  DWORD2(v61) = AppleJPEGWritePlugin::get_encoding_format((AppleJPEGWritePlugin *)this, a3);
  LODWORD(v63) = 1;
  uint64_t v15 = IIO_Reader::testHeaderSize(a2);
  DWORD2(v50) = IIOImageSource::count(a2);
  HIDWORD(v50) = v15;
  switch(Model)
  {
    case kCGColorSpaceModelCMYK:
      if (!AlphaInfo) {
        LODWORD(v51) = 15;
      }
      float v17 = JPEGWritePlugin::GetImageIOCompressionQuality(a3, v16);
      LODWORD(v59) = JPEGWritePlugin::JPEGQualityFromLossyCompressionQuality(v18, v17);
      break;
    case kCGColorSpaceModelRGB:
      if (AlphaInfo) {
        LODWORD(v51) = 3;
      }
      else {
        LODWORD(v51) = 0;
      }
      break;
    case kCGColorSpaceModelMonochrome:
      if (!AlphaInfo) {
        LODWORD(v51) = 5;
      }
      DWORD2(v61) = 4;
      break;
  }
  size_t v19 = IIOImagePlus::sourceImageProvider(a2);
  size_t v20 = v19;
  if (!v19)
  {
    _cg_jpeg_mem_term("writeOne", 460, "*** ERROR: iPixelDataProvider size_t bytesPerRow = %d\n", 0);
LABEL_69:
    if (LumaQuantizationTableFromImageIOQuality) {
      CFRelease(LumaQuantizationTableFromImageIOQuality);
    }
    if (ChromaQuantizationTableFromImageIOQuality) {
      CFRelease(ChromaQuantizationTableFromImageIOQuality);
    }
    if (theData) {
      CFRelease(theData);
    }
    goto LABEL_75;
  }
  LODWORD(v50) = 1;
  v48[0] = malloc_type_malloc(v19, 0xADDB4441uLL);
  if (!v48[0])
  {
    _cg_jpeg_mem_term("writeOne", 465, "*** ERROR: malloc(%d) failed\n", v20);
    goto LABEL_69;
  }
  uint64_t v21 = this[2];
  *((void *)&v43 + 1) = iioWriteCallback;
  *(void *)&long long v45 = v21;
  uint64_t v22 = applejpeg_encode_set_options_file();
  if (LumaQuantizationTableFromImageIOQuality) {
    CFRelease(LumaQuantizationTableFromImageIOQuality);
  }
  if (ChromaQuantizationTableFromImageIOQuality) {
    CFRelease(ChromaQuantizationTableFromImageIOQuality);
  }
  if (theData) {
    CFRelease(theData);
  }
  if (v22)
  {
    _cg_jpeg_mem_term("writeOne", 486, "*** ERROR applejpeg_encode_set_options_file returned: %d\n", v22);
  }
  else
  {
    iioWriteCallback(&__ptr, 2, this[2]);
    uint64_t v39 = 0x4649464A1000E0FFLL;
    *(_WORD *)((char *)&v40 + 1) = 257;
    if (a3
      && IIODictionary::containsKey(a3, @"DPIHeight")
      && IIODictionary::containsKey(a3, @"DPIWidth"))
    {
      double FloatForKey = IIODictionary::getFloatForKey(a3, @"DPIWidth");
      float v24 = *(float *)&FloatForKey;
      double v25 = IIODictionary::getFloatForKey(a3, @"DPIHeight");
      unsigned int v26 = vcvtmd_s64_f64(v24 + 0.5);
      unsigned int v27 = vcvtmd_s64_f64(*(float *)&v25 + 0.5);
    }
    else
    {
      unsigned int v26 = 72;
      unsigned int v27 = 72;
    }
    WORD2(v40) = __rev16(v26);
    HIWORD(v40) = __rev16(v27);
    __int16 v41 = 0;
    iioWriteCallback(&v39, 18, this[2]);
    AppleJPEGWritePlugin::WriteExifData(this[2], a2, a3, v28);
    if (!IIODictionary::getBoolForKey(a3, @"kCGImageMetadataShouldExcludeXMP"))
    {
      IIODictionary::removeObjectForKeyGroup(a3, @"Software", @"{TIFF}");
      JPEGWritePlugin::WriteExtendedXMPData(this[2], a3, v30);
    }
    JPEGWritePlugin::WriteIPTCData(this[2], a2, a3, v29);
    JPEGWritePlugin::WriteICCData(this[2], a2, 0, v31);
    HIDWORD(v50) = 1;
    if (Model == kCGColorSpaceModelCMYK)
    {
      long long v67 = xmmword_1889AA930;
      iioWriteCallback(&v67, 16, this[2]);
    }
    if (v15)
    {
      uint64_t v32 = 0;
      while (1)
      {
        uint64_t Bytes = IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v48[0]);
        if (Bytes != v20)
        {
          _cg_jpeg_mem_term("writeOne", 550, "*** ERROR: CGImagePixelDataProviderGetBytes failed (%d/%d) - expected: %ld  got: %ld\n", v32, v15, v20, Bytes);
          goto LABEL_61;
        }
        if (Model == kCGColorSpaceModelCMYK)
        {
          __int16 v34 = v48[0];
          size_t v35 = v20;
          do
          {
            *__int16 v34 = ~*v34;
            ++v34;
            --v35;
          }
          while (v35);
        }
        uint64_t v22 = applejpeg_encode_image_row();
        if (v22) {
          break;
        }
        if (++v32 == v15) {
          goto LABEL_61;
        }
      }
      _cg_jpeg_mem_term("writeOne", 561, "*** ERROR: applejpeg_encode_image_row  err = %d\n", v22);
    }
    else
    {
LABEL_61:
      uint64_t v22 = 0;
    }
  }
LABEL_62:
  applejpeg_encode_destroy();
  if (v48[0]) {
    free(v48[0]);
  }
  return v22;
}

void sub_18878006C(_Unwind_Exception *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    __cxa_end_catch();
    JUMPOUT(0x18877FF48);
  }
  _Unwind_Resume(a1);
}

__n128 AppleJPEGWritePlugin::WriteExifData(AppleJPEGWritePlugin *this, IIOImageWriteSession *SourceGeomColorSpace, IIOImagePixelDataProvider *a3, IIODictionary *a4)
{
  unint64_t v17 = 0;
  int __ptr = 57855;
  if (this && a3)
  {
    if (IIODictionary::getBoolForKey(a3, @"kCGImageDestinationEmbedThumbnail"))
    {
      uint64_t Ref = (CGImage *)IIOImageSource::imageReadRef(SourceGeomColorSpace);
      Thumb = CGImageCreateThumb(Ref, 0xA0uLL);
      CFDataRef JPEGDataFromImage = AppleJPEGReadPlugin::CreateJPEGDataFromImage(SourceGeomColorSpace, a3, Thumb, v9);
      if (SourceGeomColorSpace)
      {
LABEL_5:
        uint64_t v11 = IIOImageSource::count(SourceGeomColorSpace);
        unsigned int v12 = IIO_Reader::testHeaderSize(SourceGeomColorSpace);
        SourceGeomCGColorSpaceRef ColorSpace = (IIOImageWriteSession *)IIOImagePlus::getSourceGeomColorSpace(SourceGeomColorSpace);
LABEL_8:
        if ((gIIODebugFlags & 0x2000000000000) != 0)
        {
          ImageIOLog("%s WriteExifData: writing Exif data\n", "-o- ");
          if ((gIIODebugFlags & 0x2000000000000) != 0) {
            IIODebugOrientation("WriteExifData", 854, a3);
          }
        }
        uint64_t v13 = (void *)CreateExifBufferFromPropertiesJPEG(a3, v11, v12, SourceGeomColorSpace, JPEGDataFromImage, @"public.jpeg", &v17);
        if (v13) {
          BOOL v14 = v17 == 0;
        }
        else {
          BOOL v14 = 1;
        }
        if (v14)
        {
          __n128 result = _cg_jpeg_mem_term("WriteExifData", 858, "*** WARNING: CreateExifBufferFromPropertiesJPEG returned NULL\n");
          if (!JPEGDataFromImage) {
            goto LABEL_17;
          }
        }
        else
        {
          HIWORD(__ptr) = bswap32(v17 + 2) >> 16;
          iioWriteCallback(&__ptr, 4, this);
          iioWriteCallback(v13, v17, this);
          if (!JPEGDataFromImage)
          {
LABEL_17:
            if (Thumb) {
              CGImageRelease(Thumb);
            }
            if (v13) {
              free(v13);
            }
            return result;
          }
        }
        CFRelease(JPEGDataFromImage);
        goto LABEL_17;
      }
    }
    else
    {
      Thumb = 0;
      CFDataRef JPEGDataFromImage = 0;
      if (SourceGeomColorSpace) {
        goto LABEL_5;
      }
    }
    uint64_t v11 = 0;
    unsigned int v12 = 0;
    goto LABEL_8;
  }

  return _cg_jpeg_mem_term("WriteExifData", 830, "*** WARNING: cannot write Exif data\n", a4);
}

uint64_t AppleJPEGWritePlugin::writeAll(IIOImageDestination **this)
{
  if (!IIOWritePlugin::getImageCount(this)) {
    return 4294967246;
  }
  PixelDataProviderAtIndedouble x = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, 0);
  PropertiesAtIndedouble x = (const __CFDictionary **)IIOWritePlugin::getPropertiesAtIndex(this, 0);
  uint64_t ContainerProperties = IIOWritePlugin::getContainerProperties(this);
  if (!PixelDataProviderAtIndex)
  {
    _cg_jpeg_mem_term("writeAll", 604, "*** iPixelDataProvider is nil");
    return 4294967246;
  }
  uint64_t v5 = ContainerProperties;
  int v6 = IIO_HardwareEncoderDefaultValue();
  unsigned int BoolForKey = IIODictionary::containsKey((IIODictionary *)PropertiesAtIndex, @"kCGImageDestinationUseHardwareAcceleration");
  if (BoolForKey) {
    unsigned int BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)PropertiesAtIndex, @"kCGImageDestinationUseHardwareAcceleration");
  }
  if (!v6 || v6 != 1 && !BoolForKey) {
    return (*((uint64_t (**)(IIOImageDestination **, IIOImageSource *, const __CFDictionary **, uint64_t, void))*this
  }
            + 3))(this, PixelDataProviderAtIndex, PropertiesAtIndex, v5, 0);
  if (IIODictionary::getBoolForKey((IIODictionary *)PropertiesAtIndex, @"kCGImageDestinationEmbedThumbnail"))
  {
    uint64_t Ref = (CGImage *)IIOImageSource::imageReadRef(PixelDataProviderAtIndex);
    Thumb = CGImageCreateThumb(Ref, 0xA0uLL);
    CFDataRef JPEGDataFromImage = AppleJPEGReadPlugin::CreateJPEGDataFromImage(PixelDataProviderAtIndex, (IIOImagePixelDataProvider *)PropertiesAtIndex, Thumb, v10);
  }
  else
  {
    Thumb = 0;
    CFDataRef JPEGDataFromImage = 0;
  }
  if ((gIIODebugFlags & 0x1000000000) != 0) {
    ImageIOLog("H   writeJpegWithHardwareEncoding\n");
  }
  int v12 = AppleJPEGWritePlugin::writeJpegWithHardwareEncoding((AppleJPEGWritePlugin *)this, this[2], PixelDataProviderAtIndex, JPEGDataFromImage, PropertiesAtIndex[1]);
  if (v12 && (gIIODebugFlags & 0x1000000000) != 0) {
    ImageIOLog("H   writeJpegWithHardwareEncoding failed. Trying SW encode...\n");
  }
  if (JPEGDataFromImage) {
    CFRelease(JPEGDataFromImage);
  }
  if (Thumb) {
    CFRelease(Thumb);
  }
  if (!v12) {
    return 0;
  }
  else {
    return (*((uint64_t (**)(IIOImageDestination **, IIOImageSource *, const __CFDictionary **, uint64_t, void))*this
  }
            + 3))(this, PixelDataProviderAtIndex, PropertiesAtIndex, v5, 0);
}

void sub_18878045C(void *a1)
{
}

uint64_t AppleJPEGWritePlugin::writeJpegWithHardwareEncoding(AppleJPEGWritePlugin *this, IIOImageWriteSession *a2, IIOImagePixelDataProvider *a3, const __CFData *a4, const __CFDictionary *a5)
{
  int v10 = (__IOSurface *)AppleJPEGWritePlugin::copyIOSurfaceFromPixelProvider(this, a3);
  if (v10)
  {
    uint64_t v11 = v10;
    signed int PixelFormat = IOSurfaceGetPixelFormat(v10);
    if ((gIIODebugFlags & 0x1000000000) != 0)
    {
      signed int v13 = PixelFormat;
      unsigned int v14 = PixelFormat >> 24;
      uint64_t v15 = MEMORY[0x1E4F14390];
      if (PixelFormat < 0)
      {
        uint64_t v18 = MEMORY[0x1E4F14390];
        int v16 = __maskrune(PixelFormat >> 24, 0x40000uLL);
        uint64_t v15 = v18;
      }
      else
      {
        int v16 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v14 + 60) & 0x40000;
      }
      if (v16) {
        uint64_t v19 = v14;
      }
      else {
        uint64_t v19 = 46;
      }
      unsigned int v20 = v13 << 8 >> 24;
      long long v45 = a2;
      if (v13 << 8 < 0)
      {
        uint64_t v22 = v15;
        int v21 = __maskrune(v13 << 8 >> 24, 0x40000uLL);
        uint64_t v15 = v22;
      }
      else
      {
        int v21 = *(_DWORD *)(v15 + 4 * v20 + 60) & 0x40000;
      }
      if (v21) {
        uint64_t v23 = v20;
      }
      else {
        uint64_t v23 = 46;
      }
      unsigned int v24 = (__int16)v13 >> 8;
      CFDataRef v25 = a4;
      if (v13 << 16 < 0)
      {
        uint64_t v27 = v15;
        int v26 = __maskrune((__int16)v13 >> 8, 0x40000uLL);
        uint64_t v15 = v27;
      }
      else
      {
        int v26 = *(_DWORD *)(v15 + 4 * v24 + 60) & 0x40000;
      }
      if (v26) {
        uint64_t v28 = v24;
      }
      else {
        uint64_t v28 = 46;
      }
      if ((v13 << 24) <= 0x7F000000) {
        int v29 = *(_DWORD *)(v15 + 4 * (char)v13 + 60) & 0x40000;
      }
      else {
        int v29 = __maskrune((char)v13, 0x40000uLL);
      }
      if (v29) {
        uint64_t v30 = (char)v13;
      }
      else {
        uint64_t v30 = 46;
      }
      ImageIOLog("H   copyIOSurfaceFromPixelProvider - <IOSurface:%p> '%c%c%c%c'\n", v11, v19, v23, v28, v30);
      a2 = v45;
      a4 = v25;
    }
    memset(v47, 0, sizeof(v47));
    IIODictionary::IIODictionary((IIODictionary *)v47, a5);
    JpegDataFromIOSurface = AppleJPEGWritePlugin::createJpegDataFromIOSurface(this, v11, (IIODictionary *)v47);
    if (!JpegDataFromIOSurface)
    {
      uint64_t v17 = 0;
LABEL_67:
      IIO_IOSurfaceRelease(v11);
      IIODictionary::~IIODictionary((IIODictionary *)v47);
      return v17;
    }
    CFAllocatorRef v32 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v33 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
    __int16 v34 = v33;
    if (!v33)
    {
      uint64_t v17 = 0;
LABEL_66:
      CFRelease(JpegDataFromIOSurface);
      goto LABEL_67;
    }
    if (!CFWriteStreamOpen(v33))
    {
      uint64_t v17 = 0;
LABEL_65:
      CFRelease(v34);
      goto LABEL_66;
    }
    CFTypeRef value = 0;
    if (a5)
    {
      if (CFDictionaryGetValueIfPresent(a5, @"{MetaData}", (const void **)&value)
        && (MutableCopdouble y = CFDictionaryCreateMutableCopy(v32, 0, a5)) != 0)
      {
        CFRetain(value);
        CFDictionaryRemoveValue(MutableCopy, @"{MetaData}");
        CFMutableDictionaryRef v36 = MutableCopy;
      }
      else
      {
        CFMutableDictionaryRef v36 = 0;
        MutableCopdouble y = a5;
      }
    }
    else
    {
      MutableCopdouble y = 0;
      CFMutableDictionaryRef v36 = 0;
    }
    SourceGeomCGColorSpaceRef ColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a3);
    if (CGColorSpaceGetType() != 6 && CGColorSpaceGetType() != 10
      || IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E4F1DC98])
      || (CFDataRef v38 = CGColorSpaceCopyICCData(SourceGeomColorSpace)) == 0)
    {
LABEL_54:
      if (CGImageWriteEXIFJPEGWithMetadata(v34, JpegDataFromIOSurface, a4, MutableCopy, (const CGImageMetadata *)value, 0)&& (CFDataRef v40 = (const __CFData *)CFWriteStreamCopyProperty(v34, (CFStreamPropertyKey)*MEMORY[0x1E4F1D440]), (v41 = v40) != 0))
      {
        BytePtr = CFDataGetBytePtr(v40);
        size_t Length = CFDataGetLength(v41);
        if (IIOImageWriteSession::putBytes(a2, BytePtr, Length) == Length)
        {
          uint64_t v17 = 0;
        }
        else
        {
          _cg_jpeg_mem_term("writeJpegWithHardwareEncoding", 783, "*** ERROR: failed to write %ld bytes\n", Length);
          uint64_t v17 = 4294967246;
        }
        CFRelease(v41);
      }
      else
      {
        uint64_t v17 = 0;
      }
      if (v36) {
        CFRelease(v36);
      }
      if (value) {
        CFRelease(value);
      }
      goto LABEL_65;
    }
    if (!MutableCopy || v36)
    {
      if ((unint64_t)MutableCopy | (unint64_t)v36)
      {
LABEL_51:
        if (v36) {
          CFDictionarySetValue(v36, @"kCGImageDestinationICCProfile", v38);
        }
        CFRelease(v38);
        goto LABEL_54;
      }
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(v32, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    }
    else
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutableCopy(v32, 0, MutableCopy);
    }
    MutableCopdouble y = Mutable;
    CFMutableDictionaryRef v36 = Mutable;
    goto LABEL_51;
  }
  return 0;
}

void sub_188780884(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CFDictionaryRef createQuantizationTableFromPropertiesForComponentIndex(IIODictionary *a1, unsigned int a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  CFDictionaryRef result = IIODictionary::getObjectForKeyGroup(a1, @"Quantization", @"{JPEG}");
  if (result)
  {
    CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(result, a2);
    if (ValueAtIndex) {
      BOOL v5 = ValueAtIndex == (const __CFData *)*MEMORY[0x1E4F1D260];
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5
      && (CFDataRef v6 = ValueAtIndex, v7 = CFGetTypeID(ValueAtIndex), v7 == CFDataGetTypeID())
      && CFDataGetLength(v6) == 128)
    {
      long long v20 = 0u;
      long long v21 = 0u;
      *(_OWORD *)UInt8 bytes = 0u;
      long long v19 = 0u;
      BytePtr = CFDataGetBytePtr(v6);
      uint64_t v9 = 0;
      long long v10 = *((_OWORD *)BytePtr + 5);
      v17[4] = *((_OWORD *)BytePtr + 4);
      v17[5] = v10;
      long long v11 = *((_OWORD *)BytePtr + 7);
      v17[6] = *((_OWORD *)BytePtr + 6);
      v17[7] = v11;
      long long v12 = *((_OWORD *)BytePtr + 1);
      v17[0] = *(_OWORD *)BytePtr;
      v17[1] = v12;
      long long v13 = *((_OWORD *)BytePtr + 3);
      unsigned int v14 = (int8x16_t *)v17;
      void v17[2] = *((_OWORD *)BytePtr + 2);
      void v17[3] = v13;
      do
      {
        int8x16_t v16 = *v14;
        int8x16_t v15 = v14[1];
        v14 += 2;
        *(int8x16_t *)&bytes[v9] = vuzp1q_s8(v16, v15);
        v9 += 16;
      }
      while (v9 != 64);
      return CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 64);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void IIO_Writer_AppleJPEG::~IIO_Writer_AppleJPEG(IIO_Writer_AppleJPEG *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIO_Writer_AppleJPEG::write(IIO_Writer_AppleJPEG *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  JPEGWritePlugin::JPEGWritePlugin((JPEGWritePlugin *)v5, a2, a3, 71);
  *(void *)&v5[0] = &unk_1ED4E4E28;
  uint64_t v3 = AppleJPEGWritePlugin::writeAll((IIOImageDestination **)v5);
  JPEGWritePlugin::~JPEGWritePlugin((JPEGWritePlugin *)v5);
  return v3;
}

void sub_188780A9C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t IIO_Writer_AppleJPEG::canWriteDepth(IIO_Writer_AppleJPEG *this)
{
  return 1;
}

void *pvrtcCompress(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned int a4, uint64_t a5, _DWORD *a6)
{
  int v6 = *(unsigned char *)(a1 + 8) & 7;
  if (v6 == 4 || v6 == 2)
  {
    __int16 v83 = 0;
    int v84 = 0;
    __int16 v81 = 0;
    __int16 v82 = 0;
    int v67 = v6;
    unsigned int v61 = a3 >> 2;
    unsigned int v62 = a3 >> 3;
    if (v6 == 2) {
      uint64_t v12 = a3 >> 3;
    }
    else {
      uint64_t v12 = a3 >> 2;
    }
    unsigned int v13 = a4 >> 2;
    uint64_t v73 = v12;
    size_t v14 = 8 * (a4 >> 2) * v12;
    *a6 = v14;
    unsigned int v70 = malloc_type_malloc(v14, 0x2AF610E3uLL);
    pvrtcCompressUnpacked(a1, a2, a3, a4, v15, &v84, &v83, (uint64_t *)&v82, (uint64_t *)&v81);
    int8x16_t v16 = v82;
    uint64_t v68 = v84;
    unsigned int v69 = v83;
    uint64_t v75 = v81;
    if (a4 < 4)
    {
LABEL_82:
      free(v68);
      free(v69);
      free(v16);
      free(v75);
      return v70;
    }
    int v74 = 0;
    int v72 = v73 - 1;
    unsigned int v66 = 31 - __clz(v73);
    if (v13 <= 1) {
      int v17 = 1;
    }
    else {
      int v17 = v13;
    }
    int v63 = v17;
    int v64 = 0;
LABEL_14:
    if (!v73) {
      goto LABEL_81;
    }
    uint64_t v18 = 0;
    int v79 = 0;
    int v19 = (v74 & v72 | ((v74 & v72) << 8)) & 0xFF00FF;
    int v20 = (v19 | (16 * v19)) & 0x3030303 | (4 * ((v19 | (16 * v19)) & 0xF0F0F0F)) & 0x33333333;
    int v71 = (v20 | (2 * v20)) & 0x55555555;
    int v21 = 4 * v74;
    int v65 = v74 * v62;
    int v78 = v64;
LABEL_16:
    uint64_t v77 = v18;
    if (v67 == 2)
    {
      char v22 = *((unsigned char *)v75 + (v65 + v18));
      if (!v22)
      {
        uint64_t v32 = 0;
        uint64_t v31 = 0;
        unsigned int v33 = 8 * v18;
        do
        {
          if (v16[4 * (v32 & 7 | v33) + 4 * (v21 + (v32 >> 3)) * a3] != 255)
          {
            if (v16[4 * (v32 & 7 | v33) + 4 * (v21 + (v32 >> 3)) * a3]) {
              printf("Bad threshold mod value %d (this isn't supposed to happen!)\n", v16[4 * (v32 & 7 | v33) + 4 * (v21 + (v32 >> 3)) * a3]);
            }
            else {
              v31 |= 1 << v32;
            }
          }
          ++v32;
        }
        while (v32 != 32);
        goto LABEL_74;
      }
      if (v21 == 2147483644)
      {
        uint64_t v23 = 0;
        if ((*((unsigned char *)v75 + (v65 + v18)) & 2) == 0) {
          goto LABEL_72;
        }
LABEL_20:
        unint64_t v24 = v23 & 0xFFFFFFFFFFEFFFFFLL | ((v22 & 1) << 20) | 1;
        goto LABEL_73;
      }
      uint64_t v76 = (v65 + v18);
      int v37 = 0;
      uint64_t v23 = 0;
      int v80 = 8 * v18;
      int v38 = 8 * v18 + 8;
      int v39 = v78;
      int v40 = 4 * v74;
      while (1)
      {
        int v41 = v40 & 1;
        if ((v41 | v80) < v38) {
          break;
        }
LABEL_70:
        ++v40;
        v39 += a3;
        if (v40 >= v21 + 4)
        {
          char v22 = *((unsigned char *)v75 + v76);
          LODWORD(v18) = v77;
          if ((v22 & 2) != 0) {
            goto LABEL_20;
          }
LABEL_72:
          unint64_t v24 = v23 & 0xFFFFFFFFFFFFFFFELL;
LABEL_73:
          uint64_t v31 = v24 | 0x100000000;
LABEL_74:
          uint64_t v47 = (4 * (v74 * v73 + v18));
          uint64_t v48 = v69[v47];
          uint64_t v49 = v69[v47 | 1];
          uint64_t v50 = v69[v47 | 2];
          int v51 = v69[v47 | 3];
          if (v51 == 255)
          {
            checkBitReplication(v48, 5, 0);
            checkBitReplication(v49, 5, 0);
            checkBitReplication(v50, 4, 1);
            unint64_t v52 = (v49 << 34) & 0x3E000000000 | ((unint64_t)(v48 >> 3) << 42) | ((unint64_t)(v50 >> 4) << 33) | v31 | 0x800000000000;
          }
          else
          {
            checkBitReplication(v48, 4, 1);
            checkBitReplication(v49, 4, 1);
            checkBitReplication(v50, 3, 2);
            unint64_t v52 = (v48 << 36) & 0xF0000000000 | ((unint64_t)(v49 >> 4) << 36) & 0xFFFF8FFFFFFFFFFFLL | ((unint64_t)(v50 >> 5) << 33) & 0xFFFF8FFFFFFFFFFFLL | ((unint64_t)(v51 >> 5) << 44) | v31;
          }
          uint64_t v53 = v68[v47];
          uint64_t v54 = v68[v47 | 1];
          uint64_t v55 = v68[v47 | 2];
          int v56 = v68[v47 | 3];
          if (v56 == 255)
          {
            checkBitReplication(v53, 5, 0);
            checkBitReplication(v54, 5, 0);
            checkBitReplication(v55, 5, 0);
            unint64_t v57 = (v54 << 50) & 0x3E0000000000000 | ((unint64_t)(v53 >> 3) << 58) | ((unint64_t)(v55 >> 3) << 48) | v52 | 0x8000000000000000;
          }
          else
          {
            checkBitReplication(v53, 4, 1);
            checkBitReplication(v54, 4, 1);
            checkBitReplication(v55, 4, 1);
            unint64_t v57 = (v53 << 52) & 0xF00000000000000 | ((unint64_t)(v54 >> 4) << 52) & 0x8FFFFFFFFFFFFFFFLL | ((unint64_t)(v55 >> 4) << 48) & 0x8FFFFFFFFFFFFFFFLL | ((unint64_t)(v56 >> 5) << 60) | v52;
          }
          int v58 = (v72 & v77 | ((v72 & v77) << 8)) & 0xFF00FF;
          int v59 = (v58 | (16 * v58)) & 0x3030303 | (4 * ((v58 | (16 * v58)) & 0xF0F0F0F)) & 0x33333333;
          v70[(((v74 | v77) & -(int)v73) << v66) | v71 | ((4 * v59) | (2 * v59)) & 0xAAAAAAAA] = v57;
          uint64_t v18 = v77 + 1;
          v78 += 8;
          v79 += 8;
          if (v77 + 1 == v73)
          {
LABEL_81:
            v64 += 4 * a3;
            if (++v74 == v63) {
              goto LABEL_82;
            }
            goto LABEL_14;
          }
          goto LABEL_16;
        }
      }
      unsigned int v42 = 4 * (v39 + v41);
      int v43 = v79 + v41;
      while (1)
      {
        unsigned int v44 = v16[v42];
        if (v44 <= 0x9E) {
          break;
        }
        if (v44 == 159)
        {
          char v45 = 2 * v37++;
          uint64_t v46 = 1;
LABEL_67:
          v23 |= v46 << v45;
          goto LABEL_69;
        }
        if (v44 != 255)
        {
LABEL_68:
          printf("Bad checkerboard mod value %d (this isn't supposed to happen!)\n", v16[v42]);
          goto LABEL_69;
        }
        ++v37;
LABEL_69:
        v42 += 8;
        v43 += 2;
        if (v38 <= v43) {
          goto LABEL_70;
        }
      }
      if (v16[v42])
      {
        if (v44 != 95) {
          goto LABEL_68;
        }
        char v45 = 2 * v37++;
        uint64_t v46 = 2;
      }
      else
      {
        char v45 = 2 * v37++;
        uint64_t v46 = 3;
      }
      goto LABEL_67;
    }
    unsigned int v25 = 4 * v18;
    char v26 = 0;
    if (*((unsigned char *)v75 + v74 * v61 + v18))
    {
      uint64_t v27 = 0;
      uint64_t v28 = 0;
      while (1)
      {
        unsigned int v29 = v16[4 * (v27 & 3 | v25) + 4 * (v21 + (v27 >> 2)) * a3];
        if (v29 <= 0x7F) {
          break;
        }
        if (v29 == 128)
        {
          uint64_t v30 = 2;
          goto LABEL_32;
        }
        if (v29 != 255) {
          goto LABEL_29;
        }
LABEL_33:
        ++v27;
        v26 += 2;
        if (v27 == 16)
        {
          uint64_t v31 = v28 | 0x100000000;
          goto LABEL_74;
        }
      }
      if (!v16[4 * (v27 & 3 | v25) + 4 * (v21 + (v27 >> 2)) * a3])
      {
        uint64_t v30 = 3;
        goto LABEL_32;
      }
      if (v29 == 127)
      {
        uint64_t v30 = 1;
LABEL_32:
        v28 |= v30 << v26;
        goto LABEL_33;
      }
LABEL_29:
      printf("Bad mod value %d (this isn't supposed to happen!)\n", v16[4 * (v27 & 3 | v25) + 4 * (v21 + (v27 >> 2)) * a3]);
      goto LABEL_33;
    }
    uint64_t v34 = 0;
    uint64_t v31 = 0;
    while (1)
    {
      unsigned int v35 = v16[4 * (v34 & 3 | v25) + 4 * (v21 + (v34 >> 2)) * a3];
      if (v35 <= 0x9E) {
        break;
      }
      if (v35 == 159)
      {
        uint64_t v36 = 1;
        goto LABEL_52;
      }
      if (v35 != 255) {
        goto LABEL_49;
      }
LABEL_53:
      ++v34;
      v26 += 2;
      if (v34 == 16) {
        goto LABEL_74;
      }
    }
    if (!v16[4 * (v34 & 3 | v25) + 4 * (v21 + (v34 >> 2)) * a3])
    {
      uint64_t v36 = 3;
      goto LABEL_52;
    }
    if (v35 == 95)
    {
      uint64_t v36 = 2;
LABEL_52:
      v31 |= v36 << v26;
      goto LABEL_53;
    }
LABEL_49:
    printf("Bad mod value %d (this isn't supposed to happen!)\n", v16[4 * (v34 & 3 | v25) + 4 * (v21 + (v34 >> 2)) * a3]);
    goto LABEL_53;
  }
  return 0;
}

void pvrtcCompressUnpacked(uint64_t a1, unsigned __int8 *a2, uint64_t a3, unsigned int a4, uint64_t a5, void *a6, void *a7, uint64_t *a8, uint64_t *a9)
{
  uint64_t v245 = *MEMORY[0x1E4F143B8];
  int v9 = *(unsigned char *)(a1 + 8) & 7;
  if (v9 != 4 && v9 != 2) {
    return;
  }
  if (v9 == 2) {
    char v11 = 3;
  }
  else {
    char v11 = 2;
  }
  char v211 = v11;
  if ((a3 & (a3 - 1)) != 0 || (a4 & (a4 - 1)) != 0)
  {
    *a6 = 0;
    *a7 = 0;
    *a8 = 0;
    *a9 = 0;
    return;
  }
  uint64_t v207 = *(float **)a1;
  uint64_t v14 = a3 >> v11;
  unsigned int v15 = a4 >> 2;
  int v191 = *(unsigned char *)(a1 + 8) & 7;
  if (v9 == 2) {
    int8x16_t v16 = lanczosDownsample84;
  }
  else {
    int8x16_t v16 = lanczosDownsample4;
  }
  int v17 = bilinearUpsample4f;
  if (v9 == 2) {
    int v17 = bilinearUpsample84f;
  }
  uint64_t v216 = (void (*)(float32x4_t *, uint64_t, uint64_t, uint64_t))v17;
  if (v9 == 2) {
    uint64_t v18 = bilinearUpsample84fq;
  }
  else {
    uint64_t v18 = bilinearUpsample4fq;
  }
  if (v9 == 2) {
    int v19 = errorAccumulateBilinear84;
  }
  else {
    int v19 = errorAccumulateBilinear4;
  }
  unsigned int v226 = a3;
  int v20 = (unsigned __int8 *)((uint64_t (*)(unsigned __int8 *, uint64_t))v16)(a2, a3);
  uint64_t v215 = v14;
  unsigned int __K = v15;
  size_t size = v14 * v15;
  int v21 = (float *)malloc_type_calloc((4 * size), 4uLL, 0x100004052888210uLL);
  size_t v192 = (4 * size);
  if (v192)
  {
    char v22 = v20;
    uint64_t v23 = v21;
    uint64_t v24 = (4 * size);
    do
    {
      unsigned int v25 = *v22++;
      *v23++ = (float)v25;
      --v24;
    }
    while (v24);
  }
  uint64_t v224 = v21;
  free(v20);
  uint64_t v26 = a4 * v226;
  size_t v27 = (4 * v26);
  uint64_t v28 = (float *)malloc_type_calloc(v27, 4uLL, 0x100004052888210uLL);
  unsigned int v29 = v28;
  if (v27)
  {
    uint64_t v30 = a2;
    uint64_t v31 = v28;
    uint64_t v32 = (4 * v26);
    do
    {
      unsigned int v33 = *v30++;
      *v31++ = (float)v33;
      --v32;
    }
    while (v32);
  }
  if (v26)
  {
    for (uint64_t i = 0; i != v26; ++i)
    {
      for (uint64_t j = 0; j != 4; ++j)
        v28[4 * (i & 0x3FFFFFFF) + j] = v207[j] * v28[4 * (i & 0x3FFFFFFF) + j];
    }
  }
  char v193 = (void (*)(void *, float32x4_t *, uint64_t, uint64_t, uint64_t, uint64_t))v19;
  if (size)
  {
    for (uint64_t k = 0; k != size; ++k)
    {
      for (uint64_t m = 0; m != 4; ++m)
        v224[4 * (k & 0x3FFFFFFF) + m] = v207[m] * v224[4 * (k & 0x3FFFFFFF) + m];
    }
  }
  size_t count = (4 * v26);
  unsigned int v194 = (void (*)(float32x4_t *, uint64_t, uint64_t, uint64_t))v18;
  uint64_t v195 = a1;
  int v38 = (float32x4_t *)malloc_type_malloc(4 * v27, 0x100004052888210uLL);
  unsigned int v39 = v226;
  if (a4)
  {
    unsigned int v40 = 0;
    int v41 = 0;
    do
    {
      if (v39)
      {
        uint64_t v42 = 0;
        unsigned int v43 = v40;
        do
        {
          *(_OWORD *)__A = 0uLL;
          ((void (*)(float *, float *))v216)(__A, v224);
          for (uint64_t n = 0; n != 4; ++n)
            v38->f32[v43 + n] = v29[v43 + n] - __A[n];
          ++v42;
          v43 += 4;
          unsigned int v39 = v226;
        }
        while (v42 != v226);
      }
      ++v41;
      v40 += 4 * v226;
    }
    while (v41 != a4);
  }
  free(v29);
  uint64_t v209 = (float *)malloc_type_malloc(4 * v192, 0x100004052888210uLL);
  char v45 = (float *)malloc_type_malloc(4 * v192, 0x100004052888210uLL);
  uint64_t v46 = (float *)malloc_type_malloc(4 * v192, 0x100004052888210uLL);
  uint64_t v47 = v224;
  if (a4 >= 4)
  {
    int v199 = 0;
    int v200 = 0;
    unsigned int v48 = a4 + 0x3FFFFFFF;
    if (v191 == 2) {
      unsigned int v49 = 8;
    }
    else {
      unsigned int v49 = 4;
    }
    if (v191 == 2) {
      float v50 = 0.03125;
    }
    else {
      float v50 = 0.0625;
    }
    if (v191 == 2) {
      unsigned int v51 = 105;
    }
    else {
      unsigned int v51 = 49;
    }
    int v52 = __K;
    if (__K <= 1) {
      int v52 = 1;
    }
    int v196 = v52;
    uint64_t v203 = 16 * v51;
    int __Ka = v51;
    uint64_t v201 = 4 * v51;
    while (!v215)
    {
LABEL_130:
      v199 += 4 * v215;
      if (++v200 == v196) {
        goto LABEL_131;
      }
    }
    unint64_t v53 = 0;
    int v213 = v200 * v215;
    int v54 = (v200 + 0x3FFFFFFF) * v215;
    int v197 = v54 + 1;
    int v198 = v54 + 0x3FFFFFFF;
    int v55 = v199;
    while (1)
    {
      unint64_t v227 = v53;
      bzero(__A, 0x690uLL);
      int v56 = 0;
      float32x4_t v243 = 0uLL;
      memset(__C, 0, sizeof(__C));
      uint64_t v241 = 0;
      *(void *)__w = 0;
      int v239 = 0;
      memset(__Y, 0, sizeof(__Y));
      int v237 = 0;
      memset(v236, 0, sizeof(v236));
      __CLPK_integer __n = 4;
      __CLPK_integer __lda = 4;
      __lworuint64_t k = 11;
      __CLPK_integer __info = 0;
      float32x4_t v57 = 0uLL;
      int v58 = -3;
      int32x2_t v59 = 0;
      *(_OWORD *)__woruint64_t k = 0u;
      memset(v235, 0, sizeof(v235));
      do
      {
        uint64_t v60 = 0;
        if (v58 >= 0) {
          int v61 = v58;
        }
        else {
          int v61 = -v58;
        }
        int v62 = 4 - v61;
        int v63 = (char *)v236 + 4 * v56;
        int v64 = 4 * v56;
        int v65 = 2 * v49 - 1;
        int v66 = 1 - v49;
        do
        {
          if (v66 >= 0) {
            int v67 = v66;
          }
          else {
            int v67 = -v66;
          }
          float v68 = v50 * (float)(int)((v49 - v67) * v62);
          *(float *)&v63[v60] = v68;
          float32x4_t v69 = vmulq_n_f32(v38[(((v49 >> 1) + (v227 << v211) + v66) & (v226 + 0x3FFFFFFF))+ ((((4 * v200) | 2) + v58) & v48) * v226], v68);
          __A[v64 + (int)v60] = v69.f32[0];
          __A[v64 + 1 + (int)v60] = v69.f32[1];
          __A[v64 + 2 + (int)v60] = v69.f32[2];
          __A[v64 + 3 + (int)v60] = v69.f32[3];
          *(float *)v59.i32 = *(float *)v59.i32 + v68;
          ++v56;
          float32x4_t v57 = vaddq_f32(v69, v57);
          ++v66;
          v60 += 4;
          --v65;
        }
        while (v65);
        ++v58;
      }
      while (v58 != 4);
      unint64_t v70 = 0;
      float v219 = *(float *)v59.i32;
      float32x4_t v71 = vdivq_f32(v57, (float32x4_t)vdupq_lane_s32(v59, 0));
      float32x4_t v243 = v71;
      do
      {
        *(float32x4_t *)&__A[v70 / 4] = vsubq_f32(*(float32x4_t *)&__A[v70 / 4], v71);
        v70 += 16;
      }
      while (v203 != v70);
      float v72 = 0.0;
      cblas_ssyrk(CblasColMajor, CblasUpper, CblasNoTrans, 4, __Ka, 1.0, __A, 4, 0.0, (float *)__C, 4);
      ssyev_("V", "U", &__n, (__CLPK_real *)__C, &__lda, __w, __work, &__lwork, &__info);
      uint64_t v73 = 0;
      int v74 = 0;
      do
      {
        if (__w[v73] > v72)
        {
          float v72 = __w[v73];
          int v74 = v73;
        }
        ++v73;
      }
      while (v73 != 4);
      uint64_t v75 = (float32x4_t *)((char *)__C + 4 * (4 * v74));
      float v76 = v75->f32[0];
      float v77 = v75->f32[1];
      float v78 = v75->f32[2];
      double v79 = (float)((float)(v75->f32[0] + v77) + v78);
      if (v79 > 0.15) {
        goto LABEL_114;
      }
      if (v79 >= -0.15)
      {
        if (v200 | v227)
        {
          if (v227)
          {
            int v80 = &v209[(4 * (v200 * v215 + 0x3FFFFFFF + v227))];
            float v81 = (float)((float)((float)(v77 * v80[1]) + (float)(v76 * *v80)) + (float)(v78 * v80[2]))
                + (float)(v75->f32[3] * v80[3]);
            float v82 = 0.0;
            if (v81 <= 0.2) {
              float v83 = 0.0;
            }
            else {
              float v83 = v81 + 0.0;
            }
            if (v81 < 0.2) {
              float v82 = 0.0 - v81;
            }
          }
          else
          {
            float v83 = 0.0;
            float v82 = 0.0;
          }
          if (v200)
          {
            unsigned int v86 = &v209[(4 * ((v200 + 0x3FFFFFFF) * v215 + v227))];
            float v87 = v75->f32[3];
            float v88 = (float)((float)((float)(v77 * v86[1]) + (float)(v76 * *v86)) + (float)(v78 * v86[2]))
                + (float)(v87 * v86[3]);
            if (v88 <= 0.2) {
              float v89 = -0.0;
            }
            else {
              float v89 = (float)((float)((float)(v77 * v86[1]) + (float)(v76 * *v86)) + (float)(v78 * v86[2]))
            }
                  + (float)(v87 * v86[3]);
            float v83 = v83 + v89;
            if (v88 >= 0.2) {
              float v88 = 0.0;
            }
            float v82 = v82 - v88;
            if (v227)
            {
              __int16 v90 = &v209[(4 * (v198 + v227))];
              float v91 = v90[3];
              float v92 = (float)((float)((float)(v77 * v90[1]) + (float)(v76 * *v90)) + (float)(v78 * v90[2]))
                  + (float)(v87 * v91);
              _NF = v92 < 0.2;
              float v94 = v92 <= 0.2
                  ? -0.0
                  : (float)((float)((float)(v77 * v90[1]) + (float)(v76 * *v90)) + (float)(v78 * v90[2]))
                  + (float)(v87 * v91);
              float v83 = v83 + v94;
              float v95 = v82 - v92;
              if (_NF) {
                float v82 = v95;
              }
            }
            if (v227 < (v215 - 1))
            {
              int v96 = &v209[(4 * (v197 + v227))];
              float v97 = (float)((float)((float)(v77 * v96[1]) + (float)(v76 * *v96)) + (float)(v78 * v96[2]))
                  + (float)(v87 * v96[3]);
              float v98 = v97 <= 0.2 ? -0.0 : v97;
              float v83 = v83 + v98;
              if (v97 < 0.2) {
                float v82 = v82 - v97;
              }
            }
          }
          if (v83 + 0.3 >= v82) {
            goto LABEL_114;
          }
        }
        else
        {
          uint64_t v84 = 0;
          float v85 = 0.0;
          do
          {
            if (fabsf(v75->f32[v84]) > fabsf(v85)) {
              float v85 = v75->f32[v84];
            }
            ++v84;
          }
          while (v84 != 4);
          if (v85 >= 0.0) {
            goto LABEL_114;
          }
        }
      }
      *uint64_t v75 = vnegq_f32(*v75);
      float v76 = v75->f32[0];
LABEL_114:
      int v99 = v213 + v227;
      v209[(4 * (v213 + v227))] = v76;
      v209[(4 * v99) | 1] = v75->f32[1];
      v209[(4 * v99) | 2] = v75->f32[2];
      v209[(4 * v99) | 3] = v75->f32[3];
      float v100 = 0.0;
      cblas_sgemv(CblasRowMajor, CblasNoTrans, __Ka, 4, 1.0, __A, 4, v75->f32, 1, 0.0, (float *)__Y, 1);
      uint64_t v101 = 0;
      float v102 = 0.0;
      do
      {
        float v103 = *(float *)((char *)__Y + v101);
        float v104 = *(float *)((char *)v236 + v101);
        float v102 = v102 + (float)(v103 * v104);
        float v100 = v100 + (float)((float)(v103 * v103) * v104);
        v101 += 4;
      }
      while (v201 != v101);
      uint64_t v105 = 0;
      float v106 = v102 / v219;
      float v107 = sqrtf((float)(v100 / v219) - (float)(v106 * v106)) * 1.312;
      float v108 = (float)(v102 / v219) - v107;
      float v109 = v106 + v107;
      uint64_t v47 = v224;
      do
      {
        int v110 = v55 + v105;
        float v111 = v224[(v55 + v105)] + v243.f32[v105];
        float v112 = v75->f32[v105];
        float v113 = v111 + (float)(v108 * v112);
        float v114 = v207[v105];
        float v115 = v111 + (float)(v109 * v112);
        float v116 = v113 / v114;
        float v117 = v115 / v114;
        float v118 = 255.0;
        if (v116 <= 255.0) {
          float v119 = v116;
        }
        else {
          float v119 = 255.0;
        }
        if (v116 >= 0.0) {
          float v120 = v119;
        }
        else {
          float v120 = 0.0;
        }
        if (v117 <= 255.0) {
          float v118 = v117;
        }
        if (v117 >= 0.0) {
          float v121 = v118;
        }
        else {
          float v121 = 0.0;
        }
        v45[v110] = v120;
        v46[v110] = v121;
        ++v105;
      }
      while (v105 != 4);
      unint64_t v53 = v227 + 1;
      v55 += 4;
      unsigned int v48 = a4 + 0x3FFFFFFF;
      if (v227 + 1 == v215) {
        goto LABEL_130;
      }
    }
  }
LABEL_131:
  free(v47);
  free(v38);
  free(v209);
  double v122 = (float *)malloc_type_calloc(count, 4uLL, 0x100004052888210uLL);
  uint64_t v123 = (uint64_t)v122;
  double v124 = a2;
  if (count)
  {
    double v125 = v122;
    uint64_t v126 = (4 * v26);
    do
    {
      unsigned int v127 = *v124++;
      *v125++ = (float)v127;
      --v126;
    }
    while (v126);
  }
  uint64_t v128 = malloc_type_malloc(count, 0x100004077774924uLL);
  uint64_t v129 = malloc_type_malloc(size, 0x100004077774924uLL);
  uint64_t v130 = malloc_type_malloc(4 * a4 * v226, 0x100004052888210uLL);
  uint64_t v131 = malloc_type_malloc(20 * a4 * v226, 0x100004052888210uLL);
  uint64_t v132 = malloc_type_malloc(count, 0x100004077774924uLL);
  float v133 = malloc_type_malloc(count, 0x100004077774924uLL);
  uint64_t v225 = malloc_type_malloc(116 * size, 0x1000040DB6AEB77uLL);
  uint64_t v210 = v132;
  uint64_t v212 = (uint64_t)v129;
  uint64_t v205 = (uint64_t)v128;
  uint64_t v206 = v123;
  uint64_t v208 = v133;
  uint64_t v214 = v130;
  size_t v220 = v131;
  updateModulationError(v195, v226, a4, v123, (uint64_t)v45, (uint64_t)v46, (uint64_t)v130, (uint64_t)v131, (uint64_t)v132, (uint64_t)v133, (uint64_t)v128, (uint64_t)v129, v225, v194, v193);
  if (size)
  {
    uint64_t v136 = 0;
    uint64_t v137 = (uint64_t)v225;
    do
    {
      errorApply(v195, v137, (float32x4_t *)((char *)v45 + ((4 * v136) & 0x3FFFFFFF0)), (float32x4_t *)((char *)v46 + ((4 * v136) & 0x3FFFFFFF0)), v134, v135);
      v136 += 4;
      v137 += 116;
    }
    while (4 * size != v136);
  }
  CFStringRef v204 = malloc_type_malloc(v192, 0x100004077774924uLL);
  uint64_t v202 = malloc_type_malloc(v192, 0x100004077774924uLL);
  if (size)
  {
    int v138 = 0;
    uint64_t v139 = 0;
    do
    {
      int v140 = (4 * v139) | 3;
      float v141 = v45[v140];
      float v142 = v46[v140];
      uint64_t v143 = (4 * v139);
      *(_OWORD *)__A = *(_OWORD *)&v45[v143];
      __Y[0] = *(_OWORD *)&v46[v143];
      _Q2 = vsubq_f32(*(float32x4_t *)&v46[v143], *(float32x4_t *)&v45[v143]);
      _S4 = _Q2.i32[2];
      __asm { FMLA            S3, S4, V2.S[2] }
      _S4 = _Q2.i32[3];
      __asm { FMLA            S3, S4, V2.S[3] }
      float v151 = 0.0;
      float v152 = 0.0;
      if (_S3 < 64.0)
      {
        float v151 = flt_1889AA9F0[64 * (unint64_t)(v191 == 2)
                           + 8 * ((v139 % v215) & 7)
                           + ((v139 / v215) & 7)]
             + -32.5;
        float v152 = -v151;
      }
      *(void *)__Kb = v139;
      uint64_t v153 = 0;
      uint64_t v154 = &v45[v138];
      int v228 = v138;
      int v155 = &v46[v138];
      uint64_t v156 = (char *)&unk_1889AA998 + 4 * (v141 < 236.785714);
      int v157 = (char *)&unk_1889AA9A0 + 4 * (v142 < 236.785714);
      do
      {
        unsigned int v158 = v157[v153];
        v154[v153] = quantize(__A[v153] + (float)(v151 * flt_1889AABF0[v156[v153]]), v156[v153], v153 == 3);
        v155[v153] = quantize(*((float *)__Y + v153) + (float)(v152 * flt_1889AABF0[v158]), v158, v153 == 3);
        ++v153;
      }
      while (v153 != 4);
      uint64_t v139 = *(void *)__Kb + 1;
      int v138 = v228 + 4;
    }
    while (*(void *)__Kb + 1 != size);
  }
  uint64_t v159 = v193;
  uint64_t v161 = v205;
  int v160 = (void *)v206;
  uint64_t v162 = v195;
  updateModulationError(v195, v226, a4, v206, (uint64_t)v45, (uint64_t)v46, (uint64_t)v214, (uint64_t)v220, (uint64_t)v210, (uint64_t)v208, v205, (uint64_t)v129, v225, v216, v193);
  int v165 = 0;
  int v166 = v194;
  do
  {
    while (1)
    {
      int v229 = v165;
      if (size) {
        break;
      }
      updateModulationError(v162, v226, a4, (uint64_t)v160, (uint64_t)v45, (uint64_t)v46, (uint64_t)v214, (uint64_t)v220, (uint64_t)v210, (uint64_t)v208, v161, v212, v225, v166, v159);
      int v165 = v229 + 1;
      if (v229 == 3) {
        goto LABEL_171;
      }
    }
    uint64_t v167 = 0;
    uint64_t v168 = (uint64_t)v225;
    do
    {
      errorApply(v162, v168, (float32x4_t *)((char *)v45 + ((4 * v167) & 0x3FFFFFFF0)), (float32x4_t *)((char *)v46 + ((4 * v167) & 0x3FFFFFFF0)), v163, v164);
      v167 += 4;
      v168 += 116;
    }
    while (4 * size != v167);
    unsigned int v169 = 0;
    for (iuint64_t i = 0; ii != size; ++ii)
    {
      int v171 = (4 * ii) | 3;
      uint64_t v172 = v169;
      uint64_t v173 = (char *)&unk_1889AA998 + 4 * (v45[v171] < 236.785714);
      uint64_t v174 = (char *)&unk_1889AA9A0 + 4 * (v46[v171] < 236.785714);
      uint64_t v175 = -4;
      do
      {
        float v176 = v46[v172];
        v45[v172] = quantize(v45[v172], v173[v175 + 4], v175 == -1);
        v46[v172++] = quantize(v176, v174[v175 + 4], v175 == -1);
        ++v175;
      }
      while (v175);
      v169 += 4;
    }
    uint64_t v159 = v193;
    int v166 = v194;
    uint64_t v161 = v205;
    int v160 = (void *)v206;
    uint64_t v162 = v195;
    updateModulationError(v195, v226, a4, v206, (uint64_t)v45, (uint64_t)v46, (uint64_t)v214, (uint64_t)v220, (uint64_t)v210, (uint64_t)v208, v205, v212, v225, v194, v193);
    int v165 = v229 + 1;
  }
  while (v229 != 3);
  for (juint64_t j = 0; jj != size; ++jj)
  {
    uint64_t v178 = 0;
    uint64_t v180 = &v46[4 * (jj & 0x3FFFFFFF)];
    do
    {
      uint64_t v179 = &v45[4 * (jj & 0x3FFFFFFF)];
      float v181 = v179[v178];
      float v182 = v180[v178];
      float v183 = 255.0;
      if (v181 <= 255.0) {
        float v184 = v179[v178];
      }
      else {
        float v184 = 255.0;
      }
      if (v181 >= 0.0) {
        float v185 = v184;
      }
      else {
        float v185 = 0.0;
      }
      if (v182 <= 255.0) {
        float v183 = v180[v178];
      }
      if (v182 >= 0.0) {
        float v186 = v183;
      }
      else {
        float v186 = 0.0;
      }
      v204[4 * (jj & 0x3FFFFFFF) + v178] = (uint64_t)rintf(v185);
      v202[4 * (jj & 0x3FFFFFFF) + v178++] = (uint64_t)rintf(v186);
    }
    while (v178 != 4);
  }
LABEL_171:
  *a6 = v204;
  *a7 = v202;
  *a8 = v161;
  *a9 = v212;
  free(v160);
  free(v45);
  free(v46);
  free(v214);
  free(v210);
  free(v208);
  free(v225);
  free(v220);
}

uint64_t checkBitReplication(uint64_t result, int a2, int a3)
{
  unsigned int v5 = result;
  char v6 = 8 - (a3 + a2);
  CFTypeID v7 = (FILE **)MEMORY[0x1E4F143C8];
  if (result >> (a3 + a2) != (result & ~(-1 << v6))) {
    CFDictionaryRef result = fprintf((FILE *)*MEMORY[0x1E4F143C8], "Bit replication is wrong! (%d, %d)\n", result, a2);
  }
  if (v5 >> v6 >> a2 != ((v5 >> v6) & ~(-1 << a3))) {
    return fprintf(*v7, "Bit extra replication is wrong! (%d, %d, %d, %d)\n", v5, v5 >> v6, a2, a3);
  }
  return result;
}

void *lanczosDownsample84(const unsigned __int8 *a1, unsigned int a2, unsigned int a3)
{
  unint64_t v3 = a3 * (unint64_t)a2;
  if (v3 >> 62) {
    return 0;
  }
  vImagePixelCount v7 = a2 >> 3;
  vImagePixelCount v8 = a3 >> 2;
  vImagePixelCount v9 = a2;
  vImagePixelCount v10 = a3;
  char v11 = malloc_type_malloc(4 * v3, 0x34BF888BuLL);
  uint64_t v12 = v11;
  if (a3)
  {
    unsigned int v13 = 0;
    int v14 = 0;
    do
    {
      if (a2)
      {
        uint64_t v15 = 0;
        unsigned int v16 = v13;
        do
        {
          for (uint64_t i = 0; i != 4; ++i)
            *((unsigned char *)v11 + v16 + i) = a1[4 * (v14 + 2) % a3 * a2 + 4 * (((int)v15 + 4) % a2) + i];
          ++v15;
          v16 += 4;
        }
        while (v15 != v9);
      }
      ++v14;
      v13 += 4 * a2;
    }
    while (v14 != a3);
  }
  src.data = v11;
  src.double height = v10;
  src.double width = v9;
  src.size_t rowBytes = 4 * a2;
  uint64_t v18 = malloc_type_malloc((4 * v7 * v8), 0x100004077774924uLL);
  v20.data = v18;
  v20.double height = v8;
  v20.double width = v7;
  v20.size_t rowBytes = (4 * v7);
  vImageScale_ARGB8888(&src, &v20, 0, 0x20u);
  free(v12);
  return v18;
}

uint64_t bilinearUpsample84f(uint64_t result, float *a2, unsigned int a3, unsigned int a4, int a5, int a6)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  unsigned int v10 = ((a5 - 4) & (a3 - 1)) >> 3;
  unsigned int v11 = ((a6 - 2) & (a4 - 1)) >> 2;
  int v12 = v11 % (a4 >> 2) * (a3 >> 3);
  int v13 = v10 % (a3 >> 3);
  unsigned int v14 = (v11 + 1) % (a4 >> 2);
  int v15 = v12 + v13;
  unsigned int v16 = (v10 + 1) % (a3 >> 3);
  int v17 = v14 * (a3 >> 3);
  int v18 = v17 + v13;
  do
  {
    int v8 = (a5 - 4) & 7;
    int v9 = (a6 - 2) & 3;
    *(float *)(result + v6) = (float)((float)((float)((float)(a2[4 * v16 + 4 * v12 + v7] * (float)((4 - v9) * v8))
                                                    + (float)((float)((4 - v9) * (8 - v8))
                                                            * a2[v7 + (4 * v15)]))
                                            + (float)((float)((8 - v8) * v9) * a2[v7 + (4 * v18)]))
                                    + (float)((float)(v9 * v8) * a2[4 * v17 + 4 * v16 + v7]))
                            * 0.03125;
    ++v7;
    v6 += 4;
  }
  while (v6 != 16);
  return result;
}

float bilinearUpsample84fq(float *a1, float *a2, unsigned int a3, unsigned int a4, int a5, int a6)
{
  uint64_t v6 = 0;
  v18[1] = *MEMORY[0x1E4F143B8];
  unsigned int v7 = ((a5 - 4) & (a3 - 1)) >> 3;
  unsigned int v8 = ((a6 - 2) & (a4 - 1)) >> 2;
  int v9 = v8 % (a4 >> 2) * (a3 >> 3);
  int v10 = v7 % (a3 >> 3);
  unsigned int v11 = (v7 + 1) % (a3 >> 3);
  unsigned int v12 = (v8 + 1) % (a4 >> 2) * (a3 >> 3);
  int32x4_t v13 = vdupq_n_s32((a5 - 4) & 7);
  int32x4_t v14 = (int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * (v9 + v10)]))), (uint32x4_t)xmmword_1889AA9C0);
  int32x4_t v15 = (int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * v12 + 4 * v10]))), (uint32x4_t)xmmword_1889AA9C0);
  int32x4_t v16 = vmlaq_s32(vshlq_n_s32(v14, 3uLL), vshrq_n_s32(vshlq_n_s32(vsubq_s32((int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * v11 + 4 * v9]))), (uint32x4_t)xmmword_1889AA9C0), v14), 0x18uLL), 0x18uLL), v13);
  v18[0] = vmovn_s32(vmlaq_s32(vshlq_n_s32(v16, 2uLL), vmlaq_s32(vsubq_s32(vshlq_n_s32(v15, 3uLL), v16), vshrq_n_s32(vshlq_n_s32(vsubq_s32((int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * v12 + 4 * v11]))), (uint32x4_t)xmmword_1889AA9C0), v15), 0x18uLL), 0x18uLL), v13), vdupq_n_s32((a6 - 2) & 3)));
  do
  {
    a1[v6] = (float)((*((__int16 *)v18 + v6) >> 7) + (*((__int16 *)v18 + v6) >> 2));
    ++v6;
  }
  while (v6 != 3);
  float result = (float)((SHIWORD(v18[0]) >> 5) + (SHIWORD(v18[0]) >> 1));
  a1[3] = result;
  return result;
}

uint64_t errorAccumulateBilinear84(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4, int a5, int a6, float a7)
{
  uint64_t v7 = 0;
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  int v8 = (a6 - 2) & 3;
  v32[0] = 1.0 - a7;
  v32[1] = a7;
  int v9 = (a5 - 4) & 7;
  v10.i32[0] = 8 - v9;
  v10.i32[1] = v9;
  float32x2_t v29 = vmul_f32(vcvt_f32_s32(vmul_s32(vdup_n_s32(4 - v8), v10)), (float32x2_t)0x3D0000003D000000);
  *(float *)v10.i32 = (float)((8 - v9) * v8) * 0.03125;
  float v11 = (float)(v8 * v9) * 0.03125;
  unsigned int v12 = ((a5 - 4) & (a3 - 1)) >> 3;
  unsigned int v13 = ((a6 - 2) & (a4 - 1)) >> 2;
  int v14 = v13 % (a4 >> 2) * (a3 >> 3);
  int v15 = v12 % (a3 >> 3);
  unsigned int v16 = (v12 + 1) % (a3 >> 3);
  v28[0] = v14 + v15;
  v28[1] = v16 + v14;
  unsigned int v17 = (v13 + 1) % (a4 >> 2) * (a3 >> 3);
  v28[2] = v17 + v15;
  v28[3] = v17 + v16;
  __int32 v30 = v10.i32[0];
  float v31 = v11;
  do
  {
    uint64_t v18 = 0;
    unsigned int v19 = v28[v7];
    *(float *)(result + 116 * v19) = *(float *)(result + 116 * v19) + 1.0;
    float v20 = v29.f32[v7];
    char v21 = 1;
    do
    {
      uint64_t v22 = 0;
      char v23 = v21;
      float v24 = v20 * v32[v18];
      uint64_t v25 = result + 116 * v19 + 4 * v18;
      *(float *)(v25 + 4) = *(float *)(v25 + 4) + v24;
      *(float *)(v25 + 12) = *(float *)(v25 + 12) + (float)(v24 * v24);
      uint64_t v26 = result + 84 + 116 * v19 + 16 * v18;
      do
      {
        size_t v27 = (float *)(v26 + v22);
        *(v27 - 16) = *(float *)(a2 + v22) + *(float *)(v26 + v22 - 64);
        *(v27 - 8) = *(float *)(v26 + v22 - 32) + (float)(*(float *)(a2 + v22) * *(float *)(a2 + v22));
        float *v27 = *(float *)(v26 + v22) + (float)(v24 * *(float *)(a2 + v22));
        v22 += 4;
      }
      while (v22 != 16);
      char v21 = 0;
      uint64_t v18 = 1;
    }
    while ((v23 & 1) != 0);
    ++v7;
  }
  while (v7 != 4);
  return result;
}

void *lanczosDownsample4(const unsigned __int8 *a1, unsigned int a2, unsigned int a3)
{
  unint64_t v3 = a3 * (unint64_t)a2;
  if (v3 >> 62) {
    return 0;
  }
  vImagePixelCount v7 = a2 >> 2;
  vImagePixelCount v8 = a3 >> 2;
  vImagePixelCount v9 = a2;
  vImagePixelCount v10 = a3;
  float v11 = malloc_type_malloc(4 * v3, 0x8EEDB46EuLL);
  unsigned int v12 = v11;
  if (a3)
  {
    unsigned int v13 = 0;
    int v14 = 0;
    do
    {
      if (a2)
      {
        uint64_t v15 = 0;
        unsigned int v16 = v13;
        do
        {
          for (uint64_t i = 0; i != 4; ++i)
            *((unsigned char *)v11 + v16 + i) = a1[4 * (v14 + 2) % a3 * a2 + 4 * (((int)v15 + 2) % a2) + i];
          ++v15;
          v16 += 4;
        }
        while (v15 != v9);
      }
      ++v14;
      v13 += 4 * a2;
    }
    while (v14 != a3);
  }
  src.data = v11;
  src.double height = v10;
  src.double width = v9;
  src.size_t rowBytes = 4 * a2;
  size_t v18 = a2 & 0xFFFFFFFC;
  unsigned int v19 = malloc_type_malloc((v18 * v8), 0x100004077774924uLL);
  v21.data = v19;
  v21.double height = v8;
  v21.double width = v7;
  v21.size_t rowBytes = v18;
  vImageScale_ARGB8888(&src, &v21, 0, 0x20u);
  free(v12);
  return v19;
}

uint64_t bilinearUpsample4f(uint64_t result, float *a2, unsigned int a3, unsigned int a4, int a5, int a6)
{
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  unsigned int v10 = ((a5 - 2) & (a3 - 1)) >> 2;
  unsigned int v11 = ((a6 - 2) & (a4 - 1)) >> 2;
  int v12 = v11 % (a4 >> 2) * (a3 >> 2);
  int v13 = v10 % (a3 >> 2);
  unsigned int v14 = (v11 + 1) % (a4 >> 2);
  int v15 = v12 + v13;
  unsigned int v16 = (v10 + 1) % (a3 >> 2);
  int v17 = v14 * (a3 >> 2);
  int v18 = v17 + v13;
  do
  {
    int v8 = (a5 - 2) & 3;
    int v9 = (a6 - 2) & 3;
    *(float *)(result + v6) = (float)((float)((float)((float)(a2[4 * v16 + 4 * v12 + v7] * (float)((4 - v9) * v8))
                                                    + (float)((float)((4 - v9) * (4 - v8))
                                                            * a2[v7 + (4 * v15)]))
                                            + (float)((float)((4 - v8) * v9) * a2[v7 + (4 * v18)]))
                                    + (float)((float)(v9 * v8) * a2[4 * v17 + 4 * v16 + v7]))
                            * 0.0625;
    ++v7;
    v6 += 4;
  }
  while (v6 != 16);
  return result;
}

float bilinearUpsample4fq(float *a1, float *a2, unsigned int a3, unsigned int a4, int a5, int a6)
{
  uint64_t v6 = 0;
  v18[1] = *MEMORY[0x1E4F143B8];
  unsigned int v7 = ((a5 - 2) & (a3 - 1)) >> 2;
  unsigned int v8 = ((a6 - 2) & (a4 - 1)) >> 2;
  int v9 = v8 % (a4 >> 2) * (a3 >> 2);
  int v10 = v7 % (a3 >> 2);
  unsigned int v11 = (v7 + 1) % (a3 >> 2);
  unsigned int v12 = (v8 + 1) % (a4 >> 2) * (a3 >> 2);
  int32x4_t v13 = vdupq_n_s32((a5 - 2) & 3);
  int32x4_t v14 = (int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * (v9 + v10)]))), (uint32x4_t)xmmword_1889AA9C0);
  int32x4_t v15 = (int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * v12 + 4 * v10]))), (uint32x4_t)xmmword_1889AA9C0);
  int32x4_t v16 = vmlaq_s32(vshlq_n_s32(v14, 2uLL), vshrq_n_s32(vshlq_n_s32(vsubq_s32((int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * v11 + 4 * v9]))), (uint32x4_t)xmmword_1889AA9C0), v14), 0x18uLL), 0x18uLL), v13);
  v18[0] = vmovn_s32(vmlaq_s32(vshlq_n_s32(v16, 2uLL), vmlaq_s32(vsubq_s32(vshlq_n_s32(v15, 2uLL), v16), vshrq_n_s32(vshlq_n_s32(vsubq_s32((int32x4_t)vshlq_u32(vmovl_u16((uint16x4_t)vmovn_s32(vcvtq_s32_f32(*(float32x4_t *)&a2[4 * v12 + 4 * v11]))), (uint32x4_t)xmmword_1889AA9C0), v15), 0x18uLL), 0x18uLL), v13), vdupq_n_s32((a6 - 2) & 3)));
  do
  {
    a1[v6] = (float)((*((__int16 *)v18 + v6) >> 6) + (*((__int16 *)v18 + v6) >> 1));
    ++v6;
  }
  while (v6 != 3);
  float result = (float)(SHIWORD(v18[0]) + (SHIWORD(v18[0]) >> 4));
  a1[3] = result;
  return result;
}

uint64_t errorAccumulateBilinear4(uint64_t result, uint64_t a2, unsigned int a3, unsigned int a4, int a5, int a6, float a7)
{
  uint64_t v7 = 0;
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  int v8 = (a6 - 2) & 3;
  v32[0] = 1.0 - a7;
  v32[1] = a7;
  int v9 = (a5 - 2) & 3;
  v10.i32[0] = 4 - v9;
  v10.i32[1] = v9;
  float32x2_t v29 = vmul_f32(vcvt_f32_s32(vmul_s32(vdup_n_s32(4 - v8), v10)), (float32x2_t)vdup_n_s32(0x3D800000u));
  *(float *)v10.i32 = (float)((4 - v9) * v8) * 0.0625;
  float v11 = (float)(v8 * v9) * 0.0625;
  unsigned int v12 = ((a5 - 2) & (a3 - 1)) >> 2;
  unsigned int v13 = ((a6 - 2) & (a4 - 1)) >> 2;
  int v14 = v13 % (a4 >> 2) * (a3 >> 2);
  int v15 = v12 % (a3 >> 2);
  unsigned int v16 = (v12 + 1) % (a3 >> 2);
  v28[0] = v14 + v15;
  v28[1] = v16 + v14;
  unsigned int v17 = (v13 + 1) % (a4 >> 2) * (a3 >> 2);
  v28[2] = v17 + v15;
  v28[3] = v17 + v16;
  __int32 v30 = v10.i32[0];
  float v31 = v11;
  do
  {
    uint64_t v18 = 0;
    unsigned int v19 = v28[v7];
    *(float *)(result + 116 * v19) = *(float *)(result + 116 * v19) + 1.0;
    float v20 = v29.f32[v7];
    char v21 = 1;
    do
    {
      uint64_t v22 = 0;
      char v23 = v21;
      float v24 = v20 * v32[v18];
      uint64_t v25 = result + 116 * v19 + 4 * v18;
      *(float *)(v25 + 4) = *(float *)(v25 + 4) + v24;
      *(float *)(v25 + 12) = *(float *)(v25 + 12) + (float)(v24 * v24);
      uint64_t v26 = result + 84 + 116 * v19 + 16 * v18;
      do
      {
        size_t v27 = (float *)(v26 + v22);
        *(v27 - 16) = *(float *)(a2 + v22) + *(float *)(v26 + v22 - 64);
        *(v27 - 8) = *(float *)(v26 + v22 - 32) + (float)(*(float *)(a2 + v22) * *(float *)(a2 + v22));
        float *v27 = *(float *)(v26 + v22) + (float)(v24 * *(float *)(a2 + v22));
        v22 += 4;
      }
      while (v22 != 16);
      char v21 = 0;
      uint64_t v18 = 1;
    }
    while ((v23 & 1) != 0);
    ++v7;
  }
  while (v7 != 4);
  return result;
}

void updateModulationError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void (*a14)(float32x4_t *, uint64_t, uint64_t, uint64_t), void (*a15)(void *, float32x4_t *, uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v271 = *MEMORY[0x1E4F143B8];
  uint64_t v20 = *(void *)a1;
  int v234 = *(unsigned char *)(a1 + 8) & 7;
  if (v234 == 2) {
    char v21 = 3;
  }
  else {
    char v21 = 2;
  }
  unsigned int v22 = a3 >> 2;
  uint64_t v228 = a2 >> v21;
  bzero(a13, 116 * v228 * (a3 >> 2));
  if (a3)
  {
    unsigned int v224 = v22;
    uint64_t v226 = a1;
    uint64_t v243 = a7;
    unsigned int v227 = 0;
    unsigned int v238 = 0;
    uint64_t v229 = a8 + 4 * (a3 * a2);
    uint64_t v231 = a8 + 4 * (2 * a3 * a2);
    uint64_t v30 = a9;
    uint64_t v29 = a10;
    uint64_t v230 = a8 + 4 * (3 * a3 * a2);
    uint64_t v31 = a8 + 4 * (4 * a3 * a2);
    int v225 = 4 * a2;
    do
    {
      if (a2)
      {
        uint64_t v32 = 0;
        unsigned int v33 = v227;
        do
        {
          uint64_t v240 = v32;
          float32x4_t v251 = 0uLL;
          uint64_t v34 = v30 + v33;
          float32x4_t v249 = 0uLL;
          uint64_t v35 = v29 + v33;
          float32x4_t v247 = 0uLL;
          unsigned int v235 = v33;
          uint64_t v36 = a4 + 4 * v33;
          uint64_t v244 = 0;
          uint64_t v245 = 0;
          a14(&v251, a5, a2, a3);
          ((void (*)(float32x4_t *, uint64_t, uint64_t, uint64_t, uint64_t, void))a14)(&v249, a6, a2, a3, v240, v238);
          uint64_t v37 = 0;
          unsigned int v38 = v238 * a2 + v240;
          do
          {
            float v39 = v251.f32[v37];
            *(unsigned char *)(v34 + v37) = (int)v39;
            float v40 = v249.f32[v37];
            *(unsigned char *)(v35 + v37) = (int)v40;
            float v41 = *(float *)(v20 + 4 * v37);
            v247.f32[v37] = (float)(v40 - v39) * v41;
            *((float *)&v244 + v37) = v41 * (float)(*(float *)(v36 + 4 * v37) - v39);
            ++v37;
          }
          while (v37 != 4);
          v27.i32[0] = v247.i32[3];
          float v26 = v247.f32[2];
          *(float *)&double v25 = (float)((float)((float)(v247.f32[1] * v247.f32[1]) + (float)(v247.f32[0] * v247.f32[0]))
                                 + (float)(v247.f32[2] * v247.f32[2]))
                         + (float)(v247.f32[3] * v247.f32[3]);
          float v24 = *(float *)&v245;
          *(float *)&double v23 = (float)((float)((float)((float)(v247.f32[1] * *((float *)&v244 + 1))
                                                 + (float)(*(float *)&v244 * v247.f32[0]))
                                         + (float)(*(float *)&v245 * v247.f32[2]))
                                 + (float)(*((float *)&v245 + 1) * v247.f32[3]))
                         / *(float *)&v25;
          *(_DWORD *)(a8 + 4 * v38) = LODWORD(v23);
          *(_DWORD *)(v31 + 4 * v38) = LODWORD(v25);
          uint64_t v32 = v240 + 1;
          unsigned int v33 = v235 + 4;
          uint64_t v30 = a9;
          uint64_t v29 = a10;
        }
        while (v240 + 1 != a2);
      }
      v227 += v225;
      ++v238;
    }
    while (v238 != a3);
    if (v234 == 2)
    {
      int v42 = 0;
      uint64_t v43 = a2 - 1;
      do
      {
        unint64_t v44 = v42 & 1;
        if (v44 >= a2)
        {
          int v47 = v42 + 1;
        }
        else
        {
          int v45 = v42 * a2;
          int v46 = (v42 - 1) % a3 * a2;
          int v47 = v42 + 1;
          if (v42 + 1 == a3) {
            int v48 = 0;
          }
          else {
            int v48 = v42 + 1;
          }
          int v49 = v48 * a2;
          int v50 = v42 & 3;
          do
          {
            uint64_t v51 = (v45 + v44);
            uint64_t v52 = ((int)v44 - 1) % a2 + v45;
            uint64_t v53 = (v46 + v44);
            if (v43 == v44) {
              int v54 = 0;
            }
            else {
              int v54 = v44 + 1;
            }
            uint64_t v55 = (v45 + v54);
            uint64_t v56 = (v49 + v44);
            float v57 = (float)((float)((float)((float)(*(float *)(a8 + 4 * v52)
                                                + *(float *)(a8 + 4 * v53))
                                        + *(float *)(a8 + 4 * v55))
                                + *(float *)(a8 + 4 * v56))
                        * 0.125)
                + (float)(*(float *)(a8 + 4 * v51) * 0.5);
            int v58 = v44 & 7 | v50;
            if (v58)
            {
              float v59 = 0.0;
              if (v57 >= 0.1875)
              {
                float v59 = 0.375;
                if (v57 >= 0.5)
                {
                  if (v57 >= 0.8125) {
                    float v59 = 1.0;
                  }
                  else {
                    float v59 = 0.625;
                  }
                }
              }
            }
            else if (v57 >= 0.5)
            {
              float v59 = 1.0;
            }
            else
            {
              float v59 = 0.0;
            }
            *(float *)(v229 + 4 * v51) = v59;
            float v60 = (float)((float)(*(float *)(a8 + 4 * v52) + *(float *)(a8 + 4 * v55)) * 0.25)
                + (float)(*(float *)(a8 + 4 * v51) * 0.5);
            BOOL v62 = v50 == 2 && (v44 & 7) == 4 || v58 == 0;
            int v63 = v62;
            if (v62)
            {
              if (v60 >= 0.5) {
                float v64 = 1.0;
              }
              else {
                float v64 = 0.0;
              }
            }
            else
            {
              float v64 = 0.0;
              if (v60 >= 0.1875)
              {
                float v64 = 0.375;
                if (v60 >= 0.5)
                {
                  if (v60 >= 0.8125) {
                    float v64 = 1.0;
                  }
                  else {
                    float v64 = 0.625;
                  }
                }
              }
            }
            *(float *)(v231 + 4 * v51) = v64;
            float v65 = (float)((float)(*(float *)(a8 + 4 * v53) + *(float *)(a8 + 4 * v56)) * 0.25)
                + (float)(*(float *)(a8 + 4 * v51) * 0.5);
            if (v63)
            {
              if (v65 >= 0.5) {
                float v66 = 1.0;
              }
              else {
                float v66 = 0.0;
              }
            }
            else
            {
              float v66 = 0.0;
              if (v65 >= 0.1875)
              {
                float v66 = 0.375;
                if (v65 >= 0.5)
                {
                  if (v65 >= 0.8125) {
                    float v66 = 1.0;
                  }
                  else {
                    float v66 = 0.625;
                  }
                }
              }
            }
            *(float *)(v230 + 4 * v51) = v66;
            v44 += 2;
          }
          while (v44 < a2);
        }
        int v42 = v47;
      }
      while (v47 != a3);
      int v67 = 0;
      char v68 = 1;
      uint64_t v69 = a8 + 4 * (a3 * a2);
      do
      {
        if (((v67 & 1) == 0) >= a2)
        {
          int v73 = v67 + 1;
        }
        else
        {
          unint64_t v70 = v68 & 1;
          int v71 = v67 * a2;
          int v72 = (v67 - 1) % a3 * a2;
          int v73 = v67 + 1;
          if (v67 + 1 == a3) {
            int v74 = 0;
          }
          else {
            int v74 = v67 + 1;
          }
          int v75 = v74 * a2;
          do
          {
            uint64_t v76 = v71 + ((int)v70 - 1) % a2;
            if (v43 == v70) {
              int v77 = 0;
            }
            else {
              int v77 = v70 + 1;
            }
            uint64_t v78 = (v71 + v77);
            uint64_t v79 = (v75 + v70);
            float v80 = (float)((float)((float)(*(float *)(v229 + 4 * v76)
                                        + *(float *)(v229 + 4 * (v72 + v70)))
                                + *(float *)(v229 + 4 * v78))
                        + *(float *)(v229 + 4 * v79))
                * 0.25;
            float v81 = 0.0;
            float v82 = 0.0;
            if (v80 >= 0.0)
            {
              float v82 = 1.0;
              if (v80 < 1.0) {
                float v82 = roundf(v80 * 8.0) * 0.125;
              }
            }
            uint64_t v83 = (v71 + v70);
            *(float *)(v229 + 4 * v83) = v82;
            float v84 = (float)(*(float *)(v231 + 4 * v76) + *(float *)(v231 + 4 * v78)) * 0.5;
            if (v84 >= 0.0)
            {
              float v81 = 1.0;
              if (v84 < 1.0) {
                float v81 = roundf(v84 * 8.0) * 0.125;
              }
            }
            *(float *)(v231 + 4 * v83) = v81;
            float v85 = (float)(*(float *)(v230 + 4 * v79) + *(float *)(v230 + 4 * v79)) * 0.5;
            float v86 = 0.0;
            if (v85 >= 0.0)
            {
              float v86 = 1.0;
              if (v85 < 1.0) {
                float v86 = roundf(v85 * 8.0) * 0.125;
              }
            }
            *(float *)(v230 + 4 * v83) = v86;
            v70 += 2;
          }
          while (v70 < a2);
        }
        v68 ^= 1u;
        int v67 = v73;
      }
      while (v73 != a3);
      int v87 = 0;
      do
      {
        unsigned int v88 = v87 & 1;
        if (v88 < a2)
        {
          int v89 = v87 & 3;
          do
          {
            uint64_t v90 = 0;
            int v270 = 0;
            long long v269 = xmmword_1889AAC14;
            long long v267 = xmmword_1889AAC28;
            int v268 = 1;
            long long v265 = xmmword_1889AAC3C;
            int v266 = 1048576000;
            int v264 = 1;
            unint64_t v263 = 0xFFFFFFFF00000000;
            int v262 = 0;
            uint64_t v261 = 0;
            int v260 = 1056964608;
            uint64_t v259 = 0x3F0000003F800000;
            int v258 = 0;
            uint64_t v257 = 0;
            int v256 = 1;
            unint64_t v255 = 0xFFFFFFFF00000000;
            int v254 = 1056964608;
            uint64_t v253 = 0x3F0000003F800000;
            v251.i64[0] = v69;
            v251.i64[1] = a8 + 4 * (2 * a3 * a2);
            uint64_t v252 = a8 + 4 * (3 * a3 * a2);
            v249.i64[0] = (uint64_t)&v269;
            v249.i64[1] = (uint64_t)&v263;
            uint64_t v250 = &v257;
            v247.i64[0] = (uint64_t)&v267;
            v247.i64[1] = (uint64_t)&v261;
            CFDictionaryRef v248 = &v255;
            uint64_t v244 = &v265;
            uint64_t v245 = &v259;
            uint64_t v91 = v88 + v87 * a2;
            uint64_t v246 = &v253;
            do
            {
              uint64_t v92 = v251.i64[v90];
              int v93 = (int *)v249.i64[v90];
              float v94 = (int *)v247.i64[v90];
              float v95 = (float *)*(&v244 + v90);
              unsigned int v96 = dword_1889AAC5C[v90];
              if (v96 <= 1) {
                uint64_t v97 = 1;
              }
              else {
                uint64_t v97 = v96;
              }
              float v98 = 0.0;
              float v99 = 0.0;
              float v100 = 0.0;
              float v101 = 0.0;
              float v102 = 0.0;
              do
              {
                int v103 = *v94++;
                unsigned int v104 = (v103 + v87) % a3;
                int v105 = *v93++;
                unsigned int v106 = (v105 + v88) % a2 + v104 * a2;
                float v107 = *(float *)(v31 + 4 * v106);
                float v108 = *(float *)(a8 + 4 * v106) - *(float *)(v92 + 4 * v106);
                float v109 = *v95++;
                float v102 = v102 + v107;
                float v101 = v101 + (float)(v107 * v109);
                float v100 = v100 + (float)(v107 * (float)(v109 * v109));
                float v99 = v99 + (float)(v107 * v108);
                float v98 = v98 + (float)((float)(v107 * v109) * v108);
                --v97;
              }
              while (v97);
              float v110 = (float)((float)(1.0 / (float)((float)(v102 * v100) - (float)(v101 * v101)))
                           * (float)((float)(v102 * v98) - (float)(v101 * v99)))
                   + (float)((float)((float)(1.0 / (float)((float)(v102 * v100) - (float)(v101 * v101)))
                                   * (float)((float)(v100 * v99) - (float)(v101 * v98)))
                           + *(float *)(v92 + 4 * v91));
              if (!(v88 & 7 | v89) || v89 == 2 && (v88 & 7) == 4 && v90)
              {
                if (v110 >= 0.5) {
                  float v111 = 1.0;
                }
                else {
                  float v111 = 0.0;
                }
              }
              else
              {
                if (v110 >= 0.8125) {
                  float v112 = 1.0;
                }
                else {
                  float v112 = 0.625;
                }
                if (v110 < 0.5) {
                  float v112 = 0.375;
                }
                if (v110 >= 0.1875) {
                  float v111 = v112;
                }
                else {
                  float v111 = 0.0;
                }
              }
              *(float *)(v92 + 4 * v91) = v111;
              ++v90;
            }
            while (v90 != 3);
            v88 += 2;
            uint64_t v69 = a8 + 4 * (a3 * a2);
          }
          while (v88 < a2);
        }
        ++v87;
      }
      while (v87 != a3);
      int v113 = 0;
      LODWORD(v25) = 8.0;
      char v114 = 1;
      float v26 = 0.125;
      uint64_t v115 = v243;
      uint64_t v30 = a9;
      uint64_t v29 = a10;
      uint64_t v117 = a8 + 4 * (3 * a3 * a2);
      uint64_t v116 = a8 + 4 * (2 * a3 * a2);
      do
      {
        if (((v113 & 1) == 0) >= a2)
        {
          int v121 = v113 + 1;
        }
        else
        {
          unint64_t v118 = v114 & 1;
          int v119 = v113 * a2;
          int v120 = (v113 - 1) % a3 * a2;
          int v121 = v113 + 1;
          if (v113 + 1 == a3) {
            int v122 = 0;
          }
          else {
            int v122 = v113 + 1;
          }
          int v123 = v122 * a2;
          do
          {
            uint64_t v124 = v119 + ((int)v118 - 1) % a2;
            if (v43 == v118) {
              int v125 = 0;
            }
            else {
              int v125 = v118 + 1;
            }
            uint64_t v126 = (v119 + v125);
            uint64_t v127 = (v123 + v118);
            float v128 = (float)((float)((float)(*(float *)(v69 + 4 * v124)
                                         + *(float *)(v69 + 4 * (v120 + v118)))
                                 + *(float *)(v69 + 4 * v126))
                         + *(float *)(v69 + 4 * v127))
                 * 0.25;
            float v129 = 0.0;
            float v130 = 0.0;
            if (v128 >= 0.0)
            {
              float v130 = 1.0;
              if (v128 < 1.0) {
                float v130 = roundf(v128 * 8.0) * 0.125;
              }
            }
            uint64_t v131 = (v119 + v118);
            *(float *)(v69 + 4 * v131) = v130;
            float v132 = (float)(*(float *)(v231 + 4 * v124) + *(float *)(v231 + 4 * v126)) * 0.5;
            if (v132 >= 0.0)
            {
              float v129 = 1.0;
              if (v132 < 1.0) {
                float v129 = roundf(v132 * 8.0) * 0.125;
              }
            }
            *(float *)(v231 + 4 * v131) = v129;
            float v133 = (float)(*(float *)(v230 + 4 * v127) + *(float *)(v230 + 4 * v127)) * 0.5;
            float v134 = 0.0;
            if (v133 >= 0.0)
            {
              float v134 = 1.0;
              if (v133 < 1.0) {
                float v134 = roundf(v133 * 8.0) * 0.125;
              }
            }
            *(float *)(v230 + 4 * v131) = v134;
            v118 += 2;
          }
          while (v118 < a2);
        }
        v114 ^= 1u;
        int v113 = v121;
      }
      while (v121 != a3);
      unsigned int v236 = 0;
      unsigned int v135 = 0;
      do
      {
        unsigned int v136 = v135 + 4;
        if (a2)
        {
          unsigned int v137 = 0;
          int v138 = (v135 >> 2) * v228;
          unsigned int v139 = v236;
          do
          {
            unint64_t v140 = v137;
            v251.i32[3] = 0;
            *(uint64_t *)((char *)v251.i64 + 4) = 0;
            float v141 = 0.0;
            if (v135 != -4)
            {
              float v142 = 0.0;
              unsigned int v143 = v139;
              LODWORD(v25) = 0;
              float v26 = 0.0;
              unsigned int v144 = v135;
              do
              {
                if (v137 != -8)
                {
                  unsigned int v145 = v143;
                  unint64_t v146 = v137;
                  do
                  {
                    float v147 = *(float *)(a8 + 4 * v145);
                    float v148 = *(float *)(v31 + 4 * v145);
                    if (v147 >= 0.5) {
                      float v149 = 1.0;
                    }
                    else {
                      float v149 = 0.0;
                    }
                    float v150 = *(float *)(v69 + 4 * v145) - v147;
                    float v151 = *(float *)(v116 + 4 * v145) - v147;
                    float v141 = v141 + (float)((float)((float)(v149 - v147) * (float)(v149 - v147)) * v148);
                    float v26 = v26 + (float)((float)(v150 * v150) * v148);
                    *(float *)&double v25 = *(float *)&v25 + (float)((float)(v151 * v151) * v148);
                    float v142 = v142
                         + (float)((float)((float)(*(float *)(v117 + 4 * v145) - v147)
                                         * (float)(*(float *)(v117 + 4 * v145) - v147))
                                 * v148);
                    ++v146;
                    ++v145;
                  }
                  while (v146 < v137 + 8);
                }
                ++v144;
                v143 += a2;
              }
              while (v144 < v136);
              *(uint64_t *)((char *)v251.i64 + 4) = __PAIR64__(LODWORD(v25), LODWORD(v26));
              v251.f32[3] = v142;
            }
            unsigned __int8 v152 = 0;
            for (uint64_t i = 1; i != 4; ++i)
            {
              if (v251.f32[i] <= v141)
              {
                float v141 = v251.f32[i];
                unsigned __int8 v152 = i;
              }
            }
            *(unsigned char *)(a12 + v138 + (v140 >> 3)) = v152;
            switch(v152)
            {
              case 0u:
                if (v135 != -4)
                {
                  unsigned int v154 = v139;
                  unsigned int v155 = v135;
                  do
                  {
                    if (v140 != -8)
                    {
                      unsigned int v156 = v154;
                      unint64_t v157 = v140;
                      do
                      {
                        if (*(float *)(a8 + 4 * v156) >= 0.5) {
                          float v158 = 1.0;
                        }
                        else {
                          float v158 = 0.0;
                        }
                        *(float *)(v115 + 4 * v156) = v158;
                        ++v157;
                        ++v156;
                      }
                      while (v157 < (v140 + 8));
                    }
                    ++v155;
                    v154 += a2;
                  }
                  while (v155 < v136);
                }
                break;
              case 1u:
                if (v135 != -4)
                {
                  unsigned int v159 = v139;
                  unsigned int v160 = v135;
                  do
                  {
                    if (v140 != -8)
                    {
                      int v161 = 0;
                      unint64_t v162 = v140;
                      do
                      {
                        uint64_t v163 = v159 + v161;
                        float v164 = -1.0;
                        if (((v160 ^ (v140 + v161)) & 1) == 0) {
                          float v164 = *(float *)(v69 + 4 * v163);
                        }
                        *(float *)(v115 + 4 * v163) = v164;
                        ++v162;
                        ++v161;
                      }
                      while (v162 < (v140 + 8));
                    }
                    ++v160;
                    v159 += a2;
                  }
                  while (v160 < v136);
                }
                break;
              case 2u:
                if (v135 != -4)
                {
                  unsigned int v165 = v139;
                  unsigned int v166 = v135;
                  do
                  {
                    if (v140 != -8)
                    {
                      int v167 = 0;
                      unint64_t v168 = v140;
                      do
                      {
                        uint64_t v169 = v165 + v167;
                        float v170 = -2.0;
                        if (((v166 ^ (v140 + v167)) & 1) == 0) {
                          float v170 = *(float *)(v116 + 4 * v169);
                        }
                        *(float *)(v115 + 4 * v169) = v170;
                        ++v168;
                        ++v167;
                      }
                      while (v168 < (v140 + 8));
                    }
                    ++v166;
                    v165 += a2;
                  }
                  while (v166 < v136);
                }
                break;
              case 3u:
                if (v135 != -4)
                {
                  unsigned int v171 = v139;
                  unsigned int v172 = v135;
                  do
                  {
                    if (v140 != -8)
                    {
                      int v173 = 0;
                      unint64_t v174 = v140;
                      do
                      {
                        uint64_t v175 = v171 + v173;
                        float v176 = -3.0;
                        if (((v172 ^ (v140 + v173)) & 1) == 0) {
                          float v176 = *(float *)(v117 + 4 * v175);
                        }
                        *(float *)(v115 + 4 * v175) = v176;
                        ++v174;
                        ++v173;
                      }
                      while (v174 < (v140 + 8));
                    }
                    ++v172;
                    v171 += a2;
                  }
                  while (v172 < v136);
                }
                break;
              default:
                printf("Bad block mode %d (this isn't supposed to happen!)\n", v152);
                int v138 = (v135 >> 2) * v228;
                uint64_t v117 = a8 + 4 * (3 * a3 * a2);
                uint64_t v116 = a8 + 4 * (2 * a3 * a2);
                uint64_t v30 = a9;
                uint64_t v29 = a10;
                uint64_t v115 = v243;
                break;
            }
            unsigned int v137 = v140 + 8;
            v139 += 8;
          }
          while ((int)v140 + 8 < a2);
        }
        v236 += v225;
        v135 += 4;
      }
      while (v136 < a3);
LABEL_236:
      uint64_t v207 = 0;
      while (!a2)
      {
        uint64_t v223 = (v207 + 1);
LABEL_272:
        uint64_t v207 = v223;
        if (v223 == a3) {
          return;
        }
      }
      uint64_t v208 = 0;
      int v209 = v207 * a2;
      unsigned int v210 = v207 - 1;
      if (v207 + 1 == a3) {
        int v211 = 0;
      }
      else {
        int v211 = v207 + 1;
      }
      int v212 = v211 * a2;
      unsigned int v213 = v225 * v207;
      while (1)
      {
        float32x4_t v251 = 0uLL;
        BOOL v214 = v234 == 4 && *(unsigned char *)(a12 + (v207 >> 2) * v228 + (v208 >> 2)) != 0;
        float v215 = *(float *)(v115 + 4 * (v209 + v208));
        if (v215 == -1.0) {
          break;
        }
        if (v215 == -2.0)
        {
          float v218 = *(float *)(v115 + 4 * (v209 + ((int)v208 - 1) % a2));
          int v219 = v208 + 1;
          if (v208 + 1 == a2) {
            int v219 = 0;
          }
          unsigned int v220 = v219 + v209;
LABEL_255:
          float v217 = (float)(v218 + *(float *)(v115 + 4 * v220)) * 0.5;
LABEL_256:
          float v215 = 0.0;
          if (v217 >= 0.0)
          {
            float v215 = 1.0;
            if (v217 < 1.0) {
              float v215 = roundf(v217 * 8.0) * 0.125;
            }
          }
          goto LABEL_259;
        }
        if (v215 == -3.0)
        {
          float v218 = *(float *)(v115 + 4 * (v208 + v210 % a3 * a2));
          unsigned int v220 = v212 + v208;
          goto LABEL_255;
        }
LABEL_259:
        uint64_t v221 = 0;
        uint64_t v222 = (4 * (v209 + v208));
        do
        {
          LOBYTE(v25) = *(unsigned char *)(v30 + v213 + v221);
          LOBYTE(v26) = *(unsigned char *)(v29 + v213 + v221);
          *(unsigned char *)(a11 + v213 + v221) = (int)(float)(v215 * 255.0);
          *(float *)&double v25 = (float)((float)(1.0 - v215) * (float)LODWORD(v25)) + (float)(v215 * (float)LODWORD(v26));
          float v26 = 0.0;
          if (*(float *)&v25 >= 0.0)
          {
            float v26 = 255.0;
            if (*(float *)&v25 <= 255.0) {
              float v26 = *(float *)&v25;
            }
          }
          *(float *)&double v25 = *(float *)(a4 + 4 * v213 + 4 * v221) - v26;
          v251.i32[v221++] = LODWORD(v25);
        }
        while (v221 != 4);
        if (!v214
          || *(unsigned __int8 *)(a11 + v222) != 128
          || *(float *)(a4 + 4 * (v222 | 3)) >= 0.033333
          || (*(unsigned char *)(v226 + 8) & 8) == 0)
        {
          a15(a13, &v251, a2, a3, v208, v207);
          uint64_t v30 = a9;
          uint64_t v29 = a10;
          uint64_t v115 = v243;
        }
        ++v208;
        v213 += 4;
        if (v208 == a2)
        {
          uint64_t v223 = (v207 + 1);
          goto LABEL_272;
        }
      }
      int v216 = v208 + 1;
      if (v208 + 1 == a2) {
        int v216 = 0;
      }
      float v217 = (float)((float)((float)(*(float *)(v115 + 4 * (v209 + ((int)v208 - 1) % a2))
                                   + *(float *)(v115 + 4 * (v208 + v210 % a3 * a2)))
                           + *(float *)(v115 + 4 * (v216 + v209)))
                   + *(float *)(v115 + 4 * (v212 + v208)))
           * 0.25;
      goto LABEL_256;
    }
    uint64_t v115 = v243;
    if (a3 < 4) {
      goto LABEL_236;
    }
    int v239 = 0;
    float v177 = 0.1875;
    int v178 = v224;
    float v179 = 0.375;
    if (v224 <= 1) {
      int v178 = 1;
    }
    int v237 = v178;
    float v180 = 0.5;
    float v181 = 0.8125;
    float v182 = 0.625;
    while (1)
    {
      uint64_t v183 = v228;
      if (v228) {
        break;
      }
LABEL_235:
      if (++v239 == v237) {
        goto LABEL_236;
      }
    }
    uint64_t v184 = 0;
    int v241 = v239 * v228;
    int v185 = 4 * v239;
    while (1)
    {
      int v186 = (*(unsigned __int8 *)(a1 + 8) >> 4) & 3;
      if (v186 == 2)
      {
        *(unsigned char *)(a12 + (v241 + v184)) = 1;
      }
      else
      {
        if (v186 != 1)
        {
          *(unsigned char *)(a12 + (v241 + v184)) = 0;
LABEL_225:
          for (unsigned int j = 0; j != 16; ++j)
          {
            uint64_t v206 = (j & 3 | (4 * v184)) + (v185 + (j >> 2)) * a2;
            if ((*(unsigned char *)(a1 + 8) & 8) != 0)
            {
              findBestQuantizer(a1, 0xFu, (float32x4_t *)(a4 + 4 * (4 * v206)), (unsigned char *)(v30 + (4 * v206)), (unsigned char *)(a10 + (4 * v206)), v23, v24, v25, v26, *(float *)v27.i32);
              uint64_t v30 = a9;
              uint64_t v29 = a10;
              uint64_t v115 = v243;
            }
            else
            {
              float v24 = *(float *)(a8 + 4 * v206);
              double v23 = 0.0;
              if (v24 >= v177)
              {
                LODWORD(v23) = 0.375;
                if (v24 >= v180)
                {
                  if (v24 >= v181) {
                    *(float *)&double v23 = 1.0;
                  }
                  else {
                    *(float *)&double v23 = v182;
                  }
                }
              }
            }
            *(_DWORD *)(v115 + 4 * v206) = LODWORD(v23);
          }
          goto LABEL_234;
        }
        unsigned int v187 = 0;
        float v188 = 0.0;
        float v189 = 0.0;
        do
        {
          float32x4_t v251 = 0uLL;
          float32x4_t v249 = 0uLL;
          unsigned int v190 = (v187 & 3 | (4 * v184)) + (v185 + (v187 >> 2)) * a2;
          float v191 = *(float *)(a8 + 4 * v190);
          float32x4_t v247 = 0uLL;
          if (v191 >= 0.8125) {
            float v192 = 1.0;
          }
          else {
            float v192 = 0.625;
          }
          if (v191 < 0.5) {
            float v192 = v179;
          }
          if (v191 < 0.1875) {
            float v192 = 0.0;
          }
          unsigned int v193 = 4 * v190;
          if (v191 >= 0.75) {
            float v194 = 1.0;
          }
          else {
            float v194 = 0.5;
          }
          if (v191 <= 0.25) {
            float v195 = 0.0;
          }
          else {
            float v195 = v194;
          }
          v27.i32[0] = *(_DWORD *)(v30 + v193);
          float32x4_t v196 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v27)));
          v28.i32[0] = *(_DWORD *)(v29 + v193);
          float32x4_t v197 = vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v28)));
          float32x4_t v251 = vmlaq_n_f32(vmulq_n_f32(v196, 1.0 - v192), v197, v192);
          float32x4_t v249 = vmlaq_n_f32(vmulq_n_f32(v196, 1.0 - v195), v197, v195);
          v198.i64[0] = 0x3F0000003F000000;
          v198.i64[1] = 0x3F0000003F000000;
          float32x4_t v199 = vmulq_f32(vaddq_f32(v196, v197), v198);
          v199.i32[3] = 0;
          float32x4_t v247 = v199;
          int v200 = (float32x4_t *)(a4 + 4 * v193);
          float v189 = v189 + errorSquared(a1, v200, &v251);
          float v201 = errorSquared(a1, v200, &v249);
          *(float *)&double v23 = errorSquared(a1, v200, &v247);
          uint64_t v30 = a9;
          uint64_t v29 = a10;
          if (*(float *)&v23 >= v201) {
            *(float *)&double v23 = v201;
          }
          float v179 = 0.375;
          float v188 = v188 + *(float *)&v23;
          ++v187;
        }
        while (v187 != 16);
        BOOL v202 = v188 < v189;
        *(unsigned char *)(a12 + (v241 + v184)) = v188 < v189;
        uint64_t v115 = v243;
        uint64_t v183 = v228;
        float v181 = 0.8125;
        float v182 = 0.625;
        float v177 = 0.1875;
        float v180 = 0.5;
        if (!v202) {
          goto LABEL_225;
        }
      }
      for (unsigned int k = 0; k != 16; ++k)
      {
        unsigned int v204 = (k & 3 | (4 * v184)) + (v185 + (k >> 2)) * a2;
        findBestQuantizer(a1, 0x33u, (float32x4_t *)(a4 + 16 * v204), (unsigned char *)(v30 + 4 * v204), (unsigned char *)(a10 + 4 * v204), v23, v24, v25, v26, *(float *)v27.i32);
        uint64_t v30 = a9;
        uint64_t v29 = a10;
        uint64_t v115 = v243;
        *(_DWORD *)(v243 + 4 * v204) = LODWORD(v23);
      }
LABEL_234:
      if (++v184 == v183) {
        goto LABEL_235;
      }
    }
  }
}

uint64_t errorApply(uint64_t result, uint64_t a2, float32x4_t *a3, float32x4_t *a4, int32x4_t a5, int32x4_t a6)
{
  uint64_t v8 = 0;
  a5.i32[0] = 4;
  char v9 = 1;
  a6.i32[0] = *(unsigned char *)(result + 8) & 7;
  int8x16_t v10 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(a6, a5), 0);
  __asm { FMOV            V1.4S, #1.0 }
  float64x2_t v16 = (float64x2_t)vdupq_n_s64(0x4000ECF52B90A783uLL);
  float32x4_t v17 = (float32x4_t)vdupq_n_s32(0x437F0000u);
  do
  {
    char v18 = v9;
    uint64_t v19 = a2 + 4 * v8;
    float v20 = *(float *)(v19 + 4);
    if (v20 != 0.0)
    {
      float v21 = *(float *)(v19 + 12);
      v6.i32[0] = *(_DWORD *)a2;
      float32x4_t v22 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 0);
      uint64_t v23 = a2 + 16 * v8;
      float32x4_t v24 = *(float32x4_t *)(v23 + 20);
      float32x4_t v25 = *(float32x4_t *)(v23 + 84);
      float32x4_t v26 = vmulq_n_f32(v24, v20);
      float32x4_t v27 = vdivq_f32(vmulq_f32(v24, v24), v22);
      float32x4_t v28 = vsubq_f32(v25, vdivq_f32(v26, v22));
      float32x4_t v29 = vmulq_n_f32(vsubq_f32(*(float32x4_t *)(v23 + 52), v27), v21 - (float)((float)(v20 * v20) / *(float *)a2));
      float32x4_t v30 = (float32x4_t)vbslq_s8(v10, _Q1, vbslq_s8(vandq_s8((int8x16_t)vceqzq_f32(v28), (int8x16_t)vceqzq_f32(v29)), _Q1, (int8x16_t)vdivq_f32(vmulq_f32(v28, v28), v29)));
      if (v18) {
        uint64_t v31 = a3;
      }
      else {
        uint64_t v31 = a4;
      }
      v7.f32[0] = *(float *)(a2 + 4) + *(float *)(a2 + 8);
      float v32 = 1.0 / (float)-(float)((float)(v20 * v20) - (float)(v6.f32[0] * v21));
      float v33 = 0.05 / (float)(v32 + 0.05);
      float32x4_t v7 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v7.f32, 0);
      float32x4_t v34 = vmulq_n_f32(vmlaq_n_f32(vmulq_n_f32(v25, -v20), v24, v21), v32);
      float32x4_t v35 = vmulq_n_f32(vmlaq_n_f32(vnegq_f32(v26), v25, v6.f32[0]), v32);
      float32x4_t v36 = vdivq_f32(v25, v7);
      float32x4_t v37 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_f64(vcvtq_f64_f32(*(float32x2_t *)v36.f32), v16)), vmulq_f64(vcvt_hight_f64_f32(v36), v16));
      float32x4_t v6 = vmlaq_f32(v37, vsubq_f32(vaddq_f32(v35, v34), v37), vmulq_n_f32(v30, v33));
      float32x4_t v38 = vaddq_f32(*v31, v6);
      *(int8x16_t *)uint64_t v31 = vbicq_s8(vbslq_s8((int8x16_t)vcgtq_f32(v38, v17), (int8x16_t)v17, (int8x16_t)v38), (int8x16_t)vcltzq_f32(v38));
    }
    char v9 = 0;
    uint64_t v8 = 1;
  }
  while ((v18 & 1) != 0);
  return result;
}

float quantize(float a1, int a2, int a3)
{
  if (!a2) {
    return 255.0;
  }
  float v3 = 255.0;
  if (a1 <= 255.0) {
    float v3 = a1;
  }
  BOOL v4 = a1 < 0.0;
  float v5 = 0.0;
  if (!v4) {
    float v5 = v3;
  }
  float v6 = rintf((float)((float)(v5 * 15.0) / 255.0) * 0.5);
  int v7 = (uint64_t)v6 | (32 * (uint64_t)v6);
  float v8 = rintf((float)(v5 * (float)~(-1 << a2)) / 255.0);
  unsigned int v9 = ((uint64_t)v8 << (5 - a2)) | ((uint64_t)v8 >> (a2 - (5 - a2)));
  int v10 = (8 * v9) | (v9 >> 2);
  if (!a3) {
    LOBYTE(v7) = v10;
  }
  return (float)v7;
}

char *pvrtcDecompress(const unsigned __int8 *a1, unint64_t a2, unsigned int a3, unsigned int a4, int a5, unsigned __int8 **a6, unsigned __int8 **a7, signed __int8 **a8)
{
  if (a5 != 4 && a5 != 2) {
    return 0;
  }
  if (a5 == 2) {
    char v13 = 3;
  }
  else {
    char v13 = 2;
  }
  uint64_t v14 = a3 >> v13;
  size_t v15 = (a4 & 0xFFFFFFFC) * v14;
  float64x2_t v16 = malloc_type_malloc(v15, 0x100004077774924uLL);
  float32x4_t v17 = malloc_type_malloc(v15, 0x100004077774924uLL);
  char v18 = malloc_type_malloc(a4 * a3, 0x100004077774924uLL);
  if (a4 >= 4)
  {
    int v71 = 0;
    uint64_t v35 = 0;
    int v36 = v14 - 1;
    unsigned int v37 = 31 - __clz(v14);
    while (!v14)
    {
LABEL_70:
      ++v35;
      v71 += 4 * a3;
      if (v35 == a4 >> 2) {
        goto LABEL_7;
      }
    }
    uint64_t v38 = 0;
    int v39 = (v36 & v35 | ((v36 & v35) << 8)) & 0xFF00FF;
    int v40 = (v39 | (16 * v39)) & 0x3030303 | (4 * ((v39 | (16 * v39)) & 0xF0F0F0F)) & 0x33333333;
    int v41 = (v40 | (2 * v40)) & 0x55555555;
    int v42 = v14 * v35;
    int v43 = 4 * v35;
    int v44 = v71;
    while (1)
    {
      int v45 = (v36 & v38 | ((v36 & v38) << 8)) & 0xFF00FF;
      int v46 = (v45 | (16 * v45)) & 0x3030303 | (4 * ((v45 | (16 * v45)) & 0xF0F0F0F)) & 0x33333333;
      unsigned int v47 = (((v38 | v35) & -(int)v14) << v37) | v41 | ((4 * v46) | (2 * v46)) & 0xAAAAAAAA;
      if (a2 < 8 * (unint64_t)(v47 + 1)) {
        break;
      }
      unint64_t v48 = *(void *)&a1[8 * v47];
      if (a5 == 2)
      {
        unsigned int v49 = 8 * v38;
        if ((v48 & 0x100000000) != 0)
        {
          if ((v48 & 0x100000) != 0) {
            char v54 = 17;
          }
          else {
            char v54 = 16;
          }
          if (v48) {
            unint64_t v55 = v48 & 0xFFFFFFFFFFEFFFFFLL | (((v48 >> 21) & 1) << 20);
          }
          else {
            unint64_t v55 = v48;
          }
          if (v48) {
            unsigned __int8 v56 = v54;
          }
          else {
            unsigned __int8 v56 = 18;
          }
          uint64_t v57 = 4;
          int v58 = v44;
          do
          {
            *(void *)&v18[v58] = 0x101010101010101 * v56;
            v58 += a3;
            --v57;
          }
          while (v57);
          uint64_t v59 = 0;
          unint64_t v48 = (v55 >> 1) & 1 | v55 & 0xFFFFFFFFFFFFFFFELL;
          do
          {
            v18[(v59 & 6 | (v57 >> 2) & 1 | v49) + (v43 + (v57 >> 2)) * a3] = standardMod[(v48 >> v59) & 3];
            ++v57;
            v59 += 2;
          }
          while (v57 != 16);
        }
        else
        {
          for (uint64_t i = 0; i != 32; ++i)
            v18[(i & 7 | v49) + (v43 + (i >> 3)) * a3] = binaryMod[(v48 >> i) & 1];
        }
      }
      else
      {
        uint64_t v51 = 0;
        uint64_t v52 = 0;
        if ((v48 & 0x100000000) != 0) {
          uint64_t v53 = &punchthroughMod;
        }
        else {
          uint64_t v53 = standardMod;
        }
        do
        {
          v18[(v52 & 3 | (4 * v38)) + (v43 + (v52 >> 2)) * a3] = v53[(v48 >> v51) & 3];
          ++v52;
          v51 += 2;
        }
        while (v52 != 16);
      }
      uint64_t v60 = (4 * (v42 + v38));
      if ((v48 & 0x800000000000) != 0)
      {
        int v63 = &v16[v60];
        *int v63 = (v48 >> 42) & 0x1F;
        v63[1] = (v48 >> 37) & 0x1F;
        v63[2] = BYTE4(v48) & 0x1E | ((v48 & 0x1000000000) != 0);
        LOBYTE(v62) = 15;
      }
      else
      {
        int v61 = &v16[v60];
        *int v61 = (v48 >> 39) & 0x1E | ((v48 & 0x80000000000) != 0);
        v61[1] = (v48 >> 35) & 0x1E | ((v48 & 0x8000000000) != 0);
        v61[2] = (v48 >> 31) & 0x1C | (v48 >> 34) & 3;
        uint64_t v62 = (v48 >> 43) & 0xE;
      }
      v16[v60 | 3] = v62;
      uint64_t v64 = (4 * (v42 + v38));
      if ((v48 & 0x8000000000000000) != 0)
      {
        int v67 = &v17[v64];
        *int v67 = (v48 >> 58) & 0x1F;
        v67[1] = (v48 >> 53) & 0x1F;
        v67[2] = BYTE6(v48) & 0x1F;
        LOBYTE(v66) = 15;
      }
      else
      {
        float v65 = &v17[v64];
        *float v65 = (v48 >> 55) & 0x1E | ((v48 & 0x800000000000000) != 0);
        v65[1] = (v48 >> 51) & 0x1E | ((v48 & 0x80000000000000) != 0);
        v65[2] = (v48 >> 47) & 0x1E | ((v48 & 0x8000000000000) != 0);
        uint64_t v66 = (v48 >> 59) & 0xE;
      }
      v17[v64 | 3] = v66;
      ++v38;
      v44 += 8;
      if (v38 == v14) {
        goto LABEL_70;
      }
    }
    free(v16);
    free(v17);
    free(v18);
    return 0;
  }
LABEL_7:
  if (a5 == 2 && a4)
  {
    int v19 = 0;
    while (!a3)
    {
      int v23 = v19 + 1;
LABEL_32:
      int v19 = v23;
      if (v23 == a4) {
        goto LABEL_33;
      }
    }
    int v20 = 0;
    int v21 = v19 * a3;
    unsigned int v22 = v19 - 1;
    int v23 = v19 + 1;
    if (v19 + 1 == a4) {
      int v24 = 0;
    }
    else {
      int v24 = v19 + 1;
    }
    int v25 = v24 * a3;
    uint64_t v26 = 1 - a3;
    while (1)
    {
      uint64_t v27 = (v21 + v20);
      int v28 = v18[v27];
      if (v28 == 16) {
        break;
      }
      if (v28 == 17)
      {
        __int16 v31 = (char)v18[v20 + v22 % a4 * a3];
        int v32 = v25 + v20;
LABEL_27:
        __int16 v30 = (unsigned __int16)(v31 + (char)v18[v32] + 1) >> 1;
LABEL_28:
        v18[v27] = v30;
        goto LABEL_29;
      }
      if (v28 == 18)
      {
        if (v26) {
          int v29 = v20 + 1;
        }
        else {
          int v29 = 0;
        }
        __int16 v30 = (unsigned __int16)((char)v18[v21 + (v20 - 1) % a3]
                               + (char)v18[v29 + v21]
                               + (char)v18[v25 + v20]
                               + (char)v18[v20 + v22 % a4 * a3]
                               + 2) >> 2;
        goto LABEL_28;
      }
LABEL_29:
      ++v20;
      if (++v26 == 1) {
        goto LABEL_32;
      }
    }
    __int16 v31 = (char)v18[v21 + (v20 - 1) % a3];
    if (v26) {
      int v33 = v20 + 1;
    }
    else {
      int v33 = 0;
    }
    int v32 = v33 + v21;
    goto LABEL_27;
  }
LABEL_33:
  *a6 = v16;
  *a7 = v17;
  *a8 = v18;

  return pvrtcDecompressUnpacked(v16, v17, v18, a3, a4, a5);
}

char *pvrtcDecompressUnpacked(const unsigned __int8 *a1, const unsigned __int8 *a2, const signed __int8 *a3, unsigned int a4, unsigned int a5, int a6)
{
  int v7 = bilinearUpsample4u;
  if (a6 == 2) {
    int v7 = bilinearUpsample84u;
  }
  int v19 = v7;
  float result = (char *)malloc_type_malloc(4 * a4 * a5, 0x100004077774924uLL);
  if (a5)
  {
    int v17 = 0;
    unsigned int v23 = 0;
    char v18 = result;
    do
    {
      if (a4)
      {
        uint64_t v9 = 0;
        int v10 = v17;
        do
        {
          float v11 = &result[v10];
          int v25 = 0;
          int v24 = 0;
          ((void (*)(int *, const unsigned __int8 *, void, void, uint64_t, void))v19)(&v25, a1, a4, a5, v9, v23);
          ((void (*)(int *, const unsigned __int8 *, void, void, uint64_t, void))v19)(&v24, a2, a4, a5, v9, v23);
          uint64_t v12 = 0;
          uint64_t v13 = v23 * a4 + v9;
          int v14 = a3[v13] & 0xF;
          do
          {
            v11[v12] = *((unsigned char *)&v25 + v12)
                     + (((*((unsigned __int8 *)&v24 + v12) - *((unsigned __int8 *)&v25 + v12)) * v14) >> 3);
            ++v12;
          }
          while (v12 != 3);
          unsigned int v15 = HIBYTE(v25) + (((HIBYTE(v24) - HIBYTE(v25)) * v14) >> 3);
          if (a3[v13] < 0) {
            LOBYTE(v15) = 0;
          }
          float result = v18;
          v18[(4 * v13) | 3] = v15;
          ++v9;
          v10 += 4;
        }
        while (v9 != a4);
      }
      v17 += 4 * a4;
      ++v23;
    }
    while (v23 != a5);
  }
  return result;
}

uint64_t bilinearUpsample84u(uint64_t result, const unsigned __int8 *a2, unsigned int a3, unsigned int a4, int a5, int a6, double a7, double a8, uint8x8_t a9, uint8x8_t a10, double a11, uint8x8_t a12, double a13, uint8x8_t a14)
{
  uint64_t v14 = 0;
  v23[1] = *MEMORY[0x1E4F143B8];
  unsigned int v15 = ((a5 - 4) & (a3 - 1)) >> 3;
  unsigned int v16 = ((a6 - 2) & (a4 - 1)) >> 2;
  int v17 = v16 % (a4 >> 2) * (a3 >> 3);
  int v18 = v15 % (a3 >> 3);
  unsigned int v19 = (v15 + 1) % (a3 >> 3);
  unsigned int v20 = (v16 + 1) % (a4 >> 2) * (a3 >> 3);
  int32x4_t v21 = vdupq_n_s32((a5 - 4) & 7);
  a9.i32[0] = *(_DWORD *)&a2[4 * (v17 + v18)];
  a10.i32[0] = *(_DWORD *)&a2[4 * v19 + 4 * v17];
  a12.i32[0] = *(_DWORD *)&a2[4 * v20 + 4 * v18];
  a14.i32[0] = *(_DWORD *)&a2[4 * v20 + 4 * v19];
  int32x4_t v22 = vmlaq_s32((int32x4_t)vshll_n_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a9), 3uLL), v21, vshrq_n_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vsubl_u8(a10, a9)), 0x18uLL), 0x18uLL));
  v23[0] = vmovn_s32(vmlaq_s32(vshlq_n_s32(v22, 2uLL), vmlaq_s32(vsubq_s32((int32x4_t)vshll_n_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a12), 3uLL), v22), v21, vshrq_n_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vsubl_u8(a14, a12)), 0x18uLL), 0x18uLL)), vdupq_n_s32((a6 - 2) & 3)));
  do
  {
    *(unsigned char *)(result + v14) = (*((unsigned __int16 *)v23 + v14) >> 7) + (*((unsigned __int16 *)v23 + v14) >> 2);
    ++v14;
  }
  while (v14 != 3);
  *(unsigned char *)(result + 3) = (HIWORD(v23[0]) >> 5) + (HIWORD(v23[0]) >> 1);
  return result;
}

uint64_t bilinearUpsample4u(uint64_t result, const unsigned __int8 *a2, unsigned int a3, unsigned int a4, int a5, int a6, double a7, double a8, uint8x8_t a9, uint8x8_t a10, double a11, uint8x8_t a12, double a13, uint8x8_t a14)
{
  uint64_t v14 = 0;
  v23[1] = *MEMORY[0x1E4F143B8];
  unsigned int v15 = ((a5 - 2) & (a3 - 1)) >> 2;
  unsigned int v16 = ((a6 - 2) & (a4 - 1)) >> 2;
  int v17 = v16 % (a4 >> 2) * (a3 >> 2);
  int v18 = v15 % (a3 >> 2);
  unsigned int v19 = (v15 + 1) % (a3 >> 2);
  unsigned int v20 = (v16 + 1) % (a4 >> 2) * (a3 >> 2);
  int32x4_t v21 = vdupq_n_s32((a5 - 2) & 3);
  a9.i32[0] = *(_DWORD *)&a2[4 * (v17 + v18)];
  a10.i32[0] = *(_DWORD *)&a2[4 * v19 + 4 * v17];
  a12.i32[0] = *(_DWORD *)&a2[4 * v20 + 4 * v18];
  a14.i32[0] = *(_DWORD *)&a2[4 * v20 + 4 * v19];
  int32x4_t v22 = vmlaq_s32((int32x4_t)vshll_n_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a9), 2uLL), v21, vshrq_n_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vsubl_u8(a10, a9)), 0x18uLL), 0x18uLL));
  v23[0] = vmovn_s32(vmlaq_s32(vshlq_n_s32(v22, 2uLL), vmlaq_s32(vsubq_s32((int32x4_t)vshll_n_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a12), 2uLL), v22), v21, vshrq_n_s32(vshlq_n_s32((int32x4_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vsubl_u8(a14, a12)), 0x18uLL), 0x18uLL)), vdupq_n_s32((a6 - 2) & 3)));
  do
  {
    *(unsigned char *)(result + v14) = (*((unsigned __int16 *)v23 + v14) >> 6) + (*((unsigned __int16 *)v23 + v14) >> 1);
    ++v14;
  }
  while (v14 != 3);
  *(unsigned char *)(result + 3) = BYTE6(v23[0]) + (HIWORD(v23[0]) >> 4);
  return result;
}

uint64_t encodePVRTC(void *a1, int8x8_t *a2, unsigned int a3, uint64_t a4, int a5, char a6, char a7)
{
  uint64_t result = 0;
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  unsigned int v58 = 0;
  long long v59 = xmmword_1889AA9E0;
  long long v60 = xmmword_1889AA9D0;
  int8x8_t v10 = a2[2];
  if (*(void *)&v10 == *(void *)&a2[1])
  {
    uint64_t v12 = (unsigned __int8 *)*a2;
    if (a3 == 2 && *(void *)&v10 < 0x10uLL) {
      return 0;
    }
    BOOL v13 = *(void *)&v10 < 8uLL && a3 == 4;
    uint8x8_t v14 = (uint8x8_t)vcnt_s8(v10);
    v14.i16[0] = vaddlv_u8(v14);
    BOOL v15 = v13 || v14.u32[0] > 1uLL;
    if (v15 || v12 == 0)
    {
      return 0;
    }
    else
    {
      int v17 = &v59;
      if (!a5) {
        int v17 = &v60;
      }
      v57[0] = v17;
      v57[1] = a3 & 7 | (8 * (a6 & 1)) & 0xCF | (16 * (a7 & 3));
      unint64_t v18 = 0x10u >> (a3 >> 1);
      if (*(void *)&v10 / v18 <= 1) {
        unint64_t v19 = 1;
      }
      else {
        unint64_t v19 = *(void *)&v10 / v18;
      }
      if (*(void *)&v10 <= 7uLL) {
        unint64_t v20 = 1;
      }
      else {
        unint64_t v20 = *(void *)&v10 >> 2;
      }
      uint64_t v21 = v19 * v18;
      uint64_t v22 = 4 * v20;
      if (v19 * v18 == *(void *)&v10 && v22 == *(void *)&v10)
      {
        int v40 = pvrtcCompress((uint64_t)v57, v12, *(void *)&v10, v10.u32[0], 0, &v58);
      }
      else
      {
        unint64_t v56 = v19;
        int v24 = (char *)malloc_type_malloc(16 * v20 * v21, 0x71F07AD6uLL);
        bzero(v24, 16 * v20 * v21);
        uint64_t v26 = 4 * v21;
        if (a2[1])
        {
          unint64_t v27 = 0;
          int8x8_t v28 = a2[2];
          do
          {
            int v29 = &v24[v26 * v27];
            memcpy(v29, &v12[4 * v27 * *(void *)&v28], 4 * *(void *)&v28);
            int8x8_t v28 = a2[2];
            uint64_t v31 = v21 - *(void *)&v28;
            if (v21 != *(void *)&v28)
            {
              unint64_t v32 = 0;
              do
              {
                uint64_t v33 = 0;
                float v34 = (float)(unint64_t)(v31 + 1);
                float v35 = (float)((float)v32 + 1.0) / v34;
                uint64_t v36 = 4;
                do
                {
                  int8x8_t v37 = a2[2];
                  LOBYTE(v34) = v29[4 * *(void *)&v37 - 4 + v33];
                  float v38 = (float)LODWORD(v34);
                  LOBYTE(v30) = v29[v33];
                  float v30 = (float)LODWORD(v30) - v38;
                  float v34 = (float)(v38 + (float)(v30 * v35)) + 0.5;
                  v29[4 * *(void *)&v37 + 4 * v32 + v33++] = (int)v34;
                  --v36;
                }
                while (v36);
                ++v32;
                int8x8_t v28 = a2[2];
                uint64_t v31 = v21 - *(void *)&v28;
              }
              while (v32 < v21 - *(void *)&v28);
            }
            ++v27;
            int8x8_t v39 = a2[1];
          }
          while (v27 < *(void *)&v39);
        }
        else
        {
          int8x8_t v39 = 0;
        }
        uint64_t v41 = v22 - *(void *)&v39;
        unint64_t v19 = v56;
        if (v22 != *(void *)&v39)
        {
          unint64_t v42 = 0;
          do
          {
            if (v21)
            {
              uint64_t v43 = 0;
              int v44 = &v24[v26 * (*(void *)&v39 + v42)];
              int v45 = &v24[v26 * (*(void *)&v39 + 0x3FFFFFFFFFFFFFFFLL)];
              float v46 = (float)(unint64_t)(v41 + 1);
              float v47 = (float)((float)v42 + 1.0) / v46;
              unint64_t v48 = v24;
              do
              {
                uint64_t v49 = 0;
                uint64_t v50 = 4 * v43;
                do
                {
                  LOBYTE(v46) = v45[v49 + v50];
                  float v51 = (float)LODWORD(v46);
                  LOBYTE(v25) = v48[v49];
                  float v25 = (float)LODWORD(v25) - v51;
                  float v46 = (float)(v51 + (float)(v25 * v47)) + 0.5;
                  v44[v49 + v50] = (int)v46;
                  ++v49;
                }
                while (v49 != 4);
                ++v43;
                v48 += 4;
              }
              while (v43 != v21);
              int8x8_t v39 = a2[1];
            }
            ++v42;
            uint64_t v41 = v22 - *(void *)&v39;
          }
          while (v42 < v22 - *(void *)&v39);
        }
        int v40 = pvrtcCompress((uint64_t)v57, (unsigned __int8 *)v24, v21, 4 * (int)v20, 0, &v58);
        if (v24) {
          free(v24);
        }
      }
      if (v40 && (size_t v52 = v58) != 0 && v58 <= 0x1F)
      {
        uint64_t v53 = malloc_type_malloc(0x20uLL, 0x504FAF6BuLL);
        char v54 = v53;
        if (v19 <= v20)
        {
          for (unint64_t i = 0; i < 0x20; i += v52)
            memcpy((char *)v54 + i, v40, v52);
        }
        else
        {
          void *v53 = *v40;
          v53[1] = *v40;
          v53[2] = v40[8];
          v53[3] = v40[8];
        }
        free(v40);
      }
      else
      {
        char v54 = v40;
      }
      *a1 = v54;
      a1[1] = v22;
      uint64_t result = 1;
      a1[2] = v21;
      a1[3] = 0;
    }
  }
  return result;
}

uint64_t decodePVRTC(vImage_Buffer *a1, const unsigned __int8 *a2, unint64_t a3, int a4, int a5, unsigned int a6, unsigned int a7)
{
  unsigned int v16 = 0;
  int v17 = 0;
  BOOL v15 = 0;
  if (a5) {
    unsigned int v7 = 1;
  }
  else {
    unsigned int v7 = 2;
  }
  if (a4 == 4) {
    char v8 = 2;
  }
  else {
    char v8 = 3;
  }
  if (a4 == 2) {
    char v8 = 1;
  }
  unsigned int v9 = a6 >> v8;
  if (a6 >> v8 <= v7) {
    unsigned int v9 = v7;
  }
  if (a7 >> 2 > v7) {
    unsigned int v7 = a7 >> 2;
  }
  if (!a2) {
    return 0;
  }
  signed int v10 = v9 << v8;
  vImagePixelCount v11 = 4 * v7;
  if ((v11 * a4 * (v9 << v8)) >> 3 > a3) {
    return 0;
  }
  uint8x8_t v14 = pvrtcDecompress(a2, a3, v10, 4 * v7, a4, &v17, &v16, &v15);
  a1->double width = v10;
  a1->size_t rowBytes = 4 * v10;
  a1->data = v14;
  a1->double height = v11;
  if (v17) {
    free(v17);
  }
  if (v16) {
    free(v16);
  }
  if (v15) {
    free(v15);
  }
  return 1;
}

float errorSquared(uint64_t a1, float32x4_t *a2, float32x4_t *a3)
{
  float v3 = *(float32x4_t **)a1;
  if ((*(unsigned char *)(a1 + 8) & 8) != 0)
  {
    uint64_t v7 = 0;
    float v8 = a3->f32[3];
    float v9 = a2->f32[3];
    float v10 = v8 - v9;
    float v11 = -v8;
    float result = 0.0;
    do
    {
      float v12 = (float)((float)(a3->f32[v7] * v11) + (float)(v9 * a2->f32[v7])) * 0.0039216;
      float v13 = v12 * v12;
      float v14 = (float)(v10 + v12) * (float)(v10 + v12);
      if (v13 > v14) {
        float v14 = v13;
      }
      float result = result + (float)((float)(v3->f32[v7] * v3->f32[v7]) * v14);
      ++v7;
    }
    while (v7 != 3);
  }
  else
  {
    float32x4_t v4 = vmulq_f32(vsubq_f32(*a2, *a3), *v3);
    float32x4_t v5 = vmulq_f32(v4, v4);
    return (float)((float)((float)(v5.f32[0] + 0.0) + v5.f32[1]) + v5.f32[2]) + v5.f32[3];
  }
  return result;
}

void findBestQuantizer(uint64_t a1, unsigned int a2, float32x4_t *a3, unsigned char *a4, unsigned char *a5, double a6, float a7, double a8, float a9, float a10)
{
  uint64_t v15 = 0;
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  float v16 = 3.4028e38;
  do
  {
    if ((a2 >> v15))
    {
      float v17 = findBestQuantizer(pvrtc_ctx_t *,unsigned int,float *,unsigned char *,unsigned char *)::quants[v15];
      LOBYTE(a7) = *a5;
      LOBYTE(a9) = *a4;
      *(float *)&unsigned int v18 = (float)(1.0 - v17) * (float)LODWORD(a9);
      *(float *)&unsigned int v19 = *(float *)&v18 + (float)(v17 * (float)LODWORD(a7));
      LOBYTE(v18) = a5[1];
      LOBYTE(a10) = a4[1];
      *(float *)&unsigned int v20 = (float)((float)(1.0 - v17) * (float)LODWORD(a10)) + (float)(v17 * (float)v18);
      v24.i64[0] = __PAIR64__(v20, v19);
      LOBYTE(v19) = a5[2];
      LOBYTE(v20) = a4[2];
      float v21 = (float)(1.0 - v17) * (float)v20;
      v24.f32[2] = v21 + (float)(v17 * (float)v19);
      float v22 = 0.0;
      if (v15 != 5)
      {
        LOBYTE(v22) = a5[3];
        LOBYTE(v21) = a4[3];
        float v22 = (float)((float)(1.0 - v17) * (float)LODWORD(v21)) + (float)(v17 * (float)LODWORD(v22));
      }
      v24.f32[3] = v22;
      float v23 = errorSquared(a1, a3, &v24);
      if (v23 < v16) {
        float v16 = v23;
      }
    }
    ++v15;
  }
  while (v15 != 6);
}

uint64_t IIOGetIndexForType(CFStringRef theString1)
{
  uint64_t v2 = 0;
  while (CFStringCompare(theString1, *(CFStringRef *)(&gUtiInfo)[v2 + 1], 0))
  {
    v2 += 3;
    if (v2 == 228) {
      return 0;
    }
  }
  return *((unsigned __int8 *)&gUtiInfo + 8 * v2 + 20);
}

uint64_t IIOGetIndexForOSType(int a1)
{
  uint64_t v1 = 0;
  while (LODWORD((&gUtiInfo)[v1 + 2]) != a1)
  {
    v1 += 3;
    if ((v1 * 8) == 1824) {
      return 0;
    }
  }
  return *((unsigned __int8 *)&gUtiInfo + 8 * v1 + 20);
}

uint64_t *IIOSetFlagAtIndex(uint64_t *result, unsigned int a2)
{
  if (a2 == -1)
  {
    uint64_t v3 = -1;
  }
  else
  {
    if (a2 >= 0x40) {
      char v2 = 64;
    }
    else {
      char v2 = a2;
    }
    uint64_t v3 = *result | (1 << v2);
  }
  *float result = v3;
  return result;
}

uint64_t IIOFlagsSupportType(unint64_t a1, int a2)
{
  uint64_t v3 = 0;
  while (LODWORD((&gUtiInfo)[v3 + 2]) != a2)
  {
    v3 += 3;
    if ((v3 * 8) == 1824) {
      return 0;
    }
  }
  uint64_t v4 = 0;
  float32x4_t v5 = (&gUtiInfo)[v3];
  char v6 = 1;
  while (1)
  {
    size_t v7 = strlen((&gUtiInfo)[v4]);
    if (!strncmp(v5, (&gUtiInfo)[v4], v7) && ((a1 >> v6) & 1) != 0) {
      break;
    }
    char v6 = *((unsigned char *)&gUtiInfo + 8 * v4 + 44);
    v4 += 3;
    if (v4 == 228) {
      return 0;
    }
  }
  return 1;
}

_OWORD *jinit_arith_encoder(uint64_t a1)
{
  uint64_t v2 = (**(uint64_t (***)(void))(a1 + 8))();
  *(void *)(a1 + 560) = v2;
  *(void *)uint64_t v2 = start_pass_1;
  *(void *)(v2 + 16) = finish_pass_0;
  *(_OWORD *)(v2 + 248) = 0u;
  *(_OWORD *)(v2 + 232) = 0u;
  *(_OWORD *)(v2 + 216) = 0u;
  *(_OWORD *)(v2 + 200) = 0u;
  *(_OWORD *)(v2 + 184) = 0u;
  *(_OWORD *)(v2 + 168) = 0u;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_OWORD *)(v2 + 136) = 0u;
  *(_OWORD *)(v2 + 120) = 0u;
  *(unsigned char *)(v2 + 360) = 113;
  *(_OWORD *)(v2 + 104) = 0u;
  float result = (_OWORD *)(v2 + 104);
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  return result;
}

double start_pass_1(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 560);
  if (a2)
  {
    uint64_t v4 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v4 + 10) = 49;
    (*v4)(a1);
  }
  if (*(_DWORD *)(a1 + 348))
  {
    int v5 = *(_DWORD *)(a1 + 460);
    if (*(_DWORD *)(a1 + 468))
    {
      if (v5) {
        char v6 = encode_mcu_AC_refine_0;
      }
      else {
        char v6 = encode_mcu_DC_refine_0;
      }
    }
    else if (v5)
    {
      char v6 = encode_mcu_AC_first_0;
    }
    else
    {
      char v6 = encode_mcu_DC_first_0;
    }
  }
  else
  {
    char v6 = encode_mcu;
  }
  *(void *)(v3 + 8) = v6;
  if (*(int *)(a1 + 372) >= 1)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = *(void *)(a1 + 8 * v7 + 376);
      if (!*(_DWORD *)(a1 + 460) && !*(_DWORD *)(a1 + 468))
      {
        unsigned int v9 = *(_DWORD *)(v8 + 20);
        if (v9 >= 0x10)
        {
          float v10 = *(void (***)(uint64_t))a1;
          *((_DWORD *)v10 + 10) = 50;
          *((_DWORD *)v10 + 12) = v9;
          (**(void (***)(uint64_t))a1)(a1);
        }
        uint64_t v11 = v3 + 8 * (int)v9;
        float v14 = *(_OWORD **)(v11 + 104);
        float v13 = (void *)(v11 + 104);
        float v12 = v14;
        if (!v14)
        {
          float v12 = (_OWORD *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 64);
          *float v13 = v12;
        }
        void v12[2] = 0u;
        void v12[3] = 0u;
        *float v12 = 0u;
        v12[1] = 0u;
        uint64_t v15 = v3 + 4 * v7;
        *(_DWORD *)(v15 + 64) = 0;
        *(_DWORD *)(v15 + 80) = 0;
      }
      if (*(_DWORD *)(a1 + 464))
      {
        unsigned int v16 = *(_DWORD *)(v8 + 24);
        if (v16 >= 0x10)
        {
          float v17 = *(void (***)(uint64_t))a1;
          *((_DWORD *)v17 + 10) = 50;
          *((_DWORD *)v17 + 12) = v16;
          (**(void (***)(uint64_t))a1)(a1);
        }
        uint64_t v18 = v3 + 8 * (int)v16;
        float v21 = *(_OWORD **)(v18 + 232);
        unsigned int v20 = (void *)(v18 + 232);
        unsigned int v19 = v21;
        if (!v21)
        {
          unsigned int v19 = (_OWORD *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 256);
          void *v20 = v19;
        }
        v19[14] = 0u;
        v19[15] = 0u;
        v19[12] = 0u;
        v19[13] = 0u;
        v19[10] = 0u;
        v19[11] = 0u;
        UInt8 v19[8] = 0u;
        v19[9] = 0u;
        v19[6] = 0u;
        v19[7] = 0u;
        v19[4] = 0u;
        v19[5] = 0u;
        v19[2] = 0u;
        void v19[3] = 0u;
        *unsigned int v19 = 0u;
        v19[1] = 0u;
      }
      ++v7;
    }
    while (v7 < *(int *)(a1 + 372));
  }
  *(_OWORD *)(v3 + 24) = xmmword_1889AAC80;
  *(void *)(v3 + 40) = 0;
  *(void *)(v3 + 48) = 0;
  double result = NAN;
  *(void *)(v3 + 56) = -4294967285;
  *(void *)(v3 + 96) = *(unsigned int *)(a1 + 316);
  return result;
}

uint64_t finish_pass_0(uint64_t *a1)
{
  uint64_t v2 = a1[70];
  uint64_t v3 = *(void *)(v2 + 24);
  uint64_t v4 = (*(_DWORD *)(v2 + 32) + v3 - 1) & 0xFFFF0000;
  if (v4 < v3) {
    v4 |= 0x8000uLL;
  }
  uint64_t result = *(unsigned int *)(v2 + 60);
  uint64_t v6 = v4 << *(_DWORD *)(v2 + 56);
  *(void *)(v2 + 24) = v6;
  if ((v6 & 0xF8000000) != 0)
  {
    if ((result & 0x80000000) == 0)
    {
      if (*(void *)(v2 + 48))
      {
        do
        {
          emit_byte_0(0, a1);
          uint64_t v7 = *(void *)(v2 + 48) - 1;
          *(void *)(v2 + 48) = v7;
        }
        while (v7);
        LODWORD(result) = *(_DWORD *)(v2 + 60);
      }
      uint64_t result = emit_byte_0((result + 1), a1);
      if (*(_DWORD *)(v2 + 60) == 254) {
        uint64_t result = emit_byte_0(0, a1);
      }
    }
    uint64_t v8 = *(void *)(v2 + 48) + *(void *)(v2 + 40);
    *(void *)(v2 + 40) = 0;
    *(void *)(v2 + 48) = v8;
  }
  else
  {
    if (result)
    {
      if ((result & 0x80000000) == 0)
      {
        if (*(void *)(v2 + 48))
        {
          do
          {
            emit_byte_0(0, a1);
            uint64_t v9 = *(void *)(v2 + 48) - 1;
            *(void *)(v2 + 48) = v9;
          }
          while (v9);
          uint64_t result = *(unsigned int *)(v2 + 60);
        }
        uint64_t result = emit_byte_0(result, a1);
      }
    }
    else
    {
      ++*(void *)(v2 + 48);
    }
    if (*(void *)(v2 + 40))
    {
      if (*(void *)(v2 + 48))
      {
        do
        {
          emit_byte_0(0, a1);
          uint64_t v10 = *(void *)(v2 + 48) - 1;
          *(void *)(v2 + 48) = v10;
        }
        while (v10);
      }
      do
      {
        emit_byte_0(255, a1);
        uint64_t result = emit_byte_0(0, a1);
        uint64_t v11 = *(void *)(v2 + 40) - 1;
        *(void *)(v2 + 40) = v11;
      }
      while (v11);
    }
  }
  uint64_t v12 = *(void *)(v2 + 24);
  if ((v12 & 0x7FFF800) != 0)
  {
    if (*(void *)(v2 + 48))
    {
      do
      {
        emit_byte_0(0, a1);
        uint64_t v13 = *(void *)(v2 + 48) - 1;
        *(void *)(v2 + 48) = v13;
      }
      while (v13);
      uint64_t v12 = *(void *)(v2 + 24);
    }
    uint64_t result = emit_byte_0((v12 >> 19), a1);
    uint64_t v14 = *(void *)(v2 + 24);
    if ((~*(_DWORD *)(v2 + 24) & 0x7F80000) == 0)
    {
      uint64_t result = emit_byte_0(0, a1);
      uint64_t v14 = *(void *)(v2 + 24);
    }
    if ((v14 & 0x7F800) != 0)
    {
      uint64_t result = emit_byte_0((v14 >> 11), a1);
      if ((~*(_DWORD *)(v2 + 24) & 0x7F800) == 0)
      {
        return emit_byte_0(0, a1);
      }
    }
  }
  return result;
}

uint64_t encode_mcu_DC_first_0(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 560);
  if (*(_DWORD *)(a1 + 316))
  {
    int v4 = *(_DWORD *)(v3 + 96);
    if (!v4)
    {
      emit_restart(a1, *(_DWORD *)(v3 + 100));
      int v4 = *(_DWORD *)(a1 + 316);
      *(_DWORD *)(v3 + 100) = (*(_DWORD *)(v3 + 100) + 1) & 7;
    }
    *(_DWORD *)(v3 + 96) = v4 - 1;
  }
  if (*(int *)(a1 + 416) >= 1)
  {
    uint64_t v5 = 0;
    while (1)
    {
      uint64_t v6 = *(int *)(a1 + 4 * v5 + 420);
      uint64_t v7 = *(int *)(*(void *)(a1 + 8 * v6 + 376) + 20);
      uint64_t v8 = v3 + 8 * v7;
      uint64_t v11 = *(void *)(v8 + 104);
      uint64_t v10 = (void *)(v8 + 104);
      uint64_t v9 = v11;
      uint64_t v12 = v3 + 4 * v6;
      LODWORD(v11) = *(_DWORD *)(v12 + 64);
      uint64_t v13 = (int *)(v12 + 64);
      int v14 = **(__int16 **)(a2 + 8 * v5) >> *(_DWORD *)(a1 + 472);
      uint64_t v15 = v13 + 4;
      unsigned int v16 = (unsigned char *)(v9 + v13[4]);
      int v17 = v14 - v11;
      if (v14 != v11) {
        break;
      }
      arith_encode(a1, (unsigned char *)(v9 + v13[4]), 0);
      *uint64_t v15 = 0;
LABEL_30:
      if (++v5 >= *(int *)(a1 + 416)) {
        return 1;
      }
    }
    *uint64_t v13 = v14;
    arith_encode(a1, v16, 1);
    BOOL v18 = v17 <= 0;
    if (v17 <= 0) {
      uint64_t v19 = 3;
    }
    else {
      uint64_t v19 = 2;
    }
    if (v17 <= 0) {
      int v20 = 8;
    }
    else {
      int v20 = 4;
    }
    if (v17 <= 0) {
      int v17 = -v17;
    }
    arith_encode(a1, v16 + 1, v18);
    float v21 = &v16[v19];
    *uint64_t v15 = v20;
    unsigned int v22 = v17 - 1;
    if (v22)
    {
      int v23 = 1;
      arith_encode(a1, v21, 1);
      float v21 = (unsigned char *)(*v10 + 20);
      if (v22 != 1)
      {
        unsigned int v24 = v22;
        do
        {
          arith_encode(a1, v21, 1);
          v23 *= 2;
          ++v21;
          BOOL v25 = v24 > 3;
          v24 >>= 1;
        }
        while (v25);
      }
    }
    else
    {
      int v23 = 0;
    }
    arith_encode(a1, v21, 0);
    int v26 = 0;
    if (v23 >= (int)((unint64_t)(1 << *(unsigned char *)(a1 + v7 + 224)) >> 1))
    {
      if (v23 <= (int)((unint64_t)(1 << *(unsigned char *)(a1 + v7 + 240)) >> 1)) {
        goto LABEL_27;
      }
      int v26 = *v15 + 8;
    }
    *uint64_t v15 = v26;
LABEL_27:
    if (v23 >= 2)
    {
      unint64_t v27 = v21 + 14;
      do
      {
        arith_encode(a1, v27, (v22 & (v23 >> 1)) != 0);
        BOOL v25 = v23 > 3;
        v23 >>= 1;
      }
      while (v25);
    }
    goto LABEL_30;
  }
  return 1;
}

uint64_t encode_mcu_AC_first_0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 560);
  if (*(_DWORD *)(a1 + 316))
  {
    int v5 = *(_DWORD *)(v4 + 96);
    if (!v5)
    {
      emit_restart(a1, *(_DWORD *)(v4 + 100));
      int v5 = *(_DWORD *)(a1 + 316);
      *(_DWORD *)(v4 + 100) = (*(_DWORD *)(v4 + 100) + 1) & 7;
    }
    *(_DWORD *)(v4 + 96) = v5 - 1;
  }
  uint64_t v6 = 0;
  uint64_t v7 = *(void *)(a1 + 480);
  uint64_t v8 = *a2;
  uint64_t v9 = *(int *)(*(void *)(a1 + 376) + 24);
  uint64_t v10 = *(int *)(a1 + 464);
  int v11 = *(_DWORD *)(a1 + 464);
  uint64_t v12 = v7 + 4 * v10;
  int v13 = v10 - 1;
  while (1)
  {
    unsigned int v14 = *(__int16 *)(v8 + 2 * *(int *)(v12 + 4 * v6));
    if ((v14 & 0x80000000) != 0) {
      unsigned int v14 = -v14;
    }
    if (v14 >> *(_DWORD *)(a1 + 472)) {
      break;
    }
    if (!(v13 + v6--))
    {
      int v16 = 0;
      goto LABEL_12;
    }
  }
  int v16 = v11 + v6;
LABEL_12:
  int v17 = *(_DWORD *)(a1 + 460);
  int v18 = v17 - 1;
  if (v17 > v16) {
    goto LABEL_35;
  }
  uint64_t v19 = (uint64_t *)(v4 + 8 * v9 + 232);
  uint64_t v38 = *(int *)(*(void *)(a1 + 376) + 24);
  uint64_t v39 = v4;
  int v40 = (unsigned __int8 *)(a1 + v9 + 256);
  uint64_t v41 = v7 + 4;
  unint64_t v42 = (unsigned char *)(v4 + 360);
  do
  {
    int v20 = (unsigned char *)(*v19 + 3 * v18);
    arith_encode(a1, v20, 0);
    float v21 = (int *)(v41 + 4 * v18);
    unsigned int v22 = v20 + 1;
    for (int i = v18; ; ++i)
    {
      uint64_t v24 = *v21++;
      unsigned int v25 = *(__int16 *)(v8 + 2 * v24);
      if ((v25 & 0x80000000) != 0) {
        break;
      }
      unsigned int v26 = v25 >> *(_DWORD *)(a1 + 472);
      if (v26)
      {
        int v27 = 0;
        goto LABEL_21;
      }
LABEL_19:
      arith_encode(a1, v22, 0);
      v22 += 3;
    }
    unsigned int v26 = -v25 >> *(_DWORD *)(a1 + 472);
    if (!v26) {
      goto LABEL_19;
    }
    int v27 = 1;
LABEL_21:
    arith_encode(a1, v22, 1);
    arith_encode(a1, v42, v27);
    int8x8_t v28 = v22 + 1;
    unsigned int v29 = v26 - 1;
    if (v26 == 1 || (arith_encode(a1, v28, 1), v26 == 2))
    {
      arith_encode(a1, v28, 0);
      goto LABEL_33;
    }
    arith_encode(a1, v28, 1);
    uint64_t v30 = *v19;
    uint64_t v31 = 217;
    if (i < *v40) {
      uint64_t v31 = 189;
    }
    unint64_t v32 = (unsigned char *)(v30 + v31);
    if (v26 >= 5)
    {
      int v34 = 2;
      unsigned int v35 = v29;
      do
      {
        arith_encode(a1, v32, 1);
        v34 *= 2;
        ++v32;
        BOOL v36 = v35 >= 8;
        v35 >>= 1;
      }
      while (v36);
      arith_encode(a1, v32, 0);
      if (v34)
      {
        uint64_t v33 = v32 + 14;
        goto LABEL_32;
      }
    }
    else
    {
      arith_encode(a1, (unsigned char *)(v30 + v31), 0);
      uint64_t v33 = v32 + 14;
      int v34 = 2;
      do
      {
LABEL_32:
        arith_encode(a1, v33, (v29 & (v34 >> 1)) != 0);
        BOOL v36 = v34 >= 4;
        v34 >>= 1;
      }
      while (v36);
    }
LABEL_33:
    int v18 = i + 1;
  }
  while (v16 > i + 1);
  int v11 = *(_DWORD *)(a1 + 464);
  int v18 = i + 1;
  uint64_t v9 = v38;
  uint64_t v4 = v39;
LABEL_35:
  if (v18 < v11) {
    arith_encode(a1, (unsigned char *)(*(void *)(v4 + 8 * v9 + 232) + 3 * v18), 1);
  }
  return 1;
}

uint64_t encode_mcu_DC_refine_0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 560);
  if (*(_DWORD *)(a1 + 316))
  {
    int v5 = *(_DWORD *)(v4 + 96);
    if (!v5)
    {
      emit_restart(a1, *(_DWORD *)(v4 + 100));
      int v5 = *(_DWORD *)(a1 + 316);
      *(_DWORD *)(v4 + 100) = (*(_DWORD *)(v4 + 100) + 1) & 7;
    }
    *(_DWORD *)(v4 + 96) = v5 - 1;
  }
  if (*(int *)(a1 + 416) >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = (unsigned char *)(v4 + 360);
    int v8 = *(_DWORD *)(a1 + 472);
    do
      arith_encode(a1, v7, (**(__int16 **)(a2 + 8 * v6++) >> v8) & 1);
    while (v6 < *(int *)(a1 + 416));
  }
  return 1;
}

uint64_t encode_mcu_AC_refine_0(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 560);
  if (*(_DWORD *)(a1 + 316))
  {
    int v5 = *(_DWORD *)(v4 + 96);
    if (!v5)
    {
      emit_restart(a1, *(_DWORD *)(v4 + 100));
      int v5 = *(_DWORD *)(a1 + 316);
      *(_DWORD *)(v4 + 100) = (*(_DWORD *)(v4 + 100) + 1) & 7;
    }
    *(_DWORD *)(v4 + 96) = v5 - 1;
  }
  uint64_t v6 = 0;
  uint64_t v7 = *(void *)(a1 + 480);
  uint64_t v8 = *a2;
  uint64_t v9 = *(int *)(*(void *)(a1 + 376) + 24);
  uint64_t v10 = *(int *)(a1 + 464);
  int v11 = *(_DWORD *)(a1 + 464);
  while (1)
  {
    unsigned int v12 = *(__int16 *)(v8 + 2 * *(int *)(v7 + 4 * v10 + 4 * v6));
    if ((v12 & 0x80000000) != 0) {
      unsigned int v12 = -v12;
    }
    if (v12 >> *(_DWORD *)(a1 + 472)) {
      break;
    }
    int v13 = v10 + v6--;
    if (v13 == 1)
    {
      int v14 = 0;
LABEL_18:
      LODWORD(v15) = 0;
      goto LABEL_20;
    }
  }
  int v14 = v11 + v6;
  if (v11 + (int)v6 <= 0)
  {
    LODWORD(v15) = v11 + v6;
  }
  else
  {
    uint64_t v15 = (v10 + v6);
    while (1)
    {
      unsigned int v16 = *(__int16 *)(v8 + 2 * *(int *)(v7 + 4 * v15));
      if ((v16 & 0x80000000) != 0) {
        unsigned int v16 = -v16;
      }
      if (v16 >> *(_DWORD *)(a1 + 468)) {
        break;
      }
      if (v15-- <= 1) {
        goto LABEL_18;
      }
    }
  }
LABEL_20:
  int v18 = *(_DWORD *)(a1 + 460);
  int v19 = v18 - 1;
  if (v18 > v14) {
    goto LABEL_37;
  }
  uint64_t v35 = *(int *)(*(void *)(a1 + 376) + 24);
  uint64_t v36 = v4;
  int v20 = (uint64_t *)(v4 + 8 * v9 + 232);
  float v21 = (unsigned char *)(v4 + 360);
  uint64_t v22 = v7 + 4;
  do
  {
    uint64_t v23 = *v20;
    int v24 = 3 * v19;
    if (v19 >= (int)v15) {
      arith_encode(a1, (unsigned char *)(v23 + v24), 0);
    }
    uint64_t v25 = v24;
    unsigned int v26 = (int *)(v22 + 4 * v19++);
    for (int i = (unsigned char *)(v23 + v25 + 1); ; i += 3)
    {
      uint64_t v28 = *v26++;
      unsigned int v29 = *(__int16 *)(v8 + 2 * v28);
      if ((v29 & 0x80000000) != 0) {
        break;
      }
      unsigned int v30 = v29 >> *(_DWORD *)(a1 + 472);
      if (v30)
      {
        if (v30 == 1)
        {
          arith_encode(a1, i, 1);
          uint64_t v31 = a1;
          unint64_t v32 = v21;
          int v33 = 0;
          goto LABEL_35;
        }
        goto LABEL_34;
      }
LABEL_29:
      arith_encode(a1, i, 0);
      ++v19;
    }
    unsigned int v30 = -v29 >> *(_DWORD *)(a1 + 472);
    if (!v30) {
      goto LABEL_29;
    }
    if (v30 == 1)
    {
      arith_encode(a1, i, 1);
      uint64_t v31 = a1;
      unint64_t v32 = v21;
      int v33 = 1;
      goto LABEL_35;
    }
LABEL_34:
    unint64_t v32 = i + 1;
    int v33 = v30 & 1;
    uint64_t v31 = a1;
LABEL_35:
    arith_encode(v31, v32, v33);
  }
  while (v14 > v19);
  int v11 = *(_DWORD *)(a1 + 464);
  uint64_t v9 = v35;
  uint64_t v4 = v36;
LABEL_37:
  if (v19 < v11) {
    arith_encode(a1, (unsigned char *)(*(void *)(v4 + 8 * v9 + 232) + 3 * v19), 1);
  }
  return 1;
}

uint64_t encode_mcu(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 560);
  if (*(_DWORD *)(a1 + 316))
  {
    int v4 = *(_DWORD *)(v3 + 96);
    if (!v4)
    {
      emit_restart(a1, *(_DWORD *)(v3 + 100));
      int v4 = *(_DWORD *)(a1 + 316);
      *(_DWORD *)(v3 + 100) = (*(_DWORD *)(v3 + 100) + 1) & 7;
    }
    *(_DWORD *)(v3 + 96) = v4 - 1;
  }
  if (*(int *)(a1 + 416) < 1) {
    return 1;
  }
  uint64_t v5 = 0;
  uint64_t v58 = *(void *)(a1 + 480);
  do
  {
    uint64_t v6 = *(__int16 **)(a2 + 8 * v5);
    uint64_t v7 = *(int *)(a1 + 4 * v5 + 420);
    uint64_t v8 = *(void *)(a1 + 8 * v7 + 376);
    uint64_t v9 = *(int *)(v8 + 20);
    uint64_t v10 = v3 + 8 * v9;
    uint64_t v13 = *(void *)(v10 + 104);
    unsigned int v12 = (void *)(v10 + 104);
    uint64_t v11 = v13;
    uint64_t v14 = v3 + 4 * v7;
    LODWORD(v13) = *(_DWORD *)(v14 + 64);
    uint64_t v15 = (_DWORD *)(v14 + 64);
    unsigned int v16 = v15 + 4;
    int v17 = (unsigned char *)(v11 + (int)v15[4]);
    int v18 = *v6;
    int v19 = v18 - v13;
    uint64_t v54 = v5;
    uint64_t v56 = v8;
    if (v18 == v13)
    {
      arith_encode(a1, v17, 0);
      *unsigned int v16 = 0;
      goto LABEL_30;
    }
    *uint64_t v15 = v18;
    arith_encode(a1, v17, 1);
    BOOL v20 = v19 <= 0;
    if (v19 <= 0) {
      uint64_t v21 = 3;
    }
    else {
      uint64_t v21 = 2;
    }
    if (v19 <= 0) {
      int v22 = 8;
    }
    else {
      int v22 = 4;
    }
    if (v19 <= 0) {
      int v19 = -v19;
    }
    arith_encode(a1, v17 + 1, v20);
    uint64_t v23 = &v17[v21];
    *unsigned int v16 = v22;
    if (v19 == 1)
    {
      int v24 = 0;
    }
    else
    {
      int v24 = 1;
      arith_encode(a1, v23, 1);
      uint64_t v23 = (unsigned char *)(*v12 + 20);
      if (v19 != 2)
      {
        unsigned int v25 = v19 - 1;
        do
        {
          arith_encode(a1, v23, 1);
          v24 *= 2;
          ++v23;
          BOOL v26 = v25 > 3;
          v25 >>= 1;
        }
        while (v26);
      }
    }
    arith_encode(a1, v23, 0);
    int v27 = 0;
    if (v24 >= (int)((unint64_t)(1 << *(unsigned char *)(a1 + v9 + 224)) >> 1))
    {
      if (v24 <= (int)((unint64_t)(1 << *(unsigned char *)(a1 + v9 + 240)) >> 1)) {
        goto LABEL_27;
      }
      int v27 = *v16 + 8;
    }
    *unsigned int v16 = v27;
LABEL_27:
    if (v24 >= 2)
    {
      uint64_t v28 = v23 + 14;
      do
      {
        arith_encode(a1, v28, ((v19 - 1) & (v24 >> 1)) != 0);
        BOOL v26 = v24 > 3;
        v24 >>= 1;
      }
      while (v26);
    }
LABEL_30:
    int v29 = *(_DWORD *)(a1 + 488);
    unsigned int v30 = (unsigned char *)(v3 + 360);
    if (!v29) {
      goto LABEL_62;
    }
    uint64_t v31 = 0;
    uint64_t v32 = *(int *)(v56 + 24);
    while (!v6[*(int *)(v58 + 4 * v29 + 4 * v31)])
    {
      if (!(v29 - 1 + v31--)) {
        goto LABEL_59;
      }
    }
    if (v29 + (int)v31 <= 0)
    {
LABEL_59:
      int v34 = 0;
      goto LABEL_60;
    }
    int v34 = 0;
    int v57 = v29 + v31;
    uint64_t v35 = (uint64_t *)(v3 + 8 * v32 + 232);
    uint64_t v52 = v32;
    unint64_t v55 = (unsigned __int8 *)(a1 + v32 + 256);
    do
    {
      uint64_t v36 = (unsigned char *)(*v35 + 3 * v34);
      arith_encode(a1, v36, 0);
      LOWORD(v37) = v6[*(int *)(v58 + 4 * (v34 + 1))];
      if ((_WORD)v37)
      {
        int v38 = v34++;
      }
      else
      {
        uint64_t v39 = (int *)(v58 + 4 + 4 * (v34 + 1));
        do
        {
          arith_encode(a1, v36 + 1, 0);
          v36 += 3;
          uint64_t v40 = *v39++;
          LOWORD(v37) = v6[v40];
          ++v34;
        }
        while (!(_WORD)v37);
        int v38 = v34++;
      }
      arith_encode(a1, v36 + 1, 1);
      BOOL v41 = (__int16)v37 < 1;
      if ((v37 & 0x8000u) == 0) {
        int v37 = (__int16)v37;
      }
      else {
        int v37 = -(__int16)v37;
      }
      arith_encode(a1, v30, v41);
      unint64_t v42 = v36 + 2;
      unsigned int v43 = v37 - 1;
      if (v37 == 1 || (arith_encode(a1, v42, 1), v37 == 2))
      {
        arith_encode(a1, v42, 0);
        continue;
      }
      arith_encode(a1, v42, 1);
      uint64_t v44 = *v35;
      uint64_t v45 = 217;
      if (v38 < *v55) {
        uint64_t v45 = 189;
      }
      float v46 = (unsigned char *)(v44 + v45);
      if (v43 < 4)
      {
        arith_encode(a1, (unsigned char *)(v44 + v45), 0);
        float v47 = v46 + 14;
        int v48 = 2;
        goto LABEL_56;
      }
      int v48 = 2;
      int v49 = v37 - 1;
      do
      {
        arith_encode(a1, v46, 1);
        v48 *= 2;
        ++v46;
        BOOL v50 = v49 >= 8;
        v49 >>= 1;
      }
      while (v50);
      arith_encode(a1, v46, 0);
      unsigned int v30 = (unsigned char *)(v3 + 360);
      if (v48)
      {
        float v47 = v46 + 14;
        do
        {
LABEL_56:
          arith_encode(a1, v47, (v43 & (v48 >> 1)) != 0);
          BOOL v50 = v48 >= 4;
          v48 >>= 1;
        }
        while (v50);
      }
    }
    while (v34 < v57);
    int v29 = *(_DWORD *)(a1 + 488);
    uint64_t v32 = v52;
LABEL_60:
    if (v34 < v29) {
      arith_encode(a1, (unsigned char *)(*(void *)(v3 + 8 * v32 + 232) + 3 * v34), 1);
    }
LABEL_62:
    uint64_t v5 = v54 + 1;
  }
  while (v54 + 1 < *(int *)(a1 + 416));
  return 1;
}

double emit_restart(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 560);
  finish_pass_0((uint64_t *)a1);
  emit_byte_0(255, (uint64_t *)a1);
  emit_byte_0((a2 + 208), (uint64_t *)a1);
  if (*(int *)(a1 + 372) >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = *(void *)(a1 + 376 + 8 * v5);
      if (!*(_DWORD *)(a1 + 460) && !*(_DWORD *)(a1 + 468))
      {
        uint64_t v7 = *(_OWORD **)(v4 + 8 * *(int *)(v6 + 20) + 104);
        _OWORD v7[2] = 0uLL;
        void v7[3] = 0uLL;
        *uint64_t v7 = 0uLL;
        v7[1] = 0uLL;
        uint64_t v8 = v4 + 4 * v5;
        *(_DWORD *)(v8 + 64) = 0;
        *(_DWORD *)(v8 + 80) = 0;
      }
      if (*(_DWORD *)(a1 + 464))
      {
        uint64_t v9 = *(_OWORD **)(v4 + 8 * *(int *)(v6 + 24) + 232);
        v9[14] = 0uLL;
        v9[15] = 0uLL;
        v9[12] = 0uLL;
        v9[13] = 0uLL;
        v9[10] = 0uLL;
        v9[11] = 0uLL;
        unsigned char v9[8] = 0uLL;
        v9[9] = 0uLL;
        v9[6] = 0uLL;
        v9[7] = 0uLL;
        v9[4] = 0uLL;
        v9[5] = 0uLL;
        void v9[2] = 0uLL;
        void v9[3] = 0uLL;
        *uint64_t v9 = 0uLL;
        v9[1] = 0uLL;
      }
      ++v5;
    }
    while (v5 < *(int *)(a1 + 372));
  }
  *(_OWORD *)(v4 + 24) = xmmword_1889AAC80;
  *(void *)(v4 + 40) = 0;
  *(void *)(v4 + 48) = 0;
  double result = NAN;
  *(void *)(v4 + 56) = -4294967285;
  return result;
}

uint64_t arith_encode(uint64_t result, unsigned char *a2, int a3)
{
  uint64_t v3 = (uint64_t *)result;
  unsigned int v4 = *a2;
  uint64_t v5 = jpeg_aritab[v4 & 0x7F];
  uint64_t v6 = *(void *)(result + 560);
  uint64_t v7 = v5 >> 16;
  uint64_t v8 = *(void *)(v6 + 32) - (v5 >> 16);
  *(void *)(v6 + 32) = v8;
  if (a3 != v4 >> 7)
  {
    if (v8 >= v7)
    {
      *(void *)(v6 + 24) += v8;
      *(void *)(v6 + 32) = v7;
    }
    char v10 = v5 ^ v4 & 0x80;
    goto LABEL_9;
  }
  if (v8 < 0x8000)
  {
    unsigned int v9 = v5 >> 8;
    if (v8 < v7)
    {
      *(void *)(v6 + 24) += v8;
      *(void *)(v6 + 32) = v7;
    }
    char v10 = v9 ^ v4 & 0x80;
LABEL_9:
    *a2 = v10;
    uint64_t v12 = *(void *)(v6 + 24);
    uint64_t v11 = *(void *)(v6 + 32);
    int v13 = *(_DWORD *)(v6 + 56);
    while (1)
    {
      v11 *= 2;
      v12 *= 2;
      *(void *)(v6 + 24) = v12;
      *(void *)(v6 + 32) = v11;
      *(_DWORD *)(v6 + 56) = --v13;
      if (!v13) {
        break;
      }
LABEL_34:
      if (v11 >= 0x8000) {
        return result;
      }
    }
    if (v12 < 0x8000000)
    {
      if (v12 >> 19 == 255)
      {
        ++*(void *)(v6 + 40);
LABEL_33:
        uint64_t v11 = *(void *)(v6 + 32);
        uint64_t v12 = *(void *)(v6 + 24) & 0x7FFFFLL;
        *(void *)(v6 + 24) = v12;
        int v13 = *(_DWORD *)(v6 + 56) + 8;
        *(_DWORD *)(v6 + 56) = v13;
        goto LABEL_34;
      }
      double result = *(unsigned int *)(v6 + 60);
      if (result)
      {
        if ((result & 0x80000000) == 0)
        {
          if (*(void *)(v6 + 48))
          {
            do
            {
              emit_byte_0(0, v3);
              uint64_t v17 = *(void *)(v6 + 48) - 1;
              *(void *)(v6 + 48) = v17;
            }
            while (v17);
            double result = *(unsigned int *)(v6 + 60);
          }
          double result = emit_byte_0(result, v3);
        }
      }
      else
      {
        ++*(void *)(v6 + 48);
      }
      if (*(void *)(v6 + 40))
      {
        if (*(void *)(v6 + 48))
        {
          do
          {
            emit_byte_0(0, v3);
            uint64_t v18 = *(void *)(v6 + 48) - 1;
            *(void *)(v6 + 48) = v18;
          }
          while (v18);
        }
        do
        {
          emit_byte_0(255, v3);
          double result = emit_byte_0(0, v3);
          uint64_t v19 = *(void *)(v6 + 40) - 1;
          *(void *)(v6 + 40) = v19;
        }
        while (v19);
      }
    }
    else
    {
      int v14 = *(_DWORD *)(v6 + 60);
      if ((v14 & 0x80000000) == 0)
      {
        if (*(void *)(v6 + 48))
        {
          do
          {
            emit_byte_0(0, v3);
            uint64_t v15 = *(void *)(v6 + 48) - 1;
            *(void *)(v6 + 48) = v15;
          }
          while (v15);
          int v14 = *(_DWORD *)(v6 + 60);
        }
        double result = emit_byte_0((v14 + 1), v3);
        if (*(_DWORD *)(v6 + 60) == 254) {
          double result = emit_byte_0(0, v3);
        }
      }
      uint64_t v16 = *(void *)(v6 + 48) + *(void *)(v6 + 40);
      *(void *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = v16;
    }
    *(_DWORD *)(v6 + 60) = (v12 >> 19);
    goto LABEL_33;
  }
  return result;
}

uint64_t emit_byte_0(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = a2[5];
  uint64_t v3 = (unsigned char *)(*(void *)v2)++;
  *uint64_t v3 = result;
  uint64_t v4 = *(void *)(v2 + 8) - 1;
  *(void *)(v2 + 8) = v4;
  if (!v4)
  {
    double result = (*(uint64_t (**)(uint64_t *))(v2 + 24))(a2);
    if (!result)
    {
      uint64_t v6 = *a2;
      *(_DWORD *)(v6 + 40) = 25;
      uint64_t v7 = *(uint64_t (**)(uint64_t *))v6;
      return v7(a2);
    }
  }
  return result;
}

void ETCTextureImp::~ETCTextureImp(ETCTextureImp *this, uint64_t a2, const char *a3)
{
  *(void *)this = &unk_1ED4DF8A0;
  if (*((void *)this + 3))
  {
    uint64_t Source = (IIOImageRead **)CGImageSourceGetSource(*((void *)this + 4));
    if (Source) {
      IIOImageReadSession::releaseBytePointer(Source, *((void **)this + 3));
    }
  }
  uint64_t v5 = (const void *)*((void *)this + 4);
  if (v5) {
    CFRelease(v5);
  }
  *((void *)this + 4) = 0;

  _cg_jpeg_mem_term(this, a2, a3);
}

{
  uint64_t vars8;

  ETCTextureImp::~ETCTextureImp(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t ETCTextureImp::loadDataFromXPCObject(ETCTextureImp *this, xpc_object_t xdict)
{
  size_t length = 0;
  data = xpc_dictionary_get_data(xdict, "iio_xpc_plugin_data_etc_imp", &length);
  if (length == 544)
  {
    memcpy((char *)this + 16, data, 0x220uLL);
    *((void *)this + 3) = 0;
    *((void *)this + 4) = 0;
    *((void *)this + 2) = 0;
  }
  return 0;
}

uint64_t ETCTextureImp::saveDataToXPCObject(ETCTextureImp *this, void *a2)
{
  return 0;
}

uint64_t ETCTextureImp::textureDataLockData(ETCTextureImp *this, IIOImageReadSession *a2, unint64_t a3, unint64_t a4, IIOImageRead **a5, unint64_t *a6, unint64_t *a7)
{
  if (!*((void *)this + 2))
  {
    *((void *)this + 2) = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)this + 3, 1);
    int v13 = (const void *)IIOImageSource::cf(a2);
    *((void *)this + 4) = v13;
    CFRetain(v13);
    if (!*((void *)this + 2)) {
      _cg_jpeg_mem_term("textureDataLockData", 168, "*** Can't access image data\n");
    }
  }
  if (a3 >= 0x1F) {
    a3 = 31;
  }
  *a5 = IIOImageReadSession::getSize(a2);
  uint64_t result = *((void *)this + 2);
  uint64_t v15 = (char *)this + 8 * a3 + 16;
  *a6 = *((void *)v15 + 4);
  *a7 = *((void *)v15 + 36);
  return result;
}

uint64_t ETCReadPlugin::ETCReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v6 = (void *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *uint64_t v6 = &unk_1ED4DF778;
  v6[62] = 0;
  v6[63] = 0;
  uint64_t v7 = operator new(0x248uLL);
  v7[1] = 0;
  _OWORD v7[2] = 0;
  *uint64_t v7 = &unk_1ED4EF2D8;
  *((_DWORD *)v7 + 8) = *(_DWORD *)(a1 + 208);
  void v7[3] = &unk_1ED4DF8A0;
  bzero(v7 + 5, 0x220uLL);
  *(void *)(a1 + 496) = v7 + 3;
  *(void *)(a1 + 504) = v7;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(void *)(a1 + 488) = 0;
  return a1;
}

void sub_188786FF4(_Unwind_Exception *a1)
{
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

void ETCReadPlugin::ETCReadPlugin(uint64_t a1, uint64_t a2)
{
}

void sub_1887870D4(_Unwind_Exception *a1)
{
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

void ETCReadPlugin::~ETCReadPlugin(ETCReadPlugin *this)
{
  *(void *)this = &unk_1ED4DF778;
  uint64_t v2 = (const void *)*((void *)this + 61);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 63);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }

  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  uint64_t vars8;

  ETCReadPlugin::~ETCReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t ETCReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  if (v2 == 13) {
    return IIOReadPlugin::setupImageProviderCallbackV3(a1, a2);
  }
  if (v2 == 1) {
    return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

uint64_t ETCReadPlugin::loadDataFromXPCObject(ETCReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = (long long *)xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_etc", &length);
    if (length == 48)
    {
      long long v6 = *data;
      long long v7 = data[2];
      *(_OWORD *)((char *)this + 456) = data[1];
      *(_OWORD *)((char *)this + 472) = v7;
      *(_OWORD *)((char *)this + 440) = v6;
      *((void *)this + 59) = 0;
      return (*(uint64_t (**)(void, void *))(**((void **)this + 62) + 16))(*((void *)this + 62), a2);
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t ETCReadPlugin::saveDataToXPCObject(ETCReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!result)
  {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_etc", (char *)this + 440, 0x30uLL);
    uint64_t v5 = *(uint64_t (**)(void))(**((void **)this + 62) + 24);
    return v5();
  }
  return result;
}

uint64_t ETCReadPlugin::initialize(ETCReadPlugin *this, IIODictionary *a2)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  int __dst = 0;
  long long v57 = 0u;
  long long v58 = 0u;
  int8x16_t v55 = 0u;
  long long v56 = 0u;
  uint64_t v48 = 0;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v45 = 0u;
  long long v44 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v44, *((IIOImageReadSession **)this + 3));
  if (!*((unsigned char *)this + 341)) {
    goto LABEL_4;
  }
  uint64_t v3 = *((void *)this + 62);
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v44, &__dst, *((void *)this + 24), 4uLL) != 4) {
    goto LABEL_4;
  }
  unint64_t Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  if (__dst == 542327876) {
    goto LABEL_4;
  }
  int v7 = *((_DWORD *)this + 51);
  if (v7 == 1261585748)
  {
    long long v53 = 0u;
    long long v54 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v50 = 0u;
    if (IIOScanner::getBytesAtOffset((IIOScanner *)&v44, &v50, *((void *)this + 24), 0x50uLL) != 80
      || !IsKTX2Header(&v50))
    {
      goto LABEL_4;
    }
    if ((unint64_t)v45 <= v52)
    {
      _cg_jpeg_mem_term("initialize", 421, "*** ERROR: Invalid numberOfArrayElements (%d).");
      goto LABEL_4;
    }
    if ((unint64_t)v45 <= v53)
    {
      _cg_jpeg_mem_term("initialize", 422, "*** ERROR: Invalid dfdOffset (%d).");
      goto LABEL_4;
    }
    if ((unint64_t)v45 <= DWORD1(v53))
    {
      _cg_jpeg_mem_term("initialize", 423, "*** ERROR: Invalid dfdLength (%d).");
      goto LABEL_4;
    }
    if ((unint64_t)v45 <= DWORD2(v53))
    {
      _cg_jpeg_mem_term("initialize", 424, "*** ERROR: Invalid kvdOffset (%d).");
      goto LABEL_4;
    }
    if ((unint64_t)v45 <= HIDWORD(v53))
    {
      _cg_jpeg_mem_term("initialize", 425, "*** ERROR: Invalid kvdLength (%d).");
      goto LABEL_4;
    }
    if ((unint64_t)v54 >= (unint64_t)v45)
    {
      _cg_jpeg_mem_term("initialize", 426, "*** ERROR: Invalid scgdOffset (%d).");
      goto LABEL_4;
    }
    if (*((void *)&v54 + 1) >= (unint64_t)v45)
    {
      _cg_jpeg_mem_term("initialize", 427, "*** ERROR: Invalid scgdLength (%d).");
      goto LABEL_4;
    }
    uint64_t v43 = 0;
    memset(v42, 0, sizeof(v42));
    uint64_t v41 = 0;
    if (!CreateKtxStream((uint64_t)v42, *((IIOImageReadSession **)this + 3)))
    {
      int v21 = ktxTexture2_CreateFromStream((uint64_t (**)(void, _OWORD *, uint64_t))v42, 0, &v41);
      if (v21)
      {
        _cg_jpeg_mem_term("initialize", 436, "*** ERROR: ktxTexture2_CreateFromStream failed [%d]\n", v21);
        goto LABEL_4;
      }
      *((void *)this + 59) = v41;
      int v22 = HIDWORD(v50);
      *((_DWORD *)this + 120) = HIDWORD(v50);
      unsigned int v23 = v22 - 147;
      if (v23 >= 0xA) {
        int v24 = 0;
      }
      else {
        int v24 = dword_1889AAD40[v23];
      }
      *((_DWORD *)this + 113) = v24;
      *((unsigned char *)this + 344) = 0;
      uint64_t v36 = *(void *)((char *)&v51 + 4);
      *((uint32x2_t *)this + 57) = vshr_n_u32((uint32x2_t)vadd_s32(*(int32x2_t *)((char *)&v51 + 4), (int32x2_t)0x300000003), 2uLL);
      int v37 = DWORD2(v52);
      if (DWORD2(v52) >= 0x1F) {
        int v37 = 31;
      }
      *((_DWORD *)this + 112) = v37;
      int v11 = HIDWORD(v36);
      int v10 = v36;
      goto LABEL_46;
    }
LABEL_4:
    kdebug_trace();
    uint64_t v5 = 4294967246;
    goto LABEL_5;
  }
  if (v7 != 1262834755)
  {
    int v10 = 0;
    int v11 = 0;
    goto LABEL_46;
  }
  unint64_t v8 = (unint64_t)Size;
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v44, &v55, *((void *)this + 24), 0x40uLL) != 64) {
    goto LABEL_4;
  }
  SwapKTXHeader(&v55);
  __int32 v9 = v55.i32[3];
  *((_DWORD *)this + 113) = HIDWORD(v56);
  *((unsigned char *)this + 344) = v9 == 67305985;
  int v10 = DWORD1(v57);
  if (v8 <= DWORD1(v57))
  {
    uint64_t v39 = 349;
LABEL_71:
    _cg_jpeg_mem_term("initialize", v39, "*** bad dimension: %d x %d  (fileSize: %d)\n", DWORD1(v57), DWORD2(v57), v8);
    goto LABEL_4;
  }
  int v11 = DWORD2(v57);
  if (v8 <= DWORD2(v57))
  {
    uint64_t v39 = 350;
    goto LABEL_71;
  }
  *((uint32x2_t *)this + 57) = vshr_n_u32((uint32x2_t)vadd_s32(*(int32x2_t *)((char *)&v57 + 4), (int32x2_t)0x300000003), 2uLL);
  unsigned int v12 = DWORD2(v58);
  unint64_t v13 = HIDWORD(v58) + 64;
  *((void *)this + 24) = v13;
  if (v12 >= 0x1F) {
    int v14 = 31;
  }
  else {
    int v14 = v12;
  }
  *((_DWORD *)this + 112) = v14;
  if (v14)
  {
    unint64_t v15 = 0;
    unint64_t v16 = v45;
    uint64_t v17 = v13;
    while (1)
    {
      *(void *)&v42[0] = 0;
      if (IIOScanner::getBytesAtOffset((IIOScanner *)&v44, v42, v17, 8uLL) != 8) {
        break;
      }
      uint64_t v18 = v17 + 4;
      unint64_t v19 = v16 - (v17 + 4);
      if (v16 <= v17 + 4)
      {
        *((_DWORD *)this + 112) = v15;
        goto LABEL_39;
      }
      if (*(void *)&v42[0] < v19) {
        unint64_t v19 = *(void *)&v42[0];
      }
      if (v15 <= 0x1F)
      {
        uint64_t v20 = v3 + 8 * v15;
        *(void *)(v20 + 48) = v18;
        *(void *)(v20 + 304) = v19;
      }
      unint64_t v13 = v19 + v18;
      uint64_t v17 = ((v19 + 3) & 0xFFFFFFFFFFFFFFFCLL) + v18;
      if (++v15 >= *((unsigned int *)this + 112)) {
        goto LABEL_39;
      }
    }
    _cg_jpeg_mem_term("initialize", 368, "*** ETC - failed to read %d bytes\n", 8);
    goto LABEL_4;
  }
LABEL_39:
  unint64_t v25 = *((unsigned int *)this + 115) * (unint64_t)*((unsigned int *)this + 114);
  int v26 = *((_DWORD *)this + 113) - 37490;
  if (v26 >= 8) {
    unint64_t v27 = 8;
  }
  else {
    unint64_t v27 = qword_1889AAD00[v26];
  }
  if (!is_mul_ok(v25, v27))
  {
    _cg_jpeg_mem_term("initialize", 398, "*** ERROR: ETC-image too big\n");
    goto LABEL_4;
  }
  if (*(void *)(v3 + 304) < v25 * v27)
  {
    _cg_jpeg_mem_term("initialize", 400, "*** ERROR: ETC-levelSize too small\n");
    goto LABEL_4;
  }
  if (v13 > (unint64_t)IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3)))
  {
    uint64_t v40 = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
    _cg_jpeg_mem_term("initialize", 401, "***ERROR: ETC (KTX) file truncated. File Size: %lu, expected %lu\n", v40, v13);
    goto LABEL_4;
  }
  *((void *)this + 55) = *(void *)(v3 + 304);
  *((void *)this + 24) += 4;
LABEL_46:
  *((_DWORD *)this + 57) = v10;
  *((_DWORD *)this + 58) = v11;
  unsigned int v28 = *((_DWORD *)this + 114);
  *((_DWORD *)this + 73) = 4 * v28;
  if (v28 >> 30)
  {
    uint64_t v38 = 461;
LABEL_68:
    _cg_jpeg_mem_term("initialize", v38, "*** ERROR: ETC-image too big\n");
    goto LABEL_4;
  }
  unsigned int v29 = *((_DWORD *)this + 115);
  *((_DWORD *)this + 74) = 4 * v29;
  if (v29 >> 30)
  {
    uint64_t v38 = 463;
    goto LABEL_68;
  }
  *(_WORD *)((char *)this + 345) = 1;
  *((_DWORD *)this + 81) = 1380401696;
  *((_WORD *)this + 122) = 4;
  *((unsigned char *)this + 247) = 2;
  *((_DWORD *)this + 59) = 16 * v10;
  *((_DWORD *)this + 60) = 8388640;
  int v30 = *((_DWORD *)this + 113);
  if ((v30 - 37494) >= 4) {
    char v31 = 5;
  }
  else {
    char v31 = 3;
  }
  *((unsigned char *)this + 246) = v31;
  unsigned int v32 = v30 - 37493;
  if (v32 > 4) {
    int v33 = (CFStringRef *)MEMORY[0x1E4F1DC18];
  }
  else {
    int v33 = (CFStringRef *)qword_1E53CC4C8[v32];
  }
  *((void *)this + 20) = CGColorSpaceCreateWithName(*v33);
  int v34 = getenv("IIO_useV3");
  if (v34 && !atoi(v34)) {
    __int16 v35 = 1;
  }
  else {
    __int16 v35 = 13;
  }
  *((_WORD *)this + 188) = v35;
  if (*((unsigned char *)this + 181)) {
    ImageIOLog("    ETC:\n");
  }
  uint64_t v5 = 0;
LABEL_5:
  IIOScanner::~IIOScanner((IIOScanner *)&v44);
  return v5;
}

void sub_188787990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

uint64_t ETCReadPlugin::decodeETCtoRGBX(ETCReadPlugin *this, unint64_t *a2, uint64_t a3, vImage_Buffer *a4)
{
  int v4 = *((_DWORD *)this + 113) - 37488;
  if (v4 >= 0xA)
  {
    _cg_jpeg_mem_term("decodeETCtoRGBX", 559, "*** ETC - unknown GL pixel format\n", a4);
    return 4294967246;
  }
  else if (nv::DecompressETC_EAC(dword_1889AAD68[v4], a4->width, a4->height, a2, a3, (uint64_t)a4->data))
  {
    return 0;
  }
  else
  {
    return 4294967246;
  }
}

uint64_t ETCReadPlugin::decodeETCtoRGBX(ETCReadPlugin *this, IIOImageReadSession *a2, vImage_Buffer *a3)
{
  uint64_t v6 = *((void *)this + 62);
  int v22 = 0;
  int v7 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v22, 0);
  uint64_t v8 = *((unsigned int *)this + 52);
  if (v8 > 0x1F)
  {
    if (!v7) {
      goto LABEL_8;
    }
    unint64_t v10 = 0;
    uint64_t v11 = 0;
  }
  else
  {
    if (!v7) {
      goto LABEL_8;
    }
    uint64_t v9 = v6 + 8 * v8;
    unint64_t v10 = *(void *)(v9 + 304);
    uint64_t v11 = *(void *)(v9 + 48);
  }
  unsigned int v12 = (unint64_t *)((char *)v7 + v11);
  if ((((unint64_t)v7 + v11) & 0xF) == 0)
  {
    unint64_t v16 = 0;
    goto LABEL_19;
  }
  IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v22);
  int v22 = 0;
LABEL_8:
  unint64_t Size = IIOImageReadSession::getSize(a2);
  uint64_t v14 = *((unsigned int *)this + 52);
  if (v14 > 0x1F) {
    unint64_t v15 = 0;
  }
  else {
    unint64_t v15 = *(IIOImageRead **)(v6 + 8 * v14 + 48);
  }
  unint64_t v10 = Size - v15;
  if (Size == v15) {
    goto LABEL_17;
  }
  unint64_t v16 = (unint64_t *)malloc_type_malloc(Size - v15, 0xD6692E6uLL);
  uint64_t v17 = *((unsigned int *)this + 52);
  if (v17 > 0x1F) {
    unint64_t v18 = 0;
  }
  else {
    unint64_t v18 = *(void *)(v6 + 8 * v17 + 48);
  }
  unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v16, v18, v10);
  if (v10 == BytesAtOffset)
  {
    unsigned int v12 = v16;
    if (!v16)
    {
LABEL_17:
      _cg_jpeg_mem_term("decodeETCtoRGBX", 606, "*** tempLinearBuffer is nil\n");
      uint64_t v20 = 0;
      goto LABEL_21;
    }
LABEL_19:
    uint64_t v20 = ETCReadPlugin::decodeETCtoRGBX(this, v12, v10, a3);
    if (!v16) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  _cg_jpeg_mem_term("decodeETCtoRGBX", 603, "got: %ld expected: %ld\n", BytesAtOffset, v10);
  uint64_t v20 = 0;
  if (v16) {
LABEL_20:
  }
    free(v16);
LABEL_21:
  if (v22) {
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v22);
  }
  return v20;
}

uint64_t ETCReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  v55[0] = 0;
  if (*((unsigned char *)this + 410) == 1 && *((void *)this + 49) != 16) {
    return 4294967246;
  }
  *((void *)this + 49) = 16;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v8 = *((_DWORD *)this + 51);
    unsigned int v9 = v8 >> 24;
    uint64_t v10 = MEMORY[0x1E4F14390];
    if (v8 < 0)
    {
      int v11 = __maskrune(v9, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
    }
    if (v11) {
      uint64_t v13 = (v8 >> 24);
    }
    else {
      uint64_t v13 = 46;
    }
    unsigned int v14 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      int v15 = __maskrune(v14, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v15 = *(_DWORD *)(v10 + 4 * v14 + 60) & 0x40000;
    }
    if (v15) {
      uint64_t v16 = (v8 << 8 >> 24);
    }
    else {
      uint64_t v16 = 46;
    }
    unsigned int v17 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      int v18 = __maskrune(v17, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v18 = *(_DWORD *)(v10 + 4 * v17 + 60) & 0x40000;
    }
    if (v18) {
      uint64_t v19 = ((__int16)v8 >> 8);
    }
    else {
      uint64_t v19 = 46;
    }
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0) {
        goto LABEL_25;
      }
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_25:
      int v20 = *((_DWORD *)this + 51);
LABEL_28:
      ImageIOLog("  '%c%c%c%c' [%s] %s\n", v13, v16, v19, (char)v20, iioTypeStr[a3], "virtual OSStatus ETCReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_29;
    }
    LOBYTE(v20) = 46;
    goto LABEL_28;
  }
LABEL_29:
  IIOReadPlugin::debugDecodeImage(this, a2);
  int v21 = (IIOImageRead **)*((void *)this + 3);
  if (v21) {
    BOOL v22 = IIOImageReadSession::mapData(v21);
  }
  else {
    BOOL v22 = 0;
  }
  vImagePixelCount v23 = *((unsigned int *)this + 73);
  vImagePixelCount v24 = *((unsigned int *)this + 74);
  size_t v25 = *((unsigned int *)this + 75);
  if (a3 == 3)
  {
    uint64_t BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    unsigned int v30 = *((_DWORD *)this + 74);
    LODWORD(v31) = *((_DWORD *)this + 73);
    double v28 = (double)v30;
    double v29 = (double)v31;
    memory_object_size_t v49 = *((unsigned int *)this + 75) * (unint64_t)v30;
    BaseAddress = (void *)_ImageIO_Malloc(v49, *((void *)this + 48), v55, (uint64_t)kImageMalloc_ETC_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
    {
      uint64_t BlockArray = 0;
      goto LABEL_65;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    size_t Height = IOSurfaceGetHeight(*a4);
    uint64_t BlockArray = 0;
    memory_object_size_t v49 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v55[0] = v49;
    double v28 = 0.0;
    double v29 = 0.0;
  }
  if (!BaseAddress) {
    goto LABEL_65;
  }
  if (*((_DWORD *)this + 51) != 1261585748)
  {
    dest.data = BaseAddress;
    dest.double height = v24;
    dest.double width = v23;
    dest.size_t rowBytes = v25;
    uint64_t v38 = (IIOImageReadSession *)*((void *)this + 3);
    if (v38) {
      uint64_t BlockArray = ETCReadPlugin::decodeETCtoRGBX(this, v38, &dest);
    }
    uint64_t v36 = 0;
    if (!BlockArray) {
      goto LABEL_57;
    }
LABEL_50:
    *((_DWORD *)this + 26) = 0;
    goto LABEL_51;
  }
  Dataunint64_t Size = Ktx2GetDataSize(*((_DWORD *)this + 120), v23, v24);
  if (DataSize)
  {
    uint64_t v48 = a4;
    BOOL v33 = v22;
    uint64_t v34 = DataSize;
    __int16 v35 = (unint64_t *)malloc_type_calloc(DataSize, 1uLL, 0xA75C1443uLL);
    uint64_t v36 = v35;
    if (v35)
    {
      int v51 = *((_DWORD *)this + 52);
      long long v52 = v35;
      uint64_t v53 = v34;
      uint64_t v54 = 0;
      uint64_t KTXTexture = *((void *)this + 59);
      if (!KTXTexture)
      {
        uint64_t KTXTexture = CreateKTXTexture(*((IIOImageReadSession **)this + 3));
        *((void *)this + 59) = KTXTexture;
      }
      BOOL v22 = v33;
      if ((*(unsigned int (**)(void))(*(void *)(KTXTexture + 8) + 40))())
      {
        uint64_t BlockArray = 4294967246;
        goto LABEL_51;
      }
      dest.data = BaseAddress;
      dest.double height = v24;
      dest.double width = v23;
      dest.size_t rowBytes = v25;
      if (*((void *)this + 3)) {
        uint64_t BlockArray = ETCReadPlugin::decodeETCtoRGBX(this, v52, v54, &dest);
      }
      a4 = v48;
      if (!BlockArray)
      {
LABEL_57:
        if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 152) == 8 && *((unsigned char *)this + 406) == 1)
        {
          dest.data = BaseAddress;
          uint64_t v39 = *(void *)((char *)this + 292);
          v40.i64[0] = v39;
          v40.i64[1] = HIDWORD(v39);
          *(int8x16_t *)&dest.double height = vextq_s8(v40, v40, 8uLL);
          dest.size_t rowBytes = *((unsigned int *)this + 75);
          vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
        }
        if (a3 == 3)
        {
          uint64_t v43 = 0;
          v56.origin.double x = 0.0;
          v56.origin.double y = 0.0;
          v56.size.double width = v29;
          v56.size.double height = v28;
          **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v49, v56, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
          if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E4F1DB20]))
          {
            uint64_t v44 = 0;
          }
          else
          {
            v57.origin.double x = 0.0;
            v57.origin.double y = 0.0;
            v57.size.double width = v29;
            v57.size.double height = v28;
            *(CGRect *)(&v44 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v57);
            uint64_t v43 = v45;
            double v29 = v46;
            double v28 = v47;
          }
          uint64_t BlockArray = 0;
          *((void *)this + 15) = v43;
          *((void *)this + 16) = v44;
          *((double *)this + 17) = v29;
          *((double *)this + 18) = v28;
          if (!v36) {
            goto LABEL_65;
          }
          goto LABEL_64;
        }
        IOSurfaceUnlock(*a4, 0, 0);
        uint64_t BlockArray = 0;
        goto LABEL_63;
      }
      goto LABEL_50;
    }
    uint64_t BlockArray = 4294967188;
    BOOL v22 = v33;
  }
  else
  {
    uint64_t v36 = 0;
    uint64_t BlockArray = 4294967229;
  }
LABEL_51:
  if (a3 == 3)
  {
    _ImageIO_Free((unint64_t)BaseAddress, v55[0]);
    if (!v36) {
      goto LABEL_65;
    }
    goto LABEL_64;
  }
LABEL_63:
  if (v36) {
LABEL_64:
  }
    free(v36);
LABEL_65:
  if (v22)
  {
    uint64_t v41 = (const char **)*((void *)this + 3);
    if (v41) {
      IIOImageReadSession::unmapData(v41);
    }
  }
  return BlockArray;
}

uint64_t ETCReadPlugin::copyImageTextureData(uint64_t a1)
{
  int v2 = *(const void **)(a1 + 488);
  if (!v2)
  {
    long long v19 = xmmword_1ED4F0B68;
    long long v20 = *(_OWORD *)off_1ED4F0B78;
    uint64_t v3 = IIOImageRead::imageCount(*(IIOImageRead **)(a1 + 32));
    memset(v18, 0, sizeof(v18));
    IIODictionary::IIODictionary((IIODictionary *)v18);
    IIONumber::IIONumber((IIONumber *)v17, *(_DWORD *)(a1 + 228));
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v17, @"width");
    IIONumber::~IIONumber((IIONumber *)v17);
    IIONumber::IIONumber((IIONumber *)v16, *(_DWORD *)(a1 + 232));
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v16, @"height");
    IIONumber::~IIONumber((IIONumber *)v16);
    int v4 = *(_DWORD *)(a1 + 452) - 37488;
    if (v4 > 9) {
      int v5 = 0;
    }
    else {
      int v5 = dword_1889AAD90[v4];
    }
    IIONumber::IIONumber((IIONumber *)v15, v5 * *(_DWORD *)(a1 + 456));
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v15, @"rowBytes");
    IIONumber::~IIONumber((IIONumber *)v15);
    IIONumber::IIONumber((IIONumber *)v14, *(_DWORD *)(a1 + 452));
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v14, @"glInternalFormat");
    IIONumber::~IIONumber((IIONumber *)v14);
    IIONumber::IIONumber((IIONumber *)v13, v3);
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v13, @"mipmapLevelCount");
    IIONumber::~IIONumber((IIONumber *)v13);
    IIONumber::IIONumber((IIONumber *)v12, 1);
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v12, @"faceCount");
    IIONumber::~IIONumber((IIONumber *)v12);
    CGColorSpaceRef ColorSpace = (const void *)CGImageProviderGetColorSpace();
    IIODictionary::setObjectForKey((IIODictionary *)v18, ColorSpace, @"colorSpace");
    IIODictionary::setObjectForKey((IIODictionary *)v18, (const void *)*MEMORY[0x1E4F1CFC8], @"supportsTiledLayout");
    IIONumber::IIONumber((IIONumber *)v11, *(_DWORD *)(a1 + 452));
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v11, @"pixelFormatGL");
    IIONumber::~IIONumber((IIONumber *)v11);
    int v7 = *(_DWORD *)(a1 + 452) - 37488;
    if (v7 > 9) {
      int v8 = 0;
    }
    else {
      int v8 = dword_1889AADB8[v7];
    }
    IIONumber::IIONumber((IIONumber *)v10, v8);
    IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v10, @"pixelFormatMetal");
    IIONumber::~IIONumber((IIONumber *)v10);
    IIOImageSource::cf(*(IIOImageSource **)(a1 + 32));
    operator new();
  }
  CFRetain(v2);
  return *(void *)(a1 + 488);
}

void sub_1887883DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  IIODictionary::~IIODictionary((IIODictionary *)(v11 - 104));
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<ETCTextureImp>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED4EF2D8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ETCTextureImp>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED4EF2D8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18C11C0E0);
}

uint64_t std::__shared_ptr_emplace<ETCTextureImp>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

__CFString *CGImageMetadataDefaultPrefixForSchema(const __CFString *a1)
{
  if (CFEqual(a1, @"http://ns.adobe.com/exif/1.0/aux/"))
  {
    int v2 = (__CFString **)&kCGImageMetadataPrefixExifAux;
    goto LABEL_21;
  }
  if (CFEqual(a1, @"http://ns.adobe.com/camera-raw-settings/1.0/"))
  {
    int v2 = xmpCRSPrefix;
    goto LABEL_21;
  }
  if (CFEqual(a1, @"http://purl.org/dc/elements/1.1/"))
  {
    int v2 = (__CFString **)&kCGImageMetadataPrefixDublinCore;
    goto LABEL_21;
  }
  if (CFEqual(a1, @"http://ns.adobe.com/exif/1.0/"))
  {
    int v2 = (__CFString **)&kCGImageMetadataPrefixExif;
    goto LABEL_21;
  }
  if (CFEqual(a1, @"http://ns.adobe.com/photoshop/1.0/"))
  {
    int v2 = (__CFString **)&kCGImageMetadataPrefixPhotoshop;
    goto LABEL_21;
  }
  if (CFEqual(a1, @"http://ns.adobe.com/tiff/1.0/"))
  {
    int v2 = (__CFString **)&kCGImageMetadataPrefixTIFF;
    goto LABEL_21;
  }
  if (CFEqual(a1, @"http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/"))
  {
    int v2 = (__CFString **)&kCGImageMetadataPrefixIPTCCore;
    goto LABEL_21;
  }
  if (CFEqual(a1, @"http://iptc.org/std/Iptc4xmpExt/2008-02-29/"))
  {
    int v2 = (__CFString **)&kCGImageMetadataPrefixIPTCExtension;
    goto LABEL_21;
  }
  if (CFEqual(a1, @"http://ns.adobe.com/xap/1.0/"))
  {
    int v2 = (__CFString **)&kCGImageMetadataPrefixXMPBasic;
LABEL_21:
    uint64_t result = *v2;
    if (*v2) {
      return result;
    }
    goto LABEL_22;
  }
  if (CFEqual(a1, @"http://www.metadataworkinggroup.com/schemas/regions/"))
  {
    int v2 = xmpMWGRegionsPrefix;
    goto LABEL_21;
  }
LABEL_22:
  IIOString::IIOString((IIOString *)v5, a1);
  int v4 = (const char *)IIOString::utf8String((IIOString *)v5);
  _cg_jpeg_mem_term("CGImageMetadataDefaultPrefixForSchema", 52, "*** unknown schema '%s'\n", v4);
  IIOString::~IIOString((IIOString *)v5);
  return 0;
}

void sub_188788728(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t GetMetadataPropertyMatchingSchemaAndPropertyName(const void *a1, const __CFString *a2, const __CFString *a3)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "GetMetadataPropertyMatchingSchemaAndPropertyName", 0, 0, -1, 0);
  }
  if (!a1) {
    return 0;
  }
  CFTypeID v6 = CFGetTypeID(a1);
  CFTypeID TypeID = CFArrayGetTypeID();
  uint64_t v8 = 0;
  if (!a3 || !a2 || v6 != TypeID) {
    return v8;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
  if (Count < 1) {
    return 0;
  }
  CFIndex v10 = Count;
  CFIndex v11 = 0;
  while (1)
  {
    CFDataRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v11);
    uint64_t v8 = (uint64_t)ValueAtIndex;
    if (!ValueAtIndex) {
      break;
    }
    CFTypeID v13 = CFGetTypeID(ValueAtIndex);
    if (v13 != CGImageMetadataPropertyGetTypeID()) {
      return 0;
    }
    CFStringRef Schema = (const __CFString *)CGImageMetadataPropertyGetSchema(v8);
    if (CFEqual(Schema, a2))
    {
      PropertyCFStringRef Name = (const __CFString *)CGImageMetadataPropertyGetPropertyName(v8);
      if (CFEqual(PropertyName, a3)) {
        break;
      }
    }
    if (v10 == ++v11) {
      return 0;
    }
  }
  return v8;
}

CGImageMetadata *CGImageMetadataCreateSerializedData(__CFArray *a1)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImageMetadataCreateSerializedData", 0, 0, -1, 0);
  }
  uint64_t result = CGImageMetadataCreateFromMetadataProperties(a1);
  if (result)
  {
    uint64_t v3 = result;
    XMPuint64_t Data = CGImageMetadataCreateXMPData(result, 0);
    CFRelease(v3);
    return XMPData;
  }
  return result;
}

CGImageMetadata *CGImageMetadataCreateFromMetadataProperties(__CFArray *MetadataProperties)
{
  metadata = CGImageMetadataCreateMutable();
  CFIndex Count = CFArrayGetCount(MetadataProperties);
  if (Count == 1)
  {
    CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(MetadataProperties, 0);
    CFTypeID v4 = CFGetTypeID(ValueAtIndex);
    if (v4 != CGImageMetadataGetTypeID())
    {
      CFTypeID v6 = 0;
      CFIndex v5 = 1;
      goto LABEL_10;
    }
    _cg_jpeg_mem_term("CGImageMetadataCreateFromMetadataProperties", 404, "*** expected 'CGImageMetadataPropertyRef' but got 'CGImageMetadataRef'");
    MetadataProperties = CGImageMetadataCreateMetadataProperties((uint64_t)ValueAtIndex);
    CFIndex v5 = CFArrayGetCount(MetadataProperties);
    CFTypeID v6 = MetadataProperties;
  }
  else
  {
    CFIndex v5 = Count;
    CFTypeID v6 = 0;
  }
  if (v5 >= 1)
  {
LABEL_10:
    vImagePixelCount v23 = v6;
    for (CFIndex i = 0; i != v5; ++i)
    {
      unsigned int v9 = CFArrayGetValueAtIndex(MetadataProperties, i);
      if (v9)
      {
        uint64_t v10 = (uint64_t)v9;
        CFTypeID v11 = CFGetTypeID(v9);
        if (v11 == CGImageMetadataPropertyGetTypeID())
        {
          CFStringRef Value = (const void *)CGImageMetadataPropertyGetValue(v10);
          if (Value)
          {
            uint64_t v13 = (uint64_t)Value;
            CFTypeID v14 = CFGetTypeID(Value);
            if (v14 == CGImageMetadataValueGetTypeID())
            {
              CFStringRef Schema = (const __CFString *)CGImageMetadataPropertyGetSchema(v10);
              SuggestedPrefidouble x = (const __CFString *)CGImageMetadataPropertyGetSuggestedPrefix(v10);
              CGImageMetadataRegisterNamespaceForPrefix(metadata, Schema, SuggestedPrefix, 0);
              PropertyCFStringRef Name = (const __CFString *)CGImageMetadataPropertyGetPropertyName(v10);
              TagTypeForMetadataCFStringRef Value = GetTagTypeForMetadataValue(v13);
              TagValueFromMetadataCFStringRef Value = CreateTagValueFromMetadataValue((uint64_t)Schema, (uint64_t)SuggestedPrefix, v13);
              if (TagValueFromMetadataValue)
              {
                CFStringRef v20 = TagValueFromMetadataValue;
                CGImageMetadataTagRef v21 = CGImageMetadataTagCreate(Schema, SuggestedPrefix, PropertyName, TagTypeForMetadataValue, TagValueFromMetadataValue);
                if (v21)
                {
                  CGImageMetadataTagRef v22 = v21;
                  SyncMetadataValueQualifiersToTag(v13, (uint64_t)v21);
                  CGImageMetadataAddTag((uint64_t)metadata, v22);
                  CFRelease(v22);
                }
                CFRelease(v20);
              }
            }
          }
        }
        else
        {
          _cg_jpeg_mem_term("CGImageMetadataCreateFromMetadataProperties", 442, "*** expected 'CGImageMetadataPropertyRef' but got unknown type...\n");
        }
      }
    }
    CFTypeID v6 = v23;
    if (v23) {
      goto LABEL_7;
    }
    return metadata;
  }
  if (v6) {
LABEL_7:
  }
    CFRelease(v6);
  return metadata;
}

CGImageMetadata *CGImageMetadataSerialize(__CFArray *a1)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImageMetadataSerialize", 0, 0, -1, 0);
  }

  return CGImageMetadataCreateSerializedData(a1);
}

__CFArray *CGImageMetadataCreateFromData(const __CFData *a1)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImageMetadataCreateFromData", 0, 0, -1, 0);
  }
  CGImageMetadataRef v2 = CGImageMetadataCreateFromXMPData(a1);
  if (v2)
  {
    CGImageMetadataRef v3 = v2;
    MetadataProperties = CGImageMetadataCreateMetadataProperties((uint64_t)v2);
    CFRelease(v3);
  }
  else
  {
    MetadataProperties = 0;
  }
  kdebug_trace();
  return MetadataProperties;
}

__CFArray *CGImageMetadataCreateMetadataProperties(uint64_t a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 24));
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v2, Count, MEMORY[0x1E4F1D510]);
  int64_t v5 = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 24));
  CFTypeID v6 = (const void **)malloc_type_calloc(8uLL, v5, 0x2E9BD831uLL);
  int v7 = (const void **)malloc_type_calloc(8uLL, v5, 0xF742F9FDuLL);
  CFDictionaryGetKeysAndValues(*(CFDictionaryRef *)(a1 + 24), v6, v7);
  if (v5 >= 1)
  {
    uint64_t v8 = (uint64_t *)v7;
    do
    {
      unsigned int v9 = (CGImageMetadataTag *)*v8;
      uint64_t Source = CGImageSourceGetSource(*v8);
      uint64_t v11 = CGImageMetadataPropertyCreate(*(const __CFString **)(Source + 16), *(const void **)(Source + 24), *(const void **)(Source + 32));
      if (v11)
      {
        unsigned int v12 = (const void *)v11;
        CFStringRef PropertyValueFromTag = CreatePropertyValueFromTag(v9);
        if (PropertyValueFromTag)
        {
          CFStringRef v14 = PropertyValueFromTag;
          int v15 = (void *)CGImageMetadataValueCreate(PropertyValueFromTag);
          if (v15)
          {
            uint64_t v16 = v15;
            SyncTagQualifiersToMetadataValue((uint64_t)v9, v15);
            int v17 = *(_DWORD *)(Source + 40);
            if (v17 == 4)
            {
              CGImageMetadataValueSetIsAlternate((uint64_t)v16, 1);
            }
            else if (v17 == 5)
            {
              CGImageMetadataValueSetIsAlternateText((uint64_t)v16, 1);
            }
            CGImageMetadataPropertySetValue((uint64_t)v12, v16);
            CFArrayAppendValue(Mutable, v12);
            CFRelease(v16);
          }
          CFRelease(v14);
        }
        CFRelease(v12);
      }
      ++v8;
      --v5;
    }
    while (v5);
  }
  if (v6) {
    free(v6);
  }
  if (v7) {
    free(v7);
  }
  return Mutable;
}

uint64_t GetTagTypeForMetadataValue(uint64_t a1)
{
  CFStringRef Value = (const void *)CGImageMetadataValueGetValue(a1);
  CFTypeID v3 = CFGetTypeID(Value);
  if (v3 == CFStringGetTypeID()) {
    return 1;
  }
  CFTypeID v5 = CFGetTypeID(Value);
  if (v5 == CFArrayGetTypeID())
  {
    if (CGImageMetadataValueIsAlternateText(a1))
    {
      return 5;
    }
    else if (CGImageMetadataValueIsAlternate(a1))
    {
      return 4;
    }
    else
    {
      return 3;
    }
  }
  else
  {
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFBagGetTypeID())
    {
      return 2;
    }
    else
    {
      CFTypeID v7 = CFGetTypeID(Value);
      if (v7 == CFDictionaryGetTypeID()) {
        return 6;
      }
      else {
        return 0xFFFFFFFFLL;
      }
    }
  }
}

CFStringRef CreateTagValueFromMetadataValue(uint64_t a1, uint64_t a2, uint64_t a3)
{
  TagTypeForMetadataCFStringRef Value = GetTagTypeForMetadataValue(a3);
  CFStringRef Value = (const __CFString *)CGImageMetadataValueGetValue(a3);
  CFStringRef v6 = Value;
  switch(TagTypeForMetadataValue)
  {
    case 1:
      CFAllocatorRef v25 = CFGetAllocator(Value);
      return CFStringCreateCopy(v25, v6);
    case 2:
      uint64_t v27 = MEMORY[0x18C11A0A0](Value);
      double v28 = (const void **)malloc_type_calloc(8uLL, v27, 0x99664D1uLL);
      CFAllocatorRef v29 = CFGetAllocator(v6);
      theArradouble y = CFArrayCreateMutable(v29, v27, MEMORY[0x1E4F1D510]);
      if (!v28) {
        return 0;
      }
      CFBagGetValues((CFBagRef)v6, v28);
      if (v27 >= 1)
      {
        uint64_t v30 = 0;
        CFAllocatorRef v31 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        do
        {
          uint64_t v32 = (uint64_t)v28[v30];
          if (v32)
          {
            CFTypeID v33 = CFGetTypeID(v28[v30]);
            if (v33 == CGImageMetadataValueGetTypeID())
            {
              CGImageMetadataType v34 = GetTagTypeForMetadataValue(v32);
              uint64_t NamespaceURI = CGImageMetadataValueGetNamespaceURI(v32);
              CFStringRef v36 = (const __CFString *)(NamespaceURI ? NamespaceURI : a1);
              SuggestedNamespacePrefidouble x = CGImageMetadataValueGetSuggestedNamespacePrefix(v32);
              CFStringRef v38 = (const __CFString *)(SuggestedNamespacePrefix ? SuggestedNamespacePrefix : a2);
              CFStringRef v39 = CFStringCreateWithFormat(v31, 0, @"[%ld]", v30);
              if (v39)
              {
                CFStringRef v40 = v39;
                TagValueFromMetadataCFStringRef Value = (const void *)CreateTagValueFromMetadataValue(v36, v38, v32);
                if (TagValueFromMetadataValue)
                {
                  unint64_t v42 = TagValueFromMetadataValue;
                  CGImageMetadataTagRef v43 = CGImageMetadataTagCreate(v36, v38, v40, v34, TagValueFromMetadataValue);
                  if (v43)
                  {
                    CGImageMetadataTagRef v44 = v43;
                    SyncMetadataValueQualifiersToTag(v32, (uint64_t)v43);
                    CFArrayAppendValue(theArray, v44);
                    CFRelease(v44);
                  }
                  CFRelease(v42);
                }
                CFRelease(v40);
              }
            }
          }
          ++v30;
        }
        while (v27 != v30);
      }
      goto LABEL_64;
    case 3:
    case 4:
    case 5:
      uint64_t Count = CFArrayGetCount((CFArrayRef)Value);
      CFAllocatorRef v8 = CFGetAllocator(v6);
      theArradouble y = CFArrayCreateMutable(v8, Count, MEMORY[0x1E4F1D510]);
      if (Count >= 1)
      {
        CFIndex v9 = 0;
        CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        do
        {
          CFDataRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v6, v9);
          if (ValueAtIndex)
          {
            uint64_t v12 = (uint64_t)ValueAtIndex;
            CFTypeID v13 = CFGetTypeID(ValueAtIndex);
            if (v13 == CGImageMetadataValueGetTypeID())
            {
              CGImageMetadataType v14 = GetTagTypeForMetadataValue(v12);
              uint64_t v15 = CGImageMetadataValueGetNamespaceURI(v12);
              CFStringRef v16 = (const __CFString *)(v15 ? v15 : a1);
              uint64_t v17 = CGImageMetadataValueGetSuggestedNamespacePrefix(v12);
              CFStringRef v18 = (const __CFString *)(v17 ? v17 : a2);
              CFStringRef v19 = CFStringCreateWithFormat(v10, 0, @"[%ld]", v9);
              if (v19)
              {
                CFStringRef v20 = v19;
                CGImageMetadataTagRef v21 = (const void *)CreateTagValueFromMetadataValue(v16, v18, v12);
                if (v21)
                {
                  CGImageMetadataTagRef v22 = v21;
                  CGImageMetadataTagRef v23 = CGImageMetadataTagCreate(v16, v18, v20, v14, v21);
                  if (v23)
                  {
                    CGImageMetadataTagRef v24 = v23;
                    SyncMetadataValueQualifiersToTag(v12, (uint64_t)v23);
                    CFArrayAppendValue(theArray, v24);
                    CFRelease(v24);
                  }
                  CFRelease(v22);
                }
                CFRelease(v20);
              }
            }
          }
          ++v9;
        }
        while (Count != v9);
      }
      return (CFStringRef)theArray;
    case 6:
      int64_t v45 = CFDictionaryGetCount((CFDictionaryRef)Value);
      theArradouble y = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      double v46 = (const void **)malloc_type_calloc(8uLL, v45, 0x4942AB70uLL);
      double v47 = (const void **)malloc_type_calloc(8uLL, v45, 0x8A9DFF05uLL);
      double v28 = v47;
      uint64_t v62 = v46;
      if (v46 && v47)
      {
        CFDictionaryGetKeysAndValues((CFDictionaryRef)v6, v46, v47);
        if (v45 >= 1)
        {
          uint64_t v48 = (const __CFString **)v46;
          memory_object_size_t v49 = v28;
          do
          {
            CFTypeRef v50 = *v49;
            if (*v49)
            {
              CFStringRef v51 = *v48;
              CFTypeID v52 = CFGetTypeID(*v49);
              if (v52 == CGImageMetadataValueGetTypeID())
              {
                CGImageMetadataType v53 = GetTagTypeForMetadataValue((uint64_t)v50);
                uint64_t v54 = CGImageMetadataValueGetNamespaceURI((uint64_t)v50);
                CFStringRef v55 = (const __CFString *)(v54 ? v54 : a1);
                uint64_t v56 = CGImageMetadataValueGetSuggestedNamespacePrefix((uint64_t)v50);
                CFStringRef v57 = (const __CFString *)(v56 ? v56 : a2);
                long long v58 = (const void *)CreateTagValueFromMetadataValue(v55, v57, v50);
                if (v58)
                {
                  uint64_t v59 = v58;
                  CGImageMetadataTagRef v60 = CGImageMetadataTagCreate(v55, v57, v51, v53, v58);
                  if (v60)
                  {
                    CGImageMetadataTagRef v61 = v60;
                    SyncMetadataValueQualifiersToTag((uint64_t)v50, (uint64_t)v60);
                    CFDictionarySetValue(theArray, v51, v61);
                    CFRelease(v61);
                  }
                  CFRelease(v59);
                }
              }
            }
            ++v49;
            ++v48;
            --v45;
          }
          while (v45);
        }
      }
      else if (!v46)
      {
        goto LABEL_63;
      }
      free(v62);
LABEL_63:
      if (v28) {
LABEL_64:
      }
        free(v28);
      return (CFStringRef)theArray;
    default:
      return 0;
  }
}

void SyncMetadataValueQualifiersToTag(uint64_t a1, uint64_t a2)
{
  uint64_t Source = CGImageSourceGetSource(a2);
  CFArrayRef v4 = *(const __CFArray **)(a1 + 48);
  if (v4 && CFArrayGetCount(v4) >= 1)
  {
    uint64_t Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
    if (!*(void *)(Source + 56)) {
      *(void *)(Source + 56) = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]);
    }
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), i);
        if (CGImageMetadataValueIsAlternateText(a1))
        {
          CFTypeID v8 = CFGetTypeID(ValueAtIndex);
          if (v8 == CFStringGetTypeID())
          {
            CGImageMetadataTagRef v9 = CGImageMetadataTagCreate(@"http://www.w3.org/XML/1998/namespace", @"xml", @"lang", kCGImageMetadataTypeString, ValueAtIndex);
            if (v9)
            {
              CGImageMetadataTagRef v10 = v9;
              CFArrayAppendValue(*(CFMutableArrayRef *)(Source + 56), v9);
              CFRelease(v10);
            }
          }
        }
      }
    }
  }
}

CFStringRef CreatePropertyValueFromTag(CGImageMetadataTag *a1)
{
  uint64_t Source = CGImageSourceGetSource((uint64_t)a1);
  int v2 = *(_DWORD *)(Source + 40);
  CFStringRef v3 = *(const __CFString **)(Source + 48);
  switch(v2)
  {
    case 1:
      CFAllocatorRef v15 = CFGetAllocator(*(CFTypeRef *)(Source + 48));
      return CFStringCreateCopy(v15, v3);
    case 2:
      uint64_t Count = CFArrayGetCount(*(CFArrayRef *)(Source + 48));
      CFAllocatorRef v18 = CFGetAllocator(v3);
      CFMutableDictionaryRef Mutable = CFBagCreateMutable(v18, Count, MEMORY[0x1E4F1D520]);
      if (Count >= 1)
      {
        for (CFIndex i = 0; i != Count; ++i)
        {
          CFDataRef ValueAtIndex = (CGImageMetadataTag *)CFArrayGetValueAtIndex((CFArrayRef)v3, i);
          if (ValueAtIndex)
          {
            CGImageMetadataTagRef v21 = ValueAtIndex;
            CFTypeID v22 = CFGetTypeID(ValueAtIndex);
            if (v22 == CGImageMetadataTagGetTypeID())
            {
              CFStringRef PropertyValueFromTag = (const void *)CreatePropertyValueFromTag(v21);
              if (PropertyValueFromTag)
              {
                CGImageMetadataTagRef v24 = PropertyValueFromTag;
                CFAllocatorRef v25 = (void *)CGImageMetadataValueCreate(PropertyValueFromTag);
                if (v25)
                {
                  int v26 = v25;
                  SyncTagQualifiersToMetadataValue((uint64_t)v21, v25);
                  CFBagAddValue(Mutable, v26);
                  CFRelease(v26);
                }
                CFRelease(v24);
              }
            }
          }
        }
      }
      return (CFStringRef)Mutable;
    case 3:
    case 4:
    case 5:
      uint64_t v4 = CFArrayGetCount(*(CFArrayRef *)(Source + 48));
      CFAllocatorRef v5 = CFGetAllocator(v3);
      CFMutableDictionaryRef Mutable = CFArrayCreateMutable(v5, v4, MEMORY[0x1E4F1D510]);
      if (v4 >= 1)
      {
        for (CFIndex j = 0; j != v4; ++j)
        {
          CFTypeID v8 = (CGImageMetadataTag *)CFArrayGetValueAtIndex((CFArrayRef)v3, j);
          if (v8)
          {
            CGImageMetadataTagRef v9 = v8;
            CFTypeID v10 = CFGetTypeID(v8);
            if (v10 == CGImageMetadataTagGetTypeID())
            {
              uint64_t v11 = (const void *)CreatePropertyValueFromTag(v9);
              if (v11)
              {
                uint64_t v12 = v11;
                CFTypeID v13 = (void *)CGImageMetadataValueCreate(v11);
                if (v13)
                {
                  CGImageMetadataType v14 = v13;
                  SyncTagQualifiersToMetadataValue((uint64_t)v9, v13);
                  if (v2 == 4)
                  {
                    CGImageMetadataValueSetIsAlternate((uint64_t)v14, 1);
                  }
                  else if (v2 == 5)
                  {
                    CGImageMetadataValueSetIsAlternateText((uint64_t)v14, 1);
                  }
                  CFArrayAppendValue(Mutable, v14);
                  CFRelease(v14);
                }
                CFRelease(v12);
              }
            }
          }
        }
      }
      return (CFStringRef)Mutable;
    case 6:
      int64_t v27 = CFDictionaryGetCount(*(CFDictionaryRef *)(Source + 48));
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
      double v28 = (const void **)malloc_type_calloc(8uLL, v27, 0xDD4A3F04uLL);
      CFAllocatorRef v29 = (const void **)malloc_type_calloc(8uLL, v27, 0xC2425E9DuLL);
      uint64_t v30 = v29;
      if (v28) {
        BOOL v31 = v29 == 0;
      }
      else {
        BOOL v31 = 1;
      }
      if (v31)
      {
        if (!v28) {
          goto LABEL_47;
        }
      }
      else
      {
        CFDictionaryGetKeysAndValues((CFDictionaryRef)v3, v28, v29);
        if (v27 >= 1)
        {
          uint64_t v32 = v28;
          CFTypeID v33 = v30;
          do
          {
            CGImageMetadataType v34 = (CGImageMetadataTag *)*v33;
            if (*v33)
            {
              __int16 v35 = *v32;
              CFTypeID v36 = CFGetTypeID(*v33);
              if (v36 == CGImageMetadataTagGetTypeID())
              {
                int v37 = (const void *)CreatePropertyValueFromTag(v34);
                if (v37)
                {
                  CFStringRef v38 = v37;
                  uint64_t v39 = CGImageMetadataValueCreate(v37);
                  if (v39)
                  {
                    CFStringRef v40 = (void *)v39;
                    NameCGColorSpaceRef space = (const void *)CGImageMetadataTagGetNamespace((uint64_t)v34);
                    CGImageMetadataValueSetNamespaceURI((uint64_t)v40, Namespace);
                    SyncTagQualifiersToMetadataValue((uint64_t)v34, v40);
                    CFDictionarySetValue(Mutable, v35, v40);
                    CFRelease(v40);
                  }
                  CFRelease(v38);
                }
              }
            }
            ++v33;
            ++v32;
            --v27;
          }
          while (v27);
        }
      }
      free(v28);
LABEL_47:
      if (v30) {
        free(v30);
      }
      return (CFStringRef)Mutable;
    default:
      return 0;
  }
}

void SyncTagQualifiersToMetadataValue(uint64_t a1, void *a2)
{
  uint64_t Source = CGImageSourceGetSource(a1);
  if (a1)
  {
    uint64_t v5 = Source;
    CFArrayRef v6 = *(const __CFArray **)(Source + 56);
    if (v6)
    {
      CFIndex Count = CFArrayGetCount(v6);
      if (Count >= 1)
      {
        CFIndex v8 = Count;
        for (CFIndex i = 0; i != v8; ++i)
        {
          CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v5 + 56), i);
          if (ValueAtIndex)
          {
            CFTypeID v11 = CFGetTypeID(ValueAtIndex);
            if (v11 == CGImageMetadataTagGetTypeID())
            {
              uint64_t v12 = CGImageSourceGetSource(a1);
              if (*(_DWORD *)(v12 + 40) == 1)
              {
                CFTypeID v13 = *(const void **)(v12 + 48);
                CFTypeID v14 = CFGetTypeID(v13);
                if (v14 == CFStringGetTypeID()) {
                  CGImageMetadataValueAddQualifier(a2, v13);
                }
              }
            }
          }
        }
      }
    }
  }
}

uint64_t CGImageMetadataCreateSidecar(void *a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImageMetadataCreateSidecar", 0, 0, -1, 0);
  }
  uint64_t v4 = 0;
  if (a1 && a2)
  {
    CFTypeID v5 = CFGetTypeID(a1);
    if (v5 == CFArrayGetTypeID())
    {
      CFArrayRef v6 = CGImageMetadataSerialize((__CFArray *)a1);
      if (v6)
      {
        CFDataRef v7 = v6;
        bzero(__filename, 0x400uLL);
        if (_CFStringGetFileSystemRepresentation() && (CFIndex v8 = fopen(__filename, "w")) != 0)
        {
          CGImageMetadataTagRef v9 = v8;
          BytePtr = CFDataGetBytePtr(v7);
          size_t Length = CFDataGetLength(v7);
          uint64_t v4 = 1;
          fwrite(BytePtr, Length, 1uLL, v9);
          fclose(v9);
        }
        else
        {
          uint64_t v4 = 0;
        }
        CFRelease(v7);
        goto LABEL_14;
      }
    }
    else
    {
      LogError("CGImageMetadataCreateSidecar", 706, "*** ERROR: 'metadata' is not a CFArrayRef\n");
    }
    uint64_t v4 = 0;
  }
LABEL_14:
  kdebug_trace();
  return v4;
}

uint64_t CGImageCreateColorSpaceFromExifOrData(const void *a1, const void *a2, void *a3)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImageCreateColorSpaceFromExifOrData", 0, 0, -1, 0);
  }
  CFMutableArrayRef v8 = 0;
  CGImageMetadataTagRef v9 = 0;
  uint64_t v10 = 0;
  IIOArray::IIOArray((IIOArray *)&v8);
  if (a1) {
    IIOArray::addObject(&v8, a1);
  }
  if (a2) {
    IIOArray::addObject(&v8, a2);
  }
  if (IIOArray::getCount((IIOArray *)&v8)) {
    ColorSpaceFromDataArradouble y = CGImageCreateColorSpaceFromDataArray(v9, a3);
  }
  else {
    ColorSpaceFromDataArradouble y = 4294967246;
  }
  IIOArray::~IIOArray((IIOArray *)&v8);
  return ColorSpaceFromDataArray;
}

void sub_188789BDC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageCreateColorSpaceFromDataArray(const void *a1, void *a2)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((~gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImageCreateColorSpaceFromDataArray", 0, 0, -1, 0);
  }
  if (!a1)
  {
    LogError("CGImageCreateColorSpaceFromDataArray", 778, "*** ERROR: dataArray is nil\n");
    goto LABEL_14;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFArrayGetTypeID())
  {
    LogError("CGImageCreateColorSpaceFromDataArray", 779, "*** ERROR: dataArray is not a CFArrayRef\n");
    goto LABEL_14;
  }
  if (!a2)
  {
    LogError("CGImageCreateColorSpaceFromDataArray", 780, "*** ERROR: colorSpaceOut is nil\n");
    goto LABEL_14;
  }
  if (!CFArrayGetCount((CFArrayRef)a1))
  {
LABEL_14:
    uint64_t v7 = 4294967246;
    goto LABEL_15;
  }
  memset(v14, 0, sizeof(v14));
  CFTypeID v5 = IIOArray::IIOArray((IIOArray *)v14, (const __CFArray *)a1);
  uint64_t v10 = 0;
  CFTypeID v11 = &v10;
  uint64_t v12 = 0x2000000000;
  uint64_t v13 = 0;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 0x40000000;
  void v9[2] = __CGImageCreateColorSpaceFromDataArray_block_invoke;
  void v9[3] = &unk_1E53C0018;
  v9[4] = &v10;
  IIOArray::enumerate((uint64_t)v5, (uint64_t)v9);
  uint64_t v6 = v11[3];
  if (v6)
  {
    uint64_t v7 = 0;
    *a2 = v6;
  }
  else
  {
    uint64_t v7 = 4294967246;
  }
  _Block_object_dispose(&v10, 8);
  IIOArray::~IIOArray((IIOArray *)v14);
LABEL_15:
  kdebug_trace();
  return v7;
}

void sub_188789DD0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  _Block_object_dispose(va, 8);
  IIOArray::~IIOArray((IIOArray *)(v6 - 56));
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x188789DA0);
}

void __CGImageCreateColorSpaceFromDataArray_block_invoke(uint64_t a1, const __CFData *cf)
{
  if (cf && (CFTypeID v4 = CFGetTypeID(cf), v4 == CFDataGetTypeID()))
  {
    BytePtr = CFDataGetBytePtr(cf);
    unsigned int Length = CFDataGetLength(cf);
    if (Length >= 0x11)
    {
      if (!strncmp((const char *)BytePtr, "Exif", 5uLL))
      {
        uint64_t MetadataFromDatabuffer = CreateMetadataFromDatabuffer((const char *)BytePtr + 6, Length - 6);
        if (MetadataFromDatabuffer)
        {
          CFDictionaryRef v8 = (const __CFDictionary *)MetadataFromDatabuffer;
          CGColorSpaceRelease(*(CGColorSpaceRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
          *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = createColorSpaceFromMetadata(v8, 0, 0);
          CFRelease(v8);
        }
      }
      else if (Length >= 0x81 && !strncmp((const char *)BytePtr, "ICC_PROFILE", 0xCuLL))
      {
        CGColorSpaceRelease(*(CGColorSpaceRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CGColorSpaceCreateWithCopyOfData((UInt8 *)BytePtr + 14, Length - 14);
      }
    }
  }
  else
  {
    LogError("CGImageCreateColorSpaceFromDataArray_block_invoke", 794, "*** ERROR: dataArray does not contain CFData\n");
  }
}

void GPSCopy::~GPSCopy(GPSCopy *this)
{
  int v2 = (void *)*((void *)this + 4);
  if (v2) {
    free(v2);
  }
  CFStringRef v3 = (void *)*((void *)this + 7);
  if (v3) {
    free(v3);
  }
}

uint64_t GPSCopy::read32(GPSCopy *this, unsigned __int8 *a2)
{
  int v2 = *a2;
  int v3 = a2[1];
  int v4 = a2[2];
  int v5 = a2[3];
  unsigned int v6 = (v2 << 24) | (v3 << 16) | (v4 << 8) | v5;
  unsigned int v7 = v2 | (v3 << 8) | (v4 << 16) | (v5 << 24);
  if (*((unsigned char *)this + 24)) {
    return v7;
  }
  else {
    return v6;
  }
}

uint64_t GPSCopy::adjustIFDOffsets(uint64_t result, uint64_t a2, int a3, int a4)
{
  if (a3 >= 1)
  {
    int v4 = *(unsigned __int8 *)(result + 24);
    int v5 = (unsigned int *)(a2 + 8);
    do
    {
      unsigned int v6 = bswap32(*((unsigned __int16 *)v5 - 4)) >> 16;
      if (v4) {
        LOWORD(v6) = *((_WORD *)v5 - 4);
      }
      unsigned int v7 = bswap32(*((unsigned __int16 *)v5 - 3)) >> 16;
      if (v4) {
        LOWORD(v7) = *((_WORD *)v5 - 3);
      }
      unsigned int v8 = *v5;
      unsigned int v9 = bswap32(*v5);
      if (!v4) {
        unsigned int v8 = v9;
      }
      unsigned __int16 v10 = v7 - 1;
      uint64_t result = v10;
      if (v10 > 0xBu
        || ((LODWORD(result) = *(v5 - 1), unsigned int v11 = bswap32(result), v4) ? (result = result) : (result = v11),
            (int)result * dword_1889AADF4[v10] <= 4))
      {
        if ((unsigned __int16)v6 > 0x8824u)
        {
          if ((unsigned __int16)v6 != 40965 && (unsigned __int16)v6 != 34853) {
            goto LABEL_28;
          }
        }
        else if ((unsigned __int16)v6 != 513 && (unsigned __int16)v6 != 34665)
        {
          goto LABEL_28;
        }
      }
      unsigned int v14 = v8 + a4;
      unsigned int v15 = bswap32(v14);
      if (!v4) {
        unsigned int v14 = v15;
      }
      unsigned int *v5 = v14;
LABEL_28:
      v5 += 3;
      --a3;
    }
    while (a3);
  }
  return result;
}

uint64_t GPSCopy::readInputFile(GPSCopy *this, CFStringRef string)
{
  CFIndex MaximumSizeOfFileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(string);
  int v5 = (char *)malloc_type_malloc(MaximumSizeOfFileSystemRepresentation, 0x9671A779uLL);
  memset(&v11, 0, sizeof(v11));
  if (CFStringGetFileSystemRepresentation(string, v5, MaximumSizeOfFileSystemRepresentation))
  {
    if (stat(v5, &v11))
    {
      unsigned int v6 = 0;
LABEL_4:
      uint64_t v7 = 1;
      goto LABEL_6;
    }
    unsigned int v6 = fopen(v5, "r");
    if (!v6) {
      goto LABEL_4;
    }
    st_size_t size = v11.st_size;
    *((void *)this + 5) = v11.st_size;
    if (st_size)
    {
      unsigned __int16 v10 = malloc_type_malloc(st_size, 0x15A650E8uLL);
      *((void *)this + 4) = v10;
      if (v10)
      {
        uint64_t v7 = 1;
        fread(v10, *((void *)this + 5), 1uLL, v6);
      }
      else
      {
        uint64_t v7 = 0;
      }
    }
    else
    {
      uint64_t v7 = 0;
      *((void *)this + 4) = 0;
    }
  }
  else
  {
    uint64_t v7 = 0;
    unsigned int v6 = 0;
  }
LABEL_6:
  if (v5) {
    free(v5);
  }
  if (v6) {
    fclose(v6);
  }
  return v7;
}

BOOL GPSCopy::writeOutputFile(GPSCopy *this, CFStringRef string)
{
  CFIndex MaximumSizeOfFileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(string);
  int v5 = (char *)malloc_type_malloc(MaximumSizeOfFileSystemRepresentation, 0xE153EB21uLL);
  FileSystemRepresentatiouint64_t n = CFStringGetFileSystemRepresentation(string, v5, MaximumSizeOfFileSystemRepresentation);
  if (FileSystemRepresentation)
  {
    uint64_t v7 = fopen(v5, "w");
    if (v7) {
      fwrite(*((const void **)this + 4), *((void *)this + 6), 1uLL, v7);
    }
    if (v5) {
      goto LABEL_5;
    }
  }
  else
  {
    uint64_t v7 = 0;
    if (v5) {
LABEL_5:
    }
      free(v5);
  }
  if (v7) {
    fclose(v7);
  }
  return FileSystemRepresentation != 0;
}

uint64_t GPSCopy::processData(GPSCopy *this)
{
  uint64_t v1 = (unsigned __int8 *)*((void *)this + 4);
  int v2 = *v1;
  int v3 = v1[1];
  int v4 = *((unsigned __int8 *)this + 24);
  int v5 = v2 | (v3 << 8);
  int v6 = v3 | (v2 << 8);
  if (*((unsigned char *)this + 24)) {
    int v6 = v5;
  }
  if (v6 != 65496) {
    return 0;
  }
  int v7 = v1[2];
  int v8 = v1[3];
  int v9 = v7 | (v8 << 8);
  int v10 = v8 | (v7 << 8);
  if (*((unsigned char *)this + 24)) {
    int v10 = v9;
  }
  if (v10 != 65505) {
    return 0;
  }
  int v12 = v1[4];
  int v13 = v1[5];
  int v14 = v12 | (v13 << 8);
  int v15 = v13 | (v12 << 8);
  if (*((unsigned char *)this + 24)) {
    int v16 = v14;
  }
  else {
    int v16 = v15;
  }
  int v17 = v1[12];
  int v18 = v1[13];
  int v19 = v17 | (v18 << 8);
  int v20 = v18 | (v17 << 8);
  if (*((unsigned char *)this + 24)) {
    int v20 = v19;
  }
  if (v20 != 19789)
  {
    if (v20 != 18761) {
      return 0;
    }
    int v4 = 1;
    *((unsigned char *)this + 24) = 1;
  }
  *((void *)this + 7) = CreateGPSBufferFromPropertiesTIFFNew(*((IIODictionary **)this + 2), 0, 0, 0, v4 != 0, (unint64_t *)this + 8);
  unint64_t v21 = (*((void *)this + 8) & 1) + *((void *)this + 8);
  CFTypeID v22 = (unsigned __int8 *)reallocf(*((void **)this + 4), v21 + *((void *)this + 5) + 12);
  *((void *)this + 4) = v22;
  unsigned int v23 = GPSCopy::read32(this, v22 + 16);
  CGImageMetadataTagRef v24 = &v22[v23];
  int v25 = v24[12];
  int v26 = v24[13];
  int v27 = *((unsigned __int8 *)this + 24);
  int v28 = v25 | (v26 << 8);
  int v29 = v26 | (v25 << 8);
  if (*((unsigned char *)this + 24)) {
    int v29 = v28;
  }
  if (!v29) {
    return 0;
  }
  uint64_t v30 = 0;
  uint64_t v31 = v23;
  while (1)
  {
    unsigned int v32 = *(unsigned __int16 *)&v24[v30 + 14];
    unsigned int v33 = bswap32(v32) >> 16;
    if (!*((unsigned char *)this + 24)) {
      LOWORD(v32) = v33;
    }
    if ((unsigned __int16)v32 != 34665) {
      break;
    }
    if (12 * v29 - 12 == v30)
    {
      CFStringRef v40 = (char *)&v24[v30];
      LODWORD(v41) = *(_DWORD *)&v24[v30 + 22];
      unsigned int v42 = bswap32(v41);
      if (*((unsigned char *)this + 24)) {
        uint64_t v41 = v41;
      }
      else {
        uint64_t v41 = v42;
      }
      int v81 = v16;
      CGImageMetadataTagRef v43 = &v22[v41];
      unsigned __int16 v44 = v29 + 1;
      unsigned int v45 = bswap32(v29 + 1) >> 16;
      if (*((unsigned char *)this + 24)) {
        __int16 v46 = v29 + 1;
      }
      else {
        __int16 v46 = v45;
      }
      *((_WORD *)v24 + 6) = v46;
      GPSCopy::adjustIFDOffsets((uint64_t)this, (uint64_t)(v24 + 14), v44, 12);
      int v47 = v43[12];
      int v48 = v43[13];
      int v49 = v47 | (v48 << 8);
      int v50 = v48 | (v47 << 8);
      if (*((unsigned char *)this + 24)) {
        int v51 = v49;
      }
      else {
        int v51 = v50;
      }
      GPSCopy::adjustIFDOffsets((uint64_t)this, (uint64_t)(v43 + 14), v51, 12);
      uint64_t v52 = GPSCopy::read32(this, (unsigned __int8 *)v40 + 26) + 12;
      CGImageMetadataType v53 = (unsigned __int8 *)*((void *)this + 7);
      int v54 = *v53;
      int v55 = v53[1];
      int v56 = v54 | (v55 << 8);
      int v57 = v55 | (v54 << 8);
      if (*((unsigned char *)this + 24)) {
        int v58 = v56;
      }
      else {
        int v58 = v57;
      }
      GPSCopy::adjustIFDOffsets((uint64_t)this, (uint64_t)(v53 + 2), v58, v52);
      uint64_t v60 = *((void *)this + 4);
      uint64_t v59 = *((void *)this + 5);
      memmove(v40 + 38, v40 + 26, v60 + v59 - (void)&v22[v31] - v30 - 26);
      BOOL v61 = *((unsigned char *)this + 24) == 0;
      *((void *)this + 5) = v59 + 12;
      if (v61) {
        __int16 v62 = 9608;
      }
      else {
        __int16 v62 = -30683;
      }
      if (v61) {
        __int16 v63 = 1024;
      }
      else {
        __int16 v63 = 4;
      }
      if (v61) {
        int v64 = 0x1000000;
      }
      else {
        int v64 = 1;
      }
      unsigned int v65 = bswap32(v52);
      if (!v61) {
        unsigned int v65 = v52;
      }
      *((_WORD *)v40 + 13) = v62;
      *((_WORD *)v40 + 14) = v63;
      *(_DWORD *)(v40 + 30) = v64;
      *(_DWORD *)(v40 + 34) = v65;
      unsigned int v66 = v52 + v21;
      unsigned int v67 = bswap32(v52 + v21);
      if (v61) {
        unsigned int v66 = v67;
      }
      *(_DWORD *)(v40 + 38) = v66;
      memmove((void *)(v60 + v52 + 12 + v21), (const void *)(v60 + v52 + 12), v59 - v52);
      memcpy((void *)(v60 + v52 + 12), *((const void **)this + 7), *((void *)this + 8));
      uint64_t v68 = *((void *)this + 4);
      *((void *)this + 6) = *((void *)this + 5) + v21;
      uint64_t v69 = v68 + v21 + v52;
      LODWORD(v68) = *(unsigned __int8 *)(v69 + 12);
      int v70 = *(unsigned __int8 *)(v69 + 13);
      int v71 = v68 | (v70 << 8);
      int v72 = v70 | (v68 << 8);
      if (*((unsigned char *)this + 24)) {
        int v73 = v71;
      }
      else {
        int v73 = v72;
      }
      GPSCopy::adjustIFDOffsets((uint64_t)this, v69 + 14, v73, v21 + 12);
      *(_WORD *)(*((void *)this + 4) + 4) = bswap32(v21 + 12 + v81) >> 16;
      return 1;
    }
LABEL_25:
    v30 += 12;
    if (12 * v29 == v30) {
      return 0;
    }
  }
  if ((unsigned __int16)v32 != 34853) {
    goto LABEL_25;
  }
  CGImageMetadataType v34 = (char *)&v24[v30];
  __int16 v35 = (unsigned __int8 *)(v34 + 26);
  unsigned int v36 = *(_DWORD *)(v34 + 22);
  unsigned int v37 = bswap32(v36);
  if (*((unsigned char *)this + 24)) {
    unsigned int v38 = v36;
  }
  else {
    unsigned int v38 = v37;
  }
  if (v21 < GPSCopy::read32(this, v35) - v38)
  {
    LogError("processData", 379, "GPS info is already present...\n");
    return 0;
  }
  int v74 = &v22[v38 + 12];
  int v75 = (unsigned __int8 *)*((void *)this + 7);
  int v76 = *v75;
  int v77 = v75[1];
  int v78 = v76 | (v77 << 8);
  int v79 = v77 | (v76 << 8);
  if (v27) {
    int v80 = v78;
  }
  else {
    int v80 = v79;
  }
  GPSCopy::adjustIFDOffsets((uint64_t)this, (uint64_t)(v75 + 2), v80, v38);
  memcpy(v74, *((const void **)this + 7), *((void *)this + 8));
  *((void *)this + 6) = *((void *)this + 5);
  return 1;
}

BOOL GPSCopy::copyFileWithGPSInformation(const __CFString **this)
{
  if (!GPSCopy::readInputFile((GPSCopy *)this, *this)
    || !GPSCopy::processData((GPSCopy *)this))
  {
    return 0;
  }
  CFStringRef v2 = this[1];
  if (!v2) {
    CFStringRef v2 = *this;
  }

  return GPSCopy::writeOutputFile((GPSCopy *)this, v2);
}

uint64_t CGImageCopyFileWithGPSInformation(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCopyFileWithGPSInformation", 0, 0, -1, a3);
  }
  if (a1)
  {
    memset(v6, 0, sizeof(v6));
    IIODictionary::IIODictionary((IIODictionary *)v6, a3);
    operator new();
  }
  kdebug_trace();
  return 0;
}

void sub_18878A85C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void IIO_Reader_KTX::createReadPlugin()
{
}

{
  operator new();
}

void sub_18878A8D8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4075B25E31);
  _Unwind_Resume(a1);
}

void sub_18878A978(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4075B25E31);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_KTX::updateSourceProperties(IIO_Reader_KTX *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v33 = 0;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v29, a2);
  long long v35 = 0u;
  long long v36 = 0u;
  uint64_t v7 = 4294967246;
  memset(__dst, 0, sizeof(__dst));
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v29, __dst, 0, 0x40uLL) == 64)
  {
    SwapKTXHeader(__dst);
    uint64_t v7 = ValidateKTXHeader(__dst, v30);
    if (!v7)
    {
      GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)&v29, __dst[0].i32[3] == 67305985);
      if (DWORD1(v36) == 1) {
        int v8 = v36;
      }
      else {
        int v8 = 1;
      }
      if (v36) {
        int v9 = v8;
      }
      else {
        int v9 = DWORD1(v36);
      }
      IIONumber::IIONumber((IIONumber *)&v26, v9);
      IIODictionary::setObjectForKeyGroup(a3, v28, "ImageCount", "{FilesContents}");
      IIONumber::~IIONumber((IIONumber *)&v26);
      uint64_t v26 = 0;
      int v27 = 0;
      int v28 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v26);
      IIONumber::IIONumber((IIONumber *)&v23, SDWORD1(v35));
      IIODictionary::setObjectForKey((IIODictionary *)&v26, v25, "Width");
      IIONumber::~IIONumber((IIONumber *)&v23);
      IIONumber::IIONumber((IIONumber *)&v23, SDWORD2(v35));
      IIODictionary::setObjectForKey((IIODictionary *)&v26, v25, "Height");
      IIONumber::~IIONumber((IIONumber *)&v23);
      CFMutableArrayRef v23 = 0;
      CGImageMetadataTagRef v24 = 0;
      int v25 = 0;
      IIOArray::IIOArray((IIOArray *)&v23);
      for (; v9; --v9)
        IIOArray::addObject(&v23, v27);
      IIODictionary::setObjectForKeyGroup(a3, v24, "Images", "{FilesContents}");
      int v10 = DWORD2(v36);
      CFMutableArrayRef v20 = 0;
      unint64_t v21 = 0;
      uint64_t v22 = 0;
      IIOArray::IIOArray((IIOArray *)&v20);
      if (v10)
      {
        unsigned int v12 = DWORD1(v35);
        unsigned int v11 = DWORD2(v35);
        int v13 = v10;
        do
        {
          uint64_t v17 = 0;
          int v18 = 0;
          int v19 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v17);
          IIONumber::IIONumber((IIONumber *)v15, v12);
          IIODictionary::setObjectForKey((IIODictionary *)&v17, v16, "Width");
          IIONumber::~IIONumber((IIONumber *)v15);
          IIONumber::IIONumber((IIONumber *)v15, v11);
          IIODictionary::setObjectForKey((IIODictionary *)&v17, v16, "Height");
          IIONumber::~IIONumber((IIONumber *)v15);
          IIOArray::addObject(&v20, v18);
          IIODictionary::~IIODictionary((IIODictionary *)&v17);
          if (v12 < 2) {
            break;
          }
          if (v11 <= 1) {
            break;
          }
          v11 >>= 1;
          v12 >>= 1;
          --v13;
        }
        while (v13);
      }
      IIONumber::IIONumber((IIONumber *)&v17, v10);
      IIODictionary::setObjectForKeyGroup(a3, v19, "MipMapCount", "{MipMapInfo}");
      IIONumber::~IIONumber((IIONumber *)&v17);
      IIODictionary::setObjectForKeyGroup(a3, v21, "MipMaps", "{MipMapInfo}");
      IIOArray::~IIOArray((IIOArray *)&v20);
      IIOArray::~IIOArray((IIOArray *)&v23);
      IIODictionary::~IIODictionary((IIODictionary *)&v26);
      uint64_t v7 = 0;
    }
  }
  IIOScanner::~IIOScanner((IIOScanner *)&v29);
  return v7;
}

void sub_18878ACA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,char a22)
{
  if (a2)
  {
    IIOArray::~IIOArray((IIOArray *)&a16);
    IIOArray::~IIOArray((IIOArray *)&a19);
    IIODictionary::~IIODictionary((IIODictionary *)&a22);
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x18878AC60);
  }
  _Unwind_Resume(exception_object);
}

void sub_18878ADA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  JUMPOUT(0x18878AD1CLL);
}

uint64_t IIO_Reader_KTX::hasCustomImageCountProc(IIO_Reader_KTX *this)
{
  return 1;
}

uint64_t IIO_Reader_KTX::hasCustomSourcePropertiesProc(IIO_Reader_KTX *this)
{
  return 1;
}

void ATXWritePlugin::~ATXWritePlugin(ATXWritePlugin *this, uint64_t a2, const char *a3)
{
  *(void *)this = &unk_1ED4E1020;
  uint64_t v4 = *((void *)this + 9);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }

  CommonASTCWritePlugin::~CommonASTCWritePlugin(this, a2, a3);
}

{
  uint64_t vars8;

  ATXWritePlugin::~ATXWritePlugin(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t ATXWritePlugin::updateHeader(uint64_t a1, IIOImageSource *a2, uint64_t a3, uint64_t a4)
{
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 56))(a1, a3);
  if (gUseATXForKTX) {
    *(_WORD *)(a1 + 57) = 256;
  }
  *(_DWORD *)a4 = 1;
  *(_DWORD *)(a1 + 64) = IIOImageSource::count(a2);
  *(_DWORD *)(a1 + 68) = IIO_Reader::testHeaderSize(a2);
  int AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a2);
  *(void *)(a4 + 24) = *(void *)(a1 + 64);
  *(_DWORD *)(a4 + 32) = 1;
  *(_DWORD *)(a4 + 4) = 0;
  *(void *)(a4 + 8) = 0;
  int v8 = *(_DWORD *)(a1 + 44);
  if (v8 == 68)
  {
    int v9 = 37808;
  }
  else
  {
    if (v8 != 136) {
      goto LABEL_8;
    }
    int v9 = 37815;
  }
  *(_DWORD *)(a4 + 16) = v9;
LABEL_8:
  SourceGeomCGColorSpaceRef ColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  uint64_t result = IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E4F1DB90]);
  if (result)
  {
    int v12 = 3;
  }
  else
  {
    uint64_t result = IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E4F1DBE8]);
    if (result)
    {
      int v12 = 4;
    }
    else
    {
      uint64_t result = IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E4F1DB78]);
      if (result) {
        int v12 = 2;
      }
      else {
        int v12 = 1;
      }
    }
  }
  *(_DWORD *)(a4 + 20) = 6408;
  *(void *)(a4 + 36) = 0x100000000;
  int v13 = *(unsigned __int8 *)(a1 + 58);
  *(_DWORD *)(a4 + 44) = 1;
  *(_DWORD *)(a4 + 48) = v13;
  *(_DWORD *)(a4 + 52) = *(unsigned __int8 *)(a1 + 57);
  *(_DWORD *)(a4 + 56) = 1;
  if (v13)
  {
    ATXWritePlugin::createASTCTwiddler(a1);
    uint64_t result = ASTCTwiddler::getWatermark(*(ASTCTwiddler **)(a1 + 72), (unsigned __int8 *)(a4 + 60));
  }
  else
  {
    memset((void *)(a4 + 60), 85, 16);
  }
  *(_DWORD *)(a4 + 76) = v12;
  *(_DWORD *)(a4 + 80) = AlphaInfo;
  return result;
}

uint64_t ATXWritePlugin::createASTCTwiddler(uint64_t this)
{
  if (!*(void *)(this + 72))
  {
    int v1 = *(_DWORD *)(this + 44);
    if (v1 == 136) {
      unsigned int v2 = 37815;
    }
    else {
      unsigned int v2 = 0;
    }
    if (v1 == 68) {
      uint64_t v3 = 37808;
    }
    else {
      uint64_t v3 = v2;
    }
    ASTCTextureImp::MetalFormatForGLFormat((ASTCTextureImp *)v3);
    operator new();
  }
  return this;
}

void sub_18878B09C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

uint64_t ATXWritePlugin::writeASTCData(ATXWritePlugin *this, IIOImageWriteSession *a2, IIOImagePixelDataProvider *a3, IIODictionary *a4)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  unsigned int AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a3);
  __int16 BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(a3);
  if (AlphaInfo >= 7)
  {
    _cg_jpeg_mem_term("writeASTCData", 225, "### alpha not handled: %X\n", AlphaInfo);
    at_alpha_t v9 = at_alpha_opaque;
  }
  else
  {
    at_alpha_t v9 = dword_1889AAEAC[AlphaInfo];
  }
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    int v10 = IIO_AlphaInfoString(AlphaInfo);
    ImageIOLog("    writeASTCData: alpha = %s\n", v10);
  }
  int v11 = *((_DWORD *)this + 11);
  if (v11 == 68)
  {
    int v12 = 4;
  }
  else
  {
    if (v11 == 136)
    {
      int v12 = 8;
      at_block_format_t v13 = at_block_format_astc_8x8_ldr;
      goto LABEL_12;
    }
    LogError("writeASTCData", 252, "blockSize: '%02X' not yet supported - falling back to '44'\n", *((_DWORD *)this + 11));
    *(void *)((char *)this + 44) = 0x400000044;
    int v12 = 4;
    *((_DWORD *)this + 13) = 4;
  }
  at_block_format_t v13 = at_block_format_astc_4x4_ldr;
LABEL_12:
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    writeASTCData: blockunint64_t Size = %dx%d\n", v12, v12);
  }
  SourceGeomCGColorSpaceRef ColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a3);
  CGColorSpaceModel Model = CGColorSpaceGetModel(SourceGeomColorSpace);
  int Error = _cg_GifLastError((uint64_t)a3);
  if (Model == kCGColorSpaceModelRGB)
  {
    uint64_t v18 = 10;
    if ((BitmapInfo & 0x100) == 0) {
      uint64_t v18 = 7;
    }
    if (Error == 16) {
      at_texel_format_t v17 = v18;
    }
    else {
      at_texel_format_t v17 = at_texel_format_rgba8_unorm;
    }
  }
  else if (Model)
  {
    at_texel_format_t v17 = at_texel_format_invalid;
  }
  else if (Error == 16)
  {
    if (AlphaInfo) {
      at_texel_format_t v17 = at_texel_format_la16_unorm;
    }
    else {
      at_texel_format_t v17 = at_texel_format_l16_unorm;
    }
  }
  else if (AlphaInfo)
  {
    at_texel_format_t v17 = at_texel_format_la8_unorm;
  }
  else
  {
    at_texel_format_t v17 = at_texel_format_l8_unorm;
  }
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    writeASTCData: bpc = %d\n", Error);
  }
  __int16 v46 = 0;
  at_encoder_t v19 = at_encoder_create(v17, v9, v13, v9, 0);
  if (!v19) {
    return 4294967246;
  }
  CFMutableArrayRef v20 = v19;
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    writeASTCData: astcEncoder = %p\n", v19);
  }
  size_t v21 = IIOImagePlus::sourceImageProvider(a3);
  size_t v22 = v21 * *((unsigned int *)this + 17);
  CFMutableArrayRef v23 = malloc_type_malloc(v22, 0xAEE1A442uLL);
  if (!v23)
  {
    CFRelease(v20);
    return 4294967246;
  }
  CGImageMetadataTagRef v24 = v23;
  if (IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a3, v23) != v22)
  {
    LogError("writeASTCData", 330, "*** ERROR: failed to read %ld bytes\n", v22);
    CFRelease(v20);
    free(v24);
    return 4294967185;
  }
  src.texels = v24;
  *(void *)&src.validSize.double x = *((void *)this + 8);
  *((_DWORD *)&src.validSize + 3) = 0;
  src.size_t rowBytes = v21;
  src.validSize.z = 1;
  src.sliceuint64_t Bytes = 0;
  *(void *)&v50.double x = *(void *)&src.validSize.x;
  v50.z = 1;
  unint64_t block_counts = (unint64_t)at_encoder_get_block_counts(v20, v50);
  unsigned int v26 = block_counts;
  unint64_t v27 = HIDWORD(block_counts);
  block_size_t size = at_encoder_get_block_size(v20);
  size_t v29 = v27 * v26 * block_size;
  dest.size_t rowBytes = v26 * block_size;
  dest.sliceuint64_t Bytes = v29;
  long long v30 = malloc_type_calloc(v29, 1uLL, 0x63F854FEuLL);
  long long v31 = v30;
  if (!v30) {
    goto LABEL_44;
  }
  dest.blocks = v30;
  if (*((unsigned char *)this + 61)) {
    at_flags_t v32 = (16 * *((unsigned __int8 *)this + 60)) | 0x40;
  }
  else {
    at_flags_t v32 = 16 * *((unsigned __int8 *)this + 60);
  }
  float v33 = at_encoder_compress_texels(v20, &src, &dest, *((float *)this + 10), v32);
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    writeASTCData: at_encoder_compress_texels = %g\n", v33);
  }
  if (v33 >= 0.0)
  {
    size_t __nitems = 0;
    int v48 = 0;
    uint64_t __ptr = 0;
    if (*((unsigned char *)this + 58))
    {
      ATXWritePlugin::createASTCTwiddler((uint64_t)this);
      ASTCTwiddler::copyFromLinearData(*((ASTCTwiddler **)this + 9), v31, 0, v29, dest.rowBytes, 0);
      ASTCTwiddler::finalizeTwiddling(*((ASTCTwiddler **)this + 9));
      long long v35 = (const void *)ASTCTwiddler::twiddledData(*((ASTCTwiddler **)this + 9));
      uint64_t v36 = ASTCTwiddler::twiddledDataSize(*((ASTCTwiddler **)this + 9));
      *((unsigned char *)this + 57) = 0;
      HIDWORD(__ptr) = 1668576097;
      if (v35)
      {
        size_t v37 = v36;
        LODWORD(__ptr) = v36 + 4;
        int v48 = v36;
        if (IIOImageWriteSession::putBytes(a2, &__ptr, 0xCuLL) != 12)
        {
          LogError("writeASTCData", 455, "*** failed to write 'astc' header\n", v41, v42);
          goto LABEL_44;
        }
        if (IIOImageWriteSession::putBytes(a2, v35, v37) != v37)
        {
          LogError("writeASTCData", 461, "*** failed to write 'astc' data\n", v41, v42);
          goto LABEL_44;
        }
LABEL_59:
        uint64_t v34 = 0;
        goto LABEL_60;
      }
    }
    else if (*((unsigned char *)this + 57))
    {
      BOOL v38 = IIOWritePlugin::createLZFSECompressedData(this, (unsigned __int8 *)v31, v29, &v46, (unsigned __int8 **)&__nitems);
      HIDWORD(__ptr) = 1397119564;
      if (v38)
      {
        LODWORD(__ptr) = __nitems + 4;
        int v48 = __nitems;
        if (IIOImageWriteSession::putBytes(a2, &__ptr, 0xCuLL) != 12)
        {
          LogError("writeASTCData", 471, "*** failed to write 'LZFSE' header\n");
          goto LABEL_44;
        }
        size_t v39 = IIOImageWriteSession::putBytes(a2, v46, __nitems);
        if (v39 != __nitems)
        {
          LogError("writeASTCData", 477, "*** failed to write 'LZFSE' data\n", v41, v42);
          goto LABEL_44;
        }
        goto LABEL_59;
      }
    }
    else
    {
      HIDWORD(__ptr) = 1129599809;
    }
    LODWORD(__ptr) = v29 + 4;
    int v48 = v29;
    if (IIOImageWriteSession::putBytes(a2, &__ptr, 0xCuLL) != 12)
    {
      LogError("writeASTCData", 487, "*** failed to write 'ASTC' header\n", v41, v42);
      goto LABEL_44;
    }
    if (IIOImageWriteSession::putBytes(a2, v31, v29) != v29)
    {
      LogError("writeASTCData", 493, "*** failed to write 'ASTC' data\n", v41, v42);
      goto LABEL_44;
    }
    goto LABEL_59;
  }
  LogError("writeASTCData", 377, "at_encoder_compress_texels - %g (%ld)\n");
LABEL_44:
  uint64_t v34 = 4294967246;
LABEL_60:
  if (v46) {
    free(v46);
  }
  CFRelease(v20);
  if (v31) {
    free(v31);
  }
  free(v24);
  return v34;
}