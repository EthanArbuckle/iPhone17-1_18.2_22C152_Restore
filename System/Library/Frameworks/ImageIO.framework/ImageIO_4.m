uint64_t ATXWritePlugin::convertAndWrite420fData(ATXWritePlugin *this, IIOImagePixelDataProvider *a2, unsigned __int8 *a3, unsigned int a4, char a5, double a6, double a7)
{
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char v14;
  void *v15;
  void *v16;
  void *v17;
  BOOL v18;
  vImagePixelCount v19;
  vImagePixelCount v20;
  int8x16_t v21;
  vImage_Error v22;
  vImage_Error v23;
  const char *v24;
  unint64_t v26;
  unsigned __int8 *v27;
  vImage_Buffer destCbCr;
  vImage_Buffer destYp;
  vImage_Buffer src;
  float64x2_t v31;
  long long v32;
  float64x2_t v33[2];
  uint8_t permuteMap[4];
  unsigned char __ptr[12];
  int32x2_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)permuteMap = 33619971;
  memset(v33, 0, sizeof(v33));
  v31 = 0u;
  v32 = 0u;
  LODWORD(a7) = *((_DWORD *)this + 17);
  v11 = IIO_FillGeometry420(875704422, 0x10u, (uint64_t)&v31, (double)*((unsigned int *)this + 16), (double)*(unint64_t *)&a7, 16.0, 16.0);
  if (v11)
  {
    _cg_jpeg_mem_term("convertAndWrite420fData", 532, "*** ERROR: bad input for creating '420f' data (%dx%d)\n");
    return v11;
  }
  v12 = DWORD1(v32) * (unint64_t)v31.f64[1];
  if ((v12 & 0xFFFFFFFF00000000) != 0 || !v12)
  {
    _cg_jpeg_mem_term("convertAndWrite420fData", 535, "*** ERROR: convertAndWrite420fData unsupported lumaSize (%d)\n");
    return v11;
  }
  v13 = LODWORD(v33[1].f64[1]) * (unint64_t)v33[1].f64[0];
  if ((v13 & 0xFFFFFFFF00000000) != 0 || !v13)
  {
    _cg_jpeg_mem_term("convertAndWrite420fData", 538, "*** ERROR: convertAndWrite420fData unsupported chromaSize (%d)\n");
    return v11;
  }
  v14 = a5;
  v15 = malloc_type_malloc(v12, 0x2ED60EF6uLL);
  v16 = malloc_type_malloc(v13, 0x3FB7FD39uLL);
  v17 = v16;
  if (v15) {
    v18 = v16 == 0;
  }
  else {
    v18 = 1;
  }
  if (!v18)
  {
    v20 = *((unsigned int *)this + 16);
    v19 = *((unsigned int *)this + 17);
    src.data = a3;
    src.height = v19;
    src.width = v20;
    src.rowBytes = a4;
    destYp.data = v15;
    destYp.height = v19;
    destYp.width = v20;
    destYp.rowBytes = DWORD1(v32);
    destCbCr.data = v16;
    v21 = (int8x16_t)vcvtq_u64_f64(*(float64x2_t *)((char *)v33 + 8));
    *(int8x16_t *)&destCbCr.height = vextq_s8(v21, v21, 8uLL);
    destCbCr.rowBytes = LODWORD(v33[1].f64[1]);
    if (ATXWritePlugin::convertAndWrite420fData(IIOImagePixelDataProvider *,unsigned char *,unsigned int,BOOL)::ARGBToYpCbCrCreate != -1) {
      dispatch_once(&ATXWritePlugin::convertAndWrite420fData(IIOImagePixelDataProvider *,unsigned char *,unsigned int,BOOL)::ARGBToYpCbCrCreate, &__block_literal_global_27);
    }
    v22 = vImageConvert_ARGB8888To420Yp8_CbCr8(&src, &destYp, &destCbCr, &ATXWritePlugin::convertAndWrite420fData(IIOImagePixelDataProvider *,unsigned char *,unsigned int,BOOL)::conversion, permuteMap, 0x10u);
    if (v22)
    {
      v23 = v22;
      v24 = IIO_vImageErrorString(v22);
      _cg_jpeg_mem_term("convertAndWrite420fData", 574, "*** ERROR: vImageConvert_ARGB8888To420Yp8_CbCr8 returned %ld (%s)\n", v23, v24);
    }
    else if (v14)
    {
      v26 = 0;
      v27 = 0;
      *(void *)&__ptr[4] = 0x616D756C5A303234;
      v36 = vmovn_s64((int64x2_t)vcvtq_u64_f64(v31));
      v37 = DWORD1(v32);
      LODWORD(v38) = 1397119564;
      IIOWritePlugin::createLZFSECompressedData(this, (unsigned __int8 *)destYp.data, v12, &v27, (unsigned __int8 **)&v26);
      *(_DWORD *)__ptr = v26 + 24;
      HIDWORD(v38) = v26;
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), __ptr, 0x20uLL);
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), v27, v26);
      free(v27);
      ATXWritePlugin::writeFiller((IIOImageWriteSession **)this, 0x40u, 0x20u);
      *(void *)__ptr = 0x5A30323400000000;
      v36 = vmovn_s64((int64x2_t)vcvtq_u64_f64(*(float64x2_t *)((char *)v33 + 8)));
      *(_DWORD *)&__ptr[8] = 1836214371;
      v37 = LODWORD(v33[1].f64[1]);
      v38 = 1397119564;
      IIOWritePlugin::createLZFSECompressedData(this, (unsigned __int8 *)destCbCr.data, v13, &v27, (unsigned __int8 **)&v26);
      *(_DWORD *)__ptr = v26 + 24;
      HIDWORD(v38) = v26;
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), __ptr, 0x20uLL);
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), v27, v26);
      free(v27);
    }
    else
    {
      *(void *)&__ptr[4] = 0x414D554C66303234;
      v36 = vmovn_s64((int64x2_t)vcvtq_u64_f64(v31));
      *(_DWORD *)__ptr = v12 + 16;
      v37 = DWORD1(v32);
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), __ptr, 0x18uLL);
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), destYp.data, v12);
      ATXWritePlugin::writeFiller((IIOImageWriteSession **)this, 0x100u, 0x18u);
      *(void *)&__ptr[4] = 0x4D52484366303234;
      v36 = vmovn_s64((int64x2_t)vcvtq_u64_f64(*(float64x2_t *)((char *)v33 + 8)));
      *(_DWORD *)__ptr = v13 + 16;
      v37 = LODWORD(v33[1].f64[1]);
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), __ptr, 0x18uLL);
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), destCbCr.data, v13);
    }
    goto LABEL_20;
  }
  if (v15) {
LABEL_20:
  }
    free(v15);
  v11 = 0;
  if (v17) {
    free(v17);
  }
  return v11;
}

__n128 ___ZN14ATXWritePlugin23convertAndWrite420fDataEP25IIOImagePixelDataProviderPhjb_block_invoke()
{
  vImage_YpCbCrPixelRange pixelRange = *(vImage_YpCbCrPixelRange *)ymmword_1889AAE78;
  vImage_Error v0 = vImageConvert_ARGBToYpCbCr_GenerateConversion((const vImage_ARGBToYpCbCrMatrix *)*MEMORY[0x1E4F167C0], &pixelRange, &ATXWritePlugin::convertAndWrite420fData(IIOImagePixelDataProvider *,unsigned char *,unsigned int,BOOL)::conversion, kvImageARGB8888, kvImage420Yp8_CbCr8, 0);
  if (v0)
  {
    vImage_Error v2 = v0;
    v3 = IIO_vImageErrorString(v0);
    return _cg_jpeg_mem_term("convertAndWrite420fData_block_invoke", 567, "*** ERROR: vImageConvert_ARGBToYpCbCr_GenerateConversion returned %ld (%s)\n", v2, v3);
  }
  return result;
}

uint64_t ATXWritePlugin::writeFiller(IIOImageWriteSession **this, unsigned int a2, unsigned int a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2 <= a3) {
    return 0;
  }
  unint64_t Position = IIOImageWriteSession::getPosition(this[2]);
  unint64_t v7 = Position + a2 - 1 - ((Position + a2 - 1) % a2 + a3);
  do
  {
    unint64_t v8 = v7;
    unint64_t v9 = v7 - 8;
    v7 += a2;
  }
  while (v9 < Position);
  size_t v10 = v8 - Position - 8;
  if (v10 > a2) {
    LogError("writeFiller", 705, "    bad fillSize: %d   alignment: %d   prefix: %d\n", v10, a2, a3);
  }
  __ptr[0] = v10;
  __ptr[1] = 1280067910;
  IIOImageWriteSession::putBytes(this[2], __ptr, 8uLL);
  v11 = malloc_type_calloc(v10, 1uLL, 0x67B8C3CAuLL);
  size_t v12 = IIOImageWriteSession::putBytes(this[2], v11, v10);
  free(v11);
  if (v10 == v12) {
    return 0;
  }
  else {
    return 4294967246;
  }
}

uint64_t ATXWritePlugin::write420fData(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, char a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t Ref = IIOImageSource::imageReadRef(a2);
  CGImageGetImageProvider();
  if (IIO_CGImageWrapsIOSurface(Ref, 1))
  {
    memset(v46, 0, sizeof(v46));
    IIODictionary::IIODictionary((IIODictionary *)v46);
    IIONumber::IIONumber((IIONumber *)&__ptr, 875704422);
    IIODictionary::setObjectForKey((IIODictionary *)v46, value, @"kCGImageSurfaceFormatRequest");
    IIONumber::~IIONumber((IIONumber *)&__ptr);
    unint64_t v8 = (__IOSurface *)CGImageProviderCopyIOSurface();
    unint64_t v9 = v8;
    if (v8)
    {
      int PlaneCount = IOSurfaceGetPlaneCount(v8);
      OSType PixelFormat = IOSurfaceGetPixelFormat(v9);
      if (PixelFormat == 875704422)
      {
        if (a4)
        {
          int v51 = 0;
          unint64_t v44 = 0;
          v45 = 0;
          BaseAddressOfPlane = (unsigned __int8 *)IOSurfaceGetBaseAddressOfPlane(v9, 0);
          unsigned int BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(v9, 0);
          int WidthOfPlane = IOSurfaceGetWidthOfPlane(v9, 0);
          unsigned int HeightOfPlane = IOSurfaceGetHeightOfPlane(v9, 0);
          uint64_t v48 = 0x616D756C5A303234;
          int v49 = WidthOfPlane;
          value = (void *)__PAIR64__(BytesPerRowOfPlane, HeightOfPlane);
          IIOWritePlugin::createLZFSECompressedData((IIOWritePlugin *)this, BaseAddressOfPlane, HeightOfPlane * BytesPerRowOfPlane, &v45, (unsigned __int8 **)&v44);
          int __ptr = v44 + 24;
          int v52 = v44;
          IIOImageWriteSession::putBytes(this[2], &__ptr, 0x20uLL);
          IIOImageWriteSession::putBytes(this[2], v45, v44);
          free(v45);
          ATXWritePlugin::writeFiller(this, 0x40u, 0x20u);
          v16 = (unsigned __int8 *)IOSurfaceGetBaseAddressOfPlane(v9, 1uLL);
          unsigned int v17 = IOSurfaceGetBytesPerRowOfPlane(v9, 1uLL);
          int v18 = IOSurfaceGetWidthOfPlane(v9, 1uLL);
          unsigned int v19 = IOSurfaceGetHeightOfPlane(v9, 1uLL);
          size_t v20 = v19 * v17;
          int __ptr = v20 + 16;
          uint64_t v48 = 0x6D7268635A303234;
          int v49 = v18;
          value = (void *)__PAIR64__(v17, v19);
          uint64_t v21 = IIOWritePlugin::createLZFSECompressedData((IIOWritePlugin *)this, v16, v20, &v45, (unsigned __int8 **)&v44);
          int __ptr = v44 + 24;
          int v52 = v44;
          IIOImageWriteSession::putBytes(this[2], &__ptr, 0x20uLL);
          IIOImageWriteSession::putBytes(this[2], v45, v44);
          free(v45);
          if (!v21) {
            goto LABEL_15;
          }
        }
        else
        {
          int v43 = PlaneCount;
          v22 = IOSurfaceGetBaseAddressOfPlane(v9, 0);
          unsigned int v23 = IOSurfaceGetBytesPerRowOfPlane(v9, 0);
          int v24 = IOSurfaceGetWidthOfPlane(v9, 0);
          unsigned int v25 = IOSurfaceGetHeightOfPlane(v9, 0);
          size_t v26 = v25 * v23;
          int __ptr = v26 + 16;
          uint64_t v48 = 0x414D554C66303234;
          int v49 = v24;
          value = (void *)__PAIR64__(v23, v25);
          IIOImageWriteSession::putBytes(this[2], &__ptr, 0x18uLL);
          IIOImageWriteSession::putBytes(this[2], v22, v26);
          uint64_t v21 = ATXWritePlugin::writeFiller(this, 0x100u, 0x18u);
          v27 = IOSurfaceGetBaseAddressOfPlane(v9, 1uLL);
          LODWORD(v26) = IOSurfaceGetBytesPerRowOfPlane(v9, 1uLL);
          int v28 = IOSurfaceGetWidthOfPlane(v9, 1uLL);
          unsigned int v29 = IOSurfaceGetHeightOfPlane(v9, 1uLL);
          size_t v30 = v29 * v26;
          int __ptr = v30 + 16;
          uint64_t v48 = 0x4D52484366303234;
          int v49 = v28;
          value = (void *)__PAIR64__(v26, v29);
          IIOImageWriteSession::putBytes(this[2], &__ptr, 0x18uLL);
          IIOImageWriteSession::putBytes(this[2], v27, v30);
          int PlaneCount = v43;
          if (!v21) {
            goto LABEL_15;
          }
        }
      }
      else
      {
        uint64_t v21 = 4294967246;
      }
      if ((PlaneCount & 0xFFFFFFFE) == 0 && (PixelFormat == 1380401729 || PixelFormat == 1111970369))
      {
        BaseAddress = (unsigned __int8 *)IOSurfaceGetBaseAddress(v9);
        unsigned int BytesPerRow = IOSurfaceGetBytesPerRow(v9);
        uint64_t v21 = ATXWritePlugin::convertAndWrite420fData((ATXWritePlugin *)this, v33, BaseAddress, BytesPerRow, a4, v34, v35);
      }
LABEL_15:
      IIODictionary::~IIODictionary((IIODictionary *)v46);
      if (!v21) {
        return v21;
      }
      goto LABEL_16;
    }
    IIODictionary::~IIODictionary((IIODictionary *)v46);
  }
  uint64_t v21 = 4294967246;
LABEL_16:
  int v36 = *((_DWORD *)this + 16);
  int v37 = *((_DWORD *)this + 17);
  if (IIOImagePixelDataProvider::getAlphaInfo(a2))
  {
    v38 = malloc_type_malloc((4 * v36 * v37), 0x434E5738uLL);
    IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v38);
    uint64_t v21 = ATXWritePlugin::convertAndWrite420fData((ATXWritePlugin *)this, v39, (unsigned __int8 *)v38, 4 * *((_DWORD *)this + 16), a4, v40, v41);
    free(v38);
  }
  return v21;
}

void sub_18878C124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t ATXWritePlugin::write420f(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  int v21 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v16 = 0u;
  if (a4 && IIODictionary::containsKey(a4, @"kCGImageProperty420fUseLZFSE"))
  {
    unint64_t v8 = a4;
LABEL_7:
    BOOL BoolForKey = IIODictionary::getBoolForKey(v8, @"kCGImageProperty420fUseLZFSE");
    goto LABEL_9;
  }
  if (a3 && IIODictionary::containsKey(a3, @"kCGImageProperty420fUseLZFSE"))
  {
    unint64_t v8 = a3;
    goto LABEL_7;
  }
  BOOL BoolForKey = 0;
LABEL_9:
  uint64_t __ptr = 0xA1A0A0D4C504141;
  IIOImageWriteSession::putBytes(this[2], &__ptr, 8uLL);
  ATXWritePlugin::updateHeader((uint64_t)this, a2, (uint64_t)a3, (uint64_t)&v16);
  *(int32x2_t *)&long long v17 = vdup_n_s32(0x66303234u);
  DWORD1(v19) = BoolForKey;
  uint64_t __ptr = 0x4441454800000054;
  IIOImageWriteSession::putBytes(this[2], &__ptr, 8uLL);
  IIOImageWriteSession::putBytes(this[2], &v16, 0x54uLL);
  if (BoolForKey)
  {
    unsigned int v10 = 64;
    unsigned int v11 = 32;
  }
  else
  {
    unsigned int v10 = 256;
    unsigned int v11 = 24;
  }
  ATXWritePlugin::writeFiller(this, v10, v11);
  uint64_t v13 = ATXWritePlugin::write420fData(this, a2, v12, BoolForKey);
  if (!v13)
  {
    uint64_t __ptr = 0x20444E4500000000;
    IIOImageWriteSession::putBytes(this[2], &__ptr, 8uLL);
  }
  return v13;
}

uint64_t ATXWritePlugin::writeOneImage(ATXWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t ATXWritePlugin::writeOne(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if ((a4
     && (unsigned __int8 v8 = IIODictionary::containsKey(a4, @"kCGImagePropertyEncoder"), v9 = a4, (v8 & 1) != 0)
     || a3 && (v10 = IIODictionary::containsKey(a3, @"kCGImagePropertyEncoder"), unint64_t v9 = a3, v10))
    && (CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(v9, @"kCGImagePropertyEncoder"),
        CFEqual(ObjectForKey, @"kCGImageProperty420fEncoder")))
  {
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    saving ATX-420f image\n");
    }
    return ATXWritePlugin::write420f(this, a2, a3, a4);
  }
  else
  {
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    saving ATX-ASTC image\n");
    }
    int v22 = 0;
    memset(v21, 0, sizeof(v21));
    uint64_t __ptr = 0xA1A0A0D4C504141;
    IIOImageWriteSession::putBytes(this[2], &__ptr, 8uLL);
    ATXWritePlugin::updateHeader((uint64_t)this, a2, (uint64_t)a3, (uint64_t)v21);
    uint64_t __ptr = 0x4441454800000054;
    IIOImageWriteSession::putBytes(this[2], &__ptr, 8uLL);
    IIOImageWriteSession::putBytes(this[2], v21, 0x54uLL);
    unsigned int Position = IIOImageWriteSession::getPosition(this[2]);
    if (*((unsigned char *)this + 58)) {
      int v14 = 0x4000;
    }
    else {
      int v14 = 256;
    }
    int v15 = -20;
    do
      v15 += v14;
    while (v15 + 8 < Position);
    size_t v16 = v15 - Position;
    LODWORD(__ptr) = v15 - Position;
    HIDWORD(__ptr) = 1280067910;
    IIOImageWriteSession::putBytes(this[2], &__ptr, 8uLL);
    long long v17 = malloc_type_calloc(v16, 1uLL, 0xC622C4CBuLL);
    size_t v18 = IIOImageWriteSession::putBytes(this[2], v17, v16);
    free(v17);
    if (v18 == v16)
    {
      uint64_t result = ATXWritePlugin::writeASTCData((ATXWritePlugin *)this, this[2], a2, v19);
      if (!result)
      {
        uint64_t __ptr = 0x20444E4500000000;
        IIOImageWriteSession::putBytes(this[2], &__ptr, 8uLL);
        return 0;
      }
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t ATXWritePlugin::WriteProc(ATXWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  long long v10 = 0u;
  long long v11 = 0u;
  memset(v9, 0, sizeof(v9));
  CommonASTCWritePlugin::CommonASTCWritePlugin((CommonASTCWritePlugin *)v9, this, a2, 32);
  *(void *)&v9[0] = &unk_1ED4E1020;
  BYTE10(v10) = 0;
  *((void *)&v11 + 1) = 0;
  uint64_t v5 = IIOWritePlugin::writeAll((IIOImageDestination **)v9);
  ATXWritePlugin::~ATXWritePlugin((ATXWritePlugin *)v9, v6, v7);
  return v5;
}

void sub_18878C650(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void kdc_flow_control::kdc_flow_control(uint64_t a1, uint64_t a2, unsigned int *a3, int a4, char a5, uint64_t a6)
{
  *(void *)(a1 + 88) = 0;
  long long v17 = a3;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 80) = a3;
  long long v11 = *(_OWORD *)(a2 + 16);
  long long v10 = *(_OWORD *)(a2 + 32);
  uint64_t v12 = *(void *)(a2 + 48);
  *(_OWORD *)(a1 + 16) = *(_OWORD *)a2;
  *(void *)(a1 + 64) = v12;
  *(_OWORD *)(a1 + 48) = v10;
  *(_OWORD *)(a1 + 32) = v11;
  *(_DWORD *)(a1 + 112) = a4;
  kdu_codestream::get_valid_tiles((kdu_codestream *)&v17, (int32x4_t *)(a1 + 88));
  if ((a4 & 0x80000000) == 0 && *(_DWORD *)(a1 + 100) > a4)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    *(void *)(a1 + 104) = v13;
    *(_DWORD *)(a1 + 108) = HIDWORD(v13) + a4;
    *(void *)(a1 + 120) = kdu_codestream::open_tile((uint64_t *)&v17, *(void *)(a1 + 104), 0);
    *(void *)(a1 + 136) = a6;
    *(unsigned char *)(a1 + 128) = a5;
    int32x4_t v14 = 0uLL;
    kdu_codestream::get_tile_dims((uint64_t *)&v17, *(void *)(a1 + 104), 0, &v14, 1);
    *(_DWORD *)(a1 + 72) = v14.i32[2];
    *(_DWORD *)(a1 + 8) = kdu_codestream::get_num_components(&v17, 1);
    operator new[]();
  }
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  kdu_error::kdu_error((kdu_error *)v15, "Error in kdc_flow_control:\n");
  (*(void (**)(_OWORD *, const char *))(*(void *)&v15[0] + 16))(v15, "Bad kdc_flow_control c'tor x_tnum parameter");
  kdu_error::~kdu_error((kdu_error *)v15);
}

void sub_18878C8D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18878C8DC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Resume(v13);
}

void kdc_flow_control::~kdc_flow_control(kdc_flow_control *this)
{
  uint64_t v2 = *(void *)this;
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x20C8093837F09);
  }
  if (*((void *)this + 18)) {
    kdu_multi_analysis::destroy((uint64_t *)this + 18);
  }
}

uint64_t kdu_multi_analysis::destroy(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 16))(result);
    uint64_t result = *a1;
    if (*a1) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  *a1 = 0;
  return result;
}

uint64_t kdc_flow_control::advance_components(kdc_flow_control *this)
{
  if (*((int *)this + 18) < 1) {
    return 0;
  }
  uint64_t v2 = (char *)this + 16;
  if (*((_DWORD *)this + 9) != (*((unsigned int (**)(void, void, void))this + 2))(*((void *)this + 3), *((void *)this + 6), *((int *)this + 9)))return 0; {
  if (*((int *)this + 2) >= 1)
  }
  {
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)this;
      uint64_t v5 = (*(uint64_t (**)(void, uint64_t, void, void))(**((void **)this + 18) + 32))(*((void *)this + 18), v3, 0, 0);
      *(void *)(v4 + 8 * v3) = v5;
      if (!v5)
      {
        uint64_t v10 = 0;
        memset(v9, 0, sizeof(v9));
        kdu_error::kdu_error((kdu_error *)v9, "Error in kdc_flow_control:\n");
        (*(void (**)(_OWORD *, const char *))(*(void *)&v9[0] + 16))(v9, "advance_components: comp->line == NULL");
        kdu_error::~kdu_error((kdu_error *)v9);
      }
      kdu_image_in::get((uint64_t)v2, v3++, v5, v6, v7);
    }
    while (v3 < *((int *)this + 2));
  }
  return 1;
}

void sub_18878CB34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18878CB40()
{
  _Unwind_Resume(v0);
}

uint64_t kdc_flow_control::process_components(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 72);
  BOOL v2 = __OFSUB__(v1--, 1);
  *(_DWORD *)(this + 72) = v1;
  if (v1 < 0 == v2)
  {
    uint64_t v3 = this;
    if (*(int *)(this + 8) >= 1)
    {
      uint64_t v4 = 0;
      do
      {
        uint64_t v5 = *(void *)v3;
        uint64_t v6 = *(void *)(*(void *)v3 + 8 * v4);
        if (!v6)
        {
          uint64_t v8 = 0;
          memset(v7, 0, sizeof(v7));
          kdu_error::kdu_error((kdu_error *)v7, "Error in kdc_flow_control:\n");
          (*(void (**)(_OWORD *, const char *))(*(void *)&v7[0] + 16))(v7, "process_components: comp->line == NULL");
          kdu_error::~kdu_error((kdu_error *)v7);
        }
        this = (*(uint64_t (**)(void, uint64_t, uint64_t, void))(**(void **)(v3 + 144) + 32))(*(void *)(v3 + 144), v4, v6, 0);
        *(void *)(v5 + 8 * v4++) = 0;
      }
      while (v4 < *(int *)(v3 + 8));
    }
  }
  return this;
}

void sub_18878CC58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18878CC64()
{
  _Unwind_Resume(v0);
}

uint64_t kdc_flow_control::advance_tile(kdc_flow_control *this)
{
  int v1 = (uint64_t **)((char *)this + 120);
  if (*((void *)this + 15))
  {
    kdu_multi_analysis::destroy((uint64_t *)this + 18);
    uint64_t v3 = *((unsigned int *)this + 2);
    if ((int)v3 < 1) {
      LODWORD(v3) = 0;
    }
    else {
      bzero(*(void **)this, 8 * v3);
    }
    kdu_tile::close(v1, 0);
    *((void *)this + 15) = 0;
    int v4 = *((_DWORD *)this + 26) + 1;
    *((_DWORD *)this + 26) = v4;
    if (v4 - *((_DWORD *)this + 22) != *((_DWORD *)this + 24))
    {
      *((void *)this + 15) = kdu_codestream::open_tile((uint64_t *)this + 10, *((void *)this + 13), 0);
      int32x4_t v6 = 0uLL;
      kdu_codestream::get_tile_dims((uint64_t *)this + 10, *((void *)this + 13), v3, &v6, 1);
      *((_DWORD *)this + 18) = v6.i32[2];
      kdu_tile::set_components_of_interest(v1, *((_DWORD *)this + 2), 0);
      kdu_multi_analysis::create();
    }
  }
  return 0;
}

void *ICNSReadPlugin::ICNSReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result = (void *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *uint64_t result = &unk_1ED4E12B0;
  return result;
}

void ICNSReadPlugin::ICNSReadPlugin(uint64_t a1, uint64_t a2)
{
}

void ICNSReadPlugin::~ICNSReadPlugin(ICNSReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t ICNSReadPlugin::loadDataFromXPCObject(ICNSReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_icns", &length);
    if (length == 56)
    {
      int32x4_t v6 = data;
      uint64_t result = 0;
      long long v7 = *v6;
      long long v8 = v6[1];
      long long v9 = v6[2];
      *((void *)this + 61) = *((void *)v6 + 6);
      *(_OWORD *)((char *)this + 456) = v8;
      *(_OWORD *)((char *)this + 472) = v9;
      *(_OWORD *)((char *)this + 440) = v7;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t ICNSReadPlugin::saveDataToXPCObject(ICNSReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_icns", (char *)this + 440, 0x38uLL);
  }
  return v4;
}

uint64_t ICNSReadPlugin::initialize(ICNSReadPlugin *this, IIODictionary *a2)
{
  __dst[96] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v31 = 0;
  *(_OWORD *)unsigned int v29 = 0u;
  long long v30 = 0u;
  *(_OWORD *)int v28 = 0u;
  char v27 = 0;
  *(_DWORD *)bytes = 0;
  if (!*((unsigned char *)this + 341)) {
    goto LABEL_32;
  }
  uint64_t v4 = (IIODictionary *)*((void *)this + 7);
  uint64_t v5 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1229147731);
  if (!v5)
  {
    _cg_jpeg_mem_term("initialize", 98, "*** ERROR: globalICNSInfo is NULL for index: %d\n", *((_DWORD *)this + 52));
    goto LABEL_32;
  }
  GlobalICNSInfo::getICNSImageInfoAtIndex(v5, *((_DWORD *)this + 52), (uint64_t)v28);
  if (SLOWORD(v28[0]) < 0)
  {
LABEL_32:
    uint64_t v9 = 4294967246;
    goto LABEL_33;
  }
  double v6 = 72.0;
  if (BYTE1(v31) == 2) {
    double v6 = 144.0;
  }
  IIONumber::IIONumber((IIONumber *)v25, v6);
  IIODictionary::setObjectForKey((uint64_t)v4, (uint64_t)v25, @"DPIWidth");
  IIONumber::~IIONumber((IIONumber *)v25);
  double v7 = 72.0;
  if (BYTE1(v31) == 2) {
    double v7 = 144.0;
  }
  IIONumber::IIONumber((IIONumber *)v24, v7);
  IIODictionary::setObjectForKey((uint64_t)v4, (uint64_t)v24, @"DPIHeight");
  IIONumber::~IIONumber((IIONumber *)v24);
  *(_DWORD *)bytes = bswap32(v30);
  CFStringRef v8 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 4, 0, 0);
  if (v8)
  {
    IIODictionary::setObjectForKey(v4, v8, @"kCGImagePropertyICNSIndexSelector");
    CFRelease(v8);
  }
  if (BYTE2(v31) == 4)
  {
    IIONumber::IIONumber((IIONumber *)__dst, 1246769696);
    IIODictionary::setObjectForKey(a2, __dst[2], @"NEW_PLUGIN_ostype");
    IIONumber::~IIONumber((IIONumber *)__dst);
    IIONumber::IIONumber((IIONumber *)__dst, v28[1]);
    IIODictionary::setObjectForKey(a2, __dst[2], @"NEW_PLUGIN_dataOffset");
    IIONumber::~IIONumber((IIONumber *)__dst);
    IIONumber::IIONumber((IIONumber *)__dst, LOWORD(v29[1]));
    IIODictionary::setObjectForKey(a2, __dst[2], @"NEW_PLUGIN_expectedWidth");
    IIONumber::~IIONumber((IIONumber *)__dst);
    IIONumber::IIONumber((IIONumber *)__dst, WORD1(v29[1]));
    IIODictionary::setObjectForKey(a2, __dst[2], @"NEW_PLUGIN_expectedHeight");
    IIONumber::~IIONumber((IIONumber *)__dst);
    kdebug_trace();
    goto LABEL_14;
  }
  if (BYTE2(v31) == 2)
  {
    IIONumber::IIONumber((IIONumber *)__dst, 1347307296);
    IIODictionary::setObjectForKey(a2, __dst[2], @"NEW_PLUGIN_ostype");
    IIONumber::~IIONumber((IIONumber *)__dst);
    IIONumber::IIONumber((IIONumber *)__dst, v28[1]);
    IIODictionary::setObjectForKey(a2, __dst[2], @"NEW_PLUGIN_dataOffset");
    IIONumber::~IIONumber((IIONumber *)__dst);
    IIONumber::IIONumber((IIONumber *)__dst, LOWORD(v29[1]));
    IIODictionary::setObjectForKey(a2, __dst[2], @"NEW_PLUGIN_expectedWidth");
    IIONumber::~IIONumber((IIONumber *)__dst);
    IIONumber::IIONumber((IIONumber *)__dst, WORD1(v29[1]));
    IIODictionary::setObjectForKey(a2, __dst[2], @"NEW_PLUGIN_expectedHeight");
    IIONumber::~IIONumber((IIONumber *)__dst);
    kdebug_trace();
LABEL_14:
    uint64_t v9 = 4294967247;
LABEL_33:
    kdebug_trace();
    return v9;
  }
  unsigned int v10 = LOWORD(v29[1]);
  int v11 = WORD1(v29[1]);
  *((_DWORD *)this + 57) = LOWORD(v29[1]);
  *((_DWORD *)this + 58) = v11;
  *((_WORD *)this + 120) = 8;
  int v12 = HIWORD(v29[1]);
  int v13 = WORD2(v29[1]);
  if (WORD2(v29[1]) <= 8u) {
    __int16 v14 = 8;
  }
  else {
    __int16 v14 = WORD2(v29[1]);
  }
  unsigned __int16 v15 = v14 * HIWORD(v29[1]);
  *((_WORD *)this + 121) = v15;
  *((_WORD *)this + 122) = v12;
  *((_DWORD *)this + 59) = (v15 * (unint64_t)v10 + 7) >> 3;
  *((_DWORD *)this + 81) = 1380401696;
  *((void *)this + 20) = 0;
  *((unsigned char *)this + 246) = 3;
  if (v15 == 32)
  {
    int v16 = 4;
    *((unsigned char *)this + 247) = 4;
  }
  else
  {
    int v16 = *((unsigned __int8 *)this + 247);
  }
  int v17 = *((unsigned __int8 *)this + 248);
  BOOL v18 = *((unsigned char *)this + 249) == 0;
  *((unsigned char *)this + 278) = 3;
  char v19 = !v18;
  *((unsigned char *)this + 279) = v16 & 7;
  *((unsigned char *)this + 280) = (((v16 << 12) | (v17 << 16)) >> 16) & 0xF;
  *((unsigned char *)this + 281) = v19;
  *((unsigned char *)this + 350) = 1;
  *((unsigned char *)this + 344) = 0;
  *((unsigned char *)this + 346) = 0;
  if (v13 == 1)
  {
    *((_DWORD *)this + 81) = 1196573017;
    CGColorSpaceRef v20 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBF8]);
LABEL_29:
    *((void *)this + 20) = v20;
    goto LABEL_30;
  }
  if (v12 != 2)
  {
    CGColorSpaceRef v20 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
    goto LABEL_29;
  }
  memcpy(__dst, &unk_1889AAEF0, 0x300uLL);
  int v21 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
  *((void *)this + 20) = CGColorSpaceCreateIndexed(v21, 0xFFuLL, (const unsigned __int8 *)__dst);
  CGColorSpaceRelease(v21);
LABEL_30:
  uint64_t v9 = 0;
  *((void *)this + 61) = v31;
  long long v22 = *(_OWORD *)v29;
  *(_OWORD *)((char *)this + 440) = *(_OWORD *)v28;
  *(_OWORD *)((char *)this + 456) = v22;
  *(_OWORD *)((char *)this + 472) = v30;
  *((void *)this + 45) = 1;
  *((_WORD *)this + 188) = 1;
  return v9;
}

void sub_18878D444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t ICNSReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12) {
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2);
  }
  if (v2 == 1) {
    return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

uint64_t ICNSReadPlugin::decode_ic04_ic05(IIOImageReadSession **this, unsigned __int8 *a2, uint64_t a3, unsigned __int8 *a4, uint64_t a5)
{
  if (a5 == 4) {
    return 0;
  }
  if (a5 - 4 >= (unint64_t)IIOImageReadSession::getSize(this[3])) {
    return 0;
  }
  uint64_t v10 = (*((_DWORD *)this + 58) * *((_DWORD *)this + 57));
  if (4 * v10 != a3) {
    return 0;
  }
  int v11 = a4 + 4;
  int v23 = 33619971;
  if (*((unsigned char *)this + 404) == 1)
  {
    BYTE1(v23) = 2;
    HIBYTE(v23) = 0;
  }
  uint64_t v12 = 0;
  int v13 = &a4[a5];
  while (!v10)
  {
LABEL_24:
    if (++v12 == 4) {
      return 0;
    }
  }
  unsigned __int8 v14 = 0;
  char v15 = 0;
  int v16 = 0;
  int v17 = &a2[*((unsigned __int8 *)&v23 + v12)];
  uint64_t v18 = v10;
  while (!v16)
  {
    if (v11 >= v13) {
      return 4294967243;
    }
    char v19 = v11 + 1;
    int v20 = *v11;
    if (((char)*v11 & 0x80000000) == 0)
    {
      if (v19 >= v13) {
        return 4294967243;
      }
      int v16 = v20 + 1;
      ++v11;
      goto LABEL_17;
    }
    if (v19 >= v13 || v11 + 2 > v13) {
      return 4294967243;
    }
    int v16 = v20 - 125;
    unsigned __int8 v14 = v11[1];
    char v15 = 1;
    v11 += 2;
LABEL_23:
    --v16;
    *int v17 = v14;
    v17 += 4;
    if (!--v18) {
      goto LABEL_24;
    }
  }
  if (v11 > v13) {
    return 4294967240;
  }
  if (v15)
  {
    char v15 = 1;
    goto LABEL_23;
  }
LABEL_17:
  if (v11 < v13)
  {
    unsigned __int8 v21 = *v11++;
    unsigned __int8 v14 = v21;
    if (v11 > v13) {
      return 4294967243;
    }
    char v15 = 0;
    goto LABEL_23;
  }
  return 4294967239;
}

uint64_t ICNSReadPlugin::decodeImageData(ICNSReadPlugin *this, unsigned __int8 *a2, size_t a3)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  unint64_t v6 = *((void *)this + 56);
  size_t v7 = *((void *)this + 57);
  unsigned int v8 = *((unsigned __int16 *)this + 232);
  unsigned int v9 = *((unsigned __int16 *)this + 233);
  int v82 = *((unsigned __int16 *)this + 235);
  int v83 = *((unsigned __int16 *)this + 234);
  uint64_t v81 = *((unsigned int *)this + 119);
  int v10 = *((_DWORD *)this + 120);
  int v11 = *((_DWORD *)this + 121);
  uint64_t v87 = 0;
  *(_OWORD *)count = 0u;
  long long v86 = 0u;
  *(_OWORD *)v84 = 0u;
  uint64_t v12 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1229147731);
  IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), v6, 0);
  int v13 = (unsigned __int8 *)malloc_type_calloc(v7, 1uLL, 0xD90018F8uLL);
  if (!v13) {
    return 4294967246;
  }
  unsigned __int8 v14 = v13;
  unint64_t Bytes = IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), v13, v7);
  if (Bytes != v7)
  {
    _cg_jpeg_mem_term("decodeImageData", 383, "*** failed to read imageData (requested %d bytes - got %d)\n", v7, Bytes);
    goto LABEL_73;
  }
  if (*((_DWORD *)this + 118) >> 1 == 884054042)
  {
    uint64_t v16 = ICNSReadPlugin::decode_ic04_ic05((IIOImageReadSession **)this, a2, a3, v14, v7);
LABEL_150:
    free(v14);
    return v16;
  }
  unint64_t v17 = v9 * (unint64_t)v8;
  if (GlobalICNSInfo::getICNSMaskInfoForType((uint64_t)v12, v10, (uint64_t)v84))
  {
    if (count[0])
    {
      IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), v84[1], 0);
      unint64_t v19 = count[0];
      if (count[0] < WORD1(count[1]) * (unint64_t)LOWORD(count[1]))
      {
        int v20 = v86;
        unsigned int v21 = (int)v86 >> 24;
        if ((v86 & 0x80000000) != 0)
        {
          int v22 = __maskrune(v21, 0x40000uLL);
          int v20 = v86;
          unsigned int v21 = (int)v86 >> 24;
        }
        else
        {
          int v22 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v21 + 60) & 0x40000;
        }
        if (v22) {
          uint64_t v42 = v21;
        }
        else {
          uint64_t v42 = 46;
        }
        if (v20 << 8 < 0)
        {
          __maskrune(v20 << 8 >> 24, 0x40000uLL);
          int v20 = v86;
        }
        if (v20 << 16 < 0)
        {
          __maskrune((__int16)v20 >> 8, 0x40000uLL);
          int v20 = v86;
        }
        if ((v20 << 24) > 0x7F000000) {
          __maskrune((char)v20, 0x40000uLL);
        }
        LogError("decodeImageData", 405, "bad ICNS data - invalid size for '%c%c%c%c' (got: %ld  expected: %ld)\n", v42);
        goto LABEL_73;
      }
      int v28 = (char *)malloc_type_calloc(count[0], 1uLL, 0x67F320C4uLL);
      if (v28)
      {
        char v27 = v28;
        unint64_t v29 = IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), v28, v19);
        if (v29 != v19)
        {
          _cg_jpeg_mem_term("decodeImageData", 412, "*** failed to read deep maskData (requested %d bytes - got %d)\n", v19, v29);
          long long v30 = 0;
          uint64_t v16 = 4294967246;
          goto LABEL_148;
        }
        goto LABEL_17;
      }
LABEL_73:
      uint64_t v16 = 4294967246;
      goto LABEL_150;
    }
LABEL_14:
    char v27 = 0;
LABEL_17:
    long long v30 = 0;
    unint64_t v23 = 0;
    goto LABEL_21;
  }
  GlobalICNSInfo::getICNSMaskInfoForType((uint64_t)v12, v11, (uint64_t)v84);
  if (!count[0]) {
    goto LABEL_14;
  }
  IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), v84[1], 0);
  unint64_t v23 = count[0];
  if (count[0] < ((v17 >> 2) & 0x3FFFFFFE))
  {
    int v24 = v86;
    unsigned int v25 = (int)v86 >> 24;
    if ((v86 & 0x80000000) != 0)
    {
      int v26 = __maskrune(v25, 0x40000uLL);
      int v24 = v86;
      unsigned int v25 = (int)v86 >> 24;
    }
    else
    {
      int v26 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v25 + 60) & 0x40000;
    }
    if (v26) {
      uint64_t v43 = v25;
    }
    else {
      uint64_t v43 = 46;
    }
    if (v24 << 8 < 0)
    {
      __maskrune(v24 << 8 >> 24, 0x40000uLL);
      int v24 = v86;
    }
    if (v24 << 16 < 0)
    {
      __maskrune((__int16)v24 >> 8, 0x40000uLL);
      int v24 = v86;
    }
    if ((v24 << 24) > 0x7F000000) {
      __maskrune((char)v24, 0x40000uLL);
    }
    LogError("decodeImageData", 427, "bad ICNS data - invalid size for '%c%c%c%c' (got: %d  expected: %ld)\n", v43);
    goto LABEL_73;
  }
  uint64_t v31 = (unsigned __int8 *)malloc_type_calloc(count[0], 1uLL, 0x6257FD99uLL);
  if (!v31) {
    goto LABEL_73;
  }
  long long v30 = v31;
  unint64_t v32 = IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), v31, v23);
  if (v32 != v23)
  {
    _cg_jpeg_mem_term("decodeImageData", 434, "*** failed to read 1-bit maskData (requested %d bytes - got %d)\n", v23, v32);
    free(v14);
    uint64_t v16 = 4294967246;
    unsigned __int8 v14 = v30;
    goto LABEL_150;
  }
  char v27 = 0;
LABEL_21:
  if (v83 != 1)
  {
    if (v82 != 4)
    {
      if (v82 != 2) {
        goto LABEL_156;
      }
      if (v83 == 4)
      {
        if (v7 < v17 >> 1)
        {
          LogError("decodeImageData", 486, "corrupted 4-bit icns data");
          goto LABEL_156;
        }
        if (v17 >= 2)
        {
          uint64_t v38 = v17 >> 1;
          if (v17 >> 1 <= 1) {
            uint64_t v38 = 1;
          }
          v39 = v14;
          double v40 = a2;
          do
          {
            unsigned int v41 = *v39++;
            *double v40 = v41 & 0xF0 | (v41 >> 4);
            v40[2] = v41 & 0xF | (16 * v41);
            v40 += 4;
            --v38;
          }
          while (v38);
        }
      }
      else
      {
        if (v7 < v17)
        {
          LogError("decodeImageData", 505, "corrupted icns data, insufficient data for %zu pixels");
          goto LABEL_156;
        }
        if (!v17)
        {
          if (!v30) {
            goto LABEL_147;
          }
          goto LABEL_79;
        }
        unint64_t v44 = v17;
        v45 = v14;
        v46 = a2;
        do
        {
          unsigned __int8 v47 = *v45++;
          unsigned __int8 *v46 = v47;
          v46 += 2;
          --v44;
        }
        while (v44);
      }
      if (v30)
      {
LABEL_79:
        if (v17 <= 8 * v23)
        {
          int v57 = v23 - (v17 >> 3);
          unint64_t v58 = (8 * v57);
          if (v17 <= v58) {
            unint64_t v58 = v17;
          }
          else {
            _cg_jpeg_mem_term("decodeImageData", 521, "*** Adjusting pixelCount: %d to %d\n", v17, 8 * v57);
          }
          if (v58)
          {
            unint64_t v63 = 0;
            v64 = a2 + 1;
            do
            {
              if ((v30[(v17 >> 3) + (v63 >> 3)] >> (~(_BYTE)v63 & 7))) {
                char v65 = -1;
              }
              else {
                char v65 = 0;
              }
              unsigned __int8 *v64 = v65;
              v64 += 2;
              ++v63;
            }
            while (v58 != v63);
          }
        }
        else
        {
          _cg_jpeg_mem_term("decodeImageData", 531, "[2] maskLen1Bit = %ld   pixelCount = %ld", v23, v17);
        }
        goto LABEL_147;
      }
      if (v17)
      {
        v59 = a2 + 1;
        v60 = v27;
        do
        {
          if (v27)
          {
            char v62 = *v60++;
            char v61 = v62;
          }
          else
          {
            char v61 = -1;
          }
          unsigned __int8 *v59 = v61;
          v59 += 2;
          --v17;
        }
        while (v17);
      }
LABEL_147:
      uint64_t v16 = 0;
      if (!v27) {
        goto LABEL_149;
      }
      goto LABEL_148;
    }
    if (v30)
    {
      if (v17 <= 8 * v23)
      {
        if (!v17)
        {
          if (!v7) {
            goto LABEL_147;
          }
LABEL_117:
          __int32 v66 = *((_DWORD *)this + 118);
          if (v66 == 1769222962 || (v67 = v14, v66 == 1768125282)) {
            v67 = v14 + 4;
          }
          int32x4_t v68 = (int32x4_t)xmmword_1889AAEE0;
          int8x16_t v88 = (int8x16_t)xmmword_1889AAEE0;
          uint64_t v69 = 3;
          if (v66 == 1768125282) {
            uint64_t v69 = 4;
          }
          if (*((unsigned char *)this + 405) || v66 == 1768125282)
          {
            v68.i32[0] = 1768125282;
            v18.i32[0] = v66;
            int8x16_t v88 = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v18, v68), 0), (int8x16_t)xmmword_1889AAED0, (int8x16_t)xmmword_18898C3A0);
          }
          uint64_t v70 = 0;
          unint64_t v71 = (unint64_t)&v14[v7];
          do
          {
            if (v17)
            {
              v72 = v67 + 1;
              if ((unint64_t)(v67 + 1) < v71)
              {
                unint64_t v73 = 0;
                v74 = &a2[v88.i32[v70]];
                do
                {
                  int v75 = (char)*v67;
                  if (v75 < 0)
                  {
                    v67 += 2;
                    if (v73 < v17 && (unint64_t)v67 <= v71)
                    {
                      unsigned __int8 v78 = *v72;
                      int v79 = v75 - 125;
                      do
                      {
                        unsigned __int8 *v74 = v78;
                        v74 += 4;
                        --v79;
                        ++v73;
                      }
                      while ((_BYTE)v79 && v73 < v17);
                    }
                  }
                  else if (v73 >= v17 || (unint64_t)v72 >= v71)
                  {
                    v67 = v72;
                  }
                  else
                  {
                    int v76 = v75 + 1;
                    v67 = v72;
                    do
                    {
                      unsigned __int8 v77 = *v67++;
                      unsigned __int8 *v74 = v77;
                      v74 += 4;
                      --v76;
                      ++v73;
                    }
                    while ((_BYTE)v76 && v73 < v17 && (unint64_t)v67 < v71);
                  }
                  if (v73 >= v17) {
                    break;
                  }
                  v72 = v67 + 1;
                }
                while ((unint64_t)(v67 + 1) < v71);
              }
            }
            ++v70;
          }
          while (v70 != v69);
          goto LABEL_147;
        }
        unint64_t v52 = 0;
        uint64_t v53 = a2 + 3;
        do
        {
          if ((v30[(v17 >> 3) + (v52 >> 3)] >> (~(_BYTE)v52 & 7))) {
            char v54 = -1;
          }
          else {
            char v54 = 0;
          }
          *uint64_t v53 = v54;
          v53 += 4;
          ++v52;
        }
        while (v17 != v52);
      }
      else
      {
        _cg_jpeg_mem_term("decodeImageData", 563, "[4] maskLen1Bit = %ld   pixelCount = %ld", v23, v17);
      }
    }
    else if (v27 && v17)
    {
      uint64_t v48 = a2 + 3;
      unint64_t v49 = v17;
      v50 = (unsigned __int8 *)v27;
      do
      {
        unsigned __int8 v51 = *v50++;
        *uint64_t v48 = v51;
        v48 += 4;
        --v49;
      }
      while (v49);
    }
    if (v7 == 4 * v17)
    {
      if (v17)
      {
        v55 = v14 + 3;
        do
        {
          *a2 = *(v55 - 2);
          a2[1] = *(v55 - 1);
          unsigned __int8 v56 = *v55;
          v55 += 4;
          a2[2] = v56;
          a2 += 4;
          --v17;
        }
        while (v17);
      }
      goto LABEL_147;
    }
    goto LABEL_117;
  }
  bzero(a2, a3);
  if ((uint64_t)(v17 >> 3) > (uint64_t)v7)
  {
    LogError("decodeImageData", 457, "corrupted 1-bit icns data");
  }
  else
  {
    if (v7 == v81)
    {
      if (v17)
      {
        for (unint64_t i = 0; i != v17; ++i)
        {
          int v34 = v14[(v17 >> 3) + (i >> 3)];
          int v35 = 1 << (~(_BYTE)i & 7);
          if ((v35 & v14[i >> 3]) != 0) {
            unsigned __int8 v36 = 0;
          }
          else {
            unsigned __int8 v36 = -1;
          }
          *a2 = v36;
          if ((v35 & v34) != 0) {
            unsigned __int8 v37 = -1;
          }
          else {
            unsigned __int8 v37 = 0;
          }
          a2[1] = v37;
          a2 += 2;
        }
      }
      goto LABEL_147;
    }
    LogError("decodeImageData", 458, "corrupted 1-bit icns data");
  }
LABEL_156:
  uint64_t v16 = 4294967246;
  if (v27) {
LABEL_148:
  }
    free(v27);
LABEL_149:
  free(v14);
  unsigned __int8 v14 = v30;
  if (v30) {
    goto LABEL_150;
  }
  return v16;
}

uint64_t ICNSReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  memory_object_size_t v41 = 0;
  if ((gIIODebugFlags & 0x20000) == 0) {
    goto LABEL_26;
  }
  int v8 = *((_DWORD *)this + 51);
  unsigned int v9 = v8 >> 24;
  uint64_t v10 = MEMORY[0x1E4F14390];
  if (v8 < 0)
  {
    int v11 = __maskrune(v9, 0x40000uLL);
    int v8 = *((_DWORD *)this + 51);
  }
  else
  {
    int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
  }
  if (v11) {
    uint64_t v12 = (v8 >> 24);
  }
  else {
    uint64_t v12 = 46;
  }
  unsigned int v13 = v8 << 8 >> 24;
  if (v8 << 8 < 0)
  {
    int v14 = __maskrune(v13, 0x40000uLL);
    int v8 = *((_DWORD *)this + 51);
  }
  else
  {
    int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
  }
  if (v14) {
    uint64_t v15 = (v8 << 8 >> 24);
  }
  else {
    uint64_t v15 = 46;
  }
  unsigned int v16 = (__int16)v8 >> 8;
  if (v8 << 16 < 0)
  {
    int v17 = __maskrune(v16, 0x40000uLL);
    int v8 = *((_DWORD *)this + 51);
  }
  else
  {
    int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  }
  if (v17) {
    uint64_t v18 = ((__int16)v8 >> 8);
  }
  else {
    uint64_t v18 = 46;
  }
  if ((v8 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0) {
      goto LABEL_22;
    }
LABEL_24:
    uint64_t v19 = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v8, 0x40000uLL)) {
    goto LABEL_24;
  }
LABEL_22:
  uint64_t v19 = *((char *)this + 204);
LABEL_25:
  ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus ICNSReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  int v20 = (IIOImageRead **)*((void *)this + 3);
  if (v20) {
    BOOL v21 = IIOImageReadSession::mapData(v20);
  }
  else {
    BOOL v21 = 0;
  }
  if (a3 == 3)
  {
    uint64_t BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v28) = *((_DWORD *)this + 73);
    double v27 = (double)v28;
    unsigned int v29 = *((_DWORD *)this + 74);
    double v25 = (double)v29;
    memory_object_size_t v24 = *((unsigned int *)this + 75) * (unint64_t)v29;
    BaseAddress = (void *)_ImageIO_Malloc(v24, *((void *)this + 48), &v41, (uint64_t)kImageMalloc_ICNS_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
    {
      uint64_t BlockArray = 1;
      goto LABEL_46;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    size_t Height = IOSurfaceGetHeight(*a4);
    memory_object_size_t v24 = IOSurfaceGetBytesPerRow(*a4) * Height;
    memory_object_size_t v41 = v24;
    double v25 = 0.0;
    uint64_t BlockArray = 1;
    double v27 = 0.0;
  }
  if (BaseAddress)
  {
    bzero(BaseAddress, v24);
    uint64_t v30 = (*(uint64_t (**)(IIOReadPlugin *, void *, memory_object_size_t))(*(void *)this + 120))(this, BaseAddress, v24);
    if (v30)
    {
      uint64_t BlockArray = v30;
      if (a3 == 3) {
        _ImageIO_Free((unint64_t)BaseAddress, v41);
      }
    }
    else
    {
      if (*((unsigned char *)this + 406) == 1)
      {
        vImagePixelCount v31 = *((unsigned int *)this + 74);
        dest.data = BaseAddress;
        dest.height = v31;
        size_t v32 = *((unsigned int *)this + 75);
        dest.width = *((unsigned int *)this + 73);
        dest.rowunint64_t Bytes = v32;
        vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
      }
      if (a3 == 3)
      {
        uint64_t v33 = 0;
        v42.origin.x = 0.0;
        v42.origin.y = 0.0;
        v42.size.width = v27;
        v42.size.height = v25;
        **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v24, v42, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
        if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E4F1DB20]))
        {
          uint64_t v34 = 0;
        }
        else
        {
          v43.origin.x = 0.0;
          v43.origin.y = 0.0;
          v43.size.width = v27;
          v43.size.height = v25;
          *(CGRect *)(&v34 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v43);
          uint64_t v33 = v35;
          double v27 = v36;
          double v25 = v37;
        }
        uint64_t BlockArray = 0;
        *((void *)this + 15) = v33;
        *((void *)this + 16) = v34;
        *((double *)this + 17) = v27;
        *((double *)this + 18) = v25;
      }
      else
      {
        IOSurfaceUnlock(*a4, 0, 0);
        uint64_t BlockArray = 0;
      }
    }
  }
LABEL_46:
  if (v21)
  {
    uint64_t v38 = (const char **)*((void *)this + 3);
    if (v38) {
      IIOImageReadSession::unmapData(v38);
    }
  }
  return BlockArray;
}

void _JPEGFile::_JPEGFile(_JPEGFile *this, CFDataRef theData, char a3, char a4)
{
  *(void *)this = &unk_1ED4E6120;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 3) = CFDataGetBytePtr(theData);
  *((void *)this + 4) = CFDataGetLength(theData);
  *((void *)this + 5) = 0;
  *((unsigned char *)this + 96) = a3;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((unsigned char *)this + 50) = __PAIR64__(*(unsigned __int8 *)(*((void *)this + 3) + 1), **((unsigned __int8 **)this + 3)) == 0xD8000000FFLL;
  *((unsigned char *)this + 51) = 0;
  *((unsigned char *)this + 48) = 0;
  *((unsigned char *)this + 49) = a4;
}

void sub_18878E4B8(_Unwind_Exception *exception_object)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 80) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void _JPEGFile::_JPEGFile(_JPEGFile *this, unsigned __int8 *a2, uint64_t a3, char a4, char a5)
{
  *(void *)this = &unk_1ED4E6120;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 3) = a2;
  *((void *)this + 4) = a3;
  *((void *)this + 5) = 0;
  *((unsigned char *)this + 96) = a4;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  *((unsigned char *)this + 50) = __PAIR64__(a2[1], *a2) == 0xD8000000FFLL;
  *((unsigned char *)this + 51) = 0;
  *((unsigned char *)this + 48) = 0;
  *((unsigned char *)this + 49) = a5;
}

void _JPEGFile::~_JPEGFile(_JPEGFile *this)
{
  *(void *)this = &unk_1ED4E6120;
  int v2 = (void *)*((void *)this + 9);
  uint64_t v3 = (void *)*((void *)this + 10);
  if (v2 != v3)
  {
    do
    {
      if (*v2) {
        (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
      }
      ++v2;
    }
    while (v2 != v3);
    int v2 = (void *)*((void *)this + 9);
  }
  if (v2)
  {
    *((void *)this + 10) = v2;
    operator delete(v2);
  }
}

{
  uint64_t vars8;

  _JPEGFile::~_JPEGFile(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t _JPEGFile::findAppMarker(_JPEGFile *this, int a2)
{
  uint64_t v2 = *((void *)this + 9);
  uint64_t v3 = *((void *)this + 10);
  while (v2 != v3)
  {
    uint64_t result = *(void *)v2;
    if (*(unsigned __int16 *)(*(void *)v2 + 56) == a2) {
      return result;
    }
    v2 += 8;
  }
  return 0;
}

uint64_t _JPEGFile::appMarkerAtIndex(_JPEGFile *this, int a2)
{
  uint64_t v2 = *((void *)this + 9);
  if (a2 >= (unint64_t)((*((void *)this + 10) - v2) >> 3)) {
    return 0;
  }
  else {
    return *(void *)(v2 + 8 * a2);
  }
}

uint64_t _JPEGFile::findApp1ExifMarker(_JPEGFile *this)
{
  uint64_t v1 = *((void *)this + 9);
  uint64_t v2 = *((void *)this + 10);
  while (v1 != v2)
  {
    uint64_t result = *(void *)v1;
    if (*(__int16 *)(*(void *)v1 + 56) == -31 && *(unsigned char *)(result + 68)) {
      return result;
    }
    v1 += 8;
  }
  return 0;
}

_JPEGFile *_JPEGFile::mergeWithFile(_JPEGFile *this, _JPEGFile *a2)
{
  if (a2)
  {
    uint64_t v3 = this;
    uint64_t v4 = (_APPx **)*((void *)a2 + 9);
    uint64_t v5 = (_APPx **)*((void *)a2 + 10);
    while (v4 != v5)
    {
      unint64_t v6 = *v4;
      uint64_t v7 = *((void *)v3 + 9);
      uint64_t v8 = *((void *)v3 + 10);
      if (v7 == v8)
      {
LABEL_7:
        _JPEGFile::insertAppMarker(v3, *v4);
        *((unsigned char *)v6 + 8) |= 0x10u;
        this = (_JPEGFile *)_JPEGFile::removeAppMarker((uint64_t)a2, (uint64_t)v6);
      }
      else
      {
        while (*(unsigned __int16 *)(*(void *)v7 + 56) != *((unsigned __int16 *)v6 + 28))
        {
          v7 += 8;
          if (v7 == v8) {
            goto LABEL_7;
          }
        }
      }
      ++v4;
    }
    for (unint64_t i = (_APP1 **)*((void *)v3 + 9); i != *((_APP1 ***)v3 + 10); ++i)
    {
      uint64_t v10 = *i;
      if (*((__int16 *)*i + 28) == -31 && *((unsigned char *)v10 + 68)) {
        goto LABEL_15;
      }
    }
    uint64_t v10 = 0;
LABEL_15:
    int v11 = (_APP1 **)*((void *)a2 + 9);
    uint64_t v12 = (_APP1 **)*((void *)a2 + 10);
    while (v11 != v12)
    {
      unsigned int v13 = *v11;
      if (*((__int16 *)*v11 + 28) == -31 && *((unsigned char *)v13 + 68))
      {
        if (!v10) {
          operator new();
        }
        *((unsigned char *)v10 + 8) |= 0x20u;
        return (_JPEGFile *)_APP1::mergeWithApp1(v10, v13);
      }
      ++v11;
    }
  }
  return this;
}

void sub_18878E80C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B1C401EC73DA2);
  _Unwind_Resume(a1);
}

char *_JPEGFile::insertAppMarker(_JPEGFile *this, _APPx *a2)
{
  unsigned int v13 = a2;
  uint64_t v5 = (char *)*((void *)this + 9);
  uint64_t v4 = (char *)*((void *)this + 10);
  uint64_t v3 = (char *)this + 72;
  if (v4 != v5)
  {
    unint64_t v6 = (v4 - v5) >> 3;
    unsigned int v7 = *((unsigned __int16 *)a2 + 29);
    do
    {
      unint64_t v8 = v6 >> 1;
      unsigned int v9 = &v5[8 * (v6 >> 1)];
      uint64_t v11 = *(void *)v9;
      uint64_t v10 = v9 + 8;
      v6 += ~(v6 >> 1);
      if (*(unsigned __int16 *)(v11 + 58) <= v7) {
        uint64_t v5 = v10;
      }
      else {
        unint64_t v6 = v8;
      }
    }
    while (v6);
    uint64_t v4 = v5;
  }
  return std::vector<_APPx *>::insert((uint64_t)v3, v4, (char *)&v13);
}

uint64_t _JPEGFile::removeAppMarker(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void **)(result + 72);
  uint64_t v2 = *(void **)(result + 80);
  if (v3 != v2)
  {
    while (*v3 != a2)
    {
      if (++v3 == v2) {
        return result;
      }
    }
    if (v3 != v2)
    {
      uint64_t v4 = v3 + 1;
      if (v3 + 1 != v2)
      {
        do
        {
          if (*v4 != a2) {
            *v3++ = *v4;
          }
          ++v4;
        }
        while (v4 != v2);
        uint64_t v2 = *(void **)(result + 80);
      }
    }
    if (v3 != v2) {
      *(void *)(result + 80) = v3;
    }
  }
  return result;
}

unsigned char *_JPEGFile::copyThumbnail(unsigned char *this, _JPEGFile *a2)
{
  uint64_t v2 = this;
  if (!a2)
  {
    TagByID = 0;
    unint64_t v6 = 0;
LABEL_26:
    for (uint64_t i = *((void *)v2 + 9); i != *((void *)v2 + 10); i += 8)
    {
      this = *(unsigned char **)i;
      if (*(__int16 *)(*(void *)i + 56) == -31 && this[68])
      {
        this = (unsigned char *)(*(uint64_t (**)(unsigned char *))(*(void *)this + 48))(this);
        if (this)
        {
          int v14 = (_TAGList *)this;
          TagByID = (unsigned int *)_TAGList::findTagByID((_TAGList *)this, 513);
          this = (unsigned char *)_TAGList::findTagByID(v14, 514);
          unint64_t v6 = (_TAGList *)this;
        }
        goto LABEL_33;
      }
    }
    goto LABEL_33;
  }
  for (uint64_t j = *((void *)a2 + 9); ; j += 8)
  {
    if (j == *((void *)a2 + 10))
    {
      TagByID = 0;
      unint64_t v6 = 0;
      goto LABEL_8;
    }
    this = *(unsigned char **)j;
    if (*(__int16 *)(*(void *)j + 56) == -31)
    {
      if (this[68]) {
        break;
      }
    }
  }
  this = (unsigned char *)(*(uint64_t (**)(unsigned char *))(*(void *)this + 48))(this);
  unint64_t v6 = (_TAGList *)this;
  if (this)
  {
    TagByID = (unsigned int *)_TAGList::findTagByID((_TAGList *)this, 513);
    this = (unsigned char *)_TAGList::findTagByID(v6, 514);
    unint64_t v6 = (_TAGList *)this;
    if (TagByID) {
      BOOL v12 = this == 0;
    }
    else {
      BOOL v12 = 1;
    }
    if (!v12) {
      goto LABEL_24;
    }
  }
  else
  {
    TagByID = 0;
  }
LABEL_8:
  uint64_t v7 = *((void *)a2 + 9);
  uint64_t v8 = *((void *)a2 + 10);
  if (v7 != v8)
  {
    uint64_t v9 = *((void *)a2 + 9);
    while (1)
    {
      uint64_t v10 = *(void **)v9;
      if (*(__int16 *)(*(void *)v9 + 56) == -64) {
        break;
      }
      v9 += 8;
      if (v9 == v8)
      {
        while (1)
        {
          uint64_t v10 = *(void **)v7;
          if (*(__int16 *)(*(void *)v7 + 56) == -37) {
            goto LABEL_15;
          }
          v7 += 8;
          if (v7 == v8) {
            goto LABEL_24;
          }
        }
      }
    }
LABEL_15:
    if ((*(unsigned int (**)(void *))(*v10 + 24))(v10) >> 6 <= 0x270)
    {
      *((void *)v2 + 7) = v10[5] + v10[2];
      this = (unsigned char *)(*(uint64_t (**)(void *))(*v10 + 24))(v10);
      goto LABEL_36;
    }
    int v11 = (*(uint64_t (**)(void *))(*v10 + 24))(v10);
    this = LogError("copyThumbnail", 292, "*** ERROR: skipping thumbnail -- too big [%d bytes]\n", v11);
  }
LABEL_24:
  if (!TagByID || !v6) {
    goto LABEL_26;
  }
LABEL_33:
  if (TagByID && v6)
  {
    uint64_t v15 = *((void *)v2 + 3);
    *((void *)v2 + 7) = v15 + _TAG::nativeDataOrOffset((_TAG *)TagByID) + TagByID[7];
    this = (unsigned char *)_TAG::nativeDataOrOffset(v6);
LABEL_36:
    *((_DWORD *)v2 + 16) = this;
  }
  uint64_t v16 = *((void *)v2 + 7);
  if (v16)
  {
    uint64_t v17 = *((unsigned int *)v2 + 16);
    if (v17)
    {
      for (k = (uint64_t *)*((void *)v2 + 9); ; ++k)
      {
        if (k == *((uint64_t **)v2 + 10)) {
          operator new();
        }
        uint64_t v19 = (unsigned char *)*k;
        if (*(__int16 *)(*k + 56) == -31)
        {
          if (v19[68]) {
            break;
          }
        }
      }
      int v20 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v19 + 56);
      uint64_t v21 = *k;
      return (unsigned char *)v20(v21, v16, v17);
    }
  }
  return this;
}

void sub_18878EC9C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B1C401EC73DA2);
  _Unwind_Resume(a1);
}

uint64_t _JPEGFile::copyXMPProperties(_JPEGFile *this)
{
  long long v24 = 0u;
  long long v25 = 0u;
  unsigned int v1 = *((_DWORD *)this + 20) - *((_DWORD *)this + 18);
  uint64_t v2 = (unsigned __int16)(v1 >> 3);
  if (!(unsigned __int16)(v1 >> 3)) {
    return 0;
  }
  unint64_t v4 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v20 = 0;
  unsigned int Length = 0;
  BytePtr = 0;
  do
  {
    uint64_t v6 = *((void *)this + 9);
    if (v4 >= (*((void *)this + 10) - v6) >> 3) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = *(_APP1XMP **)(v6 + 8 * v4);
    }
    if (*((unsigned char *)v7 + 69))
    {
      CFDataRef XmpData = (const __CFData *)_APP1XMP::getXmpData(v7);
      if (XmpData)
      {
        CFDataRef v9 = XmpData;
        BytePtr = (const char *)CFDataGetBytePtr(XmpData);
        unsigned int Length = CFDataGetLength(v9);
      }
    }
    else
    {
      if (!*((unsigned char *)v7 + 70)) {
        goto LABEL_21;
      }
      CFDataRef v10 = (const __CFData *)_APP1XMP::getXmpData(v7);
      CFDataRef GUID = (const __CFData *)_APP1ExtendedXMP::getGUID(v7);
      BOOL v12 = CFDataGetBytePtr(GUID);
      TotalXMPunsigned int Length = _APP1ExtendedXMP::getTotalXMPLength(v7);
      int XmpOffset = _APP1ExtendedXMP::getXmpOffset(v7);
      unsigned int v15 = CFDataGetLength(v10);
      if (GUID)
      {
        unsigned int v16 = v15;
        if (CFDataGetLength(GUID) == 32)
        {
          if ((v22 & 0x100000000) == 0)
          {
            long long v24 = *(_OWORD *)v12;
            long long v25 = *((_OWORD *)v12 + 1);
            LODWORD(v22) = TotalXMPLength;
            uint64_t v21 = (char *)malloc_type_calloc(1uLL, TotalXMPLength, 0x78D15197uLL);
            if (!v21)
            {
              uint64_t v21 = 0;
              BYTE4(v22) = 0;
              goto LABEL_18;
            }
          }
          BYTE4(v22) = 1;
          if (!((unint64_t)v24 ^ *(void *)v12 | *((void *)&v24 + 1) ^ *((void *)v12 + 1) | (unint64_t)v25 ^ *((void *)v12 + 2) | *((void *)&v25 + 1) ^ *((void *)v12 + 3))
            && TotalXMPLength == v22
            && XmpOffset + v16 <= v22)
          {
            uint64_t v17 = CFDataGetBytePtr(v10);
            memcpy(&v21[XmpOffset], v17, v16);
            v20 += v16;
            BYTE4(v22) = 1;
LABEL_18:
            LODWORD(v22) = TotalXMPLength;
          }
        }
        else
        {
          LogError("copyXMPProperties", 396, "*** ERROR: Extended XMP marker GUID length is not 32, skipping marker\n", v20);
        }
      }
      else
      {
        LogError("copyXMPProperties", 401, "*** ERROR: Extended XMP marker GUID data is NULL, skipping marker\n", v20);
      }
    }
LABEL_21:
    ++v4;
  }
  while (v2 != v4);
  if (v21 && v22 && v20 == v22 && BytePtr && Length)
  {
    uint64_t MetadataFromExtendedXMPData = CreateMetadataFromExtendedXMPData(BytePtr, Length, v21);
    goto LABEL_36;
  }
  if (!BytePtr || !Length)
  {
    uint64_t MetadataFromExtendedXMPData = 0;
    uint64_t result = 0;
    if (!v21) {
      return result;
    }
    goto LABEL_36;
  }
  uint64_t result = CreateMetadataFromXMPBuffer(BytePtr, Length);
  uint64_t MetadataFromExtendedXMPData = result;
  if (v21)
  {
LABEL_36:
    free(v21);
    return MetadataFromExtendedXMPData;
  }
  return result;
}

void _JPEGFile::setXMPProperties(_JPEGFile *this, const CGImageMetadata *a2)
{
  CFTypeRef cf = 0;
  CFDataRef theData = 0;
  CFTypeRef v9 = 0;
  CGImageMetadataCreateSerializedDataAndExtendedData(a2, &theData, (CFDataRef *)&cf, (CFDataRef *)&v9);
  unsigned int v3 = *((_DWORD *)this + 20) - *((_DWORD *)this + 18);
  int v4 = (unsigned __int16)(v3 >> 3);
  if ((unsigned __int16)(v3 >> 3))
  {
    int v5 = 0;
    do
    {
      uint64_t v6 = *((void *)this + 9);
      if (v5 >= (unint64_t)((*((void *)this + 10) - v6) >> 3)) {
        uint64_t v7 = 0;
      }
      else {
        uint64_t v7 = *(unsigned char **)(v6 + 8 * v5);
      }
      if (v7[69] || v7[70])
      {
        _JPEGFile::removeAppMarker((uint64_t)this, (uint64_t)v7);
        --v5;
        --v4;
        (*(void (**)(unsigned char *))(*(void *)v7 + 8))(v7);
      }
      ++v5;
    }
    while (v5 < v4);
  }
  if (!theData || CFDataGetLength(theData) < 65501) {
    operator new();
  }
  CFIndex Length = CFDataGetLength(theData);
  LogError("setXMPProperties", 473, "*** ERROR: xmpData size exceeds 64KB limit (%ld)\n", Length);
  CFRelease(theData);
  CFDataRef theData = 0;
  if (cf)
  {
    CFRelease(cf);
    CFTypeRef cf = 0;
  }
  if (v9) {
    CFRelease(v9);
  }
}

void sub_18878F1FC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C4027C9E144);
  _Unwind_Resume(a1);
}

void _JPEGFile::copyIPTCProperties(_JPEGFile *this)
{
}

void sub_18878F2FC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

uint64_t _JPEGFile::setICCProfile(_JPEGFile *this, CFDataRef theData)
{
  unsigned int v4 = *((_DWORD *)this + 20) - *((_DWORD *)this + 18);
  int v5 = (unsigned __int16)(v4 >> 3);
  if ((unsigned __int16)(v4 >> 3))
  {
    int v6 = 0;
    do
    {
      uint64_t v7 = *(unsigned char **)(*((void *)this + 9) + 8 * v6);
      if (v7[71])
      {
        _JPEGFile::removeAppMarker((uint64_t)this, *(void *)(*((void *)this + 9) + 8 * v6--));
        --v5;
        (*(void (**)(unsigned char *))(*(void *)v7 + 8))(v7);
      }
      ++v6;
    }
    while (v6 < v5);
  }
  if (!theData) {
    return 0;
  }
  CFIndex Length = CFDataGetLength(theData);
  unint64_t v9 = Length + 65518;
  if ((unint64_t)(Length + 65518) >= 0xFFEF00)
  {
    LogError("setICCProfile", 590, "*** ERROR: iccData exceeds maximum size of %d bytes\n", 16707345);
    return 0;
  }
  CFIndex v10 = Length;
  BytePtr = CFDataGetBytePtr(theData);
  if (v9 >= 0xFFEF)
  {
    if (v9 / 0xFFEF == 1) {
      CFIndex v12 = v10;
    }
    else {
      CFIndex v12 = 65519;
    }
    if (CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], BytePtr, v12)) {
      operator new();
    }
  }
  return 1;
}

void sub_18878F510(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C406AB96B01);
  _Unwind_Resume(a1);
}

uint64_t _JPEGFile::addMissingIFDTags(_JPEGFile *this)
{
  for (uint64_t i = *((void *)this + 9); ; i += 8)
  {
    if (i == *((void *)this + 10)) {
      operator new();
    }
    uint64_t v2 = *(unsigned char **)i;
    if (*(__int16 *)(*(void *)i + 56) == -31)
    {
      if (v2[68]) {
        break;
      }
    }
  }
  *(void *)int v5 = 0;
  unsigned int v4 = 0;
  _JPEGFile::getImageDimension(this, &v5[1], v5, &v4);
  return (*(uint64_t (**)(unsigned char *, void, void, void))(*(void *)v2 + 64))(v2, v5[1], v5[0], v4);
}

void sub_18878F608(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B1C401EC73DA2);
  _Unwind_Resume(a1);
}

void *_JPEGFile::getImageDimension(void *this, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t v4 = this[9];
  uint64_t v5 = this[10];
  if (v4 != v5)
  {
    uint64_t v6 = this[9];
    while (1)
    {
      this = *(void **)v6;
      if (*(__int16 *)(*(void *)v6 + 56) == -64) {
        break;
      }
      v6 += 8;
      if (v6 == v5)
      {
        while (1)
        {
          this = *(void **)v4;
          if (*(__int16 *)(*(void *)v4 + 56) == -37) {
            break;
          }
          v4 += 8;
          if (v4 == v5) {
            return this;
          }
        }
        return (void *)(*(uint64_t (**)(void *, unsigned int *, unsigned int *, unsigned int *))(*this + 72))(this, a2, a3, a4);
      }
    }
    return (void *)(*(uint64_t (**)(void *, unsigned int *, unsigned int *, unsigned int *))(*this + 72))(this, a2, a3, a4);
  }
  return this;
}

char *std::vector<_APPx *>::insert(uint64_t a1, char *__src, char *a3)
{
  unsigned int v3 = a3;
  uint64_t v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    unsigned int v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(a1 + 16, v18);
    }
    else {
      uint64_t v19 = 0;
    }
    uint64_t v20 = &v19[8 * v16];
    __p = v19;
    double v27 = v20;
    unint64_t v28 = v20;
    unsigned int v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        unint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v8, v22);
        uint64_t v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        double v27 = v20;
        unsigned int v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        double v27 = v20;
      }
    }
    *(void *)uint64_t v20 = *(void *)v3;
    unint64_t v28 = v20 + 8;
    uint64_t v4 = std::vector<_APPx *>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    unint64_t v9 = __src + 8;
    CFIndex v10 = v6 - 8;
    int v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)uint64_t v4 = *(void *)v3;
  }
  return v4;
}

void sub_18878F8AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__n128 _JPEGFile::processData(_JPEGFile *this)
{
  std::vector<_APPx *>::resize((uint64_t)this + 72, 0);
  *((void *)this + 5) = 0;
  uint64_t v3 = *((void *)this + 4);
  if (v3 <= 1) {
    goto LABEL_9;
  }
  uint64_t v4 = (unsigned __int16 *)*((void *)this + 3);
  unsigned int v5 = __rev16(*v4);
  *((void *)this + 5) = 2;
  if (*((unsigned char *)this + 48)) {
    BOOL v6 = 0;
  }
  else {
    BOOL v6 = v5 == 65496;
  }
  if (!v6) {
    return result;
  }
  if ((unint64_t)v3 <= 3 || (unsigned int v7 = v4[1], *((void *)this + 5) = 4, (unint64_t)v3 <= 5))
  {
LABEL_9:
    *((unsigned char *)this + 48) = 1;
    return result;
  }
  unsigned int v8 = __rev16(v4[2]);
  *((void *)this + 5) = 6;
  if (v8 <= 1) {
    return _cg_jpeg_mem_term("processData", 692, "*** ERROR: markerLength too small (%d)\n");
  }
  unsigned int v9 = bswap32(v7) >> 16;
  uint64_t v10 = v3 - 10;
  if (v10 <= v8) {
    LogWarning("processData", 695, "*** WARNING: check markerLength: %d - expected max: %d\n", v8, v10);
  }
  *((void *)this + 5) = 4;
  if (v9 >> 8 >= 0xFF)
  {
    LODWORD(v11) = 2;
    uint64_t v12 = 4;
    LODWORD(v13) = 4;
    while (1)
    {
      switch((__int16)v9)
      {
        case -64:
        case -63:
        case -62:
        case -61:
        case -60:
        case -59:
        case -58:
        case -57:
        case -37:
        case -35:
          operator new();
        case -56:
        case -55:
        case -54:
        case -53:
        case -52:
        case -51:
        case -50:
        case -49:
        case -48:
        case -47:
        case -46:
        case -45:
        case -44:
        case -43:
        case -42:
        case -41:
        case -40:
        case -38:
        case -36:
        case -34:
        case -33:
          goto LABEL_21;
        case -39:
          return result;
        case -32:
          operator new();
        case -31:
          unsigned int v14 = v8 + 2;
          uint64_t v15 = (v13 + 2);
          if (*((void *)this + 4) - 4 <= v15)
          {
            if (v8 != 2)
            {
              _cg_jpeg_mem_term("processData", 776, "*** WARNING: APP1 marker with unknown signature, does not match EXIF, XMP, or Extended XMP. (size:%d marker: %d)\n", 0, v8 + 2);
              operator new();
            }
          }
          else
          {
            unsigned int v16 = v8 - 2;
            if (v8 - 2 >= 4)
            {
              uint64_t v17 = (const char *)(*((void *)this + 3) + v15);
              if (!strncmp(v17, "Exif", 4uLL)) {
                operator new();
              }
              if (v16 >= 0x1C)
              {
                if (!strncmp(v17, "http://ns.adobe.com/xap/1.0/", 0x1CuLL)) {
                  operator new();
                }
                if (v16 >= 0x22 && !strncmp(v17, "http://ns.adobe.com/xmp/extension/", 0x22uLL)) {
                  operator new();
                }
              }
            }
          }
          __n128 result = _cg_jpeg_mem_term("processData", 783, "*** ERROR: unknown APP1 marker - skipping\n");
          uint64_t v11 = v14 + v11;
          goto LABEL_42;
        case -30:
          unsigned int v18 = v8 + 2;
          uint64_t v19 = *((void *)this + 3);
          uint64_t v20 = (const char *)(v19 + (v13 + 2));
          size_t v21 = v8 - 2;
          if (v21 >= 0xC
            && !strncmp((const char *)(v19 + (v13 + 2)), "ICC_PROFILE", 0xBuLL))
          {
            operator new();
          }
          if (strlen(v20) < v21) {
            operator new();
          }
          __n128 result = _cg_jpeg_mem_term("processData", 822, "*** ERROR: unknown APP2 marker - skipping\n");
          uint64_t v11 = v18 + v11;
          goto LABEL_42;
        default:
          if ((unsigned __int16)v9 == 65517) {
            operator new();
          }
          if ((unsigned __int16)v9 != 0xFFFF) {
LABEL_21:
          }
            operator new();
          uint64_t v11 = v12 + 1;
LABEL_42:
          *((void *)this + 5) = v11;
          uint64_t v22 = *((void *)this + 4);
          if (v11 > v22 - 2) {
            goto LABEL_9;
          }
          uint64_t v23 = *((void *)this + 3);
          unsigned int v24 = *(unsigned __int16 *)(v23 + v11);
          uint64_t v13 = v11 + 2;
          *((void *)this + 5) = v11 + 2;
          if (*((unsigned char *)this + 48)) {
            return result;
          }
          if (v13 > v22 - 2) {
            goto LABEL_9;
          }
          unsigned int v8 = __rev16(*(unsigned __int16 *)(v23 + v13));
          *((void *)this + 5) = v11 + 4;
          if (!v8) {
            return result;
          }
          if (v8 == 1) {
            return _cg_jpeg_mem_term("processData", 927, "*** ERROR: markerLength too small (%d)\n");
          }
          uint64_t v25 = v22 - (v11 + 4) - 4;
          if (v25 <= v8) {
            LogWarning("processData", 930, "*** WARNING: check markerLength: %d - expected max: %d\n", v8, v25);
          }
          unsigned int v9 = bswap32(v24) >> 16;
          uint64_t v12 = v11;
          *((void *)this + 5) = v11;
          if (v9 >> 8 <= 0xFE) {
            return result;
          }
          break;
      }
    }
  }
  return result;
}

void sub_18878FF78(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C407B1DB21FLL);
  _Unwind_Resume(a1);
}

uint64_t _JPEGFile::getshort(_JPEGFile *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (v1 <= *((void *)this + 4) - 2)
  {
    uint64_t v2 = bswap32(*(unsigned __int16 *)(*((void *)this + 3) + v1)) >> 16;
    *((void *)this + 5) = v1 + 2;
  }
  else
  {
    uint64_t v2 = 0;
    *((unsigned char *)this + 48) = 1;
  }
  return v2;
}

uint64_t _JPEGFile::createExtendedAPP0(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 72);
  if (v1 != *(void *)(this + 80))
  {
    if (*(__int16 *)(*(void *)v1 + 56) != -32) {
      operator new();
    }
    uint64_t v2 = *(uint64_t (**)(void))(**(void **)v1 + 128);
    return v2();
  }
  return this;
}

void sub_1887901D4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1091C4040CFD0ABLL);
  _Unwind_Resume(a1);
}

void *_JPEGFile::writeToStream(void *this, __CFWriteStream *a2)
{
  uint64_t v3 = this;
  unsigned int v5 = (char *)this[9];
  uint64_t v4 = (char *)this[10];
  if (v5 == v4)
  {
    int v6 = 0;
    int v8 = -1;
    int v7 = -1;
  }
  else
  {
    int v6 = 0;
    int v7 = -1;
    int v8 = -1;
    unsigned int v9 = (char *)this[9];
    do
    {
      if (*(__int16 *)(*(void *)v9 + 56) == -31)
      {
        if (*(unsigned char *)(*(void *)v9 + 68)) {
          int v7 = v6;
        }
        else {
          int v8 = v6;
        }
        ++v6;
      }
      v9 += 8;
    }
    while (v9 != v4);
  }
  if (v6 == 2 && v8 != -1 && v7 != -1 && v8 < v7)
  {
    uint64_t v10 = *(void *)&v5[8 * v8];
    *(void *)&v5[8 * v8] = *(void *)&v5[8 * v7];
    *(void *)&v5[8 * v7] = v10;
    unsigned int v5 = (char *)this[9];
    uint64_t v4 = (char *)this[10];
  }
  if (v4 - v5 == 16)
  {
    uint64_t v11 = (__int16 *)*((void *)v5 + 1);
    if (v11[28] == -37)
    {
      this = (void *)(*(uint64_t (**)(void))(*(void *)v11 + 24))(*((void *)v5 + 1));
      unsigned int v5 = (char *)v3[9];
      if (this > 0x3000)
      {
        this = *(void **)v5;
        if (*(__int16 *)(*(void *)v5 + 56) == -31)
        {
          (*(void (**)(void *))(*this + 88))(this);
          this = (void *)(*(uint64_t (**)(__int16 *))(*(void *)v11 + 88))(v11);
          unsigned int v5 = (char *)v3[9];
        }
      }
    }
  }
  uint64_t v12 = (char *)v3[10];
  while (v5 != v12)
  {
    uint64_t v13 = *(void *)v5;
    this = (void *)(*(uint64_t (**)(void))(**(void **)v5 + 24))(*(void *)v5);
    if (this) {
      this = (void *)(*(uint64_t (**)(uint64_t, __CFWriteStream *))(*(void *)v13 + 32))(v13, a2);
    }
    v5 += 8;
  }
  return this;
}

uint64_t _JPEGFile::dump(uint64_t this, const char *a2)
{
  uint64_t v3 = *(uint64_t **)(this + 72);
  uint64_t v2 = *(uint64_t **)(this + 80);
  if (v2 != v3)
  {
    uint64_t v4 = this;
    char v5 = 1;
    do
    {
      uint64_t v6 = *v3++;
      this = (*(uint64_t (**)(uint64_t, void))(*(void *)v6 + 80))(v6, v5 & 1);
      char v5 = 0;
    }
    while (v3 != v2);
    for (uint64_t i = *(void *)(v4 + 72); i != *(void *)(v4 + 80); i += 8)
    {
      this = *(void *)i;
      if (*(__int16 *)(*(void *)i + 56) == -31 && *(unsigned char *)(this + 68))
      {
        int v8 = *(uint64_t (**)(void))(*(void *)this + 128);
        return v8();
      }
    }
  }
  return this;
}

void _JPEGWriter::_JPEGWriter(_JPEGWriter *this, CGImage *a2, const __CFData *a3, const __CFData *a4, IIODictionary *a5, const CGImageMetadata *a6, char a7)
{
  *(void *)this = &unk_1ED4DEEF8;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = a4;
  uint64_t Mutable = CGImageMetadataCreateFromLegacyProps(a5);
  if (!Mutable) {
    uint64_t Mutable = (uint64_t)CGImageMetadataCreateMutable();
  }
  CGImageMetadataMerge(Mutable, (uint64_t)a6, 0);
  *((void *)this + 4) = a5;
  *((void *)this + 5) = Mutable;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((unsigned char *)this + 66) = a7;
  *((_OWORD *)this + 3) = 0u;
  *((unsigned char *)this + 65) = 0;
  *((unsigned char *)this + 67) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  if (a5)
  {
    if (IIODictionary::containsKey(a5, @"kCGImageWriteExtendedAPP0")) {
      *((unsigned char *)this + 67) = IIODictionary::getBoolForKey(*((IIODictionary **)this + 4), @"kCGImageWriteExtendedAPP0");
    }
  }
}

void _JPEGWriter::~_JPEGWriter(_JPEGWriter *this)
{
  *(void *)this = &unk_1ED4DEEF8;
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    *((void *)this + 10) = 0;
  }
  uint64_t v3 = *((void *)this + 11);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    *((void *)this + 11) = 0;
  }
  uint64_t v4 = *((void *)this + 12);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    *((void *)this + 12) = 0;
  }
  uint64_t v5 = *((void *)this + 7);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    *((void *)this + 7) = 0;
  }
  uint64_t v6 = (const void *)*((void *)this + 5);
  if (v6)
  {
    CFRelease(v6);
    *((void *)this + 5) = 0;
  }
  int v7 = (const void *)*((void *)this + 9);
  if (v7)
  {
    CFRelease(v7);
    *((void *)this + 9) = 0;
  }
  uint64_t v8 = *((void *)this + 6);
  if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    *((void *)this + 6) = 0;
  }
}

{
  uint64_t vars8;

  _JPEGWriter::~_JPEGWriter(this);

  JUMPOUT(0x18C11C0E0);
}

void _JPEGWriter::processInput(_JPEGWriter *this)
{
  if (*((void *)this + 2)) {
    operator new();
  }
  CFDataRef v2 = (const __CFData *)*((void *)this + 3);
  if (v2 && CFDataGetLength(v2)) {
    operator new();
  }
  if (*((void *)this + 4)) {
    operator new();
  }
  uint64_t v3 = (void *)*((void *)this + 5);
  if (v3)
  {
    uint64_t v4 = (const __CFDictionary **)CGImagePropertiesCreateFromMetadata(v3);
    if (v4)
    {
      uint64_t v5 = v4;
      IIODictionary::appendDictionary(*((IIODictionary **)this + 7), v4);
      (*((void (**)(const __CFDictionary **))*v5 + 1))(v5);
    }
  }
  uint64_t v6 = (IIODictionary *)*((void *)this + 7);
  if (v6)
  {
    size_t __len = 0;
    int v7 = (unsigned char *)CreateExifBufferFromPropertiesJPEG(v6, 0, 0, 0, 0, @"public.jpeg", &__len);
    if (v7) {
      BOOL v8 = __len >= 0xFFFA;
    }
    else {
      BOOL v8 = 0;
    }
    if (v8)
    {
      CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(*((IIODictionary **)this + 7), @"{Exif}");
      if (ObjectForKey)
      {
        uint64_t v10 = ObjectForKey;
        if (CFDictionaryGetValue(ObjectForKey, @"UserComment"))
        {
          CFDictionaryRemoveValue(v10, @"UserComment");
          free(v7);
          int v7 = (unsigned char *)CreateExifBufferFromPropertiesJPEG(*((IIODictionary **)this + 7), 0, 0, 0, 0, @"public.jpeg", &__len);
        }
      }
    }
    if (v7) {
      BOOL v11 = __len > 0xFFF9;
    }
    else {
      BOOL v11 = 1;
    }
    if (!v11)
    {
      uint64_t v12 = (char *)reallocf(v7, __len + 18);
      if (!v12) {
        goto LABEL_47;
      }
      int v7 = v12;
      size_t v13 = __len;
      memmove(v12 + 6, v12, __len);
      *(_DWORD *)int v7 = -503326465;
      v7[4] = (unsigned __int16)(v13 + 6) >> 8;
      v7[5] = v13 + 6;
      size_t __len = v13 + 18;
      unsigned int v14 = &v7[v13 + 18];
      *((_DWORD *)v14 - 1) = 0;
      *(void *)(v14 - 12) = 0;
      CFDataRef v15 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v7, v13 + 18);
      *((void *)this + 9) = v15;
      if (v15) {
        operator new();
      }
    }
    free(v7);
    unsigned int v16 = (_JPEGFile *)*((void *)this + 10);
    if (v16)
    {
      uint64_t v17 = (_JPEGFile *)*((void *)this + 12);
      if (v17) {
        _JPEGFile::mergeWithFile(v16, v17);
      }
    }
  }
  uint64_t v18 = *((void *)this + 10);
  if (v18)
  {
    uint64_t v19 = (_JPEGFile *)*((void *)this + 11);
    if (v19)
    {
LABEL_32:
      _JPEGFile::copyThumbnail((unsigned char *)v18, v19);
    }
    else if (*((unsigned char *)this + 65))
    {
      uint64_t v21 = *(void *)(v18 + 72);
      uint64_t v22 = *(void *)(v18 + 80);
      while (v21 != v22)
      {
        uint64_t v23 = *(unsigned char **)v21;
        if (*(__int16 *)(*(void *)v21 + 56) == -31 && v23[68])
        {
          if (!(*(uint64_t (**)(unsigned char *))(*(void *)v23 + 48))(v23)) {
            break;
          }
          uint64_t v18 = *((void *)this + 10);
          uint64_t v19 = (_JPEGFile *)v18;
          goto LABEL_32;
        }
        v21 += 8;
      }
    }
    _JPEGFile::addMissingIFDTags(*((_JPEGFile **)this + 10));
  }
  uint64_t v20 = (const void *)*((void *)this + 5);
  if (v20)
  {
    if (*((void *)this + 10))
    {
      unsigned int v24 = (const CGImageMetadata *)CFRetain(v20);
      if (v24)
      {
        if (CGImageMetadataCreateXMPWithEXIFFiltered(v24)) {
          operator new();
        }
        CFRelease(v24);
      }
    }
  }
LABEL_47:
  if (*((unsigned char *)this + 67)) {
    _JPEGFile::createExtendedAPP0(*((void *)this + 10));
  }
}

void sub_188790E80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void _JPEGWriter::cleanupProperties(_JPEGWriter *this, IIODictionary *a2)
{
  IIODictionary::removeObjectForKey(a2, @"{Diagnostic}");
  if (IIODictionary::containsKey(a2, @"iOS_Debug"))
  {
    IIODictionary::getObjectForKey(a2, @"iOS_Debug");
    operator new();
  }
  if (IIODictionary::containsKey(a2, @"iOSCustom"))
  {
    IIODictionary::getObjectForKey(a2, @"iOSCustom");
    operator new();
  }
  if ((IIODictionary::containsKey(a2, @"{TIFF}") & 1) == 0)
  {
    IIODictionary::IIODictionary((IIODictionary *)&v25);
    IIODictionary::setObjectForKey(a2, value, @"{TIFF}");
    IIODictionary::~IIODictionary((IIODictionary *)&v25);
  }
  if (IIODictionary::containsKey(a2, @"{Exif}"))
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a2, @"{Exif}");
    uint64_t v25 = 0;
    value = 0;
    uint64_t v27 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v25, ObjectForKey);
    IIODictionary::removeObjectForKey((IIODictionary *)&v25, @"ThumbnailOffset");
    IIODictionary::removeObjectForKey((IIODictionary *)&v25, @"ThumbnailSize");
    CFDictionaryRef v5 = IIODictionary::getObjectForKey((IIODictionary *)&v25, @"{GPS}");
    if (v5)
    {
      IIODictionary::setObjectForKey(a2, v5, @"{GPS}");
      IIODictionary::removeObjectForKey((IIODictionary *)&v25, @"{GPS}");
    }
    CFDictionaryRef v6 = IIODictionary::getObjectForKey((IIODictionary *)&v25, @"{ExifAux}");
    if (v6)
    {
      IIODictionary::setObjectForKey(a2, v6, @"{ExifAux}");
      IIODictionary::removeObjectForKey((IIODictionary *)&v25, @"{ExifAux}");
    }
  }
  else
  {
    IIODictionary::IIODictionary((IIODictionary *)&v25);
    IIODictionary::setObjectForKey(a2, value, @"{Exif}");
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v25);
  int v7 = IIODictionary::getObjectForKey(a2, @"{TIFF}");
  uint64_t v25 = 0;
  value = 0;
  uint64_t v27 = 0;
  BOOL v8 = IIODictionary::IIODictionary((IIODictionary *)&v25, v7);
  _JPEGWriter::syncTopLevelAndSubDictionaries(v8, a2, (IIODictionary *)&v25);
  unsigned int v9 = IIODictionary::getObjectForKey(a2, @"{Exif}");
  memset(v24, 0, sizeof(v24));
  IIODictionary::IIODictionary((IIODictionary *)v24, v9);
  uint64_t v10 = IIODictionary::containsKey(a2, @"Orientation");
  if ((v10 & 1) == 0)
  {
    uint64_t v10 = IIODictionary::containsKey((IIODictionary *)v24, @"Orientation");
    if ((v10 & 1) == 0)
    {
      uint64_t v10 = IIODictionary::containsKey(a2, @"kCGImageCopyFileSetOrientation");
      if (v10)
      {
        CFDictionaryRef v12 = IIODictionary::getObjectForKey(a2, @"kCGImageCopyFileSetOrientation");
        IIODictionary::setObjectForKey(a2, v12, @"Orientation");
      }
    }
  }
  if (*((unsigned char *)this + 66))
  {
    _JPEGWriter::addExifVersionIfNeeded(v10, v11, (IIODictionary *)v24);
    _JPEGWriter::addExifFlashPixVersionIfNeeded(v13, v14, (IIODictionary *)v24);
    _JPEGWriter::addExifColorSpaceIfNeeded(v15, v16, (IIODictionary *)v24);
    _JPEGWriter::addExifSceneCaptureTypeIfNeeded(v17, v18, (IIODictionary *)v24);
    _JPEGWriter::addTIFFYCbCrPositioningIfNeeded(v19, v20, (IIODictionary *)&v25);
    _JPEGWriter::addExifComponentsConfigurationIfNeeded(v21, v22, (IIODictionary *)v24);
    _JPEGWriter::addExifPixelDimensionsIfNeeded(this, v23, (IIODictionary *)v24);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v24);
  IIODictionary::~IIODictionary((IIODictionary *)&v25);
}

void sub_1887912B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void _JPEGWriter::syncTopLevelAndSubDictionaries(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a2, @"Orientation");
  if (ObjectForKey) {
    IIODictionary::setObjectForKey(a3, ObjectForKey, @"Orientation");
  }
  CFDictionaryRef v6 = IIODictionary::getObjectForKey(a2, @"DPIWidth");
  CFDictionaryRef v7 = IIODictionary::getObjectForKey(a2, @"DPIHeight");
  CFDictionaryRef v8 = IIODictionary::getObjectForKey(a3, @"XResolution");
  CFDictionaryRef v9 = IIODictionary::getObjectForKey(a3, @"YResolution");
  if (v6) {
    BOOL v10 = v7 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  int v11 = !v10;
  if (v11 != 1 || v8 == 0 || v9 == 0)
  {
    if (v11)
    {
      IIODictionary::setObjectForKey(a3, v6, @"XResolution");
      unsigned int v14 = a3;
      CFDictionaryRef v15 = v7;
      CFStringRef v16 = @"YResolution";
    }
    else
    {
      CFDictionaryRef v17 = v9;
      if (v8) {
        BOOL v18 = v9 == 0;
      }
      else {
        BOOL v18 = 1;
      }
      if (v18)
      {
        IIONumber::IIONumber((IIONumber *)v22, 72.0);
        IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v22, @"DPIWidth");
        IIONumber::~IIONumber((IIONumber *)v22);
        IIONumber::IIONumber((IIONumber *)v21, 72.0);
        IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v21, @"DPIHeight");
        IIONumber::~IIONumber((IIONumber *)v21);
        IIONumber::IIONumber((IIONumber *)v20, 72.0);
        IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v20, @"XResolution");
        IIONumber::~IIONumber((IIONumber *)v20);
        IIONumber::IIONumber((IIONumber *)v19, 72.0);
        IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v19, @"YResolution");
        IIONumber::~IIONumber((IIONumber *)v19);
        return;
      }
      IIODictionary::setObjectForKey(a2, v8, @"DPIWidth");
      unsigned int v14 = a2;
      CFDictionaryRef v15 = v17;
      CFStringRef v16 = @"DPIHeight";
    }
    IIODictionary::setObjectForKey(v14, v15, v16);
  }
}

void sub_188791538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void _JPEGWriter::addExifVersionIfNeeded(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  if ((IIODictionary::containsKey(a3, @"ExifVersion") & 1) == 0)
  {
    CFMutableArrayRef v7 = 0;
    CFDictionaryRef v8 = 0;
    uint64_t v9 = 0;
    IIOArray::IIOArray((IIOArray *)&v7);
    IIONumber::IIONumber((IIONumber *)v6, 2);
    IIOArray::addObject(&v7, (uint64_t)v6);
    IIONumber::~IIONumber((IIONumber *)v6);
    IIONumber::IIONumber((IIONumber *)v5, 2);
    IIOArray::addObject(&v7, (uint64_t)v5);
    IIONumber::~IIONumber((IIONumber *)v5);
    IIONumber::IIONumber((IIONumber *)v4, 1);
    IIOArray::addObject(&v7, (uint64_t)v4);
    IIONumber::~IIONumber((IIONumber *)v4);
    IIODictionary::setObjectForKey(a3, v8, @"ExifVersion");
    IIOArray::~IIOArray((IIOArray *)&v7);
  }
}

void sub_18879163C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  IIONumber::~IIONumber((IIONumber *)&a9);
  IIOArray::~IIOArray((IIOArray *)(v9 - 40));
  _Unwind_Resume(a1);
}

void _JPEGWriter::addExifFlashPixVersionIfNeeded(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  if ((IIODictionary::containsKey(a3, @"FlashPixVersion") & 1) == 0)
  {
    CFMutableArrayRef v6 = 0;
    CFMutableArrayRef v7 = 0;
    uint64_t v8 = 0;
    IIOArray::IIOArray((IIOArray *)&v6);
    IIONumber::IIONumber((IIONumber *)v5, 1);
    IIOArray::addObject(&v6, (uint64_t)v5);
    IIONumber::~IIONumber((IIONumber *)v5);
    IIONumber::IIONumber((IIONumber *)v4, 0);
    IIOArray::addObject(&v6, (uint64_t)v4);
    IIONumber::~IIONumber((IIONumber *)v4);
    IIODictionary::setObjectForKey(a3, v7, @"FlashPixVersion");
    IIOArray::~IIOArray((IIOArray *)&v6);
  }
}

void sub_188791724(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  IIOArray::~IIOArray((IIOArray *)(v2 - 40));
  _Unwind_Resume(a1);
}

void _JPEGWriter::addExifColorSpaceIfNeeded(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  if ((IIODictionary::containsKey(a3, @"ColorSpace") & 1) == 0)
  {
    IIONumber::IIONumber((IIONumber *)v4, 1);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v4, @"ColorSpace");
    IIONumber::~IIONumber((IIONumber *)v4);
  }
}

void sub_1887917BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void _JPEGWriter::addExifSceneCaptureTypeIfNeeded(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  if ((IIODictionary::containsKey(a3, @"SceneCaptureType") & 1) == 0)
  {
    IIONumber::IIONumber((IIONumber *)v4, 0);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v4, @"SceneCaptureType");
    IIONumber::~IIONumber((IIONumber *)v4);
  }
}

void sub_188791838(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void _JPEGWriter::addTIFFYCbCrPositioningIfNeeded(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  if ((IIODictionary::containsKey(a3, @"_YCbCrPositioning") & 1) == 0)
  {
    IIONumber::IIONumber((IIONumber *)v4, 1);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v4, @"_YCbCrPositioning");
    IIONumber::~IIONumber((IIONumber *)v4);
  }
}

void sub_1887918B4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void _JPEGWriter::addExifComponentsConfigurationIfNeeded(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  if ((IIODictionary::containsKey(a3, @"ComponentsConfiguration") & 1) == 0)
  {
    IIONumber::IIONumber((IIONumber *)v4, 16909056);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v4, @"ComponentsConfiguration");
    IIONumber::~IIONumber((IIONumber *)v4);
  }
}

void sub_188791934(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void _JPEGWriter::addExifPixelDimensionsIfNeeded(_JPEGWriter *this, IIODictionary *a2, IIODictionary *a3)
{
  if (*((void *)this + 10)
    && (!IIODictionary::containsKey(a3, @"PixelXDimension")
     || (IIODictionary::containsKey(a3, @"PixelYDimension") & 1) == 0))
  {
    *(void *)CFMutableArrayRef v7 = 0;
    _JPEGFile::getImageDimension(*((void **)this + 10), &v7[1], v7, 0);
    IIONumber::IIONumber((IIONumber *)v6, v7[1]);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v6, @"PixelXDimension");
    IIONumber::~IIONumber((IIONumber *)v6);
    IIONumber::IIONumber((IIONumber *)v5, v7[0]);
    IIODictionary::setObjectForKey((uint64_t)a3, (uint64_t)v5, @"PixelYDimension");
    IIONumber::~IIONumber((IIONumber *)v5);
  }
}

void sub_188791A18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t _JPEGWriter::writePropertiesAndData(_JPEGWriter *this, __CFWriteStream *a2)
{
  *((unsigned char *)this + 64) = 0;
  if (*((void *)this + 10))
  {
    CFDataRef v3 = (const __CFData *)*((void *)this + 2);
    if (v3)
    {
      BytePtr = CFDataGetBytePtr(v3);
      if ((unint64_t)CFDataGetLength(*((CFDataRef *)this + 2)) >= 2 && *BytePtr == 255 && BytePtr[1] == 216)
      {
        CFWriteStreamWrite(a2, BytePtr, 2);
        _JPEGFile::writeToStream(*((void **)this + 10), a2);
      }
    }
  }
  return 1;
}

CFTypeRef _JPEGWriter::createData(_JPEGWriter *this)
{
  uint64_t v2 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  if (!v2) {
    return 0;
  }
  CFDataRef v3 = v2;
  if (CFWriteStreamOpen(v2))
  {
    _JPEGWriter::writePropertiesAndData(this, v3);
    CFTypeRef v4 = CFWriteStreamCopyProperty(v3, (CFStreamPropertyKey)*MEMORY[0x1E4F1D440]);
    CFWriteStreamClose(v3);
  }
  else
  {
    CFTypeRef v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

void _JPEGWriter::writeToPath(_JPEGWriter *this, const __CFString *a2)
{
  CFURLRef v3 = CFURLCreateWithFileSystemPath(0, a2, kCFURLPOSIXPathStyle, 0);
  if (v3)
  {
    CFURLRef v4 = v3;
    CFDictionaryRef v5 = CFWriteStreamCreateWithFile(0, v3);
    if (v5)
    {
      CFMutableArrayRef v6 = v5;
      if (CFWriteStreamOpen(v5))
      {
        CFDataRef v7 = (const __CFData *)CFWriteStreamCopyProperty(v6, @"_kCFStreamPropertyFileNativeHandle");
        if (v7)
        {
          CFDataRef v8 = v7;
          *(_DWORD *)buffer = 0;
          v11.location = 0;
          v11.size_t length = 4;
          CFDataGetBytes(v7, v11, buffer);
          fcntl(*(int *)buffer, 48, 1);
          fcntl(*(int *)buffer, 62, 1);
          CFRelease(v8);
        }
        _JPEGWriter::writePropertiesAndData(this, v6);
        CFWriteStreamClose(v6);
      }
      else
      {
        LogError("writeToPath", 1945, "*** ERROR: CFWriteStreamOpen failed\n");
      }
      CFRelease(v6);
    }
    else
    {
      LogError("writeToPath", 1950, "*** ERROR: CFWriteStreamCreateWithFile failed\n");
    }
    CFRelease(v4);
  }
  else
  {
    LogError("writeToPath", 1955, "*** ERROR: CFURLCreateWithFileSystemPath failed\n");
  }
}

uint64_t CGImageWriteEXIFJPEGToPath(CGImage *a1, CFDataRef theData, const __CFData *a3, const __CFString *a4, const __CFDictionary *a5)
{
  if (theData)
  {
    CFDataGetLength(theData);
    if (!a3) {
      goto LABEL_5;
    }
    goto LABEL_3;
  }
  if (a3) {
LABEL_3:
  }
    CFDataGetLength(a3);
LABEL_5:
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageWriteEXIFJPEGToPath", 0, 0, -1, a5);
  }
  memset(v13, 0, sizeof(v13));
  IIODictionary::IIODictionary((IIODictionary *)v13, a5);
  uint64_t v12 = 0;
  memset(v11, 0, sizeof(v11));
  _JPEGWriter::_JPEGWriter((_JPEGWriter *)v11, a1, theData, a3, (IIODictionary *)v13, 0, 1);
  _JPEGWriter::processInput((_JPEGWriter *)v11);
  _JPEGWriter::writeToPath((_JPEGWriter *)v11, a4);
  _JPEGWriter::~_JPEGWriter((_JPEGWriter *)v11);
  IIODictionary::~IIODictionary((IIODictionary *)v13);
  return kdebug_trace();
}

void sub_188791E10(void *a1)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 88));
  __cxa_begin_catch(a1);
  syslog(3, "*** ERROR: ImageIO - CGImageWriteEXIFJPEGToPath failed\n");
  __cxa_end_catch();
  JUMPOUT(0x188791DDCLL);
}

void sub_188791E54(_Unwind_Exception *a1)
{
}

uint64_t CGImageCreateEXIFJPEGData(uint64_t a1, uint64_t a2, uint64_t a3, const __CFDictionary *a4)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateEXIFJPEGData", 0, 0, -1, a4);
  }
  if (a2 | a3)
  {
    memset(v8, 0, sizeof(v8));
    IIODictionary::IIODictionary((IIODictionary *)v8, a4);
    operator new();
  }
  syslog(3, "*** ERROR: ImageIO - CGImageCreateEXIFJPEGData failed (jpegData and thumbnailData are nil)\n");
  kdebug_trace();
  return 0;
}

void sub_188792058(_Unwind_Exception *a1)
{
}

BOOL CGImageWriteEXIFJPEGWithMetadata(__CFWriteStream *a1, const __CFData *a2, const __CFData *a3, const __CFDictionary *a4, const CGImageMetadata *a5, CFErrorRef *a6)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageWriteEXIFJPEGWithMetadata", 0, 0, -1, 0);
  }
  if ((unint64_t)a2 | (unint64_t)a3)
  {
    memset(v17, 0, sizeof(v17));
    IIODictionary::IIODictionary((IIODictionary *)v17, a4);
    uint64_t v16 = 0;
    memset(v15, 0, sizeof(v15));
    _JPEGWriter::_JPEGWriter((_JPEGWriter *)v15, 0, a2, a3, (IIODictionary *)v17, a5, 1);
    _JPEGWriter::processInput((_JPEGWriter *)v15);
    _JPEGWriter::writePropertiesAndData((_JPEGWriter *)v15, a1);
    CFErrorRef v12 = CFWriteStreamCopyError(a1);
    BOOL v13 = v12 == 0;
    if (v12)
    {
      if (a6) {
        *a6 = v12;
      }
      else {
        CFRelease(v12);
      }
    }
    _JPEGWriter::~_JPEGWriter((_JPEGWriter *)v15);
    IIODictionary::~IIODictionary((IIODictionary *)v17);
  }
  else
  {
    BOOL v13 = 1;
  }
  kdebug_trace();
  return v13;
}

void sub_1887921DC(void *a1)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v2 - 88));
  __cxa_begin_catch(a1);
  CGImageMetadataCreateAndLogUTF8Error(0, 0, 0, "CGImageWriteEXIFJPEGWithMetadata failed with unknown error.", v1);
  __cxa_end_catch();
  JUMPOUT(0x1887921A4);
}

void sub_188792234(_Unwind_Exception *a1)
{
}

BOOL CGImageCopyFileWithParameters(__CFString *a1, const __CFString *a2, const __CFDictionary *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCopyFileWithParameters", 0, 0, -1, a3);
  }
  memset(v18, 0, sizeof(v18));
  IIODictionary::IIODictionary((IIODictionary *)v18, a3);
  if (a1)
  {
    CFTypeID v6 = CFGetTypeID(a1);
    if (v6 == CFStringGetTypeID() || v6 == CFDataGetTypeID() || v6 == CGDataProviderGetTypeID())
    {
      CFStringRef v7 = a2;
      if (a2 || (TypeID = CFStringGetTypeID(), CFStringRef v7 = a1, v6 == TypeID))
      {
        CFTypeID v17 = CFGetTypeID(v7);
        if (v17 == CFStringGetTypeID() || v17 == CFDataGetTypeID())
        {
          if (a3)
          {
            CFTypeID v9 = CFGetTypeID(a3);
            if (v9 == CFDictionaryGetTypeID())
            {
              if (v6 != CFStringGetTypeID())
              {
                if (v6 == CFDataGetTypeID())
                {
                  CFErrorRef v12 = 0;
                  CFDataRef v14 = (const __CFData *)CFRetain(a1);
                }
                else
                {
                  if (v6 != CGDataProviderGetTypeID())
                  {
                    CFErrorRef v12 = 0;
LABEL_35:
                    BOOL v15 = CGImageCopyFileWithParametersOLD(a1, a2, (IIODictionary *)v18);
                    goto LABEL_40;
                  }
                  CFErrorRef v12 = 0;
                  CFDataRef v14 = CGDataProviderCopyData((CGDataProviderRef)a1);
                }
                CFDataRef v13 = v14;
LABEL_32:
                if (v13) {
                  operator new();
                }
                goto LABEL_35;
              }
              bzero(v20, 0x400uLL);
              memset(&v19, 0, sizeof(v19));
              if (_CFStringGetFileSystemRepresentation())
              {
                int v10 = open(v20, 0, 0);
                int v11 = v10;
                if ((gIIODebugFlags & 0x200000000000) != 0) {
                  ImageIOLog(">>> %s: opening file [%d] '%s'\n", "CGImageCopyFileWithParameters", v10, v20);
                }
                if ((v11 & 0x80000000) == 0)
                {
                  if (fstat(v11, &v19) < 0)
                  {
                    if ((gIIODebugFlags & 0x200000000000) != 0) {
                      ImageIOLog("<<< %s: closing file [%d] '%s'\n", "CGImageCopyFileWithParameters", v11, v20);
                    }
                    close(v11);
                  }
                  else
                  {
                    CFErrorRef v12 = (unsigned __int8 *)malloc_type_malloc(v19.st_size, 0x7BA9BA60uLL);
                    if (v12)
                    {
                      read(v11, v12, v19.st_size);
                      if (*v12 == 255 && v12[1] == 216) {
                        CFDataRef v13 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v12, v19.st_size, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
                      }
                      else {
                        CFDataRef v13 = 0;
                      }
                      if ((gIIODebugFlags & 0x200000000000) != 0) {
                        ImageIOLog("<<< %s: closing file [%d] '%s'\n", "CGImageCopyFileWithParameters", v11, v20);
                      }
                      close(v11);
                      goto LABEL_32;
                    }
                    _cg_jpeg_mem_term("CGImageCopyFileWithParameters", 2286, "*** ERROR: cannot allocate srcBuffer [%ld bytes]\n", v19.st_size);
                  }
                }
              }
            }
            else
            {
              LogError("CGImageCopyFileWithParameters", 2239, "*** ERROR: parameters is wrong type\n");
            }
          }
          else
          {
            _cg_jpeg_mem_term("CGImageCopyFileWithParameters", 2238, "*** ERROR: no options specified?\n");
          }
        }
        else
        {
          LogError("CGImageCopyFileWithParameters", 2235, "*** ERROR: dstPath is wrong type\n");
        }
      }
    }
    else
    {
      LogError("CGImageCopyFileWithParameters", 2214, "*** ERROR: srcPath is wrong type\n");
    }
  }
  else
  {
    LogError("CGImageCopyFileWithParameters", 2207, "*** ERROR: srcPath is nil\n");
  }
  BOOL v15 = 0;
  CFErrorRef v12 = 0;
LABEL_40:
  if (v12) {
    free(v12);
  }
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v18);
  return v15;
}

void sub_1887930F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    syslog(3, "*** ERROR: ImageIO - CGImageCopyFileWithParameters failed\n");
    __cxa_end_catch();
    if (!v45) {
      JUMPOUT(0x188792F70);
    }
    JUMPOUT(0x188792F48);
  }
  _Unwind_Resume(exception_object);
}

void ExifScanner::~ExifScanner(ExifScanner *this)
{
  *(void *)this = &unk_1ED4DED18;
  if (*((unsigned char *)this + 81))
  {
    uint64_t v1 = (void *)*((void *)this + 4);
    if (v1) {
      free(v1);
    }
  }
}

{
  void *v1;

  *(void *)this = &unk_1ED4DED18;
  if (*((unsigned char *)this + 81))
  {
    uint64_t v1 = (void *)*((void *)this + 4);
    if (v1) {
      free(v1);
    }
  }
}

{
  void *v1;
  uint64_t vars8;

  *(void *)this = &unk_1ED4DED18;
  if (*((unsigned char *)this + 81))
  {
    uint64_t v1 = (void *)*((void *)this + 4);
    if (v1) {
      free(v1);
    }
  }

  JUMPOUT(0x18C11C0E0);
}

unint64_t ExifScanner::setup(ExifScanner *this, uint64_t a2)
{
  *((unsigned char *)this + 24) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((unsigned char *)this + 80) = 0;
  *((void *)this + 7) = 0;
  if (a2 >= 0x4000) {
    size_t v3 = 0x4000;
  }
  else {
    size_t v3 = a2;
  }
  *((void *)this + 5) = v3;
  *((void *)this + 6) = a2;
  *((void *)this + 4) = malloc_type_malloc(v3, 0xD41DE559uLL);
  (*(void (**)(ExifScanner *))(*(void *)this + 16))(this);
  unint64_t result = ExifScanner::read16(this);
  if (result == 65496)
  {
    unint64_t result = ExifScanner::read16(this);
    if (result >= 0x100)
    {
      *((unsigned char *)this + 80) = 1;
      if (result == 65505)
      {
        unsigned int v5 = ExifScanner::read16(this);
        unint64_t result = (*(uint64_t (**)(ExifScanner *, uint64_t))(*(void *)this + 32))(this, *((void *)this + 7) + v5 + 12);
      }
    }
  }
  *((void *)this + 7) = 0;
  return result;
}

unint64_t ExifScanner::read16(ExifScanner *this)
{
  unint64_t v1 = 0;
  uint64_t v2 = *((void *)this + 7);
  uint64_t v3 = *((void *)this + 5);
  if ((v2 & 0x8000000000000000) == 0 && v2 < v3 - 2)
  {
    unint64_t v1 = *((void *)this + 4) + v2;
    int v4 = *(unsigned __int8 *)v1;
    LODWORD(v1) = *(unsigned __int8 *)(v1 + 1);
    unsigned int v5 = v4 | (v1 << 8);
    LODWORD(v1) = v1 | (v4 << 8);
    if (*((unsigned char *)this + 24)) {
      unint64_t v1 = v5;
    }
    else {
      unint64_t v1 = v1;
    }
    uint64_t v3 = v2 + 2;
  }
  *((void *)this + 7) = v3;
  return v1;
}

ssize_t ExifScanner::fillBuffer(ExifScanner *this)
{
  return read(*((_DWORD *)this + 2), *((void **)this + 4), *((void *)this + 5));
}

BOOL ExifScanner::growBufferSize(ExifScanner *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 5);
  if (a2 - v2 < 1) {
    return 1;
  }
  uint64_t v4 = *((void *)this + 6);
  BOOL v5 = v4 >= a2;
  if (v4 < a2) {
    size_t v6 = v4 - v2;
  }
  else {
    size_t v6 = a2 - v2;
  }
  if (v4 > v2)
  {
    uint64_t v7 = v4 >= a2 ? a2 : *((void *)this + 6);
    *((void *)this + 5) = v7;
    _cg_jpeg_mem_term("growBufferSize", 2882, "growBufferSize %p - from %6ld to %6ld (max = %ld)\n", *((const void **)this + 4), v2, v7, v4);
    CFDataRef v8 = (char *)reallocf(*((void **)this + 4), *((void *)this + 5));
    *((void *)this + 4) = v8;
    if (v8)
    {
      if (read(*((_DWORD *)this + 2), &v8[v2], v6) != v6)
      {
        _cg_jpeg_mem_term("growBufferSize", 2890, "growBufferSize - failed to read %zu bytes\n", v6);
        return 0;
      }
      return 1;
    }
  }
  return v5;
}

unint64_t ExifScanner::read32(ExifScanner *this)
{
  unint64_t v1 = 0;
  uint64_t v2 = *((void *)this + 7);
  uint64_t v3 = *((void *)this + 5);
  if ((v2 & 0x8000000000000000) == 0 && v2 < v3 - 4)
  {
    unint64_t v1 = *((void *)this + 4) + v2;
    int v4 = *(unsigned __int8 *)v1;
    int v5 = *(unsigned __int8 *)(v1 + 1);
    int v6 = *(unsigned __int8 *)(v1 + 2);
    LODWORD(v1) = *(unsigned __int8 *)(v1 + 3);
    unsigned int v7 = (v4 << 24) | (v5 << 16) | (v6 << 8) | v1;
    LODWORD(v1) = v4 | (v5 << 8) | (v6 << 16) | (v1 << 24);
    if (*((unsigned char *)this + 24)) {
      unint64_t v1 = v1;
    }
    else {
      unint64_t v1 = v7;
    }
    uint64_t v3 = v2 + 4;
  }
  *((void *)this + 7) = v3;
  return v1;
}

void ExifScanner::addTag(ExifScanner *this, int a2, const __CFString *a3)
{
  uint64_t v6 = *((void *)this + 7);
  int v7 = ExifScanner::read16(this);
  unsigned int v8 = ExifScanner::read32(this);
  unsigned int v9 = v8;
  switch(v7)
  {
    case 2:
      if (v8 < 5)
      {
        if (v8 < 2) {
          goto LABEL_28;
        }
        uint64_t v26 = *((void *)this + 4);
        uint64_t v27 = *((void *)this + 7);
        *((void *)this + 7) = v27 + 4;
        if (!v26) {
          goto LABEL_28;
        }
        CFDataRef v13 = (const char *)(v26 + v27);
        goto LABEL_30;
      }
      unsigned int v10 = ExifScanner::read32(this);
      uint64_t v11 = *((void *)this + 8);
      if ((int64_t)(v10 + (unint64_t)v9 + v11) >= *((void *)this + 5)) {
        goto LABEL_28;
      }
      uint64_t v12 = *((void *)this + 4);
      CFDataRef v13 = (const char *)(v12 + v11 + v10);
      if ((unsigned __int16)(a2 + 28669) > 2u || v9 != 20 || !v12)
      {
        if (!v12) {
          goto LABEL_28;
        }
LABEL_30:
        size_t v14 = v9;
        goto LABEL_31;
      }
      size_t v14 = 20;
      if (!strncmp(v13, "                   ", 0x14uLL)) {
        goto LABEL_28;
      }
LABEL_31:
      if (strnlen(v13, v14) == v9 - 1)
      {
        unint64_t v28 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v13, 0x8000100u);
        if (v28) {
          goto LABEL_27;
        }
      }
LABEL_28:
      *((void *)this + 7) = v6 + 10;
      return;
    case 3:
      unsigned __int16 v15 = ExifScanner::read16(this);
      unsigned __int16 valuePtr = v15;
      if (a2 == 274)
      {
        if ((unsigned __int16)(v15 - 9) <= 0xFFF7u) {
          unsigned __int16 valuePtr = 1;
        }
      }
      else if (a2 == 513)
      {
        unsigned __int16 valuePtr = v15 + *((_WORD *)this + 32);
        *((void *)this + 9) = valuePtr;
      }
      CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      p_unsigned __int16 valuePtr = &valuePtr;
      CFNumberType v19 = kCFNumberSInt16Type;
      goto LABEL_26;
    case 4:
      unsigned int v16 = ExifScanner::read32(this);
      unsigned int v30 = v16;
      if (a2 == 513)
      {
        unsigned int v30 = v16 + *((_DWORD *)this + 16);
        *((void *)this + 9) = v30;
      }
      CFAllocatorRef v17 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      p_unsigned __int16 valuePtr = (unsigned __int16 *)&v30;
      CFNumberType v19 = kCFNumberSInt32Type;
LABEL_26:
      unint64_t v28 = CFNumberCreate(v17, v19, p_valuePtr);
      if (v28)
      {
LABEL_27:
        unsigned int v29 = v28;
        CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 2), a3, v28);
        CFRelease(v29);
      }
      goto LABEL_28;
    case 7:
      if (a2 == 37500)
      {
        unsigned int v20 = ExifScanner::read32(this);
        uint64_t v21 = *((void *)this + 8);
        if ((int64_t)(v20 + (unint64_t)v9 + v21) <= *((void *)this + 5))
        {
          PropertiesFromAppleMakerNote = (IIODictionary *)CreatePropertiesFromAppleMakerNote((unsigned __int8 *)(*((void *)this + 4) + v21 + v20), v9);
          if (PropertiesFromAppleMakerNote)
          {
            uint64_t v23 = PropertiesFromAppleMakerNote;
            unsigned int v24 = (__CFDictionary *)*((void *)this + 2);
            CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(PropertiesFromAppleMakerNote, @"{MakerApple}");
            CFDictionaryAddValue(v24, a3, ObjectForKey);
            (*(void (**)(IIODictionary *))(*(void *)v23 + 8))(v23);
          }
        }
      }
      goto LABEL_28;
    default:
      _cg_jpeg_mem_term("addTag", 3079, "ExifScanner::addTag: unknown tag type: %d\n", v7);
      goto LABEL_28;
  }
}

void ExifScanner::handleThumbnailIFD(ExifScanner *this)
{
  unsigned int v2 = ExifScanner::read16(this);
  if (*((void *)this + 7) + 12 * v2 + 4 <= *((void *)this + 5) && v2 != 0)
  {
    unsigned int v4 = v2;
    for (unsigned int i = 0; i < v4; ++i)
    {
      int v6 = ExifScanner::read16(this);
      if (v6 == 514)
      {
        int v7 = this;
        int v8 = 514;
        CFStringRef v9 = @"ThumbnailSize";
      }
      else
      {
        if (v6 != 513)
        {
          *((void *)this + 7) += 10;
          continue;
        }
        int v7 = this;
        int v8 = 513;
        CFStringRef v9 = @"ThumbnailOffset";
      }
      ExifScanner::addTag(v7, v8, v9);
    }
  }
}

void ExifScanner::handleExifIFD(ExifScanner *this)
{
  unsigned int v2 = ExifScanner::read16(this);
  if (*((void *)this + 7) + 12 * v2 + 4 <= *((void *)this + 5) && v2 != 0)
  {
    unsigned int v4 = v2;
    for (unsigned int i = 0; i < v4; ++i)
    {
      int v6 = ExifScanner::read16(this);
      if (v6 <= 37499)
      {
        if (v6 <= 36879)
        {
          if (v6 == 36867)
          {
            int v7 = this;
            int v8 = 36867;
            CFStringRef v9 = @"DateTimeOriginal";
          }
          else
          {
            if (v6 != 36868)
            {
LABEL_35:
              *((void *)this + 7) += 10;
              continue;
            }
            int v7 = this;
            int v8 = 36868;
            CFStringRef v9 = @"DateTimeDigitized";
          }
        }
        else
        {
          switch(v6)
          {
            case 36880:
              int v7 = this;
              int v8 = 36880;
              CFStringRef v9 = @"OffsetTime";
              break;
            case 36881:
              int v7 = this;
              int v8 = 36881;
              CFStringRef v9 = @"OffsetTimeOriginal";
              break;
            case 36882:
              int v7 = this;
              int v8 = 36882;
              CFStringRef v9 = @"OffsetTimeDigitized";
              break;
            default:
              goto LABEL_35;
          }
        }
      }
      else if (v6 > 37521)
      {
        switch(v6)
        {
          case 37522:
            int v7 = this;
            int v8 = 37522;
            CFStringRef v9 = @"SubsecTimeDigitized";
            break;
          case 40962:
            int v7 = this;
            int v8 = 40962;
            CFStringRef v9 = @"PixelXDimension";
            break;
          case 40963:
            int v7 = this;
            int v8 = 40963;
            CFStringRef v9 = @"PixelYDimension";
            break;
          default:
            goto LABEL_35;
        }
      }
      else
      {
        switch(v6)
        {
          case 37500:
            int v7 = this;
            int v8 = 37500;
            CFStringRef v9 = @"{MakerApple}";
            break;
          case 37520:
            int v7 = this;
            int v8 = 37520;
            CFStringRef v9 = @"SubsecTime";
            break;
          case 37521:
            int v7 = this;
            int v8 = 37521;
            CFStringRef v9 = @"SubsecTimeOriginal";
            break;
          default:
            goto LABEL_35;
        }
      }
      ExifScanner::addTag(v7, v8, v9);
    }
  }
}

void ExifScanner::handleIFD(ExifScanner *this)
{
  unsigned int v2 = ExifScanner::read16(this);
  if (*((void *)this + 7) + 12 * v2 + 4 <= *((void *)this + 5))
  {
    unsigned int v3 = v2;
    if (v2)
    {
      for (unsigned int i = 0; i < v3; ++i)
      {
        int v5 = ExifScanner::read16(this);
        if (v5 <= 273)
        {
          switch(v5)
          {
            case 256:
              int v6 = this;
              int v7 = 256;
              CFStringRef v8 = @"PixelWidth";
              goto LABEL_24;
            case 257:
              int v6 = this;
              int v7 = 257;
              CFStringRef v8 = @"PixelHeight";
              goto LABEL_24;
            case 258:
              int v6 = this;
              int v7 = 258;
              CFStringRef v8 = @"Depth";
              goto LABEL_24;
          }
        }
        else if (v5 > 305)
        {
          if (v5 == 306)
          {
            int v6 = this;
            int v7 = 306;
            CFStringRef v8 = @"DateTime";
            goto LABEL_24;
          }
          if (v5 == 34665)
          {
            ExifScanner::read16(this);
            ExifScanner::read32(this);
            unsigned int v9 = ExifScanner::read32(this);
            if (v9)
            {
              uint64_t v10 = *((void *)this + 7);
              uint64_t v11 = *((void *)this + 8) + v9;
              *((void *)this + 7) = v11;
              if (v11 < *((void *)this + 5)) {
                ExifScanner::handleExifIFD(this);
              }
              *((void *)this + 7) = v10;
            }
            continue;
          }
        }
        else
        {
          if (v5 == 274)
          {
            int v6 = this;
            int v7 = 274;
            CFStringRef v8 = @"Orientation";
            goto LABEL_24;
          }
          if (v5 == 277)
          {
            int v6 = this;
            int v7 = 277;
            CFStringRef v8 = @"SamplesPerPixel";
LABEL_24:
            ExifScanner::addTag(v6, v7, v8);
            continue;
          }
        }
        *((void *)this + 7) += 10;
      }
    }
    unsigned int v12 = ExifScanner::read32(this);
    if (v12)
    {
      uint64_t v13 = *((void *)this + 7);
      uint64_t v14 = *((void *)this + 8) + v12;
      *((void *)this + 7) = v14;
      if (v14 < *((void *)this + 5)) {
        ExifScanner::handleThumbnailIFD(this);
      }
      *((void *)this + 7) = v13;
    }
  }
}

void ExifScanner::addExifMetaData(ExifScanner *this, unsigned __int16 a2, uint64_t a3)
{
  *((void *)this + 7) = a3 + 8;
  *((void *)this + 8) = a3 + 8;
  if (a3 + 18 <= *((void *)this + 5))
  {
    *((unsigned char *)this + 24) = ExifScanner::read16(this) == 18761;
    *((void *)this + 7) += 2;
    *((void *)this + 7) = *((void *)this + 8) + ExifScanner::read32(this);
    ExifScanner::handleIFD(this);
  }
}

void ExifScanner::addThumbnailSizes(ExifScanner *this)
{
  uint64_t v1 = *((void *)this + 9);
  if (v1 <= *((void *)this + 5))
  {
    *((unsigned char *)this + 24) = 0;
    *((void *)this + 7) = v1;
    if (ExifScanner::read16(this) == 65496)
    {
      __int16 v3 = ExifScanner::read16(this);
      if (*((void *)this + 7) < *((void *)this + 5))
      {
        __int16 v4 = v3;
        while (1)
        {
          unsigned int v5 = ExifScanner::read16(this);
          if ((v4 & 0xFFFD) == 0xFFC0) {
            break;
          }
          *((void *)this + 7) = *((void *)this + 7) + v5 - 2;
          __int16 v4 = ExifScanner::read16(this);
          if (*((void *)this + 7) >= *((void *)this + 5)) {
            return;
          }
        }
        uint64_t v6 = *((void *)this + 7);
        if (v6 + 6 < *((void *)this + 5))
        {
          uint64_t v7 = *((void *)this + 4);
          *((void *)this + 7) = v6 + 1;
          __int16 v8 = *(unsigned __int8 *)(v7 + v6);
          __int16 v15 = ExifScanner::read16(this);
          __int16 v16 = ExifScanner::read16(this);
          uint64_t v9 = *((void *)this + 4);
          uint64_t v10 = *((void *)this + 7);
          *((void *)this + 7) = v10 + 1;
          __int16 valuePtr = *(unsigned __int8 *)(v9 + v10) * v8;
          CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFNumberRef v12 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt16Type, &valuePtr);
          CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 2), @"BitsPerPixel", v12);
          CFRelease(v12);
          CFNumberRef v13 = CFNumberCreate(v11, kCFNumberSInt16Type, &v16);
          CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 2), @"ThumbnailWidth", v13);
          CFRelease(v13);
          CFNumberRef v14 = CFNumberCreate(v11, kCFNumberSInt16Type, &v15);
          CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 2), @"ThumbnailHeight", v14);
          CFRelease(v14);
        }
      }
    }
  }
}

void ExifScanner::addMetaData(ExifScanner *this, __CFDictionary *a2)
{
  *((void *)this + 2) = a2;
  if (!a2 || ExifScanner::read16(this) != 65496) {
    return;
  }
  while (1)
  {
    unsigned __int16 v3 = ExifScanner::read16(this);
    unsigned int v4 = ExifScanner::read16(this);
    if (v3 != 65505)
    {
      if (v3 == 65475 || v3 == 65499) {
        return;
      }
      goto LABEL_8;
    }
    uint64_t v5 = *((void *)this + 7);
    if (!strncmp((const char *)(*((void *)this + 4) + v5), "Exif", 4uLL)) {
      break;
    }
LABEL_8:
    if (v4 <= 2)
    {
      uint64_t v7 = *((void *)this + 4);
      uint64_t v6 = *((void *)this + 7);
      while (*(unsigned __int8 *)(v7 + v6) != 255)
      {
        if (v6 >= *((void *)this + 5) - 4)
        {
          int v8 = (*(uint64_t (**)(ExifScanner *, uint64_t))(*(void *)this + 32))(this, v6 + 0x4000);
          uint64_t v6 = *((void *)this + 7);
          if (!v8) {
            break;
          }
          uint64_t v7 = *((void *)this + 4);
        }
        else
        {
          *((void *)this + 7) = ++v6;
        }
      }
    }
    else
    {
      uint64_t v6 = *((void *)this + 7) + v4 - 2;
      *((void *)this + 7) = v6;
    }
    if (!(*(unsigned int (**)(ExifScanner *, uint64_t))(*(void *)this + 32))(this, v6 + 10)
      || *((void *)this + 7) > *((void *)this + 5) - 4)
    {
      return;
    }
  }
  if ((*(unsigned int (**)(ExifScanner *, uint64_t))(*(void *)this + 32))(this, v5 + v4 - 2))
  {
    ExifScanner::addExifMetaData(this, 0, *((void *)this + 7) - 2);
    if (*((void *)this + 9))
    {
      ExifScanner::addThumbnailSizes(this);
    }
  }
}

void ExifScannerDP::ExifScannerDP(ExifScannerDP *this, CGDataProviderSequentialCallbacks *a2, void *a3, uint64_t a4)
{
  *((unsigned char *)this + 81) = 1;
  *(void *)this = &unk_1ED4DFA10;
  *((_DWORD *)this + 2) = 0;
  long long v4 = *(_OWORD *)&a2->version;
  CGDataProviderReleaseInfoCallback releaseInfo = a2->releaseInfo;
  *(_OWORD *)((char *)this + 104) = *(_OWORD *)&a2->skipForward;
  *(_OWORD *)((char *)this + 88) = v4;
  *((void *)this + 15) = releaseInfo;
  *((void *)this + 16) = a3;
  ExifScanner::setup(this, a4);
}

void sub_188794450(_Unwind_Exception *a1)
{
  ExifScanner::~ExifScanner(v1);
  _Unwind_Resume(a1);
}

void ExifScannerDP::~ExifScannerDP(ExifScannerDP *this)
{
  *(void *)this = &unk_1ED4DED18;
  if (*((unsigned char *)this + 81))
  {
    uint64_t v1 = (void *)*((void *)this + 4);
    if (v1) {
      free(v1);
    }
  }
}

{
  void *v1;
  uint64_t vars8;

  *(void *)this = &unk_1ED4DED18;
  if (*((unsigned char *)this + 81))
  {
    uint64_t v1 = (void *)*((void *)this + 4);
    if (v1) {
      free(v1);
    }
  }

  JUMPOUT(0x18C11C0E0);
}

unint64_t ExifScannerDP::fillBuffer(ExifScannerDP *this)
{
  unsigned int v2 = (void (*)(void))*((void *)this + 14);
  if (v2) {
    v2(*((void *)this + 16));
  }
  unsigned __int16 v3 = (uint64_t (*)(void, void, void))*((void *)this + 12);
  if (v3) {
    unint64_t v4 = v3(*((void *)this + 16), *((void *)this + 4), *((void *)this + 5));
  }
  else {
    unint64_t v4 = 0;
  }
  unint64_t v5 = *((void *)this + 5);
  if (v4 < v5) {
    LogError("fillBuffer", 3430, "*** ERROR: 'getBytes' returned %zu bytes (expected: %zu bytes)", v4, v5);
  }
  return v4;
}

BOOL ExifScannerDP::growBufferSize(ExifScannerDP *this, uint64_t a2)
{
  uint64_t v2 = *((void *)this + 5);
  uint64_t v3 = a2 - v2;
  if (a2 - v2 < 1) {
    return 1;
  }
  uint64_t v5 = *((void *)this + 6);
  BOOL v6 = v5 >= a2;
  if (v2 < v5)
  {
    if (v5 >= a2) {
      uint64_t v5 = a2;
    }
    *((void *)this + 5) = v5;
    _cg_jpeg_mem_term("growBufferSize", 3457, "growBufferSize - from %6ld to %6ld\n", v2, v5);
    uint64_t v7 = (char *)reallocf(*((void **)this + 4), *((void *)this + 5));
    *((void *)this + 4) = v7;
    if (v7)
    {
      if ((*((uint64_t (**)(void, char *, uint64_t))this + 12))(*((void *)this + 16), &v7[v2], v3) != v3)
      {
        _cg_jpeg_mem_term("growBufferSize", 3467, "growBufferSize - failed to read %zu bytes\n", v3);
        return 0;
      }
      return 1;
    }
  }
  return v6;
}

void ExifScannerCFData::ExifScannerCFData(ExifScannerCFData *this, CFTypeRef cf, int a3, __CFDictionary *a4)
{
  *((_DWORD *)this + 2) = 0;
  *((unsigned char *)this + 81) = 1;
  *(void *)this = &unk_1ED4E4068;
  *((void *)this + 2) = a4;
  *((void *)this + 11) = CFRetain(cf);
  *((_DWORD *)this + 24) = a3;
  CFIndex Length = CFDataGetLength((CFDataRef)cf);
  ExifScannerCFData::setupCF(this, Length);
}

void sub_18879470C(_Unwind_Exception *a1)
{
  ExifScanner::~ExifScanner(v1);
  _Unwind_Resume(a1);
}

const UInt8 *ExifScannerCFData::setupCF(ExifScannerCFData *this, uint64_t a2)
{
  *((_DWORD *)this + 2) = 0;
  *((unsigned char *)this + 24) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 6) = a2;
  *((void *)this + 7) = 0;
  *((unsigned char *)this + 81) = 0;
  *((void *)this + 5) = a2;
  unint64_t result = CFDataGetBytePtr(*((CFDataRef *)this + 11));
  BOOL v4 = 0;
  *((void *)this + 4) = result;
  if (*result == 255) {
    BOOL v4 = result[1] == 216;
  }
  *((unsigned char *)this + 80) = v4;
  return result;
}

void ExifScannerCFData::ExifScannerCFData(ExifScannerCFData *this, CFTypeRef cf)
{
  *((_DWORD *)this + 2) = 0;
  *((unsigned char *)this + 81) = 1;
  *(void *)this = &unk_1ED4E4068;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 24) = 0;
  *((void *)this + 11) = CFRetain(cf);
  CFIndex Length = CFDataGetLength((CFDataRef)cf);
  ExifScannerCFData::setupCF(this, Length);
}

void sub_188794800(_Unwind_Exception *a1)
{
  ExifScanner::~ExifScanner(v1);
  _Unwind_Resume(a1);
}

void ExifScannerCFData::~ExifScannerCFData(CFTypeRef *this)
{
  *this = &unk_1ED4E4068;
  CFRelease(this[11]);
  *this = &unk_1ED4DED18;
  if (*((unsigned char *)this + 81))
  {
    uint64_t v2 = (void *)this[4];
    if (v2) {
      free(v2);
    }
  }
}

{
  uint64_t vars8;

  ExifScannerCFData::~ExifScannerCFData(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t ExifScannerCFData::fillBuffer(ExifScannerCFData *this)
{
  return *((void *)this + 5);
}

BOOL ExifScannerCFData::growBufferSize(ExifScannerCFData *this, unint64_t a2)
{
  return *((void *)this + 5) > a2;
}

__CFDictionary *CopyMetadataFromFileAtPath(const void *a1, off_t a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CopyMetadataFromFileAtPath", 0, 0, -1, 0);
  }
  if (a1
    && (CFTypeID v4 = CFGetTypeID(a1), v4 == CFStringGetTypeID())
    && (bzero(v7, 0x400uLL), _CFStringGetFileSystemRepresentation()))
  {
    uint64_t v5 = _copyMetadataFromFileAtPath(v7, a2);
  }
  else
  {
    uint64_t v5 = 0;
  }
  kdebug_trace();
  return v5;
}

__CFDictionary *_copyMetadataFromFileAtPath(const char *a1, off_t st_size)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v4 = open(a1, 0, 0);
  int v5 = v4;
  if ((gIIODebugFlags & 0x200000000000) != 0) {
    ImageIOLog(">>> %s: opening file [%d] '%s'\n", "_copyMetadataFromFileAtPath", v4, a1);
  }
  memset(v19, 0, sizeof(v19));
  if (v5 < 0)
  {
    uint64_t Mutable = 0;
    if (v5 == -1) {
      return Mutable;
    }
    goto LABEL_19;
  }
  fcntl(v5, 48, 1);
  fcntl(v5, 62, 1);
  if (!st_size)
  {
    memset(&v18, 0, sizeof(v18));
    if (fstat(v5, &v18) < 0) {
      goto LABEL_18;
    }
    st_size = v18.st_size;
  }
  if (st_size >= 201)
  {
    read(v5, v19, 0x40uLL);
    BOOL v6 = (IIO_ReaderHandler *)lseek(v5, 0, 0);
    if (LOBYTE(v19[0]) == 255 && BYTE1(v19[0]) == 216) {
      operator new();
    }
    v7.i32[0] = DWORD1(v19[0]);
    if (vmovn_s16((int16x8_t)vmovl_u8(v7)).u32[0] == 1887007846)
    {
      ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v6);
      uint64_t v9 = IIO_ReaderHandler::readerForUTType(ReaderHandler, @"public.heic");
      if (v9)
      {
        uint64_t Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
        CFAllocatorRef v11 = malloc_type_malloc(0x19000uLL, 0x4218017EuLL);
        CFDataRef theData = 0;
        unsigned int v16 = 0;
        read(v5, v11, 0x19000uLL);
        int v12 = (*(uint64_t (**)(IIO_Reader *, void *, uint64_t, __CFDictionary *, unsigned int *, CFDataRef *))(*(void *)v9 + 224))(v9, v11, 102400, Mutable, &v16, &theData);
        if (theData) {
          int v13 = v12;
        }
        else {
          int v13 = 0;
        }
        if (v13 == 1)
        {
          memset(&v18, 0, 104);
          ExifScannerCFData::ExifScannerCFData((ExifScannerCFData *)&v18, theData, v16, Mutable);
          uint64_t v14 = v16;
          CFDataGetLength(theData);
          ExifScanner::addExifMetaData((ExifScanner *)&v18, 0, v14 - 8);
          ExifScannerCFData::~ExifScannerCFData((CFTypeRef *)&v18);
        }
        goto LABEL_19;
      }
    }
  }
LABEL_18:
  uint64_t Mutable = 0;
LABEL_19:
  if ((gIIODebugFlags & 0x200000000000) != 0) {
    ImageIOLog("<<< %s: closing file [%d] '%s'\n", "_copyMetadataFromFileAtPath", v5, a1);
  }
  close(v5);
  return Mutable;
}

void sub_188794DAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  ExifScannerCFData::~ExifScannerCFData((CFTypeRef *)va);
  _Unwind_Resume(a1);
}

__CFDictionary *CopyMetadataFromCFData(const void *a1)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CopyMetadataFromCFData", 0, 0, -1, 0);
  }
  if (!a1) {
    goto LABEL_19;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFDataGetTypeID()) {
    goto LABEL_19;
  }
  CFIndex Length = CFDataGetLength((CFDataRef)a1);
  if (Length < 201) {
    goto LABEL_19;
  }
  CFIndex v4 = Length;
  BytePtr = (UInt8 *)CFDataGetBytePtr((CFDataRef)a1);
  BOOL v6 = BytePtr;
  uint64_t v7 = *BytePtr;
  if (__PAIR64__(BytePtr[1], v7) == 0xD8000000FFLL) {
    operator new();
  }
  uint64_t v8 = BytePtr[4];
  unsigned int v9 = BytePtr[5];
  if (__PAIR64__(v9, v8) != 0x7400000066) {
    goto LABEL_18;
  }
  if (BytePtr[6] != 121 || BytePtr[7] != 112)
  {
    unsigned int v9 = 116;
LABEL_18:
    _cg_jpeg_mem_term("CopyMetadataFromCFData", 3747, "*** ERROR: CopyMetadataFromCFData cannot handle input data ([%ld bytes] %02X %02X %02X %02X %02X %02X %02X %02X... '%c%c%c%c%c%c%c%c)'\n", v4, v7, BytePtr[1], BytePtr[2], BytePtr[3], v8, v9, BytePtr[6], BytePtr[7], v7, BytePtr[1], BytePtr[2], BytePtr[3], v8, v9,
      BytePtr[6],
      BytePtr[7]);
    goto LABEL_19;
  }
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler((IIO_ReaderHandler *)BytePtr);
  CFAllocatorRef v11 = IIO_ReaderHandler::readerForUTType(ReaderHandler, @"public.heic");
  if (!v11)
  {
LABEL_19:
    uint64_t Mutable = 0;
    goto LABEL_20;
  }
  CFTypeRef v20 = 0;
  unsigned int v19 = 0;
  int v12 = (*(uint64_t (**)(IIO_Reader *, UInt8 *, CFIndex, void, unsigned int *, CFTypeRef *))(*(void *)v11 + 224))(v11, v6, v4, 0, &v19, &v20);
  uint64_t Mutable = 0;
  if (v12) {
    BOOL v14 = v20 == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (!v14)
  {
    uint64_t Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
    uint64_t v18 = 0;
    memset(v17, 0, sizeof(v17));
    ExifScannerCFData::ExifScannerCFData((ExifScannerCFData *)v17, v20, v19, Mutable);
    uint64_t v15 = v19;
    CFDataGetLength((CFDataRef)v20);
    ExifScanner::addExifMetaData((ExifScanner *)v17, 0, v15 - 8);
    ExifScannerCFData::~ExifScannerCFData((CFTypeRef *)v17);
  }
LABEL_20:
  kdebug_trace();
  return Mutable;
}

void sub_1887950FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,CFTypeRef a27)
{
}

__CFDictionary *CopyMetadataFromSequentialDataProviderCallbacks(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  IIOInitDebugFlags();
  uint64_t v6 = (unsigned __int16)gIIODebugFlags >> 14;
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions(v6, "S", "CopyMetadataFromSequentialDataProviderCallbacks", 0, 0, -1, 0);
  }
  if (a3 < 201) {
    return 0;
  }
  v7.i32[1] = 0;
  memset(v24, 0, 64);
  uint64_t v8 = *(uint64_t (**)(uint64_t))(a1 + 24);
  if (v8) {
    uint64_t v6 = v8(a2);
  }
  unsigned int v9 = *(uint64_t (**)(uint64_t, _DWORD *, uint64_t))(a1 + 8);
  if (v9) {
    uint64_t v6 = v9(a2, v24, 64);
  }
  uint64_t v10 = *(uint64_t (**)(uint64_t))(a1 + 24);
  if (v10) {
    uint64_t v6 = v10(a2);
  }
  if (LOBYTE(v24[0]) == 255 && BYTE1(v24[0]) == 216) {
    operator new();
  }
  v7.i32[0] = v24[1];
  if (vmovn_s16((int16x8_t)vmovl_u8(v7)).u32[0] != 1887007846) {
    return 0;
  }
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler((IIO_ReaderHandler *)v6);
  int v12 = IIO_ReaderHandler::readerForUTType(ReaderHandler, @"public.heic");
  if (!v12) {
    return 0;
  }
  uint64_t Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  BOOL v14 = malloc_type_malloc(0x19000uLL, 0x3C880E67uLL);
  CFDataRef theData = 0;
  unsigned int v22 = 0;
  uint64_t v15 = *(void (**)(uint64_t, void *, uint64_t))(a1 + 8);
  if (v15) {
    v15(a2, v14, 102400);
  }
  int v16 = (*(uint64_t (**)(IIO_Reader *, void *, uint64_t, __CFDictionary *, unsigned int *, CFDataRef *))(*(void *)v12 + 224))(v12, v14, 102400, Mutable, &v22, &theData);
  if (theData) {
    int v17 = v16;
  }
  else {
    int v17 = 0;
  }
  if (v17 == 1)
  {
    uint64_t v21 = 0;
    memset(v20, 0, sizeof(v20));
    ExifScannerCFData::ExifScannerCFData((ExifScannerCFData *)v20, theData, v22, Mutable);
    uint64_t v18 = v22;
    CFDataGetLength(theData);
    ExifScanner::addExifMetaData((ExifScanner *)v20, 0, v18 - 8);
    ExifScannerCFData::~ExifScannerCFData((CFTypeRef *)v20);
  }
  return Mutable;
}

void sub_188795434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  ExifScannerCFData::~ExifScannerCFData((CFTypeRef *)va);
  _Unwind_Resume(a1);
}

__CFDictionary *CGCopyBasicPropertiesOfImageAtPath(const char *a1, const __CFDictionary *a2)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGCopyBasicPropertiesOfImageAtPath", 0, a1, -1, a2);
  }
  if (a2 && (CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a2, @"size")) != 0)
  {
    CFNumberRef v5 = Value;
    switch(CFNumberGetType(Value))
    {
      case kCFNumberSInt8Type:
        unsigned __int8 valuePtr = 0;
        CFNumberGetValue(v5, kCFNumberSInt8Type, &valuePtr);
        off_t v6 = valuePtr;
        break;
      case kCFNumberSInt16Type:
        unsigned __int16 v11 = 0;
        CFNumberGetValue(v5, kCFNumberSInt16Type, &v11);
        off_t v6 = v11;
        break;
      case kCFNumberSInt32Type:
        unsigned int v10 = 0;
        CFNumberGetValue(v5, kCFNumberSInt32Type, &v10);
        off_t v6 = v10;
        break;
      case kCFNumberSInt64Type:
        off_t v9 = 0;
        CFNumberGetValue(v5, kCFNumberSInt64Type, &v9);
        off_t v6 = v9;
        break;
      default:
        goto LABEL_7;
    }
  }
  else
  {
LABEL_7:
    off_t v6 = 0;
  }
  uint8x8_t v7 = _copyMetadataFromFileAtPath(a1, v6);
  kdebug_trace();
  return v7;
}

uint64_t CGImageCreateEXIFDataFromProperties(const __CFDictionary *a1, const __CFDictionary *a2)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateEXIFDataFromProperties", 0, 0, -1, a2);
  }
  memset(v6, 0, sizeof(v6));
  IIODictionary::IIODictionary((IIODictionary *)v6, a1);
  memset(v5, 0, sizeof(v5));
  IIODictionary::IIODictionary((IIODictionary *)v5, a2);
  if (IIODictionary::containsKey((IIODictionary *)v5, @"kCGImageEXIFDataIncludeEXIFHeader")) {
    IIODictionary::getBoolForKey((IIODictionary *)v5, @"kCGImageEXIFDataIncludeEXIFHeader");
  }
  if (IIODictionary::containsKey((IIODictionary *)v5, @"kCGImageEXIFDataAddMissingTags"))
  {
    IIODictionary::getBoolForKey((IIODictionary *)v5, @"kCGImageEXIFDataAddMissingTags");
    if (!a1) {
      goto LABEL_10;
    }
LABEL_9:
    operator new();
  }
  if (a1) {
    goto LABEL_9;
  }
LABEL_10:
  LogError("CGImageCreateEXIFDataFromProperties", 3976, "*** ERROR: CGImageCreateEXIFDataFromProperties failed (properties is nil)\n");
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v5);
  IIODictionary::~IIODictionary((IIODictionary *)v6);
  return 0;
}

void sub_1887958C4()
{
}

char *std::vector<_APPx *>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  CFNumberRef v5 = *(char **)(a2 + 8);
  off_t v6 = (char *)*a1;
  uint8x8_t v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    uint8x8_t v7 = *(char **)(a2 + 8);
    do
    {
      uint64_t v9 = *((void *)v8 - 1);
      v8 -= 8;
      *((void *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  unsigned int v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    uint8x8_t v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v11 + v12;
  int v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  BOOL v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void std::vector<_APPx *>::__append(void **a1, unint64_t a2)
{
  off_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  CFNumberRef v5 = v6;
  uint8x8_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - (unsigned char *)*a1;
    unint64_t v9 = a2 + (v8 >> 3);
    if (v9 >> 61) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 3;
    uint64_t v11 = v5 - (unsigned char *)*a1;
    if (v11 >> 2 > v9) {
      unint64_t v9 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    if (v12) {
      int v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v4, v12);
    }
    else {
      int v13 = 0;
    }
    BOOL v14 = &v13[8 * v10];
    uint64_t v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    int v16 = &v14[8 * a2];
    uint64_t v18 = (char *)*a1;
    int v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        uint64_t v19 = *((void *)v17 - 1);
        v17 -= 8;
        *((void *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      int v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
    {
      operator delete(v17);
    }
  }
}

uint64_t TIFFInitZIP(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 != 8 && a2 != 32946) {
    TIFFInitZIP_cold_1();
  }
  if (_TIFFMergeFields((uint64_t)a1, zipFields, 2, a4, a5, a6, a7, a8))
  {
    BOOL v14 = _TIFFcallocExt(a1, 272, 1, v9, v10, v11, v12, v13);
    a1[137] = v14;
    if (v14)
    {
      v14[24] = 0;
      v14[25] = 0;
      *((_DWORD *)v14 + 54) = 0;
      v14[26] = 0;
      v14[32] = a1[161];
      a1[161] = ZIPVGetField;
      v14[33] = a1[160];
      a1[160] = ZIPVSetField;
      *(void *)((char *)v14 + 244) = 0xFFFFFFFFLL;
      *((_DWORD *)v14 + 63) = 0;
      a1[119] = ZIPFixupTags;
      a1[120] = ZIPSetupDecode;
      a1[121] = ZIPPreDecode;
      a1[126] = ZIPDecode;
      a1[128] = ZIPDecode;
      a1[130] = ZIPDecode;
      a1[122] = ZIPSetupEncode;
      a1[124] = ZIPPreEncode;
      a1[125] = ZIPPostEncode;
      a1[127] = ZIPEncode;
      a1[129] = ZIPEncode;
      a1[131] = ZIPEncode;
      a1[134] = ZIPCleanup;
      TIFFPredictorInit((uint64_t)a1, v15, v16, v9, v10, v11, v12, v13);
      return 1;
    }
    uint64_t v18 = "No space for ZIP state block";
  }
  else
  {
    uint64_t v18 = "Merging Deflate codec-specific tags failed";
  }
  TIFFErrorExtR((uint64_t)a1, "TIFFInitZIP", v18, v9, v10, v11, v12, v13, v19);
  return 0;
}

uint64_t ZIPVGetField(uint64_t a1, int a2, _DWORD **a3)
{
  uint64_t v3 = *(void *)(a1 + 1096);
  if (a2 == 65570)
  {
    int v4 = *(_DWORD *)(v3 + 252);
    goto LABEL_5;
  }
  if (a2 == 65557)
  {
    int v4 = *(_DWORD *)(v3 + 244);
LABEL_5:
    **a3 = v4;
    return 1;
  }
  return (*(uint64_t (**)(void))(v3 + 256))();
}

uint64_t ZIPVSetField(uint64_t a1, int a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 1096);
  if (a2 == 65570)
  {
    unsigned int v11 = *a3;
    *(_DWORD *)(v9 + 252) = *a3;
    if (v11 >= 2)
    {
      uint64_t v12 = "Invalid DeflateCodec value.";
    }
    else
    {
      if (v11 != 1) {
        return 1;
      }
      uint64_t v12 = "DeflateCodec = DEFLATE_SUBCODEC_LIBDEFLATE unsupported in this build";
    }
    TIFFErrorExtR(a1, "ZIPVSetField", v12, a4, a5, a6, a7, a8, v22);
    return 0;
  }
  if (a2 == 65557)
  {
    int v10 = *a3;
    *(_DWORD *)(v9 + 244) = *a3;
    if ((v10 - 13) <= 0xFFFFFFF1)
    {
      TIFFErrorExtR(a1, "ZIPVSetField", "Invalid ZipQuality value. Should be in [-1,%d] range", a4, a5, a6, a7, a8, 12);
      return 0;
    }
    if ((*(unsigned char *)(v9 + 248) & 2) != 0)
    {
      int v15 = v10 >= 9 ? 9 : v10;
      if (deflateParams((z_streamp)(v9 + 128), v15, 0))
      {
        uint64_t v21 = *(const char **)(v9 + 176);
        if (!v21) {
          uint64_t v21 = "";
        }
        TIFFErrorExtR(a1, "ZIPVSetField", "ZLib error: %s", v16, v17, v18, v19, v20, (char)v21);
        return 0;
      }
    }
    return 1;
  }
  uint64_t v13 = *(uint64_t (**)(void))(v9 + 264);

  return v13();
}

uint64_t ZIPFixupTags()
{
  return 1;
}

uint64_t ZIPSetupDecode(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1096);
  if (!v1) {
    ZIPSetupDecode_cold_1();
  }
  int v3 = *(_DWORD *)(v1 + 248);
  if ((v3 & 2) != 0)
  {
    deflateEnd((z_streamp)(v1 + 128));
    *(_DWORD *)(v1 + 248) = 0;
  }
  else if (v3)
  {
    goto LABEL_11;
  }
  if (!inflateInit_((z_streamp)(v1 + 128), "1.2.12", 112))
  {
    int v3 = *(_DWORD *)(v1 + 248);
LABEL_11:
    *(_DWORD *)(v1 + 248) = v3 | 1;
    return 1;
  }
  uint64_t v9 = *(const char **)(v1 + 176);
  if (!v9) {
    uint64_t v9 = "";
  }
  TIFFErrorExtR(a1, "ZIPSetupDecode", "%s", v4, v5, v6, v7, v8, (char)v9);
  return 0;
}

uint64_t ZIPPreDecode(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1096);
  if (!v1) {
    ZIPPreDecode_cold_1();
  }
  if ((*(unsigned char *)(v1 + 248) & 1) == 0) {
    (*(void (**)(uint64_t))(a1 + 960))(a1);
  }
  *(void *)(v1 + 128) = *(void *)(a1 + 1120);
  unint64_t v3 = *(void *)(a1 + 1160);
  if (v3 >= 0xFFFFFFFF) {
    LODWORD(v3) = -1;
  }
  *(_DWORD *)(v1 + 136) = v3;
  if (inflateReset((z_streamp)(v1 + 128))) {
    return 0;
  }
  *(_DWORD *)(v1 + 240) = 0;
  return 1;
}

uint64_t ZIPDecode(uint64_t a1, void *a2, size_t a3)
{
  uint64_t v3 = *(void *)(a1 + 1096);
  if (!v3) {
    ZIPDecode_cold_1();
  }
  if (*(_DWORD *)(v3 + 248) != 1) {
    ZIPDecode_cold_2();
  }
  uint64_t v4 = a3;
  if (*(_DWORD *)(v3 + 240))
  {
    bzero(a2, a3);
    TIFFErrorExtR(a1, "ZIPDecode", "ZIPDecode: Scanline %u cannot be read due to previous error", v6, v7, v8, v9, v10, *(_DWORD *)(a1 + 876));
    return 0;
  }
  *(void *)(v3 + 128) = *(void *)(a1 + 1152);
  *(void *)(v3 + 152) = a2;
  unint64_t v12 = *(void *)(a1 + 1160);
  while (1)
  {
    int v13 = HIDWORD(v12) ? -1 : v12;
    int v14 = (unint64_t)v4 >= 0xFFFFFFFF ? -1 : v4;
    *(_DWORD *)(v3 + 136) = v13;
    *(_DWORD *)(v3 + 160) = v14;
    int v15 = inflate((z_streamp)(v3 + 128), 1);
    unint64_t v12 = *(void *)(a1 + 1160) - (v13 - *(_DWORD *)(v3 + 136));
    *(void *)(a1 + 1160) = v12;
    size_t v21 = *(unsigned int *)(v3 + 160);
    v4 -= (v14 - v21);
    if (v15) {
      break;
    }
    if (v4 <= 0) {
      goto LABEL_18;
    }
  }
  if (v15 != 1)
  {
    if (v15 == -3)
    {
      bzero(*(void **)(v3 + 152), v21);
      TIFFErrorExtR(a1, "ZIPDecode", "Decoding error at scanline %lu, %s", v22, v23, v24, v25, v26, *(_DWORD *)(a1 + 876));
    }
    else
    {
      bzero(*(void **)(v3 + 152), v21);
      size_t v32 = *(const char **)(v3 + 176);
      if (!v32) {
        size_t v32 = "";
      }
      TIFFErrorExtR(a1, "ZIPDecode", "ZLib error: %s", v27, v28, v29, v30, v31, (char)v32);
    }
    goto LABEL_23;
  }
LABEL_18:
  if (v4)
  {
    TIFFErrorExtR(a1, "ZIPDecode", "Not enough data at scanline %lu (short %llu bytes)", v16, v17, v18, v19, v20, *(_DWORD *)(a1 + 876));
    bzero(*(void **)(v3 + 152), *(unsigned int *)(v3 + 160));
LABEL_23:
    uint64_t result = 0;
    *(_DWORD *)(v3 + 240) = 1;
    return result;
  }
  *(void *)(a1 + 1152) = *(void *)(v3 + 128);
  return 1;
}

uint64_t ZIPSetupEncode(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1096);
  if (!v1) {
    ZIPSetupEncode_cold_1();
  }
  if (*(unsigned char *)(v1 + 248))
  {
    inflateEnd((z_streamp)(v1 + 128));
    *(_DWORD *)(v1 + 248) = 0;
  }
  if (*(int *)(v1 + 244) >= 9) {
    int v3 = 9;
  }
  else {
    int v3 = *(_DWORD *)(v1 + 244);
  }
  if (deflateInit_((z_streamp)(v1 + 128), v3, "1.2.12", 112))
  {
    uint64_t v9 = *(const char **)(v1 + 176);
    if (!v9) {
      uint64_t v9 = "";
    }
    TIFFErrorExtR(a1, "ZIPSetupEncode", "%s", v4, v5, v6, v7, v8, (char)v9);
    return 0;
  }
  else
  {
    *(_DWORD *)(v1 + 248) |= 2u;
    return 1;
  }
}

BOOL ZIPPreEncode(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1096);
  if (!v1) {
    ZIPPreEncode_cold_1();
  }
  if (*(_DWORD *)(v1 + 248) != 2) {
    (*(void (**)(uint64_t))(a1 + 976))(a1);
  }
  *(void *)(v1 + 152) = *(void *)(a1 + 1120);
  unint64_t v3 = *(void *)(a1 + 1128);
  if (HIDWORD(v3)) {
    LODWORD(v3) = -1;
  }
  *(_DWORD *)(v1 + 160) = v3;
  return deflateReset((z_streamp)(v1 + 128)) == 0;
}

uint64_t ZIPPostEncode(void *a1)
{
  uint64_t v2 = a1[137];
  *(_DWORD *)(v2 + 136) = 0;
  while (1)
  {
    unsigned int v3 = deflate((z_streamp)(v2 + 128), 4);
    if (v3 > 1) {
      break;
    }
    unsigned int v11 = v3;
    uint64_t v12 = a1[141] - *(unsigned int *)(v2 + 160);
    if (v12)
    {
      a1[145] = v12;
      uint64_t result = TIFFFlushData1((uint64_t)a1, v4, v5, v6, v7, v8, v9, v10);
      if (!result) {
        return result;
      }
      *(void *)(v2 + 152) = a1[140];
      unint64_t v14 = a1[141];
      if (HIDWORD(v14)) {
        LODWORD(v14) = -1;
      }
      *(_DWORD *)(v2 + 160) = v14;
    }
    if (v11 == 1) {
      return 1;
    }
  }
  int v15 = *(const char **)(v2 + 176);
  if (!v15) {
    int v15 = "";
  }
  TIFFErrorExtR((uint64_t)a1, "ZIPPostEncode", "ZLib error: %s", v6, v7, v8, v9, v10, (char)v15);
  return 0;
}

uint64_t ZIPEncode(void *a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = a1[137];
  if (!v3) {
    ZIPEncode_cold_1();
  }
  if (*(_DWORD *)(v3 + 248) != 2) {
    ZIPEncode_cold_2();
  }
  *(void *)(v3 + 128) = a2;
  while (1)
  {
    int v6 = HIDWORD(a3) ? -1 : a3;
    *(_DWORD *)(v3 + 136) = v6;
    if (deflate((z_streamp)(v3 + 128), 0)) {
      break;
    }
    if (!*(_DWORD *)(v3 + 160))
    {
      a1[145] = a1[141];
      uint64_t result = TIFFFlushData1((uint64_t)a1, v7, v8, v9, v10, v11, v12, v13);
      if (!result) {
        return result;
      }
      *(void *)(v3 + 152) = a1[140];
      unint64_t v15 = a1[141];
      if (HIDWORD(v15)) {
        LODWORD(v15) = -1;
      }
      *(_DWORD *)(v3 + 160) = v15;
    }
    uint64_t v16 = (v6 - *(_DWORD *)(v3 + 136));
    BOOL v17 = (uint64_t)a3 <= v16;
    a3 -= v16;
    if (v17) {
      return 1;
    }
  }
  uint64_t v18 = *(const char **)(v3 + 176);
  if (!v18) {
    uint64_t v18 = "";
  }
  TIFFErrorExtR((uint64_t)a1, "ZIPEncode", "Encoder error: %s", v9, v10, v11, v12, v13, (char)v18);
  return 0;
}

uint64_t ZIPCleanup(void *a1)
{
  uint64_t v1 = a1[137];
  if (!v1) {
    ZIPCleanup_cold_1();
  }
  TIFFPredictorCleanup(a1);
  uint64_t v3 = *(void *)(v1 + 264);
  a1[161] = *(void *)(v1 + 256);
  a1[160] = v3;
  int v4 = *(_DWORD *)(v1 + 248);
  if ((v4 & 2) != 0)
  {
    deflateEnd((z_streamp)(v1 + 128));
  }
  else
  {
    if ((v4 & 1) == 0) {
      goto LABEL_7;
    }
    inflateEnd((z_streamp)(v1 + 128));
  }
  *(_DWORD *)(v1 + 248) = 0;
LABEL_7:
  _TIFFfreeExt((uint64_t)a1, (char *)v1);
  a1[137] = 0;

  return _TIFFSetDefaultCompressionState((uint64_t)a1);
}

void ImageIOSetLoggingProc(void (*a1)(int a1, const char *a2, const char *a3, int a4, const char *a5, va_list a6))
{
  IIOInitDebugFlags();
  if (a1) {
    uint64_t v2 = a1;
  }
  else {
    uint64_t v2 = ImageIOLogger;
  }
  gImageIOLogProc = (uint64_t (*)(int, const char *, const char *, int, const char *, char *))v2;
}

const char *LogModuleWithArguments(const char *result, const char *a2, char *a3)
{
  if (gImageIOLogProc) {
    return (const char *)gImageIOLogProc(0, result, 0, 0, a2, a3);
  }
  return result;
}

const char *LogFault(const char *result, int a2, const char *a3, ...)
{
  va_start(va, a3);
  if (gImageIOLogProc) {
    return (const char *)gImageIOLogProc(17, 0, result, a2, a3, va);
  }
  return result;
}

void IIOLogAndCreateError(__CFError **a1, const __CFString *a2, CFIndex a3, const char *a4, int a5, const char *a6, ...)
{
  va_start(va, a6);
  va_copy(v15, va);
  if (gImageIOLogProc) {
    gImageIOLogProc(16, "*** ERROR: ", a4, a5, a6, v15);
  }
  if (a1)
  {
    CFAllocatorRef v10 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    IIOString::IIOString((IIOString *)&v12, a6);
    CFStringRef v11 = CFStringCreateWithFormatAndArguments(v10, 0, v14, v15);
    IIOString::~IIOString((IIOString *)&v12);
    uint64_t v12 = 0;
    CFDictionaryRef userInfo = 0;
    CFStringRef v14 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v12);
    IIODictionary::setObjectForKey((IIODictionary *)&v12, v11, (const __CFString *)*MEMORY[0x1E4F1D140]);
    *a1 = CFErrorCreate(v10, a2, a3, userInfo);
    IIODictionary::~IIODictionary((IIODictionary *)&v12);
  }
}

void sub_188796658(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

const char *ImageIOLog(const char *result, ...)
{
  va_start(va, result);
  if (gImageIOLogProc) {
    return (const char *)gImageIOLogProc(0, 0, 0, 0, result, va);
  }
  return result;
}

void IIOWriteStream::IIOWriteStream(IIOWriteStream *this, unsigned __int8 *a2, uint64_t a3, char a4)
{
  *(void *)this = &unk_1ED4E1488;
  *((void *)this + 1) = a2;
  *((unsigned char *)this + 32) = a4;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
}

void IIOWriteStream::~IIOWriteStream(IIOWriteStream *this)
{
}

uint64_t IIOWriteStream::write16(uint64_t this, __int16 a2)
{
  __int16 v2 = __rev16(a2);
  if (*(unsigned char *)(this + 32)) {
    __int16 v3 = a2;
  }
  else {
    __int16 v3 = v2;
  }
  *(_WORD *)(*(void *)(this + 8) + *(void *)(this + 24)) = v3;
  *(void *)(this + 24) += 2;
  return this;
}

uint64_t IIOWriteStream::write32(uint64_t this, unsigned int a2)
{
  unsigned int v2 = bswap32(a2);
  if (*(unsigned char *)(this + 32)) {
    unsigned int v3 = a2;
  }
  else {
    unsigned int v3 = v2;
  }
  *(_DWORD *)(*(void *)(this + 8) + *(void *)(this + 24)) = v3;
  *(void *)(this + 24) += 4;
  return this;
}

uint64_t IIOWriteStream::write64(uint64_t this, unint64_t a2)
{
  unint64_t v2 = bswap64(a2);
  if (*(unsigned char *)(this + 32)) {
    unint64_t v3 = a2;
  }
  else {
    unint64_t v3 = v2;
  }
  *(void *)(*(void *)(this + 8) + *(void *)(this + 24)) = v3;
  *(void *)(this + 24) += 8;
  return this;
}

void *IIOWriteStream::writeBytes(IIOWriteStream *this, unsigned __int8 *a2, size_t a3)
{
  uint64_t result = memcpy((void *)(*((void *)this + 1) + *((void *)this + 3)), a2, a3);
  *((void *)this + 3) += a3;
  return result;
}

uint64_t CGImageMetadataPropertyGetTypeID()
{
  if (CGImageMetadataPropertyGetTypeID::once != -1) {
    dispatch_once(&CGImageMetadataPropertyGetTypeID::once, &__block_literal_global_29);
  }
  return CGImageMetadataPropertyGetTypeID::id;
}

double _CGImageMetadataPropertyFinalize(CFTypeRef cf)
{
  unsigned int v2 = (gIIODebugFlags >> 12) & 3;
  if (v2) {
    ImageIODebugOptions(v2, "A", "_CGImageMetadataPropertyFinalize", cf, 0, -1, 0);
  }
  unint64_t v3 = (const void *)*((void *)cf + 2);
  if (v3) {
    CFRelease(v3);
  }
  *((void *)cf + 2) = 0;
  int v4 = (const void *)*((void *)cf + 3);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)cf + 3) = 0;
  uint64_t v5 = (const void *)*((void *)cf + 4);
  if (v5) {
    CFRelease(v5);
  }
  *((void *)cf + 4) = 0;
  int v6 = (const void *)*((void *)cf + 5);
  if (v6) {
    CFRelease(v6);
  }
  *((void *)cf + 6) = 0;
  double result = 0.0;
  *((_OWORD *)cf + 1) = 0u;
  *((_OWORD *)cf + 2) = 0u;
  return result;
}

CFStringRef _CGImageMetadataPropertyCopyDebugDesc(CFTypeRef cf)
{
  if (*((void *)cf + 3) && *((void *)cf + 4) && *((void *)cf + 5))
  {
    CFAllocatorRef v2 = CFGetAllocator(cf);
    return CFStringCreateWithFormat(v2, 0, @"<CGImageMetadataProperty %p> (schema = \"%@\", name = \"%@\", value = %@)", cf, *((void *)cf + 3), *((void *)cf + 4), *((void *)cf + 5));
  }
  else
  {
    CFAllocatorRef v4 = CFGetAllocator(cf);
    return CFStringCreateCopy(v4, @"<CGImageMetadataProperty> (invalid)");
  }
}

uint64_t __CGImageMetadataPropertyGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CGImageMetadataPropertyGetTypeID::id = result;
  return result;
}

uint64_t CGImageMetadataPropertyCreate(const __CFString *a1, const void *a2, const void *a3)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImageMetadataPropertyCreate", 0, 0, -1, 0);
  }
  uint64_t Instance = 0;
  if (a1 && a3)
  {
    if (CGImageMetadataPropertyGetTypeID::once != -1) {
      dispatch_once(&CGImageMetadataPropertyGetTypeID::once, &__block_literal_global_29);
    }
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      *(void *)(Instance + 16) = CFRetain(a1);
      if (a2) {
        uint64_t v7 = (void *)CFRetain(a2);
      }
      else {
        uint64_t v7 = CGImageMetadataDefaultPrefixForSchema(a1);
      }
      *(void *)(Instance + 24) = v7;
      *(void *)(Instance + 32) = CFRetain(a3);
      *(void *)(Instance + 40) = 0;
      *(_DWORD *)(Instance + 48) = 0;
    }
  }
  return Instance;
}

uint64_t CGImageMetadataPropertyGetSchema(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t CGImageMetadataPropertyGetSuggestedPrefix(uint64_t result)
{
  if (result) {
    return *(void *)(result + 24);
  }
  return result;
}

uint64_t CGImageMetadataPropertyGetPropertyName(uint64_t a1)
{
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImageMetadataPropertyGetPropertyName", 0, 0, -1, 0);
  }
  if (a1) {
    return *(void *)(a1 + 32);
  }
  else {
    return 0;
  }
}

void CGImageMetadataPropertySetValue(uint64_t a1, const void *a2)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImageMetadataPropertySetValue", 0, 0, -1, 0);
  }
  if (a1)
  {
    CFAllocatorRef v4 = *(const void **)(a1 + 40);
    if (v4 != a2)
    {
      if (v4) {
        CFRelease(v4);
      }
      *(void *)(a1 + 40) = a2;
      if (a2)
      {
        CFRetain(a2);
      }
    }
  }
}

uint64_t CGImageMetadataPropertyGetValue(uint64_t a1)
{
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImageMetadataPropertyGetValue", 0, 0, -1, 0);
  }
  if (a1) {
    return *(void *)(a1 + 40);
  }
  else {
    return 0;
  }
}

uint64_t png_do_write_transformations(uint64_t result, int *a2, uint8x8_t a3)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  if (!result) {
    return result;
  }
  uint64_t v4 = result;
  int v5 = *(_DWORD *)(result + 88);
  if ((v5 & 0x100000) != 0)
  {
    int v6 = *(uint64_t (**)(uint64_t, int *, uint64_t))(result + 56);
    if (v6)
    {
      uint64_t result = v6(result, a2, *(void *)(result + 328) + 1);
      int v5 = *(_DWORD *)(v4 + 88);
    }
  }
  if ((v5 & 0x8000) != 0)
  {
    uint64_t result = png_do_strip_channel((uint64_t)a2, (unsigned char *)(*(void *)(v4 + 328) + 1), ((*(_DWORD *)(v4 + 80) >> 7) & 1) == 0);
    int v5 = *(_DWORD *)(v4 + 88);
    if ((v5 & 0x10000) == 0)
    {
LABEL_7:
      if ((v5 & 4) == 0) {
        goto LABEL_47;
      }
LABEL_11:
      if (*((unsigned char *)a2 + 17) == 8 && *((unsigned char *)a2 + 18) == 1)
      {
        uint64_t v7 = (unsigned char *)(*(void *)(v4 + 328) + 1);
        int v8 = *(unsigned __int8 *)(v4 + 392);
        switch(v8)
        {
          case 4:
            int v23 = *a2;
            if (*a2)
            {
              uint64_t v24 = (unsigned char *)(*(void *)(v4 + 328) + 1);
              while (v23 != 1)
              {
                *v7++ = v24[1] & 0xF | (16 * *v24);
                v24 += 2;
                v23 -= 2;
                if (!v23) {
                  goto LABEL_44;
                }
              }
              LOBYTE(v14) = 16 * *v24;
LABEL_43:
              *uint64_t v7 = v14;
            }
            break;
          case 2:
            if (*a2)
            {
              int v17 = 0;
              int v18 = -*a2;
              uint64_t v19 = *(void *)(v4 + 328) + 1;
LABEL_29:
              uint64_t v20 = 0;
              int v14 = 0;
              int v21 = 6;
              do
              {
                v14 |= (*(unsigned char *)(v19 + v20) & 3) << v21;
                if (!v21)
                {
                  *v7++ = v14;
                  v19 += v20 + 1;
                  int v22 = v17 + v20;
                  v17 += v20 + 1;
                  if (v22 + v18 != -1) {
                    goto LABEL_29;
                  }
                  goto LABEL_44;
                }
                v21 -= 2;
                ++v20;
              }
              while (v18 + v17 + v20);
              if (v21 != 6) {
                goto LABEL_43;
              }
            }
            break;
          case 1:
            int v9 = *a2;
            if (*a2)
            {
              int v10 = 0;
              int v11 = *a2;
              uint64_t v12 = (unsigned char *)(*(void *)(v4 + 328) + 1);
              do
              {
                uint64_t v13 = 0;
                LOBYTE(v14) = 0;
                unsigned int v15 = 128;
                while (1)
                {
                  char v16 = v7[v13] ? v15 : 0;
                  LOBYTE(v14) = v16 | v14;
                  if (v13 == 7) {
                    break;
                  }
                  v15 >>= 1;
                  if (v11 == ++v13)
                  {
                    uint64_t v7 = v12;
                    goto LABEL_43;
                  }
                }
                *v12++ = v14;
                v10 += 8;
                v7 += v13 + 1;
                v11 -= 8;
              }
              while (v10 != v9);
            }
            break;
        }
LABEL_44:
        *((unsigned char *)a2 + 17) = v8;
        unsigned __int8 v25 = *((unsigned char *)a2 + 18) * v8;
        *((unsigned char *)a2 + 19) = v25;
        BOOL v26 = v25 >= 8u;
        unint64_t v27 = (*a2 * (unint64_t)v25 + 7) >> 3;
        unint64_t v28 = *a2 * (unint64_t)(v25 >> 3);
        if (!v26) {
          unint64_t v28 = v27;
        }
        *((void *)a2 + 1) = v28;
        int v5 = *(_DWORD *)(v4 + 88);
      }
      goto LABEL_47;
    }
  }
  else if ((v5 & 0x10000) == 0)
  {
    goto LABEL_7;
  }
  uint64_t result = png_do_packswap((uint64_t)a2, (unsigned char *)(*(void *)(v4 + 328) + 1));
  int v5 = *(_DWORD *)(v4 + 88);
  if ((v5 & 4) != 0) {
    goto LABEL_11;
  }
LABEL_47:
  if ((v5 & 0x10) != 0)
  {
    uint64_t result = png_do_swap((uint64_t)a2, (char *)(*(void *)(v4 + 328) + 1));
    int v5 = *(_DWORD *)(v4 + 88);
  }
  if ((v5 & 8) != 0)
  {
    int v29 = *((unsigned __int8 *)a2 + 16);
    if (v29 != 3)
    {
      uint64_t v30 = *(void *)(v4 + 328);
      int v90 = 0;
      uint64_t v89 = 0;
      int v87 = 0;
      unint64_t v86 = 0;
      unsigned int v31 = *((unsigned __int8 *)a2 + 17);
      if ((v29 & 2) != 0)
      {
        int v32 = *(unsigned __int8 *)(v4 + 509);
        int v34 = *(unsigned __int8 *)(v4 + 510);
        int v35 = *(unsigned __int8 *)(v4 + 511);
        LODWORD(v89) = v31 - v34;
        HIDWORD(v89) = v31 - v35;
        unint64_t v86 = __PAIR64__(v35, v34);
        unsigned int v33 = 3;
      }
      else
      {
        int v32 = *(unsigned __int8 *)(v4 + 512);
        unsigned int v33 = 1;
      }
      double v36 = (unsigned __int8 *)(v30 + 1);
      int v88 = v31 - v32;
      int v85 = v32;
      if ((v29 & 4) != 0)
      {
        int v37 = *(unsigned __int8 *)(v4 + 513);
        *(&v88 + v33) = v31 - v37;
        *(&v85 + v33++) = v37;
      }
      if (v31 > 7)
      {
        int v49 = *a2 * v33;
        if (v31 == 8)
        {
          if (v49)
          {
            for (unsigned int i = 0; i != v49; ++i)
            {
              unsigned __int8 v51 = 0;
              int v52 = *(&v88 + i % v33);
              int v53 = *(&v85 + i % v33);
              if (v52 > -v53)
              {
                unsigned __int8 v51 = 0;
                unsigned int v54 = *v36;
                LODWORD(result) = -v52;
                do
                {
                  unsigned int v55 = v54 >> result;
                  int v56 = v52 - v53;
                  uint64_t result = (result + v53);
                  BOOL v57 = v52 <= 0;
                  if (v52 <= 0) {
                    LOBYTE(v58) = v55;
                  }
                  else {
                    int v58 = v54 << v52;
                  }
                  v51 |= v58;
                  int v52 = v56;
                }
                while (!v57);
              }
              *v36++ = v51;
            }
          }
        }
        else if (v49)
        {
          for (unsigned int j = 0; j != v49; ++j)
          {
            unsigned int v60 = 0;
            int v61 = *(&v88 + j % v33);
            int v62 = *(&v85 + j % v33);
            if (v61 > -v62)
            {
              unsigned int v60 = 0;
              unsigned int v63 = __rev16(*(unsigned __int16 *)v36);
              LODWORD(result) = -v61;
              do
              {
                unsigned int v64 = v63 >> result;
                int v65 = v61 - v62;
                uint64_t result = (result + v62);
                BOOL v66 = v61 <= 0;
                if (v61 <= 0) {
                  unsigned int v67 = v64;
                }
                else {
                  unsigned int v67 = v63 << v61;
                }
                v60 |= v67;
                int v61 = v65;
              }
              while (!v66);
            }
            *(_WORD *)double v36 = bswap32(v60) >> 16;
            v36 += 2;
          }
        }
      }
      else
      {
        uint64_t v38 = *((void *)a2 + 1);
        int v39 = *(unsigned __int8 *)(v4 + 512);
        if (v39 == 3 && v31 == 4) {
          int v41 = 17;
        }
        else {
          int v41 = 255;
        }
        if (v39 == 1 && v31 == 2) {
          int v43 = 85;
        }
        else {
          int v43 = v41;
        }
        if (v38)
        {
          for (uint64_t k = 0; k != v38; ++k)
          {
            unsigned __int8 v45 = 0;
            if (v31)
            {
              unsigned int v46 = *v36;
              LODWORD(result) = v31;
              char v47 = v32 - v31;
              do
              {
                if ((int)result - v32 <= 0) {
                  int v48 = (v46 >> v47) & v43;
                }
                else {
                  int v48 = v46 << (result - v32);
                }
                v45 |= v48;
                v47 += v32;
                uint64_t result = (result - v32);
              }
              while ((int)result > 0);
            }
            *v36++ = v45;
          }
        }
      }
      int v5 = *(_DWORD *)(v4 + 88);
    }
  }
  if ((v5 & 0x20000) != 0)
  {
    int32x4_t v68 = (int8x8_t *)(*(void *)(v4 + 328) + 1);
    int v69 = *((unsigned __int8 *)a2 + 16);
    if (v69 == 4)
    {
      int v72 = *a2;
      if (*((unsigned char *)a2 + 17) == 8)
      {
        for (; v72; --v72)
        {
          __int8 v73 = v68->i8[0];
          v68->i8[0] = v68->i8[1];
          v68->i8[1] = v73;
          int32x4_t v68 = (int8x8_t *)((char *)v68 + 2);
        }
      }
      else
      {
        for (; v72; --v72)
        {
          a3.i32[0] = v68->i32[0];
          int16x8_t v74 = (int16x8_t)vmovl_u8(a3);
          *(int8x8_t *)v74.i8 = vext_s8(*(int8x8_t *)v74.i8, *(int8x8_t *)v74.i8, 4uLL);
          a3 = (uint8x8_t)vmovn_s16(v74);
          v68->i32[0] = a3.i32[0];
          int32x4_t v68 = (int8x8_t *)((char *)v68 + 4);
        }
      }
    }
    else if (v69 == 6)
    {
      int v70 = *a2;
      if (*((unsigned char *)a2 + 17) == 8)
      {
        for (; v70; --v70)
        {
          a3.i32[0] = v68->i32[0];
          int16x8_t v71 = (int16x8_t)vmovl_u8(a3);
          *(int8x8_t *)v71.i8 = vext_s8(*(int8x8_t *)v71.i8, *(int8x8_t *)v71.i8, 2uLL);
          a3 = (uint8x8_t)vmovn_s16(v71);
          v68->i32[0] = a3.i32[0];
          int32x4_t v68 = (int8x8_t *)((char *)v68 + 4);
        }
      }
      else
      {
        for (; v70; --v70)
        {
          *int32x4_t v68 = vext_s8(*v68, *v68, 2uLL);
          ++v68;
        }
      }
    }
  }
  if ((*(unsigned char *)(v4 + 90) & 8) != 0)
  {
    int v75 = *(unsigned char **)(v4 + 328);
    int v76 = *((unsigned __int8 *)a2 + 16);
    if (v76 == 4)
    {
      int v79 = *a2;
      if (*((unsigned char *)a2 + 17) == 8)
      {
        if (v79)
        {
          v80 = v75 + 2;
          do
          {
            unsigned char *v80 = ~*v80;
            v80 += 2;
            --v79;
          }
          while (v79);
        }
      }
      else if (v79)
      {
        int v82 = v75 + 4;
        do
        {
          *(v82 - 1) = ~*(v82 - 1);
          *int v82 = ~*v82;
          v82 += 4;
          --v79;
        }
        while (v79);
      }
    }
    else if (v76 == 6)
    {
      int v77 = *a2;
      if (*((unsigned char *)a2 + 17) == 8)
      {
        if (v77)
        {
          unsigned __int8 v78 = v75 + 4;
          do
          {
            *unsigned __int8 v78 = ~*v78;
            v78 += 4;
            --v77;
          }
          while (v77);
        }
      }
      else if (v77)
      {
        uint64_t v81 = v75 + 8;
        do
        {
          *(v81 - 1) = ~*(v81 - 1);
          *uint64_t v81 = ~*v81;
          v81 += 8;
          --v77;
        }
        while (v77);
      }
    }
  }
  int v83 = *(_DWORD *)(v4 + 88);
  if (v83)
  {
    uint64_t result = (uint64_t)png_do_bgr(a2, (__int16 *)(*(void *)(v4 + 328) + 1));
    int v83 = *(_DWORD *)(v4 + 88);
  }
  if ((v83 & 0x20) != 0)
  {
    v84 = (unsigned char *)(*(void *)(v4 + 328) + 1);
    return png_do_invert((uint64_t)a2, v84);
  }
  return result;
}

void BMPWritePlugin::BMPWritePlugin(BMPWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 1112363040);
  void *v3 = &unk_1ED4E1070;
}

void BMPWritePlugin::~BMPWritePlugin(BMPWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t BMPWritePlugin::writePrefix(BMPWritePlugin *this, CGImageRef image, IIODictionary *a3, int a4)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  size_t BytesPerRow = CGImageGetBytesPerRow(image);
  size_t Width = CGImageGetWidth(image);
  int Height = CGImageGetHeight(image);
  size_t BitsPerPixel = CGImageGetBitsPerPixel(image);
  size_t BitsPerComponent = CGImageGetBitsPerComponent(image);
  ColorSpace = CGImageGetColorSpace(image);
  int Type = CGColorSpaceGetType();
  CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
  bzero(v51, 0x400uLL);
  __int16 v49 = 0;
  uint64_t __ptr = 19778;
  int v47 = 0;
  memset(v46, 0, sizeof(v46));
  long long v45 = 0u;
  uint64_t v15 = 32;
  if (BitsPerComponent == 8) {
    uint64_t v16 = BitsPerPixel;
  }
  else {
    uint64_t v16 = 32;
  }
  if (!a4) {
    uint64_t v15 = 24;
  }
  if (v16 == 32) {
    unint64_t v17 = v15;
  }
  else {
    unint64_t v17 = v16;
  }
  if (v17 == 24)
  {
    int v19 = 0;
    BOOL v18 = 0;
LABEL_20:
    size_t v20 = 40;
    goto LABEL_21;
  }
  if (v17 != 32)
  {
    int v19 = 0;
    BOOL v18 = 0;
    if (Model != kCGColorSpaceModelIndexed) {
      unint64_t v17 = v15;
    }
    goto LABEL_20;
  }
  BOOL v18 = *((unsigned char *)this + 48) == 0;
  if (*((unsigned char *)this + 48)) {
    int v19 = 0;
  }
  else {
    int v19 = 3;
  }
  if (*((unsigned char *)this + 48)) {
    size_t v20 = 40;
  }
  else {
    size_t v20 = 124;
  }
LABEL_21:
  uint64_t result = 0;
  if (BytesPerRow && ColorSpace)
  {
    BOOL v35 = v18;
    if (Type == 7)
    {
      BaseColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
      CGColorSpaceGetType();
      CGColorSpaceGetModel(BaseColorSpace);
      unsigned __int8 v25 = CGColorSpaceGetBaseColorSpace(BaseColorSpace);
      if (CGColorSpaceGetNumberOfComponents(v25) != 3) {
        return 0;
      }
      size_t ColorTableCount = CGColorSpaceGetColorTableCount(BaseColorSpace);
      if (ColorTableCount > 0x100) {
        return 0;
      }
      size_t v22 = ColorTableCount;
      uint64_t result = (uint64_t)malloc_type_malloc(3 * ColorTableCount, 0x989A6EB9uLL);
      if (!result) {
        return result;
      }
      unint64_t v27 = (unsigned char *)result;
      CGColorSpaceGetColorTable(BaseColorSpace, (uint8_t *)result);
      if (v22)
      {
        unsigned int v28 = 0;
        unsigned int v29 = 2;
        int v30 = 1;
        do
        {
          v51[v30 + 1] = v27[v29 - 2];
          v51[v30] = v27[v29 - 1];
          v51[v30 - 1] = v27[v29];
          ++v28;
          v29 += 3;
          v30 += 4;
        }
        while (v28 < v22);
      }
      free(v27);
      size_t v23 = (4 * v22);
    }
    else
    {
      LODWORD(v22) = 0;
      size_t v23 = 0;
    }
    unint64_t v31 = ((v17 * Width + 31) >> 3) & 0x1FFFFFFFFFFFFFFCLL;
    *((void *)this + 5) = v31;
    *(_DWORD *)((char *)&__ptr + 2) = v20 + v23 + 14 + v31 * Height;
    int v50 = v20 + v23 + 14;
    if (IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), &__ptr, 0xEuLL) == 14)
    {
      v37[0] = v20;
      v37[1] = Width;
      v37[2] = -Height;
      __int16 v38 = 1;
      __int16 v39 = v17;
      int v40 = v19;
      int v41 = Height * Width * (v17 >> 3);
      uint32x2_t v42 = 0;
      int v43 = v22;
      int v44 = v22;
      unsigned int v32 = IIODictionary::containsKey(a3, @"DPIWidth");
      unsigned int v33 = IIODictionary::containsKey(a3, @"DPIHeight");
      if (v32 && v33)
      {
        unsigned int v34 = COERCE_UNSIGNED_INT64(IIODictionary::getFloatForKey(a3, @"DPIWidth"));
        uint32x2_t v42 = vcvt_u32_f32(vadd_f32(vdiv_f32((float32x2_t)__PAIR64__(COERCE_UNSIGNED_INT64(IIODictionary::getFloatForKey(a3, @"DPIHeight")), v34), (float32x2_t)vdup_n_s32(0x3CD013A9u)), (float32x2_t)0x3F0000003F000000));
      }
      if (v35)
      {
        long long v45 = xmmword_1889AB370;
        LODWORD(v46[0]) = 1934772034;
        memset((char *)v46 + 4, 0, 48);
      }
      if (IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), v37, v20) == v20
        && (Type != 7
         || !v22
         || IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), v51, v23) == v23))
      {
        return 1;
      }
    }
    return 0;
  }
  return result;
}

uint64_t BMPWritePlugin::writeOneImage(BMPWritePlugin *this, CGImageRef image, IIODictionary *a3, IIODictionary *a4)
{
  unsigned int Height = CGImageGetHeight(image);
  if (_ImageHasRealAlphaChannel(image)
    && (!IIODictionary::containsKey(a3, @"kCGImageDestinationAllowAlpha")
     || IIODictionary::getBoolForKey(a3, @"kCGImageDestinationAllowAlpha")))
  {
    CGBitmapInfo v8 = 3;
    int v9 = 1;
  }
  else
  {
    int v9 = 0;
    CGBitmapInfo v8 = 0;
  }
  BMPWritePlugin::writePrefix(this, image, a3, v9);
  memset(v25, 0, sizeof(v25));
  IIODictionary::IIODictionary((IIODictionary *)v25);
  IIONumber::IIONumber((IIONumber *)v24, *((void *)this + 5));
  IIODictionary::setObjectForKey((uint64_t)v25, (uint64_t)v24, @"DestinationRowBytes");
  IIONumber::~IIONumber((IIONumber *)v24);
  *(void *)&v23.renderingIntent = 0;
  if (v9) {
    uint32_t v10 = 32;
  }
  else {
    uint32_t v10 = 24;
  }
  v23.bitsPerComponent = 8;
  v23.bitsPerPixel = v10;
  CFStringRef v11 = (const __CFString *)*MEMORY[0x1E4F1DC98];
  v21[0] = (CGColorSpaceRef)&unk_1ED4DFD58;
  v21[1] = CGColorSpaceCreateWithName(v11);
  v23.colorSpace = v21[1];
  IIOColorSpace::~IIOColorSpace(v21);
  v23.bitmapInfo = v8;
  *(_OWORD *)&v23.version = 0uLL;
  uint64_t v22 = 0;
  memset(v21, 0, sizeof(v21));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v21, image, &v23, (IIODictionary *)v25);
  uint64_t v17 = 0;
  BOOL v18 = &v17;
  uint64_t v19 = 0x2000000000;
  uint64_t v20 = 0;
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 0x40000000;
  _OWORD v15[2] = ___ZN14BMPWritePlugin13writeOneImageEP7CGImageP13IIODictionaryS3_j_block_invoke;
  v15[3] = &unk_1E53C00C0;
  vImage_CGImageFormat v16 = v23;
  v15[4] = &v17;
  v15[5] = this;
  uint64_t v12 = IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v21, 0, Height, 16, (uint64_t)v15);
  uint64_t v13 = (void *)v18[3];
  if (v13)
  {
    free(v13);
    void v18[3] = 0;
  }
  _Block_object_dispose(&v17, 8);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v21);
  IIODictionary::~IIODictionary((IIODictionary *)v25);
  return v12;
}

void sub_1887979B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va1, a13);
  va_start(va, a13);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)(v13 - 88));
  _Unwind_Resume(a1);
}

size_t ___ZN14BMPWritePlugin13writeOneImageEP7CGImageP13IIODictionaryS3_j_block_invoke(uint64_t a1, int a2, vImage_Buffer *src)
{
  uint64_t v4 = *(void *)(a1 + 40);
  int v5 = *(_DWORD *)(a1 + 52);
  if (v5 == 32)
  {
    LODWORD(dest.data) = 50331906;
    vImagePermuteChannels_ARGB8888(src, src, (const uint8_t *)&dest, 0);
    uint64_t v7 = *(IIOImageWriteSession **)(v4 + 16);
    rowunint64_t Bytes = src->rowBytes;
    data = src->data;
    vImagePixelCount height = src->height;
    return IIOImageWriteSession::putBytes(v7, data, height * rowBytes);
  }
  if (v5 == 24)
  {
    char v17 = 0;
    *(_WORD *)permuteMap = 258;
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = reallocf(*(void **)(*(void *)(*(void *)(a1 + 32) + 8)+ 24), src->height * src->rowBytes);
    dest.data = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    *(_OWORD *)&dest.vImagePixelCount height = *(_OWORD *)&src->height;
    dest.rowunint64_t Bytes = src->rowBytes;
    vImagePermuteChannels_RGB888(src, &dest, permuteMap, 0);
    uint64_t v7 = *(IIOImageWriteSession **)(v4 + 16);
    data = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    rowunint64_t Bytes = dest.rowBytes;
    vImagePixelCount height = dest.height;
    return IIOImageWriteSession::putBytes(v7, data, height * rowBytes);
  }
  uint64_t v12 = *(IIOImageWriteSession **)(v4 + 16);
  uint64_t v13 = src->data;
  size_t v14 = src->height * src->rowBytes;

  return IIOImageWriteSession::putBytes(v12, v13, v14);
}

uint64_t BMPWritePlugin::writeOne(BMPWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t BMPWritePlugin::WriteImageWithSession(BMPWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, CGImage *a4, IIODictionary *a5, IIODictionary *a6)
{
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v13, this, a2, 1112363040);
  *(void *)&v13[0] = &unk_1ED4E1070;
  LOBYTE(v14) = 1;
  uint64_t v9 = BMPWritePlugin::writeOneImage((BMPWritePlugin *)v13, a3, a4, v8);
  _cg_jpeg_mem_term(v13, v10, v11);
  return v9;
}

void sub_188797BE4(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

const char *ASTCTwiddler::ASTCTwiddlerImpl::copyFromTextureDataImp(ASTCTwiddler::ASTCTwiddlerImpl *this, const void *a2, void *a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  uint64_t v7 = (void *)*((void *)this + 7);
  int8x16_t v8 = (int8x16_t)vshlq_u64(*(uint64x2_t *)((char *)this + 8), (uint64x2_t)vnegq_s64(vdupq_n_s64(a6)));
  int8x16_t v9 = (int8x16_t)vcgtq_u64((uint64x2_t)v8, (uint64x2_t)vdupq_n_s64(1uLL));
  int64x2_t v12 = vsubq_s64((int64x2_t)vandq_s8(v8, v9), (int64x2_t)vmvnq_s8(v9));
  uint64_t v13 = 1;
  memset(v11, 0, sizeof(v11));
  [v7 copyFromTextureMemory:a2 textureSlice:0 textureLevel:(int)a6 textureRegion:v11 toLinearBytes:a3 linearOffset:a4 linearBytesPerRow:a5 linearBytesPerImage:0];
  return ASTCTwiddler::ASTCTwiddlerImpl::finalizeTwiddlingImp((const char *)this);
}

ASTCTwiddler::ASTCTwiddlerImpl *ASTCTwiddler::copyFromTextureData(ASTCTwiddler *this, const void *a2, void *a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  uint64_t result = (ASTCTwiddler::ASTCTwiddlerImpl *)*((void *)this + 1);
  if (result) {
    return (ASTCTwiddler::ASTCTwiddlerImpl *)ASTCTwiddler::ASTCTwiddlerImpl::copyFromTextureDataImp(result, a2, a3, a4, a5, a6);
  }
  return result;
}

unsigned char *TIFFSwabShort(unsigned char *result)
{
  char v1 = result[1];
  result[1] = *result;
  *uint64_t result = v1;
  return result;
}

int8x8_t TIFFSwabLong(__int32 *a1, uint8x8_t a2)
{
  a2.i32[0] = *a1;
  int16x8_t v2 = (int16x8_t)vmovl_u8(a2);
  *(int16x4_t *)v2.i8 = vrev64_s16(*(int16x4_t *)v2.i8);
  int8x8_t result = vmovn_s16(v2);
  *a1 = result.i32[0];
  return result;
}

int8x8_t TIFFSwabLong8(int8x8_t *a1)
{
  int8x8_t result = vrev64_s8(*a1);
  *a1 = result;
  return result;
}

uint64_t TIFFSwabArrayOfShort(uint64_t result, uint64_t a2)
{
  if (a2 >= 1)
  {
    unint64_t v2 = a2 + 1;
    unint64_t v3 = (char *)(result + 1);
    do
    {
      char v4 = *v3;
      char *v3 = *(v3 - 1);
      *(v3 - 1) = v4;
      --v2;
      v3 += 2;
    }
    while (v2 > 1);
  }
  return result;
}

uint64_t TIFFSwabArrayOfTriples(uint64_t result, uint64_t a2)
{
  if (a2 >= 1)
  {
    unint64_t v2 = a2 + 1;
    unint64_t v3 = (char *)(result + 2);
    do
    {
      char v4 = *v3;
      char *v3 = *(v3 - 2);
      *(v3 - 2) = v4;
      --v2;
      v3 += 3;
    }
    while (v2 > 1);
  }
  return result;
}

__int32 *TIFFSwabArrayOfLong(__int32 *result, uint64_t a2, uint8x8_t a3)
{
  if (a2 >= 1)
  {
    unint64_t v3 = a2 + 1;
    do
    {
      a3.i32[0] = *result;
      int16x8_t v4 = (int16x8_t)vmovl_u8(a3);
      *(int16x4_t *)v4.i8 = vrev64_s16(*(int16x4_t *)v4.i8);
      a3 = (uint8x8_t)vmovn_s16(v4);
      *result++ = a3.i32[0];
      --v3;
    }
    while (v3 > 1);
  }
  return result;
}

int8x8_t *TIFFSwabArrayOfLong8(int8x8_t *result, uint64_t a2)
{
  if (a2 >= 1)
  {
    unint64_t v2 = a2 + 1;
    do
    {
      *int8x8_t result = vrev64_s8(*result);
      ++result;
      --v2;
    }
    while (v2 > 1);
  }
  return result;
}

void *TIFFGetBitRevTable(int a1)
{
  if (a1) {
    return &TIFFBitRevTable;
  }
  else {
    return &TIFFNoBitRevTable;
  }
}

unsigned __int8 *TIFFReverseBits(unsigned __int8 *result, uint64_t a2)
{
  if (a2 < 9)
  {
    if (a2 <= 0) {
      return result;
    }
  }
  else
  {
    unint64_t v2 = a2;
    do
    {
      *int8x8_t result = TIFFBitRevTable[*result];
      result[1] = TIFFBitRevTable[result[1]];
      result[2] = TIFFBitRevTable[result[2]];
      result[3] = TIFFBitRevTable[result[3]];
      result[4] = TIFFBitRevTable[result[4]];
      result[5] = TIFFBitRevTable[result[5]];
      result[6] = TIFFBitRevTable[result[6]];
      result[7] = TIFFBitRevTable[result[7]];
      result += 8;
      a2 = v2 - 8;
      BOOL v3 = v2 > 0x10;
      v2 -= 8;
    }
    while (v3);
  }
  unint64_t v4 = a2 + 1;
  do
  {
    *int8x8_t result = TIFFBitRevTable[*result];
    ++result;
    --v4;
  }
  while (v4 > 1);
  return result;
}

void IIO_Reader_JP2::createReadPlugin()
{
}

{
  operator new();
}

void sub_188797F5C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40736AB4CFLL);
  _Unwind_Resume(a1);
}

void sub_188797FFC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40736AB4CFLL);
  _Unwind_Resume(a1);
}

CFDataRef IIO_Reader_JP2::createGlobalInfoData(IIO_Reader_JP2 *this, IIOImageReadSession *a2)
{
  unint64_t v2 = IIOImageReadSession::globalInfoForType(a2, 1246769696);
  if (!v2) {
    return 0;
  }
  int v5 = 0;
  uint64_t v6 = 0;
  GlobalJP2Info::GlobalJP2Info((GlobalJP2Info *)&v5, v2);
  HIDWORD(v5) = 0;
  uint64_t v6 = 0;
  CFDataRef v3 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)&v5, 16);
  GlobalJP2Info::~GlobalJP2Info(&v5);
  return v3;
}

void sub_1887980A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

uint64_t IIO_Reader_JP2::updateGlobalInfo(IIO_Reader_JP2 *this, IIOImageRead **a2, unsigned __int8 *a3, uint64_t a4)
{
  if (a3 && a4 == 16)
  {
    uint64_t v6 = malloc_type_malloc(0x10uLL, 0x1010040449DF08BuLL);
    *uint64_t v6 = *(_OWORD *)a3;
    IIOImageReadSession::setGlobalInfo(a2, 1246769696, v6, releaseGlobalInfoJP2);
  }
  return 0;
}

BOOL IIO_Reader_JP2::compareOptions(IIO_Reader_JP2 *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  memset(v11, 0, sizeof(v11));
  IIODictionary::IIODictionary((IIODictionary *)v11, a2);
  memset(v10, 0, sizeof(v10));
  IIODictionary::IIODictionary((IIODictionary *)v10, a3);
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v11, @"kCGImageSourceSubsampleFactor");
  unsigned int v5 = IIODictionary::getUint32ForKey((IIODictionary *)v10, @"kCGImageSourceSubsampleFactor");
  if (Uint32ForKey <= 1) {
    int v6 = 1;
  }
  else {
    int v6 = Uint32ForKey;
  }
  if (v5 <= 1) {
    int v7 = 1;
  }
  else {
    int v7 = v5;
  }
  BOOL v8 = v6 == v7;
  IIODictionary::~IIODictionary((IIODictionary *)v10);
  IIODictionary::~IIODictionary((IIODictionary *)v11);
  return v8;
}

void sub_1887981D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

void IIO_Reader_JP2::initThumbnail()
{
}

void sub_1887982A4(void *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40736AB4CFLL);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x188798290);
}

uint64_t IIO_Reader_JP2::hasCustomCompareOptionsProc(IIO_Reader_JP2 *this)
{
  return 1;
}

uint64_t IIO_Reader_JP2::hasCustomThumbnailProc(IIO_Reader_JP2 *this)
{
  return 1;
}

void PVRWritePlugin::PVRWritePlugin(PVRWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, char a4)
{
  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 1347834400);
  *(void *)uint64_t v5 = &unk_1ED4E2CC8;
  *(unsigned char *)(v5 + 37) = a4;
  *(void *)(v5 + 40) = 0;
}

void PVRWritePlugin::PVRWritePlugin(IIOWritePlugin *a1, IIOImageWriteSession *a2, IIOImageDestination *a3, uint64_t a4)
{
  IIOWritePlugin::IIOWritePlugin(a1, a2, a3, 1347834400);
  *(void *)uint64_t v5 = &unk_1ED4E2CC8;
  *(unsigned char *)(v5 + 37) = 0;
  *(void *)(v5 + 40) = a4;
}

void PVRWritePlugin::~PVRWritePlugin(PVRWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t PVRWritePlugin::writePVRHeader(IIOImageWriteSession **this, int a2, int a3, int a4)
{
  uint64_t __ptr = 55727696;
  int v7 = 2 * (a4 == 4);
  int v8 = 0;
  uint64_t v9 = 0;
  int v10 = a3;
  int v11 = a2;
  *(void *)&long long v4 = 0x100000001;
  *((void *)&v4 + 1) = 0x100000001;
  long long v12 = v4;
  int v13 = 0;
  if (IIOImageWriteSession::putBytes(this[2], &__ptr, 0x34uLL) == 52) {
    return 0;
  }
  else {
    return 4294967246;
  }
}

uint64_t PVRWritePlugin::writeOneImage(PVRWritePlugin *this, CGImageRef image, IIODictionary *a3, IIODictionary *a4)
{
  size_t Width = CGImageGetWidth(image);
  size_t Height = CGImageGetHeight(image);
  CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(image);
  uint64_t v31 = 0;
  unsigned int v32 = &v31;
  uint64_t v33 = 0x2000000000;
  int v34 = -50;
  if (Width == Height)
  {
    if (Width < 8)
    {
      int v10 = "*** can't write PVR - %d x %d (too small)\n";
      int v11 = 114;
LABEL_4:
      LogError("writeOneImage", v11, v10, Width, Width);
      goto LABEL_24;
    }
    CGImageAlphaInfo v12 = AlphaInfo;
    if (!isPowerOf2(Width) || !isPowerOf2(Width))
    {
      int v10 = "*** can't write non-power-of-2 PVR - %d x %d\n";
      int v11 = 115;
      goto LABEL_4;
    }
    if (IIODictionary::containsKey(a3, @"kCGImagePropertyPVRBitsPerPixel"))
    {
      if (IIODictionary::getUint32ForKey(a3, @"kCGImagePropertyPVRBitsPerPixel") <= 2) {
        int v13 = 2;
      }
      else {
        int v13 = 4;
      }
    }
    else
    {
      int v13 = 4;
    }
    if (IIODictionary::containsKey(a3, @"kCGImagePropertyPVRChannelWeighting"))
    {
      unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(a3, @"kCGImagePropertyPVRChannelWeighting");
      if (Uint32ForKey > 2) {
        int v15 = 1;
      }
      else {
        int v15 = Uint32ForKey;
      }
    }
    else
    {
      int v15 = 1;
    }
    if (IIODictionary::containsKey(a3, @"kCGImagePropertyPVRPunchThrough"))
    {
      unsigned int v16 = IIODictionary::getUint32ForKey(a3, @"kCGImagePropertyPVRPunchThrough");
      if (v16 <= 2) {
        unsigned int v17 = v16;
      }
      else {
        unsigned int v17 = 0;
      }
    }
    else
    {
      unsigned int v17 = 0;
    }
    *(void *)&v30.renderingIntent = 0;
    *(void *)&v30.bitsPerComponent = 0x2000000008;
    CFStringRef v18 = (const __CFString *)*MEMORY[0x1E4F1DC98];
    *(void *)&v28[0] = &unk_1ED4DFD58;
    *((void *)&v28[0] + 1) = CGColorSpaceCreateWithName(v18);
    v30.colorSpace = (CGColorSpaceRef)*((void *)&v28[0] + 1);
    IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)v28);
    v30.bitmapInfo = 3;
    *(_OWORD *)&v30.version = 0uLL;
    uint64_t v29 = 0;
    memset(v28, 0, sizeof(v28));
    IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v28, image, &v30, 0);
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 0x40000000;
    v21[2] = ___ZN14PVRWritePlugin13writeOneImageEP7CGImageP13IIODictionaryS3_j_block_invoke;
    v21[3] = &unk_1E53C00E8;
    v21[6] = Width;
    v21[7] = Width;
    int v22 = v13;
    int v23 = 0;
    int v24 = v15;
    int v25 = 1;
    v21[4] = &v31;
    _OWORD v21[5] = this;
    unsigned int v26 = v17;
    CGImageAlphaInfo v27 = v12;
    IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v28, 0, Width, Width, (uint64_t)v21);
    IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v28);
  }
  else
  {
    LogError("writeOneImage", 112, "*** can't write non-square PVR [%zu x %zu]\n");
  }
LABEL_24:
  uint64_t v19 = *((unsigned int *)v32 + 6);
  _Block_object_dispose(&v31, 8);
  return v19;
}

void sub_188798718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Block_object_dispose((const void *)(v15 - 112), 8);
  _Unwind_Resume(a1);
}

void ___ZN14PVRWritePlugin13writeOneImageEP7CGImageP13IIODictionaryS3_j_block_invoke(uint64_t a1, uint64_t a2, int8x8_t *a3)
{
  *(_OWORD *)uint64_t v14 = 0u;
  long long v15 = 0u;
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = *(unsigned int *)(a1 + 64);
  if (encodePVRTC(v14, a3, v7, *(unsigned int *)(a1 + 68), *(_DWORD *)(a1 + 72), *(_DWORD *)(a1 + 76), *(_DWORD *)(a1 + 80)))
  {
    size_t v8 = (unint64_t)(v6 * v5 * v7) >> 3;
    uint64_t v9 = *(void *)(v4 + 40);
    if (v9)
    {
      if ((*(uint64_t (**)(void))(*(void *)(v9 + 8) + 24))() == v8) {
        (*(void (**)(void))(*(void *)(*(void *)(v4 + 40) + 8) + 64))();
      }
    }
    else
    {
      if (*(unsigned char *)(v4 + 37))
      {
        int v10 = *(_DWORD *)(a1 + 64);
        if (v10 == 2) {
          int v11 = 35843;
        }
        else {
          int v11 = 0;
        }
        if (v10 == 4) {
          int v12 = 35842;
        }
        else {
          int v12 = v11;
        }
        *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = KTXWritePlugin::writeKTXHeader(*(IIOImageWriteSession **)(v4 + 16), *(_DWORD *)(a1 + 48), *(_DWORD *)(a1 + 56), 0, 1u, *(unsigned char *)(a1 + 84), 0, 1, 0, v12, 0, 0);
        if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
        {
          int __ptr = v8;
          IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v4 + 16), &__ptr, 4uLL);
        }
      }
      else
      {
        *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = PVRWritePlugin::writePVRHeader((IIOImageWriteSession **)v4, *(void *)(a1 + 48), *(void *)(a1 + 56), *(_DWORD *)(a1 + 64));
      }
      if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
        IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v4 + 16), v14[0], v8);
      }
    }
  }
  if (v14[0]) {
    free(v14[0]);
  }
}

uint64_t PVRWritePlugin::writeOne(PVRWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

BOOL PVRWritePlugin::WriteProc(PVRWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v9, this, a2, 1347834400);
  *(void *)&v9[0] = &unk_1ED4E2CC8;
  BYTE5(v10) = 0;
  *((void *)&v10 + 1) = 0;
  BOOL v5 = IIOWritePlugin::writeAll((IIOImageDestination **)v9) != 0;
  _cg_jpeg_mem_term(v9, v6, v7);
  return v5;
}

void sub_188798964(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t PVRWritePlugin::GetVkFormat(PVRWritePlugin *this, IIODictionary *a2)
{
  if (!this) {
    return 0;
  }
  uint64_t v3 = 1000054005;
  if (IIODictionary::containsKey(this, @"kCGImagePropertyPVRBitsPerPixel"))
  {
    if (IIODictionary::getUint32ForKey(this, @"kCGImagePropertyPVRBitsPerPixel") >= 3) {
      return 1000054005;
    }
    else {
      return 1000054004;
    }
  }
  return v3;
}

void _TAGList::_TAGList(_TAGList *this, char a2)
{
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((unsigned char *)this + 41) = a2;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_1ED4E5F60;
}

void _TAGList::~_TAGList(_TAGList *this)
{
  *(void *)this = &unk_1ED4E5F60;
  unint64_t v2 = (void *)*((void *)this + 2);
  uint64_t v3 = (void *)*((void *)this + 3);
  if (v2 != v3)
  {
    do
    {
      if (*v2) {
        (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
      }
      ++v2;
    }
    while (v2 != v3);
    unint64_t v2 = (void *)*((void *)this + 2);
  }
  *((void *)this + 3) = v2;
  uint64_t v4 = (void *)*((void *)this + 1);
  if (v4)
  {
    free(v4);
    *((void *)this + 1) = 0;
    unint64_t v2 = (void *)*((void *)this + 2);
  }
  if (v2)
  {
    *((void *)this + 3) = v2;
    operator delete(v2);
  }
}

{
  uint64_t vars8;

  _TAGList::~_TAGList(this);

  JUMPOUT(0x18C11C0E0);
}

__n128 _TAGList::insertTag(_TAGList *this, _TAG *a2)
{
  long long v15 = a2;
  uint64_t v4 = (char *)*((void *)this + 2);
  BOOL v5 = (char *)*((void *)this + 3);
  uint64_t v3 = (char *)this + 16;
  if (v4 == v5)
  {
    uint64_t v4 = v5;
  }
  else
  {
    int v6 = *((unsigned __int16 *)a2 + 20);
    uint64_t v7 = v4;
    do
    {
      if (*(unsigned __int16 *)(*(void *)v7 + 40) == v6) {
        return _cg_jpeg_mem_term("insertTag", 77, "*** ERROR: duplicate _TAG? '%p' (markerID: 0x%04X) already exists\n", a2, v6);
      }
      v7 += 8;
    }
    while (v7 != v5);
    unint64_t v8 = (v5 - v4) >> 3;
    unsigned int v9 = *((unsigned __int16 *)a2 + 20);
    do
    {
      unint64_t v10 = v8 >> 1;
      int v11 = &v4[8 * (v8 >> 1)];
      uint64_t v13 = *(void *)v11;
      int v12 = v11 + 8;
      v8 += ~(v8 >> 1);
      if (*(unsigned __int16 *)(v13 + 40) <= v9) {
        uint64_t v4 = v12;
      }
      else {
        unint64_t v8 = v10;
      }
    }
    while (v8);
  }
  std::vector<_TAG *>::insert((uint64_t)v3, v4, (char *)&v15);
  return result;
}

char *std::vector<_TAG *>::insert(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = __src;
  int v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      uint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(a1 + 16, v18);
    }
    else {
      uint64_t v19 = 0;
    }
    uint64_t v20 = &v19[8 * v16];
    __p = v19;
    CGImageAlphaInfo v27 = v20;
    unsigned int v28 = v20;
    uint64_t v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        int v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v8, v22);
        uint64_t v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        CGImageAlphaInfo v27 = v20;
        uint64_t v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        CGImageAlphaInfo v27 = v20;
      }
    }
    *(void *)uint64_t v20 = *(void *)v3;
    unsigned int v28 = v20 + 8;
    uint64_t v4 = std::vector<_APPx *>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(void *)__src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    unsigned int v9 = __src + 8;
    unint64_t v10 = v6 - 8;
    int v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)uint64_t v4 = *(void *)v3;
  }
  return v4;
}

void sub_188798DE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t _TAGList::removeTag(uint64_t result, unsigned __int16 *a2)
{
  uint64_t v4 = *(void *)(result + 16);
  uint64_t v3 = *(void *)(result + 24);
  if (v4 != v3)
  {
    int v5 = a2[20];
    while (*(unsigned __int16 *)(*(void *)v4 + 40) != v5)
    {
      v4 += 8;
      if (v4 == v3) {
        goto LABEL_14;
      }
    }
    if (v4 != v3)
    {
      uint64_t v6 = v4 + 8;
      if (v4 + 8 != v3)
      {
        do
        {
          if (*(unsigned __int16 *)(*(void *)v6 + 40) != v5)
          {
            *(void *)uint64_t v4 = *(void *)v6;
            v4 += 8;
          }
          v6 += 8;
        }
        while (v6 != v3);
        uint64_t v3 = *(void *)(result + 24);
      }
      if (v4 != v3) {
        *(void *)(result + 24) = v4;
      }
    }
  }
LABEL_14:
  if (a2)
  {
    unint64_t v7 = *(uint64_t (**)(unsigned __int16 *))(*(void *)a2 + 8);
    return v7(a2);
  }
  return result;
}

uint64_t _TAGList::findTagByID(_TAGList *this, int a2)
{
  uint64_t v2 = *((void *)this + 2);
  uint64_t v3 = *((void *)this + 3);
  if (v2 != v3)
  {
    while (*(unsigned __int16 *)(*(void *)v2 + 40) != a2)
    {
      v2 += 8;
      if (v2 == v3) {
        return 0;
      }
    }
  }
  if (v2 == v3) {
    return 0;
  }
  else {
    return *(void *)v2;
  }
}

uint64_t _TAGList::mergeWithTagList(uint64_t this, _TAGList *a2)
{
  if (a2)
  {
    uint64_t v2 = *((void *)a2 + 2);
    if (v2 != *((void *)a2 + 3))
    {
      uint64_t v3 = *(unsigned __int16 ***)(this + 16);
      uint64_t v4 = *(unsigned __int16 ***)(this + 24);
      if (v3 != v4)
      {
        while ((*v3)[20] != *(unsigned __int16 *)(*(void *)v2 + 40))
        {
          if (++v3 == v4) {
            goto LABEL_10;
          }
        }
      }
      if (v3 != v4)
      {
        if (*v3) {
          _TAGList::removeTag(this, *v3);
        }
      }
LABEL_10:
      operator new();
    }
    *((void *)a2 + 3) = v2;
  }
  return this;
}

uint64_t _TAGList::dump(_TAGList *this)
{
  return (unsigned __int16)((*((_DWORD *)this + 6) - *((_DWORD *)this + 4)) >> 3);
}

uint64_t _TAGList::writeToBuffer(uint64_t this, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 *a4, unsigned int *a5, unsigned int *a6, uint64_t a7)
{
  uint64_t v17 = 0;
  *a5 = 0;
  *a6 = 0;
  unint64_t v7 = *(uint64_t **)(this + 16);
  for (unsigned int i = *(uint64_t **)(this + 24); v7 != i; *a6 += v16)
  {
    uint64_t v15 = *v7++;
    this = (*(uint64_t (**)(uint64_t, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, char *, uint64_t *, uint64_t))(*(void *)v15 + 16))(v15, a2, a3, a4, (char *)&v17 + 4, &v17, a7);
    int v16 = v17;
    a3 += HIDWORD(v17);
    a4 += v17;
    *a5 += HIDWORD(v17);
  }
  return this;
}

void _TAG::_TAG(_TAG *this, char a2, __int16 a3, __int16 a4, int a5, unsigned __int8 *a6, int a7, int a8, char a9, BOOL a10)
{
  *(void *)this = &unk_1ED4E5678;
  *((void *)this + 1) = 0;
  *((unsigned char *)this + 24) = a2;
  *((_DWORD *)this + 7) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 4) = 0;
  *((unsigned char *)this + 80) = a9;
  *((_WORD *)this + 20) = a3;
  *((_WORD *)this + 28) = a4;
  *((_DWORD *)this + 15) = a5;
  *((_DWORD *)this + 16) = a8;
  if (a6 && a10) {
    operator new[]();
  }
  *((void *)this + 9) = a6;
  *((unsigned char *)this + 81) = 0;
  *((_DWORD *)this + 17) = a7;
}

void _TAG::_TAG(_TAG *this, unsigned __int8 *a2, uint64_t a3, char a4, int a5, unsigned int a6, char a7)
{
  *(void *)this = &unk_1ED4E5678;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((unsigned char *)this + 24) = a4;
  *((_DWORD *)this + 7) = a5;
  *((void *)this + 6) = &a2[a6];
  *((void *)this + 4) = a6;
  *((unsigned char *)this + 80) = a7;
  *((_WORD *)this + 20) = _TAG::readShort(this);
  *((_WORD *)this + 28) = (*(uint64_t (**)(_TAG *))(*(void *)this + 32))(this);
  *((_DWORD *)this + 15) = (*(uint64_t (**)(_TAG *))(*(void *)this + 96))(this);
  *((_DWORD *)this + 16) = 0;
  *((void *)this + 9) = 0;
  (*(void (**)(_TAG *))(*(void *)this + 104))(this);
  *((unsigned char *)this + 81) = 0;
}

double _TAG::_TAG(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3 = *(void *)(a2 + 8);
  *(void *)a1 = &unk_1ED4E5678;
  *(void *)(a1 + 8) = v3;
  *(unsigned char *)(a1 + 24) = *(unsigned char *)(a2 + 24);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(unsigned char *)(a1 + 80) = *(unsigned char *)(a2 + 80) | a3;
  *(_WORD *)(a1 + 40) = *(_WORD *)(a2 + 40);
  *(void *)(a1 + 48) = *(void *)(a2 + 48);
  *(_WORD *)(a1 + 56) = *(_WORD *)(a2 + 56);
  double result = *(double *)(a2 + 60);
  *(double *)(a1 + 60) = result;
  *(void *)(a1 + 72) = *(void *)(a2 + 72);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  *(unsigned char *)(a1 + 81) = *(unsigned char *)(a2 + 81);
  return result;
}

void _TAG::~_TAG(_TAG *this)
{
  *(void *)this = &unk_1ED4E5678;
  if (*((unsigned char *)this + 81))
  {
    uint64_t v1 = *((void *)this + 9);
    if (v1) {
      MEMORY[0x18C11C0C0](v1, 0x1000C8077774924);
    }
  }
}

{
  uint64_t vars8;

  _TAG::~_TAG(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t _TAG::nativeDataOrOffset(_TAG *this)
{
  unsigned int v1 = *((_DWORD *)this + 16);
  unsigned int v2 = bswap32(v1);
  if (*((unsigned char *)this + 24)) {
    return v1;
  }
  else {
    return v2;
  }
}

unint64_t _TAG::readShort(_TAG *this)
{
  uint64_t v1 = *((void *)this + 4);
  uint64_t v2 = v1 + 2;
  uint64_t v3 = *((void *)this + 2);
  if (v1 + 2 <= v3)
  {
    unint64_t v4 = *((void *)this + 1) + v1;
    int v5 = *(unsigned __int8 *)v4;
    LODWORD(v4) = *(unsigned __int8 *)(v4 + 1);
    unsigned int v6 = v5 | (v4 << 8);
    LODWORD(v4) = v4 | (v5 << 8);
    if (*((unsigned char *)this + 24)) {
      unint64_t v4 = v6;
    }
    else {
      unint64_t v4 = v4;
    }
    *((void *)this + 4) = v2;
  }
  else
  {
    LogError("readShort", 431, "*** ERROR: _TAG::readShort - out-of-bounds: pos: %ld  size: %ld\n", v1, v3);
    return 0;
  }
  return v4;
}

unint64_t _TAG::readLong(_TAG *this)
{
  uint64_t v1 = *((void *)this + 4);
  uint64_t v2 = v1 + 4;
  uint64_t v3 = *((void *)this + 2);
  if (v1 + 4 <= v3)
  {
    unint64_t v4 = *((void *)this + 1) + v1;
    int v5 = *(unsigned __int8 *)v4;
    int v6 = *(unsigned __int8 *)(v4 + 1);
    int v7 = *(unsigned __int8 *)(v4 + 2);
    LODWORD(v4) = *(unsigned __int8 *)(v4 + 3);
    unsigned int v8 = (v5 << 24) | (v6 << 16) | (v7 << 8) | v4;
    LODWORD(v4) = v5 | (v6 << 8) | (v7 << 16) | (v4 << 24);
    if (*((unsigned char *)this + 24)) {
      unint64_t v4 = v4;
    }
    else {
      unint64_t v4 = v8;
    }
    *((void *)this + 4) = v2;
  }
  else
  {
    LogError("readLong", 453, "*** _TAG::readLong - out-of-bounds: pos: %ld  size: %ld\n", v1, v3);
    return 0;
  }
  return v4;
}

void _TAG::readTag(_TAG *this)
{
}

void sub_1887995F4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1091C407990FA9CLL);
  _Unwind_Resume(a1);
}

const char *_TAG::readData(const char *this)
{
  uint64_t v1 = this;
  uint64_t v2 = *((void *)this + 4);
  uint64_t v3 = *((void *)this + 2);
  if (v2 + 4 <= v3)
  {
    *((_DWORD *)this + 16) = *(_DWORD *)(*((void *)this + 1) + v2);
    switch(*((_WORD *)this + 28))
    {
      case 1:
      case 2:
      case 6:
      case 7:
        int v4 = *((_DWORD *)this + 15);
        goto LABEL_8;
      case 3:
      case 8:
        int v4 = 2 * *((_DWORD *)this + 15);
        goto LABEL_8;
      case 4:
      case 9:
      case 0xB:
        int v4 = 4 * *((_DWORD *)this + 15);
        goto LABEL_8;
      case 5:
      case 0xA:
      case 0xC:
        int v4 = 8 * *((_DWORD *)this + 15);
LABEL_8:
        *((_DWORD *)this + 17) = v4;
        break;
      default:
        return this;
    }
  }
  else
  {
    this = LogError("readData", 487, "*** ERROR: readData - out-of-bounds: pos: %ld  size: %ld\n", v2, v3);
    *((void *)v1 + 8) = 0;
    *((_WORD *)v1 + 20) = 0;
  }
  return this;
}

uint64_t _TAG::positionToSubID(uint64_t this)
{
  unsigned int v1 = bswap32(*(_DWORD *)(this + 64));
  if (*(unsigned char *)(this + 24)) {
    unsigned int v2 = *(_DWORD *)(this + 64);
  }
  else {
    unsigned int v2 = v1;
  }
  *(void *)(this + 32) = v2 + *(_DWORD *)(this + 28);
  return this;
}

uint64_t _TAG::setDataOrOffset16(uint64_t this, __int16 a2)
{
  __int16 v2 = __rev16(a2);
  if (*(unsigned char *)(this + 24)) {
    __int16 v3 = a2;
  }
  else {
    __int16 v3 = v2;
  }
  *(_WORD *)(this + 64) = v3;
  return this;
}

uint64_t _TAG::setDataOrOffset32(uint64_t this, int a2)
{
  *(_DWORD *)(this + 64) = a2;
  return this;
}

uint64_t _TAG::copyDateTime(_TAG *this, const char *__s)
{
  uint64_t result = strlen(__s);
  size_t v5 = *((unsigned int *)this + 15);
  if (result == v5 - 1)
  {
    uint64_t v6 = *((void *)this + 1);
    if (v6)
    {
      LODWORD(v7) = *((_DWORD *)this + 16);
      if (v7)
      {
        uint64_t v8 = *((unsigned int *)this + 7);
        if (v8)
        {
          unsigned int v9 = bswap32(v7);
          if (*((unsigned char *)this + 24)) {
            uint64_t v7 = v7;
          }
          else {
            uint64_t v7 = v9;
          }
          return strlcpy((char *)(v6 + v8 + v7), __s, v5);
        }
      }
    }
  }
  return result;
}

uint64_t _TAG::writeData(_TAG *this, unsigned __int8 *a2, int a3)
{
  int v3 = *((unsigned __int8 *)this + 24);
  if (v3 == a3)
  {
    unsigned int v4 = *((_DWORD *)this + 16);
LABEL_28:
    *(_DWORD *)a2 = v4;
    return 4;
  }
  unsigned int v18 = 0;
  unsigned int v5 = *((unsigned __int16 *)this + 28);
  if (v5 <= 0xB)
  {
    uint64_t v6 = (unsigned int *)((char *)this + 64);
    if (((1 << v5) & 0xC6) != 0)
    {
      if (*((_DWORD *)this + 17) >= 4u) {
        int v9 = 4;
      }
      else {
        int v9 = (unsigned __int16)*((_DWORD *)this + 17);
      }
      for (; v9; --v9)
      {
        unsigned __int8 v10 = *(unsigned char *)v6;
        uint64_t v6 = (unsigned int *)((char *)v6 + 1);
        *a2++ = v10;
      }
    }
    else
    {
      if (((1 << v5) & 0xA10) != 0)
      {
        unsigned int v4 = *v6;
        unsigned int v7 = bswap32(v4);
        if (!v3) {
          unsigned int v4 = v7;
        }
        unsigned int v8 = bswap32(v4);
        if (!a3) {
          unsigned int v4 = v8;
        }
        goto LABEL_28;
      }
      if (((1 << v5) & 0x108) != 0)
      {
        int v11 = (unsigned __int16)*((_DWORD *)this + 17);
        if (*((_DWORD *)this + 17) >= 2u) {
          int v11 = 2;
        }
        if (v11)
        {
          uint64_t v12 = 0;
          int v13 = 2 * v11;
          do
          {
            unsigned int v14 = *(unsigned __int16 *)((char *)v6 + v12);
            unsigned int v15 = bswap32(v14) >> 16;
            if (!v3) {
              unsigned int v14 = v15;
            }
            unsigned int v16 = bswap32(v14) >> 16;
            if (!a3) {
              LOWORD(v14) = v16;
            }
            *(_WORD *)((char *)&v18 + v12) = v14;
            v12 += 2;
          }
          while (v13 != v12);
          unsigned int v4 = v18;
        }
        else
        {
          unsigned int v4 = 0;
        }
        goto LABEL_28;
      }
    }
  }
  return 4;
}

uint64_t _TAG::writeToBuffer(uint64_t this, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 *__dst, unsigned int *a5, unsigned int *a6, int a7)
{
  uint64_t v9 = this;
  *(void *)(this + 48) = a3;
  __int16 v10 = *(_WORD *)(this + 40);
  if (a7) {
    unsigned __int8 v11 = *(_WORD *)(this + 40);
  }
  else {
    unsigned __int8 v11 = HIBYTE(*(_WORD *)(this + 40));
  }
  if (a7) {
    LOBYTE(v10) = HIBYTE(*(_WORD *)(this + 40));
  }
  *a3 = v11;
  a3[1] = v10;
  __int16 v12 = *(_WORD *)(this + 56);
  if (a7) {
    unsigned __int8 v13 = *(_WORD *)(this + 56);
  }
  else {
    unsigned __int8 v13 = HIBYTE(*(_WORD *)(this + 56));
  }
  if (a7) {
    LOBYTE(v12) = HIBYTE(*(_WORD *)(this + 56));
  }
  a3[2] = v13;
  a3[3] = v12;
  unsigned int v14 = *(_DWORD *)(this + 60);
  unsigned int v15 = HIWORD(v14);
  if (a7) {
    unsigned __int8 v16 = *(_DWORD *)(this + 60);
  }
  else {
    unsigned __int8 v16 = HIBYTE(*(_DWORD *)(this + 60));
  }
  if (a7) {
    unsigned __int8 v17 = BYTE1(*(_DWORD *)(this + 60));
  }
  else {
    unsigned __int8 v17 = BYTE2(*(_DWORD *)(this + 60));
  }
  if (a7) {
    LOBYTE(v14) = HIBYTE(*(_DWORD *)(this + 60));
  }
  else {
    LOBYTE(v15) = BYTE1(*(_DWORD *)(this + 60));
  }
  a3[4] = v16;
  a3[5] = v17;
  a3[6] = v15;
  a3[7] = v14;
  if (*(_DWORD *)(this + 68) > 4u)
  {
    unsigned int v19 = __dst - a2;
    unsigned int v20 = (__dst - a2) >> 16;
    if (a7)
    {
      unsigned int v21 = v19 >> 8;
      LOBYTE(v22) = (_BYTE)__dst - (_BYTE)a2;
      v19 >>= 24;
    }
    else
    {
      unsigned int v22 = HIBYTE(v19);
      unsigned int v21 = HIWORD(v19);
      unsigned int v20 = v19 >> 8;
    }
    a3[8] = v22;
    a3[9] = v21;
    a3[10] = v20;
    a3[11] = v19;
    int v23 = *(unsigned int **)(this + 72);
    if (!v23)
    {
      unsigned int v24 = *(_DWORD *)(this + 64);
      unsigned int v25 = bswap32(v24);
      if (*(unsigned char *)(this + 24)) {
        uint64_t v26 = v24;
      }
      else {
        uint64_t v26 = v25;
      }
      int v23 = (unsigned int *)(*(void *)(this + 8) + *(unsigned int *)(this + 28) + v26);
    }
    switch(*(_WORD *)(this + 56))
    {
      case 1:
      case 2:
      case 6:
      case 7:
        this = (uint64_t)memcpy(__dst, v23, *(unsigned int *)(this + 68));
        break;
      case 3:
      case 8:
        unsigned int v27 = *(_DWORD *)(this + 68);
        int v38 = (unsigned __int16)(v27 >> 1);
        if (!(unsigned __int16)(v27 >> 1)) {
          goto LABEL_53;
        }
        do
        {
          unsigned int v40 = *(unsigned __int16 *)v23;
          int v23 = (unsigned int *)((char *)v23 + 2);
          unsigned int v39 = v40;
          unsigned int v41 = bswap32(v40) >> 16;
          if (!*(unsigned char *)(this + 24)) {
            unsigned int v39 = v41;
          }
          unsigned int v42 = bswap32(v39) >> 16;
          if (!a7) {
            LOWORD(v39) = v42;
          }
          *(_WORD *)__dst = v39;
          __dst += 2;
          --v38;
        }
        while (v38);
        break;
      case 4:
      case 9:
      case 0xB:
        unsigned int v27 = *(_DWORD *)(this + 68);
        int v28 = (unsigned __int16)(v27 >> 2);
        if (!(unsigned __int16)(v27 >> 2)) {
          goto LABEL_53;
        }
        do
        {
          unsigned int v30 = *v23++;
          unsigned int v29 = v30;
          unsigned int v31 = bswap32(v30);
          if (!*(unsigned char *)(this + 24)) {
            unsigned int v29 = v31;
          }
          unsigned int v32 = bswap32(v29);
          if (!a7) {
            unsigned int v29 = v32;
          }
          *(_DWORD *)__dst = v29;
          __dst += 4;
          --v28;
        }
        while (v28);
        break;
      case 5:
      case 0xA:
      case 0xC:
        unsigned int v27 = *(_DWORD *)(this + 68);
        int v33 = (unsigned __int16)(v27 >> 2);
        if (!(unsigned __int16)(v27 >> 2)) {
          goto LABEL_53;
        }
        do
        {
          unsigned int v35 = *v23++;
          unsigned int v34 = v35;
          unsigned int v36 = bswap32(v35);
          if (!*(unsigned char *)(this + 24)) {
            unsigned int v34 = v36;
          }
          unsigned int v37 = bswap32(v34);
          if (!a7) {
            unsigned int v34 = v37;
          }
          *(_DWORD *)__dst = v34;
          __dst += 4;
          --v33;
        }
        while (v33);
        break;
      default:
        unsigned int v27 = 0;
        goto LABEL_53;
    }
    unsigned int v27 = *(_DWORD *)(v9 + 68);
LABEL_53:
    unsigned int v18 = (v27 + 1) & 0xFFFFFFFE;
  }
  else
  {
    this = _TAG::writeData((_TAG *)this, a3 + 8, a7);
    unsigned int v18 = 0;
  }
  *a5 = 12;
  *a6 = v18;
  return this;
}

void _APPx::_APPx(_APPx *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  *(void *)this = &unk_1ED4E58D8;
  *((void *)this + 5) = a2;
  *((void *)this + 6) = a3;
  *((void *)this + 2) = a4;
  *((void *)this + 3) = a4;
  *((unsigned char *)this + 32) = 0;
  *((unsigned char *)this + 73) = 0;
  *((void *)this + 8) = 0;
  *((_WORD *)this + 28) = a5;
  *((_DWORD *)this + 19) = 0;
  *((_DWORD *)this + 15) = a6;
  if (a5 == 65497) {
    __int16 v7 = -1;
  }
  else {
    __int16 v7 = a5;
  }
  if (a5 == 65496) {
    __int16 v8 = 0;
  }
  else {
    __int16 v8 = v7;
  }
  if ((a5 & 0xFFF0) == 0xFFE0) {
    __int16 v9 = 16 * a5;
  }
  else {
    __int16 v9 = v8;
  }
  *((_WORD *)this + 29) = v9;
  *((unsigned char *)this + 8) = a7;
  *((unsigned char *)this + 74) = 0;
}

void _APPx::~_APPx(_APPx *this)
{
  *(void *)this = &unk_1ED4E58D8;
}

{
  *(void *)this = &unk_1ED4E58D8;
}

{
  *(void *)this = &unk_1ED4E58D8;
  JUMPOUT(0x18C11C0E0);
}

uint64_t _APPx::markerLength(_APPx *this)
{
  return *((unsigned int *)this + 15);
}

uint64_t _APPx::readByte(_APPx *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = *((void *)this + 6);
  if (v1 >= v2)
  {
    LogError("readByte", 932, "*** ERROR: readByte - out-of-bounds: pos: %ld  size: %ld\n", v1, v2);
    return 0;
  }
  else
  {
    uint64_t v3 = v1 + 1;
    uint64_t v4 = *(unsigned __int8 *)(*((void *)this + 5) + v1);
    *((void *)this + 3) = v3;
  }
  return v4;
}

unint64_t _APPx::readShort(_APPx *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = v1 + 2;
  uint64_t v3 = *((void *)this + 6);
  if (v1 + 2 <= v3)
  {
    unint64_t v4 = *((void *)this + 5) + v1;
    int v5 = *(unsigned __int8 *)v4;
    LODWORD(v4) = *(unsigned __int8 *)(v4 + 1);
    unsigned int v6 = v5 | (v4 << 8);
    LODWORD(v4) = v4 | (v5 << 8);
    if (*((unsigned char *)this + 32)) {
      unint64_t v4 = v6;
    }
    else {
      unint64_t v4 = v4;
    }
    *((void *)this + 3) = v2;
  }
  else
  {
    LogError("readShort", 946, "*** ERROR: _APPx::readShort - out-of-bounds: pos: %ld  size: %ld\n", v1, v3);
    return 0;
  }
  return v4;
}

unint64_t _APPx::readLong(_APPx *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = v1 + 4;
  uint64_t v3 = *((void *)this + 6);
  if (v1 + 4 <= v3)
  {
    unint64_t v4 = *((void *)this + 5) + v1;
    int v5 = *(unsigned __int8 *)v4;
    int v6 = *(unsigned __int8 *)(v4 + 1);
    int v7 = *(unsigned __int8 *)(v4 + 2);
    LODWORD(v4) = *(unsigned __int8 *)(v4 + 3);
    unsigned int v8 = (v5 << 24) | (v6 << 16) | (v7 << 8) | v4;
    LODWORD(v4) = v5 | (v6 << 8) | (v7 << 16) | (v4 << 24);
    if (*((unsigned char *)this + 32)) {
      unint64_t v4 = v4;
    }
    else {
      unint64_t v4 = v8;
    }
    *((void *)this + 3) = v2;
  }
  else
  {
    LogError("readLong", 968, "*** ERROR: _APPx::readLong - out-of-bounds: pos: %ld  size: %ld\n", v1, v3);
    return 0;
  }
  return v4;
}

void _APPx::readTag(_APPx *this)
{
}

void sub_18879A018(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1091C407990FA9CLL);
  _Unwind_Resume(a1);
}

uint64_t _APPx::processData(_APPx *this)
{
  *((_WORD *)this + 28) = (*(uint64_t (**)(_APPx *))(*(void *)this + 104))(this);
  uint64_t result = (*(uint64_t (**)(_APPx *))(*(void *)this + 104))(this);
  *((_DWORD *)this + 15) = result + 2;
  return result;
}

CFIndex _APPx::writeToStream(CFIndex this, CFWriteStreamRef stream)
{
  if (*(unsigned __int16 *)(this + 56) - 65505 <= 0xD
    && ((1 << (*(_WORD *)(this + 56) + 31)) & 0x2203) != 0)
  {
    return CFWriteStreamWrite(stream, (const UInt8 *)(*(void *)(this + 40) + *(void *)(this + 16)), *(unsigned int *)(this + 60));
  }
  return this;
}

uint64_t _APPx::setShouldAlignDataSize(uint64_t this)
{
  *(unsigned char *)(this + 74) = 1;
  return this;
}

uint64_t _APP3::_APP3(uint64_t a1, CFTypeRef cf, int a3)
{
  *(_WORD *)(a1 + 73) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 238092259;
  *(void *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 76) = 0;
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = &unk_1ED4E5848;
  *(void *)(a1 + 88) = 0;
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFDataGetTypeID())
    {
      *(void *)(a1 + 88) = CFRetain(cf);
      *(_DWORD *)(a1 + 60) = CFDataGetLength((CFDataRef)cf);
    }
  }
  *(_DWORD *)(a1 + 80) = a3;
  *(_WORD *)(a1 + 68) = 0;
  *(_WORD *)(a1 + 56) = -29;
  return a1;
}

void sub_18879A1E4(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ED4E58D8;
  _Unwind_Resume(a1);
}

void _APP3::~_APP3(_APP3 *this)
{
  *(void *)this = &unk_1ED4E5848;
  uint64_t v2 = (const void *)*((void *)this + 11);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 11) = 0;
  *(void *)this = &unk_1ED4E58D8;
}

{
  uint64_t vars8;

  _APP3::~_APP3(this);

  JUMPOUT(0x18C11C0E0);
}

const UInt8 *_APP3::writeToStream(_APP3 *this, __CFWriteStream *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  int v4 = *((_DWORD *)this + 15);
  if (v4) {
    unsigned int v5 = (v4 - 1) / 0xFDE8u + 1;
  }
  else {
    unsigned int v5 = 0;
  }
  int v16 = 0;
  uint64_t v15 = 0;
  *(_WORD *)buffer = -7169;
  int v6 = *((_DWORD *)this + 20);
  if (v6 == 2)
  {
    LOBYTE(v16) = 109;
    int v7 = "iOSCustom";
  }
  else
  {
    if (v6 != 1) {
      goto LABEL_9;
    }
    LOBYTE(v16) = 103;
    int v7 = "iOS_Debug";
  }
  uint64_t v15 = *(void *)v7;
LABEL_9:
  __int16 v18 = bswap32(v5) >> 16;
  uint64_t result = CFDataGetBytePtr(*((CFDataRef *)this + 11));
  if ((_WORD)v5)
  {
    __int16 v9 = result;
    uint64_t v10 = 0;
    uint64_t v11 = *((unsigned int *)this + 15);
    do
    {
      ++v10;
      if (v11 >= 65000) {
        CFIndex v12 = 65000;
      }
      else {
        CFIndex v12 = v11;
      }
      v11 -= v12;
      __int16 v14 = bswap32(v12 + 18) >> 16;
      __int16 v17 = bswap32(v10) >> 16;
      CFWriteStreamWrite(a2, buffer, 20);
      uint64_t result = (const UInt8 *)CFWriteStreamWrite(a2, v9, v12);
      v9 += v12;
    }
    while ((unsigned __int16)v5 != v10);
  }
  return result;
}

void _APPData::_APPData(_APPData *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *int v7 = &unk_1ED4E5E70;
}

void _APPData::~_APPData(_APPData *this)
{
  *(void *)this = &unk_1ED4E58D8;
}

{
  *(void *)this = &unk_1ED4E58D8;
  JUMPOUT(0x18C11C0E0);
}

CFIndex _APPData::writeToStream(_APPData *this, CFWriteStreamRef stream)
{
  if (*((unsigned char *)this + 74) && *((__int16 *)this + 28) == -37 && *((void *)this + 2) == 2)
  {
    unsigned int v4 = *((_DWORD *)this + 15);
    if (v4 < 0xFFF)
    {
      uint64_t v5 = 2;
    }
    else
    {
      CFWriteStreamWrite(stream, (const UInt8 *)(*((void *)this + 5) + 2), 4094);
      v4 -= 4094;
      uint64_t v5 = 4096;
    }
    int v6 = (const UInt8 *)(*((void *)this + 5) + v5);
    CFIndex v7 = v4;
  }
  else
  {
    int v6 = (const UInt8 *)(*((void *)this + 5) + *((void *)this + 2));
    CFIndex v7 = *((unsigned int *)this + 15);
  }

  return CFWriteStreamWrite(stream, v6, v7);
}

uint64_t _APPData::getImageDimension(_APPData *this, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result = (*(uint64_t (**)(_APPData *))(*(void *)this + 104))(this);
  __int16 v9 = result;
  if (result >> 8 >= 0xFF && (unsigned __int16)((unsigned __int16)(result + 48) >> 4) <= 0xFFEu)
  {
    do
    {
      uint64_t result = (*(uint64_t (**)(_APPData *))(*(void *)this + 104))(this);
      uint64_t v10 = *((void *)this + 3) + result;
      *((void *)this + 3) = v10 - 2;
      if (v10 > *((unsigned int *)this + 15)) {
        break;
      }
      uint64_t result = (*(uint64_t (**)(_APPData *))(*(void *)this + 104))(this);
      __int16 v9 = result;
      if (result >> 8 < 0xFF) {
        break;
      }
    }
    while ((unsigned __int16)((unsigned __int16)(result + 48) >> 4) < 0xFFFu);
  }
  if ((v9 & 0xFFF0) == 0xFFC0)
  {
    (*(void (**)(_APPData *))(*(void *)this + 104))(this);
    ++*((void *)this + 3);
    unsigned int v11 = (*(uint64_t (**)(_APPData *))(*(void *)this + 104))(this);
    if (a3) {
      *a3 = v11;
    }
    unsigned int v12 = (*(uint64_t (**)(_APPData *))(*(void *)this + 104))(this);
    if (a2) {
      *a2 = v12;
    }
    uint64_t result = (*(uint64_t (**)(_APPData *))(*(void *)this + 96))(this);
    if (a4) {
      *a4 = result;
    }
  }
  return result;
}

void _APP0::_APP0(_APP0 *this, int a2, char a3, int a4)
{
  _APPx::_APPx(this, 0, 0, 0, a2, a4, a3);
  *(void *)uint64_t v4 = &unk_1ED4E56F8;
  *(unsigned char *)(v4 + 80) = 0;
}

void _APP0::_APP0(_APP0 *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *(void *)uint64_t v7 = &unk_1ED4E56F8;
  *(unsigned char *)(v7 + 80) = 0;
}

void _APP0::~_APP0(_APP0 *this)
{
  *(void *)this = &unk_1ED4E58D8;
}

{
  *(void *)this = &unk_1ED4E58D8;
  JUMPOUT(0x18C11C0E0);
}

uint64_t _APP0::markerLength(_APP0 *this)
{
  return *((unsigned int *)this + 15);
}

uint64_t _APP0::writeToStream(uint64_t this, CFWriteStreamRef stream)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  CFIndex v3 = *(unsigned int *)(this + 60);
  if (v3 == 20 || *(unsigned char *)(this + 80))
  {
    *(_OWORD *)uint64_t v5 = xmmword_1889AB620;
    *(void *)&v5[14] = 0x46504D4100002C01;
    return CFWriteStreamWrite(stream, v5, 22);
  }
  else if (*(void *)(this + 48))
  {
    uint64_t v4 = (const UInt8 *)(*(void *)(this + 40) + *(void *)(this + 16));
    return CFWriteStreamWrite(stream, v4, v3);
  }
  return this;
}

void _APP1::_APP1(_APP1 *this, int a2, char a3)
{
  _APPx::_APPx(this, 0, 0, 0, a2, 0, a3);
  *(void *)uint64_t v3 = &unk_1ED4E5790;
  *(unsigned char *)(v3 + 68) = 1;
  *(_OWORD *)(v3 + 80) = 0u;
  *(_OWORD *)(v3 + 96) = 0u;
  *(_OWORD *)(v3 + 112) = 0u;
  *(_DWORD *)(v3 + 128) = 0;
  *(_WORD *)(v3 + 58) |= 1u;
  operator new();
}

void sub_18879A9E4(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ED4E58D8;
  _Unwind_Resume(a1);
}

void _APP1::_APP1(_APP1 *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  __int16 v7 = a5;
  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *(void *)uint64_t v8 = &unk_1ED4E5790;
  *(_WORD *)(v8 + 56) = v7;
  *(unsigned char *)(v8 + 68) = 1;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  *(_OWORD *)(v8 + 112) = 0u;
  *(_DWORD *)(v8 + 128) = 0;
  *(_WORD *)(v8 + 58) |= 1u;
}

void _APP1::~_APP1(_APP1 *this)
{
  *(void *)this = &unk_1ED4E5790;
  uint64_t v2 = *((void *)this + 10);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    *((void *)this + 10) = 0;
  }
  uint64_t v3 = *((void *)this + 11);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    *((void *)this + 11) = 0;
  }
  uint64_t v4 = *((void *)this + 12);
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    *((void *)this + 12) = 0;
  }
  uint64_t v5 = *((void *)this + 13);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    *((void *)this + 13) = 0;
  }
  uint64_t v6 = *((void *)this + 14);
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    *((void *)this + 14) = 0;
  }
  *(void *)this = &unk_1ED4E58D8;
}

{
  uint64_t vars8;

  _APP1::~_APP1(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t _APP1::mergeWithApp1(_APP1 *this, _APP1 *a2)
{
  uint64_t v4 = *((void *)this + 10);
  if (v4)
  {
    uint64_t v5 = (_TAGList *)*((void *)a2 + 10);
    if (v5) {
      _TAGList::mergeWithTagList(v4, v5);
    }
  }
  uint64_t v6 = *((void *)this + 11);
  if (v6)
  {
    __int16 v7 = (_TAGList *)*((void *)a2 + 11);
    if (v7) {
      _TAGList::mergeWithTagList(v6, v7);
    }
  }
  int v48 = 0;
  uint64_t v8 = (_TAGList *)*((void *)a2 + 12);
  if (v8)
  {
    uint64_t v9 = *((void *)this + 12);
    if (!v9) {
      operator new();
    }
    _TAGList::mergeWithTagList(v9, v8);
  }
  uint64_t v10 = (_TAGList *)*((void *)a2 + 13);
  if (v10)
  {
    uint64_t v11 = *((void *)this + 13);
    if (!v11) {
      operator new();
    }
    _TAGList::mergeWithTagList(v11, v10);
  }
  uint64_t result = *((void *)this + 14);
  if (result)
  {
    unsigned __int8 v13 = (_TAGList *)*((void *)a2 + 14);
    if (v13) {
      uint64_t result = _TAGList::mergeWithTagList(result, v13);
    }
  }
  *((_DWORD *)this + 15) = 0;
  uint64_t v14 = *((void *)this + 10);
  if (v14)
  {
    uint64_t v15 = *(uint64_t **)(v14 + 16);
    int v16 = *(uint64_t **)(v14 + 24);
    if (v15 == v16)
    {
      LODWORD(v14) = 0;
    }
    else
    {
      LODWORD(v14) = 0;
      do
      {
        uint64_t v17 = *v15++;
        unsigned int v18 = *(_DWORD *)(v17 + 68);
        if (v18 <= 4) {
          unsigned int v19 = 0;
        }
        else {
          unsigned int v19 = (v18 + 1) & 0xFFFFFFFE;
        }
        LODWORD(v14) = v19 + v14;
      }
      while (v15 != v16);
    }
    *((_DWORD *)this + 15) = v14;
  }
  uint64_t v20 = *((void *)this + 12);
  if (v20)
  {
    unsigned int v21 = *(uint64_t **)(v20 + 16);
    unsigned int v22 = *(uint64_t **)(v20 + 24);
    if (v21 == v22)
    {
      int v23 = 0;
    }
    else
    {
      int v23 = 0;
      do
      {
        uint64_t v24 = *v21++;
        unsigned int v25 = *(_DWORD *)(v24 + 68);
        if (v25 <= 4) {
          unsigned int v26 = 0;
        }
        else {
          unsigned int v26 = (v25 + 1) & 0xFFFFFFFE;
        }
        v23 += v26;
      }
      while (v21 != v22);
    }
    LODWORD(v14) = v14 + v23;
    *((_DWORD *)this + 15) = v14;
  }
  uint64_t v27 = *((void *)this + 11);
  if (v27)
  {
    int v28 = *(uint64_t **)(v27 + 16);
    unsigned int v29 = *(uint64_t **)(v27 + 24);
    if (v28 == v29)
    {
      int v30 = 0;
    }
    else
    {
      int v30 = 0;
      do
      {
        uint64_t v31 = *v28++;
        unsigned int v32 = *(_DWORD *)(v31 + 68);
        if (v32 <= 4) {
          unsigned int v33 = 0;
        }
        else {
          unsigned int v33 = (v32 + 1) & 0xFFFFFFFE;
        }
        v30 += v33;
      }
      while (v28 != v29);
    }
    LODWORD(v14) = v14 + v30;
    *((_DWORD *)this + 15) = v14;
  }
  uint64_t v34 = *((void *)this + 13);
  if (v34)
  {
    unsigned int v35 = *(uint64_t **)(v34 + 16);
    unsigned int v36 = *(uint64_t **)(v34 + 24);
    if (v35 == v36)
    {
      int v37 = 0;
    }
    else
    {
      int v37 = 0;
      do
      {
        uint64_t v38 = *v35++;
        unsigned int v39 = *(_DWORD *)(v38 + 68);
        if (v39 <= 4) {
          unsigned int v40 = 0;
        }
        else {
          unsigned int v40 = (v39 + 1) & 0xFFFFFFFE;
        }
        v37 += v40;
      }
      while (v35 != v36);
    }
    LODWORD(v14) = v14 + v37;
    *((_DWORD *)this + 15) = v14;
  }
  uint64_t v41 = *((void *)this + 14);
  if (v41)
  {
    unsigned int v42 = *(uint64_t **)(v41 + 16);
    int v43 = *(uint64_t **)(v41 + 24);
    if (v42 == v43)
    {
      int v44 = 0;
    }
    else
    {
      int v44 = 0;
      do
      {
        uint64_t v45 = *v42++;
        unsigned int v46 = *(_DWORD *)(v45 + 68);
        if (v46 <= 4) {
          unsigned int v47 = 0;
        }
        else {
          unsigned int v47 = (v46 + 1) & 0xFFFFFFFE;
        }
        v44 += v47;
      }
      while (v42 != v43);
    }
    *((_DWORD *)this + 15) = v14 + v44;
  }
  return result;
}

uint64_t _APP1::updateThumbnailInfo(uint64_t this, unsigned __int8 *a2, int a3)
{
  uint64_t v3 = *(void *)(this + 88);
  if (!v3) {
    operator new();
  }
  *(void *)(this + 120) = a2;
  *(_DWORD *)(this + 128) = a3;
  uint64_t v4 = *(void *)(v3 + 16);
  uint64_t v5 = *(void *)(v3 + 24);
  uint64_t v6 = v4;
  if (v4 != v5)
  {
    uint64_t v6 = v4;
    while (*(_WORD *)(*(void *)v6 + 40) != 513)
    {
      v6 += 8;
      if (v6 == v5) {
        goto LABEL_10;
      }
    }
  }
  if (v6 == v5 || !*(void *)v6) {
LABEL_10:
  }
    operator new();
  if (v4 == v5) {
    goto LABEL_15;
  }
  uint64_t v7 = v4;
  while (*(_WORD *)(*(void *)v7 + 40) != 514)
  {
    v7 += 8;
    if (v7 == v5) {
      goto LABEL_15;
    }
  }
  if (v7 == v5 || !*(void *)v7) {
LABEL_15:
  }
    operator new();
  if (v4 == v5) {
    goto LABEL_20;
  }
  uint64_t v8 = v4;
  while (*(_WORD *)(*(void *)v8 + 40) != 259)
  {
    v8 += 8;
    if (v8 == v5) {
      goto LABEL_20;
    }
  }
  if (v8 == v5 || !*(void *)v8) {
LABEL_20:
  }
    operator new();
  if (v4 == v5) {
    goto LABEL_25;
  }
  uint64_t v9 = v4;
  while (*(_WORD *)(*(void *)v9 + 40) != 282)
  {
    v9 += 8;
    if (v9 == v5) {
      goto LABEL_25;
    }
  }
  if (v9 == v5 || !*(void *)v9)
  {
LABEL_25:
    *(int8x8_t *)(this + 132) = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(*(unsigned char *)(this + 32) == 0), 0x1FuLL)), (int8x8_t)0x100000048000000, (int8x8_t)0x100000048);
    operator new();
  }
  if (v4 == v5) {
    goto LABEL_30;
  }
  uint64_t v10 = v4;
  while (*(_WORD *)(*(void *)v10 + 40) != 283)
  {
    v10 += 8;
    if (v10 == v5) {
      goto LABEL_30;
    }
  }
  if (v10 == v5 || !*(void *)v10)
  {
LABEL_30:
    *(int8x8_t *)(this + 140) = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(*(unsigned char *)(this + 32) == 0), 0x1FuLL)), (int8x8_t)0x100000048000000, (int8x8_t)0x100000048);
    operator new();
  }
  while (1)
  {
    if (v4 == v5) {
      goto LABEL_48;
    }
    if (*(_WORD *)(*(void *)v4 + 40) == 296) {
      break;
    }
    v4 += 8;
  }
  if (v4 == v5 || !*(void *)v4) {
LABEL_48:
  }
    operator new();
  return this;
}

void _APP1::getSubIFD(_APP1 *this, _TAG *a2, _TAGList *a3)
{
  (*(void (**)(_TAG *))(*(void *)a2 + 40))(a2);
  unsigned int v6 = (*(uint64_t (**)(_TAG *))(*(void *)a2 + 32))(a2);
  unsigned int v7 = v6;
  if (*((_DWORD *)this + 15) / 0xAu < v6)
  {
    LogError("getSubIFD", 1596, "- bad IFD count [%d entries]\n", v6);
    return;
  }
  if (v6)
  {
    int v8 = 0;
    char v9 = 1;
    while (1)
    {
      uint64_t v10 = (*(uint64_t (**)(_TAG *))(*(void *)a2 + 24))(a2);
      if (v10) {
        break;
      }
LABEL_23:
      char v9 = 0;
LABEL_24:
      if (++v8 >= v7) {
        return;
      }
    }
    uint64_t v11 = (unsigned __int16 *)v10;
    unsigned int v12 = *(_DWORD *)(v10 + 68);
    if (v12 <= 4) {
      unsigned int v13 = 0;
    }
    else {
      unsigned int v13 = (v12 + 1) & 0xFFFFFFFE;
    }
    if (v13 >= 5)
    {
      unsigned int v14 = bswap32(*(_DWORD *)(v10 + 64));
      if (*(unsigned char *)(v10 + 24)) {
        unsigned int v15 = *(_DWORD *)(v10 + 64);
      }
      else {
        unsigned int v15 = v14;
      }
      unint64_t v16 = *((unsigned int *)this + 15);
      unint64_t v17 = v15 + *((_DWORD *)this + 16);
      unint64_t v18 = *((void *)this + 2);
      if (v18 > v17)
      {
        LODWORD(v16) = v18 + v16;
LABEL_16:
        LogError("getSubIFD", 1616, ": Skipping tag '%04X', dataOffset (%08X) with size_t length = %d is outside the bounds of the APP1 marker (%08X - %08X)\n", *(unsigned __int16 *)(v10 + 40), v17, v13, *((void *)this + 2), v16);
LABEL_22:
        (*(void (**)(unsigned __int16 *))(*(void *)v11 + 8))(v11);
        goto LABEL_23;
      }
      v16 += v18;
      if (v16 < v17 + v13) {
        goto LABEL_16;
      }
    }
    if (v9)
    {
      uint64_t v19 = *((void *)a3 + 2);
      uint64_t v20 = *((void *)a3 + 3);
      if (v19 != v20)
      {
        while (*(unsigned __int16 *)(*(void *)v19 + 40) != *(unsigned __int16 *)(v10 + 40))
        {
          v19 += 8;
          if (v19 == v20) {
            goto LABEL_29;
          }
        }
      }
      if (v19 == v20 || !*(void *)v19)
      {
LABEL_29:
        *(void *)&double v21 = _TAGList::insertTag(a3, (_TAG *)v10).n128_u64[0];
        int v22 = v11[20];
        switch(v22)
        {
          case 40965:
            if (!*((void *)this + 14)) {
              operator new();
            }
            break;
          case 34853:
            LogError("getSubIFD", 1645, "*** ERROR: second GPS Info Pointer???\n", v21);
            break;
          case 34665:
            LogError("getSubIFD", 1641, "*** ERROR: second Exif IFD Pointer???\n", v21);
            break;
        }
      }
      else
      {
        _cg_jpeg_mem_term("getSubIFD", 1632, "*** skipping tag -- already added\n");
      }
      char v9 = 1;
      goto LABEL_24;
    }
    goto LABEL_22;
  }
}

const char *_APP1::processAPP1(_APP1 *this, uint64_t a2)
{
  *((_WORD *)this + 28) = (*(uint64_t (**)(_APP1 *))(*(void *)this + 104))(this);
  int v4 = (*(uint64_t (**)(_APP1 *))(*(void *)this + 104))(this);
  uint64_t v5 = *((void *)this + 2) + a2;
  *((void *)this + 3) = v5;
  *((_DWORD *)this + 15) = v4 + 2;
  *((_DWORD *)this + 16) = v5;
  if ((*(unsigned int (**)(_APP1 *))(*(void *)this + 104))(this) == 18761) {
    *((unsigned char *)this + 32) = 1;
  }
  *((void *)this + 3) += 2;
  uint64_t v6 = (*(uint64_t (**)(_APP1 *))(*(void *)this + 112))(this);
  uint64_t v7 = *((unsigned int *)this + 16);
  unint64_t v8 = *((void *)this + 2) + *((unsigned int *)this + 15);
  uint64_t v9 = (v7 + v6);
  if (!__CFADD__(v7, v6) && v8 >= v9)
  {
    *((void *)this + 3) = v9;
    (*(void (**)(_APP1 *))(*(void *)this + 104))(this);
    uint64_t v11 = 0;
    operator new();
  }
  return LogError("processAPP1", 1692, "*** ERROR: bogus ifdOffset = %p + %p, marker range = %p - %p\n", v7, v6, *((void *)this + 2), v8);
}

const char *_APP1::processData(_APP1 *this)
{
  return _APP1::processAPP1(this, 10);
}

uint64_t _APP1::markerLength(_APP1 *this)
{
  uint64_t v1 = *((void *)this + 10);
  if (v1)
  {
    uint64_t v3 = *(uint64_t **)(v1 + 16);
    uint64_t v2 = *(uint64_t **)(v1 + 24);
    int v4 = 12 * (unsigned __int16)((v2 - v3) >> 3) + 6;
    if (v2 == v3)
    {
      int v5 = 0;
    }
    else
    {
      int v5 = 0;
      do
      {
        uint64_t v6 = *v3++;
        unsigned int v7 = *(_DWORD *)(v6 + 68);
        if (v7 <= 4) {
          unsigned int v8 = 0;
        }
        else {
          unsigned int v8 = (v7 + 1) & 0xFFFFFFFE;
        }
        v5 += v8;
      }
      while (v3 != v2);
    }
    int v9 = v4 + v5;
  }
  else
  {
    int v9 = 0;
  }
  uint64_t v10 = *((void *)this + 12);
  if (v10)
  {
    uint64_t v13 = v10 + 16;
    unsigned int v12 = *(uint64_t **)(v10 + 16);
    uint64_t v11 = *(uint64_t **)(v13 + 8);
    int v14 = 12 * (unsigned __int16)((v11 - v12) >> 3);
    if (v11 == v12)
    {
      int v15 = 0;
    }
    else
    {
      int v15 = 0;
      do
      {
        uint64_t v16 = *v12++;
        unsigned int v17 = *(_DWORD *)(v16 + 68);
        if (v17 <= 4) {
          unsigned int v18 = 0;
        }
        else {
          unsigned int v18 = (v17 + 1) & 0xFFFFFFFE;
        }
        v15 += v18;
      }
      while (v12 != v11);
    }
    v9 += v14 + v15 + 6;
  }
  uint64_t v19 = *((void *)this + 11);
  if (v19)
  {
    uint64_t v22 = v19 + 16;
    double v21 = *(uint64_t **)(v19 + 16);
    uint64_t v20 = *(uint64_t **)(v22 + 8);
    int v23 = 12 * (unsigned __int16)((v20 - v21) >> 3);
    if (v20 == v21)
    {
      int v24 = 0;
    }
    else
    {
      int v24 = 0;
      do
      {
        uint64_t v25 = *v21++;
        unsigned int v26 = *(_DWORD *)(v25 + 68);
        if (v26 <= 4) {
          unsigned int v27 = 0;
        }
        else {
          unsigned int v27 = (v26 + 1) & 0xFFFFFFFE;
        }
        v24 += v27;
      }
      while (v21 != v20);
    }
    v9 += v23 + v24 + 6;
  }
  uint64_t v28 = *((void *)this + 13);
  if (v28)
  {
    uint64_t v31 = v28 + 16;
    int v30 = *(uint64_t **)(v28 + 16);
    unsigned int v29 = *(uint64_t **)(v31 + 8);
    int v32 = 12 * (unsigned __int16)((v29 - v30) >> 3);
    if (v29 == v30)
    {
      int v33 = 0;
    }
    else
    {
      int v33 = 0;
      do
      {
        uint64_t v34 = *v30++;
        unsigned int v35 = *(_DWORD *)(v34 + 68);
        if (v35 <= 4) {
          unsigned int v36 = 0;
        }
        else {
          unsigned int v36 = (v35 + 1) & 0xFFFFFFFE;
        }
        v33 += v36;
      }
      while (v30 != v29);
    }
    v9 += v32 + v33 + 6;
  }
  uint64_t v37 = *((void *)this + 14);
  if (v37)
  {
    uint64_t v40 = v37 + 16;
    unsigned int v39 = *(uint64_t **)(v37 + 16);
    uint64_t v38 = *(uint64_t **)(v40 + 8);
    int v41 = 12 * (unsigned __int16)((v38 - v39) >> 3);
    if (v38 == v39)
    {
      int v42 = 0;
    }
    else
    {
      int v42 = 0;
      do
      {
        uint64_t v43 = *v39++;
        unsigned int v44 = *(_DWORD *)(v43 + 68);
        if (v44 <= 4) {
          unsigned int v45 = 0;
        }
        else {
          unsigned int v45 = (v44 + 1) & 0xFFFFFFFE;
        }
        v42 += v45;
      }
      while (v39 != v38);
    }
    v9 += v41 + v42 + 6;
  }
  if (v9) {
    return (v9 + 18);
  }
  else {
    return 0;
  }
}

uint64_t _TAG::priority(_TAG *this)
{
  int v1 = *((unsigned __int16 *)this + 20);
  uint64_t result = 2;
  if (v1 <= 37384)
  {
    if (v1 == 33434) {
      return 1;
    }
    if (v1 != 36864 && v1 != 37121) {
      return 0;
    }
  }
  else if ((v1 - 40960) >= 4)
  {
    return (v1 - 41986) <= 4 && ((1 << (v1 - 2)) & 0x13) != 0 || v1 == 37385;
  }
  return result;
}

uint64_t _APP1::pruneContent(_APP1 *this, uint64_t a2)
{
  uint64_t v3 = *((void *)this + 12);
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 + 16);
    int v5 = *(_TAG ***)(v3 + 24);
    unint64_t v6 = 126 - 2 * __clz(((uint64_t)v5 - v4) >> 3);
    if (v5 == (_TAG **)v4) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = v6;
    }
    std::__introsort<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **,false>(v4, v5, v7, 1);
    if (a2 >= 0xFFF8)
    {
      do
      {
        uint64_t v8 = *(void *)(v3 + 16);
        uint64_t v9 = *(void *)(v3 + 24) - v8;
        if ((v9 & 0x7FFF8) == 0) {
          break;
        }
        uint64_t v10 = *(void *)(v8 + 8 * (unsigned __int16)((v9 >> 3) - 1));
        unsigned int v11 = *(_DWORD *)(v10 + 68);
        unsigned int v12 = v11 <= 4 ? 0 : (v11 + 1) & 0xFFFFFFFE;
        a2 = a2 - v12;
        _TAGList::removeTag(v3, (unsigned __int16 *)v10);
      }
      while (a2 > 0xFFF7);
    }
    uint64_t v13 = *(void *)(v3 + 16);
    int v14 = *(uint64_t **)(v3 + 24);
    unint64_t v15 = 126 - 2 * __clz(((uint64_t)v14 - v13) >> 3);
    if (v14 == (uint64_t *)v13) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = v15;
    }
    std::__introsort<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **,false>(v13, v14, v16, 1);
  }
  return a2;
}

void _APP1::writeToStream(_APP1 *this, __CFWriteStream *a2)
{
  uint64_t v3 = *((void *)this + 10);
  if (!v3)
  {
    unsigned int v7 = 0;
    goto LABEL_10;
  }
  uint64_t v6 = v3 + 16;
  int v5 = *(uint64_t **)(v3 + 16);
  uint64_t v4 = *(uint64_t **)(v6 + 8);
  unsigned int v7 = 12 * (unsigned __int16)((v4 - v5) >> 3) + 6;
  if (v4 == v5)
  {
LABEL_10:
    unsigned int v8 = 0;
    goto LABEL_11;
  }
  unsigned int v8 = 0;
  do
  {
    uint64_t v9 = *v5++;
    unsigned int v10 = *(_DWORD *)(v9 + 68);
    if (v10 <= 4) {
      unsigned int v11 = 0;
    }
    else {
      unsigned int v11 = (v10 + 1) & 0xFFFFFFFE;
    }
    v8 += v11;
  }
  while (v5 != v4);
LABEL_11:
  uint64_t v12 = *((void *)this + 11);
  if (!v12)
  {
    int v21 = 0;
LABEL_22:
    int v22 = 0;
LABEL_23:
    int v23 = 0;
    goto LABEL_31;
  }
  uint64_t v13 = (unsigned __int8 *)*((void *)this + 15);
  if (!v13)
  {
    int v21 = 0;
    LODWORD(v12) = 0;
    goto LABEL_22;
  }
  unint64_t v15 = *(uint64_t **)(v12 + 16);
  int v14 = *(uint64_t **)(v12 + 24);
  int v16 = (unsigned __int16)((v14 - v15) >> 3);
  if (v14 == v15)
  {
    int v17 = 0;
  }
  else
  {
    int v17 = 0;
    do
    {
      uint64_t v18 = *v15++;
      unsigned int v19 = *(_DWORD *)(v18 + 68);
      if (v19 <= 4) {
        unsigned int v20 = 0;
      }
      else {
        unsigned int v20 = (v19 + 1) & 0xFFFFFFFE;
      }
      v17 += v20;
    }
    while (v15 != v14);
  }
  int v21 = 12 * v16 + 6;
  int v24 = *((_DWORD *)this + 32);
  LODWORD(v12) = v24 + v17;
  if (__PAIR64__(v13[1], *v13) == 0xD8000000FFLL)
  {
    int v22 = 0;
  }
  else
  {
    LODWORD(v12) = v12 + 2;
    int v22 = 1;
  }
  if (v13[v24 - 2] == 255 && v13[v24 - 1] == 217) {
    goto LABEL_23;
  }
  LODWORD(v12) = v12 + 2;
  int v23 = 1;
LABEL_31:
  uint64_t v25 = *((void *)this + 12);
  if (v25)
  {
    unsigned int v27 = *(uint64_t **)(v25 + 16);
    unsigned int v26 = *(uint64_t **)(v25 + 24);
    unsigned int v28 = 12 * (unsigned __int16)((v26 - v27) >> 3) + 6;
    if (v26 == v27)
    {
      LODWORD(v25) = 0;
    }
    else
    {
      LODWORD(v25) = 0;
      do
      {
        uint64_t v29 = *v27++;
        unsigned int v30 = *(_DWORD *)(v29 + 68);
        if (v30 <= 4) {
          unsigned int v31 = 0;
        }
        else {
          unsigned int v31 = (v30 + 1) & 0xFFFFFFFE;
        }
        LODWORD(v25) = v31 + v25;
      }
      while (v27 != v26);
    }
  }
  else
  {
    unsigned int v28 = 0;
  }
  uint64_t v32 = *((void *)this + 13);
  if (!v32)
  {
    int v36 = 0;
    goto LABEL_50;
  }
  uint64_t v35 = v32 + 16;
  uint64_t v34 = *(uint64_t **)(v32 + 16);
  int v33 = *(uint64_t **)(v35 + 8);
  int v36 = 12 * (unsigned __int16)((v33 - v34) >> 3) + 6;
  if (v33 == v34)
  {
LABEL_50:
    int v37 = 0;
    goto LABEL_51;
  }
  int v37 = 0;
  do
  {
    uint64_t v38 = *v34++;
    unsigned int v39 = *(_DWORD *)(v38 + 68);
    if (v39 <= 4) {
      unsigned int v40 = 0;
    }
    else {
      unsigned int v40 = (v39 + 1) & 0xFFFFFFFE;
    }
    v37 += v40;
  }
  while (v34 != v33);
LABEL_51:
  uint64_t v41 = *((void *)this + 14);
  if (v41)
  {
    uint64_t v44 = v41 + 16;
    uint64_t v43 = *(uint64_t **)(v41 + 16);
    int v42 = *(uint64_t **)(v44 + 8);
    int v45 = 12 * (unsigned __int16)((v42 - v43) >> 3) + 6;
    if (v42 != v43)
    {
      int v46 = 0;
      do
      {
        uint64_t v47 = *v43++;
        unsigned int v48 = *(_DWORD *)(v47 + 68);
        if (v48 <= 4) {
          unsigned int v49 = 0;
        }
        else {
          unsigned int v49 = (v48 + 1) & 0xFFFFFFFE;
        }
        v46 += v49;
      }
      while (v43 != v42);
      if (v8) {
        goto LABEL_66;
      }
      goto LABEL_62;
    }
  }
  else
  {
    int v45 = 0;
  }
  int v46 = 0;
  if (v8) {
    goto LABEL_66;
  }
LABEL_62:
  if (!v12 && !v25 && !v37 && !v46) {
    return;
  }
LABEL_66:
  int v143 = v23;
  int v144 = v22;
  int v145 = v21;
  int v146 = v36;
  int v147 = v45;
  int v50 = v7 + v8 + v21 + v12 + v28 + v25 + v36 + v37 + v45 + v46;
  unsigned int v51 = v50 + 16;
  unsigned int v52 = ((v50 + 4111) & 0xFFFFF000) - 4;
  if (*((unsigned char *)this + 74)) {
    uint64_t v53 = v52;
  }
  else {
    uint64_t v53 = v51;
  }
  unsigned int v54 = malloc_type_calloc((v53 + 8), 1uLL, 0x379CFB8CuLL);
  if ((v53 + 8) >= 0x10000)
  {
    unsigned int v55 = _APP1::pruneContent(this, v53);
    if (v55 >= 0xFFF8)
    {
      LogError("writeToStream", 2076, "*** ERROR: EXIF Data exceeds 64K limit, too big after truncation. Dropping 'APP1' marker.\n");
      free(v54);
      return;
    }
    LODWORD(v53) = v55;
    unsigned int v28 = 12
        * (unsigned __int16)((*(_DWORD *)(*((void *)this + 12) + 24)
                                          - *(_DWORD *)(*((void *)this + 12) + 16)) >> 3)
        + 6;
  }
  __int16 v56 = *((_WORD *)this + 28);
  *unsigned int v54 = HIBYTE(v56);
  v54[1] = v56;
  strcpy(v54 + 4, "Exif");
  uint64_t v149 = 0;
  if (*((unsigned char *)this + 32)) {
    unsigned int v57 = 18761;
  }
  else {
    unsigned int v57 = 19789;
  }
  *((_WORD *)v54 + 5) = __rev16(v57);
  int v58 = v54 + 10;
  if (*((unsigned char *)this + 32)) {
    char v59 = 42;
  }
  else {
    char v59 = 0;
  }
  if (*((unsigned char *)this + 32)) {
    char v60 = 0;
  }
  else {
    char v60 = 42;
  }
  v54[12] = v59;
  v54[13] = v60;
  BOOL v61 = *((unsigned char *)this + 32) == 0;
  v54[14] = 8 * *((unsigned char *)this + 32);
  *(_WORD *)(v54 + 15) = 0;
  v54[17] = 8 * v61;
  uint64_t v62 = *((void *)this + 10);
  uint64_t v63 = (uint64_t)&v54[v7 + 18];
  if (v62 && (unint64_t v64 = *(void *)(v62 + 24) - *(void *)(v62 + 16), (unsigned __int16)(v64 >> 3)))
  {
    unint64_t v65 = v64 >> 3;
    if (*((unsigned char *)this + 32)) {
      char v66 = v65;
    }
    else {
      char v66 = BYTE1(v65);
    }
    if (*((unsigned char *)this + 32)) {
      LOBYTE(v65) = BYTE1(v65);
    }
    v54[18] = v66;
    v54[19] = v65;
    (*(void (**)(void, unsigned char *, unsigned char *, uint64_t, char *, uint64_t *, void))(**((void **)this + 10)
                                                                                         + 16))(*((void *)this + 10), v54 + 10, v54 + 20, v63, (char *)&v149 + 4, &v149, *((unsigned __int8 *)this + 32));
    unsigned int v67 = &v54[HIDWORD(v149) + 20];
  }
  else
  {
    unsigned int v67 = 0;
  }
  int32x4_t v68 = (unsigned char *)(v63 + v8);
  uint64_t v69 = *((void *)this + 12);
  if (v69)
  {
    uint64_t v70 = *((void *)this + 10);
    if (v70)
    {
      int16x8_t v71 = *(uint64_t **)(v70 + 16);
      int v72 = *(uint64_t **)(v70 + 24);
      if (v71 != v72)
      {
        while (*(unsigned __int16 *)(*v71 + 40) != 34665)
        {
          if (++v71 == v72) {
            goto LABEL_107;
          }
        }
      }
      if (v71 == v72) {
        goto LABEL_107;
      }
      uint64_t v73 = *v71;
      if (!*v71) {
        goto LABEL_107;
      }
      unsigned int v74 = v68 - v58;
      uint64_t v75 = *(void *)(v73 + 48);
      unsigned int v76 = *(_DWORD *)(v75 + 8);
      if (*((unsigned char *)this + 32))
      {
        if (v76 != v74)
        {
          unsigned int v77 = HIWORD(v74);
          unsigned int v78 = v74 >> 8;
          LOBYTE(v79) = (_BYTE)v68 - v58;
          v74 >>= 24;
LABEL_106:
          *(unsigned char *)(v75 + 8) = v79;
          *(unsigned char *)(v75 + 9) = v78;
          *(unsigned char *)(v75 + 10) = v77;
          *(unsigned char *)(v75 + 11) = v74;
          uint64_t v69 = *((void *)this + 12);
        }
      }
      else if (bswap32(v76) != v74)
      {
        unsigned int v78 = HIWORD(v74);
        unsigned int v79 = HIBYTE(v74);
        unsigned int v77 = v74 >> 8;
        goto LABEL_106;
      }
LABEL_107:
      uint64_t v80 = (*(void *)(v69 + 24) - *(void *)(v69 + 16)) >> 3;
      uint64_t v81 = &v68[v28];
      if (*((unsigned char *)this + 32)) {
        char v82 = v80;
      }
      else {
        char v82 = BYTE1(v80);
      }
      if (*((unsigned char *)this + 32)) {
        LOBYTE(v80) = BYTE1(v80);
      }
      *int32x4_t v68 = v82;
      v68[1] = v80;
      (*(void (**)(void, unsigned char *, unsigned char *, unsigned char *, char *, uint64_t *, void))(**((void **)this + 12)
                                                                                           + 16))(*((void *)this + 12), v54 + 10, v68 + 2, v81, (char *)&v149 + 4, &v149, *((unsigned __int8 *)this + 32));
      int32x4_t v68 = &v81[v149];
    }
  }
  uint64_t v83 = *((void *)this + 13);
  if (!v83) {
    goto LABEL_133;
  }
  uint64_t v84 = *((void *)this + 10);
  if (!v84) {
    goto LABEL_133;
  }
  int v85 = *(uint64_t **)(v84 + 16);
  unint64_t v86 = *(uint64_t **)(v84 + 24);
  if (v85 != v86)
  {
    while (*(unsigned __int16 *)(*v85 + 40) != 34853)
    {
      if (++v85 == v86) {
        goto LABEL_127;
      }
    }
  }
  if (v85 != v86)
  {
    uint64_t v87 = *v85;
    if (*v85)
    {
      unsigned int v88 = v68 - v58;
      uint64_t v89 = *(void *)(v87 + 48);
      unsigned int v90 = *(_DWORD *)(v89 + 8);
      if (*((unsigned char *)this + 32))
      {
        if (v90 != v88)
        {
          unsigned int v91 = HIWORD(v88);
          unsigned int v92 = v88 >> 8;
          LOBYTE(v93) = (_BYTE)v68 - v58;
          v88 >>= 24;
LABEL_126:
          *(unsigned char *)(v89 + 8) = v93;
          *(unsigned char *)(v89 + 9) = v92;
          *(unsigned char *)(v89 + 10) = v91;
          *(unsigned char *)(v89 + 11) = v88;
          uint64_t v83 = *((void *)this + 13);
        }
      }
      else if (bswap32(v90) != v88)
      {
        unsigned int v92 = HIWORD(v88);
        unsigned int v93 = HIBYTE(v88);
        unsigned int v91 = v88 >> 8;
        goto LABEL_126;
      }
    }
  }
LABEL_127:
  uint64_t v94 = (*(void *)(v83 + 24) - *(void *)(v83 + 16)) >> 3;
  v95 = &v68[v146];
  if (*((unsigned char *)this + 32)) {
    char v96 = v94;
  }
  else {
    char v96 = BYTE1(v94);
  }
  if (*((unsigned char *)this + 32)) {
    LOBYTE(v94) = BYTE1(v94);
  }
  *int32x4_t v68 = v96;
  v68[1] = v94;
  (*(void (**)(void, unsigned char *, unsigned char *, unsigned char *, char *, uint64_t *, void))(**((void **)this + 13) + 16))(*((void *)this + 13), v54 + 10, v68 + 2, v95, (char *)&v149 + 4, &v149, *((unsigned __int8 *)this + 32));
  int32x4_t v68 = &v95[v37];
LABEL_133:
  uint64_t v97 = *((void *)this + 14);
  if (v97)
  {
    uint64_t v98 = *((void *)this + 12);
    if (v98)
    {
      v99 = *(uint64_t **)(v98 + 16);
      v100 = *(uint64_t **)(v98 + 24);
      if (v99 != v100)
      {
        while (*(unsigned __int16 *)(*v99 + 40) != 40965)
        {
          if (++v99 == v100) {
            goto LABEL_147;
          }
        }
      }
      if (v99 == v100) {
        goto LABEL_147;
      }
      uint64_t v101 = *v99;
      if (!*v99) {
        goto LABEL_147;
      }
      unsigned int v102 = v68 - v58;
      uint64_t v103 = *(void *)(v101 + 48);
      unsigned int v104 = *(_DWORD *)(v103 + 8);
      if (*((unsigned char *)this + 32))
      {
        if (v104 != v102)
        {
          unsigned int v105 = HIWORD(v102);
          unsigned int v106 = v102 >> 8;
          LOBYTE(v107) = (_BYTE)v68 - v58;
          v102 >>= 24;
LABEL_146:
          *(unsigned char *)(v103 + 8) = v107;
          *(unsigned char *)(v103 + 9) = v106;
          *(unsigned char *)(v103 + 10) = v105;
          *(unsigned char *)(v103 + 11) = v102;
          uint64_t v97 = *((void *)this + 14);
        }
      }
      else if (bswap32(v104) != v102)
      {
        unsigned int v106 = HIWORD(v102);
        unsigned int v107 = HIBYTE(v102);
        unsigned int v105 = v102 >> 8;
        goto LABEL_146;
      }
LABEL_147:
      uint64_t v108 = (*(void *)(v97 + 24) - *(void *)(v97 + 16)) >> 3;
      v109 = &v68[v147];
      if (*((unsigned char *)this + 32)) {
        char v110 = v108;
      }
      else {
        char v110 = BYTE1(v108);
      }
      if (*((unsigned char *)this + 32)) {
        LOBYTE(v108) = BYTE1(v108);
      }
      *int32x4_t v68 = v110;
      v68[1] = v108;
      (*(void (**)(void, unsigned char *, unsigned char *, unsigned char *, char *, uint64_t *, void))(**((void **)this + 14)
                                                                                           + 16))(*((void *)this + 14), v54 + 10, v68 + 2, v109, (char *)&v149 + 4, &v149, *((unsigned __int8 *)this + 32));
      int32x4_t v68 = &v109[v46];
    }
  }
  if (*((void *)this + 11) && *((void *)this + 15) && v67)
  {
    unsigned int v111 = v68 - v58;
    unsigned int v112 = (v68 - v58) >> 16;
    if (*((unsigned char *)this + 32))
    {
      unsigned int v113 = v111 >> 8;
      LOBYTE(v114) = (_BYTE)v68 - v58;
      v111 >>= 24;
    }
    else
    {
      unsigned int v114 = HIBYTE(v111);
      unsigned int v113 = HIWORD(v111);
      unsigned int v112 = v111 >> 8;
    }
    unsigned char *v67 = v114;
    v67[1] = v113;
    v67[2] = v112;
    v67[3] = v111;
    uint64_t v115 = (*(void *)(*((void *)this + 11) + 24) - *(void *)(*((void *)this + 11) + 16)) >> 3;
    v116 = &v68[v145];
    if (*((unsigned char *)this + 32)) {
      char v117 = (*(void *)(*((void *)this + 11) + 24) - *(void *)(*((void *)this + 11) + 16)) >> 3;
    }
    else {
      char v117 = (*(void *)(*((void *)this + 11) + 24) - *(void *)(*((void *)this + 11) + 16)) >> 11;
    }
    if (*((unsigned char *)this + 32)) {
      LOBYTE(v115) = (*(void *)(*((void *)this + 11) + 24) - *(void *)(*((void *)this + 11) + 16)) >> 11;
    }
    *int32x4_t v68 = v117;
    v68[1] = v115;
    (*(void (**)(void, unsigned char *, unsigned char *, unsigned char *, char *, uint64_t *, void))(**((void **)this + 11)
                                                                                         + 16))(*((void *)this + 11), v54 + 10, v68 + 2, v116, (char *)&v149 + 4, &v149, *((unsigned __int8 *)this + 32));
    v118 = &v116[v149];
    uint64_t v119 = *((void *)this + 11);
    v120 = *(uint64_t **)(v119 + 16);
    v121 = *(uint64_t **)(v119 + 24);
    v122 = v120;
    if (v120 != v121)
    {
      v122 = v120;
      while (*(_WORD *)(*v122 + 40) != 513)
      {
        if (++v122 == v121) {
          goto LABEL_174;
        }
      }
    }
    if (v122 == v121 || (uint64_t v123 = *v122) == 0)
    {
LABEL_174:
      int v128 = v143;
      int v127 = v144;
      goto LABEL_175;
    }
    unsigned int v124 = v118 - v58;
    uint64_t v125 = *(void *)(v123 + 48);
    unsigned int v126 = *(_DWORD *)(v125 + 8);
    if (*((unsigned char *)this + 32))
    {
      int v128 = v143;
      int v127 = v144;
      if (v126 == v124) {
        goto LABEL_175;
      }
      unsigned int v129 = HIWORD(v124);
      unsigned int v130 = v124 >> 8;
      LOBYTE(v131) = (_BYTE)v118 - v58;
      v124 >>= 24;
    }
    else
    {
      int v128 = v143;
      int v127 = v144;
      if (bswap32(v126) == v124) {
        goto LABEL_175;
      }
      unsigned int v130 = HIWORD(v124);
      unsigned int v131 = HIBYTE(v124);
      unsigned int v129 = v124 >> 8;
    }
    *(unsigned char *)(v125 + 8) = v131;
    *(unsigned char *)(v125 + 9) = v130;
    *(unsigned char *)(v125 + 10) = v129;
    *(unsigned char *)(v125 + 11) = v124;
    uint64_t v139 = *((void *)this + 11);
    v120 = *(uint64_t **)(v139 + 16);
    v121 = *(uint64_t **)(v139 + 24);
LABEL_175:
    while (v120 != v121)
    {
      uint64_t v132 = *v120;
      if (*(_WORD *)(*v120 + 40) == 514)
      {
        if (v120 != v121 && v132)
        {
          unsigned int v133 = *((_DWORD *)this + 32);
          if (v127) {
            v133 += 2;
          }
          uint64_t v134 = *(void *)(v132 + 48);
          unsigned int v135 = *(_DWORD *)(v134 + 8);
          if (*((unsigned char *)this + 32))
          {
            if (v135 == v133) {
              break;
            }
            unsigned int v136 = HIWORD(v133);
            unsigned int v137 = v133 >> 8;
            LOBYTE(v138) = v133;
            v133 >>= 24;
          }
          else
          {
            if (bswap32(v135) == v133) {
              break;
            }
            unsigned int v137 = HIWORD(v133);
            unsigned int v138 = HIBYTE(v133);
            unsigned int v136 = v133 >> 8;
          }
          *(unsigned char *)(v134 + 8) = v138;
          *(unsigned char *)(v134 + 9) = v137;
          *(unsigned char *)(v134 + 10) = v136;
          *(unsigned char *)(v134 + 11) = v133;
        }
        break;
      }
      ++v120;
    }
    if (v127) {
      *v118++ = -9985;
    }
    memcpy(v118, *((const void **)this + 15), *((unsigned int *)this + 32));
    v140 = (char *)v118 + *((unsigned int *)this + 32);
    if (v128)
    {
      if (*((unsigned char *)this + 32)) {
        char v141 = -39;
      }
      else {
        char v141 = -1;
      }
      if (*((unsigned char *)this + 32)) {
        char v142 = -1;
      }
      else {
        char v142 = -39;
      }
      char *v140 = v141;
      v140[1] = v142;
      v140 += 2;
    }
    *(_WORD *)v140 = 0;
  }
  *((_WORD *)v54 + 1) = bswap32(v53 + 2) >> 16;
  CFWriteStreamWrite(a2, v54, (v53 + 4));
  free(v54);
}

void *_APP1::addMissingIFDTags(void *this)
{
  uint64_t v1 = this[10];
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 16);
    uint64_t v3 = *(void *)(v1 + 24);
    uint64_t v4 = v2;
    if (v2 != v3)
    {
      uint64_t v4 = v2;
      while (*(_WORD *)(*(void *)v4 + 40) != 282)
      {
        v4 += 8;
        if (v4 == v3) {
          goto LABEL_9;
        }
      }
    }
    if (v4 == v3 || !*(void *)v4) {
LABEL_9:
    }
      newRationalTag();
    if (v2 == v3) {
      goto LABEL_17;
    }
    uint64_t v5 = v2;
    while (*(_WORD *)(*(void *)v5 + 40) != 283)
    {
      v5 += 8;
      if (v5 == v3) {
        goto LABEL_17;
      }
    }
    if (v5 == v3 || !*(void *)v5) {
LABEL_17:
    }
      newRationalTag();
    if (v2 == v3) {
      goto LABEL_25;
    }
    uint64_t v6 = v2;
    while (*(_WORD *)(*(void *)v6 + 40) != 296)
    {
      v6 += 8;
      if (v6 == v3) {
        goto LABEL_25;
      }
    }
    if (v6 == v3 || !*(void *)v6) {
LABEL_25:
    }
      operator new();
    while (1)
    {
      if (v2 == v3) {
        goto LABEL_31;
      }
      if (*(_WORD *)(*(void *)v2 + 40) == 531) {
        break;
      }
      v2 += 8;
    }
    if (v2 == v3 || !*(void *)v2) {
LABEL_31:
    }
      operator new();
  }
  uint64_t v7 = this[12];
  if (!v7) {
    operator new();
  }
  uint64_t v8 = this[10];
  if (v8)
  {
    uint64_t v9 = *(void *)(v8 + 16);
    uint64_t v10 = *(void *)(v8 + 24);
    if (v9 != v10)
    {
      while (*(unsigned __int16 *)(*(void *)v9 + 40) != 34665)
      {
        v9 += 8;
        if (v9 == v10) {
          goto LABEL_41;
        }
      }
    }
    if (v9 == v10 || !*(void *)v9) {
LABEL_41:
    }
      operator new();
    uint64_t v11 = *(void *)(v7 + 16);
    uint64_t v12 = *(void *)(v7 + 24);
    uint64_t v13 = v11;
    if (v11 != v12)
    {
      uint64_t v13 = v11;
      while (*(__int16 *)(*(void *)v13 + 40) != -28672)
      {
        v13 += 8;
        if (v13 == v12) {
          goto LABEL_49;
        }
      }
    }
    if (v13 == v12 || !*(void *)v13) {
LABEL_49:
    }
      operator new();
    if (v11 == v12) {
      goto LABEL_57;
    }
    uint64_t v14 = v11;
    while (*(unsigned __int16 *)(*(void *)v14 + 40) != 37121)
    {
      v14 += 8;
      if (v14 == v12) {
        goto LABEL_57;
      }
    }
    if (v14 == v12 || !*(void *)v14) {
LABEL_57:
    }
      operator new();
    if (v11 == v12) {
      goto LABEL_65;
    }
    uint64_t v15 = v11;
    while (*(__int16 *)(*(void *)v15 + 40) != -24576)
    {
      v15 += 8;
      if (v15 == v12) {
        goto LABEL_65;
      }
    }
    if (v15 == v12 || !*(void *)v15) {
LABEL_65:
    }
      operator new();
    if (v11 == v12) {
      goto LABEL_73;
    }
    uint64_t v16 = v11;
    while (*(unsigned __int16 *)(*(void *)v16 + 40) != 40961)
    {
      v16 += 8;
      if (v16 == v12) {
        goto LABEL_73;
      }
    }
    if (v16 == v12 || !*(void *)v16) {
LABEL_73:
    }
      operator new();
    if (v11 == v12) {
      goto LABEL_81;
    }
    uint64_t v17 = v11;
    while (*(unsigned __int16 *)(*(void *)v17 + 40) != 40962)
    {
      v17 += 8;
      if (v17 == v12) {
        goto LABEL_81;
      }
    }
    if (v17 == v12 || !*(void *)v17) {
LABEL_81:
    }
      operator new();
    if (v11 == v12) {
      goto LABEL_88;
    }
    while (*(unsigned __int16 *)(*(void *)v11 + 40) != 40963)
    {
      v11 += 8;
      if (v11 == v12) {
        goto LABEL_88;
      }
    }
    if (v11 == v12 || !*(void *)v11) {
LABEL_88:
    }
      operator new();
    uint64_t v18 = this[10];
    if (v18 && this[13])
    {
      uint64_t v19 = *(void *)(v18 + 16);
      uint64_t v20 = *(void *)(v18 + 24);
      if (v19 != v20)
      {
        while (*(unsigned __int16 *)(*(void *)v19 + 40) != 34853)
        {
          v19 += 8;
          if (v19 == v20) {
            goto LABEL_97;
          }
        }
      }
      if (v19 == v20 || !*(void *)v19) {
LABEL_97:
      }
        operator new();
    }
  }
  if (this[14])
  {
    uint64_t v21 = this[12];
    uint64_t v22 = *(void *)(v21 + 16);
    uint64_t v23 = *(void *)(v21 + 24);
    if (v22 != v23)
    {
      while (*(unsigned __int16 *)(*(void *)v22 + 40) != 40965)
      {
        v22 += 8;
        if (v22 == v23) {
          goto LABEL_105;
        }
      }
    }
    if (v22 == v23 || !*(void *)v22) {
LABEL_105:
    }
      operator new();
  }
  return this;
}

void newRationalTag()
{
}

void sub_18879D8B8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1091C407990FA9CLL);
  _Unwind_Resume(a1);
}

BOOL _APP1::updateDateTime(_APP1 *this, char *__s)
{
  if (strlen(__s) != 19) {
    return 0;
  }
  uint64_t v5 = *((void *)this + 10);
  BOOL v6 = v5 != 0;
  if (v5)
  {
    uint64_t v7 = *(void **)(v5 + 16);
    uint64_t v8 = *(void **)(v5 + 24);
    if (v7 != v8)
    {
      while (*(_WORD *)(*v7 + 40) != 306)
      {
        if (++v7 == v8) {
          goto LABEL_11;
        }
      }
    }
    if (v7 == v8 || !*v7) {
LABEL_11:
    }
      operator new();
    (*(void (**)(void, char *))(*(void *)*v7 + 88))(*v7, __s);
  }
  uint64_t v9 = *((void *)this + 12);
  if (v9)
  {
    uint64_t v10 = *(void **)(v9 + 16);
    uint64_t v11 = *(void **)(v9 + 24);
    if (v10 != v11)
    {
      while (*(unsigned __int16 *)(*v10 + 40) != 36867)
      {
        if (++v10 == v11) {
          goto LABEL_20;
        }
      }
    }
    if (v10 == v11 || !*v10) {
LABEL_20:
    }
      operator new();
    (*(void (**)(void, char *, __n128))(*(void *)*v10 + 88))(*v10, __s, v4);
    uint64_t v13 = *((void *)this + 12);
    uint64_t v14 = *(void **)(v13 + 16);
    uint64_t v15 = *(void **)(v13 + 24);
    if (v14 != v15)
    {
      while (*(unsigned __int16 *)(*v14 + 40) != 36868)
      {
        if (++v14 == v15) {
          goto LABEL_28;
        }
      }
    }
    if (v14 == v15 || !*v14) {
LABEL_28:
    }
      operator new();
    (*(void (**)(void, char *, __n128))(*(void *)*v14 + 88))(*v14, __s, v12);
    return 1;
  }
  return v6;
}

void sub_18879DBA0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1091C407990FA9CLL);
  _Unwind_Resume(a1);
}

uint64_t _APP1::updateSubSecTime(_APP1 *this, char *__s)
{
  size_t v4 = strlen(__s);
  int __dst = 0;
  if ((v4 + 1) <= 4) {
    memcpy(&__dst, __s, v4);
  }
  uint64_t result = *((void *)this + 12);
  if (result)
  {
    BOOL v6 = *(unsigned __int16 ***)(result + 16);
    uint64_t v7 = *(unsigned __int16 ***)(result + 24);
    if (v6 != v7)
    {
      while ((*v6)[20] != 37520)
      {
        if (++v6 == v7) {
          goto LABEL_11;
        }
      }
    }
    if (v6 != v7)
    {
      if (*v6) {
        _TAGList::removeTag(result, *v6);
      }
    }
LABEL_11:
    operator new();
  }
  return result;
}

uint64_t _APP1::updateOrientation(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 80);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 16);
    uint64_t v3 = *(void *)(v1 + 24);
    if (v2 != v3)
    {
      while (*(_WORD *)(*(void *)v2 + 40) != 274)
      {
        v2 += 8;
        if (v2 == v3) {
          goto LABEL_11;
        }
      }
    }
    if (v2 == v3 || !*(void *)v2) {
LABEL_11:
    }
      operator new();
    size_t v4 = *(uint64_t (**)(void))(**(void **)v2 + 72);
    return v4();
  }
  return this;
}

void _APP1::updateTagWithString(_APP1 *this, int a2, CFTypeRef cf)
{
  uint64_t v5 = *((void *)this + 10);
  BOOL v6 = *(unsigned __int16 ***)(v5 + 16);
  uint64_t v7 = *(unsigned __int16 ***)(v5 + 24);
  if (v6 != v7)
  {
    while ((*v6)[20] != a2)
    {
      if (++v6 == v7) {
        return;
      }
    }
  }
  if (v6 != v7)
  {
    if (cf)
    {
      uint64_t v8 = *v6;
      if (*v6)
      {
        CFTypeID v9 = CFGetTypeID(cf);
        if (v9 == CFStringGetTypeID())
        {
          IIOString::IIOString((IIOString *)__dst, cf);
          UTF8String = (const char *)IIOString::createUTF8String((IIOString *)__dst);
          IIOString::~IIOString((IIOString *)__dst);
          if (UTF8String)
          {
            _TAGList::removeTag(*((void *)this + 10), v8);
            if (strlen(UTF8String) + 1 >= 5) {
              operator new();
            }
            *(_DWORD *)int __dst = 0;
            strlcpy(__dst, UTF8String, 4uLL);
            operator new();
          }
        }
      }
    }
  }
}

void sub_18879E210(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1091C407990FA9CLL);
  _Unwind_Resume(a1);
}

void _APP1::mergeWithIPTCProps(_APP1 *this, IIODictionary *a2)
{
  if (*((void *)this + 10))
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a2, @"Caption/Abstract");
    if (ObjectForKey) {
      _APP1::updateTagWithString(this, 270, ObjectForKey);
    }
    CFDictionaryRef v5 = IIODictionary::getObjectForKey(a2, @"Byline");
    if (v5) {
      _APP1::updateTagWithString(this, 315, v5);
    }
    CFDictionaryRef v6 = IIODictionary::getObjectForKey(a2, @"CopyrightNotice");
    if (v6)
    {
      _APP1::updateTagWithString(this, 33432, v6);
    }
  }
}

void _APP1Exif::_APP1Exif (_APP1Exif *this, unsigned __int8 *a2, uint64_t a3)
{
  *(_WORD *)((char *)this + 73) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 19) = 0;
  *((unsigned char *)this + 8) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_DWORD *)this + 32) = 0;
  *(void *)this = &unk_1ED4E6068;
  *((unsigned char *)this + 148) = 1;
  *((void *)this + 7) = 236060641;
  *((void *)this + 8) = 0x100000000;
  if (a3) {
    operator new[]();
  }
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
}

void sub_18879E3D0(_Unwind_Exception *a1)
{
  _APP1::~_APP1(v1);
  _Unwind_Resume(a1);
}

uint64_t _APP1Exif::markerLength(_APP1Exif *this)
{
  return *((unsigned int *)this + 15);
}

CFIndex _APP1Exif::writeToStream(CFIndex this, CFWriteStreamRef stream)
{
  if (*(unsigned char *)(this + 148))
  {
    CFIndex v2 = this;
    if (*(void *)(this + 152))
    {
      uint64_t v3 = *(void *)(this + 160);
      if (v3)
      {
        *(_WORD *)buffer = -7681;
        __int16 v5 = v3 + 2;
        UInt8 buffer[2] = HIBYTE(v5);
        buffer[3] = v5;
        CFWriteStreamWrite(stream, buffer, 4);
        return CFWriteStreamWrite(stream, *(const UInt8 **)(v2 + 152), *(void *)(v2 + 160));
      }
    }
  }
  return this;
}

void _APP1Exif::~_APP1Exif (_APP1Exif *this)
{
  *(void *)this = &unk_1ED4E6068;
  uint64_t v2 = *((void *)this + 19);
  if (v2)
  {
    MEMORY[0x18C11C0E0](v2, 0x1000C4077774924);
    *((void *)this + 19) = 0;
  }

  _APP1::~_APP1(this);
}

{
  uint64_t vars8;

  _APP1Exif::~_APP1Exif (this);

  JUMPOUT(0x18C11C0E0);
}

void _APP13::_APP13(_APP13 *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6, char a7)
{
  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *(void *)uint64_t v8 = &unk_1ED4E5988;
  *(void *)(v8 + 152) = 0;
  *(void *)(v8 + 80) = 0;
  *(void *)(v8 + 88) = 0;
  *(unsigned char *)(v8 + 96) = 0;
  *(void *)(v8 + 104) = 0;
  *(void *)(v8 + 112) = 0;
  *(void *)(v8 + 120) = a6;
  *(_WORD *)(v8 + 144) = 0;
}

void _APP13::_APP13(_APP13 *this, CFTypeRef cf)
{
  *(_WORD *)((char *)this + 73) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 248578029;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 19) = 0;
  *((unsigned char *)this + 8) = 0;
  *(void *)this = &unk_1ED4E5988;
  CFDataRef v3 = (const __CFData *)CFRetain(cf);
  *((void *)this + 10) = v3;
  *((void *)this + 11) = 0;
  *((void *)this + 19) = 0;
  int Length = CFDataGetLength(v3);
  *((_DWORD *)this + 15) = Length + (Length & 1) + 28;
  *((unsigned char *)this + 96) = 1;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 15) = Length + (Length & 1u) + 28;
  *((_WORD *)this + 72) = 257;
}

void sub_18879E614(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ED4E58D8;
  _Unwind_Resume(a1);
}

void _APP13::_APP13(_APP13 *this, unsigned __int8 *a2, unsigned int a3)
{
  *(_WORD *)((char *)this + 73) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 14) = 248578029;
  *((_DWORD *)this + 15) = a3;
  *((_DWORD *)this + 19) = 0;
  *((unsigned char *)this + 8) = 0;
  *(void *)this = &unk_1ED4E5988;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = a2;
  *((unsigned char *)this + 96) = 1;
  *((void *)this + 19) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 14) = 0;
  *((void *)this + 15) = a3;
  *((_WORD *)this + 72) = 257;
}

void _APP13::~_APP13(_APP13 *this)
{
  *(void *)this = &unk_1ED4E5988;
  uint64_t v2 = (const void *)*((void *)this + 10);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 10) = 0;
  CFDataRef v3 = (void *)*((void *)this + 11);
  if (v3) {
    free(v3);
  }
  *((void *)this + 11) = 0;
  uint64_t v4 = *((void *)this + 19);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  *((void *)this + 19) = 0;
  *(void *)this = &unk_1ED4E58D8;
}

{
  uint64_t vars8;

  _APP13::~_APP13(this);

  JUMPOUT(0x18C11C0E0);
}

void _APP13::processData(_APP13 *this)
{
  uint64_t v1 = (unsigned __int8 *)(*((void *)this + 5) + *((void *)this + 2));
  if (*v1 == 255)
  {
    unint64_t v3 = *((unsigned int *)this + 15);
    if (v1[1] == 237 && v3 >= 0xF)
    {
      BOOL v5 = *(void *)(v1 + 4) == 0x6F68736F746F6850 && *((_WORD *)v1 + 6) == 8304;
      BOOL v6 = !v5;
      if (!v6 && v3 >= 0x1F)
      {
        uint64_t v8 = 18;
        do
        {
          if (v1[v8] != 56) {
            break;
          }
          if (v1[v8 + 1] != 66) {
            break;
          }
          if (v1[v8 + 2] != 73) {
            break;
          }
          CFTypeID v9 = &v1[v8];
          if (v1[v8 + 3] != 77) {
            break;
          }
          uint64_t v10 = ((v1[v8 + 6] + 2) & 0x1FE) + v8 + 6;
          if (v10 + 12 >= v3) {
            break;
          }
          unsigned int v11 = *(_DWORD *)&v1[v10];
          uint64_t v8 = v10 + 4;
          if (v11)
          {
            unint64_t v12 = bswap32(v11);
            if (v3 - v8 < v12) {
              return;
            }
            unsigned int v13 = __rev16(*((unsigned __int16 *)v9 + 2));
            if (v13 == 1061)
            {
              *((void *)this + 16) = v8;
              *((void *)this + 17) = v12;
            }
            else if (v13 == 1028)
            {
              uint64_t v14 = (IIODictionary *)*((void *)this + 19);
              if (!v14) {
                operator new();
              }
              ReadIPTCProps(v14, &v1[v8], v12);
              *((void *)this + 13) = v8;
              *((void *)this + 14) = (v12 & 1) + v12;
              *((unsigned char *)this + 96) = 1;
            }
            v8 += (v12 + 1) & 0xFFFFFFFE;
          }
        }
        while (v8 + 12 < v3);
      }
    }
  }
}

void sub_18879E930(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

void *_APP13::setIPTCData(void *this, CFDataRef theData)
{
  uint64_t v2 = this;
  this[10] = theData;
  *((unsigned char *)this + 145) = 1;
  if (theData)
  {
    int Length = CFDataGetLength(theData);
    int v4 = (Length & 1) + Length;
    uint64_t v5 = v2[14];
    int v6 = v4 + 12;
    int v7 = v4 - v5;
    if (!v5) {
      int v7 = v6;
    }
    *((_DWORD *)v2 + 15) += v7;
    uint64_t v8 = (const void *)v2[10];
    return CFRetain(v8);
  }
  else
  {
    uint64_t v9 = this[14];
    if (v9) {
      *((_DWORD *)this + 15) = *((_DWORD *)this + 30) - v9;
    }
  }
  return this;
}

const __CFData *_APP13::writeToStream(_APP13 *this, CFWriteStreamRef stream)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  int v4 = (const UInt8 *)(*((void *)this + 5) + *((void *)this + 2));
  *(_OWORD *)buffer = xmmword_1889AB636;
  *(_OWORD *)&buffer[14] = *(long long *)((char *)&xmmword_1889AB636 + 14);
  CFDataRef result = (const __CFData *)*((void *)this + 10);
  if (result)
  {
    if (!*((void *)this + 13))
    {
      int v8 = *((unsigned __int8 *)this + 144);
      BytePtr = CFDataGetBytePtr(result);
      CFIndex Length = CFDataGetLength(*((CFDataRef *)this + 10));
      CFIndex v11 = Length;
      CFIndex v12 = Length & 1;
      __int16 v13 = (Length & 1) + Length;
      if (!v8)
      {
        int v15 = *((_DWORD *)this + 15) - 2;
        *(_WORD *)uint64_t v18 = -4609;
        v18[2] = BYTE1(v15);
        void v18[3] = v15;
        CFWriteStreamWrite(stream, v18, 4);
        CFWriteStreamWrite(stream, v4 + 4, *((void *)this + 15) - 4);
        *(_WORD *)&v19[8] = 0;
        *(void *)uint64_t v19 = 0x4044D494238;
        v19[10] = HIBYTE(v13);
        v19[11] = v13;
        CFWriteStreamWrite(stream, v19, 12);
        CFDataRef result = (const __CFData *)CFWriteStreamWrite(stream, BytePtr, v11);
        if (!v12) {
          return result;
        }
        UInt8 v17 = 0;
        uint64_t v14 = &v17;
        return (const __CFData *)CFWriteStreamWrite(stream, v14, 1);
      }
      UInt8 buffer[2] = (unsigned __int16)(v13 + 28) >> 8;
      buffer[3] = v13 + 28;
      buffer[28] = (unsigned __int16)((Length & 1) + Length) >> 8;
      buffer[29] = (Length & 1) + Length;
      CFWriteStreamWrite(stream, buffer, 30);
      CFDataRef result = (const __CFData *)CFWriteStreamWrite(stream, BytePtr, v11);
      if (!v12) {
        return result;
      }
LABEL_12:
      v19[0] = 0;
      uint64_t v14 = v19;
      return (const __CFData *)CFWriteStreamWrite(stream, v14, 1);
    }
    if (*((void *)this + 14) >= 3uLL)
    {
      CFDataGetBytePtr(result);
      CFDataGetLength(*((CFDataRef *)this + 10));
      operator new[]();
    }
LABEL_6:
    if (!*((unsigned char *)this + 144)) {
      return result;
    }
    int v6 = (const UInt8 *)*((void *)this + 11);
    if (!v6) {
      return result;
    }
    int v7 = *((_DWORD *)this + 15);
    *(_WORD *)&UInt8 buffer[2] = bswap32(v7 + (v7 & 1) + 2) >> 16;
    CFWriteStreamWrite(stream, buffer, 4);
    CFDataRef result = (const __CFData *)CFWriteStreamWrite(stream, v6, *((unsigned int *)this + 15));
    if ((v7 & 1) == 0) {
      return result;
    }
    goto LABEL_12;
  }
  if (*((void *)this + 11)) {
    goto LABEL_6;
  }
  if (*((unsigned char *)this + 145))
  {
    if (*((void *)this + 13) >= 5uLL) {
      operator new[]();
    }
  }
  else
  {
    CFIndex v16 = *((unsigned int *)this + 15);
    return (const __CFData *)CFWriteStreamWrite(stream, v4, v16);
  }
  return result;
}

void _APP1XMP::_APP1XMP(_APP1XMP *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *(void *)uint64_t v7 = &unk_1ED4E5D50;
  *(_WORD *)(v7 + 68) = 256;
  *(unsigned char *)(v7 + 70) = 0;
  *(_WORD *)(v7 + 58) |= 2u;
  *(void *)(v7 + 80) = 0;
  *(void *)(v7 + 88) = 0;
  *(unsigned char *)(v7 + 96) = 0;
}

void _APP1XMP::_APP1XMP(_APP1XMP *this, const __CFData *a2)
{
  *(_WORD *)((char *)this + 73) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 19) = 0;
  *((unsigned char *)this + 8) = 0;
  *(void *)this = &unk_1ED4E5D50;
  *((unsigned char *)this + 96) = 1;
  *((void *)this + 7) = 236126177;
  *((void *)this + 8) = 0x10000000000;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  _APP1XMP::setXMPData(this, a2);
}

void sub_18879EEA0(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ED4E58D8;
  _Unwind_Resume(a1);
}

void *_APP1XMP::setXMPData(void *this, CFDataRef theData)
{
  if (theData)
  {
    unint64_t v3 = this;
    *((_DWORD *)this + 15) = CFDataGetLength(theData) + 33;
    v3[10] = theData;
    this = CFRetain(theData);
    *((unsigned char *)v3 + 96) = 1;
  }
  return this;
}

CFDataRef _APP1XMP::processData(CFDataRef this)
{
  unsigned int v1 = *((_DWORD *)this + 15);
  if (v1 >= 4)
  {
    CFDataRef v2 = this;
    unint64_t v3 = (unsigned __int8 *)(*((void *)this + 5) + *((void *)this + 2));
    if (__PAIR64__(v3[1], *v3) == 0xE1000000FFLL
      && v1 >= 0x21
      && *(void *)(v3 + 4) == 0x6E2F2F3A70747468
      && *(void *)(v3 + 12) == 0x2E65626F64612E73
      && *(void *)(v3 + 20) == 0x2F7061782F6D6F63
      && *(void *)(v3 + 25) == 0x2F302E312F7061)
    {
      uint64_t v7 = __rev16(*((unsigned __int16 *)v3 + 1)) - 31;
      int v8 = v3 + 33;
      *((void *)this + 11) = CreateMetadataFromXMPBuffer((const char *)v3 + 33, v7);
      this = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v8, v7);
      *((void *)v2 + 10) = this;
    }
  }
  return this;
}

void _APP1XMP::~_APP1XMP(_APP1XMP *this)
{
  *(void *)this = &unk_1ED4E5D50;
  CFDataRef v2 = (const void *)*((void *)this + 10);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 10) = 0;
  unint64_t v3 = (const void *)*((void *)this + 11);
  if (v3) {
    CFRelease(v3);
  }
  *((void *)this + 11) = 0;
  *(void *)this = &unk_1ED4E58D8;
}

{
  uint64_t vars8;

  _APP1XMP::~_APP1XMP(this);

  JUMPOUT(0x18C11C0E0);
}

CFIndex _APP1XMP::writeToStream(CFDataRef *this, __CFWriteStream *a2)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 96) && (CFDataRef v4 = this[10]) != 0)
  {
    long long v8 = xmmword_1889AB654;
    strcpy(v9, "obe.com/xap/1.0/");
    BytePtr = CFDataGetBytePtr(v4);
    CFIndex Length = CFDataGetLength(this[10]);
    WORD1(v8) = bswap32(Length + 31) >> 16;
    CFWriteStreamWrite(a2, (const UInt8 *)&v8, 33);
  }
  else
  {
    BytePtr = (const UInt8 *)this[2] + (void)this[5];
    CFIndex Length = *((unsigned int *)this + 15);
  }
  return CFWriteStreamWrite(a2, BytePtr, Length);
}

uint64_t _APP1XMP::getXmpData(_APP1XMP *this)
{
  return *((void *)this + 10);
}

void _APP1ExtendedXMP::_APP1ExtendedXMP(_APP1ExtendedXMP *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *(void *)uint64_t v7 = &unk_1ED4E3F18;
  *(_WORD *)(v7 + 68) = 0;
  *(unsigned char *)(v7 + 70) = 1;
  *(_WORD *)(v7 + 58) |= 3u;
  *(unsigned char *)(v7 + 112) = 0;
  *(void *)(v7 + 80) = 0;
  *(void *)(v7 + 88) = 0;
}

void _APP1ExtendedXMP::_APP1ExtendedXMP(_APP1ExtendedXMP *this, CFDataRef theData, int a3, int a4, CFTypeRef cf)
{
  *(_WORD *)((char *)this + 73) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 19) = 0;
  *((unsigned char *)this + 8) = 0;
  *(void *)this = &unk_1ED4E3F18;
  *((unsigned char *)this + 112) = 1;
  *((void *)this + 7) = 236191713;
  *((void *)this + 8) = 0x1000000000000;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = cf;
  if (cf) {
    CFRetain(cf);
  }
  *((_DWORD *)this + 26) = a3;
  *((_DWORD *)this + 27) = a4;
  _APP1ExtendedXMP::setXMPData(this, theData);
}

void sub_18879F2B0(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1ED4E58D8;
  _Unwind_Resume(a1);
}

void *_APP1ExtendedXMP::setXMPData(void *this, CFDataRef theData)
{
  if (theData)
  {
    unint64_t v3 = this;
    *((_DWORD *)this + 15) = CFDataGetLength(theData) + 79;
    v3[10] = theData;
    this = CFRetain(theData);
    *((unsigned char *)v3 + 112) = 1;
  }
  return this;
}

CFDataRef _APP1ExtendedXMP::processData(CFDataRef this)
{
  unsigned int v1 = *((_DWORD *)this + 15);
  if (v1 >= 4)
  {
    CFDataRef v2 = this;
    unint64_t v3 = (unsigned __int8 *)(*((void *)this + 5) + *((void *)this + 2));
    if (*v3 == 255 && v1 >= 0x27 && v3[1] == 225)
    {
      this = (CFDataRef)strcmp((const char *)v3 + 4, "http://ns.adobe.com/xmp/extension/");
      if (v1 >= 0x47 && !this)
      {
        CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
        this = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v3 + 39, 32);
        *((void *)v2 + 12) = this;
        unsigned int v5 = *((_DWORD *)v2 + 15);
        if (v5 >= 0x4F)
        {
          *((_DWORD *)v2 + 27) = bswap32(*(_DWORD *)(v3 + 71));
          *((_DWORD *)v2 + 26) = bswap32(*(_DWORD *)(v3 + 75));
          this = CFDataCreate(v4, v3 + 79, v5 - 79);
          *((void *)v2 + 10) = this;
        }
      }
    }
  }
  return this;
}

void _APP1ExtendedXMP::~_APP1ExtendedXMP(_APP1ExtendedXMP *this)
{
  *(void *)this = &unk_1ED4E3F18;
  CFDataRef v2 = (const void *)*((void *)this + 10);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 10) = 0;
  unint64_t v3 = (const void *)*((void *)this + 11);
  if (v3) {
    CFRelease(v3);
  }
  *((void *)this + 11) = 0;
  CFAllocatorRef v4 = (const void *)*((void *)this + 12);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 12) = 0;
  *(void *)this = &unk_1ED4E58D8;
}

{
  uint64_t vars8;

  _APP1ExtendedXMP::~_APP1ExtendedXMP(this);

  JUMPOUT(0x18C11C0E0);
}

CFIndex _APP1ExtendedXMP::writeToStream(_APP1ExtendedXMP *this, __CFWriteStream *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 112) && (CFDataRef v4 = (const __CFData *)*((void *)this + 10)) != 0)
  {
    long long v10 = xmmword_1889AB699;
    strcpy(v11, "obe.com/xmp/extension/");
    BytePtr = CFDataGetBytePtr(v4);
    CFIndex Length = CFDataGetLength(*((CFDataRef *)this + 10));
    WORD1(v10) = bswap32(Length + 77) >> 16;
    uint64_t v7 = CFDataGetBytePtr(*((CFDataRef *)this + 12));
    long long v8 = *((_OWORD *)v7 + 1);
    *(_OWORD *)&v11[23] = *(_OWORD *)v7;
    *(_OWORD *)&v11[39] = v8;
    int32x2_t v12 = vrev64_s32((int32x2_t)vrev32_s8(*(int8x8_t *)((char *)this + 104)));
    CFWriteStreamWrite(a2, (const UInt8 *)&v10, 79);
  }
  else
  {
    BytePtr = (const UInt8 *)(*((void *)this + 5) + *((void *)this + 2));
    CFIndex Length = *((unsigned int *)this + 15);
  }
  return CFWriteStreamWrite(a2, BytePtr, Length);
}

uint64_t _APP1ExtendedXMP::getXmpOffset(_APP1ExtendedXMP *this)
{
  return *((unsigned int *)this + 26);
}

uint64_t _APP1ExtendedXMP::getTotalXMPLength(_APP1ExtendedXMP *this)
{
  return *((unsigned int *)this + 27);
}

uint64_t _APP1ExtendedXMP::getGUID(_APP1ExtendedXMP *this)
{
  return *((void *)this + 12);
}

void _APP2ICC::_APP2ICC(_APP2ICC *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *(void *)uint64_t v7 = &unk_1ED4E5DE0;
  *(unsigned char *)(v7 + 90) = 0;
  *(void *)(v7 + 80) = 0;
  *(unsigned char *)(v7 + 71) = 1;
  *(_WORD *)(v7 + 88) = 0;
}

void _APP2ICC::_APP2ICC(_APP2ICC *this, CFDataRef theData, char a3, char a4)
{
  *(_WORD *)((char *)this + 73) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((unsigned char *)this + 32) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 237043682;
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 19) = 0;
  *((unsigned char *)this + 8) = 0;
  *(void *)this = &unk_1ED4E5DE0;
  int Length = CFDataGetLength(theData);
  *((void *)this + 10) = CFRetain(theData);
  *((unsigned char *)this + 71) = 1;
  *((unsigned char *)this + 88) = a3;
  *((unsigned char *)this + 89) = a4;
  *((_DWORD *)this + 15) = Length + 18;
  *((unsigned char *)this + 90) = 1;
}

void sub_18879F6E0(_Unwind_Exception *a1)
{
  *unsigned int v1 = &unk_1ED4E58D8;
  _Unwind_Resume(a1);
}

void _APP2ICC::~_APP2ICC(_APP2ICC *this)
{
  *(void *)this = &unk_1ED4E5DE0;
  CFDataRef v2 = (const void *)*((void *)this + 10);
  if (v2) {
    CFRelease(v2);
  }
  *(void *)this = &unk_1ED4E58D8;
}

{
  uint64_t vars8;

  _APP2ICC::~_APP2ICC(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t _APP2ICC::writeToStream(uint64_t this, CFWriteStreamRef stream)
{
  uint64_t v3 = this;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(this + 90) && *(void *)(this + 80))
  {
    long long v9 = xmmword_1889AB6E8;
    WORD1(v9) = bswap32(*(unsigned __int16 *)(this + 60) - 2) >> 16;
    __int16 v10 = *(_WORD *)(this + 88);
    CFWriteStreamWrite(stream, (const UInt8 *)&v9, 18);
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(v3 + 80));
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(v3 + 80));
    return CFWriteStreamWrite(stream, BytePtr, Length);
  }
  else
  {
    uint64_t v6 = *(void *)(this + 40);
    if (v6)
    {
      CFIndex v7 = *(unsigned int *)(this + 60);
      long long v8 = (const UInt8 *)(v6 + *(void *)(this + 16));
      return CFWriteStreamWrite(stream, v8, v7);
    }
  }
  return this;
}

uint64_t _TAG::count(_TAG *this)
{
  return *((unsigned int *)this + 15);
}

uint64_t _TAG::tagType(_TAG *this)
{
  return *((unsigned __int16 *)this + 28);
}

uint64_t _TAG::dataOrOffset(_TAG *this)
{
  return *((unsigned int *)this + 16);
}

uint64_t _APPx::mainIFD(_APPx *this)
{
  return 0;
}

uint64_t _APPx::thumbIFD(_APPx *this)
{
  return 0;
}

uint64_t _APP0::setWriteExtendedAPP0(uint64_t this)
{
  *(unsigned char *)(this + 80) = 1;
  return this;
}

uint64_t _APP1::mainIFD(_APP1 *this)
{
  return *((void *)this + 10);
}

uint64_t _APP1::thumbIFD(_APP1 *this)
{
  return *((void *)this + 11);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **,false>(uint64_t result, _TAG **a2, uint64_t a3, char a4)
{
  CFIndex v7 = (_TAG **)result;
  while (2)
  {
    v213 = a2 - 1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v8 = (char *)a2 - (char *)v7;
          unint64_t v9 = a2 - v7;
          if (v5 || !v4)
          {
            switch(v9)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                v100 = *(a2 - 1);
                uint64_t v101 = *v7;
                unsigned int v102 = _TAG::priority(v100);
                CFDataRef result = _TAG::priority(v101);
                if (v102 > result
                  || v102 >= result
                  && ((unsigned int v192 = *((_DWORD *)v100 + 17), v192 <= 4) ? (v193 = 0) : (v193 = (v192 + 1) & 0xFFFFFFFE),
                      (unsigned int v194 = *((_DWORD *)v101 + 17), v194 >= 5)
                    ? (BOOL v195 = ((v194 + 1) & 0xFFFFFFFE) > v193)
                    : (BOOL v195 = 0),
                      v195))
                {
                  *CFIndex v7 = v100;
                  *(a2 - 1) = v101;
                }
                break;
              case 3uLL:
                CFDataRef result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v7, v7 + 1, v213);
                break;
              case 4uLL:
                CFDataRef result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v7, v7 + 1, v7 + 2, v213);
                break;
              case 5uLL:
                CFDataRef result = std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **,0>(v7, v7 + 1, v7 + 2, v7 + 3, v213);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v8 <= 191)
          {
            uint64_t v103 = v7 + 1;
            BOOL v105 = v7 == a2 || v103 == a2;
            if (a4)
            {
              if (!v105)
              {
                uint64_t v106 = 0;
                unsigned int v107 = v7;
                do
                {
                  uint64_t v108 = v107;
                  unsigned int v107 = v103;
                  char v110 = *v108;
                  v109 = v108[1];
                  unsigned int v111 = _TAG::priority(v109);
                  CFDataRef result = _TAG::priority(v110);
                  if (v111 > result
                    || v111 >= result
                    && ((unsigned int v112 = *((_DWORD *)v109 + 17), v112 <= 4) ? (v113 = 0) : (v113 = (v112 + 1) & 0xFFFFFFFE),
                        (unsigned int v114 = *((_DWORD *)v110 + 17), v114 >= 5)
                      ? (BOOL v115 = ((v114 + 1) & 0xFFFFFFFE) > v113)
                      : (BOOL v115 = 0),
                        v115))
                  {
                    v108[1] = v110;
                    v116 = v7;
                    if (v108 != v7)
                    {
                      uint64_t v117 = v106;
                      do
                      {
                        v118 = *(_TAG **)((char *)v7 + v117 - 8);
                        unsigned int v119 = _TAG::priority(v109);
                        CFDataRef result = _TAG::priority(v118);
                        if (v119 <= result)
                        {
                          if (v119 < result)
                          {
                            v116 = (_TAG **)((char *)v7 + v117);
                            goto LABEL_210;
                          }
                          unsigned int v120 = *((_DWORD *)v109 + 17);
                          unsigned int v121 = v120 <= 4 ? 0 : (v120 + 1) & 0xFFFFFFFE;
                          unsigned int v122 = *((_DWORD *)v118 + 17);
                          if (v122 < 5 || ((v122 + 1) & 0xFFFFFFFE) <= v121)
                          {
                            v116 = v108;
                            goto LABEL_210;
                          }
                        }
                        --v108;
                        *(_TAG **)((char *)v7 + v117) = v118;
                        v117 -= 8;
                      }
                      while (v117);
                      v116 = v7;
                    }
LABEL_210:
                    unsigned char *v116 = v109;
                  }
                  uint64_t v103 = v107 + 1;
                  v106 += 8;
                }
                while (v107 + 1 != a2);
              }
            }
            else if (!v105)
            {
              do
              {
                v196 = v7;
                CFIndex v7 = v103;
                v198 = *v196;
                v197 = v196[1];
                unsigned int v199 = _TAG::priority(v197);
                CFDataRef result = _TAG::priority(v198);
                if (v199 > result
                  || v199 >= result
                  && ((unsigned int v200 = *((_DWORD *)v197 + 17), v200 <= 4) ? (v201 = 0) : (v201 = (v200 + 1) & 0xFFFFFFFE),
                      (unsigned int v202 = *((_DWORD *)v198 + 17), v202 >= 5)
                    ? (BOOL v203 = ((v202 + 1) & 0xFFFFFFFE) > v201)
                    : (BOOL v203 = 0),
                      v203))
                {
                  do
                  {
                    do
                    {
                      v204 = v196;
                      v205 = *--v196;
                      v196[2] = v198;
                      v198 = v205;
                      unsigned int v206 = _TAG::priority(v197);
                      CFDataRef result = _TAG::priority(v205);
                    }
                    while (v206 > result);
                    if (v206 < result) {
                      break;
                    }
                    unsigned int v207 = *((_DWORD *)v197 + 17);
                    unsigned int v208 = v207 <= 4 ? 0 : (v207 + 1) & 0xFFFFFFFE;
                    unsigned int v209 = *((_DWORD *)v198 + 17);
                  }
                  while (v209 >= 5 && ((v209 + 1) & 0xFFFFFFFE) > v208);
                  *v204 = v197;
                }
                uint64_t v103 = v7 + 1;
              }
              while (v7 + 1 != a2);
            }
            return result;
          }
          v217 = v7;
          if (!a3)
          {
            if (v7 != a2)
            {
              int64_t v124 = (v9 - 2) >> 1;
              int64_t v125 = v124;
              do
              {
                int64_t v126 = v125;
                if (v124 >= v125)
                {
                  uint64_t v127 = (2 * v125) | 1;
                  int v128 = &v217[v127];
                  if (2 * v125 + 2 < (uint64_t)v9)
                  {
                    unsigned int v129 = *v128;
                    unsigned int v130 = v128[1];
                    unsigned int v131 = _TAG::priority(*v128);
                    unsigned int v132 = _TAG::priority(v130);
                    if (v131 > v132
                      || v131 >= v132
                      && ((unsigned int v133 = *((_DWORD *)v129 + 17), v133 <= 4) ? (v134 = 0) : (v134 = (v133 + 1) & 0xFFFFFFFE),
                          (unsigned int v135 = *((_DWORD *)v130 + 17), v135 >= 5)
                        ? (BOOL v136 = ((v135 + 1) & 0xFFFFFFFE) > v134)
                        : (BOOL v136 = 0),
                          v136))
                    {
                      ++v128;
                      uint64_t v127 = 2 * v126 + 2;
                    }
                  }
                  unsigned int v137 = *v128;
                  unsigned int v138 = v217[v126];
                  unsigned int v139 = _TAG::priority(*v128);
                  CFDataRef result = _TAG::priority(v138);
                  int64_t v124 = (v9 - 2) >> 1;
                  if (v139 <= result)
                  {
                    if (v139 < result
                      || ((v140 = *((_DWORD *)v137 + 17), v140 <= 4) ? (unsigned int v141 = 0) : (unsigned int v141 = (v140 + 1) & 0xFFFFFFFE),
                          (unsigned int v142 = *((_DWORD *)v138 + 17), v142 >= 5)
                        ? (BOOL v143 = ((v142 + 1) & 0xFFFFFFFE) > v141)
                        : (BOOL v143 = 0),
                          !v143))
                    {
                      v217[v126] = v137;
                      if ((uint64_t)((v9 - 2) >> 1) >= v127)
                      {
                        int64_t v212 = v126;
                        while (1)
                        {
                          v214 = v128;
                          uint64_t v144 = 2 * v127;
                          uint64_t v127 = (2 * v127) | 1;
                          int v128 = &v217[v127];
                          uint64_t v145 = v144 + 2;
                          if (v144 + 2 < (uint64_t)v9)
                          {
                            int v146 = *v128;
                            int v147 = v128[1];
                            unsigned int v148 = _TAG::priority(*v128);
                            unsigned int v149 = _TAG::priority(v147);
                            BOOL v150 = v148 >= v149;
                            BOOL v28 = v148 > v149;
                            int64_t v124 = (v9 - 2) >> 1;
                            if (v28
                              || v150
                              && ((unsigned int v151 = *((_DWORD *)v146 + 17), v151 <= 4)
                                ? (unsigned int v152 = 0)
                                : (unsigned int v152 = (v151 + 1) & 0xFFFFFFFE),
                                  (unsigned int v153 = *((_DWORD *)v147 + 17), v153 >= 5)
                                ? (BOOL v154 = ((v153 + 1) & 0xFFFFFFFE) > v152)
                                : (BOOL v154 = 0),
                                  v154))
                            {
                              ++v128;
                              uint64_t v127 = v145;
                            }
                          }
                          v155 = *v128;
                          unsigned int v156 = _TAG::priority(*v128);
                          CFDataRef result = _TAG::priority(v138);
                          int64_t v126 = v212;
                          if (v156 > result) {
                            break;
                          }
                          if (v156 >= result)
                          {
                            unsigned int v157 = *((_DWORD *)v155 + 17);
                            unsigned int v158 = v157 <= 4 ? 0 : (v157 + 1) & 0xFFFFFFFE;
                            unsigned int v159 = *((_DWORD *)v138 + 17);
                            if (v159 >= 5 && ((v159 + 1) & 0xFFFFFFFE) > v158) {
                              break;
                            }
                          }
                          *v214 = v155;
                          if (v124 < v127) {
                            goto LABEL_261;
                          }
                        }
                        int v128 = v214;
                      }
LABEL_261:
                      *int v128 = v138;
                    }
                  }
                }
                int64_t v125 = v126 - 1;
              }
              while (v126);
              uint64_t v160 = (unint64_t)v8 >> 3;
              v161 = v217;
              do
              {
                uint64_t v162 = 0;
                v215 = *v161;
                v163 = v161;
                do
                {
                  v164 = v163;
                  v163 += v162 + 1;
                  uint64_t v165 = 2 * v162;
                  uint64_t v162 = (2 * v162) | 1;
                  uint64_t v166 = v165 + 2;
                  if (v165 + 2 < v160)
                  {
                    v167 = *v163;
                    v168 = v163[1];
                    unsigned int v169 = _TAG::priority(*v163);
                    CFDataRef result = _TAG::priority(v168);
                    if (v169 > result
                      || v169 >= result
                      && ((unsigned int v170 = *((_DWORD *)v167 + 17), v170 <= 4) ? (v171 = 0) : (v171 = (v170 + 1) & 0xFFFFFFFE),
                          (unsigned int v172 = *((_DWORD *)v168 + 17), v172 >= 5)
                        ? (BOOL v173 = ((v172 + 1) & 0xFFFFFFFE) > v171)
                        : (BOOL v173 = 0),
                          v173))
                    {
                      ++v163;
                      uint64_t v162 = v166;
                    }
                  }
                  *v164 = *v163;
                }
                while (v162 <= (uint64_t)((unint64_t)(v160 - 2) >> 1));
                if (v163 == --a2)
                {
                  *v163 = v215;
                  v161 = v217;
                }
                else
                {
                  v161 = v217;
                  *v163 = *a2;
                  *a2 = v215;
                  uint64_t v174 = (char *)v163 - (char *)v217 + 8;
                  if (v174 >= 9)
                  {
                    unint64_t v175 = ((unint64_t)v174 >> 3) - 2;
                    unint64_t v176 = v175 >> 1;
                    v177 = &v217[v175 >> 1];
                    v178 = *v177;
                    v179 = *v163;
                    unsigned int v180 = _TAG::priority(*v177);
                    CFDataRef result = _TAG::priority(v179);
                    if (v180 > result
                      || v180 >= result
                      && ((unsigned int v181 = *((_DWORD *)v178 + 17), v181 <= 4) ? (v182 = 0) : (v182 = (v181 + 1) & 0xFFFFFFFE),
                          (unsigned int v183 = *((_DWORD *)v179 + 17), v183 >= 5)
                        ? (BOOL v184 = ((v183 + 1) & 0xFFFFFFFE) > v182)
                        : (BOOL v184 = 0),
                          v184))
                    {
                      *v163 = v178;
                      if (v175 >= 2)
                      {
                        while (1)
                        {
                          unint64_t v186 = v176 - 1;
                          unint64_t v176 = (v176 - 1) >> 1;
                          v185 = &v217[v176];
                          v187 = *v185;
                          unsigned int v188 = _TAG::priority(*v185);
                          CFDataRef result = _TAG::priority(v179);
                          if (v188 <= result)
                          {
                            if (v188 < result) {
                              break;
                            }
                            unsigned int v189 = *((_DWORD *)v187 + 17);
                            unsigned int v190 = v189 <= 4 ? 0 : (v189 + 1) & 0xFFFFFFFE;
                            unsigned int v191 = *((_DWORD *)v179 + 17);
                            if (v191 < 5 || ((v191 + 1) & 0xFFFFFFFE) <= v190) {
                              break;
                            }
                          }
                          *v177 = v187;
                          v177 = &v217[v176];
                          if (v186 <= 1) {
                            goto LABEL_300;
                          }
                        }
                      }
                      v185 = v177;
LABEL_300:
                      *v185 = v179;
                    }
                  }
                }
                BOOL v28 = v160-- <= 2;
              }
              while (!v28);
            }
            return result;
          }
          unint64_t v10 = v9 >> 1;
          uint64_t v11 = &v7[v9 >> 1];
          if ((unint64_t)v8 >= 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v7, &v7[v9 >> 1], v213);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v7 + 1, v11 - 1, a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v7 + 2, &v7[v10 + 1], a2 - 3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v11 - 1, v11, &v7[v10 + 1]);
            int32x2_t v12 = *v7;
            *CFIndex v7 = *v11;
            void *v11 = v12;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(&v7[v9 >> 1], v7, v213);
          }
          --a3;
          uint64_t v13 = *v7;
          if (a4) {
            break;
          }
          uint64_t v14 = *(v7 - 1);
          unsigned int v15 = _TAG::priority(v14);
          unsigned int v16 = _TAG::priority(v13);
          if (v15 > v16) {
            break;
          }
          unsigned int v17 = v16;
          if (v15 >= v16)
          {
            unsigned int v18 = *((_DWORD *)v14 + 17);
            unsigned int v19 = v18 <= 4 ? 0 : (v18 + 1) & 0xFFFFFFFE;
            unsigned int v20 = *((_DWORD *)v13 + 17);
            if (v20 >= 5 && ((v20 + 1) & 0xFFFFFFFE) > v19) {
              break;
            }
          }
          unint64_t v64 = *v213;
          CFDataRef result = _TAG::priority(*v213);
          if (v17 > result
            || v17 >= result
            && ((unsigned int v97 = *((_DWORD *)v13 + 17), v97 <= 4) ? (v98 = 0) : (v98 = (v97 + 1) & 0xFFFFFFFE),
                (unsigned int v99 = *((_DWORD *)v64 + 17), v99 >= 5) && ((v99 + 1) & 0xFFFFFFFE) > v98))
          {
            while (1)
            {
              char v66 = v7[1];
              ++v7;
              unint64_t v65 = v66;
              CFDataRef result = _TAG::priority(v66);
              if (v17 > result) {
                break;
              }
              if (v17 >= result)
              {
                unsigned int v67 = *((_DWORD *)v13 + 17);
                unsigned int v68 = v67 <= 4 ? 0 : (v67 + 1) & 0xFFFFFFFE;
                unsigned int v69 = *((_DWORD *)v65 + 17);
                if (v69 >= 5 && ((v69 + 1) & 0xFFFFFFFE) > v68) {
                  break;
                }
              }
            }
          }
          else
          {
            for (++v7; v7 < a2; ++v7)
            {
              unsigned int v92 = *v7;
              CFDataRef result = _TAG::priority(*v7);
              if (v17 > result) {
                break;
              }
              if (v17 >= result)
              {
                unsigned int v93 = *((_DWORD *)v13 + 17);
                unsigned int v94 = v93 <= 4 ? 0 : (v93 + 1) & 0xFFFFFFFE;
                unsigned int v95 = *((_DWORD *)v92 + 17);
                if (v95 >= 5 && ((v95 + 1) & 0xFFFFFFFE) > v94) {
                  break;
                }
              }
            }
          }
          unsigned int i = a2;
          if (v7 < a2)
          {
            for (unsigned int i = a2 - 1; ; --i)
            {
              CFDataRef result = _TAG::priority(v64);
              if (v17 <= result)
              {
                if (v17 < result) {
                  break;
                }
                unsigned int v72 = *((_DWORD *)v13 + 17);
                unsigned int v73 = v72 <= 4 ? 0 : (v72 + 1) & 0xFFFFFFFE;
                unsigned int v74 = *((_DWORD *)v64 + 17);
                if (v74 < 5 || ((v74 + 1) & 0xFFFFFFFE) <= v73) {
                  break;
                }
              }
              unsigned int v76 = *(i - 1);
              unint64_t v64 = v76;
            }
          }
          if (v7 < i)
          {
            unsigned int v77 = *v7;
            unsigned int v78 = (unsigned int *)*i;
            do
            {
              *CFIndex v7 = (_TAG *)v78;
              *unsigned int i = v77;
              unsigned int v79 = _TAG::priority(v13);
              while (1)
              {
                uint64_t v80 = v7[1];
                ++v7;
                unsigned int v77 = v80;
                unsigned int v81 = _TAG::priority(v80);
                if (v79 > v81) {
                  break;
                }
                if (v79 >= v81)
                {
                  unsigned int v82 = *((_DWORD *)v13 + 17);
                  unsigned int v83 = v82 <= 4 ? 0 : (v82 + 1) & 0xFFFFFFFE;
                  unsigned int v84 = *((_DWORD *)v77 + 17);
                  if (v84 >= 5 && ((v84 + 1) & 0xFFFFFFFE) > v83) {
                    break;
                  }
                }
              }
              do
              {
                do
                {
                  unint64_t v86 = *--i;
                  unsigned int v78 = (unsigned int *)v86;
                  CFDataRef result = _TAG::priority(v86);
                }
                while (v79 > result);
                if (v79 < result) {
                  break;
                }
                unsigned int v87 = *((_DWORD *)v13 + 17);
                unsigned int v88 = v87 <= 4 ? 0 : (v87 + 1) & 0xFFFFFFFE;
                unsigned int v89 = v78[17];
              }
              while (v89 >= 5 && ((v89 + 1) & 0xFFFFFFFE) > v88);
            }
            while (v7 < i);
          }
          unsigned int v91 = v7 - 1;
          BOOL v4 = v7 - 1 >= v217;
          BOOL v5 = v7 - 1 == v217;
          if (v7 - 1 != v217) {
            *v217 = *v91;
          }
          a4 = 0;
          *unsigned int v91 = v13;
        }
        unsigned int v21 = _TAG::priority(v13);
        for (uint64_t j = 0; ; ++j)
        {
          uint64_t v23 = v217[j + 1];
          unsigned int v24 = _TAG::priority(v23);
          if (v24 <= v21)
          {
            if (v24 < v21) {
              break;
            }
            unsigned int v25 = *((_DWORD *)v23 + 17);
            unsigned int v26 = v25 <= 4 ? 0 : (v25 + 1) & 0xFFFFFFFE;
            unsigned int v27 = *((_DWORD *)v13 + 17);
            BOOL v28 = v27 >= 5 && ((v27 + 1) & 0xFFFFFFFE) > v26;
            if (!v28) {
              break;
            }
          }
        }
        uint64_t v29 = &v217[j];
        unint64_t v30 = (unint64_t)&v217[j + 1];
        if (j * 8)
        {
          unsigned int v31 = a2 - 1;
          uint64_t v32 = *v213;
          unsigned int v33 = _TAG::priority(*v213);
          if (v33 <= v21)
          {
            unsigned int v31 = a2 - 1;
            do
            {
              if (v33 >= v21)
              {
                unsigned int v34 = *((_DWORD *)v32 + 17);
                unsigned int v35 = v34 <= 4 ? 0 : (v34 + 1) & 0xFFFFFFFE;
                unsigned int v36 = *((_DWORD *)v13 + 17);
                if (v36 >= 5 && ((v36 + 1) & 0xFFFFFFFE) > v35) {
                  break;
                }
              }
              uint64_t v38 = *--v31;
              uint64_t v32 = v38;
              unsigned int v33 = _TAG::priority(v38);
            }
            while (v33 <= v21);
          }
        }
        else
        {
          unsigned int v31 = a2;
          if (v30 < (unint64_t)a2)
          {
            unsigned int v31 = a2 - 1;
            unsigned int v39 = *v213;
            unsigned int v40 = _TAG::priority(*v213);
            if (v40 <= v21)
            {
              unsigned int v31 = a2 - 1;
              do
              {
                if (v40 >= v21)
                {
                  unsigned int v41 = *((_DWORD *)v39 + 17);
                  if (v41 <= 4) {
                    unsigned int v42 = 0;
                  }
                  else {
                    unsigned int v42 = (v41 + 1) & 0xFFFFFFFE;
                  }
                  unsigned int v43 = *((_DWORD *)v13 + 17);
                  BOOL v4 = v43 >= 5;
                  unsigned int v44 = (v43 + 1) & 0xFFFFFFFE;
                  char v46 = !v4 || v44 <= v42;
                  if (v30 >= (unint64_t)v31 || (v46 & 1) == 0) {
                    break;
                  }
                }
                else if (v30 >= (unint64_t)v31)
                {
                  break;
                }
                uint64_t v47 = *--v31;
                unsigned int v39 = v47;
                unsigned int v40 = _TAG::priority(v47);
              }
              while (v40 <= v21);
            }
          }
        }
        if (v30 < (unint64_t)v31)
        {
          unsigned int v48 = *v31;
          unsigned int v49 = v31;
          int v50 = &v217[j + 1];
          do
          {
            *v50++ = v48;
            *unsigned int v49 = v23;
            unsigned int v51 = _TAG::priority(v13);
            while (1)
            {
              uint64_t v23 = *v50;
              unsigned int v52 = _TAG::priority(*v50);
              if (v52 <= v51)
              {
                if (v52 < v51) {
                  break;
                }
                unsigned int v53 = *((_DWORD *)v23 + 17);
                unsigned int v54 = v53 <= 4 ? 0 : (v53 + 1) & 0xFFFFFFFE;
                unsigned int v55 = *((_DWORD *)v13 + 17);
                if (v55 < 5 || ((v55 + 1) & 0xFFFFFFFE) <= v54) {
                  break;
                }
              }
              ++v50;
            }
            while (1)
            {
              unsigned int v57 = *--v49;
              unsigned int v48 = v57;
              unsigned int v58 = _TAG::priority(v57);
              if (v58 > v51) {
                break;
              }
              if (v58 >= v51)
              {
                unsigned int v59 = *((_DWORD *)v48 + 17);
                unsigned int v60 = v59 <= 4 ? 0 : (v59 + 1) & 0xFFFFFFFE;
                unsigned int v61 = *((_DWORD *)v13 + 17);
                if (v61 >= 5 && ((v61 + 1) & 0xFFFFFFFE) > v60) {
                  break;
                }
              }
            }
          }
          while (v50 < v49);
          uint64_t v29 = v50 - 1;
        }
        if (v29 != v217) {
          *v217 = *v29;
        }
        *uint64_t v29 = v13;
        if (v30 >= (unint64_t)v31) {
          break;
        }
LABEL_92:
        CFDataRef result = std::__introsort<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **,false>(v217, v29, a3, a4 & 1);
        a4 = 0;
        CFIndex v7 = v29 + 1;
      }
      BOOL v63 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v217, v29);
      CFIndex v7 = v29 + 1;
      CFDataRef result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(v29 + 1, a2);
      if (result) {
        break;
      }
      if (!v63) {
        goto LABEL_92;
      }
    }
    a2 = v29;
    CFIndex v7 = v217;
    if (!v63) {
      continue;
    }
    return result;
  }
}

uint64_t std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **,0>(_TAG **a1, _TAG **a2, _TAG **a3, _TAG **a4, _TAG **a5)
{
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(a1, a2, a3, a4);
  unint64_t v10 = *a5;
  uint64_t v11 = *a4;
  unsigned int v12 = _TAG::priority(*a5);
  uint64_t result = _TAG::priority(v11);
  if (v12 > result
    || v12 >= result
    && ((v27 = *((_DWORD *)v10 + 17), v27 <= 4) ? (unsigned int v28 = 0) : (unsigned int v28 = (v27 + 1) & 0xFFFFFFFE),
        (unsigned int v29 = *((_DWORD *)v11 + 17), v29 >= 5) ? (v30 = ((v29 + 1) & 0xFFFFFFFE) > v28) : (v30 = 0),
        v30))
  {
    *a4 = v10;
    *a5 = v11;
    uint64_t v14 = *a4;
    unsigned int v15 = *a3;
    unsigned int v16 = _TAG::priority(*a4);
    uint64_t result = _TAG::priority(v15);
    if (v16 > result
      || v16 >= result
      && ((unsigned int v17 = *((_DWORD *)v14 + 17), v17 <= 4) ? (v18 = 0) : (v18 = (v17 + 1) & 0xFFFFFFFE),
          (unsigned int v19 = *((_DWORD *)v15 + 17), v19 >= 5) ? (v20 = ((v19 + 1) & 0xFFFFFFFE) > v18) : (v20 = 0),
          v20))
    {
      *a3 = v14;
      *a4 = v15;
      unsigned int v21 = *a3;
      uint64_t v22 = *a2;
      unsigned int v23 = _TAG::priority(*a3);
      uint64_t result = _TAG::priority(v22);
      if (v23 > result
        || v23 >= result
        && ((unsigned int v31 = *((_DWORD *)v21 + 17), v31 <= 4) ? (v32 = 0) : (v32 = (v31 + 1) & 0xFFFFFFFE),
            (unsigned int v33 = *((_DWORD *)v22 + 17), v33 >= 5) && ((v33 + 1) & 0xFFFFFFFE) > v32))
      {
        *a2 = v21;
        *a3 = v22;
        unsigned int v24 = *a2;
        unsigned int v25 = *a1;
        unsigned int v26 = _TAG::priority(*a2);
        uint64_t result = _TAG::priority(v25);
        if (v26 > result
          || v26 >= result
          && ((unsigned int v34 = *((_DWORD *)v24 + 17), v34 <= 4) ? (v35 = 0) : (v35 = (v34 + 1) & 0xFFFFFFFE),
              (unsigned int v36 = *((_DWORD *)v25 + 17), v36 >= 5) && ((v36 + 1) & 0xFFFFFFFE) > v35))
        {
          *a1 = v24;
          *a2 = v25;
        }
      }
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(_TAG **a1, _TAG **a2, _TAG **a3)
{
  uint64_t v6 = *a2;
  CFIndex v7 = *a1;
  unsigned int v8 = _TAG::priority(*a2);
  unsigned int v9 = _TAG::priority(v7);
  if (v8 > v9
    || v8 >= v9
    && ((unsigned int v18 = *((_DWORD *)v6 + 17), v18 <= 4) ? (v19 = 0) : (v19 = (v18 + 1) & 0xFFFFFFFE),
        (unsigned int v20 = *((_DWORD *)v7 + 17), v20 >= 5) ? (v21 = ((v20 + 1) & 0xFFFFFFFE) > v19) : (v21 = 0),
        v21))
  {
    unint64_t v10 = *a3;
    uint64_t result = _TAG::priority(*a3);
    if (result > v8
      || result >= v8
      && ((unsigned int v12 = *((_DWORD *)v10 + 17), v12 <= 4) ? (v13 = 0) : (v13 = (v12 + 1) & 0xFFFFFFFE),
          (v14 = *((_DWORD *)v6 + 17), v14 >= 5) ? (BOOL v15 = ((v14 + 1) & 0xFFFFFFFE) > v13) : (BOOL v15 = 0),
          v15))
    {
      *a1 = v10;
    }
    else
    {
      *a1 = v6;
      *a2 = v7;
      unsigned int v16 = *a3;
      unsigned int v17 = _TAG::priority(*a3);
      uint64_t result = _TAG::priority(v7);
      if (v17 <= result)
      {
        if (v17 < result) {
          return result;
        }
        unsigned int v30 = *((_DWORD *)v16 + 17);
        unsigned int v31 = v30 <= 4 ? 0 : (v30 + 1) & 0xFFFFFFFE;
        unsigned int v32 = *((_DWORD *)v7 + 17);
        if (v32 < 5 || ((v32 + 1) & 0xFFFFFFFE) <= v31) {
          return result;
        }
      }
      *a2 = v16;
    }
    *a3 = v7;
    return result;
  }
  uint64_t v22 = *a3;
  uint64_t result = _TAG::priority(*a3);
  if (result > v8
    || result >= v8
    && ((unsigned int v23 = *((_DWORD *)v22 + 17), v23 <= 4) ? (v24 = 0) : (v24 = (v23 + 1) & 0xFFFFFFFE),
        (unsigned int v25 = *((_DWORD *)v6 + 17), v25 >= 5) ? (v26 = ((v25 + 1) & 0xFFFFFFFE) > v24) : (v26 = 0),
        v26))
  {
    *a2 = v22;
    *a3 = v6;
    unsigned int v27 = *a2;
    unsigned int v28 = *a1;
    unsigned int v29 = _TAG::priority(*a2);
    uint64_t result = _TAG::priority(v28);
    if (v29 > result
      || v29 >= result
      && ((v33 = *((_DWORD *)v27 + 17), v33 <= 4) ? (unsigned int v34 = 0) : (unsigned int v34 = (v33 + 1) & 0xFFFFFFFE),
          (unsigned int v35 = *((_DWORD *)v28 + 17), v35 >= 5) && ((v35 + 1) & 0xFFFFFFFE) > v34))
    {
      *a1 = v27;
      *a2 = v28;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(_TAG **a1, _TAG **a2)
{
  CFDataRef v2 = a2;
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      CFIndex v7 = *a1;
      unsigned int v8 = _TAG::priority(v6);
      unsigned int v9 = _TAG::priority(v7);
      if (v8 > v9
        || v8 >= v9
        && ((unsigned int v10 = *((_DWORD *)v6 + 17), v10 <= 4) ? (v11 = 0) : (v11 = (v10 + 1) & 0xFFFFFFFE),
            (unsigned int v12 = *((_DWORD *)v7 + 17), v12 >= 5) ? (v13 = ((v12 + 1) & 0xFFFFFFFE) > v11) : (v13 = 0),
            v13))
      {
        *a1 = v6;
        *(v2 - 1) = v7;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      unsigned int v14 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(a1, a1 + 1, a1 + 2);
      BOOL v15 = a1 + 3;
      if (a1 + 3 == v2) {
        return 1;
      }
      uint64_t v16 = 0;
      int v17 = 0;
      unsigned int v35 = v2;
      break;
  }
  while (1)
  {
    unsigned int v18 = *v15;
    unsigned int v19 = *v14;
    unsigned int v20 = _TAG::priority(*v15);
    unsigned int v21 = _TAG::priority(v19);
    if (v20 > v21
      || v20 >= v21
      && ((v22 = *((_DWORD *)v18 + 17), v22 <= 4) ? (unsigned int v23 = 0) : (unsigned int v23 = (v22 + 1) & 0xFFFFFFFE),
          (unsigned int v24 = *((_DWORD *)v19 + 17), v24 >= 5) ? (v25 = ((v24 + 1) & 0xFFFFFFFE) > v23) : (v25 = 0),
          v25))
    {
      *BOOL v15 = v19;
      BOOL v26 = a1;
      if (v14 != a1)
      {
        uint64_t v27 = v16;
        do
        {
          unsigned int v28 = *(_TAG **)((char *)a1 + v27 + 8);
          unsigned int v29 = _TAG::priority(v18);
          unsigned int v30 = _TAG::priority(v28);
          if (v29 <= v30)
          {
            if (v29 < v30)
            {
              BOOL v26 = v14;
              goto LABEL_40;
            }
            unsigned int v31 = *((_DWORD *)v18 + 17);
            unsigned int v32 = v31 <= 4 ? 0 : (v31 + 1) & 0xFFFFFFFE;
            unsigned int v33 = *((_DWORD *)v28 + 17);
            if (v33 < 5 || ((v33 + 1) & 0xFFFFFFFE) <= v32)
            {
              BOOL v26 = (_TAG **)((char *)a1 + v27 + 16);
              goto LABEL_40;
            }
          }
          --v14;
          *(_TAG **)((char *)a1 + v27 + 16) = v28;
          v27 -= 8;
        }
        while (v27 != -16);
        BOOL v26 = a1;
LABEL_40:
        CFDataRef v2 = v35;
      }
      *BOOL v26 = v18;
      if (++v17 == 8) {
        return v15 + 1 == v2;
      }
    }
    unsigned int v14 = v15;
    v16 += 8;
    if (++v15 == v2) {
      return 1;
    }
  }
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(_TAG **a1, _TAG **a2, _TAG **a3, _TAG **a4)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortPriority(void)::$_0 &,_TAG **>(a1, a2, a3);
  unsigned int v8 = *a4;
  unsigned int v9 = *a3;
  unsigned int v10 = _TAG::priority(*a4);
  uint64_t result = _TAG::priority(v9);
  if (v10 > result
    || v10 >= result
    && ((unsigned int v12 = *((_DWORD *)v8 + 17), v12 <= 4) ? (v13 = 0) : (v13 = (v12 + 1) & 0xFFFFFFFE),
        (v14 = *((_DWORD *)v9 + 17), v14 >= 5) ? (BOOL v15 = ((v14 + 1) & 0xFFFFFFFE) > v13) : (BOOL v15 = 0),
        v15))
  {
    *a3 = v8;
    *a4 = v9;
    uint64_t v16 = *a3;
    int v17 = *a2;
    unsigned int v18 = _TAG::priority(*a3);
    uint64_t result = _TAG::priority(v17);
    if (v18 > result
      || v18 >= result
      && ((unsigned int v19 = *((_DWORD *)v16 + 17), v19 <= 4) ? (v20 = 0) : (v20 = (v19 + 1) & 0xFFFFFFFE),
          (unsigned int v21 = *((_DWORD *)v17 + 17), v21 >= 5) ? (v22 = ((v21 + 1) & 0xFFFFFFFE) > v20) : (v22 = 0),
          v22))
    {
      *a2 = v16;
      *a3 = v17;
      unsigned int v23 = *a2;
      unsigned int v24 = *a1;
      unsigned int v25 = _TAG::priority(*a2);
      uint64_t result = _TAG::priority(v24);
      if (v25 > result
        || v25 >= result
        && ((unsigned int v26 = *((_DWORD *)v23 + 17), v26 <= 4) ? (v27 = 0) : (v27 = (v26 + 1) & 0xFFFFFFFE),
            (unsigned int v28 = *((_DWORD *)v24 + 17), v28 >= 5) && ((v28 + 1) & 0xFFFFFFFE) > v27))
      {
        *a1 = v23;
        *a2 = v24;
      }
    }
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **,false>(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  unsigned int v9 = (uint64_t *)result;
  while (2)
  {
    unsigned int v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unsigned int v9 = v10;
          uint64_t v11 = (char *)a2 - (char *)v10;
          unint64_t v12 = a2 - v10;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                uint64_t v40 = *(a2 - 1);
                uint64_t v41 = *v10;
                if (*(unsigned __int16 *)(v40 + 40) < *(unsigned __int16 *)(*v10 + 40))
                {
                  *unsigned int v10 = v40;
                  *(a2 - 1) = v41;
                }
                break;
              case 3uLL:
                uint64_t result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v10, v10 + 1, a2 - 1);
                break;
              case 4uLL:
                uint64_t result = (uint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v10, v10 + 1, v10 + 2, a2 - 1);
                break;
              case 5uLL:
                unsigned int v42 = v10 + 1;
                unsigned int v43 = v10 + 2;
                unsigned int v44 = v10 + 3;
                uint64_t result = (uint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v10, v10 + 1, v10 + 2, v10 + 3);
                uint64_t v45 = *(a2 - 1);
                uint64_t v46 = v10[3];
                if (*(unsigned __int16 *)(v45 + 40) < *(unsigned __int16 *)(v46 + 40))
                {
                  *unsigned int v44 = v45;
                  *(a2 - 1) = v46;
                  uint64_t v47 = *v44;
                  uint64_t v48 = *v43;
                  unsigned int v49 = *(unsigned __int16 *)(*v44 + 40);
                  if (v49 < *(unsigned __int16 *)(*v43 + 40))
                  {
                    *unsigned int v43 = v47;
                    *unsigned int v44 = v48;
                    uint64_t v50 = *v42;
                    if (v49 < *(unsigned __int16 *)(*v42 + 40))
                    {
                      v10[1] = v47;
                      v10[2] = v50;
                      uint64_t v51 = *v10;
                      if (v49 < *(unsigned __int16 *)(*v10 + 40))
                      {
                        *unsigned int v10 = v47;
                        v10[1] = v51;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            unsigned int v52 = v10 + 1;
            BOOL v54 = v10 == a2 || v52 == a2;
            if (a4)
            {
              if (!v54)
              {
                uint64_t v55 = 0;
                __int16 v56 = v10;
                do
                {
                  uint64_t v58 = *v56;
                  uint64_t v57 = v56[1];
                  __int16 v56 = v52;
                  unsigned int v59 = *(unsigned __int16 *)(v57 + 40);
                  if (v59 < *(unsigned __int16 *)(v58 + 40))
                  {
                    uint64_t v60 = v55;
                    while (1)
                    {
                      *(uint64_t *)((char *)v10 + v60 + 8) = v58;
                      if (!v60) {
                        break;
                      }
                      uint64_t v58 = *(uint64_t *)((char *)v10 + v60 - 8);
                      v60 -= 8;
                      if (v59 >= *(unsigned __int16 *)(v58 + 40))
                      {
                        unsigned int v61 = (uint64_t *)((char *)v10 + v60 + 8);
                        goto LABEL_85;
                      }
                    }
                    unsigned int v61 = v10;
LABEL_85:
                    *unsigned int v61 = v57;
                  }
                  unsigned int v52 = v56 + 1;
                  v55 += 8;
                }
                while (v56 + 1 != a2);
              }
            }
            else if (!v54)
            {
              do
              {
                uint64_t v92 = *v9;
                uint64_t v91 = v9[1];
                unsigned int v9 = v52;
                unsigned int v93 = *(unsigned __int16 *)(v91 + 40);
                if (v93 < *(unsigned __int16 *)(v92 + 40))
                {
                  do
                  {
                    *unsigned int v52 = v92;
                    uint64_t v92 = *(v52 - 2);
                    --v52;
                  }
                  while (v93 < *(unsigned __int16 *)(v92 + 40));
                  *unsigned int v52 = v91;
                }
                unsigned int v52 = v9 + 1;
              }
              while (v9 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v62 = (v12 - 2) >> 1;
              int64_t v63 = v62;
              do
              {
                int64_t v64 = v63;
                if (v62 >= v63)
                {
                  uint64_t v65 = (2 * v63) | 1;
                  char v66 = &v10[v65];
                  uint64_t v67 = *v66;
                  if (2 * v64 + 2 < (uint64_t)v12)
                  {
                    uint64_t result = *(unsigned __int16 *)(v67 + 40);
                    if (result < *(unsigned __int16 *)(v66[1] + 40))
                    {
                      uint64_t v67 = v66[1];
                      ++v66;
                      uint64_t v65 = 2 * v64 + 2;
                    }
                  }
                  unsigned int v68 = &v10[v64];
                  uint64_t v69 = *v68;
                  unsigned int v70 = *(unsigned __int16 *)(*v68 + 40);
                  if (*(unsigned __int16 *)(v67 + 40) >= v70)
                  {
                    do
                    {
                      int16x8_t v71 = v66;
                      *unsigned int v68 = v67;
                      if (v62 < v65) {
                        break;
                      }
                      uint64_t result = (2 * v65) | 1;
                      char v66 = &v10[result];
                      uint64_t v72 = 2 * v65 + 2;
                      uint64_t v67 = *v66;
                      if (v72 < (uint64_t)v12
                        && *(unsigned __int16 *)(v67 + 40) < *(unsigned __int16 *)(v66[1] + 40))
                      {
                        uint64_t v67 = v66[1];
                        ++v66;
                        uint64_t result = v72;
                      }
                      unsigned int v68 = v71;
                      uint64_t v65 = result;
                    }
                    while (*(unsigned __int16 *)(v67 + 40) >= v70);
                    *int16x8_t v71 = v69;
                  }
                }
                int64_t v63 = v64 - 1;
              }
              while (v64);
              uint64_t v73 = (unint64_t)v11 >> 3;
              do
              {
                uint64_t v74 = 0;
                uint64_t v75 = *v10;
                unsigned int v76 = v10;
                do
                {
                  unsigned int v77 = &v76[v74];
                  uint64_t v80 = v77[1];
                  unsigned int v78 = v77 + 1;
                  uint64_t v79 = v80;
                  uint64_t v81 = (2 * v74) | 1;
                  uint64_t v82 = 2 * v74 + 2;
                  if (v82 < v73)
                  {
                    uint64_t result = *(unsigned __int16 *)(v79 + 40);
                    if (result < *(unsigned __int16 *)(v78[1] + 40))
                    {
                      uint64_t v79 = v78[1];
                      ++v78;
                      uint64_t v81 = v82;
                    }
                  }
                  *unsigned int v76 = v79;
                  unsigned int v76 = v78;
                  uint64_t v74 = v81;
                }
                while (v81 <= (uint64_t)((unint64_t)(v73 - 2) >> 1));
                if (v78 == --a2)
                {
                  *unsigned int v78 = v75;
                }
                else
                {
                  *unsigned int v78 = *a2;
                  *a2 = v75;
                  uint64_t v83 = (char *)v78 - (char *)v10 + 8;
                  if (v83 >= 9)
                  {
                    unint64_t v84 = (((unint64_t)v83 >> 3) - 2) >> 1;
                    int v85 = &v10[v84];
                    uint64_t v86 = *v85;
                    uint64_t v87 = *v78;
                    unsigned int v88 = *(unsigned __int16 *)(*v78 + 40);
                    if (*(unsigned __int16 *)(*v85 + 40) < v88)
                    {
                      do
                      {
                        unsigned int v89 = v85;
                        *unsigned int v78 = v86;
                        if (!v84) {
                          break;
                        }
                        unint64_t v84 = (v84 - 1) >> 1;
                        int v85 = &v10[v84];
                        uint64_t v86 = *v85;
                        unsigned int v78 = v89;
                      }
                      while (*(unsigned __int16 *)(*v85 + 40) < v88);
                      *unsigned int v89 = v87;
                    }
                  }
                }
              }
              while (v73-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          unsigned int v14 = &v10[v12 >> 1];
          if ((unint64_t)v11 >= 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v9, &v9[v12 >> 1], a2 - 1);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v9 + 1, v14 - 1, a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v9 + 2, &v9[v13 + 1], a2 - 3);
            uint64_t result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v14 - 1, v14, &v9[v13 + 1]);
            uint64_t v15 = *v9;
            *unsigned int v9 = *v14;
            *unsigned int v14 = v15;
          }
          else
          {
            uint64_t result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(&v9[v12 >> 1], v9, a2 - 1);
          }
          --a3;
          uint64_t v16 = *v9;
          if (a4) {
            break;
          }
          unsigned int v17 = *(unsigned __int16 *)(v16 + 40);
          if (*(unsigned __int16 *)(*(v9 - 1) + 40) < v17) {
            goto LABEL_13;
          }
          if (v17 >= *(unsigned __int16 *)(*(a2 - 1) + 40))
          {
            unsigned int v32 = v9 + 1;
            do
            {
              unsigned int v10 = v32;
              if (v32 >= a2) {
                break;
              }
              ++v32;
            }
            while (v17 >= *(unsigned __int16 *)(*v10 + 40));
          }
          else
          {
            unsigned int v10 = v9;
            do
            {
              uint64_t v31 = v10[1];
              ++v10;
            }
            while (v17 >= *(unsigned __int16 *)(v31 + 40));
          }
          unsigned int v33 = a2;
          if (v10 < a2)
          {
            unsigned int v33 = a2;
            do
              uint64_t v34 = *--v33;
            while (v17 < *(unsigned __int16 *)(v34 + 40));
          }
          if (v10 < v33)
          {
            uint64_t v35 = *v10;
            uint64_t v36 = *v33;
            do
            {
              *unsigned int v10 = v36;
              uint64_t *v33 = v35;
              do
              {
                uint64_t v37 = v10[1];
                ++v10;
                uint64_t v35 = v37;
              }
              while (v17 >= *(unsigned __int16 *)(v37 + 40));
              do
              {
                uint64_t v38 = *--v33;
                uint64_t v36 = v38;
              }
              while (v17 < *(unsigned __int16 *)(v38 + 40));
            }
            while (v10 < v33);
          }
          unsigned int v39 = v10 - 1;
          BOOL v4 = v10 - 1 >= v9;
          BOOL v5 = v10 - 1 == v9;
          if (v10 - 1 != v9) {
            *unsigned int v9 = *v39;
          }
          a4 = 0;
          uint64_t *v39 = v16;
        }
        unsigned int v17 = *(unsigned __int16 *)(v16 + 40);
LABEL_13:
        uint64_t v18 = 0;
        do
          uint64_t v19 = v9[++v18];
        while (*(unsigned __int16 *)(v19 + 40) < v17);
        unsigned int v20 = &v9[v18];
        unsigned int v21 = a2;
        if (v18 == 1)
        {
          unsigned int v21 = a2;
          do
          {
            if (v20 >= v21) {
              break;
            }
            uint64_t v23 = *--v21;
          }
          while (*(unsigned __int16 *)(v23 + 40) >= v17);
        }
        else
        {
          do
            uint64_t v22 = *--v21;
          while (*(unsigned __int16 *)(v22 + 40) >= v17);
        }
        if (v20 >= v21)
        {
          unsigned int v29 = v20 - 1;
        }
        else
        {
          uint64_t v24 = *v21;
          unsigned int v25 = v21;
          unsigned int v26 = &v9[v18];
          do
          {
            *unsigned int v26 = v24;
            *unsigned int v25 = v19;
            do
            {
              uint64_t v27 = v26[1];
              ++v26;
              uint64_t v19 = v27;
            }
            while (*(unsigned __int16 *)(v27 + 40) < v17);
            do
            {
              uint64_t v28 = *--v25;
              uint64_t v24 = v28;
            }
            while (*(unsigned __int16 *)(v28 + 40) >= v17);
          }
          while (v26 < v25);
          unsigned int v29 = v26 - 1;
        }
        if (v29 != v9) {
          *unsigned int v9 = *v29;
        }
        *unsigned int v29 = v16;
        if (v20 >= v21) {
          break;
        }
LABEL_34:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **,false>(v9, v29, a3, a4 & 1);
        a4 = 0;
        unsigned int v10 = v29 + 1;
      }
      BOOL v30 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v9, v29);
      unsigned int v10 = v29 + 1;
      uint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(v29 + 1, a2);
      if (result) {
        break;
      }
      if (!v30) {
        goto LABEL_34;
      }
    }
    a2 = v29;
    if (!v30) {
      continue;
    }
    return result;
  }
}

uint64_t *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  unsigned int v5 = *(unsigned __int16 *)(*a2 + 40);
  unsigned int v6 = *(unsigned __int16 *)(*result + 40);
  uint64_t v7 = *a3;
  unsigned int v8 = *(unsigned __int16 *)(*a3 + 40);
  if (v5 >= v6)
  {
    if (v8 < v5)
    {
      *a2 = v7;
      *a3 = v3;
      uint64_t v9 = *result;
      if (*(unsigned __int16 *)(*a2 + 40) < *(unsigned __int16 *)(*result + 40))
      {
        *uint64_t result = *a2;
        *a2 = v9;
      }
    }
  }
  else
  {
    if (v8 >= v5)
    {
      *uint64_t result = v3;
      *a2 = v4;
      if (*(unsigned __int16 *)(*a3 + 40) >= v6) {
        return result;
      }
      *a2 = *a3;
    }
    else
    {
      *uint64_t result = v7;
    }
    *a3 = v4;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      if (*(unsigned __int16 *)(v6 + 40) < *(unsigned __int16 *)(*a1 + 40))
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      uint64_t v18 = a1 + 1;
      uint64_t v19 = a1 + 2;
      unsigned int v20 = a1 + 3;
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(a1, a1 + 1, a1 + 2, a1 + 3);
      uint64_t v21 = *(a2 - 1);
      uint64_t v22 = a1[3];
      if (*(unsigned __int16 *)(v21 + 40) < *(unsigned __int16 *)(v22 + 40))
      {
        *unsigned int v20 = v21;
        *(a2 - 1) = v22;
        uint64_t v23 = *v20;
        uint64_t v24 = *v19;
        unsigned int v25 = *(unsigned __int16 *)(*v20 + 40);
        if (v25 < *(unsigned __int16 *)(*v19 + 40))
        {
          *uint64_t v19 = v23;
          *unsigned int v20 = v24;
          uint64_t v26 = *v18;
          if (v25 < *(unsigned __int16 *)(*v18 + 40))
          {
            a1[1] = v23;
            a1[2] = v26;
            uint64_t v27 = *a1;
            if (v25 < *(unsigned __int16 *)(*a1 + 40))
            {
              *a1 = v23;
              a1[1] = v27;
            }
          }
        }
      }
      return 1;
    default:
      unsigned int v8 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(a1, a1 + 1, a1 + 2);
      uint64_t v9 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v10 = 0;
      uint64_t v11 = 24;
      break;
  }
  while (1)
  {
    uint64_t v12 = *v9;
    uint64_t v13 = *v8;
    unsigned int v14 = *(unsigned __int16 *)(*v9 + 40);
    if (v14 < *(unsigned __int16 *)(*v8 + 40))
    {
      uint64_t v15 = v11;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v15) = v13;
        uint64_t v16 = v15 - 8;
        if (v15 == 8) {
          break;
        }
        uint64_t v13 = *(uint64_t *)((char *)a1 + v15 - 16);
        v15 -= 8;
        if (v14 >= *(unsigned __int16 *)(v13 + 40))
        {
          unsigned int v17 = (uint64_t *)((char *)a1 + v16);
          goto LABEL_13;
        }
      }
      unsigned int v17 = a1;
LABEL_13:
      *unsigned int v17 = v12;
      if (++v10 == 8) {
        return v9 + 1 == a2;
      }
    }
    unsigned int v8 = v9;
    v11 += 8;
    if (++v9 == a2) {
      return 1;
    }
  }
}

uint64_t *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,_TAGList::sortTagID(void)::$_0 &,_TAG **>(a1, a2, a3);
  uint64_t v9 = *a3;
  if (*(unsigned __int16 *)(*a4 + 40) < *(unsigned __int16 *)(*a3 + 40))
  {
    *a3 = *a4;
    *a4 = v9;
    uint64_t v10 = *a2;
    if (*(unsigned __int16 *)(*a3 + 40) < *(unsigned __int16 *)(*a2 + 40))
    {
      *a2 = *a3;
      *a3 = v10;
      uint64_t v11 = *a1;
      if (*(unsigned __int16 *)(*a2 + 40) < *(unsigned __int16 *)(*a1 + 40))
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

void IIOMemoryHash::~IIOMemoryHash(IIOMemoryHash *this)
{
  *(void *)this = &unk_1ED4DFD98;
  std::__tree<unsigned long long>::destroy((uint64_t)this + 8, *((void **)this + 2));
}

{
  uint64_t vars8;

  *(void *)this = &unk_1ED4DFD98;
  std::__tree<unsigned long long>::destroy((uint64_t)this + 8, *((void **)this + 2));

  JUMPOUT(0x18C11C0E0);
}

uint64_t _ImageIO_AccreditMemory(uint64_t a1, uint64_t a2)
{
  pthread_mutex_lock(&gImageIOMemoryHashLock);
  if (gMemoryHashCreateOnce != -1) {
    dispatch_once(&gMemoryHashCreateOnce, &__block_literal_global_31);
  }
  unint64_t v5 = ~a1;
  uint64_t v6 = &v5;
  std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>((uint64_t **)(gIIOMemoryHash + 8), &v5, (uint64_t)&std::piecewise_construct, (uint64_t **)&v6)[5] = a2;
  ImageIORecordMemory(a1, a2);
  return pthread_mutex_unlock(&gImageIOMemoryHashLock);
}

uint64_t IIO_ImageBlockSetRelease(const void *a1)
{
  if ((gIIODebugFlags & 0xC00) != 0)
  {
    ImageIOLog("    CGImageBlockSetRelease:   %14p [%ld]\n", a1, gBlockSetCount);
    if ((gIIODebugFlags & 0x800) != 0) {
      IIODebug_ShowBacktrace(2);
    }
  }

  return CGImageBlockSetRelease();
}

const char *IIO_ImageBlockSetReleased(const char *result)
{
  if ((gIIODebugFlags & 0xC00) != 0)
  {
    atomic_fetch_add_explicit(&gBlockSetCount, 0xFFFFFFFF, memory_order_relaxed);
    BOOL result = ImageIOLog("    CGImageBlockSetReleaseCB:                  info: %14p                        S-[%2ld]\n", result, gBlockSetCount);
    if ((gIIODebugFlags & 0x800) != 0)
    {
      return IIODebug_ShowBacktrace(2);
    }
  }
  return result;
}

const char *IIO_ImageBlockReleased(const char *result, const void *a2)
{
  if ((gIIODebugFlags & 0xC00) != 0)
  {
    atomic_fetch_add_explicit(&gBlockCount, 0xFFFFFFFF, memory_order_relaxed);
    BOOL result = ImageIOLog("    CGImageBlockReleaseCB:    %14p - info: %14p                        B-[%2ld]\n", a2, result, gBlockCount);
    if ((gIIODebugFlags & 0x800) != 0)
    {
      return IIODebug_ShowBacktrace(2);
    }
  }
  return result;
}

void IIOImageRead::IIOImageRead(IIOImageRead *this, int a2, const char *a3, unint64_t a4, char a5, char a6)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ED4DF1B0;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 31) = 0;
  *((void *)this + 30) = (char *)this + 248;
  *((void *)this + 32) = 0;
  *((void *)this + 37) = 0;
  *((void *)this + 38) = 0;
  *((void *)this + 36) = 0;
  IIOImageRead::setup((uint64_t)this, 7);
  *((_DWORD *)this + 6) = a2;
  *((void *)this + 10) = a4;
  *((unsigned char *)this + 64) = a6;
  *((unsigned char *)this + 65) = a6 ^ 1;
  *((unsigned char *)this + 66) = 1;
  bzero(&v13, 0x878uLL);
  if (statfs(a3, &v13))
  {
    if (a4 >= 0x1000) {
      size_t f_iosize = 4096;
    }
    else {
      size_t f_iosize = a4;
    }
  }
  else if (v13.f_iosize >= a4)
  {
    size_t f_iosize = a4;
  }
  else
  {
    size_t f_iosize = v13.f_iosize;
  }
  *((void *)this + 34) = f_iosize;
  if ((gIIODebugFlags & 0xC00000) != 0)
  {
    ImageIOLog("    %s: _fileBufferSize: %8ld  stat.f_iosize: %8ld  filesize: %8ld  file: '%s'", "IIOImageRead", f_iosize, v13.f_iosize, a4, a3);
    size_t f_iosize = *((void *)this + 34);
  }
  *((unsigned char *)this + 71) = a5;
  *((void *)this + 35) = -1;
  *((void *)this + 33) = malloc_type_malloc(f_iosize, 0xAEF267FFuLL);
}

void sub_1887A1DD4(_Unwind_Exception *a1)
{
  uint64_t v6 = (void *)v1[36];
  if (v6)
  {
    v1[37] = v6;
    operator delete(v6);
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(v2, *v4);
  uint64_t v7 = *v3;
  if (*v3)
  {
    v1[20] = v7;
    operator delete(v7);
  }
  _Unwind_Resume(a1);
}

void IIOImageRead::IIOImageRead(IIOImageRead *this, CGDataProvider *a2, char a3)
{
  *(void *)this = &unk_1ED4DF1B0;
  *((void *)this + 19) = 0;
  *((void *)this + 31) = 0;
  *((void *)this + 30) = (char *)this + 248;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 32) = 0;
  *((void *)this + 37) = 0;
  *((void *)this + 38) = 0;
  *((void *)this + 36) = 0;
  IIOImageRead::setup((uint64_t)this, 3);
  *((void *)this + 5) = CFRetain(a2);
  *((unsigned char *)this + 64) = a3;
  *((unsigned char *)this + 65) = a3 ^ 1;
  *((void *)this + 10) = CGDataProviderGetSizeOfData();
}

void sub_1887A1ECC(_Unwind_Exception *a1)
{
  uint64_t v7 = *v5;
  if (*v5)
  {
    *(void *)(v1 + 296) = v7;
    operator delete(v7);
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(v2, *v4);
  unsigned int v8 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 160) = v8;
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

void IIOImageRead::IIOImageRead(IIOImageRead *this, IIOImageRead *a2)
{
  *(void *)this = &unk_1ED4DF1B0;
  *((void *)this + 19) = 0;
  *((void *)this + 31) = 0;
  *((void *)this + 30) = (char *)this + 248;
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 32) = 0;
  *((void *)this + 37) = 0;
  *((void *)this + 38) = 0;
  *((void *)this + 36) = 0;
  IIOImageRead::setup((uint64_t)this, 9);
  if (MEMORY[0x18C11DEB0](a2) == MEMORY[0x1E4F14590])
  {
    CFDataRef DataFromXPCDict = (const __CFData *)IIOImageRead::CreateDataFromXPCDict(a2, v4);
    *((void *)this + 4) = DataFromXPCDict;
    if ((gIIODebugFlags & 0x80000000000) != 0)
    {
      ImageIOLog("D   %s:%d CreateDataFromXPCDict %p\n", "IIOImageRead", 628, DataFromXPCDict);
      CFDataRef DataFromXPCDict = (const __CFData *)*((void *)this + 4);
    }
    *((_WORD *)this + 32) = 1;
    if (DataFromXPCDict) {
      CFDataRef DataFromXPCDict = (const __CFData *)CFDataGetLength(DataFromXPCDict);
    }
    *((void *)this + 10) = DataFromXPCDict;
  }
}

void sub_1887A2000(_Unwind_Exception *a1)
{
  uint64_t v7 = *v5;
  if (*v5)
  {
    *(void *)(v1 + 296) = v7;
    operator delete(v7);
  }
  std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::destroy(v2, *v4);
  unsigned int v8 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 160) = v8;
    operator delete(v8);
  }
  _Unwind_Resume(a1);
}

const UInt8 *IIOImageRead::CreateDataFromXPCDict(IIOImageRead *this, void *a2)
{
  if (MEMORY[0x18C11DEB0](this, a2) != MEMORY[0x1E4F14590]) {
    return 0;
  }
  xpc_object_t source_dict = iio_xpc_get_source_dict(this);
  uint64_t v4 = source_dict;
  if (source_dict
    && (xpc_object_t value = xpc_dictionary_get_value(source_dict, "iio_xpc_src_shmem"),
        uint64_t uint64 = xpc_dictionary_get_uint64(v4, "iio_xpc_src_shmem_size"),
        value)
    && (unint64_t v7 = uint64) != 0)
  {
    region = 0;
    size_t v8 = xpc_shmem_map(value, &region);
    BOOL result = 0;
    if (v8 >= v7) {
      BOOL result = (const UInt8 *)CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)region, v7);
    }
  }
  else
  {
    region = 0;
    BOOL result = (const UInt8 *)xpc_dictionary_get_data(v4, "iio_xpc_src_data", (size_t *)&region);
    if (result) {
      BOOL result = (const UInt8 *)CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], result, (CFIndex)region, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    }
  }
  if (!result)
  {
    LogError("CreateDataFromXPCDict", 1980, "*** ERROR: Failed to create CFData from xpc_object_t: %p\n", this);
    return 0;
  }
  return result;
}

uint64_t IIOImageRead::getClientValueForKey@<X0>(uint64_t a1@<X0>, const void **a2@<X1>, void *a3@<X8>)
{
  uint64_t v6 = (pthread_mutex_t *)(a1 + 176);
  *a3 = 0;
  a3[1] = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 176));
  uint64_t v7 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(a1 + 240, a2);
  if (a1 + 248 != v7)
  {
    uint64_t v8 = *(void *)(v7 + 56);
    uint64_t v9 = *(void *)(v7 + 64);
    if (v9) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
    }
    *a3 = v8;
    a3[1] = v9;
  }
  return pthread_mutex_unlock(v6);
}

void sub_1887A21E4(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IIOImageRead::setClientValueForKey(uint64_t a1, long long *a2, uint64_t *a3)
{
  uint64_t v6 = (pthread_mutex_t *)(a1 + 176);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 176));
  uint64_t v12 = a2;
  uint64_t v7 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)(a1 + 240), (const void **)a2, (uint64_t)&std::piecewise_construct, &v12);
  uint64_t v9 = *a3;
  uint64_t v8 = a3[1];
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = (std::__shared_weak_count *)v7[8];
  v7[7] = v9;
  v7[8] = v8;
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  return pthread_mutex_unlock(v6);
}

void IIOBytesNoCopyDeallocate(void *a1, void *a2)
{
  if (a1) {
    free(a1);
  }
}

ssize_t IIOImageRead::getFileBytesAtOffset(IIOImageRead *this, void *__buf, unint64_t a3, size_t __nbyte)
{
  if ((gIIODebugFlags & 0x800000) != 0)
  {
    uint64_t v8 = (const void *)*((unsigned int *)this + 6);
    CFIndex Length = CFDataGetLength(*((CFDataRef *)this + 4));
    ImageIOLog("    %s:%d:  file: %p  [%8ld]  offset: 0x%08lX   size: %8ld\n", "getFileBytesAtOffset", 1415, v8, Length, a3, __nbyte);
  }
  uint64_t v10 = (void *)*((void *)this + 33);
  if (!v10) {
    return 0;
  }
  unint64_t v11 = *((void *)this + 34);
  if (!v11) {
    return 0;
  }
  unint64_t v12 = *((void *)this + 35);
  unint64_t v13 = a3 % v11;
  unint64_t v14 = a3 % v11 + __nbyte;
  if (v12 == -1 || v12 > a3)
  {
    if (v14 < v11) {
      goto LABEL_12;
    }
  }
  else if (v14 < v11)
  {
    if (v12 + v11 > a3)
    {
      unint64_t v15 = *((void *)this + 35);
LABEL_20:
      if ((gIIODebugFlags & 0xC00000) != 0) {
        ImageIOLog("    %s:   file-buffer: [%10lld - %10lld] (%10lld bytes)   request: [%10ld - %10ld] (%10ld bytes)  memcpy from buffer\n", "getFileBytesAtOffset", v15, *((void *)this + 34) + v15, *((void *)this + 34), a3, __nbyte + a3, __nbyte);
      }
      memmove(__buf, (const void *)(*((void *)this + 33) + v13), __nbyte);
      return __nbyte;
    }
LABEL_12:
    unint64_t v15 = a3 - v13;
    if (v11 >= *((void *)this + 10) - (a3 - v13)) {
      size_t v16 = *((void *)this + 10) - (a3 - v13);
    }
    else {
      size_t v16 = *((void *)this + 34);
    }
    if ((gIIODebugFlags & 0xC00000) != 0)
    {
      ImageIOLog("    %s:   file-buffer: [%10lld - %10lld] (%10lld bytes)   request: [%10ld - %10ld] (%10ld bytes)  fill buffer pread\n", "getFileBytesAtOffset", v12, v12 + v11, v11, a3, __nbyte + a3, __nbyte);
      uint64_t v10 = (void *)*((void *)this + 33);
    }
    if (pread(*((_DWORD *)this + 6), v10, v16, a3 - v13) == -1)
    {
      int v17 = *__error();
      uint64_t v18 = __error();
      uint64_t v19 = strerror(*v18);
      LogFault("getFileBytesAtOffset", 1466, "pread failed: err = %d (%s)\n", v17, v19);
    }
    *((void *)this + 35) = v15;
    goto LABEL_20;
  }
  *((void *)this + 35) = -1;
  if ((gIIODebugFlags & 0xC00000) != 0) {
    ImageIOLog("    %s:   file-buffer: [%10lld - %10lld] (%10lld bytes)   request: [%10ld - %10ld] (%10ld bytes)  size/boundary pread\n", "getFileBytesAtOffset", -1, v11 - 1, v11, a3, __nbyte + a3, __nbyte);
  }
  ssize_t v21 = pread(*((_DWORD *)this + 6), __buf, __nbyte, a3);
  return v21 & ~(v21 >> 63);
}

uint64_t IIOImageRead::removeCacheKey(uint64_t this, uint64_t a2)
{
  if (*(void *)(this + 296) != *(void *)(this + 288))
  {
    uint64_t v3 = this;
    uint64_t v4 = (pthread_mutex_t *)(this + 312);
    pthread_mutex_lock((pthread_mutex_t *)(this + 312));
    uint64_t v6 = *(long long **)(v3 + 288);
    unint64_t v5 = *(long long **)(v3 + 296);
    if (v6 != v5)
    {
      long long v7 = 0uLL;
      do
      {
        *(_OWORD *)&v15[12] = v7;
        long long key = v7;
        *(_OWORD *)unint64_t v15 = v7;
        long long v8 = *v6;
        long long v9 = v6[1];
        *(_OWORD *)&v15[12] = *(long long *)((char *)v6 + 28);
        long long key = v8;
        *(_OWORD *)unint64_t v15 = v9;
        if (WORD6(v9) == a2)
        {
          cache_remove((cache_t *)gImageBlockCache, &key);
          if ((gIIODebugFlags & 0x200) != 0)
          {
            DebugStringFromKey = createDebugStringFromKey((uint64_t)&key);
            if (DebugStringFromKey)
            {
              unint64_t v11 = DebugStringFromKey;
              ImageIOLog("    cache_remove:            %p key: %s\n", (const void *)gImageBlockCache, DebugStringFromKey);
              free(v11);
            }
          }
          unint64_t v12 = *(char **)(v3 + 296);
          int64_t v13 = v12 - ((char *)v6 + 44);
          if (v12 != (char *)v6 + 44) {
            memmove(v6, (char *)v6 + 44, v12 - ((char *)v6 + 44));
          }
          unint64_t v5 = (long long *)((char *)v6 + v13);
          *(void *)(v3 + 296) = (char *)v6 + v13;
          long long v7 = 0uLL;
        }
        else
        {
          uint64_t v6 = (long long *)((char *)v6 + 44);
        }
      }
      while (v6 != v5);
    }
    return pthread_mutex_unlock(v4);
  }
  return this;
}

uint64_t IIOImageRead::updateDataProvider(IIOImageRead *this, CGDataProvider *a2, int a3)
{
  uint64_t v6 = (pthread_mutex_t *)((char *)this + 376);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
  long long v7 = (const void *)*((void *)this + 4);
  if (v7) {
    CFRelease(v7);
  }
  long long v8 = (const void *)*((void *)this + 5);
  if (a2)
  {
    CFTypeRef v9 = CFRetain(a2);
    *((void *)this + 4) = 0;
    *((void *)this + 5) = v9;
    uint64_t SizeOfData = CGDataProviderGetSizeOfData();
  }
  else
  {
    uint64_t SizeOfData = 0;
    *((void *)this + 4) = 0;
    *((void *)this + 5) = 0;
  }
  *((void *)this + 10) = SizeOfData;
  *((unsigned char *)this + 64) = a3;
  if (a3) {
    *((unsigned char *)this + 65) = 0;
  }
  if (v8) {
    CFRelease(v8);
  }

  return pthread_mutex_unlock(v6);
}

uint64_t IIOImageRead::updateData(IIOImageRead *this, const __CFData *a2, int a3)
{
  uint64_t v6 = (pthread_mutex_t *)((char *)this + 376);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 376));
  long long v7 = (const void *)*((void *)this + 5);
  if (v7) {
    CFRelease(v7);
  }
  long long v8 = (const void *)*((void *)this + 4);
  *((void *)this + 5) = 0;
  if (a2)
  {
    *((void *)this + 4) = CFRetain(a2);
    CFIndex Length = CFDataGetLength(a2);
  }
  else
  {
    CFIndex Length = 0;
    *((void *)this + 4) = 0;
  }
  *((void *)this + 10) = Length;
  *((unsigned char *)this + 64) = a3;
  if (a3) {
    *((unsigned char *)this + 65) = 0;
  }
  if (v8) {
    CFRelease(v8);
  }

  return pthread_mutex_unlock(v6);
}

BOOL IIOImageRead::addDataToXPCDict(size_t *this, void *a2, void **a3)
{
  CFTypeRef cf = 0;
  if (MEMORY[0x18C11DEB0](a2) != MEMORY[0x1E4F14590]) {
    goto LABEL_14;
  }
  xpc_object_t v6 = iio_xpc_add_source_dict(a2);
  long long v7 = (UInt8 *)IIOImageRead::retainBytePointer((IIOImageRead *)this, (const __CFData **)&cf, 1);
  CFIndex Size = IIOImageRead::getSize((IIOImageRead *)this);
  size_t v9 = Size;
  if (v7 && !Size) {
    size_t v9 = this[10];
  }
  if (*((unsigned char *)this + 67))
  {
    xpc_object_t v10 = xpc_shmem_create(v7, v9);
    if (v10)
    {
      unint64_t v11 = v10;
      xpc_dictionary_set_value(v6, "iio_xpc_src_shmem", v10);
      xpc_dictionary_set_uint64(v6, "iio_xpc_src_shmem_size", v9);
      xpc_release(v11);
      BOOL v12 = 1;
      CFTypeRef v13 = cf;
      goto LABEL_16;
    }
    CFTypeRef v13 = cf;
    if (!cf)
    {
LABEL_15:
      BOOL v12 = 0;
      goto LABEL_16;
    }
    IIOImageRead::releaseBytePointer(0, cf);
LABEL_14:
    CFTypeRef v13 = 0;
    goto LABEL_15;
  }
  destructor[0] = MEMORY[0x1E4F143A8];
  destructor[1] = 0x40000000;
  destructor[2] = ___ZN12IIOImageRead16addDataToXPCDictEPvPS0__block_invoke;
  destructor[3] = &__block_descriptor_tmp_64_0;
  destructor[4] = this;
  destructor[5] = cf;
  unint64_t v14 = dispatch_data_create(v7, v9, 0, destructor);
  if (!v14) {
    goto LABEL_14;
  }
  unint64_t v15 = v14;
  xpc_object_t v16 = xpc_data_create_with_dispatch_data(v14);
  BOOL v12 = v16 != 0;
  if (v16)
  {
    int v17 = v16;
    xpc_dictionary_set_value(v6, "iio_xpc_src_data", v16);
    xpc_release(v17);
  }
  dispatch_release(v15);
  CFTypeRef v13 = 0;
LABEL_16:
  *a3 = (void *)v13;
  return v12;
}

void ___ZN12IIOImageRead16addDataToXPCDictEPvPS0__block_invoke(IIOImageRead *a1)
{
  uint64_t v1 = (const void *)*((void *)a1 + 5);
  if (v1) {
    IIOImageRead::releaseBytePointer(a1, v1);
  }
}

uint64_t IIOImageRead::shouldExposeMultiFrameContents(IIOImageRead *this)
{
  Source = (IIOImageSource *)CGImageSourceGetSource(~*((void *)this + 2));
  if (Source)
  {
    return IIOImageSource::shouldExposeMultiFrameContents(Source);
  }
  else
  {
    _cg_jpeg_mem_term("shouldExposeMultiFrameContents", 2094, "*** could not get 'shouldExposeMultiFrameContents' -- nil iSource\n");
    return 0;
  }
}

uint64_t IIOImageRead::useImageSequence(IIOImageRead *this)
{
  Source = (IIOImageSource *)CGImageSourceGetSource(~*((void *)this + 2));
  if (Source)
  {
    return IIOImageSource::useImageSequence(Source);
  }
  else
  {
    _cg_jpeg_mem_term("useImageSequence", 2109, "*** could not get 'useSequence' -- nil iSource\n");
    return 0;
  }
}

uint64_t CGImageReadGetTypeID()
{
  if (CGImageReadGetTypeID::once != -1) {
    dispatch_once(&CGImageReadGetTypeID::once, &__block_literal_global_76);
  }
  return CGImageReadGetTypeID::id;
}

CFStringRef _CGImageReadCopyDebugDesc(void *a1)
{
  if (a1) {
    uint64_t v1 = a1[3];
  }
  else {
    uint64_t v1 = 0;
  }
  CFAllocatorRef v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, @"<CGImageReadRef %p>%s", v1, "");
}

void std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::shared_ptr<IIOBaseObject>>,0>(uint64_t a1)
{
  CFAllocatorRef v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  if (*(char *)(a1 + 23) < 0)
  {
    uint64_t v3 = *(void **)a1;
    operator delete(v3);
  }
}

uint64_t *std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  uint64_t v11 = 0;
  xpc_object_t v6 = (uint64_t **)std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__find_equal<std::string>((uint64_t)a1, &v11, a2);
  long long v7 = *v6;
  if (!*v6)
  {
    long long v8 = v6;
    memset(v10, 0, sizeof(v10));
    std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a1, a4, v10);
    std::__tree<std::__value_type<unsigned long,unsigned long>,std::__map_value_compare<unsigned long,std::__value_type<unsigned long,unsigned long>,std::less<unsigned long>,true>,std::allocator<std::__value_type<unsigned long,unsigned long>>>::__insert_node_at(a1, v11, v8, v10[0]);
    long long v7 = v10[0];
    v10[0] = 0;
    std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,void *>>>>::reset[abi:ne180100]((uint64_t)v10, 0);
  }
  return v7;
}

void std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, long long **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  xpc_object_t v6 = operator new(0x48uLL);
  *a3 = v6;
  a3[1] = v5;
  *((unsigned char *)a3 + 16) = 0;
  long long v7 = (std::string *)(v6 + 4);
  long long v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)v8, *((void *)v8 + 1));
  }
  else
  {
    long long v9 = *v8;
    v6[6] = *((void *)v8 + 2);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v9;
  }
  v6[7] = 0;
  v6[8] = 0;
  *((unsigned char *)a3 + 16) = 1;
}

void sub_1887A2BE8(_Unwind_Exception *a1)
{
  std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,void *>>>>::reset[abi:ne180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__tree_node<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,void *>,std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  CFAllocatorRef v2 = *(void **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<std::string const,std::shared_ptr<IIOBaseObject>>,0>((uint64_t)v2 + 32);
    }
    operator delete(v2);
  }
}

void lexerror(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  __s1[0] = 0;
  __s1[1] = &a9;
  vasprintf(__s1, a2, &a9);
  xpc_object_t v10 = __s1[0];
  if (__s1[0])
  {
    if (a1)
    {
      if (!*(void *)(a1 + 16)) {
        *(void *)(a1 + 16) = strdup(__s1[0]);
      }
    }
    free(v10);
  }
}

uint64_t yy_create_buffer(uint64_t a1, int a2, uint64_t a3)
{
  xpc_object_t v6 = malloc_type_malloc(0x40uLL, 0xB53DB697uLL);
  if (!v6
    || (uint64_t v7 = (uint64_t)v6, v6[3] = a2,
                          long long v8 = malloc_type_malloc(a2 + 2, 0xB53DB697uLL),
                          (*(void *)(v7 + 8) = v8) == 0))
  {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s\n", "out of dynamic memory in yy_create_buffer()");
    exit(2);
  }
  *(_DWORD *)(v7 + 36) = 1;
  yy_init_buffer(v7, a1, a3);
  return v7;
}

int *yyrestart(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 40);
  if (v4 && (uint64_t v5 = *(void *)(a2 + 24), *(void *)(v4 + 8 * v5))
    || (yyensure_buffer_stack((void *)a2),
        uint64_t buffer = yy_create_buffer(*(void *)(a2 + 8), 0x4000, a2),
        uint64_t v5 = *(void *)(a2 + 24),
        *(void *)(*(void *)(a2 + 40) + 8 * v5) = buffer,
        (uint64_t v4 = *(void *)(a2 + 40)) != 0))
  {
    uint64_t v7 = *(void *)(v4 + 8 * v5);
  }
  else
  {
    uint64_t v7 = 0;
  }
  BOOL result = yy_init_buffer(v7, a1, a2);
  uint64_t v9 = *(void *)(a2 + 40);
  uint64_t v10 = *(void *)(a2 + 24);
  uint64_t v11 = *(void *)(v9 + 8 * v10);
  *(_DWORD *)(a2 + 52) = *(_DWORD *)(v11 + 32);
  BOOL v12 = *(unsigned char **)(v11 + 16);
  *(void *)(a2 + 64) = v12;
  *(void *)(a2 + 128) = v12;
  *(void *)(a2 + 8) = **(void **)(v9 + 8 * v10);
  *(unsigned char *)(a2 + 48) = *v12;
  return result;
}

int *yy_init_buffer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *__error();
  yy_flush_buffer(a1, a3);
  *(void *)a1 = a2;
  *(_DWORD *)(a1 + 56) = 1;
  uint64_t v7 = *(void *)(a3 + 40);
  if (v7) {
    uint64_t v7 = *(void *)(v7 + 8 * *(void *)(a3 + 24));
  }
  if (v7 != a1) {
    *(void *)(a1 + 48) = 1;
  }
  *(_DWORD *)(a1 + 40) = 0;
  BOOL result = __error();
  *BOOL result = v6;
  return result;
}

uint64_t yy_flush_buffer(uint64_t result, uint64_t a2)
{
  if (result)
  {
    *(_DWORD *)(result + 32) = 0;
    **(unsigned char **)(result + 8) = 0;
    *(unsigned char *)(*(void *)(result + 8) + 1) = 0;
    *(void *)(result + 16) = *(void *)(result + 8);
    *(_DWORD *)(result + 44) = 1;
    *(_DWORD *)(result + 60) = 0;
    uint64_t v2 = *(void *)(a2 + 40);
    if (v2) {
      uint64_t v3 = *(void *)(v2 + 8 * *(void *)(a2 + 24));
    }
    else {
      uint64_t v3 = 0;
    }
    if (v3 == result)
    {
      uint64_t v4 = *(void *)(a2 + 24);
      uint64_t v5 = *(void *)(v2 + 8 * v4);
      *(_DWORD *)(a2 + 52) = *(_DWORD *)(v5 + 32);
      int v6 = *(unsigned char **)(v5 + 16);
      *(void *)(a2 + 64) = v6;
      *(void *)(a2 + 128) = v6;
      *(void *)(a2 + 8) = **(void **)(v2 + 8 * v4);
      *(unsigned char *)(a2 + 48) = *v6;
    }
  }
  return result;
}

void yypop_buffer_state(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    uint64_t v3 = *(void ***)(v1 + 8 * *(void *)(a1 + 24));
    if (v3)
    {
      yy_delete_buffer(v3, a1);
      uint64_t v4 = *(void *)(a1 + 24);
      *(void *)(*(void *)(a1 + 40) + 8 * v4) = 0;
      if (v4) {
        *(void *)(a1 + 24) = --v4;
      }
      uint64_t v5 = *(void *)(a1 + 40);
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 8 * v4);
        if (v6)
        {
          *(_DWORD *)(a1 + 52) = *(_DWORD *)(v6 + 32);
          uint64_t v7 = *(unsigned char **)(v6 + 16);
          *(void *)(a1 + 64) = v7;
          *(void *)(a1 + 128) = v7;
          *(void *)(a1 + 8) = **(void **)(v5 + 8 * v4);
          *(unsigned char *)(a1 + 48) = *v7;
          *(_DWORD *)(a1 + 80) = 1;
        }
      }
    }
  }
}

void GIFWritePlugin::GIFWritePlugin(GIFWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 1195984416);
  *(void *)uint64_t v3 = &unk_1ED4E1100;
  *(_OWORD *)(v3 + 40) = 0u;
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_OWORD *)(v3 + 83) = 0u;
  *(void *)(v3 + 112) = 0;
  *(void *)(v3 + 120) = 0;
  *(void *)(v3 + 104) = 0;
  *(unsigned char *)(v3 + 128) = 0;
}

void GIFWritePlugin::~GIFWritePlugin(GIFWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

IIOImageWriteSession *GIFWritePlugin::gifWriteFunc(uint64_t a1, const void *a2, int a3)
{
  BOOL result = *(IIOImageWriteSession **)(a1 + 88);
  if (result) {
    return (IIOImageWriteSession *)IIOImageWriteSession::putBytes(result, a2, a3);
  }
  return result;
}

BOOL GIFWritePlugin::colorMapEntriesAreEqual(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 120);
  if (v4)
  {
    uint64_t v5 = *(void *)(v4 + 16);
    uint64_t v6 = 2 * a2;
  }
  else
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 16);
    if (!v7) {
      return 0;
    }
    uint64_t v5 = *(void *)(v7 + 16);
    uint64_t v6 = 2 * a2;
  }
  long long v8 = (__int16 *)(v5 + v6 + a2);
  __int16 v9 = *v8;
  char v15 = *((unsigned char *)v8 + 2);
  __int16 v14 = v9;
  uint64_t v10 = *(void *)(a3 + 16) + 3 * a4;
  LOBYTE(v9) = *(unsigned char *)(v10 + 2);
  __int16 v12 = *(_WORD *)v10;
  char v13 = v9;
  return RGBColorType::isCloseTo((unsigned __int8 *)&v14, (unsigned __int8 *)&v12);
}

const char *GIFWritePlugin::reduceFrame(const char *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, unint64_t *a7, unint64_t *a8, unint64_t *a9, uint64_t *a10)
{
  unint64_t v10 = *a9;
  unint64_t v11 = *a10;
  if (*a9 >= 2) {
    uint64_t v12 = 2;
  }
  else {
    uint64_t v12 = *a9;
  }
  if (v11 >= 2) {
    uint64_t v13 = 2;
  }
  else {
    uint64_t v13 = *a10;
  }
  if (!result[97]) {
    return result;
  }
  int v17 = result;
  uint64_t v43 = v12;
  uint64_t v44 = v13;
  int v18 = *((unsigned __int8 *)result + 96);
  double v19 = (double)*a7;
  unint64_t v47 = *a10;
  double v20 = (double)v11;
  double v21 = (double)*a8;
  v53.origin.x = v19;
  v53.origin.y = v21;
  v53.size.width = (double)v10;
  v53.size.vImagePixelCount height = (double)v11;
  BOOL result = (const char *)CGRectEqualToRect(v53, *(CGRect *)*((void *)result + 14));
  uint64_t v22 = a9;
  if ((result & 1) == 0 && !v17[97]) {
    goto LABEL_42;
  }
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    BOOL result = ImageIOLog("                    newRect: (%.0f, %.0f, %.0f, %.0f)\n", v19, v21, (double)v10, v20);
    uint64_t v22 = a9;
  }
  uint64_t v23 = v18 ? a2 : *(__int16 *)(*((void *)v17 + 5) + 6);
  if (v17[97])
  {
    uint64_t v24 = *((void *)v17 + 7);
    unint64_t v25 = *((void *)v17 + 11) * v10;
    uint64_t v26 = a3 + v25 * (v24 - 1);
    a3 += v25 * v24;
  }
  else
  {
    uint64_t v26 = **((void **)v17 + 13);
  }
  unint64_t v27 = *a10;
  if (!*a10) {
    goto LABEL_42;
  }
  uint64_t v49 = (uint64_t)v17;
  unint64_t v28 = 0;
  unint64_t v29 = 0;
  unint64_t v30 = 0;
  uint64_t v31 = 0;
  unint64_t v32 = v10 - 1;
  unint64_t v33 = *v22;
  unint64_t v34 = v47 - 1;
  int v35 = a4;
  unint64_t v48 = v10;
  do
  {
    if (!v33) {
      goto LABEL_39;
    }
    unint64_t v36 = 0;
    do
    {
      int v37 = *(unsigned __int8 *)(a3 + v36);
      if (a6)
      {
        int v38 = *(unsigned __int8 *)(v26 + v36);
        if (v35)
        {
          unint64_t v52 = v34;
          uint64_t v39 = a6;
          uint64_t v40 = v23;
          uint64_t v41 = v26;
          BOOL result = (const char *)GIFWritePlugin::colorMapEntriesAreEqual(v49, v38, a5, v37);
          uint64_t v22 = a9;
          unint64_t v34 = v52;
          uint64_t v26 = v41;
          uint64_t v23 = v40;
          a6 = v39;
          int v35 = a4;
          if (result) {
            goto LABEL_35;
          }
        }
        else if (v37 == v38)
        {
          goto LABEL_35;
        }
      }
      else if (v23 == v37)
      {
        goto LABEL_35;
      }
      ++v31;
      if (v36 < v32) {
        unint64_t v32 = v36;
      }
      if (v36 > v29) {
        unint64_t v29 = v36;
      }
      if (v28 < v34) {
        unint64_t v34 = v28;
      }
      if (v28 > v30) {
        unint64_t v30 = v28;
      }
LABEL_35:
      ++v36;
      unint64_t v33 = *v22;
    }
    while (v36 < *v22);
    unint64_t v10 = v48;
    unint64_t v27 = *a10;
LABEL_39:
    ++v28;
    a3 += v10;
    v26 += v10;
  }
  while (v28 < v27);
  if (v31)
  {
    *a7 = v32;
    *a8 = v34;
    unint64_t *v22 = v29 - v32 + 1;
    uint64_t v42 = v30 - v34 + 1;
    goto LABEL_43;
  }
LABEL_42:
  *a7 = v10 >> 1;
  *a8 = v47 >> 1;
  uint64_t v42 = v44;
  unint64_t *v22 = v43;
LABEL_43:
  *a10 = v42;
  return result;
}

uint64_t GIFWritePlugin::getDelayTime(GIFWritePlugin *this, const __CFDictionary *a2)
{
  if (!a2) {
    return 0;
  }
  memset(v8, 0, sizeof(v8));
  IIODictionary::IIODictionary((IIODictionary *)v8, a2);
  CFStringRef v2 = @"UnclampedDelayTime";
  if ((IIODictionary::containsKey((IIODictionary *)v8, @"UnclampedDelayTime") & 1) != 0
    || (CFStringRef v2 = @"DelayTime",
        unsigned int v3 = IIODictionary::containsKey((IIODictionary *)v8, @"DelayTime"),
        double DoubleForKey = 0.0,
        v3))
  {
    double DoubleForKey = IIODictionary::getDoubleForKey((IIODictionary *)v8, v2);
  }
  unsigned int v5 = vcvtmd_u64_f64(DoubleForKey * 100.0 + 0.5);
  if (DoubleForKey <= 0.0) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v5;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v8);
  return v6;
}

void sub_1887A3488(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t GIFWritePlugin::writeOneImage(GIFWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t GIFWritePlugin::writeSingleFrame(GIFWritePlugin *this)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  int v91 = *((unsigned __int8 *)this + 98);
  unint64_t v106 = 0;
  unint64_t v107 = 0;
  unsigned int v105 = 0;
  bzero(v108, 0x300uLL);
  v101[0] = 0;
  v101[1] = 0;
  uint64_t buffer = v108;
  PixelDataProviderAtIndex = (IIOImagePixelDataProvider *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, *((void *)this + 7));
  PropertiesAtIndex = (IIODictionary *)IIOWritePlugin::getPropertiesAtIndex((IIOImageDestination **)this, *((void *)this + 7));
  ContainerProperties = (IIODictionary *)IIOWritePlugin::getContainerProperties((IIOImagePlus **)this);
  *((unsigned char *)this + 96) = IIOImagePixelDataProvider::getAlphaInfo(PixelDataProviderAtIndex) - 3 < 2;
  size_t v4 = IIOImageSource::count(PixelDataProviderAtIndex);
  size_t v104 = v4;
  size_t v5 = IIO_Reader::testHeaderSize(PixelDataProviderAtIndex);
  uint64_t v6 = 0;
  unint64_t v103 = v5;
  uint64_t v7 = 4294967246;
  *((void *)this + 8) = v4;
  *((void *)this + 9) = v5;
  long long v8 = "no";
  if (v5)
  {
    if (v4)
    {
      SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(PixelDataProviderAtIndex);
      int Type = CGColorSpaceGetType();
      CGColorSpaceModel Model = CGColorSpaceGetModel(SourceGeomColorSpace);
      CGColorSpaceModel v11 = Model;
      uint64_t v6 = 0;
      if (Model <= kCGColorSpaceModelIndexed && ((1 << Model) & 0x23) != 0)
      {
        if (_cg_GifLastError((uint64_t)PixelDataProviderAtIndex) - 9 < 0xFFFFFFF8)
        {
          uint64_t v6 = 0;
          goto LABEL_116;
        }
        CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(PropertiesAtIndex, @"{GIF}");
        CFDictionaryRef v13 = ObjectForKey;
        if (ObjectForKey)
        {
          CFDataRef Value = (const __CFData *)CFDictionaryGetValue(ObjectForKey, @"ImageColorMap");
          CFDataRef v15 = Value;
          if (Value)
          {
            CFTypeID v16 = CFGetTypeID(Value);
            if (v16 == CFDataGetTypeID())
            {
              int Length = CFDataGetLength(v15);
              if (Length <= 770) {
                int v18 = Length / 3;
              }
              else {
                int v18 = 256;
              }
              int v19 = *((unsigned __int8 *)this + 96);
              if (v18 > 255 && v19 != 0) {
                int v18 = 255;
              }
              LODWORD(v101[0]) = v18;
              if (v18 >= 1)
              {
                v110.size_t length = 3 * v18;
                v110.location = 0;
                CFDataGetBytes(v15, v110, buffer);
                int v19 = *((unsigned __int8 *)this + 96);
              }
              if (v19)
              {
                int v21 = v101[0];
                uint64_t v22 = &buffer[3 * SLODWORD(v101[0])];
                *(_WORD *)uint64_t v22 = 0;
                v22[2] = 0;
                int v23 = v21 + 1;
                LODWORD(v101[0]) = v21 + 1;
              }
              else
              {
                int v23 = v101[0];
              }
              int v24 = v23 - 1;
              if (v23 != 1)
              {
                int v23 = 0;
                do
                {
                  ++v23;
                  BOOL v25 = v24 > 1;
                  v24 >>= 1;
                }
                while (v25);
              }
              HIDWORD(v101[0]) = v23;
            }
          }
        }
        uint64_t v6 = malloc_type_malloc(v5 * v4, 0x8BDC4AEAuLL);
        if (!v6) {
          goto LABEL_68;
        }
        uint64_t v100 = 0;
        ColorQuantization::ColorQuantization((ColorQuantization *)&v100);
        size_t v26 = IIOImagePlus::sourceImageProvider(PixelDataProviderAtIndex);
        unsigned int Error = _cg_GifLastError((uint64_t)PixelDataProviderAtIndex);
        CFStringRef v28 = (const __CFString *)*MEMORY[0x1E4F1DC98];
        CGColorSpaceRef v98 = (CGColorSpaceRef)&unk_1ED4DFD58;
        CFDictionaryRef v92 = v13;
        unsigned int v93 = v6;
        CGColorSpaceRef v99 = CGColorSpaceCreateWithName(v28);
        CFStringRef v29 = (const __CFString *)*MEMORY[0x1E4F1DC00];
        CGColorSpaceRef v96 = (CGColorSpaceRef)&unk_1ED4DFD58;
        CGColorSpaceRef v97 = CGColorSpaceCreateWithName(v29);
        unsigned int v30 = IIOImagePixelDataProvider::getBitmapInfo(PixelDataProviderAtIndex) & 0x1F;
        if (v30 == 3)
        {
          uint64_t v31 = 1;
        }
        else if (v30 == 4)
        {
          uint64_t v31 = 2;
        }
        else if (v30)
        {
          uint64_t v31 = v30;
        }
        else
        {
          uint64_t v31 = 5;
        }
        if (v11 == kCGColorSpaceModelRGB)
        {
          unint64_t v32 = v99;
          if (v26 <= 3 * v4) {
            size_t v26 = 4 * v4;
          }
        }
        else if (v11)
        {
          unint64_t v32 = 0;
        }
        else
        {
          unint64_t v32 = v97;
          size_t v26 = 2 * v4;
        }
        unint64_t v33 = malloc_type_calloc(v5, v26, 0x58370F57uLL);
        unint64_t v34 = v33;
        if (!v33)
        {
          int v50 = 4;
          CFDictionaryRef v55 = v92;
          uint64_t v6 = v93;
LABEL_67:
          IIOColorSpace::~IIOColorSpace(&v96);
          IIOColorSpace::~IIOColorSpace(&v98);
          ColorQuantization::~ColorQuantization((ColorQuantization *)&v100);
          if (v50)
          {
LABEL_68:
            uint64_t v7 = 4294967246;
            long long v8 = "no";
            goto LABEL_116;
          }
          __int16 DelayTime = GIFWritePlugin::getDelayTime(v56, v55);
          BOOL v58 = v91 != 0;
          if (!*((void *)this + 7))
          {
            if (_cg_EGifPutScreenDesc(*((void *)this + 5), v104, v103, SHIDWORD(v101[0]), 0, (int *)v101) != 1)
            {
              _cg_jpeg_mem_term("writeSingleFrame", 840, "*** EGifPutScreenDesc failed\n");
              goto LABEL_68;
            }
            if (*((void *)this + 7)
              || !IIODictionary::containsKeyGroup(ContainerProperties, @"LoopCount", @"{GIF}"))
            {
              goto LABEL_79;
            }
            unsigned int Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(ContainerProperties, @"LoopCount", @"{GIF}");
            BOOL v58 = 0;
            unsigned int v60 = Uint32ForKeyGroup << 16;
            if ((int)(Uint32ForKeyGroup << 16) >= -65535 && v60 != 0x10000)
            {
              unsigned int v61 = (uint64_t *)((char *)this + 40);
              _cg_EGifPutExtensionLeader(*((void *)this + 5), 255);
              _cg_EGifPutExtensionBlock(*((void *)this + 5), 11, "NETSCAPE2.0");
              __int16 v62 = Uint32ForKeyGroup - 1;
              if (v60 <= 0x10000) {
                __int16 v62 = Uint32ForKeyGroup;
              }
              LOBYTE(dest.data) = 1;
              BYTE1(dest.data) = v62;
              int v63 = v62;
              BYTE2(dest.data) = (unsigned __int16)(v62 + (v62 >> 23)) >> 8;
              _cg_EGifPutExtensionBlock(*v61, 3, &dest);
              _cg_EGifPutExtensionTrailer(*v61);
              if ((gIIODebugFlags & 0x30000) != 0) {
                ImageIOLog("                 loop count: %d\n", v63);
              }
LABEL_79:
              BOOL v58 = 0;
            }
          }
          int v64 = *((unsigned __int8 *)this + 96);
          *(_WORD *)((char *)&dest.data + 1) = DelayTime;
          char v65 = v105;
          BOOL v66 = v64 == 0;
          if (!v64) {
            char v65 = 0;
          }
          BYTE3(dest.data) = v65;
          char v67 = v64 | 8;
          if (v66) {
            char v67 = 4;
          }
          LOBYTE(dest.data) = v67;
          long long v8 = "no";
          if (_cg_EGifPutExtension(*((void *)this + 5), 249, 4, &dest) != 1)
          {
LABEL_114:
            uint64_t v7 = 4294967246;
            goto LABEL_116;
          }
          uint64_t v68 = *((void *)this + 7);
          if (v58)
          {
            uint64_t v69 = *((void *)this + 5);
            if (!v68)
            {
              unint64_t v73 = v106;
              unint64_t v72 = v107;
              unint64_t v75 = v103;
              unint64_t v74 = v104;
              BOOL v71 = 1;
              goto LABEL_99;
            }
            unsigned int v70 = *(void **)(v69 + 16);
            if (v70)
            {
              BOOL v71 = !RGBColorMap::equalTo(v101, v70);
              if (!*((void *)this + 7))
              {
LABEL_91:
                uint64_t v69 = *((void *)this + 5);
                unint64_t v73 = v106;
                unint64_t v72 = v107;
                unint64_t v75 = v103;
                unint64_t v74 = v104;
                if (!v71)
                {
LABEL_100:
                  unsigned int v76 = 0;
                  goto LABEL_101;
                }
LABEL_99:
                unsigned int v76 = (int *)v101;
LABEL_101:
                _cg_EGifPutImageDesc(v69, v72, v73, v74, v75, 0, v76);
                int v78 = v77;
                if ((gIIODebugFlags & 0x30000) != 0)
                {
                  ImageIOLog("      optimized image frame: (%d, %d, %d, %d)\n", v72, v73, v74, v75);
                  if ((gIIODebugFlags & 0x30000) != 0)
                  {
                    uint64_t v79 = "yes";
                    if (!v71) {
                      uint64_t v79 = "no";
                    }
                    ImageIOLog("         writeImageColorMap: %s\n", v79);
                  }
                }
                if (v78 == 1)
                {
                  if (v73 >= v75 + v73)
                  {
                    uint64_t v7 = 0;
                    long long v8 = "yes";
                    goto LABEL_116;
                  }
                  uint64_t v80 = *((void *)this + 8);
                  uint64_t v81 = **((void **)this + 13);
                  unint64_t v82 = v72 + v80 * v73;
                  while (_cg_EGifPutLine(*((void *)this + 5), &v6[v82], v74) == 1)
                  {
                    if (**((void **)this + 13)) {
                      bzero((void *)(v81 + v82), v74);
                    }
                    v82 += v80;
                    if (!--v75)
                    {
                      uint64_t v7 = 0;
                      long long v8 = "yes";
                      goto LABEL_116;
                    }
                  }
                }
                goto LABEL_114;
              }
            }
            else
            {
              BOOL v71 = 1;
            }
          }
          else
          {
            BOOL v71 = 0;
            if (!v68) {
              goto LABEL_91;
            }
          }
          *((unsigned char *)this + 97) = 0;
          if (*((unsigned char *)this + 96)) {
            GIFWritePlugin::reduceFrame((const char *)this, v105, (uint64_t)v6, v71, (uint64_t)v101, 0, &v107, &v106, &v104, (uint64_t *)&v103);
          }
          else {
            GIFWritePlugin::reduceFrame((const char *)this, v105, (uint64_t)v6, v71, (uint64_t)v101, 1, &v107, &v106, &v104, (uint64_t *)&v103);
          }
          uint64_t v69 = *((void *)this + 5);
          unint64_t v73 = v106;
          unint64_t v72 = v107;
          unint64_t v75 = v103;
          unint64_t v74 = v104;
          if (!v71) {
            goto LABEL_100;
          }
          goto LABEL_99;
        }
        if (Type != 7)
        {
          int v35 = CGBitmapContextCreate(v33, v4, v5, Error, v26, v32, v31);
          unint64_t v36 = v35;
          if (v35)
          {
            v111.origin.x = 0.0;
            v111.origin.y = 0.0;
            v111.size.width = (double)v4;
            v111.size.vImagePixelCount height = (double)v5;
            CGContextClearRect(v35, v111);
            int v37 = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, *((void *)this + 7));
            uint64_t Ref = (CGImage *)IIOImageSource::imageReadRef(v37);
            v112.origin.x = 0.0;
            v112.origin.y = 0.0;
            v112.size.width = (double)v4;
            v112.size.vImagePixelCount height = (double)v5;
            CGContextDrawImage(v36, v112, Ref);
            v113.origin.x = 0.0;
            v113.origin.y = 0.0;
            v113.size.width = (double)v4;
            v113.size.vImagePixelCount height = (double)v5;
            CGRectOffset(v113, 0.0, (double)v5);
            CGContextRelease(v36);
            goto LABEL_47;
          }
          _cg_jpeg_mem_term("writeSingleFrame", 708, "*** ERROR: CGBitmapContextCreate returned NULL\n");
        }
        uint64_t Ref = 0;
LABEL_47:
        dest.data = v34;
        dest.vImagePixelCount height = v5;
        dest.width = v4;
        dest.rowunint64_t Bytes = v26;
        uint64_t v39 = v31;
        uint64_t v6 = v93;
        if (v11 == kCGColorSpaceModelRGB)
        {
          if (v39 == 2)
          {
            vImageUnpremultiplyData_ARGB8888(&dest, &dest, 0x10u);
          }
          else if (v39 == 1)
          {
            vImageUnpremultiplyData_RGBA8888(&dest, &dest, 0x10u);
          }
        }
        if (Type == 7)
        {
          if (!Ref) {
            uint64_t Ref = (CGImage *)IIOImageSource::imageReadRef(PixelDataProviderAtIndex);
          }
          unsigned __int8 v40 = _cg_GifLastError((uint64_t)PixelDataProviderAtIndex);
          int v41 = *((unsigned __int8 *)this + 96);
          uint64_t v42 = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(PixelDataProviderAtIndex);
          int v43 = ColorQuantization::generateFromIndexedImage((int)&v100, (uint64_t)&dest, Ref, v40, v39, v41 != 0, v42, (uint64_t)v101, v93, &v105);
        }
        else if (v11)
        {
          if (v11 != kCGColorSpaceModelRGB)
          {
            free(v34);
            int v50 = 4;
LABEL_66:
            CFDictionaryRef v55 = v92;
            goto LABEL_67;
          }
          if (LODWORD(v101[0]))
          {
            unsigned __int8 v44 = _cg_GifLastError((uint64_t)PixelDataProviderAtIndex);
            int v45 = *((unsigned __int8 *)this + 96);
            uint64_t v46 = IIOImagePlus::getSourceGeomColorSpace(PixelDataProviderAtIndex);
            int v43 = ColorQuantization::generateFromRGBImage((uint64_t)&v100, (uint64_t)&dest, v44, v39, v45 != 0, v46, (uint64_t)v101, v93, (int *)&v105);
          }
          else
          {
            unsigned __int8 v51 = _cg_GifLastError((uint64_t)PixelDataProviderAtIndex);
            int v52 = *((unsigned __int8 *)this + 96);
            uint64_t v53 = IIOImagePlus::getSourceGeomColorSpace(PixelDataProviderAtIndex);
            int v43 = ColorQuantization::generateFromRGBImageWu((uint64_t)&v100, (uint64_t)&dest, v51, v39, v52 != 0, v53, (uint64_t)v101, (uint64_t)v93, &v105);
          }
        }
        else
        {
          unsigned __int8 v47 = _cg_GifLastError((uint64_t)PixelDataProviderAtIndex);
          int v48 = *((unsigned __int8 *)this + 96);
          uint64_t v49 = IIOImagePlus::getSourceGeomColorSpace(PixelDataProviderAtIndex);
          int v43 = ColorQuantization::generateFromGrayImage((uint64_t)&v100, (uint64_t)&dest, v47, v39, v48 != 0, v49, (uint64_t)v101, v93, &v105);
        }
        int v54 = v43;
        free(v34);
        if (v54) {
          int v50 = 0;
        }
        else {
          int v50 = 4;
        }
        goto LABEL_66;
      }
    }
  }
LABEL_116:
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    ImageIOLog("           gifWrite-success: %s\n", v8);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      int v83 = _cg_GifLastError(*((void *)this + 5));
      ImageIOLog("               GifLastError: %d\n\n", v83);
    }
  }
  if (v6)
  {
    unint64_t v84 = (void **)*((void *)this + 15);
    if (v84)
    {
      _cg_GifFreeMapObject(v84);
      *((void *)this + 15) = _cg_GifMakeMapObject(v101[0], (char *)buffer);
    }
    int v85 = (void *)*((void *)this + 13);
    if (*v85)
    {
      free(v6);
    }
    else
    {
      *int v85 = v6;
      double v86 = (double)v104;
      double v87 = (double)v103;
      uint64_t v88 = *((void *)this + 14);
      *(void *)uint64_t v88 = 0;
      *(void *)(v88 + 8) = 0;
      *(double *)(v88 + 16) = v86;
      *(double *)(v88 + 24) = v87;
    }
  }
  return v7;
}

void sub_1887A3F58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,CGColorSpaceRef a24,uint64_t a25,CGColorSpaceRef a26,uint64_t a27,char a28)
{
}

uint64_t GIFWritePlugin::writeAllFramesWithGlobalColorMap(GIFWritePlugin *this)
{
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  unsigned int v80 = 0;
  bzero(v81, 0x300uLL);
  v79[0] = 0;
  v79[1] = 0;
  v79[2] = v81;
  CFStringRef v2 = (const __CFString *)*MEMORY[0x1E4F1DC98];
  CGColorSpaceRef v77 = (CGColorSpaceRef)&unk_1ED4DFD58;
  CGColorSpaceRef space = CGColorSpaceCreateWithName(v2);
  PixelDataProviderAtIndeCGFloat x = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, 0);
  ContainerProperties = (IIODictionary *)IIOWritePlugin::getContainerProperties((IIOImagePlus **)this);
  uint64_t Ref = (CGImage *)IIOImageSource::imageReadRef(PixelDataProviderAtIndex);
  unint64_t v68 = *((void *)this + 11);
  size_t v5 = *((void *)this + 6) * v68;
  unint64_t width = *((void *)this + 10);
  data = malloc_type_calloc(v5 * 4 * width, 1uLL, 0x850FADA5uLL);
  if (!data)
  {
    CFStringRef v28 = 0;
    unint64_t v27 = 0;
    goto LABEL_113;
  }
  CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(Ref);
  if (*((void *)this + 6) == 1)
  {
    char v7 = 0;
    uint64_t v8 = 5;
    int v9 = 0;
    switch(AlphaInfo)
    {
      case kCGImageAlphaPremultipliedLast:
      case kCGImageAlphaLast:
        goto LABEL_8;
      case kCGImageAlphaPremultipliedFirst:
      case kCGImageAlphaFirst:
        int v9 = 0;
        uint64_t v8 = 2;
        char v7 = 1;
        break;
      case kCGImageAlphaNoneSkipFirst:
        char v7 = 0;
        int v9 = 0;
        uint64_t v8 = 6;
        break;
      default:
        break;
    }
  }
  else if (AlphaInfo <= kCGImageAlphaNoneSkipFirst && (char v7 = 1, ((1 << AlphaInfo) & 0x54) != 0))
  {
    int v9 = 0;
    uint64_t v8 = 2;
  }
  else
  {
LABEL_8:
    char v7 = 1;
    int v9 = 1;
    uint64_t v8 = 1;
  }
  *((unsigned char *)this + 96) = v7;
  unint64_t v10 = CGBitmapContextCreate(data, width, v5, 8uLL, 4 * width, space, v8);
  CGColorSpaceModel v11 = v10;
  if (v10)
  {
    double v12 = (double)width;
    v83.size.double height = (double)v5;
    v83.origin.CGFloat x = 0.0;
    v83.origin.CGFloat y = 0.0;
    v83.size.unint64_t width = (double)width;
    CGContextClearRect(v10, v83);
    unint64_t v13 = *((void *)this + 6);
    if (v13)
    {
      unint64_t v14 = 0;
      CGFloat x = 0.0;
      uint64_t v16 = -1;
      CGFloat y = 0.0;
      double height = (double)v68;
      do
      {
        int v19 = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v13 + v16);
        double v20 = (CGImage *)IIOImageSource::imageReadRef(v19);
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("drawing image %d\n", v14);
        }
        v84.origin.CGFloat x = x;
        v84.origin.CGFloat y = y;
        v84.size.unint64_t width = v12;
        v84.size.double height = height;
        CGContextDrawImage(v11, v84, v20);
        v85.origin.CGFloat x = x;
        v85.origin.CGFloat y = y;
        v85.size.unint64_t width = v12;
        v85.size.double height = height;
        CGRect v86 = CGRectOffset(v85, 0.0, (double)v68);
        CGFloat x = v86.origin.x;
        CGFloat y = v86.origin.y;
        double v12 = v86.size.width;
        double height = v86.size.height;
        ++v14;
        unint64_t v13 = *((void *)this + 6);
        --v16;
      }
      while (v14 < v13);
    }
    CGContextRelease(v11);
  }
  else
  {
    _cg_jpeg_mem_term("writeAllFramesWithGlobalColorMap", 1148, "*** ERROR: CGBitmapContextCreate returned NULL\n");
  }
  unint64_t v76 = 0;
  ColorQuantization::ColorQuantization((ColorQuantization *)&v76);
  dest.data = data;
  dest.double height = v5;
  dest.unint64_t width = width;
  dest.rowunint64_t Bytes = 4 * width;
  if (*((unsigned char *)this + 96))
  {
    if (v9)
    {
      vImageUnpremultiplyData_RGBA8888(&dest, &dest, 0);
      uint64_t v21 = 3;
    }
    else
    {
      vImageUnpremultiplyData_ARGB8888(&dest, &dest, 0);
      uint64_t v21 = 0;
    }
    if (dest.height)
    {
      uint64_t v23 = 0;
      int v24 = (char *)dest.data + v21;
      LOBYTE(v21) = 1;
      do
      {
        if (dest.width)
        {
          BOOL v25 = &v24[dest.rowBytes * v23];
          vImagePixelCount v26 = dest.width;
          while (*v25 == 255)
          {
            v25 += 4;
            if (!--v26) {
              goto LABEL_31;
            }
          }
          LOBYTE(v21) = 0;
        }
LABEL_31:
        ++v23;
      }
      while (v23 != dest.height);
    }
    else
    {
      LOBYTE(v21) = 1;
    }
    int v22 = v21;
  }
  else
  {
    int v22 = 1;
  }
  unsigned int v71 = v22;
  *((void *)this + 8) = width;
  *((void *)this + 9) = v5;
  unint64_t v27 = (char *)malloc_type_malloc(width + width * v5, 0xF8665CA5uLL);
  if (!v27
    || (ColorQuantization::generateFromRGBImageWu((uint64_t)&v76, (uint64_t)&dest, 8, v8, *((unsigned __int8 *)this + 96), (uint64_t)space, (uint64_t)v79, (uint64_t)v27, &v80) & 1) == 0)
  {
    ColorQuantization::~ColorQuantization((ColorQuantization *)&v76);
    CFStringRef v28 = 0;
LABEL_113:
    uint64_t v62 = 4294967246;
    int v63 = "no";
    goto LABEL_98;
  }
  ColorQuantization::~ColorQuantization((ColorQuantization *)&v76);
  CFStringRef v28 = malloc_type_malloc(width, 0x1E637333uLL);
  *((void *)this + 9) = v68;
  *((void *)this + 7) = 0;
  if (!*((void *)this + 6))
  {
LABEL_97:
    uint64_t v62 = 0;
    int v63 = "yes";
LABEL_98:
    BOOL v66 = v63;
    goto LABEL_101;
  }
  unint64_t v29 = 0;
  BOOL v66 = "no";
  unsigned int v70 = v27;
  while (1)
  {
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      ImageIOLog("####################################################################\n", v29);
      unint64_t v29 = *((void *)this + 7);
    }
    PropertiesAtIndeCGFloat x = (IIODictionary *)IIOWritePlugin::getPropertiesAtIndex((IIOImageDestination **)this, v29);
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(PropertiesAtIndex, @"{GIF}");
    __int16 DelayTime = GIFWritePlugin::getDelayTime(ObjectForKey, ObjectForKey);
    if (!*((void *)this + 7))
    {
      if (_cg_EGifPutScreenDesc(*((void *)this + 5), width, v68, SHIDWORD(v79[0]), 0, (int *)v79) != 1) {
        goto LABEL_99;
      }
      if (IIODictionary::containsKeyGroup(ContainerProperties, @"LoopCount", @"{GIF}"))
      {
        unsigned int Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup(ContainerProperties, @"LoopCount", @"{GIF}");
        unsigned int v34 = Uint32ForKeyGroup << 16;
        if ((int)(Uint32ForKeyGroup << 16) >= -65535 && v34 != 0x10000)
        {
          _cg_EGifPutExtensionLeader(*((void *)this + 5), 255);
          _cg_EGifPutExtensionBlock(*((void *)this + 5), 11, "NETSCAPE2.0");
          __int16 v35 = Uint32ForKeyGroup - 1;
          if (v34 <= 0x10000) {
            __int16 v35 = Uint32ForKeyGroup;
          }
          LOBYTE(dest.data) = 1;
          int v36 = v35;
          BYTE1(dest.data) = v35;
          BYTE2(dest.data) = (unsigned __int16)(v35 + (v35 >> 23)) >> 8;
          _cg_EGifPutExtensionBlock(*((void *)this + 5), 3, &dest);
          _cg_EGifPutExtensionTrailer(*((void *)this + 5));
          if ((gIIODebugFlags & 0x30000) != 0) {
            ImageIOLog("                 loop count: %d\n", v36);
          }
        }
      }
    }
    int v37 = *((unsigned __int8 *)this + 96);
    *(_WORD *)((char *)&dest.data + 1) = DelayTime;
    char v38 = v80;
    if (!v37) {
      char v38 = 0;
    }
    BYTE3(dest.data) = v38;
    if (v37) {
      int v39 = v71;
    }
    else {
      int v39 = 1;
    }
    if (v39) {
      char v40 = 4;
    }
    else {
      char v40 = 8;
    }
    LOBYTE(dest.data) = v40 | v37;
    if (_cg_EGifPutExtension(*((void *)this + 5), 249, 4, &dest) != 1)
    {
LABEL_99:
      uint64_t v62 = 4294967246;
      goto LABEL_101;
    }
    unint64_t v76 = 0;
    unint64_t v74 = width;
    dest.data = 0;
    uint64_t v73 = *((void *)this + 11);
    *((unsigned char *)this + 97) = 1;
    if (*((void *)this + 7))
    {
      if (*((unsigned char *)this + 96)) {
        uint64_t v41 = v71;
      }
      else {
        uint64_t v41 = 1;
      }
      GIFWritePlugin::reduceFrame((const char *)this, v80, (uint64_t)v27, 0, (uint64_t)v79, v41, &v76, (unint64_t *)&dest, &v74, &v73);
    }
    unint64_t v42 = v76;
    unint64_t v44 = v74;
    unint64_t v43 = (unint64_t)dest.data;
    uint64_t v45 = v73;
    _cg_EGifPutImageDesc(*((void *)this + 5), v76, (__int16)dest.data, v74, v73, 0, 0);
    int v47 = v46;
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("      optimized image frame: (%d, %d, %d, %d)\n", v42, v43, v44, v45);
    }
    if (v47 != 1) {
      break;
    }
    if (v44 + v42 > width)
    {
      unint64_t v44 = width - v42;
      unint64_t v74 = width - v42;
    }
    int v48 = (char *)(v45 + v43);
    unint64_t v49 = *((void *)this + 11);
    if (v45 + v43 > v49)
    {
      unint64_t v44 = v49 - v43;
      unint64_t v74 = v49 - v43;
    }
    if (v43 < (unint64_t)v48)
    {
      uint64_t v50 = *((void *)this + 7);
      uint64_t v51 = *((void *)this + 8);
      unint64_t v52 = v42 + v51 * v43;
      uint64_t v53 = (char *)(**((void **)this + 13) + v52);
      if (v50) {
        BOOL v54 = *((unsigned char *)this + 97) == 0;
      }
      else {
        BOOL v54 = 1;
      }
      unint64_t v55 = v51 * v49;
      if (v54) {
        __int16 v56 = 0;
      }
      else {
        __int16 v56 = &v70[(v50 - 1) * v55 + v52];
      }
      uint64_t v57 = (unsigned __int8 *)&v70[v50 * v55 + v52];
      do
      {
        if (v56) {
          int v58 = v39;
        }
        else {
          int v58 = 0;
        }
        unsigned int v59 = v57;
        if (v58 == 1)
        {
          memcpy(v28, v57, v44);
          unsigned int v59 = (unsigned __int8 *)v28;
          if (v44)
          {
            uint64_t v60 = 0;
            do
            {
              if (v57[v60] == v56[v60]) {
                *((unsigned char *)v28 + v60) = v80;
              }
              ++v60;
            }
            while (v44 > v60);
            unsigned int v59 = (unsigned __int8 *)v28;
          }
        }
        if (_cg_EGifPutLine(*((void *)this + 5), v59, v44) != 1) {
          goto LABEL_100;
        }
        if (**((void **)this + 13)) {
          bzero(v53, v44);
        }
        if (v56) {
          v56 += v51;
        }
        else {
          __int16 v56 = 0;
        }
        ++v43;
        v57 += v51;
        v53 += v51;
      }
      while ((char *)v43 != v48);
    }
    unint64_t v61 = *((void *)this + 6);
    unint64_t v29 = *((void *)this + 7) + 1;
    *((void *)this + 7) = v29;
    unint64_t v27 = v70;
    if (v29 >= v61) {
      goto LABEL_97;
    }
  }
LABEL_100:
  uint64_t v62 = 4294967246;
  BOOL v66 = "no";
  unint64_t v27 = v70;
LABEL_101:
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    ImageIOLog("           gifWrite-success: %s\n", v66);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      int Error = _cg_GifLastError(*((void *)this + 5));
      ImageIOLog("               GifLastError: %d\n\n", Error);
    }
  }
  if (data) {
    free(data);
  }
  if (v27) {
    free(v27);
  }
  if (v28) {
    free(v28);
  }
  IIOColorSpace::~IIOColorSpace(&v77);
  return v62;
}

void sub_1887A4888(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,CGColorSpaceRef a29)
{
}

uint64_t GIFWritePlugin::writeAll(GIFWritePlugin *this)
{
  unsigned int v30 = 0;
  memset(v29, 0, sizeof(v29));
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    GIFWritePlugin::writeAll - [%p]\n", this);
  }
  int v28 = 0;
  unsigned int ImageCount = IIOWritePlugin::getImageCount((IIOImageDestination **)this);
  if (!ImageCount)
  {
    size_t v4 = 0;
    goto LABEL_56;
  }
  unsigned int v3 = ImageCount;
  size_t v4 = _cg_EGifOpen(*((void *)this + 2), (uint64_t)GIFWritePlugin::gifWriteFunc, &v28);
  if (!v4)
  {
LABEL_56:
    uint64_t v22 = 4294967246;
    goto LABEL_45;
  }
  unint64_t v5 = v3;
  BOOL v6 = v3 > 1;
  if (v3 < 2)
  {
    int v10 = 0;
    goto LABEL_16;
  }
  PixelDataProviderAtIndeCGFloat x = IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, 0);
  uint64_t v8 = IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v5 - 1);
  if (PixelDataProviderAtIndex) {
    BOOL v9 = 1;
  }
  else {
    BOOL v9 = v8 == 0;
  }
  int v10 = !v9;
  if (v9)
  {
LABEL_16:
    CFIndex v12 = 0;
    if (v5 <= 1) {
      uint64_t v13 = 1;
    }
    else {
      uint64_t v13 = v5;
    }
    do
    {
      unint64_t v14 = (IIO_Reader *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v12);
      if (!v14)
      {
        _cg_jpeg_mem_term("writeAll", 1516, "*** Failed to get pixelDataProvider for index %d\n", v12);
        goto LABEL_56;
      }
      CFDataRef v15 = v14;
      unint64_t v16 = *((void *)this + 11);
      if (v16 <= IIO_Reader::testHeaderSize(v14)) {
        uint64_t v17 = IIO_Reader::testHeaderSize(v15);
      }
      else {
        uint64_t v17 = *((void *)this + 11);
      }
      *((void *)this + 11) = v17;
      unint64_t v18 = *((void *)this + 10);
      if (v18 <= IIOImageSource::count(v15)) {
        uint64_t v19 = IIOImageSource::count(v15);
      }
      else {
        uint64_t v19 = *((void *)this + 10);
      }
      *((void *)this + 10) = v19;
      ++v12;
    }
    while (v13 != v12);
    if (v19 && *((void *)this + 11))
    {
      int v11 = 0;
      goto LABEL_30;
    }
    goto LABEL_56;
  }
  int v10 = 1;
  BOOL v6 = 1;
  int v11 = 1;
  if (*((void *)this + 10))
  {
LABEL_30:
    if (*((void *)this + 11)) {
      goto LABEL_32;
    }
  }
  double v20 = (IIO_Reader *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v5 - 1);
  *((void *)this + 11) = IIO_Reader::testHeaderSize(v20);
  *((void *)this + 10) = IIOImageSource::count(v20);
LABEL_32:
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    ImageIOLog("_CGImagePluginWriteGIF - imageCount: %ld\n", v5);
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("                           max size: %ld * %ld\n", *((void *)this + 10), *((void *)this + 11));
    }
  }
  *((void *)this + 5) = v4;
  *((void *)this + 6) = v5;
  *((void *)this + 13) = &v30;
  *((void *)this + 14) = v29;
  *((unsigned char *)this + 98) = v10;
  if ((v6 & (v10 ^ 1)) == 1)
  {
    uint64_t v21 = GIFWritePlugin::writeAllFramesWithGlobalColorMap(this);
    if (v21)
    {
LABEL_37:
      uint64_t v22 = v21;
      goto LABEL_45;
    }
  }
  else
  {
    if (v11)
    {
      uint64_t Size = IIOImageWriteSession::getSize(*((IIOImageWriteSession **)this + 2));
      IIOImageWriteSession::seek(*((IIOImageWriteSession **)this + 2), Size - 1, 0);
      unint64_t v5 = *((void *)this + 6);
      unint64_t v24 = v5 - 1;
    }
    else
    {
      unint64_t v24 = 0;
    }
    if (v24 < v5)
    {
      do
      {
        *((void *)this + 7) = v24;
        uint64_t v21 = GIFWritePlugin::writeSingleFrame(this);
        if (v21) {
          goto LABEL_37;
        }
      }
      while (++v24 < *((void *)this + 6));
    }
  }
  uint64_t v22 = 0;
LABEL_45:
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    BOOL v25 = "no";
    if (!v22) {
      BOOL v25 = "yes";
    }
    ImageIOLog("     _CGImagePluginWriteGIF-success: %s\n", v25);
    if ((gIIODebugFlags & 0x30000) != 0)
    {
      int Error = _cg_GifLastError(*((void *)this + 5));
      ImageIOLog("                       GifLastError: %d\n\n\n", Error);
    }
  }
  if (v30) {
    free(v30);
  }
  if (v4) {
    _cg_EGifCloseFile((uint64_t)v4, 0);
  }
  *((void *)this + 14) = 0;
  return v22;
}

uint64_t GIFWritePlugin::writeOne(GIFWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967292;
}

void HEIFReadPlugin::HEIFReadPlugin(uint64_t a1, uint64_t a2)
{
}

uint64_t HEIFReadPlugin::loadDataFromXPCObject(HEIFReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_heif", &length);
    if (length == 88)
    {
      long long v6 = data[1];
      *(_OWORD *)((char *)this + 440) = *data;
      *(_OWORD *)((char *)this + 456) = v6;
      long long v7 = data[2];
      long long v8 = data[3];
      long long v9 = data[4];
      *((void *)this + 65) = *((void *)data + 10);
      *(_OWORD *)((char *)this + 488) = v8;
      *(_OWORD *)((char *)this + 504) = v9;
      *(_OWORD *)((char *)this + 472) = v7;
      string = xpc_dictionary_get_string(a2, "iio_xpc_plugin_data_heif_req_cs");
      if (string && *string) {
        CFStringRef v11 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], string, 0x8000100u);
      }
      else {
        CFStringRef v11 = 0;
      }
      uint64_t result = 0;
      *((void *)this + 65) = v11;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t HEIFReadPlugin::saveDataToXPCObject(const void **this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject((IIOReadPlugin *)this, a2);
  if (!v4)
  {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_heif", this + 55, 0x58uLL);
    memset(v7, 0, sizeof(v7));
    IIOString::IIOString((IIOString *)v7, this[65]);
    unint64_t v5 = (const char *)IIOString::utf8String((IIOString *)v7);
    xpc_dictionary_set_string(a2, "iio_xpc_plugin_data_heif_req_cs", v5);
    IIOString::~IIOString((IIOString *)v7);
  }
  return v4;
}

void sub_1887A4E04(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::canCreateChromaSubsampledIOSurface(HEIFReadPlugin *this)
{
  return 1;
}

uint64_t HEIFReadPlugin::getExpectedWidthAndHeightForSubsampling(HEIFReadPlugin *this, const __CFData *a2, uint64_t a3, unint64_t a4, unsigned int *a5, unsigned int *a6)
{
  CFTypeRef v31 = 0;
  CFTypeRef v32 = 0;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v28);
  CFDictionaryRef v27 = 0;
  CFTypeRef cf = 0;
  if (!a2)
  {
    _cg_jpeg_mem_term("getExpectedWidthAndHeightForSubsampling", 192, "*** ERROR: getExpectedWidthAndHeightForSubsampling called with NULL-data\n");
LABEL_19:
    uint64_t ImageGeometryForIndexWithOptions = 0;
    goto LABEL_20;
  }
  uint64_t ImageGeometryForIndexWithOptions = IIOCreateCMPhotoDecompressionSession((uint64_t)&v32);
  if (ImageGeometryForIndexWithOptions)
  {
    LogError("getExpectedWidthAndHeightForSubsampling", 197, "*** ERROR: CMPhotoDecompressionSessionCreate failed\n");
    goto LABEL_20;
  }
  uint64_t ImageGeometryForIndexWithOptions = gFunc_CMPhotoDecompressionSessionCreateContainer(v32, 0, a2, 0, &v31);
  if (ImageGeometryForIndexWithOptions)
  {
    LogError("getExpectedWidthAndHeightForSubsampling", 204, "*** ERROR: CMPhotoDecompressionSessionCreateContainer failed\n");
    goto LABEL_20;
  }
  unint64_t v24 = 0;
  unint64_t v25 = 0;
  uint64_t ImageGeometryForIndexWithOptions = gFunc_CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions(v31, a3, 0, &v25, &v24, 0);
  if (ImageGeometryForIndexWithOptions)
  {
    LogError("getExpectedWidthAndHeightForSubsampling", 215, "*** ERROR: CMPhotoDecompressionContainerGetImageGeometryForIndexWithOptions failed\n");
  }
  else
  {
    if (v25 / a4 <= v24 / a4) {
      unint64_t v13 = v24 / a4;
    }
    else {
      unint64_t v13 = v25 / a4;
    }
    if (IIODictionary::containsKey(*((IIODictionary **)this + 6), @"kCGImageDestinationImageMaxPixelSize"))
    {
      unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(*((IIODictionary **)this + 6), @"kCGImageDestinationImageMaxPixelSize");
      if (v13 > Uint32ForKey)
      {
        LODWORD(v13) = (Uint32ForKey & 0xFFFFFFF0) + 64;
        *((unsigned char *)this + 340) = 1;
      }
    }
    uint64_t ImageGeometryForIndexWithOptions = gFunc_CMPhotoDecompressionContainerCopyImageBitDepthForIndexWithOptions(v31, a3, 0, &cf);
    if (!ImageGeometryForIndexWithOptions)
    {
      if (cf)
      {
        uint64_t v21 = 0;
        uint64_t v22 = 0;
        uint64_t v23 = 0;
        IIOArray::IIOArray((IIOArray *)&v21, (const __CFArray *)cf);
        Uint32AtIndeCGFloat x = IIOArray::getUint32AtIndex((IIOArray *)&v21, 0);
        int PixelFormatForBitDepth = HEIFReadPlugin::getPixelFormatForBitDepth(this, Uint32AtIndex, *((IIODictionary **)this + 6));
        IIONumber::IIONumber((IIONumber *)v20, PixelFormatForBitDepth);
        IIODictionary::setObjectForKey((uint64_t)&v28, (uint64_t)v20, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
        IIONumber::~IIONumber((IIONumber *)v20);
        CFRelease(cf);
        IIOArray::~IIOArray((IIOArray *)&v21);
      }
      IIONumber::IIONumber((IIONumber *)v19, v13);
      IIODictionary::setObjectForKey((uint64_t)&v28, (uint64_t)v19, *(const void **)gIIO_kCMPhotoDecompressionOption_MaxPixelSize);
      IIONumber::~IIONumber((IIONumber *)v19);
      IIONumber::IIONumber((IIONumber *)v18, *((_DWORD *)this + 121));
      IIODictionary::setObjectForKey((uint64_t)&v28, (uint64_t)v18, *(const void **)gIIO_kCMPhotoDecompressionOption_TiledDownsampling);
      IIONumber::~IIONumber((IIONumber *)v18);
      uint64_t ImageGeometryForIndexWithOptions = gFunc_CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndex(v31, a3, v29, &v27);
      if (ImageGeometryForIndexWithOptions)
      {
        LogError("getExpectedWidthAndHeightForSubsampling", 257, "*** ERROR: CMPhotoDecompressionContainerCreateOutputBufferAttributesForImageIndex failed\n");
        goto LABEL_20;
      }
      uint64_t v21 = 0;
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v21, v27);
      *a5 = IIODictionary::getUint32ForKey((IIODictionary *)&v21, *(const __CFString **)gIIO_kCVPixelBufferWidthKey);
      *a6 = IIODictionary::getUint32ForKey((IIODictionary *)&v21, *(const __CFString **)gIIO_kCVPixelBufferHeightKey);
      IIODictionary::~IIODictionary((IIODictionary *)&v21);
      goto LABEL_19;
    }
    LogError("getExpectedWidthAndHeightForSubsampling", 233, "*** ERROR: CMPhotoDecompressionContainerCopyImageBitDepthForIndexWithOptions failed\n");
  }
LABEL_20:
  if (v31) {
    CFRelease(v31);
  }
  if (v32) {
    CFRelease(v32);
  }
  if (v27) {
    CFRelease(v27);
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v28);
  return ImageGeometryForIndexWithOptions;
}

void sub_1887A51AC(_Unwind_Exception *a1)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 104));
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::handleDecodeRequest(HEIFReadPlugin *this, IIODictionary *a2, IIODictionary *a3)
{
  if (*(_WORD *)((char *)this + 353))
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a2, @"kCGImageSourceDecodeRequestOptions");
    uint64_t v62 = 0;
    int v63 = 0;
    uint64_t v64 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v62, ObjectForKey, 1);
    if (!*((unsigned char *)this + 354))
    {
      if (!*((unsigned char *)this + 353)) {
        goto LABEL_106;
      }
      CFIndex v12 = (CGColorSpace *)*((void *)this + 20);
      if (!v12 || !CGColorSpaceUsesITUR_2100TF(v12) && !CGColorSpaceUsesExtendedRange(*((CGColorSpaceRef *)this + 20))) {
        goto LABEL_106;
      }
      if ((gIIODebugFlags & 0x300000) != 0) {
        ImageIOLog("☀️  decodeRequest: 'kCGImageSourceDecodeToSDR'\n");
      }
      *((_WORD *)this + 246) = 256;
      *((unsigned char *)this + 496) = 0;
      int v13 = 1;
LABEL_30:
      CFTypeRef cf = 0;
      uint64_t v59 = 0;
      uint64_t v60 = 0;
      uint64_t v61 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v59, a3);
      unint64_t v18 = (const void *)*((void *)this + 20);
      if (v18) {
        IIODictionary::setObjectForKey((IIODictionary *)&v59, v18, *(const __CFString **)gIIO_kCVImageBufferCGColorSpaceKey);
      }
      uint64_t v19 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1212500294);
      HEIFMainImageAtIndeCGFloat x = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(v19, *((_DWORD *)this + 126));
      HEIFAlternateImageAtIndeCGFloat x = (IIOImagePlus *)HEIFMainImage::getHEIFAlternateImageAtIndex(HEIFMainImageAtIndex, *((_DWORD *)this + 126));
      if (HEIFAlternateImageAtIndex)
      {
        Image = (const void *)IIOImagePlus::getImage(HEIFAlternateImageAtIndex);
        if (Image) {
          IIODictionary::setObjectForKey((IIODictionary *)&v62, Image, @"kCGFlexRangeAlternateColorSpace");
        }
      }
      if ((gIIODebugFlags & 0x300000) != 0) {
        ImageIOLog("☀️  'IIOCallCreatePixelBufferAttributesForHDRType'\n");
      }
      if (*((unsigned char *)this + 500))
      {
        if ((gIIODebugFlags & 0x300000) != 0) {
          ImageIOLog("☀️  image has alpha plane --> pixelformat 'l64r'\n");
        }
        IIONumber::IIONumber((IIONumber *)v56, 1815491698);
        IIODictionary::setObjectForKey((IIODictionary *)&v62, value, @"kCGTargetPixelFormat");
        IIONumber::~IIONumber((IIONumber *)v56);
      }
      int v23 = IIOCallCreatePixelBufferAttributesForHDRType(v13, v60, v63, &cf);
      int v24 = v23;
      if (v23)
      {
        unint64_t v25 = IIOCMErrorString(v23);
        LogError("handleDecodeRequest", 379, "*** ERROR: Cannot decode to SDR: err = %s [%d]\n", v25, v24);
      }
      if (!cf) {
        goto LABEL_105;
      }
      v56[0] = 0;
      v56[1] = 0;
      xpc_object_t value = 0;
      IIODictionary::IIODictionary((IIODictionary *)v56, (const __CFDictionary *)cf);
      int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v56, *(const __CFString **)gIIO_kCVPixelBufferPixelFormatTypeKey);
      int v27 = Uint32ForKey;
      if ((gIIODebugFlags & 0x300000) != 0)
      {
        unsigned int v28 = Uint32ForKey >> 24;
        uint64_t v29 = MEMORY[0x1E4F14390];
        if (Uint32ForKey < 0) {
          int v30 = __maskrune(Uint32ForKey >> 24, 0x40000uLL);
        }
        else {
          int v30 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v28 + 60) & 0x40000;
        }
        if (v30) {
          uint64_t v31 = v28;
        }
        else {
          uint64_t v31 = 46;
        }
        unsigned int v32 = v27 << 8 >> 24;
        if (v27 << 8 < 0) {
          int v33 = __maskrune(v27 << 8 >> 24, 0x40000uLL);
        }
        else {
          int v33 = *(_DWORD *)(v29 + 4 * v32 + 60) & 0x40000;
        }
        if (v33) {
          uint64_t v34 = v32;
        }
        else {
          uint64_t v34 = 46;
        }
        unsigned int v35 = (__int16)v27 >> 8;
        if (v27 << 16 < 0) {
          int v36 = __maskrune((__int16)v27 >> 8, 0x40000uLL);
        }
        else {
          int v36 = *(_DWORD *)(v29 + 4 * v35 + 60) & 0x40000;
        }
        if ((v27 << 24) <= 0x7F000000) {
          int v37 = *(_DWORD *)(v29 + 4 * (char)v27 + 60) & 0x40000;
        }
        else {
          int v37 = __maskrune((char)v27, 0x40000uLL);
        }
        if (v36) {
          uint64_t v38 = v35;
        }
        else {
          uint64_t v38 = 46;
        }
        if (v37) {
          uint64_t v39 = (char)v27;
        }
        else {
          uint64_t v39 = 46;
        }
        ImageIOLog("☀️  requestedPixelFormat: '%c%c%c%c'   %s:%d\n", v31, v34, v38, v39, "handleDecodeRequest", 385);
      }
      unsigned int v40 = IIODictionary::getUint32ForKey((IIODictionary *)v56, *(const __CFString **)gIIO_kCVPixelBufferWidthKey);
      unsigned int v41 = IIODictionary::getUint32ForKey((IIODictionary *)v56, *(const __CFString **)gIIO_kCVPixelBufferHeightKey);
      unint64_t v42 = IIODictionary::getObjectForKey((IIODictionary *)v56, *(const __CFString **)gIIO_kCVImageBufferCGColorSpaceKey);
      CFStringRef v43 = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v56, *(const __CFString **)gIIO_kCVImageBufferYCbCrMatrixKey);
      FloatForKeCGFloat y = IIODictionary::getFloatForKey((IIODictionary *)v56, @"IOSurfaceContentHeadroom");
      float v45 = *(float *)&FloatForKey;
      *((_DWORD *)this + 110) = v27;
      CFStringRef v46 = CGColorSpaceCopyName(v42);
      *((void *)this + 65) = v46;
      if ((gIIODebugFlags & 0x300000) != 0)
      {
        IIOString::IIOString((IIOString *)v55, v46);
        int v47 = (const char *)IIOString::utf8String((IIOString *)v55);
        ImageIOLog("☀️  requestedColorSpace: '%s'\n", v47);
        IIOString::~IIOString((IIOString *)v55);
      }
      if (v42)
      {
        CGColorSpaceRelease(*((CGColorSpaceRef *)this + 20));
        *((void *)this + 20) = CFRetain(v42);
      }
      if (v45 > 0.0)
      {
        *((float *)this + 44) = v45;
        *((float *)this + 112) = v45;
      }
      *((unsigned char *)this + 497) = IIODictionary::getBoolForKey((IIODictionary *)&v62, @"kCGDisableMetal");
      if (v43)
      {
        if ((gIIODebugFlags & 0x300000) != 0)
        {
          IIOString::IIOString((IIOString *)v55, v43);
          int v48 = (const char *)IIOString::utf8String((IIOString *)v55);
          ImageIOLog("☀️  requestedYCCMatrix: '%s'\n", v48);
          IIOString::~IIOString((IIOString *)v55);
        }
        if (CFStringCompare(v43, *(CFStringRef *)gIIO_kCVImageBufferYCbCrMatrix_ITU_R_601_4, 0))
        {
          if (CFStringCompare(v43, *(CFStringRef *)gIIO_kCVImageBufferYCbCrMatrix_ITU_R_709_2, 0))
          {
            if (CFStringCompare(v43, *(CFStringRef *)gIIO_kCVImageBufferYCbCrMatrix_ITU_R_2020, 0)) {
              goto LABEL_86;
            }
            int v49 = 3;
          }
          else
          {
            int v49 = 2;
          }
        }
        else
        {
          int v49 = 1;
        }
        *((_DWORD *)this + 111) = v49;
      }
LABEL_86:
      *((_DWORD *)this + 65) = v40;
      *((_DWORD *)this + 66) = v41;
      if (v27 > 1815491697)
      {
        if (v27 == 2019963440)
        {
LABEL_94:
          *((_DWORD *)this + 68) = 2097162;
          int v52 = 4;
          *((_WORD *)this + 138) = 4;
          *(_DWORD *)((char *)this + 278) = 197126;
LABEL_104:
          *((_DWORD *)this + 67) = (v40 * v52 + 15) & 0xFFFFFFF0;
          *((unsigned char *)this + 350) = 1;
          CFRelease(cf);
          IIODictionary::~IIODictionary((IIODictionary *)v56);
LABEL_105:
          IIODictionary::~IIODictionary((IIODictionary *)&v59);
LABEL_106:
          IIODictionary::~IIODictionary((IIODictionary *)&v62);
          return 0;
        }
        if (v27 != 1815491698)
        {
LABEL_97:
          *((_DWORD *)this + 68) = 2097160;
          *((_WORD *)this + 138) = 4;
          if (*((unsigned char *)this + 500)) {
            int v53 = 3;
          }
          else {
            int v53 = 5;
          }
          *(_DWORD *)((char *)this + 278) = v53;
          int v52 = 4;
          goto LABEL_104;
        }
        *((_DWORD *)this + 68) = 4194320;
        *((_WORD *)this + 138) = 4;
        uint64_t v50 = (int *)((char *)this + 278);
        if (*((unsigned char *)this + 500)) {
          int v51 = 259;
        }
        else {
          int v51 = 261;
        }
      }
      else
      {
        if (v27 != 1380411457)
        {
          if (v27 != 1815162994) {
            goto LABEL_97;
          }
          goto LABEL_94;
        }
        *((_DWORD *)this + 68) = 4194320;
        *((_WORD *)this + 138) = 4;
        uint64_t v50 = (int *)((char *)this + 278);
        if (*((unsigned char *)this + 500)) {
          int v51 = 16777475;
        }
        else {
          int v51 = 16777477;
        }
      }
      int *v50 = v51;
      int v52 = 8;
      goto LABEL_104;
    }
    if (!*((unsigned char *)this + 495) && !*((unsigned char *)this + 494)) {
      goto LABEL_106;
    }
    if ((gIIODebugFlags & 0x300000) != 0) {
      ImageIOLog("☀️  decodeRequest: 'kCGImageSourceDecodeToHDR'\n");
    }
    *((_WORD *)this + 246) = 1;
    unsigned int v7 = IIODictionary::containsKey((IIODictionary *)&v62, @"kCGTargetHeadroom");
    LODWORD(v8) = 0;
    if (v7) {
      double v8 = IIODictionary::getFloatForKey((IIODictionary *)&v62, @"kCGTargetHeadroom");
    }
    *((_DWORD *)this + 113) = LODWORD(v8);
    if ((gIIODebugFlags & 0x300000) != 0) {
      ImageIOLog("☀️  %s - _gainMapHeadroom: %g\n", "handleDecodeRequest", *(float *)&v8);
    }
    unsigned int v9 = IIODictionary::containsKey((IIODictionary *)&v62, @"kCGFallbackHDRGain");
    LODWORD(v10) = 0;
    if (v9) {
      double v10 = IIODictionary::getFloatForKey((IIODictionary *)&v62, @"kCGFallbackHDRGain");
    }
    *((_DWORD *)this + 114) = LODWORD(v10);
    if (IIODictionary::containsKey((IIODictionary *)&v62, @"kCGGenerateFlexGTC"))
    {
      BOOL BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)&v62, @"kCGGenerateFlexGTC");
    }
    else
    {
      if (!IIODictionary::containsKey((IIODictionary *)&v62, @"kCGImageSourceGenerateImageSpecificLumaScaling"))
      {
        *((unsigned char *)this + 496) = 1;
        goto LABEL_26;
      }
      BOOL BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)&v62, @"kCGImageSourceGenerateImageSpecificLumaScaling");
    }
    *((unsigned char *)this + 496) = BoolForKey;
LABEL_26:
    if (IIODictionary::getBoolForKey(a2, @"kCGImageSourceCreateThumbnailWithTransform"))
    {
      unsigned int Position = (void *)IIOImageWriteSession::getPosition(this);
      TagWithPath = CGImageMetadataGetTagWithPath(Position, 0, @"tiff:Orientation");
      CFNumberRef v16 = (const __CFNumber *)CGImageMetadataTagGetValue((uint64_t)TagWithPath);
      IIONumber::IIONumber((IIONumber *)&v59, v16);
      int v17 = IIONumber::uint32Num((IIONumber *)&v59);
      IIONumber::~IIONumber((IIONumber *)&v59);
      *((_DWORD *)this + 120) = v17;
    }
    else
    {
      *((_DWORD *)this + 120) = 1;
    }
    int v13 = 2;
    goto LABEL_30;
  }
  return 0;
}

void sub_1887A5A20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va2, a10);
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v18 = va_arg(va2, void);
  uint64_t v19 = va_arg(va2, void);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)va2);
  _Unwind_Resume(a1);
}

CFTypeRef HEIFReadPlugin::copyAuxiliaryDataInfo(HEIFReadPlugin *this, unsigned int a2, const __CFString *a3, IIODictionary *a4)
{
  CFTypeRef v67 = 0;
  unint64_t v68 = 0;
  CFTypeRef v66 = 0;
  IIO_LoadHEIFSymbols();
  double v8 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1212500294);
  HEIFMainImageAtIndeCGFloat x = GlobalHEIFInfo::getHEIFMainImageAtIndex(v8, *((_DWORD *)this + 126));
  if (!HEIFMainImageAtIndex
    || (double v10 = (HEIFGroupItem *)HEIFMainImageAtIndex,
        int v65 = 0,
        uint64_t Options = IIOImagePlus::getOptions(*((IIOImagePlus **)this + 2)),
        int v12 = IIOCreateCMPhotoDecompressionSession((uint64_t)&v67),
        !v67))
  {
    CFTypeRef v22 = 0;
    CFDataRef v18 = 0;
    goto LABEL_57;
  }
  int v13 = v12;
  uint64_t Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  uint64_t v15 = IIOImageReadSession::retainBytePointer(*((IIOImageReadSession **)this + 3), (const __CFData **)&v68, 1);
  if (!v15)
  {
    LogError("copyAuxiliaryDataInfo", 1470, "*** ERROR: retainBytePointer failed\n");
    CFDataRef v18 = 0;
    goto LABEL_42;
  }
  uint64_t v16 = (const UInt8 *)v15;
  uint64_t v17 = *((void *)this + 58);
  if (v17)
  {
    if (*((void *)this + 59)) {
      uint64_t Size = (IIOImageRead *)*((void *)this + 59);
    }
    else {
      uint64_t v17 = 0;
    }
    uint64_t v16 = (const UInt8 *)v15 + v17;
  }
  CFDataRef v18 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v16, (CFIndex)Size, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  if (v18) {
    int v13 = gFunc_CMPhotoDecompressionSessionCreateContainer(v67, 0, v18, &v65, &v66);
  }
  if (a2 == 98)
  {
    if (!HEIFGroupItem::getStereoAggressorCount(v10)) {
      goto LABEL_42;
    }
    uint64_t v62 = 0;
    CFTypeRef v63 = 0;
    uint64_t v64 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v62);
    CFTypeRef v59 = 0;
    uint64_t v60 = 0;
    uint64_t v61 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v59);
    IIONumber::IIONumber((IIONumber *)theDict, 6);
    IIODictionary::setObjectForKey((IIODictionary *)&v59, value, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputMode);
    IIONumber::~IIONumber((IIONumber *)theDict);
    IIODictionary::setObjectForKey((IIODictionary *)&v59, (const void *)*MEMORY[0x1E4F1CFD0], *(const __CFString **)gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputDoNotDecodeBaselayer);
    IIODictionary::setObjectForKey((IIODictionary *)&v62, v60, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputOptions);
    CFTypeRef v56 = 0;
    int v19 = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(v66, *((unsigned int *)this + 126), v63, 5, &v56);
    int v20 = v19;
    if (v19)
    {
      uint64_t v21 = IIOCMErrorString(v19);
      LogError("copyAuxiliaryDataInfo", 1503, "*** ERROR: CMPhotoDecompressionContainerCreateImageForIndex err: %s [%d]\n", v21, v20);
      CFTypeRef v22 = 0;
    }
    else
    {
      theDict[0] = 0;
      theDict[1] = 0;
      xpc_object_t value = 0;
      IIODictionary::IIODictionary((IIODictionary *)theDict, (const __CFDictionary *)v56);
      CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)theDict, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap);
      CFDictionaryRef v39 = IIODictionary::getObjectForKey((IIODictionary *)theDict, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeMetadata);
      CFTypeRef v55 = 0;
      CGImageCreateFlexRangeMetadata((uint64_t)v39, (uint64_t *)&v55);
      CFTypeRef cf = 0;
      CFTypeRef v53 = 0;
      uint64_t v54 = 0;
      HEIFReadPlugin::auxiliaryDataInfoFromPixelBuffer(ObjectForKey, (const CGImageMetadata *)v55, a4, (IIODictionary *)&cf);
      CFTypeRef v22 = CFRetain(v53);
      CFDictionaryRef v40 = IIODictionary::getObjectForKey((IIODictionary *)theDict, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeColorSpace);
      if (v40) {
        IIODictionary::setObjectForKey((IIODictionary *)&cf, v40, @"kCGImageAuxiliaryDataInfoColorSpace");
      }
      if (IIODictionary::getBoolForKey(a4, @"kCGImageAuxiliaryDataIncludeMeteorPlusMetadata"))
      {
        char v51 = 0;
        uint64_t v50 = -1;
        gFunc_CMPhotoDecompressionContainerFindFirstAuxiliaryOfTypeForIndexWithOptions(v66, *((unsigned int *)this + 126), 0, 4, *(void *)gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap, &v51, &v50);
        if (v51)
        {
          CFTypeRef v49 = 0;
          gFunc_CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithOptions(v66, *((unsigned int *)this + 126), v50, 0, &v49);
          IIODictionary::setObjectForKey((IIODictionary *)&cf, v49, @"kCGImageAuxiliaryDataInfoMeteorPlusMetadata");
          if (v49) {
            CFRelease(v49);
          }
        }
      }
      if (v55) {
        CFRelease(v55);
      }
      IIODictionary::~IIODictionary((IIODictionary *)&cf);
      IIODictionary::~IIODictionary((IIODictionary *)theDict);
    }
    if (v56) {
      CFRelease(v56);
    }
    IIODictionary::~IIODictionary((IIODictionary *)&v59);
    IIODictionary::~IIODictionary((IIODictionary *)&v62);
    goto LABEL_55;
  }
  unsigned int NumberOfAuxImages = HEIFMainImage::getNumberOfAuxImages(v10);
  CFTypeRef v59 = 0;
  if (!NumberOfAuxImages) {
    goto LABEL_42;
  }
  int v47 = a4;
  uint64_t v24 = 0;
  uint64_t v25 = NumberOfAuxImages;
  uint64_t v48 = Options;
  do
  {
    HEIFAuxImageAtIndeCGFloat x = (HEIFAuxImage *)HEIFMainImage::getHEIFAuxImageAtIndex(v10, v24);
    if (HEIFAuxImage::auxiliaryType(HEIFAuxImageAtIndex) != a2) {
      goto LABEL_32;
    }
    if (a2 < 4)
    {
      int v13 = gFunc_CMPhotoDecompressionContainerCreateAuxiliaryImageDictionaryRepresentation(v66, *((unsigned int *)this + 126), v24, *(void *)(Options + 8), &v59);
    }
    else
    {
      CFStringRef v27 = (const __CFString *)IIOImageWriteSession::getSize(HEIFAuxImageAtIndex);
      if (a3 && v27)
      {
        if (CFStringCompare(a3, v27, 0)) {
          goto LABEL_32;
        }
        if (a2 != 99)
        {
          theDict[0] = 0;
          float v45 = (uint64_t (*)(CFTypeRef, uint64_t, void, void, uint64_t, CFDictionaryRef *))gFunc_CMPhotoDecompressionContainerCreateAuxiliaryImageForIndex;
          CFTypeRef v33 = v66;
          uint64_t v34 = *((unsigned int *)this + 126);
          unsigned int v35 = HEIFAuxImage::payloadIndex(HEIFAuxImageAtIndex);
          int v13 = v45(v33, v34, v35, *(void *)(v48 + 8), 2, theDict);
          if (theDict[0])
          {
            CFTypeRef cf = 0;
            CFTypeRef v43 = v66;
            CFStringRef v46 = (void (*)(CFTypeRef, uint64_t, void, void, CFTypeRef *))gFunc_CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithOptions;
            uint64_t v36 = *((unsigned int *)this + 126);
            unsigned int v37 = HEIFAuxImage::payloadIndex(HEIFAuxImageAtIndex);
            v46(v43, v36, v37, *(void *)(v48 + 8), &cf);
            uint64_t v62 = 0;
            CFTypeRef v63 = 0;
            uint64_t v64 = 0;
            HEIFReadPlugin::auxiliaryDataInfoFromPixelBuffer(theDict[0], (const CGImageMetadata *)cf, v47, (IIODictionary *)&v62);
            CFTypeRef v59 = CFRetain(v63);
            if (cf) {
              CFRelease(cf);
            }
            CFRelease(theDict[0]);
            IIODictionary::~IIODictionary((IIODictionary *)&v62);
          }
          uint64_t Options = v48;
          if (!v13)
          {
LABEL_39:
            CFTypeRef v22 = v59;
            goto LABEL_55;
          }
          goto LABEL_31;
        }
        theDict[0] = 0;
        unint64_t v44 = gFunc_CMPhotoDecompressionContainerCopyCustomMetadataForIndexWithOptions;
        CFTypeRef v28 = v66;
        uint64_t v29 = *((unsigned int *)this + 126);
        unsigned int v30 = HEIFAuxImage::payloadIndex(HEIFAuxImageAtIndex);
        int v13 = ((uint64_t (*)(CFTypeRef, uint64_t, void, void, CFDictionaryRef *))v44)(v28, v29, v30, 0, theDict);
        uint64_t Options = v48;
        if (theDict[0])
        {
          uint64_t v62 = 0;
          CFTypeRef v63 = 0;
          uint64_t v64 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v62);
          if (CFDictionaryContainsKey(theDict[0], @"Data"))
          {
            uint64_t v31 = CFDictionaryGetValue(theDict[0], @"Data");
            IIODictionary::setObjectForKey((IIODictionary *)&v62, v31, @"kCGImageAuxiliaryDataInfoData");
          }
          CFTypeRef v59 = CFRetain(v63);
          CFRelease(theDict[0]);
          IIODictionary::~IIODictionary((IIODictionary *)&v62);
          if (!v13) {
            goto LABEL_39;
          }
          goto LABEL_31;
        }
      }
    }
    if (!v13) {
      goto LABEL_39;
    }
LABEL_31:
    unsigned int v32 = IIOCMErrorString(v13);
    _cg_jpeg_mem_term("copyAuxiliaryDataInfo", 1623, "*** CMPhotoDecompressionContainerCreateAuxiliaryImageDictionaryRepresentation[%d]  err = %s [%d]\n", v24, v32, v13);
LABEL_32:
    ++v24;
  }
  while (v25 != v24);
  if (v59) {
    CFRelease(v59);
  }
LABEL_42:
  CFTypeRef v22 = 0;
LABEL_55:
  if (v67) {
    CFRelease(v67);
  }
LABEL_57:
  if (v66) {
    CFRelease(v66);
  }
  if (v18) {
    CFRelease(v18);
  }
  if (v68)
  {
    unsigned int v41 = (IIOImageRead **)*((void *)this + 3);
    if (v41) {
      IIOImageReadSession::releaseBytePointer(v41, v68);
    }
  }
  return v22;
}

void sub_1887A619C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,char a28)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a20);
  IIODictionary::~IIODictionary((IIODictionary *)&a25);
  IIODictionary::~IIODictionary((IIODictionary *)&a28);
  IIODictionary::~IIODictionary((IIODictionary *)(v28 - 144));
  _Unwind_Resume(a1);
}

void HEIFReadPlugin::auxiliaryDataInfoFromPixelBuffer(__CVBuffer *a1@<X1>, const CGImageMetadata *a2@<X2>, IIODictionary *a3@<X3>, IIODictionary *a4@<X8>)
{
  *(void *)a4 = 0;
  *((void *)a4 + 1) = 0;
  *((void *)a4 + 2) = 0;
  IIODictionary::IIODictionary(a4);
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a3, @"kCGImageAuxiliaryDataRepresentation");
  CFDictionaryRef v10 = ObjectForKey;
  if (!ObjectForKey) {
    goto LABEL_8;
  }
  if (CFEqual(ObjectForKey, @"kCGImageAuxiliaryDataRepresentationPixelBuffer"))
  {
    IIODictionary::setObjectForKey(a4, a1, @"kCGImageAuxiliaryDataInfoPixelBuffer");
    goto LABEL_38;
  }
  if (CFEqual(v10, @"kCGImageAuxiliaryDataRepresentationIOSurface"))
  {
    IOSurface = (__IOSurface *)gFunc_CVPixelBufferGetIOSurface(a1);
    IOSurfaceIncrementUseCount(IOSurface);
    IIODictionary::setObjectForKey(a4, IOSurface, @"kCGImageAuxiliaryDataInfoIOSurface");
    goto LABEL_38;
  }
  if (CFEqual(v10, @"kCGImageAuxiliaryDataRepresentationImage"))
  {
    int v12 = (__IOSurface *)gFunc_CVPixelBufferGetIOSurface(a1);
    int v13 = (void *)CGImageCreateFromIOSurface(v12, 0);
    IIODictionary::setObjectForKey(a4, v13, @"kCGImageAuxiliaryDataInfoImage");
    CGImageRelease((CGImageRef)v13);
  }
  else
  {
LABEL_8:
    PixelFormatint Type = gFunc_CVPixelBufferGetPixelFormatType(a1);
    unint64_t Width = gFunc_CVPixelBufferGetWidth(a1);
    uint64_t Height = gFunc_CVPixelBufferGetHeight(a1);
    unint64_t BytesPerRow = gFunc_CVPixelBufferGetBytesPerRow(a1);
    if (gFunc_CVPixelBufferIsPlanar(a1))
    {
      unsigned int v16 = PixelFormatType >> 24;
      uint64_t v17 = MEMORY[0x1E4F14390];
      if (PixelFormatType < 0) {
        int v18 = __maskrune(PixelFormatType >> 24, 0x40000uLL);
      }
      else {
        int v18 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v16 + 60) & 0x40000;
      }
      if (v18) {
        uint64_t v22 = v16;
      }
      else {
        uint64_t v22 = 46;
      }
      unsigned int v23 = PixelFormatType << 8 >> 24;
      if (PixelFormatType << 8 < 0) {
        int v24 = __maskrune(PixelFormatType << 8 >> 24, 0x40000uLL);
      }
      else {
        int v24 = *(_DWORD *)(v17 + 4 * v23 + 60) & 0x40000;
      }
      if (v24) {
        uint64_t v25 = v23;
      }
      else {
        uint64_t v25 = 46;
      }
      unsigned int v26 = (__int16)PixelFormatType >> 8;
      if (PixelFormatType << 16 < 0) {
        int v27 = __maskrune((__int16)PixelFormatType >> 8, 0x40000uLL);
      }
      else {
        int v27 = *(_DWORD *)(v17 + 4 * v26 + 60) & 0x40000;
      }
      if ((PixelFormatType << 24) <= 0x7F000000) {
        int v28 = *(_DWORD *)(v17 + 4 * (char)PixelFormatType + 60) & 0x40000;
      }
      else {
        int v28 = __maskrune((char)PixelFormatType, 0x40000uLL);
      }
      if (v27) {
        uint64_t v29 = v26;
      }
      else {
        uint64_t v29 = 46;
      }
      if (v28) {
        uint64_t v30 = (char)PixelFormatType;
      }
      else {
        uint64_t v30 = 46;
      }
      LogError("auxiliaryDataInfoFromPixelBuffer", 1701, "*** ERROR: Unsupported AuxiliaryData format '%c%c%c%c'\n", v22, v25, v29, v30);
    }
    else
    {
      gFunc_CVPixelBufferLockBaseAddress(a1, 1);
      BaseAddress = (const UInt8 *)gFunc_CVPixelBufferGetBaseAddress(a1);
      CFDataRef v20 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], BaseAddress, BytesPerRow * Height);
      if (v20)
      {
        IIODictionary::setObjectForKey(a4, v20, @"kCGImageAuxiliaryDataInfoData");
        CFRelease(v20);
      }
      gFunc_CVPixelBufferUnlockBaseAddress(a1, 1, v21);
    }
    uint64_t v35 = 0;
    xpc_object_t value = 0;
    uint64_t v37 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v35);
    IIODictionary::setObjectForKey(a4, value, @"kCGImageAuxiliaryDataInfoDataDescription");
    IIONumber::IIONumber((IIONumber *)v33, Width);
    IIODictionary::setObjectForKey((IIODictionary *)&v35, v34, @"Width");
    IIONumber::~IIONumber((IIONumber *)v33);
    IIONumber::IIONumber((IIONumber *)v33, Height);
    IIODictionary::setObjectForKey((IIODictionary *)&v35, v34, @"Height");
    IIONumber::~IIONumber((IIONumber *)v33);
    IIONumber::IIONumber((IIONumber *)v33, BytesPerRow);
    IIODictionary::setObjectForKey((IIODictionary *)&v35, v34, @"BytesPerRow");
    IIONumber::~IIONumber((IIONumber *)v33);
    IIONumber::IIONumber((IIONumber *)v33, PixelFormatType);
    IIODictionary::setObjectForKey((IIODictionary *)&v35, v34, @"PixelFormat");
    IIONumber::~IIONumber((IIONumber *)v33);
    IIODictionary::~IIODictionary((IIODictionary *)&v35);
  }
LABEL_38:
  if (a2) {
    IIODictionary::setObjectForKey(a4, a2, @"kCGImageAuxiliaryDataInfoMetadata");
  }
}

void sub_1887A6674(_Unwind_Exception *a1)
{
  IIODictionary::~IIODictionary(v1);
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::copyISOGainMapDictionary(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = 0;
  if ((gIIODebugFlags & 0x300000) != 0) {
    ImageIOLog("☀️  %s\n", "copyISOGainMapDictionary");
  }
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v14);
  uint64_t v11 = 0;
  int v12 = 0;
  uint64_t v13 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v11);
  IIONumber::IIONumber((IIONumber *)v9, 6);
  IIODictionary::setObjectForKey((IIODictionary *)&v11, value, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputMode);
  IIONumber::~IIONumber((IIONumber *)v9);
  IIODictionary::setObjectForKey((IIODictionary *)&v11, (const void *)*MEMORY[0x1E4F1CFD0], *(const __CFString **)gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputDoNotDecodeBaselayer);
  IIODictionary::setObjectForKey((IIODictionary *)&v14, v12, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_DecodeToHDROutputOptions);
  int v4 = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(a2, *(unsigned int *)(a1 + 504), v15, 5, &v17);
  int v5 = v4;
  if (v4)
  {
    long long v6 = IIOCMErrorString(v4);
    LogError("copyISOGainMapDictionary", 1799, "*** CMPhotoDecompressionContainerCreateImageForIndex  err = %s [%d]\n", v6, v5);
  }
  uint64_t v7 = v17;
  IIODictionary::~IIODictionary((IIODictionary *)&v11);
  IIODictionary::~IIODictionary((IIODictionary *)&v14);
  return v7;
}

void sub_1887A6844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)(v3 - 48));
  _Unwind_Resume(a1);
}

__CFDictionary *HEIFReadPlugin::copyHDRGainMapDictionary(uint64_t a1, uint64_t a2, GlobalHEIFInfo *this, uint64_t a4)
{
  HEIFMainImageAtIndeCGFloat x = (HEIFMainImage *)GlobalHEIFInfo::getHEIFMainImageAtIndex(this, *(_DWORD *)(a1 + 504));
  int NumberOfAuxImages = HEIFMainImage::getNumberOfAuxImages(HEIFMainImageAtIndex);
  CFStringRef v9 = *(const __CFString **)gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap;
  long long cf = 0uLL;
  if ((gIIODebugFlags & 0x300000) != 0) {
    ImageIOLog("☀️  %s\n", "copyHDRGainMapDictionary");
  }
  if (NumberOfAuxImages)
  {
    uint64_t v10 = 0;
    int v11 = NumberOfAuxImages;
    while (1)
    {
      HEIFAuxImageAtIndeCGFloat x = (IIOImageWriteSession *)HEIFMainImage::getHEIFAuxImageAtIndex(HEIFMainImageAtIndex, v10);
      if (HEIFAuxImage::auxiliaryType(HEIFAuxImageAtIndex) == 4)
      {
        CFStringRef Size = (const __CFString *)IIOImageWriteSession::getSize(HEIFAuxImageAtIndex);
        if (!v9 || !Size) {
          goto LABEL_13;
        }
        if (CFEqual(v9, Size)) {
          break;
        }
      }
      if (v11 == ++v10) {
        goto LABEL_15;
      }
    }
    AuxiliaryImageForIndeCGFloat x = gFunc_CMPhotoDecompressionContainerCreateAuxiliaryImageForIndex(a2, *(unsigned int *)(a1 + 504), v10, *(void *)(a4 + 8), 2, (char *)&cf + 8);
    if (AuxiliaryImageForIndex)
    {
      IIOCMErrorString(AuxiliaryImageForIndex);
      _cg_jpeg_mem_term("copyHDRGainMapDictionary", 1841, "*** CMPhotoDecompressionContainerCreateAuxiliaryImageForIndex[%d]  err = %s [%d]\n");
      goto LABEL_15;
    }
LABEL_13:
    int v15 = gFunc_CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithOptions(a2, *(unsigned int *)(a1 + 504), v10, 0, &cf);
    if (v15)
    {
      IIOCMErrorString(v15);
      _cg_jpeg_mem_term("copyHDRGainMapDictionary", 1850, "*** CMPhotoDecompressionContainerCopyAuxiliaryImageMetadataForIndexWithOptions[%d]  err = %s [%d]\n");
    }
  }
LABEL_15:
  if (cf == 0) {
    return 0;
  }
  uint64_t Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 2, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v17 = Mutable;
  if (*((void *)&cf + 1))
  {
    CFDictionarySetValue(Mutable, *(const void **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap, *((const void **)&cf + 1));
    CFRelease(*((CFTypeRef *)&cf + 1));
  }
  if ((void)cf)
  {
    CFDictionarySetValue(v17, *(const void **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeMetadata, (const void *)cf);
    CFRelease((CFTypeRef)cf);
  }
  return v17;
}

uint64_t HEIFReadPlugin::createFlexGTCInfo(HEIFReadPlugin *this, IIODictionary *a2, id *a3)
{
  IIO_LoadHEIFSymbols();
  CFDictionaryRef v21 = 0;
  uint64_t v22 = 0;
  if ((gIIODebugFlags & 0x300000) != 0) {
    ImageIOLog("☀️  %s\n", "createFlexGTCInfo");
  }
  char v6 = *((unsigned char *)this + 492);
  *((unsigned char *)this + 492) = 0;
  uint64_t FlexGTCInfo = (*(uint64_t (**)(HEIFReadPlugin *, void, void, __IOSurface **, const __CFDictionary **))(*(void *)this + 224))(this, 0, *((void *)a2 + 1), &v22, &v21);
  if (v22)
  {
    if ((gIIODebugFlags & 0x2000000) != 0) {
      LogSurfaceFormat(v22, "inputSurface", "createFlexGTCInfo", 1894);
    }
    if (v21)
    {
      xpc_object_t value = 0;
      CFTypeRef v18 = 0;
      CFTypeRef cf = 0;
      CFDictionaryGetValueIfPresent(v21, *(const void **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap, (const void **)&value);
      CFDictionaryGetValueIfPresent(v21, *(const void **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeMetadata, &cf);
      if (cf)
      {
        CFTypeID v8 = CFGetTypeID(cf);
        if (v8 == CFDictionaryGetTypeID())
        {
          CGImageCreateFlexRangeMetadata((uint64_t)cf, (uint64_t *)&v18);
          CFTypeRef v9 = v18;
        }
        else
        {
          CFTypeRef v9 = CFRetain(cf);
          CFTypeRef v18 = v9;
        }
        IIODictionary::setObjectForKey(a2, v9, @"kCGImageAuxiliaryDataInfoMetadata");
        CFRelease(v18);
      }
      uint64_t v10 = (IIODictionary *)*((void *)this + 7);
      if (v10 && (CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(v10, @"{MakerApple}")) != 0)
      {
        IIODictionary::setObjectForKey(a2, ObjectForKey, @"{MakerApple}");
      }
      else
      {
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        uint64_t v17 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v15);
        IIONumber::IIONumber((IIONumber *)v14, *((float *)this + 127));
        IIODictionary::setObjectForKey((uint64_t)&v15, (uint64_t)v14, @"33");
        IIONumber::~IIONumber((IIONumber *)v14);
        IIONumber::IIONumber((IIONumber *)v13, *((float *)this + 128));
        IIODictionary::setObjectForKey((uint64_t)&v15, (uint64_t)v13, @"48");
        IIONumber::~IIONumber((IIONumber *)v13);
        IIODictionary::setObjectForKey(a2, v16, @"{MakerApple}");
        IIODictionary::~IIODictionary((IIODictionary *)&v15);
      }
      if ((gIIODebugFlags & 0x300000) != 0) {
        ImageIOLog("☀️  'IIOCallCreateFlexGTCInfo'\n");
      }
      uint64_t FlexGTCInfo = IIOCallCreateFlexGTCInfo((uint64_t)v22, (uint64_t)value, a3, *((void **)a2 + 1));
      CFRelease(v21);
    }
    else
    {
      _cg_jpeg_mem_term("createFlexGTCInfo", 1937, "*** ERROR: createFlexGTCInfo - failed to extract gainMap\n");
      uint64_t FlexGTCInfo = 4294967246;
    }
    CFRelease(v22);
  }
  *((unsigned char *)this + 492) = v6;
  return FlexGTCInfo;
}

void sub_1887A6D54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::copyImageBlockSetTiles(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary **a4, unsigned int a5, double a6, double a7, double a8, double a9, uint64_t a10, _DWORD *a11)
{
  double v16 = a6;
  uint64_t v17 = a3;
  CFTypeRef v144 = 0;
  *a11 = 0;
  if (a3)
  {
    CGImageProviderGetSize();
    double v21 = v20;
    double v23 = v22;
    PixelCFStringRef Size = CGImageProviderGetPixelSize();
  }
  else
  {
    LODWORD(a6) = *(_DWORD *)(a1 + 292);
    double v21 = (double)*(unint64_t *)&a6;
    LODWORD(a6) = *(_DWORD *)(a1 + 296);
    double v23 = (double)*(unint64_t *)&a6;
    PixelCFStringRef Size = *(unsigned __int16 *)(a1 + 308);
  }
  v145[0] = 0;
  if ((a5 & 0x1FF) != 0) {
    unsigned int v25 = 512;
  }
  else {
    unsigned int v25 = a5;
  }
  if (!v25)
  {
    uint64_t v108 = 0;
    BOOL v36 = 0;
    uint64_t v37 = 0;
    goto LABEL_135;
  }
  uint64_t v127 = a2;
  uint64_t v128 = v17;
  unsigned int v26 = (v16 / (double)v25);
  double v27 = (double)(v25 - 1);
  unsigned int v28 = ((v16 + a8 + v27) / (double)v25);
  unsigned int v29 = (a7 / (double)v25);
  unsigned int v30 = ((a7 + a9 + v27) / (double)v25);
  unsigned int v31 = v30 - v29;
  uint32x2_t v32 = vmin_u32((uint32x2_t)vdup_n_s32(v25), *(uint32x2_t *)(a1 + 228));
  *(uint32x2_t *)(a1 + 292) = v32;
  *(_DWORD *)(a1 + 236) = 16 * (unint64_t)((a8 * (double)PixelSize + 15.0) * 0.0625);
  *(_DWORD *)(a1 + 300) = v32.i32[0] * PixelSize;
  *(_DWORD *)(a1 + 104) = (v28 - v26) * (v30 - v29);
  int v33 = IIOCreateCMPhotoDecompressionSession((uint64_t)&v144);
  if (v33)
  {
    int v34 = v33;
    uint64_t v35 = IIOCMErrorString(v33);
    _cg_jpeg_mem_term("copyImageBlockSetTiles", 2779, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v35, v34);
    BOOL v36 = 0;
    uint64_t v37 = 0;
    CFDataRef v38 = 0;
    uint64_t v17 = v128;
LABEL_132:
    uint64_t v108 = IIOReadPlugin::imageBlockSetCreate(a1, v17, *(unsigned int *)(a1 + 104), *(double *)(a1 + 136), *(double *)(a1 + 144), *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(void *)(a1 + 96), v127);
    CFDataRef v107 = v38;
    goto LABEL_133;
  }
  unsigned int v129 = (void *)(a1 + 292);
  unsigned int v125 = (v16 / (double)v25);
  unsigned int v126 = v30;
  unsigned int v131 = (a7 / (double)v25);
  unsigned int v132 = v25;
  unsigned int v133 = v28;
  CFTypeRef v143 = 0;
  int v142 = 0;
  unsigned int v141 = 0;
  CFStringRef Size = IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24));
  CFDictionaryRef v40 = IIOImageReadSession::retainBytePointer(*(IIOImageReadSession **)(a1 + 24), (const __CFData **)&v141, 1);
  if (!v40)
  {
    LogError("copyImageBlockSetTiles", 2792, "*** ERROR: retainBytePointer failed\n");
    uint64_t v108 = 0;
    BOOL v36 = 0;
    uint64_t v37 = 0;
    uint64_t v17 = v128;
    goto LABEL_135;
  }
  unsigned int v41 = (const UInt8 *)v40;
  uint64_t v42 = *(void *)(a1 + 464);
  uint64_t v17 = v128;
  if (v42)
  {
    if (*(void *)(a1 + 472)) {
      CFStringRef Size = *(IIOImageRead **)(a1 + 472);
    }
    else {
      uint64_t v42 = 0;
    }
    unsigned int v41 = (const UInt8 *)v40 + v42;
  }
  CFDataRef v43 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v41, (CFIndex)Size, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  CFDataRef v122 = v43;
  if (!v43) {
    goto LABEL_19;
  }
  int v45 = gFunc_CMPhotoDecompressionSessionCreateContainer(v144, 0, v43, &v142, &v143);
  if (v45)
  {
    int v46 = v45;
    int v47 = IIOCMErrorString(v45);
    __n128 v44 = _cg_jpeg_mem_term("copyImageBlockSetTiles", 2809, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v47, v46);
LABEL_19:
    uint64_t v37 = 0;
    BOOL v36 = 0;
    char v48 = 1;
    goto LABEL_127;
  }
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
  BOOL v111 = IIOImageReadSession::mapData(*(IIOImageRead ***)(a1 + 24));
  uint64_t v138 = 0;
  uint64_t v139 = 0;
  uint64_t v140 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v138);
  uint64_t v137 = 0;
  unsigned int PixelFormatForBitDepth = HEIFReadPlugin::getPixelFormatForBitDepth((HEIFReadPlugin *)a1, *(unsigned __int16 *)(a1 + 304), *(IIODictionary **)(a1 + 48));
  HEIFReadPlugin::updateHardwareDecodeOptions((IIODictionary **)a1, (IIODictionary *)&v138, a4);
  IIONumber::IIONumber((IIONumber *)v136, PixelFormatForBitDepth);
  IIODictionary::setObjectForKey((uint64_t)&v138, (uint64_t)v136, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
  IIONumber::~IIONumber((IIONumber *)v136);
  HEIFReadPlugin::updateCreateImageOptions((HEIFReadPlugin *)a1, (IIODictionary *)&v138, *(IIODictionary **)(a1 + 48));
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    copyImageBlockSetTiles - decoding %d x %d tiles\n", v31, v28 - v26);
  }
  if (v126 <= v29)
  {
    uint64_t v37 = 0;
    char v130 = 1;
  }
  else
  {
    uint64_t v37 = 0;
    unsigned int v50 = 0;
    unsigned int v119 = HIBYTE(PixelFormatForBitDepth);
    uint64_t v118 = MEMORY[0x1E4F14390] + 60 + 4 * HIBYTE(PixelFormatForBitDepth);
    unsigned int v121 = (int)(PixelFormatForBitDepth << 8) >> 24;
    unsigned int v120 = (__int16)PixelFormatForBitDepth >> 8;
    CGRect v113 = (_DWORD *)(MEMORY[0x1E4F14390] + 60 + 4 * v120);
    unsigned int v114 = (_DWORD *)(MEMORY[0x1E4F14390] + 60 + 4 * v121);
    unsigned int v116 = PixelFormatForBitDepth << 16;
    unsigned int v117 = PixelFormatForBitDepth << 8;
    unsigned int v123 = (char)PixelFormatForBitDepth;
    unsigned int v115 = PixelFormatForBitDepth << 24;
    CGRect v112 = (_DWORD *)(MEMORY[0x1E4F14390] + 60 + 4 * (char)PixelFormatForBitDepth);
    char v130 = 1;
    do
    {
      unsigned int v51 = *(_DWORD *)(a1 + 296);
      double v52 = (double)(v51 * v131);
      double v53 = (double)v51;
      if ((double)v51 + v52 <= v23) {
        double v54 = (double)v51;
      }
      else {
        double v54 = v23 - (double)(v51 * v131);
      }
      unsigned int v55 = v125;
      if (v133 <= v125)
      {
LABEL_94:
        char v96 = 1;
      }
      else
      {
        while (1)
        {
          double v56 = (double)(v55 * v132);
          LODWORD(v53) = *(_DWORD *)(a1 + 292);
          double v57 = (double)*(unint64_t *)&v53;
          if (v56 + v57 <= v21) {
            double v58 = v57;
          }
          else {
            double v58 = v21 - (double)(v55 * v132);
          }
          uint64_t v37 = (char *)_ImageIO_Malloc(*(unsigned int *)(a1 + 300) * (unint64_t)*(unsigned int *)(a1 + 296), *(void *)(a1 + 384), v145, (uint64_t)kImageMalloc_HEIF_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
          if (!v37)
          {
            IIODictionary::~IIODictionary((IIODictionary *)&v138);
            uint64_t v108 = 0;
            uint64_t v17 = v128;
            CFDataRef v107 = v122;
            BOOL v36 = v111;
            goto LABEL_133;
          }
          unsigned int v59 = *(unsigned __int16 *)(a1 + 316);
          double v60 = v59 >= 2 ? v56 * (double)v59 : (double)(v55 * v132);
          double v61 = v59 >= 2 ? v52 * (double)v59 : v52;
          double v62 = v59 >= 2 ? v58 * (double)v59 : v58;
          double v63 = v59 >= 2 ? v54 * (double)v59 : v54;
          CFDictionaryRef DictionaryRepresentation = CGRectCreateDictionaryRepresentation(*(CGRect *)&v60);
          IIODictionary::setObjectForKey((IIODictionary *)&v138, DictionaryRepresentation, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_SourceCropRect);
          CFRelease(DictionaryRepresentation);
          int v65 = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(v143, *(unsigned int *)(a1 + 504), v139, 2, &v137);
          int v66 = v65;
          if (v65) {
            break;
          }
          gFunc_CVPixelBufferLockBaseAddress(v137, 0);
          int IsPlanar = gFunc_CVPixelBufferIsPlanar(v137);
          PixelFormatint Type = gFunc_CVPixelBufferGetPixelFormatType(v137);
          int v69 = PixelFormatType;
          if (IsPlanar)
          {
            unsigned int v70 = PixelFormatType >> 24;
            if (PixelFormatType < 0) {
              int v71 = __maskrune(PixelFormatType >> 24, 0x40000uLL);
            }
            else {
              int v71 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v70 + 60) & 0x40000;
            }
            if (v71) {
              uint64_t v83 = v70;
            }
            else {
              uint64_t v83 = 46;
            }
            unsigned int v84 = v69 << 8 >> 24;
            if (v69 << 8 < 0) {
              int v85 = __maskrune(v69 << 8 >> 24, 0x40000uLL);
            }
            else {
              int v85 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v84 + 60) & 0x40000;
            }
            if (v85) {
              uint64_t v86 = v84;
            }
            else {
              uint64_t v86 = 46;
            }
            unsigned int v87 = (__int16)v69 >> 8;
            if (v69 << 16 < 0) {
              int v88 = __maskrune((__int16)v69 >> 8, 0x40000uLL);
            }
            else {
              int v88 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v87 + 60) & 0x40000;
            }
            if ((v69 << 24) <= 0x7F000000) {
              int v89 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v69 + 60) & 0x40000;
            }
            else {
              int v89 = __maskrune((char)v69, 0x40000uLL);
            }
            if (v88) {
              uint64_t v90 = v87;
            }
            else {
              uint64_t v90 = 46;
            }
            if (v89) {
              uint64_t v91 = (char)v69;
            }
            else {
              uint64_t v91 = 46;
            }
            __n128 v75 = _cg_jpeg_mem_term("copyImageBlockSetTiles", 2904, "*** '%c%c%c%c' request returned planar data - not handled\n", v83, v86, v90, v91);
          }
          else
          {
            BaseAddress = (char *)gFunc_CVPixelBufferGetBaseAddress(v137);
            unint64_t BytesPerRow = gFunc_CVPixelBufferGetBytesPerRow(v137);
            unint64_t Height = gFunc_CVPixelBufferGetHeight(v137);
            unint64_t v76 = *(unsigned int *)(a1 + 300);
            if (BytesPerRow >= v76) {
              size_t v77 = *(unsigned int *)(a1 + 300);
            }
            else {
              size_t v77 = BytesPerRow;
            }
            if (Height >= *(unsigned int *)(a1 + 296)) {
              int v78 = *(_DWORD *)(a1 + 296);
            }
            else {
              int v78 = Height;
            }
            if (v78)
            {
              uint64_t v79 = v37;
              do
              {
                memcpy(v79, BaseAddress, v77);
                unint64_t v76 = *(unsigned int *)(a1 + 300);
                v79 += v76;
                BaseAddress += BytesPerRow;
                --v78;
              }
              while (v78);
            }
            if (v69 == 1111970369 && *(unsigned char *)(a1 + 404) == 1) {
              goto LABEL_151;
            }
            vImagePixelCount v80 = *(unsigned int *)v129;
            if (v76 >= 4 * (int)v80)
            {
              vImagePixelCount v81 = *(unsigned int *)(a1 + 296);
              dest.data = v37;
              dest.double height = v81;
              dest.unint64_t width = v80;
              dest.rowunint64_t Bytes = v76;
              *(_DWORD *)permuteMap = 50331906;
              vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0);
            }
            if (*(unsigned char *)(a1 + 404) == 1)
            {
LABEL_151:
              if (*(unsigned char *)(a1 + 500) && !*(unsigned char *)(a1 + 501))
              {
                dest.data = v37;
                v82.i64[0] = *v129;
                v82.i64[1] = HIDWORD(*v129);
                *(int8x16_t *)&dest.double height = vextq_s8(v82, v82, 8uLL);
                dest.rowunint64_t Bytes = *(unsigned int *)(a1 + 300);
                vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
              }
            }
            char v130 = 1;
          }
          v92.n128_f64[0] = gFunc_CVPixelBufferUnlockBaseAddress(v137, 0, v75);
          gFunc_CVPixelBufferRelease(v92);
          v146.origin.CGFloat x = (double)(v55 * v132);
          v146.origin.CGFloat y = v52;
          v146.size.unint64_t width = v58;
          v146.size.double height = v54;
          *(void *)(*(void *)(a1 + 96) + 8 * v50) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v37, v145[0], v146, *(unsigned int *)(a1 + 300), 0);
          if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E4F1DB20]))
          {
            double v93 = v52;
            double v94 = v54;
          }
          else
          {
            v147.origin.CGFloat x = (double)(v55 * v132);
            v147.origin.CGFloat y = v52;
            v147.size.unint64_t width = v58;
            v147.size.double height = v54;
            *(CGRect *)&double v53 = CGRectUnion(*(CGRect *)(a1 + 120), v147);
            double v56 = v53;
            double v58 = v95;
          }
          *(double *)(a1 + 120) = v56;
          *(double *)(a1 + 128) = v93;
          *(double *)(a1 + 136) = v58;
          *(double *)(a1 + 144) = v94;
          ++v50;
          if (++v55 == v133)
          {
            uint64_t v37 = 0;
            goto LABEL_94;
          }
        }
        if (v65 == -15470)
        {
          if (v128) {
            CGImageProviderSetProperty();
          }
          char v96 = 0;
        }
        else
        {
          char v96 = 1;
        }
        CGColorSpaceRef v97 = IIOCMErrorString(v66);
        _cg_jpeg_mem_term("copyImageBlockSetTiles", 2890, "*** CMPhotoDecompressionContainerCreateImageForIndex  err = %s [%d]\n", v97, v66);
        if ((*(unsigned char *)(v118 + 2) & 4) != 0) {
          uint64_t v98 = v119;
        }
        else {
          uint64_t v98 = 46;
        }
        if ((v117 & 0x80000000) != 0) {
          int v99 = __maskrune(v121, 0x40000uLL);
        }
        else {
          int v99 = *v114 & 0x40000;
        }
        if (v99) {
          uint64_t v100 = v121;
        }
        else {
          uint64_t v100 = 46;
        }
        if ((v116 & 0x80000000) != 0) {
          int v101 = __maskrune(v120, 0x40000uLL);
        }
        else {
          int v101 = *v113 & 0x40000;
        }
        if (v115 <= 0x7F000000) {
          int v102 = *v112 & 0x40000;
        }
        else {
          int v102 = __maskrune(v123, 0x40000uLL);
        }
        if (v101) {
          uint64_t v103 = v120;
        }
        else {
          uint64_t v103 = 46;
        }
        if (v102) {
          uint64_t v104 = v123;
        }
        else {
          uint64_t v104 = 46;
        }
        *(void *)&double v105 = _cg_jpeg_mem_term("copyImageBlockSetTiles", 2891, "    outputPixelFormat: %c%c%c%c\n", v98, v100, v103, v104).n128_u64[0];
        _cg_jpeg_mem_term(v139, 4, "cmPhotoContainer", v105);
        char v130 = 0;
      }
      ++v131;
    }
    while (v131 < v126 && (v96 & 1) != 0);
  }
  CFRelease(v143);
  uint64_t v17 = v128;
  IIODictionary::~IIODictionary((IIODictionary *)&v138);
  char v48 = v130 & 1;
  BOOL v36 = v111;
LABEL_127:
  gFunc_CMPhotoDecompressionSessionFlushCachedBuffers(v144, 0, 0, v44);
  CFRelease(v144);
  if (v141)
  {
    unint64_t v106 = *(IIOImageRead ***)(a1 + 24);
    if (v106) {
      IIOImageReadSession::releaseBytePointer(v106, v141);
    }
  }
  CFDataRef v107 = v122;
  if (v48)
  {
    CFDataRef v38 = v122;
    goto LABEL_132;
  }
  uint64_t v108 = 0;
LABEL_133:
  if (v107) {
    CFRelease(v107);
  }
LABEL_135:
  if (v17)
  {
    IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
  }
  else if (*(_DWORD *)(a1 + 104))
  {
    *a11 = 1;
  }
  if (v36)
  {
    uint64_t v109 = *(const char ***)(a1 + 24);
    if (v109) {
      IIOImageReadSession::unmapData(v109);
    }
  }
  if (v37) {
    _ImageIO_Free((unint64_t)v37, v145[0]);
  }
  return v108;
}

void sub_1887A78B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  IIONumber::~IIONumber((IIONumber *)&a38);
  IIODictionary::~IIODictionary((IIODictionary *)(v38 - 200));
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::copyImageBlockSetSingleTile(uint64_t a1, const void *a2, uint64_t a3, const __CFDictionary **a4, _DWORD *a5, double x, double y, double width, double a9)
{
  uint64_t v9 = a5;
  CFTypeRef v95 = 0;
  *a5 = 0;
  if (a3) {
    PixelCFStringRef Size = CGImageProviderGetPixelSize();
  }
  else {
    PixelCFStringRef Size = *(unsigned __int16 *)(a1 + 308);
  }
  v96[0] = 0;
  *(_DWORD *)(a1 + 104) = 1;
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, 1uLL);
  BOOL v18 = IIOImageReadSession::mapData(*(IIOImageRead ***)(a1 + 24));
  *(_DWORD *)(a1 + 292) = width;
  *(_DWORD *)(a1 + 296) = a9;
  double v19 = width * (double)PixelSize;
  *(_DWORD *)(a1 + 300) = (unint64_t)v19;
  double v20 = (char *)_ImageIO_Malloc((unint64_t)v19 * (unint64_t)a9, *(void *)(a1 + 384), v96, (uint64_t)kImageMalloc_HEIF_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
  if (!v20)
  {
LABEL_7:
    if (a3)
    {
LABEL_8:
      uint64_t v24 = 0;
      goto LABEL_9;
    }
    goto LABEL_86;
  }
  int v21 = IIOCreateCMPhotoDecompressionSession((uint64_t)&v95);
  if (v21)
  {
    int v22 = v21;
    double v23 = IIOCMErrorString(v21);
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2520, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v23, v22);
    goto LABEL_7;
  }
  vImagePixelCount v81 = v9;
  CFTypeRef v94 = 0;
  int v93 = 0;
  __n128 v92 = 0;
  CFStringRef Size = IIOImageReadSession::getSize(*(IIOImageReadSession **)(a1 + 24));
  unsigned int v26 = IIOImageReadSession::retainBytePointer(*(IIOImageReadSession **)(a1 + 24), (const __CFData **)&v92, 1);
  double v27 = (const UInt8 *)v26;
  uint64_t v28 = *(void *)(a1 + 464);
  if (v28)
  {
    if (*(void *)(a1 + 472)) {
      CFStringRef Size = *(IIOImageRead **)(a1 + 472);
    }
    else {
      uint64_t v28 = 0;
    }
    double v27 = (const UInt8 *)v26 + v28;
  }
  if (v27)
  {
    CFDataRef v29 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v27, (CFIndex)Size, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    if (v29)
    {
      CFDataRef cf = v29;
      int v30 = gFunc_CMPhotoDecompressionSessionCreateContainer(v95, 0, v29, &v93, &v94);
      if (v30)
      {
        int v31 = v30;
        uint32x2_t v32 = IIOCMErrorString(v30);
        _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2550, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v32, v31);
        BOOL v33 = 0;
      }
      else
      {
        uint64_t v89 = 0;
        uint64_t v90 = 0;
        uint64_t v91 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v89);
        uint64_t v88 = 0;
        unsigned int PixelFormatForBitDepth = HEIFReadPlugin::getPixelFormatForBitDepth((HEIFReadPlugin *)a1, *(unsigned __int16 *)(a1 + 304), *(IIODictionary **)(a1 + 48));
        if (CGImageProviderGetComponentType() == 6) {
          unsigned int v35 = 1815162994;
        }
        else {
          unsigned int v35 = PixelFormatForBitDepth;
        }
        HEIFReadPlugin::updateHardwareDecodeOptions((IIODictionary **)a1, (IIODictionary *)&v89, a4);
        IIONumber::IIONumber((IIONumber *)v87, v35);
        IIODictionary::setObjectForKey((uint64_t)&v89, (uint64_t)v87, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
        IIONumber::~IIONumber((IIONumber *)v87);
        HEIFReadPlugin::updateCreateImageOptions((HEIFReadPlugin *)a1, (IIODictionary *)&v89, *(IIODictionary **)(a1 + 48));
        double v36 = a9;
        double v37 = width;
        double v38 = y;
        double v39 = x;
        if (*(_WORD *)(a1 + 316))
        {
          IIONumber::IIONumber((IIONumber *)v86, *(_DWORD *)(a1 + 484));
          IIODictionary::setObjectForKey((uint64_t)&v89, (uint64_t)v86, *(const void **)gIIO_kCMPhotoDecompressionOption_TiledDownsampling);
          IIONumber::~IIONumber((IIONumber *)v86);
          int v40 = *(_DWORD *)(a1 + 292) <= *(_DWORD *)(a1 + 296) ? *(_DWORD *)(a1 + 296) : *(_DWORD *)(a1 + 292);
          IIONumber::IIONumber((IIONumber *)v85, v40);
          IIODictionary::setObjectForKey((uint64_t)&v89, (uint64_t)v85, *(const void **)gIIO_kCMPhotoDecompressionOption_MaxPixelSize);
          IIONumber::~IIONumber((IIONumber *)v85);
          double v36 = a9;
          unsigned int v41 = *(unsigned __int16 *)(a1 + 316);
          double v37 = width;
          double v38 = y;
          double v39 = x;
          if (v41 >= 2)
          {
            double v39 = x * (double)v41;
            double v38 = y * (double)v41;
            double v37 = width * (double)v41;
            double v36 = a9 * (double)v41;
          }
        }
        CFDictionaryRef DictionaryRepresentation = CGRectCreateDictionaryRepresentation(*(CGRect *)&v39);
        IIODictionary::setObjectForKey((IIODictionary *)&v89, DictionaryRepresentation, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_SourceCropRect);
        CFRelease(DictionaryRepresentation);
        int v43 = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(v94, *(unsigned int *)(a1 + 504), v90, 2, &v88);
        int v44 = v43;
        if (v43)
        {
          int v45 = IIOCMErrorString(v43);
          _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2597, "*** CMPhotoDecompressionContainerCreateImageForIndex  err = %s [%d]\n", v45, v44);
          LODWORD(v46) = HIBYTE(v35);
          if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * HIBYTE(v35) + 60) & 0x40000) != 0) {
            uint64_t v46 = v46;
          }
          else {
            uint64_t v46 = 46;
          }
          uint64_t v78 = v46;
          unsigned int v47 = (int)(v35 << 8) >> 24;
          uint64_t v48 = MEMORY[0x1E4F14390];
          if (((v35 << 8) & 0x80000000) != 0) {
            int v49 = __maskrune((int)(v35 << 8) >> 24, 0x40000uLL);
          }
          else {
            int v49 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v47 + 60) & 0x40000;
          }
          if (v49) {
            uint64_t v53 = v47;
          }
          else {
            uint64_t v53 = 46;
          }
          uint64_t v76 = v53;
          unsigned int v54 = (__int16)v35 >> 8;
          if (((v35 << 16) & 0x80000000) != 0) {
            int v55 = __maskrune((__int16)v35 >> 8, 0x40000uLL);
          }
          else {
            int v55 = *(_DWORD *)(v48 + 4 * v54 + 60) & 0x40000;
          }
          if (v35 << 24 <= 0x7F000000) {
            int v56 = *(_DWORD *)(v48 + 4 * (char)v35 + 60) & 0x40000;
          }
          else {
            int v56 = __maskrune((char)v35, 0x40000uLL);
          }
          if (v55) {
            uint64_t v57 = v54;
          }
          else {
            uint64_t v57 = 46;
          }
          if (v56) {
            uint64_t v58 = (char)v35;
          }
          else {
            uint64_t v58 = 46;
          }
          *(void *)&double v59 = _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2598, "    outputPixelFormat: %c%c%c%c\n", v78, v76, v57, v58).n128_u64[0];
          _cg_jpeg_mem_term(v90, 4, "cmPhotoContainer", v59);
          BOOL v33 = 0;
        }
        else
        {
          gFunc_CVPixelBufferLockBaseAddress(v88, 0);
          int IsPlanar = gFunc_CVPixelBufferIsPlanar(v88);
          BOOL v33 = IsPlanar == 0;
          PixelFormatint Type = gFunc_CVPixelBufferGetPixelFormatType(v88);
          if (IsPlanar)
          {
            __n128 v52 = _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2609, "*** 'BGRA' request returned planar data - not handled\n");
          }
          else
          {
            int v60 = PixelFormatType;
            BaseAddress = (char *)gFunc_CVPixelBufferGetBaseAddress(v88);
            unint64_t BytesPerRow = gFunc_CVPixelBufferGetBytesPerRow(v88);
            int v77 = v60;
            BOOL v79 = v18;
            unint64_t Height = gFunc_CVPixelBufferGetHeight(v88);
            unint64_t v64 = *(unsigned int *)(a1 + 300);
            if (BytesPerRow >= v64) {
              size_t v65 = *(unsigned int *)(a1 + 300);
            }
            else {
              size_t v65 = BytesPerRow;
            }
            if (Height >= *(unsigned int *)(a1 + 296)) {
              int v66 = *(_DWORD *)(a1 + 296);
            }
            else {
              int v66 = Height;
            }
            if (v66)
            {
              CFTypeRef v67 = v20;
              do
              {
                memcpy(v67, BaseAddress, v65);
                unint64_t v64 = *(unsigned int *)(a1 + 300);
                v67 += v64;
                BaseAddress += BytesPerRow;
                --v66;
              }
              while (v66);
            }
            unint64_t v68 = (void *)(a1 + 292);
            BOOL v18 = v79;
            if (v77 == 1111970369 && *(unsigned char *)(a1 + 404) != 1)
            {
              vImagePixelCount v69 = *(unsigned int *)v68;
              if (v64 >= 4 * (int)v69)
              {
                vImagePixelCount v70 = *(unsigned int *)(a1 + 296);
                dest.data = v20;
                dest.double height = v70;
                dest.unint64_t width = v69;
                dest.rowunint64_t Bytes = v64;
                *(_DWORD *)permuteMap = 50331906;
                vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
              }
            }
            if (*(unsigned char *)(a1 + 404) == 1 && *(unsigned char *)(a1 + 500) && !*(unsigned char *)(a1 + 501))
            {
              dest.data = v20;
              v71.i64[0] = *v68;
              v71.i64[1] = HIDWORD(*v68);
              *(int8x16_t *)&dest.double height = vextq_s8(v71, v71, 8uLL);
              dest.rowunint64_t Bytes = *(unsigned int *)(a1 + 300);
              vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
            }
          }
          v72.n128_f64[0] = gFunc_CVPixelBufferUnlockBaseAddress(v88, 0, v52);
          gFunc_CVPixelBufferRelease(v72);
        }
        CFRelease(v94);
        IIODictionary::~IIODictionary((IIODictionary *)&v89);
      }
      CFRelease(v95);
      CFRelease(cf);
    }
    else
    {
      CFRelease(v95);
      BOOL v33 = 0;
    }
    if (v92)
    {
      uint64_t v73 = *(IIOImageRead ***)(a1 + 24);
      if (v73) {
        IIOImageReadSession::releaseBytePointer(v73, v92);
      }
    }
    if (v33)
    {
      v97.origin.CGFloat x = x;
      v97.origin.CGFloat y = y;
      v97.size.unint64_t width = width;
      v97.size.double height = a9;
      **(void **)(a1 + 96) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v20, v96[0], v97, *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
      if (!CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E4F1DB20]))
      {
        v99.origin.CGFloat x = x;
        v99.origin.CGFloat y = y;
        v99.size.unint64_t width = width;
        v99.size.double height = a9;
        CGRect v98 = CGRectUnion(*(CGRect *)(a1 + 120), v99);
        CGFloat x = v98.origin.x;
        CGFloat y = v98.origin.y;
        unint64_t width = v98.size.width;
        a9 = v98.size.height;
      }
      *(double *)(a1 + 120) = x;
      *(double *)(a1 + 128) = y;
      *(double *)(a1 + 136) = width;
      *(double *)(a1 + 144) = a9;
      uint64_t v9 = v81;
      if (a3)
      {
        uint64_t v24 = IIOReadPlugin::imageBlockSetCreate(a1, a3, *(unsigned int *)(a1 + 104), width, a9, x, y, width, a9, *(void *)(a1 + 96), a2);
        double v20 = 0;
LABEL_9:
        IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
        if (!v18) {
          goto LABEL_92;
        }
        goto LABEL_90;
      }
      double v20 = 0;
      goto LABEL_86;
    }
  }
  else
  {
    LogError("copyImageBlockSetSingleTile", 2540, "*** ERROR: retainBytePointer failed\n");
  }
  uint64_t v9 = v81;
  if (a3) {
    goto LABEL_8;
  }
LABEL_86:
  if (*(_DWORD *)(a1 + 104))
  {
    uint64_t v24 = 0;
    *uint64_t v9 = 1;
    if (!v18) {
      goto LABEL_92;
    }
  }
  else
  {
    uint64_t v24 = 0;
    if (!v18) {
      goto LABEL_92;
    }
  }
LABEL_90:
  unint64_t v74 = *(const char ***)(a1 + 24);
  if (v74) {
    IIOImageReadSession::unmapData(v74);
  }
LABEL_92:
  if (v20) {
    _ImageIO_Free((unint64_t)v20, v96[0]);
  }
  return v24;
}

void sub_1887A8164(_Unwind_Exception *a1)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 184));
  _Unwind_Resume(a1);
}

__IOSurface *HEIFReadPlugin::createSurfaceWithGainMapApplied(uint64_t a1, uint64_t a2, uint64_t a3, GlobalHEIFInfo *a4, __IOSurface *a5)
{
  uint64_t v42 = 0;
  int v43 = 0;
  uint64_t v44 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v42);
  CFTypeRef v40 = 0;
  unsigned int v41 = 0;
  double v38 = 0;
  xpc_object_t value = 0;
  double Current = CFAbsoluteTimeGetCurrent();
  if ((gIIODebugFlags & 0x300000) != 0) {
    ImageIOLog("☀️  %s\n", "createSurfaceWithGainMapApplied");
  }
  if (*(unsigned char *)(a1 + 495)) {
    CFDictionaryRef v10 = (const __CFDictionary *)HEIFReadPlugin::copyISOGainMapDictionary(a1, a2);
  }
  else {
    CFDictionaryRef v10 = HEIFReadPlugin::copyHDRGainMapDictionary(a1, a2, a4, (uint64_t)&v42);
  }
  CFDictionaryRef v11 = v10;
  if (!v10)
  {
    BOOL v18 = 0;
    goto LABEL_40;
  }
  CFDictionaryGetValueIfPresent(v10, *(const void **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeGainMap, (const void **)&value);
  CFDictionaryGetValueIfPresent(v11, *(const void **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeMetadata, (const void **)&v41);
  CFDictionaryGetValueIfPresent(v11, *(const void **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeColorSpace, (const void **)&v38);
  if (!value) {
    goto LABEL_38;
  }
  size_t Width = IOSurfaceGetWidth(a5);
  size_t Height = IOSurfaceGetHeight(a5);
  CFStringRef v14 = *(const __CFString **)(a1 + 520);
  int v15 = *(_DWORD *)(a1 + 444);
  float v16 = *(float *)(a1 + 448);
  IOSurfaceWithFormat = IIO_CreateIOSurfaceWithFormat(Width, Height, 0, *(_DWORD *)(a1 + 440), 0, *(unsigned int *)(a1 + 432));
  BOOL v18 = IOSurfaceWithFormat;
  if ((gIIODebugFlags & 0x2000000) != 0) {
    LogSurfaceFormat(IOSurfaceWithFormat, "outputSurface", "createSurfaceWithGainMapApplied", 3507);
  }
  CGImageAlphaInfo Alpha = IIO_IOSurfaceGetAlpha(a5);
  IIO_IOSurfaceSetAlpha(v18, Alpha);
  if (*(unsigned char *)(a1 + 496) && CGColorSpaceContainsFlexGTCInfo())
  {
    CGColorSpaceRef v20 = CGColorSpaceRetain(*(CGColorSpaceRef *)(a1 + 160));
  }
  else
  {
    int v21 = CGColorSpaceCreateWithName(v14);
    if (v21) {
      goto LABEL_18;
    }
    int v21 = CGColorSpaceRetain((CGColorSpaceRef)v38);
    if (v21) {
      goto LABEL_18;
    }
    CGColorSpaceRef v20 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC50]);
  }
  int v21 = v20;
LABEL_18:
  CFPropertyListRef v22 = CGColorSpaceCopyPropertyList(v21);
  if (v22)
  {
    IOSurfaceSetValue(v18, (CFStringRef)*MEMORY[0x1E4F2F068], v22);
    CFRelease(v22);
  }
  CGColorSpaceRelease(v21);
  if ((v15 - 1) <= 2) {
    IOSurfaceSetYCbCrMatrix();
  }
  if (v16 > 0.0)
  {
    IIONumber::IIONumber((IIONumber *)v36, v16);
    IOSurfaceSetValue(v18, @"IOSurfaceContentHeadroom", v37);
    IIONumber::~IIONumber((IIONumber *)v36);
  }
  float v23 = *(float *)(a1 + 452);
  if (v23 > 0.0)
  {
    IIONumber::IIONumber((IIONumber *)v35, v23);
    IIODictionary::setObjectForKey((uint64_t)&v42, (uint64_t)v35, @"kCGTargetHeadroom");
    IIONumber::~IIONumber((IIONumber *)v35);
  }
  float v24 = *(float *)(a1 + 456);
  if (v24 > 0.0)
  {
    IIONumber::IIONumber((IIONumber *)v34, v24);
    IIODictionary::setObjectForKey((uint64_t)&v42, (uint64_t)v34, @"kCGFallbackHDRGain");
    IIONumber::~IIONumber((IIONumber *)v34);
  }
  IIONumber::IIONumber((IIONumber *)v33, *(unsigned __int8 *)(a1 + 497));
  IIODictionary::setObjectForKey((uint64_t)&v42, (uint64_t)v33, @"kCGDisableMetal");
  IIONumber::~IIONumber((IIONumber *)v33);
  IIONumber::IIONumber((IIONumber *)v32, *(unsigned __int8 *)(a1 + 496));
  IIODictionary::setObjectForKey((uint64_t)&v42, (uint64_t)v32, @"kCGGenerateFlexGTC");
  IIONumber::~IIONumber((IIONumber *)v32);
  IIONumber::IIONumber((IIONumber *)v31, *(_DWORD *)(a1 + 480));
  IIODictionary::setObjectForKey((uint64_t)&v42, (uint64_t)v31, @"Orientation");
  IIONumber::~IIONumber((IIONumber *)v31);
  if (v41)
  {
    CFTypeID v25 = CFGetTypeID(v41);
    if (v25 == CFDictionaryGetTypeID())
    {
      CGImageCreateFlexRangeMetadata((uint64_t)v41, (uint64_t *)&v40);
      CFTypeRef v26 = v40;
    }
    else
    {
      CFTypeRef v26 = CFRetain(v41);
      CFTypeRef v40 = v26;
    }
    IIODictionary::setObjectForKey((IIODictionary *)&v42, v26, @"kCGImageAuxiliaryDataInfoMetadata");
    CFRelease(v40);
  }
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(*(IIODictionary **)(a1 + 56), @"{MakerApple}");
  IIODictionary::setObjectForKey((IIODictionary *)&v42, ObjectForKey, @"{MakerApple}");
  IIODictionary::setObjectForKey((IIODictionary *)&v42, v38, @"kCGFlexRangeAlternateColorSpace");
  if ((gIIODebugFlags & 0x300000) != 0) {
    ImageIOLog("☀️  'IIOCallApplyHDRGainmap'\n");
  }
  int v28 = IIOCallApplyHDRGainmap(a5, (uint64_t)value, v18, v43);
  if (!v28) {
    goto LABEL_39;
  }
  _cg_jpeg_mem_term("createSurfaceWithGainMapApplied", 3581, "*** ERROR: IIOCallApplyHDRGainmap retuned %d\n", v28);
  if (!v18) {
    goto LABEL_39;
  }
  CFRelease(v18);
LABEL_38:
  BOOL v18 = 0;
LABEL_39:
  CFRelease(v11);
LABEL_40:
  if ((gIIODebugFlags & 0x300000) != 0)
  {
    CFAbsoluteTime v29 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("☀️  %s [%g ms]\n", "createSurfaceWithGainMapApplied", (v29 - Current) * 1000.0);
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v42);
  return v18;
}

void sub_1887A868C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v13 - 120));
  _Unwind_Resume(a1);
}

__IOSurface *HEIFReadPlugin::createSurfaceWithToneMapApplied(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __IOSurface *a5, int a6, const __CFString *a7, int a8)
{
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v23 = 0;
  float v24 = 0;
  uint64_t v25 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v23);
  uint64_t v13 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!a8) {
    uint64_t v13 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  IIODictionary::setObjectForKey((IIODictionary *)&v23, *v13, @"kCGDisableMetal");
  if ((gIIODebugFlags & 0x300000) != 0) {
    ImageIOLog("☀️  %s\n", "createSurfaceWithToneMapApplied");
  }
  size_t Width = IOSurfaceGetWidth(a5);
  size_t Height = IOSurfaceGetHeight(a5);
  IOSurfaceWithFormat = IIO_CreateIOSurfaceWithFormat(Width, Height, 0, a6, 0, 0);
  uint64_t v17 = IOSurfaceWithFormat;
  if ((gIIODebugFlags & 0x2000000) != 0) {
    LogSurfaceFormat(IOSurfaceWithFormat, "outputSurface", "createSurfaceWithToneMapApplied", 3614);
  }
  BOOL v18 = CGColorSpaceCreateWithName(a7);
  CFPropertyListRef v19 = CGColorSpaceCopyPropertyList(v18);
  if (v19)
  {
    IOSurfaceSetValue(v17, (CFStringRef)*MEMORY[0x1E4F2F068], v19);
    CFRelease(v19);
  }
  CGColorSpaceRelease(v18);
  if ((gIIODebugFlags & 0x300000) != 0) {
    ImageIOLog("☀️  'IIOCallConvertHDRData'\n");
  }
  int v20 = IIOCallConvertHDRData(a5, v17, v24);
  if (v20)
  {
    _cg_jpeg_mem_term("createSurfaceWithToneMapApplied", 3628, "*** ERROR: IIOCallConvertHDRData retuned %d\n", v20);
    if (v17)
    {
      CFRelease(v17);
      uint64_t v17 = 0;
    }
  }
  if ((gIIODebugFlags & 0x300000) != 0)
  {
    CFAbsoluteTime v21 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("☀️  %s [%g ms]\n", "createSurfaceWithToneMapApplied", (v21 - Current) * 1000.0);
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v23);
  return v17;
}

void sub_1887A8908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t HEIFReadPlugin::decodeIntoIOSurface(HEIFReadPlugin *this, IIODecodeParameter *a2, __IOSurface *a3)
{
  memset(v64, 0, 24);
  CFDictionaryRef XmpData = (const __CFDictionary *)_APP1XMP::getXmpData(a2);
  IIODictionary::IIODictionary((IIODictionary *)v64, XmpData);
  uint64_t v7 = *((void *)a2 + 2);
  xpc_object_t value = 0;
  uint64_t v8 = (IIOImageRead **)*((void *)this + 3);
  if (!v8)
  {
LABEL_6:
    uint64_t v9 = 4294967246;
    goto LABEL_7;
  }
  if (*((unsigned char *)this + 492) || *((unsigned char *)this + 493))
  {
    if ((gIIODebugFlags & 0x300000) != 0) {
      ImageIOLog("☀️  ***ERROR: cannot applyGainMap / applyToneMap into a caller-provided IOSurface\n");
    }
    goto LABEL_6;
  }
  BOOL v11 = IIOImageReadSession::mapData(v8);
  CFTypeRef v62 = 0;
  if (!gFunc_CMPhotoDecompressionSessionCreate) {
    _cg_jpeg_mem_term("decodeIntoIOSurface", 3083, "*** CMPhotoDecompressionSessionCreate symbol not found\n");
  }
  uint64_t v12 = IIOCreateCMPhotoDecompressionSession((uint64_t)&v62);
  uint64_t v9 = v12;
  if (v12)
  {
    uint64_t v13 = IIOCMErrorString(v12);
    __n128 v14 = _cg_jpeg_mem_term("decodeIntoIOSurface", 3090, "*** CMPhotoDecompressionSessionCreate  err = %s [%d]\n", v13, v9);
    goto LABEL_12;
  }
  CFTypeRef cf = 0;
  CFTypeRef v61 = 0;
  int v59 = 0;
  uint64_t v58 = 0;
  CFStringRef Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  uint64_t v17 = IIOImageReadSession::retainBytePointer(*((IIOImageReadSession **)this + 3), (const __CFData **)&v58, 1);
  BOOL v18 = (const UInt8 *)v17;
  if (v17)
  {
    uint64_t v19 = *((void *)this + 58);
    if (v19)
    {
      if (*((void *)this + 59)) {
        CFStringRef Size = (IIOImageRead *)*((void *)this + 59);
      }
      else {
        uint64_t v19 = 0;
      }
      BOOL v18 = (const UInt8 *)v17 + v19;
    }
    uint64_t v20 = *MEMORY[0x1E4F1CF80];
    CFDataRef v21 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v18, (CFIndex)Size, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
    if (v21)
    {
      uint64_t v23 = gFunc_CMPhotoDecompressionSessionCreateContainer(v62, 0, v21, &v59, &v61);
      uint64_t v9 = v23;
      if (!v23 && v61)
      {
        uint64_t v55 = 0;
        uint64_t v56 = 0;
        uint64_t v57 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v55);
        int v24 = gFunc_CVPixelBufferCreateWithIOSurface(v20, a3, 0, &value);
        int v25 = v24;
        if (v24)
        {
          CFTypeRef v26 = IIOCMErrorString(v24);
          _cg_jpeg_mem_term("decodeIntoIOSurface", 3134, "*** CVPixelBufferCreateWithIOSurface  err = %s [%d]\n", v26, v25);
        }
        signed int PixelFormat = IOSurfaceGetPixelFormat(a3);
        int v28 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1212500294);
        GlobalHEIFInfo::getHEIFMainImageAtIndex(v28, *((_DWORD *)this + 126));
        if (GlobalHEIFInfo::hasHEIFSequence(v28)) {
          int v29 = IIOImageRead::trustedURL(v28);
        }
        else {
          int v29 = 0;
        }
        HEIFReadPlugin::updateHardwareDecodeOptions((IIODictionary **)this, (IIODictionary *)&v55, v64);
        IIONumber::IIONumber((IIONumber *)v54, PixelFormat);
        IIODictionary::setObjectForKey((uint64_t)&v55, (uint64_t)v54, *(const void **)gIIO_kCMPhotoDecompressionOption_OutputPixelFormat);
        IIONumber::~IIONumber((IIONumber *)v54);
        IIODictionary::setObjectForKey((IIODictionary *)&v55, value, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_UseProvidedPixelBuffer);
        HEIFReadPlugin::updateCreateImageOptions(this, (IIODictionary *)&v55, *((IIODictionary **)this + 6));
        if (v29)
        {
          int v31 = gFunc_CMPhotoDecompressionContainerCreateSequenceContainer(v61, 0, 0, &cf);
          int v32 = v31;
          if (v31)
          {
            BOOL v33 = IIOCMErrorString(v31);
            _cg_jpeg_mem_term("decodeIntoIOSurface", 3153, "*** CMPhotoDecompressionSessionCreateContainer[sequence] err = %s [%d]\n", v33, v32);
          }
          if (*((unsigned __int8 *)this + 216) < 2u)
          {
            p_CFTypeRef cf = &cf;
          }
          else
          {
            p_CFTypeRef cf = &cf;
            if (!*((unsigned char *)this + 498)) {
              goto LABEL_41;
            }
          }
        }
        else if (*((unsigned char *)this + 216) == 2)
        {
          p_CFTypeRef cf = &v61;
          if (!*((unsigned char *)this + 498))
          {
LABEL_41:
            ThumbnailImageForIndeCGFloat x = gFunc_CMPhotoDecompressionContainerCreateThumbnailImageForIndex(*p_cf, *((unsigned int *)this + 126), 0, v56, 2, 0);
LABEL_45:
            uint64_t v9 = ThumbnailImageForIndex;
            if (ThumbnailImageForIndex)
            {
              if (ThumbnailImageForIndex == -15470 && v7) {
                CGImageProviderSetProperty();
              }
              CFTypeRef v37 = IIOCMErrorString(v9);
              _cg_jpeg_mem_term("decodeIntoIOSurface", 3194, "*** CMPhotoDecompressionContainerCreateImageForIndex  err = %s [%d]\n", v37, v9);
              unsigned int v38 = PixelFormat >> 24;
              uint64_t v39 = MEMORY[0x1E4F14390];
              if (PixelFormat < 0) {
                int v40 = __maskrune(PixelFormat >> 24, 0x40000uLL);
              }
              else {
                int v40 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v38 + 60) & 0x40000;
              }
              if (v40) {
                uint64_t v41 = v38;
              }
              else {
                uint64_t v41 = 46;
              }
              unsigned int v42 = PixelFormat << 8 >> 24;
              if (PixelFormat << 8 < 0) {
                int v43 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
              }
              else {
                int v43 = *(_DWORD *)(v39 + 4 * v42 + 60) & 0x40000;
              }
              if (v43) {
                uint64_t v44 = v42;
              }
              else {
                uint64_t v44 = 46;
              }
              unsigned int v45 = (__int16)PixelFormat >> 8;
              if (PixelFormat << 16 < 0)
              {
                int v47 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
                uint64_t v46 = v39;
              }
              else
              {
                uint64_t v46 = v39;
                int v47 = *(_DWORD *)(v39 + 4 * v45 + 60) & 0x40000;
              }
              if ((PixelFormat << 24) <= 0x7F000000) {
                int v48 = *(_DWORD *)(v46 + 4 * (char)PixelFormat + 60) & 0x40000;
              }
              else {
                int v48 = __maskrune((char)PixelFormat, 0x40000uLL);
              }
              if (v47) {
                uint64_t v49 = v45;
              }
              else {
                uint64_t v49 = 46;
              }
              if (v48) {
                uint64_t v50 = (char)PixelFormat;
              }
              else {
                uint64_t v50 = 46;
              }
              *(void *)&double v51 = _cg_jpeg_mem_term("decodeIntoIOSurface", 3195, "    outputPixelFormat: %c%c%c%c\n", v41, v44, v49, v50).n128_u64[0];
              _cg_jpeg_mem_term(v56, 4, "cmPhotoContainer", v51);
            }
            else
            {
              if (gFunc_CMPhotoDecompressionSessionDetachSurface) {
                uint64_t v9 = gFunc_CMPhotoDecompressionSessionDetachSurface(v62, a3, v36);
              }
              else {
                uint64_t v9 = 0;
              }
              if ((gIIODebugFlags & 0x2000000) != 0) {
                LogSurfaceFormat(a3, "surface", "decodeIntoIOSurface", 3205);
              }
              if (v9)
              {
                __n128 v52 = IIOCMErrorString(v9);
                _cg_jpeg_mem_term("decodeIntoIOSurface", 3208, "*** CMPhotoDecompressionSessionDetachSurface  err = %s [%d]\n", v52, v9);
              }
            }
            if (cf) {
              CFRelease(cf);
            }
            CFRelease(v61);
            IIODictionary::~IIODictionary((IIODictionary *)&v55);
            goto LABEL_84;
          }
        }
        else
        {
          p_CFTypeRef cf = &v61;
        }
        ThumbnailImageForIndeCGFloat x = gFunc_CMPhotoDecompressionContainerCreateImageForIndex(*p_cf, *((unsigned int *)this + 126), v56, 2, 0);
        goto LABEL_45;
      }
      int v30 = IIOCMErrorString(v23);
      __n128 v22 = _cg_jpeg_mem_term("decodeIntoIOSurface", 3122, "*** CMPhotoDecompressionSessionCreateContainer  err = %s [%d]\n", v30, v9);
    }
    else
    {
      uint64_t v9 = 0;
    }
LABEL_84:
    gFunc_CMPhotoDecompressionSessionFlushCachedBuffers(v62, 0, 0, v22);
    CFRelease(v62);
    if (v21) {
      CFRelease(v21);
    }
    if (v58)
    {
      uint64_t v53 = (IIOImageRead **)*((void *)this + 3);
      if (v53) {
        IIOImageReadSession::releaseBytePointer(v53, v58);
      }
    }
    goto LABEL_12;
  }
  LogError("decodeIntoIOSurface", 3105, "*** ERROR: retainBytePointer failed\n");
  uint64_t v9 = 0;
LABEL_12:
  if (v11)
  {
    int v15 = (const char **)*((void *)this + 3);
    if (v15) {
      IIOImageReadSession::unmapData(v15);
    }
  }
  if (value) {
    gFunc_CVPixelBufferRelease(v14);
  }
LABEL_7:
  IIODictionary::~IIODictionary((IIODictionary *)v64);
  return v9;
}

void sub_1887A8FE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)(v5 - 112));
  _Unwind_Resume(a1);
}

void AppleJPEGReadPlugin::AppleJPEGReadPlugin(uint64_t a1, uint64_t a2)
{
}

uint64_t AppleJPEGReadPlugin::loadDataFromXPCObject(AppleJPEGReadPlugin *this, void *a2)
{
  uint64_t DataFromXPCObject = JPEGReadPlugin::loadDataFromXPCObject(this, a2);
  if (!DataFromXPCObject)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_applejpeg", &length);
    if (length == 184)
    {
      uint64_t DataFromXPCObject = 0;
      long long v6 = *data;
      long long v7 = data[1];
      long long v8 = data[3];
      *(_OWORD *)((char *)this + 536) = data[2];
      *(_OWORD *)((char *)this + 552) = v8;
      *(_OWORD *)((char *)this + 504) = v6;
      *(_OWORD *)((char *)this + 520) = v7;
      long long v9 = data[4];
      long long v10 = data[5];
      long long v11 = data[7];
      *(_OWORD *)((char *)this + 600) = data[6];
      *(_OWORD *)((char *)this + 616) = v11;
      *(_OWORD *)((char *)this + 568) = v9;
      *(_OWORD *)((char *)this + 584) = v10;
      long long v12 = data[8];
      long long v13 = data[9];
      long long v14 = data[10];
      *((void *)this + 85) = *((void *)data + 22);
      *(_OWORD *)((char *)this + 648) = v13;
      *(_OWORD *)((char *)this + 664) = v14;
      *(_OWORD *)((char *)this + 632) = v12;
    }
    else
    {
      uint64_t DataFromXPCObject = 4294967246;
    }
    *((void *)this + 82) = 0;
    *((void *)this + 81) = 0;
    *((void *)this + 83) = 0;
    *((void *)this + 79) = 0;
    *(_OWORD *)((char *)this + 504) = 0u;
    *(_OWORD *)((char *)this + 520) = 0u;
    *(_OWORD *)((char *)this + 536) = 0u;
    *(_OWORD *)((char *)this + 552) = 0u;
    *(_OWORD *)((char *)this + 568) = 0u;
    *(_OWORD *)((char *)this + 584) = 0u;
    *(_OWORD *)((char *)this + 600) = 0u;
    *(_OWORD *)((char *)this + 616) = 0u;
    IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), *((void *)this + 57), 0);
  }
  return DataFromXPCObject;
}

uint64_t AppleJPEGReadPlugin::saveDataToXPCObject(AppleJPEGReadPlugin *this, void *a2)
{
  uint64_t v4 = JPEGReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_applejpeg", (char *)this + 504, 0xB8uLL);
  }
  return v4;
}

const char *AppleJPEGReadPlugin::appleJPEGErrorString(AppleJPEGReadPlugin *this, int a2)
{
  if ((a2 + 2) > 0xE) {
    return "";
  }
  else {
    return off_1E53CC6A8[a2 + 2];
  }
}

uint64_t AppleJPEGReadPlugin::canCreateChromaSubsampledIOSurface(AppleJPEGReadPlugin *this)
{
  return 1;
}

__n128 AppleJPEGReadPlugin::create_or_restoreIndexTable(uint64_t a1)
{
  if (*(void *)(a1 + 632) && *(void *)(a1 + 640))
  {
    uint64_t v1 = (AppleJPEGReadPlugin *)applejpeg_decode_set_ra_table();
    if (v1)
    {
      AppleJPEGReadPlugin::appleJPEGErrorString(v1, (int)v1);
      return _cg_jpeg_mem_term("create_or_restoreIndexTable", 248, "    applejpeg_decode_set_ra_table err = %d '%s'\n");
    }
  }
  else
  {
    uint64_t v3 = (AppleJPEGReadPlugin *)applejpeg_decode_set_option_buildindex();
    if (v3)
    {
      AppleJPEGReadPlugin::appleJPEGErrorString(v3, (int)v3);
      return _cg_jpeg_mem_term("create_or_restoreIndexTable", 255, "    applejpeg_decode_set_option_buildindex err = %d '%s'\n");
    }
  }
  return result;
}

void AppleJPEGReadPlugin::readQualityPropertiesFromJPEG(uint64_t a1, uint64_t a2, IIODictionary *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 4, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      uint64_t v4 = Mutable;
      CFIndex v5 = 0;
      long long v6 = (const void *)*MEMORY[0x1E4F1D260];
      do
        CFArraySetValueAtIndex(v4, v5++, v6);
      while (v5 != 4);
      memset(v23, 0, 64);
      memset(v22, 0, sizeof(v22));
      memset(v21, 0, sizeof(v21));
      memset(v20, 0, sizeof(v20));
      float v16 = v20;
      uint64_t v17 = v21;
      BOOL v18 = v22;
      uint64_t v19 = v23;
      int v13 = 0;
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      if (!applejpeg_decode_get_qtables()) {
        IIODictionary::setObjectForKeyGroup(a3, v4, @"Quantization", @"{JPEG}");
      }
      CFRelease(v4);
    }
    signed int chroma_subsampling = applejpeg_decode_get_chroma_subsampling();
    *(unsigned char *)(a1 + 676) = chroma_subsampling;
    if (chroma_subsampling <= 3)
    {
      int v8 = dword_1889ABED0[chroma_subsampling];
      IIONumber::IIONumber((IIONumber *)v12, dword_1889ABEC0[chroma_subsampling]);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v12, @"ChromaSubsamplingX", @"{JPEG}");
      IIONumber::~IIONumber((IIONumber *)v12);
      IIONumber::IIONumber((IIONumber *)v11, v8);
      IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v11, @"ChromaSubsamplingY", @"{JPEG}");
      IIONumber::~IIONumber((IIONumber *)v11);
    }
  }
}

void sub_1887A9558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t AppleJPEGReadPlugin::containsGainMap(AppleJPEGReadPlugin *this)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (*((int *)this + 148) >= 1)
  {
    int v2 = 0;
    do
    {
      applejpeg_decode_get_segment_info();
      ++v2;
    }
    while (v2 < *((_DWORD *)this + 148));
  }
  return 0;
}

uint64_t AppleJPEGReadPlugin::copyImageBlockSetSingleTile(uint64_t a1, const void *a2, const void *a3, double a4, double a5, double a6, double a7, double a8, double a9, uint64_t a10, _DWORD *a11)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  memory_object_size_t v42 = 0;
  *a11 = 0;
  if (a3)
  {
    PixelCFStringRef Size = CGImageProviderGetPixelSize();
  }
  else
  {
    PixelCFStringRef Size = *(unsigned __int16 *)(a1 + 308);
    if (PixelSize == 3)
    {
      if (*(unsigned char *)(a1 + 310)) {
        PixelCFStringRef Size = 4;
      }
      else {
        PixelCFStringRef Size = 3;
      }
    }
  }
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    %s:%d: Entering\n", "copyImageBlockSetSingleTile", 2274);
  }
  *(_DWORD *)(a1 + 292) = a6;
  *(_DWORD *)(a1 + 296) = a7;
  *(_DWORD *)(a1 + 300) = (unint64_t)(a6 * (double)PixelSize);
  *(_DWORD *)(a1 + 104) = 1;
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, a4, a5, a6, a7, a8, a9);
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
  applejpeg_decode_clear_options();
  int v22 = applejpeg_decode_set_option_outformat();
  if (v22) {
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2317, "err = %d\n", v22);
  }
  int v23 = applejpeg_decode_set_option_outsize();
  if (v23) {
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2330, "err = %d\n", v23);
  }
  uint64_t v43 = *(unsigned int *)(a1 + 300);
  uint64_t v44 = v43;
  uint64_t v45 = v43;
  uint64_t v46 = v43;
  int v24 = applejpeg_decode_set_option_stride();
  if (v24) {
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2338, "err = %d\n", v24);
  }
  if (*(unsigned char *)(a1 + 341)) {
    AppleJPEGReadPlugin::create_or_restoreIndexTable(a1);
  }
  int v25 = applejpeg_decode_set_option_mosquito_spray();
  if (v25) {
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2370, "applejpeg_decode_set_option_mosquito_spray err = %d\n", v25);
  }
  int v26 = applejpeg_decode_set_option_multithread();
  if (v26) {
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2377, "applejpeg_decode_set_option_multithread err = %d\n", v26);
  }
  int v27 = applejpeg_decode_set_option_crop();
  if (v27) {
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2409, "err = %d\n", v27);
  }
  applejpeg_decode_set_option_error_fill();
  output_dimensions = (AppleJPEGReadPlugin *)applejpeg_decode_get_output_dimensions();
  if (output_dimensions)
  {
    int v29 = (int)output_dimensions;
    int v30 = AppleJPEGReadPlugin::appleJPEGErrorString(output_dimensions, (int)output_dimensions);
    _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2422, "*** ERROR: applejpeg_decode_get_output_dimensions - error %d (%s)\n", v29, v30);
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    %s:%d: Options error %d\n", "copyImageBlockSetSingleTile", 2423, v29);
    }
    int v31 = 0;
  }
  else
  {
    applejpeg_decode_get_output_buffer_size();
    if (*(_DWORD *)(a1 + 300)) {
      _cg_jpeg_mem_term("copyImageBlockSetSingleTile", 2432, "*** ERROR: get_output_buffer_size rb=%d  blockGeo.rb=%d\n", 0, *(_DWORD *)(a1 + 300));
    }
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    %s:%d: applejpeg_decode_get_output_buffer_size:%ld rowB:%ld size:%ldx%ld\n", "copyImageBlockSetSingleTile", 2434, 0, 0, 0, 0);
    }
    int v31 = (void *)_ImageIO_Malloc(0, *(void *)(a1 + 384), &v42, (uint64_t)kImageMalloc_APPLEJPEG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
    if (v31)
    {
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("    %s:%d: Got outbuf\n", "copyImageBlockSetSingleTile", 2444);
      }
      int v33 = applejpeg_decode_image_all();
      if (!v33) {
        goto LABEL_60;
      }
      int v34 = v33;
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("    %s:%d: Decode error %d\n", "copyImageBlockSetSingleTile", 2451, v33);
      }
      if (v34 == 9 || v34 == -1)
      {
LABEL_60:
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("    %s:%d: Decoded image\n", "copyImageBlockSetSingleTile", 2458);
        }
        v48.origin.CGFloat x = a4;
        v48.origin.CGFloat y = a5;
        v48.size.unint64_t width = a6;
        v48.size.double height = a7;
        **(void **)(a1 + 96) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v31, v42, v48, *(unsigned int *)(a1 + 300), 0);
        BOOL v35 = CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E4F1DB20]);
        double v36 = a6;
        double v37 = a7;
        if (!v35)
        {
          v49.origin.CGFloat x = a4;
          v49.origin.CGFloat y = a5;
          v49.size.unint64_t width = a6;
          v49.size.double height = a7;
          *(CGRect *)(&v36 - 2) = CGRectUnion(*(CGRect *)(a1 + 120), v49);
          a4 = v38;
          a5 = v39;
        }
        *(double *)(a1 + 120) = a4;
        *(double *)(a1 + 128) = a5;
        *(double *)(a1 + 136) = v36;
        *(double *)(a1 + 144) = v37;
        if (*(unsigned char *)(a1 + 341)) {
          AppleJPEGReadPlugin::save_index_table((AppleJPEGReadPlugin *)a1);
        }
        int v31 = 0;
        if (a3)
        {
          unint64_t v40 = *(unsigned int *)(a1 + 104);
          if (v40)
          {
            uint64_t v32 = IIOReadPlugin::imageBlockSetCreate(a1, (uint64_t)a3, v40, a6, a7, *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(void *)(a1 + 96), a2);
            int v31 = 0;
LABEL_29:
            IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
            if (!v31) {
              return v32;
            }
            goto LABEL_54;
          }
        }
      }
    }
  }
  if (a3)
  {
    uint64_t v32 = 0;
    goto LABEL_29;
  }
  if (!*(_DWORD *)(a1 + 104))
  {
    uint64_t v32 = 0;
    if (!v31) {
      return v32;
    }
    goto LABEL_54;
  }
  uint64_t v32 = 0;
  *a11 = 1;
  if (v31) {
LABEL_54:
  }
    _ImageIO_Free((unint64_t)v31, v42);
  return v32;
}

uint64_t AppleJPEGReadPlugin::copyImageBlockSetTiles(uint64_t a1, const void *a2, const void *a3, unint64_t a4, _DWORD *a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  long long v11 = a3;
  double v17 = a6;
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  memory_object_size_t v77 = 0;
  *a5 = 0;
  if (a3)
  {
    CGImageProviderGetSize();
    double v21 = v20;
    double v23 = v22;
    PixelCFStringRef Size = CGImageProviderGetPixelSize();
  }
  else
  {
    LODWORD(a6) = *(_DWORD *)(a1 + 292);
    double v21 = (double)*(unint64_t *)&a6;
    LODWORD(a6) = *(_DWORD *)(a1 + 296);
    double v23 = (double)*(unint64_t *)&a6;
    PixelCFStringRef Size = *(unsigned __int16 *)(a1 + 308);
    if (PixelSize == 3)
    {
      if (*(unsigned char *)(a1 + 310)) {
        PixelCFStringRef Size = 4;
      }
      else {
        PixelCFStringRef Size = 3;
      }
    }
  }
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    %s:%d: Entering\n", "copyImageBlockSetTiles", 2538);
  }
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, v11, v17, a7, a8, a9, a10, a11);
  unint64_t v25 = (unint64_t)(v17 / (double)a4);
  double v26 = (double)(a4 - 1);
  unint64_t v27 = (unint64_t)((v17 + a8 + v26) / (double)a4);
  unint64_t v28 = (unint64_t)(a7 / (double)a4);
  unint64_t v74 = (unint64_t)((a7 + a9 + v26) / (double)a4);
  *(_DWORD *)(a1 + 236) = 16 * (unint64_t)((a8 * (double)PixelSize + 15.0) * 0.0625);
  uint64_t v29 = *(void *)(a1 + 228);
  v30.i64[0] = v29;
  v30.i64[1] = HIDWORD(v29);
  int8x16_t v31 = (int8x16_t)vdupq_n_s64(a4);
  int64x2_t v32 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v31, v30), (int8x16_t)v30, v31);
  *(int32x2_t *)(a1 + 292) = vmovn_s64(v32);
  *(_DWORD *)(a1 + 300) = v32.i32[0] * PixelSize;
  unint64_t v71 = v27 - v25;
  size_t v33 = ((v27 - v25) * (v74 - v28));
  *(_DWORD *)(a1 + 104) = v33;
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, v33);
  applejpeg_decode_clear_options();
  int v34 = applejpeg_decode_set_option_outformat();
  if (v34) {
    _cg_jpeg_mem_term("copyImageBlockSetTiles", 2588, "err = %d\n", v34);
  }
  if (*(unsigned __int16 *)(a1 + 316) <= 1u) {
    unsigned int v35 = 1;
  }
  else {
    unsigned int v35 = *(unsigned __int16 *)(a1 + 316);
  }
  int v36 = applejpeg_decode_set_option_outsize();
  if (v36) {
    _cg_jpeg_mem_term("copyImageBlockSetTiles", 2601, "err = %d\n", v36);
  }
  uint64_t v78 = *(unsigned int *)(a1 + 300);
  uint64_t v79 = v78;
  uint64_t v80 = v78;
  uint64_t v81 = v78;
  int v37 = applejpeg_decode_set_option_stride();
  if (v37) {
    _cg_jpeg_mem_term("copyImageBlockSetTiles", 2609, "err = %d\n", v37);
  }
  if (*(unsigned char *)(a1 + 341)) {
    AppleJPEGReadPlugin::create_or_restoreIndexTable(a1);
  }
  if (*(char *)(a1 + 677) != -1) {
    applejpeg_decode_set_option_force_app14();
  }
  applejpeg_decode_set_option_error_fill();
  int v38 = applejpeg_decode_set_option_mosquito_spray();
  if (v38) {
    _cg_jpeg_mem_term("copyImageBlockSetTiles", 2657, "applejpeg_decode_set_option_mosquito_spray err = %d\n", v38);
  }
  int v39 = applejpeg_decode_set_option_multithread();
  if (v39) {
    _cg_jpeg_mem_term("copyImageBlockSetTiles", 2664, "err = %d\n", v39);
  }
  if (v74 > v28)
  {
    unint64_t v40 = (unint64_t)(a7 / (double)a4);
    uint64_t v75 = 0;
    uint64_t v72 = 0;
    if (v25 <= v27) {
      unint64_t v41 = v27;
    }
    else {
      unint64_t v41 = (unint64_t)(v17 / (double)a4);
    }
    double v42 = (double)v35;
    uint64_t v43 = 8 * v41 - 8 * v25;
    unint64_t v44 = v25 * a4;
    uint64_t v45 = (CGRect *)MEMORY[0x1E4F1DB20];
    vImagePixelCount v70 = v11;
    unint64_t v67 = (unint64_t)(v17 / (double)a4);
    unint64_t v68 = a2;
    uint64_t v65 = v43;
    unint64_t v66 = v27;
    unint64_t v64 = v25 * a4;
    while (1)
    {
      uint64_t v46 = *(unsigned int *)(a1 + 296);
      unint64_t v73 = v40;
      unint64_t v47 = v40 * v46;
      double v48 = (double)v47;
      double v49 = (double)v46 + (double)v47 <= v23 ? (double)v46 : v23 - (double)v47;
      if (v27 > v25) {
        break;
      }
LABEL_63:
      unint64_t v40 = v73 + 1;
      v75 += v43;
      if (v73 + 1 == v74) {
        goto LABEL_64;
      }
    }
    double v50 = v49 * v42;
    unint64_t v51 = v71;
    v72 += v71;
    uint64_t v52 = v75;
    while (1)
    {
      double v53 = (double)v44;
      LODWORD(v50) = *(_DWORD *)(a1 + 292);
      double v54 = (double)*(unint64_t *)&v50;
      if ((double)v44 + v54 <= v21) {
        double v55 = v54;
      }
      else {
        double v55 = v21 - (double)v44;
      }
      if (!*(_WORD *)(a1 + 316) && v39) {
        _cg_jpeg_mem_term("copyImageBlockSetTiles", 2708, "err = %d\n", v39);
      }
      int v56 = applejpeg_decode_set_option_crop();
      if (v56) {
        _cg_jpeg_mem_term("copyImageBlockSetTiles", 2712, "err = %d\n", v56);
      }
      applejpeg_decode_get_output_buffer_size();
      if (*(_DWORD *)(a1 + 300)) {
        _cg_jpeg_mem_term("copyImageBlockSetTiles", 2719, "*** ERROR: get_output_buffer_size rb=%d  blockGeo.rb=%d\n", 0, *(_DWORD *)(a1 + 300));
      }
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("    %s:%d: applejpeg_decode_get_output_buffer_size:%ld rowB:%ld size:%ldx%ld\n", "copyImageBlockSetTiles", 2721, 0, 0, *(unsigned int *)(a1 + 292), *(unsigned int *)(a1 + 296));
      }
      uint64_t v57 = (void *)_ImageIO_Malloc(0, *(void *)(a1 + 384), &v77, (uint64_t)kImageMalloc_APPLEJPEG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
      if (!v57) {
        break;
      }
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("    %s:%d: Got outbuf\n", "copyImageBlockSetTiles", 2732);
      }
      int v58 = applejpeg_decode_image_all();
      int v39 = v58;
      if (v58)
      {
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("    %s:%d: Decode error %d\n", "copyImageBlockSetTiles", 2739, v58);
        }
        if (v39 != 9 && v39 != -1) {
          break;
        }
      }
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("    %s:%d: Decoded image\n", "copyImageBlockSetTiles", 2746);
      }
      v83.origin.CGFloat x = (double)v44;
      v83.origin.CGFloat y = v48;
      v83.size.unint64_t width = v55;
      v83.size.double height = v49;
      *(void *)(*(void *)(a1 + 96) + v52) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v57, v77, v83, *(unsigned int *)(a1 + 300), 0);
      if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *v45))
      {
        double v59 = v48;
        double v60 = v49;
      }
      else
      {
        v84.origin.CGFloat x = (double)v44;
        v84.origin.CGFloat y = v48;
        v84.size.unint64_t width = v55;
        v84.size.double height = v49;
        *(CGRect *)&double v50 = CGRectUnion(*(CGRect *)(a1 + 120), v84);
        double v53 = v50;
        double v55 = v61;
      }
      *(double *)(a1 + 120) = v53;
      *(double *)(a1 + 128) = v59;
      v52 += 8;
      v44 += a4;
      *(double *)(a1 + 136) = v55;
      *(double *)(a1 + 144) = v60;
      if (!--v51)
      {
        long long v11 = v70;
        unint64_t v25 = v67;
        a2 = v68;
        uint64_t v43 = v65;
        unint64_t v27 = v66;
        unint64_t v44 = v64;
        goto LABEL_63;
      }
    }
    uint64_t v62 = 0;
    if (!v70) {
      goto LABEL_69;
    }
LABEL_67:
    IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
    goto LABEL_71;
  }
LABEL_64:
  if (*(unsigned char *)(a1 + 341)) {
    AppleJPEGReadPlugin::save_index_table((AppleJPEGReadPlugin *)a1);
  }
  uint64_t v62 = IIOReadPlugin::imageBlockSetCreate(a1, (uint64_t)v11, *(unsigned int *)(a1 + 104), v21, v23, *(double *)(a1 + 120), *(double *)(a1 + 128), *(double *)(a1 + 136), *(double *)(a1 + 144), *(void *)(a1 + 96), a2);
  uint64_t v57 = 0;
  if (v11) {
    goto LABEL_67;
  }
LABEL_69:
  if (*(_DWORD *)(a1 + 104)) {
    *a5 = 1;
  }
LABEL_71:
  if (v57) {
    _ImageIO_Free((unint64_t)v57, v77);
  }
  return v62;
}

uint64_t AppleJPEGReadPlugin::decodeIntoIOSurface(AppleJPEGReadPlugin *this, IIODecodeParameter *a2, __IOSurface *a3)
{
  memset(v5, 0, sizeof(v5));
  CFDictionaryRef XmpData = (const __CFDictionary *)_APP1XMP::getXmpData(a2);
  IIODictionary::IIODictionary((IIODictionary *)v5, XmpData);
  IIODictionary::~IIODictionary((IIODictionary *)v5);
  return 4294967246;
}

uint64_t ___ZN19AppleJPEGReadPlugin20copyImageBlockSetImpEP7InfoRecP15CGImageProvider6CGRect6CGSizePK14__CFDictionary_block_invoke()
{
  return IOPreferencesGetBoolean("ImageIO_Tint_AppleJPEG", 0, 0);
}

CFDataRef AppleJPEGReadPlugin::CreateJPEGDataFromImage(AppleJPEGReadPlugin *this, IIOImagePixelDataProvider *a2, CGImageRef image, CGImage *a4)
{
  uint64_t v40 = qword_1ED4F0BE0;
  long long v38 = 0u;
  long long v39 = xmmword_1ED4F0BD0;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  uint64_t v31 = 0;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v24 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  uint64_t v20 = 0;
  CFIndex v21 = 0;
  bytes = 0;
  if (this) {
    SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(this);
  }
  else {
    SourceGeomColorSpace = CGImageGetColorSpace(image);
  }
  CGColorSpaceModel Model = CGColorSpaceGetModel(SourceGeomColorSpace);
  unsigned int Width = CGImageGetWidth(image);
  size_t Height = CGImageGetHeight(image);
  *(_OWORD *)double v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t v14 = 0x1800000008;
  MEMORY[0x18C11D770](v17, &v14, 0, image, 0);
  if (!applejpeg_encode_create()) {
    goto LABEL_24;
  }
  applejpeg_encode_options_init();
  *(void *)&long long v32 = 1;
  LODWORD(v33) = 80;
  DWORD2(v35) = 3;
  *((void *)&v24 + 1) = __PAIR64__(Height, Width);
  if (Model <= kCGColorSpaceModelCMYK) {
    LODWORD(v25) = dword_1889ABEB0[Model];
  }
  LODWORD(v24) = 1;
  bytes = (UInt8 *)malloc_type_malloc(0x2800uLL, 0x61ECDA44uLL);
  uint64_t v20 = 10240;
  if (applejpeg_encode_set_options_mem())
  {
LABEL_24:
    CFDataRef v12 = 0;
    goto LABEL_15;
  }
  HIDWORD(v24) = 1;
  if (Height)
  {
    uint64_t v9 = 0;
    while (1)
    {
      *(void *)&long long v22 = (char *)v17[0] + *((void *)&v18 + 1) * v9;
      int v10 = applejpeg_encode_image_row();
      if (v10) {
        break;
      }
      if (Height == ++v9)
      {
        CFIndex v11 = v21;
        goto LABEL_14;
      }
    }
    _cg_jpeg_mem_term("CreateJPEGDataFromImage", 3489, "applejpeg_encode_image_row: %d\n", v10);
    goto LABEL_24;
  }
  CFIndex v11 = 0;
LABEL_14:
  CFDataRef v12 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, v11);
LABEL_15:
  applejpeg_encode_destroy();
  if (v17[0]) {
    free(v17[0]);
  }
  if (bytes) {
    free(bytes);
  }
  if ((gIIODebugFlags & 0x800000000000) != 0 && !v12) {
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CreateJPEGDataFromImage", 3513, "could not create JPEG data");
  }
  return v12;
}

uint64_t AppleJPEGReadPlugin::copyIOSurfaceSet(unsigned char *a1)
{
  uint64_t v2 = (*(uint64_t (**)(unsigned char *))(*(void *)a1 + 232))(a1);
  if (v2)
  {
    uint64_t v3 = (void *)v2;
    CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D510]);
    CFArrayAppendValue(Mutable, v3);
    uint64_t v5 = CGImageIOSurfaceSetCreate();
    IIO_IOSurfaceRelease((__IOSurface *)v3);
  }
  else
  {
    uint64_t v5 = 0;
    a1[680] = 1;
    a1[496] = 0;
  }
  return v5;
}

__n128 ___ZN19AppleJPEGReadPlugin29createImageBlockFromIOSurfaceEP11__IOSurfaceP7InfoRecP15CGImageProvider_block_invoke()
{
  vImage_YpCbCrPixelRange pixelRange = *(vImage_YpCbCrPixelRange *)ymmword_1889ABE50;
  *(_OWORD *)&matrix.Yp = xmmword_1889ABE70;
  matrix.Cb_B = 1.772;
  vImage_Error v0 = vImageConvert_YpCbCrToARGB_GenerateConversion(&matrix, &pixelRange, &AppleJPEGReadPlugin::createImageBlockFromIOSurface(__IOSurface *,InfoRec *,CGImageProvider *)::conversion, kvImage422YpCbYpCr8, kvImageARGB8888, 0);
  if (v0)
  {
    vImage_Error v2 = v0;
    uint64_t v3 = IIO_vImageErrorString(v0);
    return _cg_jpeg_mem_term("createImageBlockFromIOSurface_block_invoke", 4007, "*** ERROR: vImageConvert_YpCbCrToARGB_GenerateConversion returned %ld (%s)\n", v2, v3);
  }
  return result;
}

void ICNSWritePlugin::~ICNSWritePlugin(ICNSWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t ICNSWritePlugin::writeOneImage(ICNSWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t ICNSWritePlugin::writeOneICNS(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, _DWORD *a6)
{
  int AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(*(IIOImagePixelDataProvider **)a2);
  uint64_t v10 = *(unsigned __int16 *)(a2 + 50);
  unsigned int v11 = *(_DWORD *)(a2 + 56);
  unsigned int v12 = *(unsigned __int8 *)(a2 + 75);
  int v63 = AlphaInfo;
  uint64_t v13 = 3;
  if (AlphaInfo) {
    uint64_t v13 = 4;
  }
  size_t size = *(unsigned __int16 *)(a2 + 48);
  unint64_t v14 = v13 * size;
  unint64_t v15 = IIOImagePlus::sourceImageProvider(*(IIOImagePlus **)a2);
  if (v15 < v14) {
    return 4294967246;
  }
  size_t v16 = v15;
  IIOImagePixelDataProvider::rewind(*(IIOImagePixelDataProvider **)a2);
  if (v12 >= 2)
  {
    if (CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0)) {
      operator new();
    }
    return 0;
  }
  unint64_t v68 = (char *)malloc_type_calloc(v16, size, 0x7D71798EuLL);
  if (!v68) {
    return 4294967246;
  }
  if (v16 == v14)
  {
    if (IIOImagePixelDataProvider::getBytes(*(uint64_t (***)(IIOImagePixelDataProvider *, void *))a2, v68) != v14 * v10) {
      goto LABEL_10;
    }
  }
  else if (v10)
  {
    long long v18 = v68;
    while (IIOImagePixelDataProvider::getBytes(*(uint64_t (***)(IIOImagePixelDataProvider *, void *))a2, v18) == v16)
    {
      v18 += v14;
      if (!--v10) {
        goto LABEL_15;
      }
    }
LABEL_10:
    uint64_t v17 = 4294967246;
    goto LABEL_61;
  }
LABEL_15:
  size_t v19 = v14 * size;
  unsigned int v20 = bswap32(v11);
  uint64_t v61 = a3;
  uint64_t v62 = a5;
  *(_DWORD *)(a3 + *a5) = v20;
  *a5 += 4;
  CFIndex v21 = a6;
  a6[2 * *a6 + 1] = v20;
  unsigned int appleflags = _cg_png_get_appleflags(*(void *)a2);
  unsigned int Error = _cg_GifLastError(*(void *)a2);
  unint64_t v71 = malloc_type_calloc(v19 + (v19 >> 2), 1uLL, 0x588743D7uLL);
  if (!v71) {
    goto LABEL_52;
  }
  long long v24 = (unsigned __int8 *)malloc_type_calloc(0x8CuLL, 1uLL, 0x14355503uLL);
  if (!v24) {
    goto LABEL_51;
  }
  long long v25 = v24;
  uint64_t v26 = 0;
  int v27 = appleflags / Error;
  unint64_t v28 = v19 / (int)(appleflags / Error);
  unsigned int v29 = 4 * (size == 128);
  long long v30 = v24 + 2;
  uint64_t v66 = v28 - 1;
  uint64_t v67 = v28 & 0xFFFFFFFE;
  vImagePixelCount v70 = (char *)(v24 + 2);
  do
  {
    uint64_t v31 = &v68[v26];
    *long long v25 = v68[v26];
    if (!v67)
    {
      unsigned __int8 v35 = 1;
      goto LABEL_48;
    }
    uint64_t v69 = v26;
    int v32 = 0;
    int v33 = 1;
    uint64_t v34 = v66;
    unsigned __int8 v35 = 1;
    do
    {
      int v36 = v31[v27 * v33];
      size_t v37 = v35;
      uint64_t v38 = v35 - 1;
      if (v35 <= 1u) {
        goto LABEL_21;
      }
      uint64_t v40 = v35 - 2;
      if (v37 == 2)
      {
        if (v36 == v25[1] && v36 == *v25) {
          goto LABEL_31;
        }
        int v32 = 0;
        unsigned __int8 v35 = 3;
        goto LABEL_32;
      }
      if ((v37 & 0x80) == 0 && !v32)
      {
        if (v36 != v25[v38] || v36 != v25[v40])
        {
          int v32 = 0;
LABEL_21:
          unsigned __int8 v35 = v37 + 1;
          long long v39 = &v25[v37];
          goto LABEL_43;
        }
        v71[v29] = v37 - 3;
        uint64_t v41 = v29 + 1;
        memcpy(&v71[v41], v25, (v37 - 2));
        long long v30 = (unsigned __int8 *)v70;
        unsigned int v29 = v41 + v40;
        *long long v25 = v25[v40];
        v25[1] = v25[v38];
LABEL_31:
        unsigned __int8 v35 = 3;
        int v32 = 1;
LABEL_32:
        long long v39 = v30;
        goto LABEL_43;
      }
      if (v37 <= 0x81 && v32 == 1)
      {
        if (v36 == v25[v38] && v36 == v25[v40])
        {
          unsigned __int8 v35 = v37 + 1;
          long long v39 = &v25[v37];
          int v32 = 1;
          goto LABEL_43;
        }
LABEL_41:
        int v32 = 0;
        v71[v29] = v37 + 125;
        v71[v29 + 1] = *v25;
        v29 += 2;
        goto LABEL_42;
      }
      if (v32) {
        goto LABEL_41;
      }
      v71[v29] = v37 - 1;
      uint64_t v42 = v29 + 1;
      memcpy(&v71[v42], v25, v37);
      long long v30 = (unsigned __int8 *)v70;
      int v32 = 0;
      unsigned int v29 = v42 + v37;
LABEL_42:
      unsigned __int8 v35 = 1;
      long long v39 = v25;
LABEL_43:
      unsigned __int8 *v39 = v36;
      ++v33;
      --v34;
    }
    while (v34);
    if (v32)
    {
      v71[v29] = v35 + 125;
      v71[v29 + 1] = *v25;
      v29 += 2;
      uint64_t v26 = v69;
      goto LABEL_49;
    }
    uint64_t v26 = v69;
LABEL_48:
    v71[v29] = v35 - 1;
    uint64_t v43 = v29 + 1;
    memcpy(&v71[v43], v25, v35);
    unsigned int v29 = v43 + v35;
    long long v30 = (unsigned __int8 *)v70;
LABEL_49:
    ++v26;
  }
  while (v26 != 3);
  unsigned int v44 = bswap32(v29 + 8);
  uint64_t v45 = *v62;
  *(_DWORD *)(v61 + v45) = v44;
  v45 += 4;
  *uint64_t v62 = v45;
  uint64_t v46 = *a6;
  a6[2 * v46 + 2] = v44;
  *a6 = v46 + 1;
  memcpy((void *)(v61 + v45), v71, v29);
  *v62 += v29;
  CFIndex v21 = a6;
  free(v25);
LABEL_51:
  free(v71);
LABEL_52:
  HIDWORD(v48) = size;
  LODWORD(v48) = size - 16;
  signed int v47 = v48 >> 4;
  if (v47 > 2)
  {
    unsigned int v50 = 1949855083;
    LODWORD(v49) = 0x4000;
  }
  else
  {
    LODWORD(v49) = dword_1889ABEF4[v47];
    unsigned int v50 = dword_1889ABF00[v47];
  }
  unsigned int v51 = bswap32(v50);
  *(_DWORD *)(v61 + *v62) = v51;
  uint64_t v52 = *v62 + 4;
  *uint64_t v62 = v52;
  v21[2 * *v21 + 1] = v51;
  unsigned int v53 = bswap32(v49 | 8);
  *(_DWORD *)(v61 + v52) = v53;
  uint64_t v54 = *v62 + 4;
  *uint64_t v62 = v54;
  uint64_t v55 = *v21;
  v21[2 * v55 + 2] = v53;
  *CFIndex v21 = v55 + 1;
  if ((v63 - 1) > 3)
  {
    uint64_t v58 = v49;
    memset((void *)(v61 + v54), 255, v49);
  }
  else
  {
    int v56 = v68 + 3;
    uint64_t v57 = (unsigned char *)(v61 + v54);
    uint64_t v58 = v49;
    uint64_t v49 = v49;
    do
    {
      char v59 = *v56;
      v56 += 4;
      *v57++ = v59;
      --v49;
    }
    while (v49);
  }
  uint64_t v17 = 0;
  *v62 += v58;
LABEL_61:
  free(v68);
  return v17;
}

void sub_1887AB08C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C408329B462);
  _Unwind_Resume(a1);
}

uint64_t ICNSWritePlugin::writeAll(IIOImageDestination **this)
{
  *(void *)&v42[1461] = *MEMORY[0x1E4F143B8];
  bzero(v41, 0x600uLL);
  unsigned int ImageCount = IIOWritePlugin::getImageCount(this);
  if (ImageCount >= 0x10) {
    uint64_t v3 = 16;
  }
  else {
    uint64_t v3 = ImageCount;
  }
  uint64_t v38 = v3;
  if (!v3) {
    goto LABEL_35;
  }
  unint64_t v37 = 0;
  uint64_t v4 = 0;
  unint64_t v5 = 0;
  unsigned int v6 = 72;
  unsigned int Uint32ForKey = 72;
  do
  {
    PixelDataProviderAtIndeCGFloat x = (IIOImageSource *)IIOWritePlugin::getPixelDataProviderAtIndex((CFArrayRef **)this, v5);
    PropertiesAtIndeCGFloat x = (IIODictionary *)IIOWritePlugin::getPropertiesAtIndex(this, v5);
    uint64_t v10 = (IIOImageSource **)&v41[96 * v4];
    *uint64_t v10 = PixelDataProviderAtIndex;
    v10[2] = PropertiesAtIndex;
    int v11 = IIOImageSource::count(PixelDataProviderAtIndex);
    int v12 = IIO_Reader::testHeaderSize(PixelDataProviderAtIndex);
    if (IIODictionary::containsKey(PropertiesAtIndex, @"DPIWidth")) {
      unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(PropertiesAtIndex, @"DPIWidth");
    }
    if (IIODictionary::containsKey(PropertiesAtIndex, @"DPIHeight")) {
      unsigned int v6 = IIODictionary::getUint32ForKey(PropertiesAtIndex, @"DPIHeight");
    }
    if (Uint32ForKey != v6)
    {
      unsigned int Uint32ForKey = 72;
      unsigned int v6 = 72;
    }
    if (Uint32ForKey == 144) {
      int v13 = 2;
    }
    else {
      int v13 = 1;
    }
    ICNSInfoTable = (unsigned __int16 *)GetICNSInfoTable();
    int v15 = *ICNSInfoTable;
    if (v15 == 0xFFFF)
    {
LABEL_23:
      LogError("writeAll", 576, "unsupported ICNS image size (%d x %d) - scaling factor: %d  dpi: %d x %d\n", v11, v12, v13, Uint32ForKey, v6);
    }
    else
    {
      size_t v16 = ICNSInfoTable + 28;
      while ((v15 & 0x8000) != 0
           || *(v16 - 16) != v11
           || *(v16 - 15) != v12
           || v13 != *((unsigned __int8 *)v16 - 7)
           || *((unsigned char *)v16 - 4) != 1)
      {
        int v17 = *v16;
        v16 += 28;
        LOWORD(v15) = v17;
        if (v17 == 0xFFFF) {
          goto LABEL_23;
        }
      }
      long long v18 = &v41[96 * v4];
      *(_OWORD *)(v18 + 24) = *(_OWORD *)(v16 - 28);
      *(_OWORD *)(v18 + 40) = *(_OWORD *)(v16 - 20);
      *(_OWORD *)(v18 + 56) = *(_OWORD *)(v16 - 12);
      *((void *)v18 + 9) = *((void *)v16 - 1);
      ++v4;
      v37 += (4 * v11 * v12);
    }
    ++v5;
  }
  while (v5 != v38);
  if (v4)
  {
    size_t v19 = v42;
    uint64_t v20 = v4;
    uint64_t v21 = v4;
    do
    {
      unsigned int v22 = *v19;
      v19 += 96;
      if (v22 < 2) {
        ++v21;
      }
      --v20;
    }
    while (v20);
    uint64_t v23 = (8 * v21 + 8);
    long long v24 = malloc_type_calloc((v37 >> 2) + v37 + v23, 1uLL, 0x4E74ADE9uLL);
    *long long v24 = 1936614249;
    v24[2] = 541282132;
    void v24[3] = bswap32(v23);
    size_t __nitems = v23 + 8;
    uint64_t v26 = malloc_type_calloc((8 * v21) | 4, 1uLL, 0x46F1E9CDuLL);
    int v27 = (long long *)v41;
    do
    {
      long long v28 = v27[3];
      v39[2] = v27[2];
      v39[3] = v28;
      long long v29 = v27[5];
      v39[4] = v27[4];
      v39[5] = v29;
      long long v30 = *v27;
      long long v31 = v27[1];
      v27 += 6;
      v39[0] = v30;
      v39[1] = v31;
      ICNSWritePlugin::writeOneICNS((uint64_t)this, (uint64_t)v39, (uint64_t)v24, v25, (uint64_t *)&__nitems, v26);
      --v4;
    }
    while (v4);
    memcpy(v24 + 4, v26 + 1, (8 * *v26));
    free(v26);
    size_t v32 = __nitems;
    v24[1] = bswap32(__nitems);
    IIOImageWriteSession::putBytes(this[2], v24, v32);
    uint64_t v33 = 0;
  }
  else
  {
LABEL_35:
    long long v24 = 0;
    uint64_t v33 = 4294967246;
  }
  for (uint64_t i = 88; i != 1624; i += 96)
  {
    unsigned __int8 v35 = *(void **)&v41[i];
    if (v35) {
      free(v35);
    }
  }
  if (v24) {
    free(v24);
  }
  return v33;
}

uint64_t ICNSWritePlugin::WriteProc(ICNSWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v9, this, a2, 1229147731);
  *(void *)&v9[0] = &unk_1ED4E3268;
  uint64_t v5 = ICNSWritePlugin::writeAll((IIOImageDestination **)v9);
  _cg_jpeg_mem_term(v9, v6, v7);
  return v5;
}

void sub_1887AB4C0(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t ICNSWritePlugin::writeOne(ICNSWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967292;
}

uint64_t TIFFInitThunderScan(void *a1)
{
  a1[120] = ThunderSetupDecode;
  a1[126] = ThunderDecodeRow;
  a1[128] = ThunderDecodeRow;
  return 1;
}

uint64_t ThunderSetupDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a1 + 116) == 4) {
    return 1;
  }
  TIFFErrorExtR(a1, "ThunderSetupDecode", "Wrong bitspersample value (%d), Thunder decoder only supports 4bits per sample.", a4, a5, a6, a7, a8, *(_WORD *)(a1 + 116));
  return 0;
}

uint64_t ThunderDecodeRow(void *a1, char *__b, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = (uint64_t)a1;
  if (a3 % a1[138])
  {
    TIFFErrorExtR((uint64_t)a1, "ThunderDecodeRow", "Fractional scanlines cannot be read", a4, a5, a6, a7, a8, v48);
    return 0;
  }
  if (a3 >= 1)
  {
    uint64_t v10 = (unsigned __int8 *)a1[144];
    uint64_t v11 = a1[145];
    while (1)
    {
      uint64_t v12 = *(unsigned int *)(v8 + 88);
      BOOL v13 = *(_DWORD *)(v8 + 88) != 0;
      uint64_t v14 = 0;
      BOOL v15 = !v12 || v11 < 1;
      if (v15)
      {
        long long v18 = (unsigned __int8 *)__b;
      }
      else
      {
        int v17 = 0;
        long long v18 = (unsigned __int8 *)__b;
        unint64_t v19 = v11;
        uint64_t v50 = a3;
        unsigned int v51 = __b;
        do
        {
          unsigned int v21 = *v10++;
          unint64_t v20 = v21;
          switch(v21 >> 6)
          {
            case 1u:
              uint64_t v22 = (v20 >> 4) & 3;
              if (v22 != 2)
              {
                int v23 = twobitdeltas[v22] + v17;
                int v17 = v23 & 0xF;
                if (v14)
                {
                  uint64_t v25 = v18 + 1;
                  unsigned __int8 v24 = *v18 | v17;
                }
                else
                {
                  unsigned __int8 v24 = 16 * v23;
                  uint64_t v25 = v18;
                }
                ++v14;
                *long long v18 = v24;
                long long v18 = v25;
              }
              uint64_t v36 = (v20 >> 2) & 3;
              if (v36 == 2 || (v37 = twobitdeltas[v36] + v17, int v17 = v37 & 0xF, v14 >= v12))
              {
                uint64_t v27 = v14;
              }
              else
              {
                if (v14)
                {
                  long long v39 = v18 + 1;
                  unsigned __int8 v38 = *v18 | v17;
                }
                else
                {
                  unsigned __int8 v38 = 16 * v37;
                  long long v39 = v18;
                }
                uint64_t v27 = v14 + 1;
                *long long v18 = v38;
                long long v18 = v39;
              }
              if ((v20 & 3) == 2) {
                goto LABEL_58;
              }
              int v40 = twobitdeltas[v20 & 3];
              goto LABEL_55;
            case 2u:
              uint64_t v26 = (v20 >> 3) & 7;
              if (v26 == 4)
              {
                uint64_t v27 = v14;
              }
              else
              {
                int v28 = threebitdeltas[v26] + v17;
                int v17 = v28 & 0xF;
                if (v14)
                {
                  long long v30 = v18 + 1;
                  unsigned __int8 v29 = *v18 | v17;
                }
                else
                {
                  unsigned __int8 v29 = 16 * v28;
                  long long v30 = v18;
                }
                uint64_t v27 = v14 + 1;
                *long long v18 = v29;
                long long v18 = v30;
              }
              if ((v20 & 7) == 4) {
                goto LABEL_58;
              }
              int v40 = threebitdeltas[v20 & 7];
LABEL_55:
              char v41 = v40 + v17;
              int v17 = v41 & 0xF;
              if (v27 >= v12) {
                goto LABEL_58;
              }
              uint64_t v14 = v27 + 1;
              if (v27) {
                *v18++ |= v17;
              }
              else {
                *long long v18 = 16 * v41;
              }
              break;
            case 3u:
              int v17 = v20 & 0xF;
              uint64_t v27 = v14 + 1;
              if (v14) {
                *v18++ |= v17;
              }
              else {
                *long long v18 = 16 * v20;
              }
LABEL_58:
              uint64_t v14 = v27;
              break;
            default:
              if (v20)
              {
                if (v14)
                {
                  unsigned __int8 v31 = *v18 | v17;
                  int v17 = v31;
                  *v18++ = v31;
                  ++v14;
                  LODWORD(v20) = v20 - 1;
                }
                else
                {
                  v17 |= 16 * v17;
                }
                v14 += v20;
                if (v14 <= v12)
                {
                  if ((int)v20 >= 1)
                  {
                    if ((int)v20 >= 2) {
                      int v32 = 2;
                    }
                    else {
                      int v32 = v20;
                    }
                    unsigned int v33 = v20 - v32 + 1;
                    memset(v18, v17, (v33 >> 1) + 1);
                    a3 = v50;
                    __b = v51;
                    v18 += (v33 >> 1) + 1;
                    unsigned int v34 = v33 & 0xFFFFFFFE;
                    uint64_t v8 = (uint64_t)a1;
                    LODWORD(v20) = v20 - v34 - 2;
                  }
                  if (v20 == -1)
                  {
                    char v35 = *--v18;
                    *long long v18 = v35 & 0xF0;
                  }
                  v17 &= 0xFu;
                }
              }
              break;
          }
          BOOL v13 = v14 < v12;
          uint64_t v11 = v19 - 1;
          if (v19 < 2) {
            break;
          }
          --v19;
        }
        while (v14 < v12);
      }
      *(void *)(v8 + 1152) = v10;
      *(void *)(v8 + 1160) = v11;
      if (v14 != v12) {
        break;
      }
      uint64_t v16 = *(void *)(v8 + 1104);
      __b += v16;
      BOOL v15 = a3 <= v16;
      a3 -= v16;
      if (v15) {
        return 1;
      }
    }
    bzero(v18, &__b[(unint64_t)(v12 + 1) >> 1] - (char *)v18);
    signed int v47 = "Too much";
    if (v13) {
      signed int v47 = "Not enough";
    }
    TIFFErrorExtR(v8, "ThunderDecode", "%s data at scanline %lu (%llu != %llu)", v42, v43, v44, v45, v46, (char)v47);
    return 0;
  }
  return 1;
}

const char *IIO_AlphaInfoString(char a1)
{
  if ((a1 & 0x1Fu) > 7) {
    return "";
  }
  else {
    return off_1E53CC738[a1 & 0x1F];
  }
}

char *IIO_BitmapInfoString(unsigned int a1)
{
  if ((a1 & 0x1F) > 7) {
    vImage_Error v2 = "";
  }
  else {
    vImage_Error v2 = off_1E53CC738[a1 & 0x1F];
  }
  memset(&v9, 0, sizeof(v9));
  std::string::basic_string[abi:ne180100]<0>(&v9, v2);
  unsigned int v3 = (a1 >> 12) & 7;
  if (v3 >= 5) {
    uint64_t v4 = "| unknown-ByteOrder";
  }
  else {
    uint64_t v4 = off_1E53CC7F8[v3];
  }
  std::string::append(&v9, v4);
  unsigned int v5 = HIWORD(a1) & 0xF;
  if (v5 > 4) {
    uint64_t v6 = "| unknown-PixelFormat";
  }
  else {
    uint64_t v6 = off_1E53CC820[v5];
  }
  std::string::append(&v9, v6);
  if ((a1 & 0xF00) == 0x100) {
    std::string::append(&v9, "| FloatComponents");
  }
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    long long v7 = (void *)v9.__r_.__value_.__r.__words[0];
    strncpy(IIO_BitmapInfoString::str, v9.__r_.__value_.__l.__data_, 0x80uLL);
    operator delete(v7);
  }
  else
  {
    strncpy(IIO_BitmapInfoString::str, (const char *)&v9, 0x80uLL);
  }
  return IIO_BitmapInfoString::str;
}

void sub_1887ABA48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *IIO_BitmapInfoStringSmall(unsigned int a1)
{
  memset(&v9, 0, sizeof(v9));
  if ((a1 & 0x1F) > 7) {
    vImage_Error v2 = "";
  }
  else {
    vImage_Error v2 = off_1E53CC778[a1 & 0x1F];
  }
  MEMORY[0x18C11BE10](&v9, v2);
  unsigned int v3 = (a1 >> 12) & 7;
  if (v3 >= 5) {
    uint64_t v4 = "| unknown ";
  }
  else {
    uint64_t v4 = off_1E53CC848[v3];
  }
  std::string::append(&v9, v4);
  unsigned int v5 = HIWORD(a1) & 0xF;
  if (v5 > 4) {
    uint64_t v6 = "| unknown  ";
  }
  else {
    uint64_t v6 = off_1E53CC870[v5];
  }
  std::string::append(&v9, v6);
  if ((a1 & 0xF00) == 0x100) {
    std::string::append(&v9, "| Float");
  }
  if (SHIBYTE(v9.__r_.__value_.__r.__words[2]) < 0)
  {
    long long v7 = (void *)v9.__r_.__value_.__r.__words[0];
    strncpy(IIO_BitmapInfoStringSmall::str, v9.__r_.__value_.__l.__data_, 0x80uLL);
    operator delete(v7);
  }
  else
  {
    strncpy(IIO_BitmapInfoStringSmall::str, (const char *)&v9, 0x80uLL);
  }
  return IIO_BitmapInfoStringSmall::str;
}

void sub_1887ABB7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

const char *IIO_ColorModelString(int a1)
{
  if (a1 > 6) {
    return "";
  }
  else {
    return off_1E53CC7B8[a1 + 1];
  }
}

const char *IIO_dump@char *a1, const __CFString *cf
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (cf)
  {
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    *(_OWORD *)uint64_t buffer = 0u;
    long long v10 = 0u;
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      CFStringGetCString(cf, buffer, 255, 0x8000100u);
    }
    else
    {
      CFStringRef v6 = CFCopyDescription(cf);
      if (v6)
      {
        CFStringRef v7 = v6;
        CFStringGetCString(v6, buffer, 255, 0x8000100u);
        CFRelease(v7);
      }
    }
    unsigned int v5 = buffer;
  }
  else
  {
    unsigned int v5 = "(null)";
  }
  return ImageIOLog(a1, v5);
}

void IIO_CFShow(const __CFDictionary *a1, uint64_t a2, const char *a3)
{
  while (1)
  {
    uint64_t v67 = *MEMORY[0x1E4F143B8];
    if (!a1) {
      break;
    }
    unsigned int v3 = a3;
    uint64_t v4 = a2;
    CFDictionaryRef v5 = a1;
    CFTypeID v6 = CFGetTypeID(a1);
    memset(v66, 0, sizeof(v66));
    long long v65 = 0u;
    long long v64 = 0u;
    long long v63 = 0u;
    long long v62 = 0u;
    long long v61 = 0u;
    long long v60 = 0u;
    long long v59 = 0u;
    long long v58 = 0u;
    long long v57 = 0u;
    long long v56 = 0u;
    long long v55 = 0u;
    long long v54 = 0u;
    long long v53 = 0u;
    long long v52 = 0u;
    char buffer = 63;
    if (v4 >= 1)
    {
      uint64_t v7 = v4;
      do
      {
        ImageIOLog("    ");
        --v7;
      }
      while (v7);
    }
    if (v3) {
      ImageIOLog("%s = ", v3);
    }
    if (v6 == CFDictionaryGetTypeID())
    {
      CFIndex Count = CFDictionaryGetCount(v5);
      std::string v9 = (FILE **)MEMORY[0x1E4F143C8];
      long long v10 = (FILE *)*MEMORY[0x1E4F143C8];
      if (Count)
      {
        int64_t v11 = Count;
        fwrite("dict(\n", 6uLL, 1uLL, v10);
        long long v12 = (const void **)malloc_type_malloc(8 * v11, 0x6004044C4A2DFuLL);
        CFDictionaryGetKeysAndValues(v5, v12, 0);
        qsort(v12, v11, 8uLL, (int (__cdecl *)(const void *, const void *))keySort);
        if (v11 >= 1)
        {
          long long v13 = (CFStringRef *)v12;
          do
          {
            CFStringGetCString(*v13, &buffer, 255, 0x8000100u);
            CFStringRef v14 = *v13++;
            CFDataRef Value = CFDictionaryGetValue(v5, v14);
            IIO_CFShow(Value, v4 + 1, &buffer);
            --v11;
          }
          while (v11);
        }
        free(v12);
        if (v4 >= 1)
        {
          do
          {
            ImageIOLog("    ");
            --v4;
          }
          while (v4);
        }
        long long v16 = *v9;
LABEL_26:
        fwrite(")\n", 2uLL, 1uLL, v16);
        return;
      }
      unsigned __int8 v29 = "dict()\n";
      size_t v30 = 7;
      goto LABEL_60;
    }
    if (v6 == CFArrayGetTypeID())
    {
      CFIndex v17 = CFArrayGetCount(v5);
      long long v18 = (FILE **)MEMORY[0x1E4F143C8];
      long long v10 = (FILE *)*MEMORY[0x1E4F143C8];
      if (v17)
      {
        uint64_t v19 = v17;
        fwrite("array(\n", 7uLL, 1uLL, v10);
        if (v19 >= 1)
        {
          for (CFIndex i = 0; i != v19; ++i)
          {
            size_t v21 = strlen(&buffer);
            snprintf(&buffer, 256 - v21, "#%2ld", i);
            ValueAtIndeCGFloat x = CFArrayGetValueAtIndex(v5, i);
            IIO_CFShow(ValueAtIndex, v4 + 1, &buffer);
          }
        }
        if (v4 >= 1)
        {
          do
          {
            ImageIOLog("    ");
            --v4;
          }
          while (v4);
        }
        long long v16 = *v18;
        goto LABEL_26;
      }
      unsigned __int8 v29 = "array()\n";
      size_t v30 = 8;
      goto LABEL_60;
    }
    if (v6 == CFBagGetTypeID())
    {
      uint64_t v23 = MEMORY[0x18C11A0A0](v5);
      long long v24 = (FILE **)MEMORY[0x1E4F143C8];
      long long v10 = (FILE *)*MEMORY[0x1E4F143C8];
      if (v23)
      {
        uint64_t v25 = v23;
        fwrite("bag(\n", 5uLL, 1uLL, v10);
        uint64_t v26 = (const void **)malloc_type_malloc(8 * v25, 0xC0040B8AA526DuLL);
        CFBagGetValues(v5, v26);
        if (v25 >= 1)
        {
          uint64_t v27 = v26;
          do
          {
            uint64_t v28 = (uint64_t)*v27++;
            IIO_CFShow(v28, v4 + 1, 0);
            --v25;
          }
          while (v25);
        }
        free(v26);
        if (v4 >= 1)
        {
          do
          {
            ImageIOLog("    ");
            --v4;
          }
          while (v4);
        }
        goto LABEL_44;
      }
      unsigned __int8 v29 = "bag()\n";
LABEL_59:
      size_t v30 = 6;
      goto LABEL_60;
    }
    if (v6 == CFSetGetTypeID())
    {
      CFIndex v31 = CFSetGetCount(v5);
      long long v24 = (FILE **)MEMORY[0x1E4F143C8];
      long long v10 = (FILE *)*MEMORY[0x1E4F143C8];
      if (!v31)
      {
        unsigned __int8 v29 = "set()\n";
        goto LABEL_59;
      }
      uint64_t v32 = v31;
      fwrite("set(\n", 5uLL, 1uLL, v10);
      unsigned int v33 = (const void **)malloc_type_malloc(8 * v32, 0xC0040B8AA526DuLL);
      CFSetGetValues(v5, v33);
      if (v32 >= 1)
      {
        unsigned int v34 = v33;
        do
        {
          uint64_t v35 = (uint64_t)*v34++;
          IIO_CFShow(v35, v4 + 1, 0);
          --v32;
        }
        while (v32);
      }
      free(v33);
      if (v4 >= 1)
      {
        do
        {
          ImageIOLog("    ");
          --v4;
        }
        while (v4);
      }
LABEL_44:
      long long v10 = *v24;
      unsigned __int8 v29 = ")\n";
      size_t v30 = 2;
LABEL_60:
      fwrite(v29, v30, 1uLL, v10);
      return;
    }
    if (v6 == CFStringGetTypeID())
    {
      IIO_dump@"\"%s\"\n", (const __CFString *)v5;
      return;
    }
    if (v6 == CFBooleanGetTypeID())
    {
      uint64_t v36 = (FILE *)*MEMORY[0x1E4F143C8];
      if ((const __CFDictionary *)*MEMORY[0x1E4F1CFD0] == v5) {
        int v37 = "true\n";
      }
      else {
        int v37 = "false\n";
      }
      fprintf(v36, v37);
      return;
    }
    if (v6 == CFNumberGetTypeID())
    {
      double valuePtr = 0.0;
      CFNumberGetValue(v5, kCFNumberDoubleType, &valuePtr);
      unsigned __int8 v38 = (FILE *)*MEMORY[0x1E4F143C8];
      if (valuePtr == (double)(int)valuePtr) {
        fprintf(v38, "%d\n", valuePtr);
      }
      else {
        fprintf(v38, "%f\n", valuePtr);
      }
      return;
    }
    if (v6 == CGImageMetadataPropertyGetTypeID())
    {
      if (v4 < 1)
      {
        CFStringRef Schema = (const __CFString *)CGImageMetadataPropertyGetSchema((uint64_t)v5);
        IIO_dump@"   schema: %s\n", Schema;
      }
      else
      {
        uint64_t v39 = v4;
        do
        {
          ImageIOLog("    ");
          --v39;
        }
        while (v39);
        CFStringRef v40 = (const __CFString *)CGImageMetadataPropertyGetSchema((uint64_t)v5);
        IIO_dump@"   schema: %s\n", v40;
        uint64_t v41 = v4;
        do
        {
          ImageIOLog("    ");
          --v41;
        }
        while (v41);
      }
      SuggestedPrefiCGFloat x = (const __CFString *)CGImageMetadataPropertyGetSuggestedPrefix((uint64_t)v5);
      IIO_dump@"            prefix: %s\n", SuggestedPrefix;
      if (v4 < 1)
      {
        CFStringRef PropertyName = (const __CFString *)CGImageMetadataPropertyGetPropertyName((uint64_t)v5);
        IIO_dump@"          property: %s\n", PropertyName;
      }
      else
      {
        uint64_t v46 = v4;
        do
        {
          ImageIOLog("    ");
          --v46;
        }
        while (v46);
        CFStringRef v48 = (const __CFString *)CGImageMetadataPropertyGetPropertyName((uint64_t)v5);
        IIO_dump@"          property: %s\n", v48;
        uint64_t v49 = v4;
        do
        {
          ImageIOLog("    ");
          --v49;
        }
        while (v49);
      }
      fwrite("             value: \n", 0x15uLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
      a1 = (const __CFDictionary *)CGImageMetadataPropertyGetValue((uint64_t)v5);
      a2 = v4 + 1;
    }
    else
    {
      if (v6 != CGImageMetadataValueGetTypeID())
      {
        if (v6)
        {
          CFStringRef v42 = CFCopyDescription(v5);
          if (v42)
          {
            CFStringRef v43 = v42;
            IIO_dump@"%s\n", v42;
            CFRelease(v43);
          }
        }
        else
        {
          ImageIOLog("*** valueType is 0\n");
          ImageIOLog("    value: %p\n", v5);
        }
        return;
      }
      a1 = (const __CFDictionary *)CGImageMetadataValueGetValue((uint64_t)v5);
      a2 = v4 - 2;
    }
    a3 = 0;
  }

  ImageIOLog("(null)\n");
}

CFComparisonResult keySort(CFTypeRef *a1, CFStringRef *a2)
{
  CFTypeID v4 = CFGetTypeID(*a1);
  if (v4 == CFStringGetTypeID() && (CFTypeID v5 = CFGetTypeID(*a2), v5 == CFStringGetTypeID())) {
    return CFStringCompare((CFStringRef)*a1, *a2, 0);
  }
  else {
    return 0;
  }
}

void IIOMetadata_Tag::setName(IIOMetadata_Tag *this, const __CFString *a2)
{
  vImage_Error v2 = (const void *)*((void *)this + 4);
  *((void *)this + 4) = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2);
  if (v2)
  {
    CFRelease(v2);
  }
}

CFStringRef IIOMetadata_Tag::createPathWithChildPath(IIOMetadata_Tag *this, const __CFString *a2)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef result = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%@:%@", *((void *)this + 3), *((void *)this + 4));
  if (result)
  {
    CFStringRef v6 = result;
    CharacterAtIndeCGFloat x = CFStringGetCharacterAtIndex(a2, 0);
    CFStringRef v8 = @"%@.%@";
    if (CharacterAtIndex == 46 || CharacterAtIndex == 63) {
      CFStringRef v8 = @"%@%@";
    }
    if (*((_DWORD *)this + 10) == 6) {
      CFStringRef v10 = CFStringCreateWithFormat(v4, 0, v8, v6, a2);
    }
    else {
      CFStringRef v10 = CFStringCreateWithFormat(v4, 0, @"%@%@", v6, a2);
    }
    CFStringRef v11 = v10;
    CFRelease(v6);
    return v11;
  }
  return result;
}

void CGImageMetadataTagSetName(uint64_t a1, const __CFString *a2)
{
  if (a1)
  {
    vImage_Error v2 = *(IIOMetadata_Tag **)(a1 + 24);
    if (v2) {
      IIOMetadata_Tag::setName(v2, a2);
    }
  }
}

uint64_t CGImageMetadataTagSetValueType(uint64_t result, int a2)
{
  if (result)
  {
    uint64_t v2 = *(void *)(result + 24);
    if (v2) {
      *(_DWORD *)(v2 + 40) = a2;
    }
  }
  return result;
}

CFArrayRef CGImageMetadataTagCopyQualifiers(CGImageMetadataTagRef tag)
{
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0x3000) == 0) {
    ImageIODebugOptions(3, "A", "CGImageMetadataTagCopyQualifiers", 0, 0, -1, 0);
  }
  if (!tag) {
    return 0;
  }
  uint64_t v2 = *((void *)tag + 3);
  if (!v2) {
    return 0;
  }
  CFArrayRef v3 = *(const __CFArray **)(v2 + 56);
  if (!v3) {
    return 0;
  }
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];

  return CFArrayCreateCopy(v4, v3);
}

uint64_t CGImageMetadataTagCreateFromImageProperty(const void *a1, const void *a2, uint64_t a3)
{
  uint64_t v13 = 0;
  CFStringRef v14 = &v13;
  uint64_t v15 = 0x2000000000;
  uint64_t v16 = 0;
  if (a1)
  {
    CFTypeID v6 = CFGetTypeID(a1);
    CFTypeID TypeID = CFStringGetTypeID();
    if (a2)
    {
      if (v6 == TypeID)
      {
        CFTypeID v8 = CFGetTypeID(a2);
        CFTypeID v9 = CFStringGetTypeID();
        if (a3)
        {
          if (v8 == v9)
          {
            v12[0] = MEMORY[0x1E4F143A8];
            v12[1] = 0x40000000;
            v12[2] = __CGImageMetadataTagCreateFromImageProperty_block_invoke;
            v12[3] = &unk_1E53C0178;
            v12[4] = &v13;
            v12[5] = a1;
            v12[6] = a2;
            v12[7] = a3;
            XMPMappingIterateUsingBlock((uint64_t)v12);
          }
        }
      }
    }
  }
  uint64_t v10 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v10;
}

void sub_1887AC968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __CGImageMetadataTagCreateFromImageProperty_block_invoke(uint64_t a1, CFStringRef **a2, unsigned char *a3)
{
  uint64_t result = CFStringCompare(*(CFStringRef *)(a1 + 40), **a2, 0);
  if (!result)
  {
    uint64_t result = CFStringCompare(*(CFStringRef *)(a1 + 48), *a2[1], 0);
    if (!result)
    {
      uint64_t result = (uint64_t)CGImageMetadataTagCreate(*a2[3], 0, *a2[4], kCGImageMetadataTypeDefault, *(CFTypeRef *)(a1 + 56));
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
      *a3 = 1;
    }
  }
  return result;
}

CGImageMetadataTagRef CGImageMetadataTagCopy(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 24);
  int v2 = *(_DWORD *)(v1 + 40);
  if ((v2 - 2) >= 4)
  {
    if (v2 == 6)
    {
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CopCGFloat y = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFDictionaryRef *)(v1 + 48));
    }
    else
    {
      if (v2 != 1) {
        return 0;
      }
      CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      CopCGFloat y = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFStringRef *)(v1 + 48));
    }
  }
  else
  {
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CopCGFloat y = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFArrayRef *)(v1 + 48));
  }
  CFTypeID v5 = Copy;
  if (!Copy) {
    return 0;
  }
  CGImageMetadataTagRef v6 = CGImageMetadataTagCreate(*(CFStringRef *)(v1 + 16), *(CFStringRef *)(v1 + 24), *(CFStringRef *)(v1 + 32), (CGImageMetadataType)*(_DWORD *)(v1 + 40), Copy);
  CFRelease(v5);
  if (v6)
  {
    CFArrayRef v7 = *(const __CFArray **)(v1 + 56);
    if (v7)
    {
      uint64_t v8 = *((void *)v6 + 3);
      *(void *)(v8 + 56) = CFArrayCreateMutableCopy(v3, 0, v7);
    }
  }
  return v6;
}

CFStringRef _CGImageMetadataTagCopyFormattingDescription(CFTypeRef cf, const __CFDictionary *a2)
{
  if (!cf || (CFTypeRef)*MEMORY[0x1E4F1D260] == cf) {
    return 0;
  }
  CFTypeID v3 = CFGetTypeID(cf);
  if (CGImageMetadataTagGetTypeID::once != -1) {
    dispatch_once(&CGImageMetadataTagGetTypeID::once, &__block_literal_global_34);
  }
  if (v3 != CGImageMetadataTagGetTypeID::id) {
    return 0;
  }
  CFAllocatorRef v4 = (void *)*((void *)cf + 3);
  uint64_t v5 = v4[3];
  uint64_t v6 = v4[4];
  uint64_t v7 = v4[6];
  BOOL v8 = !v5 || v6 == 0;
  if (v8 || v7 == 0) {
    return 0;
  }
  uint64_t v11 = v4[7];
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (v11) {
    return CFStringCreateWithFormat(v12, 0, @"%@:%@ = %@, Qualifiers = %@", v5, v6, v7, v11);
  }
  else {
    return CFStringCreateWithFormat(v12, 0, @"%@:%@ = %@", v5, v6, v7);
  }
}

CFStringRef _CGImageMetadataTagCopyDescription(CFTypeRef cf)
{
  if (!cf || (CFTypeRef)*MEMORY[0x1E4F1D260] == cf) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(cf);
  if (CGImageMetadataTagGetTypeID::once != -1) {
    dispatch_once(&CGImageMetadataTagGetTypeID::once, &__block_literal_global_34);
  }
  if (v2 != CGImageMetadataTagGetTypeID::id) {
    return 0;
  }
  CFTypeID v3 = (void *)*((void *)cf + 3);
  uint64_t v4 = v3[3];
  uint64_t v5 = v3[4];
  uint64_t v6 = v3[6];
  BOOL v7 = !v4 || v5 == 0;
  if (v7 || v6 == 0) {
    return 0;
  }
  uint64_t v10 = v3[7];
  CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (v10) {
    return CFStringCreateWithFormat(v11, 0, @"<CGImageMetadataTag %p> %@:%@ = %@, Qualifiers = %@", cf, v4, v5, v6, v10);
  }
  else {
    return CFStringCreateWithFormat(v11, 0, @"<CGImageMetadataTag %p> %@:%@ = %@", cf, v4, v5, v6);
  }
}

void __CGInitializeImageIO_block_invoke_3()
{
  if (*(double *)&gFirstCallTime == 0.0)
  {
    ImageIOLogInternal("⏹️   ImageIO: not launching XPCService (no ImageIO call within first 8 sec)...\n", *(double *)&gFirstCallTime);
    IIONumber::IIONumber((IIONumber *)v0, -2.0);
    CFPreferencesSetAppValue(@"IIO_LaunchInfo", value, (CFStringRef)*MEMORY[0x1E4F1D3D8]);
    IIONumber::~IIONumber((IIONumber *)v0);
  }
}

void sub_1887ACD44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void __CGInitializeImageIO_block_invoke_4()
{
  ImageIOLogInternal("✳️   ImageIO: launching XPCService: %g\n", *(double *)&gSavedFirstCallTime);
  if (IIOXPCClient::GetIIOXPCClient(void)::xpcClientCreate != -1) {
    dispatch_once(&IIOXPCClient::GetIIOXPCClient(void)::xpcClientCreate, &__block_literal_global_20);
  }
  vImage_Error v0 = (IIOXPCClient *)IIOXPCClient::GetIIOXPCClient(void)::gIIOXPCClient;
  if (IIOIsOOPEnabled(0))
  {
    IIOXPCClient::wakeup_xpc_service(v0);
  }
}

void IIOXPCClient::wakeup_xpc_service(IIOXPCClient *this)
{
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN12IIOXPCClient18wakeup_xpc_serviceEv_block_invoke;
  block[3] = &__block_descriptor_tmp_83;
  block[4] = this;
  if (IIOXPCClient::wakeup_xpc_service(void)::onceToken != -1) {
    dispatch_once(&IIOXPCClient::wakeup_xpc_service(void)::onceToken, block);
  }
}

void IIOXPCClient::~IIOXPCClient(IIOXPCClient *this)
{
  *(void *)this = &unk_1ED4DF1D0;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 32));
  CFTypeID v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
}

{
  uint64_t vars8;

  IIOXPCClient::~IIOXPCClient(this);

  JUMPOUT(0x18C11C0E0);
}

void IIOXPCClient::connection_set_event_handler(IIOXPCClient *this, _xpc_connection_s *a2, dispatch_queue_s *a3)
{
  if (!a2) {
    IIOXPCClient::connection_set_event_handler();
  }
  IIOXPCLog("connection_set_event_handler %p\n", a2);
  handler[0] = MEMORY[0x1E4F143A8];
  handler[1] = 0x40000000;
  handler[2] = ___ZN12IIOXPCClient28connection_set_event_handlerEP17_xpc_connection_sP16dispatch_queue_s_block_invoke;
  handler[3] = &__block_descriptor_tmp_40_0;
  handler[4] = this;
  handler[5] = a2;
  xpc_connection_set_event_handler(a2, handler);
  xpc_connection_resume(a2);
}

void ___ZN12IIOXPCClient28connection_set_event_handlerEP17_xpc_connection_sP16dispatch_queue_s_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  name = xpc_connection_get_name(*(xpc_connection_t *)(a1 + 40));
  IIOXPCLog("xpc connection  event handler called for %s\n", name);
  if (MEMORY[0x18C11DEB0](a2) == MEMORY[0x1E4F145A8])
  {
    uint64_t v6 = (const char *)*MEMORY[0x1E4F14530];
    string = xpc_dictionary_get_string(a2, (const char *)*MEMORY[0x1E4F14530]);
    if (a2 == (void *)MEMORY[0x1E4F14520])
    {
      uint64_t v10 = string;
      CFAllocatorRef v11 = xpc_connection_get_name(*(xpc_connection_t *)(a1 + 40));
      ImageIOLog("❌ ImageIOXPC: connection interrupted: %s (%s)\n", v11, v10);
      kdebug_trace();
      *(unsigned char *)(v4 + 103) = 0;
    }
    else
    {
      BOOL v8 = (void *)MEMORY[0x1E4F14528];
      CFTypeID v9 = xpc_connection_get_name(*(xpc_connection_t *)(a1 + 40));
      if (a2 == v8)
      {
        ImageIOLog("❌ XPC_ERROR_CONNECTION_INVALID: %s\n", v9);
        kdebug_trace();
      }
      else
      {
        xpc_dictionary_get_string(a2, v6);
        IIOXPCLog("❌ ImageIOXPC: connection %s received unexpected error event: %s\n");
      }
    }
  }
  else
  {
    xpc_connection_get_name(*(xpc_connection_t *)(a1 + 40));
    IIOXPCLog("❌ ImageIOXPC: received unexpected event in connection handler for service %s\n");
  }
}

double iio_xpc_get_CGRect_from_xpcObj(void *a1)
{
  if (xpc_dictionary_get_count(a1) != 4) {
    return 0.0;
  }
  double v2 = xpc_dictionary_get_double(a1, "origin_x");
  xpc_dictionary_get_double(a1, "origin_y");
  xpc_dictionary_get_double(a1, "size_width");
  xpc_dictionary_get_double(a1, "size_height");
  return v2;
}

void iio_xpc_get_CGSize_from_xpcObj(void *a1)
{
  if (xpc_dictionary_get_count(a1) == 2)
  {
    xpc_dictionary_get_double(a1, "size_width");
    xpc_dictionary_get_double(a1, "size_height");
  }
}

uint64_t ___ZN12IIOXPCClient18wakeup_xpc_serviceEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(IIOXPCClient **)(a1 + 32);
  kdebug_trace();
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  if (v2)
  {
    CFTypeID v3 = v2;
    if (!*((unsigned char *)v1 + 101))
    {
      xpc_dictionary_set_uint64(v2, "iio_xpc_message_id", 8uLL);
      xpc_dictionary_set_uint64(v3, "iio_xpc_msg_debugflags", gIIODebugFlags);
      pid_t v4 = getpid();
      xpc_dictionary_set_uint64(v3, "iio_xpc_msg_pid", v4);
      dispatch_queue_t v5 = dispatch_queue_create("com.apple.iio.queue", MEMORY[0x1E4F14430]);
      if (!v5) {
        ___ZN12IIOXPCClient18wakeup_xpc_serviceEv_block_invoke_cold_1();
      }
      uint64_t v6 = v5;
      BOOL v7 = (_xpc_connection_s *)IIOXPCClient::xpc_service_connection(v1);
      xpc_connection_send_message_with_reply(v7, v3, v6, &__block_literal_global_82);
      dispatch_release(v6);
    }
    xpc_release(v3);
  }

  return kdebug_trace();
}

xpc_object_t ___ZN12IIOXPCClient18wakeup_xpc_serviceEv_block_invoke_2(int a1, xpc_object_t xdict)
{
  return xpc_dictionary_get_dictionary(xdict, "iio_xpc_msg");
}

xpc_object_t iio_xpc_get_message_dict(void *a1)
{
  return xpc_dictionary_get_dictionary(a1, "iio_xpc_msg");
}

xpc_object_t IIOXPCClient::send_message_with_reply(IIOXPCClient *this, _xpc_connection_s *a2, dispatch_queue_s *a3, xpc_object_t xdict)
{
  atomic_fetch_add(&IIOXPCClient::send_message_with_reply(_xpc_connection_s *,dispatch_queue_s *,void *)::gTransactionID, 1uLL);
  uint64_t v7 = atomic_load((unint64_t *)&IIOXPCClient::send_message_with_reply(_xpc_connection_s *,dispatch_queue_s *,void *)::gTransactionID);
  xpc_dictionary_set_uint64(xdict, "iio_xpc_transacion_id", v7);
  unint64_t v8 = atomic_load((unint64_t *)&IIOXPCClient::send_message_with_reply(_xpc_connection_s *,dispatch_queue_s *,void *)::gTransactionID);
  if (v8 == 1)
  {
    gFirstCallTime = CFAbsoluteTimeGetCurrent();
    ImageIOLogInternal("⏹️   ImageIO: first ImageIO call after %g seconds [previously: %g]...\n", *(double *)&gFirstCallTime - *(double *)&gWakeupTime, *(double *)&gSavedFirstCallTime);
    double v9 = *(double *)&gFirstCallTime - *(double *)&gWakeupTime;
    if (*(double *)&gSavedFirstCallTime >= 0.0)
    {
      if (*(double *)&gSavedFirstCallTime - v9 <= 0.01)
      {
LABEL_9:
        kdebug_trace();
        pid_t v10 = getpid();
        xpc_dictionary_set_uint64(xdict, "iio_xpc_msg_pid", v10);
        goto LABEL_10;
      }
      *(double *)&gSavedFirstCallTime = *(double *)&gFirstCallTime - *(double *)&gWakeupTime;
      ImageIOLogInternal("⏹️   ImageIO: updating first IIO ImageIO to %g\n", v9);
      IIONumber::IIONumber((IIONumber *)v20, *(double *)&gSavedFirstCallTime);
      CFPreferencesSetAppValue(@"IIO_LaunchInfo", value, (CFStringRef)*MEMORY[0x1E4F1D3D8]);
    }
    else
    {
      if (v9 > 8.0) {
        double v9 = 8.0;
      }
      gSavedFirstCallTime = *(void *)&v9;
      ImageIOLogInternal("⏹️   ImageIO: updating first ImageIO call to %g\n", v9);
      IIONumber::IIONumber((IIONumber *)v20, *(double *)&gSavedFirstCallTime);
      CFPreferencesSetAppValue(@"IIO_LaunchInfo", value, (CFStringRef)*MEMORY[0x1E4F1D3D8]);
    }
    IIONumber::~IIONumber((IIONumber *)v20);
    goto LABEL_9;
  }
LABEL_10:
  IIOSavePermissionsToXPCObject(xdict);
  IIOSaveAllowedTypesToXPCObject(xdict);
  *((unsigned char *)this + 101) = 1;
  xpc_object_t v11 = xpc_connection_send_message_with_reply_sync(a2, xdict);
  emptCGFloat y = v11;
  if (v11)
  {
    uint64_t v13 = (IIOXPCClient *)MEMORY[0x18C11DEB0](v11);
    if (v13 == (IIOXPCClient *)MEMORY[0x1E4F145A8])
    {
      kdebug_trace();
      string = xpc_dictionary_get_string(empty, (const char *)*MEMORY[0x1E4F14530]);
      LogFault("send_message_with_reply", 656, "❌ Error: ImageIOXPCService send message error: %s\n", string);
      xpc_release(empty);
      emptCGFloat y = xpc_dictionary_create_empty();
      xpc_object_t v14 = iio_xpc_add_message_dict(empty);
      if (!v14)
      {
LABEL_18:
        uint64_t uint64 = xpc_dictionary_get_uint64(xdict, "iio_xpc_message_id");
        xpc_dictionary_set_uint64(empty, "iio_xpc_message_id", uint64);
        uint64_t v18 = xpc_dictionary_get_uint64(xdict, "iio_xpc_transacion_id");
        xpc_dictionary_set_uint64(empty, "iio_xpc_transacion_id", v18);
        return empty;
      }
      int64_t v15 = 0x70000000FFFFFA88;
    }
    else
    {
      if (IIOXPCClient::replyIsValid(v13, empty)) {
        goto LABEL_18;
      }
      xpc_release(empty);
      emptCGFloat y = xpc_dictionary_create_empty();
      xpc_object_t v14 = iio_xpc_add_message_dict(empty);
      if (!v14) {
        goto LABEL_18;
      }
      int64_t v15 = 0x70000000FFFFFA87;
    }
    xpc_dictionary_set_int64(v14, "iio_xpc_msg_error", v15);
    goto LABEL_18;
  }
  return empty;
}

void sub_1887AD6A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

xpc_object_t iio_xpc_add_message_dict(void *a1)
{
  dictionarCGFloat y = xpc_dictionary_get_dictionary(a1, "iio_xpc_msg");
  if (!dictionary)
  {
    dictionarCGFloat y = xpc_dictionary_create_empty();
    xpc_dictionary_set_value(a1, "iio_xpc_msg", dictionary);
    xpc_release(dictionary);
  }
  return dictionary;
}

void iio_xpc_dictionary_set_error_code(void *a1, unsigned int a2)
{
  if (a1) {
    xpc_dictionary_set_int64(a1, "iio_xpc_msg_error", a2 | 0x7000000000000000);
  }
}

BOOL IIOXPCClient::replyIsValid(IIOXPCClient *this, void *a2)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2000000000;
  char v9 = 1;
  if (MEMORY[0x18C11DEB0](a2) == MEMORY[0x1E4F14590])
  {
    applier[0] = MEMORY[0x1E4F143A8];
    applier[1] = 0x40000000;
    applier[2] = ___ZN12IIOXPCClient12replyIsValidEPv_block_invoke;
    applier[3] = &unk_1E53CC9C0;
    applier[4] = &v6;
    xpc_dictionary_apply(a2, applier);
    BOOL v3 = *((unsigned char *)v7 + 24) != 0;
  }
  else
  {
    BOOL v3 = 0;
    *((unsigned char *)v7 + 24) = 0;
  }
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1887AD81C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN12IIOXPCClient12replyIsValidEPv_block_invoke(uint64_t a1, char *__s)
{
  size_t v4 = strspn(__s, "abcdefghijklmnopqrstuvwxyz0123456789_");
  size_t v5 = strlen(__s);
  BOOL v6 = v4 == v5 && v5 >= 9;
  if (v6
    && !strncmp("iio_xpc_", __s, 8uLL)
    && strncmp("iio_xpc_message_id", __s, 0x12uLL)
    && strncmp("iio_xpc_transacion_id", __s, 0x15uLL))
  {
    return 1;
  }
  uint64_t result = 0;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  return result;
}

dispatch_queue_t IIOXPCClient::xpc_service_queue(IIOXPCClient *this)
{
  if (*((unsigned char *)this + 102)) {
    return (dispatch_queue_t)*((void *)this + 2);
  }
  *((unsigned char *)this + 102) = 1;
  IIOXPCLog("create xpc service queue\n");
  dispatch_queue_t result = dispatch_queue_create("com.apple.ImageIOXPCService.queue", 0);
  *((void *)this + 2) = result;
  return result;
}

uint64_t IIOXPCClient::xpc_service_connection(IIOXPCClient *this)
{
  xpc_object_t v2 = (pthread_mutex_t *)((char *)this + 32);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 32));
  if (!*((unsigned char *)this + 103))
  {
    *((unsigned char *)this + 103) = 1;
    IIOXPCLog("create xpc service connection (_connection: %p)\n", *((const void **)this + 3));
    BOOL v3 = xpc_connection_create("com.apple.ImageIOXPCService", 0);
    *((void *)this + 3) = v3;
    IIOXPCClient::connection_set_event_handler(this, v3, v4);
  }
  pthread_mutex_unlock(v2);
  return *((void *)this + 3);
}

BOOL iio_xpc_dictionary_add_databuffer(void *a1, const char *a2, void *buffer, size_t size)
{
  BOOL v6 = dispatch_data_create(buffer, size, 0, 0);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v6;
  xpc_object_t v8 = xpc_data_create_with_dispatch_data(v6);
  BOOL v9 = v8 != 0;
  if (v8)
  {
    pid_t v10 = v8;
    xpc_dictionary_set_value(a1, a2, v8);
    xpc_release(v10);
  }
  dispatch_release(v7);
  return v9;
}

BOOL iio_xpc_dictionary_add_CFData(void *a1, const char *a2, CFDataRef theData)
{
  BytePtr = (UInt8 *)CFDataGetBytePtr(theData);
  size_t Length = CFDataGetLength(theData);

  return iio_xpc_dictionary_add_databuffer(a1, a2, BytePtr, Length);
}

BOOL iio_xpc_add_xpcObj_from_IIOHeaderOptions(void *a1, const char *a2, void *a3)
{
  return iio_xpc_dictionary_add_databuffer(a1, a2, a3, 0x18uLL);
}

__n128 iio_xpc_get_IIOHeaderOptions_from_xpcObj@<Q0>(void *a1@<X0>, const char *a2@<X1>, __n128 *a3@<X8>)
{
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  size_t length = 0;
  data = (__n128 *)xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    if (length == 24)
    {
      __n128 result = *data;
      *a3 = *data;
      a3[1].n128_u64[0] = data[1].n128_u64[0];
    }
  }
  return result;
}

void *iio_xpc_add_xpcObj_from_CGRect(double a1, double a2, double a3, double a4)
{
  emptCGFloat y = xpc_dictionary_create_empty();
  BOOL v9 = empty;
  if (empty)
  {
    xpc_dictionary_set_double(empty, "origin_x", a1);
    xpc_dictionary_set_double(v9, "origin_y", a2);
    xpc_dictionary_set_double(v9, "size_width", a3);
    xpc_dictionary_set_double(v9, "size_height", a4);
  }
  return v9;
}

void *iio_xpc_add_xpcObj_from_CGSize(double a1, double a2)
{
  emptCGFloat y = xpc_dictionary_create_empty();
  size_t v5 = empty;
  if (empty)
  {
    xpc_dictionary_set_double(empty, "size_width", a1);
    xpc_dictionary_set_double(v5, "size_height", a2);
  }
  return v5;
}

void iio_xpc_dictionary_addCGRect(void *a1, const char *a2, double a3, double a4, double a5, double a6)
{
  xpc_object_t v8 = iio_xpc_add_xpcObj_from_CGRect(a3, a4, a5, a6);
  if (v8)
  {
    BOOL v9 = v8;
    xpc_dictionary_set_value(a1, a2, v8);
    xpc_release(v9);
  }
}

double iio_xpc_dictionary_get_CGRect(void *a1, const char *a2)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, a2);

  return iio_xpc_get_CGRect_from_xpcObj(value);
}

void iio_xpc_dictionary_addCGSize(void *a1, const char *a2, double a3, double a4)
{
  BOOL v6 = iio_xpc_add_xpcObj_from_CGSize(a3, a4);
  if (v6)
  {
    uint64_t v7 = v6;
    xpc_dictionary_set_value(a1, a2, v6);
    xpc_release(v7);
  }
}

void iio_xpc_dictionary_get_CGSize(void *a1, const char *a2)
{
  xpc_object_t value = xpc_dictionary_get_value(a1, a2);

  iio_xpc_get_CGSize_from_xpcObj(value);
}

void iio_xpc_dictionary_add_GlobalInfo(void *a1, const __CFData *a2, unsigned int a3)
{
  if (a2)
  {
    emptCGFloat y = xpc_dictionary_create_empty();
    iio_xpc_dictionary_add_CFData(empty, "iio_xpc_plugin_global_info_data", a2);
    uint64_t Length = CFDataGetLength(a2);
    xpc_dictionary_set_uint64(empty, "iio_xpc_plugin_global_info_data_size", Length);
    xpc_dictionary_set_uint64(empty, "iio_xpc_plugin_global_info_ostype", a3);
    xpc_dictionary_set_value(a1, "iio_xpc_plugin_global_info", empty);
    xpc_release(empty);
  }
}

xpc_object_t iio_xpc_dictionary_get_GlobalInfo(void *a1, uint64_t *a2)
{
  size_t length = 0;
  xpc_object_t result = xpc_dictionary_get_dictionary(a1, "iio_xpc_plugin_global_info");
  if (!result)
  {
    uint64_t v7 = 0;
    if (!a2) {
      return result;
    }
    goto LABEL_9;
  }
  size_t v4 = result;
  data = (void *)xpc_dictionary_get_data(result, "iio_xpc_plugin_global_info_data", &length);
  uint64_t uint64 = xpc_dictionary_get_uint64(v4, "iio_xpc_plugin_global_info_data_size");
  if (uint64 == length) {
    uint64_t v7 = uint64;
  }
  else {
    uint64_t v7 = 0;
  }
  if (uint64 == length) {
    xpc_object_t result = data;
  }
  else {
    xpc_object_t result = 0;
  }
  if (a2) {
LABEL_9:
  }
    *a2 = v7;
  return result;
}

xpc_object_t iio_xpc_dictionary_copy_CFDictionary(void *a1, const char *a2)
{
  xpc_object_t result = xpc_dictionary_get_dictionary(a1, a2);
  if (result)
  {
    return (xpc_object_t)_CFXPCCreateCFObjectFromXPCObject();
  }
  return result;
}

uint64_t iio_xpc_dictionary_add_CFDictionary(void *a1, const char *a2)
{
  size_t v4 = (void *)_CFXPCCreateXPCObjectFromCFObject();
  if (!v4) {
    return 4294967246;
  }
  size_t v5 = v4;
  xpc_dictionary_set_value(a1, a2, v4);
  xpc_release(v5);
  return 0;
}

uint64_t iio_xpc_dictionary_get_error_code(void *a1)
{
  uint64_t v1 = 4294965895;
  if (a1)
  {
    int64_t int64 = xpc_dictionary_get_int64(a1, "iio_xpc_msg_error");
    if ((~int64 & 0x7000000000000000) != 0) {
      return 4294965895;
    }
    else {
      return int64;
    }
  }
  return v1;
}

xpc_object_t iio_xpc_get_source_dict(void *a1)
{
  return xpc_dictionary_get_dictionary(a1, "iio_xpc_src");
}

xpc_object_t iio_xpc_get_plugin_dict(void *a1)
{
  return xpc_dictionary_get_dictionary(a1, "iio_xpc_plugin");
}

xpc_object_t iio_xpc_get_callback_dict(void *a1)
{
  return xpc_dictionary_get_dictionary(a1, "iio_xpc_cb");
}

xpc_object_t iio_xpc_get_permission_dict(void *a1)
{
  return xpc_dictionary_get_dictionary(a1, "iio_xpc_permission");
}

xpc_object_t iio_xpc_add_source_dict(void *a1)
{
  dictionarCGFloat y = xpc_dictionary_get_dictionary(a1, "iio_xpc_src");
  if (!dictionary)
  {
    dictionarCGFloat y = xpc_dictionary_create_empty();
    xpc_dictionary_set_value(a1, "iio_xpc_src", dictionary);
    xpc_release(dictionary);
  }
  return dictionary;
}

xpc_object_t iio_xpc_add_plugin_dict(void *a1)
{
  dictionarCGFloat y = xpc_dictionary_get_dictionary(a1, "iio_xpc_plugin");
  if (!dictionary)
  {
    dictionarCGFloat y = xpc_dictionary_create_empty();
    xpc_dictionary_set_value(a1, "iio_xpc_plugin", dictionary);
    xpc_release(dictionary);
  }
  return dictionary;
}

xpc_object_t iio_xpc_add_callback_dict(void *a1)
{
  dictionarCGFloat y = xpc_dictionary_get_dictionary(a1, "iio_xpc_cb");
  if (!dictionary)
  {
    dictionarCGFloat y = xpc_dictionary_create_empty();
    xpc_dictionary_set_value(a1, "iio_xpc_cb", dictionary);
    xpc_release(dictionary);
  }
  return dictionary;
}

xpc_object_t iio_xpc_add_permission_dict(void *a1)
{
  dictionarCGFloat y = xpc_dictionary_get_dictionary(a1, "iio_xpc_permission");
  if (!dictionary)
  {
    dictionarCGFloat y = xpc_dictionary_create_empty();
    xpc_dictionary_set_value(a1, "iio_xpc_permission", dictionary);
    xpc_release(dictionary);
  }
  return dictionary;
}

uint64_t _cg_png_set_palette_to_rgb(uint64_t result)
{
  if (result)
  {
    int v1 = *(_DWORD *)(result + 80);
    if ((v1 & 0x40) != 0)
    {
      return png_app_error(result, "invalid after png_start_read_image or png_read_update_info");
    }
    else
    {
      *(_DWORD *)(result + 80) = v1 | 0x4000;
      *(_DWORD *)(result + 88) |= 0x2001000u;
    }
  }
  return result;
}

unsigned int *png_do_gray_to_rgb(unsigned int *result, uint64_t a2)
{
  unsigned int v2 = *((unsigned __int8 *)result + 17);
  if (v2 >= 8)
  {
    int v3 = *((unsigned __int8 *)result + 16);
    if ((v3 & 2) == 0)
    {
      uint64_t v4 = *result;
      int v5 = *result;
      if (v3 == 4)
      {
        if (v2 == 8)
        {
          if (v5)
          {
            BOOL v9 = (unsigned char *)(a2 + 2 * v4 - 1);
            pid_t v10 = &v9[2 * v4];
            do
            {
              *pid_t v10 = *v9;
              *(v10 - 1) = *(v9 - 1);
              *(v10 - 2) = *(v9 - 1);
              *(v10 - 3) = *(v9 - 1);
              v10 -= 4;
              v9 -= 2;
              --v5;
            }
            while (v5);
          }
        }
        else if (v5)
        {
          uint64_t v13 = (unsigned char *)(a2 + 4 * v4 - 1);
          xpc_object_t v14 = &v13[4 * v4];
          do
          {
            *xpc_object_t v14 = *v13;
            *(v14 - 1) = *(v13 - 1);
            *(v14 - 2) = *(v13 - 2);
            *(v14 - 3) = *(v13 - 3);
            *(v14 - 4) = *(v13 - 2);
            *(v14 - 5) = *(v13 - 3);
            *(v14 - 6) = *(v13 - 2);
            *(v14 - 7) = *(v13 - 3);
            v14 -= 8;
            v13 -= 4;
            --v5;
          }
          while (v5);
        }
      }
      else if (!*((unsigned char *)result + 16))
      {
        if (v2 == 8)
        {
          if (v5)
          {
            BOOL v6 = (char *)(v4 + a2 - 1);
            uint64_t v7 = &v6[2 * v4];
            do
            {
              *uint64_t v7 = *v6;
              *(v7 - 1) = *v6;
              char v8 = *v6--;
              *(v7 - 2) = v8;
              v7 -= 3;
              --v5;
            }
            while (v5);
          }
        }
        else if (v5)
        {
          xpc_object_t v11 = (unsigned char *)(a2 + 2 * v4 - 1);
          CFAllocatorRef v12 = &v11[4 * v4];
          do
          {
            *CFAllocatorRef v12 = *v11;
            *(v12 - 1) = *(v11 - 1);
            *(v12 - 2) = *v11;
            *(v12 - 3) = *(v11 - 1);
            *(v12 - 4) = *v11;
            *(v12 - 5) = *(v11 - 1);
            v12 -= 6;
            v11 -= 2;
            --v5;
          }
          while (v5);
        }
      }
      char v15 = *((unsigned char *)result + 18) + 2;
      *((unsigned char *)result + 18) = v15;
      *((unsigned char *)result + 16) |= 2u;
      unsigned __int8 v16 = *((unsigned char *)result + 17) * v15;
      *((unsigned char *)result + 19) = v16;
      unint64_t v17 = (v16 * (unint64_t)v4 + 7) >> 3;
      unint64_t v18 = v4 * (unint64_t)(v16 >> 3);
      if (v16 < 8u) {
        unint64_t v18 = v17;
      }
      *((void *)result + 1) = v18;
    }
  }
  return result;
}

void yyerror(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  __s1[0] = 0;
  __s1[1] = &a9;
  vasprintf(__s1, a2, &a9);
  pid_t v10 = __s1[0];
  if (__s1[0])
  {
    if (a1 && (uint64_t v11 = *(void *)(a1 + 16)) != 0)
    {
      if (!*(void *)(v11 + 16)) {
        *(void *)(v11 + 16) = strdup(__s1[0]);
      }
    }
    else
    {
      fputs(__s1[0], (FILE *)*MEMORY[0x1E4F143C8]);
      pid_t v10 = __s1[0];
    }
    free(v10);
  }
}

void IIO_Reader_OpenEXR::createReadPlugin()
{
}

{
  operator new();
}

void sub_1887AE4C0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F3C406B41DD9BLL);
  _Unwind_Resume(a1);
}

void sub_1887AE560(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F3C406B41DD9BLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_OpenEXR::getImageCount(IIO_Reader_OpenEXR *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  if (!AppleEXREnabled())
  {
    unsigned int part_count = 1;
    if (!a5) {
      return 0;
    }
    goto LABEL_10;
  }
  xpc_object_t v14 = 0;
  uint64_t v7 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v14, 1);
  CFStringRef Size = IIOImageReadSession::getSize(a2);
  uint64_t v13 = 0;
  BOOL v9 = (void *)gFunc_axr_data_create(v7, Size, &v13, 0, 0);
  if (v13)
  {
    name = (const char *)gFunc_axr_error_get_name();
    LogError("getImageCount", 85, "*** axr_data_create failed: %s (%d)\n", name, v13);
  }
  if (v9)
  {
    unsigned int part_count = gFunc_axr_data_get_part_count(v9);
    os_release(v9);
  }
  else
  {
    unsigned int part_count = 0;
  }
  IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v14);
  if (a5) {
LABEL_10:
  }
    *a5 = part_count;
  return 0;
}

uint64_t IIO_Reader_OpenEXR::UpdateImageInfo(uint64_t a1, uint64_t *a2)
{
  uint64_t view_count = gFunc_axr_logical_image_list_get_view_count();
  if (!view_count)
  {
    _cg_jpeg_mem_term("UpdateImageInfo", 134, "*** ERROR: axr_logical_image_list_get_view_count returned 0\n");
    return 4294967246;
  }
  uint64_t v4 = 0;
  while (2)
  {
    memset(v27, 0, 72);
    long long v25 = 0u;
    *(_OWORD *)__p = 0u;
    *(_OWORD *)uint64_t v23 = 0u;
    *(_OWORD *)long long v24 = 0u;
    memset(v22, 0, sizeof(v22));
    DWORD1(v22[0]) = v4;
    uint64_t view_name = gFunc_axr_logical_image_list_get_view_name(a1, v4);
    MEMORY[0x18C11BE10](v23, view_name);
    unint64_t image_count = gFunc_axr_logical_image_list_get_image_count(a1, v4);
    if (!image_count)
    {
LABEL_26:
      BOOL v8 = 0;
      uint64_t v15 = 0;
      goto LABEL_27;
    }
    uint64_t v7 = 0;
    BOOL v8 = 1;
    while (1)
    {
      DWORD2(v22[0]) = v7;
      uint64_t image_name = gFunc_axr_logical_image_list_get_image_name(a1, v4, v7);
      MEMORY[0x18C11BE10](&v24[1], image_name);
      gFunc_axr_logical_image_list_get_image_info(&v18, a1, v4, v7, 1);
      *(_OWORD *)((char *)&v27[2] + 8) = v20;
      *(_OWORD *)((char *)&v27[3] + 8) = v21;
      *(_OWORD *)((char *)v27 + 8) = v18;
      *(_OWORD *)((char *)&v27[1] + 8) = v19;
      if (!v19) {
        goto LABEL_8;
      }
      if (v19 != 1) {
        break;
      }
      LOWORD(v22[0]) = 16;
LABEL_10:
      MEMORY[0x18C11BE10](__p, "");
      for (uint64_t i = 32; i != -1; --i)
      {
        if ((*((void *)&v27[0] + 1) >> i))
        {
          uint64_t v11 = "";
          if (i <= 0x11) {
            uint64_t v11 = off_1E53CC9E0[i];
          }
          std::string::append((std::string *)__p, v11);
        }
      }
      if (LODWORD(v27[3]) <= 3) {
        memset((char *)&v27[3] + 4 * LODWORD(v27[3]) + 4, 255, 4 * (3 - LODWORD(v27[3])) + 4);
      }
      CFAllocatorRef v12 = (void *)BYTE7(v27[0]);
      if (SBYTE7(v27[0]) < 0) {
        CFAllocatorRef v12 = __p[1];
      }
      if (v12) {
        std::string::append((std::string *)__p, " ");
      }
      unint64_t v13 = a2[1];
      if (v13 >= a2[2])
      {
        uint64_t v14 = std::vector<EXRPluginData>::__push_back_slow_path<EXRPluginData const&>(a2, v22);
      }
      else
      {
        std::allocator<EXRPluginData>::construct[abi:ne180100]<EXRPluginData,EXRPluginData const&>((uint64_t)(a2 + 2), a2[1], v22);
        uint64_t v14 = v13 + 168;
        a2[1] = v13 + 168;
      }
      a2[1] = v14;
      BOOL v8 = ++v7 < image_count;
      if (v7 == image_count) {
        goto LABEL_26;
      }
    }
    if (v19 == 2)
    {
LABEL_8:
      LOWORD(v22[0]) = 32;
      goto LABEL_10;
    }
    LogError("UpdateImageInfo", 156, "*** ERROR: unexpected imageInfo.type: %d\n", DWORD2(v27[1]));
    uint64_t v15 = 4294967246;
LABEL_27:
    if (SBYTE7(v27[0]) < 0) {
      operator delete(__p[0]);
    }
    if (SHIBYTE(v25) < 0) {
      operator delete(v24[1]);
    }
    if (SHIBYTE(v24[0]) < 0) {
      operator delete(v23[0]);
    }
    if (!v8)
    {
      if (++v4 == view_count)
      {
        if (a2[1] == *a2) {
          return 4294967246;
        }
        else {
          return v15;
        }
      }
      continue;
    }
    return v15;
  }
}

void sub_1887AE9B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  EXRPluginData::~EXRPluginData((void **)va);
  _Unwind_Resume(a1);
}

void EXRPluginData::~EXRPluginData(void **this)
{
  if (*((char *)this + 103) < 0) {
    operator delete(this[10]);
  }
  if (*((char *)this + 79) < 0) {
    operator delete(this[7]);
  }
  if (*((char *)this + 55) < 0) {
    operator delete(this[4]);
  }
}

uint64_t IIO_Reader_OpenEXR::updatePartInfo(IIO_Reader_OpenEXR *this, IIODictionary *a2, axr_data *a3, EXRPluginData *a4)
{
  gFunc_axr_data_get_part_info(&v40, a3, *((unsigned int *)a4 + 31), 1);
  int v5 = (int)v40;
  int v6 = HIDWORD(v40);
  int v7 = (int)v41;
  int v8 = HIDWORD(v41);
  int v10 = v42;
  int v9 = HIDWORD(v42);
  int v11 = v43;
  unsigned int v20 = v45;
  int v21 = v44;
  float v13 = v46;
  float v12 = v47;
  float v14 = v48;
  float v15 = v49;
  unint64_t v17 = v50;
  unsigned __int8 v16 = v51;
  CFMutableArrayRef v40 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  IIOArray::IIOArray((IIOArray *)&v40);
  IIONumber::IIONumber((IIONumber *)v39, v5);
  IIOArray::addObject(&v40, (uint64_t)v39);
  IIONumber::~IIONumber((IIONumber *)v39);
  IIONumber::IIONumber((IIONumber *)v38, v7);
  IIOArray::addObject(&v40, (uint64_t)v38);
  IIONumber::~IIONumber((IIONumber *)v38);
  IIONumber::IIONumber((IIONumber *)v37, v6);
  IIOArray::addObject(&v40, (uint64_t)v37);
  IIONumber::~IIONumber((IIONumber *)v37);
  IIONumber::IIONumber((IIONumber *)v36, v8);
  IIOArray::addObject(&v40, (uint64_t)v36);
  IIONumber::~IIONumber((IIONumber *)v36);
  IIODictionary::setObjectForKey(a2, v41, "dataWindow");
  CFMutableArrayRef v33 = 0;
  unsigned int v34 = 0;
  uint64_t v35 = 0;
  IIOArray::IIOArray((IIOArray *)&v33);
  IIONumber::IIONumber((IIONumber *)v32, v10);
  IIOArray::addObject(&v33, (uint64_t)v32);
  IIONumber::~IIONumber((IIONumber *)v32);
  IIONumber::IIONumber((IIONumber *)v31, v11);
  IIOArray::addObject(&v33, (uint64_t)v31);
  IIONumber::~IIONumber((IIONumber *)v31);
  IIONumber::IIONumber((IIONumber *)v30, v9);
  IIOArray::addObject(&v33, (uint64_t)v30);
  IIONumber::~IIONumber((IIONumber *)v30);
  IIONumber::IIONumber((IIONumber *)v29, v21);
  IIOArray::addObject(&v33, (uint64_t)v29);
  IIONumber::~IIONumber((IIONumber *)v29);
  IIODictionary::setObjectForKey(a2, v34, "displayWindow");
  name = (const char *)gFunc_axr_compression_get_name(v20);
  IIOString::IIOString((IIOString *)&v26, name);
  IIODictionary::setObjectForKey(a2, v28, "compression");
  IIOString::~IIOString((IIOString *)&v26);
  if (v17 && *v17)
  {
    IIOString::IIOString((IIOString *)&v26, v17);
    IIODictionary::setObjectForKey(a2, v28, "name");
    IIOString::~IIOString((IIOString *)&v26);
  }
  if (v16 && *v16)
  {
    IIOString::IIOString((IIOString *)&v26, v16);
    IIODictionary::setObjectForKey(a2, v28, "view");
    IIOString::~IIOString((IIOString *)&v26);
  }
  IIONumber::IIONumber((IIONumber *)v25, v13);
  IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v25, "AspectRatio");
  IIONumber::~IIONumber((IIONumber *)v25);
  IIONumber::IIONumber((IIONumber *)v24, v15);
  IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v24, "screenWindowWidth");
  IIONumber::~IIONumber((IIONumber *)v24);
  CFMutableArrayRef v26 = 0;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  IIOArray::IIOArray((IIOArray *)&v26);
  IIONumber::IIONumber((IIONumber *)v23, v12);
  IIOArray::addObject(&v26, (uint64_t)v23);
  IIONumber::~IIONumber((IIONumber *)v23);
  IIONumber::IIONumber((IIONumber *)v22, v14);
  IIOArray::addObject(&v26, (uint64_t)v22);
  IIONumber::~IIONumber((IIONumber *)v22);
  IIODictionary::setObjectForKey(a2, v27, "screenWindowCenter");
  IIOArray::~IIOArray((IIOArray *)&v26);
  IIOArray::~IIOArray((IIOArray *)&v33);
  IIOArray::~IIOArray((IIOArray *)&v40);
  return 0;
}

void sub_1887AED94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  IIOString::~IIOString((IIOString *)&a23);
  IIOArray::~IIOArray((IIOArray *)&a38);
  IIOArray::~IIOArray((IIOArray *)(v38 - 256));
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_OpenEXR::updatePropertyInfo(IIO_Reader_OpenEXR *this, IIODictionary *a2, axr_data *a3, EXRPluginData *a4)
{
  uint64_t v5 = *((unsigned int *)a4 + 31);
  uint64_t property_count = gFunc_axr_data_get_property_count(a3, v5);
  if (property_count)
  {
    for (uint64_t i = 0; i != property_count; ++i)
    {
      gFunc_axr_data_get_property(v11, a3, v5, i, 1);
      int v8 = v11[1];
      int v9 = v12;
      _cg_jpeg_mem_term("updatePropertyInfo", 247, "\n[%2d,%2d]:  name: %s\n", v5, i, v11[0]);
      _cg_jpeg_mem_term("updatePropertyInfo", 248, "          type: %s\n", v8);
      _cg_jpeg_mem_term("updatePropertyInfo", 249, "          size: %d\n", v9);
    }
  }
  return 0;
}

uint64_t IIO_Reader_OpenEXR::updateChannelInfo(IIO_Reader_OpenEXR *this, IIODictionary *a2, axr_data *a3, EXRPluginData *a4)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *((unsigned int *)a4 + 31);
  CFMutableArrayRef v28 = 0;
  unsigned __int8 v29 = 0;
  uint64_t v30 = 0;
  IIOArray::IIOArray((IIOArray *)&v28);
  uint64_t channel_count = gFunc_axr_data_get_channel_count(a3, v6);
  if (channel_count)
  {
    for (uint64_t i = 0; i != channel_count; ++i)
    {
      gFunc_axr_data_get_channel_info(&__p, a3, v6, i, 1);
      uint64_t v9 = (int)__p;
      int v10 = v32[0];
      memcpy(__dst, (char *)v32 + 4, sizeof(__dst));
      int v11 = operator new(0x108uLL);
      __p = v11;
      v32[0] = xmmword_1889AC510;
      long long v12 = *(_OWORD *)&__dst[55];
      v11[12] = *(_OWORD *)&__dst[51];
      v11[13] = v12;
      long long v13 = *(_OWORD *)&__dst[63];
      v11[14] = *(_OWORD *)&__dst[59];
      v11[15] = v13;
      long long v14 = *(_OWORD *)&__dst[39];
      v11[8] = *(_OWORD *)&__dst[35];
      v11[9] = v14;
      long long v15 = *(_OWORD *)&__dst[47];
      v11[10] = *(_OWORD *)&__dst[43];
      v11[11] = v15;
      long long v16 = *(_OWORD *)&__dst[23];
      v11[4] = *(_OWORD *)&__dst[19];
      v11[5] = v16;
      long long v17 = *(_OWORD *)&__dst[31];
      _OWORD v11[6] = *(_OWORD *)&__dst[27];
      v11[7] = v17;
      long long v18 = *(_OWORD *)&__dst[7];
      _OWORD *v11 = *(_OWORD *)&__dst[3];
      v11[1] = v18;
      long long v19 = *(_OWORD *)&__dst[15];
      v11[2] = *(_OWORD *)&__dst[11];
      void v11[3] = v19;
      *((unsigned char *)v11 + 256) = 0;
      uint64_t v25 = 0;
      CFMutableArrayRef v26 = 0;
      uint64_t v27 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v25);
      if (v32[0] >= 0) {
        p_p = (const char *)&__p;
      }
      else {
        p_p = (const char *)__p;
      }
      IIOString::IIOString((IIOString *)v23, p_p);
      IIODictionary::setObjectForKey((IIODictionary *)&v25, v24, "name");
      IIOString::~IIOString((IIOString *)v23);
      if (v9 < 3) {
        IIODictionary::setObjectForKey((IIODictionary *)&v25, off_1E53CCA70[v9], @"channels");
      }
      IIONumber::IIONumber((IIONumber *)v23, v10);
      IIODictionary::setObjectForKey((IIODictionary *)&v25, v24, "bits");
      IIONumber::~IIONumber((IIONumber *)v23);
      if (v32[0] >= 0) {
        int v21 = (const char *)&__p;
      }
      else {
        int v21 = (const char *)__p;
      }
      IIOString::IIOString((IIOString *)v23, v21);
      IIODictionary::setObjectForKey((IIODictionary *)&v25, v24, "name");
      IIOString::~IIOString((IIOString *)v23);
      IIOArray::addObject(&v28, v26);
      IIODictionary::~IIODictionary((IIODictionary *)&v25);
      if (SHIBYTE(v32[0]) < 0) {
        operator delete(__p);
      }
    }
  }
  IIODictionary::setObjectForKey(a2, v29, "channels");
  IIOArray::~IIOArray((IIOArray *)&v28);
  return 0;
}

void sub_1887AF218(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
}

uint64_t IIO_Reader_OpenEXR::updateSourceProperties(IIO_Reader_OpenEXR *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  if (!AppleEXREnabled()) {
    return 0;
  }
  long long v52 = 0;
  uint64_t v9 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v52, 1);
  CFStringRef Size = IIOImageReadSession::getSize(a2);
  uint64_t v51 = 0;
  int v11 = (void *)gFunc_axr_data_create(v9, Size, &v51, 0, 0);
  if (v51)
  {
    name = (const char *)gFunc_axr_error_get_name();
    LogError("updateSourceProperties", 313, "*** axr_data_create failed: %s (%d)\n", name, v51);
  }
  if (v11)
  {
    uint64_t logical_image_list = gFunc_axr_data_create_logical_image_list(v11);
    if (logical_image_list)
    {
      uint64_t v48 = 0;
      uint64_t v49 = 0;
      uint64_t v50 = 0;
      uint64_t updated = IIO_Reader_OpenEXR::UpdateImageInfo(logical_image_list, &v48);
      if (!updated)
      {
        uint64_t v45 = 0;
        float v46 = 0;
        uint64_t v47 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v45);
        IIONumber::IIONumber((IIONumber *)v44, 1022611261 * ((unint64_t)(v49 - v48) >> 3));
        IIODictionary::setObjectForKey((uint64_t)&v45, (uint64_t)v44, "ImageCount");
        uint64_t v32 = a3;
        IIONumber::~IIONumber((IIONumber *)v44);
        CFMutableArrayRef v41 = 0;
        uint64_t v42 = 0;
        uint64_t v43 = 0;
        IIOArray::IIOArray((IIOArray *)&v41);
        uint64_t v15 = v48;
        if (v49 != v48)
        {
          uint64_t v16 = 0;
          unsigned int v17 = 1;
          do
          {
            *(_OWORD *)__p = 0u;
            memset(v40, 0, 72);
            memset(v38, 0, sizeof(v38));
            *(_OWORD *)&unsigned char v36[16] = 0u;
            *(_OWORD *)int v37 = 0u;
            *(_OWORD *)uint64_t v36 = 0u;
            uint64_t v18 = v15 + 168 * v16;
            long long v19 = *(_OWORD *)v18;
            *(_OWORD *)&v36[9] = *(_OWORD *)(v18 + 9);
            *(_OWORD *)uint64_t v36 = v19;
            unsigned int v20 = (const std::string::value_type **)(v18 + 32);
            if (*(char *)(v18 + 55) < 0)
            {
              std::string::__init_copy_ctor_external((std::string *)v37, *v20, *(void *)(v15 + 168 * v16 + 40));
            }
            else
            {
              long long v21 = *(_OWORD *)v20;
              v38[0] = *(void **)(v18 + 48);
              *(_OWORD *)int v37 = v21;
            }
            long long v22 = (const std::string::value_type **)(v15 + 168 * v16 + 56);
            if (*(char *)(v18 + 79) < 0)
            {
              std::string::__init_copy_ctor_external((std::string *)&v38[1], *v22, *(void *)(v15 + 168 * v16 + 64));
            }
            else
            {
              long long v23 = *(_OWORD *)v22;
              v38[3] = *(void **)(v15 + 168 * v16 + 72);
              *(_OWORD *)&v38[1] = v23;
            }
            long long v24 = (const std::string::value_type **)(v15 + 168 * v16 + 80);
            if (*(char *)(v18 + 103) < 0)
            {
              std::string::__init_copy_ctor_external((std::string *)__p, *v24, *(void *)(v15 + 168 * v16 + 88));
            }
            else
            {
              long long v25 = *(_OWORD *)v24;
              *(void *)&v40[0] = *(void *)(v15 + 168 * v16 + 96);
              *(_OWORD *)__p = v25;
            }
            uint64_t v26 = v15 + 168 * v16;
            long long v27 = *(_OWORD *)(v26 + 104);
            long long v28 = *(_OWORD *)(v26 + 120);
            long long v29 = *(_OWORD *)(v26 + 152);
            *(_OWORD *)((char *)&v40[2] + 8) = *(_OWORD *)(v26 + 136);
            *(_OWORD *)((char *)&v40[3] + 8) = v29;
            *(_OWORD *)((char *)v40 + 8) = v27;
            *(_OWORD *)((char *)&v40[1] + 8) = v28;
            uint64_t v33 = 0;
            uint64_t v34 = 0;
            uint64_t v35 = 0;
            IIODictionary::IIODictionary((IIODictionary *)&v33);
            (*(void (**)(IIO_Reader_OpenEXR *, uint64_t *, void *, unsigned char *))(*(void *)this + 272))(this, &v33, v11, v36);
            (*(void (**)(IIO_Reader_OpenEXR *, uint64_t *, void *, unsigned char *))(*(void *)this + 280))(this, &v33, v11, v36);
            (*(void (**)(IIO_Reader_OpenEXR *, uint64_t *, void *, unsigned char *))(*(void *)this + 288))(this, &v33, v11, v36);
            IIOArray::addObject(&v41, v34);
            IIODictionary::~IIODictionary((IIODictionary *)&v33);
            if (SBYTE7(v40[0]) < 0) {
              operator delete(__p[0]);
            }
            if (SHIBYTE(v38[3]) < 0) {
              operator delete(v38[1]);
            }
            if (SHIBYTE(v38[0]) < 0) {
              operator delete(v37[0]);
            }
            uint64_t v16 = v17;
            uint64_t v15 = v48;
          }
          while (0xCF3CF3CF3CF3CF3DLL * ((v49 - v48) >> 3) > v17++);
        }
        IIODictionary::setObjectForKey((IIODictionary *)&v45, v42, "Images");
        IIODictionary::setObjectForKey(v32, v46, "{FileContents}");
        IIOArray::~IIOArray((IIOArray *)&v41);
        IIODictionary::~IIODictionary((IIODictionary *)&v45);
        uint64_t updated = 0;
      }
      *(void *)uint64_t v36 = &v48;
      std::vector<EXRPluginData>::__destroy_vector::operator()[abi:ne180100]((void ***)v36);
    }
    else
    {
      uint64_t updated = 0;
    }
    os_release(v11);
  }
  else
  {
    uint64_t updated = 0;
  }
  IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v52);
  return updated;
}

void sub_1887AF6F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v34 - 160));
  a19 = v34 - 136;
  std::vector<EXRPluginData>::__destroy_vector::operator()[abi:ne180100]((void ***)&a19);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_OpenEXR::compareOptions(IIO_Reader_OpenEXR *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  memset(v8, 0, sizeof(v8));
  IIODictionary::IIODictionary((IIODictionary *)v8, a2);
  memset(v7, 0, sizeof(v7));
  IIODictionary::IIODictionary((IIODictionary *)v7, a3);
  BOOL BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v8, @"kCGImageSourceShouldAllowFloat");
  uint64_t v5 = BoolForKey ^ IIODictionary::getBoolForKey((IIODictionary *)v7, @"kCGImageSourceShouldAllowFloat") ^ 1u;
  IIODictionary::~IIODictionary((IIODictionary *)v7);
  IIODictionary::~IIODictionary((IIODictionary *)v8);
  return v5;
}

void sub_1887AF828(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_OpenEXR::hasCustomImageCountProc(IIO_Reader_OpenEXR *this)
{
  return 1;
}

uint64_t IIO_Reader_OpenEXR::hasCustomCompareOptionsProc(IIO_Reader_OpenEXR *this)
{
  return 1;
}

uint64_t IIO_Reader_OpenEXR::hasCustomSourcePropertiesProc(IIO_Reader_OpenEXR *this)
{
  return 1;
}

uint64_t std::vector<EXRPluginData>::__push_back_slow_path<EXRPluginData const&>(uint64_t *a1, long long *a2)
{
  unint64_t v3 = 0xCF3CF3CF3CF3CF3DLL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x186186186186186) {
    std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
  }
  if (0x9E79E79E79E79E7ALL * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0x9E79E79E79E79E7ALL * ((a1[2] - *a1) >> 3);
  }
  if (0xCF3CF3CF3CF3CF3DLL * ((a1[2] - *a1) >> 3) >= 0xC30C30C30C30C3) {
    unint64_t v6 = 0x186186186186186;
  }
  else {
    unint64_t v6 = v4;
  }
  long long v14 = a1 + 2;
  if (v6) {
    int v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<EXRPluginData>>((uint64_t)(a1 + 2), v6);
  }
  else {
    int v7 = 0;
  }
  int v10 = v7;
  int v11 = &v7[168 * v3];
  long long v13 = &v7[168 * v6];
  std::allocator<EXRPluginData>::construct[abi:ne180100]<EXRPluginData,EXRPluginData const&>((uint64_t)(a1 + 2), (uint64_t)v11, a2);
  long long v12 = v11 + 168;
  std::vector<EXRPluginData>::__swap_out_circular_buffer(a1, &v10);
  uint64_t v8 = a1[1];
  std::__split_buffer<EXRPluginData>::~__split_buffer(&v10);
  return v8;
}

void sub_1887AF978(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<EXRPluginData>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

__n128 std::allocator<EXRPluginData>::construct[abi:ne180100]<EXRPluginData,EXRPluginData const&>(uint64_t a1, uint64_t a2, long long *a3)
{
  long long v5 = *a3;
  *(_OWORD *)(a2 + 9) = *(long long *)((char *)a3 + 9);
  *(_OWORD *)a2 = v5;
  unint64_t v6 = (std::string *)(a2 + 32);
  if (*((char *)a3 + 55) < 0)
  {
    std::string::__init_copy_ctor_external(v6, *((const std::string::value_type **)a3 + 4), *((void *)a3 + 5));
  }
  else
  {
    long long v7 = a3[2];
    *(void *)(a2 + 48) = *((void *)a3 + 6);
    *(_OWORD *)&v6->__r_.__value_.__l.__data_ = v7;
  }
  if (*((char *)a3 + 79) < 0)
  {
    std::string::__init_copy_ctor_external((std::string *)(a2 + 56), *((const std::string::value_type **)a3 + 7), *((void *)a3 + 8));
  }
  else
  {
    long long v8 = *(long long *)((char *)a3 + 56);
    *(void *)(a2 + 72) = *((void *)a3 + 9);
    *(_OWORD *)(a2 + 56) = v8;
  }
  uint64_t v9 = (std::string *)(a2 + 80);
  if (*((char *)a3 + 103) < 0)
  {
    std::string::__init_copy_ctor_external(v9, *((const std::string::value_type **)a3 + 10), *((void *)a3 + 11));
  }
  else
  {
    long long v10 = a3[5];
    *(void *)(a2 + 96) = *((void *)a3 + 12);
    *(_OWORD *)&v9->__r_.__value_.__l.__data_ = v10;
  }
  __n128 result = *(__n128 *)((char *)a3 + 104);
  long long v12 = *(long long *)((char *)a3 + 120);
  long long v13 = *(long long *)((char *)a3 + 136);
  *(_OWORD *)(a2 + 152) = *(long long *)((char *)a3 + 152);
  *(_OWORD *)(a2 + 136) = v13;
  *(_OWORD *)(a2 + 120) = v12;
  *(__n128 *)(a2 + 104) = result;
  return result;
}

void sub_1887AFA74(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 79) < 0) {
    operator delete(*v3);
  }
  if (*(char *)(v1 + 55) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<EXRPluginData>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<EXRPluginData>,std::reverse_iterator<EXRPluginData*>,std::reverse_iterator<EXRPluginData*>,std::reverse_iterator<EXRPluginData*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<EXRPluginData>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x186186186186187) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(168 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<EXRPluginData>,std::reverse_iterator<EXRPluginData*>,std::reverse_iterator<EXRPluginData*>,std::reverse_iterator<EXRPluginData*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v21 = a6;
  *((void *)&v21 + 1) = a7;
  long long v20 = v21;
  v18[0] = a1;
  v18[1] = &v20;
  v18[2] = &v21;
  uint64_t v19 = 0;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      long long v10 = *(_OWORD *)(a3 - 168);
      *(_OWORD *)(v9 - 159) = *(_OWORD *)(a3 - 159);
      *(_OWORD *)(v9 - 168) = v10;
      long long v11 = *(_OWORD *)(a3 - 136);
      *(void *)(v9 - 120) = *(void *)(a3 - 120);
      *(_OWORD *)(v9 - 136) = v11;
      *(void *)(a3 - 128) = 0;
      *(void *)(a3 - 120) = 0;
      *(void *)(a3 - 136) = 0;
      long long v12 = *(_OWORD *)(a3 - 112);
      *(void *)(v9 - 96) = *(void *)(a3 - 96);
      *(_OWORD *)(v9 - 112) = v12;
      *(void *)(a3 - 104) = 0;
      *(void *)(a3 - 96) = 0;
      *(void *)(a3 - 112) = 0;
      long long v13 = *(_OWORD *)(a3 - 88);
      *(void *)(v9 - 72) = *(void *)(a3 - 72);
      *(_OWORD *)(v9 - 88) = v13;
      *(void *)(a3 - 88) = 0;
      *(void *)(a3 - 80) = 0;
      *(void *)(a3 - 72) = 0;
      long long v14 = *(_OWORD *)(a3 - 64);
      long long v15 = *(_OWORD *)(a3 - 48);
      long long v16 = *(_OWORD *)(a3 - 16);
      *(_OWORD *)(v9 - 32) = *(_OWORD *)(a3 - 32);
      *(_OWORD *)(v9 - 16) = v16;
      *(_OWORD *)(v9 - 64) = v14;
      *(_OWORD *)(v9 - 48) = v15;
      v9 -= 168;
      v7 -= 168;
      a3 -= 168;
    }
    while (a3 != a5);
    *((void *)&v21 + 1) = v9;
  }
  LOBYTE(v19) = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<EXRPluginData>,std::reverse_iterator<EXRPluginData*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v18);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<EXRPluginData>,std::reverse_iterator<EXRPluginData*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<EXRPluginData>,std::reverse_iterator<EXRPluginData*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<EXRPluginData>,std::reverse_iterator<EXRPluginData*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1 = *(void *)(a1[2] + 8);
  uint64_t v2 = *(void *)(a1[1] + 8);
  if (v1 != v2)
  {
    uint64_t v3 = *a1;
    do
    {
      std::allocator<EXRPluginData>::destroy[abi:ne180100](v3, v1);
      v1 += 168;
    }
    while (v1 != v2);
  }
}

void std::allocator<EXRPluginData>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 103) < 0) {
    operator delete(*(void **)(a2 + 80));
  }
  if (*(char *)(a2 + 79) < 0) {
    operator delete(*(void **)(a2 + 56));
  }
  if (*(char *)(a2 + 55) < 0)
  {
    uint64_t v3 = *(void **)(a2 + 32);
    operator delete(v3);
  }
}

void **std::__split_buffer<EXRPluginData>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<EXRPluginData>::clear[abi:ne180100](void *a1)
{
  uint64_t v2 = a1[1];
  for (uint64_t i = a1[2]; i != v2; uint64_t i = a1[2])
  {
    uint64_t v4 = a1[4];
    a1[2] = i - 168;
    std::allocator<EXRPluginData>::destroy[abi:ne180100](v4, i - 168);
  }
}

void std::vector<EXRPluginData>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 168;
        std::allocator<EXRPluginData>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void IIO_Writer_PDF::~IIO_Writer_PDF(IIO_Writer_PDF *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIO_Writer_PDF::write(IIO_Writer_PDF *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  memset(v5, 0, sizeof(v5));
  PDFWritePlugin::PDFWritePlugin((PDFWritePlugin *)v5, a2, a3);
  PDFWritePlugin::setup((PDFWritePlugin *)v5);
  uint64_t v3 = IIOWritePlugin::writeAll((IIOImageDestination **)v5);
  PDFWritePlugin::done((CGContextRef *)v5);
  PDFWritePlugin::~PDFWritePlugin((PDFWritePlugin *)v5);
  return v3;
}

void sub_1887AFF08(void *a1)
{
}

uint64_t png_do_invert(uint64_t result, unsigned char *a2)
{
  if (*(unsigned char *)(result + 16) == 4)
  {
    int v3 = *(unsigned __int8 *)(result + 17);
    if (v3 == 16)
    {
      unint64_t v6 = *(void *)(result + 8);
      if (v6)
      {
        for (unint64_t i = 0; i < v6; i += 4)
        {
          uint64_t v8 = &a2[i];
          *uint64_t v8 = ~a2[i];
          v8[1] = ~a2[i + 1];
        }
      }
    }
    else if (v3 == 8)
    {
      unint64_t v4 = *(void *)(result + 8);
      if (v4)
      {
        for (unint64_t j = 0; j < v4; j += 2)
          a2[j] = ~a2[j];
      }
    }
  }
  else if (!*(unsigned char *)(result + 16))
  {
    for (uint64_t k = *(void *)(result + 8); k; --k)
    {
      *a2 = ~*a2;
      ++a2;
    }
  }
  return result;
}

uint64_t png_do_packswap(uint64_t result, unsigned char *a2)
{
  unsigned int v2 = *(unsigned __int8 *)(result + 17);
  if (v2 <= 7)
  {
    uint64_t v3 = *(void *)(result + 8);
    switch(v2)
    {
      case 1u:
        unint64_t v4 = &onebppswaptable;
        break;
      case 4u:
        unint64_t v4 = &fourbppswaptable;
        break;
      case 2u:
        unint64_t v4 = &twobppswaptable;
        break;
      default:
        return result;
    }
    if (v3 >= 1)
    {
      uint64_t v5 = &a2[v3];
      do
      {
        *a2 = v4[*a2];
        ++a2;
      }
      while (a2 < v5);
    }
  }
  return result;
}

uint64_t png_do_strip_channel(uint64_t result, unsigned char *a2, int a3)
{
  uint64_t v3 = *(void *)(result + 8);
  unint64_t v4 = (unint64_t)&a2[v3];
  int v5 = *(unsigned __int8 *)(result + 18);
  if (v5 == 4)
  {
    int v10 = *(unsigned __int8 *)(result + 17);
    if (v10 == 16)
    {
      uint64_t v17 = 8;
      if (a3) {
        uint64_t v17 = 2;
      }
      uint64_t v18 = 6;
      if (a3) {
        uint64_t v18 = 0;
      }
      uint64_t v8 = &a2[v18];
      if (v17 < v3)
      {
        uint64_t v19 = &a2[v17];
        do
        {
          *uint64_t v8 = *v19;
          v8[1] = v19[1];
          v8[2] = v19[2];
          void v8[3] = v19[3];
          v8[4] = v19[4];
          v8[5] = v19[5];
          v8 += 6;
          v19 += 8;
        }
        while ((unint64_t)v19 < v4);
      }
      char v14 = 48;
    }
    else
    {
      if (v10 != 8) {
        return result;
      }
      if (a3) {
        uint64_t v11 = 1;
      }
      else {
        uint64_t v11 = 4;
      }
      uint64_t v12 = 3;
      if (a3) {
        uint64_t v12 = 0;
      }
      uint64_t v8 = &a2[v12];
      if (v11 < v3)
      {
        long long v13 = &a2[v11];
        do
        {
          *uint64_t v8 = *v13;
          v8[1] = v13[1];
          v8[2] = v13[2];
          v8 += 3;
          v13 += 4;
        }
        while ((unint64_t)v13 < v4);
      }
      char v14 = 24;
    }
    *(unsigned char *)(result + 19) = v14;
    *(unsigned char *)(result + 18) = 3;
    if (*(unsigned char *)(result + 16) == 6) {
      *(unsigned char *)(result + 16) = 2;
    }
  }
  else
  {
    if (v5 != 2) {
      return result;
    }
    int v6 = *(unsigned __int8 *)(result + 17);
    if (v6 == 16)
    {
      long long v15 = a2 + 4;
      if (a3)
      {
        long long v15 = a2 + 2;
        long long v16 = a2;
      }
      else
      {
        long long v16 = a2 + 2;
      }
      if ((unint64_t)v15 >= v4)
      {
        uint64_t v8 = v16;
      }
      else
      {
        do
        {
          unsigned char *v16 = *v15;
          uint64_t v8 = v16 + 2;
          v16[1] = v15[1];
          v15 += 4;
          v16 += 2;
        }
        while ((unint64_t)v15 < v4);
      }
    }
    else
    {
      if (v6 != 8) {
        return result;
      }
      if (a3) {
        uint64_t v7 = a2 + 1;
      }
      else {
        uint64_t v7 = a2 + 2;
      }
      if (a3) {
        uint64_t v8 = a2;
      }
      else {
        uint64_t v8 = a2 + 1;
      }
      while ((unint64_t)v7 < v4)
      {
        char v9 = *v7;
        v7 += 2;
        *v8++ = v9;
      }
    }
    *(unsigned char *)(result + 19) = v6;
    *(unsigned char *)(result + 18) = 1;
    if (*(unsigned char *)(result + 16) == 4) {
      *(unsigned char *)(result + 16) = 0;
    }
  }
  *(void *)(result + 8) = v8 - a2;
  return result;
}

int *png_do_bgr(int *result, __int16 *a2)
{
  int v2 = *((unsigned __int8 *)result + 16);
  if ((v2 & 2) != 0)
  {
    int v3 = *result;
    int v4 = *((unsigned __int8 *)result + 17);
    if (v4 == 16)
    {
      if (v2 == 2)
      {
        for (; v3; --v3)
        {
          __int16 v9 = *a2;
          *a2 = a2[2];
          a2[2] = v9;
          a2 += 3;
        }
      }
      else if (v2 == 6 && v3 != 0)
      {
        do
        {
          __int16 v7 = *a2;
          *a2 = a2[2];
          a2[2] = v7;
          a2 += 4;
          --v3;
        }
        while (v3);
      }
    }
    else if (v4 == 8)
    {
      if (v2 == 2)
      {
        for (; v3; --v3)
        {
          char v8 = *(unsigned char *)a2;
          *(unsigned char *)a2 = *((unsigned char *)a2 + 2);
          *((unsigned char *)a2 + 2) = v8;
          a2 = (__int16 *)((char *)a2 + 3);
        }
      }
      else if (v2 == 6 && v3)
      {
        do
        {
          char v5 = *(unsigned char *)a2;
          *(unsigned char *)a2 = *((unsigned char *)a2 + 2);
          *((unsigned char *)a2 + 2) = v5;
          a2 += 2;
          --v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t png_do_check_palette_indexes(uint64_t result, uint64_t a2)
{
  int v2 = *(unsigned __int8 *)(a2 + 17);
  if (*(_WORD *)(result + 376)) {
    BOOL v3 = 1 << v2 <= *(unsigned __int16 *)(result + 376);
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    int v4 = v2 - 1;
    int v5 = -(*(_DWORD *)a2 * *(unsigned __int8 *)(a2 + 19)) & 7;
    unint64_t v6 = *(void *)(result + 328);
    uint64_t v7 = *(void *)(a2 + 8);
    char v8 = (unsigned __int8 *)(v6 + v7);
    switch(v4)
    {
      case 0:
        if (v7 >= 1)
        {
          do
          {
            if (*v8 >> v5) {
              *(_DWORD *)(result + 380) = 1;
            }
            LOBYTE(v5) = 0;
            --v8;
          }
          while ((unint64_t)v8 > v6);
        }
        break;
      case 1:
        if (v7 >= 1)
        {
          int v9 = *(_DWORD *)(result + 380);
          do
          {
            int v10 = v9;
            unsigned int v11 = *v8 >> v5;
            int v12 = v11 & 3;
            if (v12 <= v9) {
              unsigned int v13 = v9;
            }
            else {
              unsigned int v13 = v11 & 3;
            }
            unsigned int v14 = (v11 >> 2) & 3;
            if (v14 <= v13) {
              unsigned int v15 = v13;
            }
            else {
              unsigned int v15 = (v11 >> 2) & 3;
            }
            unsigned int v16 = (v11 >> 4) & 3;
            if (v16 <= v15) {
              unsigned int v17 = v15;
            }
            else {
              unsigned int v17 = (v11 >> 4) & 3;
            }
            unsigned int v18 = v11 >> 6;
            if (v18 <= v17) {
              int v9 = v17;
            }
            else {
              int v9 = v18;
            }
            if (v12 > v10 || v14 > v13 || v16 > v15 || v18 > v17) {
              *(_DWORD *)(result + 380) = v9;
            }
            LOBYTE(v5) = 0;
            --v8;
          }
          while ((unint64_t)v8 > v6);
        }
        break;
      case 3:
        if (v7 >= 1)
        {
          int v22 = *(_DWORD *)(result + 380);
          do
          {
            int v23 = v22;
            unsigned int v24 = *v8 >> v5;
            int v25 = v24 & 0xF;
            if (v25 <= v22) {
              unsigned int v26 = v22;
            }
            else {
              unsigned int v26 = v24 & 0xF;
            }
            unsigned int v27 = v24 >> 4;
            if (v27 <= v26) {
              int v22 = v26;
            }
            else {
              int v22 = v27;
            }
            if (v25 > v23 || v27 > v26) {
              *(_DWORD *)(result + 380) = v22;
            }
            LOBYTE(v5) = 0;
            --v8;
          }
          while ((unint64_t)v8 > v6);
        }
        break;
      case 7:
        if (v7 >= 1)
        {
          int v29 = *(_DWORD *)(result + 380);
          do
          {
            int v30 = *v8;
            if (v29 < v30)
            {
              *(_DWORD *)(result + 380) = v30;
              int v29 = v30;
            }
            --v8;
          }
          while ((unint64_t)v8 > v6);
        }
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t _cg_png_get_current_row_number(uint64_t a1)
{
  if (a1) {
    return *(unsigned int *)(a1 + 308);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t mj2_video_source::get_track_idx(mj2_video_source *this)
{
  return *(unsigned int *)(**((void **)this + 1) + 16);
}

uint64_t mj2_video_source::get_graphics_mode(mj2_video_source *this)
{
  return *(__int16 *)(*(void *)(**((void **)this + 1) + 40) + 8);
}

uint64_t mj2_video_source::access_dimensions(mj2_video_source *this)
{
  return jp2_header::access_dimensions((jp2_header *)(*((void *)this + 1) + 40));
}

uint64_t mj2_video_source::access_colour(mj2_video_source *this)
{
  return jp2_header::access_colour((jp2_header *)(*((void *)this + 1) + 40));
}

uint64_t mj2_video_source::access_palette(mj2_video_source *this)
{
  return jp2_header::access_palette((jp2_header *)(*((void *)this + 1) + 40));
}

uint64_t mj2_video_source::access_channels(mj2_video_source *this)
{
  return jp2_header::access_channels((jp2_header *)(*((void *)this + 1) + 40));
}

uint64_t mj2_video_source::get_stream_idx(mj2_video_source *this, int a2)
{
  int v2 = (_DWORD *)*((void *)this + 1);
  int v3 = v2[170];
  if (v3 < 0)
  {
    uint64_t v8 = *(void *)(*(void *)v2 + 8);
    if (!v8) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v9 = *(void *)(v8 + 104);
    if (!v9) {
      return 0xFFFFFFFFLL;
    }
    int v10 = 0;
    do
    {
      uint64_t v11 = *(void *)(v9 + 40);
      if (v11 && (*(_DWORD *)(v11 + 680) & 0x80000000) != 0)
      {
        *(_DWORD *)(v11 + 680) = v10;
        v10 += *(_DWORD *)(v11 + 676);
      }
      uint64_t v9 = *(void *)(v9 + 24);
    }
    while (v9);
    int v3 = v2[170];
    if (v3 < 0) {
      return 0xFFFFFFFFLL;
    }
  }
  uint64_t result = 0xFFFFFFFFLL;
  if ((a2 & 0x80000000) == 0)
  {
    unsigned int v5 = v2[22];
    if (v5 < v2[16])
    {
      int v6 = v2[17];
      if (v6 > a2)
      {
        int v7 = a2 + v6 * v5;
        if (v7 >= v2[169]) {
          mj2_video_source::get_stream_idx();
        }
        return (v7 + v3);
      }
    }
  }
  return result;
}

uint64_t mj2_source::count_codestreams(mj2_source *this, int *a2)
{
  *a2 = 0;
  if (*(void *)this)
  {
    uint64_t v2 = *(void *)(*(void *)this + 104);
    if (v2)
    {
      int v3 = 0;
      do
      {
        uint64_t v4 = *(void *)(v2 + 40);
        if (v4 && (*(_DWORD *)(v4 + 680) & 0x80000000) != 0)
        {
          *(_DWORD *)(v4 + 680) = v3;
          int v3 = *a2 + *(_DWORD *)(v4 + 676);
          *a2 = v3;
        }
        uint64_t v2 = *(void *)(v2 + 24);
      }
      while (v2);
    }
  }
  return 1;
}

BOOL mj2_video_source::can_open_stream(mj2_video_source *this, int a2)
{
  BOOL result = 0;
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v4 = (_DWORD *)*((void *)this + 1);
    if (v4[22] < v4[16]) {
      return v4[17] > a2;
    }
  }
  return result;
}

uint64_t mj2_source::get_track_type(mj2_source *this, int a2)
{
  if (!*(void *)this) {
    mj2_source::get_track_type();
  }
  uint64_t v2 = *(void *)(*(void *)this + 104);
  if (!v2) {
    return 0;
  }
  while (*(_DWORD *)(v2 + 16) != a2)
  {
    uint64_t v2 = *(void *)(v2 + 24);
    if (!v2) {
      return 0;
    }
  }
  if (*(void *)(v2 + 40)) {
    return 1;
  }
  else {
    return 1000;
  }
}

uint64_t mj2_source::access_video_track(mj2_source *this, int a2)
{
  if (!*(void *)this) {
    mj2_source::access_video_track();
  }
  uint64_t v2 = *(void *)(*(void *)this + 104);
  if (!v2) {
    return 0;
  }
  while (*(_DWORD *)(v2 + 16) != a2)
  {
    uint64_t v2 = *(void *)(v2 + 24);
    if (!v2) {
      return 0;
    }
  }
  uint64_t v3 = *(void *)(v2 + 40);
  if (v3) {
    return *(void *)(v3 + 56);
  }
  else {
    return 0;
  }
}

uint64_t mj2_source::find_stream(mj2_source *this, int a2, unsigned int *a3, int *a4, int *a5)
{
  if (*(void *)this)
  {
    int v19 = 0;
    mj2_source::count_codestreams(this, &v19);
    uint64_t v10 = *(void *)(*(void *)this + 104);
    if (!v10)
    {
LABEL_8:
      *a3 = 0;
      *a5 = 0;
      uint64_t result = 1;
      *a4 = 0;
      return result;
    }
    while (1)
    {
      uint64_t v11 = *(_DWORD **)(v10 + 40);
      if (v11)
      {
        int v12 = v11[170];
        if (v12 < 0) {
          return 0;
        }
        int v13 = a2 - v12;
        if (v13 >= 0 && v13 < v11[169]) {
          break;
        }
      }
      uint64_t v10 = *(void *)(v10 + 24);
      if (!v10) {
        goto LABEL_8;
      }
    }
    *a3 = *(_DWORD *)(v10 + 16);
    int v15 = v11[168];
    BOOL v16 = v15 == 0;
    int v17 = v13 & 1;
    int v18 = v13 >> (v15 != 0);
    if (v16) {
      int v17 = 0;
    }
    *a4 = v18;
    *a5 = v17;
  }
  return 1;
}

void sub_1887B07F8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40910A7DF9);
  _Unwind_Resume(a1);
}

CGMutableImageMetadataRef CGImageMetadataCreateFromXPCObj(void *a1)
{
  if (!a1) {
    return 0;
  }
  CFDictionaryRef v3 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(a1, (const char *)IIO_METADATA_OBJ);
  if (v3)
  {
    CFDictionaryRef v4 = v3;
    memset(v18, 0, sizeof(v18));
    IIODictionary::IIODictionary((IIODictionary *)v18, v3);
    CGMutableImageMetadataRef Mutable = CGImageMetadataCreateMutable();
    memset(v17, 0, sizeof(v17));
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v18, @"tags");
    IIOArray::IIOArray((IIOArray *)v17, ObjectForKey);
    uint64_t v19 = MEMORY[0x1E4F143A8];
    CFTypeRef cf = (CFTypeRef)0x40000000;
    long long v21 = ___ZL24IIOXPCDecodeMetadataTagsP8IIOArrayP15CGImageMetadata_block_invoke;
    int v22 = &__block_descriptor_tmp_343;
    CGMutableImageMetadataRef v23 = Mutable;
    IIOArray::enumerate((uint64_t)v17, (uint64_t)&v19);
    if (IIODictionary::containsKey((IIODictionary *)v18, @"makerNoteProps"))
    {
      CFDictionaryRef v6 = IIODictionary::getObjectForKey((IIODictionary *)v18, @"makerNoteProps");
      *((void *)Mutable + 6) = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v6);
    }
    if (IIODictionary::containsKey((IIODictionary *)v18, @"NStoPrefix"))
    {
      CFDictionaryRef v7 = IIODictionary::getObjectForKey((IIODictionary *)v18, @"NStoPrefix");
      *((void *)Mutable + 4) = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v7);
    }
    if (IIODictionary::containsKey((IIODictionary *)v18, @"prefixToNS"))
    {
      CFDictionaryRef v8 = IIODictionary::getObjectForKey((IIODictionary *)v18, @"prefixToNS");
      *((void *)Mutable + 5) = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v8);
    }
    if (IIODictionary::containsKey((IIODictionary *)v18, @"iptcComputedDigest"))
    {
      CFDictionaryRef v9 = IIODictionary::getObjectForKey((IIODictionary *)v18, @"iptcComputedDigest");
      *((void *)Mutable + 7) = CFRetain(v9);
    }
    if (IIODictionary::containsKey((IIODictionary *)v18, @"iptcPSIRDigest"))
    {
      CFDictionaryRef v10 = IIODictionary::getObjectForKey((IIODictionary *)v18, @"iptcPSIRDigest");
      *((void *)Mutable + 8) = CFRetain(v10);
    }
    *((unsigned char *)Mutable + 16) = IIODictionary::getBoolForKey((IIODictionary *)v18, @"mutable");
    CFRelease(v4);
    IIOArray::~IIOArray((IIOArray *)v17);
    IIODictionary::~IIODictionary((IIODictionary *)v18);
  }
  else
  {
    _cg_jpeg_mem_term("CGImageMetadataCreateFromXPCObj", 279, "*** NOTE: failed to get metadata-dictionary from xpc_object_t - decoding XMPData...\n");
    BOOL v12 = xpc_dictionary_get_BOOL(a1, (const char *)IIO_METADATA_MUTABLE);
    if (!xpc_dictionary_get_value(a1, (const char *)IIO_METADATA_OBJ_ORIG)) {
      return 0;
    }
    CFDataRef v13 = (const __CFData *)_CFXPCCreateCFObjectFromXPCObject();
    if (!v13) {
      return 0;
    }
    CFDataRef v14 = v13;
    CGMutableImageMetadataRef Mutable = CGImageMetadataCreateFromXMPData(v13);
    if (Mutable)
    {
      CFDictionaryRef v15 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(a1, (const char *)IIO_METADATA_MAKER_ORIG);
      if (v15)
      {
        CFDictionaryRef v16 = v15;
        uint64_t v19 = 0;
        CFTypeRef cf = 0;
        long long v21 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v19, v15, 1);
        *((void *)Mutable + 6) = CFRetain(cf);
        CFRelease(v16);
        IIODictionary::~IIODictionary((IIODictionary *)&v19);
      }
      *((unsigned char *)Mutable + 16) = v12;
    }
    CFRelease(v14);
  }
  return Mutable;
}

void sub_1887B0AFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

xpc_object_t CGImageMetadataCreateXPCObj(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID((CFTypeRef)a1);
  if (v2 != CGImageMetadataGetTypeID()) {
    return 0;
  }
  emptCGFloat y = xpc_dictionary_create_empty();
  if (empty)
  {
    memset(v15, 0, sizeof(v15));
    IIODictionary::IIODictionary((IIODictionary *)v15);
    CFDictionaryRef v4 = (const void **)MEMORY[0x1E4F1CFD0];
    if (!*(unsigned char *)(a1 + 16)) {
      CFDictionaryRef v4 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    IIODictionary::setObjectForKey((IIODictionary *)v15, *v4, @"mutable");
    uint64_t v12 = 0;
    xpc_object_t value = 0;
    uint64_t v14 = 0;
    IIOArray::IIOArray((IIOArray *)&v12);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___ZL24IIOXPCEncodeMetadataTagsPK15CGImageMetadataP8IIOArray_block_invoke;
    block[3] = &__block_descriptor_tmp_372;
    block[4] = &v12;
    CGImageMetadataEnumerateTagsUsingBlock((CGImageMetadataRef)a1, 0, 0, block);
    IIODictionary::setObjectForKey((IIODictionary *)v15, value, @"tags");
    unsigned int v5 = *(const void **)(a1 + 32);
    if (v5) {
      IIODictionary::setObjectForKey((IIODictionary *)v15, v5, @"NStoPrefix");
    }
    CFDictionaryRef v6 = *(const void **)(a1 + 40);
    if (v6) {
      IIODictionary::setObjectForKey((IIODictionary *)v15, v6, @"prefixToNS");
    }
    CFDictionaryRef v7 = *(const void **)(a1 + 48);
    if (v7) {
      IIODictionary::setObjectForKey((IIODictionary *)v15, v7, @"makerNoteProps");
    }
    CFDictionaryRef v8 = *(const void **)(a1 + 56);
    if (v8) {
      IIODictionary::setObjectForKey((IIODictionary *)v15, v8, @"iptcComputedDigest");
    }
    CFDictionaryRef v9 = *(const void **)(a1 + 64);
    if (v9) {
      IIODictionary::setObjectForKey((IIODictionary *)v15, v9, @"iptcPSIRDigest");
    }
    if (iio_xpc_dictionary_add_CFDictionary(empty, (const char *)IIO_METADATA_OBJ))
    {
      _cg_jpeg_mem_term("CGImageMetadataCreateXPCObj", 346, "*** NOTE: failed to add metadata-dictionary to xpc_object_t - sending XMPData...\n");
      xpc_dictionary_set_BOOL(empty, (const char *)IIO_METADATA_MUTABLE, *(unsigned char *)(a1 + 16));
      CFDataRef XMPData = CGImageMetadataCreateXMPData((CGImageMetadataRef)a1, 0);
      if (XMPData)
      {
        iio_xpc_dictionary_add_CFData(empty, (const char *)IIO_METADATA_OBJ_ORIG, XMPData);
        CFRelease(XMPData);
      }
      if (*(void *)(a1 + 48)) {
        iio_xpc_dictionary_add_CFDictionary(empty, (const char *)IIO_METADATA_MAKER_ORIG);
      }
    }
    IIOArray::~IIOArray((IIOArray *)&v12);
    IIODictionary::~IIODictionary((IIODictionary *)v15);
  }
  return empty;
}

void sub_1887B0D68(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  IIOArray::~IIOArray((IIOArray *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

__CFArray *CreateArrayFromCFValue(const __CFString *a1, int a2)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFArrayGetTypeID())
  {
    CGMutableImageMetadataRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
    if (Mutable)
    {
      CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
      if (Count >= 1)
      {
        CFIndex v7 = Count;
        for (CFIndex i = 0; i != v7; ++i)
        {
          ValueAtIndeCGFloat x = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a1, i);
          CFTypeID v10 = CFGetTypeID(ValueAtIndex);
          if (v10 == CFNumberGetTypeID()
            && (SimpleStringFromCFCFDataRef Value = CGImageMetadataCreateSimpleStringFromCFValue(ValueAtIndex, 4)) != 0)
          {
            CFStringRef v12 = SimpleStringFromCFValue;
            CFArrayAppendValue(Mutable, SimpleStringFromCFValue);
            CFRelease(v12);
          }
          else if (ValueAtIndex)
          {
            CFArrayAppendValue(Mutable, ValueAtIndex);
          }
        }
      }
    }
    return Mutable;
  }
  CFTypeID v13 = CFGetTypeID(a1);
  if (v13 != CFStringGetTypeID()) {
    return 0;
  }
  CFAllocatorRef v14 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if (a2 == 13)
  {
    CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, @"; ");
    if (ArrayBySeparatingStrings)
    {
      CFArrayRef v16 = ArrayBySeparatingStrings;
      CFIndex v17 = CFArrayGetCount(ArrayBySeparatingStrings);
      CGMutableImageMetadataRef Mutable = CFArrayCreateMutableCopy(v14, v17, v16);
      CFRelease(v16);
      return Mutable;
    }
    LogMetadata("CreateArrayFromCFValue", 2900, "Could not create array from kLegacyTypeSemicolonString value\n");
    return 0;
  }
  int v18 = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CGMutableImageMetadataRef Mutable = v18;
  if (v18) {
    CFArrayAppendValue(v18, a1);
  }
  return Mutable;
}

__CFDictionary *CreateStructureFromCFValue(const void *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFDictionaryGetTypeID()) {
    return 0;
  }
  CFIndex Count = CFDictionaryGetCount((CFDictionaryRef)a1);
  if (Count < 1) {
    return 0;
  }
  CFIndex v4 = Count;
  CGMutableImageMetadataRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    uint64_t v6 = (const void **)malloc_type_malloc(8 * v4, 0x6004044C4A2DFuLL);
    CFDictionaryGetKeysAndValues((CFDictionaryRef)a1, v6, 0);
    for (uint64_t i = 0; i != v4; ++i)
    {
      CFDictionaryRef v8 = v6[i];
      CFDataRef Value = CFDictionaryGetValue((CFDictionaryRef)a1, v8);
      CFDictionaryAddValue(Mutable, v8, Value);
    }
    free(v6);
  }
  return Mutable;
}

__CFString *CreateShortXMPDateFromIPTCDate(const __CFString *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFStringGetTypeID()) {
    return 0;
  }
  CFIndex Length = CFStringGetLength(a1);
  if (Length == 8)
  {
    CGMutableImageMetadataRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 10);
    uint64_t v5 = Mutable;
    if (Mutable)
    {
      CFStringAppend(Mutable, a1);
      CFStringInsert(v5, 4, @"-");
      CFStringInsert(v5, 7, @"-");
    }
    return v5;
  }
  if (Length != 10) {
    return 0;
  }

  return (__CFString *)CFRetain(a1);
}

__CFString *CreateXMPDateFromIPTCDateAndTime(const __CFString *a1, const __CFString *a2)
{
  unsigned int v24 = 0;
  unsigned int v23 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v20 = 0;
  if (a1 && (CFTypeID v4 = CFGetTypeID(a1), v4 == CFStringGetTypeID()))
  {
    CFIndex v5 = CFStringGetLength(a1) + 1;
    uint64_t v6 = (__CFString *)malloc_type_malloc(v5, 0xC7F6DA59uLL);
    if (!v6) {
      return v6;
    }
    if (!CFStringGetCString(a1, (char *)v6, v5, 0x600u))
    {
LABEL_32:
      free(v6);
      return 0;
    }
    BOOL v7 = sscanf((const char *)v6, "%04d%02d%02d", &v24, &v23, (char *)&v22 + 4) == 3;
    free(v6);
    if (!a2) {
      goto LABEL_14;
    }
  }
  else
  {
    BOOL v7 = 0;
    if (!a2)
    {
LABEL_14:
      int v10 = 0;
      BOOL v11 = 0;
      goto LABEL_20;
    }
  }
  CFTypeID v8 = CFGetTypeID(a2);
  if (v8 != CFStringGetTypeID())
  {
    LODWORD(a2) = 0;
    goto LABEL_14;
  }
  CFIndex v9 = CFStringGetLength(a2) + 1;
  uint64_t v6 = (__CFString *)malloc_type_malloc(v9, 0x1D0F1D2EuLL);
  if (!v6) {
    return v6;
  }
  if (!CFStringGetCString(a2, (char *)v6, v9, 0x600u)) {
    goto LABEL_32;
  }
  if (sscanf((const char *)v6, "%02d%02d%02d+%02d%02d", &v22, (char *)&v21 + 4, &v21, (char *)&v20 + 4, &v20) == 5)
  {
    LODWORD(a2) = 0;
  }
  else
  {
    if (sscanf((const char *)v6, "%02d%02d%02d-%02d%02d", &v22, (char *)&v21 + 4, &v21, (char *)&v20 + 4, &v20) != 5)
    {
      LODWORD(a2) = 0;
      int v10 = 0;
      BOOL v11 = sscanf((const char *)v6, "%02d%02d%02d", &v22, (char *)&v21 + 4, &v21) == 3;
      goto LABEL_19;
    }
    LODWORD(a2) = 1;
  }
  int v10 = 1;
  BOOL v11 = 1;
LABEL_19:
  free(v6);
LABEL_20:
  CGMutableImageMetadataRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 19);
  uint64_t v6 = Mutable;
  if (Mutable)
  {
    if (v7) {
      CFStringAppendFormat(Mutable, 0, @"%04d-%02d-%02d", v24, v23, HIDWORD(v22));
    }
    else {
      CFStringAppendFormat(Mutable, 0, @"0000-00-00", v14, v16, v18);
    }
    if (v11) {
      CFStringAppendFormat(v6, 0, @"T%02d:%02d:%02d", v22, HIDWORD(v21), v21);
    }
    else {
      CFStringAppendFormat(v6, 0, @"T00:00:00", v15, v17, v19);
    }
    if (v10)
    {
      if (a2) {
        CFStringAppendFormat(v6, 0, @"-%02d:%02d", HIDWORD(v20), v20);
      }
      else {
        CFStringAppendFormat(v6, 0, @"+%02d:%02d", HIDWORD(v20), v20);
      }
    }
  }
  return v6;
}

CFStringRef CreateMergedXMPDateWithXMPTime(CFStringRef result, const __CFString *a2)
{
  memset(&v12, 0, sizeof(v12));
  memset(&v11, 0, sizeof(v11));
  *(_WORD *)int v10 = 0;
  if (result)
  {
    CFStringRef v3 = result;
    CFTypeID v4 = CFGetTypeID(result);
    CFTypeID TypeID = CFStringGetTypeID();
    uint64_t result = 0;
    if (a2)
    {
      if (v4 == TypeID)
      {
        CFTypeID v6 = CFGetTypeID(a2);
        if (v6 == CFStringGetTypeID())
        {
          int DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(v3, &v12, 0, 0);
          int v8 = GetDateTimeStructFromXMPDateTimeString(a2, &v11, &v10[1], v10);
          uint64_t result = 0;
          if (DateTimeStructFromXMPDateTimeString && v8)
          {
            if (v10[1])
            {
              if (v10[0])
              {
                LODWORD(v9) = v11.tm_gmtoff % 3600 / 60;
                if ((int)v9 >= 0) {
                  uint64_t v9 = v9;
                }
                else {
                  uint64_t v9 = (v11.tm_gmtoff % 3600 / -60);
                }
                return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%04d-%02d-%02dT%02d:%02d:%02d%+03d:%02d", (v12.tm_year + 1900), (v12.tm_mon + 1), v12.tm_mday, v11.tm_hour, v11.tm_min, v11.tm_sec, v11.tm_gmtoff / 3600, v9);
              }
              else
              {
                return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%04d-%02d-%02dT%02d:%02d:%02d", (v12.tm_year + 1900), (v12.tm_mon + 1), v12.tm_mday, v11.tm_hour, v11.tm_min, v11.tm_sec);
              }
            }
            else
            {
              return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%04d-%02d-%02d", (v12.tm_year + 1900), (v12.tm_mon + 1), v12.tm_mday);
            }
          }
        }
        else
        {
          return 0;
        }
      }
    }
  }
  return result;
}

CFStringRef CreateXMPDateTimeFromEXIFDateTime(const __CFString *cf)
{
  CFStringRef v1 = cf;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  unsigned int v8 = 0;
  unsigned int v7 = 0;
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (v2 == CFStringGetTypeID()
      && (CFIndex v3 = CFStringGetLength(v1) + 1, (v4 = (char *)malloc_type_malloc(v3, 0x120C3F65uLL)) != 0))
    {
      CFIndex v5 = v4;
      if (CFStringGetCString(v1, v4, v3, 0x600u)
        && sscanf(v5, "%04d:%02d:%02d %02d:%02d:%02d", (char *)&v10 + 4, &v10, (char *)&v9 + 4, &v9, &v8, &v7) == 6)
      {
        CFStringRef v1 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%04d-%02d-%02dT%02d:%02d:%02d", HIDWORD(v10), v10, HIDWORD(v9), v9, v8, v7);
      }
      else
      {
        CFStringRef v1 = 0;
      }
      free(v5);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

CFStringRef CreateMetadataVersionStringFromArray(const void *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFArrayGetTypeID()) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
  if (Count < 2) {
    return 0;
  }
  unint64_t v4 = Count;
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  if (!Mutable) {
    return 0;
  }
  unsigned int v7 = Mutable;
  ValueAtIndeCGFloat x = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a1, 0);
  if (!ValueAtIndex) {
    goto LABEL_22;
  }
  CFStringRef v9 = ValueAtIndex;
  CFTypeID v10 = CFGetTypeID(ValueAtIndex);
  if (v10 != CFNumberGetTypeID()) {
    goto LABEL_22;
  }
  SimpleStringFromCFCFDataRef Value = CGImageMetadataCreateSimpleStringFromCFValue(v9, 0);
  if (!SimpleStringFromCFValue) {
    goto LABEL_22;
  }
  CFStringRef v12 = SimpleStringFromCFValue;
  if (CFStringGetLength(SimpleStringFromCFValue) == 1) {
    CFArrayAppendValue(v7, @"0");
  }
  CFArrayAppendValue(v7, v12);
  CFRelease(v12);
  CFStringRef v13 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a1, 1);
  if (!v13) {
    goto LABEL_22;
  }
  CFStringRef v14 = v13;
  CFTypeID v15 = CFGetTypeID(v13);
  if (v15 != CFNumberGetTypeID()) {
    goto LABEL_22;
  }
  CFStringRef v16 = CGImageMetadataCreateSimpleStringFromCFValue(v14, 0);
  if (!v16) {
    goto LABEL_22;
  }
  CFStringRef v17 = v16;
  CFArrayAppendValue(v7, v16);
  CFRelease(v17);
  if (v4 < 3)
  {
    CFArrayAppendValue(v7, @"0");
    goto LABEL_19;
  }
  CFStringRef v18 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)a1, 2);
  if (!v18
    || (CFStringRef v19 = v18, v20 = CFGetTypeID(v18), v20 != CFNumberGetTypeID())
    || (CFStringRef v21 = CGImageMetadataCreateSimpleStringFromCFValue(v19, 0)) == 0)
  {
LABEL_22:
    CFStringRef v23 = 0;
    goto LABEL_20;
  }
  CFStringRef v22 = v21;
  CFArrayAppendValue(v7, v21);
  CFRelease(v22);
LABEL_19:
  CFStringRef v23 = CFStringCreateByCombiningStrings(v5, v7, &stru_1ED4F1F48);
LABEL_20:
  CFRelease(v7);
  return v23;
}

CFArrayRef CreateMetadataLensInfoFromCFValue(const __CFArray *cf, CFIndex *a2)
{
  CFArrayRef v2 = cf;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFArrayGetTypeID()
      && (CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80],
          (CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510])) != 0))
    {
      unsigned int v7 = Mutable;
      CFIndex Count = CFArrayGetCount(v2);
      if (Count >= 1)
      {
        CFIndex v9 = Count;
        for (CFIndex i = 0; i != v9; ++i)
        {
          ValueAtIndeCGFloat x = (const __CFString *)CFArrayGetValueAtIndex(v2, i);
          if (ValueAtIndex)
          {
            CFStringRef v12 = ValueAtIndex;
            CFTypeID v13 = CFGetTypeID(ValueAtIndex);
            if (v13 == CFNumberGetTypeID())
            {
              SimpleStringFromCFCFDataRef Value = CGImageMetadataCreateSimpleStringFromCFValue(v12, 3);
              if (SimpleStringFromCFValue)
              {
                CFTypeID v15 = (__CFString *)SimpleStringFromCFValue;
                if (CFStringCompare(SimpleStringFromCFValue, @"0/1", 0)) {
                  CFStringRef v16 = v15;
                }
                else {
                  CFStringRef v16 = @"0/0";
                }
                CFArrayAppendValue(v7, v16);
                CFRelease(v15);
              }
            }
          }
        }
      }
      CFArrayRef v2 = (const __CFArray *)CFStringCreateByCombiningStrings(v5, v7, @" ");
      if (a2) {
        *a2 = CFArrayGetCount(v7);
      }
      CFRelease(v7);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

__CFDictionary *CreateXMPFlashStructFromCFValue(__CFDictionary *result)
{
  unsigned int valuePtr = 0;
  if (result)
  {
    CFNumberRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == CFNumberGetTypeID() && CFNumberGetValue(v1, kCFNumberIntType, &valuePtr)) {
      return CreateXMPFlashStructFromInt(valuePtr);
    }
    else {
      return 0;
    }
  }
  return result;
}

CFStringRef CreateXMPGPSCoordinateFromCFValue(CFStringRef result, const __CFString *a2, int a3)
{
  double valuePtr = 0.0;
  if (result)
  {
    CFNumberRef v5 = (const __CFNumber *)result;
    CFTypeID v6 = CFGetTypeID(result);
    if (v6 == CFNumberGetTypeID())
    {
      if (CFNumberGetValue(v5, kCFNumberDoubleType, &valuePtr))
      {
        if (a2)
        {
LABEL_5:
          if (a3)
          {
            BOOL v7 = CFEqual(a2, @"N");
            LODWORD(v8) = 83;
            unsigned int v9 = 78;
          }
          else
          {
            BOOL v7 = CFEqual(a2, @"E");
            LODWORD(v8) = 87;
            unsigned int v9 = 69;
          }
          if (v7) {
            uint64_t v8 = v9;
          }
          else {
            uint64_t v8 = v8;
          }
LABEL_23:
          double valuePtr = fabs(valuePtr);
          return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%d,%lg%c", (int)valuePtr, (valuePtr - (double)(int)valuePtr) * 60.0, v8, *(void *)&valuePtr);
        }
LABEL_9:
        if (valuePtr < 0.0) {
          LODWORD(v8) = 87;
        }
        else {
          LODWORD(v8) = 69;
        }
        if (valuePtr < 0.0) {
          unsigned int v11 = 83;
        }
        else {
          unsigned int v11 = 78;
        }
        if (a3) {
          uint64_t v8 = v11;
        }
        else {
          uint64_t v8 = v8;
        }
        goto LABEL_23;
      }
    }
    else
    {
      CFTypeID v10 = CFGetTypeID(v5);
      if (v10 == CFStringGetTypeID())
      {
        double valuePtr = CFStringGetDoubleValue((CFStringRef)v5);
        if (a2) {
          goto LABEL_5;
        }
        goto LABEL_9;
      }
    }
    return 0;
  }
  return result;
}

CFArrayRef CreateGPSVersionStringFromArray(const __CFArray *cf)
{
  CFArrayRef v1 = cf;
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)values = 0u;
  long long v18 = 0u;
  if (cf)
  {
    CFTypeID v2 = CFGetTypeID(cf);
    if (v2 != CFArrayGetTypeID()) {
      goto LABEL_16;
    }
    CFIndex Count = CFArrayGetCount(v1);
    if (Count < 2) {
      goto LABEL_16;
    }
    CFIndex v4 = Count;
    CFIndex v5 = 0;
    CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    do
    {
      if (v4 <= v5)
      {
        CopCGFloat y = (void *)CFRetain(@"0");
        if (!Copy) {
          goto LABEL_16;
        }
      }
      else
      {
        ValueAtIndeCGFloat x = (const __CFString *)CFArrayGetValueAtIndex(v1, v5);
        CFTypeID v8 = CFGetTypeID(ValueAtIndex);
        if (v8 == CFNumberGetTypeID())
        {
          uint64_t valuePtr = 0;
          CFNumberGetValue((CFNumberRef)ValueAtIndex, kCFNumberLongType, &valuePtr);
          CopCGFloat y = (void *)CFStringCreateWithFormat(v6, 0, @"%ld", valuePtr);
          if (!Copy) {
            goto LABEL_16;
          }
        }
        else
        {
          CFTypeID v10 = CFGetTypeID(ValueAtIndex);
          if (v10 != CFStringGetTypeID()) {
            goto LABEL_16;
          }
          CopCGFloat y = (void *)CFStringCreateCopy(v6, ValueAtIndex);
          if (!Copy) {
            goto LABEL_16;
          }
        }
      }
      values[v5++] = Copy;
    }
    while (v5 != 4);
    CFArrayRef v11 = CFArrayCreate(v6, (const void **)values, 4, MEMORY[0x1E4F1D510]);
    if (v11)
    {
      CFArrayRef v12 = v11;
      CFArrayRef v1 = (const __CFArray *)CFStringCreateByCombiningStrings(v6, v11, @".");
      CFRelease(v12);
    }
    else
    {
LABEL_16:
      CFArrayRef v1 = 0;
    }
  }
  for (uint64_t i = 0; i != 4; ++i)
  {
    CFStringRef v14 = values[i];
    if (v14) {
      CFRelease(v14);
    }
  }
  return v1;
}

void AddMWGRegionsFromExifAuxRegions(CGImageMetadata *a1, IIODictionary *this)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  if (this)
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(this, @"HeightAppliedTo");
    CFDictionaryRef v5 = IIODictionary::getObjectForKey(this, @"WidthAppliedTo");
    CFDictionaryRef v6 = IIODictionary::getObjectForKey(this, @"RegionList");
    if (ObjectForKey)
    {
      if (v5)
      {
        CFArrayRef v7 = v6;
        if (v6)
        {
          if (CFArrayGetCount(v6) >= 1)
          {
            memset(v50, 0, sizeof(v50));
            IIOArray::IIOArray((IIOArray *)v50, v7);
            CGImageMetadataRegisterNamespaceForPrefix(a1, @"http://www.metadataworkinggroup.com/schemas/regions/", @"mwg-rs", 0);
            CGImageMetadataRegisterNamespaceForPrefix(a1, @"http://ns.apple.com/faceinfo/1.0/", @"apple-fi", 0);
            CGImageMetadataRegisterNamespaceForPrefix(a1, @"http://ns.adobe.com/xap/1.0/sType/Dimensions#", @"stDim", 0);
            CGImageMetadataSetValueWithPath(a1, 0, @"mwg-rs:Regions.AppliedToDimensions.stDim:h", ObjectForKey);
            CGImageMetadataSetValueWithPath(a1, 0, @"mwg-rs:Regions.AppliedToDimensions.stDim:w", v5);
            CGImageMetadataSetValueWithPath(a1, 0, @"mwg-rs:Regions.AppliedToDimensions.stDim:unit", @"pixel");
            unsigned int Count = IIOArray::getCount((IIOArray *)v50);
            if (Count)
            {
              CFIndex v9 = 0;
              CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
              uint64_t v48 = Count;
              metadata = a1;
              while (1)
              {
                ObjectAtIndeCGFloat x = IIOArray::getObjectAtIndex((IIOArray *)v50, v9);
                CFDictionaryRef v11 = ObjectAtIndex;
                if (!ObjectAtIndex) {
                  goto LABEL_70;
                }
                CFTypeID v12 = CFGetTypeID(ObjectAtIndex);
                if (v12 != CFDictionaryGetTypeID()) {
                  goto LABEL_70;
                }
                memset(v49, 0, sizeof(v49));
                IIODictionary::IIODictionary((IIODictionary *)v49, v11);
                CFDictionaryRef v13 = IIODictionary::getObjectForKey((IIODictionary *)v49, @"X");
                CFDictionaryRef v14 = IIODictionary::getObjectForKey((IIODictionary *)v49, @"Y");
                CFDictionaryRef v15 = IIODictionary::getObjectForKey((IIODictionary *)v49, @"Width");
                CFDictionaryRef v16 = IIODictionary::getObjectForKey((IIODictionary *)v49, @"Height");
                if (v13)
                {
                  if (v14)
                  {
                    if (v15)
                    {
                      CFDictionaryRef v17 = v16;
                      if (v16)
                      {
                        CFStringRef v18 = CFStringCreateWithFormat(alloc, 0, @"[%ld]", v9);
                        if (v18) {
                          break;
                        }
                      }
                    }
                  }
                }
LABEL_69:
                IIODictionary::~IIODictionary((IIODictionary *)v49);
LABEL_70:
                if (v48 == ++v9) {
                  goto LABEL_71;
                }
              }
              CGImageMetadataTagRef v19 = CGImageMetadataTagCreate(@"http://ns.adobe.com/xmp/sType/Area#", @"stArea", @"x", kCGImageMetadataTypeString, v13);
              CGImageMetadataTagRef v20 = CGImageMetadataTagCreate(@"http://ns.adobe.com/xmp/sType/Area#", @"stArea", @"y", kCGImageMetadataTypeString, v14);
              CGImageMetadataTagRef v21 = CGImageMetadataTagCreate(@"http://ns.adobe.com/xmp/sType/Area#", @"stArea", @"w", kCGImageMetadataTypeString, v15);
              CGImageMetadataTagRef v22 = CGImageMetadataTagCreate(@"http://ns.adobe.com/xmp/sType/Area#", @"stArea", @"h", kCGImageMetadataTypeString, v17);
              CGImageMetadataTagRef v23 = CGImageMetadataTagCreate(@"http://ns.adobe.com/xmp/sType/Area#", @"stArea", @"unit", kCGImageMetadataTypeString, @"normalized");
              CGImageMetadataTagRef v24 = v23;
              if (v19 && v20 && v21 && v22 && v23)
              {
                *(_OWORD *)keys = xmmword_1E53CCD20;
                long long v55 = *(_OWORD *)off_1E53CCD30;
                long long v56 = @"unit";
                values[0] = v19;
                values[1] = v20;
                values[2] = v21;
                values[3] = v22;
                values[4] = v23;
                CFDictionaryRef v25 = CFDictionaryCreate(alloc, (const void **)keys, (const void **)values, 5, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                if (v25)
                {
                  CGImageMetadataTagRef v26 = CGImageMetadataTagCreate(@"http://www.metadataworkinggroup.com/schemas/regions/", @"mwg-rs", @"Area", kCGImageMetadataTypeStructure, v25);
                  CGImageMetadataTagRef cf = v26;
                  if (v26)
                  {
                    uint64_t v51 = v26;
                    long long v52 = @"Area";
                    CFDictionaryRef v27 = CFDictionaryCreate(alloc, (const void **)&v52, (const void **)&v51, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                    if (v27)
                    {
                      CGImageMetadataTagRef v28 = CGImageMetadataTagCreate(@"http://www.metadataworkinggroup.com/schemas/regions/", @"mwg-rs", v18, kCGImageMetadataTypeStructure, v27);
                      CFRelease(v27);
                    }
                    else
                    {
                      CGImageMetadataTagRef v28 = 0;
                    }
                    CFRelease(cf);
                  }
                  else
                  {
                    CGImageMetadataTagRef v28 = 0;
                  }
                  CFRelease(v25);
                }
                else
                {
                  CGImageMetadataTagRef v28 = 0;
                }
              }
              else
              {
                CGImageMetadataTagRef v28 = 0;
                int v29 = 0;
                if (!v19) {
                  goto LABEL_32;
                }
              }
              CFRelease(v19);
              int v29 = v28;
LABEL_32:
              if (v20) {
                CFRelease(v20);
              }
              if (v21) {
                CFRelease(v21);
              }
              if (v22) {
                CFRelease(v22);
              }
              if (v24) {
                CFRelease(v24);
              }
              CFRelease(v18);
              if (v29)
              {
                CFStringRef v30 = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v49, @"Type");
                CFStringRef v31 = v30;
                if (v30
                  && (CFEqual(v30, @"Face")
                   || CFEqual(v31, @"Pet")
                   || CFEqual(v31, @"Focus")
                   || CFEqual(v31, @"BarCode")
                   || CFEqual(v31, @"CleanAperture")))
                {
                  CGImageMetadataSetValueWithPath(metadata, v29, @"mwg-rs:Type", v31);
                }
                CFDictionaryRef v32 = IIODictionary::getObjectForKey((IIODictionary *)v49, @"Timestamp");
                CFDictionaryRef v33 = IIODictionary::getObjectForKey((IIODictionary *)v49, @"AngleInfoYaw");
                CFDictionaryRef v34 = IIODictionary::getObjectForKey((IIODictionary *)v49, @"AngleInfoRoll");
                CFDictionaryRef v35 = IIODictionary::getObjectForKey((IIODictionary *)v49, @"ConfidenceLevel");
                CFDictionaryRef v36 = IIODictionary::getObjectForKey((IIODictionary *)v49, @"FaceID");
                CFMutableArrayRef Mutable = CFDictionaryCreateMutable(alloc, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                if (Mutable)
                {
                  if (v32)
                  {
                    CGImageMetadataTagRef v38 = CGImageMetadataTagCreate(@"http://ns.apple.com/faceinfo/1.0/", @"apple-fi", @"Timestamp", kCGImageMetadataTypeString, v32);
                    if (v38)
                    {
                      CFDictionarySetValue(Mutable, @"Timestamp", v38);
                      CFRelease(v38);
                    }
                  }
                  if (v33)
                  {
                    CGImageMetadataTagRef v39 = CGImageMetadataTagCreate(@"http://ns.apple.com/faceinfo/1.0/", @"apple-fi", @"AngleInfoYaw", kCGImageMetadataTypeString, v33);
                    if (v39)
                    {
                      CFDictionarySetValue(Mutable, @"AngleInfoYaw", v39);
                      CFRelease(v39);
                    }
                  }
                  if (v34)
                  {
                    CGImageMetadataTagRef v40 = CGImageMetadataTagCreate(@"http://ns.apple.com/faceinfo/1.0/", @"apple-fi", @"AngleInfoRoll", kCGImageMetadataTypeString, v34);
                    if (v40)
                    {
                      CFDictionarySetValue(Mutable, @"AngleInfoRoll", v40);
                      CFRelease(v40);
                    }
                  }
                  if (v35)
                  {
                    CGImageMetadataTagRef v41 = CGImageMetadataTagCreate(@"http://ns.apple.com/faceinfo/1.0/", @"apple-fi", @"ConfidenceLevel", kCGImageMetadataTypeString, v35);
                    if (v41)
                    {
                      CFDictionarySetValue(Mutable, @"ConfidenceLevel", v41);
                      CFRelease(v41);
                    }
                  }
                  if (v36)
                  {
                    CGImageMetadataTagRef v42 = CGImageMetadataTagCreate(@"http://ns.apple.com/faceinfo/1.0/", @"apple-fi", @"FaceID", kCGImageMetadataTypeString, v36);
                    if (v42)
                    {
                      CFDictionarySetValue(Mutable, @"FaceID", v42);
                      CFRelease(v42);
                    }
                  }
                  uint64_t v43 = CGImageMetadataTagCreate(@"http://www.metadataworkinggroup.com/schemas/regions/", @"mwg-rs", @"Extensions", kCGImageMetadataTypeStructure, Mutable);
                  CFRelease(Mutable);
                  if (v43)
                  {
                    CGImageMetadataSetTagWithPath(metadata, v29, @"mwg-rs:Extensions", v43);
                    CFRelease(v43);
                  }
                }
                CFStringRef v44 = CFStringCreateWithFormat(alloc, 0, @"mwg-rs:Regions.RegionList[%ld]", v9);
                if (v44)
                {
                  CGImageMetadataSetTagWithPath(metadata, 0, v44, v29);
                  CFRelease(v44);
                }
                CFRelease(v29);
              }
              goto LABEL_69;
            }
LABEL_71:
            IIOArray::~IIOArray((IIOArray *)v50);
          }
        }
      }
    }
  }
}

void sub_1887B2658(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

BOOL GetLongLongFromPropertyValue(const __CFString *a1, uint64_t *a2)
{
  BOOL v2 = 0;
  if (a1 && a2)
  {
    CFStringRef v4 = a1;
    *a2 = 0;
    CFTypeID v5 = CFGetTypeID(a1);
    if ((v5 != CGImageMetadataTagGetTypeID()
       || (CFStringRef v4 = *(const __CFString **)(CGImageSourceGetSource((uint64_t)v4) + 48)) != 0)
      && (CFTypeID v6 = CFGetTypeID(v4), v6 == CFStringGetTypeID()))
    {
      CFIndex Length = CFStringGetLength(v4);
      CFIndex v8 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
      CFIndex v9 = (char *)malloc_type_malloc(v8, 0xD25FA49DuLL);
      int CString = CFStringGetCString(v4, v9, v8, 0x8000100u);
      BOOL v2 = CString != 0;
      if (CString) {
        *a2 = atoll(v9);
      }
      free(v9);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t GetMajorVersionFromPropertyValue(const __CFString *cf, SInt32 *a2)
{
  uint64_t result = 0;
  if (cf && a2)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFStringGetTypeID() && CFStringGetLength(cf) == 4)
    {
      v8.location = 0;
      v8.size_t length = 2;
      CFStringRef v6 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], cf, v8);
      if (v6)
      {
        CFStringRef v7 = v6;
        *a2 = CFStringGetIntValue(v6);
        CFRelease(v7);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t GetMinorVersionFromPropertyValue(const __CFString *a1, SInt32 *a2)
{
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    CFTypeID v5 = CFGetTypeID(a1);
    if (v5 == CFStringGetTypeID() && CFStringGetLength(a1) == 4)
    {
      uint64_t v2 = 1;
      v9.location = 2;
      v9.size_t length = 1;
      CFStringRef v6 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, v9);
      if (v6)
      {
        CFStringRef v7 = v6;
        *a2 = CFStringGetIntValue(v6);
        CFRelease(v7);
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t GetRevisionVersionFromPropertyValue(const __CFString *a1, SInt32 *a2)
{
  uint64_t v2 = 0;
  if (a1 && a2)
  {
    CFTypeID v5 = CFGetTypeID(a1);
    if (v5 == CFStringGetTypeID() && CFStringGetLength(a1) == 4)
    {
      uint64_t v2 = 1;
      v9.location = 3;
      v9.size_t length = 1;
      CFStringRef v6 = CFStringCreateWithSubstring((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, v9);
      if (v6)
      {
        CFStringRef v7 = v6;
        *a2 = CFStringGetIntValue(v6);
        CFRelease(v7);
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

void addPropertiesFromMetadata(IIODictionary *a1, CFMutableArrayRef *a2, void *a3, int a4)
{
  if (!a3) {
    return;
  }
  CFTypeID v8 = CFGetTypeID(a3);
  if (v8 == CGImageMetadataGetTypeID())
  {
    CFArrayRef v9 = CGImageMetadataCopyTags((CGImageMetadataRef)a3);
    uint64_t v43 = 0;
    CFStringRef v44 = 0;
    uint64_t v45 = 0;
    CFTypeID v10 = IIOArray::IIOArray((IIOArray *)&v43, v9);
    v41[0] = MEMORY[0x1E4F143A8];
    v41[1] = 0x40000000;
    v41[2] = ___ZL25addPropertiesFromMetadataP13IIODictionaryP8IIOArrayPKvi_block_invoke;
    v41[3] = &__block_descriptor_tmp_378;
    v41[4] = a1;
    v41[5] = a2;
    int v42 = a4;
    IIOArray::enumerate((uint64_t)v10, (uint64_t)v41);
    CFRelease(v9);
LABEL_4:
    IIOArray::~IIOArray((IIOArray *)&v43);
    return;
  }
  CFTypeID v11 = CFGetTypeID(a3);
  if (v11 == CGImageMetadataTagGetTypeID())
  {
    CFStringRef v12 = CGImageMetadataTagCopyNamespace((CGImageMetadataTagRef)a3);
    if (CFStringCompare(v12, @"http://ns.adobe.com/photoshop/1.0/", 0)
      && CFStringCompare(v12, @"http://ns.adobe.com/exif/1.0/", 0))
    {
      if (CFEqual(v12, @"http://ns.adobe.com/exif/1.0/aux/")
        || CFEqual(v12, @"http://ns.adobe.com/exif/1.0/"))
      {
        CFDictionaryRef v13 = &kCGImagePropertyExifAuxDictionary;
        goto LABEL_23;
      }
      if (CFStringCompare(v12, @"http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/", 0)
        && CFStringCompare(v12, @"http://iptc.org/std/Iptc4xmpExt/2008-02-29/", 0)
        && CFStringCompare(v12, @"http://purl.org/dc/elements/1.1/", 0)
        && CFEqual(v12, @"http://ns.adobe.com/tiff/1.0/"))
      {
        CFDictionaryRef v13 = &kCGImagePropertyTIFFDictionary;
        goto LABEL_23;
      }
    }
    CFDictionaryRef v13 = &kCGImagePropertyIPTCDictionary;
LABEL_23:
    CFStringRef v18 = *v13;
    CFStringRef v19 = CGImageMetadataTagCopyName((CGImageMetadataTagRef)a3);
    if (v19)
    {
      CFStringRef v20 = v19;
      uint64_t v21 = 0;
      CFStringRef v22 = @"AuthorsPosition";
      while (CFStringCompare(v20, v22, 0))
      {
        CFStringRef v22 = gKeyMapping[v21 + 2];
        v21 += 2;
        if (v21 == 32)
        {
          CGImageMetadataTagRef v23 = (__CFString *)v20;
          goto LABEL_30;
        }
      }
      CGImageMetadataTagRef v23 = gKeyMapping[v21 + 1];
LABEL_30:
      CFStringRef v24 = (const __CFString *)CFRetain(v23);
      CFRelease(v20);
    }
    else
    {
      CFStringRef v24 = 0;
    }
    if (a4 <= 1) {
      CFStringRef v25 = v18;
    }
    else {
      CFStringRef v25 = 0;
    }
    CGImageMetadataType Type = CGImageMetadataTagGetType((CGImageMetadataTagRef)a3);
    if ((Type - 2) >= 4)
    {
      if (Type == kCGImageMetadataTypeStructure)
      {
        uint64_t v43 = 0;
        CFStringRef v44 = 0;
        uint64_t v45 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v43);
        if (a1)
        {
          if (v25) {
            IIODictionary::setObjectForKeyGroup(a1, v44, v24, v25);
          }
          else {
            IIODictionary::setObjectForKey(a1, v44, v24);
          }
        }
        else
        {
          IIOArray::addObject(a2, v44);
        }
        CFTypeRef v32 = CGImageMetadataTagCopyValue((CGImageMetadataTagRef)a3);
        if (v32)
        {
          addPropertiesFromMetadata((IIODictionary *)&v43, (IIOArray *)a2, v32, a4 + 1);
          CFRelease(v32);
        }
        IIODictionary::~IIODictionary((IIODictionary *)&v43);
      }
      else if (Type == kCGImageMetadataTypeString)
      {
        CFTypeRef v28 = CGImageMetadataTagCopyValue((CGImageMetadataTagRef)a3);
        if (v28)
        {
          int v29 = v28;
          if (a1)
          {
            if (v25) {
              IIODictionary::setObjectForKeyGroup(a1, v28, v24, v25);
            }
            else {
              IIODictionary::setObjectForKey(a1, v28, v24);
            }
          }
          else if (a2)
          {
            IIOArray::addObject(a2, v28);
          }
          CFRelease(v29);
        }
      }
    }
    else
    {
      CFTypeRef v27 = CGImageMetadataTagCopyValue((CGImageMetadataTagRef)a3);
      uint64_t v43 = 0;
      CFStringRef v44 = 0;
      uint64_t v45 = 0;
      IIOArray::IIOArray((IIOArray *)&v43);
      if (a1)
      {
        if (v25) {
          IIODictionary::setObjectForKeyGroup(a1, v44, v24, v25);
        }
        else {
          IIODictionary::setObjectForKey(a1, v44, v24);
        }
      }
      else if (a2)
      {
        IIOArray::addObject(a2, v44);
      }
      addPropertiesFromMetadata(0, (IIOArray *)&v43, v27, a4 + 1);
      CFRelease(v27);
      IIOArray::~IIOArray((IIOArray *)&v43);
    }
    if (v12) {
      CFRelease(v12);
    }
    if (v24) {
      CFRelease(v24);
    }
    return;
  }
  CFTypeID v14 = CFGetTypeID(a3);
  if (v14 == CGImageMetadataValueGetTypeID())
  {
    _cg_jpeg_mem_term("addPropertiesFromMetadata", 1469, "===CGImageMetadataValue:%p===\n");
  }
  else
  {
    CFTypeID v15 = CFGetTypeID(a3);
    if (v15 == CGImageMetadataPropertyGetTypeID())
    {
      _cg_jpeg_mem_term("addPropertiesFromMetadata", 1473, "===CGImageMetadataProperty:%p===\n");
    }
    else
    {
      CFTypeID v16 = CFGetTypeID(a3);
      if (v16 == CFArrayGetTypeID())
      {
        uint64_t v43 = 0;
        CFStringRef v44 = 0;
        uint64_t v45 = 0;
        CFDictionaryRef v17 = IIOArray::IIOArray((IIOArray *)&v43, (const __CFArray *)a3);
        v39[0] = MEMORY[0x1E4F143A8];
        v39[1] = 0x40000000;
        v39[2] = ___ZL25addPropertiesFromMetadataP13IIODictionaryP8IIOArrayPKvi_block_invoke_2;
        v39[3] = &__block_descriptor_tmp_381;
        v39[4] = a1;
        v39[5] = a2;
        int v40 = a4;
        IIOArray::enumerate((uint64_t)v17, (uint64_t)v39);
        goto LABEL_4;
      }
      CFTypeID v30 = CFGetTypeID(a3);
      if (v30 == CFDictionaryGetTypeID())
      {
        uint64_t v43 = 0;
        CFStringRef v44 = 0;
        uint64_t v45 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v43);
        memset(v38, 0, sizeof(v38));
        IIODictionary::IIODictionary((IIODictionary *)v38, (const __CFDictionary *)a3);
        v36[0] = MEMORY[0x1E4F143A8];
        v36[1] = 0x40000000;
        v36[2] = ___ZL25addPropertiesFromMetadataP13IIODictionaryP8IIOArrayPKvi_block_invoke_3;
        v36[3] = &__block_descriptor_tmp_382;
        v36[4] = a1;
        v36[5] = a2;
        int v37 = a4;
        IIODictionary::enumerate((uint64_t)v38, v36);
        IIODictionary::~IIODictionary((IIODictionary *)v38);
        IIODictionary::~IIODictionary((IIODictionary *)&v43);
      }
      else
      {
        CFTypeID v31 = CFGetTypeID(a3);
        if (v31 == CFBagGetTypeID())
        {
          _cg_jpeg_mem_term("addPropertiesFromMetadata", 1498, "===CFBag:%p===\n");
        }
        else
        {
          CFTypeID v33 = CFGetTypeID(a3);
          if (v33 == CFSetGetTypeID())
          {
            _cg_jpeg_mem_term("addPropertiesFromMetadata", 1502, "===CFSet:%p===\n");
          }
          else
          {
            CFTypeID v34 = CFGetTypeID(a3);
            if (v34 == CFStringGetTypeID())
            {
              _cg_jpeg_mem_term("addPropertiesFromMetadata", 1506, "===CFString:%p===\n");
            }
            else
            {
              CFTypeID v35 = CFGetTypeID(a3);
              if (v35 == CFNumberGetTypeID())
              {
                _cg_jpeg_mem_term("addPropertiesFromMetadata", 1510, "===CFNumber:%p===\n");
              }
              else
              {
                _cg_jpeg_mem_term("addPropertiesFromMetadata", 1514, "===unknown:%p===\n", a3);
                CFShow(a3);
              }
            }
          }
        }
      }
    }
  }
}

void sub_1887B30C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v9 - 104));
  _Unwind_Resume(a1);
}

__CFDictionary *CreateRegionFromPropertyValue(const void *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFDictionaryGetTypeID()) {
    return 0;
  }
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    CFDataRef Value = CFDictionaryGetValue((CFDictionaryRef)a1, @"AppliedToDimensions");
    uint64_t Source = CGImageSourceGetSource((uint64_t)Value);
    if (Value)
    {
      uint64_t v6 = Source;
      CFTypeID v7 = CFGetTypeID(Value);
      if (v7 == CGImageMetadataTagGetTypeID())
      {
        CFTypeID v8 = *(const void **)(v6 + 48);
        if (v8)
        {
          CFTypeID v9 = CFGetTypeID(v8);
          if (v9 == CFDictionaryGetTypeID())
          {
            CFNumberRef IntValueFromField = CreateIntValueFromField((const __CFDictionary *)v8, @"w");
            if (IntValueFromField)
            {
              CFNumberRef v11 = IntValueFromField;
              CFDictionarySetValue(Mutable, @"WidthAppliedTo", IntValueFromField);
              CFRelease(v11);
            }
            CFNumberRef v12 = CreateIntValueFromField((const __CFDictionary *)v8, @"h");
            if (v12)
            {
              CFNumberRef v13 = v12;
              CFDictionarySetValue(Mutable, @"HeightAppliedTo", v12);
              CFRelease(v13);
            }
            CFTypeID v14 = CFDictionaryGetValue((CFDictionaryRef)a1, @"RegionList");
            uint64_t v15 = CGImageSourceGetSource((uint64_t)v14);
            if (v14)
            {
              uint64_t v16 = v15;
              CFTypeID v17 = CFGetTypeID(v14);
              if (v17 == CGImageMetadataTagGetTypeID())
              {
                CFArrayRef v18 = *(const __CFArray **)(v16 + 48);
                if (v18)
                {
                  CFTypeID v19 = CFGetTypeID(*(CFTypeRef *)(v16 + 48));
                  if (v19 == CFArrayGetTypeID())
                  {
                    CFMutableArrayRef v20 = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
                    if (v20)
                    {
                      CFMutableArrayRef v21 = v20;
                      CFDictionarySetValue(Mutable, @"RegionList", v20);
                      CFRelease(v21);
                      CFIndex Count = CFArrayGetCount(v18);
                      if (Count >= 1)
                      {
                        uint64_t v78 = Mutable;
                        CFIndex v22 = 0;
                        CGImageMetadataTagRef v23 = @"Name";
                        CFStringRef v24 = @"Type";
                        CFStringRef v25 = @"Description";
                        CGImageMetadataTagRef v26 = @"Timestamp";
                        do
                        {
                          CFMutableDictionaryRef v27 = CFDictionaryCreateMutable(allocator, 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
                          if (!v27) {
                            break;
                          }
                          CFMutableDictionaryRef v28 = v27;
                          CFArrayAppendValue(v21, v27);
                          CFRelease(v28);
                          ValueAtIndeCGFloat x = CFArrayGetValueAtIndex(v18, v22);
                          uint64_t v30 = CGImageSourceGetSource((uint64_t)ValueAtIndex);
                          if (!ValueAtIndex) {
                            break;
                          }
                          uint64_t v31 = v30;
                          CFTypeID v32 = CFGetTypeID(ValueAtIndex);
                          if (v32 != CGImageMetadataTagGetTypeID()) {
                            break;
                          }
                          CFDictionaryRef v33 = *(const __CFDictionary **)(v31 + 48);
                          if (!v33) {
                            break;
                          }
                          CFTypeID v34 = CFGetTypeID(*(CFTypeRef *)(v31 + 48));
                          if (v34 != CFDictionaryGetTypeID()) {
                            break;
                          }
                          CFIndex v81 = v22;
                          CFTypeID v35 = v21;
                          CFArrayRef v36 = v18;
                          int v37 = v26;
                          CGImageMetadataTagRef v38 = v25;
                          CGImageMetadataTagRef v39 = v24;
                          int v40 = v23;
                          CGImageMetadataTagRef v41 = CFDictionaryGetValue(v33, @"Area");
                          uint64_t v42 = CGImageSourceGetSource((uint64_t)v41);
                          if (!v41) {
                            break;
                          }
                          uint64_t v43 = v42;
                          CFTypeID v44 = CFGetTypeID(v41);
                          if (v44 != CGImageMetadataTagGetTypeID()) {
                            break;
                          }
                          uint64_t v45 = *(const void **)(v43 + 48);
                          if (!v45) {
                            break;
                          }
                          CFTypeID v46 = CFGetTypeID(v45);
                          if (v46 != CFDictionaryGetTypeID()) {
                            break;
                          }
                          CFNumberRef FloatValueFromField = CreateFloatValueFromField((const __CFDictionary *)v45, @"w");
                          if (FloatValueFromField)
                          {
                            CFNumberRef v48 = FloatValueFromField;
                            CFDictionarySetValue(v28, @"Width", FloatValueFromField);
                            CFRelease(v48);
                          }
                          CFNumberRef v49 = CreateFloatValueFromField((const __CFDictionary *)v45, @"h");
                          if (v49)
                          {
                            CFNumberRef v50 = v49;
                            CFDictionarySetValue(v28, @"Height", v49);
                            CFRelease(v50);
                          }
                          CFNumberRef v51 = CreateFloatValueFromField((const __CFDictionary *)v45, @"x");
                          if (v51)
                          {
                            CFNumberRef v52 = v51;
                            CFDictionarySetValue(v28, @"X", v51);
                            CFRelease(v52);
                          }
                          CFNumberRef v53 = CreateFloatValueFromField((const __CFDictionary *)v45, @"y");
                          if (v53)
                          {
                            CFNumberRef v54 = v53;
                            CFDictionarySetValue(v28, @"Y", v53);
                            CFRelease(v54);
                          }
                          CGImageMetadataTagRef v23 = v40;
                          long long v55 = CFDictionaryGetValue(v33, v40);
                          DefaultString = CGImageMetadataGetDefaultString(v55);
                          if (DefaultString) {
                            CFDictionarySetValue(v28, v40, DefaultString);
                          }
                          CFStringRef v24 = v39;
                          uint64_t v57 = CFDictionaryGetValue(v33, v39);
                          long long v58 = CGImageMetadataGetDefaultString(v57);
                          if (v58) {
                            CFDictionarySetValue(v28, v39, v58);
                          }
                          CFStringRef v25 = v38;
                          long long v59 = CFDictionaryGetValue(v33, v38);
                          long long v60 = CGImageMetadataGetDefaultString(v59);
                          if (v60) {
                            CFDictionarySetValue(v28, v38, v60);
                          }
                          long long v61 = CFDictionaryGetValue(v33, @"Extensions");
                          uint64_t v62 = CGImageSourceGetSource((uint64_t)v61);
                          CGImageMetadataTagRef v26 = v37;
                          CFArrayRef v18 = v36;
                          CFMutableArrayRef v21 = v35;
                          if (v61)
                          {
                            uint64_t v63 = v62;
                            CFTypeID v64 = CFGetTypeID(v61);
                            if (v64 == CGImageMetadataTagGetTypeID())
                            {
                              CFDictionaryRef v65 = *(const __CFDictionary **)(v63 + 48);
                              if (v65)
                              {
                                CFTypeID v66 = CFGetTypeID(*(CFTypeRef *)(v63 + 48));
                                if (v66 == CFDictionaryGetTypeID())
                                {
                                  CFNumberRef v67 = CreateIntValueFromField(v65, v26);
                                  if (v67)
                                  {
                                    CFNumberRef v68 = v67;
                                    CFDictionarySetValue(v28, v26, v67);
                                    CFRelease(v68);
                                  }
                                  CFNumberRef v69 = CreateIntValueFromField(v65, @"AngleInfoYaw");
                                  if (v69)
                                  {
                                    CFNumberRef v70 = v69;
                                    CFDictionarySetValue(v28, @"AngleInfoYaw", v69);
                                    CFRelease(v70);
                                  }
                                  CFNumberRef v71 = CreateIntValueFromField(v65, @"AngleInfoRoll");
                                  if (v71)
                                  {
                                    CFNumberRef v72 = v71;
                                    CFDictionarySetValue(v28, @"AngleInfoRoll", v71);
                                    CFRelease(v72);
                                  }
                                  CFNumberRef v73 = CreateIntValueFromField(v65, @"ConfidenceLevel");
                                  if (v73)
                                  {
                                    CFNumberRef v74 = v73;
                                    CFDictionarySetValue(v28, @"ConfidenceLevel", v73);
                                    CFRelease(v74);
                                  }
                                  CFNumberRef v75 = CreateIntValueFromField(v65, @"FaceID");
                                  if (v75)
                                  {
                                    CFNumberRef v76 = v75;
                                    CFDictionarySetValue(v28, @"FaceID", v75);
                                    CFRelease(v76);
                                  }
                                }
                              }
                            }
                          }
                          CFIndex v22 = v81 + 1;
                        }
                        while (Count != v81 + 1);
                        return v78;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return Mutable;
}

uint64_t CreateIntFromXMPFlashStruct(const void *a1)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFDictionaryGetTypeID()) {
    return 0;
  }
  CFDataRef Value = CFDictionaryGetValue((CFDictionaryRef)a1, @"Fired");
  CFStringRef DefaultString = (const __CFString *)CGImageMetadataGetDefaultString(Value);
  if (DefaultString) {
    uint64_t v5 = CFStringCompare(DefaultString, @"True", 1uLL) == kCFCompareEqualTo;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = CFDictionaryGetValue((CFDictionaryRef)a1, @"Return");
  CFStringRef v7 = (const __CFString *)CGImageMetadataGetDefaultString(v6);
  if (v7) {
    uint64_t v5 = v5 & 0xFFFFFFF9 | (2 * (CFStringGetIntValue(v7) & 3u));
  }
  CFTypeID v8 = CFDictionaryGetValue((CFDictionaryRef)a1, @"Mode");
  CFStringRef v9 = (const __CFString *)CGImageMetadataGetDefaultString(v8);
  if (v9) {
    uint64_t v5 = v5 & 0xFFFFFFE7 | (8 * (CFStringGetIntValue(v9) & 3u));
  }
  CFTypeID v10 = CFDictionaryGetValue((CFDictionaryRef)a1, @"Function");
  CFStringRef v11 = (const __CFString *)CGImageMetadataGetDefaultString(v10);
  if (v11)
  {
    if (CFStringCompare(v11, @"True", 1uLL)) {
      uint64_t v5 = v5;
    }
    else {
      uint64_t v5 = v5 | 0x20;
    }
  }
  CFNumberRef v12 = CFDictionaryGetValue((CFDictionaryRef)a1, @"RedEyeMode");
  CFStringRef v13 = (const __CFString *)CGImageMetadataGetDefaultString(v12);
  if (v13)
  {
    if (CFStringCompare(v13, @"True", 1uLL)) {
      return v5;
    }
    else {
      return v5 | 0x40;
    }
  }
  return v5;
}

CFStringRef CreateGPSDateStringWithXMPDateTimeString(const __CFString *a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  memset(__str, 0, 11);
  memset(&v3, 0, sizeof(v3));
  int DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(a1, &v3, 0, 0);
  CFStringRef result = 0;
  if (DateTimeStructFromXMPDateTimeString)
  {
    snprintf(__str, 0xBuLL, "%04d:%02d:%02d", v3.tm_year + 1900, v3.tm_mon + 1, v3.tm_mday);
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], __str, 0x600u);
  }
  return result;
}

CFStringRef CreateGPSTimeStringWithXMPDateTimeString(const __CFString *a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  char v5 = 0;
  *(void *)__str = 0;
  memset(&v3, 0, sizeof(v3));
  int DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(a1, &v3, 0, 0);
  CFStringRef result = 0;
  if (DateTimeStructFromXMPDateTimeString)
  {
    snprintf(__str, 9uLL, "%02d:%02d:%02d", v3.tm_hour, v3.tm_min, v3.tm_sec);
    return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], __str, 0x600u);
  }
  return result;
}

uint64_t GetLegacyGPSFromXMPGPSCoordinate(void *a1, double *a2, unsigned char *a3)
{
  IIOString::IIOString((IIOString *)v17, a1);
  UTF8String = (char *)IIOString::createUTF8String((IIOString *)v17);
  IIOString::~IIOString((IIOString *)v17);
  uint64_t v16 = 0;
  v17[0] = 0;
  double v15 = 0.0;
  int v14 = 0;
  __int16 v13 = 0;
  if (UTF8String)
  {
    int v6 = sscanf(UTF8String, "%d,%2d,%2d%1[NSEW]", (char *)&v16 + 4, &v16, &v14, &v13);
    if (v6 <= 2)
    {
      int v10 = sscanf(UTF8String, "%d,%lf%1[NSEW]", (char *)&v16 + 4, &v15, &v13);
      if (v10 < 2)
      {
        int v11 = sscanf(UTF8String, "%lf", v17);
        uint64_t v9 = 0;
        if (!a2 || v11 != 1) {
          goto LABEL_16;
        }
        char v7 = 0;
        *a2 = *(double *)v17;
        goto LABEL_15;
      }
      if (a2)
      {
        *a2 = v15 / 60.0 + (double)SHIDWORD(v16);
        char v7 = v13;
        BOOL v8 = v10 == 3;
LABEL_9:
        if (!v8) {
          char v7 = 0;
        }
LABEL_15:
        *a3 = v7;
        uint64_t v9 = 1;
        goto LABEL_16;
      }
    }
    else if (a2)
    {
      *a2 = (double)(int)v16 / 60.0 + (double)SHIDWORD(v16) + (double)v14 / 3600.0;
      char v7 = v13;
      BOOL v8 = v6 == 4;
      goto LABEL_9;
    }
    uint64_t v9 = 0;
LABEL_16:
    free(UTF8String);
    return v9;
  }
  return 0;
}

void sub_1887B3B28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

CFArrayRef CreateGPSVersionArrayFromString(const __CFString *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)values = 0u;
  long long v22 = 0u;
  if (!a1
    || (CFTypeID v2 = CFGetTypeID(a1), v2 != CFStringGetTypeID())
    || (CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80],
        (CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a1, @".")) == 0))
  {
LABEL_23:
    CFArrayRef v11 = 0;
    goto LABEL_24;
  }
  CFArrayRef v5 = ArrayBySeparatingStrings;
  CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
  CFIndex v7 = Count;
  if (Count >= 2)
  {
    CFIndex v8 = 0;
    while (1)
    {
      valuePtr[0] = 0;
      if (v7 > v8)
      {
        ValueAtIndeCGFloat x = (const __CFString *)CFArrayGetValueAtIndex(v5, v8);
        valuePtr[0] = CFStringGetIntValue(ValueAtIndex);
      }
      CFNumberRef v10 = CFNumberCreate(v3, kCFNumberIntType, valuePtr);
      values[v8] = v10;
      if (!v10) {
        goto LABEL_23;
      }
      if (++v8 == 4)
      {
        CFArrayRef v11 = CFArrayCreate(v3, (const void **)values, 4, MEMORY[0x1E4F1D510]);
        goto LABEL_30;
      }
    }
  }
  if (Count == 1)
  {
    IIOString::IIOString((IIOString *)valuePtr, a1);
    UTF8String = (unsigned __int8 *)IIOString::createUTF8String((IIOString *)valuePtr);
    IIOString::~IIOString((IIOString *)valuePtr);
    CFIndex Length = CFStringGetLength(a1);
    if (UTF8String)
    {
      CFIndex v14 = Length;
      CFIndex v15 = 0;
      while (1)
      {
        if (v14 <= v15)
        {
          valuePtr[0] = 0;
          CFNumberRef v16 = CFNumberCreate(v3, kCFNumberIntType, valuePtr);
        }
        else
        {
          if (UTF8String[v15] - 48 >= 0xA)
          {
            CFNumberRef v16 = (CFNumberRef)values[v15];
            goto LABEL_20;
          }
          valuePtr[0] = UTF8String[v15] - 48;
          CFNumberRef v16 = CFNumberCreate(v3, kCFNumberIntType, valuePtr);
        }
        values[v15] = v16;
LABEL_20:
        if (!v16) {
          goto LABEL_23;
        }
        if (++v15 == 4)
        {
          CFArrayRef v11 = CFArrayCreate(v3, (const void **)values, 4, MEMORY[0x1E4F1D510]);
          free(UTF8String);
          goto LABEL_30;
        }
      }
    }
  }
  CFArrayRef v11 = 0;
LABEL_30:
  CFRelease(v5);
LABEL_24:
  for (uint64_t i = 0; i != 4; ++i)
  {
    CFArrayRef v18 = values[i];
    if (v18) {
      CFRelease(v18);
    }
  }
  return v11;
}

void sub_1887B3D7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

CFDataRef CGImageMetadataCreateEXIFData(void *a1)
{
  CFIndex length = 0;
  if (!a1) {
    return 0;
  }
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CGImageMetadataGetTypeID()) {
    return 0;
  }
  CFAllocatorRef v3 = (IIODictionary *)CGImagePropertiesCreateFromMetadata(a1);
  if (!v3) {
    return 0;
  }
  CFStringRef v4 = v3;
  ExifBufferFromPropertiesJPEG = (const UInt8 *)CreateExifBufferFromPropertiesJPEG(v3, 0, 0, 0, 0, @"public.jpeg", (unint64_t *)&length);
  int v6 = (UInt8 *)ExifBufferFromPropertiesJPEG;
  if (!length)
  {
    CFDataRef v7 = 0;
    if (!ExifBufferFromPropertiesJPEG) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  CFDataRef v7 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], ExifBufferFromPropertiesJPEG, length);
  if (v6) {
LABEL_6:
  }
    free(v6);
LABEL_7:
  (*(void (**)(IIODictionary *))(*(void *)v4 + 8))(v4);
  return v7;
}

CFDataRef CGImageMetadataCreateXMPWithEXIFFiltered(const CGImageMetadata *a1)
{
  kdebug_trace();
  CFTypeID v2 = CGImageMetadataCreateWithEXIFFiltered(a1, 0);
  if (v2)
  {
    CFAllocatorRef v3 = v2;
    CFDataRef XMPData = CGImageMetadataCreateXMPData((CGImageMetadataRef)v2, 0);
    CFRelease(v3);
    if (XMPData) {
      CFDataGetLength(XMPData);
    }
  }
  else
  {
    CFDataRef XMPData = 0;
  }
  kdebug_trace();
  return XMPData;
}

CFDictionaryRef *CGImageMetadataCreateWithEXIFFiltered(const CGImageMetadata *a1, int a2)
{
  if (!a1) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CGImageMetadataGetTypeID()) {
    return 0;
  }
  MutableCopCGFloat y = CGImageMetadataCreateMutableCopy(a1);
  int v6 = (CFDictionaryRef *)MutableCopy;
  if (MutableCopy)
  {
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___ZL37CGImageMetadataCreateWithEXIFFilteredPK15CGImageMetadatab_block_invoke;
    block[3] = &__block_descriptor_tmp_484;
    block[4] = MutableCopy;
    CGImageMetadataEnumerateTagsUsingBlock(a1, 0, 0, block);
    CFDataRef v7 = CGImageMetadataCopyTagWithPath((CGImageMetadataRef)v6, 0, @"dc:description");
    CFIndex v8 = CGImageMetadataCopyTagWithPath((CGImageMetadataRef)v6, 0, @"dc:rights");
    uint64_t v9 = CGImageMetadataCopyTagWithPath((CGImageMetadataRef)v6, 0, @"dc:creator");
    CFNumberRef v10 = CGImageMetadataCopyTagWithPath((CGImageMetadataRef)v6, 0, @"xmp:CreatorTool");
    CFArrayRef v11 = CGImageMetadataCopyTagWithPath((CGImageMetadataRef)v6, 0, @"photoshop:DateCreated");
    CFNumberRef v12 = CGImageMetadataCopyTagWithPath((CGImageMetadataRef)v6, 0, @"xmp:CreateDate");
    __int16 v13 = CGImageMetadataCopyTagWithPath((CGImageMetadataRef)v6, 0, @"xmp:ModifyDate");
    uint64_t Source = CGImageSourceGetSource((uint64_t)v7);
    uint64_t v30 = CGImageSourceGetSource((uint64_t)v8);
    if (v7) {
      CGImageMetadataRemoveTagWithPath((CGMutableImageMetadataRef)v6, 0, @"dc:description");
    }
    if (v8) {
      CGImageMetadataRemoveTagWithPath((CGMutableImageMetadataRef)v6, 0, @"dc:rights");
    }
    if (v9) {
      CGImageMetadataRemoveTagWithPath((CGMutableImageMetadataRef)v6, 0, @"dc:creator");
    }
    if (v10) {
      CGImageMetadataRemoveTagWithPath((CGMutableImageMetadataRef)v6, 0, @"xmp:CreatorTool");
    }
    if (v11) {
      CGImageMetadataRemoveTagWithPath((CGMutableImageMetadataRef)v6, 0, @"photoshop:DateCreated");
    }
    if (v12) {
      CGImageMetadataRemoveTagWithPath((CGMutableImageMetadataRef)v6, 0, @"xmp:CreateDate");
    }
    if (v13) {
      CGImageMetadataRemoveTagWithPath((CGMutableImageMetadataRef)v6, 0, @"xmp:ModifyDate");
    }
    if (v7 && (CFIndex v15 = *(const void **)(Source + 48)) != 0)
    {
      CFMutableDictionaryRef v28 = v12;
      CFNumberRef v16 = v11;
      CFTypeID v17 = v10;
      CFArrayRef v18 = v9;
      CFTypeID v19 = CFGetTypeID(v15);
      BOOL v20 = v19 != CFArrayGetTypeID() || CFArrayGetCount(*(CFArrayRef *)(Source + 48)) < 2;
      uint64_t v9 = v18;
      CFNumberRef v10 = v17;
      CFArrayRef v11 = v16;
      CFNumberRef v12 = v28;
      if (v8)
      {
LABEL_28:
        long long v22 = *(const void **)(v30 + 48);
        if (v22)
        {
          int v29 = v12;
          uint64_t v23 = v11;
          CFStringRef v24 = v10;
          CFStringRef v25 = v9;
          CFTypeID v26 = CFGetTypeID(v22);
          if (v26 == CFArrayGetTypeID() && CFArrayGetCount(*(CFArrayRef *)(v30 + 48)) >= 2) {
            BOOL v20 = 0;
          }
          uint64_t v9 = v25;
          CFNumberRef v10 = v24;
          CFArrayRef v11 = v23;
          CFNumberRef v12 = v29;
        }
      }
    }
    else
    {
      BOOL v20 = 1;
      if (v8) {
        goto LABEL_28;
      }
    }
    BOOL v27 = CFDictionaryGetCount(v6[3]) < 1 && v20;
    if (a2
      && (unint64_t)v7 | (unint64_t)v8 | (unint64_t)v9 | (unint64_t)v10 | (unint64_t)v11 | (unint64_t)v12 | (unint64_t)v13)
    {
      BOOL v27 = 0;
    }
    if (v27)
    {
      CFRelease(v6);
      int v6 = 0;
    }
    else
    {
      if (v7) {
        CGImageMetadataSetTagWithPath((CGMutableImageMetadataRef)v6, 0, @"dc:description", v7);
      }
      if (v8) {
        CGImageMetadataSetTagWithPath((CGMutableImageMetadataRef)v6, 0, @"dc:rights", v8);
      }
      if (v9) {
        CGImageMetadataSetTagWithPath((CGMutableImageMetadataRef)v6, 0, @"dc:creator", v9);
      }
      if (v10) {
        CGImageMetadataSetTagWithPath((CGMutableImageMetadataRef)v6, 0, @"xmp:CreatorTool", v10);
      }
      if (v11) {
        CGImageMetadataSetTagWithPath((CGMutableImageMetadataRef)v6, 0, @"photoshop:DateCreated", v11);
      }
      if (v12) {
        CGImageMetadataSetTagWithPath((CGMutableImageMetadataRef)v6, 0, @"xmp:CreateDate", v12);
      }
      if (v13) {
        CGImageMetadataSetTagWithPath((CGMutableImageMetadataRef)v6, 0, @"xmp:ModifyDate", v13);
      }
    }
    if (v7) {
      CFRelease(v7);
    }
    if (v8) {
      CFRelease(v8);
    }
    if (v9) {
      CFRelease(v9);
    }
    if (v10) {
      CFRelease(v10);
    }
    if (v11) {
      CFRelease(v11);
    }
    if (v12) {
      CFRelease(v12);
    }
    if (v13) {
      CFRelease(v13);
    }
  }
  return v6;
}

CFDictionaryRef *CGImageMetadataCreateExtendedXMPWithEXIFFiltered(const CGImageMetadata *a1, CFDataRef *a2, CFDataRef *a3, CFDataRef *a4, int a5)
{
  CFStringRef result = CGImageMetadataCreateWithEXIFFiltered(a1, a5);
  if (result)
  {
    uint64_t v9 = result;
    BOOL SerializedDataAndExtendedData = CGImageMetadataCreateSerializedDataAndExtendedData((const CGImageMetadata *)result, a2, a3, a4);
    CFRelease(v9);
    return (CFDictionaryRef *)SerializedDataAndExtendedData;
  }
  return result;
}

BOOL CGImageMetadataCreateSerializedDataAndExtendedData(const CGImageMetadata *a1, CFDataRef *a2, CFDataRef *a3, CFDataRef *a4)
{
  CFIndex v15 = 0;
  bytes = 0;
  CFIndex length = 0;
  CFIndex v14 = 0;
  CFIndex v11 = 0;
  CFIndex v12 = 0;
  BOOL v4 = a1 != 0;
  if (a1)
  {
    SerializeMetadataForJPEGXMP(a1, (char **)&bytes, &length, (char **)&v15, &v12, (char **)&v14, &v11);
    if (!bytes)
    {
      BOOL v4 = 0;
      goto LABEL_13;
    }
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    *a2 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, length);
    if (v15 && v12 > 1)
    {
      CFDataRef v9 = CFDataCreate(v8, v15, v12);
      *a3 = v9;
      if (!v9) {
        goto LABEL_11;
      }
    }
    else if (!*a3)
    {
      goto LABEL_11;
    }
    if (v14 && v11 >= 2) {
      *a4 = CFDataCreate(v8, v14, v11);
    }
  }
LABEL_11:
  if (bytes) {
    free(bytes);
  }
LABEL_13:
  if (v15) {
    free(v15);
  }
  if (v14) {
    free(v14);
  }
  return v4;
}

void CGImageMetadataRemoveGPS(uint64_t a1)
{
  uint64_t v2 = 0;
  v3[31] = *MEMORY[0x1E4F143B8];
  v3[0] = @"GPSAltitude";
  v3[1] = @"GPSAltitudeRef";
  v3[2] = @"GPSAreaInformation";
  v3[3] = @"GPSDestBearing";
  v3[4] = @"GPSDestBearingRef";
  v3[5] = @"GPSDestDistance";
  v3[6] = @"GPSDestDistanceRef";
  v3[7] = @"GPSDestLatitude";
  v3[8] = @"GPSDestLatitudeRef";
  v3[9] = @"GPSDestLongitude";
  v3[10] = @"GPSDestLongitudeRef";
  v3[11] = @"GPSDifferential";
  v3[12] = @"GPSHPositioningError";
  v3[13] = @"GPSDOP";
  v3[14] = @"GPSImgDirection";
  v3[15] = @"GPSImgDirectionRef";
  v3[16] = @"GPSLatitude";
  v3[17] = @"GPSLatitudeRef";
  v3[18] = @"GPSLongitude";
  v3[19] = @"GPSLongitudeRef";
  v3[20] = @"GPSMapDatum";
  v3[21] = @"GPSMeasureMode";
  v3[22] = @"GPSProcessingMethod";
  v3[23] = @"GPSSatellites";
  v3[24] = @"GPSSpeed";
  v3[25] = @"GPSSpeedRef";
  v3[26] = @"GPSStatus";
  v3[27] = @"GPSTimeStamp";
  v3[28] = @"GPSTrack";
  v3[29] = @"GPSTrackRef";
  v3[30] = @"GPSVersionID";
  do
    CGImageMetadataRemoveTopLevelTag(a1, @"http://ns.adobe.com/exif/1.0/", v3[v2++]);
  while (v2 != 31);
}

void CGImageMetadataRemoveTopLevelTag(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a2)
  {
    if (a3)
    {
      key[1] = a3;
      key[2] = 0;
      key[0] = a2;
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 24), key);
    }
  }
}

__CFDictionary *CreateXMPFlashStructFromInt(unsigned int a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (Mutable)
  {
    BOOL v4 = (a1 & 1) != 0 ? @"True" : @"False";
    CGImageMetadataTagRef v5 = CGImageMetadataTagCreate(@"http://ns.adobe.com/exif/1.0/", @"exif", @"Fired", kCGImageMetadataTypeString, v4);
    if (v5)
    {
      CGImageMetadataTagRef v6 = v5;
      CFDictionarySetValue(Mutable, @"Fired", v5);
      CFRelease(v6);
      CFStringRef v7 = CFStringCreateWithFormat(v2, 0, @"%d", (a1 >> 1) & 3);
      if (v7)
      {
        CFAllocatorRef v8 = v7;
        CGImageMetadataTagRef v9 = CGImageMetadataTagCreate(@"http://ns.adobe.com/exif/1.0/", @"exif", @"Return", kCGImageMetadataTypeString, v7);
        if (!v9) {
          goto LABEL_19;
        }
        CGImageMetadataTagRef v10 = v9;
        CFDictionarySetValue(Mutable, @"Return", v9);
        CFRelease(v10);
        CFRelease(v8);
        CFStringRef v11 = CFStringCreateWithFormat(v2, 0, @"%d", (a1 >> 3) & 3);
        if (!v11) {
          return Mutable;
        }
        CFAllocatorRef v8 = v11;
        CGImageMetadataTagRef v12 = CGImageMetadataTagCreate(@"http://ns.adobe.com/exif/1.0/", @"exif", @"Mode", kCGImageMetadataTypeString, v11);
        if (!v12)
        {
LABEL_19:
          CFRelease(v8);
          return Mutable;
        }
        CGImageMetadataTagRef v13 = v12;
        CFDictionarySetValue(Mutable, @"Mode", v12);
        CFRelease(v13);
        CFRelease(v8);
        if ((a1 & 0x20) != 0) {
          CFIndex v14 = @"True";
        }
        else {
          CFIndex v14 = @"False";
        }
        CGImageMetadataTagRef v15 = CGImageMetadataTagCreate(@"http://ns.adobe.com/exif/1.0/", @"exif", @"Function", kCGImageMetadataTypeString, v14);
        if (v15)
        {
          CGImageMetadataTagRef v16 = v15;
          CFDictionarySetValue(Mutable, @"Function", v15);
          CFRelease(v16);
          CFTypeID v17 = (a1 & 0x40) != 0 ? @"True" : @"False";
          CGImageMetadataTagRef v18 = CGImageMetadataTagCreate(@"http://ns.adobe.com/exif/1.0/", @"exif", @"RedEyeMode", kCGImageMetadataTypeString, v17);
          if (v18)
          {
            CFAllocatorRef v8 = v18;
            CFDictionarySetValue(Mutable, @"RedEyeMode", v18);
            goto LABEL_19;
          }
        }
      }
    }
  }
  return Mutable;
}

void CGImageMetadataCreateAndLogUTF8Error(const char *a1, int a2, int a3, char *a4, CFErrorRef *a5)
{
  userInfoKeys[1] = *(void **)MEMORY[0x1E4F143B8];
  LogError(a1, a2, a4);
  if (a5)
  {
    CFAllocatorRef v8 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CGImageMetadataTagRef v9 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a4, 0x8000100u);
    if (v9)
    {
      CGImageMetadataTagRef v10 = v9;
      CFStringRef v11 = (void *)*MEMORY[0x1E4F1D140];
      userInfoValues = v9;
      userInfoKeys[0] = v11;
      *a5 = CFErrorCreateWithUserInfoKeysAndValues(v8, @"kCFErrorDomainCGImageMetadata", a3, (const void *const *)userInfoKeys, (const void *const *)&userInfoValues, 1);
      CFRelease(v10);
    }
  }
}

void CGImageMetadataCreateAndLogError(const char *a1, int a2, void *a3, CFErrorRef *a4)
{
  userInfoValues[1] = *(void **)MEMORY[0x1E4F143B8];
  IIOString::IIOString((IIOString *)userInfoKeys, a3);
  UTF8String = (char *)IIOString::createUTF8String((IIOString *)userInfoKeys);
  IIOString::~IIOString((IIOString *)userInfoKeys);
  if (UTF8String)
  {
    LogError(a1, 0, UTF8String);
    free(UTF8String);
  }
  if (a4)
  {
    userInfoKeys[0] = *(void **)MEMORY[0x1E4F1D140];
    userInfoValues[0] = a3;
    *a4 = CFErrorCreateWithUserInfoKeysAndValues((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"kCFErrorDomainCGImageMetadata", a2, (const void *const *)userInfoKeys, (const void *const *)userInfoValues, 1);
  }
}

void sub_1887B4BA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

CFStringRef CreateXMPDateTimeWithXMPOrExifDateTimeString(const __CFString *a1)
{
  *(_WORD *)CGImageMetadataTagRef v5 = 0;
  memset(&v4, 0, sizeof(v4));
  int DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(a1, &v4, &v5[1], v5);
  CFStringRef result = 0;
  if (DateTimeStructFromXMPDateTimeString)
  {
    if (v5[1])
    {
      if (v5[0])
      {
        LODWORD(v3) = v4.tm_gmtoff % 3600 / 60;
        if ((int)v3 >= 0) {
          uint64_t v3 = v3;
        }
        else {
          uint64_t v3 = (v4.tm_gmtoff % 3600 / -60);
        }
        return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%04d-%02d-%02dT%02d:%02d:%02d%+03d:%02d", (v4.tm_year + 1900), (v4.tm_mon + 1), v4.tm_mday, v4.tm_hour, v4.tm_min, v4.tm_sec, v4.tm_gmtoff / 3600, v3);
      }
      else
      {
        return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%04d-%02d-%02dT%02d:%02d:%02d", (v4.tm_year + 1900), (v4.tm_mon + 1), v4.tm_mday, v4.tm_hour, v4.tm_min, v4.tm_sec);
      }
    }
    else
    {
      return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%04d-%02d-%02d", (v4.tm_year + 1900), (v4.tm_mon + 1), v4.tm_mday);
    }
  }
  return result;
}

CFStringRef CreateXMPDateFromEXIFGPSDateAndTime(const __CFString *a1, const __CFString *a2)
{
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  unsigned int v18 = 0;
  double v17 = 0.0;
  if (!a1) {
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  CFTypeID TypeID = CFStringGetTypeID();
  CFStringRef v6 = 0;
  if (a2 && v4 == TypeID)
  {
    CFTypeID v7 = CFGetTypeID(a2);
    if (v7 == CFStringGetTypeID())
    {
      CFIndex v8 = CFStringGetLength(a1) + 1;
      CGImageMetadataTagRef v9 = (char *)malloc_type_malloc(v8, 0xCC34E93AuLL);
      if (v9)
      {
        CGImageMetadataTagRef v10 = v9;
        if (!CFStringGetCString(a1, v9, v8, 0x600u)
          || sscanf(v10, "%04d:%02d:%02d", (char *)&v20 + 4, &v20, (char *)&v19 + 4) != 3)
        {
          goto LABEL_18;
        }
        CFIndex v11 = CFStringGetLength(a2) + 1;
        CGImageMetadataTagRef v12 = (char *)reallocf(v10, v11);
        if (v12)
        {
          CGImageMetadataTagRef v10 = v12;
          CFStringGetCString(a2, v12, v11, 0x600u);
          if (sscanf(v10, "%02d:%02d:%lf", &v19, &v18, &v17) == 3)
          {
            if (v17 - (double)(int)v17 <= 1.0e-10)
            {
              CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%04d-%02d-%02dT%02d:%02d:%02d+0000", HIDWORD(v20), v20, HIDWORD(v19), v19, v18, (int)v17);
              goto LABEL_19;
            }
            __s = 0;
            asprintf(&__s, "%012.9f", v17);
            CGImageMetadataTagRef v13 = __s;
            if (__s)
            {
              size_t v14 = strlen(__s) - 1;
              if (v14 >= 4)
              {
                while (1)
                {
                  CGImageMetadataTagRef v13 = __s;
                  if (__s[v14] != 48) {
                    break;
                  }
                  __s[v14--] = 0;
                  if (v14 <= 3)
                  {
                    CGImageMetadataTagRef v13 = __s;
                    break;
                  }
                }
              }
              CFStringRef v6 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%04d-%02d-%02dT%02d:%02d:%s+0000", HIDWORD(v20), v20, HIDWORD(v19), v19, v18, v13);
              free(__s);
              goto LABEL_19;
            }
          }
LABEL_18:
          CFStringRef v6 = 0;
LABEL_19:
          free(v10);
          return v6;
        }
      }
    }
    return 0;
  }
  return v6;
}

CFStringRef CreateIPTCDateFromExifDateTime(void *a1)
{
  if (!a1) {
    return 0;
  }
  memset(v5, 0, sizeof(v5));
  CFArrayRef v1 = IIOString::IIOString((IIOString *)v5, a1);
  CFAllocatorRef v2 = (const char *)IIOString::utf8String(v1);
  if (strlen(v2) == 19) {
    CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%c%c%c%c%c%c%c%c", *v2, v2[1], v2[2], v2[3], v2[5], v2[6], v2[8], v2[9]);
  }
  else {
    CFStringRef v3 = 0;
  }
  IIOString::~IIOString((IIOString *)v5);
  return v3;
}

void sub_1887B501C(_Unwind_Exception *a1)
{
  IIOString::~IIOString((IIOString *)(v1 - 40));
  _Unwind_Resume(a1);
}

CFStringRef CreateIPTCTimeFromExifDateTime(void *a1)
{
  if (!a1) {
    return 0;
  }
  memset(v5, 0, sizeof(v5));
  uint64_t v1 = IIOString::IIOString((IIOString *)v5, a1);
  CFStringRef v2 = IIOString::utf8String(v1);
  if (strlen((const char *)v2) == 19) {
    CFStringRef v3 = CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%c%c%c%c%c%c", SBYTE3(v2->info), SBYTE4(v2->info), SBYTE6(v2->info), SHIBYTE(v2->info), SBYTE1(v2->data), SBYTE2(v2->data));
  }
  else {
    CFStringRef v3 = 0;
  }
  IIOString::~IIOString((IIOString *)v5);
  return v3;
}

void sub_1887B50E0(_Unwind_Exception *a1)
{
  IIOString::~IIOString((IIOString *)(v1 - 40));
  _Unwind_Resume(a1);
}

CFStringRef CreateXMPDateFromXMPDateTimeAndSubsecTime(const __CFString *cf, uint64_t a2)
{
  CFStringRef result = 0;
  *(_WORD *)CFTypeID v7 = 0;
  if (cf)
  {
    if (a2)
    {
      memset(&v8, 0, sizeof(v8));
      int DateTimeStructFromXMPDateTimeString = GetDateTimeStructFromXMPDateTimeString(cf, &v8, &v7[1], v7);
      CFStringRef result = 0;
      if (DateTimeStructFromXMPDateTimeString)
      {
        if (v7[1])
        {
          if (v7[0])
          {
            LODWORD(v6) = v8.tm_gmtoff % 3600 / 60;
            if ((int)v6 >= 0) {
              uint64_t v6 = v6;
            }
            else {
              uint64_t v6 = (v8.tm_gmtoff % 3600 / -60);
            }
            return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%04d-%02d-%02dT%02d:%02d:%02d.%@%+03d:%02d", (v8.tm_year + 1900), (v8.tm_mon + 1), v8.tm_mday, v8.tm_hour, v8.tm_min, v8.tm_sec, a2, v8.tm_gmtoff / 3600, v6);
          }
          else
          {
            return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"%04d-%02d-%02dT%02d:%02d:%02d.%@", (v8.tm_year + 1900), (v8.tm_mon + 1), v8.tm_mday, v8.tm_hour, v8.tm_min, v8.tm_sec, a2);
          }
        }
      }
    }
  }
  return result;
}

CFNumberRef CreateIntValueFromField(const __CFDictionary *a1, const void *a2)
{
  CFNumberRef result = (CFNumberRef)CFDictionaryGetValue(a1, a2);
  if (result)
  {
    CFStringRef v3 = (const __CFString *)result;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 == CGImageMetadataTagGetTypeID())
    {
      CFStringRef v3 = *(const __CFString **)(CGImageSourceGetSource((uint64_t)v3) + 48);
      if (!v3) {
        return 0;
      }
    }
    else
    {
      CFTypeID v5 = CFGetTypeID(v3);
      if (v5 != CFStringGetTypeID()) {
        return 0;
      }
    }
    CFTypeID v6 = CFGetTypeID(v3);
    if (v6 == CFStringGetTypeID())
    {
      SInt32 valuePtr = CFStringGetIntValue(v3);
      return CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
    }
    return 0;
  }
  return result;
}

CFNumberRef CreateFloatValueFromField(const __CFDictionary *a1, const void *a2)
{
  CFNumberRef result = (CFNumberRef)CFDictionaryGetValue(a1, a2);
  if (result)
  {
    CFStringRef v3 = (const __CFString *)result;
    CFTypeID v4 = CFGetTypeID(result);
    if (v4 == CGImageMetadataTagGetTypeID())
    {
      CFStringRef v3 = *(const __CFString **)(CGImageSourceGetSource((uint64_t)v3) + 48);
      if (!v3) {
        return 0;
      }
    }
    else
    {
      CFTypeID v5 = CFGetTypeID(v3);
      if (v5 != CFStringGetTypeID()) {
        return 0;
      }
    }
    CFTypeID v6 = CFGetTypeID(v3);
    if (v6 == CFStringGetTypeID())
    {
      double valuePtr = CFStringGetDoubleValue(v3);
      return CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberDoubleType, &valuePtr);
    }
    return 0;
  }
  return result;
}

void ___ZL24IIOXPCDecodeMetadataTagsP8IIOArrayP15CGImageMetadata_block_invoke(uint64_t a1, const __CFDictionary *a2)
{
  memset(v4, 0, sizeof(v4));
  IIODictionary::IIODictionary((IIODictionary *)v4, a2);
  CGImageMetadataTagRef v3 = IIOXPCDecodeCGImageMetadataTag((IIODictionary *)v4);
  if (v3)
  {
    CGImageMetadataAddTag(*(void *)(a1 + 32), v3);
    CFRelease(v3);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v4);
}

void sub_1887B5408(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CGImageMetadataTagRef IIOXPCDecodeCGImageMetadataTag(IIODictionary *a1)
{
  CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a1, @"nameSpace");
  CFStringRef v3 = (const __CFString *)IIODictionary::getObjectForKey(a1, @"prefix");
  CFStringRef v4 = (const __CFString *)IIODictionary::getObjectForKey(a1, @"name");
  CGImageMetadataType Uint32ForKey = IIODictionary::getUint32ForKey(a1, @"metadataType");
  CFDictionaryRef v6 = IIODictionary::getObjectForKey(a1, @"value");
  if (Uint32ForKey <= kCGImageMetadataTypeString)
  {
    CGImageMetadataTagRef v7 = CGImageMetadataTagCreate(ObjectForKey, v3, v4, Uint32ForKey, v6);
    if (!v7) {
      return v7;
    }
    goto LABEL_9;
  }
  CFTypeID TypeID = CFArrayGetTypeID();
  if (TypeID == CFGetTypeID(v6))
  {
    uint64_t v20 = 0;
    CFMutableArrayRef v21 = &v20;
    uint64_t v22 = 0x4002000000;
    uint64_t v23 = __Block_byref_object_copy__1;
    CFStringRef v24 = __Block_byref_object_dispose__1;
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    IIOArray::IIOArray((IIOArray *)&v25);
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    IIOArray::IIOArray((IIOArray *)&v17, v6);
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 0x40000000;
    v16[2] = ___ZL30IIOXPCDecodeCGImageMetadataTagP13IIODictionary_block_invoke;
    v16[3] = &unk_1E53CCAD8;
    v16[4] = &v20;
    IIOArray::enumerate((uint64_t)&v17, (uint64_t)v16);
    CGImageMetadataTagRef v7 = CGImageMetadataTagCreate(ObjectForKey, v3, v4, Uint32ForKey, (CFTypeRef)v21[6]);
    IIOArray::~IIOArray((IIOArray *)&v17);
    _Block_object_dispose(&v20, 8);
    IIOArray::~IIOArray((IIOArray *)&v25);
    if (!v7) {
      return v7;
    }
LABEL_9:
    int v10 = IIODictionary::getUint32ForKey(a1, @"sourceType");
    CGImageMetadataTagSetSource((uint64_t)v7, v10);
    CFDictionaryRef v11 = IIODictionary::getObjectForKey(a1, @"qualifiers");
    if (v11)
    {
      CFArrayRef v12 = v11;
      uint64_t Source = CGImageSourceGetSource((uint64_t)v7);
      if (Source) {
        *(void *)(Source + 56) = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v12);
      }
    }
    return v7;
  }
  CFTypeID v9 = CFDictionaryGetTypeID();
  if (v9 != CFGetTypeID(v6)) {
    return 0;
  }
  uint64_t v20 = 0;
  CFMutableArrayRef v21 = &v20;
  uint64_t v22 = 0x4002000000;
  uint64_t v23 = __Block_byref_object_copy__360;
  CFStringRef v24 = __Block_byref_object_dispose__361;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v25);
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v17, v6);
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 0x40000000;
  _OWORD v15[2] = ___ZL30IIOXPCDecodeCGImageMetadataTagP13IIODictionary_block_invoke_362;
  void v15[3] = &unk_1E53CCB00;
  v15[4] = &v20;
  IIODictionary::enumerate((uint64_t)&v17, v15);
  CGImageMetadataTagRef v7 = CGImageMetadataTagCreate(ObjectForKey, v3, v4, Uint32ForKey, (CFTypeRef)v21[6]);
  IIODictionary::~IIODictionary((IIODictionary *)&v17);
  _Block_object_dispose(&v20, 8);
  IIODictionary::~IIODictionary((IIODictionary *)&v25);
  if (v7) {
    goto LABEL_9;
  }
  return v7;
}

void sub_1887B5778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  IIODictionary::~IIODictionary(v15);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__1(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = &unk_1ED4E5BB8;
  uint64_t v2 = *(void *)(a2 + 48);
  *(unsigned char *)(result + 56) = *(unsigned char *)(a2 + 56);
  *(void *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
}

void ___ZL30IIOXPCDecodeCGImageMetadataTagP13IIODictionary_block_invoke(uint64_t a1, const __CFDictionary *a2)
{
  memset(v4, 0, sizeof(v4));
  IIODictionary::IIODictionary((IIODictionary *)v4, a2);
  CFStringRef v3 = (const void *)IIOXPCDecodeCGImageMetadataTag((IIODictionary *)v4);
  IIOArray::addObject((CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), v3);
  CFRelease(v3);
  IIODictionary::~IIODictionary((IIODictionary *)v4);
}

void sub_1887B5878(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

IIODictionary *__Block_byref_object_copy__360(uint64_t a1, uint64_t a2)
{
  return IIODictionary::IIODictionary((IIODictionary *)(a1 + 40), (const IIODictionary *)(a2 + 40));
}

void __Block_byref_object_dispose__361(uint64_t a1)
{
}

void ___ZL30IIOXPCDecodeCGImageMetadataTagP13IIODictionary_block_invoke_362(uint64_t a1, const __CFString *a2, __CFDictionary *a3)
{
  memset(v6, 0, sizeof(v6));
  IIODictionary::IIODictionary((IIODictionary *)v6, a3);
  CFTypeID v5 = (const void *)IIOXPCDecodeCGImageMetadataTag((IIODictionary *)v6);
  IIODictionary::setObjectForKey((IIODictionary *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), v5, a2);
  CFRelease(v5);
  IIODictionary::~IIODictionary((IIODictionary *)v6);
}

void sub_1887B591C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZL24IIOXPCEncodeMetadataTagsPK15CGImageMetadataP8IIOArray_block_invoke(uint64_t a1, uint64_t a2, CGImageMetadataTag *a3)
{
  return 1;
}

void IIOXPCEncodeMetadataTag(CGImageMetadataTag *a1, CFMutableArrayRef *a2)
{
  uint64_t Source = CGImageSourceGetSource((uint64_t)a1);
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v25);
  IIODictionary::setObjectForKey(v4, *(const void **)(Source + 16), @"nameSpace");
  IIODictionary::setObjectForKey((IIODictionary *)&v25, *(const void **)(Source + 24), @"prefix");
  IIODictionary::setObjectForKey((IIODictionary *)&v25, *(const void **)(Source + 32), @"name");
  IIODictionary::setObjectForKey((IIODictionary *)&v25, *(const void **)(Source + 56), @"qualifiers");
  int v5 = *(_DWORD *)(Source + 40);
  IIONumber::IIONumber((IIONumber *)&v17, v5);
  IIODictionary::setObjectForKey((IIODictionary *)&v25, value, @"metadataType");
  IIONumber::~IIONumber((IIONumber *)&v17);
  IIONumber::IIONumber((IIONumber *)&v17, *(_DWORD *)(Source + 68));
  IIODictionary::setObjectForKey((IIODictionary *)&v25, value, @"sourceType");
  IIONumber::~IIONumber((IIONumber *)&v17);
  CFArrayRef v6 = *(const __CFArray **)(Source + 48);
  if (v5 > 1)
  {
    CFTypeID TypeID = CFArrayGetTypeID();
    if (TypeID == CFGetTypeID(v6))
    {
      uint64_t v17 = 0;
      uint64_t v18 = &v17;
      xpc_object_t value = (void *)0x4002000000;
      uint64_t v20 = __Block_byref_object_copy__1;
      CFMutableArrayRef v21 = __Block_byref_object_dispose__1;
      uint64_t v22 = 0;
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      IIOArray::IIOArray((IIOArray *)&v22);
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      uint64_t v16 = 0;
      IIOArray::IIOArray((IIOArray *)&v14, v6);
      v13[0] = MEMORY[0x1E4F143A8];
      v13[1] = 0x40000000;
      v13[2] = ___ZL23IIOXPCEncodeMetadataTagP18CGImageMetadataTagP8IIOArray_block_invoke;
      _OWORD v13[3] = &unk_1E53CCB48;
      v13[4] = &v17;
      IIOArray::enumerate((uint64_t)&v14, (uint64_t)v13);
      IIODictionary::setObjectForKey((IIODictionary *)&v25, (const void *)v18[6], @"value");
      IIOArray::~IIOArray((IIOArray *)&v14);
      _Block_object_dispose(&v17, 8);
      IIOArray::~IIOArray((IIOArray *)&v22);
    }
    else
    {
      CFTypeID v8 = CFDictionaryGetTypeID();
      if (v8 == CFGetTypeID(v6))
      {
        uint64_t v17 = 0;
        uint64_t v18 = &v17;
        xpc_object_t value = (void *)0x4002000000;
        uint64_t v20 = __Block_byref_object_copy__360;
        CFMutableArrayRef v21 = __Block_byref_object_dispose__361;
        uint64_t v22 = 0;
        uint64_t v23 = 0;
        uint64_t v24 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v22);
        uint64_t v14 = 0;
        uint64_t v15 = 0;
        uint64_t v16 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v14, v6);
        v12[0] = MEMORY[0x1E4F143A8];
        v12[1] = 0x40000000;
        v12[2] = ___ZL23IIOXPCEncodeMetadataTagP18CGImageMetadataTagP8IIOArray_block_invoke_2;
        v12[3] = &unk_1E53CCB70;
        v12[4] = &v17;
        IIODictionary::enumerate((uint64_t)&v14, v12);
        IIODictionary::setObjectForKey((IIODictionary *)&v25, (const void *)v18[6], @"value");
        IIODictionary::~IIODictionary((IIODictionary *)&v14);
        _Block_object_dispose(&v17, 8);
        IIODictionary::~IIODictionary((IIODictionary *)&v22);
      }
      else
      {
        CFShow(v6);
        CFTypeID v9 = CFGetTypeID(v6);
        CFStringRef v10 = CFCopyTypeIDDescription(v9);
        IIOString::IIOString((IIOString *)&v17, v10);
        CFDictionaryRef v11 = (const char *)IIOString::utf8String((IIOString *)&v17);
        LogError("IIOXPCEncodeMetadataTag", 125, "*** failed to serialize metadata = %s\n", v11);
        IIOString::~IIOString((IIOString *)&v17);
      }
    }
  }
  else
  {
    IIODictionary::setObjectForKey((IIODictionary *)&v25, v6, @"value");
  }
  IIOArray::addObject(a2, v26);
  IIODictionary::~IIODictionary((IIODictionary *)&v25);
}

void sub_1887B5CD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  _Block_object_dispose(va, 8);
  IIODictionary::~IIODictionary(v16);
  IIODictionary::~IIODictionary((IIODictionary *)(v17 - 56));
  _Unwind_Resume(a1);
}

void ___ZL23IIOXPCEncodeMetadataTagP18CGImageMetadataTagP8IIOArray_block_invoke(uint64_t a1, CGImageMetadataTag *a2)
{
  CFTypeID TypeID = CGImageMetadataTagGetTypeID();
  if (TypeID == CFGetTypeID(a2))
  {
    int v5 = (IIOArray *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
    IIOXPCEncodeMetadataTag(a2, v5);
  }
  else
  {
    CFTypeID v6 = CFGetTypeID(a2);
    CFStringRef v7 = CFCopyTypeIDDescription(v6);
    IIOString::IIOString((IIOString *)v9, v7);
    CFTypeID v8 = (const char *)IIOString::utf8String((IIOString *)v9);
    LogError("IIOXPCEncodeMetadataTag_block_invoke", 97, "*** unexpected type in array: %s\n", v8);
    IIOString::~IIOString((IIOString *)v9);
  }
}

void sub_1887B5E44(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void ___ZL23IIOXPCEncodeMetadataTagP18CGImageMetadataTagP8IIOArray_block_invoke_2(uint64_t a1, const __CFString *a2, CGImageMetadataTag *a3)
{
  memset(v13, 0, sizeof(v13));
  IIOArray::IIOArray((IIOArray *)v13);
  CFTypeID TypeID = CGImageMetadataTagGetTypeID();
  if (TypeID == CFGetTypeID(a3))
  {
    IIOXPCEncodeMetadataTag(a3, (IIOArray *)v13);
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    ObjectAtIndeCGFloat x = IIOArray::getObjectAtIndex((IIOArray *)v13, 0);
    IIODictionary::setObjectForKey((IIODictionary *)(v7 + 40), ObjectAtIndex, a2);
  }
  else
  {
    CFTypeID v9 = CFGetTypeID(a3);
    CFStringRef v10 = CFCopyTypeIDDescription(v9);
    IIOString::IIOString((IIOString *)v12, v10);
    CFDictionaryRef v11 = (const char *)IIOString::utf8String((IIOString *)v12);
    LogError("IIOXPCEncodeMetadataTag_block_invoke_2", 116, "*** unexpected type in dictionary: %s\n", v11);
    IIOString::~IIOString((IIOString *)v12);
  }
  IIOArray::~IIOArray((IIOArray *)v13);
}

void sub_1887B5F3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  IIOString::~IIOString((IIOString *)va);
  IIOArray::~IIOArray((IIOArray *)va1);
  _Unwind_Resume(a1);
}

uint64_t ___ZL25addPropertiesFromMetadataP13IIODictionaryP8IIOArrayPKvi_block_invoke(uint64_t a1, void *a2)
{
  return addPropertiesFromMetadata(*(IIODictionary **)(a1 + 32), *(IIOArray **)(a1 + 40), a2, *(_DWORD *)(a1 + 48) + 1);
}

uint64_t ___ZL25addPropertiesFromMetadataP13IIODictionaryP8IIOArrayPKvi_block_invoke_2(uint64_t a1, void *a2)
{
  return addPropertiesFromMetadata(*(IIODictionary **)(a1 + 32), *(IIOArray **)(a1 + 40), a2, *(_DWORD *)(a1 + 48) + 1);
}

uint64_t ___ZL25addPropertiesFromMetadataP13IIODictionaryP8IIOArrayPKvi_block_invoke_3(uint64_t a1, uint64_t a2, const void *a3)
{
  return addPropertiesFromMetadata(*(IIODictionary **)(a1 + 32), *(IIOArray **)(a1 + 40), a3, *(_DWORD *)(a1 + 48) + 1);
}

uint64_t ___ZL37CGImageMetadataCreateWithEXIFFilteredPK15CGImageMetadatab_block_invoke(uint64_t a1, const __CFString *a2, uint64_t a3)
{
  uint64_t Source = CGImageSourceGetSource(a3);
  if (CFEqual(*(CFStringRef *)(Source + 24), @"exif")
    || CFEqual(*(CFStringRef *)(Source + 24), @"tiff")
    || CFEqual(*(CFStringRef *)(Source + 24), @"exifEX"))
  {
    CGImageMetadataRemoveTagWithPath(*(CGMutableImageMetadataRef *)(a1 + 32), 0, a2);
  }
  return 1;
}

unint64_t myTIFFReadProc(IIOImageReadSession **a1, unsigned char *a2, unint64_t a3)
{
  if (a1)
  {
    if (a1[2])
    {
      unint64_t Bytes = IIOImageReadSession::getBytes(a1[2], a2, a3);
LABEL_6:
      unint64_t v6 = Bytes;
      goto LABEL_8;
    }
    int v5 = a1[3];
    if (v5)
    {
      unint64_t Bytes = IIOImageWriteSession::getBytes(v5, a2, a3);
      goto LABEL_6;
    }
  }
  unint64_t v6 = 0;
LABEL_8:
  if (v6 != a3) {
    _cg_jpeg_mem_term("myTIFFReadProc", 34, "*** expected: %lld   got: %lld\n", a3, v6);
  }
  return v6;
}

size_t myTIFFWriteProc(void *a1, void *a2, size_t a3)
{
  if (a1 && (CFStringRef v3 = (IIOImageWriteSession *)a1[3]) != 0) {
    return IIOImageWriteSession::putBytes(v3, a2, a3);
  }
  else {
    return 0;
  }
}

IIOImageRead *myTIFFSizeProc(IIOImageReadSession **a1)
{
  if (!a1) {
    return 0;
  }
  if (a1[2]) {
    return IIOImageReadSession::getSize(a1[2]);
  }
  uint64_t v2 = a1[3];
  if (v2) {
    return (IIOImageRead *)IIOImageWriteSession::getSize(v2);
  }
  else {
    return 0;
  }
}

unint64_t myTIFFSeekProc(IIOImageReadSession **a1, unint64_t a2, int a3)
{
  if (!a1) {
    return 0;
  }
  if (a1[2]) {
    return IIOImageReadSession::seek(a1[2], a2, a3);
  }
  uint64_t v4 = a1[3];
  if (v4) {
    return IIOImageWriteSession::seek(v4, a2, a3);
  }
  else {
    return 0;
  }
}

uint64_t myTIFFCloseProc(void *a1)
{
  if (a1) {
    (*(void (**)(void *))(*(void *)a1 + 8))(a1);
  }
  return 0;
}

uint64_t myTIFFMapFileProc(void *a1, void **a2, unint64_t *a3)
{
  return 0;
}

void SetupTIFFErrorHandler(void)
{
  if ((IIO_XPCServer() & 1) == 0 && SetupTIFFErrorHandler(void)::setupOnce != -1)
  {
    dispatch_once(&SetupTIFFErrorHandler(void)::setupOnce, &__block_literal_global_36);
  }
}

size_t (*___Z21SetupTIFFErrorHandlerv_block_invoke())(const char *a1, const char *a2, va_list a3)
{
  _cg_TIFFSetErrorHandler(0);
  _cg_TIFFSetErrorHandlerExt(IIOErrorHandler);

  return _cg_TIFFSetWarningHandler((size_t (*)(const char *, const char *, va_list))IIOWarningHandler);
}

uint64_t IIOErrorHandler(unsigned char *a1, const char *a2, char *a3, char *a4)
{
  uint64_t result = (uint64_t)LogModuleWithArguments(a2, a3, a4);
  if (a2)
  {
    uint64_t result = strcmp(a2, "ZIPDecode");
    if (result)
    {
      uint64_t result = strcmp(a2, "PackBitsDecode");
      if (a1 && !result) {
        goto LABEL_5;
      }
    }
    else if (a1)
    {
LABEL_5:
      a1[32] = 1;
    }
  }
  if (!a3) {
    return result;
  }
  uint64_t result = (uint64_t)strstr(a3, "Bad code word");
  if (result || (uint64_t result = (uint64_t)strstr(a3, "Premature EOL at line")) != 0)
  {
    if (!a1) {
      return result;
    }
    goto LABEL_10;
  }
  uint64_t result = (uint64_t)strstr(a3, "Invalid tile byte count");
  if (a1 && result) {
LABEL_10:
  }
    a1[32] = 1;
  return result;
}

void IOTiffClientData::IOTiffClientData(IOTiffClientData *this, char a2)
{
  *((unsigned char *)this + 34) = a2;
  *(void *)this = &unk_1ED4E3E48;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_WORD *)this + 16) = 0;
}

void IOTiffClientData::~IOTiffClientData(IOTiffClientData *this)
{
}

void GlobalTIFFInfo::GlobalTIFFInfo(GlobalTIFFInfo *this, char a2)
{
  *(void *)this = &unk_1ED4E1168;
  *((unsigned char *)this + 8) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((unsigned char *)this + 80) = a2;
}

void GlobalTIFFInfo::GlobalTIFFInfo(GlobalTIFFInfo *this, unsigned __int8 *a2, CFIndex a3)
{
  *(void *)this = &unk_1ED4E1168;
  *((unsigned char *)this + 8) = 0;
  *((_OWORD *)this + 1) = 0u;
  uint64_t v4 = (UInt8 **)((char *)this + 16);
  int v5 = (UInt8 **)((char *)this + 40);
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  UInt8 buffer = 0;
  *(_DWORD *)CFDictionaryRef v11 = 0;
  uint64_t v10 = 0;
  unint64_t v6 = CFReadStreamCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  uint64_t v7 = v6;
  if (v6)
  {
    if (CFReadStreamOpen(v6))
    {
      if (CFReadStreamRead(v7, &buffer, 1) == 1)
      {
        *((unsigned char *)this + 8) = buffer;
        if (CFReadStreamRead(v7, v11, 4) == 4)
        {
          if (!*(_DWORD *)v11
            || (std::vector<unsigned long long>::resize((uint64_t)v4, *(unsigned int *)v11),
                CFIndex v8 = CFReadStreamRead(v7, *v4, 8 * *(unsigned int *)v11),
                v8 == 8 * *(unsigned int *)v11))
          {
            if (CFReadStreamRead(v7, v11, 4) == 4)
            {
              if (!*(_DWORD *)v11
                || (std::vector<unsigned long long>::resize((uint64_t)v5, *(unsigned int *)v11),
                    CFIndex v9 = CFReadStreamRead(v7, *v5, 8 * *(unsigned int *)v11),
                    v9 == 8 * *(unsigned int *)v11))
              {
                if (CFReadStreamRead(v7, (UInt8 *)&v10, 8) == 8)
                {
                  *((void *)this + 8) = v10;
                  if (CFReadStreamRead(v7, (UInt8 *)&v10, 8) == 8)
                  {
                    *((void *)this + 9) = v10;
                    if (CFReadStreamRead(v7, &buffer, 1) == 1) {
                      *((unsigned char *)this + 80) = buffer;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    CFRelease(v7);
  }
}

void sub_1887B653C(_Unwind_Exception *exception_object)
{
  int v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 48) = v5;
    operator delete(v5);
  }
  unint64_t v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 24) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<unsigned long long>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<unsigned long long>::__append((char **)a1, a2 - v2);
  }
}

void GlobalTIFFInfo::~GlobalTIFFInfo(GlobalTIFFInfo *this)
{
  *(void *)this = &unk_1ED4E1168;
  unint64_t v2 = (void *)*((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    operator delete(v2);
  }
  CFStringRef v3 = (void *)*((void *)this + 2);
  if (v3)
  {
    *((void *)this + 3) = v3;
    operator delete(v3);
  }
}

{
  uint64_t vars8;

  GlobalTIFFInfo::~GlobalTIFFInfo(this);

  JUMPOUT(0x18C11C0E0);
}

CFTypeRef GlobalTIFFInfo::createDataRepresentation(GlobalTIFFInfo *this)
{
  unint64_t v2 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  if (!v2) {
    return 0;
  }
  CFStringRef v3 = v2;
  UInt8 buffer = 0;
  *(_DWORD *)CFIndex v9 = 0;
  uint64_t v8 = 0;
  if (!CFWriteStreamOpen(v2)) {
    goto LABEL_16;
  }
  UInt8 buffer = *((unsigned char *)this + 8);
  if (CFWriteStreamWrite(v3, &buffer, 1) != 1) {
    goto LABEL_16;
  }
  *(_DWORD *)CFIndex v9 = (*((void *)this + 3) - *((void *)this + 2)) >> 3;
  if (CFWriteStreamWrite(v3, v9, 4) != 4) {
    goto LABEL_16;
  }
  if (*(_DWORD *)v9)
  {
    CFIndex v4 = CFWriteStreamWrite(v3, *((const UInt8 **)this + 2), 8 * *(unsigned int *)v9);
    if (v4 != 8 * *(unsigned int *)v9) {
      goto LABEL_16;
    }
  }
  if ((*(_DWORD *)CFIndex v9 = (*((void *)this + 6) - *((void *)this + 5)) >> 3, CFWriteStreamWrite(v3, v9, 4) == 4)
    && (!*(_DWORD *)v9
     || (CFIndex v5 = CFWriteStreamWrite(v3, *((const UInt8 **)this + 5), 8 * *(unsigned int *)v9),
         v5 == 8 * *(unsigned int *)v9))
    && (uint64_t v8 = *((void *)this + 8), CFWriteStreamWrite(v3, (const UInt8 *)&v8, 8) == 8)
    && (uint64_t v8 = *((void *)this + 9), CFWriteStreamWrite(v3, (const UInt8 *)&v8, 8) == 8)
    && (UInt8 buffer = *((unsigned char *)this + 80), CFWriteStreamWrite(v3, &buffer, 1) == 1))
  {
    CFTypeRef v6 = CFWriteStreamCopyProperty(v3, (CFStreamPropertyKey)*MEMORY[0x1E4F1D440]);
  }
  else
  {
LABEL_16:
    CFTypeRef v6 = 0;
  }
  CFRelease(v3);
  return v6;
}

uint64_t ReleaseTIFFGlobalInfo(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::vector<unsigned long long>::__append(char **a1, unint64_t a2)
{
  CFTypeRef v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  CFIndex v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 3);
    if (v10 >> 61) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 3;
    uint64_t v12 = v5 - v8;
    if (v12 >> 2 > v10) {
      unint64_t v10 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v4, v13);
      uint64_t v8 = *a1;
      uint64_t v7 = a1[1];
    }
    else
    {
      uint64_t v14 = 0;
    }
    uint64_t v15 = &v14[8 * v11];
    uint64_t v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    uint64_t v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      uint64_t v18 = *((void *)v7 - 1);
      v7 -= 8;
      *((void *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void IIO_Reader_AI::createReadPlugin()
{
}

{
  operator new();
}

void sub_1887B698C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40F65F68CCLL);
  _Unwind_Resume(a1);
}

void sub_1887B6A2C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40F65F68CCLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_AI::updateSourceProperties(IIO_Reader_AI *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(this);
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)IIO_ReaderHandler::readerForType(ReaderHandler, 1346651680) + 56);

  return v7();
}

uint64_t IIO_Reader_AI::compareOptions(IIO_Reader_AI *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(this);
  uint64_t v4 = *(uint64_t (**)(void))(*(void *)IIO_ReaderHandler::readerForType(ReaderHandler, 1346651680) + 80);

  return v4();
}

uint64_t IIO_Reader_AI::getImageCount(IIO_Reader_AI *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  if (a5) {
    *a5 = 0;
  }
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(this);
  unint64_t v10 = IIO_ReaderHandler::readerForType(ReaderHandler, 1346651680);
  return (*(__int16 (**)(IIO_Reader *, IIOImageReadSession *, IIODictionary *, CGImageSourceStatus *, unsigned int *))(*(void *)v10 + 32))(v10, a2, a3, a4, a5);
}

uint64_t IIO_Reader_AI::hasCustomImageCountProc(IIO_Reader_AI *this)
{
  return 1;
}

uint64_t IIO_Reader_AI::hasCustomCompareOptionsProc(IIO_Reader_AI *this)
{
  return 1;
}

uint64_t IIO_Reader_AI::hasCustomSourcePropertiesProc(IIO_Reader_AI *this)
{
  return 1;
}

uint64_t LogL16fromY(int a1, long double a2)
{
  if (a2 >= 1.8371976e19) {
    return 0x7FFFLL;
  }
  if (a2 <= -1.8371976e19) {
    return 0xFFFFLL;
  }
  if (a2 <= 5.4136769e-20)
  {
    if (a2 >= -5.4136769e-20)
    {
      return 0;
    }
    else
    {
      double v5 = (log(-a2) * 1.44269504 + 64.0) * 256.0;
      if (a1) {
        double v5 = v5 + (double)rand() * 4.65661288e-10 + -0.5;
      }
      return (int)v5 | 0xFFFF8000;
    }
  }
  else
  {
    double v3 = (log(a2) * 1.44269504 + 64.0) * 256.0;
    if (a1) {
      double v3 = v3 + (double)rand() * 4.65661288e-10 + -0.5;
    }
    return (int)v3;
  }
}

float *XYZtoRGB24(float *result, char *a2)
{
  double v2 = *result;
  double v3 = result[1];
  double v4 = result[2];
  double v5 = v3 * -1.276 + v2 * 2.69 + v4 * -0.414;
  double v6 = v3 * 1.978 + v2 * -1.022 + v4 * 0.044;
  double v7 = v3 * -0.224 + v2 * 0.061;
  if (v5 <= 0.0)
  {
    char v8 = 0;
  }
  else
  {
    char v8 = vcvtd_n_s64_f64(sqrt(v5), 8uLL);
    if (v5 >= 1.0) {
      char v8 = -1;
    }
  }
  double v9 = v7 + v4 * 1.163;
  *a2 = v8;
  if (v6 <= 0.0)
  {
    char v10 = 0;
  }
  else
  {
    char v10 = vcvtd_n_s64_f64(sqrt(v6), 8uLL);
    if (v6 >= 1.0) {
      char v10 = -1;
    }
  }
  a2[1] = v10;
  if (v9 <= 0.0)
  {
    char v11 = 0;
  }
  else
  {
    char v11 = vcvtd_n_s64_f64(sqrt(v9), 8uLL);
    if (v9 >= 1.0) {
      char v11 = -1;
    }
  }
  a2[2] = v11;
  return result;
}

uint64_t LogL10fromY(int a1, long double a2)
{
  if (a2 >= 15.742) {
    return 1023;
  }
  if (a2 <= 0.00024283) {
    return 0;
  }
  double v3 = (log(a2) * 1.44269504 + 12.0) * 64.0;
  if (a1) {
    double v3 = v3 + (double)rand() * 4.65661288e-10 + -0.5;
  }
  return (int)v3;
}

uint64_t uv_encode(int a1, double a2, double a3)
{
  if (a3 >= 0.0169399995)
  {
    double v6 = (a3 + -0.0169399995) * 285.714277;
    if (a1) {
      double v6 = v6 + (double)rand() * 4.65661288e-10 + -0.5;
    }
    uint64_t v7 = (int)v6;
    if (v7 < 0xA3)
    {
      double v8 = uv_row[2 * (int)v6];
      if (a2 >= v8)
      {
        double v9 = (a2 - v8) * 285.714277;
        if (a1) {
          double v9 = v9 + (double)rand() * 4.65661288e-10 + -0.5;
        }
        char v10 = &uv_row[2 * v7];
        if ((int)v9 < *((__int16 *)v10 + 2)) {
          return (*((__int16 *)v10 + 3) + (int)v9);
        }
      }
    }
  }

  return oog_encode(a2, a3);
}

uint64_t oog_encode(double a1, double a2)
{
  double v2 = a1;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if ((oog_encode_initialized & 1) == 0)
  {
    double v32 = a2;
    memset_pattern16(__b, &unk_1889ACF60, 0x320uLL);
    uint64_t v3 = 162;
    do
    {
      uint64_t v4 = v3;
      double v5 = (char *)&uv_row + 8 * v3;
      int v6 = *((__int16 *)v5 + 2) - 1;
      if (v4) {
        BOOL v7 = v4 == 162;
      }
      else {
        BOOL v7 = 1;
      }
      if (v7) {
        int v8 = 1;
      }
      else {
        int v8 = *((__int16 *)v5 + 2) - 1;
      }
      double v9 = *(float *)v5;
      char v10 = (__int16 *)(v5 + 6);
      do
      {
        double v11 = atan2(((double)(int)v4 + 0.5) * 0.00350000011 + 0.0169399995 + -0.473684211, v9 + ((double)v6 + 0.5) * 0.00350000011 + -0.210526316)* 15.9154943+ 50.0;
        int v12 = (int)v11;
        double v13 = vabdd_f64(v11, (double)(int)v11 + 0.5);
        if (v13 < __b[v12])
        {
          oog_encode_oog_table[v12] = v6 + *v10;
          __b[v12] = v13;
        }
        v6 -= v8;
      }
      while (v6 >= 0);
      uint64_t v3 = v4 - 1;
    }
    while (v4);
    uint64_t v14 = &v35;
    uint64_t v15 = &STACK[0x640];
    uint64_t v16 = 99;
    uint64_t v17 = 198;
    uint64_t v18 = 100;
    double v2 = a1;
    do
    {
      uint64_t v19 = v16;
      uint64_t v20 = v18 - 1;
      if (__b[v16] > 1.5)
      {
        unsigned int v21 = 1;
        unint64_t v22 = v18;
        uint64_t v23 = v14;
        do
        {
          if (*(double *)&v23[-100 * (v22 / 0x64)] < 1.5) {
            break;
          }
          ++v21;
          ++v23;
          ++v22;
        }
        while (v21 != 50);
        int v24 = v18 + 99;
        unsigned int v25 = 1;
        int v26 = -1;
        unint64_t v27 = v17;
        CFMutableDictionaryRef v28 = v15;
        while (*(double *)&v28[-100 * (v27 / 0x64)] >= 1.5)
        {
          ++v25;
          --v28;
          --v27;
          if (--v26 == -50)
          {
            unsigned int v25 = 50;
            break;
          }
        }
        int v29 = v24 + v26;
        if (v21 >= v25) {
          int v30 = v29;
        }
        else {
          int v30 = v21 + v20;
        }
        oog_encode_oog_table[v19] = oog_encode_oog_table[v30 % 100];
      }
      uint64_t v16 = v19 - 1;
      --v14;
      --v15;
      --v17;
      uint64_t v18 = v20;
    }
    while (v19);
    oog_encode_initialized = 1;
    a2 = v32;
  }
  return oog_encode_oog_table[(int)(atan2(a2 + -0.473684211, v2 + -0.210526316) * 15.9154943 + 50.0)];
}

uint64_t uv_decode(double *a1, double *a2, unsigned int a3)
{
  if (a3 > 0x3FA0) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v4 = 0;
  unsigned int v5 = 163;
  while (1)
  {
    unsigned int v6 = (v4 + v5) >> 1;
    int v7 = *((__int16 *)&uv_row + 4 * v6 + 3);
    BOOL v8 = __OFSUB__(a3, v7);
    int v9 = a3 - v7;
    if ((v9 < 0) ^ v8 | (v9 == 0)) {
      break;
    }
    unsigned int v4 = (v4 + v5) >> 1;
LABEL_8:
    if (v5 - v4 <= 1)
    {
      uint64_t v10 = v4;
      double v11 = (double)(int)(a3 - *((__int16 *)&uv_row + 4 * v4 + 3)) + 0.5;
      unsigned int v6 = v4;
      goto LABEL_11;
    }
  }
  if (v9 < 0)
  {
    unsigned int v5 = (v4 + v5) >> 1;
    goto LABEL_8;
  }
  double v11 = 0.5;
  uint64_t v10 = (v4 + v5) >> 1;
LABEL_11:
  uint64_t v3 = 0;
  *a1 = *((float *)&uv_row + 2 * v10) + v11 * 0.00350000011;
  *a2 = ((double)v6 + 0.5) * 0.00350000011 + 0.0169399995;
  return v3;
}

void LogLuv24toXYZ(unsigned int a1, uint64_t a2)
{
  int v3 = (a1 >> 14) & 0x3FF;
  if (v3 && (v4 = a1, double v5 = exp(((double)v3 + 0.5) * 0.0108304247 + -8.31776617), v5 > 0.0))
  {
    double v6 = v5;
    double v14 = 0.0;
    double v15 = 0.0;
    int v7 = uv_decode(&v15, &v14, v4 & 0x3FFF);
    double v9 = v14;
    double v8 = v15;
    if (v7 < 0)
    {
      double v9 = 0.473684211;
      double v8 = 0.210526316;
    }
    double v10 = 1.0 / (v9 * -16.0 + v8 * 6.0 + 12.0);
    double v11 = v8 * 9.0 * v10;
    double v12 = v9 * 4.0 * v10;
    *(float *)&double v10 = v6 * (v11 / v12);
    float v13 = v6;
    *(_DWORD *)a2 = LODWORD(v10);
    *(float *)(a2 + 4) = v13;
    *(float *)&double v11 = v6 * ((1.0 - v11 - v12) / v12);
    *(_DWORD *)(a2 + 8) = LODWORD(v11);
  }
  else
  {
    *(_DWORD *)(a2 + 8) = 0;
    *(void *)a2 = 0;
  }
}

uint64_t LogLuv24fromXYZ(float *a1, int a2)
{
  int v4 = LogL10fromY(a2, a1[1]);
  double v5 = 0.473684211;
  double v6 = 0.210526316;
  if (v4)
  {
    double v7 = *a1;
    double v8 = a1[1];
    double v9 = v7 + v8 * 15.0 + a1[2] * 3.0;
    if (v9 > 0.0)
    {
      double v6 = v7 * 4.0 / v9;
      double v5 = v8 * 9.0 / v9;
    }
  }
  int v10 = uv_encode(a2, v6, v5);
  if (v10 < 0) {
    int v10 = uv_encode(0, 0.210526316, 0.473684211);
  }
  return v10 | (v4 << 14);
}

void LogLuv32toXYZ(int a1, uint64_t a2)
{
  int v3 = a1 >> 16;
  if (((a1 >> 16) & 0x7FFF) == 0) {
    goto LABEL_6;
  }
  __int16 v4 = a1;
  double v5 = exp(((double)((a1 >> 16) & 0x7FFF) + 0.5) * 0.00270760617 + -44.3614196);
  if ((v3 & 0x8000) != 0) {
    double v5 = -v5;
  }
  if (v5 > 0.0)
  {
    double v6 = ((double)HIBYTE(v4) + 0.5) * 0.00243902439;
    double v7 = ((double)v4 + 0.5) * 0.00243902439;
    double v8 = 1.0 / (v7 * -16.0 + v6 * 6.0 + 12.0);
    double v9 = v6 * 9.0 * v8;
    double v10 = v7 * 4.0 * v8;
    *(float *)&double v8 = v5 * (v9 / v10);
    float v11 = v5;
    *(_DWORD *)a2 = LODWORD(v8);
    *(float *)(a2 + 4) = v11;
    float v12 = v5 * ((1.0 - v9 - v10) / v10);
    *(float *)(a2 + 8) = v12;
  }
  else
  {
LABEL_6:
    *(_DWORD *)(a2 + 8) = 0;
    *(void *)a2 = 0;
  }
}

uint64_t LogLuv32fromXYZ(float *a1, int a2)
{
  int v4 = LogL16fromY(a2, a1[1]);
  double v5 = 0.210526316;
  double v6 = 0.473684211;
  if (v4
    && (double v7 = *a1, v8 = a1[1], v9 = v7 + v8 * 15.0 + a1[2] * 3.0, v9 > 0.0)
    && (double v5 = v7 * 4.0 / v9, v6 = v8 * 9.0 / v9, v5 <= 0.0))
  {
    unsigned int v11 = 0;
  }
  else
  {
    double v10 = v5 * 410.0;
    if (a2) {
      double v10 = v10 + (double)rand() * 4.65661288e-10 + -0.5;
    }
    unsigned int v11 = (int)v10;
  }
  if (v6 <= 0.0)
  {
    unsigned int v13 = 0;
  }
  else
  {
    double v12 = v6 * 410.0;
    if (a2) {
      double v12 = v12 + (double)rand() * 4.65661288e-10 + -0.5;
    }
    unsigned int v13 = (int)v12;
  }
  if (v11 >= 0xFF) {
    int v14 = 255;
  }
  else {
    int v14 = v11;
  }
  if (v13 >= 0xFF) {
    unsigned int v13 = 255;
  }
  return v13 | (v14 << 8) | (v4 << 16);
}

uint64_t TIFFInitSGILog(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >> 1 != 17338) {
    TIFFInitSGILog_cold_1();
  }
  if (_TIFFMergeFields(a1, LogLuvFields, 2, a4, a5, a6, a7, a8))
  {
    uint64_t v16 = _TIFFmallocExt((void *)a1, 56, v10, v11, v12, v13, v14, v15);
    *(void *)(a1 + 1096) = v16;
    if (v16)
    {
      uint64_t v17 = v16;
      _TIFFmemset(v16, 0, 0x38uLL);
      *((_DWORD *)v17 + 1) = -1;
      *((_DWORD *)v17 + 2) = a2 == 34677;
      v17[4] = _logLuvNop;
      *(void *)(a1 + 952) = LogLuvFixupTags;
      *(void *)(a1 + 960) = LogLuvSetupDecode;
      *(void *)(a1 + 1024) = LogLuvDecodeStrip;
      *(void *)(a1 + 1040) = LogLuvDecodeTile;
      *(void *)(a1 + 976) = LogLuvSetupEncode;
      *(void *)(a1 + 1032) = LogLuvEncodeStrip;
      *(void *)(a1 + 1048) = LogLuvEncodeTile;
      *(void *)(a1 + 1056) = LogLuvClose;
      *(void *)(a1 + 1072) = LogLuvCleanup;
      int8x16_t v18 = *(int8x16_t *)(a1 + 1280);
      *(void *)(a1 + 1288) = LogLuvVGetField;
      *(int8x16_t *)(v17 + 5) = vextq_s8(v18, v18, 8uLL);
      *(void *)(a1 + 1280) = LogLuvVSetField;
      return 1;
    }
    uint64_t v21 = *(void *)a1;
    uint64_t v20 = "%s: No space for LogLuv state block";
  }
  else
  {
    uint64_t v20 = "Merging SGILog codec-specific tags failed";
  }
  TIFFErrorExtR(a1, "TIFFInitSGILog", v20, v11, v12, v13, v14, v15, v21);
  return 0;
}

uint64_t LogLuvFixupTags()
{
  return 1;
}

uint64_t LogLuvSetupDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 1096);
  *(void *)(a1 + 1248) = _TIFFNoPostDecode;
  int v10 = *(unsigned __int16 *)(a1 + 122);
  if (v10 == 32844)
  {
    uint64_t result = LogL16InitState(a1, a2, a3, a4, a5, a6, a7, a8);
    if (!result) {
      return result;
    }
    *(void *)(a1 + 1008) = LogL16Decode;
    int v14 = *(_DWORD *)(v9 + 4);
    if (v14 == 3)
    {
      uint64_t v13 = L16toGry;
      goto LABEL_23;
    }
    if (!v14)
    {
      uint64_t v13 = L16toY;
      goto LABEL_23;
    }
  }
  else
  {
    if (v10 != 32845)
    {
      TIFFErrorExtR(a1, "LogLuvSetupDecode", "Inappropriate photometric interpretation %hu for SGILog compression; %s",
        a4,
        a5,
        a6,
        a7,
        a8,
        *(_WORD *)(a1 + 122));
      return 0;
    }
    uint64_t result = LogLuvInitState(a1, a2, a3, a4, a5, a6, a7, a8);
    if (!result) {
      return result;
    }
    if (*(unsigned __int16 *)(a1 + 120) == 34677)
    {
      *(void *)(a1 + 1008) = LogLuvDecode24;
      int v12 = *(_DWORD *)(v9 + 4);
      switch(v12)
      {
        case 3:
          uint64_t v13 = Luv24toRGB;
          goto LABEL_23;
        case 1:
          uint64_t v13 = Luv24toLuv48;
          goto LABEL_23;
        case 0:
          uint64_t v13 = Luv24toXYZ;
LABEL_23:
          *(void *)(v9 + 32) = v13;
          break;
      }
    }
    else
    {
      *(void *)(a1 + 1008) = LogLuvDecode32;
      int v15 = *(_DWORD *)(v9 + 4);
      switch(v15)
      {
        case 3:
          uint64_t v13 = Luv32toRGB;
          goto LABEL_23;
        case 1:
          uint64_t v13 = Luv32toLuv48;
          goto LABEL_23;
        case 0:
          uint64_t v13 = Luv32toXYZ;
          goto LABEL_23;
      }
    }
  }
  return 1;
}

uint64_t LogLuvDecodeStrip(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a3;
  uint64_t v10 = a2;
  uint64_t result = _cg_TIFFScanlineSize(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v13 = result;
    if (v9 % result) {
      LogLuvDecodeStrip_cold_1();
    }
    if (v9)
    {
      do
      {
        int v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 1008))(a1, v10, v13, a4);
        v10 += v13;
        if (v14) {
          BOOL v15 = v9 == v13;
        }
        else {
          BOOL v15 = 1;
        }
        v9 -= v13;
      }
      while (!v15);
      return v14 != 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t LogLuvDecodeTile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a3;
  uint64_t v10 = a2;
  uint64_t result = _cg_TIFFTileRowSize(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v13 = result;
    if (v9 % result) {
      LogLuvDecodeTile_cold_1();
    }
    if (v9)
    {
      do
      {
        int v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 1008))(a1, v10, v13, a4);
        v10 += v13;
        if (v14) {
          BOOL v15 = v9 == v13;
        }
        else {
          BOOL v15 = 1;
        }
        v9 -= v13;
      }
      while (!v15);
      return v14 != 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t LogLuvSetupEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 1096);
  int v10 = *(unsigned __int16 *)(a1 + 122);
  if (v10 == 32844)
  {
    uint64_t result = LogL16InitState(a1, a2, a3, a4, a5, a6, a7, a8);
    if (!result) {
      return result;
    }
    *(void *)(a1 + 1016) = LogL16Encode;
    int v19 = *(_DWORD *)(v9 + 4);
    int8x16_t v18 = L16fromY;
    if (!v19) {
      goto LABEL_18;
    }
    if (v19 == 1) {
      goto LABEL_19;
    }
    goto LABEL_20;
  }
  if (v10 == 32845)
  {
    uint64_t result = LogLuvInitState(a1, a2, a3, a4, a5, a6, a7, a8);
    if (!result) {
      return result;
    }
    if (*(unsigned __int16 *)(a1 + 120) == 34677)
    {
      *(void *)(a1 + 1016) = LogLuvEncode24;
      int v17 = *(_DWORD *)(v9 + 4);
      int8x16_t v18 = Luv24fromXYZ;
      if (!v17)
      {
LABEL_18:
        *(void *)(v9 + 32) = v18;
        goto LABEL_19;
      }
      if (v17 != 2)
      {
        if (v17 == 1)
        {
          int8x16_t v18 = Luv24fromLuv48;
          goto LABEL_18;
        }
        goto LABEL_20;
      }
LABEL_19:
      uint64_t result = 1;
      *(_DWORD *)uint64_t v9 = 1;
      return result;
    }
    *(void *)(a1 + 1016) = LogLuvEncode32;
    int v20 = *(_DWORD *)(v9 + 4);
    int8x16_t v18 = Luv32fromXYZ;
    switch(v20)
    {
      case 0:
        goto LABEL_18;
      case 2:
        goto LABEL_19;
      case 1:
        int8x16_t v18 = Luv32fromLuv48;
        goto LABEL_18;
    }
LABEL_20:
    uint64_t v21 = "XYZ, Luv";
    if (*(unsigned __int16 *)(a1 + 122) == 32844) {
      uint64_t v21 = "Y, L";
    }
    TIFFErrorExtR(a1, "LogLuvSetupEncode", "SGILog compression supported only for %s, or raw data", v12, v13, v14, v15, v16, (char)v21);
    return 0;
  }
  TIFFErrorExtR(a1, "LogLuvSetupEncode", "Inappropriate photometric interpretation %hu for SGILog compression; %s",
    a4,
    a5,
    a6,
    a7,
    a8,
    *(_WORD *)(a1 + 122));
  return 0;
}

uint64_t LogLuvEncodeStrip(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a3;
  uint64_t v10 = a2;
  uint64_t result = _cg_TIFFScanlineSize(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v13 = result;
    if (v9 % result) {
      LogLuvEncodeStrip_cold_1();
    }
    if (v9)
    {
      do
      {
        int v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 1016))(a1, v10, v13, a4);
        v10 += v13;
        BOOL v15 = v14 != 1 || v9 == v13;
        v9 -= v13;
      }
      while (!v15);
      return v14 == 1;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t LogLuvEncodeTile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a3;
  uint64_t v10 = a2;
  uint64_t result = _cg_TIFFTileRowSize(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    uint64_t v13 = result;
    if (v9 % result) {
      LogLuvEncodeTile_cold_1();
    }
    if (v9)
    {
      do
      {
        int v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a1 + 1016))(a1, v10, v13, a4);
        v10 += v13;
        BOOL v15 = v14 != 1 || v9 == v13;
        v9 -= v13;
      }
      while (!v15);
      return v14 == 1;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t LogLuvClose(uint64_t result)
{
  uint64_t v1 = *(_DWORD **)(result + 1096);
  if (!v1) {
    LogLuvClose_cold_1();
  }
  if (*v1)
  {
    if (*(unsigned __int16 *)(result + 122) == 32844) {
      __int16 v2 = 1;
    }
    else {
      __int16 v2 = 3;
    }
    *(_WORD *)(result + 130) = v2;
    *(_DWORD *)(result + 116) = 131088;
  }
  return result;
}

uint64_t LogLuvCleanup(void *a1)
{
  uint64_t v1 = a1[137];
  if (!v1) {
    LogLuvCleanup_cold_1();
  }
  uint64_t v3 = *(void *)(v1 + 48);
  a1[161] = *(void *)(v1 + 40);
  a1[160] = v3;
  int v4 = *(char **)(v1 + 16);
  if (v4) {
    _TIFFfreeExt((uint64_t)a1, v4);
  }
  _TIFFfreeExt((uint64_t)a1, (char *)v1);
  a1[137] = 0;

  return _TIFFSetDefaultCompressionState((uint64_t)a1);
}

uint64_t LogLuvVGetField(uint64_t a1, int a2, _DWORD **a3)
{
  uint64_t v3 = *(void *)(a1 + 1096);
  if (a2 != 65560) {
    return (*(uint64_t (**)(void))(v3 + 40))();
  }
  **a3 = *(_DWORD *)(v3 + 4);
  return 1;
}

uint64_t LogLuvVSetField(uint64_t a1, int a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 1096);
  if (a2 == 65561)
  {
    unsigned int v13 = *a3;
    *(_DWORD *)(v9 + 8) = *a3;
    if (v13 < 2) {
      return 1;
    }
    TIFFErrorExtR(a1, "LogLuvVSetField", "Unknown encoding %d for LogLuv compression", a4, a5, a6, a7, a8, v13);
    return 0;
  }
  else
  {
    if (a2 == 65560)
    {
      unsigned int v10 = *a3;
      *(_DWORD *)(v9 + 4) = *a3;
      uint64_t v11 = 3;
      uint64_t v12 = 32;
      switch(v10)
      {
        case 0u:
          break;
        case 1u:
          uint64_t v11 = 2;
          uint64_t v12 = 16;
          break;
        case 2u:
          uint64_t v11 = 1;
          _cg_TIFFSetField(a1, 277, (uint64_t)a3, a4, a5, a6, a7, a8, 1);
          uint64_t v12 = 32;
          break;
        case 3u:
          uint64_t v11 = 1;
          uint64_t v12 = 8;
          break;
        default:
          TIFFErrorExtR(a1, *(const char **)a1, "Unknown data format %d for LogLuv compression", a4, a5, a6, a7, a8, v10);
          return 0;
      }
      _cg_TIFFSetField(a1, 258, (uint64_t)a3, a4, a5, a6, a7, a8, v12);
      _cg_TIFFSetField(a1, 339, v16, v17, v18, v19, v20, v21, v11);
      if ((*(unsigned char *)(a1 + 17) & 4) != 0) {
        uint64_t v29 = _cg_TIFFTileSize(a1, v22, v23, v24, v25, v26, v27, v28);
      }
      else {
        uint64_t v29 = -1;
      }
      *(void *)(a1 + 936) = v29;
      *(void *)(a1 + 1104) = _cg_TIFFScanlineSize(a1, v22, v23, v24, v25, v26, v27, v28);
      return 1;
    }
    int v14 = *(uint64_t (**)(void))(v9 + 48);
    return v14();
  }
}

uint64_t LogLuvInitState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 1096);
  if (!v8) {
    LogLuvInitState_cold_1();
  }
  if (*(unsigned __int16 *)(a1 + 122) != 32845) {
    LogLuvInitState_cold_2();
  }
  if (*(_WORD *)(a1 + 170) != 1)
  {
    int v14 = "SGILog compression cannot handle non-contiguous data";
    goto LABEL_37;
  }
  unsigned int v10 = *(_DWORD *)(v8 + 4);
  if (v10 == -1)
  {
    int v11 = *(unsigned __int16 *)(a1 + 118) | (8 * *(unsigned __int16 *)(a1 + 116));
    if (v11 > 256)
    {
      if ((v11 - 257) < 2) {
        goto LABEL_15;
      }
      if (v11 == 259)
      {
        int v13 = 0;
LABEL_21:
        unsigned int v10 = -1;
        goto LABEL_22;
      }
      if (v11 == 260)
      {
LABEL_15:
        unsigned int v10 = 2;
        int v13 = -1;
        goto LABEL_22;
      }
    }
    else
    {
      if ((v11 - 129) <= 3 && v11 != 131)
      {
        unsigned int v10 = -1;
        int v13 = 1;
LABEL_22:
        int v15 = *(unsigned __int16 *)(a1 + 130);
        if (v15 != 3) {
          int v13 = -1;
        }
        if (v15 != 1) {
          unsigned int v10 = v13;
        }
        *(_DWORD *)(v8 + 4) = v10;
        goto LABEL_27;
      }
      if (v11 == 65 || v11 == 68)
      {
        unsigned int v10 = -1;
        int v13 = 3;
        goto LABEL_22;
      }
    }
    int v13 = -1;
    goto LABEL_21;
  }
LABEL_27:
  if (v10 > 3)
  {
    int v14 = "No support for converting user data format to LogLuv";
  }
  else
  {
    *(_DWORD *)(v8 + 12) = dword_1889ACF70[v10];
    if ((*(unsigned char *)(a1 + 17) & 4) != 0)
    {
      int64_t v17 = *(unsigned int *)(a1 + 100);
      uint64_t v16 = *(unsigned int *)(a1 + 104);
    }
    else
    {
      uint64_t v16 = *(unsigned int *)(a1 + 132);
      int64_t v17 = *(unsigned int *)(a1 + 88);
      if (v16 >= *(_DWORD *)(a1 + 92)) {
        uint64_t v16 = *(unsigned int *)(a1 + 92);
      }
    }
    int64_t v18 = _TIFFMultiplySSize(0, v17, v16, 0, a5, a6, a7, a8);
    *(void *)(v8 + 24) = v18;
    if (_TIFFMultiplySSize(0, v18, 4, 0, v19, v20, v21, v22))
    {
      uint64_t v24 = _TIFFmallocExt((void *)a1, 4 * *(void *)(v8 + 24), v23, a4, a5, a6, a7, a8);
      *(void *)(v8 + 16) = v24;
      if (v24) {
        return 1;
      }
    }
    int v14 = "No space for SGILog translation buffer";
  }
LABEL_37:
  TIFFErrorExtR(a1, "LogLuvInitState", v14, a4, a5, a6, a7, a8, v26);
  return 0;
}

uint64_t LogLuvDecode24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4) {
    LogLuvDecode24_cold_2();
  }
  uint64_t v8 = *(void *)(a1 + 1096);
  if (!v8) {
    LogLuvDecode24_cold_1();
  }
  uint64_t v10 = a3 / *(int *)(v8 + 12);
  if (*(_DWORD *)(v8 + 4) != 2)
  {
    if (*(void *)(v8 + 24) < v10)
    {
      int v11 = "Translation buffer too short";
      goto LABEL_17;
    }
    a2 = *(void *)(v8 + 16);
  }
  uint64_t v12 = *(unsigned __int8 **)(a1 + 1152);
  uint64_t v13 = *(void *)(a1 + 1160);
  uint64_t v14 = 0;
  BOOL v15 = v10 < 1 || v13 < 3;
  if (!v15)
  {
    unint64_t v16 = *(void *)(a1 + 1160);
    do
    {
      *(_DWORD *)(a2 + 4 * v14) = (*v12 << 16) | (v12[1] << 8) | v12[2];
      v12 += 3;
      uint64_t v13 = v16 - 3;
      if (++v14 >= v10) {
        break;
      }
      BOOL v15 = v16 > 5;
      v16 -= 3;
    }
    while (v15);
  }
  *(void *)(a1 + 1152) = v12;
  *(void *)(a1 + 1160) = v13;
  if (v10 == v14)
  {
    (*(void (**)(uint64_t))(v8 + 32))(v8);
    return 1;
  }
  int v18 = *(_DWORD *)(a1 + 876);
  int v11 = "Not enough data at row %u (short %lld pixels)";
LABEL_17:
  TIFFErrorExtR(a1, "LogLuvDecode24", v11, a4, a5, a6, a7, a8, v18);
  return 0;
}

void Luv24toXYZ(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    int v4 = *(unsigned int **)(a1 + 16);
    unint64_t v5 = a3 + 1;
    do
    {
      unsigned int v6 = *v4++;
      LogLuv24toXYZ(v6, a2);
      a2 += 12;
      --v5;
    }
    while (v5 > 1);
  }
}

uint64_t Luv24toLuv48(uint64_t result, _WORD *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    v13[9] = v3;
    v13[10] = v4;
    unint64_t v6 = a3 + 1;
    double v7 = *(unsigned int **)(result + 16);
    do
    {
      double v12 = 0.0;
      v13[0] = 0.0;
      unsigned int v8 = *v7++;
      *a2 = ((v8 >> 12) & 0xFFD) + 13314;
      uint64_t result = uv_decode(v13, &v12, v8 & 0x3FFF);
      __int16 v9 = vcvtd_n_s64_f64(v13[0], 0xFuLL);
      if ((int)result < 0) {
        __int16 v9 = 6898;
      }
      __int16 v10 = vcvtd_n_s64_f64(v12, 0xFuLL);
      a2[1] = v9;
      if ((int)result >= 0) {
        __int16 v11 = v10;
      }
      else {
        __int16 v11 = 15521;
      }
      a2[2] = v11;
      --v6;
      a2 += 3;
    }
    while (v6 > 1);
  }
  return result;
}

float *Luv24toRGB(float *result, char *a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a3 >= 1)
  {
    double v4 = (unsigned int *)*((void *)result + 2);
    unint64_t v5 = a3 + 1;
    do
    {
      int v8 = 0;
      uint64_t v7 = 0;
      unsigned int v6 = *v4++;
      LogLuv24toXYZ(v6, (uint64_t)&v7);
      uint64_t result = XYZtoRGB24((float *)&v7, a2);
      a2 += 3;
      --v5;
    }
    while (v5 > 1);
  }
  return result;
}

uint64_t LogLuvDecode32(uint64_t a1, void *__b, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4) {
    LogLuvDecode32_cold_2();
  }
  uint64_t v9 = *(void *)(a1 + 1096);
  if (!v9) {
    LogLuvDecode32_cold_1();
  }
  __int16 v11 = __b;
  uint64_t v12 = a3 / *(int *)(v9 + 12);
  if (*(_DWORD *)(v9 + 4) != 2)
  {
    if (*(void *)(v9 + 24) < v12)
    {
      TIFFErrorExtR(a1, "LogLuvDecode32", "Translation buffer too short", a4, a5, a6, a7, a8, v32);
      return 0;
    }
    __int16 v11 = *(void **)(v9 + 16);
  }
  _TIFFmemset(v11, 0, 4 * v12);
  uint64_t v19 = *(char **)(a1 + 1152);
  uint64_t v20 = *(void *)(a1 + 1160);
  int v21 = 24;
  while (1)
  {
    uint64_t v22 = 0;
    int v23 = v21;
    if (v12 >= 1 && v20 >= 1)
    {
      uint64_t v22 = 0;
      do
      {
        int v24 = *v19;
        if (*v19 < 0)
        {
          if ((unint64_t)v20 < 2) {
            break;
          }
          if (v24 != 126 && v22 < v12)
          {
            int v29 = v19[1] << v23;
            int v30 = v24 - 127;
            do
            {
              *((_DWORD *)v11 + v22++) |= v29;
              BOOL v31 = v30-- != 0;
            }
            while (v31 && v22 < v12);
          }
          v19 += 2;
          v20 -= 2;
        }
        else
        {
          uint64_t v25 = (unsigned __int8 *)(v19 + 1);
          uint64_t v26 = v20 - 1;
          if (v20 == 1)
          {
            uint64_t v20 = 0;
            ++v19;
            break;
          }
          uint64_t v27 = 0;
          while (v24 != v27 && v22 + v27 < v12)
          {
            *((_DWORD *)v11 + v22 + v27) |= v25[v27] << v23;
            if (v26 == ++v27)
            {
              uint64_t v20 = 0;
              v19 += v27 + 1;
              v22 += v27;
              goto LABEL_32;
            }
          }
          uint64_t v20 = v26 - v27;
          uint64_t v19 = (char *)&v25[v27];
          v22 += v27;
        }
      }
      while (v22 < v12 && v20 > 0);
    }
LABEL_32:
    if (v12 != v22) {
      break;
    }
    int v21 = v23 - 8;
    if (!v23)
    {
      (*(void (**)(uint64_t, void *, uint64_t))(v9 + 32))(v9, __b, v12);
      *(void *)(a1 + 1152) = v19;
      *(void *)(a1 + 1160) = v20;
      return 1;
    }
  }
  TIFFErrorExtR(a1, "LogLuvDecode32", "Not enough data at row %u (short %lld pixels)", v14, v15, v16, v17, v18, *(_DWORD *)(a1 + 876));
  uint64_t result = 0;
  *(void *)(a1 + 1152) = v19;
  *(void *)(a1 + 1160) = v20;
  return result;
}

void Luv32toXYZ(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    double v4 = *(int **)(a1 + 16);
    unint64_t v5 = a3 + 1;
    do
    {
      int v6 = *v4++;
      LogLuv32toXYZ(v6, a2);
      a2 += 12;
      --v5;
    }
    while (v5 > 1);
  }
}

uint64_t Luv32toLuv48(uint64_t result, _WORD *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    double v3 = *(unsigned __int32 **)(result + 16);
    unint64_t v4 = a3 + 1;
    __asm { FMOV            V1.2D, #0.5 }
    float64x2_t v10 = (float64x2_t)vdupq_n_s64(0x3F63FB013FB013FBuLL);
    do
    {
      unsigned __int32 v11 = *v3++;
      v12.i32[0] = v11 >> 8;
      v12.i32[1] = v11;
      int8x8_t v13 = vand_s8(v12, (int8x8_t)0xFF000000FFLL);
      v14.i64[0] = v13.u32[0];
      v14.i64[1] = v13.u32[1];
      int32x2_t v15 = vmovn_s64(vcvtq_n_s64_f64(vmulq_f64(vaddq_f64(vcvtq_f64_u64(v14), _Q1), v10), 0xFuLL));
      *a2 = HIWORD(v11);
      a2[2] = v15.i16[2];
      a2[1] = v15.i16[0];
      --v4;
      a2 += 3;
    }
    while (v4 > 1);
  }
  return result;
}

float *Luv32toRGB(float *result, char *a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (a3 >= 1)
  {
    unint64_t v4 = (int *)*((void *)result + 2);
    unint64_t v5 = a3 + 1;
    do
    {
      int v8 = 0;
      uint64_t v7 = 0;
      int v6 = *v4++;
      LogLuv32toXYZ(v6, (uint64_t)&v7);
      uint64_t result = XYZtoRGB24((float *)&v7, a2);
      a2 += 3;
      --v5;
    }
    while (v5 > 1);
  }
  return result;
}

uint64_t LogL16InitState(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 1096);
  if (!v8) {
    LogL16InitState_cold_1();
  }
  if (*(unsigned __int16 *)(a1 + 122) != 32844) {
    LogL16InitState_cold_2();
  }
  if (*(_WORD *)(a1 + 130) == 1)
  {
    int v10 = *(_DWORD *)(v8 + 4);
    if (v10 != -1)
    {
      if (v10) {
        goto LABEL_6;
      }
      goto LABEL_25;
    }
    int v12 = *(unsigned __int16 *)(a1 + 118) | (*(unsigned __int16 *)(a1 + 116) << 6) | 8;
    if (v12 <= 1032)
    {
      if (v12 == 521 || v12 == 524)
      {
        int v10 = 3;
        goto LABEL_24;
      }
    }
    else
    {
      if ((v12 - 1033) <= 3 && v12 != 1035)
      {
        int v10 = 1;
        goto LABEL_24;
      }
      if (v12 == 2059)
      {
        int v10 = 0;
        goto LABEL_24;
      }
    }
    int v10 = -1;
LABEL_24:
    *(_DWORD *)(v8 + 4) = v10;
    if (v10)
    {
LABEL_6:
      if (v10 == 3)
      {
        int v11 = 1;
      }
      else
      {
        if (v10 != 1)
        {
          uint64x2_t v14 = "No support for converting user data format to LogL";
LABEL_34:
          TIFFErrorExtR(a1, "LogL16InitState", v14, a4, a5, a6, a7, a8, v25);
          return 0;
        }
        int v11 = 2;
      }
LABEL_26:
      *(_DWORD *)(v8 + 12) = v11;
      if ((*(unsigned char *)(a1 + 17) & 4) != 0)
      {
        int64_t v16 = *(unsigned int *)(a1 + 100);
        uint64_t v15 = *(unsigned int *)(a1 + 104);
      }
      else
      {
        uint64_t v15 = *(unsigned int *)(a1 + 132);
        int64_t v16 = *(unsigned int *)(a1 + 88);
        if (v15 >= *(_DWORD *)(a1 + 92)) {
          uint64_t v15 = *(unsigned int *)(a1 + 92);
        }
      }
      int64_t v17 = _TIFFMultiplySSize(0, v16, v15, 0, a5, a6, a7, a8);
      *(void *)(v8 + 24) = v17;
      if (_TIFFMultiplySSize(0, v17, 2, 0, v18, v19, v20, v21))
      {
        int v23 = _TIFFmallocExt((void *)a1, 2 * *(void *)(v8 + 24), v22, a4, a5, a6, a7, a8);
        *(void *)(v8 + 16) = v23;
        if (v23) {
          return 1;
        }
      }
      uint64x2_t v14 = "No space for SGILog translation buffer";
      goto LABEL_34;
    }
LABEL_25:
    int v11 = 4;
    goto LABEL_26;
  }
  TIFFErrorExtR(a1, "LogL16InitState", "Sorry, can not handle LogL image with %s=%hu", a4, a5, a6, a7, a8, (char)"Samples/pixel");
  return 0;
}

uint64_t LogL16Decode(uint64_t a1, void *__b, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4) {
    LogL16Decode_cold_2();
  }
  uint64_t v9 = *(void *)(a1 + 1096);
  if (!v9) {
    LogL16Decode_cold_1();
  }
  int v11 = __b;
  uint64_t v12 = a3 / *(int *)(v9 + 12);
  if (*(_DWORD *)(v9 + 4) != 1)
  {
    if (*(void *)(v9 + 24) < v12)
    {
      TIFFErrorExtR(a1, "LogL16Decode", "Translation buffer too short", a4, a5, a6, a7, a8, v32);
      return 0;
    }
    int v11 = *(void **)(v9 + 16);
  }
  _TIFFmemset(v11, 0, 2 * v12);
  uint64_t v19 = *(char **)(a1 + 1152);
  uint64_t v20 = *(void *)(a1 + 1160);
  int v21 = 8;
  while (1)
  {
    uint64_t v22 = 0;
    int v23 = v21;
    if (v12 >= 1 && v20 >= 1)
    {
      uint64_t v22 = 0;
      do
      {
        int v24 = *v19;
        if (*v19 < 0)
        {
          if ((unint64_t)v20 < 2) {
            break;
          }
          if (v24 != 126 && v22 < v12)
          {
            int v29 = v19[1] << v23;
            int v30 = v24 - 127;
            do
            {
              *((_WORD *)v11 + v22++) |= v29;
              BOOL v31 = v30-- != 0;
            }
            while (v31 && v22 < v12);
          }
          v19 += 2;
          v20 -= 2;
        }
        else
        {
          char v25 = (unsigned __int8 *)(v19 + 1);
          uint64_t v26 = v20 - 1;
          if (v20 == 1)
          {
            uint64_t v20 = 0;
            ++v19;
            break;
          }
          uint64_t v27 = 0;
          while (v24 != v27 && v22 + v27 < v12)
          {
            *((_WORD *)v11 + v22 + v27) |= v25[v27] << v23;
            if (v26 == ++v27)
            {
              uint64_t v20 = 0;
              v19 += v27 + 1;
              v22 += v27;
              goto LABEL_32;
            }
          }
          uint64_t v20 = v26 - v27;
          uint64_t v19 = (char *)&v25[v27];
          v22 += v27;
        }
      }
      while (v22 < v12 && v20 > 0);
    }
LABEL_32:
    if (v12 != v22) {
      break;
    }
    int v21 = v23 - 8;
    if (!v23)
    {
      (*(void (**)(uint64_t, void *, uint64_t))(v9 + 32))(v9, __b, v12);
      *(void *)(a1 + 1152) = v19;
      *(void *)(a1 + 1160) = v20;
      return 1;
    }
  }
  TIFFErrorExtR(a1, "LogL16Decode", "Not enough data at row %u (short %lld pixels)", v14, v15, v16, v17, v18, *(_DWORD *)(a1 + 876));
  uint64_t result = 0;
  *(void *)(a1 + 1152) = v19;
  *(void *)(a1 + 1160) = v20;
  return result;
}

void L16toY(uint64_t a1, float *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    unint64_t v4 = *(__int16 **)(a1 + 16);
    unint64_t v5 = a3 + 1;
    do
    {
      int v7 = *v4++;
      int v6 = v7;
      unsigned int v8 = v7 & 0x7FFF;
      if ((v7 & 0x7FFF) != 0)
      {
        double v9 = exp(((double)v8 + 0.5) * 0.00270760617 + -44.3614196);
        if (v6 < 0) {
          double v9 = -v9;
        }
      }
      else
      {
        double v9 = 0.0;
      }
      float v10 = v9;
      *a2++ = v10;
      --v5;
    }
    while (v5 > 1);
  }
}

void L16toGry(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    unint64_t v4 = *(__int16 **)(a1 + 16);
    unint64_t v5 = a3 + 1;
    do
    {
      int v7 = *v4++;
      int v6 = v7;
      unsigned int v8 = v7 & 0x7FFF;
      if ((v7 & 0x7FFF) != 0)
      {
        double v9 = exp(((double)v8 + 0.5) * 0.00270760617 + -44.3614196);
        if (v6 < 0) {
          double v9 = -v9;
        }
        if (v9 <= 0.0)
        {
          LOBYTE(v8) = 0;
        }
        else
        {
          LOBYTE(v8) = vcvtd_n_s64_f64(sqrt(v9), 8uLL);
          if (v9 >= 1.0) {
            LOBYTE(v8) = -1;
          }
        }
      }
      *a2++ = v8;
      --v5;
    }
    while (v5 > 1);
  }
}

uint64_t LogLuvEncode24(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4) {
    LogLuvEncode24_cold_2();
  }
  uint64_t v9 = a1[137];
  if (!v9) {
    LogLuvEncode24_cold_1();
  }
  uint64_t v10 = a2;
  uint64_t v11 = a3 / *(int *)(v9 + 12);
  if (*(_DWORD *)(v9 + 4) != 2)
  {
    if (*(void *)(v9 + 24) < v11)
    {
      TIFFErrorExtR((uint64_t)a1, "LogLuvEncode24", "Translation buffer too short", a4, a5, a6, a7, a8, v18);
      return 0;
    }
    uint64_t v13 = *(void *)(v9 + 16);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 32))(v9, a2, a3 / *(int *)(v9 + 12));
    uint64_t v10 = v13;
  }
  uint64_t v14 = (unsigned char *)a1[144];
  uint64_t v15 = a1[141];
  uint64_t v16 = v15 - a1[145];
  if (v11)
  {
    do
    {
      if (v16 <= 2)
      {
        a1[144] = v14;
        a1[145] = a1[141] - v16;
        uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
        if (!result) {
          return result;
        }
        uint64_t v14 = (unsigned char *)a1[144];
        uint64_t v16 = a1[141] - a1[145];
      }
      *uint64_t v14 = *(_WORD *)(v10 + 2);
      v14[1] = BYTE1(*(_DWORD *)v10);
      int v17 = *(_DWORD *)v10;
      v10 += 4;
      v14[2] = v17;
      v14 += 3;
      v16 -= 3;
      --v11;
    }
    while (v11);
    uint64_t v15 = a1[141];
  }
  a1[144] = v14;
  a1[145] = v15 - v16;
  return 1;
}

uint64_t Luv24fromXYZ(uint64_t result, float *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    uint64_t v4 = result;
    unint64_t v5 = *(_DWORD **)(result + 16);
    unint64_t v6 = a3 + 1;
    do
    {
      uint64_t result = LogLuv24fromXYZ(a2, *(_DWORD *)(v4 + 8));
      *v5++ = result;
      a2 += 3;
      --v6;
    }
    while (v6 > 1);
  }
  return result;
}

uint64_t Luv24fromLuv48(uint64_t result, __int16 *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    uint64_t v4 = result;
    unint64_t v5 = *(_DWORD **)(result + 16);
    unint64_t v6 = a3 + 1;
    do
    {
      int v7 = *a2;
      if (v7 < 1)
      {
        int v8 = 0;
      }
      else if ((unsigned __int16)((unsigned __int16)v7 >> 1) <= 0xE78u)
      {
        if (*(_DWORD *)(v4 + 8)) {
          int v8 = (int)(((double)v7 + -3314.0) * 0.25 + (double)rand() * 4.65661288e-10 + -0.5);
        }
        else {
          int v8 = (v7 - 3314) >> 2;
        }
      }
      else
      {
        int v8 = 1023;
      }
      uint64_t result = uv_encode(*(_DWORD *)(v4 + 8), ((double)a2[1] + 0.5) * 0.0000305175781, ((double)a2[2] + 0.5) * 0.0000305175781);
      if ((result & 0x80000000) != 0) {
        uint64_t result = uv_encode(0, 0.210526316, 0.473684211);
      }
      *v5++ = result | (v8 << 14);
      --v6;
      a2 += 3;
    }
    while (v6 > 1);
  }
  return result;
}

uint64_t LogLuvEncode32(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4) {
    LogLuvEncode32_cold_2();
  }
  uint64_t v9 = a1[137];
  if (!v9) {
    LogLuvEncode32_cold_1();
  }
  uint64_t v10 = a2;
  uint64_t v11 = a3 / *(int *)(v9 + 12);
  if (*(_DWORD *)(v9 + 4) != 2)
  {
    if (*(void *)(v9 + 24) < v11)
    {
      TIFFErrorExtR((uint64_t)a1, "LogLuvEncode32", "Translation buffer too short", a4, a5, a6, a7, a8, v27);
      return 0;
    }
    uint64_t v13 = *(void *)(v9 + 16);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 32))(v9, a2, a3 / *(int *)(v9 + 12));
    uint64_t v10 = v13;
  }
  LODWORD(v14) = 0;
  uint64_t v15 = (unsigned char *)a1[144];
  uint64_t v16 = a1[141] - a1[145];
  int v17 = 24;
  do
  {
    int v18 = v17;
    if (v11 >= 1)
    {
      uint64_t v19 = 0;
      int v20 = 255 << v17;
      do
      {
        if (v16 <= 3)
        {
          a1[144] = v15;
          a1[145] = a1[141] - v16;
          uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
          if (!result) {
            return result;
          }
          uint64_t v15 = (unsigned char *)a1[144];
          uint64_t v16 = a1[141] - a1[145];
        }
        for (uint64_t i = v19; i < v11; i += v14)
        {
          uint64_t v14 = 1;
          while (i + v14 < v11 && ((*(_DWORD *)(v10 + 4 * i + 4 * v14) ^ *(_DWORD *)(v10 + 4 * i)) & v20) == 0)
          {
            if (++v14 == 129) {
              goto LABEL_22;
            }
          }
          if (v14 >= 4) {
            break;
          }
        }
LABEL_22:
        if (((i - v19) & 0xFFFFFFFFFFFFFFFELL) == 2)
        {
          unsigned int v22 = *(_DWORD *)(v10 + 4 * v19) & v20;
          uint64_t v23 = v19 + 1;
          while ((*(_DWORD *)(v10 + 4 * v23) & v20) == v22)
          {
            if (i == ++v23)
            {
              *uint64_t v15 = i + ~(_BYTE)v19 + 127;
              v15[1] = v22 >> v18;
              v15 += 2;
              v16 -= 2;
              uint64_t v19 = i;
              goto LABEL_39;
            }
          }
        }
        while (v19 < i)
        {
          if (i - v19 >= 127) {
            uint64_t v24 = 127;
          }
          else {
            uint64_t v24 = i - v19;
          }
          if (v16 < v24 + 3)
          {
            a1[144] = v15;
            a1[145] = a1[141] - v16;
            uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
            if (!result) {
              return result;
            }
            uint64_t v15 = (unsigned char *)a1[144];
            uint64_t v16 = a1[141] - a1[145];
          }
          *v15++ = v24;
          --v16;
          if (v24)
          {
            uint64_t v25 = v24;
            do
            {
              unsigned int v26 = *(_DWORD *)(v10 + 4 * v19++);
              *v15++ = v26 >> v18;
              --v25;
            }
            while (v25);
            v16 -= v24;
          }
        }
LABEL_39:
        if ((int)v14 < 4)
        {
          LODWORD(v14) = 0;
        }
        else
        {
          *uint64_t v15 = v14 + 126;
          v15[1] = *(_DWORD *)(v10 + 4 * i) >> v18;
          v15 += 2;
          v16 -= 2;
        }
        v19 += v14;
      }
      while (v19 < v11);
    }
    int v17 = v18 - 8;
  }
  while (v18);
  a1[144] = v15;
  a1[145] = a1[141] - v16;
  return 1;
}

uint64_t Luv32fromXYZ(uint64_t result, float *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    uint64_t v4 = result;
    unint64_t v5 = *(_DWORD **)(result + 16);
    unint64_t v6 = a3 + 1;
    do
    {
      uint64_t result = LogLuv32fromXYZ(a2, *(_DWORD *)(v4 + 8));
      *v5++ = result;
      a2 += 3;
      --v6;
    }
    while (v6 > 1);
  }
  return result;
}

uint64_t Luv32fromLuv48(uint64_t result, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v4 = *(int **)(result + 16);
  if (*(_DWORD *)(result + 8))
  {
    if (a3 >= 1)
    {
      uint64_t v5 = result;
      unint64_t v6 = a3 + 1;
      do
      {
        int v7 = *a2;
        double v8 = (double)(__int16)a2[1] * 0.012512207;
        int v9 = *(_DWORD *)(v5 + 8);
        if (v9)
        {
          uint64_t result = rand();
          double v8 = v8 + (double)(int)result * 4.65661288e-10 + -0.5;
          int v9 = *(_DWORD *)(v5 + 8);
        }
        double v10 = (double)(__int16)a2[2] * 0.012512207;
        if (v9)
        {
          uint64_t result = rand();
          double v10 = v10 + (double)(int)result * 4.65661288e-10 + -0.5;
        }
        *v4++ = (int)v10 | ((int)v8 << 8) | (v7 << 16);
        --v6;
        a2 += 3;
      }
      while (v6 > 1);
    }
  }
  else if (a3 >= 1)
  {
    unint64_t v11 = a3 + 1;
    do
    {
      *v4++ = (*a2 << 16) | ((410 * (__int16)a2[1]) >> 7) & 0xFF00 | ((410 * (__int16)a2[2]) >> 15);
      --v11;
      a2 += 3;
    }
    while (v11 > 1);
  }
  return result;
}

uint64_t LogL16Encode(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a4) {
    LogL16Encode_cold_2();
  }
  uint64_t v9 = a1[137];
  if (!v9) {
    LogL16Encode_cold_1();
  }
  uint64_t v10 = a2;
  uint64_t v11 = a3 / *(int *)(v9 + 12);
  if (*(_DWORD *)(v9 + 4) != 1)
  {
    if (*(void *)(v9 + 24) < v11)
    {
      TIFFErrorExtR((uint64_t)a1, "LogL16Encode", "Translation buffer too short", a4, a5, a6, a7, a8, v27);
      return 0;
    }
    uint64_t v13 = *(void *)(v9 + 16);
    (*(void (**)(uint64_t, uint64_t, uint64_t))(v9 + 32))(v9, a2, a3 / *(int *)(v9 + 12));
    uint64_t v10 = v13;
  }
  LODWORD(v14) = 0;
  uint64_t v15 = (unsigned char *)a1[144];
  uint64_t v16 = a1[141] - a1[145];
  int v17 = 8;
  do
  {
    int v18 = v17;
    if (v11 >= 1)
    {
      uint64_t v19 = 0;
      int v20 = 255 << v17;
      do
      {
        if (v16 <= 3)
        {
          a1[144] = v15;
          a1[145] = a1[141] - v16;
          uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
          if (!result) {
            return result;
          }
          uint64_t v15 = (unsigned char *)a1[144];
          uint64_t v16 = a1[141] - a1[145];
        }
        for (uint64_t i = v19; i < v11; i += v14)
        {
          uint64_t v14 = 1;
          while (i + v14 < v11
               && (v20 & *(__int16 *)(v10 + 2 * i + 2 * v14)) == (__int16)(*(_WORD *)(v10 + 2 * i) & v20))
          {
            if (++v14 == 129) {
              goto LABEL_22;
            }
          }
          if (v14 >= 4) {
            break;
          }
        }
LABEL_22:
        if (((i - v19) & 0xFFFFFFFFFFFFFFFELL) == 2)
        {
          unsigned int v22 = (__int16)(*(_WORD *)(v10 + 2 * v19) & v20);
          uint64_t v23 = v19 + 1;
          while ((v20 & *(__int16 *)(v10 + 2 * v23)) == v22)
          {
            if (i == ++v23)
            {
              *uint64_t v15 = i + ~(_BYTE)v19 + 127;
              v15[1] = v22 >> v18;
              v15 += 2;
              v16 -= 2;
              uint64_t v19 = i;
              goto LABEL_39;
            }
          }
        }
        while (v19 < i)
        {
          if (i - v19 >= 127) {
            uint64_t v24 = 127;
          }
          else {
            uint64_t v24 = i - v19;
          }
          if (v16 < v24 + 3)
          {
            a1[144] = v15;
            a1[145] = a1[141] - v16;
            uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
            if (!result) {
              return result;
            }
            uint64_t v15 = (unsigned char *)a1[144];
            uint64_t v16 = a1[141] - a1[145];
          }
          *v15++ = v24;
          --v16;
          if (v24)
          {
            uint64_t v25 = v24;
            do
            {
              int v26 = *(__int16 *)(v10 + 2 * v19++);
              *v15++ = v26 >> v18;
              --v25;
            }
            while (v25);
            v16 -= v24;
          }
        }
LABEL_39:
        if ((int)v14 < 4)
        {
          LODWORD(v14) = 0;
        }
        else
        {
          *uint64_t v15 = v14 + 126;
          v15[1] = *(__int16 *)(v10 + 2 * i) >> v18;
          v15 += 2;
          v16 -= 2;
        }
        v19 += v14;
      }
      while (v19 < v11);
    }
    int v17 = v18 - 8;
  }
  while (v18);
  a1[144] = v15;
  a1[145] = a1[141] - v16;
  return 1;
}

uint64_t L16fromY(uint64_t result, float *a2, uint64_t a3)
{
  if (a3 >= 1)
  {
    uint64_t v4 = result;
    uint64_t v5 = *(_WORD **)(result + 16);
    unint64_t v6 = a3 + 1;
    do
    {
      float v7 = *a2++;
      uint64_t result = LogL16fromY(*(_DWORD *)(v4 + 8), v7);
      *v5++ = result;
      --v6;
    }
    while (v6 > 1);
  }
  return result;
}

void TGAWritePlugin::TGAWritePlugin(TGAWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 1413955872);
  void *v3 = &unk_1ED4E2D10;
}

void TGAWritePlugin::~TGAWritePlugin(TGAWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t TGAWritePlugin::writeOneImage(IIOImageWriteSession **this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  uint64_t __ptr = 0;
  uint64_t v41 = 0;
  __int16 v42 = 0;
  bzero(v43, 0x300uLL);
  ColorSpace = CGImageGetColorSpace(a2);
  CGColorSpaceGetType();
  CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
  size_t Width = CGImageGetWidth(a2);
  unsigned int Height = CGImageGetHeight(a2);
  if (!_ImageHasRealAlphaChannel(a2))
  {
    BOOL BoolForKey = 0;
    goto LABEL_6;
  }
  if (IIODictionary::containsKey(a3, @"kCGImageDestinationAllowAlpha"))
  {
    BOOL BoolForKey = IIODictionary::getBoolForKey(a3, @"kCGImageDestinationAllowAlpha");
    if (BoolForKey) {
      goto LABEL_8;
    }
LABEL_6:
    CGBitmapInfo v10 = 0;
    goto LABEL_9;
  }
  BOOL BoolForKey = 1;
LABEL_8:
  CGBitmapInfo v10 = 3;
LABEL_9:
  if (IIODictionary::containsKey(a3, @"Compression"))
  {
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(a3, @"Compression");
LABEL_13:
    BOOL v12 = Uint32ForKey != 0;
    goto LABEL_15;
  }
  if (IIODictionary::containsKeyGroup(a3, @"Compression", @"{TGA}"))
  {
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKeyGroup(a3, @"Compression", @"{TGA}");
    goto LABEL_13;
  }
  BOOL v12 = 1;
LABEL_15:
  if (Model == kCGColorSpaceModelRGB)
  {
    uint64_t v15 = 0;
    if (BoolForKey) {
      uint32_t v14 = 32;
    }
    else {
      uint32_t v14 = 24;
    }
  }
  else
  {
    if (Model)
    {
      if (BoolForKey) {
        uint32_t v14 = 32;
      }
      else {
        uint32_t v14 = 24;
      }
      CGColorSpaceRef v13 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
      ColorSpace = v13;
    }
    else
    {
      CGColorSpaceRef v13 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
      ColorSpace = v13;
      CGBitmapInfo v10 = 0;
      uint32_t v14 = 8;
    }
    uint64_t v15 = v13;
  }
  memset(v39, 0, sizeof(v39));
  IIODictionary::IIODictionary((IIODictionary *)v39);
  IIODictionary::setObjectForKey((IIODictionary *)v39, (const void *)*MEMORY[0x1E4F1CFD0], @"UseIndexedColorIfAvailable");
  v38.bitsPerComponent = 8;
  v38.bitsPerPixel = v14;
  v38.colorSpace = ColorSpace;
  v38.bitmapInfo = v10;
  memset(&v38.version, 0, 20);
  uint64_t v37 = 0;
  memset(v36, 0, sizeof(v36));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v36, a2, &v38, (IIODictionary *)v39);
  int v16 = IIOPixelProvider::enableIndexColorPassThrough((IIOPixelProvider *)v36);
  if (v16)
  {
    BaseColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
    size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(BaseColorSpace);
    size_t ColorTableCount = CGColorSpaceGetColorTableCount(ColorSpace);
    int v20 = (uint8_t *)malloc_type_malloc(ColorTableCount * NumberOfComponents, 0x100004077774924uLL);
    CGColorSpaceGetColorTable(ColorSpace, v20);
    int v21 = CGColorSpaceGetBaseColorSpace(ColorSpace);
    CGColorSpaceGetType();
    CGColorSpaceGetModel(v21);
    *(_WORD *)((char *)&__ptr + 1) = 257;
    uint32_t v14 = 8;
    unsigned int v22 = 1;
    char v23 = 9;
    if (!v12) {
      goto LABEL_29;
    }
    goto LABEL_28;
  }
  unsigned int v22 = v14 >> 3;
  BYTE1(__ptr) = 0;
  if (Model)
  {
    size_t ColorTableCount = 0;
    int v20 = 0;
    BYTE2(__ptr) = 2;
    char v23 = 10;
    if (v12) {
      goto LABEL_28;
    }
  }
  else
  {
    size_t ColorTableCount = 0;
    int v20 = 0;
    BYTE2(__ptr) = 3;
    char v23 = 11;
    if (v12) {
LABEL_28:
    }
      BYTE2(__ptr) = v23;
  }
LABEL_29:
  if (v16)
  {
    *(_WORD *)((char *)&__ptr + 5) = ColorTableCount;
    HIBYTE(__ptr) = 24;
  }
  WORD2(v41) = Width;
  HIWORD(v41) = Height;
  LOBYTE(v42) = v14;
  if (v14 == 32) {
    char v24 = 40;
  }
  else {
    char v24 = 32;
  }
  HIBYTE(v42) = v24;
  if (IIOImageWriteSession::putBytes(this[2], &__ptr, 0x12uLL) == 18)
  {
    if (!ColorTableCount) {
      goto LABEL_39;
    }
    uint64_t v25 = 0;
    size_t v26 = ColorTableCount;
    do
    {
      char v27 = &v43[v25];
      unsigned char *v27 = v20[v25];
      v27[1] = v20[v25 + 1];
      v27[2] = v20[v25 + 2];
      v25 += 3;
      --v26;
    }
    while (v26);
    if (IIOImageWriteSession::putBytes(this[2], v43, 3 * ColorTableCount) != 3 * ColorTableCount)
    {
      uint64_t v28 = 0;
      uint64_t v29 = 4294967246;
    }
    else
    {
LABEL_39:
      if (v12) {
        uint64_t v28 = malloc_type_malloc(Width + Width * v22, 0xA04B6A47uLL);
      }
      else {
        uint64_t v28 = 0;
      }
      v33[0] = MEMORY[0x1E4F143A8];
      v33[1] = 0x40000000;
      v33[2] = ___ZN14TGAWritePlugin13writeOneImageEP7CGImageP13IIODictionaryS3_j_block_invoke;
      v33[3] = &__block_descriptor_tmp_45;
      uint32_t v34 = v14;
      BOOL v35 = v12;
      v33[4] = this;
      v33[5] = v28;
      v33[6] = Width;
      v33[7] = v22;
      uint64_t v29 = IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v36, 0, Height, 64, (uint64_t)v33);
      if (!v20)
      {
LABEL_46:
        if (!v28) {
          goto LABEL_48;
        }
        goto LABEL_47;
      }
    }
  }
  else
  {
    uint64_t v28 = 0;
    uint64_t v29 = 4294967246;
    if (!v20) {
      goto LABEL_46;
    }
  }
  free(v20);
  if (v28) {
LABEL_47:
  }
    free(v28);
LABEL_48:
  if (v15) {
    CGColorSpaceRelease(v15);
  }
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v36);
  IIODictionary::~IIODictionary((IIODictionary *)v39);
  return v29;
}

void sub_1887B9E48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
}

uint64_t ___ZN14TGAWritePlugin13writeOneImageEP7CGImageP13IIODictionaryS3_j_block_invoke(uint64_t result, int a2, vImage_Buffer *src, unsigned char *a4)
{
  uint64_t v5 = src;
  uint64_t v6 = result;
  uint64_t v7 = *(void *)(result + 32);
  int v8 = *(_DWORD *)(result + 64);
  if (v8 == 32)
  {
    *(_DWORD *)uint32_t v34 = 50331906;
    uint64_t result = vImagePermuteChannels_ARGB8888(src, src, v34, 0);
  }
  else if (v8 == 24)
  {
    char v36 = 0;
    *(_WORD *)permuteMap = 258;
    uint64_t result = vImagePermuteChannels_RGB888(src, src, permuteMap, 0);
  }
  if (!*(unsigned char *)(v6 + 68)) {
    return IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v7 + 16), v5->data, v5->height * v5->rowBytes);
  }
  uint64_t v29 = a4;
  if (!v5->height) {
    return result;
  }
  vImagePixelCount v9 = 0;
  uint64_t v30 = v7;
  BOOL v31 = v5;
  do
  {
    CGBitmapInfo v10 = (char *)v5->data + v5->rowBytes * v9;
    int __dst = 0;
    uint64_t v11 = *(char **)(v6 + 40);
    if (*(void *)(v6 + 48) < 2uLL)
    {
      unsigned __int8 v16 = 1;
      goto LABEL_30;
    }
    vImagePixelCount v32 = v9;
    LOBYTE(v12) = 0;
    size_t v13 = *(void *)(v6 + 56);
    unint64_t v14 = 1;
    uint64_t v15 = 0x100000000;
    unsigned __int8 v16 = 1;
    int v17 = v10;
    do
    {
      memcpy(&__dst, v17, v13);
      int v17 = &v10[v13 * v14];
      int v18 = memcmp(&__dst, v17, v13);
      if ((_BYTE)v12)
      {
        if (!v18 && v12 <= 0x7Eu)
        {
          LOBYTE(v12) = v12 + 1;
          goto LABEL_25;
        }
        char *v11 = v12 ^ 0x80;
        uint64_t v19 = v11 + 1;
        memcpy(v19, &__dst, *(void *)(v6 + 56));
        LOBYTE(v12) = 0;
        size_t v13 = *(void *)(v6 + 56);
        uint64_t v11 = &v19[v13];
      }
      else
      {
        if (v18 && (v16 & 0x80) == 0)
        {
          LOBYTE(v12) = 0;
          ++v16;
          goto LABEL_25;
        }
        int v12 = v18 == 0;
        if (v12 == v16)
        {
          LOBYTE(v12) = v16;
        }
        else
        {
          LOBYTE(v20) = v16 - v12;
          char v21 = v16 - v12 - 1;
          uint64_t v22 = (v16 - v12);
          char *v11 = v21;
          char v23 = v11 + 1;
          if (v18) {
            uint64_t v20 = v20;
          }
          else {
            uint64_t v20 = v20 + 1;
          }
          memcpy(v23, &v10[*(void *)(v6 + 56) * ((v15 - (v20 << 32)) >> 32)], *(void *)(v6 + 56) * v22);
          size_t v13 = *(void *)(v6 + 56);
          uint64_t v11 = &v23[v13 * v22];
        }
      }
      unsigned __int8 v16 = 1;
LABEL_25:
      ++v14;
      v15 += 0x100000000;
    }
    while (*(void *)(v6 + 48) > v14);
    if ((_BYTE)v12)
    {
      char *v11 = v12 ^ 0x80;
      char v24 = v11 + 1;
      memcpy(v24, &__dst, *(void *)(v6 + 56));
      uint64_t v25 = &v24[*(void *)(v6 + 56)];
      uint64_t v7 = v30;
      uint64_t v5 = v31;
      vImagePixelCount v9 = v32;
      goto LABEL_31;
    }
    uint64_t v7 = v30;
    uint64_t v5 = v31;
    vImagePixelCount v9 = v32;
LABEL_30:
    char *v11 = v16 - 1;
    size_t v26 = v11 + 1;
    memcpy(v26, &v10[(*(void *)(v6 + 48) - v16) * *(void *)(v6 + 56)], *(void *)(v6 + 56) * v16);
    uint64_t v25 = &v26[*(void *)(v6 + 56) * v16];
LABEL_31:
    char v27 = *(const void **)(v6 + 40);
    size_t v28 = (v25 - v27);
    uint64_t result = IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v7 + 16), v27, v28);
    if (result != v28)
    {
      *uint64_t v29 = 1;
      return result;
    }
    ++v9;
  }
  while (v5->height > v9);
  return result;
}

void GIFBufferInfo::GIFBufferInfo(GIFBufferInfo *this, unsigned __int8 *a2, int a3, int a4, unsigned int a5, unsigned int a6)
{
  *(void *)this = &unk_1ED4DFA48;
  *((_DWORD *)this + 8) = a5;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 6) = a6;
  *((_DWORD *)this + 7) = a4;
  *((_DWORD *)this + 5) = -1;
  if (a2 && a3)
  {
    size_t v8 = a6 * (unint64_t)a5;
    vImagePixelCount v9 = malloc_type_malloc(v8, 0xA5603103uLL);
    *((void *)this + 1) = v9;
    memcpy(v9, a2, v8);
    char v10 = 1;
  }
  else
  {
    char v10 = 0;
    *((void *)this + 1) = a2;
  }
  *((unsigned char *)this + 16) = v10;
}

uint64_t GIFBufferInfo::readFromStream(GIFBufferInfo *this, CFReadStreamRef stream)
{
  uint64_t v4 = (void *)*((void *)this + 1);
  if (v4)
  {
    if (*((unsigned char *)this + 16))
    {
      free(v4);
      *((void *)this + 1) = 0;
    }
  }
  *(_DWORD *)UInt8 buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) == 4)
  {
    if (*(_DWORD *)buffer != 1111902535) {
      return 0;
    }
    size_t size = 0;
    if (CFReadStreamRead(stream, (UInt8 *)&size, 8) == 8)
    {
      if (size)
      {
        uint64_t v5 = (UInt8 *)malloc_type_malloc(size, 0x4995811EuLL);
        *((void *)this + 1) = v5;
        CFIndex v6 = CFReadStreamRead(stream, v5, size);
        if (size != v6) {
          return 4294967246;
        }
        *((unsigned char *)this + 16) = 1;
      }
      if (CFReadStreamRead(stream, (UInt8 *)this + 20, 20) == 20) {
        return 0;
      }
    }
  }
  return 4294967246;
}

void GIFBufferInfo::~GIFBufferInfo(GIFBufferInfo *this)
{
  *(void *)this = &unk_1ED4DFA48;
  __int16 v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    if (*((unsigned char *)this + 16)) {
      free(v2);
    }
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1ED4DFA48;
  __int16 v2 = (void *)*((void *)this + 1);
  if (v2 && *((unsigned char *)this + 16)) {
    free(v2);
  }

  JUMPOUT(0x18C11C0E0);
}

uint64_t GIFBufferInfo::writeToStream(GIFBufferInfo *this, CFWriteStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 1111902535;
  CFWriteStreamWrite(stream, buffer, 4);
  CFIndex v4 = *((unsigned int *)this + 6) * (unint64_t)*((unsigned int *)this + 8);
  if (!*((void *)this + 1)) {
    CFIndex v4 = 0;
  }
  bufferCFIndex Length = v4;
  CFWriteStreamWrite(stream, (const UInt8 *)&bufferLength, 8);
  uint64_t v5 = (const UInt8 *)*((void *)this + 1);
  if (v5) {
    BOOL v6 = bufferLength == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    CFWriteStreamWrite(stream, v5, bufferLength);
  }
  CFWriteStreamWrite(stream, (const UInt8 *)this + 20, 20);
  return 0;
}

void GIFColorMap::GIFColorMap(IIOColorMap *a1, int *a2)
{
}

void sub_1887BA4BC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 16);
  *(void *)(v1 + 16) = 0;
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C8033FC2DF1);
  }
  _Unwind_Resume(exception_object);
}

void GlobalGIFInfo::GlobalGIFInfo(GlobalGIFInfo *this)
{
  *(void *)this = &unk_1ED4DFB90;
  *(_OWORD *)((char *)this + 136) = 0u;
  __int16 v2 = (char *)this + 136;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 8), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 72), 0);
  std::vector<GIFFrameInfo>::resize((uint64_t)v2, 0);
  *((void *)this + 27) = 0;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
}

void sub_1887BA580(_Unwind_Exception *a1)
{
  uint64_t v5 = *v3;
  uint64_t *v3 = 0;
  if (v5) {
    std::default_delete<IIOColorMap>::operator()[abi:ne180100]((uint64_t)v3, v5);
  }
  GlobalGIFInfo::GlobalGIFInfo(v1, v2);
  _Unwind_Resume(a1);
}

void std::vector<GIFFrameInfo>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<GIFFrameInfo>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(void *)(a1 + 8) = *(void *)a1 + 40 * a2;
  }
}

void GlobalGIFInfo::GlobalGIFInfo(GlobalGIFInfo *this, unsigned __int8 *a2, CFIndex a3)
{
  *(void *)this = &unk_1ED4DFB90;
  *(_OWORD *)((char *)this + 136) = 0u;
  BOOL v6 = (char *)this + 136;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 8), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 72), 0);
  std::vector<GIFFrameInfo>::resize((uint64_t)v6, 0);
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 21);
  *((void *)this + 20) = 0;
  *((void *)this + 21) = 0;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
  size_t v8 = CFReadStreamCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  vImagePixelCount v9 = v8;
  if (v8)
  {
    if (CFReadStreamOpen(v8))
    {
      GlobalGIFInfo::readFromStream(this, v9);
      CFReadStreamClose(v9);
    }
    CFRelease(v9);
  }
}

void sub_1887BA6D8(_Unwind_Exception *exception_object)
{
  uint64_t v4 = v1[22];
  v1[22] = 0;
  if (v4) {
    std::default_delete<IIOColorMap>::operator()[abi:ne180100]((uint64_t)(v1 + 22), v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)v1[21];
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  BOOL v6 = *v2;
  if (*v2)
  {
    v1[18] = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

uint64_t GlobalGIFInfo::readFromStream(GlobalGIFInfo *this, CFReadStreamRef stream)
{
  uint64_t v15 = stream;
  int64_t v13 = 0;
  *(void *)unint64_t v14 = 0;
  *(void *)int v12 = 0;
  *(_DWORD *)UInt8 buffer = 0;
  CFReadStreamRead(stream, buffer, 4);
  if (*(_DWORD *)buffer != 1112493127) {
    return 0;
  }
  CFIndex v4 = CFReadStreamRead(stream, v14, 8);
  uint64_t result = 4294967260;
  if (v4 == 8 && *(uint64_t *)v14 >= 1)
  {
    CFIndex v6 = CFReadStreamRead(stream, v12, 8);
    uint64_t result = 4294967260;
    if (v6 == 8 && (*(void *)v12 & 0x8000000000000000) == 0)
    {
      CFIndex v7 = CFReadStreamRead(stream, (UInt8 *)&v13, 8);
      uint64_t result = 4294967260;
      if (v7 == 8
        && v13 >= 1
        && v13 == *(void *)v14
        && !__CFADD__(*(void *)v12, v13)
        && *(void *)v12 + v13 <= (unint64_t)v13)
      {
        std::vector<GIFFrameInfo>::resize((uint64_t)this + 136, v13);
        if (v13 < 1)
        {
LABEL_15:
          v10[0] = 0;
          v10[1] = 0;
          std::allocate_shared[abi:ne180100]<GIFBufferInfo,std::allocator<GIFBufferInfo>,__CFReadStream *&,void>(&v15, v10);
          if (*(unsigned int *)(v10[0] + 24) * (unint64_t)*(unsigned int *)(v10[0] + 32)) {
            GlobalGIFInfo::setCachedFrameBuffer((uint64_t)this, v10);
          }
          operator new();
        }
        size_t v8 = (UInt8 *)(*((void *)this + 17) + 40 * *(void *)v12);
        vImagePixelCount v9 = &v8[40 * v13];
        while (CFReadStreamRead(stream, v8, 40) == 40)
        {
          v8 += 40;
          if (v8 >= v9) {
            goto LABEL_15;
          }
        }
        return 4294967260;
      }
    }
  }
  return result;
}

void sub_1887BA934(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  _Unwind_Resume(exception_object);
}

void GlobalGIFInfo::~GlobalGIFInfo(GlobalGIFInfo *this)
{
  *(void *)this = &unk_1ED4DFB90;
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 8));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 72));
  uint64_t v2 = *((void *)this + 22);
  *((void *)this + 22) = 0;
  if (v2) {
    std::default_delete<IIOColorMap>::operator()[abi:ne180100]((uint64_t)this + 176, v2);
  }
  BOOL v3 = (std::__shared_weak_count *)*((void *)this + 21);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  CFIndex v4 = (void *)*((void *)this + 17);
  if (v4)
  {
    *((void *)this + 18) = v4;
    operator delete(v4);
  }
}

{
  uint64_t vars8;

  GlobalGIFInfo::~GlobalGIFInfo(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t GlobalGIFInfo::getFrameInfoAtIndex@<X0>(GlobalGIFInfo *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(void *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  CFIndex v6 = (pthread_mutex_t *)((char *)this + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 8));
  uint64_t v7 = *((void *)this + 17);
  if (-858993459 * ((unint64_t)(*((void *)this + 18) - v7) >> 3) > a2)
  {
    uint64_t v8 = v7 + 40 * a2;
    long long v9 = *(_OWORD *)(v8 + 16);
    *(_OWORD *)a3 = *(_OWORD *)v8;
    *(_OWORD *)(a3 + 16) = v9;
    *(void *)(a3 + 32) = *(void *)(v8 + 32);
  }

  return pthread_mutex_unlock(v6);
}

uint64_t GlobalGIFInfo::setFrameInfoAtIndex(uint64_t a1, long long *a2, uint64_t a3)
{
  CFIndex v6 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  uint64_t v7 = *(void *)(a1 + 136);
  unint64_t v8 = *(void *)(a1 + 144);
  uint64_t v9 = (uint64_t)(v8 - v7) >> 3;
  unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * v9;
  if (a3 >= (-858993459 * v9))
  {
    unint64_t v14 = *(void *)(a1 + 152);
    if (v8 >= v14)
    {
      if (v10 + 1 > 0x666666666666666) {
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v18 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v14 - v7) >> 3);
      uint64_t v19 = 2 * v18;
      if (2 * v18 <= v10 + 1) {
        uint64_t v19 = v10 + 1;
      }
      if (v18 >= 0x333333333333333) {
        unint64_t v20 = 0x666666666666666;
      }
      else {
        unint64_t v20 = v19;
      }
      if (v20) {
        char v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOThumbnailInfo>>(a1 + 152, v20);
      }
      else {
        char v21 = 0;
      }
      uint64_t v22 = &v21[40 * v10];
      char v23 = &v21[40 * v20];
      long long v24 = *a2;
      long long v25 = a2[1];
      *((void *)v22 + 4) = *((void *)a2 + 4);
      *(_OWORD *)uint64_t v22 = v24;
      *((_OWORD *)v22 + 1) = v25;
      int v17 = v22 + 40;
      char v27 = *(char **)(a1 + 136);
      size_t v26 = *(char **)(a1 + 144);
      if (v26 != v27)
      {
        do
        {
          long long v28 = *(_OWORD *)(v26 - 40);
          long long v29 = *(_OWORD *)(v26 - 24);
          *((void *)v22 - 1) = *((void *)v26 - 1);
          *(_OWORD *)(v22 - 24) = v29;
          *(_OWORD *)(v22 - 40) = v28;
          v22 -= 40;
          v26 -= 40;
        }
        while (v26 != v27);
        size_t v26 = *(char **)(a1 + 136);
      }
      *(void *)(a1 + 136) = v22;
      *(void *)(a1 + 144) = v17;
      *(void *)(a1 + 152) = v23;
      if (v26) {
        operator delete(v26);
      }
    }
    else
    {
      long long v15 = *a2;
      long long v16 = a2[1];
      *(void *)(v8 + 32) = *((void *)a2 + 4);
      *(_OWORD *)unint64_t v8 = v15;
      *(_OWORD *)(v8 + 16) = v16;
      int v17 = (char *)(v8 + 40);
    }
    *(void *)(a1 + 144) = v17;
  }
  else
  {
    uint64_t v11 = v7 + 40 * a3;
    long long v12 = *a2;
    long long v13 = a2[1];
    *(void *)(v11 + 32) = *((void *)a2 + 4);
    *(_OWORD *)uint64_t v11 = v12;
    *(_OWORD *)(v11 + 16) = v13;
  }

  return pthread_mutex_unlock(v6);
}

uint64_t GlobalGIFInfo::getCachedFrameBuffer@<X0>(GlobalGIFInfo *this@<X0>, void *a2@<X8>)
{
  CFIndex v4 = (pthread_mutex_t *)((char *)this + 72);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 72));
  uint64_t v5 = *((void *)this + 20);
  uint64_t v6 = *((void *)this + 21);
  *a2 = v5;
  a2[1] = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  return pthread_mutex_unlock(v4);
}

void sub_1887BACC4(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t GlobalGIFInfo::setCachedFrameBuffer(uint64_t a1, uint64_t *a2)
{
  CFIndex v4 = (pthread_mutex_t *)(a1 + 72);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 72));
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 168);
  *(void *)(a1 + 160) = v6;
  *(void *)(a1 + 168) = v5;
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }

  return pthread_mutex_unlock(v4);
}

uint64_t GlobalGIFInfo::setFinal(uint64_t this, char a2)
{
  *(unsigned char *)(this + 217) = a2;
  return this;
}

uint64_t GlobalGIFInfo::setColorSyncProfileOffset(uint64_t this, uint64_t a2)
{
  *(void *)(this + 184) = a2;
  return this;
}

uint64_t GlobalGIFInfo::frameCount(GlobalGIFInfo *this)
{
  return -858993459 * ((*((void *)this + 18) - *((void *)this + 17)) >> 3);
}

uint64_t GlobalGIFInfo::lastImageDescOffset(GlobalGIFInfo *this)
{
  return *((void *)this + 24);
}

uint64_t GlobalGIFInfo::setLastImageDescOffset(uint64_t this, uint64_t a2)
{
  *(void *)(this + 192) = a2;
  return this;
}

void GlobalGIFInfo::setGlobalColorMap(uint64_t a1, uint64_t a2)
{
  if (a2) {
    operator new();
  }
  uint64_t v2 = *(void *)(a1 + 176);
  *(void *)(a1 + 176) = 0;
  if (v2)
  {
    std::default_delete<IIOColorMap>::operator()[abi:ne180100](a1 + 176, v2);
  }
}

void sub_1887BAE14(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1020C40D090CC53);
  _Unwind_Resume(a1);
}

uint64_t GlobalGIFInfo::getSize(uint64_t this, unsigned int *a2, unsigned int *a3)
{
  *a2 = *(_DWORD *)(this + 208);
  *a3 = *(_DWORD *)(this + 212);
  return this;
}

uint64_t GlobalGIFInfo::setSize(uint64_t this, int a2, int a3)
{
  *(_DWORD *)(this + 208) = a2;
  *(_DWORD *)(this + 212) = a3;
  return this;
}

uint64_t GlobalGIFInfo::lastFrameCount(GlobalGIFInfo *this)
{
  return *((unsigned int *)this + 50);
}

uint64_t GlobalGIFInfo::setLastFrameCount(uint64_t this, int a2)
{
  *(_DWORD *)(this + 200) = a2;
  return this;
}

BOOL GlobalGIFInfo::frameSizesMatchCanvasSize(GlobalGIFInfo *this, int a2, int a3)
{
  uint64_t v4 = *((void *)this + 17);
  uint64_t v3 = *((void *)this + 18);
  if (v4 == v3) {
    return 0;
  }
  uint64_t v5 = v4 + 40;
  do
  {
    BOOL v6 = *(unsigned __int16 *)(v5 - 28) == a2 || *(unsigned __int16 *)(v5 - 26) == a3;
    BOOL result = v6;
    if (v6) {
      break;
    }
    BOOL v6 = v5 == v3;
    v5 += 40;
  }
  while (!v6);
  return result;
}

uint64_t GlobalGIFInfo::getMinMaxFrames(uint64_t this, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned __int16 *a5)
{
  uint64_t v5 = *(unsigned __int16 **)(this + 136);
  BOOL v6 = *(unsigned __int16 **)(this + 144);
  if (v5 == v6)
  {
    LOWORD(v8) = 0;
    LOWORD(v7) = 0;
    LOWORD(v10) = 16959;
    LOWORD(v9) = 16959;
  }
  else
  {
    int v7 = 0;
    int v8 = 0;
    int v9 = 999999;
    int v10 = 999999;
    do
    {
      if (v10 >= v5[4]) {
        int v10 = v5[4];
      }
      if (v9 >= v5[5]) {
        int v9 = v5[5];
      }
      if (v8 <= v5[6]) {
        int v8 = v5[6];
      }
      if (v7 <= v5[7]) {
        int v7 = v5[7];
      }
      v5 += 20;
    }
    while (v5 != v6);
  }
  *a2 = v10;
  *a3 = v9;
  *a4 = v8;
  *a5 = v7;
  return this;
}

uint64_t GlobalGIFInfo::writeToStream(GlobalGIFInfo *this, CFWriteStreamRef stream, const CFRange *a3)
{
  p_CFIndex length = &a3->length;
  if (a3->location + a3->length > 0xCCCCCCCCCCCCCCCDLL
                                 * ((uint64_t)(*((void *)this + 18) - *((void *)this + 17)) >> 3))
    return 4294967246;
  *(_DWORD *)UInt8 buffer = 1112493127;
  CFWriteStreamWrite(stream, buffer, 4);
  unint64_t v14 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*((void *)this + 18) - *((void *)this + 17)) >> 3);
  CFWriteStreamWrite(stream, (const UInt8 *)&v14, 8);
  CFWriteStreamWrite(stream, (const UInt8 *)a3, 8);
  CFWriteStreamWrite(stream, (const UInt8 *)p_length, 8);
  CFIndex length = a3->length;
  if (length >= 1)
  {
    int v9 = (const UInt8 *)(*((void *)this + 17) + 40 * a3->location);
    int v10 = &v9[40 * length];
    do
    {
      CFWriteStreamWrite(stream, v9, 40);
      v9 += 40;
    }
    while (v9 < v10);
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 72));
  uint64_t v11 = (GIFBufferInfo *)*((void *)this + 20);
  if (v11)
  {
    GIFBufferInfo::writeToStream(v11, stream);
  }
  else
  {
    *(_DWORD *)long long v16 = 1650878823;
    CFWriteStreamWrite(stream, v16, 4);
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 72));
  long long v13 = (IIOColorMap *)*((void *)this + 22);
  if (v13) {
    IIOColorMap::writeToStream(v13, stream);
  }
  else {
    IIOColorMap::writeEmptyPlaceholderToStream(stream, v12);
  }
  CFWriteStreamWrite(stream, (const UInt8 *)this + 184, 40);
  return 0;
}

CFTypeRef GlobalGIFInfo::createDataRepresentation(GlobalGIFInfo *this, const CFRange *a2)
{
  uint64_t v4 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v4;
  if (CFWriteStreamOpen(v4))
  {
    GlobalGIFInfo::writeToStream(this, v5, a2);
    CFTypeRef v6 = CFWriteStreamCopyProperty(v5, (CFStreamPropertyKey)*MEMORY[0x1E4F1D440]);
    CFWriteStreamClose(v5);
  }
  else
  {
    CFTypeRef v6 = 0;
  }
  CFRelease(v5);
  return v6;
}

void IIO_addDelayTimeToDictionary(unsigned int a1, IIODictionary *a2, const __CFString *a3)
{
  if (a1 >= 2) {
    unsigned int v5 = a1;
  }
  else {
    unsigned int v5 = 10;
  }
  double v6 = (double)v5 / 100.0;
  if (a3)
  {
    IIONumber::IIONumber((IIONumber *)v14, v6);
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v14, @"DelayTime", a3);
    IIONumber::~IIONumber((IIONumber *)v14);
    double v8 = (double)a1 / 100.0;
    int v9 = (IIONumber *)v12;
    IIONumber::IIONumber((IIONumber *)v12, v8);
    IIODictionary::setObjectForKeyGroup(a2, (uint64_t)v12, @"UnclampedDelayTime", a3);
  }
  else
  {
    IIONumber::IIONumber((IIONumber *)v13, v6);
    IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v13, @"DelayTime");
    IIONumber::~IIONumber((IIONumber *)v13);
    double v10 = (double)a1 / 100.0;
    int v9 = (IIONumber *)v11;
    IIONumber::IIONumber((IIONumber *)v11, v10);
    IIODictionary::setObjectForKey((uint64_t)a2, (uint64_t)v11, @"UnclampedDelayTime");
  }
  IIONumber::~IIONumber(v9);
}

void sub_1887BB278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::default_delete<IIOColorMap>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = 0;
    if (v2) {
      MEMORY[0x18C11C0C0](v2, 0x1000C8033FC2DF1);
    }
    JUMPOUT(0x18C11C0E0);
  }
}

void std::vector<GIFFrameInfo>::__append(void **a1, unint64_t a2)
{
  double v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  unsigned int v5 = v6;
  int v7 = *(char **)(v4 - 8);
  if (0xCCCCCCCCCCCCCCCDLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 40 * ((40 * a2 - 40) / 0x28) + 40;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((v7 - (unsigned char *)*a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x666666666666666) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - (unsigned char *)*a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x333333333333333) {
      unint64_t v11 = 0x666666666666666;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11) {
      long long v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOThumbnailInfo>>(v4, v11);
    }
    else {
      long long v12 = 0;
    }
    unint64_t v14 = &v12[40 * v8];
    long long v15 = &v12[40 * v11];
    size_t v16 = 40 * ((40 * a2 - 40) / 0x28) + 40;
    bzero(v14, v16);
    int v17 = &v14[v16];
    uint64_t v19 = (char *)*a1;
    unint64_t v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        long long v20 = *(_OWORD *)(v18 - 40);
        long long v21 = *(_OWORD *)(v18 - 24);
        *((void *)v14 - 1) = *((void *)v18 - 1);
        *(_OWORD *)(v14 - 24) = v21;
        *(_OWORD *)(v14 - 40) = v20;
        v14 -= 40;
        v18 -= 40;
      }
      while (v18 != v19);
      unint64_t v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
    {
      operator delete(v18);
    }
  }
}

uint64_t std::allocate_shared[abi:ne180100]<GIFBufferInfo,std::allocator<GIFBufferInfo>,__CFReadStream *&,void>@<X0>(__CFReadStream **a1@<X1>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x40uLL);
  uint64_t result = std::__shared_ptr_emplace<GIFBufferInfo>::__shared_ptr_emplace[abi:ne180100]<__CFReadStream *&,std::allocator<GIFBufferInfo>,0>((uint64_t)v4, a1);
  *a2 = v4 + 24;
  a2[1] = v4;
  return result;
}

void sub_1887BB500(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<GIFBufferInfo>::__shared_ptr_emplace[abi:ne180100]<__CFReadStream *&,std::allocator<GIFBufferInfo>,0>(uint64_t a1, __CFReadStream **a2)
{
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)a1 = &unk_1ED4EF310;
  uint64_t v3 = *a2;
  *(void *)(a1 + 24) = &unk_1ED4DFA48;
  *(void *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 60) = 0;
  *(_OWORD *)(a1 + 44) = 0u;
  GIFBufferInfo::readFromStream((GIFBufferInfo *)(a1 + 24), v3);
  return a1;
}

void sub_1887BB58C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<GIFBufferInfo>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED4EF310;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<GIFBufferInfo>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED4EF310;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18C11C0E0);
}

uint64_t std::__shared_ptr_emplace<GIFBufferInfo>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

unint64_t XXH64(uint64_t *a1, unint64_t a2, unint64_t a3)
{
  uint64_t v4 = a1;
  if (a2 < 0x20)
  {
    unint64_t v13 = a3 + 0x27D4EB2F165667C5;
  }
  else
  {
    unint64_t v5 = (unint64_t)a1 + a2 - 32;
    unint64_t v6 = a3 + 0x60EA27EEADC0B5D6;
    unint64_t v7 = a3 - 0x3D4D51C2D82B14B1;
    unint64_t v8 = a3 + 0x61C8864E7A143579;
    do
    {
      uint64_t v9 = __ROR8__(v6 - 0x3D4D51C2D82B14B1 * *v4, 33);
      unint64_t v6 = 0x9E3779B185EBCA87 * v9;
      uint64_t v10 = __ROR8__(v7 - 0x3D4D51C2D82B14B1 * v4[1], 33);
      unint64_t v7 = 0x9E3779B185EBCA87 * v10;
      uint64_t v11 = __ROR8__(a3 - 0x3D4D51C2D82B14B1 * v4[2], 33);
      a3 = 0x9E3779B185EBCA87 * v11;
      uint64_t v12 = __ROR8__(v8 - 0x3D4D51C2D82B14B1 * v4[3], 33);
      unint64_t v8 = 0x9E3779B185EBCA87 * v12;
      v4 += 4;
    }
    while ((unint64_t)v4 <= v5);
    unint64_t v13 = 0x9E3779B185EBCA87
        * ((0x9E3779B185EBCA87
          * ((0x9E3779B185EBCA87
            * ((0x9E3779B185EBCA87
              * ((__ROR8__(v7, 57) + __ROR8__(v6, 63) + __ROR8__(a3, 52) + __ROR8__(v8, 46)) ^ (0x9E3779B185EBCA87
                                                                                              * __ROR8__(0xDEF35B010F796CA9* v9, 33)))- 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v10, 33)))- 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v11, 33)))- 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xDEF35B010F796CA9 * v12, 33)))- 0x7A1435883D4D519DLL;
  }
  return XXH64_finalize(v13 + a2, v4, a2);
}

void *XXH64_createState()
{
  return malloc_type_malloc(0x58uLL, 0x5F4BD4DCuLL);
}

uint64_t XXH64_freeState(void *a1)
{
  return 0;
}

uint64_t XXH64_reset(uint64_t a1, unint64_t a2)
{
  *(void *)a1 = 0;
  *(int64x2_t *)(a1 + 8) = vaddq_s64(vdupq_n_s64(a2), (int64x2_t)xmmword_1889AD000);
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 32) = a2 + 0x61C8864E7A143579;
  *(_OWORD *)(a1 + 40) = v3;
  *(_OWORD *)(a1 + 56) = v4;
  *(void *)(a1 + 72) = 0;
  return 0;
}

uint64_t XXH64_update(uint64_t a1, char *__src, size_t __n)
{
  if (!__src) {
    return 1;
  }
  int v3 = __n;
  long long v4 = __src;
  *(void *)a1 += __n;
  uint64_t v6 = *(unsigned int *)(a1 + 72);
  if (v6 + __n <= 0x1F)
  {
    memcpy((void *)(a1 + v6 + 40), __src, __n);
    LODWORD(v7) = *(_DWORD *)(a1 + 72) + v3;
LABEL_13:
    uint64_t result = 0;
    *(_DWORD *)(a1 + 72) = v7;
    return result;
  }
  uint64_t v9 = &__src[__n];
  if (v6)
  {
    memcpy((void *)(a1 + 40 + v6), __src, (32 - v6));
    uint64_t v10 = __ROR8__(*(void *)(a1 + 16) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 48), 33);
    *(void *)(a1 + 8) = 0x9E3779B185EBCA87
                        * __ROR8__(*(void *)(a1 + 8) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 40), 33);
    *(void *)(a1 + 16) = 0x9E3779B185EBCA87 * v10;
    unint64_t v11 = 0x9E3779B185EBCA87 * __ROR8__(*(void *)(a1 + 32) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 64), 33);
    *(void *)(a1 + 24) = 0x9E3779B185EBCA87
                         * __ROR8__(*(void *)(a1 + 24) - 0x3D4D51C2D82B14B1 * *(void *)(a1 + 56), 33);
    *(void *)(a1 + 32) = v11;
    v4 += (32 - *(_DWORD *)(a1 + 72));
    *(_DWORD *)(a1 + 72) = 0;
  }
  if (v4 + 32 <= v9)
  {
    unint64_t v12 = *(void *)(a1 + 8);
    unint64_t v13 = *(void *)(a1 + 16);
    unint64_t v15 = *(void *)(a1 + 24);
    unint64_t v14 = *(void *)(a1 + 32);
    do
    {
      unint64_t v12 = 0x9E3779B185EBCA87 * __ROR8__(v12 - 0x3D4D51C2D82B14B1 * *(void *)v4, 33);
      unint64_t v13 = 0x9E3779B185EBCA87 * __ROR8__(v13 - 0x3D4D51C2D82B14B1 * *((void *)v4 + 1), 33);
      unint64_t v15 = 0x9E3779B185EBCA87 * __ROR8__(v15 - 0x3D4D51C2D82B14B1 * *((void *)v4 + 2), 33);
      unint64_t v14 = 0x9E3779B185EBCA87 * __ROR8__(v14 - 0x3D4D51C2D82B14B1 * *((void *)v4 + 3), 33);
      v4 += 32;
    }
    while (v4 <= v9 - 32);
    *(void *)(a1 + 8) = v12;
    *(void *)(a1 + 16) = v13;
    *(void *)(a1 + 24) = v15;
    *(void *)(a1 + 32) = v14;
  }
  if (v4 < v9)
  {
    size_t v7 = v9 - v4;
    memcpy((void *)(a1 + 40), v4, v7);
    goto LABEL_13;
  }
  return 0;
}

unint64_t XXH64_digest(void *a1)
{
  if (*a1 < 0x20uLL) {
    uint64_t v1 = a1[3] + 0x27D4EB2F165667C5;
  }
  else {
    uint64_t v1 = 0x9E3779B185EBCA87
  }
       * ((0x9E3779B185EBCA87
         * ((0x9E3779B185EBCA87
           * ((0x9E3779B185EBCA87
             * ((__ROR8__(a1[2], 57) + __ROR8__(a1[1], 63) + __ROR8__(a1[3], 52) + __ROR8__(a1[4], 46)) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[1], 33)))
             - 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[2], 33)))
           - 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[3], 33)))
         - 0x7A1435883D4D519DLL) ^ (0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * a1[4], 33)))
       - 0x7A1435883D4D519DLL;
  return XXH64_finalize(v1 + *a1, a1 + 5, *a1);
}

unint64_t XXH64_finalize(unint64_t a1, uint64_t *a2, char a3)
{
  unint64_t v3 = a3 & 0x1F;
  if (v3 >= 8)
  {
    do
    {
      uint64_t v4 = *a2++;
      a1 = 0x85EBCA77C2B2AE63
         - 0x61C8864E7A143579 * __ROR8__((0x9E3779B185EBCA87 * __ROR8__(0xC2B2AE3D27D4EB4FLL * v4, 33)) ^ a1, 37);
      v3 -= 8;
    }
    while (v3 > 7);
  }
  if (v3 >= 4)
  {
    unsigned int v5 = *(_DWORD *)a2;
    a2 = (uint64_t *)((char *)a2 + 4);
    a1 = 0x165667B19E3779F9 - 0x3D4D51C2D82B14B1 * __ROR8__((0x9E3779B185EBCA87 * v5) ^ a1, 41);
    v3 -= 4;
  }
  for (; v3; --v3)
  {
    unsigned int v6 = *(unsigned __int8 *)a2;
    a2 = (uint64_t *)((char *)a2 + 1);
    a1 = 0x9E3779B185EBCA87 * __ROR8__((0x27D4EB2F165667C5 * v6) ^ a1, 53);
  }
  unint64_t v7 = 0x165667B19E3779F9
     * ((0xC2B2AE3D27D4EB4FLL * (a1 ^ (a1 >> 33))) ^ ((0xC2B2AE3D27D4EB4FLL * (a1 ^ (a1 >> 33))) >> 29));
  return v7 ^ HIDWORD(v7);
}

void _MPEntry::_MPEntry(_MPEntry *this, unsigned __int8 *a2)
{
  *(void *)this = &unk_1ED4E5F00;
  operator new();
}

void sub_1887BBDE4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

void _MPEntry::_MPEntry(_MPEntry *this, __CFReadStream *a2)
{
  *(void *)this = &unk_1ED4E5F00;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  int v2 = _MPEntry::readFromStream((UInt8 *)this, a2);
  if (v2)
  {
    int v3 = v2;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = v3;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
}

uint64_t _MPEntry::readFromStream(UInt8 *this, CFReadStreamRef stream)
{
  CFErrorRef v11 = 0;
  *(void *)UInt8 buffer = 0;
  if (CFReadStreamRead(stream, &buffer[4], 4) == 4)
  {
    if (*(_DWORD *)&buffer[4] != 1850036301) {
      return 0;
    }
    if (CFReadStreamRead(stream, buffer, 4) == 4)
    {
      if (*(_DWORD *)buffer)
      {
        uint64_t v4 = (UInt8 *)malloc_type_malloc(*(unsigned int *)buffer, 0x4053A1F3uLL);
        if (v4)
        {
          unsigned int v5 = v4;
          CFIndex v6 = CFReadStreamRead(stream, v4, *(unsigned int *)buffer);
          if (v6 != *(unsigned int *)buffer) {
            return 4294967246;
          }
          CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          CFDataRef v8 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5, v6, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
          if (v8)
          {
            CFDataRef v9 = v8;
            if (CFPropertyListCreateWithData(v7, v8, 0, 0, &v11)) {
              operator new();
            }
            CFRelease(v9);
          }
          free(v5);
        }
      }
      if (CFReadStreamRead(stream, this + 8, 25) == 25) {
        return 0;
      }
    }
  }
  return 4294967246;
}

void sub_1887BC000(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

void _MPEntry::~_MPEntry(_MPEntry *this)
{
  *(void *)this = &unk_1ED4E5F00;
  uint64_t v2 = *((void *)this + 5);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((void *)this + 5) = 0;
  *(_DWORD *)((char *)this + 17) = 0;
  uint64_t v3 = *((void *)this + 6);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
}

{
  uint64_t vars8;

  _MPEntry::~_MPEntry(this);

  JUMPOUT(0x18C11C0E0);
}

BOOL _MPEntry::isLargeThumbnail(_MPEntry *this)
{
  return (*(_DWORD *)((char *)this + 13) - 65537) < 2;
}

uint64_t _MPEntry::imageOffset(_MPEntry *this)
{
  return *(void *)((char *)this + 21);
}

uint64_t _MPEntry::imageSize(_MPEntry *this)
{
  return *(unsigned int *)((char *)this + 17);
}

void _MPEntry::updataMetadata(_MPEntry *this, unsigned __int8 *a2, unsigned int a3, _TAG *a4, uint64_t a5)
{
  int v10 = *((unsigned __int16 *)a4 + 20);
  switch(*((_WORD *)a4 + 20))
  {
    case 0xB201:
      CFErrorRef v11 = @"PanOrientation";
      goto LABEL_19;
    case 0xB202:
      CFErrorRef v11 = @"PanOverlap_H";
      goto LABEL_19;
    case 0xB203:
      CFErrorRef v11 = @"PanOverlap_V";
      goto LABEL_19;
    case 0xB204:
      CFErrorRef v11 = @"BaseViewpointNum";
      goto LABEL_19;
    case 0xB205:
      CFErrorRef v11 = @"ConvergenceAngle";
      goto LABEL_19;
    case 0xB206:
      CFErrorRef v11 = @"BaselineLength";
      goto LABEL_19;
    case 0xB207:
      CFErrorRef v11 = @"VerticalDivergence";
      goto LABEL_19;
    case 0xB208:
      CFErrorRef v11 = @"AxisDistance_X";
      goto LABEL_19;
    case 0xB209:
      CFErrorRef v11 = @"AxisDistance_Y";
      goto LABEL_19;
    case 0xB20A:
      CFErrorRef v11 = @"AxisDistance_Z";
      goto LABEL_19;
    case 0xB20B:
      CFErrorRef v11 = @"YawAngle";
      goto LABEL_19;
    case 0xB20C:
      CFErrorRef v11 = @"PitchAngle";
      goto LABEL_19;
    case 0xB20D:
      CFErrorRef v11 = @"RollAngle";
      goto LABEL_19;
    default:
      if (v10 == 45056)
      {
        CFErrorRef v11 = @"MPFVersion";
      }
      else
      {
        if (v10 != 45313) {
          return;
        }
        CFErrorRef v11 = @"MPIndividualNum";
      }
LABEL_19:
      int v12 = (*(uint64_t (**)(_TAG *))(*(void *)a4 + 48))(a4);
      int v13 = (*(uint64_t (**)(_TAG *))(*(void *)a4 + 56))(a4);
      unsigned int v14 = _TAG::nativeDataOrOffset(a4);
      if (v12 == 1)
      {
        uint64_t v15 = v14;
        if (v13 == 10 || v13 == 5)
        {
          uint64_t v23 = 0;
          memset(v22, 0, sizeof(v22));
          IIOScanner::IIOScanner((IIOScanner *)v22, a2, a3, *(unsigned char *)(*((void *)this + 6) + 68));
          IIOScanner::seek((IIOScanner *)v22, v15 + a5);
          unsigned int Val32 = IIOScanner::getVal32((IIOScanner *)v22);
          unsigned int v18 = IIOScanner::getVal32((IIOScanner *)v22);
          if (v18)
          {
            uint64_t v19 = *((void *)this + 5);
            IIONumber::IIONumber((IIONumber *)v21, (double)Val32 / (double)v18);
            IIODictionary::setObjectForKey(v19, (uint64_t)v21, v11);
            IIONumber::~IIONumber((IIONumber *)v21);
          }
          IIOScanner::~IIOScanner((IIOScanner *)v22);
        }
        else if (v13 == 4)
        {
          uint64_t v20 = *((void *)this + 5);
          IIONumber::IIONumber((IIONumber *)v24, v14);
          IIODictionary::setObjectForKey(v20, (uint64_t)v24, v11);
          IIONumber::~IIONumber((IIONumber *)v24);
        }
      }
      return;
  }
}

void sub_1887BC3A0(_Unwind_Exception *a1)
{
  IIONumber::~IIONumber((IIONumber *)(v1 - 88));
  _Unwind_Resume(a1);
}

uint64_t _MPEntry::writeToStream(_MPEntry *this, CFWriteStreamRef stream)
{
  CFErrorRef error = 0;
  int v8 = 1850036301;
  CFWriteStreamWrite(stream, (const UInt8 *)&v8, 4);
  CFDataRef v4 = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *(CFPropertyListRef *)(*((void *)this + 5) + 8), kCFPropertyListXMLFormat_v1_0, 0, &error);
  if (v4)
  {
    CFDataRef v5 = v4;
    *(_DWORD *)UInt8 buffer = CFDataGetLength(v4);
    CFWriteStreamWrite(stream, buffer, 4);
    if (*(_DWORD *)buffer)
    {
      BytePtr = CFDataGetBytePtr(v5);
      CFWriteStreamWrite(stream, BytePtr, *(unsigned int *)buffer);
    }
    CFWriteStreamWrite(stream, (const UInt8 *)this + 8, 25);
    CFRelease(v5);
  }
  return 0;
}

void _MPExtension::_MPExtension(_MPExtension *this, unsigned __int8 *a2, uint64_t a3, uint64_t a4, int a5, int a6, char a7)
{
  _APPx::_APPx(this, a2, a3, a4, a5, a6, a7);
  *(void *)uint64_t v8 = &unk_1ED4DF390;
  *(_OWORD *)(v8 + 80) = 0u;
  *(_OWORD *)(v8 + 96) = 0u;
  std::vector<_APPx *>::resize(v8 + 88, 0);
  *((unsigned char *)this + 73) = 1;
}

void sub_1887BC554(_Unwind_Exception *a1)
{
  CFDataRef v4 = *v2;
  if (*v2)
  {
    *((void *)v1 + 12) = v4;
    operator delete(v4);
  }
  _APPx::~_APPx(v1);
  _Unwind_Resume(a1);
}

void _MPExtension::~_MPExtension(_MPExtension *this)
{
  *(void *)this = &unk_1ED4DF390;
  uint64_t v2 = *((void *)this + 10);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *((void *)this + 10) = 0;
  uint64_t v3 = (void *)*((void *)this + 11);
  CFDataRef v4 = (void *)*((void *)this + 12);
  if (v3 != v4)
  {
    do
    {
      if (*v3) {
        (*(void (**)(void))(*(void *)*v3 + 8))(*v3);
      }
      ++v3;
    }
    while (v3 != v4);
    uint64_t v3 = (void *)*((void *)this + 11);
  }
  *((void *)this + 12) = v3;
  if (v3) {
    operator delete(v3);
  }

  _APPx::~_APPx(this);
}

{
  uint64_t vars8;

  _MPExtension::~_MPExtension(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t _MPExtension::getShortBE(_MPExtension *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = v1 + 2;
  uint64_t v3 = *((void *)this + 6);
  if (v1 + 2 >= v3)
  {
    _cg_jpeg_mem_term("getShortBE", 313, "out-of-bounds-read: _pos = %d   _jpegDataCFStringRef Size = %d\n", v1, v3);
    return 0;
  }
  else
  {
    uint64_t v4 = bswap32(*(unsigned __int16 *)(*((void *)this + 5) + v1)) >> 16;
    *((void *)this + 3) = v2;
  }
  return v4;
}

__n128 _MPExtension::processData(_MPExtension *this)
{
  _APPx::processData(this);
  uint64_t v2 = *((void *)this + 2) + 8;
  *((void *)this + 3) = v2;
  *((_DWORD *)this + 16) = v2;
  if ((*(unsigned int (**)(_MPExtension *))(*(void *)this + 104))(this) == 18761) {
    *((unsigned char *)this + 32) = 1;
  }
  *((void *)this + 3) += 2;
  *((void *)this + 3) = *((_DWORD *)this + 16)
                        + (*(unsigned int (**)(_MPExtension *))(*(void *)this + 112))(this);
  unsigned int v3 = (*(uint64_t (**)(_MPExtension *))(*(void *)this + 104))(this);
  if (v3 && *((void *)this + 6) > (uint64_t)v3) {
    operator new();
  }
  return _cg_jpeg_mem_term("processData", 536, "*** ERROR: bad idfCount: %d\n", v3);
}

void sub_1887BCE98(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1091C40D65CC8F0);
  _Unwind_Resume(a1);
}

_TAGList *_MPExtension::dumpTags(_MPExtension *this)
{
  uint64_t result = (_TAGList *)*((void *)this + 10);
  if (result) {
    uint64_t result = (_TAGList *)_TAGList::dump(result);
  }
  uint64_t v3 = *((void *)this + 11);
  if (*((void *)this + 12) != v3)
  {
    uint64_t v4 = 0;
    int v5 = 0;
    do
    {
      uint64_t result = (_TAGList *)(*(uint64_t (**)(void))(**(void **)(v3 + 8 * v4) + 16))(*(void *)(v3 + 8 * v4));
      uint64_t v4 = (unsigned __int16)++v5;
      uint64_t v3 = *((void *)this + 11);
    }
    while ((unsigned __int16)v5 < (unint64_t)((*((void *)this + 12) - v3) >> 3));
  }
  return result;
}

void _MPExtension::addMetadata(_MPExtension *this, CFMutableArrayRef theArray)
{
  if (theArray)
  {
    uint64_t v3 = *((void *)this + 11);
    if (*((void *)this + 12) != v3)
    {
      uint64_t v5 = 0;
      int v6 = 0;
      do
      {
        CFArrayAppendValue(theArray, *(const void **)(*(void *)(*(void *)(v3 + 8 * v5) + 40) + 8));
        uint64_t v5 = (unsigned __int16)++v6;
        uint64_t v3 = *((void *)this + 11);
      }
      while ((unsigned __int16)v6 < (unint64_t)((*((void *)this + 12) - v3) >> 3));
    }
  }
}

void _MPOFile::~_MPOFile(_MPOFile *this)
{
  _JPEGFile::~_JPEGFile(this);

  JUMPOUT(0x18C11C0E0);
}

__CFArray *_MPOFile::CopyMetadata(_MPOFile *this)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v3 = (_MPExtension *)(*(uint64_t (**)(_MPOFile *))(*(void *)this + 32))(this);
  if (v3) {
    _MPExtension::addMetadata(v3, Mutable);
  }
  return Mutable;
}

uint64_t _MPOFile::processData(_MPOFile *this)
{
  *((void *)this + 5) = 0;
  uint64_t result = _JPEGFile::getshort(this);
  if (result == 65496)
  {
    uint64_t v3 = *((void *)this + 5);
    uint64_t result = _JPEGFile::getshort(this);
    if (result >> 8 >= 0xFF)
    {
      unsigned __int16 v4 = result;
      _JPEGFile::getshort(this);
      *((void *)this + 5) = v3;
      if (v4 == 65506 && !strncmp((const char *)(v3 + *((void *)this + 3) + 4), "MPF", 3uLL)) {
        operator new();
      }
      operator new();
    }
  }
  return result;
}

void sub_1887BD1F0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B1C40F187F6C8);
  _Unwind_Resume(a1);
}

uint64_t _MPOFile::findMPExtension(_MPOFile *this)
{
  uint64_t v1 = *((void *)this + 9);
  uint64_t v2 = *((void *)this + 10);
  while (v1 != v2)
  {
    uint64_t result = *(void *)v1;
    if (*(__int16 *)(*(void *)v1 + 56) == -30 && *(unsigned char *)(result + 73)) {
      return result;
    }
    v1 += 8;
  }
  return 0;
}

_TAGList *_MPOFile::dump(_MPOFile *this, const char *a2)
{
  _JPEGFile::dump((uint64_t)this, a2);
  uint64_t result = (_TAGList *)(*(uint64_t (**)(_MPOFile *))(*(void *)this + 32))(this);
  if (result)
  {
    return _MPExtension::dumpTags(result);
  }
  return result;
}

uint64_t globalMPOInfoReleaseProc(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void GlobalMPOInfo::GlobalMPOInfo(GlobalMPOInfo *this)
{
  *(void *)this = &unk_1ED4DFBB0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *((void *)this + 5) = 0;
  std::vector<_APPx *>::resize((uint64_t)this + 24, 0);
  *((void *)this + 6) = 0;
}

void sub_1887BD368(_Unwind_Exception *exception_object)
{
  unsigned __int16 v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void GlobalMPOInfo::GlobalMPOInfo(GlobalMPOInfo *this, unsigned __int8 *a2, CFIndex a3)
{
  *(void *)this = &unk_1ED4DFBB0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
  *((void *)this + 5) = 0;
  std::vector<_APPx *>::resize((uint64_t)this + 24, 0);
  *((void *)this + 6) = 0;
  int v6 = CFReadStreamCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  CFAllocatorRef v7 = v6;
  if (v6)
  {
    if (CFReadStreamOpen(v6))
    {
      GlobalMPOInfo::readFromStream(this, v7);
      CFReadStreamClose(v7);
    }
    CFRelease(v7);
  }
}

void sub_1887BD44C(_Unwind_Exception *exception_object)
{
  unsigned __int16 v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t GlobalMPOInfo::readFromStream(GlobalMPOInfo *this, CFReadStreamRef stream)
{
  *(void *)int v6 = 0;
  *(_DWORD *)UInt8 buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) != 4) {
    return 4294967246;
  }
  if (*(_DWORD *)buffer != 1112493127) {
    return 0;
  }
  if (CFReadStreamRead(stream, v6, 8) != 8) {
    return 4294967246;
  }
  std::vector<_MPEntry *>::reserve((void **)this + 3, *(unint64_t *)v6);
  if (*(uint64_t *)v6 >= 1) {
    operator new();
  }
  if (CFReadStreamRead(stream, (UInt8 *)this + 8, 16) == 16) {
    return 0;
  }
  else {
    return 4294967246;
  }
}

void GlobalMPOInfo::~GlobalMPOInfo(GlobalMPOInfo *this)
{
  *(void *)this = &unk_1ED4DFBB0;
  uint64_t v2 = (const void *)*((void *)this + 6);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 3);
  unsigned __int16 v4 = (void *)*((void *)this + 4);
  if (v3 != v4)
  {
    do
    {
      if (*v3) {
        (*(void (**)(void))(*(void *)*v3 + 8))(*v3);
      }
      ++v3;
    }
    while (v3 != v4);
    uint64_t v3 = (void *)*((void *)this + 3);
  }
  *((void *)this + 4) = v3;
  if (v3) {
    operator delete(v3);
  }
}

{
  uint64_t vars8;

  GlobalMPOInfo::~GlobalMPOInfo(this);

  JUMPOUT(0x18C11C0E0);
}

CFTypeRef GlobalMPOInfo::createDataRepresentation(GlobalMPOInfo *this)
{
  uint64_t v2 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  if (CFWriteStreamOpen(v2))
  {
    GlobalMPOInfo::writeToStream(this, v3);
    CFTypeRef v4 = CFWriteStreamCopyProperty(v3, (CFStreamPropertyKey)*MEMORY[0x1E4F1D440]);
    CFWriteStreamClose(v3);
  }
  else
  {
    CFTypeRef v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

uint64_t GlobalMPOInfo::writeToStream(GlobalMPOInfo *this, CFWriteStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 1112493127;
  CFWriteStreamWrite(stream, buffer, 4);
  uint64_t v8 = (uint64_t)(*((void *)this + 4) - *((void *)this + 3)) >> 3;
  CFWriteStreamWrite(stream, (const UInt8 *)&v8, 8);
  if (v8 >= 1)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 1;
    do
    {
      _MPEntry::writeToStream(*(_MPEntry **)(*((void *)this + 3) + 8 * v4), stream);
      uint64_t v4 = v5;
    }
    while (v8 > v5++);
  }
  CFWriteStreamWrite(stream, (const UInt8 *)this + 8, 16);
  return 0;
}

void std::vector<_MPEntry *>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    int v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v3, a2);
    CFAllocatorRef v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    CFDataRef v9 = &v6[8 * v8];
    CFErrorRef v11 = (char *)*a1;
    int v10 = (char *)a1[1];
    int v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *((void *)v10 - 1);
        v10 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      int v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t GlobalMPOInfo::getEntryAtIndex(GlobalMPOInfo *this, unsigned int a2)
{
  return *(void *)(*((void *)this + 3) + 8 * a2);
}

void GlobalMPOInfo::addEntry(GlobalMPOInfo *this, _MPEntry *a2)
{
  unint64_t v6 = *((void *)this + 5);
  uint64_t v4 = (char *)this + 40;
  unint64_t v5 = v6;
  CFAllocatorRef v7 = (void *)*((void *)v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    CFDataRef v9 = (void **)(v4 - 16);
    uint64_t v10 = *((void *)v4 - 2);
    uint64_t v11 = ((uint64_t)v7 - v10) >> 3;
    if ((unint64_t)(v11 + 1) >> 61) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - v10;
    uint64_t v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1)) {
      uint64_t v13 = v11 + 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v13;
    }
    if (v14) {
      uint64_t v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v4, v14);
    }
    else {
      uint64_t v15 = 0;
    }
    size_t v16 = &v15[8 * v11];
    int v17 = &v15[8 * v14];
    *(void *)size_t v16 = a2;
    uint64_t v8 = v16 + 8;
    uint64_t v19 = (char *)*((void *)this + 3);
    unsigned int v18 = (char *)*((void *)this + 4);
    if (v18 != v19)
    {
      do
      {
        uint64_t v20 = *((void *)v18 - 1);
        v18 -= 8;
        *((void *)v16 - 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      unsigned int v18 = (char *)*v9;
    }
    *((void *)this + 3) = v16;
    *((void *)this + 4) = v8;
    *((void *)this + 5) = v17;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *CFAllocatorRef v7 = a2;
    uint64_t v8 = v7 + 1;
  }
  *((void *)this + 4) = v8;
}

uint64_t GlobalMPOInfo::getMetadata(GlobalMPOInfo *this)
{
  return *((void *)this + 6);
}

uint64_t GlobalMPOInfo::getEntryCount(GlobalMPOInfo *this)
{
  return *((unsigned __int16 *)this + 8);
}

IIOImageRead *ExamineMPOFile(IIOImageReadSession *a1)
{
  CFStringRef Size = IIOImageReadSession::getSize(a1);
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  IIOScanner::IIOScanner((IIOScanner *)v5, a1);
  uint64_t v3 = 0;
  if ((unint64_t)Size >= 0xC8)
  {
    uint64_t v3 = IIOImageReadSession::globalInfoForType(a1, 1297108768);
    if (!v3) {
      operator new();
    }
    if (*((void *)&v5[0] + 1)) {
      operator new();
    }
  }
  IIOScanner::~IIOScanner((IIOScanner *)v5);
  return v3;
}

void sub_1887BDC84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  MEMORY[0x18C11C0E0](v9, 0x10A1C4078B77C84);
  IIOScanner::~IIOScanner((IIOScanner *)&a9);
  _Unwind_Resume(a1);
}

uint64_t _MPExtension::mpoBaseOffset(_MPExtension *this)
{
  return *((unsigned int *)this + 16);
}

uint64_t icnsCompare(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2 = a1[48];
  unsigned int v3 = a2[48];
  if (v2 > v3) {
    return 1;
  }
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v5 = *((unsigned __int16 *)a1 + 12);
  unsigned int v6 = *((unsigned __int16 *)a2 + 12);
  if (v5 > v6) {
    return 0xFFFFFFFFLL;
  }
  if (v5 < v6) {
    return 1;
  }
  unsigned int v7 = a1[49];
  unsigned int v8 = a2[49];
  BOOL v9 = v7 >= v8;
  BOOL v10 = v7 == v8;
  BOOL v11 = v7 < v8;
  if (!v10 && v9) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v11;
  }
}

void *GetICNSInfoTable(void)
{
  if (GetICNSInfoTable(void)::gIIO_sortIconInfo != -1) {
    dispatch_once(&GetICNSInfoTable(void)::gIIO_sortIconInfo, &__block_literal_global_37);
  }
  return &globalIconInfo;
}

void ___Z16GetICNSInfoTablev_block_invoke()
{
}

void GlobalICNSInfo::GlobalICNSInfo(GlobalICNSInfo *this)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  uint64_t v1 = (char *)this + 24;
  *(_OWORD *)this = 0u;
  std::vector<ICNS_INFO>::resize((uint64_t)this, 0);
  std::vector<ICNS_INFO>::resize((uint64_t)v1, 0);
}

void sub_1887BDDF4(_Unwind_Exception *a1)
{
  uint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }
  GlobalICNSInfo::GlobalICNSInfo((void **)v1);
  _Unwind_Resume(a1);
}

void std::vector<ICNS_INFO>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<ICNS_INFO>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(void *)(a1 + 8) = *(void *)a1 + 56 * a2;
  }
}

void GlobalICNSInfo::GlobalICNSInfo(GlobalICNSInfo *this, unsigned __int8 *a2, CFIndex a3)
{
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  unsigned int v6 = (char *)this + 24;
  *(_OWORD *)this = 0u;
  std::vector<ICNS_INFO>::resize((uint64_t)this, 0);
  std::vector<ICNS_INFO>::resize((uint64_t)v6, 0);
  unsigned int v7 = CFReadStreamCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  unsigned int v8 = v7;
  if (v7)
  {
    if (CFReadStreamOpen(v7))
    {
      if (GlobalICNSInfo::readFromStream(this, v8))
      {
        *((void *)this + 1) = *(void *)this;
        *((void *)this + 4) = *((void *)this + 3);
      }
      CFReadStreamClose(v8);
    }
    CFRelease(v8);
  }
}

void sub_1887BDF20(_Unwind_Exception *exception_object)
{
  unint64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 32) = v4;
    operator delete(v4);
  }
  unsigned int v5 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t GlobalICNSInfo::readFromStream(GlobalICNSInfo *this, CFReadStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) != 4) {
    return 4294967246;
  }
  if (*(_DWORD *)buffer != 1397637961) {
    return 0;
  }
  *((void *)this + 1) = *(void *)this;
  unint64_t v4 = (char **)((char *)this + 24);
  *((void *)this + 4) = *((void *)this + 3);
  *(_DWORD *)CFNumberRef v54 = 0;
  if (CFReadStreamRead(stream, v54, 4) != 4) {
    return 4294967246;
  }
  if (*(_DWORD *)v54)
  {
    int v5 = 0;
    do
    {
      uint64_t v53 = 0;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v50 = 0u;
      if (CFReadStreamRead(stream, (UInt8 *)&v50, 56) != 56) {
        return 4294967246;
      }
      unint64_t v6 = *((void *)this + 1);
      unint64_t v7 = *((void *)this + 2);
      if (v6 >= v7)
      {
        uint64_t v11 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v6 - *(void *)this) >> 3);
        unint64_t v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) > 0x492492492492492) {
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v13 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v7 - *(void *)this) >> 3);
        if (2 * v13 > v12) {
          unint64_t v12 = 2 * v13;
        }
        if (v13 >= 0x249249249249249) {
          unint64_t v14 = 0x492492492492492;
        }
        else {
          unint64_t v14 = v12;
        }
        if (v14) {
          uint64_t v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<ICNS_INFO>>((uint64_t)this + 16, v14);
        }
        else {
          uint64_t v15 = 0;
        }
        size_t v16 = &v15[56 * v11];
        long long v17 = v50;
        long long v18 = v51;
        long long v19 = v52;
        *((void *)v16 + 6) = v53;
        *((_OWORD *)v16 + 1) = v18;
        *((_OWORD *)v16 + 2) = v19;
        *(_OWORD *)size_t v16 = v17;
        long long v21 = *(char **)this;
        uint64_t v20 = (char *)*((void *)this + 1);
        uint64_t v22 = v16;
        if (v20 != *(char **)this)
        {
          do
          {
            long long v23 = *(_OWORD *)(v20 - 56);
            long long v24 = *(_OWORD *)(v20 - 40);
            long long v25 = *(_OWORD *)(v20 - 24);
            *((void *)v22 - 1) = *((void *)v20 - 1);
            *(_OWORD *)(v22 - 24) = v25;
            *(_OWORD *)(v22 - 40) = v24;
            *(_OWORD *)(v22 - 56) = v23;
            v22 -= 56;
            v20 -= 56;
          }
          while (v20 != v21);
          uint64_t v20 = *(char **)this;
        }
        size_t v26 = v16 + 56;
        *(void *)this = v22;
        *((void *)this + 1) = v16 + 56;
        *((void *)this + 2) = &v15[56 * v14];
        if (v20) {
          operator delete(v20);
        }
        *((void *)this + 1) = v26;
      }
      else
      {
        long long v8 = v50;
        long long v9 = v51;
        long long v10 = v52;
        *(void *)(v6 + 48) = v53;
        *(_OWORD *)(v6 + 16) = v9;
        *(_OWORD *)(v6 + 32) = v10;
        *(_OWORD *)unint64_t v6 = v8;
        *((void *)this + 1) = v6 + 56;
      }
    }
    while (++v5 < *(_DWORD *)v54);
  }
  if (CFReadStreamRead(stream, v54, 4) != 4) {
    return 4294967246;
  }
  if (*(_DWORD *)v54)
  {
    int v27 = 0;
    while (1)
    {
      uint64_t v53 = 0;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v50 = 0u;
      if (CFReadStreamRead(stream, (UInt8 *)&v50, 56) != 56) {
        break;
      }
      unint64_t v28 = *((void *)this + 4);
      unint64_t v29 = *((void *)this + 5);
      if (v28 >= v29)
      {
        uint64_t v33 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v28 - (void)*v4) >> 3);
        unint64_t v34 = v33 + 1;
        if ((unint64_t)(v33 + 1) > 0x492492492492492) {
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v35 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v29 - (void)*v4) >> 3);
        if (2 * v35 > v34) {
          unint64_t v34 = 2 * v35;
        }
        if (v35 >= 0x249249249249249) {
          unint64_t v36 = 0x492492492492492;
        }
        else {
          unint64_t v36 = v34;
        }
        if (v36) {
          uint64_t v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<ICNS_INFO>>((uint64_t)this + 40, v36);
        }
        else {
          uint64_t v37 = 0;
        }
        vImage_CGImageFormat v38 = &v37[56 * v33];
        long long v39 = v50;
        long long v40 = v51;
        long long v41 = v52;
        *((void *)v38 + 6) = v53;
        *((_OWORD *)v38 + 1) = v40;
        *((_OWORD *)v38 + 2) = v41;
        *(_OWORD *)vImage_CGImageFormat v38 = v39;
        uint64_t v43 = (char *)*((void *)this + 3);
        __int16 v42 = (char *)*((void *)this + 4);
        uint64_t v44 = v38;
        if (v42 != v43)
        {
          do
          {
            long long v45 = *(_OWORD *)(v42 - 56);
            long long v46 = *(_OWORD *)(v42 - 40);
            long long v47 = *(_OWORD *)(v42 - 24);
            *((void *)v44 - 1) = *((void *)v42 - 1);
            *(_OWORD *)(v44 - 24) = v47;
            *(_OWORD *)(v44 - 40) = v46;
            *(_OWORD *)(v44 - 56) = v45;
            v44 -= 56;
            v42 -= 56;
          }
          while (v42 != v43);
          __int16 v42 = *v4;
        }
        CFNumberRef v48 = v38 + 56;
        *((void *)this + 3) = v44;
        *((void *)this + 4) = v38 + 56;
        *((void *)this + 5) = &v37[56 * v36];
        if (v42) {
          operator delete(v42);
        }
        *((void *)this + 4) = v48;
      }
      else
      {
        long long v30 = v50;
        long long v31 = v51;
        long long v32 = v52;
        *(void *)(v28 + 48) = v53;
        *(_OWORD *)(v28 + 16) = v31;
        *(_OWORD *)(v28 + 32) = v32;
        *(_OWORD *)unint64_t v28 = v30;
        *((void *)this + 4) = v28 + 56;
      }
      if (++v27 >= *(_DWORD *)v54) {
        return 0;
      }
    }
    return 4294967246;
  }
  return 0;
}

void GlobalICNSInfo::~GlobalICNSInfo(GlobalICNSInfo *this)
{
  std::vector<ICNS_INFO>::resize((uint64_t)this, 0);
  std::vector<ICNS_INFO>::resize((uint64_t)this + 24, 0);
  unint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    *((void *)this + 4) = v2;
    operator delete(v2);
  }
  BOOL v3 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v3;
    operator delete(v3);
  }
}

CFTypeRef GlobalICNSInfo::createDataRepresentation(GlobalICNSInfo *this)
{
  unint64_t v2 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  if (!v2) {
    return 0;
  }
  BOOL v3 = v2;
  if (CFWriteStreamOpen(v2))
  {
    GlobalICNSInfo::writeToStream(this, v3);
    CFTypeRef v4 = CFWriteStreamCopyProperty(v3, (CFStreamPropertyKey)*MEMORY[0x1E4F1D440]);
    CFWriteStreamClose(v3);
  }
  else
  {
    CFTypeRef v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

uint64_t GlobalICNSInfo::writeToStream(GlobalICNSInfo *this, CFWriteStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 1397637961;
  CFWriteStreamWrite(stream, buffer, 4);
  *(_DWORD *)unint64_t v6 = -1227133513 * ((*((void *)this + 1) - *(void *)this) >> 3);
  CFWriteStreamWrite(stream, v6, 4);
  CFWriteStreamWrite(stream, *(const UInt8 **)this, 56 * *(unsigned int *)v6);
  *(_DWORD *)unint64_t v6 = -1227133513 * ((*((void *)this + 4) - *((void *)this + 3)) >> 3);
  CFWriteStreamWrite(stream, v6, 4);
  CFWriteStreamWrite(stream, *((const UInt8 **)this + 3), 56 * *(unsigned int *)v6);
  return 0;
}

uint64_t GlobalICNSInfo::icnsImageCount(GlobalICNSInfo *this)
{
  return -1227133513 * ((*((void *)this + 1) - *(void *)this) >> 3);
}

BOOL GlobalICNSInfo::getICNSImageInfoAtIndex(void *a1, unsigned int a2, uint64_t a3)
{
  unint64_t v3 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a1[1] - *a1) >> 3);
  if (v3 > a2)
  {
    uint64_t v4 = *a1 + 56 * a2;
    long long v5 = *(_OWORD *)v4;
    long long v6 = *(_OWORD *)(v4 + 16);
    long long v7 = *(_OWORD *)(v4 + 32);
    *(void *)(a3 + 48) = *(void *)(v4 + 48);
    *(_OWORD *)(a3 + 16) = v6;
    *(_OWORD *)(a3 + 32) = v7;
    *(_OWORD *)a3 = v5;
  }
  return v3 > a2;
}

uint64_t GlobalICNSInfo::getICNSMaskInfoForType(uint64_t a1, int a2, uint64_t a3)
{
  if (!a2) {
    return 0;
  }
  for (uint64_t i = *(void *)(a1 + 24); ; i += 56)
  {
    if (i == *(void *)(a1 + 32)) {
      return 0;
    }
    long long v6 = *(_OWORD *)(i + 36);
    int v7 = *(_DWORD *)(i + 52);
    if (*(_DWORD *)(i + 32) == a2) {
      break;
    }
  }
  long long v5 = *(_OWORD *)(i + 16);
  *(_OWORD *)a3 = *(_OWORD *)i;
  *(_OWORD *)(a3 + 16) = v5;
  *(_DWORD *)(a3 + 32) = a2;
  *(_OWORD *)(a3 + 36) = v6;
  *(_DWORD *)(a3 + 52) = v7;
  return 1;
}

__n128 GlobalICNSInfo::addICNSInfo(void **a1, __int16 *a2)
{
  if (*a2 == -2)
  {
    uint64_t v4 = (uint64_t)(a1 + 5);
    long long v5 = (char *)a1[5];
    long long v6 = (char *)a1[4];
    if (v6 >= v5)
    {
      uint64_t v20 = a1[3];
      uint64_t v21 = 0x6DB6DB6DB6DB6DB7 * ((v6 - v20) >> 3);
      unint64_t v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) > 0x492492492492492) {
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v23 = 0x6DB6DB6DB6DB6DB7 * ((v5 - v20) >> 3);
      if (2 * v23 > v22) {
        unint64_t v22 = 2 * v23;
      }
      if (v23 >= 0x249249249249249) {
        unint64_t v24 = 0x492492492492492;
      }
      else {
        unint64_t v24 = v22;
      }
      if (v24) {
        long long v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<ICNS_INFO>>(v4, v24);
      }
      else {
        long long v25 = 0;
      }
      unint64_t v34 = &v25[56 * v21];
      unint64_t v35 = &v25[56 * v24];
      __n128 result = *(__n128 *)a2;
      long long v36 = *((_OWORD *)a2 + 1);
      long long v37 = *((_OWORD *)a2 + 2);
      *((void *)v34 + 6) = *((void *)a2 + 6);
      *((_OWORD *)v34 + 1) = v36;
      *((_OWORD *)v34 + 2) = v37;
      *(__n128 *)unint64_t v34 = result;
      long long v10 = v34 + 56;
      long long v39 = (char *)a1[3];
      vImage_CGImageFormat v38 = (char *)a1[4];
      if (v38 != v39)
      {
        do
        {
          __n128 result = *(__n128 *)(v38 - 56);
          long long v40 = *(_OWORD *)(v38 - 40);
          long long v41 = *(_OWORD *)(v38 - 24);
          *((void *)v34 - 1) = *((void *)v38 - 1);
          *(_OWORD *)(v34 - 24) = v41;
          *(_OWORD *)(v34 - 40) = v40;
          *(__n128 *)(v34 - 56) = result;
          v34 -= 56;
          v38 -= 56;
        }
        while (v38 != v39);
        vImage_CGImageFormat v38 = (char *)a1[3];
      }
      a1[3] = v34;
      a1[4] = v10;
      a1[5] = v35;
      if (v38) {
        operator delete(v38);
      }
    }
    else
    {
      __n128 result = *(__n128 *)a2;
      long long v8 = *((_OWORD *)a2 + 1);
      long long v9 = *((_OWORD *)a2 + 2);
      *((void *)v6 + 6) = *((void *)a2 + 6);
      *((_OWORD *)v6 + 1) = v8;
      *((_OWORD *)v6 + 2) = v9;
      *(__n128 *)long long v6 = result;
      long long v10 = v6 + 56;
    }
    a1[4] = v10;
  }
  else
  {
    unint64_t v12 = (char *)*a1;
    uint64_t v11 = (char *)a1[1];
    if (*a1 == v11)
    {
LABEL_8:
      uint64_t v15 = (uint64_t)(a1 + 2);
      size_t v16 = (char *)a1[2];
      if (v11 >= v16)
      {
        uint64_t v26 = 0x6DB6DB6DB6DB6DB7 * ((v11 - v12) >> 3);
        unint64_t v27 = v26 + 1;
        if ((unint64_t)(v26 + 1) > 0x492492492492492) {
          std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v28 = 0x6DB6DB6DB6DB6DB7 * ((v16 - v12) >> 3);
        if (2 * v28 > v27) {
          unint64_t v27 = 2 * v28;
        }
        if (v28 >= 0x249249249249249) {
          unint64_t v29 = 0x492492492492492;
        }
        else {
          unint64_t v29 = v27;
        }
        if (v29) {
          long long v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<ICNS_INFO>>(v15, v29);
        }
        else {
          long long v30 = 0;
        }
        __int16 v42 = &v30[56 * v26];
        uint64_t v43 = &v30[56 * v29];
        __n128 result = *(__n128 *)a2;
        long long v44 = *((_OWORD *)a2 + 1);
        long long v45 = *((_OWORD *)a2 + 2);
        *((void *)v42 + 6) = *((void *)a2 + 6);
        *((_OWORD *)v42 + 1) = v44;
        *((_OWORD *)v42 + 2) = v45;
        *(__n128 *)__int16 v42 = result;
        long long v19 = v42 + 56;
        long long v47 = (char *)*a1;
        long long v46 = (char *)a1[1];
        if (v46 != *a1)
        {
          do
          {
            __n128 result = *(__n128 *)(v46 - 56);
            long long v48 = *(_OWORD *)(v46 - 40);
            long long v49 = *(_OWORD *)(v46 - 24);
            *((void *)v42 - 1) = *((void *)v46 - 1);
            *(_OWORD *)(v42 - 24) = v49;
            *(_OWORD *)(v42 - 40) = v48;
            *(__n128 *)(v42 - 56) = result;
            v42 -= 56;
            v46 -= 56;
          }
          while (v46 != v47);
          long long v46 = (char *)*a1;
        }
        *a1 = v42;
        a1[1] = v19;
        a1[2] = v43;
        if (v46) {
          operator delete(v46);
        }
      }
      else
      {
        __n128 result = *(__n128 *)a2;
        long long v17 = *((_OWORD *)a2 + 1);
        long long v18 = *((_OWORD *)a2 + 2);
        *((void *)v11 + 6) = *((void *)a2 + 6);
        *((_OWORD *)v11 + 1) = v17;
        *((_OWORD *)v11 + 2) = v18;
        *(__n128 *)uint64_t v11 = result;
        long long v19 = v11 + 56;
      }
      a1[1] = v19;
    }
    else
    {
      int v13 = *((_DWORD *)a2 + 8);
      unint64_t v14 = (char *)*a1;
      while (*((_DWORD *)v14 + 8) != v13)
      {
        v14 += 56;
        if (v14 == v11) {
          goto LABEL_8;
        }
      }
      unsigned int v31 = v13 >> 24;
      uint64_t v32 = MEMORY[0x1E4F14390];
      if (v13 < 0)
      {
        int v33 = __maskrune(v31, 0x40000uLL);
        int v13 = *((_DWORD *)a2 + 8);
        unsigned int v31 = v13 >> 24;
      }
      else
      {
        int v33 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v31 + 60) & 0x40000;
      }
      if (v33) {
        uint64_t v50 = v31;
      }
      else {
        uint64_t v50 = 46;
      }
      unsigned int v51 = v13 << 8 >> 24;
      if (v13 << 8 < 0)
      {
        int v52 = __maskrune(v51, 0x40000uLL);
        int v13 = *((_DWORD *)a2 + 8);
        unsigned int v51 = v13 << 8 >> 24;
      }
      else
      {
        int v52 = *(_DWORD *)(v32 + 4 * v51 + 60) & 0x40000;
      }
      if (v52) {
        uint64_t v53 = v51;
      }
      else {
        uint64_t v53 = 46;
      }
      unsigned int v54 = (__int16)v13 >> 8;
      if (v13 << 16 < 0)
      {
        int v55 = __maskrune(v54, 0x40000uLL);
        int v13 = *((_DWORD *)a2 + 8);
        unsigned int v54 = (__int16)v13 >> 8;
      }
      else
      {
        int v55 = *(_DWORD *)(v32 + 4 * v54 + 60) & 0x40000;
      }
      if (v55) {
        uint64_t v56 = v54;
      }
      else {
        uint64_t v56 = 46;
      }
      unsigned int v57 = (char)v13;
      if ((v13 << 24) <= 0x7F000000)
      {
        int v58 = *(_DWORD *)(v32 + 4 * (char)v13 + 60) & 0x40000;
      }
      else
      {
        int v58 = __maskrune((char)v13, 0x40000uLL);
        unsigned int v57 = *((char *)a2 + 32);
      }
      if (v58) {
        uint64_t v59 = v57;
      }
      else {
        uint64_t v59 = 46;
      }
      return _cg_jpeg_mem_term("addICNSInfo", 356, "*** ERROR: duplicate icnsOSType? '%c%c%c%c' already exists\n", v50, v53, v56, v59);
    }
  }
  return result;
}

void GlobalICNSInfo::sortInfo(void **this)
{
}

void std::vector<ICNS_INFO>::__append(void **a1, unint64_t a2)
{
  long long v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  long long v5 = v6;
  int v7 = *(char **)(v4 - 8);
  if (0x6DB6DB6DB6DB6DB7 * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 56 * ((56 * a2 - 56) / 0x38) + 56;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((v7 - (unsigned char *)*a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x492492492492492) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x6DB6DB6DB6DB6DB7 * ((v5 - (unsigned char *)*a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x249249249249249) {
      unint64_t v11 = 0x492492492492492;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11) {
      unint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<ICNS_INFO>>(v4, v11);
    }
    else {
      unint64_t v12 = 0;
    }
    unint64_t v14 = &v12[56 * v8];
    uint64_t v15 = &v12[56 * v11];
    size_t v16 = 56 * ((56 * a2 - 56) / 0x38) + 56;
    bzero(v14, v16);
    long long v17 = &v14[v16];
    long long v19 = (char *)*a1;
    long long v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        long long v20 = *(_OWORD *)(v18 - 56);
        long long v21 = *(_OWORD *)(v18 - 40);
        long long v22 = *(_OWORD *)(v18 - 24);
        *((void *)v14 - 1) = *((void *)v18 - 1);
        *(_OWORD *)(v14 - 24) = v22;
        *(_OWORD *)(v14 - 40) = v21;
        *(_OWORD *)(v14 - 56) = v20;
        v14 -= 56;
        v18 -= 56;
      }
      while (v18 != v19);
      long long v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
    {
      operator delete(v18);
    }
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<ICNS_INFO>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(56 * a2);
}

void OUTLINED_FUNCTION_0(void *__p@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 8) = __p;
  operator delete(__p);
}

uint64_t PBMReadPlugin::PBMReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v6 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(void *)uint64_t v6 = &unk_1ED4E0568;
  *(_OWORD *)(v6 + 440) = 0u;
  *(_OWORD *)(v6 + 456) = 0u;
  *(void *)(v6 + 472) = 0;
  *(void *)(a1 + 480) = GetPBMLookupTable();
  return a1;
}

void sub_1887BEC78(_Unwind_Exception *a1)
{
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

void PBMReadPlugin::PBMReadPlugin(uint64_t a1, uint64_t a2)
{
}

void sub_1887BECEC(_Unwind_Exception *a1)
{
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

void PBMReadPlugin::~PBMReadPlugin(PBMReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t PBMReadPlugin::readChar(PBMReadPlugin *this)
{
  uint64_t v1 = *((void *)this + 61);
  if (v1)
  {
    uint64_t v2 = *((void *)this + 59);
    unint64_t v3 = v2 + 1;
    if (v2 != -1)
    {
      unint64_t v4 = *((void *)this + 62);
      if (v4 >= v3)
      {
        uint64_t v5 = *(unsigned __int8 *)(v1 + v2);
        *((void *)this + 59) = v3;
        uint64_t v7 = *((void *)this + 60);
        if (*(unsigned __int8 *)(v7 + v5) != 254) {
          return v5;
        }
        while (v3 < v4)
        {
          uint64_t v5 = *(unsigned __int8 *)(v1 + v3++);
          *((void *)this + 59) = v3;
          if (*(unsigned __int8 *)(v7 + v5) == 252) {
            return v5;
          }
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t PBMReadPlugin::readInt(PBMReadPlugin *this)
{
  do
    uint64_t v2 = *(unsigned __int8 *)(*((void *)this + 60) + PBMReadPlugin::readChar(this));
  while ((v2 & 0x80) != 0);
  int v3 = *(unsigned __int8 *)(*((void *)this + 60) + PBMReadPlugin::readChar(this));
  if (v3 == 255) {
    return 0xFFFFFFFFLL;
  }
  while ((v3 & 0x80) == 0)
  {
    if ((int)v2 <= 214748364 && 10 * (int)v2 <= (v3 ^ 0x7FFFFFFF))
    {
      uint64_t v2 = (10 * v2 + v3);
      int v3 = *(unsigned __int8 *)(*((void *)this + 60) + PBMReadPlugin::readChar(this));
      if (v3 != 255) {
        continue;
      }
    }
    return 0xFFFFFFFFLL;
  }
  return v2;
}

uint64_t PBMReadPlugin::readFloat(PBMReadPlugin *this)
{
  do
    unsigned __int8 Char = PBMReadPlugin::readChar(this);
  while ((*(unsigned char *)(*((void *)this + 60) + Char) & 0x80) != 0);
  uint64_t v3 = 0;
  if (Char == 45) {
    int v4 = 0;
  }
  else {
    int v4 = *(unsigned __int8 *)(*((void *)this + 60) + Char);
  }
  float v5 = 1.0;
  while (1)
  {
    for (uint64_t i = v3; ; uint64_t i = 1)
    {
      uint64_t v3 = i;
      uint64_t result = PBMReadPlugin::readChar(this);
      if (result != 46) {
        break;
      }
      if (v3) {
        return result;
      }
    }
    if (*(char *)(*((void *)this + 60) + result) < 0) {
      break;
    }
    if (v4 > 214748364) {
      break;
    }
    int v8 = *(unsigned __int8 *)(*((void *)this + 60) + result);
    if (10 * v4 > (v8 ^ 0x7FFFFFFF)) {
      break;
    }
    int v4 = 10 * v4 + v8;
    if (v3) {
      float v5 = v5 * 10.0;
    }
  }
  return result;
}

uint64_t PBMReadPlugin::readWidthAndHeight(PBMReadPlugin *this, unsigned int *a2, unsigned int *a3)
{
  int Int = PBMReadPlugin::readInt(this);
  if (Int < 1 || *((void *)this + 23) <= (unint64_t)Int) {
    return 0;
  }
  if (a2) {
    *a2 = Int;
  }
  int v7 = PBMReadPlugin::readInt(this);
  if (v7 < 1 || *((void *)this + 23) <= (unint64_t)v7) {
    return 0;
  }
  if (a3) {
    *a3 = v7;
  }
  return 1;
}

uint64_t PBMReadPlugin::readHeader(PBMReadPlugin *this)
{
  *(void *)long long v46 = 0;
  uint64_t result = *((void *)this + 61);
  if (!result) {
    return result;
  }
  unint64_t v3 = *((void *)this + 59);
  if (v3 > 0xFFFFFFFFFFFFFFFDLL) {
    return 0;
  }
  unint64_t v4 = v3 + 2;
  size_t v5 = *((void *)this + 62);
  if (v5 < v3 + 2) {
    return 0;
  }
  int v6 = *(unsigned __int8 *)(result + v3);
  int v7 = *(unsigned __int8 *)(result + v3 + 1);
  *((void *)this + 59) = v4;
  if (v6 == 42 && v7 == 23)
  {
    size_t v11 = v3 + 6;
    if (v4 > 0xFFFFFFFFFFFFFFFBLL || v5 < v11) {
      return 0;
    }
    size_t v13 = (unsigned __int16 *)(result + v4);
    int v14 = *(unsigned __int8 *)(result + v4 + 2);
    int v15 = *((unsigned __int8 *)v13 + 3);
    LODWORD(v13) = *v13;
    *((void *)this + 59) = v11;
    unint64_t v16 = __rev16(v13);
    v46[1] = v16;
    unint64_t v17 = *((void *)this + 23);
    if (v17 <= v16) {
      return 0;
    }
    unint64_t v18 = v15 | (v14 << 8);
    v46[0] = v18;
    if (v17 <= v18) {
      return 0;
    }
    uint64_t result = 10;
LABEL_22:
    int v9 = 1;
LABEL_23:
    float v10 = 0.0;
LABEL_24:
    unsigned int v19 = v46[0];
    *((_DWORD *)this + 57) = v46[1];
    *((_DWORD *)this + 58) = v19;
    *((void *)this + 56) = v9;
    *((float *)this + 114) = fabsf(v10);
    if (v9)
    {
      if (v9 <= 255)
      {
        *((_WORD *)this + 120) = 8;
LABEL_38:
        unsigned int v21 = *((unsigned __int16 *)this + 122);
        if (v21 >= 3)
        {
          if (v21 == 3) {
            char v22 = 5;
          }
          else {
            char v22 = 3;
          }
          *((unsigned char *)this + 278) = v22;
          *(_DWORD *)((char *)this + 274) = 262176;
          *((unsigned char *)this + 279) = 0;
        }
        return result;
      }
      if (HIWORD(v9))
      {
        uint64_t result = 0;
        if (*((_WORD *)this + 120) != 8) {
          return result;
        }
        goto LABEL_38;
      }
      __int16 v20 = 16;
    }
    else
    {
      if (v10 == 0.0) {
        return result;
      }
      *((unsigned char *)this + 344) = v10 < 0.0;
      __int16 v20 = 32;
    }
    *((_WORD *)this + 120) = v20;
    return result;
  }
  if (v6 != 80) {
    return 0;
  }
  switch(v7)
  {
    case '1':
      if ((PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46) & 1) == 0) {
        return 0;
      }
      int v9 = 1;
      float v10 = 0.0;
      uint64_t result = 1;
      goto LABEL_24;
    case '2':
      uint64_t result = PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46);
      if (!result) {
        return result;
      }
      int Int = PBMReadPlugin::readInt(this);
      if ((Int - 0x10000) < 0xFFFF0001) {
        return 0;
      }
      int v9 = Int;
      uint64_t result = 2;
      goto LABEL_23;
    case '3':
      uint64_t result = PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46);
      if (!result) {
        return result;
      }
      int v24 = PBMReadPlugin::readInt(this);
      if ((v24 - 0x10000) < 0xFFFF0001) {
        return 0;
      }
      int v9 = v24;
      uint64_t result = 3;
      goto LABEL_23;
    case '4':
      if ((PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46) & 1) == 0) {
        return 0;
      }
      uint64_t result = 4;
      goto LABEL_22;
    case '5':
      uint64_t result = PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46);
      if (!result) {
        return result;
      }
      int v25 = PBMReadPlugin::readInt(this);
      if ((v25 - 0x10000) < 0xFFFF0001) {
        return 0;
      }
      int v9 = v25;
      uint64_t result = 5;
      goto LABEL_23;
    case '6':
      uint64_t result = PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46);
      if (!result) {
        return result;
      }
      int v26 = PBMReadPlugin::readInt(this);
      if ((v26 - 0x10000) < 0xFFFF0001) {
        return 0;
      }
      int v9 = v26;
      uint64_t result = 6;
      goto LABEL_23;
    case '7':
      uint64_t result = (uint64_t)strnstr((const char *)result, "ENDHDR", v5);
      if (!result) {
        return result;
      }
      size_t v27 = result - *((void *)this + 61);
      unint64_t v28 = strnstr(*((const char **)this + 61), "WIDTH", v27);
      if (v28) {
        *((void *)this + 59) = &v28[-*((void *)this + 61)];
      }
      int v29 = PBMReadPlugin::readInt(this);
      if (v29 < 1) {
        return 7;
      }
      v46[1] = v29;
      if (*((void *)this + 23) <= (unint64_t)v29) {
        return 7;
      }
      long long v30 = strnstr(*((const char **)this + 61), "HEIGHT", v27);
      if (v30) {
        *((void *)this + 59) = &v30[-*((void *)this + 61)];
      }
      int v31 = PBMReadPlugin::readInt(this);
      if (v31 < 1) {
        return 7;
      }
      v46[0] = v31;
      if (*((void *)this + 23) <= (unint64_t)v31) {
        return 7;
      }
      uint64_t v32 = strnstr(*((const char **)this + 61), "DEPTH", v27);
      if (v32) {
        *((void *)this + 59) = &v32[-*((void *)this + 61)];
      }
      unsigned __int16 v33 = PBMReadPlugin::readInt(this);
      *((_WORD *)this + 122) = v33;
      if (v33 > 4u) {
        return 7;
      }
      unint64_t v34 = strnstr(*((const char **)this + 61), "MAXVAL", v27);
      if (v34) {
        *((void *)this + 59) = &v34[-*((void *)this + 61)];
      }
      int v35 = PBMReadPlugin::readInt(this);
      if ((v35 - 0x10000) < 0xFFFF0001) {
        return 7;
      }
      int v9 = v35;
      long long v36 = strnstr(*((const char **)this + 61), "TUPLTYPE", v27);
      long long v37 = (const char *)*((void *)this + 61);
      if (v36) {
        *((void *)this + 59) = v36 - v37;
      }
      if (strnstr(v37, "RGB_ALPHA", v27))
      {
        if (*((_WORD *)this + 122) == 4)
        {
          *((unsigned char *)this + 246) = 3;
          *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
          *((_WORD *)this + 138) = *((_WORD *)this + 122);
LABEL_77:
          int v38 = 1380401696;
LABEL_78:
          *((_DWORD *)this + 81) = v38;
LABEL_79:
          size_t v39 = v27 + 6;
          *((void *)this + 59) = v27 + 6;
          uint64_t v40 = *((void *)this + 61);
          if (v40)
          {
            if (v27 != -7)
            {
              size_t v41 = v27 + 7;
              if (*((void *)this + 62) >= v27 + 7)
              {
                uint64_t v42 = *(unsigned __int8 *)(v40 + v39);
                *((void *)this + 59) = v41;
                uint64_t v43 = *((void *)this + 60);
                if ((*(unsigned char *)(v43 + v42) & 0xFE) == 0xFC)
                {
                  while (1)
                  {
                    size_t v39 = v41 + 1;
                    if (v41 == -1 || *((void *)this + 62) < v39) {
                      break;
                    }
                    uint64_t v44 = *(unsigned __int8 *)(v40 + v41);
                    *((void *)this + 59) = v39;
                    int v45 = *(unsigned char *)(v43 + v44) & 0xFE;
                    size_t v41 = v39;
                    if (v45 != 252) {
                      goto LABEL_95;
                    }
                  }
                }
                size_t v39 = v41;
              }
            }
          }
LABEL_95:
          *((void *)this + 59) = v39 - 1;
          uint64_t result = 7;
          goto LABEL_23;
        }
        _cg_jpeg_mem_term("readHeader", 398, "*** ERROR bad 'RGB_ALPHA':  expected %d channels got: %d channels\n");
        return 7;
      }
      if (strnstr(*((const char **)this + 61), "RGB", v27))
      {
        if (*((_WORD *)this + 122) == 3)
        {
          *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
          *((unsigned char *)this + 246) = 0;
          *((_WORD *)this + 122) = 3;
          if (*((_WORD *)this + 120) != 8) {
            goto LABEL_79;
          }
          *((_DWORD *)this + 69) = 327684;
          goto LABEL_77;
        }
        _cg_jpeg_mem_term("readHeader", 406, "*** ERROR bad 'RGB':  expected %d channels got: %d channels\n");
        return 7;
      }
      if (strnstr(*((const char **)this + 61), "GRAYSCALE_ALPHA", v27))
      {
        if (*((_WORD *)this + 122) != 2)
        {
          _cg_jpeg_mem_term("readHeader", 422, "*** ERROR bad 'GRAYSCALE_ALPHA':  expected %d channels got: %d channels\n");
          return 7;
        }
LABEL_98:
        *((unsigned char *)this + 246) = 3;
LABEL_102:
        *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
        int v38 = 1196573017;
        goto LABEL_78;
      }
      if (strnstr(*((const char **)this + 61), "GRAYSCALE", v27))
      {
        if (*((_WORD *)this + 122) != 1)
        {
          _cg_jpeg_mem_term("readHeader", 429, "*** ERROR bad 'GRAYSCALE':  expected %d channels got: %d channels\n");
          return 7;
        }
      }
      else
      {
        if (!strnstr(*((const char **)this + 61), "BLACKANDWHITE", v27))
        {
          if (!strnstr(*((const char **)this + 61), "BLACKANDWHITE_ALPHA", v27)) {
            goto LABEL_79;
          }
          if (v9 != 1 && *((_WORD *)this + 122) != 2)
          {
            _cg_jpeg_mem_term("readHeader", 443, "*** ERROR bad 'BLACKANDWHITE_ALPHA'\n");
            return 7;
          }
          goto LABEL_98;
        }
        if (v9 != 1 && *((_WORD *)this + 122) != 1)
        {
          _cg_jpeg_mem_term("readHeader", 436, "*** ERROR bad 'BLACKANDWHITE'\n");
          return 7;
        }
      }
      *((unsigned char *)this + 246) = 0;
      goto LABEL_102;
    default:
      if (v7 == 70)
      {
        uint64_t result = PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46);
        if (!result) {
          return result;
        }
        PBMReadPlugin::readFloat(this);
        int v9 = 0;
        if (v10 != 0.0)
        {
          uint64_t result = 9;
          goto LABEL_24;
        }
        return 0;
      }
      if (v7 != 102) {
        return 0;
      }
      uint64_t result = PBMReadPlugin::readWidthAndHeight(this, &v46[1], v46);
      if (result)
      {
        PBMReadPlugin::readFloat(this);
        int v9 = 0;
        if (v10 != 0.0)
        {
          uint64_t result = 8;
          goto LABEL_24;
        }
        return 0;
      }
      break;
  }
  return result;
}

uint64_t PBMReadPlugin::initialize(PBMReadPlugin *this, IIODictionary *a2)
{
  uint64_t v39 = 0;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v35, *((IIOImageReadSession **)this + 3));
  if (!*((unsigned char *)this + 341))
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -50;
  }
  unint64_t v3 = (const void **)((char *)this + 488);
  unint64_t v4 = v36;
  *((void *)this + 61) = *((void *)&v35 + 1);
  *((void *)this + 62) = v4;
  *((void *)this + 59) = 0;
  if (v4)
  {
    if (v4 >= 0x200) {
      size_t v5 = 512;
    }
    else {
      size_t v5 = v4;
    }
    int v6 = malloc_type_malloc(v5, 0x8FDA7A06uLL);
    memcpy(v6, *v3, v5);
    uint64_t v34 = 0;
    long long v32 = 0u;
    long long v33 = 0u;
    memset(v31, 0, sizeof(v31));
    IIOScanner::IIOScanner((IIOScanner *)v31, (unsigned __int8 *)v6, v5, 0);
    LODWORD(v7) = 0;
    do
    {
      if (*((unsigned char *)v6 + v7) == 35)
      {
        *((unsigned char *)v6 + v7) = 32;
        uint64_t v7 = (v7 + 1);
        if (v7 < v5)
        {
          while (*((unsigned char *)v6 + v7) != 10)
          {
            *((unsigned char *)v6 + v7++) = 32;
            if (v5 == v7) {
              goto LABEL_72;
            }
          }
        }
        if (v7 == v5)
        {
LABEL_72:
          unint64_t v28 = __cxa_allocate_exception(4uLL);
          *unint64_t v28 = -1;
          __cxa_throw(v28, MEMORY[0x1E4FBA3A8], 0);
        }
      }
      LODWORD(v7) = v7 + 1;
    }
    while (v7 < v5);
    if (IIOScanner::getVal8((IIOScanner *)v31) != 80) {
      goto LABEL_73;
    }
    int Val8 = IIOScanner::getVal8((IIOScanner *)v31);
    *((void *)&v32 + 1) = *((void *)this + 60);
    if (Val8 != 55)
    {
      unsigned __int8 v9 = IIOScanner::lookupVal8((IIOScanner *)v31);
      if ((v9 + 2) < 0xFEu) {
        goto LABEL_73;
      }
      while ((v9 & 0xFE) == 0xFC)
        unsigned __int8 v9 = IIOScanner::lookupVal8((IIOScanner *)v31);
      while (v9 <= 9u)
        unsigned __int8 v9 = IIOScanner::lookupVal8((IIOScanner *)v31);
      if ((v9 + 2) < 0xFEu) {
        goto LABEL_73;
      }
      while ((v9 & 0xFE) == 0xFC)
        unsigned __int8 v9 = IIOScanner::lookupVal8((IIOScanner *)v31);
      while (v9 <= 9u)
        unsigned __int8 v9 = IIOScanner::lookupVal8((IIOScanner *)v31);
      if (v9 == 0xFF)
      {
LABEL_73:
        int v29 = __cxa_allocate_exception(4uLL);
        *int v29 = -1;
        __cxa_throw(v29, MEMORY[0x1E4FBA3A8], 0);
      }
    }
    IIOScanner::~IIOScanner((IIOScanner *)v31);
  }
  else
  {
    int v6 = 0;
  }
  unsigned int Header = PBMReadPlugin::readHeader(this);
  unsigned int v11 = Header;
  if (Header <= 0xA)
  {
    if (((1 << Header) & 0x536) != 0)
    {
      *((unsigned char *)this + 246) = 0;
      *((_WORD *)this + 121) = *((_WORD *)this + 120);
      *((_WORD *)this + 122) = 1;
      *((_DWORD *)this + 81) = 1196573017;
      if (Header == 8)
      {
        *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBD0]);
        *((unsigned char *)this + 345) = 1;
        *((unsigned char *)this + 249) = 1;
        char v12 = 2;
        *((unsigned char *)this + 247) = 2;
        *((unsigned char *)this + 278) = 0;
        *((_WORD *)this + 136) = 32;
        *((_WORD *)this + 120) = 32;
        *((unsigned char *)this + 281) = 1;
      }
      else
      {
        *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
        int v15 = *((unsigned __int16 *)this + 120);
        *((_WORD *)this + 136) = v15;
        if (v15 == 16)
        {
          char v12 = 1;
        }
        else
        {
          if (v15 != 32)
          {
LABEL_52:
            *((_DWORD *)this + 59) = (*((_DWORD *)this + 57) * (*((unsigned __int16 *)this + 121) >> 3) + 3) & 0xFFFFFFFC;
            goto LABEL_53;
          }
          char v12 = 2;
        }
      }
      *((unsigned char *)this + 279) = v12;
      goto LABEL_52;
    }
    if (((1 << Header) & 0x248) != 0)
    {
      *((_WORD *)this + 122) = 3;
      *((unsigned char *)this + 246) = 0;
      *((_WORD *)this + 121) = 3 * *((_WORD *)this + 120);
      *((_DWORD *)this + 81) = 1380401696;
      if (Header == 9)
      {
        *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBE0]);
        *((unsigned char *)this + 345) = 1;
        *((_WORD *)this + 121) = 96;
        *((unsigned char *)this + 249) = 1;
        *((unsigned char *)this + 247) = 2;
        *((_DWORD *)this + 69) = 33882116;
        LOWORD(v13) = *((_WORD *)this + 120);
        *((_WORD *)this + 136) = v13;
        *((unsigned char *)this + 281) = 1;
        __int16 v14 = 4;
      }
      else
      {
        *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
        int v13 = *((unsigned __int16 *)this + 120);
        *((_WORD *)this + 136) = v13;
        switch(v13)
        {
          case 8:
            *((_DWORD *)this + 69) = 327684;
            __int16 v14 = 4;
            LOWORD(v13) = 8;
            break;
          case 16:
            *((_DWORD *)this + 69) = 16777219;
            __int16 v14 = 3;
            LOWORD(v13) = 16;
            break;
          case 32:
            *((_DWORD *)this + 69) = 33554435;
            *((unsigned char *)this + 281) = 1;
            __int16 v14 = 3;
            LOWORD(v13) = 32;
            break;
          default:
            __int16 v14 = *((_WORD *)this + 138);
            break;
        }
      }
      *((_DWORD *)this + 59) = *((_DWORD *)this + 57) * (*((unsigned __int16 *)this + 121) >> 3);
      *((_WORD *)this + 137) = v13 * v14;
      goto LABEL_53;
    }
    if (Header == 7)
    {
      int v16 = *((unsigned __int16 *)this + 120);
      int v17 = *((unsigned __int16 *)this + 122);
      *((_WORD *)this + 121) = v17 * v16;
      *((_DWORD *)this + 59) = (((unsigned __int16)(v17 * v16) + 7) >> 3) * *((_DWORD *)this + 57);
      *((_WORD *)this + 136) = v16;
      *((_WORD *)this + 137) = *((_WORD *)this + 138) * v16;
      if (v16 == 16)
      {
        char v18 = 1;
      }
      else
      {
        if (v16 != 32) {
          goto LABEL_63;
        }
        *((unsigned char *)this + 249) = 1;
        char v18 = 2;
      }
      *((unsigned char *)this + 247) = v18;
LABEL_63:
      if (v17 == 3)
      {
        *((_DWORD *)this + 81) = 1380401696;
        if (v16 == 8)
        {
          *(_DWORD *)((char *)this + 274) = 262176;
          *((_WORD *)this + 139) = 5;
        }
      }
      else if (v17 == 4)
      {
        *((_DWORD *)this + 81) = 1380401696;
        if (v16 == 8) {
          __int16 v24 = 3;
        }
        else {
          __int16 v24 = 259;
        }
        *((_WORD *)this + 123) = v24;
      }
      else
      {
        *((_DWORD *)this + 81) = 1196573017;
        int v25 = *((unsigned __int8 *)this + 247);
        int v26 = (v25 << 12) | (*((unsigned __int8 *)this + 248) << 16);
        BOOL v27 = *((unsigned char *)this + 249) != 0;
        *((unsigned char *)this + 278) = *((unsigned char *)this + 246) & 0x1F;
        *((unsigned char *)this + 279) = v25 & 7;
        *((unsigned char *)this + 280) = BYTE2(v26) & 0xF;
        *((unsigned char *)this + 281) = v27;
      }
LABEL_53:
      *((void *)this + 45) = 1;
      *((void *)this + 55) = v11;
      *((void *)this + 58) = *((void *)this + 59);
      *((unsigned char *)this + 350) = 1;
      unsigned int v21 = (*((unsigned __int8 *)this + 247) << 12) | (*((unsigned __int8 *)this + 248) << 16) | ((*((unsigned char *)this + 249) != 0) << 8) | *((unsigned __int8 *)this + 246);
      char v22 = IIO_BitmapInfoString(v21);
      _cg_jpeg_mem_term("initialize", 766, "*** bitmapInfo: %08X  %s\n", v21, v22);
      uint64_t v20 = 0;
      char v19 = 1;
      *((_WORD *)this + 188) = 1;
      if (!v6) {
        goto LABEL_55;
      }
      goto LABEL_54;
    }
  }
  _cg_jpeg_mem_term("initialize", 755, "*** ERROR: PBM type '%d' not handled\n", Header);
  char v19 = 0;
  uint64_t v20 = 4294967246;
  if (v6) {
LABEL_54:
  }
    free(v6);
LABEL_55:
  __CFWriteStream *v3 = 0;
  *((void *)this + 62) = 0;
  if ((v19 & 1) == 0) {
    kdebug_trace();
  }
  IIOScanner::~IIOScanner((IIOScanner *)&v35);
  return v20;
}

void sub_1887BFD80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

void sub_1887BFDA8(void *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  __cxa_begin_catch(a1);
  _cg_jpeg_mem_term("initialize", 599, "failed to read PBM header\n");
  __cxa_end_catch();
  IIOScanner::~IIOScanner((IIOScanner *)va);
  JUMPOUT(0x1887BFB20);
}

void sub_1887BFDD0(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  __cxa_end_catch();
  IIOScanner::~IIOScanner((IIOScanner *)va);
  JUMPOUT(0x1887BFD8CLL);
}

void sub_1887BFDE0(void *a1)
{
}

uint64_t PBMReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12) {
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2);
  }
  if (v2 == 1) {
    return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

uint64_t PBMReadPlugin::loadDataFromXPCObject(PBMReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_pbm", &length);
    if (length == 40)
    {
      int v6 = data;
      uint64_t result = 0;
      long long v7 = *v6;
      long long v8 = v6[1];
      *((void *)this + 59) = *((void *)v6 + 4);
      *(_OWORD *)((char *)this + 440) = v7;
      *(_OWORD *)((char *)this + 456) = v8;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t PBMReadPlugin::saveDataToXPCObject(PBMReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_pbm", (char *)this + 440, 0x28uLL);
  }
  return v4;
}

uint64_t PBMReadPlugin::decode_PBM_P1_TXT(PBMReadPlugin *this, unsigned __int8 *a2)
{
  unsigned int v2 = *((_DWORD *)this + 74);
  if (!v2) {
    return 1;
  }
  int v5 = 0;
  unint64_t v6 = 0;
  LODWORD(v7) = *((_DWORD *)this + 73);
  do
  {
    if (!v7) {
      goto LABEL_15;
    }
    unint64_t v8 = 0;
    unsigned __int8 v9 = &a2[v6 * *((unsigned int *)this + 75)];
    do
    {
      while (1)
      {
        unsigned int Char = PBMReadPlugin::readChar(this);
        if ((Char & 0x80000000) != 0) {
          break;
        }
        if ((*(char *)(*((void *)this + 60) + Char) & 0x80000000) == 0)
        {
          if (*(unsigned char *)(*((void *)this + 60) + Char)) {
            char v11 = 0;
          }
          else {
            char v11 = -1;
          }
          goto LABEL_13;
        }
      }
      if (++v5 <= 9) {
        _cg_jpeg_mem_term("decode_PBM_P1_TXT", 870, "*** PBM - P1: invalid value at [%d,%d]: 0x%02X\n", v6, v8, -1);
      }
      char v11 = 0;
LABEL_13:
      *v9++ = v11;
      ++v8;
      unint64_t v7 = *((unsigned int *)this + 73);
    }
    while (v8 < v7);
    unsigned int v2 = *((_DWORD *)this + 74);
LABEL_15:
    ++v6;
  }
  while (v6 < v2);
  if (v5) {
    LogError("decode_PBM_P1_TXT", 880, "*** ERROR: PBM - P1: %d invalid values in image [%d x %d]\n", v5, *((_DWORD *)this + 73), v2);
  }
  return 1;
}

uint64_t PBMReadPlugin::decode_PBM_P2_TXT(PBMReadPlugin *this, unsigned __int8 *a2)
{
  uint64_t v4 = *((void *)this + 56);
  unsigned int v5 = *((_DWORD *)this + 74);
  if (*((_WORD *)this + 120) == 16)
  {
    if (!v5) {
      return 1;
    }
    int v6 = 0;
    unint64_t v7 = 0;
    LODWORD(v8) = *((_DWORD *)this + 73);
    do
    {
      if (v8)
      {
        unint64_t v9 = 0;
        float v10 = &a2[v7 * *((unsigned int *)this + 75)];
        do
        {
          uint64_t Int = PBMReadPlugin::readInt(this);
          if ((Int & 0x80000000) != 0)
          {
            if (++v6 <= 9) {
              _cg_jpeg_mem_term("decode_PBM_P2_TXT", 912, "*** PGM - P2: invalid value at [%d,%d]: 0x%02\n", v7, v9, Int);
            }
            LOWORD(v13) = 0;
          }
          else
          {
            int v12 = (unsigned __int16)Int;
            if ((unsigned __int16)Int >= (unsigned __int16)v4) {
              int v12 = (unsigned __int16)v4;
            }
            unsigned int v13 = 0xFFFF * v12 / (unsigned __int16)v4;
          }
          *(_WORD *)&v10[2 * v9++] = v13;
          unint64_t v8 = *((unsigned int *)this + 73);
        }
        while (v9 < v8);
        unsigned int v5 = *((_DWORD *)this + 74);
      }
      ++v7;
    }
    while (v7 < v5);
  }
  else
  {
    if (!v5) {
      return 1;
    }
    int v6 = 0;
    unint64_t v14 = 0;
    LODWORD(v15) = *((_DWORD *)this + 73);
    do
    {
      if (v15)
      {
        unint64_t v16 = 0;
        int v17 = &a2[v14 * *((unsigned int *)this + 75)];
        do
        {
          uint64_t v18 = PBMReadPlugin::readInt(this);
          if ((v18 & 0x80000000) != 0)
          {
            if (++v6 <= 9) {
              _cg_jpeg_mem_term("decode_PBM_P2_TXT", 935, "*** PGM - P2: invalid value at [%d,%d]: 0x%02\n", v14, v16, v18);
            }
            LOBYTE(v20) = 0;
          }
          else
          {
            int v19 = v18;
            if (v18 >= v4) {
              int v19 = v4;
            }
            unsigned int v20 = 255 * v19 / v4;
          }
          v17[v16++] = v20;
          unint64_t v15 = *((unsigned int *)this + 73);
        }
        while (v16 < v15);
        unsigned int v5 = *((_DWORD *)this + 74);
      }
      ++v14;
    }
    while (v14 < v5);
  }
  if (v6) {
    LogError("decode_PBM_P2_TXT", 948, "*** ERROR: PGM - P2: %d invalid values in image [%d x %d]\n", v6, *((_DWORD *)this + 73), v5);
  }
  return 1;
}

uint64_t PBMReadPlugin::decode_PPM_P3_TXT(PBMReadPlugin *this, unsigned __int8 *a2)
{
  uint64_t v3 = *((void *)this + 56);
  if (*((_WORD *)this + 120) != 16)
  {
    unint64_t v20 = *((unsigned int *)this + 58);
    if (v20)
    {
      unint64_t v5 = 0;
      uint64_t v21 = 2 * (*((unsigned char *)this + 405) != 0);
      uint64_t v22 = 2 * (*((unsigned char *)this + 405) == 0);
      unsigned int v23 = *((void *)this + 56);
      LODWORD(v24) = *((_DWORD *)this + 57);
      long long v36 = a2;
      while (!v24)
      {
LABEL_37:
        ++v5;
        uint64_t result = 1;
        if (v5 >= v20) {
          return result;
        }
      }
      unint64_t v9 = 0;
      int v25 = &a2[v5 * *((unsigned int *)this + 75)];
      while (1)
      {
        int Int = PBMReadPlugin::readInt(this);
        if (Int == -1) {
          break;
        }
        unsigned __int8 v27 = Int;
        int v28 = PBMReadPlugin::readInt(this);
        if (v28 == -1) {
          break;
        }
        unsigned __int8 v29 = v28;
        int v30 = PBMReadPlugin::readInt(this);
        if (v30 == -1) {
          break;
        }
        int v31 = v27;
        if (v27 >= v3) {
          int v31 = v3;
        }
        v25[v22] = 255 * v31 / v23;
        int v32 = v29;
        if (v29 >= v3) {
          int v32 = v3;
        }
        v25[1] = 255 * v32 / v23;
        int v33 = v30;
        if (v30 >= v3) {
          int v33 = v3;
        }
        v25[v21] = 255 * v33 / v23;
        void v25[3] = -1;
        v25 += 4;
        ++v9;
        unint64_t v24 = *((unsigned int *)this + 57);
        if (v9 >= v24)
        {
          unint64_t v20 = *((unsigned int *)this + 58);
          a2 = v36;
          goto LABEL_37;
        }
      }
      uint64_t v34 = 1020;
      goto LABEL_42;
    }
    return 1;
  }
  unint64_t v4 = *((unsigned int *)this + 58);
  if (!v4) {
    return 1;
  }
  unint64_t v5 = 0;
  int v6 = *((unsigned __int8 *)this + 310);
  unsigned int v7 = (unsigned __int16)*((void *)this + 56);
  LODWORD(v8) = *((_DWORD *)this + 57);
  long long v35 = a2;
  while (!v8)
  {
LABEL_20:
    ++v5;
    uint64_t result = 1;
    if (v5 >= v4) {
      return result;
    }
  }
  unint64_t v9 = 0;
  float v10 = &a2[v5 * *((unsigned int *)this + 75)];
  while (1)
  {
    int v11 = PBMReadPlugin::readInt(this);
    if (v11 == -1) {
      break;
    }
    unsigned __int16 v12 = v11;
    int v13 = PBMReadPlugin::readInt(this);
    if (v13 == -1) {
      break;
    }
    unsigned __int16 v14 = v13;
    int v15 = PBMReadPlugin::readInt(this);
    if (v15 == -1) {
      break;
    }
    int v16 = v12;
    if (v12 >= (unsigned __int16)v3) {
      int v16 = (unsigned __int16)v3;
    }
    *(_WORD *)float v10 = 0xFFFF * v16 / v7;
    int v17 = v14;
    if (v14 >= (unsigned __int16)v3) {
      int v17 = (unsigned __int16)v3;
    }
    *((_WORD *)v10 + 1) = 0xFFFF * v17 / v7;
    int v18 = (unsigned __int16)v15;
    if ((unsigned __int16)v15 >= (unsigned __int16)v3) {
      int v18 = (unsigned __int16)v3;
    }
    *((_WORD *)v10 + 2) = 0xFFFF * v18 / v7;
    if (v6)
    {
      *((_WORD *)v10 + 3) = -1;
      v10 += 8;
    }
    else
    {
      v10 += 6;
    }
    ++v9;
    unint64_t v8 = *((unsigned int *)this + 57);
    if (v9 >= v8)
    {
      unint64_t v4 = *((unsigned int *)this + 58);
      a2 = v35;
      goto LABEL_20;
    }
  }
  uint64_t v34 = 987;
LABEL_42:
  _cg_jpeg_mem_term("decode_PPM_P3_TXT", v34, "reached EOF at row:%d  col:%d\n", v5, v9);
  return 0;
}

void PBMReadPlugin::decode_PBM_P4_RAW(PBMReadPlugin *this, unsigned __int8 *a2)
{
}

void sub_1887C06DC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C4050BC5624);
  _Unwind_Resume(a1);
}

uint64_t PBMReadPlugin::decode_PGM_P5_RAW(PBMReadPlugin *this, unsigned __int8 *__dst)
{
  unsigned int v2 = *((_DWORD *)this + 58);
  if (!v2) {
    return 1;
  }
  unsigned int v5 = 0;
  unint64_t v6 = (unint64_t)*((unsigned __int16 *)this + 120) >> 3;
  size_t v7 = v6 * (unint64_t)*((unsigned int *)this + 57);
  unint64_t v8 = __dst;
  do
  {
    if (v7 && (uint64_t v9 = *((void *)this + 61)) != 0)
    {
      size_t v10 = *((void *)this + 59);
      size_t v11 = v10 + v7;
      if (__CFADD__(v10, v7) || v11 < v10 || *((void *)this + 62) < v11)
      {
LABEL_19:
        _cg_jpeg_mem_term("decode_PGM_P5_RAW", 1112, "read error requested %ld bytes - got %d\n", v7, 0);
        return 0;
      }
      memcpy(v8, (const void *)(v9 + v10), v7);
      *((void *)this + 59) += v7;
      unsigned int v2 = *((_DWORD *)this + 58);
    }
    else if (v7)
    {
      goto LABEL_19;
    }
    uint64_t v12 = *((unsigned int *)this + 75);
    v8 += v12;
    ++v5;
  }
  while (v5 < v2);
  uint64_t result = 1;
  if (v6 == 2 && v2)
  {
    uint64_t v14 = 0;
    int v15 = *((_DWORD *)this + 57);
    do
    {
      if (v15)
      {
        int v16 = &__dst[(v12 * v14)];
        int v17 = v15;
        do
        {
          *(_WORD *)int v16 = bswap32(*(unsigned __int16 *)v16) >> 16;
          v16 += 2;
          --v17;
        }
        while (v17);
      }
      ++v14;
    }
    while (v14 != v2);
    return 1;
  }
  return result;
}

uint64_t PBMReadPlugin::decode_PPM_P6_RAW(PBMReadPlugin *this, unsigned __int8 *a2)
{
  size_t v4 = *((unsigned int *)this + 59);
  size_t v5 = *((unsigned int *)this + 75);
  unint64_t v6 = (unsigned __int8 *)malloc_type_malloc(v4, 0xE6F4D941uLL);
  size_t v7 = v6;
  uint64_t v8 = *((void *)this + 56);
  int v9 = *((unsigned __int16 *)this + 120);
  if (v9 == 16)
  {
    if (*((_DWORD *)this + 58))
    {
      unsigned int v20 = 0;
      vImagePixelCount v21 = 3 * *((unsigned int *)this + 57);
      do
      {
        if (v4 && (uint64_t v22 = *((void *)this + 61)) != 0)
        {
          size_t v23 = *((void *)this + 59);
          size_t v24 = v23 + v4;
          if (__CFADD__(v23, v4) || v24 < v23 || *((void *)this + 62) < v24)
          {
LABEL_51:
            _cg_jpeg_mem_term("decode_PPM_P6_RAW", 1200, "read error requested %ld bytes - got %d\n");
            goto LABEL_53;
          }
          memcpy(v7, (const void *)(v22 + v23), v4);
          *((void *)this + 59) += v4;
        }
        else if (v4)
        {
          goto LABEL_51;
        }
        if (*((unsigned char *)this + 344))
        {
          dest.data = v7;
          dest.double height = 1;
          dest.unint64_t width = v21;
          dest.rowunint64_t Bytes = v4;
          vImageByteSwap_Planar16U(&dest, &dest, 0x10u);
        }
        int v25 = *((_DWORD *)this + 73);
        if (v25)
        {
          LODWORD(v26) = 3 * v25;
          if (v26 <= 1) {
            uint64_t v26 = 1;
          }
          else {
            uint64_t v26 = v26;
          }
          unsigned __int8 v27 = v7;
          do
          {
            unsigned int v28 = (unsigned __int16)*v27;
            if (v28 >= (unsigned __int16)v8) {
              unsigned int v28 = (unsigned __int16)v8;
            }
            *v27++ = 0xFFFF * v28 / (unsigned __int16)v8;
            --v26;
          }
          while (v26);
        }
        memcpy(a2, v7, v4);
        a2 += *((unsigned int *)this + 75);
        ++v20;
      }
      while (v20 < *((_DWORD *)this + 58));
    }
    goto LABEL_47;
  }
  if (v9 != 8)
  {
LABEL_47:
    uint64_t v10 = 1;
LABEL_48:
    if (!v7) {
      return v10;
    }
    goto LABEL_49;
  }
  uint64_t v10 = 1;
  dest.data = v6;
  dest.double height = 1;
  int v11 = *((_DWORD *)this + 58);
  dest.unint64_t width = *((unsigned int *)this + 57);
  dest.rowunint64_t Bytes = v4;
  v30.data = a2;
  v30.double height = 1;
  v30.unint64_t width = *((unsigned int *)this + 73);
  v30.rowunint64_t Bytes = v5;
  if (!v11) {
    goto LABEL_48;
  }
  int v12 = 0;
  while (1)
  {
    if (v4)
    {
      uint64_t v13 = *((void *)this + 61);
      if (v13)
      {
        size_t v14 = *((void *)this + 59);
        size_t v15 = v14 + v4;
        if (!__CFADD__(v14, v4) && v15 >= v14 && *((void *)this + 62) >= v15)
        {
          memcpy(v7, (const void *)(v13 + v14), v4);
          *((void *)this + 59) += v4;
          goto LABEL_11;
        }
      }
    }
    if (v4) {
      break;
    }
LABEL_11:
    if (*((_DWORD *)this + 73))
    {
      unint64_t v16 = 0;
      do
      {
        unsigned int v17 = v7[v16];
        if (v17 >= v8) {
          unsigned int v17 = v8;
        }
        v7[v16++] = 255 * v17 / v8;
      }
      while (v16 < (3 * *((_DWORD *)this + 73)));
    }
    if (*((unsigned char *)this + 405)) {
      vImageConvert_RGB888toRGBA8888(&dest, 0, 0xFFu, &v30, 0, 0);
    }
    else {
      vImageConvert_RGB888toBGRA8888(&dest, 0, 0xFFu, &v30, 0, 0);
    }
    if (*((_DWORD *)this + 73))
    {
      unint64_t v18 = 0;
      do
      {
        unsigned int v19 = v7[v18];
        if (v19 >= v8) {
          unsigned int v19 = v8;
        }
        v7[v18++] = 255 * v19 / v8;
      }
      while (v18 < (3 * *((_DWORD *)this + 73)));
    }
    v30.data = (char *)v30.data + *((unsigned int *)this + 75);
    if (++v12 >= *((_DWORD *)this + 58)) {
      goto LABEL_47;
    }
  }
  _cg_jpeg_mem_term("decode_PPM_P6_RAW", 1160, "read error requested %ld bytes - got %d\n");
LABEL_53:
  uint64_t v10 = 0;
  if (v7) {
LABEL_49:
  }
    free(v7);
  return v10;
}

uint64_t PBMReadPlugin::decode_PAM_P7_RAW(PBMReadPlugin *this, unsigned __int8 *a2)
{
  size_t v4 = *((unsigned int *)this + 59);
  uint64_t v5 = *((unsigned int *)this + 75);
  unint64_t v6 = malloc_type_malloc(v4, 0x675D196uLL);
  int v7 = *((unsigned __int8 *)this + 240);
  switch(*((_WORD *)this + 122))
  {
    case 1:
      operator new();
    case 2:
      operator new();
    case 3:
      if (v7 == 8) {
        operator new();
      }
      return result;
    case 4:
      if (v7 == 16) {
        operator new();
      }
      operator new();
    default:
      _cg_jpeg_mem_term("decode_PAM_P7_RAW", 1274, "*** ERROR: unexpected numberOfChannels: %d\n", *((unsigned __int16 *)this + 122));
      break;
  }
  uint64_t v8 = 1;
  unsigned int v19 = v6;
  uint64_t v20 = 1;
  int v9 = *((_DWORD *)this + 58);
  uint64_t v21 = *((unsigned int *)this + 57);
  size_t v22 = v4;
  size_t v15 = a2;
  uint64_t v16 = 1;
  uint64_t v17 = *((unsigned int *)this + 73);
  uint64_t v18 = v5;
  if (v9)
  {
    int v10 = 0;
    while (1)
    {
      if (v4 && (uint64_t v11 = *((void *)this + 61)) != 0)
      {
        size_t v12 = *((void *)this + 59);
        size_t v13 = v12 + v4;
        if (__CFADD__(v12, v4) || v13 < v12 || *((void *)this + 62) < v13)
        {
LABEL_22:
          _cg_jpeg_mem_term("decode_PAM_P7_RAW", 1286, "read error requested %ld bytes - got %d\n", v6, 0);
          uint64_t v8 = 0;
          break;
        }
        memcpy(v6, (const void *)(v11 + v12), v4);
        *((void *)this + 59) += v4;
      }
      else if (v4)
      {
        goto LABEL_22;
      }
      a2 += v5;
      size_t v15 = a2;
      if (++v10 >= *((_DWORD *)this + 58))
      {
        uint64_t v8 = 1;
        break;
      }
    }
  }
  if (v6) {
    free(v6);
  }
  return v8;
}

void sub_1887C0F20(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C401865CEE3);
  _Unwind_Resume(a1);
}

uint64_t PBMReadPlugin::decode_PFM_Pf_RAW(PBMReadPlugin *this, unsigned __int8 *a2)
{
  float v4 = *((float *)this + 114);
  size_t v5 = *((unsigned int *)this + 57) * ((unint64_t)*((unsigned __int16 *)this + 121) >> 3);
  int v6 = *((unsigned __int16 *)this + 152);
  if (v6 == 16)
  {
    uint64_t v17 = malloc_type_malloc(*((unsigned int *)this + 57) * ((unint64_t)*((unsigned __int16 *)this + 121) >> 3), 0x5F4C98A2uLL);
    unsigned int v18 = *((_DWORD *)this + 58);
    if (v18)
    {
      for (unsigned int i = 0; i < v18; ++i)
      {
        int v20 = *((_DWORD *)this + 75);
        if (v5 && (uint64_t v21 = *((void *)this + 61)) != 0)
        {
          size_t v22 = *((void *)this + 59);
          size_t v23 = v22 + v5;
          if (__CFADD__(v22, v5) || v23 < v22 || *((void *)this + 62) < v23)
          {
LABEL_39:
            _cg_jpeg_mem_term("decode_PFM_Pf_RAW", 1361, "*** ERROR: read error requested %ld bytes - got %d\n", v5, 0);
            uint64_t v36 = 0;
            if (!v17) {
              return v36;
            }
LABEL_40:
            free(v17);
            return v36;
          }
          memcpy(v17, (const void *)(v21 + v22), v5);
          *((void *)this + 59) += v5;
        }
        else if (v5)
        {
          goto LABEL_39;
        }
        int v24 = *((_DWORD *)this + 57);
        if (v24)
        {
          int v25 = &a2[v20 * (v18 + ~i)];
          int v26 = *((unsigned __int8 *)this + 344);
          unsigned __int8 v27 = (unsigned int *)v17;
          do
          {
            unsigned int v28 = *v27++;
            float v29 = *(float *)&v28;
            float v30 = COERCE_FLOAT(bswap32(v28));
            if (!v26) {
              float v29 = v30;
            }
            _S0 = v4 * v29;
            __asm { FCVT            H0, S0 }
            *(_WORD *)int v25 = LOWORD(_S0);
            v25 += 2;
            --v24;
          }
          while (v24);
        }
        unsigned int v18 = *((_DWORD *)this + 58);
      }
    }
    uint64_t v36 = 1;
    if (!v17) {
      return v36;
    }
    goto LABEL_40;
  }
  if (v6 == 32)
  {
    unsigned int v7 = *((_DWORD *)this + 58);
    if (v7)
    {
      for (unsigned int j = 0; j < v7; ++j)
      {
        int v9 = (float *)&a2[*((_DWORD *)this + 75) * (v7 + ~j)];
        if (v5
          && (uint64_t v10 = *((void *)this + 61)) != 0
          && (v11 = *((void *)this + 59), size_t v12 = v11 + v5, !__CFADD__(v11, v5))
          && v12 >= v11
          && *((void *)this + 62) >= v12)
        {
          memcpy(v9, (const void *)(v10 + v11), v5);
          *((void *)this + 59) += v5;
        }
        else if (v5)
        {
          _cg_jpeg_mem_term("decode_PFM_Pf_RAW", 1337, "read error requested %ld bytes - got %d\n", v5, 0);
          return 0;
        }
        int v13 = *((_DWORD *)this + 57);
        if (v13)
        {
          int v14 = *((unsigned __int8 *)this + 344);
          do
          {
            float v15 = *v9;
            float v16 = COERCE_FLOAT(bswap32(*(_DWORD *)v9));
            if (!v14) {
              float v15 = v16;
            }
            *v9++ = v4 * v15;
            --v13;
          }
          while (v13);
        }
        unsigned int v7 = *((_DWORD *)this + 58);
      }
    }
  }
  else
  {
    LogError("decode_PFM_Pf_RAW", 1379, "*** ERROR: unexpected bitdepth: %d\n", v6);
  }
  return 1;
}

uint64_t PBMReadPlugin::decode_PFM_PF_RAW(PBMReadPlugin *this, unsigned __int8 *a2)
{
  size_t v4 = *((unsigned int *)this + 59);
  unsigned int v5 = *((_DWORD *)this + 75);
  int v6 = (char *)malloc_type_malloc(v4, 0xDBE42F3uLL);
  if (!*((_DWORD *)this + 58))
  {
LABEL_30:
    uint64_t v35 = 1;
    if (v6) {
      goto LABEL_31;
    }
    return v35;
  }
  int v7 = 0;
  float v8 = *((float *)this + 114);
  while (1)
  {
    if (v4)
    {
      uint64_t v9 = *((void *)this + 61);
      if (v9) {
        break;
      }
    }
    if (v4) {
      goto LABEL_33;
    }
LABEL_10:
    int v12 = *((unsigned __int16 *)this + 152);
    if (v12 == 16)
    {
      int v22 = *((_DWORD *)this + 57);
      if (v22)
      {
        int v23 = 0;
        int v24 = &a2[v5 * (unint64_t)(*((_DWORD *)this + 74) + ~v7)];
        int v25 = *((unsigned __int8 *)this + 344);
        int v26 = v6;
        do
        {
          uint64_t v27 = 0;
          v24 += 2;
          do
          {
            float v28 = *(float *)&v26[v27];
            float v29 = COERCE_FLOAT(bswap32(LODWORD(v28)));
            if (!v25) {
              float v28 = v29;
            }
            _S0 = v8 * v28;
            __asm { FCVT            H0, S0 }
            *((_WORD *)v24 - 1) = LOWORD(_S0);
            v27 += 4;
            v24 += 2;
          }
          while (v27 != 12);
          *((_WORD *)v24 - 1) = COERCE_UNSIGNED_INT(1.0);
          ++v23;
          v26 += v27;
        }
        while (v23 != v22);
      }
    }
    else if (v12 == 32)
    {
      int v13 = *((_DWORD *)this + 57);
      if (v13)
      {
        int v14 = 0;
        float v15 = &a2[v5 * (unint64_t)(*((_DWORD *)this + 74) + ~v7)];
        int v16 = *((unsigned __int8 *)this + 344);
        uint64_t v17 = v6;
        do
        {
          uint64_t v18 = 0;
          do
          {
            float v19 = *(float *)&v17[v18];
            float v20 = COERCE_FLOAT(bswap32(LODWORD(v19)));
            if (!v16) {
              float v19 = v20;
            }
            *(float *)&v15[v18] = v8 * v19;
            v18 += 4;
          }
          while (v18 != 12);
          uint64_t v21 = &v15[v18];
          *(_DWORD *)uint64_t v21 = 1065353216;
          float v15 = v21 + 4;
          ++v14;
          v17 += v18;
        }
        while (v14 != v13);
      }
    }
    else
    {
      LogError("decode_PFM_PF_RAW", 1462, "*** ERROR: unexpected bitdepth: %d\n", *((unsigned __int16 *)this + 152));
    }
    if (++v7 >= *((_DWORD *)this + 58)) {
      goto LABEL_30;
    }
  }
  size_t v10 = *((void *)this + 59);
  size_t v11 = v10 + v4;
  if (!__CFADD__(v10, v4) && v11 >= v10 && *((void *)this + 62) >= v11)
  {
    memcpy(v6, (const void *)(v9 + v10), v4);
    *((void *)this + 59) += v4;
    goto LABEL_10;
  }
LABEL_33:
  _cg_jpeg_mem_term("decode_PFM_PF_RAW", 1413, "read error requested %ld bytes - got %d\n", v4, 0);
  uint64_t v35 = 0;
  if (!v6) {
    return v35;
  }
LABEL_31:
  free(v6);
  return v35;
}

uint64_t PBMReadPlugin::decodeImageData(IIOImageReadSession **this, unsigned __int8 *a2)
{
  uint64_t v12 = 0;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v8, this[3]);
  size_t v4 = (IIOImageReadSession *)v9;
  this[61] = (IIOImageReadSession *)*((void *)&v8 + 1);
  this[62] = v4;
  switch((unint64_t)this[55])
  {
    case 1uLL:
      PBMReadPlugin::decode_PBM_P1_TXT((PBMReadPlugin *)this, a2);
      goto LABEL_13;
    case 2uLL:
      PBMReadPlugin::decode_PBM_P2_TXT((PBMReadPlugin *)this, a2);
      goto LABEL_13;
    case 3uLL:
      int v5 = PBMReadPlugin::decode_PPM_P3_TXT((PBMReadPlugin *)this, a2);
      goto LABEL_12;
    case 4uLL:
      PBMReadPlugin::decode_PBM_P4_RAW((PBMReadPlugin *)this, a2);
    case 5uLL:
      int v5 = PBMReadPlugin::decode_PGM_P5_RAW((PBMReadPlugin *)this, a2);
      goto LABEL_12;
    case 6uLL:
      int v5 = PBMReadPlugin::decode_PPM_P6_RAW((PBMReadPlugin *)this, a2);
      goto LABEL_12;
    case 7uLL:
      int v5 = PBMReadPlugin::decode_PAM_P7_RAW((PBMReadPlugin *)this, a2);
      goto LABEL_12;
    case 8uLL:
      int v5 = PBMReadPlugin::decode_PFM_Pf_RAW((PBMReadPlugin *)this, a2);
      goto LABEL_12;
    case 9uLL:
      int v5 = PBMReadPlugin::decode_PFM_PF_RAW((PBMReadPlugin *)this, a2);
LABEL_12:
      if (!v5) {
        goto LABEL_14;
      }
LABEL_13:
      uint64_t v6 = 0;
      break;
    default:
      _cg_jpeg_mem_term("decodeImageData", 1522, "unknown PPM format [%d]", this[55]);
LABEL_14:
      uint64_t v6 = 4294967246;
      break;
  }
  IIOScanner::~IIOScanner((IIOScanner *)&v8);
  return v6;
}

void sub_1887C1580(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

uint64_t PBMReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  uint64_t v40 = 0;
  unint64_t v41 = 0;
  if (!*((void *)this + 3)) {
    return 4294967292;
  }
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v8 = *((_DWORD *)this + 51);
    unsigned int v9 = v8 >> 24;
    uint64_t v10 = MEMORY[0x1E4F14390];
    if (v8 < 0)
    {
      int v11 = __maskrune(v9, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
    }
    if (v11) {
      uint64_t v12 = (v8 >> 24);
    }
    else {
      uint64_t v12 = 46;
    }
    unsigned int v13 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      int v14 = __maskrune(v13, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    }
    if (v14) {
      uint64_t v15 = (v8 << 8 >> 24);
    }
    else {
      uint64_t v15 = 46;
    }
    unsigned int v16 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      int v17 = __maskrune(v16, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = ((__int16)v8 >> 8);
    }
    else {
      uint64_t v18 = 46;
    }
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0) {
        goto LABEL_23;
      }
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_23:
      uint64_t v19 = *((char *)this + 204);
LABEL_26:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus PBMReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_27;
    }
    uint64_t v19 = 46;
    goto LABEL_26;
  }
LABEL_27:
  IIOReadPlugin::debugDecodeImage(this, a2);
  IIOImageReadSession::rewind(*((void *)this + 3));
  BOOL v20 = IIOImageReadSession::mapData(*((IIOImageRead ***)this + 3));
  *((void *)this + 61) = IIOImageReadSession::retainBytePointer(*((IIOImageReadSession **)this + 3), (const __CFData **)&v40, 1);
  *((void *)this + 62) = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  *((void *)this + 59) = *((void *)this + 58);
  if (a3 == 3)
  {
    uint64_t BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v27) = *((_DWORD *)this + 73);
    double v26 = (double)v27;
    unsigned int v28 = *((_DWORD *)this + 74);
    double v24 = (double)v28;
    memory_object_size_t v23 = *((unsigned int *)this + 75) * (unint64_t)v28;
    BaseAddress = (void *)_ImageIO_Malloc(v23, *((void *)this + 48), &v41, (uint64_t)kImageMalloc_PBM_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
    {
      uint64_t BlockArray = 4294967292;
      goto LABEL_46;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    size_t Height = IOSurfaceGetHeight(*a4);
    memory_object_size_t v23 = IOSurfaceGetBytesPerRow(*a4) * Height;
    unint64_t v41 = v23;
    double v24 = 0.0;
    uint64_t BlockArray = 4294967292;
    double v26 = 0.0;
  }
  if (BaseAddress)
  {
    bzero(BaseAddress, v23);
    uint64_t BlockArray = (*(uint64_t (**)(IIOReadPlugin *, void *, memory_object_size_t))(*(void *)this + 120))(this, BaseAddress, v23);
    if (BlockArray)
    {
      *((_DWORD *)this + 26) = 0;
      if (a3 == 3) {
        _ImageIO_Free((unint64_t)BaseAddress, v41);
      }
    }
    else
    {
      if (*((unsigned char *)this + 406) == 1)
      {
        vImagePixelCount v29 = *((unsigned int *)this + 74);
        dest.data = BaseAddress;
        dest.double height = v29;
        size_t v30 = *((unsigned int *)this + 75);
        dest.unint64_t width = *((unsigned int *)this + 73);
        dest.rowunint64_t Bytes = v30;
        vImagePremultiplyData_RGBA8888(&dest, &dest, 0);
      }
      if (a3 == 3)
      {
        uint64_t v31 = 0;
        v42.origin.CGFloat x = 0.0;
        v42.origin.CGFloat y = 0.0;
        v42.size.unint64_t width = v26;
        v42.size.double height = v24;
        **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v41, v42, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
        if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E4F1DB20]))
        {
          uint64_t v32 = 0;
        }
        else
        {
          v43.origin.CGFloat x = 0.0;
          v43.origin.CGFloat y = 0.0;
          v43.size.unint64_t width = v26;
          v43.size.double height = v24;
          *(CGRect *)(&v32 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v43);
          uint64_t v31 = v33;
          double v26 = v34;
          double v24 = v35;
        }
        uint64_t BlockArray = 0;
        *((void *)this + 15) = v31;
        *((void *)this + 16) = v32;
        *((double *)this + 17) = v26;
        *((double *)this + 18) = v24;
      }
      else
      {
        IOSurfaceUnlock(*a4, 0, 0);
        uint64_t BlockArray = 0;
      }
    }
  }
LABEL_46:
  if (v40 && (uint64_t v36 = (IIOImageRead **)*((void *)this + 3)) != 0)
  {
    IIOImageReadSession::releaseBytePointer(v36, v40);
    if (!v20) {
      return BlockArray;
    }
  }
  else if (!v20)
  {
    return BlockArray;
  }
  long long v37 = (const char **)*((void *)this + 3);
  if (v37) {
    IIOImageReadSession::unmapData(v37);
  }
  return BlockArray;
}

void sub_1887C19D8(void *a1)
{
}

char *createNodePath(uint64_t a1)
{
  uint64_t result = (char *)malloc_type_calloc(1uLL, 1uLL, 0x37070E98uLL);
  size_t v4 = result;
  if (a1)
  {
    do
    {
      uint64_t v3 = v4;
      if (*(_DWORD *)a1 > 1u)
      {
        switch(*(_DWORD *)a1)
        {
          case 2:
            asprintf(&v4, "%s[%d]");
            goto LABEL_4;
          case 3:
            asprintf(&v4, "%s[%s]");
            goto LABEL_4;
          case 4:
            asprintf(&v4, "%s.%s%s");
            goto LABEL_4;
          case 5:
            asprintf(&v4, "%s?%s%s");
            goto LABEL_4;
          default:
            break;
        }
      }
      else
      {
        asprintf(&v4, "%s%s%s");
LABEL_4:
        free(v3);
      }
      a1 = *(void *)(a1 + 40);
    }
    while (a1);
    return v4;
  }
  return result;
}

char *fixPrefixes(char *result)
{
  uint64_t v1 = (int *)*((void *)result + 5);
  if (v1)
  {
    unsigned int v2 = (const char *)*((void *)result + 1);
    do
    {
      uint64_t v3 = (const char *)*((void *)v1 + 1);
      if (!v3)
      {
        int v4 = *v1;
        if (*v1 != 1 && v4 != 4)
        {
          if (v4 == 5 && v2 != 0)
          {
LABEL_15:
            uint64_t result = strdup(v2);
            *((void *)v1 + 1) = result;
          }
          uint64_t v3 = v2;
          goto LABEL_17;
        }
        if (v2) {
          goto LABEL_15;
        }
        uint64_t v3 = 0;
      }
LABEL_17:
      uint64_t v1 = (int *)*((void *)v1 + 5);
      unsigned int v2 = v3;
    }
    while (v1);
  }
  return result;
}

CGPDFDocument *CreateSessionPDFRef(off_t *a1, BOOL *a2)
{
  CGDataProviderDirectCallbacks v7 = *(CGDataProviderDirectCallbacks *)byte_1ED4F0C18;
  uint64_t v3 = CGDataProviderCreateDirect(a1, a1[2], &v7);
  int v4 = CGPDFDocumentCreateWithProvider(v3);
  CFRelease(v3);
  if (v4 && !CGPDFDocumentIsUnlocked(v4))
  {
    CGPDFDocumentRelease(v4);
    int v4 = 0;
    BOOL v5 = 1;
    if (!a2) {
      return v4;
    }
    goto LABEL_4;
  }
  BOOL v5 = 0;
  if (a2) {
LABEL_4:
  }
    *a2 = v5;
  return v4;
}

uint64_t dpGetBytePointer(uint64_t result)
{
  if (result) {
    return *(void *)(result + 8);
  }
  return result;
}

IIOScanner *dpGetBytesAtPosition(IIOScanner *this, void *__dst, uint64_t a3, size_t __n)
{
  if (this) {
    return (IIOScanner *)IIOScanner::getBytesAtOffset(this, __dst, a3, __n);
  }
  return this;
}

uint64_t IIO_CreateInputColorSpaceForOutputPoppyProfile()
{
  InputPoppyProfile = (const ColorSyncProfile *)ColorSyncCreateInputPoppyProfile();
  CFErrorRef error = 0;
  if (!InputPoppyProfile) {
    return 0;
  }
  uint64_t v1 = InputPoppyProfile;
  CFDataRef v2 = ColorSyncProfileCopyData(InputPoppyProfile, &error);
  if (v2)
  {
    CFDataRef v3 = v2;
    uint64_t v4 = MEMORY[0x18C11AC10]();
    CFRelease(v3);
  }
  else
  {
    uint64_t v4 = 0;
  }
  CFRelease(v1);
  return v4;
}

const ColorSyncProfile *IIO_CreateOutputPoppyProfileForImage(CGImageSource *a1, CGImageRef image, void *a3)
{
  ThumbnailAtIndeCGFloat x = a1;
  *a3 = 0;
  if (a1)
  {
    CGColorSpaceRef v42 = 0;
    CFDictionaryRef options = 0;
    uint64_t v44 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v42);
    IIONumber::IIONumber((IIONumber *)error, 160);
    IIODictionary::setObjectForKey((IIODictionary *)&v42, error[2], @"kCGImageSourceThumbnailMaxPixelSize");
    IIONumber::~IIONumber((IIONumber *)error);
    IIODictionary::setObjectForKey((IIODictionary *)&v42, (const void *)*MEMORY[0x1E4F1CFD0], @"kCGImageSourceCreateThumbnailFromImageIfAbsent");
    ThumbnailAtIndeCGFloat x = CGImageSourceCreateThumbnailAtIndex(ThumbnailAtIndex, 0, options);
    IIODictionary::~IIODictionary((IIODictionary *)&v42);
  }
  if ((gIIODebugFlags & 0x8000000000) != 0)
  {
    int Width = CGImageGetWidth(image);
    int Height = CGImageGetHeight(image);
    ImageIOLog("COL image: %p [%d x %d]\n", image, Width, Height);
    if ((gIIODebugFlags & 0x8000300000) != 0)
    {
      int v7 = CGImageGetWidth(ThumbnailAtIndex);
      int v8 = CGImageGetHeight(ThumbnailAtIndex);
      ImageIOLog("COL thumb: %p [%d x %d]\n", ThumbnailAtIndex, v7, v8);
      if ((gIIODebugFlags & 0x8000300000) != 0) {
        ImageIOLog("COL color: ");
      }
    }
    CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
    CFShow(ColorSpace);
  }
  if (ThumbnailAtIndex) {
    uint64_t v10 = ThumbnailAtIndex;
  }
  else {
    uint64_t v10 = image;
  }
  error[0] = 0;
  size_t v11 = CGImageGetWidth(v10);
  size_t v12 = CGImageGetHeight(v10);
  CFStringRef v13 = (const __CFString *)*MEMORY[0x1E4F1DB90];
  CGColorSpaceRef v42 = (CGColorSpaceRef)&unk_1ED4DFD58;
  CFDictionaryRef options = 0;
  CFDictionaryRef options = CGColorSpaceCreateWithName(v13);
  if (v11 >= v12) {
    unint64_t v14 = v12;
  }
  else {
    unint64_t v14 = v11;
  }
  if (v14)
  {
    double v15 = 24.0 / (double)v14;
    if (v15 > 1.0) {
      double v15 = 1.0;
    }
    float v16 = v15;
  }
  else
  {
    float v16 = 1.0;
  }
  int v17 = CGImageGetColorSpace(v10);
  if (CGColorSpaceSupportsOutput(v17)) {
    uint64_t v18 = v17;
  }
  else {
    uint64_t v18 = options;
  }
  PropertCGFloat y = (const __CFString *)CGImageGetProperty();
  CFStringRef v20 = Property;
  size_t v21 = vcvtms_u32_f32(v16 * (float)v11);
  size_t v22 = vcvtms_u32_f32(v16 * (float)v12);
  if (!Property
    || CFStringCompare(Property, @"public.jpeg", 0) && CFStringCompare(v20, @"public.heic", 0))
  {
    goto LABEL_30;
  }
  memory_object_size_t v23 = CGBitmapContextCreate(0, 2 * v21, 2 * v22, 8uLL, 8 * v21, v18, 5u);
  double v24 = v23;
  if (!v23)
  {
    _cg_jpeg_mem_term("IIO_CreateOutputPoppyProfileForImage", 218, "*** ERROR: CGBitmapContextCreate returned NULL\n");
LABEL_30:
    double v26 = 0;
    goto LABEL_31;
  }
  v45.size.unint64_t width = (double)(2 * v21);
  v45.size.double height = (double)(2 * v22);
  v45.origin.CGFloat x = 0.0;
  v45.origin.CGFloat y = 0.0;
  CGContextDrawImage(v23, v45, v10);
  CGImageRef v25 = CGBitmapContextCreateImage(v24);
  double v26 = v25;
  if (v25) {
    uint64_t v10 = v25;
  }
  CGContextRelease(v24);
LABEL_31:
  unint64_t v27 = CGBitmapContextCreate(0, v21, v22, 0x10uLL, 8 * v21, v18, 0x1105u);
  if (v27)
  {
    CGContextSetInterpolationQualityRange();
    v46.size.unint64_t width = (double)v21;
    v46.size.double height = (double)v22;
    v46.origin.CGFloat x = 0.0;
    v46.origin.CGFloat y = 0.0;
    CGContextDrawImage(v27, v46, v10);
    Data = CGBitmapContextGetData(v27);
    OutputPoppyProfileForRGBData = (const ColorSyncProfile *)ColorSyncCreateOutputPoppyProfileForRGBData();
    size_t v30 = OutputPoppyProfileForRGBData;
    if (OutputPoppyProfileForRGBData)
    {
      CFDataRef v31 = ColorSyncProfileCopyData(OutputPoppyProfileForRGBData, error);
      CFDataRef v32 = v31;
      if (v31)
      {
        if ((gIIODebugFlags & 0x8000300000) != 0)
        {
          CFIndex Length = CFDataGetLength(v31);
          ImageIOLog("COL IIO_ColorSyncCreateOutputPoppyProfileForRGBData returned poppy profile [%p] data: %ld bytes\n", v30, Length);
        }
        *a3 = MEMORY[0x18C11AC10](v32);
        CFRelease(v32);
      }
    }
    else
    {
      double v34 = CGImageGetColorSpace(v10);
      BOOL v35 = IIO_CGColorSpaceNameMatchesName(v34, v13);
      if ((gIIODebugFlags & 0x8000300000) != 0)
      {
        if (v35) {
          ImageIOLog("COL IIO_ColorSyncCreateOutputPoppyProfileForRGBData returned nil - original image is P3\n");
        }
        else {
          ImageIOLog("COL IIO_ColorSyncCreateOutputPoppyProfileForRGBData returned nil - original image is not P3\n");
        }
      }
      if ((gIIODebugFlags & 0x8000000000) != 0)
      {
        __filename = 0;
        int v36 = IIO_CreateOutputPoppyProfileForImage::tCount++;
        asprintf(&__filename, "/tmp/poppy-thumb_%d w=%ld, h=%ld, rb=%ld, bpc=16, cs=RGB, f=1, bo=16l, a=pl.br2", v36, v21, v22, 8 * v21);
        long long v37 = fopen(__filename, "w");
        if (v37)
        {
          fwrite(Data, v22, 8 * v21, v37);
          fclose(v37);
        }
        free(__filename);
      }
    }
    CGContextRelease(v27);
  }
  else
  {
    _cg_jpeg_mem_term("IIO_CreateOutputPoppyProfileForImage", 234, "*** ERROR: CGBitmapContextCreate returned NULL\n");
    size_t v30 = 0;
  }
  if (ThumbnailAtIndex) {
    CGImageRelease(ThumbnailAtIndex);
  }
  if (v26) {
    CGImageRelease(v26);
  }
  IIOColorSpace::~IIOColorSpace(&v42);
  return v30;
}

void sub_1887C21E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_ColorSpaceCreateCopyWithFlexGTCInfo()
{
  uint64_t v0 = CGColorSpaceCopyColorSyncProfile();
  if (!v0) {
    return 0;
  }
  uint64_t v1 = (const void *)v0;
  CopyWithFlexGTC = (const ColorSyncProfile *)ColorSyncProfileCreateCopyWithFlexGTC();
  if (CopyWithFlexGTC)
  {
    CFDataRef v3 = CopyWithFlexGTC;
    uint64_t v4 = 0;
    if (ColorSyncProfileVerify(CopyWithFlexGTC, 0, 0)) {
      uint64_t v4 = MEMORY[0x18C11AC00](v3, 0);
    }
    CFRelease(v3);
  }
  else
  {
    uint64_t v4 = 0;
  }
  CFRelease(v1);
  return v4;
}

uint64_t IIO_ColorSpaceAddToStream(CGColorSpace *a1, CFWriteStreamRef stream)
{
  buffer[5] = 0;
  *(_WORD *)&buffer[6] = 0;
  *(_DWORD *)&UInt8 buffer[8] = 0;
  strcpy(buffer, "ICC ");
  CFWriteStreamWrite(stream, buffer, 4);
  if (a1)
  {
    CFPropertyListRef v4 = CGColorSpaceCopyPropertyList(a1);
    if (v4)
    {
      BOOL v5 = v4;
      CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, kCFPropertyListXMLFormat_v1_0, 0, 0);
      if (Data)
      {
        CFDataRef v7 = Data;
        *(void *)&UInt8 buffer[4] = CFDataGetLength(Data);
        if (*(void *)&buffer[4])
        {
          CFWriteStreamWrite(stream, &buffer[4], 8);
          BytePtr = CFDataGetBytePtr(v7);
          CFWriteStreamWrite(stream, BytePtr, *(CFIndex *)&buffer[4]);
        }
        CFRelease(v7);
      }
      CFRelease(v5);
    }
  }
  if (!*(void *)&buffer[4]) {
    CFWriteStreamWrite(stream, &buffer[4], 8);
  }
  return 0;
}

CGColorSpaceRef IIO_ColorSpaceCreateFromStream(__CFReadStream *a1)
{
  *(void *)double v15 = 0;
  *(_DWORD *)UInt8 buffer = 0;
  CGColorSpaceRef v2 = 0;
  if (CFReadStreamRead(a1, buffer, 4) == 4 && *(_DWORD *)buffer == 541279049)
  {
    CGColorSpaceRef v2 = 0;
    if (CFReadStreamRead(a1, v15, 8) == 8 && *(uint64_t *)v15 >= 1)
    {
      CFErrorRef error = 0;
      CFPropertyListRef v4 = (UInt8 *)malloc_type_malloc(*(size_t *)v15, 0x47689F12uLL);
      if (v4)
      {
        BOOL v5 = v4;
        CFIndex v6 = CFReadStreamRead(a1, v4, *(CFIndex *)v15);
        if (*(void *)v15 == v6
          && (CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80],
              (CFDataRef v8 = CFDataCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5, v6, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0])) != 0))
        {
          CFDataRef v9 = v8;
          CFPropertyListRef v10 = CFPropertyListCreateWithData(v7, v8, 0, 0, &error);
          if (v10)
          {
            size_t v11 = v10;
            CGColorSpaceRef v2 = CGColorSpaceCreateWithPropertyList(v10);
            CFRelease(v11);
          }
          else
          {
            CGColorSpaceRef v2 = 0;
          }
          CFRelease(v9);
        }
        else
        {
          CGColorSpaceRef v2 = 0;
        }
        free(v5);
      }
      else
      {
        return 0;
      }
    }
  }
  return v2;
}

uint64_t IIO_ColorSpaceNameAddToStream(const __CFString *a1, CFWriteStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 0;
  if (!a1) {
    goto LABEL_6;
  }
  int Length = CFStringGetLength(a1);
  *(_DWORD *)UInt8 buffer = Length;
  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr && Length)
  {
    CFIndex v6 = (const UInt8 *)CStringPtr;
    CFWriteStreamWrite(stream, buffer, 4);
    CFWriteStreamWrite(stream, v6, *(unsigned int *)buffer);
    int Length = *(_DWORD *)buffer;
  }
  if (!Length) {
LABEL_6:
  }
    CFWriteStreamWrite(stream, buffer, 4);
  return 0;
}

CFStringRef IIO_ColorSpaceNameCreateFromStream(__CFReadStream *a1)
{
  *(_DWORD *)UInt8 buffer = 0;
  if (CFReadStreamRead(a1, buffer, 4) != 4 || *(_DWORD *)buffer == 0) {
    return 0;
  }
  CFPropertyListRef v4 = (UInt8 *)malloc_type_malloc(*(unsigned int *)buffer, 0x8DABDB9FuLL);
  CFIndex v5 = CFReadStreamRead(a1, v4, *(unsigned int *)buffer);
  if (v5 == *(unsigned int *)buffer) {
    CFStringRef v3 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, v5, 0x8000100u, 1u);
  }
  else {
    CFStringRef v3 = 0;
  }
  free(v4);
  return v3;
}

void IIOColorConverter::createConverterWithColorSpaces(IIOColorConverter *this, vImage_CGImageFormat *a2, vImage_CGImageFormat *a3, CGColorSpaceRef src, CGColorSpaceRef dst)
{
  vImage_Error error = 0;
  CFDataRef v8 = CGColorConversionInfoCreate(src, dst);
  if (v8)
  {
    CFDataRef v9 = v8;
    *((void *)this + 1) = vImageConverter_CreateWithCGColorConversionInfo(v8, a2, a3, 0, 0, &error);
    CFRelease(v9);
  }
}

void IIOColorConverter::IIOColorConverter(IIOColorConverter *this, vImage_CGImageFormat *a2, vImage_CGImageFormat *a3, CGColorSpace *a4, CGColorSpace *a5)
{
  *(void *)this = &unk_1ED4E40A0;
  *((void *)this + 1) = 0;
  IIOColorConverter::createConverterWithColorSpaces(this, a2, a3, a4, a5);
}

void IIOColorConverter::IIOColorConverter(IIOColorConverter *this, CGColorSpaceRef src, CGColorSpaceRef dst)
{
  *(void *)this = &unk_1ED4E40A0;
  *((void *)this + 1) = 0;
  *(void *)&v4.bitsPerComponent = 0x2000000008;
  v4.colorSpace = src;
  v4.bitmapInfo = 8198;
  memset(&v4.version, 0, 20);
  *(void *)&v3.bitsPerComponent = 0x2000000008;
  v3.colorSpace = dst;
  v3.bitmapInfo = 8198;
  memset(&v3.version, 0, 20);
  IIOColorConverter::createConverterWithColorSpaces(this, &v4, &v3, src, dst);
}

void IIOColorConverter::~IIOColorConverter(IIOColorConverter *this)
{
  *(void *)this = &unk_1ED4E40A0;
  uint64_t v1 = (vImageConverter *)*((void *)this + 1);
  if (v1) {
    vImageConverter_Release(v1);
  }
}

{
  uint64_t vars8;

  IIOColorConverter::~IIOColorConverter(this);

  JUMPOUT(0x18C11C0E0);
}

vImage_Error IIOColorConverter::colorConvert(IIOColorConverter *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  vImage_CGImageFormat v3 = (vImageConverter *)*((void *)this + 1);
  if (!v3) {
    return -50;
  }
  vImage_Error v4 = iio_vImageConvert_AnyToAny(v3, a2, a3, 0, 0x10u);
  vImage_Error v5 = v4;
  if (v4)
  {
    CFIndex v6 = IIO_vImageErrorString(v4);
    LogError("colorConvert", 521, "*** ERROR: vImageConvert_AnyToAny - %d - '%s'\n", v5, v6);
  }
  return v5;
}

uint64_t CGImageCreateFromIOSurface(__IOSurface *a1, const __CFDictionary *a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  IIOInitDebugFlags();
  memset(v29, 0, sizeof(v29));
  IIODictionary::IIODictionary((IIODictionary *)v29, a2);
  if (a1)
  {
    signed int PixelFormat = IOSurfaceGetPixelFormat(a1);
    char Alpha = IIO_IOSurfaceGetAlpha(a1);
    int Width = IOSurfaceGetWidth(a1);
    int Height = IOSurfaceGetHeight(a1);
    kdebug_trace();
    if ((gIIODebugFlags & 0x8000) != 0)
    {
      long long v34 = 0u;
      long long v35 = 0u;
      long long v32 = 0u;
      long long v33 = 0u;
      *(_OWORD *)__str = 0u;
      long long v31 = 0u;
      CFTypeRef v8 = IOSurfaceCopyValue(a1, (CFStringRef)*MEMORY[0x1E4F2F128]);
      char v27 = Alpha;
      memset(v28, 0, sizeof(v28));
      IIOString::IIOString((IIOString *)v28, v8);
      unsigned int v9 = PixelFormat >> 24;
      uint64_t v10 = MEMORY[0x1E4F14390];
      if (PixelFormat < 0) {
        int v11 = __maskrune(PixelFormat >> 24, 0x40000uLL);
      }
      else {
        int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
      }
      if (v11) {
        uint64_t v12 = v9;
      }
      else {
        uint64_t v12 = 46;
      }
      uint64_t v26 = v12;
      unsigned int v13 = PixelFormat << 8 >> 24;
      if (PixelFormat << 8 < 0) {
        int v14 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
      }
      else {
        int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
      }
      if (v14) {
        uint64_t v15 = v13;
      }
      else {
        uint64_t v15 = 46;
      }
      unsigned int v16 = (__int16)PixelFormat >> 8;
      if (PixelFormat << 16 < 0) {
        int v17 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
      }
      else {
        int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
      }
      if (v17) {
        uint64_t v18 = v16;
      }
      else {
        uint64_t v18 = 46;
      }
      if ((PixelFormat << 24) <= 0x7F000000) {
        int v19 = *(_DWORD *)(v10 + 4 * (char)PixelFormat + 60) & 0x40000;
      }
      else {
        int v19 = __maskrune((char)PixelFormat, 0x40000uLL);
      }
      if (v19) {
        uint64_t v20 = (char)PixelFormat;
      }
      else {
        uint64_t v20 = 46;
      }
      size_t v21 = (const char *)IIOString::utf8String((IIOString *)v28);
      size_t v22 = IIO_AlphaInfoString(v27);
      snprintf(__str, 0x60uLL, "<IOSurface: %p>  %dx%d '%c%c%c%c' '%s' %s", a1, Width, Height, v26, v15, v18, v20, v21, v22);
      if (v8) {
        CFRelease(v8);
      }
      IIOString::~IIOString((IIOString *)v28);
      if ((unsigned __int16)gIIODebugFlags >> 14) {
        ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateFromIOSurface", 0, __str, -1, a2);
      }
    }
    CFAbsoluteTimeGetCurrent();
    if (PixelFormat > 2016686641)
    {
      if (PixelFormat > 2019963439)
      {
        if (PixelFormat == 2019963440 || PixelFormat == 2019963442) {
LABEL_47:
        }
          operator new();
        int v24 = 2019963956;
LABEL_46:
        if (PixelFormat != v24) {
          operator new();
        }
        goto LABEL_47;
      }
      if (PixelFormat == 2016686642) {
        goto LABEL_47;
      }
      unsigned __int16 v23 = 13364;
    }
    else
    {
      if (PixelFormat <= 1647534391)
      {
        if (PixelFormat == 875704422) {
          goto LABEL_47;
        }
        int v24 = 875704438;
        goto LABEL_46;
      }
      if (PixelFormat == 1647534392 || PixelFormat == 1999843442) {
        operator new();
      }
      unsigned __int16 v23 = 12848;
    }
    int v24 = v23 | 0x78340000;
    goto LABEL_46;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v29);
  return 0;
}

void sub_1887C2EC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  MEMORY[0x18C11C0E0](v16, 0x10B1C403AEDC547);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageWasCreatedWithIOSurface(uint64_t a1)
{
  return IIO_CGImageWrapsIOSurface(a1, 0);
}

void IIOIOSurfaceWrapperBase::IIOIOSurfaceWrapperBase(IIOIOSurfaceWrapperBase *this, __IOSurface *a2, size_t WidthOfPlane, size_t HeightOfPlane, int a5, CGImageAlphaInfo a6, IIODictionary *a7)
{
  *(void *)this = &unk_1ED4B4230;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 8), 0);
  *((void *)this + 9) = a2;
  *((void *)this + 19) = 0;
  *((unsigned char *)this + 200) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
  *((_WORD *)this + 110) = -1;
  *((void *)this + 24) = 0;
  IOSurfaceIncrementUseCount(a2);
  IIOFrameBufferRetain(*((CFTypeRef *)this + 9));
  *((unsigned char *)this + 142) = 0;
  *((unsigned char *)this + 201) = 0;
  *((_DWORD *)this + 22) = a5;
  *((void *)this + 10) = IIO_IOSurfaceCopyColorSpace(*((__IOSurface **)this + 9));
  *((unsigned char *)this + 140) = IOSurfaceGetProtectionOptions() != 0;
  if (!WidthOfPlane) {
    int WidthOfPlane = IOSurfaceGetWidthOfPlane(*((IOSurfaceRef *)this + 9), 0);
  }
  *((void *)this + 12) = WidthOfPlane;
  if (!HeightOfPlane) {
    unsigned int HeightOfPlane = IOSurfaceGetHeightOfPlane(*((IOSurfaceRef *)this + 9), 0);
  }
  *((void *)this + 13) = HeightOfPlane;
  *((void *)this + 14) = IOSurfaceGetBytesPerRowOfPlane(*((IOSurfaceRef *)this + 9), 0);
  *((void *)this + 15) = IOSurfaceGetBytesPerElementOfPlane(*((IOSurfaceRef *)this + 9), 0);
  *((_DWORD *)this + 34) = a6;
  size_t PlaneCount = IOSurfaceGetPlaneCount(*((IOSurfaceRef *)this + 9));
  *((void *)this + 16) = PlaneCount;
  *((unsigned char *)this + 141) = 0;
  if (PlaneCount)
  {
    uint64_t v15 = 0;
    while (!IOSurfaceGetCompressionTypeOfPlane())
    {
      if ((unint64_t)++v15 >= *((void *)this + 16)) {
        goto LABEL_11;
      }
    }
    *((unsigned char *)this + 141) = 1;
  }
LABEL_11:
  *((unsigned char *)this + 208) = -1;
  *((_DWORD *)this + 53) = 0;
  *((_DWORD *)this + 54) = 0;
  if (!a7
    || (!IIODictionary::containsKey(a7, @"kCGImageComponentTypeRequest")
      ? (unsigned int Uint32ForKey = *((_DWORD *)this + 53))
      : (*((unsigned char *)this + 208) = 1,
         unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(a7, @"kCGImageComponentTypeRequest"),
         *((_DWORD *)this + 53) = Uint32ForKey),
        Uint32ForKey <= 6 ? (BOOL v17 = ((1 << Uint32ForKey) & 0x64) == 0) : (BOOL v17 = 1),
        v17))
  {
    *((_DWORD *)this + 53) = 1;
  }
  *((unsigned char *)this + 202) = -1;
  *((_DWORD *)this + 51) = 0;
  if (IIODictionary::containsKey(a7, @"CGImageAlphaInfo"))
  {
    *((unsigned char *)this + 202) = 1;
    uint64_t v18 = (uint64_t)IIODictionary::getUint32ForKey(a7, @"CGImageAlphaInfo");
    *((_DWORD *)this + 51) = v18;
    if (v18 > 5 || ((1 << v18) & 0x2A) == 0) {
      *((_DWORD *)this + 51) = _AlphaTogglePosition(v18);
    }
  }
  *((void *)this + 20) = 0;
}

void IIOIOSurfaceWrapperBase::completeSetup(IIOIOSurfaceWrapperBase *this, IIODictionary *a2, CFStringRef name)
{
  *((_DWORD *)this + 40) = *((_DWORD *)this + 40) & 0xFFFFFFE0 | *((_DWORD *)this + 41);
  if (name && !*((void *)this + 10))
  {
    vImage_Error v4 = CGColorSpaceCreateWithName(name);
    *((void *)this + 10) = v4;
    vImage_Error v5 = (__IOSurface *)*((void *)this + 9);
    IIO_IOSurfaceAddColorSpace(v5, v4);
  }
}

uint64_t IIOIOSurfaceWrapperBase::createImage(IIOIOSurfaceWrapperBase *this)
{
  return 0;
}

uint64_t IIOIOSurfaceWrapperBase::createBlockSetForCompressedSurface(uint64_t a1, double a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, void *a8)
{
  PixelCFStringRef Size = CGImageProviderGetPixelSize();
  uint64_t v15 = (void *)_ImageIO_Malloc(*(void *)(a1 + 96) * PixelSize * *(void *)(a1 + 104), 64, (memory_object_size_t *)(a1 + 176), (uint64_t)kImageMalloc_IOSurface_Data, 0, 0, 0);
  *(void *)(a1 + 168) = v15;
  if (v15)
  {
    if (*(_DWORD *)(a1 + 216) == 1) {
      size_t v16 = 8;
    }
    else {
      size_t v16 = 16;
    }
    CGContextRef v17 = CGBitmapContextCreate(v15, *(void *)(a1 + 96), *(void *)(a1 + 104), v16, *(void *)(a1 + 96) * PixelSize, *(CGColorSpaceRef *)(a1 + 80), *(_DWORD *)(a1 + 160));
    if (v17)
    {
      uint64_t v18 = v17;
      CGContextErase();
      CGContextSetRGBStrokeColor(v18, 1.0, 0.0, 0.0, 1.0);
      unint64_t v19 = *(void *)(a1 + 96);
      if (v19 >= *(void *)(a1 + 104)) {
        unint64_t v19 = *(void *)(a1 + 104);
      }
      double v20 = (double)v19;
      CGContextSetLineWidth(v18, (double)v19 / 20.0);
      CGContextAddArc(v18, (double)(*(void *)(a1 + 96) >> 1), (double)(*(void *)(a1 + 104) >> 1), v20 / 6.0, 3437.74677, -3437.74677, 0);
      CGContextStrokePath(v18);
      CGContextFlush(v18);
      CFRelease(v18);
    }
    CGImageBlockCreate();
    uint64_t v21 = CGImageBlockSetCreate();
  }
  else
  {
    uint64_t v21 = 0;
  }
  *a8 = (*(uint64_t (**)(uint64_t, void, double, double, double, double))(*(void *)a1 + 64))(a1, 0, a2, a3, a4, a5);
  return v21;
}

const char *IIOIOSurfaceWrapperBase::ImageBlockReleaseNonCached(const char *result, const void *a2)
{
  if ((gIIODebugFlags & 0xC00) != 0) {
    uint64_t result = IIO_ImageBlockReleased(result, a2);
  }
  if (a2)
  {
    unint64_t Data = CGImageBlockGetData();
    return (const char *)_ImageIO_Free(Data, 0);
  }
  return result;
}

const char *IIOIOSurfaceWrapperBase::ImageBlockSetReleaseInfo(const char *this, void *a2)
{
  if ((gIIODebugFlags & 0xC00) != 0) {
    return IIO_ImageBlockSetReleased(this);
  }
  return this;
}

unint64_t IIOIOSurfaceWrapperBase::packDebugInfo(IIOIOSurfaceWrapperBase *this, CGRect a2, uint64_t a3)
{
  unint64_t v3 = (*((_DWORD *)this + 54) << 28) | (unint64_t)(a3 << 32) | ((unint64_t)(*((_DWORD *)this + 51) & 0xF) << 24);
  if (*((unsigned char *)this + 142)) {
    v3 |= 0x400000uLL;
  }
  if (*((unsigned char *)this + 202) == 1) {
    v3 |= 0x100000uLL;
  }
  if (*((unsigned char *)this + 208) == 1) {
    v3 |= 0x40000uLL;
  }
  if (*((unsigned char *)this + 140)) {
    v3 |= 0x10000uLL;
  }
  if (*((unsigned char *)this + 141)) {
    v3 |= 0x4000uLL;
  }
  if (a2.origin.y > 0.0 || a2.origin.x > 0.0) {
    v3 |= 0x100uLL;
  }
  if (a2.size.width < (double)*((unint64_t *)this + 12)
    || a2.size.height < (double)*((unint64_t *)this + 13))
  {
    v3 |= 0x40uLL;
  }
  if (*((unsigned char *)this + 201)) {
    return v3 | 0x10;
  }
  else {
    return v3;
  }
}

uint64_t IIOIOSurfaceWrapperBase::preCopyBlockSet(IIOIOSurfaceWrapperBase *this, int a2, CGRect a3, CGSize a4, IIODictionary *a5)
{
  *((unsigned char *)this + 200) = 0;
  if (a2 == 8)
  {
    CFStringRef v7 = (const __CFString *)*MEMORY[0x1E4F1DD38];
    if (IIODictionary::containsKey(a5, (const __CFString *)*MEMORY[0x1E4F1DD38]))
    {
      CFStringRef v8 = (const __CFString *)*MEMORY[0x1E4F1DD30];
      CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a5, v7);
      if (CFEqual(v8, ObjectForKey)) {
        *((unsigned char *)this + 200) = 1;
      }
    }
  }
  return 0;
}

uint64_t IIOIOSurfaceWrapperBase::postCopyBlockSet(uint64_t this)
{
  *(void *)(this + 144) = 0;
  *(void *)(this + 152) = 0;
  *(void *)(this + 168) = 0;
  *(void *)(this + 176) = 0;
  *(_DWORD *)(this + 184) = 0;
  return this;
}

uint64_t IIOIOSurfaceWrapperBase::CopyImageBlockSetWithOptionsNoOp(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 140)) {
    LogError("CopyImageBlockSetWithOptionsNoOp", 561, "*** ERROR: cannot copy data from protected IOSurface\n");
  }
  return 0;
}

const char *IIOIOSurfaceWrapperBase::ImageBlockSetReleaseInfoNoCopy(const char *this, void *a2)
{
  if ((gIIODebugFlags & 0xC00) != 0) {
    return IIO_ImageBlockSetReleased(this);
  }
  return this;
}

const char *IIOIOSurfaceWrapperBase::ImageBlockReleaseNoCopy(const char *result, const void *a2)
{
  CGColorSpaceRef v2 = result;
  if ((gIIODebugFlags & 0xC00) != 0) {
    uint64_t result = IIO_ImageBlockReleased(result, a2);
  }
  if (v2)
  {
    unint64_t v3 = (__IOSurface *)*((void *)v2 + 9);
    return (const char *)IOSurfaceUnlock(v3, 1u, 0);
  }
  return result;
}

__IOSurface *IIOIOSurfaceWrapperBase::CopyIOSurface(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  IIOPackCopyCallbackInfo(a3);
  CGImageProviderGetBitmapInfo();
  kdebug_trace();
  memset(v7, 0, sizeof(v7));
  IIODictionary::IIODictionary((IIODictionary *)v7, a3);
  IIOFrameBufferRetain(*(CFTypeRef *)(a1 + 72));
  vImage_Error v5 = *(__IOSurface **)(a1 + 72);
  IOSurfaceGetWidth(v5);
  IOSurfaceGetHeight(v5);
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v7);
  return v5;
}

void sub_1887C3840(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void IIOIOSurfaceWrapper::IIOIOSurfaceWrapper(IIOIOSurfaceWrapper *this, __IOSurface *a2, size_t a3, size_t a4, int a5, CGImageAlphaInfo a6, IIODictionary *a7)
{
  IIOIOSurfaceWrapperBase::IIOIOSurfaceWrapperBase(this, a2, a3, a4, a5, a6, a7);
  *(void *)CFStringRef v7 = &unk_1ED4E4BC8;
  IIOIOSurfaceWrapper::completeSetup(v7, v8, v9);
}

void sub_1887C38A0(_Unwind_Exception *a1)
{
  IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(v1);
  _Unwind_Resume(a1);
}

void IIOIOSurfaceWrapper::~IIOIOSurfaceWrapper(IIOIOSurfaceWrapper *this)
{
  IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(this);

  JUMPOUT(0x18C11C0E0);
}

void IIOIOSurfaceWrapper::completeSetup(IIOIOSurfaceWrapper *this, IIODictionary *a2, const __CFString *a3)
{
  uint64_t v4 = 136;
  if (*((unsigned char *)this + 202) == 1) {
    uint64_t v4 = 204;
  }
  int v5 = *(_DWORD *)((char *)this + v4);
  unsigned int v6 = v5 & 0xFFFFFFFD;
  int v7 = *((_DWORD *)this + 22);
  if (v7 <= 1278226487)
  {
    if (v7 <= 843264309)
    {
      if (v7 != 843264056)
      {
        if (v7 == 843264104)
        {
          BOOL v8 = v6 == 1 || v5 == 5;
          int v9 = 5;
          uint64_t v10 = (const __CFString **)MEMORY[0x1E4F1DBB8];
          goto LABEL_46;
        }
        goto LABEL_54;
      }
      BOOL v12 = v6 == 1 || v5 == 5;
      *((_DWORD *)this + 54) = 1;
      unsigned int v13 = (const __CFString **)MEMORY[0x1E4F1DC00];
LABEL_38:
      CFStringRef v14 = *v13;
      if (!v12) {
        int v5 = 1;
      }
      *((_DWORD *)this + 41) = v5;
      goto LABEL_50;
    }
    if (v7 == 843264310)
    {
      BOOL v8 = v6 == 1 || v5 == 5;
      int v9 = 2;
      uint64_t v10 = (const __CFString **)MEMORY[0x1E4F1DC00];
      goto LABEL_46;
    }
    int v11 = 1111970369;
LABEL_23:
    if (v7 != v11) {
      goto LABEL_54;
    }
    BOOL v12 = v6 == 1 || v5 == 5;
    *((_DWORD *)this + 54) = 1;
    unsigned int v13 = (const __CFString **)MEMORY[0x1E4F1DC98];
    goto LABEL_38;
  }
  if (v7 <= 1380411456)
  {
    if (v7 == 1278226488)
    {
      *((_DWORD *)this + 54) = 1;
      CFStringRef v14 = (const __CFString *)*MEMORY[0x1E4F1DC00];
      *((_DWORD *)this + 41) = 0;
LABEL_50:
      *((unsigned char *)this + 142) = 1;
      goto LABEL_51;
    }
    int v11 = 1380401729;
    goto LABEL_23;
  }
  switch(v7)
  {
    case 1815491698:
      BOOL v8 = v6 == 1 || v5 == 5;
      int v9 = 2;
      goto LABEL_32;
    case 1815162994:
      *((_DWORD *)this + 54) = 6;
      CFStringRef v14 = (const __CFString *)*MEMORY[0x1E4F1DBE8];
      *((_DWORD *)this + 41) = 6;
      goto LABEL_51;
    case 1380411457:
      BOOL v8 = v6 == 1 || v5 == 5;
      int v9 = 5;
LABEL_32:
      uint64_t v10 = (const __CFString **)MEMORY[0x1E4F1DC98];
LABEL_46:
      *((_DWORD *)this + 54) = v9;
      CFStringRef v14 = *v10;
      if (v8) {
        int v15 = v5;
      }
      else {
        int v15 = 1;
      }
      *((_DWORD *)this + 41) = v15;
      goto LABEL_50;
  }
LABEL_54:
  unsigned int v16 = v7 >> 24;
  uint64_t v17 = MEMORY[0x1E4F14390];
  if (v7 < 0)
  {
    int v18 = __maskrune(v16, 0x40000uLL);
    int v7 = *((_DWORD *)this + 22);
  }
  else
  {
    int v18 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v16 + 60) & 0x40000;
  }
  if (v18) {
    uint64_t v19 = (v7 >> 24);
  }
  else {
    uint64_t v19 = 46;
  }
  unsigned int v20 = v7 << 8 >> 24;
  if (v7 << 8 < 0)
  {
    int v21 = __maskrune(v20, 0x40000uLL);
    int v7 = *((_DWORD *)this + 22);
  }
  else
  {
    int v21 = *(_DWORD *)(v17 + 4 * v20 + 60) & 0x40000;
  }
  if (v21) {
    uint64_t v22 = (v7 << 8 >> 24);
  }
  else {
    uint64_t v22 = 46;
  }
  unsigned int v23 = (__int16)v7 >> 8;
  if (v7 << 16 < 0)
  {
    int v24 = __maskrune(v23, 0x40000uLL);
    int v7 = *((_DWORD *)this + 22);
  }
  else
  {
    int v24 = *(_DWORD *)(v17 + 4 * v23 + 60) & 0x40000;
  }
  if (v24) {
    uint64_t v25 = ((__int16)v7 >> 8);
  }
  else {
    uint64_t v25 = 46;
  }
  if ((v7 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v17 + 4 * (char)v7 + 60) & 0x40000) != 0) {
      goto LABEL_74;
    }
LABEL_76:
    uint64_t v26 = 46;
    goto LABEL_77;
  }
  if (!__maskrune((char)v7, 0x40000uLL)) {
    goto LABEL_76;
  }
LABEL_74:
  uint64_t v26 = *((char *)this + 88);
LABEL_77:
  LogError("completeSetup", 741, "*** pixelformat '%c%c%c%c' not handled\n", v19, v22, v25, v26);
  CFStringRef v14 = 0;
LABEL_51:

  IIOIOSurfaceWrapperBase::completeSetup(this, a2, v14);
}

uint64_t IIOIOSurfaceWrapper::createImage(IIOIOSurfaceWrapper *this)
{
  int v2 = *((_DWORD *)this + 22);
  if (v2 <= 1278226487)
  {
    if (v2 > 843264309)
    {
      BOOL v3 = v2 == 843264310;
      int v4 = 1111970369;
    }
    else
    {
      BOOL v3 = v2 == 843264056;
      int v4 = 843264104;
    }
  }
  else if (v2 <= 1380411456)
  {
    BOOL v3 = v2 == 1278226488;
    int v4 = 1380401729;
  }
  else
  {
    BOOL v3 = v2 == 1380411457 || v2 == 1815491698;
    int v4 = 1815162994;
  }
  if (!v3 && v2 != v4)
  {
    unsigned int v7 = v2 >> 24;
    uint64_t v8 = MEMORY[0x1E4F14390];
    if (v2 < 0)
    {
      int v9 = __maskrune(v7, 0x40000uLL);
      int v2 = *((_DWORD *)this + 22);
    }
    else
    {
      int v9 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v7 + 60) & 0x40000;
    }
    if (v9) {
      uint64_t v10 = (v2 >> 24);
    }
    else {
      uint64_t v10 = 46;
    }
    unsigned int v11 = v2 << 8 >> 24;
    if (v2 << 8 < 0)
    {
      int v12 = __maskrune(v11, 0x40000uLL);
      int v2 = *((_DWORD *)this + 22);
    }
    else
    {
      int v12 = *(_DWORD *)(v8 + 4 * v11 + 60) & 0x40000;
    }
    if (v12) {
      uint64_t v13 = (v2 << 8 >> 24);
    }
    else {
      uint64_t v13 = 46;
    }
    unsigned int v14 = (__int16)v2 >> 8;
    if (v2 << 16 < 0)
    {
      int v15 = __maskrune(v14, 0x40000uLL);
      int v2 = *((_DWORD *)this + 22);
    }
    else
    {
      int v15 = *(_DWORD *)(v8 + 4 * v14 + 60) & 0x40000;
    }
    if (v15) {
      uint64_t v16 = ((__int16)v2 >> 8);
    }
    else {
      uint64_t v16 = 46;
    }
    if ((v2 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v8 + 4 * (char)v2 + 60) & 0x40000) != 0) {
        goto LABEL_39;
      }
    }
    else if (__maskrune((char)v2, 0x40000uLL))
    {
LABEL_39:
      uint64_t v17 = *((char *)this + 88);
LABEL_42:
      _cg_jpeg_mem_term("createImage", 771, "    CGImageCreateFromIOSurface -- unsupported pixelformat: '%c%c%c%c'\n", v10, v13, v16, v17);
      return 0;
    }
    uint64_t v17 = 46;
    goto LABEL_42;
  }

  return IIOIOSurfaceWrapper::createImageWithImageProvider(this);
}

uint64_t IIOIOSurfaceWrapper::createImageWithImageProvider(IIOIOSurfaceWrapper *this)
{
  v12[2] = 0;
  v12[3] = 2;
  int v2 = IIOIOSurfaceWrapperBase::CopyImageBlockSetWithOptionsNoOp;
  if (!*((unsigned char *)this + 140)) {
    int v2 = IIOIOSurfaceWrapper::CopyImageBlockSetWithOptions;
  }
  v12[4] = v2;
  void v12[5] = IIOIOSurfaceWrapperBase::CopyIOSurface;
  v12[6] = IIOIOSurfaceWrapperBase::ReleaseInfo;
  v12[0] = 0;
  v12[1] = 0;
  IIODictionary::IIODictionary((IIODictionary *)v12);
  if (*((_DWORD *)this + 54) == 6)
  {
    IIONumber::IIONumber((IIONumber *)v10, 204806);
    IIODictionary::setObjectForKey((IIODictionary *)v12, value, (const __CFString *)*MEMORY[0x1E4F1DD80]);
    IIONumber::~IIONumber((IIONumber *)v10);
  }
  else
  {
    int v3 = *((_DWORD *)this + 41) - 1;
    if (v3 < 6) {
      IIODictionary::setObjectForKey((IIODictionary *)v12, (const void *)*MEMORY[0x1E4F1CFD0], **((const __CFString ***)&unk_1E53CCE58 + v3));
    }
  }
  int v4 = (CGColorSpace *)*((void *)this + 10);
  CFStringRef v5 = (const __CFString *)*MEMORY[0x1E4F1DC98];
  v9[0] = (CGColorSpaceRef)&unk_1ED4DFD58;
  unsigned int v6 = CGColorSpaceCreateWithName(v5);
  v9[1] = v6;
  if (!v4) {
    int v4 = v6;
  }
  if (CGImageProviderCreate())
  {
    CGImageProviderSetProperty();
    v10[0] = 0;
    v10[1] = 0;
    xpc_object_t value = 0;
    IIONumber::IIONumber((IIONumber *)v10, *((_DWORD *)this + 22));
    CGImageProviderSetProperty();
    uint64_t v7 = CGImageCreateWithImageProvider();
    CGImageProviderRelease();
    if (!*((void *)this + 10)) {
      IIO_IOSurfaceAddColorSpace(*((__IOSurface **)this + 9), v4);
    }
    IIONumber::~IIONumber((IIONumber *)v10);
  }
  else
  {
    uint64_t v7 = 0;
  }
  IIOColorSpace::~IIOColorSpace(v9);
  IIODictionary::~IIODictionary((IIODictionary *)v12);
  return v7;
}

void sub_1887C4030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOIOSurfaceWrapper::CopyImageBlockSetWithOptions(uint64_t a1, uint64_t a2, __CFDictionary *a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7, double a8, double a9)
{
  memset(v37, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)v37, a3);
  uint64_t v18 = *(int *)(a1 + 216);
  IIOPackCopyCallbackInfo(a3);
  CGImageProviderGetBitmapInfo();
  kdebug_trace();
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    int v20 = *(_DWORD *)(a1 + 88);
    unsigned int v21 = v20 >> 24;
    uint64_t v22 = MEMORY[0x1E4F14390];
    if (v20 < 0) {
      int v23 = __maskrune(v20 >> 24, 0x40000uLL);
    }
    else {
      int v23 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v21 + 60) & 0x40000;
    }
    if (v23) {
      uint64_t v24 = v21;
    }
    else {
      uint64_t v24 = 46;
    }
    unsigned int v25 = v20 << 8 >> 24;
    if (v20 << 8 < 0) {
      int v26 = __maskrune(v20 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v26 = *(_DWORD *)(v22 + 4 * v25 + 60) & 0x40000;
    }
    if (v26) {
      uint64_t v27 = v25;
    }
    else {
      uint64_t v27 = 46;
    }
    unsigned int v28 = (__int16)v20 >> 8;
    if (v20 << 16 < 0) {
      int v29 = __maskrune((__int16)v20 >> 8, 0x40000uLL);
    }
    else {
      int v29 = *(_DWORD *)(v22 + 4 * v28 + 60) & 0x40000;
    }
    if ((v20 << 24) <= 0x7F000000) {
      int v30 = *(_DWORD *)(v22 + 4 * (char)v20 + 60) & 0x40000;
    }
    else {
      int v30 = __maskrune((char)v20, 0x40000uLL);
    }
    if (v29) {
      uint64_t v31 = v28;
    }
    else {
      uint64_t v31 = 46;
    }
    if (v30) {
      uint64_t v32 = (char)v20;
    }
    else {
      uint64_t v32 = 46;
    }
    ImageIOLog("S   CopyImageBlockSetWithOptions-SURF: {%g, %g, %g, %g} {%g, %g} '%c%c%c%c' %s\n", a4, a5, a6, a7, a8, a9, v24, v27, v31, v32, off_1E53CCE00[v18]);
  }
  uint64_t v36 = 0;
  if (!*(unsigned char *)(a1 + 141))
  {
    switch((int)v18)
    {
      case 1:
        uint64_t v33 = IIOIOSurfaceWrapper::copyImageBlockSetWithOptions8Bit(a1, a2, (IIODictionary *)v37, &v36, a4, a5, a6, a7, a8, a9);
        goto LABEL_29;
      case 2:
      case 5:
        uint64_t v33 = IIOIOSurfaceWrapper::copyImageBlockSetWithOptions16Bit((unsigned char *)a1, a2, (uint64_t)v37, &v36, a4, a5, a6, a7, a8, a9);
        goto LABEL_29;
      case 6:
        uint64_t v33 = IIOIOSurfaceWrapper::copyImageBlockSetWithOptions10Bit(a1, a4, a5, a6, a7, a8, a9, a2, (uint64_t)v37, &v36);
        goto LABEL_29;
      default:
        LogError("CopyImageBlockSetWithOptions", 1687, "*** unsupported componentType '%s' (%d)\n", gComponentString[v18], v18);
        goto LABEL_35;
    }
  }
  uint64_t v33 = IIOIOSurfaceWrapperBase::createBlockSetForCompressedSurface(a1, a4, a5, a6, a7, a2, v19, &v36);
LABEL_29:
  uint64_t v34 = v33;
  if (v33)
  {
    CGImageBlockSetGetRect();
  }
  else
  {
LABEL_35:
    _cg_jpeg_mem_term("CopyImageBlockSetWithOptions", 1697, "*** ERROR: CopyImageBlockSetWithOptions returned NULL\n");
    uint64_t v34 = 0;
  }
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v37);
  return v34;
}

void sub_1887C43EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOIOSurfaceWrapper::copyImageBlockSetNoCopy(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  kern_return_t v8;
  uint64_t result;
  CGRect v10;
  CGRect v11;

  v11.size.double height = a5;
  v11.size.unint64_t width = a4;
  v10.size.unint64_t width = (double)*(unint64_t *)(a1 + 96);
  v10.size.double height = (double)*(unint64_t *)(a1 + 104);
  v10.origin.CGFloat x = 0.0;
  v10.origin.CGFloat y = 0.0;
  v11.origin.CGFloat x = a2;
  v11.origin.CGFloat y = a3;
  CGRectIntersection(v10, v11);
  uint64_t v8 = IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
  uint64_t result = 0;
  if (!v8)
  {
    IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(a1 + 72));
    CGImageBlockCreate();
    return CGImageBlockSetCreate();
  }
  return result;
}

vImage_Error IIOIOSurfaceWrapper::copy_BGRA_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  int v12 = 50331906;
  int v11 = 50462976;
  if (*((unsigned char *)this + 200)) {
    uint64_t v7 = &v11;
  }
  else {
    uint64_t v7 = &v12;
  }
  vImage_Error v8 = vImagePermuteChannels_ARGB8888(a2, a3, (const uint8_t *)v7, 0x10u);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v9 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_BGRA_8bit", (v9 - Current) * 1000.0);
  }
  return v8;
}

vImage_Error IIOIOSurfaceWrapper::copy_RGBA_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  int v12 = 50331906;
  int v11 = 50462976;
  if (*((unsigned char *)this + 200)) {
    uint64_t v7 = &v12;
  }
  else {
    uint64_t v7 = &v11;
  }
  vImage_Error v8 = vImagePermuteChannels_ARGB8888(a2, a3, (const uint8_t *)v7, 0x10u);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v9 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_RGBA_8bit", (v9 - Current) * 1000.0);
  }
  return v8;
}

uint64_t IIOIOSurfaceWrapper::copy_L008_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (a2->rowBytes >= a3->rowBytes) {
    rowunint64_t Bytes = a3->rowBytes;
  }
  else {
    rowunint64_t Bytes = a2->rowBytes;
  }
  if (a3->height)
  {
    data = (char *)a3->data;
    vImage_Error v8 = (char *)a2->data;
    unsigned int v9 = 1;
    do
    {
      memcpy(data, v8, rowBytes);
      v8 += a2->rowBytes;
      data += a3->rowBytes;
    }
    while (a3->height > v9++);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v11 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_L008_8bit", (v11 - Current) * 1000.0);
  }
  return 0;
}

uint64_t IIOIOSurfaceWrapper::copy_LA08_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (a2->rowBytes >= a3->rowBytes) {
    rowunint64_t Bytes = a3->rowBytes;
  }
  else {
    rowunint64_t Bytes = a2->rowBytes;
  }
  if (a3->height)
  {
    data = (char *)a3->data;
    vImage_Error v8 = (char *)a2->data;
    unsigned int v9 = 1;
    do
    {
      memcpy(data, v8, rowBytes);
      v8 += a2->rowBytes;
      data += a3->rowBytes;
    }
    while (a3->height > v9++);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v11 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_LA08_8bit", (v11 - Current) * 1000.0);
  }
  return 0;
}

vImage_Error IIOIOSurfaceWrapper::copy_l64r_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  *(_DWORD *)backgroundColor = 0;
  *(_DWORD *)permuteMap = 50462976;
  vImage_Error v6 = vImageConvert_ARGB16UToARGB8888(a2, a3, permuteMap, 0, backgroundColor, 0x10u);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_l64r_8bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

vImage_Error IIOIOSurfaceWrapper::copy_RGhA_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  vImage_Error v6 = vImageConvert_Planar16FtoPlanar8(a2, a3, 0x10u);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_RGhA_8bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

vImage_Error IIOIOSurfaceWrapper::copy_2C16_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  vImage_Error v6 = vImageConvert_Planar16UtoPlanar8_dithered(a2, a3, 0, 0x10u);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_2C16_8bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

vImage_Error IIOIOSurfaceWrapper::copy_2C0h_8bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  vImage_Error v6 = vImageConvert_Planar16FtoPlanar8(a2, a3, 0x10u);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_2C0h_8bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

uint64_t IIOIOSurfaceWrapper::copyImageBlockSet_8bit(uint64_t a1, double a2, double a3, double a4, double a5)
{
  long long v33 = xmmword_1ED4F0C80;
  long long v32 = xmmword_1ED4F0C90;
  if (IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0)) {
    goto LABEL_32;
  }
  BaseAddress = (IIOIOSurfaceWrapper *)IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(a1 + 72));
  if (!BaseAddress)
  {
    if (*(unsigned char *)(a1 + 140)) {
      int v15 = "YES";
    }
    else {
      int v15 = "NO";
    }
    _cg_jpeg_mem_term("copyImageBlockSet_8bit", 1037, "*** IOSurfaceGetBaseAddress returned NULL -- (protected: %s)\n", v15);
    goto LABEL_12;
  }
  size_t v11 = *(void *)(a1 + 112);
  v31.data = (char *)BaseAddress
           + (unint64_t)(a2 * (double)*(unint64_t *)(a1 + 120))
           + (unint64_t)(a3 * (double)v11);
  v31.double height = (unint64_t)a5;
  v31.unint64_t width = (unint64_t)a4;
  v31.rowunint64_t Bytes = v11;
  dest.data = *(void **)(a1 + 168);
  dest.double height = (unint64_t)a5;
  size_t v12 = *(unsigned int *)(a1 + 184);
  dest.unint64_t width = (unint64_t)a4;
  dest.rowunint64_t Bytes = v12;
  int v13 = *(_DWORD *)(a1 + 88);
  if (v13 > 1278226487)
  {
    if (v13 <= 1380411456)
    {
      if (v13 != 1278226488)
      {
        if (v13 == 1380401729)
        {
          int v14 = IIOIOSurfaceWrapper::copy_RGBA_8bit((IIOIOSurfaceWrapper *)a1, &v31, &dest);
          goto LABEL_30;
        }
        goto LABEL_34;
      }
      IIOIOSurfaceWrapper::copy_L008_8bit(BaseAddress, &v31, &dest);
      goto LABEL_27;
    }
    if (v13 == 1380411457)
    {
      int v14 = IIOIOSurfaceWrapper::copy_RGhA_8bit(BaseAddress, &v31, &dest);
      goto LABEL_30;
    }
    if (v13 == 1815491698)
    {
      int v14 = IIOIOSurfaceWrapper::copy_l64r_8bit(BaseAddress, &v31, &dest);
      goto LABEL_30;
    }
LABEL_34:
    unsigned int v18 = v13 >> 24;
    uint64_t v19 = MEMORY[0x1E4F14390];
    if (v13 < 0)
    {
      int v20 = __maskrune(v18, 0x40000uLL);
      int v13 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      int v20 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v18 + 60) & 0x40000;
    }
    if (v20) {
      uint64_t v21 = (v13 >> 24);
    }
    else {
      uint64_t v21 = 46;
    }
    unsigned int v22 = v13 << 8 >> 24;
    if (v13 << 8 < 0)
    {
      int v23 = __maskrune(v22, 0x40000uLL);
      int v13 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      int v23 = *(_DWORD *)(v19 + 4 * v22 + 60) & 0x40000;
    }
    if (v23) {
      uint64_t v24 = (v13 << 8 >> 24);
    }
    else {
      uint64_t v24 = 46;
    }
    unsigned int v25 = (__int16)v13 >> 8;
    if (v13 << 16 < 0)
    {
      int v26 = __maskrune(v25, 0x40000uLL);
      int v13 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      int v26 = *(_DWORD *)(v19 + 4 * v25 + 60) & 0x40000;
    }
    if (v26) {
      uint64_t v27 = ((__int16)v13 >> 8);
    }
    else {
      uint64_t v27 = 46;
    }
    if ((v13 << 24) <= 0x7F000000) {
      int v28 = *(_DWORD *)(v19 + 4 * (char)v13 + 60) & 0x40000;
    }
    else {
      int v28 = __maskrune((char)v13, 0x40000uLL);
    }
    if (v28) {
      uint64_t v29 = *(char *)(a1 + 88);
    }
    else {
      uint64_t v29 = 46;
    }
    LogError("copyImageBlockSet_8bit", 1084, "*** pixelFormat '%c%c%c%c' not supported\n", v21, v24, v27, v29);
LABEL_12:
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
LABEL_32:
    _ImageIO_Free(*(void *)(a1 + 168), *(void *)(a1 + 176));
    uint64_t result = 0;
    *(void *)(a1 + 168) = 0;
    return result;
  }
  if (v13 <= 843264309)
  {
    if (v13 != 843264056)
    {
      if (v13 == 843264104)
      {
        int v14 = IIOIOSurfaceWrapper::copy_2C0h_8bit(BaseAddress, &v31, &dest);
LABEL_30:
        int v16 = v14;
        goto LABEL_31;
      }
      goto LABEL_34;
    }
    IIOIOSurfaceWrapper::copy_LA08_8bit(BaseAddress, &v31, &dest);
LABEL_27:
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
    goto LABEL_33;
  }
  if (v13 == 843264310)
  {
    int v14 = IIOIOSurfaceWrapper::copy_2C16_8bit(BaseAddress, &v31, &dest);
    goto LABEL_30;
  }
  if (v13 != 1111970369) {
    goto LABEL_34;
  }
  int v16 = IIOIOSurfaceWrapper::copy_BGRA_8bit((IIOIOSurfaceWrapper *)a1, &v31, &dest);
  if (*(unsigned char *)(a1 + 200) && *(_DWORD *)(a1 + 136) == 3) {
    int v16 = vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
  }
LABEL_31:
  IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
  if (v16) {
    goto LABEL_32;
  }
LABEL_33:
  v31.data = (void *)CGImageBlockCreate();
  return CGImageBlockSetCreate();
}

uint64_t IIOIOSurfaceWrapper::copy_RGBA_10bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (a2->rowBytes >= a3->rowBytes) {
    rowunint64_t Bytes = a3->rowBytes;
  }
  else {
    rowunint64_t Bytes = a2->rowBytes;
  }
  if (a3->height)
  {
    data = (char *)a3->data;
    vImage_Error v8 = (char *)a2->data;
    unsigned int v9 = 1;
    do
    {
      memcpy(data, v8, rowBytes);
      v8 += a2->rowBytes;
      data += a3->rowBytes;
    }
    while (a3->height > v9++);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v11 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_RGBA_10bit", (v11 - Current) * 1000.0);
  }
  return 0;
}

uint64_t IIOIOSurfaceWrapper::copyImageBlockSet_10bit(uint64_t a1, double a2, double a3, double a4, double a5)
{
  long long v41 = xmmword_1ED4F0C80;
  long long v40 = xmmword_1ED4F0C90;
  if (IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0)) {
    goto LABEL_34;
  }
  BaseAddress = (IIOIOSurfaceWrapper *)IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(a1 + 72));
  if (!BaseAddress)
  {
    if (*(unsigned char *)(a1 + 140)) {
      int v15 = "YES";
    }
    else {
      int v15 = "NO";
    }
    _cg_jpeg_mem_term("copyImageBlockSet_10bit", 1152, "*** IOSurfaceGetBaseAddress returned NULL -- (protected: %s)\n", v15);
    goto LABEL_33;
  }
  size_t v11 = *(void *)(a1 + 112);
  v39.data = (char *)BaseAddress
           + (unint64_t)(a2 * (double)*(unint64_t *)(a1 + 120))
           + (unint64_t)(a3 * (double)v11);
  v39.double height = (unint64_t)a5;
  v39.unint64_t width = (unint64_t)a4;
  v39.rowunint64_t Bytes = v11;
  v38.data = *(void **)(a1 + 168);
  v38.double height = (unint64_t)a5;
  size_t v12 = *(unsigned int *)(a1 + 184);
  v38.unint64_t width = (unint64_t)a4;
  v38.rowunint64_t Bytes = v12;
  int v13 = *(_DWORD *)(a1 + 88);
  if (v13 == 1815162994)
  {
    IIOIOSurfaceWrapper::copy_RGBA_10bit(BaseAddress, &v39, &v38);
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
    v39.data = (void *)CGImageBlockCreate();
    return CGImageBlockSetCreate();
  }
  unsigned int v16 = v13 >> 24;
  if (v13 < 0)
  {
    int v17 = __maskrune(v16, 0x40000uLL);
    int v13 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    int v17 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v16 + 60) & 0x40000;
  }
  if (v17) {
    uint64_t v18 = (v13 >> 24);
  }
  else {
    uint64_t v18 = 46;
  }
  unsigned int v19 = v13 << 8 >> 24;
  if (v13 << 8 < 0)
  {
    int v20 = __maskrune(v19, 0x40000uLL);
    int v13 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    int v20 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v19 + 60) & 0x40000;
  }
  if (v20) {
    uint64_t v21 = (v13 << 8 >> 24);
  }
  else {
    uint64_t v21 = 46;
  }
  unsigned int v22 = (__int16)v13 >> 8;
  if (v13 << 16 < 0)
  {
    int v23 = __maskrune(v22, 0x40000uLL);
    int v13 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    int v23 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v22 + 60) & 0x40000;
  }
  if (v23) {
    uint64_t v24 = ((__int16)v13 >> 8);
  }
  else {
    uint64_t v24 = 46;
  }
  if ((v13 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v13 + 60) & 0x40000) != 0) {
      goto LABEL_29;
    }
LABEL_31:
    uint64_t v25 = 46;
    goto LABEL_32;
  }
  if (!__maskrune((char)v13, 0x40000uLL)) {
    goto LABEL_31;
  }
LABEL_29:
  uint64_t v25 = *(char *)(a1 + 88);
LABEL_32:
  LogError("copyImageBlockSet_10bit", 1167, "*** pixelFormat '%c%c%c%c' not supported\n", v18, v21, v24, v25);
LABEL_33:
  IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
LABEL_34:
  kdebug_trace();
  int v26 = *(_DWORD *)(a1 + 88);
  unsigned int v27 = v26 >> 24;
  uint64_t v28 = MEMORY[0x1E4F14390];
  if (v26 < 0)
  {
    int v29 = __maskrune(v27, 0x40000uLL);
    int v26 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    int v29 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v27 + 60) & 0x40000;
  }
  if (v29) {
    uint64_t v30 = (v26 >> 24);
  }
  else {
    uint64_t v30 = 46;
  }
  unsigned int v31 = v26 << 8 >> 24;
  if (v26 << 8 < 0)
  {
    int v32 = __maskrune(v31, 0x40000uLL);
    int v26 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    int v32 = *(_DWORD *)(v28 + 4 * v31 + 60) & 0x40000;
  }
  if (v32) {
    uint64_t v33 = (v26 << 8 >> 24);
  }
  else {
    uint64_t v33 = 46;
  }
  unsigned int v34 = (__int16)v26 >> 8;
  if (v26 << 16 < 0)
  {
    int v35 = __maskrune(v34, 0x40000uLL);
    int v26 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    int v35 = *(_DWORD *)(v28 + 4 * v34 + 60) & 0x40000;
  }
  if (v35) {
    uint64_t v36 = ((__int16)v26 >> 8);
  }
  else {
    uint64_t v36 = 46;
  }
  if ((v26 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v28 + 4 * (char)v26 + 60) & 0x40000) != 0) {
      goto LABEL_54;
    }
LABEL_56:
    uint64_t v37 = 46;
    goto LABEL_57;
  }
  if (!__maskrune((char)v26, 0x40000uLL)) {
    goto LABEL_56;
  }
LABEL_54:
  uint64_t v37 = *(char *)(a1 + 88);
LABEL_57:
  LogError("copyImageBlockSet_10bit", 1186, "*** copyImageBlockSet_10bit '%c%c%c%c' failed: err=%d\n", v30, v33, v36, v37, -50);
  _ImageIO_Free(*(void *)(a1 + 168), *(void *)(a1 + 176));
  uint64_t result = 0;
  *(void *)(a1 + 168) = 0;
  return result;
}

vImage_Error IIOIOSurfaceWrapper::copy_RGBA_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  *(_DWORD *)permuteMap = 50462976;
  __int16 v10 = 0;
  *(_DWORD *)backgroundColor = 0;
  vImage_Error v6 = vImageConvert_ARGB8888ToARGB16U(a2, a3, permuteMap, 0, backgroundColor, 0x10u);
  if (v6) {
    _cg_jpeg_mem_term("copy_RGBA_16bit", 1209, "*** ERROR: iio_vImageConvert_ARGB8888ToARGB16U returned: %d\n", v6);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_RGBA_16bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

vImage_Error IIOIOSurfaceWrapper::copy_BGRA_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  *(_DWORD *)permuteMap = 50331906;
  __int16 v10 = 0;
  *(_DWORD *)backgroundColor = 0;
  vImage_Error v6 = vImageConvert_ARGB8888ToARGB16U(a2, a3, permuteMap, 0, backgroundColor, 0x10u);
  if (v6) {
    _cg_jpeg_mem_term("copy_BGRA_16bit", 1228, "*** ERROR: iio_vImageConvert_ARGB8888ToARGB16U returned: %d\n", v6);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_BGRA_16bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

vImage_Error IIOIOSurfaceWrapper::copy_L008_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  vImage_Error v6 = vImageConvert_Planar8To16U(a2, a3, 0x10u);
  if (v6) {
    _cg_jpeg_mem_term("copy_L008_16bit", 1244, "*** ERROR: iio_vImageConvert_Planar8To16U returned: %d\n", v6);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_L008_16bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

vImage_Error IIOIOSurfaceWrapper::copy_LA08_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  vImage_Error v6 = vImageConvert_Planar8To16U(a2, a3, 0x10u);
  if (v6) {
    _cg_jpeg_mem_term("copy_LA08_16bit", 1258, "*** ERROR: iio_vImageConvert_Planar8To16U returned: %d\n", v6);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v7 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_LA08_16bit", (v7 - Current) * 1000.0);
  }
  return v6;
}

uint64_t IIOIOSurfaceWrapper::copy_l64r_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (a2->rowBytes >= a3->rowBytes) {
    rowunint64_t Bytes = a3->rowBytes;
  }
  else {
    rowunint64_t Bytes = a2->rowBytes;
  }
  if (a3->height)
  {
    data = (char *)a3->data;
    vImage_Error v8 = (char *)a2->data;
    unsigned int v9 = 1;
    do
    {
      memcpy(data, v8, rowBytes);
      v8 += a2->rowBytes;
      data += a3->rowBytes;
    }
    while (a3->height > v9++);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v11 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_l64r_16bit", (v11 - Current) * 1000.0);
  }
  return 0;
}

vImage_Error IIOIOSurfaceWrapper::copy_RGhA_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (*((_DWORD *)this + 54) == 5)
  {
    if (a2->rowBytes >= a3->rowBytes) {
      rowunint64_t Bytes = a3->rowBytes;
    }
    else {
      rowunint64_t Bytes = a2->rowBytes;
    }
    if (a3->height)
    {
      data = (char *)a3->data;
      unsigned int v9 = (char *)a2->data;
      unsigned int v10 = 1;
      do
      {
        memcpy(data, v9, rowBytes);
        v9 += a2->rowBytes;
        data += a3->rowBytes;
      }
      while (a3->height > v10++);
    }
    vImage_Error v12 = 0;
  }
  else
  {
    vImage_Error v12 = vImageConvert_16Fto16U(a2, a3, 0x10u);
    if (v12) {
      _cg_jpeg_mem_term("copy_RGhA_16bit", 1310, "*** ERROR: iio_vImageConvert_16Fto16U returned: %d\n", v12);
    }
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v13 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_RGhA_16bit", (v13 - Current) * 1000.0);
  }
  return v12;
}

uint64_t IIOIOSurfaceWrapper::copy_2C16_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (a2->rowBytes >= a3->rowBytes) {
    rowunint64_t Bytes = a3->rowBytes;
  }
  else {
    rowunint64_t Bytes = a2->rowBytes;
  }
  if (a3->height)
  {
    data = (char *)a3->data;
    vImage_Error v8 = (char *)a2->data;
    unsigned int v9 = 1;
    do
    {
      memcpy(data, v8, rowBytes);
      v8 += a2->rowBytes;
      data += a3->rowBytes;
    }
    while (a3->height > v9++);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v11 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_2C16_16bit", (v11 - Current) * 1000.0);
  }
  return 0;
}

vImage_Error IIOIOSurfaceWrapper::copy_2C0h_16bit(IIOIOSurfaceWrapper *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  double Current = CFAbsoluteTimeGetCurrent();
  if (*((_DWORD *)this + 54) == 5)
  {
    if (a2->rowBytes >= a3->rowBytes) {
      rowunint64_t Bytes = a3->rowBytes;
    }
    else {
      rowunint64_t Bytes = a2->rowBytes;
    }
    if (a3->height)
    {
      data = (char *)a3->data;
      unsigned int v9 = (char *)a2->data;
      unsigned int v10 = 1;
      do
      {
        memcpy(data, v9, rowBytes);
        v9 += a2->rowBytes;
        data += a3->rowBytes;
      }
      while (a3->height > v10++);
    }
    vImage_Error v12 = 0;
  }
  else
  {
    vImage_Error v12 = vImageConvert_16Fto16U(a2, a3, 0x10u);
    if (v12) {
      _cg_jpeg_mem_term("copy_2C0h_16bit", 1362, "*** ERROR: iio_vImageConvert_16Fto16U returned: %d\n", v12);
    }
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v13 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_2C0h_16bit", (v13 - Current) * 1000.0);
  }
  return v12;
}

uint64_t IIOIOSurfaceWrapper::copyImageBlockSet_16bit(uint64_t a1, double a2, double a3, double a4, double a5)
{
  long long v49 = xmmword_1ED4F0C80;
  long long v48 = xmmword_1ED4F0C90;
  if (IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0))
  {
LABEL_2:
    int v10 = -50;
    goto LABEL_3;
  }
  BaseAddress = (IIOIOSurfaceWrapper *)IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(a1 + 72));
  if (!BaseAddress)
  {
    if (*(unsigned char *)(a1 + 140)) {
      int v29 = "YES";
    }
    else {
      int v29 = "NO";
    }
    _cg_jpeg_mem_term("copyImageBlockSet_16bit", 1391, "*** IOSurfaceGetBaseAddress returned NULL -- (protected: %s)\n", v29);
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
    goto LABEL_2;
  }
  size_t v16 = *(void *)(a1 + 112);
  v47.data = (char *)BaseAddress
           + (unint64_t)(a2 * (double)*(unint64_t *)(a1 + 120))
           + (unint64_t)(a3 * (double)v16);
  v47.double height = (unint64_t)a5;
  v47.unint64_t width = (unint64_t)a4;
  v47.rowunint64_t Bytes = v16;
  v46.data = *(void **)(a1 + 168);
  v46.double height = (unint64_t)a5;
  size_t v17 = *(unsigned int *)(a1 + 184);
  v46.unint64_t width = (unint64_t)a4;
  v46.rowunint64_t Bytes = v17;
  int v18 = *(_DWORD *)(a1 + 88);
  if (v18 <= 1278226487)
  {
    if (v18 > 843264309)
    {
      if (v18 == 843264310)
      {
        IIOIOSurfaceWrapper::copy_2C16_16bit(BaseAddress, &v47, &v46);
        goto LABEL_57;
      }
      if (v18 == 1111970369)
      {
        int v31 = IIOIOSurfaceWrapper::copy_BGRA_16bit(BaseAddress, &v47, &v46);
        if (v31)
        {
          int v10 = v31;
          _cg_jpeg_mem_term("copyImageBlockSet_16bit", 1410, "*** ERROR: copy_BGRA_16bit returned: %d\n");
          goto LABEL_83;
        }
        goto LABEL_57;
      }
    }
    else
    {
      if (v18 == 843264056)
      {
        int v32 = IIOIOSurfaceWrapper::copy_LA08_16bit(BaseAddress, &v47, &v46);
        if (v32)
        {
          int v10 = v32;
          _cg_jpeg_mem_term("copyImageBlockSet_16bit", 1434, "*** ERROR: copy_LA08_16bit returned: %d\n");
          goto LABEL_83;
        }
        goto LABEL_57;
      }
      if (v18 == 843264104)
      {
        int v19 = IIOIOSurfaceWrapper::copy_2C0h_16bit((IIOIOSurfaceWrapper *)a1, &v47, &v46);
        if (v19)
        {
          int v10 = v19;
          _cg_jpeg_mem_term("copyImageBlockSet_16bit", 1446, "*** ERROR: copy_2C0h_16bit returned: %d\n");
LABEL_83:
          IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
LABEL_3:
          kdebug_trace();
          int v11 = *(_DWORD *)(a1 + 88);
          unsigned int v12 = v11 >> 24;
          uint64_t v13 = MEMORY[0x1E4F14390];
          if (v11 < 0)
          {
            int v14 = __maskrune(v12, 0x40000uLL);
            int v11 = *(_DWORD *)(a1 + 88);
          }
          else
          {
            int v14 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x40000;
          }
          if (v14) {
            uint64_t v20 = (v11 >> 24);
          }
          else {
            uint64_t v20 = 46;
          }
          unsigned int v21 = v11 << 8 >> 24;
          if (v11 << 8 < 0)
          {
            int v22 = __maskrune(v21, 0x40000uLL);
            int v11 = *(_DWORD *)(a1 + 88);
          }
          else
          {
            int v22 = *(_DWORD *)(v13 + 4 * v21 + 60) & 0x40000;
          }
          if (v22) {
            uint64_t v23 = (v11 << 8 >> 24);
          }
          else {
            uint64_t v23 = 46;
          }
          unsigned int v24 = (__int16)v11 >> 8;
          if (v11 << 16 < 0)
          {
            int v25 = __maskrune(v24, 0x40000uLL);
            int v11 = *(_DWORD *)(a1 + 88);
          }
          else
          {
            int v25 = *(_DWORD *)(v13 + 4 * v24 + 60) & 0x40000;
          }
          if (v25) {
            uint64_t v26 = ((__int16)v11 >> 8);
          }
          else {
            uint64_t v26 = 46;
          }
          if ((v11 << 24) <= 0x7F000000)
          {
            if ((*(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000) != 0) {
              goto LABEL_30;
            }
          }
          else if (__maskrune((char)v11, 0x40000uLL))
          {
LABEL_30:
            uint64_t v27 = *(char *)(a1 + 88);
LABEL_33:
            LogError("copyImageBlockSet_16bit", 1471, "*** copyImageBlockSet_16bit '%c%c%c%c' failed: err=%d\n", v20, v23, v26, v27, v10);
            _ImageIO_Free(*(void *)(a1 + 168), *(void *)(a1 + 176));
            uint64_t result = 0;
            *(void *)(a1 + 168) = 0;
            return result;
          }
          uint64_t v27 = 46;
          goto LABEL_33;
        }
        goto LABEL_57;
      }
    }
    goto LABEL_58;
  }
  if (v18 > 1380411456)
  {
    if (v18 == 1380411457)
    {
      int v34 = IIOIOSurfaceWrapper::copy_RGhA_16bit((IIOIOSurfaceWrapper *)a1, &v47, &v46);
      if (v34)
      {
        int v10 = v34;
        _cg_jpeg_mem_term("copyImageBlockSet_16bit", 1416, "*** ERROR: copy_RGhA_16bit returned: %d\n");
        goto LABEL_83;
      }
      goto LABEL_57;
    }
    if (v18 == 1815491698)
    {
      IIOIOSurfaceWrapper::copy_l64r_16bit(BaseAddress, &v47, &v46);
      goto LABEL_57;
    }
    goto LABEL_58;
  }
  if (v18 == 1278226488)
  {
    int v33 = IIOIOSurfaceWrapper::copy_L008_16bit(BaseAddress, &v47, &v46);
    if (v33)
    {
      int v10 = v33;
      _cg_jpeg_mem_term("copyImageBlockSet_16bit", 1428, "*** ERROR: copy_L008_16bit returned: %d\n");
      goto LABEL_83;
    }
    goto LABEL_57;
  }
  if (v18 != 1380401729)
  {
LABEL_58:
    unsigned int v35 = v18 >> 24;
    if (v18 < 0)
    {
      int v36 = __maskrune(v35, 0x40000uLL);
      int v18 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      int v36 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v35 + 60) & 0x40000;
    }
    if (v36) {
      uint64_t v37 = (v18 >> 24);
    }
    else {
      uint64_t v37 = 46;
    }
    unsigned int v38 = v18 << 8 >> 24;
    if (v18 << 8 < 0)
    {
      int v39 = __maskrune(v38, 0x40000uLL);
      int v18 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      int v39 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v38 + 60) & 0x40000;
    }
    if (v39) {
      uint64_t v40 = (v18 << 8 >> 24);
    }
    else {
      uint64_t v40 = 46;
    }
    unsigned int v41 = (__int16)v18 >> 8;
    if (v18 << 16 < 0)
    {
      int v42 = __maskrune(v41, 0x40000uLL);
      int v18 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      int v42 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v41 + 60) & 0x40000;
    }
    if (v42) {
      uint64_t v43 = ((__int16)v18 >> 8);
    }
    else {
      uint64_t v43 = 46;
    }
    if ((v18 << 24) <= 0x7F000000) {
      int v44 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v18 + 60) & 0x40000;
    }
    else {
      int v44 = __maskrune((char)v18, 0x40000uLL);
    }
    if (v44) {
      uint64_t v45 = *(char *)(a1 + 88);
    }
    else {
      uint64_t v45 = 46;
    }
    LogError("copyImageBlockSet_16bit", 1451, "*** pixelFormat '%c%c%c%c' not supported\n", v37, v40, v43, v45);
    int v10 = -4;
    goto LABEL_83;
  }
  int v30 = IIOIOSurfaceWrapper::copy_RGBA_16bit(BaseAddress, &v47, &v46);
  if (v30)
  {
    int v10 = v30;
    _cg_jpeg_mem_term("copyImageBlockSet_16bit", 1404, "*** ERROR: copy_RGBA_16bit returned: %d\n");
    goto LABEL_83;
  }
LABEL_57:
  IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
  v47.data = (void *)CGImageBlockCreate();
  return CGImageBlockSetCreate();
}

uint64_t IIOIOSurfaceWrapper::preCopyBlockSet(IIOIOSurfaceWrapper *this, int a2, CGRect a3, CGSize a4, IIODictionary *a5)
{
  double height = a3.size.height;
  double width = a3.size.width;
  IIOIOSurfaceWrapperBase::preCopyBlockSet(this, a2, a3, a4, a5);
  int v9 = IIO_CGImageBlockSetBytesPerPixelForPixelFormat(*((_DWORD *)this + 22));
  char v11 = a2 == 16 && *((_DWORD *)this + 22) == 1815162994;
  unsigned int v12 = IIOAlignRowBytes((unint64_t)(width * (double)(v9 << v11)), 0);
  *((_DWORD *)this + 46) = v12;
  if (is_mul_ok((unint64_t)height, v12)) {
    *((void *)this + 21) = _ImageIO_Malloc((unint64_t)height * v12, 64, (memory_object_size_t *)this + 22, (uint64_t)kImageMalloc_IOSurface_Data, 0, 0, 0);
  }
  return 0;
}

uint64_t IIO_CGImageBlockSetBytesPerPixelForPixelFormat(int a1)
{
  uint64_t result = 4;
  if (a1 <= 1650943795)
  {
    if (a1 <= 875836517)
    {
      if (a1 > 875704933)
      {
        if (a1 == 875704934) {
          return result;
        }
        unsigned __int16 v5 = 12918;
      }
      else
      {
        if (a1 == 875704422) {
          return result;
        }
        unsigned __int16 v5 = 12406;
      }
      int v3 = v5 | 0x34320000;
    }
    else
    {
      if (a1 > 1278226735)
      {
        if (a1 == 1278226736 || a1 == 1278226742) {
          return 2;
        }
        int v4 = 1279340600;
        goto LABEL_26;
      }
      if (a1 == 875836518) {
        return result;
      }
      int v3 = 875836534;
    }
LABEL_30:
    if (a1 == v3) {
      return result;
    }
    return IIO_BytesPerPixelForPixelFormatPlane0(a1);
  }
  if (a1 > 2019963439)
  {
    if (a1 <= 2019963955)
    {
      if (a1 == 2019963440) {
        return result;
      }
      int v3 = 2019963442;
    }
    else
    {
      if (a1 == 2019963956 || a1 == 2037741158) {
        return result;
      }
      int v3 = 2037741171;
    }
    goto LABEL_30;
  }
  if (a1 <= 2016686639)
  {
    if (a1 == 1650943796) {
      return 2;
    }
    int v4 = 1919379252;
LABEL_26:
    if (a1 != v4) {
      return IIO_BytesPerPixelForPixelFormatPlane0(a1);
    }
    return 2;
  }
  if (a1 != 2016686640 && a1 != 2016686642)
  {
    int v3 = 2016687156;
    goto LABEL_30;
  }
  return result;
}

unint64_t IIOIOSurfaceWrapper::packDebugInfo(IIOIOSurfaceWrapper *this, CGRect a2, uint64_t a3)
{
  unint64_t result = IIOIOSurfaceWrapperBase::packDebugInfo(this, a2, a3);
  if (*((unsigned char *)this + 200)) {
    result |= 0x1000uLL;
  }
  return result;
}

uint64_t IIOIOSurfaceWrapper::copyImageBlockSetWithOptions8Bit(uint64_t a1, uint64_t a2, IIODictionary *a3, void *a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8, double a9, double a10)
{
  uint64_t v20 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (*(unsigned char *)(a1 + 142))
  {
    *(unsigned char *)(a1 + 200) = 0;
    CFStringRef v21 = (const __CFString *)*MEMORY[0x1E4F1DD38];
    if (IIODictionary::containsKey(a3, (const __CFString *)*MEMORY[0x1E4F1DD38]))
    {
      CFStringRef v22 = (const __CFString *)*MEMORY[0x1E4F1DD30];
      CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(a3, v21);
      if (CFEqual(v22, ObjectForKey)) {
        *(unsigned char *)(a1 + 200) = 1;
      }
    }
    int v24 = *(_DWORD *)(a1 + 88);
    if (v24 == 1111970369)
    {
      if (!*(unsigned char *)(a1 + 200) || *(_DWORD *)(a1 + 136) != 1) {
        goto LABEL_13;
      }
    }
    else if (v24 == 1380401729 && *(unsigned char *)(a1 + 200))
    {
      goto LABEL_13;
    }
    uint64_t v25 = IIOIOSurfaceWrapper::copyImageBlockSetNoCopy(a1, a5, a6, a7, a8);
    if (v25)
    {
      uint64_t v26 = v25;
      uint64_t v27 = 0;
      goto LABEL_18;
    }
  }
LABEL_13:
  uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t, IIODictionary *, CGFloat, CGFloat, CGFloat, CGFloat, double, double))(*(void *)a1 + 40))(a1, 8, a3, a5, a6, a7, a8, a9, a10);
  if (v27) {
    uint64_t v26 = 0;
  }
  else {
    uint64_t v26 = (*(uint64_t (**)(uint64_t, uint64_t, IIODictionary *, CGFloat, CGFloat, CGFloat, CGFloat, double, double))(*(void *)a1 + 24))(a1, a2, a3, a5, a6, a7, a8, a9, a10);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
  if (v27) {
    _cg_jpeg_mem_term("copyImageBlockSetWithOptions8Bit", 1574, "*** ERROR: copyImageBlockSetWithOptions8Bit err = %d\n", v27);
  }
LABEL_18:
  *a4 = (*(uint64_t (**)(uint64_t, uint64_t, CGFloat, CGFloat, CGFloat, CGFloat))(*(void *)a1 + 64))(a1, v27, a5, a6, a7, a8);
  pthread_mutex_unlock(v20);
  return v26;
}

uint64_t IIOIOSurfaceWrapper::copyImageBlockSetWithOptions10Bit(uint64_t a1, double a2, double a3, double a4, double a5, double a6, double a7, uint64_t a8, uint64_t a9, void *a10)
{
  int v19 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  uint64_t v20 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, double, double, double, double, double, double))(*(void *)a1 + 40))(a1, 10, a9, a2, a3, a4, a5, a6, a7);
  if (v20) {
    uint64_t v21 = 0;
  }
  else {
    uint64_t v21 = IIOIOSurfaceWrapper::copyImageBlockSet_10bit(a1, a2, a3, a4, a5);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
  if (v20) {
    _cg_jpeg_mem_term("copyImageBlockSetWithOptions10Bit", 1597, "*** ERROR: copyImageBlockSetWithOptions10Bit err = %d\n", v20);
  }
  *a10 = (*(uint64_t (**)(uint64_t, uint64_t, double, double, double, double))(*(void *)a1 + 64))(a1, v20, a2, a3, a4, a5);
  pthread_mutex_unlock(v19);
  return v21;
}

uint64_t IIOIOSurfaceWrapper::copyImageBlockSetWithOptions16Bit(unsigned char *a1, uint64_t a2, uint64_t a3, void *a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8, double a9, double a10)
{
  uint64_t v20 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  if (a1[142])
  {
    uint64_t v21 = IIOIOSurfaceWrapper::copyImageBlockSetNoCopy((uint64_t)a1, a5, a6, a7, a8);
    uint64_t v22 = 0;
  }
  else
  {
    uint64_t v22 = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, CGFloat, CGFloat, CGFloat, CGFloat, double, double))(*(void *)a1 + 40))(a1, 16, a3, a5, a6, a7, a8, a9, a10);
    if (v22) {
      uint64_t v21 = 0;
    }
    else {
      uint64_t v21 = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, CGFloat, CGFloat, CGFloat, CGFloat, double, double))(*(void *)a1 + 32))(a1, a2, a3, a5, a6, a7, a8, a9, a10);
    }
    (*(void (**)(unsigned char *))(*(void *)a1 + 48))(a1);
    if (v22) {
      _cg_jpeg_mem_term("copyImageBlockSetWithOptions16Bit", 1628, "*** ERROR: copyImageBlockSetWithOptions16Bit err = %d\n", v22);
    }
  }
  *a4 = (*(uint64_t (**)(unsigned char *, uint64_t, CGFloat, CGFloat, CGFloat, CGFloat))(*(void *)a1 + 64))(a1, v22, a5, a6, a7, a8);
  pthread_mutex_unlock(v20);
  return v21;
}

void IIOIOSurfaceWrapper_CIF10::IIOIOSurfaceWrapper_CIF10(IIOIOSurfaceWrapper_CIF10 *this, __IOSurface *a2, size_t a3, size_t a4, int a5, CGImageAlphaInfo a6, IIODictionary *a7)
{
  IIOIOSurfaceWrapperBase::IIOIOSurfaceWrapperBase(this, a2, a3, a4, a5, a6, a7);
  int v9 = (void (**)(IIOIOSurfaceWrapper_CIF10 *, IIODictionary *, void))&unk_1ED4B42E0;
  *int v10 = &unk_1ED4B42E0;
  if (v10[16] < 2uLL)
  {
    *((_OWORD *)this + 14) = 0u;
    *((_OWORD *)this + 15) = 0u;
  }
  else
  {
    *((void *)this + 28) = IOSurfaceGetWidthOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    *((void *)this + 29) = IOSurfaceGetHeightOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    *((void *)this + 30) = IOSurfaceGetBytesPerRowOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    *((void *)this + 31) = IOSurfaceGetBytesPerElementOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    int v9 = *(void (***)(IIOIOSurfaceWrapper_CIF10 *, IIODictionary *, void))this;
  }
  v9[7](this, a7, 0);
}

void sub_1887C6C28(_Unwind_Exception *a1)
{
  IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(v1);
  _Unwind_Resume(a1);
}

void IIOIOSurfaceWrapper_CIF10::completeSetup(IIOIOSurfaceWrapper_CIF10 *this, IIODictionary *a2, const __CFString *a3)
{
  *((void *)this + 33) = 0;
  *((_DWORD *)this + 64) = CIF10MIN();
  *((_DWORD *)this + 65) = CIF10MAX();
  *((unsigned char *)this + 272) = 1;
  if (onceSkipCheck != -1) {
    dispatch_once(&onceSkipCheck, &__block_literal_global_104);
  }
  int v6 = *((_DWORD *)this + 22);
  if (v6 == 1647534392)
  {
    *((_DWORD *)this + 54) = 1;
    *((unsigned char *)this + 264) = 1;
    CFStringRef v7 = (const __CFString *)*MEMORY[0x1E4F1DBE8];
    *((_DWORD *)this + 41) = 1;
    goto LABEL_31;
  }
  if (v6 == 1999843442)
  {
    *((_DWORD *)this + 54) = 1;
    *((unsigned char *)this + 264) = 1;
    CFStringRef v7 = (const __CFString *)*MEMORY[0x1E4F1DBE8];
    *((_DWORD *)this + 41) = 0;
    goto LABEL_31;
  }
  unsigned int v8 = v6 >> 24;
  uint64_t v9 = MEMORY[0x1E4F14390];
  if (v6 < 0)
  {
    int v10 = __maskrune(v8, 0x40000uLL);
    int v6 = *((_DWORD *)this + 22);
  }
  else
  {
    int v10 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v8 + 60) & 0x40000;
  }
  if (v10) {
    uint64_t v11 = (v6 >> 24);
  }
  else {
    uint64_t v11 = 46;
  }
  unsigned int v12 = v6 << 8 >> 24;
  if (v6 << 8 < 0)
  {
    int v13 = __maskrune(v12, 0x40000uLL);
    int v6 = *((_DWORD *)this + 22);
  }
  else
  {
    int v13 = *(_DWORD *)(v9 + 4 * v12 + 60) & 0x40000;
  }
  if (v13) {
    uint64_t v14 = (v6 << 8 >> 24);
  }
  else {
    uint64_t v14 = 46;
  }
  unsigned int v15 = (__int16)v6 >> 8;
  if (v6 << 16 < 0)
  {
    int v16 = __maskrune(v15, 0x40000uLL);
    int v6 = *((_DWORD *)this + 22);
  }
  else
  {
    int v16 = *(_DWORD *)(v9 + 4 * v15 + 60) & 0x40000;
  }
  if (v16) {
    uint64_t v17 = ((__int16)v6 >> 8);
  }
  else {
    uint64_t v17 = 46;
  }
  if ((v6 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v9 + 4 * (char)v6 + 60) & 0x40000) != 0) {
      goto LABEL_27;
    }
LABEL_29:
    uint64_t v18 = 46;
    goto LABEL_30;
  }
  if (!__maskrune((char)v6, 0x40000uLL)) {
    goto LABEL_29;
  }
LABEL_27:
  uint64_t v18 = *((char *)this + 88);
LABEL_30:
  LogError("completeSetup", 1771, "*** IIOIOSurfaceWrapper_CIF10 - pixelFormat '%c%c%c%c' not handled\n", v11, v14, v17, v18);
  CFStringRef v7 = 0;
LABEL_31:
  IIOIOSurfaceWrapperBase::completeSetup(this, v5, v7);
  if (!a2) {
    return;
  }
  if (*((unsigned char *)this + 264))
  {
    if (IIODictionary::containsKey(a2, @"kCGImageSkipCIF10SRGBCheck"))
    {
      BOOL BoolForKey = IIODictionary::getBoolForKey(a2, @"kCGImageSkipCIF10SRGBCheck");
      *((unsigned char *)this + 265) = BoolForKey;
      uint64_t v20 = "NO";
      if (BoolForKey) {
        uint64_t v20 = "YES";
      }
      _cg_jpeg_mem_term("completeSetup", 1790, "    kCGImageSkipCIF10SRGBCheck was set to %s\n", v20);
    }
    else
    {
      int v21 = *((_DWORD *)this + 54);
      if (v21 == 2 || v21 == 5 || (int v22 = *((_DWORD *)this + 53), v22 == 5) || v22 == 2)
      {
        if (v21 == 2) {
          uint64_t v23 = "kCGImageComponent16BitInteger";
        }
        else {
          uint64_t v23 = "kCGImageComponent16BitFloat";
        }
        _cg_jpeg_mem_term("completeSetup", 1799, "    _componentCGImageMetadataType Type = %s  -- will skip CIF10SRGBCheck\n", v23);
        *((unsigned char *)this + 265) = 1;
        goto LABEL_49;
      }
    }
    if (!*((unsigned char *)this + 265)) {
      goto LABEL_53;
    }
LABEL_49:
    int v24 = gDeviceHasExtendedColorDisplay;
    *((unsigned char *)this + 272) = gDeviceHasExtendedColorDisplay ^ 1;
    if (v24) {
      uint64_t v25 = "NO (= assume P3)";
    }
    else {
      uint64_t v25 = "YES";
    }
    _cg_jpeg_mem_term("completeSetup", 1805, "    Skipping CIF10-to-SRGB-Check -- _isSRGB = %s\n", v25);
    goto LABEL_53;
  }
  *((unsigned char *)this + 265) = 1;
LABEL_53:

  IIOIOSurfaceWrapper_CIF10::updateColorMatchMode((uint64_t)this, a2);
}

uint64_t IIOIOSurfaceWrapper_CIF10::updateColorMatchMode(uint64_t this, IIODictionary *a2)
{
  uint64_t v2 = this;
  if (a2)
  {
    this = (uint64_t)IIODictionary::containsKey(a2, @"kCGImagePreferredColorConversionMode");
    if (this)
    {
      this = (uint64_t)IIODictionary::getUint32ForKey(a2, @"kCGImagePreferredColorConversionMode");
      switch((int)this)
      {
        case 1:
          break;
        case 2:
          this = 2 * gCanUseMSRForColorConversion;
          break;
        case 3:
          this = 3;
          break;
        case 4:
          this = 0;
          *(unsigned char *)(v2 + 267) = 1;
          break;
        default:
          this = 0;
          break;
      }
      *(_DWORD *)(v2 + 268) = this;
      if ((gIIODebugFlags & 0x8000300000) != 0) {
        this = (uint64_t)ImageIOLog("COL updateColorMatchMode: kCGImagePreferredColorConversionMode specified --> using: %d '%s'\n", this, gIIOColorMatchModeString[this]);
      }
      *(unsigned char *)(v2 + 266) = 1;
    }
  }
  else if (!*(unsigned char *)(this + 266))
  {
    *(_DWORD *)(this + 268) = 0;
    if ((gIIODebugFlags & 0x8000300000) != 0)
    {
      return (uint64_t)ImageIOLog("COL updateColorMatchMode: no options specified --> using: kColorConversionModeDefault\n");
    }
  }
  return this;
}

uint64_t IIOIOSurfaceWrapper_CIF10::createImage(IIOIOSurfaceWrapper_CIF10 *this)
{
  void v29[3] = 2;
  uint64_t v2 = IIOIOSurfaceWrapperBase::CopyImageBlockSetWithOptionsNoOp;
  if (!*((unsigned char *)this + 140)) {
    uint64_t v2 = IIOIOSurfaceWrapper_CIF10::CopyImageBlockSetWithOptions;
  }
  v29[4] = v2;
  v29[5] = IIOIOSurfaceWrapperBase::CopyIOSurface;
  v29[6] = IIOIOSurfaceWrapperBase::ReleaseInfo;
  memset(v29, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)v29);
  int v3 = *((_DWORD *)this + 22);
  if (v3 == 1647534392)
  {
    int v4 = (const __CFString **)MEMORY[0x1E4F1DD78];
    goto LABEL_7;
  }
  if (v3 == 1999843442)
  {
    int v4 = (const __CFString **)MEMORY[0x1E4F1DD70];
LABEL_7:
    IIODictionary::setObjectForKey((IIODictionary *)v29, (const void *)*MEMORY[0x1E4F1CFD0], *v4);
  }
  if (!*((unsigned char *)this + 265) && !IOSurfaceLock(*((IOSurfaceRef *)this + 9), 1u, 0))
  {
    int v5 = *((_DWORD *)this + 22);
    if (v5 == 1647534392)
    {
      BaseAddressOfPlane = (unsigned int *)IOSurfaceGetBaseAddressOfPlane(*((IOSurfaceRef *)this + 9), 0);
    }
    else
    {
      if (v5 != 1999843442) {
        goto LABEL_46;
      }
      BaseAddressOfPlane = (unsigned int *)IOSurfaceGetBaseAddress(*((IOSurfaceRef *)this + 9));
    }
    if (BaseAddressOfPlane)
    {
      *((unsigned char *)this + 272) = IIOIOSurfaceWrapper_CIF10::checkIfCIF10DataFitsIntoSRGB(this, BaseAddressOfPlane);
      IOSurfaceUnlock(*((IOSurfaceRef *)this + 9), 1u, 0);
      goto LABEL_16;
    }
    int v5 = *((_DWORD *)this + 22);
LABEL_46:
    unsigned int v14 = v5 >> 24;
    uint64_t v15 = MEMORY[0x1E4F14390];
    if (v5 < 0)
    {
      int v16 = __maskrune(v14, 0x40000uLL);
      int v5 = *((_DWORD *)this + 22);
    }
    else
    {
      int v16 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v14 + 60) & 0x40000;
    }
    if (v16) {
      uint64_t v17 = (v5 >> 24);
    }
    else {
      uint64_t v17 = 46;
    }
    unsigned int v18 = v5 << 8 >> 24;
    if (v5 << 8 < 0)
    {
      int v19 = __maskrune(v18, 0x40000uLL);
      int v5 = *((_DWORD *)this + 22);
    }
    else
    {
      int v19 = *(_DWORD *)(v15 + 4 * v18 + 60) & 0x40000;
    }
    if (v19) {
      uint64_t v20 = (v5 << 8 >> 24);
    }
    else {
      uint64_t v20 = 46;
    }
    unsigned int v21 = (__int16)v5 >> 8;
    if (v5 << 16 < 0)
    {
      int v22 = __maskrune(v21, 0x40000uLL);
      int v5 = *((_DWORD *)this + 22);
    }
    else
    {
      int v22 = *(_DWORD *)(v15 + 4 * v21 + 60) & 0x40000;
    }
    if (v22) {
      uint64_t v23 = ((__int16)v5 >> 8);
    }
    else {
      uint64_t v23 = 46;
    }
    if ((v5 << 24) <= 0x7F000000) {
      int v24 = *(_DWORD *)(v15 + 4 * (char)v5 + 60) & 0x40000;
    }
    else {
      int v24 = __maskrune((char)v5, 0x40000uLL);
    }
    if (v24) {
      uint64_t v25 = *((char *)this + 88);
    }
    else {
      uint64_t v25 = 46;
    }
    _cg_jpeg_mem_term("createImage", 1842, "*** ERROR: can't get CIF10 data '%c%c%c%c'\n", v17, v20, v23, v25);
LABEL_71:
    uint64_t v13 = 0;
    goto LABEL_72;
  }
LABEL_16:
  if (*((unsigned char *)this + 208) != 1)
  {
    uint64_t v9 = *((int *)this + 54);
    if (*((unsigned char *)this + 272))
    {
      if (v9 != 1)
      {
        if ((gIIODebugFlags & 0x8000300000) != 0) {
          ImageIOLog("*** _isSRGB + componentType: changing %s to %s\n", gComponentString[v9], "8BitInt");
        }
        int v10 = 1;
LABEL_29:
        *((_DWORD *)this + 54) = v10;
      }
    }
    else if (v9 != 2)
    {
      if ((gIIODebugFlags & 0x8000300000) != 0) {
        ImageIOLog("*** NOTE: outside sRGB: changing compType from %s to %s\n", gComponentString[v9], "16BitInt");
      }
      int v10 = 2;
      goto LABEL_29;
    }
    unsigned int v8 = (const __CFString **)MEMORY[0x1E4F1DB90];
    goto LABEL_31;
  }
  int v7 = *((_DWORD *)this + 53);
  *((_DWORD *)this + 54) = v7;
  if ((v7 - 1) >= 2) {
    unsigned int v8 = (const __CFString **)MEMORY[0x1E4F1DBE8];
  }
  else {
    unsigned int v8 = (const __CFString **)MEMORY[0x1E4F1DB90];
  }
LABEL_31:
  if (*((unsigned char *)this + 272)) {
    unsigned int v8 = (const __CFString **)MEMORY[0x1E4F1DC98];
  }
  CFStringRef v11 = *v8;
  if (!*v8) {
    goto LABEL_71;
  }
  v28[0] = (CGColorSpaceRef)&unk_1ED4DFD58;
  v28[1] = CGColorSpaceCreateWithName(v11);
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    if (*((unsigned char *)this + 272))
    {
      unsigned int v12 = "sRGB";
    }
    else if (*((_DWORD *)this + 54) == 1)
    {
      unsigned int v12 = "P3";
    }
    else
    {
      unsigned int v12 = "extended-sRGB";
    }
    ImageIOLog("COL CGImageProviderCreate - using '%s'\n", v12);
  }
  if (CGImageProviderCreate())
  {
    CGImageProviderSetProperty();
    memset(v27, 0, sizeof(v27));
    IIONumber::IIONumber((IIONumber *)v27, *((_DWORD *)this + 22));
    CGImageProviderSetProperty();
    uint64_t v13 = CGImageCreateWithImageProvider();
    CGImageProviderRelease();
    CGImageSetProperty();
    IIONumber::~IIONumber((IIONumber *)v27);
  }
  else
  {
    uint64_t v13 = 0;
  }
  IIOColorSpace::~IIOColorSpace(v28);
LABEL_72:
  IIODictionary::~IIODictionary((IIODictionary *)v29);
  return v13;
}

void sub_1887C75D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  CGColorSpaceRef v9 = va_arg(va1, CGColorSpaceRef);
  uint64_t v11 = va_arg(va1, void);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t IIOIOSurfaceWrapper_CIF10::CopyImageBlockSetWithOptions(uint64_t a1, uint64_t a2, __CFDictionary *a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  memset(v37, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)v37, a3);
  uint64_t v18 = *(int *)(a1 + 216);
  IIOPackCopyCallbackInfo(a3);
  CGImageProviderGetBitmapInfo();
  kdebug_trace();
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    int v20 = *(_DWORD *)(a1 + 88);
    unsigned int v21 = v20 >> 24;
    uint64_t v22 = MEMORY[0x1E4F14390];
    if (v20 < 0) {
      int v23 = __maskrune(v20 >> 24, 0x40000uLL);
    }
    else {
      int v23 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v21 + 60) & 0x40000;
    }
    if (v23) {
      uint64_t v24 = v21;
    }
    else {
      uint64_t v24 = 46;
    }
    unsigned int v25 = v20 << 8 >> 24;
    if (v20 << 8 < 0) {
      int v26 = __maskrune(v20 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v26 = *(_DWORD *)(v22 + 4 * v25 + 60) & 0x40000;
    }
    if (v26) {
      uint64_t v27 = v25;
    }
    else {
      uint64_t v27 = 46;
    }
    unsigned int v28 = (__int16)v20 >> 8;
    if (v20 << 16 < 0) {
      int v29 = __maskrune((__int16)v20 >> 8, 0x40000uLL);
    }
    else {
      int v29 = *(_DWORD *)(v22 + 4 * v28 + 60) & 0x40000;
    }
    if ((v20 << 24) <= 0x7F000000) {
      int v30 = *(_DWORD *)(v22 + 4 * (char)v20 + 60) & 0x40000;
    }
    else {
      int v30 = __maskrune((char)v20, 0x40000uLL);
    }
    if (v29) {
      uint64_t v31 = v28;
    }
    else {
      uint64_t v31 = 46;
    }
    if (v30) {
      uint64_t v32 = (char)v20;
    }
    else {
      uint64_t v32 = 46;
    }
    ImageIOLog("S   CopyImageBlockSetWithOptions-CIF10: {%g, %g, %g, %g} {%g, %g} '%c%c%c%c' %s\n", a4, a5, a6, a7, a8, a9, v24, v27, v31, v32, off_1E53CCE00[v18]);
  }
  uint64_t v36 = 0;
  if (!*(unsigned char *)(a1 + 141))
  {
    switch((int)v18)
    {
      case 1:
        uint64_t v33 = IIOIOSurfaceWrapper_CIF10::copyImageBlockSetWithOptions8Bit(a1, a2, (uint64_t)v37, &v36, a4, a5, a6, a7, a8, a9);
        goto LABEL_29;
      case 2:
      case 5:
        uint64_t v33 = IIOIOSurfaceWrapper_CIF10::copyImageBlockSetWithOptions16Bit(a1, a2, (uint64_t)v37, &v36, a4, a5, a6, a7, a8, a9);
        goto LABEL_29;
      case 6:
        goto LABEL_35;
      default:
        LogError("CopyImageBlockSetWithOptions", 2839, "*** unsupported componentType '%s' (%d)\n", gComponentString[v18], v18);
        goto LABEL_35;
    }
  }
  uint64_t v33 = IIOIOSurfaceWrapperBase::createBlockSetForCompressedSurface(a1, a4, a5, a6, a7, a2, v19, &v36);
LABEL_29:
  uint64_t v34 = v33;
  if (v33)
  {
    CGImageBlockSetGetRect();
  }
  else
  {
LABEL_35:
    _cg_jpeg_mem_term("CopyImageBlockSetWithOptions", 2849, "*** ERROR: CopyImageBlockSetWithOptions returned NULL\n");
    uint64_t v34 = 0;
  }
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v37);
  return v34;
}

void sub_1887C7950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

BOOL IIOIOSurfaceWrapper_CIF10::checkIfCIF10DataFitsIntoSRGB(IIOIOSurfaceWrapper_CIF10 *this, unsigned int *a2)
{
  unint64_t v2 = *((void *)this + 13);
  if (v2)
  {
    BOOL v3 = 0;
    unint64_t v4 = 0;
    unsigned int v5 = *((_DWORD *)this + 64);
    unsigned int v6 = *((_DWORD *)this + 65);
    uint64_t v7 = *((void *)this + 14);
    unint64_t v8 = *((void *)this + 12);
    uint64_t v9 = v8 >> 2;
    uint32x4_t v10 = (uint32x4_t)vdupq_n_s32(v5);
    uint32x4_t v11 = (uint32x4_t)vdupq_n_s32(v6);
    if (v8 >> 2 <= 1) {
      uint64_t v9 = 1;
    }
    v12.i64[0] = 0x300000003;
    v12.i64[1] = 0x300000003;
    do
    {
      int8x16_t v13 = 0uLL;
      if (v8 >= 4)
      {
        unsigned int v14 = a2;
        uint64_t v15 = v9;
        do
        {
          int8x16_t v16 = *(int8x16_t *)v14;
          v14 += 4;
          unsigned long long v17 = *(_OWORD *)&vshrq_n_u32((uint32x4_t)v16, 0x14uLL) & __PAIR128__(0xFFFFF3FFFFFFF3FFLL, 0xFFFFF3FFFFFFF3FFLL);
          uint32x4_t v18 = (uint32x4_t)vandq_s8((int8x16_t)vshrq_n_u32((uint32x4_t)v16, 0xAuLL), v12);
          uint32x4_t v19 = (uint32x4_t)vandq_s8(v16, v12);
          int8x16_t v13 = vorrq_s8(vorrq_s8(v13, (int8x16_t)vcgtq_u32(v18, v11)), vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vcgtq_u32(v19, v11), (int8x16_t)vcgtq_u32(v10, v19)), (int8x16_t)vcgtq_u32((uint32x4_t)v17, v11)), vorrq_s8((int8x16_t)vcgtq_u32(v10, (uint32x4_t)v17), (int8x16_t)vcgtq_u32(v10, v18))));
          --v15;
        }
        while (v15);
      }
      if ((v8 & 0xFFFFFFFFFFFFFFFCLL) >= v8)
      {
        char v20 = 0;
      }
      else
      {
        char v20 = 0;
        unint64_t v21 = v8 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          unsigned int v22 = a2[v21];
          unsigned int v23 = (v22 >> 20) & 0x3FF;
          unsigned int v24 = (v22 >> 10) & 0x3FF;
          unsigned int v25 = v22 & 0x3FF;
          BOOL v31 = v23 < v5 || v23 > v6 || v24 < v5 || v24 > v6 || v25 < v5 || v25 > v6;
          v20 |= v31;
          ++v21;
        }
        while (v8 != v21);
      }
      if ((vmaxvq_u32((uint32x4_t)v13) & 0x80000000) != 0) {
        break;
      }
      if (v20) {
        break;
      }
      ++v4;
      a2 = (unsigned int *)((char *)a2 + v7);
      BOOL v3 = v4 >= v2;
    }
    while (v4 != v2);
  }
  else
  {
    return 1;
  }
  return v3;
}

vImage_Error IIOIOSurfaceWrapper_CIF10::copy_CIF10_8bit_sRGB(IIOIOSurfaceWrapper_CIF10 *this, vImage_Buffer *a2, vImage_Buffer *a3, vImage_Buffer *a4)
{
  double Current = CFAbsoluteTimeGetCurrent();
  int v8 = *((_DWORD *)this + 22);
  if (v8 != 1647534392)
  {
    if (v8 == 1999843442)
    {
      int v14 = 197121;
      int v13 = 66051;
      if (*((unsigned char *)this + 200)) {
        uint64_t v9 = &v13;
      }
      else {
        uint64_t v9 = &v14;
      }
      vImage_Error v10 = vImageConvert_XRGB2101010ToARGB8888(a2, 0xFFu, a4, *((_DWORD *)this + 64), *((_DWORD *)this + 65), (const uint8_t *)v9, 0x10u);
      if (v10) {
        _cg_jpeg_mem_term("copy_CIF10_8bit_sRGB", 2063, "*** ERROR vImageConvert_XRGB2101010ToARGB8888 - %d\n");
      }
      goto LABEL_13;
    }
LABEL_12:
    vImage_Error v10 = 4294967246;
    goto LABEL_13;
  }
  if (IOSurfaceGetPlaneCount(*((IOSurfaceRef *)this + 9)) != 2) {
    goto LABEL_12;
  }
  int v14 = 197121;
  int v13 = 66051;
  vImage_Error v10 = vImageConvert_XRGB2101010_A8ToARGB8888();
  if (v10) {
    _cg_jpeg_mem_term("copy_CIF10_8bit_sRGB", 2088, "*** ERROR vImageConvert_XRGB2101010_A8ToARGB8888 - %d\n");
  }
LABEL_13:
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v11 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_CIF10_8bit_sRGB", (v11 - Current) * 1000.0);
  }
  return v10;
}

vImage_Error IIOIOSurfaceWrapper_CIF10::copy_to_CIF10_FP16_xsRGB(IIOIOSurfaceWrapper_CIF10 *this, vImage_Buffer *a2, vImage_Buffer *a3, vImage_Buffer *a4)
{
  double Current = CFAbsoluteTimeGetCurrent();
  int v8 = *((_DWORD *)this + 22);
  if (v8 != 1647534392)
  {
    if (v8 == 1999843442)
    {
      *(_DWORD *)permuteMap = 197121;
      vImage_Error v9 = vImageConvert_XRGB2101010ToARGB16F(a2, 1.0, a4, *((_DWORD *)this + 64), *((_DWORD *)this + 65), permuteMap, 0x810u);
      goto LABEL_33;
    }
    unsigned int v15 = v8 >> 24;
    uint64_t v16 = MEMORY[0x1E4F14390];
    if (v8 < 0)
    {
      int v17 = __maskrune(v15, 0x40000uLL);
      int v8 = *((_DWORD *)this + 22);
    }
    else
    {
      int v17 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v15 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = (v8 >> 24);
    }
    else {
      uint64_t v18 = 46;
    }
    unsigned int v19 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      int v20 = __maskrune(v19, 0x40000uLL);
      int v8 = *((_DWORD *)this + 22);
    }
    else
    {
      int v20 = *(_DWORD *)(v16 + 4 * v19 + 60) & 0x40000;
    }
    if (v20) {
      uint64_t v21 = (v8 << 8 >> 24);
    }
    else {
      uint64_t v21 = 46;
    }
    unsigned int v22 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      int v23 = __maskrune(v22, 0x40000uLL);
      int v8 = *((_DWORD *)this + 22);
    }
    else
    {
      int v23 = *(_DWORD *)(v16 + 4 * v22 + 60) & 0x40000;
    }
    if (v23) {
      uint64_t v24 = ((__int16)v8 >> 8);
    }
    else {
      uint64_t v24 = 46;
    }
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v16 + 4 * (char)v8 + 60) & 0x40000) != 0) {
        goto LABEL_28;
      }
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_28:
      uint64_t v25 = *((char *)this + 88);
LABEL_31:
      _cg_jpeg_mem_term("copy_to_CIF10_FP16_xsRGB", 2162, "*** _surfacePixelFormat '%c%c%c%c' is not handled\n", v18, v21, v24, v25);
      goto LABEL_32;
    }
    uint64_t v25 = 46;
    goto LABEL_31;
  }
  if (IOSurfaceGetPlaneCount(*((IOSurfaceRef *)this + 9)) != 2)
  {
LABEL_32:
    vImage_Error v9 = 4294967246;
    goto LABEL_33;
  }
  size_t BytesPerRowOfPlane = IOSurfaceGetBytesPerRowOfPlane(*((IOSurfaceRef *)this + 9), 0);
  size_t WidthOfPlane = IOSurfaceGetWidthOfPlane(*((IOSurfaceRef *)this + 9), 0);
  size_t HeightOfPlane = IOSurfaceGetHeightOfPlane(*((IOSurfaceRef *)this + 9), 0);
  BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(*((IOSurfaceRef *)this + 9), 0);
  IOSurfaceGetBytesPerRowOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
  IOSurfaceGetWidthOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
  IOSurfaceGetHeightOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
  int v14 = IOSurfaceGetBaseAddressOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
  int v32 = 50462976;
  vImage_Error v9 = 4294967246;
  if (BaseAddressOfPlane && v14)
  {
    *(void *)permuteMap = BaseAddressOfPlane;
    size_t v29 = HeightOfPlane;
    size_t v30 = WidthOfPlane;
    size_t v31 = BytesPerRowOfPlane;
    vImage_Error v9 = vImageConvert_XRGB2101010_A8ToARGB16F();
    LogError("copy_to_CIF10_FP16_xsRGB", 2153, "⭕️ check 'b3a8' conversion\n");
  }
LABEL_33:
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v26 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_to_CIF10_FP16_xsRGB", (v26 - Current) * 1000.0);
  }
  return v9;
}

uint64_t IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_CA(IIOIOSurfaceWrapper_CIF10 *this, CGRect a2, vImage_Buffer *a3, vImage_Buffer *a4, vImage_Buffer *a5)
{
  double height = a2.size.height;
  double width = a2.size.width;
  double Current = CFAbsoluteTimeGetCurrent();
  long long v35 = xmmword_1ED4F0C60;
  long long v36 = *(_OWORD *)&off_1ED4F0C70;
  memset(v34, 0, sizeof(v34));
  IIODictionary::IIODictionary((IIODictionary *)v34);
  if (height == (double)*((unint64_t *)this + 13) && width == (double)*((unint64_t *)this + 12))
  {
    vImage_Error v10 = (uint64_t *)MEMORY[0x1E4F1CFD0];
    if (*((_DWORD *)this + 41)) {
      IIODictionary::setObjectForKey((IIODictionary *)v34, (const void *)*MEMORY[0x1E4F1CFD0], (const __CFString *)*MEMORY[0x1E4F1DD78]);
    }
    if (CGImageProviderCreate())
    {
      uint64_t v11 = *v10;
      CGImageProviderSetProperty();
      memset(v33, 0, sizeof(v33));
      IIONumber::IIONumber((IIONumber *)v33, *((_DWORD *)this + 22));
      CGImageProviderSetProperty();
      int8x16_t v12 = (CGImage *)CGImageCreateWithImageProvider();
      if (v12)
      {
        int v13 = *((_DWORD *)this + 54);
        double v14 = 4.0;
        if (v13 == 2) {
          double v14 = 8.0;
        }
        unint64_t v15 = IIOAlignRowBytes((unint64_t)(width * v14), 0);
        if (v13 == 2) {
          int v16 = 1815491698;
        }
        else {
          int v16 = 1111970369;
        }
        IOSurfaceWithFormatAndBuffer = IIO_CreateIOSurfaceWithFormatAndBuffer(a5->width, a5->height, v15, v16, (unsigned __int8 *)a5->data, a5->height * v15, 1, 0);
        if (IOSurfaceWithFormatAndBuffer)
        {
          CFStringRef v18 = (const __CFString *)*MEMORY[0x1E4F1DB90];
          CGColorSpaceRef v31 = (CGColorSpaceRef)&unk_1ED4DFD58;
          int v32 = CGColorSpaceCreateWithName(v18);
          IIO_IOSurfaceAddColorSpace(IOSurfaceWithFormatAndBuffer, v32);
          IOSurfaceContext = (CGContext *)IIO_CreateIOSurfaceContext(IOSurfaceWithFormatAndBuffer, v32);
          if (IOSurfaceContext)
          {
            CGContextClear();
            v37.origin.CGFloat x = 0.0;
            v37.origin.CGFloat y = 0.0;
            v37.size.double width = width;
            v37.size.double height = height;
            CGContextDrawImage(IOSurfaceContext, v37, v12);
            CGContextFlush(IOSurfaceContext);
            if (IOSurfaceLock(IOSurfaceWithFormatAndBuffer, 1u, 0))
            {
              unsigned int v20 = -50;
            }
            else
            {
              BaseAddress = IOSurfaceGetBaseAddress(IOSurfaceWithFormatAndBuffer);
              if (BaseAddress)
              {
                if (*((_DWORD *)this + 54) == 1)
                {
                  int v30 = 50331906;
                  int v29 = 50462976;
                  src.data = BaseAddress;
                  *(_OWORD *)&src.double height = *(_OWORD *)&a5->height;
                  src.rowunint64_t Bytes = v15;
                  if (*((unsigned char *)this + 200)) {
                    int v23 = &v29;
                  }
                  else {
                    int v23 = &v30;
                  }
                  vImagePermuteChannels_ARGB8888(&src, a5, (const uint8_t *)v23, 0x10u);
                }
              }
              else
              {
                IOSurfaceRemoveValue(IOSurfaceWithFormatAndBuffer, @"com.apple.ImageIO.ImageIO_Malloced");
              }
              IOSurfaceUnlock(IOSurfaceWithFormatAndBuffer, 1u, 0);
              unsigned int v20 = 0;
            }
            CGContextRelease(IOSurfaceContext);
          }
          else
          {
            unsigned int v20 = -50;
          }
          IIO_IOSurfaceRelease(IOSurfaceWithFormatAndBuffer);
          IIOColorSpace::~IIOColorSpace(&v31);
        }
        else
        {
          unsigned int v20 = -50;
        }
        CGImageRelease(v12);
      }
      else
      {
        unsigned int v20 = -50;
      }
      PropertCGFloat y = CGImageProviderGetProperty();
      CGImageProviderRelease();
      if (Property != v11 || Property == 0) {
        uint64_t v21 = v20;
      }
      else {
        uint64_t v21 = 4294967246;
      }
      IIONumber::~IIONumber((IIONumber *)v33);
    }
    else
    {
      uint64_t v21 = 4294967246;
    }
    if ((gIIODebugFlags & 0x8000300000) != 0)
    {
      CFAbsoluteTime v26 = CFAbsoluteTimeGetCurrent();
      ImageIOLog("COL %s - time: %gms\n", "copy_and_colormatch_CIF10_to_P3_CA", (v26 - Current) * 1000.0);
    }
  }
  else
  {
    uint64_t v21 = 4294967246;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v34);
  return v21;
}

void sub_1887C8334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va2, a9);
  va_start(va1, a9);
  va_start(va, a9);
  CGColorSpaceRef v10 = va_arg(va1, CGColorSpaceRef);
  uint64_t v12 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)va);
  IIONumber::~IIONumber((IIONumber *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)va2);
  _Unwind_Resume(a1);
}

vImage_Error IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_MSR(IIOIOSurfaceWrapper_CIF10 *this, CGRect a2, vImage_Buffer *a3, vImage_Buffer *a4, vImage_Buffer *a5)
{
  double height = a2.size.height;
  double width = a2.size.width;
  CGFloat x = a2.origin.x;
  CGFloat y = a2.origin.y;
  CFTypeRef v47 = 0;
  int v7 = *((_DWORD *)this + 54);
  BOOL v8 = v7 == 5 || v7 == 2;
  if (v8) {
    int v9 = 1380411457;
  }
  else {
    int v9 = 1380401729;
  }
  int v10 = !v8;
  if (v8) {
    int v11 = 8;
  }
  else {
    int v11 = 4;
  }
  uint64_t v12 = IOSurfaceAcceleratorCreate();
  if (v12)
  {
    vImage_Error v18 = v12;
    double v14 = 0;
  }
  else
  {
    IOSurfaceWithFormatAndBuffer = IIO_CreateIOSurfaceWithFormatAndBuffer(a5->width, a5->height, a5->rowBytes, v9, (unsigned __int8 *)a5->data, a5->rowBytes * a5->height, 1, 0);
    double v14 = IOSurfaceWithFormatAndBuffer;
    if (IOSurfaceWithFormatAndBuffer) {
      goto LABEL_16;
    }
    properties[0] = 0;
    properties[1] = 0;
    *(void *)&long long v40 = 0;
    IIODictionary::IIODictionary((IIODictionary *)properties);
    IIONumber::IIONumber((IIONumber *)&v34, (uint64_t)width);
    IIODictionary::setObjectForKey((IIODictionary *)properties, value[0], (const __CFString *)*MEMORY[0x1E4F2F2C0]);
    IIONumber::~IIONumber((IIONumber *)&v34);
    IIONumber::IIONumber((IIONumber *)&v34, (uint64_t)height);
    IIODictionary::setObjectForKey((IIODictionary *)properties, value[0], (const __CFString *)*MEMORY[0x1E4F2F0E8]);
    IIONumber::~IIONumber((IIONumber *)&v34);
    IIONumber::IIONumber((IIONumber *)&v34, v11);
    IIODictionary::setObjectForKey((IIODictionary *)properties, value[0], (const __CFString *)*MEMORY[0x1E4F2EFD8]);
    IIONumber::~IIONumber((IIONumber *)&v34);
    IIONumber::IIONumber((IIONumber *)&v34, v9);
    IIODictionary::setObjectForKey((IIODictionary *)properties, value[0], (const __CFString *)*MEMORY[0x1E4F2F150]);
    IIONumber::~IIONumber((IIONumber *)&v34);
    double v14 = IOSurfaceCreate(properties[1]);
    _cg_jpeg_mem_term("copy_and_colormatch_CIF10_to_P3_MSR", 2338, "*** falling back to standard 'IOSurfaceCreate'\n");
    IIODictionary::~IIODictionary((IIODictionary *)properties);
    if (v14)
    {
LABEL_16:
      IOSurfaceRemoveValue(v14, @"com.apple.ImageIO.ImageIO_Malloced");
      int v46 = 0;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v42 = 0u;
      long long v43 = 0u;
      long long v40 = 0u;
      long long v41 = 0u;
      *(_OWORD *)properties = 0u;
      *(_WORD *)((char *)&v42 + 11) = 2049;
      BYTE5(v45) = 7;
      IOSurfaceSetBulkAttachments2();
      v15.f64[0] = x;
      v15.f64[1] = y;
      uint64x2_t v16 = vcvtq_n_u64_f64(v15, 0x10uLL);
      v15.f64[0] = width;
      v15.f64[1] = height;
      uint64x2_t v34 = v16;
      *(uint64x2_t *)xpc_object_t value = vcvtq_n_u64_f64(v15, 0x10uLL);
      uint64_t v36 = 0;
      unsigned int v37 = width;
      unsigned int v38 = height;
      uint64_t v17 = IOSurfaceAcceleratorTransformSurface();
      if (v17)
      {
        vImage_Error v18 = v17;
        _cg_jpeg_mem_term("copy_and_colormatch_CIF10_to_P3_MSR", 2373, "*** TransformSurface-band err 0x%x (%d)\n", v18, v18);
        goto LABEL_26;
      }
      if (v10)
      {
        *(_DWORD *)permuteMap = 50331906;
        int v32 = 50462976;
        if (IOSurfaceWithFormatAndBuffer)
        {
          if (*((unsigned char *)this + 200))
          {
            vImage_Error v18 = vImagePermuteChannels_ARGB8888(a5, a5, permuteMap, 0x10u);
            goto LABEL_26;
          }
        }
        else if (!IOSurfaceLock(v14, 1u, 0))
        {
          BaseAddress = IOSurfaceGetBaseAddress(v14);
          unsigned int BytesPerRow = IOSurfaceGetBytesPerRow(v14);
          dest.data = BaseAddress;
          *(_OWORD *)&dest.double height = *(_OWORD *)&a5->height;
          dest.rowunint64_t Bytes = BytesPerRow;
          if (*((unsigned char *)this + 200)) {
            CFAbsoluteTime v26 = permuteMap;
          }
          else {
            CFAbsoluteTime v26 = (uint8_t *)&v32;
          }
          vImage_Error v18 = vImagePermuteChannels_ARGB8888(&dest, a5, v26, 0x10u);
          IOSurfaceUnlock(v14, 1u, 0);
          goto LABEL_26;
        }
      }
      else if (*((_DWORD *)this + 54) == 2)
      {
        unsigned int v19 = IOSurfaceGetBaseAddress(v14);
        unsigned int v20 = IOSurfaceGetBytesPerRow(v14);
        vImagePixelCount v21 = a5->height;
        vImagePixelCount v22 = a5->width;
        dest.data = v19;
        dest.double height = v21;
        dest.double width = 4 * v22;
        dest.rowunint64_t Bytes = v20;
        vImageConvert_16Fto16U(&dest, &dest, 0);
      }
    }
    vImage_Error v18 = 0;
  }
LABEL_26:
  IIO_IOSurfaceRelease(v14);
  if (v47) {
    CFRelease(v47);
  }
  return v18;
}

void sub_1887C8750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

uint64_t IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_vImage(IIOIOSurfaceWrapper_CIF10 *this, CGRect a2, vImage_Buffer *a3, vImage_Buffer *a4, vImage_Buffer *a5)
{
  double Current = CFAbsoluteTimeGetCurrent();
  int v9 = *((_DWORD *)this + 41);
  CFStringRef v10 = (const __CFString *)*MEMORY[0x1E4F1DBE8];
  CGColorSpaceRef v64 = (CGColorSpaceRef)&unk_1ED4DFD58;
  CFDictionaryRef v65 = CGColorSpaceCreateWithName(v10);
  CFStringRef v11 = (const __CFString *)*MEMORY[0x1E4F1DB90];
  CGColorSpaceRef v62 = (CGColorSpaceRef)&unk_1ED4DFD58;
  uint64_t v63 = CGColorSpaceCreateWithName(v11);
  CFStringRef v12 = (const __CFString *)*MEMORY[0x1E4F1DC98];
  CGColorSpaceRef v60 = (CGColorSpaceRef)&unk_1ED4DFD58;
  long long v61 = CGColorSpaceCreateWithName(v12);
  v59[0] = (CGColorSpaceRef)&unk_1ED4DFD58;
  uint64_t v13 = CGColorSpaceCreateWithName(v11);
  v59[1] = v13;
  *(void *)&v58.renderingIntent = 0;
  *(void *)&v58.bitsPerComponent = 0x4000000010;
  v58.colorSpace = v65;
  if (v9) {
    CGBitmapInfo v14 = 4353;
  }
  else {
    CGBitmapInfo v14 = 4357;
  }
  v58.bitmapInfo = v14;
  *(_OWORD *)&v58.version = 0uLL;
  *(void *)&v57.bitsPerComponent = 0x4000000010;
  v57.colorSpace = v63;
  v57.bitmapInfo = v14;
  memset(&v57.version, 0, 20);
  v56[0] = 0;
  v56[1] = 0;
  IIOColorConverter::IIOColorConverter((IIOColorConverter *)v56, &v58, &v57, v61, v13);
  vImagePixelCount width = a5->width;
  uint64x2_t v16 = malloc_type_malloc(width << 9, 0x4606608uLL);
  uint64_t v17 = malloc_type_malloc(width << 9, 0xCFBB36ABuLL);
  if ((gIIODebugFlags & 0x8000300000) != 0) {
    ImageIOLog("COL copy_and_colormatch_CIF10_to_P3_vImage: allocating FP16 buffers: 2 x %ld = %ld\n", width << 9, width << 10);
  }
  v55.data = v16;
  v55.vImagePixelCount height = 64;
  v54.data = v17;
  v54.vImagePixelCount height = 64;
  vImagePixelCount v18 = a5->width;
  rowunint64_t Bytes = a5->rowBytes;
  v55.vImagePixelCount width = v18;
  v55.rowunint64_t Bytes = 8 * width;
  v54.vImagePixelCount width = v18;
  v54.rowunint64_t Bytes = 8 * width;
  long long v19 = *(_OWORD *)&a3->width;
  *(_OWORD *)&v53.data = *(_OWORD *)&a3->data;
  *(_OWORD *)&v53.vImagePixelCount width = v19;
  memset(&v52, 0, sizeof(v52));
  if (a4)
  {
    long long v20 = *(_OWORD *)&a4->width;
    *(_OWORD *)&v52.data = *(_OWORD *)&a4->data;
    *(_OWORD *)&v52.vImagePixelCount width = v20;
  }
  long long v44 = v17;
  long long v45 = v16;
  vImagePixelCount height = a5->height;
  if (height)
  {
    int v46 = a4;
    vImagePixelCount v22 = 0;
    vImagePixelCount v48 = 4 * v18;
    uint64_t v23 = 4294967246;
    vImagePixelCount v24 = 64;
    vImagePixelCount v25 = 64;
    while (v22 + v25 <= height)
    {
      v53.vImagePixelCount height = v25;
      v52.vImagePixelCount height = v25;
      if (v24) {
        goto LABEL_14;
      }
      v22 += v25;
LABEL_54:
      if (v22 >= height) {
        goto LABEL_57;
      }
    }
    vImagePixelCount v25 = (height - v22);
    v55.vImagePixelCount height = v25;
    v54.vImagePixelCount height = v25;
    v53.vImagePixelCount height = v25;
    v52.vImagePixelCount height = v25;
    vImagePixelCount v24 = v25;
    if (height == v22) {
      goto LABEL_57;
    }
LABEL_14:
    int v26 = *((_DWORD *)this + 22);
    if (v26 == 1647534392)
    {
      v53.data = (char *)a3->data + *((void *)this + 14) * v22;
      v52.data = (char *)v46->data + *((void *)this + 30) * v22;
      int v27 = IIOIOSurfaceWrapper_CIF10::convert_b3a8_to_ARGB16F(this, &v53, &v52, &v55);
      goto LABEL_18;
    }
    if (v26 == 1999843442)
    {
      v53.data = (char *)a3->data + *((void *)this + 14) * v22;
      int v27 = IIOIOSurfaceWrapper_CIF10::convert_w30r_to_ARGB16F(this, &v53, &v55);
LABEL_18:
      LODWORD(v23) = v27;
LABEL_44:
      if (v23) {
        _cg_jpeg_mem_term("copy_and_colormatch_CIF10_to_P3_vImage", 2510, "*** ERROR: conversion from CIF10 to FP16 failed: %d\n", v23);
      }
      int v38 = IIOColorConverter::colorConvert((IIOColorConverter *)v56, &v55, &v54);
      if (v38) {
        _cg_jpeg_mem_term("copy_and_colormatch_CIF10_to_P3_vImage", 2517, "*** ERROR: color conversion fp16_xsRGB to fp16_P3 failed: %d\n", v38);
      }
      int v39 = (char *)a5->data + a5->rowBytes * v22;
      *(_OWORD *)&src.data = *(_OWORD *)&v54.data;
      src.rowunint64_t Bytes = v54.rowBytes;
      dest.data = v39;
      dest.vImagePixelCount height = v24;
      src.vImagePixelCount width = 4 * v54.width;
      dest.vImagePixelCount width = v48;
      dest.rowunint64_t Bytes = rowBytes;
      if (*((_DWORD *)this + 54) == 1)
      {
        vImage_Error v40 = vImageConvert_Planar16FtoPlanar8(&src, &dest, 0x10u);
        uint64_t v23 = v40;
        if (v40) {
          _cg_jpeg_mem_term("copy_and_colormatch_CIF10_to_P3_vImage", 2536, "*** ERROR: vImageConvert_Planar16FtoPlanar8 err: %d\n", v40);
        }
      }
      else
      {
        vImage_Error v41 = vImageConvert_16Fto16U(&src, &dest, 0x10u);
        uint64_t v23 = v41;
        if (v41) {
          _cg_jpeg_mem_term("copy_and_colormatch_CIF10_to_P3_vImage", 2548, "*** ERROR: vImageConvert_16Fto16U err: %d\n", v41);
        }
      }
      vImagePixelCount height = a5->height;
      v22 += v25;
      goto LABEL_54;
    }
    unsigned int v28 = v26 >> 24;
    if (v26 < 0)
    {
      int v29 = __maskrune(v28, 0x40000uLL);
      int v26 = *((_DWORD *)this + 22);
    }
    else
    {
      int v29 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v28 + 60) & 0x40000;
    }
    if (v29) {
      uint64_t v30 = (v26 >> 24);
    }
    else {
      uint64_t v30 = 46;
    }
    unsigned int v31 = v26 << 8 >> 24;
    if (v26 << 8 < 0)
    {
      int v32 = __maskrune(v31, 0x40000uLL);
      int v26 = *((_DWORD *)this + 22);
    }
    else
    {
      int v32 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v31 + 60) & 0x40000;
    }
    if (v32) {
      uint64_t v33 = (v26 << 8 >> 24);
    }
    else {
      uint64_t v33 = 46;
    }
    unsigned int v34 = (__int16)v26 >> 8;
    if (v26 << 16 < 0)
    {
      int v35 = __maskrune(v34, 0x40000uLL);
      int v26 = *((_DWORD *)this + 22);
    }
    else
    {
      int v35 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v34 + 60) & 0x40000;
    }
    if (v35) {
      uint64_t v36 = ((__int16)v26 >> 8);
    }
    else {
      uint64_t v36 = 46;
    }
    if ((v26 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v26 + 60) & 0x40000) != 0) {
        goto LABEL_40;
      }
    }
    else if (__maskrune((char)v26, 0x40000uLL))
    {
LABEL_40:
      int v37 = *((_DWORD *)this + 22);
LABEL_43:
      _cg_jpeg_mem_term("copy_and_colormatch_CIF10_to_P3_vImage", 2506, "*** ERROR - check the _surfacePixelFormat case '%c%c%c%c'\n", v30, v33, v36, (char)v37);
      goto LABEL_44;
    }
    LOBYTE(v37) = 46;
    goto LABEL_43;
  }
  uint64_t v23 = 4294967246;
LABEL_57:
  if (v45) {
    free(v45);
  }
  if (v44) {
    free(v44);
  }
  if ((gIIODebugFlags & 0x8000300000) != 0)
  {
    CFAbsoluteTime v42 = CFAbsoluteTimeGetCurrent();
    ImageIOLog("COL %s - time: %gms\n", "copy_and_colormatch_CIF10_to_P3_vImage", (v42 - Current) * 1000.0);
  }
  IIOColorConverter::~IIOColorConverter((IIOColorConverter *)v56);
  IIOColorSpace::~IIOColorSpace(v59);
  IIOColorSpace::~IIOColorSpace(&v60);
  IIOColorSpace::~IIOColorSpace(&v62);
  IIOColorSpace::~IIOColorSpace(&v64);
  return v23;
}

void sub_1887C8D88(_Unwind_Exception *a1)
{
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)(v1 - 176));
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)(v1 - 160));
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)(v1 - 144));
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)(v1 - 128));
  _Unwind_Resume(a1);
}

vImage_Error IIOIOSurfaceWrapper_CIF10::convert_w30r_to_ARGB16F(IIOIOSurfaceWrapper_CIF10 *this, vImage_Buffer *src, vImage_Buffer *dest)
{
  *(_DWORD *)permuteMap = 197121;
  vImage_Error v3 = vImageConvert_XRGB2101010ToARGB16F(src, 1.0, dest, *((_DWORD *)this + 64), *((_DWORD *)this + 65), permuteMap, 0x810u);
  if (v3) {
    kdebug_trace();
  }
  return v3;
}

uint64_t IIOIOSurfaceWrapper_CIF10::convert_b3a8_to_ARGB16F(IIOIOSurfaceWrapper_CIF10 *this, vImage_Buffer *a2, vImage_Buffer *a3, vImage_Buffer *a4)
{
  if (*((void *)this + 16) != 2) {
    return 4294967246;
  }
  *(_DWORD *)permuteMap = 197121;
  uint64_t v5 = vImageConvert_XRGB2101010_A8ToARGB16F();
  if (v5 || (uint64_t v5 = vImagePermuteChannels_ARGB16U(a4, a4, permuteMap, 0x10u), v5)) {
    kdebug_trace();
  }
  return v5;
}

uint64_t IIOIOSurfaceWrapper_CIF10::copyImageBlockSet_8bit(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  long long v30 = xmmword_1ED4F0C90;
  long long v31 = xmmword_1ED4F0C80;
  int ColorMatchMode = IIOIOSurfaceWrapper_CIF10::getColorMatchMode((IIOIOSurfaceWrapper_CIF10 *)a1, *(CGRect *)&a2);
  if (IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0)) {
    goto LABEL_23;
  }
  BaseAddress = (char *)IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(a1 + 72));
  BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 72), 1uLL);
  if (!BaseAddress)
  {
    _cg_jpeg_mem_term("copyImageBlockSet_8bit", 2627, "*** IOSurfaceGetBaseAddress returned NULL -- (protected: %s)\n");
LABEL_22:
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
    goto LABEL_23;
  }
  size_t v18 = *(void *)(a1 + 112);
  double v19 = a2 * (double)*(unint64_t *)(a1 + 120);
  long long v20 = &BaseAddress[(unint64_t)v19 + (unint64_t)(a3 * (double)v18)];
  unint64_t v21 = *(void *)(a1 + 240);
  if (BaseAddressOfPlane)
  {
    double v19 = a2 * (double)*(unint64_t *)(a1 + 248);
    unint64_t v22 = (unint64_t)BaseAddressOfPlane + (unint64_t)v19 + (unint64_t)(a3 * (double)v21);
  }
  else
  {
    unint64_t v22 = 0;
  }
  v29.data = v20;
  v29.vImagePixelCount height = (unint64_t)a5;
  v29.vImagePixelCount width = (unint64_t)a4;
  v29.rowunint64_t Bytes = v18;
  v28.data = *(void **)(a1 + 168);
  v28.vImagePixelCount height = (unint64_t)a5;
  size_t v23 = *(unsigned int *)(a1 + 184);
  v28.vImagePixelCount width = (unint64_t)a4;
  v28.rowunint64_t Bytes = v23;
  v27[0] = v22;
  v27[1] = (unint64_t)a5;
  v27[2] = (unint64_t)a4;
  void v27[3] = v21;
  if (v22) {
    vImagePixelCount v24 = (vImage_Buffer *)v27;
  }
  else {
    vImagePixelCount v24 = 0;
  }
  if (*(unsigned char *)(a1 + 272))
  {
    int v25 = IIOIOSurfaceWrapper_CIF10::copy_CIF10_8bit_sRGB((IIOIOSurfaceWrapper_CIF10 *)a1, &v29, v24, &v28);
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
    if (!v25) {
      goto LABEL_25;
    }
LABEL_23:
    _ImageIO_Free(*(void *)(a1 + 168), *(void *)(a1 + 176));
    uint64_t result = 0;
    *(void *)(a1 + 168) = 0;
    return result;
  }
  if (ColorMatchMode == 2)
  {
    v33.origin.CGFloat x = a2;
    v33.origin.CGFloat y = a3;
    v33.size.vImagePixelCount width = a4;
    v33.size.vImagePixelCount height = a5;
    if (!IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_MSR((IIOIOSurfaceWrapper_CIF10 *)a1, v33, v13, v14, &v28))goto LABEL_24; {
    *(void *)&double v19 = _cg_jpeg_mem_term("copyImageBlockSet_8bit", 2659, "*** ERROR: copy_and_colormatch_CIF10_to_P3_MSR returned: %d\n").n128_u64[0];
    }
  }
  else if (ColorMatchMode == 1 && !*(unsigned char *)(a1 + 267))
  {
    v32.origin.CGFloat x = a2;
    v32.origin.CGFloat y = a3;
    v32.size.vImagePixelCount width = a4;
    v32.size.vImagePixelCount height = a5;
    if (!IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_CA((IIOIOSurfaceWrapper_CIF10 *)a1, v32, v13, v14, &v28))goto LABEL_24; {
    *(void *)&double v19 = _cg_jpeg_mem_term("copyImageBlockSet_8bit", 2651, "*** ERROR: copy_and_colormatch_CIF10_to_P3_CA returned: %d\n").n128_u64[0];
    }
  }
  if (IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_vImage((IIOIOSurfaceWrapper_CIF10 *)a1, *(CGRect *)(&v15 - 1), &v29, v24, &v28))
  {
    _cg_jpeg_mem_term("copyImageBlockSet_8bit", 2665, "*** ERROR: copy_and_colormatch_CIF10_to_P3_vImage returned: %d\n");
    goto LABEL_22;
  }
LABEL_24:
  IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
LABEL_25:
  v29.data = (void *)CGImageBlockCreate();
  return CGImageBlockSetCreate();
}

uint64_t IIOIOSurfaceWrapper_CIF10::getColorMatchMode(IIOIOSurfaceWrapper_CIF10 *this, CGRect a2)
{
  unsigned int v2 = *((_DWORD *)this + 67);
  if (gCanUseMSRForColorConversion) {
    unsigned int v3 = 2;
  }
  else {
    unsigned int v3 = 3;
  }
  if (v2) {
    uint64_t v4 = v2;
  }
  else {
    uint64_t v4 = v3;
  }
  if (v4 == 1)
  {
    double height = a2.size.height;
    double width = a2.size.width;
    uint64_t v4 = 3;
    if ((IIOIsAppSuspended() & 1) == 0)
    {
      unint64_t v8 = *((void *)this + 12);
      unint64_t v9 = *((void *)this + 13);
      uint64_t v4 = (v9 * v8) >> 7 >= 0xE1 ? 1 : 3;
      if (width != (double)v8 || height != (double)v9)
      {
        if (gCanUseMSRForColorConversion) {
          BOOL v11 = *((_DWORD *)this + 54) == 1;
        }
        else {
          BOOL v11 = 0;
        }
        if (v11) {
          return 2;
        }
        else {
          return 3;
        }
      }
    }
  }
  return v4;
}

uint64_t IIOIOSurfaceWrapper_CIF10::copyImageBlockSet_16bit(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  long long v57 = xmmword_1ED4F0C90;
  long long v58 = xmmword_1ED4F0C80;
  uint64_t v56 = 0;
  int ColorMatchMode = IIOIOSurfaceWrapper_CIF10::getColorMatchMode((IIOIOSurfaceWrapper_CIF10 *)a1, *(CGRect *)&a2);
  if (IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0))
  {
LABEL_2:
    int v11 = -50;
    goto LABEL_3;
  }
  BaseAddress = (char *)IOSurfaceGetBaseAddress(*(IOSurfaceRef *)(a1 + 72));
  BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 72), 1uLL);
  if (!BaseAddress)
  {
    if (*(unsigned char *)(a1 + 140)) {
      int v37 = "YES";
    }
    else {
      int v37 = "NO";
    }
    _cg_jpeg_mem_term("copyImageBlockSet_16bit", 2716, "*** IOSurfaceGetBaseAddress returned NULL -- (protected: %s)\n", v37);
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
    goto LABEL_2;
  }
  size_t v23 = *(void *)(a1 + 112);
  double v24 = a2 * (double)*(unint64_t *)(a1 + 120);
  int v25 = &BaseAddress[(unint64_t)v24 + (unint64_t)(a3 * (double)v23)];
  unint64_t v26 = *(void *)(a1 + 240);
  if (BaseAddressOfPlane)
  {
    double v24 = a2 * (double)*(unint64_t *)(a1 + 248);
    unint64_t v27 = (unint64_t)BaseAddressOfPlane + (unint64_t)v24 + (unint64_t)(a3 * (double)v26);
  }
  else
  {
    unint64_t v27 = 0;
  }
  v55.data = v25;
  v55.double height = (unint64_t)a5;
  v55.double width = (unint64_t)a4;
  v55.rowunint64_t Bytes = v23;
  v54.data = *(void **)(a1 + 168);
  v54.double height = (unint64_t)a5;
  size_t v38 = *(unsigned int *)(a1 + 184);
  v54.double width = (unint64_t)a4;
  v54.rowunint64_t Bytes = v38;
  v53[0] = v27;
  v53[1] = (unint64_t)a5;
  v53[2] = (unint64_t)a4;
  v53[3] = v26;
  if (v27) {
    int v39 = (vImage_Buffer *)v53;
  }
  else {
    int v39 = 0;
  }
  int v40 = *(_DWORD *)(a1 + 88);
  if (v40 != 1999843442 && v40 != 1647534392)
  {
    unsigned int v42 = v40 >> 24;
    if (v40 < 0)
    {
      int v43 = __maskrune(v42, 0x40000uLL);
      int v40 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      int v43 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v42 + 60) & 0x40000;
    }
    if (v43) {
      uint64_t v45 = (v40 >> 24);
    }
    else {
      uint64_t v45 = 46;
    }
    unsigned int v46 = v40 << 8 >> 24;
    if (v40 << 8 < 0)
    {
      int v47 = __maskrune(v46, 0x40000uLL);
      int v40 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      int v47 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v46 + 60) & 0x40000;
    }
    if (v47) {
      uint64_t v48 = (v40 << 8 >> 24);
    }
    else {
      uint64_t v48 = 46;
    }
    unsigned int v49 = (__int16)v40 >> 8;
    if (v40 << 16 < 0)
    {
      int v50 = __maskrune(v49, 0x40000uLL);
      int v40 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      int v50 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v49 + 60) & 0x40000;
    }
    if (v50) {
      uint64_t v51 = ((__int16)v40 >> 8);
    }
    else {
      uint64_t v51 = 46;
    }
    if ((v40 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v40 + 60) & 0x40000) != 0) {
        goto LABEL_67;
      }
    }
    else if (__maskrune((char)v40, 0x40000uLL))
    {
LABEL_67:
      uint64_t v52 = *(char *)(a1 + 88);
LABEL_70:
      LogError("copyImageBlockSet_16bit", 2761, "*** pixelFormat '%c%c%c%c' not supported\n", v45, v48, v51, v52);
      int v11 = -4;
      goto LABEL_71;
    }
    uint64_t v52 = 46;
    goto LABEL_70;
  }
  if (*(_DWORD *)(a1 + 216) == 5)
  {
    int v41 = IIOIOSurfaceWrapper_CIF10::copy_to_CIF10_FP16_xsRGB((IIOIOSurfaceWrapper_CIF10 *)a1, &v55, v19, &v54);
    if (v41)
    {
      int v11 = v41;
      _cg_jpeg_mem_term("copyImageBlockSet_16bit", 2738, "*** ERROR: copy_to_CIF10_FP16_xsRGB returned: %d\n", v41);
LABEL_71:
      IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
      goto LABEL_3;
    }
    goto LABEL_76;
  }
  if (ColorMatchMode != 1)
  {
    if (ColorMatchMode != 2) {
      goto LABEL_74;
    }
    v59.origin.CGFloat x = a2;
    v59.origin.CGFloat y = a3;
    v59.size.double width = a4;
    v59.size.double height = a5;
    int v44 = IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_MSR((IIOIOSurfaceWrapper_CIF10 *)a1, v59, v18, v19, &v54);
    if (v44)
    {
      *(void *)&double v24 = _cg_jpeg_mem_term("copyImageBlockSet_16bit", 2746, "*** ERROR: copy_and_colormatch_CIF10_to_P3_MSR returned: %d\n", v44).n128_u64[0];
      goto LABEL_74;
    }
LABEL_76:
    IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
    goto LABEL_77;
  }
  if (!*(unsigned char *)(a1 + 267))
  {
    v60.origin.CGFloat x = a2;
    v60.origin.CGFloat y = a3;
    v60.size.double width = a4;
    v60.size.double height = a5;
    if (!IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_CA((IIOIOSurfaceWrapper_CIF10 *)a1, v60, v18, v19, &v54))goto LABEL_76; {
  }
    }
LABEL_74:
  int v11 = IIOIOSurfaceWrapper_CIF10::copy_and_colormatch_CIF10_to_P3_vImage((IIOIOSurfaceWrapper_CIF10 *)a1, *(CGRect *)(&v20 - 1), &v55, v39, &v54);
  IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
  if (v11)
  {
LABEL_3:
    kdebug_trace();
    int v12 = *(_DWORD *)(a1 + 88);
    unsigned int v13 = v12 >> 24;
    uint64_t v14 = MEMORY[0x1E4F14390];
    if (v12 < 0)
    {
      int v15 = __maskrune(v13, 0x40000uLL);
      int v12 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      int v15 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v13 + 60) & 0x40000;
    }
    if (v15) {
      uint64_t v28 = (v12 >> 24);
    }
    else {
      uint64_t v28 = 46;
    }
    unsigned int v29 = v12 << 8 >> 24;
    if (v12 << 8 < 0)
    {
      int v30 = __maskrune(v29, 0x40000uLL);
      int v12 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      int v30 = *(_DWORD *)(v14 + 4 * v29 + 60) & 0x40000;
    }
    if (v30) {
      uint64_t v31 = (v12 << 8 >> 24);
    }
    else {
      uint64_t v31 = 46;
    }
    unsigned int v32 = (__int16)v12 >> 8;
    if (v12 << 16 < 0)
    {
      int v33 = __maskrune(v32, 0x40000uLL);
      int v12 = *(_DWORD *)(a1 + 88);
    }
    else
    {
      int v33 = *(_DWORD *)(v14 + 4 * v32 + 60) & 0x40000;
    }
    if (v33) {
      uint64_t v34 = ((__int16)v12 >> 8);
    }
    else {
      uint64_t v34 = 46;
    }
    if ((v12 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v14 + 4 * (char)v12 + 60) & 0x40000) != 0) {
        goto LABEL_26;
      }
    }
    else if (__maskrune((char)v12, 0x40000uLL))
    {
LABEL_26:
      uint64_t v35 = *(char *)(a1 + 88);
LABEL_29:
      LogError("copyImageBlockSet_16bit", 2781, "*** copyImageBlockSet_16bit '%c%c%c%c' failed: err=%d\n", v28, v31, v34, v35, v11);
      _ImageIO_Free(*(void *)(a1 + 168), *(void *)(a1 + 176));
      uint64_t result = 0;
      *(void *)(a1 + 168) = 0;
      return result;
    }
    uint64_t v35 = 46;
    goto LABEL_29;
  }
LABEL_77:
  uint64_t v56 = CGImageBlockCreate();
  return CGImageBlockSetCreate();
}

uint64_t IIOIOSurfaceWrapper_CIF10::copyImageBlockSetWithOptions8Bit(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  uint64_t v20 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, double, double, double, double, double, double))(*(void *)a1 + 40))(a1, 8, a3, a5, a6, a7, a8, a9, a10);
  if (v21) {
    uint64_t v22 = 0;
  }
  else {
    uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, double, double, double, double, double, double))(*(void *)a1 + 24))(a1, a2, a3, a5, a6, a7, a8, a9, a10);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
  if (v21) {
    _cg_jpeg_mem_term("copyImageBlockSetWithOptions8Bit", 3025, "*** ERROR: copyImageBlockSetWithOptions8Bit err = %d\n", v21);
  }
  *a4 = (*(uint64_t (**)(uint64_t, uint64_t, double, double, double, double))(*(void *)a1 + 64))(a1, v21, a5, a6, a7, a8);
  pthread_mutex_unlock(v20);
  return v22;
}

uint64_t IIOIOSurfaceWrapper_CIF10::copyImageBlockSetWithOptions16Bit(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  uint64_t v20 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, double, double, double, double, double, double))(*(void *)a1 + 40))(a1, 16, a3, a5, a6, a7, a8, a9, a10);
  if (v21) {
    uint64_t v22 = 0;
  }
  else {
    uint64_t v22 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, double, double, double, double, double, double))(*(void *)a1 + 32))(a1, a2, a3, a5, a6, a7, a8, a9, a10);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
  if (v21) {
    _cg_jpeg_mem_term("copyImageBlockSetWithOptions16Bit", 3060, "*** ERROR: copyImageBlockSetWithOptions16Bit err = %d\n", v21);
  }
  *a4 = (*(uint64_t (**)(uint64_t, uint64_t, double, double, double, double))(*(void *)a1 + 64))(a1, v21, a5, a6, a7, a8);
  pthread_mutex_unlock(v20);
  return v22;
}

uint64_t IIOIOSurfaceWrapper_CIF10::preCopyBlockSet(IIOIOSurfaceWrapper_CIF10 *this, unsigned int a2, CGRect a3, CGSize a4, IIODictionary *a5)
{
  double height = a3.size.height;
  double width = a3.size.width;
  IIOIOSurfaceWrapperBase::preCopyBlockSet(this, a2, a3, a4, a5);
  int v9 = IIO_CGImageBlockSetBytesPerPixelForPixelFormat(*((_DWORD *)this + 22));
  unsigned int v10 = (a2 + 7) >> 3;
  if (a2 <= 8) {
    unsigned int v10 = 1;
  }
  unsigned int v11 = IIOAlignRowBytes((unint64_t)(width * (double)(v9 * v10)), 0);
  *((_DWORD *)this + 46) = v11;
  if (is_mul_ok((unint64_t)height, v11)) {
    *((void *)this + 21) = _ImageIO_Malloc((unint64_t)height * v11, 64, (memory_object_size_t *)this + 22, (uint64_t)kImageMalloc_IOSurface_Data, 0, 0, 0);
  }
  return 0;
}

unint64_t IIOIOSurfaceWrapper_CIF10::packDebugInfo(IIOIOSurfaceWrapper_CIF10 *this, CGRect a2, uint64_t a3)
{
  unint64_t result = IIOIOSurfaceWrapperBase::packDebugInfo(this, a2, a3);
  if (*((unsigned char *)this + 200)) {
    result |= 0x1000uLL;
  }
  return result;
}

void IIOIOSurfaceWrapper_YCC::IIOIOSurfaceWrapper_YCC(IIOIOSurfaceWrapper_YCC *this, __IOSurface *a2, size_t a3, size_t a4, int a5, CGImageAlphaInfo a6, IIODictionary *a7)
{
  IIOIOSurfaceWrapperBase::IIOIOSurfaceWrapperBase(this, a2, a3, a4, a5, a6, a7);
  int v9 = (void (**)(IIOIOSurfaceWrapper_YCC *, IIODictionary *, void))&unk_1ED4B4288;
  *unsigned int v10 = &unk_1ED4B4288;
  if (v10[16] < 2uLL)
  {
    *((_OWORD *)this + 14) = 0u;
    *((_OWORD *)this + 15) = 0u;
  }
  else
  {
    *((void *)this + 28) = IOSurfaceGetWidthOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    *((void *)this + 29) = IOSurfaceGetHeightOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    *((void *)this + 30) = IOSurfaceGetBytesPerRowOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    *((void *)this + 31) = IOSurfaceGetBytesPerElementOfPlane(*((IOSurfaceRef *)this + 9), 1uLL);
    int v9 = *(void (***)(IIOIOSurfaceWrapper_YCC *, IIODictionary *, void))this;
  }
  v9[7](this, a7, 0);
}

void sub_1887C9DC8(_Unwind_Exception *a1)
{
  IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(v1);
  _Unwind_Resume(a1);
}

void IIOIOSurfaceWrapper_YCC::~IIOIOSurfaceWrapper_YCC(IIOIOSurfaceWrapper_YCC *this)
{
  IIOIOSurfaceWrapperBase::~IIOIOSurfaceWrapperBase(this);

  JUMPOUT(0x18C11C0E0);
}

void IIOIOSurfaceWrapper_YCC::completeSetup(IIOIOSurfaceWrapper_YCC *this, IIODictionary *a2, const __CFString *a3)
{
  int v4 = *((_DWORD *)this + 22);
  if (v4 > 2016687155)
  {
    if (v4 <= 2019963441)
    {
      if (v4 != 2016687156 && v4 != 2019963440) {
        goto LABEL_12;
      }
      goto LABEL_21;
    }
    BOOL v10 = v4 == 2019963442;
    int v11 = 2019963956;
LABEL_16:
    if (!v10 && v4 != v11) {
      goto LABEL_12;
    }
LABEL_21:
    *((_DWORD *)this + 54) = 6;
    CFStringRef v6 = (const __CFString *)*MEMORY[0x1E4F1DBE8];
    *((_DWORD *)this + 41) = 0;
    goto LABEL_22;
  }
  if (v4 > 2016686639)
  {
    BOOL v10 = v4 == 2016686640;
    int v11 = 2016686642;
    goto LABEL_16;
  }
  if (v4 == 875704422 || v4 == 875704438)
  {
    *((_DWORD *)this + 54) = 1;
    CFStringRef v6 = (const __CFString *)*MEMORY[0x1E4F1DC98];
    *((_DWORD *)this + 41) = 5;
    goto LABEL_22;
  }
LABEL_12:
  unsigned int v7 = v4 >> 24;
  uint64_t v8 = MEMORY[0x1E4F14390];
  if (v4 < 0)
  {
    int v9 = __maskrune(v7, 0x40000uLL);
    int v4 = *((_DWORD *)this + 22);
  }
  else
  {
    int v9 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v7 + 60) & 0x40000;
  }
  if (v9) {
    uint64_t v13 = (v4 >> 24);
  }
  else {
    uint64_t v13 = 46;
  }
  unsigned int v14 = v4 << 8 >> 24;
  if (v4 << 8 < 0)
  {
    int v15 = __maskrune(v14, 0x40000uLL);
    int v4 = *((_DWORD *)this + 22);
  }
  else
  {
    int v15 = *(_DWORD *)(v8 + 4 * v14 + 60) & 0x40000;
  }
  if (v15) {
    uint64_t v16 = (v4 << 8 >> 24);
  }
  else {
    uint64_t v16 = 46;
  }
  unsigned int v17 = (__int16)v4 >> 8;
  if (v4 << 16 < 0)
  {
    int v18 = __maskrune(v17, 0x40000uLL);
    int v4 = *((_DWORD *)this + 22);
  }
  else
  {
    int v18 = *(_DWORD *)(v8 + 4 * v17 + 60) & 0x40000;
  }
  if (v18) {
    uint64_t v19 = ((__int16)v4 >> 8);
  }
  else {
    uint64_t v19 = 46;
  }
  if ((v4 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v8 + 4 * (char)v4 + 60) & 0x40000) != 0) {
      goto LABEL_43;
    }
LABEL_45:
    uint64_t v20 = 46;
    goto LABEL_46;
  }
  if (!__maskrune((char)v4, 0x40000uLL)) {
    goto LABEL_45;
  }
LABEL_43:
  uint64_t v20 = *((char *)this + 88);
LABEL_46:
  LogError("completeSetup", 3130, "*** pixelformat '%c%c%c%c' not handled\n", v13, v16, v19, v20);
  CFStringRef v6 = 0;
LABEL_22:

  IIOIOSurfaceWrapperBase::completeSetup(this, a2, v6);
}

uint64_t IIOIOSurfaceWrapper_YCC::createImage(IIOIOSurfaceWrapper_YCC *this)
{
  int v2 = *((_DWORD *)this + 22);
  if (v2 > 2016687155)
  {
    if (v2 > 2019963441)
    {
      BOOL v3 = v2 == 2019963956;
      unsigned __int16 v5 = 12850;
    }
    else
    {
      BOOL v3 = v2 == 2016687156;
      unsigned __int16 v5 = 12848;
    }
    int v4 = v5 | 0x78660000;
  }
  else if (v2 > 2016686639)
  {
    BOOL v3 = v2 == 2016686640;
    int v4 = 2016686642;
  }
  else
  {
    BOOL v3 = v2 == 875704422;
    int v4 = 875704438;
  }
  if (!v3 && v2 != v4)
  {
    unsigned int v8 = v2 >> 24;
    uint64_t v9 = MEMORY[0x1E4F14390];
    if (v2 < 0)
    {
      int v10 = __maskrune(v8, 0x40000uLL);
      int v2 = *((_DWORD *)this + 22);
    }
    else
    {
      int v10 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v8 + 60) & 0x40000;
    }
    if (v10) {
      uint64_t v11 = (v2 >> 24);
    }
    else {
      uint64_t v11 = 46;
    }
    unsigned int v12 = v2 << 8 >> 24;
    if (v2 << 8 < 0)
    {
      int v13 = __maskrune(v12, 0x40000uLL);
      int v2 = *((_DWORD *)this + 22);
    }
    else
    {
      int v13 = *(_DWORD *)(v9 + 4 * v12 + 60) & 0x40000;
    }
    if (v13) {
      uint64_t v14 = (v2 << 8 >> 24);
    }
    else {
      uint64_t v14 = 46;
    }
    unsigned int v15 = (__int16)v2 >> 8;
    if (v2 << 16 < 0)
    {
      int v16 = __maskrune(v15, 0x40000uLL);
      int v2 = *((_DWORD *)this + 22);
    }
    else
    {
      int v16 = *(_DWORD *)(v9 + 4 * v15 + 60) & 0x40000;
    }
    if (v16) {
      uint64_t v17 = ((__int16)v2 >> 8);
    }
    else {
      uint64_t v17 = 46;
    }
    if ((v2 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v9 + 4 * (char)v2 + 60) & 0x40000) != 0) {
        goto LABEL_37;
      }
    }
    else if (__maskrune((char)v2, 0x40000uLL))
    {
LABEL_37:
      uint64_t v18 = *((char *)this + 88);
LABEL_40:
      _cg_jpeg_mem_term("createImage", 3158, "    CGImageCreateFromIOSurface -- unsupported pixelformat: '%c%c%c%c'\n", v11, v14, v17, v18);
      return 0;
    }
    uint64_t v18 = 46;
    goto LABEL_40;
  }

  return IIOIOSurfaceWrapper_YCC::createImageWithImageProvider(this);
}

uint64_t IIOIOSurfaceWrapper_YCC::createImageWithImageProvider(IIOIOSurfaceWrapper_YCC *this)
{
  v13[2] = 0;
  void v13[3] = 2;
  int v2 = IIOIOSurfaceWrapperBase::CopyImageBlockSetWithOptionsNoOp;
  if (!*((unsigned char *)this + 140)) {
    int v2 = IIOIOSurfaceWrapper_YCC::CopyImageBlockSetWithOptions;
  }
  v13[4] = v2;
  void v13[5] = IIOIOSurfaceWrapperBase::CopyIOSurface;
  v13[6] = IIOIOSurfaceWrapperBase::ReleaseInfo;
  v13[0] = 0;
  v13[1] = 0;
  IIODictionary::IIODictionary((IIODictionary *)v13);
  unsigned int v3 = *((_DWORD *)this + 41);
  int v4 = (const void **)MEMORY[0x1E4F1CFD0];
  if (v3 <= 6)
  {
    if (((1 << v3) & 6) != 0)
    {
      IIODictionary::setObjectForKey((IIODictionary *)v13, (const void *)*MEMORY[0x1E4F1CFD0], (const __CFString *)*MEMORY[0x1E4F1DD78]);
    }
    else if (((1 << v3) & 0x18) == 0)
    {
      if (((1 << v3) & 0x60) == 0) {
        goto LABEL_11;
      }
      unsigned __int16 v5 = (const __CFString **)MEMORY[0x1E4F1DD70];
      goto LABEL_10;
    }
    unsigned __int16 v5 = (const __CFString **)MEMORY[0x1E4F1DD68];
LABEL_10:
    IIODictionary::setObjectForKey((IIODictionary *)v13, *v4, *v5);
  }
LABEL_11:
  CFStringRef v6 = (CGColorSpace *)*((void *)this + 10);
  CFStringRef v7 = (const __CFString *)*MEMORY[0x1E4F1DC98];
  v12[0] = (CGColorSpaceRef)&unk_1ED4DFD58;
  unsigned int v8 = CGColorSpaceCreateWithName(v7);
  v12[1] = v8;
  if (!v6) {
    CFStringRef v6 = v8;
  }
  if (CGImageProviderCreate())
  {
    CGImageProviderSetProperty();
    memset(v11, 0, sizeof(v11));
    IIONumber::IIONumber((IIONumber *)v11, *((_DWORD *)this + 22));
    CGImageProviderSetProperty();
    uint64_t v9 = CGImageCreateWithImageProvider();
    CGImageProviderRelease();
    if (!*((void *)this + 10)) {
      IIO_IOSurfaceAddColorSpace(*((__IOSurface **)this + 9), v6);
    }
    IIONumber::~IIONumber((IIONumber *)v11);
  }
  else
  {
    uint64_t v9 = 0;
  }
  IIOColorSpace::~IIOColorSpace(v12);
  IIODictionary::~IIODictionary((IIODictionary *)v13);
  return v9;
}

void sub_1887CA45C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  CGColorSpaceRef v5 = va_arg(va1, CGColorSpaceRef);
  uint64_t v7 = va_arg(va1, void);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t IIOIOSurfaceWrapper_YCC::CopyImageBlockSetWithOptions(uint64_t a1, uint64_t a2, __CFDictionary *a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  memset(v41, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)v41, a3);
  uint64_t v18 = *(int *)(a1 + 216);
  IIOPackCopyCallbackInfo(a3);
  CGImageProviderGetBitmapInfo();
  kdebug_trace();
  if ((gIIODebugFlags & 0xC000) != 0)
  {
    int v20 = *(_DWORD *)(a1 + 88);
    unsigned int v21 = v20 >> 24;
    uint64_t v22 = MEMORY[0x1E4F14390];
    if (v20 < 0) {
      int v23 = __maskrune(v20 >> 24, 0x40000uLL);
    }
    else {
      int v23 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v21 + 60) & 0x40000;
    }
    if (v23) {
      uint64_t v24 = v21;
    }
    else {
      uint64_t v24 = 46;
    }
    unsigned int v25 = v20 << 8 >> 24;
    if (v20 << 8 < 0) {
      int v26 = __maskrune(v20 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v26 = *(_DWORD *)(v22 + 4 * v25 + 60) & 0x40000;
    }
    if (v26) {
      uint64_t v27 = v25;
    }
    else {
      uint64_t v27 = 46;
    }
    unsigned int v28 = (__int16)v20 >> 8;
    if (v20 << 16 < 0) {
      int v29 = __maskrune((__int16)v20 >> 8, 0x40000uLL);
    }
    else {
      int v29 = *(_DWORD *)(v22 + 4 * v28 + 60) & 0x40000;
    }
    if ((v20 << 24) <= 0x7F000000) {
      int v30 = *(_DWORD *)(v22 + 4 * (char)v20 + 60) & 0x40000;
    }
    else {
      int v30 = __maskrune((char)v20, 0x40000uLL);
    }
    if (v29) {
      uint64_t v31 = v28;
    }
    else {
      uint64_t v31 = 46;
    }
    if (v30) {
      uint64_t v32 = (char)v20;
    }
    else {
      uint64_t v32 = 46;
    }
    ImageIOLog("S   CopyImageBlockSetWithOptions_YCC: {%g, %g, %g, %g} {%g, %g} '%c%c%c%c' %s\n", a4, a5, a6, a7, a8, a9, v24, v27, v31, v32, off_1E53CCE00[v18]);
  }
  uint64_t v40 = 0;
  if (*(unsigned char *)(a1 + 141))
  {
    uint64_t v33 = IIOIOSurfaceWrapperBase::createBlockSetForCompressedSurface(a1, a4, a5, a6, a7, a2, v19, &v40);
  }
  else
  {
    double v35 = (double)*(unint64_t *)(a1 + 96);
    double v36 = (double)*(unint64_t *)(a1 + 104);
    double v37 = *MEMORY[0x1E4F1DAD8];
    double v38 = *(double *)(MEMORY[0x1E4F1DAD8] + 8);
    if (v18 == 6)
    {
      uint64_t v33 = IIOIOSurfaceWrapper_YCC::copyImageBlockSetWithOptions10Bit(a1, v37, v38, v35, v36, a2, v19, &v40);
    }
    else
    {
      if (v18 != 1)
      {
        LogError("CopyImageBlockSetWithOptions", 3600, "*** unsupported componentType '%s' (%d)\n", gComponentString[v18], v18);
        goto LABEL_36;
      }
      uint64_t v33 = IIOIOSurfaceWrapper_YCC::copyImageBlockSetWithOptions8Bit(a1, v37, v38, v35, v36, a2, (IIODictionary *)v41, &v40);
    }
  }
  uint64_t v34 = v33;
  if (!v33)
  {
LABEL_36:
    _cg_jpeg_mem_term("CopyImageBlockSetWithOptions", 3610, "*** ERROR: CopyImageBlockSetWithOptions returned NULL\n");
    uint64_t v34 = 0;
    goto LABEL_37;
  }
  CGImageBlockSetGetRect();
LABEL_37:
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v41);
  return v34;
}

void sub_1887CA79C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(uint64_t a1, double a2, double a3, double a4, double a5)
{
  uint64_t v43 = 0;
  unint64_t v7 = (unint64_t)a5;
  int v41 = 197121;
  int v40 = 66051;
  long long v39 = xmmword_1ED4F0C80;
  long long v38 = xmmword_1ED4F0C90;
  unint64_t v8 = IIOAlignRowBytes(vcvtd_n_u64_f64(a4, 2uLL), 0);
  if (!is_mul_ok(v7, v8)) {
    return 0;
  }
  size_t v9 = v8;
  memory_object_size_t v42 = 0;
  int v10 = (void *)_ImageIO_Malloc(v7 * v8, 64, &v42, (uint64_t)kImageMalloc_IOSurface_Data, 0, 0, 0);
  if (IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0))
  {
    uint64_t v11 = 0;
    if (!v10) {
      return v11;
    }
    goto LABEL_41;
  }
  BaseAddressOfPlane = IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 72), 0);
  int v13 = IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 72), 1uLL);
  uint64_t v11 = 0;
  if (BaseAddressOfPlane)
  {
    uint64_t v14 = v13;
    if (v13)
    {
      int v37 = 0;
      IOSurfaceGetYCbCrMatrix();
      OSType PixelFormat = IOSurfaceGetPixelFormat(*(IOSurfaceRef *)(a1 + 72));
      int v16 = (const vImage_YpCbCrToARGB *)&IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv601v;
      if (PixelFormat != 875704438) {
        int v16 = (const vImage_YpCbCrToARGB *)&IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv601f;
      }
      *(int8x16_t *)&srcYp.double height = vextq_s8(*(int8x16_t *)(a1 + 96), *(int8x16_t *)(a1 + 96), 8uLL);
      srcYp.rowunint64_t Bytes = *(void *)(a1 + 112);
      dest.rowunint64_t Bytes = v9;
      srcCbCr.data = v14;
      *(int8x16_t *)&srcCbCr.double height = vextq_s8(*(int8x16_t *)(a1 + 224), *(int8x16_t *)(a1 + 224), 8uLL);
      srcCbCr.rowunint64_t Bytes = *(void *)(a1 + 240);
      srcYp.data = BaseAddressOfPlane;
      dest.double height = v7;
      dest.double width = (unint64_t)a4;
      uint64_t v17 = v16;
      dest.data = v10;
      ERROR_ImageIO_DataBufferIsNotReadable((unsigned __int8 *)BaseAddressOfPlane);
      ERROR_ImageIO_DataBufferIsNotReadable((unsigned __int8 *)v14);
      if (IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::YpCbCrToARGBCreate != -1) {
        dispatch_once(&IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::YpCbCrToARGBCreate, &__block_literal_global_38);
      }
      if (*(unsigned char *)(a1 + 200)) {
        uint64_t v18 = &v40;
      }
      else {
        uint64_t v18 = &v41;
      }
      vImage_Error v19 = vImageConvert_420Yp8_CbCr8ToARGB8888(&srcYp, &srcCbCr, &dest, v17, (const uint8_t *)v18, 0xFFu, 0);
      if (!v19)
      {
        uint64_t v43 = CGImageBlockCreate();
        uint64_t v11 = CGImageBlockSetCreate();
        int v10 = 0;
        goto LABEL_40;
      }
      int v20 = v19;
      kdebug_trace();
      int v21 = *(_DWORD *)(a1 + 88);
      unsigned int v22 = v21 >> 24;
      uint64_t v23 = MEMORY[0x1E4F14390];
      if (v21 < 0)
      {
        int v24 = __maskrune(v22, 0x40000uLL);
        int v21 = *(_DWORD *)(a1 + 88);
      }
      else
      {
        int v24 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v22 + 60) & 0x40000;
      }
      if (v24) {
        uint64_t v25 = (v21 >> 24);
      }
      else {
        uint64_t v25 = 46;
      }
      unsigned int v26 = v21 << 8 >> 24;
      if (v21 << 8 < 0)
      {
        int v27 = __maskrune(v26, 0x40000uLL);
        int v21 = *(_DWORD *)(a1 + 88);
      }
      else
      {
        int v27 = *(_DWORD *)(v23 + 4 * v26 + 60) & 0x40000;
      }
      if (v27) {
        uint64_t v28 = (v21 << 8 >> 24);
      }
      else {
        uint64_t v28 = 46;
      }
      unsigned int v29 = (__int16)v21 >> 8;
      if (v21 << 16 < 0)
      {
        int v30 = __maskrune(v29, 0x40000uLL);
        int v21 = *(_DWORD *)(a1 + 88);
      }
      else
      {
        int v30 = *(_DWORD *)(v23 + 4 * v29 + 60) & 0x40000;
      }
      if (v30) {
        uint64_t v31 = ((__int16)v21 >> 8);
      }
      else {
        uint64_t v31 = 46;
      }
      if ((v21 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(v23 + 4 * (char)v21 + 60) & 0x40000) != 0) {
          goto LABEL_36;
        }
      }
      else if (__maskrune((char)v21, 0x40000uLL))
      {
LABEL_36:
        uint64_t v32 = *(char *)(a1 + 88);
LABEL_39:
        LogError("copyImageBlockSet_420f_8bit", 3372, "*** copyImageBlockSet_420f_8bit '%c%c%c%c' failed: err=%d\n", v25, v28, v31, v32, v20);
        uint64_t v11 = 0;
        goto LABEL_40;
      }
      uint64_t v32 = 46;
      goto LABEL_39;
    }
  }
LABEL_40:
  IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
  if (v10) {
LABEL_41:
  }
    _ImageIO_Free((unint64_t)v10, v42);
  return v11;
}

void ___ZN23IIOIOSurfaceWrapper_YCC27copyImageBlockSet_420f_8bitEP15CGImageProvider6CGRect6CGSizeP13IIODictionary_block_invoke()
{
  uint64_t v0 = 0;
  v13[16] = *MEMORY[0x1E4F143B8];
  v10[0] = xmmword_1889AD098;
  v10[1] = unk_1889AD0A8;
  v9[0] = xmmword_1889AD0B8;
  v9[1] = unk_1889AD0C8;
  uint64_t v1 = *MEMORY[0x1E4F167D0];
  uint64_t v2 = *MEMORY[0x1E4F167D8];
  int v8 = 1072746935;
  long long v7 = xmmword_1889AD0D8;
  uint64_t v11 = v9;
  uint64_t v12 = v1;
  unsigned int v3 = (vImage_YpCbCrToARGB **)v13;
  v13[0] = &IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv601f;
  v13[1] = v10;
  v13[2] = v1;
  void v13[3] = &IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv601v;
  v13[4] = v9;
  void v13[5] = v2;
  v13[6] = &IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv709f;
  void v13[7] = v10;
  v13[8] = v2;
  v13[9] = &IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv709v;
  v13[10] = v9;
  double v13[11] = &v7;
  v13[12] = &IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv2020f;
  v13[13] = v10;
  v13[14] = &v7;
  v13[15] = &IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(CGImageProvider *,CGRect,CGSize,IIODictionary *)::conv2020v;
  do
  {
    vImage_Error Conversion = vImageConvert_YpCbCrToARGB_GenerateConversion((const vImage_YpCbCrToARGBMatrix *)*(v3 - 1), (const vImage_YpCbCrPixelRange *)*(v3 - 2), *v3, kvImage420Yp8_CbCr8, kvImageARGB8888, 0);
    if (Conversion)
    {
      vImage_Error v5 = Conversion;
      CFStringRef v6 = IIO_vImageErrorString(Conversion);
      _cg_jpeg_mem_term("copyImageBlockSet_420f_8bit_block_invoke", 3349, "*** ERROR: vImageConvert_YpCbCrToARGB_GenerateConversion[%d] returned %ld (%s)\n", v0, v5, v6);
    }
    ++v0;
    v3 += 3;
  }
  while (v0 != 6);
}

uint64_t IIOIOSurfaceWrapper_YCC::copyImageBlockSet_xf20_10bit(uint64_t a1, double a2, double a3, double a4, double a5)
{
  uint64_t v41 = 0;
  unint64_t v7 = (unint64_t)a5;
  long long v39 = xmmword_1ED4F0C80;
  long long v38 = xmmword_1ED4F0C90;
  unint64_t v8 = IIOAlignRowBytes(4 * *(void *)(a1 + 96), 0);
  if (!is_mul_ok(v7, v8)) {
    return 0;
  }
  size_t v9 = (unint64_t *)v8;
  memory_object_size_t v40 = 0;
  int v10 = (unint64_t *)_ImageIO_Malloc(v7 * v8, 64, &v40, (uint64_t)kImageMalloc_ATX_Data[0], 0, 0, 0);
  if (IOSurfaceLock(*(IOSurfaceRef *)(a1 + 72), 1u, 0))
  {
    uint64_t v11 = 0;
    if (!v10) {
      return v11;
    }
    goto LABEL_32;
  }
  BaseAddressOfPlane = (unsigned __int16 *)IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 72), 0);
  int v13 = (unsigned __int16 *)IOSurfaceGetBaseAddressOfPlane(*(IOSurfaceRef *)(a1 + 72), 1uLL);
  int8x16_t v36 = vextq_s8(*(int8x16_t *)(a1 + 96), *(int8x16_t *)(a1 + 96), 8uLL);
  uint64_t v37 = *(void *)(a1 + 112);
  v31[3] = v9;
  uint64_t v32 = v13;
  int8x16_t v33 = vextq_s8(*(int8x16_t *)(a1 + 224), *(int8x16_t *)(a1 + 224), 8uLL);
  uint64_t v34 = *(void *)(a1 + 240);
  double v35 = BaseAddressOfPlane;
  v31[1] = (unint64_t *)v7;
  _OWORD v31[2] = (unint64_t *)a4;
  v31[0] = v10;
  IOSurfaceGetYCbCrMatrix();
  BOOL v14 = IOSurfaceGetRangeOfComponentOfPlane(*(IOSurfaceRef *)(a1 + 72), 0, 0) == kIOSurfaceComponentRangeVideoRange;
  XF20toRGB16fConversionInfo = (__int16 *)GetXF20toRGB16fConversionInfo(0, v14);
  uint64_t v16 = ConvertXF20toRGBA1010102(&v35, &v32, v31, XF20toRGB16fConversionInfo);
  if (!v16)
  {
    uint64_t v41 = CGImageBlockCreate();
    uint64_t v11 = CGImageBlockSetCreate();
    int v10 = 0;
    goto LABEL_31;
  }
  int v17 = v16;
  kdebug_trace();
  int v18 = *(_DWORD *)(a1 + 88);
  unsigned int v19 = v18 >> 24;
  uint64_t v20 = MEMORY[0x1E4F14390];
  if (v18 < 0)
  {
    int v21 = __maskrune(v19, 0x40000uLL);
    int v18 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    int v21 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v19 + 60) & 0x40000;
  }
  if (v21) {
    uint64_t v22 = (v18 >> 24);
  }
  else {
    uint64_t v22 = 46;
  }
  unsigned int v23 = v18 << 8 >> 24;
  if (v18 << 8 < 0)
  {
    int v24 = __maskrune(v23, 0x40000uLL);
    int v18 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    int v24 = *(_DWORD *)(v20 + 4 * v23 + 60) & 0x40000;
  }
  if (v24) {
    uint64_t v25 = (v18 << 8 >> 24);
  }
  else {
    uint64_t v25 = 46;
  }
  unsigned int v26 = (__int16)v18 >> 8;
  if (v18 << 16 < 0)
  {
    int v27 = __maskrune(v26, 0x40000uLL);
    int v18 = *(_DWORD *)(a1 + 88);
  }
  else
  {
    int v27 = *(_DWORD *)(v20 + 4 * v26 + 60) & 0x40000;
  }
  if (v27) {
    uint64_t v28 = ((__int16)v18 >> 8);
  }
  else {
    uint64_t v28 = 46;
  }
  if ((v18 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v20 + 4 * (char)v18 + 60) & 0x40000) != 0) {
      goto LABEL_27;
    }
LABEL_29:
    uint64_t v29 = 46;
    goto LABEL_30;
  }
  if (!__maskrune((char)v18, 0x40000uLL)) {
    goto LABEL_29;
  }
LABEL_27:
  uint64_t v29 = *(char *)(a1 + 88);
LABEL_30:
  LogError("copyImageBlockSet_xf20_10bit", 3454, "*** copyImageBlockSet_xf20_10bit '%c%c%c%c' failed: err=%d\n", v22, v25, v28, v29, v17);
  uint64_t v11 = 0;
LABEL_31:
  IOSurfaceUnlock(*(IOSurfaceRef *)(a1 + 72), 1u, 0);
  if (v10) {
LABEL_32:
  }
    _ImageIO_Free((unint64_t)v10, v40);
  return v11;
}

uint64_t IIOIOSurfaceWrapper_YCC::copyImageBlockSetWithOptions8Bit(uint64_t a1, double a2, double d1_0, double d2_0, double a5, uint64_t a6, IIODictionary *a7, void *a8)
{
  unsigned int v15 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  IIOIOSurfaceWrapperBase::preCopyBlockSet((IIOIOSurfaceWrapperBase *)a1, 8, v19, v18, a7);
  uint64_t v16 = IIOIOSurfaceWrapper_YCC::copyImageBlockSet_420f_8bit(a1, a2, d1_0, d2_0, a5);
  *a8 = (*(uint64_t (**)(uint64_t, void, double, double, double, double))(*(void *)a1 + 64))(a1, 0, a2, d1_0, d2_0, a5);
  pthread_mutex_unlock(v15);
  return v16;
}

uint64_t IIOIOSurfaceWrapper_YCC::copyImageBlockSetWithOptions10Bit(uint64_t a1, double a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7, void *a8)
{
  BOOL v14 = (pthread_mutex_t *)(a1 + 8);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  *(unsigned char *)(a1 + 200) = 0;
  uint64_t v15 = IIOIOSurfaceWrapper_YCC::copyImageBlockSet_xf20_10bit(a1, a2, a3, a4, a5);
  *a8 = (*(uint64_t (**)(uint64_t, void, double, double, double, double))(*(void *)a1 + 64))(a1, 0, a2, a3, a4, a5);
  pthread_mutex_unlock(v14);
  return v15;
}

unint64_t IIOIOSurfaceWrapper_YCC::packDebugInfo(IIOIOSurfaceWrapper_YCC *this, CGRect a2, uint64_t a3)
{
  unint64_t result = IIOIOSurfaceWrapperBase::packDebugInfo(this, a2, a3);
  if (*((unsigned char *)this + 200)) {
    result |= 0x1000uLL;
  }
  return result;
}

uint64_t IIOIOSurfaceWrapperBase::copyImageBlockSet_8bit()
{
  return 0;
}

uint64_t IIOIOSurfaceWrapperBase::copyImageBlockSet_16bit()
{
  return 0;
}

uint64_t ___ZL30CheckIfDeviceHasDisplayP3Panelv_block_invoke()
{
  gDeviceHasExtendedColorDisplaCGFloat y = MGCopyAnswer() == *MEMORY[0x1E4F1CFD0];
  mach_port_t v0 = *MEMORY[0x1E4F2EF00];
  CFDictionaryRef v1 = IOServiceMatching("AppleM2ScalerCSCDriver");
  io_service_t MatchingService = IOServiceGetMatchingService(v0, v1);
  io_object_t v3 = MatchingService;
  if (MatchingService)
  {
    CFDictionaryRef v4 = (const __CFDictionary *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"IOSurfaceAcceleratorCapabilitiesDict", 0, 0);
    if (v4)
    {
      CFDictionaryRef v5 = v4;
      CFTypeID v6 = CFGetTypeID(v4);
      if (v6 == CFDictionaryGetTypeID())
      {
        if (CFDictionaryContainsKey(v5, @"kSurfaceAcceleratorCapabilitiesColorManager"))
        {
          CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v5, @"kSurfaceAcceleratorCapabilitiesColorManager");
          if (Value)
          {
            int valuePtr = 0;
            if (CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr)) {
              gCanUseMSRForColorvImage_Error Conversion = valuePtr != 0;
            }
          }
        }
      }
      CFRelease(v5);
    }
  }
  return IOObjectRelease(v3);
}

uint64_t png_handle_PLTE(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0)
  {
    uint64_t v16 = "missing IHDR";
    goto LABEL_37;
  }
  if ((v4 & 2) != 0)
  {
    uint64_t v16 = "duplicate";
    goto LABEL_37;
  }
  int v5 = a3;
  if ((v4 & 4) != 0)
  {
    png_crc_finish(a1, a3);
    unint64_t v7 = "out of place";
    goto LABEL_7;
  }
  *(_DWORD *)(a1 + 76) = v4 | 2;
  int v6 = *(unsigned __int8 *)(a1 + 391);
  if ((v6 & 2) == 0)
  {
    png_crc_finish(a1, a3);
    unint64_t v7 = "ignored in grayscale PNG";
LABEL_7:
    return png_chunk_benign_error(a1, v7);
  }
  if (a3 > 0x300 || a3 % 3)
  {
    png_crc_finish(a1, a3);
    if (*(unsigned char *)(a1 + 391) != 3)
    {
      unint64_t v7 = "invalid";
      goto LABEL_7;
    }
    uint64_t v16 = "invalid";
LABEL_37:
    png_chunk_error((void (**)(void))a1, v16);
  }
  int v10 = (unsigned __int16)a3 / 3u;
  if (v6 == 3) {
    int v11 = 1 << *(unsigned char *)(a1 + 392);
  }
  else {
    int v11 = 256;
  }
  bzero(v18, 0x300uLL);
  if (v11 < v10) {
    int v10 = v11;
  }
  if (v10 >= 1)
  {
    uint64_t v12 = v18;
    int v13 = v10;
    do
    {
      memset(v17, 0, 3);
      png_crc_read(a1, (Bytef *)v17, 3u);
      *uint64_t v12 = v17[0];
      *(_WORD *)(v12 + 1) = *(_WORD *)((char *)v17 + 1);
      v12 += 3;
      --v13;
    }
    while (v13);
  }
  png_crc_finish(a1, (-3 * v10 + v5));
  uint64_t result = (uint64_t)_cg_png_set_PLTE((void (**)(void))a1, a2, v18, v10);
  if (*(_WORD *)(a1 + 384))
  {
    *(_WORD *)(a1 + 384) = 0;
    if (!a2)
    {
      BOOL v14 = "tRNS must be after";
      return png_chunk_benign_error(a1, v14);
    }
    goto LABEL_28;
  }
  if (!a2) {
    return result;
  }
  int v15 = *(_DWORD *)(a2 + 8);
  if ((v15 & 0x10) != 0)
  {
    *(_WORD *)(a1 + 384) = 0;
LABEL_28:
    *(_WORD *)(a2 + 34) = 0;
    uint64_t result = png_chunk_benign_error(a1, "tRNS must be after");
    int v15 = *(_DWORD *)(a2 + 8);
  }
  if ((v15 & 0x40) != 0) {
    uint64_t result = png_chunk_benign_error(a1, "hIST must be after");
  }
  if ((*(unsigned char *)(a2 + 8) & 0x20) != 0)
  {
    BOOL v14 = "bKGD must be after";
    return png_chunk_benign_error(a1, v14);
  }
  return result;
}

uint64_t png_handle_IEND(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a1 + 76);
  if ((~v4 & 5) != 0) {
    png_chunk_error((void (**)(void))a1, "out of place");
  }
  int v5 = a3;
  *(_DWORD *)(a1 + 76) = v4 | 0x18;
  uint64_t result = png_crc_finish(a1, a3);
  if (v5)
  {
    return png_chunk_benign_error(a1, "invalid");
  }
  return result;
}

uint64_t png_handle_sBIT(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0) {
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  }
  if ((v4 & 6) != 0)
  {
    png_crc_finish(a1, a3);
    int v6 = "out of place";
LABEL_4:
    return png_chunk_benign_error(a1, v6);
  }
  if (a2 && (*(unsigned char *)(a2 + 8) & 2) != 0)
  {
    png_crc_finish(a1, a3);
    int v6 = "duplicate";
    goto LABEL_4;
  }
  int v9 = *(unsigned __int8 *)(a1 + 391);
  if (v9 == 3)
  {
    unsigned __int8 v10 = 8;
  }
  else
  {
    int v9 = *(unsigned __int8 *)(a1 + 395);
    unsigned __int8 v10 = *(unsigned char *)(a1 + 392);
  }
  if (a3 <= 4 && v9 == a3)
  {
    int v19 = 16843009 * v10;
    png_crc_read(a1, (Bytef *)&v19, a3);
    uint64_t result = png_crc_finish(a1, 0);
    if (!result)
    {
      if (a3)
      {
        uint64_t v11 = a3;
        uint64_t v12 = &v19;
        while (1)
        {
          char v13 = *(unsigned char *)v12;
          uint64_t v12 = (int *)((char *)v12 + 1);
          if ((v13 - 1) >= v10) {
            return png_chunk_benign_error(a1, "invalid");
          }
          if (!--v11) {
            goto LABEL_19;
          }
        }
      }
      else
      {
LABEL_19:
        char v14 = v19;
        if ((*(unsigned char *)(a1 + 391) & 2) != 0)
        {
          int v15 = (char *)&v19 + 3;
          char v16 = BYTE1(v19);
          char v17 = BYTE2(v19);
        }
        else
        {
          int v15 = (char *)&v19 + 1;
          *(unsigned char *)(a1 + 507) = v19;
          char v16 = v14;
          char v17 = v14;
        }
        char v18 = *v15;
        *(unsigned char *)(a1 + 504) = v14;
        *(unsigned char *)(a1 + 505) = v16;
        *(unsigned char *)(a1 + 506) = v17;
        *(unsigned char *)(a1 + 508) = v18;
        return png_set_sBIT(a1, a2, a1 + 504);
      }
    }
  }
  else
  {
    png_chunk_benign_error(a1, "invalid");
    return png_crc_finish(a1, a3);
  }
  return result;
}

void png_handle_sPLT(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a1 + 884);
  if (v6)
  {
    int v7 = v6 - 1;
    if (!v7)
    {
LABEL_5:
      png_crc_finish(a1, a3);
      return;
    }
    *(_DWORD *)(a1 + 884) = v7;
    if (v7 == 1)
    {
      png_warning(a1, "No space in chunk cache for sPLT");
      goto LABEL_5;
    }
  }
  int v8 = *(_DWORD *)(a1 + 76);
  if ((v8 & 1) == 0) {
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  }
  if ((v8 & 4) != 0)
  {
    png_crc_finish(a1, a3);
    uint64_t v11 = "out of place";
LABEL_15:
    png_chunk_benign_error(a1, v11);
    return;
  }
  UInt8 buffer = (Bytef *)png_read_buffer(a1, (a3 + 1), 2);
  if (!buffer)
  {
    png_crc_finish(a1, a3);
    uint64_t v11 = "out of memory";
    goto LABEL_15;
  }
  unsigned __int8 v10 = buffer;
  png_crc_read(a1, buffer, a3);
  if (png_crc_finish(a1, 0)) {
    return;
  }
  uint64_t v12 = 0;
  v10[a3] = 0;
  while (v10[v12++])
    ;
  if (a3 < 2 || &v10[v12] > &v10[(a3 - 2)])
  {
    char v18 = "malformed sPLT chunk";
    goto LABEL_28;
  }
  uint64_t v27 = 0;
  long long v25 = 0u;
  *(_OWORD *)unsigned int v26 = 0u;
  int v15 = &v10[v12 + 1];
  LOBYTE(v26[0]) = v10[v12];
  int v14 = LOBYTE(v26[0]);
  if (LOBYTE(v26[0]) == 8) {
    unsigned int v16 = 6;
  }
  else {
    unsigned int v16 = 10;
  }
  unsigned int v17 = a3 - 1 - v12;
  if (v17 % v16)
  {
    char v18 = "sPLT chunk has bad length";
LABEL_28:
    png_warning(a1, v18);
    return;
  }
  int v19 = png_malloc_warn((void *)a1, 10 * (v17 / v16));
  v26[1] = v19;
  LODWORD(v27) = v17 / v16;
  if (!v19)
  {
    char v18 = "sPLT chunk requires too much memory";
    goto LABEL_28;
  }
  if (v16 <= v17)
  {
    unint64_t v20 = 0;
    int v21 = (_WORD *)v19 + 2;
    do
    {
      if (v14 == 8)
      {
        *(v21 - 2) = *v15;
        *(v21 - 1) = v15[1];
        *int v21 = v15[2];
        LOWORD(v22) = v15[3];
        unsigned int v23 = (unsigned __int16 *)(v15 + 4);
      }
      else
      {
        *(v21 - 2) = bswap32(*(unsigned __int16 *)v15) >> 16;
        *(v21 - 1) = bswap32(*((unsigned __int16 *)v15 + 1)) >> 16;
        *int v21 = bswap32(*((unsigned __int16 *)v15 + 2)) >> 16;
        unsigned int v22 = bswap32(*((unsigned __int16 *)v15 + 3)) >> 16;
        unsigned int v23 = (unsigned __int16 *)(v15 + 8);
      }
      v21[1] = v22;
      unsigned int v24 = *v23;
      int v15 = (Bytef *)(v23 + 1);
      v21[2] = bswap32(v24) >> 16;
      ++v20;
      v21 += 5;
    }
    while (v20 < v17 / v16);
  }
  *(void *)&long long v25 = v10;
  *((void *)&v25 + 1) = v12;
  png_set_sPLT((void (**)(void))a1, a2, (uint64_t)&v25, 1);
  png_free(a1, v26[1]);
}

void png_handle_tRNS(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0) {
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  }
  __int16 v5 = a3;
  if ((v4 & 4) != 0) {
    goto LABEL_12;
  }
  if (a2 && (*(unsigned char *)(a2 + 8) & 0x10) != 0)
  {
    png_crc_finish(a1, a3);
    int v8 = "duplicate";
    goto LABEL_13;
  }
  memset(v13, 0, sizeof(v13));
  int v7 = *(unsigned __int8 *)(a1 + 391);
  if (v7 == 3)
  {
    if ((v4 & 2) == 0)
    {
LABEL_12:
      png_crc_finish(a1, a3);
      int v8 = "out of place";
      goto LABEL_13;
    }
    if (a3 <= 0x100 && (int)a3 - 1 < *(unsigned __int16 *)(a1 + 376))
    {
      png_crc_read(a1, (Bytef *)v13, a3);
      *(_WORD *)(a1 + 384) = v5;
      goto LABEL_23;
    }
    png_crc_finish(a1, a3);
    int v8 = "invalid";
LABEL_13:
    png_chunk_benign_error(a1, v8);
    return;
  }
  if (v7 == 2)
  {
    unsigned __int16 v12 = 0;
    int v11 = 0;
    if (a3 == 6)
    {
      png_crc_read(a1, (Bytef *)&v11, 6u);
      *(_WORD *)(a1 + 384) = 1;
      *(_WORD *)(a1 + 530) = bswap32((unsigned __int16)v11) >> 16;
      *(_WORD *)(a1 + 532) = bswap32(HIWORD(v11)) >> 16;
      *(_WORD *)(a1 + 534) = bswap32(v12) >> 16;
      goto LABEL_23;
    }
LABEL_19:
    png_crc_finish(a1, a3);
    png_chunk_benign_error(a1, "invalid");
    return;
  }
  if (*(unsigned char *)(a1 + 391))
  {
    png_crc_finish(a1, a3);
    int v8 = "invalid with alpha channel";
    goto LABEL_13;
  }
  LOWORD(v11) = 0;
  if (a3 != 2) {
    goto LABEL_19;
  }
  png_crc_read(a1, (Bytef *)&v11, 2u);
  *(_WORD *)(a1 + 384) = 1;
  *(_WORD *)(a1 + 536) = bswap32((unsigned __int16)v11) >> 16;
LABEL_23:
  if (png_crc_finish(a1, 0))
  {
    *(_WORD *)(a1 + 384) = 0;
    int v9 = *(_DWORD *)(a1 + 80);
    if ((*(unsigned char *)(a1 + 315) & 0x20) != 0)
    {
      if ((v9 & 0x200) != 0) {
        return;
      }
    }
    else if ((v9 & 0x400) == 0)
    {
      return;
    }
    unsigned int v10 = 0;
  }
  else
  {
    unsigned int v10 = *(unsigned __int16 *)(a1 + 384);
  }
  _cg_png_set_tRNS(a1, a2, v13, v10, a1 + 528);
}

uint64_t png_handle_hIST(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if ((*(_DWORD *)(a1 + 76) & 1) == 0) {
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  }
  if ((*(_DWORD *)(a1 + 76) & 6) == 2)
  {
    if (a2 && (*(unsigned char *)(a2 + 8) & 0x40) != 0)
    {
      png_crc_finish(a1, a3);
      int v9 = "duplicate";
    }
    else
    {
      if ((a3 & 1) == 0 && a3 <= 0x201)
      {
        unsigned int v5 = a3 >> 1;
        if (a3 >> 1 == *(unsigned __int16 *)(a1 + 376))
        {
          memset(v11, 0, sizeof(v11));
          if (a3 >= 2)
          {
            if (v5 <= 1) {
              uint64_t v6 = 1;
            }
            else {
              uint64_t v6 = v5;
            }
            int v7 = v11;
            do
            {
              unsigned __int16 v10 = 0;
              png_crc_read(a1, (Bytef *)&v10, 2u);
              *v7++ = bswap32(v10) >> 16;
              --v6;
            }
            while (v6);
          }
          uint64_t result = png_crc_finish(a1, 0);
          if (!result) {
            return (uint64_t)png_set_hIST((void *)a1, a2, v11);
          }
          return result;
        }
      }
      png_crc_finish(a1, a3);
      int v9 = "invalid";
    }
  }
  else
  {
    png_crc_finish(a1, a3);
    int v9 = "out of place";
  }

  return png_chunk_benign_error(a1, v9);
}

uint64_t png_handle_oFFs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0) {
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  }
  if ((v4 & 4) != 0)
  {
    png_crc_finish(a1, a3);
    int v8 = "out of place";
  }
  else if (a2 && (*(unsigned char *)(a2 + 9) & 1) != 0)
  {
    png_crc_finish(a1, a3);
    int v8 = "duplicate";
  }
  else
  {
    if (a3 == 9)
    {
      char v11 = 0;
      uint64_t v10 = 0;
      png_crc_read(a1, (Bytef *)&v10, 9u);
      uint64_t result = png_crc_finish(a1, 0);
      if (!result)
      {
        if ((char)v10 < 0) {
          int v7 = -((2147418112 * BYTE1(v10) - ((v10 << 24) | (BYTE2(v10) << 8) | BYTE3(v10))) & 0x7FFFFFFF);
        }
        else {
          int v7 = _byteswap_ulong(v10);
        }
        if (SBYTE4(v10) < 0) {
          int v9 = -((2147418112 * BYTE5(v10) - ((BYTE4(v10) << 24) | (BYTE6(v10) << 8) | HIBYTE(v10))) & 0x7FFFFFFF);
        }
        else {
          int v9 = _byteswap_ulong(HIDWORD(v10));
        }
        return png_set_oFFs(a1, a2, v7, v9, v11);
      }
      return result;
    }
    png_crc_finish(a1, a3);
    int v8 = "invalid";
  }

  return png_chunk_benign_error(a1, v8);
}

void png_handle_pCAL(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0) {
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  }
  if ((v4 & 4) != 0)
  {
    png_crc_finish(a1, a3);
    int v9 = "out of place";
LABEL_29:
    png_chunk_benign_error(a1, v9);
    return;
  }
  if (a2 && (*(unsigned char *)(a2 + 9) & 4) != 0)
  {
    png_crc_finish(a1, a3);
    int v9 = "duplicate";
    goto LABEL_29;
  }
  UInt8 buffer = (Bytef *)png_read_buffer(a1, (a3 + 1), 2);
  if (!buffer)
  {
    png_crc_finish(a1, a3);
LABEL_11:
    int v9 = "out of memory";
    goto LABEL_29;
  }
  int v8 = (char *)buffer;
  png_crc_read(a1, buffer, a3);
  if (png_crc_finish(a1, 0)) {
    return;
  }
  uint64_t v10 = 0;
  uint64_t v11 = a3;
  uint64_t v12 = &v8[a3];
  *uint64_t v12 = 0;
  while (v8[v10++])
    ;
  if (a3 - v10 + 1 <= 12)
  {
    int v9 = "invalid";
    goto LABEL_29;
  }
  uint64_t v14 = &v8[v10];
  if (v8[v10] < 0) {
    int v15 = -((2147418112 * v8[v10 + 1]
  }
           - ((v8[v10] << 24) | (v8[v10 + 2] << 8) | v8[v10 + 3])) & 0x7FFFFFFF);
  else {
    int v15 = _byteswap_ulong(*(_DWORD *)&v8[v10]);
  }
  unsigned int v16 = (unsigned __int8 *)&v8[v10];
  int v17 = v8[v10 + 4];
  if (v8[v10 + 4] < 0) {
    int v18 = -((2147418112 * v16[5] - ((v17 << 24) | (v16[6] << 8) | v16[7])) & 0x7FFFFFFF);
  }
  else {
    int v18 = (v17 << 24) | (v16[5] << 16) | (v16[6] << 8) | v16[7];
  }
  int v19 = &v8[v10];
  unsigned int v20 = v19[8];
  uint64_t v21 = v19[9];
  if (!v19[8] && v21 != 2 || v20 - 1 <= 1 && v21 != 3 || v20 == 3 && v21 != 4)
  {
    int v9 = "invalid parameter count";
    goto LABEL_29;
  }
  int v30 = v15;
  unsigned int v22 = v14 + 9;
  uint64_t v29 = v19 + 10;
  if (v20 >= 4) {
    png_chunk_benign_error(a1, "unrecognized equation type");
  }
  while (*++v22)
    ;
  unsigned int v24 = png_malloc_warn((void *)a1, 8 * v21);
  if (!v24) {
    goto LABEL_11;
  }
  long long v25 = v24;
  if (v21)
  {
    uint64_t v26 = 0;
    while (1)
    {
      uint64_t v27 = v22 + 1;
      if (v22 + 1 < v12)
      {
        v24[v26] = v27;
        uint64_t v28 = (char *)(&v8[v11 - 1] - v22);
        while (*v27)
        {
          ++v27;
          if (!--v28)
          {
            unsigned int v22 = &v8[v11];
            goto LABEL_44;
          }
        }
      }
      unsigned int v22 = v27;
LABEL_44:
      if (v22 >= v12) {
        break;
      }
      if (++v26 == v21) {
        goto LABEL_46;
      }
    }
    png_free(a1, v24);
    int v9 = "invalid data";
    goto LABEL_29;
  }
LABEL_46:
  png_set_pCAL_sized((void *)a1, a2, v8, v30, v18, v20, v21, v29, (const char **)v24);

  png_free(a1, v25);
}

uint64_t png_handle_sCAL(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0) {
    png_chunk_error((void (**)(void))a1, "missing IHDR");
  }
  if ((v4 & 4) != 0)
  {
    png_crc_finish(a1, a3);
    int v7 = "out of place";
    goto LABEL_18;
  }
  if (a2 && (*(unsigned char *)(a2 + 9) & 0x40) != 0)
  {
    png_crc_finish(a1, a3);
    int v7 = "duplicate";
    goto LABEL_18;
  }
  if (a3 <= 3)
  {
    png_crc_finish(a1, a3);
    int v7 = "invalid";
LABEL_18:
    return png_chunk_benign_error(a1, v7);
  }
  UInt8 buffer = (Bytef *)png_read_buffer(a1, (a3 + 1), 2);
  if (buffer)
  {
    int v9 = (char *)buffer;
    png_crc_read(a1, buffer, a3);
    v9[a3] = 0;
    uint64_t result = png_crc_finish(a1, 0);
    if (result) {
      return result;
    }
    if (*v9 - 1 >= 2)
    {
      int v7 = "invalid unit";
      goto LABEL_18;
    }
    unint64_t v15 = 1;
    unsigned int v14 = 0;
    if (png_check_fp_number((uint64_t)v9, a3, &v14, &v15)
      && (unint64_t v11 = v15, v15 < a3)
      && (uint64_t v12 = v15 + 1, ++v15, !v9[v11]))
    {
      if ((v14 & 0x188) == 0x108)
      {
        unsigned int v14 = 0;
        if (png_check_fp_number((uint64_t)v9, a3, &v14, &v15) && v15 == a3)
        {
          if ((v14 & 0x188) == 0x108) {
            return (uint64_t)png_set_sCAL_sized((void (**)(void))a1, a2, *v9, v9 + 1, &v9[v12]);
          }
          char v13 = "non-positive height";
        }
        else
        {
          char v13 = "bad height format";
        }
      }
      else
      {
        char v13 = "non-positive width";
      }
    }
    else
    {
      char v13 = "bad width format";
    }
    return png_chunk_benign_error(a1, v13);
  }
  else
  {
    png_chunk_benign_error(a1, "out of memory");
    return png_crc_finish(a1, a3);
  }
}

uint64_t png_handle_acTL(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  v12[1] = *MEMORY[0x1E4F143B8];
  int v4 = *(_DWORD *)(a1 + 76);
  if ((v4 & 1) == 0)
  {
    unint64_t v11 = "Missing IHDR before acTL";
    goto LABEL_18;
  }
  if ((v4 & 4) != 0)
  {
    uint64_t v10 = "Invalid acTL after IDAT skipped";
  }
  else if ((v4 & 0x10000) != 0)
  {
    uint64_t v10 = "Duplicate acTL skipped";
  }
  else
  {
    if (a3 == 8)
    {
      v12[0] = 0;
      png_crc_read(a1, (Bytef *)v12, 8u);
      png_crc_finish(a1, 0);
      int v7 = bswap32(v12[0]);
      if ((v7 & 0x80000000) == 0)
      {
        int v8 = bswap32(HIDWORD(v12[0]));
        if ((v8 & 0x80000000) == 0)
        {
          uint64_t result = _cg_png_set_acTL(a1, a2, v7, v8);
          if (result) {
            *(_DWORD *)(a1 + 76) |= 0x10000u;
          }
          return result;
        }
      }
      unint64_t v11 = "PNG unsigned integer out of range";
LABEL_18:
      _cg_png_error((void (**)(void))a1, v11);
    }
    uint64_t v10 = "acTL with invalid length skipped";
  }
  png_warning(a1, v10);

  return png_crc_finish(a1, a3);
}

void png_handle_fcTL(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  v14[3] = *MEMORY[0x1E4F143B8];
  png_ensure_sequence_number(a1, a3);
  int v6 = *(_DWORD *)(a1 + 76);
  if ((v6 & 1) == 0)
  {
    char v13 = "Missing IHDR before fcTL";
    goto LABEL_28;
  }
  if ((v6 & 4) != 0)
  {
    unint64_t v11 = "Invalid fcTL after IDAT skipped";
LABEL_15:
    png_warning(a1, v11);
    png_crc_finish(a1, a3 - 4);
    return;
  }
  if ((v6 & 0x20000) != 0)
  {
    unint64_t v11 = "Duplicate fcTL within one frame skipped";
    goto LABEL_15;
  }
  if (a3 != 26)
  {
    unint64_t v11 = "fcTL with invalid length skipped";
    goto LABEL_15;
  }
  memset(v14, 0, 22);
  png_crc_read(a1, (Bytef *)v14, 0x16u);
  png_crc_finish(a1, 0);
  int v7 = bswap32(v14[0]);
  if (v7 < 0
    || (int v8 = bswap32(HIDWORD(v14[0])), v8 < 0)
    || (int v9 = bswap32(v14[1]), v9 < 0)
    || (int v10 = bswap32(HIDWORD(v14[1])), v10 < 0))
  {
    char v13 = "PNG unsigned integer out of range";
LABEL_28:
    _cg_png_error((void (**)(void))a1, v13);
  }
  if (*(_DWORD *)(a1 + 784))
  {
    if (a2)
    {
LABEL_11:
      png_set_next_frame_fcTL(a1, (uint64_t)a2, v7, v8, v9, v10, bswap32(LOWORD(v14[2])) >> 16, bswap32(WORD1(v14[2])) >> 16, BYTE4(v14[2]), BYTE5(v14[2]));
      png_read_reinit(a1, (uint64_t)a2);
      *(_DWORD *)(a1 + 76) |= 0x20000u;
    }
  }
  else
  {
    if (v10 | v9)
    {
      uint64_t v12 = "fcTL for the first frame must have zero offset";
    }
    else
    {
      if (!a2) {
        return;
      }
      if (v7 == *a2 && v8 == a2[1]) {
        goto LABEL_11;
      }
      uint64_t v12 = "size in first frame's fcTL must match the size in IHDR";
    }
    png_warning(a1, v12);
  }
}

uint64_t png_ensure_sequence_number(uint64_t a1, unsigned int a2)
{
  if (a2 <= 3)
  {
    unsigned int v5 = "invalid fcTL or fdAT chunk found";
    goto LABEL_8;
  }
  unsigned int v6 = 0;
  uint64_t result = png_crc_read(a1, (Bytef *)&v6, 4u);
  unsigned int v4 = bswap32(v6);
  if ((v4 & 0x80000000) != 0)
  {
    unsigned int v5 = "PNG unsigned integer out of range";
    goto LABEL_8;
  }
  if (v4 != *(_DWORD *)(a1 + 772))
  {
    unsigned int v5 = "fcTL or fdAT chunk with out-of-order sequence number found";
LABEL_8:
    _cg_png_error((void (**)(void))a1, v5);
  }
  *(_DWORD *)(a1 + 772) = v4 + 1;
  return result;
}

void png_read_reinit(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 368);
  *(void *)(a1 + 280) = v2;
  unint64_t v3 = *(unsigned __int8 *)(a1 + 394);
  BOOL v4 = v3 >= 8;
  unint64_t v5 = (v3 >> 3) * (unint64_t)v2;
  if (!v4) {
    unint64_t v5 = (*(unsigned __int8 *)(a1 + 394) * (unint64_t)v2 + 7) >> 3;
  }
  *(void *)(a1 + 296) = v5;
  unint64_t v6 = *(unsigned __int8 *)(a2 + 42);
  unint64_t v7 = (v6 >> 3) * (unint64_t)v2;
  if (v6 < 8) {
    unint64_t v7 = (*(unsigned __int8 *)(a2 + 42) * (unint64_t)v2 + 7) >> 3;
  }
  *(void *)(a1 + 352) = v7;
  int v8 = *(void **)(a1 + 320);
  if (v8) {
    bzero(v8, v5 + 1);
  }
}

BOOL png_handle_fdAT(uint64_t a1, uint64_t a2, unsigned int a3)
{
  png_ensure_sequence_number(a1, a3);
  png_warning(a1, "ignoring fdAT chunk");

  return png_crc_finish(a1, a3 - 4);
}

uint64_t png_read_filter_row_sub(uint64_t result, unsigned char *a2)
{
  unint64_t v2 = *(void *)(result + 8);
  unint64_t v3 = ((unint64_t)*(unsigned __int8 *)(result + 19) + 7) >> 3;
  if (v3 < v2)
  {
    do
    {
      a2[v3] += *a2;
      ++a2;
      --v2;
    }
    while (v3 != v2);
  }
  return result;
}

uint64_t png_read_filter_row_up(uint64_t result, unsigned char *a2, char *a3)
{
  for (uint64_t i = *(void *)(result + 8); i; --i)
  {
    char v4 = *a3++;
    *a2++ += v4;
  }
  return result;
}

uint64_t png_read_reset(uint64_t result)
{
  *(_DWORD *)(result + 76) &= 0xFFFFFFF3;
  *(_DWORD *)(result + 308) = 0;
  *(unsigned char *)(result + 389) = 0;
  return result;
}

void *png_malloc_array(void (**a1)(void), int a2, unint64_t a3)
{
  if (a2 < 1 || !a3) {
    _cg_png_error(a1, "internal error: array alloc");
  }
  if (!is_mul_ok(a3, a2)) {
    return 0;
  }
  size_t v5 = a2 * a3;
  return png_malloc_base((uint64_t)a1, v5);
}

const char *IIO_vImageErrorString(uint64_t a1)
{
  switch(a1)
  {
    case -21784:
      uint64_t result = "kvImageCoreVideoIsAbsent";
      break;
    case -21783:
      uint64_t result = "kvImageUnsupportedConversion";
      break;
    case -21782:
      uint64_t result = "kvImageInvalidCVImageFormat";
      break;
    case -21781:
      uint64_t result = "kvImageInvalidImageObject";
      break;
    case -21780:
      uint64_t result = "kvImageOutOfPlaceOperationRequired";
      break;
    case -21779:
      uint64_t result = "kvImageColorSyncIsAbsent";
      break;
    case -21778:
      uint64_t result = "kvImageInvalidImageFormat";
      break;
    case -21777:
      uint64_t result = "kvImageInvalidRowBytes";
      break;
    case -21776:
      uint64_t result = "kvImageInternalError";
      break;
    case -21775:
      uint64_t result = "kvImageUnknownFlagsBit";
      break;
    case -21774:
      uint64_t result = "kvImageBufferSizeMismatch";
      break;
    case -21773:
      uint64_t result = "kvImageInvalidParameter";
      break;
    case -21772:
      uint64_t result = "kvImageNullPointerArgument";
      break;
    case -21771:
      uint64_t result = "kvImageMemoryAllocationError";
      break;
    case -21770:
      uint64_t result = "kvImageInvalidOffset_Y";
      break;
    case -21769:
      uint64_t result = "kvImageInvalidOffset_X";
      break;
    case -21768:
      uint64_t result = "kvImageInvalidEdgeStyle";
      break;
    case -21767:
      uint64_t result = "kvImageInvalidKernelSize";
      break;
    case -21766:
      uint64_t result = "kvImageRoiLargerThanInputBuffer";
      break;
    default:
      if (a1) {
        uint64_t result = "unknown vImage error";
      }
      else {
        uint64_t result = "kvImageNoError";
      }
      break;
  }
  return result;
}

vImage_Error iio_convert_XRGB2101010ToRGB16U(const vImage_Buffer *a1, const vImage_Buffer *a2, vImage_Flags a3)
{
  long long v6 = *(_OWORD *)&a1->width;
  src.data = a1->data;
  *(_OWORD *)&src.vImagePixelCount width = v6;
  src.double height = 1;
  size_t v7 = (8 * LODWORD(a1->width));
  int v8 = malloc_type_malloc(v7, 0x1675A7EuLL);
  long long v9 = *(_OWORD *)&a2->data;
  *(_OWORD *)&rgbDest.vImagePixelCount width = *(_OWORD *)&a2->width;
  *(_OWORD *)&dest.data = v9;
  vImagePixelCount width = a2->width;
  dest.data = v8;
  dest.double height = 1;
  dest.vImagePixelCount width = width;
  dest.rowunint64_t Bytes = v7;
  rgbDest.data = a2->data;
  rgbDest.double height = 1;
  *(_DWORD *)permuteMap = 50462976;
  if (a1->height)
  {
    int v11 = 0;
    while (1)
    {
      vImage_Error v12 = vImageConvert_XRGB2101010ToARGB16U(&src, 0xFFFFu, &dest, 0, 1023, permuteMap, a3);
      if (v12)
      {
        vImage_Error v14 = v12;
        _cg_jpeg_mem_term("iio_convert_XRGB2101010ToRGB16U", 1130, "*** ERROR: vImageConvert_XRGB2101010ToARGB16U failed err: %ld\n");
        goto LABEL_7;
      }
      vImage_Error v13 = vImageConvert_ARGB16UtoRGB16U(&dest, &rgbDest, a3);
      if (v13) {
        break;
      }
      src.data = (char *)src.data + src.rowBytes;
      rgbDest.data = (char *)rgbDest.data + rgbDest.rowBytes;
      if (a1->height <= (unsigned __int16)++v11) {
        goto LABEL_6;
      }
    }
    vImage_Error v14 = v13;
    _cg_jpeg_mem_term("iio_convert_XRGB2101010ToRGB16U", 1132, "*** ERROR: vImageConvert_ARGB16UtoRGB16U failed err: %ld\n");
  }
  else
  {
LABEL_6:
    vImage_Error v14 = 0;
  }
LABEL_7:
  free(v8);
  return v14;
}

vImage_Error iioConvert_XRGB2101010ToRGB888(const vImage_Buffer *a1, Pixel_8 a2, const vImage_Buffer *a3, int32_t a4, int32_t a5, const unsigned __int8 *a6, vImage_Flags a7)
{
  size_t v14 = 4 * a3->width;
  unint64_t v15 = malloc_type_malloc(v14 * a3->height, 0x23B3A213uLL);
  v18.data = v15;
  *(_OWORD *)&v18.double height = *(_OWORD *)&a3->height;
  v18.rowunint64_t Bytes = v14;
  vImage_Error v16 = vImageConvert_XRGB2101010ToARGB8888(a1, a2, &v18, a4, a5, a6, a7);
  if (!v16) {
    vImage_Error v16 = vImageConvert_RGBA8888toRGB888(&v18, a3, a7);
  }
  free(v15);
  return v16;
}

void IIOSubsampler::IIOSubsampler(IIOSubsampler *this, int a2, int a3, int a4, __int16 a5, __int16 a6, __int16 a7, __int16 a8, unsigned int a9, unsigned int a10)
{
  *(void *)this = &unk_1ED4DFEE0;
  *((_DWORD *)this + 2) = a2;
  *((_DWORD *)this + 3) = a3;
  *((_DWORD *)this + 4) = a4;
  *((_DWORD *)this + 5) = a4 & 0x1F;
  *((unsigned char *)this + 40) = BYTE1(a4) & 1;
  *((_WORD *)this + 12) = a5;
  *((_WORD *)this + 13) = a6;
  *((_WORD *)this + 14) = a7;
  *((_WORD *)this + 15) = a8;
  *((_DWORD *)this + 8) = a9;
  *((_DWORD *)this + 9) = a10;
  *((unsigned char *)this + 41) = 0;
}

void IIOSubsampler::~IIOSubsampler(IIOSubsampler *this)
{
}

vImage_Error IIOSubsampler::scale8bitChannels(IIOSubsampler *this, vImage_Buffer *a2, vImage_Buffer *a3, vImage_Error a4)
{
  vImagePixelCount width = a2->width;
  uint64_t v5 = a4;
  if (a2->rowBytes < width * a4 || a3->rowBytes < a3->width * a4) {
    return 4294945522;
  }
  vImage_Error v7 = a4;
  int v10 = (char *)malloc_type_malloc(a2->height * width, 0xE9765EA7uLL);
  vImagePixelCount height = a2->height;
  vImagePixelCount v12 = a2->width;
  src.data = v10;
  src.vImagePixelCount height = height;
  src.vImagePixelCount width = v12;
  src.rowunint64_t Bytes = v12;
  vImage_Error v13 = malloc_type_malloc(a3->height * a3->width, 0x874A699CuLL);
  vImagePixelCount v14 = a3->height;
  vImagePixelCount v15 = a3->width;
  v29.data = v13;
  v29.vImagePixelCount height = v14;
  v29.vImagePixelCount width = v15;
  v29.rowunint64_t Bytes = v15;
  if (v7)
  {
    uint64_t v16 = 0;
    do
    {
      vImagePixelCount v17 = a2->height;
      if (v17)
      {
        LODWORD(v18) = 0;
        vImagePixelCount v19 = a2->width;
        do
        {
          if (v19)
          {
            uint64_t v20 = 0;
            uint64_t v21 = &v10[v19 * v18];
            unsigned int v22 = (char *)a2->data + a2->rowBytes * v18;
            do
            {
              v21[v20++] = v22[v16];
              vImagePixelCount v19 = a2->width;
              v22 += v5;
            }
            while (v19 > v20);
            vImagePixelCount v17 = a2->height;
          }
          vImagePixelCount v18 = (v18 + 1);
        }
        while (v17 > v18);
      }
      vImage_Error v7 = vImageScale_Planar8(&src, &v29, 0, 0);
      vImagePixelCount v23 = a3->height;
      if (v23)
      {
        LODWORD(v24) = 0;
        vImagePixelCount v25 = a3->width;
        do
        {
          if (v25)
          {
            uint64_t v26 = 0;
            uint64_t v27 = (char *)a3->data + a3->rowBytes * v24;
            size_t v28 = (size_t)v13 + v29.rowBytes * v24;
            do
            {
              v27[v16] = *(unsigned char *)(v28 + v26++);
              vImagePixelCount v25 = a3->width;
              v27 += v5;
            }
            while (v25 > v26);
            vImagePixelCount v23 = a3->height;
          }
          vImagePixelCount v24 = (v24 + 1);
        }
        while (v23 > v24);
      }
      ++v16;
    }
    while (v16 != v5);
  }
  if (v10) {
    free(v10);
  }
  if (v13) {
    free(v13);
  }
  return v7;
}

vImage_Error IIOSubsampler::scale16bitChannels(IIOSubsampler *this, vImage_Buffer *a2, vImage_Buffer *a3, unsigned int a4)
{
  vImagePixelCount width = a2->width;
  uint64_t v6 = 2 * a4;
  if (a2->rowBytes < v6 * width || a3->rowBytes < v6 * a3->width) {
    return 4294945522;
  }
  size_t v12 = (2 * width);
  vImage_Error v13 = (char *)malloc_type_malloc(a2->height * v12, 0xC25A23FAuLL);
  src.data = v13;
  *(_OWORD *)&src.vImagePixelCount height = *(_OWORD *)&a2->height;
  src.rowunint64_t Bytes = v12;
  size_t v14 = (2 * LODWORD(a3->width));
  vImagePixelCount v15 = (char *)malloc_type_malloc(a3->height * v14, 0xB42682E3uLL);
  dest.data = v15;
  *(_OWORD *)&dest.vImagePixelCount height = *(_OWORD *)&a3->height;
  dest.rowunint64_t Bytes = v14;
  if (a4)
  {
    int8x16_t v36 = this;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    uint64_t v35 = a4;
    do
    {
      vImagePixelCount height = a2->height;
      if (height)
      {
        unsigned int v19 = 0;
        uint64_t v20 = 0;
        vImagePixelCount v22 = a2->width;
        rowunint64_t Bytes = a2->rowBytes;
        vImagePixelCount v23 = (char *)a2->data + v16;
        do
        {
          if (v22)
          {
            uint64_t v24 = 0;
            vImagePixelCount v25 = v23;
            do
            {
              *(_WORD *)&v13[2 * v24++ + v19] = *v25;
              vImagePixelCount v25 = (_WORD *)((char *)v25 + v6);
            }
            while (v22 > v24);
          }
          ++v20;
          v19 += v12;
          v23 += rowBytes;
        }
        while (height > v20);
      }
      if (*((unsigned char *)v36 + 40)) {
        vImage_Error v26 = vImageScale_Planar16F(&src, &dest, 0, 0);
      }
      else {
        vImage_Error v26 = vImageScale_Planar16U(&src, &dest, 0, 0);
      }
      vImage_Error v8 = v26;
      vImagePixelCount v27 = a3->height;
      if (v27)
      {
        unsigned int v28 = 0;
        uint64_t v29 = 0;
        data = (char *)a3->data;
        vImagePixelCount v32 = a3->width;
        size_t v31 = a3->rowBytes;
        do
        {
          if (v32)
          {
            uint64_t v33 = 0;
            uint64_t v34 = data;
            do
            {
              *(_WORD *)&v34[v16] = *(_WORD *)&v15[2 * v33++ + v28];
              v34 += v6;
            }
            while (v32 > v33);
          }
          ++v29;
          data += v31;
          v28 += v14;
        }
        while (v27 > v29);
      }
      ++v17;
      v16 += 2;
    }
    while (v17 != v35);
    if (!v13) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  vImage_Error v8 = 0;
  if (v13) {
LABEL_24:
  }
    free(v13);
LABEL_25:
  if (v15) {
    free(v15);
  }
  return v8;
}

vImage_Error IIOSubsampler::scale32bitChannels(IIOSubsampler *this, vImage_Buffer *a2, vImage_Buffer *a3, vImage_Error a4)
{
  vImage_Error v4 = a4;
  vImagePixelCount width = a2->width;
  uint64_t v6 = 4 * a4;
  if (a2->rowBytes < v6 * width || a3->rowBytes < v6 * a3->width) {
    return 4294945522;
  }
  size_t v10 = (4 * width);
  int v11 = (char *)malloc_type_malloc(a2->height * v10, 0x25797BBBuLL);
  src.data = v11;
  *(_OWORD *)&src.vImagePixelCount height = *(_OWORD *)&a2->height;
  src.rowunint64_t Bytes = v10;
  size_t v12 = (4 * LODWORD(a3->width));
  vImage_Error v13 = (char *)malloc_type_malloc(a3->height * v12, 0xE543619uLL);
  dest.data = v13;
  *(_OWORD *)&dest.vImagePixelCount height = *(_OWORD *)&a3->height;
  dest.rowunint64_t Bytes = v12;
  if (v4)
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v32 = v4;
    do
    {
      vImagePixelCount height = a2->height;
      if (height)
      {
        unsigned int v17 = 0;
        uint64_t v18 = 0;
        vImagePixelCount v20 = a2->width;
        rowunint64_t Bytes = a2->rowBytes;
        uint64_t v21 = (char *)a2->data + v14;
        do
        {
          if (v20)
          {
            uint64_t v22 = 0;
            vImagePixelCount v23 = v21;
            do
            {
              *(_DWORD *)&v11[4 * v22++ + v17] = *v23;
              vImagePixelCount v23 = (_DWORD *)((char *)v23 + v6);
            }
            while (v20 > v22);
          }
          ++v18;
          v17 += v10;
          v21 += rowBytes;
        }
        while (height > v18);
      }
      vImage_Error v4 = vImageScale_PlanarF(&src, &dest, 0, 0);
      vImagePixelCount v24 = a3->height;
      if (v24)
      {
        unsigned int v25 = 0;
        uint64_t v26 = 0;
        data = (char *)a3->data;
        vImagePixelCount v29 = a3->width;
        size_t v28 = a3->rowBytes;
        do
        {
          if (v29)
          {
            uint64_t v30 = 0;
            size_t v31 = data;
            do
            {
              *(_DWORD *)&v31[v14] = *(_DWORD *)&v13[4 * v30++ + v25];
              v31 += v6;
            }
            while (v29 > v30);
          }
          ++v26;
          data += v28;
          v25 += v12;
        }
        while (v24 > v26);
      }
      ++v15;
      v14 += 4;
    }
    while (v15 != v32);
  }
  if (v11) {
    free(v11);
  }
  if (v13) {
    free(v13);
  }
  return v4;
}

vImage_Error IIOSubsampler::subsampleGray8(IIOSubsampler *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5)
{
  src.data = a2;
  src.vImagePixelCount height = a3;
  uint64_t v5 = *((void *)this + 1);
  *(void *)&long long v6 = v5;
  *((void *)&v6 + 1) = HIDWORD(v5);
  *(_OWORD *)&src.vImagePixelCount width = v6;
  vImagePixelCount v7 = *a5;
  dest.data = a4;
  dest.vImagePixelCount height = v7;
  uint64_t v8 = *((void *)this + 4);
  *(void *)&long long v6 = v8;
  *((void *)&v6 + 1) = HIDWORD(v8);
  *(_OWORD *)&dest.vImagePixelCount width = v6;
  vImage_Error v9 = vImageScale_Planar8(&src, &dest, 0, 0x20u);
  if (v9) {
    LogError("subsampleGray8", 267, "*** ERROR: vImageScale_Planar8 err = %ld\n", v9);
  }
  return v9;
}

vImage_Error IIOSubsampler::subsampleGray16(IIOSubsampler *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5)
{
  src.data = a2;
  src.vImagePixelCount height = a3;
  uint64_t v5 = *((void *)this + 1);
  *(void *)&long long v6 = v5;
  *((void *)&v6 + 1) = HIDWORD(v5);
  *(_OWORD *)&src.vImagePixelCount width = v6;
  vImagePixelCount v7 = *a5;
  dest.data = a4;
  dest.vImagePixelCount height = v7;
  uint64_t v8 = *((void *)this + 4);
  *(void *)&long long v6 = v8;
  *((void *)&v6 + 1) = HIDWORD(v8);
  *(_OWORD *)&dest.vImagePixelCount width = v6;
  vImage_Error v9 = vImageScale_Planar16U(&src, &dest, 0, 0x20u);
  if (v9) {
    LogError("subsampleGray16", 283, "*** ERROR: vImageScale_Planar16U err = %ld\n", v9);
  }
  return v9;
}

vImage_Error IIOSubsampler::subsampleRGB888(IIOSubsampler *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5)
{
  long long v6 = a4;
  vImagePixelCount v8 = a3;
  v31.data = a2;
  v31.vImagePixelCount height = a3;
  uint64_t v9 = *((void *)this + 1);
  *(void *)&long long v10 = v9;
  *((void *)&v10 + 1) = HIDWORD(v9);
  *(_OWORD *)&v31.vImagePixelCount width = v10;
  vImagePixelCount v11 = *a5;
  v30.data = a4;
  v30.vImagePixelCount height = v11;
  uint64_t v12 = *((void *)this + 4);
  *(void *)&long long v10 = v12;
  *((void *)&v10 + 1) = HIDWORD(v12);
  *(_OWORD *)&v30.vImagePixelCount width = v10;
  size_t v13 = (4 * v9);
  size_t v14 = (4 * v12 + 15) & 0xFFFFFFF0;
  src.data = malloc_type_malloc(v13 * (unint64_t)a3, 0x9FC8435BuLL);
  src.vImagePixelCount height = v8;
  src.vImagePixelCount width = *((unsigned int *)this + 2);
  src.rowunint64_t Bytes = v13;
  uint64_t v15 = malloc_type_malloc(*a5 * (unint64_t)v14, 0x8FBCB94DuLL);
  vImagePixelCount v16 = *a5;
  dest.data = v15;
  dest.vImagePixelCount height = v16;
  dest.vImagePixelCount width = *((unsigned int *)this + 8);
  dest.rowunint64_t Bytes = v14;
  vImage_Error v17 = vImageConvert_RGB888toARGB8888(&v31, 0, 0xFFu, &src, 0, 0);
  if (v17)
  {
    vImage_Error v22 = v17;
    IIO_vImageErrorString(v17);
    LogError("subsampleRGB888", 335, "*** ERROR: vImageConvert_RGB888toARGB8888 err = %ld (%s)\n");
  }
  else
  {
    vImage_Error v18 = vImageScale_ARGB8888(&src, &dest, 0, 0x20u);
    if (v18)
    {
      vImage_Error v22 = v18;
      IIO_vImageErrorString(v18);
      LogError("subsampleRGB888", 338, "*** ERROR: vImageScale_ARGB8888 err = %ld (%s)\n");
    }
    else
    {
      __int16 v19 = *((_WORD *)this + 15);
      if (v19)
      {
        if ((v19 & 2) != 0) {
          int v20 = 66051;
        }
        else {
          int v20 = 197121;
        }
        *(_DWORD *)permuteMap = v20;
        vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
        if (*a5)
        {
          unsigned int v23 = 0;
          data = (char *)dest.data;
          size_t v25 = *((unsigned int *)this + 9);
          do
          {
            memcpy(v6, data, v25);
            data += v14;
            size_t v25 = *((unsigned int *)this + 9);
            v6 += v25;
            ++v23;
          }
          while (v23 < *a5);
        }
        vImage_Error v22 = 0;
      }
      else
      {
        vImage_Error v21 = vImageConvert_ARGB8888toRGB888(&dest, &v30, 0);
        vImage_Error v22 = v21;
        if (v21)
        {
          IIO_vImageErrorString(v21);
          LogError("subsampleRGB888", 364, "*** ERROR: vImageConvert_ARGB8888toRGB888 err = %ld (%s)\n");
        }
      }
    }
  }
  if (src.data) {
    free(src.data);
  }
  if (dest.data) {
    free(dest.data);
  }
  return v22;
}

vImage_Error IIOSubsampler::subsampleRGBA8888(IIOSubsampler *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5)
{
  src.data = a2;
  src.vImagePixelCount height = a3;
  size_t v6 = *((unsigned int *)this + 3);
  src.vImagePixelCount width = *((unsigned int *)this + 2);
  src.rowunint64_t Bytes = v6;
  vImagePixelCount v7 = *a5;
  v24.data = a4;
  v24.vImagePixelCount height = v7;
  uint64_t v8 = *((void *)this + 4);
  *(void *)&long long v9 = v8;
  *((void *)&v9 + 1) = HIDWORD(v8);
  *(_OWORD *)&v24.vImagePixelCount width = v9;
  vImage_Buffer dest = src;
  int v10 = *((_DWORD *)this + 5);
  if ((v10 - 1) > 1)
  {
    size_t v13 = 0;
  }
  else
  {
    uint64_t v12 = malloc_type_malloc(v6 * a3, 0x1FAB4A1BuLL);
    if (!v12)
    {
      LogError("subsampleRGBA8888", 430, "*** ERROR: failed to allocte temp (%d bytes)\n", *((_DWORD *)this + 3) * a3);
      return 0;
    }
    size_t v13 = v12;
    dest.data = v12;
    int v10 = *((_DWORD *)this + 5);
  }
  if (v10 == 1)
  {
    vImage_Error v16 = vImageUnpremultiplyData_RGBA8888(&src, &dest, 0x10u);
    if (v16)
    {
      vImage_Error v15 = v16;
      IIO_vImageErrorString(v16);
      LogError("subsampleRGBA8888", 442, "*** ERROR: vImageUnpremultiplyData_RGBA8888 err = %ld (%s)\n");
      goto LABEL_25;
    }
  }
  else if (v10 == 2)
  {
    vImage_Error v14 = vImageUnpremultiplyData_ARGB8888(&src, &dest, 0x10u);
    if (v14)
    {
      vImage_Error v15 = v14;
      IIO_vImageErrorString(v14);
      LogError("subsampleRGBA8888", 437, "*** ERROR: vImageUnpremultiplyData_ARGB8888 err = %ld (%s)\n");
      goto LABEL_25;
    }
  }
  vImage_Error v17 = vImageScale_ARGB8888(&dest, &v24, 0, 0x20u);
  if (v17)
  {
    vImage_Error v15 = v17;
    IIO_vImageErrorString(v17);
    LogError("subsampleRGBA8888", 446, "*** ERROR: vImageScale_ARGB8888 err = %ld (%s)\n");
    goto LABEL_25;
  }
  int v18 = *((_DWORD *)this + 5);
  if (v18 == 1)
  {
    vImage_Error v20 = vImagePremultiplyData_RGBA8888(&v24, &v24, 0x10u);
    if (!v20) {
      goto LABEL_16;
    }
    vImage_Error v15 = v20;
    IIO_vImageErrorString(v20);
    LogError("subsampleRGBA8888", 456, "*** ERROR: vImagePremultiplyData_RGBA8888 err = %ld (%s)\n");
LABEL_25:
    if (!v13) {
      return v15;
    }
    goto LABEL_19;
  }
  if (v18 == 2)
  {
    vImage_Error v19 = vImagePremultiplyData_ARGB8888(&v24, &v24, 0x10u);
    if (v19)
    {
      vImage_Error v15 = v19;
      IIO_vImageErrorString(v19);
      LogError("subsampleRGBA8888", 451, "*** ERROR: vImagePremultiplyData_ARGB8888 err = %ld (%s)\n");
      goto LABEL_25;
    }
  }
LABEL_16:
  if ((*((_WORD *)this + 15) & 2) != 0)
  {
    *(_DWORD *)permuteMap = 50331906;
    vImagePermuteChannels_ARGB8888(&v24, &v24, permuteMap, 0x10u);
  }
  vImage_Error v15 = 0;
  if (v13) {
LABEL_19:
  }
    free(v13);
  return v15;
}

vImage_Error IIOSubsampler::subsampleRGBA16(IIOSubsampler *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5)
{
  src.data = a2;
  src.vImagePixelCount height = a3;
  size_t v6 = *((unsigned int *)this + 3);
  src.vImagePixelCount width = *((unsigned int *)this + 2);
  src.rowunint64_t Bytes = v6;
  vImagePixelCount v7 = *a5;
  v21.data = a4;
  v21.vImagePixelCount height = v7;
  uint64_t v8 = *((void *)this + 4);
  *(void *)&long long v9 = v8;
  *((void *)&v9 + 1) = HIDWORD(v8);
  *(_OWORD *)&v21.vImagePixelCount width = v9;
  vImage_Buffer dest = src;
  int v10 = *((_DWORD *)this + 5);
  if ((v10 - 1) > 1)
  {
    vImagePixelCount v11 = 0;
  }
  else
  {
    vImagePixelCount v11 = malloc_type_malloc(v6 * a3, 0x88A12BFDuLL);
    dest.data = v11;
    int v10 = *((_DWORD *)this + 5);
  }
  if (v10 == 1)
  {
    if (*((unsigned char *)this + 40)) {
      vImage_Error v12 = vImageUnpremultiplyData_RGBA16F(&src, &dest, 0);
    }
    else {
      vImage_Error v12 = vImageUnpremultiplyData_RGBA16U(&src, &dest, 0);
    }
    vImage_Error v14 = v12;
    if (v12)
    {
      IIO_vImageErrorString(v12);
      LogError("subsampleRGBA16", 514, "*** ERROR: vImageUnpremultiplyData_RGBA16%c err = %ld (%s)\n");
      goto LABEL_35;
    }
  }
  else if (v10 == 2)
  {
    if (*((unsigned char *)this + 40))
    {
      vImage_Buffer dest = src;
    }
    else
    {
      vImage_Error v13 = vImageUnpremultiplyData_ARGB16U(&src, &dest, 0);
      if (v13)
      {
        vImage_Error v14 = v13;
        IIO_vImageErrorString(v13);
        LogError("subsampleRGBA16", 506, "*** ERROR: vImageUnpremultiplyData_ARGB16U err = %ld (%s)\n");
        goto LABEL_35;
      }
    }
  }
  if (*((unsigned char *)this + 40)) {
    vImage_Error v15 = vImageScale_ARGB16F(&dest, &v21, 0, 0x10u);
  }
  else {
    vImage_Error v15 = vImageScale_ARGB16U(&dest, &v21, 0, 0x20u);
  }
  vImage_Error v14 = v15;
  if (v15)
  {
    IIO_vImageErrorString(v15);
    LogError("subsampleRGBA16", 522, "*** ERROR: vImageScale_ARGB16%c err = %ld (%s)\n");
    goto LABEL_35;
  }
  int v16 = *((_DWORD *)this + 5);
  if (v16 == 1)
  {
    if (*((unsigned char *)this + 40)) {
      vImage_Error v17 = vImagePremultiplyData_RGBA16F(&v21, &v21, 0);
    }
    else {
      vImage_Error v17 = vImagePremultiplyData_RGBA16U(&v21, &v21, 0);
    }
    vImage_Error v14 = v17;
    if (!v17) {
      goto LABEL_29;
    }
    IIO_vImageErrorString(v17);
    LogError("subsampleRGBA16", 538, "*** ERROR: vImagePremultiplyData_RGBA16%c err = %ld (%s)\n");
LABEL_35:
    if (!v11) {
      return v14;
    }
    goto LABEL_30;
  }
  if (v16 != 2 || *((unsigned char *)this + 40))
  {
    vImage_Error v14 = 0;
    if (!v11) {
      return v14;
    }
    goto LABEL_30;
  }
  vImage_Error v18 = vImagePremultiplyData_ARGB16U(&v21, &v21, 0);
  vImage_Error v14 = v18;
  if (v18)
  {
    IIO_vImageErrorString(v18);
    LogError("subsampleRGBA16", 530, "*** ERROR: vImagePremultiplyData_ARGB16U err = %ld (%s)\n");
    goto LABEL_35;
  }
LABEL_29:
  if (v11) {
LABEL_30:
  }
    free(v11);
  return v14;
}

vImage_Error IIOSubsampler::subsampleRGBA32(IIOSubsampler *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5)
{
  src.data = a2;
  src.vImagePixelCount height = a3;
  size_t v6 = *((unsigned int *)this + 3);
  src.vImagePixelCount width = *((unsigned int *)this + 2);
  src.rowunint64_t Bytes = v6;
  vImagePixelCount v7 = *a5;
  v21.data = a4;
  v21.vImagePixelCount height = v7;
  uint64_t v8 = *((void *)this + 4);
  *(void *)&long long v9 = v8;
  *((void *)&v9 + 1) = HIDWORD(v8);
  *(_OWORD *)&v21.vImagePixelCount width = v9;
  vImage_Buffer dest = src;
  int v10 = *((_DWORD *)this + 5);
  if ((v10 - 1) > 1)
  {
    vImagePixelCount v11 = 0;
  }
  else
  {
    vImagePixelCount v11 = malloc_type_malloc(v6 * a3, 0xF8DC76C0uLL);
    dest.data = v11;
    int v10 = *((_DWORD *)this + 5);
  }
  if (v10 == 1)
  {
    if (*((unsigned char *)this + 40)) {
      vImage_Error v12 = vImageUnpremultiplyData_RGBA16F(&src, &dest, 0);
    }
    else {
      vImage_Error v12 = vImageUnpremultiplyData_RGBA16U(&src, &dest, 0);
    }
    vImage_Error v14 = v12;
    if (v12)
    {
      IIO_vImageErrorString(v12);
      LogError("subsampleRGBA32", 588, "*** ERROR: vImageUnpremultiplyData_RGBA16%c err = %ld (%s)\n");
      goto LABEL_35;
    }
  }
  else if (v10 == 2)
  {
    if (*((unsigned char *)this + 40))
    {
      vImage_Buffer dest = src;
    }
    else
    {
      vImage_Error v13 = vImageUnpremultiplyData_ARGB16U(&src, &dest, 0);
      if (v13)
      {
        vImage_Error v14 = v13;
        IIO_vImageErrorString(v13);
        LogError("subsampleRGBA32", 580, "*** ERROR: vImageUnpremultiplyData_ARGB16U err = %ld (%s)\n");
        goto LABEL_35;
      }
    }
  }
  if (*((unsigned char *)this + 40)) {
    vImage_Error v15 = vImageScale_ARGB16F(&dest, &v21, 0, 0x10u);
  }
  else {
    vImage_Error v15 = vImageScale_ARGB16U(&dest, &v21, 0, 0x20u);
  }
  vImage_Error v14 = v15;
  if (v15)
  {
    IIO_vImageErrorString(v15);
    LogError("subsampleRGBA32", 596, "*** ERROR: vImageScale_ARGB16%c err = %ld (%s)\n");
    goto LABEL_35;
  }
  int v16 = *((_DWORD *)this + 5);
  if (v16 == 1)
  {
    if (*((unsigned char *)this + 40)) {
      vImage_Error v17 = vImagePremultiplyData_RGBA16F(&v21, &v21, 0);
    }
    else {
      vImage_Error v17 = vImagePremultiplyData_RGBA16U(&v21, &v21, 0);
    }
    vImage_Error v14 = v17;
    if (!v17) {
      goto LABEL_29;
    }
    IIO_vImageErrorString(v17);
    LogError("subsampleRGBA32", 612, "*** ERROR: vImagePremultiplyData_RGBA16%c err = %ld (%s)\n");
LABEL_35:
    if (!v11) {
      return v14;
    }
    goto LABEL_30;
  }
  if (v16 != 2 || *((unsigned char *)this + 40))
  {
    vImage_Error v14 = 0;
    if (!v11) {
      return v14;
    }
    goto LABEL_30;
  }
  vImage_Error v18 = vImagePremultiplyData_ARGB16U(&v21, &v21, 0);
  vImage_Error v14 = v18;
  if (v18)
  {
    IIO_vImageErrorString(v18);
    LogError("subsampleRGBA32", 604, "*** ERROR: vImagePremultiplyData_ARGB16U err = %ld (%s)\n");
    goto LABEL_35;
  }
LABEL_29:
  if (v11) {
LABEL_30:
  }
    free(v11);
  return v14;
}

uint64_t IIOSubsampler::subsample(IIOSubsampler *this, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4, unsigned int *a5)
{
  switch(*((_WORD *)this + 13))
  {
    case 1:
      int v6 = *((unsigned __int16 *)this + 12);
      if (v6 == 16)
      {
        if (IIOSubsampler::subsampleGray16(this, a2, a3, a4, a5)) {
          goto LABEL_32;
        }
      }
      else if (v6 != 8 || IIOSubsampler::subsampleGray8(this, a2, a3, a4, a5))
      {
        goto LABEL_32;
      }
      return 1;
    case 2:
      int v7 = *((unsigned __int16 *)this + 12);
      if (v7 == 16)
      {
        v39.data = a2;
        v39.vImagePixelCount height = a3;
        uint64_t v21 = *((void *)this + 1);
        *(void *)&long long v22 = v21;
        *((void *)&v22 + 1) = HIDWORD(v21);
        *(_OWORD *)&v39.vImagePixelCount width = v22;
        vImagePixelCount v23 = *a5;
        v38.data = a4;
        v38.vImagePixelCount height = v23;
        uint64_t v24 = *((void *)this + 4);
        *(void *)&long long v22 = v24;
        *((void *)&v22 + 1) = HIDWORD(v24);
        *(_OWORD *)&v38.vImagePixelCount width = v22;
        unsigned int v25 = 2;
        goto LABEL_31;
      }
      if (v7 != 8) {
        goto LABEL_32;
      }
      v39.data = a2;
      v39.vImagePixelCount height = a3;
      uint64_t v8 = *((void *)this + 1);
      *(void *)&long long v9 = v8;
      *((void *)&v9 + 1) = HIDWORD(v8);
      *(_OWORD *)&v39.vImagePixelCount width = v9;
      vImagePixelCount v10 = *a5;
      v38.data = a4;
      v38.vImagePixelCount height = v10;
      uint64_t v11 = *((void *)this + 4);
      *(void *)&long long v9 = v11;
      *((void *)&v9 + 1) = HIDWORD(v11);
      *(_OWORD *)&v38.vImagePixelCount width = v9;
      vImage_Error v12 = 2;
      goto LABEL_22;
    case 3:
      int v13 = *((unsigned __int16 *)this + 12);
      if (v13 == 32)
      {
        v39.data = a2;
        v39.vImagePixelCount height = a3;
        uint64_t v30 = *((void *)this + 1);
        *(void *)&long long v31 = v30;
        *((void *)&v31 + 1) = HIDWORD(v30);
        *(_OWORD *)&v39.vImagePixelCount width = v31;
        vImagePixelCount v32 = *a5;
        v38.data = a4;
        v38.vImagePixelCount height = v32;
        uint64_t v33 = *((void *)this + 4);
        *(void *)&long long v31 = v33;
        *((void *)&v31 + 1) = HIDWORD(v33);
        *(_OWORD *)&v38.vImagePixelCount width = v31;
        if (IIOSubsampler::scale32bitChannels(this, &v39, &v38, 3)) {
          goto LABEL_32;
        }
        return 1;
      }
      if (v13 == 16)
      {
        v39.data = a2;
        v39.vImagePixelCount height = a3;
        uint64_t v34 = *((void *)this + 1);
        *(void *)&long long v35 = v34;
        *((void *)&v35 + 1) = HIDWORD(v34);
        *(_OWORD *)&v39.vImagePixelCount width = v35;
        vImagePixelCount v36 = *a5;
        v38.data = a4;
        v38.vImagePixelCount height = v36;
        uint64_t v37 = *((void *)this + 4);
        *(void *)&long long v35 = v37;
        *((void *)&v35 + 1) = HIDWORD(v37);
        *(_OWORD *)&v38.vImagePixelCount width = v35;
        unsigned int v25 = 3;
        goto LABEL_31;
      }
      if (v13 == 8 && !IIOSubsampler::subsampleRGB888(this, a2, a3, a4, a5)) {
        return 1;
      }
      goto LABEL_32;
    case 4:
      int v14 = *((unsigned __int16 *)this + 12);
      if (v14 == 32)
      {
        if (IIOSubsampler::subsampleRGBA32(this, a2, a3, a4, a5)) {
          goto LABEL_32;
        }
      }
      else if (v14 == 16)
      {
        if (IIOSubsampler::subsampleRGBA16(this, a2, a3, a4, a5)) {
          goto LABEL_32;
        }
      }
      else if (v14 != 8 || IIOSubsampler::subsampleRGBA8888(this, a2, a3, a4, a5))
      {
        goto LABEL_32;
      }
      return 1;
    case 5:
      int v15 = *((unsigned __int16 *)this + 12);
      if (v15 == 16)
      {
        v39.data = a2;
        v39.vImagePixelCount height = a3;
        uint64_t v26 = *((void *)this + 1);
        *(void *)&long long v27 = v26;
        *((void *)&v27 + 1) = HIDWORD(v26);
        *(_OWORD *)&v39.vImagePixelCount width = v27;
        vImagePixelCount v28 = *a5;
        v38.data = a4;
        v38.vImagePixelCount height = v28;
        uint64_t v29 = *((void *)this + 4);
        *(void *)&long long v27 = v29;
        *((void *)&v27 + 1) = HIDWORD(v29);
        *(_OWORD *)&v38.vImagePixelCount width = v27;
        unsigned int v25 = 5;
LABEL_31:
        if (!IIOSubsampler::scale16bitChannels(this, &v39, &v38, v25)) {
          return 1;
        }
      }
      else if (v15 == 8)
      {
        v39.data = a2;
        v39.vImagePixelCount height = a3;
        uint64_t v16 = *((void *)this + 1);
        *(void *)&long long v17 = v16;
        *((void *)&v17 + 1) = HIDWORD(v16);
        *(_OWORD *)&v39.vImagePixelCount width = v17;
        vImagePixelCount v18 = *a5;
        v38.data = a4;
        v38.vImagePixelCount height = v18;
        uint64_t v19 = *((void *)this + 4);
        *(void *)&long long v17 = v19;
        *((void *)&v17 + 1) = HIDWORD(v19);
        *(_OWORD *)&v38.vImagePixelCount width = v17;
        vImage_Error v12 = 5;
LABEL_22:
        if (!IIOSubsampler::scale8bitChannels(this, &v39, &v38, v12)) {
          return 1;
        }
      }
LABEL_32:
      if (!*((unsigned char *)this + 41))
      {
        *((unsigned char *)this + 41) = 1;
        _cg_jpeg_mem_term("subsample", 745, "*** ERROR subsample #channels: %d    bitsPerComponent: %d not handled\n", *((unsigned __int16 *)this + 13), *((unsigned __int16 *)this + 12));
      }
      return 0;
    default:
      goto LABEL_32;
  }
}

uint64_t IIOImageAnimator::IIOImageAnimator(uint64_t a1, uint64_t a2, const void *a3, IIODictionary *a4)
{
  *(void *)a1 = &unk_1ED4E3E08;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  IIO_LoadCoreMediaSymbols();
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 24) = _Block_copy(a3);
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  if (IIODictionary::containsKey(a4, @"StartIndex")) {
    Uint64ForKeCGFloat y = (uint64_t)IIODictionary::getUint64ForKey(a4, @"StartIndex");
  }
  else {
    Uint64ForKeCGFloat y = -1;
  }
  *(void *)(a1 + 128) = Uint64ForKey;
  unsigned int v9 = IIODictionary::containsKey(a4, @"DelayTime");
  double DoubleForKey = -1.0;
  if (v9) {
    double DoubleForKey = IIODictionary::getDoubleForKey(a4, @"DelayTime");
  }
  *(void *)(a1 + 136) = -1;
  *(double *)(a1 + 144) = DoubleForKey;
  if (IIODictionary::containsKey(a4, @"LoopCount"))
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a4, @"LoopCount");
    CFNumberRef v12 = ObjectForKey;
    if (ObjectForKey != (const __CFDictionary *)*MEMORY[0x1E4F1D3A8])
    {
      CFTypeID v13 = CFGetTypeID(ObjectForKey);
      if (v13 == CFNumberGetTypeID()) {
        CFNumberGetValue(v12, kCFNumberCFIndexType, (void *)(a1 + 136));
      }
    }
  }
  return a1;
}

void sub_1887CE7BC(_Unwind_Exception *exception_object)
{
  vImage_Error v4 = *(std::__shared_weak_count **)(v1 + 120);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  uint64_t v5 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 64) = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

void IIOImageAnimator::~IIOImageAnimator(IIOImageAnimator *this)
{
  *(void *)this = &unk_1ED4E3E08;
  unint64_t v2 = (IIOImageSource *)*((void *)this + 1);
  if (v2)
  {
    uint64_t v3 = (const void *)IIOImageSource::cf(v2);
    CFRelease(v3);
  }
  vImage_Error v4 = (const void *)*((void *)this + 12);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 15);
  *((void *)this + 14) = 0;
  *((void *)this + 15) = 0;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  int v6 = (const void *)*((void *)this + 21);
  if (v6) {
    CFRelease(v6);
  }
  int v7 = (const void *)*((void *)this + 22);
  if (v7) {
    CFRelease(v7);
  }
  CGColorSpaceRelease(*((CGColorSpaceRef *)this + 10));
  _Block_release(*((const void **)this + 3));
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v8) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v8);
  }
  unsigned int v9 = (void *)*((void *)this + 7);
  if (v9)
  {
    *((void *)this + 8) = v9;
    operator delete(v9);
  }
}

{
  uint64_t vars8;

  IIOImageAnimator::~IIOImageAnimator(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIOImageAnimator::setup(IIOImageSource **this)
{
  memset(v37, 0, sizeof(v37));
  IIODictionary::IIODictionary((IIODictionary *)v37);
  CFDictionaryRef v2 = IIOImageSource::copyProperties(this[1], (IIODictionary *)v37);
  if (!v2)
  {
    uint64_t v5 = 4294945155;
    goto LABEL_45;
  }
  CFStringRef Type = (const __CFString *)IIOImageSource::getType((IIO_Reader **)this[1]);
  memset(v36, 0, sizeof(v36));
  IIODictionary::IIODictionary((IIODictionary *)v36, v2);
  if (CFEqual(Type, @"com.compuserve.gif"))
  {
    int v6 = &kCGImagePropertyGIFDictionary;
LABEL_14:
    CFStringRef v4 = *v6;
    goto LABEL_15;
  }
  if (CFEqual(Type, @"public.png"))
  {
    int v6 = &kCGImagePropertyPNGDictionary;
    goto LABEL_14;
  }
  if (CFEqual(Type, @"public.heics"))
  {
    int v6 = &kCGImagePropertyHEICSDictionary;
    goto LABEL_14;
  }
  if (CFEqual(Type, @"public.avis"))
  {
    int v6 = &kCGImagePropertyAVISDictionary;
    goto LABEL_14;
  }
  if (CFStringCompare(Type, @"org.webmproject.webp", 0)) {
    CFStringRef v4 = 0;
  }
  else {
    CFStringRef v4 = @"{WebP}";
  }
LABEL_15:
  this[5] = (IIOImageSource *)IIODictionary::getUint32ForKeyGroup((IIODictionary *)v36, @"CanvasPixelWidth", v4);
  unsigned int Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v36, @"CanvasPixelHeight", v4);
  this[6] = (IIOImageSource *)Uint32ForKeyGroup;
  if (this[5] && Uint32ForKeyGroup)
  {
    CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup((IIODictionary *)v36, @"FrameInfo", v4);
    CFIndex Count = CFArrayGetCount(ObjectForKeyGroup);
    this[4] = (IIOImageSource *)Count;
    if (Count)
    {
      unint64_t v10 = 0;
      uint64_t v11 = (void **)(this + 7);
      do
      {
        ValueAtIndeCGFloat x = (const __CFDictionary *)CFArrayGetValueAtIndex(ObjectForKeyGroup, v10);
        CFDictionaryRef v33 = 0;
        uint64_t v34 = 0;
        uint64_t v35 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v33, ValueAtIndex);
        double DoubleForKey = IIODictionary::getDoubleForKey((IIODictionary *)&v33, @"DelayTime");
        double v14 = DoubleForKey;
        uint64_t v16 = (double *)this[8];
        int v15 = this[9];
        if (v16 >= (double *)v15)
        {
          vImagePixelCount v18 = (double *)*v11;
          uint64_t v19 = ((char *)v16 - (unsigned char *)*v11) >> 3;
          unint64_t v20 = v19 + 1;
          if ((unint64_t)(v19 + 1) >> 61) {
            std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v21 = v15 - (IIOImageSource *)v18;
          if (v21 >> 2 > v20) {
            unint64_t v20 = v21 >> 2;
          }
          if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v22 = v20;
          }
          if (v22)
          {
            vImagePixelCount v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)(this + 9), v22);
            vImagePixelCount v18 = (double *)this[7];
            uint64_t v16 = (double *)this[8];
          }
          else
          {
            vImagePixelCount v23 = 0;
          }
          uint64_t v24 = (IIOImageSource *)&v23[8 * v19];
          *(double *)uint64_t v24 = v14;
          long long v17 = (IIOImageSource *)((char *)v24 + 8);
          while (v16 != v18)
          {
            uint64_t v25 = *((void *)v16-- - 1);
            *((void *)v24 - 1) = v25;
            uint64_t v24 = (IIOImageSource *)((char *)v24 - 8);
          }
          this[7] = v24;
          this[8] = v17;
          this[9] = (IIOImageSource *)&v23[8 * v22];
          if (v18) {
            operator delete(v18);
          }
        }
        else
        {
          double *v16 = DoubleForKey;
          long long v17 = (IIOImageSource *)(v16 + 1);
        }
        this[8] = v17;
        IIODictionary::~IIODictionary((IIODictionary *)&v33);
        ++v10;
      }
      while (v10 < (unint64_t)this[4]);
      CFDictionaryRef v33 = 0;
      uint64_t v34 = 0;
      uint64_t v35 = 0;
      IIODictionary::IIODictionary((IIODictionary *)&v33);
      uint64_t v26 = IIOImageSource::copyPropertiesAtIndex(this[1], 0, &v33);
      memset(v32, 0, sizeof(v32));
      IIODictionary::IIODictionary((IIODictionary *)v32, (const __CFDictionary *)v26);
      *((unsigned char *)this + 92) = IIODictionary::getBoolForKey((IIODictionary *)v32, "HasAlpha");
      Plugin = IIOImageSource::getAnimationReadPlugin(this[1]);
      this[2] = Plugin;
      CGColorSpaceRef ColorSpace = (CGColorSpace *)IIOReadPlugin::getColorSpace(Plugin);
      this[10] = CGColorSpaceRetain(ColorSpace);
      ColorSpaceCGColorSpaceModel Model = IIOReadPlugin::getColorSpaceModel(this[2]);
      *((_DWORD *)this + 22) = ColorSpaceModel;
      if (ColorSpaceModel >= 2)
      {
        _cg_jpeg_mem_term("setup", 274, "*** ERROR: unsupported colorspace");
        uint64_t v5 = 4294945154;
      }
      else if (this[10])
      {
        uint64_t v5 = 0;
      }
      else
      {
        uint64_t v30 = (CFStringRef *)MEMORY[0x1E4F1DC00];
        if (ColorSpaceModel) {
          uint64_t v30 = (CFStringRef *)MEMORY[0x1E4F1DC98];
        }
        uint64_t v5 = 0;
        this[10] = CGColorSpaceCreateWithName(*v30);
      }
      IIODictionary::~IIODictionary((IIODictionary *)v32);
      IIODictionary::~IIODictionary((IIODictionary *)&v33);
      IIODictionary::~IIODictionary((IIODictionary *)v36);
      goto LABEL_43;
    }
    _cg_jpeg_mem_term("setup", 256, "*** ERROR: bad image count (%ld)", 0);
  }
  else
  {
    _cg_jpeg_mem_term("setup", 253, "*** ERROR: bad image dimensions (%ldx%ld)", this[5], Uint32ForKeyGroup);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v36);
  uint64_t v26 = 0;
  uint64_t v5 = 4294945155;
LABEL_43:
  CFRelease(v2);
  if (v26) {
    CFRelease(v26);
  }
LABEL_45:
  IIODictionary::~IIODictionary((IIODictionary *)v37);
  return v5;
}

void sub_1887CED24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va2, a6);
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)va2);
  _Unwind_Resume(a1);
}

uint64_t IIOImageAnimator::start(IIOImageAnimator *this)
{
  v50[0] = 0;
  v50[1] = v50;
  v50[2] = 0x2000000000;
  uint64_t v2 = *((void *)this + 16);
  if (v2 == -1) {
    uint64_t v2 = 0;
  }
  v50[3] = v2;
  unint64_t v3 = *((void *)this + 5);
  unint64_t v4 = *((void *)this + 6);
  memset(v49, 0, sizeof(v49));
  IIODictionary::IIODictionary((IIODictionary *)v49);
  long long v47 = xmmword_1ED4F0CC0;
  long long v48 = *(_OWORD *)&off_1ED4F0CD0;
  IIODictionary::setObjectForKey(v5, (const void *)*MEMORY[0x1E4F1CFD0], (const __CFString *)*MEMORY[0x1E4F1DD78]);
  double v6 = (double)v3;
  uint64_t v43 = 0;
  int v44 = &v43;
  uint64_t v45 = 0x2000000000;
  uint64_t v46 = 0;
  uint64_t v46 = CGImageProviderCreate();
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v40);
  uint64_t v7 = (const void *)*MEMORY[0x1E4F1DD30];
  CFStringRef v8 = (const __CFString *)*MEMORY[0x1E4F1DD38];
  IIODictionary::setObjectForKey(v9, (const void *)*MEMORY[0x1E4F1DD30], (const __CFString *)*MEMORY[0x1E4F1DD38]);
  (*(void (**)(void, uint64_t))(**((void **)this + 2) + 80))(*((void *)this + 2), v41);
  if (*((_DWORD *)this + 22)) {
    int v10 = 1111970369;
  }
  else {
    int v10 = 843264056;
  }
  SurfaceWithFormat = IIO_CreateSurfaceWithFormat(v10, v3, v4, *((CGColorSpace **)this + 10));
  *((void *)this + 21) = SurfaceWithFormat;
  IOSurfaceIncrementUseCount(SurfaceWithFormat);
  if (*((void *)this + 4) == 1)
  {
    LOBYTE(v29[0]) = 0;
    uint64_t v30 = 0;
    long long v31 = 0;
    uint64_t v32 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v30);
    IIODictionary::setObjectForKey((IIODictionary *)&v30, v7, v8);
    uint64_t v39 = 0;
    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    long long v34 = 0u;
    IIODecodeParameter::IIODecodeParameter(&v34, 0, v44[3], 0, v31, 0.0, 0.0, (double)v3, (double)v4, (double)v3, (double)v4);
    IIOReadPlugin::decodeImageIntoIOSurface(*((IIOReadPlugin **)this + 2), (IIODecodeParameter *)&v34, *((__IOSurface **)this + 21));
    CFNumberRef v12 = (CGImage *)CGImageCreateFromIOSurface(*((__IOSurface **)this + 21), 0);
    uint64_t v13 = (IIOImageAnimator *)(*(uint64_t (**)(void))(*((void *)this + 3) + 16))();
    IIOImageAnimator::_releaseFrameImage(v13, v12);
    IIODecodeParameter::~IIODecodeParameter((IIODecodeParameter *)&v34);
    IIODictionary::~IIODictionary((IIODictionary *)&v30);
    uint64_t v14 = 0;
  }
  else
  {
    int v15 = IIO_CreateSurfaceWithFormat(v10, v3, v4, *((CGColorSpace **)this + 10));
    *((void *)this + 22) = v15;
    IOSurfaceIncrementUseCount(v15);
    uint64_t v16 = *((void *)this + 21);
    if (v16 && *((void *)this + 22))
    {
      *(void *)&long long v34 = 0;
      *((void *)&v34 + 1) = &v34;
      long long v35 = 0x2000000000uLL;
      uint64_t v30 = 0;
      long long v31 = &v30;
      uint64_t v32 = 0x2000000000;
      uint64_t v33 = v16;
      v29[0] = 0;
      v29[1] = v29;
      _OWORD v29[2] = 0x2000000000;
      void v29[3] = 0;
      long long v17 = malloc_type_calloc(8uLL, 2uLL, 0x913437F6uLL);
      v28[0] = 0;
      v28[1] = v28;
      CGColorSpaceRef v28[2] = 0x2000000000;
      void v28[3] = 0;
      *((void *)this + 20) = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, MEMORY[0x1E4F14428]);
      uint64_t v27 = 0;
      HostTimeClocuint64_t k = gFunc_CMClockGetHostTimeClock();
      gFunc_CMTimebaseCreateWithSourceClock(*MEMORY[0x1E4F1CF80], HostTimeClock, &v27);
      if (v27)
      {
        gFunc_CMTimebaseAddTimerDispatchSource(v27, *((void *)this + 20));
        uint64_t v19 = *((void *)this + 20);
        uint64_t v26 = 0;
        long long v25 = *(_OWORD *)&kCMTimeZero.value;
        gFunc_CMTimebaseSetTimerDispatchSourceNextFireTime(v27, v19, &v25, 0);
        uint64_t Ref = IIOImageSource::imageReadRef(*((IIOImageSource **)this + 1));
        uint64_t v21 = CGImageReadSessionCreate(Ref);
        *((void *)this + 12) = v21;
        *((void *)this + 13) = CGImageSourceGetSource(v21);
        *((void *)this + 19) = IIOImageSource::reader(*((IIOImageSource **)this + 1));
        unint64_t v22 = *((void *)this + 20);
        handler[0] = MEMORY[0x1E4F143A8];
        handler[1] = 0x40000000;
        handler[2] = ___ZN16IIOImageAnimator5startEv_block_invoke;
        handler[3] = &unk_1E53CCE90;
        handler[4] = v50;
        handler[5] = &v43;
        handler[11] = 0;
        handler[12] = 0;
        *(double *)&handler[13] = v6;
        *(double *)&handler[14] = (double)v4;
        *(double *)&handler[15] = v6;
        *(double *)&handler[16] = (double)v4;
        void handler[6] = &v30;
        handler[7] = v29;
        handler[8] = v28;
        handler[9] = &v34;
        handler[10] = this;
        handler[17] = v17;
        handler[18] = v27;
        dispatch_source_set_event_handler(v22, handler);
        gFunc_CMTimebaseSetRate(v27, 1.0);
        dispatch_resume(*((dispatch_object_t *)this + 20));
        uint64_t v14 = 0;
      }
      else
      {
        uint64_t v14 = 4294945152;
      }
      _Block_object_dispose(v28, 8);
      _Block_object_dispose(v29, 8);
      _Block_object_dispose(&v30, 8);
      _Block_object_dispose(&v34, 8);
    }
    else
    {
      uint64_t v14 = 4294945152;
    }
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v40);
  _Block_object_dispose(&v43, 8);
  IIODictionary::~IIODictionary((IIODictionary *)v49);
  _Block_object_dispose(v50, 8);
  return v14;
}

void sub_1887CF264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose(&a41, 8);
  _Block_object_dispose(&a45, 8);
  IIODictionary::~IIODictionary((IIODictionary *)(v45 - 248));
  _Block_object_dispose((const void *)(v45 - 224), 8);
  IIODictionary::~IIODictionary((IIODictionary *)(v45 - 152));
  _Block_object_dispose((const void *)(v45 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t _CopyImageBlockSetCallback()
{
  return 0;
}

uint64_t _CopyIOSurfaceCallback()
{
  return 0;
}

void IIOImageAnimator::_releaseFrameImage(IIOImageAnimator *this, CGImage *a2)
{
  if (CGImageGetImageProvider())
  {
    CGImageProviderSetProperty();
    CGImageProviderSetProperty();
  }

  CGImageRelease(a2);
}

void ___ZN16IIOImageAnimator5startEv_block_invoke(uint64_t a1)
{
  void (*v16)(long long *__return_ptr, void *, unsigned char *);
  uint64_t v17;
  uint64_t v18;
  IIOImageAnimator *v19;
  IIOImageAnimator *v20;
  long long v21;
  uint64_t v22;
  unsigned char v23[24];
  void v24[3];
  long long v25;
  uint64_t v26;
  void block[5];
  void v28[3];
  long long v29;
  long long v30;
  _OWORD v31[5];
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;

  uint64_t v2 = *(void *)(a1 + 80);
  long long v36 = 0;
  uint64_t v33 = 0;
  long long v34 = 0;
  long long v35 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v33);
  IIODictionary::setObjectForKey(v3, (const void *)*MEMORY[0x1E4F1DD30], (const __CFString *)*MEMORY[0x1E4F1DD38]);
  uint64_t v32 = 0;
  memset(v31, 0, sizeof(v31));
  IIODecodeParameter::IIODecodeParameter(v31, 0, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v34, *(double *)(a1 + 88), *(double *)(a1 + 96), *(double *)(a1 + 104), *(double *)(a1 + 112), *(double *)(a1 + 120), *(double *)(a1 + 128));
  IIOReadPlugin::decodeImageIntoIOSurface(*(IIOReadPlugin **)(v2 + 16), (IIODecodeParameter *)v31, *(__IOSurface **)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
  *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = *(void *)(*(void *)(*(void *)(a1 + 48) + 8)
                                                                          + 24);
  uint64_t v29 = 0u;
  uint64_t v30 = 0u;
  memset(v28, 0, sizeof(v28));
  IIODictionary::IIODictionary((IIODictionary *)v28);
  IIODictionary::setObjectForKey((IIODictionary *)v28, (const void *)*MEMORY[0x1E4F1CFD0], (const __CFString *)*MEMORY[0x1E4F1DD78]);
  LODWORD(v29) = 2;
  *((void *)&v29 + 1) = _copyImageBlockSetCallback;
  *(void *)&uint64_t v30 = _copyIOSurfaceCallback;
  *((void *)&v30 + 1) = _releaseFrameImageProviderInfo;
  unint64_t v4 = (IIOImageAnimator *)CGImageProviderCreate();
  if (v4)
  {
    unint64_t v4 = (IIOImageAnimator *)CGImageCreateWithImageProvider();
    uint64_t v5 = v4;
    if (v4)
    {
      CGImageProviderRelease();
      unint64_t v4 = (IIOImageAnimator *)(*(uint64_t (**)(void))(*(void *)(v2 + 24) + 16))();
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(void *)(*(void *)(a1 + 64) + 8);
  uint64_t v7 = *(void *)(v6 + 24);
  if (v7 == 2)
  {
    uint64_t v9 = *(void *)(a1 + 136);
    int v10 = *(CGImage **)v9;
    *(void *)uint64_t v9 = *(void *)(v9 + 8);
    IIOImageAnimator::_releaseFrameImage(v4, v10);
  }
  else
  {
    if (v7 == 1)
    {
      **(void **)(a1 + 136) = *(void *)(*(void *)(a1 + 136) + 8);
      uint64_t v6 = *(void *)(*(void *)(a1 + 64) + 8);
      uint64_t v8 = *(void *)(v6 + 24) + 1;
    }
    else
    {
      if (v7) {
        goto LABEL_11;
      }
      uint64_t v8 = 1;
    }
    *(void *)(v6 + 24) = v8;
  }
LABEL_11:
  *(void *)(*(void *)(a1 + 136) + 8) = v5;
  CGImageRetain(*(CGImageRef *)(*(void *)(a1 + 136) + 8));
  CGImageRelease(v5);
  CGImageProviderRelease();
  uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v12 = *(void *)(v2 + 168);
  if (*(void *)(v11 + 24) == v12) {
    uint64_t v12 = *(void *)(v2 + 176);
  }
  *(void *)(v11 + 24) = v12;
  if (v36) {
    goto LABEL_20;
  }
  if (*(void *)(v2 + 32) < 2uLL
    || (++*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24),
        uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8),
        *(void *)(v13 + 24) >= *(void *)(v2 + 32))
    && (*(void *)(v13 + 24) = 0,
        *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 0,
        *(void *)(v2 + 136) != -1)
    && (uint64_t v14 = *(void *)(*(void *)(a1 + 72) + 8),
        unint64_t v15 = *(void *)(v14 + 24) + 1,
        *(void *)(v14 + 24) = v15,
        v15 >= *(void *)(v2 + 136)))
  {
    long long v36 = 1;
LABEL_20:
    _cg_jpeg_mem_term("start_block_invoke", 448, "*** animation was stopped...\n");
    CFRelease(*(CFTypeRef *)(a1 + 144));
    dispatch_source_cancel(*(dispatch_source_t *)(v2 + 160));
    dispatch_release(*(dispatch_object_t *)(v2 + 160));
    *(void *)(v2 + 160) = 0;
    IIOImageAnimator::_releaseFrameImage(v19, **(CGImage ***)(a1 + 136));
    IIOImageAnimator::_releaseFrameImage(v20, *(CGImage **)(*(void *)(a1 + 136) + 8));
    free(*(void **)(a1 + 136));
    CGImageProviderRelease();
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 0x40000000;
    block[2] = ___ZN16IIOImageAnimator5startEv_block_invoke_2;
    block[3] = &__block_descriptor_tmp_48;
    block[4] = v2;
    dispatch_async(MEMORY[0x1E4F14428], block);
    goto LABEL_21;
  }
  long long v25 = 0uLL;
  uint64_t v26 = 0;
  uint64_t v16 = (void (*)(long long *__return_ptr, void *, unsigned char *))gFunc_CMTimeAdd;
  gFunc_CMTimebaseGetTime(v24, *(void *)(a1 + 144));
  gFunc_CMTimeMakeWithSeconds(600);
  v16(&v25, v24, v23);
  long long v17 = *(void *)(a1 + 144);
  vImagePixelCount v18 = *(void *)(v2 + 160);
  uint64_t v21 = v25;
  unint64_t v22 = v26;
  gFunc_CMTimebaseSetTimerDispatchSourceNextFireTime(v17, v18, &v21, 0);
LABEL_21:
  IIODictionary::~IIODictionary((IIODictionary *)v28);
  IIODecodeParameter::~IIODecodeParameter((IIODecodeParameter *)v31);
  IIODictionary::~IIODictionary((IIODictionary *)&v33);
}

void sub_1887CF84C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a26);
  IIODecodeParameter::~IIODecodeParameter((IIODecodeParameter *)&a33);
  IIODictionary::~IIODictionary((IIODictionary *)(v33 - 96));
  _Unwind_Resume(a1);
}

void *_copyImageBlockSetCallback(__IOSurface *a1, uint64_t a2, const __CFDictionary *a3)
{
  uint64_t v22 = 0;
  CGImageProviderGetSize();
  double v6 = v5;
  double v8 = v7;
  long long v21 = xmmword_1ED4F0CE0;
  if (!CGImageProviderGetProperty())
  {
    unint64_t BytesPerRow = IOSurfaceGetBytesPerRow(a1);
    IOSurfaceLock(a1, 1u, 0);
    uint64_t v11 = malloc_type_malloc((unint64_t)(v8 * (double)BytesPerRow), 0x766E6C11uLL);
    if (v11)
    {
      uint64_t v12 = v11;
      BaseAddress = IOSurfaceGetBaseAddress(a1);
      memcpy(v12, BaseAddress, (unint64_t)(v8 * (double)BytesPerRow));
      if (!a3
        || (CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a3, (const void *)*MEMORY[0x1E4F1DD38])) == 0
        || (CFStringRef v15 = Value, v16 = CFGetTypeID(Value), v16 != CFStringGetTypeID())
        || CFStringCompare(v15, (CFStringRef)*MEMORY[0x1E4F1DD30], 0))
      {
        src.data = v12;
        src.vImagePixelCount height = (unint64_t)v8;
        src.vImagePixelCount width = (unint64_t)v6;
        src.rowunint64_t Bytes = BytesPerRow;
        dest.data = v12;
        dest.vImagePixelCount height = (unint64_t)v8;
        dest.vImagePixelCount width = (unint64_t)v6;
        dest.rowunint64_t Bytes = BytesPerRow;
        *(_DWORD *)permuteMap = 50331906;
        vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0x10u);
      }
      uint64_t v17 = CGImageBlockCreate();
      uint64_t v22 = v17;
    }
    else
    {
      uint64_t v17 = 0;
    }
    IOSurfaceUnlock(a1, 1u, 0);
    if (v17) {
      goto LABEL_6;
    }
    return 0;
  }
  if (*MEMORY[0x1E4F1CFC8] == CGImageProviderGetProperty()) {
    _cg_jpeg_mem_term("_copyImageBlockSetCallback", 68, "*** Should not be here\n");
  }
  uint64_t result = malloc_type_calloc((vcvtd_n_u64_f64(v6, 2uLL) + 15) & 0xFFFFFFFFFFFFFFF0, (unint64_t)v8, 0xF15B57AuLL);
  if (result)
  {
    uint64_t v22 = CGImageBlockCreate();
    if (v22)
    {
LABEL_6:
      CGImageProviderGetColorSpace();
      return (void *)CGImageBlockSetCreateWithType();
    }
    return 0;
  }
  return result;
}

CFTypeRef _copyIOSurfaceCallback(const void *a1)
{
  PropertCGFloat y = CGImageProviderGetProperty();
  if (!a1 || Property) {
    return 0;
  }

  return IIOFrameBufferRetain(a1);
}

uint64_t ___ZN16IIOImageAnimator5startEv_block_invoke_2(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t _cg_JP2InitCompressionSettings(uint64_t result, float a2)
{
  *(_WORD *)uint64_t result = a2 < 1.0;
  *(_WORD *)(result + 2) = 0;
  *(_WORD *)(result + 4) = vcvts_n_s32_f32(a2, 0xAuLL);
  *(_WORD *)(result + 6) = 4;
  *(_DWORD *)(result + 8) = 0;
  return result;
}

uint64_t _cg_JP2CompressorSetup(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4, uint64_t *a5, void *a6)
{
  uint64_t v11 = malloc_type_calloc(0x120uLL, 1uLL, 0xFFF05A2DuLL);
  *a6 = v11;
  if (v11)
  {
    uint64_t v12 = v11;
    long long v13 = *a4;
    long long v14 = a4[1];
    long long v15 = a4[3];
    v11[2] = a4[2];
    void v11[3] = v15;
    _OWORD *v11 = v13;
    v11[1] = v14;
    long long v16 = a4[4];
    long long v17 = a4[5];
    long long v18 = a4[7];
    _OWORD v11[6] = a4[6];
    v11[7] = v18;
    UInt8 v11[4] = v16;
    v11[5] = v17;
    long long v19 = a4[8];
    long long v20 = a4[9];
    long long v21 = a4[11];
    v11[10] = a4[10];
    v11[11] = v21;
    v11[8] = v19;
    v11[9] = v20;
    uint64_t v22 = (const void *)*((void *)v11 + 12);
    if (v22) {
      CFRetain(v22);
    }
    *((void *)v12 + 26) = a1;
    *((void *)v12 + 27) = a2;
    uint64_t v23 = *a5;
    *((_DWORD *)v12 + 50) = *((_DWORD *)a5 + 2);
    *((void *)v12 + 24) = v23;
    operator new();
  }
  return 4294967188;
}

void sub_1887CFDE8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B1C405E65678DLL);
  _Unwind_Resume(a1);
}

void kdu_image_in::AllocateSrcLineBuffer(kdu_image_in *this)
{
  if (*((int *)this + 5) > 0) {
    operator new[]();
  }
  kdu_image_in::AllocateSrcLineBuffer();
}

uint64_t kdu_image_in::SetChannelOffsets(uint64_t result, int a2)
{
  *(_OWORD *)(result + 40) = xmmword_1889AD2B0;
  switch(a2)
  {
    case 2:
      goto LABEL_4;
    case 6:
LABEL_5:
      *(void *)(result + 40) = 0x200000001;
      *(_DWORD *)(result + 48) = 3;
      return result;
    case 4:
LABEL_4:
      *(_DWORD *)(result + 52) = 0;
      goto LABEL_5;
  }
  if ((a2 & 0xFFFFFFFD) == 1) {
    *(_DWORD *)(result + 52) = 3;
  }
  return result;
}

uint64_t _cg_JP2CompressorTearDown(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 232);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  unint64_t v3 = *(const void **)(a1 + 96);
  if (v3) {
    CFRelease(v3);
  }
  kdu_image_in::DeallocateSrcLineBuffer(*(kdu_image_in **)(a1 + 248));
  uint64_t v4 = *(void *)(a1 + 248);
  if (v4) {
    MEMORY[0x18C11C0E0](v4, 0x1090C40459A9DE1);
  }
  uint64_t v5 = *(void *)(a1 + 224);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  free((void *)a1);
  return 0;
}

uint64_t kdu_image_in::DeallocateSrcLineBuffer(kdu_image_in *this)
{
  uint64_t v2 = *((void *)this + 4);
  if (!v2) {
    kdu_image_in::DeallocateSrcLineBuffer();
  }
  uint64_t result = MEMORY[0x18C11C0C0](v2, 0x1000C8077774924);
  *((void *)this + 4) = 0;
  return result;
}

uint64_t kdu_image_in::get(uint64_t a1, int a2, uint64_t a3, double a4, float a5)
{
  int v5 = *(_DWORD *)(a1 + 24) / 8;
  int v6 = *(_DWORD *)a3;
  double v7 = (unsigned char *)(*(void *)(a1 + 32) + *(int *)(a1 + 4 * a2 + 40));
  double v8 = *(_WORD **)(a3 + 8);
  if ((*(unsigned char *)(a3 + 6) & 2) != 0 || !v8)
  {
    if (*(unsigned char *)(a3 + 6))
    {
      if (v6 >= 1)
      {
        unsigned int v11 = v6 + 1;
        do
        {
          *v8++ = *v7 - 128;
          v7 += v5;
          --v11;
        }
        while (v11 > 1);
      }
    }
    else if (v6 >= 1)
    {
      unsigned int v10 = v6 + 1;
      do
      {
        *v8++ = 32 * *v7 - 4096;
        v7 += v5;
        --v10;
      }
      while (v10 > 1);
    }
  }
  else if (*(unsigned char *)(a3 + 6))
  {
    if (v6 >= 1)
    {
      unsigned int v12 = v6 + 1;
      do
      {
        *(_DWORD *)double v8 = *v7 - 128;
        v8 += 2;
        v7 += v5;
        --v12;
      }
      while (v12 > 1);
    }
  }
  else if (v6 >= 1)
  {
    unsigned int v9 = v6 + 1;
    do
    {
      LOBYTE(a5) = *v7;
      a5 = (float)((float)LODWORD(a5) * 0.0039062) + -0.5;
      *(float *)double v8 = a5;
      v8 += 2;
      v7 += v5;
      --v9;
    }
    while (v9 > 1);
  }
  return 1;
}

uint64_t _cg_JP2CompressorProcessImage(uint64_t a1)
{
  uint64_t v2 = (int *)*(unsigned int *)(a1 + 64);
  unint64_t v3 = (int *)*(unsigned int *)(a1 + 72);
  uint64_t v4 = *(void *)(a1 + 232);
  if (*(void *)(v4 + 8) || *(void *)(v4 + 16))
  {
    uint64_t v10 = 0;
    memset(v9, 0, sizeof(v9));
    siz_params::siz_params((siz_params *)v9);
    kdu_params::set((kdu_params *)v9, "Scomponents", 0, 0, (int *)*(unsigned int *)(a1 + 120));
    kdu_params::set((kdu_params *)v9, "Sdims", 0, 0, (int *)*(unsigned int *)(a1 + 72));
    kdu_params::set((kdu_params *)v9, "Sdims", 0, 1, (int *)*(unsigned int *)(a1 + 64));
    kdu_params::set((kdu_params *)v9, "Sprecision", 0, 0, (int *)8);
    kdu_params::set((uint64_t)v9, "Ssigned", 0, 0, 0);
    kdu_params::set((kdu_params *)v9, "Stiles", 0, 0, v3);
    kdu_params::set((kdu_params *)v9, "Stiles", 0, 1, v2);
    kdu_params::set((kdu_params *)v9, "Stile_origin", 0, 0, 0);
    kdu_params::set((kdu_params *)v9, "Stile_origin", 0, 1, 0);
    (*(void (**)(_OWORD *, void))(*(void *)&v9[0] + 72))(v9, 0);
    uint64_t v8 = 0;
    uint64_t v8 = jp2_target::access_dimensions(*(jp2_target **)(a1 + 240));
    jp2_target::access_resolution(*(jp2_target **)(a1 + 240));
    jp2_target::access_channels(*(jp2_target **)(a1 + 240));
    uint64_t v7 = 0;
    uint64_t v7 = jp2_target::access_colour(*(jp2_target **)(a1 + 240));
    if (*(void *)(a1 + 120))
    {
      unint64_t v5 = 0;
      do
      {
        kdu_params::set((kdu_params *)v9, "Sdims", v5, 0, (int *)*(unsigned int *)(a1 + 72));
        kdu_params::set((kdu_params *)v9, "Sdims", v5, 1, (int *)*(unsigned int *)(a1 + 64));
        kdu_params::set((kdu_params *)v9, "Sprecision", v5, 0, (int *)8);
        kdu_params::set((uint64_t)v9, "Ssigned", v5++, 0, 0);
      }
      while (*(void *)(a1 + 120) > v5);
    }
    (*(void (**)(_OWORD *, void))(*(void *)&v9[0] + 72))(v9, 0);
    jp2_dimensions::init((jp2_dimensions *)&v8, (siz_params *)v9, 1u);
  }
  return 0xFFFFFFFFLL;
}

void sub_1887D0CDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  kdu_params::~kdu_params((kdu_params *)va);
  _Unwind_Resume(a1);
}

float **_cg_JP2CompressorSetDisplayResolution(uint64_t a1, float a2, float a3)
{
  int v6 = (float *)jp2_target::access_resolution(*(jp2_target **)(a1 + 240));
  jp2_resolution::init((jp2_resolution *)&v6, a2 / a3);
  return jp2_resolution::set_resolution(&v6, a2, 1);
}

void jp2_family_tgt::~jp2_family_tgt(jp2_family_tgt *this)
{
  jp2_family_tgt::~jp2_family_tgt(this);

  JUMPOUT(0x18C11C0E0);
}

{
  *(void *)this = &unk_1ED4E3078;
  jp2_family_tgt::close(this);
}

void MyJP2CompressedTarget::~MyJP2CompressedTarget(MyJP2CompressedTarget *this)
{
  *(void *)this = &unk_1ED4E5410;
}

{
  *(void *)this = &unk_1ED4E5410;
  JUMPOUT(0x18C11C0E0);
}

BOOL MyJP2CompressedTarget::write(MyJP2CompressedTarget *this, const unsigned __int8 *a2, int a3)
{
  uint64_t v5 = (*(uint64_t (**)(void, const unsigned __int8 *, void))(*((void *)this + 1) + 40))(*(void *)(*((void *)this + 1) + 8), a2, a3);
  *((void *)this + 2) += v5;
  return v5 == a3;
}

void IIO_Writer_BMP::~IIO_Writer_BMP(IIO_Writer_BMP *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIO_Writer_BMP::write(IIO_Writer_BMP *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  BMPWritePlugin::BMPWritePlugin((BMPWritePlugin *)v5, a2, a3);
  uint64_t v3 = IIOWritePlugin::writeAll((IIOImageDestination **)v5);
  BMPWritePlugin::~BMPWritePlugin((BMPWritePlugin *)v5);
  return v3;
}

void sub_1887D100C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void IIOImageSource::IIOImageSource(IIOImageSource *a1, const __CFData *a2, int a3)
{
  *(void *)a1 = &unk_1ED4E1420;
  *((void *)a1 + 18) = 0;
  *((void *)a1 + 19) = 0;
  *((void *)a1 + 20) = 0;
  *((void *)a1 + 25) = 0;
  *((void *)a1 + 26) = 0;
  *((void *)a1 + 27) = 0;
  IIOImageSource::setup((uint64_t)a1, a3);
  IIOImageSource::setupWithProxyData(a1, a2, v5);
}

void sub_1887D10B8(_Unwind_Exception *exception_object)
{
  uint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 208) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 152) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

void IIOImageSource::setupWithProxyData(IIOImageSource *this, const __CFData *a2, IIODictionary *a3)
{
}

void sub_1887D1218(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

void IIOImageSource::addImageSourceProxyInfo(IIOImageSource *this, IIODictionary *a2, IIODictionary *a3)
{
  Properties = (IIODictionary *)IIOImageSource::getProperties(this, a3);
  if (Properties)
  {
    uint64_t v5 = Properties;
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(Properties, @"{Groups}");
    if (ObjectForKey) {
      IIODictionary::setObjectForKey(a2, ObjectForKey, @"{Groups}");
    }
    CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(v5, @"ImageCount", @"{FileContents}");
    if (ObjectForKeyGroup)
    {
      IIODictionary::setObjectForKeyGroup(a2, ObjectForKeyGroup, @"ImageCount", @"{FileContents}");
      uint64_t v11 = 0;
      unsigned int v12 = &v11;
      uint64_t v13 = 0x4002000000;
      long long v14 = __Block_byref_object_copy__2;
      long long v15 = __Block_byref_object_dispose__2;
      memset(v16, 0, sizeof(v16));
      IIOArray::IIOArray((IIOArray *)v16);
      IIODictionary::setObjectForKeyGroup(a2, (const void *)v12[6], @"Images", @"{FileContents}");
      CFDictionaryRef v8 = IIODictionary::getObjectForKeyGroup(v5, @"Images", @"{FileContents}");
      memset(v10, 0, sizeof(v10));
      IIOArray::IIOArray((IIOArray *)v10, v8);
      v9[0] = MEMORY[0x1E4F143A8];
      v9[1] = 0x40000000;
      _OWORD v9[2] = ___ZN14IIOImageSource23addImageSourceProxyInfoEP13IIODictionaryS1__block_invoke;
      _OWORD v9[3] = &unk_1E53CCEB8;
      UInt8 v9[4] = &v11;
      IIOArray::enumerate((uint64_t)v10, (uint64_t)v9);
      IIOArray::~IIOArray((IIOArray *)v10);
      _Block_object_dispose(&v11, 8);
      IIOArray::~IIOArray((IIOArray *)v16);
    }
  }
}

void sub_1887D13F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va1, a6);
  va_start(va, a6);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  IIOArray::~IIOArray((IIOArray *)va);
  _Block_object_dispose(va1, 8);
  IIOArray::~IIOArray(v6);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__2(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = &unk_1ED4E5BB8;
  uint64_t v2 = *(void *)(a2 + 48);
  *(unsigned char *)(result + 56) = *(unsigned char *)(a2 + 56);
  *(void *)(result + 48) = v2;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

void ___ZN14IIOImageSource23addImageSourceProxyInfoEP13IIODictionaryS1__block_invoke(uint64_t a1, const __CFDictionary *a2)
{
  memset(v16, 0, sizeof(v16));
  IIODictionary::IIODictionary((IIODictionary *)v16, a2);
  uint64_t v13 = 0;
  long long v14 = 0;
  uint64_t v15 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v13);
  IIOArray::addObject((CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), v14);
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v16, @"AuxiliaryData");
  if (ObjectForKey)
  {
    memset(v12, 0, sizeof(v12));
    IIOArray::IIOArray((IIOArray *)v12, ObjectForKey);
    uint64_t v6 = 0;
    uint64_t v7 = &v6;
    uint64_t v8 = 0x4002000000;
    unsigned int v9 = __Block_byref_object_copy__2;
    uint64_t v10 = __Block_byref_object_dispose__2;
    memset(v11, 0, sizeof(v11));
    IIOArray::IIOArray((IIOArray *)v11);
    IIODictionary::setObjectForKey((IIODictionary *)&v13, (const void *)v7[6], @"AuxiliaryData");
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 0x40000000;
    BOOL v5[2] = ___ZN14IIOImageSource23addImageSourceProxyInfoEP13IIODictionaryS1__block_invoke_2;
    _OWORD v5[3] = &unk_1E53C02B0;
    _OWORD v5[4] = &v6;
    IIOArray::enumerate((uint64_t)v12, (uint64_t)v5);
    _Block_object_dispose(&v6, 8);
    IIOArray::~IIOArray((IIOArray *)v11);
    IIOArray::~IIOArray((IIOArray *)v12);
  }
  CFDictionaryRef v4 = IIODictionary::getObjectForKey((IIODictionary *)v16, @"NamedColorSpace");
  IIODictionary::setObjectForKey((IIODictionary *)&v13, v4, @"NamedColorSpace");
  IIODictionary::~IIODictionary((IIODictionary *)&v13);
  IIODictionary::~IIODictionary((IIODictionary *)v16);
}

void sub_1887D1600(_Unwind_Exception *a1)
{
  IIOArray::~IIOArray((IIOArray *)(v1 - 88));
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 64));
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 40));
  _Unwind_Resume(a1);
}

void ___ZN14IIOImageSource23addImageSourceProxyInfoEP13IIODictionaryS1__block_invoke_2(uint64_t a1, const __CFDictionary *a2)
{
  memset(v7, 0, sizeof(v7));
  IIODictionary::IIODictionary((IIODictionary *)v7, a2);
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v4);
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v7, @"AuxiliaryDataType");
  IIODictionary::setObjectForKey((IIODictionary *)&v4, ObjectForKey, @"AuxiliaryDataType");
  IIOArray::addObject((CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), v5);
  IIODictionary::~IIODictionary((IIODictionary *)&v4);
  IIODictionary::~IIODictionary((IIODictionary *)v7);
}

void sub_1887D16EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void IIOImageSource::addImageSourceAtIndexProxyInfo(IIOImageSource *this, IIODictionary *a2, unsigned int a3, const __CFDictionary **a4)
{
  PropertiesAtIndexInternal = IIOImageSource::getPropertiesAtIndexInternal(this, a3, a4);
  CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(PropertiesAtIndexInternal, @"23", @"{MakerApple}");
  if (ObjectForKeyGroup) {
    IIODictionary::setObjectForKeyGroup(a2, ObjectForKeyGroup, @"23", @"{MakerApple}");
  }
  CFDictionaryRef v7 = IIODictionary::getObjectForKeyGroup(PropertiesAtIndexInternal, @"25", @"{MakerApple}");
  if (v7) {
    IIODictionary::setObjectForKeyGroup(a2, v7, @"25", @"{MakerApple}");
  }
  CFDictionaryRef v8 = IIODictionary::getObjectForKeyGroup(PropertiesAtIndexInternal, @"87", @"{MakerApple}");
  if (v8) {
    IIODictionary::setObjectForKeyGroup(a2, v8, @"87", @"{MakerApple}");
  }
  CFDictionaryRef v9 = IIODictionary::getObjectForKeyGroup(PropertiesAtIndexInternal, @"CameraExtrinsics", @"{HEIF}");
  if (v9) {
    IIODictionary::setObjectForKeyGroup(a2, v9, @"CameraExtrinsics", @"{HEIF}");
  }
  CFDictionaryRef v10 = IIODictionary::getObjectForKeyGroup(PropertiesAtIndexInternal, @"CameraModel", @"{HEIF}");
  if (v10)
  {
    IIODictionary::setObjectForKeyGroup(a2, v10, @"CameraModel", @"{HEIF}");
  }
}

CFDataRef IIOImageSource::createProxyData(IIO_Reader **this, const __CFDictionary **a2)
{
  CFStringRef Type = (const void *)IIOImageSource::getType(this);
  unint64_t v5 = IIOImageSource::updatedCount((IIOImageSource *)this);
  PrimaryImageIndeCGFloat x = IIOImageSource::getPrimaryImageIndex(this);
  uint64_t v24 = 0;
  CFPropertyListRef v25 = 0;
  uint64_t v26 = 0;
  PropertiesAtIndexInternal = IIOImageSource::getPropertiesAtIndexInternal((IIOImageSource *)this, 0, a2);
  IIODictionary::IIODictionary((IIODictionary *)&v24, *((const __CFDictionary **)PropertiesAtIndexInternal + 1), 1);
  memset(v23, 0, sizeof(v23));
  IIODictionary::IIODictionary((IIODictionary *)v23);
  uint64_t v20 = 0;
  long long v21 = 0;
  uint64_t v22 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v20);
  IIONumber::IIONumber((IIONumber *)&v17, 1.0);
  IIODictionary::setObjectForKey((IIODictionary *)&v20, value, @"iio-proxy-version");
  IIONumber::~IIONumber((IIONumber *)&v17);
  IIODictionary::setObjectForKey((IIODictionary *)&v20, Type, @"iio-proxy-isrType");
  IIONumber::IIONumber((IIONumber *)&v17, v5);
  IIODictionary::setObjectForKey((IIODictionary *)&v20, value, @"iio-proxy-count");
  IIONumber::~IIONumber((IIONumber *)&v17);
  IIONumber::IIONumber((IIONumber *)&v17, PrimaryImageIndex);
  IIODictionary::setObjectForKey((IIODictionary *)&v20, value, @"iio-primary_index");
  IIONumber::~IIONumber((IIONumber *)&v17);
  IIODictionary::setObjectForKey((IIODictionary *)&v24, v21, @"{iio-proxy-base}");
  uint64_t v17 = 0;
  long long v18 = 0;
  xpc_object_t value = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v17);
  IIOImageSource::addImageSourceProxyInfo((IIOImageSource *)this, (IIODictionary *)&v17, (IIODictionary *)a2);
  IIODictionary::setObjectForKey((IIODictionary *)&v24, v18, @"{iio-proxy-containerProperties}");
  if (v5 >= 2)
  {
    CFErrorRef error = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    IIOArray::IIOArray((IIOArray *)&error);
    if (v5)
    {
      unsigned int v8 = 0;
      do
      {
        uint64_t v11 = 0;
        unsigned int v12 = 0;
        uint64_t v13 = 0;
        IIODictionary::IIODictionary((IIODictionary *)&v11);
        if (v8) {
          IIOImageSource::addImageSourceAtIndexProxyInfo((IIOImageSource *)this, (IIODictionary *)&v11, v8, a2);
        }
        IIOArray::addObject(&error, v12);
        IIODictionary::~IIODictionary((IIODictionary *)&v11);
        ++v8;
      }
      while (v5 != v8);
    }
    IIODictionary::setObjectForKey((IIODictionary *)&v24, v15, @"{iio-proxy-imageProperties}");
    IIOArray::~IIOArray((IIOArray *)&error);
  }
  CFErrorRef error = 0;
  CFDataRef v9 = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v25, kCFPropertyListBinaryFormat_v1_0, 0, &error);
  IIODictionary::~IIODictionary((IIODictionary *)&v17);
  IIODictionary::~IIODictionary((IIODictionary *)&v20);
  IIODictionary::~IIODictionary((IIODictionary *)v23);
  IIODictionary::~IIODictionary((IIODictionary *)&v24);
  return v9;
}

void sub_1887D1ABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va3, a4);
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v14 = va_arg(va3, void);
  uint64_t v16 = va_arg(va3, void);
  uint64_t v17 = va_arg(va3, void);
  IIOArray::~IIOArray((IIOArray *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)va2);
  IIODictionary::~IIODictionary((IIODictionary *)va3);
  IIODictionary::~IIODictionary((IIODictionary *)(v4 - 72));
  _Unwind_Resume(a1);
}

const __CFDictionary *IIOImageSource::proxyGetType(IIODictionary **this)
{
  return IIODictionary::getObjectForKeyGroup(this[16], @"iio-proxy-isrType", @"{iio-proxy-base}");
}

uint64_t IIOImageSource::proxyGetCount(IIODictionary **this)
{
  return IIODictionary::getUint32ForKeyGroup(this[16], @"iio-proxy-count", @"{iio-proxy-base}");
}

CFTypeRef IIOImageSource::proxyCopyProperties(IIODictionary **this, IIODictionary *a2)
{
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(this[16], @"{iio-proxy-containerProperties}");

  return CFRetain(ObjectForKey);
}

CFTypeRef IIOImageSource::proxyCopyPropertiesAtIndex(IIOImageSource *this, unint64_t a2, IIODictionary *a3)
{
  if (!a2)
  {
    CFTypeRef cf = 0;
    uint64_t v10 = 0;
    uint64_t v8 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v8, *(const __CFDictionary **)(*((void *)this + 16) + 8), 0);
    IIODictionary::removeObjectForKey((IIODictionary *)&v8, @"{iio-proxy-base}");
    IIODictionary::removeObjectForKey((IIODictionary *)&v8, @"{iio-proxy-containerProperties}");
    IIODictionary::removeObjectForKey((IIODictionary *)&v8, @"{iio-proxy-imageProperties}");
    CFTypeRef v7 = CFRetain(cf);
    IIODictionary::~IIODictionary((IIODictionary *)&v8);
    return v7;
  }
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(*((IIODictionary **)this + 16), @"{iio-proxy-imageProperties}");
  if (CFArrayGetCount(ObjectForKey) <= a2) {
    return 0;
  }
  ValueAtIndeCGFloat x = CFArrayGetValueAtIndex(ObjectForKey, a2);

  return CFRetain(ValueAtIndex);
}

void sub_1887D1CB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIOImageSource::proxyGetPrimaryImageIndex(IIODictionary **this)
{
  return IIODictionary::getUint32ForKeyGroup(this[16], @"iio-primary_index", @"{iio-proxy-base}");
}

CFDataRef CGImageSourceCreateProxyData(uint64_t a1, const __CFDictionary *a2)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceCreateProxyData", 0, 0, -1, 0);
  }
  if (!a1)
  {
    LogError("CGImageSourceCreateProxyData", 291, "*** ERROR: CGImageSourceCopyProxyPropertyList: source is NULL\n");
    return 0;
  }
  uint64_t Source = CGImageSourceGetSource(a1);
  if (!Source) {
    return 0;
  }
  unint64_t v5 = (IIOImageSource *)Source;
  memset(v8, 0, sizeof(v8));
  IIODictionary::IIODictionary((IIODictionary *)v8, a2);
  IIOImageSource::lock(v5);
  Proxyunint64_t Data = IIOImageSource::createProxyData((IIO_Reader **)v5, v8);
  IIOImageSource::unlock(v5);
  IIODictionary::~IIODictionary((IIODictionary *)v8);
  return ProxyData;
}

void sub_1887D1DBC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageSourceCreateWithProxyData(const void *a1, const __CFDictionary *a2)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceCreateWithProxyData", 0, 0, -1, 0);
  }
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFDataGetTypeID())
    {
      memset(v6, 0, sizeof(v6));
      IIODictionary::IIODictionary((IIODictionary *)v6, a2);
      operator new();
    }
    LogError("CGImageSourceCreateWithProxyData", 319, "*** ERROR: CGImageSourceCreateWithProxyData: data is not a CFDataRef\n");
  }
  else
  {
    LogError("CGImageSourceCreateWithProxyData", 318, "*** ERROR: CGImageSourceCreateWithProxyData: proxyData is NULL\n");
  }
  kdebug_trace();
  kdebug_trace();
  return 0;
}

void sub_1887D1FC0(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MEMORY[0x18C11C0E0](v2, 0x10E1C40A1B1CD90);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1887D1EF4);
}

BOOL CGImageSourceIsProxy(uint64_t a1)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceIsProxy", 0, 0, -1, 0);
  }
  if (!a1)
  {
    LogError("CGImageSourceIsProxy", 361, "*** ERROR: CGImageSourceIsProxy: source is NULL\n");
    return 0;
  }
  uint64_t Source = (IIOImageSource *)CGImageSourceGetSource(a1);
  if (!Source) {
    return 0;
  }
  uint64_t v3 = (unsigned __int8 *)Source;
  if (IIOImageSource::imageDataDidNotMatchRequestedHint(Source))
  {
    LogError("CGImageSourceIsProxy", 366, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    return 0;
  }
  IIOImageSource::lock((IIOImageSource *)v3);
  BOOL v4 = v3[54] == 7;
  IIOImageSource::unlock((IIOImageSource *)v3);
  return v4;
}

uint64_t _ImageGetNonAlphaInfo(CGImage *a1)
{
  return CGImageGetBitmapInfo(a1) & 0xFFFFFFE0;
}

uint64_t _ImageHasRealAlphaChannel(CGImage *a1)
{
  CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(a1);
  return (AlphaInfo > kCGImageAlphaNoneSkipFirst) | (0x1Eu >> AlphaInfo) & 1;
}

uint64_t _AlphaPosition(int a1)
{
  if ((a1 - 1) > 5) {
    return 0;
  }
  else {
    return dword_1889AD360[a1 - 1];
  }
}

uint64_t _ImageAlphaPosition(CGImage *a1)
{
  unsigned __int32 v1 = CGImageGetAlphaInfo(a1) - 1;
  if (v1 > 5) {
    return 0;
  }
  else {
    return dword_1889AD360[v1];
  }
}

uint64_t _AlphaTogglePosition(uint64_t result)
{
  if ((result - 1) <= 5) {
    return dword_1889AD378[(int)result - 1];
  }
  return result;
}

BOOL IIOChromaticitiesMatchLinearSRGB(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9)
{
  return fabs(a1 + -0.3127) < 0.0005
      && fabs(a2 + -0.329) < 0.0005
      && fabs(a3 + -0.64) < 0.0005
      && fabs(a4 + -0.33) < 0.0005
      && fabs(a5 + -0.3) < 0.0005
      && fabs(a6 + -0.6) < 0.0005
      && fabs(a7 + -0.15) < 0.0005
      && fabs(a8 + -0.06) < 0.0005
      && fabs(a9 + -1.0) < 0.0005;
}

void IIOAddDateComponents(CFMutableArrayRef *a1)
{
  time_t v11 = time(0);
  uint64_t v2 = localtime(&v11);
  tm_mdaCGFloat y = v2->tm_mday;
  int tm_mon = v2->tm_mon;
  IIONumber::IIONumber((IIONumber *)v10, v2->tm_year + 1900);
  IIOArray::addObject(a1, (uint64_t)v10);
  IIONumber::~IIONumber((IIONumber *)v10);
  IIONumber::IIONumber((IIONumber *)v9, tm_mon + 1);
  IIOArray::addObject(a1, (uint64_t)v9);
  IIONumber::~IIONumber((IIONumber *)v9);
  IIONumber::IIONumber((IIONumber *)v8, tm_mday);
  IIOArray::addObject(a1, (uint64_t)v8);
  IIONumber::~IIONumber((IIONumber *)v8);
  IIONumber::IIONumber((IIONumber *)v7, 0);
  IIOArray::addObject(a1, (uint64_t)v7);
  IIONumber::~IIONumber((IIONumber *)v7);
  IIONumber::IIONumber((IIONumber *)v6, 0);
  IIOArray::addObject(a1, (uint64_t)v6);
  IIONumber::~IIONumber((IIONumber *)v6);
  IIONumber::IIONumber((IIONumber *)v5, 0);
  IIOArray::addObject(a1, (uint64_t)v5);
  IIONumber::~IIONumber((IIONumber *)v5);
}

void sub_1887D23C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void IIOAddXYZfrom_xy(CFMutableArrayRef *a1, float a2, float a3, float a4)
{
  if (a3 == 0.0)
  {
    float v7 = 0.0;
    a4 = 0.0;
    float v8 = 0.0;
  }
  else
  {
    float v7 = (float)(a2 * a4) / a3;
    float v8 = (float)((float)((float)(1.0 - a2) - a3) * a4) / a3;
  }
  IIONumber::IIONumber((IIONumber *)v11, v7);
  IIOArray::addObject(a1, (uint64_t)v11);
  IIONumber::~IIONumber((IIONumber *)v11);
  IIONumber::IIONumber((IIONumber *)v10, a4);
  IIOArray::addObject(a1, (uint64_t)v10);
  IIONumber::~IIONumber((IIONumber *)v10);
  IIONumber::IIONumber((IIONumber *)v9, v8);
  IIOArray::addObject(a1, (uint64_t)v9);
  IIONumber::~IIONumber((IIONumber *)v9);
}

void sub_1887D24DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_ConvertCGColorToColorComponents(CGColor *a1, uint64_t a2)
{
  uint64_t v3 = MEMORY[0x18C11ADC0](a2, 0);
  if (!v3) {
    return 0;
  }
  BOOL v4 = (const void *)v3;
  if (a1)
  {
    CGColorGetColorSpace(a1);
    CGColorGetComponents(a1);
    uint64_t v5 = CGColorTransformConvertColorComponents();
  }
  else
  {
    CGColorSpaceRef v6 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
    if (v6)
    {
      CGColorSpaceRef v7 = v6;
      uint64_t v5 = CGColorTransformConvertColorComponents();
      CFRelease(v7);
    }
    else
    {
      uint64_t v5 = 0;
    }
  }
  CFRelease(v4);
  return v5;
}

void sub_1887D2650(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4070B3CFD8);
  _Unwind_Resume(a1);
}

IIOImageRead *IIO_Reader_PNG::createGlobalInfoData(IIO_Reader_PNG *this, IIOImageReadSession *a2)
{
  uint64_t result = IIOImageReadSession::globalInfoForType(a2, 1095781959);
  if (result)
  {
    CFIndex v3 = 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*((void *)result + 2) - *((void *)result + 1)) >> 1);
    v4.location = 0;
    v4.size_t length = v3;
    return (IIOImageRead *)GlobalPNGInfo::createDataRepresentation(result, &v4);
  }
  return result;
}

void IIO_Reader_PNG::updateGlobalInfo(IIO_Reader_PNG *this, IIOImageReadSession *a2, unsigned __int8 *a3)
{
}

void sub_1887D2748(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B1C402BA5416ELL);
  _Unwind_Resume(a1);
}

uint64_t globalPNGInfoReleaseProc(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void IIO_Reader_PNG::deserializeGlobalInfo(IIO_Reader_PNG *this, unsigned __int8 *a2)
{
}

void sub_1887D27F0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B1C402BA5416ELL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PNG::updateSourceProperties(IIO_Reader_PNG *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  v56[1] = *MEMORY[0x1E4F143B8];
  if (a4) {
    BOOL BoolForKey = IIODictionary::getBoolForKey(a4, @"kCGImageSourcePropertiesIncludeColorInfo");
  }
  else {
    BOOL BoolForKey = 0;
  }
  v56[0] = 0;
  if (IIOImageReadSession::getBytesAtOffset(a2, v56, 8uLL, 8uLL) != 8)
  {
    uint64_t v27 = 0;
    char v8 = -1;
    goto LABEL_21;
  }
  uint64_t v27 = 0;
  char v8 = -1;
  unint64_t v9 = 8;
  while (1)
  {
    unsigned int v10 = v56[0];
    if (HIDWORD(v56[0]) != 1380206665 || !BoolForKey) {
      break;
    }
    LOWORD(Size) = 0;
    if (IIOImageReadSession::getBytesAtOffset(a2, &Size, v9 + 16, 2uLL) != 2) {
      goto LABEL_21;
    }
    switch(BYTE1(Size))
    {
      case 0:
      case 4:
        uint64_t v27 = @"Gray";
        break;
      case 2:
      case 3:
      case 6:
        uint64_t v27 = @"RGB";
        break;
      default:
        break;
    }
    char v8 = (BYTE1(Size) & 0xFD) == 4;
LABEL_18:
    v9 += bswap32(v10) + 12;
    if (IIOImageReadSession::getBytesAtOffset(a2, v56, v9, 8uLL) != 8) {
      goto LABEL_21;
    }
  }
  unsigned int v12 = bswap32(HIDWORD(v56[0]));
  if (v12 == 1229209940) {
    goto LABEL_21;
  }
  if (v12 != 1633899596) {
    goto LABEL_18;
  }
  if (IIOImageReadSession::getBytesAtOffset(a2, v56, v9 + 8, 8uLL) == 8)
  {
    IIONumber::IIONumber((IIONumber *)&Size, bswap32(HIDWORD(v56[0])));
    IIODictionary::setObjectForKeyGroup(a3, v35[1], @"LoopCount", @"{PNG}");
    IIONumber::~IIONumber((IIONumber *)&Size);
  }
LABEL_21:
  uint64_t v13 = IIOImageReadSession::globalInfoForType(a2, 1095781959);
  if (v13
    || (LODWORD(Size) = 0,
        LODWORD(v29[0]) = 0,
        (*(void (**)(IIO_Reader_PNG *, IIOImageReadSession *, IIODictionary *, CFMutableArrayRef *, void **))(*(void *)this + 32))(this, a2, a4, &Size, v29), (uint64_t v13 = IIOImageReadSession::globalInfoForType(a2, 1095781959)) != 0))
  {
    IIONumber::IIONumber((IIONumber *)v55, *((_DWORD *)v13 + 8));
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v55, @"CanvasPixelWidth", @"{PNG}");
    IIONumber::~IIONumber((IIONumber *)v55);
    IIONumber::IIONumber((IIONumber *)v54, *((_DWORD *)v13 + 9));
    IIODictionary::setObjectForKeyGroup(a3, (uint64_t)v54, @"CanvasPixelHeight", @"{PNG}");
    IIONumber::~IIONumber((IIONumber *)v54);
    CFMutableArrayRef Size = 0;
    v35[0] = 0;
    v35[1] = 0;
    IIOArray::IIOArray((IIOArray *)&Size);
    uint64_t v14 = *((void *)v13 + 1);
    for (uint64_t i = *((void *)v13 + 2); v14 != i; v14 += 34)
    {
      unsigned int v16 = *(unsigned __int16 *)(v14 + 20);
      unsigned int v17 = *(unsigned __int16 *)(v14 + 22);
      v29[0] = 0;
      v29[1] = 0;
      *(void *)&long long v30 = 0;
      IIODictionary::IIODictionary((IIODictionary *)v29);
      float v18 = (float)v16 / (float)v17;
      if (v18 < 0.05) {
        float v18 = 0.05;
      }
      IIONumber::IIONumber((IIONumber *)v53, v18);
      IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v53, @"DelayTime");
      IIONumber::~IIONumber((IIONumber *)v53);
      IIOArray::addObject(&Size, v29[1]);
      IIODictionary::~IIODictionary((IIODictionary *)v29);
    }
    IIODictionary::setObjectForKeyGroup(a3, v35[0], @"FrameInfo", @"{PNG}");
    IIOArray::~IIOArray((IIOArray *)&Size);
    char v19 = 1;
    if (BoolForKey)
    {
LABEL_28:
      uint64_t v20 = (const void **)MEMORY[0x1E4F1CFD0];
      if (v8 != -1)
      {
        long long v21 = (const void **)MEMORY[0x1E4F1CFC8];
        if (v8) {
          long long v21 = (const void **)MEMORY[0x1E4F1CFD0];
        }
        IIODictionary::setObjectForKeyGroup(a3, *v21, @"kCGImageSourcePropertyHasAlpha", @"{PNG}");
      }
      if (v27) {
        IIODictionary::setObjectForKeyGroup(a3, v27, @"kCGImageSourcePropertyColorModel", @"{PNG}");
      }
      memset(v52, 0, sizeof(v52));
      IIODictionary::IIODictionary((IIODictionary *)v52);
      memset(v51, 0, sizeof(v51));
      IIODictionary::IIODictionary((IIODictionary *)v51);
      int v50 = 0;
      long long v49 = 0u;
      long long v48 = 0u;
      long long v47 = 0u;
      long long v46 = 0u;
      long long v45 = 0u;
      long long v44 = 0u;
      long long v43 = 0u;
      long long v42 = 0u;
      long long v41 = 0u;
      long long v40 = 0u;
      long long v39 = 0u;
      long long v38 = 0u;
      long long v37 = 0u;
      *(_OWORD *)long long v35 = 0u;
      long long v36 = 0u;
      IIODictionary::setObjectForKey((IIODictionary *)v52, *v20, @"kCGImageSourceSkipMetadata");
      CFMutableArrayRef Mutable = CGImageMetadataCreateMutable();
      long long v32 = 0u;
      long long v33 = 0u;
      long long v30 = 0u;
      long long v31 = 0u;
      *(_OWORD *)uint64_t v29 = 0u;
      BYTE14(v30) = v19;
      CFMutableArrayRef Size = IIOImageReadSession::getSize(a2);
      BYTE5(v44) = IIOImageReadSession::isFinal(a2);
      IIOImageReadSession::rewind((uint64_t)a2);
      PNGReadPlugin::InitializePluginData(a2, (IIODictionary *)v52, (IIODictionary *)v51, Mutable, &v50, (uint64_t)&Size, (uint64_t)v29, 0);
      if (v50)
      {
        CFDataRef v23 = CGColorSpaceCopyICCData(v50);
        if (v23)
        {
          IIODictionary::setObjectForKeyGroup(a3, v23, @"kCGImageSourceColorSpace", @"{PNG}");
          CFRelease(v23);
        }
        CFRelease(v50);
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
      IIODictionary::~IIODictionary((IIODictionary *)v51);
      IIODictionary::~IIODictionary((IIODictionary *)v52);
    }
  }
  else
  {
    char v19 = 0;
    if (BoolForKey) {
      goto LABEL_28;
    }
  }
  return 0;
}

void sub_1887D2DAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PNG::hasCustomSourcePropertiesProc(IIO_Reader_PNG *this)
{
  return 1;
}

uint64_t globalGIFInfoReleaseProc(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

unint64_t gifRead(uint64_t a1, unsigned char *a2, int a3)
{
  return IIOImageReadSession::getBytes(*(IIOImageReadSession **)(a1 + 88), a2, a3);
}

void *GIFReadPlugin::GIFReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result = (void *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *uint64_t result = &unk_1ED4DFA68;
  *(void *)((char *)result + 436) = 0;
  return result;
}

void GIFReadPlugin::GIFReadPlugin(uint64_t a1, uint64_t a2)
{
}

void GIFReadPlugin::~GIFReadPlugin(GIFReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t GIFReadPlugin::loadDataFromXPCObject(GIFReadPlugin *this, void *a2)
{
  uint64_t DataFromXPCObject = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!DataFromXPCObject)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_gif", &length);
    if (length == 8) {
      *(void *)((char *)this + 436) = *data;
    }
  }
  return DataFromXPCObject;
}

uint64_t GIFReadPlugin::saveDataToXPCObject(GIFReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_gif", (char *)this + 436, 8uLL);
  }
  return v4;
}

uint64_t GIFReadPlugin::initialize(GIFReadPlugin *this, IIODictionary *a2)
{
  v58[0] = 0;
  CFIndex v3 = (IIODictionary *)*((void *)this + 6);
  uint64_t v4 = (IIODictionary *)*((void *)this + 7);
  *((unsigned char *)this + 441) = IIODictionary::getBoolForKey(v3, @"IIO_SKIP_GIF_COMPOSING");
  IIOSkipMetadata(v3);
  IIOSkipXMP_and_IPTC(v3);
  uint64_t v5 = *((void *)this + 3);
  if (!v5) {
    goto LABEL_33;
  }
  uint64_t v6 = _cg_DGifOpen(v5, (int (*)(uint64_t, _DWORD *, uint64_t))gifRead, v58);
  if (!v6) {
    goto LABEL_33;
  }
  CGColorSpaceRef v7 = (__int16 *)v6;
  char v8 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1195984416);
  if (!v8)
  {
    _cg_jpeg_mem_term("initialize", 319, "globalGifInfo is NULL\n");
LABEL_32:
    _cg_DGifCloseFile((uint64_t)v7, 0);
LABEL_33:
    uint64_t Extension = 4294967246;
LABEL_34:
    kdebug_trace();
    return Extension;
  }
  unint64_t v9 = v8;
  unsigned int v10 = *((_DWORD *)this + 52);
  if (v10 >= GlobalGIFInfo::frameCount(v8))
  {
    GlobalGIFInfo::frameCount(v9);
    _cg_jpeg_mem_term("initialize", 320, "_rpd._index<count (%d<%d)\n");
    goto LABEL_32;
  }
  if (GlobalGIFInfo::frameCount(v9) >= 6) {
    *((unsigned char *)this + 442) = 1;
  }
  *((_DWORD *)this + 60) = 2097160;
  *((_DWORD *)this + 81) = 1380401696;
  *((unsigned char *)this + 344) = 0;
  *((unsigned char *)this + 346) = 0;
  *((_DWORD *)this + 57) = *v7;
  *((_DWORD *)this + 58) = v7[1];
  unsigned int v11 = GlobalGIFInfo::frameCount(v9);
  if (v11 >= 2)
  {
    unsigned int v16 = *((_DWORD *)this + 57);
    unsigned int v17 = *((_DWORD *)this + 58);
  }
  else
  {
    GlobalGIFInfo::getFrameInfoAtIndex(v9, 0, (uint64_t)&v48);
    int v12 = v49;
    int v13 = v50;
    unsigned int v14 = v51;
    unsigned int v15 = v52;
    unsigned int v16 = *((_DWORD *)this + 57);
    if (!v16 && !*((_DWORD *)this + 58) && !v50 && !v49)
    {
      *((_DWORD *)this + 57) = v51;
      *((_DWORD *)this + 58) = v15;
      unsigned int v16 = v14;
    }
    if (!v13 && !v12 && v16 > v14 && *((_DWORD *)this + 58) > v15
      || v16 > 0x800
      || (unsigned int v17 = *((_DWORD *)this + 58), v17 >= 0x801))
    {
      *((_DWORD *)this + 57) = v14;
      *((_DWORD *)this + 58) = v15;
      unsigned int v16 = v14;
      unsigned int v17 = v15;
    }
  }
  if (4 * v11 * v17 * v16 >= 0x1E8481) {
    *((unsigned char *)this + 343) = 0;
  }
  float v18 = (_DWORD *)*((void *)v9 + 22);
  if (v18) {
    char v19 = *v18 == 2;
  }
  else {
    char v19 = 0;
  }
  if (v7[1] * (uint64_t)*v7 > (unint64_t)((1100
                                                * (void)IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3))) << v19))
  {
    if (*((unsigned char *)this + 341)) {
      LogError("initialize", 397, "malformed GIF file (%d x %d) - [canvasSize: %ld  fileSize: %ld   ratio: %d]  \n");
    }
    goto LABEL_32;
  }
  char v20 = v19;
  GlobalGIFInfo::getFrameInfoAtIndex(v9, *((unsigned int *)this + 52), (uint64_t)&v48);
  uint64_t v21 = v51;
  unint64_t v22 = v52;
  if (v52 * (unint64_t)v51 > (1100 * (unint64_t)v56) << v20)
  {
    if (*((unsigned char *)this + 341)) {
      LogError("initialize", 411, "malformed GIF frame#%ld (%d x %d) - [canvasSize: %ld  frameDataSize: %ld   adjustment: %d]\n", *((unsigned int *)this + 52));
    }
    goto LABEL_32;
  }
  unsigned int v25 = v54;
  int v26 = v55;
  char v27 = v57;
  if (*((unsigned char *)this + 441))
  {
    unsigned int v40 = v54;
    int v28 = v50;
    int v41 = v53;
    IIONumber::IIONumber((IIONumber *)v47, v49);
    IIODictionary::setObjectForKeyGroup(v4, (uint64_t)v47, @"xOffset", @"{GIF}");
    IIONumber::~IIONumber((IIONumber *)v47);
    IIONumber::IIONumber((IIONumber *)v46, v28);
    IIODictionary::setObjectForKeyGroup(v4, (uint64_t)v46, @"yOffset", @"{GIF}");
    IIONumber::~IIONumber((IIONumber *)v46);
    IIONumber::IIONumber((IIONumber *)v45, v21);
    IIODictionary::setObjectForKeyGroup(v4, (uint64_t)v45, @"width", @"{GIF}");
    IIONumber::~IIONumber((IIONumber *)v45);
    IIONumber::IIONumber((IIONumber *)v44, v22);
    IIODictionary::setObjectForKeyGroup(v4, (uint64_t)v44, @"height", @"{GIF}");
    IIONumber::~IIONumber((IIONumber *)v44);
    IIONumber::IIONumber((IIONumber *)v43, v41);
    IIODictionary::setObjectForKeyGroup(v4, (uint64_t)v43, @"disposeOp", @"{GIF}");
    IIONumber::~IIONumber((IIONumber *)v43);
    unsigned int v25 = v40;
  }
  *((_DWORD *)this + 59) = (4 * *((_DWORD *)this + 57) + 15) & 0xFFFFFFF0;
  if ((v27 & 2) != 0) {
    char v29 = 3;
  }
  else {
    char v29 = 5;
  }
  *((unsigned char *)this + 246) = v29;
  if (v11 != 1 || (v27 & 2) != 0 || v22 >= v7[1])
  {
    unsigned int v30 = v25;
    *((_WORD *)this + 122) = 4;
    if (*((_DWORD *)this + 52) && (v27 & 2) == 0)
    {
      GlobalGIFInfo::getFrameInfoAtIndex(v9, 0, (uint64_t)&v48);
      if ((v57 & 2) != 0)
      {
        char v29 = 3;
        *((unsigned char *)this + 246) = 3;
      }
      else
      {
        char v29 = *((unsigned char *)this + 246) & 0x1F;
      }
    }
  }
  else
  {
    unsigned int v30 = v25;
    char v29 = 3;
    *((unsigned char *)this + 246) = 3;
    *((_WORD *)this + 122) = 4;
  }
  *((unsigned char *)this + 247) = 0;
  char v31 = *((unsigned char *)this + 248);
  BOOL v32 = *((unsigned char *)this + 249) != 0;
  *((unsigned char *)this + 278) = v29;
  *((unsigned char *)this + 279) = 0;
  *((unsigned char *)this + 280) = v31 & 0xF;
  *((unsigned char *)this + 281) = v32;
  *((unsigned char *)this + 350) = 1;
  if (IIOImageDestination::resizeImageMaxPixelSize(v9))
  {
    long long v48 = 0;
    int v42 = 0;
    long long v33 = (IIOImageReadSession *)*((void *)this + 3);
    unint64_t v34 = IIOImageDestination::resizeImageMaxPixelSize(v9);
    IIOImageReadSession::seek(v33, v34, 0);
    uint64_t Extension = _cg_DGifGetExtension((uint64_t)v7, &v42, (uint64_t)&v48);
    if (!Extension)
    {
      _cg_jpeg_mem_term("initialize", 459, "    GIF-ERROR: DGifGetExtension (%d)\n", 0);
      long long v35 = 0;
      goto LABEL_67;
    }
    long long v35 = (UInt8 *)malloc_type_malloc(0, 0xC6FBEE0AuLL);
    if (!v35) {
      goto LABEL_67;
    }
    int v36 = 0;
    while (v48)
    {
      if (v35)
      {
        long long v37 = (UInt8 *)reallocf(v35, *v48 + (uint64_t)v36);
        long long v35 = v37;
        if (!v37)
        {
          _cg_jpeg_mem_term("initialize", 470, "    GIF-ERROR: realloc(%d) failed\n");
          goto LABEL_67;
        }
        long long v38 = v48;
        memcpy(&v37[v36], v48 + 1, *v48);
        v36 += *v38;
      }
      uint64_t Extension = _cg_DGifGetExtensionNext((uint64_t)v7, (uint64_t)&v48);
      if (!Extension)
      {
        _cg_jpeg_mem_term("initialize", 476, "    GIF-ERROR: DGifGetExtensionNext (%d)\n");
        goto LABEL_67;
      }
    }
    uint64_t v39 = CGColorSpaceCreateWithCopyOfData(v35 + 11, v36 - 11);
    if (v39) {
      goto LABEL_64;
    }
  }
  else
  {
    long long v35 = 0;
  }
  uint64_t v39 = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
LABEL_64:
  *((void *)this + 20) = v39;
  *((void *)this + 45) = 1;
  *((_DWORD *)this + 109) = v26;
  if ((v27 & 8) != 0) {
    IIO_addDelayTimeToDictionary(v30, v4, @"{GIF}");
  }
  uint64_t Extension = 0;
  *((_WORD *)this + 188) = 1;
LABEL_67:
  if (v35) {
    free(v35);
  }
  _cg_DGifCloseFile((uint64_t)v7, 0);
  if (Extension) {
    goto LABEL_34;
  }
  return Extension;
}

void sub_1887D36CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t GIFReadPlugin::cacheImmediately(uint64_t this, const __CFDictionary *a2, CGImage *a3)
{
  *(unsigned char *)(this + 343) = 0;
  return this;
}

uint64_t GIFReadPlugin::decodeIndexedColorFrame(uint64_t a1, IIOScanner *a2, GlobalGIFInfo *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  memset(__c, 0, sizeof(__c));
  *(void *)CFNumberRef v73 = 0;
  *(void *)(a6 + 80) = 0;
  uint64_t v72 = _cg_DGifOpen((uint64_t)a2, (int (*)(uint64_t, _DWORD *, uint64_t))gifReadWithScanner, (int *)&__c[1]);
  if (v72)
  {
    GlobalGIFInfo::getFrameInfoAtIndex(a3, *(void *)a6, (uint64_t)v75);
    unint64_t v9 = *(void *)v75;
    unsigned int v10 = v76;
    uint64_t v67 = v77;
    size_t count = v78;
    unsigned int v62 = v79;
    char v11 = v82;
    if ((v82 & 2) != 0)
    {
      __c[0] = v80;
    }
    else if (!v81)
    {
      int v12 = (unsigned int *)*((void *)a3 + 22);
      if (v12)
      {
        bzero(v75, 0x400uLL);
        IIOColorMap::copyToRGBX(v12, v75, 0x400uLL, 0);
        if (**((_DWORD **)a3 + 22) > 0x100u) {
          goto LABEL_98;
        }
        if (!IIOColorMap::indexForColor((IIOColorMap *)0xFFFFFFFFLL, v75, (const unsigned int *)(unsigned __int16)**((_DWORD **)a3 + 22), __c, v13))__c[0] = 0; {
      }
        }
    }
    IIOScanner::seek(a2, v9, 0);
    if (_cg_DGifGetImageDesc(v72))
    {
      GlobalGIFInfo::getSize((uint64_t)a3, &v73[1], v73);
      LODWORD(v15) = v73[1];
      v84.size.CGFloat width = (double)v15;
      LODWORD(v15) = v73[0];
      v84.size.CGFloat height = (double)v15;
      double v16 = (double)v10;
      double v17 = (double)v67;
      v99.size.CGFloat width = (double)count;
      v84.origin.double x = 0.0;
      v84.origin.CGFloat y = 0.0;
      v99.origin.double x = (double)v10;
      v99.origin.CGFloat y = (double)v67;
      v99.size.CGFloat height = (double)v62;
      CGRect v85 = CGRectIntersection(v84, v99);
      double x = v85.origin.x;
      CGFloat y = v85.origin.y;
      CGFloat width = v85.size.width;
      CGFloat height = v85.size.height;
      if (CGRectIsEmpty(v85))
      {
        if (!*(void *)a6) {
          bzero(*(void **)(a6 + 40), *(void *)(a6 + 56));
        }
        unint64_t v14 = 0;
        goto LABEL_91;
      }
      v86.origin.double x = x;
      v86.origin.CGFloat y = y;
      v86.size.CGFloat width = width;
      v86.size.CGFloat height = height;
      double v65 = CGRectGetWidth(v86);
      v87.origin.double x = (double)v10;
      v87.origin.CGFloat y = (double)v67;
      v87.size.CGFloat width = (double)count;
      v87.size.CGFloat height = (double)v62;
      double v64 = CGRectGetWidth(v87);
      v88.origin.double x = (double)v10;
      v88.origin.CGFloat y = (double)v67;
      v88.size.CGFloat width = (double)count;
      v88.size.CGFloat height = (double)v62;
      double MinY = CGRectGetMinY(v88);
      v89.origin.double x = x;
      v89.origin.CGFloat y = y;
      v89.size.CGFloat width = width;
      v89.size.CGFloat height = height;
      double v66 = CGRectGetMinY(v89);
      v90.origin.double x = x;
      v90.origin.CGFloat y = y;
      v90.size.CGFloat width = width;
      v90.size.CGFloat height = height;
      double v22 = CGRectGetWidth(v90);
      v91.origin.double x = x;
      v91.origin.CGFloat y = y;
      v91.size.CGFloat width = width;
      v91.size.CGFloat height = height;
      size_t v23 = v22;
      int64_t v24 = CGRectGetHeight(v91);
      if (*(void *)(a6 + 56) >= (uint64_t)(v24 * v23))
      {
        if (v65 >= v64 && MinY >= v66)
        {
          unint64_t v25 = 0;
          int v26 = 0;
          goto LABEL_23;
        }
        int v26 = (char *)malloc_type_calloc(count, 1uLL, 0x7EED3C60uLL);
        if (v26)
        {
          if (x <= v16) {
            unint64_t v25 = 0;
          }
          else {
            unint64_t v25 = (unint64_t)(x - v16);
          }
LABEL_23:
          CFNumberRef v70 = v26;
          if ((v11 & 4) != 0)
          {
            unint64_t v38 = 0;
            unint64_t v39 = 0;
            __vImage_Buffer src = &v26[v25];
            uint64_t v40 = -1;
            while (2)
            {
              for (uint64_t i = gInterlacedOffset[v39]; i < v24; i += gInterlacedJumps[v39])
              {
                v96.origin.double x = v16;
                v96.origin.CGFloat y = (double)v67;
                v96.size.CGFloat width = (double)count;
                v96.size.CGFloat height = (double)v62;
                double v42 = CGRectGetMinY(v96);
                v97.origin.double x = x;
                v97.origin.CGFloat y = y;
                v97.size.CGFloat width = width;
                v97.size.CGFloat height = height;
                long long v43 = (char *)(*(void *)(a6 + 40) + i * v23);
                double v44 = (double)(v42 + (double)i);
                if (CGRectGetMinY(v97) > v44
                  || (v98.origin.double x = x,
                      v98.origin.CGFloat y = y,
                      v98.size.CGFloat width = width,
                      v98.size.CGFloat height = height,
                      CGRectGetMaxY(v98) <= v44))
                {
                  char v45 = 1;
                  long long v46 = v70;
                }
                else
                {
                  char v45 = 0;
                  if (v65 >= v64) {
                    long long v46 = v43;
                  }
                  else {
                    long long v46 = v70;
                  }
                }
                if (!_cg_DGifGetLine(v72, v46, count))
                {
                  if (v40 >= 0xFFFFFFFFLL) {
                    unint64_t v14 = 0xFFFFFFFFLL;
                  }
                  else {
                    unint64_t v14 = v40;
                  }
                  if (v14 != -1)
                  {
                    if (i < v24)
                    {
                      uint64_t v53 = gInterlacedJumps[v39];
                      size_t v54 = v23 * i;
                      do
                      {
                        memset((void *)(*(void *)(a6 + 40) + v54), __c[0], v23);
                        i += v53;
                        v54 += v53 * v23;
                      }
                      while (i < v24);
                    }
                    if (v39 <= 2)
                    {
                      do
                      {
                        int64_t v55 = gInterlacedOffset[++v39];
                        if (v55 < v24)
                        {
                          uint64_t v56 = gInterlacedJumps[v39];
                          size_t v57 = v23 * v55;
                          do
                          {
                            memset((void *)(*(void *)(a6 + 40) + v57), __c[0], v23);
                            v55 += v56;
                            v57 += v23 * v56;
                          }
                          while (v55 < v24);
                        }
                      }
                      while (v39 != 3);
                    }
                  }
                  goto LABEL_88;
                }
                if (!(v45 & 1 | (v65 >= v64))) {
                  memcpy(v43, __src, v23);
                }
                uint64_t v47 = i + v67;
                if (v40 > i + v67) {
                  uint64_t v47 = v40;
                }
                ++v38;
                BOOL v50 = v39 < 3 && v47 == v24 - 1 && v24 > 1;
                uint64_t v40 = v47 - v50;
              }
              if (++v39 != 4) {
                continue;
              }
              break;
            }
            if (v38) {
              BOOL v51 = v62 == 1;
            }
            else {
              BOOL v51 = 0;
            }
            if (v51 && v40 == 0) {
              unint64_t v14 = v38;
            }
            else {
              unint64_t v14 = v40;
            }
          }
          else
          {
            char v27 = *(char **)(a6 + 40);
            v92.origin.double x = x;
            v92.origin.CGFloat y = y;
            v92.size.CGFloat width = width;
            v92.size.CGFloat height = height;
            double v68 = CGRectGetMinY(v92);
            v93.origin.double x = (double)v10;
            v93.origin.CGFloat y = v17;
            v93.size.CGFloat width = (double)count;
            v93.size.CGFloat height = (double)v62;
            double v28 = CGRectGetMinY(v93);
            v94.origin.double x = x;
            v94.origin.CGFloat y = y;
            v94.size.CGFloat width = width;
            v94.size.CGFloat height = height;
            if (CGRectGetMaxY(v94) > (double)(uint64_t)v28)
            {
              uint64_t v29 = 0;
              uint64_t v30 = (uint64_t)v68;
              uint64_t v31 = (uint64_t)v28;
              BOOL v32 = &v70[v25];
              while (1)
              {
                uint64_t v33 = v31 + v29;
                unint64_t v34 = v65 >= v64 ? v27 : v70;
                long long v35 = v33 < v30 ? v70 : v34;
                if (!_cg_DGifGetLine(v72, v35, count)) {
                  break;
                }
                if (v33 >= v30 && v65 < v64) {
                  memcpy(v27, v32, v23);
                }
                v95.origin.double x = x;
                v95.origin.CGFloat y = y;
                v95.size.CGFloat width = width;
                v95.size.CGFloat height = height;
                CGFloat MaxY = CGRectGetMaxY(v95);
                v27 += v23;
                CGFloat v37 = (double)(v31 + v29++ + 1);
                if (MaxY <= v37)
                {
                  unint64_t v14 = v29 - 1;
                  goto LABEL_86;
                }
              }
              uint64_t v60 = v31 - v30 + v29;
              unint64_t v14 = v60 & ~(v60 >> 63);
              if (v14 < v24)
              {
                unint64_t v61 = v60 & ~(v60 >> 63);
                long long v58 = v70;
                do
                {
                  memset(v27, __c[0], v23);
                  v27 += v23;
                  ++v61;
                }
                while (v61 < v24);
LABEL_89:
                if (v58) {
                  free(v58);
                }
                goto LABEL_91;
              }
LABEL_88:
              long long v58 = v70;
              goto LABEL_89;
            }
            unint64_t v14 = -1;
          }
LABEL_86:
          if (*(void *)(v72 + 48)) {
            operator new();
          }
          goto LABEL_88;
        }
      }
    }
    else
    {
      _cg_jpeg_mem_term("decodeIndexedColorFrame", 610, "    GIF-ERROR: DGifGetImageDesc (%d)\n", 0);
    }
LABEL_98:
    unint64_t v14 = -1;
LABEL_91:
    _cg_DGifCloseFile(v72, 0);
    return v14;
  }
  return -1;
}

void sub_1887D3DF8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1020C40D090CC53);
  _Unwind_Resume(a1);
}

size_t gifReadWithScanner(uint64_t a1, void *a2, int a3)
{
  return IIOScanner::getBytes(*(IIOScanner **)(a1 + 88), a2, a3);
}

void GIFReadPlugin::decodeIndexedColorFrames(uint64_t a1, IIOImageRead *this, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  double v16 = 0;
  int v12 = IIOImageRead::retainBytePointer(this, (const __CFData **)&v16, 1);
  unsigned int Size = IIOImageRead::getSize(this);
  uint64_t v14 = (uint64_t)(a6[1] - *a6) >> 3;
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 0x40000000;
  _OWORD v15[2] = ___ZN13GIFReadPlugin24decodeIndexedColorFramesEP12IIOImageReadP13GlobalGIFInfoRK14ReadPluginDataRK13GIFPluginDataRNSt3__16vectorI20IIODecodeFrameParamsNSA_9allocatorISC_EEEE_block_invoke;
  void v15[3] = &__block_descriptor_tmp_50;
  v15[4] = a1;
  void v15[5] = a6;
  void v15[6] = v12;
  v15[7] = Size;
  UInt8 v15[8] = a3;
  v15[9] = a4;
  v15[10] = a5;
  dispatch_apply(0x2E8BA2E8BA2E8BA3 * v14, 0, v15);
  if (this)
  {
    if (v16) {
      IIOImageRead::releaseBytePointer(this, v16);
    }
  }
}

void ___ZN13GIFReadPlugin24decodeIndexedColorFramesEP12IIOImageReadP13GlobalGIFInfoRK14ReadPluginDataRK13GIFPluginDataRNSt3__16vectorI20IIODecodeFrameParamsNSA_9allocatorISC_EEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned __int8 **)(a1 + 48);
  uint64_t v5 = **(void **)(a1 + 40);
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  IIOScanner::IIOScanner((IIOScanner *)v9, v4, *(unsigned int *)(a1 + 56), 1);
  *(void *)(v5 + 88 * a2 + 64) = GIFReadPlugin::decodeIndexedColorFrame(v6, (IIOScanner *)v9, *(GlobalGIFInfo **)(a1 + 64), v7, v8, v5 + 88 * a2);
  IIOScanner::~IIOScanner((IIOScanner *)v9);
}

void sub_1887D3FD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *GIFReadPlugin::createFrameBufferAtIndex(task_t *a1, CGRect *a2, uint64_t a3, IIO_Reader *a4, GlobalGIFInfo *a5, uint64_t a6, uint64_t a7)
{
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler((IIO_ReaderHandler *)a1);
  IIO_ReaderHandler::readerForType(ReaderHandler, 1195984416);
  uint64_t v63 = 0;
  double v64 = 0;
  double v65 = 0;
  unint64_t v15 = (IIOImageRead *)IIO_Reader::testHeaderSize(a4);
  if (!v15) {
    goto LABEL_16;
  }
  uint64_t v61 = 0;
  memory_object_size_t v62 = 0;
  memset(v60, 0, sizeof(v60));
  GlobalGIFInfo::getFrameInfoAtIndex(a5, a3, (uint64_t)v60);
  LOWORD(v16) = WORD4(v60[0]);
  v68.origin.CGFloat x = (double)v16;
  LOWORD(v16) = WORD5(v60[0]);
  v68.origin.CGFloat y = (double)v16;
  LOWORD(v16) = WORD6(v60[0]);
  v68.size.double width = (double)v16;
  LOWORD(v16) = HIWORD(v60[0]);
  v68.size.double height = (double)v16;
  CGRect v67 = CGRectIntersection(*a2, v68);
  CGFloat x = v67.origin.x;
  CGFloat y = v67.origin.y;
  double width = v67.size.width;
  double height = v67.size.height;
  unint64_t v21 = (unint64_t)v67.size.width;
  if (!CGRectIsEmpty(v67))
  {
    if (is_mul_ok(v21, (unint64_t)height))
    {
      memory_object_offset_t v22 = _ImageIO_Malloc(v21 * (unint64_t)height, *(void *)(a6 + 200), &v62, (uint64_t)kImageMalloc_GIF_Data[0], a1[108], 0, 0);
      if (v22) {
        goto LABEL_6;
      }
    }
LABEL_16:
    unint64_t v34 = 0;
    goto LABEL_32;
  }
  memory_object_offset_t v22 = 0;
LABEL_6:
  *(void *)&long long v54 = a3;
  *((CGFloat *)&v54 + 1) = x;
  *(CGFloat *)&long long v55 = y;
  *((double *)&v55 + 1) = width;
  *(double *)&long long v56 = height;
  *((void *)&v56 + 1) = v22;
  *(void *)&long long v57 = (unint64_t)width;
  *((void *)&v57 + 1) = v62;
  *(void *)&long long v58 = 0;
  DWORD2(v58) = 0;
  uint64_t v59 = 0;
  unint64_t v23 = (unint64_t)v64;
  if (v64 >= v65)
  {
    unint64_t v29 = (unint64_t)v63;
    uint64_t v30 = 0x2E8BA2E8BA2E8BA3 * ((v64 - (char *)v63) >> 3);
    unint64_t v31 = v30 + 1;
    if ((unint64_t)(v30 + 1) > 0x2E8BA2E8BA2E8BALL) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    if (0x5D1745D1745D1746 * ((v65 - (char *)v63) >> 3) > v31) {
      unint64_t v31 = 0x5D1745D1745D1746 * ((v65 - (char *)v63) >> 3);
    }
    if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((v65 - (char *)v63) >> 3)) >= 0x1745D1745D1745DLL) {
      unint64_t v32 = 0x2E8BA2E8BA2E8BALL;
    }
    else {
      unint64_t v32 = v31;
    }
    v66[4] = (unint64_t)&v65;
    if (v32)
    {
      uint64_t v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIODecodeFrameParams>>((uint64_t)&v65, v32);
      unint64_t v29 = (unint64_t)v63;
      unint64_t v23 = (unint64_t)v64;
    }
    else
    {
      uint64_t v33 = 0;
    }
    long long v35 = &v33[88 * v30];
    long long v36 = v55;
    *(_OWORD *)long long v35 = v54;
    *((_OWORD *)v35 + 1) = v36;
    long long v37 = v56;
    long long v38 = v57;
    long long v39 = v58;
    *((void *)v35 + 10) = v59;
    *((_OWORD *)v35 + 3) = v38;
    *((_OWORD *)v35 + 4) = v39;
    *((_OWORD *)v35 + 2) = v37;
    if (v23 == v29)
    {
      double v42 = (uint64_t *)&v33[88 * v30];
    }
    else
    {
      unint64_t v40 = v23;
      int v41 = &v33[88 * v30];
      do
      {
        double v42 = (uint64_t *)(v41 - 88);
        long long v43 = *(_OWORD *)(v40 - 88);
        *(_OWORD *)(v41 - 72) = *(_OWORD *)(v40 - 72);
        *(_OWORD *)(v41 - 88) = v43;
        long long v44 = *(_OWORD *)(v40 - 56);
        long long v45 = *(_OWORD *)(v40 - 40);
        long long v46 = *(_OWORD *)(v40 - 24);
        *((void *)v41 - 1) = *(void *)(v40 - 8);
        *(_OWORD *)(v41 - 24) = v46;
        *(_OWORD *)(v41 - 40) = v45;
        *(_OWORD *)(v41 - 56) = v44;
        v40 -= 88;
        v41 -= 88;
      }
      while (v40 != v29);
    }
    double v28 = v35 + 88;
    uint64_t v63 = v42;
    double v64 = v35 + 88;
    unint64_t v47 = (unint64_t)v65;
    double v65 = &v33[88 * v32];
    v66[2] = v23;
    v66[3] = v47;
    v66[0] = v29;
    v66[1] = v29;
    std::__split_buffer<IIODecodeFrameParams>::~__split_buffer((uint64_t)v66);
  }
  else
  {
    long long v24 = v55;
    *(_OWORD *)double v64 = v54;
    *(_OWORD *)(v23 + 16) = v24;
    long long v25 = v56;
    long long v26 = v57;
    long long v27 = v58;
    *(void *)(v23 + 80) = v59;
    *(_OWORD *)(v23 + 48) = v26;
    *(_OWORD *)(v23 + 64) = v27;
    *(_OWORD *)(v23 + 32) = v25;
    double v28 = (char *)(v23 + 88);
  }
  double v64 = v28;
  IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)&v54);
  GIFReadPlugin::decodeIndexedColorFrames((uint64_t)a1, v15, (uint64_t)a5, a6, a7, &v63);
  long long v48 = v63;
  *(void *)&long long v56 = 0;
  long long v54 = 0u;
  long long v55 = 0u;
  GlobalGIFInfo::getFrameInfoAtIndex(a5, *v63, (uint64_t)&v54);
  if (WORD1(v55)) {
    double v49 = (double)WORD1(v55) / 100.0;
  }
  else {
    double v49 = 0.0333333333;
  }
  unint64_t v34 = (void *)IIOFrameBufferCreateForBuffer(v48[5], v48[7], HIWORD(v54) * (unint64_t)WORD6(v54), *v48, v49);
  IIOGIFFrameSetNumRowsDecoded((uint64_t)v34, v48[8]);
  BOOL v50 = (IIOColorMap *)v48[10];
  if (v50)
  {
    v66[0] = 0;
    Serializedunint64_t Data = IIOColorMap::createSerializedData(v50, v66);
    if (SerializedData)
    {
      CFDataRef v52 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)SerializedData, v66[0]);
      if (v52)
      {
        IIOFrameBufferSetColorTable(v34, v52);
        CFRelease(v52);
      }
      free(SerializedData);
    }
  }
LABEL_32:
  *(void *)&long long v54 = &v63;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100]((void ***)&v54);
  return v34;
}

void sub_1887D43C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  a9 = (void **)&a27;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t GIFReadPlugin::doDecodeImageData(task_t *a1, IIO_Reader *this, GlobalGIFInfo *a3, uint64_t a4, uint64_t a5, char *a6, size_t a7, uint64_t *a8, uint64_t *a9)
{
  uint64_t v142 = *MEMORY[0x1E4F143B8];
  if (!this || (uint64_t v14 = IIO_Reader::testHeaderSize(this)) == 0)
  {
    CGRect v85 = 0;
    uint64_t v106 = 0;
    uint64_t NumRowsDecoded = -1;
    goto LABEL_120;
  }
  uint64_t v15 = v14;
  uint64_t v108 = this;
  bzero(v141, 0x400uLL);
  unsigned int v16 = *(_DWORD *)a5;
  int v17 = *(_DWORD *)(a4 + 112);
  int v18 = *(_DWORD *)(a4 + 116);
  uint64_t v120 = a4;
  *(void *)uint64_t v139 = 0;
  unsigned int v114 = a3;
  GlobalGIFInfo::getSize((uint64_t)a3, &v139[1], v139);
  LODWORD(v19) = v139[1];
  LODWORD(v20) = v139[0];
  v140.origin.unint64_t y = 0.0;
  v140.origin.double x = 0.0;
  v140.size.unint64_t width = (double)v19;
  v140.size.unint64_t height = (double)v20;
  uint64_t v21 = *a8;
  if (!*a8)
  {
    int v30 = 1;
    unint64_t v23 = v114;
    goto LABEL_27;
  }
  memory_object_offset_t v22 = *(const void **)(v21 + 8);
  unint64_t v23 = a3;
  if (!v22) {
    goto LABEL_26;
  }
  unsigned int v24 = *(_DWORD *)(a4 + 24);
  if (!v24) {
    goto LABEL_26;
  }
  uint64_t v25 = *(unsigned int *)(v21 + 20);
  if (v25 == v24 - 1)
  {
    GlobalGIFInfo::getFrameInfoAtIndex(a3, v25, (uint64_t)__p);
    if ((unsigned __int16)v122 >= 2u)
    {
      unint64_t v23 = a3;
      if (unsigned __int16)v122 == 2 && (BYTE4(v123)) {
        unsigned int v16 = *(_DWORD *)(a4 + 24) - 1;
      }
    }
    else
    {
      uint64_t v26 = *a8;
      unint64_t v23 = a3;
      if (*(unsigned __int8 *)(*a8 + 36) == *(unsigned __int8 *)(a4 + 220))
      {
        unsigned int v27 = *(_DWORD *)(a4 + 116);
        if (v27 == *(_DWORD *)(v26 + 24))
        {
          unint64_t v28 = *(unsigned int *)(v26 + 32) * (unint64_t)v27;
          if (v28 >= a7) {
            size_t v29 = a7;
          }
          else {
            size_t v29 = v28;
          }
          memcpy(a6, *(const void **)(v26 + 8), v29);
          int v30 = 0;
          goto LABEL_27;
        }
      }
    }
LABEL_26:
    int v30 = 1;
    goto LABEL_27;
  }
  int v30 = 1;
  if (v25 >= v16
    && v25 < v24
    && *(unsigned __int8 *)(v21 + 36) == *(unsigned __int8 *)(a4 + 220))
  {
    unsigned int v31 = *(_DWORD *)(a4 + 116);
    if (v31 == *(_DWORD *)(v21 + 24))
    {
      unint64_t v32 = *(unsigned int *)(v21 + 32) * (unint64_t)v31;
      if (v32 >= a7) {
        size_t v33 = a7;
      }
      else {
        size_t v33 = v32;
      }
      memcpy(a6, v22, v33);
      unsigned int v16 = *(_DWORD *)(*a8 + 20);
    }
  }
LABEL_27:
  uint64_t v34 = v16;
  if (*(unsigned char *)(a5 + 4))
  {
    uint64_t v138 = 0;
    uint64_t v137 = 0;
    std::string::basic_string[abi:ne180100]<0>(__p, (char *)kFrameBufferQueueKey);
    ClientValueForKeunint64_t y = (IIO_ReaderHandler *)IIOImageRead::getClientValueForKey(v15, (const void **)__p, &v137);
    unint64_t v23 = v114;
    if (SBYTE7(v122) < 0) {
      operator delete(__p[0]);
    }
    long long v36 = v137;
    if (!v137)
    {
      ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(ClientValueForKey);
      IIO_ReaderHandler::readerForType(ReaderHandler, 1195984416);
      long long v38 = *(_OWORD *)(a4 + 208);
      long long v133 = *(_OWORD *)(a4 + 192);
      long long v134 = v38;
      long long v135 = *(_OWORD *)(a4 + 224);
      uint64_t v136 = *(void *)(a4 + 240);
      long long v39 = *(_OWORD *)(a4 + 144);
      long long v129 = *(_OWORD *)(a4 + 128);
      long long v130 = v39;
      long long v40 = *(_OWORD *)(a4 + 176);
      long long v131 = *(_OWORD *)(a4 + 160);
      long long v132 = v40;
      long long v41 = *(_OWORD *)(a4 + 80);
      long long v125 = *(_OWORD *)(a4 + 64);
      long long v126 = v41;
      long long v42 = *(_OWORD *)(a4 + 112);
      long long v127 = *(_OWORD *)(a4 + 96);
      long long v128 = v42;
      long long v43 = *(_OWORD *)(a4 + 16);
      *(_OWORD *)__p = *(_OWORD *)a4;
      long long v122 = v43;
      long long v44 = *(_OWORD *)(a4 + 48);
      long long v123 = *(_OWORD *)(a4 + 32);
      long long v124 = v44;
      operator new();
    }
    if (v138) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v138);
    }
  }
  else
  {
    long long v36 = 0;
  }
  BOOL v111 = v36;
  unsigned int v119 = &a6[v18 * v17];
  if (*(unsigned char *)(a5 + 5)) {
    int v45 = 0;
  }
  else {
    int v45 = v30;
  }
  LODWORD(v46) = *(_DWORD *)(a4 + 24);
  uint64_t NumRowsDecoded = -1;
  if (v45 == 1 && v34 < v46)
  {
    uint64_t Buffer = 0;
    uint64_t NumRowsDecoded = -1;
    unsigned int v47 = 255;
    uint64_t v48 = v34;
    while (1)
    {
      uint64_t v117 = v48;
      GlobalGIFInfo::getFrameInfoAtIndex(v23, v48, (uint64_t)__p);
      unsigned int v49 = LOWORD(__p[1]);
      unsigned int v50 = WORD1(__p[1]);
      unsigned int v51 = WORD2(__p[1]);
      unsigned int v52 = HIWORD(__p[1]);
      unsigned int v53 = (unsigned __int16)v122;
      int v54 = SWORD2(v122);
      char v55 = BYTE4(v123);
      if ((unsigned __int16)v122 == 2) {
        break;
      }
      if ((unsigned __int16)v122 != 3)
      {
        if (v111) {
          unsigned int v116 = (void *)IIOFrameBufferQueue::getAndRetainBufferAtIndex((os_unfair_lock_s *)v111, v117);
        }
        else {
          unsigned int v116 = GIFReadPlugin::createFrameBufferAtIndex(a1, &v140, v117, v108, v114, v120, a5);
        }
        if (!v116)
        {
          _cg_jpeg_mem_term("doDecodeImageData", 1144, "*** IIOFrameBufferQueue returned NULL for buffer at index: %ld\n", v117);
          goto LABEL_122;
        }
        uint64_t Buffer = IIOFrameBufferGetBuffer((uint64_t)v116);
        CFDataRef ColorTable = (const __CFData *)IIOFrameBufferGetColorTable((uint64_t)v116);
        CFDataRef v58 = ColorTable;
        if (ColorTable)
        {
          __p[0] = 0;
          __p[1] = 0;
          *(void *)&long long v122 = 0;
          BytePtr = CFDataGetBytePtr(ColorTable);
          CFIndex Length = CFDataGetLength(v58);
          IIOColorMap::IIOColorMap((IIOColorMap *)__p, BytePtr, Length);
          LOWORD(v61) = __p[0];
          IIOColorMap::copyToRGBX((unsigned int *)__p, v141, 0x400uLL, *(unsigned char *)(v120 + 221) == 0);
          uint64_t v62 = v122;
          *(void *)&long long v122 = 0;
          uint64_t v63 = (uint64_t)v116;
          if (v62) {
            MEMORY[0x18C11C0C0](v62, 0x1000C8033FC2DF1);
          }
        }
        else
        {
          double v64 = (unsigned int *)*((void *)v114 + 22);
          if (!v64)
          {
            bzero(a6, (*(_DWORD *)(v120 + 116) * *(_DWORD *)(v120 + 112)));
LABEL_118:
            CGRect v85 = v116;
            goto LABEL_119;
          }
          unsigned int v61 = *v64;
          IIOColorMap::copyToRGBX(v64, v141, 0x400uLL, *(unsigned char *)(v120 + 221) == 0);
          uint64_t v63 = (uint64_t)v116;
        }
        uint64_t NumRowsDecoded = IIOGIFFrameGetNumRowsDecoded(v63);
        if (NumRowsDecoded < 0) {
          goto LABEL_118;
        }
        if (v54 > (__int16)v61) {
          unsigned __int16 v65 = v54 + 1;
        }
        else {
          unsigned __int16 v65 = v61;
        }
        if (v65 >= 0xFFu) {
          unsigned int v47 = 255;
        }
        else {
          unsigned int v47 = v65;
        }
        goto LABEL_63;
      }
      if (!v117) {
        bzero(a6, (*(_DWORD *)(v120 + 116) * *(_DWORD *)(v120 + 112)));
      }
      long long v56 = 0;
LABEL_83:
      IIOFrameBufferRelease(v56);
      uint64_t v48 = v117 + 1;
      unint64_t v46 = *(unsigned int *)(v120 + 24);
      unint64_t v23 = v114;
      if (v117 + 1 >= v46) {
        goto LABEL_84;
      }
    }
    unsigned int v116 = 0;
LABEL_63:
    v145.origin.double x = (double)v49;
    v145.origin.unint64_t y = (double)v50;
    v145.size.unint64_t width = (double)v51;
    v145.size.unint64_t height = (double)v52;
    double x = v140.origin.x;
    CGRect v143 = CGRectIntersection(v140, v145);
    unint64_t height = (unint64_t)v143.size.height;
    if ((unint64_t)v143.size.height)
    {
      uint64_t v68 = 0;
      unint64_t width = (unint64_t)v143.size.width;
      unint64_t y = (unint64_t)v143.origin.y;
      CFNumberRef v71 = &a6[4 * (unint64_t)((double)(unint64_t)v143.origin.x - x)];
      size_t v72 = 4 * (unint64_t)v143.size.width;
      do
      {
        CFNumberRef v73 = &v71[(v68 + y) * *(unsigned int *)(v120 + 116)];
        if (v73 > v119 || &v73[v72] > v119) {
          break;
        }
        if (v53 < 2)
        {
          if (width)
          {
            CFNumberRef v75 = (unsigned __int8 *)(Buffer + v68 * width);
            unint64_t v76 = width;
            do
            {
              unsigned int v78 = *v75++;
              unsigned int v77 = v78;
              if (v78 > v47) {
                unsigned int v77 = 0;
              }
              if ((v55 & 2) == 0 || v77 != v54) {
                *(_DWORD *)CFNumberRef v73 = v141[v77];
              }
              v73 += 4;
              --v76;
            }
            while (v76);
          }
        }
        else if (v53 == 2 && width)
        {
          bzero(v73, v72);
        }
        ++v68;
      }
      while (v68 != height);
    }
    long long v56 = v116;
    goto LABEL_83;
  }
LABEL_84:
  GlobalGIFInfo::getFrameInfoAtIndex(v23, v46, (uint64_t)__p);
  unsigned int v79 = LOWORD(__p[1]);
  unsigned int v80 = WORD1(__p[1]);
  unsigned int v81 = WORD2(__p[1]);
  unsigned int v118 = HIWORD(__p[1]);
  int v82 = SWORD2(v122);
  char v83 = BYTE4(v123);
  if (v111) {
    CGRect v84 = (void *)IIOFrameBufferQueue::getAndRetainBufferAtIndex((os_unfair_lock_s *)v111, *(unsigned int *)(v120 + 24));
  }
  else {
    CGRect v84 = GIFReadPlugin::createFrameBufferAtIndex(a1, &v140, *(unsigned int *)(v120 + 24), v108, v114, v120, a5);
  }
  CGRect v85 = v84;
  if (!v84)
  {
    _cg_jpeg_mem_term("doDecodeImageData", 1280, "*** IIOFrameBufferQueue returned NULL for buffer at index: %u\n", *(_DWORD *)(v120 + 24));
LABEL_122:
    CGRect v85 = 0;
    goto LABEL_119;
  }
  uint64_t v86 = IIOFrameBufferGetBuffer((uint64_t)v84);
  CFDataRef v87 = (const __CFData *)IIOFrameBufferGetColorTable((uint64_t)v85);
  CFDataRef v88 = v87;
  if (v87)
  {
    __p[0] = 0;
    __p[1] = 0;
    *(void *)&long long v122 = 0;
    CGRect v89 = CFDataGetBytePtr(v87);
    CFIndex v90 = CFDataGetLength(v88);
    IIOColorMap::IIOColorMap((IIOColorMap *)__p, v89, v90);
    LOWORD(v91) = __p[0];
    IIOColorMap::copyToRGBX((unsigned int *)__p, v141, 0x400uLL, *(unsigned char *)(v120 + 221) == 0);
    uint64_t v92 = v122;
    *(void *)&long long v122 = 0;
    uint64_t v93 = (uint64_t)v85;
    if (v92) {
      MEMORY[0x18C11C0C0](v92, 0x1000C8033FC2DF1);
    }
    goto LABEL_93;
  }
  CGRect v94 = (unsigned int *)*((void *)v114 + 22);
  if (v94)
  {
    unsigned int v91 = *v94;
    IIOColorMap::copyToRGBX(v94, v141, 0x400uLL, *(unsigned char *)(v120 + 221) == 0);
    uint64_t v93 = (uint64_t)v85;
LABEL_93:
    uint64_t NumRowsDecoded = IIOGIFFrameGetNumRowsDecoded(v93);
    if ((NumRowsDecoded & 0x8000000000000000) == 0)
    {
      unsigned __int16 v95 = v82 > (__int16)v91 ? v82 + 1 : v91;
      unsigned int v96 = v95 >= 0xFFu ? 255 : v95;
      v146.origin.double x = (double)v79;
      v146.origin.unint64_t y = (double)v80;
      v146.size.unint64_t width = (double)v81;
      v146.size.unint64_t height = (double)v118;
      double v97 = v140.origin.x;
      CGRect v144 = CGRectIntersection(v140, v146);
      if ((unint64_t)v144.size.height)
      {
        uint64_t v98 = 0;
        unint64_t v99 = (unint64_t)v144.size.width;
        do
        {
          uint64_t v100 = &a6[4 * (unint64_t)((double)(int)v144.origin.x - v97)
                   + (v98 + (unint64_t)v144.origin.y) * *(unsigned int *)(v120 + 116)];
          if (v100 > v119 || &v100[4 * (unint64_t)v144.size.width] > v119) {
            break;
          }
          if (v99)
          {
            int v102 = (unsigned __int8 *)(v86 + v98 * v99);
            unint64_t v103 = (unint64_t)v144.size.width;
            do
            {
              unsigned int v105 = *v102++;
              unsigned int v104 = v105;
              if (v96 < v105) {
                unsigned int v104 = 0;
              }
              if ((v83 & 2) == 0 || v104 != v82) {
                *(_DWORD *)uint64_t v100 = v141[v104];
              }
              v100 += 4;
              --v103;
            }
            while (v103);
          }
          ++v98;
        }
        while (v98 != (unint64_t)v144.size.height);
      }
    }
    goto LABEL_119;
  }
  bzero(a6, (*(_DWORD *)(v120 + 116) * *(_DWORD *)(v120 + 112)));
LABEL_119:
  uint64_t v106 = 1;
LABEL_120:
  IIOFrameBufferRelease(v85);
  *a9 = NumRowsDecoded;
  return v106;
}

void sub_1887D4E34(_Unwind_Exception *a1)
{
  if (STACK[0x2F8]) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)STACK[0x2F8]);
  }
  _Unwind_Resume(a1);
}

__CFArray *___ZN13GIFReadPlugin17doDecodeImageDataEP19IIOImageReadSessionP13GlobalGIFInfoRK14ReadPluginDataRK13GIFPluginDataPhmNSt3__110shared_ptrI13GIFBufferInfoEEPl_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  unsigned int v61 = 0;
  CFAllocatorRef v48 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  unint64_t v6 = 0;
  uint64_t v49 = a2;
  while (a2 < GlobalGIFInfo::frameCount(*(GlobalGIFInfo **)(a1 + 40)))
  {
    memory_object_size_t v58 = 0;
    uint64_t v57 = 0;
    memset(v56, 0, sizeof(v56));
    GlobalGIFInfo::getFrameInfoAtIndex(*(GlobalGIFInfo **)(a1 + 40), a2, (uint64_t)v56);
    LOWORD(v7) = WORD4(v56[0]);
    v64.origin.CGFloat x = (double)v7;
    LOWORD(v7) = WORD5(v56[0]);
    v64.origin.CGFloat y = (double)v7;
    LOWORD(v7) = WORD6(v56[0]);
    v64.size.double width = (double)v7;
    LOWORD(v7) = HIWORD(v56[0]);
    v64.size.double height = (double)v7;
    CGRect v63 = CGRectIntersection(*(CGRect *)(a1 + 48), v64);
    CGFloat x = v63.origin.x;
    CGFloat y = v63.origin.y;
    double width = v63.size.width;
    double height = v63.size.height;
    unint64_t v12 = (unint64_t)v63.size.width;
    if (CGRectIsEmpty(v63))
    {
      memory_object_offset_t v13 = 0;
    }
    else
    {
      if (!is_mul_ok(v12, (unint64_t)height)) {
        goto LABEL_45;
      }
      memory_object_offset_t v13 = _ImageIO_Malloc(v12 * (unint64_t)height, *(void *)(a1 + 280), &v58, (uint64_t)kImageMalloc_GIF_Data[0], *(_DWORD *)(v4 + 432), 0, 0);
      if (!v13) {
        goto LABEL_45;
      }
      v6 += v12 * (unint64_t)height;
    }
    *(void *)&long long v50 = a2;
    *((CGFloat *)&v50 + 1) = x;
    *(CGFloat *)&long long v51 = y;
    *((double *)&v51 + 1) = width;
    *(double *)&long long v52 = height;
    *((void *)&v52 + 1) = v13;
    *(void *)&long long v53 = (unint64_t)width;
    *((void *)&v53 + 1) = v58;
    *(void *)&long long v54 = 0;
    DWORD2(v54) = 0;
    uint64_t v55 = 0;
    unint64_t v14 = (unint64_t)v60;
    if (v60 >= (uint64_t *)v61)
    {
      unint64_t v20 = (unint64_t)v59;
      uint64_t v21 = 0x2E8BA2E8BA2E8BA3 * (v60 - v59);
      unint64_t v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) > 0x2E8BA2E8BA2E8BALL) {
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      }
      if (0x5D1745D1745D1746 * ((v61 - (char *)v59) >> 3) > v22) {
        unint64_t v22 = 0x5D1745D1745D1746 * ((v61 - (char *)v59) >> 3);
      }
      unint64_t v23 = (unint64_t)(0x2E8BA2E8BA2E8BA3 * ((v61 - (char *)v59) >> 3)) >= 0x1745D1745D1745DLL
          ? 0x2E8BA2E8BA2E8BALL
          : v22;
      v62[4] = (unint64_t)&v61;
      if (v23)
      {
        unsigned int v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIODecodeFrameParams>>((uint64_t)&v61, v23);
        unint64_t v20 = (unint64_t)v59;
        unint64_t v14 = (unint64_t)v60;
      }
      else
      {
        unsigned int v24 = 0;
      }
      uint64_t v25 = &v24[88 * v21];
      long long v26 = v51;
      *(_OWORD *)uint64_t v25 = v50;
      *((_OWORD *)v25 + 1) = v26;
      long long v27 = v52;
      long long v28 = v53;
      long long v29 = v54;
      *((void *)v25 + 10) = v55;
      *((_OWORD *)v25 + 3) = v28;
      *((_OWORD *)v25 + 4) = v29;
      *((_OWORD *)v25 + 2) = v27;
      if (v14 == v20)
      {
        unint64_t v32 = &v24[88 * v21];
      }
      else
      {
        unint64_t v30 = v14;
        unsigned int v31 = &v24[88 * v21];
        do
        {
          unint64_t v32 = v31 - 88;
          long long v33 = *(_OWORD *)(v30 - 88);
          *(_OWORD *)(v31 - 72) = *(_OWORD *)(v30 - 72);
          *(_OWORD *)(v31 - 88) = v33;
          long long v34 = *(_OWORD *)(v30 - 56);
          long long v35 = *(_OWORD *)(v30 - 40);
          long long v36 = *(_OWORD *)(v30 - 24);
          *((void *)v31 - 1) = *(void *)(v30 - 8);
          *(_OWORD *)(v31 - 24) = v36;
          *(_OWORD *)(v31 - 40) = v35;
          *(_OWORD *)(v31 - 56) = v34;
          v30 -= 88;
          v31 -= 88;
        }
        while (v30 != v20);
      }
      unint64_t v19 = (uint64_t *)(v25 + 88);
      uint64_t v59 = (uint64_t *)v32;
      uint64_t v60 = (uint64_t *)(v25 + 88);
      unint64_t v37 = (unint64_t)v61;
      unsigned int v61 = &v24[88 * v23];
      v62[0] = v20;
      v62[2] = v14;
      v62[3] = v37;
      v62[1] = v20;
      std::__split_buffer<IIODecodeFrameParams>::~__split_buffer((uint64_t)v62);
    }
    else
    {
      long long v15 = v51;
      *(_OWORD *)uint64_t v60 = v50;
      *(_OWORD *)(v14 + 16) = v15;
      long long v16 = v52;
      long long v17 = v53;
      long long v18 = v54;
      *(void *)(v14 + 80) = v55;
      *(_OWORD *)(v14 + 48) = v17;
      *(_OWORD *)(v14 + 64) = v18;
      *(_OWORD *)(v14 + 32) = v16;
      unint64_t v19 = (uint64_t *)(v14 + 88);
    }
    uint64_t v60 = v19;
    IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)&v50);
    BOOL v38 = (v6 & 0xFFFFFFFFFFFF0000) != 0 && (unint64_t)(0x2E8BA2E8BA2E8BA3 * (v60 - v59)) > 2;
    if (v38 || v6 >> 20 != 0) {
      break;
    }
    ++a2;
  }
  if ((gIIODebugFlags & 0x1000000000000) != 0) {
    ImageIOLog("    Asking for frames at indexes: (%ld, %ld), %ld bytes\n", v49, 0x2E8BA2E8BA2E8BA3 * (v60 - v59), v6);
  }
  GIFReadPlugin::decodeIndexedColorFrames(v4, *(IIOImageRead **)(a1 + 328), *(void *)(a1 + 40), a1 + 80, a1 + 336, &v59);
  long long v40 = v59;
  for (uint64_t i = v60; v40 != i; v40 += 11)
  {
    *(void *)&long long v52 = 0;
    long long v50 = 0u;
    long long v51 = 0u;
    GlobalGIFInfo::getFrameInfoAtIndex(*(GlobalGIFInfo **)(a1 + 40), *v40, (uint64_t)&v50);
    double v42 = 0.0333333333;
    if (WORD1(v51)) {
      double v42 = (double)WORD1(v51) / 100.0;
    }
    long long v43 = (void *)IIOFrameBufferCreateForBuffer(v40[5], v40[7], HIWORD(v50) * (unint64_t)WORD6(v50), *v40, v42);
    IIOGIFFrameSetNumRowsDecoded((uint64_t)v43, v40[8]);
    long long v44 = (IIOColorMap *)v40[10];
    if (v44)
    {
      v62[0] = 0;
      Serializedunint64_t Data = IIOColorMap::createSerializedData(v44, v62);
      if (SerializedData)
      {
        CFDataRef v46 = CFDataCreate(v48, (const UInt8 *)SerializedData, v62[0]);
        if (v46)
        {
          IIOFrameBufferSetColorTable(v43, v46);
          CFRelease(v46);
        }
        free(SerializedData);
      }
    }
    CFArrayAppendValue(Mutable, v43);
    IIOFrameBufferRelease(v43);
  }
LABEL_45:
  *(void *)&long long v50 = &v59;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100]((void ***)&v50);
  return Mutable;
}

void sub_1887D537C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void **a15)
{
  a15 = (void **)(v15 - 184);
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](&a15);
  _Unwind_Resume(a1);
}

const void *GIFReadPlugin::copyImageBlockSetImp(IIOReadPlugin *this, const void *a2, const void *a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  uint64_t v15 = a3;
  int __dst = 0;
  if (a3) {
    CGImageProviderGetSize();
  }
  memory_object_size_t v66 = 0;
  if (!*((void *)this + 3)) {
    goto LABEL_52;
  }
  if (!*((void *)this + 49)) {
    *((void *)this + 49) = 16;
  }
  *((_DWORD *)this + 75) = (4 * *((_DWORD *)this + 57) + 15) & 0xFFFFFFF0;
  IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
  int CachedBlocks = IIOReadPlugin::getCachedBlocks(this, v18, v19, v20);
  IIOReadPlugin::debugCopyBlockSet((const char *)this, v15, a4, a5, a6, a7, a8, a9);
  if (CachedBlocks)
  {
    unint64_t v22 = IIOImageReadSession::globalInfoForType(*((IIOImageReadSession **)this + 3), 1195984416);
    if (v22)
    {
      unint64_t v23 = v22;
      if (GlobalGIFInfo::frameCount(v22) > *((_DWORD *)this + 52))
      {
        uint64_t v64 = 0;
        unsigned __int16 v65 = 0;
        GlobalGIFInfo::getCachedFrameBuffer(v23, &v64);
        memory_object_size_t v24 = *((unsigned int *)this + 75) * (unint64_t)*((unsigned int *)this + 74);
        uint64_t v25 = (void *)_ImageIO_Malloc(v24, *((void *)this + 48), &v66, (uint64_t)kImageMalloc_GIF_Data[0], *((_DWORD *)this + 108), 0, 0);
        int __dst = v25;
        if (v25)
        {
          if (v64)
          {
            long long v26 = *(const void **)(v64 + 8);
            if (v26)
            {
              unsigned int v27 = *(_DWORD *)(v64 + 24);
              size_t v28 = v27 * (unint64_t)*(unsigned int *)(v64 + 32);
              if (v28)
              {
                int v29 = *(_DWORD *)(v64 + 20);
                if (v29 == *((_DWORD *)this + 52)
                  && v27 == *((_DWORD *)this + 75)
                  && v28 == *((_DWORD *)this + 74) * v27)
                {
                  if ((gIIODebugFlags & 0x30000) != 0)
                  {
                    ImageIOLog("    frame#%d found in current-cache\n", v29);
                    uint64_t v25 = __dst;
                    long long v26 = *(const void **)(v64 + 8);
                    size_t v28 = *(unsigned int *)(v64 + 24) * (unint64_t)*(unsigned int *)(v64 + 32);
                  }
                  memcpy(v25, v26, v28);
                  if (*(unsigned __int8 *)(v64 + 36) != *((unsigned __int8 *)this + 404))
                  {
                    *(_DWORD *)permuteMap = 50331906;
                    dest.data = __dst;
                    uint64_t v31 = *(void *)((char *)this + 292);
                    v32.i64[0] = v31;
                    v32.i64[1] = HIDWORD(v31);
                    *(int8x16_t *)&dest.double height = vextq_s8(v32, v32, 8uLL);
                    dest.rowunint64_t Bytes = *((unsigned int *)this + 75);
                    vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
                  }
                  LODWORD(v30) = *((_DWORD *)this + 73);
                  CGFloat v33 = (double)v30;
                  LODWORD(v30) = *((_DWORD *)this + 74);
                  CGFloat v34 = (double)v30;
                  v68.origin.CGFloat x = 0.0;
                  v68.origin.CGFloat y = 0.0;
                  v68.size.double width = v33;
                  v68.size.double height = v34;
                  **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, __dst, v66, v68, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
                  v69.origin.CGFloat x = 0.0;
                  v69.origin.CGFloat y = 0.0;
                  v69.size.double width = v33;
                  v69.size.double height = v34;
                  AddSubRect((CGRect *)((char *)this + 120), v69);
                  int CachedBlocks = 0;
                  int v35 = 1;
                  *((_DWORD *)this + 26) = 1;
                  char v36 = 1;
LABEL_44:
                  if (v65) {
                    std::__shared_weak_count::__release_shared[abi:ne180100](v65);
                  }
                  if ((v36 & 1) == 0) {
                    goto LABEL_53;
                  }
                  goto LABEL_47;
                }
              }
            }
          }
          uint64_t v63 = 0;
          memset(&dest, 0, sizeof(dest));
          GlobalGIFInfo::getFrameInfoAtIndex(v23, *((unsigned int *)this + 52), (uint64_t)&dest);
          uint64_t v61 = 0;
          unint64_t v37 = (IIOImageRead **)*((void *)this + 3);
          if (v37)
          {
            int CachedBlocks = IIOImageReadSession::mapData(v37);
            unint64_t v37 = (IIOImageRead **)*((void *)this + 3);
          }
          else
          {
            int CachedBlocks = 0;
          }
          IIOImageReadSession::rewind((uint64_t)v37);
          BOOL v38 = (IIO_Reader *)*((void *)this + 3);
          size_t v40 = v66;
          long long v39 = (char *)__dst;
          long long v41 = v65;
          v60[0] = v64;
          v60[1] = (uint64_t)v65;
          if (v65) {
            atomic_fetch_add_explicit(&v65->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          int v35 = GIFReadPlugin::doDecodeImageData((task_t *)this, v38, v23, (uint64_t)this + 184, (uint64_t)this + 436, v39, v40, v60, &v61);
          if (v41) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v41);
          }
          if (LOWORD(dest.width) <= 1u)
          {
            *(void *)permuteMap = 0;
            uint64_t v59 = 0;
            char v57 = 1;
            unsigned int v56 = *((_DWORD *)this + 75);
            std::allocate_shared[abi:ne180100]<GIFBufferInfo,std::allocator<GIFBufferInfo>,unsigned char *&,BOOL,unsigned int &,unsigned int &,unsigned int,void>((unsigned __int8 **)&__dst, (BOOL *)&v57, (unsigned int *)this + 73, (unsigned int *)this + 74, &v56, permuteMap);
            uint64_t v43 = *(void *)permuteMap;
            *(_DWORD *)(*(void *)permuteMap + 20) = *((_DWORD *)this + 52);
            *(unsigned char *)(v43 + 36) = *((unsigned char *)this + 404);
            GlobalGIFInfo::setCachedFrameBuffer((uint64_t)v23, (uint64_t *)permuteMap);
            if (v59) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v59);
            }
          }
          if ((v61 & 0x8000000000000000) == 0)
          {
            LODWORD(v42) = *((_DWORD *)this + 73);
            double v44 = (double)v42;
            LODWORD(v42) = *((_DWORD *)this + 74);
            double v45 = (double)v42;
            if (v61 >= HIWORD(dest.height) - 1)
            {
              BOOL v46 = *((unsigned char *)this + 343) != 0;
            }
            else
            {
              BOOL v46 = 0;
              *((unsigned char *)this + 343) = 0;
            }
            v70.origin.CGFloat x = 0.0;
            v70.origin.CGFloat y = 0.0;
            v70.size.double width = v44;
            v70.size.double height = v45;
            **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, __dst, v66, v70, *((unsigned int *)this + 75), v46);
            BOOL v48 = CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E4F1DB20]);
            uint64_t v49 = 0;
            if (v48)
            {
              uint64_t v50 = 0;
            }
            else
            {
              v71.origin.CGFloat x = 0.0;
              v71.origin.CGFloat y = 0.0;
              v71.size.double width = v44;
              v71.size.double height = v45;
              *(CGRect *)&uint64_t v49 = CGRectUnion(*(CGRect *)((char *)this + 120), v71);
              double v44 = v51;
              double v45 = v52;
            }
            *((void *)this + 15) = v49;
            *((void *)this + 16) = v50;
            char v36 = 1;
            *((double *)this + 17) = v44;
            *((double *)this + 18) = v45;
            goto LABEL_44;
          }
          int v47 = *((_DWORD *)this + 26);
          if (v47) {
            *((_DWORD *)this + 26) = v47 - 1;
          }
          _ImageIO_Free((unint64_t)__dst, v66);
        }
        else
        {
          _cg_jpeg_mem_term("copyImageBlockSetImp", 1456, "*** ImageIO_Malloc failed to alloc %ld bytes\n", v24);
          int CachedBlocks = 0;
          int v35 = 0;
        }
        char v36 = 0;
        goto LABEL_44;
      }
    }
LABEL_52:
    int CachedBlocks = 0;
    goto LABEL_53;
  }
  int v35 = 1;
LABEL_47:
  unint64_t v53 = *((unsigned int *)this + 26);
  if (v53 && v15 && v35)
  {
    uint64_t v15 = (const void *)IIOReadPlugin::imageBlockSetCreate((uint64_t)this, (uint64_t)v15, v53, *((double *)this + 17), *((double *)this + 18), *((double *)this + 15), *((double *)this + 16), *((double *)this + 17), *((double *)this + 18), *((void *)this + 12), a2);
    IIOReadPlugin::freeBlockArray(this);
    if ((CachedBlocks & 1) == 0) {
      return v15;
    }
    goto LABEL_57;
  }
LABEL_53:
  if (v15)
  {
    IIOReadPlugin::freeBlockArray(this);
    uint64_t v15 = 0;
    if ((CachedBlocks & 1) == 0) {
      return v15;
    }
  }
  else if (!CachedBlocks)
  {
    return v15;
  }
LABEL_57:
  long long v54 = (const char **)*((void *)this + 3);
  if (v54) {
    IIOImageReadSession::unmapData(v54);
  }
  return v15;
}

void sub_1887D5938(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::__shared_weak_count *a23)
{
  if (a23) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t GIFReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4, uint64_t a5, uint64_t *a6)
{
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v11 = *((_DWORD *)this + 51);
    unsigned int v12 = v11 >> 24;
    uint64_t v13 = MEMORY[0x1E4F14390];
    if (v11 < 0)
    {
      int v14 = __maskrune(v12, 0x40000uLL);
      int v11 = *((_DWORD *)this + 51);
    }
    else
    {
      int v14 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x40000;
    }
    if (v14) {
      uint64_t v15 = (v11 >> 24);
    }
    else {
      uint64_t v15 = 46;
    }
    unsigned int v16 = v11 << 8 >> 24;
    if (v11 << 8 < 0)
    {
      int v17 = __maskrune(v16, 0x40000uLL);
      int v11 = *((_DWORD *)this + 51);
    }
    else
    {
      int v17 = *(_DWORD *)(v13 + 4 * v16 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = (v11 << 8 >> 24);
    }
    else {
      uint64_t v18 = 46;
    }
    unsigned int v19 = (__int16)v11 >> 8;
    if (v11 << 16 < 0)
    {
      int v20 = __maskrune(v19, 0x40000uLL);
      int v11 = *((_DWORD *)this + 51);
    }
    else
    {
      int v20 = *(_DWORD *)(v13 + 4 * v19 + 60) & 0x40000;
    }
    if (v20) {
      uint64_t v21 = ((__int16)v11 >> 8);
    }
    else {
      uint64_t v21 = 46;
    }
    if ((v11 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000) != 0) {
        goto LABEL_22;
      }
    }
    else if (__maskrune((char)v11, 0x40000uLL))
    {
LABEL_22:
      uint64_t v22 = *((char *)this + 204);
LABEL_25:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v15, v18, v21, v22, iioTypeStr[a3], "virtual OSStatus GIFReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    uint64_t v22 = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  *((_DWORD *)this + 52) = *((void *)a2 + 9);
  *((_DWORD *)this + 26) = 1;
  uint64_t v23 = *((void *)a2 + 1);
  uint64_t v24 = *((void *)a2 + 2);
  double v25 = *((double *)a2 + 3);
  double v26 = *((double *)a2 + 4);
  double v27 = *((double *)a2 + 5);
  double v28 = *((double *)a2 + 6);
  double v29 = *((double *)a2 + 7);
  double v30 = *((double *)a2 + 8);
  uint64_t XmpData = _APP1XMP::getXmpData(a2);
  uint64_t v32 = (*(uint64_t (**)(IIOReadPlugin *, uint64_t, uint64_t, uint64_t, double, double, double, double, double, double))(*(void *)this + 208))(this, v23, v24, XmpData, v25, v26, v27, v28, v29, v30);
  uint64_t v33 = v32;
  if (a3 == 1)
  {
    if (v32 && CGImageBlockSetGetCount() == 1 || *((_DWORD *)this + 26) == 1)
    {
      if (!a4 || !*a4)
      {
        uint64_t v37 = 0;
        goto LABEL_50;
      }
      if (IOSurfaceLock(*a4, 0, 0))
      {
        uint64_t v37 = 4294967246;
      }
      else
      {
        BaseAddress = IOSurfaceGetBaseAddress(*a4);
        IOSurfaceGetWidth(*a4);
        size_t Height = IOSurfaceGetHeight(*a4);
        size_t BytesPerRow = IOSurfaceGetBytesPerRow(*a4);
        if (v33) {
          CGImageBlockSetGetImageBlock();
        }
        CGImageBlockGetRect();
        double v39 = v38;
        uint64_t v40 = CGImageBlockGetBytesPerRow();
        unint64_t Data = (const void *)CGImageBlockGetData();
        if (BytesPerRow == v40 && Height == (unint64_t)v39) {
          memcpy(BaseAddress, Data, BytesPerRow * Height);
        }
        else {
          _cg_jpeg_mem_term("decodeImageImp", 1641, "*** ERROR: cannot copy into IOSurface\n");
        }
        IOSurfaceUnlock(*a4, 1u, 0);
        uint64_t v37 = 0;
      }
    }
    else
    {
      uint64_t v37 = 4294967246;
      if (!a4) {
        goto LABEL_50;
      }
    }
    goto LABEL_48;
  }
  uint64_t v37 = 4294967246;
  if (a3 == 3 && a6)
  {
    uint64_t v37 = 0;
    *a6 = v32;
    uint64_t v33 = 0;
  }
  if (a4)
  {
LABEL_48:
    if (*a4) {
      IOSurfaceUnlock(*a4, 0, 0);
    }
  }
LABEL_50:
  if (v33) {
    CGImageBlockSetRelease();
  }
  return v37;
}

void *std::allocate_shared[abi:ne180100]<GIFBufferInfo,std::allocator<GIFBufferInfo>,unsigned char *&,BOOL,unsigned int &,unsigned int &,unsigned int,void>@<X0>(unsigned __int8 **a1@<X1>, BOOL *a2@<X2>, unsigned int *a3@<X3>, unsigned int *a4@<X4>, unsigned int *a5@<X5>, void *a6@<X8>)
{
  unsigned int v12 = operator new(0x40uLL);
  uint64_t result = std::__shared_ptr_emplace<GIFBufferInfo>::__shared_ptr_emplace[abi:ne180100]<unsigned char *&,BOOL,unsigned int &,unsigned int &,unsigned int,std::allocator<GIFBufferInfo>,0>(v12, a1, a2, a3, a4, a5);
  *a6 = v12 + 3;
  a6[1] = v12;
  return result;
}

void sub_1887D5D88(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<GIFBufferInfo>::__shared_ptr_emplace[abi:ne180100]<unsigned char *&,BOOL,unsigned int &,unsigned int &,unsigned int,std::allocator<GIFBufferInfo>,0>(void *a1, unsigned __int8 **a2, BOOL *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1ED4EF310;
  GIFBufferInfo::GIFBufferInfo((GIFBufferInfo *)(a1 + 3), *a2, *a3, *a4, *a5, *a6);
  return a1;
}

void sub_1887D5DF8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t png_write_filter_row_none_neon(int8x16_t *a1, uint64_t a2, unint64_t a3)
{
  int32x4_t v3 = 0uLL;
  if (a3 >= 0x40)
  {
    int32x4_t v4 = 0uLL;
    int32x4_t v5 = 0uLL;
    int32x4_t v6 = 0uLL;
    do
    {
      int8x16_t v7 = *a1;
      int8x16_t v8 = a1[1];
      int8x16_t v9 = a1[2];
      int8x16_t v10 = a1[3];
      a1 += 4;
      int32x4_t v3 = (int32x4_t)vpadalq_u16((uint32x4_t)v3, vpaddlq_u8((uint8x16_t)vabsq_s8(v7)));
      int32x4_t v4 = (int32x4_t)vpadalq_u16((uint32x4_t)v4, vpaddlq_u8((uint8x16_t)vabsq_s8(v8)));
      int32x4_t v5 = (int32x4_t)vpadalq_u16((uint32x4_t)v5, vpaddlq_u8((uint8x16_t)vabsq_s8(v9)));
      int32x4_t v6 = (int32x4_t)vpadalq_u16((uint32x4_t)v6, vpaddlq_u8((uint8x16_t)vabsq_s8(v10)));
      a3 -= 64;
    }
    while (a3 > 0x3F);
    int32x4_t v3 = vaddq_s32(vaddq_s32(v5, v6), vaddq_s32(v4, v3));
  }
  if (a3 >= 0x10)
  {
    do
    {
      int8x16_t v11 = *a1++;
      int32x4_t v3 = (int32x4_t)vpadalq_u16((uint32x4_t)v3, vpaddlq_u8((uint8x16_t)vabsq_s8(v11)));
      a3 -= 16;
    }
    while (a3 > 0xF);
  }
  v12.i64[0] = vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32((uint32x4_t)v3), 1), (uint32x4_t)v3).u64[0];
  uint64_t v13 = v12.u32[0];
  if (a3 >= 4)
  {
    v14.i64[0] = 0x10000000100;
    v14.i64[1] = 0x10000000100;
    do
    {
      __int32 v15 = a1->i32[0];
      a1 = (int8x16_t *)((char *)a1 + 4);
      v12.i32[0] = v15;
      int16x4_t v16 = (int16x4_t)vmovl_u8(*(uint8x8_t *)v12.i8).u64[0];
      int32x4_t v12 = (int32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vcltz_s16(vshr_n_s16(vshl_n_s16(v16, 8uLL), 8uLL))), (int8x16_t)vsubw_u16(v14, (uint16x4_t)v16), (int8x16_t)vmovl_u16((uint16x4_t)v16));
      uint64_t v13 = (vaddvq_s32(v12) + v13);
      a3 -= 4;
    }
    while (a3 > 3);
  }
  return v13;
}

uint64_t png_write_filter_row_sub_neon(int8x16_t *a1, unsigned char *a2, uint64_t a3, double a4, double a5, int32x4_t a6, int32x4_t a7)
{
  int v7 = a1->u8[0];
  int v8 = a1->u8[1];
  int v9 = a1->u8[2];
  int v10 = a1->u8[3];
  int8x16_t v11 = &a1->u8[4];
  *a2 = v7;
  a2[1] = v8;
  a2[2] = v9;
  a2[3] = v10;
  int32x4_t v12 = (int8x16_t *)(a2 + 4);
  if ((v7 & 0x80u) != 0) {
    int v7 = 256 - v7;
  }
  int v13 = 256 - v8;
  if ((v8 & 0x80u) == 0) {
    int v13 = v8;
  }
  int v14 = 256 - v9;
  if ((v9 & 0x80u) == 0) {
    int v14 = v9;
  }
  int v15 = 256 - v10;
  if ((v10 & 0x80u) == 0) {
    int v15 = v10;
  }
  int v16 = v13 + v7;
  int v17 = v14 + v15;
  unint64_t v18 = a3 - 4;
  int32x4_t v19 = 0uLL;
  if ((unint64_t)(a3 - 4) >= 0x40)
  {
    int32x4_t v20 = 0uLL;
    int32x4_t v21 = 0uLL;
    a7 = 0uLL;
    do
    {
      uint64_t v22 = v11 + 64;
      int8x16_t v23 = vsubq_s8(*(int8x16_t *)v11, *(int8x16_t *)(v11 - 4));
      int8x16_t v24 = vsubq_s8(*((int8x16_t *)v11 + 1), *(int8x16_t *)(v11 + 12));
      int8x16_t v25 = vsubq_s8(*((int8x16_t *)v11 + 2), *(int8x16_t *)(v11 + 28));
      int8x16_t v26 = vsubq_s8(*((int8x16_t *)v11 + 3), *(int8x16_t *)(v11 + 44));
      *int32x4_t v12 = v23;
      v12[1] = v24;
      void v12[2] = v25;
      void v12[3] = v26;
      v12 += 4;
      int32x4_t v19 = (int32x4_t)vpadalq_u16((uint32x4_t)v19, vpaddlq_u8((uint8x16_t)vabsq_s8(v23)));
      int32x4_t v20 = (int32x4_t)vpadalq_u16((uint32x4_t)v20, vpaddlq_u8((uint8x16_t)vabsq_s8(v24)));
      int32x4_t v21 = (int32x4_t)vpadalq_u16((uint32x4_t)v21, vpaddlq_u8((uint8x16_t)vabsq_s8(v25)));
      a7 = (int32x4_t)vpadalq_u16((uint32x4_t)a7, vpaddlq_u8((uint8x16_t)vabsq_s8(v26)));
      v18 -= 64;
      v11 += 64;
    }
    while (v18 > 0x3F);
    a6 = vaddq_s32(v21, a7);
    int32x4_t v19 = vaddq_s32(a6, vaddq_s32(v20, v19));
    a1 = (int8x16_t *)(v22 - 4);
    int8x16_t v11 = v22;
  }
  int v27 = v16 + v17;
  if (v18 >= 0x10)
  {
    do
    {
      int8x16_t v28 = *(int8x16_t *)v11;
      v11 += 16;
      int8x16_t v29 = v28;
      int8x16_t v30 = *a1++;
      a6.i32[1] = v30.i32[1];
      int8x16_t v31 = vsubq_s8(v29, v30);
      *v12++ = v31;
      int32x4_t v19 = (int32x4_t)vpadalq_u16((uint32x4_t)v19, vpaddlq_u8((uint8x16_t)vabsq_s8(v31)));
      v18 -= 16;
    }
    while (v18 > 0xF);
  }
  uint64_t v32 = v27
      + vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32((uint32x4_t)v19), 1), (uint32x4_t)v19).u32[0];
  if (v18 >= 4)
  {
    v33.i64[0] = 0xFF000000FFLL;
    v33.i64[1] = 0xFF000000FFLL;
    v34.i64[0] = 0x10000000100;
    v34.i64[1] = 0x10000000100;
    do
    {
      unsigned __int32 v35 = *(_DWORD *)v11;
      v11 += 4;
      a6.i32[0] = v35;
      unsigned __int32 v36 = a1->i32[0];
      a1 = (int8x16_t *)((char *)a1 + 4);
      a7.i32[0] = v36;
      int16x8_t v37 = (int16x8_t)vsubl_u8(*(uint8x8_t *)a6.i8, *(uint8x8_t *)a7.i8);
      v12->i32[0] = vmovn_s16(v37).u32[0];
      int32x4_t v12 = (int8x16_t *)((char *)v12 + 4);
      int16x4_t v38 = vshr_n_s16(vshl_n_s16(*(int16x4_t *)v37.i8, 8uLL), 8uLL);
      int32x4_t v39 = (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v37.i8), v33);
      a7 = vmovl_s16(vcltz_s16(v38));
      a6 = (int32x4_t)vbslq_s8((int8x16_t)a7, (int8x16_t)vsubq_s32(v34, v39), (int8x16_t)v39);
      uint64_t v32 = (vaddvq_s32(a6) + v32);
      v18 -= 4;
    }
    while (v18 > 3);
  }
  return v32;
}

uint64_t png_write_filter_row_up_neon(int8x16_t *a1, int8x16_t *a2, int8x16_t *a3, unint64_t a4, double a5, double a6, int32x4_t a7, int32x4_t a8)
{
  int32x4_t v8 = 0uLL;
  if (a4 >= 0x40)
  {
    int32x4_t v9 = 0uLL;
    int32x4_t v10 = 0uLL;
    a8 = 0uLL;
    do
    {
      int8x16_t v11 = *a1;
      int8x16_t v12 = a1[1];
      int8x16_t v13 = a1[2];
      int8x16_t v14 = a1[3];
      a1 += 4;
      int8x16_t v15 = *a3;
      int8x16_t v16 = a3[1];
      int8x16_t v17 = a3[2];
      int8x16_t v18 = a3[3];
      a3 += 4;
      int8x16_t v19 = vsubq_s8(v11, v15);
      int8x16_t v20 = vsubq_s8(v12, v16);
      int8x16_t v21 = vsubq_s8(v13, v17);
      int8x16_t v22 = vsubq_s8(v14, v18);
      *a2 = v19;
      a2[1] = v20;
      a2[2] = v21;
      a2[3] = v22;
      a2 += 4;
      int32x4_t v8 = (int32x4_t)vpadalq_u16((uint32x4_t)v8, vpaddlq_u8((uint8x16_t)vabsq_s8(v19)));
      int32x4_t v9 = (int32x4_t)vpadalq_u16((uint32x4_t)v9, vpaddlq_u8((uint8x16_t)vabsq_s8(v20)));
      int32x4_t v10 = (int32x4_t)vpadalq_u16((uint32x4_t)v10, vpaddlq_u8((uint8x16_t)vabsq_s8(v21)));
      a8 = (int32x4_t)vpadalq_u16((uint32x4_t)a8, vpaddlq_u8((uint8x16_t)vabsq_s8(v22)));
      a4 -= 64;
    }
    while (a4 > 0x3F);
    a7 = vaddq_s32(v10, a8);
    int32x4_t v8 = vaddq_s32(a7, vaddq_s32(v9, v8));
  }
  if (a4 >= 0x10)
  {
    do
    {
      int8x16_t v23 = *a1++;
      int8x16_t v24 = v23;
      int8x16_t v25 = *a3++;
      a7.i32[1] = v25.i32[1];
      int8x16_t v26 = vsubq_s8(v24, v25);
      *a2++ = v26;
      int32x4_t v8 = (int32x4_t)vpadalq_u16((uint32x4_t)v8, vpaddlq_u8((uint8x16_t)vabsq_s8(v26)));
      a4 -= 16;
    }
    while (a4 > 0xF);
  }
  uint64_t v27 = vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32((uint32x4_t)v8), 1), (uint32x4_t)v8).u32[0];
  if (a4 >= 4)
  {
    v28.i64[0] = 0xFF000000FFLL;
    v28.i64[1] = 0xFF000000FFLL;
    v29.i64[0] = 0x10000000100;
    v29.i64[1] = 0x10000000100;
    do
    {
      unsigned __int32 v30 = a1->i32[0];
      a1 = (int8x16_t *)((char *)a1 + 4);
      a7.i32[0] = v30;
      unsigned __int32 v31 = a3->i32[0];
      a3 = (int8x16_t *)((char *)a3 + 4);
      a8.i32[0] = v31;
      int16x8_t v32 = (int16x8_t)vsubl_u8(*(uint8x8_t *)a7.i8, *(uint8x8_t *)a8.i8);
      a2->i32[0] = vmovn_s16(v32).u32[0];
      a2 = (int8x16_t *)((char *)a2 + 4);
      int16x4_t v33 = vshr_n_s16(vshl_n_s16(*(int16x4_t *)v32.i8, 8uLL), 8uLL);
      int32x4_t v34 = (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v32.i8), v28);
      a8 = vmovl_s16(vcltz_s16(v33));
      a7 = (int32x4_t)vbslq_s8((int8x16_t)a8, (int8x16_t)vsubq_s32(v29, v34), (int8x16_t)v34);
      uint64_t v27 = (vaddvq_s32(a7) + v27);
      a4 -= 4;
    }
    while (a4 > 3);
  }
  return v27;
}

uint64_t png_write_filter_row_avg_neon(unsigned __int32 *a1, _DWORD *a2, _DWORD *a3, uint64_t a4, uint8x8_t a5, uint8x8_t a6, int32x4_t a7, int32x4_t a8, int32x4_t a9)
{
  int32x4_t v9 = (int8x16_t *)(a1 + 1);
  a5.i32[0] = *a1;
  __int32 v11 = *a3;
  int32x4_t v10 = (uint8x16_t *)(a3 + 1);
  a6.i32[0] = v11;
  int16x8_t v12 = (int16x8_t)vmovl_u8(a5);
  *(int16x4_t *)v12.i8 = vsub_s16(*(int16x4_t *)v12.i8, (int16x4_t)vshr_n_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a6), 1uLL));
  *a2 = vmovn_s16(v12).u32[0];
  int8x16_t v13 = (int8x16_t *)(a2 + 1);
  int v14 = 256 - v12.u8[0];
  if (v12.i8[0] >= 0) {
    int v14 = v12.u8[0];
  }
  int v15 = 256 - v12.u8[2];
  if (v12.i8[2] >= 0) {
    int v15 = v12.u8[2];
  }
  int v16 = 256 - v12.u8[4];
  if (v12.i8[4] >= 0) {
    int v16 = v12.u8[4];
  }
  int v17 = 256 - v12.u8[6];
  if (v12.i8[6] >= 0) {
    int v17 = v12.u8[6];
  }
  int v18 = v15 + v14;
  int v19 = v16 + v17;
  unint64_t v20 = a4 - 4;
  if ((unint64_t)(a4 - 4) < 0x40)
  {
    uint32x4_t v30 = 0uLL;
  }
  else
  {
    unint64_t v21 = 0;
    int32x4_t v22 = 0uLL;
    int32x4_t v23 = 0uLL;
    int32x4_t v24 = 0uLL;
    a8 = 0uLL;
    do
    {
      int8x16_t v25 = &v13[v21 / 0x10];
      int8x16_t v26 = vsubq_s8(*(int8x16_t *)&a1[v21 / 4 + 1], (int8x16_t)vhaddq_u8(*(uint8x16_t *)&a1[v21 / 4], v10[v21 / 0x10]));
      int8x16_t v27 = vsubq_s8(*(int8x16_t *)&a1[v21 / 4 + 5], (int8x16_t)vhaddq_u8(*(uint8x16_t *)&a1[v21 / 4 + 4], v10[v21 / 0x10 + 1]));
      int8x16_t v28 = vsubq_s8(*(int8x16_t *)&a1[v21 / 4 + 9], (int8x16_t)vhaddq_u8(*(uint8x16_t *)&a1[v21 / 4 + 8], v10[v21 / 0x10 + 2]));
      int8x16_t v29 = vsubq_s8(*(int8x16_t *)&a1[v21 / 4 + 13], (int8x16_t)vhaddq_u8(*(uint8x16_t *)&a1[v21 / 4 + 12], v10[v21 / 0x10 + 3]));
      *int8x16_t v25 = v26;
      v25[1] = v27;
      v25[2] = v28;
      void v25[3] = v29;
      a9 = (int32x4_t)vpaddlq_u8((uint8x16_t)vabsq_s8(v26));
      int32x4_t v22 = (int32x4_t)vpadalq_u16((uint32x4_t)v22, (uint16x8_t)a9);
      int32x4_t v23 = (int32x4_t)vpadalq_u16((uint32x4_t)v23, vpaddlq_u8((uint8x16_t)vabsq_s8(v27)));
      int32x4_t v24 = (int32x4_t)vpadalq_u16((uint32x4_t)v24, vpaddlq_u8((uint8x16_t)vabsq_s8(v28)));
      a8 = (int32x4_t)vpadalq_u16((uint32x4_t)a8, vpaddlq_u8((uint8x16_t)vabsq_s8(v29)));
      v20 -= 64;
      v21 += 64;
    }
    while (v20 > 0x3F);
    a7 = vaddq_s32(v24, a8);
    uint32x4_t v30 = (uint32x4_t)vaddq_s32(a7, vaddq_s32(v23, v22));
    a1 = (unsigned __int32 *)((char *)a1 + v21);
    int32x4_t v9 = (int8x16_t *)(a1 + 1);
    int32x4_t v10 = (uint8x16_t *)((char *)v10 + v21);
    int8x16_t v13 = (int8x16_t *)((char *)v13 + v21);
  }
  int v31 = v18 + v19;
  if (v20 >= 0x10)
  {
    do
    {
      int8x16_t v32 = *v9++;
      int8x16_t v33 = v32;
      uint8x16_t v34 = *(uint8x16_t *)a1;
      a1 += 4;
      uint8x16_t v35 = v34;
      uint8x16_t v36 = *v10++;
      a8.i32[1] = v36.i32[1];
      a7 = (int32x4_t)vhaddq_u8(v35, v36);
      int8x16_t v37 = vsubq_s8(v33, (int8x16_t)a7);
      *v13++ = v37;
      uint32x4_t v30 = vpadalq_u16(v30, vpaddlq_u8((uint8x16_t)vabsq_s8(v37)));
      v20 -= 16;
    }
    while (v20 > 0xF);
  }
  uint64_t v38 = v31 + vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32(v30), 1), v30).u32[0];
  if (v20 >= 4)
  {
    v39.i64[0] = 0xFF000000FFLL;
    v39.i64[1] = 0xFF000000FFLL;
    v40.i64[0] = 0x10000000100;
    v40.i64[1] = 0x10000000100;
    do
    {
      unsigned __int32 v41 = v9->i32[0];
      int32x4_t v9 = (int8x16_t *)((char *)v9 + 4);
      a7.i32[0] = v41;
      unsigned __int32 v42 = *a1++;
      a8.i32[0] = v42;
      unsigned __int32 v43 = v10->i32[0];
      int32x4_t v10 = (uint8x16_t *)((char *)v10 + 4);
      a9.i32[0] = v43;
      int16x8_t v44 = (int16x8_t)vmovl_u8(*(uint8x8_t *)a7.i8);
      *(int16x4_t *)v44.i8 = vsub_s16(*(int16x4_t *)v44.i8, (int16x4_t)vhadd_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)a9.i8), (uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)a8.i8)));
      v13->i32[0] = vmovn_s16(v44).u32[0];
      int8x16_t v13 = (int8x16_t *)((char *)v13 + 4);
      int16x4_t v45 = vshr_n_s16(vshl_n_s16(*(int16x4_t *)v44.i8, 8uLL), 8uLL);
      int32x4_t v46 = (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v44.i8), v39);
      a9 = vsubq_s32(v40, v46);
      a8 = vmovl_s16(vcltz_s16(v45));
      a7 = (int32x4_t)vbslq_s8((int8x16_t)a8, (int8x16_t)a9, (int8x16_t)v46);
      uint64_t v38 = (vaddvq_s32(a7) + v38);
      v20 -= 4;
    }
    while (v20 > 3);
  }
  return v38;
}

uint64_t png_write_filter_row_paeth_neon(unsigned char *a1, unsigned __int8 *a2, unsigned char *a3, uint64_t a4, double a5, double a6, int8x16_t a7, uint16x8_t a8, int8x16_t a9, int8x16_t a10)
{
  unsigned __int8 v10 = *a1 - *a3;
  int v11 = (char)v10;
  unsigned __int8 v12 = a1[1] - a3[1];
  int v13 = (char)v12;
  unsigned __int8 v14 = a1[2] - a3[2];
  int v15 = (char)v14;
  unsigned __int8 v16 = a1[3] - a3[3];
  int v17 = (char)v16;
  *a2 = v10;
  a2[1] = v12;
  a2[2] = v14;
  a2[3] = v16;
  int v18 = (int8x16_t *)(a2 + 4);
  int v19 = v10;
  int v20 = 256 - v10;
  if (v11 >= 0) {
    int v20 = v19;
  }
  int v21 = v12;
  int v22 = 256 - v12;
  if (v13 < 0) {
    int v21 = v22;
  }
  int v23 = v14;
  int v24 = 256 - v14;
  if (v15 >= 0) {
    int v24 = v23;
  }
  int v25 = v16;
  int v26 = 256 - v16;
  if (v17 >= 0) {
    int v26 = v25;
  }
  int v27 = v21 + v20;
  int v28 = v24 + v26;
  unint64_t v29 = a4 - 4;
  if ((unint64_t)(a4 - 4) < 0x20)
  {
    double v51 = (int8x16_t *)(a1 + 4);
    double v52 = (int8x16_t *)(a3 + 4);
    uint32x4_t v50 = 0uLL;
  }
  else
  {
    unint64_t v30 = 0;
    int32x4_t v31 = 0uLL;
    int32x4_t v32 = 0uLL;
    do
    {
      int8x16_t v33 = &v18[v30 / 0x10];
      int8x16_t v35 = *(int8x16_t *)&a1[v30];
      int8x16_t v34 = *(int8x16_t *)&a1[v30 + 16];
      int8x16_t v36 = *(int8x16_t *)&a3[v30 + 4];
      int8x16_t v37 = *(int8x16_t *)&a3[v30 + 20];
      int8x16_t v39 = *(int8x16_t *)&a3[v30];
      int8x16_t v38 = *(int8x16_t *)&a3[v30 + 16];
      uint16x8_t v40 = vabdq_u16(vaddl_u8(*(uint8x8_t *)v36.i8, *(uint8x8_t *)v35.i8), vshll_n_u8(*(uint8x8_t *)v39.i8, 1uLL));
      uint16x8_t v41 = vabdq_u16(vaddl_u8(*(uint8x8_t *)v37.i8, *(uint8x8_t *)v34.i8), vshll_n_u8(*(uint8x8_t *)v38.i8, 1uLL));
      uint8x8_t v42 = (uint8x8_t)vextq_s8(v39, v39, 8uLL).u64[0];
      uint16x8_t v43 = vabdq_u16(vaddl_high_u8((uint8x16_t)v36, (uint8x16_t)v35), vshll_high_n_u8((uint8x16_t)v39, 1uLL));
      uint8x8_t v44 = (uint8x8_t)vextq_s8(v38, v38, 8uLL).u64[0];
      *(int8x8_t *)v45.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v40, vabdl_u8(*(uint8x8_t *)v36.i8, *(uint8x8_t *)v39.i8))), (int8x8_t)vcge_u8(vabd_u8(*(uint8x8_t *)v35.i8, *(uint8x8_t *)v39.i8), vabd_u8(*(uint8x8_t *)v36.i8, *(uint8x8_t *)v39.i8)));
      *(int8x8_t *)v46.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v41, vabdl_u8(*(uint8x8_t *)v37.i8, *(uint8x8_t *)v38.i8))), (int8x8_t)vcge_u8(vabd_u8(*(uint8x8_t *)v34.i8, *(uint8x8_t *)v38.i8), vabd_u8(*(uint8x8_t *)v37.i8, *(uint8x8_t *)v38.i8)));
      uint16x8_t v47 = vabdq_u16(vaddl_high_u8((uint8x16_t)v37, (uint8x16_t)v34), vshll_high_n_u8((uint8x16_t)v38, 1uLL));
      v45.u64[1] = (unint64_t)vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v43, vabdl_high_u8((uint8x16_t)v36, (uint8x16_t)v39))), (int8x8_t)vcge_u8(vabd_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v35, v35, 8uLL), v42), vabd_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v36, v36, 8uLL), v42)));
      v46.u64[1] = (unint64_t)vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v47, vabdl_high_u8((uint8x16_t)v37, (uint8x16_t)v38))), (int8x8_t)vcge_u8(vabd_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v34, v34, 8uLL), v44), vabd_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v37, v37, 8uLL), v44)));
      a10 = vbslq_s8(v45, v35, vbslq_s8(vuzp1q_s8((int8x16_t)vcgeq_u16(v40, vabdl_u8(*(uint8x8_t *)v35.i8, *(uint8x8_t *)v39.i8)), (int8x16_t)vcgeq_u16(v43, vabdl_high_u8((uint8x16_t)v35, (uint8x16_t)v39))), v36, v39));
      a9 = vbslq_s8(v46, v34, vbslq_s8(vuzp1q_s8((int8x16_t)vcgeq_u16(v41, vabdl_u8(*(uint8x8_t *)v34.i8, *(uint8x8_t *)v38.i8)), (int8x16_t)vcgeq_u16(v47, vabdl_high_u8((uint8x16_t)v34, (uint8x16_t)v38))), v37, v38));
      int8x16_t v48 = vsubq_s8(*(int8x16_t *)&a1[v30 + 4], a10);
      int8x16_t v49 = vsubq_s8(*(int8x16_t *)&a1[v30 + 20], a9);
      int8x16_t *v33 = v48;
      v33[1] = v49;
      a7 = (int8x16_t)vpaddlq_u8((uint8x16_t)vabsq_s8(v48));
      a8 = vpaddlq_u8((uint8x16_t)vabsq_s8(v49));
      int32x4_t v31 = (int32x4_t)vpadalq_u16((uint32x4_t)v31, (uint16x8_t)a7);
      int32x4_t v32 = (int32x4_t)vpadalq_u16((uint32x4_t)v32, a8);
      v29 -= 32;
      v30 += 32;
    }
    while (v29 > 0x1F);
    uint32x4_t v50 = (uint32x4_t)vaddq_s32(v31, v32);
    a1 += v30;
    double v51 = (int8x16_t *)(a1 + 4);
    a3 += v30;
    double v52 = (int8x16_t *)(a3 + 4);
    int v18 = (int8x16_t *)((char *)v18 + v30);
  }
  int v53 = v27 + v28;
  if (v29 >= 0x10)
  {
    do
    {
      int8x16_t v54 = *(int8x16_t *)a1;
      a1 += 16;
      int8x16_t v55 = v54;
      int8x16_t v56 = *v52++;
      int8x16_t v57 = v56;
      uint8x16_t v58 = *(uint8x16_t *)a3;
      a3 += 16;
      a8 = (uint16x8_t)v58;
      uint16x8_t v59 = vabdq_u16(vaddl_u8(*(uint8x8_t *)v57.i8, *(uint8x8_t *)v55.i8), vshll_n_u8(*(uint8x8_t *)v58.i8, 1uLL));
      uint8x8_t v60 = (uint8x8_t)vextq_s8((int8x16_t)a8, (int8x16_t)a8, 8uLL).u64[0];
      *(int8x8_t *)a9.i8 = vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v59, vabdl_u8(*(uint8x8_t *)v57.i8, *(uint8x8_t *)v58.i8))), (int8x8_t)vcge_u8(vabd_u8(*(uint8x8_t *)v55.i8, *(uint8x8_t *)v58.i8), vabd_u8(*(uint8x8_t *)v57.i8, *(uint8x8_t *)v58.i8)));
      uint16x8_t v61 = vabdq_u16(vaddl_high_u8((uint8x16_t)v57, (uint8x16_t)v55), vshll_high_n_u8(v58, 1uLL));
      a9.u64[1] = (unint64_t)vand_s8(vmovn_s16((int16x8_t)vcgeq_u16(v61, vabdl_high_u8((uint8x16_t)v57, v58))), (int8x8_t)vcge_u8(vabd_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v55, v55, 8uLL), v60), vabd_u8((uint8x8_t)*(_OWORD *)&vextq_s8(v57, v57, 8uLL), v60)));
      int8x16_t v62 = (int8x16_t)vcgeq_u16(v59, vabdl_u8(*(uint8x8_t *)v55.i8, *(uint8x8_t *)v58.i8));
      int8x16_t v63 = (int8x16_t)vcgeq_u16(v61, vabdl_high_u8((uint8x16_t)v55, v58));
      int8x16_t v64 = *v51++;
      a10 = vuzp1q_s8(v62, v63);
      a7 = vbslq_s8(a10, v57, (int8x16_t)a8);
      int8x16_t v65 = vsubq_s8(v64, vbslq_s8(a9, v55, a7));
      *v18++ = v65;
      uint32x4_t v50 = vpadalq_u16(v50, vpaddlq_u8((uint8x16_t)vabsq_s8(v65)));
      v29 -= 16;
    }
    while (v29 > 0xF);
  }
  uint64_t v66 = v53 + vpadalq_u32((uint64x2_t)vdupq_laneq_s64((int64x2_t)vpaddlq_u32(v50), 1), v50).u32[0];
  if (v29 >= 4)
  {
    v67.i64[0] = 0xFF000000FFLL;
    v67.i64[1] = 0xFF000000FFLL;
    v68.i64[0] = 0x10000000100;
    v68.i64[1] = 0x10000000100;
    do
    {
      unsigned __int32 v69 = v51->i32[0];
      double v51 = (int8x16_t *)((char *)v51 + 4);
      a7.i32[0] = v69;
      unsigned __int32 v70 = *(_DWORD *)a1;
      a1 += 4;
      a8.i32[0] = v70;
      unsigned __int32 v71 = v52->i32[0];
      double v52 = (int8x16_t *)((char *)v52 + 4);
      a9.i32[0] = v71;
      unsigned __int32 v72 = *(_DWORD *)a3;
      a3 += 4;
      a10.i32[0] = v72;
      int8x8_t v73 = (int8x8_t)vmovl_u8(*(uint8x8_t *)a8.i8).u64[0];
      int8x8_t v74 = (int8x8_t)vmovl_u8(*(uint8x8_t *)a9.i8).u64[0];
      int8x8_t v75 = (int8x8_t)vmovl_u8(*(uint8x8_t *)a10.i8).u64[0];
      uint32x4_t v76 = vmovl_u16((uint16x4_t)v75);
      uint32x4_t v77 = vabdq_u32(vmovl_u16((uint16x4_t)v74), v76);
      uint32x4_t v78 = vabdq_u32(vmovl_u16((uint16x4_t)v73), v76);
      uint32x4_t v79 = (uint32x4_t)vabsq_s32(vaddq_s32((int32x4_t)vsubl_u16((uint16x4_t)v74, (uint16x4_t)v75), (int32x4_t)vsubl_u16((uint16x4_t)v73, (uint16x4_t)v75)));
      int16x8_t v80 = (int16x8_t)vmovl_u8(*(uint8x8_t *)a7.i8);
      *(int16x4_t *)v80.i8 = vsub_s16(*(int16x4_t *)v80.i8, (int16x4_t)vbsl_s8((int8x8_t)vmovn_s32((int32x4_t)vcgtq_u32(v77, vminq_u32(v78, v79))), vbsl_s8((int8x8_t)vmovn_s32((int32x4_t)vcgtq_u32(v78, v79)), v75, v74), v73));
      *(int8x8_t *)a8.i8 = vmovn_s16(v80);
      int16x4_t v81 = vshr_n_s16(vshl_n_s16(*(int16x4_t *)v80.i8, 8uLL), 8uLL);
      int32x4_t v82 = (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v80.i8), v67);
      a10 = (int8x16_t)vsubq_s32(v68, v82);
      a9 = (int8x16_t)vmovl_s16(vcltz_s16(v81));
      v18->i32[0] = a8.i32[0];
      int v18 = (int8x16_t *)((char *)v18 + 4);
      a7 = vbslq_s8(a9, a10, (int8x16_t)v82);
      uint64_t v66 = (vaddvq_s32((int32x4_t)a7) + v66);
      v29 -= 4;
    }
    while (v29 > 3);
  }
  return v66;
}

void IIO_LoadJPEGSymbols()
{
  if (gLoadCoreVideoSymbolsInitOnce != -1) {
    dispatch_once(&gLoadCoreVideoSymbolsInitOnce, &__block_literal_global_39);
  }
}

void IIO_LoadCoreMediaSymbols()
{
  if (gLoadCoreMediaSymbolsInitOnce != -1) {
    dispatch_once(&gLoadCoreMediaSymbolsInitOnce, &__block_literal_global_19);
  }
}

OSStatus CGAnimateImageAtURLWithBlock(CFURLRef url, CFDictionaryRef options, CGImageSourceAnimationBlock block)
{
  kdebug_trace();
  IIOInitDebugFlags();
  unsigned int v5 = (gIIODebugFlags >> 12) & 3;
  if (v5) {
    ImageIODebugOptions(v5, "A", "CGAnimateImageAtURLWithBlock", url, 0, -1, 0);
  }
  if (url)
  {
    CFTypeID v6 = CFGetTypeID(url);
    if (v6 == CFURLGetTypeID())
    {
      if (options)
      {
        CFTypeID v7 = CFGetTypeID(options);
        if (v7 != CFDictionaryGetTypeID())
        {
          LogError("CGAnimateImageAtURLWithBlock", 127, "*** ERROR: CGAnimateImageAtURLWithBlock: options parameter is not a CFDictionaryRef - ignoring\n");
          CFDictionaryRef options = 0;
        }
      }
      memset(v9, 0, sizeof(v9));
      IIODictionary::IIODictionary((IIODictionary *)v9, options);
      operator new();
    }
    LogError("CGAnimateImageAtURLWithBlock", 124, "*** ERROR: CGAnimateImageAtURLWithBlock: url is not a CFURLRef\n");
  }
  else
  {
    LogError("CGAnimateImageAtURLWithBlock", 123, "*** ERROR: CGAnimateImageAtURLWithBlock: url is nil\n");
  }
  kdebug_trace();
  return -50;
}

void sub_1887D6A60(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MEMORY[0x18C11C0E0](v2, 0x10E1C40A1B1CD90);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1887D69F4);
}

OSStatus CGAnimateImageDataWithBlock(CFDataRef data, CFDictionaryRef options, CGImageSourceAnimationBlock block)
{
  kdebug_trace();
  IIOInitDebugFlags();
  unsigned int v5 = (gIIODebugFlags >> 12) & 3;
  if (v5) {
    ImageIODebugOptions(v5, "A", "CGAnimateImageDataWithBlock", data, 0, -1, 0);
  }
  if (data)
  {
    CFTypeID v6 = CFGetTypeID(data);
    if (v6 == CFDataGetTypeID())
    {
      if (options)
      {
        CFTypeID v7 = CFGetTypeID(options);
        if (v7 != CFDictionaryGetTypeID())
        {
          LogError("CGAnimateImageDataWithBlock", 181, "*** ERROR: CGImageSourceCreateWithData: options parameter is not a CFDictionaryRef - ignoring\n");
          CFDictionaryRef options = 0;
        }
      }
      memset(v9, 0, sizeof(v9));
      IIODictionary::IIODictionary((IIODictionary *)v9, options);
      operator new();
    }
    LogError("CGAnimateImageDataWithBlock", 178, "*** ERROR: CGImageSourceCreateWithData: data is not a CFDataRef\n");
  }
  else
  {
    LogError("CGAnimateImageDataWithBlock", 177, "*** ERROR: CGImageSourceCreateWithData: data is nil\n");
  }
  kdebug_trace();
  return -50;
}

void sub_1887D6C84(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MEMORY[0x18C11C0E0](v2, 0x10E1C40A1B1CD90);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1887D6C18);
}

uint64_t IIODecodeParameter::saveDataToXPCObject(IIODecodeParameter *this, void *a2)
{
  xpc_object_t v4 = iio_xpc_add_source_dict(a2);
  xpc_object_t v5 = iio_xpc_add_callback_dict(a2);
  iio_xpc_dictionary_addCGRect(v5, "iio_xpc_cb_blockset_cgrect", *((double *)this + 3), *((double *)this + 4), *((double *)this + 5), *((double *)this + 6));
  iio_xpc_dictionary_addCGSize(v5, "iio_xpc_cb_blockset_dest_cgsize", *((double *)this + 7), *((double *)this + 8));
  xpc_dictionary_set_uint64(v4, "iio_xpc_src_image_index", *((void *)this + 9));
  iio_xpc_dictionary_add_CFDictionary(v5, "iio_xpc_cb_blockset_options");
  return 0;
}

void IIO_Writer_TGA::~IIO_Writer_TGA(IIO_Writer_TGA *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIO_Writer_TGA::write(IIO_Writer_TGA *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  TGAWritePlugin::TGAWritePlugin((TGAWritePlugin *)v5, a2, a3);
  uint64_t v3 = IIOWritePlugin::writeAll((IIOImageDestination **)v5);
  TGAWritePlugin::~TGAWritePlugin((TGAWritePlugin *)v5);
  return v3;
}

void sub_1887D6E34(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t _cg_TIFFComputeTile(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5)
{
  unsigned int v5 = *(_DWORD *)(a1 + 100);
  unsigned int v6 = *(_DWORD *)(a1 + 104);
  unsigned int v7 = *(_DWORD *)(a1 + 96);
  if (v7 == 1) {
    unsigned int v8 = 0;
  }
  else {
    unsigned int v8 = a4;
  }
  if (v5 == -1) {
    unsigned int v5 = *(_DWORD *)(a1 + 88);
  }
  if (v6 == -1) {
    unsigned int v6 = *(_DWORD *)(a1 + 92);
  }
  if (*(_DWORD *)(a1 + 108) == -1) {
    unsigned int v9 = *(_DWORD *)(a1 + 96);
  }
  else {
    unsigned int v9 = *(_DWORD *)(a1 + 108);
  }
  if (v5) {
    BOOL v10 = v6 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10 || v9 == 0) {
    return 1;
  }
  unsigned int v13 = 0;
  unsigned int v14 = *(_DWORD *)(a1 + 88);
  if (v14 < -v5) {
    unsigned int v13 = (v5 + v14 - 1) / v5;
  }
  unsigned int v15 = 0;
  unsigned int v16 = *(_DWORD *)(a1 + 92);
  if (v16 < -v6) {
    unsigned int v15 = (v6 + v16 - 1) / v6;
  }
  unsigned int v17 = 0;
  if (v7 < -v9) {
    unsigned int v17 = (v7 + v9 - 1) / v9;
  }
  int v18 = v8 / v9;
  int v19 = a3 / v6;
  if (*(_WORD *)(a1 + 170) == 2) {
    v18 += v17 * a5;
  }
  return a2 / v5 + (v19 + v18 * v15) * v13;
}

uint64_t TIFFCheckTile(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 88) <= a2)
  {
    TIFFErrorExtR(a1, *(const char **)a1, "%lu: Col out of range, max %lu", a4, a5, a6, a7, a8, a2);
  }
  else if (*(_DWORD *)(a1 + 92) <= a3)
  {
    TIFFErrorExtR(a1, *(const char **)a1, "%lu: Row out of range, max %lu", a4, a5, a6, a7, a8, a3);
  }
  else if (*(_DWORD *)(a1 + 96) <= a4)
  {
    TIFFErrorExtR(a1, *(const char **)a1, "%lu: Depth out of range, max %lu", a4, a5, a6, a7, a8, a4);
  }
  else
  {
    if (*(_WORD *)(a1 + 170) != 2 || *(unsigned __int16 *)(a1 + 130) > a5) {
      return 1;
    }
    TIFFErrorExtR(a1, *(const char **)a1, "%lu: Sample out of range, max %lu", a4, a5, a6, a7, a8, a5);
  }
  return 0;
}

uint64_t _cg_TIFFNumberOfTiles(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10 = *(_DWORD *)(a1 + 100);
  unsigned int v9 = *(_DWORD *)(a1 + 104);
  if (v10 == -1) {
    unsigned int v10 = *(_DWORD *)(a1 + 88);
  }
  unsigned int v11 = *(_DWORD *)(a1 + 108);
  if (v9 == -1) {
    unsigned int v9 = *(_DWORD *)(a1 + 92);
  }
  if (v11 == -1) {
    unsigned int v11 = *(_DWORD *)(a1 + 96);
  }
  uint64_t v12 = 0;
  if (v10 && v9 && v11)
  {
    unsigned int v13 = 0;
    unsigned int v14 = *(_DWORD *)(a1 + 88);
    if (v14 < -v10) {
      unsigned int v13 = (v10 + v14 - 1) / v10;
    }
    unsigned int v15 = 0;
    unsigned int v16 = *(_DWORD *)(a1 + 92);
    if (v16 < -v9) {
      unsigned int v15 = (v9 + v16 - 1) / v9;
    }
    unsigned int v17 = _TIFFMultiply32(a1, v13, v15, "TIFFNumberOfTiles", a5, a6, a7, a8);
    unsigned int v22 = 0;
    unsigned int v23 = *(_DWORD *)(a1 + 96);
    if (v23 < -v11) {
      unsigned int v22 = (v11 + v23 - 1) / v11;
    }
    uint64_t v12 = _TIFFMultiply32(a1, v17, v22, "TIFFNumberOfTiles", v18, v19, v20, v21);
  }
  if (*(_WORD *)(a1 + 170) != 2) {
    return v12;
  }
  unsigned int v24 = *(unsigned __int16 *)(a1 + 130);

  return _TIFFMultiply32(a1, v12, v24, "TIFFNumberOfTiles", a5, a6, a7, a8);
}

uint64_t _cg_TIFFTileRowSize64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)(a1 + 104))
  {
    uint64_t v12 = "Tile length is zero";
    goto LABEL_14;
  }
  unint64_t v9 = *(unsigned int *)(a1 + 100);
  if (!v9)
  {
    uint64_t v12 = "Tile width is zero";
    goto LABEL_14;
  }
  unint64_t v10 = _TIFFMultiply64(a1, *(unsigned __int16 *)(a1 + 116), v9, "TIFFTileRowSize", a5, a6, a7, a8);
  if (*(_WORD *)(a1 + 170) == 1)
  {
    if (!*(_WORD *)(a1 + 130))
    {
      uint64_t v12 = "Samples per pixel is zero";
      goto LABEL_14;
    }
    unint64_t v10 = _TIFFMultiply64(a1, v10, *(unsigned __int16 *)(a1 + 130), "TIFFTileRowSize", a5, a6, a7, a8);
  }
  if ((v10 & 7) != 0) {
    uint64_t result = (v10 >> 3) + 1;
  }
  else {
    uint64_t result = v10 >> 3;
  }
  if (!result)
  {
    uint64_t v12 = "Computed tile row size is zero";
LABEL_14:
    TIFFErrorExtR(a1, "TIFFTileRowSize64", v12, a4, a5, a6, a7, a8, v13);
    return 0;
  }
  return result;
}

uint64_t _cg_TIFFTileRowSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = _cg_TIFFTileRowSize64(a1, a2, a3, a4, a5, a6, a7, a8);

  return _TIFFCastUInt64ToSSize(a1, v9, "TIFFTileRowSize", v10, v11, v12, v13, v14);
}

unint64_t TIFFVTileSize64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)(a1 + 104) || !*(_DWORD *)(a1 + 100) || !*(_DWORD *)(a1 + 108)) {
    return 0;
  }
  unsigned int v9 = a2;
  if (*(_WORD *)(a1 + 170) == 1
    && *(_WORD *)(a1 + 122) == 6
    && *(_WORD *)(a1 + 130) == 3
    && (*(unsigned char *)(a1 + 17) & 0x40) == 0)
  {
    int v41 = 0;
    _cg_TIFFGetFieldDefaulted(a1, 530, a3, a4, a5, a6, a7, a8, &v41);
    if ((unsigned __int16)v41 <= 4u
      && ((1 << v41) & 0x16) != 0
      && HIWORD(v41) <= 4u
      && ((1 << SBYTE2(v41)) & 0x16) != 0)
    {
      unsigned int v15 = *(_DWORD *)(a1 + 100);
      if (v15 >= -(unsigned __int16)v41) {
        unint64_t v16 = 0;
      }
      else {
        unint64_t v16 = ((unsigned __int16)v41 + v15 - 1) / (unsigned __int16)v41;
      }
      if (-HIWORD(v41) > v9) {
        unint64_t v24 = (v9 + HIWORD(v41) - 1) / HIWORD(v41);
      }
      else {
        unint64_t v24 = 0;
      }
      unint64_t v25 = _TIFFMultiply64(a1, v16, (unsigned __int16)(HIWORD(v41) * v41 + 2), "TIFFVTileSize64", v11, v12, v13, v14);
      char v30 = _TIFFMultiply64(a1, v25, *(unsigned __int16 *)(a1 + 116), "TIFFVTileSize64", v26, v27, v28, v29);
      unint64_t v35 = _TIFFMultiply64(a1, v25, *(unsigned __int16 *)(a1 + 116), "TIFFVTileSize64", v31, v32, v33, v34);
      if ((v30 & 7) != 0) {
        unint64_t v40 = (v35 >> 3) + 1;
      }
      else {
        unint64_t v40 = v35 >> 3;
      }
      return _TIFFMultiply64(a1, v40, v24, "TIFFVTileSize64", v36, v37, v38, v39);
    }
    TIFFErrorExtR(a1, "TIFFVTileSize64", "Invalid YCbCr subsampling (%dx%d)", v10, v11, v12, v13, v14, v41);
    return 0;
  }
  unsigned int v17 = a2;
  unint64_t v18 = _cg_TIFFTileRowSize64(a1, a2, a3, a4, a5, a6, a7, a8);

  return _TIFFMultiply64(a1, v17, v18, "TIFFVTileSize64", v19, v20, v21, v22);
}

unint64_t _cg_TIFFTileSize64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return TIFFVTileSize64(a1, *(unsigned int *)(a1 + 104), a3, a4, a5, a6, a7, a8);
}

uint64_t _cg_TIFFTileSize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = TIFFVTileSize64(a1, *(unsigned int *)(a1 + 104), a3, a4, a5, a6, a7, a8);

  return _TIFFCastUInt64ToSSize(a1, v9, "TIFFTileSize", v10, v11, v12, v13, v14);
}

void _TIFFDefaultTileSize(uint64_t a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = *a2;
  if ((int)*a2 <= 0)
  {
    unsigned int v3 = 256;
    *a2 = 256;
  }
  unsigned int v4 = *a3;
  if ((int)*a3 <= 0)
  {
    unsigned int v4 = 256;
    *a3 = 256;
    unsigned int v3 = *a2;
  }
  if ((v3 & 0xF) != 0)
  {
    if (v3 >= 0xFFFFFFF0) {
      unsigned int v5 = 0;
    }
    else {
      unsigned int v5 = (v3 + 15) & 0xFFFFFFF0;
    }
    *a2 = v5;
    unsigned int v4 = *a3;
  }
  if ((v4 & 0xF) != 0)
  {
    unsigned int v6 = (v4 + 15) & 0xFFFFFFF0;
    if (v4 >= 0xFFFFFFF0) {
      unsigned int v6 = 0;
    }
    *a3 = v6;
  }
}

void EXRWritePlugin::EXRWritePlugin(EXRWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  IIOWritePlugin::IIOWritePlugin(this, a2, a3, 1163416096);
  *unsigned int v4 = &unk_1ED4E10B8;
  AppleEXREnabled();
  *((void *)this + 5) = 0;
}

void sub_1887D7530(_Unwind_Exception *a1, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(v3, a2, a3);
  _Unwind_Resume(a1);
}

void EXRWritePlugin::~EXRWritePlugin(EXRWritePlugin *this, uint64_t a2, const char *a3)
{
  *(void *)this = &unk_1ED4E10B8;
  unsigned int v4 = (void *)*((void *)this + 5);
  if (v4) {
    os_release(v4);
  }

  _cg_jpeg_mem_term(this, a2, a3);
}

{
  uint64_t vars8;

  EXRWritePlugin::~EXRWritePlugin(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t EXRWritePlugin::writeOneImage(EXRWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t EXRWritePlugin::writeOne(EXRWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t EXRWritePlugin::writeAll(IIOImageDestination **this)
{
  unsigned int ImageCount = IIOWritePlugin::getImageCount(this);
  uint64_t v3 = gFunc_axr_encoder_create(0);
  this[5] = (IIOImageDestination *)v3;
  if (ImageCount)
  {
    IIOWritePlugin::getSourceImageAtIndex(this, 0);
    IIOWritePlugin::getPropertiesAtIndex(this, 0);
    operator new();
  }
  return gFunc_axr_encoder_compress(v3, this, EXRWritePlugin::WriteCallback, 0, EXRWritePlugin::DestroyCallback, 0);
}

void sub_1887D76E4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C40C0714077);
  _Unwind_Resume(a1);
}

size_t EXRWritePlugin::WriteCallback(IIOImageWriteSession **this, void *a2, const unsigned __int8 *a3)
{
  return IIOImageWriteSession::putBytes(this[2], a2, (size_t)a3);
}

uint64_t EXRWritePlugin::WriteProc(EXRWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  if (!AppleEXREnabled()) {
    return 4294967246;
  }
  memset(v11, 0, sizeof(v11));
  EXRWritePlugin::EXRWritePlugin((EXRWritePlugin *)v11, this, a2);
  uint64_t v7 = EXRWritePlugin::writeAll((IIOImageDestination **)v11);
  EXRWritePlugin::~EXRWritePlugin((EXRWritePlugin *)v11, v8, v9);
  return v7;
}

void EXRWritePluginInput::EXRWritePluginInput(EXRWritePluginInput *this, axr_encoder *a2, CGImageRef image, IIODictionary *a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1ED4E4B88;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = image;
  *((void *)this + 3) = a4;
  long long v37 = 0uLL;
  long long v35 = 0u;
  long long v36 = 0u;
  CGColorSpaceRef ColorSpace = CGImageGetColorSpace(image);
  int HasRealAlphaChannel = _ImageHasRealAlphaChannel(image);
  *((void *)this + 12) = 0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 27) = 0;
  if ((CGImageGetBitmapInfo(image) & 0x100) != 0) {
    unint64_t v9 = 16;
  }
  else {
    unint64_t v9 = 10;
  }
  size_t BitsPerComponent = CGImageGetBitsPerComponent(image);
  if (BitsPerComponent <= v9) {
    int v11 = 1;
  }
  else {
    int v11 = 2;
  }
  *((_DWORD *)this + 26) = v11;
  if (BitsPerComponent <= v9) {
    int v12 = 16;
  }
  else {
    int v12 = 32;
  }
  *((_DWORD *)this + 28) = v12;
  while (1)
  {
    CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
    if (Model != kCGColorSpaceModelIndexed) {
      break;
    }
    CGColorSpaceRef ColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
  }
  switch(Model)
  {
    case kCGColorSpaceModelMonochrome:
      uint64_t v14 = 0;
      uint64_t v15 = 1;
      if (HasRealAlphaChannel) {
        int v16 = 2;
      }
      else {
        int v16 = 1;
      }
      *((_DWORD *)this + 27) = v16;
      if (HasRealAlphaChannel) {
        int v17 = 4;
      }
      else {
        int v17 = -1;
      }
      LODWORD(v37) = 10;
      DWORD1(v37) = v17;
      *((void *)&v37 + 1) = -1;
      *(void *)&long long v35 = "Y";
      goto LABEL_24;
    case kCGColorSpaceModelRGB:
    case kCGColorSpaceModelCMYK:
      *((_DWORD *)this + 27) = 4;
      long long v37 = xmmword_1889AB340;
      *(void *)&long long v35 = "R";
      *((void *)&v35 + 1) = "G";
      *(void *)&long long v36 = "B";
      uint64_t v14 = 1;
      goto LABEL_23;
    case kCGColorSpaceModelXYZ:
      *((_DWORD *)this + 27) = 4;
      long long v37 = xmmword_1889AD580;
      *(void *)&long long v35 = "X";
      *((void *)&v35 + 1) = "Y";
      *(void *)&long long v36 = "Z";
      uint64_t v14 = 7;
LABEL_23:
      uint64_t v15 = 3;
LABEL_24:
      *((void *)&v35 + v15) = "A";
      unint64_t v18 = (IIODictionary *)*((void *)this + 3);
      if (!v18) {
        goto LABEL_32;
      }
      unsigned int v19 = IIODictionary::containsKey(v18, @"Compression");
      uint64_t v20 = (IIODictionary *)*((void *)this + 3);
      if (v19)
      {
        unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(v20, @"Compression");
      }
      else
      {
        if (!IIODictionary::containsKeyGroup(v20, @"Compression", @"{EXR}"))
        {
LABEL_32:
          uint64_t v22 = 4;
          goto LABEL_33;
        }
        unsigned int Uint32ForKey = IIODictionary::getUint32ForKeyGroup(*((IIODictionary **)this + 3), @"Compression", @"{EXR}");
      }
      if (Uint32ForKey <= 7) {
        uint64_t v22 = Uint32ForKey;
      }
      else {
        uint64_t v22 = 4;
      }
LABEL_33:
      int Width = CGImageGetWidth(image);
      size_t Height = CGImageGetHeight(image);
      uint64_t appended = gFunc_axr_encoder_append_part(a2, "part name", 0, v22, (unint64_t)(Width - 1) << 32, (Height << 32) - 0x100000000, (unint64_t)(Width - 1) << 32, (Height << 32) - 0x100000000, 1.0, (float)(Width - 1) * 0.5, (float)(int)(((Height << 32) - 0x100000000) >> 32) * 0.5, (float)Width, 72.0, 0, 0);
      if (appended)
      {
        uint64_t v26 = appended;
        CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(*((IIODictionary **)this + 3), @"Chromaticities", @"{EXR}");
        memset(v32, 0, sizeof(v32));
        IIOArray::IIOArray((IIOArray *)v32, ObjectForKeyGroup);
        if (IIOArray::getCount((IIOArray *)v32) == 8)
        {
          uint64_t v28 = 0;
          CFIndex v29 = 0;
          v34[0] = 0;
          v34[1] = 0;
          v33[0] = 0;
          v33[1] = 0;
          do
          {
            *(float *)((char *)v34 + v28) = IIOArray::getFloatAtIndex((IIOArray *)v32, v29);
            CFIndex v30 = v29 + 1;
            *(float *)((char *)v33 + v28) = IIOArray::getFloatAtIndex((IIOArray *)v32, v30);
            v28 += 4;
            CFIndex v29 = v30 + 1;
          }
          while (v28 != 16);
          gFunc_axr_part_set_chromaticities(v26, v14, v34, v33, 1.0);
        }
        else
        {
          gFunc_axr_part_set_chromaticities(v26, v14, 0, 0, 1.0);
        }
        IIOArray::~IIOArray((IIOArray *)v32);
        *((void *)this + 17) = gFunc_axr_part_create_colorspace(v26, 2, 0);
        gFunc_axr_part_append_channels(v26, 0, *((unsigned int *)this + 26), 1, 1, 0, &v37, &v35, *((unsigned int *)this + 27), EXRWritePluginInput::ReadCallback, EXRWritePluginInput::ReleaseCallback, this);
      }
      return;
    default:
      uint64_t v31 = IIO_ColorModelString(Model);
      LogError("EXRWritePluginInput", 112, "*** colorspaceModel '%s' not handled\n", v31);
      return;
  }
}

void sub_1887D7C24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

uint64_t EXRWritePluginInput::ReadCallback(const CGFloat *this, unint64_t a2, unint64_t a3, axr_size_t a4, EXRWritePluginInput *a5)
{
  axr_size_t v10 = a4;
  return EXRWritePluginInput::readCB(a5, this, a2, a3, v10);
}

uint64_t EXRWritePluginInput::ReleaseCallback(uint64_t this)
{
  if (this) {
    return (*(uint64_t (**)(void))(*(void *)this + 8))();
  }
  return this;
}

void EXRWritePluginInput::~EXRWritePluginInput(EXRWritePluginInput *this)
{
  EXRWritePluginInput::~EXRWritePluginInput(this);

  JUMPOUT(0x18C11C0E0);
}

{
  uint64_t v2;
  CGColorSpace *v3;

  *(void *)this = &unk_1ED4E4B88;
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (CGColorSpace *)*((void *)this + 17);
  if (v3) {
    CGColorSpaceRelease(v3);
  }
}

uint64_t EXRWritePluginInput::readCB(EXRWritePluginInput *this, const CGFloat *a2, unint64_t a3, unint64_t a4, axr_size_t a5)
{
  uint64_t v5 = a3;
  uint64_t v8 = (IIOPixelProvider *)*((void *)this + 4);
  if (!v8)
  {
    uint32_t v11 = *((_DWORD *)this + 27) * *((_DWORD *)this + 28);
    v19.bitsPerComponent = *((_DWORD *)this + 28);
    v19.bitsPerPixel = v11;
    v19.colorSpace = (CGColorSpaceRef)*((void *)this + 17);
    memset(&v19.bitmapInfo, 0, 24);
    if (CGColorSpaceGetModel(v19.colorSpace) || (CGImageHasAlpha() & 1) != 0)
    {
      BOOL v12 = *((_DWORD *)this + 28) == 32;
      CGBitmapInfo v13 = 4355;
      int v14 = 8451;
    }
    else
    {
      BOOL v12 = *((_DWORD *)this + 28) == 32;
      CGBitmapInfo v13 = 4352;
      int v14 = 8448;
    }
    if (v12) {
      CGBitmapInfo v13 = v14;
    }
    v19.bitmapInfo = v13;
    *(_OWORD *)&v19.version = 0uLL;
    operator new();
  }
  unint64_t v10 = *((void *)this + 10);
  uint64_t v9 = *((void *)this + 11);
  unint64_t v15 = a3 / v10;
  *(void *)&v19.bitsPerComponent = 0;
  v19.colorSpace = (CGColorSpaceRef)&v19;
  *(void *)&v19.bitmapInfo = 0x2000000000;
  v19.decode = a2;
  if (v9 + a3 / v10 >= *((void *)this + 9)) {
    uint64_t v16 = *((void *)this + 9);
  }
  else {
    LODWORD(v16) = v9 + v15;
  }
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 0x40000000;
  v18[2] = ___ZN19EXRWritePluginInput6readCBEPvmm10axr_size_t_block_invoke;
  void v18[3] = &unk_1E53C0318;
  UInt8 v18[4] = &v19;
  if (IIOPixelProvider::iterateOverImage(v8, v9, v16, v15, (uint64_t)v18)) {
    uint64_t v5 = -12;
  }
  else {
    *((void *)this + 11) += v15;
  }
  _Block_object_dispose(&v19, 8);
  return v5;
}

void sub_1887D7E98(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C405C07969BLL);
  _Unwind_Resume(a1);
}

void *___ZN19EXRWritePluginInput6readCBEPvmm10axr_size_t_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = memcpy(*(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24), *(const void **)a3, *(void *)(a3 + 8) * *(void *)(a3 + 24));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += *(void *)(a3 + 24);
  return result;
}

void IIO_Reader_BC::createReadPlugin()
{
}

{
  operator new();
}

void sub_1887D800C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409569C651);
  _Unwind_Resume(a1);
}

void sub_1887D80AC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C409569C651);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_BC::getImageCount(IIO_Reader_BC *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  if (a5) {
    *a5 = 1;
  }
  return 0;
}

uint64_t IIO_Reader_BC::updateSourceProperties(IIO_Reader_BC *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  return 0;
}

uint64_t _cg_png_set_zstream_owner(uint64_t result, int a2)
{
  *(_DWORD *)(result + 92) = a2;
  return result;
}

void _cg_png_reset_write(void **a1)
{
  a1[40] = 0;
  a1[42] = 0;
  a1[43] = 0;
}

uint64_t png_read_filter_row_paeth4_apple(uint64_t result, uint64_t a2, uint64_t a3, uint16x4_t a4, double a5, uint8x8_t a6, double a7, uint32x4_t a8)
{
  uint64_t v8 = 0;
  uint64_t v9 = *(void *)(result + 8);
  do
  {
    __int16 v10 = *(unsigned __int8 *)(a2 + v8);
    __int16 v11 = *(unsigned __int8 *)(a3 + v8) + v10;
    *(unsigned char *)(a2 + v8) = *(unsigned char *)(a3 + v8) + v10;
    ++v8;
  }
  while (v8 != 4);
  if ((int)v9 >= 5)
  {
    uint64_t v12 = 0;
    a4.i8[0] = *(unsigned char *)(a2 + v8 - 4);
    a4.i8[4] = *(unsigned char *)(a2 + v8 - 3);
    a4.i16[1] = a4.i16[2];
    a4.i8[4] = *(unsigned char *)(a2 + v8 - 2);
    a4.i16[3] = v11;
    int8x16_t v13 = (int8x16_t)vmovl_u16(a4);
    v14.i64[0] = 0xFF000000FFLL;
    v14.i64[1] = 0xFF000000FFLL;
    int32x4_t v15 = (int32x4_t)vandq_s8(v13, v14);
    a6.i32[0] = *(_DWORD *)(a3 + v8 - 4);
    int32x4_t v16 = (int32x4_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a6));
    do
    {
      a8.i32[0] = *(_DWORD *)(a3 + v12 + v8);
      a8 = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)a8.i8));
      uint32x4_t v17 = (uint32x4_t)vabdq_s32((int32x4_t)a8, v16);
      uint32x4_t v18 = (uint32x4_t)vabdq_s32(v15, v16);
      uint32x4_t v19 = (uint32x4_t)vbslq_s8((int8x16_t)vcgtq_u32(vminq_u32(v18, v17), (uint32x4_t)vabsq_s32(vaddq_s32(vsubq_s32((int32x4_t)a8, v16), vsubq_s32(v15, v16)))), (int8x16_t)v16, vbslq_s8((int8x16_t)vcgtq_u32(v17, v18), (int8x16_t)a8, (int8x16_t)v15));
      v16.i32[0] = *(_DWORD *)(a2 + v12 + v8);
      int16x8_t v20 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v16.i8);
      int32x4_t v21 = (int32x4_t)vaddw_u16(v19, *(uint16x4_t *)v20.i8);
      *(int16x4_t *)v20.i8 = vmovn_s32(v21);
      *(_DWORD *)(a2 + v12 + v8) = vmovn_s16(v20).u32[0];
      int32x4_t v15 = (int32x4_t)vandq_s8((int8x16_t)v21, v14);
      v12 += 4;
      int32x4_t v16 = (int32x4_t)a8;
    }
    while ((int)v12 + 4 < (int)v9);
  }
  return result;
}

uint64_t CGImageCreateDataFromMetadata(const __CFDictionary *a1, uint64_t a2, CGImage *a3, CFDataRef *a4, CFDataRef *a5, CFDataRef *a6, const __CFDictionary *a7)
{
  if (a2)
  {
    CFDictionaryRef v13 = *(const __CFDictionary **)(a2 + 24);
    if (v13) {
      CFDictionaryGetCount(v13);
    }
  }
  int v41 = a5;
  kdebug_trace();
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImageCreateDataFromMetadata", 0, 0, -1, 0);
  }
  memset(v43, 0, sizeof(v43));
  IIODictionary::IIODictionary((IIODictionary *)v43, a1, 1);
  unint64_t v40 = a6;
  if (IIODictionary::containsKeyGroup((IIODictionary *)v43, @"{ExifAux}", @"{Exif}"))
  {
    CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup((IIODictionary *)v43, @"{ExifAux}", @"{Exif}");
    IIODictionary::setObjectForKey((IIODictionary *)v43, ObjectForKeyGroup, @"{ExifAux}");
    IIODictionary::removeObjectForKeyGroup((IIODictionary *)v43, @"{ExifAux}", @"{Exif}");
  }
  CFDictionaryRef v15 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v43, @"Caption/Abstract", @"{IPTC}");
  CFDictionaryRef v16 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v43, @"ImageDescription", @"{TIFF}");
  if (v16)
  {
    if (!v15 || CFEqual(v15, v16)) {
      goto LABEL_15;
    }
  }
  else if (!v15)
  {
    goto LABEL_15;
  }
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID == CFGetTypeID(v15)) {
    IIODictionary::setObjectForKeyGroup((IIODictionary *)v43, v15, @"ImageDescription", @"{TIFF}");
  }
LABEL_15:
  uint32x4_t v18 = (const CGImageMetadata *)CGImageMetadataCreateFromLegacyProps((IIODictionary *)v43);
  CGImageMetadataMerge((uint64_t)v18, a2, 0);
  if (!a4) {
    goto LABEL_48;
  }
  uint64_t v46 = 0;
  size_t __n = 0;
  size_t v44 = 0;
  uint64_t v45 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v44, a7);
  if (IIODictionary::containsKey((IIODictionary *)&v44, @"kCGDataFromMetadataAddExifApp1Marker")) {
    BOOL BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)&v44, @"kCGDataFromMetadataAddExifApp1Marker");
  }
  else {
    BOOL BoolForKey = 0;
  }
  if (IIODictionary::containsKey((IIODictionary *)v43, "{ExifThumbnail}"))
  {
    CFDictionaryRef v19 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v43, "JPEGThumbnailData", "{ExifThumbnail}");
    CFDataRef JPEGDataFromImage = v19;
    if (v19) {
      CFRetain(v19);
    }
    if (!a3) {
      goto LABEL_31;
    }
    goto LABEL_28;
  }
  if (IIODictionary::getBoolForKey((IIODictionary *)v43, @"kCGImageDestinationEmbedThumbnail"))
  {
    if (a3)
    {
      Thumb = CGImageCreateThumb(a3, 0xA0uLL);
      CFDataRef JPEGDataFromImage = AppleJPEGReadPlugin::CreateJPEGDataFromImage(0, (IIOImagePixelDataProvider *)v43, Thumb, v22);
LABEL_29:
      uint64_t Width = CGImageGetWidth(a3);
      unsigned int Height = CGImageGetHeight(a3);
      CGColorSpaceRef ColorSpace = CGImageGetColorSpace(a3);
      goto LABEL_32;
    }
    LogError("IIOCreateExifFromMetadata", 277, "*** ERROR: no image provided - cannot embed thumbnail\n");
    CFDataRef JPEGDataFromImage = 0;
  }
  else
  {
    CFDataRef JPEGDataFromImage = 0;
    if (a3)
    {
LABEL_28:
      Thumb = 0;
      goto LABEL_29;
    }
  }
LABEL_31:
  uint64_t Width = (uint64_t)IIODictionary::getUint32ForKey((IIODictionary *)&v44, @"PixelXDimension");
  unsigned int Height = IIODictionary::getUint32ForKey((IIODictionary *)&v44, @"PixelYDimension");
  Thumb = 0;
  CGColorSpaceRef ColorSpace = 0;
LABEL_32:
  if ((gIIODebugFlags & 0x2000000000000) != 0)
  {
    ImageIOLog("%s WriteExifData: writing Exif data\n", "-o- ");
    if ((gIIODebugFlags & 0x2000000000000) != 0) {
      IIODebugOrientation("IIOCreateExifFromMetadata", 305, (IIODictionary *)v43);
    }
  }
  uint64_t v26 = (void *)CreateExifBufferFromPropertiesJPEG((IIODictionary *)v43, Width, Height, ColorSpace, JPEGDataFromImage, @"public.jpeg", &__n);
  if (v26 && (int v27 = __n, __n))
  {
    if (BoolForKey)
    {
      uint64_t v28 = (UInt8 *)malloc_type_malloc((__n + 4), 0xF9030F24uLL);
      *(_WORD *)uint64_t v28 = -7681;
      CGColorSpaceRef v28[2] = (unsigned __int16)(v27 + 2) >> 8;
      void v28[3] = v27 + 2;
      memcpy(v28 + 4, v26, __n);
      *a4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v28, (v27 + 4));
      CFIndex v29 = v28;
    }
    else
    {
      CFIndex v30 = malloc_type_malloc(__n, 0xA945AF96uLL);
      memcpy(v30, v26, __n);
      *a4 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)v30, __n);
      CFIndex v29 = (UInt8 *)v30;
    }
    free(v29);
  }
  else
  {
    _cg_jpeg_mem_term("IIOCreateExifFromMetadata", 309, "*** WARNING: CreateExifBufferFromPropertiesJPEG returned NULL\n");
  }
  if (JPEGDataFromImage) {
    CFRelease(JPEGDataFromImage);
  }
  if (Thumb) {
    CGImageRelease(Thumb);
  }
  if (v26) {
    free(v26);
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v44);
LABEL_48:
  if (v41)
  {
    size_t v44 = 0;
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v43, @"{IPTC}");
    if (ObjectForKey)
    {
      CFTypeID v32 = CFGetTypeID(ObjectForKey);
      if (v32 == CFDictionaryGetTypeID()) {
        operator new();
      }
    }
    if (IIODictionary::getCount((IIODictionary *)v43))
    {
      unsigned int v33 = IIODictionary::containsKeyGroup((IIODictionary *)v43, @"ColorSpace", @"{Exif}");
      if (v33) {
        LOBYTE(v33) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v43, @"ColorSpace", @"{Exif}") == 1;
      }
      uint64_t v34 = CreateIPTCDataFromProperties(v33, 0, &v44);
      if (v34)
      {
        int v35 = v44;
        if (v44)
        {
          long long v36 = (UInt8 *)malloc_type_malloc((v44 + 4), 0x7A3D08uLL);
          *(_WORD *)long long v36 = -4609;
          v36[2] = (unsigned __int16)(v35 + 2) >> 8;
          void v36[3] = v35 + 2;
          memcpy(v36 + 4, v34, v44);
          *int v41 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v36, (v35 + 4));
          free(v36);
          free(v34);
        }
      }
    }
  }
  if (v40)
  {
    size_t v44 = 0;
    uint64_t v45 = 0;
    uint64_t v46 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v44, a7);
    if (IIODictionary::containsKey((IIODictionary *)&v44, @"kCGDataFromMetadataStripExifFromXMP")
      && !IIODictionary::getBoolForKey((IIODictionary *)&v44, @"kCGDataFromMetadataStripExifFromXMP"))
    {
      CFDataRef XMPData = CGImageMetadataCreateXMPData(v18, 0);
    }
    else
    {
      CFDataRef XMPData = CGImageMetadataCreateXMPWithEXIFFiltered(v18);
    }
    *unint64_t v40 = XMPData;
    IIODictionary::~IIODictionary((IIODictionary *)&v44);
  }
  if (v18) {
    CFRelease(v18);
  }
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v43);
  return 0;
}

void sub_1887D8924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  MEMORY[0x18C11C0E0](v6, 0x10A1C4047070A01);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageCreateMetadataFromData(const __CFData *a1, const __CFData *a2, const __CFData *a3, const __CFData *a4, CFDictionaryRef *a5, CGMutableImageMetadataRef *a6)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((~(_WORD)gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImageCreateMetadataFromData", 0, 0, -1, 0);
  }
  if (!a5)
  {
    __int16 v11 = a6;
    if (!a6)
    {
      LogError("CGImageCreateMetadataFromData", 456, "*** ERROR: imageProperties or imageMetadata have to be non-nil\n");
LABEL_39:
      uint64_t v26 = 4294967246;
      goto LABEL_115;
    }
    goto LABEL_7;
  }
  *a5 = 0;
  __int16 v11 = a6;
  if (a6)
  {
LABEL_7:
    char v68 = 0;
    CGMutableImageMetadataRef *v11 = 0;
    goto LABEL_8;
  }
  char v68 = 1;
LABEL_8:
  CGMutableImageMetadataRef Mutable = CGImageMetadataCreateMutable();
  if (!a1) {
    goto LABEL_13;
  }
  BytePtr = (const char *)CFDataGetBytePtr(a1);
  unint64_t Length = CFDataGetLength(a1);
  if (Length < 0x11) {
    goto LABEL_13;
  }
  if (!strncmp(BytePtr, "Exif", 5uLL))
  {
    unsigned int v15 = 6;
  }
  else
  {
    if (strncmp(BytePtr + 4, "Exif", 5uLL))
    {
      LogError("CGImageCreateMetadataFromData", 499, "*** ERROR: exifData not recognized (does not start with 'Exif");
LABEL_13:
      unsigned int v15 = 0;
      goto LABEL_14;
    }
    unsigned int v15 = 10;
  }
  MetadataFromDataUInt8 buffer = (const void *)CreateMetadataFromDatabuffer(&BytePtr[v15], Length - v15);
  if (MetadataFromDatabuffer)
  {
    CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)MetadataFromDatabuffer, 0);
    CFRelease(MetadataFromDatabuffer);
    int v16 = 1;
    if (!a3) {
      goto LABEL_31;
    }
LABEL_15:
    uint32x4_t v17 = (const char *)CFDataGetBytePtr(a3);
    unint64_t v18 = CFDataGetLength(a3);
    if (v18 >= 0x29)
    {
      uint64_t v19 = 29;
      if (strncmp(v17, kMainXMPSignatureString[0], 0x1DuLL))
      {
        if (strncmp(v17, kMainXMPPlainString[0], 0x21uLL))
        {
          if (!strncmp(v17, "http://ns.adobe.com/xmp/extension/", 0x23uLL)) {
            LogError("CGImageCreateMetadataFromData", 538, "*** ERROR: XMP exention blocks not handled yet!\n");
          }
          goto LABEL_30;
        }
        uint64_t v19 = 0;
      }
      MetadataFromXMPuint64_t Buffer = (const void *)CreateMetadataFromXMPBuffer(&v17[v19], v18 - v19);
      if (MetadataFromXMPBuffer)
      {
        CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)MetadataFromXMPBuffer, 0);
        CFRelease(MetadataFromXMPBuffer);
        LODWORD(a3) = 1;
        goto LABEL_31;
      }
      LogError("CGImageCreateMetadataFromData", 533, "*** ERROR: XMP not recognized (does not start with 'http://ns.adobe.com/xap/1.0/'\n");
    }
LABEL_30:
    LODWORD(a3) = 0;
    goto LABEL_31;
  }
LABEL_14:
  int v16 = 0;
  if (a3) {
    goto LABEL_15;
  }
LABEL_31:
  CGMutableImageMetadataRef cf = Mutable;
  unsigned int v67 = v15;
  if (a2)
  {
    uint64_t v22 = (const char *)CFDataGetBytePtr(a2);
    unint64_t v23 = CFDataGetLength(a2);
    if (v23 >= 0x15)
    {
      if (!strncmp(v22, "Photoshop 3.0", 0xEuLL) || !strncmp(v22 + 4, "Photoshop 3.0", 0xEuLL))
      {
        CGMutableImageMetadataRef v27 = CGImageMetadataCreateMutable();
        ReadPhotoshopImageResource((uint64_t)v27, (uint64_t)(v22 + 14), v23 - 14);
        CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)v27, 0);
        CFRelease(v27);
        BOOL v25 = a4 == 0;
        char v24 = 1;
        goto LABEL_41;
      }
      LogError("CGImageCreateMetadataFromData", 570, "*** ERROR: IPTC not recognized (does not start with 'Photoshop 3.0'\n");
    }
  }
  char v24 = 0;
  BOOL v25 = a4 == 0;
  if (((v16 | a3) & 1) == 0 && !a4)
  {
    CFRelease(cf);
    goto LABEL_39;
  }
LABEL_41:
  if (!a5) {
    goto LABEL_112;
  }
  uint64_t v28 = CGImagePropertiesCreateFromMetadata(cf);
  CFIndex v29 = (CFDictionaryRef *)v28;
  if (v28) {
    char v30 = 1;
  }
  else {
    char v30 = v25;
  }
  if ((v30 & 1) == 0) {
    operator new();
  }
  if (!v28) {
    goto LABEL_112;
  }
  IIONumber::IIONumber((IIONumber *)v83, 8);
  IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v83, @"Depth");
  IIONumber::~IIONumber((IIONumber *)v83);
  CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup((IIODictionary *)v29, @"XResolution", @"{TIFF}");
  if (ObjectForKeyGroup)
  {
    IIODictionary::setObjectForKey((IIODictionary *)v29, ObjectForKeyGroup, @"DPIHeight");
  }
  else
  {
    IIONumber::IIONumber((IIONumber *)v82, 72);
    IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v82, @"DPIHeight");
    IIONumber::~IIONumber((IIONumber *)v82);
  }
  CFDictionaryRef v32 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v29, @"YResolution", @"{TIFF}");
  if (v32)
  {
    IIODictionary::setObjectForKey((IIODictionary *)v29, v32, @"DPIWidth");
  }
  else
  {
    IIONumber::IIONumber((IIONumber *)v81, 72);
    IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v81, @"DPIWidth");
    IIONumber::~IIONumber((IIONumber *)v81);
  }
  CFDictionaryRef v33 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v29, @"Orientation", @"{TIFF}");
  if (v33)
  {
    IIODictionary::setObjectForKey((IIODictionary *)v29, v33, @"Orientation");
  }
  else
  {
    IIONumber::IIONumber((IIONumber *)v80, 1);
    IIODictionary::setObjectForKey((uint64_t)v29, (uint64_t)v80, @"Orientation");
    IIONumber::~IIONumber((IIONumber *)v80);
  }
  CFDictionaryRef v34 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v29, @"PixelYDimension", @"{Exif}");
  if (v34) {
    IIODictionary::setObjectForKey((IIODictionary *)v29, v34, @"PixelHeight");
  }
  CFDictionaryRef v35 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v29, @"PixelXDimension", @"{Exif}");
  if (v35) {
    IIODictionary::setObjectForKey((IIODictionary *)v29, v35, @"PixelWidth");
  }
  if (!v25)
  {
    int8x16_t v48 = (UInt8 *)CFDataGetBytePtr(a4);
    unsigned int v49 = CFDataGetLength(a4);
    if (v49 < 0xC9) {
      goto LABEL_76;
    }
    int v50 = bswap32(*((_DWORD *)v48 + 4));
    if (v50 > 1281450527)
    {
      if (v50 == 1281450528)
      {
        double v51 = (const void **)&kCGImagePropertyColorModelLab;
      }
      else
      {
        if (v50 != 1380401696) {
          goto LABEL_89;
        }
        double v51 = (const void **)&kCGImagePropertyColorModelRGB;
      }
    }
    else if (v50 == 1129142603)
    {
      double v51 = (const void **)&kCGImagePropertyColorModelCMYK;
    }
    else
    {
      if (v50 != 1196573017) {
        goto LABEL_89;
      }
      double v51 = (const void **)&kCGImagePropertyColorModelGray;
    }
    IIODictionary::setObjectForKey((IIODictionary *)v29, *v51, @"ColorModel");
LABEL_89:
    uint64_t v79 = 0;
    *(_OWORD *)__p = 0u;
    long long v78 = 0u;
    *(_OWORD *)int8x8_t v75 = 0u;
    long long v76 = 0u;
    IIOScanner::IIOScanner((IIOScanner *)v75, v48, v49, 0);
    IIOScanner::seek((IIOScanner *)v75, 0x80uLL);
    int Val32 = IIOScanner::getVal32((IIOScanner *)v75);
    if (Val32)
    {
      while (IIOScanner::getVal32((IIOScanner *)v75) != 1684370275)
      {
        IIOScanner::skip((uint64_t)v75, 8);
        if (!--Val32) {
          goto LABEL_95;
        }
      }
      unsigned int v56 = IIOScanner::getVal32((IIOScanner *)v75);
      IIOScanner::getVal32((IIOScanner *)v75);
      IIOScanner::seek((IIOScanner *)v75, v56);
      if (IIOScanner::getVal32((IIOScanner *)v75) == 1684370275)
      {
        IIOScanner::skip((uint64_t)v75, 4);
        IIOScanner::getVal32((IIOScanner *)v75);
        uint64_t v72 = 0;
        uint64_t v73 = 0;
        xpc_object_t value = 0;
        IIOString::IIOString((IIOString *)&v72, (const char *)&v48[*((void *)&v76 + 1)]);
        IIODictionary::setObjectForKey((IIODictionary *)v29, value, @"ProfileName");
        IIOString::~IIOString((IIOString *)&v72);
      }
    }
LABEL_95:
    IIOScanner::~IIOScanner((IIOScanner *)v75);
    if (v24) {
      goto LABEL_101;
    }
    goto LABEL_77;
  }
  if (IIODictionary::containsKeyGroup((IIODictionary *)v29, @"PrimaryChromaticities", @"{TIFF}")
    && IIODictionary::containsKeyGroup((IIODictionary *)v29, @"WhitePoint", @"{TIFF}")
    && IIODictionary::containsKeyGroup((IIODictionary *)v29, @"Gamma", @"{Exif}"))
  {
    IIODictionary::setObjectForKey((IIODictionary *)v29, @"RGB", @"ColorModel");
    double FloatForKeyGroup = IIODictionary::getFloatForKeyGroup((IIODictionary *)v29, @"Gamma", @"{Exif}");
    float v66 = *(float *)&FloatForKeyGroup;
    CFDictionaryRef v37 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v29, @"WhitePoint", @"{TIFF}");
    v75[0] = 0;
    v75[1] = 0;
    *(void *)&long long v76 = 0;
    IIOArray::IIOArray((IIOArray *)v75, v37);
    FloatAtIndeCGFloat x = IIOArray::getFloatAtIndex((IIOArray *)v75, 0);
    float v39 = IIOArray::getFloatAtIndex((IIOArray *)v75, 1);
    CFDictionaryRef v40 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v29, @"PrimaryChromaticities", @"{TIFF}");
    uint64_t v72 = 0;
    uint64_t v73 = 0;
    xpc_object_t value = 0;
    IIOArray::IIOArray((IIOArray *)&v72, v40);
    float v41 = IIOArray::getFloatAtIndex((IIOArray *)&v72, 0);
    float v42 = IIOArray::getFloatAtIndex((IIOArray *)&v72, 1);
    float v43 = IIOArray::getFloatAtIndex((IIOArray *)&v72, 2);
    float v44 = IIOArray::getFloatAtIndex((IIOArray *)&v72, 3);
    float v45 = IIOArray::getFloatAtIndex((IIOArray *)&v72, 4);
    float v46 = IIOArray::getFloatAtIndex((IIOArray *)&v72, 5);
    if (IIOChromaticitiesMatchAdobeRGB(FloatAtIndex, v39, v41, v42, v43, v44, v45, v46, v66))
    {
      uint16x8_t v47 = @"Adobe RGB (1998)";
    }
    else
    {
      if (!IIOChromaticitiesMatchSRGB(FloatAtIndex, v39, v41, v42, v43, v44, v45, v46, v66)) {
        goto LABEL_100;
      }
      uint16x8_t v47 = @"sRGB IEC61966-2.1";
    }
    IIODictionary::setObjectForKey((IIODictionary *)v29, v47, @"ProfileName");
LABEL_100:
    IIOArray::~IIOArray((IIOArray *)&v72);
    IIOArray::~IIOArray((IIOArray *)v75);
    if (v24) {
      goto LABEL_101;
    }
LABEL_77:
    if (IIODictionary::containsKey((IIODictionary *)v29, @"{IPTC}"))
    {
      _cg_jpeg_mem_term("CGImageCreateMetadataFromData", 615, "*** NOTE: metadata contains {IPTC} - but IPTCData was not requested...\n");
      CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v29, @"{IPTC}");
      v83[0] = 0;
      v83[1] = 0;
      CGRect v84 = 0;
      int v53 = IIODictionary::IIODictionary((IIODictionary *)v83, ObjectForKey);
      v75[0] = 0;
      v75[1] = v75;
      *(void *)&long long v76 = 0x4002000000;
      *((void *)&v76 + 1) = __Block_byref_object_copy__3;
      __p[0] = __Block_byref_object_dispose__3;
      __p[1] = 0;
      long long v78 = 0uLL;
      v71[0] = MEMORY[0x1E4F143A8];
      v71[1] = 0x40000000;
      v71[2] = __CGImageCreateMetadataFromData_block_invoke;
      v71[3] = &unk_1E53C0340;
      v71[4] = v75;
      IIODictionary::enumerate((uint64_t)v53, v71);
      int8x16_t v54 = (char *)v75[1] + 40;
      if (*((char *)v75[1] + 63) < 0) {
        int8x16_t v54 = *(const char **)v54;
      }
      _cg_jpeg_mem_term("CGImageCreateMetadataFromData", 623, "    returning with Exif: '%s'\n", v54);
      kdebug_trace();
      _Block_object_dispose(v75, 8);
      if (SHIBYTE(v78) < 0) {
        operator delete(__p[1]);
      }
      IIODictionary::~IIODictionary((IIODictionary *)v83);
    }
    goto LABEL_101;
  }
  if (IIODictionary::containsKeyGroup((IIODictionary *)v29, @"ColorSpace", @"{Exif}")
    && IIODictionary::getUint32ForKeyGroup((IIODictionary *)v29, @"ColorSpace", @"{Exif}") == 1)
  {
    IIODictionary::setObjectForKey((IIODictionary *)v29, @"sRGB IEC61966-2.1", @"ProfileName");
  }
LABEL_76:
  if ((v24 & 1) == 0) {
    goto LABEL_77;
  }
LABEL_101:
  if (IIODictionary::containsKeyGroup((IIODictionary *)v29, @"JPEGInterchangeFormatLength", @"{Exif}"))
  {
    unsigned int Uint32ForKeyGroup = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v29, @"JPEGInterchangeFormatLength", @"{Exif}");
    unsigned int v58 = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v29, @"JPEGInterchangeFormat", @"{Exif}");
    int v59 = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v29, @"JPEGInterchangeFormatWidth", @"{Exif}");
    unsigned int v60 = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v29, @"JPEGInterchangeFormatHeight", @"{Exif}");
    if (v59)
    {
      int v61 = v60;
      if (v60)
      {
        if (v58 && Uint32ForKeyGroup)
        {
          v75[0] = 0;
          v75[1] = 0;
          *(void *)&long long v76 = 0;
          IIODictionary::IIODictionary((IIODictionary *)v75);
          IIODictionary::setObjectForKey((IIODictionary *)v29, v75[1], @"{ExifThumbnail}");
          IIONumber::IIONumber((IIONumber *)v83, v59);
          IIODictionary::setObjectForKey((IIODictionary *)v75, v84, @"JPEGInterchangeFormatWidth");
          IIONumber::~IIONumber((IIONumber *)v83);
          IIONumber::IIONumber(v62, v61);
          IIODictionary::setObjectForKey((IIODictionary *)v75, v84, @"JPEGInterchangeFormatHeight");
          IIONumber::~IIONumber((IIONumber *)v83);
          int8x16_t v63 = CFDataGetBytePtr(a1);
          if (CFDataGetLength(a1) > Uint32ForKeyGroup - v67 + v58)
          {
            CFDataRef v64 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], &v63[v58 - v67], Uint32ForKeyGroup);
            if (v64)
            {
              IIODictionary::setObjectForKey((IIODictionary *)v75, v64, @"JPEGThumbnailData");
              CFRelease(v64);
            }
          }
          IIODictionary::~IIODictionary((IIODictionary *)v75);
        }
      }
    }
    IIODictionary::removeObjectForKeyGroup((IIODictionary *)v29, @"JPEGInterchangeFormatLength", @"{Exif}");
    IIODictionary::removeObjectForKeyGroup((IIODictionary *)v29, @"JPEGInterchangeFormat", @"{Exif}");
    IIODictionary::removeObjectForKeyGroup((IIODictionary *)v29, @"JPEGInterchangeFormatWidth", @"{Exif}");
    IIODictionary::removeObjectForKeyGroup((IIODictionary *)v29, @"JPEGInterchangeFormatHeight", @"{Exif}");
  }
  *a5 = CFDictionaryCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v29[1]);
  (*((void (**)(CFDictionaryRef *))*v29 + 1))(v29);
LABEL_112:
  if (v68)
  {
    CFRelease(cf);
    uint64_t v26 = 0;
  }
  else
  {
    uint64_t v26 = 0;
    *a6 = cf;
  }
LABEL_115:
  kdebug_trace();
  return v26;
}

void sub_1887D9730(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,char a38)
{
}

__n128 __Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(__n128 *)(a1 + 40) = result;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
  if (*(char *)(a1 + 63) < 0) {
    operator delete(*(void **)(a1 + 40));
  }
}

std::string *__CGImageCreateMetadataFromData_block_invoke(uint64_t a1, const void *a2)
{
  IIOString::IIOString((IIOString *)v5, a2);
  CFStringRef v3 = IIOString::utf8String((IIOString *)v5);
  std::string::append((std::string *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), (const std::string::value_type *)v3);
  IIOString::~IIOString((IIOString *)v5);
  return std::string::append((std::string *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), "  ");
}

void sub_1887D994C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageCreateMetadataFromDataArray(const __CFArray *a1, CFDictionaryRef *a2, CGMutableImageMetadataRef *a3)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((~gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImageCreateMetadataFromDataArray", 0, 0, -1, 0);
  }
  if (!a1)
  {
    LogError("CGImageCreateMetadataFromDataArray", 698, "*** ERROR: dataArray is nil\n");
    MetadataFromunint64_t Data = 4294967246;
    goto LABEL_38;
  }
  if (CFArrayGetCount(a1) <= 0)
  {
    MetadataFromunint64_t Data = CGImageCreateMetadataFromData(0, 0, 0, 0, a2, a3);
    goto LABEL_38;
  }
  uint64_t v19 = a2;
  CFIndex v6 = 0;
  CFDataRef v7 = 0;
  CFDataRef v20 = 0;
  CFDataRef v21 = 0;
  CFDataRef v8 = 0;
  CFAllocatorRef allocator = (CFAllocatorRef)*MEMORY[0x1E4F1CF80];
  do
  {
    ValueAtIndeCGFloat x = CFArrayGetValueAtIndex(a1, v6);
    CFTypeID v10 = CFGetTypeID(ValueAtIndex);
    if (v10 != CFDataGetTypeID())
    {
      LogError("CGImageCreateMetadataFromDataArray", 705, "*** ERROR: dataArray does not contain CFData\n");
      goto LABEL_15;
    }
    BytePtr = CFDataGetBytePtr((CFDataRef)ValueAtIndex);
    unsigned int Length = CFDataGetLength((CFDataRef)ValueAtIndex);
    if (Length < 0x11) {
      goto LABEL_15;
    }
    if (!strncmp((const char *)BytePtr, "Exif", 5uLL))
    {
      CFDataRef v8 = (const __CFData *)ValueAtIndex;
      goto LABEL_15;
    }
    if (Length < 0x1F)
    {
      if (Length < 0x15) {
        goto LABEL_15;
      }
    }
    else
    {
      if (!strncmp((const char *)BytePtr, kMainXMPSignatureString[0], 0x1DuLL))
      {
        CFDataRef v20 = (const __CFData *)ValueAtIndex;
        goto LABEL_15;
      }
      if (Length >= 0x29 && !strncmp((const char *)BytePtr, "http://ns.adobe.com/xmp/extension/", 0x23uLL))
      {
        LogError("CGImageCreateMetadataFromDataArray", 722, "*** ERROR: XMP exention blocks not handled yet!\n");
        goto LABEL_15;
      }
    }
    if (!strncmp((const char *)BytePtr, "Photoshop 3.0", 0xEuLL))
    {
      CFDataRef v21 = (const __CFData *)ValueAtIndex;
      goto LABEL_15;
    }
    if (Length < 0x81) {
      goto LABEL_15;
    }
    if (!strncmp((const char *)BytePtr, "ICC_PROFILE", 0xCuLL))
    {
      if (v7) {
        CFRelease(v7);
      }
      unsigned int v15 = BytePtr + 14;
      CFIndex v13 = Length - 14;
      CFAllocatorRef v14 = allocator;
      goto LABEL_34;
    }
    if (BytePtr[36] == 97 && BytePtr[37] == 99 && BytePtr[38] == 115 && BytePtr[39] == 112)
    {
      if (v7) {
        CFRelease(v7);
      }
      CFIndex v13 = Length;
      CFAllocatorRef v14 = allocator;
      unsigned int v15 = BytePtr;
LABEL_34:
      CFDataRef v7 = CFDataCreate(v14, v15, v13);
    }
LABEL_15:
    ++v6;
  }
  while (v6 < CFArrayGetCount(a1));
  MetadataFromunint64_t Data = CGImageCreateMetadataFromData(v8, v21, v20, v7, v19, a3);
  if (v7) {
    CFRelease(v7);
  }
LABEL_38:
  kdebug_trace();
  return MetadataFromData;
}

uint64_t EXRReadPlugin::EXRReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v6 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(void *)uint64_t v6 = &unk_1ED4DF8E8;
  *(_OWORD *)(v6 + 440) = 0u;
  *(_OWORD *)(v6 + 456) = 0u;
  *(_OWORD *)(v6 + 472) = 0u;
  *(_OWORD *)(v6 + 488) = 0u;
  *(_OWORD *)(v6 + 504) = 0u;
  *(_OWORD *)(v6 + 520) = 0u;
  *(_OWORD *)(v6 + 536) = 0u;
  *(_OWORD *)(v6 + 552) = 0u;
  *(_OWORD *)(v6 + 568) = 0u;
  *(_OWORD *)(v6 + 584) = 0u;
  *(void *)(v6 + 600) = 0;
  AppleEXREnabled();
  return a1;
}

void sub_1887D9D08(_Unwind_Exception *a1)
{
  EXRPluginData::~EXRPluginData(v2);
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

void EXRReadPlugin::EXRReadPlugin(uint64_t a1, uint64_t a2)
{
}

void sub_1887D9D98(_Unwind_Exception *a1)
{
  EXRPluginData::~EXRPluginData(v2);
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

void EXRReadPlugin::~EXRReadPlugin(EXRReadPlugin *this)
{
  *(void *)this = &unk_1ED4DF8E8;
  *((void *)this + 75) = 0;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *(_OWORD *)((char *)this + 536) = 0u;
  *(_OWORD *)((char *)this + 552) = 0u;
  *(_OWORD *)((char *)this + 568) = 0u;
  *(_OWORD *)((char *)this + 584) = 0u;
  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1ED4DF8E8;
  *((void *)this + 75) = 0;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *(_OWORD *)((char *)this + 488) = 0u;
  *(_OWORD *)((char *)this + 504) = 0u;
  *(_OWORD *)((char *)this + 520) = 0u;
  *(_OWORD *)((char *)this + 536) = 0u;
  *(_OWORD *)((char *)this + 552) = 0u;
  *(_OWORD *)((char *)this + 568) = 0u;
  *(_OWORD *)((char *)this + 584) = 0u;
  IIOReadPlugin::~IIOReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t EXRReadPlugin::initialize(EXRReadPlugin *this, IIODictionary *a2)
{
  if (!AppleEXREnabled())
  {
    uint64_t updated = 4294967246;
LABEL_39:
    kdebug_trace();
    return updated;
  }
  int8x16_t v63 = 0;
  CFStringRef v3 = IIOImageReadSession::retainBytePointer(*((IIOImageReadSession **)this + 3), (const __CFData **)&v63, 1);
  unsigned int Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  uint64_t v62 = 0;
  uint64_t v5 = (void *)gFunc_axr_data_create(v3, Size, &v62, 0, 0);
  uint64_t logical_image_list = (void *)gFunc_axr_data_create_logical_image_list(v5);
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  uint64_t updated = IIO_Reader_OpenEXR::UpdateImageInfo((uint64_t)logical_image_list, &v59);
  if (updated)
  {
    _cg_jpeg_mem_term("initialize", 87, "*** ERROR: IIO_Reader_OpenEXR::UpdateImageInfo failed: %d\n", updated);
    goto LABEL_32;
  }
  unint64_t v8 = *((unsigned int *)this + 52);
  uint64_t v9 = v59;
  if (0xCF3CF3CF3CF3CF3DLL * ((v60 - v59) >> 3) <= v8)
  {
    LogError("initialize", 89, "*** IIO_Reader_OpenEXR::UpdateImageInfo read past end of imageInfo\n");
    goto LABEL_32;
  }
  CFTypeID v10 = (long long *)(v59 + 168 * v8);
  long long v11 = *v10;
  *(_OWORD *)((char *)this + 449) = *(long long *)((char *)v10 + 9);
  *(_OWORD *)((char *)this + 440) = v11;
  std::string::operator=((std::string *)((char *)this + 472), (const std::string *)(v10 + 2));
  std::string::operator=((std::string *)((char *)this + 496), (const std::string *)(v9 + 168 * v8 + 56));
  std::string::operator=((std::string *)((char *)this + 520), (const std::string *)(v9 + 168 * v8 + 80));
  uint64_t v12 = v9 + 168 * v8;
  long long v13 = *(_OWORD *)(v12 + 104);
  long long v14 = *(_OWORD *)(v12 + 120);
  long long v15 = *(_OWORD *)(v12 + 152);
  *((_OWORD *)this + 36) = *(_OWORD *)(v12 + 136);
  *((_OWORD *)this + 37) = v15;
  *((_OWORD *)this + 34) = v13;
  *((_OWORD *)this + 35) = v14;
  if (v62)
  {
    name = (const char *)gFunc_axr_error_get_name();
    LogError("initialize", 91, "*** axr_data_create failed: %s (%d)\n", name, v62);
    goto LABEL_32;
  }
  uint64_t decoder = gFunc_axr_logical_image_list_create_decoder(logical_image_list, v5, *((unsigned int *)this + 111), *((unsigned int *)this + 112), 0, 0, 0, 1.0);
  uint32x4_t v17 = (void *)decoder;
  if (!decoder)
  {
    LogError("initialize", 95, "*** axr_logical_image_list_create_decoder returned NULL\n");
    goto LABEL_32;
  }
  int channel_count = gFunc_axr_decoder_get_channel_count(decoder);
  char v19 = channel_count;
  *((_DWORD *)this + 146) = channel_count;
  double v20 = NAN;
  if ((channel_count & 1) == 0) {
    double v20 = 1.0;
  }
  *((double *)this + 57) = v20;
  gFunc_axr_data_get_part_info(v49, v5, *((unsigned int *)this + 141), 1);
  float v22 = v51;
  float v21 = v52;
  float v24 = v53;
  float v23 = v54;
  float v26 = v55;
  float v25 = v56;
  float v28 = v57;
  float v27 = v58;
  uint64_t v46 = 0;
  xpc_object_t value = 0;
  uint64_t v48 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v46);
  IIODictionary::setObjectForKey(*((IIODictionary **)this + 7), value, @"{EXR}");
  CFMutableArrayRef v43 = 0;
  float v44 = 0;
  uint64_t v45 = 0;
  IIOArray::IIOArray((IIOArray *)&v43);
  IIODictionary::setObjectForKey((IIODictionary *)&v46, v44, @"Chromaticities");
  IIONumber::IIONumber((IIONumber *)v49, v22);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  IIONumber::IIONumber((IIONumber *)v49, v26);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  IIONumber::IIONumber((IIONumber *)v49, v21);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  IIONumber::IIONumber((IIONumber *)v49, v25);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  IIONumber::IIONumber((IIONumber *)v49, v24);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  IIONumber::IIONumber((IIONumber *)v49, v28);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  IIONumber::IIONumber((IIONumber *)v49, v23);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  IIONumber::IIONumber((IIONumber *)v49, v27);
  IIOArray::addObject(&v43, v50);
  IIONumber::~IIONumber((IIONumber *)v49);
  int v29 = *((_DWORD *)this + 143);
  BOOL v31 = v29 != 1 && v29 != 7;
  *((unsigned char *)this + 464) = v31;
  colorCGColorSpaceRef space = gFunc_axr_decoder_create_colorspace(v17, 0, 0);
  *((void *)this + 20) = colorspace;
  if (!colorspace)
  {
    if ((*((_DWORD *)this + 146) - 1) >= 2) {
      CFDictionaryRef v33 = (CFStringRef *)MEMORY[0x1E4F1DBE0];
    }
    else {
      CFDictionaryRef v33 = (CFStringRef *)MEMORY[0x1E4F1DBD0];
    }
    *((void *)this + 20) = CGColorSpaceCreateWithName(*v33);
  }
  if (*((unsigned char *)this + 464)) {
    gFunc_axr_decoder_get_read_pixels_info(v49, v17, 0, 1);
  }
  else {
    gFunc_axr_decoder_get_read_rgba_pixels_info(v49, v17, 0, 1, *((double *)this + 57));
  }
  CGColorSpaceModel Model = CGColorSpaceGetModel(*((CGColorSpaceRef *)this + 20));
  if (Model == kCGColorSpaceModelMonochrome)
  {
    int v35 = 1196573017;
    goto LABEL_27;
  }
  if (Model == kCGColorSpaceModelRGB)
  {
    int v35 = 1380401696;
LABEL_27:
    *((_DWORD *)this + 81) = v35;
  }
  os_release(v17);
  IIOArray::~IIOArray((IIOArray *)&v43);
  IIODictionary::~IIODictionary((IIODictionary *)&v46);
  uint64_t v36 = *((void *)this + 69);
  *(void *)((char *)this + 228) = v36;
  __int16 v37 = *((_WORD *)this + 292);
  *((_WORD *)this + 122) = v37;
  __int16 v38 = *((_WORD *)this + 220);
  *((_WORD *)this + 120) = v38;
  unsigned __int16 v39 = v38 * v37;
  *((_WORD *)this + 121) = v39;
  if (v19) {
    char v40 = 5;
  }
  else {
    char v40 = 3;
  }
  *((unsigned char *)this + 246) = v40;
  *((_DWORD *)this + 59) = v36 * (v39 >> 3);
  *((void *)this + 24) = 0;
  *((_WORD *)this + 172) = 256;
  *((unsigned char *)this + 346) = 0;
  *((_WORD *)this + 188) = 1;
LABEL_32:
  if (v5) {
    os_release(v5);
  }
  if (logical_image_list) {
    os_release(logical_image_list);
  }
  if (v63) {
    IIOImageReadSession::releaseBytePointer(*((IIOImageRead ***)this + 3), v63);
  }
  v49[0] = (void **)&v59;
  std::vector<EXRPluginData>::__destroy_vector::operator()[abi:ne180100](v49);
  if (updated) {
    goto LABEL_39;
  }
  return updated;
}

void sub_1887DA41C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void **a17)
{
  IIOArray::~IIOArray((IIOArray *)&a11);
  IIODictionary::~IIODictionary((IIODictionary *)&a14);
  a17 = (void **)(v17 - 168);
  std::vector<EXRPluginData>::__destroy_vector::operator()[abi:ne180100](&a17);
  _Unwind_Resume(a1);
}

uint64_t EXRReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12) {
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2);
  }
  if (v2 == 1) {
    return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

uint64_t EXRReadPlugin::loadDataFromXPCObject(EXRReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_exr", &length);
    if (length == 168)
    {
      uint64_t v6 = data;
      uint64_t result = 0;
      long long v7 = *v6;
      long long v8 = v6[2];
      *(_OWORD *)((char *)this + 456) = v6[1];
      *(_OWORD *)((char *)this + 472) = v8;
      *(_OWORD *)((char *)this + 440) = v7;
      long long v9 = v6[3];
      long long v10 = v6[4];
      long long v11 = v6[6];
      *(_OWORD *)((char *)this + 520) = v6[5];
      *(_OWORD *)((char *)this + 536) = v11;
      *(_OWORD *)((char *)this + 488) = v9;
      *(_OWORD *)((char *)this + 504) = v10;
      long long v12 = v6[7];
      long long v13 = v6[8];
      long long v14 = v6[9];
      *((void *)this + 75) = *((void *)v6 + 20);
      *(_OWORD *)((char *)this + 568) = v13;
      *(_OWORD *)((char *)this + 584) = v14;
      *(_OWORD *)((char *)this + 552) = v12;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t EXRReadPlugin::saveDataToXPCObject(EXRReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_exr", (char *)this + 440, 0xA8uLL);
  }
  return v4;
}

uint64_t EXRReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  memory_object_size_t v38 = 0;
  if ((gIIODebugFlags & 0x20000) == 0) {
    goto LABEL_26;
  }
  int v8 = *((_DWORD *)this + 51);
  unsigned int v9 = v8 >> 24;
  uint64_t v10 = MEMORY[0x1E4F14390];
  if (v8 < 0)
  {
    int v11 = __maskrune(v9, 0x40000uLL);
    int v8 = *((_DWORD *)this + 51);
  }
  else
  {
    int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
  }
  if (v11) {
    uint64_t v12 = (v8 >> 24);
  }
  else {
    uint64_t v12 = 46;
  }
  unsigned int v13 = v8 << 8 >> 24;
  if (v8 << 8 < 0)
  {
    int v14 = __maskrune(v13, 0x40000uLL);
    int v8 = *((_DWORD *)this + 51);
  }
  else
  {
    int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
  }
  if (v14) {
    uint64_t v15 = (v8 << 8 >> 24);
  }
  else {
    uint64_t v15 = 46;
  }
  unsigned int v16 = (__int16)v8 >> 8;
  if (v8 << 16 < 0)
  {
    int v17 = __maskrune(v16, 0x40000uLL);
    int v8 = *((_DWORD *)this + 51);
  }
  else
  {
    int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  }
  if (v17) {
    uint64_t v18 = ((__int16)v8 >> 8);
  }
  else {
    uint64_t v18 = 46;
  }
  if ((v8 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0) {
      goto LABEL_22;
    }
LABEL_24:
    uint64_t v19 = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v8, 0x40000uLL)) {
    goto LABEL_24;
  }
LABEL_22:
  uint64_t v19 = *((char *)this + 204);
LABEL_25:
  ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus EXRReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  double v20 = (IIOImageRead **)*((void *)this + 3);
  if (v20) {
    BOOL v21 = IIOImageReadSession::mapData(v20);
  }
  else {
    BOOL v21 = 0;
  }
  if (a3 == 3)
  {
    uint64_t BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v28) = *((_DWORD *)this + 73);
    double v27 = (double)v28;
    unsigned int v29 = *((_DWORD *)this + 74);
    double v26 = (double)v29;
    memory_object_size_t v25 = *((unsigned int *)this + 75) * (unint64_t)v29;
    BaseAddress = (void *)_ImageIO_Malloc(v25, *((void *)this + 48), &v38, (uint64_t)kImageMalloc_EXR_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4) {
      goto LABEL_42;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    size_t Height = IOSurfaceGetHeight(*a4);
    uint64_t BlockArray = 0;
    memory_object_size_t v25 = IOSurfaceGetBytesPerRow(*a4) * Height;
    memory_object_size_t v38 = v25;
    double v26 = 0.0;
    double v27 = 0.0;
  }
  if (!BaseAddress) {
    goto LABEL_43;
  }
  uint64_t v30 = EXRReadPlugin::decodeBlockAppleEXR(this, BaseAddress);
  if (v30)
  {
    uint64_t BlockArray = v30;
    *((_DWORD *)this + 26) = 0;
    if (a3 == 3)
    {
      _ImageIO_Free((unint64_t)BaseAddress, v38);
      if (!v21) {
        return BlockArray;
      }
      goto LABEL_44;
    }
LABEL_43:
    if (!v21) {
      return BlockArray;
    }
    goto LABEL_44;
  }
  if (a3 != 3)
  {
    IOSurfaceUnlock(*a4, 0, 0);
LABEL_42:
    uint64_t BlockArray = 0;
    goto LABEL_43;
  }
  uint64_t v33 = 0;
  v39.origin.CGFloat x = 0.0;
  v39.origin.CGFloat y = 0.0;
  v39.size.double width = v27;
  v39.size.double height = v26;
  **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v25, v39, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
  if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E4F1DB20]))
  {
    uint64_t v34 = 0;
  }
  else
  {
    v40.origin.CGFloat x = 0.0;
    v40.origin.CGFloat y = 0.0;
    v40.size.double width = v27;
    v40.size.double height = v26;
    *(CGRect *)(&v34 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v40);
    uint64_t v33 = v35;
    double v27 = v36;
    double v26 = v37;
  }
  uint64_t BlockArray = 0;
  *((void *)this + 15) = v33;
  *((void *)this + 16) = v34;
  *((double *)this + 17) = v27;
  *((double *)this + 18) = v26;
  if (v21)
  {
LABEL_44:
    BOOL v31 = (const char **)*((void *)this + 3);
    if (v31) {
      IIOImageReadSession::unmapData(v31);
    }
  }
  return BlockArray;
}

uint64_t EXRReadPlugin::decodeBlockAppleEXR(EXRReadPlugin *this, void *a2)
{
  if (!AppleEXREnabled()) {
    return 4294967246;
  }
  int v4 = *((_DWORD *)this + 66);
  int v17 = 0;
  uint64_t v5 = IIOImageReadSession::retainBytePointer(*((IIOImageReadSession **)this + 3), (const __CFData **)&v17, 1);
  unsigned int Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
  uint64_t v16 = 0;
  long long v7 = (void *)gFunc_axr_data_create(v5, Size, &v16, 0, 0);
  if (!v16)
  {
    uint64_t logical_image_list = (void *)gFunc_axr_data_create_logical_image_list(v7);
    uint64_t decoder = gFunc_axr_logical_image_list_create_decoder(logical_image_list, v7, *((unsigned int *)this + 111), *((unsigned int *)this + 112), 0, 0, 0, *((double *)this + 57));
    uint64_t v10 = (void *)decoder;
    if (decoder)
    {
      if (*((unsigned char *)this + 464))
      {
        gFunc_axr_decoder_get_read_pixels_info(v15, decoder, 0, 1);
        uint64_t pixels = gFunc_axr_decoder_read_pixels(v10, a2, *((unsigned int *)this + 75), 2);
      }
      else
      {
        gFunc_axr_decoder_get_read_rgba_pixels_info(v15, decoder, 0, 1, *((double *)this + 57));
        uint64_t pixels = gFunc_axr_decoder_read_rgba_pixels(v10, a2, *((unsigned int *)this + 75), 2, 1.0);
      }
      uint64_t v16 = pixels;
      if (!pixels)
      {
        if (*((_DWORD *)this + 74) == v4) {
          uint64_t v12 = 0;
        }
        else {
          uint64_t v12 = 4294967246;
        }
        if (logical_image_list) {
          goto LABEL_13;
        }
        goto LABEL_14;
      }
      gFunc_axr_error_get_name();
      LogError("decodeBlockAppleEXR", 390, "*** axr_decoder_read_pixels failed: %s (%d)\n");
    }
    else
    {
      LogError("decodeBlockAppleEXR", 378, "*** axr_decoder_create failed\n");
    }
    uint64_t v12 = 4294967246;
    if (logical_image_list) {
LABEL_13:
    }
      os_release(logical_image_list);
LABEL_14:
    if (v10) {
      os_release(v10);
    }
    if (!v7) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  name = (const char *)gFunc_axr_error_get_name();
  LogError("decodeBlockAppleEXR", 370, "*** axr_data_create failed: %s (%d)\n", name, v16);
  uint64_t v12 = 4294967246;
  if (v7) {
LABEL_17:
  }
    os_release(v7);
LABEL_18:
  if (v17) {
    IIOImageReadSession::releaseBytePointer(*((IIOImageRead ***)this + 3), v17);
  }
  return v12;
}

double TGAReadPlugin::TGAReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(void *)uint64_t v5 = &unk_1ED4E0C58;
  double result = 0.0;
  *(_OWORD *)(v5 + 440) = 0u;
  *(_OWORD *)(v5 + 456) = 0u;
  *(void *)(v5 + 472) = 0;
  return result;
}

void TGAReadPlugin::TGAReadPlugin(uint64_t a1, uint64_t a2)
{
}

void TGAReadPlugin::~TGAReadPlugin(TGAReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t TGAReadPlugin::loadDataFromXPCObject(TGAReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_tga", &length);
    if (length == 40)
    {
      uint64_t v6 = data;
      uint64_t result = 0;
      long long v7 = *v6;
      long long v8 = v6[1];
      *((void *)this + 59) = *((void *)v6 + 4);
      *(_OWORD *)((char *)this + 440) = v7;
      *(_OWORD *)((char *)this + 456) = v8;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t TGAReadPlugin::saveDataToXPCObject(TGAReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_tga", (char *)this + 440, 0x28uLL);
  }
  return v4;
}

unint64_t TGAReadPlugin::readHeader(IIOImageReadSession **this)
{
  unint64_t result = IIOImageReadSession::getBytesAtOffset(this[3], (unsigned char *)this + 440, 0, 0x12uLL);
  if (result != 18)
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -36;
  }
  return result;
}

const char *TGAReadPlugin::debugHeader(TGAReadPlugin *this)
{
  int v2 = (unsigned __int16 *)((char *)this + 443);
  ImageIOLog("    TGA:\n");
  ImageIOLog("                  sizeOfImageID:  %d\n", *((unsigned __int8 *)this + 440));
  ImageIOLog("                     hasPalette:  %d\n", *((unsigned __int8 *)this + 441));
  int v3 = *((unsigned __int8 *)this + 442);
  uint64_t v4 = "Compressed";
  if ((v3 & 8) == 0) {
    uint64_t v4 = "Uncompressed";
  }
  ImageIOLog("                      imageType:  %d = %s+%s\n", v3, off_1E53CCFD8[v3 & 3], v4);
  ImageIOLog("                       palStart:  %d\n", *v2);
  ImageIOLog("                        palSize:  %d\n", v2[1]);
  ImageIOLog("                palBitsPerPixel:  %d\n", *((unsigned __int8 *)this + 447));
  ImageIOLog("                        xOffset:  %d\n", *((unsigned __int16 *)this + 224));
  ImageIOLog("                        yOffset:  %d\n", *((unsigned __int16 *)this + 225));
  ImageIOLog("                          width:  %d\n", *((unsigned __int16 *)this + 226));
  ImageIOLog("                         height:  %d\n", *((unsigned __int16 *)this + 227));
  ImageIOLog("                   bitsPerPixel:  %d\n", *((unsigned __int8 *)this + 456));
  return ImageIOLog("                       attrBits:  0x%.2X = %d alphabits + %d origin\n", *((unsigned __int8 *)this + 457), *((unsigned char *)this + 457) & 0xF, (*((unsigned __int8 *)this + 457) >> 4) & 3);
}

uint64_t TGAReadPlugin::initialize(IIOImageReadSession **this, IIODictionary *a2)
{
  if (*((unsigned char *)this + 341))
  {
    TGAReadPlugin::readHeader(this);
    if (*((unsigned char *)this + 181)) {
      TGAReadPlugin::debugHeader((TGAReadPlugin *)this);
    }
    if (*((unsigned __int8 *)this + 441) >= 2u)
    {
      _cg_jpeg_mem_term("initialize", 141, "*** ERROR: _tga._tgaHeader.hasPalette: %d\n");
    }
    else
    {
      unsigned int v3 = *((unsigned __int8 *)this + 442);
      if (v3 <= 0xB && ((0xE0Fu >> v3) & 1) != 0)
      {
        if (TGAReadPlugin::sanityCheck((TGAReadPlugin *)this, (0x202u >> v3) & 1, (0xE00u >> v3) & 1))
        {
          uint64_t v11 = 0;
          uint64_t v12 = 0;
          uint64_t v13 = 0;
          IIODictionary::IIODictionary((IIODictionary *)&v11);
          IIONumber::IIONumber((IIONumber *)v9, *((unsigned __int8 *)this + 442) > 3u);
          IIODictionary::setObjectForKey((IIODictionary *)&v11, value, @"Compression");
          IIONumber::~IIONumber((IIONumber *)v9);
          IIODictionary::setObjectForKey(this[7], v12, @"{TGA}");
          IIODictionary::~IIODictionary((IIODictionary *)&v11);
          unint64_t v5 = TGAReadPlugin::setupGeometry((TGAReadPlugin *)this);
          unsigned int v6 = *((unsigned __int16 *)this + 121);
          *((_DWORD *)this + 59) = (*((unsigned __int16 *)this + 121)
                                  * (unint64_t)*((unsigned __int16 *)this + 226)
                                  + 7) >> 3;
          this[45] = (IIOImageReadSession *)1;
          *((_WORD *)this + 122) = v6 / *((unsigned __int16 *)this + 120);
          unint64_t v7 = v5 + *((unsigned __int8 *)this + 440) + 18;
          this[24] = (IIOImageReadSession *)v7;
          if (v7 < (unint64_t)IIOImageReadSession::getSize(this[3]))
          {
            unsigned int Size = IIOImageReadSession::getSize(this[3]);
            uint64_t result = 0;
            this[58] = (IIOImageReadSession *)(Size - this[24]);
            *((unsigned char *)this + 472) = (*((unsigned char *)this + 442) & 8) != 0;
            *((unsigned char *)this + 473) = ~(*((unsigned __int8 *)this + 457) >> 5) & 1;
            *((_WORD *)this + 188) = 1;
            return result;
          }
          IIOImageReadSession::getSize(this[3]);
          _cg_jpeg_mem_term("initialize", 199, "*** ERROR: offset (%ld) out of range (%ld)\n");
        }
        else
        {
          _cg_jpeg_mem_term("initialize", 170, "*** ERROR: sanityCheck failed\n");
        }
      }
    }
  }
  kdebug_trace();
  return 4294967246;
}

void sub_1887DB12C(void *a1)
{
}

void sub_1887DB150(_Unwind_Exception *a1)
{
}

uint64_t TGAReadPlugin::sanityCheck(TGAReadPlugin *this, char a2, char a3)
{
  unsigned int v6 = (_WORD *)((char *)this + 443);
  int v7 = *((unsigned __int8 *)this + 442);
  if (!*((unsigned char *)this + 441))
  {
    if (*(unsigned __int16 *)((char *)this + 445) | (unsigned __int16)*v6)
    {
      _cg_jpeg_mem_term("sanityCheck", 487, "*** true-color (no palette) has paletteStart and paletteSize set (%d and %d)\n");
      return 0;
    }
    goto LABEL_8;
  }
  HIDWORD(v8) = *((unsigned __int8 *)this + 447);
  LODWORD(v8) = (HIDWORD(v8) << 24) - 0x8000000;
  if ((v8 >> 27) >= 4u)
  {
    _cg_jpeg_mem_term("sanityCheck", 480, "*** invalid paletteBitsPerPixel (%d)\n");
    return 0;
  }
  if ((v7 | 8) != 9)
  {
    _cg_jpeg_mem_term("sanityCheck", 481, "*** ERROR: unexpected image type (%d) with color palette\n");
    return 0;
  }
  if (*(unsigned __int16 *)((char *)this + 445) - 1 >= 0x1000)
  {
    _cg_jpeg_mem_term("sanityCheck", 482, "*** invalid paletteSize (%d)\n");
    return 0;
  }
  if (!*v6)
  {
LABEL_8:
    if (!*((_WORD *)this + 226))
    {
      _cg_jpeg_mem_term("sanityCheck", 490, "*** invalid width (%d)\n");
      return 0;
    }
    if (!*((_WORD *)this + 227))
    {
      _cg_jpeg_mem_term("sanityCheck", 491, "*** invalid height (%d)\n");
      return 0;
    }
    if (*((unsigned __int8 *)this + 457) >= 0x40u)
    {
      _cg_jpeg_mem_term("sanityCheck", 492, "*** invalid attrBits [%X]\n");
      return 0;
    }
    int v9 = v7 & 3;
    if (v9 == 3)
    {
      int v10 = *((unsigned __int8 *)this + 456);
      if (v10 != 8 && v10 != 16)
      {
        _cg_jpeg_mem_term("sanityCheck", 497, "*** Gray - invalid bitsPerPixel [%d]\n");
        return 0;
      }
    }
    else if (v9 == 2)
    {
      unsigned int v11 = *((unsigned __int8 *)this + 456);
      if (v11 > 0x20 || ((1 << v11) & 0x101018000) == 0)
      {
        _cg_jpeg_mem_term("sanityCheck", 499, "*** RGB - invalid bitsPerPixel [%d]\n");
        return 0;
      }
    }
    else if (v9 == 1 && *((unsigned char *)this + 456) != 8)
    {
      _cg_jpeg_mem_term("sanityCheck", 495, "*** Indexed - invalid bitsPerPixel [%d]\n");
      return 0;
    }
    unsigned int Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
    unint64_t v13 = *((unsigned __int16 *)this + 227) * (unint64_t)*((unsigned __int16 *)this + 226);
    if (a3)
    {
      if (100 * (uint64_t)Size < v13) {
        return 0;
      }
    }
    else
    {
      if ((a2 & 1) == 0) {
        unint64_t v13 = v13 * ((unint64_t)*((unsigned __int8 *)this + 456) >> 3);
      }
      if ((unint64_t)Size < v13) {
        return 0;
      }
    }
    return 1;
  }
  _cg_jpeg_mem_term("sanityCheck", 483, "*** unhandled paletteStart (%d)\n");
  return 0;
}

unint64_t TGAReadPlugin::setupGeometry(TGAReadPlugin *this)
{
  int v2 = *((unsigned char *)this + 442) & 3;
  char v3 = *((unsigned char *)this + 457);
  int v4 = *((unsigned __int16 *)this + 226);
  int v5 = *((unsigned __int16 *)this + 227);
  *((_DWORD *)this + 57) = v4;
  *((_DWORD *)this + 58) = v5;
  unsigned int v6 = *((unsigned __int8 *)this + 456);
  *((_WORD *)this + 121) = v6;
  *((_WORD *)this + 120) = 8;
  unsigned int v7 = v3 & 0xF;
  BOOL v8 = v7 > 4;
  unint64_t v9 = 0x103050505uLL >> (8 * v7);
  if (v8) {
    LOBYTE(v9) = 3;
  }
  if (v6 != 32) {
    LOBYTE(v9) = 0;
  }
  *((unsigned char *)this + 246) = v9;
  *((void *)this + 20) = 0;
  if (v2 == 3) {
    int v10 = 1196573017;
  }
  else {
    int v10 = 1380401696;
  }
  *((_DWORD *)this + 81) = v10;
  if (*((unsigned char *)this + 441)) {
    unint64_t v11 = (*((unsigned __int8 *)this + 447) * (unint64_t)*(unsigned __int16 *)((char *)this + 445)) >> 3;
  }
  else {
    unint64_t v11 = 0;
  }
  switch(v2)
  {
    case 2:
      if (v6 - 15 >= 2)
      {
        if (v6 != 24)
        {
          if (v6 <= 8 && !v11) {
            goto LABEL_29;
          }
          *((unsigned char *)this + 278) = v9;
          if (v6 != 32) {
            break;
          }
LABEL_23:
          *((_WORD *)this + 138) = 4;
          *((_DWORD *)this + 68) = 2097160;
          *((unsigned char *)this + 279) = 0;
          break;
        }
      }
      else
      {
        *((_WORD *)this + 120) = 5;
      }
      *((unsigned char *)this + 278) = 5;
      goto LABEL_23;
    case 1:
      if (TGAReadPlugin::createIndexedColorSpace(this, v11) && *((unsigned __int16 *)this + 121) <= 8u)
      {
        int v4 = *((_DWORD *)this + 57);
        break;
      }
LABEL_29:
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = -50;
    case 3:
      *((unsigned char *)this + 278) = v9;
      if (v6 == 16)
      {
        *((_DWORD *)this + 68) = 1048584;
        *((unsigned char *)this + 278) = 3;
      }
      break;
  }
  int v12 = *((unsigned __int8 *)this + 279);
  int v13 = (v12 << 12) | (*((unsigned __int8 *)this + 280) << 16);
  BOOL v14 = *((unsigned char *)this + 281) != 0;
  *((unsigned char *)this + 310) = *((unsigned char *)this + 278) & 0x1F;
  *((unsigned char *)this + 311) = v12 & 7;
  *((unsigned char *)this + 312) = BYTE2(v13) & 0xF;
  *((unsigned char *)this + 313) = v14;
  *((unsigned char *)this + 350) = 1;
  *((_DWORD *)this + 67) = ((*((unsigned __int16 *)this + 137) + 7) >> 3) * v4;
  *((unsigned char *)this + 344) = 0;
  *((unsigned char *)this + 346) = 0;
  return v11;
}

uint64_t TGAReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12) {
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2);
  }
  if (v2 == 1) {
    return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

BOOL TGAReadPlugin::createIndexedColorSpace(TGAReadPlugin *this, uint64_t a2)
{
  MEMORY[0x1F4188790](this, a2);
  *(void *)&v33[16382] = *MEMORY[0x1E4F143B8];
  if (!v3) {
    return 0;
  }
  uint64_t v4 = v2;
  uint64_t v5 = *(unsigned __int8 *)(v2 + 440);
  if (*(unsigned __int16 *)(v2 + 445) >= 0x100u) {
    size_t v6 = 256;
  }
  else {
    size_t v6 = *(unsigned __int16 *)(v2 + 445);
  }
  int v7 = *(unsigned __int8 *)(v2 + 447);
  BOOL v8 = (char *)malloc_type_calloc(v6, 3uLL, 0x3F1B0C95uLL);
  if (v8)
  {
    unint64_t v9 = v8;
    HIDWORD(v10) = *(unsigned __int8 *)(v4 + 447);
    LODWORD(v10) = (HIDWORD(v10) << 24) - 0x8000000;
    unint64_t v11 = v5 + 18;
    unint64_t v12 = (v6 * v7) >> 3;
    switch((v10 >> 27))
    {
      case 0u:
        bzero(v32, 0x1000uLL);
        if (IIOImageReadSession::getBytesAtOffset(*(IIOImageReadSession **)(v4 + 24), v32, v11, v12) != v12) {
          goto LABEL_28;
        }
        if (v6)
        {
          int v13 = v9 + 2;
          BOOL v14 = v32;
          size_t v15 = v6;
          do
          {
            char v16 = *v14++;
            *int v13 = v16;
            *(v13 - 1) = v16;
            *(v13 - 2) = v16;
            v13 += 3;
            --v15;
          }
          while (v15);
        }
        goto LABEL_26;
      case 1u:
        bzero(v32, 0x2000uLL);
        if (IIOImageReadSession::getBytesAtOffset(*(IIOImageReadSession **)(v4 + 24), v32, v11, v12) != v12) {
          goto LABEL_28;
        }
        if (v6)
        {
          int v17 = v9 + 2;
          uint64_t v18 = (unsigned __int16 *)v32;
          size_t v19 = v6;
          do
          {
            unsigned int v20 = *v18++;
            uint32x2_t v21 = (uint32x2_t)vand_s8((int8x8_t)vdup_n_s32(v20), (int8x8_t)0x3E000007C00);
            int8x8_t v22 = vorr_s8((int8x8_t)vshl_u32(v21, (uint32x2_t)0xFFFFFFFEFFFFFFF9), (int8x8_t)vshl_u32(v21, (uint32x2_t)0xFFFFFFF9FFFFFFF4));
            *(v17 - 1) = v22.i8[4];
            *(v17 - 2) = v22.i8[0];
            *int v17 = (8 * v20) | (v20 >> 2) & 7;
            v17 += 3;
            --v19;
          }
          while (v19);
        }
        goto LABEL_26;
      case 2u:
        if (IIOImageReadSession::getBytesAtOffset(*(IIOImageReadSession **)(v4 + 24), v8, v11, (v6 * v7) >> 3) != v12)goto LABEL_28; {
        if (v6)
        }
        {
          int v23 = v6;
          float v24 = v9;
          do
          {
            char v25 = *v24;
            *float v24 = v24[2];
            v24[2] = v25;
            v24 += 3;
            --v23;
          }
          while (v23);
        }
        goto LABEL_26;
      case 3u:
        bzero(v32, 0x4000uLL);
        if (IIOImageReadSession::getBytesAtOffset(*(IIOImageReadSession **)(v4 + 24), v32, v11, v12) != v12)
        {
LABEL_28:
          free(v9);
          return 0;
        }
        if (v6)
        {
          double v26 = v9 + 2;
          double v27 = v33;
          size_t v28 = v6;
          do
          {
            *(v26 - 2) = *(v27 - 2);
            *(v26 - 1) = *(v27 - 1);
            char v29 = *v27;
            v27 += 4;
            *double v26 = v29;
            v26 += 3;
            --v28;
          }
          while (v28);
        }
LABEL_26:
        uint64_t v30 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
        *(void *)(v4 + 160) = CGColorSpaceCreateIndexed(v30, (v6 - 1), (const unsigned __int8 *)v9);
        CGColorSpaceRelease(v30);
        free(v9);
        break;
      default:
        goto LABEL_26;
    }
  }
  return *(void *)(v4 + 160) != 0;
}

unsigned int *TGAReadPlugin::adjustAlphaIfNeeded(unsigned int *this, char *a2)
{
  unint64_t v2 = this[74];
  if (v2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = this[73];
    uint64_t v5 = this[75];
    size_t v6 = a2 + 3;
    while (!v4)
    {
LABEL_7:
      ++v3;
      v6 += v5;
      if (v3 == v2)
      {
        uint64_t v10 = 0;
        while (!v4)
        {
LABEL_13:
          if (++v10 >= v2) {
            return this;
          }
        }
        unint64_t v11 = &a2[v10 * v5];
        uint64_t v12 = this[73];
        while (!*(_DWORD *)v11)
        {
          v11 += 4;
          if (!--v12) {
            goto LABEL_13;
          }
        }
        uint64_t v13 = 0;
        BOOL v14 = a2 + 3;
        do
        {
          uint64_t v15 = v4;
          char v16 = v14;
          do
          {
            unsigned char *v16 = -1;
            v16 += 4;
            --v15;
          }
          while (v15);
          ++v13;
          v14 += v5;
        }
        while (v13 != v2);
        return this;
      }
    }
    uint64_t v7 = this[73];
    BOOL v8 = (unsigned __int8 *)v6;
    while (1)
    {
      int v9 = *v8;
      v8 += 4;
      if (v9) {
        break;
      }
      if (!--v7) {
        goto LABEL_7;
      }
    }
  }
  return this;
}

uint64_t TGAReadPlugin::decodeRLE(TGAReadPlugin *this, char *a2)
{
  unint64_t v4 = *((unsigned int *)this + 74);
  unint64_t v5 = *((unsigned int *)this + 73);
  uint64_t v6 = *((unsigned int *)this + 75);
  char v7 = *((unsigned char *)this + 442);
  uint64_t v8 = *((unsigned __int8 *)this + 456);
  int v9 = (unsigned __int8 *)malloc_type_malloc(*((void *)this + 58), 0x760A4549uLL);
  if (!v9) {
    return 4294967243;
  }
  uint64_t v10 = v9;
  unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, *((void *)this + 24), *((void *)this + 58));
  if (BytesAtOffset == *((void *)this + 58))
  {
    uint64_t v12 = 0;
    unint64_t v13 = 0;
    unint64_t v14 = (unint64_t)&v10[BytesAtOffset];
    BOOL v15 = (v7 & 3) == 2 && ((v8 + 1) & 0x1F0) == 16;
    unint64_t v16 = 4;
    if (!v15) {
      unint64_t v16 = (unint64_t)(v8 + 1) >> 3;
    }
    if (*((unsigned char *)this + 473)) {
      unint64_t v17 = v4 - 1;
    }
    else {
      unint64_t v17 = 0;
    }
    uint64_t v18 = &a2[v17 * v6];
    size_t v19 = v10;
    do
    {
      if (v4 <= v13) {
        break;
      }
      signed __int8 v20 = *v19;
      uint64_t v21 = (*v19 & 0x7F) + 1;
      if (v12 + v21 > v5 && v12 + v21 + 1 > (v4 - v13) * v5) {
        goto LABEL_46;
      }
      int v22 = v20;
      unint64_t v23 = v20 < 0 ? 0 : (unint64_t)(v8 + 1) >> 3;
      float v24 = (char *)(v19 + 2);
      do
      {
        switch((unint64_t)(v8 + 1) >> 3)
        {
          case 1uLL:
            if ((unint64_t)(v24 - 1) >= v14) {
              goto LABEL_46;
            }
            *uint64_t v18 = *(v24 - 1);
            break;
          case 2uLL:
            if ((unint64_t)v24 >= v14) {
              goto LABEL_46;
            }
            if ((v7 & 3) == 2)
            {
              int v25 = *v24;
              unsigned int v26 = *(v24 - 1);
              v18[2] = (2 * *v24) & 0xF8 | (*v24 >> 4) & 7;
              v18[1] = ((v26 | (v25 << 8)) >> 2) & 0xF8 | ((v26 | (v25 << 8)) >> 7) & 7;
              int v27 = (8 * v26) | (v26 >> 2) & 7;
              goto LABEL_27;
            }
            *uint64_t v18 = *(v24 - 1);
            v18[1] = *v24;
            break;
          case 3uLL:
            if ((unint64_t)(v24 + 1) >= v14) {
              goto LABEL_46;
            }
            v18[2] = v24[1];
            v18[1] = *v24;
            LOBYTE(v27) = *(v24 - 1);
LABEL_27:
            *uint64_t v18 = v27;
            if (v16 == 4) {
              void v18[3] = -1;
            }
            break;
          case 4uLL:
            if ((unint64_t)(v24 + 2) >= v14) {
              goto LABEL_46;
            }
            v18[2] = v24[1];
            v18[1] = *v24;
            *uint64_t v18 = *(v24 - 1);
            void v18[3] = v24[2];
            break;
          default:
            break;
        }
        if (++v12 == v5)
        {
          uint64_t v12 = 0;
          if (*((unsigned char *)this + 473)) {
            unint64_t v28 = v4 - 2 - v13;
          }
          else {
            unint64_t v28 = v13 + 1;
          }
          ++v13;
          uint64_t v18 = &a2[v28 * v6];
        }
        else
        {
          v18 += v16;
        }
        v24 += v23;
        LODWORD(v21) = v21 - 1;
      }
      while (v21);
      unint64_t v29 = v22 < 0 ? (unint64_t)(v8 + 1) >> 3 : 0;
      size_t v19 = (unsigned __int8 *)&v24[v29 - 1];
    }
    while ((unint64_t)v19 < v14);
    if (*((unsigned char *)this + 456) == 32) {
      TGAReadPlugin::adjustAlphaIfNeeded((unsigned int *)this, a2);
    }
    uint64_t v30 = 0;
  }
  else
  {
LABEL_46:
    uint64_t v30 = 4294967243;
  }
  free(v10);
  return v30;
}

uint64_t TGAReadPlugin::decodeUncompressed(TGAReadPlugin *this, char *a2)
{
  uint64_t v4 = *((unsigned int *)this + 66);
  vImagePixelCount v5 = *((unsigned int *)this + 65);
  unint64_t v6 = *((unsigned int *)this + 59);
  size_t v7 = *((unsigned int *)this + 75);
  if (!*((unsigned char *)this + 441) || *((unsigned char *)this + 442) != 1)
  {
    unsigned int v15 = *((unsigned __int8 *)this + 456);
    if (v15 <= 0xF)
    {
      if (v15 == 8)
      {
        if (*((_WORD *)this + 122) == 1 && v4 != 0)
        {
          uint64_t v44 = 0;
          uint64_t v45 = 0;
          uint64_t v46 = v4 - 1;
          while (1)
          {
            uint64_t v47 = *((unsigned char *)this + 473) ? v46 : v45;
            if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &a2[v47 * v7], v44 + *((void *)this + 24), v6) != v6)return 4294967243; {
            ++v45;
            }
            --v46;
            v44 += v6;
            if (v46 == -1) {
              goto LABEL_81;
            }
          }
        }
        goto LABEL_81;
      }
      if (v15 != 15 || *((_WORD *)this + 122) != 3) {
        goto LABEL_81;
      }
      int v9 = (unsigned __int8 *)malloc_type_malloc(2 * v5, 0x5122EA62uLL);
      if (!v4) {
        goto LABEL_80;
      }
      uint64_t v20 = 0;
      while (1)
      {
        int v21 = *((unsigned __int8 *)this + 473);
        if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, *((void *)this + 24) + v20 * 2 * v5, 2 * v5) != 2 * v5)break; {
        if (v5)
        }
        {
          uint64_t v22 = ~v20 + v4;
          if (!v21) {
            uint64_t v22 = v20;
          }
          unint64_t v23 = &a2[v22 * v7 + 3];
          vImagePixelCount v24 = v5;
          int v25 = v9;
          do
          {
            int v26 = *v25;
            *(v23 - 2) = *v25 & 0xF8 | (*v25 >> 5);
            unsigned int v27 = v25[1];
            *(v23 - 3) = ((v27 | (v26 << 8)) >> 3) & 0xF8 | v26 & 7;
            *(v23 - 1) = (4 * v27) & 0xF8 | (v27 >> 3) & 7;
            *unint64_t v23 = -1;
            v23 += 4;
            v25 += 2;
            --v24;
          }
          while (v24);
        }
        if (++v20 == v4) {
          goto LABEL_80;
        }
      }
    }
    else
    {
      if (v15 != 16)
      {
        if (v15 != 24)
        {
          if (v15 == 32 && v4)
          {
            uint64_t v16 = 0;
            uint64_t v17 = 0;
            uint64_t v18 = v4 - 1;
            while (1)
            {
              uint64_t v19 = *((unsigned char *)this + 473) ? v18 : v17;
              if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &a2[v19 * v7], v16 + *((void *)this + 24), v6) != v6)return 4294967243; {
              ++v17;
              }
              --v18;
              v16 += v6;
              if (v18 == -1) {
                goto LABEL_81;
              }
            }
          }
          goto LABEL_81;
        }
        int v9 = (unsigned __int8 *)malloc_type_malloc(*((unsigned int *)this + 75), 0x2154F42EuLL);
        v65.data = v9;
        v65.double height = 1;
        v65.double width = v5;
        v65.rowunint64_t Bytes = v6;
        *(_OWORD *)&v64.data = xmmword_18898C840;
        v64.double width = v5;
        v64.rowunint64_t Bytes = v7;
        if (v4)
        {
          uint64_t v38 = 0;
          uint64_t v39 = 0;
          uint64_t v40 = v4 - 1;
          while (1)
          {
            int v41 = *((unsigned __int8 *)this + 473);
            if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, v38 + *((void *)this + 24), v6) != v6)goto LABEL_94; {
            if (v41)
            }
              uint64_t v42 = v40;
            else {
              uint64_t v42 = v39;
            }
            v64.data = &a2[v42 * v7];
            vImageConvert_RGB888toRGBA8888(&v65, 0, 0xFFu, &v64, 0, 0);
            ++v39;
            --v40;
            v38 += v6;
            if (v40 == -1) {
              goto LABEL_80;
            }
          }
        }
        goto LABEL_80;
      }
      int v28 = *((unsigned __int16 *)this + 122);
      if (v28 != 3)
      {
        if (v28 == 2 && v4)
        {
          uint64_t v58 = 0;
          uint64_t v59 = 0;
          uint64_t v60 = v4 - 1;
          while (1)
          {
            uint64_t v61 = *((unsigned char *)this + 473) ? v60 : v59;
            if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), &a2[v61 * v7], v58 + *((void *)this + 24), v6) != v6)return 4294967243; {
            ++v59;
            }
            --v60;
            v58 += v6;
            if (v60 == -1) {
              goto LABEL_81;
            }
          }
        }
        goto LABEL_81;
      }
      unint64_t v29 = (unsigned __int8 *)malloc_type_malloc(*((unsigned int *)this + 59), 0xC121423uLL);
      int v9 = v29;
      if (!v4) {
        goto LABEL_80;
      }
      uint64_t v30 = 0;
      uint64_t v62 = v29 + 1;
      while (1)
      {
        int v31 = *((unsigned __int8 *)this + 473);
        if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, *((void *)this + 24) + v30 * v6, v6) != v6)break; {
        if (v5)
        }
        {
          uint64_t v32 = ~v30 + v4;
          if (!v31) {
            uint64_t v32 = v30;
          }
          uint64_t v33 = &a2[v32 * v7 + 3];
          uint64_t v34 = v62;
          vImagePixelCount v35 = v5;
          do
          {
            int v36 = *v34;
            unsigned int v37 = *(v34 - 1);
            *(v33 - 1) = (2 * *v34) & 0xF8 | (*v34 >> 4) & 7;
            *(v33 - 2) = ((v37 | (v36 << 8)) >> 2) & 0xF8 | ((v37 | (v36 << 8)) >> 7) & 7;
            *(v33 - 3) = (8 * v37) | (v37 >> 2) & 7;
            char *v33 = -1;
            v33 += 4;
            v34 += 2;
            --v35;
          }
          while (v35);
        }
        if (++v30 == v4) {
          goto LABEL_80;
        }
      }
    }
LABEL_93:
    if (!v9) {
      return 4294967243;
    }
LABEL_94:
    free(v9);
    return 4294967243;
  }
  int v8 = *((unsigned __int8 *)this + 456);
  if (v8 == 16)
  {
    int v9 = (unsigned __int8 *)malloc_type_malloc(*((unsigned int *)this + 59), 0xBB74A9B7uLL);
    if (v4)
    {
      uint64_t v48 = 0;
      LODWORD(v49) = ((2863311531u * (unint64_t)v5) >> 32) & 0xFFFFFFFE;
      if (v49) {
        uint64_t v49 = v49;
      }
      else {
        uint64_t v49 = 1;
      }
      uint64_t v63 = v49;
      do
      {
        int v50 = *((unsigned __int8 *)this + 473);
        if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, *((void *)this + 24) + v48 * v6, v6) != v6)goto LABEL_93; {
        if (v5 >= 3)
        }
        {
          uint64_t v51 = ~v48 + v4;
          if (!v50) {
            uint64_t v51 = v48;
          }
          float v52 = &a2[v51 * v7];
          uint64_t v53 = v63;
          float v54 = v9 + 1;
          do
          {
            int v55 = *v54;
            int v56 = *(v54 - 1);
            *float v52 = (2 * v55) & 0xF8;
            v52[1] = ((v56 | (v55 << 8)) >> 2) & 0xF8;
            v52[2] = 8 * v56;
            v52 += 3;
            v54 += 2;
            --v53;
          }
          while (v53);
        }
      }
      while (++v48 != v4);
    }
LABEL_80:
    free(v9);
    goto LABEL_81;
  }
  if (v8 == 8)
  {
    int v9 = (unsigned __int8 *)malloc_type_malloc(*((unsigned int *)this + 59), 0x6BE6C816uLL);
    if (v4)
    {
      uint64_t v10 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = v4 - 1;
      while (1)
      {
        int v13 = *((unsigned __int8 *)this + 473);
        if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, v10 + *((void *)this + 24), v6) != v6)goto LABEL_93; {
        if (v13)
        }
          uint64_t v14 = v12;
        else {
          uint64_t v14 = v11;
        }
        memcpy(&a2[v14 * v7], v9, v6);
        ++v11;
        --v12;
        v10 += v6;
        if (v12 == -1) {
          goto LABEL_80;
        }
      }
    }
    goto LABEL_80;
  }
LABEL_81:
  if (*((unsigned char *)this + 456) == 32) {
    TGAReadPlugin::adjustAlphaIfNeeded((unsigned int *)this, a2);
  }
  return 0;
}

uint64_t TGAReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  memory_object_size_t v42 = 0;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v8 = *((_DWORD *)this + 51);
    unsigned int v9 = v8 >> 24;
    uint64_t v10 = MEMORY[0x1E4F14390];
    if (v8 < 0)
    {
      int v11 = __maskrune(v9, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
    }
    if (v11) {
      uint64_t v12 = (v8 >> 24);
    }
    else {
      uint64_t v12 = 46;
    }
    unsigned int v13 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      int v14 = __maskrune(v13, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    }
    if (v14) {
      uint64_t v15 = (v8 << 8 >> 24);
    }
    else {
      uint64_t v15 = 46;
    }
    unsigned int v16 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      int v17 = __maskrune(v16, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = ((__int16)v8 >> 8);
    }
    else {
      uint64_t v18 = 46;
    }
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0) {
        goto LABEL_22;
      }
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_22:
      int v19 = *((_DWORD *)this + 51);
LABEL_25:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v12, v15, v18, (char)v19, iioTypeStr[a3], "virtual OSStatus TGAReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    LOBYTE(v19) = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  if (!*((unsigned char *)this + 414)) {
    return 4294967115;
  }
  uint64_t v20 = (IIOImageRead **)*((void *)this + 3);
  if (v20) {
    BOOL v21 = IIOImageReadSession::mapData(v20);
  }
  else {
    BOOL v21 = 0;
  }
  if (a3 == 3)
  {
    uint64_t BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v28) = *((_DWORD *)this + 73);
    double v27 = (double)v28;
    unsigned int v29 = *((_DWORD *)this + 74);
    double v26 = (double)v29;
    memory_object_size_t v25 = *((unsigned int *)this + 75) * (unint64_t)v29;
    BaseAddress = (void *)_ImageIO_Malloc(v25, *((void *)this + 48), &v42, (uint64_t)kImageMalloc_TGA_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4) {
      goto LABEL_54;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    size_t Height = IOSurfaceGetHeight(*a4);
    uint64_t BlockArray = 0;
    memory_object_size_t v25 = IOSurfaceGetBytesPerRow(*a4) * Height;
    memory_object_size_t v42 = v25;
    double v26 = 0.0;
    double v27 = 0.0;
  }
  if (!BaseAddress) {
    goto LABEL_55;
  }
  memset(BaseAddress, 255, v25);
  if (*((unsigned char *)this + 472)) {
    uint64_t v30 = TGAReadPlugin::decodeRLE(this, (char *)BaseAddress);
  }
  else {
    uint64_t v30 = TGAReadPlugin::decodeUncompressed(this, (char *)BaseAddress);
  }
  uint64_t BlockArray = v30;
  if (v30)
  {
    *((_DWORD *)this + 26) = 0;
    if (a3 == 3)
    {
      _ImageIO_Free((unint64_t)BaseAddress, v42);
      if (!v21) {
        return BlockArray;
      }
      goto LABEL_56;
    }
LABEL_55:
    if (!v21) {
      return BlockArray;
    }
    goto LABEL_56;
  }
  if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 152) == 8)
  {
    vImagePixelCount v31 = *((unsigned int *)this + 74);
    dest.data = BaseAddress;
    dest.double height = v31;
    size_t v32 = *((unsigned int *)this + 75);
    dest.double width = *((unsigned int *)this + 73);
    dest.rowunint64_t Bytes = v32;
    if (*((unsigned char *)this + 405))
    {
      *(_DWORD *)permuteMap = 50331906;
      vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
    }
    if (!*((unsigned char *)this + 413) && !*((unsigned char *)this + 405)) {
      vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
    }
  }
  if (a3 != 3)
  {
    IOSurfaceUnlock(*a4, 0, 0);
LABEL_54:
    uint64_t BlockArray = 0;
    goto LABEL_55;
  }
  uint64_t v35 = 0;
  v43.origin.CGFloat x = 0.0;
  v43.origin.CGFloat y = 0.0;
  v43.size.double width = v27;
  v43.size.double height = v26;
  **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v25, v43, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
  if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E4F1DB20]))
  {
    uint64_t v36 = 0;
  }
  else
  {
    v44.origin.CGFloat x = 0.0;
    v44.origin.CGFloat y = 0.0;
    v44.size.double width = v27;
    v44.size.double height = v26;
    *(CGRect *)(&v36 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v44);
    uint64_t v35 = v37;
    double v27 = v38;
    double v26 = v39;
  }
  uint64_t BlockArray = 0;
  *((void *)this + 15) = v35;
  *((void *)this + 16) = v36;
  *((double *)this + 17) = v27;
  *((double *)this + 18) = v26;
  if (v21)
  {
LABEL_56:
    uint64_t v33 = (const char **)*((void *)this + 3);
    if (v33) {
      IIOImageReadSession::unmapData(v33);
    }
  }
  return BlockArray;
}

void HDRFlexGTC_curveFit(uint64_t a1, uint64_t a2, char a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v8 = 0;
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  float v46 = 0.0;
  memset(v65, 0, 128);
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v48 = 0u;
  float v10 = -1.0;
  memset(v47, 0, sizeof(v47));
  float v45 = 0.0;
  do
  {
    v65[v8] = (float)((float)(int)v8 + 0.5) * 0.03125;
    float v11 = binY(a1, v8, *((float *)&a2 + 1));
    float v12 = fmaxf(v11, v10);
    if (a3) {
      float v10 = v12;
    }
    else {
      float v10 = v11;
    }
    *((float *)&v57 + v8++) = v10;
  }
  while (v8 != 32);
  uint64_t v13 = 0;
  do
  {
    uint64_t v14 = v13;
    unint64_t v15 = 31 - v13++;
    unint64_t v16 = 2;
    do
    {
      int v17 = 0;
      LODWORD(v18) = v14 - v16;
      if (v14 >= v16) {
        unint64_t v18 = v18;
      }
      else {
        unint64_t v18 = 0;
      }
      LODWORD(v19) = v16 + v13;
      if (v15 <= v16) {
        unint64_t v19 = 32;
      }
      else {
        unint64_t v19 = v19;
      }
      if (v19 > v18)
      {
        int v17 = 0;
        uint64_t v20 = (int *)(a1 + 140 * v18);
        unint64_t v21 = v18;
        do
        {
          int v22 = *v20;
          v20 += 35;
          v17 += v22;
          ++v21;
        }
        while (v21 < v19);
      }
      if (v16 > 0xE) {
        break;
      }
      ++v16;
    }
    while (v17 < 201);
    linearRegression(&v65[v18], (float *)&v57 + v18, v19 - v18, &v46, &v45);
    float v23 = v45;
    float v24 = v46 + (float)(v45 * v65[v14]);
    *((float *)&v49 + v14) = v24;
    *((float *)v47 + v14) = v23;
    if (v24 > 1.0)
    {
      *((_DWORD *)&v49 + v14) = 1065353216;
      *((_DWORD *)v47 + v14) = 0;
    }
  }
  while (v13 != 32);
  int v25 = 0;
  long long v61 = v53;
  long long v62 = v54;
  long long v63 = v55;
  long long v64 = v56;
  long long v57 = v49;
  long long v58 = v50;
  long long v59 = v51;
  long long v60 = v52;
  *(_DWORD *)a4 = 0;
  int v26 = v47[0];
  *(float *)(a4 + 4) = fminf(fmaxf(*(float *)&v49 + (float)(*(float *)v47 * -0.015625), 0.0), 1.0);
  *(_DWORD *)(a4 + 8) = v26;
  uint64_t v27 = a4 + 28;
  int v28 = 1;
  do
  {
    unsigned int v44 = v28;
    uint64_t v29 = v27;
    int v30 = v25 + 2;
    LODWORD(v31) = v25 + 2;
    if (v25 <= 29)
    {
      uint64_t v31 = v30;
      if (v30 <= 31) {
        uint64_t v32 = 31;
      }
      else {
        uint64_t v32 = v30;
      }
      int v33 = 3;
      while (1)
      {
        *(float *)(a4 + 28) = (float)((float)(int)v31 + 0.5) * 0.03125;
        *(_DWORD *)(a4 + 32) = *((_DWORD *)&v49 + v31);
        *(_DWORD *)(a4 + 36) = *((_DWORD *)v47 + v31);
        computeCubic(a4);
        float v34 = 0.0;
        if (v31 >= v25)
        {
          float v34 = 0.0;
          int v35 = v25;
          uint64_t v36 = (float *)&v57 + v25;
          int v37 = v33;
          do
          {
            float v38 = *v36++;
            float v39 = *(float *)(a4 + 24)
                + (*(float *)(a4 + 20)
                 + (*(float *)(a4 + 16) + *(float *)(a4 + 12) * (float)((float)((float)v35 + 0.5) * 0.03125))
                 * (float)((float)((float)v35 + 0.5) * 0.03125))
                * (float)((float)((float)v35 + 0.5) * 0.03125);
            float v34 = v34 + (float)((float)(v38 - v39) * (float)(v38 - v39));
            ++v35;
            --v37;
          }
          while (v37);
        }
        if (sqrtf(v34 / (float)(v31 - v25 + 1)) > *(float *)&a2) {
          break;
        }
        ++v33;
        if (v31++ == v32)
        {
          LODWORD(v31) = 32;
          break;
        }
      }
    }
    if ((int)v31 >= 32) {
      int v25 = 32;
    }
    else {
      int v25 = v31;
    }
    uint64_t v41 = v25 - 1;
    *(float *)(a4 + 28) = (float)((float)(int)v41 + 0.5) * 0.03125;
    *(_DWORD *)(a4 + 32) = *((_DWORD *)&v49 + v41);
    *(_DWORD *)(a4 + 36) = *((_DWORD *)v47 + v41);
    computeCubic(a4);
    if (v25 > 31) {
      break;
    }
    int v28 = v44 + 1;
    uint64_t v27 = v29 + 28;
    a4 = v29;
  }
  while (v44 < 0x1E);
  *(_DWORD *)(v29 + 28) = 1065353216;
  int v42 = HIDWORD(v48);
  *(float *)(v29 + 32) = fminf(fmaxf(*((float *)&v56 + 3) + (float)(*((float *)&v48 + 3) * 0.015625), 0.0), 1.0);
  *(_DWORD *)(v29 + 36) = v42;
  computeCubic(v29);
  *a5 = v44 + 2;
}

float HDRFlexGTC_fillTable(float *a1, int a2, uint64_t a3, int a4, float result)
{
  size_t v7 = a1;
  int v8 = a2 - 1;
  if (a2 >= 2)
  {
    uint64_t v9 = (a2 - 1);
    uint64_t v10 = (uint64_t)a1;
    do
    {
      uint64_t result = computeCubic(v10);
      v10 += 28;
      --v9;
    }
    while (v9);
  }
  if ((a4 & 0x80000000) == 0)
  {
    uint64_t v11 = 0;
    unint64_t v12 = (unint64_t)&v7[7 * v8];
    float v13 = v7[7];
    uint64_t result = (float)a4;
    do
    {
      float v14 = (float)(int)v11 / result;
      BOOL v15 = v14 > v13;
      if (v14 > v13 && (unint64_t)(v7 + 7) < v12)
      {
        int v17 = v7 + 14;
        unint64_t v18 = v7 + 14;
        do
        {
          float v19 = *v18;
          v18 += 7;
          float v13 = v19;
          BOOL v15 = v14 > v19;
          BOOL v20 = v14 <= v19 || (unint64_t)v17 >= v12;
          int v17 = v18;
        }
        while (!v20);
        size_t v7 = v18 - 14;
      }
      if (v15) {
        float v14 = v13;
      }
      float v21 = v7[6] + (v7[5] + (v7[4] + v7[3] * v14) * v14) * v14;
      *(float *)(a3 + 4 * v11++) = v21;
    }
    while (v11 != a4 + 1);
  }
  return result;
}

float computeCubic(uint64_t a1)
{
  double v1 = *(float *)a1;
  double v2 = *(float *)(a1 + 4);
  double v3 = *(float *)(a1 + 8);
  double v4 = *(float *)(a1 + 28);
  double v5 = *(float *)(a1 + 36);
  double v6 = (v3 + v5 - (*(float *)(a1 + 32) - v2 + *(float *)(a1 + 32) - v2) / (v4 - v1)) / ((v1 - v4) * (v1 - v4));
  double v7 = (v5 - v3) / (v4 - v1 + v4 - v1) + (v1 + v4) * -1.5 * v6;
  double v8 = v3 + v1 * -3.0 * v1 * v6 + v1 * -2.0 * v7;
  double v9 = v2 + -(v1 * v1) * v1 * v6 + -(v1 * v1) * v7 - v1 * v8;
  *(float *)&double v2 = v6;
  *(float *)&double v7 = v7;
  *(_DWORD *)(a1 + 12) = LODWORD(v2);
  *(_DWORD *)(a1 + 16) = LODWORD(v7);
  *(float *)&double v2 = v8;
  float result = v9;
  *(_DWORD *)(a1 + 20) = LODWORD(v2);
  *(float *)(a1 + 24) = result;
  return result;
}

BOOL HDRFlexGTC_fillGaps(uint64_t a1, uint64_t a2, char a3)
{
  LOBYTE(v4) = 0;
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  float v5 = *((float *)&a2 + 1);
  int v46 = 0;
  double v6 = (char *)v49;
  int v7 = -1;
  double v8 = (int *)a1;
  memset(v49, 0, sizeof(v49));
  do
  {
    int v9 = *v8;
    if (v4)
    {
      if (v9)
      {
        int v4 = 0;
        *((_DWORD *)v6 + 1) = v7;
        v6 += 8;
        goto LABEL_10;
      }
    }
    else
    {
      if (v9)
      {
        int v4 = 0;
        goto LABEL_10;
      }
      if (v6 - (char *)v49 >= 121)
      {
        puts("too many gaps");
        LODWORD(v10) = 16;
LABEL_16:
        BOOL v11 = 0;
        int v12 = 0;
        uint64_t v44 = a1 + 12;
        for (uint64_t i = (int *)v49; ; i += 2)
        {
          int v14 = *i;
          int v15 = i[1];
          int v16 = v15 + 1;
          int v17 = *i - 1;
          if (*i < 1)
          {
            if (v15 > 30)
            {
              puts("no gain samples");
              return v11;
            }
            if (!slopeScan(a1, v16, 1, (_DWORD *)&v48 + 1, &v48)) {
              return v11;
            }
            multiBinLinearRegression(a1, SHIDWORD(v48), v48, (_DWORD *)&v47 + 1, &v47, (float *)&v46, a3 & 1, v5);
            int v25 = *i;
            int v26 = i[1];
            if (*i <= v26)
            {
              uint64_t v27 = v47;
              int v28 = v46;
              uint64_t v29 = v44 + 140 * v25;
              int v30 = v26 + 1;
              do
              {
                float v31 = *((float *)&v27 + 1) + (float)(*(float *)&v27 * (float)((float)((float)v25 + 0.5) * 0.03125));
                int v32 = vcvtms_s32_f32(v31 * 32.0);
                *(_DWORD *)(v29 - 12) = 1;
                if (v32 >= 31) {
                  int v32 = 31;
                }
                *(float *)(v29 - 8) = v31;
                *(_DWORD *)(v29 - 4) = v28;
                *(_DWORD *)(v29 + 4 * (v32 & ~(v32 >> 31))) = 1;
                ++v25;
                v29 += 140;
              }
              while (v30 != v25);
            }
          }
          else if (v15 > 30)
          {
            if (!slopeScan(a1, v14 - 1, -1, (_DWORD *)&v48 + 1, &v48)) {
              return v11;
            }
            multiBinLinearRegression(a1, SHIDWORD(v48), v48, (_DWORD *)&v47 + 1, &v47, (float *)&v46, a3 & 1, v5);
            float v33 = (float)((float)v17 + 0.5) * 0.03125;
            float v34 = *((float *)&v47 + 1);
            float v35 = *(float *)&v47;
            if ((float)(*((float *)&v47 + 1) + *(float *)&v47) <= 1.0)
            {
              if (*(float *)&v47 < 0.0)
              {
                float v34 = *((float *)&v47 + 1) + (float)(*(float *)&v47 * v33);
                *((float *)&v47 + 1) = v34;
                LODWORD(v47) = 0;
                float v35 = 0.0;
              }
            }
            else
            {
              float v35 = fmaxf((float)(1.0 - (float)(*((float *)&v47 + 1) + (float)(*(float *)&v47 * v33))) / (float)(1.0 - v33), 0.0);
              float v34 = 1.0 - v35;
              *(float *)&uint64_t v47 = v35;
              *((float *)&v47 + 1) = 1.0 - v35;
            }
            int v36 = *i;
            int v37 = i[1];
            if (*i <= v37)
            {
              int v38 = v46;
              uint64_t v39 = v44 + 140 * v36;
              int v40 = v37 + 1;
              do
              {
                float v41 = v34 + (float)(v35 * (float)((float)((float)v36 + 0.5) * 0.03125));
                int v42 = vcvtms_s32_f32(v41 * 32.0);
                *(_DWORD *)(v39 - 12) = 50;
                if (v42 >= 31) {
                  int v42 = 31;
                }
                *(float *)(v39 - 8) = v41;
                *(_DWORD *)(v39 - 4) = v38;
                *(_DWORD *)(v39 + 4 * (v42 & ~(v42 >> 31))) = 1;
                ++v36;
                v39 += 140;
              }
              while (v40 != v36);
            }
          }
          else if (v15 >= v14)
          {
            float32x2_t v18 = *(float32x2_t *)(a1 + 140 * v17 + 4);
            float32x2_t v19 = vsub_f32(*(float32x2_t *)(a1 + 140 * v16 + 4), v18);
            uint64_t v20 = v44 + 140 * v14;
            int v21 = v15 - v14;
            int v22 = -1;
            do
            {
              float32x2_t v23 = vmla_n_f32(v18, v19, (float)(v22 + 2) / (float)(v16 - v17));
              *(_DWORD *)(v20 - 12) = 1;
              int v24 = vcvtms_s32_f32(32.0 * v23.f32[0]);
              if (v24 >= 31) {
                int v24 = 31;
              }
              *(float32x2_t *)(v20 - 8) = v23;
              *(_DWORD *)(v20 + 4 * (v24 & ~(v24 >> 31))) = 1;
              v20 += 140;
              ++v22;
            }
            while (v21 != v22);
          }
          BOOL v11 = ++v12 >= (int)v10;
          if (v12 == v10) {
            return v11;
          }
        }
      }
      *(_DWORD *)double v6 = v7 + 1;
    }
    int v4 = 1;
LABEL_10:
    v8 += 35;
    ++v7;
  }
  while (v7 != 31);
  if (v4)
  {
    *((_DWORD *)v6 + 1) = 31;
    v6 += 8;
  }
  unint64_t v10 = (unint64_t)(v6 - (char *)v49) >> 3;
  if ((int)v10 >= 1) {
    goto LABEL_16;
  }
  return 1;
}

float binY(uint64_t a1, int a2, float a3)
{
  float v3 = (float)(a3 / 100.0) * (float)*(unsigned int *)(a1 + 140 * a2);
  uint64_t v4 = 0;
  if (v3 == 0.0)
  {
    while (!*(_DWORD *)(a1 + 140 * a2 + 12 + 4 * v4))
    {
      if (++v4 == 32) {
        return 0.0;
      }
    }
    float v9 = (float)(int)v4;
    return v9 * 0.03125;
  }
  else
  {
    int v5 = 0;
    do
    {
      int v6 = *(_DWORD *)(a1 + 140 * a2 + 12 + 4 * v4);
      if (v3 >= (float)v5 && v3 <= (float)(v6 + v5))
      {
        float v9 = (float)((float)(v3 - (float)v5) / (float)v6) + (float)(int)v4;
        return v9 * 0.03125;
      }
      ++v4;
      v5 += v6;
    }
    while (v4 != 32);
    return 0.0;
  }
}

float linearRegression(float *a1, float *a2, int a3, float *a4, float *a5)
{
  if (a3 <= 0)
  {
    float v15 = 0.0;
    float v16 = 0.0 / (float)a3;
    float v13 = v16;
    float v14 = 0.0;
  }
  else
  {
    uint64_t v5 = a3;
    float v6 = 0.0;
    uint64_t v7 = a3;
    double v8 = a2;
    float v9 = a1;
    float v10 = 0.0;
    do
    {
      float v11 = *v8++;
      float v10 = v10 + v11;
      float v12 = *v9++;
      float v6 = v6 + v12;
      --v7;
    }
    while (v7);
    float v13 = v10 / (float)a3;
    float v14 = 0.0;
    float v15 = 0.0;
    float v16 = v6 / (float)a3;
    do
    {
      float v17 = *a1++;
      float v18 = v17 - v16;
      float v14 = v14 + (float)(v18 * v18);
      float v19 = *a2++;
      float v15 = v15 + (float)((float)(v19 - v13) * v18);
      --v5;
    }
    while (v5);
  }
  float v20 = v15 / v14;
  BOOL v21 = v14 == 0.0;
  float v22 = 0.0;
  if (!v21) {
    float v22 = v20;
  }
  float result = v13 - (float)(v22 * v16);
  *a4 = result;
  *a5 = v22;
  return result;
}

uint64_t slopeScan(uint64_t a1, int a2, int a3, _DWORD *a4, _DWORD *a5)
{
  if (a3 == 1) {
    uint64_t v5 = 32;
  }
  else {
    uint64_t v5 = -1;
  }
  int v6 = *(_DWORD *)(a1 + 140 * a2);
  int v7 = a3 + a2;
  uint64_t v8 = a3 + (uint64_t)a2;
  uint64_t v9 = v5 - v8;
  float v10 = (int *)(a1 + 140 * v8);
  int v11 = 1;
  do
  {
    int v12 = v7;
    if (!v9) {
      break;
    }
    if (*v10 > 0) {
      ++v11;
    }
    v6 += *v10;
    v7 += a3;
    v9 -= a3;
    v10 += 35 * a3;
  }
  while (v6 < 200 || v11 < 5);
  BOOL v14 = v6 <= 199 || v11 <= 4;
  uint64_t v15 = !v14;
  if (v14)
  {
    puts("too few samples");
  }
  else
  {
    if (a3 <= 0) {
      int v16 = v12;
    }
    else {
      int v16 = a2;
    }
    *a4 = v16;
    if (a3 <= 0) {
      int v17 = a2;
    }
    else {
      int v17 = v12;
    }
    *a5 = v17;
  }
  return v15;
}

void multiBinLinearRegression(uint64_t a1, int a2, int a3, _DWORD *a4, _DWORD *a5, float *a6, int a7, float a8)
{
  int v11 = 0;
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v31 = 0;
  memset(v33, 0, 128);
  memset(v32, 0, sizeof(v32));
  if (a2 <= a3)
  {
    int v13 = a2;
    int v11 = 0;
    int v15 = a3 + 1;
    uint64_t v16 = 140 * a2;
    float v17 = -1.0;
    float v18 = v33;
    float v19 = (float *)v32;
    do
    {
      if (*(_DWORD *)(a1 + v16))
      {
        *v18++ = (float)((float)v13 + 0.5) * 0.03125;
        float v20 = binY(a1, v13, a8);
        float v21 = fmaxf(v20, v17);
        if (a7) {
          float v17 = v21;
        }
        else {
          float v17 = v20;
        }
        *v19++ = v17;
        ++v11;
      }
      ++v13;
      v16 += 140;
    }
    while (v15 != v13);
  }
  linearRegression(v33, (float *)v32, v11, (float *)&v31 + 1, (float *)&v31);
  uint64_t v22 = v31;
  *a4 = HIDWORD(v31);
  *a5 = v22;
  if (v11 < 1)
  {
    float v24 = 0.0;
  }
  else
  {
    uint64_t v23 = v11;
    float v24 = 0.0;
    int v25 = (float *)v32;
    int v26 = v33;
    do
    {
      float v27 = *v26++;
      float v28 = *((float *)&v22 + 1) + (float)(*(float *)&v22 * v27);
      float v29 = *v25++;
      float v24 = v24 + (float)((float)(v29 - v28) * (float)(v29 - v28));
      --v23;
    }
    while (v23);
  }
  *a6 = sqrtf(v24 / (float)v11);
}

uint64_t _TIFFMultiply32(uint64_t a1, unsigned int a2, unsigned int a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3 || ((a3 * (unint64_t)a2) & 0xFFFFFFFF00000000) == 0) {
    return a3 * a2;
  }
  TIFFErrorExtR(a1, a4, "Integer overflow in %s", (uint64_t)a4, a5, a6, a7, a8, (char)a4);
  return 0;
}

unint64_t _TIFFMultiply64(uint64_t a1, unint64_t a2, unint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3 || is_mul_ok(a3, a2)) {
    return a3 * a2;
  }
  TIFFErrorExtR(a1, a4, "Integer overflow in %s", (uint64_t)a4, a5, a6, a7, a8, (char)a4);
  return 0;
}

uint64_t _TIFFMultiplySSize(uint64_t a1, int64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 < 1 || a3 <= 0)
  {
    uint64_t v8 = 0;
    if (a1 && a4)
    {
      TIFFErrorExtR(a1, a4, "Invalid argument to _TIFFMultiplySSize() in %s", (uint64_t)a4, a5, a6, a7, a8, (char)a4);
      return 0;
    }
  }
  else
  {
    if (0x7FFFFFFFFFFFFFFFuLL / a3 >= a2) {
      return a3 * a2;
    }
    uint64_t v8 = 0;
    if (a1 && a4)
    {
      TIFFErrorExtR(a1, a4, "Integer overflow in %s", (uint64_t)a4, a5, a6, a7, a8, (char)a4);
      return 0;
    }
  }
  return v8;
}

uint64_t _TIFFCastUInt64ToSSize(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 < 0)
  {
    a2 = 0;
    if (a1)
    {
      if (a3)
      {
        TIFFErrorExtR(a1, a3, "Integer overflow", a4, a5, a6, a7, a8, vars0);
        return 0;
      }
    }
  }
  return a2;
}

void *_TIFFCheckRealloc(const char **a1, char *a2, int64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a5;
  if (a3 < 1
    || a4 < 1
    || ((v11 = a4 * a3, 0x7FFFFFFFFFFFFFFFuLL / a4 >= a3) ? (BOOL v12 = v11 == 0) : (BOOL v12 = 1),
        v12 || (float result = _TIFFreallocExt(a1, a2, v11, a4, a5, a6, a7, a8)) == 0))
  {
    TIFFErrorExtR((uint64_t)a1, *a1, "Failed to allocate memory for %s (%lld elements of %lld bytes each)", a4, a5, a6, a7, a8, v8);
    return 0;
  }
  return result;
}

void *_TIFFCheckMalloc(const char **a1, int64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _TIFFCheckRealloc(a1, 0, a2, a3, a4, a6, a7, a8);
}

uint64_t TIFFVGetFieldDefaulted(uint64_t a1, uint64_t a2, _DWORD **a3)
{
  int v3 = a2;
  uint64_t result = TIFFVGetField((void *)a1, a2, (uint64_t)a3);
  if (result) {
    return 1;
  }
  if (v3 <= 331)
  {
    if (v3 <= 273)
    {
      if (v3 > 262)
      {
        if (v3 == 263)
        {
          LOWORD(v12) = *(_WORD *)(a1 + 124);
        }
        else
        {
          if (v3 != 266) {
            return result;
          }
          LOWORD(v12) = *(_WORD *)(a1 + 126);
        }
      }
      else
      {
        if (v3 == 254)
        {
          int v20 = *(_DWORD *)(a1 + 112);
LABEL_46:
          **a3 = v20;
          return 1;
        }
        if (v3 != 258) {
          return result;
        }
        LOWORD(v12) = *(_WORD *)(a1 + 116);
      }
    }
    else
    {
      if (v3 <= 295)
      {
        switch(v3)
        {
          case 274:
            LOWORD(v12) = *(_WORD *)(a1 + 128);
            goto LABEL_48;
          case 277:
            LOWORD(v12) = *(_WORD *)(a1 + 130);
            goto LABEL_48;
          case 278:
            int v20 = *(_DWORD *)(a1 + 132);
            goto LABEL_46;
          case 280:
            LOWORD(v12) = *(_WORD *)(a1 + 136);
            goto LABEL_48;
          case 281:
            unsigned int v21 = *(unsigned __int16 *)(a1 + 116);
            if (v21 <= 0x10) {
              int v22 = ~(-1 << v21);
            }
            else {
              LOWORD(v22) = -1;
            }
            if (*(_WORD *)(a1 + 116)) {
              LOWORD(v12) = v22;
            }
            else {
              LOWORD(v12) = 0;
            }
            goto LABEL_48;
          case 284:
            LOWORD(v12) = *(_WORD *)(a1 + 170);
            goto LABEL_48;
          default:
            return result;
        }
        return result;
      }
      if (v3 > 316)
      {
        if (v3 != 317)
        {
          if (v3 != 318) {
            return result;
          }
          *(void *)*a3 = &TIFFVGetFieldDefaulted_whitepoint;
          return 1;
        }
        uint64_t v23 = *(int **)(a1 + 1096);
        if (!v23)
        {
          TIFFErrorExtR(a1, *(const char **)a1, "Cannot get \"Predictor\" tag as plugin is not configured", v7, v8, v9, v10, v11, v24);
          uint64_t result = 0;
          *(_WORD *)*a3 = 0;
          return result;
        }
        int v12 = *v23;
      }
      else
      {
        if (v3 != 296)
        {
          if (v3 != 301) {
            return result;
          }
          uint64_t v13 = *(void *)(a1 + 344);
          if (!v13)
          {
            if (!TIFFDefaultTransferFunction((void *)a1, a1 + 72, v6, v7, v8, v9, v10, v11))
            {
              TIFFErrorExtR(a1, *(const char **)a1, "No space for \"TransferFunction\" tag", v14, v15, v16, v17, v18, v24);
              return 0;
            }
            uint64_t v13 = *(void *)(a1 + 344);
          }
          float v19 = (void **)a3;
          int v26 = (void **)(a3 + 1);
          **float v19 = v13;
          if (*(unsigned __int16 *)(a1 + 130) - *(unsigned __int16 *)(a1 + 212) >= 2)
          {
            **int v26 = *(void *)(a1 + 352);
            *v26[1] = *(void *)(a1 + 360);
          }
          return 1;
        }
        LOWORD(v12) = *(_WORD *)(a1 + 168);
      }
    }
LABEL_48:
    *(_WORD *)*a3 = v12;
    return 1;
  }
  switch(v3)
  {
    case 32995:
      LOWORD(v12) = *(_WORD *)(a1 + 212) == 1 && **(_WORD **)(a1 + 216) == 1;
      goto LABEL_48;
    case 32996:
      LOWORD(v12) = *(_WORD *)(a1 + 118) - 1;
      goto LABEL_48;
    case 32997:
      int v20 = *(_DWORD *)(a1 + 96);
      goto LABEL_46;
    case 32998:
      int v20 = *(_DWORD *)(a1 + 108);
      goto LABEL_46;
    default:
      return result;
  }
  return result;
}

uint64_t TIFFDefaultTransferFunction(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)(a2 + 272) = 0;
  *(void *)(a2 + 280) = 0;
  *(void *)(a2 + 288) = 0;
  unsigned int v8 = *(unsigned __int16 *)(a2 + 44);
  if (v8 > 0x3D) {
    return 0;
  }
  uint64_t v12 = a2 + 272;
  uint64_t v13 = 2 << v8;
  uint64_t result = (uint64_t)_TIFFmallocExt(a1, 2 << v8, a3, a4, a5, a6, a7, a8);
  *(void *)uint64_t v12 = result;
  if (result)
  {
    uint64_t v20 = result;
    *(_WORD *)uint64_t result = 0;
    if (v8)
    {
      unint64_t v21 = 0;
      uint64_t v22 = 1 << v8;
      if ((unint64_t)(1 << v8) <= 2) {
        uint64_t v22 = 2;
      }
      uint64x2_t v45 = (uint64x2_t)vdupq_n_s64(v22 - 2);
      double v23 = (double)(1 << v8) + -1.0;
      uint64_t v24 = v22 & 0x7FFFFFFFFFFFFFFELL;
      __asm { FMOV            V0.2D, #0.5 }
      float64x2_t v43 = _Q0;
      float64x2_t v44 = (float64x2_t)vdupq_n_s64(0x40EFFFE000000000uLL);
      do
      {
        int32x2_t v47 = vmovn_s64((int64x2_t)vcgeq_u64(v45, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v21), (int8x16_t)xmmword_18898C840)));
        unint64_t v30 = v21 + 2;
        long double v46 = pow((double)(uint64_t)(v21 + 2) / v23, 2.2);
        v31.f64[0] = pow((double)(uint64_t)(v21 + 1) / v23, 2.2);
        v31.f64[1] = v46;
        float64x2_t v32 = vrndmq_f64(vmlaq_f64(v43, v44, v31));
        if (v47.i8[0]) {
          *(_WORD *)(v20 + 2 * v21 + 2) = (int)v32.f64[0];
        }
        if (v47.i8[4]) {
          *(_WORD *)(v20 + 2 * v21 + 4) = (int)v32.f64[1];
        }
        v21 += 2;
      }
      while (v30 != v24);
    }
    if (*(unsigned __int16 *)(a2 + 58) - *(unsigned __int16 *)(a2 + 140) < 2) {
      return 1;
    }
    float v33 = _TIFFmallocExt(a1, v13, v14, v15, v16, v17, v18, v19);
    *(void *)(a2 + 280) = v33;
    if (v33)
    {
      _TIFFmemcpy(v33, *(const void **)(a2 + 272), v13);
      int v40 = _TIFFmallocExt(a1, v13, v34, v35, v36, v37, v38, v39);
      *(void *)(a2 + 288) = v40;
      if (v40)
      {
        _TIFFmemcpy(v40, *(const void **)v12, v13);
        return 1;
      }
    }
    if (*(void *)v12) {
      _TIFFfreeExt((uint64_t)a1, *(char **)v12);
    }
    float v41 = *(char **)(a2 + 280);
    if (v41) {
      _TIFFfreeExt((uint64_t)a1, v41);
    }
    int v42 = *(char **)(a2 + 288);
    if (v42) {
      _TIFFfreeExt((uint64_t)a1, v42);
    }
    uint64_t result = 0;
    *(void *)uint64_t v12 = 0;
    *(void *)(v12 + 8) = 0;
    *(void *)(v12 + 16) = 0;
  }
  return result;
}

uint64_t TIFFDefaultRefBlackWhite(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = (uint64_t)_TIFFmallocExt(a1, 24, a3, a4, a5, a6, a7, a8);
  *(void *)(a2 + 296) = result;
  if (result)
  {
    if (*(_WORD *)(a2 + 50) == 6)
    {
      *(void *)(result + 16) = 0x437F000043000000;
      *(_OWORD *)uint64_t result = xmmword_1889AD6C0;
    }
    else
    {
      float v10 = (float)~(-1 << *(_WORD *)(a2 + 44));
      *(_DWORD *)uint64_t result = 0;
      *(float *)(result + 4) = v10;
      *(_DWORD *)(result + 8) = 0;
      *(float *)(result + 12) = v10;
      *(_DWORD *)(result + 16) = 0;
      *(float *)(result + 20) = v10;
    }
    return 1;
  }
  return result;
}

uint64_t _cg_TIFFGetFieldDefaulted(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _DWORD *a9)
{
  return TIFFVGetFieldDefaulted(a1, a2, &a9);
}

float _TIFFClampDoubleToFloat(double a1)
{
  if (a1 > 3.40282347e38) {
    return 3.4028e38;
  }
  if (a1 < -3.40282347e38) {
    return -3.4028e38;
  }
  return a1;
}

BOOL _TIFFSeekOK(uint64_t a1, uint64_t a2)
{
  return (a2 & 0x8000000000000000) == 0
      && (*(uint64_t (**)(void))(a1 + 1224))(*(void *)(a1 + 1200)) == a2;
}

void ASTCReadPlugin::ASTCReadPlugin(uint64_t a1, uint64_t a2)
{
}

uint64_t ASTCReadPlugin::loadDataFromXPCObject(ASTCReadPlugin *this, void *a2)
{
  uint64_t DataFromXPCObject = CommonASTCReadPlugin::loadDataFromXPCObject(this, a2);
  if (!DataFromXPCObject)
  {
    size_t length = 0;
    data = (char *)xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_astc", &length);
    if (length == 22)
    {
      uint64_t DataFromXPCObject = 0;
      long long v6 = *(_OWORD *)data;
      *(void *)((char *)this + 502) = *(void *)(data + 14);
      *(_OWORD *)((char *)this + 488) = v6;
    }
    else
    {
      uint64_t DataFromXPCObject = 4294967246;
    }
    uint64_t v7 = *((void *)this + 59);
    if (v7) {
      (*(void (**)(uint64_t, void *))(*(void *)v7 + 16))(v7, a2);
    }
  }
  return DataFromXPCObject;
}

uint64_t ASTCReadPlugin::saveDataToXPCObject(ASTCReadPlugin *this, void *a2)
{
  uint64_t v4 = CommonASTCReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4)
  {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_astc", (char *)this + 488, 0x16uLL);
    uint64_t v5 = *((void *)this + 59);
    if (v5) {
      (*(void (**)(uint64_t, void *))(*(void *)v5 + 24))(v5, a2);
    }
  }
  return v4;
}

uint64_t ASTCReadPlugin::decodeImageData(ASTCReadPlugin *this, unsigned __int8 *a2)
{
  uint64_t v4 = (void *)*((void *)this + 59);
  if (v4) {
  vImagePixelCount v5 = *((unsigned int *)this + 65);
  }
  vImagePixelCount v6 = *((unsigned int *)this + 66);
  size_t v7 = *((unsigned int *)this + 75);
  v10.data = a2;
  v10.double height = v6;
  v10.double width = v5;
  v10.rowunint64_t Bytes = v7;
  unsigned int v8 = (IIOImageReadSession *)*((void *)this + 3);
  if (v8) {
    return ASTCTextureImp::decodeASTCtoRGBX((ASTCTextureImp *)v4, v8, &v10, *((unsigned __int8 *)this + 310), *((unsigned char *)this + 405) == 0);
  }
  else {
    return 0;
  }
}

uint64_t ASTCReadPlugin::decodeImageImp(uint64_t a1, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  v63[0] = 0;
  unsigned int v8 = *(const void **)(a1 + 472);
  if (v8) {
  else
  }
    uint64_t v9 = 0;
  uint64_t v62 = 0;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v10 = *(_DWORD *)(a1 + 204);
    unsigned int v11 = v10 >> 24;
    uint64_t v12 = MEMORY[0x1E4F14390];
    if (v10 < 0)
    {
      int v13 = __maskrune(v11, 0x40000uLL);
      int v10 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      int v13 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v11 + 60) & 0x40000;
    }
    if (v13) {
      uint64_t v14 = (v10 >> 24);
    }
    else {
      uint64_t v14 = 46;
    }
    unsigned int v15 = v10 << 8 >> 24;
    if (v10 << 8 < 0)
    {
      int v16 = __maskrune(v15, 0x40000uLL);
      int v10 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      int v16 = *(_DWORD *)(v12 + 4 * v15 + 60) & 0x40000;
    }
    if (v16) {
      uint64_t v17 = (v10 << 8 >> 24);
    }
    else {
      uint64_t v17 = 46;
    }
    unsigned int v18 = (__int16)v10 >> 8;
    if (v10 << 16 < 0)
    {
      int v19 = __maskrune(v18, 0x40000uLL);
      int v10 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      int v19 = *(_DWORD *)(v12 + 4 * v18 + 60) & 0x40000;
    }
    if (v19) {
      uint64_t v20 = ((__int16)v10 >> 8);
    }
    else {
      uint64_t v20 = 46;
    }
    if ((v10 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v12 + 4 * (char)v10 + 60) & 0x40000) != 0) {
        goto LABEL_25;
      }
    }
    else if (__maskrune((char)v10, 0x40000uLL))
    {
LABEL_25:
      int v21 = *(_DWORD *)(a1 + 204);
LABEL_28:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v14, v17, v20, (char)v21, iioTypeStr[a3], "virtual OSStatus ASTCReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_29;
    }
    LOBYTE(v21) = 46;
    goto LABEL_28;
  }
LABEL_29:
  IIOReadPlugin::debugDecodeImage((IIOReadPlugin *)a1, a2);
  if (*(unsigned char *)(a1 + 410) == 1 && *(void *)(a1 + 392) != 16)
  {
    _cg_jpeg_mem_term("decodeImageImp", 896, "*** ERROR: ASTC cannot handle %d rowBytesAlignment\n", *(void *)(a1 + 392));
    uint64_t BlockArray = 0;
    goto LABEL_66;
  }
  *(void *)(a1 + 392) = 16;
  uint64_t v22 = *(IIOImageRead ***)(a1 + 24);
  if (v22) {
    BOOL v23 = IIOImageReadSession::mapData(v22);
  }
  else {
    BOOL v23 = 0;
  }
  int v24 = ASTCTextureImp::needs_hdr(v9);
  unsigned int v25 = *(_DWORD *)(a1 + 236);
  if (v24)
  {
    int v26 = *(_DWORD *)(a1 + 228);
    if (v25 < 8 * v26)
    {
      unsigned int v25 = 8 * v26;
      *(_DWORD *)(a1 + 236) = 8 * v26;
    }
  }
  *(_DWORD *)(a1 + 300) = ImageIOAlignRowBytes(v25, *(void *)(a1 + 392));
  if (a3 == 3)
  {
    uint64_t BlockArray = IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
    LODWORD(v33) = *(_DWORD *)(a1 + 292);
    double v32 = (double)v33;
    unsigned int v34 = *(_DWORD *)(a1 + 296);
    double v31 = (double)v34;
    memory_object_size_t v30 = *(unsigned int *)(a1 + 300) * (unint64_t)v34;
    BaseAddress = (void *)_ImageIO_Malloc(v30, *(void *)(a1 + 384), v63, (uint64_t)kImageMalloc_ASTC_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
    {
      uint64_t BlockArray = 0;
      goto LABEL_63;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    size_t Height = IOSurfaceGetHeight(*a4);
    uint64_t BlockArray = 0;
    memory_object_size_t v30 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v63[0] = v30;
    double v31 = 0.0;
    double v32 = 0.0;
  }
  if (!BaseAddress)
  {
LABEL_63:
    if (!v23) {
      goto LABEL_66;
    }
    goto LABEL_64;
  }
  if (*(unsigned char *)(a1 + 505))
  {
    size_t v35 = (16 * *(_DWORD *)(a1 + 452) * *(_DWORD *)(a1 + 456));
    uint64_t v36 = malloc_type_calloc(v35, 1uLL, 0x94AE4889uLL);
    if (v36)
    {
      uint64_t v61 = 0;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      memset(&v56, 0, sizeof(v56));
      if (!CreateKtxStream((uint64_t)&v56, *(IIOImageReadSession **)(a1 + 24)))
      {
        if (ktxTexture2_CreateFromStream(&v56, 0, &v62))
        {
          _cg_jpeg_mem_term("decodeImageImp", 965, "*** ERROR: ktxTexture2_CreateFromStream failed [%d]\n");
        }
        else
        {
          int v52 = *(_DWORD *)(a1 + 208);
          long long v53 = v36;
          size_t v54 = v35;
          size_t v55 = 0;
          if (!(*(unsigned int (**)(void))(*(void *)(v62 + 8) + 40))())
          {
            vImagePixelCount v37 = *(unsigned int *)(a1 + 260);
            vImagePixelCount v38 = *(unsigned int *)(a1 + 264);
            size_t v39 = *(unsigned int *)(a1 + 300);
            v51.data = BaseAddress;
            v51.double height = v38;
            v51.double width = v37;
            v51.rowunint64_t Bytes = v39;
            uint64_t BlockArray = ASTCTextureImp::decodeASTCtoRGBX(v9, v36, v55, &v51, *(unsigned __int8 *)(a1 + 310), *(unsigned char *)(a1 + 405) == 0);
            if (!BlockArray) {
              goto LABEL_51;
            }
            goto LABEL_58;
          }
          _cg_jpeg_mem_term("decodeImageImp", 969, "*** ERROR: ktxTexture_IterateLoadLevelFaces failed [%d]\n");
        }
      }
    }
LABEL_59:
    if (a3 == 3) {
      _ImageIO_Free((unint64_t)BaseAddress, v63[0]);
    }
    if (!v36) {
      goto LABEL_53;
    }
LABEL_62:
    free(v36);
    goto LABEL_63;
  }
  vImagePixelCount v40 = *(unsigned int *)(a1 + 292);
  vImagePixelCount v41 = *(unsigned int *)(a1 + 296);
  size_t v42 = *(unsigned int *)(a1 + 300);
  v56.data = BaseAddress;
  v56.double height = v41;
  v56.double width = v40;
  v56.rowunint64_t Bytes = v42;
  float64x2_t v43 = *(IIOImageReadSession **)(a1 + 24);
  if (v43) {
    uint64_t BlockArray = ASTCTextureImp::decodeASTCtoRGBX(v9, v43, &v56, *(unsigned __int8 *)(a1 + 310), *(unsigned char *)(a1 + 405) == 0);
  }
  uint64_t v36 = 0;
  if (BlockArray)
  {
LABEL_58:
    *(_DWORD *)(a1 + 104) = 0;
    goto LABEL_59;
  }
LABEL_51:
  if (a3 != 3)
  {
    IOSurfaceUnlock(*a4, 0, 0);
    uint64_t BlockArray = 0;
    if (!v36) {
      goto LABEL_53;
    }
    goto LABEL_62;
  }
  uint64_t v46 = 0;
  v64.origin.CGFloat x = 0.0;
  v64.origin.CGFloat y = 0.0;
  v64.size.double width = v32;
  v64.size.double height = v31;
  **(void **)(a1 + 96) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, BaseAddress, v30, v64, *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
  if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E4F1DB20]))
  {
    uint64_t v47 = 0;
  }
  else
  {
    v65.origin.CGFloat x = 0.0;
    v65.origin.CGFloat y = 0.0;
    v65.size.double width = v32;
    v65.size.double height = v31;
    *(CGRect *)(&v47 - 1) = CGRectUnion(*(CGRect *)(a1 + 120), v65);
    uint64_t v46 = v48;
    double v32 = v49;
    double v31 = v50;
  }
  uint64_t BlockArray = 0;
  *(void *)(a1 + 120) = v46;
  *(void *)(a1 + 128) = v47;
  *(double *)(a1 + 136) = v32;
  *(double *)(a1 + 144) = v31;
  if (v36) {
    goto LABEL_62;
  }
LABEL_53:
  if (!v23) {
    goto LABEL_66;
  }
LABEL_64:
  float64x2_t v44 = *(const char ***)(a1 + 24);
  if (v44) {
    IIOImageReadSession::unmapData(v44);
  }
LABEL_66:
  if (v62) {
    (**(void (***)(void))(v62 + 8))();
  }
  return BlockArray;
}

uint64_t TIFFInitLZW(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 != 5) {
    TIFFInitLZW_cold_1();
  }
  uint64_t v9 = _TIFFmallocExt((void *)a1, 296, a3, a4, a5, a6, a7, a8);
  *(void *)(a1 + 1096) = v9;
  if (v9)
  {
    v9[29] = 0;
    unsigned char v9[24] = 0;
    v9[36] = 0;
    *((_DWORD *)v9 + 38) = *(_DWORD *)(a1 + 12);
    *(void *)(a1 + 952) = LZWFixupTags;
    *(void *)(a1 + 960) = LZWSetupDecode;
    *(void *)(a1 + 968) = LZWPreDecode;
    *(void *)(a1 + 1008) = LZWDecode;
    *(void *)(a1 + 1024) = LZWDecode;
    *(void *)(a1 + 1040) = LZWDecode;
    *(void *)(a1 + 976) = LZWSetupEncode;
    *(void *)(a1 + 992) = LZWPreEncode;
    *(void *)(a1 + 1000) = LZWPostEncode;
    *(void *)(a1 + 1016) = LZWEncode;
    *(void *)(a1 + 1032) = LZWEncode;
    *(void *)(a1 + 1048) = LZWEncode;
    *(void *)(a1 + 1072) = LZWCleanup;
    TIFFPredictorInit(a1, v10, v11, v12, v13, v14, v15, v16);
    return 1;
  }
  else
  {
    TIFFErrorExtR(a1, "TIFFInitLZW", "No space for LZW state block", v12, v13, v14, v15, v16, v18);
    return 0;
  }
}

uint64_t LZWFixupTags()
{
  return 1;
}

uint64_t LZWSetupDecode(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = (void *)a1[137];
  if (!v9)
  {
    uint64_t v10 = _TIFFmallocExt(a1, 296, a3, a4, a5, a6, a7, a8);
    a1[137] = v10;
    if (!v10)
    {
      uint64_t v22 = "No space for LZW state block";
      goto LABEL_12;
    }
    uint64_t v9 = v10;
    v10[29] = 0;
    unsigned char v10[24] = 0;
    TIFFPredictorInit((uint64_t)a1, v11, v12, v13, v14, v15, v16, v17);
  }
  if (v9[29]) {
    return 1;
  }
  char v18 = _TIFFmallocExt(a1, 81904, a3, a4, a5, a6, a7, a8);
  v9[29] = v18;
  if (v18)
  {
    int v19 = (char *)v18 + 4092;
    for (uint64_t i = 255; i != -1; --i)
    {
      *(v19 - 2) = i;
      *(v19 - 1) = i;
      *int v19 = 1;
      *((_WORD *)v19 - 2) = 1;
      *(void *)(v19 - 12) = 0;
      v19 -= 16;
    }
    *((_OWORD *)v18 + 257) = 0u;
    *((_OWORD *)v18 + 256) = 0u;
    return 1;
  }
  uint64_t v22 = "No space for LZW code table";
LABEL_12:
  TIFFErrorExtR((uint64_t)a1, "LZWSetupDecode", v22, v13, v14, v15, v16, v17, v23);
  return 0;
}

uint64_t LZWPreDecode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 1096);
  if (!v8) {
    LZWPreDecode_cold_1();
  }
  uint64_t v10 = *(void *)(v8 + 232);
  if (!v10)
  {
    (*(void (**)(uint64_t))(a1 + 960))(a1);
    uint64_t v10 = *(void *)(v8 + 232);
    if (!v10) {
      return 0;
    }
  }
  if (*(uint64_t *)(a1 + 1160) >= 2 && (uint64_t v11 = *(unsigned char **)(a1 + 1120), !*v11) && (v11[1] & 1) != 0)
  {
    if (!*(void *)(v8 + 192))
    {
      TIFFWarningExtR(a1, "LZWPreDecode", "Old-style LZW codes, convert file", a4, a5, a6, a7, a8, v13);
      *(void *)(a1 + 1008) = LZWDecodeCompat;
      *(void *)(a1 + 1024) = LZWDecodeCompat;
      *(void *)(a1 + 1040) = LZWDecodeCompat;
      (*(void (**)(uint64_t))(a1 + 960))(a1);
      *(void *)(v8 + 192) = LZWDecodeCompat;
      uint64_t v10 = *(void *)(v8 + 232);
    }
    *(_WORD *)(v8 + 130) = 511;
  }
  else
  {
    *(_WORD *)(v8 + 130) = 510;
    *(void *)(v8 + 192) = LZWDecode;
  }
  *(_WORD *)(v8 + 128) = 9;
  *(void *)(v8 + 136) = 0;
  *(void *)(v8 + 144) = 0;
  *(_OWORD *)(v8 + 160) = xmmword_1889AD700;
  *(void *)(v8 + 176) = 0;
  *(void *)(v8 + 184) = 0;
  *(void *)(v8 + 208) = v10;
  *(void *)(v8 + 216) = v10 - 16;
  *(void *)(v8 + 224) = v10 + 8160;
  *(_DWORD *)(v8 + 240) = 0;
  return 1;
}

uint64_t LZWDecode(void *a1, char *__b, int64_t a3)
{
  uint64_t v3 = a1[137];
  if (!v3) {
    LZWDecode_cold_1();
  }
  uint64_t v4 = *(void *)(v3 + 232);
  if (!v4) {
    LZWDecode_cold_2();
  }
  int64_t v5 = a3;
  vImagePixelCount v6 = __b;
  uint64_t v7 = (uint64_t)a1;
  if (*(_DWORD *)(v3 + 240))
  {
    bzero(__b, a3);
    char v13 = "LZWDecode";
    int v88 = *(_DWORD *)(v7 + 876);
    uint64_t v14 = "LZWDecode: Scanline %u cannot be read due to previous error";
LABEL_5:
    TIFFErrorExtR(v7, v13, v14, v8, v9, v10, v11, v12, v88);
    return 0;
  }
  uint64_t v16 = *(void *)(v3 + 168);
  if (v16)
  {
    uint64_t v17 = *(uint64_t **)(v3 + 200);
    uint64_t v18 = *((unsigned __int16 *)v17 + 4);
    int64_t v19 = v18 - v16;
    int64_t v20 = a3 - (v18 - v16);
    if (a3 >= v18 - v16)
    {
      int v24 = &__b[v19];
      uint64_t v25 = ~v16 + v18;
      do
      {
        __b[v25] = *((unsigned char *)v17 + 11);
        BOOL v23 = v25-- != 0;
        if (!v23) {
          break;
        }
        uint64_t v17 = (uint64_t *)*v17;
      }
      while (v17);
      *(void *)(v3 + 168) = 0;
    }
    else
    {
      *(void *)(v3 + 168) = v16 + a3;
      int64_t v21 = ~v16 + v18;
      do
      {
        uint64_t v17 = (uint64_t *)*v17;
        if (v21 <= a3) {
          break;
        }
        --v21;
      }
      while (v17);
      if (v17)
      {
        int64_t v22 = a3 - 1;
        do
        {
          __b[v22] = *((unsigned char *)v17 + 11);
          BOOL v23 = v22-- != 0;
          if (!v23) {
            break;
          }
          uint64_t v17 = (uint64_t *)*v17;
        }
        while (v17);
        int64_t v20 = v22 + 1;
        int v24 = __b;
      }
      else
      {
        int v24 = __b;
        int64_t v20 = a3;
      }
    }
    if (a3 < v19) {
      return 1;
    }
    uint64_t v4 = *(void *)(v3 + 232);
    vImagePixelCount v6 = v24;
    int64_t v5 = v20;
  }
  int v26 = (unsigned __int8 *)a1[144];
  unint64_t v27 = *(void *)(v3 + 176) + 8 * (a1[145] - *(void *)(v3 + 184));
  *(void *)(v3 + 176) = v27;
  uint64_t v28 = *(unsigned __int16 *)(v3 + 128);
  unint64_t v30 = *(void *)(v3 + 136);
  uint64_t v29 = *(void *)(v3 + 144);
  uint64_t v31 = *(void *)(v3 + 160);
  unint64_t v32 = *(void *)(v3 + 208);
  unint64_t v33 = *(void *)(v3 + 216);
  unint64_t v34 = *(void *)(v3 + 224);
  if (!v5) {
    goto LABEL_114;
  }
  unint64_t v35 = v4 - 16;
  unint64_t v36 = v4 + 4128;
  unint64_t v37 = v4 + 8160;
  unint64_t v38 = v4 + 81904;
  uint64_t v97 = v7;
LABEL_28:
  while (2)
  {
    while (2)
    {
      while (2)
      {
        v29 -= v28;
        if (v29 >= 0) {
          goto LABEL_29;
        }
        if (v27 < 0x40)
        {
          if (v27 < 8) {
            goto LABEL_117;
          }
          unint64_t v30 = *v26 | (v30 << 8);
          if ((unint64_t)v29 > 0xFFFFFFFFFFFFFFF7)
          {
            v29 += 8;
            ++v26;
            v27 -= 8;
          }
          else
          {
            if (v27 - 8 < 8)
            {
LABEL_117:
              bzero(v6, v5);
              *(_DWORD *)(v3 + 240) = 1;
              TIFFErrorExtR(v7, "LZWDecode", "LZWDecode: Strip %u not terminated with EOI code", v81, v82, v83, v84, v85, *(_DWORD *)(v7 + 884));
              return 0;
            }
            uint64_t v67 = v26[1];
            v26 += 2;
            unint64_t v30 = v67 | (v30 << 8);
            v29 += 16;
            v27 -= 16;
          }
LABEL_29:
          unint64_t v39 = v30 >> v29;
          goto LABEL_30;
        }
        unint64_t v51 = v30 << -(char)v29;
        unint64_t v52 = *(void *)v26;
        v26 += 8;
        unint64_t v30 = bswap64(v52);
        unint64_t v53 = v30 >> v29;
        v29 += 64;
        unint64_t v39 = v53 | v51;
        v27 -= 64;
LABEL_30:
        unint64_t v40 = v39 & v31;
        unint64_t v41 = v4 + 16 * (v39 & v31);
        if ((v39 & v31) <= 0x101)
        {
          if (v40 < 0x100)
          {
            if (v41 > v33) {
              goto LABEL_118;
            }
            *(void *)unint64_t v33 = v32;
            *(unsigned char *)(v33 + 10) = *(unsigned char *)(v32 + 10);
            *(_WORD *)(v33 + 8) = *(_WORD *)(v32 + 8) + 1;
            *(unsigned char *)(v33 + 11) = v40;
            int v44 = *(unsigned __int8 *)(v32 + 12);
            uint64_t v45 = *(unsigned __int8 *)(v32 + 11);
            if (v44) {
              BOOL v46 = v40 == v45;
            }
            else {
              BOOL v46 = 0;
            }
            char v47 = v46;
            *(unsigned char *)(v33 + 12) = v47;
            unint64_t v48 = v33 + 16;
            if (v28 >= 11) {
              uint64_t v49 = 11;
            }
            else {
              uint64_t v49 = v28;
            }
            if (v48 >= v38) {
              unint64_t v50 = v35;
            }
            else {
              unint64_t v50 = v33 + 16;
            }
            if (v48 <= v34)
            {
              v33 += 16;
            }
            else
            {
              uint64_t v28 = v49 + 1;
              uint64_t v31 = ~(-2 << v49);
              unint64_t v33 = v50;
            }
            if (v48 > v34) {
              unint64_t v34 = v35 + 16 * ~(-2 << v49);
            }
            *v6++ = v40;
            unint64_t v32 = v41;
            if (!--v5) {
              goto LABEL_128;
            }
            continue;
          }
          if (v40 == 257) {
            goto LABEL_114;
          }
          while (v29 <= 8)
          {
            if (v27 < 0x40)
            {
              if (v27 < 8) {
                goto LABEL_117;
              }
              unint64_t v30 = *v26 | (v30 << 8);
              if (v29 <= 0)
              {
                if (v27 - 8 < 8) {
                  goto LABEL_117;
                }
                uint64_t v64 = v26[1];
                v26 += 2;
                unint64_t v30 = v64 | (v30 << 8);
                v29 += 7;
                v27 -= 16;
              }
              else
              {
                --v29;
                ++v26;
                v27 -= 8;
              }
              goto LABEL_88;
            }
            unint64_t v61 = v30 << (9 - v29);
            unint64_t v62 = *(void *)v26;
            v26 += 8;
            unint64_t v30 = bswap64(v62);
            v29 += 55;
            unint64_t v63 = (v30 >> v29) | v61;
            v27 -= 64;
LABEL_89:
            unint64_t v65 = v63 & 0x1FF;
            if (v65 != 256)
            {
              if (v65 == 257)
              {
                uint64_t v31 = 511;
                LOWORD(v28) = 9;
LABEL_113:
                unint64_t v33 = v36;
                unint64_t v34 = v37;
                goto LABEL_114;
              }
              if (v65 > 0x101)
              {
LABEL_118:
                bzero(v6, v5);
                *(_DWORD *)(v3 + 240) = 1;
                char v13 = *(const char **)v7;
                uint64_t v14 = "Using code not yet in table";
                goto LABEL_5;
              }
              *v6++ = v63;
              unint64_t v32 = v4 + 16 * v65;
              uint64_t v28 = 9;
              uint64_t v31 = 511;
              unint64_t v33 = v36;
              unint64_t v34 = v37;
              if (!--v5)
              {
                LOWORD(v28) = 9;
                uint64_t v31 = 511;
                goto LABEL_113;
              }
              goto LABEL_28;
            }
          }
          v29 -= 9;
LABEL_88:
          unint64_t v63 = v30 >> v29;
          goto LABEL_89;
        }
        break;
      }
      if (v41 >= v33)
      {
        if (v41 != v33) {
          goto LABEL_118;
        }
        int v43 = *(unsigned __int8 *)(v32 + 10);
        *(unsigned char *)(v33 + 11) = v43;
        int v42 = v43;
      }
      else
      {
        int v42 = *(unsigned __int8 *)(v4 + 16 * v40 + 10);
        *(unsigned char *)(v33 + 11) = v42;
        LOBYTE(v43) = *(unsigned char *)(v32 + 10);
      }
      if (*(unsigned char *)(v32 + 12)) {
        BOOL v54 = *(unsigned __int8 *)(v32 + 11) == v42;
      }
      else {
        BOOL v54 = 0;
      }
      char v55 = v54;
      *(unsigned char *)(v33 + 12) = v55;
      *(void *)unint64_t v33 = v32;
      *(unsigned char *)(v33 + 10) = v43;
      *(_WORD *)(v33 + 8) = *(_WORD *)(v32 + 8) + 1;
      unint64_t v56 = v33 + 16;
      if (v28 >= 11) {
        uint64_t v57 = 11;
      }
      else {
        uint64_t v57 = v28;
      }
      if (v56 >= v38) {
        unint64_t v58 = v35;
      }
      else {
        unint64_t v58 = v33 + 16;
      }
      if (v56 <= v34)
      {
        v33 += 16;
      }
      else
      {
        uint64_t v28 = v57 + 1;
        uint64_t v31 = ~(-2 << v57);
        unint64_t v33 = v58;
      }
      if (v56 > v34) {
        unint64_t v34 = v35 + 16 * ~(-2 << v57);
      }
      int64_t v59 = *(unsigned __int16 *)(v4 + 16 * v40 + 8);
      if (v59 <= 2)
      {
        int64_t v60 = v5 - 2;
        if (v5 <= 2)
        {
          if (v5 == 2)
          {
            int64_t v5 = 0;
            *(_WORD *)vImagePixelCount v6 = *(_WORD *)(v4 + 16 * v40 + 10);
            v6 += 2;
LABEL_123:
            unint64_t v32 = v41;
            uint64_t v7 = v97;
            goto LABEL_114;
          }
          goto LABEL_124;
        }
        *(_WORD *)vImagePixelCount v6 = *(_WORD *)(v4 + 16 * v40 + 10);
        v6 += 2;
        goto LABEL_97;
      }
      if (v59 != 3)
      {
        if (v5 < v59) {
          goto LABEL_124;
        }
        uint64_t v68 = v4 + 16 * v40;
        if (*(unsigned char *)(v68 + 12))
        {
          unint64_t v91 = v35;
          unint64_t v92 = v37;
          unint64_t v89 = v41;
          unint64_t v90 = v38;
          uint64_t v95 = v31;
          unsigned int v96 = v26;
          unint64_t v93 = v36;
          unint64_t v94 = v34;
          memset(v6, *(unsigned __int8 *)(v68 + 11), v59);
          unint64_t v38 = v90;
          unint64_t v35 = v91;
          unint64_t v37 = v92;
          unint64_t v36 = v93;
          unint64_t v34 = v94;
          uint64_t v31 = v95;
          int v26 = v96;
          v6 += v59;
          unint64_t v32 = v89;
          v5 -= v59;
          uint64_t v7 = v97;
          if (!v5)
          {
            unint64_t v32 = v89;
            goto LABEL_114;
          }
        }
        else
        {
          unsigned __int32 v69 = &v6[v59];
          *(v69 - 1) = *(unsigned char *)(v68 + 11);
          unsigned __int32 v70 = *(uint64_t ****)v41;
          *(v69 - 2) = *(unsigned char *)(*(void *)v41 + 11);
          unsigned __int32 v71 = *v70;
          *(v69 - 3) = *((unsigned char *)v71 + 11);
          uint64_t v72 = *v71;
          v6[v59 - 4] = *((unsigned char *)v72 + 11);
          if (&v6[v59 - 4] > v6)
          {
            uint64_t v73 = v69 - 5;
            do
            {
              uint64_t v72 = (uint64_t *)*v72;
              BOOL v74 = v73 > v6;
              *v73-- = *((unsigned char *)v72 + 11);
            }
            while (v74);
          }
          v6 += v59;
          unint64_t v32 = v41;
          v5 -= v59;
          uint64_t v7 = v97;
          if (!v5)
          {
            vImagePixelCount v6 = v69;
            goto LABEL_128;
          }
        }
        continue;
      }
      break;
    }
    int64_t v60 = v5 - 3;
    if (v5 > 3)
    {
      uint64_t v66 = v4 + 16 * v40;
      *vImagePixelCount v6 = *(unsigned char *)(v66 + 10);
      v6[1] = *(unsigned char *)(*(void *)v41 + 11);
      v6[2] = *(unsigned char *)(v66 + 11);
      v6 += 3;
LABEL_97:
      int64_t v5 = v60;
      unint64_t v32 = v41;
      uint64_t v7 = v97;
      continue;
    }
    break;
  }
  if (v5 == 3)
  {
    int64_t v5 = 0;
    uint64_t v86 = v4 + 16 * v40;
    *vImagePixelCount v6 = *(unsigned char *)(v86 + 10);
    v6[1] = *(unsigned char *)(*(void *)v41 + 11);
    v6[2] = *(unsigned char *)(v86 + 11);
    v6 += 3;
    goto LABEL_123;
  }
LABEL_124:
  *(void *)(v3 + 200) = v41;
  CFDataRef v87 = (uint64_t *)v41;
  do
    CFDataRef v87 = (uint64_t *)*v87;
  while (v5 < *((unsigned __int16 *)v87 + 4));
  *(void *)(v3 + 168) = v5;
  uint64_t v7 = v97;
  do
  {
    v6[v5 - 1] = *((unsigned char *)v87 + 11);
    CFDataRef v87 = (uint64_t *)*v87;
    --v5;
  }
  while (v5);
LABEL_128:
  unint64_t v32 = v41;
LABEL_114:
  uint64_t v75 = *(void *)(v7 + 1152) - (void)v26 + *(void *)(v7 + 1160);
  *(void *)(v7 + 1160) = v75;
  *(void *)(v7 + 1152) = v26;
  *(void *)(v3 + 176) = v27;
  *(void *)(v3 + 184) = v75;
  *(_WORD *)(v3 + 128) = v28;
  *(void *)(v3 + 136) = v30;
  *(void *)(v3 + 144) = v29;
  *(void *)(v3 + 160) = v31;
  *(void *)(v3 + 208) = v32;
  *(void *)(v3 + 216) = v33;
  *(void *)(v3 + 224) = v34;
  if (v5 >= 1)
  {
    bzero(v6, v5);
    TIFFErrorExtR(v7, "LZWDecode", "Not enough data at scanline %u (short %llu bytes)", v76, v77, v78, v79, v80, *(_DWORD *)(v7 + 876));
    return 0;
  }
  return 1;
}

uint64_t LZWSetupEncode(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a1[137];
  if (!v8) {
    LZWSetupEncode_cold_1();
  }
  uint64_t v10 = _TIFFmallocExt(a1, 144016, a3, a4, a5, a6, a7, a8);
  *(void *)(v8 + 288) = v10;
  if (v10) {
    return 1;
  }
  TIFFErrorExtR((uint64_t)a1, "LZWSetupEncode", "No space for LZW hash table", v11, v12, v13, v14, v15, v17);
  return 0;
}

uint64_t LZWPreEncode(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1096);
  if (!v1) {
    LZWPreEncode_cold_1();
  }
  uint64_t v3 = *(void **)(v1 + 288);
  if (!v3)
  {
    (*(void (**)(uint64_t))(a1 + 976))(a1);
    uint64_t v3 = *(void **)(v1 + 288);
  }
  *(_DWORD *)(v1 + 128) = 33488905;
  *(_WORD *)(v1 + 132) = 258;
  *(void *)(v1 + 136) = 0;
  *(void *)(v1 + 144) = 0;
  *(void *)(v1 + 248) = 10000;
  *(void *)(v1 + 256) = 0;
  *(void *)(v1 + 264) = 0;
  *(void *)(v1 + 272) = 0;
  *(void *)(v1 + 280) = *(void *)(a1 + 1120) + *(void *)(a1 + 1128) - 5;
  unint64_t v4 = 9001;
  uint64_t v5 = 17986;
  do
  {
    vImagePixelCount v6 = &v3[v5];
    *vImagePixelCount v6 = -1;
    v6[2] = -1;
    UInt8 v6[4] = -1;
    v6[6] = -1;
    UInt8 v6[8] = -1;
    v6[10] = -1;
    v6[12] = -1;
    v4 -= 8;
    v5 -= 16;
    v6[14] = -1;
  }
  while (v4 > 7);
  void *v3 = -1;
  *(_DWORD *)(v1 + 244) = 0xFFFF;
  return 1;
}

uint64_t LZWPostEncode(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1[137];
  uint64_t v10 = (unsigned char *)a1[144];
  unint64_t v11 = *(void *)(v9 + 136);
  uint64_t v12 = *(void *)(v9 + 144);
  uint64_t v13 = *(unsigned __int16 *)(v9 + 128);
  if ((unint64_t)v10 > *(void *)(v9 + 280))
  {
    a1[145] = &v10[-a1[140]];
    uint64_t result = TIFFFlushData1((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
    if (!result) {
      return result;
    }
    uint64_t v10 = (unsigned char *)a1[140];
  }
  uint64_t v15 = *(int *)(v9 + 244);
  if (v15 != 0xFFFF)
  {
    unsigned int v16 = *(unsigned __int16 *)(v9 + 132);
    unint64_t v11 = (v11 << v13) | v15;
    uint64_t v17 = v12 + v13;
    uint64_t v12 = v12 + v13 - 8;
    *uint64_t v10 = v11 >> v12;
    BOOL v18 = v17 < 16;
    uint64_t v19 = v17 - 16;
    if (v18)
    {
      ++v10;
    }
    else
    {
      v10[1] = v11 >> v19;
      v10 += 2;
      uint64_t v12 = v19;
    }
    *(_DWORD *)(v9 + 244) = 0xFFFF;
    if (v16 == 4093)
    {
      unint64_t v11 = (v11 << v13) | 0x100;
      uint64_t v20 = v12 + v13;
      uint64_t v12 = v12 + v13 - 8;
      *uint64_t v10 = v11 >> v12;
      BOOL v18 = v20 < 16;
      uint64_t v21 = v20 - 16;
      if (v18)
      {
        LODWORD(v13) = 9;
        ++v10;
      }
      else
      {
        v10[1] = v11 >> v21;
        v10 += 2;
        LODWORD(v13) = 9;
        uint64_t v12 = v21;
      }
    }
    else if (v16 >= *(unsigned __int16 *)(v9 + 130))
    {
      if (v13 >= 0xC) {
        LZWPostEncode_cold_1();
      }
      LODWORD(v13) = v13 + 1;
    }
  }
  unint64_t v22 = (v11 << v13) | 0x101;
  uint64_t v23 = v12 + v13;
  uint64_t v24 = v23 - 8;
  *uint64_t v10 = v22 >> (v23 - 8);
  uint64_t v25 = v10 + 1;
  BOOL v18 = v23 < 16;
  uint64_t v26 = v23 - 16;
  if (!v18)
  {
    uint64_t v25 = v10 + 2;
    v10[1] = v22 >> v26;
    uint64_t v24 = v26;
  }
  if (v24 >= 1) {
    *v25++ = v22 << (8 - v24);
  }
  a1[145] = &v25[-a1[140]];
  return 1;
}

uint64_t LZWEncode(void *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v3 = a1[137];
  if (!v3) {
    return 0;
  }
  if (!*(void *)(v3 + 288)) {
    LZWEncode_cold_1();
  }
  vImagePixelCount v6 = a1;
  uint64_t v8 = *(void *)(v3 + 264);
  uint64_t v7 = *(void *)(v3 + 272);
  uint64_t v9 = *(void *)(v3 + 248);
  unint64_t v11 = *(void *)(v3 + 136);
  uint64_t v10 = *(void *)(v3 + 144);
  int v12 = *(unsigned __int16 *)(v3 + 132);
  int v13 = *(unsigned __int16 *)(v3 + 130);
  uint64_t v14 = *(unsigned __int16 *)(v3 + 128);
  uint64_t v15 = (unsigned char *)v6[144];
  unint64_t v16 = *(void *)(v3 + 280);
  uint64_t v17 = *(unsigned __int16 *)(v3 + 244);
  if (a3 >= 1 && v17 == 0xFFFF)
  {
    uint64_t v18 = *(void *)(v3 + 264);
    unint64_t v11 = (v11 << v14) | 0x100;
    uint64_t v19 = v10 + *(unsigned __int16 *)(v3 + 128);
    uint64_t v10 = v19 - 8;
    *uint64_t v15 = v11 >> (v19 - 8);
    BOOL v20 = v19 < 16;
    uint64_t v21 = v19 - 16;
    if (v20)
    {
      ++v15;
    }
    else
    {
      v15[1] = v11 >> v21;
      v15 += 2;
      uint64_t v10 = v21;
    }
    v7 += v14;
    unsigned int v23 = *a2++;
    uint64_t v17 = v23;
    uint64_t v8 = v18 + 1;
    --a3;
  }
  if (a3 >= 1)
  {
    uint64_t v24 = v14;
    while (1)
    {
      uint64_t v25 = 0;
      uint64_t v26 = *(void *)(v3 + 288);
      uint64_t v27 = (v8 << 8) + 256;
      uint64_t v28 = 1;
      uint64_t v29 = v17;
      while (1)
      {
        uint64_t v17 = a2[v25];
        uint64_t v30 = v29 + (v17 << 12);
        uint64_t v31 = (unsigned __int16)v29 ^ (32 * v17);
        uint64_t v32 = *(void *)(v26 + 16 * v31);
        if (v32 != v30) {
          break;
        }
        uint64_t v29 = *(unsigned __int16 *)(v26 + 16 * v31 + 8);
        ++v25;
        v27 += 256;
        --v28;
        if ((unint64_t)(a3 + v28) <= 1)
        {
          uint64_t v52 = v8 + v25;
          LODWORD(v17) = v29;
          goto LABEL_53;
        }
      }
      uint64_t v63 = v8 + v25;
      uint64_t v64 = v8 + v25 + 1;
      if ((v32 & 0x8000000000000000) == 0)
      {
        int v33 = v31 - 9001;
        if (!v31) {
          int v33 = -1;
        }
        int v34 = (unsigned __int16)v29 ^ (32 * v17);
        while (1)
        {
          v34 += v33 + (v34 + v33 < 0 ? 0x2329 : 0);
          uint64_t v31 = v34;
          uint64_t v35 = *(void *)(v26 + 16 * v34);
          if (v35 == v30) {
            break;
          }
          if (v35 < 0) {
            goto LABEL_22;
          }
        }
        uint64_t v17 = *(unsigned __int16 *)(v26 + 16 * v34 + 8);
        uint64_t v52 = v8 + v25 + 1;
        goto LABEL_47;
      }
LABEL_22:
      if ((unint64_t)v15 > v16)
      {
        uint64_t v54 = v8;
        uint64_t v55 = v24;
        uint64_t v56 = v7;
        int v57 = v13;
        uint64_t v58 = v10;
        unint64_t v59 = v16;
        uint64_t v60 = v9;
        unint64_t v61 = v11;
        uint64_t v62 = v3;
        v6[145] = &v15[-v6[140]];
        unint64_t v53 = v6;
        uint64_t result = TIFFFlushData1((uint64_t)v6, v16, v10, 4294958295, v7, 9001, 10001, 0x7FFFFFLL);
        if (!result) {
          return result;
        }
        vImagePixelCount v6 = v53;
        uint64_t v8 = v54;
        uint64_t v15 = (unsigned char *)v53[140];
        unint64_t v11 = v61;
        uint64_t v3 = v62;
        unint64_t v16 = v59;
        uint64_t v9 = v60;
        uint64_t v10 = v58;
        int v13 = v57;
        uint64_t v7 = v56;
        uint64_t v24 = v55;
      }
      unint64_t v11 = (v11 << v24) | v29;
      uint64_t v36 = v10 + (int)v24;
      uint64_t v10 = v36 - 8;
      *uint64_t v15 = v11 >> (v36 - 8);
      uint64_t v37 = v8;
      BOOL v20 = v36 < 16;
      uint64_t v38 = v36 - 16;
      if (v20)
      {
        ++v15;
      }
      else
      {
        v15[1] = v11 >> v38;
        v15 += 2;
        uint64_t v10 = v38;
      }
      uint64_t v39 = (int)v24;
      *(_WORD *)(v26 + 16 * v31 + 8) = v12;
      *(void *)(v26 + 16 * v31) = v30;
      char v40 = v24;
      if (v12 == 4093) {
        break;
      }
      v7 += (int)v24;
      if (v12 >= v13)
      {
        uint64_t v52 = v64;
        if ((int)v24 >= 12) {
          LZWEncode_cold_2();
        }
        int v13 = ~(-1 << (v24 + 1));
        ++v12;
        uint64_t v24 = (v24 + 1);
        goto LABEL_47;
      }
      uint64_t v52 = v64;
      if (v64 >= v9)
      {
        if (v63 < 0x7FFFFF)
        {
          uint64_t v47 = v27 / v7;
        }
        else if ((unint64_t)v7 >= 0x100)
        {
          uint64_t v47 = v64 / (v7 >> 8);
        }
        else
        {
          uint64_t v47 = 0x7FFFFFFFLL;
        }
        uint64_t v9 = v37 + v25 + 10001;
        if (v47 <= *(void *)(v3 + 256))
        {
          unint64_t v41 = *(void **)(v3 + 288);
          uint64_t v49 = 17986;
          for (unint64_t i = 9001; i > 7; i -= 8)
          {
            unint64_t v51 = &v41[v49];
            *unint64_t v51 = -1;
            v51[2] = -1;
            v51[4] = -1;
            v51[6] = -1;
            v51[8] = -1;
            v51[10] = -1;
            v51[12] = -1;
            v49 -= 16;
            v51[14] = -1;
          }
          goto LABEL_31;
        }
        *(void *)(v3 + 256) = v47;
        ++v12;
      }
      else
      {
        ++v12;
      }
LABEL_47:
      uint64_t v48 = a3 - v25;
      a3 = a3 - v25 - 1;
      a2 += v25 + 1;
      uint64_t v8 = v52;
      if (v48 <= 1) {
        goto LABEL_53;
      }
    }
    unint64_t v41 = *(void **)(v3 + 288);
    uint64_t v42 = 17986;
    for (unint64_t j = 9001; j > 7; j -= 8)
    {
      int v44 = &v41[v42];
      *int v44 = -1;
      v44[2] = -1;
      v44[4] = -1;
      v44[6] = -1;
      v44[8] = -1;
      v44[10] = -1;
      v44[12] = -1;
      v42 -= 16;
      v44[14] = -1;
    }
LABEL_31:
    *unint64_t v41 = -1;
    *(void *)(v3 + 256) = 0;
    unint64_t v11 = (v11 << v40) | 0x100;
    uint64_t v45 = v10 + v39;
    uint64_t v10 = v10 + v39 - 8;
    *uint64_t v15 = v11 >> v10;
    uint64_t v52 = 0;
    BOOL v20 = v45 < 16;
    uint64_t v46 = v45 - 16;
    if (v20)
    {
      uint64_t v24 = 9;
      int v13 = 511;
      int v12 = 258;
      uint64_t v7 = v39;
      ++v15;
    }
    else
    {
      v15[1] = v11 >> v46;
      v15 += 2;
      uint64_t v24 = 9;
      int v13 = 511;
      int v12 = 258;
      uint64_t v7 = v39;
      uint64_t v10 = v46;
    }
    goto LABEL_47;
  }
  LOWORD(v24) = v14;
  uint64_t v52 = v8;
LABEL_53:
  *(void *)(v3 + 264) = v52;
  *(void *)(v3 + 272) = v7;
  *(void *)(v3 + 248) = v9;
  *(_DWORD *)(v3 + 244) = v17;
  *(void *)(v3 + 136) = v11;
  *(void *)(v3 + 144) = v10;
  *(_WORD *)(v3 + 132) = v12;
  *(_WORD *)(v3 + 130) = v13;
  *(_WORD *)(v3 + 128) = v24;
  uint64_t result = 1;
  v6[144] = v15;
  return result;
}

uint64_t LZWCleanup(void *a1)
{
  TIFFPredictorCleanup(a1);
  uint64_t v2 = a1[137];
  if (!v2) {
    LZWCleanup_cold_1();
  }
  if (*(void *)(v2 + 232))
  {
    _TIFFfreeExt((uint64_t)a1, *(char **)(v2 + 232));
    uint64_t v2 = a1[137];
  }
  if (*(void *)(v2 + 288))
  {
    _TIFFfreeExt((uint64_t)a1, *(char **)(v2 + 288));
    uint64_t v2 = a1[137];
  }
  _TIFFfreeExt((uint64_t)a1, (char *)v2);
  a1[137] = 0;

  return _TIFFSetDefaultCompressionState((uint64_t)a1);
}

uint64_t LZWDecodeCompat(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 1096);
  if (!v8) {
    LZWDecodeCompat_cold_1();
  }
  uint64_t v9 = a3;
  uint64_t v10 = a2;
  uint64_t v11 = *(void *)(v8 + 168);
  if (!v11) {
    goto LABEL_13;
  }
  int v12 = *(uint64_t **)(v8 + 200);
  uint64_t v13 = *((unsigned __int16 *)v12 + 4) - v11;
  uint64_t v14 = a3 - v13;
  if (a3 >= v13)
  {
    uint64_t v16 = *((unsigned __int16 *)v12 + 4) - v11;
    do
    {
      a2[v16 - 1] = *((unsigned char *)v12 + 11);
      int v12 = (uint64_t *)*v12;
      --v16;
    }
    while (v16);
    *(void *)(v8 + 168) = 0;
    uint64_t v10 = &a2[v13];
  }
  else
  {
    *(void *)(v8 + 168) = v11 + a3;
    uint64_t v15 = v13;
    do
    {
      int v12 = (uint64_t *)*v12;
      --v15;
    }
    while (v15 > a3);
    uint64_t v14 = a3;
    do
    {
      a2[v14 - 1] = *((unsigned char *)v12 + 11);
      int v12 = (uint64_t *)*v12;
      --v14;
    }
    while (v14);
  }
  uint64_t v9 = v14;
  if (a3 >= v13)
  {
LABEL_13:
    uint64_t v17 = *(unsigned __int8 **)(a1 + 1152);
    unint64_t v18 = *(void *)(v8 + 176) + 8 * (*(void *)(a1 + 1160) - *(void *)(v8 + 184));
    *(void *)(v8 + 176) = v18;
    LODWORD(v19) = *(unsigned __int16 *)(v8 + 128);
    unint64_t v21 = *(void *)(v8 + 136);
    uint64_t v20 = *(void *)(v8 + 144);
    uint64_t v22 = *(void *)(v8 + 160);
    unint64_t v23 = *(void *)(v8 + 208);
    uint64_t v24 = *(char **)(v8 + 216);
    unint64_t v25 = *(void *)(v8 + 224);
    if (v9 >= 1)
    {
      uint64_t v52 = a1;
      while (1)
      {
        if (v18 < v19)
        {
          unint64_t v49 = v25;
          uint64_t v51 = v22;
          TIFFWarningExtR(v52, "LZWDecodeCompat", "LZWDecode: Strip %u not terminated with EOI code", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 884));
          uint64_t v22 = v51;
          a1 = v52;
          unint64_t v25 = v49;
          goto LABEL_53;
        }
        unint64_t v26 = ((unint64_t)*v17 << v20) | v21;
        uint64_t v27 = v20 + 8;
        if (v20 + 8 >= v19)
        {
          ++v17;
        }
        else
        {
          uint64_t v28 = v17[1];
          v17 += 2;
          v26 |= v28 << v27;
          uint64_t v27 = v20 + 16;
        }
        unsigned __int16 v29 = v26 & v22;
        unint64_t v21 = v26 >> v19;
        uint64_t v20 = v27 - v19;
        v18 -= v19;
        int v30 = v26 & (unsigned __int16)v22;
        if (v30 == 256) {
          break;
        }
        if (v30 == 257) {
          goto LABEL_53;
        }
        unint64_t v31 = *(void *)(v8 + 232);
        if ((unint64_t)v24 < v31
          || (unint64_t)v24 >= v31 + 81904
          || (*(void *)uint64_t v24 = v23, v23 < v31)
          || v23 >= v31 + 81904)
        {
          TIFFErrorExtR(a1, "LZWDecodeCompat", "Corrupted LZW table at scanline %u", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 876));
          return 0;
        }
        uint64_t v32 = v29;
        v24[10] = *(unsigned char *)(v23 + 10);
        int v33 = v24 + 10;
        unint64_t v34 = v31 + 16 * v29;
        *((_WORD *)v24 + 4) = *(_WORD *)(v23 + 8) + 1;
        if (v34 < (unint64_t)v24) {
          int v33 = (char *)(v31 + 16 * v29 + 10);
        }
        v24[11] = *v33;
        v24 += 16;
        if ((unint64_t)v24 > v25)
        {
          if ((int)v19 >= 11) {
            int v35 = 11;
          }
          else {
            int v35 = v19;
          }
          LODWORD(v19) = v35 + 1;
          uint64_t v22 = ~(-1 << (v35 + 1));
          unint64_t v25 = v31 + 16 * v22;
        }
        if ((v29 & 0xFF00) != 0)
        {
          unint64_t v36 = *(unsigned __int16 *)(v31 + 16 * v29 + 8);
          if (!*(_WORD *)(v31 + 16 * v32 + 8))
          {
            TIFFErrorExtR(a1, "LZWDecodeCompat", "Wrong length of decoded string: data probably corrupted at scanline %u", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 876));
            return 0;
          }
          uint64_t v37 = v9 - v36;
          if (v9 < v36)
          {
            *(void *)(v8 + 200) = v34;
            unint64_t v50 = v34;
            do
              unint64_t v50 = *(void *)v50;
            while (*(unsigned __int16 *)(v50 + 8) > (unsigned __int16)v9);
            *(void *)(v8 + 168) = v9;
            do
            {
              v10[v9 - 1] = *(unsigned char *)(v50 + 11);
              unint64_t v50 = *(void *)v50;
              --v9;
            }
            while (v9);
            goto LABEL_55;
          }
          uint64_t v38 = &v10[v36];
          uint64_t v39 = v38 - 1;
          unint64_t v40 = v34;
          unint64_t v41 = v38 - 1;
          do
          {
            *v41-- = *(unsigned char *)(v40 + 11);
            unint64_t v40 = *(void *)v40;
            if (v40) {
              BOOL v42 = v39 > v10;
            }
            else {
              BOOL v42 = 0;
            }
            uint64_t v39 = v41;
          }
          while (v42);
          uint64_t v9 = v37;
        }
        else
        {
          *uint64_t v10 = v29;
          --v9;
          uint64_t v38 = v10 + 1;
        }
LABEL_50:
        unint64_t v23 = v34;
        uint64_t v10 = v38;
        if (v9 <= 0) {
          goto LABEL_55;
        }
      }
      do
      {
        uint64_t v24 = (char *)(*(void *)(v8 + 232) + 4128);
        _TIFFmemset(v24, 0, 0x12FD0uLL);
        if (v18 <= 8)
        {
          uint64_t v19 = *(void *)(v8 + 232) + 8176;
          TIFFWarningExtR(v52, "LZWDecodeCompat", "LZWDecode: Strip %u not terminated with EOI code", a4, a5, a6, a7, a8, *(_DWORD *)(v52 + 884));
          unint64_t v25 = v19;
          a1 = v52;
          LOWORD(v19) = 9;
          uint64_t v22 = 511;
          goto LABEL_53;
        }
        unint64_t v43 = ((unint64_t)*v17 << v20) | v21;
        uint64_t v44 = v20 + 8;
        if (v20 <= 0)
        {
          uint64_t v45 = v17[1];
          v17 += 2;
          v43 |= v45 << v44;
          uint64_t v44 = v20 + 16;
        }
        else
        {
          ++v17;
        }
        unsigned int v46 = v43 & 0x1FF;
        unint64_t v21 = v43 >> 9;
        uint64_t v20 = v44 - 9;
        v18 -= 9;
      }
      while (v46 == 256);
      if (v46 == 257)
      {
        unint64_t v25 = *(void *)(v8 + 232) + 8176;
        LOWORD(v19) = 9;
        uint64_t v22 = 511;
        unint64_t v34 = v23;
        a1 = v52;
        goto LABEL_55;
      }
      a1 = v52;
      if (v46 < 0x101)
      {
        unint64_t v25 = *(void *)(v8 + 232) + 8176;
        *uint64_t v10 = v43;
        --v9;
        unint64_t v34 = *(void *)(v8 + 232) + 16 * (v43 & 0x1FF);
        LODWORD(v19) = 9;
        uint64_t v38 = v10 + 1;
        uint64_t v22 = 511;
        goto LABEL_50;
      }
      TIFFErrorExtR(v52, *(const char **)v52, "LZWDecode: Corrupted LZW table at scanline %u", a4, a5, a6, a7, a8, *(_DWORD *)(v52 + 876));
      return 0;
    }
LABEL_53:
    unint64_t v34 = v23;
LABEL_55:
    uint64_t v47 = *(void *)(a1 + 1152) - (void)v17 + *(void *)(a1 + 1160);
    *(void *)(a1 + 1160) = v47;
    *(void *)(a1 + 1152) = v17;
    *(void *)(v8 + 176) = v18;
    *(void *)(v8 + 184) = v47;
    *(_WORD *)(v8 + 128) = v19;
    *(void *)(v8 + 136) = v21;
    *(void *)(v8 + 144) = v20;
    *(void *)(v8 + 160) = v22;
    *(void *)(v8 + 208) = v34;
    *(void *)(v8 + 216) = v24;
    *(void *)(v8 + 224) = v25;
    if (v9 >= 1)
    {
      TIFFErrorExtR(a1, "LZWDecodeCompat", "Not enough data at scanline %u (short %llu bytes)", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 876));
      return 0;
    }
  }
  return 1;
}

void PSDWritePlugin::~PSDWritePlugin(PSDWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t PSDWritePlugin::writeLayerMaskBlock8bit(IIOImageWriteSession **this, uint64_t (**a2)(IIOImagePixelDataProvider *, void *), uint64_t a3, unint64_t a4, PSDWritePlugin *size, __int16 a6, unint64_t a7, int a8)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = (char *)malloc_type_malloc((size_t)size, 0xA6E3977CuLL);
  int8x16_t v66 = 0uLL;
  uint64_t v78 = 0x4D49423800000000;
  int v80 = 255;
  long long v82 = gExtraData8bit;
  int8x8_t __ptr = 0;
  unsigned int v74 = 0;
  unsigned int v76 = 0;
  __int16 v68 = -1;
  uint64_t v69 = 0;
  unsigned int v70 = bswap32(a4);
  unsigned int v71 = bswap32(a3);
  uint64_t v72 = 4294902784;
  __int16 v73 = 0;
  __int16 v77 = 512;
  int v79 = 1836216174;
  int v81 = 805306368;
  __int16 v75 = 256;
  long long v83 = *(_OWORD *)"8BIMluni";
  long long v84 = xmmword_1889AD7C0;
  __int16 v61 = 256;
  long long v64 = 0u;
  long long v65 = 0u;
  uint64_t __nitems = 2 * a4;
  long long v62 = 0u;
  long long v63 = 0u;
  uint64_t v15 = (char *)malloc_type_malloc(2 * a4 * a7, 0x321DFE19uLL);
  if (v15 && (v59 = a6, (uint64_t v16 = (char *)malloc_type_malloc(a3 + a4 * a3 * a7, 0x34A1057uLL)) != 0))
  {
    if (a8) {
      unsigned int v17 = -1;
    }
    else {
      unsigned int v17 = 0;
    }
    int8x16_t v66 = vbslq_s8((int8x16_t)vdupq_n_s32(v17), (int8x16_t)xmmword_18898C3A0, (int8x16_t)xmmword_1889AD780);
    uint64_t v54 = (unsigned __int8 *)v16;
    unint64_t v56 = a4 * a3;
    if (a4)
    {
      uint64_t v50 = a3;
      uint64_t v51 = v15;
      uint64_t v48 = (PSDWritePlugin *)this;
      uint64_t v18 = 0;
      unsigned int v19 = 0;
      unint64_t v49 = (unsigned __int8 *)&v16[a3 + a4 * a3 * a7];
      int v57 = v14;
      unint64_t v58 = a7;
      uint64_t v20 = v15;
      int v21 = v59;
      do
      {
        unint64_t Bytes = (PSDWritePlugin *)IIOImagePixelDataProvider::getBytes(a2, v14);
        if (Bytes != size) {
          break;
        }
        unint64_t v23 = a4;
        unint64_t v25 = v49;
        uint64_t v24 = v50;
        if (a7)
        {
          unint64_t v26 = 0;
          unsigned int v27 = 1;
          uint64_t v60 = v18;
          do
          {
            uint64_t v28 = (const unsigned __int8 *)&v14[v66.i32[v26]];
            uint64_t v29 = *((void *)&v62 + v26);
            uint64_t v30 = v24;
            unint64_t v31 = v25;
            unint64_t v32 = v23;
            unint64_t Bytes = (PSDWritePlugin *)PSDWritePlugin::PackBits(Bytes, v28, v21, v24, &v54[v26 * v56 + v29], v25, 0);
            unint64_t v25 = v31;
            uint64_t v24 = v30;
            unint64_t v23 = v32;
            a7 = v58;
            *(_WORD *)&v20[2 * v60 + 2 * v26 * v32] = __rev16(Bytes);
            uint64_t v33 = v29 + Bytes;
            uint64_t v14 = v57;
            *((void *)&v62 + v26) = v33;
            unint64_t v26 = v27++;
          }
          while (v26 < v58);
        }
        uint64_t v18 = ++v19;
        a4 = v23;
      }
      while (v19 < v23);
      int v34 = DWORD2(v62);
      int v35 = v62;
      int v36 = DWORD2(v63);
      int v37 = v63;
      this = (IIOImageWriteSession **)v48;
      uint64_t v15 = v51;
    }
    else
    {
      int v36 = 0;
      int v37 = 0;
      int v34 = 0;
      int v35 = 0;
    }
    unsigned int v38 = __nitems + 2 + v35;
    unsigned int v39 = __nitems + 2 + v34;
    unsigned int v40 = __nitems + 2 + v37;
    unsigned int v41 = __nitems + 2 + v36;
    HIDWORD(v72) = bswap32(v38);
    unsigned int v74 = bswap32(v39);
    unsigned int v76 = bswap32(v40);
    LODWORD(v78) = bswap32(v41);
    int8x8_t __ptr = vrev32_s8((int8x8_t)vadd_s32(vdup_n_s32(v39 + v38 + v40 + v41), (int32x2_t)0x6C00000070));
    IIOImageWriteSession::putBytes(this[2], &__ptr, 0x74uLL);
    if (!a7)
    {
      uint64_t v46 = 0;
      uint64_t v44 = v54;
      if (!v14) {
        goto LABEL_25;
      }
      goto LABEL_24;
    }
    unint64_t v42 = 0;
    unsigned int v43 = 1;
    uint64_t v44 = v54;
    while (IIOImageWriteSession::putBytes(this[2], &v61, 2uLL) == 2)
    {
      if (IIOImageWriteSession::putBytes(this[2], &v15[2 * v42 * a4], __nitems) != __nitems) {
        break;
      }
      size_t v45 = *((void *)&v62 + v42);
      if (IIOImageWriteSession::putBytes(this[2], &v54[v42 * v56], v45) != v45) {
        break;
      }
      unint64_t v42 = v43++;
      if (v42 >= a7)
      {
        uint64_t v46 = 0;
        if (v14) {
          goto LABEL_24;
        }
        goto LABEL_25;
      }
    }
  }
  else
  {
    uint64_t v44 = 0;
  }
  uint64_t v46 = 4294967246;
  if (v14) {
LABEL_24:
  }
    free(v14);
LABEL_25:
  if (v44) {
    free(v44);
  }
  if (v15) {
    free(v15);
  }
  return v46;
}

uint64_t PSDWritePlugin::PackBits(PSDWritePlugin *this, const unsigned __int8 *a2, int a3, uint64_t a4, unsigned __int8 *a5, unsigned __int8 *a6, int a7)
{
  LOWORD(v7) = (_WORD)a5;
  if (a4 >= 1)
  {
    int v8 = a7 << 31 >> 31;
    uint64_t v9 = a3;
    uint64_t v10 = 2 * a3;
    uint64_t v7 = a5;
    do
    {
      uint64_t v11 = 0;
      uint64_t v12 = 1;
      BOOL v13 = 1;
      uint64_t v14 = a2;
      while (1)
      {
        if (a4 + v11 >= 3)
        {
          int v15 = *v14;
          if (v14[v9] == v15 && v14[v10] == v15) {
            break;
          }
        }
        v14 += v9;
        BOOL v13 = v12 < a4;
        --v11;
        ++v12;
        if (!(a4 + v11))
        {
          uint64_t v16 = a4;
          goto LABEL_9;
        }
      }
      if (!v11) {
        goto LABEL_19;
      }
      uint64_t v16 = -v11;
      do
      {
LABEL_9:
        if (v16 >= 127) {
          uint64_t v17 = 127;
        }
        else {
          uint64_t v17 = v16;
        }
        a4 -= v17;
        if (v7 >= a6) {
          break;
        }
        *v7++ = v17 - 1;
        if (v16 >= 1 && v7 < a6)
        {
          uint64_t v18 = v17;
          do
          {
            *v7++ = *a2 ^ v8;
            a2 += v9;
            if (v18 <= 1) {
              break;
            }
            --v18;
          }
          while (v7 < a6);
        }
        v16 -= v17;
      }
      while (v16 >= 1);
LABEL_19:
      if (v13)
      {
        int v19 = *a2;
        a2 += v9;
        if (a4 < 2)
        {
          uint64_t v21 = 1;
        }
        else
        {
          if ((unint64_t)(a4 - 2) >= 0x7D) {
            uint64_t v20 = 125;
          }
          else {
            uint64_t v20 = a4 - 2;
          }
          uint64_t v21 = v20 + 2;
          uint64_t v22 = -1;
          while (*a2 == v19)
          {
            a2 += v9;
            if (v20 == ++v22) {
              goto LABEL_32;
            }
          }
          uint64_t v21 = v22 + 2;
        }
LABEL_32:
        if (v7 >= a6) {
          return (unsigned __int16)((_WORD)v7 - (_WORD)a5);
        }
        *uint64_t v7 = 1 - v21;
        if (v7 + 1 >= a6)
        {
          LOWORD(v7) = (_WORD)v7 + 1;
          return (unsigned __int16)((_WORD)v7 - (_WORD)a5);
        }
        v7[1] = v19 ^ v8;
        v7 += 2;
        a4 -= v21;
      }
    }
    while (a4 > 0);
  }
  return (unsigned __int16)((_WORD)v7 - (_WORD)a5);
}

uint64_t PSDWritePlugin::writeLayerMaskBlock16bit(IIOImageWriteSession **this, uint64_t (**a2)(IIOImagePixelDataProvider *, void *), unint64_t a3, unint64_t a4, size_t size, unint64_t a6, unint64_t a7, unsigned int a8)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  BOOL v13 = (char *)malloc_type_malloc(size, 0x491520AFuLL);
  long long v89 = 0u;
  long long v90 = 0u;
  long long v87 = 0u;
  long long v88 = 0u;
  int v63 = 0;
  int v65 = 909210188;
  int v59 = 0;
  uint64_t __ptr = 0;
  unsigned int v73 = 0;
  unsigned int v75 = 0;
  long long v64 = xmmword_1889AD790;
  unsigned int v66 = 0;
  __int16 v67 = 256;
  uint64_t v68 = 0;
  unsigned int v69 = bswap32(a4);
  unsigned int v70 = bswap32(a3);
  uint64_t v71 = 4294902784;
  __int16 v72 = 0;
  __int16 v74 = 256;
  __int16 v76 = 512;
  uint64_t v77 = 0x4D49423800000000;
  int v78 = 1836216174;
  int v79 = 524543;
  int v80 = 1476395008;
  uint64_t v86 = 0x310020007200;
  long long v83 = xmmword_1889AD7F0;
  long long v84 = unk_1889AD800;
  long long v85 = xmmword_1889AD810;
  uint64_t v14 = 2 * a4 * a3;
  long long v82 = unk_1889AD7E0;
  long long v81 = gExtraData16bit;
  __int16 v60 = 768;
  int v15 = (unsigned __int8 *)malloc_type_malloc(v14 * a7 + v14, 0x9EFD133FuLL);
  uint64_t v16 = v15;
  if (v15)
  {
    unint64_t v58 = v13;
    unint64_t v61 = 0;
    if (a8) {
      uint64_t v17 = 0;
    }
    else {
      uint64_t v17 = 3;
    }
    uint64_t v18 = 1;
    if (a8) {
      uint64_t v18 = 2;
    }
    uint64_t v19 = 2;
    if (a8) {
      uint64_t v19 = 3;
    }
    unint64_t v55 = a4;
    if (a4)
    {
      LODWORD(v20) = 0;
      uint64_t v21 = a8;
      uint64_t v22 = (char *)&v15[8 * a4 * a3];
      unint64_t v23 = (char *)&v15[6 * a4 * a3];
      uint64_t v24 = (char *)&v15[4 * a4 * a3];
      unint64_t v25 = (char *)&v15[v14];
      uint64_t v54 = &v58[2 * v17];
      uint64_t v52 = &v58[2 * v18];
      unint64_t v53 = &v58[2 * v21];
      uint64_t v51 = &v58[2 * v19];
      do
      {
        if (IIOImagePixelDataProvider::getBytes(a2, v58) != size) {
          break;
        }
        if (a3)
        {
          uint64_t v26 = 0;
          unsigned int v27 = 1;
          uint64_t v28 = v51;
          uint64_t v29 = v52;
          uint64_t v30 = v53;
          unint64_t v31 = v54;
          do
          {
            __int16 v32 = *(_WORD *)v31;
            v31 += 8;
            *(_WORD *)&v25[v26] = v32;
            __int16 v33 = *(_WORD *)v30;
            v30 += 8;
            *(_WORD *)&v24[v26] = v33;
            __int16 v34 = *(_WORD *)v29;
            v29 += 8;
            *(_WORD *)&v23[v26] = v34;
            __int16 v35 = *(_WORD *)v28;
            v28 += 8;
            *(_WORD *)&v22[v26] = v35;
            unint64_t v36 = v27;
            v26 += 2;
            ++v27;
          }
          while (v36 < a3);
          v22 += v26;
          v23 += v26;
          v24 += v26;
          v25 += v26;
        }
        unint64_t v20 = (v20 + 1);
      }
      while (v20 < v55);
    }
    if (a7)
    {
      unint64_t v37 = 0;
      unsigned int v38 = 1;
      do
      {
        unint64_t v39 = v38;
        unint64_t v61 = v14;
        PSDWritePlugin::zipWithPrediction((PSDWritePlugin *)this, &v16[v14 * v38], v14, &v16[v37 * v14], &v61, a3, 16);
        *((void *)&v87 + v37) = v61;
        ++v38;
        unint64_t v37 = v39;
      }
      while (v39 < a7);
      unsigned int v40 = v87 + 2;
      unsigned int v41 = DWORD2(v87) + 2;
      unsigned int v42 = v88 + 2;
      unsigned int v43 = DWORD2(v88) + 2;
    }
    else
    {
      unsigned int v43 = 2;
      unsigned int v42 = 2;
      unsigned int v41 = 2;
      unsigned int v40 = 2;
    }
    HIDWORD(v71) = bswap32(v40);
    unsigned int v73 = bswap32(v41);
    unsigned int v75 = bswap32(v42);
    LODWORD(v77) = bswap32(v43);
    int v44 = v41 + v43 + v40 + v42;
    LODWORD(__ptr) = bswap32((v44 & 0xFFFFFFFC) + 184);
    unsigned int v66 = bswap32((v44 & 0xFFFFFFFC) + 152);
    IIOImageWriteSession::putBytes(this[2], &__ptr, 0xB8uLL);
    if (a7)
    {
      unint64_t v45 = 0;
      unsigned int v46 = 1;
      while (IIOImageWriteSession::putBytes(this[2], &v60, 2uLL) == 2)
      {
        uint64_t v47 = &v16[v45 * v14];
        size_t v48 = *((void *)&v87 + v45);
        if (IIOImageWriteSession::putBytes(this[2], v47, v48) != v48) {
          break;
        }
        unint64_t v45 = v46++;
        if (v45 >= a7) {
          goto LABEL_27;
        }
      }
      uint64_t v49 = 4294967246;
    }
    else
    {
LABEL_27:
      int v59 = 0;
      IIOImageWriteSession::putBytes(this[2], &v59, 4 - (v44 & 3));
      uint64_t v49 = 0;
    }
    BOOL v13 = v58;
    if (v58) {
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v49 = 4294967246;
    if (v13) {
LABEL_29:
    }
      free(v13);
  }
  if (v16) {
    free(v16);
  }
  return v49;
}

uint64_t PSDWritePlugin::zipWithPrediction(PSDWritePlugin *this, unsigned __int8 *a2, uint64_t a3, unsigned __int8 *a4, unint64_t *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = 2 * a6 - 2;
  int v8 = a2;
  uint64_t v9 = a3;
  do
  {
    if (a7 == 16)
    {
      if (a6 != 1)
      {
        uint64_t v10 = &v8[v7];
        uint64_t v11 = a6 - 1;
        uint64_t v12 = &v8[v7];
        do
        {
          __int16 v13 = *(v10 - 1);
          unsigned __int8 v14 = v10[1] - v13;
          v10[1] = v14;
          this = (PSDWritePlugin *)*v10;
          char v15 = *(v12 - 2);
          v12 -= 2;
          *uint64_t v10 = (_BYTE)this - ((unsigned __int16)(v13 + v14) >> 8) - v15;
          uint64_t v10 = v12;
          --v11;
        }
        while (v11);
        v8 += v7;
      }
      v8 += 2;
      uint64_t v16 = 2 * a6;
    }
    else
    {
      if (a6 != 1)
      {
        for (uint64_t i = a6; i != 1; --i)
          v8[i - 1] -= v8[i - 2];
        v8 += a6 - 1;
      }
      ++v8;
      uint64_t v16 = a6;
    }
    v9 -= v16;
  }
  while (v9 > 0);
  return PSDWritePlugin::zipWithoutPrediction(this, a2, a3, a4, a5);
}

uint64_t PSDWritePlugin::zipWithoutPrediction(PSDWritePlugin *this, unsigned __int8 *a2, uInt a3, unsigned __int8 *a4, unint64_t *a5)
{
  memset(&v10.avail_in, 0, 104);
  uint64_t v6 = *a5;
  v10.next_in = a2;
  v10.avail_in = a3;
  v10.next_out = a4;
  v10.avail_out = v6;
  *a5 = 0;
  if (deflateInit_(&v10, -1, "1.2.12", 112)) {
    return 0;
  }
  do
  {
    int v9 = deflate(&v10, 1);
    if (v9 == 1)
    {
      deflateEnd(&v10);
      goto LABEL_8;
    }
    unsigned int v8 = v9;
  }
  while (!v9 && v10.avail_in);
  deflateEnd(&v10);
  if (v8 > 1) {
    return 0;
  }
LABEL_8:
  *a5 = v6 - v10.avail_out;
  return 1;
}

uint64_t PSDWritePlugin::writeOneImage(PSDWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967292;
}

uint64_t PSDWritePlugin::writeOne(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  uint64_t v178 = *MEMORY[0x1E4F143B8];
  uint64_t v172 = 0;
  memset(v177, 0, sizeof(v177));
  uint64_t v168 = 0;
  uint64_t v169 = 0;
  uint64_t v167 = 0;
  uint64_t __ptr = 0;
  long long v163 = 0uLL;
  __int16 v164 = 0;
  unsigned int v165 = 0;
  int v166 = 1296646712;
  int AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a2);
  size_t size = (PSDWritePlugin *)IIOImagePlus::sourceImageProvider(a2);
  unint64_t v159 = IIOImageSource::count(a2);
  unint64_t v157 = IIO_Reader::testHeaderSize(a2);
  unsigned int Error = _cg_GifLastError((uint64_t)a2);
  unsigned int appleflags = _cg_png_get_appleflags((uint64_t)a2);
  SourceGeomCGColorSpaceRef ColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  int Type = CGColorSpaceGetType();
  CGColorSpaceModel Model = CGColorSpaceGetModel(SourceGeomColorSpace);
  size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(SourceGeomColorSpace);
  haschar Alpha = IIOImagePixelDataProvider::hasAlpha(a2);
  uint64_t Ref = (CGImage *)IIOImageSource::imageReadRef(a2);
  CGColorRenderingIntent RenderingIntent = CGImageGetRenderingIntent(Ref);
  __int16 v13 = CGColorSpaceCopyData(SourceGeomColorSpace, RenderingIntent);
  long long v135 = v13;
  if (v13)
  {
    CFDataRef v14 = v13;
    BytePtr = CFDataGetBytePtr(v13);
    unsigned int __nitems = CFDataGetLength(v14);
  }
  else
  {
    BytePtr = 0;
    unsigned int __nitems = 0;
  }
  unint64_t v171 = 0;
  int v170 = 0;
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a4, @"{IPTC}");
  int v158 = AlphaInfo;
  if (ObjectForKey)
  {
    uint64_t valuePtr = 0;
    uint64_t v174 = 0;
    uint64_t v175 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&valuePtr, ObjectForKey);
    CC_LONG v16 = SizeOfIPTCData((IIODictionary *)&valuePtr);
    CC_LONG v17 = v16;
    if (v16)
    {
      uint64_t v18 = (unsigned __int8 *)malloc_type_malloc(v16, 0xCCA8E47EuLL);
      if (!v18)
      {
        _cg_jpeg_mem_term("writeOne", 1413, "*** ERRROR: could not allocate iptcData - size=%d\n", v17);
        IIODictionary::~IIODictionary((IIODictionary *)&valuePtr);
        __int16 v35 = 0;
        unint64_t v37 = 0;
        unint64_t v36 = 0;
        table = 0;
        unsigned int v139 = -50;
        goto LABEL_150;
      }
      WriteIPTCData((CFDictionaryRef *)&valuePtr, v18);
    }
    else
    {
      uint64_t v18 = 0;
    }
    IIODictionary::~IIODictionary((IIODictionary *)&valuePtr);
  }
  else
  {
    CC_LONG v17 = 0;
    uint64_t v18 = 0;
  }
  CC_LONG v153 = v17;
  uint64_t v137 = v18;
  CGRect v144 = a2;
  if (a2)
  {
    uint64_t v19 = IIOImageSource::count(a2);
    unsigned int v20 = IIO_Reader::testHeaderSize(a2);
    uint64_t v21 = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  }
  else
  {
    uint64_t v19 = 0;
    unsigned int v20 = 0;
    uint64_t v21 = 0;
  }
  uint64_t v136 = (char *)CreateExifBufferFromPropertiesJPEG(a3, v19, v20, v21, 0, @"com.adobe.photoshop-image", &v171);
  if (v171 <= 6) {
    size_t v22 = 0;
  }
  else {
    size_t v22 = (v171 - 6);
  }
  if (IIODictionary::getBoolForKey(a4, @"kCGImageMetadataShouldExcludeXMP")) {
    goto LABEL_25;
  }
  CFDictionaryRef v23 = IIODictionary::getObjectForKey(a4, @"{MetaData}");
  uint64_t v24 = v23;
  if (v23)
  {
    CFTypeID v25 = CFGetTypeID(v23);
    if (v25 == CGImageMetadataGetTypeID())
    {
      CFDataRef XMPData = CGImageMetadataCreateXMPData(v24, 0);
      goto LABEL_23;
    }
  }
  unsigned int v27 = (const CGImageMetadata *)CGImageMetadataCreateFromLegacyProps(a4);
  uint64_t v28 = v27;
  if (!v27)
  {
LABEL_25:
    CFDataRef v29 = 0;
    goto LABEL_26;
  }
  CFDataRef XMPData = CGImageMetadataCreateXMPData(v27, 0);
  CFRelease(v28);
LABEL_23:
  CFDataRef v29 = XMPData;
  if (!XMPData)
  {
LABEL_26:
    long long v133 = 0;
    unsigned int Length = 0;
    goto LABEL_27;
  }
  long long v133 = CFDataGetBytePtr(XMPData);
  unsigned int Length = CFDataGetLength(XMPData);
  CFDataRef v29 = XMPData;
LABEL_27:
  if (Type == 7
    && (CFDataRef v31 = v29,
        BaseCGColorSpaceRef ColorSpace = CGColorSpaceGetBaseColorSpace(SourceGeomColorSpace),
        CGColorSpaceModel Model = CGColorSpaceGetModel(BaseColorSpace),
        CFDataRef v29 = v31,
        Model == kCGColorSpaceModelRGB))
  {
    int v149 = 0;
    __int16 v33 = 2;
    int v34 = v158;
  }
  else
  {
    if (Model) {
      __int16 v33 = 3;
    }
    else {
      __int16 v33 = 1;
    }
    int v34 = v158;
    if (Model < kCGColorSpaceModelCMYK)
    {
      int v149 = 0;
    }
    else if (Model == kCGColorSpaceModelCMYK)
    {
      int v149 = 1;
      __int16 v33 = 4;
    }
    else
    {
      if (Model != kCGColorSpaceModelLab) {
        goto LABEL_62;
      }
      int v149 = 0;
      __int16 v33 = 9;
    }
  }
  if (Error != 16 && Error != 8)
  {
LABEL_62:
    table = 0;
    unint64_t v36 = 0;
    unint64_t v37 = 0;
    __int16 v35 = 0;
    unsigned int v139 = -50;
    if (!v29) {
      goto LABEL_146;
    }
    goto LABEL_145;
  }
  __int16 v35 = 0;
  unsigned int v139 = -50;
  table = 0;
  unint64_t v36 = 0;
  unint64_t v37 = 0;
  if (size && SourceGeomColorSpace)
  {
    CFDataRef cf = v29;
    unint64_t v38 = NumberOfComponents + hasAlpha;
    BOOL v39 = v38 != 4 || v34 == 0;
    int v40 = v39;
    int v151 = v40;
    BOOL v42 = v34 == 4 || v34 == 2;
    unsigned int v140 = v42;
    LODWORD(__ptr) = 1397768760;
    WORD2(__ptr) = 256;
    WORD2(v163) = bswap32(v38) >> 16;
    *(_DWORD *)((char *)&v163 + 6) = bswap32(v157);
    *(_DWORD *)((char *)&v163 + 10) = bswap32(v159);
    unsigned int v138 = Error;
    HIWORD(v163) = bswap32(Error) >> 16;
    __int16 v164 = v33 << 8;
    if (IIOImageWriteSession::putBytes(this[2], &__ptr, 0x1AuLL) != 26)
    {
      table = 0;
      goto LABEL_61;
    }
    if (Type == 7)
    {
      bzero(&valuePtr, 0x304uLL);
      BYTE2(valuePtr) = 3;
      unsigned int v43 = CGColorSpaceGetBaseColorSpace(SourceGeomColorSpace);
      size_t v44 = CGColorSpaceGetNumberOfComponents(v43);
      size_t ColorTableCount = CGColorSpaceGetColorTableCount(SourceGeomColorSpace);
      table = (uint8_t *)malloc_type_malloc(ColorTableCount * v44, 0x100004077774924uLL);
      CGColorSpaceGetColorTable(SourceGeomColorSpace, table);
      if (ColorTableCount)
      {
        unsigned int v46 = (char *)(table + 2);
        uint64_t v47 = &v176;
        do
        {
          *((unsigned char *)v47 - 256) = *(v46 - 2);
          *(unsigned char *)uint64_t v47 = *(v46 - 1);
          char v48 = *v46;
          v46 += 3;
          *((unsigned char *)v47 + 256) = v48;
          uint64_t v47 = (int *)((char *)v47 + 1);
          --ColorTableCount;
        }
        while (ColorTableCount);
      }
      if (IIOImageWriteSession::putBytes(this[2], &valuePtr, 0x304uLL) != 772) {
        goto LABEL_61;
      }
    }
    else
    {
      LODWORD(valuePtr) = 0;
      __int16 v35 = 0;
      table = 0;
      if (IIOImageWriteSession::putBytes(this[2], &valuePtr, 4uLL) != 4)
      {
        unsigned int v139 = -50;
        unint64_t v36 = 0;
        unint64_t v37 = 0;
LABEL_130:
        CFDataRef v29 = cf;
        if (!cf) {
          goto LABEL_146;
        }
        goto LABEL_145;
      }
    }
    if (v151) {
      int v49 = 28;
    }
    else {
      int v49 = 54;
    }
    unsigned int v50 = v165 + v49;
    BOOL v51 = BytePtr != 0;
    BOOL v52 = __nitems != 0;
    BOOL v53 = v51 && v52;
    BOOL v39 = !v51 || !v52;
    int v54 = __nitems + (__nitems & 1) + 12;
    if (v39) {
      int v54 = 0;
    }
    BOOL v55 = v137 != 0;
    BOOL v56 = v153 != 0;
    BOOL v57 = v56 && v55;
    BOOL v39 = !v56 || !v55;
    int v58 = v153 + (v153 & 1) + 12;
    if (v39) {
      int v58 = 0;
    }
    unsigned int v59 = v50 + v54 + v58;
    int v60 = v22 + (v22 & 1) + 12;
    if (v136 == 0 || v22 == 0) {
      int v60 = 0;
    }
    unsigned int v61 = v59 + v60;
    if (v133) {
      BOOL v62 = Length == 0;
    }
    else {
      BOOL v62 = 1;
    }
    int v63 = !v62;
    int v129 = v63;
    if (!v62)
    {
      if (v57) {
        int v64 = 40;
      }
      else {
        int v64 = 12;
      }
      v61 += Length + (Length & 1) + v64;
    }
    unsigned int v165 = bswap32(v61);
    if (IIOImageWriteSession::putBytes(this[2], &v165, 4uLL) == 4
      && ((v151 & 1) != 0 || IIOImageWriteSession::putBytes(this[2], &gAlphaNames, 0x1AuLL) == 26))
    {
      LOWORD(v167) = -4861;
      HIDWORD(v167) = 0x10000000;
      if (IIOImageWriteSession::putBytes(this[2], &v166, 0xCuLL) == 12)
      {
        if (IIODictionary::containsKey(a3, @"DPIWidth")
          && IIODictionary::containsKey(a3, @"DPIHeight"))
        {
          FloatForKeCGFloat y = IIODictionary::getFloatForKey(a3, @"DPIWidth");
          float v66 = *(float *)&FloatForKey;
          double v67 = IIODictionary::getFloatForKey(a3, @"DPIHeight");
          unsigned int v68 = (int)(float)((float)(v66 * 65536.0) + 0.5);
          unsigned int v69 = (int)(float)((float)(*(float *)&v67 * 65536.0) + 0.5);
        }
        else
        {
          unsigned int v68 = 4718592;
          unsigned int v69 = 4718592;
        }
        uint64_t v168 = bswap32(v68) | 0x100010000000000;
        uint64_t v169 = bswap32(v69) | 0x100010000000000;
        if (IIOImageWriteSession::putBytes(this[2], &v168, 0x10uLL) == 16)
        {
          if (!v53
            || (LOWORD(v167) = 3844,
                HIDWORD(v167) = bswap32(__nitems),
                IIOImageWriteSession::putBytes(this[2], &v166, 0xCuLL) == 12)
            && IIOImageWriteSession::putBytes(this[2], BytePtr, __nitems) == __nitems
            && ((__nitems & 1) == 0 || IIOImageWriteSession::putBytes(this[2], &v172, 1uLL) == 1))
          {
            if (!v57
              || (LOWORD(v167) = 1028,
                  HIDWORD(v167) = bswap32(v153),
                  IIOImageWriteSession::putBytes(this[2], &v166, 0xCuLL) == 12)
              && IIOImageWriteSession::putBytes(this[2], v137, v153) == v153
              && ((v153 & 1) == 0 || IIOImageWriteSession::putBytes(this[2], &v172, 1uLL) == 1))
            {
              if (v136 == 0
                || v22 == 0
                || (LOWORD(v167) = 8708,
                    HIDWORD(v167) = bswap32(v22),
                    IIOImageWriteSession::putBytes(this[2], &v166, 0xCuLL) == 12)
                && IIOImageWriteSession::putBytes(this[2], v136 + 6, v22) == v22
                && ((v22 & 1) == 0 || IIOImageWriteSession::putBytes(this[2], &v172, 1uLL) == 1))
              {
                if (v129)
                {
                  LOWORD(v167) = 9220;
                  HIDWORD(v167) = bswap32(Length);
                  if (IIOImageWriteSession::putBytes(this[2], &v166, 0xCuLL) != 12
                    || IIOImageWriteSession::putBytes(this[2], v133, Length) != Length
                    || (Length & 1) != 0 && IIOImageWriteSession::putBytes(this[2], &v172, 1uLL) != 1)
                  {
                    goto LABEL_61;
                  }
                  if (v57)
                  {
                    IIMHashArrayForIIMBlocuint64_t k = CreateIIMHashArrayForIIMBlock(v137, v153);
                    LOWORD(v167) = 9476;
                    HIDWORD(v167) = 0x10000000;
                    if (IIOImageWriteSession::putBytes(this[2], &v166, 0xCuLL) != 12) {
                      goto LABEL_61;
                    }
                    for (CFIndex i = 0; i != 16; ++i)
                    {
                      LOBYTE(valuePtr) = 0;
                      if (IIMHashArrayForIIMBlock)
                      {
                        ValueAtIndeCGFloat x = (const __CFNumber *)CFArrayGetValueAtIndex(IIMHashArrayForIIMBlock, i);
                        CFNumberGetValue(ValueAtIndex, kCFNumberCharType, &valuePtr);
                      }
                      if (IIOImageWriteSession::putBytes(this[2], &valuePtr, 1uLL) != 1) {
                        goto LABEL_61;
                      }
                    }
                    if (IIMHashArrayForIIMBlock) {
                      CFRelease(IIMHashArrayForIIMBlock);
                    }
                  }
                }
                __int16 v35 = (char *)malloc_type_malloc((size_t)size, 0xFD5E2F1FuLL);
                if (v35)
                {
                  v161 = (IIODictionary *)(appleflags / Error);
                  if (v151)
                  {
                    LODWORD(v174) = 0;
                    uint64_t valuePtr = 0x8000000;
                    unsigned int v139 = -50;
                    if (IIOImageWriteSession::putBytes(this[2], &valuePtr, 0xCuLL) != 12)
                    {
LABEL_142:
                      unint64_t v36 = 0;
LABEL_143:
                      unint64_t v37 = 0;
                      CFDataRef v29 = cf;
                      goto LABEL_144;
                    }
                    unint64_t v74 = v159;
                    unint64_t v75 = v157;
                    uint64_t v76 = Error;
                  }
                  else
                  {
                    if (Error == 8) {
                      unsigned int v139 = PSDWritePlugin::writeLayerMaskBlock8bit(this, (uint64_t (**)(IIOImagePixelDataProvider *, void *))v144, v159, v157, size, (__int16)v161, 4uLL, v140);
                    }
                    else {
                      unsigned int v139 = PSDWritePlugin::writeLayerMaskBlock16bit(this, (uint64_t (**)(IIOImagePixelDataProvider *, void *))v144, v159, v157, (size_t)size, v73, 4uLL, v140);
                    }
                    unint64_t v74 = v159;
                    unint64_t v75 = v157;
                    uint64_t v76 = Error;
                    if (v139) {
                      goto LABEL_142;
                    }
                    unsigned int v139 = 0;
                  }
                  int v170 = 0;
                  unint64_t v77 = v75 * v74;
                  if (v76 != 8)
                  {
                    unsigned int v130 = 0;
                    unint64_t v36 = 0;
                    unint64_t v78 = (v77 * v76) >> 3;
                    goto LABEL_162;
                  }
                  size_t v79 = (2 * v38 * v75);
                  int v170 = 256;
                  uint64_t v80 = ((v74 + 127) * (unsigned __int128)0x204081020408103uLL) >> 64;
                  unint64_t v81 = v74 + ((v80 + ((v74 + 127 - v80) >> 1)) >> 6);
                  unint64_t v78 = v81 * v75;
                  if (v79)
                  {
                    unint64_t v82 = v81 * v75;
                    unsigned int v130 = 2 * v38 * v75;
                    unint64_t v36 = malloc_type_malloc(v79, 0x7CA154A9uLL);
                    unint64_t v78 = v82;
                    if (!v36)
                    {
                      _cg_jpeg_mem_term("writeOne", 1737, "*** ERRROR: could not allocate rlebuf - size=%d\n", v130);
                      goto LABEL_142;
                    }
                  }
                  else
                  {
                    unsigned int v130 = 0;
                    unint64_t v36 = 0;
                  }
LABEL_162:
                  if (is_mul_ok(v38, v78))
                  {
                    size_t v154 = v78;
                    unint64_t v84 = v38 * v78;
                    unsigned int v156 = (unsigned __int8 *)malloc_type_malloc(v38 * v78, 0xCDD4E68BuLL);
                    if (v156)
                    {
                      if (v138 == 16 && v38)
                      {
                        uint64_t v85 = 0;
                        do
                          *((void *)v177 + v85++) = v154;
                        while (v38 > v85);
                      }
                      IIOImagePixelDataProvider::rewind(v144);
                      if (v157)
                      {
                        uint64_t v86 = 0;
                        unsigned int v143 = 0;
                        __nitemsa = &v156[v84];
                        unint64_t v87 = v38 - 1;
                        BOOL v90 = v138 != 8 || v36 == 0 || v38 == 0;
                        BOOL v134 = v90;
                        uint64_t v91 = 2 * v77;
                        unsigned int v152 = v36;
                        while (1)
                        {
                          unint64_t Bytes = (PSDWritePlugin *)IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))v144, v35);
                          if (Bytes != size) {
                            goto LABEL_223;
                          }
                          if (v138 == 16)
                          {
                            unint64_t v93 = &v156[2 * v159 * v143];
                            switch(v158)
                            {
                              case 0:
                              case 5:
                                if (v159)
                                {
                                  LODWORD(v94) = 0;
                                  uint64_t v95 = v35;
                                  do
                                  {
                                    if (v38)
                                    {
                                      uint64_t v96 = 0;
                                      unsigned int v97 = 1;
                                      uint64_t v98 = v93;
                                      do
                                      {
                                        *(_WORD *)uint64_t v98 = *(_WORD *)&v95[2 * v96] ^ ((__int16)((_WORD)v149 << 15) >> 15);
                                        uint64_t v96 = v97;
                                        v98 += v91;
                                        BOOL v99 = v38 > v97++;
                                      }
                                      while (v99);
                                    }
                                    unint64_t v94 = (v94 + 1);
                                    v95 += 2 * (void)v161;
                                    v93 += 2;
                                  }
                                  while (v159 > v94);
                                }
                                break;
                              case 1:
                              case 3:
                                if (v159)
                                {
                                  unint64_t v107 = 0;
                                  uint64_t v108 = v35;
                                  do
                                  {
                                    uint64_t v109 = 0;
                                    if (v38 == 1)
                                    {
                                      unint64_t v112 = v159;
                                      unint64_t v113 = v157;
                                    }
                                    else
                                    {
                                      unsigned int v110 = 1;
                                      BOOL v111 = v93;
                                      unint64_t v112 = v159;
                                      unint64_t v113 = v157;
                                      do
                                      {
                                        *(_WORD *)BOOL v111 = *(_WORD *)&v108[2 * v109] ^ ((__int16)((_WORD)v149 << 15) >> 15);
                                        uint64_t v109 = v110;
                                        v111 += v91;
                                        BOOL v99 = v87 > v110++;
                                      }
                                      while (v99);
                                    }
                                    *(_WORD *)&v156[2 * v107 + 2 * (v86 + v109 * v113) * v112] = *(_WORD *)&v108[2 * v109];
                                    unint64_t v107 = (v107 + 1);
                                    v108 += 2 * (void)v161;
                                    v93 += 2;
                                  }
                                  while (v112 > v107);
                                }
                                break;
                              case 2:
                              case 4:
                                if (v159)
                                {
                                  unint64_t v114 = 0;
                                  unsigned int v115 = v35;
                                  do
                                  {
                                    if (v38 == 1)
                                    {
                                      uint64_t v121 = 0;
                                      unint64_t v118 = v159;
                                      unint64_t v119 = v157;
                                    }
                                    else
                                    {
                                      unsigned int v116 = 1;
                                      uint64_t v117 = v93;
                                      unint64_t v118 = v159;
                                      unint64_t v119 = v157;
                                      do
                                      {
                                        unsigned int v120 = v116;
                                        *(_WORD *)uint64_t v117 = v115[v116] ^ ((__int16)((_WORD)v149 << 15) >> 15);
                                        v117 += v91;
                                        ++v116;
                                      }
                                      while (v87 > v120);
                                      uint64_t v121 = v120;
                                    }
                                    *(_WORD *)&v156[2 * v114 + 2 * (v86 + v121 * v119) * v118] = *v115;
                                    unint64_t v114 = (v114 + 1);
                                    v115 += (uint64_t)v161;
                                    v93 += 2;
                                  }
                                  while (v118 > v114);
                                }
                                break;
                              case 6:
                                if (v159)
                                {
                                  LODWORD(v122) = 0;
                                  long long v123 = v35;
                                  do
                                  {
                                    if (v38)
                                    {
                                      unsigned int v124 = 1;
                                      long long v125 = v93;
                                      do
                                      {
                                        *(_WORD *)long long v125 = *(_WORD *)&v123[2 * v124] ^ ((__int16)((_WORD)v149 << 15) >> 15);
                                        v125 += v91;
                                        BOOL v99 = v38 > v124++;
                                      }
                                      while (v99);
                                    }
                                    unint64_t v122 = (v122 + 1);
                                    v123 += 2 * (void)v161;
                                    v93 += 2;
                                  }
                                  while (v159 > v122);
                                }
                                break;
                              default:
                                goto LABEL_222;
                            }
                            goto LABEL_222;
                          }
                          uint64_t v100 = v156;
                          if (!v134) {
                            break;
                          }
LABEL_222:
                          uint64_t v86 = ++v143;
                          unint64_t v36 = v152;
                          if (v157 <= v143) {
                            goto LABEL_223;
                          }
                        }
                        uint64_t v101 = 0;
                        unsigned int v102 = 1;
                        while (1)
                        {
                          if (v158 == 2) {
                            goto LABEL_194;
                          }
                          unint64_t v103 = (const unsigned __int8 *)&v35[v101];
                          if (v158 == 6)
                          {
                            ++v103;
                            goto LABEL_196;
                          }
                          if (v158 == 4) {
LABEL_194:
                          }
                            unint64_t v103 = (const unsigned __int8 *)&v35[v102 % v161];
LABEL_196:
                          unsigned int v104 = v35;
                          uint64_t v105 = *((void *)v177 + v101);
                          unint64_t Bytes = (PSDWritePlugin *)PSDWritePlugin::PackBits(Bytes, v103, (__int16)v161, v159, &v100[v101 * v154 + v105], __nitemsa, v149);
                          uint64_t v106 = v105 + Bytes;
                          __int16 v35 = v104;
                          uint64_t v100 = v156;
                          *((_WORD *)v152 + v86 + v101 * v157) = __rev16(Bytes);
                          *((void *)v177 + v101) = v106;
                          uint64_t v101 = v102;
                          BOOL v99 = v38 > v102++;
                          if (!v99) {
                            goto LABEL_222;
                          }
                        }
                      }
LABEL_223:
                      if (IIOImageWriteSession::putBytes(this[2], &v170, 2uLL) == 2
                        && (!v36 || IIOImageWriteSession::putBytes(this[2], v36, v130) == v130))
                      {
                        if (v38)
                        {
                          uint64_t v126 = 0;
                          unsigned int v127 = 1;
                          while (1)
                          {
                            size_t v128 = *((void *)v177 + v126);
                            if (IIOImageWriteSession::putBytes(this[2], &v156[v126 * v154], v128) != v128) {
                              break;
                            }
                            uint64_t v126 = v127;
                            BOOL v99 = v38 > v127++;
                            if (!v99) {
                              goto LABEL_230;
                            }
                          }
                        }
                        else
                        {
LABEL_230:
                          unsigned int v139 = 0;
                        }
                      }
                      CFDataRef v29 = cf;
                      unint64_t v37 = v156;
                      if (!cf) {
                        goto LABEL_146;
                      }
LABEL_145:
                      CFRelease(v29);
                      goto LABEL_146;
                    }
                    _cg_jpeg_mem_term("writeOne", 1742, "*** ERRROR: could not allocate fullbuf - size=%d\n", 0);
                  }
                  goto LABEL_143;
                }
                _cg_jpeg_mem_term("writeOne", 1694, "*** ERRROR: could not allocate rowbuf - size=%d\n", size);
              }
            }
          }
        }
      }
    }
LABEL_61:
    unint64_t v36 = 0;
    unint64_t v37 = 0;
    __int16 v35 = 0;
    unsigned int v139 = -50;
    goto LABEL_130;
  }
LABEL_144:
  if (v29) {
    goto LABEL_145;
  }
LABEL_146:
  if (v136) {
    free(v136);
  }
  if (v137) {
    free(v137);
  }
LABEL_150:
  if (v135) {
    CFRelease(v135);
  }
  if (v37) {
    free(v37);
  }
  if (v35) {
    free(v35);
  }
  if (v36) {
    free(v36);
  }
  if (table) {
    free(table);
  }
  return v139;
}

void sub_1887E197C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46)
{
}

BOOL PSDWritePlugin::WriteProc(PSDWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v9, this, a2, 1347634208);
  *(void *)&v9[0] = &unk_1ED4E2C80;
  BOOL v5 = IIOWritePlugin::writeAll((IIOImageDestination **)v9) != 0;
  _cg_jpeg_mem_term(v9, v6, v7);
  return v5;
}

void sub_1887E1A38(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t _cg_RadReadRGBSize(FILE *a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  *a3 = 0;
  if (!a1) {
    return 4294967246;
  }
  memset(v9, 0, sizeof(v9));
  int v10 = 0;
  uint64_t v8 = 0;
  if (RGBE_ReadHeader(a1, (uint64_t)&v8 + 4, (uint64_t)&v8, (uint64_t)v9)) {
    return 4294967246;
  }
  int v6 = v8;
  uint64_t result = 4294967246;
  if ((HIDWORD(v8) - 1) >> 14) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = (int)v8 < 1;
  }
  if (!v7 && v8 <= 0x4000)
  {
    uint64_t result = 0;
    *a2 = HIDWORD(v8);
    *a3 = v6;
  }
  return result;
}

uint64_t _cg_RadReadRGB_float(FILE *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t result = 4294967246;
  if (a1 && a2)
  {
    uint64_t v10 = 0;
    memset(v11, 0, sizeof(v11));
    int v12 = 0;
    if (RGBE_ReadHeader(a1, (uint64_t)&v10 + 4, (uint64_t)&v10, (uint64_t)v11)
      || SHIDWORD(v10) < 1
      || HIDWORD(v10) > 0x4000
      || (v10 - 16385) < 0xFFFFC000)
    {
      return 4294967246;
    }
    unint64_t v7 = 4 * (3 * HIDWORD(v10) * v10);
    BOOL v8 = v7 <= a3 && v7 >= HIDWORD(v10);
    if (!v8 || v7 < v10) {
      return 4294967246;
    }
    if ((v11[0] & 8) != 0)
    {
      if (!RGBE_ReadPixels_RLE(a1, a2, HIDWORD(v10), v10)) {
        return 0;
      }
    }
    else if ((v11[0] & 0x10) != 0 && !ReadFloatPixels(a1, a2, SHIDWORD(v10), v10))
    {
      return 0;
    }
    return 4294967246;
  }
  return result;
}

uint64_t ReadFloatPixels(FILE *__stream, uint64_t a2, int a3, int a4)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (__stream)
  {
    uint64_t v6 = a2;
    if (a2)
    {
      int v7 = a4;
      if (a4)
      {
        while (1)
        {
          int v12 = 0;
          uint64_t v11 = 0;
          if (a3) {
            break;
          }
LABEL_9:
          uint64_t result = 0;
          if (!--v7) {
            return result;
          }
        }
        int v9 = a3;
        while (fread(&v11, 0xCuLL, 1uLL, __stream))
        {
          *(void *)uint64_t v6 = v11;
          uint64_t v10 = v6 + 12;
          *(_DWORD *)(v6 + 8) = v12;
          v6 += 12;
          if (!--v9)
          {
            uint64_t v6 = v10;
            goto LABEL_9;
          }
        }
        return 0xFFFFFFFFLL;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t _cg_RadReadRGB_fp16(FILE *a1, void *a2, unsigned int a3)
{
  uint64_t v3 = 0;
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v18 = 0;
  memset(v19, 0, sizeof(v19));
  int v20 = 0;
  uint64_t v4 = 4294967246;
  if (a1 && a2)
  {
    if (RGBE_ReadHeader(a1, (uint64_t)&v18 + 4, (uint64_t)&v18, (uint64_t)v19))
    {
LABEL_4:
      uint64_t v3 = 0;
      goto LABEL_5;
    }
    uint64_t v3 = 0;
    if (HIDWORD(v18) <= 0x4000 && v18 <= 0x4000)
    {
      uint64_t v3 = 0;
      if (HIDWORD(v18))
      {
        if (v18)
        {
          unint64_t v9 = 2 * (3 * HIDWORD(v18) * v18);
          if (v9 > a3 || v9 < SHIDWORD(v18) || v9 < (int)v18) {
            goto LABEL_4;
          }
          uint64_t v3 = malloc_type_malloc(4 * (4 * HIDWORD(v18) * v18), 0x100004052888210uLL);
          if (!v3) {
            goto LABEL_5;
          }
          if ((v19[0] & 8) != 0)
          {
            if (RGBE_ReadPixels_RLE(a1, (uint64_t)v3, HIDWORD(v18), v18)) {
              goto LABEL_5;
            }
LABEL_24:
            memset(&srcFormat.colorSpace, 0, 32);
            *(void *)&srcFormat.bitsPerComponent = 0x8000000020;
            srcFormat.bitmapInfo = 8453;
            memset(&destFormat.colorSpace, 0, 32);
            *(void *)&destFormat.bitsPerComponent = 0x4000000010;
            destFormat.bitmapInfo = 4357;
            vImage_Error error = 0;
            int v12 = vImageConverter_CreateWithCGImageFormat(&srcFormat, &destFormat, 0, 0, &error);
            srcs.data = v3;
            srcs.double height = (int)v18;
            srcs.double width = SHIDWORD(v18);
            srcs.rowunint64_t Bytes = 16 * SHIDWORD(v18);
            dests.data = a2;
            dests.double height = (int)v18;
            dests.double width = SHIDWORD(v18);
            dests.rowunint64_t Bytes = 8 * SHIDWORD(v18);
            vImage_Error error = vImageConvert_AnyToAny(v12, &srcs, &dests, 0, 0x10u);
            vImageConverter_Release(v12);
            uint64_t v4 = 0;
            goto LABEL_5;
          }
          if ((v19[0] & 0x10) != 0 && !ReadFloatPixels(a1, (uint64_t)v3, SHIDWORD(v18), v18)) {
            goto LABEL_24;
          }
        }
      }
    }
  }
LABEL_5:
  free(v3);
  return v4;
}

float *TIFFCIELabToXYZ(float *a1, int a2, int a3, int a4, float *a5, float *a6, float *a7)
{
  return TIFFCIELab16ToXYZ(a1, 257 * a2, a3 << 8, a4 << 8, a5, a6, a7);
}

float *TIFFCIELab16ToXYZ(float *result, unsigned int a2, int a3, int a4, float *a5, float *a6, float *a7)
{
  float v7 = (float)((float)a2 * 100.0) / 65535.0;
  if (v7 >= 8.856)
  {
    float v9 = (float)(v7 + 16.0) / 116.0;
    *a6 = v9 * (float)(v9 * (float)(v9 * result[5]));
  }
  else
  {
    float v8 = (float)(v7 * result[5]) / 903.29;
    *a6 = v8;
    float v9 = (float)((float)(v8 / result[5]) * 7.787) + 0.13793;
  }
  float v10 = (float)((float)((float)a3 * 0.0039062) / 500.0) + v9;
  float v11 = result[4];
  if (v10 >= 0.2069) {
    float v12 = v10 * (float)(v10 * (float)(v10 * v11));
  }
  else {
    float v12 = (float)((float)(v10 + -0.13793) * v11) / 7.787;
  }
  *a5 = v12;
  float v13 = v9 + (float)((float)((float)a4 * -0.0039062) / 200.0);
  float v14 = result[6];
  if (v13 >= 0.2069) {
    float v15 = v13 * (float)(v13 * (float)(v13 * v14));
  }
  else {
    float v15 = (float)((float)(v13 + -0.13793) * v14) / 7.787;
  }
  *a7 = v15;
  return result;
}

float *TIFFXYZToRGB(float *result, int *a2, int *a3, int *a4, float a5, float a6, float a7)
{
  float v7 = (float)((float)(result[8] * a6) + (float)(result[7] * a5)) + (float)(result[9] * a7);
  float v8 = (float)((float)(result[11] * a6) + (float)(result[10] * a5)) + (float)(result[12] * a7);
  float v9 = (float)((float)(result[14] * a6) + (float)(result[13] * a5)) + (float)(result[15] * a7);
  float v10 = result[22];
  float v11 = result[23];
  if (v7 <= v10) {
    float v7 = result[22];
  }
  if (v8 <= v11) {
    float v8 = result[23];
  }
  float v12 = result[24];
  if (v9 <= v12) {
    float v9 = result[24];
  }
  if (v7 >= result[16]) {
    float v7 = result[16];
  }
  if (v8 >= result[17]) {
    float v8 = result[17];
  }
  if (v9 >= result[18]) {
    float v9 = result[18];
  }
  float v13 = result[2];
  unint64_t v14 = (unint64_t)(float)((float)(v7 - v10) / result[1]);
  if (*(int *)result < v14) {
    unint64_t v14 = *(int *)result;
  }
  float v15 = result[v14 + 28];
  if (v15 <= 0.0) {
    double v16 = -0.5;
  }
  else {
    double v16 = 0.5;
  }
  *a2 = (v16 + v15);
  unint64_t v17 = (unint64_t)(float)((float)(v8 - v11) / v13);
  if (*(int *)result < v17) {
    unint64_t v17 = *(int *)result;
  }
  float v18 = result[v17 + 1529];
  double v19 = v18;
  if (v18 <= 0.0) {
    double v20 = -0.5;
  }
  else {
    double v20 = 0.5;
  }
  *a3 = (v20 + v19);
  unint64_t v21 = (unint64_t)(float)((float)(v9 - v12) / result[3]);
  if (*(int *)result < v21) {
    unint64_t v21 = *(int *)result;
  }
  float v22 = result[v21 + 3030];
  double v23 = v22;
  if (v22 <= 0.0) {
    double v24 = -0.5;
  }
  else {
    double v24 = 0.5;
  }
  *a4 = (v24 + v23);
  int v25 = *a2;
  if (*a2 >= *((_DWORD *)result + 19)) {
    int v25 = *((_DWORD *)result + 19);
  }
  *a2 = v25;
  int v26 = *a3;
  if (*a3 >= *((_DWORD *)result + 20)) {
    int v26 = *((_DWORD *)result + 20);
  }
  *a3 = v26;
  int v27 = *a4;
  if (*a4 >= *((_DWORD *)result + 21)) {
    int v27 = *((_DWORD *)result + 21);
  }
  *a4 = v27;
  return result;
}

uint64_t TIFFCIELabToRGBInit(float *a1, const void *a2, int *a3)
{
  *(_DWORD *)a1 = 1500;
  _TIFFmemcpy(a1 + 7, a2, 0x54uLL);
  unint64_t v5 = 0;
  double v6 = 1.0 / a1[25];
  uint64_t v7 = *(int *)a1;
  float v8 = (float)(int)v7;
  a1[1] = (float)(a1[16] - a1[22]) / (float)(int)v7;
  float v9 = (float)*((unsigned int *)a1 + 19);
  double v10 = (double)(int)v7;
  if ((unint64_t)(v7 + 1) > 1) {
    uint64_t v11 = v7 + 1;
  }
  else {
    uint64_t v11 = 1;
  }
  uint64x2_t v42 = (uint64x2_t)vdupq_n_s64(v11 - 1);
  int64x2_t v36 = vdupq_n_s64(2uLL);
  int64x2_t v12 = (int64x2_t)xmmword_18898C840;
  do
  {
    long double v13 = COERCE_DOUBLE(vmovn_s64((int64x2_t)vcgeq_u64(v42, (uint64x2_t)v12)));
    int64x2_t v39 = v12;
    if (LOBYTE(v13))
    {
      char v33 = BYTE4(v13);
      long double v13 = pow((double)v5 / v10, v6);
      int64x2_t v12 = v39;
      *(float *)&long double v13 = v13;
      a1[v5 + 28] = *(float *)&v13 * v9;
      BYTE4(v13) = v33;
    }
    if (BYTE4(v13))
    {
      long double v14 = pow((double)(v5 + 1) / v10, v6);
      int64x2_t v12 = v39;
      *(float *)&long double v14 = v14;
      a1[v5 + 29] = *(float *)&v14 * v9;
    }
    v5 += 2;
    int64x2_t v12 = vaddq_s64(v12, v36);
  }
  while (((v11 + 1) & 0xFFFFFFFFFFFFFFFELL) != v5);
  double v15 = 1.0 / a1[26];
  a1[2] = (float)(a1[16] - a1[22]) / v8;
  float v16 = (float)*((unsigned int *)a1 + 20);
  unint64_t v17 = a1 + 1530;
  int64x2_t v18 = (int64x2_t)xmmword_18898C840;
  uint64_t v19 = 1530;
  int64x2_t v37 = vdupq_n_s64(2uLL);
  do
  {
    long double v20 = COERCE_DOUBLE(vmovn_s64((int64x2_t)vcgeq_u64(v42, (uint64x2_t)v18)));
    int64x2_t v40 = v18;
    if (LOBYTE(v20))
    {
      char v34 = BYTE4(v20);
      long double v20 = pow((double)(unint64_t)(v19 - 1530) / v10, v15);
      int64x2_t v18 = v40;
      *(float *)&long double v20 = v20;
      *(v17 - 1) = *(float *)&v20 * v16;
      BYTE4(v20) = v34;
    }
    if (BYTE4(v20))
    {
      long double v21 = pow((double)(unint64_t)(v19 - 1529) / v10, v15);
      int64x2_t v18 = v40;
      *(float *)&long double v21 = v21;
      *unint64_t v17 = *(float *)&v21 * v16;
    }
    int64x2_t v18 = vaddq_s64(v18, v37);
    v19 += 2;
    v17 += 2;
  }
  while (v19 - ((v11 + 1) & 0xFFFFFFFFFFFFFFFELL) != 1530);
  double v22 = 1.0 / a1[27];
  unsigned int v23 = *((_DWORD *)a1 + 21);
  a1[3] = (float)(a1[16] - a1[22]) / v8;
  float v24 = (float)v23;
  uint64_t v25 = v11 + 1;
  int v26 = a1 + 3031;
  uint64_t v27 = -(uint64_t)(v25 & 0xFFFFFFFFFFFFFFFELL);
  int64x2_t v28 = (int64x2_t)xmmword_18898C840;
  uint64_t v29 = 3031;
  int64x2_t v38 = vdupq_n_s64(2uLL);
  do
  {
    long double v30 = COERCE_DOUBLE(vmovn_s64((int64x2_t)vcgeq_u64(v42, (uint64x2_t)v28)));
    int64x2_t v41 = v28;
    if (LOBYTE(v30))
    {
      char v35 = BYTE4(v30);
      long double v30 = pow((double)(unint64_t)(v29 - 3031) / v10, v22);
      int64x2_t v28 = v41;
      *(float *)&long double v30 = v30;
      *(v26 - 1) = *(float *)&v30 * v24;
      BYTE4(v30) = v35;
    }
    if (BYTE4(v30))
    {
      long double v31 = pow((double)(unint64_t)(v29 - 3030) / v10, v22);
      int64x2_t v28 = v41;
      *(float *)&long double v31 = v31;
      *int v26 = *(float *)&v31 * v24;
    }
    int64x2_t v28 = vaddq_s64(v28, v38);
    v29 += 2;
    v26 += 2;
  }
  while (v27 + v29 != 3031);
  *((_DWORD *)a1 + 4) = *a3;
  *((_DWORD *)a1 + 5) = a3[1];
  *((_DWORD *)a1 + 6) = a3[2];
  return 0;
}

void *TIFFYCbCrtoRGB(void *result, unsigned int a2, int a3, int a4, int *a5, int *a6, int *a7)
{
  if (a2 >= 0xFF) {
    unsigned int v7 = 255;
  }
  else {
    unsigned int v7 = a2;
  }
  if (a3 >= 255) {
    int v8 = 255;
  }
  else {
    int v8 = a3;
  }
  if (a4 >= 255) {
    int v9 = 255;
  }
  else {
    int v9 = a4;
  }
  unsigned int v10 = v9 & ~(v9 >> 31);
  uint64_t v11 = result[5];
  uint64_t v12 = result[2];
  int v13 = *(_DWORD *)(result[1] + 4 * v10) + *(_DWORD *)(v11 + 4 * v7);
  unsigned int v14 = v8 & ~(v8 >> 31);
  if (v13 >= 255) {
    int v13 = 255;
  }
  *a5 = v13 & ~(v13 >> 31);
  int v15 = *(_DWORD *)(v11 + 4 * v7) + ((*(_DWORD *)(result[3] + 4 * v10) + *(_DWORD *)(result[4] + 4 * v14)) >> 16);
  if (v15 >= 255) {
    int v15 = 255;
  }
  *a6 = v15 & ~(v15 >> 31);
  int v16 = *(_DWORD *)(v12 + 4 * v14) + *(_DWORD *)(v11 + 4 * v7);
  if (v16 >= 255) {
    int v17 = 255;
  }
  else {
    int v17 = v16;
  }
  *a7 = v17 & ~(v17 >> 31);
  return result;
}

uint64_t TIFFYCbCrToRGBInit(void *a1, float *a2, float *a3)
{
  _TIFFmemset(a1 + 6, 0, 0x100uLL);
  uint64_t v6 = 0;
  *a1 = a1 + 38;
  int8x16_t v7 = (int8x16_t)xmmword_18898F090;
  v8.i64[0] = 0x1010101010101010;
  v8.i64[1] = 0x1010101010101010;
  do
  {
    *(int8x16_t *)&a1[v6 + 38] = v7;
    v6 += 2;
    int8x16_t v7 = vaddq_s8(v7, v8);
  }
  while (v6 != 32);
  _TIFFmemset(a1 + 70, 255, 0x200uLL);
  a1[1] = a1 + 134;
  a1[2] = a1 + 262;
  a1[3] = a1 + 390;
  a1[4] = a1 + 518;
  if ((float)(a3[1] - *a3) == 0.0) {
    *(float *)v11.i32 = 1.0;
  }
  else {
    *(float *)v11.i32 = a3[1] - *a3;
  }
  float v12 = a3[2] + -128.0;
  if ((float)((float)(a3[3] + -128.0) - v12) == 0.0) {
    *(float *)v10.i32 = 1.0;
  }
  else {
    *(float *)v10.i32 = (float)(a3[3] + -128.0) - v12;
  }
  unsigned int v13 = (int)v12;
  float v14 = a3[4] + -128.0;
  *(float *)v9.i32 = (float)(a3[5] + -128.0) - v14;
  if (*(float *)v9.i32 == 0.0) {
    *(float *)v9.i32 = 1.0;
  }
  unsigned int v15 = (int)v14;
  float v17 = a2[1];
  float v16 = a2[2];
  float v18 = (float)(v16 * -2.0) + 2.0;
  float v19 = *a2;
  float v20 = (float)(v16 * v18) / v17;
  float v21 = v20 * 65536.0;
  if (v20 > 2.0) {
    float v21 = 131070.0;
  }
  BOOL v22 = v20 < 0.0;
  float v23 = 0.0;
  if (v22) {
    float v21 = 0.0;
  }
  unsigned int v24 = (int)(v21 + 0.5);
  float v25 = v18 * 65536.0;
  if (v18 > 2.0) {
    float v25 = 131070.0;
  }
  if (v18 < 0.0) {
    float v26 = 0.0;
  }
  else {
    float v26 = v25;
  }
  unsigned int v27 = (int)(v26 + 0.5);
  float v28 = (float)(v19 * -2.0) + 2.0;
  float v29 = (float)(v19 * v28) / v17;
  float v30 = v29 * 65536.0;
  if (v29 > 2.0) {
    float v30 = 131070.0;
  }
  if (v29 < 0.0) {
    float v31 = 0.0;
  }
  else {
    float v31 = v30;
  }
  unsigned int v32 = (int)(v31 + 0.5);
  if (v28 <= 2.0) {
    float v33 = v28 * 65536.0;
  }
  else {
    float v33 = 131070.0;
  }
  if (v28 >= 0.0) {
    float v23 = v33;
  }
  double v34 = v23 + 0.5;
  int32x4_t v35 = vdupq_n_s32(v15);
  unsigned int v36 = (int)v34;
  float32x4_t v37 = (float32x4_t)vdupq_lane_s32(v9, 0);
  int32x4_t v38 = vdupq_n_s32(v13);
  float32x4_t v39 = (float32x4_t)vdupq_lane_s32(v10, 0);
  int32x4_t v40 = vdupq_n_s32(v36);
  int32x4_t v41 = vdupq_n_s32(v27);
  int32x4_t v42 = vdupq_n_s32(v32);
  int32x4_t v43 = vdupq_n_s32(v24);
  int32x4_t v44 = vdupq_n_s32((int)*a3);
  a1[5] = a1 + 646;
  float32x4_t v45 = (float32x4_t)vdupq_lane_s32(v11, 0);
  int32x4_t v46 = (int32x4_t)xmmword_1889AD880;
  uint64_t v47 = 262;
  v48.i64[0] = 0x8000000080;
  v48.i64[1] = 0x8000000080;
  v49.i64[0] = 0x400000004;
  v49.i64[1] = 0x400000004;
  do
  {
    float32x4_t v50 = (float32x4_t)vdupq_n_s32(0x42FE0000u);
    float32x4_t v51 = vdivq_f32(vmulq_f32(vcvtq_f32_s32(vsubq_s32(v46, v35)), v50), v37);
    float32x4_t v52 = (float32x4_t)vdupq_n_s32(0xC5800000);
    float32x4_t v53 = (float32x4_t)vdupq_n_s32(0x45800000u);
    int32x4_t v54 = vcvtq_s32_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v52, v51), (int8x16_t)v52, vbslq_s8((int8x16_t)vcgtq_f32(v51, v53), (int8x16_t)v53, (int8x16_t)v51)));
    float32x4_t v55 = vdivq_f32(vmulq_f32(vcvtq_f32_s32(vsubq_s32(v46, v38)), v50), v39);
    int32x4_t v56 = vcvtq_s32_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v52, v55), (int8x16_t)v52, vbslq_s8((int8x16_t)vcgtq_f32(v55, v53), (int8x16_t)v53, (int8x16_t)v55)));
    v57.i64[0] = 0x800000008000;
    v57.i64[1] = 0x800000008000;
    int v58 = (int32x4_t *)&a1[v47];
    *(int32x4_t *)&a1[v47 - 128] = vshrq_n_s32(vmlaq_s32(v57, v40, v54), 0x10uLL);
    v57.i64[0] = 0x800000008000;
    v57.i64[1] = 0x800000008000;
    *int v58 = vshrq_n_s32(vmlaq_s32(v57, v41, v56), 0x10uLL);
    v58[64] = vnegq_s32(vmulq_s32(v42, v54));
    v54.i64[0] = 0x800000008000;
    v54.i64[1] = 0x800000008000;
    v58[128] = vmlsq_s32(v54, v43, v56);
    float32x4_t v59 = vdivq_f32(vmulq_f32(vcvtq_f32_s32(vaddq_s32(vsubq_s32(v46, v44), v48)), (float32x4_t)vdupq_n_s32(0x437F0000u)), v45);
    v58[192] = vcvtq_s32_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v52, v59), (int8x16_t)v52, vbslq_s8((int8x16_t)vcgtq_f32(v59, v53), (int8x16_t)v53, (int8x16_t)v59)));
    int32x4_t v46 = vaddq_s32(v46, v49);
    v47 += 2;
  }
  while (v47 != 390);
  return 0;
}

const char *IIOCMErrorString(int a1)
{
  if (a1 > -15475)
  {
    if (a1 <= -12849)
    {
      switch(a1)
      {
        case -12912:
          uint64_t result = "kVTVideoEncoderMalfunctionErr";
          break;
        case -12911:
          uint64_t result = "kVTVideoDecoderMalfunctionErr";
          break;
        case -12910:
          uint64_t result = "kVTVideoDecoderUnsupportedDataFormatErr";
          break;
        case -12909:
          uint64_t result = "kVTVideoDecoderBadDataErr";
          break;
        case -12908:
          uint64_t result = "kVTCouldNotFindVideoEncoderErr";
          break;
        case -12907:
          uint64_t result = "kVTCouldNotCreateInstanceErr";
          break;
        case -12906:
          uint64_t result = "kVTCouldNotFindVideoDecoderErr";
          break;
        case -12905:
        case -12904:
        case -12903:
          goto LABEL_52;
        case -12902:
          uint64_t result = "kVTParameterErr";
          break;
        default:
          switch(a1)
          {
            case -15474:
              uint64_t result = "kCMPhotoError_SubsamplingOrBitDepthNotSupported";
              break;
            case -15473:
              uint64_t result = "kCMPhotoError_SequenceFrameEncodeFailed";
              break;
            case -15472:
              uint64_t result = "kCMPhotoError_AsyncAuxiliaryEncodeFailed";
              break;
            case -15471:
              uint64_t result = "kCMPhotoError_PixelTransferNotAllowed";
              break;
            case -15470:
              uint64_t result = "kCMPhotoError_XPCError";
              break;
            default:
              goto LABEL_52;
          }
          break;
      }
      return result;
    }
    if (a1 > -6664)
    {
      if (a1 <= -6662)
      {
        if (a1 == -6663) {
          return "kCVReturnUnsupported";
        }
        else {
          return "kCVReturnAllocationFailed";
        }
      }
      if (a1 == -6661) {
        return "kCVReturnInvalidArgument";
      }
      if (a1 == 1100) {
        return "BOOTSTRAP_NOT_PRIVILEGED (media server is NOT running)";
      }
    }
    else
    {
      if (a1 > -6685)
      {
        switch(a1)
        {
          case -6684:
            uint64_t result = "kCVReturnPixelBufferNotMetalCompatible";
            break;
          case -6683:
            uint64_t result = "kCVReturnPixelBufferNotOpenGLCompatible";
            break;
          case -6682:
            uint64_t result = "kCVReturnInvalidPixelBufferAttributes";
            break;
          case -6681:
            uint64_t result = "kCVReturnInvalidSize";
            break;
          case -6680:
            uint64_t result = "kCVReturnInvalidPixelFormat";
            break;
          default:
            goto LABEL_52;
        }
        return result;
      }
      switch(a1)
      {
        case -12848:
          return "kFigFormatReaderError_ParsingFailure";
        case -12783:
          return "kCMBaseObjectError_ValueNotAvailable";
        case -12782:
          return "kCMBaseObjectError_UnsupportedOperation";
      }
    }
LABEL_52:
    uint64_t v2 = (a1 & 0x3FFF) - 736;
    if (v2 > 4) {
      return "unknown error";
    }
    else {
      return off_1E53CD0C0[v2];
    }
  }
  switch(a1)
  {
    case -17109:
      uint64_t result = "kCMPhotoError_ThumbnailEncodeFailed";
      break;
    case -17108:
      uint64_t result = "kCMPhotoError_FileStructureLocked";
      break;
    case -17107:
      uint64_t result = "kCMPhotoError_TimeoutReached";
      break;
    case -17106:
      uint64_t result = "kCMPhotoError_DataTooLarge";
      break;
    case -17105:
      uint64_t result = "kCMPhotoError_RequestCanceled";
      break;
    case -17104:
      uint64_t result = "kCMPhotoError_FrameDropped";
      break;
    case -17103:
      uint64_t result = "kCMPhotoError_InvalidCropRect";
      break;
    case -17102:
      uint64_t result = "kCMPhotoError_InvalidData";
      break;
    case -17101:
      uint64_t result = "kCMPhotoError_InvalidSession";
      break;
    case -17100:
      uint64_t result = "kCMPhotoError_UnsupportedQuality";
      break;
    default:
      JUMPOUT(0);
  }
  return result;
}

void HEIFExif::HEIFExif (HEIFExif *this, __CFReadStream *a2)
{
  *(void *)this = &unk_1ED4E5B78;
  int v2 = HEIFExif::readFromStream((UInt8 *)this, a2);
  if (v2)
  {
    int v3 = v2;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = v3;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
}

uint64_t HEIFExif::readFromStream(UInt8 *this, CFReadStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) == 4
    && (*(_DWORD *)buffer != 1179211845 || CFReadStreamRead(stream, this + 8, 16) == 16))
  {
    return 0;
  }
  else
  {
    return 4294967246;
  }
}

void HEIFItem::HEIFItem(HEIFItem *this, const __CFDictionary *a2)
{
  *(void *)this = &unk_1ED4E5B98;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  memset(v17, 0, sizeof(v17));
  int v3 = IIODictionary::IIODictionary((IIODictionary *)v17, a2);
  if (IIODictionary::containsKeyGroup(v3, @"CoordinateSystemID", @"CameraExtrinsics"))
  {
    *((_DWORD *)this + 2) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v17, @"CoordinateSystemID", @"CameraExtrinsics");
    *((unsigned char *)this + 184) = 1;
  }
  CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup((IIODictionary *)v17, @"Position", @"CameraExtrinsics");
  if (ObjectForKeyGroup)
  {
    *((unsigned char *)this + 185) = 1;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    unint64_t v5 = IIOArray::IIOArray((IIOArray *)&v14, ObjectForKeyGroup);
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 0x40000000;
    v13[2] = ___ZN8HEIFItemC2EPK14__CFDictionary_block_invoke;
    void v13[3] = &__block_descriptor_tmp_57;
    v13[4] = this;
    IIOArray::enumerate((uint64_t)v5, (uint64_t)v13);
    IIOArray::~IIOArray((IIOArray *)&v14);
  }
  CFDictionaryRef v6 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v17, @"Rotation", @"CameraExtrinsics");
  if (v6)
  {
    *((unsigned char *)this + 186) = 1;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    int8x16_t v7 = IIOArray::IIOArray((IIOArray *)&v14, v6);
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 0x40000000;
    void v12[2] = ___ZN8HEIFItemC2EPK14__CFDictionary_block_invoke_2;
    void v12[3] = &__block_descriptor_tmp_58;
    v12[4] = this;
    IIOArray::enumerate((uint64_t)v7, (uint64_t)v12);
    IIOArray::~IIOArray((IIOArray *)&v14);
  }
  CFDictionaryRef v8 = IIODictionary::getObjectForKeyGroup((IIODictionary *)v17, @"Intrinsics", @"CameraModel");
  if (v8)
  {
    *((unsigned char *)this + 187) = 1;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    int32x2_t v9 = IIOArray::IIOArray((IIOArray *)&v14, v8);
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 0x40000000;
    v11[2] = ___ZN8HEIFItemC2EPK14__CFDictionary_block_invoke_3;
    void v11[3] = &__block_descriptor_tmp_59_0;
    UInt8 v11[4] = this;
    IIOArray::enumerate((uint64_t)v9, (uint64_t)v11);
    IIOArray::~IIOArray((IIOArray *)&v14);
  }
  CFStringRef v10 = (const __CFString *)IIODictionary::getObjectForKeyGroup((IIODictionary *)v17, @"ModelType", @"CameraModel");
  if (v10) {
    *((void *)this + 24) = CFStringCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v10);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v17);
}

void sub_1887E3094(_Unwind_Exception *a1)
{
  IIOArray::~IIOArray((IIOArray *)(v1 - 80));
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 56));
  _Unwind_Resume(a1);
}

void ___ZN8HEIFItemC2EPK14__CFDictionary_block_invoke(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  if (cf && a3 <= 2)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFNumberGetTypeID())
    {
      IIONumber::IIONumber((IIONumber *)v7, (const __CFNumber *)cf);
      *(double *)(v5 + 8 * a3 + 16) = IIONumber::doubleNum((IIONumber *)v7);
      IIONumber::~IIONumber((IIONumber *)v7);
    }
  }
}

void sub_1887E315C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void ___ZN8HEIFItemC2EPK14__CFDictionary_block_invoke_2(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  if (cf && a3 <= 8)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFNumberGetTypeID())
    {
      IIONumber::IIONumber((IIONumber *)v7, (const __CFNumber *)cf);
      *(double *)(v5 + 8 * a3 + 40) = IIONumber::doubleNum((IIONumber *)v7);
      IIONumber::~IIONumber((IIONumber *)v7);
    }
  }
}

void sub_1887E31F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void ___ZN8HEIFItemC2EPK14__CFDictionary_block_invoke_3(uint64_t a1, CFTypeRef cf, uint64_t a3)
{
  if (cf && a3 <= 8)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFNumberGetTypeID())
    {
      IIONumber::IIONumber((IIONumber *)v7, (const __CFNumber *)cf);
      *(double *)(v5 + 8 * a3 + 112) = IIONumber::doubleNum((IIONumber *)v7);
      IIONumber::~IIONumber((IIONumber *)v7);
    }
  }
}

void sub_1887E3284(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void HEIFItem::HEIFItem(HEIFItem *this, __CFReadStream *a2)
{
  *(void *)this = &unk_1ED4E5B98;
  int v2 = HEIFItem::readFromStream(this, a2);
  if (v2)
  {
    int v3 = v2;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = v3;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
}

uint64_t HEIFItem::readFromStream(HEIFItem *this, CFReadStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 0;
  CFReadStreamRead(stream, buffer, 4);
  uint64_t result = 0;
  if (*(_DWORD *)buffer == 1835365449)
  {
    if (CFReadStreamRead(stream, (UInt8 *)this + 8, 192) == 192)
    {
      *((void *)this + 24) = 0;
      *(_DWORD *)int8x16_t v7 = 0;
      if (CFReadStreamRead(stream, v7, 4) == 4)
      {
        if (!*(_DWORD *)v7) {
          return 0;
        }
        uint64_t v5 = (UInt8 *)malloc_type_malloc(*(unsigned int *)v7, 0x70B9F09BuLL);
        CFIndex v6 = CFReadStreamRead(stream, v5, *(unsigned int *)v7);
        if (v6 == *(unsigned int *)v7)
        {
          *((void *)this + 24) = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5, v6, 0x8000100u, 1u);
          free(v5);
          return 0;
        }
        free(v5);
      }
    }
    return 4294967246;
  }
  return result;
}

void HEIFItem::~HEIFItem(HEIFItem *this)
{
  *(void *)this = &unk_1ED4E5B98;
  int v2 = (const void *)*((void *)this + 24);
  if (v2)
  {
    CFRelease(v2);
    *((void *)this + 24) = 0;
  }
}

{
  uint64_t vars8;

  HEIFItem::~HEIFItem(this);

  JUMPOUT(0x18C11C0E0);
}

void HEIFItem::updateProperties(HEIFItem *this, IIODictionary *a2)
{
  uint64_t v17 = 0;
  float v18 = 0;
  uint64_t v19 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v17);
  IIODictionary::setObjectForKey(a2, v18, @"{HEIF}");
  if (*((_WORD *)this + 92) || *((unsigned char *)this + 186))
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v14);
    IIODictionary::setObjectForKey((IIODictionary *)&v17, v15, @"CameraExtrinsics");
    if (*((unsigned char *)this + 184))
    {
      IIONumber::IIONumber((IIONumber *)&v11, *((_DWORD *)this + 2));
      IIODictionary::setObjectForKey((IIODictionary *)&v14, value, @"CoordinateSystemID");
      IIONumber::~IIONumber((IIONumber *)&v11);
    }
    if (*((unsigned char *)this + 185))
    {
      CFMutableArrayRef v11 = 0;
      float v12 = 0;
      xpc_object_t value = 0;
      IIOArray::IIOArray((IIOArray *)&v11);
      for (uint64_t i = 0; i != 24; i += 8)
      {
        IIONumber::IIONumber((IIONumber *)v10, *(double *)((char *)this + i + 16));
        IIOArray::addObject(&v11, (uint64_t)v10);
        IIONumber::~IIONumber((IIONumber *)v10);
      }
      IIODictionary::setObjectForKey((IIODictionary *)&v14, v12, @"Position");
      IIOArray::~IIOArray((IIOArray *)&v11);
    }
    if (*((unsigned char *)this + 186))
    {
      CFMutableArrayRef v11 = 0;
      float v12 = 0;
      xpc_object_t value = 0;
      IIOArray::IIOArray((IIOArray *)&v11);
      for (uint64_t j = 40; j != 112; j += 8)
      {
        IIONumber::IIONumber((IIONumber *)v9, *(double *)((char *)this + j));
        IIOArray::addObject(&v11, (uint64_t)v9);
        IIONumber::~IIONumber((IIONumber *)v9);
      }
      IIODictionary::setObjectForKey((IIODictionary *)&v14, v12, @"Rotation");
      IIOArray::~IIOArray((IIOArray *)&v11);
    }
    IIODictionary::~IIODictionary((IIODictionary *)&v14);
  }
  if (*((unsigned char *)this + 187) || *((void *)this + 24))
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v14);
    IIODictionary::setObjectForKey((IIODictionary *)&v17, v15, @"CameraModel");
    if (*((unsigned char *)this + 187))
    {
      CFMutableArrayRef v11 = 0;
      float v12 = 0;
      xpc_object_t value = 0;
      IIOArray::IIOArray((IIOArray *)&v11);
      for (uint64_t k = 0; k != 72; k += 8)
      {
        IIONumber::IIONumber((IIONumber *)v8, *(double *)((char *)this + k + 112));
        IIOArray::addObject(&v11, (uint64_t)v8);
        IIONumber::~IIONumber((IIONumber *)v8);
      }
      IIODictionary::setObjectForKey((IIODictionary *)&v14, v12, @"Intrinsics");
      IIOArray::~IIOArray((IIOArray *)&v11);
    }
    int8x16_t v7 = (const void *)*((void *)this + 24);
    if (v7) {
      IIODictionary::setObjectForKey((IIODictionary *)&v14, v7, @"ModelType");
    }
    IIODictionary::~IIODictionary((IIODictionary *)&v14);
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v17);
}

void sub_1887E371C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  IIOArray::~IIOArray((IIOArray *)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v10 - 80));
  IIODictionary::~IIODictionary((IIODictionary *)(v10 - 56));
  _Unwind_Resume(a1);
}

uint64_t HEIFItem::writeToStream(HEIFItem *this, CFWriteStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 1835365449;
  CFWriteStreamWrite(stream, buffer, 4);
  CFWriteStreamWrite(stream, (const UInt8 *)this + 8, 192);
  *(_DWORD *)float v12 = 0;
  CFStringRef v4 = (const __CFString *)*((void *)this + 24);
  if (!v4)
  {
    uint64_t v10 = v12;
    int32x2_t v9 = stream;
    CFIndex v8 = 4;
    goto LABEL_8;
  }
  *(_DWORD *)float v12 = CFStringGetLength(v4);
  CStringPtr = CFStringGetCStringPtr(*((CFStringRef *)this + 24), 0x8000100u);
  if (CStringPtr) {
    BOOL v6 = *(_DWORD *)v12 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6)
  {
    int8x16_t v7 = (UInt8 *)CStringPtr;
    CFWriteStreamWrite(stream, v12, 4);
    CFIndex v8 = *(unsigned int *)v12;
    int32x2_t v9 = stream;
    uint64_t v10 = v7;
LABEL_8:
    CFWriteStreamWrite(v9, v10, v8);
  }
  return 0;
}

void HEIFXMP::HEIFXMP(HEIFXMP *this, __CFReadStream *a2)
{
  *(void *)this = &unk_1ED4E5A18;
  int v2 = HEIFXMP::readFromStream((UInt8 *)this, a2);
  if (v2)
  {
    int v3 = v2;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = v3;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
}

uint64_t HEIFXMP::readFromStream(UInt8 *this, CFReadStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) == 4
    && (*(_DWORD *)buffer != 542133592 || CFReadStreamRead(stream, this + 8, 16) == 16))
  {
    return 0;
  }
  else
  {
    return 4294967246;
  }
}

void HEIFStereoAggressor::HEIFStereoAggressor(HEIFStereoAggressor *this, const __CFDictionary *a2)
{
  *((void *)this + 1) = 0;
  int v3 = (CFTypeRef *)((char *)this + 8);
  *(void *)this = &unk_1ED4B4470;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  memset(v8, 0, sizeof(v8));
  IIODictionary::IIODictionary((IIODictionary *)v8, a2);
  if (IIODictionary::containsKey((IIODictionary *)v8, @"Type"))
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v8, @"Type");
    CFTypeRef *v3 = CFRetain(ObjectForKey);
  }
  if (IIODictionary::containsKey((IIODictionary *)v8, @"SubTypeURI"))
  {
    CFDictionaryRef v5 = IIODictionary::getObjectForKey((IIODictionary *)v8, @"SubTypeURI");
    *((void *)this + 2) = CFRetain(v5);
  }
  unsigned int v6 = IIODictionary::containsKey((IIODictionary *)v8, @"Severity");
  LODWORD(FloatForKey) = -1.0;
  if (v6) {
    FloatForKeCGFloat y = IIODictionary::getFloatForKey((IIODictionary *)v8, @"Severity");
  }
  *((_DWORD *)this + 6) = LODWORD(FloatForKey);
  IIODictionary::~IIODictionary((IIODictionary *)v8);
}

void sub_1887E3A74(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void HEIFStereoAggressor::HEIFStereoAggressor(HEIFStereoAggressor *this, __CFReadStream *a2)
{
  *(void *)this = &unk_1ED4B4470;
  int v2 = HEIFStereoAggressor::readFromStream((UInt8 *)this, a2);
  if (v2)
  {
    int v3 = v2;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = v3;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
}

uint64_t HEIFStereoAggressor::readFromStream(UInt8 *this, CFReadStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) == 4
    && (*(_DWORD *)buffer != 1195463763 || CFReadStreamRead(stream, this + 8, 24) == 24))
  {
    return 0;
  }
  else
  {
    return 4294967246;
  }
}

void HEIFStereoAggressor::~HEIFStereoAggressor(HEIFStereoAggressor *this)
{
  *(void *)this = &unk_1ED4B4470;
  int v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  int v3 = (const void *)*((void *)this + 2);
  if (v3) {
    CFRelease(v3);
  }
}

{
  uint64_t vars8;

  HEIFStereoAggressor::~HEIFStereoAggressor(this);

  JUMPOUT(0x18C11C0E0);
}

BOOL HEIFStereoAggressor::hasSeverity(HEIFStereoAggressor *this)
{
  return *((float *)this + 6) >= 0.0;
}

float HEIFStereoAggressor::getSeverity(HEIFStereoAggressor *this)
{
  return *((float *)this + 6);
}

void HEIFGroupItem::HEIFGroupItem(HEIFGroupItem *this, const __CFDictionary *a2, const __CFDictionary *a3, int a4)
{
  *(void *)this = &unk_1ED4DFBF0;
  *((_OWORD *)this + 2) = 0u;
  *((void *)this + 1) = 0;
  int8x16_t v7 = (_DWORD *)((char *)this + 8);
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  memset(v17, 0, sizeof(v17));
  CFIndex v8 = IIODictionary::IIODictionary((IIODictionary *)v17, a2);
  *((_DWORD *)this + 3) = a4;
  *int8x16_t v7 = IIODictionary::getUint32ForKey(v8, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Group_Type);
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v17, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Group_PictureIndexList);
  memset(v16, 0, sizeof(v16));
  uint64_t v10 = IIOArray::IIOArray((IIOArray *)v16, ObjectForKey);
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 0x40000000;
  _OWORD v15[2] = ___ZN13HEIFGroupItemC2EPK14__CFDictionaryS2_j_block_invoke;
  void v15[3] = &__block_descriptor_tmp_81;
  void v15[4] = this;
  IIOArray::enumerate((uint64_t)v10, (uint64_t)v15);
  if (a3)
  {
    memset(v14, 0, sizeof(v14));
    IIODictionary::IIODictionary((IIODictionary *)v14, a3);
    if (IIODictionary::containsKey((IIODictionary *)v14, *(const __CFString **)gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_DisparityAdjustment))
    {
      *((unsigned char *)this + 20) = 1;
      *((_DWORD *)this + 4) = IIODictionary::getUint32ForKey((IIODictionary *)v14, *(const __CFString **)gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_DisparityAdjustment);
    }
    CFDictionaryRef v11 = IIODictionary::getObjectForKey((IIODictionary *)v17, @"StereoAggressors");
    memset(v13, 0, sizeof(v13));
    IIOArray::IIOArray((IIOArray *)v13, v11);
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 0x40000000;
    void v12[2] = ___ZN13HEIFGroupItemC2EPK14__CFDictionaryS2_j_block_invoke_2;
    void v12[3] = &__block_descriptor_tmp_85_0;
    UInt8 v12[4] = this;
    IIOArray::enumerate((uint64_t)v13, (uint64_t)v12);
    if (IIODictionary::containsKey((IIODictionary *)v14, *(const __CFString **)gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_MonoImageLocation))*((_DWORD *)this + 6) = IIODictionary::getUint32ForKey((IIODictionary *)v14, *(const __CFString **)gIIO_kCMPhotoCompressionContainerDescription_GroupProperty_MonoImageLocation); {
    IIOArray::~IIOArray((IIOArray *)v13);
    }
    IIODictionary::~IIODictionary((IIODictionary *)v14);
  }
  IIOArray::~IIOArray((IIOArray *)v16);
  IIODictionary::~IIODictionary((IIODictionary *)v17);
}

void sub_1887E3E60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIOArray::~IIOArray((IIOArray *)(v11 - 112));
  IIODictionary::~IIODictionary((IIODictionary *)(v11 - 88));
  unsigned int v13 = (void *)v9[7];
  if (v13)
  {
    v9[8] = v13;
    operator delete(v13);
  }
  uint64_t v14 = *v10;
  if (*v10)
  {
    void v9[5] = v14;
    operator delete(v14);
  }
  _Unwind_Resume(a1);
}

void ___ZN13HEIFGroupItemC2EPK14__CFDictionaryS2_j_block_invoke(uint64_t a1, const __CFNumber *a2)
{
  int v2 = *(void **)(a1 + 32);
  memset(v17, 0, sizeof(v17));
  IIONumber::IIONumber((IIONumber *)v17, a2);
  int v3 = IIONumber::uint32Num((IIONumber *)v17);
  int v4 = v3;
  unint64_t v5 = v2[6];
  unsigned int v6 = (char *)v2[5];
  if ((unint64_t)v6 >= v5)
  {
    CFIndex v8 = (char *)v2[4];
    uint64_t v9 = (v6 - v8) >> 2;
    if ((unint64_t)(v9 + 1) >> 62) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = v5 - (void)v8;
    unint64_t v11 = (uint64_t)(v5 - (void)v8) >> 1;
    if (v11 <= v9 + 1) {
      unint64_t v11 = v9 + 1;
    }
    if (v10 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v11;
    }
    if (v12)
    {
      unsigned int v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)(v2 + 6), v12);
      CFIndex v8 = (char *)v2[4];
      unsigned int v6 = (char *)v2[5];
    }
    else
    {
      unsigned int v13 = 0;
    }
    uint64_t v14 = &v13[4 * v9];
    uint64_t v15 = &v13[4 * v12];
    *(_DWORD *)uint64_t v14 = v4;
    int8x16_t v7 = v14 + 4;
    while (v6 != v8)
    {
      int v16 = *((_DWORD *)v6 - 1);
      v6 -= 4;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    v2[4] = v14;
    v2[5] = v7;
    v2[6] = v15;
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    *(_DWORD *)unsigned int v6 = v3;
    int8x16_t v7 = v6 + 4;
  }
  v2[5] = v7;
  IIONumber::~IIONumber((IIONumber *)v17);
}

void sub_1887E3FF0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void ___ZN13HEIFGroupItemC2EPK14__CFDictionaryS2_j_block_invoke_2()
{
}

void sub_1887E4108(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4038959712);
  _Unwind_Resume(a1);
}

void HEIFGroupItem::HEIFGroupItem(HEIFGroupItem *this, __CFReadStream *a2)
{
  *(void *)this = &unk_1ED4DFBF0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  int v2 = HEIFGroupItem::readFromStream(this, a2);
  if (v2)
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = v2;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
}

void sub_1887E41B4(_Unwind_Exception *exception_object)
{
  int v4 = (void *)v1[7];
  if (v4)
  {
    v1[8] = v4;
    operator delete(v4);
  }
  unint64_t v5 = *v2;
  if (*v2)
  {
    v1[5] = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HEIFGroupItem::readFromStream(HEIFGroupItem *this, CFReadStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) != 4) {
    return 4294967246;
  }
  if (*(_DWORD *)buffer == 542134855)
  {
    if (CFReadStreamRead(stream, (UInt8 *)this + 8, 20) == 20)
    {
      int v4 = (void **)((char *)this + 32);
      *((void *)this + 5) = *((void *)this + 4);
      *((void *)this + 8) = *((void *)this + 7);
      *(_DWORD *)uint64_t v19 = 0;
      if (CFReadStreamRead(stream, v19, 4) == 4)
      {
        if (*(_DWORD *)v19)
        {
          int v5 = 0;
          do
          {
            *(_DWORD *)float v18 = 0;
            if (CFReadStreamRead(stream, v18, 4) != 4) {
              return 4294967246;
            }
            int8x16_t v7 = (char *)*((void *)this + 5);
            unint64_t v6 = *((void *)this + 6);
            if ((unint64_t)v7 >= v6)
            {
              CFIndex v8 = (char *)*v4;
              uint64_t v9 = (v7 - (unsigned char *)*v4) >> 2;
              unint64_t v10 = v9 + 1;
              if ((unint64_t)(v9 + 1) >> 62) {
                std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v11 = v6 - (void)v8;
              if (v11 >> 1 > v10) {
                unint64_t v10 = v11 >> 1;
              }
              if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v12 = v10;
              }
              if (v12)
              {
                unsigned int v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<unsigned int>>((uint64_t)this + 48, v12);
                CFIndex v8 = (char *)*((void *)this + 4);
                int8x16_t v7 = (char *)*((void *)this + 5);
              }
              else
              {
                unsigned int v13 = 0;
              }
              uint64_t v14 = &v13[4 * v9];
              *(_DWORD *)uint64_t v14 = *(_DWORD *)v18;
              uint64_t v15 = v14 + 4;
              while (v7 != v8)
              {
                int v16 = *((_DWORD *)v7 - 1);
                v7 -= 4;
                *((_DWORD *)v14 - 1) = v16;
                v14 -= 4;
              }
              *((void *)this + 4) = v14;
              *((void *)this + 5) = v15;
              *((void *)this + 6) = &v13[4 * v12];
              if (v8) {
                operator delete(v8);
              }
              *((void *)this + 5) = v15;
            }
            else
            {
              *(_DWORD *)int8x16_t v7 = *(_DWORD *)v18;
              *((void *)this + 5) = v7 + 4;
            }
          }
          while (++v5 < *(_DWORD *)v19);
        }
        if (CFReadStreamRead(stream, v19, 4) == 4)
        {
          if (*(_DWORD *)v19) {
            operator new();
          }
          return 0;
        }
      }
    }
    return 4294967246;
  }
  return 0;
}

void sub_1887E44B0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4038959712);
  _Unwind_Resume(a1);
}

void HEIFGroupItem::~HEIFGroupItem(HEIFGroupItem *this)
{
  *(void *)this = &unk_1ED4DFBF0;
  *((void *)this + 5) = *((void *)this + 4);
  int v4 = (char *)this + 56;
  int v2 = (void *)*((void *)this + 7);
  int v3 = (void *)*((void *)v4 + 1);
  if (v3 == v2)
  {
    int v2 = v3;
  }
  else
  {
    unint64_t v5 = 0;
    unsigned int v6 = 1;
    do
    {
      uint64_t v7 = v2[v5];
      if (v7)
      {
        (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
        int v2 = (void *)*((void *)this + 7);
        int v3 = (void *)*((void *)this + 8);
      }
      unint64_t v5 = v6++;
    }
    while (v5 < v3 - v2);
  }
  *((void *)this + 8) = v2;
  if (v2) {
    operator delete(v2);
  }
  CFIndex v8 = (void *)*((void *)this + 4);
  if (v8)
  {
    *((void *)this + 5) = v8;
    operator delete(v8);
  }
}

{
  uint64_t vars8;

  HEIFGroupItem::~HEIFGroupItem(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t HEIFGroupItem::getGroupPictureIndexListCount(HEIFGroupItem *this)
{
  return (*((void *)this + 5) - *((void *)this + 4)) >> 2;
}

uint64_t HEIFGroupItem::getGroupType(HEIFGroupItem *this)
{
  return *((unsigned int *)this + 2);
}

uint64_t HEIFGroupItem::getDisparityAdjustment(HEIFGroupItem *this)
{
  return *((unsigned int *)this + 4);
}

uint64_t HEIFGroupItem::hasDisparityAdjustment(HEIFGroupItem *this)
{
  return *((unsigned __int8 *)this + 20);
}

__CFString *HEIFGroupItem::getMonoscopicImageLocationString(HEIFGroupItem *this)
{
  unsigned int v1 = *((_DWORD *)this + 6) - 1;
  if (v1 > 2) {
    int v2 = kIIOMonoscopicImageLocation_Unspecified;
  }
  else {
    int v2 = off_1E53CD0E8[v1];
  }
  return *v2;
}

uint64_t HEIFGroupItem::getGroupPictureIndexAtIndex(HEIFGroupItem *this, unsigned int a2)
{
  return *(unsigned int *)(*((void *)this + 4) + 4 * a2);
}

uint64_t HEIFGroupItem::getStereoAggressorAtIndex(HEIFGroupItem *this, unsigned int a2)
{
  return *(void *)(*((void *)this + 7) + 8 * a2);
}

uint64_t HEIFGroupItem::writeToStream(HEIFGroupItem *this, CFWriteStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 542134855;
  CFWriteStreamWrite(stream, buffer, 4);
  CFWriteStreamWrite(stream, (const UInt8 *)this + 8, 20);
  *(_DWORD *)CFIndex v8 = (*((void *)this + 5) - *((void *)this + 4)) >> 2;
  CFWriteStreamWrite(stream, v8, 4);
  CFWriteStreamWrite(stream, *((const UInt8 **)this + 4), 4 * *(unsigned int *)v8);
  *(_DWORD *)CFIndex v8 = (*((void *)this + 8) - *((void *)this + 7)) >> 3;
  CFWriteStreamWrite(stream, v8, 4);
  if (*(_DWORD *)v8)
  {
    unint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(*((void *)this + 7) + 8 * v4);
      *(_DWORD *)uint64_t v9 = 1195463763;
      CFWriteStreamWrite(stream, v9, 4);
      CFWriteStreamWrite(stream, (const UInt8 *)(v5 + 8), 24);
      ++v4;
    }
    while (v4 < *(unsigned int *)v8);
  }
  return 0;
}

void HEIFThumbnailImage::HEIFThumbnailImage(HEIFThumbnailImage *this, const __CFDictionary *a2)
{
  *(void *)this = &unk_1ED4E4538;
  memset(v5, 0, sizeof(v5));
  IIODictionary::IIODictionary((IIODictionary *)v5, a2);
  *((_DWORD *)this + 2) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v5, @"Width", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
  *((_DWORD *)this + 3) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v5, @"Height", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
  *((_DWORD *)this + 5) = IIODictionary::getUint32ForKey((IIODictionary *)v5, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DataLength);
  *((_DWORD *)this + 6) = IIODictionary::getUint32ForKey((IIODictionary *)v5, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DataOffset);
  *((_DWORD *)this + 4) = 8;
  if (IIODictionary::containsKey((IIODictionary *)v5, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_BitDepth))
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v5, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_BitDepth);
    memset(v4, 0, sizeof(v4));
    IIOArray::IIOArray((IIOArray *)v4, ObjectForKey);
    if (IIOArray::getCount((IIOArray *)v4)) {
      *((_DWORD *)this + 4) = IIOArray::getUint32AtIndex((IIOArray *)v4, 0);
    }
    IIOArray::~IIOArray((IIOArray *)v4);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v5);
}

void sub_1887E48A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void HEIFThumbnailImage::HEIFThumbnailImage(HEIFThumbnailImage *this, __CFReadStream *a2)
{
  *(void *)this = &unk_1ED4E4538;
  int v2 = HEIFThumbnailImage::readFromStream((UInt8 *)this, a2);
  if (v2)
  {
    int v3 = v2;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = v3;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
}

uint64_t HEIFThumbnailImage::readFromStream(UInt8 *this, CFReadStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) == 4
    && (*(_DWORD *)buffer != 1297434708 || CFReadStreamRead(stream, this + 8, 20) == 20))
  {
    return 0;
  }
  else
  {
    return 4294967246;
  }
}

void HEIFThumbnailImage::~HEIFThumbnailImage(HEIFThumbnailImage *this)
{
  *(void *)this = &unk_1ED4E4538;
}

{
  *(void *)this = &unk_1ED4E4538;
  JUMPOUT(0x18C11C0E0);
}

uint64_t HEIFThumbnailImage::dataLength(HEIFThumbnailImage *this)
{
  return *((unsigned int *)this + 5);
}

void HEIFAuxImage::HEIFAuxImage(HEIFAuxImage *this, const __CFDictionary *a2, const __CFDictionary *a3, int a4)
{
  *(void *)this = &unk_1ED4DF170;
  memset(v25, 0, sizeof(v25));
  IIODictionary::IIODictionary((IIODictionary *)v25, a2);
  *(_OWORD *)((char *)this + 8) = 0u;
  uint64_t v7 = (_DWORD *)((char *)this + 8);
  *((void *)this + 7) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_DWORD *)this + 8) = a4;
  if (!a3)
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v25, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN);
    *uint64_t v7 = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v25, @"Width", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
    *((_DWORD *)this + 3) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v25, @"Height", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
    *((_DWORD *)this + 4) = IIODictionary::getUint32ForKey((IIODictionary *)v25, @"Orientation");
    FloatForKeCGFloat y = IIODictionary::getFloatForKey((IIODictionary *)v25, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromMakerNote);
    *((_DWORD *)this + 11) = LODWORD(FloatForKey);
    double v16 = IIODictionary::getFloatForKey((IIODictionary *)v25, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_MeteorHeadroomFromProperties);
    *((_DWORD *)this + 12) = LODWORD(v16);
    *((_DWORD *)this + 10) = IIODictionary::getUint32ForKey((IIODictionary *)v25, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryNativePixelFormat);
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v25, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryType);
    *((_DWORD *)this + 7) = Uint32ForKey;
    if (Uint32ForKey == 3)
    {
      if (!ObjectForKey)
      {
        _cg_jpeg_mem_term("HEIFAuxImage", 1108, "*** ERROR: 'kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN' is NULL - for 'kCMPhotoAuxiliaryImageType_Alpha'\n");
        CFDictionaryRef ObjectForKey = *(const __CFDictionary **)gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Alpha;
      }
      unsigned int v18 = IIODictionary::getUint32ForKey((IIODictionary *)v25, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AlphaPremultiplication);
      if (v18) {
        int v19 = v18 == 1;
      }
      else {
        int v19 = 3;
      }
      *((_DWORD *)this + 9) = v19;
      float v20 = IIO_AlphaInfoString(v19);
      _cg_jpeg_mem_term("HEIFAuxImage", 1118, "    HEIFAuxImage: alpha: %s\n", v20);
    }
    if (!ObjectForKey)
    {
      CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v25, @"URI");
      if (!ObjectForKey) {
        goto LABEL_27;
      }
      *((_DWORD *)this + 7) = 99;
    }
    goto LABEL_25;
  }
  xpc_object_t value = 0;
  CFDictionaryGetValueIfPresent(a3, *(const void **)gIIO_kCMPhotoDecompressionContainerDescription_MainImages, (const void **)&value);
  if (value)
  {
    if (CFArrayGetCount((CFArrayRef)value))
    {
      ValueAtIndeCGFloat x = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)value, 0);
      theArraCGFloat y = 0;
      CFDictionaryGetValueIfPresent(ValueAtIndex, *(const void **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryImages, (const void **)&theArray);
      if (theArray)
      {
        if (CFArrayGetCount(theArray))
        {
          CFDictionaryRef v9 = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, 0);
          memset(v22, 0, sizeof(v22));
          IIODictionary::IIODictionary((IIODictionary *)v22, v9);
          CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v22, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN);
          unsigned int v11 = IIODictionary::getUint32ForKey((IIODictionary *)v22, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryType);
          *((_DWORD *)this + 7) = v11;
          if (v11 == 3)
          {
            if (!ObjectForKey)
            {
              _cg_jpeg_mem_term("HEIFAuxImage", 1070, "*** ERROR: 'kCMPhotoDecompressionContainerDescription_AuxiliaryTypeURN' is NULL - for 'kCMPhotoAuxiliaryImageType_Alpha'\n");
              CFDictionaryRef ObjectForKey = *(const __CFDictionary **)gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Alpha;
            }
            unsigned int v12 = IIODictionary::getUint32ForKey((IIODictionary *)v25, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AlphaPremultiplication);
            if (v12) {
              int v13 = v12 == 1;
            }
            else {
              int v13 = 3;
            }
            *((_DWORD *)this + 9) = v13;
            uint64_t v14 = IIO_AlphaInfoString(v13);
            _cg_jpeg_mem_term("HEIFAuxImage", 1080, "    HEIFAuxImage: alpha: %s\n", v14);
          }
          *uint64_t v7 = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v22, @"Width", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
          *((_DWORD *)this + 3) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v22, @"Height", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_Dimensions);
          *((_DWORD *)this + 4) = IIODictionary::getUint32ForKey((IIODictionary *)v22, @"Orientation");
          *((_DWORD *)this + 10) = IIODictionary::getUint32ForKey((IIODictionary *)v22, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryNativePixelFormat);
          IIODictionary::~IIODictionary((IIODictionary *)v22);
          if (ObjectForKey)
          {
LABEL_25:
            CFTypeID v21 = CFGetTypeID(ObjectForKey);
            if (v21 == CFStringGetTypeID()) {
              *((void *)this + 7) = CFRetain(ObjectForKey);
            }
          }
        }
      }
    }
  }
LABEL_27:
  *((_DWORD *)this + 5) = IIODictionary::getUint32ForKey((IIODictionary *)v25, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DataLength);
  *((_DWORD *)this + 6) = IIODictionary::getUint32ForKey((IIODictionary *)v25, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DataOffset);
  IIODictionary::~IIODictionary((IIODictionary *)v25);
}

void sub_1887E4E64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void HEIFAuxImage::HEIFAuxImage(HEIFAuxImage *this, __CFReadStream *a2)
{
  *(void *)this = &unk_1ED4DF170;
  int v2 = HEIFAuxImage::readFromStream((UInt8 *)this, a2);
  if (v2)
  {
    int v3 = v2;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = v3;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
}

uint64_t HEIFAuxImage::readFromStream(UInt8 *this, CFReadStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) != 4) {
    return 4294967246;
  }
  if (*(_DWORD *)buffer == 542659905)
  {
    if (CFReadStreamRead(stream, this + 8, 56) != 56) {
      return 4294967246;
    }
    *((void *)this + 7) = 0;
    *(_DWORD *)uint64_t v7 = 0;
    if (CFReadStreamRead(stream, v7, 4) != 4) {
      return 4294967246;
    }
    if (*(_DWORD *)v7)
    {
      unint64_t v4 = (UInt8 *)malloc_type_malloc(*(unsigned int *)v7, 0xB2723850uLL);
      CFIndex v5 = CFReadStreamRead(stream, v4, *(unsigned int *)v7);
      if (v5 == *(unsigned int *)v7)
      {
        *((void *)this + 7) = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v4, v5, 0x8000100u, 1u);
        free(v4);
        return 0;
      }
      free(v4);
      return 4294967246;
    }
  }
  return 0;
}

void HEIFAuxImage::~HEIFAuxImage(HEIFAuxImage *this)
{
  *(void *)this = &unk_1ED4DF170;
  int v2 = (const void *)*((void *)this + 7);
  if (v2) {
    CFRelease(v2);
  }
  *((void *)this + 7) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
}

{
  uint64_t vars8;

  HEIFAuxImage::~HEIFAuxImage(this);

  JUMPOUT(0x18C11C0E0);
}

float HEIFAuxImage::meteorHeadroomFromMakerNote(HEIFAuxImage *this)
{
  return *((float *)this + 11);
}

float HEIFAuxImage::meteorHeadroomFromProperties(HEIFAuxImage *this)
{
  return *((float *)this + 12);
}

uint64_t HEIFAuxImage::auxiliaryType(HEIFAuxImage *this)
{
  return *((unsigned int *)this + 7);
}

uint64_t HEIFAuxImage::auxiliaryAlpha(HEIFAuxImage *this)
{
  return *((unsigned int *)this + 9);
}

uint64_t HEIFAuxImage::payloadIndex(HEIFAuxImage *this)
{
  return *((unsigned int *)this + 8);
}

uint64_t HEIFAuxImage::writeToStream(const UInt8 *this, CFWriteStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 542659905;
  CFWriteStreamWrite(stream, buffer, 4);
  CFWriteStreamWrite(stream, this + 8, 56);
  *(_DWORD *)CFIndex v8 = 0;
  unint64_t v4 = (const void *)*((void *)this + 7);
  if (v4)
  {
    memset(v7, 0, sizeof(v7));
    IIOString::IIOString((IIOString *)v7, v4);
    *(_DWORD *)CFIndex v8 = IIOString::length((IIOString *)v7);
    CFStringRef v5 = IIOString::utf8String((IIOString *)v7);
    if (v5 && *(_DWORD *)v8)
    {
      CFWriteStreamWrite(stream, v8, 4);
      CFWriteStreamWrite(stream, (const UInt8 *)v5, *(unsigned int *)v8);
    }
    IIOString::~IIOString((IIOString *)v7);
  }
  else
  {
    CFWriteStreamWrite(stream, v8, 4);
  }
  return 0;
}

void sub_1887E51B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void HEIFAlternateImage::HEIFAlternateImage(HEIFAlternateImage *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  *(void *)this = &unk_1ED4B4450;
  *(_OWORD *)((char *)this + 8) = 0u;
  unint64_t v4 = (_DWORD *)((char *)this + 8);
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  memset(v28, 0, sizeof(v28));
  IIODictionary::IIODictionary((IIODictionary *)v28, a2);
  *unint64_t v4 = IIODictionary::getUint32ForKey((IIODictionary *)v28, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_CodecType);
  *((_DWORD *)this + 11) = IIODictionary::getUint32ForKey((IIODictionary *)v28, *(const __CFString **)gIIO_kCMPhotoDecompressionOption_AlternateIndex);
  *((_DWORD *)this + 12) = IIODictionary::getUint32ForKey((IIODictionary *)v28, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_AuxiliaryImageCount);
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v28, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_ItemType);
  *((_DWORD *)this + 3) = Uint32ForKey;
  if (!Uint32ForKey)
  {
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v28, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_CodecType);
    *((_DWORD *)this + 3) = Uint32ForKey;
  }
  if (Uint32ForKey == 1953325424)
  {
    if (gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapPixelFormat) {
      *((_DWORD *)this + 4) = IIODictionary::getUint32ForKey((IIODictionary *)v28, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapPixelFormat);
    }
    if (gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapDimension)
    {
      *((_DWORD *)this + 5) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v28, @"Width", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapDimension);
      *((_DWORD *)this + 6) = IIODictionary::getUint32ForKeyGroup((IIODictionary *)v28, @"Height", *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapDimension);
    }
    if (gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapOrientation)
    {
      unsigned int v6 = IIODictionary::getUint32ForKey((IIODictionary *)v28, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DerivationGainMapOrientation);
      *((_DWORD *)this + 7) = v6;
      if (v6) {
        goto LABEL_13;
      }
    }
    else if (*((_DWORD *)this + 7))
    {
      goto LABEL_13;
    }
    *((_DWORD *)this + 7) = IIODictionary::getUint32ForKey((IIODictionary *)v28, @"Orientation");
LABEL_13:
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v28, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerConstituent_FlexRangeColorSpace);
    *((void *)this + 16) = CGColorSpaceRetain(ObjectForKey);
    *((_DWORD *)this + 9) = IIODictionary::getUint32ForKey((IIODictionary *)v28, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DataLength);
    *((_DWORD *)this + 10) = IIODictionary::getUint32ForKey((IIODictionary *)v28, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DataOffset);
    *((_DWORD *)this + 13) = IIODictionary::getUint32ForKey((IIODictionary *)v28, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_ThumbnailImageCount);
    if (IIODictionary::containsKey((IIODictionary *)v28, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DerivationDetails))
    {
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      uint64_t v27 = 0;
      CFDictionaryRef v8 = IIODictionary::getObjectForKey((IIODictionary *)v28, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_DerivationDetails);
      IIODictionary::IIODictionary((IIODictionary *)&v25, v8);
      DoubleFromRationalForKeCGFloat y = IIODictionary::getDoubleFromRationalForKey((IIODictionary *)&v25, *(const __CFString **)gIIO_kCMPhotoMetadata_TonemapAlternateHDRHeadroom);
      *((float *)this + 14) = exp2f(DoubleFromRationalForKey);
      float v10 = IIODictionary::getDoubleFromRationalForKey((IIODictionary *)&v25, *(const __CFString **)gIIO_kCMPhotoMetadata_TonemapBaseHDRHeadroom);
      *((float *)this + 15) = exp2f(v10);
      *((unsigned char *)this + 64) = IIODictionary::getBoolForKey((IIODictionary *)&v25, *(const __CFString **)gIIO_kCMPhotoMetadata_TonemapBaseColorIsWorkingColor);
      CFDictionaryRef v11 = IIODictionary::getObjectForKey((IIODictionary *)&v25, @"TonemapChannelMetadata");
      memset(v24, 0, sizeof(v24));
      IIOArray::IIOArray((IIOArray *)v24, v11);
      unsigned int Count = IIOArray::getCount((IIOArray *)v24);
      unint64_t v13 = 0;
      *((unsigned char *)this + 65) = Count == 3;
      uint64_t v14 = (float *)((char *)this + 84);
      do
      {
        ObjectAtIndeCGFloat x = IIOArray::getObjectAtIndex((IIOArray *)v24, v13);
        memset(v23, 0, sizeof(v23));
        IIODictionary::IIODictionary((IIODictionary *)v23, ObjectAtIndex);
        if (gIIO_kCMPhotoMetadataTonemapChannel_AlternateOffset)
        {
          float v16 = IIODictionary::getDoubleFromRationalForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCMPhotoMetadataTonemapChannel_AlternateOffset);
          *uint64_t v14 = v16;
        }
        if (gIIO_kCMPhotoMetadataTonemapChannel_BaseOffset)
        {
          float v17 = IIODictionary::getDoubleFromRationalForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCMPhotoMetadataTonemapChannel_BaseOffset);
          *(v14 - 1) = v17;
        }
        if (gIIO_kCMPhotoMetadataTonemapChannel_GainMapMin)
        {
          float v18 = IIODictionary::getDoubleFromRationalForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCMPhotoMetadataTonemapChannel_GainMapMin);
          *(v14 - 4) = v18;
        }
        if (gIIO_kCMPhotoMetadataTonemapChannel_GainMapMax)
        {
          float v19 = IIODictionary::getDoubleFromRationalForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCMPhotoMetadataTonemapChannel_GainMapMax);
          *(v14 - 3) = v19;
        }
        if (gIIO_kCMPhotoMetadataTonemapChannel_Gamma)
        {
          float v20 = IIODictionary::getDoubleFromRationalForKey((IIODictionary *)v23, *(const __CFString **)gIIO_kCMPhotoMetadataTonemapChannel_Gamma);
          *(v14 - 2) = v20;
        }
        IIODictionary::~IIODictionary((IIODictionary *)v23);
        if (Count != 3) {
          break;
        }
        v14 += 5;
      }
      while (v13++ < 2);
      IIOArray::~IIOArray((IIOArray *)v24);
      IIODictionary::~IIODictionary((IIODictionary *)&v25);
    }
  }
  *((_DWORD *)this + 8) = 8;
  if (IIODictionary::containsKey((IIODictionary *)v28, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_BitDepth))
  {
    CFDictionaryRef v22 = IIODictionary::getObjectForKey((IIODictionary *)v28, *(const __CFString **)gIIO_kCMPhotoDecompressionContainerDescription_BitDepth);
    uint64_t v25 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    IIOArray::IIOArray((IIOArray *)&v25, v22);
    if (IIOArray::getCount((IIOArray *)&v25)) {
      *((_DWORD *)this + 8) = IIOArray::getUint32AtIndex((IIOArray *)&v25, 0);
    }
    IIOArray::~IIOArray((IIOArray *)&v25);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v28);
}

void sub_1887E5694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  IIOArray::~IIOArray((IIOArray *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  IIODictionary::~IIODictionary((IIODictionary *)va2);
  _Unwind_Resume(a1);
}

void HEIFAlternateImage::HEIFAlternateImage(HEIFAlternateImage *this, __CFReadStream *a2)
{
  *(void *)this = &unk_1ED4B4450;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  int v2 = HEIFAlternateImage::readFromStream(this, a2);
  if (v2)
  {
    int v3 = v2;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = v3;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
}

uint64_t HEIFAlternateImage::readFromStream(HEIFAlternateImage *this, CFReadStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) != 4) {
    return 4294967246;
  }
  if (*(_DWORD *)buffer == 1480936518)
  {
    if (CFReadStreamRead(stream, (UInt8 *)this + 8, 128) == 128)
    {
      CGColorSpaceRef v4 = IIO_ColorSpaceCreateFromStream(stream);
      uint64_t result = 0;
      *((void *)this + 16) = v4;
      return result;
    }
    return 4294967246;
  }
  return 0;
}

void HEIFAlternateImage::~HEIFAlternateImage(HEIFAlternateImage *this)
{
  *(void *)this = &unk_1ED4B4450;
  int v2 = (CGColorSpace *)*((void *)this + 16);
  if (v2) {
    CGColorSpaceRelease(v2);
  }
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 8) = 0u;
}

{
  uint64_t vars8;

  HEIFAlternateImage::~HEIFAlternateImage(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t HEIFAlternateImage::writeToStream(HEIFAlternateImage *this, CFWriteStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 1480936518;
  CFWriteStreamWrite(stream, buffer, 4);
  CFWriteStreamWrite(stream, (const UInt8 *)this + 8, 128);
  return IIO_ColorSpaceAddToStream(*((CGColorSpace **)this + 16), stream);
}

void HEIFAlternateImage::addInfoToProperties(HEIFAlternateImage *this, IIODictionary *a2)
{
  IIONumber::IIONumber((IIONumber *)&v14, *((float *)this + 14));
  IIODictionary::setObjectForKey(a2, value, @"TonemapAlternateHDRHeadroom");
  IIONumber::~IIONumber((IIONumber *)&v14);
  IIONumber::IIONumber((IIONumber *)&v14, *((float *)this + 15));
  IIODictionary::setObjectForKey(a2, value, @"TonemapBaseHDRHeadroom");
  IIONumber::~IIONumber((IIONumber *)&v14);
  CGColorSpaceRef v4 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!*((unsigned char *)this + 64)) {
    CGColorSpaceRef v4 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  IIODictionary::setObjectForKey(a2, *v4, @"TonemapBaseColorIsWorkingColor");
  CFMutableArrayRef v14 = 0;
  uint64_t v15 = 0;
  xpc_object_t value = 0;
  IIOArray::IIOArray((IIOArray *)&v14);
  IIODictionary::setObjectForKey(a2, v15, @"TonemapChannelMetadata");
  unint64_t v5 = 0;
  unsigned int v6 = (float *)((char *)this + 84);
  int v7 = *((unsigned __int8 *)this + 65);
  do
  {
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v11);
    IIONumber::IIONumber((IIONumber *)v9, *(v6 - 4));
    IIODictionary::setObjectForKey((IIODictionary *)&v11, v10, @"GainMapMin");
    IIONumber::~IIONumber((IIONumber *)v9);
    IIONumber::IIONumber((IIONumber *)v9, *(v6 - 3));
    IIODictionary::setObjectForKey((IIODictionary *)&v11, v10, @"GainMapMax");
    IIONumber::~IIONumber((IIONumber *)v9);
    IIONumber::IIONumber((IIONumber *)v9, *(v6 - 2));
    IIODictionary::setObjectForKey((IIODictionary *)&v11, v10, @"Gamma");
    IIONumber::~IIONumber((IIONumber *)v9);
    IIONumber::IIONumber((IIONumber *)v9, *(v6 - 1));
    IIODictionary::setObjectForKey((IIODictionary *)&v11, v10, @"BaseOffset");
    IIONumber::~IIONumber((IIONumber *)v9);
    IIONumber::IIONumber((IIONumber *)v9, *v6);
    IIODictionary::setObjectForKey((IIODictionary *)&v11, v10, @"AlternateOffset");
    IIONumber::~IIONumber((IIONumber *)v9);
    IIOArray::addObject(&v14, v12);
    IIODictionary::~IIODictionary((IIODictionary *)&v11);
    if (!v7) {
      break;
    }
    v6 += 5;
  }
  while (v5++ < 2);
  IIOArray::~IIOArray((IIOArray *)&v14);
}

void sub_1887E5B54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

void HEIFAlternateImage::addAsAuxImageToProperties(HEIFAlternateImage *this, IIODictionary *a2)
{
  IIODictionary::setObjectForKey(a2, @"kCGImageAuxiliaryDataTypeISOGainMap", @"AuxiliaryDataType");
  IIONumber::IIONumber((IIONumber *)v4, 1953325424);
  IIODictionary::setObjectForKey(a2, value, @"PixelFormat");
  IIONumber::~IIONumber((IIONumber *)v4);
  IIONumber::IIONumber((IIONumber *)v4, *((_DWORD *)this + 5));
  IIODictionary::setObjectForKey(a2, value, @"Width");
  IIONumber::~IIONumber((IIONumber *)v4);
  IIONumber::IIONumber((IIONumber *)v4, *((_DWORD *)this + 6));
  IIODictionary::setObjectForKey(a2, value, @"Height");
  IIONumber::~IIONumber((IIONumber *)v4);
  IIONumber::IIONumber((IIONumber *)v4, *((_DWORD *)this + 7));
  IIODictionary::setObjectForKey(a2, value, @"Orientation");
  IIONumber::~IIONumber((IIONumber *)v4);
  IIONumber::IIONumber((IIONumber *)v4, *((_DWORD *)this + 4));
  IIODictionary::setObjectForKey(a2, value, @"PixelFormat");
  IIONumber::~IIONumber((IIONumber *)v4);
}

void sub_1887E5CF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void HEIFMainImage::HEIFMainImage(HEIFMainImage *this, __CFReadStream *a2)
{
  *(_OWORD *)((char *)this + 8) = 0u;
  *(void *)this = &unk_1ED4DFC10;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  int v2 = HEIFMainImage::readFromStream(this, a2);
  if (v2)
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = v2;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
}

void sub_1887E5DCC(_Unwind_Exception *exception_object)
{
  CGColorSpaceRef v4 = (void *)v1[16];
  if (v4)
  {
    v1[17] = v4;
    operator delete(v4);
  }
  unint64_t v5 = (void *)v1[13];
  if (v5)
  {
    v1[14] = v5;
    operator delete(v5);
  }
  unsigned int v6 = (void *)v1[10];
  if (v6)
  {
    v1[11] = v6;
    operator delete(v6);
  }
  int v7 = (void *)v1[7];
  if (v7)
  {
    v1[8] = v7;
    operator delete(v7);
  }
  uint64_t v8 = (void *)v1[4];
  if (v8)
  {
    v1[5] = v8;
    operator delete(v8);
  }
  uint64_t v9 = *v2;
  if (*v2)
  {
    v1[2] = v9;
    operator delete(v9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HEIFMainImage::readFromStream(HEIFMainImage *this, CFReadStreamRef stream)
{
  *(void *)int v7 = 0;
  *(_DWORD *)UInt8 buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) != 4 || *(_DWORD *)buffer != 1313423693)
  {
    _cg_jpeg_mem_term("readFromStream", 2419, "*** ERROR: missing 'MAIN' marker\n");
    return 4294967246;
  }
  if (CFReadStreamRead(stream, buffer, 4) != 4 || *(_DWORD *)buffer != 1297434708)
  {
    _cg_jpeg_mem_term("readFromStream", 2423, "*** ERROR: missing 'THUM' marker\n");
    return 4294967246;
  }
  if (CFReadStreamRead(stream, v7, 8) != 8) {
    return 4294967246;
  }
  std::vector<_MPEntry *>::reserve((void **)this + 1, *(unint64_t *)v7);
  if (*(uint64_t *)v7 >= 1) {
    operator new();
  }
  if (CFReadStreamRead(stream, buffer, 4) != 4 || *(_DWORD *)buffer != 1230525761)
  {
    _cg_jpeg_mem_term("readFromStream", 2441, "*** ERROR: missing 'AUXI' marker\n");
    return 4294967246;
  }
  if (CFReadStreamRead(stream, v7, 8) != 8) {
    return 4294967246;
  }
  std::vector<_MPEntry *>::reserve((void **)this + 4, *(unint64_t *)v7);
  if (*(uint64_t *)v7 >= 1) {
    operator new();
  }
  if (CFReadStreamRead(stream, buffer, 4) != 4 || *(_DWORD *)buffer != 1230261313)
  {
    _cg_jpeg_mem_term("readFromStream", 2459, "*** ERROR: missing 'ALTI' marker\n");
    return 4294967246;
  }
  if (CFReadStreamRead(stream, v7, 8) != 8) {
    return 4294967246;
  }
  std::vector<_MPEntry *>::reserve((void **)this + 7, *(unint64_t *)v7);
  if (*(uint64_t *)v7 >= 1) {
    operator new();
  }
  if (CFReadStreamRead(stream, buffer, 4) != 4 || *(_DWORD *)buffer != 1179211845)
  {
    _cg_jpeg_mem_term("readFromStream", 2478, "*** ERROR: missing 'EXIF' marker\n");
    return 4294967246;
  }
  if (CFReadStreamRead(stream, v7, 8) != 8) {
    return 4294967246;
  }
  std::vector<_MPEntry *>::reserve((void **)this + 10, *(unint64_t *)v7);
  if (*(uint64_t *)v7 >= 1) {
    operator new();
  }
  if (CFReadStreamRead(stream, buffer, 4) != 4 || *(_DWORD *)buffer != 1296389193)
  {
    _cg_jpeg_mem_term("readFromStream", 2496, "*** ERROR: missing 'ITEM' marker\n");
    return 4294967246;
  }
  if (CFReadStreamRead(stream, v7, 8) != 8) {
    return 4294967246;
  }
  std::vector<_MPEntry *>::reserve((void **)this + 16, *(unint64_t *)v7);
  if (*(uint64_t *)v7 >= 1) {
    operator new();
  }
  if (CFReadStreamRead(stream, buffer, 4) != 4 || *(_DWORD *)buffer != 542133592)
  {
    _cg_jpeg_mem_term("readFromStream", 2514, "*** ERROR: missing 'XMP ' marker\n");
    return 4294967246;
  }
  if (CFReadStreamRead(stream, v7, 8) != 8) {
    return 4294967246;
  }
  std::vector<_MPEntry *>::reserve((void **)this + 13, *(unint64_t *)v7);
  if (*(uint64_t *)v7 >= 1) {
    operator new();
  }
  if (CFReadStreamRead(stream, buffer, 4) != 4 || *(_DWORD *)buffer != 1096040772)
  {
    _cg_jpeg_mem_term("readFromStream", 2532, "*** ERROR: missing 'DATA' marker\n");
    return 4294967246;
  }
  if (CFReadStreamRead(stream, (UInt8 *)this + 160, 144) != 144) {
    return 4294967246;
  }
  *((void *)this + 36) = 0;
  *((void *)this + 37) = 0;
  if (CFReadStreamRead(stream, buffer, 4) != 4 || *(_DWORD *)buffer != 1313623875)
  {
    _cg_jpeg_mem_term("readFromStream", 2540, "*** ERROR: missing 'COLN' marker\n");
    return 4294967246;
  }
  *((void *)this + 36) = IIO_ColorSpaceNameCreateFromStream(stream);
  if (CFReadStreamRead(stream, buffer, 4) != 4 || *(_DWORD *)buffer != 1397509955)
  {
    _cg_jpeg_mem_term("readFromStream", 2545, "*** ERROR: missing 'COLS' marker\n");
    return 4294967246;
  }
  *((void *)this + 37) = IIO_ColorSpaceCreateFromStream(stream);
  if (!*((_DWORD *)this + 41))
  {
    _cg_jpeg_mem_term("readFromStream", 2548, "*** ERROR: mainImage - bad dimension: %d x %d\n");
    return 4294967246;
  }
  if (!*((_DWORD *)this + 42))
  {
    _cg_jpeg_mem_term("readFromStream", 2549, "*** ERROR: mainImage - bad dimension: %d x %d\n");
    return 4294967246;
  }
  return 0;
}

void sub_1887E6890(void *a1)
{
}

uint64_t HEIFMainImage::getTileWidth(HEIFMainImage *this)
{
  return *((unsigned int *)this + 47);
}

uint64_t HEIFMainImage::getTileLength(HEIFMainImage *this)
{
  return *((unsigned int *)this + 48);
}

BOOL HEIFMainImage::isTiled(HEIFMainImage *this)
{
  return *((_DWORD *)this + 47) && *((_DWORD *)this + 48) != 0;
}

uint64_t HEIFMainImage::getHEIFAuxImageAtIndex(HEIFMainImage *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 4);
  if (a2 >= (unint64_t)((*((void *)this + 5) - v2) >> 3)) {
    return 0;
  }
  else {
    return *(void *)(v2 + 8 * a2);
  }
}

uint64_t HEIFMainImage::getHEIFAlternateImageAtIndex(HEIFMainImage *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 7);
  if (a2 >= (unint64_t)((*((void *)this + 8) - v2) >> 3)) {
    return 0;
  }
  else {
    return *(void *)(v2 + 8 * a2);
  }
}

uint64_t HEIFMainImage::getColorSpace(HEIFMainImage *this)
{
  return *((void *)this + 37);
}

double HEIFMainImage::getFrameDuration(HEIFMainImage *this)
{
  return *((double *)this + 34);
}

uint64_t HEIFMainImage::getNumberOfThumbnailImages(HEIFMainImage *this)
{
  return (*((void *)this + 2) - *((void *)this + 1)) >> 3;
}

uint64_t HEIFMainImage::getHEIFThumbnailImageAtIndex(HEIFMainImage *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (a2 >= (unint64_t)((*((void *)this + 2) - v2) >> 3)) {
    return 0;
  }
  else {
    return *(void *)(v2 + 8 * a2);
  }
}

uint64_t HEIFMainImage::getHEIFExifPayloadAtIndex(HEIFMainImage *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 10);
  if (a2 >= (unint64_t)((*((void *)this + 11) - v2) >> 3)) {
    return 0;
  }
  else {
    return *(void *)(v2 + 8 * a2);
  }
}

uint64_t HEIFMainImage::getHEIFItemPayloadAtIndex(HEIFMainImage *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 16);
  if (a2 >= (unint64_t)((*((void *)this + 17) - v2) >> 3)) {
    return 0;
  }
  else {
    return *(void *)(v2 + 8 * a2);
  }
}

uint64_t HEIFMainImage::getHEIFXMPPayloadAtIndex(HEIFMainImage *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 13);
  if (a2 >= (unint64_t)((*((void *)this + 14) - v2) >> 3)) {
    return 0;
  }
  else {
    return *(void *)(v2 + 8 * a2);
  }
}

uint64_t HEIFMainImage::writeToStream(HEIFMainImage *this, CFWriteStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 1313423693;
  CFWriteStreamWrite(stream, buffer, 4);
  *(_DWORD *)UInt8 buffer = 1297434708;
  CFWriteStreamWrite(stream, buffer, 4);
  *(void *)unsigned int v24 = (uint64_t)(*((void *)this + 2) - *((void *)this + 1)) >> 3;
  CFWriteStreamWrite(stream, v24, 8);
  if (*(uint64_t *)v24 >= 1)
  {
    uint64_t v4 = 0;
    unsigned int v5 = 1;
    do
    {
      uint64_t v6 = *(void *)(*((void *)this + 1) + 8 * v4);
      *(_DWORD *)uint64_t v25 = 1297434708;
      CFWriteStreamWrite(stream, v25, 4);
      CFWriteStreamWrite(stream, (const UInt8 *)(v6 + 8), 20);
      uint64_t v4 = v5;
      BOOL v7 = *(void *)v24 <= (uint64_t)v5++;
    }
    while (!v7);
  }
  *(_DWORD *)UInt8 buffer = 1230525761;
  CFWriteStreamWrite(stream, buffer, 4);
  *(void *)unsigned int v24 = (uint64_t)(*((void *)this + 5) - *((void *)this + 4)) >> 3;
  CFWriteStreamWrite(stream, v24, 8);
  if (*(uint64_t *)v24 >= 1)
  {
    uint64_t v8 = 0;
    unsigned int v9 = 1;
    do
    {
      HEIFAuxImage::writeToStream(*(const UInt8 **)(*((void *)this + 4) + 8 * v8), stream);
      uint64_t v8 = v9;
      BOOL v7 = *(void *)v24 <= (uint64_t)v9++;
    }
    while (!v7);
  }
  *(_DWORD *)UInt8 buffer = 1230261313;
  CFWriteStreamWrite(stream, buffer, 4);
  *(void *)unsigned int v24 = (uint64_t)(*((void *)this + 8) - *((void *)this + 7)) >> 3;
  CFWriteStreamWrite(stream, v24, 8);
  if (*(uint64_t *)v24 < 1)
  {
    uint64_t v13 = 0;
  }
  else
  {
    uint64_t v10 = 0;
    unsigned int v11 = 1;
    do
    {
      uint64_t v12 = HEIFAlternateImage::writeToStream(*(HEIFAlternateImage **)(*((void *)this + 7) + 8 * v10), stream);
      uint64_t v10 = v11;
      BOOL v7 = *(void *)v24 <= (uint64_t)v11++;
    }
    while (!v7);
    uint64_t v13 = v12;
  }
  *(_DWORD *)UInt8 buffer = 1179211845;
  CFWriteStreamWrite(stream, buffer, 4);
  *(void *)unsigned int v24 = (uint64_t)(*((void *)this + 11) - *((void *)this + 10)) >> 3;
  CFWriteStreamWrite(stream, v24, 8);
  if (*(uint64_t *)v24 >= 1)
  {
    uint64_t v14 = 0;
    unsigned int v15 = 1;
    do
    {
      uint64_t v16 = *(void *)(*((void *)this + 10) + 8 * v14);
      *(_DWORD *)uint64_t v25 = 1179211845;
      CFWriteStreamWrite(stream, v25, 4);
      CFWriteStreamWrite(stream, (const UInt8 *)(v16 + 8), 16);
      uint64_t v14 = v15;
      BOOL v7 = *(void *)v24 <= (uint64_t)v15++;
    }
    while (!v7);
    uint64_t v13 = 0;
  }
  *(_DWORD *)UInt8 buffer = 1296389193;
  CFWriteStreamWrite(stream, buffer, 4);
  *(void *)unsigned int v24 = (uint64_t)(*((void *)this + 17) - *((void *)this + 16)) >> 3;
  CFWriteStreamWrite(stream, v24, 8);
  if (*(uint64_t *)v24 >= 1)
  {
    uint64_t v17 = 0;
    unsigned int v18 = 1;
    do
    {
      HEIFItem::writeToStream(*(HEIFItem **)(*((void *)this + 16) + 8 * v17), stream);
      uint64_t v17 = v18;
      BOOL v7 = *(void *)v24 <= (uint64_t)v18++;
    }
    while (!v7);
    uint64_t v13 = 0;
  }
  *(_DWORD *)UInt8 buffer = 542133592;
  CFWriteStreamWrite(stream, buffer, 4);
  *(void *)unsigned int v24 = (uint64_t)(*((void *)this + 14) - *((void *)this + 13)) >> 3;
  CFWriteStreamWrite(stream, v24, 8);
  if (*(uint64_t *)v24 >= 1)
  {
    uint64_t v19 = 0;
    unsigned int v20 = 1;
    do
    {
      uint64_t v21 = *(void *)(*((void *)this + 13) + 8 * v19);
      *(_DWORD *)uint64_t v25 = 542133592;
      CFWriteStreamWrite(stream, v25, 4);
      CFWriteStreamWrite(stream, (const UInt8 *)(v21 + 8), 16);
      uint64_t v19 = v20;
      BOOL v7 = *(void *)v24 <= (uint64_t)v20++;
    }
    while (!v7);
    uint64_t v13 = 0;
  }
  *(_DWORD *)UInt8 buffer = 1096040772;
  CFWriteStreamWrite(stream, buffer, 4);
  CFWriteStreamWrite(stream, (const UInt8 *)this + 160, 144);
  *(_DWORD *)UInt8 buffer = 1313623875;
  CFWriteStreamWrite(stream, buffer, 4);
  IIO_ColorSpaceNameAddToStream(*((const __CFString **)this + 36), stream);
  *(_DWORD *)UInt8 buffer = 1397509955;
  CFWriteStreamWrite(stream, buffer, 4);
  IIO_ColorSpaceAddToStream(*((CGColorSpace **)this + 37), stream);
  if (*((_DWORD *)this + 41))
  {
    if (!*((_DWORD *)this + 42)) {
      _cg_jpeg_mem_term("writeToStream", 2404, "*** ERROR: mainImage - bad dimension: %d x %d\n");
    }
  }
  else
  {
    _cg_jpeg_mem_term("writeToStream", 2403, "*** ERROR: mainImage - bad dimension: %d x %d\n");
  }
  return v13;
}

void GlobalHEIFInfo::GlobalHEIFInfo(GlobalHEIFInfo *this, unsigned __int8 *a2, CFIndex a3)
{
  *(void *)this = &unk_1ED4E1148;
  *(_OWORD *)((char *)this + 8) = 0u;
  uint64_t v6 = (char *)this + 32;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  std::vector<_APPx *>::resize((uint64_t)this + 8, 0);
  std::vector<_APPx *>::resize((uint64_t)v6, 0);
  *((void *)this + 7) = 0;
  BOOL v7 = CFReadStreamCreateWithBytesNoCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3, (CFAllocatorRef)*MEMORY[0x1E4F1CFA0]);
  uint64_t v8 = v7;
  if (v7)
  {
    if (CFReadStreamOpen(v7))
    {
      if (GlobalHEIFInfo::readFromStream(this, v8))
      {
        *((void *)this + 2) = *((void *)this + 1);
        *((void *)this + 5) = *((void *)this + 4);
        *((void *)this + 8) = 0;
        unsigned int v9 = (const void *)*((void *)this + 7);
        if (v9)
        {
          CFRelease(v9);
          *((void *)this + 7) = 0;
        }
      }
      CFReadStreamClose(v8);
    }
    CFRelease(v8);
  }
}

void sub_1887E6FCC(_Unwind_Exception *exception_object)
{
  unsigned int v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 40) = v5;
    operator delete(v5);
  }
  uint64_t v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 16) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

uint64_t GlobalHEIFInfo::readFromStream(GlobalHEIFInfo *this, CFReadStreamRef stream)
{
  *(void *)BOOL v7 = 0;
  *(_DWORD *)UInt8 buffer = 0;
  if (CFReadStreamRead(stream, buffer, 4) != 4) {
    return 4294967246;
  }
  if (*(_DWORD *)buffer != 1112493127) {
    return 0;
  }
  if (CFReadStreamRead(stream, v7, 8) != 8) {
    return 4294967246;
  }
  std::vector<_MPEntry *>::reserve((void **)this + 1, *(unint64_t *)v7);
  if (*(uint64_t *)v7 >= 1) {
    operator new();
  }
  if (CFReadStreamRead(stream, v7, 8) != 8) {
    return 4294967246;
  }
  std::vector<_MPEntry *>::reserve((void **)this + 4, *(unint64_t *)v7);
  if (*(uint64_t *)v7 >= 1) {
    operator new();
  }
  if (CFReadStreamRead(stream, (UInt8 *)this + 64, 8) != 8 || CFReadStreamRead(stream, v7, 8) != 8) {
    return 4294967246;
  }
  uint64_t result = *(void *)v7;
  if (!*(void *)v7) {
    return result;
  }
  unsigned int v5 = (UInt8 *)malloc_type_malloc(*(size_t *)v7, 0x2F12BA05uLL);
  if (CFReadStreamRead(stream, v5, 8) == 8) {
    *((void *)this + 7) = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5, *(CFIndex *)v7);
  }
  free(v5);
  return 0;
}

void sub_1887E740C()
{
}

uint64_t GlobalHEIFInfo::setHasHEIFSequence(uint64_t this, char a2)
{
  *(unsigned char *)(this + 69) = a2;
  return this;
}

void GlobalHEIFInfo::addHEIFGroupItem(GlobalHEIFInfo *this, HEIFGroupItem *a2)
{
  unint64_t v6 = *((void *)this + 6);
  uint64_t v4 = (char *)this + 48;
  unint64_t v5 = v6;
  BOOL v7 = (void *)*((void *)v4 - 1);
  if ((unint64_t)v7 >= v6)
  {
    unsigned int v9 = (void **)(v4 - 16);
    uint64_t v10 = *((void *)v4 - 2);
    uint64_t v11 = ((uint64_t)v7 - v10) >> 3;
    if ((unint64_t)(v11 + 1) >> 61) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v5 - v10;
    uint64_t v13 = v12 >> 2;
    if (v12 >> 2 <= (unint64_t)(v11 + 1)) {
      uint64_t v13 = v11 + 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v13;
    }
    if (v14) {
      unsigned int v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>((uint64_t)v4, v14);
    }
    else {
      unsigned int v15 = 0;
    }
    uint64_t v16 = &v15[8 * v11];
    uint64_t v17 = &v15[8 * v14];
    *(void *)uint64_t v16 = a2;
    uint64_t v8 = v16 + 8;
    uint64_t v19 = (char *)*((void *)this + 4);
    unsigned int v18 = (char *)*((void *)this + 5);
    if (v18 != v19)
    {
      do
      {
        uint64_t v20 = *((void *)v18 - 1);
        v18 -= 8;
        *((void *)v16 - 1) = v20;
        v16 -= 8;
      }
      while (v18 != v19);
      unsigned int v18 = (char *)*v9;
    }
    *((void *)this + 4) = v16;
    *((void *)this + 5) = v8;
    *((void *)this + 6) = v17;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *BOOL v7 = a2;
    uint64_t v8 = v7 + 1;
  }
  *((void *)this + 5) = v8;
}

uint64_t GlobalHEIFInfo::writeToStream(GlobalHEIFInfo *this, CFWriteStreamRef stream)
{
  *(_DWORD *)UInt8 buffer = 1112493127;
  CFWriteStreamWrite(stream, buffer, 4);
  *(void *)uint64_t v16 = (uint64_t)(*((void *)this + 2) - *((void *)this + 1)) >> 3;
  CFWriteStreamWrite(stream, v16, 8);
  int v4 = *(_DWORD *)v16;
  if (*(uint64_t *)v16 >= 1)
  {
    uint64_t v5 = 0;
    unsigned int v6 = 1;
    do
    {
      BOOL v7 = *(HEIFMainImage **)(*((void *)this + 1) + 8 * v5);
      if (v7)
      {
        uint64_t result = HEIFMainImage::writeToStream(v7, stream);
        if (result) {
          return result;
        }
      }
      else
      {
        LogError("writeToStream", 2796, "*** ERROR: count=%d --> _mainImages[%d] is NULL?\n", v4, v6 - 1);
      }
      uint64_t v5 = v6;
      int v4 = *(_DWORD *)v16;
      BOOL v9 = *(void *)v16 <= (uint64_t)v6++;
    }
    while (!v9);
  }
  *(void *)uint64_t v16 = (uint64_t)(*((void *)this + 5) - *((void *)this + 4)) >> 3;
  CFWriteStreamWrite(stream, v16, 8);
  int v10 = *(_DWORD *)v16;
  if (*(uint64_t *)v16 >= 1)
  {
    uint64_t v11 = 0;
    unsigned int v12 = 1;
    do
    {
      uint64_t v13 = *(HEIFGroupItem **)(*((void *)this + 4) + 8 * v11);
      if (v13) {
        HEIFGroupItem::writeToStream(v13, stream);
      }
      else {
        LogError("writeToStream", 2813, "*** ERROR: count=%d --> _groupsList[%d] is NULL?\n", v10, v12 - 1);
      }
      uint64_t v11 = v12;
      int v10 = *(_DWORD *)v16;
      BOOL v9 = *(void *)v16 <= (uint64_t)v12++;
    }
    while (!v9);
  }
  CFWriteStreamWrite(stream, (const UInt8 *)this + 64, 8);
  CFDataRef Length = (const __CFData *)*((void *)this + 7);
  if (Length) {
    CFDataRef Length = (const __CFData *)CFDataGetLength(Length);
  }
  *(void *)uint64_t v16 = Length;
  CFWriteStreamWrite(stream, v16, 8);
  uint64_t result = 0;
  if (*((void *)this + 7))
  {
    if (*(void *)v16)
    {
      BytePtr = CFDataGetBytePtr(*((CFDataRef *)this + 7));
      CFWriteStreamWrite(stream, BytePtr, *(CFIndex *)v16);
      return 0;
    }
  }
  return result;
}

CFTypeRef GlobalHEIFInfo::createDataRepresentation(GlobalHEIFInfo *this)
{
  uint64_t v2 = CFWriteStreamCreateWithAllocatedBuffers((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFAllocatorRef)*MEMORY[0x1E4F1CF80]);
  if (!v2) {
    return 0;
  }
  int v3 = v2;
  if (CFWriteStreamOpen(v2))
  {
    GlobalHEIFInfo::writeToStream(this, v3);
    CFTypeRef v4 = CFWriteStreamCopyProperty(v3, (CFStreamPropertyKey)*MEMORY[0x1E4F1D440]);
    CFWriteStreamClose(v3);
  }
  else
  {
    CFTypeRef v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

double PSDReadPlugin::PSDReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(void *)uint64_t v5 = &unk_1ED4E08E0;
  double result = 0.0;
  *(_OWORD *)(v5 + 440) = 0u;
  *(_OWORD *)(v5 + 456) = 0u;
  *(void *)(v5 + 472) = 0;
  *(unsigned char *)(v5 + 461) = 1;
  return result;
}

void PSDReadPlugin::PSDReadPlugin(uint64_t a1, uint64_t a2)
{
}

void PSDReadPlugin::~PSDReadPlugin(PSDReadPlugin *this)
{
  *(void *)this = &unk_1ED4E08E0;
  uint64_t v2 = (void *)*((void *)this + 59);
  if (v2) {
    free(v2);
  }

  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  uint64_t vars8;

  PSDReadPlugin::~PSDReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t PSDReadPlugin::loadDataFromXPCObject(PSDReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_psd", &length);
    if (length == 40)
    {
      long long v6 = data[1];
      *(_OWORD *)((char *)this + 440) = *data;
      *(_OWORD *)((char *)this + 456) = v6;
      *((void *)this + 59) = 0;
      if (*((_WORD *)this + 233))
      {
        size_t size = 0;
        BOOL v7 = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_psd_layer", &size);
        if (size == 440 * *((unsigned __int16 *)this + 233))
        {
          uint64_t v8 = malloc_type_malloc(size, 0x29EB2149uLL);
          *((void *)this + 59) = v8;
          memcpy(v8, v7, size);
        }
        else
        {
          *((_WORD *)this + 233) = 0;
        }
      }
      return 0;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t PSDReadPlugin::saveDataToXPCObject(void **this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject((IIOReadPlugin *)this, a2);
  if (!v4)
  {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_psd", this + 55, 0x28uLL);
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_psd_layer", this[59], 440 * *((unsigned __int16 *)this + 233));
  }
  return v4;
}

uint64_t PSDReadPlugin::readHeader(uint64_t a1, unsigned int *a2)
{
  if (IIOImageReadSession::getBytes(*(IIOImageReadSession **)(a1 + 24), a2, 0x1AuLL) != 26)
  {
    _cg_jpeg_mem_term("readHeader", 180, "*** ERROR: can't read PSD header\n");
    return 4294967246;
  }
  unsigned int v4 = *a2;
  *a2 = bswap32(*a2);
  unsigned int v5 = *((unsigned __int16 *)a2 + 2);
  __int16 v6 = __rev16(v5);
  *((_WORD *)a2 + 2) = v6;
  int v7 = bswap32(*((unsigned __int16 *)a2 + 6));
  *((_WORD *)a2 + 6) = HIWORD(v7);
  unsigned int v8 = *(unsigned int *)((char *)a2 + 14);
  unsigned int v9 = bswap32(v8);
  *(unsigned int *)((char *)a2 + 14) = v9;
  unsigned int v10 = *(unsigned int *)((char *)a2 + 18);
  unsigned int v11 = bswap32(v10);
  *(unsigned int *)((char *)a2 + 18) = v11;
  unsigned int v12 = *((unsigned __int16 *)a2 + 11);
  unsigned int v13 = __rev16(v12);
  *((_WORD *)a2 + 11) = v13;
  unsigned int v14 = bswap32(*((unsigned __int16 *)a2 + 12)) >> 16;
  *((_WORD *)a2 + 12) = v14;
  if (v4 != 1397768760)
  {
    _cg_jpeg_mem_term("readHeader", 190, "*** ERROR: bad signature\n");
    return 4294967246;
  }
  if ((unsigned __int16)(v6 - 1) >= 2u)
  {
    _cg_jpeg_mem_term("readHeader", 191, "*** ERROR: bad header version\n");
    return 4294967246;
  }
  if (v5 == 256)
  {
    if (!v8 || v9 >= 0x7531)
    {
      _cg_jpeg_mem_term("readHeader", 195, "*** ERROR: unsupported height (%d)\n");
      return 4294967246;
    }
    if (!v10 || v11 >= 0x7531)
    {
      _cg_jpeg_mem_term("readHeader", 196, "*** ERROR: unsupported width (%d)\n");
      return 4294967246;
    }
  }
  else
  {
    if (!v8 || v9 >= 0x493E1)
    {
      _cg_jpeg_mem_term("readHeader", 200, "*** ERROR: unsupported height (%d)\n");
      return 4294967246;
    }
    if (!v10 || v11 > 0x493E0)
    {
      _cg_jpeg_mem_term("readHeader", 201, "*** ERROR: unsupported width (%d)\n");
      return 4294967246;
    }
    *(unsigned char *)(a1 + 463) = 1;
  }
  if (v14 > 9) {
    goto LABEL_29;
  }
  if (((1 << v14) & 0x31E) != 0)
  {
    if (v13 > 0x20 || ((1 << v13) & 0x100010100) == 0)
    {
      _cg_jpeg_mem_term("readHeader", 218, "*** ERROR: unsupported bitsPerComp\n");
      return 4294967246;
    }
    int v16 = v7 >> 16;
    if (v16 > 24 || modeChans[v14] > v16)
    {
      _cg_jpeg_mem_term("readHeader", 219, "*** ERROR: unsupported numChannels for mode\n");
      return 4294967246;
    }
    return 0;
  }
  if (v14)
  {
LABEL_29:
    _cg_jpeg_mem_term("readHeader", 210, "*** ERROR: unsupported mode (%d)\n");
    return 4294967246;
  }
  if (v12 != 256 || *((_WORD *)a2 + 6) != 1)
  {
    _cg_jpeg_mem_term("readHeader", 214, "*** ERROR: unsupported bitsPerComp/numChannels\n");
    return 4294967246;
  }
  return 0;
}

uint64_t PSDReadPlugin::initThumbnail(PSDReadPlugin *this)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  v17[0] = 0;
  v17[1] = 0;
  __int16 v19 = 0;
  uint64_t v18 = 0;
  uint64_t v16 = 0;
  uint64_t result = PSDReadPlugin::readHeader((uint64_t)this, (unsigned int *)v17);
  if (!result)
  {
    if (IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), (unsigned char *)&v16 + 4, 4uLL) == 4)
    {
      int v3 = HIDWORD(v16);
      unsigned int v4 = bswap32(HIDWORD(v16));
      HIDWORD(v16) = v4;
      if (HIWORD(v18) == 32
        || (v3 == 196608 ? (BOOL v5 = v19 == 2) : (BOOL v5 = 0), !v5 ? (v6 = 0) : (v6 = 1), !v3 || (v6 & 1) != 0 || v19 == 8))
      {
        if (IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), v4 + 30, 0) == v4 + 30
          && IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), &v16, 4uLL) == 4)
        {
          unsigned int v15 = 0;
          for (LODWORD(v16) = bswap32(v16);
                IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), &v15, 4uLL) == 4;
                unsigned int v15 = 0)
          {
            unsigned int v7 = v15;
            unsigned int v15 = bswap32(v15);
            if (v7 != 1296646712) {
              break;
            }
            unsigned __int16 v14 = 0;
            if (IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), &v14, 2uLL) != 2) {
              break;
            }
            unsigned __int16 v14 = bswap32(v14) >> 16;
            unsigned __int8 v13 = 0;
            if (IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), &v13, 1uLL) != 1) {
              break;
            }
            if (v13 > 0xFDu) {
              break;
            }
            unint64_t v8 = v13 | 1;
            memset(v20, 0, sizeof(v20));
            if (IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), v20, v8) != v8) {
              break;
            }
            *((unsigned char *)v20 + v13) = 0;
            unsigned int v12 = 0;
            if (IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), &v12, 4uLL) != 4) {
              break;
            }
            unsigned int v9 = bswap32(v12);
            unsigned int v12 = v9;
            if ((v9 & 0x80000000) != 0) {
              break;
            }
            if (v14 == 1036)
            {
              uint64_t v10 = IIO_Reader::minimumFileSize(*((IIO_Reader **)this + 3)) + 28;
              uint64_t v11 = v12;
              if (IIO_XPCServer())
              {
                ImageIOLog("*********************************************************************\n");
                ImageIOLog("**** __FIXME__ -- swapping the IIOReadPlugin\n");
                ImageIOLog("*********************************************************************\n");
              }
              CGImagePluginInitJPEGAtOffset(*((void *)this + 1), 0, v10, v11, *((_DWORD *)this + 53) != 0, *((unsigned int *)this + 53), 1347634208);
            }
            if (IIOImageReadSession::skipBytes(*((IIOImageReadSession **)this + 3), (v9 + 1) & 0xFFFFFFFE) != (IIOImageRead *)((v9 + 1) & 0xFFFFFFFE)) {
              break;
            }
          }
        }
      }
    }
    return 4294967246;
  }
  return result;
}

char *PSDReadPlugin::parseLayers(PSDReadPlugin *this, IIOScanner *a2, __int16 *a3)
{
  unint64_t v6 = *((void *)a2 + 2);
  *a3 = 0;
  __int16 Val16 = IIOScanner::getVal16(a2);
  LOWORD(v8) = Val16;
  if (Val16 < 0)
  {
    *((unsigned char *)this + 464) = 1;
    int v8 = -Val16;
  }
  if ((__int16)v8 >= 8000)
  {
    _cg_jpeg_mem_term("parseLayers", 369, "*** ERROR: unexpected number of layers: %d\n");
    return 0;
  }
  if (*((void *)this + 23) <= (unint64_t)(unsigned __int16)v8)
  {
    _cg_jpeg_mem_term("parseLayers", 370, "*** ERROR: unexpected number of layers: %d\n");
    return 0;
  }
  float32x4_t v59 = a3;
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("    got %d layers\n", (__int16)v8);
  }
  unsigned int v61 = (char *)malloc_type_calloc((unsigned __int16)v8, 0x1B8uLL, 0x100004037BD86E4uLL);
  if (!v61)
  {
    _cg_jpeg_mem_term("parseLayers", 380, "*** ERROR: failed to allocate 'layerInfoPtr'\n");
    return 0;
  }
  __int16 v58 = v8;
  if ((__int16)v8 < 1)
  {
LABEL_63:
    __int16 *v59 = v58;
  }
  else
  {
    uint64_t v9 = 0;
    CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v10 = v61;
    uint64_t v60 = (__int16)v8;
    do
    {
      int Val32 = IIOScanner::getVal32(a2);
      uint64_t v12 = v9;
      unsigned __int8 v13 = &v61[440 * v9];
      *(_DWORD *)unsigned __int8 v13 = Val32;
      int v14 = IIOScanner::getVal32(a2);
      *((_DWORD *)v13 + 1) = v14;
      int v15 = IIOScanner::getVal32(a2);
      *((_DWORD *)v13 + 2) = v15;
      int v16 = IIOScanner::getVal32(a2);
      int v17 = v16;
      *((_DWORD *)v13 + 3) = v16;
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("    #%d:   {%d, %d, %d, %d}\n", v12, v14, Val32, v16, v15);
      }
      uint64_t v62 = v12;
      unsigned int v18 = IIOScanner::getVal16(a2);
      unsigned int v19 = v18;
      if (v18 >= 0x10)
      {
        _cg_jpeg_mem_term("parseLayers", 415, "*** ERROR: unexpected number of channels: %d (max=%d)\n");
        return v61;
      }
      if (!v18)
      {
        _cg_jpeg_mem_term("parseLayers", 416, "*** ERROR: unexpected number of channels: %d (max=%d)\n");
        return v61;
      }
      if ((gIIODebugFlags & 0x30000) != 0) {
        ImageIOLog("       : %d channels\n", v18);
      }
      uint64_t v20 = &v61[440 * v62];
      v20[18] = 1;
      uint64_t v21 = v20 + 18;
      *((_WORD *)v21 - 1) = v19;
      if (Val32 >= v15 || v14 >= v17)
      {
        _cg_jpeg_mem_term("parseLayers", 426, "*** ERROR: skipping layer#%d {%d, %d, %d, %d}\n", v62, v14, Val32, v17, v15);
        *uint64_t v21 = 0;
      }
      if (v15 - (uint64_t)Val32 > *((void *)a2 + 2))
      {
        _cg_jpeg_mem_term("parseLayers", 431, "*** ERROR: skipping layer#%d {%d, %d, %d, %d}\n", v62, v14, Val32, v17, v15);
        *uint64_t v21 = 0;
      }
      uint64_t v22 = 0;
      if (v19 <= 1) {
        uint64_t v23 = 1;
      }
      else {
        uint64_t v23 = v19;
      }
      do
      {
        *(_WORD *)&v10[2 * v22 + 20] = IIOScanner::getVal16(a2);
        if (*((unsigned char *)this + 463)) {
          unint64_t Val64 = IIOScanner::getVal64(a2);
        }
        else {
          unint64_t Val64 = IIOScanner::getVal32(a2);
        }
        *(void *)&v10[8 * v22++ + 56] = Val64;
      }
      while (v23 != v22);
      if (IIOScanner::getVal32(a2) != 943868237) {
        return v61;
      }
      if (!IIOScanner::getVal32(a2)) {
        return v61;
      }
      IIOScanner::skip((uint64_t)a2, 4);
      unsigned int v25 = IIOScanner::getVal32(a2);
      if (!v25 || *((void *)a2 + 2) - *((void *)a2 + 3) <= (unint64_t)v25) {
        return v61;
      }
      size_t v26 = v25;
      if (*v21)
      {
        uint64_t v27 = malloc_type_calloc(v25, 1uLL, 0xDC777311uLL);
        uint64_t v28 = v62;
        if (!v27)
        {
          _cg_jpeg_mem_term("parseLayers", 485, "*** ERROR: failed to allocate 'tempBuffer'\n", v55, v56);
          return v61;
        }
        float v29 = v27;
        if (IIOScanner::getBytes(a2, v27, v26) != v26)
        {
          _cg_jpeg_mem_term("parseLayers", 487, "*** ERROR: can't read layer data\n", v55, v56);
          return v61;
        }
        float v30 = memmem(v29, v26, "8BIMluni", 8uLL);
        if (v30)
        {
          uint64_t v31 = (unsigned char *)v29 - (unsigned char *)v30 + v26;
          if (v31 >= 17)
          {
            unint64_t v32 = 2 * bswap32(*((_DWORD *)v30 + 3));
            unint64_t v33 = v31 - 16;
            unsigned int v34 = v31 - 16;
            if (v33 >= v32) {
              unsigned int v34 = v32;
            }
            if (v34 >= 0x17)
            {
              *((_WORD *)v30 + 7) = -2;
              if (*((unsigned char *)v30 + 16)
                || *((unsigned char *)v30 + 17) != 60
                || *((unsigned char *)v30 + 18)
                || *((unsigned char *)v30 + 19) != 47)
              {
                CFStringRef v35 = CFStringCreateWithBytes(0, (const UInt8 *)v30 + 14, v34 + 2, 0x100u, 1u);
                CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(*((IIODictionary **)this + 7), @"LayerNames", @"{8BIM}");
                if (!ObjectForKeyGroup)
                {
                  CFDictionaryRef ObjectForKeyGroup = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E4F1D510]);
                  IIODictionary::setObjectForKeyGroup(*((IIODictionary **)this + 7), ObjectForKeyGroup, @"LayerNames", @"{8BIM}");
                  CFRelease(ObjectForKeyGroup);
                }
                memset(__dst, 0, sizeof(__dst));
                IIOArray::IIOArray((IIOArray *)__dst, ObjectForKeyGroup);
                IIOArray::addObject(__dst, v35);
                CFRelease(v35);
                IIOArray::~IIOArray((IIOArray *)__dst);
              }
            }
          }
        }
        free(v29);
      }
      else
      {
        IIOScanner::skip((uint64_t)a2, v25);
        uint64_t v28 = v62;
      }
      uint64_t v9 = v28 + 1;
      v10 += 440;
    }
    while (v9 != v60);
    uint64_t v37 = 0;
    unint64_t v38 = *((void *)a2 + 3);
    float32x4_t v39 = (unint64_t *)(v61 + 184);
    do
    {
      uint64_t v40 = *(unsigned __int16 *)&v61[440 * v37 + 16];
      int32x4_t v41 = v39;
      if (*(_WORD *)&v61[440 * v37 + 16])
      {
        do
        {
          *int32x4_t v41 = v38;
          uint64_t v42 = *(v41 - 16);
          BOOL v43 = __CFADD__(v38, v42);
          v38 += v42;
          if (v43 || v38 >= v6)
          {
            _cg_jpeg_mem_term("parseLayers", 553, "*** ERROR: layer offset (%ld) > fileSize (%d)\n", v38, v6);
            exception = __cxa_allocate_exception(4uLL);
            _DWORD *exception = -1;
            __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
          }
          ++v41;
          --v40;
        }
        while (v40);
      }
      ++v37;
      v39 += 55;
    }
    while (v37 != v60);
    uint64_t v44 = 0;
    float32x4_t v45 = v61 + 312;
    while (1)
    {
      int32x4_t v46 = &v61[440 * v44];
      int v48 = *((unsigned __int16 *)v46 + 8);
      uint64_t v47 = (unsigned __int16 *)(v46 + 16);
      if (v48) {
        break;
      }
LABEL_62:
      ++v44;
      v45 += 55;
      if (v44 == v60) {
        goto LABEL_63;
      }
    }
    unint64_t v49 = 0;
    float32x4_t v50 = v45;
    while (1)
    {
      uint64_t v51 = *(v50 - 16);
      LOWORD(__dst[0]) = 0;
      if (IIOScanner::getBytesAtOffset(a2, __dst, v51, 2uLL) != 2) {
        break;
      }
      uint64_t v52 = bswap32(LOWORD(__dst[0])) >> 16;
      LOWORD(__dst[0]) = v52;
      void *v50 = v52;
      IIOScanner::seek(a2, *(v50 - 32) + v51);
      if (*((_DWORD *)a2 + 16)) {
        break;
      }
      ++v49;
      ++v50;
      if (v49 >= *v47) {
        goto LABEL_62;
      }
    }
  }
  return v61;
}

void sub_1887E8618(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

uint64_t PSDReadPlugin::initialize(PSDReadPlugin *this, IIODictionary *a2)
{
  *(void *)&v111[766] = *MEMORY[0x1E4F143B8];
  uint64_t v106 = 0;
  long long v107 = 0uLL;
  unsigned __int16 v108 = 0;
  bzero(colorTable, 0x300uLL);
  __int16 v105 = 0;
  uint64_t v104 = 0;
  memset(v103, 0, sizeof(v103));
  uint64_t v101 = this;
  IIOScanner::IIOScanner((IIOScanner *)v103, *((IIOImageReadSession **)this + 3));
  GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v103, 0);
  CFDictionaryRef data = IIODictionary::getObjectForKey(*((IIODictionary **)this + 6), @"kCGImageSourceXMPSidecar");
  int v3 = IIOSkipMetadata(*((IIODictionary **)this + 6));
  int v4 = IIOSkipXMP_and_IPTC(*((IIODictionary **)this + 6));
  if (*((unsigned __int8 *)this + 216) < 2u) {
    char v5 = 1;
  }
  else {
    char v5 = v3;
  }
  if ((v5 & 1) == 0)
  {
    if ((gIIODebugFlags & 0x4000000000000) != 0 && IIO_OSAppleInternalBuild()) {
      ImageIOLog("••• Ⓜ️  skipping metadata for thumbnail creation\n");
    }
    int v3 = 1;
  }
  if (IIODictionary::containsKey(*((IIODictionary **)this + 6), @"kCGImageSourceSubsampleFactor")) {
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(*((IIODictionary **)this + 6), @"kCGImageSourceSubsampleFactor");
  }
  else {
    unsigned int Uint32ForKey = 0;
  }
  if (PSDReadPlugin::readHeader((uint64_t)this, (unsigned int *)&v106))
  {
    uint64_t v57 = 4294967246;
    goto LABEL_237;
  }
  *((unsigned char *)this + 464) = 1;
  unint64_t v6 = IIO_Reader::minimumFileSize(*((IIO_Reader **)this + 3));
  IIOScanner::seek((IIOScanner *)v103, v6);
  int Val32 = IIOScanner::getVal32((IIOScanner *)v103);
  if (v108 == 2 && !Val32) {
    goto LABEL_263;
  }
  unsigned int v7 = 0;
  if (HIWORD(v107) == 16 || HIWORD(v107) == 32) {
    goto LABEL_33;
  }
  BOOL v8 = Val32 == 768 && v108 == 2;
  BOOL v9 = v8;
  if (Val32 && v108 != 8 && !v9) {
    goto LABEL_263;
  }
  unsigned int v7 = 0;
  if (!Val32 || v108 != 2) {
    goto LABEL_33;
  }
  if (SWORD2(v107) >= 3)
  {
    _cg_jpeg_mem_term("initialize", 688, "*** ERROR: too many channels (%d) for indexed color image\n", WORD2(v107));
    goto LABEL_263;
  }
  uint64_t v10 = malloc_type_calloc(3uLL, 0x100uLL, 0xF2487E0EuLL);
  unsigned int v7 = v10;
  if (!v10)
  {
LABEL_263:
    uint64_t v57 = 4294967246;
    goto LABEL_238;
  }
  if (IIOScanner::getBytes((IIOScanner *)v103, v10, 0x300uLL) != 768)
  {
    int v35 = 0;
    _cg_jpeg_mem_term("initialize", 695, "*** ERROR: can't read PSD color palette\n");
    uint64_t v57 = 4294967246;
    goto LABEL_235;
  }
  uint64_t v11 = v111;
  for (uint64_t i = 256; i != 512; ++i)
  {
    *(v11 - 2) = v7[i - 256];
    *(v11 - 1) = v7[i];
    unsigned char *v11 = v7[i + 256];
    v11 += 3;
  }
LABEL_33:
  BOOL v99 = v7;
  IIOScanner::seek((IIOScanner *)v103, (Val32 + 30));
  unsigned int v95 = IIOScanner::getVal32((IIOScanner *)v103);
  if (*((void *)this + 23) <= (unint64_t)v95)
  {
    int v35 = 0;
    goto LABEL_261;
  }
  MetadataFromDataUInt8 buffer = 0;
  MetadataFromIPTCDataUInt8 buffer = 0;
  CFTypeRef cf = 0;
  uint64_t v98 = 0;
  while (1)
  {
    memset(__dst, 0, 256);
    if (IIOScanner::getVal32((IIOScanner *)v103) != 943868237) {
      break;
    }
    int Val16 = IIOScanner::getVal16((IIOScanner *)v103);
    int Val8 = IIOScanner::getVal8((IIOScanner *)v103);
    size_t v17 = Val8 | 1u;
    IIOScanner::copyBytes(v103, __dst, v17);
    IIOScanner::skip((uint64_t)v103, v17);
    __dst[Val8] = 0;
    unsigned int v18 = IIOScanner::getVal32((IIOScanner *)v103);
    unsigned int v19 = v18;
    if ((v18 & 0x80000000) != 0)
    {
      CGImageMetadataRef v29 = 0;
      if (!MetadataFromDatabuffer) {
        goto LABEL_85;
      }
LABEL_84:
      CFRelease(MetadataFromDatabuffer);
      goto LABEL_85;
    }
    size_t v20 = (v18 + 1) & 0xFFFFFFFE;
    if (Val16 == 1082)
    {
      LOBYTE(v98) = 1;
      goto LABEL_50;
    }
    if (Val16 == 1028)
    {
      BYTE4(v98) = 1;
      int v21 = v3;
    }
    else
    {
      int v21 = 1;
    }
    if ((v21 | v4))
    {
      if ((Val16 & 0xFFFE) == 0x422)
      {
        if (v20)
        {
          uint64_t v22 = malloc_type_calloc((v18 + 1) & 0xFFFFFFFE, 1uLL, 0xC720A62BuLL);
          if (v22)
          {
            if (IIOScanner::getBytes((IIOScanner *)v103, v22, (v19 + 1) & 0xFFFFFFFE) != v20)
            {
              uint64_t v23 = v22;
              _cg_jpeg_mem_term("initialize", 786, "*** ERROR: can't read kPhotoshopExif data\n");
              goto LABEL_248;
            }
            IIOMetadataFlagsFromImageSourceOptions(*((IIODictionary **)this + 6));
            if (MetadataFromDatabuffer) {
              CFRelease(MetadataFromDatabuffer);
            }
            uint64_t v23 = v22;
            MetadataFromDataUInt8 buffer = (const void *)CreateMetadataFromDatabuffer(v22, v19);
            goto LABEL_77;
          }
        }
      }
      else if (Val16 == 1039)
      {
        if (v20)
        {
          unsigned int v25 = malloc_type_calloc((v18 + 1) & 0xFFFFFFFE, 1uLL, 0xDA06C7B3uLL);
          if (v25)
          {
            if (IIOScanner::getBytes((IIOScanner *)v103, v25, v20) != v20)
            {
              uint64_t v23 = v25;
              _cg_jpeg_mem_term("initialize", 809, "*** ERROR: can't read kPhotoshopICC data\n");
              goto LABEL_248;
            }
            *((void *)this + 20) = CGColorSpaceCreateWithCopyOfData(v25, v20);
            uint64_t v23 = v25;
            goto LABEL_77;
          }
        }
      }
      else
      {
        if (Val16 == 1060 && data == 0) {
          int v27 = v3;
        }
        else {
          int v27 = 1;
        }
        if ((v27 | v4))
        {
          if (Val16 == 1057)
          {
            IIOScanner::getVal32((IIOScanner *)v103);
            *((unsigned char *)this + 461) = IIOScanner::getVal8((IIOScanner *)v103) != 0;
            IIOScanner::skip((uint64_t)v103, (v20 - 5));
          }
          else
          {
LABEL_50:
            IIOScanner::skip((uint64_t)v103, (v18 + 1) & 0xFFFFFFFE);
          }
        }
        else if (v20)
        {
          uint64_t v28 = malloc_type_calloc((v18 + 1) & 0xFFFFFFFE, 1uLL, 0xE3945338uLL);
          if (v28)
          {
            uint64_t v23 = v28;
            if (IIOScanner::getBytes((IIOScanner *)v103, v28, (v19 + 1) & 0xFFFFFFFE) != v20)
            {
              _cg_jpeg_mem_term("initialize", 824, "*** ERROR: can't read kPhotoshopXMP data\n");
LABEL_248:
              unint64_t v33 = 0;
              int v35 = 0;
              if (MetadataFromDatabuffer) {
                CFRelease(MetadataFromDatabuffer);
              }
              if (MetadataFromIPTCDatabuffer) {
                CFRelease(MetadataFromIPTCDatabuffer);
              }
              if (cf) {
                CFRelease(cf);
              }
              free(v23);
LABEL_131:
              uint64_t v57 = 4294967246;
              if (!v33) {
                goto LABEL_234;
              }
LABEL_233:
              free(v33);
              goto LABEL_234;
            }
            if (cf) {
              CFRelease(cf);
            }
            CFTypeRef cf = (CFTypeRef)CreateMetadataFromXMPBuffer(v23, v19);
LABEL_77:
            free(v23);
          }
        }
      }
    }
    else if (v20)
    {
      unsigned int v24 = malloc_type_calloc((v18 + 1) & 0xFFFFFFFE, 1uLL, 0xB11DC623uLL);
      if (v24)
      {
        uint64_t v23 = v24;
        if (IIOScanner::getBytes((IIOScanner *)v103, v24, (v19 + 1) & 0xFFFFFFFE) != v20)
        {
          _cg_jpeg_mem_term("initialize", 764, "*** ERROR: can't read kPhotoshopIPTC data\n");
          goto LABEL_248;
        }
        if (MetadataFromIPTCDatabuffer) {
          CFRelease(MetadataFromIPTCDatabuffer);
        }
        MetadataFromIPTCDataUInt8 buffer = CreateMetadataFromIPTCDatabuffer(v23, v19);
        goto LABEL_77;
      }
    }
  }
  if (data) {
    CGImageMetadataRef v29 = CGImageMetadataCreateFromXMPData(data);
  }
  else {
    CGImageMetadataRef v29 = 0;
  }
  CGImageMetadataMerge(*((void *)this + 8), (uint64_t)MetadataFromDatabuffer, *((IIODictionary **)this + 6));
  if ((v4 & 1) == 0)
  {
    CGImageMetadataMerge(*((void *)this + 8), (uint64_t)MetadataFromIPTCDatabuffer, *((IIODictionary **)this + 6));
    CGImageMetadataMerge(*((void *)this + 8), (uint64_t)cf, *((IIODictionary **)this + 6));
    CGImageMetadataMerge(*((void *)this + 8), (uint64_t)v29, *((IIODictionary **)this + 6));
  }
  if (MetadataFromDatabuffer) {
    goto LABEL_84;
  }
LABEL_85:
  if (MetadataFromIPTCDatabuffer) {
    CFRelease(MetadataFromIPTCDatabuffer);
  }
  if (v29) {
    CFRelease(v29);
  }
  if (cf) {
    CFRelease(cf);
  }
  unsigned int v30 = Val32 + v95 + 34;
  IIOScanner::seek((IIOScanner *)v103, v30, 0);
  if (!*((unsigned char *)this + 463))
  {
    unsigned int v34 = IIOScanner::getVal32((IIOScanner *)v103);
    int v32 = 0;
    unint64_t v33 = 0;
    if (v34 < 9)
    {
LABEL_116:
      if (v3) {
        goto LABEL_121;
      }
      goto LABEL_117;
    }
    goto LABEL_99;
  }
  unint64_t Val64 = IIOScanner::getVal64((IIOScanner *)v103);
  int v32 = Val64;
  if (Val64 >= 9)
  {
    int v35 = 0;
    if (Val64 >= *((void *)this + 23)) {
      goto LABEL_261;
    }
    unsigned int v34 = 0;
LABEL_99:
    if (!*((unsigned char *)this + 463))
    {
      uint64_t v38 = IIOScanner::getVal32((IIOScanner *)v103);
      if (*((void *)this + 23) <= (unint64_t)v38)
      {
        unint64_t v92 = "*** ERROR: unexpected layerBlockSize=%d [0x%X]\n";
        uint64_t v93 = 936;
LABEL_260:
        int v35 = 0;
        _cg_jpeg_mem_term("initialize", v93, v92, v38, v38);
        goto LABEL_261;
      }
LABEL_104:
      if (v38)
      {
LABEL_114:
        uint64_t v40 = PSDReadPlugin::parseLayers(this, (IIOScanner *)v103, &v105);
LABEL_115:
        unint64_t v33 = v40;
        goto LABEL_116;
      }
      uint64_t v38 = IIOScanner::getVal32((IIOScanner *)v103);
      if (*((void *)this + 23) > (unint64_t)v38)
      {
        if (v38) {
          IIOScanner::seek((IIOScanner *)v103, v38, 1);
        }
        if (IIOScanner::getVal32((IIOScanner *)v103) == 943868237)
        {
          int v39 = IIOScanner::getVal32((IIOScanner *)v103);
          if (v39 == 1282552626 || v39 == 1282552118)
          {
            IIOScanner::getVal32((IIOScanner *)v103);
            uint64_t v40 = PSDReadPlugin::parseLayers(this, (IIOScanner *)v103, &v105);
            goto LABEL_115;
          }
          if (v39 == 1179480939)
          {
            unint64_t v33 = 0;
            *((unsigned char *)this + 464) = 0;
            if (v3) {
              goto LABEL_121;
            }
            goto LABEL_117;
          }
        }
        unint64_t v33 = 0;
        if ((v3 & 1) == 0) {
          goto LABEL_117;
        }
        goto LABEL_121;
      }
      unint64_t v92 = "*** ERROR: unexpected maskBlockSize=%d [0x%X]\n";
      uint64_t v93 = 952;
      goto LABEL_260;
    }
    unint64_t v36 = IIOScanner::getVal64((IIOScanner *)v103);
    unint64_t v37 = v36;
    if (v36 < *((void *)this + 23))
    {
      LODWORD(v38) = 0;
      if (v37) {
        goto LABEL_114;
      }
      goto LABEL_104;
    }
    int v35 = 0;
    _cg_jpeg_mem_term("initialize", 931, "*** ERROR: unexpected layerBlockSize=%lld [0x%X]\n", v36, v36);
LABEL_261:
    uint64_t v57 = 4294967246;
    goto LABEL_234;
  }
  unint64_t v33 = 0;
  unsigned int v34 = 0;
  if (v3) {
    goto LABEL_121;
  }
LABEL_117:
  int32x4_t v41 = (IIODictionary *)*((void *)this + 7);
  if (*((unsigned char *)this + 463)) {
    int v42 = 2;
  }
  else {
    int v42 = 1;
  }
  IIONumber::IIONumber((IIONumber *)v102, v42);
  IIODictionary::setObjectForKeyGroup(v41, (uint64_t)v102, @"Version", @"{8BIM}");
  IIONumber::~IIONumber((IIONumber *)v102);
LABEL_121:
  if (*((unsigned char *)this + 463)) {
    int v43 = 8;
  }
  else {
    int v43 = 4;
  }
  unint64_t v44 = v30 + v32 + v34 + v43;
  IIOScanner::seek((IIOScanner *)v103, v44);
  unsigned int v45 = IIOScanner::getVal16((IIOScanner *)v103);
  *((_WORD *)this + 229) = v45;
  if (v104)
  {
    int v35 = -39;
    goto LABEL_131;
  }
  if (v45 > 1)
  {
    int v35 = -4;
    goto LABEL_131;
  }
  if (!v45)
  {
    int32x4_t v46 = v33;
    int v47 = *(_DWORD *)((char *)&v107 + 10);
    int v48 = *(_DWORD *)((char *)&v107 + 6);
    int v49 = SWORD2(v107);
    int v50 = SHIWORD(v107);
    unsigned int Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)v101 + 3));
    unint64_t v52 = v48 * v47 * v49 * ((v50 + 7) >> 3);
    unint64_t v33 = v46;
    if ((unint64_t)Size < v52)
    {
      int v53 = *(_DWORD *)((char *)&v107 + 10);
      int v54 = *(_DWORD *)((char *)&v107 + 6);
      int v55 = SWORD2(v107);
      unsigned int v56 = IIOImageReadSession::getSize(*((IIOImageReadSession **)v101 + 3));
      _cg_jpeg_mem_term("initialize", 1012, "*** ERROR: truncated file? %d x %d x %d  -  fileSize: %d\n", v53, v54, v55, v56);
      int v35 = 0;
      uint64_t v57 = 4294967246;
      unint64_t v33 = v46;
      if (!v46) {
        goto LABEL_234;
      }
      goto LABEL_233;
    }
  }
  int v58 = v108;
  int v59 = 1196573017;
  switch(v108)
  {
    case 0u:
    case 1u:
    case 8u:
      goto LABEL_141;
    case 2u:
      *((_DWORD *)v101 + 81) = 1380401696;
      unsigned int v60 = Uint32ForKey;
      if (!v99) {
        goto LABEL_135;
      }
      goto LABEL_143;
    case 3u:
      int v59 = 1380401696;
      goto LABEL_141;
    case 4u:
      int v59 = 1129142603;
      goto LABEL_141;
    case 9u:
      int v59 = 1281450528;
LABEL_141:
      *((_DWORD *)v101 + 81) = v59;
      break;
    default:
      break;
  }
  unsigned int v60 = Uint32ForKey;
  if (v99)
  {
LABEL_143:
    unsigned int v61 = (CGColorSpace *)*((void *)v101 + 20);
    if (!v61) {
      unsigned int v61 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
    }
    if (CGColorSpaceGetModel(v61) != kCGColorSpaceModelRGB)
    {
      _cg_jpeg_mem_term("initialize", 1035, "*** ERROR: header says indexed color, but ICC profile is not RGB\n");
      int v35 = 0;
      goto LABEL_131;
    }
    *((void *)v101 + 20) = CGColorSpaceCreateIndexed(v61, 0xFFuLL, colorTable);
    CGColorSpaceRelease(v61);
  }
  else if (v58 == 2)
  {
LABEL_135:
    int v35 = 0;
    BOOL v99 = 0;
    _cg_jpeg_mem_term("initialize", 1043, "*** ERROR: bad header data: modeIndexed, but no paletteData\n");
    goto LABEL_131;
  }
  unsigned int v62 = (unsigned __int16)v105;
  int v63 = v105;
  if (!*((unsigned char *)v101 + 461) && v105 >= 1)
  {
    char v64 = 0;
    char v65 = 1;
    float v66 = v101;
    *((unsigned char *)v101 + 246) = 1;
    int v67 = v108;
    goto LABEL_164;
  }
  *((unsigned char *)v101 + 246) = 0;
  int v67 = v108;
  if (modeChans[(__int16)v108] >= SWORD2(v107))
  {
    if (v108 == 3)
    {
      char v64 = 0;
      char v65 = 5;
      float v66 = v101;
      *((unsigned char *)v101 + 246) = 5;
      int v67 = 3;
      goto LABEL_164;
    }
    char v65 = 0;
    char v64 = 1;
    goto LABEL_163;
  }
  char v65 = 3;
  *((unsigned char *)v101 + 246) = 3;
  if ((v98 & 0x100000000) == 0)
  {
    char v64 = 0;
LABEL_163:
    float v66 = v101;
    goto LABEL_164;
  }
  if ((v98 & (HIWORD(v107) == 8)) != 1)
  {
    char v64 = 0;
    char v65 = 3;
    goto LABEL_163;
  }
  float v66 = v101;
  char v64 = *((unsigned char *)v101 + 464);
  if (v64)
  {
    char v64 = 0;
    char v65 = 1;
  }
  else
  {
    char v65 = 5;
  }
  *((unsigned char *)v101 + 246) = v65;
LABEL_164:
  *((unsigned char *)v66 + 278) = v65;
  __int16 v68 = WORD2(v107);
  int v69 = WORD2(v107);
  *((_DWORD *)v66 + 110) = SWORD2(v107);
  *((_WORD *)v66 + 122) = v68;
  int v70 = modeChans[(__int16)v67];
  if (v69 - v70 < 2)
  {
    if (v69 - v70 == 1) {
      *((unsigned char *)v101 + 465) = 1;
    }
    unsigned __int16 v71 = v69;
  }
  else
  {
    unsigned __int16 v71 = v70 + 1;
    *((_WORD *)v66 + 122) = v70 + 1;
    *((unsigned char *)v66 + 465) = 1;
    int v69 = (unsigned __int16)(v70 + 1);
  }
  if (v70 == v69) {
    char v72 = v64;
  }
  else {
    char v72 = 1;
  }
  if (v72)
  {
    unint64_t v73 = v101;
  }
  else
  {
    ++v71;
    unint64_t v73 = v101;
    *((_WORD *)v101 + 122) = v71;
  }
  unsigned int v74 = *(_DWORD *)((char *)&v107 + 10);
  unsigned int v75 = *(_DWORD *)((char *)&v107 + 6);
  *((_DWORD *)v73 + 57) = *(_DWORD *)((char *)&v107 + 10);
  *((_DWORD *)v73 + 58) = v75;
  if (!v60)
  {
    unsigned int v76 = *((_DWORD *)v101 + 53);
    if (v76)
    {
      double v77 = (double)v74 / (double)v76;
      if (v77 <= (double)v75 / (double)v76) {
        double v77 = (double)v75 / (double)v76;
      }
      unsigned int v60 = v77;
    }
    else
    {
      unsigned int v60 = 0;
    }
  }
  int v78 = HIWORD(v107);
  if (v67 == 2 || HIWORD(v107) == 32) {
    unsigned int v80 = 0;
  }
  else {
    unsigned int v80 = v60;
  }
  if (v74 >= v75) {
    unsigned int v81 = v75;
  }
  else {
    unsigned int v81 = v74;
  }
  if (v80 - 1 >= v81)
  {
    long long v83 = v101;
    *((_WORD *)v101 + 158) = 0;
LABEL_194:
    *((_DWORD *)v83 + 59) = 0;
    goto LABEL_211;
  }
  if (v80 > 0x7F)
  {
    unsigned int v82 = 128;
    goto LABEL_209;
  }
  if (v80 > 0x3F)
  {
    unsigned int v82 = 64;
    goto LABEL_209;
  }
  if (v80 > 0x1F)
  {
    unsigned int v82 = 32;
    goto LABEL_209;
  }
  if (v80 > 0xF)
  {
    unsigned int v82 = 16;
    goto LABEL_209;
  }
  if (v80 > 7)
  {
    unsigned int v82 = 8;
    goto LABEL_209;
  }
  if (v80 < 4)
  {
    long long v83 = v101;
    *((_WORD *)v101 + 158) = 2 * (v80 > 1);
    if (v80 >= 2)
    {
      unsigned int v82 = 2;
      goto LABEL_210;
    }
    goto LABEL_194;
  }
  unsigned int v82 = 4;
LABEL_209:
  long long v83 = v101;
  *((_WORD *)v101 + 158) = v82;
LABEL_210:
  *((_DWORD *)v83 + 65) = v74 / v82;
  *((_DWORD *)v83 + 66) = v75 / v82;
  unsigned int v84 = ((v74 * v78 * v71 + 7) >> 3) / v82;
  *((_DWORD *)v83 + 67) = v84;
  *((_DWORD *)v83 + 75) = v84;
LABEL_211:
  __int16 v85 = v71 * v78;
  *((_WORD *)v83 + 121) = v71 * v78;
  *((_WORD *)v83 + 120) = v78;
  *((unsigned char *)v83 + 344) = 1;
  *((unsigned char *)v83 + 346) = 0;
  if (v78 == 16)
  {
    uint64_t v86 = (char *)v101 + 247;
LABEL_215:
    *uint64_t v86 = 1;
  }
  else if (v78 == 32)
  {
    *((unsigned char *)v101 + 249) = 1;
    uint64_t v86 = (char *)v101 + 345;
    goto LABEL_215;
  }
  if ((v64 & 1) == 0)
  {
    if (v85 == 32)
    {
      char v87 = 0;
LABEL_221:
      *((unsigned char *)v101 + 247) = v87;
    }
    else if (v85 == 64)
    {
      char v87 = 1;
      goto LABEL_221;
    }
  }
  if (v63 >= 1 && v33)
  {
    *((_WORD *)v101 + 233) = v63;
    size_t v88 = 440 * v62;
    long long v89 = malloc_type_calloc(v88, 1uLL, 0x1EB63D19uLL);
    *((void *)v101 + 59) = v89;
    if (!v89)
    {
      int v35 = 0;
      _cg_jpeg_mem_term("initialize", 1182, "*** ERROR: failed to allocate '_psd._layerPtr'\n");
      uint64_t v57 = 4294967246;
      goto LABEL_233;
    }
    memcpy(v89, v33, v88);
  }
  if ((gIIODebugFlags & 0x30000) != 0)
  {
    BOOL v90 = ImageIOLog("    PSD-layers\n");
    PSDReadPlugin::dumpLayers((uint64_t)v90, *((unsigned __int16 *)v101 + 233), *((void *)v101 + 59));
  }
  *((_DWORD *)v101 + 59) = ((*((unsigned __int16 *)v101 + 121) + 7) >> 3) * *((_DWORD *)v101 + 57);
  *((void *)v101 + 56) = 0;
  *((_WORD *)v101 + 228) = v108;
  *((void *)v101 + 24) = v44;
  *((unsigned char *)v101 + 460) = 0;
  *((void *)v101 + 45) = 1;
  if (*((_DWORD *)v101 + 81) == 1281450528) {
    *((unsigned char *)v101 + 462) = 1;
  }
  if (*((_WORD *)v101 + 137) == 32) {
    *((unsigned char *)v101 + 350) = 1;
  }
  uint64_t v57 = 0;
  int v35 = 0;
  *((_WORD *)v101 + 188) = 1;
  if (v33) {
    goto LABEL_233;
  }
LABEL_234:
  unsigned int v7 = v99;
  if (v99) {
LABEL_235:
  }
    free(v7);
  if (v35) {
LABEL_237:
  }
    kdebug_trace();
LABEL_238:
  IIOScanner::~IIOScanner((IIOScanner *)v103);
  return v57;
}

void sub_1887E9A10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,char a23)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    JUMPOUT(0x1887E9878);
  }
  _Unwind_Resume(exception_object);
}

const char *PSDReadPlugin::dumpLayers(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v4 = 0;
    uint64_t v5 = a2;
    uint64_t v6 = a3 + 20;
    unsigned int v7 = (uint64_t *)(a3 + 312);
    do
    {
      uint64_t v8 = a3 + 440 * v4;
      ImageIOLog("#%2d:  {%d, %d, %d, %d}   \n", v4, *(_DWORD *)(v8 + 4), *(_DWORD *)v8, *(_DWORD *)(v8 + 12), *(_DWORD *)(v8 + 8));
      int v10 = *(unsigned __int16 *)(v8 + 16);
      BOOL v9 = (_WORD *)(v8 + 16);
      uint64_t result = ImageIOLog("       %d channels:\n", v10);
      if (*v9)
      {
        unint64_t v12 = 0;
        unsigned __int8 v13 = v7;
        do
        {
          uint64_t v14 = *(v13 - 32);
          uint64_t v15 = *(v13 - 16);
          uint64_t v16 = *v13++;
          uint64_t result = ImageIOLog("          id: %2d    size: %8lld    offset: 0x%08X    compression: %d\n", *(__int16 *)(v6 + 2 * v12++), v14, v15, v16);
        }
        while (v12 < (unsigned __int16)*v9);
      }
      ++v4;
      v6 += 440;
      v7 += 55;
    }
    while (v4 != v5);
  }
  return result;
}

void PSDReadPlugin::convertPremulWhiteToBlack8(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unint64_t v4 = (unint64_t)*(double *)(a2 + 32);
  if (v4)
  {
    uint64_t v5 = 0;
    double v6 = *(double *)(a2 + 24);
    unint64_t v7 = (unint64_t)v6;
    BOOL v9 = *(unsigned char **)(a2 + 40);
    uint64_t v8 = *(void *)(a2 + 48);
    int v10 = v9 + 1;
    do
    {
      if (a4 == 3)
      {
        if (v7)
        {
          unint64_t v13 = (unint64_t)v6;
          uint64_t v14 = v10;
          do
          {
            char v15 = ~v14[2];
            *(v14 - 1) += v14[2] + 1;
            *v14 -= v15;
            v14[1] -= v15;
            v14 += a3;
            --v13;
          }
          while (v13);
        }
      }
      else if (a4 == 1)
      {
        unint64_t v11 = (unint64_t)v6;
        unint64_t v12 = v9;
        if (v7)
        {
          do
          {
            *v12 += v12[1] + 1;
            v12 += a3;
            --v11;
          }
          while (v11);
        }
      }
      v9 += v8;
      ++v5;
      v10 += v8;
    }
    while (v5 != v4);
  }
}

uint64_t PSDReadPlugin::decode_packbits(PSDReadPlugin *this, const unsigned __int8 *a2, unsigned __int8 *__b, unsigned int a4, unsigned int a5, int a6, char a7, uint64_t a8, unsigned int a9)
{
  if (!a5) {
    return 0;
  }
  uint64_t v9 = a8;
  int v10 = __b;
  uint64_t v12 = a5;
  uint64_t v13 = *((unsigned __int16 *)this + 154);
  uint64_t v14 = &__b[a5];
  uint64_t v15 = a4;
  int v35 = a8;
  while (2)
  {
    uint64_t v16 = 0;
    uint64_t v17 = v15;
    do
    {
      if (v17 < 1) {
        return 0;
      }
      uint64_t v18 = (char)a2[v16];
      if ((v18 & 0x8000000000000000) == 0)
      {
        uint64_t v36 = v9;
        uint64_t v26 = a2[v16];
        if (v26 >= v12)
        {
          uint64_t v27 = v12;
          _cg_jpeg_mem_term("decode_packbits", 1498, "*** ERROR: channel[%d] row[%d] discarding %lld bytes to avoid buffer overrun", v35, a9, a2[v16] - v12 + 1);
          uint64_t v12 = v27;
          uint64_t v26 = v27 - 1;
        }
        uint64_t v28 = v26 + 1;
        if (v17 > v26 + 1)
        {
          unsigned int v24 = &a2[v16 + 1];
          if (a6 == 1)
          {
            uint64_t v29 = v12;
            memcpy(v10, &a2[v16 + 1], v26 + 1);
            v10 += v28;
            uint64_t v12 = v29 - v28;
            unsigned int v24 = &a2[v26 + 2 + v16];
            uint64_t v15 = v15 - v26 - v16 - 2;
          }
          else
          {
            v15 += ~v16;
            if ((v26 & 0x8000000000000000) == 0 && v10 < v14)
            {
              uint64_t v30 = 0;
              do
              {
                *int v10 = a2[v16 + 1 + v30] ^ a7;
                v10 += v13;
                uint64_t v31 = v30 + 1;
                if (v26 <= v30) {
                  break;
                }
                ++v30;
              }
              while (v10 < v14);
              v12 -= v31;
              uint64_t v15 = ~v31 + v17;
              unsigned int v24 = &a2[v16 + 1 + v31];
            }
          }
          uint64_t v9 = v36;
          goto LABEL_25;
        }
        uint64_t v33 = 1501;
        LODWORD(v9) = v36;
LABEL_35:
        _cg_jpeg_mem_term("decode_packbits", v33, "*** ERROR: channel[%d] row[%d] terminating PackBitsDecode due to lack of data\n", v9, a9);
        return 4294967246;
      }
      ++v16;
      --v17;
    }
    while (v18 == -128);
    int64_t v19 = 1 - v18;
    BOOL v20 = __OFSUB__(1 - v18, v12);
    uint64_t v21 = 1 - v18 - v12;
    if (!((v21 < 0) ^ v20 | (v21 == 0)))
    {
      uint64_t v22 = v12;
      _cg_jpeg_mem_term("decode_packbits", 1475, "*** ERROR: channel[%d] row[%d] discarding %lld bytes to avoid buffer overrun\n", v9, a9, v21);
      uint64_t v12 = v22;
      int64_t v19 = v22;
    }
    if (v15 == v16)
    {
      uint64_t v33 = 1478;
      goto LABEL_35;
    }
    v12 -= v19;
    unsigned int v24 = &a2[v16 + 1];
    int v23 = a2[v16];
    v15 += ~v16;
    if (a6 == 1)
    {
      if (v19 >= 1)
      {
        uint64_t v25 = v12;
        memset(v10, v23, v19);
        uint64_t v12 = v25;
        v10 += v19;
      }
    }
    else if (v19 >= 1 && v10 < v14)
    {
      do
      {
        *int v10 = v23 ^ a7;
        v10 += v13;
        if ((unint64_t)v19 < 2) {
          break;
        }
        --v19;
      }
      while (v10 < v14);
    }
LABEL_25:
    a2 = v24;
    if (v12 > 0) {
      continue;
    }
    return 0;
  }
}

void PSDReadPlugin::decode_32_bit_predictor(PSDReadPlugin *this, unsigned __int8 *a2, unsigned __int8 *a3, int a4, unsigned int a5)
{
  uint64_t v5 = 4 * a5;
  if (a4)
  {
    uint64_t v6 = 0;
    unint64_t v7 = a2 + 1;
    do
    {
      int v8 = a2[v6 * v5];
      uint64_t v9 = (v5 - 1);
      int v10 = v7;
      do
      {
        v8 += *v10;
        *v10++ = v8;
        --v9;
      }
      while (v9);
      ++v6;
      v7 += v5;
    }
    while (v6 != a4);
  }
  unint64_t v11 = (v5 * a4);
  if (v11)
  {
    uint64_t v12 = 0;
    for (unint64_t i = 0; i < v11; i += v5)
    {
      if (a5)
      {
        unint64_t v14 = i;
        do
        {
          if (v5)
          {
            unint64_t v15 = v14;
            do
            {
              a3[v12++] = a2[v15];
              v15 += a5;
            }
            while (v15 < v14 + v5);
          }
          ++v14;
        }
        while (v14 < i + a5);
      }
    }
  }
}

char *PSDReadPlugin::decodeLayer(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned __int16 *)(a2 + 16) - 3 >= 2)
  {
    _cg_jpeg_mem_term("decodeLayer", 1603, "*** ERROR: unexpected number of channels: %d\n");
    return 0;
  }
  uint64_t v3 = a2;
  uint64_t v4 = *(int *)(a2 + 12);
  uint64_t v5 = *(int *)(a2 + 4);
  int64_t v6 = v4 - v5;
  if ((int)v4 - (int)v5 <= 0)
  {
    _cg_jpeg_mem_term("decodeLayer", 1604, "*** ERROR: width <= 0 - skipping layer decoding\n");
    return 0;
  }
  int64_t v7 = (uint64_t)*(double *)(a3 + 24);
  if (v7 <= 0)
  {
    _cg_jpeg_mem_term("decodeLayer", 1605, "*** ERROR: height <= 0 - skipping layer decoding\n");
    return 0;
  }
  if (((*(unsigned __int16 *)(a1 + 306) + 7) & 0x1FFF8) != *(unsigned __int16 *)(a1 + 306)) {
    return 0;
  }
  int64_t size = (((unint64_t)*(unsigned __int16 *)(a1 + 304) + 7) >> 3) * v6;
  if (size <= 0)
  {
    _cg_jpeg_mem_term("decodeLayer", 1612, "*** ERROR: rowBytes <= 0 - skipping layer decoding\n");
    return 0;
  }
  double v9 = (double)*(int *)a2;
  double v10 = *(double *)(a3 + 8);
  uint64_t v11 = (uint64_t)(v10 - v9);
  if (v10 <= v9) {
    uint64_t v11 = 0;
  }
  if (v11 < 0)
  {
    _cg_jpeg_mem_term("decodeLayer", 1618, "*** ERROR: layerYOffset: %lld\n");
    return 0;
  }
  uint64_t v12 = 4 * size;
  if (!is_mul_ok(v7, 4 * size))
  {
    _cg_jpeg_mem_term("decodeLayer", 1621, "*** ERROR: bad layer size %ld x %ld (rb: %ld)\n");
    return 0;
  }
  uint64_t v13 = malloc_type_calloc(v7 * v12, 1uLL, 0x47A63013uLL);
  unint64_t v14 = (char *)v13;
  if (!v13)
  {
    _cg_jpeg_mem_term("decodeLayer", 1626, "*** ERROR: failed to allocate 'buffer' (%ld bytes)\n");
    return v14;
  }
  if (*(_WORD *)(v3 + 16) == 3)
  {
    if (*(_WORD *)(a1 + 304) == 32)
    {
      LODWORD(v15) = 0;
      uint64_t v16 = v13 + 3;
      do
      {
        int64_t v17 = 0;
        do
        {
          _DWORD *v16 = 1065353216;
          v16 += 4;
          ++v17;
        }
        while (v17 < v6);
        int64_t v15 = (v15 + 1);
      }
      while (v15 < v7);
    }
    else
    {
      memset(v13, 255, v7 * v12);
    }
  }
  if ((v12 & 0x80000000) == 0)
  {
    uint64_t v18 = malloc_type_calloc((8 * size), 1uLL, 0x66072EFDuLL);
    if (!v18)
    {
      _cg_jpeg_mem_term("decodeLayer", 1650, "*** ERROR: failed to allocate 'rleRow' (%d bytes)\n");
      return v14;
    }
    __int16 v85 = v18;
    size_t count = v7;
    size_t v88 = v14;
    if (!*(_WORD *)(v3 + 16))
    {
LABEL_111:
      free(v85);
      return v88;
    }
    unint64_t v19 = 0;
    uint64_t v89 = v6 * count;
    uint64_t v86 = 2 * count;
    uint64_t v87 = 4 * count;
    uint64_t v20 = 2;
    if ((unint64_t)v6 > 2) {
      uint64_t v20 = v4 - v5;
    }
    if (count <= 1) {
      uint64_t v21 = 1;
    }
    else {
      uint64_t v21 = count;
    }
    uint64_t v84 = v21;
    uint64_t v82 = 2 * v4 - 2 * v5;
    uint64_t v83 = v20 - 1;
    uint64_t v90 = v3;
    while (1)
    {
      uint64_t v22 = (void *)(v3 + 8 * v19);
      uint64_t v23 = v22[39];
      if ((unint64_t)(v23 - 2) < 2)
      {
        unint64_t v34 = v22[23] + 2;
        uint64_t v35 = v22[7] - 2;
        uint64_t v36 = (Bytef *)malloc_type_calloc(v35, 1uLL, 0x428221B0uLL);
        unint64_t v37 = (Bytef *)malloc_type_calloc(count, size, 0x297104E6uLL);
        if (IIOImageReadSession::getBytesAtOffset(*(IIOImageReadSession **)(a1 + 24), v36, v34, v35) == v35)
        {
          memset(&strm.avail_in, 0, 104);
          strm.next_in = v36;
          strm.avail_in = v35;
          strm.next_out = v37;
          strm.avail_out = size * count;
          if (inflateInit_(&strm, "1.2.12", 112) || inflate(&strm, 4) != 1) {
            _cg_jpeg_mem_term("decodeLayer", 1835, "*** ERROR: inflate failed\n");
          }
          else {
            inflateEnd(&strm);
          }
          if (v22[39] == 3)
          {
            int v42 = *(unsigned __int16 *)(a1 + 304);
            if (v42 == 32)
            {
              unint64_t v73 = (PSDReadPlugin *)malloc_type_malloc(4 * v6 * count, 0xFF891555uLL);
              PSDReadPlugin::decode_32_bit_predictor(v73, v37, (unsigned __int8 *)v73, count, v6);
              if (v89 >= 1)
              {
                uint64_t v74 = 0;
                do
                {
                  *((_DWORD *)v73 + v74) = bswap32(*((_DWORD *)v73 + v74));
                  ++v74;
                }
                while (v89 > v74);
                uint64_t v75 = 0;
                unsigned int v76 = (float *)&v88[4 * v19];
                do
                {
                  *unsigned int v76 = (float)bswap32(*((float *)v73 + v75));
                  v76 += 4;
                  ++v75;
                }
                while (v89 > v75);
              }
            }
            else if (v42 == 16)
            {
              dest.CFDictionaryRef data = v37;
              dest.double height = count;
              dest.double width = v6;
              dest.rowunint64_t Bytes = size;
              vImageByteSwap_Planar16U(&dest, &dest, 0x10u);
              uint64_t v43 = 0;
              unint64_t v44 = v37 + 2;
              do
              {
                if (v6 >= 2)
                {
                  int v45 = *(unsigned __int16 *)&v37[2 * v6 * v43];
                  int32x4_t v46 = v44;
                  uint64_t v47 = v83;
                  do
                  {
                    v45 += *(unsigned __int16 *)v46;
                    *(_WORD *)int32x4_t v46 = v45;
                    v46 += 2;
                    --v47;
                  }
                  while (v47);
                }
                ++v43;
                v44 += v82;
              }
              while (v43 != v84);
              if (v89 >= 1)
              {
                uint64_t v48 = 0;
                int v49 = &v88[2 * v19];
                do
                {
                  *(_WORD *)int v49 = *(_WORD *)&v37[2 * v48];
                  v49 += 8;
                  ++v48;
                }
                while (v89 > v48);
              }
            }
          }
        }
      }
      else if (v23)
      {
        if (v23 != 1)
        {
          _cg_jpeg_mem_term("decodeLayer", 1887, "*** ERROR: invalid compression: %d\n", v23);
LABEL_114:
          free(v85);
          free(v88);
          return 0;
        }
        unsigned int v24 = (unint64_t *)malloc_type_calloc(count, 8uLL, 0x100004000313F17uLL);
        uint64_t v25 = malloc_type_calloc(count, 4uLL, 0x100004052888210uLL);
        unint64_t v26 = *(void *)(v3 + 8 * v19 + 184) + 2;
        if (*(unsigned char *)(a1 + 463))
        {
          size_t v27 = 0;
          if (IIOImageReadSession::getBytesAtOffset(*(IIOImageReadSession **)(a1 + 24), v25, *(void *)(v3 + 8 * v19 + 184) + 2, v87) == v87&& count != 0)
          {
            unint64_t v29 = v26 + v87;
            uint64_t v30 = count;
            uint64_t v31 = v24;
            int v32 = v25;
            do
            {
              size_t v33 = bswap32(*(unsigned __int16 *)v32) >> 16;
              if (v27 <= v33) {
                size_t v27 = v33;
              }
              *v32++ = v33;
              *v31++ = v29;
              v29 += v33;
              --v30;
            }
            while (v30);
          }
        }
        else
        {
          int v50 = (unsigned __int16 *)malloc_type_calloc(count, 2uLL, 0x1000040BDFB0063uLL);
          if (!v50) {
            goto LABEL_111;
          }
          uint64_t v51 = v50;
          size_t v27 = 0;
          if (IIOImageReadSession::getBytesAtOffset(*(IIOImageReadSession **)(a1 + 24), v50, v26, v86) == v86
            && count != 0)
          {
            unint64_t v53 = v26 + v86;
            uint64_t v54 = count;
            int v55 = v24;
            unsigned int v56 = v25;
            uint64_t v57 = v51;
            do
            {
              unsigned int v58 = *v57++;
              size_t v59 = bswap32(v58) >> 16;
              if (v27 <= v59) {
                size_t v27 = v59;
              }
              *v56++ = v59;
              *v55++ = v53;
              v53 += v59;
              --v54;
            }
            while (v54);
          }
          free(v51);
        }
        unsigned int v60 = (unsigned __int8 *)malloc_type_malloc(v27, 0xEDB386D8uLL);
        unsigned int v61 = (unsigned __int8 *)malloc_type_malloc(size, 0xE26258CAuLL);
        if (count)
        {
          unsigned int v62 = v61;
          uint64_t v63 = 0;
          char v64 = v88;
          do
          {
            unint64_t v65 = *(unsigned int *)&v25[4 * v63];
            if (IIOImageReadSession::getBytesAtOffset(*(IIOImageReadSession **)(a1 + 24), v60, v24[v63], v65) == v65)
            {
              if (PSDReadPlugin::decode_packbits((PSDReadPlugin *)a1, v60, v62, v65, size, 1, 0, v19, v63))goto LABEL_114; {
              int v66 = *(unsigned __int16 *)(a1 + 304);
              }
              switch(v66)
              {
                case 32:
                  int64_t v69 = 0;
                  int v70 = &v64[4 * v19];
                  do
                  {
                    *(_DWORD *)int v70 = bswap32(*(_DWORD *)&v62[4 * v69]);
                    v70 += 16;
                    ++v69;
                  }
                  while (v69 < v6);
                  break;
                case 16:
                  int64_t v71 = 0;
                  char v72 = &v64[2 * v19];
                  do
                  {
                    *(_WORD *)char v72 = *(_WORD *)&v62[2 * v71];
                    v72 += 8;
                    ++v71;
                  }
                  while (v71 < v6);
                  break;
                case 8:
                  int64_t v67 = 0;
                  __int16 v68 = v64;
                  do
                  {
                    v68[v19] = v62[v67++];
                    v68 += 4;
                  }
                  while (v67 < v6);
                  break;
              }
              v64 += 4 * size;
            }
            ++v63;
          }
          while (v63 != count);
        }
      }
      else
      {
        uint64_t v38 = malloc_type_calloc(count, size, 0x6A5410C0uLL);
        if (IIOImageReadSession::getBytesAtOffset(*(IIOImageReadSession **)(a1 + 24), v38, *(void *)(v3 + 8 * v19 + 184) + 2, size * count) == size * count)
        {
          int v39 = *(unsigned __int16 *)(a1 + 304);
          if (v39 == 32)
          {
            if (v89 >= 1)
            {
              uint64_t v77 = 0;
              int v78 = &v88[4 * v19];
              do
              {
                *(_DWORD *)int v78 = bswap32(*(_DWORD *)&v38[4 * v77]);
                v78 += 16;
                ++v77;
              }
              while (v89 > v77);
            }
          }
          else if (v39 == 16)
          {
            if (v89 >= 1)
            {
              uint64_t v79 = 0;
              unsigned int v80 = &v88[2 * v19];
              do
              {
                *(_WORD *)unsigned int v80 = *(_WORD *)&v38[2 * v79];
                v80 += 8;
                ++v79;
              }
              while (v89 > v79);
            }
          }
          else if (v39 == 8 && v89 >= 1)
          {
            uint64_t v40 = 0;
            int32x4_t v41 = &v88[v19];
            do
            {
              *int32x4_t v41 = v38[v40];
              v41 += 4;
              ++v40;
            }
            while (v89 > v40);
          }
        }
        free(v38);
      }
      ++v19;
      uint64_t v3 = v90;
      if (v19 >= *(unsigned __int16 *)(v90 + 16)) {
        goto LABEL_111;
      }
    }
  }
  return v14;
}

__n128 PSDReadPlugin::mergeLayers(PSDReadPlugin *this, IIODecodeFrameParams *a2, __n128 result)
{
  if (*((void *)this + 59))
  {
    unsigned int v4 = *((unsigned __int16 *)this + 233);
    if (*((_WORD *)this + 233))
    {
      uint64_t v6 = 0;
      unint64_t v7 = 0;
      double v8 = *((double *)a2 + 1);
      double v9 = *((double *)a2 + 2);
      CGFloat v10 = *((double *)a2 + 4);
      CGFloat r1 = *((double *)a2 + 3);
      do
      {
        memcpy(__dst, (const void *)(*((void *)this + 59) + v6), 0x1B8uLL);
        if (BYTE2(__dst[4]))
        {
          int v12 = __dst[2];
          int v11 = __dst[3];
          int v14 = __dst[0];
          int v13 = __dst[1];
          int v15 = __dst[3] - __dst[1];
          double v16 = (double)__dst[1];
          v37.origin.double y = (double)__dst[0];
          v37.size.double width = (double)(__dst[3] - __dst[1]);
          v37.size.double height = (double)(__dst[2] - __dst[0]);
          v35.origin.CGFloat x = v8;
          v35.origin.double y = v9;
          v35.size.double width = r1;
          v35.size.double height = v10;
          v37.origin.CGFloat x = (double)__dst[1];
          *(CGRect *)result.n128_u64 = CGRectIntersection(v35, v37);
          v32[0] = result.n128_u64[0];
          v32[1] = *(void *)&v36.origin.y;
          unsigned char v32[2] = *(void *)&v36.size.width;
          void v32[3] = *(void *)&v36.size.height;
          unsigned int v17 = *((unsigned __int16 *)this + 152);
          if ((v17 & 7) != 0) {
            return result;
          }
          double v18 = result.n128_f64[0];
          result.n128_u64[0] = *((void *)a2 + 3);
          if (*((void *)a2 + 6) >= 4 * (unint64_t)result.n128_f64[0] && v12 > v14 && v11 > v13)
          {
            double y = v36.origin.y;
            double width = v36.size.width;
            double height = v36.size.height;
            double v24 = v18;
            if (!CGRectIsEmpty(v36))
            {
              uint64_t v25 = PSDReadPlugin::decodeLayer((uint64_t)this, (uint64_t)__dst, (uint64_t)v32);
              if (v25)
              {
                unint64_t v26 = v25;
                unsigned int v27 = v17 >> 3;
                srcTop.CFDictionaryRef data = &v25[(v17 >> 3) * ((v13 >> 31) & (4 * (int)(v18 - v16)))];
                srcTop.double height = (unint64_t)height;
                srcTop.double width = (unint64_t)width;
                srcTop.rowunint64_t Bytes = 4 * v15 * (v17 >> 3);
                size_t v28 = *((void *)a2 + 6);
                dest.CFDictionaryRef data = (void *)(*((void *)a2 + 5) + v28 * (int)(y - v9) + 4 * (int)(v18 - v8) * (v17 >> 3));
                dest.double height = (unint64_t)height;
                dest.double width = (unint64_t)width;
                dest.rowunint64_t Bytes = v28;
                if (v17 >> 3 == 4)
                {
                  AlphaBlend<unsigned int>((uint64_t *)&srcTop, (uint64_t *)&dest, (uint64_t *)&dest);
                }
                else if (v27 == 2)
                {
                  AlphaBlend<unsigned short>((uint64_t *)&srcTop, (uint64_t *)&dest, (uint64_t *)&dest);
                }
                else if (v27 == 1)
                {
                  vImageAlphaBlend_ARGB8888(&srcTop, &dest, &dest, 0x10u);
                }
                free(v26);
              }
            }
          }
          unsigned int v4 = *((unsigned __int16 *)this + 233);
        }
        ++v7;
        v6 += 440;
      }
      while (v7 < v4);
    }
  }
  else
  {
    return _cg_jpeg_mem_term("mergeLayers", 1915, "*** Error: MergeLayers was called with NULL _layerPtr\n");
  }
  return result;
}

uint64_t AlphaBlend<unsigned short>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t v3 = a1[1];
  if (v3)
  {
    LODWORD(v4) = 0;
    uint64_t v5 = *a3;
    uint64_t v6 = *a2;
    uint64_t v7 = *a1;
    unint64_t v8 = a1[2];
    uint64_t v9 = a1[3];
    uint64_t v10 = a2[3];
    uint64_t v11 = a3[3];
    do
    {
      if (v8)
      {
        uint64_t v12 = 0;
        unsigned int v13 = 1;
        do
        {
          int v14 = (_WORD *)(v5 + v12);
          __int16 v15 = *(_WORD *)(v7 + v12);
          __int16 v16 = *(_WORD *)(v7 + v12 + 4);
          __int16 v17 = *(_WORD *)(v7 + v12 + 6);
          __int16 v18 = *(_WORD *)(v6 + v12 + 2);
          __int16 v19 = *(_WORD *)(v6 + v12 + 4);
          *int v14 = *(_WORD *)(v7 + v12 + 2) + *(_WORD *)(v6 + v12) * ~v15;
          v14[1] = v16 + v18 * ~v15;
          v14[2] = v17 + v19 * ~v15;
          void v14[3] = v15;
          v12 += 8;
        }
        while (v8 > v13++);
      }
      v7 += v9;
      v6 += v10;
      v5 += v11;
      unint64_t v4 = (v4 + 1);
    }
    while (v3 > v4);
  }
  return 0;
}

uint64_t AlphaBlend<unsigned int>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  unint64_t v3 = a1[1];
  if (v3)
  {
    LODWORD(v4) = 0;
    uint64_t v5 = *a3;
    uint64_t v6 = *a2;
    uint64_t v7 = *a1;
    unint64_t v8 = a1[2];
    uint64_t v9 = a1[3];
    uint64_t v10 = a2[3];
    uint64_t v11 = a3[3];
    do
    {
      if (v8)
      {
        uint64_t v12 = 0;
        unsigned int v13 = 1;
        do
        {
          int v14 = (int32x2_t *)(v5 + v12);
          __int32 v15 = *(_DWORD *)(v7 + v12);
          int v16 = *(_DWORD *)(v7 + v12 + 12);
          int v17 = *(_DWORD *)(v6 + v12 + 8);
          *int v14 = vmla_s32(*(int32x2_t *)(v7 + v12 + 4), *(int32x2_t *)(v6 + v12), vdup_n_s32(~v15));
          v14[1].i32[0] = v16 + v17 * ~v15;
          v14[1].i32[1] = v15;
          v12 += 16;
        }
        while (v8 > v13++);
      }
      v7 += v9;
      v6 += v10;
      v5 += v11;
      unint64_t v4 = (v4 + 1);
    }
    while (v3 > v4);
  }
  return 0;
}

void PSDReadPlugin::handlePremultiplication(PSDReadPlugin *this, IIODecodeFrameParams *a2, unsigned int a3)
{
  if (*((unsigned char *)this + 460) && *((unsigned char *)this + 278))
  {
    int v3 = *((unsigned __int16 *)this + 228);
    if (v3 == 1)
    {
      if (*((_WORD *)this + 120) == 8)
      {
        PSDReadPlugin::convertPremulWhiteToBlack8((uint64_t)this, (uint64_t)a2, a3, 1);
      }
    }
    else if (v3 == 3 && *((_WORD *)this + 120) == 8)
    {
      size_t v4 = *((void *)a2 + 6);
      v6.CFDictionaryRef data = (void *)*((void *)a2 + 5);
      int8x16_t v5 = (int8x16_t)vcvtq_u64_f64(*(float64x2_t *)((char *)a2 + 24));
      *(int8x16_t *)&v6.double height = vextq_s8(v5, v5, 8uLL);
      v6.rowunint64_t Bytes = v4;
      vImagePremultiplyData_RGBA8888(&v6, &v6, 0x10u);
    }
  }
}

uint64_t PSDReadPlugin::readDataSizeTable(PSDReadPlugin *this, unsigned int **a2, unsigned int **a3, unint64_t *a4)
{
  unsigned int v7 = *((_DWORD *)this + 58);
  if (!v7)
  {
    _cg_jpeg_mem_term("readDataSizeTable", 2110, "*** ERROR: readDataSizeTable height is 0\n");
LABEL_31:
    uint64_t v11 = 0;
LABEL_32:
    uint64_t v12 = 0;
    goto LABEL_33;
  }
  unsigned int v9 = *((_DWORD *)this + 110);
  if (!v9)
  {
    _cg_jpeg_mem_term("readDataSizeTable", 2111, "*** ERROR: readDataSizeTable NumberOfChannels is 0\n");
    goto LABEL_31;
  }
  unint64_t v10 = v7 * (unint64_t)v9;
  if ((v10 & 0xFFFFFFFF00000000) != 0)
  {
    _cg_jpeg_mem_term("readDataSizeTable", 2114, "*** ERROR: bad numValues (%d x %d)\n");
    goto LABEL_31;
  }
  if (v10 >> 30)
  {
    _cg_jpeg_mem_term("readDataSizeTable", 2117, "*** ERROR: bad table size %d x %d\n");
    goto LABEL_31;
  }
  uint64_t v11 = (char *)malloc_type_calloc((4 * v10), 1uLL, 0x97FD4E50uLL);
  if (!v11)
  {
    _cg_jpeg_mem_term("readDataSizeTable", 2120, "*** ERROR: failed to allocate 'localDataSizeTable'\n");
    goto LABEL_32;
  }
  uint64_t v12 = (unsigned int *)malloc_type_calloc((4 * v10), 1uLL, 0x5C3258B9uLL);
  if (!v12)
  {
    _cg_jpeg_mem_term("readDataSizeTable", 2123, "*** ERROR: failed to allocate 'localOffsetsTable'\n");
    goto LABEL_33;
  }
  if (!*((unsigned char *)this + 463))
  {
    int v17 = malloc_type_calloc((2 * v10), 1uLL, 0x2DDB12F5uLL);
    if (v17)
    {
      if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v17, *((void *)this + 24) + 2, (2 * v10)) == 2 * v10)
      {
        if (v10)
        {
          uint64_t v18 = 0;
          unsigned int v14 = 0;
          uint64_t v19 = *((void *)this + 24) + 2 * (*((_DWORD *)this + 110) * *((_DWORD *)this + 58)) + 2;
          do
          {
            unsigned int v20 = bswap32(*(unsigned __int16 *)&v17[2 * v18]);
            uint64_t v21 = HIWORD(v20);
            *(_DWORD *)&v11[4 * v18] = v21;
            if (v14 <= HIWORD(v20)) {
              unsigned int v14 = HIWORD(v20);
            }
            v12[v18] = v19;
            v19 += v21;
            ++v18;
          }
          while (v10 != v18);
          goto LABEL_25;
        }
        goto LABEL_24;
      }
    }
    else
    {
      _cg_jpeg_mem_term("readDataSizeTable", 2147, "*** ERROR: failed to allocate 'shortDataSizeTable'\n");
    }
LABEL_34:
    free(v17);
    free(v11);
    unsigned int v14 = 0;
    uint64_t v22 = 0;
    uint64_t v11 = 0;
    int v17 = v12;
    uint64_t v12 = 0;
    goto LABEL_26;
  }
  if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v11, *((void *)this + 24) + 2, (4 * v10)) != 4 * v10)
  {
LABEL_33:
    int v17 = 0;
    goto LABEL_34;
  }
  if (v10)
  {
    uint64_t v13 = 0;
    unsigned int v14 = 0;
    uint64_t v15 = *((void *)this + 24) + 4 * (*((_DWORD *)this + 110) * *((_DWORD *)this + 58)) + 2;
    do
    {
      uint64_t v16 = bswap32(*(_DWORD *)&v11[v13 * 4]);
      *(_DWORD *)&v11[v13 * 4] = v16;
      if (v16 > v14) {
        unsigned int v14 = v16;
      }
      v12[v13] = v15;
      v15 += v16;
      ++v13;
    }
    while (v10 != v13);
    int v17 = 0;
    goto LABEL_25;
  }
  int v17 = 0;
LABEL_24:
  unsigned int v14 = 0;
LABEL_25:
  uint64_t v22 = 1;
LABEL_26:
  free(v17);
  *a2 = (unsigned int *)v11;
  *a3 = v12;
  *a4 = v14;
  return v22;
}

uint64_t PSDReadPlugin::decodeBlock(PSDReadPlugin *this, IIODecodeFrameParams *a2, unsigned int a3, unsigned int a4, __n128 a5)
{
  vImage_Buffer v6 = a2;
  double v7 = *((double *)a2 + 2);
  double v8 = *((double *)a2 + 4);
  int v9 = *((_DWORD *)this + 57);
  int v10 = *((unsigned __int16 *)this + 120);
  uint64_t v87 = 0;
  size_t v88 = 0;
  unint64_t v86 = 0;
  unsigned int v80 = this;
  if (!*((unsigned char *)this + 461))
  {
    if (*((unsigned char *)this + 246))
    {
      bzero(*((void **)a2 + 5), *((void *)a2 + 6) * (unint64_t)v8);
      this = v80;
      int v10 = *((unsigned __int16 *)v80 + 120);
    }
    if (v10 == 1) {
      goto LABEL_103;
    }
    PSDReadPlugin::mergeLayers(v80, v6, a5);
    this = v80;
    size_t v15 = *((void *)v6 + 6);
    dest.CFDictionaryRef data = (void *)*((void *)v6 + 5);
    int8x16_t v16 = (int8x16_t)vcvtq_u64_f64(*(float64x2_t *)((char *)v6 + 24));
    *(int8x16_t *)&dest.double height = vextq_s8(v16, v16, 8uLL);
    dest.rowunint64_t Bytes = v15;
    if (*((_WORD *)v80 + 152) != 8) {
      goto LABEL_103;
    }
    if (*((unsigned char *)v80 + 404) == 1)
    {
      int v17 = 66051;
    }
    else
    {
      if (v15 < 4 * v16.i64[0])
      {
        _cg_jpeg_mem_term("decodeBlock", 2435, "*** ERROR: vImagePermuteChannels_ARGB8888 - width: %d  rowBytes: %d\n", v16.i32[0], v15);
LABEL_102:
        this = v80;
LABEL_103:
        unsigned int v28 = 0;
        uint64_t v18 = 0;
        unint64_t v26 = 0;
        goto LABEL_104;
      }
      int v17 = 197121;
    }
    *(_DWORD *)permuteMap = v17;
    vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
    goto LABEL_102;
  }
  unsigned int v12 = v9 * v10 + 7;
  size_t count = v12 >> 3;
  if (*((_WORD *)this + 229) == 1)
  {
    if (PSDReadPlugin::readDataSizeTable(this, &v87, &v88, &v86))
    {
      size_t v13 = v86;
      if (v86)
      {
        malloc_type_id_t v14 = 1863895455;
        goto LABEL_14;
      }
    }
LABEL_115:
    uint64_t v18 = 0;
LABEL_118:
    *((void *)v6 + 8) = 0;
    uint64_t v69 = 4294967246;
    goto LABEL_108;
  }
  if (v12 < 8) {
    goto LABEL_115;
  }
  size_t v13 = v12 >> 3;
  malloc_type_id_t v14 = 2817939150;
LABEL_14:
  uint64_t v18 = (unsigned int *)malloc_type_calloc(v13, 1uLL, v14);
  if (!v18)
  {
    _cg_jpeg_mem_term("decodeBlock", 2223, "*** ERROR: failed to allocate 'scanLineData'\n");
    goto LABEL_118;
  }
  if (*((_WORD *)v80 + 120) == 1)
  {
    if (malloc_type_calloc(*((void *)v6 + 6), 1uLL, 0x1AD45839uLL)) {
      operator new();
    }
    _cg_jpeg_mem_term("decodeBlock", 2229, "*** ERROR: failed to allocate 'tempData'\n");
    goto LABEL_118;
  }
  if (*((unsigned __int8 *)v80 + 278) - 5 > 1) {
    goto LABEL_25;
  }
  if (!*((unsigned char *)v80 + 345)) {
    goto LABEL_23;
  }
  int v19 = *((unsigned __int16 *)v80 + 136);
  if (v19 == 32)
  {
    double v24 = *((double *)v6 + 3);
    double v23 = *((double *)v6 + 4);
    size_t v25 = *((void *)v6 + 6);
    dest.CFDictionaryRef data = (void *)*((void *)v6 + 5);
    dest.double height = (unint64_t)v23;
    dest.double width = 4 * (unint64_t)v24;
    dest.rowunint64_t Bytes = v25;
    vImageOverwriteChannelsWithScalar_PlanarF(1.0, &dest, 0x10u);
    goto LABEL_25;
  }
  if (v19 == 16)
  {
    double v21 = *((double *)v6 + 3);
    double v20 = *((double *)v6 + 4);
    size_t v22 = *((void *)v6 + 6);
    dest.CFDictionaryRef data = (void *)*((void *)v6 + 5);
    dest.double height = (unint64_t)v20;
    dest.double width = 4 * (unint64_t)v21;
    dest.rowunint64_t Bytes = v22;
    vImageOverwriteChannelsWithScalar_Planar16U(0x3C00u, &dest, 0x10u);
  }
  else
  {
LABEL_23:
    memset(*((void **)v6 + 5), 255, (unint64_t)(*((double *)v6 + 4) * (double)*((unint64_t *)v6 + 6)));
  }
LABEL_25:
  unint64_t v26 = (unsigned __int8 *)malloc_type_malloc(*((unsigned int *)v6 + 12), 0xE471BB60uLL);
  unsigned int v72 = a4;
  if (a3)
  {
    unint64_t v27 = 0;
    unsigned int v28 = 0;
    uint64_t v29 = a4;
    unsigned int v74 = (v8 + (double)v7);
    uint64_t v73 = a3;
    uint64_t v75 = 2 * a4;
    uint64_t v76 = 4 * a4;
    unsigned int v77 = -50;
    this = v80;
    uint64_t v83 = (double *)v6;
    while (1)
    {
      unsigned int v30 = v27;
      if (v27 <= 3)
      {
        unsigned int v30 = v27;
        if (*((unsigned char *)this + 404) == 1) {
          unsigned int v30 = *((_DWORD *)&xmmword_1889AAEE0 + v27);
        }
      }
      int v31 = *((unsigned __int16 *)this + 228);
      BOOL v32 = v31 != 4 || v30 >= 4;
      BOOL v33 = !v32 || v31 == 0;
      int v34 = v33;
      uint64_t v35 = v7;
      unint64_t v36 = *((_WORD *)this + 229) == 1
          ? (*((_DWORD *)this + 58) * v27)
          : *((void *)this + 24)
          + count * (unint64_t)(*((_DWORD *)this + 58) * v27)
          + 2;
      unint64_t v81 = v36;
      uint64_t v79 = v27;
      if (v7 < v74) {
        break;
      }
LABEL_84:
      unint64_t v27 = v79 + 1;
      if (v79 + 1 == v73) {
        goto LABEL_87;
      }
    }
    uint64_t v37 = 0;
    int v38 = v34 << 31 >> 31;
    uint64_t v82 = v30;
    while (1)
    {
      if (*((_WORD *)this + 229) == 1)
      {
        unint64_t v39 = v88[v81 + v35];
        unint64_t v40 = v87[v81 + v35];
        if (!v87[v81 + v35]) {
          goto LABEL_93;
        }
      }
      else
      {
        unint64_t v40 = count;
        unint64_t v39 = v81 + v35 * count;
        if (!count)
        {
LABEL_93:
          _cg_jpeg_mem_term("decodeBlock", 2303, "*** ERROR: corrupt PSD image: row[%d]: srcDataLen==0\n");
          goto LABEL_105;
        }
      }
      int32x4_t v41 = (unsigned __int16 *)this;
      if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v18, v39, v40) != v40)
      {
        _cg_jpeg_mem_term("decodeBlock", 2306, "*** ERROR: failed to read scanline (expected: %d got: %d\n");
        goto LABEL_105;
      }
      uint64_t v42 = *((void *)v6 + 6);
      uint64_t v43 = *((void *)v6 + 5) + v42 * v37;
      if (v41[229] != 1)
      {
        int v48 = v41[120];
        switch(v48)
        {
          case 32:
            if (v40 >= 4)
            {
              unint64_t v52 = v40 >> 2;
              unint64_t v53 = v18;
              uint64_t v54 = (unsigned int *)(v43 + 4 * v82);
              do
              {
                unsigned int v55 = *v53++;
                *uint64_t v54 = bswap32(v55) ^ v38;
                uint64_t v54 = (unsigned int *)((char *)v54 + v76);
                --v52;
              }
              while (v52);
            }
            break;
          case 16:
            if (v40 >= 2)
            {
              unint64_t v56 = v40 >> 1;
              uint64_t v57 = v18;
              unsigned int v58 = (_WORD *)(v43 + 2 * v82);
              do
              {
                unsigned int v59 = *(unsigned __int16 *)v57;
                uint64_t v57 = (unsigned int *)((char *)v57 + 2);
                *unsigned int v58 = v38 ^ (bswap32(v59) >> 16);
                unsigned int v58 = (_WORD *)((char *)v58 + v75);
                --v56;
              }
              while (v56);
            }
            break;
          case 8:
            int v49 = (unsigned char *)(v43 + v82);
            int v50 = v18;
            do
            {
              char v51 = *(unsigned char *)v50;
              int v50 = (unsigned int *)((char *)v50 + 1);
              *int v49 = v51 ^ v38;
              v49 += v29;
              --v40;
            }
            while (v40);
            break;
        }
        vImage_Buffer v6 = (IIODecodeFrameParams *)v83;
        goto LABEL_72;
      }
      unsigned int v44 = PSDReadPlugin::decode_packbits((PSDReadPlugin *)v41, (const unsigned __int8 *)v18, v26, v40, v42, 1, 0, v79, v35);
      if (v44)
      {
        unsigned int v77 = v44;
        vImage_Buffer v6 = (IIODecodeFrameParams *)v83;
        goto LABEL_105;
      }
      int v45 = v41[120];
      if (v45 == 32)
      {
        double v60 = v83[3];
        if (v60 > 0.0)
        {
          uint64_t v61 = 0;
          unsigned int v62 = (unsigned int *)(v43 + 4 * v82);
          do
          {
            *unsigned int v62 = bswap32(*(_DWORD *)&v26[4 * v61++]) ^ v38;
            unsigned int v62 = (unsigned int *)((char *)v62 + v76);
          }
          while (v60 > (double)(int)v61);
        }
      }
      else if (v45 == 16)
      {
        double v63 = v83[3];
        if (v63 > 0.0)
        {
          uint64_t v64 = 0;
          unint64_t v65 = (_WORD *)(v43 + 2 * v82);
          do
          {
            *unint64_t v65 = v38 ^ (bswap32(*(unsigned __int16 *)&v26[2 * v64++]) >> 16);
            unint64_t v65 = (_WORD *)((char *)v65 + v75);
          }
          while (v63 > (double)(int)v64);
        }
      }
      else if (v45 == 8 && v83[3] > 0.0)
      {
        uint64_t v46 = 0;
        uint64_t v47 = (unsigned char *)(v43 + v82);
        vImage_Buffer v6 = (IIODecodeFrameParams *)v83;
        do
        {
          *uint64_t v47 = v26[v46] ^ v38;
          v47 += v29;
          ++v46;
        }
        while (v83[3] > (double)(int)v46);
        unsigned int v77 = 0;
        goto LABEL_72;
      }
      unsigned int v77 = 0;
      vImage_Buffer v6 = (IIODecodeFrameParams *)v83;
LABEL_72:
      if (v28 <= ++v35) {
        unsigned int v28 = v35;
      }
      ++v37;
      this = v80;
      if (v74 - v7 == v37) {
        goto LABEL_84;
      }
    }
  }
  unsigned int v28 = 0;
  this = v80;
LABEL_87:
  if (*((_DWORD *)this + 81) == 1380401696)
  {
    a4 = v72;
    if (*((_DWORD *)this + 110) == 4 && *((unsigned char *)this + 278) == 5)
    {
      size_t v66 = *((void *)v6 + 6);
      dest.CFDictionaryRef data = (void *)*((void *)v6 + 5);
      int8x16_t v67 = (int8x16_t)vcvtq_u64_f64(*(float64x2_t *)((char *)v6 + 24));
      *(int8x16_t *)&dest.double height = vextq_s8(v67, v67, 8uLL);
      dest.rowunint64_t Bytes = v66;
      int v68 = *((unsigned __int16 *)this + 152);
      if (v68 == 8) {
        vImageOverwriteChannelsWithScalar_ARGB8888(0xFFu, &dest, &dest, 1u, 0x10u);
      }
      else {
        _cg_jpeg_mem_term("decodeBlock", 2405, "*** RGB-%d: check alpha-one?\n", v68);
      }
      this = v80;
    }
  }
  else
  {
    a4 = v72;
  }
LABEL_104:
  PSDReadPlugin::handlePremultiplication(this, v6, a4);
  unsigned int v77 = 0;
LABEL_105:
  *((void *)v6 + 8) = v28;
  if (v26) {
    free(v26);
  }
  uint64_t v69 = v77;
LABEL_108:
  uint64_t v70 = v69;
  if (v18)
  {
    free(v18);
    uint64_t v69 = v70;
  }
  if (v87)
  {
    free(v87);
    uint64_t v69 = v70;
  }
  if (v88)
  {
    free(v88);
    return v70;
  }
  return v69;
}

void sub_1887EB950(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C4050BC5624);
  _Unwind_Resume(a1);
}

uint64_t PSDReadPlugin::decodeBlockSubsampled(PSDReadPlugin *this, IIODecodeFrameParams *a2, int a3, unsigned int a4)
{
  double v6 = *((double *)a2 + 1);
  double v5 = *((double *)a2 + 2);
  double v7 = *((double *)a2 + 3);
  double v8 = *((double *)a2 + 4);
  int v9 = *((_DWORD *)this + 57);
  int v10 = *((unsigned __int16 *)this + 120);
  unint64_t v92 = 0;
  uint64_t v93 = 0;
  unint64_t v91 = 0;
  unint64_t v11 = *((unsigned __int16 *)this + 158);
  double v12 = (double)v11;
  double v13 = v7 * (double)v11;
  double v14 = v8 * (double)v11;
  uint64_t v15 = *((void *)a2 + 6);
  unint64_t v16 = v15 * v11;
  if ((0x1000000 / (v15 * v11) + v11 - 1) / v11 * v11 >= (unint64_t)v14) {
    unint64_t v17 = (unint64_t)v14;
  }
  else {
    unint64_t v17 = (0x1000000 / (v15 * v11) + v11 - 1) / v11 * v11;
  }
  memset(v90, 0, 48);
  unint64_t v74 = (unint64_t)v13;
  IIOSubsampler::IIOSubsampler((IIOSubsampler *)v90, (unint64_t)v13, v15 * v11, *((unsigned __int8 *)this + 310), *((_WORD *)this + 152), *((_WORD *)this + 154), v11, 0, v7, v15);
  unint64_t v18 = v17 * (unint64_t)v16;
  if ((v18 & 0xFFFFFFFF00000000) != 0) {
    goto LABEL_104;
  }
  __b = (unsigned __int8 *)malloc_type_calloc(v18, 1uLL, 0xC355889uLL);
  if (!__b)
  {
    _cg_jpeg_mem_term("decodeBlockSubsampled", 2526, "*** ERROR: failed to allocate 'bandBuffer'\n");
LABEL_104:
    uint64_t v53 = 4294967246;
    goto LABEL_98;
  }
  double v19 = v5 * v12;
  unint64_t v20 = (unint64_t)(v19 + v14);
  double v21 = (double)v17;
  if (!*((unsigned char *)this + 461))
  {
    unint64_t v26 = this;
    if (*((unsigned char *)this + 246)) {
      bzero(*((void **)a2 + 5), *((void *)a2 + 6) * (unint64_t)*((double *)a2 + 4));
    }
    if (*((_WORD *)this + 120) == 1 || (double v27 = (double)v20, v19 >= (double)v20))
    {
      uint64_t v35 = 0;
    }
    else
    {
      double v28 = v6 * v12;
      double v29 = (double)(unint64_t)v13;
      double v30 = (double)v17;
      do
      {
        vImage_Buffer src = 0;
        long long v88 = 0u;
        unint64_t src_8 = *(void *)&v28;
        unint64_t src_16 = *(void *)&v19;
        src_24.f64[0] = v29;
        src_24.f64[1] = v30;
        __int16 v85 = __b;
        size_t v86 = v16;
        unint64_t v87 = v16 * (unint64_t)v30;
        DWORD2(v88) = 0;
        uint64_t v89 = 0;
        PSDReadPlugin::mergeLayers(this, (IIODecodeFrameParams *)&src, (__n128)0);
        dest.CFDictionaryRef data = v85;
        int8x16_t v31 = (int8x16_t)vcvtq_u64_f64(src_24);
        *(int8x16_t *)&dest.double height = vextq_s8(v31, v31, 8uLL);
        dest.rowunint64_t Bytes = v86;
        if (*((unsigned char *)this + 404) == 1)
        {
          *(_DWORD *)permuteMap = 66051;
          vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
        }
        else if (v86 >= 4 * v31.i64[0])
        {
          *(_DWORD *)permuteMap = 197121;
          vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
        }
        else
        {
          __n128 v32 = _cg_jpeg_mem_term("decodeBlockSubsampled", 2708, "*** ERROR: vImagePermuteChannels_ARGB8888 - width: %d  rowBytes: %d\n", v31.i32[0], v86);
        }
        v32.n128_u16[0] = *((_WORD *)this + 158);
        double v33 = (double)v32.n128_u64[0];
        uint64_t v34 = (v19 / v33 - *((double *)a2 + 2));
        *(_DWORD *)permuteMap = (v30 / v33);
        IIOSubsampler::subsample((IIOSubsampler *)v90, __b, v30, (unsigned __int8 *)(*((void *)a2 + 5) + *((void *)a2 + 6) * v34), (unsigned int *)permuteMap);
        double v19 = v19 + v21;
        if (v30 + v19 > v27) {
          double v30 = v27 - v19;
        }
        IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)&src);
      }
      while (v19 < v27);
      uint64_t v35 = 0;
      unint64_t v26 = this;
    }
    goto LABEL_95;
  }
  unsigned int v22 = v9 * v10 + 7;
  size_t count = v22 >> 3;
  if (*((_WORD *)this + 229) == 1)
  {
    char v23 = PSDReadPlugin::readDataSizeTable(this, &v92, &v93, &v91);
    size_t v24 = v91;
    if (!v91) {
      char v23 = 0;
    }
    if ((v23 & 1) == 0) {
      goto LABEL_106;
    }
    malloc_type_id_t v25 = 2356552657;
  }
  else
  {
    if (v22 < 8)
    {
LABEL_106:
      uint64_t v35 = 0;
      goto LABEL_107;
    }
    malloc_type_id_t v25 = 3946758401;
    size_t v24 = v22 >> 3;
  }
  uint64_t v35 = (unsigned __int16 *)malloc_type_calloc(v24, 1uLL, v25);
  if (!v35)
  {
    _cg_jpeg_mem_term("decodeBlockSubsampled", 2545, "*** ERROR: failed to allocate 'scanLineData'\n");
    goto LABEL_106;
  }
  unint64_t v26 = this;
  if (*((_WORD *)this + 120) == 1)
  {
    if (malloc_type_calloc(v16, 1uLL, 0x15CA43CFuLL)) {
      operator new();
    }
    _cg_jpeg_mem_term("decodeBlockSubsampled", 2551, "*** ERROR: failed to allocate 'tempData'\n");
LABEL_107:
    free(__b);
    uint64_t v53 = 4294967246;
    if (!v35) {
      goto LABEL_98;
    }
LABEL_97:
    free(v35);
    goto LABEL_98;
  }
  double v37 = (double)v20;
  if (v19 < (double)v20)
  {
    double v38 = (double)v17;
    do
    {
      if (*((unsigned __int8 *)v26 + 278) - 5 <= 1) {
        memset(__b, 255, (unint64_t)(v38 * (double)v16));
      }
      if (a3)
      {
        unint64_t v39 = 0;
        v36.n128_f64[0] = v38 + (double)v19;
        unsigned int v71 = v36.n128_f64[0];
        unsigned int v75 = v36.n128_f64[0] - v19;
        do
        {
          unsigned int v40 = v39;
          if (v39 <= 3)
          {
            unsigned int v40 = v39;
            if (*((unsigned char *)v26 + 404) == 1) {
              unsigned int v40 = *((_DWORD *)&xmmword_1889AAEE0 + v39);
            }
          }
          int v41 = *((unsigned __int16 *)v26 + 228);
          int v44 = v41 == 4 && v40 < 4 || v41 == 0;
          if (*((_WORD *)v26 + 229) == 1) {
            unint64_t v45 = (*((_DWORD *)v26 + 58) * v39);
          }
          else {
            unint64_t v45 = *((void *)v26 + 24)
          }
                + count * (unint64_t)(*((_DWORD *)v26 + 58) * v39)
                + 2;
          unint64_t v77 = v45;
          if (v19 < v71)
          {
            uint64_t v46 = 0;
            int v47 = v44 << 31 >> 31;
            uint64_t v48 = v19;
            uint64_t v49 = v40;
            do
            {
              if (*((_WORD *)this + 229) == 1)
              {
                unint64_t v50 = v93[v77 + v48];
                unint64_t v51 = v92[v77 + v48];
              }
              else
              {
                unint64_t v51 = count;
                unint64_t v50 = v77 + v48 * count;
              }
              if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v35, v50, v51) != v51) {
                break;
              }
              unint64_t v52 = &__b[v16 * v46];
              if (*((_WORD *)this + 229) == 1)
              {
                uint64_t v53 = PSDReadPlugin::decode_packbits(this, (const unsigned __int8 *)v35, &v52[v49], v51, v16, a4, v47, v39, v48);
                if (v53) {
                  goto LABEL_96;
                }
              }
              else
              {
                int v54 = *((unsigned __int16 *)this + 120);
                switch(v54)
                {
                  case 32:
                    unint64_t v63 = v51 >> 2;
                    if (v51 >> 2 >= v74) {
                      unint64_t v63 = (unint64_t)v13;
                    }
                    if (v63)
                    {
                      uint64_t v64 = (unsigned int *)&v52[4 * v49];
                      unint64_t v65 = (unsigned int *)v35;
                      do
                      {
                        unsigned int v66 = *v65++;
                        unsigned int *v64 = bswap32(v66) ^ v47;
                        v64 += a4;
                        --v63;
                      }
                      while (v63);
                    }
                    break;
                  case 16:
                    unint64_t v59 = v51 >> 1;
                    if (v51 >> 1 >= v74) {
                      unint64_t v59 = (unint64_t)v13;
                    }
                    if (v59)
                    {
                      double v60 = &v52[2 * v49];
                      uint64_t v61 = v35;
                      do
                      {
                        unsigned int v62 = *v61++;
                        *(_WORD *)double v60 = v47 ^ (bswap32(v62) >> 16);
                        v60 += 2 * a4;
                        --v59;
                      }
                      while (v59);
                    }
                    break;
                  case 8:
                    unint64_t v55 = (unint64_t)v13;
                    if (v51 < v74) {
                      unint64_t v55 = v51;
                    }
                    if (v55)
                    {
                      unint64_t v56 = &v52[v49];
                      uint64_t v57 = (char *)v35;
                      do
                      {
                        char v58 = *v57++;
                        *unint64_t v56 = v58 ^ v47;
                        v56 += a4;
                        --v55;
                      }
                      while (v55);
                    }
                    break;
                }
              }
              ++v48;
              ++v46;
            }
            while (v75 != v46);
          }
          ++v39;
          unint64_t v26 = this;
        }
        while (v39 != a3);
      }
      if (*((_DWORD *)v26 + 81) == 1380401696 && *((_DWORD *)v26 + 110) == 4 && *((unsigned char *)v26 + 278) == 5)
      {
        vImage_Buffer src = __b;
        unint64_t src_8 = (unint64_t)v38;
        unint64_t src_16 = (unint64_t)v13;
        *(void *)&src_24.f64[0] = v16;
        if (*((_WORD *)v26 + 152) == 8) {
          vImageOverwriteChannelsWithScalar_ARGB8888(0xFFu, (const vImage_Buffer *)&src, (const vImage_Buffer *)&src, 1u, 0x10u);
        }
        else {
          __n128 v36 = _cg_jpeg_mem_term("decodeBlockSubsampled", 2667, "*** RGB-%d: check alpha-one?\n", *((unsigned __int16 *)v26 + 152));
        }
      }
      v36.n128_u16[0] = *((_WORD *)v26 + 158);
      double v67 = (double)v36.n128_u64[0];
      uint64_t v68 = (v19 / v67 - *((double *)a2 + 2));
      LODWORD(src) = (v38 / v67);
      IIOSubsampler::subsample((IIOSubsampler *)v90, __b, v38, (unsigned __int8 *)(*((void *)a2 + 5) + *((void *)a2 + 6) * v68), (unsigned int *)&src);
      double v19 = v19 + v21;
      v36.n128_f64[0] = v38 + v19;
      if (v38 + v19 > v37) {
        double v38 = v37 - v19;
      }
    }
    while (v19 < v37);
  }
LABEL_95:
  PSDReadPlugin::handlePremultiplication(v26, a2, a4);
  uint64_t v53 = 0;
LABEL_96:
  free(__b);
  if (v35) {
    goto LABEL_97;
  }
LABEL_98:
  if (v92) {
    free(v92);
  }
  if (v93) {
    free(v93);
  }
  IIOSubsampler::~IIOSubsampler((IIOSubsampler *)v90);
  return v53;
}

void sub_1887EC24C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  MEMORY[0x18C11C0E0](a25, 0x10F1C4050BC5624);
  IIOSubsampler::~IIOSubsampler((IIOSubsampler *)(v25 - 224));
  _Unwind_Resume(a1);
}

uint64_t PSDReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3)
{
  uint64_t v84 = 0;
  memory_object_size_t v85 = 0;
  uint64_t v82 = 0;
  uint64_t v83 = 0;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v7 = *((_DWORD *)this + 51);
    unsigned int v8 = v7 >> 24;
    uint64_t v9 = MEMORY[0x1E4F14390];
    if (v7 < 0)
    {
      int v10 = __maskrune(v8, 0x40000uLL);
      int v7 = *((_DWORD *)this + 51);
    }
    else
    {
      int v10 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v8 + 60) & 0x40000;
    }
    if (v10) {
      uint64_t v11 = (v7 >> 24);
    }
    else {
      uint64_t v11 = 46;
    }
    unsigned int v12 = v7 << 8 >> 24;
    if (v7 << 8 < 0)
    {
      int v13 = __maskrune(v12, 0x40000uLL);
      int v7 = *((_DWORD *)this + 51);
    }
    else
    {
      int v13 = *(_DWORD *)(v9 + 4 * v12 + 60) & 0x40000;
    }
    if (v13) {
      uint64_t v14 = (v7 << 8 >> 24);
    }
    else {
      uint64_t v14 = 46;
    }
    unsigned int v15 = (__int16)v7 >> 8;
    if (v7 << 16 < 0)
    {
      int v16 = __maskrune(v15, 0x40000uLL);
      int v7 = *((_DWORD *)this + 51);
    }
    else
    {
      int v16 = *(_DWORD *)(v9 + 4 * v15 + 60) & 0x40000;
    }
    if (v16) {
      uint64_t v17 = ((__int16)v7 >> 8);
    }
    else {
      uint64_t v17 = 46;
    }
    if ((v7 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v9 + 4 * (char)v7 + 60) & 0x40000) != 0) {
        goto LABEL_22;
      }
    }
    else if (__maskrune((char)v7, 0x40000uLL))
    {
LABEL_22:
      int v18 = *((_DWORD *)this + 51);
LABEL_25:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v11, v14, v17, (char)v18, iioTypeStr[a3], "virtual OSStatus PSDReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    LOBYTE(v18) = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  if (*((void *)this + 3))
  {
    uint64_t v19 = *((void *)this + 56);
    if (v19) {
      *((_DWORD *)this + 75) = v19;
    }
    else {
      *((void *)this + 56) = *((unsigned int *)this + 75);
    }
    if (*((unsigned char *)this + 406) || *((unsigned char *)this + 404) == 1) {
      *((unsigned char *)this + 460) = 1;
    }
    uint64_t v20 = *((unsigned int *)this + 28);
    uint64_t BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    if (IIOReadPlugin::getCachedBlocks(this, v22, v23, v24))
    {
      unint64_t v26 = (IIOImageRead **)*((void *)this + 3);
      if (v26) {
        BOOL v27 = IIOImageReadSession::mapData(v26);
      }
      else {
        BOOL v27 = 0;
      }
      if (*((_WORD *)this + 229) != 1 || (int v28 = *((unsigned __int16 *)this + 120), v28 == 8) || v28 == 1)
      {
        BOOL v75 = v27;
        unint64_t v29 = *((unsigned int *)this + 28);
        if (v29 >= *((_DWORD *)this + 29))
        {
LABEL_69:
          PSDReadPlugin::decodeBlocks((uint64_t)this, &v82);
          BOOL v27 = v75;
          unint64_t v65 = v82;
          unsigned int v66 = v83;
          if (v82 != v83)
          {
            while (1)
            {
              uint64_t BlockArray = *((unsigned int *)v65 + 18);
              if (BlockArray)
              {
                *(void *)&double v67 = _cg_jpeg_mem_term("decodeImageImp", 2848, "*** ERROR: (err=%d) when decoding block with index: %d\n", *((_DWORD *)v65 + 18), *(void *)v65).n128_u64[0];
                if (!*((void *)v65 + 8)) {
                  break;
                }
              }
              if (BlockArray) {
                BOOL v68 = 1;
              }
              else {
                BOOL v68 = *((unsigned char *)this + 343) == 0;
              }
              int v69 = !v68;
              *(void *)(*((void *)this + 12) + 8 * (*(void *)v65 - v20)) = IIOReadPlugin::createImageBlock(this, *((void **)v65 + 5), *((void *)v65 + 7), *(CGRect *)(v65 + 8), *((void *)v65 + 6), v69);
              *((void *)v65 + 5) = 0;
              v65 += 88;
              if (v65 == v66) {
                goto LABEL_79;
              }
            }
            _cg_jpeg_mem_term("decodeImageImp", 2849, "*** ERROR: no valid rows\n", v67);
          }
        }
        else
        {
          double v30 = (CGRect *)MEMORY[0x1E4F1DB20];
          while (1)
          {
            if (*(void *)(*((void *)this + 12) + 8 * (v29 - v20))) {
              _cg_jpeg_mem_term("decodeImageImp", 2812, "*** _blockArray[%d] was cached - and already allocated\n", v29 - v20);
            }
            unsigned int v31 = *((_DWORD *)this + 74);
            double v32 = (double)(v31 * v29);
            LODWORD(v3) = *((_DWORD *)this + 73);
            LODWORD(v25) = *((_DWORD *)this + 66);
            double v33 = (double)v25;
            double v34 = (double)v31 + v32 <= v33 ? (double)v31 : v33 - (double)(v31 * v29);
            memory_object_offset_t v35 = _ImageIO_Malloc(*((unsigned int *)this + 75) * (unint64_t)v31, *((void *)this + 48), &v85, (uint64_t)kImageMalloc_PSD_Data[0], *((_DWORD *)this + 108), 0, 0);
            if (!v35) {
              break;
            }
            double v3 = (double)*(unint64_t *)&v3;
            uint64_t v36 = *((unsigned int *)this + 75);
            long long v76 = v29;
            *(double *)&long long v77 = v32;
            *((double *)&v77 + 1) = v3;
            *(double *)&long long v78 = v34;
            *((void *)&v78 + 1) = v35;
            *(void *)&long long v79 = v36;
            *((void *)&v79 + 1) = v85;
            *(void *)&long long v80 = 0;
            DWORD2(v80) = 0;
            uint64_t v81 = 0;
            double v37 = v83;
            if (v83 >= v84)
            {
              uint64_t v43 = v82;
              uint64_t v44 = 0x2E8BA2E8BA2E8BA3 * ((v83 - v82) >> 3);
              unint64_t v45 = v44 + 1;
              if ((unint64_t)(v44 + 1) > 0x2E8BA2E8BA2E8BALL) {
                std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
              }
              if (0x5D1745D1745D1746 * ((v84 - v82) >> 3) > v45) {
                unint64_t v45 = 0x5D1745D1745D1746 * ((v84 - v82) >> 3);
              }
              if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((v84 - v82) >> 3)) >= 0x1745D1745D1745DLL) {
                unint64_t v46 = 0x2E8BA2E8BA2E8BALL;
              }
              else {
                unint64_t v46 = v45;
              }
              v86[4] = &v84;
              if (v46)
              {
                int v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIODecodeFrameParams>>((uint64_t)&v84, v46);
                uint64_t v43 = v82;
                double v37 = v83;
              }
              else
              {
                int v47 = 0;
              }
              uint64_t v48 = &v47[88 * v44];
              long long v49 = v77;
              *(_OWORD *)uint64_t v48 = v76;
              *((_OWORD *)v48 + 1) = v49;
              long long v50 = v78;
              long long v51 = v79;
              long long v52 = v80;
              *((void *)v48 + 10) = v81;
              *((_OWORD *)v48 + 3) = v51;
              *((_OWORD *)v48 + 4) = v52;
              *((_OWORD *)v48 + 2) = v50;
              if (v37 == (_OWORD *)v43)
              {
                unint64_t v55 = &v47[88 * v44];
              }
              else
              {
                uint64_t v53 = v37;
                int v54 = &v47[88 * v44];
                do
                {
                  unint64_t v55 = v54 - 88;
                  long long v56 = *(_OWORD *)((char *)v53 - 88);
                  *(_OWORD *)(v54 - 72) = *(_OWORD *)((char *)v53 - 72);
                  *(_OWORD *)(v54 - 88) = v56;
                  long long v57 = *(_OWORD *)((char *)v53 - 56);
                  long long v58 = *(_OWORD *)((char *)v53 - 40);
                  long long v59 = *(_OWORD *)((char *)v53 - 24);
                  *((void *)v54 - 1) = *((void *)v53 - 1);
                  *(_OWORD *)(v54 - 24) = v59;
                  *(_OWORD *)(v54 - 40) = v58;
                  *(_OWORD *)(v54 - 56) = v57;
                  uint64_t v53 = (_OWORD *)((char *)v53 - 88);
                  v54 -= 88;
                }
                while (v53 != (_OWORD *)v43);
              }
              uint64_t v42 = v48 + 88;
              uint64_t v82 = v55;
              uint64_t v83 = v48 + 88;
              double v60 = v84;
              uint64_t v84 = &v47[88 * v46];
              v86[2] = v37;
              v86[3] = v60;
              v86[0] = v43;
              v86[1] = v43;
              std::__split_buffer<IIODecodeFrameParams>::~__split_buffer((uint64_t)v86);
            }
            else
            {
              long long v38 = v77;
              *(_OWORD *)uint64_t v83 = v76;
              v37[1] = v38;
              long long v39 = v78;
              long long v40 = v79;
              long long v41 = v80;
              *((void *)v37 + 10) = v81;
              void v37[3] = v40;
              void v37[4] = v41;
              v37[2] = v39;
              uint64_t v42 = (char *)v37 + 88;
            }
            uint64_t v83 = v42;
            IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)&v76);
            BOOL v61 = CGRectEqualToRect(*(CGRect *)((char *)this + 120), *v30);
            uint64_t v62 = 0;
            if (!v61)
            {
              v87.origin.CGFloat x = 0.0;
              v87.origin.double y = v32;
              v87.size.double width = v3;
              v87.size.double height = v34;
              *(CGRect *)(&v25 - 2) = CGRectUnion(*(CGRect *)((char *)this + 120), v87);
              double v32 = v63;
              double v3 = *(double *)&v25;
              double v34 = v64;
            }
            *((void *)this + 15) = v62;
            *((double *)this + 16) = v32;
            *((double *)this + 17) = v3;
            *((double *)this + 18) = v34;
            if (++v29 >= *((unsigned int *)this + 29)) {
              goto LABEL_69;
            }
          }
          _cg_jpeg_mem_term("decodeImageImp", 2831, "*** ERROR: failed to allocate 'imageData'\n");
          BOOL v27 = v75;
        }
      }
    }
    else
    {
      BOOL v27 = 0;
    }
  }
  else
  {
    BOOL v27 = 0;
    uint64_t BlockArray = 0;
  }
LABEL_79:
  uint64_t v70 = v82;
  unsigned int v71 = v83;
  while (v70 != v71)
  {
    unint64_t v72 = *((void *)v70 + 5);
    if (v72) {
      _ImageIO_Free(v72, *((void *)v70 + 7));
    }
    v70 += 88;
  }
  if (v27)
  {
    uint64_t v73 = (const char **)*((void *)this + 3);
    if (v73) {
      IIOImageReadSession::unmapData(v73);
    }
  }
  *(void *)&long long v76 = &v82;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100]((void ***)&v76);
  return BlockArray;
}

void sub_1887EC8D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  a16 = (void **)&a27;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](&a16);
  _Unwind_Resume(a1);
}

void PSDReadPlugin::decodeBlocks(uint64_t a1, void *a2)
{
  uint64_t v4 = IIO_Reader::testHeaderSize(*(IIO_Reader **)(a1 + 24));
  uint64_t v5 = (uint64_t)(a2[1] - *a2) >> 3;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 0x40000000;
  block[2] = ___ZN13PSDReadPlugin12decodeBlocksERNSt3__16vectorI20IIODecodeFrameParamsNS0_9allocatorIS2_EEEE_block_invoke;
  block[3] = &__block_descriptor_tmp_55;
  block[4] = a1;
  void block[5] = a2;
  block[6] = v4;
  dispatch_apply(0x2E8BA2E8BA2E8BA3 * v5, 0, block);
}

void ___ZN13PSDReadPlugin12decodeBlocksERNSt3__16vectorI20IIODecodeFrameParamsNS0_9allocatorIS2_EEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = **(void **)(a1 + 40);
  double v6 = (IIODecodeFrameParams *)(v5 + 88 * a2);
  memset(v13, 0, sizeof(v13));
  IIOImageReadSession::IIOImageReadSession((IIOImageReadSession *)v13, *(IIOImageRead **)(a1 + 48));
  unsigned int v8 = *(unsigned __int16 *)(v4 + 244);
  if (*(_DWORD *)(v4 + 440) >= v8) {
    unsigned int v9 = *(unsigned __int16 *)(v4 + 244);
  }
  else {
    unsigned int v9 = *(_DWORD *)(v4 + 440);
  }
  if (*(unsigned __int16 *)(v4 + 316) < 2u) {
    int v10 = PSDReadPlugin::decodeBlock((PSDReadPlugin *)v4, v6, v9, v8, v7);
  }
  else {
    int v10 = PSDReadPlugin::decodeBlockSubsampled((PSDReadPlugin *)v4, v6, v9, v8);
  }
  unint64_t v11 = (unint64_t)*(double *)(v5 + 88 * a2 + 32);
  if (v10) {
    unint64_t v11 = 0;
  }
  uint64_t v12 = **(void **)(a1 + 40) + 88 * a2;
  *(void *)(v12 + 64) = v11;
  *(_DWORD *)(v12 + 72) = v10;
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)v13);
}

void sub_1887ECAA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

unint64_t IIOHashForDataProvider(CGDataProvider *a1, unint64_t a2)
{
  unint64_t SizeOfData = CGDataProviderGetSizeOfData();
  if (!CGAccessSessionCreate()) {
    return 0;
  }
  if (SizeOfData == -1
    || (BytePointer = (uint64_t *)CGAccessSessionGetBytePointer()) == 0
    || (unint64_t v5 = XXH64(BytePointer, SizeOfData, a2)) == 0)
  {
    CGAccessSessionRewind();
    double v6 = (char *)malloc_type_malloc(0xF4240uLL, 0xDE93F85uLL);
    State = XXH64_createState();
    XXH64_reset((uint64_t)State, a2);
    uint64_t Bytes = CGAccessSessionGetBytes();
    if (Bytes)
    {
      size_t v9 = Bytes;
      do
      {
        XXH64_update((uint64_t)State, v6, v9);
        size_t v9 = CGAccessSessionGetBytes();
      }
      while (v9);
    }
    unint64_t v5 = XXH64_digest(State);
    XXH64_freeState(State);
    free(v6);
  }
  CGAccessSessionRelease();
  return v5;
}

uint64_t TIFFJPEGIsFullStripRequired(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  bzero(v4, 0x550uLL);
  uint64_t v12 = a1;
  TIFFjpeg_create_decompress((uint64_t)v4);
  unint64_t v5 = &v6;
  __n128 v7 = std_init_source;
  unsigned int v8 = std_fill_input_buffer;
  size_t v9 = std_skip_input_data;
  int v10 = _cg_jpeg_resync_to_restart;
  unint64_t v11 = std_term_source;
  long long v6 = 0u;
  if (TIFFjpeg_read_header((uint64_t)v4, 1) == 1) {
    uint64_t has_multiple_scans = TIFFjpeg_has_multiple_scans((uint64_t)v4);
  }
  else {
    uint64_t has_multiple_scans = 0;
  }
  TIFFjpeg_destroy((uint64_t)v4);
  return has_multiple_scans;
}

uint64_t TIFFjpeg_create_decompress(uint64_t a1)
{
  *(void *)a1 = _cg_jpeg_std_error(a1 + 672);
  *(void *)(a1 + 672) = TIFFjpeg_error_exit;
  *(void *)(a1 + 688) = TIFFjpeg_output_message;
  *(void *)(a1 + 24) = 0;
  if (setjmp((int *)(a1 + 848))) {
    return 0;
  }
  _cg_jpeg_CreateDecompress((char *)a1, 90, 664);
  return 1;
}

uint64_t TIFFjpeg_read_header(uint64_t a1, int a2)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0xFFFFFFFFLL;
  }
  else {
    return _cg_jpeg_read_header(a1, a2);
  }
}

uint64_t TIFFjpeg_destroy(uint64_t a1)
{
  uint64_t result = setjmp((int *)(a1 + 848));
  if (!result) {
    return _cg_jpeg_destroy(a1);
  }
  return result;
}

uint64_t TIFFjpeg_has_multiple_scans(uint64_t a1)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0;
  }
  else {
    return _cg_jpeg_has_multiple_scans(a1);
  }
}

uint64_t TIFFInitJPEG(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 != 7) {
    TIFFInitJPEG_cold_1();
  }
  if (_TIFFMergeFields(a1, jpegFields, 4, a4, a5, a6, a7, a8))
  {
    unsigned int v15 = _TIFFmallocExt((void *)a1, 1360, v9, v10, v11, v12, v13, v14);
    *(void *)(a1 + 1096) = v15;
    if (v15)
    {
      _TIFFmemset(v15, 0, 0x550uLL);
      uint64_t v22 = *(void *)(a1 + 1096);
      *(void *)(v22 + 1280) = *(void *)(a1 + 1288);
      *(void *)(v22 + 1288) = *(void *)(a1 + 1280);
      *(void *)(v22 + 1296) = *(void *)(a1 + 1296);
      *(_OWORD *)(v22 + 1304) = *(_OWORD *)(a1 + 1080);
      *(void *)(v22 + 1168) = a1;
      *(void *)(v22 + 1320) = 0;
      *(_OWORD *)(v22 + 1328) = xmmword_1889AD970;
      *(_DWORD *)(v22 + 1344) = 0;
      *(void *)(a1 + 1288) = JPEGVGetField;
      *(void *)(a1 + 1280) = JPEGVSetField;
      *(void *)(a1 + 1296) = JPEGPrintDir;
      *(void *)(a1 + 952) = JPEGFixupTags;
      *(void *)(a1 + 960) = JPEGSetupDecode;
      *(void *)(a1 + 968) = JPEGPreDecode;
      *(void *)(a1 + 1008) = JPEGDecode;
      *(void *)(a1 + 1024) = JPEGDecode;
      *(void *)(a1 + 1040) = JPEGDecode;
      *(void *)(a1 + 976) = JPEGSetupEncode;
      *(void *)(a1 + 992) = JPEGPreEncode;
      *(void *)(a1 + 1000) = JPEGPostEncode;
      *(void *)(a1 + 1016) = JPEGEncode;
      *(void *)(a1 + 1032) = JPEGEncode;
      *(void *)(a1 + 1048) = JPEGEncode;
      *(void *)(a1 + 1072) = JPEGCleanup;
      *(void *)(a1 + 1080) = JPEGDefaultStripSize;
      *(void *)(a1 + 1088) = JPEGDefaultTileSize;
      *(_DWORD *)(a1 + 16) |= 0x100u;
      *(_DWORD *)(v22 + 664) = 0;
      if (*(void *)(a1 + 24)) {
        return 1;
      }
      *(_DWORD *)(v22 + 1328) = 2000;
      double v23 = _TIFFmallocExt((void *)a1, 2000, v16, v17, v18, v19, v20, v21);
      *(void *)(v22 + 1320) = v23;
      if (v23)
      {
        _TIFFmemset(v23, 0, 0x7D0uLL);
        return 1;
      }
      unint64_t v25 = "Failed to allocate memory for JPEG tables";
    }
    else
    {
      unint64_t v25 = "No space for JPEG state block";
    }
  }
  else
  {
    unint64_t v25 = "Merging JPEG codec-specific tags failed";
  }
  TIFFErrorExtR(a1, "TIFFInitJPEG", v25, v10, v11, v12, v13, v14, v26);
  return 0;
}

void TIFFjpeg_error_exit(uint64_t a1)
{
  uint64_t v8 = 0;
  memset(v7, 0, sizeof(v7));
  (*(void (**)(uint64_t, _OWORD *))(*(void *)a1 + 24))(a1, v7);
  TIFFErrorExtR(*(void *)(a1 + 1168), "JPEGLib", "%s", v2, v3, v4, v5, v6, (char)v7);
  _cg_jpeg_abort(a1);
  longjmp((int *)(a1 + 848), 1);
}

uint64_t TIFFjpeg_output_message(uint64_t *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  (*(void (**)(uint64_t *, _OWORD *))(*a1 + 24))(a1, v8);
  return TIFFWarningExtR(a1[146], "JPEGLib", "%s", v2, v3, v4, v5, v6, (char)v8);
}

void *std_init_source(void *result)
{
  uint64_t v1 = result[146];
  result[139] = *(void *)(v1 + 1120);
  result[140] = *(void *)(v1 + 1160);
  return result;
}

uint64_t std_fill_input_buffer(uint64_t *a1)
{
  uint64_t v2 = *a1;
  *(_DWORD *)(v2 + 40) = 123;
  (*(void (**)(uint64_t *, uint64_t))(v2 + 8))(a1, 0xFFFFFFFFLL);
  a1[139] = (uint64_t)&std_fill_input_buffer_dummy_EOI;
  a1[140] = 2;
  return 1;
}

void *std_skip_input_data(void *result, uint64_t a2)
{
  if (a2 >= 1)
  {
    uint64_t v2 = result;
    unint64_t v3 = result[140];
    BOOL v4 = v3 >= a2;
    uint64_t v5 = v3 - a2;
    if (v4)
    {
      result[139] += a2;
    }
    else
    {
      uint64_t v6 = *result;
      *(_DWORD *)(v6 + 40) = 123;
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t))(v6 + 8))(result, 0xFFFFFFFFLL);
      v2[139] = &std_fill_input_buffer_dummy_EOI;
      uint64_t v5 = 2;
    }
    v2[140] = v5;
  }
  return result;
}

uint64_t JPEGVGetField(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 1096);
  if (!v3) {
    JPEGVGetField_cold_1();
  }
  if (a2 > 65537)
  {
    if (a2 == 65538)
    {
      int v4 = *(_DWORD *)(v3 + 1336);
      goto LABEL_11;
    }
    if (a2 == 65539)
    {
      int v4 = *(_DWORD *)(v3 + 1340);
      goto LABEL_11;
    }
  }
  else
  {
    if (a2 == 347)
    {
      **(_DWORD **)a3 = *(_DWORD *)(v3 + 1328);
      **(void **)(a3 + 8) = *(void *)(v3 + 1320);
      return 1;
    }
    if (a2 == 65537)
    {
      int v4 = *(_DWORD *)(v3 + 1332);
LABEL_11:
      **(_DWORD **)a3 = v4;
      return 1;
    }
  }
  uint64_t v6 = *(uint64_t (**)(void))(v3 + 1280);

  return v6();
}

uint64_t JPEGVSetField(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 1096);
  if (!v8) {
    JPEGVSetField_cold_1();
  }
  if ((int)a2 > 0x10000)
  {
    switch(a2)
    {
      case 0x10001:
        *(_DWORD *)(v8 + 1332) = *(_DWORD *)a3;
        break;
      case 0x10002:
        *(_DWORD *)(v8 + 1336) = *(_DWORD *)a3;
        JPEGResetUpsampled(a1, a2, a3, a4, a5, a6, a7, a8);
        break;
      case 0x10003:
        *(_DWORD *)(v8 + 1340) = *(_DWORD *)a3;
        break;
      default:
LABEL_11:
        uint64_t v10 = *(uint64_t (**)(void))(v8 + 1288);
        return v10();
    }
    return 1;
  }
  if (a2 == 262)
  {
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(v8 + 1288))(a1);
    JPEGResetUpsampled(a1, v13, v14, v15, v16, v17, v18, v19);
    return v12;
  }
  if (a2 != 347)
  {
    if (a2 == 530) {
      *(_DWORD *)(v8 + 1344) = 1;
    }
    goto LABEL_11;
  }
  unsigned int v20 = *(_DWORD *)a3;
  if (!*(_DWORD *)a3) {
    return 0;
  }
  _TIFFsetByteArrayExt((void *)a1, (char **)(v8 + 1320), *(const void **)(a3 + 8), v20, a5, a6, a7, a8);
  *(_DWORD *)(v8 + 1328) = v20;
  *(_DWORD *)(a1 + 80) |= 4u;
  uint64_t result = (uint64_t)TIFFFieldWithTag((void *)a1, 347);
  if (result)
  {
    unint64_t v21 = *(unsigned __int16 *)(result + 24);
    uint64_t result = 1;
    *(_DWORD *)(a1 + ((v21 >> 3) & 0x1FFC) + 72) |= 1 << v21;
    *(_DWORD *)(a1 + 16) |= 8u;
  }
  return result;
}

uint64_t JPEGPrintDir(uint64_t result, FILE *a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 1096);
  if (!v3) {
    JPEGPrintDir_cold_1();
  }
  uint64_t v6 = result;
  if ((*(unsigned char *)(result + 80) & 4) != 0) {
    uint64_t result = fprintf(a2, "  JPEG Tables: (%u bytes)\n", *(_DWORD *)(v3 + 1328));
  }
  __n128 v7 = *(uint64_t (**)(uint64_t, FILE *, uint64_t))(v3 + 1296);
  if (v7)
  {
    return v7(v6, a2, a3);
  }
  return result;
}

uint64_t JPEGFixupTags(uint64_t a1)
{
  if (*(_WORD *)(a1 + 122) == 6
    && *(_WORD *)(a1 + 170) == 1
    && *(_WORD *)(a1 + 130) == 3
    && !*(_DWORD *)(*(void *)(a1 + 1096) + 1344))
  {
    uint64_t v3 = TIFFGetStrileOffset(a1, 0);
    if (v3)
    {
      uint64_t v10 = v3;
      long long v40 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      uint64_t v36 = a1;
      LODWORD(v38) = 2048;
      double v37 = _TIFFmallocExt((void *)a1, 2048, v4, v5, v6, v7, v8, v9);
      if (v37)
      {
        *((void *)&v38 + 1) = 0;
        LODWORD(v39) = 0;
        *((void *)&v39 + 1) = v10;
        BYTE8(v40) = 0;
        *(void *)&long long v40 = TIFFGetStrileByteCount(a1, 0);
        unsigned __int8 v43 = 0;
        while (JPEGFixupTagsSubsamplingReadByte((uint64_t)&v36, &v43))
        {
          if (v43 == 255)
          {
LABEL_11:
            if (JPEGFixupTagsSubsamplingReadByte((uint64_t)&v36, &v43))
            {
              switch(v43)
              {
                case 0xC0u:
                case 0xC1u:
                case 0xC2u:
                case 0xC9u:
                case 0xCAu:
                  unsigned __int16 v42 = 0;
                  unsigned __int8 v41 = 0;
                  if (!JPEGFixupTagsSubsamplingReadWord((uint64_t)&v36, &v42)
                    || 3 * *(unsigned __int16 *)(v36 + 130) + 8 != v42)
                  {
                    goto LABEL_57;
                  }
                  if (v39 >= 7)
                  {
                    *((void *)&v38 + 1) += 7;
                    LODWORD(v39) = v39 - 7;
                  }
                  else
                  {
                    unint64_t v23 = 7 - v39;
                    LODWORD(v39) = 0;
                    if ((unint64_t)v40 >= v23)
                    {
                      *((void *)&v39 + 1) += v23;
                      *(void *)&long long v40 = v40 - v23;
                      BYTE8(v40) = 0;
                    }
                    else
                    {
                      *(void *)&long long v40 = 0;
                    }
                  }
                  if (!JPEGFixupTagsSubsamplingReadByte((uint64_t)&v36, &v41)) {
                    goto LABEL_57;
                  }
                  if (v39)
                  {
                    ++*((void *)&v38 + 1);
                    int v24 = v39 - 1;
                  }
                  else
                  {
                    int v24 = 0;
                    if ((void)v40)
                    {
                      ++*((void *)&v39 + 1);
                      *(void *)&long long v40 = v40 - 1;
                      BYTE8(v40) = 0;
                    }
                    else
                    {
                      *(void *)&long long v40 = 0;
                    }
                  }
                  unsigned int v25 = v41;
                  uint64_t v26 = v36;
                  if (*(unsigned __int16 *)(v36 + 130) < 2u) {
                    goto LABEL_50;
                  }
                  unsigned int v27 = 1;
                  break;
                case 0xC4u:
                case 0xDAu:
                case 0xDBu:
                case 0xDDu:
                case 0xE0u:
                case 0xE1u:
                case 0xE2u:
                case 0xE3u:
                case 0xE4u:
                case 0xE5u:
                case 0xE6u:
                case 0xE7u:
                case 0xE8u:
                case 0xE9u:
                case 0xEAu:
                case 0xEBu:
                case 0xECu:
                case 0xEDu:
                case 0xEEu:
                case 0xEFu:
                case 0xFEu:
                  unsigned __int16 v42 = 0;
                  if (!JPEGFixupTagsSubsamplingReadWord((uint64_t)&v36, &v42)) {
                    goto LABEL_57;
                  }
                  unsigned __int16 v21 = v42 - 2;
                  if (v42 < 2u) {
                    goto LABEL_57;
                  }
                  if (v42 != 2)
                  {
                    if (v39 >= v21)
                    {
                      *((void *)&v38 + 1) += v21;
                      LODWORD(v39) = v39 - (unsigned __int16)(v42 - 2);
                    }
                    else
                    {
                      unsigned __int16 v22 = v21 - v39;
                      LODWORD(v39) = 0;
                      if ((unint64_t)v40 >= v22)
                      {
                        *((void *)&v39 + 1) += v22;
                        *(void *)&long long v40 = v40 - v22;
                        BYTE8(v40) = 0;
                      }
                      else
                      {
                        *(void *)&long long v40 = 0;
                      }
                    }
                  }
                  continue;
                case 0xD8u:
                  continue;
                case 0xFFu:
                  goto LABEL_11;
                default:
                  goto LABEL_57;
              }
              while (1)
              {
                if (v24)
                {
                  ++*((void *)&v38 + 1);
                  LODWORD(v39) = v24 - 1;
                }
                else
                {
                  LODWORD(v39) = 0;
                  if ((void)v40)
                  {
                    ++*((void *)&v39 + 1);
                    *(void *)&long long v40 = v40 - 1;
                    BYTE8(v40) = 0;
                  }
                  else
                  {
                    *(void *)&long long v40 = 0;
                  }
                }
                if (!JPEGFixupTagsSubsamplingReadByte((uint64_t)&v36, &v41)) {
                  goto LABEL_57;
                }
                if (v41 != 17) {
                  break;
                }
                if (v39)
                {
                  ++*((void *)&v38 + 1);
                  int v24 = v39 - 1;
                  LODWORD(v39) = v39 - 1;
                }
                else
                {
                  LODWORD(v39) = 0;
                  int v24 = 0;
                  if ((void)v40)
                  {
                    ++*((void *)&v39 + 1);
                    *(void *)&long long v40 = v40 - 1;
                    BYTE8(v40) = 0;
                  }
                  else
                  {
                    *(void *)&long long v40 = 0;
                  }
                }
                ++v27;
                uint64_t v26 = v36;
                if (v27 >= *(unsigned __int16 *)(v36 + 130))
                {
LABEL_50:
                  unsigned int v28 = v25 >> 4;
                  if (v25 >> 4 <= 4 && ((1 << v28) & 0x16) != 0)
                  {
                    unsigned int v29 = v25 & 0xF;
                    if (v29 <= 4 && ((1 << v29) & 0x16) != 0)
                    {
                      int v30 = *(unsigned __int16 *)(v26 + 336);
                      if (v30 != v28 || *(unsigned __int16 *)(v26 + 338) != v29)
                      {
                        uint64_t v31 = v26;
                        __int16 v32 = v29;
                        TIFFWarningExtR(v26, "JPEGFixupTagsSubsamplingSec", "Auto-corrected former TIFF subsampling values [%hu,%hu] to match subsampling values inside JPEG compressed data [%hhu,%hhu]", v16, v17, v18, v19, v20, v30);
                        *(_WORD *)(v31 + 336) = v28;
                        *(_WORD *)(v31 + 338) = v32;
                      }
                      goto LABEL_59;
                    }
                  }
LABEL_61:
                  double v33 = "JPEGFixupTagsSubsamplingSec";
                  double v34 = "Subsampling values inside JPEG compressed data have no TIFF equivalent, auto-correction of TIFF "
                        "subsampling values failed";
                  goto LABEL_58;
                }
              }
              uint64_t v26 = v36;
              goto LABEL_61;
            }
            break;
          }
        }
LABEL_57:
        double v33 = "JPEGFixupTagsSubsampling";
        double v34 = "Unable to auto-correct subsampling values, likely corrupt JPEG compressed data in first strip/tile; auto-c"
              "orrecting skipped";
        uint64_t v26 = a1;
LABEL_58:
        TIFFWarningExtR(v26, v33, v34, v16, v17, v18, v19, v20, v35);
LABEL_59:
        _TIFFfreeExt(a1, (char *)v37);
      }
      else
      {
        TIFFWarningExtR(a1, "JPEGFixupTagsSubsampling", "Unable to allocate memory for auto-correcting of subsampling values; auto-correcting skipped",
          v11,
          v12,
          v13,
          v14,
          v15,
          v35);
      }
    }
  }
  return 1;
}

uint64_t JPEGSetupDecode(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 1096);
  JPEGInitializeLibJPEG(a1, 1);
  if (!v2) {
    JPEGSetupDecode_cold_1();
  }
  if (!*(_DWORD *)(v2 + 32)) {
    JPEGSetupDecode_cold_2();
  }
  if ((*(unsigned char *)(a1 + 80) & 4) != 0
    && (*(void *)(v2 + 40) = v2 + 1112,
        *(void *)(v2 + 1136) = std_fill_input_buffer,
        *(void *)(v2 + 1144) = std_skip_input_data,
        *(void *)(v2 + 1152) = _cg_jpeg_resync_to_restart,
        *(void *)(v2 + 1160) = std_term_source,
        *(_OWORD *)(v2 + 1112) = 0u,
        *(void *)(v2 + 1128) = tables_init_source,
        TIFFjpeg_read_header(v2, 0) != 2))
  {
    TIFFErrorExtR(a1, "JPEGSetupDecode", "Bogus JPEGTables field", v3, v4, v5, v6, v7, v11);
    return 0;
  }
  else
  {
    int v8 = *(unsigned __int16 *)(a1 + 122);
    *(_WORD *)(v2 + 1176) = v8;
    if (v8 == 6)
    {
      *(_WORD *)(v2 + 1178) = *(_WORD *)(a1 + 336);
      __int16 v9 = *(_WORD *)(a1 + 338);
    }
    else
    {
      __int16 v9 = 1;
      *(_WORD *)(v2 + 1178) = 1;
    }
    *(_WORD *)(v2 + 1180) = v9;
    *(void *)(v2 + 40) = v2 + 1112;
    *(void *)(v2 + 1128) = std_init_source;
    *(void *)(v2 + 1136) = std_fill_input_buffer;
    *(void *)(v2 + 1144) = std_skip_input_data;
    *(void *)(v2 + 1152) = _cg_jpeg_resync_to_restart;
    *(void *)(v2 + 1160) = std_term_source;
    *(_OWORD *)(v2 + 1112) = 0u;
    *(void *)(a1 + 1248) = _TIFFNoPostDecode;
    return 1;
  }
}

uint64_t JPEGPreDecode(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 1096);
  if (!v2) {
    JPEGPreDecode_cold_1();
  }
  if (!*(_DWORD *)(v2 + 32))
  {
    (*(void (**)(uint64_t))(a1 + 960))(a1);
    if (!*(_DWORD *)(v2 + 32)) {
      JPEGPreDecode_cold_2();
    }
  }
  uint64_t result = TIFFjpeg_abort(v2);
  if (result)
  {
    if (TIFFjpeg_read_header(v2, 1) == 1)
    {
      *(void *)(a1 + 1152) = *(void *)(v2 + 1112);
      *(void *)(a1 + 1160) = *(void *)(v2 + 1120);
      if ((*(unsigned char *)(a1 + 17) & 4) != 0)
      {
        unsigned int v13 = *(_DWORD *)(a1 + 100);
        unsigned int v14 = *(_DWORD *)(a1 + 104);
        uint64_t v15 = _cg_TIFFTileRowSize(a1, v6, v7, v8, v9, v10, v11, v12);
      }
      else
      {
        unsigned int v13 = *(_DWORD *)(a1 + 88);
        if ((*(_DWORD *)(a1 + 92) - *(_DWORD *)(a1 + 876)) >= *(_DWORD *)(a1 + 132)) {
          unsigned int v14 = *(_DWORD *)(a1 + 132);
        }
        else {
          unsigned int v14 = *(_DWORD *)(a1 + 92) - *(_DWORD *)(a1 + 876);
        }
        uint64_t v15 = _cg_TIFFScanlineSize(a1, v6, v7, v8, v9, v10, v11, v12);
      }
      *(void *)(v2 + 1184) = v15;
      if (a2 && *(_WORD *)(a1 + 170) == 2)
      {
        unsigned int v21 = *(unsigned __int16 *)(v2 + 1178);
        if (!*(_WORD *)(v2 + 1178) || (unsigned int v22 = *(unsigned __int16 *)(v2 + 1180), !*(_WORD *)(v2 + 1180)))
        {
          uint64_t v26 = "JPEG horizontal or vertical sampling is zero";
          goto LABEL_81;
        }
        unsigned int v23 = 0;
        if (v13 < -v21) {
          unsigned int v23 = (v13 + v21 - 1) / v21;
        }
        if (v14 >= -v22) {
          unsigned int v14 = 0;
        }
        else {
          unsigned int v14 = (v14 + v22 - 1) / v22;
        }
      }
      else
      {
        unsigned int v23 = v13;
      }
      unsigned int v24 = *(_DWORD *)(v2 + 48);
      if (v24 < v23 || *(_DWORD *)(v2 + 52) < v14)
      {
        TIFFWarningExtR(a1, "JPEGPreDecode", "Improper JPEG strip/tile size, expected %ux%u, got %ux%u", v16, v17, v18, v19, v20, v23);
        unsigned int v24 = *(_DWORD *)(v2 + 48);
      }
      if (v24 == v23
        && *(_DWORD *)(v2 + 52) > v14
        && *(_DWORD *)(a1 + 876) + v14 == *(_DWORD *)(a1 + 92)
        && (*(unsigned char *)(a1 + 17) & 4) == 0)
      {
        TIFFWarningExtR(a1, "JPEGPreDecode", "JPEG strip size exceeds expected dimensions, expected %ux%u, got %ux%u", v16, v17, v18, v19, v20, v23);
LABEL_31:
        if (*(_WORD *)(a1 + 170) == 1) {
          int v25 = *(unsigned __int16 *)(a1 + 130);
        }
        else {
          int v25 = 1;
        }
        if (*(_DWORD *)(v2 + 56) == v25)
        {
          if (*(_DWORD *)(v2 + 296) == *(unsigned __int16 *)(a1 + 116))
          {
            if (*(_DWORD *)(v2 + 316) && !*(_DWORD *)(v2 + 1352))
            {
              TIFFWarningExtR(a1, "JPEGPreDecode", "The JPEG strip/tile is encoded with progressive mode, which is normally not legal for JPEG-in-TIFF.\nlibtiff should be able to decode it, but it might cause compatibility issues with other readers", v16, v17, v18, v19, v20, v45);
              *(_DWORD *)(v2 + 1352) = 1;
            }
            if (TIFFjpeg_has_multiple_scans(v2))
            {
              uint64_t v27 = *(unsigned int *)(v2 + 56);
              if ((int)v27 < 1)
              {
                unint64_t v29 = 0x100000;
              }
              else
              {
                unsigned int v28 = (_DWORD *)(*(void *)(v2 + 304) + 32);
                unint64_t v29 = 0x100000;
                do
                {
                  int v30 = *(v28 - 6);
                  if (v30 >= 1)
                  {
                    int v31 = *(v28 - 5);
                    if (v31 >= 1) {
                      v29 += ((v30 + *(v28 - 1) - 1)
                    }
                            / v30
                            * (unint64_t)((v31 + *v28 - 1) / v31)) << 7;
                  }
                  v28 += 24;
                  --v27;
                }
                while (v27);
              }
              uint64_t v32 = *(void *)(*(void *)(v2 + 8) + 88);
              BOOL v33 = v32 >= 1 && v29 > v32;
              if (v33 && !getenv("LIBTIFF_ALLOW_LARGE_LIBJPEG_MEM_ALLOC"))
              {
                char v45 = v29;
                uint64_t v26 = "Reading this image would require libjpeg to allocate at least %llu bytes. This is disabled since a"
                      "bove the %ld threshold. You may override this restriction by defining the LIBTIFF_ALLOW_LARGE_LIBJ"
                      "PEG_MEM_ALLOC environment variable, or setting the JPEGMEM environment variable to a value greater"
                      " or equal to '%lluM'";
                goto LABEL_81;
              }
            }
            double v34 = *(_DWORD **)(v2 + 304);
            int v35 = v34[2];
            if (*(_WORD *)(a1 + 170) == 1)
            {
              if (v35 != *(unsigned __int16 *)(v2 + 1178) || v34[3] != *(unsigned __int16 *)(v2 + 1180))
              {
                TIFFErrorExtR(a1, "JPEGPreDecode", "Improper JPEG sampling factors %d,%d\nApparently should be %hu,%hu.", v16, v17, v18, v19, v20, v35);
                return 0;
              }
              uint64_t v37 = *(unsigned int *)(v2 + 56);
              if ((int)v37 >= 2)
              {
                long long v38 = v34 + 27;
                uint64_t v39 = v37 - 1;
                while (*(v38 - 1) == 1 && *v38 == 1)
                {
                  v38 += 24;
                  if (!--v39) {
                    goto LABEL_73;
                  }
                }
                goto LABEL_67;
              }
LABEL_73:
              if (*(_WORD *)(v2 + 1176) == 6 && *(_DWORD *)(v2 + 1336) == 1)
              {
                *(void *)(v2 + 60) = 0x200000003;
                goto LABEL_79;
              }
            }
            else if (v35 != 1 || v34[3] != 1)
            {
LABEL_67:
              uint64_t v26 = "Improper JPEG sampling factors";
              goto LABEL_81;
            }
            *(_DWORD *)(v2 + 60) = 0;
            *(_DWORD *)(v2 + 64) = 0;
            if (*(_WORD *)(a1 + 170) == 1 && (*(_WORD *)(v2 + 1178) != 1 || *(_WORD *)(v2 + 1180) != 1))
            {
              char v41 = 0;
              *(_DWORD *)(v2 + 92) = 1;
              long long v40 = (_DWORD *)(v2 + 100);
              unsigned __int8 v43 = JPEGDecodeRaw;
              unsigned __int16 v42 = DecodeRowError;
              goto LABEL_85;
            }
LABEL_79:
            long long v40 = (_DWORD *)(v2 + 92);
            char v41 = 1;
            unsigned __int16 v42 = JPEGDecode;
            unsigned __int8 v43 = JPEGDecode;
LABEL_85:
            *long long v40 = 0;
            *(void *)(a1 + 1008) = v42;
            *(void *)(a1 + 1024) = v43;
            *(void *)(a1 + 1040) = v43;
            int started = TIFFjpeg_start_decompress(v2);
            uint64_t result = started != 0;
            if ((v41 & 1) == 0 && started)
            {
              uint64_t result = alloc_downsampled_buffers(a1, *(void *)(v2 + 304), *(_DWORD *)(v2 + 56));
              if (result)
              {
                *(_DWORD *)(v2 + 1272) = 8;
                return 1;
              }
            }
            return result;
          }
          uint64_t v26 = "Improper JPEG data precision";
        }
        else
        {
          uint64_t v26 = "Improper JPEG component count";
        }
LABEL_81:
        TIFFErrorExtR(a1, "JPEGPreDecode", v26, v16, v17, v18, v19, v20, v45);
        return 0;
      }
      if (v24 <= v23 && *(_DWORD *)(v2 + 52) <= v14) {
        goto LABEL_31;
      }
      TIFFErrorExtR(a1, "JPEGPreDecode", "JPEG strip/tile size exceeds expected dimensions, expected %ux%u, got %ux%u", v16, v17, v18, v19, v20, v23);
    }
    return 0;
  }
  return result;
}

BOOL JPEGDecode(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  size_t v8 = a3;
  uint64_t v10 = *(void *)(a1 + 1096);
  *(void *)(v10 + 1112) = *(void *)(a1 + 1152);
  *(void *)(v10 + 1120) = *(void *)(a1 + 1160);
  uint64_t v11 = *(void *)(v10 + 1184);
  if (!v11)
  {
LABEL_12:
    bzero(a2, v8);
    return 0;
  }
  uint64_t v13 = a3 / v11;
  if (a3 % v11) {
    TIFFWarningExtR(a1, *(const char **)a1, "fractional scanline not read", a4, a5, a6, a7, a8, v18);
  }
  uint64_t v14 = *(unsigned int *)(v10 + 52);
  if (v13 < v14) {
    uint64_t v14 = v13;
  }
  if (v14)
  {
    uint64_t v15 = v14 + 1;
    do
    {
      uint64_t v19 = a2;
      if (TIFFjpeg_read_scanlines(v10, (uint64_t)&v19) != 1) {
        goto LABEL_12;
      }
      ++*(_DWORD *)(a1 + 876);
      uint64_t v16 = *(void *)(v10 + 1184);
      a2 += v16;
      v8 -= v16;
    }
    while (--v15 > 1);
  }
  *(void *)(a1 + 1152) = *(void *)(v10 + 1112);
  *(void *)(a1 + 1160) = *(void *)(v10 + 1120);
  return *(_DWORD *)(v10 + 168) < *(_DWORD *)(v10 + 140) || TIFFjpeg_finish_decompress(v10) != 0;
}

uint64_t JPEGSetupEncode(uint64_t a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 1096);
  JPEGInitializeLibJPEG(a1, 0);
  if (!v2) {
    JPEGSetupEncode_cold_1();
  }
  if (*(_DWORD *)(v2 + 32)) {
    JPEGSetupEncode_cold_2();
  }
  int v3 = *(unsigned __int16 *)(a1 + 122);
  *(_WORD *)(v2 + 1176) = v3;
  if (*(_WORD *)(a1 + 170) != 1)
  {
    *(void *)(v2 + 56) = 1;
    goto LABEL_19;
  }
  *(_DWORD *)(v2 + 56) = *(unsigned __int16 *)(a1 + 130);
  if (v3 == 6)
  {
    if (*(_DWORD *)(v2 + 1336) != 1)
    {
      int v4 = 3;
      goto LABEL_12;
    }
    goto LABEL_6;
  }
  unsigned int v5 = *(unsigned __int16 *)(a1 + 122);
  if (v5 > 1)
  {
    if (v5 == 5)
    {
      int v4 = *(unsigned __int16 *)(a1 + 130);
      if (v4 == 4) {
        goto LABEL_12;
      }
    }
    else if (v5 == 2 && *(_WORD *)(a1 + 130) == 3)
    {
LABEL_6:
      int v4 = 2;
LABEL_12:
      *(_DWORD *)(v2 + 60) = v4;
      goto LABEL_19;
    }
  }
  else
  {
    int v4 = *(unsigned __int16 *)(a1 + 130);
    if (v4 == 1) {
      goto LABEL_12;
    }
  }
  *(_DWORD *)(v2 + 60) = 0;
LABEL_19:
  uint64_t result = TIFFjpeg_set_defaults(v2);
  if (!result) {
    return result;
  }
  if (*(_DWORD *)(v2 + 272) && (*(unsigned char *)(v2 + 1340) & 2) != 0)
  {
    TIFFWarningExtR(a1, "JPEGSetupEncode", "mozjpeg library likely detected. Disable emission of Huffman tables in JpegTables tag, and use optimize_coding to avoid potential issues", v8, v9, v10, v11, v12, v24);
    *(_DWORD *)(v2 + 1340) &= ~2u;
  }
  *(_DWORD *)(v2 + 272) = 0;
  *(void *)(v2 + 280) = 0;
  int v13 = *(unsigned __int16 *)(v2 + 1176);
  if ((v13 - 3) < 2)
  {
    TIFFErrorExtR(a1, "JPEGSetupEncode", "PhotometricInterpretation %hu not allowed for JPEG", v8, v9, v10, v11, v12, *(_WORD *)(v2 + 1176));
    return 0;
  }
  if (v13 == 6)
  {
    int v14 = *(unsigned __int16 *)(a1 + 336);
    *(_WORD *)(v2 + 1178) = v14;
    int v15 = *(unsigned __int16 *)(a1 + 338);
    *(_WORD *)(v2 + 1180) = v15;
    if (!v14 || !v15)
    {
      uint64_t v20 = "Invalig horizontal/vertical sampling value";
      goto LABEL_43;
    }
    unsigned int v16 = *(unsigned __int16 *)(a1 + 116);
    if (v16 >= 0x11)
    {
LABEL_37:
      TIFFErrorExtR(a1, "JPEGSetupEncode", "BitsPerSample %hu not allowed for JPEG", v8, v9, v10, v11, v12, v16);
      return 0;
    }
    uint64_t v25 = 0;
    if (!_cg_TIFFGetField((void *)a1, 532, v7, v8, v9, v10, v11, v12, (uint64_t)&v25))
    {
      uint64_t v18 = 1 << *(_WORD *)(a1 + 116);
      int v26 = 0;
      float v27 = (float)(v18 - 1);
      float v28 = (float)(v18 >> 1);
      float v29 = v27;
      float v30 = v28;
      float v31 = v27;
      _cg_TIFFSetField(a1, 532, v17, v8, v9, v10, v11, v12, (uint64_t)&v26);
    }
  }
  else
  {
    *(_DWORD *)(v2 + 1178) = 65537;
  }
  unsigned int v16 = *(unsigned __int16 *)(a1 + 116);
  if (v16 != 8) {
    goto LABEL_37;
  }
  *(_DWORD *)(v2 + 88) = 8;
  if ((*(unsigned char *)(a1 + 17) & 4) != 0)
  {
    if (*(_DWORD *)(a1 + 104) % (8 * *(unsigned __int16 *)(v2 + 1180)))
    {
      TIFFErrorExtR(a1, "JPEGSetupEncode", "JPEG tile height must be multiple of %u", v8, v9, v10, v11, v12, 8 * *(unsigned char *)(v2 + 1180));
      return 0;
    }
    if (!(*(_DWORD *)(a1 + 100) % (8 * *(unsigned __int16 *)(v2 + 1178)))) {
      goto LABEL_46;
    }
    __int16 v24 = 8 * *(_WORD *)(v2 + 1178);
    uint64_t v20 = "JPEG tile width must be multiple of %u";
LABEL_43:
    TIFFErrorExtR(a1, "JPEGSetupEncode", v20, v8, v9, v10, v11, v12, v24);
    return 0;
  }
  unsigned int v19 = *(_DWORD *)(a1 + 132);
  if (v19 < *(_DWORD *)(a1 + 92) && v19 % (8 * *(unsigned __int16 *)(v2 + 1180)))
  {
    TIFFErrorExtR(a1, "JPEGSetupEncode", "RowsPerStrip must be multiple of %u for JPEG", v8, v9, v10, v11, v12, 8 * *(unsigned char *)(v2 + 1180));
    return 0;
  }
LABEL_46:
  int v21 = *(_DWORD *)(v2 + 1340);
  if ((v21 & 3) == 0)
  {
    unsigned int v23 = *(_DWORD *)(a1 + 80) & 0xFFFFFFFB;
    goto LABEL_58;
  }
  unsigned int v22 = *(void **)(v2 + 1320);
  if (v22 && *v22) {
    goto LABEL_59;
  }
  if ((v21 & 2) != 0
    && (!*(void *)(v2 + 160) || !*(void *)(v2 + 168) || !*(void *)(v2 + 192) || !*(void *)(v2 + 200)))
  {
    TIFF_std_huff_tables(v2);
  }
  uint64_t result = prepare_JPEGTables((void *)a1);
  if (result)
  {
    *(_DWORD *)(a1 + 16) |= 8u;
    unsigned int v23 = *(_DWORD *)(a1 + 80) | 4;
LABEL_58:
    *(_DWORD *)(a1 + 80) = v23;
LABEL_59:
    *(void *)(v2 + 40) = v2 + 1072;
    *(void *)(v2 + 1088) = std_init_destination;
    *(void *)(v2 + 1096) = std_empty_output_buffer;
    *(void *)(v2 + 1104) = std_term_destination;
    return 1;
  }
  return result;
}

uint64_t JPEGPreEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *(void *)(a1 + 1096);
  if (!v8) {
    JPEGPreEncode_cold_1();
  }
  int v9 = a2;
  int v11 = *(_DWORD *)(v8 + 32);
  if (v11 == 1)
  {
    (*(void (**)(uint64_t))(a1 + 976))(a1);
    int v11 = *(_DWORD *)(v8 + 32);
  }
  if (v11) {
    JPEGPreEncode_cold_2();
  }
  if ((*(unsigned char *)(a1 + 17) & 4) != 0)
  {
    unsigned int v12 = *(_DWORD *)(a1 + 100);
    unsigned int v13 = *(_DWORD *)(a1 + 104);
    uint64_t v14 = _cg_TIFFTileRowSize(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
    unsigned int v12 = *(_DWORD *)(a1 + 88);
    if ((*(_DWORD *)(a1 + 92) - *(_DWORD *)(a1 + 876)) >= *(_DWORD *)(a1 + 132)) {
      unsigned int v13 = *(_DWORD *)(a1 + 132);
    }
    else {
      unsigned int v13 = *(_DWORD *)(a1 + 92) - *(_DWORD *)(a1 + 876);
    }
    uint64_t v14 = _cg_TIFFScanlineSize(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  *(void *)(v8 + 1184) = v14;
  if (v9 && *(_WORD *)(a1 + 170) == 2)
  {
    unsigned int v20 = *(unsigned __int16 *)(v8 + 1178);
    if (!*(_WORD *)(v8 + 1178) || (unsigned int v21 = *(unsigned __int16 *)(v8 + 1180), !*(_WORD *)(v8 + 1180)))
    {
      __int16 v24 = "JPEG horizontal or vertical sampling is zero";
      goto LABEL_28;
    }
    unsigned int v22 = 0;
    if (v12 < -v20) {
      unsigned int v22 = (v12 + v20 - 1) / v20;
    }
    if (v13 >= -v21) {
      unsigned int v13 = 0;
    }
    else {
      unsigned int v13 = (v13 + v21 - 1) / v21;
    }
  }
  else
  {
    unsigned int v22 = v12;
  }
  if (HIWORD(v22) || v13 >= 0x10000)
  {
    __int16 v24 = "Strip/tile too large for JPEG";
LABEL_28:
    TIFFErrorExtR(a1, "JPEGPreEncode", v24, v15, v16, v17, v18, v19, v36);
    return 0;
  }
  *(_DWORD *)(v8 + 48) = v22;
  *(_DWORD *)(v8 + 52) = v13;
  if (*(_WORD *)(a1 + 170) != 1)
  {
    uint64_t result = TIFFjpeg_set_colorspace(v8, 0);
    if (!result) {
      return result;
    }
    BOOL v23 = 0;
    **(_DWORD **)(v8 + 104) = v9;
    if (v9 && *(_WORD *)(v8 + 1176) == 6)
    {
      BOOL v23 = 0;
      *(_DWORD *)(*(void *)(v8 + 104) + 16) = 1;
      *(_DWORD *)(*(void *)(v8 + 104) + 20) = 1;
      *(_DWORD *)(*(void *)(v8 + 104) + 24) = 1;
    }
    goto LABEL_42;
  }
  *(_DWORD *)(v8 + 56) = *(unsigned __int16 *)(a1 + 130);
  if (*(_WORD *)(v8 + 1176) != 6)
  {
    int v26 = TIFFjpeg_set_colorspace(v8, *(_DWORD *)(v8 + 60));
    BOOL v23 = 0;
    uint64_t result = 0;
    if (!v26) {
      return result;
    }
LABEL_42:
    *(_DWORD *)(v8 + 324) = 0;
    *(_DWORD *)(v8 + 336) = 0;
    uint64_t result = TIFFjpeg_set_quality(v8, *(_DWORD *)(v8 + 1332));
    if (!result) {
      return result;
    }
    int v27 = *(_DWORD *)(v8 + 1340);
    uint64_t v28 = *(void *)(v8 + 112);
    if (v27)
    {
      if (v28) {
        *(_DWORD *)(v28 + 128) = 1;
      }
      uint64_t v29 = *(void *)(v8 + 120);
      if (v29)
      {
        int v30 = 1;
        goto LABEL_52;
      }
    }
    else
    {
      if (v28) {
        *(_DWORD *)(v28 + 128) = 0;
      }
      uint64_t v29 = *(void *)(v8 + 120);
      if (v29)
      {
        int v30 = 0;
LABEL_52:
        *(_DWORD *)(v29 + 128) = v30;
      }
    }
    if ((v27 & 2) != 0)
    {
      uint64_t v32 = *(void *)(v8 + 160);
      if (v32) {
        *(_DWORD *)(v32 + 276) = 1;
      }
      uint64_t v33 = *(void *)(v8 + 192);
      if (v33) {
        *(_DWORD *)(v33 + 276) = 1;
      }
      uint64_t v34 = *(void *)(v8 + 168);
      if (v34) {
        *(_DWORD *)(v34 + 276) = 1;
      }
      uint64_t v35 = *(void *)(v8 + 200);
      int v31 = 0;
      if (v35) {
        *(_DWORD *)(v35 + 276) = 1;
      }
    }
    else
    {
      int v31 = 1;
    }
    *(_DWORD *)(v8 + 296) = v31;
    if (v23)
    {
      *(_DWORD *)(v8 + 288) = 1;
      *(void *)(a1 + 1016) = JPEGEncodeRaw;
      *(void *)(a1 + 1032) = JPEGEncodeRaw;
      *(void *)(a1 + 1048) = JPEGEncodeRaw;
      uint64_t result = TIFFjpeg_start_compress(v8);
      if (!result) {
        return result;
      }
      uint64_t result = alloc_downsampled_buffers(a1, *(void *)(v8 + 104), *(_DWORD *)(v8 + 92));
      if (!result) {
        return result;
      }
    }
    else
    {
      *(_DWORD *)(v8 + 288) = 0;
      *(void *)(a1 + 1016) = JPEGEncode;
      *(void *)(a1 + 1032) = JPEGEncode;
      *(void *)(a1 + 1048) = JPEGEncode;
      uint64_t result = TIFFjpeg_start_compress(v8);
      if (!result) {
        return result;
      }
    }
    *(_DWORD *)(v8 + 1272) = 0;
    return 1;
  }
  BOOL v23 = *(_DWORD *)(v8 + 1336) != 1 && (*(_WORD *)(v8 + 1178) != 1 || *(_WORD *)(v8 + 1180) != 1);
  uint64_t result = TIFFjpeg_set_colorspace(v8, 3);
  if (result)
  {
    *(_DWORD *)(*(void *)(v8 + 104) + 8) = *(unsigned __int16 *)(v8 + 1178);
    *(_DWORD *)(*(void *)(v8 + 104) + 12) = *(unsigned __int16 *)(v8 + 1180);
    goto LABEL_42;
  }
  return result;
}

uint64_t JPEGPostEncode(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1096);
  if (*(int *)(v1 + 1272) >= 1)
  {
    int v3 = *(_DWORD *)(v1 + 92);
    if (v3 >= 1)
    {
      uint64_t v4 = 0;
      uint64_t v5 = *(void *)(v1 + 104);
      do
      {
        int v6 = *(_DWORD *)(v5 + 12);
        int v7 = *(_DWORD *)(v1 + 1272);
        if (v7 * v6 < 8 * v6)
        {
          size_t v8 = (8 * *(_DWORD *)(v5 + 28));
          uint64_t v9 = 8 * v7 * v6;
          int v10 = v6 * (8 - v7);
          do
          {
            int v11 = (void **)(*(void *)(v1 + 8 * v4 + 1192) + v9);
            _TIFFmemcpy(*v11, *(v11 - 1), v8);
            v9 += 8;
            --v10;
          }
          while (v10);
          int v3 = *(_DWORD *)(v1 + 92);
        }
        ++v4;
        v5 += 96;
      }
      while (v4 < v3);
    }
    int v12 = *(_DWORD *)(v1 + 356);
    if (TIFFjpeg_write_raw_data(v1, v1 + 1192, 8 * v12) != 8 * v12) {
      return 0;
    }
    uint64_t v1 = *(void *)(a1 + 1096);
  }

  return TIFFjpeg_finish_compress(v1);
}

uint64_t JPEGEncode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v33[1] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a1 + 1096);
  if (!v8) {
    JPEGEncode_cold_1();
  }
  uint64_t v11 = *(void *)(v8 + 1184);
  uint64_t v12 = a3 / v11;
  if (a3 % v11) {
    TIFFWarningExtR(a1, *(const char **)a1, "fractional scanline discarded", a4, a5, a6, a7, a8, v33[0]);
  }
  if ((*(unsigned char *)(a1 + 17) & 4) == 0)
  {
    uint64_t v13 = *(unsigned int *)(a1 + 876);
    uint64_t v14 = v12 + v13;
    uint64_t v15 = *(unsigned int *)(a1 + 92);
    uint64_t v16 = (v15 - v13);
    if (v14 > v15) {
      uint64_t v12 = v16;
    }
  }
  if (*(_DWORD *)(v8 + 88) == 12)
  {
    uint64_t v17 = 2 * *(void *)(v8 + 1184) / 3;
    uint64_t v18 = (char *)_TIFFmallocExt((void *)a1, 2 * (int)v17, a3, a4, a5, a6, a7, a8);
    if (!v18)
    {
      TIFFErrorExtR(a1, "JPEGEncode", "Failed to allocate memory", v19, v20, v21, v22, v23, v33[0]);
      return 0;
    }
    __int16 v24 = v18;
  }
  else
  {
    __int16 v24 = 0;
    LODWORD(v17) = 0;
  }
  v33[0] = 0;
  if (v12 >= 1)
  {
    if ((int)v17 >= 0) {
      int v25 = v17;
    }
    else {
      int v25 = v17 + 1;
    }
    uint64_t v26 = (v25 >> 1);
    while (1)
    {
      if (*(_DWORD *)(v8 + 88) == 12)
      {
        v33[0] = v24;
        if ((int)v17 >= 2)
        {
          int v27 = (char *)(a2 + 2);
          uint64_t v28 = v26;
          uint64_t v29 = v24 + 1;
          do
          {
            HIDWORD(v30) = *(v27 - 2);
            LODWORD(v30) = *(v27 - 1) << 24;
            *(v29 - 1) = v30 >> 28;
            char v31 = *v27;
            v27 += 3;
            *uint64_t v29 = v31;
            v29 += 4;
            --v28;
          }
          while (v28);
        }
      }
      else
      {
        v33[0] = a2;
      }
      if (TIFFjpeg_write_scanlines(v8, (uint64_t)v33) != 1) {
        return 0;
      }
      if (v12 < 2) {
        break;
      }
      --v12;
      ++*(_DWORD *)(a1 + 876);
      a2 += *(void *)(v8 + 1184);
    }
  }
  if (*(_DWORD *)(v8 + 88) == 12) {
    _TIFFfreeExt(a1, v24);
  }
  return 1;
}

uint64_t JPEGCleanup(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 1096);
  if (!v1) {
    JPEGCleanup_cold_1();
  }
  *(void *)(a1 + 1288) = *(void *)(v1 + 1280);
  *(void *)(a1 + 1280) = *(void *)(v1 + 1288);
  *(void *)(a1 + 1296) = *(void *)(v1 + 1296);
  if (*(_DWORD *)(v1 + 664)) {
    TIFFjpeg_destroy(v1);
  }
  int v3 = *(char **)(v1 + 1320);
  if (v3) {
    _TIFFfreeExt(a1, v3);
  }
  _TIFFfreeExt(a1, *(char **)(a1 + 1096));
  *(void *)(a1 + 1096) = 0;

  return _TIFFSetDefaultCompressionState(a1);
}

uint64_t JPEGDefaultStripSize(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 1096) + 1304))();
  if (result < *(_DWORD *)(a1 + 92))
  {
    unsigned int v3 = 0;
    int v4 = *(unsigned __int16 *)(a1 + 338);
    unsigned int v5 = 8 * v4;
    if (result < -8 * v4) {
      unsigned int v3 = (result + v5 - 1) / v5;
    }
    return v3 * v5;
  }
  return result;
}

uint64_t JPEGDefaultTileSize(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 1096) + 1312))();
  unsigned int v7 = 0;
  int v8 = *(unsigned __int16 *)(a1 + 336);
  unsigned int v9 = 8 * v8;
  if (*a2 < (-8 * v8)) {
    unsigned int v7 = (*a2 + v9 - 1) / v9;
  }
  unsigned int v10 = 0;
  *a2 = v7 * v9;
  int v11 = *(unsigned __int16 *)(a1 + 338);
  unsigned int v12 = 8 * v11;
  if (*a3 < (-8 * v11)) {
    unsigned int v10 = (*a3 + v12 - 1) / v12;
  }
  *a3 = v10 * v12;
  return result;
}

uint64_t JPEGResetUpsampled(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = result;
  uint64_t v9 = *(void *)(result + 1096);
  int v10 = *(_DWORD *)(result + 16);
  __int16 v11 = v10 & 0xBFFF;
  *(_DWORD *)(result + 16) = v10 & 0xFFFFBFFF;
  if (*(_WORD *)(result + 170) == 1 && *(_WORD *)(result + 122) == 6 && *(_DWORD *)(v9 + 1336) == 1)
  {
    __int16 v11 = v10 | 0x4000;
    *(_DWORD *)(result + 16) = v10 | 0x4000;
  }
  if (*(uint64_t *)(result + 936) >= 1)
  {
    if ((v11 & 0x400) != 0) {
      uint64_t result = _cg_TIFFTileSize(result, a2, a3, a4, a5, a6, a7, a8);
    }
    else {
      uint64_t result = -1;
    }
    *(void *)(v8 + 936) = result;
  }
  if (*(uint64_t *)(v8 + 1104) >= 1)
  {
    uint64_t result = _cg_TIFFScanlineSize(v8, a2, a3, a4, a5, a6, a7, a8);
    *(void *)(v8 + 1104) = result;
  }
  return result;
}

uint64_t JPEGFixupTagsSubsamplingReadByte(uint64_t a1, unsigned char *a2)
{
  if (*(_DWORD *)(a1 + 32))
  {
    int v4 = *(unsigned char **)(a1 + 24);
LABEL_3:
    *a2 = *v4;
    ++*(void *)(a1 + 24);
    --*(_DWORD *)(a1 + 32);
    return 1;
  }
  unint64_t v6 = *(void *)(a1 + 48);
  if (v6)
  {
    if (!*(unsigned char *)(a1 + 56))
    {
      if ((*(uint64_t (**)(void, void, void))(*(void *)a1 + 1224))(*(void *)(*(void *)a1 + 1200), *(void *)(a1 + 40), 0) == -1)return 0; {
      *(unsigned char *)(a1 + 56) = 1;
      }
      unint64_t v6 = *(void *)(a1 + 48);
    }
    unint64_t v7 = *(unsigned int *)(a1 + 16);
    if (v6 >= v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = v6;
    }
    if ((v8 & 0x80000000) != 0) {
      JPEGFixupTagsSubsamplingReadByte_cold_1();
    }
    if ((*(uint64_t (**)(void, void, uint64_t))(*(void *)a1 + 1208))(*(void *)(*(void *)a1 + 1200), *(void *)(a1 + 8), v8) == v8)
    {
      int v4 = *(unsigned char **)(a1 + 8);
      *(void *)(a1 + 24) = v4;
      *(_DWORD *)(a1 + 32) = v8;
      uint64_t v9 = *(void *)(a1 + 48) - v8;
      *(void *)(a1 + 40) += v8;
      *(void *)(a1 + 48) = v9;
      goto LABEL_3;
    }
  }
  return 0;
}

uint64_t JPEGFixupTagsSubsamplingReadWord(uint64_t a1, _WORD *a2)
{
  unsigned __int8 v6 = 0;
  uint64_t result = JPEGFixupTagsSubsamplingReadByte(a1, &v6);
  if (result)
  {
    unsigned __int8 v5 = 0;
    uint64_t result = JPEGFixupTagsSubsamplingReadByte(a1, &v5);
    if (result)
    {
      *a2 = v5 | (v6 << 8);
      return 1;
    }
  }
  return result;
}

uint64_t JPEGInitializeLibJPEG(uint64_t result, int a2)
{
  uint64_t v3 = *(void *)(result + 1096);
  if (*(_DWORD *)(v3 + 664))
  {
    int v4 = *(_DWORD *)(v3 + 32);
    if (a2)
    {
      if (v4) {
        return result;
      }
    }
    else if (!v4)
    {
      return result;
    }
    TIFFjpeg_destroy(*(void *)(result + 1096));
    *(_DWORD *)(v3 + 664) = 0;
  }
  if (a2)
  {
    uint64_t result = TIFFjpeg_create_decompress(v3);
    if (!result) {
      return result;
    }
    goto LABEL_9;
  }
  uint64_t result = TIFFjpeg_create_compress(v3);
  if (result)
  {
    uint64_t v5 = *(void *)(v3 + 8);
    uint64_t v6 = *(void *)(v5 + 88);
    if (v6 >= 1)
    {
      uint64_t result = (uint64_t)getenv("JPEGMEM");
      if ((unint64_t)v6 >> 21 <= 4 && result == 0) {
        *(void *)(v5 + 88) = 10485760;
      }
    }
LABEL_9:
    *(_DWORD *)(v3 + 664) = 1;
  }
  return result;
}

uint64_t TIFFjpeg_create_compress(uint64_t a1)
{
  *(void *)a1 = _cg_jpeg_std_error(a1 + 672);
  *(void *)(a1 + 672) = TIFFjpeg_error_exit;
  *(void *)(a1 + 688) = TIFFjpeg_output_message;
  *(void *)(a1 + 24) = 0;
  if (setjmp((int *)(a1 + 848))) {
    return 0;
  }
  _cg_jpeg_CreateCompress((char *)a1, 90, 584);
  return 1;
}

uint64_t tables_init_source(uint64_t result)
{
  *(void *)(result + 1112) = *(void *)(result + 1320);
  *(void *)(result + 1120) = *(unsigned int *)(result + 1328);
  return result;
}

uint64_t TIFFjpeg_abort(uint64_t a1)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0;
  }
  _cg_jpeg_abort(a1);
  return 1;
}

uint64_t DecodeRowError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  TIFFErrorExtR(a1, "TIFFReadScanline", "scanline oriented access is not supported for downsampled JPEG compressed images, consider enabling TIFFTAG_JPEGCOLORMODE as JPEGCOLORMODE_RGB.", a4, a5, a6, a7, a8, vars0);
  return 0;
}

BOOL JPEGDecodeRaw(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = *(void *)(a1 + 1096);
  unsigned int v12 = *(_DWORD *)(v11 + 52);
  unsigned int v13 = *(_DWORD *)(a1 + 92) - *(_DWORD *)(a1 + 876);
  if (v12 <= v13)
  {
    unsigned int v13 = *(_DWORD *)(v11 + 52);
  }
  else if ((*(unsigned char *)(a1 + 17) & 4) != 0)
  {
    goto LABEL_6;
  }
  unsigned int v12 = v13;
  if (!v13) {
    return *(_DWORD *)(v11 + 168) < *(_DWORD *)(v11 + 140) || TIFFjpeg_finish_decompress(v11) != 0;
  }
LABEL_6:
  uint64_t v14 = v12;
  int v15 = *(_DWORD *)(*(void *)(v11 + 304) + 140);
  uint64_t v16 = *(int *)(v11 + 1276);
  uint64_t v17 = *(void *)(v11 + 1184);
  while (1)
  {
    if (a3 < v17)
    {
      uint64_t v37 = "application buffer not large enough for all data.";
      goto LABEL_37;
    }
    int v18 = *(_DWORD *)(v11 + 1272);
    if (v18 >= 8)
    {
      int v19 = *(_DWORD *)(v11 + 420);
      if (TIFFjpeg_read_raw_data(v11, v11 + 1192, 8 * v19) != 8 * v19) {
        return 0;
      }
      int v18 = 0;
      *(_DWORD *)(v11 + 1272) = 0;
    }
    int v20 = *(_DWORD *)(v11 + 56);
    if (v20 >= 1) {
      break;
    }
LABEL_32:
    *(_DWORD *)(v11 + 1272) = v18 + 1;
    uint64_t v34 = *(unsigned __int16 *)(v11 + 1180);
    *(_DWORD *)(a1 + 876) += v34;
    uint64_t v17 = *(void *)(v11 + 1184);
    a2 += v17;
    a3 -= v17;
    BOOL v35 = v14 <= v34;
    v14 -= v34;
    if (v35) {
      return *(_DWORD *)(v11 + 168) < *(_DWORD *)(v11 + 140) || TIFFjpeg_finish_decompress(v11) != 0;
    }
  }
  uint64_t v21 = 0;
  LODWORD(v22) = 0;
  uint64_t v23 = *(void *)(v11 + 304);
  while (1)
  {
    int v24 = *(_DWORD *)(v23 + 12);
    if (v24 >= 1) {
      break;
    }
LABEL_30:
    ++v21;
    v23 += 96;
    if (v21 >= v20)
    {
      int v18 = *(_DWORD *)(v11 + 1272);
      goto LABEL_32;
    }
  }
  int v25 = 0;
  uint64_t v26 = *(unsigned int *)(v23 + 8);
  uint64_t v22 = (int)v22;
  while (a3 >= v16 * (v15 - 1) + (int)v26 + v22)
  {
    int v27 = *(char **)(*(void *)(v11 + 8 * v21 + 1192) + 8 * (v25 + *(_DWORD *)(v11 + 1272) * v24));
    if (v26 == 1)
    {
      if (v15)
      {
        uint64_t v28 = a2;
        int v29 = v15;
        do
        {
          char v30 = *v27++;
          *(unsigned char *)(v28 + v22) = v30;
          v28 += v16;
          --v29;
        }
        while (v29);
      }
    }
    else if (v15)
    {
      uint64_t v31 = a2 + v22;
      int v32 = v15;
      do
      {
        if ((int)v26 >= 1)
        {
          for (uint64_t i = 0; i != v26; ++i)
          {
            a4 = v27[i];
            *(unsigned char *)(v31 + i) = a4;
          }
          v27 += i;
        }
        v31 += v16;
        --v32;
      }
      while (v32);
    }
    v22 += (int)v26;
    if (++v25 == v24)
    {
      int v20 = *(_DWORD *)(v11 + 56);
      goto LABEL_30;
    }
  }
  uint64_t v37 = "application buffer not large enough for all data, possible subsampling issue";
LABEL_37:
  TIFFErrorExtR(a1, "JPEGDecodeRaw", v37, a4, a5, a6, a7, a8, v38);
  return 0;
}

uint64_t TIFFjpeg_start_decompress(uint64_t a1)
{
  *(void *)(a1 + 16) = a1 + 1040;
  *(void *)(a1 + 1040) = TIFFjpeg_progress_monitor;
  *(_DWORD *)(a1 + 1348) = 100;
  uint64_t v2 = getenv("LIBTIFF_JPEG_MAX_ALLOWED_SCAN_NUMBER");
  if (v2) {
    *(_DWORD *)(a1 + 1348) = atoi(v2);
  }
  if (setjmp((int *)(a1 + 848))) {
    return 0;
  }
  _cg_jpeg_start_decompress(a1);
  return 1;
}

uint64_t alloc_downsampled_buffers(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 1096);
  if (a3 < 1)
  {
    int v5 = 0;
LABEL_7:
    *(_DWORD *)(v3 + 1276) = v5;
    return 1;
  }
  else
  {
    uint64_t v4 = 0;
    int v5 = 0;
    uint64_t v6 = 8 * a3;
    unint64_t v7 = (_DWORD *)(a2 + 28);
    while (1)
    {
      int v8 = *(v7 - 5);
      int v9 = *(v7 - 4);
      uint64_t result = TIFFjpeg_alloc_sarray(v3, (8 * *v7), (8 * v9));
      if (!result) {
        break;
      }
      v7 += 24;
      v5 += v9 * v8;
      *(void *)(v3 + v4 + 1192) = result;
      v4 += 8;
      if (v6 == v4) {
        goto LABEL_7;
      }
    }
  }
  return result;
}

uint64_t TIFFjpeg_read_raw_data(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0xFFFFFFFFLL;
  }
  else {
    return _cg_jpeg_read_raw_data(a1, a2, a3);
  }
}

uint64_t TIFFjpeg_finish_decompress(uint64_t a1)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0xFFFFFFFFLL;
  }
  else {
    return _cg_jpeg_finish_decompress(a1);
  }
}

uint64_t TIFFjpeg_progress_monitor(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(result + 32))
  {
    if (*(_DWORD *)(result + 172) >= *(_DWORD *)(result + 1348))
    {
      uint64_t v8 = result;
      TIFFErrorExtR(*(void *)(result + 1168), "TIFFjpeg_progress_monitor", "Scan number %d exceeds maximum scans (%d). This limit can be raised through the LIBTIFF_JPEG_MAX_ALLOWED_SCAN_NUMBER environment variable.", a4, a5, a6, a7, a8, *(_DWORD *)(result + 172));
      _cg_jpeg_abort(v8);
      longjmp((int *)(v8 + 848), 1);
    }
  }
  return result;
}

uint64_t TIFFjpeg_alloc_sarray(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0;
  }
  else {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, a2, a3);
  }
}

uint64_t TIFFjpeg_read_scanlines(uint64_t a1, uint64_t a2)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0xFFFFFFFFLL;
  }
  else {
    return _cg_jpeg_read_scanlines(a1, a2, 1);
  }
}

uint64_t TIFFjpeg_set_defaults(uint64_t a1)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0;
  }
  _cg_jpeg_set_defaults(a1, v2, v3, v4, v5, v6, v7, v8);
  return 1;
}

uint64_t TIFF_std_huff_tables(uint64_t result)
{
  uint64_t v1 = (void *)result;
  if (!*(void *)(result + 160)) {
    uint64_t result = _cg_jpeg_std_huff_table(result, 1, 0);
  }
  if (!v1[24]) {
    uint64_t result = _cg_jpeg_std_huff_table((uint64_t)v1, 0, 0);
  }
  if (!v1[21]) {
    uint64_t result = _cg_jpeg_std_huff_table((uint64_t)v1, 1, 1u);
  }
  if (!v1[25])
  {
    return _cg_jpeg_std_huff_table((uint64_t)v1, 0, 1u);
  }
  return result;
}

uint64_t prepare_JPEGTables(void *a1)
{
  uint64_t v2 = a1[137];
  if (!TIFFjpeg_set_quality(v2, *(_DWORD *)(v2 + 1332)) || !TIFFjpeg_suppress_tables(v2)) {
    return 0;
  }
  int v9 = *(_DWORD *)(v2 + 1340);
  if (v9)
  {
    uint64_t v10 = *(void *)(v2 + 112);
    if (v10) {
      *(_DWORD *)(v10 + 128) = 0;
    }
    if (*(_WORD *)(v2 + 1176) == 6)
    {
      uint64_t v11 = *(void *)(v2 + 120);
      if (v11) {
        *(_DWORD *)(v11 + 128) = 0;
      }
    }
  }
  if ((v9 & 2) != 0)
  {
    uint64_t v12 = *(void *)(v2 + 160);
    if (v12) {
      *(_DWORD *)(v12 + 276) = 0;
    }
    uint64_t v13 = *(void *)(v2 + 192);
    if (v13) {
      *(_DWORD *)(v13 + 276) = 0;
    }
    if (*(_WORD *)(v2 + 1176) == 6)
    {
      uint64_t v14 = *(void *)(v2 + 168);
      if (v14) {
        *(_DWORD *)(v14 + 276) = 0;
      }
      uint64_t v15 = *(void *)(v2 + 200);
      if (v15) {
        *(_DWORD *)(v15 + 276) = 0;
      }
    }
  }
  uint64_t v16 = *(char **)(v2 + 1320);
  if (v16) {
    _TIFFfreeExt((uint64_t)a1, v16);
  }
  *(_DWORD *)(v2 + 1328) = 1000;
  uint64_t v17 = _TIFFmallocExt(a1, 1000, v3, v4, v5, v6, v7, v8);
  *(void *)(v2 + 1320) = v17;
  if (!v17)
  {
    *(_DWORD *)(v2 + 1328) = 0;
    TIFFErrorExtR(*(void *)(v2 + 1168), "TIFFjpeg_tables_dest", "No space for JPEGTables", v18, v19, v20, v21, v22, v24);
    return 0;
  }
  *(void *)(v2 + 40) = v2 + 1072;
  *(void *)(v2 + 1088) = tables_init_destination;
  *(void *)(v2 + 1096) = tables_empty_output_buffer;
  *(void *)(v2 + 1104) = tables_term_destination;

  return TIFFjpeg_write_tables(v2);
}

uint64_t TIFFjpeg_set_quality(uint64_t a1, int a2)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0;
  }
  _cg_jpeg_set_quality(a1, a2, 0, v4, v5, v6, v7, v8, v9, v10);
  return 1;
}

uint64_t TIFFjpeg_suppress_tables(uint64_t a1)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0;
  }
  _cg_jpeg_suppress_tables(a1, 1);
  return 1;
}

uint64_t TIFFjpeg_write_tables(uint64_t a1)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0;
  }
  _cg_jpeg_write_tables(a1);
  return 1;
}

uint64_t tables_init_destination(uint64_t result)
{
  *(void *)(result + 1072) = *(void *)(result + 1320);
  *(void *)(result + 1080) = *(unsigned int *)(result + 1328);
  return result;
}

uint64_t tables_empty_output_buffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v9 = _TIFFreallocExt(*(void **)(a1 + 1168), *(char **)(a1 + 1320), (*(_DWORD *)(a1 + 1328) + 1000), a4, a5, a6, a7, a8);
  if (!v9)
  {
    __n128 v10 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v10 + 10) = 56;
    *((_DWORD *)v10 + 12) = 100;
    (**(void (***)(uint64_t))a1)(a1);
  }
  uint64_t v11 = *(unsigned int *)(a1 + 1328);
  *(void *)(a1 + 1072) = (char *)v9 + v11;
  *(void *)(a1 + 1080) = 1000;
  *(void *)(a1 + 1320) = v9;
  *(_DWORD *)(a1 + 1328) = v11 + 1000;
  return 1;
}

uint64_t tables_term_destination(uint64_t result)
{
  *(_DWORD *)(result + 1328) -= *(_DWORD *)(result + 1080);
  return result;
}

void *std_init_destination(void *result)
{
  uint64_t v1 = result[146];
  result[134] = *(void *)(v1 + 1120);
  result[135] = *(void *)(v1 + 1128);
  return result;
}

uint64_t std_empty_output_buffer(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double v9 = (void *)a1[146];
  v9[145] = v9[141];
  uint64_t result = TIFFFlushData1((uint64_t)v9, a2, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    a1[134] = v9[140];
    a1[135] = v9[141];
    return 1;
  }
  return result;
}

void *std_term_destination(void *result)
{
  uint64_t v1 = (void *)result[146];
  v1[144] = result[134];
  v1[145] = v1[141] - result[135];
  return result;
}

uint64_t TIFFjpeg_set_colorspace(uint64_t a1, int a2)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0;
  }
  _cg_jpeg_set_colorspace(a1, a2);
  return 1;
}

uint64_t JPEGEncodeRaw(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a1 + 1096);
  uint64_t v11 = *(int *)(v10 + 1276);
  int64_t v12 = (uint64_t)(*(unsigned int *)(v10 + 48) + (unint64_t)*(unsigned __int16 *)(v10 + 1178) - 1)
      / *(unsigned __int16 *)(v10 + 1178)
      * *(int *)(v10 + 88)
      * (*(unsigned __int16 *)(v10 + 1180) * (unint64_t)*(unsigned __int16 *)(v10 + 1178) + 2);
  uint64_t v14 = v12 + 7;
  BOOL v13 = v12 < -7;
  uint64_t v15 = v12 + 14;
  if (!v13) {
    uint64_t v15 = v14;
  }
  uint64_t v16 = v15 >> 3;
  uint64_t v17 = a3 / (v15 >> 3);
  uint64_t v18 = v17 * *(unsigned __int16 *)(v10 + 1180);
  if (a3 != v17 * v16) {
    TIFFWarningExtR(a1, *(const char **)a1, "fractional scanline discarded", a4, a5, a6, a7, a8, v44);
  }
  if (v18 < 1) {
    return 1;
  }
  int v19 = *(_DWORD *)(*(void *)(v10 + 104) + 140);
  while (1)
  {
    int v20 = *(_DWORD *)(v10 + 92);
    if (v20 >= 1)
    {
      uint64_t v21 = 0;
      LODWORD(v22) = 0;
      uint64_t v23 = *(int **)(v10 + 104);
      do
      {
        int v24 = v23[3];
        if (v24 >= 1)
        {
          int v25 = 0;
          uint64_t v26 = v23[2];
          uint64_t v27 = v23[2];
          int v28 = 8 * v23[7];
          int v29 = v28 - v26 * v19;
          uint64_t v22 = (int)v22;
          int v30 = v26 * v19 - v28;
          do
          {
            uint64_t v31 = *(unsigned char **)(*(void *)(v10 + 8 * v21 + 1192) + 8 * (v25 + *(_DWORD *)(v10 + 1272) * v24));
            if (v27 == 1)
            {
              if (v19)
              {
                uint64_t v32 = a2;
                int v33 = v19;
                do
                {
                  *v31++ = *(unsigned char *)(v32 + v22);
                  v32 += v11;
                  --v33;
                }
                while (v33);
              }
            }
            else if (v19)
            {
              uint64_t v34 = a2 + v22;
              int v35 = v19;
              do
              {
                if ((int)v26 >= 1)
                {
                  uint64_t v36 = 0;
                  do
                  {
                    v31[v36] = *(unsigned char *)(v34 + v36);
                    ++v36;
                  }
                  while (v27 != v36);
                  v31 += v36;
                }
                v34 += v11;
                --v35;
              }
              while (v35);
            }
            if (v29 >= 1)
            {
              char v37 = *(v31 - 1);
              int v38 = v30;
              do
                *v31++ = v37;
              while (!__CFADD__(v38++, 1));
            }
            v22 += v26;
            ++v25;
          }
          while (v25 != v24);
          int v20 = *(_DWORD *)(v10 + 92);
        }
        ++v21;
        v23 += 24;
      }
      while (v21 < v20);
    }
    int v40 = *(_DWORD *)(v10 + 1272);
    *(_DWORD *)(v10 + 1272) = v40 + 1;
    if (v40 < 7) {
      goto LABEL_33;
    }
    int v41 = *(_DWORD *)(v10 + 356);
    if (TIFFjpeg_write_raw_data(v10, v10 + 1192, 8 * v41) != 8 * v41) {
      return 0;
    }
    *(_DWORD *)(v10 + 1272) = 0;
LABEL_33:
    uint64_t v42 = *(unsigned __int16 *)(v10 + 1180);
    *(_DWORD *)(a1 + 876) += v42;
    a2 += v16;
    BOOL v13 = v18 <= v42;
    v18 -= v42;
    if (v13) {
      return 1;
    }
  }
}

uint64_t TIFFjpeg_start_compress(uint64_t a1)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0;
  }
  _cg_jpeg_start_compress(a1, 0);
  return 1;
}

uint64_t TIFFjpeg_write_raw_data(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0xFFFFFFFFLL;
  }
  else {
    return _cg_jpeg_write_raw_data(a1, a2, a3);
  }
}

uint64_t TIFFjpeg_finish_compress(uint64_t a1)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0;
  }
  _cg_jpeg_finish_compress(a1);
  return 1;
}

uint64_t TIFFjpeg_write_scanlines(uint64_t a1, uint64_t a2)
{
  if (setjmp((int *)(a1 + 848))) {
    return 0xFFFFFFFFLL;
  }
  else {
    return _cg_jpeg_write_scanlines(a1, a2, 1u);
  }
}

void Default_CTor(void)
{
  uint64_t v1 = 0;
  memset(v0, 0, sizeof(v0));
  WXMPFiles_CTor_1(v0);
}

void IIOMetadataUpdater::IIOMetadataUpdater(IIOMetadataUpdater *this, IIOImageSource *a2, IIOImageDestination *a3, IIODictionary *a4, char a5)
{
  *(void *)this = &unk_1ED4E45E8;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = a4;
  *((unsigned char *)this + 32) = a5;
  *((unsigned char *)this + 33) = IIODictionary::containsKey(a4, @"kCGImageDestinationMetadata");
  *((unsigned char *)this + 34) = 0;
  if (IIODictionary::containsKey(*((IIODictionary **)this + 3), @"kCGImageDestinationMergeMetadata"))
  {
    char BoolForKey = IIODictionary::getBoolForKey(*((IIODictionary **)this + 3), @"kCGImageDestinationMergeMetadata");
    *((unsigned char *)this + 34) = BoolForKey;
  }
  else
  {
    char BoolForKey = *((unsigned char *)this + 34);
  }
  *((unsigned char *)this + 35) = BoolForKey ^ 1;
  *((unsigned char *)this + 39) = IIODictionary::getUint32ForKey(*((IIODictionary **)this + 3), @"kCGImageDestinationOrientation")- 1 < 8;
  *((unsigned char *)this + 38) = IIODictionary::containsKey(*((IIODictionary **)this + 3), @"kCGImageDestinationDateTime");
  *((unsigned char *)this + 40) = IIODictionary::containsKey(*((IIODictionary **)this + 3), @"kCGImageDestinationICCProfile");
  *((unsigned char *)this + 36) = IIODictionary::getBoolForKey(*((IIODictionary **)this + 3), @"kCGImageMetadataShouldExcludeXMP");
  *((unsigned char *)this + 37) = IIODictionary::getBoolForKey(*((IIODictionary **)this + 3), @"kCGImageMetadataShouldExcludeGPS");
}

void IIOMetadataUpdater::~IIOMetadataUpdater(IIOMetadataUpdater *this)
{
}

BOOL IIOMetadataUpdater::copySourceToDestination(IIOImageSource **this)
{
  uint64_t v2 = (IIOImageRead *)IIOImageSource::imageRead(this[1]);
  CFDataRef v3 = IIOImageRead::copyData(v2);
  if (v3)
  {
    CFDataRef v4 = v3;
    int32x2_t v5 = (IIOImageWriteSession *)IIOImageSource::count(this[2]);
    BytePtr = CFDataGetBytePtr(v4);
    size_t Length = CFDataGetLength(v4);
    size_t v8 = IIOImageWriteSession::putBytes(v5, BytePtr, Length);
    if (v8 == CFDataGetLength(v4))
    {
      uint64_t Ref = IIOImageSource::imageReadRef(this[2]);
      BOOL v10 = CGImageWriteSessionFinalize(Ref, 0) == 0;
    }
    else
    {
      BOOL v10 = 1;
    }
    CFRelease(v4);
  }
  else
  {
    LogError("copySourceToDestination", 164, "*** ERROR: cannot get src data from CGImageSource\n");
    return 1;
  }
  return v10;
}

CGImageMetadata *IIOMetadataUpdater::createMetadataWithOrientation(IIOImageSource **this, int a2, __CFError **a3)
{
  memset(v11, 0, sizeof(v11));
  IIODictionary::IIODictionary((IIODictionary *)v11);
  int32x2_t v5 = (const CGImageMetadata *)IIOImageSource::copyMetadataAtIndex(this[1], 0, v11);
  double v6 = v5;
  if (v5 && (MutableCopdouble y = CGImageMetadataCreateMutableCopy(v5)) != 0
    || (MutableCopdouble y = CGImageMetadataCreateMutable()) != 0)
  {
    IIONumber::IIONumber((IIONumber *)v9, a2);
    CGImageMetadataSetValueMatchingImageProperty(MutableCopy, @"{TIFF}", @"Orientation", value);
    IIONumber::~IIONumber((IIONumber *)v9);
  }
  if (v6) {
    CFRelease(v6);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v11);
  return MutableCopy;
}

void sub_1887F018C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

CGImageMetadata *IIOMetadataUpdater::createMetadataWithDateTime(IIOImageSource **this, const __CFString *a2, __CFError **a3)
{
  memset(v19, 0, sizeof(v19));
  IIODictionary::IIODictionary((IIODictionary *)v19);
  double v6 = (const CGImageMetadata *)IIOImageSource::copyMetadataAtIndex(this[1], 0, v19);
  double v7 = v6;
  if (!v6 || (CGMutableImageMetadataRef Mutable = CGImageMetadataCreateMutableCopy(v6)) == 0)
  {
    CGMutableImageMetadataRef Mutable = CGImageMetadataCreateMutable();
    if (!Mutable) {
      goto LABEL_31;
    }
  }
  CFTypeID v9 = CFGetTypeID(a2);
  if (v9 == CFDateGetTypeID())
  {
    CFLocaleRef v10 = CFLocaleCopyCurrent();
    CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    int64_t v12 = CFDateFormatterCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v10, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
    CFDateFormatterSetFormat(v12, @"yyyy-MM-dd'T'HH:mm:ss.SSSZZZZ");
    BOOL v13 = CFDateFormatterCreate(v11, v10, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
    CFDateFormatterSetFormat(v13, @"SSS");
    if (v13)
    {
      CFStringRef StringWithDate = CFDateFormatterCreateStringWithDate(v11, v13, (CFDateRef)a2);
      if (!v12) {
        goto LABEL_19;
      }
    }
    else
    {
      CFStringRef StringWithDate = 0;
      if (!v12) {
        goto LABEL_19;
      }
    }
    CFStringRef v17 = CFDateFormatterCreateStringWithDate(v11, v12, (CFDateRef)a2);
    if (v17)
    {
      MutableCopdouble y = CFStringCreateMutableCopy(v11, 32, v17);
      if (MutableCopy)
      {
        v20.size_t length = CFStringGetLength(v17);
        v20.location = 0;
        CFStringFindAndReplace(MutableCopy, @"GMT", &stru_1ED4F1F48, v20, 0);
      }
      CFRelease(v17);
      if (!v10)
      {
LABEL_21:
        if (v12) {
          CFRelease(v12);
        }
        if (v13) {
          CFRelease(v13);
        }
        if (MutableCopy) {
          goto LABEL_26;
        }
        goto LABEL_28;
      }
LABEL_20:
      CFRelease(v10);
      goto LABEL_21;
    }
LABEL_19:
    MutableCopdouble y = 0;
    if (!v10) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  CFTypeID v15 = CFGetTypeID(a2);
  if (v15 == CFStringGetTypeID())
  {
    CFStringRef StringWithDate = CreateSubsecTimeFromXMPDateTime(a2);
    if (StringWithDate)
    {
      MutableCopdouble y = (__CFString *)CreateXMPDateFromXMPDateTimeAndSubsecTime(a2, (uint64_t)StringWithDate);
      if (!MutableCopy) {
        goto LABEL_28;
      }
    }
    else
    {
      MutableCopdouble y = (__CFString *)CreateXMPDateTimeWithXMPOrExifDateTimeString(a2);
      CFStringRef StringWithDate = 0;
      if (!MutableCopy) {
        goto LABEL_28;
      }
    }
LABEL_26:
    CGImageMetadataSetValueWithPath(Mutable, 0, @"photoshop:DateCreated", MutableCopy);
    CGImageMetadataSetValueWithPath(Mutable, 0, @"xmp:CreateDate", MutableCopy);
    CGImageMetadataSetValueWithPath(Mutable, 0, @"xmp:ModifyDate", MutableCopy);
    CFRelease(MutableCopy);
    goto LABEL_29;
  }
  CFStringRef StringWithDate = 0;
LABEL_28:
  CGImageMetadataCreateAndLogUTF8Error("createMetadataWithDateTime", 278, 2, "Could not parse kCGImageDestinationDateTime string - must be a valid EXIF DateTime or ISO8601 string", a3);
LABEL_29:
  if (StringWithDate) {
    CFRelease(StringWithDate);
  }
LABEL_31:
  if (v7) {
    CFRelease(v7);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v19);
  return Mutable;
}

void sub_1887F0470(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CGMutableImageMetadataRef IIOMetadataUpdater::createMetadataWithMetadata(IIOImageSource **this, const CGImageMetadata *cf, __CFError **a3)
{
  if (cf && *((unsigned char *)this + 34))
  {
    memset(v9, 0, sizeof(v9));
    IIODictionary::IIODictionary((IIODictionary *)v9);
    int32x2_t v5 = (const CGImageMetadata *)IIOImageSource::copyMetadataAtIndex(this[1], 0, v9);
    MutableCopdouble y = CGImageMetadataCreateMutableCopy(v5);
    if (MutableCopy)
    {
      if (!v5) {
        goto LABEL_12;
      }
    }
    else
    {
      MutableCopdouble y = CGImageMetadataCreateMutable();
      if (!v5)
      {
LABEL_12:
        if (MutableCopy)
        {
          memset(v8, 0, sizeof(v8));
          IIODictionary::IIODictionary((IIODictionary *)v8);
          IIODictionary::setObjectForKey((IIODictionary *)v8, (const void *)*MEMORY[0x1E4F1CFD0], @"kCGImageMetadataMergeOverwrite");
          CGImageMetadataMerge((uint64_t)MutableCopy, (uint64_t)cf, (IIODictionary *)v8);
          if (*((unsigned char *)this + 37)) {
            CGImageMetadataRemoveGPS((uint64_t)MutableCopy);
          }
          IIODictionary::~IIODictionary((IIODictionary *)v8);
        }
        IIODictionary::~IIODictionary((IIODictionary *)v9);
        return MutableCopy;
      }
    }
    CFRelease(v5);
    goto LABEL_12;
  }
  if (!cf) {
    return 0;
  }
  if (*((unsigned char *)this + 37))
  {
    MutableCopdouble y = CGImageMetadataCreateMutableCopy(cf);
    CGImageMetadataRemoveGPS((uint64_t)MutableCopy);
    return MutableCopy;
  }

  return (CGMutableImageMetadataRef)CFRetain(cf);
}

void sub_1887F05DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOMetadataUpdater::isValid(IIOMetadataUpdater *this, __CFError **a2)
{
  if (!*((unsigned char *)this + 32)) {
    return 1;
  }
  int Type = (const void *)IIOImageSource::getType(*((IIO_Reader ***)this + 1));
  if (*((unsigned char *)this + 33)) {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(*((IIODictionary **)this + 3), @"kCGImageDestinationMetadata");
  }
  else {
    CFDictionaryRef ObjectForKey = 0;
  }
  if (*((unsigned char *)this + 39)) {
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(*((IIODictionary **)this + 3), @"kCGImageDestinationOrientation");
  }
  else {
    unsigned int Uint32ForKey = 0;
  }
  if (*((unsigned char *)this + 38)) {
    CFDictionaryRef v7 = IIODictionary::getObjectForKey(*((IIODictionary **)this + 3), @"kCGImageDestinationDateTime");
  }
  else {
    CFDictionaryRef v7 = 0;
  }
  if (*((unsigned char *)this + 40)) {
    CFDictionaryRef v8 = IIODictionary::getObjectForKey(*((IIODictionary **)this + 3), @"kCGImageDestinationICCProfile");
  }
  else {
    CFDictionaryRef v8 = 0;
  }
  if (*((unsigned char *)this + 33))
  {
    if (*((unsigned char *)this + 39))
    {
      CFTypeID v9 = "kCGImageDestinationMetadata cannot be used with kCGImageDestinationOrientation";
      int v10 = 364;
LABEL_34:
      int v13 = 3;
LABEL_35:
      CGImageMetadataCreateAndLogUTF8Error("CGImageDestinationCopyImageSource", v10, v13, v9, a2);
      return 0;
    }
    if (*((unsigned char *)this + 38))
    {
      CFTypeID v9 = "kCGImageDestinationMetadata cannot be used with kCGImageDestinationDateTime";
      int v10 = 369;
      goto LABEL_34;
    }
    if (ObjectForKey)
    {
      CFTypeID v12 = CFGetTypeID(ObjectForKey);
      if (v12 != CGImageMetadataGetTypeID())
      {
        CFTypeID v9 = "Invalid type - kCGImageDestinationMetadata value must be a CGImageMetadataRef";
        int v10 = 379;
        goto LABEL_51;
      }
    }
  }
  else
  {
    if (!*((unsigned char *)this + 39)
      && !*((unsigned char *)this + 38)
      && !*((unsigned char *)this + 40)
      && !*((unsigned char *)this + 37)
      && !*((unsigned char *)this + 36))
    {
      CFTypeID v9 = "One of kCGImageDestinationMetadata, kCGImageDestinationOrientation, kCGImageDestinationDateTime, kCGImageMeta"
           "dataShouldExcludeXMP, or kCGImageMetadataShouldExcludeGPS is required.";
      int v10 = 359;
      goto LABEL_51;
    }
    if (*((unsigned char *)this + 34))
    {
      int v11 = *((unsigned __int8 *)this + 38);
      if (!(v11 | *((unsigned __int8 *)this + 39)))
      {
        CFTypeID v9 = "kCGImageDestinationMetadata is required if kCGImageDestinationMergeMetadata is true";
        int v10 = 374;
        goto LABEL_34;
      }
      goto LABEL_30;
    }
  }
  int v11 = *((unsigned __int8 *)this + 38);
LABEL_30:
  if (*((unsigned char *)this + 37))
  {
    if (v11 || *((unsigned char *)this + 39))
    {
      CFTypeID v9 = "kCGImageDestinationExcludeGPS cannot be used with kCGImageDestinationDateTime or kCGImageDestinationOrientation";
      int v10 = 384;
      goto LABEL_34;
    }
  }
  else if (v11)
  {
    if (v7)
    {
      CFTypeID v15 = CFGetTypeID(v7);
      if (v15 != CFStringGetTypeID())
      {
        CFTypeID v16 = CFGetTypeID(v7);
        if (v16 != CFDateGetTypeID())
        {
          CFTypeID v9 = "Invalid type - kCGImageDestinationDateTime value must be a CFStringRef or CFDateRef";
          int v10 = 389;
          goto LABEL_51;
        }
      }
    }
  }
  if (*((unsigned char *)this + 39) && Uint32ForKey - 9 <= 0xFFFFFFF7)
  {
    CFTypeID v9 = "Invalid value for kCGImageDestinationOrientation, must be a CFNumber between 1 and 8 inclusive.";
    int v10 = 394;
LABEL_51:
    int v13 = 2;
    goto LABEL_35;
  }
  if (*((unsigned char *)this + 40))
  {
    CFTypeID v17 = CFGetTypeID(v8);
    if (v17 != CFDataGetTypeID())
    {
      CFTypeID v9 = "Invalid value for kCGImageDestinationICCProfile, must be a CFData";
      int v10 = 399;
      goto LABEL_51;
    }
    if (*((unsigned char *)this + 40) && !CFEqual(Type, @"public.jpeg"))
    {
      CFTypeID v9 = "Setting ICC profile is only supported for JPEG.";
      int v10 = 404;
      int v13 = 1;
      goto LABEL_35;
    }
  }
  return 1;
}

BOOL IIOMetadataUpdater::updateDestination(IIOImageSource **this, __CFError **a2)
{
  if ((IIOMetadataUpdater::isValid((IIOMetadataUpdater *)this, a2) & 1) == 0)
  {
    _cg_jpeg_mem_term("updateDestination", 420, "*** ERROR: IIOMetadataUpdate - invalid request\n");
    return 0;
  }
  if (*((unsigned char *)this + 32))
  {
    memset(v26, 0, sizeof(v26));
    IIODictionary::IIODictionary((IIODictionary *)v26);
    memset(v25, 0, sizeof(v25));
    IIODictionary::IIODictionary((IIODictionary *)v25, *((const __CFDictionary **)this[3] + 1), 1);
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v25, @"kCGImageDestinationMetadata");
    if (ObjectForKey) {
      CFTypeRef v5 = CFRetain(ObjectForKey);
    }
    else {
      CFTypeRef v5 = 0;
    }
    IIODictionary::removeObjectForKey((IIODictionary *)v25, @"kCGImageDestinationMetadata");
    if (*((unsigned char *)this + 34))
    {
      CFDictionaryRef v7 = (const void *)IIOImageSource::copyMetadataAtIndex(this[1], 0, v26);
      CFDictionaryRef v8 = IIOImageSource::copyPropertiesAtIndex(this[1], 0, v26);
    }
    else
    {
      CFDictionaryRef v7 = 0;
      CFDictionaryRef v8 = 0;
    }
    CGMutableImageMetadataRef Mutable = CGImageMetadataCreateMutable();
    CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)v7, (IIODictionary *)v26);
    IIODictionary::setObjectForKey((IIODictionary *)v26, (const void *)*MEMORY[0x1E4F1CFD0], @"kCGImageMetadataMergeOverwrite");
    CGImageMetadataMerge((uint64_t)Mutable, (uint64_t)v5, (IIODictionary *)v26);
    if (*((unsigned char *)this + 37)) {
      CGImageMetadataRemoveGPS((uint64_t)Mutable);
    }
    CFStringRef Type = (const __CFString *)IIOImageSource::getType((IIO_Reader **)this[1]);
    if (CFStringCompare(Type, @"public.jpeg", 0))
    {
      if (CFStringCompare(Type, @"public.heic", 0))
      {
        if (CFStringCompare(Type, @"public.png", 0))
        {
          if (CFStringCompare(Type, @"com.adobe.photoshop-image", 0))
          {
            if (CFStringCompare(Type, @"public.tiff", 0))
            {
              int v11 = (__CFString *)CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"image type '%@' is not supported for lossless metadata modification at this time.\n", Type);
              if (v11)
              {
                CGImageMetadataCreateAndLogError("updateDestination", 1, v11, a2);
                CFRelease(v11);
              }
              if ((gIIODebugFlags & 0x800000000000) != 0) {
                ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "updateDestination", 488, "*** ERROR: image type not supported\n");
              }
              goto LABEL_49;
            }
            uint64_t v23 = IIOMetadataUpdater::modifyTIFF(this, Mutable, a2);
            uint64_t v13 = v23;
            if ((gIIODebugFlags & 0x800000000000) != 0) {
              char v24 = v23;
            }
            else {
              char v24 = 1;
            }
            if (v24) {
              goto LABEL_50;
            }
            CFTypeID v15 = "*** ERROR: modifyTIFF failed\n";
            int v16 = 477;
          }
          else
          {
            BOOL v21 = IIOMetadataUpdater::modifyXMPOnlyFile(this, a2, Mutable, 1347634208);
            uint64_t v13 = v21;
            char v22 = (gIIODebugFlags & 0x800000000000) == 0 || v21;
            if (v22) {
              goto LABEL_50;
            }
            CFTypeID v15 = "*** ERROR: modifyPSD failed\n";
            int v16 = 471;
          }
        }
        else
        {
          BOOL v19 = IIOMetadataUpdater::modifyXMPOnlyFile(this, a2, Mutable, 1347307296);
          uint64_t v13 = v19;
          char v20 = (gIIODebugFlags & 0x800000000000) == 0 || v19;
          if (v20) {
            goto LABEL_50;
          }
          CFTypeID v15 = "*** ERROR: modifyPNG failed\n";
          int v16 = 465;
        }
      }
      else
      {
        BOOL v17 = IIOMetadataUpdater::modifyHEIC(this, Mutable, a2);
        uint64_t v13 = v17;
        char v18 = (gIIODebugFlags & 0x800000000000) == 0 || v17;
        if (v18) {
          goto LABEL_50;
        }
        CFTypeID v15 = "*** ERROR: modifyHEIC failed\n";
        int v16 = 459;
      }
    }
    else
    {
      uint64_t v12 = IIOMetadataUpdater::modifyJPEG(this, Mutable, a2);
      uint64_t v13 = v12;
      if ((gIIODebugFlags & 0x800000000000) != 0) {
        char v14 = v12;
      }
      else {
        char v14 = 1;
      }
      if (v14) {
        goto LABEL_50;
      }
      CFTypeID v15 = "*** ERROR: modifyJPEG failed\n";
      int v16 = 453;
    }
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "updateDestination", v16, v15);
LABEL_49:
    uint64_t v13 = 0;
LABEL_50:
    IIODictionary::~IIODictionary((IIODictionary *)v25);
    IIODictionary::~IIODictionary((IIODictionary *)v26);
    if (v5) {
      CFRelease(v5);
    }
    if (v7) {
      CFRelease(v7);
    }
    if (v8) {
      CFRelease(v8);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    return v13;
  }

  return IIOMetadataUpdater::copySourceToDestination(this);
}

void sub_1887F0D5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

uint64_t IIOMetadataUpdater::modifyJPEG(IIOImageSource **this, CGImageMetadata *a2, __CFError **a3)
{
  CFDataRef v4 = (IIOImageRead *)IIOImageSource::imageRead(this[1]);
  uint64_t result = (uint64_t)IIOImageRead::copyData(v4);
  if (result)
  {
    uint64_t v6 = (const void *)result;
    MutableCopdouble y = CFDataCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, (CFDataRef)result);
    CFRelease(v6);
    if (MutableCopy)
    {
      if (IIODictionary::getCount(this[3]) != 1
        || !IIODictionary::containsKey(this[3], @"kCGImageDestinationOrientation")
        || (unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(this[3], @"kCGImageDestinationOrientation"),
            !IIOMetadataUpdater::fastUpdateExifOrientationJPEG(Uint32ForKey, MutableCopy, (unsigned __int16)Uint32ForKey))|| (uint64_t v9 = (IIOImageWriteSession *)IIOImageSource::count(this[2]), BytePtr = CFDataGetBytePtr(MutableCopy), Length = CFDataGetLength(MutableCopy), v12 = IIOImageWriteSession::putBytes(v9, BytePtr, Length), v12 == CFDataGetLength(MutableCopy))&& IIOImageWriteSession::finalize(v9, 0))
      {
        operator new();
      }
      CFRelease(MutableCopy);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_1887F1064(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40FF95427CLL);
  _Unwind_Resume(a1);
}

BOOL IIOMetadataUpdater::modifyHEIC(IIOImageSource **this, CGImageMetadata *a2, __CFError **a3)
{
  CFDataRef v28 = 0;
  CFTypeRef v29 = 0;
  CFTypeRef v27 = 0;
  IIO_LoadHEIFSymbols();
  uint64_t v6 = (IIOImageRead *)IIOImageSource::imageRead(this[1]);
  CFDataRef v7 = IIOImageRead::copyData(v6);
  if (!v7)
  {
    BOOL v16 = 0;
    goto LABEL_17;
  }
  CFDataRef v8 = v7;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v24);
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v21);
  int v9 = gFunc_CMPhotoCompressionSessionCreate(*MEMORY[0x1E4F1CF80], v25, &v27);
  if (v9)
  {
    IIOCMErrorString(v9);
    _cg_jpeg_mem_term("modifyHEIC", 1424, "*** ERROR: CMPhotoCompressionSessionCreate returned %d (%s)\n");
  }
  else
  {
    IIONumber::IIONumber((IIONumber *)v19, 1);
    IIODictionary::setObjectForKey((IIODictionary *)&v21, value, *(const __CFString **)gIIO_kCMPhotoCompressionContainerOption_BackingType);
    IIONumber::~IIONumber((IIONumber *)v19);
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 0x40000000;
    v18[2] = ___ZN18IIOMetadataUpdater10modifyHEICEP15CGImageMetadataPP9__CFError_block_invoke;
    void v18[3] = &__block_descriptor_tmp_78;
    UInt8 v18[4] = this;
    void v18[5] = a3;
    v18[6] = a2;
    int v10 = gFunc_CMPhotoCompressionSessionOpenExistingContainerForModification(v27, v22, v8, &v29, v18);
    if (v10)
    {
      IIOCMErrorString(v10);
      _cg_jpeg_mem_term("modifyHEIC", 1500, "*** ERROR: CMPhotoCompressionSessionOpenExistingContainerForModification returned %d (%s)\n");
    }
    else
    {
      int v11 = gFunc_CMPhotoCompressionSessionCloseContainerAndCopyBacking(v27, 0, 0, &v28);
      if (v11)
      {
        IIOCMErrorString(v11);
        _cg_jpeg_mem_term("modifyHEIC", 1504, "*** ERROR: CMPhotoCompressionSessionCloseContainerAndCopyBacking returned %d (%s)\n");
      }
      else if (v28)
      {
        size_t v12 = (IIOImageWriteSession *)IIOImageSource::count(this[2]);
        BytePtr = CFDataGetBytePtr(v28);
        size_t Length = CFDataGetLength(v28);
        size_t v15 = IIOImageWriteSession::putBytes(v12, BytePtr, Length);
        if (v15 == CFDataGetLength(v28))
        {
          BOOL v16 = IIOImageWriteSession::finalize(v12, 0) == 0;
          goto LABEL_15;
        }
      }
      else
      {
        LogError("modifyHEIC", 1505, "*** ERROR: CMPhotoCompressionSessionCloseContainerAndCopyBacking returned noErr, but data is NULL\n");
      }
    }
  }
  BOOL v16 = 0;
LABEL_15:
  IIODictionary::~IIODictionary((IIODictionary *)&v21);
  IIODictionary::~IIODictionary((IIODictionary *)&v24);
  if (v27) {
    CFRelease(v27);
  }
LABEL_17:
  if (v28) {
    CFRelease(v28);
  }
  if (v29) {
    CFRelease(v29);
  }
  return v16;
}

void sub_1887F131C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  IIODictionary::~IIODictionary((IIODictionary *)(v14 - 96));
  _Unwind_Resume(a1);
}

uint64_t IIOMetadataUpdater::modifyTIFF(IIODictionary **this, CGImageMetadata *a2, __CFError **a3)
{
  IIO_InitializeXMPToolkit();
  if (*((unsigned char *)this + 39))
  {
    int Uint32ForKey = IIODictionary::getUint32ForKey(this[3], @"kCGImageDestinationOrientation");
    MetadataWithOrientation = IIOMetadataUpdater::createMetadataWithOrientation(this, Uint32ForKey, v8);
  }
  else if (*((unsigned char *)this + 38))
  {
    CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(this[3], @"kCGImageDestinationDateTime");
    MetadataWithOrientation = IIOMetadataUpdater::createMetadataWithDateTime(this, ObjectForKey, a3);
  }
  else
  {
    int v11 = 0;
    char v12 = 1;
    if (!a2 || !*((unsigned char *)this + 33)) {
      goto LABEL_13;
    }
    MetadataWithOrientation = IIOMetadataUpdater::createMetadataWithMetadata(this, a2, v6);
  }
  int v11 = MetadataWithOrientation;
  if (MetadataWithOrientation)
  {
    TagWithPath = (CGImageMetadataTag *)CGImageMetadataGetTagWithPath(MetadataWithOrientation, 0, @"photoshop:DateCreated");
    if (TagWithPath) {
      CGImageMetadataSetTagWithPath(v11, 0, @"exif:DateTimeOriginal", TagWithPath);
    }
    char v12 = 0;
  }
  else
  {
    char v12 = 1;
  }
LABEL_13:
  uint64_t v14 = (IIOImageRead *)IIOImageSource::imageRead(this[1]);
  CFDataRef v15 = IIOImageRead::copyData(v14);
  if (v15)
  {
    CFDataCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v15);
    Default_CTor();
  }
  IIO_TerminateXMPToolkit();
  if ((v12 & 1) == 0) {
    CFRelease(v11);
  }
  return 0;
}

CFTypeRef IIOMetadataUpdater::createModifiedJPEGWithOrientation(IIOMetadataUpdater *this, _JPEGFile **a2, int a3, __CFError **a4)
{
  CFTypeRef result = (CFTypeRef)_JPEGFile::findApp1ExifMarker(a2[10]);
  if (result)
  {
    if ((a3 - 9) < 0xFFFFFFF8) {
      unsigned __int16 v7 = 1;
    }
    else {
      unsigned __int16 v7 = a3;
    }
    (*(void (**)(CFTypeRef, void))(*(void *)result + 152))(result, v7);
    return _JPEGWriter::createData((_JPEGWriter *)a2);
  }
  return result;
}

CFTypeRef IIOMetadataUpdater::createModifiedJPEGWithDateTime(IIOMetadataUpdater *this, _JPEGFile **a2, const __CFString *cf, __CFError **a4)
{
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 == CFDateGetTypeID())
  {
    int v35 = a4;
    uint64_t v36 = (_JPEGWriter *)a2;
    CFLocaleRef v8 = CFLocaleCopyCurrent();
    CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    int v10 = CFDateFormatterCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v8, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
    CFDateFormatterSetFormat(v10, @"yyyy-MM-dd'T'HH:mm:ss.SSSZZZZ");
    int v11 = CFDateFormatterCreate(v9, v8, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
    CFDateFormatterSetFormat(v11, @"yyyy:MM:dd HH:mm:ss");
    char v12 = CFDateFormatterCreate(v9, v8, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
    CFDateFormatterSetFormat(v12, @"SSS");
    uint64_t v13 = CFDateFormatterCreate(v9, v8, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
    CFDateFormatterSetFormat(v13, @"yyyyMMdd");
    uint64_t v14 = CFDateFormatterCreate(v9, v8, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
    CFDateFormatterSetFormat(v14, @"HHmmssZZZ");
    CFStringRef StringWithDate = CFDateFormatterCreateStringWithDate(v9, v11, (CFDateRef)cf);
    CFStringRef v37 = CFDateFormatterCreateStringWithDate(v9, v12, (CFDateRef)cf);
    CFStringRef v15 = CFDateFormatterCreateStringWithDate(v9, v10, (CFDateRef)cf);
    if (v15)
    {
      CFStringRef v16 = v15;
      MutableCopdouble y = CFStringCreateMutableCopy(v9, 32, v15);
      if (MutableCopy)
      {
        v39.size_t length = CFStringGetLength(v16);
        v39.location = 0;
        CFStringFindAndReplace(MutableCopy, @"GMT", &stru_1ED4F1F48, v39, 0);
      }
      CFRelease(v16);
    }
    else
    {
      MutableCopdouble y = 0;
    }
    CFStringRef IPTCDateStringWithXMPDateTimeString = CFDateFormatterCreateStringWithDate(v9, v13, (CFDateRef)cf);
    CFStringRef IPTCTimeStringWithXMPDateTimeString = CFDateFormatterCreateStringWithDate(v9, v14, (CFDateRef)cf);
    CFRelease(v8);
    CFRelease(v10);
    CFRelease(v11);
    CFRelease(v12);
    CFRelease(v13);
    CFRelease(v14);
    a2 = (_JPEGFile **)v36;
    CFStringRef SubsecTimeFromXMPDateTime = v37;
    CFStringRef EXIFDataTimeStringWithXMPDateTimeString = StringWithDate;
    a4 = v35;
    if (StringWithDate)
    {
LABEL_18:
      if (EXIFDataTimeStringWithXMPDateTimeString && (uint64_t App1ExifMarker = _JPEGFile::findApp1ExifMarker(a2[10])) != 0)
      {
        uint64_t v25 = App1ExifMarker;
        int v26 = 1;
        CFTypeRef v27 = (char *)malloc_type_calloc(1uLL, 0x14uLL, 0x885DA183uLL);
        if (v27)
        {
          CFStringGetCString(EXIFDataTimeStringWithXMPDateTimeString, v27, 20, 0x600u);
          (*(void (**)(uint64_t, char *))(*(void *)v25 + 136))(v25, v27);
          if (SubsecTimeFromXMPDateTime && CFStringCompare(SubsecTimeFromXMPDateTime, @"000", 0))
          {
            size_t Length = CFStringGetLength(SubsecTimeFromXMPDateTime);
            int v26 = 1;
            CFTypeRef v29 = (char *)malloc_type_calloc(1uLL, Length, 0x1E1E7783uLL);
            if (!v29)
            {
              if (!MutableCopy) {
                goto LABEL_33;
              }
              goto LABEL_31;
            }
            CFIndex v30 = CFStringGetLength(SubsecTimeFromXMPDateTime);
            CFStringGetCString(SubsecTimeFromXMPDateTime, v29, v30 + 1, 0x600u);
            (*(void (**)(uint64_t, char *))(*(void *)v25 + 144))(v25, v29);
          }
          else
          {
            CFTypeRef v29 = 0;
          }
          int v26 = 1;
          if (!MutableCopy) {
            goto LABEL_33;
          }
        }
        else
        {
          CFTypeRef v29 = 0;
          if (!MutableCopy) {
            goto LABEL_33;
          }
        }
      }
      else
      {
        CFTypeRef v27 = 0;
        CFTypeRef v29 = 0;
        int v26 = 0;
        if (!MutableCopy) {
          goto LABEL_33;
        }
      }
LABEL_31:
      uint64_t v31 = (CGImageMetadata *)_JPEGFile::copyXMPProperties(a2[10]);
      if (v31)
      {
        uint64_t v32 = v31;
        CGImageMetadataSetValueWithPath(v31, 0, @"photoshop:DateCreated", MutableCopy);
        CGImageMetadataSetValueWithPath(v32, 0, @"xmp:CreateDate", MutableCopy);
        CGImageMetadataSetValueWithPath(v32, 0, @"xmp:ModifyDate", MutableCopy);
        _JPEGFile::setXMPProperties(a2[10], v32);
        CFRelease(v32);
        int v26 = 1;
      }
LABEL_33:
      if ((unint64_t)IPTCDateStringWithXMPDateTimeString | (unint64_t)IPTCTimeStringWithXMPDateTimeString) {
        _JPEGFile::copyIPTCProperties(a2[10]);
      }
      if (v26)
      {
        CFTypeRef Data = _JPEGWriter::createData((_JPEGWriter *)a2);
        if (!v27)
        {
LABEL_40:
          if (v29) {
            free(v29);
          }
          if (EXIFDataTimeStringWithXMPDateTimeString) {
            CFRelease(EXIFDataTimeStringWithXMPDateTimeString);
          }
          if (MutableCopy) {
            CFRelease(MutableCopy);
          }
          if (SubsecTimeFromXMPDateTime) {
            goto LABEL_47;
          }
          goto LABEL_48;
        }
      }
      else
      {
        CFTypeRef Data = 0;
        if (!v27) {
          goto LABEL_40;
        }
      }
      free(v27);
      goto LABEL_40;
    }
  }
  else
  {
    CFTypeID v18 = CFGetTypeID(cf);
    if (v18 == CFStringGetTypeID())
    {
      CFStringRef EXIFDataTimeStringWithXMPDateTimeString = CreateEXIFDataTimeStringWithXMPDateTimeString(cf);
      CFStringRef SubsecTimeFromXMPDateTime = CreateSubsecTimeFromXMPDateTime(cf);
      if (SubsecTimeFromXMPDateTime) {
        CFStringRef XMPDateFromXMPDateTimeAndSubsecTime = CreateXMPDateFromXMPDateTimeAndSubsecTime(cf, (uint64_t)SubsecTimeFromXMPDateTime);
      }
      else {
        CFStringRef XMPDateFromXMPDateTimeAndSubsecTime = CreateXMPDateTimeWithXMPOrExifDateTimeString(cf);
      }
      MutableCopdouble y = (__CFString *)XMPDateFromXMPDateTimeAndSubsecTime;
      CFStringRef IPTCDateStringWithXMPDateTimeString = CreateIPTCDateStringWithXMPDateTimeString(cf);
      CFStringRef IPTCTimeStringWithXMPDateTimeString = CreateIPTCTimeStringWithXMPDateTimeString(cf);
      if (EXIFDataTimeStringWithXMPDateTimeString) {
        goto LABEL_18;
      }
    }
    else
    {
      CFStringRef EXIFDataTimeStringWithXMPDateTimeString = 0;
      MutableCopdouble y = 0;
      CFStringRef IPTCDateStringWithXMPDateTimeString = 0;
      CFStringRef IPTCTimeStringWithXMPDateTimeString = 0;
      CFStringRef SubsecTimeFromXMPDateTime = 0;
    }
  }
  if (MutableCopy || IPTCDateStringWithXMPDateTimeString || IPTCTimeStringWithXMPDateTimeString) {
    goto LABEL_18;
  }
  CGImageMetadataCreateAndLogUTF8Error("createModifiedJPEGWithDateTime", 610, 2, "Could not parse kCGImageDestinationDateTime string - must be a valid EXIF DateTime or ISO8601 string", a4);
  CFTypeRef Data = 0;
  if (SubsecTimeFromXMPDateTime) {
LABEL_47:
  }
    CFRelease(SubsecTimeFromXMPDateTime);
LABEL_48:
  if (IPTCDateStringWithXMPDateTimeString) {
    CFRelease(IPTCDateStringWithXMPDateTimeString);
  }
  if (IPTCTimeStringWithXMPDateTimeString) {
    CFRelease(IPTCTimeStringWithXMPDateTimeString);
  }
  return Data;
}

CFTypeRef IIOMetadataUpdater::createModifiedJPEGWithMetadata(IIOMetadataUpdater *this, _JPEGWriter *a2, CFTypeRef cf, __CFError **a4)
{
  int v6 = (unsigned __int16)((*(_DWORD *)(*((void *)a2 + 10) + 80)
                                       - *(_DWORD *)(*((void *)a2 + 10) + 72)) >> 3);
  if (cf)
  {
    CFTypeID v7 = (const CGImageMetadata *)CFRetain(cf);
    if (v6)
    {
LABEL_3:
      int v8 = 0;
      char v9 = 0;
      CFDataRef v10 = 0;
      CFAllocatorRef v11 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
      while (1)
      {
        uint64_t v12 = _JPEGFile::appMarkerAtIndex(*((_JPEGFile **)a2 + 10), v8);
        uint64_t v13 = v12;
        if (*(unsigned char *)(v12 + 68))
        {
          uint64_t v14 = *(const UInt8 **)(v12 + 120);
          if (v14)
          {
            CFIndex v15 = *(unsigned int *)(v12 + 128);
            if (v15 && v10 == 0) {
              CFDataRef v10 = CFDataCreate(v11, v14, v15);
            }
          }
        }
        else if (!*(unsigned char *)(v12 + 69) && !*(unsigned char *)(v12 + 70))
        {
          v9 |= *(__int16 *)(v12 + 56) == -19;
          goto LABEL_15;
        }
        _JPEGFile::removeAppMarker(*((void *)a2 + 10), v13);
        --v8;
        --v6;
        (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
LABEL_15:
        if (++v8 >= v6) {
          goto LABEL_20;
        }
      }
    }
  }
  else
  {
    CFTypeID v7 = 0;
    if ((unsigned __int16)((*(_DWORD *)(*((void *)a2 + 10) + 80)
                                         - *(_DWORD *)(*((void *)a2 + 10) + 72)) >> 3))
      goto LABEL_3;
  }
  CFDataRef v10 = 0;
  char v9 = 0;
LABEL_20:
  BOOL v17 = (IIODictionary *)CGImagePropertiesCreateFromMetadata(v7);
  if (!v17) {
    operator new();
  }
  unint64_t v28 = 0;
  if (CreateExifBufferFromPropertiesJPEG(v17, 0, 0, 0, v10, @"public.jpeg", &v28)) {
    BOOL v18 = v28 == 0;
  }
  else {
    BOOL v18 = 1;
  }
  if (!v18) {
    operator new();
  }
  if (v9)
  {
    AppMarker = (void *)_JPEGFile::findAppMarker(*((_JPEGFile **)a2 + 10), 65517);
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(v17, @"{IPTC}");
    if (ObjectForKey)
    {
      memset(v27, 0, sizeof(v27));
      IIODictionary::IIODictionary((IIODictionary *)v27, ObjectForKey);
      CFIndex v21 = SizeOfIPTCData((IIODictionary *)v27);
      if (v21)
      {
        CGMutableImageMetadataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v21);
        uint64_t v23 = Mutable;
        if (Mutable)
        {
          CFDataSetLength(Mutable, v21);
          MutableBytePtr = CFDataGetMutableBytePtr(v23);
          WriteIPTCData(v27, MutableBytePtr);
          _APP13::setIPTCData(AppMarker, v23);
          CFRelease(v23);
        }
      }
      IIODictionary::~IIODictionary((IIODictionary *)v27);
    }
    else
    {
      _APP13::setIPTCData(AppMarker, 0);
    }
  }
  if (!*((unsigned char *)this + 36)) {
    _JPEGFile::setXMPProperties(*((_JPEGFile **)a2 + 10), v7);
  }
  CFTypeRef Data = _JPEGWriter::createData(a2);
  if (v7) {
    CFRelease(v7);
  }
  if (v10) {
    CFRelease(v10);
  }
  (*(void (**)(IIODictionary *))(*(void *)v17 + 8))(v17);
  return Data;
}

void sub_1887F214C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t IIOMetadataUpdater::fastUpdateExifOrientationJPEG(IIOMetadataUpdater *this, CFDataRef theData, unsigned int a3)
{
  BytePtr = (unsigned __int8 *)CFDataGetBytePtr(theData);
  unsigned int Length = CFDataGetLength(theData);
  uint64_t v25 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v21, BytePtr, Length, 0);
  uint64_t v7 = 0;
  int v20 = 0;
  uint64_t v19 = 0;
  if (IIOScanner::getVal16((IIOScanner *)&v21) != 65496) {
    goto LABEL_8;
  }
  while (1)
  {
    int Val16 = IIOScanner::getVal16((IIOScanner *)&v21);
    if (Val16 != 65505)
    {
      unsigned int v9 = IIOScanner::getVal16((IIOScanner *)&v21);
      goto LABEL_6;
    }
    unsigned int v9 = IIOScanner::getVal16((IIOScanner *)&v21);
    if (!strncmp((const char *)&BytePtr[*((void *)&v22 + 1)], "Exif", 4uLL)) {
      break;
    }
LABEL_6:
    IIOScanner::skip((uint64_t)&v21, v9 - 2);
    if (Val16 == 65499)
    {
LABEL_7:
      uint64_t v7 = 0;
      goto LABEL_8;
    }
  }
  IIOScanner::skip((uint64_t)&v21, 6);
  uint64_t v11 = *((void *)&v22 + 1);
  int v12 = IIOScanner::getVal16((IIOScanner *)&v21);
  if (v12 == 18761) {
    GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)&v21, 1);
  }
  IIOScanner::skip((uint64_t)&v21, 2);
  unsigned int Val32 = IIOScanner::getVal32((IIOScanner *)&v21);
  IIOScanner::seek((IIOScanner *)&v21, v11 + Val32);
  uint64_t v7 = IIOScanner::getVal16((IIOScanner *)&v21);
  if (v7)
  {
    int v14 = 0;
    while (1)
    {
      IIOScanner::getTiffTag((uint64_t)&v21, (uint64_t)&v19);
      BOOL v15 = (unsigned __int16)v19 == 274 && WORD1(v19) == 3;
      if (v15 && HIDWORD(v19) == 1) {
        break;
      }
      if (v7 <= (unsigned __int16)++v14) {
        goto LABEL_7;
      }
    }
    __int16 v17 = __rev16(a3);
    if (BYTE4(v25)) {
      __int16 v18 = a3;
    }
    else {
      __int16 v18 = v17;
    }
    *(_WORD *)&BytePtr[*((void *)&v22 + 1) - 4] = v18;
    uint64_t v7 = 1;
  }
LABEL_8:
  IIOScanner::~IIOScanner((IIOScanner *)&v21);
  return v7;
}

void sub_1887F2380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

__CFData *IIOMetadataUpdater::createExifChunkData(IIOMetadataUpdater *this, IIODictionary *a2, uint64_t a3, unsigned int a4)
{
  CFIndex length = 0;
  uint64_t ExifBufferFromPropertiesJPEG = CreateExifBufferFromPropertiesJPEG(a2, a3, a4, 0, 0, @"public.jpeg", (unint64_t *)&length);
  if (!ExifBufferFromPropertiesJPEG) {
    return 0;
  }
  CFTypeRef v5 = (UInt8 *)ExifBufferFromPropertiesJPEG;
  if ((unint64_t)length < 0x1F)
  {
    uint64_t v7 = 0;
  }
  else
  {
    length -= 2;
    *(_DWORD *)(ExifBufferFromPropertiesJPEG + 2) = 1716082789;
    *(_DWORD *)bytes = bswap32(length - 4);
    CGMutableImageMetadataRef Mutable = CFDataCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
    uint64_t v7 = Mutable;
    if (Mutable)
    {
      CFDataAppendBytes(Mutable, bytes, 4);
      CFDataAppendBytes(v7, v5 + 2, length);
      uLong v8 = crc32(0, 0, 0);
      unsigned int v10 = bswap32(crc32(v8, v5 + 2, length));
      CFDataAppendBytes(v7, (const UInt8 *)&v10, 4);
    }
  }
  free(v5);
  return v7;
}

BOOL IIOMetadataUpdater::updatePNGExifData(IIOMetadataUpdater *this, CFDataRef theData, IIODictionary *a3, int a4, char a5)
{
  uint64_t v20 = 0;
  long long v21 = &v20;
  uint64_t v22 = 0x2000000000;
  char v23 = 0;
  v18[0] = 0;
  v18[1] = v18;
  v18[2] = 0x2000000000;
  int v19 = 0;
  v16[0] = 0;
  v16[1] = v16;
  v16[2] = 0x2000000000;
  int v17 = 0;
  BytePtr = (unsigned __int8 *)CFDataGetBytePtr(theData);
  unsigned int Length = CFDataGetLength(theData);
  if (!a4 || (a5 & 1) != 0)
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 0x40000000;
    v13[2] = ___ZN18IIOMetadataUpdater17updatePNGExifDataEP8__CFDataP13IIODictionarybb_block_invoke;
    void v13[3] = &unk_1E53C03A8;
    _OWORD v13[4] = v18;
    void v13[5] = v16;
    char v14 = a4;
    char v15 = a5;
    v13[8] = BytePtr;
    v13[9] = theData;
    v13[6] = &v20;
    void v13[7] = this;
    EnumeratePNGUsingBlock(BytePtr, Length, (uint64_t)v13);
    BOOL v11 = *((unsigned char *)v21 + 24) != 0;
  }
  else
  {
    BOOL v11 = 0;
  }
  _Block_object_dispose(v16, 8);
  _Block_object_dispose(v18, 8);
  _Block_object_dispose(&v20, 8);
  return v11;
}

void sub_1887F260C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 112), 8);
  _Block_object_dispose((const void *)(v13 - 80), 8);
  _Unwind_Resume(a1);
}

unsigned __int8 *EnumeratePNGUsingBlock(unsigned __int8 *result, unsigned int a2, uint64_t a3)
{
  char v9 = 0;
  if (*result == 137)
  {
    CFDataRef v3 = result;
    if (result[1] == 80 && result[2] == 78 && result[3] == 71)
    {
      unint64_t v5 = 8;
      unint64_t v6 = a2;
      do
      {
        while (1)
        {
          v8[1] = v5;
          v8[0] = vrev64_s32((int32x2_t)vrev32_s8(*(int8x8_t *)&v3[v5]));
          if (!a3) {
            break;
          }
          CFTypeRef result = (unsigned __int8 *)(*(uint64_t (**)(uint64_t, void *, char *))(a3 + 16))(a3, v8, &v9);
          if (result != -1) {
            break;
          }
          if (LODWORD(v8[0]) == 1229278788) {
            return result;
          }
        }
        if (v9) {
          break;
        }
        v5 += HIDWORD(v8[0]) + 12;
      }
      while (v5 <= v6 && LODWORD(v8[0]) != 1229278788);
    }
  }
  return result;
}

uint64_t ___ZN18IIOMetadataUpdater17updatePNGExifDataEP8__CFDataP13IIODictionarybb_block_invoke(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = 0;
  uint64_t v7 = *(void *)(a1 + 56);
  int v8 = *(_DWORD *)a2;
  if (*(int *)a2 > 1700284741)
  {
    if (v8 == 1700284742)
    {
      v29.location = *(void *)(a2 + 8);
      v29.CFIndex length = (*(_DWORD *)(a2 + 4) + 12);
      CFDataReplaceBytes(*(CFMutableDataRef *)(a1 + 72), v29, 0, 0);
      return 0xFFFFFFFFLL;
    }
    if (v8 == 1700284774)
    {
      CFIndex v14 = *(void *)(a2 + 8);
      int v15 = *(_DWORD *)(a2 + 4);
      MetadataFromDataUInt8 buffer = CreateMetadataFromDatabuffer((const char *)(*(void *)(a1 + 64) + v14 + 8), (v15 - 8));
      if (MetadataFromDatabuffer)
      {
        int v17 = (void *)MetadataFromDatabuffer;
        v30.CFIndex length = (v15 + 12);
        v30.location = v14;
        CFDataReplaceBytes(*(CFMutableDataRef *)(a1 + 72), v30, 0, 0);
        uint64_t v18 = CGImagePropertiesCreateFromMetadata(v17);
        if (v18)
        {
          int v19 = (IIODictionary *)v18;
          if (IIODictionary::containsKey(*(IIODictionary **)(v7 + 24), @"kCGImageDestinationOrientation"))
          {
            int Uint32ForKey = IIODictionary::getUint32ForKey(*(IIODictionary **)(v7 + 24), @"kCGImageDestinationOrientation");
            IIONumber::IIONumber((IIONumber *)v25, Uint32ForKey);
            IIODictionary::setObjectForKey((uint64_t)v19, (uint64_t)v25, @"Orientation");
            IIONumber::~IIONumber((IIONumber *)v25);
          }
          unsigned int Count = IIODictionary::getCount(v19);
          if (Count)
          {
            ExifChunkCFTypeRef Data = IIOMetadataUpdater::createExifChunkData(Count, v19, *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
            BytePtr = CFDataGetBytePtr(ExifChunkData);
            unsigned int Length = CFDataGetLength(ExifChunkData);
            v31.location = *(void *)(a2 + 8);
            v31.CFIndex length = 0;
            CFDataReplaceBytes(*(CFMutableDataRef *)(a1 + 72), v31, BytePtr, Length);
            CFRelease(ExifChunkData);
            *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
          }
          (*(void (**)(IIODictionary *))(*(void *)v19 + 8))(v19);
        }
        CFRelease(v17);
      }
      goto LABEL_26;
    }
    if (v8 != 1766084436) {
      return result;
    }
LABEL_10:
    if (!*(unsigned char *)(a1 + 80) && !*(unsigned char *)(a1 + 81))
    {
      memset(v27, 0, sizeof(v27));
      IIODictionary::IIODictionary((IIODictionary *)v27);
      if (IIODictionary::containsKey(*(IIODictionary **)(v7 + 24), @"kCGImageDestinationOrientation"))
      {
        int v9 = IIODictionary::getUint32ForKey(*(IIODictionary **)(v7 + 24), @"kCGImageDestinationOrientation");
        IIONumber::IIONumber((IIONumber *)v26, v9);
        IIODictionary::setObjectForKey((uint64_t)v27, (uint64_t)v26, @"Orientation");
        IIONumber::~IIONumber((IIONumber *)v26);
      }
      unsigned int v10 = IIODictionary::getCount((IIODictionary *)v27);
      if (v10)
      {
        BOOL v11 = IIOMetadataUpdater::createExifChunkData(v10, (IIODictionary *)v27, *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
        int v12 = CFDataGetBytePtr(v11);
        unsigned int v13 = CFDataGetLength(v11);
        v28.location = *(void *)(a2 + 8);
        v28.CFIndex length = 0;
        CFDataReplaceBytes(*(CFMutableDataRef *)(a1 + 72), v28, v12, v13);
        CFRelease(v11);
        *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
      }
      IIODictionary::~IIODictionary((IIODictionary *)v27);
    }
LABEL_26:
    uint64_t result = 0;
    *a3 = 1;
    return result;
  }
  if (v8 == 1229209940) {
    goto LABEL_10;
  }
  if (v8 == 1229472850)
  {
    uint64_t result = 0;
    if (*(_DWORD *)(a2 + 4) >= 0xDu)
    {
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(*(void *)(a1 + 64)
                                                                              + *(void *)(a2 + 8)
                                                                              + 8);
      *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = *(_DWORD *)(*(void *)(a1 + 64)
                                                                              + *(void *)(a2 + 8)
                                                                              + 12);
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = bswap32(*(_DWORD *)(*(void *)(*(void *)(a1 + 32)
                                                                                                  + 8)
                                                                                      + 24));
      *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = bswap32(*(_DWORD *)(*(void *)(*(void *)(a1 + 40)
                                                                                                  + 8)
                                                                                      + 24));
    }
  }
  return result;
}

void sub_1887F2AC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  IIONumber::~IIONumber((IIONumber *)va);
  IIODictionary::~IIODictionary((IIODictionary *)va1);
  _Unwind_Resume(a1);
}

BOOL IIOMetadataUpdater::modifyXMPOnlyFile(IIODictionary **this, __CFError **a2, CGImageMetadata *a3, int a4)
{
  uint64_t v35 = 0;
  uint64_t v36 = &v35;
  uint64_t v37 = 0x2000000000;
  char v38 = 0;
  uint64_t v31 = 0;
  uint64_t v32 = &v31;
  uint64_t v33 = 0x2000000000;
  char v34 = 0;
  IIO_InitializeXMPToolkit();
  if (*((unsigned char *)this + 39))
  {
    int Uint32ForKey = IIODictionary::getUint32ForKey(this[3], @"kCGImageDestinationOrientation");
    MetadataWithOrientation = IIOMetadataUpdater::createMetadataWithOrientation(this, Uint32ForKey, v10);
  }
  else if (*((unsigned char *)this + 38))
  {
    CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(this[3], @"kCGImageDestinationDateTime");
    MetadataWithOrientation = IIOMetadataUpdater::createMetadataWithDateTime(this, ObjectForKey, a2);
  }
  else
  {
    if (!*((unsigned char *)this + 33))
    {
      BOOL v14 = 0;
      unsigned int v13 = 0;
      goto LABEL_12;
    }
    MetadataWithOrientation = IIOMetadataUpdater::createMetadataWithMetadata(this, a3, v8);
  }
  unsigned int v13 = MetadataWithOrientation;
  BOOL v14 = MetadataWithOrientation != 0;
  if (a4 == 1347634208 && MetadataWithOrientation)
  {
    TagWithPath = (CGImageMetadataTag *)CGImageMetadataGetTagWithPath(MetadataWithOrientation, 0, @"photoshop:DateCreated");
    if (TagWithPath) {
      CGImageMetadataSetTagWithPath(v13, 0, @"exif:DateTimeOriginal", TagWithPath);
    }
    BOOL v14 = 1;
  }
LABEL_12:
  CFStringRef v16 = (IIOImageRead *)IIOImageSource::imageRead(this[1]);
  CFDataRef v17 = IIOImageRead::copyData(v16);
  if (!v17)
  {
    BOOL v24 = 0;
    goto LABEL_34;
  }
  MutableCopdouble y = CFDataCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v17);
  if (a4 == 1347307296)
  {
    BytePtr = (unsigned __int8 *)CFDataGetBytePtr(v17);
    unsigned int Length = CFDataGetLength(v17);
    v30[0] = MEMORY[0x1E4F143A8];
    v30[1] = 0x40000000;
    v30[2] = ___ZN18IIOMetadataUpdater17modifyXMPOnlyFileEPP9__CFErrorP15CGImageMetadataj_block_invoke;
    v30[3] = &unk_1E53CD1C8;
    v30[4] = &v35;
    v30[5] = &v31;
    v30[6] = BytePtr;
    EnumeratePNGUsingBlock(BytePtr, Length, (uint64_t)v30);
    if (*((unsigned char *)v36 + 24)) {
      BOOL v22 = *((unsigned char *)v32 + 24) != 0;
    }
    else {
      BOOL v22 = 1;
    }
    if (*((unsigned char *)v36 + 24)) {
      BOOL v23 = v14;
    }
    else {
      BOOL v23 = 0;
    }
    if (v23
      && !IIOMetadataUpdater::updatePNGExifData((IIOMetadataUpdater *)this, MutableCopy, v21, *((unsigned __int8 *)v32 + 24) != 0, 1))
    {
      _cg_jpeg_mem_term("modifyXMPOnlyFile", 1313, "*** ERROR: UpdatePNGExifData did not update Exif\n");
    }
    else if (!v22)
    {
      goto LABEL_29;
    }
LABEL_28:
    Default_CTor();
  }
  if (a4 == 1347634208) {
    goto LABEL_28;
  }
LABEL_29:
  uint64_t v25 = (IIOImageWriteSession *)IIOImageSource::count(this[2]);
  int v26 = CFDataGetBytePtr(MutableCopy);
  size_t v27 = CFDataGetLength(MutableCopy);
  size_t v28 = IIOImageWriteSession::putBytes(v25, v26, v27);
  if (v28 != CFDataGetLength(MutableCopy))
  {
    BOOL v24 = 0;
    if (!MutableCopy) {
      goto LABEL_34;
    }
    goto LABEL_33;
  }
  BOOL v24 = IIOImageWriteSession::finalize(v25, 0) == 0;
  if (MutableCopy) {
LABEL_33:
  }
    CFRelease(MutableCopy);
LABEL_34:
  IIO_TerminateXMPToolkit();
  if (v17) {
    CFRelease(v17);
  }
  if (v14) {
    CFRelease(v13);
  }
  _Block_object_dispose(&v31, 8);
  _Block_object_dispose(&v35, 8);
  return v24;
}

#error "1887F2F8C: call analysis failed (funcsize=29)"

void sub_1887F306C(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  ImageIO_XMP_IO::~ImageIO_XMP_IO((ImageIO_XMP_IO *)va);
  JUMPOUT(0x1887F3024);
}

void sub_1887F30A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZN18IIOMetadataUpdater17modifyXMPOnlyFileEPP9__CFErrorP15CGImageMetadataj_block_invoke(void *a1, int *a2)
{
  int v3 = *a2;
  if (*a2 == 1700284742) {
    goto LABEL_4;
  }
  if (v3 == 1767135348)
  {
    if (a2[1] >= 0x1E
      && !strncmp((const char *)(a1[6] + *((void *)a2 + 1) + 8), "XML:com.adobe.xmp", 0x11uLL))
    {
      uint64_t v4 = a1[5];
      goto LABEL_5;
    }
  }
  else if (v3 == 1700284774)
  {
LABEL_4:
    uint64_t v4 = a1[4];
LABEL_5:
    *(unsigned char *)(*(void *)(v4 + 8) + 24) = 1;
  }
  return 0;
}

uint64_t ___ZN18IIOMetadataUpdater10modifyHEICEP15CGImageMetadataPP9__CFError_block_invoke(uint64_t a1, CFDictionaryRef theDict)
{
  uint64_t v3 = *(void *)(a1 + 32);
  memset(v9, 0, sizeof(v9));
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(theDict, @"ImageList");
  unint64_t v5 = IIOArray::IIOArray((IIOArray *)v9, Value);
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 0x40000000;
  BOOL v7[2] = ___ZN18IIOMetadataUpdater10modifyHEICEP15CGImageMetadataPP9__CFError_block_invoke_2;
  void v7[3] = &__block_descriptor_tmp_76;
  UInt8 v7[4] = v3;
  long long v8 = *(_OWORD *)(a1 + 40);
  IIOArray::enumerate((uint64_t)v5, (uint64_t)v7);
  IIOArray::~IIOArray((IIOArray *)v9);
  return 0;
}

void sub_1887F3220(_Unwind_Exception *a1)
{
  IIOArray::~IIOArray((IIOArray *)(v1 - 40));
  _Unwind_Resume(a1);
}

void ___ZN18IIOMetadataUpdater10modifyHEICEP15CGImageMetadataPP9__CFError_block_invoke_2(uint64_t a1, __CFDictionary *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  memset(v18, 0, sizeof(v18));
  IIODictionary::IIODictionary((IIODictionary *)v18, a2);
  if (!*(unsigned char *)(v3 + 39))
  {
    if (*(unsigned char *)(v3 + 38))
    {
      CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey(*(IIODictionary **)(v3 + 24), @"kCGImageDestinationDateTime");
      MetadataWithDateTime = IIOMetadataUpdater::createMetadataWithDateTime((IIOImageSource **)v3, ObjectForKey, *(__CFError ***)(a1 + 40));
    }
    else
    {
      if (!*(unsigned char *)(v3 + 34) && !*(unsigned char *)(v3 + 35))
      {
        MetadataWithOrientation = 0;
        goto LABEL_14;
      }
      MetadataWithDateTime = IIOMetadataUpdater::createMetadataWithMetadata((IIOImageSource **)v3, *(const CGImageMetadata **)(a1 + 48), v4);
    }
    MetadataWithOrientation = MetadataWithDateTime;
    if (MetadataWithDateTime) {
      goto LABEL_10;
    }
LABEL_14:
    char v11 = 1;
    goto LABEL_15;
  }
  int Uint32ForKey = IIODictionary::getUint32ForKey(*(IIODictionary **)(v3 + 24), @"kCGImageDestinationOrientation");
  IIONumber::IIONumber((IIONumber *)v17, Uint32ForKey);
  IIODictionary::setObjectForKey((uint64_t)v18, (uint64_t)v17, *(const void **)gIIO_kCMPhotoCompressionContainerDescription_Orientation);
  IIONumber::~IIONumber((IIONumber *)v17);
  MetadataWithOrientation = IIOMetadataUpdater::createMetadataWithOrientation((IIOImageSource **)v3, Uint32ForKey, v6);
  CFMutableArrayRef v14 = 0;
  int v15 = 0;
  CFTypeRef value = 0;
  IIONumber::IIONumber((IIONumber *)&v14, Uint32ForKey);
  IIODictionary::setObjectForKey((IIODictionary *)v18, value, @"Orientation");
  IIODictionary::setObjectForKeyGroup((IIODictionary *)v18, value, @"Orientation", @"{Exif}");
  IIONumber::~IIONumber((IIONumber *)&v14);
  if (!MetadataWithOrientation) {
    goto LABEL_14;
  }
LABEL_10:
  TagWithPath = (CGImageMetadataTag *)CGImageMetadataGetTagWithPath(MetadataWithOrientation, 0, @"photoshop:DateCreated");
  if (TagWithPath) {
    CGImageMetadataSetTagWithPath(MetadataWithOrientation, 0, @"exif:DateTimeOriginal", TagWithPath);
  }
  char v11 = 0;
LABEL_15:
  CFDataRef XMPWithEXIFFiltered = CGImageMetadataCreateXMPWithEXIFFiltered(MetadataWithOrientation);
  if (XMPWithEXIFFiltered)
  {
    CFMutableArrayRef v14 = 0;
    int v15 = 0;
    CFTypeRef value = 0;
    IIOArray::IIOArray((IIOArray *)&v14);
    IIOArray::addObject(&v14, XMPWithEXIFFiltered);
    IIODictionary::setObjectForKey((IIODictionary *)v18, v15, *(const __CFString **)gIIO_kCMPhotoCompressionContainerDescription_XMPMetadata);
    CFRelease(XMPWithEXIFFiltered);
    IIOArray::~IIOArray((IIOArray *)&v14);
  }
  if (*(unsigned char *)(v3 + 35) || *(unsigned char *)(v3 + 36) || *(unsigned char *)(v3 + 37))
  {
    EXIFCFTypeRef Data = CGImageMetadataCreateEXIFData(MetadataWithOrientation);
    if (EXIFData)
    {
      CFMutableArrayRef v14 = 0;
      int v15 = 0;
      CFTypeRef value = 0;
      IIOArray::IIOArray((IIOArray *)&v14);
      IIOArray::addObject(&v14, EXIFData);
      IIODictionary::setObjectForKey((IIODictionary *)v18, v15, *(const __CFString **)gIIO_kCMPhotoCompressionContainerDescription_EXIFMetadata);
      CFRelease(EXIFData);
      IIOArray::~IIOArray((IIOArray *)&v14);
    }
  }
  if ((v11 & 1) == 0) {
    CFRelease(MetadataWithOrientation);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v18);
}

void sub_1887F34A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void IIO_Writer::~IIO_Writer(IIO_Writer *this)
{
}

uint64_t IIO_Writer::canWriteDepth(IIO_Writer *this)
{
  return 0;
}

uint64_t IIO_Writer::matchesExtension(IIO_Writer *this, char *a2)
{
  return 0;
}

void IIO_Writer::addImageWriteFormats(IIO_Writer *this, CFMutableArrayRef theArray)
{
  int v4 = *((_DWORD *)this + 10);
  if (v4)
  {
    CFArrayAppendValue(theArray, @"kCGImageDestinationCanRGB");
    if ((v4 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0) {
        goto LABEL_4;
      }
      goto LABEL_25;
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  CFArrayAppendValue(theArray, @"kCGImageDestinationCanCMYK");
  if ((v4 & 4) == 0)
  {
LABEL_4:
    if ((v4 & 8) == 0) {
      goto LABEL_5;
    }
    goto LABEL_26;
  }
LABEL_25:
  CFArrayAppendValue(theArray, @"kCGImageDestinationCanGray");
  if ((v4 & 8) == 0)
  {
LABEL_5:
    if ((v4 & 0x10) == 0) {
      goto LABEL_6;
    }
    goto LABEL_27;
  }
LABEL_26:
  CFArrayAppendValue(theArray, @"kCGImageDestinationCanLab");
  if ((v4 & 0x10) == 0)
  {
LABEL_6:
    if ((v4 & 0x40000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_28;
  }
LABEL_27:
  CFArrayAppendValue(theArray, @"kCGImageDestinationCanRGBIdx");
  if ((v4 & 0x40000) == 0)
  {
LABEL_7:
    if ((v4 & 0x100) == 0) {
      goto LABEL_8;
    }
    goto LABEL_29;
  }
LABEL_28:
  CFArrayAppendValue(theArray, @"kCGImageDestinationCanICC");
  if ((v4 & 0x100) == 0)
  {
LABEL_8:
    if ((v4 & 0x200) == 0) {
      goto LABEL_9;
    }
    goto LABEL_30;
  }
LABEL_29:
  CFArrayAppendValue(theArray, @"kCGImageDestinationCan1BPS");
  if ((v4 & 0x200) == 0)
  {
LABEL_9:
    if ((v4 & 0x400) == 0) {
      goto LABEL_10;
    }
    goto LABEL_31;
  }
LABEL_30:
  CFArrayAppendValue(theArray, @"kCGImageDestinationCan2BPS");
  if ((v4 & 0x400) == 0)
  {
LABEL_10:
    if ((v4 & 0x800) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_31:
  CFArrayAppendValue(theArray, @"kCGImageDestinationCan4BPS");
  if ((v4 & 0x800) != 0) {
LABEL_11:
  }
    CFArrayAppendValue(theArray, @"kCGImageDestinationCan8BPS");
LABEL_12:
  if ((v4 & 0x5000) != 0) {
    CFArrayAppendValue(theArray, @"kCGImageDestinationCan16BPS");
  }
  if ((v4 & 0x10000) != 0) {
    CFArrayAppendValue(theArray, @"kCGImageDestinationCan16fBPS");
  }
  if ((v4 & 0xA000) != 0) {
    CFArrayAppendValue(theArray, @"kCGImageDestinationCan32fBPS");
  }
  if ((v4 & 0x1E000000) != 0) {
    CFArrayAppendValue(theArray, @"kCGImageDestinationCanAlpha");
  }
  if (*((void *)this + 4) == -1)
  {
    CFArrayAppendValue(theArray, @"kCGImageDestinationCanMultiPage");
    if ((v4 & 0x20000) == 0) {
      return;
    }
  }
  else if ((v4 & 0x20000) == 0)
  {
    return;
  }

  CFArrayAppendValue(theArray, @"kCGImageDestinationCanWriteOrientation");
}

void IIOGeneric_Writer::~IIOGeneric_Writer(IIOGeneric_Writer *this)
{
}

uint64_t IIO_Writer::write(IIO_Writer *this, void *a2, void *a3)
{
  return 0;
}

uint64_t _cg_png_read_frame_head(uint64_t result, _DWORD *a2)
{
  uLong v2 = result;
  if ((*(unsigned char *)(result + 78) & 1) == 0)
  {
    unsigned int v10 = "attempt to png_read_frame_head() but no acTL present";
    goto LABEL_20;
  }
  if (!*(_DWORD *)(result + 784)) {
    return result;
  }
  png_read_reset(result);
  int v4 = 0;
  *(int8x8_t *)(v2 + 76) = vand_s8(*(int8x8_t *)(v2 + 76), (int8x8_t)0xFFFFFFBFFFFDFFFFLL);
  while (1)
  {
    uint64_t chunk_header = _cg_png_read_chunk_header(v2);
    int v6 = *(_DWORD *)(v2 + 312);
    if (v6 == 1717846356) {
      break;
    }
    if (v6 == 1717785676)
    {
      png_handle_fcTL(v2, a2, chunk_header);
      int v4 = 1;
    }
    else if (v6 == 1229209940)
    {
      if (v4 || *(_DWORD *)(v2 + 784) >= 2u)
      {
        unsigned int v10 = "png_read_frame_head(): out of place IDAT";
        goto LABEL_20;
      }
      uint64_t v8 = v2;
      uint64_t v7 = chunk_header;
LABEL_15:
      png_crc_finish(v8, v7);
      int v4 = 0;
    }
    else
    {
      png_warning(v2, "Skipped (ignored) a chunk between APNG chunks");
      png_crc_finish(v2, chunk_header);
    }
  }
  uint64_t result = png_ensure_sequence_number(v2, chunk_header);
  if (!v4 && *(_DWORD *)(v2 + 784) >= 2u)
  {
    uint64_t v7 = (chunk_header - 4);
    uint64_t v8 = v2;
    goto LABEL_15;
  }
  int v9 = *(_DWORD *)(v2 + 76);
  if ((v9 & 0x20000) == 0)
  {
    unsigned int v10 = "png_read_frame_head(): out of place fdAT";
LABEL_20:
    _cg_png_error((void (**)(void))v2, v10);
  }
  *(_DWORD *)(v2 + 360) = chunk_header - 4;
  *(_DWORD *)(v2 + 76) = v9 | 4;
  return result;
}

void *RADReadPlugin::RADReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result = (void *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *uint64_t result = &unk_1ED4E0B30;
  return result;
}

void RADReadPlugin::RADReadPlugin(uint64_t a1, uint64_t a2)
{
}

void RADReadPlugin::~RADReadPlugin(RADReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t RADReadPlugin::loadDataFromXPCObject(RADReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    CFDictionaryRef data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_rad", &length);
    if (length == 1)
    {
      int v6 = data;
      uint64_t result = 0;
      *((unsigned char *)this + 436) = *v6;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t RADReadPlugin::saveDataToXPCObject(RADReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_rad", (char *)this + 436, 1uLL);
  }
  return v4;
}

uint64_t RADReadPlugin::initialize(IIODictionary **this, IIODictionary *a2)
{
  uint64_t v18 = 0;
  BOOL BoolForKey = IIODictionary::getBoolForKey(this[6], @"kCGImageSourceShouldAllowFloat");
  if (!*((unsigned char *)this + 341) || (BOOL v4 = BoolForKey, (FILE = IIOImageReadSession::createFILE(this[3])) == 0))
  {
    uint64_t v16 = 4294967246;
LABEL_17:
    kdebug_trace();
    return v16;
  }
  int v6 = FILE;
  uint64_t v7 = _cg_RadReadRGBSize(FILE, (_DWORD *)&v18 + 1, &v18);
  if (v7)
  {
    uint64_t v16 = v7;
    fclose(v6);
    goto LABEL_17;
  }
  if (v4) {
    __int16 v8 = 32;
  }
  else {
    __int16 v8 = 16;
  }
  if (v4) {
    char v9 = 2;
  }
  else {
    char v9 = 1;
  }
  *((_WORD *)this + 120) = v8;
  *((unsigned char *)this + 345) = 1;
  *((unsigned char *)this + 247) = v9;
  int v11 = v18;
  int v10 = HIDWORD(v18);
  *((_DWORD *)this + 57) = HIDWORD(v18);
  *((_DWORD *)this + 58) = v11;
  *((_WORD *)this + 121) = 4 * v8;
  if (v4) {
    char v12 = 7;
  }
  else {
    char v12 = 6;
  }
  int v13 = v10 << v12;
  int v14 = v13 | 7;
  int v15 = v13 | 0xE;
  if (v14 >= 0) {
    int v15 = v14;
  }
  *((_DWORD *)this + 59) = v15 >> 3;
  *((_DWORD *)this + 81) = 1380401696;
  this[20] = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBE0]);
  *((unsigned char *)this + 246) = 5;
  *((unsigned char *)this + 346) = 0;
  *((unsigned char *)this + 344) = 1;
  this[45] = (IIODictionary *)1;
  *((_WORD *)this + 122) = *((_WORD *)this + 121) / *((_WORD *)this + 120);
  *((_WORD *)this + 188) = 1;
  fclose(v6);
  return 0;
}

uint64_t RADReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12) {
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2);
  }
  if (v2 == 1) {
    return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

uint64_t RADReadPlugin::decodeImageImp(uint64_t a1, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  unint64_t v37 = 0;
  *(_DWORD *)(a1 + 300) = *(_DWORD *)(a1 + 268);
  IIOImageReadSession::rewind(*(void *)(a1 + 24));
  if ((gIIODebugFlags & 0x20000) == 0) {
    goto LABEL_26;
  }
  int v8 = *(_DWORD *)(a1 + 204);
  unsigned int v9 = v8 >> 24;
  uint64_t v10 = MEMORY[0x1E4F14390];
  if (v8 < 0)
  {
    int v11 = __maskrune(v9, 0x40000uLL);
    int v8 = *(_DWORD *)(a1 + 204);
  }
  else
  {
    int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
  }
  if (v11) {
    uint64_t v12 = (v8 >> 24);
  }
  else {
    uint64_t v12 = 46;
  }
  unsigned int v13 = v8 << 8 >> 24;
  if (v8 << 8 < 0)
  {
    int v14 = __maskrune(v13, 0x40000uLL);
    int v8 = *(_DWORD *)(a1 + 204);
  }
  else
  {
    int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
  }
  if (v14) {
    uint64_t v15 = (v8 << 8 >> 24);
  }
  else {
    uint64_t v15 = 46;
  }
  unsigned int v16 = (__int16)v8 >> 8;
  if (v8 << 16 < 0)
  {
    int v17 = __maskrune(v16, 0x40000uLL);
    int v8 = *(_DWORD *)(a1 + 204);
  }
  else
  {
    int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  }
  if (v17) {
    uint64_t v18 = ((__int16)v8 >> 8);
  }
  else {
    uint64_t v18 = 46;
  }
  if ((v8 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0) {
      goto LABEL_22;
    }
LABEL_24:
    uint64_t v19 = 46;
    goto LABEL_25;
  }
  if (!__maskrune((char)v8, 0x40000uLL)) {
    goto LABEL_24;
  }
LABEL_22:
  uint64_t v19 = *(char *)(a1 + 204);
LABEL_25:
  ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus RADReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
LABEL_26:
  IIOReadPlugin::debugDecodeImage((IIOReadPlugin *)a1, a2);
  uint64_t v20 = *(IIOImageRead ***)(a1 + 24);
  if (v20) {
    BOOL v21 = IIOImageReadSession::mapData(v20);
  }
  else {
    BOOL v21 = 0;
  }
  if (a3 == 3)
  {
    uint64_t BlockArray = IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
    LODWORD(v27) = *(_DWORD *)(a1 + 292);
    double v26 = (double)v27;
    unsigned int v28 = *(_DWORD *)(a1 + 296);
    double v25 = (double)v28;
    BaseAddress = (void *)_ImageIO_Malloc(*(unsigned int *)(a1 + 300) * (unint64_t)v28, *(void *)(a1 + 384), &v37, (uint64_t)kImageMalloc_RAD_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
    {
      uint64_t BlockArray = 4294967243;
      if (!v21) {
        return BlockArray;
      }
      goto LABEL_45;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    size_t Height = IOSurfaceGetHeight(*a4);
    unint64_t v37 = IOSurfaceGetBytesPerRow(*a4) * Height;
    uint64_t BlockArray = 4294967243;
    double v25 = 0.0;
    double v26 = 0.0;
  }
  if (!BaseAddress) {
    goto LABEL_44;
  }
  uint64_t v29 = (*(uint64_t (**)(uint64_t, void *, unint64_t))(*(void *)a1 + 120))(a1, BaseAddress, v37);
  if (v29)
  {
    uint64_t BlockArray = v29;
    *(_DWORD *)(a1 + 104) = 0;
    if (a3 == 3)
    {
      _ImageIO_Free((unint64_t)BaseAddress, v37);
      if (!v21) {
        return BlockArray;
      }
      goto LABEL_45;
    }
LABEL_44:
    if (!v21) {
      return BlockArray;
    }
    goto LABEL_45;
  }
  if (a3 != 3)
  {
    IOSurfaceUnlock(*a4, 0, 0);
    uint64_t BlockArray = 0;
    goto LABEL_44;
  }
  uint64_t v32 = 0;
  v38.origin.CGFloat x = 0.0;
  v38.origin.double y = 0.0;
  v38.size.double width = v26;
  v38.size.double height = v25;
  **(void **)(a1 + 96) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, BaseAddress, v37, v38, *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
  if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E4F1DB20]))
  {
    uint64_t v33 = 0;
  }
  else
  {
    v39.origin.CGFloat x = 0.0;
    v39.origin.double y = 0.0;
    v39.size.double width = v26;
    v39.size.double height = v25;
    *(CGRect *)(&v33 - 1) = CGRectUnion(*(CGRect *)(a1 + 120), v39);
    uint64_t v32 = v34;
    double v26 = v35;
    double v25 = v36;
  }
  uint64_t BlockArray = 0;
  *(void *)(a1 + 120) = v32;
  *(void *)(a1 + 128) = v33;
  *(double *)(a1 + 136) = v26;
  *(double *)(a1 + 144) = v25;
  if (v21)
  {
LABEL_45:
    CFRange v30 = *(const char ***)(a1 + 24);
    if (v30) {
      IIOImageReadSession::unmapData(v30);
    }
  }
  return BlockArray;
}

uint64_t RADReadPlugin::decodeImageData(IIOImageReadSession **this, unsigned __int8 *a2, unsigned int a3)
{
  FILE = IIOImageReadSession::createFILE(this[3]);
  if (!FILE) {
    return 0;
  }
  uint64_t v7 = FILE;
  if (*((_WORD *)this + 120) == 32) {
    uint64_t RGB_float = _cg_RadReadRGB_float(FILE, (uint64_t)a2, a3);
  }
  else {
    uint64_t RGB_float = _cg_RadReadRGB_fp16(FILE, a2, a3);
  }
  uint64_t v9 = RGB_float;
  fclose(v7);
  return v9;
}

void IIO_Reader_PBM::createReadPlugin()
{
}

{
  operator new();
}

void sub_1887F4048(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C403A5B1CCFLL);
  _Unwind_Resume(a1);
}

void sub_1887F40E8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C403A5B1CCFLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_PBM::testHeader(uint64_t a1, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v14 = 0;
  long long v12 = 0u;
  long long v13 = 0u;
  memset(v11, 0, sizeof(v11));
  IIOScanner::IIOScanner((IIOScanner *)v11, a2, a3, 0);
  int Val8 = IIOScanner::getVal8((IIOScanner *)v11);
  int v4 = IIOScanner::getVal8((IIOScanner *)v11);
  int v5 = v4;
  uint64_t v7 = Val8 == 42 && v4 == 23;
  if (Val8 == 80 && ((v4 - 49) < 7 || v4 == 102 || v4 == 70))
  {
    *((void *)&v12 + 1) = GetPBMLookupTable();
    unsigned __int8 v8 = IIOScanner::lookupVal8((IIOScanner *)v11);
    if ((v8 + 2) >= 0xFEu)
    {
      while ((v8 & 0xFE) == 0xFC)
        unsigned __int8 v8 = IIOScanner::lookupVal8((IIOScanner *)v11);
      if (v8 == 254)
      {
        while (IIOScanner::lookupVal8((IIOScanner *)v11) != 252)
          ;
        unsigned __int8 v8 = -4;
      }
      if (v8 != 0xFF || v5 == 55) {
        uint64_t v7 = 1;
      }
      else {
        uint64_t v7 = v7;
      }
    }
  }
  IIOScanner::~IIOScanner((IIOScanner *)v11);
  return v7;
}

void sub_1887F422C(void *a1)
{
}

void sub_1887F4248(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t IIO_Reader_PBM::compareOptions(IIO_Reader_PBM *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  memset(v16, 0, sizeof(v16));
  IIODictionary::IIODictionary((IIODictionary *)v16, a2);
  memset(v15, 0, sizeof(v15));
  IIODictionary::IIODictionary((IIODictionary *)v15, a3);
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v16, @"kCGImageSourceSubsampleFactor");
  unsigned int v6 = IIODictionary::getUint32ForKey((IIODictionary *)v15, @"kCGImageSourceSubsampleFactor");
  if (Uint32ForKey <= 1) {
    int v7 = 1;
  }
  else {
    int v7 = Uint32ForKey;
  }
  if (v6 <= 1) {
    int v8 = 1;
  }
  else {
    int v8 = v6;
  }
  if (v7 == v8)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a2, @"kCGImageSourceDecodeRequest");
    CFStringRef v10 = (const __CFString *)CFDictionaryGetValue(a3, @"kCGImageSourceDecodeRequest");
    if (Value) {
      BOOL v11 = v10 == 0;
    }
    else {
      BOOL v11 = 1;
    }
    if (v11) {
      BOOL v13 = ((unint64_t)Value | (unint64_t)v10) == 0;
    }
    else {
      BOOL v13 = CFEqual(Value, v10);
    }
    uint64_t v12 = v13;
  }
  else
  {
    uint64_t v12 = 0;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v15);
  IIODictionary::~IIODictionary((IIODictionary *)v16);
  return v12;
}

void sub_1887F4368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

uint64_t IIO_Reader_PBM::hasCustomCompareOptionsProc(IIO_Reader_PBM *this)
{
  return 1;
}

uint64_t ImageIOPixelConverter::extractInfo(uint64_t this)
{
  unint64_t v1 = *(char *)(this + 32);
  if (v1 <= 0x18)
  {
    int v2 = dword_1889ADB6C[v1];
    char v3 = byte_1889ADBD0[v1];
    char v4 = byte_1889ADBE9[v1];
    *(_DWORD *)(this + 44) = v2;
    *(unsigned char *)(this + 41) = v3;
    *(unsigned char *)(this + 48) = v4;
  }
  unint64_t v5 = *(char *)(this + 49);
  if (v5 <= 0x18)
  {
    char v6 = byte_1889ADBD0[v5];
    char v7 = byte_1889ADBE9[v5];
    *(_DWORD *)(this + 60) = dword_1889ADB6C[v5];
    *(unsigned char *)(this + 56) = v6;
    *(unsigned char *)(this + 64) = v7;
  }
  *(_DWORD *)(this + 68) = 0;
  if (*(unsigned char *)(this + 41) == 3)
  {
    int v8 = *(unsigned __int8 *)(this + 64);
    if (*(_DWORD *)(this + 60) == 4) {
      v8 |= 2u;
    }
    if (*(unsigned char *)(this + 48)) {
      v8 |= 4u;
    }
LABEL_18:
    *(_DWORD *)(this + 68) = v8 | 8;
    return this;
  }
  if (*(unsigned char *)(this + 56) == 4)
  {
    int v8 = *(unsigned __int8 *)(this + 64);
    if (*(unsigned char *)(this + 64))
    {
      int v8 = 1;
      *(_DWORD *)(this + 68) = 1;
    }
    if (*(_DWORD *)(this + 60) == 4)
    {
      v8 |= 2u;
      *(_DWORD *)(this + 68) = v8;
    }
    if (*(unsigned char *)(this + 48))
    {
      v8 |= 4u;
      *(_DWORD *)(this + 68) = v8;
    }
    if (*(_DWORD *)(this + 44) == 4) {
      goto LABEL_18;
    }
  }
  return this;
}

void ImageIOPixelConverter::~ImageIOPixelConverter(ImageIOPixelConverter *this)
{
  *(void *)this = &unk_1ED4E52A0;
  unint64_t v1 = (vImageConverter *)*((void *)this + 1);
  if (v1) {
    vImageConverter_Release(v1);
  }
}

const char *PixelTypeStr(char a1)
{
  if ((a1 + 1) > 0x11u) {
    return "???";
  }
  else {
    return off_1E53CD228[(char)(a1 + 1)];
  }
}

uint64_t ImageIOPixelConverter::convertAnyToAny(ImageIOPixelConverter *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  rowuint64_t Bytes = a3->rowBytes;
  CFDictionaryRef data = a3->data;
  vImagePixelCount height = a3->height;
  int v6 = *((unsigned __int8 *)this + 41);
  int v7 = *((unsigned __int8 *)this + 56);
  if (v6 != v7 && v6 + 1 != v7)
  {
    _cg_jpeg_mem_term("convertAnyToAny", 278, "*** unsupported src/dst channel combination: src: %d  dst: %d\n", v6, v7);
LABEL_9:
    memset(data, 255, height * rowBytes);
    return -1;
  }
  uint64_t v9 = (char *)a2->data;
  int v10 = *((_DWORD *)this + 13);
  unsigned int v11 = *((unsigned __int8 *)this + 37);
  int v12 = v10 & 0xFF00;
  if (v11 > 8)
  {
    if (v11 > 0x10)
    {
      if (v12 != 0x2000) {
        goto LABEL_9;
      }
      char v14 = 32;
    }
    else
    {
      if (v12 != 4096) {
        goto LABEL_9;
      }
      char v14 = 16;
    }
    char v13 = *((unsigned char *)this + 37);
  }
  else
  {
    if (v12 != 2048) {
      goto LABEL_9;
    }
    char v13 = 2 * v11 - 8;
    char v14 = 8;
  }
  char v16 = v14 - v11;
  if (*((unsigned char *)this + 17) == 4)
  {
    char v16 = 0;
    char v13 = 0;
  }
  vImagePixelCount v17 = a2->height;
  if (!v17) {
    return 0;
  }
  vImagePixelCount v18 = 0;
  vImagePixelCount width = a2->width;
  unsigned int v20 = *((unsigned __int8 *)this + 41);
  vImagePixelCount v21 = width;
  do
  {
    if (!v21) {
      goto LABEL_58;
    }
    vImagePixelCount v22 = 0;
    size_t v23 = (size_t)data + a3->rowBytes * v18;
    BOOL v24 = &v9[a2->rowBytes * v18];
    int v25 = 7;
    do
    {
      if (!v20) {
        goto LABEL_56;
      }
      for (unsigned int i = 0; i < v20; ++i)
      {
        unsigned int v27 = v20 - 1;
        BOOL v29 = v6 == v7 || i != v27;
        if (v11)
        {
          unsigned int v30 = 0;
          unsigned int v31 = v11;
          do
          {
            unsigned int v32 = (*v24 >> v25) & 1 | (2 * v30);
            BOOL v33 = __OFSUB__(v25--, 1);
            if (v25 < 0 != v33)
            {
              int v25 = 7;
              ++v24;
            }
            unsigned int v30 = v32;
            --v31;
          }
          while (v31);
        }
        else
        {
          unsigned int v32 = 0;
        }
        unsigned int v34 = bswap32(v32) >> 8;
        if (v11 != 24) {
          unsigned int v34 = v32;
        }
        unsigned int v35 = (v34 << v16 >> v13) | (v34 << v16);
        switch(BYTE1(v10))
        {
          case 0x20u:
            unsigned int v38 = bswap32(v35);
            if (v11 != 32) {
              unsigned int v38 = v35;
            }
            *(_DWORD *)size_t v23 = v38;
            size_t v37 = v23 + 4;
            if (v29) {
              goto LABEL_51;
            }
            *(_DWORD *)(v23 + 4) = -1;
            v23 += 8;
            break;
          case 0x10u:
            unsigned int v36 = bswap32(v35) >> 16;
            if (v11 != 16) {
              LOWORD(v36) = v35;
            }
            *(_WORD *)size_t v23 = v36;
            size_t v37 = v23 + 2;
            if (!v29)
            {
              *(_WORD *)(v23 + 2) = -1;
              v23 += 4;
              break;
            }
LABEL_51:
            size_t v23 = v37;
            break;
          case 8u:
            *(unsigned char *)size_t v23 = v35;
            if (v29)
            {
              ++v23;
            }
            else
            {
              *(unsigned char *)(v23 + 1) = -1;
              v23 += 2;
            }
            break;
        }
        unsigned int v20 = *((unsigned __int8 *)this + 41);
      }
      vImagePixelCount width = a2->width;
LABEL_56:
      ++v22;
    }
    while (v22 < width);
    vImagePixelCount v17 = a2->height;
    vImagePixelCount v21 = width;
LABEL_58:
    ++v18;
  }
  while (v18 < v17);
  return 0;
}

uint64_t ImageIOPixelConverter::CreatePixelConverter(_DWORD *a1)
{
  switch(*a1)
  {
    case 0:
      operator new();
    case 1:
      operator new();
    case 2:
      operator new();
    case 3:
      operator new();
    case 5:
      operator new();
    default:
      return 0;
  }
}

void sub_1887F4960(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C4050BC5624);
  _Unwind_Resume(a1);
}

uint64_t IIOPixelConverterGray::IIOPixelConverterGray(uint64_t a1, char a2, char a3, uint32_t a4, int a5, char a6, uint32_t a7, char a8, uint64_t a9)
{
  return IIOPixelConverterGray::IIOPixelConverterGray(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

{
  uint32_t v12;
  CFStringRef v13;
  CGColorSpace *v14;
  uint32_t v15;
  CGBitmapInfo v16;
  uint32_t v17;
  CGBitmapInfo v18;
  int v19;
  vImageConverterRef v20;
  const char *v21;
  vImage_CGImageFormat destFormat;
  vImage_CGImageFormat srcFormat;
  CGColorSpaceRef v25[2];
  vImage_Error error;

  *(unsigned char *)(a1 + 72) = 0;
  vImage_Error error = 0;
  *(void *)a1 = &unk_1ED4E5270;
  *(void *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 32) = a2;
  *(unsigned char *)(a1 + 49) = a6;
  *(void *)(a1 + 24) = a9;
  *(unsigned char *)(a1 + 17) = 0;
  *(unsigned char *)(a1 + 65) = a8;
  *(unsigned char *)(a1 + 40) = a3;
  *(_DWORD *)(a1 + 36) = a5 | (a4 << 8);
  if (a5) {
    int v12 = a7;
  }
  else {
    int v12 = 0;
  }
  *(_DWORD *)(a1 + 52) = v12 | (a7 << 8);
  ImageIOPixelConverter::extractInfo(a1);
  if (*(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a1 + 49) && *(_DWORD *)(a1 + 36) == *(_DWORD *)(a1 + 52))
  {
    *(unsigned char *)(a1 + 16) = 0;
    return a1;
  }
  *(unsigned char *)(a1 + 16) = 1;
  char v13 = (const __CFString *)*MEMORY[0x1E4F1DC00];
  v25[0] = (CGColorSpaceRef)&unk_1ED4DFD58;
  char v14 = CGColorSpaceCreateWithName(v13);
  v25[1] = v14;
  uint64_t v15 = *(unsigned __int8 *)(a1 + 41) * a4;
  srcFormat.bitsPerComponent = a4;
  srcFormat.bitsPerPixel = v15;
  char v16 = *(_DWORD *)(a1 + 44);
  srcFormat.colorSpace = v14;
  memset(&srcFormat.version, 0, 20);
  srcFormat.bitmapInfo = v16;
  memset(&destFormat.bitmapInfo, 0, 24);
  vImagePixelCount v17 = *(unsigned __int8 *)(a1 + 56) * a7;
  destFormat.bitsPerComponent = a7;
  destFormat.bitsPerPixel = v17;
  vImagePixelCount v18 = *(_DWORD *)(a1 + 60);
  destFormat.bitmapInfo = v18;
  if (a7 == 16)
  {
    uint64_t v19 = 4096;
  }
  else
  {
    if (a7 != 32) {
      goto LABEL_12;
    }
    uint64_t v19 = 0x2000;
  }
  destFormat.bitmapInfo = v18 | v19;
LABEL_12:
  destFormat.colorSpace = v14;
  unsigned int v20 = vImageConverter_CreateWithCGImageFormat(&srcFormat, &destFormat, 0, 0, &error);
  *(void *)(a1 + 8) = v20;
  if (!v20 || error)
  {
    vImagePixelCount v21 = IIO_vImageErrorString(error);
    _cg_jpeg_mem_term("IIOPixelConverterGray", 869, "*** IIOPixelConverterGray could not create vImageConverter '%s'\n", v21);
  }
  IIOColorSpace::~IIOColorSpace(v25);
  return a1;
}

uint64_t IIOPixelConverterRGB::IIOPixelConverterRGB(uint64_t a1, char a2, char a3, uint32_t a4, int a5, int a6, int a7, char a8, unsigned __int8 a9, char a10, uint64_t a11)
{
  return IIOPixelConverterRGB::IIOPixelConverterRGB(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

{
  int v13;
  int v14;
  int v15;
  unsigned int v17;
  int v18;
  CGBitmapInfo v19;
  BOOL v20;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  int v26;
  CGBitmapInfo v27;
  int v28;
  vImageConverterRef v29;
  const char *v30;
  vImage_CGImageFormat destFormat;
  vImage_CGImageFormat srcFormat;
  vImage_Error error;

  *(unsigned char *)(a1 + 72) = 0;
  vImage_Error error = 0;
  *(void *)a1 = &unk_1ED4E5028;
  *(void *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 32) = a2;
  *(unsigned char *)(a1 + 49) = a8;
  *(void *)(a1 + 24) = a11;
  *(unsigned char *)(a1 + 17) = 1;
  *(unsigned char *)(a1 + 65) = a10;
  *(unsigned char *)(a1 + 40) = a3;
  *(_DWORD *)(a1 + 36) = (a4 << 24) | (a5 << 16) | (a6 << 8) | a7;
  if (a7) {
    char v13 = a9;
  }
  else {
    char v13 = 0;
  }
  *(_DWORD *)(a1 + 52) = (16843008 * a9) | v13;
  *(unsigned char *)(a1 + 73) = 0;
  ImageIOPixelConverter::extractInfo(a1);
  char v14 = *(_DWORD *)(a1 + 36);
  if (v14 > 134744318)
  {
    if (v14 == 168430082) {
      goto LABEL_10;
    }
    uint64_t v15 = 134744319;
  }
  else
  {
    if (v14 == 84215041) {
      goto LABEL_10;
    }
    uint64_t v15 = 84280831;
  }
  if (v14 == v15) {
    goto LABEL_10;
  }
  *(unsigned char *)(a1 + 16) = 1;
  if (v14 == 134744072 && *(_DWORD *)(a1 + 52) == 134744072)
  {
    switch(*(unsigned char *)(a1 + 32))
    {
      case 2:
        *(unsigned char *)(a1 + 73) = 1;
        vImagePixelCount v17 = (*(unsigned char *)(a1 + 49) - 2);
        if (v17 >= 4) {
          goto LABEL_10;
        }
        break;
      case 3:
        *(unsigned char *)(a1 + 73) = 1;
        size_t v23 = (*(unsigned char *)(a1 + 49) - 2);
        if (v23 >= 4) {
          goto LABEL_10;
        }
        vImagePixelCount v17 = v23 + 4;
        break;
      case 4:
        *(unsigned char *)(a1 + 73) = 1;
        BOOL v24 = (*(unsigned char *)(a1 + 49) - 2);
        if (v24 >= 4) {
          goto LABEL_10;
        }
        vImagePixelCount v17 = v24 + 8;
        break;
      case 5:
        *(unsigned char *)(a1 + 73) = 1;
        int v25 = (*(unsigned char *)(a1 + 49) - 2);
        if (v25 >= 4) {
          goto LABEL_10;
        }
        vImagePixelCount v17 = v25 + 12;
        break;
      default:
        goto LABEL_17;
    }
    *(_DWORD *)(a1 + 68) = v17;
    goto LABEL_10;
  }
LABEL_17:
  if (*(unsigned char *)(a1 + 73))
  {
LABEL_10:
    *(unsigned char *)(a1 + 16) = 0;
    return a1;
  }
  memset(&srcFormat.colorSpace, 0, 32);
  vImagePixelCount v18 = *(unsigned __int8 *)(a1 + 41);
  srcFormat.bitsPerComponent = a4;
  srcFormat.bitsPerPixel = v18 * a4;
  uint64_t v19 = *(_DWORD *)(a1 + 44);
  srcFormat.bitmapInfo = v19;
  unsigned int v20 = a4 == 8 && v18 == 4;
  vImagePixelCount v21 = !v20;
  if (v20)
  {
    vImagePixelCount v22 = 0x4000;
  }
  else
  {
    if (a4 != 16)
    {
      vImagePixelCount v21 = 0;
      goto LABEL_39;
    }
    srcFormat.bitmapInfo = v19 | 0x1000;
    if (*(unsigned char *)(a1 + 32) != 22)
    {
      vImagePixelCount v21 = 1;
      goto LABEL_39;
    }
    vImagePixelCount v22 = 4352;
  }
  srcFormat.bitmapInfo = v19 | v22;
LABEL_39:
  memset(&destFormat.colorSpace, 0, 32);
  double v26 = *(unsigned __int8 *)(a1 + 56);
  destFormat.bitsPerComponent = a9;
  destFormat.bitsPerPixel = v26 * a9;
  unsigned int v27 = *(_DWORD *)(a1 + 60);
  destFormat.bitmapInfo = v27;
  if (a9 == 8 && v26 == 4)
  {
    if ((*(unsigned char *)(a1 + 49) - 2) >= 4u) {
      unsigned int v28 = 0x4000;
    }
    else {
      unsigned int v28 = dword_1889ADC10[(char)(*(unsigned char *)(a1 + 49) - 2)];
    }
  }
  else if (a9 == 16)
  {
    unsigned int v28 = 4096;
  }
  else
  {
    if (a9 != 32) {
      goto LABEL_49;
    }
    unsigned int v28 = 0x2000;
  }
  v27 |= v28;
  destFormat.bitmapInfo = v27;
LABEL_49:
  if (v21 && *(unsigned char *)(a1 + 49) == 22) {
    destFormat.bitmapInfo = v27 | 0x100;
  }
  BOOL v29 = vImageConverter_CreateWithCGImageFormat(&srcFormat, &destFormat, 0, 0, &error);
  *(void *)(a1 + 8) = v29;
  if (!v29 || error)
  {
    unsigned int v30 = IIO_vImageErrorString(error);
    _cg_jpeg_mem_term("IIOPixelConverterRGB", 1078, "*** IIOPixelConverterRGB could not create vImageConverter '%s'\n", v30);
  }
  return a1;
}

uint64_t ImageIOPixelConverter::ExpandRGB888ToARGB8888(ImageIOPixelConverter *this, unint64_t a2, unsigned int a3, int a4, unsigned int a5)
{
  uint64_t result = 4294967246;
  if (a5 >= 4 * a3)
  {
    int v8 = a4;
    if (a5 * a4 <= a2)
    {
      size_t v10 = 3 * a3;
      unsigned int v11 = malloc_type_malloc(v10, 0x46A4D581uLL);
      if (v11)
      {
        int v12 = v11;
        v16.CFDictionaryRef data = v11;
        v16.vImagePixelCount height = 1;
        v16.vImagePixelCount width = a3;
        v16.rowuint64_t Bytes = v10;
        v15.vImagePixelCount height = 1;
        v15.vImagePixelCount width = a3;
        v15.rowuint64_t Bytes = a5;
        if (v8)
        {
          unsigned int v13 = (v8 - 1) * a5;
          unsigned int v14 = (v8 - 1) * v10;
          do
          {
            memcpy(v12, (char *)this + v14, v10);
            v15.CFDictionaryRef data = (char *)this + v13;
            vImageConvert_RGB888toBGRA8888(&v16, 0, 0xFFu, &v15, 0, 0x10u);
            v14 -= v10;
            v13 -= a5;
            --v8;
          }
          while (v8);
        }
        free(v12);
        return 0;
      }
      else
      {
        return 4294967246;
      }
    }
  }
  return result;
}

uint64_t ImageIOPixelConverter::AdjustRowBytes(ImageIOPixelConverter *this, unint64_t a2, int a3, int a4, size_t __len, unsigned int a6)
{
  uint64_t v6 = 4294967246;
  if (__len >= 4 * a3 && a6 > __len)
  {
    int v7 = a4;
    if (a6 * a4 <= a2)
    {
      if (a4)
      {
        int v8 = (char *)this + (a4 - 1) * a6;
        size_t v9 = __len;
        size_t v10 = (char *)this + ((a4 - 1) * __len);
        uint64_t v11 = -(uint64_t)__len;
        uint64_t v12 = -(uint64_t)a6;
        do
        {
          memmove(v8, v10, v9);
          v10 += v11;
          v8 += v12;
          --v7;
        }
        while (v7);
      }
      return 0;
    }
  }
  return v6;
}

uint64_t IIOPixelConverterIndexed::IIOPixelConverterIndexed(uint64_t a1, char a2, char a3, uint32_t a4, char a5, uint32_t a6, char a7, uint64_t a8)
{
  *(unsigned char *)(a1 + 72) = 0;
  vImage_Error error = 0;
  *(void *)a1 = &unk_1ED4E55D8;
  *(void *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 32) = a2;
  *(unsigned char *)(a1 + 49) = a5;
  *(void *)(a1 + 24) = a8;
  *(unsigned char *)(a1 + 17) = 4;
  *(unsigned char *)(a1 + 65) = a7;
  *(unsigned char *)(a1 + 40) = a3;
  *(_DWORD *)(a1 + 36) = a4 << 8;
  *(_DWORD *)(a1 + 52) = a6 << 8;
  ImageIOPixelConverter::extractInfo(a1);
  if (*(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a1 + 49) && *(_DWORD *)(a1 + 36) == *(_DWORD *)(a1 + 52)
    || (a5 & 0xFE) == 0xC)
  {
    *(unsigned char *)(a1 + 16) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 16) = 1;
    CFStringRef v12 = (const __CFString *)*MEMORY[0x1E4F1DC98];
    CGColorSpaceRef v22 = (CGColorSpaceRef)&unk_1ED4DFD58;
    size_t v23 = CGColorSpaceCreateWithName(v12);
    uint32_t v13 = *(unsigned __int8 *)(a1 + 41) * a4;
    srcFormat.bitsPerComponent = a4;
    srcFormat.bitsPerPixel = v13;
    CGBitmapInfo v14 = *(_DWORD *)(a1 + 44);
    srcFormat.colorSpace = v23;
    memset(&srcFormat.version, 0, 20);
    srcFormat.bitmapInfo = v14;
    uint32_t v15 = *(unsigned __int8 *)(a1 + 56) * a6;
    destFormat.bitsPerComponent = a6;
    destFormat.bitsPerPixel = v15;
    CGBitmapInfo v16 = *(_DWORD *)(a1 + 60);
    destFormat.colorSpace = v23;
    memset(&destFormat.version, 0, 20);
    destFormat.bitmapInfo = v16;
    vImageConverterRef v17 = vImageConverter_CreateWithCGImageFormat(&srcFormat, &destFormat, 0, 0, &error);
    *(void *)(a1 + 8) = v17;
    if (!v17 || error)
    {
      vImagePixelCount v18 = IIO_vImageErrorString(error);
      _cg_jpeg_mem_term("IIOPixelConverterIndexed", 550, "*** IIOPixelConverterIndexed could not create vImageConverter '%s'\n", v18);
    }
    IIOColorSpace::~IIOColorSpace(&v22);
  }
  return a1;
}

void sub_1887F4D24(_Unwind_Exception *a1)
{
  ImageIOPixelConverter::~ImageIOPixelConverter(v1);
  _Unwind_Resume(a1);
}

void IIOPixelConverterIndexed::~IIOPixelConverterIndexed(IIOPixelConverterIndexed *this)
{
  ImageIOPixelConverter::~ImageIOPixelConverter(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIOPixelConverterIndexed::convert(IIOPixelConverterIndexed *this, vImage_Buffer *a2, vImage_Buffer *a3)
{
  return -1;
}

uint64_t IIOPixelConverterIndexed::convertRow(IIOPixelConverterIndexed *this, unsigned __int8 *a2, unsigned __int8 *__dst, unsigned int a4)
{
  int v5 = *((_DWORD *)this + 9);
  HIDWORD(v6) = v5;
  LODWORD(v6) = v5 - 256;
  switch((v6 >> 8))
  {
    case 0u:
      IIOPixelConverterIndexed::expandIndex1to8(this, a2, __dst, a4);
      goto LABEL_15;
    case 1u:
      IIOPixelConverterIndexed::expandIndex2to8(this, a2, __dst, a4);
      goto LABEL_15;
    case 3u:
      if (a4 + 1 >= 2)
      {
        unsigned int v10 = (a4 + 1) >> 1;
        do
        {
          unsigned int v11 = *a2++;
          *int __dst = v11 >> 4;
          __dst[1] = v11 & 0xF;
          __dst += 2;
          --v10;
        }
        while (v10);
      }
      goto LABEL_15;
    case 7u:
      if (*((_DWORD *)this + 11)) {
        size_t v12 = 2 * a4;
      }
      else {
        size_t v12 = a4;
      }
      memcpy(__dst, a2, v12);
LABEL_15:
      uint64_t result = 0;
      break;
    default:
      size_t v7 = (BYTE1(v5) * a4 * *((unsigned __int8 *)this + 41)) >> 3;
      size_t v8 = (*((unsigned __int8 *)this + 53) * a4 * *((unsigned __int8 *)this + 56)) >> 3;
      v14.CFDictionaryRef data = a2;
      v14.vImagePixelCount height = 1;
      v14.vImagePixelCount width = a4;
      v14.rowuint64_t Bytes = v7;
      v13.CFDictionaryRef data = __dst;
      v13.vImagePixelCount height = 1;
      v13.vImagePixelCount width = a4;
      v13.rowuint64_t Bytes = v8;
      if (!*((unsigned char *)this + 72))
      {
        _cg_jpeg_mem_term("convertRow", 607, "🔺  check 'convertAnyToAny' usage: _srcBits: %08X not handled\n", v5);
        *((unsigned char *)this + 72) = 1;
      }
      uint64_t result = ImageIOPixelConverter::convertAnyToAny(this, &v14, &v13);
      break;
  }
  return result;
}

uint64_t IIOPixelConverterIndexed::expandIndex1to8(IIOPixelConverterIndexed *this, unsigned __int8 *a2, unsigned __int8 *a3, int a4)
{
  unsigned int v4 = a4 + 3;
  if ((a4 + 3) >= 8)
  {
    uint64_t v5 = v4 >> 3;
    do
    {
      unsigned int v6 = *a2++;
      int v7 = _LUT_INDEX[v6 & 0xF];
      *(_DWORD *)a3 = *(_DWORD *)((char *)_LUT_INDEX + (((unint64_t)v6 >> 2) & 0x3C));
      *((_DWORD *)a3 + 1) = v7;
      a3 += 8;
      --v5;
    }
    while (v5);
  }
  if ((v4 & 4) != 0) {
    *(_DWORD *)a3 = *(_DWORD *)((char *)_LUT_INDEX + (((unint64_t)*a2 >> 2) & 0x3C));
  }
  return 0;
}

uint64_t IIOPixelConverterIndexed::expandIndex2to8(IIOPixelConverterIndexed *this, unsigned __int8 *a2, unsigned __int8 *a3, int a4)
{
  if ((a4 + 3) >= 4)
  {
    unsigned int v4 = (a4 + 3) >> 2;
    do
    {
      unsigned int v5 = *a2++;
      *a3 = IIOPixelConverterIndexed::expandIndex2to8(unsigned char *,unsigned char *,unsigned int)::_LUT2_4[(unint64_t)v5 >> 6];
      a3[1] = IIOPixelConverterIndexed::expandIndex2to8(unsigned char *,unsigned char *,unsigned int)::_LUT2_4[((unint64_t)v5 >> 4) & 3];
      a3[2] = IIOPixelConverterIndexed::expandIndex2to8(unsigned char *,unsigned char *,unsigned int)::_LUT2_4[((unint64_t)v5 >> 2) & 3];
      a3[3] = IIOPixelConverterIndexed::expandIndex2to8(unsigned char *,unsigned char *,unsigned int)::_LUT2_4[v5 & 3];
      a3 += 4;
      --v4;
    }
    while (v4);
  }
  return 0;
}

void sub_1887F515C(_Unwind_Exception *a1)
{
  ImageIOPixelConverter::~ImageIOPixelConverter(v1);
  _Unwind_Resume(a1);
}

void IIOPixelConverterGray::~IIOPixelConverterGray(IIOPixelConverterGray *this)
{
  ImageIOPixelConverter::~ImageIOPixelConverter(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIOPixelConverterGray::convert(IIOPixelConverterGray *this, vImage_Buffer *srcs, vImage_Buffer *dests)
{
  if (__PAIR64__(*((_DWORD *)this + 9), *((unsigned __int8 *)this + 32)) == __PAIR64__(*((_DWORD *)this + 13), *((unsigned __int8 *)this + 49)))
  {
    CFDictionaryRef data = srcs->data;
    rowuint64_t Bytes = srcs->rowBytes;
    if (rowBytes >= dests->rowBytes) {
      rowuint64_t Bytes = dests->rowBytes;
    }
    memcpy(dests->data, data, rowBytes * dests->height);
  }
  else
  {
    size_t v8 = (vImageConverter *)*((void *)this + 1);
    if (v8)
    {
      vImage_Error v9 = iio_vImageConvert_AnyToAny(v8, srcs, dests, 0, 0);
      if (!v9) {
        goto LABEL_9;
      }
      unsigned int v10 = IIO_vImageErrorString(v9);
      _cg_jpeg_mem_term("convert", 895, "*** vImageConvert_AnyToAny: %s\n", v10);
    }
    _cg_jpeg_mem_term("convert", 899, "   falling back to own convertAnyToAny [Gray]\n");
    ImageIOPixelConverter::convertAnyToAny(this, srcs, dests);
  }
LABEL_9:
  if (*((unsigned char *)this + 65) == 1)
  {
    long long v11 = *(_OWORD *)&dests->width;
    *(_OWORD *)&dest.CFDictionaryRef data = *(_OWORD *)&dests->data;
    *(_OWORD *)&dest.vImagePixelCount width = v11;
    vImageByteSwap_Planar16U(&dest, &dest, 0x10u);
  }
  return 0;
}

uint64_t IIOPixelConverterGray::convertRow(IIOPixelConverterGray *this, unsigned __int8 *a2, unsigned __int8 *a3, unsigned int a4)
{
  uint64_t v4 = (*((unsigned __int8 *)this + 37) * a4 * *((unsigned __int8 *)this + 41)) >> 3;
  uint64_t v5 = (*((unsigned __int8 *)this + 53) * a4 * *((unsigned __int8 *)this + 56)) >> 3;
  v8[0] = a2;
  v8[1] = 1;
  void v8[2] = a4;
  void v8[3] = v4;
  v7[0] = a3;
  v7[1] = 1;
  BOOL v7[2] = a4;
  void v7[3] = v5;
  return (*(uint64_t (**)(IIOPixelConverterGray *, void *, void *))(*(void *)this + 16))(this, v8, v7);
}

void sub_1887F56A4(_Unwind_Exception *a1)
{
  ImageIOPixelConverter::~ImageIOPixelConverter(v1);
  _Unwind_Resume(a1);
}

void IIOPixelConverterRGB::~IIOPixelConverterRGB(IIOPixelConverterRGB *this)
{
  ImageIOPixelConverter::~ImageIOPixelConverter(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIOPixelConverterRGB::convert(IIOPixelConverterRGB *this, vImage_Buffer *srcs, vImage_Buffer *dests)
{
  if (*((unsigned __int8 *)this + 40) > *((unsigned __int8 *)this + 41))
  {
    if (*((unsigned char *)this + 36) == 8)
    {
      vImagePixelCount height = srcs->height;
      if (height)
      {
        vImagePixelCount v7 = 0;
        vImagePixelCount width = srcs->width;
        do
        {
          if (width)
          {
            vImagePixelCount v9 = 0;
            unsigned int v10 = (char *)dests->data + dests->rowBytes * v7;
            long long v11 = (char *)srcs->data + srcs->rowBytes * v7;
            size_t v12 = *((unsigned __int8 *)this + 56);
            do
            {
              memcpy(v10, v11, v12);
              v11 += *((unsigned __int8 *)this + 40);
              size_t v12 = *((unsigned __int8 *)this + 56);
              v10 += v12;
              ++v9;
              vImagePixelCount width = srcs->width;
            }
            while (v9 < width);
            vImagePixelCount height = srcs->height;
          }
          ++v7;
        }
        while (v7 < height);
      }
    }
    else
    {
      bzero(dests->data, dests->height * dests->rowBytes);
    }
    goto LABEL_60;
  }
  if (*((unsigned char *)this + 73))
  {
    vImagePermuteChannels_ARGB8888(srcs, dests, &gPermuteMap[4 * *((int *)this + 17)], 0);
    goto LABEL_60;
  }
  if (*((unsigned __int8 *)this + 32) == *((unsigned __int8 *)this + 49)
    && *((_DWORD *)this + 9) == *((_DWORD *)this + 13))
  {
    rowuint64_t Bytes = srcs->rowBytes;
    if (rowBytes >= dests->rowBytes) {
      rowuint64_t Bytes = dests->rowBytes;
    }
    memcpy(dests->data, srcs->data, rowBytes * srcs->height);
    int v14 = *((unsigned __int8 *)this + 65);
    if (v14 == 2)
    {
      vImagePixelCount v20 = dests->height;
      if (v20)
      {
        LODWORD(v21) = 0;
        CFDictionaryRef data = (char *)dests->data;
        vImagePixelCount v23 = dests->width;
        size_t v24 = dests->rowBytes;
        do
        {
          if (v23)
          {
            uint64_t v25 = 0;
            do
            {
              *(_DWORD *)&data[4 * v25] = bswap32(*(_DWORD *)&data[4 * v25]);
              ++v25;
            }
            while (v23 > v25);
          }
          data += v24;
          vImagePixelCount v21 = (v21 + 1);
        }
        while (v20 > v21);
      }
    }
    else if (v14 == 1)
    {
      long long v15 = *(_OWORD *)&dests->width;
      *(_OWORD *)&dest.CFDictionaryRef data = *(_OWORD *)&dests->data;
      *(_OWORD *)&dest.vImagePixelCount width = v15;
      dest.vImagePixelCount width = v15 * *((unsigned __int8 *)this + 41);
      vImageByteSwap_Planar16U(&dest, &dest, 0x10u);
    }
    goto LABEL_60;
  }
  if (*((unsigned char *)this + 16))
  {
    CGBitmapInfo v16 = (vImageConverter *)*((void *)this + 1);
    if (v16)
    {
      vImage_Error v17 = iio_vImageConvert_AnyToAny(v16, srcs, dests, 0, 0);
      if (!v17) {
        goto LABEL_60;
      }
      vImagePixelCount v18 = IIO_vImageErrorString(v17);
      _cg_jpeg_mem_term("convert", 1158, "*** vImageConvert_AnyToAny: %s\n", v18);
    }
    _cg_jpeg_mem_term("convert", 1162, "   falling back to own convertAnyToAny [RGB]\n");
    ImageIOPixelConverter::convertAnyToAny(this, srcs, dests);
    goto LABEL_60;
  }
  int v19 = *((_DWORD *)this + 9);
  if (v19 > 134744318)
  {
    if (v19 == 134744319)
    {
      if (*((unsigned char *)this + 64)) {
        vImageConvert_RGB888toBGRA8888(srcs, 0, 0xFFu, dests, 0, 0);
      }
      else {
        vImageConvert_RGB888toRGBA8888(srcs, 0, 0xFFu, dests, 0, 0);
      }
    }
    else
    {
      if (v19 != 168430082) {
        goto LABEL_60;
      }
      if (*((_DWORD *)this + 13) != 134744072) {
        vImageConvert_ARGB2101010ToARGB16U(srcs, dests, 0, 1023, &gPermuteMap[4 * *((int *)this + 17)], 0);
      }
    }
    goto LABEL_54;
  }
  if (v19 != 84215041)
  {
    if (v19 != 84280831) {
      goto LABEL_60;
    }
    if (*((unsigned char *)this + 64)) {
      vImageConvert_RGB565toBGRA8888(0xFFu, srcs, dests, 0);
    }
    else {
      vImageConvert_RGB565toRGBA8888(0xFFu, srcs, dests, 0);
    }
LABEL_54:
    *((_DWORD *)this + 17) = 0;
    goto LABEL_60;
  }
  vImagePixelCount v26 = srcs->height;
  unint64_t v27 = 3 * srcs->width;
  if (!is_mul_ok(v27, v26)) {
    return 0;
  }
  unsigned int v28 = malloc_type_malloc(v27 * v26, 0xE0BDB114uLL);
  vImagePixelCount v29 = srcs->height;
  vImagePixelCount v30 = srcs->width;
  dest.CFDictionaryRef data = v28;
  dest.vImagePixelCount height = v29;
  dest.vImagePixelCount width = v30;
  dest.rowuint64_t Bytes = 3 * v30;
  if (v28)
  {
    size_t v31 = dests->rowBytes;
    dests->rowuint64_t Bytes = srcs->rowBytes;
    vImage_Error v32 = vImageConvert_RGBA5551toRGB565(srcs, dests, 0);
    if (v32)
    {
      vImage_Error v33 = v32;
      unsigned int v34 = IIO_vImageErrorString(v32);
      printf("*** vImageConvert_RGBA5551toRGB565: %ld '%s'\n", v33, v34);
    }
    vImage_Error v35 = vImageConvert_RGB565toRGB888(dests, &dest, 0);
    if (v35)
    {
      vImage_Error v36 = v35;
      size_t v37 = IIO_vImageErrorString(v35);
      printf("*** vImageConvert_RGB565toRGB888: %ld '%s'\n", v36, v37);
    }
    dests->rowuint64_t Bytes = v31;
    if (*((unsigned char *)this + 64)) {
      vImage_Error v38 = vImageConvert_RGB888toBGRA8888(&dest, 0, 0xFFu, dests, 0, 0);
    }
    else {
      vImage_Error v38 = vImageConvert_RGB888toRGBA8888(&dest, 0, 0xFFu, dests, 0, 0);
    }
    vImage_Error v39 = v38;
    if (v38)
    {
      int v40 = IIO_vImageErrorString(v38);
      printf("*** vImageConvert_RGB888toRGBA8888: %ld '%s'\n", v39, v40);
    }
    free(dest.data);
  }
  *((_DWORD *)this + 17) = 4 * *((unsigned __int8 *)this + 48);
LABEL_60:
  if (!*((unsigned char *)this + 73))
  {
    uint64_t v41 = *((int *)this + 17);
    if (!gPermuteMap[4 * v41]
      && ((0x8433uLL >> v41) & 1) != 0
      && ((0xCC21uLL >> v41) & 1) != 0
      && *((unsigned char *)this + 65)
      && *((void *)this + 1)
      && !*((unsigned char *)this + 72))
    {
      *((unsigned char *)this + 72) = 1;
      int v42 = *((unsigned __int8 *)this + 40);
      int v43 = *((unsigned __int8 *)this + 56);
      char v44 = PixelTypeStr(*((unsigned char *)this + 32));
      char v45 = PixelTypeStr(*((unsigned char *)this + 49));
      _cg_jpeg_mem_term("convert", 1243, "⭕️  check result - converter is no longer swapping (%d-->%d)  %s --> %s\n", v42, v43, v44, v45);
    }
  }
  return 0;
}

uint64_t IIOPixelConverterRGB::convertRow(IIOPixelConverterRGB *this, unsigned __int8 *a2, unsigned __int8 *a3, unsigned int a4)
{
  int v4 = *((unsigned __int8 *)this + 37);
  unsigned int v5 = *((unsigned __int8 *)this + 40);
  if (v5 <= *((unsigned __int8 *)this + 41)) {
    unsigned int v5 = *((unsigned __int8 *)this + 41);
  }
  uint64_t v6 = (*((unsigned __int8 *)this + 53) * a4 * *((unsigned __int8 *)this + 56)) >> 3;
  v9[0] = a2;
  v9[1] = 1;
  _OWORD v9[2] = a4;
  void v9[3] = (v4 * a4 * v5) >> 3;
  v8[0] = a3;
  v8[1] = 1;
  void v8[2] = a4;
  void v8[3] = v6;
  return (*(uint64_t (**)(IIOPixelConverterRGB *, void *, void *))(*(void *)this + 16))(this, v9, v8);
}

uint64_t IIOPixelConverterLab::IIOPixelConverterLab(uint64_t a1, char a2, char a3, uint32_t a4, int a5, char a6, uint32_t a7, char a8, uint64_t a9, uint64_t a10)
{
  *(unsigned char *)(a1 + 72) = 0;
  vImage_Error error = 0;
  *(void *)a1 = &unk_1ED4E4FF8;
  *(void *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 32) = a2;
  *(unsigned char *)(a1 + 49) = a6;
  *(void *)(a1 + 24) = a10;
  *(unsigned char *)(a1 + 17) = 3;
  *(unsigned char *)(a1 + 65) = a8;
  *(unsigned char *)(a1 + 40) = a3;
  *(_DWORD *)(a1 + 36) = (16843008 * a4) | a5;
  if (a5) {
    uint32_t v13 = a7;
  }
  else {
    uint32_t v13 = 0;
  }
  *(_DWORD *)(a1 + 52) = (16843008 * a7) | v13;
  ImageIOPixelConverter::extractInfo(a1);
  *(unsigned char *)(a1 + 16) = 1;
  if (*(unsigned __int8 *)(a1 + 32) == *(unsigned __int8 *)(a1 + 49) && *(_DWORD *)(a1 + 36) == *(_DWORD *)(a1 + 52))
  {
    *(unsigned char *)(a1 + 16) = 0;
  }
  else
  {
    memset(&srcFormat.colorSpace, 0, 32);
    int v14 = *(unsigned __int8 *)(a1 + 41);
    BOOL v15 = v14 == 4;
    srcFormat.bitsPerComponent = a4;
    srcFormat.bitsPerPixel = v14 * a4;
    CGBitmapInfo v16 = *(_DWORD *)(a1 + 44);
    BOOL v17 = a4 == 8;
    if (v17 && v15) {
      v16 |= 0x4000u;
    }
    srcFormat.bitmapInfo = v16;
    memset(&destFormat.colorSpace, 0, 32);
    int v18 = *(unsigned __int8 *)(a1 + 56);
    destFormat.bitsPerComponent = a7;
    destFormat.bitsPerPixel = v18 * a7;
    BOOL v20 = a7 == 8 && v18 == 4;
    if (v17 && v20) {
      CGBitmapInfo v21 = *(_DWORD *)(a1 + 60) | 0x4000;
    }
    else {
      CGBitmapInfo v21 = *(_DWORD *)(a1 + 60);
    }
    destFormat.bitmapInfo = v21;
    vImageConverterRef v22 = vImageConverter_CreateWithCGImageFormat(&srcFormat, &destFormat, 0, 0, &error);
    *(void *)(a1 + 8) = v22;
    if (!v22 || error)
    {
      vImagePixelCount v23 = IIO_vImageErrorString(error);
      _cg_jpeg_mem_term("IIOPixelConverterLab", 1335, "*** IIOPixelConverterLab could not create vImageConverter '%s'\n", v23);
    }
  }
  return a1;
}

void sub_1887F5E4C(_Unwind_Exception *a1)
{
  ImageIOPixelConverter::~ImageIOPixelConverter(v1);
  _Unwind_Resume(a1);
}

void IIOPixelConverterLab::~IIOPixelConverterLab(IIOPixelConverterLab *this)
{
  ImageIOPixelConverter::~ImageIOPixelConverter(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIOPixelConverterLab::convert(IIOPixelConverterLab *this, vImage_Buffer *srcs, vImage_Buffer *dests)
{
  if (__PAIR64__(*((_DWORD *)this + 9), *((unsigned __int8 *)this + 32)) == __PAIR64__(*((_DWORD *)this + 13), *((unsigned __int8 *)this + 49)))
  {
    CFDictionaryRef data = srcs->data;
    rowuint64_t Bytes = srcs->rowBytes;
    if (rowBytes >= dests->rowBytes) {
      rowuint64_t Bytes = dests->rowBytes;
    }
    memcpy(dests->data, data, rowBytes * dests->height);
    vImagePixelCount height = dests->height;
    if (*((unsigned char *)this + 39) == 8)
    {
      if (height)
      {
        uint64_t v9 = 0;
        unsigned int v10 = 0;
        vImagePixelCount width = dests->width;
        do
        {
          if (width)
          {
            size_t v12 = (char *)dests->data + dests->rowBytes * v9;
            unsigned int v13 = 1;
            do
            {
              v12[1] ^= 0x80u;
              v12[2] ^= 0x80u;
              v12 += *((unsigned __int8 *)this + 56);
              vImagePixelCount width = dests->width;
              BOOL v14 = width > v13++;
            }
            while (v14);
            vImagePixelCount height = dests->height;
          }
          uint64_t v9 = ++v10;
        }
        while (height > v10);
      }
    }
    else if (height)
    {
      uint64_t v20 = 0;
      vImagePixelCount v21 = dests->width;
      vImageConverterRef v22 = (char *)dests->data + 4;
      size_t v23 = 2 * dests->rowBytes;
      do
      {
        if (v21)
        {
          uint64_t v24 = 2 * *((unsigned __int8 *)this + 56);
          unsigned int v25 = 1;
          vImagePixelCount v26 = v22;
          do
          {
            *(v26 - 1) ^= 0x8000u;
            *v26 ^= 0x8000u;
            BOOL v14 = v21 > v25++;
            vImagePixelCount v26 = (_WORD *)((char *)v26 + v24);
          }
          while (v14);
        }
        ++v20;
        v22 += v23;
      }
      while (height > v20);
    }
  }
  else
  {
    BOOL v15 = (vImageConverter *)*((void *)this + 1);
    if (v15)
    {
      vImage_Error v16 = iio_vImageConvert_AnyToAny(v15, srcs, dests, 0, 0);
      if (!v16) {
        goto LABEL_17;
      }
      BOOL v17 = IIO_vImageErrorString(v16);
      _cg_jpeg_mem_term("convert", 1392, "*** vImageConvert_AnyToAny: %s\n", v17);
    }
    _cg_jpeg_mem_term("convert", 1396, "   falling back to own convertAnyToAny [Lab]\n");
    ImageIOPixelConverter::convertAnyToAny(this, srcs, dests);
  }
LABEL_17:
  if (*((unsigned char *)this + 65) == 1)
  {
    long long v18 = *(_OWORD *)&dests->width;
    *(_OWORD *)&dest.CFDictionaryRef data = *(_OWORD *)&dests->data;
    *(_OWORD *)&dest.vImagePixelCount width = v18;
    vImageByteSwap_Planar16U(&dest, &dest, 0x10u);
  }
  return 0;
}

uint64_t IIOPixelConverterLab::convertRow(IIOPixelConverterLab *this, unsigned __int8 *a2, unsigned __int8 *a3, unsigned int a4)
{
  uint64_t v4 = (*((unsigned __int8 *)this + 37) * a4 * *((unsigned __int8 *)this + 41)) >> 3;
  uint64_t v5 = (*((unsigned __int8 *)this + 53) * a4 * *((unsigned __int8 *)this + 56)) >> 3;
  v8[0] = a2;
  v8[1] = 1;
  void v8[2] = a4;
  void v8[3] = v4;
  v7[0] = a3;
  v7[1] = 1;
  BOOL v7[2] = a4;
  void v7[3] = v5;
  return (*(uint64_t (**)(IIOPixelConverterLab *, void *, void *))(*(void *)this + 16))(this, v8, v7);
}

uint64_t IIOPixelConverterCMYK::IIOPixelConverterCMYK(uint64_t a1, char a2, char a3, uint32_t a4, int a5, int a6, int a7, uint64_t a8, char a9, unsigned __int8 a10, char a11, uint64_t a12)
{
  *(unsigned char *)(a1 + 72) = 0;
  *(void *)a1 = &unk_1ED4E5240;
  vImage_Error error = 0;
  *(unsigned char *)(a1 + 32) = a2;
  *(unsigned char *)(a1 + 49) = a9;
  *(unsigned char *)(a1 + 17) = 2;
  *(void *)(a1 + 24) = a12;
  *(unsigned char *)(a1 + 65) = a11;
  *(unsigned char *)(a1 + 40) = a3;
  *(_DWORD *)(a1 + 36) = (a4 << 24) | (a5 << 16) | (a6 << 8) | a7;
  *(_DWORD *)(a1 + 52) = 16843009 * a10;
  ImageIOPixelConverter::extractInfo(a1);
  *(unsigned char *)(a1 + 16) = 1;
  CFStringRef v14 = (const __CFString *)*MEMORY[0x1E4F1DBF0];
  v29[0] = (CGColorSpaceRef)&unk_1ED4DFD58;
  BOOL v15 = CGColorSpaceCreateWithName(v14);
  v29[1] = v15;
  srcFormat.decode = 0;
  *(void *)&srcFormat.renderingIntent = 0;
  int v16 = *(unsigned __int8 *)(a1 + 41);
  BOOL v17 = v16 == 4;
  srcFormat.bitsPerComponent = a4;
  srcFormat.bitsPerPixel = v16 * a4;
  CGBitmapInfo v18 = *(_DWORD *)(a1 + 44);
  BOOL v19 = a4 == 8;
  if (v19 && v17) {
    v18 |= 0x4000u;
  }
  srcFormat.colorSpace = v15;
  srcFormat.version = 0;
  srcFormat.bitmapInfo = v18;
  destFormat.decode = 0;
  *(void *)&destFormat.renderingIntent = 0;
  int v20 = *(unsigned __int8 *)(a1 + 56);
  destFormat.bitsPerComponent = a10;
  destFormat.bitsPerPixel = v20 * a10;
  BOOL v22 = a10 == 8 && v20 == 4;
  if (v19 && v22) {
    CGBitmapInfo v23 = *(_DWORD *)(a1 + 60) | 0x4000;
  }
  else {
    CGBitmapInfo v23 = *(_DWORD *)(a1 + 60);
  }
  destFormat.colorSpace = v15;
  destFormat.version = 0;
  destFormat.bitmapInfo = v23;
  vImageConverterRef v24 = vImageConverter_CreateWithCGImageFormat(&srcFormat, &destFormat, 0, 0, &error);
  *(void *)(a1 + 8) = v24;
  if (!v24 || error)
  {
    unsigned int v25 = IIO_vImageErrorString(error);
    _cg_jpeg_mem_term("IIOPixelConverterCMYK", 1486, "*** IIOPixelConverterCMYK could not create vImageConverter '%s'\n", v25);
  }
  IIOColorSpace::~IIOColorSpace(v29);
  return a1;
}

void sub_1887F62C0(_Unwind_Exception *a1)
{
  ImageIOPixelConverter::~ImageIOPixelConverter(v1);
  _Unwind_Resume(a1);
}

void IIOPixelConverterCMYK::~IIOPixelConverterCMYK(IIOPixelConverterCMYK *this)
{
  ImageIOPixelConverter::~ImageIOPixelConverter(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIOPixelConverterCMYK::convert(IIOPixelConverterCMYK *this, vImage_Buffer *srcs, vImage_Buffer *dests)
{
  if (*((unsigned char *)this + 16))
  {
    uint64_t v6 = (vImageConverter *)*((void *)this + 1);
    if (!v6)
    {
LABEL_5:
      _cg_jpeg_mem_term("convert", 1512, "   falling back to own convertAnyToAny [CMYK]\n");
      ImageIOPixelConverter::convertAnyToAny(this, srcs, dests);
      return 0;
    }
    vImage_Error v7 = iio_vImageConvert_AnyToAny(v6, srcs, dests, 0, 0);
    if (v7)
    {
      size_t v8 = IIO_vImageErrorString(v7);
      _cg_jpeg_mem_term("convert", 1508, "*** vImageConvert_AnyToAny: %s\n", v8);
      goto LABEL_5;
    }
  }
  return 0;
}

uint64_t IIOPixelConverterCMYK::convertRow(IIOPixelConverterCMYK *this, unsigned __int8 *a2, unsigned __int8 *a3, unsigned int a4)
{
  uint64_t v4 = (*((unsigned __int8 *)this + 37) * a4 * *((unsigned __int8 *)this + 41)) >> 3;
  uint64_t v5 = (*((unsigned __int8 *)this + 53) * a4 * *((unsigned __int8 *)this + 56)) >> 3;
  v8[0] = a2;
  v8[1] = 1;
  void v8[2] = a4;
  void v8[3] = v4;
  v7[0] = a3;
  v7[1] = 1;
  BOOL v7[2] = a4;
  void v7[3] = v5;
  return (*(uint64_t (**)(IIOPixelConverterCMYK *, void *, void *))(*(void *)this + 16))(this, v8, v7);
}

void IIOColorMap::IIOColorMap(IIOColorMap *this, int a2, int a3)
{
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = a3;
  *((unsigned char *)this + 8) = 0;
  *((void *)this + 2) = 0;
  operator new[]();
}

void sub_1887F64C8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 16);
  *(void *)(v1 + 16) = 0;
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C8033FC2DF1);
  }
  _Unwind_Resume(exception_object);
}

void IIOColorMap::IIOColorMap(IIOColorMap *this, const unsigned __int8 *a2, unint64_t a3)
{
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  *((unsigned char *)this + 8) = 0;
  if (a3 >= 0xC)
  {
    *(void *)this = *(void *)a2;
    *((unsigned char *)this + 8) = a2[8];
    operator new[]();
  }
}

void sub_1887F65B0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 16);
  *(void *)(v1 + 16) = 0;
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C8033FC2DF1);
  }
  _Unwind_Resume(exception_object);
}

void IIOColorMap::IIOColorMap(IIOColorMap *this, CFReadStreamRef stream)
{
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  *((unsigned char *)this + 8) = 0;
  *(_DWORD *)UInt8 buffer = 0;
  int v7 = 0;
  *(void *)uint64_t v6 = 0;
  if (CFReadStreamRead(stream, buffer, 4) == 4)
  {
    BOOL v4 = *(_DWORD *)buffer != 1885433187 && *(_DWORD *)buffer == 1346456899;
    if (v4 && CFReadStreamRead(stream, v6, 12) == 12 && *(_DWORD *)v6 <= 0x100u)
    {
      int v5 = *(_DWORD *)&v6[4];
      *(_DWORD *)this = *(_DWORD *)v6;
      *((_DWORD *)this + 1) = v5;
      *((unsigned char *)this + 8) = v7;
      operator new[]();
    }
  }
}

void sub_1887F6714(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 + 16);
  *(void *)(v1 + 16) = 0;
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C8033FC2DF1);
  }
  _Unwind_Resume(exception_object);
}

char *IIOColorMap::createSerializedData(IIOColorMap *this, unint64_t *a2)
{
  size_t v3 = 3 * *(unsigned int *)this + 12;
  *a2 = v3;
  BOOL v4 = (char *)malloc_type_malloc(v3, 0xEF744ED1uLL);
  uint64_t v5 = *(void *)this;
  *(void *)BOOL v4 = *(void *)this;
  v4[8] = *((unsigned char *)this + 8);
  memcpy(v4 + 12, *((const void **)this + 2), 3 * v5);
  return v4;
}

uint64_t IIOColorMap::writeEmptyPlaceholderToStream(IIOColorMap *this, __CFWriteStream *a2)
{
  *(_DWORD *)UInt8 buffer = 1885433187;
  if (CFWriteStreamWrite(this, buffer, 4) == 4) {
    return 0;
  }
  else {
    return 4294967260;
  }
}

uint64_t IIOColorMap::writeToStream(IIOColorMap *this, CFWriteStreamRef stream)
{
  int v6 = 0;
  uint64_t v5 = *(void *)this;
  LOBYTE(v6) = *((unsigned char *)this + 8);
  *(_DWORD *)UInt8 buffer = 1346456899;
  if (CFWriteStreamWrite(stream, buffer, 4) != 4 || CFWriteStreamWrite(stream, (const UInt8 *)&v5, 12) != 12) {
    return 4294967260;
  }
  if (CFWriteStreamWrite(stream, *((const UInt8 **)this + 2), 3 * *(unsigned int *)this) == 3
                                                                                             * *(unsigned int *)this)
    return 0;
  return 4294967260;
}

unsigned int *IIOColorMap::copyToRGBX(unsigned int *this, unsigned int *a2, unint64_t a3, char a4)
{
  unint64_t v4 = *this;
  if (a3 >> 2 < v4) {
    unint64_t v4 = a3 >> 2;
  }
  if (v4)
  {
    uint64_t v5 = (__int16 *)*((void *)this + 2);
    unint64_t v6 = v4;
    int v7 = a2;
    do
    {
      __int16 v8 = *v5;
      *((unsigned char *)v7 + 2) = *((unsigned char *)v5 + 2);
      *(_WORD *)int v7 = v8;
      *((unsigned char *)v7 + 3) = -1;
      uint64_t v5 = (__int16 *)((char *)v5 + 3);
      ++v7;
      --v6;
    }
    while (v6);
  }
  if (a4)
  {
    *(_DWORD *)permuteMap = 50331906;
    dest.CFDictionaryRef data = a2;
    dest.vImagePixelCount height = 1;
    dest.vImagePixelCount width = (unsigned __int16)v4;
    dest.rowuint64_t Bytes = 4 * (unsigned __int16)v4;
    return (unsigned int *)vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
  }
  return this;
}

BOOL IIOColorMap::indexForColor(IIOColorMap *this, _DWORD *a2, const unsigned int *a3, unsigned char *a4, unsigned __int8 *a5)
{
  *a4 = 0;
  if (!a3) {
    return 0;
  }
  if (*a2 != this)
  {
    unint64_t v5 = 0;
    while (a3 - 1 != v5)
    {
      int v7 = a2[++v5];
      if (v7 == this)
      {
        BOOL result = v5 < a3;
        goto LABEL_8;
      }
    }
    return 0;
  }
  LOBYTE(v5) = 0;
  BOOL result = 1;
LABEL_8:
  *a4 = v5;
  return result;
}

uint64_t _cg_png_get_PLTE(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4)
{
  uint64_t result = 0;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0;
      if (a3)
      {
        if ((*(_DWORD *)(a2 + 8) & 8) != 0)
        {
          *a3 = *(void *)(a2 + 24);
          *a4 = *(unsigned __int16 *)(a2 + 32);
          return 8;
        }
      }
    }
  }
  return result;
}

uint64_t _cg_png_get_next_frame_fcTL(uint64_t a1, uint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _WORD *a7, _WORD *a8, unsigned char *a9, unsigned char *a10)
{
  uint64_t result = 0;
  if (a1 && a2)
  {
    if (a10) {
      BOOL v12 = a9 == 0;
    }
    else {
      BOOL v12 = 1;
    }
    if (v12
      || a8 == 0
      || a7 == 0
      || a6 == 0
      || a5 == 0
      || a4 == 0
      || a3 == 0
      || (*(_DWORD *)(a2 + 8) & 0x40000) == 0)
    {
      return 0;
    }
    else
    {
      *a3 = *(_DWORD *)(a2 + 368);
      *a4 = *(_DWORD *)(a2 + 372);
      *a5 = *(_DWORD *)(a2 + 376);
      *a6 = *(_DWORD *)(a2 + 380);
      *a7 = *(_WORD *)(a2 + 384);
      *a8 = *(_WORD *)(a2 + 386);
      *a9 = *(unsigned char *)(a2 + 388);
      *a10 = *(unsigned char *)(a2 + 389);
      return 1;
    }
  }
  return result;
}

uint64_t _cg_png_get_first_frame_is_hidden(uint64_t result)
{
  if (result) {
    return *(unsigned char *)(result + 768) & 1;
  }
  return result;
}

void IIOWritePlugin::IIOWritePlugin(IIOWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, int a4)
{
  *(void *)this = &unk_1ED4E1440;
  *((_DWORD *)this + 8) = a4;
  *((void *)this + 2) = a2;
  *((void *)this + 3) = a3;
  *((unsigned char *)this + 36) = IIOPluginShouldDebugWriteImageBlocks();
}

uint64_t IIOWritePlugin::writeOne(IIOWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t IIOWritePlugin::writeAll(IIOImageDestination **this)
{
  uint64_t v2 = IIOImageDestination::pixelProviderCount(this[3]);
  if (v2)
  {
    unint64_t v3 = 0;
    uint64_t v4 = 4294967246;
    while (1)
    {
      PixelProviderAtIndeCGFloat x = (IIOImageSource *)IIOImageDestination::getPixelProviderAtIndex((CFArrayRef *)this[3], v3);
      ImagePropertiesAtIndeCGFloat x = IIOImageDestination::getImagePropertiesAtIndex(this[3], v3);
      SourceGeomCGColorSpaceRef ColorSpace = IIOImagePlus::getSourceGeomColorSpace(this[3]);
      if (!PixelProviderAtIndex) {
        goto LABEL_6;
      }
      uint64_t v8 = SourceGeomColorSpace;
      if ((*((unsigned int (**)(IIOImageDestination **, IIOImageSource *, uint64_t, uint64_t, unint64_t))*this
            + 3))(this, PixelProviderAtIndex, ImagePropertiesAtIndex, SourceGeomColorSpace, v3))
      {
        break;
      }
LABEL_7:
      uint64_t v4 = 0;
      if (v2 == ++v3) {
        return v4;
      }
    }
    uint64_t Ref = IIOImageSource::imageReadRef(PixelProviderAtIndex);
    uint64_t v4 = (*((uint64_t (**)(IIOImageDestination **, uint64_t, uint64_t, uint64_t, unint64_t))*this + 4))(this, Ref, ImagePropertiesAtIndex, v8, v3);
LABEL_6:
    if (v4) {
      return v4;
    }
    goto LABEL_7;
  }
  return 4294967246;
}

uint64_t IIOWritePlugin::getSourceImageAtIndex(IIOImageDestination **this, unint64_t a2)
{
  return IIOImageDestination::getSourceImageAtIndex(this[3], a2);
}

BOOL IIOWritePlugin::createLZFSECompressedData(IIOWritePlugin *this, unsigned __int8 *a2, size_t size, unsigned __int8 **a4, unsigned __int8 **a5)
{
  uint64_t v9 = (unsigned __int8 *)malloc_type_malloc(size, 0x80BD9F20uLL);
  *a4 = v9;
  if (v9) {
    uint64_t v9 = (unsigned __int8 *)compression_encode_buffer(v9, size, a2, size, 0, COMPRESSION_LZFSE);
  }
  *a5 = v9;
  return v9 != 0;
}

size_t png_default_write_data(size_t result, void *__ptr, size_t a3)
{
  if (result)
  {
    uint64_t v4 = (void (**)(void))result;
    uint64_t result = fwrite(__ptr, 1uLL, a3, *(FILE **)(result + 40));
    if (result != a3) {
      _cg_png_error(v4, "Write Error");
    }
  }
  return result;
}

uint64_t png_default_flush(uint64_t result)
{
  if (result) {
    return fflush(*(FILE **)(result + 40));
  }
  return result;
}

const char *AppleJPEGReadPlugin::ColorConvert(IIOColorConverter *this, uint64_t a2, uint64_t a3)
{
  int v4 = *(_DWORD *)(a2 + 40);
  vImagePixelCount v5 = *(int *)(a2 + 44);
  int v6 = *(_DWORD *)(a2 + 120);
  int v7 = *(_DWORD *)(a3 + 40);
  int v8 = *(_DWORD *)(a3 + 48);
  int v9 = *(_DWORD *)(a3 + 120);
  unsigned int v10 = *(void **)a2;
  long long v11 = *(void **)a3;
  if (!v6)
  {
    int v14 = *(_DWORD *)(a2 + 48);
    if ((v14 - 3) < 2)
    {
      int v6 = 4 * v4;
    }
    else if (v14 == 5)
    {
      int v6 = *(_DWORD *)(a2 + 40);
    }
    else if (v14)
    {
      _cg_jpeg_mem_term("ColorConvert", 91, "inRowBytes is 0\n");
      int v6 = 0;
    }
    else
    {
      int v6 = 3 * v4;
    }
  }
  if (!v9)
  {
    if ((v8 - 3) < 2)
    {
      int v9 = 4 * v7;
    }
    else if (v8 == 5)
    {
      int v9 = v7;
    }
    else if (v8)
    {
      _cg_jpeg_mem_term("ColorConvert", 110, "outRowBytes is 0\n");
      int v9 = 0;
    }
    else
    {
      int v9 = 3 * v7;
    }
  }
  v16.CFDictionaryRef data = v10;
  v16.vImagePixelCount height = v5;
  v16.vImagePixelCount width = v4;
  v16.rowuint64_t Bytes = v6;
  v15.CFDictionaryRef data = v11;
  v15.vImagePixelCount height = v5;
  v15.vImagePixelCount width = v7;
  v15.rowuint64_t Bytes = v9;
  uint64_t result = (const char *)IIOColorConverter::colorConvert(this, &v16, &v15);
  if (result)
  {
    unsigned int v13 = IIO_vImageErrorString((uint64_t)result);
    return LogError("ColorConvert", 121, "*** vImageConvert_AnyToAny - %s\n", v13);
  }
  return result;
}

uint64_t AppleJPEGReadPlugin::IIORecodeAppleJPEG_to_JPEG(AppleJPEGReadPlugin *this, IIOImageDestination *a2, IIOImageSource *a3)
{
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "IIORecodeAppleJPEG_to_JPEG", 0, 0, -1, 0);
  }
  uint64_t v39 = 0;
  *(void *)UInt8 buffer = 0;
  IIOImageSource::count(this);
  uint64_t v38 = 0;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v35 = 0u;
  uint64_t v34 = 0;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v31 = 0u;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  int v27 = 0;
  long long v25 = xmmword_1ED4F0D10;
  uint64_t v26 = qword_1ED4F0D20;
  CFStringRef v5 = (const __CFString *)*MEMORY[0x1E4F1DC98];
  v24[0] = (CGColorSpaceRef)&unk_1ED4DFD58;
  CFStringRef theString2 = v5;
  v24[1] = CGColorSpaceCreateWithName(v5);
  CFStringRef v6 = (const __CFString *)*MEMORY[0x1E4F1DB90];
  v23[0] = (CGColorSpaceRef)&unk_1ED4DFD58;
  v23[1] = CGColorSpaceCreateWithName(v6);
  vImagePixelCount v21 = this;
  Plugin = (CGImage *)IIOImagePlus::readPlugin(this);
  CFTypeRef cf = Plugin;
  if (Plugin)
  {
    CFRetain(Plugin);
  }
  else
  {
    CGColorSpaceRef ColorSpace = (CGImageSource *)IIOReadPlugin::getColorSpace(this);
    CFTypeRef cf = CGImageSourceCreateImageAtIndex(ColorSpace, 0, 0);
    if (!cf)
    {
      _cg_jpeg_mem_term("IIORecodeAppleJPEG_to_JPEG", 180, "*** ERROR: cannot get the source image...");
      goto LABEL_19;
    }
  }
  CGColorSpaceRef space = CGImageGetColorSpace(cf);
  CGColorSpaceModel Model = CGColorSpaceGetModel(space);
  if (Model >= kCGColorSpaceModelCMYK)
  {
    CGBitmapInfo v18 = IIO_ColorModelString(Model);
    _cg_jpeg_mem_term("IIORecodeAppleJPEG_to_JPEG", 186, "*** ERROR: applejpeg_recode_session cannot handle non-RGB data (%s)\n", v18);
  }
  else
  {
    CFStringRef Name = CGColorSpaceGetName(space);
    if (Name) {
      CFStringCompare(Name, theString2, 0);
    }
    if (a2)
    {
      uint64_t Ref = IIOImageSource::imageReadRef(a2);
      *(void *)UInt8 buffer = Ref;
    }
    else
    {
      Propertdouble y = (const __CFData *)CGImageGetProperty();
      if (Property)
      {
        v41.location = 0;
        v41.size_t length = 8;
        CFDataGetBytes(Property, v41, buffer);
      }
      uint64_t Ref = *(void *)buffer;
    }
    if (Ref)
    {
      IIOImageDestination::getPixelProviderAtIndex((CFArrayRef *)this, 0);
      if (a2) {
        ImagePropertiesAtIndeCGFloat x = (IIODictionary *)IIOImageSource::getImagePropertiesAtIndex(a2, 0);
      }
      else {
        ImagePropertiesAtIndeCGFloat x = 0;
      }
      int v14 = (JPEGWritePlugin *)IIOImageDestination::getImagePropertiesAtIndex(v21, 0);
      IIOSkipMetadata(ImagePropertiesAtIndex);
      JPEGWritePlugin::GetImageIOCompressionQuality(v14, v15);
      IIODictionary::getBoolForKey(v14, @"kCGImageSourceCreateThumbnailWithTransform");
      IIOReadPlugin::CreateRecodeProperties(a2, ImagePropertiesAtIndex, v21, v14, (IIODictionary *)&v39, v16);
    }
    _cg_jpeg_mem_term("IIORecodeAppleJPEG_to_JPEG", 208, "*** ERROR: cannot get the 'CGImageReadRef' of the source image...");
  }
  CGImageRelease(cf);
LABEL_19:
  IIOColorSpace::~IIOColorSpace(v23);
  IIOColorSpace::~IIOColorSpace(v24);
  return 0;
}

void sub_1887F7ED4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,CGColorSpaceRef a47,uint64_t a48,CGColorSpaceRef a49)
{
}

uint64_t IIOBitStream::CreateIIOBitStream(IIOBitStream *this, void *a2, unsigned __int8 *a3, const char *a4)
{
  uint64_t result = 0;
  if (this && a2 && a3)
  {
    int v6 = *a3;
    if (v6 == 119) {
      operator new();
    }
    if (v6 == 114) {
      operator new();
    }
    return 0;
  }
  return result;
}

uint64_t IIOBitStream::putBits(IIOBitStream *this)
{
  return 4294967292;
}

uint64_t IIOBitStream::getBits(IIOBitStream *this, unsigned __int16 a2, unsigned int *a3)
{
  return 4294967292;
}

uint64_t IIOBitStream::seek(IIOBitStream *this, unint64_t a2)
{
  if (*((void *)this + 3) <= a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *((void *)this + 4) = a2;
  return result;
}

void IIOBitStreamReader::~IIOBitStreamReader(IIOBitStreamReader *this)
{
  *(void *)this = &unk_1ED4E4558;
  *((_WORD *)this + 4) = 0;
}

{
  *(void *)this = &unk_1ED4E4558;
  *((_WORD *)this + 4) = 0;
  JUMPOUT(0x18C11C0E0);
}

uint64_t IIOBitStreamReader::getBits(IIOBitStreamReader *this, signed int a2, unsigned int *a3)
{
  if (a2 > 0x20) {
    return 4294967293;
  }
  unint64_t v4 = *((void *)this + 3);
  unint64_t v3 = *((void *)this + 4);
  if (a2 != 8)
  {
    if (v3 >= v4)
    {
      if (v3 != v4) {
        return 0xFFFFFFFFLL;
      }
      signed int v6 = *((char *)this + 9);
      if (a2 > v6) {
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      signed int v6 = *((char *)this + 9);
    }
    char v7 = v6;
    if (v6 >= a2)
    {
      int v8 = 0;
      unsigned int v11 = *((unsigned __int8 *)this + 8);
      char v10 = a2;
LABEL_18:
      *((unsigned char *)this + 9) = v7 - a2;
      int v5 = (v11 >> (v7 - a2)) & ~(-1 << v10) | v8;
      goto LABEL_19;
    }
    int v8 = 0;
    if (v3 <= v4) {
      uint64_t v9 = *((void *)this + 3);
    }
    else {
      uint64_t v9 = *((void *)this + 4);
    }
    while (v9 != v3)
    {
      LOWORD(a2) = a2 - v7;
      char v10 = a2;
      v8 |= (*((unsigned __int8 *)this + 8) & ~(-1 << v6)) << a2;
      unsigned int v11 = *(unsigned __int8 *)(*((void *)this + 2) + v3++);
      *((void *)this + 4) = v3;
      *((unsigned char *)this + 8) = v11;
      LOBYTE(v6) = 8;
      *((unsigned char *)this + 9) = 8;
      char v7 = 8;
      if ((unsigned __int16)a2 <= 8u) {
        goto LABEL_18;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (v3 >= v4) {
    return 0xFFFFFFFFLL;
  }
  int v5 = *(unsigned __int8 *)(*((void *)this + 2) + v3);
  *((void *)this + 4) = v3 + 1;
LABEL_19:
  uint64_t result = 0;
  if (a3) {
    *a3 = v5;
  }
  return result;
}

void IIOBitStreamWriter::~IIOBitStreamWriter(IIOBitStreamWriter *this)
{
  *(void *)this = &unk_1ED4E4590;
  if (*((void *)this + 4) < *((void *)this + 3)) {
    IIOBitStreamWriter::putBits(this, 7u, 0);
  }
}

{
  uint64_t vars8;

  *(void *)this = &unk_1ED4E4590;
  if (*((void *)this + 4) < *((void *)this + 3)) {
    IIOBitStreamWriter::putBits(this, 7u, 0);
  }

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIOBitStreamWriter::putBits(IIOBitStreamWriter *this, unsigned int a2, unsigned int a3)
{
  if (a2 > 0x20) {
    return 4294967293;
  }
  unint64_t v3 = *((void *)this + 4);
  if (v3 >= *((void *)this + 3)) {
    return 0xFFFFFFFFLL;
  }
  signed int v4 = *((char *)this + 9);
  char v5 = *((unsigned char *)this + 9);
  if ((int)a2 >= v4)
  {
    char v8 = *((unsigned char *)this + 8);
    do
    {
      LOWORD(a2) = a2 - v5;
      char v7 = a2;
      *(unsigned char *)(*((void *)this + 2) + v3) = v8 | (a3 >> a2) & ~(-1 << v4);
      unint64_t v3 = *((void *)this + 4) + 1;
      *((void *)this + 4) = v3;
      *((unsigned char *)this + 8) = 0;
      LOBYTE(v4) = 8;
      char v5 = 8;
      char v8 = 0;
    }
    while ((unsigned __int16)a2 > 7u);
    char v6 = 0;
  }
  else
  {
    char v6 = *((unsigned char *)this + 8);
    char v7 = a2;
  }
  uint64_t v9 = 0;
  char v10 = v5 - a2;
  *((unsigned char *)this + 9) = v10;
  *((unsigned char *)this + 8) = v6 | ((a3 & ~(-1 << v7)) << v10);
  return v9;
}

uint64_t _cg_TIFFRGBAImageOK(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)(a1 + 944))
  {
    uint64_t result = 0;
    strcpy(a2, "Sorry, requested compression method is not configured");
    return result;
  }
  unsigned int v10 = *(unsigned __int16 *)(a1 + 116);
  if (v10 > 0x10 || ((1 << v10) & 0x10116) == 0)
  {
    snprintf(a2, 0x400uLL, "Sorry, can not handle images with %hu-bit samples");
  }
  else
  {
    if (*(_WORD *)(a1 + 118) == 3)
    {
      uint64_t result = 0;
      strcpy(a2, "Sorry, can not handle images with IEEE floating-point samples");
      return result;
    }
    HIWORD(v21) = 0;
    int v13 = *(unsigned __int16 *)(a1 + 130) - *(unsigned __int16 *)(a1 + 212);
    if (_cg_TIFFGetField((void *)a1, 262, a3, a4, a5, a6, a7, a8, (uint64_t)&v21 + 2))
    {
      uint64_t result = 1;
      switch(HIWORD(v21))
      {
        case 0:
        case 1:
        case 3:
          goto LABEL_17;
        case 2:
          if (v13 > 2) {
            return result;
          }
          snprintf(a2, 0x400uLL, "Sorry, can not handle RGB image with %s=%d");
          return 0;
        case 4:
        case 7:
          goto LABEL_29;
        case 5:
          LOWORD(v21) = 0;
          _cg_TIFFGetFieldDefaulted(a1, 332, v14, v15, v16, v17, v18, v19, &v21);
          if ((unsigned __int16)v21 == 1)
          {
            if (*(unsigned __int16 *)(a1 + 130) > 3u) {
              return 1;
            }
            snprintf(a2, 0x400uLL, "Sorry, can not handle separated image with %s=%hu");
          }
          else
          {
            snprintf(a2, 0x400uLL, "Sorry, can not handle separated image with %s=%d");
          }
          return 0;
        case 6:
          return result;
        case 8:
          int v20 = *(unsigned __int16 *)(a1 + 116);
          if (*(_WORD *)(a1 + 130) == 3 && v13 == 3 && (v20 == 8 || v20 == 16)) {
            return result;
          }
          snprintf(a2, 0x400uLL, "Sorry, can not handle image with %s=%hu, %s=%d and %s=%hu", "Samples/pixel");
          return 0;
        default:
          if (HIWORD(v21) == 32844)
          {
            if (*(unsigned __int16 *)(a1 + 120) == 34676) {
              return 1;
            }
            snprintf(a2, 0x400uLL, "Sorry, LogL data must have %s=%d");
            return 0;
          }
          if (HIWORD(v21) != 32845)
          {
LABEL_29:
            snprintf(a2, 0x400uLL, "Sorry, can not handle image with %s=%hu");
            return 0;
          }
          if ((*(_WORD *)(a1 + 120) & 0xFFFE) != 0x8774)
          {
            snprintf(a2, 0x400uLL, "Sorry, LogLuv data must have %s=%d or %d");
            return 0;
          }
          if (*(_WORD *)(a1 + 170) != 1)
          {
            snprintf(a2, 0x400uLL, "Sorry, can not handle LogLuv images with %s=%hu");
            return 0;
          }
          if (*(_WORD *)(a1 + 130) != 3 || v13 != 3)
          {
            snprintf(a2, 0x400uLL, "Sorry, can not handle image with %s=%hu, %s=%d");
            return 0;
          }
          break;
      }
      return 1;
    }
    if (v13 == 3) {
      return 1;
    }
    if (v13 != 1)
    {
      snprintf(a2, 0x400uLL, "Missing needed %s tag");
      return 0;
    }
    HIWORD(v21) = 1;
LABEL_17:
    if (*(_WORD *)(a1 + 170) != 1 || *(_WORD *)(a1 + 130) == 1 || *(unsigned __int16 *)(a1 + 116) > 7u) {
      return 1;
    }
    snprintf(a2, 0x400uLL, "Sorry, can not handle contiguous data with %s=%hu, and %s=%hu and Bits/Sample=%hu");
  }
  return 0;
}

void _cg_TIFFRGBAImageEnd(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 80);
  if (v2)
  {
    _TIFFfreeExt(*(void *)a1, v2);
    *(void *)(a1 + 80) = 0;
  }
  unint64_t v3 = *(char **)(a1 + 88);
  if (v3)
  {
    _TIFFfreeExt(*(void *)a1, v3);
    *(void *)(a1 + 88) = 0;
  }
  signed int v4 = *(char **)(a1 + 96);
  if (v4)
  {
    _TIFFfreeExt(*(void *)a1, v4);
    *(void *)(a1 + 96) = 0;
  }
  char v5 = *(char **)(a1 + 104);
  if (v5)
  {
    _TIFFfreeExt(*(void *)a1, v5);
    *(void *)(a1 + 104) = 0;
  }
  char v6 = *(char **)(a1 + 112);
  if (v6)
  {
    _TIFFfreeExt(*(void *)a1, v6);
    *(void *)(a1 + 112) = 0;
  }
  char v7 = *(char **)(a1 + 120);
  if (v7)
  {
    _TIFFfreeExt(*(void *)a1, v7);
    *(void *)(a1 + 120) = 0;
  }
  char v8 = *(char **)(a1 + 128);
  if (v8)
  {
    _TIFFfreeExt(*(void *)a1, v8);
    *(void *)(a1 + 128) = 0;
  }
  uint64_t v9 = *(char **)(a1 + 40);
  if (v9)
  {
    _TIFFfreeExt(*(void *)a1, v9);
    _TIFFfreeExt(*(void *)a1, *(char **)(a1 + 48));
    _TIFFfreeExt(*(void *)a1, *(char **)(a1 + 56));
    *(void *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
    *(void *)(a1 + 56) = 0;
  }
}

uint64_t _cg_TIFFRGBAImageBegin(void **a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = a3;
  uint64_t v199 = *MEMORY[0x1E4F143B8];
  uint64_t result = _cg_TIFFRGBAImageOK((uint64_t)a2, (char *)a4, a3, a4, a5, a6, a7, a8);
  if (result)
  {
    v196 = 0;
    int v195 = 0;
    unsigned __int16 v194 = 0;
    __vImage_Buffer src = 0;
    *((_OWORD *)a1 + 5) = 0u;
    a1[6] = 0;
    a1[7] = 0;
    a1[5] = 0;
    *((_OWORD *)a1 + 6) = 0u;
    *((_OWORD *)a1 + 7) = 0u;
    *((_OWORD *)a1 + 8) = 0u;
    *((_WORD *)a1 + 17) = 4;
    *a1 = a2;
    uint64_t v19 = (_WORD *)a1 + 14;
    *((_DWORD *)a1 + 2) = v9;
    _cg_TIFFGetFieldDefaulted((uint64_t)a2, 258, v13, v14, v15, v16, v17, v18, (_DWORD *)a1 + 7);
    unsigned int v26 = *((unsigned __int16 *)a1 + 14);
    if (v26 > 0x10 || ((1 << v26) & 0x10116) == 0)
    {
      snprintf((char *)a4, 0x400uLL, "Sorry, can not handle images with %hu-bit samples");
      goto LABEL_188;
    }
    *((_DWORD *)a1 + 4) = 0;
    int v27 = (_WORD *)a1 + 15;
    _cg_TIFFGetFieldDefaulted((uint64_t)a2, 277, v20, v21, v22, v23, v24, v25, (void **)((char *)a1 + 30));
    _cg_TIFFGetFieldDefaulted((uint64_t)a2, 338, v28, v29, v30, v31, v32, v33, (int *)((char *)&v195 + 2));
    if (HIWORD(v195))
    {
      int v40 = (unsigned __int16)*v196;
      if ((v40 - 1) < 2)
      {
LABEL_9:
        *((_DWORD *)a1 + 4) = v40;
        goto LABEL_10;
      }
      if (!*v196 && (unsigned __int16)*v27 > 3u)
      {
        int v40 = 1;
        goto LABEL_9;
      }
    }
LABEL_10:
    CFRange v41 = (__int16 *)a1 + 18;
    if (!_cg_TIFFGetField(a2, 262, v34, v35, v36, v37, v38, v39, (uint64_t)a1 + 36)) {
      *CFRange v41 = 0;
    }
    int v48 = HIWORD(v195);
    int v49 = (unsigned __int16)*v27;
    if (!HIWORD(v195))
    {
      if (v49 == 4 && *v41 == 2)
      {
        int v48 = 1;
        *((_DWORD *)a1 + 4) = 1;
        HIWORD(v195) = 1;
      }
      else
      {
        int v48 = 0;
      }
    }
    int v50 = v49 - v48;
    _cg_TIFFGetFieldDefaulted((uint64_t)a2, 259, v42, v43, v44, v45, v46, v47, &v194);
    _cg_TIFFGetFieldDefaulted((uint64_t)a2, 284, v51, v52, v53, v54, v55, v56, &v195);
    if (_cg_TIFFGetField(a2, 262, v57, v58, v59, v60, v61, v62, (uint64_t)a1 + 36))
    {
      int v69 = (unsigned __int16)*v41;
      switch(*v41)
      {
        case 0:
        case 1:
          goto LABEL_26;
        case 2:
          if (v50 > 2) {
            goto LABEL_49;
          }
          snprintf((char *)a4, 0x400uLL, "Sorry, can not handle RGB image with %s=%d");
          goto LABEL_188;
        case 3:
          if (_cg_TIFFGetField(a2, 320, v63, v64, v65, v66, v67, v68, (uint64_t)&__src))
          {
            __int16 v76 = *((_WORD *)a1 + 14);
            uint64_t v77 = 2 * (1 << v76);
            a1[5] = _TIFFmallocExt(a2, v77, v70, v71, v72, v73, v74, v75);
            a1[6] = _TIFFmallocExt(a2, v77, v78, v79, v80, v81, v82, v83);
            uint64_t v90 = _TIFFmallocExt(a2, v77, v84, v85, v86, v87, v88, v89);
            a1[7] = v90;
            unint64_t v91 = a1[5];
            if (v91 && a1[6] && v90)
            {
              size_t v92 = 2 << v76;
              _TIFFmemcpy(v91, __src, v92);
              _TIFFmemcpy(a1[6], 0, v92);
              _TIFFmemcpy(a1[7], 0, v92);
              goto LABEL_26;
            }
            long long v163 = "Out of memory for colormap copy";
          }
          else
          {
            long long v163 = "Missing required \"Colormap\" tag";
          }
          long long v164 = *((_OWORD *)v163 + 1);
          *(_OWORD *)a4 = *(_OWORD *)v163;
          *(_OWORD *)(a4 + 16) = v164;
          goto LABEL_188;
        case 4:
        case 7:
          goto LABEL_36;
        case 5:
          LOWORD(v198[0]) = 0;
          _cg_TIFFGetFieldDefaulted((uint64_t)a2, 332, v63, v64, v65, v66, v67, v68, v198);
          if (LOWORD(v198[0]) == 1 && (unsigned __int16)*v27 > 3u) {
            goto LABEL_49;
          }
          snprintf((char *)a4, 0x400uLL, "Sorry, can not handle separated image with %s=%hu");
          goto LABEL_188;
        case 6:
          if ((unsigned __int16)v195 != 1 || v194 != 7) {
            goto LABEL_49;
          }
          _cg_TIFFSetField((uint64_t)a2, 65538, v63, v64, v65, v66, v67, v68, 1);
          goto LABEL_48;
        case 8:
          goto LABEL_49;
        default:
          if (v69 == 32844)
          {
            if (v194 != 34676)
            {
              snprintf((char *)a4, 0x400uLL, "Sorry, LogL data must have %s=%d");
              goto LABEL_188;
            }
            _cg_TIFFSetField((uint64_t)a2, 65560, v63, v64, v65, v66, v67, v68, 3);
            __int16 v162 = 1;
          }
          else
          {
            if (v69 != 32845)
            {
LABEL_36:
              snprintf((char *)a4, 0x400uLL, "Sorry, can not handle image with %s=%hu");
              goto LABEL_188;
            }
            if ((unsigned __int16)(v194 + 30858) <= 0xFFFDu)
            {
              snprintf((char *)a4, 0x400uLL, "Sorry, LogLuv data must have %s=%d or %d");
              goto LABEL_188;
            }
            if ((unsigned __int16)v195 != 1)
            {
              snprintf((char *)a4, 0x400uLL, "Sorry, can not handle LogLuv images with %s=%hu", "Planarconfiguration", (unsigned __int16)v195);
              return 0;
            }
            _cg_TIFFSetField((uint64_t)a2, 65560, v63, v64, v65, v66, v67, v68, 3);
            __int16 v162 = 2;
          }
          *CFRange v41 = v162;
          *uint64_t v19 = 8;
          goto LABEL_49;
      }
    }
    if (v50 == 3)
    {
LABEL_48:
      *CFRange v41 = 2;
LABEL_49:
      _cg_TIFFGetField(a2, 256, v63, v64, v65, v66, v67, v68, (uint64_t)a1 + 20);
      _cg_TIFFGetField(a2, 257, v93, v94, v95, v96, v97, v98, (uint64_t)(a1 + 3));
      _cg_TIFFGetFieldDefaulted((uint64_t)a2, 274, v99, v100, v101, v102, v103, v104, (_DWORD *)a1 + 8);
      if ((unsigned __int16)v195 == 2)
      {
        unsigned int v105 = *((unsigned __int16 *)a1 + 15);
        *((_DWORD *)a1 + 3) = v105 < 2;
        if (v105 >= 2)
        {
          int v106 = _cg_TIFFIsTiled((uint64_t)*a1);
          unint64_t v114 = gtTileSeparate;
          if (!v106) {
            unint64_t v114 = gtStripSeparate;
          }
          a1[8] = v114;
          a1[9] = 0;
          unsigned int v115 = *((unsigned __int16 *)a1 + 18);
          if (v115 >= 3)
          {
            if (v115 == 5)
            {
              if (*v19 != 8 || *v27 != 4) {
                goto LABEL_184;
              }
              *((_DWORD *)a1 + 4) = 1;
              unint64_t v118 = putCMYKseparate8bittile;
            }
            else
            {
              if (v115 != 6)
              {
LABEL_187:
                strcpy((char *)a4, "Sorry, can not handle image");
                goto LABEL_188;
              }
              if (*v19 != 8) {
                goto LABEL_184;
              }
              if (*v27 != 3) {
                goto LABEL_184;
              }
              if (!initYCbCrConversion((uint64_t *)a1, v107, v108, v109, v110, v111, v112, v113)) {
                goto LABEL_184;
              }
              LOWORD(v198[0]) = 0;
              LOWORD(v197) = 0;
              _cg_TIFFGetFieldDefaulted((uint64_t)*a1, 530, v128, v129, v130, v131, v132, v133, v198);
              if (((unsigned __int16)v197 | (16 * LOWORD(v198[0]))) != 0x11) {
                goto LABEL_184;
              }
              unint64_t v118 = putseparate8bitYCbCr11tile;
            }
          }
          else
          {
            int v116 = (unsigned __int16)*v19;
            if (v116 != 16)
            {
              if (v116 == 8)
              {
                int v117 = *((_DWORD *)a1 + 4);
                if (v117 != 2)
                {
                  if (v117 == 1) {
                    unint64_t v118 = putRGBAAseparate8bittile;
                  }
                  else {
                    unint64_t v118 = putRGBseparate8bittile;
                  }
                  goto LABEL_183;
                }
                if (BuildMapUaToAa((uint64_t *)a1, v107, v108, v109, v110, v111, v112, v113))
                {
                  unint64_t v118 = putRGBUAseparate8bittile;
                  goto LABEL_183;
                }
              }
LABEL_184:
              if (a1[8] && a1[9]) {
                return 1;
              }
              goto LABEL_187;
            }
            int v165 = *((_DWORD *)a1 + 4);
            if (v165 == 2)
            {
              if (BuildMapBitdepth16To8((uint64_t *)a1, v107, v108, v109, v110, v111, v112, v113)
                && BuildMapUaToAa((uint64_t *)a1, v175, v176, v177, v178, v179, v180, v181))
              {
                unint64_t v118 = putRGBUAseparate16bittile;
                goto LABEL_183;
              }
              goto LABEL_184;
            }
            if (v165 != 1)
            {
              if (BuildMapBitdepth16To8((uint64_t *)a1, v107, v108, v109, v110, v111, v112, v113))
              {
                unint64_t v118 = putRGBseparate16bittile;
                goto LABEL_183;
              }
              goto LABEL_184;
            }
            if (!BuildMapBitdepth16To8((uint64_t *)a1, v107, v108, v109, v110, v111, v112, v113)) {
              goto LABEL_184;
            }
            unint64_t v118 = putRGBAAseparate16bittile;
          }
LABEL_183:
          a1[9] = v118;
          goto LABEL_184;
        }
      }
      else
      {
        *((_DWORD *)a1 + 3) = 1;
      }
      int v119 = _cg_TIFFIsTiled((uint64_t)*a1);
      unsigned int v127 = gtTileContig;
      if (!v119) {
        unsigned int v127 = gtStripContig;
      }
      a1[8] = v127;
      a1[9] = 0;
      switch(*((_WORD *)a1 + 18))
      {
        case 0:
        case 1:
          if (!buildMap(a1, v120, v121, v122, v123, v124, v125, v126)) {
            goto LABEL_184;
          }
          switch(*v19)
          {
            case 1:
              unint64_t v118 = put1bitbwtile;
              goto LABEL_183;
            case 2:
              unint64_t v118 = put2bitbwtile;
              goto LABEL_183;
            case 3:
            case 5:
            case 6:
            case 7:
              goto LABEL_184;
            case 4:
              unint64_t v118 = put4bitbwtile;
              goto LABEL_183;
            case 8:
              if (*((_DWORD *)a1 + 4) && *v27 == 2) {
                unint64_t v118 = putagreytile;
              }
              else {
                unint64_t v118 = putgreytile;
              }
              goto LABEL_183;
            default:
              if (*v19 != 16) {
                goto LABEL_184;
              }
              unint64_t v118 = put16bitbwtile;
              break;
          }
          goto LABEL_183;
        case 2:
          int v134 = (unsigned __int16)*v19;
          if (v134 != 16)
          {
            if (v134 != 8) {
              goto LABEL_184;
            }
            int v135 = *((_DWORD *)a1 + 4);
            if (v135 == 1)
            {
              unsigned int v136 = (unsigned __int16)*v27;
              if (v136 >= 4)
              {
                unint64_t v118 = putRGBAAcontig8bittile;
                goto LABEL_183;
              }
            }
            else if (v135 == 2)
            {
              unsigned int v136 = (unsigned __int16)*v27;
              if (v136 >= 4)
              {
                if (!BuildMapUaToAa((uint64_t *)a1, v120, v121, v122, v123, v124, v125, v126)) {
                  goto LABEL_184;
                }
                unint64_t v118 = putRGBUAcontig8bittile;
                goto LABEL_183;
              }
            }
            else
            {
              unsigned int v136 = (unsigned __int16)*v27;
            }
            if (v136 < 3) {
              goto LABEL_184;
            }
            unint64_t v118 = putRGBcontig8bittile;
            goto LABEL_183;
          }
          int v166 = *((_DWORD *)a1 + 4);
          if (v166 == 1)
          {
            unsigned int v167 = (unsigned __int16)*v27;
            if (v167 >= 4)
            {
              if (!BuildMapBitdepth16To8((uint64_t *)a1, v120, v121, v122, v123, v124, v125, v126)) {
                goto LABEL_184;
              }
              unint64_t v118 = putRGBAAcontig16bittile;
              goto LABEL_183;
            }
          }
          else if (v166 == 2)
          {
            unsigned int v167 = (unsigned __int16)*v27;
            if (v167 >= 4)
            {
              if (BuildMapBitdepth16To8((uint64_t *)a1, v120, v121, v122, v123, v124, v125, v126)
                && BuildMapUaToAa((uint64_t *)a1, v168, v169, v170, v171, v172, v173, v174))
              {
                unint64_t v118 = putRGBUAcontig16bittile;
                goto LABEL_183;
              }
              goto LABEL_184;
            }
          }
          else
          {
            unsigned int v167 = (unsigned __int16)*v27;
          }
          if (v167 >= 3 && BuildMapBitdepth16To8((uint64_t *)a1, v120, v121, v122, v123, v124, v125, v126))
          {
            unint64_t v118 = putRGBcontig16bittile;
            goto LABEL_183;
          }
          goto LABEL_184;
        case 3:
          if (buildMap(a1, v120, v121, v122, v123, v124, v125, v126))
          {
            switch(*v19)
            {
              case 1:
                unint64_t v118 = put1bitcmaptile;
                goto LABEL_183;
              case 2:
                unint64_t v118 = put2bitcmaptile;
                goto LABEL_183;
              case 4:
                unint64_t v118 = put4bitcmaptile;
                goto LABEL_183;
              case 8:
                unint64_t v118 = put8bitcmaptile;
                goto LABEL_183;
              default:
                goto LABEL_184;
            }
          }
          goto LABEL_184;
        case 5:
          if ((unsigned __int16)*v27 < 4u
            || !buildMap(a1, v120, v121, v122, v123, v124, v125, v126)
            || *v19 != 8)
          {
            goto LABEL_184;
          }
          if (a1[10]) {
            unint64_t v118 = putRGBcontig8bitCMYKMaptile;
          }
          else {
            unint64_t v118 = putRGBcontig8bitCMYKtile;
          }
          goto LABEL_183;
        case 6:
          if (*v19 != 8 || *v27 != 3 || !initYCbCrConversion((uint64_t *)a1, v120, v121, v122, v123, v124, v125, v126)) {
            goto LABEL_184;
          }
          LOWORD(v198[0]) = 0;
          LOWORD(v197) = 0;
          _cg_TIFFGetFieldDefaulted((uint64_t)*a1, 530, v137, v138, v139, v140, v141, v142, v198);
          int v143 = (unsigned __int16)v197 | (16 * LOWORD(v198[0]));
          unint64_t v118 = putcontig8bitYCbCr44tile;
          if (v143 <= 33)
          {
            switch(v143)
            {
              case 17:
                unint64_t v118 = putcontig8bitYCbCr11tile;
                break;
              case 18:
                unint64_t v118 = putcontig8bitYCbCr12tile;
                break;
              case 33:
                unint64_t v118 = putcontig8bitYCbCr21tile;
                break;
              default:
                goto LABEL_184;
            }
            goto LABEL_183;
          }
          if (v143 <= 65)
          {
            if (v143 == 34)
            {
              unint64_t v118 = putcontig8bitYCbCr22tile;
            }
            else
            {
              if (v143 != 65) {
                goto LABEL_184;
              }
              unint64_t v118 = putcontig8bitYCbCr41tile;
            }
            goto LABEL_183;
          }
          if (v143 == 68) {
            goto LABEL_183;
          }
          if (v143 == 66)
          {
            unint64_t v118 = putcontig8bitYCbCr42tile;
            goto LABEL_183;
          }
          goto LABEL_184;
        case 8:
          if (*v27 != 3) {
            goto LABEL_184;
          }
          if (!buildMap(a1, v120, v121, v122, v123, v124, v125, v126)) {
            goto LABEL_184;
          }
          int v150 = (unsigned __int16)*v19;
          if (v150 != 16 && v150 != 8) {
            goto LABEL_184;
          }
          v197 = 0;
          _cg_TIFFGetFieldDefaulted((uint64_t)*a1, 318, v144, v145, v146, v147, v148, v149, &v197);
          unint64_t v157 = v197;
          float v158 = v197[1];
          if (v158 == 0.0)
          {
            uint64_t v159 = (uint64_t)*a1;
            uint64_t v160 = "Invalid value for WhitePoint tag.";
LABEL_102:
            TIFFErrorExtR(v159, "initCIELabConversion", v160, v152, v153, v154, v155, v156, v192);
            goto LABEL_103;
          }
          unsigned int v182 = (float *)a1[14];
          if (!v182)
          {
            unsigned int v182 = (float *)_TIFFmallocExt(*a1, 18124, v151, v152, v153, v154, v155, v156);
            a1[14] = v182;
            if (!v182)
            {
              uint64_t v159 = (uint64_t)*a1;
              uint64_t v160 = "No space for CIE L*a*b*->RGB conversion state.";
              goto LABEL_102;
            }
            unint64_t v157 = v197;
            float v158 = v197[1];
          }
          v198[1] = 1120403456;
          float v183 = (float)(*v157 / v158) * 100.0;
          *(float *)&int v184 = (float)((float)((float)(1.0 - *v157) - v158) / v158) * 100.0;
          *(float *)v198 = v183;
          v198[2] = v184;
          if ((TIFFCIELabToRGBInit(v182, &display_sRGB, v198) & 0x80000000) == 0)
          {
            int v190 = (unsigned __int16)*v19;
            if (v190 == 16) {
              unsigned int v191 = putcontig8bitCIELab16;
            }
            else {
              unsigned int v191 = 0;
            }
            if (v190 == 8) {
              v161 = putcontig8bitCIELab8;
            }
            else {
              v161 = (float *(*)(float *, _DWORD *, uint64_t, uint64_t, int, int, int, int, unsigned __int8 *))v191;
            }
LABEL_170:
            a1[9] = v161;
            goto LABEL_184;
          }
          TIFFErrorExtR((uint64_t)*a1, "initCIELabConversion", "Failed to initialize CIE L*a*b*->RGB conversion state.", v185, v186, v187, v188, v189, v192);
          _TIFFfreeExt((uint64_t)*a1, (char *)a1[14]);
LABEL_103:
          v161 = 0;
          goto LABEL_170;
        default:
          goto LABEL_187;
      }
    }
    if (v50 != 1)
    {
      snprintf((char *)a4, 0x400uLL, "Missing needed %s tag");
      goto LABEL_188;
    }
    LOWORD(v198[0]) = 0;
    _cg_TIFFGetField(a2, 259, v63, v64, v65, v66, v67, v68, (uint64_t)v198);
    *CFRange v41 = LOWORD(v198[0]) - 2 >= 3 && LOWORD(v198[0]) != 32771;
LABEL_26:
    if ((unsigned __int16)v195 == 1 && *v27 != 1 && (unsigned __int16)*v19 <= 7u)
    {
      snprintf((char *)a4, 0x400uLL, "Sorry, can not handle contiguous data with %s=%hu, and %s=%hu and Bits/Sample=%hu");
LABEL_188:
      _cg_TIFFRGBAImageEnd((uint64_t)a1);
      return 0;
    }
    goto LABEL_49;
  }
  return result;
}

uint64_t _cg_TIFFRGBAImageGet(uint64_t *a1)
{
  uint64_t v1 = (uint64_t (*)(void))a1[8];
  if (!v1)
  {
    uint64_t v3 = *a1;
    signed int v4 = (const char *)TIFFFileName(*a1);
    unsigned int v10 = "No \"get\" routine setup";
LABEL_8:
    TIFFErrorExtR(v3, v4, v10, v5, v6, v7, v8, v9, v11);
    return 0;
  }
  if (!a1[9])
  {
    uint64_t v3 = *a1;
    signed int v4 = (const char *)TIFFFileName(*a1);
    unsigned int v10 = "No \"put\" routine setupl; probably can not handle image format";
    goto LABEL_8;
  }

  return v1();
}

uint64_t _cg_TIFFReadRGBAImageOriented(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, __int16 a5, uint64_t a6)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  bzero(v35, 0x400uLL);
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v28 = 0u;
  memset(v27, 0, sizeof(v27));
  if (_cg_TIFFRGBAImageOK((uint64_t)a1, v35, v9, v10, v11, v12, v13, v14)
    && _cg_TIFFRGBAImageBegin((void **)v27, a1, a6, (uint64_t)v35, v15, v16, v17, v18))
  {
    WORD1(v28) = a5;
    uint64_t v19 = _cg_TIFFRGBAImageGet((uint64_t *)v27);
    _cg_TIFFRGBAImageEnd((uint64_t)v27);
  }
  else
  {
    uint64_t v20 = (const char *)TIFFFileName((uint64_t)a1);
    TIFFErrorExtR((uint64_t)a1, v20, "%s", v21, v22, v23, v24, v25, (char)v35);
    return 0;
  }
  return v19;
}

uint64_t gtTileContig(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a4;
  unsigned int v9 = a3;
  uint64_t v85 = 0;
  uint64_t v11 = *(void **)a1;
  uint64_t v81 = *(void (**)(uint64_t, unint64_t, uint64_t, void, uint64_t, void, uint64_t, uint64_t, char *))(a1 + 72);
  uint64_t v82 = _cg_TIFFTileSize(*(void *)a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v82)
  {
    long long v28 = (const char *)TIFFFileName((uint64_t)v11);
    long long v34 = "No space for tile buffer";
LABEL_35:
    TIFFErrorExtR((uint64_t)v11, v28, "%s", v29, v30, v31, v32, v33, (char)v34);
    return 0;
  }
  uint64_t v86 = 0;
  _cg_TIFFGetField(v11, 322, v12, v13, v14, v15, v16, v17, (uint64_t)&v86 + 4);
  _cg_TIFFGetField(v11, 323, v18, v19, v20, v21, v22, v23, (uint64_t)&v86);
  unsigned int v24 = setorientation(a1);
  unsigned int v26 = v24;
  if (v24)
  {
    if ((int)(HIDWORD(v86) + v9) >= 0)
    {
      unsigned int v83 = v8 - 1;
      int v27 = -(HIDWORD(v86) + v9);
      goto LABEL_8;
    }
    goto LABEL_34;
  }
  if (HIDWORD(v86) > v9 + 0x7FFFFFFF)
  {
LABEL_34:
    long long v28 = (const char *)TIFFFileName((uint64_t)v11);
    long long v34 = "unsupported tile size (too wide)";
    goto LABEL_35;
  }
  unsigned int v83 = 0;
  int v27 = v9 - HIDWORD(v86);
LABEL_8:
  int v79 = v27;
  if (!HIDWORD(v86) || !v86)
  {
    uint64_t v58 = (const char *)TIFFFileName((uint64_t)v11);
    TIFFErrorExtR((uint64_t)v11, v58, "tile width or height is zero", v59, v60, v61, v62, v63, v73);
    return 0;
  }
  if (v8)
  {
    unsigned int v35 = 0;
    int v36 = *(_DWORD *)(a1 + 140) % HIDWORD(v86);
    int v75 = HIDWORD(v86) - v36;
    int v76 = v36;
    int v74 = v36 + v79;
    unsigned int v77 = v24;
    unsigned int v78 = v8;
    while (1)
    {
      unsigned int v37 = v86 + (*(_DWORD *)(a1 + 136) + v35) / v86 * v86 - (*(_DWORD *)(a1 + 136) + v35);
      if (v86 + (*(_DWORD *)(a1 + 136) + v35) / v86 * v86 - *(_DWORD *)(a1 + 136) > v8) {
        unsigned int v37 = v8 - v35;
      }
      unsigned int v80 = v37;
      if (v9) {
        break;
      }
LABEL_29:
      unsigned int v26 = v77;
      unsigned int v8 = v78;
      if (v77) {
        int v56 = -v80;
      }
      else {
        int v56 = v80;
      }
      v83 += v56;
      v35 += v80;
      if (v35 >= v78)
      {
        uint64_t v57 = 1;
        goto LABEL_40;
      }
    }
    uint64_t v38 = 0;
    uint64_t v39 = *(unsigned int *)(a1 + 140);
    unsigned int v40 = v74;
    LODWORD(v41) = v75;
    int v42 = v76;
    while (_TIFFReadTileAndAllocBuffer((uint64_t)v11, (unsigned __int8 **)&v85, v82, v39, *(_DWORD *)(a1 + 136) + v35, 0, 0, v25) != -1|| v85 && !*(_DWORD *)(a1 + 8))
    {
      uint64_t v50 = (*(_DWORD *)(a1 + 136) + v35) % v86;
      uint64_t v51 = _cg_TIFFTileRowSize((uint64_t)v11, v43, v44, v45, v46, v47, v48, v49) * v50
          + *(unsigned __int16 *)(a1 + 30) * (uint64_t)v42;
      unsigned int v52 = v38 + v41;
      unsigned int v53 = HIDWORD(v86) - (v9 - v38);
      if ((int)v38 + (int)v41 <= v9) {
        uint64_t v54 = v42;
      }
      else {
        uint64_t v54 = v53;
      }
      if (v52 <= v9) {
        uint64_t v41 = v41;
      }
      else {
        uint64_t v41 = v9 - v38;
      }
      if (v52 <= v9) {
        uint64_t v55 = v40;
      }
      else {
        uint64_t v55 = v53 + v79;
      }
      v81(a1, a2 + 4 * (v9 * (unint64_t)v83 + v38), v38, v83, v41, v80, v54, v55, &v85[v51]);
      int v42 = 0;
      uint64_t v38 = (v41 + v38);
      uint64_t v39 = (v41 + v39);
      LODWORD(v41) = HIDWORD(v86);
      unsigned int v40 = v79;
      if (v38 >= v9) {
        goto LABEL_29;
      }
    }
    uint64_t v57 = 0;
    unsigned int v26 = v77;
    unsigned int v8 = v78;
LABEL_40:
    uint64_t v65 = v85;
  }
  else
  {
    uint64_t v65 = 0;
    uint64_t v57 = 1;
  }
  _TIFFfreeExt(*(void *)a1, v65);
  if (v26 >= 2 && v8)
  {
    unsigned int v66 = 0;
    for (uint64_t i = 0; i != v8; ++i)
    {
      unint64_t v68 = a2 + 4 * i * v9;
      int v69 = (_DWORD *)(v68 + 4 * v9 - 4);
      if (v68 < (unint64_t)v69)
      {
        unint64_t v70 = a2 + 4 + 4 * v66;
        do
        {
          int v71 = *(_DWORD *)(v70 - 4);
          *(_DWORD *)(v70 - 4) = *v69;
          *v69-- = v71;
          BOOL v72 = v70 >= (unint64_t)v69;
          v70 += 4;
        }
        while (!v72);
      }
      v66 += v9;
    }
  }
  return v57;
}

uint64_t gtStripContig(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a1;
  uint64_t v18 = 0;
  HIWORD(v17[0]) = 0;
  v17[1] = 0;
  _cg_TIFFGetFieldDefaulted(v8, 530, a3, a4, a5, a6, a7, a8, (_DWORD *)((char *)v17 + 2));
  unsigned int v9 = (const char *)TIFFFileName(v8);
  TIFFErrorExtR(v8, v9, "Invalid vertical YCbCr subsampling", v10, v11, v12, v13, v14, v16);
  return 0;
}

uint64_t putRGBAAcontig8bittile(uint64_t result, _DWORD *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, int a8, _DWORD *a9)
{
  if (a6)
  {
    uint64_t v10 = *(unsigned __int16 *)(result + 30);
    do
    {
      unsigned int v11 = a5;
      if (a5 >= 8)
      {
        do
        {
          *a2 = *a9;
          uint64_t v12 = (_DWORD *)((char *)a9 + v10);
          a2[1] = *v12;
          uint64_t v13 = (_DWORD *)((char *)v12 + v10);
          a2[2] = *v13;
          uint64_t v14 = (_DWORD *)((char *)v13 + v10);
          a2[3] = *v14;
          uint64_t v15 = (_DWORD *)((char *)v14 + v10);
          a2[4] = *v15;
          char v16 = (_DWORD *)((char *)v15 + v10);
          a2[5] = *v16;
          uint64_t v17 = (_DWORD *)((char *)v16 + v10);
          a2[6] = *v17;
          uint64_t v18 = (_DWORD *)((char *)v17 + v10);
          uint64_t v19 = a2 + 8;
          a2[7] = *v18;
          a9 = (_DWORD *)((char *)v18 + v10);
          v11 -= 8;
          a2 += 8;
        }
        while (v11 > 7);
        a2 = v19;
      }
      switch(v11)
      {
        case 1u:
          goto LABEL_13;
        case 2u:
          goto LABEL_12;
        case 3u:
          goto LABEL_11;
        case 4u:
          goto LABEL_10;
        case 5u:
          goto LABEL_9;
        case 6u:
          goto LABEL_8;
        case 7u:
          *a2++ = *a9;
          a9 = (_DWORD *)((char *)a9 + v10);
LABEL_8:
          *a2++ = *a9;
          a9 = (_DWORD *)((char *)a9 + v10);
LABEL_9:
          *a2++ = *a9;
          a9 = (_DWORD *)((char *)a9 + v10);
LABEL_10:
          *a2++ = *a9;
          a9 = (_DWORD *)((char *)a9 + v10);
LABEL_11:
          *a2++ = *a9;
          a9 = (_DWORD *)((char *)a9 + v10);
LABEL_12:
          *a2++ = *a9;
          a9 = (_DWORD *)((char *)a9 + v10);
LABEL_13:
          *a2++ = *a9;
          a9 = (_DWORD *)((char *)a9 + v10);
          break;
        default:
          break;
      }
      a2 += a8;
      a9 = (_DWORD *)((char *)a9 + v10 * a7);
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t BuildMapUaToAa(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[15]) {
    BuildMapUaToAa_cold_1();
  }
  unsigned int v9 = _TIFFmallocExt((void *)*a1, 0x10000, a3, a4, a5, a6, a7, a8);
  a1[15] = (uint64_t)v9;
  if (v9)
  {
    unsigned int v15 = 0;
    uint32x4_t v16 = (uint32x4_t)vdupq_n_s32(0x80808081);
    v17.i64[0] = 0x400000004;
    v17.i64[1] = 0x400000004;
    do
    {
      uint64_t v18 = 0;
      int32x4_t v19 = vdupq_n_s32(v15);
      int32x4_t v20 = (int32x4_t)xmmword_18898C3A0;
      do
      {
        v21.i64[0] = 0x7F0000007FLL;
        v21.i64[1] = 0x7F0000007FLL;
        uint32x4_t v22 = (uint32x4_t)vmlaq_s32(v21, v19, v20);
        int16x8_t v23 = (int16x8_t)vuzp2q_s32((int32x4_t)vmull_u32(*(uint32x2_t *)v22.i8, *(uint32x2_t *)v16.i8), (int32x4_t)vmull_high_u32(v22, v16));
        *(uint16x4_t *)v23.i8 = vshr_n_u16((uint16x4_t)vmovn_s32((int32x4_t)v23), 7uLL);
        *(_DWORD *)((char *)v9 + v18) = vmovn_s16(v23).u32[0];
        v18 += 4;
        int32x4_t v20 = vaddq_s32(v20, v17);
      }
      while (v18 != 256);
      ++v15;
      v9 += 32;
    }
    while (v15 != 256);
    return 1;
  }
  else
  {
    TIFFErrorExtR(*a1, "BuildMapUaToAa", "Out of memory", v10, v11, v12, v13, v14, v25);
    return 0;
  }
}

uint64_t putRGBUAcontig8bittile(uint64_t result, int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(unsigned __int16 *)(result + 30);
    do
    {
      if (a5)
      {
        uint64_t v11 = *(void *)(result + 120);
        int v12 = a5;
        do
        {
          uint64_t v13 = v11 + ((unint64_t)a9[3] << 8);
          *a2++ = *(unsigned __int8 *)(v13 + *a9) | (a9[3] << 24) | (*(unsigned __int8 *)(v13 + a9[1]) << 8) | (*(unsigned __int8 *)(v13 + a9[2]) << 16);
          a9 += v10;
          --v12;
        }
        while (v12);
      }
      a2 += a8;
      a9 += v10 * a7;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t putRGBcontig8bittile(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, int a8, unsigned __int16 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(unsigned __int16 *)(result + 30);
    do
    {
      unsigned int v11 = a5;
      if (a5 >= 8)
      {
        do
        {
          *a2 = *a9 | (*((unsigned __int8 *)a9 + 2) << 16) | 0xFF000000;
          int v12 = (unsigned __int16 *)((char *)a9 + v10);
          a2[1] = *v12 | (*((unsigned __int8 *)v12 + 2) << 16) | 0xFF000000;
          uint64_t v13 = (unsigned __int16 *)((char *)v12 + v10);
          a2[2] = *v13 | (*((unsigned __int8 *)v13 + 2) << 16) | 0xFF000000;
          uint64_t v14 = (unsigned __int16 *)((char *)v13 + v10);
          a2[3] = *v14 | (*((unsigned __int8 *)v14 + 2) << 16) | 0xFF000000;
          unsigned int v15 = (unsigned __int16 *)((char *)v14 + v10);
          a2[4] = *v15 | (*((unsigned __int8 *)v15 + 2) << 16) | 0xFF000000;
          uint32x4_t v16 = (unsigned __int16 *)((char *)v15 + v10);
          a2[5] = *v16 | (*((unsigned __int8 *)v16 + 2) << 16) | 0xFF000000;
          int32x4_t v17 = (unsigned __int16 *)((char *)v16 + v10);
          a2[6] = *v17 | (*((unsigned __int8 *)v17 + 2) << 16) | 0xFF000000;
          uint64_t v18 = (unsigned __int16 *)((char *)v17 + v10);
          int32x4_t v19 = a2 + 8;
          a2[7] = *v18 | (*((unsigned __int8 *)v18 + 2) << 16) | 0xFF000000;
          a9 = (unsigned __int16 *)((char *)v18 + v10);
          v11 -= 8;
          a2 += 8;
        }
        while (v11 > 7);
        a2 = v19;
      }
      switch(v11)
      {
        case 1u:
          goto LABEL_13;
        case 2u:
          goto LABEL_12;
        case 3u:
          goto LABEL_11;
        case 4u:
          goto LABEL_10;
        case 5u:
          goto LABEL_9;
        case 6u:
          goto LABEL_8;
        case 7u:
          *a2++ = *a9 | (*((unsigned __int8 *)a9 + 2) << 16) | 0xFF000000;
          a9 = (unsigned __int16 *)((char *)a9 + v10);
LABEL_8:
          *a2++ = *a9 | (*((unsigned __int8 *)a9 + 2) << 16) | 0xFF000000;
          a9 = (unsigned __int16 *)((char *)a9 + v10);
LABEL_9:
          *a2++ = *a9 | (*((unsigned __int8 *)a9 + 2) << 16) | 0xFF000000;
          a9 = (unsigned __int16 *)((char *)a9 + v10);
LABEL_10:
          *a2++ = *a9 | (*((unsigned __int8 *)a9 + 2) << 16) | 0xFF000000;
          a9 = (unsigned __int16 *)((char *)a9 + v10);
LABEL_11:
          *a2++ = *a9 | (*((unsigned __int8 *)a9 + 2) << 16) | 0xFF000000;
          a9 = (unsigned __int16 *)((char *)a9 + v10);
LABEL_12:
          *a2++ = *a9 | (*((unsigned __int8 *)a9 + 2) << 16) | 0xFF000000;
          a9 = (unsigned __int16 *)((char *)a9 + v10);
LABEL_13:
          *a2++ = *a9 | (*((unsigned __int8 *)a9 + 2) << 16) | 0xFF000000;
          a9 = (unsigned __int16 *)((char *)a9 + v10);
          break;
        default:
          break;
      }
      a2 += a8;
      a9 = (unsigned __int16 *)((char *)a9 + v10 * a7);
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t BuildMapBitdepth16To8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[16]) {
    BuildMapBitdepth16To8_cold_1();
  }
  unsigned int v9 = _TIFFmallocExt((void *)*a1, 0x10000, a3, a4, a5, a6, a7, a8);
  a1[16] = (uint64_t)v9;
  if (v9)
  {
    uint64_t v15 = 0;
    int32x4_t v16 = (int32x4_t)xmmword_18898C3A0;
    v17.i64[0] = 0x8000000080;
    v17.i64[1] = 0x8000000080;
    uint32x4_t v18 = (uint32x4_t)vdupq_n_s32(0xFF00FF01);
    v19.i64[0] = 0x400000004;
    v19.i64[1] = 0x400000004;
    do
    {
      uint32x4_t v20 = (uint32x4_t)vaddq_s32(v16, v17);
      int16x8_t v21 = (int16x8_t)vuzp2q_s32((int32x4_t)vmull_u32(*(uint32x2_t *)v20.i8, *(uint32x2_t *)v18.i8), (int32x4_t)vmull_high_u32(v20, v18));
      *(uint16x4_t *)v21.i8 = vshr_n_u16((uint16x4_t)vmovn_s32((int32x4_t)v21), 8uLL);
      *(_DWORD *)((char *)v9 + v15) = vmovn_s16(v21).u32[0];
      v15 += 4;
      int32x4_t v16 = vaddq_s32(v16, v19);
    }
    while (v15 != 0x10000);
    return 1;
  }
  else
  {
    TIFFErrorExtR(*a1, "BuildMapBitdepth16To8", "Out of memory", v10, v11, v12, v13, v14, v23);
    return 0;
  }
}

uint64_t putRGBAAcontig16bittile(uint64_t result, int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int16 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(unsigned __int16 *)(result + 30);
    uint64_t v11 = (int)v10 * a7;
    uint64_t v12 = 2 * v10;
    do
    {
      if (a5)
      {
        uint64_t v13 = *(void *)(result + 128);
        int v14 = a5;
        do
        {
          *a2++ = *(unsigned __int8 *)(v13 + *a9) | (*(unsigned __int8 *)(v13 + a9[1]) << 8) | (*(unsigned __int8 *)(v13 + a9[2]) << 16) | (*(unsigned __int8 *)(v13 + a9[3]) << 24);
          a9 = (unsigned __int16 *)((char *)a9 + v12);
          --v14;
        }
        while (v14);
      }
      a2 += a8;
      a9 += v11;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t putRGBUAcontig16bittile(uint64_t result, int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int16 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(unsigned __int16 *)(result + 30);
    uint64_t v11 = (int)v10 * a7;
    uint64_t v12 = 2 * v10;
    do
    {
      if (a5)
      {
        uint64_t v14 = *(void *)(result + 120);
        uint64_t v13 = *(void *)(result + 128);
        int v15 = a5;
        do
        {
          uint64_t v16 = v14 + ((unint64_t)*(unsigned __int8 *)(v13 + a9[3]) << 8);
          *a2++ = *(unsigned __int8 *)(v16 + *(unsigned __int8 *)(v13 + *a9)) | (*(unsigned __int8 *)(v13 + a9[3]) << 24) | (*(unsigned __int8 *)(v16 + *(unsigned __int8 *)(v13 + a9[1])) << 8) | (*(unsigned __int8 *)(v16 + *(unsigned __int8 *)(v13 + a9[2])) << 16);
          a9 = (unsigned __int16 *)((char *)a9 + v12);
          --v15;
        }
        while (v15);
      }
      a2 += a8;
      a9 += v11;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t putRGBcontig16bittile(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int16 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(unsigned __int16 *)(result + 30);
    uint64_t v11 = (int)v10 * a7;
    uint64_t v12 = 2 * v10;
    do
    {
      if (a5)
      {
        uint64_t v13 = *(void *)(result + 128);
        int v14 = a5;
        do
        {
          *a2++ = *(unsigned __int8 *)(v13 + *a9) | (*(unsigned __int8 *)(v13 + a9[1]) << 8) | (*(unsigned __int8 *)(v13 + a9[2]) << 16) | 0xFF000000;
          a9 = (unsigned __int16 *)((char *)a9 + v12);
          --v14;
        }
        while (v14);
      }
      a2 += a8;
      a9 += v11;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t buildMap(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9 = *((unsigned __int16 *)a1 + 18);
  uint64_t result = 1;
  if (v9 <= 6)
  {
    if (((1 << v9) & 0x64) != 0)
    {
      if (*((_WORD *)a1 + 14) == 8) {
        return result;
      }
    }
    else if (((1 << v9) & 3) == 0)
    {
      if (v9 != 3) {
        return result;
      }
      __int16 v11 = *((_WORD *)a1 + 14);
      uint64_t v12 = 1 << v11;
      uint64_t v13 = (unsigned __int16 *)a1[5];
      int v14 = (unsigned __int16 *)a1[6];
      int v15 = (unsigned __int16 *)a1[7];
      do
      {
        if (v12-- < 1)
        {
          uint64_t v69 = (uint64_t)*a1;
          unint64_t v70 = (const char *)TIFFFileName((uint64_t)*a1);
          TIFFWarningExtR(v69, v70, "Assuming 8-bit colormap", v71, v72, v73, v74, v75, v104);
          goto LABEL_45;
        }
        unsigned int v17 = *v13++;
        if (v17 > 0xFF) {
          break;
        }
        if (*v14 > 0xFFu) {
          break;
        }
        ++v14;
        unsigned int v18 = *v15++;
      }
      while (v18 < 0x100);
      uint64_t v19 = -(-1 << v11);
      uint64_t v20 = (uint64_t)a1[7] - 2;
      uint64_t v21 = (uint64_t)a1[6] - 2;
      uint64_t v22 = (uint64_t)a1[5] - 2;
      do
      {
        *(_WORD *)(v22 + 2 * v19) = *(unsigned __int8 *)(v22 + 2 * v19 + 1);
        *(_WORD *)(v21 + 2 * v19) = *(unsigned __int8 *)(v21 + 2 * v19 + 1);
        *(_WORD *)(v20 + 2 * v19) = *(unsigned __int8 *)(v20 + 2 * v19 + 1);
        --v19;
      }
      while (v19 > 0);
LABEL_45:
      uint64_t v76 = *((unsigned __int16 *)a1 + 14);
      if (v76 > 8) {
        return 1;
      }
      unsigned int v77 = a1[5];
      unsigned int v78 = a1[6];
      int v79 = a1[7];
      unsigned int v80 = _TIFFmallocExt(*a1, ((unint64_t)(8u / *((_WORD *)a1 + 14)) << 10) + 2048, a3, a4, a5, a6, a7, a8);
      a1[12] = v80;
      if (v80)
      {
        unint64_t v81 = 0;
        uint64_t v82 = (unsigned int *)(v80 + 256);
        do
        {
          a1[12][v81] = v82;
          char v83 = 6;
          uint64_t v84 = 0x3FFFFFFLL;
          uint64_t v85 = 1;
          uint64_t v86 = v82;
          char v87 = 4;
          uint64_t v88 = 3;
          uint64_t v89 = v76;
          char v90 = v76;
          uint64_t v91 = 3;
          uint64_t v92 = 4;
          uint64_t v93 = 0xFFFFFFFLL;
          uint64_t v94 = 1;
          uint64_t v95 = v82;
          uint64_t v96 = 15;
          uint64_t v97 = 2;
          switch((int)v76)
          {
            case 1:
              unsigned int v98 = *((unsigned __int8 *)v77 + 2 * ((v81 >> 6) & 1)) | (*((_WORD *)v78
                                                                                         + ((v81 >> 6) & 1)) << 8) | (*((unsigned __int16 *)v79 + ((v81 >> 6) & 1)) << 16) | 0xFF000000;
              unsigned int v99 = *((unsigned __int8 *)v77 + 2 * ((v81 >> 5) & 1)) | (*((_WORD *)v78
                                                                                         + ((v81 >> 5) & 1)) << 8) | (*((unsigned __int16 *)v79 + ((v81 >> 5) & 1)) << 16) | 0xFF000000;
              unsigned int v100 = *((unsigned __int8 *)v77 + 2 * ((v81 >> 4) & 1)) | (*((_WORD *)v78
                                                                                          + ((v81 >> 4) & 1)) << 8) | (*((unsigned __int16 *)v79 + ((v81 >> 4) & 1)) << 16) | 0xFF000000;
              uint64_t v86 = v82 + 4;
              char v83 = 3;
              *uint64_t v82 = *((unsigned __int8 *)v77 + 2 * (v81 >> 7)) | (*((_WORD *)v78
                                                                                                  + (v81 >> 7)) << 8) | (*((unsigned __int16 *)v79 + (v81 >> 7)) << 16) | 0xFF000000;
              v82[1] = v98;
              uint64_t v84 = 1;
              uint64_t v85 = 5;
              char v87 = 2;
              uint64_t v88 = 1;
              v82[2] = v99;
              v82[3] = v100;
              uint64_t v89 = 6;
              char v90 = 1;
              uint64_t v91 = 7;
              uint64_t v92 = 8;
              goto LABEL_50;
            case 2:
LABEL_50:
              int v101 = *((unsigned __int8 *)v77 + 2 * ((v81 >> v87) & v88)) | (*((_WORD *)v78
                                                                                              + ((v81 >> v87) & v88)) << 8) | (*((unsigned __int16 *)v79 + ((v81 >> v87) & v88)) << 16);
              *uint64_t v86 = *((unsigned __int8 *)v77 + 2 * ((v81 >> v83) & v84)) | (*((_WORD *)v78
                                                                                              + ((v81 >> v83) & v84)) << 8) | (*((unsigned __int16 *)v79 + ((v81 >> v83) & v84)) << 16) | 0xFF000000;
              uint64_t v95 = &v82[v89];
              v82[v85] = v101 | 0xFF000000;
              uint64_t v93 = v88;
              uint64_t v94 = v91;
              uint64_t v96 = v88;
              uint64_t v97 = v92;
              goto LABEL_51;
            case 4:
LABEL_51:
              uint64_t v102 = &v82[v94];
              unsigned int *v95 = *((unsigned __int8 *)v77 + 2 * ((v81 >> v90) & v93)) | (*((_WORD *)v78
                                                                                              + ((v81 >> v90) & v93)) << 8) | (*((unsigned __int16 *)v79 + ((v81 >> v90) & v93)) << 16) | 0xFF000000;
              uint64_t v103 = v96 & v81;
              goto LABEL_53;
            case 8:
              uint64_t v103 = v81;
              uint64_t v97 = 1;
              uint64_t v102 = v82;
LABEL_53:
              v82 += v97;
              *uint64_t v102 = *((unsigned __int8 *)v77 + 2 * v103) | (*((_WORD *)v78 + v103) << 8) | (*((unsigned __int16 *)v79 + v103) << 16) | 0xFF000000;
              break;
            default:
              break;
          }
          ++v81;
        }
        while (v81 != 256);
        return 1;
      }
      uint64_t v35 = (uint64_t)*a1;
      int v36 = (const char *)TIFFFileName(v35);
      int v42 = "No space for Palette mapping table";
      goto LABEL_24;
    }
    int v23 = *((unsigned __int16 *)a1 + 14);
    if (v23 == 16) {
      signed int v24 = 255;
    }
    else {
      signed int v24 = ~(-1 << v23);
    }
    uint64_t v25 = (v24 + 1);
    unsigned int v26 = _TIFFmallocExt(*a1, (int)v25, a3, a4, a5, a6, a7, a8);
    a1[10] = v26;
    if (v26)
    {
      if (*((_WORD *)a1 + 18))
      {
        if ((v24 & 0x80000000) == 0)
        {
          int v33 = 0;
          uint64_t v34 = 0;
          do
          {
            *((unsigned char *)a1[10] + v34++) = v33 / v24;
            v33 += 255;
          }
          while (v25 != v34);
        }
      }
      else if ((v24 & 0x80000000) == 0)
      {
        uint64_t v43 = 0;
        int v44 = 255 * v24;
        do
        {
          *((unsigned char *)a1[10] + v43++) = v44 / v24;
          v44 -= 255;
        }
        while (v25 != v43);
      }
      uint64_t v45 = *((unsigned __int16 *)a1 + 14);
      if (v45 > 0x10 || *((unsigned __int16 *)a1 + 18) > 1u) {
        return 1;
      }
      uint64_t v46 = a1[10];
      if (v45 <= 8) {
        uint64_t v47 = ((unint64_t)(8u / *((_WORD *)a1 + 14)) << 10) + 2048;
      }
      else {
        uint64_t v47 = 3072;
      }
      uint64_t v48 = _TIFFmallocExt(*a1, v47, v27, v28, v29, v30, v31, v32);
      a1[11] = v48;
      if (v48)
      {
        unint64_t v49 = 0;
        uint64_t v50 = (unsigned int *)(v48 + 256);
        while (2)
        {
          a1[11][v49] = v50;
          char v51 = 6;
          uint64_t v52 = 0x3FFFFFFLL;
          uint64_t v53 = 1;
          uint64_t v54 = v50;
          char v55 = 4;
          uint64_t v56 = 3;
          uint64_t v57 = v45;
          char v58 = v45;
          uint64_t v59 = 3;
          uint64_t v60 = 4;
          uint64_t v61 = 0xFFFFFFFLL;
          uint64_t v62 = 1;
          uint64_t v63 = v50;
          uint64_t v64 = 15;
          uint64_t v65 = 2;
          switch((int)v45)
          {
            case 1:
              unsigned int *v50 = (65793 * *((unsigned __int8 *)v46 + (v49 >> 7))) | 0xFF000000;
              v50[1] = (65793 * *((unsigned __int8 *)v46 + ((v49 >> 6) & 1))) | 0xFF000000;
              v50[2] = (65793 * *((unsigned __int8 *)v46 + ((v49 >> 5) & 1))) | 0xFF000000;
              uint64_t v54 = v50 + 4;
              v50[3] = (65793 * *((unsigned __int8 *)v46 + ((v49 >> 4) & 1))) | 0xFF000000;
              char v51 = 3;
              uint64_t v52 = 1;
              uint64_t v53 = 5;
              char v55 = 2;
              uint64_t v56 = 1;
              uint64_t v57 = 6;
              char v58 = 1;
              uint64_t v59 = 7;
              uint64_t v60 = 8;
              goto LABEL_37;
            case 2:
LABEL_37:
              *uint64_t v54 = (65793 * *((unsigned __int8 *)v46 + ((v49 >> v51) & v52))) | 0xFF000000;
              uint64_t v63 = &v50[v57];
              v50[v53] = (65793 * *((unsigned __int8 *)v46 + ((v49 >> v55) & v56))) | 0xFF000000;
              uint64_t v61 = v56;
              uint64_t v62 = v59;
              uint64_t v64 = v56;
              uint64_t v65 = v60;
              goto LABEL_38;
            case 3:
            case 5:
            case 6:
            case 7:
              goto LABEL_42;
            case 4:
LABEL_38:
              unsigned int v66 = (65793 * *((unsigned __int8 *)v46 + ((v49 >> v58) & v61))) | 0xFF000000;
              uint64_t v67 = &v50[v62];
              *uint64_t v63 = v66;
              uint64_t v68 = v64 & v49;
              goto LABEL_41;
            case 8:
              goto LABEL_40;
            default:
              if (v45 == 16)
              {
LABEL_40:
                uint64_t v68 = v49;
                uint64_t v65 = 1;
                uint64_t v67 = v50;
LABEL_41:
                v50 += v65;
                unsigned int *v67 = (65793 * *((unsigned __int8 *)v46 + v68)) | 0xFF000000;
              }
LABEL_42:
              if (++v49 != 256) {
                continue;
              }
              _TIFFfreeExt((uint64_t)*a1, (char *)a1[10]);
              a1[10] = 0;
              break;
          }
          return 1;
        }
      }
      uint64_t v35 = (uint64_t)*a1;
      int v36 = (const char *)TIFFFileName(v35);
      int v42 = "No space for B&W mapping table";
    }
    else
    {
      uint64_t v35 = (uint64_t)*a1;
      int v36 = (const char *)TIFFFileName(v35);
      int v42 = "No space for photometric conversion table";
    }
LABEL_24:
    TIFFErrorExtR(v35, v36, v42, v37, v38, v39, v40, v41, v104);
    return 0;
  }
  return result;
}

uint64_t putRGBcontig8bitCMYKtile(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(unsigned __int16 *)(result + 30);
    do
    {
      unsigned int v11 = a5;
      if (a5 >= 8)
      {
        do
        {
          uint64_t v12 = a9;
          *a2 = ((32897 * (a9[1] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 15) & 0x1FF00 | ((32897 * (*a9 ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 23) | ((32897 * (a9[2] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 7) & 0xFF0000 | 0xFF000000;
          uint64_t v13 = &a9[v10 + 3];
          a2[1] = ((32897 * (*(v13 - 2) ^ 0xFF) * (*v13 ^ 0xFFu)) >> 15) & 0x1FF00 | ((32897
                                                                                     * (*(v13 - 3) ^ 0xFF)
                                                                                     * (*v13 ^ 0xFFu)) >> 23) | ((32897 * (*(v13 - 1) ^ 0xFF) * (*v13 ^ 0xFFu)) >> 7) & 0xFF0000 | 0xFF000000;
          int v14 = &v13[v10];
          a2[2] = ((32897 * (*(v14 - 2) ^ 0xFF) * (*v14 ^ 0xFFu)) >> 15) & 0x1FF00 | ((32897
                                                                                     * (*(v14 - 3) ^ 0xFF)
                                                                                     * (*v14 ^ 0xFFu)) >> 23) | ((32897 * (*(v14 - 1) ^ 0xFF) * (*v14 ^ 0xFFu)) >> 7) & 0xFF0000 | 0xFF000000;
          int v15 = &v14[v10];
          unsigned int v16 = ((32897 * (*(v15 - 2) ^ 0xFF) * (*v15 ^ 0xFFu)) >> 15) & 0x1FF00 | ((32897
                                                                                   * (*(v15 - 3) ^ 0xFF)
                                                                                   * (*v15 ^ 0xFFu)) >> 23) | ((32897 * (*(v15 - 1) ^ 0xFF) * (*v15 ^ 0xFFu)) >> 7) & 0xFF0000 | 0xFF000000;
          unsigned int v17 = &v15[v10];
          a2[3] = v16;
          a2[4] = ((32897 * (*(v17 - 2) ^ 0xFF) * (*v17 ^ 0xFFu)) >> 15) & 0x1FF00 | ((32897
                                                                                     * (*(v17 - 3) ^ 0xFF)
                                                                                     * (*v17 ^ 0xFFu)) >> 23) | ((32897 * (*(v17 - 1) ^ 0xFF) * (*v17 ^ 0xFFu)) >> 7) & 0xFF0000 | 0xFF000000;
          unsigned int v18 = &v17[v10];
          a2[5] = ((32897 * (*(v18 - 2) ^ 0xFF) * (*v18 ^ 0xFFu)) >> 15) & 0x1FF00 | ((32897
                                                                                     * (*(v18 - 3) ^ 0xFF)
                                                                                     * (*v18 ^ 0xFFu)) >> 23) | ((32897 * (*(v18 - 1) ^ 0xFF) * (*v18 ^ 0xFFu)) >> 7) & 0xFF0000 | 0xFF000000;
          uint64_t v19 = &v18[v10];
          a2[6] = ((32897 * (*(v19 - 2) ^ 0xFF) * (*v19 ^ 0xFFu)) >> 15) & 0x1FF00 | ((32897
                                                                                     * (*(v19 - 3) ^ 0xFF)
                                                                                     * (*v19 ^ 0xFFu)) >> 23) | ((32897 * (*(v19 - 1) ^ 0xFF) * (*v19 ^ 0xFFu)) >> 7) & 0xFF0000 | 0xFF000000;
          uint64_t v20 = &v19[v10];
          int v21 = *v20 ^ 0xFF;
          uint64_t result = ((32897 * (*(v20 - 2) ^ 0xFFu) * v21) >> 15) & 0x1FF00;
          unsigned int v22 = result | ((32897 * (*(v20 - 3) ^ 0xFFu) * v21) >> 23) | ((32897 * (*(v20 - 1) ^ 0xFFu) * v21) >> 7) & 0xFF0000 | 0xFF000000;
          int v23 = a2 + 8;
          a2[7] = v22;
          v11 -= 8;
          a9 = &v20[v10 - 3];
          a2 += 8;
        }
        while (v11 > 7);
        a9 = &v12[3 * v10 + 2 * v10 + 2 * v10 + v10];
        a2 = v23;
      }
      switch(v11)
      {
        case 1u:
          goto LABEL_13;
        case 2u:
          goto LABEL_12;
        case 3u:
          goto LABEL_11;
        case 4u:
          goto LABEL_10;
        case 5u:
          goto LABEL_9;
        case 6u:
          goto LABEL_8;
        case 7u:
          *a2++ = ((32897 * (a9[1] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 15) & 0x1FF00 | ((32897 * (*a9 ^ 0xFF)
                                                                                         * (a9[3] ^ 0xFFu)) >> 23) | ((32897 * (a9[2] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 7) & 0xFF0000 | 0xFF000000;
          a9 += v10;
LABEL_8:
          *a2++ = ((32897 * (a9[1] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 15) & 0x1FF00 | ((32897 * (*a9 ^ 0xFF)
                                                                                         * (a9[3] ^ 0xFFu)) >> 23) | ((32897 * (a9[2] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 7) & 0xFF0000 | 0xFF000000;
          a9 += v10;
LABEL_9:
          *a2++ = ((32897 * (a9[1] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 15) & 0x1FF00 | ((32897 * (*a9 ^ 0xFF)
                                                                                         * (a9[3] ^ 0xFFu)) >> 23) | ((32897 * (a9[2] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 7) & 0xFF0000 | 0xFF000000;
          a9 += v10;
LABEL_10:
          *a2++ = ((32897 * (a9[1] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 15) & 0x1FF00 | ((32897 * (*a9 ^ 0xFF)
                                                                                         * (a9[3] ^ 0xFFu)) >> 23) | ((32897 * (a9[2] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 7) & 0xFF0000 | 0xFF000000;
          a9 += v10;
LABEL_11:
          *a2++ = ((32897 * (a9[1] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 15) & 0x1FF00 | ((32897 * (*a9 ^ 0xFF)
                                                                                         * (a9[3] ^ 0xFFu)) >> 23) | ((32897 * (a9[2] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 7) & 0xFF0000 | 0xFF000000;
          a9 += v10;
LABEL_12:
          *a2++ = ((32897 * (a9[1] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 15) & 0x1FF00 | ((32897 * (*a9 ^ 0xFF)
                                                                                         * (a9[3] ^ 0xFFu)) >> 23) | ((32897 * (a9[2] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 7) & 0xFF0000 | 0xFF000000;
          a9 += v10;
LABEL_13:
          *a2++ = ((32897 * (a9[1] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 15) & 0x1FF00 | ((32897 * (*a9 ^ 0xFF)
                                                                                         * (a9[3] ^ 0xFFu)) >> 23) | ((32897 * (a9[2] ^ 0xFF) * (a9[3] ^ 0xFFu)) >> 7) & 0xFF0000 | 0xFF000000;
          a9 += v10;
          break;
        default:
          break;
      }
      a2 += a8;
      a9 += v10 * a7;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t putRGBcontig8bitCMYKMaptile(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(void *)(result + 80);
    uint64_t v11 = *(unsigned __int16 *)(result + 30);
    do
    {
      if (a5)
      {
        int v12 = a5;
        do
        {
          int v13 = a9[3] ^ 0xFF;
          uint64_t result = a9[2] ^ 0xFFu;
          *a2++ = *(unsigned __int8 *)(v10 + ((32897 * (*a9 ^ 0xFFu) * v13) >> 23)) | (*(unsigned __int8 *)(v10 + ((32897 * (a9[1] ^ 0xFFu) * v13) >> 23)) << 8) | (*(unsigned __int8 *)(v10 + ((32897 * result * v13) >> 23)) << 16) | 0xFF000000;
          a9 += v11;
          --v12;
        }
        while (v12);
      }
      a9 += v11 * a7;
      a2 += a8;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t put8bitcmaptile(uint64_t result, _DWORD *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(void *)(result + 96);
    uint64_t v11 = *(unsigned __int16 *)(result + 30);
    do
    {
      if (a5)
      {
        int v12 = a5;
        do
        {
          *a2++ = **(_DWORD **)(v10 + 8 * *a9);
          a9 += v11;
          --v12;
        }
        while (v12);
      }
      a2 += a8;
      a9 += a7;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t put4bitcmaptile(uint64_t result, _DWORD *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(void *)(result + 96);
    if (a7 >= 0) {
      int v11 = a7;
    }
    else {
      int v11 = a7 + 1;
    }
    uint64_t v12 = (uint64_t)v11 >> 1;
    do
    {
      unsigned int v13 = a5;
      if (a5 >= 2)
      {
        do
        {
          unsigned int v14 = *a9++;
          int v15 = *(_DWORD **)(v10 + 8 * v14);
          *a2 = *v15;
          int v16 = v15[1];
          unsigned int v17 = a2 + 2;
          a2[1] = v16;
          v13 -= 2;
          a2 += 2;
        }
        while (v13 > 1);
        a2 = v17;
      }
      if (v13)
      {
        unsigned int v18 = *a9++;
        *a2++ = **(_DWORD **)(v10 + 8 * v18);
      }
      a2 += a8;
      a9 += v12;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t put2bitcmaptile(uint64_t result, int *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(void *)(result + 96);
    if (a7 >= 0) {
      int v11 = a7;
    }
    else {
      int v11 = a7 + 3;
    }
    uint64_t v12 = (uint64_t)v11 >> 2;
    while (1)
    {
      unsigned int v13 = a5;
      if (a5 >= 4)
      {
        do
        {
          unsigned int v14 = *a9++;
          int v15 = *(int **)(v10 + 8 * v14);
          *a2 = *v15;
          a2[1] = v15[1];
          a2[2] = v15[2];
          int v16 = v15[3];
          unsigned int v17 = a2 + 4;
          a2[3] = v16;
          v13 -= 4;
          a2 += 4;
        }
        while (v13 > 3);
        a2 = v17;
      }
      if (!v13) {
        goto LABEL_16;
      }
      unsigned int v18 = *a9++;
      uint64_t v19 = *(int **)(v10 + 8 * v18);
      if (v13 == 1) {
        goto LABEL_15;
      }
      if (v13 == 2) {
        goto LABEL_14;
      }
      if (v13 == 3) {
        break;
      }
LABEL_16:
      a2 += a8;
      a9 += v12;
      if (!--a6) {
        return result;
      }
    }
    int v20 = *v19++;
    *a2++ = v20;
LABEL_14:
    int v21 = *v19++;
    *a2++ = v21;
LABEL_15:
    *a2++ = *v19;
    goto LABEL_16;
  }
  return result;
}

uint64_t put1bitcmaptile(uint64_t result, int *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(void *)(result + 96);
    if (a7 >= 0) {
      int v11 = a7;
    }
    else {
      int v11 = a7 + 7;
    }
    uint64_t v12 = (uint64_t)v11 >> 3;
    do
    {
      unsigned int v13 = a5;
      if (a5 >= 8)
      {
        do
        {
          unsigned int v14 = *a9++;
          int v15 = *(int **)(v10 + 8 * v14);
          *a2 = *v15;
          a2[1] = v15[1];
          a2[2] = v15[2];
          a2[3] = v15[3];
          a2[4] = v15[4];
          a2[5] = v15[5];
          a2[6] = v15[6];
          int v16 = v15[7];
          unsigned int v17 = a2 + 8;
          a2[7] = v16;
          v13 -= 8;
          a2 += 8;
        }
        while (v13 > 7);
        a2 = v17;
      }
      if (v13)
      {
        unsigned int v18 = *a9++;
        unsigned int v19 = v13 - 1;
        int v20 = *(int **)(v10 + 8 * v18);
        switch(v19)
        {
          case 0u:
            goto LABEL_17;
          case 1u:
            goto LABEL_16;
          case 2u:
            goto LABEL_15;
          case 3u:
            goto LABEL_14;
          case 4u:
            goto LABEL_13;
          case 5u:
            goto LABEL_12;
          case 6u:
            int v21 = *v20++;
            *a2++ = v21;
LABEL_12:
            int v22 = *v20++;
            *a2++ = v22;
LABEL_13:
            int v23 = *v20++;
            *a2++ = v23;
LABEL_14:
            int v24 = *v20++;
            *a2++ = v24;
LABEL_15:
            int v25 = *v20++;
            *a2++ = v25;
LABEL_16:
            int v26 = *v20++;
            *a2++ = v26;
LABEL_17:
            *a2++ = *v20;
            break;
          default:
            break;
        }
      }
      a2 += a8;
      a9 += v12;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t put16bitbwtile(uint64_t result, _DWORD *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int16 *a9)
{
  if (a6)
  {
    uint64_t v10 = 2 * *(unsigned __int16 *)(result + 30);
    uint64_t v11 = *(void *)(result + 88);
    do
    {
      if (a5)
      {
        int v12 = a5;
        do
        {
          *a2++ = **(_DWORD **)(v11 + (((unint64_t)*a9 >> 5) & 0x7F8));
          a9 = (unsigned __int16 *)((char *)a9 + v10);
          --v12;
        }
        while (v12);
      }
      a2 += a8;
      a9 = (unsigned __int16 *)((char *)a9 + a7);
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t putagreytile(uint64_t result, int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(void *)(result + 88);
    uint64_t v11 = *(unsigned __int16 *)(result + 30);
    do
    {
      if (a5)
      {
        int v12 = a5;
        do
        {
          *a2++ = ((a9[1] << 24) | 0xFFFFFF) & **(_DWORD **)(v10 + 8 * *a9);
          a9 += v11;
          --v12;
        }
        while (v12);
      }
      a2 += a8;
      a9 += a7;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t putgreytile(uint64_t result, _DWORD *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(void *)(result + 88);
    uint64_t v11 = *(unsigned __int16 *)(result + 30);
    do
    {
      if (a5)
      {
        int v12 = a5;
        do
        {
          *a2++ = **(_DWORD **)(v10 + 8 * *a9);
          a9 += v11;
          --v12;
        }
        while (v12);
      }
      a2 += a8;
      a9 += a7;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t put4bitbwtile(uint64_t result, _DWORD *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(void *)(result + 88);
    if (a7 >= 0) {
      int v11 = a7;
    }
    else {
      int v11 = a7 + 1;
    }
    uint64_t v12 = (uint64_t)v11 >> 1;
    do
    {
      unsigned int v13 = a5;
      if (a5 >= 2)
      {
        do
        {
          unsigned int v14 = *a9++;
          int v15 = *(_DWORD **)(v10 + 8 * v14);
          *a2 = *v15;
          int v16 = v15[1];
          unsigned int v17 = a2 + 2;
          a2[1] = v16;
          v13 -= 2;
          a2 += 2;
        }
        while (v13 > 1);
        a2 = v17;
      }
      if (v13)
      {
        unsigned int v18 = *a9++;
        *a2++ = **(_DWORD **)(v10 + 8 * v18);
      }
      a2 += a8;
      a9 += v12;
      --a6;
    }
    while (a6);
  }
  return result;
}

uint64_t put2bitbwtile(uint64_t result, int *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(void *)(result + 88);
    if (a7 >= 0) {
      int v11 = a7;
    }
    else {
      int v11 = a7 + 3;
    }
    uint64_t v12 = (uint64_t)v11 >> 2;
    while (1)
    {
      unsigned int v13 = a5;
      if (a5 >= 4)
      {
        do
        {
          unsigned int v14 = *a9++;
          int v15 = *(int **)(v10 + 8 * v14);
          *a2 = *v15;
          a2[1] = v15[1];
          a2[2] = v15[2];
          int v16 = v15[3];
          unsigned int v17 = a2 + 4;
          a2[3] = v16;
          v13 -= 4;
          a2 += 4;
        }
        while (v13 > 3);
        a2 = v17;
      }
      if (!v13) {
        goto LABEL_16;
      }
      unsigned int v18 = *a9++;
      unsigned int v19 = *(int **)(v10 + 8 * v18);
      if (v13 == 1) {
        goto LABEL_15;
      }
      if (v13 == 2) {
        goto LABEL_14;
      }
      if (v13 == 3) {
        break;
      }
LABEL_16:
      a2 += a8;
      a9 += v12;
      if (!--a6) {
        return result;
      }
    }
    int v20 = *v19++;
    *a2++ = v20;
LABEL_14:
    int v21 = *v19++;
    *a2++ = v21;
LABEL_15:
    *a2++ = *v19;
    goto LABEL_16;
  }
  return result;
}

uint64_t put1bitbwtile(uint64_t result, int *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  if (a6)
  {
    uint64_t v10 = *(void *)(result + 88);
    if (a7 >= 0) {
      int v11 = a7;
    }
    else {
      int v11 = a7 + 7;
    }
    uint64_t v12 = (uint64_t)v11 >> 3;
    do
    {
      unsigned int v13 = a5;
      if (a5 >= 8)
      {
        do
        {
          unsigned int v14 = *a9++;
          int v15 = *(int **)(v10 + 8 * v14);
          *a2 = *v15;
          a2[1] = v15[1];
          a2[2] = v15[2];
          a2[3] = v15[3];
          a2[4] = v15[4];
          a2[5] = v15[5];
          a2[6] = v15[6];
          int v16 = v15[7];
          unsigned int v17 = a2 + 8;
          a2[7] = v16;
          v13 -= 8;
          a2 += 8;
        }
        while (v13 > 7);
        a2 = v17;
      }
      if (v13)
      {
        unsigned int v18 = *a9++;
        unsigned int v19 = v13 - 1;
        int v20 = *(int **)(v10 + 8 * v18);
        switch(v19)
        {
          case 0u:
            goto LABEL_17;
          case 1u:
            goto LABEL_16;
          case 2u:
            goto LABEL_15;
          case 3u:
            goto LABEL_14;
          case 4u:
            goto LABEL_13;
          case 5u:
            goto LABEL_12;
          case 6u:
            int v21 = *v20++;
            *a2++ = v21;
LABEL_12:
            int v22 = *v20++;
            *a2++ = v22;
LABEL_13:
            int v23 = *v20++;
            *a2++ = v23;
LABEL_14:
            int v24 = *v20++;
            *a2++ = v24;
LABEL_15:
            int v25 = *v20++;
            *a2++ = v25;
LABEL_16:
            int v26 = *v20++;
            *a2++ = v26;
LABEL_17:
            *a2++ = *v20;
            break;
          default:
            break;
        }
      }
      a2 += a8;
      a9 += v12;
      --a6;
    }
    while (a6);
  }
  return result;
}

BOOL initYCbCrConversion(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1[13] || (unsigned int v9 = _TIFFmallocExt((void *)*a1, 6192, a3, a4, a5, a6, a7, a8), (a1[13] = (uint64_t)v9) != 0))
  {
    uint64_t v29 = 0;
    uint64_t v30 = 0;
    _cg_TIFFGetFieldDefaulted(*a1, 529, a3, a4, a5, a6, a7, a8, &v30);
    _cg_TIFFGetFieldDefaulted(*a1, 532, v10, v11, v12, v13, v14, v15, &v29);
    if (v30[1] == 0.0)
    {
      uint64_t v26 = *a1;
      uint64_t v27 = "Invalid values for YCbCrCoefficients tag";
    }
    else
    {
      if (*v29 > -2147500000.0 && *v29 < 2147500000.0)
      {
        float v17 = v29[1];
        if (v17 > -2147500000.0 && v17 < 2147500000.0)
        {
          float v19 = v29[2];
          if (v19 > -2147500000.0 && v19 < 2147500000.0)
          {
            float v21 = v29[3];
            if (v21 > -2147500000.0 && v21 < 2147500000.0)
            {
              float v23 = v29[4];
              if (v23 > -2147500000.0 && v23 < 2147500000.0)
              {
                float v24 = v29[5];
                if (v24 > -2147500000.0 && v24 < 2147500000.0) {
                  return (int)TIFFYCbCrToRGBInit((void *)a1[13], v30, v29) >= 0;
                }
              }
            }
          }
        }
      }
      uint64_t v26 = *a1;
      uint64_t v27 = "Invalid values for ReferenceBlackWhite tag";
    }
  }
  else
  {
    uint64_t v26 = *a1;
    uint64_t v27 = "No space for YCbCr->RGB conversion state";
  }
  TIFFErrorExtR(v26, "initYCbCrConversion", v27, a4, a5, a6, a7, a8, v28);
  return 0;
}

void *putcontig8bitYCbCr44tile(void *result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, int a7, int a8, unsigned __int8 *a9)
{
  unsigned int v9 = a6;
  uint64_t v10 = a2;
  uint64_t v11 = result;
  uint64_t v13 = a2 + 4 * a5 + 4 * a8;
  uint64_t v14 = v13 + 4 * a5 + 4 * a8;
  uint64_t v15 = v14 + 4 * a5 + 4 * a8;
  int v16 = 3 * a5 + 4 * a8;
  uint64_t v34 = 10 * (a7 / 4);
  if (((a6 | a5) & 3) != 0)
  {
    if (a6)
    {
      uint64_t v37 = v16;
      do
      {
        if (a5)
        {
          uint64_t v41 = v15;
          uint64_t v17 = 0;
          unsigned int v18 = a9 + 18;
          uint64_t v19 = a5;
          while (1)
          {
            a9 = v18;
            int v20 = *(v18 - 2);
            int v21 = *(v18 - 1);
            if (v19 != 1)
            {
              if (v19 != 2)
              {
                if (v19 != 3)
                {
                  if (v9 != 1)
                  {
                    if (v9 != 2)
                    {
                      if (v9 != 3)
                      {
                        uint64_t v44 = 0;
                        int v43 = 0;
                        TIFFYCbCrtoRGB((void *)v11[13], *(v18 - 3), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
                        *(_DWORD *)(v41 + v17 + 12) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
                      }
                      uint64_t v44 = 0;
                      int v43 = 0;
                      TIFFYCbCrtoRGB((void *)v11[13], *(a9 - 7), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
                      *(_DWORD *)(v14 + v17 + 12) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
                    }
                    uint64_t v44 = 0;
                    int v43 = 0;
                    TIFFYCbCrtoRGB((void *)v11[13], *(a9 - 11), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
                    *(_DWORD *)(v13 + v17 + 12) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
                  }
                  uint64_t v44 = 0;
                  int v43 = 0;
                  TIFFYCbCrtoRGB((void *)v11[13], *(a9 - 15), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
                  *(_DWORD *)(v10 + v17 + 12) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
                }
                if (v9 != 1)
                {
                  if (v9 != 2)
                  {
                    if (v9 != 3)
                    {
                      uint64_t v44 = 0;
                      int v43 = 0;
                      TIFFYCbCrtoRGB((void *)v11[13], *(a9 - 4), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
                      *(_DWORD *)(v41 + v17 + 8) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
                    }
                    uint64_t v44 = 0;
                    int v43 = 0;
                    TIFFYCbCrtoRGB((void *)v11[13], *(a9 - 8), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
                    *(_DWORD *)(v14 + v17 + 8) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
                  }
                  uint64_t v44 = 0;
                  int v43 = 0;
                  TIFFYCbCrtoRGB((void *)v11[13], *(a9 - 12), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
                  *(_DWORD *)(v13 + v17 + 8) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
                }
                uint64_t v44 = 0;
                int v43 = 0;
                TIFFYCbCrtoRGB((void *)v11[13], *(a9 - 16), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
                *(_DWORD *)(v10 + v17 + 8) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
              }
              if (v9 != 1)
              {
                if (v9 != 2)
                {
                  if (v9 != 3)
                  {
                    uint64_t v44 = 0;
                    int v43 = 0;
                    TIFFYCbCrtoRGB((void *)v11[13], *(a9 - 5), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
                    *(_DWORD *)(v41 + v17 + 4) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
                  }
                  uint64_t v44 = 0;
                  int v43 = 0;
                  TIFFYCbCrtoRGB((void *)v11[13], *(a9 - 9), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
                  *(_DWORD *)(v14 + v17 + 4) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
                }
                uint64_t v44 = 0;
                int v43 = 0;
                TIFFYCbCrtoRGB((void *)v11[13], *(a9 - 13), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
                *(_DWORD *)(v13 + v17 + 4) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
              }
              uint64_t v44 = 0;
              int v43 = 0;
              TIFFYCbCrtoRGB((void *)v11[13], *(a9 - 17), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
              *(_DWORD *)(v10 + v17 + 4) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
            }
            if (v9 != 1)
            {
              if (v9 != 2)
              {
                if (v9 != 3)
                {
                  uint64_t v44 = 0;
                  int v43 = 0;
                  TIFFYCbCrtoRGB((void *)v11[13], *(a9 - 6), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
                  *(_DWORD *)(v41 + v17) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
                }
                uint64_t v44 = 0;
                int v43 = 0;
                TIFFYCbCrtoRGB((void *)v11[13], *(a9 - 10), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
                *(_DWORD *)(v14 + v17) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
              }
              uint64_t v44 = 0;
              int v43 = 0;
              TIFFYCbCrtoRGB((void *)v11[13], *(a9 - 14), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
              *(_DWORD *)(v13 + v17) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
            }
            uint64_t v44 = 0;
            int v43 = 0;
            uint64_t result = TIFFYCbCrtoRGB((void *)v11[13], *(a9 - 18), v20, v21, (int *)&v44 + 1, (int *)&v44, &v43);
            *(_DWORD *)(v10 + v17) = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
            if (v19 <= 3) {
              break;
            }
            v17 += 16;
            unsigned int v18 = a9 + 18;
            v19 -= 4;
            if (!v19)
            {
              v10 += v17;
              uint64_t v15 = v41 + v17;
              v13 += v17;
              v14 += v17;
              goto LABEL_40;
            }
          }
          v10 += v17 + 4 * v19;
          v13 += v17 + 4 * v19;
          v14 += v17 + 4 * v19;
          uint64_t v15 = v41 + v17 + 4 * v19;
        }
LABEL_40:
        v10 += 4 * v37;
        v13 += 4 * v37;
        v14 += 4 * v37;
        a9 += (int)v34;
        v15 += 4 * v37;
        BOOL v22 = v9 >= 4;
        v9 -= 4;
      }
      while (v9 != 0 && v22);
    }
  }
  else if (a6 >= 4)
  {
    unsigned int v33 = a5 >> 2;
    uint64_t v32 = 4 * v16;
    do
    {
      uint64_t v38 = v13;
      uint64_t v40 = v14;
      unsigned int v35 = v9;
      uint64_t v23 = 0;
      unsigned int v24 = v33;
      uint64_t v36 = v10;
      uint64_t v42 = v15;
      do
      {
        int v25 = (unsigned int *)(v10 + v23);
        uint64_t v26 = (unsigned int *)(v15 + v23);
        uint64_t v27 = (unsigned int *)(v40 + v23);
        char v28 = (unsigned int *)(v38 + v23);
        int v29 = a9[16];
        int v30 = a9[17];
        uint64_t v44 = 0;
        int v43 = 0;
        TIFFYCbCrtoRGB((void *)v11[13], *a9, v29, v30, (int *)&v44 + 1, (int *)&v44, &v43);
        *int v25 = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        uint64_t v44 = 0;
        int v43 = 0;
        TIFFYCbCrtoRGB((void *)v11[13], a9[1], v29, v30, (int *)&v44 + 1, (int *)&v44, &v43);
        v25[1] = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        uint64_t v44 = 0;
        int v43 = 0;
        TIFFYCbCrtoRGB((void *)v11[13], a9[2], v29, v30, (int *)&v44 + 1, (int *)&v44, &v43);
        v25[2] = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        uint64_t v44 = 0;
        int v43 = 0;
        TIFFYCbCrtoRGB((void *)v11[13], a9[3], v29, v30, (int *)&v44 + 1, (int *)&v44, &v43);
        void v25[3] = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        uint64_t v44 = 0;
        int v43 = 0;
        TIFFYCbCrtoRGB((void *)v11[13], a9[4], v29, v30, (int *)&v44 + 1, (int *)&v44, &v43);
        *char v28 = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        uint64_t v44 = 0;
        int v43 = 0;
        TIFFYCbCrtoRGB((void *)v11[13], a9[5], v29, v30, (int *)&v44 + 1, (int *)&v44, &v43);
        v28[1] = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        uint64_t v44 = 0;
        int v43 = 0;
        TIFFYCbCrtoRGB((void *)v11[13], a9[6], v29, v30, (int *)&v44 + 1, (int *)&v44, &v43);
        CGColorSpaceRef v28[2] = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        uint64_t v44 = 0;
        int v43 = 0;
        TIFFYCbCrtoRGB((void *)v11[13], a9[7], v29, v30, (int *)&v44 + 1, (int *)&v44, &v43);
        void v28[3] = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        uint64_t v10 = v36;
        uint64_t v44 = 0;
        int v43 = 0;
        TIFFYCbCrtoRGB((void *)v11[13], a9[8], v29, v30, (int *)&v44 + 1, (int *)&v44, &v43);
        unsigned int *v27 = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        uint64_t v44 = 0;
        int v43 = 0;
        TIFFYCbCrtoRGB((void *)v11[13], a9[9], v29, v30, (int *)&v44 + 1, (int *)&v44, &v43);
        v27[1] = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        uint64_t v44 = 0;
        int v43 = 0;
        TIFFYCbCrtoRGB((void *)v11[13], a9[10], v29, v30, (int *)&v44 + 1, (int *)&v44, &v43);
        _OWORD v27[2] = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        uint64_t v44 = 0;
        int v43 = 0;
        TIFFYCbCrtoRGB((void *)v11[13], a9[11], v29, v30, (int *)&v44 + 1, (int *)&v44, &v43);
        void v27[3] = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        uint64_t v44 = 0;
        int v43 = 0;
        TIFFYCbCrtoRGB((void *)v11[13], a9[12], v29, v30, (int *)&v44 + 1, (int *)&v44, &v43);
        *uint64_t v26 = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        uint64_t v44 = 0;
        int v43 = 0;
        TIFFYCbCrtoRGB((void *)v11[13], a9[13], v29, v30, (int *)&v44 + 1, (int *)&v44, &v43);
        v26[1] = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        uint64_t v44 = 0;
        int v43 = 0;
        TIFFYCbCrtoRGB((void *)v11[13], a9[14], v29, v30, (int *)&v44 + 1, (int *)&v44, &v43);
        v26[2] = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        uint64_t v44 = 0;
        int v43 = 0;
        int v31 = v30;
        uint64_t v15 = v42;
        uint64_t result = TIFFYCbCrtoRGB((void *)v11[13], a9[15], v29, v31, (int *)&v44 + 1, (int *)&v44, &v43);
        v26[3] = HIDWORD(v44) | (v44 << 8) | (v43 << 16) | 0xFF000000;
        a9 += 18;
        v23 += 16;
        --v24;
      }
      while (v24);
      uint64_t v10 = v36 + v32 + v23;
      uint64_t v13 = v38 + v32 + v23;
      uint64_t v14 = v40 + v32 + v23;
      uint64_t v15 = v42 + v32 + v23;
      a9 += v34;
      unsigned int v9 = v35 - 4;
    }
    while (v35 - 4 > 3);
  }
  return result;
}

void *putcontig8bitYCbCr42tile(void *result, unsigned int *a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, int a7, int a8, unsigned __int8 *a9)
{
  unsigned int v9 = a6;
  unsigned int v10 = a5;
  uint64_t v11 = a2;
  uint64_t v12 = result;
  uint64_t v14 = &a2[a5 + a8];
  signed int v15 = a5 + 2 * a8;
  uint64_t v16 = 10 * (a7 / 4);
  if (a6 & 1 | a5 & 3)
  {
    if (a6)
    {
      uint64_t v17 = v15;
      uint64_t v28 = (int)v16;
      do
      {
        if (v10)
        {
          do
          {
            int v18 = a9[8];
            int v19 = a9[9];
            if (v10 != 1)
            {
              if (v10 != 2)
              {
                if (v10 != 3)
                {
                  if (v9 != 1)
                  {
                    uint64_t v32 = 0;
                    int v31 = 0;
                    TIFFYCbCrtoRGB((void *)v12[13], a9[7], v18, v19, (int *)&v32 + 1, (int *)&v32, &v31);
                    void v14[3] = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
                  }
                  uint64_t v32 = 0;
                  int v31 = 0;
                  TIFFYCbCrtoRGB((void *)v12[13], a9[3], v18, v19, (int *)&v32 + 1, (int *)&v32, &v31);
                  void v11[3] = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
                }
                if (v9 != 1)
                {
                  uint64_t v32 = 0;
                  int v31 = 0;
                  TIFFYCbCrtoRGB((void *)v12[13], a9[6], v18, v19, (int *)&v32 + 1, (int *)&v32, &v31);
                  v14[2] = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
                }
                uint64_t v32 = 0;
                int v31 = 0;
                TIFFYCbCrtoRGB((void *)v12[13], a9[2], v18, v19, (int *)&v32 + 1, (int *)&v32, &v31);
                _OWORD v11[2] = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
              }
              if (v9 != 1)
              {
                uint64_t v32 = 0;
                int v31 = 0;
                TIFFYCbCrtoRGB((void *)v12[13], a9[5], v18, v19, (int *)&v32 + 1, (int *)&v32, &v31);
                v14[1] = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
              }
              uint64_t v32 = 0;
              int v31 = 0;
              TIFFYCbCrtoRGB((void *)v12[13], a9[1], v18, v19, (int *)&v32 + 1, (int *)&v32, &v31);
              v11[1] = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
            }
            if (v9 != 1)
            {
              uint64_t v32 = 0;
              int v31 = 0;
              TIFFYCbCrtoRGB((void *)v12[13], a9[4], v18, v19, (int *)&v32 + 1, (int *)&v32, &v31);
              *uint64_t v14 = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
            }
            uint64_t v32 = 0;
            int v31 = 0;
            unsigned int v20 = *a9;
            a9 += 10;
            uint64_t result = TIFFYCbCrtoRGB((void *)v12[13], v20, v18, v19, (int *)&v32 + 1, (int *)&v32, &v31);
            unsigned int *v11 = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
            BOOL v21 = v10 > 4;
            if (v10 >= 4) {
              unsigned int v22 = 4;
            }
            else {
              unsigned int v22 = v10;
            }
            v14 += v22;
            v11 += v22;
            v10 -= 4;
          }
          while (v21);
        }
        v11 += v17;
        a9 += v28;
        v14 += v17;
        BOOL v23 = v9 >= 2;
        v9 -= 2;
        unsigned int v10 = a5;
      }
      while (v9 != 0 && v23);
    }
  }
  else if (a6 >= 2)
  {
    unsigned int v30 = a5 >> 2;
    uint64_t v24 = 4 * v15;
    do
    {
      unsigned int v25 = v30;
      do
      {
        int v26 = a9[8];
        int v27 = a9[9];
        uint64_t v32 = 0;
        int v31 = 0;
        TIFFYCbCrtoRGB((void *)v12[13], *a9, v26, v27, (int *)&v32 + 1, (int *)&v32, &v31);
        unsigned int *v11 = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
        uint64_t v32 = 0;
        int v31 = 0;
        TIFFYCbCrtoRGB((void *)v12[13], a9[1], v26, v27, (int *)&v32 + 1, (int *)&v32, &v31);
        v11[1] = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
        uint64_t v32 = 0;
        int v31 = 0;
        TIFFYCbCrtoRGB((void *)v12[13], a9[2], v26, v27, (int *)&v32 + 1, (int *)&v32, &v31);
        _OWORD v11[2] = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
        uint64_t v32 = 0;
        int v31 = 0;
        TIFFYCbCrtoRGB((void *)v12[13], a9[3], v26, v27, (int *)&v32 + 1, (int *)&v32, &v31);
        void v11[3] = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
        uint64_t v32 = 0;
        int v31 = 0;
        TIFFYCbCrtoRGB((void *)v12[13], a9[4], v26, v27, (int *)&v32 + 1, (int *)&v32, &v31);
        *uint64_t v14 = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
        uint64_t v32 = 0;
        int v31 = 0;
        TIFFYCbCrtoRGB((void *)v12[13], a9[5], v26, v27, (int *)&v32 + 1, (int *)&v32, &v31);
        v14[1] = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
        uint64_t v32 = 0;
        int v31 = 0;
        TIFFYCbCrtoRGB((void *)v12[13], a9[6], v26, v27, (int *)&v32 + 1, (int *)&v32, &v31);
        v14[2] = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
        uint64_t v32 = 0;
        int v31 = 0;
        uint64_t result = TIFFYCbCrtoRGB((void *)v12[13], a9[7], v26, v27, (int *)&v32 + 1, (int *)&v32, &v31);
        void v14[3] = HIDWORD(v32) | (v32 << 8) | (v31 << 16) | 0xFF000000;
        v11 += 4;
        v14 += 4;
        a9 += 10;
        --v25;
      }
      while (v25);
      uint64_t v11 = (unsigned int *)((char *)v11 + v24);
      uint64_t v14 = (unsigned int *)((char *)v14 + v24);
      a9 += v16;
      v9 -= 2;
    }
    while (v9 > 1);
  }
  return result;
}

void *putcontig8bitYCbCr41tile(void *result, unsigned int *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  unsigned int v10 = a5;
  uint64_t v12 = result;
  unsigned int v25 = a5 >> 2;
  uint64_t v14 = a5 & 3;
  uint64_t v15 = a8;
  uint64_t v16 = 6 * (a7 / 4);
  do
  {
    if (v10 >= 4)
    {
      uint64_t v17 = v16;
      uint64_t v18 = v15;
      unsigned int v19 = v25;
      do
      {
        int v20 = a9[4];
        int v21 = a9[5];
        uint64_t v27 = 0;
        int v26 = 0;
        TIFFYCbCrtoRGB((void *)v12[13], *a9, v20, v21, (int *)&v27 + 1, (int *)&v27, &v26);
        *a2 = HIDWORD(v27) | (v27 << 8) | (v26 << 16) | 0xFF000000;
        uint64_t v27 = 0;
        int v26 = 0;
        TIFFYCbCrtoRGB((void *)v12[13], a9[1], v20, v21, (int *)&v27 + 1, (int *)&v27, &v26);
        a2[1] = HIDWORD(v27) | (v27 << 8) | (v26 << 16) | 0xFF000000;
        uint64_t v27 = 0;
        int v26 = 0;
        TIFFYCbCrtoRGB((void *)v12[13], a9[2], v20, v21, (int *)&v27 + 1, (int *)&v27, &v26);
        a2[2] = HIDWORD(v27) | (v27 << 8) | (v26 << 16) | 0xFF000000;
        uint64_t v27 = 0;
        int v26 = 0;
        uint64_t result = TIFFYCbCrtoRGB((void *)v12[13], a9[3], v20, v21, (int *)&v27 + 1, (int *)&v27, &v26);
        a2[3] = HIDWORD(v27) | (v27 << 8) | (v26 << 16) | 0xFF000000;
        a2 += 4;
        a9 += 6;
        --v19;
      }
      while (v19);
      uint64_t v15 = v18;
      uint64_t v16 = v17;
      unsigned int v10 = a5;
    }
    if (v14)
    {
      int v22 = a9[4];
      int v23 = a9[5];
      if (v14 != 1)
      {
        if (v14 != 2)
        {
          if (v14 != 3)
          {
LABEL_13:
            a2 += v14;
            a9 += 6;
            goto LABEL_14;
          }
          uint64_t v27 = 0;
          int v26 = 0;
          TIFFYCbCrtoRGB((void *)v12[13], a9[2], v22, v23, (int *)&v27 + 1, (int *)&v27, &v26);
          a2[2] = HIDWORD(v27) | (v27 << 8) | (v26 << 16) | 0xFF000000;
        }
        uint64_t v27 = 0;
        int v26 = 0;
        TIFFYCbCrtoRGB((void *)v12[13], a9[1], v22, v23, (int *)&v27 + 1, (int *)&v27, &v26);
        a2[1] = HIDWORD(v27) | (v27 << 8) | (v26 << 16) | 0xFF000000;
      }
      uint64_t v27 = 0;
      int v26 = 0;
      uint64_t result = TIFFYCbCrtoRGB((void *)v12[13], *a9, v22, v23, (int *)&v27 + 1, (int *)&v27, &v26);
      *a2 = HIDWORD(v27) | (v27 << 8) | (v26 << 16) | 0xFF000000;
      goto LABEL_13;
    }
LABEL_14:
    a2 += v15;
    a9 += v16;
    --a6;
  }
  while (a6);
  return result;
}

void *putcontig8bitYCbCr22tile(void *result, unsigned int *a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, int a7, int a8, unsigned __int8 *a9)
{
  unsigned int v9 = a6;
  unsigned int v10 = a5;
  uint64_t v11 = a2;
  uint64_t v12 = result;
  if (a6 >= 2)
  {
    uint64_t v14 = &a2[a5 + a8];
    if (a7 >= 0) {
      int v15 = a7;
    }
    else {
      int v15 = a7 + 1;
    }
    uint64_t v16 = (int)(a5 + 2 * a8);
    uint64_t v26 = (int)(2 * ((v15 & 0xFFFFFFFE) + (v15 >> 1)));
    do
    {
      unsigned int v17 = v10;
      if (v10 >= 2)
      {
        do
        {
          int v18 = a9[4];
          int v19 = a9[5];
          uint64_t v28 = 0;
          int v27 = 0;
          TIFFYCbCrtoRGB((void *)v12[13], *a9, v18, v19, (int *)&v28 + 1, (int *)&v28, &v27);
          unsigned int *v11 = HIDWORD(v28) | (v28 << 8) | (v27 << 16) | 0xFF000000;
          uint64_t v28 = 0;
          int v27 = 0;
          TIFFYCbCrtoRGB((void *)v12[13], a9[1], v18, v19, (int *)&v28 + 1, (int *)&v28, &v27);
          v11[1] = HIDWORD(v28) | (v28 << 8) | (v27 << 16) | 0xFF000000;
          uint64_t v28 = 0;
          int v27 = 0;
          TIFFYCbCrtoRGB((void *)v12[13], a9[2], v18, v19, (int *)&v28 + 1, (int *)&v28, &v27);
          *uint64_t v14 = HIDWORD(v28) | (v28 << 8) | (v27 << 16) | 0xFF000000;
          uint64_t v28 = 0;
          int v27 = 0;
          uint64_t result = TIFFYCbCrtoRGB((void *)v12[13], a9[3], v18, v19, (int *)&v28 + 1, (int *)&v28, &v27);
          v14[1] = HIDWORD(v28) | (v28 << 8) | (v27 << 16) | 0xFF000000;
          v11 += 2;
          v14 += 2;
          a9 += 6;
          v17 -= 2;
        }
        while (v17 > 1);
      }
      if (v17)
      {
        int v20 = a9[4];
        int v21 = a9[5];
        uint64_t v28 = 0;
        int v27 = 0;
        TIFFYCbCrtoRGB((void *)v12[13], *a9, v20, v21, (int *)&v28 + 1, (int *)&v28, &v27);
        *v11++ = HIDWORD(v28) | (v28 << 8) | (v27 << 16) | 0xFF000000;
        uint64_t v28 = 0;
        int v27 = 0;
        uint64_t result = TIFFYCbCrtoRGB((void *)v12[13], a9[2], v20, v21, (int *)&v28 + 1, (int *)&v28, &v27);
        *v14++ = HIDWORD(v28) | (v28 << 8) | (v27 << 16) | 0xFF000000;
        a9 += 6;
      }
      v11 += v16;
      v14 += v16;
      a9 += v26;
      v9 -= 2;
    }
    while (v9 > 1);
  }
  if (v9)
  {
    if (v10 >= 2)
    {
      do
      {
        int v22 = a9[4];
        int v23 = a9[5];
        uint64_t v28 = 0;
        int v27 = 0;
        TIFFYCbCrtoRGB((void *)v12[13], *a9, v22, v23, (int *)&v28 + 1, (int *)&v28, &v27);
        unsigned int *v11 = HIDWORD(v28) | (v28 << 8) | (v27 << 16) | 0xFF000000;
        uint64_t v28 = 0;
        int v27 = 0;
        uint64_t result = TIFFYCbCrtoRGB((void *)v12[13], a9[1], v22, v23, (int *)&v28 + 1, (int *)&v28, &v27);
        v11[1] = HIDWORD(v28) | (v28 << 8) | (v27 << 16) | 0xFF000000;
        v11 += 2;
        a9 += 6;
        v10 -= 2;
      }
      while (v10 > 1);
    }
    if (v10)
    {
      int v24 = a9[4];
      int v25 = a9[5];
      uint64_t v28 = 0;
      int v27 = 0;
      uint64_t result = TIFFYCbCrtoRGB((void *)v12[13], *a9, v24, v25, (int *)&v28 + 1, (int *)&v28, &v27);
      unsigned int *v11 = HIDWORD(v28) | (v28 << 8) | (v27 << 16) | 0xFF000000;
    }
  }
  return result;
}

void *putcontig8bitYCbCr21tile(void *result, unsigned int *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  uint64_t v12 = result;
  if (a7 >= 0) {
    int v14 = a7;
  }
  else {
    int v14 = a7 + 1;
  }
  unsigned int v23 = a5 >> 1;
  uint64_t v15 = a8;
  uint64_t v16 = (int)((2 * v14) & 0xFFFFFFFC);
  do
  {
    if (a5 >= 2)
    {
      unsigned int v17 = v23;
      do
      {
        int v18 = a9[2];
        int v19 = a9[3];
        uint64_t v25 = 0;
        int v24 = 0;
        TIFFYCbCrtoRGB((void *)v12[13], *a9, v18, v19, (int *)&v25 + 1, (int *)&v25, &v24);
        *a2 = HIDWORD(v25) | (v25 << 8) | (v24 << 16) | 0xFF000000;
        uint64_t v25 = 0;
        int v24 = 0;
        uint64_t result = TIFFYCbCrtoRGB((void *)v12[13], a9[1], v18, v19, (int *)&v25 + 1, (int *)&v25, &v24);
        a2[1] = HIDWORD(v25) | (v25 << 8) | (v24 << 16) | 0xFF000000;
        a2 += 2;
        a9 += 4;
        --v17;
      }
      while (v17);
    }
    if (a5)
    {
      int v20 = a9[2];
      int v21 = a9[3];
      uint64_t v25 = 0;
      int v24 = 0;
      unsigned int v22 = *a9;
      a9 += 4;
      uint64_t result = TIFFYCbCrtoRGB((void *)v12[13], v22, v20, v21, (int *)&v25 + 1, (int *)&v25, &v24);
      *a2++ = HIDWORD(v25) | (v25 << 8) | (v24 << 16) | 0xFF000000;
    }
    a2 += v15;
    a9 += v16;
    --a6;
  }
  while (a6);
  return result;
}

void *putcontig8bitYCbCr12tile(void *result, unsigned int *a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6, int a7, int a8, uint64_t a9)
{
  unsigned int v9 = a6;
  int v10 = a5;
  uint64_t v11 = a2;
  uint64_t v12 = result;
  if (a6 >= 2)
  {
    uint64_t v25 = 4 * a7;
    uint64_t v23 = a5 + 2 * a8;
    uint64_t v24 = v23;
    uint64_t v14 = (uint64_t)&a2[a5 + a8];
    do
    {
      unint64_t v15 = 0;
      uint64_t v16 = v11;
      int v17 = v10;
      do
      {
        int v18 = *(unsigned __int8 *)(a9 + v15 + 2);
        int v19 = *(unsigned __int8 *)(a9 + v15 + 3);
        uint64_t v28 = 0;
        int v27 = 0;
        TIFFYCbCrtoRGB((void *)v12[13], *(unsigned __int8 *)(a9 + v15), v18, v19, (int *)&v28 + 1, (int *)&v28, &v27);
        v16[v15 / 4] = HIDWORD(v28) | (v28 << 8) | (v27 << 16) | 0xFF000000;
        uint64_t v28 = 0;
        int v27 = 0;
        uint64_t result = TIFFYCbCrtoRGB((void *)v12[13], *(unsigned __int8 *)(a9 + v15 + 1), v18, v19, (int *)&v28 + 1, (int *)&v28, &v27);
        *(_DWORD *)(v14 + v15) = HIDWORD(v28) | (v28 << 8) | (v27 << 16) | 0xFF000000;
        v15 += 4;
        --v17;
      }
      while (v17);
      uint64_t v11 = &v16[v24 + v15 / 4];
      v14 += v24 * 4 + v15;
      a9 += v25 + v15;
      v9 -= 2;
      int v10 = a5;
    }
    while (v9 > 1);
    uint64_t v11 = &v16[v23 + v15 / 4];
  }
  if (v9)
  {
    int v20 = (unsigned __int8 *)(a9 + 3);
    do
    {
      int v21 = *(v20 - 1);
      int v22 = *v20;
      uint64_t v28 = 0;
      int v27 = 0;
      uint64_t result = TIFFYCbCrtoRGB((void *)v12[13], *(v20 - 3), v21, v22, (int *)&v28 + 1, (int *)&v28, &v27);
      *v11++ = HIDWORD(v28) | (v28 << 8) | (v27 << 16) | 0xFF000000;
      v20 += 4;
      --v10;
    }
    while (v10);
  }
  return result;
}

void *putcontig8bitYCbCr11tile(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  uint64_t v14 = 3 * a7;
  uint64_t v15 = 4 * a8;
  do
  {
    int v16 = a5;
    do
    {
      int v17 = a9[1];
      int v18 = a9[2];
      uint64_t v22 = 0;
      int v21 = 0;
      unsigned int v19 = *a9;
      a9 += 3;
      uint64_t result = TIFFYCbCrtoRGB(*(void **)(a1 + 104), v19, v17, v18, (int *)&v22 + 1, (int *)&v22, &v21);
      *a2++ = HIDWORD(v22) | (v22 << 8) | (v21 << 16) | 0xFF000000;
      --v16;
    }
    while (v16);
    a2 = (unsigned int *)((char *)a2 + v15);
    a9 += v14;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t setorientation(uint64_t a1)
{
  switch(*(_WORD *)(a1 + 32))
  {
    case 1:
    case 5:
      unsigned int v1 = *(unsigned __int16 *)(a1 + 34) - 2;
      if (v1 >= 7) {
        goto LABEL_11;
      }
      uint64_t v2 = (unsigned int *)&unk_1889ADD38;
      goto LABEL_10;
    case 2:
    case 6:
      LOWORD(v1) = *(_WORD *)(a1 + 34) - 1;
      if ((unsigned __int16)v1 >= 8u) {
        goto LABEL_11;
      }
      uint64_t v2 = (unsigned int *)&unk_1889ADD54;
      goto LABEL_10;
    case 3:
    case 7:
      LOWORD(v1) = *(_WORD *)(a1 + 34) - 1;
      if ((unsigned __int16)v1 >= 8u) {
        goto LABEL_11;
      }
      uint64_t v2 = (unsigned int *)&unk_1889ADD74;
      goto LABEL_10;
    case 4:
    case 8:
      unsigned int v1 = *(unsigned __int16 *)(a1 + 34) - 1;
      if (v1 >= 7) {
        goto LABEL_11;
      }
      uint64_t v2 = (unsigned int *)&unk_1889ADD94;
LABEL_10:
      uint64_t result = v2[(__int16)v1];
      break;
    default:
LABEL_11:
      uint64_t result = 0;
      break;
  }
  return result;
}

float *putcontig8bitCIELab8(float *result, _DWORD *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int8 *a9)
{
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v17 = 0;
  if (a6)
  {
    int v9 = a6;
    uint64_t v12 = result;
    uint64_t v14 = a8;
    uint64_t v15 = 3 * a7;
    do
    {
      if (a5)
      {
        int v16 = a5;
        do
        {
          TIFFCIELabToXYZ(*((float **)v12 + 14), *a9, (char)a9[1], (char)a9[2], (float *)&v19 + 1, (float *)&v19, (float *)&v18 + 1);
          uint64_t result = TIFFXYZToRGB(*((float **)v12 + 14), (int *)&v18, (int *)&v17 + 1, (int *)&v17, *((float *)&v19 + 1), *(float *)&v19, *((float *)&v18 + 1));
          *a2++ = v18 | (HIDWORD(v17) << 8) | (v17 << 16) | 0xFF000000;
          a9 += 3;
          --v16;
        }
        while (v16);
      }
      a2 += v14;
      a9 += v15;
      --v9;
    }
    while (v9);
  }
  return result;
}

float *putcontig8bitCIELab16(float *result, _DWORD *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int16 *a9)
{
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v17 = 0;
  if (a6)
  {
    int v9 = a6;
    uint64_t v12 = result;
    uint64_t v14 = a8;
    uint64_t v15 = 3 * a7;
    do
    {
      if (a5)
      {
        int v16 = a5;
        do
        {
          TIFFCIELab16ToXYZ(*((float **)v12 + 14), *a9, (__int16)a9[1], (__int16)a9[2], (float *)&v19 + 1, (float *)&v19, (float *)&v18 + 1);
          uint64_t result = TIFFXYZToRGB(*((float **)v12 + 14), (int *)&v18, (int *)&v17 + 1, (int *)&v17, *((float *)&v19 + 1), *(float *)&v19, *((float *)&v18 + 1));
          *a2++ = v18 | (HIDWORD(v17) << 8) | (v17 << 16) | 0xFF000000;
          a9 += 3;
          --v16;
        }
        while (v16);
      }
      a2 += v14;
      a9 += v15;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t gtTileSeparate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a4;
  uint64_t v9 = a3;
  uint64_t v11 = *(void **)a1;
  uint64_t v109 = *(void (**)(uint64_t, unint64_t, uint64_t, void, uint64_t, void, uint64_t, uint64_t, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *, unsigned __int8 *))(a1 + 72);
  int v116 = 0;
  uint64_t v12 = *(unsigned int *)(a1 + 16);
  uint64_t v17 = _cg_TIFFTileSize((uint64_t)v11, a2, a3, a4, a5, a6, a7, a8);
  if (v12) {
    int64_t v18 = 4;
  }
  else {
    int64_t v18 = 3;
  }
  uint64_t v104 = _TIFFMultiplySSize((uint64_t)v11, v18, v17, "gtTileSeparate", v13, v14, v15, v16);
  if (!v104) {
    return 0;
  }
  v117[0] = 0;
  _cg_TIFFGetField(v11, 322, v19, v20, v21, v22, v23, v24, (uint64_t)v117 + 4);
  _cg_TIFFGetField(v11, 323, v25, v26, v27, v28, v29, v30, (uint64_t)v117);
  unsigned int v31 = setorientation(a1);
  if ((v31 & 1) == 0)
  {
    if (HIDWORD(v117[0]) <= (v9 + 0x7FFFFFFF))
    {
      unsigned int v108 = 0;
      unsigned int v34 = v9 - HIDWORD(v117[0]);
      goto LABEL_10;
    }
LABEL_59:
    uint64_t v74 = (const char *)TIFFFileName((uint64_t)v11);
    TIFFErrorExtR((uint64_t)v11, v74, "%s", v75, v76, v77, v78, v79, (char)"unsupported tile size (too wide)");
    return 0;
  }
  if (HIDWORD(v117[0]) + (int)v9 < 0) {
    goto LABEL_59;
  }
  unsigned int v108 = v8 - 1;
  unsigned int v34 = -(HIDWORD(v117[0]) + v9);
LABEL_10:
  unsigned int v106 = v34;
  unint64_t v35 = *(unsigned __int16 *)(a1 + 36);
  unint64_t v36 = 0x1000300010001uLL >> (16 * v35);
  if (v35 >= 4) {
    LOWORD(v36) = 3;
  }
  if (!HIDWORD(v117[0]) || !LODWORD(v117[0]))
  {
    unsigned int v80 = (const char *)TIFFFileName((uint64_t)v11);
    TIFFErrorExtR((uint64_t)v11, v80, "tile width or height is zero", v81, v82, v83, v84, v85, v94);
    return 0;
  }
  if (!v8)
  {
    uint64_t v73 = 1;
    goto LABEL_73;
  }
  unint64_t v114 = 0;
  uint64_t v110 = 0;
  uint64_t v111 = 0;
  unsigned int v115 = 0;
  unsigned int v37 = 0;
  unsigned int v105 = (v35 < 4) & (0xBu >> (v35 & 0xF));
  int v38 = *(_DWORD *)(a1 + 140) % HIDWORD(v117[0]);
  int v96 = HIDWORD(v117[0]) - v38;
  int v97 = v38;
  unsigned int v95 = v38 + v106;
  uint64_t v101 = 3 * v17;
  uint64_t v102 = v17;
  uint64_t v98 = v9;
  unsigned int v103 = (unsigned __int16)v36;
  unsigned int v99 = v8;
  unsigned int v100 = v31;
  do
  {
    unsigned int v39 = LODWORD(v117[0])
        + (*(_DWORD *)(a1 + 136) + v37) / LODWORD(v117[0]) * LODWORD(v117[0])
        - (*(_DWORD *)(a1 + 136)
         + v37);
    if (LODWORD(v117[0]) + (*(_DWORD *)(a1 + 136) + v37) / LODWORD(v117[0]) * LODWORD(v117[0]) - *(_DWORD *)(a1 + 136) > v8) {
      unsigned int v39 = v8 - v37;
    }
    unsigned int v107 = v39;
    if (v9)
    {
      uint64_t v40 = 0;
      uint64_t v41 = *(unsigned int *)(a1 + 140);
      unsigned int v42 = v95;
      LODWORD(v43) = v96;
      int v44 = v97;
      do
      {
        unsigned int v113 = v42;
        int v45 = *(_DWORD *)(a1 + 136);
        if (v116)
        {
          if (_cg_TIFFReadTile((uint64_t)v11, v115, v41, v45 + v37, 0, 0, v32, v33) == -1 && *(_DWORD *)(a1 + 8)) {
            goto LABEL_63;
          }
          if (v105) {
            goto LABEL_39;
          }
        }
        else
        {
          uint64_t v53 = _TIFFReadTileAndAllocBuffer((uint64_t)v11, (unsigned __int8 **)&v116, v104, v41, v45 + v37, 0, 0, v33);
          unsigned int v115 = (unsigned __int8 *)v116;
          if (v53 == -1 && (!v116 || *(_DWORD *)(a1 + 8))) {
            goto LABEL_63;
          }
          if (v105)
          {
            uint64_t v54 = (unsigned __int8 *)&v116[v101];
            if (!v12) {
              uint64_t v54 = 0;
            }
            unint64_t v114 = v54;
            uint64_t v110 = (unsigned __int8 *)v116;
            uint64_t v111 = (unsigned __int8 *)v116;
            goto LABEL_39;
          }
          uint64_t v111 = (unsigned __int8 *)&v116[v102];
          uint64_t v110 = (unsigned __int8 *)&v116[v102 + v102];
          char v55 = &v110[v102];
          if (!v12) {
            char v55 = 0;
          }
          unint64_t v114 = v55;
        }
        if (_cg_TIFFReadTile((uint64_t)v11, v111, v41, *(_DWORD *)(a1 + 136) + v37, 0, 1, v51, v52) == -1
          && *(_DWORD *)(a1 + 8)
          || _cg_TIFFReadTile((uint64_t)v11, v110, v41, *(_DWORD *)(a1 + 136) + v37, 0, 2, v56, v57) == -1
          && *(_DWORD *)(a1 + 8))
        {
LABEL_63:
          uint64_t v73 = 0;
          unsigned int v71 = v100;
          goto LABEL_64;
        }
LABEL_39:
        if (v12
          && _cg_TIFFReadTile((uint64_t)v11, v114, v41, *(_DWORD *)(a1 + 136) + v37, 0, v103, v51, v52) == -1
          && *(_DWORD *)(a1 + 8))
        {
          goto LABEL_63;
        }
        uint64_t v58 = v9;
        uint64_t v59 = v12;
        uint64_t v60 = (*(_DWORD *)(a1 + 136) + v37) % LODWORD(v117[0]);
        uint64_t v61 = _cg_TIFFTileRowSize((uint64_t)v11, v46, v47, v48, v49, v50, v51, v52) * v60;
        uint64_t v12 = v59;
        uint64_t v9 = v58;
        uint64_t v62 = v61 + *(unsigned __int16 *)(a1 + 30) * (uint64_t)v44;
        unsigned int v63 = HIDWORD(v117[0]) - (v58 - v40);
        BOOL v64 = (int)v40 + (int)v43 > v58;
        if ((int)v40 + (int)v43 <= v58) {
          uint64_t v65 = v44;
        }
        else {
          uint64_t v65 = v63;
        }
        if ((int)v40 + (int)v43 <= v58) {
          uint64_t v43 = v43;
        }
        else {
          uint64_t v43 = (v58 - v40);
        }
        if (v64) {
          uint64_t v66 = v63 + v106;
        }
        else {
          uint64_t v66 = v113;
        }
        uint64_t v67 = &v115[v62];
        uint64_t v68 = &v111[v62];
        uint64_t v69 = &v110[v62];
        unint64_t v70 = &v114[v62];
        if (!v12) {
          unint64_t v70 = 0;
        }
        v109(a1, a2 + 4 * (v98 * (unint64_t)v108 + v40), v40, v108, v43, v107, v65, v66, v67, v68, v69, v70);
        int v44 = 0;
        uint64_t v40 = (v43 + v40);
        uint64_t v41 = (v43 + v41);
        LODWORD(v43) = HIDWORD(v117[0]);
        unsigned int v42 = v106;
      }
      while (v40 < v58);
    }
    unsigned int v8 = v99;
    unsigned int v71 = v100;
    if (v100) {
      int v72 = -v107;
    }
    else {
      int v72 = v107;
    }
    v108 += v72;
    v37 += v107;
  }
  while (v37 < v99);
  uint64_t v73 = 1;
LABEL_64:
  if (v71 >= 2)
  {
    unsigned int v87 = 0;
    for (uint64_t i = 0; i != v99; ++i)
    {
      unint64_t v89 = a2 + 4 * (i * v9);
      char v90 = (_DWORD *)(v89 + 4 * v98 - 4);
      if (v89 < (unint64_t)v90)
      {
        unint64_t v91 = a2 + 4 + 4 * v87;
        do
        {
          int v92 = *(_DWORD *)(v91 - 4);
          *(_DWORD *)(v91 - 4) = *v90;
          *v90-- = v92;
          BOOL v93 = v91 >= (unint64_t)v90;
          v91 += 4;
        }
        while (!v93);
      }
      v87 += v9;
    }
  }
LABEL_73:
  _TIFFfreeExt(*(void *)a1, v116);
  return v73;
}

uint64_t gtStripSeparate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a4;
  uint64_t v10 = a2;
  uint64_t v12 = *(void *)a1;
  uint64_t v120 = *(void (**)(uint64_t, unint64_t, void, void, uint64_t, void, void, void))(a1 + 72);
  uint64_t v130 = 0;
  int v14 = *(_DWORD *)(a1 + 16);
  unsigned int v13 = *(_DWORD *)(a1 + 20);
  uint64_t v15 = _cg_TIFFStripSize(v12, a2, a3, a4, a5, a6, a7, a8);
  if (v14) {
    int64_t v20 = 4;
  }
  else {
    int64_t v20 = 3;
  }
  uint64_t v110 = v15;
  size_t v112 = _TIFFMultiplySSize(v12, v20, v15, "gtStripSeparate", v16, v17, v18, v19);
  if (!v112) {
    return 0;
  }
  unsigned int v119 = setorientation(a1);
  if (v119)
  {
    if ((a3 & 0x80000000) != 0)
    {
      int v92 = (const char *)TIFFFileName(v12);
      uint64_t v98 = "Width overflow";
      goto LABEL_53;
    }
    int v123 = v14;
    unsigned int v27 = v8 - 1;
    unsigned int v118 = -2 * a3;
  }
  else
  {
    int v123 = v14;
    unsigned int v27 = 0;
    unsigned int v118 = 0;
  }
  unint64_t v28 = *(unsigned __int16 *)(a1 + 36);
  if (v28 >= 4) {
    unsigned __int16 v29 = 3;
  }
  else {
    unsigned __int16 v29 = 0x1000300010001uLL >> (16 * v28);
  }
  unsigned int v129 = 0;
  _cg_TIFFGetFieldDefaulted(v12, 278, v21, v22, v23, v24, v25, v26, &v129);
  if (!v129)
  {
    int v92 = (const char *)TIFFFileName(v12);
    uint64_t v98 = "rowsperstrip is zero";
LABEL_53:
    TIFFErrorExtR(v12, v92, v98, v93, v94, v95, v96, v97, v108);
    return 0;
  }
  uint64_t v37 = _cg_TIFFScanlineSize(v12, v30, v31, v32, v33, v34, v35, v36);
  unsigned int v43 = v13 - a3;
  if (v13 < a3) {
    unsigned int v43 = 0;
  }
  unsigned int v117 = v43;
  if (!v8)
  {
    uint64_t v91 = 1;
    goto LABEL_65;
  }
  unsigned int v44 = v8;
  unsigned int v125 = v27;
  unsigned int v45 = 0;
  uint64_t v126 = 0;
  uint64_t v121 = 0;
  uint64_t v122 = 0;
  uint64_t v128 = 0;
  unsigned int v114 = (v28 < 4) & (0xBu >> (v28 & 0xF));
  unsigned int v109 = v29;
  uint64_t v46 = a3;
  unint64_t v111 = 0x7FFFFFFFFFFFFFFFuLL / v37;
  uint64_t v115 = v12;
  uint64_t v116 = a3;
  int v47 = v123;
  uint64_t v127 = v37;
  unsigned int v113 = v8;
  while (1)
  {
    unsigned int v48 = *(_DWORD *)(a1 + 136) + v45;
    if (v129 - v48 % v129 + v45 <= v44) {
      unsigned int v49 = v129 - v48 % v129;
    }
    else {
      unsigned int v49 = v44 - v45;
    }
    uint64_t v50 = v49 + v48 % v129;
    if (v37 >= 1 && v111 < v50)
    {
      int v92 = (const char *)TIFFFileName(v12);
      uint64_t v98 = "Integer overflow in gtStripSeparate";
      goto LABEL_53;
    }
    unsigned int v124 = v49;
    unsigned int v51 = v44;
    uint64_t v52 = v10;
    uint64_t v53 = v46;
    uint64_t v54 = v130;
    uint64_t v55 = _cg_TIFFComputeStrip(v12, v48, 0, v38, v39, v40, v41, v42);
    uint64_t v60 = v127 * v50;
    if (v54) {
      break;
    }
    uint64_t v67 = _TIFFReadEncodedStripAndAllocBuffer(v12, v55, &v130, v112, v60, v57, v58, v59);
    uint64_t v128 = v130;
    uint64_t v46 = v53;
    uint64_t v10 = v52;
    unsigned int v44 = v51;
    uint64_t v66 = v116;
    if (v67 == -1 && (!v130 || *(_DWORD *)(a1 + 8)))
    {
      uint64_t v91 = 0;
      goto LABEL_58;
    }
    if (v114)
    {
      uint64_t v68 = &v130[3 * v110];
      if (!v47) {
        uint64_t v68 = 0;
      }
      uint64_t v126 = v68;
      uint64_t v121 = v130;
      uint64_t v122 = v130;
      uint64_t v12 = v115;
      goto LABEL_41;
    }
    uint64_t v122 = &v130[v110];
    uint64_t v121 = &v130[v110 + v110];
    uint64_t v69 = &v121[v110];
    if (!v47) {
      uint64_t v69 = 0;
    }
    uint64_t v126 = v69;
    uint64_t v12 = v115;
LABEL_37:
    uint64_t v70 = _cg_TIFFComputeStrip(v12, v48, 1u, v61, v62, v63, v64, v65);
    if (_cg_TIFFReadEncodedStrip(v12, v70, v122, v60, v71, v72, v73, v74) == -1 && *(_DWORD *)(a1 + 8)
      || (uint64_t v80 = _cg_TIFFComputeStrip(v12, v48, 2u, v75, v76, v77, v78, v79),
          _cg_TIFFReadEncodedStrip(v12, v80, v121, v60, v81, v82, v83, v84) == -1)
      && *(_DWORD *)(a1 + 8))
    {
LABEL_55:
      uint64_t v91 = 0;
      unsigned int v44 = v113;
      goto LABEL_58;
    }
LABEL_41:
    if (v47)
    {
      uint64_t v85 = _cg_TIFFComputeStrip(v12, v48, v109, v61, v62, v63, v64, v65);
      if (_cg_TIFFReadEncodedStrip(v12, v85, v126, v60, v86, v87, v88, v89) == -1)
      {
        if (*(_DWORD *)(a1 + 8)) {
          goto LABEL_55;
        }
      }
    }
    char v108 = (_BYTE)v128 + v127 * ((*(_DWORD *)(a1 + 136) + v45) % v129) + *(_WORD *)(a1 + 30) * *(unsigned char *)(a1 + 140);
    v120(a1, v10 + 4 * v66 * (unint64_t)v125, 0, v125, v46, v124, v117, v118);
    uint64_t v37 = v127;
    if (v119) {
      int v90 = -v124;
    }
    else {
      int v90 = v124;
    }
    v125 += v90;
    v45 += v124;
    unsigned int v44 = v113;
    if (v45 >= v113)
    {
      uint64_t v91 = 1;
      goto LABEL_58;
    }
  }
  if (_cg_TIFFReadEncodedStrip(v12, v55, v128, v60, v56, v57, v58, v59) != -1 || !*(_DWORD *)(a1 + 8))
  {
    uint64_t v46 = v53;
    uint64_t v10 = v52;
    uint64_t v12 = v115;
    uint64_t v66 = v116;
    if (v114) {
      goto LABEL_41;
    }
    goto LABEL_37;
  }
  uint64_t v91 = 0;
  LODWORD(v46) = v53;
  uint64_t v10 = v52;
  unsigned int v44 = v51;
  uint64_t v66 = v116;
LABEL_58:
  if (v119 >= 2)
  {
    unsigned int v99 = 0;
    uint64_t v100 = 0;
    uint64_t v101 = v44;
    do
    {
      unint64_t v102 = v10 + 4 * (v100 * v46);
      unsigned int v103 = (_DWORD *)(v102 + 4 * v66 - 4);
      if (v102 < (unint64_t)v103)
      {
        unint64_t v104 = v10 + 4 + 4 * v99;
        do
        {
          int v105 = *(_DWORD *)(v104 - 4);
          *(_DWORD *)(v104 - 4) = *v103;
          *v103-- = v105;
          BOOL v106 = v104 >= (unint64_t)v103;
          v104 += 4;
        }
        while (!v106);
      }
      ++v100;
      v99 += v46;
    }
    while (v100 != v101);
  }
LABEL_65:
  _TIFFfreeExt(*(void *)a1, v130);
  return v91;
}

void putRGBAAseparate8bittile(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, int a8, unsigned __int8 *a9, unsigned __int8 *a10, unsigned __int8 *a11, unsigned __int8 *a12)
{
  for (; a6; --a6)
  {
    unsigned int v16 = a5;
    if (a5 >= 8)
    {
      do
      {
        *a2 = *a9 | (*a10 << 8) | (*a11 << 16) | (*a12 << 24);
        a2[1] = a9[1] | (a10[1] << 8) | (a11[1] << 16) | (a12[1] << 24);
        a2[2] = a9[2] | (a10[2] << 8) | (a11[2] << 16) | (a12[2] << 24);
        a2[3] = a9[3] | (a10[3] << 8) | (a11[3] << 16) | (a12[3] << 24);
        a2[4] = a9[4] | (a10[4] << 8) | (a11[4] << 16) | (a12[4] << 24);
        a2[5] = a9[5] | (a10[5] << 8) | (a11[5] << 16) | (a12[5] << 24);
        a2[6] = a9[6] | (a10[6] << 8) | (a11[6] << 16) | (a12[6] << 24);
        uint64_t v17 = a9 + 8;
        int v18 = a9[7] | (a10[7] << 8) | (a11[7] << 16) | (a12[7] << 24);
        uint64_t v19 = a10 + 8;
        int64_t v20 = a11 + 8;
        uint64_t v21 = a12 + 8;
        uint64_t v22 = a2 + 8;
        v16 -= 8;
        a12 += 8;
        a11 += 8;
        a2[7] = v18;
        a10 += 8;
        a9 = v17;
        a2 += 8;
      }
      while (v16 > 7);
      a2 = v22;
      a9 = v17;
      a10 = v19;
      a11 = v20;
      a12 = v21;
    }
    switch(v16)
    {
      case 1u:
        goto LABEL_12;
      case 2u:
        goto LABEL_11;
      case 3u:
        goto LABEL_10;
      case 4u:
        goto LABEL_9;
      case 5u:
        goto LABEL_8;
      case 6u:
        goto LABEL_7;
      case 7u:
        int v24 = *a9++;
        int v23 = v24;
        int v25 = *a10++;
        int v26 = v23 | (v25 << 8);
        int v27 = *a11++;
        int v28 = v26 | (v27 << 16);
        int v29 = *a12++;
        *a2++ = v28 | (v29 << 24);
LABEL_7:
        int v31 = *a9++;
        int v30 = v31;
        int v32 = *a10++;
        int v33 = v30 | (v32 << 8);
        int v34 = *a11++;
        int v35 = v33 | (v34 << 16);
        int v36 = *a12++;
        *a2++ = v35 | (v36 << 24);
LABEL_8:
        int v38 = *a9++;
        int v37 = v38;
        int v39 = *a10++;
        int v40 = v37 | (v39 << 8);
        int v41 = *a11++;
        int v42 = v40 | (v41 << 16);
        int v43 = *a12++;
        *a2++ = v42 | (v43 << 24);
LABEL_9:
        int v45 = *a9++;
        int v44 = v45;
        int v46 = *a10++;
        int v47 = v44 | (v46 << 8);
        int v48 = *a11++;
        int v49 = v47 | (v48 << 16);
        int v50 = *a12++;
        *a2++ = v49 | (v50 << 24);
LABEL_10:
        int v52 = *a9++;
        int v51 = v52;
        int v53 = *a10++;
        int v54 = v51 | (v53 << 8);
        int v55 = *a11++;
        int v56 = v54 | (v55 << 16);
        int v57 = *a12++;
        *a2++ = v56 | (v57 << 24);
LABEL_11:
        int v59 = *a9++;
        int v58 = v59;
        int v60 = *a10++;
        int v61 = v58 | (v60 << 8);
        int v62 = *a11++;
        int v63 = v61 | (v62 << 16);
        int v64 = *a12++;
        *a2++ = v63 | (v64 << 24);
LABEL_12:
        int v66 = *a9++;
        int v65 = v66;
        int v67 = *a10++;
        int v68 = v65 | (v67 << 8);
        int v69 = *a11++;
        int v70 = v68 | (v69 << 16);
        int v71 = *a12++;
        *a2++ = v70 | (v71 << 24);
        break;
      default:
        break;
    }
    a9 += a7;
    a10 += a7;
    a11 += a7;
    a12 += a7;
    a2 += a8;
  }
}

uint64_t putRGBUAseparate8bittile(uint64_t result, int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int8 *a9, unsigned __int8 *a10, unsigned __int8 *a11, unsigned __int8 *a12)
{
  for (; a6; --a6)
  {
    if (a5)
    {
      uint64_t v16 = *(void *)(result + 120);
      int v17 = a5;
      do
      {
        int v19 = *a12++;
        int v18 = v19;
        uint64_t v20 = v16 + ((unint64_t)v19 << 8);
        unsigned int v21 = *a9++;
        int v22 = *(unsigned __int8 *)(v20 + v21);
        unsigned int v23 = *a10++;
        int v24 = *(unsigned __int8 *)(v20 + v23);
        unsigned int v25 = *a11++;
        *a2++ = v22 | (v18 << 24) | (v24 << 8) | (*(unsigned __int8 *)(v20 + v25) << 16);
        --v17;
      }
      while (v17);
    }
    a9 += a7;
    a10 += a7;
    a11 += a7;
    a12 += a7;
    a2 += a8;
  }
  return result;
}

void putRGBseparate8bittile(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, int a8, unsigned __int8 *a9, unsigned __int8 *a10, unsigned __int8 *a11)
{
  for (; a6; --a6)
  {
    unsigned int v14 = a5;
    if (a5 >= 8)
    {
      do
      {
        *a2 = *a9 | (*a10 << 8) | (*a11 << 16) | 0xFF000000;
        a2[1] = a9[1] | (a10[1] << 8) | (a11[1] << 16) | 0xFF000000;
        a2[2] = a9[2] | (a10[2] << 8) | (a11[2] << 16) | 0xFF000000;
        a2[3] = a9[3] | (a10[3] << 8) | (a11[3] << 16) | 0xFF000000;
        a2[4] = a9[4] | (a10[4] << 8) | (a11[4] << 16) | 0xFF000000;
        a2[5] = a9[5] | (a10[5] << 8) | (a11[5] << 16) | 0xFF000000;
        a2[6] = a9[6] | (a10[6] << 8) | (a11[6] << 16) | 0xFF000000;
        uint64_t v15 = a9 + 8;
        uint64_t v16 = a10 + 8;
        int v17 = a11 + 8;
        int v18 = a2 + 8;
        v14 -= 8;
        a2[7] = a9[7] | (a10[7] << 8) | (a11[7] << 16) | 0xFF000000;
        a2 += 8;
        a11 += 8;
        a10 += 8;
        a9 += 8;
      }
      while (v14 > 7);
      a9 = v15;
      a10 = v16;
      a11 = v17;
      a2 = v18;
    }
    switch(v14)
    {
      case 1u:
        goto LABEL_12;
      case 2u:
        goto LABEL_11;
      case 3u:
        goto LABEL_10;
      case 4u:
        goto LABEL_9;
      case 5u:
        goto LABEL_8;
      case 6u:
        goto LABEL_7;
      case 7u:
        int v20 = *a9++;
        int v19 = v20;
        int v22 = *a10++;
        int v21 = v22;
        int v23 = *a11++;
        *a2++ = v19 | (v21 << 8) | (v23 << 16) | 0xFF000000;
LABEL_7:
        int v25 = *a9++;
        int v24 = v25;
        int v27 = *a10++;
        int v26 = v27;
        int v28 = *a11++;
        *a2++ = v24 | (v26 << 8) | (v28 << 16) | 0xFF000000;
LABEL_8:
        int v30 = *a9++;
        int v29 = v30;
        int v32 = *a10++;
        int v31 = v32;
        int v33 = *a11++;
        *a2++ = v29 | (v31 << 8) | (v33 << 16) | 0xFF000000;
LABEL_9:
        int v35 = *a9++;
        int v34 = v35;
        int v37 = *a10++;
        int v36 = v37;
        int v38 = *a11++;
        *a2++ = v34 | (v36 << 8) | (v38 << 16) | 0xFF000000;
LABEL_10:
        int v40 = *a9++;
        int v39 = v40;
        int v42 = *a10++;
        int v41 = v42;
        int v43 = *a11++;
        *a2++ = v39 | (v41 << 8) | (v43 << 16) | 0xFF000000;
LABEL_11:
        int v45 = *a9++;
        int v44 = v45;
        int v47 = *a10++;
        int v46 = v47;
        int v48 = *a11++;
        *a2++ = v44 | (v46 << 8) | (v48 << 16) | 0xFF000000;
LABEL_12:
        int v50 = *a9++;
        int v49 = v50;
        int v52 = *a10++;
        int v51 = v52;
        int v53 = *a11++;
        *a2++ = v49 | (v51 << 8) | (v53 << 16) | 0xFF000000;
        break;
      default:
        break;
    }
    a9 += a7;
    a10 += a7;
    a11 += a7;
    a2 += a8;
  }
}

uint64_t putRGBAAseparate16bittile(uint64_t result, int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  for (; a6; --a6)
  {
    if (a5)
    {
      uint64_t v16 = 0;
      uint64_t v17 = *(void *)(result + 128);
      int v18 = a5;
      do
      {
        *a2++ = *(unsigned __int8 *)(v17 + *(unsigned __int16 *)(a9 + v16)) | (*(unsigned __int8 *)(v17
                                                                                                  + *(unsigned __int16 *)(a10 + v16)) << 8) | (*(unsigned __int8 *)(v17 + *(unsigned __int16 *)(a11 + v16)) << 16) | (*(unsigned __int8 *)(v17 + *(unsigned __int16 *)(a12 + v16)) << 24);
        v16 += 2;
        --v18;
      }
      while (v18);
      a12 += v16;
      a11 += v16;
      a10 += v16;
      a9 += v16;
    }
    a9 += 2 * a7;
    a10 += 2 * a7;
    a11 += 2 * a7;
    a12 += 2 * a7;
    a2 += a8;
  }
  return result;
}

uint64_t putRGBUAseparate16bittile(uint64_t result, int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  for (; a6; --a6)
  {
    if (a5)
    {
      uint64_t v16 = 0;
      uint64_t v18 = *(void *)(result + 120);
      uint64_t v17 = *(void *)(result + 128);
      int v19 = a5;
      do
      {
        uint64_t v20 = v18 + ((unint64_t)*(unsigned __int8 *)(v17 + *(unsigned __int16 *)(a12 + v16)) << 8);
        *a2++ = *(unsigned __int8 *)(v20 + *(unsigned __int8 *)(v17 + *(unsigned __int16 *)(a9 + v16))) | (*(unsigned __int8 *)(v17 + *(unsigned __int16 *)(a12 + v16)) << 24) | (*(unsigned __int8 *)(v20 + *(unsigned __int8 *)(v17 + *(unsigned __int16 *)(a10 + v16))) << 8) | (*(unsigned __int8 *)(v20 + *(unsigned __int8 *)(v17 + *(unsigned __int16 *)(a11 + v16))) << 16);
        v16 += 2;
        --v19;
      }
      while (v19);
      a12 += v16;
      a11 += v16;
      a10 += v16;
      a9 += v16;
    }
    a9 += 2 * a7;
    a10 += 2 * a7;
    a11 += 2 * a7;
    a12 += 2 * a7;
    a2 += a8;
  }
  return result;
}

uint64_t putRGBseparate16bittile(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int16 *a9, unsigned __int16 *a10, unsigned __int16 *a11)
{
  for (; a6; --a6)
  {
    if (a5)
    {
      uint64_t v14 = *(void *)(result + 128);
      int v15 = a5;
      do
      {
        unsigned int v16 = *a9++;
        int v17 = *(unsigned __int8 *)(v14 + v16);
        unsigned int v18 = *a10++;
        int v19 = *(unsigned __int8 *)(v14 + v18);
        unsigned int v20 = *a11++;
        *a2++ = v17 | (v19 << 8) | (*(unsigned __int8 *)(v14 + v20) << 16) | 0xFF000000;
        --v15;
      }
      while (v15);
    }
    a9 += a7;
    a10 += a7;
    a11 += a7;
    a2 += a8;
  }
  return result;
}

uint64_t putCMYKseparate8bittile(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int8 *a9, unsigned __int8 *a10, unsigned __int8 *a11, unsigned __int8 *a12)
{
  for (; a6; --a6)
  {
    if (a5)
    {
      int v16 = a5;
      do
      {
        int v18 = *a12++;
        int v17 = v18;
        int v19 = *a9++;
        v17 ^= 0xFFu;
        unsigned int v20 = 32897 * (v19 ^ 0xFF) * v17;
        int v21 = *a10++;
        unsigned int v22 = 32897 * (v21 ^ 0xFF) * v17;
        int v23 = *a11++;
        uint64_t result = (v22 >> 15) & 0x1FF00;
        *a2++ = result | (v20 >> 23) | ((32897 * (v23 ^ 0xFFu) * v17) >> 7) & 0xFF0000 | 0xFF000000;
        --v16;
      }
      while (v16);
    }
    a9 += a7;
    a10 += a7;
    a11 += a7;
    a12 += a7;
    a2 += a8;
  }
  return result;
}

void *putseparate8bitYCbCr11tile(void *result, unsigned int *a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7, int a8, unsigned __int8 *a9, unsigned __int8 *a10, unsigned __int8 *a11)
{
  if (a6)
  {
    int v11 = a6;
    uint64_t v14 = result;
    uint64_t v17 = a7;
    uint64_t v18 = 4 * a8;
    do
    {
      int v20 = a5;
      do
      {
        uint64_t v27 = 0;
        int v26 = 0;
        unsigned int v22 = *a9++;
        unsigned int v21 = v22;
        int v24 = *a10++;
        int v23 = v24;
        int v25 = *a11++;
        uint64_t result = TIFFYCbCrtoRGB((void *)v14[13], v21, v23, v25, (int *)&v27 + 1, (int *)&v27, &v26);
        *a2++ = HIDWORD(v27) | (v27 << 8) | (v26 << 16) | 0xFF000000;
        --v20;
      }
      while (v20);
      a9 += v17;
      a10 += v17;
      a11 += v17;
      a2 = (unsigned int *)((char *)a2 + v18);
      --v11;
    }
    while (v11);
  }
  return result;
}

uint64_t IIOScanner::lookupVal8(IIOScanner *this)
{
  unsigned int Val8 = IIOScanner::getVal8(this);
  uint64_t v3 = *((void *)this + 5);
  if (v3) {
    LOBYTE(Val8) = *(unsigned char *)(v3 + Val8);
  }
  return (char)Val8;
}

uint64_t IIOScanner::getVal24(IIOScanner *this)
{
  uint64_t v1 = *((void *)this + 3);
  uint64_t v2 = v1 + 2;
  if ((unint64_t)(v1 + 2) >= *((void *)this + 2))
  {
    LogError("getVal24", 196, "*** IIOScanner::getVal24 reached EOF\n");
    *((_DWORD *)this + 16) = -39;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -39;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  if (*((unsigned char *)this + 68)) {
    uint64_t v3 = *((void *)this + 3);
  }
  else {
    uint64_t v3 = v1 + 2;
  }
  if (!*((unsigned char *)this + 68)) {
    uint64_t v2 = *((void *)this + 3);
  }
  uint64_t v4 = *(unsigned __int8 *)(*((void *)this + 1) + v3) | (*(unsigned __int8 *)(v1 + *((void *)this + 1) + 1) << 8) | (*(unsigned __int8 *)(*((void *)this + 1) + v2) << 16);
  *((void *)this + 3) = v1 + 3;
  return v4;
}

uint64_t IIOScanner::getOSType(IIOScanner *this)
{
  uint64_t v1 = *((void *)this + 3);
  if ((unint64_t)(v1 + 3) >= *((void *)this + 2))
  {
    LogError("getOSType", 234, "*** IIOScanner::getOSType reached EOF\n");
    *((_DWORD *)this + 16) = -39;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -39;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  LODWORD(v2) = *(_DWORD *)(*((void *)this + 1) + v1);
  unsigned int v3 = bswap32(v2);
  if (*((unsigned char *)this + 68)) {
    uint64_t v2 = v3;
  }
  else {
    uint64_t v2 = v2;
  }
  *((void *)this + 3) = v1 + 4;
  return v2;
}

unint64_t IIOScanner::getVal64(IIOScanner *this)
{
  uint64_t v1 = *((void *)this + 3);
  if ((unint64_t)(v1 + 7) >= *((void *)this + 2))
  {
    LogError("getVal64", 254, "*** IIOScanner::getVal64 reached EOF\n");
    *((_DWORD *)this + 16) = -39;
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -39;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  unint64_t v2 = *(void *)(*((void *)this + 1) + v1);
  unint64_t v3 = bswap64(v2);
  if (!*((unsigned char *)this + 68)) {
    unint64_t v2 = v3;
  }
  *((void *)this + 3) = v1 + 8;
  return v2;
}

unint64_t IIOScanner::getTiffOffset(IIOScanner *this)
{
  if (*((_DWORD *)this + 8) == 4) {
    return IIOScanner::getVal32(this);
  }

  return IIOScanner::getVal64(this);
}

unint64_t IIOScanner::getIFDCount(IIOScanner *this)
{
  if (*((_DWORD *)this + 8) == 4) {
    return IIOScanner::getVal16(this);
  }

  return IIOScanner::getVal64(this);
}

uint64_t IIOScanner::sizeForTypeAndCount(IIOScanner *this, int a2, uint64_t a3)
{
  uint64_t result = a3;
  switch(a2)
  {
    case 0:
      uint64_t result = 0;
      break;
    case 3:
    case 8:
      uint64_t result = 2 * a3;
      break;
    case 4:
    case 9:
    case 11:
    case 13:
      uint64_t result = 4 * a3;
      break;
    case 5:
    case 10:
    case 12:
    case 16:
    case 17:
    case 18:
      uint64_t result = 8 * a3;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t IIOScanner::getTiffTag(uint64_t this, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = this;
    if ((unint64_t)(*(void *)(this + 24) + 12) >= *(void *)(this + 16))
    {
      *(_DWORD *)(a2 + 8) = 0;
      *(void *)a2 = 0;
      LogError("getTiffTag", 348, "*** IIOScanner::getTiffTag reached EOF\n");
      *(_DWORD *)(v3 + 64) = -39;
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = -39;
      __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
    }
    *(_WORD *)a2 = IIOScanner::getVal16((IIOScanner *)this);
    *(_WORD *)(a2 + 2) = IIOScanner::getVal16((IIOScanner *)v3);
    unsigned int Val32 = (IIOScanner *)IIOScanner::getVal32((IIOScanner *)v3);
    *(_DWORD *)(a2 + 4) = Val32;
    int v5 = IIOScanner::sizeForTypeAndCount(Val32, *(unsigned __int16 *)(a2 + 2), Val32);
    this = IIOScanner::getVal32((IIOScanner *)v3);
    int v6 = v5 - 1;
    if ((v5 - 1) <= 2)
    {
      int v7 = dword_1889ADDC0[v6];
      char v8 = 24 - 8 * v6;
      if (*(unsigned char *)(v3 + 68)) {
        char v8 = 0;
      }
      this = (this >> v8) & v7;
    }
    *(_DWORD *)(a2 + 8) = this;
  }
  return this;
}

unint64_t IIOScanner::getBigTiffTag(unint64_t this, uint64_t a2)
{
  if (a2)
  {
    unint64_t v3 = this;
    if ((unint64_t)(*(void *)(this + 24) + 20) >= *(void *)(this + 16))
    {
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
      *(_DWORD *)(a2 + 16) = 0;
      LogError("getBigTiffTag", 383, "*** IIOScanner::getBigTiffTag reached EOF\n");
      *(_DWORD *)(v3 + 64) = -39;
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = -39;
      __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
    }
    *(_WORD *)a2 = IIOScanner::getVal16((IIOScanner *)this);
    *(_WORD *)(a2 + 2) = IIOScanner::getVal16((IIOScanner *)v3);
    unint64_t Val64 = (IIOScanner *)IIOScanner::getVal64((IIOScanner *)v3);
    *(void *)(a2 + 4) = Val64;
    uint64_t v5 = IIOScanner::sizeForTypeAndCount(Val64, *(unsigned __int16 *)(a2 + 2), (uint64_t)Val64);
    this = IIOScanner::getVal64((IIOScanner *)v3);
    uint64_t v6 = v5 - 1;
    if ((unint64_t)(v5 - 1) <= 6)
    {
      uint64_t v7 = qword_1889ADDD0[v6];
      char v8 = 56 - 8 * v6;
      if (*(unsigned char *)(v3 + 68)) {
        char v8 = 0;
      }
      this = (this >> v8) & v7;
    }
    *(void *)(a2 + 12) = this;
  }
  return this;
}

uint64_t IIOScanner::getString(IIOScanner *this)
{
  unint64_t v2 = *((void *)this + 2);
  unint64_t v1 = *((void *)this + 3);
  if (v1 >= v2) {
    return 0;
  }
  uint64_t v3 = *((void *)this + 1);
  uint64_t v4 = v3 + v1;
  while (*(unsigned char *)(v3 + v1))
  {
    *((void *)this + 3) = ++v1;
    if (v2 == v1)
    {
      unint64_t v1 = v2;
      goto LABEL_7;
    }
  }
  if (v2 != v1) {
    goto LABEL_9;
  }
LABEL_7:
  if (*(unsigned char *)(v2 + v3 - 1)) {
    return 0;
  }
LABEL_9:
  *((void *)this + 3) = v1 + 1;
  return v4;
}

unint64_t IIOScanner::seek(IIOScanner *this, unint64_t a2, int a3)
{
  if (a3)
  {
    if (a3 == 2)
    {
      uint64_t v3 = (char *)this + 16;
    }
    else
    {
      if (a3 != 1)
      {
        a2 = 0;
        goto LABEL_10;
      }
      uint64_t v3 = (char *)this + 24;
    }
    a2 += *(void *)v3;
  }
  if ((a2 & 0x8000000000000000) != 0)
  {
    unint64_t v4 = 0;
    goto LABEL_12;
  }
LABEL_10:
  unint64_t v4 = *((void *)this + 2);
  if (a2 < v4) {
    unint64_t v4 = a2;
  }
LABEL_12:
  *((void *)this + 3) = v4;
  return v4;
}

size_t IIOScanner::getBytes(IIOScanner *this, void *__dst, size_t a3)
{
  uint64_t v4 = *((void *)this + 3);
  if (v4 + a3 <= *((void *)this + 2))
  {
    size_t v5 = a3;
    memcpy(__dst, (const void *)(*((void *)this + 1) + v4), a3);
    uint64_t v4 = *((void *)this + 3);
  }
  else
  {
    size_t v5 = 0;
  }
  *((void *)this + 3) = v4 + v5;
  return v5;
}

void ImageIO_XMP_IO::New_ImageIO_XMP_IO(ImageIO_XMP_IO *this, __CFData *a2)
{
  if (this)
  {
    CFTypeID v2 = CFGetTypeID(this);
    if (v2 == CFDataGetTypeID()) {
      operator new();
    }
  }
  exception = __cxa_allocate_exception(0x18uLL);
  *(_DWORD *)exception = 4;
  exception[1] = "New_ImageIO_XMP_IO, data must be a valid non-NULL CFMutableDataRef";
  *((unsigned char *)exception + 16) = 0;
}

void sub_1887FF0F8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C404F4F037ELL);
  _Unwind_Resume(a1);
}

void ImageIO_XMP_IO::ImageIO_XMP_IO(ImageIO_XMP_IO *this, CFTypeRef cf)
{
  *(void *)this = &unk_1ED4E2838;
  CFTypeRef v3 = CFRetain(cf);
  *((void *)this + 4) = 0;
  *((unsigned char *)this + 24) = 0;
  *((void *)this + 1) = v3;
  *((void *)this + 2) = 0;
}

size_t ImageIO_XMP_IO::Read(CFDataRef *this, void *a2, int a3)
{
  LODWORD(v3) = a3;
  BytePtr = CFDataGetBytePtr(this[1]);
  CFIndex Length = CFDataGetLength(this[1]);
  CFDataRef v8 = this[2];
  if ((uint64_t)v8 + v3 <= Length) {
    size_t v3 = v3;
  }
  else {
    size_t v3 = (Length - v8);
  }
  memmove(a2, (char *)v8 + (void)BytePtr, v3);
  this[2] = (CFDataRef)((char *)this[2] + v3);
  return v3;
}

void ImageIO_XMP_IO::Write(ImageIO_XMP_IO *this, const UInt8 *a2, unsigned int a3)
{
  uint64_t v6 = *((void *)this + 2);
  if (v6 == CFDataGetLength(*((CFDataRef *)this + 1)))
  {
    CFDataAppendBytes(*((CFMutableDataRef *)this + 1), a2, a3);
  }
  else
  {
    CFIndex v7 = *((void *)this + 2) + a3;
    if (v7 > CFDataGetLength(*((CFDataRef *)this + 1)))
    {
      CFDataRef v8 = (const __CFData *)*((void *)this + 1);
      uint64_t v9 = *((void *)this + 2) + a3;
      CFIndex Length = CFDataGetLength(v8);
      CFDataIncreaseLength(v8, v9 - Length);
    }
    MutableBytePtr = CFDataGetMutableBytePtr(*((CFMutableDataRef *)this + 1));
    memmove(&MutableBytePtr[*((void *)this + 2)], a2, a3);
  }
  *((void *)this + 2) += a3;
}

uint64_t ImageIO_XMP_IO::Seek(uint64_t a1, uint64_t a2, int a3)
{
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 8));
  switch(a3)
  {
    case 0:
      goto LABEL_6;
    case 1:
      a2 += *(void *)(a1 + 16);
      goto LABEL_6;
    case 2:
      a2 += Length;
LABEL_6:
      *(void *)(a1 + 16) = a2;
      goto LABEL_8;
  }
  a2 = *(void *)(a1 + 16);
LABEL_8:
  if (a2 <= Length)
  {
    if (a2 < 0)
    {
      a2 = 0;
      *(void *)(a1 + 16) = 0;
    }
  }
  else
  {
    CFDataRef v7 = *(const __CFData **)(a1 + 8);
    CFIndex v8 = CFDataGetLength(v7);
    CFDataIncreaseLength(v7, a2 - v8);
    return *(void *)(a1 + 16);
  }
  return a2;
}

CFIndex ImageIO_XMP_IO::Length(CFDataRef *this)
{
  return CFDataGetLength(this[1]);
}

void ImageIO_XMP_IO::Truncate(CFDataRef *this, CFIndex a2)
{
  if (CFDataGetLength(this[1]) < a2)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 7;
    exception[1] = "ImageIO_XMP_IO::Truncate, new length is longer than current length";
    *((unsigned char *)exception + 16) = 0;
  }
  if ((uint64_t)this[2] > a2) {
    this[2] = (CFDataRef)a2;
  }
  uint64_t v4 = this[1];

  CFDataSetLength(v4, a2);
}

CFDataRef ImageIO_XMP_IO::DeriveTemp(CFDataRef *this)
{
  if (!this[4])
  {
    MutableCopdouble y = CFDataCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, this[1]);
    if (MutableCopy) {
      ImageIO_XMP_IO::New_ImageIO_XMP_IO(MutableCopy, v3);
    }
  }
  return this[4];
}

uint64_t ImageIO_XMP_IO::AbsorbTemp(ImageIO_XMP_IO *this)
{
  CFTypeID v2 = (void *)*((void *)this + 4);
  if (!v2)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 9;
    exception[1] = "XMPFiles_IO::AbsorbTemp, no temp to absorb";
    *((unsigned char *)exception + 16) = 0;
  }
  CFDataRef v3 = (const __CFData *)v2[1];
  CFIndex v4 = (*(uint64_t (**)(void *))(*v2 + 24))(v2);
  CFDataSetLength(*((CFMutableDataRef *)this + 1), v4);
  size_t v5 = (__CFData *)*((void *)this + 1);
  BytePtr = CFDataGetBytePtr(v3);
  v11.location = 0;
  v11.size_t length = v4;
  CFDataReplaceBytes(v5, v11, BytePtr, v4);
  CFDataRef v7 = *(uint64_t (**)(ImageIO_XMP_IO *))(*(void *)this + 56);

  return v7(this);
}

uint64_t ImageIO_XMP_IO::DeleteTemp(ImageIO_XMP_IO *this)
{
  uint64_t result = *((void *)this + 4);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 72))(result);
    *((void *)this + 4) = 0;
  }
  return result;
}

void ImageIO_XMP_IO::~ImageIO_XMP_IO(ImageIO_XMP_IO *this)
{
  *(void *)this = &unk_1ED4E2838;
  CFDataRef v3 = (void *)((char *)this + 8);
  CFTypeID v2 = (const void *)*((void *)this + 1);
  if (v2) {
    CFRelease(v2);
  }
  void *v3 = 0;
  v3[1] = 0;
  if (*((void *)this + 4)) {
    (*(void (**)(ImageIO_XMP_IO *))(*(void *)this + 56))(this);
  }
}

{
  uint64_t vars8;

  ImageIO_XMP_IO::~ImageIO_XMP_IO(this);

  JUMPOUT(0x18C11C0E0);
}

void IIO_Writer_ICO::~IIO_Writer_ICO(IIO_Writer_ICO *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIO_Writer_ICO::write(IIO_Writer_ICO *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  ICOWritePlugin::ICOWritePlugin((ICOWritePlugin *)v5, a2, a3);
  uint64_t v3 = ICOWritePlugin::writeAll((IIOImageDestination **)v5);
  ICOWritePlugin::~ICOWritePlugin((ICOWritePlugin *)v5);
  return v3;
}

void sub_1887FF6C4(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void JP2WritePlugin::~JP2WritePlugin(JP2WritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t JP2WritePlugin::writeOneImage(JP2WritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t JP2WritePlugin::writeOne(JP2WritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  uint64_t v37 = 0;
  long long v36 = 0u;
  memset(v35, 0, sizeof(v35));
  SourceGeomCGColorSpaceRef ColorSpace = IIOImagePlus::getSourceGeomColorSpace(a2);
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v30 = 0u;
  long long v28 = 0u;
  *(_OWORD *)CFTypeRef cf = 0u;
  long long v27 = 0u;
  memset(v26, 0, sizeof(v26));
  uint64_t v23 = 0;
  if (!SourceGeomColorSpace) {
    return 4294967246;
  }
  CFIndex v8 = (CGColorSpace *)SourceGeomColorSpace;
  v35[1] = *((void *)this + 2);
  *((void *)&v36 + 1) = MyWrite;
  *(void *)&long long v27 = IIOImageSource::count(a2);
  *((void *)&v27 + 1) = IIO_Reader::testHeaderSize(a2);
  unsigned int Error = _cg_GifLastError((uint64_t)a2);
  *(void *)&long long v30 = Error;
  unsigned int appleflags = _cg_png_get_appleflags((uint64_t)a2);
  *(void *)&long long v31 = appleflags;
  *((void *)&v31 + 1) = IIOImagePlus::sourceImageProvider(a2);
  HIDWORD(cf[1]) = IIOImagePixelDataProvider::getAlphaInfo(a2);
  size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(v8);
  if ((HIDWORD(cf[1]) - 1) >= 4) {
    size_t v12 = NumberOfComponents;
  }
  else {
    size_t v12 = NumberOfComponents + 1;
  }
  *((void *)&v28 + 1) = NumberOfComponents;
  *((void *)&v30 + 1) = v12;
  if (v12 != appleflags / Error)
  {
    _cg_jpeg_mem_term("writeOne", 354, "*** ERROR numChannels != (bpp / bpc)  (%d != (%d / %d)\n", v12, appleflags, Error);
    return 4294967246;
  }
  if (IIODictionary::containsKey(a3, @"kCGImageDestinationLossyCompressionQuality"))
  {
    FloatForKedouble y = IIODictionary::getFloatForKey(a3, @"kCGImageDestinationLossyCompressionQuality");
    float v14 = *(float *)&FloatForKey;
    float v15 = 1.0;
    if (v14 > 1.0) {
      float v14 = 1.0;
    }
    if (v14 < 0.0) {
      float v14 = 0.0;
    }
    if (v14 < 1.0)
    {
      if (v14 >= 0.03)
      {
        float v22 = logf(1.0 - v14);
        float v15 = 1.0 - exp(v22 * 0.333333333);
      }
      else
      {
        float v15 = 0.01;
      }
    }
  }
  else
  {
    float v15 = 0.2;
  }
  unsigned int v25 = 0;
  uint64_t v24 = 0;
  _cg_JP2InitCompressionSettings((uint64_t)&v24, v15);
  if (IIODictionary::containsKey(a3, @"kCGImageDestinationRequestedFileSize"))
  {
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(a3, @"kCGImageDestinationRequestedFileSize");
    if (Uint32ForKey <= 0x65uLL) {
      unsigned int Uint32ForKey = 101;
    }
    unsigned int v25 = Uint32ForKey - 100;
  }
  uint64_t v17 = _cg_JP2CompressorSetup((uint64_t)MyImageSourceReader, (uint64_t)a2, (uint64_t)v35, v26, &v24, &v23);
  if (IIODictionary::containsKey(a3, @"DPIHeight"))
  {
    if (IIODictionary::containsKey(a3, @"DPIWidth"))
    {
      double v18 = IIODictionary::getFloatForKey(a3, @"DPIWidth");
      float v19 = *(float *)&v18;
      double v20 = IIODictionary::getFloatForKey(a3, @"DPIHeight");
      if (v19 != 72.0 || *(float *)&v20 != 72.0) {
        _cg_JP2CompressorSetDisplayResolution(v23, v19, *(float *)&v20);
      }
    }
  }
  if (!v17) {
    uint64_t v17 = _cg_JP2CompressorProcessImage(v23);
  }
  _cg_JP2CompressorTearDown(v23);
  if (cf[0]) {
    CFRelease(cf[0]);
  }
  return v17;
}

uint64_t JP2WritePlugin::WriteProc(JP2WritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v9, this, a2, 1246769696);
  *(void *)&v9[0] = &unk_1ED4E2898;
  uint64_t v5 = IIOWritePlugin::writeAll((IIOImageDestination **)v9);
  _cg_jpeg_mem_term(v9, v6, v7);
  return v5;
}

void sub_1887FFAE4(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void IIO_Writer_TIFF::~IIO_Writer_TIFF(IIO_Writer_TIFF *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIO_Writer_TIFF::write(IIO_Writer_TIFF *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  TIFFWritePlugin::TIFFWritePlugin((TIFFWritePlugin *)v5, a2, a3);
  uint64_t v3 = TIFFWritePlugin::writeAll((IIOImageDestination **)v5);
  TIFFWritePlugin::~TIFFWritePlugin((TIFFWritePlugin *)v5);
  return v3;
}

void sub_1887FFB98(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

float ASTCBitsPerPixel(int a1, int a2)
{
  if (a1 != 4 || (float result = 8.0, a2 != 4))
  {
    if (a1 == 5 && a2 == 5)
    {
      return 5.12;
    }
    else if (a1 == 6 && a2 == 6)
    {
      return 3.556;
    }
    else if (a1 != 8 || (float result = 2.0, a2 != 8))
    {
      if (a1 == 4 && a2 == 6)
      {
        return 5.333;
      }
      else if (a1 == 8 && a2 == 10)
      {
        return 1.6;
      }
      else
      {
        BOOL v3 = a2 == 10 && a1 == 12;
        float result = 1.067;
        if (!v3) {
          return 8.0;
        }
      }
    }
  }
  return result;
}

void IIOTextureHandler::setImp(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v2 = a2[1];
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  CFIndex v4 = *(std::__shared_weak_count **)(a1 + 16);
  *(void *)(a1 + 8) = v3;
  *(void *)(a1 + 16) = v2;
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
}

void CommonASTCReadPlugin::CommonASTCReadPlugin(uint64_t a1, uint64_t a2)
{
}

void sub_1887FFD44(_Unwind_Exception *a1)
{
  uint64_t v3 = (std::__shared_weak_count *)*((void *)v1 + 60);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

uint64_t CommonASTCReadPlugin::loadDataFromXPCObject(CommonASTCReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (result)
  {
    *((void *)this + 58) = 0;
  }
  else
  {
    *(void *)&long long v9 = 0;
    CFDictionaryRef data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_common_astc", (size_t *)&v9);
    if ((void)v9 == 24)
    {
      long long v6 = *(_OWORD *)data;
      *(void *)((char *)this + 452) = data[2];
      *(_OWORD *)((char *)this + 436) = v6;
      *((void *)this + 58) = 0;
      std::allocate_shared[abi:ne180100]<ASTCTextureImp,std::allocator<ASTCTextureImp>,unsigned int &,void>((unsigned int *)this + 52, &v9);
      long long v7 = v9;
      long long v9 = 0uLL;
      CFIndex v8 = (std::__shared_weak_count *)*((void *)this + 60);
      *(_OWORD *)((char *)this + 472) = v7;
      if (v8)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v8);
        if (*((void *)&v9 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v9 + 1));
        }
      }
      return 0;
    }
    else
    {
      *((void *)this + 58) = 0;
      return 4294967246;
    }
  }
  return result;
}

uint64_t CommonASTCReadPlugin::saveDataToXPCObject(CommonASTCReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_common_astc", (char *)this + 436, 0x18uLL);
  }
  return v4;
}

uint64_t CommonASTCReadPlugin::cacheImmediately(CommonASTCReadPlugin *this, const __CFDictionary *a2, CGImage *a3)
{
  return (*(uint64_t (**)(void, void, const __CFDictionary *, CGImage *))(**((void **)this + 59) + 32))(*((void *)this + 59), *((void *)this + 3), a2, a3);
}

void CommonASTCWritePlugin::CommonASTCWritePlugin(CommonASTCWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, int a4)
{
  IIOWritePlugin::IIOWritePlugin(this, a2, a3, a4);
  *(void *)uint64_t v4 = &unk_1ED4E51F0;
  *(void *)(v4 + 44) = 0x400000044;
  *(_DWORD *)(v4 + 52) = 4;
  *(_DWORD *)(v4 + 40) = 0;
  *(_DWORD *)(v4 + 57) = 0;
  *(unsigned char *)(v4 + 61) = 0;
}

void CommonASTCWritePlugin::~CommonASTCWritePlugin(CommonASTCWritePlugin *this, uint64_t a2, const char *a3)
{
  *(void *)this = &unk_1ED4E51F0;
  _cg_jpeg_mem_term(this, a2, a3);
}

const __CFDictionary *CommonASTCWritePlugin::handleProperties(const __CFDictionary *this, IIODictionary *a2)
{
  if (a2)
  {
    uint64_t v3 = (uint64_t)this;
    if (IIODictionary::containsKey(a2, @"kCGImageDestinationLossyCompressionQuality"))
    {
      FloatForKedouble y = IIODictionary::getFloatForKey(a2, @"kCGImageDestinationLossyCompressionQuality");
      float v5 = 0.0;
      if (*(float *)&FloatForKey >= 0.0)
      {
        float v5 = *(float *)&FloatForKey;
        if (*(float *)&FloatForKey > 1.0) {
          float v5 = 1.0;
        }
      }
      float v6 = (1.0 - v5) * 0.0032;
      *(float *)(v3 + 40) = v6;
    }
    else
    {
      *(_DWORD *)(v3 + 40) = 978433815;
    }
    if (IIODictionary::containsKey(a2, @"kCGImagePropertyASTCBlockSize"))
    {
      unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(a2, @"kCGImagePropertyASTCBlockSize");
      *(_DWORD *)(v3 + 44) = Uint32ForKey;
    }
    else
    {
      unsigned int Uint32ForKey = *(_DWORD *)(v3 + 44);
    }
    *(_DWORD *)(v3 + 48) = Uint32ForKey >> 4;
    *(_DWORD *)(v3 + 52) = Uint32ForKey & 0xF;
    *(unsigned char *)(v3 + 56) = IIODictionary::getBoolForKey(a2, @"kCGImagePropertyASTCUseHDR");
    *(unsigned char *)(v3 + 57) = IIODictionary::getBoolForKey(a2, @"kCGImagePropertyASTCUseLZFSE");
    *(unsigned char *)(v3 + 58) = IIODictionary::getBoolForKey(a2, @"kCGImagePropertyASTCPreTwiddle");
    if (IIODictionary::containsKey(a2, @"kCGImagePropertyASTCFlipVertically")) {
      *(unsigned char *)(v3 + 60) = IIODictionary::getBoolForKey(a2, @"kCGImagePropertyASTCFlipVertically");
    }
    this = IIODictionary::containsKey(a2, @"kCGImagePropertyASTCWeightChannelsEqually");
    if (this)
    {
      this = (const __CFDictionary *)IIODictionary::getBoolForKey(a2, @"kCGImagePropertyASTCWeightChannelsEqually");
      *(unsigned char *)(v3 + 61) = (_BYTE)this;
    }
  }
  return this;
}

void std::__shared_ptr_emplace<ASTCTextureImp>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED4EF348;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<ASTCTextureImp>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED4EF348;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18C11C0E0);
}

uint64_t _TIFFgetMode(void *a1, uint64_t a2, char *a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *a3;
  if (v8 == 97 || v8 == 119)
  {
    if (*a3 == 119) {
      return 1538;
    }
    else {
      return 514;
    }
  }
  else if (v8 == 114)
  {
    return 2 * (a3[1] == 43);
  }
  else
  {
    _TIFFErrorEarly(a1, a2, a4, "\"%s\": Bad mode", a5, a6, a7, a8, (char)a3);
    return 0xFFFFFFFFLL;
  }
}

void *_TIFFmallocExt(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v10 = a1[170];
    if (v10 >= 1 && v10 < a2)
    {
      TIFFErrorExtR((uint64_t)a1, "_TIFFmallocExt", "Memory allocation of %llu bytes is beyond the %llu byte limit defined in open options", a4, a5, a6, a7, a8, a2);
      return 0;
    }
    uint64_t v12 = a1[171];
    if (v12 >= 1)
    {
      uint64_t v13 = a1[172];
      if (a2 <= 0x7FFFFFFFFFFFFFEFLL && v12 - v13 >= a2)
      {
        uint64_t result = _TIFFmalloc((void *)(a2 + 16));
        if (result)
        {
          a1[172] += a2;
          *uint64_t result = a2;
          result += 2;
        }
        return result;
      }
      TIFFErrorExtR((uint64_t)a1, "_TIFFmallocExt", "Cumulated memory allocation of %llu + %llu bytes is beyond the %llu cumulated byte limit defined in open options", a4, a5, a6, a7, a8, v13);
      return 0;
    }
  }

  return _TIFFmalloc((void *)a2);
}

void *_TIFFcallocExt(void *a1, int64_t a2, int64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 0;
  if (a2 >= 1 && a3 >= 1)
  {
    if (0x7FFFFFFFFFFFFFFFuLL / a3 < a2) {
      return 0;
    }
    if (!a1) {
      goto LABEL_13;
    }
    uint64_t v10 = a1[170];
    uint64_t v11 = a3 * a2;
    if (v10 >= 1 && v11 > v10)
    {
      TIFFErrorExtR((uint64_t)a1, "_TIFFcallocExt", "Memory allocation of %llu bytes is beyond the %llu byte limit defined in open options", a4, a5, a6, a7, a8, v11);
      return 0;
    }
    uint64_t v12 = a1[171];
    if (v12 >= 1)
    {
      uint64_t v13 = a1[172];
      if (v11 > 0x7FFFFFFFFFFFFFEFLL || v11 > v12 - v13)
      {
        TIFFErrorExtR((uint64_t)a1, "_TIFFcallocExt", "Cumulated memory allocation of %llu + %llu bytes is beyond the %llu cumulated byte limit defined in open options", a4, a5, a6, a7, a8, v13);
        return 0;
      }
      uint64_t result = _TIFFcalloc(v11 + 16, 1uLL);
      if (result)
      {
        a1[172] += v11;
        *uint64_t result = v11;
        result += 2;
      }
    }
    else
    {
LABEL_13:
      return _TIFFcalloc(a2, a3);
    }
  }
  return result;
}

void *_TIFFreallocExt(void *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v10 = a1[170];
    if (v10 >= 1 && v10 < a3)
    {
      TIFFErrorExtR((uint64_t)a1, "_TIFFreallocExt", "Memory allocation of %llu bytes is beyond the %llu byte limit defined in open options", a4, a5, a6, a7, a8, a3);
      return 0;
    }
    uint64_t v12 = a1[171];
    if (v12 >= 1)
    {
      if (a2)
      {
        uint64_t v14 = *((void *)a2 - 2);
        a2 -= 16;
        uint64_t v13 = v14;
        if (v14 > a1[172]) {
          _TIFFreallocExt_cold_1();
        }
      }
      else
      {
        uint64_t v13 = 0;
      }
      uint64_t v16 = a3 - v13;
      if (a3 <= v13 || (uint64_t v17 = a1[172], a3 <= 0x7FFFFFFFFFFFFFEFLL) && v13 + v12 - v17 >= a3)
      {
        uint64_t result = _TIFFrealloc(a2, a3 + 16);
        if (result)
        {
          a1[172] += v16;
          *uint64_t result = a3;
          result += 2;
        }
        return result;
      }
      TIFFErrorExtR((uint64_t)a1, "_TIFFreallocExt", "Cumulated memory allocation of %llu + %llu bytes is beyond the %llu cumulated byte limit defined in open options", a4, a5, a6, a7, a8, v17);
      return 0;
    }
  }

  return _TIFFrealloc(a2, a3);
}

void _TIFFfreeExt(uint64_t a1, char *a2)
{
  if (a1 && a2 && *(uint64_t *)(a1 + 1368) >= 1)
  {
    uint64_t v2 = *((void *)a2 - 2);
    a2 -= 16;
    uint64_t v3 = *(void *)(a1 + 1376);
    uint64_t v4 = v3 - v2;
    if (v3 < v2) {
      _TIFFfreeExt_cold_1();
    }
    *(void *)(a1 + 1376) = v4;
  }

  _TIFFfree(a2);
}

uint64_t _cg_TIFFClientOpen(const char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(), uint64_t (*a10)())
{
  return TIFFClientOpenExt(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, 0);
}

uint64_t TIFFClientOpenExt(const char *a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t (*a9)(), uint64_t (*a10)(), uint64_t a11)
{
  int v19 = _TIFFgetMode((void *)a11, a3, a2, "TIFFClientOpenExt", a5, a6, a7, a8);
  if (v19 == -1) {
    return 0;
  }
  int v20 = v19;
  unsigned int v21 = (void *)(strlen(a1) + 1385);
  if (a11)
  {
    uint64_t v26 = *(void *)(a11 + 32);
    if (v26 >= 1 && (uint64_t)v21 > v26)
    {
      _TIFFErrorEarly((void *)a11, a3, "TIFFClientOpenExt", "%s: Memory allocation of %llu bytes is beyond the %llu byte limit defined in open options", v22, v23, v24, v25, (char)a1);
      return 0;
    }
    uint64_t v28 = *(void *)(a11 + 40);
    if (v28 >= 1 && (uint64_t)v21 > v28)
    {
      _TIFFErrorEarly((void *)a11, a3, "TIFFClientOpenExt", "%s: Memory allocation of %llu bytes is beyond the %llu cumulated byte limit defined in open options", v22, v23, v24, v25, (char)a1);
      return 0;
    }
  }
  uint64_t v70 = a8;
  long long v30 = _TIFFmalloc(v21);
  uint64_t v35 = (uint64_t)v30;
  if (!v30)
  {
    _TIFFErrorEarly((void *)a11, a3, "TIFFClientOpenExt", "%s: Out of memory (TIFF structure)", v31, v32, v33, v34, (char)a1);
    return v35;
  }
  _TIFFmemset(v30, 0, 0x568uLL);
  *(void *)uint64_t v35 = v35 + 1384;
  strcpy((char *)(v35 + 1384), a1);
  *(_DWORD *)(v35 + 12) = v20 & 0xFFFFF9FF;
  *(void *)(v35 + 888) = 0;
  *(void *)(v35 + 880) = -1;
  *(_DWORD *)(v35 + 876) = -1;
  *(void *)(v35 + 1200) = a3;
  *(void *)(v35 + 1208) = a4;
  *(void *)(v35 + 1216) = a5;
  *(void *)(v35 + 1224) = a6;
  *(void *)(v35 + 1232) = a7;
  *(void *)(v35 + 1240) = v70;
  if (a9) {
    int v41 = a9;
  }
  else {
    int v41 = _tiffDummyMapProc;
  }
  *(void *)(v35 + 1184) = v41;
  int v42 = a10;
  if (!a10) {
    int v42 = _tiffDummyUnmapProc;
  }
  *(void *)(v35 + 1192) = v42;
  if (a11)
  {
    *(_OWORD *)(v35 + 1328) = *(_OWORD *)a11;
    *(_OWORD *)(v35 + 1344) = *(_OWORD *)(a11 + 16);
    *(_OWORD *)(v35 + 1360) = *(_OWORD *)(a11 + 32);
  }
  if (!a4 || !a5 || !a6 || !a7 || !v70)
  {
    TIFFErrorExtR(v35, "TIFFClientOpenExt", "One of the client procedures is NULL pointer.", v36, v37, v38, v39, v40, v69);
    _TIFFfree((void *)v35);
    return 0;
  }
  _TIFFSetDefaultCompressionState(v35);
  if (v20) {
    unsigned int v48 = 1;
  }
  else {
    unsigned int v48 = 2049;
  }
  *(_DWORD *)(v35 + 16) = v48;
  if ((v20 | 2) == 2)
  {
    v48 |= 0x8000u;
    *(_DWORD *)(v35 + 16) = v48;
  }
  LOBYTE(v49) = *a2;
  if (*a2)
  {
    int v50 = (unsigned __int8 *)(a2 + 1);
    while (1)
    {
      int v49 = (char)v49;
      if ((char)v49 <= 97) {
        break;
      }
      if (v49 > 103)
      {
        if (v49 == 104)
        {
          v48 |= 0x10000u;
        }
        else
        {
          if (v49 != 109 || v20) {
            goto LABEL_61;
          }
          v48 &= ~0x800u;
        }
        goto LABEL_60;
      }
      if (v49 != 98)
      {
        if (v49 != 99 || v20) {
          goto LABEL_61;
        }
        v48 &= ~0x8000u;
        goto LABEL_60;
      }
      if ((v20 & 0x200) != 0)
      {
        v48 |= 0x80u;
LABEL_60:
        *(_DWORD *)(v35 + 16) = v48;
      }
LABEL_61:
      int v51 = *v50++;
      LOBYTE(v49) = v51;
      if (!v51) {
        goto LABEL_62;
      }
    }
    switch(v49)
    {
      case 'B':
        goto LABEL_51;
      case 'C':
        if (v20) {
          goto LABEL_61;
        }
        v48 |= 0x8000u;
        goto LABEL_60;
      case 'D':
        v48 |= 0x1000000u;
        goto LABEL_60;
      case 'E':
      case 'F':
      case 'G':
      case 'I':
      case 'J':
      case 'K':
      case 'N':
        goto LABEL_61;
      case 'H':
        TIFFWarningExtR(v35, a1, "H(ost) mode is deprecated. Since libtiff 4.5.1, it is an alias of 'B' / FILLORDER_MSB2LSB.", v43, v44, v45, v46, v47, v69);
        unsigned int v48 = *(_DWORD *)(v35 + 16);
LABEL_51:
        unsigned int v48 = v48 & 0xFFFFFFFC | 1;
        goto LABEL_60;
      case 'L':
        unsigned int v48 = v48 & 0xFFFFFFFC | 2;
        goto LABEL_60;
      case 'M':
        if (v20) {
          goto LABEL_61;
        }
        v48 |= 0x800u;
        break;
      case 'O':
        if (v20) {
          goto LABEL_61;
        }
        v48 |= 0x3000000u;
        break;
      default:
        if (v49 != 56 || (v20 & 0x200) == 0) {
          goto LABEL_61;
        }
        v48 |= 0x80000u;
        break;
    }
    goto LABEL_60;
  }
LABEL_62:
  if ((v20 & 0x400) == 0)
  {
    int v52 = (_WORD *)(v35 + 856);
    if ((*(uint64_t (**)(void, uint64_t, uint64_t))(v35 + 1208))(*(void *)(v35 + 1200), v35 + 856, 8) == 8)
    {
      int v56 = (unsigned __int16)*v52;
      if (v56 != 18761)
      {
        if (v56 == 19789)
        {
          *(_DWORD *)(v35 + 16) |= 0x80u;
        }
        else if (v56 != 20549)
        {
          TIFFErrorExtR(v35, a1, "Not a TIFF or MDI file, bad magic number %hu (0x%hx)", v43, v44, v45, v46, v47, *v52);
LABEL_105:
          *(_DWORD *)(v35 + 12) = 0;
          TIFFCleanup(v35, v53, v54, v43, v44, v45, v46, v47);
          return 0;
        }
      }
      if ((*(unsigned char *)(v35 + 16) & 0x80) != 0) {
        TIFFSwabShort((unsigned char *)(v35 + 858));
      }
      int v62 = *(unsigned __int16 *)(v35 + 858);
      if ((v62 & 0xFFFE) != 0x2A)
      {
        TIFFErrorExtR(v35, a1, "Not a TIFF file, bad version number %hu (0x%hx)", v43, v44, v45, v46, v47, *(_WORD *)(v35 + 858));
        goto LABEL_105;
      }
      if (v62 == 42)
      {
        int v63 = *(_DWORD *)(v35 + 16);
        if ((v63 & 0x80) != 0)
        {
          TIFFSwabLong((__int32 *)(v35 + 860), v55);
          int v63 = *(_DWORD *)(v35 + 16);
        }
        *(_WORD *)(v35 + 872) = 8;
        goto LABEL_92;
      }
      if ((*(uint64_t (**)(void, uint64_t, uint64_t))(v35 + 1208))(*(void *)(v35 + 1200), v35 + 864, 8) == 8)
      {
        if ((*(unsigned char *)(v35 + 16) & 0x80) != 0)
        {
          TIFFSwabShort((unsigned char *)(v35 + 860));
          TIFFSwabLong8((int8x8_t *)(v35 + 864));
        }
        if (*(_WORD *)(v35 + 860) != 8)
        {
          TIFFErrorExtR(v35, a1, "Not a TIFF file, bad BigTIFF offsetsize %hu (0x%hx)", v43, v44, v45, v46, v47, *(_WORD *)(v35 + 860));
          goto LABEL_105;
        }
        if (*(_WORD *)(v35 + 862))
        {
          TIFFErrorExtR(v35, a1, "Not a TIFF file, bad BigTIFF unused %hu (0x%hx)", v43, v44, v45, v46, v47, *(_WORD *)(v35 + 862));
          goto LABEL_105;
        }
        *(_WORD *)(v35 + 872) = 16;
        int v63 = *(_DWORD *)(v35 + 16) | 0x80000;
LABEL_92:
        unsigned int v64 = v63 | 0x200;
        *(_DWORD *)(v35 + 16) = v63 | 0x200;
        *(_OWORD *)(v35 + 1120) = 0u;
        *(_OWORD *)(v35 + 1136) = 0u;
        *(void *)(v35 + 1152) = 0;
        int v65 = *a2;
        if (v65 == 97)
        {
          uint64_t v68 = v35;
        }
        else
        {
          if (v65 != 114) {
            goto LABEL_105;
          }
          if ((v63 & 0x80000) != 0) {
            uint64_t v66 = *(void *)(v35 + 864);
          }
          else {
            uint64_t v66 = *(unsigned int *)(v35 + 860);
          }
          *(void *)(v35 + 32) = v66;
          if ((v63 & 0x800) != 0)
          {
            __dst[0] = 0;
            if ((*(unsigned int (**)(void, uint64_t, void *))(v35 + 1184))(*(void *)(v35 + 1200), v35 + 1168, __dst))
            {
              *(void *)(v35 + 1176) = __dst[0];
              unsigned int v64 = *(_DWORD *)(v35 + 16);
            }
            else
            {
              unsigned int v64 = *(_DWORD *)(v35 + 16) & 0xFFFFF7FF;
              *(_DWORD *)(v35 + 16) = v64;
            }
          }
          uint64_t v68 = v35;
          if ((v64 & 0x10000) == 0)
          {
            if (_cg_TIFFReadDirectory(v35)) {
              return v35;
            }
            goto LABEL_105;
          }
        }
        if (TIFFDefaultDirectory(v68)) {
          return v35;
        }
        goto LABEL_105;
      }
      goto LABEL_103;
    }
  }
  if (!*(_DWORD *)(v35 + 12))
  {
LABEL_103:
    int v61 = "Cannot read TIFF header";
    goto LABEL_104;
  }
  int v57 = *(_DWORD *)(v35 + 16);
  if ((v57 & 0x80) != 0) {
    __int16 v58 = 19789;
  }
  else {
    __int16 v58 = 18761;
  }
  *(_WORD *)(v35 + 856) = v58;
  int v59 = (const void *)(v35 + 856);
  __dst[0] = 0;
  __dst[1] = 0;
  if ((v57 & 0x80000) != 0)
  {
    *(_DWORD *)(v35 + 858) = 524331;
    *(_WORD *)(v35 + 862) = 0;
    *(void *)(v35 + 864) = 0;
    *(_WORD *)(v35 + 872) = 16;
    _TIFFmemcpy(__dst, v59, 0x10uLL);
    if ((*(unsigned char *)(v35 + 16) & 0x80) != 0)
    {
      TIFFSwabShort((unsigned char *)__dst + 2);
      int v60 = (char *)__dst + 4;
      goto LABEL_79;
    }
  }
  else
  {
    *(_WORD *)(v35 + 858) = 42;
    *(_DWORD *)(v35 + 860) = 0;
    *(_WORD *)(v35 + 872) = 8;
    _TIFFmemcpy(__dst, v59, 0x10uLL);
    if ((*(unsigned char *)(v35 + 16) & 0x80) != 0)
    {
      int v60 = (char *)__dst + 2;
LABEL_79:
      TIFFSwabShort(v60);
    }
  }
  (*(void (**)(void, void, void))(v35 + 1224))(*(void *)(v35 + 1200), 0, 0);
  if ((*(uint64_t (**)(void, void *, void))(v35 + 1216))(*(void *)(v35 + 1200), __dst, *(unsigned __int16 *)(v35 + 872)) != *(unsigned __int16 *)(v35 + 872))
  {
    int v61 = "Error writing TIFF header";
LABEL_104:
    TIFFErrorExtR(v35, a1, v61, v43, v44, v45, v46, v47, v69);
    goto LABEL_105;
  }
  if (!TIFFDefaultDirectory(v35)) {
    goto LABEL_105;
  }
  *(void *)(v35 + 24) = 0;
  *(void *)(v35 + 40) = 0;
  *(_DWORD *)(v35 + 64) = 0;
  return v35;
}

uint64_t _tiffDummyMapProc()
{
  return 0;
}

uint64_t TIFFFileName(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t _cg_TIFFIsTiled(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 16) >> 10) & 1;
}

void IIO_Reader_TGA::createReadPlugin()
{
}

{
  operator new();
}

void sub_188800CDC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40D445A7BBLL);
  _Unwind_Resume(a1);
}

void sub_188800D7C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40D445A7BBLL);
  _Unwind_Resume(a1);
}

__n128 IIOImagePixelDataProvider::srcFormat@<Q0>(IIOImagePixelDataProvider *this@<X0>, uint64_t a2@<X8>)
{
  __n128 result = *(__n128 *)((char *)this + 40);
  long long v3 = *(_OWORD *)((char *)this + 56);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  *(void *)(a2 + 32) = *((void *)this + 9);
  return result;
}

unint64_t IIOImagePixelDataProvider::sourceBytesForCoordinates(IIOImagePixelDataProvider *this, CGPoint a2, CGPoint a3, double a4, double a5)
{
  if (a2.x <= 0.0 || a3.y <= a2.y)
  {
    unint64_t v6 = 0;
    double y = a2.y;
  }
  else
  {
    LODWORD(a5) = *((_DWORD *)this + 11);
    unint64_t v6 = (unint64_t)((double)*((unint64_t *)this + 16) + a2.x * (double)*(unint64_t *)&a5 * -0.125);
    double y = a2.y + 1.0;
    a2.CGFloat x = 0.0;
  }
  if (a3.y > a2.y) {
    v6 += *((void *)this + 16) * (unint64_t)(a3.y - y);
  }
  return v6 + ((*((unsigned int *)this + 11) * (unint64_t)(a3.x - a2.x)) >> 3);
}

uint64_t IIOImagePixelDataProvider::getBytesDataProviderRGB101010(IIOImagePixelDataProvider *this, void *a2, uint64_t a3)
{
  unint64_t v3 = (unint64_t)a3 / *((void *)this + 18);
  unint64_t v4 = *((void *)this + 16);
  if (!is_mul_ok(v3, v4)) {
    return 0;
  }
  uint64_t v5 = a3;
  unint64_t v8 = v3 * v4;
  long long v9 = (char *)malloc_type_malloc(v3 * v4, 0x30F0D996uLL);
  if (!v9) {
    return 0;
  }
  uint64_t v10 = v9;
  if (IIOImagePixelDataProvider::getBytesCGAccessSessionNoConvert(this, v9, v8) == v8
    && is_mul_ok(v3, *((void *)this + 18)))
  {
    CGColorSpaceRef ColorSpace = CGImageGetColorSpace(*((CGImageRef *)this + 2));
    if (CGColorSpaceContainsFlexGTCInfo())
    {
      uint64_t v12 = CGBitmapContextCreate(a2, *((void *)this + 3), *((void *)this + 4), *((unsigned int *)this + 20), *((void *)this + 18), ColorSpace, *((_DWORD *)this + 24));
      if (v12)
      {
        uint64_t v13 = v12;
        v23.size.vImagePixelCount width = (double)*((unint64_t *)this + 3);
        v23.size.vImagePixelCount height = (double)*((unint64_t *)this + 4);
        v23.origin.CGFloat x = 0.0;
        v23.origin.double y = 0.0;
        CGContextDrawImage(v12, v23, *((CGImageRef *)this + 2));
        CGContextFlush(v13);
        CGContextRelease(v13);
      }
    }
    else
    {
      src.CFDictionaryRef data = v10;
      src.vImagePixelCount height = v3;
      size_t v14 = *((void *)this + 16);
      src.vImagePixelCount width = *((void *)this + 3);
      src.rowuint64_t Bytes = v14;
      dest.CFDictionaryRef data = a2;
      dest.vImagePixelCount height = v3;
      size_t v15 = *((void *)this + 18);
      dest.vImagePixelCount width = src.width;
      dest.rowuint64_t Bytes = v15;
      *(_DWORD *)permuteMap = 197121;
      int v16 = *((_DWORD *)this + 20);
      if (v16 == 8)
      {
        int v18 = *((_DWORD *)this + 21);
        if (v18 == 24)
        {
          iioConvert_XRGB2101010ToRGB888(&src, 0xFFu, &dest, 0, 1023, permuteMap, 0);
        }
        else if (v18 == 32)
        {
          vImageConvert_XRGB2101010ToARGB8888(&src, 0xFFu, &dest, 0, 1023, permuteMap, 0);
        }
        else
        {
          LogError("getBytesDataProviderRGB101010", 1221, "*** %s: unhandled bpc: %d  bpp: %d\n");
        }
      }
      else if (v16 == 16)
      {
        int v17 = *((_DWORD *)this + 21);
        if (v17 == 64)
        {
          vImageConvert_XRGB2101010ToARGB16U(&src, 0xFFFFu, &dest, 0, 1023, permuteMap, 0);
        }
        else if (v17 == 48)
        {
          iio_convert_XRGB2101010ToRGB16U(&src, &dest, 0);
        }
        else
        {
          LogError("getBytesDataProviderRGB101010", 1206, "*** %s: unhandled bpc: %d  bpp: %d\n");
        }
      }
      else
      {
        LogError("getBytesDataProviderRGB101010", 1226, "*** %s: unhandled bpc: %d  bpp: %d\n");
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  free(v10);
  return v5;
}

unint64_t IIOImagePixelDataProvider::getBytesCGAccessSessionNoConvert(IIOImagePixelDataProvider *this, char *a2, unint64_t a3)
{
  if (*((void *)this + 31))
  {
    unint64_t v6 = *((void *)this + 19);
  }
  else
  {
    if (!CGImageGetDataProvider(*((CGImageRef *)this + 2))) {
      return 0;
    }
    uint64_t v13 = CGAccessSessionCreate();
    *((void *)this + 31) = v13;
    if (!v13) {
      return 0;
    }
    unint64_t v6 = 0;
    *((void *)this + 19) = 0;
  }
  uint64_t v7 = 0;
  if (a2)
  {
    unint64_t v8 = *((void *)this + 21);
    if (v8 > v6)
    {
      if (v6 + a3 > v8) {
        a3 = v8 - v6;
      }
      uint64_t BytesFromAccessSession = IIOImagePixelDataProvider::getBytesFromAccessSession(this, a2, a3);
      uint64_t v10 = *((void *)this + 20);
      unint64_t v11 = *((void *)this + 19) + BytesFromAccessSession;
      if (v11 >= *((void *)this + 21)) {
        unint64_t v11 = *((void *)this + 21);
      }
      *((void *)this + 19) = v11;
      if (BytesFromAccessSession != a3 || v11 == v10)
      {
        uint64_t v7 = BytesFromAccessSession;
        if (BytesFromAccessSession != a3) {
          _cg_jpeg_mem_term("getBytesCGAccessSessionNoConvert", 1380, "*** ERROR: 'getBytesFromAccessSession' - got %ld bytes, expected: %ld\n", BytesFromAccessSession, a3);
        }
        CGAccessSessionRelease();
        *((void *)this + 31) = 0;
      }
      else
      {
        return a3;
      }
    }
  }
  return v7;
}

uint64_t IIOImagePixelDataProvider::getBytesDataProviderCIF10(IIOImagePixelDataProvider *this, void *a2, uint64_t a3)
{
  vImagePixelCount v4 = (unint64_t)a3 / *((void *)this + 18);
  unint64_t v5 = *((void *)this + 16);
  if (is_mul_ok(v4, v5))
  {
    unint64_t v8 = (char *)malloc_type_malloc(v4 * v5, 0x25EBAF72uLL);
    if (v8)
    {
      long long v9 = v8;
      IIOImagePixelDataProvider::getBytesCGAccessSessionNoConvert(this, v8, *((void *)this + 16) * v4);
      unint64_t v10 = *((void *)this + 18);
      if (is_mul_ok(v4, v10) && (unint64_t v11 = malloc_type_malloc(v4 * v10, 0xE59A62F8uLL)) != 0)
      {
        uint64_t v12 = v11;
        if (*((_DWORD *)this + 20) == 16)
        {
          CFStringRef v13 = (const __CFString *)*MEMORY[0x1E4F1DBE8];
          CGColorSpaceRef v38 = (CGColorSpaceRef)&unk_1ED4DFD58;
          uint64_t v39 = CGColorSpaceCreateWithName(v13);
          *(void *)&v37.bitsPerComponent = 0x4000000010;
          v37.colorSpace = v39;
          v37.bitmapInfo = 4358;
          memset(&v37.version, 0, 20);
          CFStringRef v14 = (const __CFString *)*MEMORY[0x1E4F1DC98];
          CGColorSpaceRef v35 = (CGColorSpaceRef)&unk_1ED4DFD58;
          uint64_t v36 = CGColorSpaceCreateWithName(v14);
          CFStringRef v15 = (const __CFString *)*MEMORY[0x1E4F1DB90];
          CGColorSpaceRef v33 = (CGColorSpaceRef)&unk_1ED4DFD58;
          uint64_t v34 = CGColorSpaceCreateWithName(v15);
          *(void *)&v32.bitsPerComponent = 0x4000000010;
          v32.colorSpace = v34;
          v32.bitmapInfo = 4358;
          memset(&v32.version, 0, 20);
          CGColorSpaceRef v30 = (CGColorSpaceRef)&unk_1ED4DFD58;
          uint64_t v31 = CGColorSpaceCreateWithName(v15);
          v29[0] = 0;
          v29[1] = 0;
          IIOColorConverter::IIOColorConverter((IIOColorConverter *)v29, &v37, &v32, v36, v31);
          src.CFDictionaryRef data = v9;
          src.vImagePixelCount height = v4;
          size_t v16 = *((void *)this + 16);
          src.vImagePixelCount width = *((void *)this + 3);
          src.rowuint64_t Bytes = v16;
          dest.CFDictionaryRef data = v12;
          dest.vImagePixelCount height = v4;
          size_t v17 = *((void *)this + 18);
          dest.vImagePixelCount width = src.width;
          dest.rowuint64_t Bytes = v17;
          v26.CFDictionaryRef data = a2;
          v26.vImagePixelCount height = v4;
          v26.vImagePixelCount width = src.width;
          v26.rowuint64_t Bytes = v17;
          v25.CFDictionaryRef data = a2;
          v25.vImagePixelCount height = v4;
          v25.vImagePixelCount width = 4 * src.width;
          v25.rowuint64_t Bytes = v17;
          *(_DWORD *)permuteMap = 50462976;
          int32_t v18 = CIF10MIN();
          int32_t v19 = CIF10MAX();
          vImage_Error v20 = vImageConvert_XRGB2101010ToARGB16F(&src, 1.0, &dest, v18, v19, permuteMap, 0x810u);
          if (v20
            || (vImage_Error v20 = IIOColorConverter::colorConvert((IIOColorConverter *)v29, &dest, &v26)) != 0
            || (vImage_Error v20 = vImageConvert_16Fto16U(&v25, &v25, 0x10u)) != 0)
          {
            unsigned int v21 = IIO_vImageErrorString(v20);
            LogError("getBytesDataProviderCIF10", 1295, "*** ERROR: CIF10 to RGB16 failed: %d '%s'\n", v20, v21);
          }
          IIOColorConverter::~IIOColorConverter((IIOColorConverter *)v29);
          IIOColorSpace::~IIOColorSpace(&v30);
          IIOColorSpace::~IIOColorSpace(&v33);
          IIOColorSpace::~IIOColorSpace(&v35);
          IIOColorSpace::~IIOColorSpace(&v38);
        }
        free(v9);
        uint64_t v22 = (char *)v12;
      }
      else
      {
        uint64_t v22 = v9;
      }
      free(v22);
    }
  }
  return a3;
}

void sub_1888014CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,CGColorSpaceRef a31)
{
  IIOColorSpace::~IIOColorSpace(&a31);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)(v31 - 184));
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)(v31 - 168));
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)(v31 - 112));
  _Unwind_Resume(a1);
}

uint64_t IIOImagePixelDataProvider::getBytesFromAccessSession(IIOImagePixelDataProvider *this, char *a2, unint64_t a3)
{
  if (!a3) {
    return 0;
  }
  unint64_t v3 = a3;
  uint64_t v5 = 0;
  while (1)
  {
    uint64_t Bytes = CGAccessSessionGetBytes();
    if (Bytes - 1 >= v3) {
      break;
    }
    v5 += Bytes;
    a2 += Bytes;
    v3 -= Bytes;
    if (!v3) {
      return v5;
    }
  }
  if (Bytes) {
    _cg_jpeg_mem_term("getBytesFromAccessSession", 1333, "*** CGAccessSessionGetBytes returned unexpected amount of data.");
  }
  else {
    _cg_jpeg_mem_term("getBytesFromAccessSession", 1330, "*** CGAccessSessionGetBytes did not return any data.");
  }
  return v5;
}

vImagePixelCount IIOImagePixelDataProvider::getBytesCGAccessSessionConvert(CGImageRef *this, unsigned __int8 *a2, unint64_t a3)
{
  if (!this[31])
  {
    if (!CGImageGetDataProvider(this[2])) {
      return 0;
    }
    uint64_t v23 = CGAccessSessionCreate();
    this[31] = (CGImageRef)v23;
    if (!v23) {
      return 0;
    }
  }
  unint64_t v6 = 0;
  if (a2)
  {
    unint64_t v7 = (unint64_t)this[19];
    CGImageRef v8 = this[20];
    if ((unint64_t)v8 > v7)
    {
      if (v7 + a3 <= (unint64_t)v8) {
        unint64_t v6 = a3;
      }
      else {
        unint64_t v6 = (unint64_t)v8 - v7;
      }
      unint64_t v9 = (unint64_t)this[18];
      double v10 = (double)(8 * (v7 % v9) / *((unsigned int *)this + 21));
      double v11 = (double)(v7 / v9);
      double v12 = IIOImagePixelDataProvider::endingPointForByteCount((IIOImagePixelDataProvider *)this, v6);
      CGFloat v14 = v13;
      v25.CGFloat x = v10;
      v25.double y = v11;
      v27.CGFloat x = v12;
      v27.double y = v14;
      size_t v17 = IIOImagePixelDataProvider::sourceBytesForCoordinates((IIOImagePixelDataProvider *)this, v25, v27, v15, v16);
      unint64_t v18 = v17;
      int v19 = *((unsigned __int8 *)this + 256);
      vImage_Error v20 = (char *)a2;
      if (!*((unsigned char *)this + 256))
      {
        vImage_Error v20 = (char *)malloc_type_malloc(v17, 0x5CA38E5CuLL);
        if (!v20) {
          return 0;
        }
      }
      uint64_t BytesFromAccessSession = IIOImagePixelDataProvider::getBytesFromAccessSession((IIOImagePixelDataProvider *)this, v20, v18);
      if (BytesFromAccessSession == v18)
      {
        v26.CGFloat x = v10;
        v26.double y = v11;
        v28.CGFloat x = v12;
        v28.double y = v14;
        vImagePixelCount v22 = IIOImagePixelDataProvider::convertBytesWithRange((IIOImagePixelDataProvider *)this, (unsigned __int8 *)v20, a2, v26, v28, v6);
        if (!v19) {
          goto LABEL_16;
        }
      }
      else
      {
        _cg_jpeg_mem_term("getBytesCGAccessSessionConvert", 1446, "CGAccessSessionGetBytes did not return enough bytes. Got %zd, expected %zd.\n", BytesFromAccessSession, v18);
        vImagePixelCount v22 = 0;
        if (!v19) {
LABEL_16:
        }
          free(v20);
      }
      if (this[19] == this[20] || v22 != v6)
      {
        CGAccessSessionRelease();
        this[31] = 0;
        return v22;
      }
    }
  }
  return v6;
}

uint64_t IIOImagePixelDataProvider::rewind(IIOImagePixelDataProvider *this)
{
  *((void *)this + 19) = 0;
  uint64_t result = *((void *)this + 31);
  if (result) {
    return CGAccessSessionRewind();
  }
  return result;
}

CFStringRef _CGImagePixelDataProviderCopyFormattingDescription(const void *a1, const __CFDictionary *a2)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"CGImagePixelDataProvider (%p)", a1);
}

CFStringRef _CGImagePixelDataProviderCopyDescription(const void *a1)
{
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"CGImagePixelDataProvider (%p)", a1);
}

uint64_t TIFFFlush(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)(a1 + 12)) {
    return 1;
  }
  uint64_t result = TIFFFlushData(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!result) {
    return result;
  }
  int v17 = *(_DWORD *)(a1 + 16) & 0x200008;
  if (v17 != 0x200000) {
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 12) != 2) {
    goto LABEL_8;
  }
  if (!TIFFForceStrileArrayWriting(a1))
  {
    int v17 = *(_DWORD *)(a1 + 16) & 0x200008;
LABEL_7:
    if (v17)
    {
LABEL_8:
      uint64_t result = TIFFRewriteDirectory(a1, v10, v11, v12, v13, v14, v15, v16);
      if (!result) {
        return result;
      }
    }
  }
  return 1;
}

uint64_t TIFFFlushData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD *)(a1 + 16);
  if ((v8 & 0x40) == 0) {
    return 1;
  }
  if ((v8 & 0x1000) == 0
    || (*(_DWORD *)(a1 + 16) = v8 & 0xFFFFEFFF,
        uint64_t result = (*(uint64_t (**)(uint64_t))(a1 + 1000))(a1),
        result))
  {
    return TIFFFlushData1(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  return result;
}

uint64_t TIFFForceStrileArrayWriting(uint64_t a1)
{
  int v2 = _cg_TIFFIsTiled(a1);
  if (!*(_DWORD *)(a1 + 12))
  {
    uint64_t v12 = *(const char **)a1;
    uint64_t v13 = "File opened in read-only mode";
    goto LABEL_13;
  }
  if (!*(void *)(a1 + 24))
  {
    uint64_t v12 = "TIFFForceStrileArrayWriting";
    uint64_t v13 = "Directory has not yet been written";
    goto LABEL_13;
  }
  int v10 = *(_DWORD *)(a1 + 16);
  if ((v10 & 8) != 0)
  {
    uint64_t v12 = "TIFFForceStrileArrayWriting";
    uint64_t v13 = "Directory has changes other than the strile arrays. TIFFRewriteDirectory() should be called instead";
    goto LABEL_13;
  }
  int v11 = v2;
  if ((v10 & 0x200000) == 0)
  {
    if (*(_WORD *)(a1 + 256)
      && !*(void *)(a1 + 264)
      && !*(_WORD *)(a1 + 258)
      && !*(void *)(a1 + 272)
      && *(_WORD *)(a1 + 288)
      && !*(void *)(a1 + 296)
      && !*(_WORD *)(a1 + 290)
      && !*(void *)(a1 + 304))
    {
      if (!*(void *)(a1 + 232))
      {
        uint64_t result = TIFFSetupStrips(a1, v3, v4, v5, v6, v7, v8, v9);
        if (!result) {
          return result;
        }
      }
      goto LABEL_21;
    }
    uint64_t v12 = "TIFFForceStrileArrayWriting";
    uint64_t v13 = "Function not called together with TIFFDeferStrileArrayWriting()";
LABEL_13:
    TIFFErrorExtR(a1, v12, v13, v5, v6, v7, v8, v9, v17);
    return 0;
  }
LABEL_21:
  if (v11) {
    int v15 = 324;
  }
  else {
    int v15 = 273;
  }
  uint64_t result = _TIFFRewriteField(a1, v15, 0x10u, *(unsigned int *)(a1 + 228), *(const void **)(a1 + 232));
  if (result)
  {
    if (v11) {
      int v16 = 325;
    }
    else {
      int v16 = 279;
    }
    uint64_t result = _TIFFRewriteField(a1, v16, 0x10u, *(unsigned int *)(a1 + 228), *(const void **)(a1 + 240));
    if (result)
    {
      *(_DWORD *)(a1 + 16) &= 0xFFDFFFBF;
      return 1;
    }
  }
  return result;
}

void AdobeXMPCore_Int::IMetadataConverterUtils_I::convertXMPMetatoIMetadata(AdobeXMPCore_Int::IMetadataConverterUtils_I *this@<X0>, void *a2@<X8>)
{
}

void AdobeXMPCore_Int::MetadataConverterUtilsImpl::ConvertOldDOMtoNewDOM(AdobeXMPCore_Int::MetadataConverterUtilsImpl *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  AdobeXMPCore::IMetadata_v1::CreateMetadata(this);
}

void sub_188801C04(_Unwind_Exception *exception_object)
{
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v4 = *(std::__shared_weak_count **)(v1 + 8);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  _Unwind_Resume(exception_object);
}

void AdobeXMPCore_Int::IMetadataConverterUtils_I::convertIMetadatatoXMPMeta(void *a1, AdobeXMPCore::INode_v1 *a2)
{
  int v3 = 0;
  if (a1) {
    a1 = (void *)((char *)a1 + *(void *)(*a1 - 544));
  }
  AdobeXMPCore::INode_v1::MakeShared(a1, a2, &v2);
  AdobeXMPCore_Int::MetadataConverterUtilsImpl::ConvertNewDOMtoOldDOM();
}

void sub_188801CA0(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  __cxa_call_unexpected(a1);
}

void AdobeXMPCore_Int::MetadataConverterUtilsImpl::ConvertNewDOMtoOldDOM()
{
}

void sub_188801F68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::shared_ptr<AdobeXMPCore::INode_v1>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  return a1;
}

void AdobeXMPCore_Int::IMetadataConverterUtils_I::convertIMetadatatoXMPMeta(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v1 + 8), 1uLL, memory_order_relaxed);
  }
  AdobeXMPCore_Int::MetadataConverterUtilsImpl::ConvertNewDOMtoOldDOM();
}

void sub_188802094(void *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::shared_ptr<AdobeXMPCore::INode_v1>::~shared_ptr[abi:ne180100]((uint64_t)va);
  __cxa_call_unexpected(a1);
}

void AdobeXMPCore_Int::MetadataConverterUtilsImpl::CreateAndPopulateNode(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = 0;
  int v10 = 0;
  *(void *)uint64_t v8 = 0;
  XMP_Node::GetFullQualifiedName((XMP_Node *)a2, (const char **)&v10, &v8[1], (const char **)&v9, v8);
  unsigned int v4 = v8[0];
  unsigned int v3 = v8[1];
  if (!*(void *)v8)
  {
    uint64_t v9 = "arrayItem";
    int v10 = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
    unsigned int v3 = 43;
    unsigned int v4 = 9;
    v8[0] = 9;
    v8[1] = 43;
  }
  int v5 = *(_DWORD *)(a2 + 8);
  if ((v5 & 0x1F00) == 0)
  {
    if (*(char *)(a2 + 63) < 0)
    {
      uint64_t v6 = *(const char **)(a2 + 40);
      uint64_t v7 = *(const char **)(a2 + 48);
    }
    else
    {
      uint64_t v6 = (const char *)(a2 + 40);
      uint64_t v7 = (const char *)*(unsigned __int8 *)(a2 + 63);
    }
    AdobeXMPCore::ISimpleNode_v1::CreateSimpleNode((AdobeXMPCore::ISimpleNode_v1 *)v10, (const char *)v3, v9, (const char *)v4, v6, v7);
  }
  if ((v5 & 0x100) != 0) {
    AdobeXMPCore::IStructureNode_v1::CreateStructureNode((AdobeXMPCore::IStructureNode_v1 *)v10, (char *)v3, v9, (const char *)v4);
  }
  if ((v5 & 0x200) != 0) {
    AdobeXMPCore_Int::IUTF8String_I::CreateUTF8String((AdobeXMPCore_Int::IUTF8String_I *)v10, (const char *)v3);
  }
}

void sub_1888024D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, uint64_t a12, std::__shared_weak_count *a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, std::__shared_weak_count *a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  if (a13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a13);
  }
  if (a17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a17);
  }
  if (a19) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a19);
  }
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  _Unwind_Resume(exception_object);
}

void *std::shared_ptr<AdobeXMPCore::INode_v1>::operator=[abi:ne180100]<AdobeXMPCore::ISimpleNode_v1,void>(void *a1, uint64_t a2)
{
  unsigned int v3 = *(void **)a2;
  if (*(void *)a2) {
    unsigned int v3 = (void *)((char *)v3 + *(void *)(*v3 - 544));
  }
  uint64_t v4 = *(void *)(a2 + 8);
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  int v5 = (std::__shared_weak_count *)a1[1];
  *a1 = v3;
  a1[1] = v4;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return a1;
}

void AdobeXMPCore_Int::MetadataConverterUtilsImpl::CreateQualifiedName()
{
}

void sub_188802DE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,uint64_t a27)
{
  int v29 = *(std::__shared_weak_count **)(v27 - 152);
  if (v29) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v29);
  }
  CGColorSpaceRef v30 = *(std::__shared_weak_count **)(v27 - 136);
  if (v30) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v30);
  }
  uint64_t v31 = *(std::__shared_weak_count **)(v27 - 120);
  if (v31) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v31);
  }
  vImage_CGImageFormat v32 = *(std::__shared_weak_count **)(v27 - 104);
  if (v32) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v32);
  }
  _Unwind_Resume(exception_object);
}

void AdobeXMPCore_Int::MakeUncheckedSharedPointer<AdobeXMPCore_Int::INameSpacePrefixMap_I>(char *a1@<X0>, int a2@<W3>, void *a3@<X8>)
{
  if (a1 || !a2)
  {
    (**(void (***)(char *))&a1[*(void *)(*(void *)a1 - 56)])(&a1[*(void *)(*(void *)a1 - 56)]);
    std::shared_ptr<AdobeXMPCore_Int::INameSpacePrefixMap_I>::shared_ptr[abi:ne180100]<AdobeXMPCore_Int::INameSpacePrefixMap_I,std::__mem_fn<void (AdobeXMPCommon::ISharedObject::*)(void)const>,void>(a3, (uint64_t)a1);
  }
  AdobeXMPCore_Int::IError_I::CreateError(1, 6, 2);
}

void sub_188803048(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA498] + 64;
  *(void *)(a1 + 112) = MEMORY[0x1E4FBA498] + 64;
  uint64_t v3 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v3;
  int v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v5, (void *)(a1 + 8));
  uint64_t v6 = MEMORY[0x1E4FBA498] + 24;
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  *(void *)a1 = v6;
  *(void *)(a1 + 112) = v2;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1888031D0(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x18C11C080](v1);
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA418];
  uint64_t v3 = *MEMORY[0x1E4FBA418];
  *(void *)a1 = *MEMORY[0x1E4FBA418];
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  if (*(char *)(a1 + 95) < 0) {
    operator delete(*(void **)(a1 + 72));
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x18C11C080](a1 + 112);
  return a1;
}

void AdobeXMPCore_Int::MetadataConverterUtilsImpl::AddQualifierNode()
{
  uint64_t v0 = 0;
  uint64_t v1 = 0;
  AdobeXMPCore_Int::MetadataConverterUtilsImpl::CreateQualifiedName();
}

void sub_188803984(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<XMP_Node *>::insert(uint64_t a1, char *__src, char *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = __src;
  uint64_t v6 = *(char **)(a1 + 8);
  uint64_t v8 = a1 + 16;
  unint64_t v7 = *(void *)(a1 + 16);
  if ((unint64_t)v6 >= v7)
  {
    uint64_t v13 = *(char **)a1;
    unint64_t v14 = ((uint64_t)&v6[-*(void *)a1] >> 3) + 1;
    if (v14 >> 61) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = __src - v13;
    uint64_t v16 = (__src - v13) >> 3;
    uint64_t v17 = v7 - (void)v13;
    if (v17 >> 2 > v14) {
      unint64_t v14 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v14;
    }
    uint64_t v30 = a1 + 16;
    if (v18) {
      int v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(a1 + 16, v18);
    }
    else {
      int v19 = 0;
    }
    vImage_Error v20 = &v19[8 * v16];
    __p = v19;
    uint64_t v27 = v20;
    CGPoint v28 = v20;
    int v29 = &v19[8 * v18];
    if (v16 == v18)
    {
      if (v15 < 1)
      {
        if (v13 == v4) {
          unint64_t v22 = 1;
        }
        else {
          unint64_t v22 = v15 >> 2;
        }
        uint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOTag *>>(v8, v22);
        vImage_Error v20 = &v23[8 * (v22 >> 2)];
        __p = v23;
        uint64_t v27 = v20;
        int v29 = &v23[8 * v24];
        if (v19) {
          operator delete(v19);
        }
      }
      else
      {
        unint64_t v21 = v16 + 2;
        if (v16 >= -1) {
          unint64_t v21 = v16 + 1;
        }
        v20 -= 8 * (v21 >> 1);
        uint64_t v27 = v20;
      }
    }
    *(void *)vImage_Error v20 = *(void *)v3;
    CGPoint v28 = v20 + 8;
    uint64_t v4 = std::vector<_APPx *>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v28 != v27) {
      v28 += (v27 - v28 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
  }
  else if (__src == v6)
  {
    *(void *)__vImage_Buffer src = *(void *)a3;
    *(void *)(a1 + 8) = __src + 8;
  }
  else
  {
    uint64_t v9 = __src + 8;
    int v10 = v6 - 8;
    int v11 = *(void **)(a1 + 8);
    while (v10 < v6)
    {
      uint64_t v12 = *(void *)v10;
      v10 += 8;
      *v11++ = v12;
    }
    *(void *)(a1 + 8) = v11;
    if (v6 != v9) {
      memmove(&v6[-8 * ((v6 - v9) >> 3)], __src, v6 - v9);
    }
    if (v4 <= v3) {
      v3 += 8 * (*(void *)(a1 + 8) > (unint64_t)v3);
    }
    *(void *)uint64_t v4 = *(void *)v3;
  }
  return v4;
}

void sub_188803C18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL AdobeXMPCore_Int::MetadataConverterUtilsImpl::FindPrefixFromUserSuppliedMap(AdobeXMPCore_Int::MetadataConverterUtilsImpl *this, void *a2, char *a3, const char **a4, unsigned int *a5)
{
  if (!this) {
    return 0;
  }
  uint64_t v9 = 0;
  int v10 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)this + 88))(&v9);
  uint64_t v7 = v9;
  if (v9)
  {
    *(void *)a3 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 192))(v9);
    *(_DWORD *)a4 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 208))(v9);
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  return v7 != 0;
}

void AdobeXMPCore_Int::MetadataConverterUtilsImpl::AddChildNode(uint64_t a1, uint64_t a2)
{
  (*(void (**)(void))(**(void **)a2 + 160))();
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  AdobeXMPCore_Int::MetadataConverterUtilsImpl::CreateQualifiedName();
}

void sub_1888041B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  uint64_t v23 = *(std::__shared_weak_count **)(v21 - 72);
  if (v23) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v23);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AdobeXMPCore_Int::MetadataConverterUtilsImpl::HandleStructureNode(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  if (!a5) {
    goto LABEL_10;
  }
  long long v23 = 0uLL;
  (*(void (**)(long long *__return_ptr))(*(void *)(*a1 + *(void *)(*(void *)*a1 - 544)) + 256))(&v23);
  uint64_t v11 = v23;
  if ((void)v23)
  {
    (*(void (**)(uint64_t *__return_ptr, void))(*(void *)v23 + 736))(&v21, v23);
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 192))(v21);
    MEMORY[0x18C11BE10](a2 + 16, v12);
    if (v22) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v22);
    }
  }
  if (*((void *)&v23 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v23 + 1));
  }
  if (!v11)
  {
LABEL_10:
    if (a6)
    {
      uint64_t v13 = (void *)*a1;
      if (*a1) {
        uint64_t v13 = (void *)((char *)v13 + *(void *)(*v13 - 544));
      }
      uint64_t v14 = a1[1];
      *(void *)&long long v23 = v13;
      *((void *)&v23 + 1) = v14;
      if (v14) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v14 + 8), 1uLL, memory_order_relaxed);
      }
      AdobeXMPCore_Int::MetadataConverterUtilsImpl::AddQualifierNode();
    }
    uint64_t v15 = (void *)*a1;
    if (*a1) {
      uint64_t v15 = (void *)((char *)v15 + *(void *)(*v15 - 544));
    }
    uint64_t v16 = a1[1];
    *(void *)&long long v23 = v15;
    *((void *)&v23 + 1) = v16;
    if (v16) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
    }
    AdobeXMPCore_Int::MetadataConverterUtilsImpl::AddChildNode(a2, (uint64_t)&v23);
  }
  if (a2)
  {
    *(_DWORD *)(a2 + 8) |= 0x100u;
    long long v23 = 0uLL;
    (*(void (**)(long long *__return_ptr))(*(void *)(*a1 + *(void *)(*(void *)*a1 - 688)) + 552))(&v23);
    while ((void)v23)
    {
      uint64_t v21 = 0;
      unint64_t v22 = 0;
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v23 + 48))(&v21);
      AdobeXMPCore_Int::MetadataConverterUtilsImpl::HandleNode(&v21, a2, a3, a4, 1, 0);
      (*(void (**)(long long *__return_ptr))(*(void *)v23 + 56))(&v20);
      long long v17 = v20;
      long long v20 = 0uLL;
      unint64_t v18 = (std::__shared_weak_count *)*((void *)&v23 + 1);
      long long v23 = v17;
      if (v18)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v18);
        if (*((void *)&v20 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v20 + 1));
        }
      }
      if (v22) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v22);
      }
    }
    if (*((void *)&v23 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v23 + 1));
    }
  }
  return a2;
}

void sub_1888045AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void AdobeXMPCore_Int::MetadataConverterUtilsImpl::HandleNode(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v7 = *a1;
  if (v7)
  {
    int v13 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 40))(v7);
    switch(v13)
    {
      case 4:
        (*(void (**)(long long *__return_ptr))(*(void *)*a1 + 240))(&v21);
        uint64_t v14 = AdobeXMPCore_Int::MetadataConverterUtilsImpl::HandleStructureNode(&v21, a2, a3, a4, a5, a6);
        if (*((void *)&v21 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v21 + 1));
        }
        break;
      case 2:
        (*(void (**)(long long *__return_ptr))(*(void *)*a1 + 248))(&v21);
        AdobeXMPCore_Int::MetadataConverterUtilsImpl::HandleArrayNode((uint64_t)&v21, a2, a3, a4, a5, a6);
      case 1:
        (*(void (**)(long long *__return_ptr))(*(void *)*a1 + 232))(&v21);
        AdobeXMPCore_Int::MetadataConverterUtilsImpl::HandleSimpleNode((uint64_t *)&v21, a2, a3, a4, a5, a6);
      default:
        uint64_t v14 = 0;
        break;
    }
    if ((*(unsigned int (**)(void))(*(void *)*a1 + 184))()) {
      BOOL v15 = v14 == 0;
    }
    else {
      BOOL v15 = 1;
    }
    if (!v15)
    {
      long long v21 = 0uLL;
      (*(void (**)(long long *__return_ptr))(*(void *)*a1 + 112))(&v21);
      while ((void)v21)
      {
        uint64_t v19 = 0;
        long long v20 = 0;
        (*(void (**)(uint64_t *__return_ptr))(*(void *)v21 + 48))(&v19);
        AdobeXMPCore_Int::MetadataConverterUtilsImpl::HandleNode(&v19, v14, a3, a4, 0, 1);
        (*(void (**)(long long *__return_ptr))(*(void *)v21 + 56))(&v18);
        long long v16 = v18;
        long long v18 = 0uLL;
        long long v17 = (std::__shared_weak_count *)*((void *)&v21 + 1);
        long long v21 = v16;
        if (v17)
        {
          std::__shared_weak_count::__release_shared[abi:ne180100](v17);
          if (*((void *)&v18 + 1)) {
            std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v18 + 1));
          }
        }
        if (v20) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v20);
        }
      }
      if (*((void *)&v21 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v21 + 1));
      }
    }
  }
}

void sub_1888048AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  _Unwind_Resume(exception_object);
}

void AdobeXMPCore_Int::MetadataConverterUtilsImpl::HandleArrayNode(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  if (a6)
  {
    uint64_t v6 = *(void **)a1;
    if (*(void *)a1) {
      uint64_t v6 = (void *)((char *)v6 + *(void *)(*v6 - 544));
    }
    uint64_t v7 = *(void *)(a1 + 8);
    int v10 = v6;
    uint64_t v11 = v7;
    if (v7) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v7 + 8), 1uLL, memory_order_relaxed);
    }
    AdobeXMPCore_Int::MetadataConverterUtilsImpl::AddQualifierNode();
  }
  uint64_t v8 = *(void **)a1;
  if (*(void *)a1) {
    uint64_t v8 = (void *)((char *)v8 + *(void *)(*v8 - 544));
  }
  uint64_t v9 = *(void *)(a1 + 8);
  int v10 = v8;
  uint64_t v11 = v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  AdobeXMPCore_Int::MetadataConverterUtilsImpl::AddChildNode(a2, (uint64_t)&v10);
}

void sub_188804B78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  _Unwind_Resume(exception_object);
}

void AdobeXMPCore_Int::MetadataConverterUtilsImpl::HandleSimpleNode(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  if (a6)
  {
    uint64_t v8 = *a1;
    if (*a1) {
      uint64_t v9 = v8 + *(void *)(*(void *)v8 - 544);
    }
    else {
      uint64_t v9 = 0;
    }
    uint64_t v12 = a1[1];
    uint64_t v15 = v9;
    uint64_t v16 = v12;
    if (v12)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
      uint64_t v8 = *a1;
    }
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v8 + 504))(&v14);
    (*(void (**)(uint64_t))(*(void *)v14 + 192))(v14);
    AdobeXMPCore_Int::MetadataConverterUtilsImpl::AddQualifierNode();
  }
  uint64_t v10 = *a1;
  if (*a1) {
    uint64_t v11 = v10 + *(void *)(*(void *)v10 - 544);
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v13 = a1[1];
  uint64_t v15 = v11;
  uint64_t v16 = v13;
  if (v13)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
    uint64_t v10 = *a1;
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)v10 + 504))(&v14);
  (*(void (**)(uint64_t))(*(void *)v14 + 192))(v14);
  AdobeXMPCore_Int::MetadataConverterUtilsImpl::AddChildNode(a2, (uint64_t)&v15);
}

void sub_188804DE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::shared_ptr<AdobeXMPCore_Int::IError_I>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  return a1;
}

void std::shared_ptr<AdobeXMPCore_Int::INameSpacePrefixMap_I>::shared_ptr[abi:ne180100]<AdobeXMPCore_Int::INameSpacePrefixMap_I,std::__mem_fn<void (AdobeXMPCommon::ISharedObject::*)(void)const>,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_188804EC4(void *a1)
{
  __cxa_begin_catch(a1);
  uint64_t v4 = (void *)((char *)v3 + *(void *)(*v3 - 56) + (v2 >> 1));
  if (v2) {
    uint64_t v1 = *(void (**)(void *))(*v4 + v1);
  }
  v1(v4);
  __cxa_rethrow();
}

void sub_188804F28(_Unwind_Exception *a1)
{
}

uint64_t std::__mem_fn<void (AdobeXMPCommon::ISharedObject::*)(void)const>::operator()[abi:ne180100]<AdobeXMPCore_Int::INameSpacePrefixMap_I *&>(uint64_t a1, void *a2)
{
  uint64_t v2 = *a2 + *(void *)(*(void *)*a2 - 56);
  uint64_t v3 = *(uint64_t (**)(void *))a1;
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = (void *)(v2 + (v4 >> 1));
  if (v4) {
    return (*(uint64_t (**)(void))(*v5 + v3))();
  }
  else {
    return v3(v5);
  }
}

void std::__shared_ptr_pointer<AdobeXMPCore_Int::INameSpacePrefixMap_I *,std::__mem_fn<void (AdobeXMPCommon::ISharedObject::*)(void)const>,std::allocator<AdobeXMPCore_Int::INameSpacePrefixMap_I>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18C11C0E0);
}

uint64_t std::__shared_ptr_pointer<AdobeXMPCore_Int::INameSpacePrefixMap_I *,std::__mem_fn<void (AdobeXMPCommon::ISharedObject::*)(void)const>,std::allocator<AdobeXMPCore_Int::INameSpacePrefixMap_I>>::__on_zero_shared(uint64_t a1)
{
  return std::__mem_fn<void (AdobeXMPCommon::ISharedObject::*)(void)const>::operator()[abi:ne180100]<AdobeXMPCore_Int::INameSpacePrefixMap_I *&>(a1 + 32, (void *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<AdobeXMPCore_Int::INameSpacePrefixMap_I *,std::__mem_fn<void (AdobeXMPCommon::ISharedObject::*)(void)const>,std::allocator<AdobeXMPCore_Int::INameSpacePrefixMap_I>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 32;
  }
  else
  {
    return 0;
  }
}

void XMPUtils::SetNode(void *a1, char *a2, int a3)
{
  uint64_t v4 = *a1;
  if (!v4) {
    return;
  }
  __int16 v5 = a3;
  if ((a3 & 0x20000000) != 0)
  {
    __int16 v5 = a3;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 224))(v4, 1, 1);
  }
  if (!a2)
  {
    int v12 = (*(uint64_t (**)(void))(*(void *)*a1 + 40))();
    if ((v5 & 0x200) == 0 || v12 != 4)
    {
      int v13 = (*(uint64_t (**)(void))(*(void *)*a1 + 40))();
      if ((v5 & 0x100) == 0 || v13 != 2)
      {
        uint64_t v14 = *(void (**)(void))(*(void *)*a1 + 224);
        v14();
        return;
      }
    }
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    long long v18 = "Requested and existing composite form mismatch";
LABEL_48:
    exception[1] = v18;
    *((unsigned char *)exception + 16) = 0;
  }
  if ((v5 & 0x1F00) != 0)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    long long v18 = "Composite nodes can't have values";
    goto LABEL_48;
  }
  if (!*a1) {
    return;
  }
  if ((*(unsigned int (**)(void))(*(void *)*a1 + 40))(*a1) != 1) {
    XMPUtils::SetNode();
  }
  uint64_t v25 = 0;
  CGPoint v26 = 0;
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 232))(&v25);
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v24 = 0;
  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  if (v24 >= 0) {
    uint64_t v7 = (char *)__p;
  }
  else {
    uint64_t v7 = (char *)__p[0];
  }
  unsigned int v8 = *v7;
  if (!*v7) {
    goto LABEL_23;
  }
  while ((char)v8 < 1)
  {
LABEL_21:
    v19[0] = 0;
    unint64_t v21 = 0;
    CodePoint_from_UTF8(v7, 4uLL, v19, &v21);
    if (v19[0] >> 1 == 0x7FFF)
    {
      uint64_t v16 = __cxa_allocate_exception(0x18uLL);
      *(_DWORD *)uint64_t v16 = 205;
      v16[1] = "U+FFFE and U+FFFF are not allowed in XML";
      *((unsigned char *)v16 + 16) = 0;
    }
    v7 += v21;
    unsigned int v8 = *v7;
    if (!*v7) {
      goto LABEL_23;
    }
  }
  do
  {
    if (v8 > 0x1F)
    {
      if (v8 != 127) {
        goto LABEL_19;
      }
LABEL_15:
      *uint64_t v7 = 32;
      goto LABEL_19;
    }
    if (v8 > 0xD || ((1 << v8) & 0x2600) == 0) {
      goto LABEL_15;
    }
LABEL_19:
    int v9 = *++v7;
    unsigned int v8 = v9;
  }
  while (v9 > 0);
  if (v8) {
    goto LABEL_21;
  }
LABEL_23:
  if ((v5 & 0x20) != 0)
  {
    (*(void (**)(unint64_t *__return_ptr))(*(void *)*a1 + 88))(&v21);
    uint64_t v10 = (const char *)(*(uint64_t (**)(unint64_t))(*(void *)v21 + 192))(v21);
    if (!strcmp(v10, "http://www.w3.org/XML/1998/namespace"))
    {
      (*(void (**)(unsigned int *__return_ptr))(*(void *)*a1 + 72))(v19);
      uint64_t v15 = (const char *)(*(uint64_t (**)(void))(**(void **)v19 + 192))(*(void *)v19);
      BOOL v11 = strcmp(v15, "lang") == 0;
      if (v20) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v20);
      }
    }
    else
    {
      BOOL v11 = 0;
    }
    if (v22) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v22);
    }
    if (v11) {
      NormalizeLangValue((unsigned __int8 *)__p);
    }
  }
  (*(void (**)(void))(*(void *)v25 + 512))();
  if (SHIBYTE(v24) < 0) {
    operator delete(__p[0]);
  }
  if (v26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v26);
  }
}

void sub_1888054A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::__shared_weak_count *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,std::__shared_weak_count *a21)
{
  if (a13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a13);
  }
  if (a19 < 0) {
    operator delete(__p);
  }
  if (a21) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a21);
  }
  _Unwind_Resume(exception_object);
}

uint64_t XMPUtils::ConvertNewArrayFormToOldArrayForm(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result)
  {
    if ((*(unsigned int (**)(uint64_t))(*(void *)result + 640))(result) == 4)
    {
      return 2048;
    }
    else if ((*(unsigned int (**)(uint64_t))(*(void *)*a1 + 640))(*a1) == 2)
    {
      return 1024;
    }
    else
    {
      return ((*(unsigned int (**)(uint64_t))(*(void *)*a1 + 640))(*a1) == 1) << 9;
    }
  }
  return result;
}

void XMPUtils::CreateArrayChildNode(uint64_t a1@<X0>, const char *a2@<X1>, void *a3@<X8>)
{
  int v42 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)(*(void *)a1 + *(void *)(**(void **)a1 - 544)) + 88))(&__p);
  uint64_t v6 = (char *)(*(uint64_t (**)(void *))(*(void *)__p + 192))(__p);
  std::string::basic_string[abi:ne180100]<0>(&v42, v6);
  if (v40) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v40);
  }
  __p = 0;
  uint64_t v40 = 0;
  uint64_t v41 = 0;
  (*(void (**)(long long *__return_ptr))(*(void *)(*(void *)a1 + *(void *)(**(void **)a1 - 544))
                                                 + 72))(&v38);
  uint64_t v7 = (char *)(*(uint64_t (**)(void))(*(void *)v38 + 192))(v38);
  std::string::basic_string[abi:ne180100]<0>(&__p, v7);
  if (*((void *)&v38 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v38 + 1));
  }
  *a3 = 0;
  a3[1] = 0;
  if (!(*(uint64_t (**)(void))(*(void *)(*(void *)a1 + *(void *)(**(void **)a1 - 688)) + 560))())
  {
    if (v44 >= 0) {
      long long v23 = (AdobeXMPCore::ISimpleNode_v1 *)&v42;
    }
    else {
      long long v23 = (AdobeXMPCore::ISimpleNode_v1 *)v42;
    }
    if (v41 >= 0) {
      p_p = (const char *)&__p;
    }
    else {
      p_p = (const char *)__p;
    }
    XMPUtils::CreateTerminalNode(v23, p_p, a2, &v38);
    long long v25 = v38;
    long long v38 = 0uLL;
    CGPoint v26 = (std::__shared_weak_count *)a3[1];
    *(_OWORD *)a3 = v25;
    if (v26)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v26);
      uint64_t v27 = (std::__shared_weak_count *)*((void *)&v38 + 1);
      if (*((void *)&v38 + 1)) {
        goto LABEL_101;
      }
    }
    goto LABEL_102;
  }
  (*(void (**)(long long *__return_ptr))(**(void **)a1 + 656))(&v38);
  long long v8 = v38;
  if (!(void)v38 || (*(unsigned int (**)(void))(*(void *)v38 + 40))(v38) != 2)
  {
    unsigned int v10 = 0;
    if (((unsigned __int16)a2 & 0x100) == 0) {
      goto LABEL_29;
    }
    goto LABEL_15;
  }
  (*(void (**)(long long *__return_ptr, void))(*(void *)v8 + 248))(&v37, v8);
  int v9 = (std::__shared_weak_count *)*((void *)&v37 + 1);
  long long v38 = v37;
  long long v37 = 0uLL;
  unsigned int v10 = XMPUtils::ConvertNewArrayFormToOldArrayForm((uint64_t *)&v38);
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  if (*((void *)&v37 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v37 + 1));
  }
  if (((unsigned __int16)a2 & 0x100) != 0)
  {
LABEL_15:
    if ((*(unsigned int (**)(void))(*(void *)v8 + 40))(v8) == 4)
    {
      if (v44 >= 0) {
        BOOL v11 = (AdobeXMPCore::IStructureNode_v1 *)&v42;
      }
      else {
        BOOL v11 = (AdobeXMPCore::IStructureNode_v1 *)v42;
      }
      if (v44 >= 0) {
        int v12 = (char *)HIBYTE(v44);
      }
      else {
        int v12 = v43;
      }
      if (v41 >= 0) {
        int v13 = (const char *)&__p;
      }
      else {
        int v13 = (const char *)__p;
      }
      if (v41 >= 0) {
        uint64_t v14 = (const char *)HIBYTE(v41);
      }
      else {
        uint64_t v14 = (const char *)v40;
      }
      AdobeXMPCore::IStructureNode_v1::CreateStructureNode(v11, v12, v13, v14);
    }
  }
LABEL_29:
  if (((unsigned __int16)a2 & 0x1F00) == 0 && (*(unsigned int (**)(void))(*(void *)v8 + 40))(v8) == 1)
  {
    if (v44 >= 0) {
      uint64_t v15 = (AdobeXMPCore::ISimpleNode_v1 *)&v42;
    }
    else {
      uint64_t v15 = (AdobeXMPCore::ISimpleNode_v1 *)v42;
    }
    if (v44 >= 0) {
      uint64_t v16 = (char *)HIBYTE(v44);
    }
    else {
      uint64_t v16 = v43;
    }
    if (v41 >= 0) {
      long long v17 = (const char *)&__p;
    }
    else {
      long long v17 = (const char *)__p;
    }
    if (v41 >= 0) {
      long long v18 = (const char *)HIBYTE(v41);
    }
    else {
      long long v18 = (const char *)v40;
    }
    AdobeXMPCore::ISimpleNode_v1::CreateSimpleNode(v15, v16, v17, v18, "", 0);
  }
  if (((unsigned __int16)a2 & 0x800) != 0 && v10 >= 0x800)
  {
    if (v44 >= 0) {
      uint64_t v19 = (AdobeXMPCore::IArrayNode_v1 *)&v42;
    }
    else {
      uint64_t v19 = (AdobeXMPCore::IArrayNode_v1 *)v42;
    }
    if (v44 >= 0) {
      long long v20 = (char *)HIBYTE(v44);
    }
    else {
      long long v20 = v43;
    }
    if (v41 >= 0) {
      unint64_t v21 = &__p;
    }
    else {
      unint64_t v21 = __p;
    }
    if (v41 >= 0) {
      unint64_t v22 = (const char *)HIBYTE(v41);
    }
    else {
      unint64_t v22 = (const char *)v40;
    }
    AdobeXMPCore::IArrayNode_v1::CreateAlternativeArrayNode(v19, v20, (unint64_t)v21, v22);
  }
  if (((unsigned __int16)a2 & 0x400) != 0 && (v10 & 0x400) != 0)
  {
    if (v44 >= 0) {
      CGPoint v28 = (AdobeXMPCore::IArrayNode_v1 *)&v42;
    }
    else {
      CGPoint v28 = (AdobeXMPCore::IArrayNode_v1 *)v42;
    }
    if (v44 >= 0) {
      int v29 = (char *)HIBYTE(v44);
    }
    else {
      int v29 = v43;
    }
    if (v41 >= 0) {
      uint64_t v30 = &__p;
    }
    else {
      uint64_t v30 = __p;
    }
    if (v41 >= 0) {
      uint64_t v31 = (const char *)HIBYTE(v41);
    }
    else {
      uint64_t v31 = (const char *)v40;
    }
    AdobeXMPCore::IArrayNode_v1::CreateOrderedArrayNode(v28, v29, (unint64_t)v30, v31);
  }
  if (((unsigned __int16)a2 & 0x200) != 0 && (v10 & 0x200) != 0)
  {
    if (v44 >= 0) {
      vImage_CGImageFormat v32 = (AdobeXMPCore::IArrayNode_v1 *)&v42;
    }
    else {
      vImage_CGImageFormat v32 = (AdobeXMPCore::IArrayNode_v1 *)v42;
    }
    if (v44 >= 0) {
      CGColorSpaceRef v33 = (char *)HIBYTE(v44);
    }
    else {
      CGColorSpaceRef v33 = v43;
    }
    if (v41 >= 0) {
      uint64_t v34 = &__p;
    }
    else {
      uint64_t v34 = __p;
    }
    if (v41 >= 0) {
      CGColorSpaceRef v35 = (const char *)HIBYTE(v41);
    }
    else {
      CGColorSpaceRef v35 = (const char *)v40;
    }
    AdobeXMPCore::IArrayNode_v1::CreateUnorderedArrayNode(v32, v33, (unint64_t)v34, v35);
  }
  if (!*a3)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    exception[1] = "Array has to be homogeneous";
    *((unsigned char *)exception + 16) = 0;
  }
  if (*((void *)&v8 + 1))
  {
    uint64_t v27 = (std::__shared_weak_count *)*((void *)&v8 + 1);
LABEL_101:
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  }
LABEL_102:
  if (SHIBYTE(v41) < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v44) < 0) {
    operator delete(v42);
  }
}

void sub_188805B40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (v25) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v25);
  }
  uint64_t v27 = *(std::__shared_weak_count **)(v24 + 8);
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

AdobeXMPCore::ISimpleNode_v1 *XMPUtils::CreateTerminalNode@<X0>(AdobeXMPCore::ISimpleNode_v1 *this@<X0>, const char *a2@<X1>, const char *a3@<X2>, void *a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  if (((unsigned __int16)a3 & 0x1F00) == 0) {
    AdobeXMPCore::ISimpleNode_v1::CreateSimpleNode(this, (const char *)0xFFFFFFFFFFFFFFFFLL, a2, (const char *)0xFFFFFFFFFFFFFFFFLL, 0, 0);
  }
  if (((unsigned __int16)a3 & 0x100) != 0) {
    AdobeXMPCore::IStructureNode_v1::CreateStructureNode(this, (char *)0xFFFFFFFFFFFFFFFFLL, a2, (const char *)0xFFFFFFFFFFFFFFFFLL);
  }
  if (((unsigned __int16)a3 & 0x200) != 0)
  {
    if (((unsigned __int16)a3 & 0x800) == 0)
    {
      if (((unsigned __int16)a3 & 0x400) == 0) {
        AdobeXMPCore::IArrayNode_v1::CreateUnorderedArrayNode(this, (char *)0xFFFFFFFFFFFFFFFFLL, (unint64_t)a2, (const char *)0xFFFFFFFFFFFFFFFFLL);
      }
      AdobeXMPCore::IArrayNode_v1::CreateOrderedArrayNode(this, (char *)0xFFFFFFFFFFFFFFFFLL, (unint64_t)a2, (const char *)0xFFFFFFFFFFFFFFFFLL);
    }
    AdobeXMPCore::IArrayNode_v1::CreateAlternativeArrayNode(this, (char *)0xFFFFFFFFFFFFFFFFLL, (unint64_t)a2, (const char *)0xFFFFFFFFFFFFFFFFLL);
  }
  return this;
}

void sub_188805D28(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::shared_ptr<AdobeXMPCore::INode_v1>::operator=[abi:ne180100]<AdobeXMPCore::IStructureNode_v1,void>(void *a1, uint64_t a2)
{
  uint64_t v3 = *(void **)a2;
  if (*(void *)a2) {
    uint64_t v3 = (void *)((char *)v3 + *(void *)(*v3 - 544));
  }
  uint64_t v4 = *(void *)(a2 + 8);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  __int16 v5 = (std::__shared_weak_count *)a1[1];
  *a1 = v3;
  a1[1] = v4;
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  return a1;
}

void XMPUtils::DoSetArrayItem(void *a1, int a2, char *a3, int a4)
{
  uint64_t v8 = *a1 + *(void *)(*(void *)*a1 - 688);
  int v9 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 560))(v8);
  v35[0] = 0;
  v35[1] = 0;
  uint64_t v36 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)(*a1 + *(void *)(*(void *)*a1 - 544)) + 88))(&__p);
  unsigned int v10 = (char *)(*(uint64_t (**)(void *))(*(void *)__p + 192))(__p);
  std::string::basic_string[abi:ne180100]<0>(v35, v10);
  if (v33) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v33);
  }
  __p = 0;
  CGColorSpaceRef v33 = 0;
  uint64_t v34 = 0;
  (*(void (**)(long long *__return_ptr))(*(void *)(*a1 + *(void *)(*(void *)*a1 - 544)) + 72))(&v31);
  BOOL v11 = (char *)(*(uint64_t (**)(void))(*(void *)v31 + 192))(v31);
  std::string::basic_string[abi:ne180100]<0>(&__p, v11);
  if (*((void *)&v31 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v31 + 1));
  }
  int v12 = (const char *)VerifySetOptions(a4 & 0xFFFF3FFF, a3);
  int v13 = a4 & 0xC000;
  if (a2 == -1) {
    int v14 = v9;
  }
  else {
    int v14 = a2;
  }
  if (v13 == 0x8000 && v14 == 0)
  {
    int v14 = 1;
    int v13 = 0x4000;
  }
  int v15 = v14 + (v14 == v9 && v13 == 0x8000);
  if (v14 == v9 && v13 == 0x8000) {
    unsigned int v16 = 0;
  }
  else {
    unsigned int v16 = v13;
  }
  long long v31 = 0uLL;
  if (v15 == v9 + 1)
  {
    if (v16 < 0x8000)
    {
      XMPUtils::CreateArrayChildNode((uint64_t)a1, v12, &v30);
      long long v17 = v30;
      long long v30 = 0uLL;
      long long v18 = (std::__shared_weak_count *)*((void *)&v31 + 1);
      long long v31 = v17;
      if (v18)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v18);
        if (*((void *)&v30 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v30 + 1));
        }
      }
      uint64_t v19 = v9 + 1;
LABEL_31:
      (*(void (**)(void, long long *, uint64_t))(*(void *)*a1 + 664))(*a1, &v31, v19);
      goto LABEL_32;
    }
    CGPoint v26 = "Can't insert before or after implicit new item";
LABEL_47:
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 104;
    exception[1] = v26;
    *((unsigned char *)exception + 16) = 0;
  }
  if (v15 < 1 || v15 > v9)
  {
    CGPoint v26 = "Array index out of bounds";
    goto LABEL_47;
  }
  if (v16)
  {
    XMPUtils::CreateArrayChildNode((uint64_t)a1, v12, &v30);
    long long v21 = v30;
    long long v30 = 0uLL;
    unint64_t v22 = (std::__shared_weak_count *)*((void *)&v31 + 1);
    long long v31 = v21;
    if (v22)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v22);
      if (*((void *)&v30 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v30 + 1));
      }
    }
    if (v16 == 0x8000) {
      uint64_t v19 = (v15 + 1);
    }
    else {
      uint64_t v19 = v15;
    }
    goto LABEL_31;
  }
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 656))(&v28);
  (*(void (**)(long long *__return_ptr))(*(void *)v28 + 232))(&v30);
  uint64_t v23 = v30;
  if ((void)v30) {
    uint64_t v23 = v30 + *(void *)(*(void *)v30 - 544);
  }
  uint64_t v24 = *((void *)&v30 + 1);
  long long v30 = 0uLL;
  long long v25 = (std::__shared_weak_count *)*((void *)&v31 + 1);
  *(void *)&long long v31 = v23;
  *((void *)&v31 + 1) = v24;
  if (v25)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v25);
    if (*((void *)&v30 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v30 + 1));
    }
  }
  if (v29) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v29);
  }
LABEL_32:
  XMPUtils::SetNode(&v31, a3, (int)v12);
  if (*((void *)&v31 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v31 + 1));
  }
  if (SHIBYTE(v34) < 0) {
    operator delete(__p);
  }
  if (SHIBYTE(v36) < 0) {
    operator delete(v35[0]);
  }
}

void sub_1888061CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  if (a20 < 0) {
    operator delete(__p);
  }
  if (a26 < 0) {
    operator delete(a21);
  }
  _Unwind_Resume(exception_object);
}

void XMPUtils::GetNameSpaceAndNameFromStepValue(const std::string *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::string::size_type v8 = std::string::find(a1, 58, 0);
  memset(&v11, 0, sizeof(v11));
  std::string::basic_string(&v11, a1, 0, v8, (std::allocator<char> *)&v10);
  (*(void (**)(std::string *__return_ptr))(**(void **)a2 + 80))(&v10);
  uint64_t v9 = (*(uint64_t (**)(std::string::size_type))(*(void *)v10.__r_.__value_.__l.__data_ + 192))(v10.__r_.__value_.__r.__words[0]);
  MEMORY[0x18C11BE10](a3, v9);
  if (v10.__r_.__value_.__l.__size_) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v10.__r_.__value_.__l.__size_);
  }
  std::string::basic_string(&v10, a1, v8 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v12);
  if (*(char *)(a4 + 23) < 0) {
    operator delete(*(void **)a4);
  }
  *(std::string *)a4 = v10;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v11.__r_.__value_.__l.__data_);
  }
}

void sub_1888063A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  if (a18 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL XMPUtils::HandleConstAliasStep(void *a1, void *a2, uint64_t *a3, int *a4)
{
  std::shared_ptr<AdobeXMPCore::INode_v1>::operator=[abi:ne180100]<AdobeXMPCore::ISimpleNode_v1,void>(a2, (uint64_t)a1);
  uint64_t v8 = *a3;
  if (*a3 == a3[1])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    exception[1] = "Empty XPath";
    *((unsigned char *)exception + 16) = 0;
  }
  if ((*(unsigned char *)(v8 + 56) & 0x10) == 0) {
    return 0;
  }
  uint64_t v10 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(sRegisteredAliasMap, (const void **)(v8 + 32));
  if (sRegisteredAliasMap + 8 == v10) {
    XMPUtils::HandleConstAliasStep();
  }
  uint64_t v11 = v10;
  __p[1] = 0;
  uint64_t v59 = 0;
  __p[0] = 0;
  char v12 = *(char **)(v10 + 56);
  if (v12[23] < 0) {
    char v12 = *(char **)v12;
  }
  std::string::basic_string[abi:ne180100]<0>(__p, v12);
  uint64_t v13 = *(void *)(v11 + 56);
  int v14 = (const std::string *)(v13 + 32);
  if (*(char *)(v13 + 55) < 0)
  {
    unsigned int v16 = *(char **)(v13 + 32);
    int64_t v15 = *(void *)(v13 + 40);
  }
  else
  {
    int64_t v15 = *(unsigned __int8 *)(v13 + 55);
    unsigned int v16 = (char *)(v13 + 32);
  }
  if (v15 < 1) {
    goto LABEL_23;
  }
  long long v17 = &v16[v15];
  long long v18 = v16;
  while (1)
  {
    uint64_t v19 = (char *)memchr(v18, 58, v15);
    if (!v19) {
      goto LABEL_23;
    }
    if (*v19 == 58) {
      break;
    }
    long long v18 = v19 + 1;
    int64_t v15 = v17 - (unsigned char *)v18;
    if (v17 - (unsigned char *)v18 < 1) {
      goto LABEL_23;
    }
  }
  if (v19 == v17 || v19 - v16 == -1) {
LABEL_23:
  }
    __assert_rtn("HandleConstAliasStep", "XMPUtils.cpp", 296, "colonPos != std::string::npos");
  memset(&v57, 0, sizeof(v57));
  std::string::basic_string(&v57, v14, v19 - v16 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v60);
  (*(void (**)(long long *__return_ptr))(*(void *)(*a1 + *(void *)(*(void *)*a1 - 792)) + 648))(&v60);
  long long v20 = v60;
  long long v60 = 0uLL;
  long long v21 = (std::__shared_weak_count *)a2[1];
  *(_OWORD *)a2 = v20;
  if (v21)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v21);
    if (*((void *)&v60 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v60 + 1));
    }
    uint64_t v22 = *a2;
    if (!*a2) {
      goto LABEL_33;
    }
  }
  else
  {
    uint64_t v22 = v20;
    if (!(void)v20) {
      goto LABEL_33;
    }
  }
  if (*(void *)(v11 + 64) - *(void *)(v11 + 56) != 64)
  {
    if ((*(unsigned int (**)(uint64_t))(*(void *)v22 + 40))(v22) != 2)
    {
      int v50 = "destNode->GetNodeType() == INode::kNTArray";
      int v51 = 301;
      goto LABEL_100;
    }
    uint64_t v23 = *(void *)(v11 + 56);
    uint64_t v24 = (unsigned __int16 *)(v23 + 64);
    int v25 = *(_DWORD *)(v23 + 88);
    if (v25 != 5)
    {
      if (v25 == 3)
      {
        int v26 = *(char *)(v23 + 87);
        if (v26 < 0)
        {
          if (*(void *)(v23 + 72) != 3)
          {
LABEL_98:
            int v50 = "aliasPos->second[2].step == \"[1]\"";
            int v51 = 304;
            goto LABEL_100;
          }
          uint64_t v24 = *(unsigned __int16 **)v24;
        }
        else if (v26 != 3)
        {
          goto LABEL_98;
        }
        int v29 = *v24;
        int v30 = *((unsigned __int8 *)v24 + 2);
        if (v29 == 12635 && v30 == 93)
        {
          (*(void (**)(uint64_t *__return_ptr))(*(void *)*a2 + 248))(&v55);
          (*(void (**)(long long *__return_ptr))(*(void *)v55 + 656))(&v60);
          long long v32 = v60;
          long long v60 = 0uLL;
          CGColorSpaceRef v33 = (std::__shared_weak_count *)a2[1];
          *(_OWORD *)a2 = v32;
          if (v33)
          {
            std::__shared_weak_count::__release_shared[abi:ne180100](v33);
            if (*((void *)&v60 + 1)) {
              std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v60 + 1));
            }
          }
          if (v56) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v56);
          }
          (*(void (**)(void))(*(void *)*a2 + 40))();
          BOOL v9 = *a2 != 0;
          if (a4 && *a2)
          {
            BOOL v9 = 1;
            *a4 = 1;
          }
          goto LABEL_34;
        }
        goto LABEL_98;
      }
LABEL_33:
      BOOL v9 = 0;
      goto LABEL_34;
    }
    int v28 = *(char *)(v23 + 87);
    if (v28 < 0)
    {
      if (*(void *)(v23 + 72) != 23)
      {
LABEL_99:
        int v50 = "aliasPos->second[2].step == \"[?xml:lang=\\\"x-default\\\"]\"";
        int v51 = 315;
LABEL_100:
        __assert_rtn("HandleConstAliasStep", "XMPUtils.cpp", v51, v50);
      }
      uint64_t v24 = *(unsigned __int16 **)v24;
    }
    else if (v28 != 23)
    {
      goto LABEL_99;
    }
    uint64_t v34 = *(void *)v24;
    uint64_t v35 = *((void *)v24 + 1);
    uint64_t v36 = *(void *)((char *)v24 + 15);
    if (v34 == 0x616C3A6C6D783F5BLL && v35 == 0x65642D78223D676ELL && v36 == 0x5D22746C75616665)
    {
      uint64_t v55 = 0;
      int v56 = 0;
      uint64_t v39 = (std::__shared_weak_count *)a2[1];
      *(void *)&long long v60 = *a2;
      *((void *)&v60 + 1) = v39;
      if (v39) {
        atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      XMPUtils::GetNodeChildIterator(&v60, &v55);
      if (v39) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v39);
      }
      uint64_t v40 = v55;
      int v41 = 1;
      do
      {
        BOOL v9 = v40 != 0;
        if (!v40) {
          break;
        }
        (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v40 + 48))(&v60, v40);
        long long v42 = v60;
        (*(void (**)(long long *__return_ptr, void, const char *, uint64_t, const char *, uint64_t))(*(void *)v60 + 128))(&v60, v60, "http://www.w3.org/XML/1998/namespace", 36, "lang", -1);
        long long v43 = v60;
        if ((*(unsigned int (**)(void))(*(void *)v60 + 40))(v60) != 1) {
          goto LABEL_79;
        }
        (*(void (**)(long long *__return_ptr, void))(*(void *)v43 + 232))(&v60, v43);
        uint64_t v44 = (std::__shared_weak_count *)*((void *)&v60 + 1);
        (*(void (**)(uint64_t *__return_ptr))(*(void *)v60 + 504))(&v53);
        uint64_t v45 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v53 + 192))(v53);
        int v46 = strcmp("x-default", v45);
        if (v54) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v54);
        }
        if (v44) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v44);
        }
        if (!v46)
        {
          if (*((void *)&v42 + 1)) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v42 + 1) + 8), 1uLL, memory_order_relaxed);
          }
          int v49 = (std::__shared_weak_count *)a2[1];
          *(_OWORD *)a2 = v42;
          if (v49) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v49);
          }
          char v48 = 0;
          if (a4) {
            *a4 = v41;
          }
        }
        else
        {
LABEL_79:
          (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v40 + 56))(&v60, v40);
          uint64_t v40 = v60;
          ++v41;
          uint64_t v47 = v56;
          int v56 = (std::__shared_weak_count *)*((void *)&v60 + 1);
          if (v47) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v47);
          }
          char v48 = 1;
        }
        if (*((void *)&v43 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v43 + 1));
        }
        if (*((void *)&v42 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v42 + 1));
        }
      }
      while ((v48 & 1) != 0);
      if (v56) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v56);
      }
      goto LABEL_34;
    }
    goto LABEL_99;
  }
  BOOL v9 = 1;
LABEL_34:
  if (SHIBYTE(v57.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v57.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v59) < 0) {
    operator delete(__p[0]);
  }
  return v9;
}

void sub_188806AE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (v24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v24);
  }
  if (a18 < 0) {
    operator delete(__p);
  }
  if (a24 < 0) {
    operator delete(a19);
  }
  _Unwind_Resume(exception_object);
}

void XMPUtils::GetNodeChildIterator(void *a1@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  int v4 = (*(uint64_t (**)(void))(*(void *)*a1 + 40))(*a1);
  uint64_t v5 = *a1;
  if (v4 == 2)
  {
    (*(void (**)(long long *__return_ptr))(*(void *)v5 + 248))(&v7);
    uint64_t v6 = (std::__shared_weak_count *)*((void *)&v7 + 1);
    (*(void (**)(long long *__return_ptr))(*(void *)(v7 + *(void *)(*(void *)v7 - 688)) + 552))(&v7);
  }
  else
  {
    if ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 40))(v5) != 4) {
      return;
    }
    (*(void (**)(long long *__return_ptr))(*(void *)*a1 + 240))(&v7);
    uint64_t v6 = (std::__shared_weak_count *)*((void *)&v7 + 1);
    (*(void (**)(long long *__return_ptr))(*(void *)(v7 + *(void *)(*(void *)v7 - 688)) + 552))(&v7);
  }
  *(_OWORD *)a2 = v7;
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
}

void sub_188806D60(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
  _Unwind_Resume(exception_object);
}

BOOL XMPUtils::HandleAliasStep(void *a1, uint64_t *a2, char a3, unsigned int a4, void *a5, int *a6)
{
  std::shared_ptr<AdobeXMPCore::INode_v1>::operator=[abi:ne180100]<AdobeXMPCore::ISimpleNode_v1,void>(a5, (uint64_t)a1);
  uint64_t v12 = *a2;
  uint64_t v13 = a2[1];
  uint64_t v14 = v13 - *a2;
  if (v13 == *a2)
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    exception[1] = "Empty XPath";
    *((unsigned char *)exception + 16) = 0;
  }
  if ((*(unsigned char *)(v12 + 56) & 0x10) == 0) {
    return 0;
  }
  uint64_t v16 = std::__tree<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::shared_ptr<IIOBaseObject>>>>::find<std::string>(sRegisteredAliasMap, (const void **)(v12 + 32));
  if (sRegisteredAliasMap + 8 == v16) {
    XMPUtils::HandleAliasStep();
  }
  uint64_t v17 = v16;
  uint64_t v91 = 0;
  uint64_t v92 = 0;
  __p = 0;
  long long v18 = *(char **)(v16 + 56);
  if (v18[23] < 0) {
    long long v18 = *(char **)v18;
  }
  std::string::basic_string[abi:ne180100]<0>(&__p, v18);
  uint64_t v19 = *(void *)(v17 + 56);
  long long v20 = (const std::string *)(v19 + 32);
  if (*(char *)(v19 + 55) < 0)
  {
    uint64_t v22 = *(char **)(v19 + 32);
    int64_t v21 = *(void *)(v19 + 40);
  }
  else
  {
    int64_t v21 = *(unsigned __int8 *)(v19 + 55);
    uint64_t v22 = (char *)(v19 + 32);
  }
  if (v21 < 1) {
    goto LABEL_23;
  }
  uint64_t v23 = &v22[v21];
  uint64_t v24 = v22;
  while (1)
  {
    int v25 = (char *)memchr(v24, 58, v21);
    if (!v25) {
      goto LABEL_23;
    }
    if (*v25 == 58) {
      break;
    }
    uint64_t v24 = v25 + 1;
    int64_t v21 = v23 - (unsigned char *)v24;
    if (v23 - (unsigned char *)v24 < 1) {
      goto LABEL_23;
    }
  }
  if (v25 == v23 || v25 - v22 == -1) {
LABEL_23:
  }
    __assert_rtn("HandleAliasStep", "XMPUtils.cpp", 362, "colonPos != std::string::npos");
  memset(&v89, 0, sizeof(v89));
  std::string::basic_string(&v89, v20, v25 - v22 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v93);
  (*(void (**)(long long *__return_ptr))(*(void *)(*a1 + *(void *)(*(void *)*a1 - 792)) + 648))(&v93);
  long long v26 = v93;
  long long v93 = 0uLL;
  uint64_t v27 = (std::__shared_weak_count *)a5[1];
  *(_OWORD *)a5 = v26;
  if (v27)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
    if (*((void *)&v93 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v93 + 1));
    }
    uint64_t v28 = *a5;
    if (*a5) {
      goto LABEL_27;
    }
  }
  else
  {
    uint64_t v28 = v26;
    if ((void)v26) {
      goto LABEL_27;
    }
  }
  if ((a3 & 1) == 0) {
    goto LABEL_26;
  }
LABEL_27:
  uint64_t v29 = *(void *)(v17 + 56);
  uint64_t v30 = (*(void *)(v17 + 64) - v29) >> 5;
  if (v30 == 2)
  {
    if (!v28)
    {
      std::shared_ptr<AdobeXMPCore::INode_v1>::operator=[abi:ne180100]<AdobeXMPCore::ISimpleNode_v1,void>(a5, (uint64_t)a1);
      if (v14 == 64) {
        uint64_t v34 = (const char *)a4;
      }
      else {
        uint64_t v34 = 0;
      }
      long long v93 = 0uLL;
      if (v92 >= 0) {
        p_p = (AdobeXMPCore::ISimpleNode_v1 *)&__p;
      }
      else {
        p_p = (AdobeXMPCore::ISimpleNode_v1 *)__p;
      }
      if ((v89.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v36 = &v89;
      }
      else {
        uint64_t v36 = (std::string *)v89.__r_.__value_.__r.__words[0];
      }
      XMPUtils::CreateTerminalNode(p_p, (const char *)v36, v34, &v93);
      if ((void)v93)
      {
        (*(void (**)(long long *__return_ptr))(*(void *)*a5 + 240))(&v88);
        (*(void (**)(void, long long *))(*(void *)(v88 + *(void *)(*(void *)v88 - 688)) + 520))(v88 + *(void *)(*(void *)v88 - 688), &v93);
        if (*((void *)&v88 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v88 + 1));
        }
        uint64_t v38 = *((void *)&v93 + 1);
        uint64_t v37 = v93;
        if (*((void *)&v93 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v93 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v39 = (std::__shared_weak_count *)a5[1];
        *a5 = v37;
        a5[1] = v38;
        if (v39)
        {
          std::__shared_weak_count::__release_shared[abi:ne180100](v39);
          uint64_t v37 = *a5;
        }
        BOOL v15 = v37 != 0;
      }
      else
      {
        BOOL v15 = 0;
      }
      if (*((void *)&v93 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v93 + 1));
      }
      goto LABEL_151;
    }
    goto LABEL_29;
  }
  if (v30 != 3)
  {
    uint64_t v81 = "aliasPos->second.size() == 3";
    int v82 = 381;
    goto LABEL_172;
  }
  long long v31 = (unsigned __int16 *)(v29 + 64);
  int v32 = *(_DWORD *)(v29 + 88);
  if (v32 == 5)
  {
    int v40 = *(char *)(v29 + 87);
    if (v40 < 0)
    {
      if (*(void *)(v29 + 72) != 23) {
        goto LABEL_171;
      }
      long long v31 = *(unsigned __int16 **)v31;
    }
    else if (v40 != 23)
    {
      goto LABEL_171;
    }
    uint64_t v47 = *(void *)v31;
    uint64_t v48 = *((void *)v31 + 1);
    uint64_t v49 = *(void *)((char *)v31 + 15);
    if (v47 == 0x616C3A6C6D783F5BLL && v48 == 0x65642D78223D676ELL && v49 == 0x5D22746C75616665)
    {
      (*(void (**)(long long *__return_ptr))(*(void *)(*a1 + *(void *)(*(void *)*a1 - 792)) + 648))(&v93);
      long long v52 = v93;
      long long v93 = 0uLL;
      uint64_t v53 = (std::__shared_weak_count *)a5[1];
      *(_OWORD *)a5 = v52;
      if (v53)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v53);
        if (*((void *)&v93 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v93 + 1));
        }
      }
      if (*a5 || (a3 & 1) != 0)
      {
        long long v88 = 0uLL;
        if (v92 >= 0) {
          uint64_t v54 = (AdobeXMPCore::ISimpleNode_v1 *)&__p;
        }
        else {
          uint64_t v54 = (AdobeXMPCore::ISimpleNode_v1 *)__p;
        }
        if ((v89.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v55 = &v89;
        }
        else {
          uint64_t v55 = (std::string *)v89.__r_.__value_.__r.__words[0];
        }
        XMPUtils::CreateTerminalNode(v54, (const char *)v55, (const char *)0x1200, &v88);
        uint64_t v56 = *a1 + *(void *)(*(void *)*a1 - 688);
        (*(void (**)(uint64_t, long long *))(*(void *)v56 + 520))(v56, &v88);
        __int16 v58 = (std::__shared_weak_count *)*((void *)&v88 + 1);
        uint64_t v57 = v88;
        if (*((void *)&v88 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v88 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v59 = (std::__shared_weak_count *)a5[1];
        *a5 = v57;
        a5[1] = v58;
        if (v59)
        {
          std::__shared_weak_count::__release_shared[abi:ne180100](v59);
          uint64_t v57 = *a5;
          __int16 v58 = (std::__shared_weak_count *)a5[1];
        }
        uint64_t v86 = 0;
        uint64_t v87 = 0;
        *(void *)&long long v93 = v57;
        *((void *)&v93 + 1) = v58;
        if (v58) {
          atomic_fetch_add_explicit(&v58->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        XMPUtils::GetNodeChildIterator(&v93, &v86);
        if (v58) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v58);
        }
        uint64_t v60 = v86;
        int v61 = 1;
        do
        {
          if (!v60)
          {
            uint64_t v86 = 0;
            long long v93 = 0uLL;
            AdobeXMPCore::ISimpleNode_v1::CreateSimpleNode((AdobeXMPCore::ISimpleNode_v1 *)"http://www.w3.org/XML/1998/namespace", (const char *)0x24, "lang", (const char *)0xFFFFFFFFFFFFFFFFLL, "x-default", (const char *)0xFFFFFFFFFFFFFFFFLL);
          }
          (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v60 + 48))(&v93, v60);
          long long v62 = v93;
          (*(void (**)(long long *__return_ptr, void, const char *, uint64_t, const char *, uint64_t))(*(void *)v93 + 128))(&v93, v93, "http://www.w3.org/XML/1998/namespace", 36, "lang", -1);
          long long v63 = v93;
          if ((*(unsigned int (**)(void))(*(void *)v93 + 40))(v93) != 1) {
            goto LABEL_107;
          }
          (*(void (**)(long long *__return_ptr, void))(*(void *)v63 + 232))(&v93, v63);
          unsigned int v64 = (std::__shared_weak_count *)*((void *)&v93 + 1);
          (*(void (**)(uint64_t *__return_ptr))(*(void *)v93 + 504))(&v84);
          int v65 = (const char *)(*(uint64_t (**)(uint64_t))(*(void *)v84 + 192))(v84);
          int v66 = strcmp("x-default", v65);
          if (v85) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v85);
          }
          if (v64) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v64);
          }
          if (!v66)
          {
            if (*((void *)&v62 + 1)) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v62 + 1) + 8), 1uLL, memory_order_relaxed);
            }
            char v69 = (std::__shared_weak_count *)a5[1];
            *(_OWORD *)a5 = v62;
            if (v69) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v69);
            }
            char v68 = 0;
            if (a6) {
              *a6 = v61;
            }
          }
          else
          {
LABEL_107:
            (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v60 + 56))(&v93, v60);
            uint64_t v60 = v93;
            ++v61;
            int v67 = v87;
            uint64_t v87 = (std::__shared_weak_count *)*((void *)&v93 + 1);
            if (v67) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v67);
            }
            char v68 = 1;
          }
          if (*((void *)&v63 + 1)) {
            std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v63 + 1));
          }
          if (*((void *)&v62 + 1)) {
            std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v62 + 1));
          }
        }
        while ((v68 & 1) != 0);
        if (v87) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v87);
        }
        if (*((void *)&v88 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v88 + 1));
        }
LABEL_29:
        BOOL v15 = 1;
        goto LABEL_151;
      }
      goto LABEL_26;
    }
LABEL_171:
    uint64_t v81 = "aliasPos->second[2].step == \"[?xml:lang=\\\"x-default\\\"]\"";
    int v82 = 406;
LABEL_172:
    __assert_rtn("HandleAliasStep", "XMPUtils.cpp", v82, v81);
  }
  if (v32 == 3)
  {
    int v33 = *(char *)(v29 + 87);
    if (v33 < 0)
    {
      if (*(void *)(v29 + 72) != 3)
      {
LABEL_170:
        uint64_t v81 = "aliasPos->second[2].step == \"[1]\"";
        int v82 = 383;
        goto LABEL_172;
      }
      long long v31 = *(unsigned __int16 **)v31;
    }
    else if (v33 != 3)
    {
      goto LABEL_170;
    }
    int v41 = *v31;
    int v42 = *((unsigned __int8 *)v31 + 2);
    if (v41 != 12635 || v42 != 93) {
      goto LABEL_170;
    }
    (*(void (**)(long long *__return_ptr))(*(void *)(*a1 + *(void *)(*(void *)*a1 - 792)) + 648))(&v93);
    long long v44 = v93;
    long long v93 = 0uLL;
    uint64_t v45 = (std::__shared_weak_count *)a5[1];
    *(_OWORD *)a5 = v44;
    if (v45)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v45);
      if (*((void *)&v93 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v93 + 1));
      }
      uint64_t v46 = *a5;
    }
    else
    {
      uint64_t v46 = v44;
    }
    if (v46 || (a3 & 1) != 0)
    {
      if (!v46)
      {
        long long v93 = 0uLL;
        if (v92 >= 0) {
          uint64_t v70 = (AdobeXMPCore::ISimpleNode_v1 *)&__p;
        }
        else {
          uint64_t v70 = (AdobeXMPCore::ISimpleNode_v1 *)__p;
        }
        if ((v89.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          int v71 = &v89;
        }
        else {
          int v71 = (std::string *)v89.__r_.__value_.__r.__words[0];
        }
        XMPUtils::CreateTerminalNode(v70, (const char *)v71, (const char *)0x600, &v93);
        uint64_t v72 = *a1 + *(void *)(*(void *)*a1 - 688);
        (*(void (**)(uint64_t, long long *))(*(void *)v72 + 520))(v72, &v93);
        long long v73 = v93;
        if (*((void *)&v93 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v93 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v74 = (std::__shared_weak_count *)a5[1];
        *(_OWORD *)a5 = v73;
        if (v74) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v74);
        }
        if (*((void *)&v93 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v93 + 1));
        }
        uint64_t v46 = *a5;
      }
      (*(void (**)(long long *__return_ptr))(*(void *)v46 + 248))(&v88);
      (*(void (**)(long long *__return_ptr))(*(void *)v88 + 656))(&v93);
      uint64_t v75 = v93;
      if (*((void *)&v93 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v93 + 1));
      }
      if (*((void *)&v88 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v88 + 1));
      }
      if (!v75)
      {
        long long v93 = 0uLL;
        if (v92 >= 0) {
          uint64_t v79 = (AdobeXMPCore::ISimpleNode_v1 *)&__p;
        }
        else {
          uint64_t v79 = (AdobeXMPCore::ISimpleNode_v1 *)__p;
        }
        if (v92 >= 0) {
          uint64_t v80 = (const char *)HIBYTE(v92);
        }
        else {
          uint64_t v80 = v91;
        }
        AdobeXMPCore::ISimpleNode_v1::CreateSimpleNode(v79, v80, "[]", (const char *)0xFFFFFFFFFFFFFFFFLL, "", (const char *)0xFFFFFFFFFFFFFFFFLL);
      }
      (*(void (**)(long long *__return_ptr))(*(void *)*a5 + 248))(&v88);
      (*(void (**)(long long *__return_ptr))(*(void *)v88 + 656))(&v93);
      long long v76 = v93;
      long long v93 = 0uLL;
      uint64_t v77 = (std::__shared_weak_count *)a5[1];
      *(_OWORD *)a5 = v76;
      if (v77)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v77);
        if (*((void *)&v93 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v93 + 1));
        }
      }
      if (*((void *)&v88 + 1)) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v88 + 1));
      }
      BOOL v15 = 1;
      if (a6) {
        *a6 = 1;
      }
      goto LABEL_151;
    }
  }
LABEL_26:
  BOOL v15 = 0;
LABEL_151:
  if (SHIBYTE(v89.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v89.__r_.__value_.__l.__data_);
  }
  if (SHIBYTE(v92) < 0) {
    operator delete(__p);
  }
  return v15;
}

void sub_188807E54(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, std::__shared_weak_count *a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  if (a14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a14);
  }
  int v32 = *(std::__shared_weak_count **)(v30 - 88);
  if (v32) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v32);
  }
  if (a16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a16);
  }
  if (a18) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a18);
  }
  if (a24 < 0) {
    operator delete(__p);
  }
  if (a30 < 0) {
    operator delete(a25);
  }
  _Unwind_Resume(exception_object);
}

uint64_t XMPUtils::FindNode(void *a1, uint64_t *a2, uint64_t a3, unsigned int a4, uint64_t a5, _DWORD *a6, unsigned int a7)
{
  uint64_t v11 = a3;
  uint64_t v12 = a2;
  __n128 v215 = 0uLL;
  uint64_t v14 = (void *)*a1;
  if (*a1) {
    uint64_t v14 = (void *)((char *)v14 + *(void *)(*v14 - 544));
  }
  unint64_t v15 = a1[1];
  v215.n128_u64[0] = (unint64_t)v14;
  v215.n128_u64[1] = v15;
  if (!v15)
  {
    uint64_t v16 = 0;
    if (!a4) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
  uint64_t v16 = (std::__shared_weak_count *)a1[1];
  if (v16) {
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (a4)
  {
LABEL_9:
    if ((a3 & 1) == 0) {
      __assert_rtn("FindNode", "XMPUtils.cpp", 468, "(leafOptions == 0) || createNodes");
    }
  }
LABEL_10:
  if (*a2 == a2[1])
  {
    exception = __cxa_allocate_exception(0x18uLL);
    *(_DWORD *)exception = 102;
    exception[1] = "Empty XPath";
    *((unsigned char *)exception + 16) = 0;
  }
  long long v214 = 0uLL;
  v17.n128_f64[0] = AdobeXMPCore::INameSpacePrefixMap_v1::GetDefaultNameSpacePrefixMap(&v214);
  if ((*(unsigned char *)(*v12 + 56) & 0x10) == 0)
  {
    uint64_t v180 = a5;
    unint64_t v18 = 1;
    goto LABEL_15;
  }
  if (XMPUtils::HandleAliasStep(a1, v12, v11, a4, &v215, 0))
  {
    uint64_t v180 = a5;
    unint64_t v18 = 2;
LABEL_15:
    unint64_t v185 = ((v12[1] - *v12) >> 5) - a7;
    if (v18 >= v185)
    {
      uint64_t v181 = 0;
LABEL_448:
      __n128 v160 = v215;
      if (v215.n128_u64[1]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v215.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
      }
      v161 = *(std::__shared_weak_count **)(v180 + 8);
      *(__n128 *)uint64_t v180 = v160;
      if (v161) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v161);
      }
      uint64_t v162 = 1;
LABEL_453:
      long long v163 = v181;
      goto LABEL_455;
    }
    unsigned int v176 = a4;
    uint64_t v181 = 0;
    unint64_t v19 = 0;
    int v178 = 0;
    long long v20 = v16;
    uint64_t v177 = (char *)v12;
    uint64_t v179 = a6;
LABEL_17:
    unint64_t v21 = v215.n128_u64[0];
    if (v215.n128_u64[0])
    {
      memset(&__str, 0, sizeof(__str));
      uint64_t v22 = *v12 + 32 * v18;
      if (*(char *)(v22 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(&__str, *(const std::string::value_type **)v22, *(void *)(v22 + 8));
      }
      else
      {
        long long v23 = *(_OWORD *)v22;
        __str.__r_.__value_.__r.__words[2] = *(void *)(v22 + 16);
        *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v23;
      }
      memset(&v212, 0, sizeof(v212));
      uint64_t v24 = *v12;
      uint64_t v25 = *v12 + 32 * v18;
      if (*(char *)(v25 - 9) < 0)
      {
        std::string::__init_copy_ctor_external(&v212, *(const std::string::value_type **)(v25 - 32), *(void *)(v25 - 24));
        uint64_t v24 = *v12;
      }
      else
      {
        __n128 v17 = *(__n128 *)(v25 - 32);
        v212.__r_.__value_.__r.__words[2] = *(void *)(v25 - 16);
        *(__n128 *)&v212.__r_.__value_.__l.__data_ = v17;
      }
      memset(&v211, 0, sizeof(v211));
      switch(*(_DWORD *)(v24 + 32 * v18 + 24))
      {
        case 1:
          std::string::size_type v26 = std::string::find(&__str, 58, 0);
          memset(&v210, 0, sizeof(v210));
          std::string::basic_string(&v210, &__str, 0, v26, (std::allocator<char> *)&v204);
          unint64_t v27 = v19;
          (*(void (**)(std::string *__return_ptr))(*(void *)v214 + 80))(&v209);
          int64_t size = (std::__shared_weak_count *)v209.__r_.__value_.__l.__size_;
          std::string::size_type v28 = v209.__r_.__value_.__r.__words[0];
          std::string::basic_string(&v209, &__str, v26 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v204);
          if (SHIBYTE(v211.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v211.__r_.__value_.__l.__data_);
          }
          std::string v211 = v209;
          if ((*(unsigned int (**)(unint64_t))(*(void *)v215.n128_u64[0] + 40))(v215.n128_u64[0]) != 4)
          {
            int v34 = 5;
            uint64_t v16 = v20;
            unint64_t v19 = v27;
            goto LABEL_415;
          }
          *(_OWORD *)&v209.__r_.__value_.__l.__data_ = 0uLL;
          (*(void (**)(std::string *__return_ptr))(*(void *)v215.n128_u64[0] + 240))(&v209);
          uint64_t v16 = (std::__shared_weak_count *)v215.n128_u64[1];
          if (v215.n128_u64[1]) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v215.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
          }
          if (v20) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v20);
          }
          std::string::size_type v29 = v209.__r_.__value_.__r.__words[0];
          uint64_t v30 = (*(uint64_t (**)(std::string::size_type))(*(void *)v28 + 192))(v28);
          uint64_t v31 = (*(uint64_t (**)(std::string::size_type))(*(void *)v28 + 208))(v28);
          p_str = &__str;
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          (*(void (**)(void **__return_ptr, std::string::size_type, uint64_t, uint64_t, std::string::size_type, uint64_t))(*(void *)v29 + 648))(__p, v29, v30, v31, (std::string::size_type)p_str->__r_.__value_.__r.__words + v26 + 1, -1);
          __n128 v17 = *(__n128 *)__p;
          __p[0] = 0;
          __p[1] = 0;
          int v33 = (std::__shared_weak_count *)v215.n128_u64[1];
          __n128 v215 = v17;
          if (v33)
          {
            std::__shared_weak_count::__release_shared[abi:ne180100](v33);
            if (__p[1]) {
              std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__p[1]);
            }
          }
          if (v215.n128_u64[0]) {
            int v34 = 4;
          }
          else {
            int v34 = 1;
          }
          if (v215.n128_u64[0] || (v11 & 1) == 0) {
            goto LABEL_412;
          }
          if (v18 == ((v12[1] - *v12) >> 5) - 1)
          {
            __p[0] = 0;
            __p[1] = 0;
            uint64_t v35 = (AdobeXMPCore::ISimpleNode_v1 *)(*(uint64_t (**)(std::string::size_type))(*(void *)v28 + 192))(v28);
            if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v36 = &v211;
            }
            else {
              uint64_t v36 = (std::string *)v211.__r_.__value_.__r.__words[0];
            }
            XMPUtils::CreateTerminalNode(v35, (const char *)v36, (const char *)v176, __p);
            unint64_t v19 = v27;
            (*(void (**)(std::string::size_type, void **))(*(void *)v209.__r_.__value_.__l.__data_ + 656))(v209.__r_.__value_.__r.__words[0], __p);
            uint64_t v38 = __p[0];
            uint64_t v37 = __p[1];
            if (__p[1]) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)__p[1] + 1, 1uLL, memory_order_relaxed);
            }
            uint64_t v39 = (std::__shared_weak_count *)v215.n128_u64[1];
            v215.n128_u64[0] = (unint64_t)v38;
            v215.n128_u64[1] = (unint64_t)v37;
            if (v39) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v39);
            }
            if (!v178)
            {
              int v40 = (std::__shared_weak_count *)v215.n128_u64[1];
              unint64_t v19 = v215.n128_u64[0];
              if (v215.n128_u64[1]) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v215.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
              }
              if (v181) {
                std::__shared_weak_count::__release_shared[abi:ne180100](v181);
              }
              int v178 = 1;
              uint64_t v181 = v40;
            }
            if (__p[1]) {
              std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__p[1]);
            }
            int v34 = 0;
          }
          else
          {
            int v116 = *(_DWORD *)(*v12 + 32 * v18 + 56);
            if ((v116 - 3) < 4)
            {
              __p[0] = 0;
              __p[1] = 0;
              unsigned int v117 = (AdobeXMPCore::IArrayNode_v1 *)(*(uint64_t (**)(std::string::size_type))(*(void *)v28 + 192))(v28);
              unsigned int v118 = (char *)(*(uint64_t (**)(std::string::size_type))(*(void *)v28 + 208))(v28);
              if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                unsigned int v119 = &v211;
              }
              else {
                unsigned int v119 = (std::string *)v211.__r_.__value_.__r.__words[0];
              }
              if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::string::size_type v120 = HIBYTE(v211.__r_.__value_.__r.__words[2]);
              }
              else {
                std::string::size_type v120 = v211.__r_.__value_.__l.__size_;
              }
              AdobeXMPCore::IArrayNode_v1::CreateOrderedArrayNode(v117, v118, (unint64_t)v119, (const char *)v120);
            }
            if (v116 == 2)
            {
              __p[0] = 0;
              __p[1] = 0;
              uint64_t v148 = (AdobeXMPCore::ISimpleNode_v1 *)(*(uint64_t (**)(std::string::size_type))(*(void *)v28 + 192))(v28);
              uint64_t v149 = (const char *)(*(uint64_t (**)(std::string::size_type))(*(void *)v28 + 208))(v28);
              if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                int v150 = &v211;
              }
              else {
                int v150 = (std::string *)v211.__r_.__value_.__r.__words[0];
              }
              if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::string::size_type v151 = HIBYTE(v211.__r_.__value_.__r.__words[2]);
              }
              else {
                std::string::size_type v151 = v211.__r_.__value_.__l.__size_;
              }
              AdobeXMPCore::ISimpleNode_v1::CreateSimpleNode(v148, v149, (const char *)v150, (const char *)v151, 0, (const char *)0xFFFFFFFFFFFFFFFFLL);
            }
            if (v116 == 1)
            {
              __p[0] = 0;
              __p[1] = 0;
              uint64_t v127 = (AdobeXMPCore::IStructureNode_v1 *)(*(uint64_t (**)(std::string::size_type))(*(void *)v28 + 192))(v28);
              uint64_t v128 = (char *)(*(uint64_t (**)(std::string::size_type))(*(void *)v28 + 208))(v28);
              if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                unsigned int v129 = &v211;
              }
              else {
                unsigned int v129 = (std::string *)v211.__r_.__value_.__r.__words[0];
              }
              if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::string::size_type v130 = HIBYTE(v211.__r_.__value_.__r.__words[2]);
              }
              else {
                std::string::size_type v130 = v211.__r_.__value_.__l.__size_;
              }
              AdobeXMPCore::IStructureNode_v1::CreateStructureNode(v127, v128, (const char *)v129, (const char *)v130);
            }
            int v34 = 0;
LABEL_412:
            unint64_t v19 = v27;
          }
          if (v209.__r_.__value_.__l.__size_) {
            std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v209.__r_.__value_.__l.__size_);
          }
LABEL_415:
          if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v210.__r_.__value_.__l.__data_);
            if (!v34) {
              goto LABEL_417;
            }
            goto LABEL_418;
          }
LABEL_416:
          if (!v34) {
            goto LABEL_417;
          }
          goto LABEL_418;
        case 2:
          int v66 = &__str;
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
            int v66 = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          if (v66->__r_.__value_.__s.__data_[0] != 63) {
            __assert_rtn("FindNode", "XMPUtils.cpp", 728, "stepStr[0] == '?'");
          }
          std::string::basic_string(&v210, &__str, 1uLL, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v204);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          int v67 = a6;
          std::string __str = v210;
          std::string::size_type v68 = std::string::find(&__str, 58, 0);
          memset(&v210, 0, sizeof(v210));
          std::string::basic_string(&v210, &__str, 0, v68, (std::allocator<char> *)&v204);
          unint64_t v69 = v19;
          (*(void (**)(std::string *__return_ptr))(*(void *)v214 + 80))(&v209);
          int64_t size = (std::__shared_weak_count *)v209.__r_.__value_.__l.__size_;
          std::string::size_type v70 = v209.__r_.__value_.__r.__words[0];
          std::string::basic_string(&v209, &__str, v68 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v204);
          if (SHIBYTE(v211.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v211.__r_.__value_.__l.__data_);
          }
          std::string v211 = v209;
          uint64_t v16 = (std::__shared_weak_count *)v215.n128_u64[1];
          unint64_t v71 = v215.n128_u64[0];
          if (v215.n128_u64[1]) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v215.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
          }
          unint64_t v72 = v71;
          if (v20)
          {
            std::__shared_weak_count::__release_shared[abi:ne180100](v20);
            unint64_t v72 = v215.n128_u64[0];
          }
          uint64_t v73 = (*(uint64_t (**)(std::string::size_type))(*(void *)v70 + 192))(v70);
          uint64_t v74 = (*(uint64_t (**)(std::string::size_type))(*(void *)v70 + 208))(v70);
          if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v75 = &v211;
          }
          else {
            uint64_t v75 = (std::string *)v211.__r_.__value_.__r.__words[0];
          }
          if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v76 = HIBYTE(v211.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v76 = v211.__r_.__value_.__l.__size_;
          }
          (*(void (**)(std::string *__return_ptr, unint64_t, uint64_t, uint64_t, std::string *, std::string::size_type))(*(void *)v72 + 128))(&v209, v72, v73, v74, v75, v76);
          __n128 v17 = *(__n128 *)&v209.__r_.__value_.__l.__data_;
          *(_OWORD *)&v209.__r_.__value_.__l.__data_ = 0uLL;
          uint64_t v77 = (std::__shared_weak_count *)v215.n128_u64[1];
          __n128 v215 = v17;
          if (v77)
          {
            std::__shared_weak_count::__release_shared[abi:ne180100](v77);
            if (v209.__r_.__value_.__l.__size_) {
              std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v209.__r_.__value_.__l.__size_);
            }
          }
          if (v215.n128_u64[0]) {
            char v78 = 0;
          }
          else {
            char v78 = v11;
          }
          if (v215.n128_u64[0]) {
            int v34 = 4;
          }
          else {
            int v34 = 1;
          }
          if (v78)
          {
            *(_OWORD *)&v209.__r_.__value_.__l.__data_ = 0uLL;
            uint64_t v79 = (AdobeXMPCore::ISimpleNode_v1 *)(*(uint64_t (**)(std::string::size_type))(*(void *)v70 + 192))(v70);
            uint64_t v80 = (const char *)(*(uint64_t (**)(std::string::size_type))(*(void *)v70 + 208))(v70);
            if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              uint64_t v81 = &v211;
            }
            else {
              uint64_t v81 = (std::string *)v211.__r_.__value_.__r.__words[0];
            }
            if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
              std::string::size_type v82 = HIBYTE(v211.__r_.__value_.__r.__words[2]);
            }
            else {
              std::string::size_type v82 = v211.__r_.__value_.__l.__size_;
            }
            AdobeXMPCore::ISimpleNode_v1::CreateSimpleNode(v79, v80, (const char *)v81, (const char *)v82, 0, (const char *)0xFFFFFFFFFFFFFFFFLL);
          }
          unint64_t v19 = v69;
          a6 = v67;
          uint64_t v12 = (uint64_t *)v177;
          if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(v210.__r_.__value_.__l.__data_);
            if (v78) {
              goto LABEL_417;
            }
          }
          else if (v78)
          {
            goto LABEL_417;
          }
          goto LABEL_418;
        case 3:
          if ((*(unsigned int (**)(unint64_t))(*(void *)v215.n128_u64[0] + 40))(v215.n128_u64[0]) != 2) {
            goto LABEL_492;
          }
          *(_OWORD *)&v209.__r_.__value_.__l.__data_ = 0uLL;
          (*(void (**)(std::string *__return_ptr))(*(void *)v215.n128_u64[0] + 248))(&v209);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
          {
            std::string::size_type v59 = __str.__r_.__value_.__l.__size_;
            if (__str.__r_.__value_.__l.__size_ <= 1 || *__str.__r_.__value_.__l.__data_ != 91) {
              goto LABEL_488;
            }
          }
          else
          {
            if (HIBYTE(__str.__r_.__value_.__r.__words[2]) < 2u || __str.__r_.__value_.__s.__data_[0] != 91) {
              goto LABEL_488;
            }
            std::string::size_type v59 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
          }
          std::string::size_type v98 = v59 - 1;
          unint64_t v184 = v19;
          if ((*((unsigned char *)&__str.__r_.__value_.__s + 23) & 0x80) != 0)
          {
            if (*(unsigned char *)(__str.__r_.__value_.__r.__words[0] + v98) == 93)
            {
              std::string::size_type v99 = __str.__r_.__value_.__l.__size_;
              goto LABEL_231;
            }
          }
          else if (__str.__r_.__value_.__s.__data_[v98] == 93)
          {
            std::string::size_type v99 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
LABEL_231:
            std::string::size_type v100 = v99 - 2;
            if (!v100) {
              goto LABEL_493;
            }
            unint64_t v101 = 0;
            unint64_t v102 = &__str;
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              unint64_t v102 = (std::string *)__str.__r_.__value_.__r.__words[0];
            }
            unsigned int v103 = &v102->__r_.__value_.__s.__data_[1];
            do
            {
              uint64_t v105 = *v103++;
              uint64_t v104 = v105;
              if ((v105 - 48) >= 0xAu) {
                __assert_rtn("FindNode", "XMPUtils.cpp", 579, "('0' <= stepStr[chNum]) && (stepStr[chNum] <= '9')");
              }
              unint64_t v101 = v104 + 10 * v101 - 48;
              --v100;
            }
            while (v100);
            if (!v101)
            {
LABEL_493:
              uint64_t v175 = __cxa_allocate_exception(0x18uLL);
              *(_DWORD *)uint64_t v175 = 102;
              v175[1] = "Array index must be larger than one";
              *((unsigned char *)v175 + 16) = 0;
            }
            if (a6) {
              *a6 = v101;
            }
            std::string::size_type v106 = std::string::find(&v212, 58, 0);
            memset(&v210, 0, sizeof(v210));
            std::string::basic_string(&v210, &v212, 0, v106, (std::allocator<char> *)&v204);
            (*(void (**)(void **__return_ptr))(*(void *)v214 + 80))(__p);
            unsigned int v107 = __p[0];
            int64_t size = (std::__shared_weak_count *)__p[1];
            MEMORY[0x18C11BE10](&v211, "[]");
            uint64_t v16 = (std::__shared_weak_count *)v215.n128_u64[1];
            unint64_t v108 = v215.n128_u64[0];
            if (v215.n128_u64[1]) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v215.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
            }
            if (v20) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v20);
            }
            (*(void (**)(void **__return_ptr))(*(void *)v209.__r_.__value_.__l.__data_ + 656))(__p);
            __n128 v17 = *(__n128 *)__p;
            __p[0] = 0;
            __p[1] = 0;
            unsigned int v109 = (std::__shared_weak_count *)v215.n128_u64[1];
            __n128 v215 = v17;
            if (v109)
            {
              std::__shared_weak_count::__release_shared[abi:ne180100](v109);
              if (__p[1]) {
                std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__p[1]);
              }
            }
            if (v215.n128_u64[0]) {
              int v34 = 4;
            }
            else {
              int v34 = 1;
            }
            if (v215.n128_u64[0] || (v11 & 1) == 0)
            {
              unint64_t v19 = v184;
              goto LABEL_390;
            }
            __p[0] = 0;
            __p[1] = 0;
            (*(void (**)(void **__return_ptr, unint64_t))(*(void *)v108 + 248))(__p, v108);
            if ((*(uint64_t (**)(char *))(*(void *)((char *)__p[0] + *(void *)(*(void *)__p[0] - 688))
                                                   + 560))((char *)__p[0] + *(void *)(*(void *)__p[0] - 688))
               + 1 >= v101)
            {
              if (v18 == ((v12[1] - *v12) >> 5) - 1)
              {
                *(_OWORD *)&v204.__r_.__value_.__l.__data_ = 0uLL;
                if (v107) {
                  uint64_t v110 = (AdobeXMPCore::ISimpleNode_v1 *)(*(uint64_t (**)(void *))(*(void *)v107 + 192))(v107);
                }
                else {
                  uint64_t v110 = (AdobeXMPCore::ISimpleNode_v1 *)"http://ns.adobe.com/xap/1.0/";
                }
                if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  uint64_t v140 = &v211;
                }
                else {
                  uint64_t v140 = (std::string *)v211.__r_.__value_.__r.__words[0];
                }
                XMPUtils::CreateTerminalNode(v110, (const char *)v140, (const char *)v176, &v204);
                (*(void (**)(void *, std::string *, unint64_t))(*(void *)__p[0] + 664))(__p[0], &v204, v101);
                __n128 v141 = *(__n128 *)&v204.__r_.__value_.__l.__data_;
                if (v204.__r_.__value_.__l.__size_) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v204.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
                }
                uint64_t v142 = (std::__shared_weak_count *)v215.n128_u64[1];
                __n128 v215 = v141;
                if (v142) {
                  std::__shared_weak_count::__release_shared[abi:ne180100](v142);
                }
                if (!v178)
                {
                  int v143 = (std::__shared_weak_count *)v215.n128_u64[1];
                  unint64_t v184 = v215.n128_u64[0];
                  if (v215.n128_u64[1]) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v215.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
                  }
                  if (v181) {
                    std::__shared_weak_count::__release_shared[abi:ne180100](v181);
                  }
                  int v178 = 1;
                  uint64_t v181 = v143;
                }
                unint64_t v19 = v184;
                if (v204.__r_.__value_.__l.__size_) {
                  std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v204.__r_.__value_.__l.__size_);
                }
                int v34 = 0;
                goto LABEL_388;
              }
              int v121 = *(_DWORD *)(*v12 + 32 * v18 + 56);
              if ((v121 - 3) < 4)
              {
                *(_OWORD *)&v204.__r_.__value_.__l.__data_ = 0uLL;
                uint64_t v122 = (AdobeXMPCore::IArrayNode_v1 *)(*(uint64_t (**)(void *))(*(void *)v107 + 192))(v107);
                int v123 = (char *)(*(uint64_t (**)(void *))(*(void *)v107 + 208))(v107);
                if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  unsigned int v124 = &v211;
                }
                else {
                  unsigned int v124 = (std::string *)v211.__r_.__value_.__r.__words[0];
                }
                if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  std::string::size_type v125 = HIBYTE(v211.__r_.__value_.__r.__words[2]);
                }
                else {
                  std::string::size_type v125 = v211.__r_.__value_.__l.__size_;
                }
                AdobeXMPCore::IArrayNode_v1::CreateOrderedArrayNode(v122, v123, (unint64_t)v124, (const char *)v125);
              }
              if (v121 == 2)
              {
                *(_OWORD *)&v204.__r_.__value_.__l.__data_ = 0uLL;
                uint64_t v152 = (AdobeXMPCore::ISimpleNode_v1 *)(*(uint64_t (**)(void *))(*(void *)v107 + 192))(v107);
                uint64_t v153 = (const char *)(*(uint64_t (**)(void *))(*(void *)v107 + 208))(v107);
                if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  uint64_t v154 = &v211;
                }
                else {
                  uint64_t v154 = (std::string *)v211.__r_.__value_.__r.__words[0];
                }
                if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  std::string::size_type v155 = HIBYTE(v211.__r_.__value_.__r.__words[2]);
                }
                else {
                  std::string::size_type v155 = v211.__r_.__value_.__l.__size_;
                }
                AdobeXMPCore::ISimpleNode_v1::CreateSimpleNode(v152, v153, (const char *)v154, (const char *)v155, 0, (const char *)0xFFFFFFFFFFFFFFFFLL);
              }
              if (v121 == 1)
              {
                *(_OWORD *)&v204.__r_.__value_.__l.__data_ = 0uLL;
                uint64_t v131 = (AdobeXMPCore::IStructureNode_v1 *)(*(uint64_t (**)(void *))(*(void *)v107 + 192))(v107);
                uint64_t v132 = (char *)(*(uint64_t (**)(void *))(*(void *)v107 + 208))(v107);
                if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  uint64_t v133 = &v211;
                }
                else {
                  uint64_t v133 = (std::string *)v211.__r_.__value_.__r.__words[0];
                }
                if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                  std::string::size_type v134 = HIBYTE(v211.__r_.__value_.__r.__words[2]);
                }
                else {
                  std::string::size_type v134 = v211.__r_.__value_.__l.__size_;
                }
                AdobeXMPCore::IStructureNode_v1::CreateStructureNode(v131, v132, (const char *)v133, (const char *)v134);
              }
              int v34 = 0;
            }
            else
            {
              int v34 = 5;
            }
            unint64_t v19 = v184;
LABEL_388:
            if (__p[1]) {
              std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__p[1]);
            }
LABEL_390:
            if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(v210.__r_.__value_.__l.__data_);
            }
            if (v209.__r_.__value_.__l.__size_)
            {
              std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v209.__r_.__value_.__l.__size_);
              if (!v34) {
                goto LABEL_417;
              }
              goto LABEL_418;
            }
            goto LABEL_416;
          }
LABEL_488:
          __assert_rtn("FindNode", "XMPUtils.cpp", 577, "(stepStr.length() >= 2) && (*(stepStr.begin()) == '[') && (stepStr[stepStr.length() - 1] == ']')");
        case 4:
          if ((*(unsigned int (**)(unint64_t))(*(void *)v215.n128_u64[0] + 40))(v215.n128_u64[0]) != 2)
          {
LABEL_492:
            uint64_t v174 = __cxa_allocate_exception(0x18uLL);
            *(_DWORD *)uint64_t v174 = 102;
            v174[1] = "Indexing applied to non-array";
            *((unsigned char *)v174 + 16) = 0;
          }
          unint64_t v60 = v19;
          __p[0] = 0;
          __p[1] = 0;
          (*(void (**)(void **__return_ptr))(*(void *)v215.n128_u64[0] + 248))(__p);
          std::string::size_type v61 = std::string::find(&v212, 58, 0);
          memset(&v210, 0, sizeof(v210));
          std::string::basic_string(&v210, &v212, 0, v61, (std::allocator<char> *)&v204);
          (*(void (**)(std::string *__return_ptr))(*(void *)v214 + 80))(&v209);
          int64_t size = (std::__shared_weak_count *)v209.__r_.__value_.__l.__size_;
          std::string::size_type v62 = v209.__r_.__value_.__r.__words[0];
          std::string::basic_string(&v209, &v212, v61 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v204);
          if (SHIBYTE(v211.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v211.__r_.__value_.__l.__data_);
          }
          std::string v211 = v209;
          __n128 v63 = v215;
          if (v215.n128_u64[1]) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v215.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
          }
          *(_OWORD *)&v209.__r_.__value_.__l.__data_ = 0uLL;
          (*(void (**)(std::string *__return_ptr, unint64_t))(*(void *)v63.n128_u64[0] + 248))(&v209, v63.n128_u64[0]);
          if ((*(unsigned int (**)(unint64_t))(*(void *)v63.n128_u64[0] + 40))(v63.n128_u64[0]) == 2)
          {
            (*(void (**)(std::string *__return_ptr, unint64_t))(*(void *)v63.n128_u64[0] + 248))(&v204, v63.n128_u64[0]);
            uint64_t v64 = (*(uint64_t (**)(std::string::size_type))(*(void *)(v204.__r_.__value_.__r.__words[0]
                                                                                + *(void *)(*(void *)v204.__r_.__value_.__l.__data_
                                                                                            - 688))
                                                                    + 560))(v204.__r_.__value_.__r.__words[0] + *(void *)(*(void *)v204.__r_.__value_.__l.__data_ - 688));
            if (v204.__r_.__value_.__l.__size_) {
              std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v204.__r_.__value_.__l.__size_);
            }
            if (v179) {
              _DWORD *v179 = v64 + 1;
            }
            if (v64)
            {
              (*(void (**)(std::string *__return_ptr))(*(void *)v209.__r_.__value_.__l.__data_ + 656))(&v204);
              __n128 v17 = *(__n128 *)&v204.__r_.__value_.__l.__data_;
              *(_OWORD *)&v204.__r_.__value_.__l.__data_ = 0uLL;
              int v65 = (std::__shared_weak_count *)v215.n128_u64[1];
              __n128 v215 = v17;
              unint64_t v19 = v60;
              if (!v65)
              {
LABEL_123:
                LOBYTE(v41) = 0;
                int v34 = 4;
LABEL_215:
                if (v209.__r_.__value_.__l.__size_) {
                  std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v209.__r_.__value_.__l.__size_);
                }
                if (v63.n128_u64[1]) {
                  std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v63.n128_u64[1]);
                }
                if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(v210.__r_.__value_.__l.__data_);
                }
                a6 = v179;
                if (__p[1]) {
                  std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__p[1]);
                }
                goto LABEL_340;
              }
              std::__shared_weak_count::__release_shared[abi:ne180100](v65);
LABEL_121:
              if (v204.__r_.__value_.__l.__size_) {
                std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v204.__r_.__value_.__l.__size_);
              }
              goto LABEL_123;
            }
            if (v11)
            {
              unint64_t v19 = v60;
              if (v18 != ((v12[1] - *v12) >> 5) - 1)
              {
                int v135 = *(_DWORD *)(*v12 + 32 * v18 + 56);
                if ((v135 - 3) < 4)
                {
                  *(_OWORD *)&v204.__r_.__value_.__l.__data_ = 0uLL;
                  unsigned int v136 = (AdobeXMPCore::IArrayNode_v1 *)(*(uint64_t (**)(std::string::size_type))(*(void *)v62 + 192))(v62);
                  uint64_t v137 = (char *)(*(uint64_t (**)(std::string::size_type))(*(void *)v62 + 208))(v62);
                  if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    uint64_t v138 = &v211;
                  }
                  else {
                    uint64_t v138 = (std::string *)v211.__r_.__value_.__r.__words[0];
                  }
                  if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    std::string::size_type v139 = HIBYTE(v211.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    std::string::size_type v139 = v211.__r_.__value_.__l.__size_;
                  }
                  AdobeXMPCore::IArrayNode_v1::CreateOrderedArrayNode(v136, v137, (unint64_t)v138, (const char *)v139);
                }
                if (v135 == 1)
                {
                  *(_OWORD *)&v204.__r_.__value_.__l.__data_ = 0uLL;
                  uint64_t v156 = (AdobeXMPCore::IStructureNode_v1 *)(*(uint64_t (**)(std::string::size_type))(*(void *)v62 + 192))(v62);
                  unint64_t v157 = (char *)(*(uint64_t (**)(std::string::size_type))(*(void *)v62 + 208))(v62);
                  if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    float v158 = &v211;
                  }
                  else {
                    float v158 = (std::string *)v211.__r_.__value_.__r.__words[0];
                  }
                  if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    std::string::size_type v159 = HIBYTE(v211.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    std::string::size_type v159 = v211.__r_.__value_.__l.__size_;
                  }
                  AdobeXMPCore::IStructureNode_v1::CreateStructureNode(v156, v157, (const char *)v158, (const char *)v159);
                }
                if (v135 == 2)
                {
                  *(_OWORD *)&v204.__r_.__value_.__l.__data_ = 0uLL;
                  uint64_t v144 = (AdobeXMPCore::ISimpleNode_v1 *)(*(uint64_t (**)(std::string::size_type))(*(void *)v62 + 192))(v62);
                  uint64_t v145 = (const char *)(*(uint64_t (**)(std::string::size_type))(*(void *)v62 + 208))(v62);
                  if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    uint64_t v146 = &v211;
                  }
                  else {
                    uint64_t v146 = (std::string *)v211.__r_.__value_.__r.__words[0];
                  }
                  if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                    std::string::size_type v147 = HIBYTE(v211.__r_.__value_.__r.__words[2]);
                  }
                  else {
                    std::string::size_type v147 = v211.__r_.__value_.__l.__size_;
                  }
                  AdobeXMPCore::ISimpleNode_v1::CreateSimpleNode(v144, v145, (const char *)v146, (const char *)v147, 0, (const char *)0xFFFFFFFFFFFFFFFFLL);
                }
                int v34 = 0;
                LOBYTE(v41) = 1;
                goto LABEL_215;
              }
              *(_OWORD *)&v204.__r_.__value_.__l.__data_ = 0uLL;
              unint64_t v111 = (AdobeXMPCore::ISimpleNode_v1 *)(*(uint64_t (**)(std::string::size_type))(*(void *)v62 + 192))(v62);
              if ((v211.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                size_t v112 = &v211;
              }
              else {
                size_t v112 = (std::string *)v211.__r_.__value_.__r.__words[0];
              }
              XMPUtils::CreateTerminalNode(v111, (const char *)v112, (const char *)v176, &v204);
              (*(void (**)(std::string::size_type, std::string *, uint64_t))(*(void *)v209.__r_.__value_.__l.__data_
                                                                                     + 664))(v209.__r_.__value_.__r.__words[0], &v204, 1);
              __n128 v113 = *(__n128 *)&v204.__r_.__value_.__l.__data_;
              if (v204.__r_.__value_.__l.__size_) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v204.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
              }
              unsigned int v114 = (std::__shared_weak_count *)v215.n128_u64[1];
              __n128 v215 = v113;
              if (v114) {
                std::__shared_weak_count::__release_shared[abi:ne180100](v114);
              }
              if (!v178)
              {
                uint64_t v115 = (std::__shared_weak_count *)v215.n128_u64[1];
                unint64_t v19 = v215.n128_u64[0];
                if (v215.n128_u64[1]) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v215.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
                }
                if (v181) {
                  std::__shared_weak_count::__release_shared[abi:ne180100](v181);
                }
                int v178 = 1;
                uint64_t v181 = v115;
              }
              goto LABEL_121;
            }
            LOBYTE(v41) = 0;
            int v34 = 1;
          }
          else
          {
            int v34 = 0;
            LOBYTE(v41) = 1;
          }
          unint64_t v19 = v60;
          goto LABEL_215;
        case 5:
          if ((*(unsigned int (**)(unint64_t))(*(void *)v215.n128_u64[0] + 40))(v215.n128_u64[0]) != 2)
          {
            int64_t size = 0;
            int v34 = 5;
            uint64_t v16 = v20;
            goto LABEL_418;
          }
          uint64_t v207 = 0;
          unsigned int v208 = 0;
          unint64_t v182 = v19;
          (*(void (**)(uint64_t *__return_ptr))(*(void *)v215.n128_u64[0] + 248))(&v207);
          memset(&v210, 0, sizeof(v210));
          memset(&v209, 0, sizeof(v209));
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v206 = 0;
          SplitNameAndValue((uint64_t)&__str, (uint64_t)&v210, &v209);
          int v42 = (std::__shared_weak_count *)v215.n128_u64[1];
          unint64_t v41 = v215.n128_u64[0];
          if (v215.n128_u64[1]) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v215.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
          }
          std::string::size_type v43 = std::string::find(&v210, 58, 0);
          memset(&v204, 0, sizeof(v204));
          std::string::basic_string(&v204, &v210, 0, v43, (std::allocator<char> *)&__s1);
          (*(void (**)(void **__return_ptr))(*(void *)v214 + 80))(&__s1);
          uint64_t v44 = (*(uint64_t (**)(void *))(*(void *)__s1 + 192))(__s1);
          MEMORY[0x18C11BE10](__p, v44);
          if (__n) {
            std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__n);
          }
          if (!v41) {
            goto LABEL_280;
          }
          if ((*(unsigned int (**)(unint64_t))(*(void *)v41 + 40))(v41) == 2)
          {
            uint64_t v187 = v42;
            uint64_t v45 = v12;
            uint64_t v202 = 0;
            BOOL v203 = 0;
            (*(void (**)(uint64_t *__return_ptr, unint64_t))(*(void *)v41 + 248))(&v202, v41);
            uint64_t v46 = v11;
            uint64_t v47 = (*(uint64_t (**)(uint64_t))(*(void *)(v202 + *(void *)(*(void *)v202 - 688)) + 560))(v202 + *(void *)(*(void *)v202 - 688));
            if (v47)
            {
              unint64_t v48 = v47;
              char v49 = 0;
              uint64_t v50 = 1;
              while (1)
              {
                uint64_t v200 = 0;
                unsigned int v201 = 0;
                (*(void (**)(uint64_t *__return_ptr))(*(void *)v202 + 656))(&v200);
                __n128 v199 = 0uLL;
                (*(void (**)(__n128 *__return_ptr))(*(void *)v200 + 128))(&v199);
                if (v199.n128_u64[0])
                {
                  __s1 = 0;
                  size_t __n = 0;
                  uint64_t v198 = 0;
                  (*(void (**)(uint64_t *__return_ptr))(*(void *)v199.n128_u64[0] + 232))(&v193);
                  (*(void (**)(__n128 *__return_ptr))(*(void *)v193 + 504))(&v195);
                  int v51 = (char *)(*(uint64_t (**)(unint64_t))(*(void *)v195.n128_u64[0] + 192))(v195.n128_u64[0]);
                  std::string::basic_string[abi:ne180100]<0>(&__s1, v51);
                  if (v195.n128_u64[1]) {
                    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v195.n128_u64[1]);
                  }
                  if (v194) {
                    std::__shared_weak_count::__release_shared[abi:ne180100](v194);
                  }
                  uint64_t v52 = HIBYTE(v198);
                  if (v198 >= 0) {
                    size_t v53 = HIBYTE(v198);
                  }
                  else {
                    size_t v53 = __n;
                  }
                  std::string::size_type v54 = HIBYTE(v209.__r_.__value_.__r.__words[2]);
                  if ((v209.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                    std::string::size_type v54 = v209.__r_.__value_.__l.__size_;
                  }
                  if (v53 == v54)
                  {
                    if ((v209.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                      uint64_t v55 = &v209;
                    }
                    else {
                      uint64_t v55 = (std::string *)v209.__r_.__value_.__r.__words[0];
                    }
                    if (SHIBYTE(v198) < 0)
                    {
                      if (!memcmp(__s1, v55, __n))
                      {
LABEL_90:
                        (*(void (**)(__n128 *__return_ptr))(*(void *)v202 + 656))(&v195);
                        __n128 v17 = v195;
                        __n128 v195 = 0uLL;
                        __int16 v58 = (std::__shared_weak_count *)v215.n128_u64[1];
                        __n128 v215 = v17;
                        if (v58)
                        {
                          std::__shared_weak_count::__release_shared[abi:ne180100](v58);
                          if (v195.n128_u64[1]) {
                            std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v195.n128_u64[1]);
                          }
                        }
                        char v49 = 1;
                        int v57 = 13;
                        if ((v198 & 0x8000000000000000) == 0) {
                          goto LABEL_95;
                        }
                      }
                      else
                      {
                        int v57 = 0;
                      }
LABEL_94:
                      operator delete(__s1);
                      goto LABEL_95;
                    }
                    if (!HIBYTE(v198)) {
                      goto LABEL_90;
                    }
                    p_s1 = &__s1;
                    while (*(unsigned __int8 *)p_s1 == v55->__r_.__value_.__s.__data_[0])
                    {
                      p_s1 = (void **)((char *)p_s1 + 1);
                      uint64_t v55 = (std::string *)((char *)v55 + 1);
                      if (!--v52) {
                        goto LABEL_90;
                      }
                    }
                  }
                  int v57 = 0;
                  if (v198 < 0) {
                    goto LABEL_94;
                  }
                }
                else
                {
                  int v57 = 15;
                }
LABEL_95:
                if (v199.n128_u64[1]) {
                  std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v199.n128_u64[1]);
                }
                if (v201) {
                  std::__shared_weak_count::__release_shared[abi:ne180100](v201);
                }
                if ((v57 == 15 || !v57) && ++v50 <= v48) {
                  continue;
                }
                goto LABEL_321;
              }
            }
            char v49 = 0;
LABEL_321:
            if (v203) {
              std::__shared_weak_count::__release_shared[abi:ne180100](v203);
            }
            LOBYTE(v41) = v49;
            if (v49) {
              int v34 = 0;
            }
            else {
              int v34 = 5;
            }
            unint64_t v19 = v182;
            uint64_t v11 = v46;
            uint64_t v12 = v45;
            int v42 = v187;
          }
          else
          {
            LOBYTE(v41) = 0;
LABEL_280:
            int v34 = 5;
            unint64_t v19 = v182;
          }
          if (SHIBYTE(v204.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v204.__r_.__value_.__l.__data_);
          }
          if (v42) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v42);
          }
          if (SHIBYTE(v206) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v209.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v209.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v210.__r_.__value_.__l.__data_);
          }
          if (v208) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v208);
          }
          int64_t size = 0;
LABEL_340:
          uint64_t v16 = v20;
          if (v41) {
            goto LABEL_417;
          }
          goto LABEL_418;
        case 6:
          memset(&v210, 0, sizeof(v210));
          memset(&v209, 0, sizeof(v209));
          __p[0] = 0;
          __p[1] = 0;
          uint64_t v206 = 0;
          unint64_t v183 = v19;
          SplitNameAndValue((uint64_t)&__str, (uint64_t)&v210, &v209);
          __n128 v83 = v215;
          if (v215.n128_u64[1]) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v215.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
          }
          std::string::size_type v84 = std::string::find(&v210, 58, 0);
          memset(&v204, 0, sizeof(v204));
          std::string::basic_string(&v204, &v210, 0, v84, (std::allocator<char> *)&__s1);
          (*(void (**)(void **__return_ptr))(*(void *)v214 + 80))(&__s1);
          uint64_t v85 = (*(uint64_t (**)(void *))(*(void *)__s1 + 192))(__s1);
          MEMORY[0x18C11BE10](__p, v85);
          if (__n) {
            std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__n);
          }
          if (!v83.n128_u64[0]
            || (*(unsigned int (**)(unint64_t))(*(void *)v83.n128_u64[0] + 40))(v83.n128_u64[0]) != 2)
          {
            int v34 = 5;
            unint64_t v19 = v183;
            goto LABEL_307;
          }
          uint64_t v86 = v12;
          uint64_t v87 = v11;
          uint64_t v207 = 0;
          unsigned int v208 = 0;
          (*(void (**)(uint64_t *__return_ptr, unint64_t))(*(void *)v83.n128_u64[0] + 248))(&v207, v83.n128_u64[0]);
          uint64_t v88 = (*(uint64_t (**)(uint64_t))(*(void *)(v207 + *(void *)(*(void *)v207 - 688)) + 560))(v207 + *(void *)(*(void *)v207 - 688));
          if (!v88)
          {
            char v126 = 0;
            int v34 = 0;
            unint64_t v19 = v183;
            uint64_t v12 = v86;
            goto LABEL_301;
          }
          unint64_t v89 = v88;
          char v188 = 0;
          uint64_t v90 = 1;
          break;
        default:
          int64_t size = 0;
          uint64_t v16 = v20;
          goto LABEL_417;
      }
      while (1)
      {
        uint64_t v202 = 0;
        BOOL v203 = 0;
        (*(void (**)(uint64_t *__return_ptr))(*(void *)v207 + 656))(&v202);
        if ((*(unsigned int (**)(uint64_t))(*(void *)v202 + 40))(v202) != 4)
        {
          int v34 = 5;
          goto LABEL_194;
        }
        uint64_t v200 = 0;
        unsigned int v201 = 0;
        (*(void (**)(void **__return_ptr))(*(void *)v202 + 240))(&__s1);
        (*(void (**)(uint64_t *__return_ptr))(*(void *)__s1 + 648))(&v200);
        if (__n) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__n);
        }
        if (!v200 || (*(unsigned int (**)(uint64_t))(*(void *)v200 + 40))(v200) != 1)
        {
          int v34 = 18;
          goto LABEL_192;
        }
        __s1 = 0;
        size_t __n = 0;
        uint64_t v198 = 0;
        (*(void (**)(__n128 *__return_ptr))(*(void *)v200 + 232))(&v195);
        (*(void (**)(__n128 *__return_ptr))(*(void *)v195.n128_u64[0] + 504))(&v199);
        uint64_t v91 = (char *)(*(uint64_t (**)(unint64_t))(*(void *)v199.n128_u64[0] + 192))(v199.n128_u64[0]);
        std::string::basic_string[abi:ne180100]<0>(&__s1, v91);
        if (v199.n128_u64[1]) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v199.n128_u64[1]);
        }
        if (v195.n128_u64[1]) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v195.n128_u64[1]);
        }
        uint64_t v92 = HIBYTE(v198);
        if (v198 >= 0) {
          size_t v93 = HIBYTE(v198);
        }
        else {
          size_t v93 = __n;
        }
        std::string::size_type v94 = HIBYTE(v209.__r_.__value_.__r.__words[2]);
        if ((v209.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
          std::string::size_type v94 = v209.__r_.__value_.__l.__size_;
        }
        if (v93 != v94) {
          goto LABEL_200;
        }
        uint64_t v95 = (v209.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
            ? &v209
            : (std::string *)v209.__r_.__value_.__r.__words[0];
        if ((SHIBYTE(v198) & 0x80000000) == 0) {
          break;
        }
        if (!memcmp(__s1, v95, __n)) {
          goto LABEL_204;
        }
        int v34 = 0;
LABEL_208:
        operator delete(__s1);
LABEL_192:
        if (v201) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v201);
        }
LABEL_194:
        if (v203) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v203);
        }
        if (v34 && v34 != 18)
        {
          unint64_t v19 = v183;
          uint64_t v11 = v87;
          if (v34 == 16) {
            int v34 = 0;
          }
LABEL_300:
          uint64_t v12 = v86;
          char v126 = v188;
LABEL_301:
          if (v208) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v208);
          }
          if (!v34)
          {
            if (v126) {
              int v34 = 0;
            }
            else {
              int v34 = 5;
            }
          }
LABEL_307:
          if (SHIBYTE(v204.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v204.__r_.__value_.__l.__data_);
          }
          if (v83.n128_u64[1]) {
            std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v83.n128_u64[1]);
          }
          if (SHIBYTE(v206) < 0) {
            operator delete(__p[0]);
          }
          if (SHIBYTE(v209.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v209.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(v210.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v210.__r_.__value_.__l.__data_);
          }
          int64_t size = 0;
          uint64_t v16 = v20;
          if (!v34) {
LABEL_417:
          }
            int v34 = 0;
LABEL_418:
          if (SHIBYTE(v211.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v211.__r_.__value_.__l.__data_);
          }
          if (size) {
            std::__shared_weak_count::__release_shared[abi:ne180100](size);
          }
          if (SHIBYTE(v212.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v212.__r_.__value_.__l.__data_);
          }
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          switch(v34)
          {
            case 0:
            case 4:
              ++v18;
              long long v20 = v16;
              if (v18 == v185) {
                goto LABEL_448;
              }
              goto LABEL_17;
            case 2:
              goto LABEL_448;
            case 5:
              unint64_t v21 = v215.n128_u64[0];
              goto LABEL_466;
            default:
              goto LABEL_486;
          }
        }
        if (++v90 > v89)
        {
          int v34 = 0;
          unint64_t v19 = v183;
          uint64_t v11 = v87;
          goto LABEL_300;
        }
      }
      if (HIBYTE(v198))
      {
        uint64_t v96 = &__s1;
        while (*(unsigned __int8 *)v96 == v95->__r_.__value_.__s.__data_[0])
        {
          uint64_t v96 = (void **)((char *)v96 + 1);
          uint64_t v95 = (std::string *)((char *)v95 + 1);
          if (!--v92) {
            goto LABEL_204;
          }
        }
LABEL_200:
        int v34 = 0;
        if ((v198 & 0x8000000000000000) == 0) {
          goto LABEL_192;
        }
        goto LABEL_208;
      }
LABEL_204:
      (*(void (**)(__n128 *__return_ptr))(*(void *)v207 + 656))(&v199);
      __n128 v17 = v199;
      __n128 v199 = 0uLL;
      uint64_t v97 = (std::__shared_weak_count *)v215.n128_u64[1];
      __n128 v215 = v17;
      if (v97)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v97);
        if (v199.n128_u64[1]) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v199.n128_u64[1]);
        }
      }
      char v188 = 1;
      int v34 = 16;
      if ((v198 & 0x8000000000000000) == 0) {
        goto LABEL_192;
      }
      goto LABEL_208;
    }
    uint64_t v16 = v20;
LABEL_466:
    uint64_t v162 = 0;
    if (v21 || !v178) {
      goto LABEL_453;
    }
    *(_OWORD *)&__str.__r_.__value_.__l.__data_ = 0uLL;
    (*(void (**)(std::string *__return_ptr, unint64_t, __n128))(*(void *)v19 + 56))(&__str, v19, v17);
    if ((*(unsigned int (**)(std::string::size_type))(*(void *)__str.__r_.__value_.__l.__data_ + 40))(__str.__r_.__value_.__r.__words[0]) == 2)
    {
      (*(void (**)(std::string *__return_ptr))(*(void *)__str.__r_.__value_.__l.__data_ + 248))(&v212);
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v212.__r_.__value_.__l.__data_ + 680))(&v191);
      int v166 = v192;
      if (!v192) {
        goto LABEL_471;
      }
    }
    else
    {
      if ((*(unsigned int (**)(std::string::size_type))(*(void *)__str.__r_.__value_.__l.__data_ + 40))(__str.__r_.__value_.__r.__words[0]) != 4) {
        goto LABEL_484;
      }
      (*(void (**)(std::string *__return_ptr))(*(void *)__str.__r_.__value_.__l.__data_ + 240))(&v212);
      std::string::size_type v167 = v212.__r_.__value_.__r.__words[0];
      (*(void (**)(std::string *__return_ptr, unint64_t))(*(void *)v19 + 88))(&v211, v19);
      unint64_t v168 = v19;
      uint64_t v169 = (*(uint64_t (**)(std::string::size_type))(*(void *)v211.__r_.__value_.__l.__data_ + 192))(v211.__r_.__value_.__r.__words[0]);
      (*(void (**)(std::string *__return_ptr, unint64_t))(*(void *)v168 + 88))(&v210, v168);
      uint64_t v170 = (*(uint64_t (**)(std::string::size_type))(*(void *)v210.__r_.__value_.__l.__data_ + 208))(v210.__r_.__value_.__r.__words[0]);
      (*(void (**)(std::string *__return_ptr, unint64_t))(*(void *)v168 + 72))(&v209, v168);
      uint64_t v171 = (*(uint64_t (**)(std::string::size_type))(*(void *)v209.__r_.__value_.__l.__data_ + 192))(v209.__r_.__value_.__r.__words[0]);
      (*(void (**)(void **__return_ptr, unint64_t))(*(void *)v168 + 72))(__p, v168);
      uint64_t v172 = (*(uint64_t (**)(void *))(*(void *)__p[0] + 208))(__p[0]);
      (*(void (**)(uint64_t *__return_ptr, std::string::size_type, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v167 + 672))(&v189, v167, v169, v170, v171, v172);
      if (v190) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v190);
      }
      if (__p[1]) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__p[1]);
      }
      if (v209.__r_.__value_.__l.__size_) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v209.__r_.__value_.__l.__size_);
      }
      if (v210.__r_.__value_.__l.__size_) {
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v210.__r_.__value_.__l.__size_);
      }
      int v166 = (std::__shared_weak_count *)v211.__r_.__value_.__l.__size_;
      if (!v211.__r_.__value_.__l.__size_)
      {
LABEL_471:
        if (v212.__r_.__value_.__l.__size_) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v212.__r_.__value_.__l.__size_);
        }
LABEL_484:
        if (__str.__r_.__value_.__l.__size_) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)__str.__r_.__value_.__l.__size_);
        }
LABEL_486:
        uint64_t v162 = 0;
        goto LABEL_453;
      }
    }
    std::__shared_weak_count::__release_shared[abi:ne180100](v166);
    goto LABEL_471;
  }
  long long v163 = 0;
  uint64_t v162 = 0;
LABEL_455:
  if (*((void *)&v214 + 1))
  {
    long long v164 = v163;
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v214 + 1));
    long long v163 = v164;
  }
  if (v163) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v163);
  }
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  if (v215.n128_u64[1]) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v215.n128_u64[1]);
  }
  return v162;
}