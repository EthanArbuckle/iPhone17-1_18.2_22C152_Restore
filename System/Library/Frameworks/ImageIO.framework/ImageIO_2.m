uint64_t merged_1v_upsample(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  uint64_t result;

  result = (*(uint64_t (**)(void))(*(void *)(a1 + 640) + 24))();
  ++*a6;
  ++*a3;
  return result;
}

uint64_t h2v1_merged_upsample(uint64_t result, void *a2, unsigned int a3, unsigned char **a4)
{
  v4 = *(void **)(result + 640);
  uint64_t v5 = *(void *)(result + 440);
  uint64_t v7 = v4[4];
  uint64_t v6 = v4[5];
  uint64_t v8 = v4[6];
  uint64_t v9 = v4[7];
  v10 = *(unsigned __int8 **)(*a2 + 8 * a3);
  v11 = *(unsigned __int8 **)(a2[1] + 8 * a3);
  v12 = *(unsigned __int8 **)(a2[2] + 8 * a3);
  v13 = *a4;
  unsigned int v14 = *(_DWORD *)(result + 136);
  if (v14 < 2)
  {
    if ((v14 & 1) == 0) {
      return result;
    }
LABEL_7:
    uint64_t v25 = *v11;
    uint64_t v26 = *v12;
    uint64_t v27 = (*(void *)(v8 + 8 * v26) + *(void *)(v9 + 8 * v25)) >> 16;
    uint64_t v28 = *(int *)(v6 + 4 * v25);
    uint64_t v29 = *v10;
    unsigned char *v13 = *(unsigned char *)(v5 + *(int *)(v7 + 4 * v26) + v29);
    v13[1] = *(unsigned char *)(v5 + v29 + (int)v27);
    v13[2] = *(unsigned char *)(v5 + v28 + v29);
    return result;
  }
  unsigned int v15 = v14 >> 1;
  do
  {
    unsigned int v17 = *v11++;
    uint64_t v16 = v17;
    unsigned int v18 = *v12++;
    uint64_t v19 = *(int *)(v7 + 4 * v18);
    uint64_t v20 = (*(void *)(v8 + 8 * v18) + *(void *)(v9 + 8 * v16)) >> 16;
    uint64_t v21 = *(int *)(v6 + 4 * v16);
    uint64_t v22 = *v10;
    unsigned char *v13 = *(unsigned char *)(v5 + v19 + v22);
    v13[1] = *(unsigned char *)(v5 + v22 + (int)v20);
    v13[2] = *(unsigned char *)(v5 + v21 + v22);
    v23 = v10 + 2;
    uint64_t v24 = v10[1];
    v13[3] = *(unsigned char *)(v5 + v19 + v24);
    v13[4] = *(unsigned char *)(v5 + v24 + (int)v20);
    v13[5] = *(unsigned char *)(v5 + v21 + v24);
    v13 += 6;
    v10 = v23;
    --v15;
  }
  while (v15);
  v10 = v23;
  if (*(_DWORD *)(result + 136)) {
    goto LABEL_7;
  }
  return result;
}

uint64_t mq_decoder::start(uint64_t this, unsigned __int8 *a2, int a3, int a4)
{
  if (*(unsigned char *)(this + 38)) {
    mq_decoder::start();
  }
  uint64_t v4 = this;
  if (*(void *)(this + 16)) {
    mq_decoder::start();
  }
  if (!a2 || a3 < 0) {
    mq_decoder::start();
  }
  if (!*(unsigned char *)(this + 39))
  {
    uint64_t v5 = 0;
    uint64_t v6 = &dword_1E91048A0;
    do
    {
      uint64_t v7 = dword_18898D9B0[v5 >> 1];
      *(v6 - 4) = v5 & 1 | (mq_decoder::p_bar_table[v7] << 8);
      *((void *)v6 - 1) = (char *)&mq_decoder::transition_table + 32 * (v5 & 1 | (2 * v7));
      uint64_t v8 = dword_18898DA6C[v5 >> 1];
      this = mq_decoder::p_bar_table[v5 >> 1];
      BOOL v10 = v5 >> 1 != 46 && this == 22017;
      int v11 = v5 & 1 ^ v10;
      *uint64_t v6 = v11 | (mq_decoder::p_bar_table[v8] << 8);
      *((void *)v6 + 1) = (char *)&mq_decoder::transition_table + 32 * (v11 | (2 * v8));
      ++v5;
      v6 += 8;
    }
    while (v5 != 94);
    *(unsigned char *)(v4 + 39) = 1;
  }
  *(unsigned char *)(v4 + 38) = 1;
  *(unsigned char *)(v4 + 37) = a4;
  *(void *)(v4 + 16) = a2;
  *(void *)(v4 + 24) = a2;
  *(_DWORD *)(v4 + 40) = a3;
  v12 = &a2[a3];
  *(unsigned char *)(v4 + 44) = *v12;
  *(unsigned char *)(v4 + 45) = v12[1];
  *(_WORD *)v12 = -1;
  *(unsigned char *)(v4 + 36) = 0;
  if (a4)
  {
    *(_DWORD *)(v4 + 32) = 0;
    *(void *)(v4 + 8) = 0;
    *(_DWORD *)(v4 + 4) = 0;
    mq_decoder::fill_lsbs(v4);
    *(_DWORD *)(v4 + 4) <<= *(_DWORD *)(v4 + 8);
    this = mq_decoder::fill_lsbs(v4);
    int32x2_t v13 = *(int32x2_t *)(v4 + 4);
    LODWORD(v14) = vshl_n_s32(v13, 7uLL).u32[0];
    HIDWORD(v14) = vadd_s32(v13, (int32x2_t)0x600000006).i32[1];
    *(void *)(v4 + 4) = v14;
    *(_DWORD *)uint64_t v4 = 0x800000;
  }
  else
  {
    *(void *)(v4 + 8) = 0;
  }
  return this;
}

uint64_t mq_decoder::fill_lsbs(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 12);
  v2 = *(unsigned __int8 **)(this + 24);
  *(void *)(this + 24) = v2 + 1;
  unsigned int v3 = *v2;
  if (v1 != 255)
  {
    int v4 = 8;
LABEL_6:
    *(_DWORD *)(this + 8) = v4;
    *(_DWORD *)(this + 12) = v3;
    goto LABEL_7;
  }
  if (v3 < 0x90)
  {
    v3 *= 2;
    int v4 = 7;
    goto LABEL_6;
  }
  *(void *)(this + 24) = v2;
  *(void *)(this + 8) = 0xFF00000008;
  ++*(_DWORD *)(this + 32);
  unsigned int v3 = 255;
LABEL_7:
  *(_DWORD *)(this + 4) += v3;
  return this;
}

uint64_t mq_decoder::finish(mq_decoder *this, char a2)
{
  if (!*((unsigned char *)this + 38) || *((unsigned char *)this + 36)) {
    mq_decoder::finish();
  }
  if (a2)
  {
    uint64_t v3 = *((void *)this + 2);
    v2 = (unsigned __int8 *)*((void *)this + 3);
    uint64_t v4 = *((int *)this + 10);
    uint64_t v5 = (unsigned __int8 *)(v3 + v4);
    if (*((unsigned char *)this + 37))
    {
      if ((unint64_t)v2 > v3 + v4)
      {
        if (v2 != v5 + 1) {
          mq_decoder::finish();
        }
        int v6 = *((_DWORD *)this + 8);
        int v7 = v6 + 1;
        *((_DWORD *)this + 8) = v6 + 1;
        int v8 = *((_DWORD *)this + 2);
        if (!v8)
        {
          int v7 = v6 + 2;
          *((_DWORD *)this + 8) = v6 + 2;
          LOBYTE(v8) = 8;
          *((_DWORD *)this + 2) = 8;
        }
        if ((v7 - 4) >= 0xFFFFFFFE && !(*((int *)this + 1) >> (24 - v8))) {
          goto LABEL_13;
        }
      }
LABEL_20:
      uint64_t v9 = 0;
      goto LABEL_21;
    }
    if ((unint64_t)v2 < v3 + v4 && *((_DWORD *)this + 3) == 255 && !*((_DWORD *)this + 2))
    {
      v12 = v2 + 1;
      *((void *)this + 3) = v2 + 1;
      int v13 = *v2;
      *((_DWORD *)this + 2) = 8;
      *((_DWORD *)this + 3) = v13;
      unsigned int v10 = 42;
      v2 = v12;
    }
    else
    {
      unsigned int v10 = 85;
    }
    if (v2 != v5 || (*((_DWORD *)this + 3) & ~(-1 << *((_DWORD *)this + 2))) != v10 >> (8 - *((_DWORD *)this + 2))) {
      goto LABEL_20;
    }
  }
  else
  {
    uint64_t v3 = *((void *)this + 2);
    uint64_t v4 = *((int *)this + 10);
  }
LABEL_13:
  uint64_t v9 = 1;
LABEL_21:
  *(unsigned char *)(v3 + v4) = *((unsigned char *)this + 44);
  *(unsigned char *)(*((int *)this + 10) + *((void *)this + 2) + 1) = *((unsigned char *)this + 45);
  *((unsigned char *)this + 38) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  return v9;
}

void mq_decoder::mq_decode(mq_decode *this, int *a2, uint64_t a3)
{
  if (!*((unsigned char *)this + 37) || !*((unsigned char *)this + 38) || *((unsigned char *)this + 36)) {
    mq_decoder::mq_decode();
  }
  int v4 = *(_DWORD *)a3 & 1;
  *a2 = v4;
  int v5 = *(_DWORD *)a3 - v4;
  int v6 = *((_DWORD *)this + 1);
  int v7 = *(_DWORD *)this - v5;
  *(_DWORD *)this = v7;
  BOOL v8 = __OFSUB__(v6, v5);
  int v9 = v6 - v5;
  if (v9 < 0 != v8)
  {
    if (v7 >= v5)
    {
      *a2 = 1 - *a2;
      unsigned int v10 = (_OWORD *)(*(void *)(a3 + 8) + 16);
    }
    else
    {
      unsigned int v10 = *(_OWORD **)(a3 + 8);
    }
    *(_OWORD *)a3 = *v10;
    *(_DWORD *)this = v5;
    int v12 = *((_DWORD *)this + 2);
    do
    {
      if (!v12)
      {
        mq_decoder::fill_lsbs((uint64_t)this);
        int v5 = *(_DWORD *)this;
        int v12 = *((_DWORD *)this + 2);
      }
      int v13 = 2 * *((_DWORD *)this + 1);
      *(_DWORD *)this = 2 * v5;
      *((_DWORD *)this + 1) = v13;
      *((_DWORD *)this + 2) = --v12;
      BOOL v14 = v5 < 0x400000;
      v5 *= 2;
    }
    while (v14);
  }
  else
  {
    *((_DWORD *)this + 1) = v9;
    if (v7 < 0x800000)
    {
      if (v7 >= v5)
      {
        int v11 = *(_OWORD **)(a3 + 8);
      }
      else
      {
        *a2 = 1 - *a2;
        int v11 = (_OWORD *)(*(void *)(a3 + 8) + 16);
      }
      *(_OWORD *)a3 = *v11;
      int v15 = *((_DWORD *)this + 2);
      do
      {
        if (!v15)
        {
          mq_decoder::fill_lsbs((uint64_t)this);
          int v15 = *((_DWORD *)this + 2);
        }
        uint64_t v16 = *(void *)this;
        *(int32x2_t *)this = vadd_s32(*(int32x2_t *)this, *(int32x2_t *)this);
        *((_DWORD *)this + 2) = --v15;
      }
      while ((int)v16 < 0x400000);
    }
  }
}

void mq_decoder::mq_decode_run(mq_decoder *this, int *a2)
{
  if (!*((unsigned char *)this + 37) || !*((unsigned char *)this + 38) || *((unsigned char *)this + 36)) {
    mq_decoder::mq_decode_run();
  }
  v5[1] = &unk_1E9105410;
  int v4 = 0;
  v5[0] = (dword_1E90FD24C << 8);
  mq_decoder::mq_decode(this, &v4, (uint64_t)v5);
  *a2 = 2 * v4;
  mq_decoder::mq_decode(this, &v4, (uint64_t)v5);
  *a2 += v4;
}

uint64_t (**_cg_jinit_c_main_controller(int *a1, int a2))(uint64_t result, int a2)
{
  result = (uint64_t (**)(uint64_t, int))(**((uint64_t (***)(void))a1 + 1))();
  *((void *)a1 + 63) = result;
  *result = start_pass_main_0;
  if (!a1[72])
  {
    if (a2)
    {
      uint64_t v5 = *(void *)a1;
      *(_DWORD *)(v5 + 40) = 3;
      int v6 = *(uint64_t (**)(int *))v5;
      return (uint64_t (**)(uint64_t, int))v6(a1);
    }
    else if (a1[23] >= 1)
    {
      uint64_t v7 = 0;
      BOOL v8 = result + 4;
      int v9 = (int *)(*((void *)a1 + 13) + 40);
      do
      {
        uint64_t v10 = (*(v9 - 1) * *(v9 - 3));
        int v11 = *(v9 - 7);
        int v12 = *v9;
        v9 += 24;
        result = (uint64_t (**)(uint64_t, int))(*(uint64_t (**)(int *, uint64_t, uint64_t, void))(*((void *)a1 + 1) + 16))(a1, 1, v10, (v12 * v11));
        v8[v7++] = result;
      }
      while (v7 < a1[23]);
    }
  }
  return result;
}

uint64_t start_pass_main_0(uint64_t result, int a2)
{
  if (!*(_DWORD *)(result + 288))
  {
    uint64_t v2 = *(void *)(result + 504);
    *(void *)(v2 + 16) = 0;
    *(_DWORD *)(v2 + 24) = 0;
    *(_DWORD *)(v2 + 28) = a2;
    if (a2)
    {
      uint64_t v3 = *(void *)result;
      *(_DWORD *)(v3 + 40) = 3;
      return (*(uint64_t (**)(uint64_t))v3)(result);
    }
    else
    {
      *(void *)(v2 + 8) = process_data_simple_main_0;
    }
  }
  return result;
}

uint64_t process_data_simple_main_0(uint64_t result, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  int v4 = *(_DWORD **)(result + 504);
  if (v4[4] < *(_DWORD *)(result + 368))
  {
    uint64_t v8 = result;
    unsigned int v9 = v4[5];
    do
    {
      unsigned int v10 = *(_DWORD *)(v8 + 364);
      if (v9 < v10)
      {
        result = (*(uint64_t (**)(uint64_t, uint64_t, _DWORD *, uint64_t, _DWORD *, _DWORD *))(*(void *)(v8 + 512) + 8))(v8, a2, a3, a4, v4 + 8, v4 + 5);
        unsigned int v9 = v4[5];
        unsigned int v10 = *(_DWORD *)(v8 + 364);
      }
      if (v9 != v10) {
        break;
      }
      result = (*(uint64_t (**)(uint64_t, _DWORD *))(*(void *)(v8 + 520) + 8))(v8, v4 + 8);
      int v11 = v4[6];
      if (!result)
      {
        if (!v11)
        {
          --*a3;
          v4[6] = 1;
        }
        return result;
      }
      if (v11)
      {
        ++*a3;
        v4[6] = 0;
      }
      unsigned int v9 = 0;
      unsigned int v12 = v4[4] + 1;
      *((void *)v4 + 2) = v12;
    }
    while (v12 < *(_DWORD *)(v8 + 368));
  }
  return result;
}

uint64_t _cg_jpeg_abort(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  if (v1)
  {
    uint64_t v2 = result;
    result = (*(uint64_t (**)(void))(v1 + 72))();
    if (*(_DWORD *)(v2 + 32))
    {
      *(_DWORD *)(v2 + 36) = 200;
      *(void *)(v2 + 408) = 0;
    }
    else
    {
      *(_DWORD *)(v2 + 36) = 100;
    }
  }
  return result;
}

uint64_t _cg_jpeg_destroy(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 8);
  if (v2) {
    result = (*(uint64_t (**)(uint64_t))(v2 + 80))(result);
  }
  *(void *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 36) = 0;
  return result;
}

uint64_t _cg_jpeg_alloc_quant_table(uint64_t a1)
{
  uint64_t result = (**(uint64_t (***)(void))(a1 + 8))();
  *(_DWORD *)(result + 128) = 0;
  return result;
}

uint64_t _cg_jpeg_alloc_huff_table(uint64_t a1)
{
  uint64_t result = (**(uint64_t (***)(void))(a1 + 8))();
  *(_DWORD *)(result + 276) = 0;
  return result;
}

uint64_t _cg_jpeg_std_huff_table(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v4 = a1 + 192;
  if (a2) {
    uint64_t v4 = a1 + 160;
  }
  uint64_t v5 = a1 + 264;
  if (a2) {
    uint64_t v5 = a1 + 232;
  }
  if (*(_DWORD *)(a1 + 32)) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = v4;
  }
  if (a3 == 1)
  {
    BOOL v7 = a2 == 0;
    if (a2) {
      uint64_t v8 = (char *)&_cg_jpeg_std_huff_table_bits_dc_chrominance;
    }
    else {
      uint64_t v8 = (char *)&_cg_jpeg_std_huff_table_bits_ac_chrominance;
    }
    unsigned int v9 = &_cg_jpeg_std_huff_table_val_dc_chrominance;
    unsigned int v10 = &_cg_jpeg_std_huff_table_val_ac_chrominance;
LABEL_18:
    if (v7) {
      int v11 = v10;
    }
    else {
      int v11 = v9;
    }
    uint64_t v12 = *(void *)(v6 + 8 * a3);
    if (!v12)
    {
      uint64_t v13 = a3;
      uint64_t v12 = (**(uint64_t (***)(uint64_t, void, uint64_t))(a1 + 8))(a1, 0, 280);
      *(_DWORD *)(v12 + 276) = 0;
      *(void *)(v6 + 8 * v13) = v12;
    }
    *(_OWORD *)uint64_t v12 = *(_OWORD *)v8;
    *(unsigned char *)(v12 + 16) = v8[16];
    uint8x16_t v14 = *(uint8x16_t *)(v8 + 1);
    uint16x8_t v15 = vmovl_high_u8(v14);
    uint16x8_t v16 = vmovl_u8(*(uint8x8_t *)v14.i8);
    unsigned int v17 = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v16.i8, *(uint16x4_t *)v15.i8), (int32x4_t)vaddl_high_u16(v16, v15)));
    size_t v18 = v17;
    if (v17 < 0x101)
    {
      if (!v17)
      {
LABEL_28:
        *(_DWORD *)(v12 + 276) = 0;
        return v12;
      }
    }
    else
    {
      uint64_t v19 = *(void (***)(uint64_t))a1;
      *((_DWORD *)v19 + 10) = 9;
      (*v19)(a1);
    }
    memcpy((void *)(v12 + 17), v11, v18);
    goto LABEL_28;
  }
  if (!a3)
  {
    BOOL v7 = a2 == 0;
    if (a2) {
      uint64_t v8 = (char *)&_cg_jpeg_std_huff_table_bits_dc_luminance;
    }
    else {
      uint64_t v8 = (char *)&_cg_jpeg_std_huff_table_bits_ac_luminance;
    }
    unsigned int v9 = &_cg_jpeg_std_huff_table_val_dc_luminance;
    unsigned int v10 = &_cg_jpeg_std_huff_table_val_ac_luminance;
    goto LABEL_18;
  }
  uint64_t v20 = *(void (***)(uint64_t))a1;
  *((_DWORD *)v20 + 10) = 52;
  *((_DWORD *)v20 + 12) = a3;
  (**(void (***)(uint64_t))a1)(a1);
  return 0;
}

void KTX2WritePlugin::~KTX2WritePlugin(KTX2WritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t KTX2WritePlugin::writeOneImage(KTX2WritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t KTX2WritePlugin::writeOne(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  v35[1] = *MEMORY[0x1E4F143B8];
  v33 = 0;
  v34 = 0;
  size_t __nitems = 0;
  if (!IIODictionary::containsKey(a3, @"kCGImagePropertyEncoder"))
  {
    int Error = _cg_GifLastError((uint64_t)a2);
    __int16 BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(a2);
    if (Error == 32)
    {
      int v13 = 0;
      BOOL v10 = 0;
      int v12 = 0;
      BOOL v17 = (BitmapInfo & 0x100) == 0;
      int v18 = 108;
    }
    else
    {
      if (Error != 16)
      {
        if (Error != 8 || (BitmapInfo & 0x100) != 0) {
          return 4294967242;
        }
        int v13 = 0;
        BOOL v10 = 0;
        int v12 = 0;
        int VkFormat = 43;
        goto LABEL_18;
      }
      int v13 = 0;
      BOOL v10 = 0;
      int v12 = 0;
      BOOL v17 = (BitmapInfo & 0x100) == 0;
      int v18 = 96;
    }
    if (v17) {
      int VkFormat = v18;
    }
    else {
      int VkFormat = v18 + 1;
    }
    goto LABEL_18;
  }
  CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a3, @"kCGImagePropertyEncoder");
  int v8 = CFEqual(ObjectForKey, @"kCGImagePropertyPVREncoder");
  BOOL v10 = v8 != 0;
  if (v8)
  {
    int VkFormat = PVRWritePlugin::GetVkFormat(a3, v9);
    int v12 = 0;
    int v13 = 0;
    if (!VkFormat) {
      return 4294967242;
    }
  }
  else if (CFEqual(ObjectForKey, @"kCGImagePropertyBCEncoder"))
  {
    int VkFormat = BCWritePlugin::GetVkFormat((uint64_t)a3, v16);
    int v12 = 0;
    int v13 = 1;
    if (!VkFormat) {
      return 4294967242;
    }
  }
  else
  {
    if (!CFEqual(ObjectForKey, @"kCGImagePropertyASTCEncoder")) {
      return 4294967242;
    }
    int VkFormat = ASTCWritePlugin::GetVkFormat(a3, v24);
    int v13 = 0;
    int v12 = 1;
    if (!VkFormat) {
      return 4294967242;
    }
  }
LABEL_18:
  *(_OWORD *)&v31[8] = 0u;
  long long v28 = 0u;
  DWORD1(v28) = VkFormat;
  int v29 = IIOImageSource::count(a2);
  int v30 = IIO_Reader::testHeaderSize(a2);
  *(_OWORD *)v31 = xmmword_18898DCD0;
  *(_DWORD *)&v31[16] = 1;
  *(_WORD *)&v31[20] = 0;
  if (ktxTexture2_Create((uint64_t)&v28, 1, &v34)
    || (v35[0] = 0x4F496567616D49, ktxHashList_AddKVPair((uint64_t)(v34 + 20), "KTXwriter", 8u, v35))
    || (strcpy(v27, "rd"), ktxHashList_AddKVPair((uint64_t)(v34 + 20), "KTXorientation", 3u, v27))
    || (char v26 = IIOImagePixelDataProvider::getAlphaInfo(a2) + 48,
        ktxHashList_AddKVPair((uint64_t)(v34 + 20), "AlphaInfo_APPLE", 1u, &v26)))
  {
    uint64_t v20 = 0;
  }
  else
  {
    if (v10)
    {
      if ((gIIODebugFlags & 0x20000) != 0) {
        ImageIOLog("♦️  'KTX2' %d: writeOne saving image [PVR] (%d x %d)\n", 180, v29, v30);
      }
      operator new();
    }
    if (v13)
    {
      if ((gIIODebugFlags & 0x20000) != 0) {
        ImageIOLog("♦️  'KTX2' %d: writeOne saving image [BC] (%d x %d)\n", 187, v29, v30);
      }
      operator new();
    }
    if (v12)
    {
      if ((gIIODebugFlags & 0x20000) != 0) {
        ImageIOLog("♦️  'KTX2' %d: writeOne saving image [ASTC] (%d x %d)\n", 192, v29, v30);
      }
      operator new();
    }
    if ((gIIODebugFlags & 0x20000) != 0) {
      ImageIOLog("♦️  'KTX2' %d: writeOne saving image [uncompressed] (%d x %d)\n", 203, v29, v30);
    }
    uint64_t v22 = IIOImagePlus::sourceImageProvider(a2);
    size_t v23 = IIO_Reader::testHeaderSize(a2) * v22;
    uint64_t v20 = malloc_type_malloc(v23, 0x2D32C5CFuLL);
    if (v20)
    {
      IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v20);
      if ((*(uint64_t (**)(void))(*((void *)v34 + 1) + 24))() == v23
        && !(*(unsigned int (**)(void))(*((void *)v34 + 1) + 64))())
      {
        free(v20);
        if (!(*(unsigned int (**)(void))(*((void *)v34 + 1) + 96))())
        {
          size_t v19 = IIOImageWriteSession::putBytes(this[2], v33, __nitems);
          uint64_t v20 = 0;
          if (v19 == __nitems) {
            uint64_t v21 = 0;
          }
          else {
            uint64_t v21 = 4294967246;
          }
          goto LABEL_38;
        }
        uint64_t v20 = 0;
      }
    }
  }
  uint64_t v21 = 4294967246;
LABEL_38:
  if (v34) {
    (**((void (***)(void))v34 + 1))();
  }
  if (v20) {
    free(v20);
  }
  return v21;
}

void sub_1886AA5C0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C407ADEFACFLL);
  _Unwind_Resume(a1);
}

uint64_t KTX2WritePlugin::WriteProc(KTX2WritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v9, this, a2, 1263818802);
  *(void *)&v9[0] = &unk_1ED4E3AD0;
  uint64_t v5 = IIOWritePlugin::writeAll((IIOImageDestination **)v9);
  _cg_jpeg_mem_term(v9, v6, v7);
  return v5;
}

void sub_1886AA694(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t IIOWritePlugin::writeImageAtIndex(IIOWritePlugin *this, IIOImagePixelDataProvider *a2, CGImage *a3, IIODictionary *a4, IIODictionary *a5, unsigned int a6, uint64_t *a7)
{
  return 4294967292;
}

uint64_t IIOWritePlugin::completePerFrameSaving(IIOWritePlugin *this)
{
  return 0;
}

uint64_t _cg_jpeg_resync_to_restart(_DWORD *a1, int a2)
{
  int v4 = a1[143];
  uint64_t v5 = *(void *)a1;
  *(_DWORD *)(v5 + 40) = 124;
  *(_DWORD *)(v5 + 48) = v4;
  *(_DWORD *)(*(void *)a1 + 52) = a2;
  (*(void (**)(_DWORD *, uint64_t))(*(void *)a1 + 8))(a1, 0xFFFFFFFFLL);
  while (1)
  {
    if (v4 >= 192)
    {
      if ((v4 - 216) < 0xFFFFFFF8
        || v4 == (((_BYTE)a2 + 1) & 7 | 0xD0)
        || v4 == (((_BYTE)a2 + 2) & 7 | 0xD0))
      {
        uint64_t v8 = *(void *)a1;
        *(_DWORD *)(v8 + 40) = 99;
        *(_DWORD *)(v8 + 48) = v4;
        *(_DWORD *)(*(void *)a1 + 52) = 3;
        (*(void (**)(_DWORD *, uint64_t))(*(void *)a1 + 8))(a1, 4);
        return 1;
      }
      if (v4 != (((_BYTE)a2 - 1) & 7 | 0xD0) && v4 != ((a2 + 6) & 7 | 0xD0)) {
        break;
      }
    }
    uint64_t v6 = *(void *)a1;
    *(_DWORD *)(v6 + 40) = 99;
    *(_DWORD *)(v6 + 48) = v4;
    *(_DWORD *)(*(void *)a1 + 52) = 2;
    (*(void (**)(_DWORD *, uint64_t))(*(void *)a1 + 8))(a1, 4);
    if (!next_marker(a1)) {
      return 0;
    }
    int v4 = a1[143];
  }
  uint64_t v9 = *(void *)a1;
  *(_DWORD *)(v9 + 40) = 99;
  *(_DWORD *)(v9 + 48) = v4;
  uint64_t v7 = 1;
  *(_DWORD *)(*(void *)a1 + 52) = 1;
  (*(void (**)(_DWORD *, uint64_t))(*(void *)a1 + 8))(a1, 4);
  a1[143] = 0;
  return v7;
}

uint64_t next_marker(void *a1)
{
  uint64_t v2 = (unsigned __int8 **)a1[5];
  uint64_t v3 = *v2;
  for (i = v2[1]; i; v2[1] = i)
  {
LABEL_4:
    int v6 = *v3++;
    --i;
    if (v6 == 255)
    {
      do
      {
        if (!i)
        {
          uint64_t result = ((uint64_t (*)(void *))v2[3])(a1);
          if (!result) {
            return result;
          }
          uint64_t v3 = *v2;
          i = v2[1];
        }
        --i;
        int v10 = *v3++;
        int v9 = v10;
      }
      while (v10 == 255);
      if (v9)
      {
        int v11 = *(_DWORD *)(a1[77] + 36);
        if (v11)
        {
          uint64_t v12 = *a1;
          *(_DWORD *)(v12 + 40) = 119;
          *(_DWORD *)(v12 + 48) = v11;
          *(_DWORD *)(*a1 + 52) = v9;
          (*(void (**)(void *, uint64_t))(*a1 + 8))(a1, 0xFFFFFFFFLL);
          *(_DWORD *)(a1[77] + 36) = 0;
        }
        *((_DWORD *)a1 + 143) = v9;
        uint64_t result = 1;
        unsigned __int8 *v2 = v3;
        v2[1] = i;
        return result;
      }
      uint64_t v7 = a1[77];
      int v8 = *(_DWORD *)(v7 + 36) + 2;
    }
    else
    {
      uint64_t v7 = a1[77];
      int v8 = *(_DWORD *)(v7 + 36) + 1;
    }
    *(_DWORD *)(v7 + 36) = v8;
    unsigned __int8 *v2 = v3;
  }
  uint64_t result = ((uint64_t (*)(void *))v2[3])(a1);
  if (result)
  {
    uint64_t v3 = *v2;
    i = v2[1];
    goto LABEL_4;
  }
  return result;
}

void _cg_jinit_marker_reader(uint64_t a1)
{
  uint64_t v2 = (**(uint64_t (***)(void))(a1 + 8))();
  *(void *)(a1 + 616) = v2;
  *(void *)uint64_t v2 = reset_marker_reader;
  *(void *)(v2 + 8) = read_markers;
  *(void *)(v2 + 16) = read_restart_marker;
  *(void *)(v2 + 40) = skip_variable;
  *(_DWORD *)(v2 + 176) = 0;
  memset_pattern16((void *)(v2 + 48), &off_1ED4F09A0, 0x80uLL);
  for (uint64_t i = 0; i != 64; i += 16)
  {
    int v4 = (void *)(v2 + 180 + i);
    void *v4 = 0;
    v4[1] = 0;
  }
  *(void *)(v2 + 48) = get_interesting_appn;
  *(void *)(v2 + 160) = get_interesting_appn;
  uint64_t v5 = *(void *)(a1 + 616);
  *(void *)(a1 + 304) = 0;
  *(_DWORD *)(a1 + 172) = 0;
  *(_DWORD *)(a1 + 572) = 0;
  *(void *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 36) = 0;
  *(void *)(v5 + 248) = 0;
}

uint64_t reset_marker_reader(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 616);
  *(void *)(result + 304) = 0;
  *(_DWORD *)(result + 172) = 0;
  *(_DWORD *)(result + 572) = 0;
  *(void *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 36) = 0;
  *(void *)(v1 + 248) = 0;
  return result;
}

uint64_t read_markers(uint64_t a1)
{
  v229 = (void *)(a1 + 340);
  v230 = (void *)(a1 + 324);
  uint64_t v233 = *MEMORY[0x1E4F143B8];
  v228 = (void *)(a1 + 356);
  __int32 v2 = *(_DWORD *)(a1 + 572);
  if (v2) {
    goto LABEL_15;
  }
  while (2)
  {
    if (*(_DWORD *)(*(void *)(a1 + 616) + 24))
    {
      uint64_t result = next_marker((void *)a1);
      if (!result) {
        return result;
      }
      __int32 v2 = *(_DWORD *)(a1 + 572);
    }
    else
    {
      int v4 = *(unsigned __int8 ***)(a1 + 40);
      uint64_t v5 = v4[1];
      if (!v5)
      {
        uint64_t result = ((uint64_t (*)(uint64_t))v4[3])(a1);
        if (!result) {
          return result;
        }
        uint64_t v5 = v4[1];
      }
      int v6 = *v4 + 1;
      int v7 = **v4;
      int v8 = v5 - 1;
      if (v5 == (unsigned __int8 *)1)
      {
        uint64_t result = ((uint64_t (*)(uint64_t))v4[3])(a1);
        if (!result) {
          return result;
        }
        int v6 = *v4;
        int v8 = v4[1];
      }
      int v10 = *v6;
      int v9 = v6 + 1;
      __int32 v2 = v10;
      if (v7 != 255 || v2 != 216)
      {
        uint64_t v11 = *(void *)a1;
        *(_DWORD *)(v11 + 40) = 55;
        *(_DWORD *)(v11 + 48) = v7;
        *(_DWORD *)(*(void *)a1 + 52) = v2;
        (**(void (***)(uint64_t))a1)(a1);
      }
      *(_DWORD *)(a1 + 572) = v2;
      void *v4 = v9;
      v4[1] = v8 - 1;
    }
LABEL_15:
    switch(v2)
    {
      case 192:
        uint16x8_t v15 = (uint64_t *)a1;
        int v16 = 1;
        goto LABEL_26;
      case 193:
        uint16x8_t v15 = (uint64_t *)a1;
        int v16 = 0;
LABEL_26:
        int v17 = 0;
        goto LABEL_28;
      case 194:
        uint16x8_t v15 = (uint64_t *)a1;
        int v16 = 0;
        int v17 = 1;
LABEL_28:
        int v18 = 0;
        goto LABEL_74;
      case 195:
      case 197:
      case 198:
      case 199:
      case 200:
      case 203:
      case 205:
      case 206:
      case 207:
        uint64_t v12 = *(uint32x4_t **)a1;
        int v13 = 63;
        goto LABEL_20;
      case 196:
        memset(v232, 0, sizeof(v232));
        memset(__src, 0, sizeof(__src));
        size_t v19 = *(unsigned __int8 ***)(a1 + 40);
        uint64_t v20 = v19[1];
        if (v20) {
          goto LABEL_32;
        }
        if (!((unsigned int (*)(uint64_t))v19[3])(a1)) {
          return 0;
        }
        uint64_t v20 = v19[1];
LABEL_32:
        uint64_t v22 = *v19 + 1;
        uint64_t v21 = **v19;
        size_t v23 = v20 - 1;
        if (v23) {
          goto LABEL_35;
        }
        if (!((unsigned int (*)(uint64_t))v19[3])(a1)) {
          return 0;
        }
        uint64_t v22 = *v19;
        size_t v23 = v19[1];
LABEL_35:
        uint64_t v24 = v23 - 1;
        unsigned int v26 = *v22;
        uint64_t v25 = v22 + 1;
        unint64_t v27 = (v21 << 8) | v26;
        unint64_t v28 = v27 - 2;
        if (v27 < 0x13) {
          goto LABEL_68;
        }
        while (2)
        {
          if (v24) {
            goto LABEL_39;
          }
          if (((unsigned int (*)(uint64_t))v19[3])(a1))
          {
            uint64_t v25 = *v19;
            uint64_t v24 = v19[1];
LABEL_39:
            unsigned int v30 = *v25++;
            uint64_t v29 = v30;
            v31 = *(uint32x4_t **)a1;
            v31[2].i32[2] = 82;
            v31[3].i32[0] = v30;
            (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 8))(a1, 1);
            LODWORD(v33) = 0;
            v232[0] = 0;
            --v24;
            for (uint64_t i = 1; i != 17; ++i)
            {
              if (!v24)
              {
                if (!((unsigned int (*)(uint64_t))v19[3])(a1)) {
                  return 0;
                }
                uint64_t v25 = *v19;
                uint64_t v24 = v19[1];
              }
              int v35 = *v25++;
              v232[i] = v35;
              int64_t v33 = (v33 + v35);
              --v24;
            }
            int64_t v36 = v28 - 17;
            v37 = *(uint32x4_t **)a1;
            v32.i32[0] = *(_DWORD *)&v232[1];
            uint32x4_t v38 = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v32));
            v37[3] = v38;
            v38.i32[0] = *(_DWORD *)&v232[5];
            v37[4] = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v38.i8));
            v37[2].i32[2] = 88;
            __n128 v39 = ((__n128 (*)(uint64_t, uint64_t))v37->i64[1])(a1, 2);
            v40 = *(uint32x4_t **)a1;
            v39.n128_u32[0] = *(_DWORD *)&v232[9];
            uint32x4_t v41 = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8((uint8x8_t)v39.n128_u64[0]));
            v40[3] = v41;
            v41.i32[0] = *(_DWORD *)&v232[13];
            v40[4] = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v41.i8));
            v40[2].i32[2] = 88;
            ((void (*)(uint64_t, uint64_t))v40->i64[1])(a1, 2);
            if (v33 > 0x100 || v36 < v33)
            {
              v42 = *(uint32x4_t **)a1;
              v42[2].i32[2] = 9;
              ((void (*)(uint64_t))v42->i64[0])(a1);
              if (!v33) {
                goto LABEL_54;
              }
            }
            else if (!v33)
            {
              goto LABEL_54;
            }
            v43 = __src;
            int64_t v44 = v33;
            do
            {
              if (!v24)
              {
                if (!((unsigned int (*)(uint64_t))v19[3])(a1)) {
                  return 0;
                }
                uint64_t v25 = *v19;
                uint64_t v24 = v19[1];
              }
              --v24;
              char v45 = *v25++;
              *v43++ = v45;
              --v44;
            }
            while (v44);
LABEL_54:
            if ((v29 & 0x10) != 0)
            {
              if ((v29 - 20) <= 0xFFFFFFFB)
              {
                v48 = *(uint32x4_t **)a1;
                v48[2].i32[2] = 12;
                ((void (*)(uint64_t))v48->i64[0])(a1);
              }
              v29 -= 16;
              uint64_t v47 = a1 + 8 * v29 + 264;
            }
            else
            {
              if (v29 >= 4)
              {
                v46 = *(uint32x4_t **)a1;
                v46[2].i32[2] = 12;
                ((void (*)(uint64_t))v46->i64[0])(a1);
              }
              uint64_t v47 = a1 + 8 * v29 + 232;
            }
            if (v29 >= 4)
            {
              v49 = *(uint32x4_t **)a1;
              v49[2].i32[2] = 31;
              v49[3].i32[0] = v29;
              (**(void (***)(uint64_t))a1)(a1);
            }
            uint64_t v50 = *(void *)v47;
            if (!*(void *)v47)
            {
              uint64_t v50 = _cg_jpeg_alloc_huff_table(a1);
              *(void *)uint64_t v47 = v50;
            }
            *(_OWORD *)uint64_t v50 = *(_OWORD *)v232;
            *(unsigned char *)(v50 + 16) = v232[16];
            if (v33) {
              memcpy((void *)(*(void *)v47 + 17), __src, v33);
            }
            unint64_t v28 = v36 - v33;
            if (v36 - v33 <= 16)
            {
LABEL_68:
              if (v28)
              {
                v51 = *(uint32x4_t **)a1;
                v51[2].i32[2] = 12;
                ((void (*)(uint64_t))v51->i64[0])(a1);
              }
              *size_t v19 = v25;
              v19[1] = v24;
              goto LABEL_278;
            }
            continue;
          }
          return 0;
        }
      case 201:
        uint16x8_t v15 = (uint64_t *)a1;
        int v16 = 0;
        int v17 = 0;
        goto LABEL_73;
      case 202:
        uint16x8_t v15 = (uint64_t *)a1;
        int v16 = 0;
        int v17 = 1;
LABEL_73:
        int v18 = 1;
LABEL_74:
        uint64_t result = get_sof(v15, v16, v17, v18);
        if (!result) {
          return result;
        }
        goto LABEL_278;
      case 204:
        v52 = *(unsigned __int8 ***)(a1 + 40);
        v53 = v52[1];
        if (v53) {
          goto LABEL_79;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v52[3])(a1);
        if (!result) {
          return result;
        }
        v53 = v52[1];
LABEL_79:
        v54 = *v52 + 1;
        uint64_t v55 = **v52;
        v56 = v53 - 1;
        if (v56) {
          goto LABEL_82;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v52[3])(a1);
        if (!result) {
          return result;
        }
        v54 = *v52;
        v56 = v52[1];
LABEL_82:
        unsigned int v58 = *v54;
        v57 = v54 + 1;
        unint64_t v59 = (v55 << 8) | v58;
        v60 = v56 - 1;
        if (v59 >= 3)
        {
          while (1)
          {
            if (!v60)
            {
              uint64_t result = ((uint64_t (*)(uint64_t))v52[3])(a1);
              if (!result) {
                return result;
              }
              v57 = *v52;
              v60 = v52[1];
            }
            unsigned int v63 = *v57;
            v61 = v57 + 1;
            uint64_t v62 = v63;
            v64 = v60 - 1;
            if (!v64)
            {
              uint64_t result = ((uint64_t (*)(uint64_t))v52[3])(a1);
              if (!result) {
                return result;
              }
              v61 = *v52;
              v64 = v52[1];
            }
            unsigned int v65 = *v61;
            v66 = *(uint32x4_t **)a1;
            v66[2].i32[2] = 81;
            v66[3].i32[0] = v62;
            *(_DWORD *)(*(void *)a1 + 52) = v65;
            (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 8))(a1, 1);
            if (v62 < 0x20)
            {
              if (v62 < 0x10)
              {
                uint64_t v69 = a1 + v62;
                *(unsigned char *)(v69 + 324) = v65 & 0xF;
                *(unsigned char *)(v69 + 340) = v65 >> 4;
                if ((v65 & 0xF) > v65 >> 4)
                {
                  v70 = *(uint32x4_t **)a1;
                  v70[2].i32[2] = 30;
                  v70[3].i32[0] = v65;
                  (**(void (***)(uint64_t))a1)(a1);
                }
                goto LABEL_93;
              }
            }
            else
            {
              v67 = *(uint32x4_t **)a1;
              v67[2].i32[2] = 29;
              v67[3].i32[0] = v62;
              (**(void (***)(uint64_t))a1)(a1);
            }
            *(unsigned char *)(a1 + (v62 - 16) + 356) = v65;
LABEL_93:
            v57 = v61 + 1;
            v60 = v64 - 1;
            v59 -= 2;
            unint64_t v68 = v59 - 2;
            if (v59 <= 2) {
              goto LABEL_273;
            }
          }
        }
        unint64_t v68 = v59 - 2;
LABEL_273:
        if (v68)
        {
          v180 = *(uint32x4_t **)a1;
          v180[2].i32[2] = 12;
          ((void (*)(uint64_t))v180->i64[0])(a1);
        }
LABEL_275:
        *v52 = v57;
        v52[1] = v60;
LABEL_278:
        *(_DWORD *)(a1 + 572) = 0;
        continue;
      case 208:
      case 209:
      case 210:
      case 211:
      case 212:
      case 213:
      case 214:
      case 215:
        goto LABEL_22;
      case 216:
        v71 = *(uint32x4_t **)a1;
        v71[2].i32[2] = 104;
        ((void (*)(uint64_t, uint64_t))v71->i64[1])(a1, 1);
        uint64_t v72 = *(void *)(a1 + 616);
        if (*(_DWORD *)(v72 + 24))
        {
          v73 = *(uint32x4_t **)a1;
          v73[2].i32[2] = 64;
          ((void (*)(uint64_t))v73->i64[0])(a1);
          uint64_t v72 = *(void *)(a1 + 616);
        }
        void *v230 = 0;
        v230[1] = 0;
        void *v229 = 0x101010101010101;
        v229[1] = 0x101010101010101;
        void *v228 = 0x505050505050505;
        v228[1] = 0x505050505050505;
        *(void *)(a1 + 372) = 0;
        *(_DWORD *)(a1 + 60) = 0;
        *(void *)(a1 + 396) = 0;
        *(_WORD *)(a1 + 380) = 257;
        *(unsigned char *)(a1 + 382) = 0;
        *(void *)(a1 + 384) = 65537;
        *(unsigned char *)(a1 + 392) = 0;
        *(_DWORD *)(v72 + 24) = 1;
        goto LABEL_278;
      case 217:
        v182 = *(uint32x4_t **)a1;
        v182[2].i32[2] = 87;
        ((void (*)(uint64_t, uint64_t))v182->i64[1])(a1, 1);
        *(_DWORD *)(a1 + 572) = 0;
        return 2;
      case 218:
        v183 = *(unsigned __int8 ***)(a1 + 40);
        v184 = *v183;
        v185 = v183[1];
        if (!*(_DWORD *)(*(void *)(a1 + 616) + 28))
        {
          v186 = *(uint32x4_t **)a1;
          v186[2].i32[2] = 60;
          v186[5] = (uint32x4_t)xmmword_18898DD12;
          v186[6] = (uint32x4_t)unk_18898DD22;
          v186[7] = (uint32x4_t)xmmword_18898DD32;
          v186[3] = (uint32x4_t)xmmword_18898DCF2;
          v186[4] = (uint32x4_t)unk_18898DD02;
          (**(void (***)(uint64_t))a1)(a1);
        }
        if (v185) {
          goto LABEL_287;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v183[3])(a1);
        if (!result) {
          return result;
        }
        v184 = *v183;
        v185 = v183[1];
LABEL_287:
        unsigned int v189 = *v184;
        v187 = v184 + 1;
        uint64_t v188 = v189;
        v190 = v185 - 1;
        if (v185 != (unsigned __int8 *)1) {
          goto LABEL_290;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v183[3])(a1);
        if (!result) {
          return result;
        }
        v187 = *v183;
        v190 = v183[1];
LABEL_290:
        unsigned int v193 = *v187;
        v191 = v187 + 1;
        uint64_t v192 = v193;
        v194 = v190 - 1;
        if (v190 != (unsigned __int8 *)1) {
          goto LABEL_293;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v183[3])(a1);
        if (!result) {
          return result;
        }
        v191 = *v183;
        v194 = v183[1];
LABEL_293:
        uint64_t v195 = (v188 << 8) | v192;
        uint64_t v196 = *v191;
        v197 = *(uint32x4_t **)a1;
        v197[2].i32[2] = 105;
        v197[3].i32[0] = v196;
        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 8))(a1, 1);
        if (v195 != 2 * v196 + 6 || v196 > 4) {
          goto LABEL_298;
        }
        if (v196)
        {
          *(_DWORD *)(a1 + 448) = v196;
          v200 = v191 + 1;
          v201 = v194 - 1;
          goto LABEL_302;
        }
        if (*(_DWORD *)(a1 + 316))
        {
          *(_DWORD *)(a1 + 448) = 0;
          v200 = v191 + 1;
          v201 = v194 - 1;
        }
        else
        {
LABEL_298:
          v199 = *(uint32x4_t **)a1;
          v199[2].i32[2] = 12;
          ((void (*)(uint64_t))v199->i64[0])(a1);
          *(_DWORD *)(a1 + 448) = v196;
          v200 = v191 + 1;
          v201 = v194 - 1;
          if (v196)
          {
LABEL_302:
            unint64_t v202 = 0;
            while (1)
            {
              if (!v201)
              {
                uint64_t result = ((uint64_t (*)(uint64_t))v183[3])(a1);
                if (!result) {
                  return result;
                }
                v200 = *v183;
                v201 = v183[1];
              }
              int v205 = *v200;
              v204 = v200 + 1;
              __int32 v203 = v205;
              if (v202)
              {
                uint64_t v206 = 0;
                while (**(_DWORD **)(a1 + 456 + 8 * v206) != v203)
                {
                  if (v202 == ++v206) {
                    goto LABEL_317;
                  }
                }
                int v207 = **(_DWORD **)(a1 + 456);
                if (v202 >= 2)
                {
                  uint64_t v208 = 0;
                  do
                  {
                    if (**(_DWORD **)(a1 + 464 + 8 * v208) > v207) {
                      int v207 = **(_DWORD **)(a1 + 464 + 8 * v208);
                    }
                    ++v208;
                  }
                  while (v202 - 1 != v208);
                }
                __int32 v203 = v207 + 1;
              }
LABEL_317:
              v209 = *(__int32 **)(a1 + 304);
              int v210 = *(_DWORD *)(a1 + 56);
              if (v210 >= 1)
              {
                uint64_t v211 = (uint64_t)&v209[24 * (v210 - 1) + 24];
                do
                {
                  if (v203 == *v209) {
                    goto LABEL_323;
                  }
                  v209 += 24;
                  --v210;
                }
                while (v210);
                v209 = (__int32 *)v211;
              }
              v212 = *(uint32x4_t **)a1;
              v212[2].i32[2] = 4;
              v212[3].i32[0] = v203;
              (**(void (***)(uint64_t))a1)(a1);
LABEL_323:
              *(void *)(a1 + 8 * v202 + 456) = v209;
              v213 = v201 - 1;
              if (!v213)
              {
                uint64_t result = ((uint64_t (*)(uint64_t))v183[3])(a1);
                if (!result) {
                  return result;
                }
                v204 = *v183;
                v213 = v183[1];
              }
              unsigned int v214 = *v204;
              v200 = v204 + 1;
              v209[5] = v214 >> 4;
              v209[6] = v214 & 0xF;
              v215 = *(uint32x4_t **)a1;
              v215[3].i32[0] = *v209;
              v215[3].i32[1] = v209[5];
              v215[3].i32[2] = v209[6];
              v215[2].i32[2] = 106;
              ((void (*)(uint64_t, uint64_t))v215->i64[1])(a1, 1);
              ++v202;
              v201 = v213 - 1;
              if (v202 == v196)
              {
                char v216 = 0;
                goto LABEL_331;
              }
            }
          }
        }
        char v216 = 1;
LABEL_331:
        if (v201) {
          goto LABEL_334;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v183[3])(a1);
        if (!result) {
          return result;
        }
        v200 = *v183;
        v201 = v183[1];
LABEL_334:
        int v218 = *v200;
        v217 = v200 + 1;
        *(_DWORD *)(a1 + 540) = v218;
        v219 = v201 - 1;
        if (v201 != (unsigned __int8 *)1) {
          goto LABEL_337;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v183[3])(a1);
        if (!result) {
          return result;
        }
        v217 = *v183;
        v219 = v183[1];
LABEL_337:
        int v221 = *v217;
        v220 = v217 + 1;
        *(_DWORD *)(a1 + 544) = v221;
        v222 = v219 - 1;
        if (v222) {
          goto LABEL_340;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v183[3])(a1);
        if (result)
        {
          v220 = *v183;
          v222 = v183[1];
LABEL_340:
          v223 = v222 - 1;
          unsigned int v225 = *v220;
          v224 = v220 + 1;
          *(_DWORD *)(a1 + 548) = v225 >> 4;
          *(_DWORD *)(a1 + 552) = v225 & 0xF;
          v226 = *(uint32x4_t **)a1;
          v226[3].i32[0] = *(_DWORD *)(a1 + 540);
          v226[3].i32[1] = *(_DWORD *)(a1 + 544);
          v226[3].i32[2] = *(_DWORD *)(a1 + 548);
          v226[3].i32[3] = *(_DWORD *)(a1 + 552);
          v226[2].i32[2] = 107;
          ((void (*)(uint64_t, uint64_t))v226->i64[1])(a1, 1);
          *(_DWORD *)(*(void *)(a1 + 616) + 32) = 0;
          if ((v216 & 1) == 0) {
            ++*(_DWORD *)(a1 + 172);
          }
          *v183 = v224;
          v183[1] = v223;
          uint64_t result = 1;
          *(_DWORD *)(a1 + 572) = 0;
        }
        return result;
      case 219:
        v74 = *(unsigned __int8 ***)(a1 + 40);
        v75 = v74[1];
        if (v75) {
          goto LABEL_103;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v74[3])(a1);
        if (!result) {
          return result;
        }
        v75 = v74[1];
LABEL_103:
        v77 = *v74 + 1;
        uint64_t v76 = **v74;
        v78 = v75 - 1;
        if (v78) {
          goto LABEL_106;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v74[3])(a1);
        if (!result) {
          return result;
        }
        v77 = *v74;
        v78 = v74[1];
LABEL_106:
        v79 = v78 - 1;
        unsigned int v81 = *v77;
        v80 = v77 + 1;
        unint64_t v82 = (v76 << 8) | v81;
        uint64_t v83 = v82 - 2;
        if (v82 < 3) {
          goto LABEL_269;
        }
        break;
      case 220:
        uint64_t result = skip_variable((void *)a1);
        if (!result) {
          return result;
        }
        goto LABEL_278;
      case 221:
        v52 = *(unsigned __int8 ***)(a1 + 40);
        v104 = v52[1];
        if (v104) {
          goto LABEL_162;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v52[3])(a1);
        if (!result) {
          return result;
        }
        v104 = v52[1];
LABEL_162:
        v105 = *v52 + 1;
        uint64_t v106 = **v52;
        v107 = v104 - 1;
        if (v104 != (unsigned __int8 *)1) {
          goto LABEL_165;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v52[3])(a1);
        if (!result) {
          return result;
        }
        v105 = *v52;
        v107 = v52[1];
LABEL_165:
        unsigned int v109 = *v105;
        v108 = v105 + 1;
        if (((v106 << 8) | v109) != 4)
        {
          v110 = *(uint32x4_t **)a1;
          v110[2].i32[2] = 12;
          ((void (*)(uint64_t))v110->i64[0])(a1);
        }
        v111 = v107 - 1;
        if (v107 != (unsigned __int8 *)1) {
          goto LABEL_170;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v52[3])(a1);
        if (!result) {
          return result;
        }
        v108 = *v52;
        v111 = v52[1];
LABEL_170:
        int v114 = *v108;
        v112 = v108 + 1;
        int v113 = v114;
        v115 = v111 - 1;
        if (v115) {
          goto LABEL_173;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v52[3])(a1);
        if (!result) {
          return result;
        }
        v112 = *v52;
        v115 = v52[1];
LABEL_173:
        int v116 = v113 << 8;
        v60 = v115 - 1;
        int v117 = *v112;
        v57 = v112 + 1;
        int v118 = v116 | v117;
        v119 = *(uint32x4_t **)a1;
        v119[2].i32[2] = 84;
        v119[3].i32[0] = v116 | v117;
        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 8))(a1, 1);
        *(_DWORD *)(a1 + 372) = v118;
        goto LABEL_275;
      case 222:
      case 223:
      case 240:
      case 241:
      case 242:
      case 243:
      case 244:
      case 245:
      case 246:
      case 247:
      case 249:
      case 250:
      case 251:
      case 252:
      case 253:
        goto LABEL_23;
      case 224:
      case 225:
      case 226:
      case 227:
      case 228:
      case 229:
      case 230:
      case 231:
      case 232:
      case 233:
      case 234:
      case 235:
      case 236:
      case 237:
      case 238:
      case 239:
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 616) + 8 * (v2 - 224) + 48))(a1);
        goto LABEL_17;
      case 248:
        v120 = *(unsigned __int8 ***)(a1 + 40);
        v121 = *v120;
        v122 = v120[1];
        if (!*(_DWORD *)(*(void *)(a1 + 616) + 28))
        {
          v123 = *(uint32x4_t **)a1;
          v123[2].i32[2] = 60;
          v123[5] = (uint32x4_t)xmmword_18898DD63;
          v123[6] = (uint32x4_t)unk_18898DD73;
          v123[7] = (uint32x4_t)xmmword_18898DD83;
          v123[3] = (uint32x4_t)xmmword_18898DD43;
          v123[4] = (uint32x4_t)unk_18898DD53;
          (**(void (***)(uint64_t))a1)(a1);
        }
        if (*(int *)(a1 + 56) < 3) {
          goto LABEL_276;
        }
        if (v122) {
          goto LABEL_180;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v121 = *v120;
        v122 = v120[1];
LABEL_180:
        unsigned int v126 = *v121;
        v125 = v121 + 1;
        uint64_t v124 = v126;
        v127 = v122 - 1;
        if (v122 != (unsigned __int8 *)1) {
          goto LABEL_183;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v125 = *v120;
        v127 = v120[1];
LABEL_183:
        unsigned int v129 = *v125;
        v128 = v125 + 1;
        if (((v124 << 8) | v129) != 0x18)
        {
          v130 = *(uint32x4_t **)a1;
          v130[2].i32[2] = 12;
          ((void (*)(uint64_t))v130->i64[0])(a1);
        }
        v131 = v127 - 1;
        if (v131) {
          goto LABEL_188;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v128 = *v120;
        v131 = v120[1];
LABEL_188:
        int v133 = *v128;
        v132 = v128 + 1;
        if (v133 != 13)
        {
          v134 = *(uint32x4_t **)a1;
          v134[2].i32[2] = 70;
          v134[3].i32[0] = *(_DWORD *)(a1 + 572);
          (**(void (***)(uint64_t))a1)(a1);
        }
        v135 = v131 - 1;
        if (v131 != (unsigned __int8 *)1) {
          goto LABEL_193;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v132 = *v120;
        v135 = v120[1];
LABEL_193:
        int v138 = *v132;
        v137 = v132 + 1;
        int v136 = v138;
        v139 = v135 - 1;
        if (v139) {
          goto LABEL_196;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v137 = *v120;
        v139 = v120[1];
LABEL_196:
        v122 = v139 - 1;
        int v140 = *v137;
        v121 = v137 + 1;
        if (((v136 << 8) | v140) != 0xFF) {
          goto LABEL_276;
        }
        if (v139 != (unsigned __int8 *)1) {
          goto LABEL_200;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v121 = *v120;
        v122 = v120[1];
LABEL_200:
        --v122;
        int v141 = *v121++;
        if (v141 != 3) {
          goto LABEL_276;
        }
        if (v122) {
          goto LABEL_204;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v121 = *v120;
        v122 = v120[1];
LABEL_204:
        --v122;
        int v142 = *v121++;
        v143 = *(_DWORD **)(a1 + 304);
        if (v143[24] != v142) {
          goto LABEL_276;
        }
        if (v122) {
          goto LABEL_208;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v121 = *v120;
        v122 = v120[1];
        v143 = *(_DWORD **)(a1 + 304);
LABEL_208:
        --v122;
        int v144 = *v121++;
        if (*v143 != v144) {
          goto LABEL_276;
        }
        if (v122) {
          goto LABEL_212;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v121 = *v120;
        v122 = v120[1];
        v143 = *(_DWORD **)(a1 + 304);
LABEL_212:
        --v122;
        int v145 = *v121++;
        if (v143[48] != v145) {
          goto LABEL_276;
        }
        if (v122) {
          goto LABEL_216;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v121 = *v120;
        v122 = v120[1];
LABEL_216:
        --v122;
        int v146 = *v121++;
        if (v146 != 128) {
          goto LABEL_276;
        }
        if (v122) {
          goto LABEL_220;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v121 = *v120;
        v122 = v120[1];
LABEL_220:
        int v149 = *v121;
        v148 = v121 + 1;
        int v147 = v149;
        v150 = v122 - 1;
        if (v122 != (unsigned __int8 *)1) {
          goto LABEL_223;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v148 = *v120;
        v150 = v120[1];
LABEL_223:
        v122 = v150 - 1;
        int v151 = *v148;
        v121 = v148 + 1;
        if ((v147 << 8) | v151) {
          goto LABEL_276;
        }
        if (v150 != (unsigned __int8 *)1) {
          goto LABEL_227;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v121 = *v120;
        v122 = v120[1];
LABEL_227:
        int v154 = *v121;
        v153 = v121 + 1;
        int v152 = v154;
        v155 = v122 - 1;
        if (v122 != (unsigned __int8 *)1) {
          goto LABEL_230;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v153 = *v120;
        v155 = v120[1];
LABEL_230:
        v122 = v155 - 1;
        int v156 = *v153;
        v121 = v153 + 1;
        if ((v152 << 8) | v156) {
          goto LABEL_276;
        }
        if (v155 != (unsigned __int8 *)1) {
          goto LABEL_234;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v121 = *v120;
        v122 = v120[1];
LABEL_234:
        --v122;
        if (*v121++) {
          goto LABEL_276;
        }
        if (v122) {
          goto LABEL_238;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v121 = *v120;
        v122 = v120[1];
LABEL_238:
        int v160 = *v121;
        v159 = v121 + 1;
        int v158 = v160;
        v161 = v122 - 1;
        if (v122 != (unsigned __int8 *)1) {
          goto LABEL_241;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v159 = *v120;
        v161 = v120[1];
LABEL_241:
        v122 = v161 - 1;
        int v162 = *v159;
        v121 = v159 + 1;
        if (((v158 << 8) | v162) != 1) {
          goto LABEL_276;
        }
        if (v161 != (unsigned __int8 *)1) {
          goto LABEL_245;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v121 = *v120;
        v122 = v120[1];
LABEL_245:
        int v165 = *v121;
        v164 = v121 + 1;
        int v163 = v165;
        v166 = v122 - 1;
        if (v122 != (unsigned __int8 *)1) {
          goto LABEL_248;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v164 = *v120;
        v166 = v120[1];
LABEL_248:
        v122 = v166 - 1;
        int v167 = *v164;
        v121 = v164 + 1;
        if ((v163 << 8) | v167) {
          goto LABEL_276;
        }
        if (v166 != (unsigned __int8 *)1) {
          goto LABEL_252;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v121 = *v120;
        v122 = v120[1];
LABEL_252:
        --v122;
        if (*v121++) {
          goto LABEL_276;
        }
        if (v122) {
          goto LABEL_256;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v121 = *v120;
        v122 = v120[1];
LABEL_256:
        int v171 = *v121;
        v170 = v121 + 1;
        int v169 = v171;
        v172 = v122 - 1;
        if (v122 != (unsigned __int8 *)1) {
          goto LABEL_259;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v170 = *v120;
        v172 = v120[1];
LABEL_259:
        v122 = v172 - 1;
        int v173 = *v170;
        v121 = v170 + 1;
        if (((v169 << 8) | v173) != 1) {
          goto LABEL_276;
        }
        if (v172 != (unsigned __int8 *)1) {
          goto LABEL_263;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v121 = *v120;
        v122 = v120[1];
LABEL_263:
        int v176 = *v121;
        v175 = v121 + 1;
        int v174 = v176;
        v177 = v122 - 1;
        if (v122 != (unsigned __int8 *)1) {
          goto LABEL_266;
        }
        uint64_t result = ((uint64_t (*)(uint64_t))v120[3])(a1);
        if (!result) {
          return result;
        }
        v175 = *v120;
        v177 = v120[1];
LABEL_266:
        v122 = v177 - 1;
        int v178 = *v175;
        v121 = v175 + 1;
        if ((v174 << 8) | v178)
        {
LABEL_276:
          v181 = *(uint32x4_t **)a1;
          v181[2].i32[2] = 28;
          ((void (*)(uint64_t))v181->i64[0])(a1);
        }
        *(_DWORD *)(a1 + 396) = 1;
        *v120 = v121;
        v120[1] = v122;
        goto LABEL_278;
      case 254:
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 616) + 40))(a1);
LABEL_17:
        if (!result) {
          return result;
        }
        goto LABEL_278;
      default:
        if (v2 == 1)
        {
LABEL_22:
          uint8x16_t v14 = *(uint32x4_t **)a1;
          v14[2].i32[2] = 94;
          v14[3].i32[0] = v2;
          (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 8))(a1, 1);
        }
        else
        {
LABEL_23:
          uint64_t v12 = *(uint32x4_t **)a1;
          int v13 = 70;
LABEL_20:
          v12[2].i32[2] = v13;
          v12[3].i32[0] = v2;
          (**(void (***)(uint64_t))a1)(a1);
        }
        goto LABEL_278;
    }
    break;
  }
  while (1)
  {
    if (!v79)
    {
      uint64_t result = ((uint64_t (*)(uint64_t))v74[3])(a1);
      if (!result) {
        return result;
      }
      v80 = *v74;
      v79 = v74[1];
    }
    unsigned int v84 = *v80;
    uint64_t v85 = v84 & 0xF;
    v86 = *(uint32x4_t **)a1;
    v86[2].i32[2] = 83;
    v86[3].i32[0] = v84 & 0xF;
    *(_DWORD *)(*(void *)a1 + 52) = v84 >> 4;
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 8))(a1, 1);
    if ((v84 & 0xF) >= 4)
    {
      v87 = *(uint32x4_t **)a1;
      v87[2].i32[2] = 32;
      v87[3].i32[0] = v85;
      (**(void (***)(uint64_t))a1)(a1);
    }
    uint64_t v88 = a1 + 8 * v85;
    v91 = *(uint16x4_t **)(v88 + 200);
    v90 = (uint16x4_t **)(v88 + 200);
    v89 = v91;
    if (!v91)
    {
      v89 = (uint16x4_t *)_cg_jpeg_alloc_quant_table(a1);
      *v90 = v89;
    }
    uint64_t v227 = v83 - 1;
    if (v84 >= 0x10)
    {
      if ((unint64_t)v83 > 0x80)
      {
LABEL_124:
        unint64_t v92 = 64;
LABEL_125:
        v93 = &_cg_jpeg_natural_order;
        goto LABEL_126;
      }
      memset_pattern16(v89, &unk_18898DDA0, 0x80uLL);
      unint64_t v92 = (unint64_t)(v83 - 1) >> 1;
    }
    else
    {
      if ((unint64_t)v83 > 0x40) {
        goto LABEL_124;
      }
      memset_pattern16(v89, &unk_18898DDA0, 0x80uLL);
      unint64_t v92 = v83 - 1;
    }
    if ((int)v92 > 24)
    {
      switch(v92)
      {
        case 0x19:
          v93 = &jpeg_natural_order5;
          goto LABEL_126;
        case 0x24:
          v93 = &jpeg_natural_order6;
          goto LABEL_126;
        case 0x31:
          v93 = &jpeg_natural_order7;
          goto LABEL_126;
      }
      goto LABEL_125;
    }
    if (v92 == 4)
    {
      v93 = &jpeg_natural_order2;
      goto LABEL_126;
    }
    if (v92 == 9)
    {
      v93 = &jpeg_natural_order3;
      goto LABEL_126;
    }
    if (v92 != 16) {
      goto LABEL_125;
    }
    v93 = &jpeg_natural_order4;
LABEL_126:
    ++v80;
    --v79;
    if (v92)
    {
      unint64_t v94 = v92;
      do
      {
        if (v84 >= 0x10)
        {
          if (!v79)
          {
            uint64_t result = ((uint64_t (*)(uint64_t))v74[3])(a1);
            if (!result) {
              return result;
            }
            v80 = *v74;
            v79 = v74[1];
          }
          __int16 v97 = *v80++;
          __int16 v96 = v97;
          if (!--v79)
          {
            uint64_t result = ((uint64_t (*)(uint64_t))v74[3])(a1);
            if (!result) {
              return result;
            }
            v80 = *v74;
            v79 = v74[1];
          }
          __int16 v95 = (v96 << 8) | *v80;
        }
        else
        {
          if (!v79)
          {
            uint64_t result = ((uint64_t (*)(uint64_t))v74[3])(a1);
            if (!result) {
              return result;
            }
            v80 = *v74;
            v79 = v74[1];
          }
          __int16 v95 = *v80;
        }
        uint64_t v98 = *v93++;
        v89->i16[v98] = v95;
        ++v80;
        --v79;
        --v94;
      }
      while (v94);
    }
    if (*(int *)(*(void *)a1 + 128) >= 2)
    {
      v99 = v89 + 1;
      unint64_t v100 = -8;
      do
      {
        v101 = *(uint32x4_t **)a1;
        v101[3] = vmovl_u16(v99[-1]);
        uint16x4_t v102 = *v99;
        v99 += 2;
        v101[4] = vmovl_u16(v102);
        v101[2].i32[2] = 95;
        ((void (*)(uint64_t, uint64_t))v101->i64[1])(a1, 2);
        v100 += 8;
      }
      while (v100 < 0x38);
    }
    if (v84 >= 0x10) {
      unint64_t v103 = v92;
    }
    else {
      unint64_t v103 = 0;
    }
    uint64_t v83 = v227 - v92 - v103;
    if (v83 <= 0)
    {
LABEL_269:
      if (v83)
      {
        v179 = *(uint32x4_t **)a1;
        v179[2].i32[2] = 12;
        ((void (*)(uint64_t))v179->i64[0])(a1);
      }
      *v74 = v80;
      v74[1] = v79;
      goto LABEL_278;
    }
  }
}

uint64_t read_restart_marker(uint64_t *a1)
{
  int v2 = *((_DWORD *)a1 + 143);
  if (!v2)
  {
    uint64_t result = next_marker(a1);
    if (!result) {
      return result;
    }
    int v2 = *((_DWORD *)a1 + 143);
  }
  int v4 = *(_DWORD *)(a1[77] + 32);
  if (v2 == v4 + 208)
  {
    uint64_t v5 = *a1;
    *(_DWORD *)(v5 + 40) = 100;
    *(_DWORD *)(v5 + 48) = v4;
    (*(void (**)(uint64_t *, uint64_t))(*a1 + 8))(a1, 3);
    *((_DWORD *)a1 + 143) = 0;
  }
  else
  {
    uint64_t result = (*(uint64_t (**)(uint64_t *))(a1[5] + 40))(a1);
    if (!result) {
      return result;
    }
  }
  *(_DWORD *)(a1[77] + 32) = (*(_DWORD *)(a1[77] + 32) + 1) & 7;
  return 1;
}

uint64_t skip_variable(void *a1)
{
  int v2 = (unsigned __int8 **)a1[5];
  uint64_t v3 = v2[1];
  if (!v3)
  {
    if (!((unsigned int (*)(void *))v2[3])(a1)) {
      return 0;
    }
    uint64_t v3 = v2[1];
  }
  uint64_t v5 = *v2 + 1;
  uint64_t v4 = **v2;
  int v6 = v3 - 1;
  if (v6) {
    goto LABEL_7;
  }
  if (!((unsigned int (*)(void *))v2[3])(a1)) {
    return 0;
  }
  uint64_t v5 = *v2;
  int v6 = v2[1];
LABEL_7:
  int v7 = v6 - 1;
  unint64_t v8 = (v4 << 8) | *v5;
  uint64_t v9 = *a1;
  *(_DWORD *)(v9 + 40) = 93;
  *(_DWORD *)(v9 + 48) = *((_DWORD *)a1 + 143);
  *(_DWORD *)(*a1 + 52) = v8 - 2;
  uint64_t v10 = 1;
  (*(void (**)(void *, uint64_t))(*a1 + 8))(a1, 1);
  unsigned __int8 *v2 = v5 + 1;
  v2[1] = v7;
  if (v8 >= 3) {
    (*(void (**)(void *, unint64_t))(a1[5] + 32))(a1, v8 - 2);
  }
  return v10;
}

uint64_t get_interesting_appn(uint64_t a1)
{
  v22[2] = *MEMORY[0x1E4F143B8];
  int v2 = *(unsigned __int8 ***)(a1 + 40);
  uint64_t v3 = v2[1];
  if (!v3)
  {
    uint64_t result = ((uint64_t (*)(uint64_t))v2[3])(a1);
    if (!result) {
      return result;
    }
    uint64_t v3 = v2[1];
  }
  int v6 = *v2 + 1;
  uint64_t v5 = **v2;
  int v7 = v3 - 1;
  if (!v7)
  {
    uint64_t result = ((uint64_t (*)(uint64_t))v2[3])(a1);
    if (!result) {
      return result;
    }
    int v6 = *v2;
    int v7 = v2[1];
  }
  memset(v22, 0, 14);
  unsigned int v9 = *v6;
  unint64_t v8 = v6 + 1;
  unint64_t v10 = (v5 << 8) | v9;
  unint64_t v11 = v10 - 2;
  if (v10 <= 2) {
    unsigned int v12 = 0;
  }
  else {
    unsigned int v12 = v10 - 2;
  }
  if (v10 <= 0xF) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 14;
  }
  uint8x16_t v14 = v7 - 1;
  if (v13)
  {
    uint16x8_t v15 = v22;
    uint64_t v16 = v13;
    do
    {
      if (!v14)
      {
        uint64_t result = ((uint64_t (*)(uint64_t))v2[3])(a1);
        if (!result) {
          return result;
        }
        unint64_t v8 = *v2;
        uint8x16_t v14 = v2[1];
      }
      char v17 = *v8++;
      *v15++ = v17;
      --v14;
      --v16;
    }
    while (v16);
    uint64_t v18 = v13;
  }
  else
  {
    uint64_t v18 = 0;
  }
  uint64_t v19 = v11 - v18;
  int v20 = *(_DWORD *)(a1 + 572);
  if (v20 == 238)
  {
    examine_app14((uint64_t *)a1, (uint64_t)v22, v13, v19);
  }
  else if (v20 == 224)
  {
    examine_app0((uint64_t *)a1, (uint64_t)v22, v13, v19);
  }
  else
  {
    uint64_t v21 = *(void *)a1;
    *(_DWORD *)(v21 + 40) = 70;
    *(_DWORD *)(v21 + 48) = v20;
    (**(void (***)(uint64_t))a1)(a1);
  }
  unsigned __int8 *v2 = v8;
  v2[1] = v14;
  if (v19 >= 1) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 + 40) + 32))(a1, v19);
  }
  return 1;
}

void *_cg_jpeg_save_markers(void *result, int a2, unsigned int a3)
{
  uint64_t v3 = result[77];
  uint64_t v4 = *(void *)(result[1] + 96) - 32;
  if (v4 >= a3) {
    LODWORD(v4) = a3;
  }
  if (v4)
  {
    uint64_t v5 = save_marker;
    if (a2 == 224 && v4 < 0xE)
    {
      int v6 = 14;
LABEL_23:
      *(void *)(v3 + 8 * (a2 - 224) + 48) = v5;
      *(_DWORD *)(v3 + 4 * (a2 - 224) + 180) = v6;
      return result;
    }
    if (v4 < 0xC && a2 == 238) {
      int v6 = 12;
    }
    else {
      int v6 = v4;
    }
    uint64_t v5 = save_marker;
  }
  else
  {
    int v6 = 0;
    BOOL v7 = a2 == 238 || a2 == 224;
    uint64_t v5 = get_interesting_appn;
    if (!v7) {
      uint64_t v5 = skip_variable;
    }
  }
  if (a2 == 254)
  {
    *(void *)(v3 + 40) = v5;
    *(_DWORD *)(v3 + 176) = v6;
    return result;
  }
  if ((a2 & 0xFFFFFFF0) == 0xE0) {
    goto LABEL_23;
  }
  unsigned int v9 = (uint64_t (**)(void))*result;
  *((_DWORD *)v9 + 10) = 70;
  *((_DWORD *)v9 + 12) = a2;
  return (void *)(*(uint64_t (**)(void *))*result)(result);
}

uint64_t save_marker(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 616);
  uint64_t v3 = *(void *)(v2 + 248);
  uint64_t v4 = *(unsigned __int8 ***)(a1 + 40);
  uint64_t v5 = *v4;
  int v6 = v4[1];
  if (v3)
  {
    uint64_t v7 = *(unsigned int *)(v2 + 256);
    LODWORD(v8) = *(_DWORD *)(v3 + 16);
    uint64_t v9 = *(void *)(v3 + 24) + v7;
    goto LABEL_29;
  }
  if (!v6)
  {
    uint64_t result = ((uint64_t (*)(uint64_t))v4[3])(a1);
    if (!result) {
      return result;
    }
    uint64_t v5 = *v4;
    int v6 = v4[1];
  }
  unsigned int v13 = *v5;
  unsigned int v12 = v5 + 1;
  uint64_t v11 = v13;
  uint8x16_t v14 = v6 - 1;
  if (v6 == (unsigned __int8 *)1)
  {
    uint64_t result = ((uint64_t (*)(uint64_t))v4[3])(a1);
    if (!result) {
      return result;
    }
    unsigned int v12 = *v4;
    uint8x16_t v14 = v4[1];
  }
  int v6 = v14 - 1;
  unsigned int v15 = *v12;
  uint64_t v5 = v12 + 1;
  unint64_t v16 = (v11 << 8) | v15;
  uint64_t v17 = v16 - 2;
  if (v16 < 2)
  {
    LODWORD(v8) = 0;
    uint64_t v25 = 0;
  }
  else
  {
    int v18 = *(_DWORD *)(a1 + 572);
    if (v18 == 254) {
      uint64_t v19 = (unsigned int *)(v2 + 176);
    }
    else {
      uint64_t v19 = (unsigned int *)(v2 + 4 * (v18 - 224) + 180);
    }
    unsigned int v20 = *v19;
    if (v20 >= v17) {
      uint64_t v8 = v17;
    }
    else {
      uint64_t v8 = v20;
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 8))(a1, 1, v8 + 32);
    LODWORD(v7) = 0;
    *(void *)uint64_t v3 = 0;
    *(unsigned char *)(v3 + 8) = *(_DWORD *)(a1 + 572);
    *(_DWORD *)(v3 + 12) = v17;
    *(_DWORD *)(v3 + 16) = v8;
    uint64_t v9 = v3 + 32;
    *(void *)(v3 + 24) = v3 + 32;
    *(void *)(v2 + 248) = v3;
    *(_DWORD *)(v2 + 256) = 0;
LABEL_29:
    while (v7 < v8)
    {
      void *v4 = v5;
      v4[1] = v6;
      *(_DWORD *)(v2 + 256) = v7;
      if (!v6)
      {
        uint64_t result = ((uint64_t (*)(uint64_t))v4[3])(a1);
        if (!result) {
          return result;
        }
        uint64_t v5 = *v4;
        int v6 = v4[1];
      }
      if (v7 < v8 && v6)
      {
        uint64_t v21 = 0;
        do
        {
          v21[v9] = v21[(void)v5];
          BOOL v22 = (int)v7 + (int)v21 + 1 >= v8 || v6 - 1 == v21;
          ++v21;
        }
        while (!v22);
        v6 -= (uint64_t)v21;
        uint64_t v5 = &v21[(void)v5];
        v9 += (uint64_t)v21;
        LODWORD(v7) = v7 + v21;
      }
    }
    size_t v23 = *(uint64_t **)(a1 + 408);
    if (v23)
    {
      do
      {
        uint64_t v24 = v23;
        size_t v23 = (uint64_t *)*v23;
      }
      while (v23);
    }
    else
    {
      uint64_t v24 = (uint64_t *)(a1 + 408);
    }
    *uint64_t v24 = v3;
    uint64_t v25 = *(void *)(v3 + 24);
    uint64_t v17 = (*(_DWORD *)(v3 + 12) - v8);
  }
  *(void *)(v2 + 248) = 0;
  int v26 = *(_DWORD *)(a1 + 572);
  if (v26 == 238)
  {
    examine_app14((uint64_t *)a1, v25, v8, v17);
  }
  else if (v26 == 224)
  {
    examine_app0((uint64_t *)a1, v25, v8, v17);
  }
  else
  {
    uint64_t v27 = *(void *)a1;
    *(_DWORD *)(v27 + 40) = 93;
    *(_DWORD *)(v27 + 48) = v26;
    *(_DWORD *)(*(void *)a1 + 52) = v8 + v17;
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 8))(a1, 1);
  }
  void *v4 = v5;
  v4[1] = v6;
  if (v17 >= 1) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)(a1 + 40) + 32))(a1, v17);
  }
  return 1;
}

uint64_t get_sof(uint64_t *a1, int a2, int a3, int a4)
{
  uint64_t v5 = (unsigned __int8 **)a1[5];
  uint64_t v7 = *v5;
  int v6 = v5[1];
  *((_DWORD *)a1 + 78) = a2;
  *((_DWORD *)a1 + 79) = a3;
  *((_DWORD *)a1 + 80) = a4;
  if (!v6)
  {
    uint64_t result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!result) {
      return result;
    }
    uint64_t v7 = *v5;
    int v6 = v5[1];
  }
  unsigned int v11 = *v7;
  uint64_t v9 = v7 + 1;
  uint64_t v10 = v11;
  unsigned int v12 = v6 - 1;
  if (!v12)
  {
    uint64_t result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!result) {
      return result;
    }
    uint64_t v9 = *v5;
    unsigned int v12 = v5[1];
  }
  unsigned int v15 = *v9;
  unsigned int v13 = v9 + 1;
  uint64_t v14 = v15;
  unint64_t v16 = v12 - 1;
  if (!v16)
  {
    uint64_t result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!result) {
      return result;
    }
    unsigned int v13 = *v5;
    unint64_t v16 = v5[1];
  }
  int v18 = *v13;
  uint64_t v17 = v13 + 1;
  *((_DWORD *)a1 + 74) = v18;
  uint64_t v19 = v16 - 1;
  if (!v19)
  {
    uint64_t result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!result) {
      return result;
    }
    uint64_t v17 = *v5;
    uint64_t v19 = v5[1];
  }
  int v21 = *v17;
  unsigned int v20 = v17 + 1;
  int v22 = v21 << 8;
  *((_DWORD *)a1 + 13) = v21 << 8;
  size_t v23 = v19 - 1;
  if (!v23)
  {
    uint64_t result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!result) {
      return result;
    }
    unsigned int v20 = *v5;
    size_t v23 = v5[1];
    int v22 = *((_DWORD *)a1 + 13);
  }
  int v25 = *v20;
  uint64_t v24 = v20 + 1;
  *((_DWORD *)a1 + 13) = v22 + v25;
  int v26 = v23 - 1;
  if (!v26)
  {
    uint64_t result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!result) {
      return result;
    }
    uint64_t v24 = *v5;
    int v26 = v5[1];
  }
  int v28 = *v24;
  uint64_t v27 = v24 + 1;
  int v29 = v28 << 8;
  *((_DWORD *)a1 + 12) = v28 << 8;
  unsigned int v30 = v26 - 1;
  if (!v30)
  {
    uint64_t result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!result) {
      return result;
    }
    uint64_t v27 = *v5;
    unsigned int v30 = v5[1];
    int v29 = *((_DWORD *)a1 + 12);
  }
  int v32 = *v27;
  v31 = v27 + 1;
  *((_DWORD *)a1 + 12) = v29 + v32;
  int64_t v33 = v30 - 1;
  if (v30 == (unsigned __int8 *)1)
  {
    uint64_t result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
    if (!result) {
      return result;
    }
    v31 = *v5;
    int64_t v33 = v5[1];
  }
  uint64_t v34 = (v10 << 8) | v14;
  *((_DWORD *)a1 + 14) = *v31;
  uint64_t v35 = *a1;
  *(_DWORD *)(v35 + 48) = *((_DWORD *)a1 + 143);
  *(_DWORD *)(v35 + 52) = *((_DWORD *)a1 + 12);
  *(_DWORD *)(v35 + 56) = *((_DWORD *)a1 + 13);
  *(_DWORD *)(v35 + 60) = *((_DWORD *)a1 + 14);
  *(_DWORD *)(v35 + 40) = 102;
  (*(void (**)(uint64_t *, uint64_t))(v35 + 8))(a1, 1);
  if (*(_DWORD *)(a1[77] + 28))
  {
    uint64_t v36 = *a1;
    *(_DWORD *)(v36 + 40) = 61;
    (*(void (**)(uint64_t *))v36)(a1);
  }
  uint64_t v37 = v34 - 8;
  if (!*((_DWORD *)a1 + 13) || !*((_DWORD *)a1 + 12) || (int v38 = *((_DWORD *)a1 + 14), v38 <= 0))
  {
    uint64_t v39 = *a1;
    *(_DWORD *)(v39 + 40) = 33;
    (*(void (**)(uint64_t *))v39)(a1);
    int v38 = *((_DWORD *)a1 + 14);
  }
  if (v37 != 3 * v38)
  {
    uint64_t v40 = *a1;
    *(_DWORD *)(v40 + 40) = 12;
    (*(void (**)(uint64_t *))v40)(a1);
    int v38 = *((_DWORD *)a1 + 14);
  }
  if (!a1[38])
  {
    a1[38] = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))a1[1])(a1, 1, 96 * v38);
    int v38 = *((_DWORD *)a1 + 14);
  }
  uint32x4_t v41 = v31 + 1;
  v42 = v33 - 1;
  if (v38 >= 1)
  {
    unsigned int v43 = 0;
    int v44 = -1;
    do
    {
      if (!v42)
      {
        uint64_t result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
        if (!result) {
          return result;
        }
        uint32x4_t v41 = *v5;
        v42 = v5[1];
      }
      int v47 = *v41;
      v46 = v41 + 1;
      int v45 = v47;
      v48 = (int *)a1[38];
      if (v43)
      {
        unsigned int v49 = v43;
        uint64_t v50 = (int *)a1[38];
        while (*v50 != v45)
        {
          v50 += 24;
          if (!--v49)
          {
            v48 = v50;
            goto LABEL_51;
          }
        }
        int v52 = *v48;
        v48 += 24;
        int v51 = v52;
        if (v43 >= 2)
        {
          int v53 = v44;
          do
          {
            int v55 = *v48;
            v48 += 24;
            int v54 = v55;
            if (v55 > v51) {
              int v51 = v54;
            }
            --v53;
          }
          while (v53);
        }
        int v45 = v51 + 1;
      }
LABEL_51:
      int *v48 = v45;
      v48[1] = v43;
      v56 = v42 - 1;
      if (!v56)
      {
        uint64_t result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
        if (!result) {
          return result;
        }
        v46 = *v5;
        v56 = v5[1];
      }
      unsigned int v58 = *v46;
      v57 = v46 + 1;
      v48[2] = v58 >> 4;
      v48[3] = v58 & 0xF;
      unint64_t v59 = v56 - 1;
      if (v56 == (unsigned __int8 *)1)
      {
        uint64_t result = ((uint64_t (*)(uint64_t *))v5[3])(a1);
        if (!result) {
          return result;
        }
        v57 = *v5;
        unint64_t v59 = v5[1];
      }
      int v60 = *v57;
      uint32x4_t v41 = v57 + 1;
      v48[4] = v60;
      uint64_t v61 = *a1;
      *(_DWORD *)(v61 + 48) = *v48;
      *(_DWORD *)(v61 + 52) = v48[2];
      *(_DWORD *)(v61 + 56) = v48[3];
      *(_DWORD *)(v61 + 60) = v48[4];
      *(_DWORD *)(v61 + 40) = 103;
      (*(void (**)(uint64_t *, uint64_t))(v61 + 8))(a1, 1);
      ++v43;
      v42 = v59 - 1;
      ++v44;
    }
    while ((signed int)v43 < *((_DWORD *)a1 + 14));
  }
  uint64_t result = 1;
  *(_DWORD *)(a1[77] + 28) = 1;
  *uint64_t v5 = v41;
  v5[1] = v42;
  return result;
}

uint64_t examine_app0(uint64_t *a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v6 = a4 + a3;
  if (a3 < 0xE)
  {
    if (a3 < 6 || *(unsigned char *)a2 != 74) {
      goto LABEL_19;
    }
    goto LABEL_15;
  }
  if (*(unsigned char *)a2 != 74) {
    goto LABEL_19;
  }
  if (*(unsigned char *)(a2 + 1) != 70 || *(unsigned char *)(a2 + 2) != 73 || *(unsigned char *)(a2 + 3) != 70 || *(unsigned char *)(a2 + 4))
  {
LABEL_15:
    if (*(unsigned char *)(a2 + 1) == 70 && *(unsigned char *)(a2 + 2) == 88 && *(unsigned char *)(a2 + 3) == 88 && !*(unsigned char *)(a2 + 4))
    {
      int v21 = *(unsigned __int8 *)(a2 + 5);
      switch(v21)
      {
        case 19:
          uint64_t v18 = *a1;
          int v19 = 112;
          break;
        case 17:
          uint64_t v18 = *a1;
          int v19 = 111;
          break;
        case 16:
          uint64_t v18 = *a1;
          int v19 = 110;
          break;
        default:
          uint64_t v23 = *a1;
          *(_DWORD *)(v23 + 40) = 91;
          *(_DWORD *)(v23 + 48) = *(unsigned __int8 *)(a2 + 5);
          *(_DWORD *)(*a1 + 52) = v6;
          goto LABEL_21;
      }
      goto LABEL_20;
    }
LABEL_19:
    uint64_t v18 = *a1;
    int v19 = 79;
LABEL_20:
    *(_DWORD *)(v18 + 40) = v19;
    *(_DWORD *)(v18 + 48) = v6;
LABEL_21:
    unsigned int v20 = *(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 8);
    return v20(a1, 1);
  }
  *((_DWORD *)a1 + 94) = 1;
  int v7 = *(unsigned __int8 *)(a2 + 5);
  *((unsigned char *)a1 + 380) = v7;
  int v8 = *(unsigned __int8 *)(a2 + 6);
  *((unsigned char *)a1 + 381) = v8;
  int v9 = *(unsigned __int8 *)(a2 + 7);
  *((unsigned char *)a1 + 382) = v9;
  unsigned int v10 = bswap32(*(unsigned __int16 *)(a2 + 8)) >> 16;
  *((_WORD *)a1 + 192) = v10;
  unsigned int v11 = bswap32(*(unsigned __int16 *)(a2 + 10)) >> 16;
  *((_WORD *)a1 + 193) = v11;
  if ((v7 - 1) >= 2)
  {
    uint64_t v12 = *a1;
    *(_DWORD *)(v12 + 40) = 122;
    *(_DWORD *)(v12 + 48) = v7;
    *(_DWORD *)(*a1 + 52) = *((unsigned __int8 *)a1 + 381);
    (*(void (**)(uint64_t *, uint64_t))(*a1 + 8))(a1, 0xFFFFFFFFLL);
    int v7 = *((unsigned __int8 *)a1 + 380);
    int v8 = *((unsigned __int8 *)a1 + 381);
    unsigned int v10 = *((unsigned __int16 *)a1 + 192);
    unsigned int v11 = *((unsigned __int16 *)a1 + 193);
    int v9 = *((unsigned __int8 *)a1 + 382);
  }
  uint64_t v13 = *a1;
  *(_DWORD *)(v13 + 48) = v7;
  *(_DWORD *)(v13 + 52) = v8;
  *(_DWORD *)(v13 + 56) = v10;
  *(_DWORD *)(v13 + 60) = v11;
  *(_DWORD *)(v13 + 64) = v9;
  *(_DWORD *)(v13 + 40) = 89;
  uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t))(v13 + 8))(a1, 1);
  unsigned int v15 = *(unsigned __int8 *)(a2 + 12);
  unsigned int v16 = *(unsigned __int8 *)(a2 + 13);
  if (v16 | v15)
  {
    uint64_t v17 = *a1;
    *(_DWORD *)(v17 + 40) = 92;
    *(_DWORD *)(v17 + 48) = *(unsigned __int8 *)(a2 + 12);
    *(_DWORD *)(*a1 + 52) = *(unsigned __int8 *)(a2 + 13);
    uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 8))(a1, 1);
    unsigned int v15 = *(unsigned __int8 *)(a2 + 12);
    unsigned int v16 = *(unsigned __int8 *)(a2 + 13);
  }
  if (v6 - 14 != 3 * v15 * (unint64_t)v16)
  {
    uint64_t v22 = *a1;
    *(_DWORD *)(v22 + 40) = 90;
    *(_DWORD *)(v22 + 48) = v6 - 14;
    goto LABEL_21;
  }
  return result;
}

uint64_t examine_app14(uint64_t *a1, uint64_t a2, unsigned int a3, int a4)
{
  if (a3 >= 0xC
    && *(unsigned char *)a2 == 65
    && *(unsigned char *)(a2 + 1) == 100
    && *(unsigned char *)(a2 + 2) == 111
    && *(unsigned char *)(a2 + 3) == 98
    && *(unsigned char *)(a2 + 4) == 101)
  {
    unsigned int v5 = __rev16(*(unsigned __int16 *)(a2 + 7));
    unsigned int v6 = __rev16(*(unsigned __int16 *)(a2 + 9));
    int v7 = *(unsigned __int8 *)(a2 + 11);
    uint64_t v8 = *a1;
    *(_DWORD *)(v8 + 48) = __rev16(*(unsigned __int16 *)(a2 + 5));
    *(_DWORD *)(v8 + 52) = v5;
    *(_DWORD *)(v8 + 56) = v6;
    *(_DWORD *)(v8 + 60) = v7;
    *(_DWORD *)(v8 + 40) = 78;
    uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t))(v8 + 8))(a1, 1);
    *((_DWORD *)a1 + 97) = 1;
    *((unsigned char *)a1 + 392) = v7;
  }
  else
  {
    uint64_t v10 = *a1;
    *(_DWORD *)(v10 + 40) = 80;
    *(_DWORD *)(v10 + 48) = a4 + a3;
    unsigned int v11 = *(uint64_t (**)(void))(*a1 + 8);
    return v11();
  }
  return result;
}

uint64_t _cg_jpeg_start_compress(uint64_t a1, int a2)
{
  int v4 = *(_DWORD *)(a1 + 36);
  if (v4 != 100)
  {
    unsigned int v5 = *(void (***)(void))a1;
    *((_DWORD *)v5 + 10) = 21;
    *((_DWORD *)v5 + 12) = v4;
    (**(void (***)(uint64_t))a1)(a1);
  }
  if (a2) {
    _cg_jpeg_suppress_tables(a1, 0);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
  (*(void (**)(uint64_t))(*(void *)(a1 + 40) + 16))(a1);
  _cg_jinit_compress_master(a1);
  uint64_t result = (**(uint64_t (***)(uint64_t))(a1 + 496))(a1);
  *(_DWORD *)(a1 + 344) = 0;
  if (*(_DWORD *)(a1 + 288)) {
    int v7 = 102;
  }
  else {
    int v7 = 101;
  }
  *(_DWORD *)(a1 + 36) = v7;
  return result;
}

uint64_t _cg_jpeg_write_scanlines(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v6 = *(_DWORD *)(a1 + 36);
  if (v6 != 101)
  {
    int v7 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v7 + 10) = 21;
    *((_DWORD *)v7 + 12) = v6;
    (**(void (***)(uint64_t))a1)(a1);
  }
  if (*(_DWORD *)(a1 + 344) >= *(_DWORD *)(a1 + 52))
  {
    uint64_t v8 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v8 + 10) = 126;
    ((void (*)(uint64_t, uint64_t))v8[1])(a1, 0xFFFFFFFFLL);
  }
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9)
  {
    uint64_t v10 = *(unsigned int *)(a1 + 52);
    *(void *)(v9 + 8) = *(unsigned int *)(a1 + 344);
    *(void *)(v9 + 16) = v10;
    (*(void (**)(uint64_t))v9)(a1);
  }
  uint64_t v11 = *(void *)(a1 + 496);
  if (*(_DWORD *)(v11 + 24)) {
    (*(void (**)(uint64_t))(v11 + 8))(a1);
  }
  unsigned int v12 = *(_DWORD *)(a1 + 52) - *(_DWORD *)(a1 + 344);
  if (v12 >= a3) {
    uint64_t v13 = a3;
  }
  else {
    uint64_t v13 = v12;
  }
  unsigned int v15 = 0;
  (*(void (**)(uint64_t, uint64_t, unsigned int *, uint64_t))(*(void *)(a1 + 504) + 8))(a1, a2, &v15, v13);
  uint64_t result = v15;
  *(_DWORD *)(a1 + 344) += v15;
  return result;
}

uint64_t _cg_jpeg_write_raw_data(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v6 = *(_DWORD *)(a1 + 36);
  if (v6 != 102)
  {
    int v7 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v7 + 10) = 21;
    *((_DWORD *)v7 + 12) = v6;
    (**(void (***)(uint64_t))a1)(a1);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 344);
  uint64_t v9 = *(unsigned int *)(a1 + 52);
  if (v8 >= v9)
  {
    uint64_t v14 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v14 + 10) = 126;
    ((void (*)(uint64_t, uint64_t))v14[1])(a1, 0xFFFFFFFFLL);
    return 0;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  if (v10)
  {
    *(void *)(v10 + 8) = v8;
    *(void *)(v10 + 16) = v9;
    (*(void (**)(uint64_t))v10)(a1);
  }
  uint64_t v11 = *(void *)(a1 + 496);
  if (*(_DWORD *)(v11 + 24)) {
    (*(void (**)(uint64_t))(v11 + 8))(a1);
  }
  uint64_t v12 = (*(_DWORD *)(a1 + 364) * *(_DWORD *)(a1 + 356));
  if (v12 > a3)
  {
    uint64_t v13 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v13 + 10) = 24;
    (*v13)(a1);
  }
  if (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)(a1 + 520) + 8))(a1, a2)) {
    return 0;
  }
  *(_DWORD *)(a1 + 344) += v12;
  return v12;
}

double HEIFReadPlugin::ColorConvert(HEIFReadPlugin *this, __CVBuffer *a2, unint64_t a3, IIOColorConverter *a4, void *a5, double result)
{
  if (this)
  {
    IIO_LoadHEIFSymbols();
    if (gFunc_CVPixelBufferGetPixelFormatType(this) == 1111970369
      && !gFunc_CVPixelBufferLockBaseAddress(this, 0))
    {
      vImagePixelCount Width = gFunc_CVPixelBufferGetWidth(this);
      vImagePixelCount Height = gFunc_CVPixelBufferGetHeight(this);
      size_t BytesPerRow = gFunc_CVPixelBufferGetBytesPerRow(this);
      BaseAddress = (void *)gFunc_CVPixelBufferGetBaseAddress(this);
      if (BaseAddress)
      {
        v15.data = BaseAddress;
        v15.height = Height;
        v15.width = Width;
        v15.rowBytes = BytesPerRow;
        vImage_Error v13 = IIOColorConverter::colorConvert(a4, &v15, &v15);
        if (v13)
        {
          uint64_t v14 = IIO_vImageErrorString(v13);
          LogError("ColorConvert", 91, "*** vImageConvert_AnyToAny - %s\n", v14);
        }
      }
      return gFunc_CVPixelBufferUnlockBaseAddress(this, 0, v12);
    }
  }
  return result;
}

uint64_t HEIFReadPlugin::IIORecodeHEIF_to_JPEG(HEIFReadPlugin *this, IIOImageDestination *a2, IIOImageSource *a3)
{
  unsigned int v3 = a3;
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "IIORecodeHEIF_to_JPEG", 0, 0, -1, 0);
  }
  CFTypeRef v29 = 0;
  *(void *)buffer = 0;
  uint64_t v27 = 0;
  CFTypeRef v28 = 0;
  int v26 = 0;
  CFTypeRef v25 = 0;
  memset(v24, 0, sizeof(v24));
  IIODictionary::IIODictionary((IIODictionary *)v24);
  memset(v23, 0, sizeof(v23));
  IIODictionary::IIODictionary((IIODictionary *)v23);
  memset(v22, 0, sizeof(v22));
  IIODictionary::IIODictionary((IIODictionary *)v22);
  int v21 = 0;
  IIOImageSource::count(this);
  CGColorSpaceRef v20 = 0;
  CFStringRef v6 = (const __CFString *)*MEMORY[0x1E4F1DC98];
  v19[0] = (CGColorSpaceRef)&unk_1ED4DFD58;
  v19[1] = CGColorSpaceCreateWithName(v6);
  Plugin = (CGImage *)IIOImagePlus::readPlugin(this);
  ImageAtIndex = Plugin;
  if (Plugin)
  {
    CGImageRetain(Plugin);
  }
  else
  {
    ColorSpace = (CGImageSource *)IIOReadPlugin::getColorSpace(this);
    ImageAtIndex = CGImageSourceCreateImageAtIndex(ColorSpace, 0, 0);
    if (!ImageAtIndex)
    {
      _cg_jpeg_mem_term("IIORecodeHEIF_to_JPEG", 154, "*** ERROR: cannot get the source image...");
      ImageAtIndex = 0;
      goto LABEL_22;
    }
  }
  space = CGImageGetColorSpace(ImageAtIndex);
  CGColorSpaceGetModel(space);
  if (a2)
  {
    uint64_t Ref = IIOImageSource::imageReadRef(a2);
    *(void *)buffer = Ref;
    if (Ref) {
      goto LABEL_8;
    }
  }
  else
  {
    CFDataRef Property = (const __CFData *)CGImageGetProperty();
    if (Property)
    {
      v31.location = 0;
      v31.length = 8;
      CFDataGetBytes(Property, v31, buffer);
    }
    uint64_t Ref = *(void *)buffer;
    if (*(void *)buffer)
    {
LABEL_8:
      CFTypeRef cf = (CFTypeRef)CGImageReadSessionCreate(Ref);
      CGImageSourceGetSource((uint64_t)cf);
      unint64_t v11 = v3;
      if (a2)
      {
        ImagePropertiesAtIndex = (IIODictionary *)IIOImageSource::getImagePropertiesAtIndex(a2, v3);
        unint64_t v11 = v3;
      }
      else
      {
        ImagePropertiesAtIndex = 0;
      }
      uint64_t v14 = (IIODictionary *)IIOImageDestination::getImagePropertiesAtIndex(this, v11);
      if (!v14) {
        uint64_t v14 = (IIODictionary *)IIOImageDestination::getImagePropertiesAtIndex(this, 0);
      }
      if (IIODictionary::containsKey(v14, @"kCGImageSourceTiledDownsamplingMode")) {
        IIODictionary::getUint32ForKey(v14, @"kCGImageSourceTiledDownsamplingMode");
      }
      IIOSkipMetadata(ImagePropertiesAtIndex);
      if (v14) {
        IIODictionary::getBoolForKey(v14, @"kCGImageSourceCreateThumbnailWithTransform");
      }
      IIOReadPlugin::CreateRecodeProperties(a2, ImagePropertiesAtIndex, this, v14, (IIODictionary *)&v29, v15);
    }
  }
  _cg_jpeg_mem_term("IIORecodeHEIF_to_JPEG", 175, "*** ERROR: cannot get the 'CGImageReadRef' of the source image...");
LABEL_22:
  CGImageRelease(ImageAtIndex);
  CGColorSpaceRelease(0);
  CGColorSpaceRelease(v20);
  CGColorSpaceRelease(0);
  if (v25) {
    CFRelease(v25);
  }
  if (v29) {
    CFRelease(v29);
  }
  if (v28) {
    CFRelease(v28);
  }
  IIOColorSpace::~IIOColorSpace(v19);
  IIODictionary::~IIODictionary((IIODictionary *)v22);
  IIODictionary::~IIODictionary((IIODictionary *)v23);
  IIODictionary::~IIODictionary((IIODictionary *)v24);
  return 4294967246;
}

void sub_1886AE2B0(_Unwind_Exception *a1)
{
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)(v1 - 256));
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 224));
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 200));
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 176));
  _Unwind_Resume(a1);
}

void IIOColorSpace::~IIOColorSpace(CGColorSpaceRef *this)
{
  IIOColorSpace::~IIOColorSpace(this);

  JUMPOUT(0x18C11C0E0);
}

{
  *this = (CGColorSpaceRef)&unk_1ED4DFD58;
  CGColorSpaceRelease(this[1]);
}

void *_cg_jinit_color_deconverter(uint64_t a1)
{
  uint64_t result = (void *)(**(uint64_t (***)(void))(a1 + 8))();
  unsigned int v3 = result;
  *(void *)(a1 + 648) = result;
  *uint64_t result = start_pass_dcolor;
  unsigned int v4 = *(_DWORD *)(a1 + 60);
  if (v4 > 7) {
    goto LABEL_34;
  }
  if (((1 << v4) & 0xCC) == 0)
  {
    if (((1 << v4) & 0x30) != 0)
    {
      if (*(_DWORD *)(a1 + 56) == 4) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
    if (v4 == 1)
    {
      if (*(_DWORD *)(a1 + 56) == 1) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
LABEL_34:
    if (*(int *)(a1 + 56) > 0) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  if (*(_DWORD *)(a1 + 56) != 3)
  {
LABEL_4:
    uint64_t v5 = *(void *)a1;
    *(_DWORD *)(v5 + 40) = 11;
    uint64_t result = (void *)(*(uint64_t (**)(uint64_t))v5)(a1);
  }
LABEL_5:
  if (*(_DWORD *)(a1 + 396) && (*(_DWORD *)(a1 + 60) | 4) != 6)
  {
    uint64_t v6 = *(void *)a1;
    *(_DWORD *)(v6 + 40) = 28;
    uint64_t result = (void *)(*(uint64_t (**)(uint64_t))v6)(a1);
  }
  int v7 = *(_DWORD *)(a1 + 64);
  switch(v7)
  {
    case 1:
      *(_DWORD *)(a1 + 144) = 1;
      switch(*(_DWORD *)(a1 + 60))
      {
        case 1:
        case 3:
        case 7:
          v3[1] = grayscale_convert_0;
          uint64_t v8 = *(unsigned int *)(a1 + 56);
          if ((int)v8 >= 2)
          {
            uint64_t v9 = (_DWORD *)(*(void *)(a1 + 304) + 148);
            uint64_t v10 = v8 - 1;
            do
            {
              *uint64_t v9 = 0;
              v9 += 24;
              --v10;
            }
            while (v10);
          }
          goto LABEL_46;
        case 2:
          int v17 = *(_DWORD *)(a1 + 396);
          if (v17 == 1)
          {
            uint64_t v18 = rgb1_gray_convert;
            goto LABEL_54;
          }
          if (!v17)
          {
            uint64_t v18 = rgb_gray_convert_0;
LABEL_54:
            v3[1] = v18;
            goto LABEL_56;
          }
          uint64_t v31 = *(void *)a1;
          *(_DWORD *)(v31 + 40) = 28;
          (*(void (**)(uint64_t))v31)(a1);
LABEL_56:
          uint64_t v32 = *(void *)(a1 + 648);
          uint64_t result = (void *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 6144);
          uint64_t v33 = 0;
          uint64_t v34 = 0;
          uint64_t v35 = 0;
          *(void *)(v32 + 48) = result;
          uint64_t v36 = 0x8000;
          do
          {
            uint64_t v37 = &result[v35];
            void *v37 = v33;
            ++v35;
            v37[256] = v34;
            v37[512] = v36;
            v36 += 7471;
            v34 += 38470;
            v33 += 19595;
          }
          while (v35 != 256);
LABEL_46:
          if (*(_DWORD *)(a1 + 108)) {
            int v21 = 1;
          }
          else {
            int v21 = *(_DWORD *)(a1 + 144);
          }
          *(_DWORD *)(a1 + 148) = v21;
          return result;
        default:
          goto LABEL_43;
      }
    case 2:
      *(_DWORD *)(a1 + 144) = 3;
      switch(*(_DWORD *)(a1 + 60))
      {
        case 1:
          vImage_Error v13 = gray_rgb_convert;
          goto LABEL_45;
        case 2:
          int v19 = *(_DWORD *)(a1 + 396);
          if (v19 == 1) {
            goto LABEL_44;
          }
          if (v19) {
            goto LABEL_43;
          }
          goto LABEL_30;
        case 3:
          __n128 v12 = ycc_rgb_convert;
          goto LABEL_40;
        case 7:
          v3[1] = ycc_rgb_convert;
          uint64_t v22 = *(void **)(a1 + 648);
          v22[2] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1024);
          void v22[3] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1024);
          v22[4] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2048);
          uint64_t result = (void *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2048);
          uint64_t v23 = 0;
          v22[5] = result;
          uint64_t v24 = v22[2];
          uint64_t v25 = v22[3];
          unint64_t v26 = -29696512;
          unint64_t v27 = -23488896;
          uint64_t v28 = 5806464;
          uint64_t v29 = 11981184;
          uint64_t v30 = v22[4];
          do
          {
            *(_DWORD *)(v24 + 4 * v23) = v27 >> 16;
            *(_DWORD *)(v25 + 4 * v23) = v26 >> 16;
            *(void *)(v30 + 8 * v23) = v29;
            result[v23++] = v28;
            v28 -= 45107;
            v29 -= 93603;
            v26 += 232260;
            v27 += 183763;
          }
          while (v23 != 256);
          goto LABEL_46;
        default:
          goto LABEL_43;
      }
    case 4:
      *(_DWORD *)(a1 + 144) = 4;
      int v11 = *(_DWORD *)(a1 + 60);
      if (v11 == 4) {
        goto LABEL_25;
      }
      if (v11 != 5) {
        goto LABEL_43;
      }
      __n128 v12 = ycck_cmyk_convert;
LABEL_40:
      v3[1] = v12;
      uint64_t result = (void *)build_ycc_rgb_table(a1);
      goto LABEL_46;
    case 6:
      *(_DWORD *)(a1 + 144) = 3;
      if (*(_DWORD *)(a1 + 60) != 6)
      {
        uint64_t v15 = *(void *)a1;
        *(_DWORD *)(v15 + 40) = 28;
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t))v15)(a1);
      }
      int v16 = *(_DWORD *)(a1 + 396);
      if (v16 == 1)
      {
LABEL_44:
        vImage_Error v13 = rgb1_rgb_convert;
      }
      else
      {
        if (v16)
        {
LABEL_43:
          uint64_t v20 = *(void *)a1;
          *(_DWORD *)(v20 + 40) = 28;
          uint64_t result = (void *)(*(uint64_t (**)(uint64_t))v20)(a1);
          goto LABEL_46;
        }
LABEL_30:
        vImage_Error v13 = rgb_convert_0;
      }
LABEL_45:
      v3[1] = v13;
      goto LABEL_46;
    default:
      if (v7 != *(_DWORD *)(a1 + 60))
      {
        uint64_t v14 = *(void *)a1;
        *(_DWORD *)(v14 + 40) = 28;
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t))v14)(a1);
      }
      *(_DWORD *)(a1 + 144) = *(_DWORD *)(a1 + 56);
LABEL_25:
      vImage_Error v13 = null_convert_0;
      goto LABEL_45;
  }
}

char *grayscale_convert_0(uint64_t a1, char **a2, int a3, uint64_t a4, int a5)
{
  return _cg_jcopy_sample_rows(*a2, a3, a4, 0, a5, *(unsigned int *)(a1 + 136));
}

uint64_t rgb_gray_convert_0(uint64_t result, void *a2, unsigned int a3, void *a4, int a5)
{
  if (a5 >= 1)
  {
    uint64_t v5 = *(void *)(*(void *)(result + 648) + 48);
    uint64_t v6 = *(unsigned int *)(result + 136);
    do
    {
      uint64_t v8 = (unsigned char *)*a4++;
      int v7 = v8;
      if (v6)
      {
        uint64_t v9 = *(unsigned __int8 **)(*a2 + 8 * a3);
        uint64_t v10 = *(unsigned __int8 **)(a2[1] + 8 * a3);
        int v11 = *(unsigned __int8 **)(a2[2] + 8 * a3);
        uint64_t v12 = v6;
        do
        {
          unsigned int v14 = *v9++;
          uint64_t v13 = v14;
          unsigned int v16 = *v10++;
          uint64_t v15 = v16;
          unsigned int v17 = *v11++;
          *v7++ = (*(_DWORD *)(v5 + 8 * v15 + 2048)
                 + *(void *)(v5 + 8 * v13)
                 + *(_DWORD *)(v5 + 8 * v17 + 4096)) >> 16;
          --v12;
        }
        while (v12);
      }
      ++a3;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t rgb1_gray_convert(uint64_t result, void *a2, unsigned int a3, void *a4, int a5)
{
  if (a5 >= 1)
  {
    uint64_t v5 = *(void *)(*(void *)(result + 648) + 48);
    uint64_t v6 = *(unsigned int *)(result + 136);
    do
    {
      uint64_t v8 = (unsigned char *)*a4++;
      int v7 = v8;
      if (v6)
      {
        uint64_t v9 = *(char **)(*a2 + 8 * a3);
        uint64_t v10 = *(unsigned __int8 **)(a2[1] + 8 * a3);
        int v11 = *(unsigned char **)(a2[2] + 8 * a3);
        uint64_t v12 = v6;
        do
        {
          char v14 = *v9++;
          char v13 = v14;
          unsigned int v16 = *v10++;
          uint64_t v15 = v16;
          LOBYTE(v16) = *v11++;
          uint64_t result = v15 ^ 0xFFFFFF80;
          *v7++ = (*(_DWORD *)(v5 + 8 * v15 + 2048)
                 + *(void *)(v5 + 8 * ((v15 ^ 0x80) + v13))
                 + *(_DWORD *)(v5 + 8 * ((v15 ^ 0x80) + v16) + 4096)) >> 16;
          --v12;
        }
        while (v12);
      }
      ++a3;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t gray_rgb_convert(uint64_t result, void *a2, unsigned int a3, void *a4, int a5)
{
  if (a5 >= 1)
  {
    uint64_t v5 = *(unsigned int *)(result + 136);
    do
    {
      if (v5)
      {
        uint64_t v6 = *(char **)(*a2 + 8 * a3);
        int v7 = (unsigned char *)(*a4 + 2);
        uint64_t v8 = v5;
        do
        {
          char v9 = *v6++;
          *int v7 = v9;
          *(v7 - 1) = v9;
          *(v7 - 2) = v9;
          v7 += 3;
          --v8;
        }
        while (v8);
      }
      ++a3;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t ycc_rgb_convert(uint64_t result, void *a2, unsigned int a3, unsigned char **a4, int a5)
{
  if (a5 >= 1)
  {
    uint64_t v5 = *(void **)(result + 648);
    uint64_t v6 = *(void *)(result + 440);
    uint64_t v7 = v5[2];
    uint64_t v8 = v5[3];
    uint64_t v9 = v5[4];
    uint64_t v10 = v5[5];
    uint64_t v11 = *(unsigned int *)(result + 136);
    do
    {
      if (v11)
      {
        uint64_t v12 = *(unsigned __int8 **)(*a2 + 8 * a3);
        char v13 = *(unsigned __int8 **)(a2[1] + 8 * a3);
        char v14 = *(unsigned __int8 **)(a2[2] + 8 * a3);
        uint64_t v15 = *a4;
        uint64_t result = v11;
        do
        {
          unsigned int v17 = *v12++;
          uint64_t v16 = v17;
          unsigned int v19 = *v13++;
          uint64_t v18 = v19;
          unsigned int v20 = *v14++;
          *uint64_t v15 = *(unsigned char *)(v6 + *(int *)(v7 + 4 * v20) + v16);
          v15[1] = *(unsigned char *)(v6 + v16 + (int)((*(void *)(v9 + 8 * v20) + *(void *)(v10 + 8 * v18)) >> 16));
          v15[2] = *(unsigned char *)(v6 + *(int *)(v8 + 4 * v18) + v16);
          v15 += 3;
          --result;
        }
        while (result);
      }
      ++a3;
      ++a4;
      BOOL v22 = __OFSUB__(a5, 2);
      BOOL v21 = a5 - 2 < 0;
      --a5;
    }
    while (v21 == v22);
  }
  return result;
}

uint64_t build_ycc_rgb_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 648);
  v2[2] = (**(uint64_t (***)(void))(a1 + 8))();
  v2[3] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1024);
  v2[4] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2048);
  uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2048);
  uint64_t v4 = 0;
  v2[5] = result;
  uint64_t v5 = v2[2];
  uint64_t v6 = v2[3];
  unint64_t v7 = -11728000;
  unint64_t v8 = -14831872;
  uint64_t v9 = 5990656;
  uint64_t v10 = 2919552;
  uint64_t v11 = v2[4];
  do
  {
    *(_DWORD *)(v5 + 4 * v4) = v7 >> 16;
    *(_DWORD *)(v6 + 4 * v4) = v8 >> 16;
    *(void *)(v11 + 8 * v4) = v9;
    *(void *)(result + 8 * v4++) = v10;
    v7 += 91881;
    v8 += 116130;
    v9 -= 46802;
    v10 -= 22553;
  }
  while (v4 != 256);
  return result;
}

uint64_t rgb_convert_0(uint64_t result, void *a2, unsigned int a3, unsigned char **a4, int a5)
{
  if (a5 >= 1)
  {
    uint64_t v5 = *(unsigned int *)(result + 136);
    do
    {
      if (v5)
      {
        uint64_t v6 = *(char **)(*a2 + 8 * a3);
        unint64_t v7 = *(char **)(a2[1] + 8 * a3);
        unint64_t v8 = *(char **)(a2[2] + 8 * a3);
        uint64_t v9 = *a4;
        uint64_t v10 = v5;
        do
        {
          char v11 = *v6++;
          *uint64_t v9 = v11;
          char v12 = *v7++;
          v9[1] = v12;
          char v13 = *v8++;
          _OWORD v9[2] = v13;
          v9 += 3;
          --v10;
        }
        while (v10);
      }
      ++a3;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t rgb1_rgb_convert(uint64_t result, void *a2, unsigned int a3, unsigned char **a4, int a5)
{
  if (a5 >= 1)
  {
    uint64_t v5 = *(unsigned int *)(result + 136);
    do
    {
      if (v5)
      {
        uint64_t v6 = *(char **)(*a2 + 8 * a3);
        unint64_t v7 = *(char **)(a2[1] + 8 * a3);
        unint64_t v8 = *(char **)(a2[2] + 8 * a3);
        uint64_t v9 = *a4;
        uint64_t v10 = v5;
        do
        {
          char v12 = *v6++;
          char v11 = v12;
          char v14 = *v7++;
          char v13 = v14;
          char v15 = *v8++;
          *uint64_t v9 = (v13 + v11) ^ 0x80;
          v9[1] = v13;
          _OWORD v9[2] = (v15 + v13) ^ 0x80;
          v9 += 3;
          --v10;
        }
        while (v10);
      }
      ++a3;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t ycck_cmyk_convert(uint64_t result, void *a2, unsigned int a3, unsigned char **a4, int a5)
{
  if (a5 >= 1)
  {
    uint64_t v5 = *(void **)(result + 648);
    uint64_t v6 = *(void *)(result + 440);
    uint64_t v7 = v5[2];
    uint64_t v8 = v5[3];
    uint64_t v9 = v5[4];
    uint64_t v10 = v5[5];
    uint64_t v11 = *(unsigned int *)(result + 136);
    do
    {
      if (v11)
      {
        char v12 = *(unsigned __int8 **)(*a2 + 8 * a3);
        char v13 = *(unsigned __int8 **)(a2[1] + 8 * a3);
        char v14 = *(unsigned __int8 **)(a2[2] + 8 * a3);
        char v15 = *(unsigned char **)(a2[3] + 8 * a3);
        uint64_t result = v11;
        uint64_t v16 = *a4;
        do
        {
          int v18 = *v12++;
          int v17 = v18;
          unsigned int v20 = *v13++;
          uint64_t v19 = v20;
          unsigned int v21 = *v14++;
          v17 ^= 0xFFu;
          *uint64_t v16 = *(unsigned char *)(v6 + v17 - *(_DWORD *)(v7 + 4 * v21));
          v16[1] = *(unsigned char *)(v6 + (int)(v17 - ((*(void *)(v9 + 8 * v21) + *(void *)(v10 + 8 * v19)) >> 16)));
          v16[2] = *(unsigned char *)(v6 + v17 - *(_DWORD *)(v8 + 4 * v19));
          LOBYTE(v21) = *v15++;
          v16[3] = v21;
          v16 += 4;
          --result;
        }
        while (result);
      }
      ++a3;
      ++a4;
      BOOL v23 = __OFSUB__(a5, 2);
      BOOL v22 = a5 - 2 < 0;
      --a5;
    }
    while (v22 == v23);
  }
  return result;
}

uint64_t null_convert_0(uint64_t result, uint64_t a2, unsigned int a3, uint64_t *a4, int a5)
{
  if (a5 >= 1)
  {
    int v5 = *(_DWORD *)(result + 136);
    uint64_t v6 = *(unsigned int *)(result + 56);
    int v7 = *(_DWORD *)(result + 56);
    do
    {
      if (v7 >= 1)
      {
        uint64_t v8 = 0;
        do
        {
          if (v5)
          {
            uint64_t v9 = *a4;
            uint64_t v10 = *(char **)(*(void *)(a2 + 8 * v8) + 8 * a3);
            int v11 = v5;
            do
            {
              char v12 = *v10++;
              *(unsigned char *)(v9 + v8) = v12;
              v9 += (int)v6;
              --v11;
            }
            while (v11);
          }
          ++v8;
        }
        while (v8 != v6);
      }
      ++a3;
      ++a4;
    }
    while (a5-- > 1);
  }
  return result;
}

double _cg_jinit_memory_mgr(void *a1)
{
  a1[1] = 0;
  uint64_t v2 = _cg_jpeg_mem_init();
  small = (char *)_cg_jpeg_get_small((int)a1, 0xA8uLL);
  if (!small)
  {
    __n128 v6 = _cg_jpeg_mem_term(a1, v3, v4);
    int v7 = (void (**)(void, __n128))*a1;
    *((_DWORD *)v7 + 10) = 56;
    *((_DWORD *)v7 + 12) = 0;
    (*(void (**)(void *, __n128))*a1)(a1, v6);
  }
  *(void *)small = alloc_small;
  *((void *)small + 1) = alloc_large;
  *((void *)small + 2) = alloc_sarray;
  *((void *)small + 3) = alloc_barray;
  *((void *)small + 4) = request_virt_sarray;
  *((void *)small + 5) = request_virt_barray;
  *((void *)small + 6) = realize_virt_arrays;
  *((void *)small + 7) = access_virt_sarray;
  *((void *)small + 8) = access_virt_barray;
  *((void *)small + 9) = free_pool;
  *((void *)small + 11) = v2;
  *((void *)small + 12) = 1000000000;
  *((void *)small + 10) = self_destruct;
  double result = 0.0;
  *(_OWORD *)(small + 104) = 0u;
  *(_OWORD *)(small + 120) = 0u;
  *(_OWORD *)(small + 136) = 0u;
  *((void *)small + 19) = 168;
  a1[1] = small;
  return result;
}

uint64_t alloc_small(void *a1, signed int a2, unint64_t a3)
{
  uint64_t v6 = a1[1];
  if (a3 > 0x3B9AC9E8)
  {
    int v7 = (void (**)(void *))*a1;
    *((_DWORD *)v7 + 10) = 56;
    *((_DWORD *)v7 + 12) = 1;
    (*(void (**)(void *))*a1)(a1);
  }
  unint64_t v8 = a3 + 7;
  if (a2 >= 2)
  {
    uint64_t v9 = (void (**)(void *))*a1;
    *((_DWORD *)v9 + 10) = 15;
    *((_DWORD *)v9 + 12) = a2;
    (*(void (**)(void *))*a1)(a1);
  }
  unint64_t v10 = v8 & 0xFFFFFFFFFFFFFFF8;
  uint64_t v11 = v6 + 8 * a2;
  char v14 = *(void **)(v11 + 104);
  char v13 = (void *)(v11 + 104);
  char v12 = v14;
  if (v14)
  {
    while (1)
    {
      char v15 = v12;
      if (v12[2] >= v10) {
        break;
      }
      char v12 = (void *)*v12;
      if (!*v15) {
        goto LABEL_10;
      }
    }
  }
  else
  {
    char v15 = 0;
LABEL_10:
    unint64_t v16 = v10 + 24;
    int v17 = &extra_pool_slop;
    if (!v15) {
      int v17 = &first_pool_slop;
    }
    if (v17[a2] >= 999999976 - v10) {
      unint64_t v18 = 999999976 - v10;
    }
    else {
      unint64_t v18 = v17[a2];
    }
    unint64_t v19 = v16 + v18;
    for (uint64_t i = _cg_jpeg_get_small((int)a1, v16 + v18); !i; uint64_t i = _cg_jpeg_get_small((int)a1, v16 + v18))
    {
      if (v18 <= 0x63)
      {
        unsigned int v21 = (void (**)(void *))*a1;
        *((_DWORD *)v21 + 10) = 56;
        *((_DWORD *)v21 + 12) = 2;
        (*(void (**)(void *))*a1)(a1);
      }
      v18 >>= 1;
      unint64_t v19 = v16 + v18;
    }
    *(void *)(v6 + 152) += v19;
    void *i = 0;
    i[1] = 0;
    i[2] = v18 + v10;
    if (v15) {
      BOOL v22 = v15;
    }
    else {
      BOOL v22 = v13;
    }
    *BOOL v22 = i;
    char v15 = i;
  }
  uint64_t v23 = v15[1];
  uint64_t result = (uint64_t)v15 + v23 + 24;
  unint64_t v25 = v15[2] - v10;
  v15[1] = v23 + v10;
  v15[2] = v25;
  return result;
}

void *alloc_large(void *a1, unsigned int a2, unint64_t a3)
{
  uint64_t v6 = a1[1];
  if (a3 >= 0x3B9AC9E9)
  {
    int v7 = (void (**)(void *))*a1;
    *((_DWORD *)v7 + 10) = 56;
    *((_DWORD *)v7 + 12) = 3;
    (*(void (**)(void *))*a1)(a1);
  }
  unint64_t v8 = (a3 + 7) & 0xFFFFFFFFFFFFFFF8;
  if (a2 >= 2)
  {
    uint64_t v9 = (void (**)(void *))*a1;
    *((_DWORD *)v9 + 10) = 15;
    *((_DWORD *)v9 + 12) = a2;
    (*(void (**)(void *))*a1)(a1);
  }
  large = _cg_jpeg_get_large((int)a1, v8 + 24);
  if (!large)
  {
    uint64_t v11 = (void (**)(void *))*a1;
    *((_DWORD *)v11 + 10) = 56;
    *((_DWORD *)v11 + 12) = 4;
    (*(void (**)(void *))*a1)(a1);
  }
  *(void *)(v6 + 152) += v8 + 24;
  uint64_t v12 = v6 + 8 * (int)a2;
  void *large = *(void *)(v12 + 120);
  large[1] = v8;
  large[2] = 0;
  *(void *)(v12 + 120) = large;
  return large + 3;
}

uint64_t alloc_sarray(uint64_t *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v8 = a1[1];
  unsigned int v9 = 0x3B9AC9E8 / a3;
  if (a3 > 0x3B9AC9E8)
  {
    uint64_t v10 = *a1;
    *(_DWORD *)(v10 + 40) = 72;
    (*(void (**)(uint64_t *))v10)(a1);
  }
  if (v9 >= a4) {
    unsigned int v9 = a4;
  }
  *(_DWORD *)(v8 + 160) = v9;
  uint64_t v11 = alloc_small(a1, a2, 8 * a4);
  if (a4)
  {
    uint64_t v12 = 0;
    do
    {
      if (v9 >= a4 - v12) {
        unsigned int v9 = a4 - v12;
      }
      char v13 = alloc_large(a1, a2, a3 * (unint64_t)v9);
      if (v9)
      {
        unsigned int v14 = v9;
        do
        {
          uint64_t v15 = (v12 + 1);
          *(void *)(v11 + 8 * v12) = v13;
          char v13 = (void *)((char *)v13 + a3);
          LODWORD(v12) = v12 + 1;
          --v14;
        }
        while (v14);
      }
      else
      {
        uint64_t v15 = v12;
      }
      uint64_t v12 = v15;
    }
    while (v15 < a4);
  }
  return v11;
}

uint64_t alloc_barray(uint64_t *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v8 = a1[1];
  unint64_t v9 = (unint64_t)a3 << 7;
  unint64_t v10 = 0x3B9AC9E8 / v9;
  if (a3 >= 0x773594)
  {
    uint64_t v11 = *a1;
    *(_DWORD *)(v11 + 40) = 72;
    (*(void (**)(uint64_t *))v11)(a1);
  }
  if (v10 >= a4) {
    LODWORD(v10) = a4;
  }
  *(_DWORD *)(v8 + 160) = v10;
  uint64_t v12 = alloc_small(a1, a2, 8 * a4);
  if (a4)
  {
    uint64_t v13 = 0;
    unint64_t v14 = (unint64_t)a3 << 7;
    do
    {
      if (v10 >= a4 - v13) {
        unint64_t v10 = a4 - v13;
      }
      else {
        unint64_t v10 = v10;
      }
      uint64_t v15 = alloc_large(a1, a2, v9 * v10);
      if (v10)
      {
        int v16 = v10;
        do
        {
          uint64_t v17 = (v13 + 1);
          *(void *)(v12 + 8 * v13) = v15;
          uint64_t v15 = (void *)((char *)v15 + v14);
          LODWORD(v13) = v13 + 1;
          --v16;
        }
        while (v16);
      }
      else
      {
        uint64_t v17 = v13;
      }
      uint64_t v13 = v17;
    }
    while (v17 < a4);
  }
  return v12;
}

uint64_t request_virt_sarray(void *a1, signed int a2, int a3, int a4, int a5, int a6)
{
  uint64_t v12 = a1[1];
  if (a2 != 1)
  {
    uint64_t v13 = (void (**)(void))*a1;
    *((_DWORD *)v13 + 10) = 15;
    *((_DWORD *)v13 + 12) = a2;
    (*(void (**)(void *))*a1)(a1);
  }
  uint64_t result = alloc_small(a1, a2, 0x98uLL);
  *(void *)uint64_t result = 0;
  *(_DWORD *)(result + 8) = a5;
  *(_DWORD *)(result + 12) = a4;
  *(_DWORD *)(result + 16) = a6;
  *(_DWORD *)(result + 36) = a3;
  *(_DWORD *)(result + 44) = 0;
  *(void *)(result + 48) = *(void *)(v12 + 136);
  *(void *)(v12 + 136) = result;
  return result;
}

uint64_t request_virt_barray(void *a1, signed int a2, int a3, int a4, int a5, int a6)
{
  uint64_t v12 = a1[1];
  if (a2 != 1)
  {
    uint64_t v13 = (void (**)(void))*a1;
    *((_DWORD *)v13 + 10) = 15;
    *((_DWORD *)v13 + 12) = a2;
    (*(void (**)(void *))*a1)(a1);
  }
  uint64_t result = alloc_small(a1, a2, 0x98uLL);
  *(void *)uint64_t result = 0;
  *(_DWORD *)(result + 8) = a5;
  *(_DWORD *)(result + 12) = a4;
  *(_DWORD *)(result + 16) = a6;
  *(_DWORD *)(result + 36) = a3;
  *(_DWORD *)(result + 44) = 0;
  *(void *)(result + 48) = *(void *)(v12 + 144);
  *(void *)(v12 + 144) = result;
  return result;
}

uint64_t realize_virt_arrays(uint64_t result)
{
  uint64_t v1 = (uint64_t *)result;
  uint64_t v2 = *(void *)(result + 8);
  uint64_t v3 = *(void *)(v2 + 136);
  if (v3)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    do
    {
      if (!*(void *)v3)
      {
        unsigned int v6 = *(_DWORD *)(v3 + 12);
        v5 += *(unsigned int *)(v3 + 16) * (unint64_t)v6;
        v4 += *(unsigned int *)(v3 + 8) * (unint64_t)v6;
      }
      uint64_t v3 = *(void *)(v3 + 48);
    }
    while (v3);
  }
  else
  {
    uint64_t v5 = 0;
    uint64_t v4 = 0;
  }
  for (uint64_t i = *(void *)(v2 + 144); i; uint64_t i = *(void *)(i + 48))
  {
    if (!*(void *)i)
    {
      unint64_t v8 = (unint64_t)*(unsigned int *)(i + 12) << 7;
      v5 += v8 * *(unsigned int *)(i + 16);
      v4 += v8 * *(unsigned int *)(i + 8);
    }
  }
  if (v5 >= 1)
  {
    uint64_t result = _cg_jpeg_mem_available(result, v5, v4, *(void *)(v2 + 152));
    if (result >= v4)
    {
      uint64_t v9 = 1000000000;
    }
    else if (result / v5 <= 1)
    {
      uint64_t v9 = 1;
    }
    else
    {
      uint64_t v9 = result / v5;
    }
    for (uint64_t j = *(void *)(v2 + 136); j; uint64_t j = *(void *)(j + 48))
    {
      if (!*(void *)j)
      {
        uint64_t v11 = *(unsigned int *)(j + 8);
        uint64_t v12 = *(unsigned int *)(j + 16);
        if ((v11 - 1) / v12 >= v9)
        {
          *(_DWORD *)(j + 20) = v12 * v9;
          _cg_jpeg_open_backing_store(v1, (size_t (**)(uint64_t *, uint64_t, void *, uint64_t, size_t))(j + 56));
          *(_DWORD *)(j + 44) = 1;
          LODWORD(v11) = *(_DWORD *)(j + 20);
        }
        else
        {
          *(_DWORD *)(j + 20) = v11;
        }
        uint64_t result = alloc_sarray(v1, 1u, *(_DWORD *)(j + 12), v11);
        *(void *)uint64_t j = result;
        *(void *)(j + 24) = *(unsigned int *)(v2 + 160);
        *(_DWORD *)(j + 32) = 0;
        *(_DWORD *)(j + 40) = 0;
      }
    }
    for (uint64_t k = *(void *)(v2 + 144); k; uint64_t k = *(void *)(k + 48))
    {
      if (!*(void *)k)
      {
        uint64_t v14 = *(unsigned int *)(k + 8);
        uint64_t v15 = *(unsigned int *)(k + 16);
        if ((v14 - 1) / v15 >= v9)
        {
          *(_DWORD *)(k + 20) = v15 * v9;
          _cg_jpeg_open_backing_store(v1, (size_t (**)(uint64_t *, uint64_t, void *, uint64_t, size_t))(k + 56));
          *(_DWORD *)(k + 44) = 1;
          LODWORD(v14) = *(_DWORD *)(k + 20);
        }
        else
        {
          *(_DWORD *)(k + 20) = v14;
        }
        uint64_t result = alloc_barray(v1, 1u, *(_DWORD *)(k + 12), v14);
        *(void *)uint64_t k = result;
        *(void *)(k + 24) = *(unsigned int *)(v2 + 160);
        *(_DWORD *)(k + 32) = 0;
        *(_DWORD *)(k + 40) = 0;
      }
    }
  }
  return result;
}

uint64_t access_virt_sarray(uint64_t *a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5)
{
  uint64_t v10 = a4 + a3;
  if (v10 > *(_DWORD *)(a2 + 8) || *(_DWORD *)(a2 + 16) < a4 || !*(void *)a2)
  {
    uint64_t v11 = *a1;
    *(_DWORD *)(v11 + 40) = 23;
    (*(void (**)(uint64_t *))v11)(a1);
  }
  unsigned int v12 = *(_DWORD *)(a2 + 28);
  if (v12 > a3 || v10 > *(_DWORD *)(a2 + 20) + v12)
  {
    if (!*(_DWORD *)(a2 + 44))
    {
      uint64_t v13 = *a1;
      *(_DWORD *)(v13 + 40) = 71;
      (*(void (**)(uint64_t *))v13)(a1);
    }
    if (*(_DWORD *)(a2 + 40))
    {
      do_sarray_io((uint64_t)a1, a2, 1);
      *(_DWORD *)(a2 + 40) = 0;
    }
    unsigned int v14 = a3;
    if (*(_DWORD *)(a2 + 28) >= a3) {
      unsigned int v14 = (v10 - *(_DWORD *)(a2 + 20)) & ~((v10 - *(unsigned int *)(a2 + 20)) >> 63);
    }
    *(_DWORD *)(a2 + 28) = v14;
    do_sarray_io((uint64_t)a1, a2, 0);
  }
  unsigned int v15 = *(_DWORD *)(a2 + 32);
  if (v15 < v10)
  {
    if (v15 >= a3)
    {
      if (a5)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v10;
        if (!*(_DWORD *)(a2 + 36)) {
          goto LABEL_26;
        }
        goto LABEL_22;
      }
      if (*(_DWORD *)(a2 + 36))
      {
LABEL_22:
        int v17 = *(_DWORD *)(a2 + 28);
        if (v15 - v17 < (int)v10 - v17)
        {
          size_t v18 = *(unsigned int *)(a2 + 12);
          uint64_t v19 = 8 * (v15 - v17);
          unsigned int v20 = a4 + a3 - v15;
          do
          {
            bzero(*(void **)(*(void *)a2 + v19), v18);
            v19 += 8;
            --v20;
          }
          while (v20);
        }
        goto LABEL_25;
      }
    }
    else
    {
      if (a5)
      {
        uint64_t v16 = *a1;
        *(_DWORD *)(v16 + 40) = 23;
        (*(void (**)(uint64_t *))v16)(a1);
        unsigned int v15 = a3;
        goto LABEL_19;
      }
      unsigned int v15 = a3;
      if (*(_DWORD *)(a2 + 36)) {
        goto LABEL_22;
      }
    }
    uint64_t v22 = *a1;
    *(_DWORD *)(v22 + 40) = 23;
    (*(void (**)(uint64_t *))v22)(a1);
    return *(void *)a2 + 8 * (a3 - *(_DWORD *)(a2 + 28));
  }
LABEL_25:
  if (a5) {
LABEL_26:
  }
    *(_DWORD *)(a2 + 40) = 1;
  return *(void *)a2 + 8 * (a3 - *(_DWORD *)(a2 + 28));
}

uint64_t access_virt_barray(uint64_t *a1, uint64_t a2, unsigned int a3, unsigned int a4, int a5)
{
  uint64_t v10 = a4 + a3;
  if (v10 > *(_DWORD *)(a2 + 8) || *(_DWORD *)(a2 + 16) < a4 || !*(void *)a2)
  {
    uint64_t v11 = *a1;
    *(_DWORD *)(v11 + 40) = 23;
    (*(void (**)(uint64_t *))v11)(a1);
  }
  unsigned int v12 = *(_DWORD *)(a2 + 28);
  if (v12 > a3 || v10 > *(_DWORD *)(a2 + 20) + v12)
  {
    if (!*(_DWORD *)(a2 + 44))
    {
      uint64_t v13 = *a1;
      *(_DWORD *)(v13 + 40) = 71;
      (*(void (**)(uint64_t *))v13)(a1);
    }
    if (*(_DWORD *)(a2 + 40))
    {
      do_barray_io((uint64_t)a1, a2, 1);
      *(_DWORD *)(a2 + 40) = 0;
    }
    unsigned int v14 = a3;
    if (*(_DWORD *)(a2 + 28) >= a3) {
      unsigned int v14 = (v10 - *(_DWORD *)(a2 + 20)) & ~((v10 - *(unsigned int *)(a2 + 20)) >> 63);
    }
    *(_DWORD *)(a2 + 28) = v14;
    do_barray_io((uint64_t)a1, a2, 0);
  }
  unsigned int v15 = *(_DWORD *)(a2 + 32);
  if (v15 < v10)
  {
    if (v15 >= a3)
    {
      if (a5)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v10;
        if (!*(_DWORD *)(a2 + 36)) {
          goto LABEL_26;
        }
        goto LABEL_22;
      }
      if (*(_DWORD *)(a2 + 36))
      {
LABEL_22:
        int v17 = *(_DWORD *)(a2 + 28);
        if (v15 - v17 < (int)v10 - v17)
        {
          size_t v18 = (unint64_t)*(unsigned int *)(a2 + 12) << 7;
          uint64_t v19 = 8 * (v15 - v17);
          unsigned int v20 = a4 + a3 - v15;
          do
          {
            bzero(*(void **)(*(void *)a2 + v19), v18);
            v19 += 8;
            --v20;
          }
          while (v20);
        }
        goto LABEL_25;
      }
    }
    else
    {
      if (a5)
      {
        uint64_t v16 = *a1;
        *(_DWORD *)(v16 + 40) = 23;
        (*(void (**)(uint64_t *))v16)(a1);
        unsigned int v15 = a3;
        goto LABEL_19;
      }
      unsigned int v15 = a3;
      if (*(_DWORD *)(a2 + 36)) {
        goto LABEL_22;
      }
    }
    uint64_t v22 = *a1;
    *(_DWORD *)(v22 + 40) = 23;
    (*(void (**)(uint64_t *))v22)(a1);
    return *(void *)a2 + 8 * (a3 - *(_DWORD *)(a2 + 28));
  }
LABEL_25:
  if (a5) {
LABEL_26:
  }
    *(_DWORD *)(a2 + 40) = 1;
  return *(void *)a2 + 8 * (a3 - *(_DWORD *)(a2 + 28));
}

void free_pool(void *a1, signed int a2)
{
  uint64_t v4 = (void *)a1[1];
  if (a2 < 2)
  {
    if (a2 == 1)
    {
      for (uint64_t i = v4[17]; i; uint64_t i = *(void *)(i + 48))
      {
        if (*(_DWORD *)(i + 44))
        {
          *(_DWORD *)(i + 44) = 0;
          (*(void (**)(void *, uint64_t))(i + 72))(a1, i + 56);
        }
      }
      v4[17] = 0;
      for (uint64_t j = v4[18]; j; uint64_t j = *(void *)(j + 48))
      {
        if (*(_DWORD *)(j + 44))
        {
          *(_DWORD *)(j + 44) = 0;
          (*(void (**)(void *, uint64_t))(j + 72))(a1, j + 56);
        }
      }
      v4[18] = 0;
    }
  }
  else
  {
    uint64_t v5 = (void (**)(void))*a1;
    *((_DWORD *)v5 + 10) = 15;
    *((_DWORD *)v5 + 12) = a2;
    (*(void (**)(void *))*a1)(a1);
  }
  uint64_t v8 = a2;
  uint64_t v9 = &v4[a2];
  uint64_t v10 = (void *)v9[15];
  v9[15] = 0;
  if (v10)
  {
    do
    {
      uint64_t v11 = (void *)*v10;
      uint64_t v12 = v10[1] + v10[2] + 24;
      _cg_jpeg_free_small((int)a1, v10);
      v4[19] -= v12;
      uint64_t v10 = v11;
    }
    while (v11);
  }
  uint64_t v13 = &v4[v8];
  unsigned int v14 = (void *)v13[13];
  v13[13] = 0;
  if (v14)
  {
    do
    {
      unsigned int v15 = (void *)*v14;
      uint64_t v16 = v14[1] + v14[2] + 24;
      _cg_jpeg_free_small((int)a1, v14);
      v4[19] -= v16;
      unsigned int v14 = v15;
    }
    while (v15);
  }
}

__n128 self_destruct(uint64_t a1)
{
  for (signed int i = 1; i != -1; --i)
    free_pool((void *)a1, i);
  _cg_jpeg_free_small(a1, *(void **)(a1 + 8));
  *(void *)(a1 + 8) = 0;

  return _cg_jpeg_mem_term(a1, v3, v4);
}

uint64_t do_sarray_io(uint64_t result, uint64_t a2, int a3)
{
  unint64_t v3 = *(unsigned int *)(a2 + 20);
  if (v3)
  {
    uint64_t v5 = result;
    unint64_t v6 = 0;
    uint64_t v7 = *(unsigned int *)(a2 + 12);
    uint64_t v8 = *(unsigned int *)(a2 + 24);
    unint64_t v9 = *(unsigned int *)(a2 + 28) * (unint64_t)v7;
    uint64_t v10 = a2 + 56;
    if (a3) {
      uint64_t v11 = 64;
    }
    else {
      uint64_t v11 = 56;
    }
    do
    {
      uint64_t v12 = v3 - v6;
      if (v12 >= v8) {
        uint64_t v12 = v8;
      }
      unint64_t v13 = v6 + *(unsigned int *)(a2 + 28);
      if (v12 >= (uint64_t)(*(unsigned int *)(a2 + 32) - v13)) {
        uint64_t v12 = *(unsigned int *)(a2 + 32) - v13;
      }
      uint64_t v14 = *(unsigned int *)(a2 + 8) - v13;
      if (v12 >= v14) {
        uint64_t v12 = v14;
      }
      if (v12 < 1) {
        break;
      }
      uint64_t v15 = v12 * v7;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, unint64_t, uint64_t))(a2 + v11))(v5, v10, *(void *)(*(void *)a2 + 8 * v6), v9, v12 * v7);
      v9 += v15;
      unint64_t v3 = *(unsigned int *)(a2 + 20);
      uint64_t v8 = *(unsigned int *)(a2 + 24);
      v6 += v8;
    }
    while (v6 < v3);
  }
  return result;
}

uint64_t do_barray_io(uint64_t result, uint64_t a2, int a3)
{
  unint64_t v3 = *(unsigned int *)(a2 + 20);
  if (v3)
  {
    uint64_t v5 = result;
    unint64_t v6 = 0;
    unint64_t v7 = (unint64_t)*(unsigned int *)(a2 + 12) << 7;
    uint64_t v8 = *(unsigned int *)(a2 + 24);
    unint64_t v9 = v7 * *(unsigned int *)(a2 + 28);
    uint64_t v10 = a2 + 56;
    if (a3) {
      uint64_t v11 = 64;
    }
    else {
      uint64_t v11 = 56;
    }
    do
    {
      uint64_t v12 = v3 - v6;
      if (v12 >= v8) {
        uint64_t v12 = v8;
      }
      unint64_t v13 = v6 + *(unsigned int *)(a2 + 28);
      if (v12 >= (uint64_t)(*(unsigned int *)(a2 + 32) - v13)) {
        uint64_t v12 = *(unsigned int *)(a2 + 32) - v13;
      }
      uint64_t v14 = *(unsigned int *)(a2 + 8) - v13;
      if (v12 >= v14) {
        uint64_t v12 = v14;
      }
      if (v12 < 1) {
        break;
      }
      unint64_t v15 = v12 * v7;
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, unint64_t, unint64_t))(a2 + v11))(v5, v10, *(void *)(*(void *)a2 + 8 * v6), v9, v12 * v7);
      v9 += v15;
      unint64_t v3 = *(unsigned int *)(a2 + 20);
      uint64_t v8 = *(unsigned int *)(a2 + 24);
      v6 += v8;
    }
    while (v6 < v3);
  }
  return result;
}

uint64_t (**_cg_jinit_forward_dct(uint64_t a1))(uint64_t result)
{
  uint64_t result = (uint64_t (**)(uint64_t))(**(uint64_t (***)(void))(a1 + 8))();
  *(void *)(a1 + 552) = result;
  *uint64_t result = start_pass_fdctmgr;
  if (*(int *)(a1 + 92) >= 1)
  {
    int v3 = 0;
    uint64_t v4 = (uint64_t (***)(uint64_t))(*(void *)(a1 + 104) + 88);
    do
    {
      uint64_t result = (uint64_t (**)(uint64_t))(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 256);
      const char *v4 = result;
      v4 += 12;
      ++v3;
    }
    while (v3 < *(_DWORD *)(a1 + 92));
  }
  return result;
}

uint64_t start_pass_fdctmgr(uint64_t result)
{
  if (*(int *)(result + 92) >= 1)
  {
    uint64_t v1 = (int *)result;
    uint64_t v2 = 0;
    int v3 = 0;
    uint64_t v47 = *(void *)(result + 552);
    uint64_t v4 = *(void *)(result + 104);
    float64x2_t v6 = (float64x2_t)xmmword_18898DEA0;
    float64x2_t v5 = (float64x2_t)unk_18898DEB0;
    float64x2_t v8 = (float64x2_t)start_pass_fdctmgr_aanscalefactor;
    float64x2_t v7 = (float64x2_t)unk_18898DE90;
    __asm { FMOV            V18.2D, #1.0 }
    float64x2_t v46 = _Q18;
    while (1)
    {
      int v14 = *(_DWORD *)(v4 + 36);
      int v15 = *(_DWORD *)(v4 + 40) + (v14 << 8);
      if (v15 <= 1805)
      {
        if (v15 > 1027)
        {
          if (v15 > 1538)
          {
            if (v15 > 1547)
            {
              if (v15 == 1548)
              {
                int v3 = 0;
                uint64_t v16 = v47 + 8 * v2;
                int v17 = jpeg_fdct_6x12;
                goto LABEL_85;
              }
              if (v15 == 1799)
              {
                int v3 = 0;
                uint64_t v16 = v47 + 8 * v2;
                int v17 = jpeg_fdct_7x7;
                goto LABEL_85;
              }
            }
            else
            {
              if (v15 == 1539)
              {
                int v3 = 0;
                uint64_t v16 = v47 + 8 * v2;
                int v17 = jpeg_fdct_6x3;
                goto LABEL_85;
              }
              if (v15 == 1542)
              {
                int v3 = 0;
                uint64_t v16 = v47 + 8 * v2;
                int v17 = jpeg_fdct_6x6;
                goto LABEL_85;
              }
            }
          }
          else if (v15 > 1284)
          {
            if (v15 == 1285)
            {
              int v3 = 0;
              uint64_t v16 = v47 + 8 * v2;
              int v17 = jpeg_fdct_5x5;
              goto LABEL_85;
            }
            if (v15 == 1290)
            {
              int v3 = 0;
              uint64_t v16 = v47 + 8 * v2;
              int v17 = jpeg_fdct_5x10;
              goto LABEL_85;
            }
          }
          else
          {
            if (v15 == 1028)
            {
              int v3 = 0;
              uint64_t v16 = v47 + 8 * v2;
              int v17 = jpeg_fdct_4x4;
              goto LABEL_85;
            }
            if (v15 == 1032)
            {
              int v3 = 0;
              uint64_t v16 = v47 + 8 * v2;
              int v17 = jpeg_fdct_4x8;
              goto LABEL_85;
            }
          }
        }
        else if (v15 > 515)
        {
          if (v15 > 773)
          {
            if (v15 == 774)
            {
              int v3 = 0;
              uint64_t v16 = v47 + 8 * v2;
              int v17 = jpeg_fdct_3x6;
              goto LABEL_85;
            }
            if (v15 == 1026)
            {
              int v3 = 0;
              uint64_t v16 = v47 + 8 * v2;
              int v17 = jpeg_fdct_4x2;
              goto LABEL_85;
            }
          }
          else
          {
            if (v15 == 516)
            {
              int v3 = 0;
              uint64_t v16 = v47 + 8 * v2;
              int v17 = jpeg_fdct_2x4;
              goto LABEL_85;
            }
            if (v15 == 771)
            {
              int v3 = 0;
              uint64_t v16 = v47 + 8 * v2;
              int v17 = jpeg_fdct_3x3;
              goto LABEL_85;
            }
          }
        }
        else if (v15 > 512)
        {
          if (v15 == 513)
          {
            int v3 = 0;
            uint64_t v16 = v47 + 8 * v2;
            int v17 = jpeg_fdct_2x1;
            goto LABEL_85;
          }
          if (v15 == 514)
          {
            int v3 = 0;
            uint64_t v16 = v47 + 8 * v2;
            int v17 = jpeg_fdct_2x2;
            goto LABEL_85;
          }
        }
        else
        {
          if (v15 == 257)
          {
            int v3 = 0;
            uint64_t v16 = v47 + 8 * v2;
            int v17 = jpeg_fdct_1x1;
            goto LABEL_85;
          }
          if (v15 == 258)
          {
            int v3 = 0;
            uint64_t v16 = v47 + 8 * v2;
            int v17 = jpeg_fdct_1x2;
LABEL_85:
            *(void *)(v16 + 88) = v17;
            goto LABEL_86;
          }
        }
        goto LABEL_110;
      }
      if (v15 > 3077)
      {
        if (v15 > 3597)
        {
          if (v15 > 4103)
          {
            if (v15 == 4104)
            {
              int v3 = 0;
              uint64_t v16 = v47 + 8 * v2;
              int v17 = jpeg_fdct_16x8;
              goto LABEL_85;
            }
            if (v15 == 4112)
            {
              int v3 = 0;
              uint64_t v16 = v47 + 8 * v2;
              int v17 = jpeg_fdct_16x16;
              goto LABEL_85;
            }
          }
          else
          {
            if (v15 == 3598)
            {
              int v3 = 0;
              uint64_t v16 = v47 + 8 * v2;
              int v17 = jpeg_fdct_14x14;
              goto LABEL_85;
            }
            if (v15 == 3855)
            {
              int v3 = 0;
              uint64_t v16 = v47 + 8 * v2;
              int v17 = jpeg_fdct_15x15;
              goto LABEL_85;
            }
          }
        }
        else if (v15 > 3340)
        {
          if (v15 == 3341)
          {
            int v3 = 0;
            uint64_t v16 = v47 + 8 * v2;
            int v17 = jpeg_fdct_13x13;
            goto LABEL_85;
          }
          if (v15 == 3591)
          {
            int v3 = 0;
            uint64_t v16 = v47 + 8 * v2;
            int v17 = jpeg_fdct_14x7;
            goto LABEL_85;
          }
        }
        else
        {
          if (v15 == 3078)
          {
            int v3 = 0;
            uint64_t v16 = v47 + 8 * v2;
            int v17 = jpeg_fdct_12x6;
            goto LABEL_85;
          }
          if (v15 == 3084)
          {
            int v3 = 0;
            uint64_t v16 = v47 + 8 * v2;
            int v17 = jpeg_fdct_12x12;
            goto LABEL_85;
          }
        }
        goto LABEL_110;
      }
      if (v15 > 2312) {
        break;
      }
      if (v15 <= 2055)
      {
        if (v15 == 1806)
        {
          int v3 = 0;
          uint64_t v16 = v47 + 8 * v2;
          int v17 = jpeg_fdct_7x14;
          goto LABEL_85;
        }
        if (v15 == 2052)
        {
          int v3 = 0;
          uint64_t v16 = v47 + 8 * v2;
          int v17 = jpeg_fdct_8x4;
          goto LABEL_85;
        }
        goto LABEL_110;
      }
      if (v15 != 2056)
      {
        if (v15 == 2064)
        {
          int v3 = 0;
          uint64_t v16 = v47 + 8 * v2;
          int v17 = jpeg_fdct_8x16;
          goto LABEL_85;
        }
LABEL_110:
        uint64_t v44 = *(void *)v1;
        *(_DWORD *)(v44 + 40) = 7;
        *(_DWORD *)(v44 + 48) = v14;
        *(_DWORD *)(*(void *)v1 + 52) = *(_DWORD *)(v4 + 40);
        int v45 = *(uint64_t (***)(int *))v1;
        goto LABEL_114;
      }
      int v18 = v1[78];
      switch(v18)
      {
        case 2:
          *(void *)(v47 + 8 * v2 + 168) = _cg_jpeg_fdct_float;
          int v3 = 2;
          goto LABEL_86;
        case 1:
          *(void *)(v47 + 8 * v2 + 88) = _cg_jpeg_fdct_ifast;
          int v3 = 1;
          goto LABEL_86;
        case 0:
          int v3 = 0;
          uint64_t v16 = v47 + 8 * v2;
          int v17 = _cg_jpeg_fdct_islow;
          goto LABEL_85;
      }
      int v45 = *(uint64_t (***)(int *))v1;
      *(_DWORD *)(*(void *)v1 + 40) = 49;
LABEL_114:
      uint64_t result = (*v45)(v1);
      _Q18 = v46;
      float64x2_t v8 = (float64x2_t)start_pass_fdctmgr_aanscalefactor;
      float64x2_t v7 = (float64x2_t)unk_18898DE90;
      float64x2_t v6 = (float64x2_t)xmmword_18898DEA0;
      float64x2_t v5 = (float64x2_t)unk_18898DEB0;
LABEL_86:
      uint64_t v19 = *(unsigned int *)(v4 + 16);
      if (v19 > 3 || !*(void *)&v1[2 * v19 + 28])
      {
        unsigned int v20 = *(uint64_t (***)(int *))v1;
        *((_DWORD *)v20 + 10) = 54;
        *((_DWORD *)v20 + 12) = v19;
        uint64_t result = (**(uint64_t (***)(int *))v1)(v1);
        _Q18 = v46;
        float64x2_t v8 = (float64x2_t)start_pass_fdctmgr_aanscalefactor;
        float64x2_t v7 = (float64x2_t)unk_18898DE90;
        float64x2_t v6 = (float64x2_t)xmmword_18898DEA0;
        float64x2_t v5 = (float64x2_t)unk_18898DEB0;
      }
      uint64_t v21 = *(void *)&v1[2 * (int)v19 + 28];
      if (v3 == 2)
      {
        uint64_t v25 = 0;
        uint64_t v26 = 0;
        uint64_t v27 = *(void *)(v4 + 88);
        if (*(_DWORD *)(v4 + 52)) {
          double v28 = 16.0;
        }
        else {
          double v28 = 8.0;
        }
        do
        {
          uint64_t v29 = v26 << 32;
          double v30 = *(double *)((char *)&start_pass_fdctmgr_aanscalefactor + v25);
          uint16x8_t v31 = *(uint16x8_t *)(v21 + 2 * (int)v26);
          uint32x4_t v32 = vmovl_high_u16(v31);
          v33.i64[0] = v32.u32[2];
          v33.i64[1] = v32.u32[3];
          float64x2_t v34 = vcvtq_f64_u64(v33);
          v33.i64[0] = v32.u32[0];
          v33.i64[1] = v32.u32[1];
          uint64x2_t v35 = v33;
          uint32x4_t v36 = vmovl_u16(*(uint16x4_t *)v31.i8);
          v33.i64[0] = v36.u32[2];
          v33.i64[1] = v36.u32[3];
          float64x2_t v37 = vcvtq_f64_u64(v33);
          v33.i64[0] = v36.u32[0];
          v33.i64[1] = v36.u32[1];
          uint64_t v26 = (int)v26 + 8;
          int v38 = (float32x4_t *)(v27 + (v29 >> 30));
          *int v38 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(_Q18, vmulq_n_f64(vmulq_f64(vmulq_n_f64(vcvtq_f64_u64(v33), v30), v8), v28))), vdivq_f64(_Q18, vmulq_n_f64(vmulq_f64(vmulq_n_f64(v37, v30), v7), v28)));
          v38[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vdivq_f64(_Q18, vmulq_n_f64(vmulq_f64(vmulq_n_f64(vcvtq_f64_u64(v35), v30), v6), v28))), vdivq_f64(_Q18, vmulq_n_f64(vmulq_f64(vmulq_n_f64(v34, v30), v5), v28)));
          v25 += 8;
        }
        while (v25 != 64);
        uint64_t v39 = v47 + 8 * v2;
        uint64_t v40 = forward_DCT_float;
      }
      else
      {
        if (v3 == 1)
        {
          uint64_t v41 = 0;
          uint64_t v42 = *(void *)(v4 + 88);
          do
          {
            if (*(_DWORD *)(v4 + 52)) {
              char v43 = 10;
            }
            else {
              char v43 = 11;
            }
            *(_DWORD *)(v42 + 4 * v41) = (uint64_t)((1 << (v43 - 1))
                                                 + start_pass_fdctmgr_aanscales[v41]
                                                 * (unint64_t)*(unsigned __int16 *)(v21 + 2 * v41)) >> v43;
            ++v41;
          }
          while (v41 != 64);
        }
        else
        {
          uint64_t v22 = 0;
          uint64_t v23 = *(void *)(v4 + 88);
          do
          {
            if (*(_DWORD *)(v4 + 52)) {
              char v24 = 4;
            }
            else {
              char v24 = 3;
            }
            *(_DWORD *)(v23 + 4 * v22) = *(unsigned __int16 *)(v21 + 2 * v22) << v24;
            ++v22;
          }
          while (v22 != 64);
        }
        uint64_t v39 = v47 + 8 * v2;
        uint64_t v40 = forward_DCT;
      }
      *(void *)(v39 + 8) = v40;
      ++v2;
      v4 += 96;
      if (v2 >= v1[23]) {
        return result;
      }
    }
    if (v15 > 2569)
    {
      if (v15 == 2570)
      {
        int v3 = 0;
        uint64_t v16 = v47 + 8 * v2;
        int v17 = jpeg_fdct_10x10;
        goto LABEL_85;
      }
      if (v15 == 2827)
      {
        int v3 = 0;
        uint64_t v16 = v47 + 8 * v2;
        int v17 = jpeg_fdct_11x11;
        goto LABEL_85;
      }
    }
    else
    {
      if (v15 == 2313)
      {
        int v3 = 0;
        uint64_t v16 = v47 + 8 * v2;
        int v17 = jpeg_fdct_9x9;
        goto LABEL_85;
      }
      if (v15 == 2565)
      {
        int v3 = 0;
        uint64_t v16 = v47 + 8 * v2;
        int v17 = jpeg_fdct_10x5;
        goto LABEL_85;
      }
    }
    goto LABEL_110;
  }
  return result;
}

uint64_t forward_DCT(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, unsigned int a7)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a7)
  {
    uint64_t v10 = 0;
    uint64_t v11 = *(uint64_t (**)(_OWORD *, uint64_t, uint64_t))(*(void *)(result + 552) + 8 * *(int *)(a2 + 4) + 88);
    uint64_t v12 = *(void *)(a2 + 88);
    uint64_t v13 = a3 + 8 * a5;
    uint64_t v14 = a7;
    memset(v23, 0, sizeof(v23));
    do
    {
      uint64_t result = v11(v23, v13, a6);
      for (uint64_t i = 0; i != 64; ++i)
      {
        int v16 = *(_DWORD *)(v12 + 4 * i);
        int v17 = *((_DWORD *)v23 + i);
        int v18 = v16 >> 1;
        if (v17 < 0)
        {
          int v21 = v18 - v17;
          if (v21 >= v16) {
            int v22 = v21 / v16;
          }
          else {
            int v22 = 0;
          }
          int v20 = -v22;
        }
        else
        {
          int v19 = v17 + v18;
          if (v19 >= v16) {
            int v20 = v19 / v16;
          }
          else {
            LOWORD(v20) = 0;
          }
        }
        *(_WORD *)(a4 + 2 * i) = v20;
      }
      ++v10;
      a6 = (*(_DWORD *)(a2 + 36) + a6);
      a4 += 128;
    }
    while (v10 != v14);
  }
  return result;
}

uint64_t forward_DCT_float(uint64_t result, uint64_t a2, uint64_t a3, int16x8_t *a4, unsigned int a5, uint64_t a6, unsigned int a7)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a7)
  {
    uint64_t v10 = 0;
    uint64_t v11 = *(uint64_t (**)(_OWORD *, uint64_t, uint64_t))(*(void *)(result + 552) + 8 * *(int *)(a2 + 4) + 168);
    uint64_t v12 = a3 + 8 * a5;
    memset(v19, 0, sizeof(v19));
    uint64_t v13 = a7;
    uint64_t v14 = *(void *)(a2 + 88);
    float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x46800100u);
    do
    {
      uint64_t result = v11(v19, v12, a6);
      v15.i64[0] = 0xC000C000C000C000;
      v15.i64[1] = 0xC000C000C000C000;
      uint64_t v16 = 0;
      int v17 = a4;
      do
      {
        *v17++ = vaddq_s16(vuzp1q_s16((int16x8_t)vcvtq_s32_f32(vaddq_f32(vmulq_f32((float32x4_t)v19[v16], *(float32x4_t *)(v14 + v16 * 16)), v18)), (int16x8_t)vcvtq_s32_f32(vaddq_f32(vmulq_f32((float32x4_t)v19[v16 + 1], *(float32x4_t *)(v14 + v16 * 16 + 16)), v18))), v15);
        v16 += 2;
      }
      while (v16 != 16);
      ++v10;
      a6 = (*(_DWORD *)(a2 + 36) + a6);
      a4 += 8;
    }
    while (v10 != v13);
  }
  return result;
}

uint64_t _cg_jinit_1pass_quantizer(uint64_t a1)
{
  uint64_t v2 = (void (**)(uint64_t))(**(uint64_t (***)(void))(a1 + 8))();
  *(void *)(a1 + 656) = v2;
  void *v2 = start_pass_1_quant;
  v2[2] = (void (*)(uint64_t))finish_pass_1_quant;
  v2[3] = (void (*)(uint64_t))new_color_map_1_quant;
  v2[14] = 0;
  v2[10] = 0;
  if (*(int *)(a1 + 144) >= 5)
  {
    int v3 = *(void (***)(void))a1;
    *((_DWORD *)v3 + 10) = 57;
    *((_DWORD *)v3 + 12) = 4;
    (**(void (***)(uint64_t))a1)(a1);
  }
  int v4 = *(_DWORD *)(a1 + 120);
  if (v4 >= 257)
  {
    float64x2_t v5 = *(void (***)(void))a1;
    *((_DWORD *)v5 + 10) = 59;
    *((_DWORD *)v5 + 12) = 256;
    (**(void (***)(uint64_t))a1)(a1);
    int v4 = *(_DWORD *)(a1 + 120);
  }
  uint64_t v6 = *(void *)(a1 + 656);
  uint64_t v7 = *(unsigned int *)(a1 + 144);
  uint64_t v8 = v4;
  uint64_t v9 = 1;
  do
  {
    unsigned int v10 = v9++;
    uint64_t v11 = v9;
    if ((int)v7 >= 2)
    {
      int v12 = v7 - 1;
      uint64_t v11 = v9;
      do
      {
        v11 *= v9;
        --v12;
      }
      while (v12);
    }
  }
  while (v11 <= v4);
  if (v10 <= 1)
  {
    uint64_t v13 = *(void (***)(void))a1;
    *((_DWORD *)v13 + 10) = 58;
    *((_DWORD *)v13 + 12) = v11;
    (**(void (***)(uint64_t))a1)(a1);
  }
  if ((int)v7 < 1)
  {
    uint64_t v25 = 1;
  }
  else
  {
    uint64_t v14 = v6 + 60;
    uint64_t v15 = (v7 + 1) & 0x1FFFFFFFELL;
    uint64x2_t v16 = (uint64x2_t)vdupq_n_s64(v7 - 1);
    int32x2_t v17 = vdup_n_s32(v10);
    int64x2_t v18 = (int64x2_t)xmmword_18898C840;
    int v19 = (unsigned int *)(v6 + 64);
    int8x8_t v20 = (int8x8_t)0x100000001;
    int64x2_t v21 = vdupq_n_s64(2uLL);
    do
    {
      int8x8_t v22 = v20;
      int8x8_t v23 = (int8x8_t)vmovn_s64((int64x2_t)vcgeq_u64(v16, (uint64x2_t)v18));
      if (v23.i8[0]) {
        *(v19 - 1) = v10;
      }
      if (v23.i8[4]) {
        *int v19 = v10;
      }
      int8x8_t v20 = (int8x8_t)vmul_s32((int32x2_t)v20, v17);
      int64x2_t v18 = vaddq_s64(v18, v21);
      v19 += 2;
      v15 -= 2;
    }
    while (v15);
    int8x8_t v24 = vbsl_s8(v23, v20, v22);
    uint64_t v25 = (v24.i32[0] * v24.i32[1]);
    uint64_t v26 = 0;
    int v27 = *(_DWORD *)(a1 + 64);
    char v28 = 1;
    while (1)
    {
      int v29 = v26;
      if (v27 == 2) {
        int v29 = select_ncolors_RGB_order[v26];
      }
      uint64_t v30 = *(int *)(v14 + 4 * v29);
      int v31 = v30 + 1;
      uint64_t v32 = (int)v25 / (int)v30 * (v30 + 1);
      if (v32 <= v8)
      {
        char v28 = 0;
        *(_DWORD *)(v14 + 4 * v29) = v31;
        ++v26;
        uint64_t v25 = v32;
        if (v26 != v7) {
          continue;
        }
      }
      uint64_t v26 = 0;
      char v33 = v28;
      char v28 = 1;
      if (v33) {
        break;
      }
    }
  }
  float64x2_t v34 = *(_DWORD **)a1;
  if (*(_DWORD *)(a1 + 144) == 3)
  {
    v34[12] = v25;
    v34[13] = *(_DWORD *)(v6 + 60);
    v34[14] = *(_DWORD *)(v6 + 64);
    v34[15] = *(_DWORD *)(v6 + 68);
    int v35 = 96;
    uint32x4_t v36 = (void (**)(void))v34;
  }
  else
  {
    v34[12] = v25;
    uint32x4_t v36 = *(void (***)(void))a1;
    int v35 = 97;
  }
  v34[10] = v35;
  ((void (*)(uint64_t, uint64_t))v36[1])(a1, 1);
  uint64_t v37 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)(a1 + 8) + 16))(a1, 1, v25, *(unsigned int *)(a1 + 144));
  int v38 = *(_DWORD *)(a1 + 144);
  if (v38 >= 1)
  {
    uint64_t v39 = 0;
    int v40 = v25;
    do
    {
      uint64_t v41 = *(unsigned int *)(v6 + 4 * v39 + 60);
      uint64_t v42 = (v40 / (int)v41);
      if ((int)v41 >= 1)
      {
        uint64_t v43 = 0;
        uint64_t v44 = 0;
        do
        {
          if (v43 * (int)v42 < (int)v25)
          {
            uint64_t v45 = v44;
            do
            {
              if ((int)v42 >= 1)
              {
                for (uint64_t i = 0; i != v42; ++i)
                  *(unsigned char *)(*(void *)(v37 + 8 * v39) + v45 + i) = ((unint64_t)((v41 - 1) >> 1)
                                                                    - v43
                                                                    + (v43 << 8))
                                                                   / (v41 - 1);
              }
              v45 += v40;
            }
            while (v45 < (int)v25);
          }
          ++v43;
          v44 += (int)v42;
        }
        while (v43 != v41);
        int v38 = *(_DWORD *)(a1 + 144);
      }
      ++v39;
      v40 /= (int)v41;
    }
    while (v39 < v38);
  }
  *(void *)(v6 + 32) = v37;
  *(_DWORD *)(v6 + 40) = v25;
  uint64_t result = create_colorindex(a1);
  if (*(_DWORD *)(a1 + 112) == 2)
  {
    return alloc_fs_workspace(a1);
  }
  return result;
}

void start_pass_1_quant(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 656);
  *(void *)(a1 + 160) = *(void *)(v2 + 32);
  *(_DWORD *)(a1 + 156) = *(_DWORD *)(v2 + 40);
  int v3 = *(_DWORD *)(a1 + 112);
  if (v3 == 2)
  {
    *(void *)(v2 + 8) = quantize_fs_dither;
    *(_DWORD *)(v2 + 144) = 0;
    if (!*(void *)(v2 + 112)) {
      alloc_fs_workspace(a1);
    }
    if (*(int *)(a1 + 144) >= 1)
    {
      uint64_t v5 = 0;
      size_t v6 = 2 * (*(_DWORD *)(a1 + 136) + 2);
      uint64_t v7 = v2 + 112;
      do
        bzero(*(void **)(v7 + 8 * v5++), v6);
      while (v5 < *(int *)(a1 + 144));
    }
  }
  else if (v3 == 1)
  {
    uint64_t v8 = quantize_ord_dither;
    if (*(_DWORD *)(a1 + 144) == 3) {
      uint64_t v8 = quantize3_ord_dither;
    }
    *(void *)(v2 + 8) = v8;
    *(_DWORD *)(v2 + 76) = 0;
    if (!*(_DWORD *)(v2 + 56)) {
      create_colorindex(a1);
    }
    if (!*(void *)(v2 + 80))
    {
      int v9 = *(_DWORD *)(a1 + 144);
      if (v9 >= 1)
      {
        uint64_t v10 = 0;
        uint64_t v11 = *(void *)(a1 + 656);
        uint64_t v12 = v11 + 60;
        do
        {
          int v13 = *(_DWORD *)(v11 + 4 * v10 + 60);
          if (!v10) {
            goto LABEL_25;
          }
          uint64_t v14 = 0;
          while (v13 != *(_DWORD *)(v12 + 4 * v14))
          {
            if (v10 == ++v14) {
              goto LABEL_25;
            }
          }
          uint64_t v15 = *(void *)(v12 + 8 * v14 + 20);
          if (!v15)
          {
LABEL_25:
            uint64_t v15 = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1024);
            uint64_t v16 = 0;
            int32x2_t v17 = (unsigned __int8 *)&base_dither_matrix;
            uint64_t v18 = v15;
            do
            {
              for (uint64_t i = 0; i != 16; ++i)
                *(_DWORD *)(v18 + 4 * i) = 255 * (255 - 2 * v17[i]) / ((uint64_t)(v13 - 1) << 9);
              ++v16;
              v18 += 64;
              v17 += 16;
            }
            while (v16 != 16);
            int v9 = *(_DWORD *)(a1 + 144);
          }
          *(void *)(v11 + 8 * v10++ + 80) = v15;
        }
        while (v10 < v9);
      }
    }
  }
  else if (v3)
  {
    uint64_t v20 = *(void *)a1;
    *(_DWORD *)(v20 + 40) = 49;
    int64x2_t v21 = *(void (**)(void))v20;
    v21();
  }
  else
  {
    if (*(_DWORD *)(a1 + 144) == 3) {
      int v4 = color_quantize3;
    }
    else {
      int v4 = color_quantize;
    }
    *(void *)(v2 + 8) = v4;
  }
}

uint64_t new_color_map_1_quant(uint64_t *a1)
{
  uint64_t v1 = *a1;
  *(_DWORD *)(v1 + 40) = 47;
  return (*(uint64_t (**)(uint64_t *))v1)(a1);
}

uint64_t create_colorindex(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 656);
  int v3 = *(_DWORD *)(a1 + 112);
  if (v3 == 1) {
    uint64_t v4 = 766;
  }
  else {
    uint64_t v4 = 256;
  }
  *(_DWORD *)(v2 + 56) = v3 == 1;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)(a1 + 8) + 16))(a1, 1, v4, *(unsigned int *)(a1 + 144));
  *(void *)(v2 + 48) = result;
  if (*(int *)(a1 + 144) >= 1)
  {
    uint64_t v6 = 0;
    int v7 = *(_DWORD *)(v2 + 40);
    do
    {
      uint64_t v8 = *(int *)(v2 + 4 * v6 + 60);
      uint64_t v9 = *(void *)(v2 + 48);
      if (v3 == 1)
      {
        *(void *)(v9 + 8 * v6) += 255;
        uint64_t v9 = *(void *)(v2 + 48);
      }
      uint64_t v10 = 0;
      int v11 = 0;
      uint64_t v12 = *(char **)(v9 + 8 * v6);
      uint64_t v13 = v8 - 1;
      uint64_t v14 = 2 * ((int)v8 - 1);
      uint64_t v15 = (v8 + 254) / v14;
      v7 /= (int)v8;
      do
      {
        if (v10 > (int)v15)
        {
          int v16 = 2 * v11 + 3;
          do
          {
            uint64_t v15 = (v13 - v16 + ((uint64_t)v16 << 8)) / v14;
            ++v11;
            v16 += 2;
          }
          while (v10 > (int)v15);
        }
        v12[v10++] = v11 * v7;
      }
      while (v10 != 256);
      if (v3 == 1)
      {
        uint64_t v17 = 0;
        char v18 = *v12;
        int v19 = v12 + 256;
        do
        {
          v12[v17 - 1] = v18;
          *v19++ = v12[255];
          --v17;
        }
        while (v17 != -255);
      }
      ++v6;
    }
    while (v6 < *(int *)(a1 + 144));
  }
  return result;
}

uint64_t alloc_fs_workspace(uint64_t result)
{
  if (*(int *)(result + 144) >= 1)
  {
    uint64_t v1 = result;
    uint64_t v2 = 0;
    uint64_t v3 = 2 * (*(_DWORD *)(result + 136) + 2);
    uint64_t v4 = *(void *)(result + 656) + 112;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v1 + 8) + 8))(v1, 1, v3);
      *(void *)(v4 + 8 * v2++) = result;
    }
    while (v2 < *(int *)(v1 + 144));
  }
  return result;
}

uint64_t color_quantize3(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(uint64_t **)(*(void *)(result + 656) + 48);
    uint64_t v6 = *v5;
    uint64_t v7 = v5[1];
    uint64_t v8 = v5[2];
    int v9 = *(_DWORD *)(result + 136);
    do
    {
      if (v9)
      {
        uint64_t v10 = *(unsigned char **)(a3 + 8 * v4);
        int v11 = *(unsigned __int8 **)(a2 + 8 * v4);
        int v12 = v9;
        do
        {
          uint64_t result = *(unsigned __int8 *)(v7 + v11[1]);
          *v10++ = result + *(unsigned char *)(v6 + *v11) + *(unsigned char *)(v8 + v11[2]);
          v11 += 3;
          --v12;
        }
        while (v12);
      }
      ++v4;
    }
    while (v4 != a4);
  }
  return result;
}

uint64_t color_quantize(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(uint64_t **)(*(void *)(result + 656) + 48);
    int v6 = *(_DWORD *)(result + 136);
    uint64_t v7 = *(unsigned int *)(result + 144);
    uint64_t v8 = a4;
    do
    {
      if (v6)
      {
        int v9 = *(unsigned char **)(a3 + 8 * v4);
        uint64_t v10 = *(unsigned __int8 **)(a2 + 8 * v4);
        int v11 = v6;
        do
        {
          if ((int)v7 < 1)
          {
            char v12 = 0;
          }
          else
          {
            char v12 = 0;
            uint64_t result = v7;
            uint64_t v13 = v5;
            uint64_t v14 = v10;
            do
            {
              uint64_t v16 = *v13++;
              uint64_t v15 = v16;
              LODWORD(v16) = *v14++;
              v12 += *(unsigned char *)(v15 + v16);
              --result;
            }
            while (result);
            v10 += (v7 - 1) + 1;
          }
          *v9++ = v12;
          --v11;
        }
        while (v11);
      }
      ++v4;
    }
    while (v4 != v8);
  }
  return result;
}

uint64_t quantize3_ord_dither(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(void *)(result + 656);
    int v6 = *(uint64_t **)(v5 + 48);
    uint64_t v7 = *v6;
    uint64_t v8 = v6[1];
    uint64_t v9 = v6[2];
    int v10 = *(_DWORD *)(result + 136);
    uint64_t v11 = a4;
    int v12 = *(_DWORD *)(v5 + 76);
    do
    {
      if (v10)
      {
        uint64_t v13 = 0;
        uint64_t v14 = *(void *)(v5 + 80) + ((uint64_t)v12 << 6);
        uint64_t result = *(void *)(v5 + 88) + ((uint64_t)v12 << 6);
        uint64_t v15 = *(void *)(v5 + 96) + ((uint64_t)v12 << 6);
        uint64_t v16 = *(unsigned char **)(a3 + 8 * v4);
        uint64_t v17 = *(unsigned __int8 **)(a2 + 8 * v4);
        int v18 = v10;
        do
        {
          *v16++ = *(unsigned char *)(v8 + *(int *)(result + 4 * v13) + (unint64_t)v17[1])
                 + *(unsigned char *)(v7 + *(int *)(v14 + 4 * v13) + (unint64_t)*v17)
                 + *(unsigned char *)(v9 + *(int *)(v15 + 4 * v13) + (unint64_t)v17[2]);
          uint64_t v13 = ((_BYTE)v13 + 1) & 0xF;
          v17 += 3;
          --v18;
        }
        while (v18);
      }
      int v12 = ((_BYTE)v12 + 1) & 0xF;
      *(_DWORD *)(v5 + 76) = v12;
      ++v4;
    }
    while (v4 != v11);
  }
  return result;
}

void quantize_ord_dither(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = *(void *)(a1 + 656);
    size_t v8 = *(unsigned int *)(a1 + 136);
    uint64_t v9 = *(unsigned int *)(a1 + 144);
    int v10 = *(_DWORD *)(a1 + 144);
    uint64_t v11 = a4;
    do
    {
      bzero(*(void **)(a3 + 8 * v6), v8);
      uint64_t v12 = *(int *)(v7 + 76);
      if (v10 >= 1)
      {
        uint64_t v13 = 0;
        do
        {
          if (v8)
          {
            uint64_t v14 = 0;
            uint64_t v15 = *(void *)(*(void *)(v7 + 48) + 8 * v13);
            uint64_t v16 = *(void *)(v7 + 8 * v13 + 80) + (v12 << 6);
            uint64_t v17 = *(unsigned char **)(a3 + 8 * v6);
            uint64_t v18 = *(void *)(a2 + 8 * v6);
            int v19 = v8;
            do
            {
              *v17++ += *(unsigned char *)(v15 + *(int *)(v16 + 4 * v14) + (unint64_t)*(unsigned __int8 *)(v18 + v13));
              uint64_t v14 = ((_BYTE)v14 + 1) & 0xF;
              v18 += (int)v9;
              --v19;
            }
            while (v19);
          }
          ++v13;
        }
        while (v13 != v9);
      }
      *(_DWORD *)(v7 + 76) = ((_BYTE)v12 + 1) & 0xF;
      ++v6;
    }
    while (v6 != v11);
  }
}

void quantize_fs_dither(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = *(void *)(a1 + 656);
    uint64_t v8 = *(unsigned int *)(a1 + 144);
    size_t v9 = *(unsigned int *)(a1 + 136);
    uint64_t v10 = *(void *)(a1 + 440);
    uint64_t v11 = (v9 - 1);
    uint64_t v12 = (v11 * v8);
    uint64_t v13 = -(int)v8;
    uint64_t v31 = a4;
    do
    {
      uint64_t v14 = v13;
      uint64_t v15 = v11;
      bzero(*(void **)(a3 + 8 * v6), v9);
      uint64_t v11 = v15;
      uint64_t v13 = v14;
      if ((int)v8 >= 1)
      {
        for (uint64_t i = 0; i != v8; ++i)
        {
          uint64_t v17 = (unsigned __int8 *)(*(void *)(a2 + 8 * v6) + i);
          uint64_t v18 = *(unsigned char **)(a3 + 8 * v6);
          if (*(_DWORD *)(v7 + 144))
          {
            v17 += v12;
            v18 += v11;
            int v19 = (_WORD *)(*(void *)(v7 + 8 * i + 112) + 2 * (v9 + 1));
            uint64_t v20 = -1;
            int v21 = v14;
          }
          else
          {
            int v19 = *(_WORD **)(v7 + 8 * i + 112);
            uint64_t v20 = 1;
            int v21 = v8;
          }
          __int16 v22 = 0;
          if (v9)
          {
            __int16 v23 = 0;
            int v24 = 0;
            uint64_t v25 = *(void *)(*(void *)(v7 + 48) + 8 * i);
            uint64_t v26 = *(void *)(*(void *)(v7 + 32) + 8 * i);
            int v27 = v9;
            do
            {
              uint64_t v28 = *(unsigned __int8 *)(v10 + *v17 + (uint64_t)((v24 + (__int16)v19[v20] + 8) >> 4));
              uint64_t v29 = *(unsigned __int8 *)(v25 + v28);
              *v18 += v29;
              LODWORD(v29) = v28 - *(unsigned __int8 *)(v26 + v29);
              __int16 v30 = 3 * v29 + v22;
              __int16 v22 = 5 * v29 + v23;
              int v24 = 7 * v29;
              v17 += v21;
              *int v19 = v30;
              v18 += v20;
              v19 += v20;
              __int16 v23 = v29;
              --v27;
            }
            while (v27);
          }
          *int v19 = v22;
        }
      }
      *(_DWORD *)(v7 + 144) = *(_DWORD *)(v7 + 144) == 0;
      ++v6;
    }
    while (v6 != v31);
  }
}

double xdr::Texture<unsigned short,float,int>::sampleRead(unsigned __int16 *a1, uint64_t a2, int a3, float a4)
{
  int v4 = (int)(float)((float)a3 + a4);
  if ((v4 & 0x80000000) == 0 && a1[6] > (unsigned __int16)v4)
  {
LABEL_7:
    (*(void (**)(unsigned __int16 *, void))(*(void *)a1 + 16))(a1, (unsigned __int16)v4);
    return result;
  }
  int v5 = *(_DWORD *)(a2 + 4);
  if (v5)
  {
    if (v5 == 1)
    {
      v4 &= ~(v4 >> 31);
      if ((__int16)(a1[6] - 1) < v4) {
        LOWORD(v4) = a1[6] - 1;
      }
    }
    goto LABEL_7;
  }
  return 0.0;
}

double _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE10sampleReadERKNS_7SamplerES2_S3_(__int16 *a1, uint64_t a2, float32x2_t a3, int32x2_t a4)
{
  *(int32x2_t *)v4.i8 = vadd_s32(vcvt_s32_f32(a3), a4);
  int32x2_t v5 = vshr_n_s32(vshl_n_s32(*(int32x2_t *)v4.i8, 0x10uLL), 0x10uLL);
  int16x4_t v6 = (int16x4_t)vshr_n_s32(v5, 0xFuLL);
  if ((vmaxv_u16((uint16x4_t)vuzp1_s16(v6, v6)) & 0x8000) == 0)
  {
    v7.i32[0] = a1[6];
    v7.i32[1] = a1[7];
    int16x4_t v8 = (int16x4_t)vcge_s32(v5, v7);
    int32x2_t v5 = (int32x2_t)vuzp1_s16(v8, v8);
    if ((vmaxv_u16((uint16x4_t)v5) & 0x8000) == 0) {
      goto LABEL_6;
    }
  }
  int v9 = *(_DWORD *)(a2 + 4);
  if (v9)
  {
    if (v9 == 1)
    {
      v5.i16[0] = a1[6];
      v5.i16[2] = a1[7];
      unsigned __int32 v10 = vmax_s16((int16x4_t)vuzp1_s16(*(int16x4_t *)v4.i8, *(int16x4_t *)v4.i8).u32[0], 0).u32[0];
      uint32x4_t v4 = vmovl_u16((uint16x4_t)vmin_s16((int16x4_t)v10, (int16x4_t)vuzp1_s16((int16x4_t)vadd_s32(v5, (int32x2_t)0xFFFF0000FFFFLL), (int16x4_t)v10).u32[0]));
    }
LABEL_6:
    HIWORD(v12) = v4.i16[2];
    LOWORD(v12) = v4.i16[0];
    (*(void (**)(__int16 *, void))(*(void *)a1 + 16))(a1, v12);
    return result;
  }
  return 0.0;
}

double _ZNK3xdr7TextureIDv3_tDv3_fDv3_iE10sampleReadERKNS_7SamplerES2_S3_(int16x4_t *a1, uint64_t a2, float32x4_t a3, int32x4_t a4)
{
  __n128 v4 = (__n128)vcvtq_s32_f32(a3);
  v4.n128_u64[0] = (unint64_t)vadd_s16(vmovn_s32((int32x4_t)v4), vmovn_s32(a4));
  uint16x4_t v5 = (uint16x4_t)vcltz_s16((int16x4_t)v4.n128_u64[0]);
  v5.i16[3] = v5.i16[2];
  if ((vmaxv_u16(v5) & 0x8000) == 0)
  {
    uint16x4_t v6 = (uint16x4_t)vcge_s16((int16x4_t)v4.n128_u64[0], a1[2]);
    v6.i16[3] = v6.i16[2];
    if ((vmaxv_u16(v6) & 0x8000) == 0) {
      goto LABEL_6;
    }
  }
  int v7 = *(_DWORD *)(a2 + 4);
  if (v7)
  {
    if (v7 == 1)
    {
      int16x4_t v8 = vadd_s16(a1[2], (int16x4_t)-1);
      v4.n128_u16[3] = 0;
      int16x4_t v9 = vmax_s16((int16x4_t)v4.n128_u64[0], 0);
      v9.i16[3] = 0;
      v8.i16[3] = 0;
      v4.n128_u64[0] = (unint64_t)vmin_s16(v9, v8);
    }
LABEL_6:
    (*(void (**)(__n128))(*(void *)a1 + 16))(v4);
    return result;
  }
  return 0.0;
}

double xdr::Texture<unsigned short,float,int>::sample(unsigned __int16 *a1, _DWORD *a2, int a3, float a4, float a5)
{
  if (!*a2)
  {
    LOWORD(a5) = a1[6];
    a4 = (float)LODWORD(a5) * a4;
  }
  if (a2[2] == 1)
  {
    float v8 = a4 + -0.5;
    float v12 = ceilf(a4 + -0.5) - (float)(a4 + -0.5);
    float v14 = 1.0 - v12;
    *(double *)v9.i64 = xdr::Texture<unsigned short,float,int>::sampleRead(a1, (uint64_t)a2, a3, a4 + -0.5);
    float32x4_t v13 = vmlaq_n_f32((float32x4_t)0, v9, v12);
    *(double *)v10.i64 = xdr::Texture<unsigned short,float,int>::sampleRead(a1, (uint64_t)a2, a3 + 1, v8);
    *(void *)&double result = vmlaq_n_f32(v13, v10, v14).u64[0];
  }
  else
  {
    return xdr::Texture<unsigned short,float,int>::sampleRead(a1, (uint64_t)a2, a3, a4);
  }
  return result;
}

double _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE6sampleERKNS_7SamplerES2_S3_(uint64_t a1, _DWORD *a2, float32x2_t a3, int32x2_t a4)
{
  if (!*a2)
  {
    v7.i32[0] = *(unsigned __int16 *)(a1 + 12);
    v7.i32[1] = *(unsigned __int16 *)(a1 + 14);
    a3 = vmul_f32(vadd_f32((float32x2_t)vorr_s8(v7, (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), a3);
  }
  if (a2[2] == 1)
  {
    float32x2_t v8 = vadd_f32(vrndm_f32(vadd_f32(a3, (float32x2_t)0xBF000000BF000000)), (float32x2_t)0x3F0000003F000000);
    float32x2_t v9 = vsub_f32(a3, v8);
    __asm { FMOV            V0.2S, #1.0 }
    float32x2_t v20 = vsub_f32(_D0, v9);
    float32x2_t v21 = v9;
    *(double *)v15.i64 = _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE10sampleReadERKNS_7SamplerES2_S3_((__int16 *)a1, (uint64_t)a2, v8, a4);
    float32x4_t v22 = vmlaq_n_f32((float32x4_t)0, v15, vmuls_lane_f32(v20.f32[0], v20, 1));
    *(double *)v16.i64 = _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE10sampleReadERKNS_7SamplerES2_S3_((__int16 *)a1, (uint64_t)a2, v8, vadd_s32(a4, (int32x2_t)0x100000000));
    float32x4_t v23 = vmlaq_n_f32(v22, v16, vmuls_lane_f32(v20.f32[0], v21, 1));
    *(double *)v17.i64 = _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE10sampleReadERKNS_7SamplerES2_S3_((__int16 *)a1, (uint64_t)a2, v8, vadd_s32(a4, (int32x2_t)1));
    float32x4_t v24 = vmlaq_n_f32(v23, v17, vmuls_lane_f32(v21.f32[0], v20, 1));
    *(double *)v18.i64 = _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE10sampleReadERKNS_7SamplerES2_S3_((__int16 *)a1, (uint64_t)a2, v8, vadd_s32(a4, (int32x2_t)0x100000001));
    *(void *)&double result = vmlaq_n_f32(v24, v18, vmuls_lane_f32(v21.f32[0], v21, 1)).u64[0];
  }
  else
  {
    return _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE10sampleReadERKNS_7SamplerES2_S3_((__int16 *)a1, (uint64_t)a2, a3, a4);
  }
  return result;
}

double _ZNK3xdr7TextureIDv3_tDv3_fDv3_iE6sampleERKNS_7SamplerES2_S3_(uint64_t a1, _DWORD *a2, float32x4_t a3, int32x4_t a4)
{
  if (!*a2) {
    a3 = vmulq_f32(a3, vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)(a1 + 16)), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000)));
  }
  if (a2[2] == 1)
  {
    v6.i64[0] = 0xBF000000BF000000;
    v6.i64[1] = 0xBF000000BF000000;
    float32x4_t v7 = vaddq_f32(a3, v6);
    v7.i32[3] = 0;
    float32x4_t v8 = vrndmq_f32(v7);
    v7.i64[0] = 0x3F0000003F000000;
    v7.i64[1] = 0x3F0000003F000000;
    float32x4_t v29 = vaddq_f32(v8, v7);
    float32x4_t v30 = vsubq_f32(a3, v29);
    __asm { FMOV            V0.4S, #1.0 }
    float32x4_t v27 = vsubq_f32(_Q0, v30);
    float v14 = vmuls_lane_f32(v27.f32[0], *(float32x2_t *)v27.f32, 1);
    *(double *)v15.i64 = _ZNK3xdr7TextureIDv3_tDv3_fDv3_iE10sampleReadERKNS_7SamplerES2_S3_((int16x4_t *)a1, (uint64_t)a2, v29, a4);
    float32x4_t v31 = vmlaq_n_f32((float32x4_t)0, v15, vmuls_lane_f32(v14, v27, 2));
    *(double *)v16.i64 = _ZNK3xdr7TextureIDv3_tDv3_fDv3_iE10sampleReadERKNS_7SamplerES2_S3_((int16x4_t *)a1, (uint64_t)a2, v29, vaddq_s32(a4, (int32x4_t)xmmword_18898C840));
    float32x4_t v32 = vmlaq_n_f32(v31, v16, vmuls_lane_f32(v14, v30, 2));
    float v17 = vmuls_lane_f32(v27.f32[0], *(float32x2_t *)v30.f32, 1);
    *(double *)v18.i64 = _ZNK3xdr7TextureIDv3_tDv3_fDv3_iE10sampleReadERKNS_7SamplerES2_S3_((int16x4_t *)a1, (uint64_t)a2, v29, vaddq_s32(a4, (int32x4_t)xmmword_18898E360));
    float32x4_t v33 = vmlaq_n_f32(v32, v18, vmuls_lane_f32(v17, v27, 2));
    *(double *)v19.i64 = _ZNK3xdr7TextureIDv3_tDv3_fDv3_iE10sampleReadERKNS_7SamplerES2_S3_((int16x4_t *)a1, (uint64_t)a2, v29, vaddq_s32(a4, (int32x4_t)xmmword_18898C350));
    float32x4_t v34 = vmlaq_n_f32(v33, v19, vmuls_lane_f32(v17, v30, 2));
    float v20 = vmuls_lane_f32(v30.f32[0], *(float32x2_t *)v27.f32, 1);
    *(double *)v21.i64 = _ZNK3xdr7TextureIDv3_tDv3_fDv3_iE10sampleReadERKNS_7SamplerES2_S3_((int16x4_t *)a1, (uint64_t)a2, v29, vaddq_s32(a4, (int32x4_t)xmmword_18898E370));
    float32x4_t v35 = vmlaq_n_f32(v34, v21, vmuls_lane_f32(v20, v27, 2));
    *(double *)v22.i64 = _ZNK3xdr7TextureIDv3_tDv3_fDv3_iE10sampleReadERKNS_7SamplerES2_S3_((int16x4_t *)a1, (uint64_t)a2, v29, vaddq_s32(a4, (int32x4_t)xmmword_18898E380));
    float32x4_t v36 = vmlaq_n_f32(v35, v22, vmuls_lane_f32(v20, v30, 2));
    float v23 = vmuls_lane_f32(v30.f32[0], *(float32x2_t *)v30.f32, 1);
    *(double *)v24.i64 = _ZNK3xdr7TextureIDv3_tDv3_fDv3_iE10sampleReadERKNS_7SamplerES2_S3_((int16x4_t *)a1, (uint64_t)a2, v29, vaddq_s32(a4, (int32x4_t)xmmword_18898E390));
    float32x4_t v37 = vmlaq_n_f32(v36, v24, vmuls_lane_f32(v23, v27, 2));
    v24.i64[0] = 0x100000001;
    v24.i64[1] = 0x100000001;
    *(double *)v25.i64 = _ZNK3xdr7TextureIDv3_tDv3_fDv3_iE10sampleReadERKNS_7SamplerES2_S3_((int16x4_t *)a1, (uint64_t)a2, v29, vaddq_s32(a4, (int32x4_t)v24));
    *(void *)&double result = vmlaq_n_f32(v37, v25, vmuls_lane_f32(v23, v30, 2)).u64[0];
  }
  else
  {
    return _ZNK3xdr7TextureIDv3_tDv3_fDv3_iE10sampleReadERKNS_7SamplerES2_S3_((int16x4_t *)a1, (uint64_t)a2, a3, a4);
  }
  return result;
}

uint64_t IIOCallCreatePixelBufferAttributesForHDRType(int a1, void *a2, void *a3, void *a4)
{
  kdebug_trace();
  uint64_t v8 = IIOCreatePixelBufferAttributesForHDRType(a1, a2, a3, a4);
  kdebug_trace();
  return v8;
}

uint64_t IIOCallConvertHDRGainMap(__IOSurface *a1, const void *a2, __IOSurface *a3, uint64_t a4, CGImageMetadata **a5, void *a6)
{
  kdebug_trace();
  float32x4_t v18 = 0;
  uint64_t v12 = *MEMORY[0x1E4F1CF80];
  gFunc_CVPixelBufferCreateWithIOSurface(*MEMORY[0x1E4F1CF80], a1, MEMORY[0x1E4F1CC08], &v18);
  float32x4_t v13 = v18;
  if (v18)
  {
    if (a2)
    {
      float32x4_t v18 = 0;
      gFunc_CVPixelBufferCreateWithIOSurface(v12, a2, MEMORY[0x1E4F1CC08], &v18);
      a2 = v18;
    }
    float32x4_t v18 = 0;
    gFunc_CVPixelBufferCreateWithIOSurface(v12, a3, MEMORY[0x1E4F1CC08], &v18);
    float v14 = v18;
    if (v18)
    {
      float32x4_t v18 = 0;
      gFunc_CVPixelBufferCreateWithIOSurface(v12, a4, MEMORY[0x1E4F1CC08], &v18);
      float32x4_t v15 = v18;
      if (v18)
      {
        uint64_t v16 = IIOConvertHDRGainMap((uint64_t)v13, (uint64_t)a2, (uint64_t)v14, (uint64_t)v18, a5, a6);
        CFRelease(v15);
      }
      else
      {
        uint64_t v16 = 4294967246;
      }
      CFRelease(v14);
    }
    else
    {
      uint64_t v16 = 4294967246;
    }
    if (a2) {
      CFRelease(a2);
    }
    CFRelease(v13);
    if (!v16)
    {
      uint64_t v16 = IIOSurfaceCopyAlphaValuesFromSource(a1, a3);
      IIO_IOSurfaceLogAlphaInfo(a1, "IIOCallConvertHDRGainMap inputSurface:");
      IIO_IOSurfaceLogAlphaInfo(a3, "IIOCallConvertHDRGainMap outputSurface:");
    }
  }
  else
  {
    uint64_t v16 = 4294967246;
  }
  kdebug_trace();
  return v16;
}

uint64_t IIOCallCreateFlexGTCInfo(uint64_t a1, uint64_t a2, id *a3, void *a4)
{
  kdebug_trace();
  if (a3
    && (uint64_t v11 = 0,
        gFunc_CVPixelBufferCreateWithIOSurface(*MEMORY[0x1E4F1CF80], a1, MEMORY[0x1E4F1CC08], &v11),
        (uint64_t v8 = v11) != 0))
  {
    if (a2) {
      uint64_t FlexGTCInfo = CGImageCreateFlexGTCInfo((uint64_t)v11, a2, a3, a4);
    }
    else {
      uint64_t FlexGTCInfo = 4294967246;
    }
    CFRelease(v8);
  }
  else
  {
    uint64_t FlexGTCInfo = 4294967246;
  }
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(*a3, "objectForKeyedSubscript:", @"com.apple.ColorSync.MonoGainMapParams"), "objectForKeyedSubscript:", @"com.apple.ColorSync.GainMapBaselineHeadroom"), "floatValue");
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a4, "objectForKeyedSubscript:", @"{MakerApple}"), "objectForKeyedSubscript:", @"33"), "floatValue");
  objc_msgSend((id)objc_msgSend((id)objc_msgSend(a4, "objectForKeyedSubscript:", @"{MakerApple}"), "objectForKeyedSubscript:", @"48"), "floatValue");
  kdebug_trace();
  return FlexGTCInfo;
}

uint64_t IIOCallConvertHDRData(__IOSurface *a1, __IOSurface *a2, void *a3)
{
  kdebug_trace();
  uint64_t v11 = 0;
  uint64_t v6 = *MEMORY[0x1E4F1CF80];
  gFunc_CVPixelBufferCreateWithIOSurface(*MEMORY[0x1E4F1CF80], a1, MEMORY[0x1E4F1CC08], &v11);
  float32x4_t v7 = v11;
  if (!v11) {
    goto LABEL_8;
  }
  uint64_t v11 = 0;
  gFunc_CVPixelBufferCreateWithIOSurface(v6, a2, MEMORY[0x1E4F1CC08], &v11);
  uint64_t v8 = v11;
  if (!v11)
  {
    CFRelease(v7);
LABEL_8:
    uint64_t v9 = 4294967246;
    goto LABEL_9;
  }
  if (*(void *)gIIO_kCVImageBufferYCbCrMatrix_ITU_R_2020) {
    gFunc_CVBufferSetAttachment(v11, *(void *)gIIO_kCVImageBufferYCbCrMatrixKey, *(void *)gIIO_kCVImageBufferYCbCrMatrix_ITU_R_2020, 1);
  }
  uint64_t v9 = IIOConvertHDRData((uint64_t)v7, (uint64_t)v8, a3);
  CFRelease(v8);
  CFRelease(v7);
  if (!v9)
  {
    uint64_t v9 = IIOSurfaceCopyAlphaValuesFromSource(a1, a2);
    IIO_IOSurfaceLogAlphaInfo(a1, "IIOCallConvertHDRData inputSurface:");
    IIO_IOSurfaceLogAlphaInfo(a2, "IIOCallConvertHDRData outputSurface:");
  }
LABEL_9:
  kdebug_trace();
  return v9;
}

uint64_t IIOCallApplyHDRGainmap(__IOSurface *a1, uint64_t a2, __IOSurface *a3, void *a4)
{
  kdebug_trace();
  CFTypeRef cf = 0;
  uint64_t v8 = *MEMORY[0x1E4F1CF80];
  gFunc_CVPixelBufferCreateWithIOSurface(*MEMORY[0x1E4F1CF80], a1, MEMORY[0x1E4F1CC08], &cf);
  CFTypeRef v9 = cf;
  if (!cf) {
    goto LABEL_7;
  }
  if (!a2 || (cf = 0, gFunc_CVPixelBufferCreateWithIOSurface(v8, a3, MEMORY[0x1E4F1CC08], &cf), (CFTypeRef v10 = cf) == 0))
  {
    CFRelease(v9);
LABEL_7:
    uint64_t v11 = 4294967246;
    goto LABEL_8;
  }
  uint64_t v11 = IIOApplyHDRGainMap((uint64_t)v9, a2, (uint64_t)cf, a4);
  CFRelease(v10);
  CFRelease(v9);
  if (!v11)
  {
    uint64_t v11 = IIOSurfaceCopyAlphaValuesFromSource(a1, a3);
    IIO_IOSurfaceLogAlphaInfo(a1, "IIOCallApplyHDRGainmap inputSurface:");
    IIO_IOSurfaceLogAlphaInfo(a3, "IIOCallApplyHDRGainmap outputSurface:");
  }
LABEL_8:
  kdebug_trace();
  return v11;
}

uint64_t IIOCallCreateHDRGainmap(__IOSurface *a1, __IOSurface *a2, uint64_t a3, void *a4)
{
  kdebug_trace();
  float v14 = 0;
  uint64_t v8 = *MEMORY[0x1E4F1CF80];
  gFunc_CVPixelBufferCreateWithIOSurface(*MEMORY[0x1E4F1CF80], a1, MEMORY[0x1E4F1CC08], &v14);
  CFTypeRef v9 = v14;
  if (!v14) {
    goto LABEL_6;
  }
  float v14 = 0;
  gFunc_CVPixelBufferCreateWithIOSurface(v8, a2, MEMORY[0x1E4F1CC08], &v14);
  CFTypeRef v10 = v14;
  if (!v14)
  {
    CFRelease(v9);
LABEL_6:
    uint64_t v12 = 4294967246;
    goto LABEL_10;
  }
  float v14 = 0;
  gFunc_CVPixelBufferCreateWithIOSurface(v8, a3, MEMORY[0x1E4F1CC08], &v14);
  uint64_t v11 = v14;
  if (v14)
  {
    uint64_t v12 = IIOCreateHDRGainMap((uint64_t)v9, (uint64_t)v10, (uint64_t)v14, a4);
    CFRelease(v11);
  }
  else
  {
    uint64_t v12 = 4294967246;
  }
  CFRelease(v10);
  CFRelease(v9);
  if (!v12)
  {
    uint64_t v12 = IIOSurfaceCopyAlphaValuesFromSource(a1, a2);
    IIO_IOSurfaceLogAlphaInfo(a1, "IIOCallCreateHDRGainmap inputSurface:");
    IIO_IOSurfaceLogAlphaInfo(a2, "IIOCallCreateHDRGainmap outputSurface:");
  }
LABEL_10:
  kdebug_trace();
  return v12;
}

void kdu_block_encoder::kdu_block_encoder(kdu_block_encoder *this)
{
}

clock_t kd_block_encoder::encode(kd_block_encoder *this, kdu_block *a2, double a3)
{
  double v5 = MEMORY[0x1F4188790](this, a2);
  int v565 = v6;
  v605[91] = *MEMORY[0x1E4F143B8];
  double v7 = -1.0;
  BOOL v8 = v5 > 0.0 && v4 >= 2;
  v587 = v3;
  if (v8 && *((_DWORD *)v3 + 8)) {
    double v7 = exp(((double)v4 + -65536.0) * 0.00270760617) * 4294967300.0;
  }
  bzero(v605, 0x2D8uLL);
  long long v603 = 0u;
  long long v604 = 0u;
  long long v602 = 0u;
  memset(v601, 0, sizeof(v601));
  long long v600 = 0u;
  memset(v599, 0, sizeof(v599));
  bzero(v597, 0x16C0uLL);
  CFTypeRef v9 = &v598;
  uint64_t v10 = 91;
  do
  {
    *((unsigned char *)v9 - 5) = 0;
    *(v9 - 3) = 0;
    *(v9 - 2) = 0;
    *CFTypeRef v9 = 0;
    v9[1] = 0;
    *((unsigned char *)v9 + 16) = 0;
    v9 += 8;
    --v10;
  }
  while (v10);
  uint64_t v11 = v587;
  int v12 = *((_DWORD *)v587 + 1);
  int v566 = *(_DWORD *)v587;
  int v13 = *(_DWORD *)v587 + 3;
  if (*((_DWORD *)v587 + 28) < (signed int)((v13 & 0xFFFFFFFC) * v12)) {
    kd_block_encoder::encode();
  }
  uint64_t v14 = v12;
  uint64_t v15 = v12 + 3;
  int v563 = v13 >> 2;
  int v16 = ((v13 >> 2) + 2) * v15;
  int v585 = *((_DWORD *)v587 + 1);
  uint64_t v561 = v12;
  uint64_t v559 = v15;
  if (*((_DWORD *)v587 + 29) <= v16)
  {
    if (v16 <= 1599) {
      int v16 = 1599;
    }
    kdu_block::set_max_contexts((uint64_t)v587, v16 + 1);
    uint64_t v15 = v559;
    uint64_t v14 = v561;
    int v12 = v585;
    uint64_t v11 = v587;
  }
  uint64_t v17 = *((void *)v11 + 13);
  v560 = (_DWORD *)*((void *)v11 + 12);
  int v18 = *((_DWORD *)v11 + 12);
  int v19 = 3 * (31 - *((_DWORD *)v11 + 11)) - 2;
  BOOL v20 = v18 <= v19;
  if (v18 >= v19) {
    int v21 = 3 * (31 - *((_DWORD *)v11 + 11)) - 2;
  }
  else {
    int v21 = *((_DWORD *)v11 + 12);
  }
  int v22 = v21 & ~(v21 >> 31);
  if (!v20 || v21 < 0) {
    *((_DWORD *)v11 + 12) = v22;
  }
  float v23 = (char *)(v17 + 4 * v15);
  if (*((_DWORD *)v11 + 22) < v22)
  {
    kdu_block::set_max_passes((uint64_t)v587, v22 + 10, 0);
    uint64_t v15 = v559;
    uint64_t v14 = v561;
    int v12 = v585;
    uint64_t v11 = v587;
  }
  v562 = (unsigned int *)(v23 + 4);
  if (*((_DWORD *)v11 + 34))
  {
    clock_t v24 = clock();
    uint64_t v15 = v559;
    uint64_t v14 = v561;
    int v12 = v585;
    *((void *)v587 + 19) = v24;
    int v25 = *((_DWORD *)v587 + 34);
  }
  else
  {
    int v25 = 1;
  }
  int v558 = v25;
  size_t v26 = 4 * (int)v15 * v563 + 4;
  int v27 = v566 & 3;
  v555 = (int *)&v562[(v563 - 1) * (int)v15];
  uint64_t v583 = -3 - v12;
  uint64_t v584 = -4 - v12;
  uint64_t v582 = -2 - v12;
  uint64_t v589 = v12 + 2;
  uint64_t v588 = v12 + 4;
  uint64_t v577 = v14;
  uint64_t v557 = 4 * v14 + 4 * v15 + v17 + 12;
  uint64_t v576 = -12 - 4 * v14;
  uint64_t v575 = v589;
  int32x2_t v28 = vdup_n_s32(0x49200000u);
  uint64_t v591 = 2 * v14;
  uint64_t v592 = 3 * v14;
  v593 = v601;
  int v554 = v18;
  uint64_t v553 = (v18 - 1);
  unsigned int v578 = v12 + 1;
  uint64_t v579 = v15;
  uint64_t v573 = 3 * v14;
  uint64_t v574 = 2 * v14;
  v556 = v23;
  size_t v564 = v26;
  do
  {
    bzero(v23, v26);
    if (v27)
    {
      if (v27 == 2) {
        int v29 = 1207959552;
      }
      else {
        int v29 = 0x40000000;
      }
      if (v27 == 1) {
        int v29 = 1224736768;
      }
      if (v585 >= 1)
      {
        unsigned int v30 = v578;
        float32x4_t v31 = v555;
        do
        {
          *v31++ = v29;
          --v30;
        }
        while (v30 > 1);
      }
    }
    clock_t v32 = (clock_t)v587;
    if (v566 >= 1)
    {
      float32x4_t v33 = (int32x2_t *)v557;
      int v34 = v563 + 1;
      do
      {
        v33->i32[0] = 1226833920;
        v33[-1] = v28;
        --v34;
        float32x4_t v33 = (int32x2_t *)((char *)v33 + v579 * 4);
      }
      while (v34 > 1);
    }
    int v35 = *((_DWORD *)v587 + 11);
    double v36 = v5 * 0.0000152587891 * 0.0000152587891;
    if (v35 >= 1)
    {
      unsigned int v37 = v35 + 1;
      double v36 = v5 * 0.0000152587891 * 0.0000152587891;
      do
      {
        double v36 = v36 * 0.25;
        --v37;
      }
      while (v37 > 1);
    }
    LODWORD(v38) = *((_DWORD *)v587 + 12);
    if ((int)v38 < 1)
    {
      int v40 = 0;
      goto LABEL_918;
    }
    unint64_t v39 = 0;
    BOOL v567 = 0;
    int v40 = 0;
    int v41 = 0;
    int v580 = 0;
    int v590 = *((_DWORD *)v587 + 7);
    int v572 = *((_DWORD *)v587 + 23);
    v568 = (unsigned __int8 *)*((void *)v587 + 9);
    int v569 = 30 - v35;
    int v42 = 2;
    int v586 = 1;
    do
    {
      BOOL v43 = v42 == 3;
      if (v42 == 3)
      {
        double v36 = v36 * 0.25;
        int v44 = 0;
      }
      else
      {
        int v44 = v42;
      }
      int v571 = v44;
      int v45 = v572;
      int64_t v581 = v39;
      if (v572 - v41 <= 4095)
      {
        if (v572 < v41) {
          kd_block_encoder::encode();
        }
        float64x2_t v46 = *(unsigned __int8 **)(v32 + 72);
        clock_t v47 = v32;
        unint64_t v48 = v39;
        kdu_block::set_max_bytes(v32, *(_DWORD *)(v32 + 92) + 0x2000, 1);
        unsigned int v49 = *(unsigned __int8 **)(v47 + 72);
        if (v48)
        {
          uint64_t v50 = v597;
          int64_t v51 = v581;
          do
          {
            mq_encoder::augment_buffer((uint64_t)v50, v46, v49);
            v50 += 64;
            --v51;
          }
          while (v51);
        }
        int v45 = v572 + 0x2000;
        v568 = &v49[v568 - v46];
        clock_t v32 = (clock_t)v587;
        unint64_t v39 = v581;
        BOOL v43 = v42 == 3;
      }
      int v572 = v45;
      if (v580)
      {
        mq_encoder::continues((mq_encoder *)&v597[64 * v39], (mq_encoder *)(&v589 + 8 * v39));
      }
      else
      {
        int v52 = *(_DWORD *)(v32 + 48);
        int v53 = *(_DWORD *)(v32 + 28);
        if (v53)
        {
          if (v571 == 2) {
            int v54 = 1;
          }
          else {
            int v54 = 2;
          }
          if (v39 <= 9) {
            int v54 = 10 - v39;
          }
          BOOL v55 = v567;
          if (v39 > 9) {
            BOOL v55 = v571 != 2;
          }
        }
        else
        {
          int v54 = *(_DWORD *)(v32 + 48);
          BOOL v55 = v567;
        }
        if ((v53 & 4) != 0) {
          int v56 = 1;
        }
        else {
          int v56 = v54;
        }
        if (v56 + (int)v39 <= v52) {
          int v57 = v56;
        }
        else {
          int v57 = v52 - v39;
        }
        int v580 = v57;
        BOOL v567 = v55;
        mq_encoder::start((mq_encoder *)&v597[64 * v39], v568, !v55);
      }
      int v570 = v569 - v43;
      if (v565) {
        BOOL v58 = 31 - (v569 - v43) == *((_DWORD *)v587 + 10);
      }
      else {
        BOOL v58 = 0;
      }
      if (!v581 || (*((unsigned char *)v587 + 28) & 2) != 0)
      {
        uint64_t v59 = 0;
        int v60 = mq_encoder::p_bar_table[0];
        do
        {
          uint64_t v61 = &v599[v59];
          *(_DWORD *)uint64_t v61 = v60;
          v61[1] = &mq_encoder::transition_table;
          v59 += 2;
        }
        while (v59 != 36);
        LODWORD(v599[0]) = unk_1E90FD0E8;
        v599[1] = &unk_1E91059E8;
        LODWORD(v600) = dword_1E90FD0E4;
        *((void *)&v600 + 1) = &unk_1E91059A8;
      }
      if (v42 == 3 && !v567)
      {
        uint64_t v208 = *((int *)v587 + 8);
        *(void *)v595 = 0;
        *(void *)v596 = 0;
        v594 = 0;
        mq_encoder::check_out((uint64_t)&v597[64 * v581], &v596[1], v596, &v595[1], v595, &v594);
        if (v570 >= 31) {
          kd_block_encoder::encode();
        }
        v209 = &significance_distortion_lut;
        if (v58) {
          v209 = &significance_distortion_lut_lossless;
        }
        if (v566 < 1)
        {
          int v64 = 0;
LABEL_654:
          mq_encoder::check_in((uint64_t)&v597[64 * v581], v596[1], v596[0], v595[1], v595[0], v594);
LABEL_832:
          size_t v389 = v564;
          goto LABEL_833;
        }
        int v64 = 0;
        char v210 = 31 - v570;
        uint64_t v211 = (uint64_t)*(&significance_luts + v208);
        int v212 = v563;
        v213 = v560;
        unsigned int v214 = v562;
        while (v585 < 1)
        {
LABEL_589:
          v214 += 3;
          v213 += v592;
          BOOL v207 = __OFSUB__(v212--, 1);
          if ((v212 < 0) ^ v207 | (v212 == 0)) {
            goto LABEL_654;
          }
        }
        int v215 = v585;
        while (1)
        {
          unsigned int v216 = *v214;
          if (!*v214)
          {
            if (!v214[3])
            {
              do
              {
                v215 -= 3;
                v213 += 3;
                unsigned int v225 = v214[6];
                v214 += 3;
              }
              while (!v225);
            }
            goto LABEL_587;
          }
          if ((v216 & 0x1EF) != 0 && (v216 & 0x200010) == 0)
          {
            uint64_t v218 = *(unsigned __int8 *)(v211 + (v216 & 0x1EF));
            v219 = (int *)&v599[2 * v218];
            unsigned int v220 = *v213 << v210;
            int v221 = *v219;
            signed int v222 = v220 & 0x80000000 ^ *v219;
            signed int v223 = v596[1] - v222;
            v596[1] = v223;
            if (v223 < 0x8000)
            {
              if (v222 < 0)
              {
                v223 &= ~0x80000000;
                v596[1] = v223;
                if (v223 >= (v221 & 0x7FFFFFFFu))
                {
                  v596[1] = v221 & 0x7FFFFFFF;
                  signed int v223 = v221 & 0x7FFFFFFF;
                }
                else
                {
                  v596[0] += v221 & 0x7FFFFFFF;
                }
                v226 = (_OWORD *)(v599[2 * v218 + 1] + 16);
              }
              else
              {
                if (v223 >= v222)
                {
                  v596[0] += v222;
                }
                else
                {
                  v596[1] = v220 & 0x80000000 ^ v221;
                  signed int v223 = v596[1];
                }
                v226 = (_OWORD *)v599[2 * v218 + 1];
              }
              *(_OWORD *)v219 = *v226;
              if (v223 >= 0x8000) {
                kd_block_encoder::encode();
              }
              int v224 = v596[0];
              int v227 = v595[1];
              do
              {
                v596[1] = 2 * v223;
                v596[0] = 2 * v224;
                v595[1] = --v227;
                if (v227)
                {
                  v224 *= 2;
                }
                else
                {
                  int v228 = v595[0] + (v224 >> 26);
                  v595[0] = v228;
                  if (v228 < 255)
                  {
                    v230 = v594++;
                    unsigned __int8 *v230 = v228;
                    v595[0] = (v596[0] >> 19);
                    int v224 = v596[0] & 0x7FFFF;
                    v596[0] &= 0x7FFFFu;
                    int v227 = 8;
                  }
                  else
                  {
                    v229 = v594++;
                    unsigned __int8 *v229 = -1;
                    v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                    int v224 = v596[0] & 0xFFFFF;
                    v596[0] &= 0xFFFFFu;
                    int v227 = 7;
                  }
                  v595[1] = v227;
                }
                signed int v223 = v596[1];
              }
              while (v596[1] < 0x8000);
            }
            else
            {
              int v224 = v596[0] + v222;
              v596[0] += v222;
            }
            if ((v220 & 0x80000000) != 0)
            {
              int v231 = v209[(v220 >> 26) & 0x1F];
              unsigned int v232 = v214[1];
              int v233 = sign_lut[(*(v214 - 1) >> 2) & 4 | (v216 >> 1) & 0x41 | v232 & 0x10 | (((*(v214 - 1) >> 2) & 0x80004 | (v216 >> 1) & 0x820041 | v232 & 0x200010) >> 16)];
              uint64_t v234 = v233 >> 1;
              v235 = (int *)&v593[16 * v234];
              unsigned int v236 = *v213 & 0x80000000;
              int v237 = *v235;
              int v238 = *v235 ^ (v233 << 31) ^ v236;
              int v239 = v223 - v238;
              v596[1] = v239;
              if (v239 < 0x8000)
              {
                if (v238 < 0)
                {
                  int v238 = v239 & 0x7FFFFFFF;
                  v596[1] = v239 & 0x7FFFFFFF;
                  if ((v239 & 0x7FFFFFFFu) >= (v237 & 0x7FFFFFFFu))
                  {
                    v596[1] = v237 & 0x7FFFFFFF;
                    int v238 = v237 & 0x7FFFFFFF;
                  }
                  else
                  {
                    v224 += v237 & 0x7FFFFFFF;
                    v596[0] = v224;
                  }
                  v240 = (_OWORD *)(*(void *)&v593[16 * v234 + 8] + 16);
                }
                else
                {
                  if (v239 >= v238)
                  {
                    v224 += v238;
                    v596[0] = v224;
                    int v238 = v239;
                  }
                  else
                  {
                    v596[1] = v238;
                  }
                  v240 = *(_OWORD **)&v593[16 * v234 + 8];
                }
                *(_OWORD *)v235 = *v240;
                if (v238 >= 0x8000) {
                  kd_block_encoder::encode();
                }
                int v241 = v595[1];
                do
                {
                  v596[1] = 2 * v238;
                  v596[0] = 2 * v224;
                  v595[1] = --v241;
                  if (v241)
                  {
                    v224 *= 2;
                  }
                  else
                  {
                    int v242 = v595[0] + (v224 >> 26);
                    v595[0] = v242;
                    if (v242 < 255)
                    {
                      v244 = v594++;
                      unsigned __int8 *v244 = v242;
                      v595[0] = (v596[0] >> 19);
                      int v224 = v596[0] & 0x7FFFF;
                      v596[0] &= 0x7FFFFu;
                      int v241 = 8;
                    }
                    else
                    {
                      v243 = v594++;
                      unsigned __int8 *v243 = -1;
                      v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                      int v224 = v596[0] & 0xFFFFF;
                      v596[0] &= 0xFFFFFu;
                      int v241 = 7;
                    }
                    v595[1] = v241;
                  }
                  int v238 = v596[1];
                }
                while (v596[1] < 0x8000);
                unsigned int v232 = v214[1];
              }
              else
              {
                v596[0] = v238 + v224;
              }
              v64 += v231;
              *(v214 - 1) |= 0x20u;
              v214[1] = v232 | 8;
              if (v236)
              {
                v216 |= 0x300010u;
                if ((v590 & 8) == 0)
                {
                  v214[v584] |= 0x20000u;
                  v214[v583] |= 0x80010000;
                  goto LABEL_441;
                }
              }
              else
              {
                v216 |= 0x100010u;
                if ((v590 & 8) == 0)
                {
                  v214[v584] |= 0x20000u;
                  v214[v583] |= 0x10000u;
LABEL_441:
                  v214[v582] |= 0x8000u;
                }
              }
            }
            else
            {
              v216 |= 0x100000u;
            }
          }
          if ((v216 & 0xF78) != 0 && (v216 & 0x1000080) == 0)
          {
            uint64_t v246 = *(unsigned __int8 *)(v211 + ((v216 >> 3) & 0x1EFLL));
            v247 = (int *)&v599[2 * v246];
            unsigned int v248 = v213[v561] << v210;
            int v249 = *v247;
            signed int v250 = v248 & 0x80000000 ^ *v247;
            signed int v251 = v596[1] - v250;
            v596[1] = v251;
            if (v251 < 0x8000)
            {
              if (v250 < 0)
              {
                v251 &= ~0x80000000;
                v596[1] = v251;
                if (v251 >= (v249 & 0x7FFFFFFFu))
                {
                  v596[1] = v249 & 0x7FFFFFFF;
                  signed int v251 = v249 & 0x7FFFFFFF;
                }
                else
                {
                  v596[0] += v249 & 0x7FFFFFFF;
                }
                v253 = (_OWORD *)(v599[2 * v246 + 1] + 16);
              }
              else
              {
                if (v251 >= v250)
                {
                  v596[0] += v250;
                }
                else
                {
                  v596[1] = v248 & 0x80000000 ^ v249;
                  signed int v251 = v596[1];
                }
                v253 = (_OWORD *)v599[2 * v246 + 1];
              }
              *(_OWORD *)v247 = *v253;
              if (v251 >= 0x8000) {
                kd_block_encoder::encode();
              }
              int v252 = v596[0];
              int v254 = v595[1];
              do
              {
                v596[1] = 2 * v251;
                v596[0] = 2 * v252;
                v595[1] = --v254;
                if (v254)
                {
                  v252 *= 2;
                }
                else
                {
                  int v255 = v595[0] + (v252 >> 26);
                  v595[0] = v255;
                  if (v255 < 255)
                  {
                    v257 = v594++;
                    unsigned __int8 *v257 = v255;
                    v595[0] = (v596[0] >> 19);
                    int v252 = v596[0] & 0x7FFFF;
                    v596[0] &= 0x7FFFFu;
                    int v254 = 8;
                  }
                  else
                  {
                    v256 = v594++;
                    unsigned __int8 *v256 = -1;
                    v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                    int v252 = v596[0] & 0xFFFFF;
                    v596[0] &= 0xFFFFFu;
                    int v254 = 7;
                  }
                  v595[1] = v254;
                }
                signed int v251 = v596[1];
              }
              while (v596[1] < 0x8000);
            }
            else
            {
              int v252 = v596[0] + v250;
              v596[0] += v250;
            }
            if ((v248 & 0x80000000) != 0)
            {
              int v258 = v209[(v248 >> 26) & 0x1F];
              unsigned int v259 = v214[1];
              int v260 = sign_lut[(*(v214 - 1) >> 5) & 4 | (v216 >> 4) & 0x41 | (v259 >> 3) & 0x10 | (((*(v214 - 1) >> 5) & 0x80004 | (v216 >> 4) & 0x820041 | (v259 >> 3) & 0x200010) >> 16)];
              uint64_t v261 = v260 >> 1;
              v262 = (int *)&v593[16 * v261];
              unsigned int v263 = v213[v561] & 0x80000000;
              int v264 = *v262;
              int v265 = *v262 ^ (v260 << 31) ^ v263;
              int v266 = v251 - v265;
              v596[1] = v266;
              if (v266 < 0x8000)
              {
                if (v265 < 0)
                {
                  int v265 = v266 & 0x7FFFFFFF;
                  v596[1] = v266 & 0x7FFFFFFF;
                  if ((v266 & 0x7FFFFFFFu) >= (v264 & 0x7FFFFFFFu))
                  {
                    v596[1] = v264 & 0x7FFFFFFF;
                    int v265 = v264 & 0x7FFFFFFF;
                  }
                  else
                  {
                    v252 += v264 & 0x7FFFFFFF;
                    v596[0] = v252;
                  }
                  v267 = (_OWORD *)(*(void *)&v593[16 * v261 + 8] + 16);
                }
                else
                {
                  if (v266 >= v265)
                  {
                    v252 += v265;
                    v596[0] = v252;
                    int v265 = v266;
                  }
                  else
                  {
                    v596[1] = v265;
                  }
                  v267 = *(_OWORD **)&v593[16 * v261 + 8];
                }
                *(_OWORD *)v262 = *v267;
                if (v265 >= 0x8000) {
                  kd_block_encoder::encode();
                }
                int v268 = v595[1];
                do
                {
                  v596[1] = 2 * v265;
                  v596[0] = 2 * v252;
                  v595[1] = --v268;
                  if (v268)
                  {
                    v252 *= 2;
                  }
                  else
                  {
                    int v269 = v595[0] + (v252 >> 26);
                    v595[0] = v269;
                    if (v269 < 255)
                    {
                      v271 = v594++;
                      unsigned __int8 *v271 = v269;
                      v595[0] = (v596[0] >> 19);
                      int v252 = v596[0] & 0x7FFFF;
                      v596[0] &= 0x7FFFFu;
                      int v268 = 8;
                    }
                    else
                    {
                      v270 = v594++;
                      unsigned __int8 *v270 = -1;
                      v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                      int v252 = v596[0] & 0xFFFFF;
                      v596[0] &= 0xFFFFFu;
                      int v268 = 7;
                    }
                    v595[1] = v268;
                  }
                  int v265 = v596[1];
                }
                while (v596[1] < 0x8000);
                unsigned int v259 = v214[1];
              }
              else
              {
                v596[0] = v265 + v252;
              }
              v64 += v258;
              *(v214 - 1) |= 0x100u;
              v214[1] = v259 | 0x40;
              v216 |= (v263 >> 7) | 0x800080;
            }
            else
            {
              v216 |= 0x800000u;
            }
          }
          if ((v216 & 0x7BC0) != 0 && (v216 & 0x8000400) == 0)
          {
            uint64_t v272 = *(unsigned __int8 *)(v211 + ((v216 >> 6) & 0x1EFLL));
            v273 = (int *)&v599[2 * v272];
            unsigned int v274 = v213[v591] << v210;
            int v275 = *v273;
            signed int v276 = v274 & 0x80000000 ^ *v273;
            signed int v277 = v596[1] - v276;
            v596[1] = v277;
            if (v277 < 0x8000)
            {
              if (v276 < 0)
              {
                v277 &= ~0x80000000;
                v596[1] = v277;
                if (v277 >= (v275 & 0x7FFFFFFFu))
                {
                  v596[1] = v275 & 0x7FFFFFFF;
                  signed int v277 = v275 & 0x7FFFFFFF;
                }
                else
                {
                  v596[0] += v275 & 0x7FFFFFFF;
                }
                v279 = (_OWORD *)(v599[2 * v272 + 1] + 16);
              }
              else
              {
                if (v277 >= v276)
                {
                  v596[0] += v276;
                }
                else
                {
                  v596[1] = v274 & 0x80000000 ^ v275;
                  signed int v277 = v596[1];
                }
                v279 = (_OWORD *)v599[2 * v272 + 1];
              }
              *(_OWORD *)v273 = *v279;
              if (v277 >= 0x8000) {
                kd_block_encoder::encode();
              }
              int v278 = v596[0];
              int v280 = v595[1];
              do
              {
                v596[1] = 2 * v277;
                v596[0] = 2 * v278;
                v595[1] = --v280;
                if (v280)
                {
                  v278 *= 2;
                }
                else
                {
                  int v281 = v595[0] + (v278 >> 26);
                  v595[0] = v281;
                  if (v281 < 255)
                  {
                    v283 = v594++;
                    unsigned __int8 *v283 = v281;
                    v595[0] = (v596[0] >> 19);
                    int v278 = v596[0] & 0x7FFFF;
                    v596[0] &= 0x7FFFFu;
                    int v280 = 8;
                  }
                  else
                  {
                    v282 = v594++;
                    unsigned __int8 *v282 = -1;
                    v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                    int v278 = v596[0] & 0xFFFFF;
                    v596[0] &= 0xFFFFFu;
                    int v280 = 7;
                  }
                  v595[1] = v280;
                }
                signed int v277 = v596[1];
              }
              while (v596[1] < 0x8000);
            }
            else
            {
              int v278 = v596[0] + v276;
              v596[0] += v276;
            }
            if ((v274 & 0x80000000) != 0)
            {
              int v284 = v209[(v274 >> 26) & 0x1F];
              unsigned int v285 = v214[1];
              int v286 = sign_lut[(*(v214 - 1) >> 8) & 4 | (v216 >> 7) & 0x41 | (v285 >> 6) & 0x10 | (((*(v214 - 1) >> 8) & 0x80004 | (v216 >> 7) & 0x820041 | (v285 >> 6) & 0x200010) >> 16)];
              uint64_t v287 = v286 >> 1;
              v288 = (int *)&v593[16 * v287];
              unsigned int v289 = v213[v591] & 0x80000000;
              int v290 = *v288;
              int v291 = *v288 ^ (v286 << 31) ^ v289;
              int v292 = v277 - v291;
              v596[1] = v292;
              if (v292 < 0x8000)
              {
                if (v291 < 0)
                {
                  int v291 = v292 & 0x7FFFFFFF;
                  v596[1] = v292 & 0x7FFFFFFF;
                  if ((v292 & 0x7FFFFFFFu) >= (v290 & 0x7FFFFFFFu))
                  {
                    v596[1] = v290 & 0x7FFFFFFF;
                    int v291 = v290 & 0x7FFFFFFF;
                  }
                  else
                  {
                    v278 += v290 & 0x7FFFFFFF;
                    v596[0] = v278;
                  }
                  v293 = (_OWORD *)(*(void *)&v593[16 * v287 + 8] + 16);
                }
                else
                {
                  if (v292 >= v291)
                  {
                    v278 += v291;
                    v596[0] = v278;
                    int v291 = v292;
                  }
                  else
                  {
                    v596[1] = v291;
                  }
                  v293 = *(_OWORD **)&v593[16 * v287 + 8];
                }
                *(_OWORD *)v288 = *v293;
                if (v291 >= 0x8000) {
                  kd_block_encoder::encode();
                }
                int v294 = v595[1];
                do
                {
                  v596[1] = 2 * v291;
                  v596[0] = 2 * v278;
                  v595[1] = --v294;
                  if (v294)
                  {
                    v278 *= 2;
                  }
                  else
                  {
                    int v295 = v595[0] + (v278 >> 26);
                    v595[0] = v295;
                    if (v295 < 255)
                    {
                      v297 = v594++;
                      unsigned __int8 *v297 = v295;
                      v595[0] = (v596[0] >> 19);
                      int v278 = v596[0] & 0x7FFFF;
                      v596[0] &= 0x7FFFFu;
                      int v294 = 8;
                    }
                    else
                    {
                      v296 = v594++;
                      unsigned __int8 *v296 = -1;
                      v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                      int v278 = v596[0] & 0xFFFFF;
                      v596[0] &= 0xFFFFFu;
                      int v294 = 7;
                    }
                    v595[1] = v294;
                  }
                  int v291 = v596[1];
                }
                while (v596[1] < 0x8000);
                unsigned int v285 = v214[1];
              }
              else
              {
                v596[0] = v291 + v278;
              }
              v64 += v284;
              *(v214 - 1) |= 0x800u;
              v214[1] = v285 | 0x200;
              v216 |= (v289 >> 4) | 0x4000400;
            }
            else
            {
              v216 |= 0x4000000u;
            }
          }
          if ((v216 & 0x3DE00) != 0 && (v216 & 0x40002000) == 0)
          {
            uint64_t v298 = *(unsigned __int8 *)(v211 + ((v216 >> 9) & 0x1EF));
            v299 = (int *)&v599[2 * v298];
            unsigned int v300 = v213[v592] << v210;
            int v301 = *v299;
            signed int v302 = v300 & 0x80000000 ^ *v299;
            signed int v303 = v596[1] - v302;
            v596[1] = v303;
            if (v303 < 0x8000)
            {
              if (v302 < 0)
              {
                v303 &= ~0x80000000;
                v596[1] = v303;
                if (v303 >= (v301 & 0x7FFFFFFFu))
                {
                  v596[1] = v301 & 0x7FFFFFFF;
                  signed int v303 = v301 & 0x7FFFFFFF;
                }
                else
                {
                  v596[0] += v301 & 0x7FFFFFFF;
                }
                v305 = (_OWORD *)(v599[2 * v298 + 1] + 16);
              }
              else
              {
                if (v303 >= v302)
                {
                  v596[0] += v302;
                }
                else
                {
                  v596[1] = v300 & 0x80000000 ^ v301;
                  signed int v303 = v596[1];
                }
                v305 = (_OWORD *)v599[2 * v298 + 1];
              }
              *(_OWORD *)v299 = *v305;
              if (v303 >= 0x8000) {
                kd_block_encoder::encode();
              }
              int v304 = v596[0];
              int v306 = v595[1];
              do
              {
                v596[1] = 2 * v303;
                v596[0] = 2 * v304;
                v595[1] = --v306;
                if (v306)
                {
                  v304 *= 2;
                }
                else
                {
                  int v307 = v595[0] + (v304 >> 26);
                  v595[0] = v307;
                  if (v307 < 255)
                  {
                    v309 = v594++;
                    unsigned __int8 *v309 = v307;
                    v595[0] = (v596[0] >> 19);
                    int v304 = v596[0] & 0x7FFFF;
                    v596[0] &= 0x7FFFFu;
                    int v306 = 8;
                  }
                  else
                  {
                    v308 = v594++;
                    unsigned __int8 *v308 = -1;
                    v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                    int v304 = v596[0] & 0xFFFFF;
                    v596[0] &= 0xFFFFFu;
                    int v306 = 7;
                  }
                  v595[1] = v306;
                }
                signed int v303 = v596[1];
              }
              while (v596[1] < 0x8000);
            }
            else
            {
              int v304 = v596[0] + v302;
              v596[0] += v302;
            }
            if ((v300 & 0x80000000) != 0)
            {
              int v310 = v209[(v300 >> 26) & 0x1F];
              int v311 = (v216 >> 10) & 0x20041;
              if ((v216 & 0x80000000) != 0) {
                v311 |= 0x800000u;
              }
              unsigned int v312 = (*(v214 - 1) >> 11) & 0x80004 | v311 | (v214[1] >> 9) & 0x200010;
              int v313 = sign_lut[v312 & 0x55 | HIWORD(v312)];
              uint64_t v314 = v313 >> 1;
              v315 = (int *)&v593[16 * v314];
              unsigned int v316 = v213[v592] & 0x80000000;
              int v317 = *v315;
              int v318 = *v315 ^ (v313 << 31) ^ v316;
              int v319 = v303 - v318;
              v596[1] = v319;
              if (v319 < 0x8000)
              {
                if (v318 < 0)
                {
                  int v318 = v319 & 0x7FFFFFFF;
                  v596[1] = v319 & 0x7FFFFFFF;
                  if ((v319 & 0x7FFFFFFFu) >= (v317 & 0x7FFFFFFFu))
                  {
                    v596[1] = v317 & 0x7FFFFFFF;
                    int v318 = v317 & 0x7FFFFFFF;
                  }
                  else
                  {
                    v304 += v317 & 0x7FFFFFFF;
                    v596[0] = v304;
                  }
                  v320 = (_OWORD *)(*(void *)&v593[16 * v314 + 8] + 16);
                }
                else
                {
                  if (v319 >= v318)
                  {
                    v304 += v318;
                    v596[0] = v304;
                    int v318 = v319;
                  }
                  else
                  {
                    v596[1] = v318;
                  }
                  v320 = *(_OWORD **)&v593[16 * v314 + 8];
                }
                *(_OWORD *)v315 = *v320;
                if (v318 >= 0x8000) {
                  kd_block_encoder::encode();
                }
                int v321 = v595[1];
                do
                {
                  v596[1] = 2 * v318;
                  v596[0] = 2 * v304;
                  v595[1] = --v321;
                  if (v321)
                  {
                    v304 *= 2;
                  }
                  else
                  {
                    int v322 = v595[0] + (v304 >> 26);
                    v595[0] = v322;
                    if (v322 < 255)
                    {
                      v324 = v594++;
                      unsigned __int8 *v324 = v322;
                      v595[0] = (v596[0] >> 19);
                      int v304 = v596[0] & 0x7FFFF;
                      v596[0] &= 0x7FFFFu;
                      int v321 = 8;
                    }
                    else
                    {
                      v323 = v594++;
                      unsigned __int8 *v323 = -1;
                      v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                      int v304 = v596[0] & 0xFFFFF;
                      v596[0] &= 0xFFFFFu;
                      int v321 = 7;
                    }
                    v595[1] = v321;
                  }
                  int v318 = v596[1];
                }
                while (v596[1] < 0x8000);
              }
              else
              {
                v596[0] = v318 + v304;
              }
              v214[v589] |= 4u;
              v64 += v310;
              v214[v588] |= 1u;
              *(v214 - 1) |= 0x4000u;
              v214[1] |= 0x1000u;
              unsigned int v325 = v214[v559];
              if (v316)
              {
                v214[v559] = v325 | 0x40002;
                v216 |= 0x60002000u;
              }
              else
              {
                v214[v559] = v325 | 2;
                v216 |= 0x20002000u;
              }
            }
            else
            {
              v216 |= 0x20000000u;
            }
          }
          *unsigned int v214 = v216;
LABEL_587:
          ++v213;
          ++v214;
          BOOL v207 = __OFSUB__(v215--, 1);
          if ((v215 < 0) ^ v207 | (v215 == 0)) {
            goto LABEL_589;
          }
        }
      }
      if (v42 == 3)
      {
        *(void *)v596 = 0;
        v594 = 0;
        mq_encoder::check_out((uint64_t)&v597[64 * v581], &v596[1], v596, &v594);
        if (v569 >= 32) {
          kd_block_encoder::encode();
        }
        v326 = &significance_distortion_lut;
        if (v58) {
          v326 = &significance_distortion_lut_lossless;
        }
        if (v566 < 1)
        {
          int v64 = 0;
        }
        else
        {
          int v64 = 0;
          char v327 = 32 - v569;
          int v328 = v563;
          v329 = v560;
          v330 = v562;
          int v331 = v585;
          do
          {
            if (v331 >= 1)
            {
              uint64_t v332 = 0;
              v333 = &v329[v577];
              v334 = &v329[v574];
              v335 = &v329[v573];
              int v336 = v578;
              do
              {
                unsigned int v337 = v330[v332];
                if (v337)
                {
                  if ((v337 & 0x1EF) != 0 && (v337 & 0x200010) == 0)
                  {
                    int v339 = v329[v332];
                    int v340 = v596[1];
                    int v341 = v596[0];
                    if (!v596[1])
                    {
                      v342 = v594++;
                      unsigned __int8 *v342 = v596[0];
                      int v341 = 0;
                      int v340 = 8 - ((v596[0] + 1) >> 8);
                    }
                    unsigned int v343 = v339 << v327;
                    int v344 = __PAIR64__(v341, v343) >> 31;
                    v596[0] = v344;
                    int v345 = v340 - 1;
                    v596[1] = v345;
                    if ((v343 & 0x80000000) != 0)
                    {
                      int v346 = v326[(v343 >> 26) & 0x1F];
                      unsigned int v347 = v329[v332];
                      if (!v345)
                      {
                        v348 = v594++;
                        unsigned __int8 *v348 = v344;
                        int v344 = 0;
                        int v345 = 8 - ((v596[0] + 1) >> 8);
                      }
                      v596[0] = (v347 >> 31) | (2 * v344);
                      v596[1] = v345 - 1;
                      if ((v590 & 8) == 0)
                      {
                        v330[v584 + v332] |= 0x20000u;
                        *(unsigned int *)((char *)v330 + v576 + v332 * 4) |= v347 & 0x80000000 | 0x10000;
                        v330[v582 + v332] |= 0x8000u;
                      }
                      v64 += v346;
                      v349 = &v330[v332];
                      *(v349 - 1) = v330[v332 - 1] | 0x20;
                      v349[1] = v330[v332 + 1] | 8;
                      v337 |= (v347 >> 31 << 21) | 0x100010;
                      int v331 = v585;
                    }
                    else
                    {
                      v337 |= 0x100000u;
                    }
                  }
                  if ((v337 & 0xF78) != 0 && (v337 & 0x1000080) == 0)
                  {
                    int v351 = v333[v332];
                    int v352 = v596[1];
                    int v353 = v596[0];
                    if (!v596[1])
                    {
                      v354 = v594++;
                      unsigned __int8 *v354 = v596[0];
                      int v353 = 0;
                      int v352 = 8 - ((v596[0] + 1) >> 8);
                    }
                    unsigned int v355 = v351 << v327;
                    HIDWORD(v357) = v353;
                    LODWORD(v357) = v351 << v327;
                    int v356 = v357 >> 31;
                    v596[0] = v356;
                    int v358 = v352 - 1;
                    v596[1] = v352 - 1;
                    if ((v355 & 0x80000000) != 0)
                    {
                      int v359 = v326[(v355 >> 26) & 0x1F];
                      unsigned int v360 = v333[v332];
                      if (!v358)
                      {
                        v361 = v594++;
                        unsigned __int8 *v361 = v356;
                        int v356 = 0;
                        int v358 = 8 - ((v596[0] + 1) >> 8);
                      }
                      v64 += v359;
                      v596[0] = (v360 >> 31) | (2 * v356);
                      v596[1] = v358 - 1;
                      v362 = &v330[v332];
                      *(v362 - 1) = v330[v332 - 1] | 0x100;
                      v362[1] = v330[v332 + 1] | 0x40;
                      v337 |= (v360 >> 31 << 24) | 0x800080;
                    }
                    else
                    {
                      v337 |= 0x800000u;
                    }
                  }
                  if ((v337 & 0x7BC0) != 0 && (v337 & 0x8000400) == 0)
                  {
                    int v364 = v334[v332];
                    int v365 = v596[1];
                    int v366 = v596[0];
                    if (!v596[1])
                    {
                      v367 = v594++;
                      unsigned __int8 *v367 = v596[0];
                      int v366 = 0;
                      int v365 = 8 - ((v596[0] + 1) >> 8);
                    }
                    unsigned int v368 = v364 << v327;
                    HIDWORD(v370) = v366;
                    LODWORD(v370) = v364 << v327;
                    int v369 = v370 >> 31;
                    v596[0] = v369;
                    int v371 = v365 - 1;
                    v596[1] = v365 - 1;
                    if ((v368 & 0x80000000) != 0)
                    {
                      int v372 = v326[(v368 >> 26) & 0x1F];
                      unsigned int v373 = v334[v332];
                      if (!v371)
                      {
                        v374 = v594++;
                        unsigned __int8 *v374 = v369;
                        int v369 = 0;
                        int v371 = 8 - ((v596[0] + 1) >> 8);
                      }
                      v64 += v372;
                      v596[0] = (v373 >> 31) | (2 * v369);
                      v596[1] = v371 - 1;
                      v375 = &v330[v332];
                      *(v375 - 1) = v330[v332 - 1] | 0x800;
                      v375[1] = v330[v332 + 1] | 0x200;
                      v337 |= (v373 >> 31 << 27) | 0x4000400;
                    }
                    else
                    {
                      v337 |= 0x4000000u;
                    }
                  }
                  if ((v337 & 0x3DE00) != 0 && (v337 & 0x40002000) == 0)
                  {
                    int v376 = v335[v332];
                    int v377 = v596[1];
                    int v378 = v596[0];
                    if (!v596[1])
                    {
                      v379 = v594++;
                      unsigned __int8 *v379 = v596[0];
                      int v378 = 0;
                      int v377 = 8 - ((v596[0] + 1) >> 8);
                    }
                    unsigned int v380 = v376 << v327;
                    HIDWORD(v382) = v378;
                    LODWORD(v382) = v376 << v327;
                    int v381 = v382 >> 31;
                    v596[0] = v381;
                    int v383 = v377 - 1;
                    v596[1] = v377 - 1;
                    if ((v380 & 0x80000000) != 0)
                    {
                      int v384 = v326[(v380 >> 26) & 0x1F];
                      unsigned int v385 = v335[v332];
                      if (!v383)
                      {
                        v386 = v594++;
                        unsigned __int8 *v386 = v381;
                        int v381 = 0;
                        int v383 = 8 - ((v596[0] + 1) >> 8);
                      }
                      v596[0] = (v385 >> 31) | (2 * v381);
                      v596[1] = v383 - 1;
                      v64 += v384;
                      v330[v575 + v332] |= 4u;
                      v330[v579 + v332] |= (v385 >> 31 << 18) | 2;
                      v330[v588 + v332] |= 1u;
                      v387 = &v330[v332];
                      *(v387 - 1) = v330[v332 - 1] | 0x4000;
                      v387[1] = v330[v332 + 1] | 0x1000;
                      v337 |= (v385 >> 31 << 30) | 0x20002000;
                    }
                    else
                    {
                      v337 |= 0x20000000u;
                    }
                  }
                  v330[v332] = v337;
                }
                ++v332;
                --v336;
              }
              while (v336 > 1);
              v329 = (_DWORD *)((char *)v329 + v332 * 4);
              v330 = (unsigned int *)((char *)v330 + v332 * 4);
            }
            v330 += 3;
            v329 += v592;
            BOOL v207 = __OFSUB__(v328--, 1);
          }
          while (!((v328 < 0) ^ v207 | (v328 == 0)));
        }
        mq_encoder::check_in((uint64_t)&v597[64 * v581], v596[1], v596[0], v594);
        goto LABEL_832;
      }
      if (v42 != 1 || v567)
      {
        if (v42 != 1)
        {
          uint64_t v62 = *((int *)v587 + 8);
          *(void *)v595 = 0;
          *(void *)v596 = 0;
          v594 = 0;
          mq_encoder::check_out((uint64_t)&v597[64 * v581], &v596[1], v596, &v595[1], v595, &v594);
          if (v569 >= 31) {
            kd_block_encoder::encode();
          }
          unsigned int v63 = &significance_distortion_lut;
          if (v58) {
            unsigned int v63 = &significance_distortion_lut_lossless;
          }
          if (v566 >= 1)
          {
            int v64 = 0;
            char v65 = 31 - v569;
            uint64_t v66 = (uint64_t)*(&significance_luts + v62);
            int v67 = v563;
            unint64_t v68 = v560;
            uint64_t v69 = v562;
            while (v585 < 1)
            {
LABEL_374:
              v69 += 3;
              v68 += v592;
              BOOL v207 = __OFSUB__(v67--, 1);
              if ((v67 < 0) ^ v207 | (v67 == 0)) {
                goto LABEL_654;
              }
            }
            int v70 = v585;
            while (1)
            {
              unsigned int v71 = *v69;
              if (!*v69)
              {
                if (*v68 << v65 < 0)
                {
                  BOOL v80 = 0;
                  int v81 = 0;
                }
                else if (v68[v561] << v65 < 0)
                {
                  BOOL v80 = 0;
                  int v81 = 1;
                }
                else
                {
                  if (((v68[v591] << v65) & 0x80000000) == 0)
                  {
                    if (v68[v592] << v65 < 0) {
                      unsigned int v79 = 0x80000000;
                    }
                    else {
                      unsigned int v79 = 0;
                    }
                    BOOL v80 = v68[v592] << v65 >= 0;
                    if (v68[v592] << v65 < 0) {
                      int v81 = 3;
                    }
                    else {
                      int v81 = -1;
                    }
                    goto LABEL_111;
                  }
                  BOOL v80 = 0;
                  int v81 = 2;
                }
                unsigned int v79 = 0x80000000;
LABEL_111:
                int v82 = v600 ^ v79;
                signed int v83 = v596[1] - (v600 ^ v79);
                v596[1] = v83;
                if (v83 < 0x8000)
                {
                  if (v82 < 0)
                  {
                    v83 &= ~0x80000000;
                    v596[1] = v83;
                    if (v83 >= (v600 & 0x7FFFFFFF))
                    {
                      v596[1] = v600 & 0x7FFFFFFF;
                      signed int v83 = v600 & 0x7FFFFFFF;
                    }
                    else
                    {
                      v596[0] += v600 & 0x7FFFFFFF;
                    }
                    uint64_t v85 = (long long *)(*((void *)&v600 + 1) + 16);
                  }
                  else
                  {
                    if (v83 >= v82)
                    {
                      v596[0] += v82;
                    }
                    else
                    {
                      v596[1] = v82;
                      signed int v83 = v82;
                    }
                    uint64_t v85 = (long long *)*((void *)&v600 + 1);
                  }
                  long long v600 = *v85;
                  if (v83 >= 0x8000) {
                    kd_block_encoder::encode();
                  }
                  int v84 = v596[0];
                  int v87 = v595[1];
                  do
                  {
                    v596[1] = 2 * v83;
                    v596[0] = 2 * v84;
                    v595[1] = --v87;
                    if (v87)
                    {
                      v84 *= 2;
                    }
                    else
                    {
                      int v88 = v595[0] + (v84 >> 26);
                      v595[0] = v88;
                      if (v88 < 255)
                      {
                        v90 = v594++;
                        unsigned __int8 *v90 = v88;
                        v595[0] = (v596[0] >> 19);
                        int v84 = v596[0] & 0x7FFFF;
                        v596[0] &= 0x7FFFFu;
                        int v87 = 8;
                      }
                      else
                      {
                        v89 = v594++;
                        unsigned __int8 *v89 = -1;
                        v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                        int v84 = v596[0] & 0xFFFFF;
                        v596[0] &= 0xFFFFFu;
                        int v87 = 7;
                      }
                      v595[1] = v87;
                    }
                    signed int v83 = v596[1];
                  }
                  while (v596[1] < 0x8000);
                }
                else
                {
                  int v84 = v596[0] + v82;
                  v596[0] = v84;
                }
                if (!v80)
                {
                  unsigned int v91 = v83 - 22017;
                  if ((v81 & 2) != 0 || v83 < 0xD601)
                  {
                    int v92 = v84 + 22017;
                    BOOL v93 = v83 >= 0xAC02;
                    if (v83 >= 0xAC02) {
                      int v94 = v84 + 22017;
                    }
                    else {
                      int v94 = v84;
                    }
                    if (v93) {
                      int v95 = v91;
                    }
                    else {
                      int v95 = 22017;
                    }
                    if (v93) {
                      int v92 = v84;
                    }
                    if (v93) {
                      int v96 = 22017;
                    }
                    else {
                      int v96 = v91;
                    }
                    if ((v81 & 2) != 0)
                    {
                      unsigned int v91 = v96;
                    }
                    else
                    {
                      int v92 = v94;
                      unsigned int v91 = v95;
                    }
                    int v97 = v595[1];
                    do
                    {
                      v596[1] = 2 * v91;
                      v596[0] = 2 * v92;
                      v595[1] = --v97;
                      if (v97)
                      {
                        v92 *= 2;
                      }
                      else
                      {
                        int v98 = v595[0] + (v92 >> 26);
                        v595[0] = v98;
                        if (v98 < 255)
                        {
                          unint64_t v100 = v594++;
                          *unint64_t v100 = v98;
                          v595[0] = (v596[0] >> 19);
                          int v92 = v596[0] & 0x7FFFF;
                          v596[0] &= 0x7FFFFu;
                          int v97 = 8;
                        }
                        else
                        {
                          v99 = v594++;
                          unsigned __int8 *v99 = -1;
                          v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                          int v92 = v596[0] & 0xFFFFF;
                          v596[0] &= 0xFFFFFu;
                          int v97 = 7;
                        }
                        v595[1] = v97;
                      }
                      unsigned int v91 = v596[1];
                    }
                    while (v596[1] < 0x8000);
                  }
                  else
                  {
                    int v92 = v84 + 22017;
                  }
                  signed int v77 = v91 - 22017;
                  v596[1] = v91 - 22017;
                  if ((v81 & 1) != 0 || v91 < 0xD601)
                  {
                    BOOL v101 = v91 >= 0xAC02;
                    if (v91 >= 0xAC02) {
                      int v78 = v92 + 22017;
                    }
                    else {
                      int v78 = v92;
                    }
                    if (v91 >= 0xAC02) {
                      int v102 = v91 - 22017;
                    }
                    else {
                      int v102 = 22017;
                    }
                    if (v101)
                    {
                      int v103 = 22017;
                    }
                    else
                    {
                      v92 += 22017;
                      int v103 = v77;
                    }
                    if (v81)
                    {
                      int v78 = v92;
                      signed int v77 = v103;
                    }
                    else
                    {
                      signed int v77 = v102;
                    }
                    int v104 = v595[1];
                    do
                    {
                      v596[1] = 2 * v77;
                      v596[0] = 2 * v78;
                      v595[1] = --v104;
                      if (v104)
                      {
                        v78 *= 2;
                      }
                      else
                      {
                        int v105 = v595[0] + (v78 >> 26);
                        v595[0] = v105;
                        if (v105 < 255)
                        {
                          v107 = v594++;
                          unsigned __int8 *v107 = v105;
                          v595[0] = (v596[0] >> 19);
                          int v78 = v596[0] & 0x7FFFF;
                          v596[0] &= 0x7FFFFu;
                          int v104 = 8;
                        }
                        else
                        {
                          uint64_t v106 = v594++;
                          *uint64_t v106 = -1;
                          v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                          int v78 = v596[0] & 0xFFFFF;
                          v596[0] &= 0xFFFFFu;
                          int v104 = 7;
                        }
                        v595[1] = v104;
                      }
                      signed int v77 = v596[1];
                    }
                    while (v596[1] < 0x8000);
                  }
                  else
                  {
                    int v78 = v92 + 22017;
                    v596[0] = v92 + 22017;
                  }
                  unsigned int v71 = *v69;
                  switch(v81)
                  {
                    case 0:
                      int v108 = *v68;
                      unsigned int v74 = *v68 << v65;
                      goto LABEL_203;
                    case 1:
                      int v113 = v68[v561];
                      unsigned int v114 = v113 << v65;
                      goto LABEL_252;
                    case 2:
                      int v109 = v68[v591];
                      unsigned int v110 = v109 << v65;
                      goto LABEL_297;
                    case 3:
                      int v111 = v68[v592];
                      unsigned int v112 = v111 << v65;
                      goto LABEL_342;
                    default:
                      goto LABEL_92;
                  }
                }
                goto LABEL_372;
              }
LABEL_92:
              if ((v71 & 0x300010) == 0)
              {
                uint64_t v72 = *(unsigned __int8 *)(v66 + (v71 & 0x1EF));
                v73 = (int *)&v599[2 * v72];
                unsigned int v74 = *v68 << v65;
                int v75 = *v73;
                signed int v76 = v74 & 0x80000000 ^ *v73;
                signed int v77 = v596[1] - v76;
                v596[1] = v77;
                if (v77 < 0x8000)
                {
                  if (v76 < 0)
                  {
                    v77 &= ~0x80000000;
                    v596[1] = v77;
                    if (v77 >= (v75 & 0x7FFFFFFFu))
                    {
                      v596[1] = v75 & 0x7FFFFFFF;
                      signed int v77 = v75 & 0x7FFFFFFF;
                    }
                    else
                    {
                      v596[0] += v75 & 0x7FFFFFFF;
                    }
                    v86 = (_OWORD *)(v599[2 * v72 + 1] + 16);
                  }
                  else
                  {
                    if (v77 >= v76)
                    {
                      v596[0] += v76;
                    }
                    else
                    {
                      v596[1] = v74 & 0x80000000 ^ v75;
                      signed int v77 = v596[1];
                    }
                    v86 = (_OWORD *)v599[2 * v72 + 1];
                  }
                  *(_OWORD *)v73 = *v86;
                  if (v77 >= 0x8000) {
                    kd_block_encoder::encode();
                  }
                  int v78 = v596[0];
                  int v115 = v595[1];
                  do
                  {
                    v596[1] = 2 * v77;
                    v596[0] = 2 * v78;
                    v595[1] = --v115;
                    if (v115)
                    {
                      v78 *= 2;
                    }
                    else
                    {
                      int v116 = v595[0] + (v78 >> 26);
                      v595[0] = v116;
                      if (v116 < 255)
                      {
                        int v118 = v594++;
                        *int v118 = v116;
                        v595[0] = (v596[0] >> 19);
                        int v78 = v596[0] & 0x7FFFF;
                        v596[0] &= 0x7FFFFu;
                        int v115 = 8;
                      }
                      else
                      {
                        int v117 = v594++;
                        *int v117 = -1;
                        v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                        int v78 = v596[0] & 0xFFFFF;
                        v596[0] &= 0xFFFFFu;
                        int v115 = 7;
                      }
                      v595[1] = v115;
                    }
                    signed int v77 = v596[1];
                  }
                  while (v596[1] < 0x8000);
                }
                else
                {
                  int v78 = v596[0] + v76;
                  v596[0] += v76;
                }
                if ((v74 & 0x80000000) != 0)
                {
                  int v108 = *v68;
LABEL_203:
                  int v119 = v63[(v74 >> 26) & 0x1F];
                  unsigned int v120 = v69[1];
                  int v121 = sign_lut[(*(v69 - 1) >> 2) & 4 | (v71 >> 1) & 0x41 | v120 & 0x10 | (((*(v69 - 1) >> 2) & 0x80004 | (v71 >> 1) & 0x820041 | v120 & 0x200010) >> 16)];
                  uint64_t v122 = v121 >> 1;
                  v123 = (int *)&v593[16 * v122];
                  unsigned int v124 = v108 & 0x80000000;
                  int v125 = *v123;
                  int v126 = v124 ^ (v121 << 31) ^ *v123;
                  int v127 = v77 - v126;
                  v596[1] = v127;
                  if (v127 < 0x8000)
                  {
                    if (v126 < 0)
                    {
                      int v126 = v127 & 0x7FFFFFFF;
                      v596[1] = v127 & 0x7FFFFFFF;
                      if ((v127 & 0x7FFFFFFFu) >= (v125 & 0x7FFFFFFFu))
                      {
                        v596[1] = v125 & 0x7FFFFFFF;
                        int v126 = v125 & 0x7FFFFFFF;
                      }
                      else
                      {
                        v78 += v125 & 0x7FFFFFFF;
                        v596[0] = v78;
                      }
                      v128 = (_OWORD *)(*(void *)&v593[16 * v122 + 8] + 16);
                    }
                    else
                    {
                      if (v127 >= v126)
                      {
                        v78 += v126;
                        v596[0] = v78;
                        int v126 = v127;
                      }
                      else
                      {
                        v596[1] = v126;
                      }
                      v128 = *(_OWORD **)&v593[16 * v122 + 8];
                    }
                    *(_OWORD *)v123 = *v128;
                    if (v126 >= 0x8000) {
                      kd_block_encoder::encode();
                    }
                    int v129 = v595[1];
                    do
                    {
                      v596[1] = 2 * v126;
                      v596[0] = 2 * v78;
                      v595[1] = --v129;
                      if (v129)
                      {
                        v78 *= 2;
                      }
                      else
                      {
                        int v130 = v595[0] + (v78 >> 26);
                        v595[0] = v130;
                        if (v130 < 255)
                        {
                          v132 = v594++;
                          unsigned __int8 *v132 = v130;
                          v595[0] = (v596[0] >> 19);
                          int v78 = v596[0] & 0x7FFFF;
                          v596[0] &= 0x7FFFFu;
                          int v129 = 8;
                        }
                        else
                        {
                          v131 = v594++;
                          unsigned __int8 *v131 = -1;
                          v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                          int v78 = v596[0] & 0xFFFFF;
                          v596[0] &= 0xFFFFFu;
                          int v129 = 7;
                        }
                        v595[1] = v129;
                      }
                      int v126 = v596[1];
                    }
                    while (v596[1] < 0x8000);
                    unsigned int v120 = v69[1];
                  }
                  else
                  {
                    v596[0] = v126 + v78;
                  }
                  v64 += v119;
                  *(v69 - 1) |= 0x20u;
                  v69[1] = v120 | 8;
                  if (v124)
                  {
                    v71 |= 0x200010u;
                    int v133 = -2147418112;
                    if ((v590 & 8) != 0) {
                      goto LABEL_229;
                    }
                  }
                  else
                  {
                    v71 |= 0x10u;
                    if ((v590 & 8) != 0) {
                      goto LABEL_229;
                    }
                    int v133 = 0x10000;
                  }
                  v69[v584] |= 0x20000u;
                  v69[v583] |= v133;
                  v69[v582] |= 0x8000u;
                }
              }
LABEL_229:
              if ((v71 & 0x1800080) == 0)
              {
                uint64_t v134 = *(unsigned __int8 *)(v66 + ((v71 >> 3) & 0x1EFLL));
                v135 = (int *)&v599[2 * v134];
                unsigned int v114 = v68[v561] << v65;
                int v136 = *v135;
                signed int v137 = v114 & 0x80000000 ^ *v135;
                signed int v77 = v596[1] - v137;
                v596[1] = v77;
                if (v77 < 0x8000)
                {
                  if (v137 < 0)
                  {
                    v77 &= ~0x80000000;
                    v596[1] = v77;
                    if (v77 >= (v136 & 0x7FFFFFFFu))
                    {
                      v596[1] = v136 & 0x7FFFFFFF;
                      signed int v77 = v136 & 0x7FFFFFFF;
                    }
                    else
                    {
                      v596[0] += v136 & 0x7FFFFFFF;
                    }
                    int v138 = (_OWORD *)(v599[2 * v134 + 1] + 16);
                  }
                  else
                  {
                    if (v77 >= v137)
                    {
                      v596[0] += v137;
                    }
                    else
                    {
                      v596[1] = v114 & 0x80000000 ^ v136;
                      signed int v77 = v596[1];
                    }
                    int v138 = (_OWORD *)v599[2 * v134 + 1];
                  }
                  *(_OWORD *)v135 = *v138;
                  if (v77 >= 0x8000) {
                    kd_block_encoder::encode();
                  }
                  int v78 = v596[0];
                  int v139 = v595[1];
                  do
                  {
                    v596[1] = 2 * v77;
                    v596[0] = 2 * v78;
                    v595[1] = --v139;
                    if (v139)
                    {
                      v78 *= 2;
                    }
                    else
                    {
                      int v140 = v595[0] + (v78 >> 26);
                      v595[0] = v140;
                      if (v140 < 255)
                      {
                        int v142 = v594++;
                        *int v142 = v140;
                        v595[0] = (v596[0] >> 19);
                        int v78 = v596[0] & 0x7FFFF;
                        v596[0] &= 0x7FFFFu;
                        int v139 = 8;
                      }
                      else
                      {
                        int v141 = v594++;
                        *int v141 = -1;
                        v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                        int v78 = v596[0] & 0xFFFFF;
                        v596[0] &= 0xFFFFFu;
                        int v139 = 7;
                      }
                      v595[1] = v139;
                    }
                    signed int v77 = v596[1];
                  }
                  while (v596[1] < 0x8000);
                }
                else
                {
                  int v78 = v596[0] + v137;
                  v596[0] += v137;
                }
                if ((v114 & 0x80000000) != 0)
                {
                  int v113 = v68[v561];
LABEL_252:
                  int v143 = v63[(v114 >> 26) & 0x1F];
                  unsigned int v144 = v69[1];
                  int v145 = sign_lut[(*(v69 - 1) >> 5) & 4 | (v71 >> 4) & 0x41 | (v144 >> 3) & 0x10 | (((*(v69 - 1) >> 5) & 0x80004 | (v71 >> 4) & 0x820041 | (v144 >> 3) & 0x200010) >> 16)];
                  uint64_t v146 = v145 >> 1;
                  int v147 = (int *)&v593[16 * v146];
                  unsigned int v148 = v113 & 0x80000000;
                  int v149 = *v147;
                  int v150 = v148 ^ (v145 << 31) ^ *v147;
                  int v151 = v77 - v150;
                  v596[1] = v151;
                  if (v151 < 0x8000)
                  {
                    if (v150 < 0)
                    {
                      int v150 = v151 & 0x7FFFFFFF;
                      v596[1] = v151 & 0x7FFFFFFF;
                      if ((v151 & 0x7FFFFFFFu) >= (v149 & 0x7FFFFFFFu))
                      {
                        v596[1] = v149 & 0x7FFFFFFF;
                        int v150 = v149 & 0x7FFFFFFF;
                      }
                      else
                      {
                        v78 += v149 & 0x7FFFFFFF;
                        v596[0] = v78;
                      }
                      int v152 = (_OWORD *)(*(void *)&v593[16 * v146 + 8] + 16);
                    }
                    else
                    {
                      if (v151 >= v150)
                      {
                        v78 += v150;
                        v596[0] = v78;
                        int v150 = v151;
                      }
                      else
                      {
                        v596[1] = v150;
                      }
                      int v152 = *(_OWORD **)&v593[16 * v146 + 8];
                    }
                    *(_OWORD *)int v147 = *v152;
                    if (v150 >= 0x8000) {
                      kd_block_encoder::encode();
                    }
                    int v153 = v595[1];
                    do
                    {
                      v596[1] = 2 * v150;
                      v596[0] = 2 * v78;
                      v595[1] = --v153;
                      if (v153)
                      {
                        v78 *= 2;
                      }
                      else
                      {
                        int v154 = v595[0] + (v78 >> 26);
                        v595[0] = v154;
                        if (v154 < 255)
                        {
                          int v156 = v594++;
                          *int v156 = v154;
                          v595[0] = (v596[0] >> 19);
                          int v78 = v596[0] & 0x7FFFF;
                          v596[0] &= 0x7FFFFu;
                          int v153 = 8;
                        }
                        else
                        {
                          v155 = v594++;
                          unsigned __int8 *v155 = -1;
                          v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                          int v78 = v596[0] & 0xFFFFF;
                          v596[0] &= 0xFFFFFu;
                          int v153 = 7;
                        }
                        v595[1] = v153;
                      }
                      int v150 = v596[1];
                    }
                    while (v596[1] < 0x8000);
                    unsigned int v144 = v69[1];
                  }
                  else
                  {
                    v596[0] = v150 + v78;
                  }
                  v64 += v143;
                  *(v69 - 1) |= 0x100u;
                  v69[1] = v144 | 0x40;
                  v71 |= (v148 >> 7) | 0x80;
                }
              }
              if ((v71 & 0xC000400) == 0)
              {
                uint64_t v157 = *(unsigned __int8 *)(v66 + ((v71 >> 6) & 0x1EFLL));
                int v158 = (int *)&v599[2 * v157];
                unsigned int v110 = v68[v591] << v65;
                int v159 = *v158;
                signed int v160 = v110 & 0x80000000 ^ *v158;
                signed int v77 = v596[1] - v160;
                v596[1] = v77;
                if (v77 < 0x8000)
                {
                  if (v160 < 0)
                  {
                    v77 &= ~0x80000000;
                    v596[1] = v77;
                    if (v77 >= (v159 & 0x7FFFFFFFu))
                    {
                      v596[1] = v159 & 0x7FFFFFFF;
                      signed int v77 = v159 & 0x7FFFFFFF;
                    }
                    else
                    {
                      v596[0] += v159 & 0x7FFFFFFF;
                    }
                    v161 = (_OWORD *)(v599[2 * v157 + 1] + 16);
                  }
                  else
                  {
                    if (v77 >= v160)
                    {
                      v596[0] += v160;
                    }
                    else
                    {
                      v596[1] = v110 & 0x80000000 ^ v159;
                      signed int v77 = v596[1];
                    }
                    v161 = (_OWORD *)v599[2 * v157 + 1];
                  }
                  *(_OWORD *)int v158 = *v161;
                  if (v77 >= 0x8000) {
                    kd_block_encoder::encode();
                  }
                  int v78 = v596[0];
                  int v162 = v595[1];
                  do
                  {
                    v596[1] = 2 * v77;
                    v596[0] = 2 * v78;
                    v595[1] = --v162;
                    if (v162)
                    {
                      v78 *= 2;
                    }
                    else
                    {
                      int v163 = v595[0] + (v78 >> 26);
                      v595[0] = v163;
                      if (v163 < 255)
                      {
                        int v165 = v594++;
                        *int v165 = v163;
                        v595[0] = (v596[0] >> 19);
                        int v78 = v596[0] & 0x7FFFF;
                        v596[0] &= 0x7FFFFu;
                        int v162 = 8;
                      }
                      else
                      {
                        v164 = v594++;
                        unsigned __int8 *v164 = -1;
                        v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                        int v78 = v596[0] & 0xFFFFF;
                        v596[0] &= 0xFFFFFu;
                        int v162 = 7;
                      }
                      v595[1] = v162;
                    }
                    signed int v77 = v596[1];
                  }
                  while (v596[1] < 0x8000);
                }
                else
                {
                  int v78 = v596[0] + v160;
                  v596[0] += v160;
                }
                if ((v110 & 0x80000000) != 0)
                {
                  int v109 = v68[v591];
LABEL_297:
                  int v166 = v63[(v110 >> 26) & 0x1F];
                  unsigned int v167 = v69[1];
                  int v168 = sign_lut[(*(v69 - 1) >> 8) & 4 | (v71 >> 7) & 0x41 | (v167 >> 6) & 0x10 | (((*(v69 - 1) >> 8) & 0x80004 | (v71 >> 7) & 0x820041 | (v167 >> 6) & 0x200010) >> 16)];
                  uint64_t v169 = v168 >> 1;
                  v170 = (int *)&v593[16 * v169];
                  unsigned int v171 = v109 & 0x80000000;
                  int v172 = *v170;
                  int v173 = v171 ^ (v168 << 31) ^ *v170;
                  int v174 = v77 - v173;
                  v596[1] = v174;
                  if (v174 < 0x8000)
                  {
                    if (v173 < 0)
                    {
                      int v173 = v174 & 0x7FFFFFFF;
                      v596[1] = v174 & 0x7FFFFFFF;
                      if ((v174 & 0x7FFFFFFFu) >= (v172 & 0x7FFFFFFFu))
                      {
                        v596[1] = v172 & 0x7FFFFFFF;
                        int v173 = v172 & 0x7FFFFFFF;
                      }
                      else
                      {
                        v78 += v172 & 0x7FFFFFFF;
                        v596[0] = v78;
                      }
                      v175 = (_OWORD *)(*(void *)&v593[16 * v169 + 8] + 16);
                    }
                    else
                    {
                      if (v174 >= v173)
                      {
                        v78 += v173;
                        v596[0] = v78;
                        int v173 = v174;
                      }
                      else
                      {
                        v596[1] = v173;
                      }
                      v175 = *(_OWORD **)&v593[16 * v169 + 8];
                    }
                    *(_OWORD *)v170 = *v175;
                    if (v173 >= 0x8000) {
                      kd_block_encoder::encode();
                    }
                    int v176 = v595[1];
                    do
                    {
                      v596[1] = 2 * v173;
                      v596[0] = 2 * v78;
                      v595[1] = --v176;
                      if (v176)
                      {
                        v78 *= 2;
                      }
                      else
                      {
                        int v177 = v595[0] + (v78 >> 26);
                        v595[0] = v177;
                        if (v177 < 255)
                        {
                          v179 = v594++;
                          unsigned __int8 *v179 = v177;
                          v595[0] = (v596[0] >> 19);
                          int v78 = v596[0] & 0x7FFFF;
                          v596[0] &= 0x7FFFFu;
                          int v176 = 8;
                        }
                        else
                        {
                          int v178 = v594++;
                          *int v178 = -1;
                          v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                          int v78 = v596[0] & 0xFFFFF;
                          v596[0] &= 0xFFFFFu;
                          int v176 = 7;
                        }
                        v595[1] = v176;
                      }
                      int v173 = v596[1];
                    }
                    while (v596[1] < 0x8000);
                    unsigned int v167 = v69[1];
                  }
                  else
                  {
                    v596[0] = v173 + v78;
                  }
                  v64 += v166;
                  *(v69 - 1) |= 0x800u;
                  v69[1] = v167 | 0x200;
                  v71 |= (v171 >> 4) | 0x400;
                }
              }
              if ((v71 & 0x60002000) == 0)
              {
                uint64_t v180 = *(unsigned __int8 *)(v66 + ((v71 >> 9) & 0x1EF));
                v181 = (int *)&v599[2 * v180];
                unsigned int v112 = v68[v592] << v65;
                int v182 = *v181;
                signed int v183 = v112 & 0x80000000 ^ *v181;
                signed int v77 = v596[1] - v183;
                v596[1] = v77;
                if (v77 < 0x8000)
                {
                  if (v183 < 0)
                  {
                    v77 &= ~0x80000000;
                    v596[1] = v77;
                    if (v77 >= (v182 & 0x7FFFFFFFu))
                    {
                      v596[1] = v182 & 0x7FFFFFFF;
                      signed int v77 = v182 & 0x7FFFFFFF;
                    }
                    else
                    {
                      v596[0] += v182 & 0x7FFFFFFF;
                    }
                    v184 = (_OWORD *)(v599[2 * v180 + 1] + 16);
                  }
                  else
                  {
                    if (v77 >= v183)
                    {
                      v596[0] += v183;
                    }
                    else
                    {
                      v596[1] = v112 & 0x80000000 ^ v182;
                      signed int v77 = v596[1];
                    }
                    v184 = (_OWORD *)v599[2 * v180 + 1];
                  }
                  *(_OWORD *)v181 = *v184;
                  if (v77 >= 0x8000) {
                    kd_block_encoder::encode();
                  }
                  int v78 = v596[0];
                  int v185 = v595[1];
                  do
                  {
                    v596[1] = 2 * v77;
                    v596[0] = 2 * v78;
                    v595[1] = --v185;
                    if (v185)
                    {
                      v78 *= 2;
                    }
                    else
                    {
                      int v186 = v595[0] + (v78 >> 26);
                      v595[0] = v186;
                      if (v186 < 255)
                      {
                        uint64_t v188 = v594++;
                        *uint64_t v188 = v186;
                        v595[0] = (v596[0] >> 19);
                        int v78 = v596[0] & 0x7FFFF;
                        v596[0] &= 0x7FFFFu;
                        int v185 = 8;
                      }
                      else
                      {
                        v187 = v594++;
                        unsigned __int8 *v187 = -1;
                        v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                        int v78 = v596[0] & 0xFFFFF;
                        v596[0] &= 0xFFFFFu;
                        int v185 = 7;
                      }
                      v595[1] = v185;
                    }
                    signed int v77 = v596[1];
                  }
                  while (v596[1] < 0x8000);
                }
                else
                {
                  int v78 = v596[0] + v183;
                  v596[0] += v183;
                }
                if ((v112 & 0x80000000) != 0)
                {
                  int v111 = v68[v592];
LABEL_342:
                  int v189 = v63[(v112 >> 26) & 0x1F];
                  int v190 = (v71 >> 10) & 0x20041;
                  if ((v71 & 0x80000000) != 0) {
                    v190 |= 0x800000u;
                  }
                  unsigned int v191 = (*(v69 - 1) >> 11) & 0x80004 | v190 | (v69[1] >> 9) & 0x200010;
                  int v192 = sign_lut[v191 & 0x55 | HIWORD(v191)];
                  uint64_t v193 = v192 >> 1;
                  v194 = (int *)&v593[16 * v193];
                  unsigned int v195 = v111 & 0x80000000;
                  int v196 = *v194;
                  int v197 = v195 ^ (v192 << 31) ^ *v194;
                  int v198 = v77 - v197;
                  v596[1] = v198;
                  if (v198 < 0x8000)
                  {
                    if (v197 < 0)
                    {
                      int v197 = v198 & 0x7FFFFFFF;
                      v596[1] = v198 & 0x7FFFFFFF;
                      if ((v198 & 0x7FFFFFFFu) >= (v196 & 0x7FFFFFFFu))
                      {
                        v596[1] = v196 & 0x7FFFFFFF;
                        int v197 = v196 & 0x7FFFFFFF;
                      }
                      else
                      {
                        v78 += v196 & 0x7FFFFFFF;
                        v596[0] = v78;
                      }
                      v199 = (_OWORD *)(*(void *)&v593[16 * v193 + 8] + 16);
                    }
                    else
                    {
                      if (v198 >= v197)
                      {
                        v78 += v197;
                        v596[0] = v78;
                        int v197 = v198;
                      }
                      else
                      {
                        v596[1] = v197;
                      }
                      v199 = *(_OWORD **)&v593[16 * v193 + 8];
                    }
                    *(_OWORD *)v194 = *v199;
                    if (v197 >= 0x8000) {
                      kd_block_encoder::encode();
                    }
                    int v200 = v595[1];
                    do
                    {
                      v596[1] = 2 * v197;
                      v596[0] = 2 * v78;
                      v595[1] = --v200;
                      if (v200)
                      {
                        v78 *= 2;
                      }
                      else
                      {
                        int v201 = v595[0] + (v78 >> 26);
                        v595[0] = v201;
                        if (v201 < 255)
                        {
                          __int32 v203 = v594++;
                          *__int32 v203 = v201;
                          v595[0] = (v596[0] >> 19);
                          int v78 = v596[0] & 0x7FFFF;
                          v596[0] &= 0x7FFFFu;
                          int v200 = 8;
                        }
                        else
                        {
                          unint64_t v202 = v594++;
                          *unint64_t v202 = -1;
                          v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                          int v78 = v596[0] & 0xFFFFF;
                          v596[0] &= 0xFFFFFu;
                          int v200 = 7;
                        }
                        v595[1] = v200;
                      }
                      int v197 = v596[1];
                    }
                    while (v596[1] < 0x8000);
                  }
                  else
                  {
                    v596[0] = v197 + v78;
                  }
                  v64 += v189;
                  v69[v589] |= 4u;
                  v69[v588] |= 1u;
                  *(v69 - 1) |= 0x4000u;
                  v69[1] |= 0x1000u;
                  BOOL v204 = v195 == 0;
                  if (v195) {
                    int v205 = 262146;
                  }
                  else {
                    int v205 = 2;
                  }
                  if (v204) {
                    int v206 = 0x2000;
                  }
                  else {
                    int v206 = 1073750016;
                  }
                  v69[v559] |= v205;
                  v71 |= v206;
                }
              }
              *uint64_t v69 = (v71 << 15) & 0x12480000 | v71 & 0xDB6FFFFF;
LABEL_372:
              ++v68;
              ++v69;
              BOOL v207 = __OFSUB__(v70--, 1);
              if ((v70 < 0) ^ v207 | (v70 == 0)) {
                goto LABEL_374;
              }
            }
          }
          int v64 = 0;
          goto LABEL_654;
        }
        *(void *)v596 = 0;
        v594 = 0;
        mq_encoder::check_out((uint64_t)&v597[64 * v581], &v596[1], v596, &v594);
        v504 = &refinement_distortion_lut;
        if (v58) {
          v504 = &refinement_distortion_lut_lossless;
        }
        int v64 = 0;
        if (v566 >= 1)
        {
          char v505 = 31 - v569;
          int v506 = v563;
          v507 = v560;
          v508 = v562;
          size_t v389 = v564;
          while (v585 < 1)
          {
LABEL_906:
            v508 += 3;
            v507 += v592;
            BOOL v207 = __OFSUB__(v506--, 1);
            if ((v506 < 0) ^ v207 | (v506 == 0)) {
              goto LABEL_914;
            }
          }
          int v509 = v585;
          while (2)
          {
            unsigned int v510 = *v508;
            if ((*v508 & 0x12480000) == 0)
            {
              if (!v508[2])
              {
                do
                {
                  v509 -= 2;
                  v507 += 2;
                  unsigned int v511 = v508[4];
                  v508 += 2;
                }
                while (!v511);
              }
              goto LABEL_904;
            }
            if ((v510 & 0x80000) != 0)
            {
              unsigned int v512 = *v507 << v505;
              int v513 = v504[v512 >> 26];
              int v514 = v596[1];
              int v515 = v596[0];
              if (!v596[1])
              {
                v516 = v594++;
                unsigned __int8 *v516 = v596[0];
                int v515 = 0;
                int v514 = 8 - ((v596[0] + 1) >> 8);
              }
              v64 += v513;
              v596[0] = __PAIR64__(v515, v512) >> 31;
              v596[1] = v514 - 1;
              if ((v510 & 0x400000) != 0) {
                goto LABEL_895;
              }
LABEL_886:
              if ((v510 & 0x2000000) == 0) {
                goto LABEL_887;
              }
LABEL_898:
              unsigned int v522 = v507[v591] << v505;
              int v523 = v504[v522 >> 26];
              int v524 = v596[1];
              int v525 = v596[0];
              if (!v596[1])
              {
                v526 = v594++;
                unsigned __int8 *v526 = v596[0];
                int v525 = 0;
                int v524 = 8 - ((v596[0] + 1) >> 8);
              }
              v64 += v523;
              v596[0] = __PAIR64__(v525, v522) >> 31;
              v596[1] = v524 - 1;
              if ((v510 & 0x10000000) == 0)
              {
LABEL_904:
                ++v507;
                ++v508;
                BOOL v207 = __OFSUB__(v509--, 1);
                if ((v509 < 0) ^ v207 | (v509 == 0)) {
                  goto LABEL_906;
                }
                continue;
              }
            }
            else
            {
              if ((v510 & 0x400000) == 0) {
                goto LABEL_886;
              }
LABEL_895:
              unsigned int v517 = v507[v561] << v505;
              int v518 = v504[v517 >> 26];
              int v519 = v596[1];
              int v520 = v596[0];
              if (!v596[1])
              {
                v521 = v594++;
                unsigned __int8 *v521 = v596[0];
                int v520 = 0;
                int v519 = 8 - ((v596[0] + 1) >> 8);
              }
              v64 += v518;
              v596[0] = __PAIR64__(v520, v517) >> 31;
              v596[1] = v519 - 1;
              if ((v510 & 0x2000000) != 0) {
                goto LABEL_898;
              }
LABEL_887:
              if ((v510 & 0x10000000) == 0) {
                goto LABEL_904;
              }
            }
            break;
          }
          unsigned int v527 = v507[v592] << v505;
          int v528 = v504[v527 >> 26];
          int v529 = v596[1];
          int v530 = v596[0];
          if (!v596[1])
          {
            v531 = v594++;
            unsigned __int8 *v531 = v596[0];
            int v530 = 0;
            int v529 = 8 - ((v596[0] + 1) >> 8);
          }
          v64 += v528;
          v596[0] = __PAIR64__(v530, v527) >> 31;
          v596[1] = v529 - 1;
          goto LABEL_904;
        }
        size_t v389 = v564;
LABEL_914:
        mq_encoder::check_in((uint64_t)&v597[64 * v581], v596[1], v596[0], v594);
      }
      else
      {
        *(void *)v595 = 0;
        *(void *)v596 = 0;
        v594 = 0;
        mq_encoder::check_out((uint64_t)&v597[64 * v581], &v596[1], v596, &v595[1], v595, &v594);
        v388 = &refinement_distortion_lut;
        if (v58) {
          v388 = &refinement_distortion_lut_lossless;
        }
        size_t v389 = v564;
        int v64 = 0;
        if (v566 >= 1)
        {
          char v390 = 31 - v569;
          int v391 = (-1 << (v569 + 2)) & 0x7FFFFFFF;
          int v392 = v563;
          v393 = v560;
          v394 = v562;
          do
          {
            if (v585 >= 1)
            {
              int v395 = v585;
              do
              {
                unsigned int v396 = *v394;
                if ((*v394 & 0x12480000) != 0)
                {
                  if ((v396 & 0x80000) != 0)
                  {
                    int v397 = *v393;
                    int v398 = *v394 & 0x1EF;
                    if ((v396 & 0x1EF) != 0) {
                      uint64_t v399 = 256;
                    }
                    else {
                      uint64_t v399 = 240;
                    }
                    if ((v396 & 0x1EF) != 0) {
                      v400 = &v603;
                    }
                    else {
                      v400 = &v602;
                    }
                    int v401 = v397 & v391;
                    if ((v397 & v391) != 0) {
                      uint64_t v402 = 272;
                    }
                    else {
                      uint64_t v402 = v399;
                    }
                    if ((v397 & v391) != 0) {
                      v403 = &v604;
                    }
                    else {
                      v403 = v400;
                    }
                    unsigned int v404 = v397 << v390;
                    v64 += v388[v404 >> 26];
                    int v405 = *(_DWORD *)((char *)v599 + v402);
                    int v406 = v404 & 0x80000000 ^ v405;
                    int v407 = v596[1] - v406;
                    v596[1] = v407;
                    if (v407 < 0x8000)
                    {
                      if (v406 < 0)
                      {
                        int v406 = v407 & 0x7FFFFFFF;
                        v596[1] = v407 & 0x7FFFFFFF;
                        if ((v407 & 0x7FFFFFFFu) >= (v405 & 0x7FFFFFFFu))
                        {
                          v596[1] = v405 & 0x7FFFFFFF;
                          int v406 = v405 & 0x7FFFFFFF;
                        }
                        else
                        {
                          v596[0] += v405 & 0x7FFFFFFF;
                        }
                        BOOL v204 = v398 == 0;
                        uint64_t v412 = 264;
                        if (v204) {
                          uint64_t v412 = 248;
                        }
                        BOOL v204 = v401 == 0;
                        uint64_t v413 = 280;
                        if (v204) {
                          uint64_t v413 = v412;
                        }
                        v411 = (long long *)(*(void *)((char *)v599 + v413) + 16);
                      }
                      else
                      {
                        if (v407 >= v406)
                        {
                          v596[0] += v406;
                          int v406 = v407;
                        }
                        else
                        {
                          v596[1] = v406;
                        }
                        BOOL v204 = v398 == 0;
                        uint64_t v409 = 264;
                        if (v204) {
                          uint64_t v409 = 248;
                        }
                        BOOL v204 = v401 == 0;
                        uint64_t v410 = 280;
                        if (v204) {
                          uint64_t v410 = v409;
                        }
                        v411 = *(long long **)((char *)v599 + v410);
                      }
                      long long *v403 = *v411;
                      if (v406 >= 0x8000) {
                        kd_block_encoder::encode();
                      }
                      int v414 = v596[0];
                      int v415 = v595[1];
                      do
                      {
                        v596[1] = 2 * v406;
                        v596[0] = 2 * v414;
                        v595[1] = --v415;
                        if (v415)
                        {
                          v414 *= 2;
                        }
                        else
                        {
                          int v416 = v595[0] + (v414 >> 26);
                          v595[0] = v416;
                          if (v416 < 255)
                          {
                            v418 = v594++;
                            unsigned __int8 *v418 = v416;
                            v595[0] = (v596[0] >> 19);
                            int v414 = v596[0] & 0x7FFFF;
                            v596[0] &= 0x7FFFFu;
                            int v415 = 8;
                          }
                          else
                          {
                            v417 = v594++;
                            unsigned __int8 *v417 = -1;
                            v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                            int v414 = v596[0] & 0xFFFFF;
                            v596[0] &= 0xFFFFFu;
                            int v415 = 7;
                          }
                          v595[1] = v415;
                        }
                        int v406 = v596[1];
                      }
                      while (v596[1] < 0x8000);
                    }
                    else
                    {
                      v596[0] += v406;
                    }
                  }
                  if ((v396 & 0x400000) != 0)
                  {
                    int v419 = v393[v561];
                    int v420 = v396 & 0xF78;
                    if ((v396 & 0xF78) != 0) {
                      uint64_t v421 = 256;
                    }
                    else {
                      uint64_t v421 = 240;
                    }
                    if ((v396 & 0xF78) != 0) {
                      v422 = &v603;
                    }
                    else {
                      v422 = &v602;
                    }
                    int v423 = v419 & v391;
                    if ((v419 & v391) != 0) {
                      uint64_t v424 = 272;
                    }
                    else {
                      uint64_t v424 = v421;
                    }
                    if ((v419 & v391) != 0) {
                      v425 = &v604;
                    }
                    else {
                      v425 = v422;
                    }
                    unsigned int v426 = v419 << v390;
                    v64 += v388[v426 >> 26];
                    int v427 = *(_DWORD *)((char *)v599 + v424);
                    int v428 = v426 & 0x80000000 ^ v427;
                    int v429 = v596[1] - v428;
                    v596[1] = v429;
                    if (v429 < 0x8000)
                    {
                      if (v428 < 0)
                      {
                        int v428 = v429 & 0x7FFFFFFF;
                        v596[1] = v429 & 0x7FFFFFFF;
                        if ((v429 & 0x7FFFFFFFu) >= (v427 & 0x7FFFFFFFu))
                        {
                          v596[1] = v427 & 0x7FFFFFFF;
                          int v428 = v427 & 0x7FFFFFFF;
                        }
                        else
                        {
                          v596[0] += v427 & 0x7FFFFFFF;
                        }
                        BOOL v204 = v420 == 0;
                        uint64_t v433 = 264;
                        if (v204) {
                          uint64_t v433 = 248;
                        }
                        BOOL v204 = v423 == 0;
                        uint64_t v434 = 280;
                        if (v204) {
                          uint64_t v434 = v433;
                        }
                        v432 = (long long *)(*(void *)((char *)v599 + v434) + 16);
                      }
                      else
                      {
                        if (v429 >= v428)
                        {
                          v596[0] += v428;
                          int v428 = v429;
                        }
                        else
                        {
                          v596[1] = v428;
                        }
                        BOOL v204 = v420 == 0;
                        uint64_t v430 = 264;
                        if (v204) {
                          uint64_t v430 = 248;
                        }
                        BOOL v204 = v423 == 0;
                        uint64_t v431 = 280;
                        if (v204) {
                          uint64_t v431 = v430;
                        }
                        v432 = *(long long **)((char *)v599 + v431);
                      }
                      long long *v425 = *v432;
                      if (v428 >= 0x8000) {
                        kd_block_encoder::encode();
                      }
                      int v435 = v596[0];
                      int v436 = v595[1];
                      do
                      {
                        v596[1] = 2 * v428;
                        v596[0] = 2 * v435;
                        v595[1] = --v436;
                        if (v436)
                        {
                          v435 *= 2;
                        }
                        else
                        {
                          int v437 = v595[0] + (v435 >> 26);
                          v595[0] = v437;
                          if (v437 < 255)
                          {
                            v439 = v594++;
                            unsigned __int8 *v439 = v437;
                            v595[0] = (v596[0] >> 19);
                            int v435 = v596[0] & 0x7FFFF;
                            v596[0] &= 0x7FFFFu;
                            int v436 = 8;
                          }
                          else
                          {
                            v438 = v594++;
                            unsigned __int8 *v438 = -1;
                            v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                            int v435 = v596[0] & 0xFFFFF;
                            v596[0] &= 0xFFFFFu;
                            int v436 = 7;
                          }
                          v595[1] = v436;
                        }
                        int v428 = v596[1];
                      }
                      while (v596[1] < 0x8000);
                    }
                    else
                    {
                      v596[0] += v428;
                    }
                  }
                  if ((v396 & 0x2000000) != 0)
                  {
                    int v440 = v393[v591];
                    int v441 = v396 & 0x7BC0;
                    if ((v396 & 0x7BC0) != 0) {
                      uint64_t v442 = 256;
                    }
                    else {
                      uint64_t v442 = 240;
                    }
                    if ((v396 & 0x7BC0) != 0) {
                      v443 = &v603;
                    }
                    else {
                      v443 = &v602;
                    }
                    int v444 = v440 & v391;
                    if ((v440 & v391) != 0) {
                      uint64_t v445 = 272;
                    }
                    else {
                      uint64_t v445 = v442;
                    }
                    if ((v440 & v391) != 0) {
                      v446 = &v604;
                    }
                    else {
                      v446 = v443;
                    }
                    unsigned int v447 = v440 << v390;
                    v64 += v388[v447 >> 26];
                    int v448 = *(_DWORD *)((char *)v599 + v445);
                    int v449 = v447 & 0x80000000 ^ v448;
                    int v450 = v596[1] - v449;
                    v596[1] = v450;
                    if (v450 < 0x8000)
                    {
                      if (v449 < 0)
                      {
                        int v449 = v450 & 0x7FFFFFFF;
                        v596[1] = v450 & 0x7FFFFFFF;
                        if ((v450 & 0x7FFFFFFFu) >= (v448 & 0x7FFFFFFFu))
                        {
                          v596[1] = v448 & 0x7FFFFFFF;
                          int v449 = v448 & 0x7FFFFFFF;
                        }
                        else
                        {
                          v596[0] += v448 & 0x7FFFFFFF;
                        }
                        BOOL v204 = v441 == 0;
                        uint64_t v454 = 264;
                        if (v204) {
                          uint64_t v454 = 248;
                        }
                        BOOL v204 = v444 == 0;
                        uint64_t v455 = 280;
                        if (v204) {
                          uint64_t v455 = v454;
                        }
                        v453 = (long long *)(*(void *)((char *)v599 + v455) + 16);
                      }
                      else
                      {
                        if (v450 >= v449)
                        {
                          v596[0] += v449;
                          int v449 = v450;
                        }
                        else
                        {
                          v596[1] = v449;
                        }
                        BOOL v204 = v441 == 0;
                        uint64_t v451 = 264;
                        if (v204) {
                          uint64_t v451 = 248;
                        }
                        BOOL v204 = v444 == 0;
                        uint64_t v452 = 280;
                        if (v204) {
                          uint64_t v452 = v451;
                        }
                        v453 = *(long long **)((char *)v599 + v452);
                      }
                      long long *v446 = *v453;
                      if (v449 >= 0x8000) {
                        kd_block_encoder::encode();
                      }
                      int v456 = v596[0];
                      int v457 = v595[1];
                      do
                      {
                        v596[1] = 2 * v449;
                        v596[0] = 2 * v456;
                        v595[1] = --v457;
                        if (v457)
                        {
                          v456 *= 2;
                        }
                        else
                        {
                          int v458 = v595[0] + (v456 >> 26);
                          v595[0] = v458;
                          if (v458 < 255)
                          {
                            v460 = v594++;
                            unsigned __int8 *v460 = v458;
                            v595[0] = (v596[0] >> 19);
                            int v456 = v596[0] & 0x7FFFF;
                            v596[0] &= 0x7FFFFu;
                            int v457 = 8;
                          }
                          else
                          {
                            v459 = v594++;
                            unsigned __int8 *v459 = -1;
                            v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                            int v456 = v596[0] & 0xFFFFF;
                            v596[0] &= 0xFFFFFu;
                            int v457 = 7;
                          }
                          v595[1] = v457;
                        }
                        int v449 = v596[1];
                      }
                      while (v596[1] < 0x8000);
                    }
                    else
                    {
                      v596[0] += v449;
                    }
                  }
                  if ((v396 & 0x10000000) != 0)
                  {
                    int v461 = v393[v592];
                    int v463 = v396 & 0x3DE00;
                    BOOL v462 = (v396 & 0x3DE00) == 0;
                    if ((v396 & 0x3DE00) != 0) {
                      uint64_t v464 = 32;
                    }
                    else {
                      uint64_t v464 = 30;
                    }
                    if (v462) {
                      v465 = &v602;
                    }
                    else {
                      v465 = &v603;
                    }
                    int v466 = v461 & v391;
                    if ((v461 & v391) != 0)
                    {
                      uint64_t v464 = 34;
                      v465 = &v604;
                    }
                    unsigned int v467 = v461 << v390;
                    v64 += v388[v467 >> 26];
                    int v468 = v599[v464];
                    int v469 = v467 & 0x80000000 ^ v468;
                    int v470 = v596[1] - v469;
                    v596[1] = v470;
                    if (v470 < 0x8000)
                    {
                      if (v469 < 0)
                      {
                        int v469 = v470 & 0x7FFFFFFF;
                        v596[1] = v470 & 0x7FFFFFFF;
                        if ((v470 & 0x7FFFFFFFu) >= (v468 & 0x7FFFFFFFu))
                        {
                          v596[1] = v468 & 0x7FFFFFFF;
                          int v469 = v468 & 0x7FFFFFFF;
                        }
                        else
                        {
                          v596[0] += v468 & 0x7FFFFFFF;
                        }
                        BOOL v204 = v463 == 0;
                        uint64_t v474 = 264;
                        if (v204) {
                          uint64_t v474 = 248;
                        }
                        BOOL v204 = v466 == 0;
                        uint64_t v475 = 280;
                        if (v204) {
                          uint64_t v475 = v474;
                        }
                        v473 = (long long *)(*(void *)((char *)v599 + v475) + 16);
                      }
                      else
                      {
                        if (v470 >= v469)
                        {
                          v596[0] += v469;
                          int v469 = v470;
                        }
                        else
                        {
                          v596[1] = v469;
                        }
                        BOOL v204 = v463 == 0;
                        uint64_t v471 = 264;
                        if (v204) {
                          uint64_t v471 = 248;
                        }
                        BOOL v204 = v466 == 0;
                        uint64_t v472 = 280;
                        if (v204) {
                          uint64_t v472 = v471;
                        }
                        v473 = *(long long **)((char *)v599 + v472);
                      }
                      long long *v465 = *v473;
                      if (v469 >= 0x8000) {
                        kd_block_encoder::encode();
                      }
                      int v476 = v596[0];
                      int v477 = v595[1];
                      do
                      {
                        v596[1] = 2 * v469;
                        v596[0] = 2 * v476;
                        v595[1] = --v477;
                        if (v477)
                        {
                          v476 *= 2;
                        }
                        else
                        {
                          int v478 = v595[0] + (v476 >> 26);
                          v595[0] = v478;
                          if (v478 < 255)
                          {
                            v480 = v594++;
                            unsigned __int8 *v480 = v478;
                            v595[0] = (v596[0] >> 19);
                            int v476 = v596[0] & 0x7FFFF;
                            v596[0] &= 0x7FFFFu;
                            int v477 = 8;
                          }
                          else
                          {
                            v479 = v594++;
                            unsigned __int8 *v479 = -1;
                            v595[0] = ((v595[0] >> 1) | 0x7F) & (v596[0] >> 20);
                            int v476 = v596[0] & 0xFFFFF;
                            v596[0] &= 0xFFFFFu;
                            int v477 = 7;
                          }
                          v595[1] = v477;
                        }
                        int v469 = v596[1];
                      }
                      while (v596[1] < 0x8000);
                    }
                    else
                    {
                      v596[0] += v469;
                    }
                  }
                }
                else if (!v394[2])
                {
                  do
                  {
                    v395 -= 2;
                    v393 += 2;
                    unsigned int v408 = v394[4];
                    v394 += 2;
                  }
                  while (!v408);
                }
                ++v393;
                ++v394;
                BOOL v207 = __OFSUB__(v395--, 1);
              }
              while (!((v395 < 0) ^ v207 | (v395 == 0)));
            }
            v394 += 3;
            v393 += v592;
            BOOL v207 = __OFSUB__(v392--, 1);
          }
          while (!((v392 < 0) ^ v207 | (v392 == 0)));
        }
        mq_encoder::check_in((uint64_t)&v597[64 * v581], v596[1], v596[0], v595[1], v595[0], v594);
      }
LABEL_833:
      int64_t v481 = v581;
      *(double *)&v605[v581] = v36 * (double)v64;
      if ((*((unsigned char *)v587 + 28) & 0x20) != 0 && v571 == 2)
      {
        mq_encoder::mq_encode_run((mq_encoder *)&v597[64 * v581], 2);
        mq_encoder::mq_encode_run((mq_encoder *)&v597[64 * v581], 2);
        int64_t v481 = v581;
      }
      int v482 = v580 - 1;
      v483 = (mq_encoder *)&v597[64 * v481];
      int bytes_used = mq_encoder::get_bytes_used(v483);
      if (v580 == 1)
      {
        v485 = mq_encoder::terminate(v483, (v590 & 0x10) == 0);
        int v41 = 0;
        int v572 = v45 + v568 - v485;
        v568 = v485;
      }
      else
      {
        int v41 = bytes_used;
      }
      LOBYTE(v594) = 0;
      if (v581 >= v40)
      {
        v486 = (mq_encoder *)&v597[64 * (uint64_t)v40];
        uint64_t v487 = 4 * v40;
        int v488 = v40;
        do
        {
          *(_DWORD *)(*((void *)v587 + 7) + v487) = mq_encoder::get_incremental_length(v486, (BOOL *)&v594);
          if ((_BYTE)v594)
          {
            if (v488 != v40) {
              kd_block_encoder::encode();
            }
            ++v40;
          }
          ++v488;
          v486 = (mq_encoder *)((char *)v486 + 64);
          v487 += 4;
        }
        while (v586 != v488);
      }
      clock_t v32 = (clock_t)v587;
      if (v7 > 0.0)
      {
        int v489 = 0;
        double v490 = 0.0;
        int v491 = 3;
        double v492 = 0.0;
        double v493 = 0.0;
        int v494 = v581;
        double v495 = 0.0;
        while (1)
        {
          if (v494 <= 6) {
            int v496 = 6;
          }
          else {
            int v496 = v494;
          }
          int v497 = v496 - 7;
          if (v494 > v497)
          {
            int v498 = 0;
            double v499 = 0.0;
            double v500 = 0.0;
            do
            {
              double v499 = v499 + (double)*(int *)(*((void *)v587 + 7) + 4 * (v494 + v498));
              double v500 = v500 + *(double *)&v605[v494 + v498];
              if (!v498 || v492 * v499 > v490 * v500)
              {
                double v492 = v500;
                double v490 = v499;
              }
              --v498;
            }
            while (v494 + v498 > v497);
          }
          double v501 = v7 * v490;
          if ((v581 - v494) >= 3)
          {
            int v502 = v491;
            do
            {
              double v501 = v501 * 3.0;
              v502 -= 3;
            }
            while (v502 > 5);
          }
          if (v492 > v501) {
            break;
          }
          if (v492 > 0.0 && v490 > 0.0 && (v489 < 1 || v493 * v492 > v495 * v490))
          {
            ++v489;
            double v495 = v492;
            double v493 = v490;
          }
          BOOL v207 = __OFSUB__(v494--, 1);
          if (v494 < 0 == v207)
          {
            ++v491;
            if (v489 < 3) {
              continue;
            }
          }
          if (v489 < 2) {
            break;
          }
          if ((int)v581 - v494 < 3) {
            break;
          }
          int64_t v503 = v581 + 1;
          *((_DWORD *)v587 + 12) = v581 + 1;
          if (v580 < 2) {
            break;
          }
          mq_encoder::terminate(v483, (v590 & 0x10) == 0);
          if (v581 >= v40)
          {
            v532 = (mq_encoder *)&v597[64 * (uint64_t)v40];
            uint64_t v533 = 4 * v40;
            do
            {
              LOBYTE(v594) = 0;
              *(_DWORD *)(*((void *)v587 + 7) + v533) = mq_encoder::get_incremental_length(v532, (BOOL *)&v594);
              if (!(_BYTE)v594) {
                kd_block_encoder::encode();
              }
              v532 = (mq_encoder *)((char *)v532 + 64);
              v533 += 4;
              ++v40;
            }
            while (v586 != v40);
            int v40 = v586;
          }
          goto LABEL_873;
        }
      }
      int64_t v503 = v581 + 1;
      --v580;
      if (!v482)
      {
LABEL_873:
        if (v503 != v40) {
          kd_block_encoder::encode();
        }
        mq_encoder::finish((uint64_t)v483);
        clock_t v32 = (clock_t)v587;
        int v580 = 0;
      }
      int v42 = v571 + 1;
      int64_t v38 = *(int *)(v32 + 48);
      ++v586;
      unint64_t v39 = v503;
      int v569 = v570;
    }
    while (v503 < v38);
    size_t v26 = v389;
    if (v580) {
      kd_block_encoder::encode();
    }
LABEL_918:
    if (v40 != v38) {
      kd_block_encoder::encode();
    }
    if (v5 > 0.0 && v40 >= 1)
    {
      uint64_t v534 = 0;
      uint64_t v536 = *(void *)(v32 + 56);
      uint64_t v535 = *(void *)(v32 + 64);
      do
      {
        int v537 = v534 - 9;
        if (v534 < 9) {
          int v537 = 0;
        }
        double v538 = -1.0;
        double v539 = 0.0;
        uint64_t v540 = v534;
        double v541 = 0.0;
        do
        {
          double v539 = v539 + *(double *)&v605[v540];
          if (v539 <= 0.0) {
            goto LABEL_937;
          }
          double v541 = v541 + (double)*(int *)(v536 + 4 * v540);
          if (v541 > 0.0 && (v538 < 0.0 || v538 * v541 > v539)) {
            double v538 = v539 / v541;
          }
          BOOL v20 = v540-- <= v537;
        }
        while (!v20);
        if (v538 <= 0.0)
        {
LABEL_937:
          LOWORD(v544) = 0;
          goto LABEL_938;
        }
        double v542 = v538 * 2.32830644e-10;
        if (v542 > 1.0) {
          double v542 = 1.0;
        }
        double v543 = log(v542) * 369.32993 + 65536.0;
        if (v543 <= 65535.0)
        {
          clock_t v32 = (clock_t)v587;
          if (v543 >= 2.0) {
            int v544 = (int)v543;
          }
          else {
            LOWORD(v544) = 2;
          }
        }
        else
        {
          LOWORD(v544) = -1;
          clock_t v32 = (clock_t)v587;
        }
LABEL_938:
        *(_WORD *)(v535 + 2 * v534++) = v544;
      }
      while (v534 != v40);
      uint64_t v545 = 0;
      v546 = (unsigned __int16 *)(v535 + 2);
      uint64_t v547 = 1;
      do
      {
        uint64_t v548 = v545 + 1;
        if (v545 + 1 < (unint64_t)v40)
        {
          v549 = v546;
          uint64_t v550 = v40;
          while (1)
          {
            unsigned int v551 = *v549++;
            if (v551 >= *(unsigned __int16 *)(v535 + 2 * v545)) {
              break;
            }
            if (v547 == --v550) {
              goto LABEL_949;
            }
          }
          *(_WORD *)(v535 + 2 * v545) = 0;
        }
LABEL_949:
        ++v547;
        ++v546;
        ++v545;
      }
      while (v548 != v40);
      if (v40 == v554 && v565 && !*(_WORD *)(v535 + 2 * v553)) {
        *(_WORD *)(v535 + 2 * v553) = 1;
      }
    }
    BOOL v20 = v558-- <= 1;
    float v23 = v556;
    int v27 = v566 & 3;
  }
  while (!v20);
  return kdu_block::finish_timing(v32);
}

uint64_t mq_encoder::augment_buffer(uint64_t this, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t v3 = *(void *)(this + 16);
  if (v3)
  {
    if (!a3 || !a2 || *(unsigned char *)(this + 33)) {
      mq_encoder::augment_buffer();
    }
    int64_t v4 = *(void *)(this + 24) + a3 - a2;
    *(void *)(this + 16) = v3 + a3 - a2;
    *(void *)(this + 24) = v4;
  }
  return this;
}

__n128 mq_encoder::continues(mq_encoder *this, mq_encoder *a2)
{
  if (*((unsigned char *)this + 35) || *((void *)this + 2)) {
    mq_encoder::continues();
  }
  if (!*((unsigned char *)a2 + 35)) {
    mq_encoder::continues();
  }
  if (*((unsigned char *)a2 + 33)) {
    mq_encoder::continues();
  }
  __n128 result = *(__n128 *)a2;
  long long v3 = *((_OWORD *)a2 + 1);
  long long v4 = *((_OWORD *)a2 + 2);
  *(_OWORD *)((char *)this + 41) = *(_OWORD *)((char *)a2 + 41);
  *((_OWORD *)this + 1) = v3;
  *((_OWORD *)this + 2) = v4;
  *(__n128 *)this = result;
  *((void *)this + 5) = a2;
  *((void *)a2 + 6) = this;
  *((unsigned char *)a2 + 35) = 0;
  return result;
}

uint64_t mq_encoder::get_bytes_used(mq_encoder *this)
{
  if (*((unsigned char *)this + 33) || (uint64_t v1 = *((void *)this + 2)) == 0) {
    mq_encoder::get_bytes_used();
  }
  return (*((_DWORD *)this + 6) - v1);
}

uint64_t mq_encoder::get_incremental_length(mq_encoder *this, BOOL *a2)
{
  if (*((unsigned char *)this + 36))
  {
    char v4 = 1;
  }
  else
  {
    double v5 = this;
    do
    {
      int v6 = v5;
      double v5 = (mq_encoder *)*((void *)v5 + 6);
    }
    while (v5);
    uint64_t v7 = (uint64_t)v6;
    do
    {
      if (*(unsigned char *)(v7 + 36)) {
        break;
      }
      if (!*(unsigned char *)(v7 + 35))
      {
        BOOL v8 = (unsigned __int8 *)*((void *)v6 + 3);
        if ((uint64_t)&v8[-*(void *)(v7 + 24)] >= 5) {
          mq_encoder::find_truncation_point(v7, v8);
        }
      }
      uint64_t v7 = *(void *)(v7 + 40);
    }
    while (v7);
    char v4 = *((unsigned char *)this + 36);
  }
  *a2 = v4;
  uint64_t v9 = *((void *)this + 5);
  if (v9) {
    uint64_t v10 = (_DWORD *)(v9 + 24);
  }
  else {
    uint64_t v10 = (_DWORD *)((char *)this + 16);
  }
  return (*((_DWORD *)this + 6) - *v10);
}

uint64_t mq_encoder::finish(uint64_t this)
{
  if (*(unsigned char *)(this + 35) || *(void *)(this + 48)) {
    mq_encoder::finish();
  }
  do
  {
    if (*(unsigned char *)(this + 35)) {
      mq_encoder::finish();
    }
    uint64_t v1 = *(void *)(this + 40);
    *(unsigned char *)(this + 36) = 0;
    *(void *)(this + 16) = 0;
    *(void *)(this + 24) = 0;
    *(void *)(this + 40) = 0;
    *(void *)(this + 48) = 0;
    this = v1;
  }
  while (v1);
  return this;
}

clock_t kdu_block::finish_timing(clock_t this)
{
  if (*(_DWORD *)(this + 136))
  {
    uint64_t v1 = (int *)this;
    this = clock();
    uint64_t v2 = *((void *)v1 + 18);
    *((void *)v1 + 20) += this - *((void *)v1 + 19);
    *((void *)v1 + 18) = v2 + *v1 * (uint64_t)v1[1];
  }
  return this;
}

void kd_block_encoder::~kd_block_encoder(kd_block_encoder *this)
{
  *(void *)this = &unk_1ED4E5548;
}

{
  *(void *)this = &unk_1ED4E5548;
  JUMPOUT(0x18C11C0E0);
}

uint64_t mq_encoder::check_out(uint64_t this, int *a2, int *a3, int *a4, int *a5, unsigned __int8 **a6)
{
  if (!*(unsigned char *)(this + 35) || *(unsigned char *)(this + 33) || !*(unsigned char *)(this + 34)) {
    mq_encoder::check_out();
  }
  *(unsigned char *)(this + 33) = 1;
  *a2 = *(_DWORD *)this;
  *a3 = *(_DWORD *)(this + 4);
  *a4 = *(_DWORD *)(this + 8);
  *a5 = *(_DWORD *)(this + 12);
  *a6 = *(unsigned __int8 **)(this + 24);
  return this;
}

uint64_t mq_encoder::check_in(uint64_t this, int a2, int a3, int a4, int a5, unsigned __int8 *a6)
{
  if (!*(unsigned char *)(this + 35) || !*(unsigned char *)(this + 33) || !*(unsigned char *)(this + 34)) {
    mq_encoder::check_in();
  }
  *(unsigned char *)(this + 33) = 0;
  *(_DWORD *)this = a2;
  *(_DWORD *)(this + 4) = a3;
  *(_DWORD *)(this + 8) = a4;
  *(_DWORD *)(this + 12) = a5;
  *(void *)(this + 24) = a6;
  return this;
}

uint64_t mq_encoder::check_out(uint64_t this, int *a2, int *a3, unsigned __int8 **a4)
{
  if (!*(unsigned char *)(this + 35) || *(unsigned char *)(this + 33) || *(unsigned char *)(this + 34)) {
    mq_encoder::check_out();
  }
  *(unsigned char *)(this + 33) = 1;
  *a2 = *(_DWORD *)(this + 8);
  *a3 = *(_DWORD *)(this + 12);
  *a4 = *(unsigned __int8 **)(this + 24);
  return this;
}

uint64_t mq_encoder::check_in(uint64_t this, int a2, int a3, unsigned __int8 *a4)
{
  if (!*(unsigned char *)(this + 35) || !*(unsigned char *)(this + 33) || *(unsigned char *)(this + 34)) {
    mq_encoder::check_in();
  }
  *(unsigned char *)(this + 33) = 0;
  *(_DWORD *)(this + 8) = a2;
  *(_DWORD *)(this + 12) = a3;
  *(void *)(this + 24) = a4;
  return this;
}

void kdu_block_decoder::kdu_block_decoder(kdu_block_decoder *this)
{
}

clock_t kd_block_decoder::decode(kd_block_decoder *this, kdu_block *a2)
{
  uint64_t v2 = a2;
  uint64_t v621 = *MEMORY[0x1E4F143B8];
  int v3 = *((_DWORD *)a2 + 1);
  int v589 = *(_DWORD *)a2;
  signed int v4 = ((*(_DWORD *)a2 + 3) & 0xFFFFFFFC) * v3;
  int v5 = v3 + 3;
  int v585 = (*(_DWORD *)a2 + 3) >> 2;
  int v6 = (v585 + 2) * (v3 + 3);
  int v606 = v3;
  if (*((_DWORD *)a2 + 28) < v4)
  {
    if (v4 <= 4096) {
      int v7 = 4096;
    }
    else {
      int v7 = ((*(_DWORD *)a2 + 3) & 0xFFFFFFFC) * v3;
    }
    kdu_block::set_max_samples((uint64_t)v2, v7);
    int v3 = v606;
    uint64_t v2 = a2;
  }
  if (*((_DWORD *)v2 + 29) <= v6)
  {
    if (v6 <= 1599) {
      int v8 = 1599;
    }
    else {
      int v8 = v6;
    }
    kdu_block::set_max_contexts((uint64_t)v2, v8 + 1);
    int v3 = v606;
    uint64_t v2 = a2;
  }
  uint64_t v607 = v3;
  if (*((_DWORD *)v2 + 34))
  {
    uint64_t v9 = v2;
    clock_t v10 = clock();
    int v3 = v606;
    *((void *)v9 + 19) = v10;
    int v11 = *((_DWORD *)v9 + 34);
  }
  else
  {
    int v11 = 1;
  }
  int v578 = v11;
  long long v613 = 0u;
  long long v614 = 0u;
  long long v612 = 0u;
  long long v619 = 0u;
  long long v620 = 0u;
  uint64_t v601 = v5;
  long long v618 = 0u;
  size_t v576 = 4 * v5 * v585 + 4;
  size_t v577 = 4 * v4;
  uint64_t v574 = (v585 - 1) * v5;
  memset(v617, 0, sizeof(v617));
  long long v616 = 0u;
  uint64_t v592 = -3 - v3;
  uint64_t v593 = -4 - v3;
  uint64_t v591 = -2 - v3;
  uint64_t v600 = v3 + 2;
  uint64_t v599 = v3 + 4;
  uint64_t v12 = 4 * v5;
  uint64_t v575 = 4 * v607 + v12 + 12;
  memset(v615, 0, sizeof(v615));
  int32x2_t v13 = vdup_n_s32(0x49200000u);
  int v579 = v589 & 3;
  unsigned int v603 = v3 + 1;
  uint64_t v14 = (char *)&mq_decoder::transition_table;
  uint64_t v15 = a2;
  uint64_t v604 = v12;
  while (2)
  {
    int v16 = v14;
LABEL_16:
    int v586 = (char *)*((void *)v15 + 12);
    uint64_t v17 = v15;
    bzero(v586, v577);
    uint64_t v18 = *((void *)v17 + 13);
    int v19 = (char *)(v18 + 4 * v601);
    v587 = (unsigned int *)(v19 + 4);
    bzero(v19, v576);
    int v20 = v606;
    if ((v589 & 3) != 0)
    {
      if (v579 == 2) {
        int v21 = 1207959552;
      }
      else {
        int v21 = 0x40000000;
      }
      if (v579 == 1) {
        int v21 = 1224736768;
      }
      if (v606 >= 1)
      {
        int v22 = (int *)&v587[v574];
        unsigned int v23 = v603;
        do
        {
          *v22++ = v21;
          --v23;
        }
        while (v23 > 1);
      }
    }
    uint64_t v14 = v16;
    if (v589 >= 1)
    {
      clock_t v24 = (int32x2_t *)(v18 + v575);
      int v25 = v585 + 1;
      do
      {
        v24->i32[0] = 1226833920;
        v24[-1] = v13;
        --v25;
        clock_t v24 = (int32x2_t *)((char *)v24 + v12);
      }
      while (v25 > 1);
    }
    uint64_t v15 = a2;
    int v26 = *((_DWORD *)a2 + 11);
    int v27 = *((_DWORD *)a2 + 10) - v26;
    if (v27 < 1) {
      return kdu_block::finish_timing((clock_t)v15);
    }
    int v28 = 30 - v26;
    LODWORD(v29) = 3 * (30 - v26) - 2;
    int v30 = *((_DWORD *)a2 + 12);
    if ((int)v29 >= v30) {
      uint64_t v29 = v30;
    }
    else {
      uint64_t v29 = v29;
    }
    uint64_t v594 = v29;
    int v608 = *((_DWORD *)a2 + 7);
    if ((v608 & 0x10) != 0)
    {
      if (*((unsigned char *)a2 + 37)) {
        BOOL v31 = 1;
      }
      else {
        BOOL v31 = *((unsigned char *)a2 + 36) != 0;
      }
      BOOL v583 = v31;
    }
    else
    {
      BOOL v583 = 0;
    }
    if ((int)v594 >= 1)
    {
      uint64_t v597 = 0;
      unint64_t v32 = 0;
      BOOL v596 = 0;
      BOOL v588 = 0;
      int v33 = 0;
      int v584 = 0;
      int v582 = 3 * v27 - 2;
      int v590 = (unsigned __int8 *)*((void *)a2 + 9);
      int v34 = 2;
      do
      {
        char v35 = v28 - 1;
        if (v34 == 3) {
          int v36 = v28 - 1;
        }
        else {
          int v36 = v28;
        }
        if (v34 == 3) {
          int v37 = 0;
        }
        else {
          int v37 = v34;
        }
        int v602 = v37;
        unint64_t v605 = v32;
        if (v33)
        {
          if (v32) {
            goto LABEL_74;
          }
        }
        else
        {
          int v38 = *((_DWORD *)v15 + 7);
          if (v38)
          {
            if (v602 == 2) {
              int v40 = 1;
            }
            else {
              int v40 = 2;
            }
            if (v32 <= 9) {
              int v40 = 10 - v32;
            }
            BOOL v41 = v596;
            if (v32 > 9) {
              BOOL v41 = v602 != 2;
            }
            BOOL v596 = v41;
            int v39 = v582;
          }
          else
          {
            int v39 = v582;
            int v40 = v582;
          }
          if ((v38 & 4) != 0) {
            LODWORD(v42) = 1;
          }
          else {
            LODWORD(v42) = v40;
          }
          BOOL v43 = (int)v42 + (int)v32 > (int)v594;
          if ((int)v42 + (int)v32 <= (int)v594) {
            unint64_t v42 = v42;
          }
          else {
            unint64_t v42 = (v594 - v32);
          }
          unint64_t v44 = v42;
          BOOL v45 = (int)v594 < v39 && v43;
          BOOL v588 = v45;
          int v46 = v36;
          if ((int)v44 < 1)
          {
            int v48 = 0;
          }
          else
          {
            unint64_t v47 = 0;
            int v48 = 0;
            do
              v48 += *(_DWORD *)(*((void *)v15 + 7) + v597 + 4 * v47++);
            while (v47 < v44);
          }
          int v49 = v44;
          mq_decoder::start((uint64_t)&v612, v590, v48, !v596);
          v590 += v48;
          int v584 = v605;
          uint64_t v15 = a2;
          int v20 = v606;
          uint64_t v14 = v16;
          int v33 = v49;
          int v36 = v46;
          if (v605)
          {
LABEL_74:
            if ((*((unsigned char *)v15 + 28) & 2) == 0) {
              goto LABEL_78;
            }
          }
        }
        uint64_t v50 = 0;
        int v51 = mq_decoder::p_bar_table[0] << 8;
        do
        {
          int v52 = &v615[v50];
          *(_DWORD *)int v52 = v51;
          *((void *)v52 + 1) = v14;
          ++v50;
        }
        while (v50 != 18);
        LODWORD(v615[0]) = unk_1E90FD1A4 << 8;
        *((void *)&v615[0] + 1) = v14 + 256;
        LODWORD(v616) = dword_1E90FD1A0 << 8;
        *((void *)&v616 + 1) = v14 + 192;
LABEL_78:
        int v595 = v33;
        if (v34 == 3 && !v596)
        {
          if (!BYTE6(v614) || BYTE4(v614) || !BYTE5(v614)) {
            kd_block_decoder::decode();
          }
          uint64_t v251 = *((int *)v15 + 8);
          BYTE4(v614) = 1;
          if (SDWORD1(v612) >= (int)v612 - 0x800000) {
            signed int v252 = v612 - 0x800000;
          }
          else {
            signed int v252 = DWORD1(v612);
          }
          int v253 = v612 - v252;
          int v254 = DWORD1(v612) - v252;
          int v255 = DWORD2(v612);
          unsigned int v256 = HIDWORD(v612);
          v257 = (unsigned __int8 *)*((void *)&v613 + 1);
          int v258 = v614;
          if (v589 < 1) {
            goto LABEL_1473;
          }
          uint64_t v259 = (uint64_t)*(&significance_luts + v251);
          int v260 = (1 << v36) + (1 << v36 >> 1);
          int v261 = v585;
          v262 = v586;
          unsigned int v263 = v587;
          while (v20 < 1)
          {
LABEL_1036:
            v263 += 3;
            v262 += 3 * v607;
            BOOL v250 = __OFSUB__(v261--, 1);
            int v20 = v606;
            if ((v261 < 0) ^ v250 | (v261 == 0)) {
              goto LABEL_1473;
            }
          }
          int v264 = v20;
          while (2)
          {
            unsigned int v265 = *v263;
            if (!*v263)
            {
              if (!v263[3])
              {
                do
                {
                  v264 -= 3;
                  v262 += 3;
                  unsigned int v275 = v263[6];
                  v263 += 3;
                }
                while (!v275);
              }
              goto LABEL_1034;
            }
            if ((v265 & 0x1EF) == 0 || (v265 & 0x200010) != 0) {
              goto LABEL_743;
            }
            uint64_t v267 = *(unsigned __int8 *)(v259 + (v265 & 0x1EF));
            int v268 = &v615[v267];
            int v269 = *v268 & 1;
            signed int v252 = v252 - *v268 + v269;
            if (v252 < 0)
            {
              v253 += v252;
              v254 += v252;
              signed int v252 = *v268 & 0xFFFFFFFE;
              if (v254 < 0)
              {
                if (v253 >= v252)
                {
                  int v269 = !(*(unsigned char *)v268 & 1);
                  signed int v277 = (_OWORD *)(*((void *)&v615[v267] + 1) + 16);
                }
                else
                {
                  signed int v277 = (_OWORD *)*((void *)&v615[v267] + 1);
                }
                v254 += v252;
                *(_OWORD *)int v268 = *v277;
                if (v252 >= 0x800000)
                {
LABEL_1471:
                  int v253 = v252;
LABEL_1472:
                  int v20 = v606;
LABEL_1473:
                  BYTE4(v614) = 0;
                  LODWORD(v612) = v253 + v252;
                  DWORD1(v612) = v254 + v252;
                  *((void *)&v612 + 1) = __PAIR64__(v256, v255);
                  *((void *)&v613 + 1) = v257;
                  LODWORD(v614) = v258;
                  uint64_t v14 = v16;
                  goto LABEL_1587;
                }
              }
              else
              {
                if (v253 >= 0x800000) {
                  goto LABEL_1472;
                }
                if (v253 >= v252)
                {
                  signed int v276 = (_OWORD *)*((void *)&v615[v267] + 1);
                }
                else
                {
                  int v269 = !(*(unsigned char *)v268 & 1);
                  signed int v276 = (_OWORD *)(*((void *)&v615[v267] + 1) + 16);
                }
                *(_OWORD *)int v268 = *v276;
                signed int v252 = v253;
              }
              int v279 = v258;
              do
              {
                if (!v255)
                {
                  int v281 = v257 + 1;
                  unsigned int v280 = *v257;
                  unsigned int v282 = v254 + v280;
                  if (v280 >= 0x90) {
                    int v283 = 255;
                  }
                  else {
                    int v283 = *v257;
                  }
                  if (v280 >= 0x90)
                  {
                    int v284 = v279 + 1;
                  }
                  else
                  {
                    ++v257;
                    int v284 = v258;
                  }
                  if (v280 < 0x90) {
                    int v285 = v279;
                  }
                  else {
                    int v285 = v279 + 1;
                  }
                  if (v280 < 0x90)
                  {
                    int v286 = 7;
                  }
                  else
                  {
                    unsigned int v282 = v254;
                    int v286 = 8;
                  }
                  BOOL v287 = v256 == 255;
                  if (v256 == 255) {
                    unsigned int v256 = v283;
                  }
                  else {
                    unsigned int v256 = v280;
                  }
                  if (v287) {
                    int v258 = v284;
                  }
                  else {
                    v257 = v281;
                  }
                  if (v287) {
                    int v279 = v285;
                  }
                  if (v287) {
                    int v254 = v282;
                  }
                  if (v287) {
                    int v255 = v286;
                  }
                  else {
                    int v255 = 8;
                  }
                  v254 += v256;
                }
                int v288 = 2 * v252;
                v254 *= 2;
                --v255;
                BOOL v91 = v252 < 0x400000;
                v252 *= 2;
              }
              while (v91);
              signed int v252 = v288 - 0x800000;
              if (v254 < v288 - 0x800000) {
                signed int v252 = v254;
              }
              int v253 = v288 - v252;
              v254 -= v252;
              if (v269) {
                goto LABEL_647;
              }
            }
            else if (v269)
            {
LABEL_647:
              unint64_t v270 = sign_lut[(*(v263 - 1) >> 2) & 4 | (v265 >> 1) & 0x41 | v263[1] & 0x10 | (((*(v263 - 1) >> 2) & 0x80004 | (v265 >> 1) & 0x820041 | v263[1] & 0x200010) >> 16)];
              unint64_t v271 = v270 >> 1;
              uint64_t v272 = &v617[v270 >> 1];
              int v273 = *v272 & 1;
              signed int v252 = v252 - *v272 + v273;
              if (v252 < 0)
              {
                v253 += v252;
                v254 += v252;
                signed int v252 = *v272 & 0xFFFFFFFE;
                if (v254 < 0)
                {
                  if (v253 >= v252)
                  {
                    int v273 = !(*(unsigned char *)v272 & 1);
                    int v278 = (_OWORD *)(*((void *)&v617[v271] + 1) + 16);
                  }
                  else
                  {
                    int v278 = (_OWORD *)*((void *)&v617[v271] + 1);
                  }
                  v254 += v252;
                  *(_OWORD *)uint64_t v272 = *v278;
                  if (v252 >= 0x800000) {
                    goto LABEL_1471;
                  }
                }
                else
                {
                  if (v253 >= 0x800000) {
                    goto LABEL_1472;
                  }
                  if (v253 >= v252)
                  {
                    unsigned int v274 = (_OWORD *)*((void *)&v617[v271] + 1);
                  }
                  else
                  {
                    int v273 = !(*(unsigned char *)v272 & 1);
                    unsigned int v274 = (_OWORD *)(*((void *)&v617[v271] + 1) + 16);
                  }
                  *(_OWORD *)uint64_t v272 = *v274;
                  signed int v252 = v253;
                }
                int v289 = v258;
                do
                {
                  if (!v255)
                  {
                    int v291 = v257 + 1;
                    unsigned int v290 = *v257;
                    unsigned int v292 = v254 + v290;
                    if (v290 >= 0x90) {
                      int v293 = 255;
                    }
                    else {
                      int v293 = *v257;
                    }
                    if (v290 >= 0x90)
                    {
                      int v294 = v289 + 1;
                    }
                    else
                    {
                      ++v257;
                      int v294 = v258;
                    }
                    if (v290 < 0x90) {
                      int v295 = v289;
                    }
                    else {
                      int v295 = v289 + 1;
                    }
                    if (v290 < 0x90)
                    {
                      int v296 = 7;
                    }
                    else
                    {
                      unsigned int v292 = v254;
                      int v296 = 8;
                    }
                    BOOL v297 = v256 == 255;
                    if (v256 == 255) {
                      unsigned int v256 = v293;
                    }
                    else {
                      unsigned int v256 = v290;
                    }
                    if (v297) {
                      int v258 = v294;
                    }
                    else {
                      v257 = v291;
                    }
                    if (v297) {
                      int v289 = v295;
                    }
                    if (v297) {
                      int v254 = v292;
                    }
                    if (v297) {
                      int v255 = v296;
                    }
                    else {
                      int v255 = 8;
                    }
                    v254 += v256;
                  }
                  int v298 = 2 * v252;
                  v254 *= 2;
                  --v255;
                  BOOL v91 = v252 < 0x400000;
                  v252 *= 2;
                }
                while (v91);
                signed int v252 = v298 - 0x800000;
                if (v254 < v298 - 0x800000) {
                  signed int v252 = v254;
                }
                int v253 = v298 - v252;
                v254 -= v252;
              }
              int v299 = v273 ^ v270 & 1;
              if ((v608 & 8) == 0)
              {
                v263[v593] |= 0x20000u;
                v263[v592] |= (v299 << 31) | 0x10000;
                v263[v591] |= 0x8000u;
              }
              *(v263 - 1) |= 0x20u;
              v263[1] |= 8u;
              v265 |= (v299 << 21) | 0x100010;
              _DWORD *v262 = (v299 << 31) + v260;
LABEL_743:
              if ((v265 & 0xF78) == 0 || (v265 & 0x1000080) != 0)
              {
LABEL_841:
                if ((v265 & 0x7BC0) != 0 && (v265 & 0x8000400) == 0)
                {
                  uint64_t v335 = *(unsigned __int8 *)(v259 + ((v265 >> 6) & 0x1EFLL));
                  int v336 = &v615[v335];
                  int v337 = *v336 & 1;
                  signed int v252 = v252 - *v336 + v337;
                  if (v252 < 0)
                  {
                    v253 += v252;
                    v254 += v252;
                    signed int v252 = *v336 & 0xFFFFFFFE;
                    if (v254 < 0)
                    {
                      if (v253 >= v252)
                      {
                        int v337 = !(*(unsigned char *)v336 & 1);
                        int v346 = (_OWORD *)(*((void *)&v615[v335] + 1) + 16);
                      }
                      else
                      {
                        int v346 = (_OWORD *)*((void *)&v615[v335] + 1);
                      }
                      v254 += v252;
                      *(_OWORD *)int v336 = *v346;
                      if (v252 >= 0x800000) {
                        goto LABEL_1471;
                      }
                    }
                    else
                    {
                      if (v253 >= 0x800000) {
                        goto LABEL_1472;
                      }
                      if (v253 >= v252)
                      {
                        int v345 = (_OWORD *)*((void *)&v615[v335] + 1);
                      }
                      else
                      {
                        int v337 = !(*(unsigned char *)v336 & 1);
                        int v345 = (_OWORD *)(*((void *)&v615[v335] + 1) + 16);
                      }
                      *(_OWORD *)int v336 = *v345;
                      signed int v252 = v253;
                    }
                    int v348 = v258;
                    do
                    {
                      if (!v255)
                      {
                        v350 = v257 + 1;
                        unsigned int v349 = *v257;
                        unsigned int v351 = v254 + v349;
                        if (v349 >= 0x90) {
                          int v352 = 255;
                        }
                        else {
                          int v352 = *v257;
                        }
                        if (v349 >= 0x90)
                        {
                          int v353 = v348 + 1;
                        }
                        else
                        {
                          ++v257;
                          int v353 = v258;
                        }
                        if (v349 < 0x90) {
                          int v354 = v348;
                        }
                        else {
                          int v354 = v348 + 1;
                        }
                        if (v349 < 0x90)
                        {
                          int v355 = 7;
                        }
                        else
                        {
                          unsigned int v351 = v254;
                          int v355 = 8;
                        }
                        BOOL v356 = v256 == 255;
                        if (v256 == 255) {
                          unsigned int v256 = v352;
                        }
                        else {
                          unsigned int v256 = v349;
                        }
                        if (v356) {
                          int v258 = v353;
                        }
                        else {
                          v257 = v350;
                        }
                        if (v356) {
                          int v348 = v354;
                        }
                        if (v356) {
                          int v254 = v351;
                        }
                        if (v356) {
                          int v255 = v355;
                        }
                        else {
                          int v255 = 8;
                        }
                        v254 += v256;
                      }
                      int v357 = 2 * v252;
                      v254 *= 2;
                      --v255;
                      BOOL v91 = v252 < 0x400000;
                      v252 *= 2;
                    }
                    while (v91);
                    signed int v252 = v357 - 0x800000;
                    if (v254 < v357 - 0x800000) {
                      signed int v252 = v254;
                    }
                    int v253 = v357 - v252;
                    v254 -= v252;
                    if (!v337) {
                      goto LABEL_896;
                    }
LABEL_845:
                    unsigned int v338 = *(v263 - 1);
                    unsigned int v339 = v263[1];
                    unint64_t v340 = sign_lut[(v338 >> 8) & 4 | (v265 >> 7) & 0x41 | (v339 >> 6) & 0x10 | (((v338 >> 8) & 0x80004 | (v265 >> 7) & 0x820041 | (v339 >> 6) & 0x200010) >> 16)];
                    unint64_t v341 = v340 >> 1;
                    v342 = &v617[v340 >> 1];
                    int v343 = *v342 & 1;
                    signed int v252 = v252 - *v342 + v343;
                    if (v252 < 0)
                    {
                      v253 += v252;
                      v254 += v252;
                      signed int v252 = *v342 & 0xFFFFFFFE;
                      if (v254 < 0)
                      {
                        if (v253 >= v252)
                        {
                          int v343 = !(*(unsigned char *)v342 & 1);
                          unsigned int v347 = (_OWORD *)(*((void *)&v617[v341] + 1) + 16);
                        }
                        else
                        {
                          unsigned int v347 = (_OWORD *)*((void *)&v617[v341] + 1);
                        }
                        v254 += v252;
                        *(_OWORD *)v342 = *v347;
                        if (v252 >= 0x800000) {
                          goto LABEL_1471;
                        }
                      }
                      else
                      {
                        if (v253 >= 0x800000) {
                          goto LABEL_1472;
                        }
                        if (v253 >= v252)
                        {
                          int v344 = (_OWORD *)*((void *)&v617[v341] + 1);
                        }
                        else
                        {
                          int v343 = !(*(unsigned char *)v342 & 1);
                          int v344 = (_OWORD *)(*((void *)&v617[v341] + 1) + 16);
                        }
                        *(_OWORD *)v342 = *v344;
                        signed int v252 = v253;
                      }
                      int v358 = v258;
                      do
                      {
                        if (!v255)
                        {
                          unsigned int v360 = v257 + 1;
                          unsigned int v359 = *v257;
                          unsigned int v361 = v254 + v359;
                          if (v359 >= 0x90) {
                            int v362 = 255;
                          }
                          else {
                            int v362 = *v257;
                          }
                          if (v359 >= 0x90)
                          {
                            int v363 = v358 + 1;
                          }
                          else
                          {
                            ++v257;
                            int v363 = v258;
                          }
                          if (v359 < 0x90) {
                            int v364 = v358;
                          }
                          else {
                            int v364 = v358 + 1;
                          }
                          if (v359 < 0x90)
                          {
                            int v365 = 7;
                          }
                          else
                          {
                            unsigned int v361 = v254;
                            int v365 = 8;
                          }
                          BOOL v366 = v256 == 255;
                          if (v256 == 255) {
                            unsigned int v256 = v362;
                          }
                          else {
                            unsigned int v256 = v359;
                          }
                          if (v366) {
                            int v258 = v363;
                          }
                          else {
                            v257 = v360;
                          }
                          if (v366) {
                            int v358 = v364;
                          }
                          if (v366) {
                            int v254 = v361;
                          }
                          if (v366) {
                            int v255 = v365;
                          }
                          else {
                            int v255 = 8;
                          }
                          v254 += v256;
                        }
                        int v367 = 2 * v252;
                        v254 *= 2;
                        --v255;
                        BOOL v91 = v252 < 0x400000;
                        v252 *= 2;
                      }
                      while (v91);
                      signed int v252 = v367 - 0x800000;
                      if (v254 < v367 - 0x800000) {
                        signed int v252 = v254;
                      }
                      int v253 = v367 - v252;
                      v254 -= v252;
                      unsigned int v339 = v263[1];
                      unsigned int v338 = *(v263 - 1);
                    }
                    int v368 = v343 ^ v340 & 1;
                    *(v263 - 1) = v338 | 0x800;
                    v263[1] = v339 | 0x200;
                    v265 |= (v368 << 27) | 0x4000400;
                    v262[2 * v607] = v260 + (v368 << 31);
                  }
                  else
                  {
                    if (v337) {
                      goto LABEL_845;
                    }
LABEL_896:
                    v265 |= 0x4000000u;
                  }
                }
                if ((v265 & 0x3DE00) != 0 && (v265 & 0x40002000) == 0)
                {
                  uint64_t v369 = *(unsigned __int8 *)(v259 + ((v265 >> 9) & 0x1EFLL));
                  unint64_t v370 = &v615[v369];
                  int v371 = *v370 & 1;
                  signed int v252 = v252 - *v370 + v371;
                  if (v252 < 0)
                  {
                    v253 += v252;
                    v254 += v252;
                    signed int v252 = *v370 & 0xFFFFFFFE;
                    if (v254 < 0)
                    {
                      if (v253 >= v252)
                      {
                        int v371 = !(*(unsigned char *)v370 & 1);
                        unsigned int v380 = (_OWORD *)(*((void *)&v615[v369] + 1) + 16);
                      }
                      else
                      {
                        unsigned int v380 = (_OWORD *)*((void *)&v615[v369] + 1);
                      }
                      v254 += v252;
                      *(_OWORD *)unint64_t v370 = *v380;
                      if (v252 >= 0x800000) {
                        goto LABEL_1471;
                      }
                    }
                    else
                    {
                      if (v253 >= 0x800000) {
                        goto LABEL_1472;
                      }
                      if (v253 >= v252)
                      {
                        v379 = (_OWORD *)*((void *)&v615[v369] + 1);
                      }
                      else
                      {
                        int v371 = !(*(unsigned char *)v370 & 1);
                        v379 = (_OWORD *)(*((void *)&v615[v369] + 1) + 16);
                      }
                      *(_OWORD *)unint64_t v370 = *v379;
                      signed int v252 = v253;
                    }
                    int v382 = v258;
                    do
                    {
                      if (!v255)
                      {
                        int v384 = v257 + 1;
                        unsigned int v383 = *v257;
                        unsigned int v385 = v254 + v383;
                        if (v383 >= 0x90) {
                          int v386 = 255;
                        }
                        else {
                          int v386 = *v257;
                        }
                        if (v383 >= 0x90)
                        {
                          int v387 = v382 + 1;
                        }
                        else
                        {
                          ++v257;
                          int v387 = v258;
                        }
                        if (v383 < 0x90) {
                          int v388 = v382;
                        }
                        else {
                          int v388 = v382 + 1;
                        }
                        if (v383 < 0x90)
                        {
                          int v389 = 7;
                        }
                        else
                        {
                          unsigned int v385 = v254;
                          int v389 = 8;
                        }
                        BOOL v390 = v256 == 255;
                        if (v256 == 255) {
                          unsigned int v256 = v386;
                        }
                        else {
                          unsigned int v256 = v383;
                        }
                        if (v390) {
                          int v258 = v387;
                        }
                        else {
                          v257 = v384;
                        }
                        if (v390) {
                          int v382 = v388;
                        }
                        if (v390) {
                          int v254 = v385;
                        }
                        if (v390) {
                          int v255 = v389;
                        }
                        else {
                          int v255 = 8;
                        }
                        v254 += v256;
                      }
                      int v391 = 2 * v252;
                      v254 *= 2;
                      --v255;
                      BOOL v91 = v252 < 0x400000;
                      v252 *= 2;
                    }
                    while (v91);
                    signed int v252 = v391 - 0x800000;
                    if (v254 < v391 - 0x800000) {
                      signed int v252 = v254;
                    }
                    int v253 = v391 - v252;
                    v254 -= v252;
                    if (!v371) {
                      goto LABEL_993;
                    }
LABEL_940:
                    int v372 = (v265 >> 10) & 0x20041;
                    if ((v265 & 0x80000000) != 0) {
                      v372 |= 0x800000u;
                    }
                    unsigned int v373 = (*(v263 - 1) >> 11) & 0x80004 | v372 | (v263[1] >> 9) & 0x200010;
                    unint64_t v374 = sign_lut[v373 & 0x55 | HIWORD(v373)];
                    unint64_t v375 = v374 >> 1;
                    int v376 = &v617[v374 >> 1];
                    int v377 = *v376 & 1;
                    signed int v252 = v252 - *v376 + v377;
                    if (v252 < 0)
                    {
                      v253 += v252;
                      v254 += v252;
                      signed int v252 = *v376 & 0xFFFFFFFE;
                      if (v254 < 0)
                      {
                        if (v253 >= v252)
                        {
                          int v377 = !(*(unsigned char *)v376 & 1);
                          int v381 = (_OWORD *)(*((void *)&v617[v375] + 1) + 16);
                        }
                        else
                        {
                          int v381 = (_OWORD *)*((void *)&v617[v375] + 1);
                        }
                        v254 += v252;
                        *(_OWORD *)int v376 = *v381;
                        if (v252 >= 0x800000) {
                          goto LABEL_1471;
                        }
                      }
                      else
                      {
                        if (v253 >= 0x800000) {
                          goto LABEL_1472;
                        }
                        if (v253 >= v252)
                        {
                          int v378 = (_OWORD *)*((void *)&v617[v375] + 1);
                        }
                        else
                        {
                          int v377 = !(*(unsigned char *)v376 & 1);
                          int v378 = (_OWORD *)(*((void *)&v617[v375] + 1) + 16);
                        }
                        *(_OWORD *)int v376 = *v378;
                        signed int v252 = v253;
                      }
                      int v392 = v258;
                      do
                      {
                        if (!v255)
                        {
                          v394 = v257 + 1;
                          unsigned int v393 = *v257;
                          unsigned int v395 = v254 + v393;
                          if (v393 >= 0x90) {
                            int v396 = 255;
                          }
                          else {
                            int v396 = *v257;
                          }
                          if (v393 >= 0x90)
                          {
                            int v397 = v392 + 1;
                          }
                          else
                          {
                            ++v257;
                            int v397 = v258;
                          }
                          if (v393 < 0x90) {
                            int v398 = v392;
                          }
                          else {
                            int v398 = v392 + 1;
                          }
                          if (v393 < 0x90)
                          {
                            int v399 = 7;
                          }
                          else
                          {
                            unsigned int v395 = v254;
                            int v399 = 8;
                          }
                          BOOL v400 = v256 == 255;
                          if (v256 == 255) {
                            unsigned int v256 = v396;
                          }
                          else {
                            unsigned int v256 = v393;
                          }
                          if (v400) {
                            int v258 = v397;
                          }
                          else {
                            v257 = v394;
                          }
                          if (v400) {
                            int v392 = v398;
                          }
                          if (v400) {
                            int v254 = v395;
                          }
                          if (v400) {
                            int v255 = v399;
                          }
                          else {
                            int v255 = 8;
                          }
                          v254 += v256;
                        }
                        int v401 = 2 * v252;
                        v254 *= 2;
                        --v255;
                        BOOL v91 = v252 < 0x400000;
                        v252 *= 2;
                      }
                      while (v91);
                      signed int v252 = v401 - 0x800000;
                      if (v254 < v401 - 0x800000) {
                        signed int v252 = v254;
                      }
                      int v253 = v401 - v252;
                      v254 -= v252;
                    }
                    int v402 = v377 ^ v374 & 1;
                    v263[v600] |= 4u;
                    v263[v601] |= (v402 << 18) | 2;
                    v263[v599] |= 1u;
                    *(v263 - 1) |= 0x4000u;
                    v263[1] |= 0x1000u;
                    v265 |= (v402 << 30) | 0x20002000;
                    v262[3 * v607] = v260 + (v402 << 31);
                  }
                  else
                  {
                    if (v371) {
                      goto LABEL_940;
                    }
LABEL_993:
                    v265 |= 0x20000000u;
                  }
                }
                *unsigned int v263 = v265;
LABEL_1034:
                ++v262;
                ++v263;
                BOOL v250 = __OFSUB__(v264--, 1);
                if ((v264 < 0) ^ v250 | (v264 == 0)) {
                  goto LABEL_1036;
                }
                continue;
              }
              uint64_t v301 = *(unsigned __int8 *)(v259 + ((v265 >> 3) & 0x1EFLL));
              signed int v302 = &v615[v301];
              int v303 = *v302 & 1;
              signed int v252 = v252 - *v302 + v303;
              if (v252 < 0)
              {
                v253 += v252;
                v254 += v252;
                signed int v252 = *v302 & 0xFFFFFFFE;
                if (v254 < 0)
                {
                  if (v253 >= v252)
                  {
                    int v303 = !(*(unsigned char *)v302 & 1);
                    unsigned int v312 = (_OWORD *)(*((void *)&v615[v301] + 1) + 16);
                  }
                  else
                  {
                    unsigned int v312 = (_OWORD *)*((void *)&v615[v301] + 1);
                  }
                  v254 += v252;
                  *(_OWORD *)signed int v302 = *v312;
                  if (v252 >= 0x800000) {
                    goto LABEL_1471;
                  }
                }
                else
                {
                  if (v253 >= 0x800000) {
                    goto LABEL_1472;
                  }
                  if (v253 >= v252)
                  {
                    int v311 = (_OWORD *)*((void *)&v615[v301] + 1);
                  }
                  else
                  {
                    int v303 = !(*(unsigned char *)v302 & 1);
                    int v311 = (_OWORD *)(*((void *)&v615[v301] + 1) + 16);
                  }
                  *(_OWORD *)signed int v302 = *v311;
                  signed int v252 = v253;
                }
                int v314 = v258;
                do
                {
                  if (!v255)
                  {
                    unsigned int v316 = v257 + 1;
                    unsigned int v315 = *v257;
                    unsigned int v317 = v254 + v315;
                    if (v315 >= 0x90) {
                      int v318 = 255;
                    }
                    else {
                      int v318 = *v257;
                    }
                    if (v315 >= 0x90)
                    {
                      int v319 = v314 + 1;
                    }
                    else
                    {
                      ++v257;
                      int v319 = v258;
                    }
                    if (v315 < 0x90) {
                      int v320 = v314;
                    }
                    else {
                      int v320 = v314 + 1;
                    }
                    if (v315 < 0x90)
                    {
                      int v321 = 7;
                    }
                    else
                    {
                      unsigned int v317 = v254;
                      int v321 = 8;
                    }
                    BOOL v322 = v256 == 255;
                    if (v256 == 255) {
                      unsigned int v256 = v318;
                    }
                    else {
                      unsigned int v256 = v315;
                    }
                    if (v322) {
                      int v258 = v319;
                    }
                    else {
                      v257 = v316;
                    }
                    if (v322) {
                      int v314 = v320;
                    }
                    if (v322) {
                      int v254 = v317;
                    }
                    if (v322) {
                      int v255 = v321;
                    }
                    else {
                      int v255 = 8;
                    }
                    v254 += v256;
                  }
                  int v323 = 2 * v252;
                  v254 *= 2;
                  --v255;
                  BOOL v91 = v252 < 0x400000;
                  v252 *= 2;
                }
                while (v91);
                signed int v252 = v323 - 0x800000;
                if (v254 < v323 - 0x800000) {
                  signed int v252 = v254;
                }
                int v253 = v323 - v252;
                v254 -= v252;
                if (v303) {
                  goto LABEL_750;
                }
              }
              else if (v303)
              {
LABEL_750:
                unsigned int v304 = *(v263 - 1);
                unsigned int v305 = v263[1];
                unint64_t v306 = sign_lut[(v304 >> 5) & 4 | (v265 >> 4) & 0x41 | (v305 >> 3) & 0x10 | (((v304 >> 5) & 0x80004 | (v265 >> 4) & 0x820041 | (v305 >> 3) & 0x200010) >> 16)];
                unint64_t v307 = v306 >> 1;
                v308 = &v617[v306 >> 1];
                int v309 = *v308 & 1;
                signed int v252 = v252 - *v308 + v309;
                if (v252 < 0)
                {
                  v253 += v252;
                  v254 += v252;
                  signed int v252 = *v308 & 0xFFFFFFFE;
                  if (v254 < 0)
                  {
                    if (v253 >= v252)
                    {
                      int v309 = !(*(unsigned char *)v308 & 1);
                      int v313 = (_OWORD *)(*((void *)&v617[v307] + 1) + 16);
                    }
                    else
                    {
                      int v313 = (_OWORD *)*((void *)&v617[v307] + 1);
                    }
                    v254 += v252;
                    *(_OWORD *)v308 = *v313;
                    if (v252 >= 0x800000) {
                      goto LABEL_1471;
                    }
                  }
                  else
                  {
                    if (v253 >= 0x800000) {
                      goto LABEL_1472;
                    }
                    if (v253 >= v252)
                    {
                      int v310 = (_OWORD *)*((void *)&v617[v307] + 1);
                    }
                    else
                    {
                      int v309 = !(*(unsigned char *)v308 & 1);
                      int v310 = (_OWORD *)(*((void *)&v617[v307] + 1) + 16);
                    }
                    *(_OWORD *)v308 = *v310;
                    signed int v252 = v253;
                  }
                  int v324 = v258;
                  do
                  {
                    if (!v255)
                    {
                      v326 = v257 + 1;
                      unsigned int v325 = *v257;
                      unsigned int v327 = v254 + v325;
                      if (v325 >= 0x90) {
                        int v328 = 255;
                      }
                      else {
                        int v328 = *v257;
                      }
                      if (v325 >= 0x90)
                      {
                        int v329 = v324 + 1;
                      }
                      else
                      {
                        ++v257;
                        int v329 = v258;
                      }
                      if (v325 < 0x90) {
                        int v330 = v324;
                      }
                      else {
                        int v330 = v324 + 1;
                      }
                      if (v325 < 0x90)
                      {
                        int v331 = 7;
                      }
                      else
                      {
                        unsigned int v327 = v254;
                        int v331 = 8;
                      }
                      BOOL v332 = v256 == 255;
                      if (v256 == 255) {
                        unsigned int v256 = v328;
                      }
                      else {
                        unsigned int v256 = v325;
                      }
                      if (v332) {
                        int v258 = v329;
                      }
                      else {
                        v257 = v326;
                      }
                      if (v332) {
                        int v324 = v330;
                      }
                      if (v332) {
                        int v254 = v327;
                      }
                      if (v332) {
                        int v255 = v331;
                      }
                      else {
                        int v255 = 8;
                      }
                      v254 += v256;
                    }
                    int v333 = 2 * v252;
                    v254 *= 2;
                    --v255;
                    BOOL v91 = v252 < 0x400000;
                    v252 *= 2;
                  }
                  while (v91);
                  signed int v252 = v333 - 0x800000;
                  if (v254 < v333 - 0x800000) {
                    signed int v252 = v254;
                  }
                  int v253 = v333 - v252;
                  v254 -= v252;
                  unsigned int v305 = v263[1];
                  unsigned int v304 = *(v263 - 1);
                }
                int v334 = v309 ^ v306 & 1;
                *(v263 - 1) = v304 | 0x100;
                v263[1] = v305 | 0x40;
                v265 |= (v334 << 24) | 0x800080;
                v262[v607] = v260 + (v334 << 31);
                goto LABEL_841;
              }
              v265 |= 0x800000u;
              goto LABEL_841;
            }
            break;
          }
          v265 |= 0x100000u;
          goto LABEL_743;
        }
        if (v34 == 3)
        {
          if (!BYTE6(v614) || BYTE4(v614) | BYTE5(v614)) {
            kd_block_decoder::decode();
          }
          BYTE4(v614) = 1;
          int v403 = DWORD2(v612);
          uint64_t v404 = HIDWORD(v612);
          int v405 = (unsigned __int8 *)*((void *)&v613 + 1);
          if (v589 < 1) {
            goto LABEL_1176;
          }
          int v406 = (1 << v35) + (1 << v35 >> 1);
          int v407 = v585;
          unsigned int v408 = v586;
          uint64_t v409 = v587;
LABEL_1043:
          if (v20 < 1) {
            goto LABEL_1174;
          }
          uint64_t v410 = 0;
          unsigned int v411 = v603;
          uint64_t v412 = v405;
          while (1)
          {
            unsigned int v413 = v409[v410];
            if (v413) {
              break;
            }
LABEL_1172:
            ++v410;
            if ((int)--v411 <= 1)
            {
              v408 += v410 * 4;
              uint64_t v409 = (unsigned int *)((char *)v409 + v410 * 4);
              int v20 = v606;
LABEL_1174:
              v409 += 3;
              v408 += 12 * v607;
              BOOL v250 = __OFSUB__(v407--, 1);
              if (!((v407 < 0) ^ v250 | (v407 == 0))) {
                goto LABEL_1043;
              }
LABEL_1176:
              BYTE4(v614) = 0;
              *((void *)&v612 + 1) = __PAIR64__(v404, v403);
              *((void *)&v613 + 1) = v405;
              goto LABEL_1587;
            }
          }
          if ((v413 & 0x1EF) == 0 || (v413 & 0x200010) != 0)
          {
            uint64_t v415 = v404;
            goto LABEL_1086;
          }
          if (v403)
          {
            uint64_t v415 = v404;
            goto LABEL_1059;
          }
          int v405 = v412 + 1;
          uint64_t v415 = *v412;
          if (v404 == 255)
          {
            if (v415 >= 0x90)
            {
              int v403 = 8;
              uint64_t v415 = 255;
              int v405 = v412;
              goto LABEL_1059;
            }
            int v403 = 7;
          }
          else
          {
            int v403 = 8;
          }
          ++v412;
LABEL_1059:
          if ((v415 >> --v403))
          {
            if (!v403)
            {
              unsigned int v416 = *v412;
              if (v416 >= 0x90) {
                unsigned int v417 = 255;
              }
              else {
                unsigned int v417 = *v412;
              }
              if (v416 >= 0x90) {
                int v418 = 8;
              }
              else {
                int v418 = 7;
              }
              if (v416 >= 0x90) {
                int v419 = v412;
              }
              else {
                int v419 = v412 + 1;
              }
              BOOL v420 = v415 == 255;
              if (v415 == 255) {
                uint64_t v415 = v417;
              }
              else {
                uint64_t v415 = *v412;
              }
              if (v420) {
                int v403 = v418;
              }
              else {
                int v403 = 8;
              }
              if (v420) {
                int v405 = v419;
              }
              else {
                int v405 = v412 + 1;
              }
              if (v420) {
                uint64_t v412 = v419;
              }
              else {
                ++v412;
              }
            }
            --v403;
            if ((v608 & 8) == 0)
            {
              v409[v593 + v410] |= 0x20000u;
              v409[v410 - 3 - v607] |= (v415 >> v403 << 31) | 0x10000;
              v409[v591 + v410] |= 0x8000u;
            }
            uint64_t v421 = &v409[v410];
            *(v421 - 1) = v409[v410 - 1] | 0x20;
            v421[1] = v409[v410 + 1] | 8;
            v413 |= (((v415 >> v403) & 1) << 21) | 0x100010;
            *(_DWORD *)&v408[v410 * 4] = (v415 >> v403 << 31) + v406;
          }
          else
          {
            v413 |= 0x100000u;
          }
LABEL_1086:
          if ((v413 & 0xF78) == 0 || (v413 & 0x1000080) != 0)
          {
            uint64_t v423 = v415;
            goto LABEL_1124;
          }
          if (v403)
          {
            uint64_t v423 = v415;
            goto LABEL_1099;
          }
          int v405 = v412 + 1;
          uint64_t v423 = *v412;
          if (v415 == 255)
          {
            if (v423 >= 0x90)
            {
              int v403 = 8;
              uint64_t v423 = 255;
              int v405 = v412;
              goto LABEL_1099;
            }
            int v403 = 7;
          }
          else
          {
            int v403 = 8;
          }
          ++v412;
LABEL_1099:
          if ((v423 >> --v403))
          {
            if (!v403)
            {
              unsigned int v424 = *v412;
              if (v424 >= 0x90) {
                unsigned int v425 = 255;
              }
              else {
                unsigned int v425 = *v412;
              }
              if (v424 >= 0x90) {
                int v426 = 8;
              }
              else {
                int v426 = 7;
              }
              if (v424 >= 0x90) {
                int v427 = v412;
              }
              else {
                int v427 = v412 + 1;
              }
              BOOL v428 = v423 == 255;
              if (v423 == 255) {
                uint64_t v423 = v425;
              }
              else {
                uint64_t v423 = *v412;
              }
              if (v428) {
                int v403 = v426;
              }
              else {
                int v403 = 8;
              }
              if (v428) {
                int v405 = v427;
              }
              else {
                int v405 = v412 + 1;
              }
              if (v428) {
                uint64_t v412 = v427;
              }
              else {
                ++v412;
              }
            }
            --v403;
            int v429 = &v409[v410];
            *(v429 - 1) = v409[v410 - 1] | 0x100;
            v429[1] = v409[v410 + 1] | 0x40;
            v413 |= (((v423 >> v403) & 1) << 24) | 0x800080;
            *(_DWORD *)&v408[4 * v607 + v410 * 4] = v406 + (v423 >> v403 << 31);
          }
          else
          {
            v413 |= 0x800000u;
          }
LABEL_1124:
          if ((v413 & 0x7BC0) == 0 || (v413 & 0x8000400) != 0)
          {
LABEL_1148:
            uint64_t v431 = v423;
            goto LABEL_1149;
          }
          if (v403)
          {
            uint64_t v431 = v423;
            goto LABEL_1137;
          }
          int v405 = v412 + 1;
          uint64_t v431 = *v412;
          if (v423 == 255)
          {
            if (v431 >= 0x90)
            {
              int v403 = 8;
              uint64_t v431 = 255;
              int v405 = v412;
              goto LABEL_1137;
            }
            int v403 = 7;
          }
          else
          {
            int v403 = 8;
          }
          ++v412;
LABEL_1137:
          if ((v431 >> --v403))
          {
            if (v403)
            {
              uint64_t v423 = v431;
LABEL_1147:
              --v403;
              v432 = &v409[v410];
              *(v432 - 1) = v409[v410 - 1] | 0x800;
              v432[1] = v409[v410 + 1] | 0x200;
              v413 |= (((v423 >> v403) & 1) << 27) | 0x4000400;
              *(_DWORD *)&v408[8 * v607 + v410 * 4] = v406 + (v423 >> v403 << 31);
              goto LABEL_1148;
            }
            int v405 = v412 + 1;
            uint64_t v423 = *v412;
            if (v431 == 255)
            {
              if (v423 >= 0x90)
              {
                int v403 = 8;
                uint64_t v423 = 255;
                int v405 = v412;
                goto LABEL_1147;
              }
              int v403 = 7;
            }
            else
            {
              int v403 = 8;
            }
            ++v412;
            goto LABEL_1147;
          }
          v413 |= 0x4000000u;
LABEL_1149:
          if ((v413 & 0x3DE00) == 0 || (v413 & 0x40002000) != 0) {
            goto LABEL_1170;
          }
          if (v403)
          {
            uint64_t v404 = v431;
            goto LABEL_1159;
          }
          int v405 = v412 + 1;
          uint64_t v404 = *v412;
          if (v431 == 255)
          {
            if (v404 >= 0x90)
            {
              int v403 = 8;
              uint64_t v404 = 255;
              int v405 = v412;
              goto LABEL_1159;
            }
            int v403 = 7;
          }
          else
          {
            int v403 = 8;
          }
          ++v412;
LABEL_1159:
          uint64_t v14 = v16;
          if ((v404 >> --v403))
          {
            if (v403)
            {
              uint64_t v431 = v404;
              goto LABEL_1169;
            }
            int v405 = v412 + 1;
            uint64_t v431 = *v412;
            if (v404 == 255)
            {
              if (v431 >= 0x90)
              {
                int v403 = 8;
                uint64_t v431 = 255;
                int v405 = v412;
                goto LABEL_1169;
              }
              int v403 = 7;
            }
            else
            {
              int v403 = 8;
            }
            ++v412;
LABEL_1169:
            unsigned int v433 = (v431 >> --v403) & 1;
            v409[v600 + v410] |= 4u;
            *(unsigned int *)((char *)v409 + v604 + v410 * 4) |= (v433 << 18) | 2;
            v409[v599 + v410] |= 1u;
            uint64_t v434 = &v409[v410];
            *(v434 - 1) = v409[v410 - 1] | 0x4000;
            v434[1] = v409[v410 + 1] | 0x1000;
            v413 |= (v433 << 30) | 0x20002000;
            *(_DWORD *)&v408[12 * v607 + v410 * 4] = v406 + (v431 >> v403 << 31);
LABEL_1170:
            uint64_t v404 = v431;
            uint64_t v14 = v16;
          }
          else
          {
            v413 |= 0x20000000u;
          }
          v409[v410] = v413;
          goto LABEL_1172;
        }
        if (v34 == 1 && !v596)
        {
          if (!BYTE6(v614) || BYTE4(v614) || !BYTE5(v614)) {
            kd_block_decoder::decode();
          }
          BYTE4(v614) = 1;
          if (SDWORD1(v612) >= (int)v612 - 0x800000) {
            signed int v435 = v612 - 0x800000;
          }
          else {
            signed int v435 = DWORD1(v612);
          }
          int v436 = v612 - v435;
          int v437 = DWORD1(v612) - v435;
          int v438 = DWORD2(v612);
          unsigned int v439 = HIDWORD(v612);
          int v440 = (unsigned __int8 *)*((void *)&v613 + 1);
          int v60 = v614;
          if (v589 < 1) {
            goto LABEL_1579;
          }
          int v441 = 1 << v28 >> 1;
          int v442 = v585;
          v443 = (int *)v586;
          int v444 = v587;
          while (1)
          {
            int v445 = v606;
            if (v606 >= 1) {
              break;
            }
LABEL_1468:
            v444 += 3;
            v443 += 3 * v607;
            BOOL v250 = __OFSUB__(v442--, 1);
            if ((v442 < 0) ^ v250 | (v442 == 0)) {
              goto LABEL_1579;
            }
          }
          while (1)
          {
            unsigned int v446 = *v444;
            if ((*v444 & 0x12480000) != 0)
            {
              if ((v446 & 0x80000) != 0)
              {
                int v447 = *v443;
                unsigned int v448 = (*v443 & 0x7FFFFFFFu) >> v36;
                uint64_t v449 = 16;
                if ((v446 & 0x1EF) == 0) {
                  uint64_t v449 = 15;
                }
                int v450 = &v619;
                if ((v446 & 0x1EF) == 0) {
                  int v450 = &v618;
                }
                if (v448 >= 4)
                {
                  uint64_t v449 = 17;
                  int v450 = &v620;
                }
                int v451 = v615[v449];
                int v452 = v451 & 1;
                signed int v435 = v435 - v451 + v452;
                if (v435 < 0)
                {
                  v436 += v435;
                  v437 += v435;
                  signed int v435 = v451 & 0xFFFFFFFE;
                  if (v437 < 0)
                  {
                    if (v436 >= v435)
                    {
                      int v452 = !(v451 & 1);
                      uint64_t v459 = 264;
                      if ((v446 & 0x1EF) == 0) {
                        uint64_t v459 = 248;
                      }
                      if (v448 >= 4) {
                        uint64_t v459 = 280;
                      }
                      int v457 = (long long *)(*(void *)((char *)v615 + v459) + 16);
                    }
                    else
                    {
                      uint64_t v456 = 264;
                      if ((v446 & 0x1EF) == 0) {
                        uint64_t v456 = 248;
                      }
                      if (v448 >= 4) {
                        uint64_t v456 = 280;
                      }
                      int v457 = *(long long **)((char *)v615 + v456);
                    }
                    v437 += v435;
                    *int v450 = *v457;
                    if (v435 >= 0x800000)
                    {
LABEL_1578:
                      int v436 = v435;
LABEL_1579:
                      BYTE4(v614) = 0;
                      LODWORD(v612) = v436 + v435;
                      DWORD1(v612) = v437 + v435;
                      *((void *)&v612 + 1) = __PAIR64__(v439, v438);
                      *((void *)&v613 + 1) = v440;
                      goto LABEL_1586;
                    }
                  }
                  else
                  {
                    if (v436 >= 0x800000) {
                      goto LABEL_1579;
                    }
                    if (v436 >= v435)
                    {
                      uint64_t v458 = 264;
                      if ((v446 & 0x1EF) == 0) {
                        uint64_t v458 = 248;
                      }
                      if (v448 >= 4) {
                        uint64_t v458 = 280;
                      }
                      uint64_t v454 = *(long long **)((char *)v615 + v458);
                    }
                    else
                    {
                      int v452 = !(v451 & 1);
                      uint64_t v453 = 264;
                      if ((v446 & 0x1EF) == 0) {
                        uint64_t v453 = 248;
                      }
                      if (v448 >= 4) {
                        uint64_t v453 = 280;
                      }
                      uint64_t v454 = (long long *)(*(void *)((char *)v615 + v453) + 16);
                    }
                    *int v450 = *v454;
                    signed int v435 = v436;
                  }
                  int v460 = v60;
                  do
                  {
                    if (!v438)
                    {
                      BOOL v462 = v440 + 1;
                      unsigned int v461 = *v440;
                      unsigned int v463 = v437 + v461;
                      if (v461 >= 0x90) {
                        int v464 = 255;
                      }
                      else {
                        int v464 = *v440;
                      }
                      if (v461 >= 0x90) {
                        int v465 = v460 + 1;
                      }
                      else {
                        int v465 = v60;
                      }
                      if (v461 < 0x90) {
                        int v466 = v460;
                      }
                      else {
                        int v466 = v460 + 1;
                      }
                      if (v461 < 0x90)
                      {
                        ++v440;
                        int v467 = 7;
                      }
                      else
                      {
                        unsigned int v463 = v437;
                        int v467 = 8;
                      }
                      BOOL v468 = v439 == 255;
                      if (v439 == 255) {
                        unsigned int v439 = v464;
                      }
                      else {
                        unsigned int v439 = v461;
                      }
                      if (v468) {
                        int v60 = v465;
                      }
                      if (v468) {
                        int v460 = v466;
                      }
                      uint64_t v14 = v16;
                      if (v468) {
                        int v437 = v463;
                      }
                      if (v468)
                      {
                        int v438 = v467;
                      }
                      else
                      {
                        int v440 = v462;
                        int v438 = 8;
                      }
                      v437 += v439;
                    }
                    int v469 = 2 * v435;
                    v437 *= 2;
                    --v438;
                    BOOL v91 = v435 < 0x400000;
                    v435 *= 2;
                  }
                  while (v91);
                  signed int v435 = v469 - 0x800000;
                  if (v437 < v469 - 0x800000) {
                    signed int v435 = v437;
                  }
                  int v436 = v469 - v435;
                  v437 -= v435;
                }
                int *v443 = ((v452 ^ 1) << v36) ^ v447 | v441;
              }
              if ((v446 & 0x400000) != 0)
              {
                int v470 = v443[v607];
                unsigned int v471 = (v470 & 0x7FFFFFFFu) >> v36;
                uint64_t v472 = 16;
                if ((v446 & 0xF78) == 0) {
                  uint64_t v472 = 15;
                }
                v473 = &v619;
                if ((v446 & 0xF78) == 0) {
                  v473 = &v618;
                }
                if (v471 >= 4)
                {
                  uint64_t v472 = 17;
                  v473 = &v620;
                }
                int v474 = v615[v472];
                int v475 = v474 & 1;
                signed int v435 = v435 - v474 + v475;
                if (v435 < 0)
                {
                  v436 += v435;
                  v437 += v435;
                  signed int v435 = v474 & 0xFFFFFFFE;
                  if (v437 < 0)
                  {
                    if (v436 >= v435)
                    {
                      int v475 = !(v474 & 1);
                      uint64_t v481 = 264;
                      if ((v446 & 0xF78) == 0) {
                        uint64_t v481 = 248;
                      }
                      if (v471 >= 4) {
                        uint64_t v481 = 280;
                      }
                      v479 = (long long *)(*(void *)((char *)v615 + v481) + 16);
                    }
                    else
                    {
                      uint64_t v478 = 264;
                      if ((v446 & 0xF78) == 0) {
                        uint64_t v478 = 248;
                      }
                      if (v471 >= 4) {
                        uint64_t v478 = 280;
                      }
                      v479 = *(long long **)((char *)v615 + v478);
                    }
                    v437 += v435;
                    long long *v473 = *v479;
                    if (v435 >= 0x800000) {
                      goto LABEL_1578;
                    }
                  }
                  else
                  {
                    if (v436 >= 0x800000) {
                      goto LABEL_1579;
                    }
                    if (v436 >= v435)
                    {
                      uint64_t v480 = 264;
                      if ((v446 & 0xF78) == 0) {
                        uint64_t v480 = 248;
                      }
                      if (v471 >= 4) {
                        uint64_t v480 = 280;
                      }
                      int v477 = *(long long **)((char *)v615 + v480);
                    }
                    else
                    {
                      int v475 = !(v474 & 1);
                      uint64_t v476 = 264;
                      if ((v446 & 0xF78) == 0) {
                        uint64_t v476 = 248;
                      }
                      if (v471 >= 4) {
                        uint64_t v476 = 280;
                      }
                      int v477 = (long long *)(*(void *)((char *)v615 + v476) + 16);
                    }
                    long long *v473 = *v477;
                    signed int v435 = v436;
                  }
                  int v482 = v60;
                  do
                  {
                    if (!v438)
                    {
                      v484 = v440 + 1;
                      unsigned int v483 = *v440;
                      unsigned int v485 = v437 + v483;
                      if (v483 >= 0x90) {
                        int v486 = 255;
                      }
                      else {
                        int v486 = *v440;
                      }
                      if (v483 >= 0x90) {
                        int v487 = v482 + 1;
                      }
                      else {
                        int v487 = v60;
                      }
                      if (v483 < 0x90) {
                        int v488 = v482;
                      }
                      else {
                        int v488 = v482 + 1;
                      }
                      if (v483 < 0x90)
                      {
                        ++v440;
                        int v489 = 7;
                      }
                      else
                      {
                        unsigned int v485 = v437;
                        int v489 = 8;
                      }
                      BOOL v490 = v439 == 255;
                      if (v439 == 255) {
                        unsigned int v439 = v486;
                      }
                      else {
                        unsigned int v439 = v483;
                      }
                      if (v490) {
                        int v60 = v487;
                      }
                      if (v490) {
                        int v482 = v488;
                      }
                      uint64_t v14 = v16;
                      if (v490) {
                        int v437 = v485;
                      }
                      if (v490)
                      {
                        int v438 = v489;
                      }
                      else
                      {
                        int v440 = v484;
                        int v438 = 8;
                      }
                      v437 += v439;
                    }
                    int v491 = 2 * v435;
                    v437 *= 2;
                    --v438;
                    BOOL v91 = v435 < 0x400000;
                    v435 *= 2;
                  }
                  while (v91);
                  signed int v435 = v491 - 0x800000;
                  if (v437 < v491 - 0x800000) {
                    signed int v435 = v437;
                  }
                  int v436 = v491 - v435;
                  v437 -= v435;
                }
                v443[v607] = ((v475 ^ 1) << v36) ^ v470 | v441;
              }
              if ((v446 & 0x2000000) != 0)
              {
                int v492 = v443[2 * v607];
                unsigned int v493 = (v492 & 0x7FFFFFFFu) >> v36;
                uint64_t v494 = 16;
                if ((v446 & 0x7BC0) == 0) {
                  uint64_t v494 = 15;
                }
                double v495 = &v619;
                if ((v446 & 0x7BC0) == 0) {
                  double v495 = &v618;
                }
                if (v493 >= 4)
                {
                  uint64_t v494 = 17;
                  double v495 = &v620;
                }
                int v496 = v615[v494];
                int v497 = v496 & 1;
                signed int v435 = v435 - v496 + v497;
                if (v435 < 0)
                {
                  v436 += v435;
                  v437 += v435;
                  signed int v435 = v496 & 0xFFFFFFFE;
                  if (v437 < 0)
                  {
                    if (v436 >= v435)
                    {
                      int v497 = !(v496 & 1);
                      uint64_t v503 = 264;
                      if ((v446 & 0x7BC0) == 0) {
                        uint64_t v503 = 248;
                      }
                      if (v493 >= 4) {
                        uint64_t v503 = 280;
                      }
                      double v501 = (long long *)(*(void *)((char *)v615 + v503) + 16);
                    }
                    else
                    {
                      uint64_t v500 = 264;
                      if ((v446 & 0x7BC0) == 0) {
                        uint64_t v500 = 248;
                      }
                      if (v493 >= 4) {
                        uint64_t v500 = 280;
                      }
                      double v501 = *(long long **)((char *)v615 + v500);
                    }
                    v437 += v435;
                    *double v495 = *v501;
                    if (v435 >= 0x800000) {
                      goto LABEL_1578;
                    }
                  }
                  else
                  {
                    if (v436 >= 0x800000) {
                      goto LABEL_1579;
                    }
                    if (v436 >= v435)
                    {
                      uint64_t v502 = 264;
                      if ((v446 & 0x7BC0) == 0) {
                        uint64_t v502 = 248;
                      }
                      if (v493 >= 4) {
                        uint64_t v502 = 280;
                      }
                      double v499 = *(long long **)((char *)v615 + v502);
                    }
                    else
                    {
                      int v497 = !(v496 & 1);
                      uint64_t v498 = 264;
                      if ((v446 & 0x7BC0) == 0) {
                        uint64_t v498 = 248;
                      }
                      if (v493 >= 4) {
                        uint64_t v498 = 280;
                      }
                      double v499 = (long long *)(*(void *)((char *)v615 + v498) + 16);
                    }
                    *double v495 = *v499;
                    signed int v435 = v436;
                  }
                  int v504 = v60;
                  do
                  {
                    if (!v438)
                    {
                      int v506 = v440 + 1;
                      unsigned int v505 = *v440;
                      unsigned int v507 = v437 + v505;
                      if (v505 >= 0x90) {
                        int v508 = 255;
                      }
                      else {
                        int v508 = *v440;
                      }
                      if (v505 >= 0x90) {
                        int v509 = v504 + 1;
                      }
                      else {
                        int v509 = v60;
                      }
                      if (v505 < 0x90) {
                        int v510 = v504;
                      }
                      else {
                        int v510 = v504 + 1;
                      }
                      if (v505 < 0x90)
                      {
                        ++v440;
                        int v511 = 7;
                      }
                      else
                      {
                        unsigned int v507 = v437;
                        int v511 = 8;
                      }
                      BOOL v512 = v439 == 255;
                      if (v439 == 255) {
                        unsigned int v439 = v508;
                      }
                      else {
                        unsigned int v439 = v505;
                      }
                      if (v512) {
                        int v60 = v509;
                      }
                      if (v512) {
                        int v504 = v510;
                      }
                      uint64_t v14 = v16;
                      if (v512) {
                        int v437 = v507;
                      }
                      if (v512)
                      {
                        int v438 = v511;
                      }
                      else
                      {
                        int v440 = v506;
                        int v438 = 8;
                      }
                      v437 += v439;
                    }
                    int v513 = 2 * v435;
                    v437 *= 2;
                    --v438;
                    BOOL v91 = v435 < 0x400000;
                    v435 *= 2;
                  }
                  while (v91);
                  signed int v435 = v513 - 0x800000;
                  if (v437 < v513 - 0x800000) {
                    signed int v435 = v437;
                  }
                  int v436 = v513 - v435;
                  v437 -= v435;
                }
                v443[2 * v607] = ((v497 ^ 1) << v36) ^ v492 | v441;
              }
              if ((v446 & 0x10000000) != 0)
              {
                int v514 = v443[3 * v607];
                unsigned int v515 = (v514 & 0x7FFFFFFFu) >> v36;
                int v517 = v446 & 0x3DE00;
                BOOL v516 = (v446 & 0x3DE00) == 0;
                uint64_t v518 = 16;
                if (v516) {
                  uint64_t v518 = 15;
                }
                int v519 = &v619;
                if (v516) {
                  int v519 = &v618;
                }
                if (v515 >= 4)
                {
                  uint64_t v518 = 17;
                  int v519 = &v620;
                }
                int v520 = v615[v518];
                int v521 = v520 & 1;
                signed int v435 = v435 - v520 + v521;
                if (v435 < 0)
                {
                  v436 += v435;
                  v437 += v435;
                  signed int v435 = v520 & 0xFFFFFFFE;
                  if (v437 < 0)
                  {
                    if (v436 >= v435)
                    {
                      int v521 = !(v520 & 1);
                      uint64_t v527 = 264;
                      if (!v517) {
                        uint64_t v527 = 248;
                      }
                      if (v515 >= 4) {
                        uint64_t v527 = 280;
                      }
                      int v525 = (long long *)(*(void *)((char *)v615 + v527) + 16);
                    }
                    else
                    {
                      uint64_t v524 = 264;
                      if (!v517) {
                        uint64_t v524 = 248;
                      }
                      if (v515 >= 4) {
                        uint64_t v524 = 280;
                      }
                      int v525 = *(long long **)((char *)v615 + v524);
                    }
                    v437 += v435;
                    *int v519 = *v525;
                    if (v435 >= 0x800000) {
                      goto LABEL_1578;
                    }
                  }
                  else
                  {
                    if (v436 >= 0x800000) {
                      goto LABEL_1579;
                    }
                    if (v436 >= v435)
                    {
                      uint64_t v526 = 264;
                      if (!v517) {
                        uint64_t v526 = 248;
                      }
                      if (v515 >= 4) {
                        uint64_t v526 = 280;
                      }
                      int v523 = *(long long **)((char *)v615 + v526);
                    }
                    else
                    {
                      int v521 = !(v520 & 1);
                      uint64_t v522 = 264;
                      if (!v517) {
                        uint64_t v522 = 248;
                      }
                      if (v515 >= 4) {
                        uint64_t v522 = 280;
                      }
                      int v523 = (long long *)(*(void *)((char *)v615 + v522) + 16);
                    }
                    *int v519 = *v523;
                    signed int v435 = v436;
                  }
                  int v528 = v60;
                  do
                  {
                    if (!v438)
                    {
                      int v530 = v440 + 1;
                      unsigned int v529 = *v440;
                      unsigned int v531 = v437 + v529;
                      if (v529 >= 0x90) {
                        int v532 = 255;
                      }
                      else {
                        int v532 = *v440;
                      }
                      if (v529 >= 0x90) {
                        int v533 = v528 + 1;
                      }
                      else {
                        int v533 = v60;
                      }
                      if (v529 < 0x90) {
                        int v534 = v528;
                      }
                      else {
                        int v534 = v528 + 1;
                      }
                      if (v529 < 0x90)
                      {
                        ++v440;
                        int v535 = 7;
                      }
                      else
                      {
                        unsigned int v531 = v437;
                        int v535 = 8;
                      }
                      BOOL v536 = v439 == 255;
                      if (v439 == 255) {
                        unsigned int v439 = v532;
                      }
                      else {
                        unsigned int v439 = v529;
                      }
                      if (v536) {
                        int v60 = v533;
                      }
                      if (v536) {
                        int v528 = v534;
                      }
                      if (v536) {
                        int v437 = v531;
                      }
                      if (v536)
                      {
                        int v438 = v535;
                      }
                      else
                      {
                        int v440 = v530;
                        int v438 = 8;
                      }
                      uint64_t v14 = v16;
                      v437 += v439;
                    }
                    int v537 = 2 * v435;
                    v437 *= 2;
                    --v438;
                    BOOL v91 = v435 < 0x400000;
                    v435 *= 2;
                  }
                  while (v91);
                  signed int v435 = v537 - 0x800000;
                  if (v437 < v537 - 0x800000) {
                    signed int v435 = v437;
                  }
                  int v436 = v537 - v435;
                  v437 -= v435;
                }
                v443[3 * v607] = ((v521 ^ 1) << v36) ^ v514 | v441;
              }
            }
            else if (!v444[2])
            {
              do
              {
                v445 -= 2;
                v443 += 2;
                unsigned int v455 = v444[4];
                v444 += 2;
              }
              while (!v455);
            }
            ++v443;
            ++v444;
            BOOL v250 = __OFSUB__(v445--, 1);
            if ((v445 < 0) ^ v250 | (v445 == 0)) {
              goto LABEL_1468;
            }
          }
        }
        if (v34 == 1)
        {
          if (!BYTE6(v614) || BYTE4(v614) | BYTE5(v614)) {
            kd_block_decoder::decode();
          }
          BYTE4(v614) = 1;
          int v538 = DWORD2(v612);
          unsigned int v539 = HIDWORD(v612);
          uint64_t v540 = (unsigned __int8 *)*((void *)&v613 + 1);
          if (v589 < 1)
          {
LABEL_1577:
            BYTE4(v614) = 0;
            *((void *)&v612 + 1) = __PAIR64__(v539, v538);
            *((void *)&v613 + 1) = v540;
            goto LABEL_1587;
          }
          int v541 = 1 << v28 >> 1;
          int v542 = v585;
          double v543 = (int *)v586;
          int v544 = v587;
          while (v20 < 1)
          {
LABEL_1575:
            v544 += 3;
            v543 += 3 * v607;
            BOOL v250 = __OFSUB__(v542--, 1);
            if ((v542 < 0) ^ v250 | (v542 == 0)) {
              goto LABEL_1577;
            }
          }
          int v545 = v20;
          v546 = v540;
          while (2)
          {
            unsigned int v547 = *v544;
            if ((*v544 & 0x12480000) == 0)
            {
              if (!v544[2])
              {
                do
                {
                  v545 -= 2;
                  v543 += 2;
                  unsigned int v548 = v544[4];
                  v544 += 2;
                }
                while (!v548);
              }
              goto LABEL_1573;
            }
            if ((v547 & 0x80000) != 0)
            {
              if (!v538)
              {
                v549 = v546 + 1;
                unsigned int v550 = *v546;
                if (v550 >= 0x90) {
                  int v551 = 255;
                }
                else {
                  int v551 = *v546;
                }
                if (v550 >= 0x90) {
                  int v552 = 8;
                }
                else {
                  int v552 = 7;
                }
                if (v550 < 0x90) {
                  ++v546;
                }
                BOOL v553 = v539 == 255;
                if (v539 == 255) {
                  unsigned int v539 = v551;
                }
                else {
                  unsigned int v539 = v550;
                }
                if (v553) {
                  int v538 = v552;
                }
                else {
                  int v538 = 8;
                }
                if (v553) {
                  uint64_t v540 = v546;
                }
                else {
                  uint64_t v540 = v549;
                }
                if (!v553) {
                  v546 = v549;
                }
              }
              *double v543 = ((((v539 >> --v538) & 1) == 0) << v36) ^ *v543 | v541;
              if ((v547 & 0x400000) != 0) {
                goto LABEL_1510;
              }
LABEL_1483:
              if ((v547 & 0x2000000) == 0) {
                goto LABEL_1484;
              }
LABEL_1531:
              if (!v538)
              {
                uint64_t v559 = v546 + 1;
                unsigned int v560 = *v546;
                if (v560 >= 0x90) {
                  int v561 = 255;
                }
                else {
                  int v561 = *v546;
                }
                if (v560 >= 0x90) {
                  int v562 = 8;
                }
                else {
                  int v562 = 7;
                }
                if (v560 < 0x90) {
                  ++v546;
                }
                BOOL v563 = v539 == 255;
                if (v539 == 255) {
                  unsigned int v539 = v561;
                }
                else {
                  unsigned int v539 = v560;
                }
                if (v563) {
                  int v538 = v562;
                }
                else {
                  int v538 = 8;
                }
                if (v563) {
                  uint64_t v540 = v546;
                }
                else {
                  uint64_t v540 = v559;
                }
                if (!v563) {
                  v546 = v559;
                }
              }
              v543[2 * v607] = ((((v539 >> --v538) & 1) == 0) << v36) ^ v543[2 * v607] | v541;
              if ((v547 & 0x10000000) == 0)
              {
LABEL_1573:
                ++v543;
                ++v544;
                BOOL v250 = __OFSUB__(v545--, 1);
                if ((v545 < 0) ^ v250 | (v545 == 0)) {
                  goto LABEL_1575;
                }
                continue;
              }
            }
            else
            {
              if ((v547 & 0x400000) == 0) {
                goto LABEL_1483;
              }
LABEL_1510:
              if (!v538)
              {
                int v554 = v546 + 1;
                unsigned int v555 = *v546;
                if (v555 >= 0x90) {
                  int v556 = 255;
                }
                else {
                  int v556 = *v546;
                }
                if (v555 >= 0x90) {
                  int v557 = 8;
                }
                else {
                  int v557 = 7;
                }
                if (v555 < 0x90) {
                  ++v546;
                }
                BOOL v558 = v539 == 255;
                if (v539 == 255) {
                  unsigned int v539 = v556;
                }
                else {
                  unsigned int v539 = v555;
                }
                if (v558) {
                  int v538 = v557;
                }
                else {
                  int v538 = 8;
                }
                if (v558) {
                  uint64_t v540 = v546;
                }
                else {
                  uint64_t v540 = v554;
                }
                if (!v558) {
                  v546 = v554;
                }
              }
              v543[v607] = ((((v539 >> --v538) & 1) == 0) << v36) ^ v543[v607] | v541;
              if ((v547 & 0x2000000) != 0) {
                goto LABEL_1531;
              }
LABEL_1484:
              if ((v547 & 0x10000000) == 0) {
                goto LABEL_1573;
              }
            }
            break;
          }
          if (!v538)
          {
            int v565 = v546 + 1;
            unsigned int v564 = *v546;
            if (v564 >= 0x90) {
              int v566 = 255;
            }
            else {
              int v566 = *v546;
            }
            if (v564 >= 0x90) {
              int v567 = 8;
            }
            else {
              int v567 = 7;
            }
            if (v564 < 0x90) {
              ++v546;
            }
            BOOL v568 = v539 == 255;
            if (v539 == 255) {
              unsigned int v539 = v566;
            }
            else {
              unsigned int v539 = v564;
            }
            if (v568) {
              int v538 = v567;
            }
            else {
              int v538 = 8;
            }
            if (v568) {
              uint64_t v540 = v546;
            }
            else {
              uint64_t v540 = v565;
            }
            if (!v568) {
              v546 = v565;
            }
          }
          v543[3 * v607] = ((((v539 >> --v538) & 1) == 0) << v36) ^ v543[3 * v607] | v541;
          goto LABEL_1573;
        }
        if (!BYTE6(v614) || BYTE4(v614) || !BYTE5(v614)) {
          kd_block_decoder::decode();
        }
        uint64_t v53 = *((int *)v15 + 8);
        BYTE4(v614) = 1;
        if (SDWORD1(v612) >= (int)v612 - 0x800000) {
          signed int v54 = v612 - 0x800000;
        }
        else {
          signed int v54 = DWORD1(v612);
        }
        int v55 = v612 - v54;
        int v56 = DWORD1(v612) - v54;
        int v57 = DWORD2(v612);
        unsigned int v58 = HIDWORD(v612);
        uint64_t v59 = (unsigned __int8 *)*((void *)&v613 + 1);
        int v60 = v614;
        uint64_t v61 = *((void *)&v616 + 1);
        unsigned int v581 = DWORD1(v616);
        unsigned int v62 = v616;
        if (v589 < 1) {
          goto LABEL_1585;
        }
        uint64_t v63 = (uint64_t)*(&significance_luts + v53);
        int v64 = (1 << v28) + (1 << v28 >> 1);
        int v65 = v585;
        uint64_t v66 = v586;
        int v67 = v587;
        while (1)
        {
          int v580 = v65;
          if (v606 >= 1) {
            break;
          }
LABEL_627:
          v67 += 3;
          v66 += 3 * v607;
          int v65 = v580 - 1;
          if (v580 <= 1) {
            goto LABEL_1585;
          }
        }
        int v68 = v606;
        while (1)
        {
          unsigned int v69 = *v67;
          if (*v67)
          {
LABEL_93:
            if ((v69 & 0x300010) == 0)
            {
              uint64_t v70 = *(unsigned __int8 *)(v63 + (v69 & 0x1EF));
              unsigned int v71 = &v615[v70];
              int v72 = *v71 & 1;
              signed int v54 = v54 - *v71 + v72;
              if (v54 < 0)
              {
                v55 += v54;
                v56 += v54;
                signed int v54 = *v71 & 0xFFFFFFFE;
                if (v56 < 0)
                {
                  if (v55 >= v54)
                  {
                    int v72 = !(*(unsigned char *)v71 & 1);
                    int v96 = (_OWORD *)(*((void *)&v615[v70] + 1) + 16);
                  }
                  else
                  {
                    int v96 = (_OWORD *)*((void *)&v615[v70] + 1);
                  }
                  v56 += v54;
                  *(_OWORD *)unsigned int v71 = *v96;
                  if (v54 >= 0x800000) {
                    goto LABEL_1580;
                  }
                }
                else
                {
                  if (v55 >= 0x800000) {
                    goto LABEL_1585;
                  }
                  if (v55 >= v54)
                  {
                    signed int v77 = (_OWORD *)*((void *)&v615[v70] + 1);
                  }
                  else
                  {
                    int v72 = !(*(unsigned char *)v71 & 1);
                    signed int v77 = (_OWORD *)(*((void *)&v615[v70] + 1) + 16);
                  }
                  *(_OWORD *)unsigned int v71 = *v77;
                  signed int v54 = v55;
                }
                int v122 = v60;
                do
                {
                  if (!v57)
                  {
                    v123 = v59 + 1;
                    unsigned int v124 = *v59;
                    unsigned int v125 = v56 + v124;
                    if (v124 >= 0x90) {
                      int v126 = 255;
                    }
                    else {
                      int v126 = *v59;
                    }
                    if (v124 >= 0x90)
                    {
                      int v127 = v122 + 1;
                    }
                    else
                    {
                      ++v59;
                      int v127 = v60;
                    }
                    if (v124 < 0x90) {
                      int v128 = v122;
                    }
                    else {
                      int v128 = v122 + 1;
                    }
                    if (v124 < 0x90)
                    {
                      int v129 = 7;
                    }
                    else
                    {
                      unsigned int v125 = v56;
                      int v129 = 8;
                    }
                    BOOL v130 = v58 == 255;
                    if (v58 == 255) {
                      unsigned int v58 = v126;
                    }
                    else {
                      unsigned int v58 = v124;
                    }
                    if (v130) {
                      int v60 = v127;
                    }
                    else {
                      uint64_t v59 = v123;
                    }
                    uint64_t v14 = v16;
                    if (v130) {
                      int v122 = v128;
                    }
                    if (v130) {
                      int v56 = v125;
                    }
                    if (v130) {
                      int v57 = v129;
                    }
                    else {
                      int v57 = 8;
                    }
                    v56 += v58;
                  }
                  int v131 = 2 * v54;
                  v56 *= 2;
                  --v57;
                  BOOL v91 = v54 < 0x400000;
                  v54 *= 2;
                }
                while (v91);
                if (v56 >= v131 - 0x800000) {
                  signed int v54 = v131 - 0x800000;
                }
                else {
                  signed int v54 = v56;
                }
                int v55 = v131 - v54;
                v56 -= v54;
                if (v72) {
                  goto LABEL_285;
                }
              }
              else
              {
                if (!v72) {
                  goto LABEL_335;
                }
LABEL_285:
                unint64_t v132 = sign_lut[(*(v67 - 1) >> 2) & 4 | (v69 >> 1) & 0x41 | v67[1] & 0x10 | (((*(v67 - 1) >> 2) & 0x80004 | (v69 >> 1) & 0x820041 | v67[1] & 0x200010) >> 16)];
                unint64_t v133 = v132 >> 1;
                uint64_t v134 = &v617[v132 >> 1];
                int v135 = *v134 & 1;
                signed int v54 = v54 - *v134 + v135;
                if (v54 < 0)
                {
                  v55 += v54;
                  v56 += v54;
                  signed int v54 = *v134 & 0xFFFFFFFE;
                  if (v56 < 0)
                  {
                    if (v55 >= v54)
                    {
                      int v135 = !(*(unsigned char *)v134 & 1);
                      signed int v137 = (_OWORD *)(*((void *)&v617[v133] + 1) + 16);
                    }
                    else
                    {
                      signed int v137 = (_OWORD *)*((void *)&v617[v133] + 1);
                    }
                    v56 += v54;
                    *(_OWORD *)uint64_t v134 = *v137;
                    if (v54 >= 0x800000) {
                      goto LABEL_1580;
                    }
                  }
                  else
                  {
                    if (v55 >= 0x800000) {
                      goto LABEL_1585;
                    }
                    if (v55 >= v54)
                    {
                      int v136 = (_OWORD *)*((void *)&v617[v133] + 1);
                    }
                    else
                    {
                      int v135 = !(*(unsigned char *)v134 & 1);
                      int v136 = (_OWORD *)(*((void *)&v617[v133] + 1) + 16);
                    }
                    *(_OWORD *)uint64_t v134 = *v136;
                    signed int v54 = v55;
                  }
                  int v138 = v60;
                  do
                  {
                    if (!v57)
                    {
                      int v140 = v59 + 1;
                      unsigned int v139 = *v59;
                      unsigned int v141 = v56 + v139;
                      if (v139 >= 0x90) {
                        int v142 = 255;
                      }
                      else {
                        int v142 = *v59;
                      }
                      if (v139 >= 0x90)
                      {
                        int v143 = v138 + 1;
                      }
                      else
                      {
                        ++v59;
                        int v143 = v60;
                      }
                      if (v139 < 0x90) {
                        int v144 = v138;
                      }
                      else {
                        int v144 = v138 + 1;
                      }
                      if (v139 < 0x90)
                      {
                        int v145 = 7;
                      }
                      else
                      {
                        unsigned int v141 = v56;
                        int v145 = 8;
                      }
                      BOOL v146 = v58 == 255;
                      if (v58 == 255) {
                        unsigned int v58 = v142;
                      }
                      else {
                        unsigned int v58 = v139;
                      }
                      uint64_t v14 = v16;
                      if (v146) {
                        int v60 = v143;
                      }
                      else {
                        uint64_t v59 = v140;
                      }
                      if (v146) {
                        int v138 = v144;
                      }
                      if (v146) {
                        int v56 = v141;
                      }
                      if (v146) {
                        int v57 = v145;
                      }
                      else {
                        int v57 = 8;
                      }
                      v56 += v58;
                    }
                    int v147 = 2 * v54;
                    v56 *= 2;
                    --v57;
                    BOOL v91 = v54 < 0x400000;
                    v54 *= 2;
                  }
                  while (v91);
                  if (v56 >= v147 - 0x800000) {
                    signed int v54 = v147 - 0x800000;
                  }
                  else {
                    signed int v54 = v56;
                  }
                  int v55 = v147 - v54;
                  v56 -= v54;
                }
                int v148 = v135 ^ v132 & 1;
                if ((v608 & 8) != 0)
                {
                  int v149 = v148 << 31;
                }
                else
                {
                  v67[v593] |= 0x20000u;
                  v67[v592] |= (v148 << 31) | 0x10000;
                  int v149 = v148 << 31;
                  v67[v591] |= 0x8000u;
                }
                *(v67 - 1) |= 0x20u;
                v67[1] |= 8u;
                v69 |= (v148 << 21) | 0x10;
                _DWORD *v66 = v149 + v64;
              }
            }
LABEL_335:
            if ((v69 & 0x1800080) == 0)
            {
              uint64_t v150 = *(unsigned __int8 *)(v63 + ((v69 >> 3) & 0x1EFLL));
              int v151 = &v615[v150];
              int v152 = *v151 & 1;
              signed int v54 = v54 - *v151 + v152;
              if (v54 < 0)
              {
                v55 += v54;
                v56 += v54;
                signed int v54 = *v151 & 0xFFFFFFFE;
                if (v56 < 0)
                {
                  if (v55 >= v54)
                  {
                    int v152 = !(*(unsigned char *)v151 & 1);
                    int v154 = (_OWORD *)(*((void *)&v615[v150] + 1) + 16);
                  }
                  else
                  {
                    int v154 = (_OWORD *)*((void *)&v615[v150] + 1);
                  }
                  v56 += v54;
                  *(_OWORD *)int v151 = *v154;
                  if (v54 >= 0x800000) {
                    goto LABEL_1580;
                  }
                }
                else
                {
                  if (v55 >= 0x800000) {
                    goto LABEL_1585;
                  }
                  if (v55 >= v54)
                  {
                    int v153 = (_OWORD *)*((void *)&v615[v150] + 1);
                  }
                  else
                  {
                    int v152 = !(*(unsigned char *)v151 & 1);
                    int v153 = (_OWORD *)(*((void *)&v615[v150] + 1) + 16);
                  }
                  *(_OWORD *)int v151 = *v153;
                  signed int v54 = v55;
                }
                int v155 = v60;
                do
                {
                  if (!v57)
                  {
                    int v156 = v59 + 1;
                    unsigned int v157 = *v59;
                    unsigned int v158 = v56 + v157;
                    if (v157 >= 0x90) {
                      int v159 = 255;
                    }
                    else {
                      int v159 = *v59;
                    }
                    if (v157 >= 0x90)
                    {
                      int v160 = v155 + 1;
                    }
                    else
                    {
                      ++v59;
                      int v160 = v60;
                    }
                    if (v157 < 0x90) {
                      int v161 = v155;
                    }
                    else {
                      int v161 = v155 + 1;
                    }
                    if (v157 < 0x90)
                    {
                      int v162 = 7;
                    }
                    else
                    {
                      unsigned int v158 = v56;
                      int v162 = 8;
                    }
                    BOOL v163 = v58 == 255;
                    if (v58 == 255) {
                      unsigned int v58 = v159;
                    }
                    else {
                      unsigned int v58 = v157;
                    }
                    if (v163) {
                      int v60 = v160;
                    }
                    else {
                      uint64_t v59 = v156;
                    }
                    uint64_t v14 = v16;
                    if (v163) {
                      int v155 = v161;
                    }
                    if (v163) {
                      int v56 = v158;
                    }
                    if (v163) {
                      int v57 = v162;
                    }
                    else {
                      int v57 = 8;
                    }
                    v56 += v58;
                  }
                  int v164 = 2 * v54;
                  v56 *= 2;
                  --v57;
                  BOOL v91 = v54 < 0x400000;
                  v54 *= 2;
                }
                while (v91);
                if (v56 >= v164 - 0x800000) {
                  signed int v54 = v164 - 0x800000;
                }
                else {
                  signed int v54 = v56;
                }
                int v55 = v164 - v54;
                v56 -= v54;
              }
              unsigned int v118 = v69;
              if (v152)
              {
LABEL_383:
                unsigned int v165 = *(v67 - 1);
                unsigned int v166 = v67[1];
                unint64_t v167 = sign_lut[(v165 >> 5) & 4 | (v118 >> 4) & 0x41 | (v166 >> 3) & 0x10 | (((v165 >> 5) & 0x80004 | (v118 >> 4) & 0x820041 | (v166 >> 3) & 0x200010) >> 16)];
                unint64_t v168 = v167 >> 1;
                uint64_t v169 = &v617[v167 >> 1];
                int v170 = *v169 & 1;
                signed int v54 = v54 - *v169 + v170;
                if (v54 < 0)
                {
                  v55 += v54;
                  v56 += v54;
                  signed int v54 = *v169 & 0xFFFFFFFE;
                  if (v56 < 0)
                  {
                    if (v55 >= v54)
                    {
                      int v170 = !(*(unsigned char *)v169 & 1);
                      int v172 = (_OWORD *)(*((void *)&v617[v168] + 1) + 16);
                    }
                    else
                    {
                      int v172 = (_OWORD *)*((void *)&v617[v168] + 1);
                    }
                    v56 += v54;
                    *(_OWORD *)uint64_t v169 = *v172;
                    if (v54 >= 0x800000)
                    {
LABEL_1581:
                      int v55 = v54;
                      goto LABEL_1585;
                    }
                  }
                  else
                  {
                    if (v55 >= 0x800000) {
                      goto LABEL_1585;
                    }
                    if (v55 >= v54)
                    {
                      unsigned int v171 = (_OWORD *)*((void *)&v617[v168] + 1);
                    }
                    else
                    {
                      int v170 = !(*(unsigned char *)v169 & 1);
                      unsigned int v171 = (_OWORD *)(*((void *)&v617[v168] + 1) + 16);
                    }
                    *(_OWORD *)uint64_t v169 = *v171;
                    signed int v54 = v55;
                  }
                  int v173 = v60;
                  do
                  {
                    if (!v57)
                    {
                      v175 = v59 + 1;
                      unsigned int v174 = *v59;
                      unsigned int v176 = v56 + v174;
                      if (v174 >= 0x90) {
                        int v177 = 255;
                      }
                      else {
                        int v177 = *v59;
                      }
                      if (v174 >= 0x90)
                      {
                        int v178 = v173 + 1;
                      }
                      else
                      {
                        ++v59;
                        int v178 = v60;
                      }
                      if (v174 < 0x90) {
                        int v179 = v173;
                      }
                      else {
                        int v179 = v173 + 1;
                      }
                      if (v174 < 0x90)
                      {
                        int v180 = 7;
                      }
                      else
                      {
                        unsigned int v176 = v56;
                        int v180 = 8;
                      }
                      BOOL v181 = v58 == 255;
                      if (v58 == 255) {
                        unsigned int v58 = v177;
                      }
                      else {
                        unsigned int v58 = v174;
                      }
                      uint64_t v14 = v16;
                      if (v181) {
                        int v60 = v178;
                      }
                      else {
                        uint64_t v59 = v175;
                      }
                      if (v181) {
                        int v173 = v179;
                      }
                      if (v181) {
                        int v56 = v176;
                      }
                      if (v181) {
                        int v57 = v180;
                      }
                      else {
                        int v57 = 8;
                      }
                      v56 += v58;
                    }
                    int v182 = 2 * v54;
                    v56 *= 2;
                    --v57;
                    BOOL v91 = v54 < 0x400000;
                    v54 *= 2;
                  }
                  while (v91);
                  if (v56 >= v182 - 0x800000) {
                    signed int v54 = v182 - 0x800000;
                  }
                  else {
                    signed int v54 = v56;
                  }
                  int v55 = v182 - v54;
                  v56 -= v54;
                  unsigned int v166 = v67[1];
                  unsigned int v165 = *(v67 - 1);
                }
                int v183 = v170 ^ v167 & 1;
                *(v67 - 1) = v165 | 0x100;
                v67[1] = v166 | 0x40;
                unsigned int v69 = v118 | (v183 << 24) | 0x80;
                v66[v607] = v64 + (v183 << 31);
              }
            }
            if ((v69 & 0xC000400) == 0)
            {
              uint64_t v184 = *(unsigned __int8 *)(v63 + ((v69 >> 6) & 0x1EFLL));
              int v185 = &v615[v184];
              int v186 = *v185 & 1;
              signed int v54 = v54 - *v185 + v186;
              if (v54 < 0)
              {
                v55 += v54;
                v56 += v54;
                signed int v54 = *v185 & 0xFFFFFFFE;
                if (v56 < 0)
                {
                  if (v55 >= v54)
                  {
                    int v186 = !(*(unsigned char *)v185 & 1);
                    uint64_t v188 = (_OWORD *)(*((void *)&v615[v184] + 1) + 16);
                  }
                  else
                  {
                    uint64_t v188 = (_OWORD *)*((void *)&v615[v184] + 1);
                  }
                  v56 += v54;
                  *(_OWORD *)int v185 = *v188;
                  if (v54 >= 0x800000) {
                    goto LABEL_1580;
                  }
                }
                else
                {
                  if (v55 >= 0x800000) {
                    goto LABEL_1585;
                  }
                  if (v55 >= v54)
                  {
                    v187 = (_OWORD *)*((void *)&v615[v184] + 1);
                  }
                  else
                  {
                    int v186 = !(*(unsigned char *)v185 & 1);
                    v187 = (_OWORD *)(*((void *)&v615[v184] + 1) + 16);
                  }
                  *(_OWORD *)int v185 = *v187;
                  signed int v54 = v55;
                }
                int v189 = v60;
                do
                {
                  if (!v57)
                  {
                    int v190 = v59 + 1;
                    unsigned int v191 = *v59;
                    unsigned int v192 = v56 + v191;
                    if (v191 >= 0x90) {
                      int v193 = 255;
                    }
                    else {
                      int v193 = *v59;
                    }
                    if (v191 >= 0x90)
                    {
                      int v194 = v189 + 1;
                    }
                    else
                    {
                      ++v59;
                      int v194 = v60;
                    }
                    if (v191 < 0x90) {
                      int v195 = v189;
                    }
                    else {
                      int v195 = v189 + 1;
                    }
                    if (v191 < 0x90)
                    {
                      int v196 = 7;
                    }
                    else
                    {
                      unsigned int v192 = v56;
                      int v196 = 8;
                    }
                    BOOL v197 = v58 == 255;
                    if (v58 == 255) {
                      unsigned int v58 = v193;
                    }
                    else {
                      unsigned int v58 = v191;
                    }
                    if (v197) {
                      int v60 = v194;
                    }
                    else {
                      uint64_t v59 = v190;
                    }
                    uint64_t v14 = v16;
                    if (v197) {
                      int v189 = v195;
                    }
                    if (v197) {
                      int v56 = v192;
                    }
                    if (v197) {
                      int v57 = v196;
                    }
                    else {
                      int v57 = 8;
                    }
                    v56 += v58;
                  }
                  int v198 = 2 * v54;
                  v56 *= 2;
                  --v57;
                  BOOL v91 = v54 < 0x400000;
                  v54 *= 2;
                }
                while (v91);
                if (v56 >= v198 - 0x800000) {
                  signed int v54 = v198 - 0x800000;
                }
                else {
                  signed int v54 = v56;
                }
                int v55 = v198 - v54;
                v56 -= v54;
              }
              unsigned int v119 = v69;
              if (v186)
              {
LABEL_478:
                unsigned int v199 = *(v67 - 1);
                unsigned int v200 = v67[1];
                unint64_t v201 = sign_lut[(v199 >> 8) & 4 | (v119 >> 7) & 0x41 | (v200 >> 6) & 0x10 | (((v199 >> 8) & 0x80004 | (v119 >> 7) & 0x820041 | (v200 >> 6) & 0x200010) >> 16)];
                unint64_t v202 = v201 >> 1;
                __int32 v203 = &v617[v201 >> 1];
                int v204 = *v203 & 1;
                signed int v54 = v54 - *v203 + v204;
                if (v54 < 0)
                {
                  v55 += v54;
                  v56 += v54;
                  signed int v54 = *v203 & 0xFFFFFFFE;
                  if (v56 < 0)
                  {
                    if (v55 >= v54)
                    {
                      int v204 = !(*(unsigned char *)v203 & 1);
                      int v206 = (_OWORD *)(*((void *)&v617[v202] + 1) + 16);
                    }
                    else
                    {
                      int v206 = (_OWORD *)*((void *)&v617[v202] + 1);
                    }
                    v56 += v54;
                    *(_OWORD *)__int32 v203 = *v206;
                    if (v54 >= 0x800000) {
                      goto LABEL_1581;
                    }
                  }
                  else
                  {
                    if (v55 >= 0x800000) {
                      goto LABEL_1585;
                    }
                    if (v55 >= v54)
                    {
                      int v205 = (_OWORD *)*((void *)&v617[v202] + 1);
                    }
                    else
                    {
                      int v204 = !(*(unsigned char *)v203 & 1);
                      int v205 = (_OWORD *)(*((void *)&v617[v202] + 1) + 16);
                    }
                    *(_OWORD *)__int32 v203 = *v205;
                    signed int v54 = v55;
                  }
                  int v207 = v60;
                  do
                  {
                    if (!v57)
                    {
                      v209 = v59 + 1;
                      unsigned int v208 = *v59;
                      unsigned int v210 = v56 + v208;
                      if (v208 >= 0x90) {
                        int v211 = 255;
                      }
                      else {
                        int v211 = *v59;
                      }
                      if (v208 >= 0x90)
                      {
                        int v212 = v207 + 1;
                      }
                      else
                      {
                        ++v59;
                        int v212 = v60;
                      }
                      if (v208 < 0x90) {
                        int v213 = v207;
                      }
                      else {
                        int v213 = v207 + 1;
                      }
                      if (v208 < 0x90)
                      {
                        int v214 = 7;
                      }
                      else
                      {
                        unsigned int v210 = v56;
                        int v214 = 8;
                      }
                      BOOL v215 = v58 == 255;
                      if (v58 == 255) {
                        unsigned int v58 = v211;
                      }
                      else {
                        unsigned int v58 = v208;
                      }
                      uint64_t v14 = v16;
                      if (v215) {
                        int v60 = v212;
                      }
                      else {
                        uint64_t v59 = v209;
                      }
                      if (v215) {
                        int v207 = v213;
                      }
                      if (v215) {
                        int v56 = v210;
                      }
                      if (v215) {
                        int v57 = v214;
                      }
                      else {
                        int v57 = 8;
                      }
                      v56 += v58;
                    }
                    int v216 = 2 * v54;
                    v56 *= 2;
                    --v57;
                    BOOL v91 = v54 < 0x400000;
                    v54 *= 2;
                  }
                  while (v91);
                  if (v56 >= v216 - 0x800000) {
                    signed int v54 = v216 - 0x800000;
                  }
                  else {
                    signed int v54 = v56;
                  }
                  int v55 = v216 - v54;
                  v56 -= v54;
                  unsigned int v200 = v67[1];
                  unsigned int v199 = *(v67 - 1);
                }
                int v217 = v204 ^ v201 & 1;
                *(v67 - 1) = v199 | 0x800;
                v67[1] = v200 | 0x200;
                unsigned int v69 = v119 | (v217 << 27) | 0x400;
                v66[2 * v607] = v64 + (v217 << 31);
              }
            }
            if ((v69 & 0x60002000) == 0)
            {
              uint64_t v218 = *(unsigned __int8 *)(v63 + ((v69 >> 9) & 0x1EFLL));
              v219 = &v615[v218];
              int v220 = *v219 & 1;
              signed int v54 = v54 - *v219 + v220;
              if (v54 < 0)
              {
                v55 += v54;
                v56 += v54;
                signed int v54 = *v219 & 0xFFFFFFFE;
                if (v56 < 0)
                {
                  if (v55 >= v54)
                  {
                    int v220 = !(*(unsigned char *)v219 & 1);
                    signed int v222 = (_OWORD *)(*((void *)&v615[v218] + 1) + 16);
                  }
                  else
                  {
                    signed int v222 = (_OWORD *)*((void *)&v615[v218] + 1);
                  }
                  v56 += v54;
                  *(_OWORD *)v219 = *v222;
                  if (v54 >= 0x800000) {
                    goto LABEL_1580;
                  }
                }
                else
                {
                  if (v55 >= 0x800000) {
                    goto LABEL_1585;
                  }
                  if (v55 >= v54)
                  {
                    int v221 = (_OWORD *)*((void *)&v615[v218] + 1);
                  }
                  else
                  {
                    int v220 = !(*(unsigned char *)v219 & 1);
                    int v221 = (_OWORD *)(*((void *)&v615[v218] + 1) + 16);
                  }
                  *(_OWORD *)v219 = *v221;
                  signed int v54 = v55;
                }
                int v223 = v60;
                do
                {
                  if (!v57)
                  {
                    int v224 = v59 + 1;
                    unsigned int v225 = *v59;
                    unsigned int v226 = v56 + v225;
                    if (v225 >= 0x90) {
                      int v227 = 255;
                    }
                    else {
                      int v227 = *v59;
                    }
                    if (v225 >= 0x90)
                    {
                      int v228 = v223 + 1;
                    }
                    else
                    {
                      ++v59;
                      int v228 = v60;
                    }
                    if (v225 < 0x90) {
                      int v229 = v223;
                    }
                    else {
                      int v229 = v223 + 1;
                    }
                    if (v225 < 0x90)
                    {
                      int v230 = 7;
                    }
                    else
                    {
                      unsigned int v226 = v56;
                      int v230 = 8;
                    }
                    BOOL v231 = v58 == 255;
                    if (v58 == 255) {
                      unsigned int v58 = v227;
                    }
                    else {
                      unsigned int v58 = v225;
                    }
                    if (v231) {
                      int v60 = v228;
                    }
                    else {
                      uint64_t v59 = v224;
                    }
                    uint64_t v14 = v16;
                    if (v231) {
                      int v223 = v229;
                    }
                    if (v231) {
                      int v56 = v226;
                    }
                    if (v231) {
                      int v57 = v230;
                    }
                    else {
                      int v57 = 8;
                    }
                    v56 += v58;
                  }
                  int v232 = 2 * v54;
                  v56 *= 2;
                  --v57;
                  BOOL v91 = v54 < 0x400000;
                  v54 *= 2;
                }
                while (v91);
                if (v56 >= v232 - 0x800000) {
                  signed int v54 = v232 - 0x800000;
                }
                else {
                  signed int v54 = v56;
                }
                int v55 = v232 - v54;
                v56 -= v54;
                if (!v220) {
                  goto LABEL_624;
                }
              }
              else if (!v220)
              {
                goto LABEL_624;
              }
              if ((v69 & 0x80000000) == 0) {
                int v121 = (v69 >> 10) & 0x20041;
              }
              else {
                int v121 = (v69 >> 10) & 0x20041 | 0x800000;
              }
              unsigned int v120 = v69;
LABEL_578:
              unint64_t v233 = sign_lut[(*(v67 - 1) >> 11) & 4 | v121 & 0x55 | (v67[1] >> 9) & 0x10 | (((*(v67 - 1) >> 11) & 0x80004 | v121 | (v67[1] >> 9) & 0x200010) >> 16)];
              unint64_t v234 = v233 >> 1;
              v235 = &v617[v233 >> 1];
              int v236 = *v235 & 1;
              signed int v54 = v54 - *v235 + v236;
              if (v54 < 0)
              {
                v55 += v54;
                v56 += v54;
                signed int v54 = *v235 & 0xFFFFFFFE;
                if (v56 < 0)
                {
                  if (v55 >= v54)
                  {
                    int v236 = !(*(unsigned char *)v235 & 1);
                    int v238 = (_OWORD *)(*((void *)&v617[v234] + 1) + 16);
                  }
                  else
                  {
                    int v238 = (_OWORD *)*((void *)&v617[v234] + 1);
                  }
                  v56 += v54;
                  *(_OWORD *)v235 = *v238;
                  if (v54 >= 0x800000) {
                    goto LABEL_1581;
                  }
                }
                else
                {
                  if (v55 >= 0x800000) {
                    goto LABEL_1585;
                  }
                  if (v55 >= v54)
                  {
                    int v237 = (_OWORD *)*((void *)&v617[v234] + 1);
                  }
                  else
                  {
                    int v236 = !(*(unsigned char *)v235 & 1);
                    int v237 = (_OWORD *)(*((void *)&v617[v234] + 1) + 16);
                  }
                  *(_OWORD *)v235 = *v237;
                  signed int v54 = v55;
                }
                int v239 = v60;
                do
                {
                  if (!v57)
                  {
                    v240 = v59 + 1;
                    unsigned int v241 = *v59;
                    unsigned int v242 = v56 + v241;
                    if (v241 >= 0x90) {
                      int v243 = 255;
                    }
                    else {
                      int v243 = *v59;
                    }
                    if (v241 >= 0x90)
                    {
                      int v244 = v239 + 1;
                    }
                    else
                    {
                      ++v59;
                      int v244 = v60;
                    }
                    if (v241 < 0x90) {
                      int v245 = v239;
                    }
                    else {
                      int v245 = v239 + 1;
                    }
                    if (v241 < 0x90)
                    {
                      int v246 = 7;
                    }
                    else
                    {
                      unsigned int v242 = v56;
                      int v246 = 8;
                    }
                    BOOL v247 = v58 == 255;
                    if (v58 == 255) {
                      unsigned int v58 = v243;
                    }
                    else {
                      unsigned int v58 = v241;
                    }
                    if (v247) {
                      int v60 = v244;
                    }
                    else {
                      uint64_t v59 = v240;
                    }
                    if (v247) {
                      int v239 = v245;
                    }
                    if (v247) {
                      int v56 = v242;
                    }
                    uint64_t v14 = v16;
                    if (v247) {
                      int v57 = v246;
                    }
                    else {
                      int v57 = 8;
                    }
                    v56 += v58;
                  }
                  int v248 = 2 * v54;
                  v56 *= 2;
                  --v57;
                  BOOL v91 = v54 < 0x400000;
                  v54 *= 2;
                }
                while (v91);
                signed int v54 = v248 - 0x800000;
                if (v56 < v248 - 0x800000) {
                  signed int v54 = v56;
                }
                int v55 = v248 - v54;
                v56 -= v54;
              }
              int v249 = v236 ^ v233 & 1;
              v67[v600] |= 4u;
              v67[v601] |= (v249 << 18) | 2;
              v67[v599] |= 1u;
              *(v67 - 1) |= 0x4000u;
              v67[1] |= 0x1000u;
              unsigned int v69 = v120 | (v249 << 30) | 0x2000;
              v66[3 * v607] = v64 + (v249 << 31);
            }
LABEL_624:
            unsigned int *v67 = (v69 << 15) & 0x12480000 | v69 & 0xDB6FFFFF;
            goto LABEL_625;
          }
          int v73 = v62 & 1;
          if (!(v67[3] | v73) && (int)(v54 - 4 * v62) >= 0)
          {
            v68 -= 3;
            v66 += 3;
            v54 -= 4 * v62;
            v67 += 3;
            goto LABEL_625;
          }
          signed int v54 = v54 - v62 + v73;
          if (v54 >= 0)
          {
            if (v62) {
              break;
            }
            goto LABEL_625;
          }
          v55 += v54;
          v56 += v54;
          signed int v54 = v62 & 0xFFFFFFFE;
          if (v56 < 0)
          {
            v56 += v54;
            int v78 = (unsigned int *)(v61 + 16);
            unsigned int v79 = (unsigned int *)(v61 + 20);
            if (v55 >= v54)
            {
              BOOL v80 = (uint64_t *)(v61 + 24);
            }
            else
            {
              int v78 = (unsigned int *)v61;
              unsigned int v79 = (unsigned int *)(v61 + 4);
              BOOL v80 = (uint64_t *)(v61 + 8);
            }
            if (v55 >= v54) {
              v73 ^= 1u;
            }
            uint64_t v61 = *v80;
            unsigned int v581 = *v79;
            unsigned int v62 = *v78;
            uint64_t v14 = v16;
            if (v54 >= 0x800000)
            {
LABEL_1580:
              int v55 = v54;
              goto LABEL_1585;
            }
          }
          else
          {
            if (v55 >= 0x800000)
            {
              uint64_t v14 = v16;
              goto LABEL_1585;
            }
            unsigned int v74 = (unsigned int *)(v61 + 4);
            int v75 = (unsigned int *)(v61 + 16);
            if (v55 < v54) {
              unsigned int v74 = (unsigned int *)(v61 + 20);
            }
            else {
              int v75 = (unsigned int *)v61;
            }
            if (v55 < v54) {
              signed int v76 = (uint64_t *)(v61 + 24);
            }
            else {
              signed int v76 = (uint64_t *)(v61 + 8);
            }
            if (v55 < v54) {
              v73 ^= 1u;
            }
            uint64_t v61 = *v76;
            unsigned int v581 = *v74;
            signed int v54 = v55;
            unsigned int v62 = *v75;
            uint64_t v14 = v16;
          }
          int v81 = v60;
          do
          {
            if (!v57)
            {
              int v82 = v59 + 1;
              unsigned int v83 = *v59;
              unsigned int v84 = v56 + v83;
              if (v83 >= 0x90) {
                int v85 = 255;
              }
              else {
                int v85 = *v59;
              }
              if (v83 >= 0x90)
              {
                int v86 = v81 + 1;
              }
              else
              {
                ++v59;
                int v86 = v60;
              }
              if (v83 < 0x90) {
                int v87 = v81;
              }
              else {
                int v87 = v81 + 1;
              }
              if (v83 < 0x90)
              {
                int v88 = 7;
              }
              else
              {
                unsigned int v84 = v56;
                int v88 = 8;
              }
              BOOL v89 = v58 == 255;
              if (v58 == 255) {
                unsigned int v58 = v85;
              }
              else {
                unsigned int v58 = v83;
              }
              if (v89) {
                int v60 = v86;
              }
              else {
                uint64_t v59 = v82;
              }
              uint64_t v14 = v16;
              if (v89) {
                int v81 = v87;
              }
              if (v89) {
                int v56 = v84;
              }
              if (v89) {
                int v57 = v88;
              }
              else {
                int v57 = 8;
              }
              v56 += v58;
            }
            int v90 = 2 * v54;
            v56 *= 2;
            --v57;
            BOOL v91 = v54 < 0x400000;
            v54 *= 2;
          }
          while (v91);
          signed int v54 = v56 >= v90 - 0x800000 ? v90 - 0x800000 : v56;
          int v55 = v90 - v54;
          v56 -= v54;
          if (v73) {
            break;
          }
LABEL_625:
          ++v66;
          ++v67;
          BOOL v250 = __OFSUB__(v68--, 1);
          if ((v68 < 0) ^ v250 | (v68 == 0)) {
            goto LABEL_627;
          }
        }
        int v92 = v54 - 5636352;
        if (v54 >= 5636352)
        {
          int v95 = 0;
          goto LABEL_205;
        }
        v55 += v92;
        int v93 = v56 + v92;
        if (v56 + v92 < 0)
        {
          int v93 = v56 + v54;
          BOOL v94 = v55 > 5636351;
          int v55 = 5636352;
          goto LABEL_167;
        }
        if (v55 >= 0x800000)
        {
          v54 -= 5636352;
        }
        else
        {
          BOOL v94 = v55 < 5636352;
LABEL_167:
          if (v94) {
            int v95 = 2;
          }
          else {
            int v95 = 0;
          }
          int v97 = v60;
          do
          {
            if (!v57)
            {
              int v98 = v59 + 1;
              unsigned int v99 = *v59;
              unsigned int v100 = v93 + v99;
              if (v99 >= 0x90) {
                int v101 = 255;
              }
              else {
                int v101 = *v59;
              }
              if (v99 >= 0x90)
              {
                int v102 = v97 + 1;
              }
              else
              {
                ++v59;
                int v102 = v60;
              }
              if (v99 < 0x90) {
                int v103 = v97;
              }
              else {
                int v103 = v97 + 1;
              }
              if (v99 < 0x90)
              {
                int v104 = 7;
              }
              else
              {
                unsigned int v100 = v93;
                int v104 = 8;
              }
              BOOL v105 = v58 == 255;
              if (v58 == 255) {
                unsigned int v58 = v101;
              }
              else {
                unsigned int v58 = v99;
              }
              if (v105) {
                int v60 = v102;
              }
              else {
                uint64_t v59 = v98;
              }
              uint64_t v14 = v16;
              if (v105) {
                int v97 = v103;
              }
              if (v105) {
                int v93 = v100;
              }
              if (v105) {
                int v57 = v104;
              }
              else {
                int v57 = 8;
              }
              v93 += v58;
            }
            int v106 = 2 * v55;
            v93 *= 2;
            --v57;
            BOOL v91 = v55 < 0x400000;
            v55 *= 2;
          }
          while (v91);
          if (v93 >= v106 - 0x800000) {
            int v92 = v106 - 0x800000;
          }
          else {
            int v92 = v93;
          }
          int v55 = v106 - v92;
          int v56 = v93 - v92;
LABEL_205:
          signed int v54 = v92 - 5636352;
          if (v92 >= 5636352) {
            goto LABEL_245;
          }
          v55 += v54;
          int v93 = v54 + v56;
          if (v54 + v56 < 0)
          {
            int v93 = v92 + v56;
            BOOL v107 = v55 > 5636351;
            int v55 = 5636352;
            goto LABEL_210;
          }
          if (v55 < 0x800000)
          {
            BOOL v107 = v55 < 5636352;
LABEL_210:
            int v108 = v60;
            do
            {
              if (!v57)
              {
                unsigned int v110 = v59 + 1;
                unsigned int v109 = *v59;
                unsigned int v111 = v93 + v109;
                if (v109 >= 0x90) {
                  int v112 = 255;
                }
                else {
                  int v112 = *v59;
                }
                if (v109 >= 0x90)
                {
                  int v113 = v108 + 1;
                }
                else
                {
                  ++v59;
                  int v113 = v60;
                }
                if (v109 < 0x90) {
                  int v114 = v108;
                }
                else {
                  int v114 = v108 + 1;
                }
                if (v109 < 0x90)
                {
                  int v115 = 7;
                }
                else
                {
                  unsigned int v111 = v93;
                  int v115 = 8;
                }
                BOOL v116 = v58 == 255;
                if (v58 == 255) {
                  unsigned int v58 = v112;
                }
                else {
                  unsigned int v58 = v109;
                }
                uint64_t v14 = v16;
                if (v116) {
                  int v60 = v113;
                }
                else {
                  uint64_t v59 = v110;
                }
                if (v116) {
                  int v108 = v114;
                }
                if (v116) {
                  int v93 = v111;
                }
                if (v116) {
                  int v57 = v115;
                }
                else {
                  int v57 = 8;
                }
                v93 += v58;
              }
              int v117 = 2 * v55;
              v93 *= 2;
              --v57;
              BOOL v91 = v55 < 0x400000;
              v55 *= 2;
            }
            while (v91);
            v95 |= v107;
            if (v93 >= v117 - 0x800000) {
              signed int v54 = v117 - 0x800000;
            }
            else {
              signed int v54 = v93;
            }
            int v55 = v117 - v54;
            int v56 = v93 - v54;
LABEL_245:
            unsigned int v118 = 0;
            unsigned int v119 = 0;
            unsigned int v120 = 0;
            int v121 = 0;
            switch(v95)
            {
              case 0:
                goto LABEL_285;
              case 1:
                goto LABEL_383;
              case 2:
                goto LABEL_478;
              case 3:
                goto LABEL_578;
              default:
                goto LABEL_93;
            }
          }
        }
        int v56 = v93;
LABEL_1585:
        *(void *)&long long v616 = __PAIR64__(v581, v62);
        *((void *)&v616 + 1) = v61;
        BYTE4(v614) = 0;
        LODWORD(v612) = v55 + v54;
        DWORD1(v612) = v56 + v54;
        *((void *)&v612 + 1) = __PAIR64__(v58, v57);
        *((void *)&v613 + 1) = v59;
LABEL_1586:
        LODWORD(v614) = v60;
        int v20 = v606;
LABEL_1587:
        uint64_t v15 = a2;
        unint64_t v569 = v605;
        if ((*((unsigned char *)a2 + 28) & 0x20) != 0 && v602 == 2)
        {
          v609[0] = 0;
          mq_decoder::mq_decode_run((mq_decoder *)&v612, v609);
          int v570 = v609[0];
          mq_decoder::mq_decode_run((mq_decoder *)&v612, v609);
          uint64_t v15 = a2;
          if (v609[0] + 4 * v570 == 10 || !*((unsigned char *)a2 + 37) && !*((unsigned char *)a2 + 36))
          {
            int v20 = v606;
            uint64_t v14 = v16;
            unint64_t v569 = v605;
            goto LABEL_1593;
          }
          int v572 = v605 - 2;
          if (v605 < 2) {
            int v572 = 0;
          }
          if (v583 && v584 > v572) {
            int v572 = v584;
          }
          *((_DWORD *)a2 + 12) = v572;
          mq_decoder::finish((mq_decoder *)&v612, 0);
          uint64_t v15 = a2;
LABEL_1605:
          if (*((unsigned char *)v15 + 37))
          {
            uint64_t v611 = 0;
            *(_OWORD *)v609 = 0u;
            long long v610 = 0u;
            kdu_error::kdu_error((kdu_error *)v609, "Kakadu Core Error:\n");
            (*(void (**)(int *, const char *))(*(void *)v609 + 16))(v609, "Encountered incorrectly terminated codeword segment, or invalid SEGMARK symbol in code-block bit-stream.  You may like to use the \"resilient\" mode to recover from and conceal such errors.");
            kdu_error::~kdu_error((kdu_error *)v609);
          }
          uint64_t v12 = v604;
          if (!*((unsigned char *)v15 + 120))
          {
            *((unsigned char *)v15 + 120) = 1;
            uint64_t v611 = 0;
            *(_OWORD *)v609 = 0u;
            long long v610 = 0u;
            kdu_warning::kdu_warning((kdu_warning *)v609, "Kakadu Core Warning:\n");
            (*(void (**)(int *, const char *))(*(void *)v609 + 16))(v609, "One or more corrupted block bit-streams detected.\n");
            kdu_warning::~kdu_warning((kdu_warning *)v609);
            uint64_t v15 = a2;
            uint64_t v12 = v604;
          }
          goto LABEL_16;
        }
LABEL_1593:
        int v33 = v595 - 1;
        if (v595 == 1)
        {
          char v571 = mq_decoder::finish((mq_decoder *)&v612, v583 & !v588);
          uint64_t v15 = a2;
          int v20 = v606;
          uint64_t v14 = v16;
          unint64_t v569 = v605;
          int v33 = 0;
          if ((v571 & 1) == 0)
          {
            *((_DWORD *)a2 + 12) = v584;
            if ((*((unsigned char *)a2 + 28) & 0x20) != 0 && (int)v605 - v602 > v584) {
              *((_DWORD *)a2 + 12) = v605 - v602;
            }
            goto LABEL_1605;
          }
        }
        unint64_t v32 = v569 + 1;
        int v34 = v602 + 1;
        v597 += 4;
        int v28 = v36;
      }
      while (v32 != v594);
    }
    BOOL v91 = v578-- <= 1;
    uint64_t v12 = v604;
    if (!v91) {
      continue;
    }
    return kdu_block::finish_timing((clock_t)v15);
  }
}

void sub_1886BA1A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
}

void kd_block_decoder::~kd_block_decoder(kd_block_decoder *this)
{
  *(void *)this = &unk_1ED4E5520;
}

{
  *(void *)this = &unk_1ED4E5520;
  JUMPOUT(0x18C11C0E0);
}

void kdu_decoder::kdu_decoder(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1886BA2F0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4039ECD5E3);
  _Unwind_Resume(a1);
}

int32x4_t *kd_decoder::init(uint64_t a1, int32x4_t *a2, uint64_t a3, int a4, float a5, uint64_t a6, kdu_thread_entity *a7, char *a8)
{
  char v35 = a2;
  int v8 = (void *)(a1 + 88);
  if (*(void *)(a1 + 88) || *(void *)(a1 + 120)) {
    kd_decoder::init();
  }
  if (a7) {
    *(void *)(a1 + 120) = kdu_thread_entity::add_queue((uint64_t)a7, a1 + 8, a8, (uint64_t)"block decoder");
  }
  *(void *)(a1 + 24) = a2;
  *(_WORD *)(a1 + 32) = kdu_subband::get_K_max((kdu_subband *)&v35);
  __int16 K_max_prime = kdu_subband::get_K_max_prime((kdu_subband *)&v35);
  *(_WORD *)(a1 + 34) = K_max_prime;
  if (*(__int16 *)(a1 + 32) > K_max_prime)
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  *(unsigned char *)(a1 + 36) = kdu_subband::get_reversible((kdu_subband *)&v35);
  *(unsigned char *)(a1 + 37) = 0;
  *(float *)(a1 + 40) = kdu_subband::get_delta((kdu_subband *)&v35) * a5;
  int32x4_t v34 = 0uLL;
  kdu_subband::get_dims(&v35, &v34);
  int32x2_t v32 = 0;
  int32x2_t v33 = 0;
  kdu_subband::get_block_size((uint64_t *)&v35, &v33, &v32);
  __n128 result = kdu_subband::get_valid_blocks((kdu_subband *)&v35, (int32x4_t *)(a1 + 44));
  __int32 v17 = v34.i32[2];
  *(void *)(a1 + 60) = v34.i64[1];
  __int16 v18 = v32.i16[0];
  *(_WORD *)(a1 + 70) = v32.i16[2];
  *(_WORD *)(a1 + 72) = v18;
  __int16 v19 = v33.i16[0];
  *(_WORD *)(a1 + 74) = v33.i16[2];
  *(_WORD *)(a1 + 76) = v19;
  *(unsigned char *)(a1 + 39) = 1;
  if (!a7)
  {
    *(_WORD *)(a1 + 78) = v19;
    clock_t v24 = (_WORD *)(a1 + 78);
    *(_WORD *)(a1 + 68) = 0;
    LOWORD(v21) = v17;
    if (v17 > v19) {
      goto LABEL_24;
    }
    goto LABEL_23;
  }
  __n128 result = (int32x4_t *)kdu_thread_entity::get_num_threads(a7);
  int v20 = *(__int16 *)(a1 + 76);
  int v21 = *(_DWORD *)(a1 + 60);
  if ((int)result > 1)
  {
    uint64_t v22 = *(__int16 *)(a1 + 76);
    if (v21 < v20) {
      uint64_t v22 = v21;
    }
    unint64_t v23 = (v22 * *(int *)(a1 + 64) + (v22 * *(int *)(a1 + 64) < 0 ? 0x1FFFuLL : 0)) >> 13;
    if (*(_DWORD *)(a1 + 56) <= (int)v23) {
      kd_decoder::init();
    }
    if ((int)v23 <= 1) {
      LODWORD(v23) = 1;
    }
    if (v23 >= 0x20) {
      LOBYTE(v23) = 32;
    }
    *(unsigned char *)(a1 + 39) = v23;
  }
  *(_WORD *)(a1 + 78) = v20;
  clock_t v24 = (_WORD *)(a1 + 78);
  *(_WORD *)(a1 + 68) = 0;
  if (v21 <= v20)
  {
LABEL_23:
    *clock_t v24 = v21;
    goto LABEL_24;
  }
  __n128 result = (int32x4_t *)kdu_thread_entity::get_num_threads(a7);
  if ((int)result >= 2)
  {
    signed int v25 = 8u / *(unsigned __int8 *)(a1 + 39) + 1;
    __n128 result = (int32x4_t *)kdu_subband::get_band_idx((kdu_subband *)&v35);
    if ((int)result <= v25)
    {
      int v26 = *(_DWORD *)(a1 + 60) - *(__int16 *)(a1 + 72);
      if (v26 >= *(__int16 *)(a1 + 76)) {
        LOWORD(v26) = *(_WORD *)(a1 + 76);
      }
      *(_WORD *)(a1 + 78) += v26;
      uint64_t v31 = kdu_node::access_resolution((kdu_node *)&v35);
      __n128 result = (int32x4_t *)kdu_resolution::get_dwt_level((kdu_resolution *)&v31);
      *(_WORD *)(a1 + 68) = 64 - (_WORD)result;
    }
  }
LABEL_24:
  __int32 v27 = 0;
  *(unsigned char *)(a1 + 38) = 0;
  *(void *)(a1 + 80) = 0;
  __int32 v28 = *(_DWORD *)(a1 + 64);
  if (v32.i32[1] < v28)
  {
    if (a4) {
      int v29 = 7;
    }
    else {
      int v29 = 3;
    }
    __int32 v27 = v29 & -v32.i32[1];
    *(unsigned char *)(a1 + 38) = v27;
  }
  *int v8 = 0;
  v8[1] = 0;
  v8[2] = 0;
  if (v34.i32[3] >= 1 && *(uint64_t *)((char *)v34.i64 + 4) > 0)
  {
    *(void *)(a1 + 88) = a3;
    kdu_sample_allocator::pre_alloc(a3, a4, 0, v28 + v27 + 3, *(__int16 *)(a1 + 78));
    operator new[]();
  }
  *(_DWORD *)(a1 + 60) = 0;
  return result;
}

void kd_decoder::~kd_decoder(kd_decoder *this)
{
  *(void *)this = &unk_1ED4DE8B0;
  *((void *)this + 1) = &unk_1ED4DE8E8;
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x20C8093837F09);
  }
  uint64_t v3 = *((void *)this + 13);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x20C8093837F09);
  }
  uint64_t v4 = *((void *)this + 2);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  *((void *)this + 1) = &unk_1ED4DE9F0;
  *(void *)this = &unk_1ED4E44E0;
}

{
  uint64_t vars8;

  kd_decoder::~kd_decoder(this);

  JUMPOUT(0x18C11C0E0);
}

void non-virtual thunk to'kd_decoder::~kd_decoder(kd_decoder *this)
{
}

{
  uint64_t vars8;

  kd_decoder::~kd_decoder((kd_decoder *)((char *)this - 8));

  JUMPOUT(0x18C11C0E0);
}

uint64_t kd_decoder::start(uint64_t result, kdu_thread_entity *this)
{
  uint64_t v2 = result;
  if (!*(unsigned char *)(result + 37) && *(_DWORD *)(result + 64) && *(_DWORD *)(result + 60))
  {
    if (this) {
      __n128 result = kdu_thread_entity::acquire_lock(this, 3, 1);
    }
    int v4 = *(__int16 *)(v2 + 78);
    if (*(void *)(v2 + 96))
    {
      if (v4 >= 1)
      {
        uint64_t v5 = 0;
        int v6 = *(unsigned __int8 *)(v2 + 38);
        do
        {
          __n128 result = kdu_sample_allocator::alloc16(*(kdu_sample_allocator **)(v2 + 88), 0, *(_DWORD *)(v2 + 64) + v6 + 3);
          int v6 = *(unsigned __int8 *)(v2 + 38);
          *(void *)(*(void *)(v2 + 96) + 8 * v5++) = result + 2 * *(unsigned __int8 *)(v2 + 38);
        }
        while (v5 < *(__int16 *)(v2 + 78));
      }
    }
    else if (v4 >= 1)
    {
      uint64_t v7 = 0;
      int v8 = *(unsigned __int8 *)(v2 + 38);
      do
      {
        __n128 result = kdu_sample_allocator::alloc32(*(kdu_sample_allocator **)(v2 + 88), 0, *(_DWORD *)(v2 + 64) + v8 + 3);
        int v8 = *(unsigned __int8 *)(v2 + 38);
        *(void *)(*(void *)(v2 + 104) + 8 * v7++) = result + 4 * *(unsigned __int8 *)(v2 + 38);
      }
      while (v7 < *(__int16 *)(v2 + 78));
    }
    *(unsigned char *)(v2 + 37) = 1;
    if (this)
    {
      kdu_thread_entity::release_lock(this, 3);
      uint64_t v9 = *(kdu_thread_queue **)(v2 + 120);
      int v10 = *(unsigned __int8 *)(v2 + 39);
      return kdu_thread_entity::add_jobs((uint64_t)this, v9, v10, 0);
    }
  }
  else
  {
    *(unsigned char *)(result + 37) = 1;
  }
  return result;
}

unsigned __int16 *kd_decoder::pull(unsigned __int16 *result, uint64_t a2, kdu_thread_entity *this)
{
  uint64_t v5 = result;
  if (!this && *((void *)result + 15)) {
    kd_decoder::pull();
  }
  if (*(_DWORD *)a2 > *((_DWORD *)result + 28))
  {
    if (!*((unsigned char *)result + 37)) {
      __n128 result = (unsigned __int16 *)(*(uint64_t (**)(unsigned __int16 *, kdu_thread_entity *))(*(void *)result + 16))(result, this);
    }
    if (*((int *)v5 + 15) >= 1)
    {
      int v6 = v5[40];
      if (v6 == v5[41])
      {
        v5[40] = 0;
        uint64_t v7 = (kdu_thread_queue *)*((void *)v5 + 15);
        if (v7)
        {
          if (v5[34])
          {
            int v8 = (__int16)v5[38];
            if ((__int16)v5[39] <= v8) {
              kd_decoder::pull();
            }
            if (*((_DWORD *)v5 + 21))
            {
              if ((__int16)v6 <= v8) {
                v5[40] = v8;
              }
            }
            else
            {
              kdu_thread_entity::add_jobs((uint64_t)this, v7, *((unsigned __int8 *)v5 + 39), v5[34]);
              uint64_t v7 = (kdu_thread_queue *)*((void *)v5 + 15);
            }
          }
          kdu_thread_entity::process_jobs(this, v7, 0, 1);
        }
        else
        {
          if (*((unsigned char *)v5 + 39) != 1) {
            kd_decoder::pull();
          }
          (*(void (**)(unsigned __int16 *, kdu_thread_entity *, void))(*(void *)v5 + 32))(v5, this, *((unsigned int *)v5 + 21));
        }
        int v9 = *((_DWORD *)v5 + 21);
        if (v9)
        {
          int v10 = *((_DWORD *)v5 + 15);
          unsigned __int16 v11 = v5[40];
          BOOL v12 = v10 < (__int16)v5[38];
          signed __int16 v13 = v11 + v10;
          if (!v12) {
            signed __int16 v13 = v11 + v5[38];
          }
        }
        else
        {
          signed __int16 v13 = v5[36];
        }
        v5[41] = v13;
        if ((__int16)v5[39] < v13) {
          kd_decoder::pull();
        }
        *((_DWORD *)v5 + 21) = v9 + 1;
      }
      int v14 = *((_DWORD *)v5 + 16);
      uint64_t v15 = *((int *)v5 + 28);
      if (*(_DWORD *)a2 != v15 + v14) {
        kd_decoder::pull();
      }
      uint64_t v16 = *((void *)v5 + 13);
      uint64_t v17 = *(void *)(a2 + 8);
      if (v16)
      {
        if ((*(unsigned char *)(a2 + 6) & 2) != 0) {
          uint64_t v17 = 0;
        }
        __int16 v18 = (void *)(v17 + 4 * v15);
        __int16 v19 = *(const void **)(v16 + 8 * (__int16)v5[40]);
        int v20 = 4 * v14;
      }
      else
      {
        if ((*(unsigned char *)(a2 + 6) & 2) != 0) {
          uint64_t v21 = *(void *)(a2 + 8);
        }
        else {
          uint64_t v21 = 0;
        }
        __int16 v18 = (void *)(v21 + 2 * v15);
        __int16 v19 = *(const void **)(*((void *)v5 + 12) + 8 * (__int16)v5[40]);
        int v20 = 2 * v14;
      }
      __n128 result = (unsigned __int16 *)memcpy(v18, v19, v20);
      int v22 = *((_DWORD *)v5 + 15);
      int v23 = v22 - 1;
      *((_DWORD *)v5 + 15) = v22 - 1;
      signed __int16 v24 = v5[40] + 1;
      v5[40] = v24;
      signed int v25 = (kdu_thread_queue *)*((void *)v5 + 15);
      if (v25 && v24 >= (__int16)v5[41] && v22 >= 2)
      {
        int v26 = v5[34];
        if (!v5[34]) {
          goto LABEL_40;
        }
        int v27 = (__int16)v5[38];
        if ((__int16)v5[39] <= v27) {
          kd_decoder::pull();
        }
        if (v23 <= v27)
        {
          int v29 = this;
          int v28 = 0;
          int v26 = 0;
        }
        else
        {
LABEL_40:
          int v28 = *((unsigned __int8 *)v5 + 39);
          int v29 = this;
        }
        return (unsigned __int16 *)kdu_thread_entity::add_jobs((uint64_t)v29, v25, v28, v26);
      }
    }
  }
  return result;
}

void kd_decoder::do_job(kd_decoder *this, kdu_thread_entity *a2, int a3)
{
  uint64_t v3 = a2;
  int v4 = this;
  signed int v5 = *((unsigned __int8 *)this + 39);
  uint64_t v7 = (void *)*((void *)this + 12);
  int v6 = (void *)*((void *)this + 13);
  int v8 = a3 / v5;
  if ((a3 / v5))
  {
    uint64_t v9 = *((__int16 *)this + 38);
    int v10 = &v6[v9];
    if (!v6) {
      int v10 = 0;
    }
    unsigned __int16 v11 = &v7[v9];
    if (!v7) {
      unsigned __int16 v11 = 0;
    }
    if (*((__int16 *)this + 39) > *((__int16 *)this + 38))
    {
      int v6 = v10;
      uint64_t v7 = v11;
    }
  }
  if (v8 >= *((_DWORD *)this + 13)) {
    kd_decoder::do_job();
  }
  int v12 = *((_DWORD *)this + 14);
  uint64_t v13 = *((unsigned int *)this + 12);
  int v102 = v6;
  int v98 = v7;
  if (v5 < 2)
  {
    if (v12 < 1) {
      return;
    }
  }
  else
  {
    int v14 = a3 % v5 * v12;
    int v15 = v14 / v5;
    int v16 = (v12 + v14) / v5;
    int v12 = v16 - v15;
    if (v16 <= v15) {
      kd_decoder::do_job();
    }
    if (v15 >= 1)
    {
      uint64_t v13 = (v15 + v13);
      int v17 = *((__int16 *)this + 35) + (v15 - 1) * *((__int16 *)this + 37);
      goto LABEL_15;
    }
  }
  int v17 = 0;
LABEL_15:
  __int16 v18 = (uint64_t *)((char *)this + 24);
  unsigned int v100 = (uint64_t *)((char *)this + 24);
  uint64_t v101 = (v8 + *((_DWORD *)this + 11));
  do
  {
    uint64_t v19 = kdu_subband::open_block(v18, v101 | (v13 << 32), 0, v3);
    if (!v19
      || ((uint64_t v20 = v19,
           (*(void (**)(void, uint64_t))(**((void **)v4 + 2) + 16))(*((void *)v4 + 2), v19),
           *(unsigned char *)(v20 + 24))
        ? (int v21 = *(_DWORD *)(v20 + 16))
        : (int v21 = *(_DWORD *)(v20 + 20)),
          *(unsigned char *)(v20 + 24) ? (uint64_t v22 = *(unsigned int *)(v20 + 20)) : (uint64_t v22 = *(unsigned int *)(v20 + 16)),
          v21 + v17 > *((_DWORD *)v4 + 16)))
    {
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = -50;
      __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
    }
    int v104 = v21 + v17;
    if (*(_DWORD *)(v20 + 48))
    {
      if (*((__int16 *)v4 + 17) > *((__int16 *)v4 + 16)) {
        kd_decoder::adjust_roi_background((uint64_t)v4, (kdu_block *)v20);
      }
      uint64_t v23 = *(int *)(v20 + 4);
      uint64_t v24 = *(void *)(v20 + 96) + 4 * *(_DWORD *)(v20 + 8) * (int)v23 + 4 * *(int *)(v20 + 12);
      uint64_t v25 = (int)v22 - 1;
      if (*(unsigned char *)(v20 + 26)) {
        int v26 = v21 - 1;
      }
      else {
        int v26 = 0;
      }
      if (*(unsigned char *)(v20 + 26)) {
        uint64_t v27 = -1;
      }
      else {
        uint64_t v27 = 1;
      }
      int v28 = v4;
      if (*(unsigned char *)(v20 + 25)) {
        uint64_t v29 = -1;
      }
      else {
        uint64_t v29 = 1;
      }
      int v30 = v26 + v17;
      if (!*(unsigned char *)(v20 + 25)) {
        uint64_t v25 = 0;
      }
      int v31 = *((unsigned __int8 *)v28 + 36);
      if (v102)
      {
        int32x2_t v32 = &v102[v25];
        if (v31)
        {
          int v33 = *((__int16 *)this + 16);
          if (v33 >= 32)
          {
            uint64_t v107 = 0;
            long long v105 = 0u;
            long long v106 = 0u;
            kdu_error::kdu_error((kdu_error *)&v105, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "Insufficient implementation precision available for true reversible processing!");
            kdu_error::~kdu_error((kdu_error *)&v105);
          }
          char v34 = 31 - v33;
          if (*(unsigned char *)(v20 + 24))
          {
            uint64_t v3 = a2;
            if (v22)
            {
              uint64_t v35 = v30;
              uint64_t v36 = 4 * v23;
              do
              {
                if (v21)
                {
                  uint64_t v37 = 0;
                  int v38 = (unsigned int *)(*v32 + 4 * v35);
                  int v39 = v21;
                  do
                  {
                    int v40 = *(_DWORD *)(v24 + v37);
                    if (v40 < 0) {
                      unsigned int v41 = -((v40 & 0x7FFFFFFFu) >> v34);
                    }
                    else {
                      unsigned int v41 = v40 >> v34;
                    }
                    *int v38 = v41;
                    v38 += v27;
                    v37 += v36;
                    --v39;
                  }
                  while (v39);
                }
                v32 += v29;
                v24 += 4;
                LODWORD(v22) = v22 - 1;
              }
              while (v22);
            }
          }
          else
          {
            uint64_t v3 = a2;
            if (v22)
            {
              uint64_t v60 = v30;
              uint64_t v61 = 4 * v23;
              do
              {
                if (v21)
                {
                  uint64_t v62 = 0;
                  uint64_t v63 = (unsigned int *)(*v32 + 4 * v60);
                  do
                  {
                    int v64 = *(_DWORD *)(v24 + 4 * v62);
                    if (v64 < 0) {
                      unsigned int v65 = -((v64 & 0x7FFFFFFFu) >> v34);
                    }
                    else {
                      unsigned int v65 = v64 >> v34;
                    }
                    *uint64_t v63 = v65;
                    v63 += v27;
                    ++v62;
                  }
                  while (v21 != v62);
                }
                v32 += v29;
                v24 += v61;
                LODWORD(v22) = v22 - 1;
              }
              while (v22);
            }
          }
        }
        else
        {
          float v54 = *((float *)this + 10);
          int v55 = *((__int16 *)this + 16);
          if (v55 > 31) {
            float v56 = v54 * (float)(1 << (v55 - 31));
          }
          else {
            float v56 = v54 / (float)(int)(0x80000000 >> v55);
          }
          if (*(unsigned char *)(v20 + 24))
          {
            if (v22)
            {
              uint64_t v69 = v30;
              uint64_t v70 = 4 * v23;
              do
              {
                if (v21)
                {
                  uint64_t v71 = 0;
                  int v72 = (float *)(*v32 + 4 * v69);
                  int v73 = v21;
                  do
                  {
                    int v74 = *(_DWORD *)(v24 + v71);
                    if (v74 < 0) {
                      int v74 = -(v74 & 0x7FFFFFFF);
                    }
                    *int v72 = v56 * (float)v74;
                    v72 += v27;
                    v71 += v70;
                    --v73;
                  }
                  while (v73);
                }
                v32 += v29;
                v24 += 4;
                LODWORD(v22) = v22 - 1;
              }
              while (v22);
            }
          }
          else if (v22)
          {
            uint64_t v75 = v30;
            do
            {
              if (v21)
              {
                uint64_t v76 = 0;
                signed int v77 = (float *)(*v32 + 4 * v75);
                do
                {
                  int v78 = *(_DWORD *)(v24 + 4 * v76);
                  if (v78 < 0) {
                    int v78 = -(v78 & 0x7FFFFFFF);
                  }
                  float *v77 = v56 * (float)v78;
                  v77 += v27;
                  ++v76;
                }
                while (v21 != v76);
              }
              v32 += v29;
              v24 += 4 * v23;
              LODWORD(v22) = v22 - 1;
            }
            while (v22);
          }
        }
      }
      else
      {
        BOOL v45 = &v98[v25];
        if (v31)
        {
          int v46 = *((__int16 *)this + 16);
          if (v46 >= 32)
          {
            uint64_t v107 = 0;
            long long v105 = 0u;
            long long v106 = 0u;
            kdu_error::kdu_error((kdu_error *)&v105, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "Need 32 bits for 16-bit dequantized values");
            kdu_error::~kdu_error((kdu_error *)&v105);
          }
          char v47 = 31 - v46;
          if (*(unsigned char *)(v20 + 24))
          {
            uint64_t v3 = a2;
            if (v22)
            {
              uint64_t v48 = v30;
              uint64_t v49 = 4 * v23;
              do
              {
                if (v21)
                {
                  uint64_t v50 = 0;
                  int v51 = (_WORD *)(*v45 + 2 * v48);
                  int v52 = v21;
                  do
                  {
                    signed int v53 = *(_DWORD *)(v24 + v50);
                    if (v53 < 0) {
                      signed int v53 = -((v53 & 0x7FFFFFFFu) >> v47);
                    }
                    else {
                      LOWORD(v53) = v53 >> v47;
                    }
                    _WORD *v51 = v53;
                    v51 += v27;
                    v50 += v49;
                    --v52;
                  }
                  while (v52);
                }
                v45 += v29;
                v24 += 4;
                LODWORD(v22) = v22 - 1;
              }
              while (v22);
            }
          }
          else
          {
            uint64_t v3 = a2;
            if (v22)
            {
              uint64_t v79 = v30;
              uint64_t v80 = 4 * v23;
              do
              {
                if (v21)
                {
                  uint64_t v81 = 0;
                  int v82 = (_WORD *)(*v45 + 2 * v79);
                  do
                  {
                    signed int v83 = *(_DWORD *)(v24 + 4 * v81);
                    if (v83 < 0) {
                      signed int v83 = -((v83 & 0x7FFFFFFFu) >> v47);
                    }
                    else {
                      LOWORD(v83) = v83 >> v47;
                    }
                    *int v82 = v83;
                    v82 += v27;
                    ++v81;
                  }
                  while (v21 != v81);
                }
                v45 += v29;
                v24 += v80;
                LODWORD(v22) = v22 - 1;
              }
              while (v22);
            }
          }
        }
        else
        {
          float v66 = *((float *)this + 10) * 8192.0;
          int v67 = *((__int16 *)this + 16);
          if (v67 > 31) {
            float v68 = v66 * (float)(1 << (v67 - 31));
          }
          else {
            float v68 = v66 / (float)(int)(0x80000000 >> v67);
          }
          int v84 = (int)(float)((float)(v68 * 4295000000.0) + 0.5);
          if (*(unsigned char *)(v20 + 24))
          {
            if (v22)
            {
              uint64_t v85 = v30;
              uint64_t v86 = 4 * v23;
              do
              {
                if (v21)
                {
                  uint64_t v87 = 0;
                  int v88 = (_WORD *)(*v45 + 2 * v85);
                  int v89 = v21;
                  do
                  {
                    int v90 = *(_DWORD *)(v24 + v87);
                    if (v90 < 0) {
                      int v90 = -(v90 & 0x7FFFFFFF);
                    }
                    *int v88 = (((v90 + 0x8000) >> 16) * v84 + 0x8000) >> 16;
                    v88 += v27;
                    v87 += v86;
                    --v89;
                  }
                  while (v89);
                }
                v45 += v29;
                v24 += 4;
                LODWORD(v22) = v22 - 1;
              }
              while (v22);
            }
          }
          else if (v22)
          {
            uint64_t v91 = v30;
            uint64_t v92 = 4 * v23;
            do
            {
              if (v21)
              {
                uint64_t v93 = 0;
                BOOL v94 = (_WORD *)(*v45 + 2 * v91);
                do
                {
                  int v95 = *(_DWORD *)(v24 + 4 * v93);
                  if (v95 < 0) {
                    int v95 = -(v95 & 0x7FFFFFFF);
                  }
                  *BOOL v94 = (((v95 + 0x8000) >> 16) * v84 + 0x8000) >> 16;
                  v94 += v27;
                  ++v93;
                }
                while (v21 != v93);
              }
              v45 += v29;
              v24 += v92;
              LODWORD(v22) = v22 - 1;
            }
            while (v22);
          }
        }
      }
    }
    else if (v102)
    {
      if ((int)v22 >= 1)
      {
        if (v21 >= 4) {
          int v42 = 4;
        }
        else {
          int v42 = v21;
        }
        size_t v43 = 16 * ((v21 - v42 + 3) >> 2) + 16;
        unint64_t v44 = v102;
        do
        {
          if (v21 >= 1) {
            bzero((void *)(*v44 + 4 * v17), v43);
          }
          ++v44;
          --v22;
        }
        while (v22);
      }
    }
    else if ((int)v22 >= 1)
    {
      if (v21 >= 4) {
        int v57 = 4;
      }
      else {
        int v57 = v21;
      }
      size_t v58 = 8 * ((v21 - v57 + 3) >> 2) + 8;
      uint64_t v59 = v98;
      do
      {
        if (v21 >= 1) {
          bzero((void *)(*v59 + 2 * v17), v58);
        }
        ++v59;
        --v22;
      }
      while (v22);
    }
    __int16 v18 = v100;
    kdu_subband::close_block((uint64_t)v100, (kdu_block *)v20, (uint64_t)v3);
    uint64_t v13 = (v13 + 1);
    int v17 = v104;
    BOOL v96 = __OFSUB__(v12--, 1);
    int v4 = this;
  }
  while (!((v12 < 0) ^ v96 | (v12 == 0)));
}

void sub_1886BB3AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886BB3B8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  _Unwind_Resume(v19);
}

uint64_t kd_decoder::adjust_roi_background(uint64_t this, kdu_block *a2)
{
  int v2 = *((_DWORD *)a2 + 1) * ((*(_DWORD *)a2 + 3) >> 2);
  if (4 * v2)
  {
    __int16 v3 = *(_WORD *)(this + 32);
    __int16 v4 = *(_WORD *)(this + 34) - v3;
    int v5 = (-1 << ~(_BYTE)v3) & 0x7FFFFFFF;
    int v6 = (int *)*((void *)a2 + 12);
    int v7 = -4 * v2;
    do
    {
      int v8 = *v6;
      if (*v6) {
        BOOL v9 = (v5 & *v6) == 0;
      }
      else {
        BOOL v9 = 0;
      }
      if (v9)
      {
        if (v8 >= 0) {
          unsigned int v10 = v8 << v4;
        }
        else {
          unsigned int v10 = (v8 << v4) | 0x80000000;
        }
        *int v6 = v10;
      }
      ++v6;
    }
    while (!__CFADD__(v7++, 1));
  }
  return this;
}

void non-virtual thunk to'kd_decoder::do_job(kd_decoder *this, kdu_thread_entity *a2, int a3)
{
}

void kd_decoder::kd_decoder(kd_decoder *this)
{
  *(void *)this = &unk_1ED4DE8B0;
  *((void *)this + 1) = &unk_1ED4DE8E8;
  kdu_block_decoder::kdu_block_decoder((kd_decoder *)((char *)this + 16));
}

void sub_1886BB4D4(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ED4E44E0;
  v1[1] = &unk_1ED4DE9F0;
  _Unwind_Resume(a1);
}

void kdu_analysis::kdu_analysis(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1886BB5BC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B1C405B8F8FE9);
  _Unwind_Resume(a1);
}

float *kd_analysis::init(uint64_t a1, int32x4_t *a2, kdu_sample_allocator *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, double a8)
{
  v174[4] = *MEMORY[0x1E4F143B8];
  int v172 = a2;
  uint64_t v171 = kdu_node::access_resolution((kdu_node *)&v172);
  if (a5)
  {
    if (kdu_resolution::propagate_roi((kdu_resolution *)&v171)) {
      kdu_roi_level::create();
    }
    (*(void (**)(uint64_t))(*(void *)a5 + 16))(a5);
  }
  char reversible = kdu_resolution::get_reversible((kdu_resolution *)&v171);
  *(_OWORD *)(a1 + 48) = 0u;
  int v12 = (int *)(a1 + 48);
  *(unsigned char *)(a1 + 40) = reversible;
  *(unsigned char *)(a1 + 41) = a4;
  *(unsigned char *)(a1 + 42) = 0;
  *(void *)(a1 + 104) = 0;
  *(_WORD *)(a1 + 98) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  char kernel_id = kdu_node::get_kernel_id((kdu_node *)&v172);
  *(void *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 184) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  int32x4_t v170 = 0uLL;
  __n128 result = (float *)kdu_node::get_dims(&v172, &v170);
  __int32 v15 = v170.i32[0];
  int v16 = v170.i32[1];
  __int32 v17 = v170.i32[2];
  int v18 = v170.i32[3];
  __int32 v19 = v170.i32[3] + v170.i32[1];
  __int32 v20 = v170.i32[3] + v170.i32[1] - 1;
  __int32 v21 = v170.i32[0] + v170.i32[2] - 1;
  *(_DWORD *)(a1 + 112) = v170.i32[0];
  *(_DWORD *)(a1 + 116) = v21;
  *(_DWORD *)(a1 + 124) = v16;
  *(_DWORD *)(a1 + 128) = v20;
  BOOL v23 = v18 < 1 || v17 < 1;
  *(unsigned char *)(a1 + 142) = v23;
  *(unsigned char *)(a1 + 140) = v21 == v15;
  *(unsigned char *)(a1 + 141) = v20 == v16;
  if (!v23)
  {
    unsigned int v156 = v18;
    int v157 = v19;
    uint64_t v24 = kdu_node::access_child((kdu_node *)&v172, 0);
    v174[0] = v24;
    uint64_t v25 = kdu_node::access_child((kdu_node *)&v172, 1u);
    v174[1] = v25;
    uint64_t v26 = kdu_node::access_child((kdu_node *)&v172, 2u);
    v174[2] = v26;
    v174[3] = kdu_node::access_child((kdu_node *)&v172, 3u);
    if (!v24) {
      kd_analysis::init();
    }
    *(unsigned char *)(a1 + 43) = v26 != 0;
    int v27 = v25 != 0;
    *(unsigned char *)(a1 + 44) = v27;
    float v168 = 1.0;
    float v169 = 1.0;
    float v166 = 1.0;
    float v167 = 1.0;
    if (v26)
    {
      v173[0] = 0;
      *(void *)unsigned int v165 = 0;
      int v164 = 0;
      uint64_t kernel_info = kdu_node::get_kernel_info((kdu_node *)&v172, (int *)(a1 + 48), &v169, &v168, (BOOL *)(a1 + 96), (BOOL *)(a1 + 98), v173, &v165[1], v165, &v164, 1);
      if (v165[1] <= v164) {
        int v29 = v164;
      }
      else {
        int v29 = v165[1];
      }
      if (v173[0] >= v165[0]) {
        int v30 = v165[0];
      }
      else {
        int v30 = v173[0];
      }
      LODWORD(v31) = *(_DWORD *)(a1 + 48);
      if ((int)v31 > 4) {
        operator new[]();
      }
      uint64_t v32 = a1 + 576;
      *(void *)(a1 + 80) = v32;
      if ((int)v31 < 1)
      {
        int v33 = 0;
        LODWORD(v26) = 0;
      }
      else
      {
        int v33 = 0;
        LODWORD(v26) = 0;
        char v34 = *(unsigned char *)(a1 + 40);
        uint64_t v35 = (_DWORD *)(kernel_info + 8);
        uint64_t v31 = v31;
        do
        {
          *(_WORD *)(v32 + 4) = *(v35 - 1);
          int v36 = *(v35 - 2);
          *(unsigned char *)(v32 + 1) = v36;
          *(unsigned char *)(v32 + 2) = *v35;
          *(_WORD *)(v32 + 6) = v35[1];
          if (v33 <= v36) {
            int v33 = v36;
          }
          *(unsigned char *)(v32 + 30) = kernel_id;
          *(unsigned char *)(v32 + 29) = v34;
          LODWORD(v26) = v36 + v26;
          v32 += 32;
          v35 += 4;
          --v31;
        }
        while (v31);
        if (v33 > 4) {
          operator new[]();
        }
      }
      int v155 = v29 - v30;
      *(void *)(a1 + 56) = a1 + 272 + 8 * v33;
      *(void *)(a1 + 64) = a1 + 272;
      int v27 = *(unsigned __int8 *)(a1 + 44);
    }
    else
    {
      int v155 = 0;
      uint64_t kernel_info = 0;
    }
    uint64_t v37 = (int *)(a1 + 52);
    if (v27)
    {
      v173[0] = 0;
      *(void *)unsigned int v165 = 0;
      int v164 = 0;
      uint64_t v38 = kdu_node::get_kernel_info((kdu_node *)&v172, (int *)(a1 + 52), &v167, &v166, (BOOL *)(a1 + 97), (BOOL *)(a1 + 99), v173, &v165[1], v165, &v164, 0);
      if (v38 == kernel_info)
      {
        uint64_t v40 = *(void *)(a1 + 80);
      }
      else
      {
        uint64_t v39 = *v12;
        if ((int)v39 + *v37 > 4) {
          operator new[]();
        }
        uint64_t v40 = a1 + 32 * v39 + 576;
      }
      *(void *)(a1 + 88) = v40;
      if (v40 != *(void *)(a1 + 80))
      {
        uint64_t v41 = *v37;
        if ((int)v41 >= 1)
        {
          char v42 = *(unsigned char *)(a1 + 40);
          size_t v43 = (_DWORD *)(v38 + 8);
          do
          {
            *(_WORD *)(v40 + 4) = *(v43 - 1);
            int v44 = *(v43 - 2);
            *(unsigned char *)(v40 + 1) = v44;
            *(unsigned char *)(v40 + 2) = *v43;
            *(_WORD *)(v40 + 6) = v43[1];
            *(unsigned char *)(v40 + 30) = kernel_id;
            *(unsigned char *)(v40 + 29) = v42;
            LODWORD(v26) = v44 + v26;
            v40 += 32;
            v43 += 4;
            --v41;
          }
          while (v41);
        }
      }
      *(_DWORD *)(a1 + 132) = ((v157 + 1) >> 1) - ((v16 + 1) >> 1);
      *(_DWORD *)(a1 + 136) = (v157 >> 1) - (v16 >> 1);
    }
    else
    {
      *(void *)(a1 + 132) = v156;
    }
    if ((int)v26 >= 9) {
      operator new[]();
    }
    BOOL v45 = (_DWORD *)(a1 + 208);
    int v46 = (_DWORD *)(a1 + 240);
    if (*(unsigned char *)(a1 + 43))
    {
      uint64_t kernel_coefficients = kdu_node::get_kernel_coefficients((kdu_node *)&v172, 1);
      int v48 = *v12;
      if (*v12 >= 1)
      {
        uint64_t v49 = 0;
        uint64_t v50 = *(void *)(a1 + 80);
        int v51 = *(unsigned __int8 *)(a1 + 40);
        do
        {
          uint64_t v52 = v50 + 32 * v49;
          *(unsigned char *)uint64_t v52 = v49;
          *(void *)(v52 + 8) = v45;
          *(void *)(v52 + 16) = v46;
          *(unsigned char *)(v52 + 28) = 0;
          uint64_t v53 = *(unsigned __int8 *)(v52 + 1);
          if (v53)
          {
            uint64_t v54 = v53;
            int v55 = (float *)kernel_coefficients;
            float v56 = v45;
            float v57 = 0.4;
            do
            {
              float v58 = *v55;
              _DWORD *v56 = *(_DWORD *)v55;
              if (v58 <= v57)
              {
                if (v58 < (float)-v57) {
                  float v57 = -v58;
                }
              }
              else
              {
                float v57 = v58;
              }
              ++v56;
              ++v55;
              --v54;
            }
            while (v54);
            if (v51)
            {
LABEL_64:
              unsigned __int8 v60 = *(unsigned char *)(v50 + 32 * v49 + 2);
              if (v53) {
                goto LABEL_68;
              }
              goto LABEL_71;
            }
            uint64_t v59 = v50 + 32 * v49;
            unsigned __int8 v60 = 16;
            *(unsigned char *)(v59 + 2) = 16;
            uint64_t v61 = (unsigned __int8 *)(v59 + 2);
            if (v57 >= 0.499)
            {
              unsigned __int8 v60 = 16;
              do
              {
                --v60;
                float v57 = v57 * 0.5;
              }
              while (v57 >= 0.499);
              unsigned __int8 *v61 = v60;
              if (v60 < 0x10u)
              {
                *(_WORD *)(v50 + 32 * v49 + 6) = 1 << (v60 - 1);
LABEL_68:
                float v62 = (float)(1 << v60);
                uint64_t v63 = v53;
                int v64 = (float *)v45;
                unsigned int v65 = v46;
                do
                {
                  float v66 = *v64++;
                  *v65++ = vcvtmd_s64_f64((float)(v66 * v62) + 0.5);
                  --v63;
                }
                while (v63);
                int v48 = *v12;
                goto LABEL_71;
              }
            }
          }
          else
          {
            if (v51) {
              goto LABEL_64;
            }
            unsigned __int8 v60 = 16;
            *(unsigned char *)(v50 + 32 * v49 + 2) = 16;
          }
          *(_WORD *)(v50 + 32 * v49 + 6) = 0x7FFF;
          if (v53) {
            goto LABEL_68;
          }
LABEL_71:
          v45 += v53;
          v46 += v53;
          kernel_coefficients += 4 * v53;
          uint64_t v67 = v50 + 32 * v49;
          *(unsigned char *)(v67 + 3) = 0;
          *(_DWORD *)(v67 + 24) = 0;
          ++v49;
        }
        while (v49 < v48);
      }
    }
    if (*(unsigned char *)(a1 + 44))
    {
      uint64_t v68 = kdu_node::get_kernel_coefficients((kdu_node *)&v172, 0);
      if (*v37 >= 1)
      {
        uint64_t v69 = 0;
        int v70 = 0;
        uint64_t v72 = *(void *)(a1 + 80);
        uint64_t v71 = *(void *)(a1 + 88);
        while (1)
        {
          if (v71 == v72)
          {
            uint64_t v83 = v71 + 32 * v69;
            uint64_t v74 = *(unsigned __int8 *)(v83 + 1);
            if (*(unsigned char *)(v83 + 1))
            {
              int v84 = *(float **)(v83 + 8);
              uint64_t v85 = v74;
              uint64_t v86 = (float *)v68;
              do
              {
                if (*v84 != *v86) {
                  kd_analysis::init();
                }
                ++v86;
                ++v84;
                --v85;
              }
              while (v85);
            }
            goto LABEL_102;
          }
          uint64_t v73 = v71 + 32 * v69;
          *(unsigned char *)uint64_t v73 = v69;
          *(_DWORD *)(v73 + 24) = 0;
          *(void *)(v73 + 8) = v45;
          *(void *)(v73 + 16) = v46;
          *(unsigned char *)(v73 + 28) = 0;
          uint64_t v74 = *(unsigned __int8 *)(v73 + 1);
          if (v74)
          {
            uint64_t v75 = v74;
            uint64_t v76 = (float *)v68;
            signed int v77 = v45;
            float v78 = 0.4;
            do
            {
              float v79 = *v76;
              _DWORD *v77 = *(_DWORD *)v76;
              if (v79 <= v78)
              {
                if (v79 < (float)-v78) {
                  float v78 = -v79;
                }
              }
              else
              {
                float v78 = v79;
              }
              ++v77;
              ++v76;
              --v75;
            }
            while (v75);
            if (*(unsigned char *)(a1 + 40))
            {
LABEL_95:
              unsigned __int8 v81 = *(unsigned char *)(v71 + 32 * v69 + 2);
              if (v74) {
                goto LABEL_99;
              }
              goto LABEL_101;
            }
            uint64_t v80 = v71 + 32 * v69;
            unsigned __int8 v81 = 16;
            *(unsigned char *)(v80 + 2) = 16;
            int v82 = (unsigned __int8 *)(v80 + 2);
            if (v78 >= 0.499)
            {
              unsigned __int8 v81 = 16;
              do
              {
                --v81;
                float v78 = v78 * 0.5;
              }
              while (v78 >= 0.499);
              *int v82 = v81;
              if (v81 < 0x10u)
              {
                *(_WORD *)(v71 + 32 * v69 + 6) = 1 << (v81 - 1);
LABEL_99:
                float v87 = (float)(1 << v81);
                uint64_t v88 = v74;
                int v89 = (float *)v45;
                int v90 = v46;
                do
                {
                  float v91 = *v89++;
                  *v90++ = vcvtmd_s64_f64((float)(v91 * v87) + 0.5);
                  --v88;
                }
                while (v88);
                goto LABEL_101;
              }
            }
          }
          else
          {
            if (*(unsigned char *)(a1 + 40)) {
              goto LABEL_95;
            }
            unsigned __int8 v81 = 16;
            *(unsigned char *)(v71 + 32 * v69 + 2) = 16;
          }
          *(_WORD *)(v71 + 32 * v69 + 6) = 0x7FFF;
          if (v74) {
            goto LABEL_99;
          }
LABEL_101:
          v45 += v74;
          v46 += v74;
LABEL_102:
          uint64_t v92 = v71 + 32 * v69;
          int v93 = *(__int16 *)(v92 + 4);
          if (v69) {
            int v94 = -1;
          }
          else {
            int v94 = 1;
          }
          int v95 = (*(unsigned __int8 *)(a1 + 124) << 31 >> 31) & v94;
          if (v69) {
            int v96 = 1;
          }
          else {
            int v96 = -1;
          }
          int v97 = v95 - v93;
          if (*(unsigned char *)(a1 + 128)) {
            int v96 = 0;
          }
          int v98 = v74 + v93 + v96 - 1;
          if (v97 > v98) {
            int v98 = v97;
          }
          int v99 = v98 & ~(v98 >> 31);
          if (v99 >= 0x100) {
            kd_analysis::init();
          }
          if (v99 > v70) {
            int v70 = v99;
          }
          v68 += 4 * v74;
          *(unsigned char *)(v92 + 3) = v99;
          if (++v69 >= *v37) {
            goto LABEL_118;
          }
        }
      }
    }
    LOBYTE(v70) = 0;
LABEL_118:
    int v100 = *v12;
    if (*v12 <= 0)
    {
      int v103 = *(_DWORD *)(a1 + 132);
      if (v103 <= *(_DWORD *)(a1 + 136)) {
        LOBYTE(v103) = *(_DWORD *)(a1 + 136);
      }
      char v102 = v103 + v70;
      goto LABEL_132;
    }
    if (*(unsigned char *)(a1 + 140))
    {
      int v101 = *(_DWORD *)(a1 + 132);
      if (v101 <= *(_DWORD *)(a1 + 136)) {
        LOBYTE(v101) = *(_DWORD *)(a1 + 136);
      }
      char v102 = v101 + v70;
    }
    else
    {
      if (v100 > 4) {
        operator new[]();
      }
      *(void *)(a1 + 104) = a1 + 752;
      int v104 = *(_DWORD *)(a1 + 132);
      if (v104 <= *(_DWORD *)(a1 + 136)) {
        LOBYTE(v104) = *(_DWORD *)(a1 + 136);
      }
      char v102 = v104 + v70;
      if (v100 < 1) {
        goto LABEL_132;
      }
    }
    if (!*(unsigned char *)(a1 + 140))
    {
      __n128 result = (float *)kd_analysis::simulate_vertical_lifting((kd_analysis *)a1, v155);
      LODWORD(v105) = result;
      if (result >= 7) {
        operator new[]();
      }
      *(void *)(a1 + 72) = 0;
      if (!result)
      {
LABEL_137:
        *(_DWORD *)(a1 + 120) = *(_DWORD *)(a1 + 112);
        LODWORD(v109) = *(_DWORD *)(a1 + 48);
        if (*(void *)(a1 + 104))
        {
          if ((v109 & 0x80000000) != 0)
          {
LABEL_150:
            *(int32x4_t *)int v173 = vdupq_lane_s32(*(int32x2_t *)&a8, 0);
            *(_DWORD *)(a1 + 100) = 0;
            if (!*(unsigned char *)(a1 + 40))
            {
              v165[1] = 0;
              uint64_t bibo_gains = kdu_node::get_bibo_gains((kdu_node *)&v172, &v165[1], 1);
              if (v165[1] != *v12) {
                kd_analysis::init();
              }
              uint64_t v126 = bibo_gains;
              __n128 result = (float *)kdu_node::get_bibo_gains((kdu_node *)&v172, &v165[1], 0);
              uint64_t v127 = v165[1];
              if (v165[1] != *v37) {
                kd_analysis::init();
              }
              uint64_t v128 = *v12;
              float v129 = *(float *)&a8;
              float v130 = *(float *)&a8;
              float v131 = *(float *)&a8;
              if ((int)v128 >= 1)
              {
                float v129 = *(float *)&a8;
                float v130 = *(float *)&a8;
                float v131 = *(float *)&a8;
                if (!*(unsigned char *)(a1 + 140))
                {
                  uint64_t v132 = 0;
                  float v130 = *(float *)&a8 / v169;
                  *(float *)int v173 = *(float *)&a8 / v169;
                  *(float *)&v173[1] = *(float *)&a8 / v169;
                  float v129 = *(float *)&a8 / v168;
                  *(float *)&v173[2] = *(float *)&a8 / v168;
                  *(float *)&v173[3] = *(float *)&a8 / v168;
                  float v133 = *result * *(float *)&a8;
                  uint64_t v134 = (float *)(v126 + 4);
                  float v135 = v133;
                  float v131 = *(float *)&a8;
                  do
                  {
                    float v136 = v135;
                    float v135 = v133 * *v134;
                    if (v135 > v131) {
                      float v131 = v133 * *v134;
                    }
                    if (a4)
                    {
                      float v137 = v136 + v136;
                      if (*(unsigned char *)(*(void *)(a1 + 80) + v132 + 28) && v137 > v131) {
                        float v131 = v137;
                      }
                    }
                    v132 += 32;
                    ++v134;
                  }
                  while (32 * v128 != v132);
                }
              }
              if (v165[1] >= 1 && !*(unsigned char *)(a1 + 141))
              {
                *(float *)int v173 = v130 / v167;
                *(float *)&v173[1] = v130 / v166;
                *(float *)&v173[2] = v129 / v167;
                *(float *)&v173[3] = v129 / v166;
                float v139 = *(float *)(v126 + 4 * (int)v128);
                if ((int)v128 < 1)
                {
                  float v140 = *(float *)&a8;
                }
                else
                {
                  float v140 = *(float *)&a8;
                  if (*(float *)(v126 + 4 * (v128 - 1)) > v139) {
                    float v139 = *(float *)(v126 + 4 * (v128 - 1));
                  }
                }
                float v141 = v139 * v140;
                int v142 = result + 1;
                uint64_t v143 = 28;
                float v144 = v141;
                do
                {
                  float v145 = v144;
                  float v144 = v141 * *v142;
                  if (v144 > v131) {
                    float v131 = v141 * *v142;
                  }
                  if (a4)
                  {
                    float v146 = v145 + v145;
                    if (*(unsigned char *)(*(void *)(a1 + 88) + v143) && v146 > v131) {
                      float v131 = v146;
                    }
                  }
                  v143 += 32;
                  ++v142;
                  --v127;
                }
                while (v127);
              }
              if (v131 > 7.6)
              {
                int v148 = *(_DWORD *)(a1 + 100);
                float32x4_t v149 = *(float32x4_t *)v173;
                v150.i64[0] = 0x3F0000003F000000;
                v150.i64[1] = 0x3F0000003F000000;
                do
                {
                  float32x4_t v149 = vmulq_f32(v149, v150);
                  ++v148;
                  float v131 = v131 * 0.5;
                }
                while (v131 > 7.6);
                *(float32x4_t *)int v173 = v149;
                *(_DWORD *)(a1 + 100) = v148;
              }
            }
            uint64_t v151 = 0;
            uint64_t v152 = 0;
            int v153 = 0;
            do
            {
              if (v174[v151])
              {
                if (kdu_node::access_child((kdu_node *)&v174[v151], 0)) {
                  kdu_analysis::kdu_analysis(&v162);
                }
                uint64_t v154 = kdu_node::access_subband((kdu_node *)&v174[v151]);
                __n128 result = (float *)kdu_encoder::kdu_encoder(&v163, v154, a3, a4, 0, a6, a7, *(float *)&v173[v152]);
                *(void *)(a1 + 8 + v151 * 8) = v163;
              }
              ++v153;
              ++v152;
              ++v151;
            }
            while (v152 != 4);
            return result;
          }
          uint64_t v110 = -1;
          uint64_t v111 = -48;
          do
          {
            int v112 = *(_DWORD *)(a1 + 116);
            int v113 = v112;
            if (v110 >= 1)
            {
              uint64_t v114 = *(void *)(a1 + 80) + 32 * v110;
              int v113 = v112
                   - ((v112 ^ v110) & 1)
                   + 2 * (*(__int16 *)(v114 + 4) + *(unsigned __int8 *)(v114 + 1))
                   - 2;
            }
            __n128 result = (float *)kd_vlift_queue::init(*(void *)(a1 + 104) + v111, *(_DWORD *)(a1 + 112), v112, v110++, *(unsigned char *)(a1 + 98), v113);
            uint64_t v109 = *(int *)(a1 + 48);
            v111 += 48;
          }
          while (v110 < v109);
        }
        if ((int)v109 >= 1)
        {
          int v115 = *(_DWORD *)(a1 + 112);
          uint64_t v116 = v109;
          uint64_t v117 = (v109 + 1) & 0x1FFFFFFFELL;
          uint64x2_t v118 = (uint64x2_t)vdupq_n_s64(v116 - 1);
          int v119 = v115 | 1;
          unsigned int v120 = (v115 | 0xFFFFFFFE) + v115 + 2;
          int64x2_t v121 = (int64x2_t)xmmword_18898C840;
          int v122 = (unsigned int *)(*(void *)(a1 + 80) + 56);
          int64x2_t v123 = vdupq_n_s64(2uLL);
          do
          {
            int32x2_t v124 = vmovn_s64((int64x2_t)vcgeq_u64(v118, (uint64x2_t)v121));
            if (v124.i8[0]) {
              *(v122 - 8) = v119;
            }
            if (v124.i8[4]) {
              unsigned int *v122 = v120;
            }
            int64x2_t v121 = vaddq_s64(v121, v123);
            v122 += 16;
            v117 -= 2;
          }
          while (v117);
        }
        goto LABEL_150;
      }
LABEL_133:
      uint64_t v106 = 0;
      uint64_t v105 = v105;
      do
      {
        uint64_t v107 = *(void *)(a1 + 176);
        int v108 = (void *)(v107 + v106 + 32);
        if (!v107)
        {
          int v108 = (void *)(a1 + 368 + v106);
          uint64_t v107 = a1 + 336;
        }
        void *v108 = *(void *)(a1 + 72);
        *(void *)(a1 + 72) = v107 + v106;
        __n128 result = (float *)kd_vlift_line::pre_create((kd_vlift_line *)(v107 + v106), a3, *(_DWORD *)(a1 + 132), *(_DWORD *)(a1 + 136), *(unsigned char *)(a1 + 40), a4, v70, v102, *(unsigned char *)(a1 + 44));
        v106 += 40;
        --v105;
      }
      while (v105);
      goto LABEL_137;
    }
LABEL_132:
    *(void *)(a1 + 72) = 0;
    LODWORD(v105) = 1;
    goto LABEL_133;
  }
  return result;
}

void kdu_analysis::kdu_analysis(void *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  *a1 = 0;
  operator new();
}

void sub_1886BC4E4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B1C405B8F8FE9);
  _Unwind_Resume(a1);
}

uint64_t kd_analysis::simulate_vertical_lifting(kd_analysis *this, int a2)
{
  int v41 = 0;
  int v3 = *((_DWORD *)this + 28);
  int v4 = *((_DWORD *)this + 29);
  if (v4 - (v3 + a2) - 2 <= 0) {
    unsigned int v5 = 0;
  }
  else {
    unsigned int v5 = (v4 - (v3 + a2) - 2) & 0xFFFFFFFE;
  }
  int v6 = v4 - v5;
  *((_DWORD *)this + 30) = v3;
  if ((*((_DWORD *)this + 12) & 0x80000000) == 0)
  {
    uint64_t v7 = -1;
    uint64_t v8 = -48;
    do
    {
      int v9 = v6;
      if (v7 >= 1)
      {
        uint64_t v10 = *((void *)this + 10) + 32 * v7;
        int v9 = v6
           - ((v4 ^ v7) & 1)
           + 2 * (*(__int16 *)(v10 + 4) + *(unsigned __int8 *)(v10 + 1))
           - 2;
      }
      kd_vlift_queue::init(*((void *)this + 13) + v8, *((_DWORD *)this + 30), v6, v7++, *((unsigned char *)this + 98), v9);
      uint64_t v11 = *((int *)this + 12);
      v8 += 48;
    }
    while (v7 < v11);
    uint64_t v12 = *((unsigned int *)this + 12);
    if ((int)v11 >= 1)
    {
      int v13 = *((_DWORD *)this + 28);
      uint64_t v14 = (v12 + 1) & 0x1FFFFFFFELL;
      uint64x2_t v15 = (uint64x2_t)vdupq_n_s64(v12 - 1);
      int v16 = v13 | 1;
      unsigned int v17 = (v13 | 0xFFFFFFFE) + v13 + 2;
      int64x2_t v18 = (int64x2_t)xmmword_18898C840;
      __int32 v19 = (unsigned int *)(*((void *)this + 10) + 56);
      int64x2_t v20 = vdupq_n_s64(2uLL);
      do
      {
        int32x2_t v21 = vmovn_s64((int64x2_t)vcgeq_u64(v15, (uint64x2_t)v18));
        if (v21.i8[0]) {
          *(v19 - 8) = v16;
        }
        if (v21.i8[4]) {
          *__int32 v19 = v17;
        }
        int64x2_t v18 = vaddq_s64(v18, v20);
        v19 += 16;
        v14 -= 2;
      }
      while (v14);
    }
  }
  int v22 = *((_DWORD *)this + 30);
  if (v22 > v6) {
    return 0;
  }
  LODWORD(result) = 0;
  do
  {
    if (v41 >= (int)result) {
      LODWORD(result) = v41 + 1;
    }
    int v40 = result;
    ++v41;
    kd_vlift_queue::simulate_push_line(*((void *)this + 13) + 48 * -(v22 & 1), v22, &v41);
    int v24 = (*((_DWORD *)this + 30) & 1) == 0;
    do
    {
      if (v24 < 0) {
        break;
      }
      uint64_t v25 = 0;
      char v26 = 0;
      uint64_t v27 = -1;
      uint64_t v28 = 48;
      do
      {
        uint64_t v29 = v27 + 1;
        uint64_t v30 = *((int *)this + 12);
        if (v27 + 1 >= v30) {
          break;
        }
        uint64_t v31 = *((void *)this + 10);
        uint64_t v32 = v31 + v25;
        int v33 = *(_DWORD *)(v31 + v25 + 24);
        int v34 = (v33 ^ 1) + 2 * *(__int16 *)(v31 + v25 + 4);
        if (v33 <= v6)
        {
          uint64_t v35 = *((void *)this + 13);
          *(_DWORD *)(v35 + v28 - 60) = v33;
          if (*(_DWORD *)(v35 + v28 - 72) > v33
            || *(_DWORD *)(v35 + v28 - 68) < v33
            || !kd_vlift_queue::simulate_access_source((kd_vlift_queue *)(v35 + v28 - 48), v34, *(unsigned __int8 *)(v31 + v25 + 1), &v41))
          {
            goto LABEL_36;
          }
          kd_vlift_queue::simulate_access_update((kd_vlift_queue *)(*((void *)this + 13) + v28 - 96), *(_DWORD *)(v32 + 24), &v41);
          int v37 = v40;
          int v36 = v41;
          if (v41 >= v40) {
            int v37 = v41 + 1;
          }
          uint64_t v38 = (*((_DWORD *)this + 12) - 1);
          int v40 = v37;
          ++v41;
          if (v29 == v38)
          {
            int v41 = v36;
            kd_vlift_queue::simulate_access_update((kd_vlift_queue *)(*((void *)this + 13) + v28 - 48), v34, &v41);
          }
          else
          {
            kd_vlift_queue::simulate_push_line(*((void *)this + 13) + v28, *(_DWORD *)(v32 + 24), &v41);
            int v24 = v27 + 3;
          }
        }
        else if (v29 != v30 - 1 {
               || (kd_vlift_queue::simulate_access_update((kd_vlift_queue *)(*((void *)this + 13) + v28 - 48), v34, &v41) & 1) == 0)
        }
        {
          goto LABEL_36;
        }
        *(_DWORD *)(v32 + 24) += 2;
        char v26 = 1;
LABEL_36:
        ++v27;
        v28 += 48;
        v25 += 32;
      }
      while (v27 < v24);
    }
    while ((v26 & 1) != 0);
    int v39 = *((_DWORD *)this + 30);
    int v22 = v39 + 1;
    *((_DWORD *)this + 30) = v39 + 1;
    uint64_t result = v40;
  }
  while (v39 < v6);
  return result;
}

uint64_t kd_vlift_line::pre_create(kd_vlift_line *this, kdu_sample_allocator *a2, int a3, int a4, char a5, int a6, unsigned __int8 a7, char a8, BOOL a9)
{
  uint64_t result = kdu_line_buf::pre_create(this, a2, a3, a5, a6, a7, a8 - a3);
  if (a9)
  {
    return kdu_line_buf::pre_create((kd_vlift_line *)((char *)this + 16), a2, a4, a5, a6, a7, a8 - a4);
  }
  return result;
}

uint64_t kd_vlift_queue::init(uint64_t this, int a2, int a3, int a4, unsigned __int8 a5, int a6)
{
  *(unsigned char *)(this + 45) = a4;
  *(_DWORD *)this = a2;
  *(_DWORD *)(this + 4) = a3;
  *(_DWORD *)(this + 32) = a2 - 1000;
  *(_DWORD *)(this + 36) = a2 - 1000;
  *(_DWORD *)(this + 24) = a2 - 1000;
  *(unsigned char *)(this + 44) = a5;
  if (((a6 >= a3) & a5) != 0) {
    int v6 = 2 * a3 - a6;
  }
  else {
    int v6 = a3 - 1;
  }
  *(_DWORD *)(this + 40) = v6;
  if (a4 < 0)
  {
    *(_DWORD *)(this + 40) = a3 + 2;
    *(_DWORD *)(this + 32) = a3 + 2;
  }
  *(_DWORD *)(this + 28) = a2 - 1002;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  return this;
}

void kd_analysis::~kd_analysis(kd_roi_level **this)
{
  *this = (kd_roi_level *)&unk_1ED4DEF40;
  for (uint64_t i = 1; i != 5; ++i)
  {
    int v3 = this[i];
    if (v3)
    {
      (*(void (**)(kd_roi_level *))(*(void *)v3 + 8))(v3);
      this[i] = 0;
    }
  }
  if (this[18]) {
    kdu_roi_level::destroy(this + 18);
  }
  int v4 = this[19];
  if (v4) {
    MEMORY[0x18C11C0C0](v4, 0x1000C8052888210);
  }
  unsigned int v5 = this[20];
  if (v5) {
    MEMORY[0x18C11C0C0](v5, 0x1000C8052888210);
  }
  int v6 = this[21];
  if (v6) {
    MEMORY[0x18C11C0C0](v6, 0x80C80B8603338);
  }
  uint64_t v7 = this[22];
  if (v7) {
    MEMORY[0x18C11C0C0](v7, 0x1020C803C8EFFD9);
  }
  uint64_t v8 = this[23];
  if (v8) {
    MEMORY[0x18C11C0C0](v8, 0x1090C805C18EE7CLL);
  }
  int v9 = this[24];
  if (v9) {
    MEMORY[0x18C11C0C0](v9, 0x1090C805C18EE7CLL);
  }
  uint64_t v10 = this[25];
  if (v10) {
    MEMORY[0x18C11C0C0](v10, 0x1020C806F595497);
  }
  *this = (kd_roi_level *)&unk_1ED4E4510;
}

{
  uint64_t vars8;

  kd_analysis::~kd_analysis(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t kd_vlift_queue::simulate_push_line(uint64_t this, int a2, int *a3)
{
  if ((*(unsigned __int8 *)(this + 45) ^ a2)) {
    kd_vlift_queue::simulate_push_line();
  }
  if (*(_DWORD *)(this + 32) <= a2 || *(_DWORD *)(this + 36) <= a2)
  {
    if (*(_DWORD *)(this + 28) < *(_DWORD *)(this + 24)) {
      *(_DWORD *)(this + 24) = a2;
    }
    *(_DWORD *)(this + 28) = a2;
  }
  else
  {
    --*a3;
  }
  return this;
}

uint64_t kd_vlift_queue::simulate_access_update(kd_vlift_queue *this, int a2, int *a3)
{
  if (((*((unsigned __int8 *)this + 45) ^ a2) & 1) != 0 || *((_DWORD *)this + 9) > a2) {
    kd_vlift_queue::simulate_access_update();
  }
  *((_DWORD *)this + 9) = a2;
  int v3 = *((_DWORD *)this + 6);
  if (v3 > a2 || *((_DWORD *)this + 7) < a2) {
    return 0;
  }
  *((_DWORD *)this + 9) = a2 + 2;
  do
  {
    if (v3 >= *((_DWORD *)this + 8)) {
      break;
    }
    if (*((_DWORD *)this + 7) < v3) {
      break;
    }
    if (v3 >= *((_DWORD *)this + 10)) {
      break;
    }
    *((_DWORD *)this + 6) = v3 + 2;
    --*a3;
    int v3 = *((_DWORD *)this + 6);
  }
  while (v3 < *((_DWORD *)this + 9));
  return 1;
}

uint64_t kd_vlift_queue::simulate_access_source(kd_vlift_queue *this, int a2, int a3, int *a4)
{
  if (((*((unsigned __int8 *)this + 45) ^ a2) & 1) != 0 || *((_DWORD *)this + 8) > a2) {
    kd_vlift_queue::simulate_access_source();
  }
  *((_DWORD *)this + 8) = a2;
  if (a3 <= 0)
  {
    int v7 = *((_DWORD *)this + 6);
LABEL_21:
    *((_DWORD *)this + 8) = a2 + 2;
    while (v7 < *((_DWORD *)this + 9)
         && v7 < *((_DWORD *)this + 8)
         && *((_DWORD *)this + 7) >= v7
         && v7 < *((_DWORD *)this + 10))
    {
      *((_DWORD *)this + 6) = v7 + 2;
      --*a4;
      int v7 = *((_DWORD *)this + 6);
    }
    return 1;
  }
  else
  {
    int v4 = a3 - 1;
    int v5 = a2 + 2 * (a3 - 1);
    int v6 = *(_DWORD *)this;
    int v7 = *((_DWORD *)this + 6);
    while (1)
    {
      int v8 = v5;
      while (1)
      {
        while (v8 < v6)
        {
          if (*((unsigned char *)this + 44)) {
            int v8 = 2 * *(_DWORD *)this - v8;
          }
          else {
            int v8 = ((v6 ^ v8) & 1) + v6;
          }
        }
        int v9 = *((_DWORD *)this + 1);
        if (v8 <= v9) {
          break;
        }
        if (*((unsigned char *)this + 44)) {
          int v8 = 2 * v9 - v8;
        }
        else {
          int v8 = v9 - ((v9 ^ v8) & 1);
        }
      }
      if (v8 < v7 || v8 > *((_DWORD *)this + 7)) {
        return 0;
      }
      v5 -= 2;
      if (v4-- <= 0) {
        goto LABEL_21;
      }
    }
  }
}

uint64_t kd_analysis::push(uint64_t result, int *a2, kdu_thread_entity *this)
{
  int v3 = *(_DWORD *)(result + 120);
  if (v3 > *(_DWORD *)(result + 116)) {
    kd_analysis::push();
  }
  uint64_t v5 = result;
  if (*(unsigned char *)(result + 40) != (*((unsigned char *)a2 + 6) & 1)) {
    kd_analysis::push();
  }
  if (*(unsigned char *)(result + 142))
  {
    *(_DWORD *)(result + 120) = v3 + 1;
    return result;
  }
  int v6 = this;
  if (!*(unsigned char *)(result + 42))
  {
    if (this) {
      uint64_t result = kdu_thread_entity::acquire_lock(this, 3, 1);
    }
    for (uint64_t i = *(void *)(v5 + 72); i; uint64_t i = *(void *)(i + 32))
    {
      kdu_line_buf::create(i);
      uint64_t result = kdu_line_buf::create(i + 16);
    }
    *(unsigned char *)(v5 + 42) = 1;
    if (v6) {
      uint64_t result = kdu_thread_entity::release_lock(v6, 3);
    }
  }
  int v9 = (void *)(v5 + 72);
  uint64_t v8 = *(void *)(v5 + 72);
  if (!v8) {
    kd_analysis::push();
  }
  if (*(unsigned char *)(v5 + 43)) {
    int v10 = *(_DWORD *)(v5 + 120) & 1;
  }
  else {
    int v10 = 0;
  }
  if (*(int *)(v5 + 48) < 1 || *(unsigned char *)(v5 + 140))
  {
    uint64_t v11 = 0;
  }
  else
  {
    *(void *)(v5 + 72) = *(void *)(v8 + 32);
    *(void *)(v8 + 32) = 0;
    uint64_t v11 = *(void *)(v5 + 104) + 48 * -v10;
    uint64_t result = kd_vlift_queue::push_line(v11, *(_DWORD *)(v5 + 120), v8, (void *)(v5 + 72));
  }
  ++*(_DWORD *)(v5 + 120);
  int v12 = *a2;
  if (*a2 != *(_DWORD *)(v5 + 136) + *(_DWORD *)(v5 + 132)) {
    kd_analysis::push();
  }
  unsigned int v13 = v12 + 1;
  int v14 = (v12 + 1) >> 1;
  uint64x2_t v15 = (float *)*((void *)a2 + 1);
  if (*(unsigned char *)(v5 + 44))
  {
    uint64_t v16 = *(_DWORD *)(v5 + 124) & 1;
    if (*(unsigned char *)(v5 + 41))
    {
      unsigned int v17 = 0;
      if ((*((unsigned char *)a2 + 6) & 2) == 0) {
        uint64x2_t v15 = 0;
      }
      if ((*(unsigned char *)(v8 + 16 * v16 + 6) & 2) != 0) {
        unsigned int v17 = *(_WORD **)(v8 + 16 * v16 + 8);
      }
      if ((*(unsigned char *)(v8 + 16 * !(*(unsigned char *)(v5 + 124) & 1) + 6) & 2) != 0) {
        int64x2_t v18 = *(_WORD **)(v8 + 16 * !(*(unsigned char *)(v5 + 124) & 1) + 8);
      }
      else {
        int64x2_t v18 = 0;
      }
      int v24 = *(_DWORD *)(v5 + 100);
      if (v24)
      {
        if (v13 >= 2)
        {
          int v25 = 0x8000 << v24 >> 16;
          do
          {
            *v17++ = (v25 + *(__int16 *)v15) >> *(_DWORD *)(v5 + 100);
            *v18++ = (v25 + *((__int16 *)v15++ + 1)) >> *(_DWORD *)(v5 + 100);
            --v14;
          }
          while (v14);
        }
      }
      else if (v13 >= 2)
      {
        do
        {
          *v17++ = *(_WORD *)v15;
          *v18++ = *((_WORD *)v15++ + 1);
          --v14;
        }
        while (v14);
      }
    }
    else
    {
      int v22 = 0;
      if ((*((unsigned char *)a2 + 6) & 2) != 0) {
        uint64x2_t v15 = 0;
      }
      if ((*(unsigned char *)(v8 + 16 * v16 + 6) & 2) == 0) {
        int v22 = *(float **)(v8 + 16 * v16 + 8);
      }
      if ((*(unsigned char *)(v8 + 16 * !(*(unsigned char *)(v5 + 124) & 1) + 6) & 2) != 0) {
        BOOL v23 = 0;
      }
      else {
        BOOL v23 = *(float **)(v8 + 16 * !(*(unsigned char *)(v5 + 124) & 1) + 8);
      }
      int v29 = *(_DWORD *)(v5 + 100);
      if (v29)
      {
        if (v13 >= 2)
        {
          float v30 = 1.0 / (float)(1 << v29);
          do
          {
            *v22++ = v30 * *v15;
            *v23++ = v30 * v15[1];
            v15 += 2;
            --v14;
          }
          while (v14);
        }
      }
      else if (v13 >= 2)
      {
        do
        {
          *v22++ = *v15;
          *v23++ = v15[1];
          v15 += 2;
          --v14;
        }
        while (v14);
      }
    }
  }
  else if (*(unsigned char *)(v5 + 41))
  {
    __int32 v19 = 0;
    if ((*((unsigned char *)a2 + 6) & 2) == 0) {
      uint64x2_t v15 = 0;
    }
    if ((*(unsigned char *)(v8 + 6) & 2) != 0) {
      __int32 v19 = *(_WORD **)(v8 + 8);
    }
    int v20 = *(_DWORD *)(v5 + 100);
    if (v20)
    {
      if (v13 >= 2)
      {
        int v21 = 0x8000 << v20 >> 16;
        do
        {
          *__int32 v19 = (v21 + *(__int16 *)v15) >> *(_DWORD *)(v5 + 100);
          v19[1] = (v21 + *((__int16 *)v15++ + 1)) >> *(_DWORD *)(v5 + 100);
          v19 += 2;
          --v14;
        }
        while (v14);
      }
    }
    else if (v13 >= 2)
    {
      do
      {
        *__int32 v19 = *(_WORD *)v15;
        v19[1] = *((_WORD *)v15++ + 1);
        v19 += 2;
        --v14;
      }
      while (v14);
    }
  }
  else
  {
    char v26 = 0;
    if ((*((unsigned char *)a2 + 6) & 2) != 0) {
      uint64x2_t v15 = 0;
    }
    if ((*(unsigned char *)(v8 + 6) & 2) == 0) {
      char v26 = *(float **)(v8 + 8);
    }
    int v27 = *(_DWORD *)(v5 + 100);
    if (v27)
    {
      if (v13 >= 2)
      {
        float v28 = 1.0 / (float)(1 << v27);
        do
        {
          *char v26 = v28 * *v15;
          v26[1] = v28 * v15[1];
          v15 += 2;
          v26 += 2;
          --v14;
        }
        while (v14);
      }
    }
    else if (v13 >= 2)
    {
      do
      {
        *char v26 = *v15;
        v26[1] = v15[1];
        v15 += 2;
        v26 += 2;
        --v14;
      }
      while (v14);
    }
  }
  if (*(unsigned char *)(v5 + 140))
  {
    if (*(unsigned char *)(v5 + 40) && v10 != 0)
    {
      if (!*(unsigned char *)(v5 + 43)) {
        kd_analysis::push();
      }
      if (*(unsigned char *)(v5 + 41))
      {
        uint64_t v32 = 0;
        char v33 = 1;
        do
        {
          char v34 = v33;
          uint64_t v35 = v8 + 16 * v32;
          if ((*(unsigned char *)(v35 + 6) & 2) != 0) {
            int v36 = *(_WORD **)(v35 + 8);
          }
          else {
            int v36 = 0;
          }
          for (int j = *(_DWORD *)v35; j; --j)
            *v36++ *= 2;
          char v33 = 0;
          uint64_t v32 = 1;
        }
        while ((v34 & 1) != 0);
      }
      else
      {
        uint64_t v38 = 0;
        char v39 = 1;
        do
        {
          char v40 = v39;
          uint64_t v41 = v8 + 16 * v38;
          if ((*(unsigned char *)(v41 + 6) & 2) != 0) {
            char v42 = 0;
          }
          else {
            char v42 = *(_DWORD **)(v41 + 8);
          }
          for (int k = *(_DWORD *)v41; k; --k)
            *v42++ *= 2;
          char v39 = 0;
          uint64_t v38 = 1;
        }
        while ((v40 & 1) != 0);
      }
    }
  }
  if (v11)
  {
    if (*(int *)(v5 + 48) < 1 || *(unsigned char *)(v5 + 140)) {
      kd_analysis::push();
    }
    uint64_t v44 = v10 ^ 1u;
    uint64_t v86 = (void *)(v5 + 72);
    uint64_t v87 = (uint64_t)v6;
    while (1)
    {
      if ((v44 & 0x80000000) != 0) {
        return result;
      }
      uint64_t v45 = 0;
      char v46 = 0;
      do
      {
        uint64_t v47 = *(int *)(v5 + 48);
        if (v45 >= v47) {
          break;
        }
        uint64_t v48 = *(void *)(v5 + 80);
        uint64_t v49 = v48 + 32 * v45;
        int v51 = (int *)(v49 + 24);
        int v50 = *(_DWORD *)(v49 + 24);
        int v52 = (v50 ^ 1) + 2 * *(__int16 *)(v49 + 4);
        if (v50 <= *(_DWORD *)(v5 + 116))
        {
          uint64_t v54 = *(void *)(v5 + 104);
          uint64_t v55 = v45 - 1;
          uint64_t v56 = v54 + 48 * (v45 - 1);
          *(_DWORD *)(v56 + 36) = v50;
          if (*(_DWORD *)(v56 + 24) > v50 || *(_DWORD *)(v54 + 48 * v55 + 28) < v50) {
            continue;
          }
          unsigned int v88 = v44;
          uint64_t v57 = v48 + 32 * v45;
          int v59 = *(unsigned __int8 *)(v57 + 1);
          float v58 = (unsigned char *)(v57 + 1);
          uint64_t result = kd_vlift_queue::access_source((int *)(v54 + 48 * v45), v52, v59, *(void *)(v5 + 56), v9);
          if (!result)
          {
            uint64_t v44 = v88;
            continue;
          }
          uint64_t v60 = kd_vlift_queue::access_update(*(void *)(v5 + 104) + 48 * v55, *v51, v9);
          uint64_t v61 = *(void *)(v5 + 72);
          if (!v61) {
            kd_analysis::push();
          }
          if (*v58)
          {
            uint64_t v62 = v60;
            uint64_t v63 = 0;
            char v64 = 1;
            do
            {
              char v65 = v64;
              int v66 = *(_DWORD *)(v5 + 4 * v63 + 132);
              if (v66)
              {
                uint64_t v67 = *(uint64_t **)(v5 + 64);
                uint64_t v68 = *v58;
                if (*(unsigned char *)(v5 + 41))
                {
                  if (*v58)
                  {
                    unint64_t v69 = 0;
                    uint64_t v70 = 8 * v68;
                    do
                    {
                      uint64_t v71 = *(void *)(*(void *)(v5 + 56) + v69) + 16 * v63;
                      if ((*(unsigned char *)(v71 + 6) & 2) != 0) {
                        uint64_t v72 = *(void *)(v71 + 8);
                      }
                      else {
                        uint64_t v72 = 0;
                      }
                      v67[v69 / 8] = v72;
                      v69 += 8;
                    }
                    while (v70 != v69);
                  }
                  uint64_t v73 = v62 + 16 * v63;
                  if ((*(unsigned char *)(v73 + 6) & 2) != 0) {
                    uint64_t v74 = *(void *)(v73 + 8);
                  }
                  else {
                    uint64_t v74 = 0;
                  }
                  uint64_t v81 = v61 + 16 * v63;
                  if ((*(unsigned char *)(v81 + 6) & 2) != 0) {
                    uint64_t v82 = *(void *)(v81 + 8);
                  }
                  else {
                    uint64_t v82 = 0;
                  }
                  perform_analysis_lifting_step(v49, v67, v74, v82, v66, 0);
                }
                else
                {
                  if (*v58)
                  {
                    unint64_t v75 = 0;
                    uint64_t v76 = 8 * v68;
                    do
                    {
                      uint64_t v77 = *(void *)(*(void *)(v5 + 56) + v75) + 16 * v63;
                      if ((*(unsigned char *)(v77 + 6) & 2) != 0) {
                        uint64_t v78 = 0;
                      }
                      else {
                        uint64_t v78 = *(void *)(v77 + 8);
                      }
                      v67[v75 / 8] = v78;
                      v75 += 8;
                    }
                    while (v76 != v75);
                  }
                  uint64_t v79 = v62 + 16 * v63;
                  if ((*(unsigned char *)(v79 + 6) & 2) != 0) {
                    uint64_t v80 = 0;
                  }
                  else {
                    uint64_t v80 = *(void *)(v79 + 8);
                  }
                  uint64_t v83 = v61 + 16 * v63;
                  if ((*(unsigned char *)(v83 + 6) & 2) != 0) {
                    uint64_t v84 = 0;
                  }
                  else {
                    uint64_t v84 = *(void *)(v83 + 8);
                  }
                  perform_analysis_lifting_step(v49, v67, v80, v84, v66, 0);
                }
              }
              char v64 = 0;
              uint64_t v63 = 1;
            }
            while ((v65 & 1) != 0);
          }
          if (v45 == *(_DWORD *)(v5 + 48) - 1)
          {
            int v6 = (kdu_thread_entity *)v87;
            kd_analysis::horizontal_analysis(v5, v61, !(v45 & 1), v87);
            int v9 = (void *)(v5 + 72);
            uint64_t result = kd_vlift_queue::access_update(*(void *)(v5 + 104) + 48 * v45, v52, v86);
            if (result) {
              uint64_t result = kd_analysis::horizontal_analysis(v5, result, v45 & 1, v87);
            }
            uint64_t v44 = v88;
          }
          else
          {
            *(void *)(v5 + 72) = *(void *)(v61 + 32);
            *(void *)(v61 + 32) = 0;
            int v9 = (void *)(v5 + 72);
            uint64_t result = kd_vlift_queue::push_line(*(void *)(v5 + 104) + 48 * (v45 + 1), *v51, v61, v86);
            uint64_t v44 = (v45 + 2);
            int v6 = (kdu_thread_entity *)v87;
          }
LABEL_111:
          *v51 += 2;
          char v46 = 1;
          continue;
        }
        if (v45 == v47 - 1)
        {
          uint64_t v53 = v44;
          uint64_t result = kd_vlift_queue::access_update(*(void *)(v5 + 104) + 48 * v45, v52, v9);
          if (!result)
          {
            uint64_t v44 = v53;
            continue;
          }
          uint64_t result = kd_analysis::horizontal_analysis(v5, result, v45 & 1, (uint64_t)v6);
          uint64_t v44 = v53;
          goto LABEL_111;
        }
      }
      while (v45++ < (int)v44);
      if ((v46 & 1) == 0) {
        return result;
      }
    }
  }

  return kd_analysis::horizontal_analysis(v5, v8, v10, (uint64_t)v6);
}

uint64_t kd_vlift_queue::push_line(uint64_t result, int a2, uint64_t a3, void *a4)
{
  if ((*(unsigned __int8 *)(result + 45) ^ a2)) {
    kd_vlift_queue::push_line();
  }
  if (*(_DWORD *)(result + 32) <= a2 || *(_DWORD *)(result + 36) <= a2)
  {
    *(void *)(a3 + 32) = 0;
    uint64_t v5 = *(void *)(result + 16);
    if (v5)
    {
      if (*(_DWORD *)(result + 28) + 2 != a2) {
        kd_vlift_queue::push_line();
      }
      *(void *)(v5 + 32) = a3;
      *(void *)(result + 16) = a3;
    }
    else
    {
      *(void *)(result + 8) = a3;
      *(void *)(result + 16) = a3;
      *(_DWORD *)(result + 24) = a2;
    }
    *(_DWORD *)(result + 28) = a2;
  }
  else
  {
    *(void *)(a3 + 32) = *a4;
    for (*a4 = a3; ; *a4 = v4)
    {
      uint64_t v4 = *(void *)(result + 8);
      *(void *)(result + 16) = v4;
      if (!v4) {
        break;
      }
      *(void *)(result + 8) = *(void *)(v4 + 32);
      *(void *)(v4 + 32) = *a4;
    }
  }
  return result;
}

uint64_t kd_analysis::horizontal_analysis(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  if (*(_DWORD *)(result + 132) != *(_DWORD *)a2 || (uint64_t v5 = result, *(_DWORD *)(result + 136) != *(_DWORD *)(a2 + 16))) {
    kd_analysis::horizontal_analysis();
  }
  if (*(unsigned char *)(result + 141)
    && *(int *)(result + 52) >= 1
    && *(unsigned char *)(result + 40)
    && (*(unsigned char *)(result + 124) & 1) != 0)
  {
    if (!*(unsigned char *)(result + 44)) {
      kd_analysis::horizontal_analysis();
    }
    if (*(unsigned char *)(result + 41)) {
      **(_WORD **)(a2 + 24) *= 2;
    }
    else {
      **(_DWORD **)(a2 + 24) *= 2;
    }
  }
  int v7 = *(_DWORD *)(result + 52);
  if (v7 && !*(unsigned char *)(result + 141))
  {
    if (v7 < 1)
    {
LABEL_112:
      uint64_t v97 = 0;
      uint64_t v98 = 2 * a3;
      char v99 = 1;
      do
      {
        char v100 = v99;
        uint64_t v101 = *(void *)(v5 + 8 * (v97 | v98) + 8);
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v101 + 16))(v101, a2 + 16 * v97, a4);
        char v99 = 0;
        uint64_t v97 = 1;
      }
      while ((v100 & 1) != 0);
      return result;
    }
    uint64_t v13 = 0;
    while (1)
    {
      uint64_t v14 = *(void *)(v5 + 88);
      uint64_t v15 = v14 + 32 * v13;
      int v17 = *(unsigned __int8 *)(v15 + 1);
      uint64_t v16 = (unsigned __int8 *)(v15 + 1);
      if (v17)
      {
        BOOL v18 = (v13 & 1) == 0;
        uint64_t v19 = *(unsigned int *)(v5 + 4 * v18 + 132);
        uint64_t v20 = v13 & 1;
        if (*(unsigned char *)(v5 + 41))
        {
          if ((*(unsigned char *)(a2 + 16 * (v13 & 1) + 6) & 2) != 0) {
            int v21 = *(_WORD **)(a2 + 16 * v20 + 8);
          }
          else {
            int v21 = 0;
          }
          uint64_t v23 = a2 + 16 * v18;
          if ((*(unsigned char *)(v23 + 6) & 2) != 0) {
            int v24 = *(_WORD **)(v23 + 8);
          }
          else {
            int v24 = 0;
          }
          uint64_t v25 = *(int *)(v5 + 4 * v20 + 132);
          char v26 = &v21[v25];
          uint64_t v27 = v14 + 32 * v13;
          int v30 = *(unsigned __int8 *)(v27 + 3);
          int v29 = (unsigned __int8 *)(v27 + 3);
          int v28 = v30;
          if (*(unsigned char *)(v5 + 99))
          {
            if (v28)
            {
              unint64_t v31 = 0;
              uint64_t v32 = v26 - 1;
              uint64_t v33 = -1;
              char v34 = &v21[v25];
              do
              {
                v21[v33] = v21[v31 - ((*(_DWORD *)(v5 + 124) ^ v13) & 1) + 1];
                v34[v31++] = v32[v33 + ((*(_DWORD *)(v5 + 128) ^ v13) & 1)];
                --v33;
              }
              while (v31 < *v29);
            }
          }
          else if (v28)
          {
            unint64_t v35 = 0;
            int v36 = v21 - 1;
            do
            {
              *v36-- = *v21;
              v26[v35++] = *(v26 - 1);
            }
            while (v35 < *v29);
          }
          BOOL v37 = (*(unsigned __int8 *)(v5 + 124) << 31 >> 31) & (1 - 2 * v18);
          uint64_t v38 = v14 + 32 * v13;
          uint64_t v39 = *(__int16 *)(v38 + 4);
          uint64_t v40 = *v16;
          uint64_t v41 = *(int **)(v38 + 16);
          if (v40 == 2 && (int v42 = *v41, *v41 == v41[1]))
          {
            uint64_t v43 = v14 + 32 * v13;
            char v44 = *(unsigned char *)(v43 + 2);
            int v45 = *(__int16 *)(v43 + 6);
            if (v42 == 1)
            {
              if ((int)v19 >= 1)
              {
                uint64_t v92 = &v21[v39 + 1 + v37];
                do
                {
                  *v24++ += (*(v92 - 1) + v45 + *v92) >> v44;
                  ++v92;
                  --v19;
                }
                while (v19);
              }
            }
            else if (v42 == -1)
            {
              if ((int)v19 >= 1)
              {
                char v46 = &v21[v39 + 1 + v37];
                do
                {
                  *v24++ += (v45 - (*(v46 - 1) + *v46)) >> v44;
                  ++v46;
                  --v19;
                }
                while (v19);
              }
            }
            else if ((int)v19 >= 1)
            {
              int v93 = &v21[v39 + 1 + v37];
              do
              {
                *v24++ += (v45 + (*v93 + *(v93 - 1)) * v42) >> v44;
                ++v93;
                --v19;
              }
              while (v19);
            }
          }
          else if ((int)v19 >= 1)
          {
            uint64_t v47 = 0;
            uint64_t v48 = (uint64_t)&v21[v37 + v39];
            char v49 = *(unsigned char *)(v38 + 2);
            int v50 = *(__int16 *)(v38 + 6);
            do
            {
              int v51 = v50;
              if (v40)
              {
                uint64_t v52 = 0;
                int v51 = v50;
                do
                {
                  v51 += v41[v52] * *(__int16 *)(v48 + 2 * v52);
                  ++v52;
                }
                while (v40 != v52);
              }
              v24[v47++] += v51 >> v49;
              v48 += 2;
            }
            while (v47 != v19);
          }
        }
        else
        {
          if ((*(unsigned char *)(a2 + 16 * (v13 & 1) + 6) & 2) != 0) {
            int v22 = 0;
          }
          else {
            int v22 = *(_DWORD **)(a2 + 16 * v20 + 8);
          }
          uint64_t v53 = a2 + 16 * v18;
          if ((*(unsigned char *)(v53 + 6) & 2) != 0) {
            uint64_t v54 = 0;
          }
          else {
            uint64_t v54 = *(float **)(v53 + 8);
          }
          uint64_t v55 = *(int *)(v5 + 4 * v20 + 132);
          uint64_t v56 = &v22[v55];
          uint64_t v57 = v14 + 32 * v13;
          int v60 = *(unsigned __int8 *)(v57 + 3);
          int v59 = (unsigned __int8 *)(v57 + 3);
          int v58 = v60;
          if (*(unsigned char *)(v5 + 99))
          {
            if (v58)
            {
              unint64_t v61 = 0;
              uint64_t v62 = v56 - 1;
              uint64_t v63 = -1;
              char v64 = &v22[v55];
              do
              {
                v22[v63] = v22[v61 - ((*(_DWORD *)(v5 + 124) ^ v13) & 1) + 1];
                v64[v61++] = v62[v63 + ((*(_DWORD *)(v5 + 128) ^ v13) & 1)];
                --v63;
              }
              while (v61 < *v59);
            }
          }
          else if (v58)
          {
            unint64_t v65 = 0;
            int v66 = v22 - 1;
            do
            {
              *v66-- = *v22;
              v56[v65++] = *(v56 - 1);
            }
            while (v65 < *v59);
          }
          BOOL v67 = (*(unsigned __int8 *)(v5 + 124) << 31 >> 31) & (1 - 2 * v18);
          uint64_t v68 = v14 + 32 * v13;
          uint64_t v69 = *(__int16 *)(v68 + 4);
          uint64_t v70 = *v16;
          if (v70 != 2)
          {
            int v74 = *(unsigned __int8 *)(v5 + 40);
LABEL_75:
            uint64_t v80 = (uint64_t)&v22[v67 + v69];
            if (v74)
            {
              if ((int)v19 >= 1)
              {
                uint64_t v81 = 0;
                uint64_t v82 = v14 + 32 * v13;
                char v83 = *(unsigned char *)(v82 + 2);
                int v84 = *(__int16 *)(v82 + 6);
                uint64_t v85 = *(void *)(v82 + 16);
                do
                {
                  int v86 = v84;
                  if (v70)
                  {
                    uint64_t v87 = 0;
                    int v86 = v84;
                    do
                    {
                      v86 += *(_DWORD *)(v80 + v87) * *(_DWORD *)(v85 + v87);
                      v87 += 4;
                    }
                    while (4 * v70 != v87);
                  }
                  LODWORD(v54[v81++]) += v86 >> v83;
                  v80 += 4;
                }
                while (v81 != v19);
              }
            }
            else if ((int)v19 >= 1)
            {
              uint64_t v88 = 0;
              uint64_t v89 = *(void *)(v14 + 32 * v13 + 8);
              do
              {
                if (v70)
                {
                  uint64_t v90 = 0;
                  float v91 = 0.0;
                  do
                  {
                    float v91 = v91 + (float)(*(float *)(v89 + v90) * *(float *)(v80 + v90));
                    v90 += 4;
                  }
                  while (4 * v70 != v90);
                }
                else
                {
                  float v91 = 0.0;
                }
                v54[v88] = v91 + v54[v88];
                ++v88;
                v80 += 4;
              }
              while (v88 != v19);
            }
            goto LABEL_111;
          }
          uint64_t v71 = *(float **)(v68 + 8);
          float v72 = *v71;
          float v73 = v71[1];
          int v74 = *(unsigned __int8 *)(v5 + 40);
          if (v72 != v73) {
            goto LABEL_75;
          }
          if (*(unsigned char *)(v5 + 40))
          {
            uint64_t v75 = v14 + 32 * v13;
            char v76 = *(unsigned char *)(v75 + 2);
            int v77 = *(__int16 *)(v75 + 6);
            int v78 = **(_DWORD **)(v75 + 16);
            if (v78 == 1)
            {
              if ((int)v19 >= 1)
              {
                int v95 = &v22[v69 + 1 + v67];
                do
                {
                  *(_DWORD *)v54++ += (*(v95 - 1) + v77 + *v95) >> v76;
                  ++v95;
                  --v19;
                }
                while (v19);
              }
            }
            else if (v78 == -1)
            {
              if ((int)v19 >= 1)
              {
                uint64_t v79 = &v22[v69 + 1 + v67];
                do
                {
                  *(_DWORD *)v54++ += (v77 - (*(v79 - 1) + *v79)) >> v76;
                  ++v79;
                  --v19;
                }
                while (v19);
              }
            }
            else if ((int)v19 >= 1)
            {
              int v96 = &v22[v69 + 1 + v67];
              do
              {
                *(_DWORD *)v54++ += (v77 + (*v96 + *(v96 - 1)) * v78) >> v76;
                ++v96;
                --v19;
              }
              while (v19);
            }
          }
          else if ((int)v19 >= 1)
          {
            int v94 = (float *)&v22[v69 + 1 + v67];
            do
            {
              float *v54 = *v54 + (float)(v72 * (float)(*(v94 - 1) + *v94));
              ++v54;
              ++v94;
              --v19;
            }
            while (v19);
          }
        }
      }
LABEL_111:
      if (++v13 >= *(int *)(v5 + 52)) {
        goto LABEL_112;
      }
    }
  }
  uint64_t v8 = 0;
  uint64_t v9 = 2 * a3;
  char v10 = 1;
  do
  {
    char v11 = v10;
    if (*(int *)(v5 + 4 * v8 + 132) >= 1)
    {
      uint64_t v12 = *(void *)(v5 + 8 * (v8 | v9) + 8);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12 + 16))(v12, a2 + 16 * v8, a4);
    }
    char v10 = 0;
    uint64_t v8 = 1;
  }
  while ((v11 & 1) != 0);
  return result;
}

uint64_t kd_vlift_queue::access_update(uint64_t a1, int a2, void *a3)
{
  if (((*(unsigned __int8 *)(a1 + 45) ^ a2) & 1) != 0 || *(_DWORD *)(a1 + 36) > a2) {
    kd_vlift_queue::access_update();
  }
  *(_DWORD *)(a1 + 36) = a2;
  int v3 = *(_DWORD *)(a1 + 24);
  if (v3 > a2 || *(_DWORD *)(a1 + 28) < a2) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 8);
  uint64_t v4 = v6;
  if (v3 < a2)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    int v7 = a2;
    do
    {
      v7 -= 2;
      uint64_t v4 = *(void *)(v4 + 32);
    }
    while (v7 > v3);
  }
  if (!v4) {
    kd_vlift_queue::access_update();
  }
  int v8 = a2 + 2;
  *(_DWORD *)(a1 + 36) = a2 + 2;
  if (*(_DWORD *)(a1 + 32) < a2 + 2) {
    int v8 = *(_DWORD *)(a1 + 32);
  }
  while (v3 < v8 && v6 && v3 < *(_DWORD *)(a1 + 40))
  {
    v3 += 2;
    *(_DWORD *)(a1 + 24) = v3;
    uint64_t v9 = *(void *)(v6 + 32);
    *(void *)(v6 + 32) = *a3;
    *a3 = v6;
    *(void *)(a1 + 8) = v9;
    if (!v9) {
      *(void *)(a1 + 16) = 0;
    }
    uint64_t v6 = v9;
  }
  return v4;
}

uint64_t kd_vlift_queue::access_source(int *a1, int a2, int a3, uint64_t a4, void *a5)
{
  if (((*((unsigned __int8 *)a1 + 45) ^ a2) & 1) != 0 || a1[8] > a2) {
    kd_vlift_queue::access_source();
  }
  a1[8] = a2;
  int v5 = a3 - 1;
  int v6 = a2 + 2 * (a3 - 1);
  int v7 = a1[7];
  if (v6 > v7 && v6 <= a1[1]) {
    return 0;
  }
  if (a3 <= 0)
  {
    int v11 = a1[6];
LABEL_25:
    int v17 = a2 + 2;
    a1[8] = a2 + 2;
    if (a1[9] < a2 + 2) {
      int v17 = a1[9];
    }
    if (v11 < v17)
    {
      uint64_t v18 = *((void *)a1 + 1);
      do
      {
        if (!v18 || v11 >= a1[10]) {
          break;
        }
        v11 += 2;
        a1[6] = v11;
        uint64_t v19 = *(void *)(v18 + 32);
        *(void *)(v18 + 32) = *a5;
        *a5 = v18;
        *((void *)a1 + 1) = v19;
        if (!v19) {
          *((void *)a1 + 2) = 0;
        }
        uint64_t v18 = v19;
      }
      while (v11 < v17);
    }
    return 1;
  }
  else
  {
    int v8 = (void *)(a4 + 8 * v5);
    int v9 = *a1;
    int v10 = 2 * *a1;
    int v11 = a1[6];
    while (1)
    {
      int v12 = v6;
      while (1)
      {
        while (v12 < v9)
        {
          if (*((unsigned char *)a1 + 44)) {
            int v12 = v10 - v12;
          }
          else {
            int v12 = ((v9 ^ v12) & 1) + v9;
          }
        }
        int v13 = a1[1];
        if (v12 <= v13) {
          break;
        }
        if (*((unsigned char *)a1 + 44)) {
          int v12 = 2 * v13 - v12;
        }
        else {
          int v12 = v13 - ((v13 ^ v12) & 1);
        }
      }
      uint64_t v14 = 0;
      if (v12 > v7 || v12 < v11) {
        break;
      }
      for (uint64_t i = *((void *)a1 + 1); ; uint64_t i = *(void *)(i + 32))
      {
        *int v8 = i;
        if (v12 <= v11) {
          break;
        }
        v12 -= 2;
      }
      v6 -= 2;
      --v8;
      if (v5-- <= 0) {
        goto LABEL_25;
      }
    }
  }
  return v14;
}

uint64_t perform_analysis_lifting_step(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  if (a5 >= 1)
  {
    if (a6 >= 16) {
      int v6 = 16;
    }
    else {
      int v6 = a6;
    }
    unsigned int v7 = a6 - v6 + 7;
    unsigned int v8 = v7 & 0xFFFFFFF8;
    uint64_t v9 = 16 * (v7 >> 3) + 16;
    int v10 = a6 - v8 - 8;
    uint64_t v11 = a4 + v9;
    if (a6 >= 9) {
      uint64_t v12 = a3 + v9;
    }
    else {
      uint64_t v12 = a3;
    }
    if (a6 >= 9)
    {
      LODWORD(v13) = v10;
    }
    else
    {
      uint64_t v11 = a4;
      LODWORD(v13) = a6;
    }
    int v14 = v13 + a5;
    uint64_t v15 = *(unsigned __int8 *)(result + 1);
    if (v15 == 2 && (uint64_t v16 = *(int **)(result + 16), v17 = *v16, *v16 == v16[1]))
    {
      uint64_t v18 = *a2;
      uint64_t v19 = a2[1];
      char v20 = *(unsigned char *)(result + 2);
      int v21 = 1 << v20 >> 1;
      if (v17 == 1)
      {
        uint64_t v33 = (int)v13;
        do
        {
          uint64_t result = *(unsigned __int16 *)(v12 + 2 * v33);
          *(_WORD *)(v11 + 2 * v33) = result
                                    + ((v21 + *(__int16 *)(v18 + 2 * v33) + *(__int16 *)(v19 + 2 * v33)) >> v20);
          ++v33;
        }
        while (v33 < v14);
      }
      else if (v17 == -1)
      {
        uint64_t v22 = (int)v13;
        do
        {
          uint64_t result = *(unsigned __int16 *)(v12 + 2 * v22);
          *(_WORD *)(v11 + 2 * v22) = result
                                    + ((v21 - (*(__int16 *)(v18 + 2 * v22) + *(__int16 *)(v19 + 2 * v22))) >> v20);
          ++v22;
        }
        while (v22 < v14);
      }
      else
      {
        uint64_t v13 = (int)v13;
        do
        {
          uint64_t result = *(unsigned __int16 *)(v12 + 2 * v13);
          *(_WORD *)(v11 + 2 * v13) = result
                                    + ((v21 + (*(__int16 *)(v19 + 2 * v13) + *(__int16 *)(v18 + 2 * v13)) * v17) >> v20);
          ++v13;
        }
        while (v13 < v14);
      }
    }
    else
    {
      char v23 = *(unsigned char *)(result + 2);
      int v24 = *(__int16 *)(result + 6);
      uint64_t v25 = (int)v13;
      do
      {
        int v26 = v24;
        if (v15)
        {
          uint64_t v27 = *(int **)(result + 16);
          uint64_t v28 = v15;
          int v29 = a2;
          int v26 = v24;
          do
          {
            int v31 = *v27++;
            int v30 = v31;
            uint64_t v32 = *v29++;
            v26 += v30 * *(__int16 *)(v32 + 2 * v25);
            --v28;
          }
          while (v28);
        }
        *(_WORD *)(v11 + 2 * v25) = *(_WORD *)(v12 + 2 * v25) + (v26 >> v23);
        ++v25;
      }
      while (v25 < v14);
    }
  }
  return result;
}

{
  int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  float *v17;
  float v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  int v22;
  int v23;
  char v24;
  int v25;
  uint64_t v26;
  int v27;
  int *v28;
  uint64_t v29;
  uint64_t *v30;
  int v31;
  int v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  uint64_t v38;
  uint64_t v39;

  if (a5 < 1) {
    return result;
  }
  if (a6 >= 8) {
    int v6 = 8;
  }
  else {
    int v6 = a6;
  }
  unsigned int v7 = a6 - v6 + 3;
  unsigned int v8 = v7 & 0xFFFFFFFC;
  uint64_t v9 = 16 * (v7 >> 2) + 16;
  int v10 = a3 + v9;
  uint64_t v11 = a6 - v8 - 4;
  uint64_t v12 = a4 + v9;
  if (a6 >= 5) {
    uint64_t v13 = v10;
  }
  else {
    uint64_t v13 = a3;
  }
  if (a6 >= 5)
  {
    LODWORD(v14) = v11;
  }
  else
  {
    uint64_t v12 = a4;
    LODWORD(v14) = a6;
  }
  uint64_t v15 = v14 + a5;
  uint64_t v16 = *(unsigned __int8 *)(result + 1);
  if (v16 == 2)
  {
    int v17 = *(float **)(result + 8);
    uint64_t v18 = *v17;
    if (*v17 == v17[1])
    {
      uint64_t v19 = *a2;
      char v20 = a2[1];
      if (*(unsigned char *)(result + 29))
      {
        int v21 = *(unsigned char *)(result + 2);
        uint64_t v22 = *(__int16 *)(result + 6);
        char v23 = **(_DWORD **)(result + 16);
        int v14 = (int)v14;
        if (v23 == 1)
        {
          do
          {
            uint64_t result = *(unsigned int *)(v20 + 4 * v14);
            *(_DWORD *)(v12 + 4 * v14) = ((*(_DWORD *)(v19 + 4 * v14) + v22 + (int)result) >> v21)
                                       + *(_DWORD *)(v13 + 4 * v14);
            ++v14;
          }
          while (v14 < v15);
        }
        else if (v23 == -1)
        {
          do
          {
            uint64_t result = *(unsigned int *)(v20 + 4 * v14);
            *(_DWORD *)(v12 + 4 * v14) = ((v22 - (*(_DWORD *)(v19 + 4 * v14) + (int)result)) >> v21)
                                       + *(_DWORD *)(v13 + 4 * v14);
            ++v14;
          }
          while (v14 < v15);
        }
        else
        {
          do
          {
            uint64_t result = ((v22 + (*(_DWORD *)(v20 + 4 * v14) + *(_DWORD *)(v19 + 4 * v14)) * v23) >> v21);
            *(_DWORD *)(v12 + 4 * v14) = result + *(_DWORD *)(v13 + 4 * v14);
            ++v14;
          }
          while (v14 < v15);
        }
      }
      else
      {
        uint64_t v39 = (int)v14;
        do
        {
          *(float *)(v12 + 4 * v39) = *(float *)(v13 + 4 * v39)
                                    + (float)(v18 * (float)(*(float *)(v19 + 4 * v39) + *(float *)(v20 + 4 * v39)));
          ++v39;
        }
        while (v39 < v15);
      }
      return result;
    }
    if (*(unsigned char *)(result + 29)) {
      goto LABEL_26;
    }
LABEL_32:
    char v34 = 0;
    unint64_t v35 = v15;
    do
    {
      int v36 = a2[v34];
      BOOL v37 = *(float *)(*(void *)(result + 8) + 4 * v34);
      uint64_t v38 = (int)v14;
      do
      {
        *(float *)(v12 + 4 * v38) = *(float *)(v13 + 4 * v38) + (float)(v37 * *(float *)(v36 + 4 * v38));
        ++v38;
      }
      while (v38 < v35);
      ++v34;
      uint64_t v13 = v12;
    }
    while (v34 < *(unsigned __int8 *)(result + 1));
    return result;
  }
  if (!*(unsigned char *)(result + 29))
  {
    if (!*(unsigned char *)(result + 1)) {
      return result;
    }
    goto LABEL_32;
  }
LABEL_26:
  int v24 = *(unsigned char *)(result + 2);
  uint64_t v25 = *(__int16 *)(result + 6);
  int v26 = (int)v14;
  do
  {
    uint64_t v27 = v25;
    if (v16)
    {
      uint64_t v28 = *(int **)(result + 16);
      int v29 = v16;
      int v30 = a2;
      uint64_t v27 = v25;
      do
      {
        uint64_t v32 = *v28++;
        int v31 = v32;
        uint64_t v33 = *v30++;
        v27 += *(_DWORD *)(v33 + 4 * v26) * v31;
        --v29;
      }
      while (v29);
    }
    *(_DWORD *)(v12 + 4 * v26) = *(_DWORD *)(v13 + 4 * v26) + (v27 >> v24);
    ++v26;
  }
  while (v26 < v15);
  return result;
}

void kd_analysis::kd_analysis(kd_analysis *this)
{
  uint64_t v1 = 0;
  *(void *)this = &unk_1ED4DEF40;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((void *)this + 18) = 0;
  uint64_t v2 = (kd_analysis *)((char *)this + 336);
  do
  {
    uint64_t v3 = v1;
    uint64_t v4 = 2;
    do
    {
      int v5 = (char *)this + v3;
      *((_DWORD *)v5 + 84) = 0;
      *((_WORD *)v5 + 171) = 0;
      *((void *)v5 + 43) = 0;
      v3 += 16;
      --v4;
    }
    while (v4);
    uint64_t v2 = (kd_analysis *)((char *)v2 + 40);
    v1 += 40;
  }
  while (v2 != (kd_analysis *)((char *)this + 576));
  *((void *)this + 13) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 11) = 0;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((void *)this + 25) = 0;
}

void kdu_synthesis::kdu_synthesis(void *a1, uint64_t a2)
{
  uint64_t v2 = a2;
  *a1 = 0;
  operator new();
}

void sub_1886BE508(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B1C40833BFE5ALL);
  _Unwind_Resume(a1);
}

float *kd_synthesis::init(uint64_t a1, int32x4_t *a2, kdu_sample_allocator *a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, double a8)
{
  uint64_t v218 = *MEMORY[0x1E4F143B8];
  int v214 = a2;
  uint64_t v213 = kdu_node::access_resolution((kdu_node *)&v214);
  char reversible = kdu_resolution::get_reversible((kdu_resolution *)&v213);
  *(_DWORD *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 40) = reversible;
  *(unsigned char *)(a1 + 206) = a4;
  *(unsigned char *)(a1 + 41) = 0;
  *(void *)(a1 + 104) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  int v198 = (int *)(a1 + 48);
  unsigned int v199 = (int *)(a1 + 44);
  *(_WORD *)(a1 + 98) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(void *)(a1 + 88) = 0;
  char kernel_id = kdu_node::get_kernel_id((kdu_node *)&v214);
  *(void *)(a1 + 264) = 0;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  int32x4_t v212 = 0uLL;
  uint64_t result = (float *)kdu_node::get_dims(&v214, &v212);
  __int32 v15 = v212.i32[0];
  __int32 v14 = v212.i32[1];
  __int32 v16 = v212.i32[2];
  __int32 v17 = v212.i32[0] + v212.i32[2] - 1;
  int v18 = v212.i32[1] - a5;
  __int32 v19 = v212.i32[3] - 1;
  BOOL v21 = v212.i32[3] < 1;
  __int32 v20 = v212.i32[3] - 1 + v212.i32[1];
  *(_DWORD *)(a1 + 112) = v212.i32[0];
  *(_DWORD *)(a1 + 120) = v17;
  *(_DWORD *)(a1 + 184) = v14;
  *(_DWORD *)(a1 + 188) = v20;
  *(_DWORD *)(a1 + 200) = v18;
  *(_DWORD *)(a1 + 148) = v18;
  BOOL v21 = v21 || v16 < 1;
  char v22 = v21;
  *(unsigned char *)(a1 + 209) = v22;
  *(unsigned char *)(a1 + 207) = v17 == v15;
  *(unsigned char *)(a1 + 208) = v19 == 0;
  if (v22) {
    return result;
  }
  long long v216 = 0u;
  long long v217 = 0u;
  *(void *)&long long v216 = kdu_node::access_child((kdu_node *)&v214, 0);
  *((void *)&v216 + 1) = kdu_node::access_child((kdu_node *)&v214, 1u);
  *(void *)&long long v217 = kdu_node::access_child((kdu_node *)&v214, 2u);
  *((void *)&v217 + 1) = kdu_node::access_child((kdu_node *)&v214, 3u);
  if (!(void)v216) {
    kd_synthesis::init();
  }
  int32x4_t v211 = 0uLL;
  kdu_node::get_dims((int32x4_t **)&v216, &v211);
  uint64_t v23 = *((void *)&v216 + 1);
  uint64_t v24 = v217;
  *(unsigned char *)(a1 + 42) = (void)v217 != 0;
  int v25 = v23 != 0;
  *(unsigned char *)(a1 + 43) = v25;
  float v209 = 1.0;
  float v210 = 1.0;
  float v207 = 1.0;
  float v208 = 1.0;
  *(unsigned char *)(a1 + 207) = 0;
  if (v24)
  {
    *(void *)int v205 = 0;
    *(void *)int v206 = 0;
    uint64_t kernel_info = kdu_node::get_kernel_info((kdu_node *)&v214, v199, &v210, &v209, (BOOL *)(a1 + 96), (BOOL *)(a1 + 98), &v206[1], v206, &v205[1], v205, 1);
    if (v206[0] <= v205[0]) {
      int v26 = v205[0];
    }
    else {
      int v26 = v206[0];
    }
    if (v206[1] >= v205[1]) {
      int v27 = v205[1];
    }
    else {
      int v27 = v206[1];
    }
    LODWORD(v28) = *(_DWORD *)(a1 + 44);
    if ((int)v28 > 4) {
      operator new[]();
    }
    uint64_t v29 = a1 + 640;
    *(void *)(a1 + 80) = v29;
    if ((int)v28 < 1)
    {
      int v33 = 0;
      int v32 = 0;
    }
    else
    {
      int v33 = 0;
      int v32 = 0;
      char v34 = *(unsigned char *)(a1 + 40);
      unint64_t v35 = (_DWORD *)(kernel_info + 8);
      uint64_t v28 = v28;
      do
      {
        *(_WORD *)(v29 + 4) = *(v35 - 1);
        int v36 = *(v35 - 2);
        *(unsigned char *)(v29 + 1) = v36;
        *(unsigned char *)(v29 + 2) = *v35;
        *(_WORD *)(v29 + 6) = v35[1];
        if (v33 <= v36) {
          int v33 = v36;
        }
        *(unsigned char *)(v29 + 30) = kernel_id;
        *(unsigned char *)(v29 + 29) = v34;
        v32 += v36;
        v29 += 32;
        v35 += 4;
        --v28;
      }
      while (v28);
      if (v33 > 4) {
        operator new[]();
      }
    }
    *(void *)(a1 + 56) = a1 + 336 + 8 * v33;
    *(void *)(a1 + 64) = a1 + 336;
    float32x4_t v215 = 0uLL;
    kdu_node::get_dims((int32x4_t **)&v217, (int32x4_t *)&v215);
    int v37 = v211.i32[2];
    __int32 v38 = 2 * v211.i32[0];
    __int32 v39 = 2 * (v211.i32[2] + v211.i32[0]) - 2;
    __int32 v40 = v215.i32[0];
    int v41 = v215.i32[2];
    __int32 v42 = (2 * v215.i32[0]) | 1;
    *(_DWORD *)(a1 + 124) = 2 * v211.i32[0];
    *(_DWORD *)(a1 + 128) = v42;
    int v43 = 2 * (v41 + v40) - 1;
    *(_DWORD *)(a1 + 140) = v39;
    *(_DWORD *)(a1 + 144) = v43;
    if (v41 <= 0)
    {
      *(unsigned char *)(a1 + 207) = 1;
      if (v38 != v39)
      {
        exception = __cxa_allocate_exception(4uLL);
        _DWORD *exception = -1;
        __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
      }
      __int32 v42 = v38 | 1;
      *(_DWORD *)(a1 + 128) = v38 | 1;
      int v43 = v38 - 1;
      *(_DWORD *)(a1 + 144) = v38 - 1;
    }
    if (v37 <= 0)
    {
      *(unsigned char *)(a1 + 207) = 1;
      if (v42 != v43) {
        kd_synthesis::init();
      }
      *(_DWORD *)(a1 + 124) = v43 + 1;
      *(_DWORD *)(a1 + 140) = v43 - 1;
    }
    char v30 = a5;
    int v31 = v26 - v27;
    int v25 = *(unsigned __int8 *)(a1 + 43);
  }
  else
  {
    char v30 = a5;
    int v31 = 0;
    int v32 = 0;
    uint64_t kernel_info = 0;
    *(_DWORD *)(a1 + 124) = *(_DWORD *)(a1 + 112);
    *(_DWORD *)(a1 + 140) = *(_DWORD *)(a1 + 120);
  }
  *(unsigned char *)(a1 + 208) = 0;
  if (v25)
  {
    *(void *)int v205 = 0;
    *(void *)int v206 = 0;
    uint64_t v44 = kdu_node::get_kernel_info((kdu_node *)&v214, (int *)(a1 + 48), &v208, &v207, (BOOL *)(a1 + 97), (BOOL *)(a1 + 99), &v206[1], v206, &v205[1], v205, 0);
    if (v44 == kernel_info)
    {
      uint64_t v46 = *(void *)(a1 + 80);
    }
    else
    {
      uint64_t v45 = *v199;
      if ((int)v45 + *v198 > 4) {
        operator new[]();
      }
      uint64_t v46 = a1 + 32 * v45 + 640;
    }
    *(void *)(a1 + 88) = v46;
    if (v46 != *(void *)(a1 + 80))
    {
      uint64_t v50 = *v198;
      if ((int)v50 >= 1)
      {
        char v51 = *(unsigned char *)(a1 + 40);
        uint64_t v52 = (_DWORD *)(v44 + 8);
        do
        {
          *(_WORD *)(v46 + 4) = *(v52 - 1);
          int v53 = *(v52 - 2);
          *(unsigned char *)(v46 + 1) = v53;
          *(unsigned char *)(v46 + 2) = *v52;
          *(_WORD *)(v46 + 6) = v52[1];
          *(unsigned char *)(v46 + 30) = kernel_id;
          *(unsigned char *)(v46 + 29) = v51;
          v32 += v53;
          v46 += 32;
          v52 += 4;
          --v50;
        }
        while (v50);
      }
    }
    float32x4_t v215 = 0uLL;
    kdu_node::get_dims((int32x4_t **)&v216 + 1, (int32x4_t *)&v215);
    __int32 v54 = v211.i32[1];
    int v55 = v211.i32[3];
    __int32 v56 = 2 * v211.i32[1];
    __int32 v57 = 2 * (v211.i32[3] + v211.i32[1]) - 2;
    __int32 v58 = v215.i32[1];
    __int32 v59 = v215.i32[3];
    if (v215.i64[1] <= 0)
    {
      *(unsigned char *)(a1 + 208) = 1;
      __int32 v60 = v56;
      __int32 v61 = v56;
      if (v56 != v57) {
        kd_synthesis::init();
      }
    }
    else
    {
      __int32 v60 = 2 * v215.i32[1];
      __int32 v61 = 2 * (v215.i32[3] + v215.i32[1]);
    }
    int v62 = v61 - 1;
    int v63 = v60 | 1;
    if (v55 <= 0)
    {
      *(unsigned char *)(a1 + 208) = 1;
      if (v63 != v62) {
        kd_synthesis::init();
      }
      __int32 v56 = v60 + 2;
      __int32 v57 = v60;
    }
    if (v56 >= v63) {
      int v64 = v60 | 1;
    }
    else {
      int v64 = v56;
    }
    if (v57 > v62) {
      int v62 = v57;
    }
    *(_DWORD *)(a1 + 152) = v64;
    *(_DWORD *)(a1 + 156) = v62;
    unsigned int v65 = *(_DWORD *)(a1 + 148);
    if (v64 < (int)v65)
    {
      if (a4) {
        int v66 = -8;
      }
      else {
        int v66 = -4;
      }
      do
        v65 += v66;
      while (v64 < (int)v65);
      *(_DWORD *)(a1 + 148) = v65;
    }
    unsigned int v67 = ((v64 + 1) >> 1) - ((v65 + 1) >> 1);
    *(unsigned char *)(a1 + 168) = ((v64 + 1) >> 1) - ((v65 + 1) >> 1);
    int v68 = (v64 >> 1) - (v65 >> 1);
    *(unsigned char *)(a1 + 169) = (v64 >> 1) - (v65 >> 1);
    int v69 = (v62 >> 1) - ((v64 + 1) >> 1) + 1;
    int v70 = ((v62 - 1) >> 1) - (v64 >> 1) + 1;
    *(_DWORD *)(a1 + 160) = v69;
    *(_DWORD *)(a1 + 164) = v70;
    unsigned __int32 v71 = v54 - ((v65 + 1) >> 1);
    *(unsigned char *)(a1 + 170) = v54 - ((v65 + 1) >> 1);
    __int32 v72 = v58 - (v65 >> 1);
    *(unsigned char *)(a1 + 171) = v72;
    *(_DWORD *)(a1 + 172) = v55;
    *(_DWORD *)(a1 + 176) = v59;
    int v73 = (v54 - ((v65 + 1) >> 1)) - v67;
    if (v73 < 0
      || (int v74 = v69 + v67 - (v55 + v71), v74 < 0)
      || v74 > 255
      || v72 - v68 < 0
      || (int v75 = v70 + v68 - (v59 + v72), v75 < 0)
      || v75 >= 256)
    {
      kd_synthesis::init();
    }
    *(unsigned char *)(a1 + 180) = v73;
    *(unsigned char *)(a1 + 182) = v74;
    *(unsigned char *)(a1 + 181) = v72 - v68;
    *(unsigned char *)(a1 + 183) = v75;
    int v76 = *(_DWORD *)(a1 + 184);
    int v77 = *(_DWORD *)(a1 + 188);
    *(unsigned char *)(a1 + 205) = (v76 >> 1) - (v65 >> 1);
    *(unsigned char *)(a1 + 204) = ((v76 + 1) >> 1) - ((v65 + 1) >> 1);
    *(_DWORD *)(a1 + 192) = (v77 >> 1) - ((v76 + 1) >> 1) + 1;
    *(_DWORD *)(a1 + 196) = ((v77 - 1) >> 1) - (v76 >> 1) + 1;
  }
  else
  {
    int v47 = *(_DWORD *)(a1 + 184);
    int v48 = *(_DWORD *)(a1 + 188);
    *(_DWORD *)(a1 + 152) = v47;
    *(_DWORD *)(a1 + 156) = v48;
    *(unsigned char *)(a1 + 170) = v30;
    unsigned int v49 = v48 - v47 + 1;
    *(_DWORD *)(a1 + 172) = v49;
    *(unsigned char *)(a1 + 171) = 0;
    *(void *)(a1 + 176) = 0;
    *(_WORD *)(a1 + 204) = (v47 - *(unsigned char *)(a1 + 148));
    *(void *)(a1 + 192) = v49;
  }
  if (v32 >= 9) {
    operator new[]();
  }
  int v78 = (_DWORD *)(a1 + 272);
  uint64_t v79 = (_DWORD *)(a1 + 304);
  if (*(unsigned char *)(a1 + 42))
  {
    uint64_t kernel_coefficients = kdu_node::get_kernel_coefficients((kdu_node *)&v214, 1);
    uint64_t v81 = (int *)(a1 + 44);
    int v82 = *v199;
    if (*v199 >= 1)
    {
      uint64_t v83 = 0;
      uint64_t v84 = *(void *)(a1 + 80);
      int v85 = *(unsigned __int8 *)(a1 + 40);
      do
      {
        uint64_t v86 = v84 + 32 * v83;
        *(unsigned char *)uint64_t v86 = v83;
        *(void *)(v86 + 8) = v78;
        *(void *)(v86 + 16) = v79;
        *(unsigned char *)(v86 + 28) = 0;
        uint64_t v87 = *(unsigned __int8 *)(v86 + 1);
        if (v87)
        {
          uint64_t v88 = v87;
          uint64_t v89 = (float *)kernel_coefficients;
          uint64_t v90 = v78;
          float v91 = 0.4;
          do
          {
            float v92 = *v89;
            _DWORD *v90 = *(_DWORD *)v89;
            if (v92 <= v91)
            {
              if (v92 < (float)-v91) {
                float v91 = -v92;
              }
            }
            else
            {
              float v91 = v92;
            }
            ++v90;
            ++v89;
            --v88;
          }
          while (v88);
          if (v85)
          {
LABEL_89:
            unsigned __int8 v94 = *(unsigned char *)(v84 + 32 * v83 + 2);
            if (v87) {
              goto LABEL_93;
            }
            goto LABEL_96;
          }
          uint64_t v93 = v84 + 32 * v83;
          unsigned __int8 v94 = 16;
          *(unsigned char *)(v93 + 2) = 16;
          int v95 = (unsigned __int8 *)(v93 + 2);
          if (v91 >= 0.499)
          {
            unsigned __int8 v94 = 16;
            do
            {
              --v94;
              float v91 = v91 * 0.5;
            }
            while (v91 >= 0.499);
            *int v95 = v94;
            if (v94 < 0x10u)
            {
              *(_WORD *)(v84 + 32 * v83 + 6) = 1 << (v94 - 1);
LABEL_93:
              float v96 = (float)(1 << v94);
              uint64_t v97 = v87;
              uint64_t v98 = (float *)v78;
              char v99 = v79;
              do
              {
                float v100 = *v98++;
                *v99++ = vcvtmd_s64_f64((float)(v100 * v96) + 0.5);
                --v97;
              }
              while (v97);
              int v82 = *v199;
              goto LABEL_96;
            }
          }
        }
        else
        {
          if (v85) {
            goto LABEL_89;
          }
          unsigned __int8 v94 = 16;
          *(unsigned char *)(v84 + 32 * v83 + 2) = 16;
        }
        *(_WORD *)(v84 + 32 * v83 + 6) = 0x7FFF;
        if (v87) {
          goto LABEL_93;
        }
LABEL_96:
        v78 += v87;
        v79 += v87;
        kernel_coefficients += 4 * v87;
        uint64_t v101 = v84 + 32 * v83;
        *(unsigned char *)(v101 + 3) = 0;
        *(_DWORD *)(v101 + 24) = 0;
        ++v83;
      }
      while (v83 < v82);
    }
  }
  else
  {
    uint64_t v81 = (int *)(a1 + 44);
  }
  if (*(unsigned char *)(a1 + 43))
  {
    uint64_t v102 = kdu_node::get_kernel_coefficients((kdu_node *)&v214, 0);
    if (*v198 >= 1)
    {
      uint64_t v103 = 0;
      int v104 = 0;
      uint64_t v106 = *(void *)(a1 + 80);
      uint64_t v105 = *(void *)(a1 + 88);
      uint64_t v81 = (int *)(a1 + 44);
      while (1)
      {
        if (v105 == v106)
        {
          uint64_t v117 = v105 + 32 * v103;
          uint64_t v108 = *(unsigned __int8 *)(v117 + 1);
          if (*(unsigned char *)(v117 + 1))
          {
            uint64x2_t v118 = *(float **)(v117 + 8);
            uint64_t v119 = v108;
            unsigned int v120 = (float *)v102;
            do
            {
              if (*v118 != *v120) {
                kd_synthesis::init();
              }
              ++v120;
              ++v118;
              --v119;
            }
            while (v119);
          }
          goto LABEL_129;
        }
        uint64_t v107 = v105 + 32 * v103;
        *(unsigned char *)uint64_t v107 = v103;
        *(_DWORD *)(v107 + 24) = 0;
        *(void *)(v107 + 8) = v78;
        *(void *)(v107 + 16) = v79;
        *(unsigned char *)(v107 + 28) = 0;
        uint64_t v108 = *(unsigned __int8 *)(v107 + 1);
        if (v108)
        {
          uint64_t v109 = v108;
          uint64_t v110 = (float *)v102;
          uint64_t v111 = v78;
          float v112 = 0.4;
          do
          {
            float v113 = *v110;
            _DWORD *v111 = *(_DWORD *)v110;
            if (v113 <= v112)
            {
              if (v113 < (float)-v112) {
                float v112 = -v113;
              }
            }
            else
            {
              float v112 = v113;
            }
            ++v111;
            ++v110;
            --v109;
          }
          while (v109);
          if (*(unsigned char *)(a1 + 40))
          {
LABEL_122:
            unsigned __int8 v115 = *(unsigned char *)(v105 + 32 * v103 + 2);
            if (v108) {
              goto LABEL_126;
            }
            goto LABEL_128;
          }
          uint64_t v114 = v105 + 32 * v103;
          unsigned __int8 v115 = 16;
          *(unsigned char *)(v114 + 2) = 16;
          uint64_t v116 = (unsigned __int8 *)(v114 + 2);
          if (v112 >= 0.499)
          {
            unsigned __int8 v115 = 16;
            do
            {
              --v115;
              float v112 = v112 * 0.5;
            }
            while (v112 >= 0.499);
            *uint64_t v116 = v115;
            if (v115 < 0x10u)
            {
              *(_WORD *)(v105 + 32 * v103 + 6) = 1 << (v115 - 1);
LABEL_126:
              float v121 = (float)(1 << v115);
              uint64_t v122 = v108;
              int64x2_t v123 = (float *)v78;
              int32x2_t v124 = v79;
              do
              {
                float v125 = *v123++;
                *v124++ = vcvtmd_s64_f64((float)(v125 * v121) + 0.5);
                --v122;
              }
              while (v122);
              goto LABEL_128;
            }
          }
        }
        else
        {
          if (*(unsigned char *)(a1 + 40)) {
            goto LABEL_122;
          }
          unsigned __int8 v115 = 16;
          *(unsigned char *)(v105 + 32 * v103 + 2) = 16;
        }
        *(_WORD *)(v105 + 32 * v103 + 6) = 0x7FFF;
        if (v108) {
          goto LABEL_126;
        }
LABEL_128:
        v78 += v108;
        v79 += v108;
LABEL_129:
        uint64_t v126 = v105 + 32 * v103;
        int v127 = *(__int16 *)(v126 + 4);
        if (v103) {
          int v128 = -1;
        }
        else {
          int v128 = 1;
        }
        int v129 = (*(unsigned __int8 *)(a1 + 152) << 31 >> 31) & v128;
        if (v103) {
          int v130 = 1;
        }
        else {
          int v130 = -1;
        }
        int v131 = v129 - v127;
        if (*(unsigned char *)(a1 + 156)) {
          int v130 = 0;
        }
        int v132 = v108 + v127 + v130 - 1;
        if (v131 > v132) {
          int v132 = v131;
        }
        int v133 = v132 & ~(v132 >> 31);
        if (v133 >= 0x100) {
          kd_synthesis::init();
        }
        if (v133 > v104) {
          int v104 = v133;
        }
        v102 += 4 * v108;
        *(unsigned char *)(v126 + 3) = v133;
        if (++v103 >= *v198) {
          goto LABEL_146;
        }
      }
    }
    int v104 = 0;
    uint64_t v81 = (int *)(a1 + 44);
  }
  else
  {
    int v104 = 0;
  }
LABEL_146:
  if (*v81 >= 1 && !*(unsigned char *)(a1 + 207))
  {
    if (*v81 > 4) {
      operator new[]();
    }
    *(void *)(a1 + 104) = a1 + 816;
  }
  int v134 = *(_DWORD *)(a1 + 172);
  int v135 = v134 + *(unsigned __int8 *)(a1 + 170);
  if (*(unsigned char *)(a1 + 43))
  {
    unsigned int v136 = *(unsigned __int8 *)(a1 + 168);
    unsigned int v137 = *(unsigned __int8 *)(a1 + 169);
    if (v136 >= v137) {
      int v138 = *(unsigned __int8 *)(a1 + 169);
    }
    else {
      int v138 = *(unsigned __int8 *)(a1 + 168);
    }
    int v139 = (v104 - v138) & ~((v104 - v138) >> 31);
    int v140 = *(_DWORD *)(a1 + 160) + v136;
    int v141 = *(_DWORD *)(a1 + 164) + v137;
    if (v140 <= v141) {
      LOBYTE(v140) = v141;
    }
    char v142 = v140 + v104;
  }
  else
  {
    LOBYTE(v139) = 0;
    char v142 = v134 + *(unsigned char *)(a1 + 170);
  }
  int v143 = *(unsigned __int8 *)(a1 + 171);
  int v144 = *(_DWORD *)(a1 + 176);
  if (*v81 < 1 || *(unsigned char *)(a1 + 207))
  {
    *(void *)(a1 + 72) = 0;
    LODWORD(v145) = 1;
LABEL_162:
    uint64_t v146 = 0;
    int v147 = v144 + v143;
    uint64_t v145 = v145;
    do
    {
      uint64_t v148 = *(void *)(a1 + 240);
      float32x4_t v149 = (void *)(v148 + v146 + 32);
      if (!v148)
      {
        float32x4_t v149 = (void *)(a1 + 432 + v146);
        uint64_t v148 = a1 + 400;
      }
      *float32x4_t v149 = *(void *)(a1 + 72);
      *(void *)(a1 + 72) = v148 + v146;
      uint64_t result = (float *)kd_vlift_line::pre_create((kd_vlift_line *)(v148 + v146), a3, v135, v147, *(unsigned char *)(a1 + 40), a4, v139, v142, *(unsigned char *)(a1 + 43));
      v146 += 40;
      --v145;
    }
    while (v145);
    goto LABEL_166;
  }
  uint64_t result = (float *)kd_synthesis::simulate_vertical_lifting((kd_synthesis *)a1, v31);
  LODWORD(v145) = result;
  if (result >= 7) {
    operator new[]();
  }
  *(void *)(a1 + 72) = 0;
  if (result) {
    goto LABEL_162;
  }
LABEL_166:
  *(_DWORD *)(a1 + 116) = *(_DWORD *)(a1 + 112);
  int v150 = *(_DWORD *)(a1 + 124);
  int v151 = *(_DWORD *)(a1 + 128);
  *(_DWORD *)(a1 + 132) = v150;
  *(_DWORD *)(a1 + 136) = v151;
  LODWORD(v152) = *(_DWORD *)(a1 + 44);
  if (!*(void *)(a1 + 104))
  {
LABEL_184:
    if ((int)v152 >= 1)
    {
      uint64_t v163 = 0;
      int v164 = (_DWORD *)(*(void *)(a1 + 80) + 24);
      do
      {
        _DWORD *v164 = *(_DWORD *)(a1 + 4 * ((v163 & 1) == 0) + 124);
        v164 += 8;
        ++v163;
      }
      while (v152 != v163);
    }
    goto LABEL_187;
  }
  if (v150 >= v151) {
    int v153 = v151;
  }
  else {
    int v153 = v150;
  }
  if (*(_DWORD *)(a1 + 140) <= *(_DWORD *)(a1 + 144)) {
    int v154 = *(_DWORD *)(a1 + 144);
  }
  else {
    int v154 = *(_DWORD *)(a1 + 140);
  }
  if ((v152 & 0x80000000) == 0)
  {
    uint64_t v155 = -1;
    uint64_t v156 = -48;
    do
    {
      uint64_t v157 = a1 + 4 * (v155 & 1);
      if (*(_DWORD *)(v157 + 124) <= v153 + 1) {
        int v158 = v153;
      }
      else {
        int v158 = *(_DWORD *)(v157 + 124);
      }
      int v159 = *(_DWORD *)(v157 + 140);
      if (v159 >= v154 - 1) {
        int v160 = v154;
      }
      else {
        int v160 = v159;
      }
      int v161 = v160;
      if (v155 >= 1)
      {
        uint64_t v162 = *(void *)(a1 + 80) + 32 * v155;
        int v161 = v159 + 2 * (*(__int16 *)(v162 + 4) + *(unsigned __int8 *)(v162 + 1)) - 2;
      }
      uint64_t result = (float *)kd_vlift_queue::init(*(void *)(a1 + 104) + v156, v158, v160, v155++, *(unsigned char *)(a1 + 98), v161);
      uint64_t v152 = *(int *)(a1 + 44);
      v156 += 48;
    }
    while (v155 < v152);
    goto LABEL_184;
  }
LABEL_187:
  float32x4_t v215 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a8, 0);
  *(_DWORD *)(a1 + 100) = 0;
  if (!*(unsigned char *)(a1 + 40))
  {
    v206[1] = 0;
    uint64_t bibo_gains = kdu_node::get_bibo_gains((kdu_node *)&v214, &v206[1], 1);
    if (v206[1] != *v199) {
      kd_synthesis::init();
    }
    uint64_t v166 = bibo_gains;
    uint64_t result = (float *)kdu_node::get_bibo_gains((kdu_node *)&v214, &v206[1], 0);
    uint64_t v167 = v206[1];
    if (v206[1] != *v198) {
      kd_synthesis::init();
    }
    uint64_t v168 = *v199;
    float v169 = *(float *)&a8;
    float v170 = *(float *)&a8;
    float v171 = *(float *)&a8;
    if ((int)v168 >= 1)
    {
      float v169 = *(float *)&a8;
      float v170 = *(float *)&a8;
      float v171 = *(float *)&a8;
      if (!*(unsigned char *)(a1 + 207))
      {
        uint64_t v172 = 0;
        float v170 = *(float *)&a8 / v210;
        v215.f32[0] = *(float *)&a8 / v210;
        v215.f32[1] = *(float *)&a8 / v210;
        float v169 = *(float *)&a8 / v209;
        v215.f32[2] = *(float *)&a8 / v209;
        v215.f32[3] = *(float *)&a8 / v209;
        float v173 = *result * *(float *)&a8;
        unsigned int v174 = (float *)(v166 + 4);
        float v175 = v173;
        float v171 = *(float *)&a8;
        do
        {
          float v176 = v175;
          float v175 = v173 * *v174;
          if (v175 > v171) {
            float v171 = v173 * *v174;
          }
          if (a4)
          {
            float v177 = v176 + v176;
            if (*(unsigned char *)(*(void *)(a1 + 80) + v172 + 28) && v177 > v171) {
              float v171 = v177;
            }
          }
          v172 += 32;
          ++v174;
        }
        while (32 * v168 != v172);
      }
    }
    if (v206[1] >= 1 && !*(unsigned char *)(a1 + 208))
    {
      v215.f32[0] = v170 / v208;
      v215.f32[1] = v170 / v207;
      v215.f32[2] = v169 / v208;
      v215.f32[3] = v169 / v207;
      float v179 = *(float *)(v166 + 4 * (int)v168);
      if ((int)v168 >= 1 && *(float *)(v166 + 4 * (v168 - 1)) > v179) {
        float v179 = *(float *)(v166 + 4 * (v168 - 1));
      }
      float v180 = v179 * *(float *)&a8;
      BOOL v181 = result + 1;
      uint64_t v182 = 28;
      float v183 = v180;
      do
      {
        float v184 = v183;
        float v183 = v180 * *v181;
        if (v183 > v171) {
          float v171 = v180 * *v181;
        }
        if (a4)
        {
          float v185 = v184 + v184;
          if (*(unsigned char *)(*(void *)(a1 + 88) + v182) && v185 > v171) {
            float v171 = v185;
          }
        }
        v182 += 32;
        ++v181;
        --v167;
      }
      while (v167);
    }
    if (v171 > 7.6)
    {
      int v187 = *(_DWORD *)(a1 + 100);
      float32x4_t v188 = v215;
      v189.i64[0] = 0x3F0000003F000000;
      v189.i64[1] = 0x3F0000003F000000;
      do
      {
        float32x4_t v188 = vmulq_f32(v188, v189);
        ++v187;
        float v171 = v171 * 0.5;
      }
      while (v171 > 7.6);
      float32x4_t v215 = v188;
      *(_DWORD *)(a1 + 100) = v187;
    }
  }
  int v190 = (float *)&v215;
  unsigned int v191 = (kdu_node *)&v216;
  for (uint64_t i = 1; i != 5; ++i)
  {
    if (*(void *)v191)
    {
      uint64_t v193 = *(unsigned __int8 *)(a1 + (((_BYTE)i - 1) & 1) + 170);
      if (kdu_node::access_child(v191, 0)) {
        kdu_synthesis::kdu_synthesis(&v203);
      }
      uint64_t v194 = kdu_node::access_subband(v191);
      uint64_t result = (float *)kdu_decoder::kdu_decoder(&v204, v194, a3, a4, v193, a6, a7, *v190);
      *(void *)(a1 + 8 * i) = v204;
    }
    ++v190;
    unsigned int v191 = (kdu_node *)((char *)v191 + 8);
  }
  return result;
}

void kdu_synthesis::kdu_synthesis(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1886BF6D4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B1C40833BFE5ALL);
  _Unwind_Resume(a1);
}

uint64_t kd_synthesis::simulate_vertical_lifting(kd_synthesis *this, int a2)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  int v3 = *((_DWORD *)this + 30);
  int v4 = *((_DWORD *)this + 35);
  int v5 = *((_DWORD *)this + 36);
  int v54 = 0;
  int v55 = v4;
  int v56 = v5;
  int v6 = *((_DWORD *)this + 28);
  int v7 = v3 - (v6 + a2) - 2;
  if (v7 >= 1)
  {
    unsigned int v8 = v7 & 0xFFFFFFFE;
    v3 -= v8;
    v4 -= v8;
    v5 -= v8;
    int v55 = v4;
    int v56 = v5;
  }
  *((_DWORD *)this + 29) = v6;
  int v9 = *((_DWORD *)this + 31);
  int v10 = *((_DWORD *)this + 32);
  *((_DWORD *)this + 33) = v9;
  *((_DWORD *)this + 34) = v10;
  if (v9 >= v10) {
    int v11 = v10;
  }
  else {
    int v11 = v9;
  }
  if (v4 <= v5) {
    int v12 = v5;
  }
  else {
    int v12 = v4;
  }
  if ((*((_DWORD *)this + 11) & 0x80000000) == 0)
  {
    uint64_t v13 = -1;
    uint64_t v14 = -48;
    do
    {
      if (*((_DWORD *)this + (v13 & 1) + 31) <= v11 + 1) {
        int v15 = v11;
      }
      else {
        int v15 = *((_DWORD *)this + (v13 & 1) + 31);
      }
      int v16 = *(_DWORD *)((unint64_t)&v55 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v13 & 1)));
      if (v16 >= v12 - 1) {
        int v17 = v12;
      }
      else {
        int v17 = *(_DWORD *)((unint64_t)&v55 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v13 & 1)));
      }
      int v18 = v17;
      if (v13 >= 1)
      {
        uint64_t v19 = *((void *)this + 10) + 32 * v13;
        int v18 = v16 + 2 * (*(__int16 *)(v19 + 4) + *(unsigned __int8 *)(v19 + 1)) - 2;
      }
      kd_vlift_queue::init(*((void *)this + 13) + v14, v15, v17, v13++, *((unsigned char *)this + 98), v18);
      v14 += 48;
    }
    while (v13 < *((int *)this + 11));
    uint64_t v20 = *((unsigned int *)this + 11);
    if ((int)v20 >= 1)
    {
      uint64_t v21 = 0;
      char v22 = (_DWORD *)(*((void *)this + 10) + 24);
      do
      {
        *char v22 = *((_DWORD *)this + ((v21 & 1) == 0) + 31);
        v22 += 8;
        ++v21;
      }
      while (v20 != v21);
    }
  }
  if (*((_DWORD *)this + 29) <= v3)
  {
    int v53 = v3;
    uint64_t v23 = 0;
    for (unsigned int i = -1; ; unsigned int i = v26)
    {
      while (2)
      {
        while ((i & 0x80000000) != 0)
        {
LABEL_51:
          unsigned int i = !(*((_DWORD *)this + 29) & 1);
          if (kd_vlift_queue::simulate_access_update((kd_vlift_queue *)(*((void *)this + 13) + 48 * -(*((_DWORD *)this + 29) & 1)), *((_DWORD *)this + 29), &v54))
          {
            int v52 = *((_DWORD *)this + 29);
            *((_DWORD *)this + 29) = v52 + 1;
            unsigned int i = -1;
            if (v52 >= v53) {
              return v23;
            }
          }
        }
        uint64_t v26 = i + 1;
        uint64_t v27 = 48 * i - 48;
        uint64_t v28 = 32 * i;
        while (1)
        {
          uint64_t v29 = v26 - 1;
          BOOL v30 = ((v26 - 1) & 1) == 0;
          uint64_t v31 = *((unsigned int *)this + 11);
          if (v26 - 1 == v31)
          {
            int v32 = (char *)this + 4 * (((v26 - 1) & 1) == 0);
            int v35 = *((_DWORD *)v32 + 33);
            char v34 = v32 + 132;
            int v33 = v35;
            if (v35 <= *(_DWORD *)((unint64_t)&v55 & 0xFFFFFFFFFFFFFFFBLL | (4 * (((v26 - 1) & 1) == 0))))
            {
              int v36 = v54++;
              if (v36 >= (int)v23) {
                uint64_t v23 = (v36 + 1);
              }
              else {
                uint64_t v23 = v23;
              }
              kd_vlift_queue::simulate_push_line(*((void *)this + 13) + v27, v33, &v54);
              *v34 += 2;
            }
            goto LABEL_50;
          }
          uint64_t v37 = *((void *)this + 10);
          uint64_t v38 = v37 + v28;
          int v39 = *(_DWORD *)(v37 + v28 + 24);
          if (v39 <= *(_DWORD *)((unint64_t)&v55 | (4 * v30))) {
            break;
          }
LABEL_50:
          v27 -= 48;
          v28 -= 32;
          --v26;
          if (v29 <= 0) {
            goto LABEL_51;
          }
        }
        uint64_t v40 = (int)v31;
        int v41 = *(__int16 *)(v38 + 4);
        uint64_t v42 = v40 - 1;
        uint64_t v43 = *((void *)this + 13);
        if (v29 < v42)
        {
          uint64_t v44 = v43 + 48 * v26;
          *(_DWORD *)(v44 + 36) = v39;
          if (*(_DWORD *)(v44 + 24) > v39 || *(_DWORD *)(v43 + 48 * v26 + 28) < v39)
          {
            unsigned int i = v26 + 1;
            continue;
          }
        }
        break;
      }
      if (kd_vlift_queue::simulate_access_source((kd_vlift_queue *)(v43 + v27 + 48), (v39 ^ 1u) + 2 * v41, *(unsigned __int8 *)(v37 + v28 + 1), &v54))
      {
        if (v29 == *((_DWORD *)this + 11) - 1)
        {
          int v45 = v54;
          unsigned int v46 = ++v54;
          int v47 = *(_DWORD *)(v38 + 24);
          int v48 = (char *)this + 4 * v30;
          int v50 = *((_DWORD *)v48 + 33);
          unsigned int v49 = v48 + 132;
          if (v47 != v50) {
            kd_synthesis::simulate_vertical_lifting();
          }
          if (v45 >= (int)v23) {
            uint64_t v23 = v46;
          }
          else {
            uint64_t v23 = v23;
          }
          _DWORD *v49 = v47 + 2;
        }
        else
        {
          kd_vlift_queue::simulate_access_update((kd_vlift_queue *)(*((void *)this + 13) + 48 * v26), *(_DWORD *)(v38 + 24), &v54);
          int v51 = v54++;
          if (v51 >= (int)v23) {
            uint64_t v23 = (v51 + 1);
          }
          else {
            uint64_t v23 = v23;
          }
        }
        kd_vlift_queue::simulate_push_line(*((void *)this + 13) + v27, *(_DWORD *)(v38 + 24), &v54);
        *(_DWORD *)(v38 + 24) += 2;
        goto LABEL_50;
      }
    }
  }
  return 0;
}

void kd_synthesis::~kd_synthesis(kd_synthesis *this)
{
  *(void *)this = &unk_1ED4DF480;
  for (uint64_t i = 8; i != 40; i += 8)
  {
    uint64_t v3 = *(void *)((char *)this + i);
    if (v3)
    {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
      *(void *)((char *)this + i) = 0;
    }
  }
  uint64_t v4 = *((void *)this + 27);
  if (v4) {
    MEMORY[0x18C11C0C0](v4, 0x1000C8052888210);
  }
  uint64_t v5 = *((void *)this + 28);
  if (v5) {
    MEMORY[0x18C11C0C0](v5, 0x1000C8052888210);
  }
  uint64_t v6 = *((void *)this + 29);
  if (v6) {
    MEMORY[0x18C11C0C0](v6, 0x80C80B8603338);
  }
  uint64_t v7 = *((void *)this + 30);
  if (v7) {
    MEMORY[0x18C11C0C0](v7, 0x1020C803C8EFFD9);
  }
  uint64_t v8 = *((void *)this + 31);
  if (v8) {
    MEMORY[0x18C11C0C0](v8, 0x1090C805C18EE7CLL);
  }
  uint64_t v9 = *((void *)this + 32);
  if (v9) {
    MEMORY[0x18C11C0C0](v9, 0x1090C805C18EE7CLL);
  }
  uint64_t v10 = *((void *)this + 33);
  if (v10) {
    MEMORY[0x18C11C0C0](v10, 0x1020C806F595497);
  }
  *(void *)this = &unk_1ED4E44E0;
}

{
  uint64_t vars8;

  kd_synthesis::~kd_synthesis(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t kd_synthesis::start(uint64_t a1, kdu_thread_entity *this)
{
  if (!*(unsigned char *)(a1 + 41))
  {
    if (this) {
      kdu_thread_entity::acquire_lock(this, 3, 1);
    }
    for (uint64_t i = *(void *)(a1 + 72); i; uint64_t i = *(void *)(i + 32))
    {
      kdu_line_buf::create(i);
      kdu_line_buf::create(i + 16);
    }
    *(unsigned char *)(a1 + 41) = 1;
    if (this) {
      kdu_thread_entity::release_lock(this, 3);
    }
  }
  uint64_t v5 = 0;
  uint64_t v6 = a1 + 8;
  do
  {
    uint64_t result = *(void *)(v6 + v5);
    if (result) {
      uint64_t result = (*(uint64_t (**)(uint64_t, kdu_thread_entity *))(*(void *)result + 16))(result, this);
    }
    v5 += 8;
  }
  while (v5 != 32);
  return result;
}

uint64_t kd_synthesis::pull(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(result + 209)) {
    return result;
  }
  uint64_t v5 = result;
  if (!*(unsigned char *)(result + 41)) {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 16))(result, a3);
  }
  if (*(_DWORD *)(v5 + 116) > *(_DWORD *)(v5 + 120)) {
    kd_synthesis::pull();
  }
  uint64_t v106 = a2;
  if (*(unsigned char *)(v5 + 42)) {
    int v6 = *(_DWORD *)(v5 + 116) & 1;
  }
  else {
    int v6 = 0;
  }
  if (!*(_DWORD *)(v5 + 44) || *(unsigned char *)(v5 + 207))
  {
    uint64_t v7 = *(void *)(v5 + 72);
    uint64_t result = kd_synthesis::horizontal_synthesis(v5, v7, v6, a3);
    if (*(unsigned char *)(v5 + 207) && v6 && *(unsigned char *)(v5 + 40))
    {
      if (*(unsigned char *)(v5 + 206))
      {
        uint64_t v8 = 0;
        char v9 = 1;
        do
        {
          char v10 = v9;
          uint64_t v11 = v7 + 16 * v8;
          if ((*(unsigned char *)(v11 + 6) & 2) != 0) {
            uint64_t v12 = *(void *)(v11 + 8);
          }
          else {
            uint64_t v12 = 0;
          }
          int v13 = *(_DWORD *)(v5 + 4 * v8 + 192);
          if (v13)
          {
            uint64_t v14 = (__int16 *)(v12 + 2 * *(unsigned __int8 *)(v5 + v8 + 204));
            do
            {
              *uint64_t v14 = *v14 >> 1;
              ++v14;
              --v13;
            }
            while (v13);
          }
          char v9 = 0;
          uint64_t v8 = 1;
        }
        while ((v10 & 1) != 0);
      }
      else
      {
        uint64_t v63 = 0;
        char v64 = 1;
        do
        {
          char v65 = v64;
          uint64_t v66 = v7 + 16 * v63;
          if ((*(unsigned char *)(v66 + 6) & 2) != 0) {
            uint64_t v67 = 0;
          }
          else {
            uint64_t v67 = *(void *)(v66 + 8);
          }
          int v68 = *(_DWORD *)(v5 + 4 * v63 + 192);
          if (v68)
          {
            int v69 = (int *)(v67 + 4 * *(unsigned __int8 *)(v5 + v63 + 204));
            do
            {
              *v69++ >>= 1;
              --v68;
            }
            while (v68);
          }
          char v64 = 0;
          uint64_t v63 = 1;
        }
        while ((v65 & 1) != 0);
      }
    }
    goto LABEL_89;
  }
  int v15 = (uint64_t *)(v5 + 72);
  unsigned int v16 = -1;
  do
  {
    if ((v16 & 0x80000000) != 0)
    {
LABEL_76:
      unsigned int v16 = !(*(_DWORD *)(v5 + 116) & 1);
      uint64_t result = kd_vlift_queue::access_update(*(void *)(v5 + 104) + 48 * -(*(_DWORD *)(v5 + 116) & 1), *(_DWORD *)(v5 + 116), (void *)(v5 + 72));
      uint64_t v7 = result;
      continue;
    }
    uint64_t v17 = v16;
    while (1)
    {
      BOOL v18 = (v17 & 1) == 0;
      uint64_t v19 = *(unsigned int *)(v5 + 44);
      uint64_t v20 = v5 + 4 * v18;
      if (v17 == v19)
      {
        int v22 = *(_DWORD *)(v20 + 132);
        uint64_t v21 = (int *)(v20 + 132);
        if (v22 <= v21[2])
        {
          uint64_t v23 = *v15;
          if (!*v15)
          {
            exception = __cxa_allocate_exception(4uLL);
            int v105 = -1;
LABEL_150:
            _DWORD *exception = v105;
            __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
          }
          *(void *)(v5 + 72) = *(void *)(v23 + 32);
          *(void *)(v23 + 32) = 0;
          kd_synthesis::horizontal_synthesis(v5, v23, (v17 & 1) == 0, a3);
          uint64_t result = kd_vlift_queue::push_line(*(void *)(v5 + 104) + 48 * v17 - 48, *v21, v23, (void *)(v5 + 72));
          *v21 += 2;
        }
        goto LABEL_74;
      }
      uint64_t v24 = *(void *)(v5 + 80);
      uint64_t v25 = v24 + 32 * v17;
      uint64_t v27 = (int *)(v25 + 24);
      int v26 = *(_DWORD *)(v25 + 24);
      if (v26 > *(_DWORD *)(v20 + 140)) {
        goto LABEL_74;
      }
      int v28 = *(__int16 *)(v25 + 4);
      uint64_t v29 = (int)v19 - 1;
      uint64_t v30 = *(void *)(v5 + 104);
      if (v17 < v29)
      {
        uint64_t v31 = v30 + 48 * (v17 + 1);
        *(_DWORD *)(v31 + 36) = v26;
        if (*(_DWORD *)(v31 + 24) > v26 || *(_DWORD *)(v30 + 48 * (v17 + 1) + 28) < v26)
        {
          uint64_t v7 = 0;
          unsigned int v16 = v17 + 2;
          goto LABEL_77;
        }
      }
      uint64_t v32 = v24 + 32 * v17;
      int v34 = *(unsigned __int8 *)(v32 + 1);
      int v33 = (unsigned char *)(v32 + 1);
      uint64_t result = kd_vlift_queue::access_source((int *)(v30 + 48 * v17), (v26 ^ 1u) + 2 * v28, v34, *(void *)(v5 + 56), (void *)(v5 + 72));
      if ((result & 1) == 0) {
        break;
      }
      if (v17 == *(_DWORD *)(v5 + 44) - 1)
      {
        uint64_t v35 = *v15;
        if (!*v15) {
          goto LABEL_148;
        }
        uint64_t v36 = v5 + 4 * v18;
        int v38 = *(_DWORD *)(v36 + 132);
        uint64_t v37 = (_DWORD *)(v36 + 132);
        if (*v27 != v38) {
          kd_synthesis::pull();
        }
        kd_synthesis::horizontal_synthesis(v5, *v15, v18, a3);
        *v37 += 2;
      }
      else
      {
        uint64_t v35 = kd_vlift_queue::access_update(*(void *)(v5 + 104) + 48 * (v17 + 1), *v27, (void *)(v5 + 72));
      }
      uint64_t v39 = *v15;
      if (!*v15)
      {
LABEL_148:
        exception = __cxa_allocate_exception(4uLL);
        int v105 = -50;
        goto LABEL_150;
      }
      *(void *)(v5 + 72) = *(void *)(v39 + 32);
      *(void *)(v39 + 32) = 0;
      uint64_t result = kd_vlift_queue::push_line(*(void *)(v5 + 104) + 48 * v17 - 48, *v27, v39, (void *)(v5 + 72));
      if (*v33)
      {
        uint64_t v40 = 0;
        char v41 = 1;
        do
        {
          char v42 = v41;
          int v43 = *(_DWORD *)(v5 + 4 * v40 + 192);
          if (v43)
          {
            uint64_t v44 = *(uint64_t **)(v5 + 64);
            uint64_t v45 = *v33;
            if (*(unsigned char *)(v5 + 206))
            {
              if (*v33)
              {
                unint64_t v46 = 0;
                uint64_t v47 = 8 * v45;
                do
                {
                  uint64_t v48 = *(void *)(*(void *)(v5 + 56) + v46) + 16 * v40;
                  if ((*(unsigned char *)(v48 + 6) & 2) != 0) {
                    uint64_t v49 = *(void *)(v48 + 8);
                  }
                  else {
                    uint64_t v49 = 0;
                  }
                  v44[v46 / 8] = v49;
                  v46 += 8;
                }
                while (v47 != v46);
              }
              uint64_t v50 = v35 + 16 * v40;
              if ((*(unsigned char *)(v50 + 6) & 2) != 0) {
                uint64_t v51 = *(void *)(v50 + 8);
              }
              else {
                uint64_t v51 = 0;
              }
              uint64_t v58 = v39 + 16 * v40;
              if ((*(unsigned char *)(v58 + 6) & 2) != 0) {
                uint64_t v59 = *(void *)(v58 + 8);
              }
              else {
                uint64_t v59 = 0;
              }
              uint64_t result = perform_synthesis_lifting_step(v25, v44, v51, v59, v43, *(unsigned __int8 *)(v5 + v40 + 204));
            }
            else
            {
              if (*v33)
              {
                unint64_t v52 = 0;
                uint64_t v53 = 8 * v45;
                do
                {
                  uint64_t v54 = *(void *)(*(void *)(v5 + 56) + v52) + 16 * v40;
                  if ((*(unsigned char *)(v54 + 6) & 2) != 0) {
                    uint64_t v55 = 0;
                  }
                  else {
                    uint64_t v55 = *(void *)(v54 + 8);
                  }
                  v44[v52 / 8] = v55;
                  v52 += 8;
                }
                while (v53 != v52);
              }
              uint64_t v56 = v35 + 16 * v40;
              if ((*(unsigned char *)(v56 + 6) & 2) != 0) {
                uint64_t v57 = 0;
              }
              else {
                uint64_t v57 = *(void *)(v56 + 8);
              }
              uint64_t v60 = v39 + 16 * v40;
              if ((*(unsigned char *)(v60 + 6) & 2) != 0) {
                uint64_t v61 = 0;
              }
              else {
                uint64_t v61 = *(void *)(v60 + 8);
              }
              uint64_t result = perform_synthesis_lifting_step(v25, v44, v57, v61, v43, *(unsigned __int8 *)(v5 + v40 + 204));
            }
          }
          char v41 = 0;
          uint64_t v40 = 1;
        }
        while ((v42 & 1) != 0);
      }
      *v27 += 2;
LABEL_74:
      if (v17-- <= 0) {
        goto LABEL_76;
      }
    }
    uint64_t v7 = 0;
    unsigned int v16 = v17 + 1;
LABEL_77:
    ;
  }
  while (!v7);
LABEL_89:
  ++*(_DWORD *)(v5 + 116);
  int v70 = *(_DWORD *)(v5 + 200);
  unsigned int v71 = *(_DWORD *)(v5 + 188) - v70;
  int v72 = (int)(v71 + 2) >> 1;
  int v73 = v70 - *(_DWORD *)(v5 + 148);
  if (*(unsigned char *)(v5 + 43))
  {
    uint64_t v74 = v70 & 1;
    int v75 = v73 >> 1;
    uint64_t v76 = *(void *)(v106 + 8);
    if (*(unsigned char *)(v5 + 206))
    {
      uint64_t v77 = 0;
      if ((*(unsigned char *)(v106 + 6) & 2) == 0) {
        uint64_t v76 = 0;
      }
      if ((*(unsigned char *)(v7 + 16 * v74 + 6) & 2) != 0) {
        uint64_t v77 = *(void *)(v7 + 16 * v74 + 8);
      }
      uint64_t v78 = v75;
      uint64_t v79 = (unsigned __int16 *)(v77 + 2 * v75);
      uint64_t v80 = v74 ^ 1;
      if ((*(unsigned char *)(v7 + 16 * v80 + 6) & 2) != 0) {
        uint64_t v81 = *(void *)(v7 + 16 * v80 + 8);
      }
      else {
        uint64_t v81 = 0;
      }
      uint64_t v89 = (unsigned __int16 *)(v81 + 2 * v78);
      if (*(_DWORD *)(v5 + 100))
      {
        if (v71 <= 0xFFFFFFFD)
        {
          do
          {
            int v90 = *v79++;
            *(_WORD *)uint64_t v76 = v90 << *(_DWORD *)(v5 + 100);
            int v91 = *v89++;
            *(_WORD *)(v76 + 2) = v91 << *(_DWORD *)(v5 + 100);
            v76 += 4;
            --v72;
          }
          while (v72);
        }
      }
      else if (v71 <= 0xFFFFFFFD)
      {
        do
        {
          __int16 v92 = *v79++;
          *(_WORD *)uint64_t v76 = v92;
          __int16 v93 = *v89++;
          *(_WORD *)(v76 + 2) = v93;
          v76 += 4;
          --v72;
        }
        while (v72);
      }
    }
    else
    {
      uint64_t v84 = 0;
      if ((*(unsigned char *)(v106 + 6) & 2) != 0) {
        uint64_t v76 = 0;
      }
      if ((*(unsigned char *)(v7 + 16 * v74 + 6) & 2) == 0) {
        uint64_t v84 = *(void *)(v7 + 16 * v74 + 8);
      }
      uint64_t v85 = v75;
      uint64_t v86 = (float *)(v84 + 4 * v75);
      uint64_t v87 = v74 ^ 1;
      if ((*(unsigned char *)(v7 + 16 * v87 + 6) & 2) != 0) {
        uint64_t v88 = 0;
      }
      else {
        uint64_t v88 = *(void *)(v7 + 16 * v87 + 8);
      }
      uint64_t v97 = (float *)(v88 + 4 * v85);
      int v98 = *(_DWORD *)(v5 + 100);
      if (v98)
      {
        if (v71 <= 0xFFFFFFFD)
        {
          float v99 = (float)(1 << v98);
          do
          {
            float v100 = *v86++;
            *(float *)uint64_t v76 = v100 * v99;
            float v101 = *v97++;
            *(float *)(v76 + 4) = v101 * v99;
            v76 += 8;
            --v72;
          }
          while (v72);
        }
      }
      else if (v71 <= 0xFFFFFFFD)
      {
        do
        {
          float v102 = *v86++;
          *(float *)uint64_t v76 = v102;
          float v103 = *v97++;
          *(float *)(v76 + 4) = v103;
          v76 += 8;
          --v72;
        }
        while (v72);
      }
    }
  }
  else
  {
    if (v73 >= 2) {
      kd_synthesis::pull();
    }
    uint64_t v82 = *(void *)(v106 + 8);
    if (*(unsigned char *)(v5 + 206))
    {
      uint64_t v83 = 0;
      if ((*(unsigned char *)(v106 + 6) & 2) == 0) {
        uint64_t v82 = 0;
      }
      if ((*(unsigned char *)(v7 + 6) & 2) != 0) {
        uint64_t v83 = *(unsigned __int16 **)(v7 + 8);
      }
      if (*(_DWORD *)(v5 + 100))
      {
        if (v71 <= 0xFFFFFFFD)
        {
          do
          {
            *(_WORD *)uint64_t v82 = *v83 << *(_DWORD *)(v5 + 100);
            *(_WORD *)(v82 + 2) = v83[1] << *(_DWORD *)(v5 + 100);
            v83 += 2;
            v82 += 4;
            --v72;
          }
          while (v72);
        }
      }
      else if (v71 <= 0xFFFFFFFD)
      {
        do
        {
          *(_WORD *)uint64_t v82 = *v83;
          *(_WORD *)(v82 + 2) = v83[1];
          v83 += 2;
          v82 += 4;
          --v72;
        }
        while (v72);
      }
    }
    else
    {
      unsigned __int8 v94 = 0;
      if ((*(unsigned char *)(v106 + 6) & 2) != 0) {
        uint64_t v82 = 0;
      }
      if ((*(unsigned char *)(v7 + 6) & 2) == 0) {
        unsigned __int8 v94 = *(float **)(v7 + 8);
      }
      int v95 = *(_DWORD *)(v5 + 100);
      if (v95)
      {
        if (v71 <= 0xFFFFFFFD)
        {
          float v96 = (float)(1 << v95);
          do
          {
            *(float *)uint64_t v82 = *v94 * v96;
            *(float *)(v82 + 4) = v94[1] * v96;
            v94 += 2;
            v82 += 8;
            --v72;
          }
          while (v72);
        }
      }
      else if (v71 <= 0xFFFFFFFD)
      {
        do
        {
          *(float *)uint64_t v82 = *v94;
          *(float *)(v82 + 4) = v94[1];
          v94 += 2;
          v82 += 8;
          --v72;
        }
        while (v72);
      }
    }
  }
  return result;
}

uint64_t kd_synthesis::horizontal_synthesis(uint64_t result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v6 = result;
  uint64_t v7 = 0;
  uint64_t v8 = 2 * a3;
  char v9 = 1;
  do
  {
    char v10 = v9;
    uint64_t v11 = v6 + 4 * v7;
    int v13 = *(_DWORD *)(v11 + 172);
    uint64_t v12 = (int *)(v11 + 172);
    if (v13 >= 1)
    {
      uint64_t v14 = *(void *)(v6 + 8 * (v7 | v8) + 8);
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v14 + 24))(v14, a2 + 16 * v7, a4);
      int v15 = *(unsigned __int8 *)(v6 + v7 + 180);
      if (*(unsigned char *)(v6 + v7 + 180))
      {
        if (*(unsigned char *)(v6 + 206))
        {
          unsigned int v16 = (__int16 *)(*(void *)(a2 + 16 * v7 + 8) + 2 * *(unsigned __int8 *)(v6 + v7 + 170));
          __int16 v19 = *v16;
          uint64_t v17 = v16 - 1;
          __int16 v18 = v19;
          unsigned int v20 = v15 + 1;
          do
          {
            *v17-- = v18;
            --v20;
          }
          while (v20 > 1);
        }
        else
        {
          uint64_t v21 = (int *)(*(void *)(a2 + 16 * v7 + 8) + 4 * *(unsigned __int8 *)(v6 + v7 + 170));
          int v24 = *v21;
          int v22 = v21 - 1;
          int v23 = v24;
          unsigned int v25 = v15 + 1;
          do
          {
            *v22-- = v23;
            --v25;
          }
          while (v25 > 1);
        }
      }
      int v26 = *(unsigned __int8 *)(v6 + v7 + 182);
      if (*(unsigned char *)(v6 + v7 + 182))
      {
        if (*(unsigned char *)(v6 + 206))
        {
          uint64_t v27 = *(void *)(a2 + 16 * v7 + 8);
          uint64_t v28 = *(unsigned __int8 *)(v6 + v7 + 170);
          uint64_t v29 = *v12;
          uint64_t v30 = (_WORD *)(v27 + 2 * v28 + 2 * v29);
          __int16 v31 = *(_WORD *)(v27 + 2 * (v29 + v28) - 2);
          unsigned int v32 = v26 + 1;
          do
          {
            *v30++ = v31;
            --v32;
          }
          while (v32 > 1);
        }
        else
        {
          uint64_t v33 = *(void *)(a2 + 16 * v7 + 8);
          uint64_t v34 = *(unsigned __int8 *)(v6 + v7 + 170);
          uint64_t v35 = *v12;
          uint64_t v36 = (_DWORD *)(v33 + 4 * v34 + 4 * v35);
          int v37 = *(_DWORD *)(v33 + 4 * (v35 + v34) - 4);
          unsigned int v38 = v26 + 1;
          do
          {
            *v36++ = v37;
            --v38;
          }
          while (v38 > 1);
        }
      }
    }
    char v9 = 0;
    uint64_t v7 = 1;
  }
  while ((v10 & 1) != 0);
  LODWORD(v39) = *(_DWORD *)(v6 + 48);
  if (v39)
  {
    if (*(unsigned char *)(v6 + 208))
    {
      if (*(unsigned char *)(v6 + 40) && (*(unsigned char *)(v6 + 152) & 1) != 0)
      {
        if (*(unsigned char *)(v6 + 206)) {
          *(_WORD *)(*(void *)(a2 + 24) + 2 * *(unsigned __int8 *)(v6 + 169)) = *(__int16 *)(*(void *)(a2 + 24) + 2 * *(unsigned __int8 *)(v6 + 169)) >> 1;
        }
        else {
          *(int *)(*(void *)(a2 + 24) + 4 * *(unsigned __int8 *)(v6 + 169)) >>= 1;
        }
      }
      if (*(unsigned char *)(v6 + 208)) {
        return result;
      }
      LODWORD(v39) = *(_DWORD *)(v6 + 48);
    }
    if ((int)v39 >= 1)
    {
      uint64_t v39 = v39;
      do
      {
        unsigned __int8 v40 = v39 - 1;
        uint64_t v41 = *(void *)(v6 + 88);
        uint64_t v42 = (v39 - 1);
        uint64_t v43 = v41 + 32 * v42;
        int v45 = *(unsigned __int8 *)(v43 + 1);
        uint64_t v44 = (unsigned __int8 *)(v43 + 1);
        if (v45)
        {
          BOOL v46 = (v40 & 1) == 0;
          uint64_t v47 = *(unsigned int *)(v6 + 4 * v46 + 160);
          uint64_t v48 = *(unsigned __int8 *)(v6 + v46 + 168);
          uint64_t v49 = v40 & 1;
          if (*(unsigned char *)(v6 + 206))
          {
            if ((*(unsigned char *)(a2 + 16 * (v40 & 1) + 6) & 2) != 0) {
              uint64_t v50 = *(void *)(a2 + 16 * v49 + 8);
            }
            else {
              uint64_t v50 = 0;
            }
            uint64_t v52 = a2 + 16 * v46;
            if ((*(unsigned char *)(v52 + 6) & 2) != 0) {
              uint64_t v53 = *(void *)(v52 + 8);
            }
            else {
              uint64_t v53 = 0;
            }
            uint64_t result = *(unsigned __int8 *)(v6 + v49 + 168);
            uint64_t v54 = (_WORD *)(v50 + 2 * result);
            uint64_t v55 = *(int *)(v6 + 4 * v49 + 160);
            uint64_t v56 = &v54[v55];
            uint64_t v57 = v41 + 32 * v42;
            int v60 = *(unsigned __int8 *)(v57 + 3);
            uint64_t v58 = (unsigned __int8 *)(v57 + 3);
            int v59 = v60;
            if (*(unsigned char *)(v6 + 99))
            {
              if (v59)
              {
                unint64_t v61 = 0;
                int v62 = v56 - 1;
                uint64_t v63 = -1;
                char v64 = &v54[v55];
                do
                {
                  v54[v63] = v54[v61 - ((*(_DWORD *)(v6 + 152) ^ v40) & 1) + 1];
                  v64[v61++] = v62[v63 + ((*(_DWORD *)(v6 + 156) ^ v40) & 1)];
                  --v63;
                }
                while (v61 < *v58);
              }
            }
            else if (v59)
            {
              unint64_t v65 = 0;
              uint64_t v66 = (_WORD *)(v50 + 2 * result - 2);
              do
              {
                *v66-- = *v54;
                v56[v65++] = *(v56 - 1);
              }
              while (v65 < *v58);
            }
            uint64_t v67 = (_WORD *)(v53 + 2 * v48);
            BOOL v68 = (*(unsigned __int8 *)(v6 + 152) << 31 >> 31) & (1 - 2 * v46);
            uint64_t v69 = v41 + 32 * v42;
            uint64_t v70 = *(__int16 *)(v69 + 4);
            uint64_t v71 = *v44;
            int v72 = *(int **)(v69 + 16);
            if (v71 == 2 && (int v73 = *v72, *v72 == v72[1]))
            {
              uint64_t v74 = v41 + 32 * v42;
              char v75 = *(unsigned char *)(v74 + 2);
              int v76 = *(__int16 *)(v74 + 6);
              if (v73 == 1)
              {
                if ((int)v47 >= 1)
                {
                  uint64_t v122 = (__int16 *)(v50 + 2 * v70 + 2 * v68 + 2 * result + 2);
                  do
                  {
                    *v67++ -= (*(v122 - 1) + v76 + *v122) >> v75;
                    ++v122;
                    --v47;
                  }
                  while (v47);
                }
              }
              else if (v73 == -1)
              {
                if ((int)v47 >= 1)
                {
                  uint64_t v77 = (__int16 *)(v50 + 2 * v70 + 2 * v68 + 2 * result + 2);
                  do
                  {
                    *v67++ -= (v76 - (*(v77 - 1) + *v77)) >> v75;
                    ++v77;
                    --v47;
                  }
                  while (v47);
                }
              }
              else if ((int)v47 >= 1)
              {
                int64x2_t v123 = (__int16 *)(v50 + 2 * v70 + 2 * v68 + 2 * result + 2);
                do
                {
                  *v67++ -= (v76 + (*v123 + *(v123 - 1)) * v73) >> v75;
                  ++v123;
                  --v47;
                }
                while (v47);
              }
            }
            else if ((int)v47 >= 1)
            {
              uint64_t v78 = 0;
              uint64_t v79 = (uint64_t)&v54[v68 + v70];
              char v80 = *(unsigned char *)(v69 + 2);
              uint64_t result = *(__int16 *)(v69 + 6);
              do
              {
                int v81 = result;
                if (v71)
                {
                  uint64_t v82 = 0;
                  int v81 = result;
                  do
                  {
                    v81 += v72[v82] * *(__int16 *)(v79 + 2 * v82);
                    ++v82;
                  }
                  while (v71 != v82);
                }
                v67[v78++] -= v81 >> v80;
                v79 += 2;
              }
              while (v78 != v47);
            }
          }
          else
          {
            if ((*(unsigned char *)(a2 + 16 * (v40 & 1) + 6) & 2) != 0) {
              uint64_t v51 = 0;
            }
            else {
              uint64_t v51 = *(void *)(a2 + 16 * v49 + 8);
            }
            uint64_t v83 = a2 + 16 * v46;
            if ((*(unsigned char *)(v83 + 6) & 2) != 0) {
              uint64_t v84 = 0;
            }
            else {
              uint64_t v84 = *(void *)(v83 + 8);
            }
            uint64_t result = *(unsigned __int8 *)(v6 + v49 + 168);
            uint64_t v85 = (_DWORD *)(v51 + 4 * result);
            uint64_t v86 = *(int *)(v6 + 4 * v49 + 160);
            uint64_t v87 = &v85[v86];
            uint64_t v88 = v41 + 32 * v42;
            int v91 = *(unsigned __int8 *)(v88 + 3);
            uint64_t v89 = (unsigned __int8 *)(v88 + 3);
            int v90 = v91;
            if (*(unsigned char *)(v6 + 99))
            {
              if (v90)
              {
                unint64_t v92 = 0;
                __int16 v93 = v87 - 1;
                uint64_t v94 = -1;
                int v95 = &v85[v86];
                do
                {
                  v85[v94] = v85[v92 - ((*(_DWORD *)(v6 + 152) ^ v40) & 1) + 1];
                  v95[v92++] = v93[v94 + ((*(_DWORD *)(v6 + 156) ^ v40) & 1)];
                  --v94;
                }
                while (v92 < *v89);
              }
            }
            else if (v90)
            {
              unint64_t v96 = 0;
              uint64_t v97 = (_DWORD *)(v51 + 4 * result - 4);
              do
              {
                *v97-- = *v85;
                v87[v96++] = *(v87 - 1);
              }
              while (v96 < *v89);
            }
            int v98 = (float *)(v84 + 4 * v48);
            BOOL v99 = (*(unsigned __int8 *)(v6 + 152) << 31 >> 31) & (1 - 2 * v46);
            uint64_t v100 = v41 + 32 * v42;
            uint64_t v101 = *(__int16 *)(v100 + 4);
            uint64_t v102 = *v44;
            if (v102 != 2)
            {
              int v106 = *(unsigned __int8 *)(v6 + 40);
LABEL_84:
              uint64_t v112 = (uint64_t)&v85[v99 + v101];
              if (v106)
              {
                if ((int)v47 >= 1)
                {
                  uint64_t v113 = 0;
                  uint64_t v114 = v41 + 32 * v42;
                  char v115 = *(unsigned char *)(v114 + 2);
                  int v116 = *(__int16 *)(v114 + 6);
                  uint64_t result = *(void *)(v114 + 16);
                  do
                  {
                    int v117 = v116;
                    if (v102)
                    {
                      uint64_t v118 = 0;
                      int v117 = v116;
                      do
                      {
                        v117 += *(_DWORD *)(v112 + v118) * *(_DWORD *)(result + v118);
                        v118 += 4;
                      }
                      while (4 * v102 != v118);
                    }
                    LODWORD(v98[v113++]) -= v117 >> v115;
                    v112 += 4;
                  }
                  while (v113 != v47);
                }
              }
              else if ((int)v47 >= 1)
              {
                uint64_t v119 = 0;
                uint64_t v120 = *(void *)(v41 + 32 * v42 + 8);
                do
                {
                  if (v102)
                  {
                    uint64_t result = 0;
                    float v121 = 0.0;
                    do
                    {
                      float v121 = v121 + (float)(*(float *)(v120 + result) * *(float *)(v112 + result));
                      result += 4;
                    }
                    while (4 * v102 != result);
                  }
                  else
                  {
                    float v121 = 0.0;
                  }
                  v98[v119] = v98[v119] - v121;
                  ++v119;
                  v112 += 4;
                }
                while (v119 != v47);
              }
              continue;
            }
            float v103 = *(float **)(v100 + 8);
            float v104 = *v103;
            float v105 = v103[1];
            int v106 = *(unsigned __int8 *)(v6 + 40);
            if (v104 != v105) {
              goto LABEL_84;
            }
            if (*(unsigned char *)(v6 + 40))
            {
              uint64_t v107 = v41 + 32 * v42;
              char v108 = *(unsigned char *)(v107 + 2);
              int v109 = *(__int16 *)(v107 + 6);
              int v110 = **(_DWORD **)(v107 + 16);
              if (v110 == 1)
              {
                if ((int)v47 >= 1)
                {
                  uint64_t v126 = (_DWORD *)(v51 + 4 * v101 + 4 * v99 + 4 * result + 4);
                  do
                  {
                    *(_DWORD *)v98++ -= (*(v126 - 1) + v109 + *v126) >> v108;
                    ++v126;
                    --v47;
                  }
                  while (v47);
                }
              }
              else if (v110 == -1)
              {
                if ((int)v47 >= 1)
                {
                  uint64_t v111 = (_DWORD *)(v51 + 4 * v101 + 4 * v99 + 4 * result + 4);
                  do
                  {
                    *(_DWORD *)v98++ -= (v109 - (*(v111 - 1) + *v111)) >> v108;
                    ++v111;
                    --v47;
                  }
                  while (v47);
                }
              }
              else if ((int)v47 >= 1)
              {
                int v127 = (_DWORD *)(v51 + 4 * v101 + 4 * v99 + 4 * result + 4);
                do
                {
                  *(_DWORD *)v98++ -= (v109 + (*v127 + *(v127 - 1)) * v110) >> v108;
                  ++v127;
                  --v47;
                }
                while (v47);
              }
            }
            else if ((int)v47 >= 1)
            {
              float v124 = -v104;
              float v125 = (float *)(v51 + 4 * v101 + 4 * v99 + 4 * result + 4);
              do
              {
                *int v98 = *v98 + (float)(v124 * (float)(*(v125 - 1) + *v125));
                ++v98;
                ++v125;
                --v47;
              }
              while (v47);
            }
          }
        }
      }
      while (v39-- > 1);
    }
  }
  return result;
}

uint64_t perform_synthesis_lifting_step(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  if (a5 >= 1)
  {
    if (a6 >= 16) {
      int v6 = 16;
    }
    else {
      int v6 = a6;
    }
    unsigned int v7 = a6 - v6 + 7;
    unsigned int v8 = v7 & 0xFFFFFFF8;
    uint64_t v9 = 16 * (v7 >> 3) + 16;
    int v10 = a6 - v8 - 8;
    uint64_t v11 = a4 + v9;
    if (a6 >= 9) {
      uint64_t v12 = a3 + v9;
    }
    else {
      uint64_t v12 = a3;
    }
    if (a6 >= 9)
    {
      LODWORD(v13) = v10;
    }
    else
    {
      uint64_t v11 = a4;
      LODWORD(v13) = a6;
    }
    int v14 = v13 + a5;
    uint64_t v15 = *(unsigned __int8 *)(result + 1);
    if (v15 == 2 && (unsigned int v16 = *(int **)(result + 16), v17 = *v16, *v16 == v16[1]))
    {
      uint64_t v18 = *a2;
      uint64_t v19 = a2[1];
      char v20 = *(unsigned char *)(result + 2);
      int v21 = 1 << v20 >> 1;
      if (v17 == 1)
      {
        uint64_t v33 = (int)v13;
        do
        {
          uint64_t result = *(unsigned __int16 *)(v12 + 2 * v33);
          *(_WORD *)(v11 + 2 * v33) = result
                                    - ((v21 + *(__int16 *)(v18 + 2 * v33) + *(__int16 *)(v19 + 2 * v33)) >> v20);
          ++v33;
        }
        while (v33 < v14);
      }
      else if (v17 == -1)
      {
        uint64_t v22 = (int)v13;
        do
        {
          uint64_t result = *(unsigned __int16 *)(v12 + 2 * v22);
          *(_WORD *)(v11 + 2 * v22) = result
                                    - ((v21 - (*(__int16 *)(v18 + 2 * v22) + *(__int16 *)(v19 + 2 * v22))) >> v20);
          ++v22;
        }
        while (v22 < v14);
      }
      else
      {
        uint64_t v13 = (int)v13;
        do
        {
          uint64_t result = *(unsigned __int16 *)(v12 + 2 * v13);
          *(_WORD *)(v11 + 2 * v13) = result
                                    - ((v21 + (*(__int16 *)(v19 + 2 * v13) + *(__int16 *)(v18 + 2 * v13)) * v17) >> v20);
          ++v13;
        }
        while (v13 < v14);
      }
    }
    else
    {
      char v23 = *(unsigned char *)(result + 2);
      int v24 = *(__int16 *)(result + 6);
      uint64_t v25 = (int)v13;
      do
      {
        int v26 = v24;
        if (v15)
        {
          uint64_t v27 = *(int **)(result + 16);
          uint64_t v28 = v15;
          uint64_t v29 = a2;
          int v26 = v24;
          do
          {
            int v31 = *v27++;
            int v30 = v31;
            uint64_t v32 = *v29++;
            v26 += v30 * *(__int16 *)(v32 + 2 * v25);
            --v28;
          }
          while (v28);
        }
        *(_WORD *)(v11 + 2 * v25) = *(_WORD *)(v12 + 2 * v25) - (v26 >> v23);
        ++v25;
      }
      while (v25 < v14);
    }
  }
  return result;
}

{
  int v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  float *v17;
  float v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  int v22;
  int v23;
  char v24;
  int v25;
  uint64_t v26;
  int v27;
  int *v28;
  uint64_t v29;
  uint64_t *v30;
  int v31;
  int v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  float v37;
  uint64_t v38;
  float v39;
  uint64_t v40;

  if (a5 < 1) {
    return result;
  }
  if (a6 >= 8) {
    int v6 = 8;
  }
  else {
    int v6 = a6;
  }
  unsigned int v7 = a6 - v6 + 3;
  unsigned int v8 = v7 & 0xFFFFFFFC;
  uint64_t v9 = 16 * (v7 >> 2) + 16;
  int v10 = a3 + v9;
  uint64_t v11 = a6 - v8 - 4;
  uint64_t v12 = a4 + v9;
  if (a6 >= 5) {
    uint64_t v13 = v10;
  }
  else {
    uint64_t v13 = a3;
  }
  if (a6 >= 5)
  {
    LODWORD(v14) = v11;
  }
  else
  {
    uint64_t v12 = a4;
    LODWORD(v14) = a6;
  }
  uint64_t v15 = v14 + a5;
  unsigned int v16 = *(unsigned __int8 *)(result + 1);
  if (v16 == 2)
  {
    int v17 = *(float **)(result + 8);
    uint64_t v18 = *v17;
    if (*v17 == v17[1])
    {
      uint64_t v19 = *a2;
      char v20 = a2[1];
      if (*(unsigned char *)(result + 29))
      {
        int v21 = *(unsigned char *)(result + 2);
        uint64_t v22 = *(__int16 *)(result + 6);
        char v23 = **(_DWORD **)(result + 16);
        int v14 = (int)v14;
        if (v23 == 1)
        {
          do
          {
            uint64_t result = *(unsigned int *)(v20 + 4 * v14);
            *(_DWORD *)(v12 + 4 * v14) = *(_DWORD *)(v13 + 4 * v14)
                                       - ((*(_DWORD *)(v19 + 4 * v14) + v22 + (int)result) >> v21);
            ++v14;
          }
          while (v14 < v15);
        }
        else if (v23 == -1)
        {
          do
          {
            uint64_t result = *(unsigned int *)(v20 + 4 * v14);
            *(_DWORD *)(v12 + 4 * v14) = *(_DWORD *)(v13 + 4 * v14)
                                       - ((v22 - (*(_DWORD *)(v19 + 4 * v14) + (int)result)) >> v21);
            ++v14;
          }
          while (v14 < v15);
        }
        else
        {
          do
          {
            uint64_t result = ((v22 + (*(_DWORD *)(v20 + 4 * v14) + *(_DWORD *)(v19 + 4 * v14)) * v23) >> v21);
            *(_DWORD *)(v12 + 4 * v14) = *(_DWORD *)(v13 + 4 * v14) - result;
            ++v14;
          }
          while (v14 < v15);
        }
      }
      else
      {
        uint64_t v39 = -v18;
        unsigned __int8 v40 = (int)v14;
        do
        {
          *(float *)(v12 + 4 * v40) = *(float *)(v13 + 4 * v40)
                                    + (float)(v39 * (float)(*(float *)(v19 + 4 * v40) + *(float *)(v20 + 4 * v40)));
          ++v40;
        }
        while (v40 < v15);
      }
      return result;
    }
    if (*(unsigned char *)(result + 29)) {
      goto LABEL_26;
    }
LABEL_32:
    uint64_t v34 = 0;
    uint64_t v35 = v15;
    do
    {
      uint64_t v36 = a2[v34];
      int v37 = -*(float *)(*(void *)(result + 8) + 4 * v34);
      unsigned int v38 = (int)v14;
      do
      {
        *(float *)(v12 + 4 * v38) = *(float *)(v13 + 4 * v38) + (float)(v37 * *(float *)(v36 + 4 * v38));
        ++v38;
      }
      while (v38 < v35);
      ++v34;
      uint64_t v13 = v12;
    }
    while (v34 < *(unsigned __int8 *)(result + 1));
    return result;
  }
  if (!*(unsigned char *)(result + 29))
  {
    if (!*(unsigned char *)(result + 1)) {
      return result;
    }
    goto LABEL_32;
  }
LABEL_26:
  int v24 = *(unsigned char *)(result + 2);
  uint64_t v25 = *(__int16 *)(result + 6);
  int v26 = (int)v14;
  do
  {
    uint64_t v27 = v25;
    if (v16)
    {
      uint64_t v28 = *(int **)(result + 16);
      uint64_t v29 = v16;
      int v30 = a2;
      uint64_t v27 = v25;
      do
      {
        uint64_t v32 = *v28++;
        int v31 = v32;
        uint64_t v33 = *v30++;
        v27 += *(_DWORD *)(v33 + 4 * v26) * v31;
        --v29;
      }
      while (v29);
    }
    *(_DWORD *)(v12 + 4 * v26) = *(_DWORD *)(v13 + 4 * v26) - (v27 >> v24);
    ++v26;
  }
  while (v26 < v15);
  return result;
}

void kd_synthesis::kd_synthesis(kd_synthesis *this)
{
  uint64_t v1 = 0;
  *(void *)this = &unk_1ED4DF480;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  uint64_t v2 = (kd_synthesis *)((char *)this + 400);
  do
  {
    uint64_t v3 = v1;
    uint64_t v4 = 2;
    do
    {
      uint64_t v5 = (char *)this + v3;
      *((_DWORD *)v5 + 100) = 0;
      *((_WORD *)v5 + 203) = 0;
      *((void *)v5 + 51) = 0;
      v3 += 16;
      --v4;
    }
    while (v4);
    uint64_t v2 = (kd_synthesis *)((char *)v2 + 40);
    v1 += 40;
  }
  while (v2 != (kd_synthesis *)((char *)this + 640));
  *((void *)this + 13) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 11) = 0;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *((void *)this + 33) = 0;
}

uint64_t _cg_jpeg_fdct_islow(uint64_t result, uint64_t a2, unsigned int a3)
{
  for (uint64_t i = 0; i != 64; i += 8)
  {
    uint64_t v4 = (_DWORD *)(result + 4 * i);
    uint64_t v5 = (unsigned __int8 *)(*(void *)(a2 + i) + a3);
    int v6 = *v5;
    int v7 = v5[7];
    int v8 = v5[1];
    int v9 = v5[6];
    uint64_t v10 = (v9 + v8);
    int v11 = v5[2];
    int v12 = v5[5];
    uint64_t v13 = (v12 + v11);
    int v14 = v5[3];
    LODWORD(v5) = v5[4];
    int v15 = v5 + v14 + v7 + v6;
    int v16 = v7 + v6 - (v5 + v14);
    int v17 = v13 + v10;
    uint64_t v18 = v10 - v13;
    int v19 = v6 - v7;
    int v20 = v8 - v9;
    int v21 = v11 - v12;
    LODWORD(v5) = v14 - v5;
    uint64_t v22 = 4433 * (v16 + (int)v18) + 1024;
    unint64_t v23 = (unint64_t)(v22 + 6270 * v16) >> 11;
    unint64_t v24 = (unint64_t)(v22 + 0x7FFFFFFC4DFLL * v18) >> 11;
    uint64_t v25 = 9633 * ((int)v5 + v20 + v21 + v19) + 1024;
    uint64_t v26 = v25 - 3196 * (v21 + v19);
    uint64_t v27 = v25 - 16069 * ((int)v5 + v20);
    _DWORD *v4 = 4 * (v15 + v17) - 4096;
    v4[1] = (unint64_t)(12299 * v19 - 7373 * ((int)v5 + v19) + v26) >> 11;
    v4[2] = v23;
    v4[3] = (unint64_t)(25172 * v20 - 20995 * (v21 + v20) + v27) >> 11;
    v4[4] = 4 * (v15 - v17);
    v4[5] = (unint64_t)(16819 * v21 - 20995 * (v21 + v20) + v26) >> 11;
    v4[6] = v24;
    v4[7] = (unint64_t)(2446 * (int)v5 - 7373 * ((int)v5 + v19) + v27) >> 11;
  }
  uint64_t v28 = 0;
  do
  {
    uint64_t v29 = (_DWORD *)(result + v28);
    int v30 = *(_DWORD *)(result + v28);
    int v31 = *(_DWORD *)(result + v28 + 224);
    uint64_t v32 = v31 + v30;
    int v33 = *(_DWORD *)(result + v28 + 32);
    int v34 = *(_DWORD *)(result + v28 + 192);
    int v35 = *(_DWORD *)(result + v28 + 64);
    int v36 = *(_DWORD *)(result + v28 + 160);
    int v37 = *(_DWORD *)(result + v28 + 96);
    int v38 = *(_DWORD *)(result + v28 + 128);
    uint64_t v39 = v32 + v38 + v37 + 2;
    uint64_t v40 = v32 - (v38 + v37);
    uint64_t v41 = v36 + v35 + (uint64_t)(v34 + v33);
    uint64_t v42 = v34 + v33 - (uint64_t)(v36 + v35);
    int v43 = v30 - v31;
    int v44 = v33 - v34;
    int v45 = v35 - v36;
    uint64_t v46 = v37 - v38;
    *uint64_t v29 = (unint64_t)(v39 + v41) >> 2;
    v29[32] = (unint64_t)(v39 - v41) >> 2;
    uint64_t v47 = 4433 * (v40 + v42) + 0x4000;
    v29[16] = (unint64_t)(v47 + 6270 * v40) >> 15;
    v29[48] = (unint64_t)(v47 + 0x7FFFFFFFC4DFLL * v42) >> 15;
    uint64_t v48 = v45 + (uint64_t)v43;
    uint64_t v49 = v46 + v44;
    uint64_t v50 = 9633 * (v49 + v48) + 0x4000;
    uint64_t v51 = v50 - 3196 * v48;
    uint64_t v52 = v50 - 16069 * v49;
    uint64_t v53 = -7373 * (v46 + v43);
    uint64_t v54 = -20995 * (v45 + (uint64_t)v44);
    v29[8] = (unint64_t)(v53 + 12299 * v43 + v51) >> 15;
    v29[24] = (unint64_t)(v54 + 25172 * v44 + v52) >> 15;
    v29[40] = (unint64_t)(v54 + 16819 * v45 + v51) >> 15;
    v29[56] = (unint64_t)(v53 + 2446 * v46 + v52) >> 15;
    v28 += 4;
  }
  while (v28 != 32);
  return result;
}

_OWORD *jpeg_fdct_7x7(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  *uint64_t result = 0u;
  result[1] = 0u;
  do
  {
    uint64_t v4 = &result[v3];
    uint64_t v5 = (unsigned __int8 *)(*(void *)(a2 + v3 * 4) + a3);
    int v6 = *v5;
    int v7 = v5[6];
    int v8 = v7 + v6;
    int v9 = v5[1];
    int v10 = v5[5];
    uint64_t v11 = (v10 + v9);
    int v12 = v5[2];
    int v13 = v5[4];
    int v14 = v13 + v12;
    unsigned int v15 = v5[3];
    int v16 = v6 - v7;
    int v17 = v9 - v10;
    LODWORD(v5) = v12 - v13;
    int v18 = v13 + v12 + v8;
    int v19 = 4 * (v15 + v11 + v18) - 3584;
    int v20 = v18 - 4 * v15;
    int v21 = v8 - (v13 + v12);
    int v22 = v11 - v14;
    unint64_t v23 = (unint64_t)(7542 * v21 + 2578 * ((int)v11 - v14) + 2896 * v20 + 1024) >> 11;
    uint64_t v24 = 7223 * (v8 - (int)v11) + 1024;
    unint64_t v25 = (v24 + 2578 * v22 + 0x7FFFFFFE95FLL * (v11 - 2 * (unint64_t)v15)) >> 11;
    v4[6] = (unint64_t)(v24 - 7542 * v21 + 2896 * v20) >> 11;
    LODWORD(v24) = v17 + v16;
    uint64_t v26 = 1395 * (v16 - v17);
    int v27 = v5 + v17;
    uint64_t v28 = 5027 * ((int)v5 + v16) + 1024;
    _DWORD *v4 = v19;
    v4[1] = (unint64_t)(v28 - v26 + 7663 * (int)v24) >> 11;
    v4[2] = v23;
    v4[3] = (unint64_t)(v26 - 11295 * v27 + 7663 * (int)v24 + 1024) >> 11;
    v4[4] = v25;
    v4[5] = (unint64_t)(v28 + 15326 * (int)v5 - 11295 * v27) >> 11;
    v3 += 2;
  }
  while (v3 != 14);
  uint64_t v29 = 0;
  do
  {
    int v30 = (_DWORD *)((char *)result + v29);
    int v31 = *(_DWORD *)((char *)result + v29);
    int v32 = *(_DWORD *)((char *)result + v29 + 192);
    uint64_t v33 = v32 + v31;
    int v34 = *(_DWORD *)((char *)result + v29 + 32);
    int v35 = *(_DWORD *)((char *)result + v29 + 160);
    uint64_t v36 = v35 + v34;
    int v37 = *(_DWORD *)((char *)result + v29 + 64);
    int v38 = *(_DWORD *)((char *)result + v29 + 128);
    int v39 = v38 + v37;
    uint64_t v40 = v38 + v37;
    uint64_t v41 = *(int *)((char *)result + v29 + 96);
    int v42 = v31 - v32;
    uint64_t v43 = v34 - v35;
    uint64_t v44 = v37 - v38;
    *int v30 = (unint64_t)(10700 * (v41 + v36 + v40 + v33) + 0x4000) >> 15;
    uint64_t v45 = 3783 * (v40 + v33 - 4 * v41);
    uint64_t v46 = 9850 * (v33 - v39);
    uint64_t v47 = 3367 * (v36 - v39);
    v30[16] = (unint64_t)(v47 + v46 + v45 + 0x4000) >> 15;
    uint64_t v48 = 9434 * (v33 - v36) + 0x4000;
    v30[32] = (unint64_t)(v48 + v47 + 0x7FFFFFFFE272 * (v36 - 2 * v41)) >> 15;
    v30[48] = (unint64_t)(v48 - v46 + v45) >> 15;
    uint64_t v49 = 10009 * (v43 + v42);
    uint64_t v50 = 1822 * (v42 - v43);
    uint64_t v51 = 6565 * (v44 + v42) + 0x4000;
    v30[8] = (unint64_t)(v51 - v50 + v49) >> 15;
    v30[24] = (unint64_t)(-14752 * (v44 + v43) + v50 + v49 + 0x4000) >> 15;
    v30[40] = (unint64_t)(v51 + 20017 * v44 - 14752 * (v44 + v43)) >> 15;
    v29 += 4;
  }
  while (v29 != 28);
  return result;
}

_OWORD *jpeg_fdct_6x6(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  uint64_t v4 = a3;
  *uint64_t result = 0u;
  result[1] = 0u;
  do
  {
    uint64_t v5 = (int *)&result[v3];
    int v6 = (unsigned __int8 *)(*(void *)(a2 + v3 * 4) + v4);
    int v7 = *v6;
    int v8 = v6[5];
    int v9 = v6[1];
    int v10 = v6[4];
    int v11 = v10 + v9;
    int v12 = v6[2];
    LODWORD(v6) = v6[3];
    int v13 = v6 + v12 + v8 + v7;
    int v14 = v8 + v7 - (v6 + v12);
    int v15 = v7 - v8;
    int v16 = v9 - v10;
    LODWORD(v6) = v12 - v6;
    int v17 = 4 * (v13 + v10 + v9) - 3072;
    unint64_t v18 = (unint64_t)(5793 * (v13 - 2 * v11) + 1024) >> 11;
    unint64_t v19 = (unint64_t)(2998 * ((int)v6 + v15) + 1024) >> 11;
    *uint64_t v5 = v17;
    v5[1] = v19 + 4 * (v16 + v15);
    void v5[2] = (10033 * v14 + 1024) >> 11;
    v5[3] = 4 * (v15 - (v16 + v6));
    v5[4] = v18;
    v5[5] = v19 + 4 * (v6 - v16);
    v3 += 2;
  }
  while (v3 != 12);
  uint64_t v20 = 0;
  do
  {
    int v21 = (_DWORD *)((char *)result + v20);
    int v22 = *(_DWORD *)((char *)result + v20);
    int v23 = *(_DWORD *)((char *)result + v20 + 160);
    int v24 = *(_DWORD *)((char *)result + v20 + 32);
    int v25 = *(_DWORD *)((char *)result + v20 + 128);
    int v26 = v25 + v24;
    int v27 = *(_DWORD *)((char *)result + v20 + 64);
    int v28 = *(_DWORD *)((char *)result + v20 + 96);
    uint64_t v29 = v28 + v27 + (uint64_t)(v23 + v22);
    uint64_t v30 = v23 + v22 - (uint64_t)(v28 + v27);
    uint64_t v31 = v22 - v23;
    uint64_t v32 = v24 - v25;
    uint64_t v33 = v27 - v28;
    *int v21 = (unint64_t)(14564 * (v29 + v26) + 0x4000) >> 15;
    v21[16] = (unint64_t)(17837 * v30 + 0x4000) >> 15;
    v21[32] = (unint64_t)(10298 * (v29 - 2 * v26) + 0x4000) >> 15;
    uint64_t v34 = 5331 * (v33 + v31) + 0x4000;
    v21[8] = (unint64_t)(v34 + 14564 * (v32 + v31)) >> 15;
    v21[24] = (unint64_t)(14564 * (v31 - (v32 + v33)) + 0x4000) >> 15;
    v21[40] = (unint64_t)(v34 + 14564 * (v33 - v32)) >> 15;
    v20 += 4;
  }
  while (v20 != 24);
  return result;
}

_OWORD *jpeg_fdct_5x5(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  uint64_t v4 = a3;
  result[2] = 0u;
  result[3] = 0u;
  *uint64_t result = 0u;
  result[1] = 0u;
  do
  {
    uint64_t v5 = &result[v3];
    int v6 = (unsigned __int8 *)(*(void *)(a2 + v3 * 4) + v4);
    int v7 = *v6;
    int v8 = v6[4];
    int v9 = v8 + v7;
    uint64_t v10 = v6[1];
    uint64_t v11 = v6[3];
    int v12 = v11 + v10;
    LODWORD(v6) = v6[2];
    int v13 = v7 - v8;
    uint64_t v14 = v10 - v11;
    LODWORD(v10) = 8 * (v11 + v10 + v9 + v6) - 5120;
    LODWORD(v6) = v12 + v9 - 4 * v6;
    uint64_t v15 = 6476 * (v9 - v12) + 512;
    unint64_t v16 = (unint64_t)(v15 + 2896 * (int)v6) >> 10;
    v5[4] = (unint64_t)(v15 - 2896 * (int)v6) >> 10;
    uint64_t v17 = 6810 * ((int)v14 + v13) + 512;
    *uint64_t v5 = v10;
    v5[1] = (unint64_t)(v17 + 4209 * v13) >> 10;
    void v5[2] = v16;
    v5[3] = (unint64_t)(v17 + 0x3FFFFFFBA5CLL * v14) >> 10;
    v3 += 2;
  }
  while (v3 != 10);
  uint64_t v18 = 0;
  do
  {
    unint64_t v19 = (_DWORD *)((char *)result + v18);
    int v20 = *(_DWORD *)((char *)result + v18);
    int v21 = *(_DWORD *)((char *)result + v18 + 128);
    int v22 = *(_DWORD *)((char *)result + v18 + 32);
    int v23 = *(_DWORD *)((char *)result + v18 + 96);
    uint64_t v24 = v23 + v22;
    uint64_t v25 = *(int *)((char *)result + v18 + 64);
    uint64_t v26 = v24 + v21 + v20;
    uint64_t v27 = v21 + v20 - v24;
    int v28 = v20 - v21;
    uint64_t v29 = v22 - v23;
    *unint64_t v19 = (unint64_t)(10486 * (v26 + v25) + 0x4000) >> 15;
    uint64_t v30 = 3707 * (v26 - 4 * v25);
    uint64_t v31 = 8290 * v27 + 0x4000;
    _OWORD v19[16] = (unint64_t)(v31 + v30) >> 15;
    v19[32] = (unint64_t)(v31 - v30) >> 15;
    uint64_t v32 = 8716 * (v29 + v28) + 0x4000;
    v19[8] = (unint64_t)(v32 + 5387 * v28) >> 15;
    v19[24] = (unint64_t)(v32 + 0x7FFFFFFFA6DCLL * v29) >> 15;
    v18 += 4;
  }
  while (v18 != 20);
  return result;
}

int32x4_t jpeg_fdct_4x4(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  uint64_t v4 = a3;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  do
  {
    uint64_t v5 = (_DWORD *)(a1 + 4 * v3);
    int v6 = (unsigned __int8 *)(*(void *)(a2 + v3) + v4);
    int v7 = *v6;
    int v8 = v6[3];
    int v9 = v8 + v7;
    uint64_t v10 = v6[1];
    uint64_t v11 = v6[2];
    int v12 = v11 + v10;
    int v13 = v7 - v8;
    uint64_t v14 = v10 - v11;
    uint64_t v15 = 4433 * ((int)v14 + v13) + 256;
    *uint64_t v5 = 16 * (v12 + v9) - 0x2000;
    v5[1] = (unint64_t)(v15 + 6270 * v13) >> 9;
    void v5[2] = 16 * (v9 - v12);
    v5[3] = (unint64_t)(v15 + 0x1FFFFFFC4DFLL * v14) >> 9;
    v3 += 8;
  }
  while (v3 != 32);
  int32x4_t v16 = *(int32x4_t *)(a1 + 96);
  int32x4_t v17 = vaddq_s32(v16, *(int32x4_t *)a1);
  int64x2_t v18 = vdupq_n_s64(2uLL);
  int64x2_t v19 = vaddw_s32(v18, *(int32x2_t *)v17.i8);
  int64x2_t v20 = vaddw_high_s32(v18, v17);
  int32x4_t v21 = *(int32x4_t *)(a1 + 32);
  int32x4_t v22 = *(int32x4_t *)(a1 + 64);
  int32x4_t v23 = vaddq_s32(v22, v21);
  int32x4_t v24 = vsubq_s32(*(int32x4_t *)a1, v16);
  int32x4_t v25 = vsubq_s32(v21, v22);
  *(void *)&long long v26 = v25.i32[2];
  *((void *)&v26 + 1) = v25.i32[3];
  long long v27 = v26;
  *(void *)&long long v26 = v25.i32[0];
  *((void *)&v26 + 1) = v25.i32[1];
  *(int32x4_t *)a1 = vshrn_high_n_s64(vshrn_n_s64(vaddw_s32(v19, *(int32x2_t *)v23.i8), 2uLL), vaddw_high_s32(v20, v23), 2uLL);
  *(int32x4_t *)(a1 + 64) = vshrn_high_n_s64(vshrn_n_s64(vsubw_s32(v19, *(int32x2_t *)v23.i8), 2uLL), vsubw_high_s32(v20, v23), 2uLL);
  int64x2_t v28 = vaddl_s32(*(int32x2_t *)v25.i8, *(int32x2_t *)v24.i8);
  int64x2_t v29 = vaddl_high_s32(v25, v24);
  v29.i64[0] *= 4433;
  v29.i64[1] *= 4433;
  v28.i64[0] *= 4433;
  v28.i64[1] *= 4433;
  int64x2_t v30 = vdupq_n_s64(0x4000uLL);
  int64x2_t v31 = vaddq_s64(v28, v30);
  int32x4_t v32 = vdupq_n_s32(0x187Eu);
  int64x2_t v33 = vaddq_s64(v29, v30);
  v30.i64[0] = 0x7FFFFFFFC4DFLL * v27;
  v30.i64[1] = 0x7FFFFFFFC4DFLL * *((void *)&v27 + 1);
  v16.i64[0] = 0x7FFFFFFFC4DFLL * v26;
  v16.i64[1] = 0x7FFFFFFFC4DFLL * *((void *)&v26 + 1);
  *(int32x4_t *)(a1 + 32) = vshrn_high_n_s64(vshrn_n_s64(vmlal_s32(v31, *(int32x2_t *)v24.i8, *(int32x2_t *)v32.i8), 0xFuLL), vmlal_high_s32(v33, v24, v32), 0xFuLL);
  int32x4_t result = vshrn_high_n_s64(vshrn_n_s64(vaddq_s64(v31, (int64x2_t)v16), 0xFuLL), vaddq_s64(v33, v30), 0xFuLL);
  *(int32x4_t *)(a1 + 96) = result;
  return result;
}

_OWORD *jpeg_fdct_3x3(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  *int32x4_t result = 0u;
  result[1] = 0u;
  do
  {
    uint64_t v4 = &result[v3];
    uint64_t v5 = (unsigned __int8 *)(*(void *)(a2 + v3 * 4) + a3);
    int v6 = *v5;
    int v7 = v5[2];
    LODWORD(v5) = v5[1];
    v4[2] = (5793 * (v7 + v6 - 2 * (int)v5) + 256) >> 9;
    _DWORD *v4 = 16 * (v7 + v6 + v5) - 6144;
    v4[1] = (10033 * (v6 - v7) + 256) >> 9;
    v3 += 2;
  }
  while (v3 != 6);
  uint64_t v8 = 0;
  do
  {
    int v9 = (_DWORD *)((char *)result + v8);
    int v10 = *(_DWORD *)((char *)result + v8);
    int v11 = *(_DWORD *)((char *)result + v8 + 64);
    uint64_t v12 = v11 + v10;
    uint64_t v13 = *(int *)((char *)result + v8 + 32);
    *int v9 = (unint64_t)(14564 * (v13 + v12) + 0x4000) >> 15;
    v9[16] = (unint64_t)(10298 * (v12 - 2 * v13) + 0x4000) >> 15;
    v9[8] = (unint64_t)(17837 * (v10 - v11) + 0x4000) >> 15;
    v8 += 4;
  }
  while (v8 != 12);
  return result;
}

double jpeg_fdct_2x2(uint64_t a1, void *a2, unsigned int a3)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v4 = (unsigned __int8 *)(*a2 + a3);
  int v5 = *v4;
  LODWORD(v4) = v4[1];
  int v6 = v4 + v5;
  LODWORD(v4) = v5 - v4;
  int v7 = (unsigned __int8 *)(a2[1] + a3);
  int v8 = *v7;
  LODWORD(v7) = v7[1];
  int v9 = v7 + v8;
  LODWORD(v7) = v8 - v7;
  *(_DWORD *)a1 = 16 * (v9 + v6) - 0x2000;
  *(_DWORD *)(a1 + 4) = 16 * (v7 + v4);
  *(_DWORD *)(a1 + 32) = 16 * (v6 - v9);
  *(_DWORD *)(a1 + 36) = 16 * (v4 - v7);
  return result;
}

double jpeg_fdct_1x1(_OWORD *a1, void *a2, unsigned int a3)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  *(_DWORD *)a1 = (*(unsigned __int8 *)(*a2 + a3) << 6) - 0x2000;
  return result;
}

_DWORD *jpeg_fdct_9x9(_DWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  memset(v56, 0, sizeof(v56));
  uint64_t v4 = result;
  while (1)
  {
    int v5 = (unsigned __int8 *)(*(void *)(a2 + 8 * v3) + a3);
    int v6 = *v5;
    int v7 = v5[8];
    uint64_t v8 = (v7 + v6);
    int v9 = v5[1];
    int v10 = v5[7];
    uint64_t v11 = (v10 + v9);
    int v12 = v5[2];
    int v13 = v5[6];
    uint64_t v14 = (v13 + v12);
    int v15 = v5[3];
    int v16 = v5[5];
    uint64_t v17 = (v16 + v15);
    uint64_t v18 = v5[4];
    int v19 = v6 - v7;
    LODWORD(v5) = v9 - v10;
    int v20 = v12 - v13;
    uint64_t v21 = v14 + v8 + v17;
    int v22 = 2 * (v21 + v18 + v11) - 2304;
    unint64_t v23 = (unint64_t)(5793 * (v21 - 2 * (v18 + v11)) + 2048) >> 12;
    LODWORD(v11) = v11 - 2 * v18;
    uint64_t v24 = 10887 * ((int)v8 - (int)v14) + 2048;
    unint64_t v25 = (unint64_t)(v24 + 2012 * ((int)v17 - (int)v8) - 5793 * (int)v11) >> 12;
    v4[2] = (unint64_t)(v24 + 8875 * ((int)v14 - (int)v17) + 5793 * (int)v11) >> 12;
    v4[3] = (unint64_t)(10033 * (v19 - (v20 + v15 - v16)) + 2048) >> 12;
    uint64_t v26 = 7447 * (v20 + v19);
    uint64_t v27 = 3962 * (v15 - v16 + v19);
    _DWORD *v4 = v22;
    v4[1] = (unint64_t)(v26 + 10033 * (int)v5 + v27 + 2048) >> 12;
    int v28 = v20 - (v15 - v16);
    v4[4] = v25;
    v4[5] = (unint64_t)(v26 - 11409 * v28 - 10033 * (int)v5 + 2048) >> 12;
    v4[6] = v23;
    v4[7] = (unint64_t)(v27 - 10033 * (int)v5 + 11409 * v28 + 2048) >> 12;
    if (v3 != 7) {
      break;
    }
    uint64_t v4 = v56;
LABEL_6:
    ++v3;
  }
  if (v3 != 8)
  {
    v4 += 8;
    goto LABEL_6;
  }
  uint64_t v29 = 0;
  do
  {
    int64x2_t v30 = &result[v29];
    int v31 = result[v29];
    int v32 = *(_DWORD *)((char *)v56 + v29 * 4);
    int v33 = v32 + v31;
    int v34 = result[v29 + 8];
    int v35 = result[v29 + 56];
    uint64_t v36 = v35 + v34;
    int v37 = result[v29 + 16];
    int v38 = result[v29 + 48];
    uint64_t v39 = v38 + v37;
    int v40 = result[v29 + 24];
    int v41 = result[v29 + 40];
    int v42 = v41 + v40;
    uint64_t v43 = v31 - v32;
    uint64_t v44 = v37 - v38;
    uint64_t v45 = v40 - v41;
    uint64_t v46 = (int)result[v29 + 32];
    int v47 = v34 - v35;
    uint64_t v48 = v39 + v33 + v42;
    uint64_t v49 = result;
    *int64x2_t v30 = (unint64_t)(12945 * (v48 + v46 + v36) + 0x4000) >> 15;
    v30[48] = (unint64_t)(9154 * (v48 - 2 * (v46 + v36)) + 0x4000) >> 15;
    uint64_t v50 = 9154 * (v36 - 2 * v46);
    uint64_t v51 = 17203 * (v33 - v39) + 0x4000;
    v30[16] = (unint64_t)(v51 + 14024 * (v39 - v42) + v50) >> 15;
    v30[32] = (unint64_t)(v51 + 3179 * (v42 - (uint64_t)v33) - v50) >> 15;
    v30[24] = (unint64_t)(15855 * (v43 - (v44 + v45)) + 0x4000) >> 15;
    uint64_t v52 = 11768 * (v44 + v43);
    uint64_t v53 = 6262 * (v45 + v43);
    v30[8] = (unint64_t)(v52 + 15855 * v47 + v53 + 0x4000) >> 15;
    uint64_t v54 = 18029 * (v44 - v45);
    v30[40] = (unint64_t)(v52 - 15855 * v47 - v54 + 0x4000) >> 15;
    uint64_t v55 = v53 - 15855 * v47;
    double result = v49;
    v30[56] = (unint64_t)(v55 + v54 + 0x4000) >> 15;
    ++v29;
  }
  while ((v29 * 4) != 32);
  return result;
}

unint64_t jpeg_fdct_10x10(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  memset(v57, 0, sizeof(v57));
  uint64_t v4 = a1;
  while (1)
  {
    int v5 = (unsigned __int8 *)(*(void *)(a2 + 8 * v3) + a3);
    int v6 = *v5;
    int v7 = v5[9];
    uint64_t v8 = v5[1];
    uint64_t v9 = v5[8];
    uint64_t v10 = (v9 + v8);
    uint64_t v11 = v5[3];
    uint64_t v12 = v5[6];
    uint64_t v13 = (v12 + v11);
    int v14 = v5[4];
    int v15 = v5[5];
    int v16 = v15 + v14 + v7 + v6;
    int v17 = v7 + v6 - (v15 + v14);
    uint64_t v18 = v13 + v10;
    uint64_t v19 = v10 - v13;
    int v20 = v6 - v7;
    uint64_t v21 = v5[2];
    uint64_t v22 = v5[7];
    uint64_t v23 = v8 - v9;
    LODWORD(v9) = v22 + v21;
    uint64_t v24 = v21 - v22;
    uint64_t v25 = v11 - v12;
    LODWORD(v12) = v9 + v16 + v18;
    unint64_t v26 = (0xFFFFFFFF204 * (v18 - (unint64_t)(2 * v9)) + 9373 * (v16 - 2 * (int)v9) + 2048) >> 12;
    uint64_t v27 = 6810 * (v17 + (int)v19) + 2048;
    LODWORD(v9) = v14 - v15 + v20;
    v4[4] = v26;
    v4[5] = 2 * (v9 - (v23 - v25 + v24));
    _DWORD *v4 = 2 * v12 - 2560;
    v4[1] = (unint64_t)(10323 * (int)v23
                             + 11443 * v20
                             + (v24 << 13)
                             + 5260 * (int)v25
                             + 1812 * (v14 - v15)
                             + 2048) >> 12;
    uint64_t v28 = 2531 * ((int)v9 + (int)v23 - (int)v25) - (v24 << 13) + ((v23 - v25) << 12);
    uint64_t v29 = -4815 * ((int)v25 + (int)v23) + 7791 * (v20 - (v14 - v15)) + 2048;
    v4[2] = (unint64_t)(v27 + 4209 * v17) >> 12;
    v4[3] = (unint64_t)(v29 + v28) >> 12;
    v4[6] = (unint64_t)(v27 + 0xFFFFFFFBA5CLL * v19) >> 12;
    v4[7] = (unint64_t)(v29 - v28) >> 12;
    if (v3 != 7) {
      break;
    }
    uint64_t v4 = v57;
LABEL_6:
    ++v3;
  }
  if (v3 != 9)
  {
    v4 += 8;
    goto LABEL_6;
  }
  uint64_t v30 = 0;
  do
  {
    int v31 = &a1[v30];
    int v32 = a1[v30];
    int v33 = *(_DWORD *)((char *)&v57[2] + v30 * 4);
    int v34 = a1[v30 + 8];
    int v35 = *(_DWORD *)((char *)v57 + v30 * 4);
    int v36 = a1[v30 + 24];
    int v37 = a1[v30 + 48];
    int v38 = a1[v30 + 32];
    int v39 = a1[v30 + 40];
    uint64_t v40 = v39 + v38 + (uint64_t)(v33 + v32);
    uint64_t v41 = v33 + v32 - (uint64_t)(v39 + v38);
    uint64_t v42 = v37 + v36 + (uint64_t)(v35 + v34);
    uint64_t v43 = v35 + v34 - (uint64_t)(v37 + v36);
    int v44 = a1[v30 + 16];
    int v45 = v32 - v33;
    int v46 = a1[v30 + 56];
    int v47 = v34 - v35;
    int v48 = v46 + v44;
    int v49 = v44 - v46;
    _DWORD *v31 = (unint64_t)(10486 * (v42 + v48 + v40) + 0x4000) >> 15;
    v31[32] = (unint64_t)(11997 * (v40 - 2 * v48) + 0x7FFFFFFFEE1ALL * (v42 - 2 * v48) + 0x4000) >> 15;
    uint64_t v50 = 8716 * (v41 + v43) + 0x4000;
    v31[16] = (unint64_t)(v50 + 5387 * v41) >> 15;
    v31[48] = (unint64_t)(v50 + 0x7FFFFFFFA6DCLL * v43) >> 15;
    uint64_t v51 = v38 - v39 + (uint64_t)v45;
    uint64_t v52 = v47 - (uint64_t)(v36 - v37);
    v31[40] = (unint64_t)(10486 * (v51 - (v52 + v49)) + 0x4000) >> 15;
    v31[8] = (unint64_t)(13213 * v47
                              + 14647 * v45
                              + 10486 * v49
                              + 6732 * (v36 - v37)
                              + 2320 * (v38 - v39)
                              + 0x4000) >> 15;
    uint64_t v53 = 5243 * v52 - 10486 * v49 + 3240 * (v51 + v52);
    uint64_t v54 = -6163 * (v36 - v37 + (uint64_t)v47) + 9973 * (v45 - (uint64_t)(v38 - v39)) + 0x4000;
    unint64_t result = (unint64_t)(v54 + v53) >> 15;
    unsigned char v31[24] = result;
    v31[56] = (unint64_t)(v54 - v53) >> 15;
    ++v30;
  }
  while ((v30 * 4) != 32);
  return result;
}

uint64_t jpeg_fdct_11x11(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  memset(v82, 0, sizeof(v82));
  uint64_t v4 = a1;
  while (1)
  {
    int v5 = (unsigned __int8 *)(*(void *)(a2 + 8 * v3) + a3);
    uint64_t v6 = *v5;
    uint64_t v7 = v5[10];
    uint64_t v8 = (v7 + v6);
    int v9 = v5[2];
    int v10 = v5[8];
    uint64_t v11 = (v10 + v9);
    int v12 = v5[3];
    int v13 = v5[7];
    uint64_t v14 = (v13 + v12);
    uint64_t v15 = v5[4];
    uint64_t v16 = v5[6];
    uint64_t v17 = (v16 + v15);
    unsigned int v18 = v5[5];
    uint64_t v19 = v8 - 2 * v5[5];
    uint64_t v20 = v11 - 2 * v5[5];
    uint64_t v21 = v14 - 2 * v5[5];
    uint64_t v22 = v17 - 2 * v5[5];
    uint64_t v23 = 1649 * ((int)v20 + (int)v22) + 11116 * ((int)v19 + (int)v21);
    int v24 = v5[1];
    LODWORD(v5) = v5[9];
    uint64_t v25 = v6 - v7;
    uint64_t v26 = (v5 + v24);
    LODWORD(v5) = v24 - v5;
    LODWORD(v7) = v9 - v10;
    int v27 = v12 - v13;
    uint64_t v28 = v15 - v16;
    int v29 = v26 + v8 + v11 + v14;
    uint64_t v30 = v26 - 2 * v18;
    int v31 = v29 + v18;
    int v32 = v30 - v21;
    int v33 = v17 + v31;
    uint64_t v34 = 0xFFFFFFFDF6ALL * v21 + 7587 * ((int)v30 - (int)v21) + 0xFFFFFFFD37DLL * v22;
    uint64_t v35 = 9746 * ((int)v19 - (int)v30) + 2048;
    uint64_t v36 = v35 + 0xFFFFFFFCC25 * v19;
    uint64_t v37 = v35 - v30 + (v30 << 9) + 0xFFFFFFFD494 * v20 + 4813 * (int)v22;
    uint64_t v38 = v34 + v23;
    uint64_t v39 = 10538 * ((int)v5 + (int)v25) + 2048;
    _DWORD *v4 = 2 * v33 - 2816;
    v4[1] = (unint64_t)(v39
                             + 0xFFFFFFFC8F6 * v25
                             + 8756 * ((int)v7 + (int)v25)
                             + 6263 * (v27 + (int)v25)
                             + 3264 * (int)v28) >> 12;
    unint64_t v40 = (unint64_t)(v38 + 2048) >> 12;
    LODWORD(v38) = v7 + v5;
    uint64_t v41 = v39 + 10456 * (int)v5;
    LODWORD(v5) = v27 + v5;
    v4[2] = v40;
    v4[3] = (unint64_t)(v41 - 6263 * (int)v38 - 11467 * (int)v5 + 0xFFFFFFFDDCCLL * v28) >> 12;
    v4[4] = (unint64_t)(v37 + 7587 * v32) >> 12;
    v4[5] = (unint64_t)(-16294 * (int)v7
                             - 6263 * (int)v38
                             + 8756 * ((int)v7 + (int)v25)
                             + 3264 * (v27 + (int)v7)
                             + 11467 * (int)v28
                             + 2048) >> 12;
    v4[6] = (unint64_t)(v36 + 0xFFFFFFFE6C3 * v20 + v23) >> 12;
    v4[7] = (unint64_t)(10695 * v27
                             + 3264 * (v27 + (int)v7)
                             - 11467 * (int)v5
                             + 6263 * (v27 + (int)v25)
                             + 0xFFFFFFFD6D6 * v28
                             + 2048) >> 12;
    if (v3 != 7) {
      break;
    }
    uint64_t v4 = v82;
LABEL_6:
    ++v3;
  }
  if (v3 != 10)
  {
    v4 += 8;
    goto LABEL_6;
  }
  uint64_t v42 = 0;
  do
  {
    uint64_t v43 = &a1[v42];
    int v44 = a1[v42];
    int v45 = *(_DWORD *)((char *)&v82[4] + v42 * 4);
    uint64_t v46 = v45 + v44;
    int v47 = a1[v42 + 8];
    int v48 = *(_DWORD *)((char *)&v82[2] + v42 * 4);
    uint64_t v49 = v48 + v47;
    int v50 = a1[v42 + 16];
    int v51 = *(_DWORD *)((char *)v82 + v42 * 4);
    int v52 = v51 + v50;
    int v53 = a1[v42 + 24];
    int v54 = a1[v42 + 56];
    int v55 = a1[v42 + 32];
    int v56 = v44 - v45;
    int v57 = a1[v42 + 48];
    int v58 = v47 - v48;
    int v59 = v57 + v55;
    int v60 = v50 - v51;
    uint64_t v61 = (int)a1[v42 + 40];
    int v62 = v53 - v54;
    unint64_t v63 = 8666 * (v49 + v46 + v52 + v54 + v53 + v57 + v55 + v61) + 0x4000;
    uint64_t v64 = v46 - 2 * v61;
    uint64_t v65 = v49 - 2 * v61;
    uint64_t v66 = 10310 * (v64 - v65) + 0x4000;
    uint64_t result = (v55 - v57);
    _DWORD *v43 = v63 >> 15;
    uint64_t v68 = v52 - 2 * v61;
    uint64_t v69 = v66 + 540 * v65 + 0x7FFFFFFFD211 * v68;
    uint64_t v70 = v54 + v53 - 2 * v61;
    uint64_t v71 = v59 - 2 * v61;
    uint64_t v72 = v66 + 0x7FFFFFFFC925 * v64 + 0x7FFFFFFFE54DLL * v68;
    uint64_t v73 = 1744 * (v68 + v71) + 11759 * (v64 + v70);
    uint64_t v74 = 8026 * (v65 - v70);
    v43[16] = (unint64_t)(v74 + 0x7FFFFFFFDD87 * v70 + 0x7FFFFFFFD0EALL * v71 + v73 + 0x4000) >> 15;
    v43[32] = (unint64_t)(v69 + 5091 * v71 + v74) >> 15;
    v43[48] = (unint64_t)(v72 + v73) >> 15;
    uint64_t v75 = 9262 * (v60 + (uint64_t)v56);
    uint64_t v76 = 6626 * (v62 + (uint64_t)v56);
    uint64_t v77 = 11148 * (v58 + (uint64_t)v56) + 0x4000;
    uint64_t v78 = -6626 * (v60 + (uint64_t)v58);
    v43[8] = (unint64_t)(v77 + 0x7FFFFFFFC5C7 * v56 + v75 + v76 + 3453 * (int)result) >> 15;
    uint64_t v79 = 3453 * (v62 + (uint64_t)v60);
    v43[24] = (unint64_t)(v77
                               + 11061 * v58
                               + v78
                               - 12131 * (v62 + (uint64_t)v58)
                               + 0x7FFFFFFFDBD2 * (int)result) >> 15;
    v43[40] = (unint64_t)(v78 - 17237 * v60 + v75 + v79 + 12131 * (int)result + 0x4000) >> 15;
    v43[56] = (unint64_t)(v79
                               + 11314 * v62
                               + -12131 * (v62 + (uint64_t)v58)
                               + v76
                               + 0x7FFFFFFFD474 * (int)result
                               + 0x4000) >> 15;
    ++v42;
  }
  while ((v42 * 4) != 32);
  return result;
}

uint64_t jpeg_fdct_12x12(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  memset(v75, 0, sizeof(v75));
  uint64_t v4 = a1;
  while (1)
  {
    int v5 = (unsigned __int8 *)(*(void *)(a2 + 8 * v3) + a3);
    uint64_t v6 = *v5;
    uint64_t v7 = v5[11];
    int v8 = v5[1];
    uint64_t v9 = v5[2];
    uint64_t v10 = v5[9];
    uint64_t v11 = (v10 + v9);
    int v12 = v5[3];
    int v13 = v5[8];
    uint64_t v14 = (v13 + v12);
    uint64_t v15 = v5[5];
    uint64_t v16 = v5[6];
    int v17 = v16 + v15 + v7 + v6;
    int v18 = v7 + v6 - (v16 + v15);
    int v19 = v14 + v11;
    uint64_t v20 = v11 - v14;
    int v21 = v5[10];
    uint64_t v22 = v6 - v7;
    uint64_t v23 = (v21 + v8);
    int v24 = v8 - v21;
    uint64_t v25 = v9 - v10;
    LODWORD(v6) = v5[4];
    int v26 = v5[7];
    uint64_t v27 = (v26 + v6);
    LODWORD(v10) = v6 - v26;
    uint64_t v28 = v15 - v16;
    uint64_t v29 = v23 - v27;
    LODWORD(v23) = v19 + v23 + v27 + v17 - 1536;
    int v30 = v18 - (v29 + v20);
    int v31 = v17 - v19;
    uint64_t v32 = v29 - v20 + 11190 * (v18 + (int)v20);
    uint64_t v33 = 6270 * v24 + 4433 * ((int)v10 + v24);
    uint64_t v34 = -15137 * (int)v10 + 4433 * ((int)v10 + v24);
    int v35 = v12 - v13 + v22;
    uint64_t v36 = 9191 * ((int)v25 + (int)v22) + 4096;
    _DWORD *v4 = v23;
    v4[1] = (unint64_t)(v36 + 0x1FFFFFFFED6ALL * v22 + 7053 * v35 + v33 + 1512 * (int)v28) >> 13;
    v4[2] = (unint64_t)(v32 + 4096) >> 13;
    v4[3] = (unint64_t)(v34 + 10703 * ((int)v22 - (v12 - v13)) + 0x1FFFFFFFEEAFLL * (v28 + v25) + 4096) >> 13;
    int v37 = v12 - v13 + v25;
    v4[4] = (unint64_t)(10033 * v31 + 4096) >> 13;
    v4[5] = (unint64_t)(v36 - 19165 * (int)v25 - 1512 * v37 - v34 + 7053 * (int)v28) >> 13;
    v4[6] = v30;
    v4[7] = (unint64_t)(5946 * (v12 - v13) + 7053 * v35 - 1512 * v37 - v33 + 0x1FFFFFFFDC19 * v28 + 4096) >> 13;
    if (v3 != 7) {
      break;
    }
    uint64_t v4 = v75;
LABEL_6:
    ++v3;
  }
  if (v3 != 11)
  {
    v4 += 8;
    goto LABEL_6;
  }
  uint64_t v38 = 0;
  do
  {
    uint64_t v39 = &a1[v38];
    int v40 = a1[v38];
    int v41 = *(_DWORD *)((char *)&v75[6] + v38 * 4);
    int v42 = a1[v38 + 16];
    int v43 = *(_DWORD *)((char *)&v75[2] + v38 * 4);
    int v44 = a1[v38 + 24];
    int v45 = *(_DWORD *)((char *)v75 + v38 * 4);
    int v46 = a1[v38 + 40];
    int v47 = a1[v38 + 48];
    uint64_t v48 = v47 + v46 + (uint64_t)(v41 + v40);
    uint64_t v49 = v41 + v40 - (uint64_t)(v47 + v46);
    uint64_t v50 = v45 + v44 + (uint64_t)(v43 + v42);
    uint64_t v51 = v43 + v42 - (uint64_t)(v45 + v44);
    int v52 = a1[v38 + 8];
    int v53 = *(_DWORD *)((char *)&v75[4] + v38 * 4);
    int v54 = v40 - v41;
    int v55 = v53 + v52;
    int v56 = v52 - v53;
    int v57 = a1[v38 + 32];
    int v58 = v42 - v43;
    int v59 = a1[v38 + 56];
    int v60 = v59 + v57;
    int v61 = v57 - v59;
    int v62 = v46 - v47;
    uint64_t v63 = v55 - (uint64_t)v60;
    *uint64_t v39 = (unint64_t)(7282 * (v50 + v55 + v60 + v48) + 0x2000) >> 14;
    v39[48] = (unint64_t)(7282 * (v49 - (v63 + v51)) + 0x2000) >> 14;
    uint64_t v64 = v48 - v50;
    uint64_t v65 = v54;
    v39[32] = (unint64_t)(8918 * v64 + 0x2000) >> 14;
    uint64_t v66 = v44 - v45;
    v39[16] = (unint64_t)(9947 * (v49 + v51) + 7282 * (v63 - v51) + 0x2000) >> 14;
    uint64_t v67 = 3941 * (v61 + (uint64_t)v56);
    uint64_t v68 = v67 + 5573 * v56;
    uint64_t v69 = v67 - 13455 * v61;
    uint64_t v70 = v58 + (uint64_t)v54;
    uint64_t v71 = 6269 * (v66 + v54);
    uint64_t v72 = 8170 * v70 + 0x2000;
    v39[8] = (unint64_t)(v72 + 0x3FFFFFFFEF7BLL * v65 + v71 + v68 + 1344 * v62) >> 14;
    uint64_t result = v62 + (uint64_t)v58;
    v39[24] = (unint64_t)(v69 + 9514 * (v65 - v66) + 0x3FFFFFFFF09BLL * result + 0x2000) >> 14;
    v39[40] = (unint64_t)(v72 - 17036 * v58 - 1344 * (v66 + v58) - v69 + 6269 * v62) >> 14;
    v39[56] = (unint64_t)(v71 + 5285 * v66 - 1344 * (v66 + v58) - v68 + 0x3FFFFFFFE016 * v62 + 0x2000) >> 14;
    ++v38;
  }
  while ((v38 * 4) != 32);
  return result;
}

uint64_t jpeg_fdct_13x13(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  memset(v91, 0, sizeof(v91));
  uint64_t v87 = a1;
  uint64_t v88 = a3;
  while (1)
  {
    uint64_t v90 = v3;
    uint64_t v4 = (unsigned __int8 *)(*(void *)(a2 + 8 * v3) + v88);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[12];
    int v7 = v4[1];
    int v8 = v4[6];
    int v9 = v6 + v5 - 2 * v8;
    int v10 = v4[11];
    int v11 = v10 + v7;
    int v12 = v10 + v7 - 2 * v8;
    int v13 = v4[2];
    int v14 = v4[10];
    int v15 = v14 + v13 - 2 * v8;
    int v16 = v4[3];
    int v17 = v4[9];
    uint64_t v18 = (v17 + v16);
    uint64_t v19 = v18 - 2 * v4[6];
    uint64_t v20 = v4[4];
    uint64_t v21 = v4[8];
    uint64_t v22 = (v21 + v20);
    uint64_t v23 = v22 - 2 * v4[6];
    uint64_t v24 = v4[5];
    uint64_t v25 = v4[7];
    uint64_t v26 = (v25 + v24);
    uint64_t v27 = v26 - 2 * v4[6];
    uint64_t v28 = 11249 * v9
        + 8672 * v12
        + 4108 * v15
        + 0x1FFFFFFFFA8CLL * v19
        + 0x1FFFFFFFE64BLL * v23
        + 0x1FFFFFFFD7EELL * v27;
    int v29 = v7 - v10;
    uint64_t v30 = 9465 * (v9 - v15) - 3570 * ((int)v19 - (int)v23) - 2592 * (v12 - (int)v27);
    uint64_t v31 = v20 - v21;
    uint64_t v32 = 793 * (v9 + v15) - 7678 * ((int)v19 + (int)v23) + 3989 * (v12 + (int)v27);
    uint64_t v33 = 7682 * (v16 - v17 + (int)v5 - (int)v6) + 2773 * ((int)v24 - (int)v25 + (int)v31);
    uint64_t v34 = -2773 * (v13 - v14 + v29) + 7682 * ((int)v31 - ((int)v24 - (int)v25));
    uint64_t v35 = 10832 * (v29 + (int)v5 - (int)v6) + 4096;
    int v36 = v13 - v14 + v5 - v6;
    *a1 = v26 + v11 + v6 + v5 + v14 + v13 + v18 + v22 + v8 - 1664;
    a1[1] = (unint64_t)(v35 + 0x1FFFFFFFBF5BLL * (v5 - v6) + 9534 * v36 + 2611 * (int)v31 + v33) >> 13;
    uint64_t v37 = v35 + 6859 * v29;
    LODWORD(v35) = v16 - v17 + v29;
    a1[2] = (unint64_t)(v28 + 4096) >> 13;
    a1[3] = (unint64_t)(v37 - 9534 * (int)v35 + 0x1FFFFFFFB511 * v31 + v34) >> 13;
    LODWORD(v31) = v16 - v17 + v13 - v14;
    a1[4] = (unint64_t)(v32 + v30 + 4096) >> 13;
    a1[5] = (unint64_t)(-12879 * (v13 - v14)
                             + 9534 * v36
                             - 5384 * (int)v31
                             + 18515 * ((int)v24 - (int)v25)
                             + v34
                             + 4096) >> 13;
    a1[6] = (unint64_t)(v30 - v32 + 4096) >> 13;
    a1[7] = (unint64_t)(18068 * (v16 - v17)
                             - 5384 * (int)v31
                             - 9534 * (int)v35
                             + 0x1FFFFFFFC83FLL * (v24 - v25)
                             + v33
                             + 4096) >> 13;
    if (v90 != 7) {
      break;
    }
    a1 = v91;
LABEL_6:
    uint64_t v3 = v90 + 1;
  }
  if (v90 != 12)
  {
    a1 += 8;
    goto LABEL_6;
  }
  uint64_t v38 = 0;
  do
  {
    uint64_t v39 = &v87[v38];
    int v40 = v87[v38];
    int v41 = *(_DWORD *)((char *)&v91[8] + v38 * 4);
    uint64_t v42 = v41 + v40;
    int v43 = v87[v38 + 8];
    int v44 = *(_DWORD *)((char *)&v91[6] + v38 * 4);
    uint64_t v45 = v44 + v43;
    int v46 = v87[v38 + 16];
    int v47 = *(_DWORD *)((char *)&v91[4] + v38 * 4);
    int v48 = v87[v38 + 24];
    int v49 = *(_DWORD *)((char *)&v91[2] + v38 * 4);
    uint64_t v50 = v47 + v46;
    int v51 = v49 + v48;
    int v52 = v87[v38 + 32];
    int v53 = *(_DWORD *)((char *)v91 + v38 * 4);
    int v54 = v53 + v52;
    int v55 = v40 - v41;
    uint64_t v56 = v49 + v48;
    int v57 = v87[v38 + 40];
    int v58 = v43 - v44;
    int v59 = v87[v38 + 56];
    int v60 = v46 - v47;
    int v61 = v48 - v49;
    int v62 = v59 + v57;
    int v63 = v52 - v53;
    uint64_t v64 = (int)v87[v38 + 48];
    int v65 = v57 - v59;
    uint64_t v66 = v45 + v42 + v50;
    uint64_t v67 = v42 - 2 * v64;
    uint64_t v68 = v45 - 2 * v64;
    uint64_t v69 = v50 - 2 * v64;
    uint64_t v70 = v56 - 2 * v64;
    uint64_t v71 = v54 - 2 * v64;
    uint64_t v72 = v66 + v51 + v54;
    uint64_t v73 = v62 - 2 * v64;
    uint64_t v74 = 7169 * (v67 - v69) - 2704 * (v70 - v71) - 1963 * (v68 - v73);
    uint64_t v75 = v55;
    *uint64_t v39 = (unint64_t)(6205 * (v72 + v62 + v64) + 0x2000) >> 14;
    uint64_t v76 = v67 + v69;
    uint64_t v77 = 8520 * v67 + 6568 * v68 + 3112 * v69 + 0x3FFFFFFFFBDELL * v70;
    uint64_t v78 = 601 * v76 - 5816 * (v70 + v71);
    uint64_t v79 = v77 + 0x3FFFFFFFEC87 * v71;
    uint64_t v80 = v78 + 3021 * (v68 + v73);
    uint64_t v81 = 5819 * (v61 + (uint64_t)v55) + 2100 * (v65 + (uint64_t)v63);
    uint64_t v82 = v80 + v74;
    uint64_t result = v74 - v80;
    uint64_t v84 = -2100 * (v60 + (uint64_t)v58) + 5819 * (v63 - (uint64_t)v65);
    uint64_t v85 = 8204 * (v58 + (uint64_t)v55) + 0x2000;
    uint64_t v86 = 7221 * (v60 + (uint64_t)v55);
    v39[8] = (unint64_t)(v85 + 0x3FFFFFFFCF0ALL * v75 + v86 + 1978 * v63 + v81) >> 14;
    v39[32] = (unint64_t)(v82 + 0x2000) >> 14;
    v39[24] = (unint64_t)(v85 + 5195 * v58 - 7221 * (v61 + (uint64_t)v58) + 0x3FFFFFFFC73FLL * v63 + v84) >> 14;
    v39[48] = (unint64_t)(result + 0x2000) >> 14;
    v39[40] = (unint64_t)(v86 - 9754 * v60 - 4078 * (v61 + (uint64_t)v60) + 14023 * v65 + v84 + 0x2000) >> 14;
    v39[16] = (unint64_t)(v79 + 0x3FFFFFFFE1A6 * v73 + 0x2000) >> 14;
    v39[56] = (unint64_t)(-4078 * (v61 + (uint64_t)v60)
                               + 13685 * v61
                               - 7221 * (v61 + (uint64_t)v58)
                               + 0x3FFFFFFFD5C5 * v65
                               + v81
                               + 0x2000) >> 14;
    ++v38;
  }
  while ((v38 * 4) != 32);
  return result;
}

uint64_t jpeg_fdct_14x14(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a3;
  uint64_t v5 = a1;
  memset(v81, 0, sizeof(v81));
  while (1)
  {
    uint64_t v6 = (unsigned __int8 *)(*(void *)(a2 + 8 * v3) + v4);
    uint64_t v7 = *v6;
    uint64_t v8 = v6[13];
    uint64_t v9 = v6[1];
    uint64_t v10 = v6[12];
    uint64_t v11 = (v10 + v9);
    uint64_t v12 = v6[2];
    uint64_t v13 = v6[11];
    uint64_t v14 = (v13 + v12);
    int v15 = v6[4];
    int v16 = v6[9];
    uint64_t v17 = (v16 + v15);
    uint64_t v18 = v6[5];
    uint64_t v19 = v6[8];
    uint64_t v20 = (v19 + v18);
    uint64_t v21 = v6[6];
    uint64_t v22 = v6[7];
    int v23 = v22 + v21 + v8 + v7;
    int v24 = v8 + v7 - (v22 + v21);
    int v25 = v20 + v11;
    uint64_t v26 = v11 - v20;
    uint64_t v27 = v17 + v14;
    uint64_t v28 = v14 - v17;
    uint64_t v29 = v7 - v8;
    uint64_t v30 = v9 - v10;
    uint64_t v31 = v6[3];
    uint64_t v32 = v6[10];
    uint64_t v33 = v12 - v13;
    LODWORD(v13) = v32 + v31;
    uint64_t v34 = v31 - v32;
    LODWORD(v32) = v15 - v16;
    uint64_t v35 = v18 - v19;
    uint64_t v36 = 9058 * (v24 + (int)v26) + 4096;
    unint64_t v37 = v36 + 5027 * (int)v28 + 2237 * v24;
    LODWORD(v18) = v18 - v19 - v32;
    v5[6] = (unint64_t)(v36 + 0x1FFFFFFFD3E1 * v28 + 0x1FFFFFFFC8FCLL * v26) >> 13;
    v5[7] = v29 + v34 - (v21 - v22) - (v33 + v30 + v18);
    uint64_t v38 = 9810 * ((int)v33 + (int)v29) + 6164 * ((int)v21 - (int)v22 + (int)v32);
    uint64_t v39 = 11512 * (int)v18 - (v34 << 13) - 1297 * ((int)v33 + (int)v30) + 4096;
    v5[4] = (0x1FFFFFFFE3C9 * (v27 - (unint64_t)(2 * v13))
           + 2578 * (v25 - 2 * (int)v13)
           + 10438 * (v23 - 2 * (int)v13)
           + 4096) >> 13;
    v5[5] = (unint64_t)(v39 + 0x1FFFFFFFB409 * v33 + 9175 * (int)v32 + v38) >> 13;
    uint64_t v40 = 10935 * ((int)v30 + (int)v29) + 3826 * ((int)v35 - ((int)v21 - (int)v22));
    void v5[2] = v37 >> 13;
    v5[3] = (unint64_t)(v39 + 0x1FFFFFFFF26ELL * v30 + 0x1FFFFFFF9DC4 * v35 + v40) >> 13;
    *uint64_t v5 = v13 + v25 + v27 + v23 - 1792;
    v5[1] = (unint64_t)(v40 + (v34 << 13) + v21 - v22 + 0x1FFFFFFFDBF0 * (v21 - v22 + v29) + v38 + 4096) >> 13;
    if (v3 != 7) {
      break;
    }
    uint64_t v5 = v81;
LABEL_6:
    ++v3;
  }
  if (v3 != 13)
  {
    v5 += 8;
    goto LABEL_6;
  }
  uint64_t v41 = 0;
  do
  {
    uint64_t v42 = &a1[v41];
    int v43 = a1[v41];
    int v44 = *(_DWORD *)((char *)&v81[10] + v41 * 4);
    int v45 = a1[v41 + 8];
    int v46 = *(_DWORD *)((char *)&v81[8] + v41 * 4);
    int v47 = a1[v41 + 16];
    int v48 = *(_DWORD *)((char *)&v81[6] + v41 * 4);
    int v49 = a1[v41 + 24];
    int v50 = *(_DWORD *)((char *)&v81[4] + v41 * 4);
    int v51 = a1[v41 + 40];
    int v52 = v48 + v47;
    int v53 = a1[v41 + 48];
    int v54 = a1[v41 + 56];
    uint64_t v55 = v54 + v53 + (uint64_t)(v44 + v43);
    uint64_t v56 = v44 + v43 - (uint64_t)(v54 + v53);
    int v57 = *(_DWORD *)((char *)v81 + v41 * 4) + v51;
    int v58 = v43 - v44;
    uint64_t v59 = v57 + (uint64_t)(v46 + v45);
    uint64_t v60 = v46 + v45;
    int v61 = v45 - v46;
    int v62 = v50 + v49;
    int v63 = v47 - v48;
    int v64 = a1[v41 + 32];
    int v65 = *(_DWORD *)((char *)&v81[2] + v41 * 4);
    uint64_t v66 = v60 - v57;
    int v67 = v49 - v50;
    uint64_t v68 = v65 + v64 + (uint64_t)v52;
    uint64_t v69 = v52 - (uint64_t)(v65 + v64);
    LODWORD(v60) = v64 - v65;
    int v70 = v51 - *(_DWORD *)((char *)v81 + v41 * 4);
    _DWORD *v42 = (unint64_t)(5350 * (v68 + v62 + v59 + v55) + 0x2000) >> 14;
    uint64_t v71 = 5915 * (v56 + v66) + 0x2000;
    v42[16] = (unint64_t)(v71 + 3283 * v69 + 1461 * v56) >> 14;
    unint64_t v72 = (unint64_t)(v71 + 0x3FFFFFFFE330 * v69 + 0x3FFFFFFFDC12 * v66) >> 14;
    uint64_t v73 = v63 + (uint64_t)v61;
    v42[48] = v72;
    uint64_t v74 = v70 - (uint64_t)(v64 - v65);
    v42[56] = (unint64_t)(5350 * (v58 + (uint64_t)v67 - (v73 + v74 + v53 - v54)) + 0x2000) >> 14;
    uint64_t v75 = 7518 * v74 - 5350 * v67 - 847 * v73 + 0x2000;
    uint64_t v76 = v75 + 0x3FFFFFFFCE64 * v63;
    v42[32] = (unint64_t)(1684 * (v59 - 2 * v62)
                               + 0x3FFFFFFFED93 * (v68 - 2 * v62)
                               + 6817 * (v55 - 2 * v62)
                               + 0x2000) >> 14;
    uint64_t v77 = v75 + 0x3FFFFFFFF723 * v61;
    uint64_t result = 7141 * (v61 + (uint64_t)v58) + 2499 * (v70 - (uint64_t)(v53 - v54));
    uint64_t v79 = 6406 * (v63 + (uint64_t)v58) + 4025 * (v53 - v54 + (uint64_t)(int)v60);
    v42[40] = (unint64_t)(v76 + 5992 * (int)v60 + v79) >> 14;
    v42[24] = (unint64_t)(v77 + 0x3FFFFFFFBFD9 * v70 + result) >> 14;
    v42[8] = (unint64_t)(result
                              + 0x3FFFFFFFE873 * v58
                              + 5350 * v67
                              + 0x3FFFFFFFFD59 * (v53 - v54)
                              + v79
                              + 0x2000) >> 14;
    ++v41;
  }
  while ((v41 * 4) != 32);
  return result;
}

uint64_t jpeg_fdct_15x15(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  uint64_t v87 = *MEMORY[0x1E4F143B8];
  uint64_t v84 = a3;
  uint64_t v4 = a1;
  memset(v86, 0, sizeof(v86));
  while (1)
  {
    uint64_t v5 = (unsigned __int8 *)(*(void *)(a2 + 8 * v3) + v84);
    uint64_t v6 = *v5;
    uint64_t v7 = v5[14];
    uint64_t v8 = (v7 + v6);
    int v9 = v5[1];
    int v10 = v5[13];
    uint64_t v11 = (v10 + v9);
    uint64_t v12 = v5[2];
    uint64_t v13 = v5[12];
    uint64_t v14 = (v13 + v12);
    uint64_t v15 = v5[3];
    uint64_t v16 = v5[11];
    uint64_t v17 = (v16 + v15);
    uint64_t v18 = v5[4];
    uint64_t v19 = v5[10];
    uint64_t v20 = (v19 + v18);
    uint64_t v21 = v5[5];
    uint64_t v22 = v5[9];
    uint64_t v23 = (v22 + v21);
    uint64_t v24 = v6 - v7;
    uint64_t v25 = v5[6];
    int v26 = v9 - v10;
    uint64_t v27 = v5[8];
    uint64_t v28 = (v27 + v25);
    uint64_t v29 = v5[7];
    uint64_t v30 = v15 - v16;
    uint64_t v31 = v25 - v27;
    uint64_t v32 = v20 + v8 + v23;
    uint64_t v33 = v17 + v11 + v28;
    LODWORD(v27) = v29 + v14 + v32 + v33;
    uint64_t v34 = 0x1FFFFFFFF204 * (v33 - 2 * (v29 + v14)) + 9373 * (v32 - 2 * (v29 + v14));
    uint64_t v35 = v14 - 2 * v29 + ((unint64_t)(v20 + v11) >> 1);
    uint64_t v36 = v28 - v35;
    uint64_t v37 = 11332 * ((int)v8 - (int)v17) + 6476 * ((int)v11 - (int)v20) + 7752 * ((int)v28 - (int)v23) + 4096;
    unint64_t v38 = v37 + 12543 * (v17 - v35) + 0x1FFFFFFFB860 * v36;
    unint64_t v39 = v37 + 6541 * (v23 - v35) + 0x1FFFFFFFFD14 * (v8 - v35);
    uint64_t v40 = 11018 * ((int)v18 - (int)v19 + v26)
        + 4712 * ((int)v21 - (int)v22 + (int)v30)
        + 11522 * ((int)v24 - (int)v31);
    _DWORD *v4 = v27 - 1920;
    v4[1] = (unint64_t)(3897 * (int)v30
                             + 10033 * ((int)v12 - (int)v13)
                             + 0x1FFFFFFFEF8FLL * (v18 - v19)
                             + 13930 * (int)v31
                             + v40
                             + 4096) >> 13;
    v4[2] = v38 >> 13;
    v4[3] = (unint64_t)(6810 * (v26 - ((int)v30 + (int)v31))
                             + 11018 * ((int)v24 - ((int)v18 - (int)v19 + (int)v21 - (int)v22))
                             + 4096) >> 13;
    v4[4] = v39 >> 13;
    v4[5] = (unint64_t)(10033 * (v24 - (v12 - v13 + v30) + v21 - v22 + v31) + 4096) >> 13;
    v4[6] = (unint64_t)(v34 + 4096) >> 13;
    v4[7] = (unint64_t)(-17828 * v26
                             - 2912 * (int)v24
                             - 10033 * ((int)v12 - (int)v13)
                             + 0x1FFFFFFFE42FLL * (v21 - v22)
                             + v40
                             + 4096) >> 13;
    if (v3 != 7) {
      break;
    }
    uint64_t v4 = v86;
LABEL_6:
    ++v3;
  }
  if (v3 != 14)
  {
    v4 += 8;
    goto LABEL_6;
  }
  uint64_t v41 = 0;
  do
  {
    uint64_t v42 = &a1[v41];
    int v43 = a1[v41];
    int v44 = *(_DWORD *)((char *)&v86[12] + v41 * 4);
    int v45 = v44 + v43;
    int v46 = a1[v41 + 8];
    int v47 = *(_DWORD *)((char *)&v86[10] + v41 * 4);
    int v48 = v47 + v46;
    int v49 = a1[v41 + 16];
    int v50 = *(_DWORD *)((char *)&v86[8] + v41 * 4);
    int v51 = v50 + v49;
    int v52 = a1[v41 + 24];
    int v53 = *(_DWORD *)((char *)&v86[6] + v41 * 4);
    int v54 = a1[v41 + 32];
    int v55 = *(_DWORD *)((char *)&v86[4] + v41 * 4);
    int v56 = v55 + v54;
    int v57 = a1[v41 + 40];
    int v58 = *(_DWORD *)((char *)&v86[2] + v41 * 4);
    int v59 = a1[v41 + 48];
    int v60 = *(_DWORD *)((char *)v86 + v41 * 4);
    uint64_t v61 = v53 + v52;
    int v62 = v43 - v44;
    int v63 = v60 + v59;
    int v64 = v46 - v47;
    uint64_t v65 = (int)a1[v41 + 56];
    int v66 = v49 - v50;
    uint64_t v67 = v55 + v54;
    int v68 = v52 - v53;
    int v69 = v54 - v55;
    int v70 = v59 - v60;
    uint64_t v71 = v67 + v45 + v58 + v57;
    uint64_t v72 = v61 + v48 + v63;
    uint64_t v73 = v65 + v51;
    _DWORD *v42 = (unint64_t)(9321 * (v72 + v71 + v73) + 0x4000) >> 15;
    v42[48] = (unint64_t)(0x7FFFFFFFF017 * (v72 - 2 * v73) + 10664 * (v71 - 2 * v73) + 0x4000) >> 15;
    uint64_t v74 = v51 - 2 * v65 + ((v67 + v48) >> 1);
    uint64_t v75 = v58 + v57 - v74;
    uint64_t v76 = v45 - v74;
    uint64_t v77 = 12893 * (v45 - v61) + 7369 * (v48 - (uint64_t)v56) + 8820 * (v63 - (uint64_t)(v58 + v57)) + 0x4000;
    unint64_t v78 = v77 + 14271 * (v61 - v74) + 0x7FFFFFFFAE82 * (v63 - v74);
    unint64_t v79 = v77 + 7442 * v75 + 0x7FFFFFFFFCACLL * v76;
    uint64_t result = 4434 * v68 + 11415 * v66 + 0x7FFFFFFFED4CLL * v69;
    uint64_t v81 = v57 - v58;
    uint64_t v82 = 12536 * (v69 + (uint64_t)v64) + 5361 * (v81 + v68) + 13109 * (v62 - (uint64_t)v70);
    v42[8] = (unint64_t)(result + 15850 * v70 + v82 + 0x4000) >> 15;
    v42[24] = (unint64_t)(7748 * (v64 - (v68 + (uint64_t)v70)) + 12536 * (v62 - (v69 + v81)) + 0x4000) >> 15;
    v42[40] = (unint64_t)(11415 * (v62 - (v66 + (uint64_t)v68) + v81 + v70) + 0x4000) >> 15;
    v42[16] = v78 >> 15;
    v42[32] = v79 >> 15;
    v42[56] = (unint64_t)(-20284 * v64 - 3314 * v62 - 11415 * v66 + 0x7FFFFFFFE05ALL * v81 + v82 + 0x4000) >> 15;
    ++v41;
  }
  while ((v41 * 4) != 32);
  return result;
}

uint64_t jpeg_fdct_16x16(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = a1;
  uint64_t v4 = 0;
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  uint64_t v81 = a3;
  memset(v87, 0, sizeof(v87));
  while (1)
  {
    uint64_t v5 = (unsigned __int8 *)(*(void *)(a2 + 8 * v4) + v81);
    uint64_t v84 = *v5;
    uint64_t v85 = v5[15];
    uint64_t v86 = v4;
    uint64_t v6 = (v85 + v84);
    int v83 = v5[1];
    int v7 = v5[14];
    int v8 = v5[2];
    int v9 = v5[13];
    int v10 = v5[3];
    int v11 = v5[12];
    uint64_t v12 = (v11 + v10);
    int v13 = v5[4];
    int v14 = v5[11];
    uint64_t v15 = (v14 + v13);
    int v16 = v5[5];
    int v17 = v5[10];
    uint64_t v18 = v5[6];
    int v19 = v5[7];
    int v20 = v5[8];
    uint64_t v21 = (v20 + v19);
    int v22 = v21 + v6;
    uint64_t v23 = v5[9];
    LODWORD(v5) = v23 + v18 + v7 + v83;
    int v24 = v17 + v16 + v9 + v8;
    uint64_t v25 = 10703 * ((int)v21 + (int)v6 - ((int)v15 + (int)v12)) + 4433 * ((int)v5 - v24);
    uint64_t v26 = v6 - v21;
    int v27 = v7 + v83 - (v23 + v18);
    int v28 = v9 + v8 - (v17 + v16);
    LODWORD(v6) = v83 - v7;
    int v29 = v8 - v9;
    uint64_t v30 = 2260 * ((int)v12 - (int)v15 - v27) + 11363 * ((int)v26 - v28) + 1024;
    unint64_t v31 = v30 + 17799 * v28 + 11893 * v27;
    int v32 = v10 - v11;
    uint64_t v33 = v18 - v23;
    int v34 = v24 + v15 + v12 + v5 + v22;
    unint64_t v35 = v30 + 0x7FFFFFFDE07 * (v12 - v15) + 0x7FFFFFFF93ELL * v26;
    uint64_t v36 = 11086 * ((int)v6 + (int)v84 - (int)v85) + 3363 * ((int)v33 - (v19 - v20));
    uint64_t v37 = 10217 * (v29 + (int)v84 - (int)v85) + 5461 * (v19 - v20 + v16 - v17);
    uint64_t v38 = 8956 * (v10 - v11 + (int)v84 - (int)v85) + 7350 * (v13 - v14 - (v19 - v20));
    uint64_t v39 = 1136 * (v29 + (int)v6) + 11529 * ((int)v33 - (v16 - v17));
    uint64_t v40 = -5461 * (v10 - v11 + (int)v6) - 10217 * ((int)v33 + v13 - v14);
    uint64_t v41 = -11086 * (v10 - v11 + v29) + 3363 * (v16 - v17 - (v13 - v14));
    *uint64_t v3 = 4 * v34 - 0x2000;
    v3[1] = (unint64_t)(v37 + 0x7FFFFFFB6D6 * (v84 - v85) + 6387 * (v19 - v20) + v36 + v38 + 1024) >> 11;
    v3[2] = v31 >> 11;
    v3[3] = (unint64_t)(v40 + 589 * (int)v6 + 0x7FFFFFFCAC1 * v33 + v39 + v36 + 1024) >> 11;
    v3[4] = (unint64_t)(v25 + 1024) >> 11;
    v3[5] = (unint64_t)(v41 + 1024 - 9222 * v29 + 10055 * (v16 - v17) + v39 + v37) >> 11;
    v3[6] = v35 >> 11;
    v3[7] = (unint64_t)(v41 + 1024 + 8728 * v32 + 17760 * (v13 - v14) + v40 + v38) >> 11;
    if (v86 != 7) {
      break;
    }
    uint64_t v3 = v87;
LABEL_6:
    uint64_t v4 = v86 + 1;
  }
  if (v86 != 15)
  {
    v3 += 8;
    goto LABEL_6;
  }
  uint64_t v42 = 0;
  do
  {
    int v43 = &a1[v42];
    int v44 = a1[v42];
    int v45 = *(_DWORD *)((char *)&v87[14] + v42 * 4);
    int v46 = a1[v42 + 8];
    int v47 = *(_DWORD *)((char *)&v87[12] + v42 * 4);
    int v48 = a1[v42 + 16];
    int v49 = *(_DWORD *)((char *)&v87[10] + v42 * 4);
    int v50 = a1[v42 + 24];
    int v51 = *(_DWORD *)((char *)&v87[8] + v42 * 4);
    int v52 = a1[v42 + 32];
    int v53 = a1[v42 + 40];
    int v54 = *(_DWORD *)((char *)&v87[4] + v42 * 4);
    int v55 = a1[v42 + 48];
    int v56 = *(_DWORD *)((char *)&v87[2] + v42 * 4);
    int v57 = a1[v42 + 56];
    int v58 = *(_DWORD *)((char *)v87 + v42 * 4);
    uint64_t v59 = v58 + v57 + (uint64_t)(v45 + v44);
    uint64_t v60 = v45 + v44 - (uint64_t)(v58 + v57);
    uint64_t v61 = v56 + v55 + (uint64_t)(v47 + v46);
    int v62 = *(_DWORD *)((char *)&v87[6] + v42 * 4);
    uint64_t v63 = v47 + v46 - (uint64_t)(v56 + v55);
    uint64_t v64 = v54 + v53 + (uint64_t)(v49 + v48);
    uint64_t v65 = v49 + v48 - (uint64_t)(v54 + v53);
    uint64_t v66 = v62 + v52 + (uint64_t)(v51 + v50);
    uint64_t v67 = v51 + v50 - (uint64_t)(v62 + v52);
    int v68 = v44 - v45;
    int v69 = v46 - v47;
    int v70 = v48 - v49;
    int v71 = v50 - v51;
    _DWORD *v43 = (unint64_t)(v66 + v64 + v61 + v59 + 8) >> 4;
    v43[32] = (unint64_t)(10703 * (v59 - v66) + 4433 * (v61 - v64) + 0x10000) >> 17;
    uint64_t v72 = 2260 * (v67 - v63) + 11363 * (v60 - v65) + 0x10000;
    v43[16] = (unint64_t)(v72 + 17799 * v65 + 11893 * v63) >> 17;
    uint64_t v73 = v55 - v56;
    v43[48] = (unint64_t)(v72 + 0x1FFFFFFFFDE07 * v67 + 0x1FFFFFFFFF93ELL * v60) >> 17;
    uint64_t result = 11086 * (v46 - v47 + (uint64_t)v68) + 3363 * (v73 - (v57 - v58));
    uint64_t v75 = 10217 * (v70 + (uint64_t)v68) + 5461 * (v57 - v58 + (uint64_t)(v53 - v54));
    uint64_t v76 = 8956 * (v71 + (uint64_t)v68) + 7350 * (v52 - v62 - (uint64_t)(v57 - v58));
    uint64_t v77 = 1136 * (v70 + (uint64_t)v69) + 11529 * (v73 - (v53 - v54));
    uint64_t v78 = -5461 * (v71 + (uint64_t)v69) - 10217 * (v73 + v52 - v62);
    uint64_t v79 = -11086 * (v71 + (uint64_t)v70) + 3363 * (v53 - v54 - (uint64_t)(v52 - v62));
    v43[8] = (unint64_t)(v75 + 0x1FFFFFFFFB6D6 * v68 + 6387 * (v57 - v58) + result + v76 + 0x10000) >> 17;
    v43[24] = (unint64_t)(v78 + 589 * v69 + 0x1FFFFFFFFCAC1 * v73 + v77 + result + 0x10000) >> 17;
    v43[40] = (unint64_t)(v79 + 0x10000 - 9222 * v70 + 10055 * (v53 - v54) + v77 + v75) >> 17;
    v43[56] = (unint64_t)(v79 + 0x10000 + 8728 * v71 + 17760 * (v52 - v62) + v78 + v76) >> 17;
    ++v42;
  }
  while ((v42 * 4) != 32);
  return result;
}

uint64_t jpeg_fdct_16x8(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3;
  do
  {
    uint64_t v5 = (unsigned __int8 *)(*(void *)(a2 + v3) + v4);
    uint64_t v6 = *v5;
    uint64_t v7 = v5[15];
    uint64_t v8 = (v7 + v6);
    int v9 = v5[1];
    int v10 = v5[14];
    int v11 = v5[2];
    int v12 = v5[13];
    int v13 = v5[3];
    int v14 = v5[5];
    int v15 = v5[10];
    uint64_t v16 = v5[6];
    uint64_t v17 = v5[9];
    int v18 = v5[7];
    int v19 = v5[8];
    uint64_t v20 = (v19 + v18);
    int v21 = v20 + v8;
    uint64_t v22 = v8 - v20;
    int v23 = v17 + v16 + v10 + v9;
    int v24 = v10 + v9 - (v17 + v16);
    int v25 = v15 + v14 + v12 + v11;
    int v26 = v12 + v11 - (v15 + v14);
    LODWORD(v8) = v5[12];
    uint64_t v27 = v6 - v7;
    int v28 = v5[4];
    LODWORD(v7) = v9 - v10;
    uint64_t v29 = (v8 + v13);
    int v30 = v5[11];
    LODWORD(v6) = v11 - v12;
    uint64_t v31 = (v30 + v28);
    LODWORD(v5) = v13 - v8;
    uint64_t v32 = v29 - v31;
    LODWORD(v29) = v31 + v29;
    uint64_t v33 = v16 - v17;
    int v34 = v18 - v19;
    uint64_t v35 = 11086 * ((int)v7 + (int)v27) + 3363 * ((int)v16 - (int)v17 - v34);
    int v36 = v28 - v30;
    LODWORD(v31) = v14 - v15;
    uint64_t v37 = 10703 * (v21 - (int)v29) + 4433 * (v23 - v25);
    int v38 = v25 + v29 + v23 + v21;
    uint64_t v39 = 2260 * ((int)v32 - v24) + 11363 * ((int)v22 - v26) + 1024;
    uint64_t v40 = v39 + 17799 * v26;
    uint64_t v41 = 10217 * ((int)v6 + (int)v27) + 5461 * (v34 + (int)v31);
    uint64_t v42 = 8956 * ((int)v5 + (int)v27) + 7350 * (v36 - v34);
    uint64_t v43 = v39 + 0x7FFFFFFDE07 * v32;
    uint64_t v44 = 1136 * ((int)v6 + (int)v7) + 11529 * ((int)v33 - (int)v31);
    unint64_t v45 = v40 + 11893 * v24;
    uint64_t v46 = -5461 * ((int)v5 + (int)v7) - 10217 * ((int)v33 + v36);
    uint64_t v47 = v41 + 0x7FFFFFFB6D6 * v27 + 6387 * v34 + v35 + v42;
    uint64_t v48 = v46 + 589 * (int)v7 + 0x7FFFFFFCAC1 * v33 + v44 + v35;
    uint64_t v49 = -11086 * ((int)v5 + (int)v6) + 3363 * ((int)v31 - v36) + 1024;
    int v50 = (_DWORD *)(result + 4 * v3);
    v50[4] = (unint64_t)(v37 + 1024) >> 11;
    v50[5] = (unint64_t)(v49 - 9222 * (int)v6 + 10055 * (int)v31 + v44 + v41) >> 11;
    *int v50 = 4 * v38 - 0x2000;
    v50[1] = (unint64_t)(v47 + 1024) >> 11;
    v50[2] = v45 >> 11;
    v50[3] = (unint64_t)(v48 + 1024) >> 11;
    v50[6] = (unint64_t)(v43 + 0x7FFFFFFF93ELL * v22) >> 11;
    v50[7] = (unint64_t)(v49 + 8728 * (int)v5 + 17760 * v36 + v46 + v42) >> 11;
    v3 += 8;
  }
  while (v3 != 64);
  uint64_t v51 = 0;
  do
  {
    int v52 = (_DWORD *)(result + v51);
    int v53 = *(_DWORD *)(result + v51);
    int v54 = *(_DWORD *)(result + v51 + 224);
    int v55 = *(_DWORD *)(result + v51 + 32);
    int v56 = *(_DWORD *)(result + v51 + 192);
    int v57 = *(_DWORD *)(result + v51 + 64);
    int v58 = *(_DWORD *)(result + v51 + 160);
    uint64_t v59 = v58 + v57;
    int v60 = *(_DWORD *)(result + v51 + 96);
    int v61 = *(_DWORD *)(result + v51 + 128);
    uint64_t v62 = v61 + v60 + (uint64_t)(v54 + v53);
    uint64_t v63 = v54 + v53 - (uint64_t)(v61 + v60);
    uint64_t v64 = v59 + v56 + v55;
    uint64_t v65 = v56 + v55 - v59;
    int v66 = v53 - v54;
    uint64_t v67 = v60 - v61;
    *int v52 = (unint64_t)(v64 + v62 + 4) >> 3;
    v52[32] = (unint64_t)(v62 - v64 + 4) >> 3;
    uint64_t v68 = 4433 * (v63 + v65) + 0x8000;
    v52[16] = (unint64_t)(v68 + 6270 * v63) >> 16;
    v52[48] = (unint64_t)(v68 + 0xFFFFFFFFC4DFLL * v65) >> 16;
    uint64_t v69 = v57 - v58 + (uint64_t)v66;
    uint64_t v70 = v67 + v55 - v56;
    uint64_t v71 = 9633 * (v70 + v69);
    uint64_t v72 = v71 - 3196 * v69;
    uint64_t v73 = v71 - 16069 * v70;
    uint64_t v74 = -7373 * (v67 + v66) + 0x8000;
    v52[8] = (unint64_t)(v74 + 12299 * v66 + v72) >> 16;
    uint64_t v75 = -20995 * (v57 - v58 + (uint64_t)(v55 - v56)) + 0x8000;
    v52[24] = (unint64_t)(v75 + 25172 * (v55 - v56) + v73) >> 16;
    v52[40] = (unint64_t)(v75 + 16819 * (v57 - v58) + v72) >> 16;
    v52[56] = (unint64_t)(v74 + 2446 * v67 + v73) >> 16;
    v51 += 4;
  }
  while (v51 != 32);
  return result;
}

uint64_t jpeg_fdct_14x7(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  *(_OWORD *)(result + 224) = 0u;
  *(_OWORD *)(result + 240) = 0u;
  do
  {
    uint64_t v4 = (unsigned __int8 *)(*(void *)(a2 + v3) + a3);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[13];
    uint64_t v7 = v4[1];
    uint64_t v8 = v4[12];
    uint64_t v9 = v4[2];
    uint64_t v10 = (v8 + v7);
    uint64_t v11 = v4[11];
    uint64_t v12 = (v11 + v9);
    uint64_t v13 = v4[3];
    uint64_t v14 = v4[5];
    uint64_t v15 = v4[8];
    uint64_t v16 = (v15 + v14);
    uint64_t v17 = v4[6];
    uint64_t v18 = v4[7];
    int v19 = v18 + v17 + v6 + v5;
    int v20 = v6 + v5 - (v18 + v17);
    int v21 = v16 + v10;
    uint64_t v22 = v10 - v16;
    uint64_t v23 = v4[10];
    uint64_t v24 = v5 - v6;
    LODWORD(v5) = v4[4];
    uint64_t v25 = v7 - v8;
    int v26 = v23 + v13;
    LODWORD(v4) = v4[9];
    uint64_t v27 = v9 - v11;
    uint64_t v28 = (v4 + v5);
    uint64_t v29 = v13 - v23;
    uint64_t v30 = v28 + v12;
    uint64_t v31 = v12 - v28;
    LODWORD(v4) = v5 - v4;
    uint64_t v32 = v14 - v15;
    uint64_t v33 = v17 - v18;
    uint64_t v34 = (2 * v26);
    LODWORD(v5) = v21 + v30 + v19;
    LODWORD(v15) = v19 - v34;
    uint64_t v35 = 0x7FFFFFFE3C9 * (v30 - v34) + 2578 * (v21 - (int)v34);
    uint64_t v36 = 9058 * (v20 + (int)v22) + 1024;
    uint64_t v37 = v36 + 5027 * (int)v31;
    uint64_t v38 = v35 + 10438 * (int)v15;
    uint64_t v39 = v36 + 0x7FFFFFFD3E1 * v31;
    unint64_t v40 = v37 + 2237 * v20;
    uint64_t v41 = 9810 * ((int)v27 + (int)v24) + 6164 * ((int)v33 + (int)v4);
    uint64_t v42 = 10935 * ((int)v25 + (int)v24) + 3826 * ((int)v32 - (int)v33);
    uint64_t v43 = 11512 * ((int)v32 - (int)v4) - (v29 << 13) - 1297 * ((int)v27 + (int)v25) + 1024;
    uint64_t v44 = (_DWORD *)(result + 4 * v3);
    v44[6] = (unint64_t)(v39 + 0x7FFFFFFC8FCLL * v22) >> 11;
    v44[7] = 4 * (v24 + v29 - v33 - (v27 + v25 + v32 - v4));
    v44[4] = (unint64_t)(v38 + 1024) >> 11;
    v44[5] = (unint64_t)(v43 + 0x7FFFFFFB409 * v27 + 9175 * (int)v4 + v41) >> 11;
    v44[2] = v40 >> 11;
    v44[3] = (unint64_t)(v43 + 0x7FFFFFFF26ELL * v25 + 0x7FFFFFF9DC4 * v32 + v42) >> 11;
    *uint64_t v44 = 4 * (v26 + v5) - 7168;
    v44[1] = (unint64_t)(v42 + (v29 << 13) + v33 + 0x7FFFFFFDBF0 * (v33 + v24) + v41 + 1024) >> 11;
    v3 += 8;
  }
  while (v3 != 56);
  uint64_t v45 = 0;
  do
  {
    uint64_t v46 = (_DWORD *)(result + v45);
    int v47 = *(_DWORD *)(result + v45);
    int v48 = *(_DWORD *)(result + v45 + 192);
    uint64_t v49 = v48 + v47;
    int v50 = *(_DWORD *)(result + v45 + 32);
    int v51 = *(_DWORD *)(result + v45 + 160);
    uint64_t v52 = v51 + v50;
    int v53 = *(_DWORD *)(result + v45 + 64);
    int v54 = *(_DWORD *)(result + v45 + 128);
    int v55 = v54 + v53;
    uint64_t v56 = v54 + v53;
    uint64_t v57 = *(int *)(result + v45 + 96);
    int v58 = v47 - v48;
    uint64_t v59 = v50 - v51;
    uint64_t v60 = v53 - v54;
    _DWORD *v46 = (unint64_t)(10700 * (v57 + v52 + v56 + v49) + 0x8000) >> 16;
    uint64_t v61 = 3783 * (v56 + v49 - 4 * v57);
    uint64_t v62 = 9850 * (v49 - v55);
    uint64_t v63 = 3367 * (v52 - v55);
    v46[16] = (unint64_t)(v63 + v62 + v61 + 0x8000) >> 16;
    uint64_t v64 = 9434 * (v49 - v52) + 0x8000;
    v46[32] = (unint64_t)(v64 + v63 + 0xFFFFFFFFE272 * (v52 - 2 * v57)) >> 16;
    v46[48] = (unint64_t)(v64 - v62 + v61) >> 16;
    uint64_t v65 = 10009 * (v59 + v58);
    uint64_t v66 = 1822 * (v58 - v59);
    uint64_t v67 = 6565 * (v60 + v58) + 0x8000;
    v46[8] = (unint64_t)(v67 - v66 + v65) >> 16;
    v46[24] = (unint64_t)(-14752 * (v60 + v59) + v66 + v65 + 0x8000) >> 16;
    v46[40] = (unint64_t)(v67 + 20017 * v60 - 14752 * (v60 + v59)) >> 16;
    v45 += 4;
  }
  while (v45 != 32);
  return result;
}

_OWORD *jpeg_fdct_12x6(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  do
  {
    uint64_t v4 = (unsigned __int8 *)(*(void *)(a2 + v3 * 4) + a3);
    uint64_t v5 = *v4;
    uint64_t v6 = v4[11];
    int v7 = v4[1];
    uint64_t v8 = v4[2];
    uint64_t v9 = v4[9];
    uint64_t v10 = (v9 + v8);
    int v11 = v4[3];
    int v12 = v4[8];
    uint64_t v13 = (v12 + v11);
    uint64_t v14 = v4[5];
    uint64_t v15 = v4[6];
    int v16 = v15 + v14 + v6 + v5;
    int v17 = v6 + v5 - (v15 + v14);
    int v18 = v13 + v10;
    uint64_t v19 = v10 - v13;
    int v20 = v4[10];
    uint64_t v21 = v5 - v6;
    uint64_t v22 = (v20 + v7);
    int v23 = v7 - v20;
    uint64_t v24 = v8 - v9;
    LODWORD(v6) = v4[4];
    LODWORD(v4) = v4[7];
    uint64_t v25 = (v4 + v6);
    LODWORD(v9) = v6 - v4;
    int v26 = &result[v3];
    uint64_t v27 = v14 - v15;
    uint64_t v28 = v22 - v25;
    LODWORD(v8) = 4 * (v18 + v22 + v25 + v16) - 6144;
    LODWORD(v25) = v17 - (v22 - v25 + v19);
    LODWORD(v15) = v16 - v18;
    uint64_t v29 = v28 - v19 + 11190 * (v17 + (int)v19);
    uint64_t v30 = 6270 * v23 + 4433 * ((int)v9 + v23);
    uint64_t v31 = -15137 * (int)v9 + 4433 * ((int)v9 + v23);
    LODWORD(v22) = v11 - v12 + v21;
    uint64_t v32 = 9191 * ((int)v24 + (int)v21) + 1024;
    *int v26 = v8;
    v26[1] = (unint64_t)(v32 + 0x7FFFFFFED6ALL * v21 + 7053 * (int)v22 + v30 + 1512 * (int)v27) >> 11;
    v26[2] = (unint64_t)(v29 + 1024) >> 11;
    v26[3] = (unint64_t)(v31 + 10703 * ((int)v21 - (v11 - v12)) + 0x7FFFFFFEEAFLL * (v27 + v24) + 1024) >> 11;
    int v33 = v11 - v12 + v24;
    v26[4] = (unint64_t)(10033 * (int)v15 + 1024) >> 11;
    v26[5] = (unint64_t)(v32 - 19165 * (int)v24 - 1512 * v33 - v31 + 7053 * (int)v27) >> 11;
    v26[6] = 4 * v25;
    v26[7] = (unint64_t)(5946 * (v11 - v12)
                              + 7053 * (int)v22
                              - 1512 * v33
                              - v30
                              + 0x7FFFFFFDC19 * v27
                              + 1024) >> 11;
    v3 += 2;
  }
  while (v3 != 12);
  uint64_t v34 = 0;
  do
  {
    uint64_t v35 = (_DWORD *)((char *)result + v34);
    int v36 = *(_DWORD *)((char *)result + v34);
    int v37 = *(_DWORD *)((char *)result + v34 + 160);
    int v38 = *(_DWORD *)((char *)result + v34 + 32);
    int v39 = *(_DWORD *)((char *)result + v34 + 128);
    int v40 = v39 + v38;
    int v41 = *(_DWORD *)((char *)result + v34 + 64);
    int v42 = *(_DWORD *)((char *)result + v34 + 96);
    uint64_t v43 = v42 + v41 + (uint64_t)(v37 + v36);
    uint64_t v44 = v37 + v36 - (uint64_t)(v42 + v41);
    uint64_t v45 = v36 - v37;
    uint64_t v46 = v38 - v39;
    uint64_t v47 = v41 - v42;
    *uint64_t v35 = (unint64_t)(14564 * (v43 + v40) + 0x8000) >> 16;
    v35[16] = (unint64_t)(17837 * v44 + 0x8000) >> 16;
    v35[32] = (unint64_t)(10298 * (v43 - 2 * v40) + 0x8000) >> 16;
    uint64_t v48 = 5331 * (v47 + v45) + 0x8000;
    v35[8] = (unint64_t)(v48 + 14564 * (v46 + v45)) >> 16;
    v35[24] = (unint64_t)(14564 * (v45 - (v46 + v47)) + 0x8000) >> 16;
    v35[40] = (unint64_t)(v48 + 14564 * (v47 - v46)) >> 16;
    v34 += 4;
  }
  while (v34 != 32);
  return result;
}

_OWORD *jpeg_fdct_10x5(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  do
  {
    uint64_t v4 = (unsigned __int8 *)(*(void *)(a2 + v3 * 4) + a3);
    int v5 = *v4;
    int v6 = v4[9];
    uint64_t v7 = v4[1];
    uint64_t v8 = v4[8];
    uint64_t v9 = (v8 + v7);
    uint64_t v10 = v4[3];
    uint64_t v11 = v4[6];
    uint64_t v12 = (v11 + v10);
    int v13 = v4[4];
    int v14 = v4[5];
    int v15 = v14 + v13 + v6 + v5;
    int v16 = v6 + v5 - (v14 + v13);
    uint64_t v17 = v12 + v9;
    uint64_t v18 = v9 - v12;
    int v19 = v5 - v6;
    uint64_t v20 = v4[2];
    uint64_t v21 = v4[7];
    uint64_t v22 = v7 - v8;
    LODWORD(v8) = v21 + v20;
    uint64_t v23 = v20 - v21;
    uint64_t v24 = &result[v3];
    uint64_t v25 = v10 - v11;
    LODWORD(v12) = v8 + v15 + v17;
    unint64_t v26 = (0x7FFFFFFF204 * (v17 - (unint64_t)(2 * v8)) + 9373 * (v15 - 2 * (int)v8) + 1024) >> 11;
    uint64_t v27 = 6810 * (v16 + (int)v18) + 1024;
    LODWORD(v8) = v13 - v14 + v19;
    v24[4] = v26;
    v24[5] = 4 * (v8 - (v22 - v25 + v23));
    *uint64_t v24 = 4 * v12 - 5120;
    v24[1] = (unint64_t)(10323 * (int)v22
                              + 11443 * v19
                              + (v23 << 13)
                              + 5260 * (int)v25
                              + 1812 * (v13 - v14)
                              + 1024) >> 11;
    uint64_t v28 = 2531 * ((int)v8 + (int)v22 - (int)v25) - (v23 << 13) + ((v22 - v25) << 12);
    uint64_t v29 = -4815 * ((int)v25 + (int)v22) + 7791 * (v19 - (v13 - v14)) + 1024;
    v24[2] = (unint64_t)(v27 + 4209 * v16) >> 11;
    void v24[3] = (unint64_t)(v29 + v28) >> 11;
    v24[6] = (unint64_t)(v27 + 0x7FFFFFFBA5CLL * v18) >> 11;
    v24[7] = (unint64_t)(v29 - v28) >> 11;
    v3 += 2;
  }
  while (v3 != 10);
  uint64_t v30 = 0;
  do
  {
    uint64_t v31 = (_DWORD *)((char *)result + v30);
    int v32 = *(_DWORD *)((char *)result + v30);
    int v33 = *(_DWORD *)((char *)result + v30 + 128);
    int v34 = *(_DWORD *)((char *)result + v30 + 32);
    int v35 = *(_DWORD *)((char *)result + v30 + 96);
    uint64_t v36 = v35 + v34;
    uint64_t v37 = *(int *)((char *)result + v30 + 64);
    uint64_t v38 = v36 + v33 + v32;
    uint64_t v39 = v33 + v32 - v36;
    int v40 = v32 - v33;
    uint64_t v41 = v34 - v35;
    _DWORD *v31 = (unint64_t)(10486 * (v38 + v37) + 0x4000) >> 15;
    uint64_t v42 = 3707 * (v38 - 4 * v37);
    uint64_t v43 = 8290 * v39 + 0x4000;
    v31[16] = (unint64_t)(v43 + v42) >> 15;
    v31[32] = (unint64_t)(v43 - v42) >> 15;
    uint64_t v44 = 8716 * (v41 + v40) + 0x4000;
    v31[8] = (unint64_t)(v44 + 5387 * v40) >> 15;
    unsigned char v31[24] = (unint64_t)(v44 + 0x7FFFFFFFA6DCLL * v41) >> 15;
    v30 += 4;
  }
  while (v30 != 32);
  return result;
}

_OWORD *jpeg_fdct_8x4(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  do
  {
    uint64_t v4 = &result[v3];
    int v5 = (unsigned __int8 *)(*(void *)(a2 + v3 * 4) + a3);
    int v6 = *v5;
    int v7 = v5[7];
    int v8 = v5[1];
    int v9 = v5[6];
    uint64_t v10 = (v9 + v8);
    int v11 = v5[2];
    int v12 = v5[5];
    uint64_t v13 = (v12 + v11);
    int v14 = v5[3];
    LODWORD(v5) = v5[4];
    int v15 = v5 + v14 + v7 + v6;
    int v16 = v7 + v6 - (v5 + v14);
    int v17 = v13 + v10;
    uint64_t v18 = v10 - v13;
    int v19 = v6 - v7;
    int v20 = v8 - v9;
    int v21 = v11 - v12;
    LODWORD(v5) = v14 - v5;
    uint64_t v22 = 4433 * (v16 + (int)v18) + 512;
    unint64_t v23 = (unint64_t)(v22 + 6270 * v16) >> 10;
    unint64_t v24 = (unint64_t)(v22 + 0x3FFFFFFC4DFLL * v18) >> 10;
    uint64_t v25 = 9633 * ((int)v5 + v20 + v21 + v19) + 512;
    uint64_t v26 = v25 - 3196 * (v21 + v19);
    uint64_t v27 = v25 - 16069 * ((int)v5 + v20);
    _DWORD *v4 = 8 * (v15 + v17) - 0x2000;
    v4[1] = (unint64_t)(12299 * v19 - 7373 * ((int)v5 + v19) + v26) >> 10;
    v4[2] = v23;
    v4[3] = (unint64_t)(25172 * v20 - 20995 * (v21 + v20) + v27) >> 10;
    v4[4] = 8 * (v15 - v17);
    v4[5] = (unint64_t)(16819 * v21 - 20995 * (v21 + v20) + v26) >> 10;
    v4[6] = v24;
    v4[7] = (unint64_t)(2446 * (int)v5 - 7373 * ((int)v5 + v19) + v27) >> 10;
    v3 += 2;
  }
  while (v3 != 8);
  uint64_t v28 = 0;
  int64x2_t v29 = vdupq_n_s64(2uLL);
  int64x2_t v30 = vdupq_n_s64(0x4000uLL);
  int32x4_t v31 = vdupq_n_s32(0x187Eu);
  do
  {
    int v32 = &result[v28];
    int32x4_t v33 = (int32x4_t)result[v28];
    int32x4_t v34 = (int32x4_t)result[v28 + 6];
    int32x4_t v35 = vaddq_s32(v34, v33);
    int64x2_t v36 = vaddw_s32(v29, *(int32x2_t *)v35.i8);
    int32x4_t v37 = (int32x4_t)result[v28 + 2];
    int64x2_t v38 = vaddw_high_s32(v29, v35);
    int32x4_t v39 = (int32x4_t)result[v28 + 4];
    int32x4_t v40 = vaddq_s32(v39, v37);
    int32x4_t v41 = vsubq_s32(v33, v34);
    int32x4_t v42 = vsubq_s32(v37, v39);
    v43.i64[0] = v42.i32[2];
    v43.i64[1] = v42.i32[3];
    int64x2_t v44 = v43;
    v43.i64[0] = v42.i32[0];
    v43.i64[1] = v42.i32[1];
    int64x2_t v45 = vaddw_high_s32(v38, v40);
    int32x2_t v46 = vshrn_n_s64(vaddw_s32(v36, *(int32x2_t *)v40.i8), 2uLL);
    int64x2_t v47 = (int64x2_t)vshrn_high_n_s64(vshrn_n_s64(vsubw_s32(v36, *(int32x2_t *)v40.i8), 2uLL), vsubw_high_s32(v38, v40), 2uLL);
    int64x2_t v48 = vaddl_high_s32(v42, v41);
    *int v32 = vshrn_high_n_s64(v46, v45, 2uLL);
    v48.i64[0] *= 4433;
    v48.i64[1] *= 4433;
    int64x2_t v49 = vaddl_s32(*(int32x2_t *)v42.i8, *(int32x2_t *)v41.i8);
    v32[4] = v47;
    v49.i64[0] *= 4433;
    v49.i64[1] *= 4433;
    v47.i64[0] = 0x7FFFFFFFC4DFLL * v43.i64[0];
    v47.i64[1] = 0x7FFFFFFFC4DFLL * v43.i64[1];
    int64x2_t v50 = vaddq_s64(v49, v30);
    int64x2_t v51 = vaddq_s64(v48, v30);
    v44.i64[0] *= 0x7FFFFFFFC4DFLL;
    v44.i64[1] *= 0x7FFFFFFFC4DFLL;
    v32[2] = vshrn_high_n_s64(vshrn_n_s64(vmlal_s32(v50, *(int32x2_t *)v41.i8, *(int32x2_t *)v31.i8), 0xFuLL), vmlal_high_s32(v51, v41, v31), 0xFuLL);
    v32[6] = vshrn_high_n_s64(vshrn_n_s64(vaddq_s64(v50, v47), 0xFuLL), vaddq_s64(v51, v44), 0xFuLL);
    ++v28;
  }
  while (v28 != 2);
  return result;
}

_OWORD *jpeg_fdct_6x3(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  uint64_t v4 = a3;
  result[2] = 0u;
  result[3] = 0u;
  *uint64_t result = 0u;
  result[1] = 0u;
  do
  {
    int v5 = (int *)&result[v3];
    int v6 = (unsigned __int8 *)(*(void *)(a2 + v3 * 4) + v4);
    int v7 = *v6;
    int v8 = v6[5];
    int v9 = v6[1];
    int v10 = v6[4];
    int v11 = v10 + v9;
    int v12 = v6[2];
    LODWORD(v6) = v6[3];
    int v13 = v6 + v12 + v8 + v7;
    int v14 = v8 + v7 - (v6 + v12);
    int v15 = v7 - v8;
    int v16 = v9 - v10;
    LODWORD(v6) = v12 - v6;
    int v17 = 8 * (v13 + v10 + v9) - 6144;
    unint64_t v18 = (unint64_t)(5793 * (v13 - 2 * v11) + 512) >> 10;
    unint64_t v19 = (unint64_t)(2998 * ((int)v6 + v15) + 512) >> 10;
    *int v5 = v17;
    v5[1] = v19 + 8 * (v16 + v15);
    void v5[2] = (10033 * v14 + 512) >> 10;
    v5[3] = 8 * (v15 - (v16 + v6));
    v5[4] = v18;
    v5[5] = v19 + 8 * (v6 - v16);
    v3 += 2;
  }
  while (v3 != 6);
  uint64_t v20 = 0;
  do
  {
    int v21 = (_DWORD *)((char *)result + v20);
    int v22 = *(_DWORD *)((char *)result + v20);
    int v23 = *(_DWORD *)((char *)result + v20 + 64);
    uint64_t v24 = v23 + v22;
    uint64_t v25 = *(int *)((char *)result + v20 + 32);
    *int v21 = (unint64_t)(14564 * (v25 + v24) + 0x4000) >> 15;
    v21[16] = (unint64_t)(10298 * (v24 - 2 * v25) + 0x4000) >> 15;
    v21[8] = (unint64_t)(17837 * (v22 - v23) + 0x4000) >> 15;
    v20 += 4;
  }
  while (v20 != 24);
  return result;
}

double jpeg_fdct_4x2(uint64_t a1, void *a2, unsigned int a3)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v4 = (unsigned __int8 *)(*a2 + a3);
  int v5 = *v4;
  int v6 = v4[3];
  int v7 = v4[1];
  LODWORD(v4) = v4[2];
  int v8 = v4 + v7 + v6 + v5;
  int v9 = v6 + v5 - (v4 + v7);
  int v10 = v5 - v6;
  LODWORD(v4) = v7 - v4;
  uint64_t v11 = 4433 * ((int)v4 + v10) + 512;
  uint64_t v12 = v11 + 6270 * v10;
  uint64_t v13 = v11 - 15137 * (int)v4;
  int v14 = (unsigned __int8 *)(a2[1] + a3);
  LODWORD(v11) = *v14;
  int v15 = v14[3];
  int v16 = v14[1];
  LODWORD(v14) = v14[2];
  int v17 = v14 + v16 + v15 + v11;
  int v18 = v15 + v11 - (v14 + v16);
  LODWORD(v11) = v11 - v15;
  LODWORD(v14) = v16 - v14;
  int v19 = v14 + v11;
  uint64_t v20 = 6270 * (int)v11 + 4433 * ((int)v14 + (int)v11);
  uint64_t v21 = -15137 * (int)v14 + 4433 * v19;
  *(_DWORD *)a1 = 8 * (v17 + v8) - 0x2000;
  *(_DWORD *)(a1 + 4) = (unint64_t)(v20 + v12) >> 10;
  *(_DWORD *)(a1 + 32) = 8 * (v8 - v17);
  *(_DWORD *)(a1 + 36) = (unint64_t)(v12 - v20) >> 10;
  *(_DWORD *)(a1 + 8) = 8 * (v18 + v9);
  *(_DWORD *)(a1 + 12) = (unint64_t)(v21 + v13) >> 10;
  *(_DWORD *)(a1 + 40) = 8 * (v9 - v18);
  *(_DWORD *)(a1 + 44) = (unint64_t)(v13 - v21) >> 10;
  return result;
}

double jpeg_fdct_2x1(uint64_t a1, void *a2, unsigned int a3)
{
  double result = 0.0;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v4 = (unsigned __int8 *)(*a2 + a3);
  int v5 = *v4;
  LODWORD(v4) = v4[1];
  *(_DWORD *)a1 = 32 * (v4 + v5) - 0x2000;
  *(_DWORD *)(a1 + 4) = 32 * (v5 - v4);
  return result;
}

uint64_t jpeg_fdct_8x16(_DWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = a1;
  uint64_t v4 = 0;
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  memset(v68, 0, sizeof(v68));
  while (1)
  {
    int v5 = (unsigned __int8 *)(*(void *)(a2 + 8 * v4) + a3);
    int v6 = *v5;
    int v7 = v5[7];
    int v8 = v5[1];
    int v9 = v5[6];
    uint64_t v10 = (v9 + v8);
    int v11 = v5[2];
    int v12 = v5[5];
    uint64_t v13 = (v12 + v11);
    int v14 = v5[3];
    LODWORD(v5) = v5[4];
    int v15 = v5 + v14 + v7 + v6;
    int v16 = v7 + v6 - (v5 + v14);
    int v17 = v13 + v10;
    uint64_t v18 = v10 - v13;
    int v19 = v6 - v7;
    int v20 = v8 - v9;
    int v21 = v11 - v12;
    LODWORD(v5) = v14 - v5;
    uint64_t v22 = 4433 * (v16 + (int)v18) + 1024;
    unint64_t v23 = (unint64_t)(v22 + 6270 * v16) >> 11;
    unint64_t v24 = (unint64_t)(v22 + 0x7FFFFFFC4DFLL * v18) >> 11;
    LODWORD(v13) = v5 + v20 + v21 + v19;
    uint64_t v25 = -3196 * (v21 + v19) + 9633 * (int)v13;
    uint64_t v26 = -16069 * ((int)v5 + v20) + 9633 * (int)v13;
    uint64_t v27 = -20995 * (v21 + v20);
    uint64_t v28 = -7373 * ((int)v5 + v19) + 1024;
    *uint64_t v3 = 4 * (v15 + v17) - 4096;
    v3[1] = (unint64_t)(v28 + 12299 * v19 + v25) >> 11;
    v3[2] = v23;
    v3[3] = (unint64_t)(v27 + 1024 + 25172 * v20 + v26) >> 11;
    v3[4] = 4 * (v15 - v17);
    v3[5] = (unint64_t)(v27 + 1024 + 16819 * v21 + v25) >> 11;
    v3[6] = v24;
    v3[7] = (unint64_t)(v28 + 2446 * (int)v5 + v26) >> 11;
    if (v4 != 7) {
      break;
    }
    uint64_t v3 = v68;
LABEL_6:
    ++v4;
  }
  if (v4 != 15)
  {
    v3 += 8;
    goto LABEL_6;
  }
  uint64_t v29 = 0;
  do
  {
    int64x2_t v30 = &a1[v29];
    int v31 = a1[v29];
    int v32 = *(_DWORD *)((char *)&v68[14] + v29 * 4);
    int v33 = a1[v29 + 8];
    int v34 = *(_DWORD *)((char *)&v68[12] + v29 * 4);
    int v35 = a1[v29 + 16];
    int v36 = *(_DWORD *)((char *)&v68[10] + v29 * 4);
    int v37 = a1[v29 + 24];
    int v38 = *(_DWORD *)((char *)&v68[8] + v29 * 4);
    int v39 = a1[v29 + 32];
    int v40 = a1[v29 + 40];
    int v41 = *(_DWORD *)((char *)&v68[4] + v29 * 4);
    int v42 = a1[v29 + 48];
    int v43 = *(_DWORD *)((char *)&v68[2] + v29 * 4);
    int v44 = a1[v29 + 56];
    int v45 = *(_DWORD *)((char *)v68 + v29 * 4);
    uint64_t v46 = v45 + v44 + (uint64_t)(v32 + v31);
    uint64_t v47 = v32 + v31 - (uint64_t)(v45 + v44);
    uint64_t v48 = v43 + v42 + (uint64_t)(v34 + v33);
    int v49 = *(_DWORD *)((char *)&v68[6] + v29 * 4);
    uint64_t v50 = v34 + v33 - (uint64_t)(v43 + v42);
    uint64_t v51 = v41 + v40 + (uint64_t)(v36 + v35);
    uint64_t v52 = v36 + v35 - (uint64_t)(v41 + v40);
    uint64_t v53 = v49 + v39 + (uint64_t)(v38 + v37);
    uint64_t v54 = v38 + v37 - (uint64_t)(v49 + v39);
    int v55 = v31 - v32;
    int v56 = v33 - v34;
    int v57 = v35 - v36;
    int v58 = v39 - v49;
    *int64x2_t v30 = (unint64_t)(v53 + v51 + v48 + v46 + 4) >> 3;
    v30[32] = (unint64_t)(10703 * (v46 - v53) + 4433 * (v48 - v51) + 0x8000) >> 16;
    uint64_t v59 = 2260 * (v54 - v50) + 11363 * (v47 - v52) + 0x8000;
    v30[16] = (unint64_t)(v59 + 17799 * v52 + 11893 * v50) >> 16;
    uint64_t v60 = v42 - v43;
    v30[48] = (unint64_t)(v59 + 0xFFFFFFFFDE07 * v54 + 0xFFFFFFFFF93ELL * v47) >> 16;
    uint64_t v61 = 11086 * (v33 - v34 + (uint64_t)v55) + 3363 * (v60 - (v44 - v45));
    uint64_t v62 = 10217 * (v57 + (uint64_t)v55) + 5461 * (v44 - v45 + (uint64_t)(v40 - v41));
    uint64_t v63 = 8956 * (v37 - v38 + (uint64_t)v55) + 7350 * (v58 - (uint64_t)(v44 - v45));
    uint64_t result = 1136 * (v57 + (uint64_t)v56) + 11529 * (v60 - (v40 - v41));
    uint64_t v65 = -5461 * (v37 - v38 + (uint64_t)v56) - 10217 * (v60 + v58);
    uint64_t v66 = -11086 * (v37 - v38 + (uint64_t)v57) + 3363 * (v40 - v41 - (uint64_t)v58);
    v30[8] = (unint64_t)(v62 + 0xFFFFFFFFB6D6 * v55 + 6387 * (v44 - v45) + v61 + v63 + 0x8000) >> 16;
    v30[24] = (unint64_t)(v65 + 589 * v56 + 0xFFFFFFFFCAC1 * v60 + result + v61 + 0x8000) >> 16;
    v30[40] = (unint64_t)(v66 + 0x8000 - 9222 * v57 + 10055 * (v40 - v41) + result + v62) >> 16;
    v30[56] = (unint64_t)(v66 + 0x8000 + 8728 * (v37 - v38) + 17760 * v58 + v65 + v63) >> 16;
    ++v29;
  }
  while ((v29 * 4) != 32);
  return result;
}

_OWORD *jpeg_fdct_7x14(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  memset(v68, 0, sizeof(v68));
  *uint64_t result = 0u;
  result[1] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  uint64_t v4 = result;
  result[14] = 0u;
  result[15] = 0u;
  while (1)
  {
    int v5 = (unsigned __int8 *)(*(void *)(a2 + 8 * v3) + a3);
    int v6 = *v5;
    int v7 = v5[6];
    int v8 = v7 + v6;
    int v9 = v5[1];
    int v10 = v5[5];
    uint64_t v11 = (v10 + v9);
    int v12 = v5[2];
    int v13 = v5[4];
    int v14 = v13 + v12;
    unsigned int v15 = v5[3];
    int v16 = v6 - v7;
    int v17 = v9 - v10;
    LODWORD(v5) = v12 - v13;
    int v18 = v13 + v12 + v8;
    int v19 = 4 * (v15 + v11 + v18) - 3584;
    int v20 = v18 - 4 * v15;
    int v21 = v8 - (v13 + v12);
    int v22 = v11 - v14;
    unint64_t v23 = (unint64_t)(7542 * v21 + 2578 * ((int)v11 - v14) + 2896 * v20 + 1024) >> 11;
    uint64_t v24 = 7223 * (v8 - (int)v11) + 1024;
    unint64_t v25 = (v24 + 2578 * v22 + 0x7FFFFFFE95FLL * (v11 - 2 * (unint64_t)v15)) >> 11;
    v4[6] = (unint64_t)(v24 - 7542 * v21 + 2896 * v20) >> 11;
    LODWORD(v24) = v17 + v16;
    uint64_t v26 = 1395 * (v16 - v17);
    int v27 = v5 + v17;
    uint64_t v28 = 5027 * ((int)v5 + v16) + 1024;
    _DWORD *v4 = v19;
    v4[1] = (unint64_t)(v28 - v26 + 7663 * (int)v24) >> 11;
    v4[2] = v23;
    v4[3] = (unint64_t)(v26 - 11295 * v27 + 7663 * (int)v24 + 1024) >> 11;
    v4[4] = v25;
    v4[5] = (unint64_t)(v28 + 15326 * (int)v5 - 11295 * v27) >> 11;
    if (v3 != 7) {
      break;
    }
    uint64_t v4 = v68;
LABEL_6:
    ++v3;
  }
  if (v3 != 13)
  {
    v4 += 8;
    goto LABEL_6;
  }
  uint64_t v29 = 0;
  do
  {
    int64x2_t v30 = (_DWORD *)((char *)result + v29);
    int v31 = *(_DWORD *)((char *)result + v29);
    int v32 = *(_DWORD *)((char *)&v68[10] + v29);
    int v33 = *(_DWORD *)((char *)result + v29 + 32);
    int v34 = *(_DWORD *)((char *)&v68[8] + v29);
    int v35 = *(_DWORD *)((char *)result + v29 + 64);
    int v36 = *(_DWORD *)((char *)&v68[6] + v29);
    int v37 = *(_DWORD *)((char *)result + v29 + 96);
    int v38 = *(_DWORD *)((char *)&v68[4] + v29);
    int v39 = *(_DWORD *)((char *)result + v29 + 160);
    int v40 = *(_DWORD *)((char *)v68 + v29);
    int v41 = v36 + v35;
    int v42 = *(_DWORD *)((char *)result + v29 + 192);
    int v43 = *(_DWORD *)((char *)result + v29 + 224);
    uint64_t v44 = v43 + v42 + (uint64_t)(v32 + v31);
    uint64_t v45 = v32 + v31 - (uint64_t)(v43 + v42);
    int v46 = v31 - v32;
    uint64_t v47 = v40 + v39 + (uint64_t)(v34 + v33);
    uint64_t v48 = v34 + v33;
    int v49 = v33 - v34;
    int v50 = v38 + v37;
    int v51 = v35 - v36;
    int v52 = *(_DWORD *)((char *)result + v29 + 128);
    int v53 = *(_DWORD *)((char *)&v68[2] + v29);
    uint64_t v54 = v48 - (v40 + v39);
    LODWORD(v48) = v37 - v38;
    uint64_t v55 = v53 + v52 + (uint64_t)v41;
    uint64_t v56 = v41 - (uint64_t)(v53 + v52);
    int v57 = v52 - v53;
    int v58 = v39 - v40;
    *int64x2_t v30 = (unint64_t)(5350 * (v55 + v50 + v47 + v44) + 0x4000) >> 15;
    uint64_t v59 = 5915 * (v45 + v54) + 0x4000;
    v30[16] = (unint64_t)(v59 + 3283 * v56 + 1461 * v45) >> 15;
    unint64_t v60 = (unint64_t)(v59 + 0x7FFFFFFFE330 * v56 + 0x7FFFFFFFDC12 * v54) >> 15;
    uint64_t v61 = v51 + (uint64_t)v49;
    v30[48] = v60;
    uint64_t v62 = v58 - (uint64_t)v57;
    v30[56] = (unint64_t)(5350 * (v46 + (uint64_t)(int)v48 - (v61 + v62 + v42 - v43)) + 0x4000) >> 15;
    uint64_t v63 = 7518 * v62 - 5350 * (int)v48 - 847 * v61 + 0x4000;
    uint64_t v64 = v63 + 0x7FFFFFFFCE64 * v51;
    v30[32] = (unint64_t)(1684 * (v47 - 2 * v50)
                               + 0x7FFFFFFFED93 * (v55 - 2 * v50)
                               + 6817 * (v44 - 2 * v50)
                               + 0x4000) >> 15;
    uint64_t v65 = v63 + 0x7FFFFFFFF723 * v49;
    uint64_t v66 = 7141 * (v49 + (uint64_t)v46) + 2499 * (v58 - (uint64_t)(v42 - v43));
    uint64_t v67 = 6406 * (v51 + (uint64_t)v46) + 4025 * (v42 - v43 + (uint64_t)v57);
    v30[40] = (unint64_t)(v64 + 5992 * v57 + v67) >> 15;
    v30[24] = (unint64_t)(v65 + 0x7FFFFFFFBFD9 * v58 + v66) >> 15;
    v30[8] = (unint64_t)(v66
                              + 0x7FFFFFFFE873 * v46
                              + 5350 * (int)v48
                              + 0x7FFFFFFFFD59 * (v42 - v43)
                              + v67
                              + 0x4000) >> 15;
    v29 += 4;
  }
  while (v29 != 28);
  return result;
}

int *jpeg_fdct_6x12(int *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  memset(v54, 0, sizeof(v54));
  *(_OWORD *)uint64_t result = 0u;
  *((_OWORD *)result + 1) = 0u;
  *((_OWORD *)result + 2) = 0u;
  *((_OWORD *)result + 3) = 0u;
  *((_OWORD *)result + 4) = 0u;
  *((_OWORD *)result + 5) = 0u;
  *((_OWORD *)result + 6) = 0u;
  *((_OWORD *)result + 7) = 0u;
  *((_OWORD *)result + 8) = 0u;
  *((_OWORD *)result + 9) = 0u;
  *((_OWORD *)result + 10) = 0u;
  *((_OWORD *)result + 11) = 0u;
  uint64_t v4 = a3;
  *((_OWORD *)result + 12) = 0u;
  *((_OWORD *)result + 13) = 0u;
  int v5 = result;
  *((_OWORD *)result + 14) = 0u;
  *((_OWORD *)result + 15) = 0u;
  while (1)
  {
    int v6 = (unsigned __int8 *)(*(void *)(a2 + 8 * v3) + v4);
    int v7 = *v6;
    int v8 = v6[5];
    int v9 = v6[1];
    int v10 = v6[4];
    int v11 = v10 + v9;
    int v12 = v6[2];
    LODWORD(v6) = v6[3];
    int v13 = v6 + v12 + v8 + v7;
    int v14 = v8 + v7 - (v6 + v12);
    int v15 = v7 - v8;
    int v16 = v9 - v10;
    LODWORD(v6) = v12 - v6;
    int v17 = 4 * (v13 + v10 + v9) - 3072;
    unint64_t v18 = (unint64_t)(5793 * (v13 - 2 * v11) + 1024) >> 11;
    unint64_t v19 = (unint64_t)(2998 * ((int)v6 + v15) + 1024) >> 11;
    *int v5 = v17;
    v5[1] = v19 + 4 * (v16 + v15);
    void v5[2] = (10033 * v14 + 1024) >> 11;
    v5[3] = 4 * (v15 - (v16 + v6));
    v5[4] = v18;
    v5[5] = v19 + 4 * (v6 - v16);
    if (v3 != 7) {
      break;
    }
    int v5 = (int *)v54;
LABEL_6:
    ++v3;
  }
  if (v3 != 11)
  {
    v5 += 8;
    goto LABEL_6;
  }
  uint64_t v20 = 0;
  do
  {
    int v21 = &result[v20];
    int v22 = result[v20];
    int v23 = *(_DWORD *)((char *)&v54[6] + v20 * 4);
    int v24 = result[v20 + 16];
    int v25 = *(_DWORD *)((char *)&v54[2] + v20 * 4);
    int v26 = result[v20 + 24];
    int v27 = *(_DWORD *)((char *)v54 + v20 * 4);
    int v28 = result[v20 + 40];
    int v29 = result[v20 + 48];
    uint64_t v30 = v29 + v28 + (uint64_t)(v23 + v22);
    uint64_t v31 = v23 + v22 - (uint64_t)(v29 + v28);
    uint64_t v32 = v27 + v26 + (uint64_t)(v25 + v24);
    uint64_t v33 = v25 + v24 - (uint64_t)(v27 + v26);
    int v34 = result[v20 + 8];
    int v35 = *(_DWORD *)((char *)&v54[4] + v20 * 4);
    int v36 = v22 - v23;
    int v37 = v35 + v34;
    int v38 = v34 - v35;
    int v39 = result[v20 + 32];
    int v40 = v24 - v25;
    int v41 = result[v20 + 56];
    int v42 = v26 - v27;
    int v43 = v41 + v39;
    int v44 = v39 - v41;
    int v45 = v28 - v29;
    uint64_t v46 = v37 - (uint64_t)v43;
    *int v21 = (unint64_t)(7282 * (v32 + v37 + v43 + v30) + 0x4000) >> 15;
    v21[48] = (unint64_t)(7282 * (v31 - (v46 + v33)) + 0x4000) >> 15;
    uint64_t v47 = v36;
    v21[32] = (unint64_t)(8918 * (v30 - v32) + 0x4000) >> 15;
    v21[16] = (unint64_t)(9947 * (v31 + v33) + 7282 * (v46 - v33) + 0x4000) >> 15;
    uint64_t v48 = 3941 * (v44 + (uint64_t)v38);
    uint64_t v49 = v48 + 5573 * v38;
    uint64_t v50 = v48 - 13455 * v44;
    uint64_t v51 = v40 + (uint64_t)v36;
    uint64_t v52 = 6269 * (v42 + (uint64_t)v36);
    uint64_t v53 = 8170 * v51 + 0x4000;
    v21[8] = (unint64_t)(v53 + 0x7FFFFFFFEF7BLL * v47 + v52 + v49 + 1344 * v45) >> 15;
    v21[24] = (unint64_t)(v50 + 9514 * (v47 - v42) + 0x7FFFFFFFF09BLL * (v45 + (uint64_t)v40) + 0x4000) >> 15;
    v21[40] = (unint64_t)(v53 - 17036 * v40 - 1344 * (v42 + (uint64_t)v40) - v50 + 6269 * v45) >> 15;
    v21[56] = (unint64_t)(v52 + 5285 * v42 - 1344 * (v42 + (uint64_t)v40) - v49 + 0x7FFFFFFFE016 * v45 + 0x4000) >> 15;
    ++v20;
  }
  while ((v20 * 4) != 24);
  return result;
}

_OWORD *jpeg_fdct_5x10(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  memset(v44, 0, sizeof(v44));
  *uint64_t result = 0u;
  result[1] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  uint64_t v4 = a3;
  result[12] = 0u;
  result[13] = 0u;
  int v5 = result;
  result[14] = 0u;
  result[15] = 0u;
  while (1)
  {
    int v6 = (unsigned __int8 *)(*(void *)(a2 + 8 * v3) + v4);
    int v7 = *v6;
    int v8 = v6[4];
    int v9 = v8 + v7;
    uint64_t v10 = v6[1];
    uint64_t v11 = v6[3];
    int v12 = v11 + v10;
    LODWORD(v6) = v6[2];
    int v13 = v7 - v8;
    uint64_t v14 = v10 - v11;
    LODWORD(v10) = 4 * (v11 + v10 + v9 + v6) - 2560;
    LODWORD(v6) = v12 + v9 - 4 * v6;
    uint64_t v15 = 6476 * (v9 - v12) + 1024;
    unint64_t v16 = (unint64_t)(v15 + 2896 * (int)v6) >> 11;
    v5[4] = (unint64_t)(v15 - 2896 * (int)v6) >> 11;
    uint64_t v17 = 6810 * ((int)v14 + v13) + 1024;
    *int v5 = v10;
    v5[1] = (unint64_t)(v17 + 4209 * v13) >> 11;
    void v5[2] = v16;
    v5[3] = (unint64_t)(v17 + 0x7FFFFFFBA5CLL * v14) >> 11;
    if (v3 != 7) {
      break;
    }
    int v5 = v44;
LABEL_6:
    ++v3;
  }
  if (v3 != 9)
  {
    v5 += 8;
    goto LABEL_6;
  }
  uint64_t v18 = 0;
  do
  {
    unint64_t v19 = (_DWORD *)((char *)result + v18);
    int v20 = *(_DWORD *)((char *)result + v18);
    int v21 = *(_DWORD *)((char *)&v44[2] + v18);
    int v22 = *(_DWORD *)((char *)result + v18 + 32);
    int v23 = *(_DWORD *)((char *)v44 + v18);
    int v24 = *(_DWORD *)((char *)result + v18 + 96);
    int v25 = *(_DWORD *)((char *)result + v18 + 192);
    int v26 = *(_DWORD *)((char *)result + v18 + 128);
    int v27 = *(_DWORD *)((char *)result + v18 + 160);
    uint64_t v28 = v27 + v26 + (uint64_t)(v21 + v20);
    uint64_t v29 = v21 + v20 - (uint64_t)(v27 + v26);
    uint64_t v30 = v25 + v24 + (uint64_t)(v23 + v22);
    uint64_t v31 = v23 + v22 - (uint64_t)(v25 + v24);
    int v32 = *(_DWORD *)((char *)result + v18 + 64);
    int v33 = v20 - v21;
    int v34 = *(_DWORD *)((char *)result + v18 + 224);
    int v35 = v22 - v23;
    int v36 = v34 + v32;
    int v37 = v32 - v34;
    int v38 = v26 - v27;
    *unint64_t v19 = (unint64_t)(10486 * (v30 + v36 + v28) + 0x4000) >> 15;
    v19[32] = (unint64_t)(11997 * (v28 - 2 * v36) + 0x7FFFFFFFEE1ALL * (v30 - 2 * v36) + 0x4000) >> 15;
    uint64_t v39 = 8716 * (v29 + v31) + 0x4000;
    _OWORD v19[16] = (unint64_t)(v39 + 5387 * v29) >> 15;
    v19[48] = (unint64_t)(v39 + 0x7FFFFFFFA6DCLL * v31) >> 15;
    uint64_t v40 = v38 + (uint64_t)v33;
    uint64_t v41 = v35 - (uint64_t)(v24 - v25);
    v19[40] = (unint64_t)(10486 * (v40 - (v41 + v37)) + 0x4000) >> 15;
    v19[8] = (unint64_t)(13213 * v35
                              + 14647 * v33
                              + 10486 * v37
                              + 6732 * (v24 - v25)
                              + 2320 * v38
                              + 0x4000) >> 15;
    uint64_t v42 = 5243 * v41 - 10486 * v37 + 3240 * (v40 + v41);
    uint64_t v43 = -6163 * (v24 - v25 + (uint64_t)v35) + 9973 * (v33 - (uint64_t)v38) + 0x4000;
    v19[24] = (unint64_t)(v43 + v42) >> 15;
    v19[56] = (unint64_t)(v43 - v42) >> 15;
    v18 += 4;
  }
  while (v18 != 20);
  return result;
}

_OWORD *jpeg_fdct_4x8(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  uint64_t v4 = a3;
  *uint64_t result = 0u;
  result[1] = 0u;
  do
  {
    int v5 = &result[v3];
    int v6 = (unsigned __int8 *)(*(void *)(a2 + v3 * 4) + v4);
    int v7 = *v6;
    int v8 = v6[3];
    int v9 = v8 + v7;
    uint64_t v10 = v6[1];
    uint64_t v11 = v6[2];
    int v12 = v11 + v10;
    int v13 = v7 - v8;
    uint64_t v14 = v10 - v11;
    uint64_t v15 = 4433 * ((int)v14 + v13) + 512;
    *int v5 = 8 * (v12 + v9) - 4096;
    v5[1] = (unint64_t)(v15 + 6270 * v13) >> 10;
    void v5[2] = 8 * (v9 - v12);
    v5[3] = (unint64_t)(v15 + 0x3FFFFFFC4DFLL * v14) >> 10;
    v3 += 2;
  }
  while (v3 != 16);
  uint64_t v16 = 0;
  do
  {
    uint64_t v17 = (_DWORD *)((char *)result + v16);
    int v18 = *(_DWORD *)((char *)result + v16);
    int v19 = *(_DWORD *)((char *)result + v16 + 224);
    uint64_t v20 = v19 + v18;
    int v21 = *(_DWORD *)((char *)result + v16 + 32);
    int v22 = *(_DWORD *)((char *)result + v16 + 192);
    int v23 = *(_DWORD *)((char *)result + v16 + 64);
    int v24 = *(_DWORD *)((char *)result + v16 + 160);
    uint64_t v25 = v24 + v23;
    int v26 = *(_DWORD *)((char *)result + v16 + 96);
    int v27 = *(_DWORD *)((char *)result + v16 + 128);
    uint64_t v28 = v20 + v27 + v26 + 2;
    uint64_t v29 = v20 - (v27 + v26);
    uint64_t v30 = v25 + v22 + v21;
    uint64_t v31 = v22 + v21 - v25;
    int v32 = v18 - v19;
    int v33 = v21 - v22;
    int v34 = v23 - v24;
    uint64_t v35 = v26 - v27;
    *uint64_t v17 = (unint64_t)(v28 + v30) >> 2;
    v17[32] = (unint64_t)(v28 - v30) >> 2;
    uint64_t v36 = 4433 * (v29 + v31) + 0x4000;
    v17[16] = (unint64_t)(v36 + 6270 * v29) >> 15;
    v17[48] = (unint64_t)(v36 + 0x7FFFFFFFC4DFLL * v31) >> 15;
    uint64_t v37 = v34 + (uint64_t)v32;
    uint64_t v38 = v35 + v33;
    uint64_t v39 = 9633 * (v38 + v37) + 0x4000;
    uint64_t v40 = v39 - 3196 * v37;
    uint64_t v41 = v39 - 16069 * v38;
    uint64_t v42 = -7373 * (v35 + v32);
    uint64_t v43 = -20995 * (v34 + (uint64_t)v33);
    v17[8] = (unint64_t)(v42 + 12299 * v32 + v40) >> 15;
    v17[24] = (unint64_t)(v43 + 25172 * v33 + v41) >> 15;
    v17[40] = (unint64_t)(v43 + 16819 * v34 + v40) >> 15;
    v17[56] = (unint64_t)(v42 + 2446 * v35 + v41) >> 15;
    v16 += 4;
  }
  while (v16 != 16);
  return result;
}

_OWORD *jpeg_fdct_3x6(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  *uint64_t result = 0u;
  result[1] = 0u;
  do
  {
    uint64_t v4 = &result[v3];
    int v5 = (unsigned __int8 *)(*(void *)(a2 + v3 * 4) + a3);
    int v6 = *v5;
    int v7 = v5[2];
    LODWORD(v5) = v5[1];
    v4[2] = (5793 * (v7 + v6 - 2 * (int)v5) + 512) >> 10;
    _DWORD *v4 = 8 * (v7 + v6 + v5) - 3072;
    v4[1] = (10033 * (v6 - v7) + 512) >> 10;
    v3 += 2;
  }
  while (v3 != 12);
  uint64_t v8 = 0;
  do
  {
    int v9 = (_DWORD *)((char *)result + v8);
    int v10 = *(_DWORD *)((char *)result + v8);
    int v11 = *(_DWORD *)((char *)result + v8 + 160);
    int v12 = *(_DWORD *)((char *)result + v8 + 32);
    int v13 = *(_DWORD *)((char *)result + v8 + 128);
    int v14 = v13 + v12;
    int v15 = *(_DWORD *)((char *)result + v8 + 64);
    int v16 = *(_DWORD *)((char *)result + v8 + 96);
    uint64_t v17 = v16 + v15 + (uint64_t)(v11 + v10);
    uint64_t v18 = v11 + v10 - (uint64_t)(v16 + v15);
    uint64_t v19 = v10 - v11;
    uint64_t v20 = v12 - v13;
    uint64_t v21 = v15 - v16;
    *int v9 = (unint64_t)(14564 * (v17 + v14) + 0x4000) >> 15;
    v9[16] = (unint64_t)(17837 * v18 + 0x4000) >> 15;
    v9[32] = (unint64_t)(10298 * (v17 - 2 * v14) + 0x4000) >> 15;
    uint64_t v22 = 5331 * (v21 + v19) + 0x4000;
    v9[8] = (unint64_t)(v22 + 14564 * (v20 + v19)) >> 15;
    v9[24] = (unint64_t)(14564 * (v19 - (v20 + v21)) + 0x4000) >> 15;
    v9[40] = (unint64_t)(v22 + 14564 * (v21 - v20)) >> 15;
    v8 += 4;
  }
  while (v8 != 12);
  return result;
}

_OWORD *jpeg_fdct_2x4(_OWORD *result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  result[14] = 0u;
  result[15] = 0u;
  result[12] = 0u;
  result[13] = 0u;
  result[10] = 0u;
  result[11] = 0u;
  result[8] = 0u;
  result[9] = 0u;
  result[6] = 0u;
  result[7] = 0u;
  result[4] = 0u;
  result[5] = 0u;
  result[2] = 0u;
  result[3] = 0u;
  *uint64_t result = 0u;
  result[1] = 0u;
  do
  {
    uint64_t v4 = &result[v3];
    int v5 = (unsigned __int8 *)(*(void *)(a2 + v3 * 4) + a3);
    int v6 = *v5;
    LODWORD(v5) = v5[1];
    _DWORD *v4 = v5 + v6 - 256;
    v4[1] = v6 - v5;
    v3 += 2;
  }
  while (v3 != 8);
  char v7 = 1;
  do
  {
    char v8 = v7;
    int v9 = *((_DWORD *)result + 24);
    int v10 = v9 + *(_DWORD *)result;
    int v11 = *((_DWORD *)result + 8);
    int v12 = *((_DWORD *)result + 16);
    int v13 = *(_DWORD *)result - v9;
    uint64_t v14 = v11 - v12;
    *(_DWORD *)uint64_t result = 8 * (v12 + v11 + v10);
    *((_DWORD *)result + 16) = 8 * (v10 - (v12 + v11));
    uint64_t v15 = 4433 * (v14 + v13) + 512;
    *((_DWORD *)result + 8) = (unint64_t)(v15 + 6270 * v13) >> 10;
    *((_DWORD *)result + 24) = (unint64_t)(v15 + 0x3FFFFFFC4DFLL * v14) >> 10;
    uint64_t result = (_OWORD *)((char *)result + 4);
    char v7 = 0;
  }
  while ((v8 & 1) != 0);
  return result;
}

double jpeg_fdct_1x2(_OWORD *a1, void *a2, unsigned int a3)
{
  double result = 0.0;
  a1[14] = 0u;
  a1[15] = 0u;
  a1[12] = 0u;
  a1[13] = 0u;
  a1[10] = 0u;
  a1[11] = 0u;
  a1[8] = 0u;
  a1[9] = 0u;
  a1[6] = 0u;
  a1[7] = 0u;
  a1[4] = 0u;
  a1[5] = 0u;
  a1[2] = 0u;
  a1[3] = 0u;
  *a1 = 0u;
  a1[1] = 0u;
  int v4 = *(unsigned __int8 *)(*a2 + a3);
  int v5 = *(unsigned __int8 *)(a2[1] + a3);
  *(_DWORD *)a1 = 32 * (v5 + v4) - 0x2000;
  *((_DWORD *)a1 + 8) = 32 * (v4 - v5);
  return result;
}

void *_cg_jpeg_get_small(int a1, size_t size)
{
  return malloc_type_malloc(size, 0x80D6B4CDuLL);
}

void _cg_jpeg_free_small(int a1, void *a2)
{
}

void *_cg_jpeg_get_large(int a1, size_t size)
{
  return malloc_type_malloc(size, 0x64AF2682uLL);
}

uint64_t _cg_jpeg_mem_available(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return *(void *)(*(void *)(a1 + 8) + 88) - a4;
}

uint64_t _cg_jpeg_open_backing_store(void *a1, size_t (**a2)(uint64_t *a1, uint64_t a2, void *a3, uint64_t a4, size_t a5))
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  bzero(v10, 0x400uLL);
  if (confstr(65537, v10, 0x400uLL)
    && (strcpy(v9, "libjpeg_temp-XXXXXX"), strlen(v9), __strncat_chk(), v4 = mktemp(v10), (int v5 = fopen(v4, "w+b")) != 0))
  {
    int v6 = v5;
    uint64_t result = unlink(v4);
    a2[3] = (size_t (*)(uint64_t *, uint64_t, void *, uint64_t, size_t))v6;
  }
  else
  {
    a2[3] = 0;
    char v8 = (uint64_t (**)(void))*a1;
    *((_DWORD *)v8 + 10) = 65;
    *((_OWORD *)v8 + 3) = 0u;
    *((_OWORD *)v8 + 4) = 0u;
    *((_OWORD *)v8 + 5) = 0u;
    *((_OWORD *)v8 + 6) = 0u;
    *((_OWORD *)v8 + 7) = 0u;
    uint64_t result = (*(uint64_t (**)(void *))*a1)(a1);
  }
  *a2 = read_backing_store;
  a2[1] = (size_t (*)(uint64_t *, uint64_t, void *, uint64_t, size_t))write_backing_store;
  a2[2] = (size_t (*)(uint64_t *, uint64_t, void *, uint64_t, size_t))close_backing_store;
  return result;
}

size_t read_backing_store(uint64_t *a1, uint64_t a2, void *a3, uint64_t a4, size_t a5)
{
  if (fseek(*(FILE **)(a2 + 24), a4, 0))
  {
    uint64_t v9 = *a1;
    *(_DWORD *)(v9 + 40) = 67;
    (*(void (**)(uint64_t *))v9)(a1);
  }
  size_t result = fread(a3, 1uLL, a5, *(FILE **)(a2 + 24));
  if (result != a5)
  {
    uint64_t v11 = *a1;
    *(_DWORD *)(v11 + 40) = 66;
    int v12 = *(uint64_t (**)(uint64_t *))v11;
    return v12(a1);
  }
  return result;
}

size_t write_backing_store(uint64_t *a1, uint64_t a2, const void *a3, uint64_t a4, size_t a5)
{
  if (fseek(*(FILE **)(a2 + 24), a4, 0))
  {
    uint64_t v9 = *a1;
    *(_DWORD *)(v9 + 40) = 67;
    (*(void (**)(uint64_t *))v9)(a1);
  }
  size_t result = fwrite(a3, 1uLL, a5, *(FILE **)(a2 + 24));
  if (result != a5)
  {
    uint64_t v11 = *a1;
    *(_DWORD *)(v11 + 40) = 68;
    int v12 = *(uint64_t (**)(uint64_t *))v11;
    return v12(a1);
  }
  return result;
}

uint64_t close_backing_store(uint64_t a1, uint64_t a2)
{
  return fclose(*(FILE **)(a2 + 24));
}

uint64_t _cg_jpeg_mem_init()
{
  return 1000000000;
}

void kdu_warning::kdu_warning(kdu_warning *this, const char *a2)
{
  *(void *)this = &unk_1ED4DEF68;
  *((void *)this + 2) = 0;
}

void kdu_warning::~kdu_warning(kdu_warning *this)
{
  *(void *)this = &unk_1ED4DEF68;
  uint64_t v1 = *((void *)this + 2);
  if (v1) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v1 + 32))(v1, 1);
  }
}

{
  kdu_warning::~kdu_warning(this);
}

{
  uint64_t vars8;

  kdu_warning::~kdu_warning(this);

  JUMPOUT(0x18C11C0E0);
}

void sub_1886C6DF0(_Unwind_Exception *a1, int a2)
{
  if (a2 < 0) {
    __cxa_call_unexpected(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1886C6E68(_Unwind_Exception *a1, int a2)
{
  MEMORY[0x18C11C0E0](v2, 0x10F1C40713AC7E1);
  if (a2 < 0) {
    __cxa_call_unexpected(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t kdu_warning::put_text(kdu_warning *this, const char *a2)
{
  uint64_t result = *((void *)this + 2);
  if (!result) {
    return result;
  }
  if (*a2 != 60 || a2[1] != 35 || a2[2] != 62 || a2[3]) {
    goto LABEL_6;
  }
  int v5 = (unsigned char *)*((void *)this + 3);
  if (v5)
  {
    if (*v5)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)result + 16))(result, *((void *)this + 3));
      int v6 = (unsigned __int8 *)*((void *)this + 3);
      if (*v6)
      {
        char v7 = v6 + 1;
        do
          *((void *)this + 3) = v7;
        while (*v7++);
        int v6 = v7 - 1;
      }
      *((void *)this + 3) = v6 + 1;
      return result;
    }
LABEL_6:
    int v4 = *(uint64_t (**)(void))(*(void *)result + 16);
    return v4();
  }
  uint64_t v9 = (_WORD *)*((void *)this + 4);
  if (!v9 || !*v9) {
    goto LABEL_6;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)result + 24))(result, *((void *)this + 4));
  int v10 = (_WORD *)*((void *)this + 4);
  if (*v10)
  {
    do
    {
      int v11 = (unsigned __int16)v10[1];
      ++v10;
    }
    while (v11);
  }
  *((void *)this + 4) = v10 + 1;
  return result;
}

void kdu_error::kdu_error(kdu_error *this)
{
  *(void *)this = &unk_1ED4E6170;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  kdu_error::put_text(this, "Kakadu Error:\n");
}

void kdu_error::kdu_error(kdu_error *this, const char *a2)
{
  *(void *)this = &unk_1ED4E6170;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 2) = 0;
  if (*a2) {
    kdu_error::put_text(this, a2);
  }
}

void kdu_error::~kdu_error(kdu_error *this)
{
  *(void *)this = &unk_1ED4E6170;
  uint64_t v1 = *((void *)this + 2);
  if (v1) {
    (*(void (**)(uint64_t, uint64_t))(*(void *)v1 + 32))(v1, 1);
  }
  exception = __cxa_allocate_exception(4uLL);
  _DWORD *exception = -1;
  __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
}

{
  kdu_error::~kdu_error(this);
}

{
  kdu_error::~kdu_error(this);
}

void sub_1886C7108(_Unwind_Exception *a1, int a2)
{
  if (a2 < 0) {
    __cxa_call_unexpected(a1);
  }
  _Unwind_Resume(a1);
}

void sub_1886C714C(_Unwind_Exception *a1, int a2)
{
  MEMORY[0x18C11C0E0](v2, 0x10F1C40713AC7E1);
  if (a2 < 0) {
    __cxa_call_unexpected(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t kdu_error::put_text(kdu_error *this, const char *a2)
{
  uint64_t result = *((void *)this + 2);
  if (!result) {
    return result;
  }
  if (*a2 != 60 || a2[1] != 35 || a2[2] != 62 || a2[3]) {
    goto LABEL_6;
  }
  int v5 = (unsigned char *)*((void *)this + 3);
  if (v5)
  {
    if (*v5)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)result + 16))(result, *((void *)this + 3));
      int v6 = (unsigned __int8 *)*((void *)this + 3);
      if (*v6)
      {
        char v7 = v6 + 1;
        do
          *((void *)this + 3) = v7;
        while (*v7++);
        int v6 = v7 - 1;
      }
      *((void *)this + 3) = v6 + 1;
      return result;
    }
LABEL_6:
    int v4 = *(uint64_t (**)(void))(*(void *)result + 16);
    return v4();
  }
  uint64_t v9 = (_WORD *)*((void *)this + 4);
  if (!v9 || !*v9) {
    goto LABEL_6;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)result + 24))(result, *((void *)this + 4));
  int v10 = (_WORD *)*((void *)this + 4);
  if (*v10)
  {
    do
    {
      int v11 = (unsigned __int16)v10[1];
      ++v10;
    }
    while (v11);
  }
  *((void *)this + 4) = v10 + 1;
  return result;
}

uint64_t kdu_warning::flush(kdu_warning *this)
{
  uint64_t result = *((void *)this + 2);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)result + 32))(result, 0);
  }
  return result;
}

uint64_t kdu_error::flush(kdu_error *this)
{
  uint64_t result = *((void *)this + 2);
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)result + 32))(result, 0);
  }
  return result;
}

uint64_t _cg_jpeg_add_quant_table(uint64_t a1, unsigned int a2, uint64_t a3, int a4, __int32 a5, double a6, int32x2_t a7, double a8, double a9, double a10, double a11, __n128 a12)
{
  int v17 = *(_DWORD *)(a1 + 36);
  if (v17 != 100)
  {
    uint64_t v18 = *(void (***)(void))a1;
    *((_DWORD *)v18 + 10) = 21;
    *((_DWORD *)v18 + 12) = v17;
    (**(void (***)(uint64_t))a1)(a1);
  }
  if (a2 >= 4)
  {
    uint64_t v19 = *(void (***)(void))a1;
    *((_DWORD *)v19 + 10) = 32;
    *((_DWORD *)v19 + 12) = a2;
    (**(void (***)(uint64_t))a1)(a1);
  }
  uint64_t v20 = a1 + 8 * (int)a2;
  uint64_t v23 = *(void *)(v20 + 112);
  uint64_t v22 = (uint64_t *)(v20 + 112);
  uint64_t result = v23;
  if (!v23)
  {
    uint64_t result = _cg_jpeg_alloc_quant_table(a1);
    *uint64_t v22 = result;
  }
  uint64_t v24 = 0;
  int64x2_t v25 = vdupq_n_s64(a4);
  a7.i32[0] = a5;
  int64x2_t v26 = vdupq_n_s64(0x32uLL);
  int64x2_t v27 = vdupq_n_s64(1uLL);
  int8x16_t v28 = (int8x16_t)vdupq_n_s64(0x7FFFuLL);
  v29.i64[0] = 255;
  v29.i64[1] = 255;
  do
  {
    a12.n128_u32[0] = 0;
    int64x2_t v30 = *(int64x2_t *)(a3 + 16);
    v31.i64[0] = v30.u32[2];
    v31.i64[1] = v30.u32[3];
    int64x2_t v32 = v31;
    v31.i64[1] = v30.u32[1];
    v33.i64[0] = v25.i64[0] * *(_OWORD *)a3;
    v34.i64[0] = v25.i64[0] * *(void *)(a3 + 8);
    v33.i64[1] = v25.i64[1] * HIDWORD(*(void *)a3);
    v34.i64[1] = v25.i64[1] * HIDWORD(*(_OWORD *)a3);
    v30.i64[0] = v25.i64[0] * v30.u32[0];
    v30.i64[1] = v25.i64[1] * v31.i64[1];
    v32.i64[0] *= v25.i64[0];
    v32.i64[1] *= v25.i64[1];
    int64x2_t v35 = vaddq_s64(v30, v26);
    int64x2_t v36 = vaddq_s64(v34, v26);
    int64x2_t v37 = vaddq_s64(v33, v26);
    v37.i64[0] /= 100;
    v36.i64[0] /= 100;
    uint64_t v38 = v35.i64[1];
    uint64_t v39 = v35.i64[0];
    int64x2_t v40 = vaddq_s64(v32, v26);
    v32.i64[0] = v39 / 100;
    v37.i64[1] /= 100;
    v36.i64[1] /= 100;
    v32.i64[1] = v38 / 100;
    v40.i64[0] /= 100;
    v40.i64[1] /= 100;
    int8x16_t v41 = (int8x16_t)vcgtq_s64(v40, v27);
    int8x16_t v42 = (int8x16_t)vcgtq_s64(v32, v27);
    int8x16_t v43 = (int8x16_t)vsubq_s64((int64x2_t)vandq_s8((int8x16_t)v40, v41), (int64x2_t)vmvnq_s8(v41));
    int64x2_t v44 = (int64x2_t)vandq_s8((int8x16_t)v32, v42);
    int64x2_t v45 = (int64x2_t)vmvnq_s8(v42);
    int8x16_t v46 = (int8x16_t)vcgtq_s64(v36, v27);
    int8x16_t v47 = (int8x16_t)vsubq_s64(v44, v45);
    int8x16_t v48 = (int8x16_t)vsubq_s64((int64x2_t)vandq_s8((int8x16_t)v36, v46), (int64x2_t)vmvnq_s8(v46));
    int8x16_t v49 = (int8x16_t)vcgtq_s64(v37, v27);
    int8x16_t v50 = (int8x16_t)vsubq_s64((int64x2_t)vandq_s8((int8x16_t)v37, v49), (int64x2_t)vmvnq_s8(v49));
    int32x4_t v51 = (int32x4_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v28, (uint64x2_t)v50), v50, v28);
    int32x4_t v52 = (int32x4_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v28, (uint64x2_t)v48), v48, v28);
    int32x4_t v53 = (int32x4_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v28, (uint64x2_t)v47), v47, v28);
    int32x4_t v54 = (int32x4_t)vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v28, (uint64x2_t)v43), v43, v28);
    int8x16_t v55 = (int8x16_t)vcltzq_s16(vshlq_n_s16((int16x8_t)vmovl_u8((uint8x8_t)vbic_s8(vmovn_s16(vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64((uint64x2_t)v51, v29), (int32x4_t)vcgtq_u64((uint64x2_t)v52, v29)), (int16x8_t)vuzp1q_s32((int32x4_t)vcgtq_u64((uint64x2_t)v53, v29), (int32x4_t)vcgtq_u64((uint64x2_t)v54, v29)))), (int8x8_t)vdup_lane_s32(vceq_s32(a7, (int32x2_t)a12.n128_u64[0]), 0))), 0xFuLL));
    a12 = (__n128)vorrq_s8((int8x16_t)(*(_OWORD *)&v55 & __PAIR128__(0xFF00FF00FF00FFLL, 0xFF00FF00FF00FFLL)), vbicq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32(v51, v52), (int16x8_t)vuzp1q_s32(v53, v54)), v55));
    *(__n128 *)(result + v24) = a12;
    a3 += 32;
    v24 += 16;
  }
  while (v24 != 128);
  *(_DWORD *)(result + 128) = 0;
  return result;
}

uint64_t _cg_jpeg_set_quality(uint64_t a1, int a2, __int32 a3, double a4, int32x2_t a5, double a6, double a7, double a8, double a9, __n128 a10)
{
  if (a2 <= 1) {
    unsigned int v12 = 1;
  }
  else {
    unsigned int v12 = a2;
  }
  if (v12 >= 0x64) {
    unsigned int v12 = 100;
  }
  if (v12 > 0x31) {
    unsigned int v13 = 200 - 2 * v12;
  }
  else {
    unsigned int v13 = 0x1388u / (unsigned __int16)v12;
  }
  _cg_jpeg_add_quant_table(a1, 0, (uint64_t)&std_luminance_quant_tbl, v13, a3, a4, a5, a6, a7, a8, a9, a10);

  return _cg_jpeg_add_quant_table(a1, 1u, (uint64_t)&std_chrominance_quant_tbl, v13, a3, v14, v15, v16, v17, v18, v19, v20);
}

uint64_t _cg_jpeg_set_defaults(uint64_t a1, double a2, int32x2_t a3, double a4, double a5, double a6, double a7, __n128 a8)
{
  int v9 = *(_DWORD *)(a1 + 36);
  if (v9 != 100)
  {
    int v10 = *(void (***)(void))a1;
    *((_DWORD *)v10 + 10) = 21;
    *((_DWORD *)v10 + 12) = v9;
    (**(void (***)(uint64_t))a1)(a1);
  }
  if (!*(void *)(a1 + 104)) {
    *(void *)(a1 + 104) = (**(uint64_t (***)(uint64_t, void, uint64_t))(a1 + 8))(a1, 0, 960);
  }
  *(void *)(a1 + 72) = 0x100000001;
  *(_DWORD *)(a1 + 88) = 8;
  _cg_jpeg_add_quant_table(a1, 0, (uint64_t)&std_luminance_quant_tbl, 50, 1, COERCE_DOUBLE(0x100000001), a3, a4, a5, a6, a7, a8);
  _cg_jpeg_add_quant_table(a1, 1u, (uint64_t)&std_chrominance_quant_tbl, 50, 1, v11, v12, v13, v14, v15, v16, v17);
  if (*(void *)(a1 + 160)) {
    _cg_jpeg_std_huff_table(a1, 1, 0);
  }
  if (*(void *)(a1 + 192)) {
    _cg_jpeg_std_huff_table(a1, 0, 0);
  }
  if (*(void *)(a1 + 168)) {
    _cg_jpeg_std_huff_table(a1, 1, 1u);
  }
  if (*(void *)(a1 + 200)) {
    _cg_jpeg_std_huff_table(a1, 0, 1u);
  }
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0x101010101010101;
  *(void *)(a1 + 248) = 0x101010101010101;
  *(void *)(a1 + 256) = 0x505050505050505;
  *(void *)(a1 + 264) = 0x505050505050505;
  *(void *)(a1 + 280) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 288) = 0;
  *(_DWORD *)(a1 + 292) = *(_DWORD *)(a1 + 88) > 8;
  *(void *)(a1 + 296) = 0;
  *(_DWORD *)(a1 + 304) = 1;
  *(void *)(a1 + 316) = 0;
  *(void *)(a1 + 308) = 0;
  *(_WORD *)(a1 + 328) = 257;
  *(unsigned char *)(a1 + 330) = 0;
  *(_DWORD *)(a1 + 332) = 65537;
  *(_DWORD *)(a1 + 340) = 0;

  return _cg_jpeg_default_colorspace(a1);
}

uint64_t _cg_jpeg_default_colorspace(uint64_t a1)
{
  switch(*(_DWORD *)(a1 + 60))
  {
    case 0:
      int v1 = 0;
      goto LABEL_3;
    case 1:
      int v1 = 1;
      goto LABEL_3;
    case 2:
    case 3:
      int v1 = 3;
      goto LABEL_3;
    case 4:
      int v1 = 4;
      goto LABEL_3;
    case 5:
      int v1 = 5;
      goto LABEL_3;
    case 6:
      int v1 = 6;
      goto LABEL_3;
    case 7:
      int v1 = 7;
LABEL_3:
      uint64_t result = _cg_jpeg_set_colorspace(a1, v1);
      break;
    default:
      uint64_t v2 = *(void *)a1;
      *(_DWORD *)(v2 + 40) = 10;
      uint64_t result = (*(uint64_t (**)(uint64_t))v2)(a1);
      break;
  }
  return result;
}

uint64_t _cg_jpeg_set_colorspace(uint64_t result, int a2)
{
  uint64_t v3 = result;
  int v4 = *(_DWORD *)(result + 36);
  if (v4 != 100)
  {
    int v5 = *(uint64_t (***)(void))result;
    *((_DWORD *)v5 + 10) = 21;
    *((_DWORD *)v5 + 12) = v4;
    uint64_t result = (**(uint64_t (***)(uint64_t))result)(result);
  }
  *(_DWORD *)(v3 + 96) = a2;
  *(_DWORD *)(v3 + 324) = 0;
  *(_DWORD *)(v3 + 336) = 0;
  switch(a2)
  {
    case 0:
      int v6 = *(_DWORD *)(v3 + 56);
      *(_DWORD *)(v3 + 92) = v6;
      if ((v6 - 11) > 0xFFFFFFF5
        || (uint64_t v7 = *(void *)v3,
            *(_DWORD *)(v7 + 40) = 27,
            *(_DWORD *)(v7 + 48) = v6,
            *(_DWORD *)(*(void *)v3 + 52) = 10,
            uint64_t result = (**(uint64_t (***)(uint64_t))v3)(v3),
            int v6 = *(_DWORD *)(v3 + 92),
            v6 >= 1))
      {
        uint64_t v8 = 0;
        uint64_t v9 = *(void *)(v3 + 104);
        do
        {
          *(_DWORD *)uint64_t v9 = v8;
          *(_OWORD *)(v9 + 8) = xmmword_18898E390;
          *(_DWORD *)(v9 + 24) = 0;
          ++v8;
          v9 += 96;
        }
        while (v6 != v8);
      }
      break;
    case 1:
      *(_DWORD *)(v3 + 324) = 1;
      *(_DWORD *)(v3 + 92) = 1;
      uint64_t v20 = *(void *)(v3 + 104);
      *(_DWORD *)uint64_t v20 = 1;
      *(_OWORD *)(v20 + 8) = xmmword_18898E390;
      *(_DWORD *)(v20 + 24) = 0;
      break;
    case 2:
      *(_DWORD *)(v3 + 336) = 1;
      *(_DWORD *)(v3 + 92) = 3;
      uint64_t v10 = *(void *)(v3 + 104);
      *(_DWORD *)uint64_t v10 = 82;
      *(void *)(v10 + 8) = 0x100000001;
      BOOL v11 = *(_DWORD *)(v3 + 340) == 1;
      *(_DWORD *)(v10 + 16) = 0;
      *(_DWORD *)(v10 + 20) = v11;
      *(_DWORD *)(v10 + 24) = v11;
      *(_DWORD *)(v10 + 96) = 71;
      *(_OWORD *)(v10 + 104) = xmmword_18898E390;
      *(_DWORD *)(v10 + 120) = 0;
      int v12 = 66;
      goto LABEL_19;
    case 3:
      *(_DWORD *)(v3 + 324) = 1;
      *(_DWORD *)(v3 + 92) = 3;
      uint64_t v13 = *(void *)(v3 + 104);
      *(_DWORD *)uint64_t v13 = 1;
      *(_OWORD *)(v13 + 8) = xmmword_18898E7A0;
      *(_DWORD *)(v13 + 24) = 0;
      *(_DWORD *)(v13 + 96) = 2;
      *(void *)&long long v14 = 0x100000001;
      *((void *)&v14 + 1) = 0x100000001;
      *(_OWORD *)(v13 + 104) = v14;
      *(_DWORD *)(v13 + 120) = 1;
      *(_DWORD *)(v13 + 192) = 3;
      *(_OWORD *)(v13 + 200) = v14;
      *(_DWORD *)(v13 + 216) = 1;
      break;
    case 4:
      *(_DWORD *)(v3 + 336) = 1;
      *(_DWORD *)(v3 + 92) = 4;
      uint64_t v15 = *(void *)(v3 + 104);
      *(_DWORD *)uint64_t v15 = 67;
      *(_OWORD *)(v15 + 8) = xmmword_18898E390;
      *(_DWORD *)(v15 + 24) = 0;
      *(_DWORD *)(v15 + 96) = 77;
      *(_OWORD *)(v15 + 104) = xmmword_18898E390;
      *(_DWORD *)(v15 + 120) = 0;
      *(_DWORD *)(v15 + 192) = 89;
      *(_OWORD *)(v15 + 200) = xmmword_18898E390;
      *(_DWORD *)(v15 + 216) = 0;
      *(_DWORD *)(v15 + 288) = 75;
      *(_OWORD *)(v15 + 296) = xmmword_18898E390;
      *(_DWORD *)(v15 + 312) = 0;
      break;
    case 5:
      *(_DWORD *)(v3 + 336) = 1;
      *(_DWORD *)(v3 + 92) = 4;
      uint64_t v21 = *(void *)(v3 + 104);
      *(_DWORD *)uint64_t v21 = 1;
      *(_OWORD *)(v21 + 8) = xmmword_18898E7A0;
      *(_DWORD *)(v21 + 24) = 0;
      *(_DWORD *)(v21 + 96) = 2;
      *(void *)&long long v22 = 0x100000001;
      *((void *)&v22 + 1) = 0x100000001;
      *(_OWORD *)(v21 + 104) = v22;
      *(_DWORD *)(v21 + 120) = 1;
      *(_DWORD *)(v21 + 192) = 3;
      *(_OWORD *)(v21 + 200) = v22;
      *(_DWORD *)(v21 + 216) = 1;
      *(_DWORD *)(v21 + 288) = 4;
      *(_OWORD *)(v21 + 296) = xmmword_18898E7A0;
      *(_DWORD *)(v21 + 312) = 0;
      break;
    case 6:
      *(_DWORD *)(v3 + 324) = 1;
      *(unsigned char *)(v3 + 328) = 2;
      *(_DWORD *)(v3 + 92) = 3;
      uint64_t v10 = *(void *)(v3 + 104);
      *(_DWORD *)uint64_t v10 = 114;
      *(void *)(v10 + 8) = 0x100000001;
      BOOL v11 = *(_DWORD *)(v3 + 340) == 1;
      *(_DWORD *)(v10 + 16) = 0;
      *(_DWORD *)(v10 + 20) = v11;
      *(_DWORD *)(v10 + 24) = v11;
      *(_DWORD *)(v10 + 96) = 103;
      *(_OWORD *)(v10 + 104) = xmmword_18898E390;
      *(_DWORD *)(v10 + 120) = 0;
      int v12 = 98;
LABEL_19:
      *(_DWORD *)(v10 + 192) = v12;
      *(void *)(v10 + 200) = 0x100000001;
      *(_DWORD *)(v10 + 208) = 0;
      *(_DWORD *)(v10 + 212) = v11;
      *(_DWORD *)(v10 + 216) = v11;
      break;
    case 7:
      *(_DWORD *)(v3 + 324) = 1;
      *(unsigned char *)(v3 + 328) = 2;
      *(_DWORD *)(v3 + 92) = 3;
      uint64_t v16 = *(void *)(v3 + 104);
      *(_DWORD *)uint64_t v16 = 1;
      *(_OWORD *)(v16 + 8) = xmmword_18898E7A0;
      *(_DWORD *)(v16 + 24) = 0;
      *(_DWORD *)(v16 + 96) = 34;
      *(void *)&long long v17 = 0x100000001;
      *((void *)&v17 + 1) = 0x100000001;
      *(_OWORD *)(v16 + 104) = v17;
      *(_DWORD *)(v16 + 120) = 1;
      *(_DWORD *)(v16 + 192) = 35;
      *(_OWORD *)(v16 + 200) = v17;
      *(_DWORD *)(v16 + 216) = 1;
      break;
    default:
      uint64_t v18 = *(void *)v3;
      *(_DWORD *)(v18 + 40) = 11;
      double v19 = *(uint64_t (**)(uint64_t))v18;
      uint64_t result = v19(v3);
      break;
  }
  return result;
}

uint64_t _cg_jinit_marker_writer(uint64_t a1)
{
  uint64_t result = (**(uint64_t (***)(void))(a1 + 8))();
  *(void *)(a1 + 528) = result;
  *(void *)uint64_t result = write_file_header;
  *(void *)(result + 8) = write_frame_header;
  *(void *)(result + 16) = write_scan_header;
  *(void *)(result + 24) = write_file_trailer;
  *(void *)(result + 32) = write_tables_only;
  *(void *)(result + 40) = write_marker_header;
  *(void *)(result + 48) = write_marker_byte;
  *(_DWORD *)(result + 56) = 0;
  return result;
}

uint64_t write_file_header(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 528);
  emit_byte(a1, 255);
  uint64_t result = emit_byte(a1, 216);
  *(_DWORD *)(v2 + 56) = 0;
  if (*(_DWORD *)(a1 + 324))
  {
    emit_byte(a1, 255);
    emit_byte(a1, 224);
    emit_byte(a1, 0);
    emit_byte(a1, 16);
    emit_byte(a1, 74);
    emit_byte(a1, 70);
    emit_byte(a1, 73);
    emit_byte(a1, 70);
    emit_byte(a1, 0);
    emit_byte(a1, *(unsigned char *)(a1 + 328));
    emit_byte(a1, *(unsigned char *)(a1 + 329));
    emit_byte(a1, *(unsigned char *)(a1 + 330));
    __int16 v4 = *(_WORD *)(a1 + 332);
    emit_byte(a1, SHIBYTE(v4));
    emit_byte(a1, v4);
    __int16 v5 = *(_WORD *)(a1 + 334);
    emit_byte(a1, SHIBYTE(v5));
    emit_byte(a1, v5);
    emit_byte(a1, 0);
    uint64_t result = emit_byte(a1, 0);
  }
  if (*(_DWORD *)(a1 + 336))
  {
    emit_byte(a1, 255);
    emit_byte(a1, 238);
    emit_byte(a1, 0);
    emit_byte(a1, 14);
    emit_byte(a1, 65);
    emit_byte(a1, 100);
    emit_byte(a1, 111);
    emit_byte(a1, 98);
    emit_byte(a1, 101);
    emit_byte(a1, 0);
    emit_byte(a1, 100);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    int v6 = *(_DWORD *)(a1 + 96);
    if (v6 == 3) {
      char v7 = 1;
    }
    else {
      char v7 = 2 * (v6 == 5);
    }
    return emit_byte(a1, v7);
  }
  return result;
}

uint64_t write_frame_header(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 92);
  if (v2 < 1)
  {
    int v3 = 0;
  }
  else
  {
    int v3 = 0;
    int v4 = 0;
    __int16 v5 = (int *)(*(void *)(a1 + 104) + 16);
    do
    {
      int v6 = *v5;
      v5 += 24;
      v3 += emit_dqt(a1, v6);
      ++v4;
      int v2 = *(_DWORD *)(a1 + 92);
    }
    while (v4 < v2);
  }
  if (*(_DWORD *)(a1 + 292)) {
    goto LABEL_7;
  }
  if (*(_DWORD *)(a1 + 348)) {
    goto LABEL_22;
  }
  if (*(_DWORD *)(a1 + 88) != 8 || *(_DWORD *)(a1 + 476) != 8)
  {
    int v9 = 0;
    goto LABEL_21;
  }
  if (v2 < 1)
  {
    int v9 = 1;
  }
  else
  {
    uint64_t v8 = (int *)(*(void *)(a1 + 104) + 24);
    int v9 = 1;
    do
    {
      if (*(v8 - 1) > 1 || *v8 >= 2) {
        int v9 = 0;
      }
      v8 += 24;
      --v2;
    }
    while (v2);
  }
  if (!v3 || !v9)
  {
LABEL_21:
    if (!*(_DWORD *)(a1 + 348))
    {
      if (v9)
      {
        char v7 = -64;
        goto LABEL_23;
      }
      goto LABEL_41;
    }
LABEL_22:
    char v7 = -62;
    goto LABEL_23;
  }
  uint64_t v13 = *(void *)a1;
  *(_DWORD *)(v13 + 40) = 77;
  (*(void (**)(uint64_t, void))(v13 + 8))(a1, 0);
  if (!*(_DWORD *)(a1 + 292))
  {
    if (!*(_DWORD *)(a1 + 348))
    {
LABEL_41:
      char v7 = -63;
      goto LABEL_23;
    }
    goto LABEL_22;
  }
LABEL_7:
  if (*(_DWORD *)(a1 + 348)) {
    char v7 = -54;
  }
  else {
    char v7 = -55;
  }
LABEL_23:
  uint64_t result = emit_sof(a1, v7);
  int v11 = *(_DWORD *)(a1 + 340);
  if (v11)
  {
    if (v11 != 1 || *(int *)(a1 + 92) <= 2)
    {
      uint64_t v12 = *(void *)a1;
      *(_DWORD *)(v12 + 40) = 28;
      (*(void (**)(uint64_t))v12)(a1);
    }
    emit_byte(a1, 255);
    emit_byte(a1, 248);
    emit_byte(a1, 0);
    emit_byte(a1, 24);
    emit_byte(a1, 13);
    emit_byte(a1, 0);
    emit_byte(a1, 255);
    emit_byte(a1, 3);
    emit_byte(a1, *(_DWORD *)(*(void *)(a1 + 104) + 96));
    emit_byte(a1, **(_DWORD **)(a1 + 104));
    emit_byte(a1, *(_DWORD *)(*(void *)(a1 + 104) + 192));
    emit_byte(a1, 128);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 1);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, 1);
    emit_byte(a1, 0);
    uint64_t result = emit_byte(a1, 0);
  }
  if (*(_DWORD *)(a1 + 348) && *(_DWORD *)(a1 + 476) != 8)
  {
    emit_byte(a1, 255);
    emit_byte(a1, 218);
    emit_byte(a1, 0);
    emit_byte(a1, 6);
    emit_byte(a1, 0);
    emit_byte(a1, 0);
    emit_byte(a1, *(_DWORD *)(a1 + 476) * *(_DWORD *)(a1 + 476) - 1);
    return emit_byte(a1, 0);
  }
  return result;
}

uint64_t write_scan_header(uint64_t a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 528);
  if (*(_DWORD *)(a1 + 292))
  {
    int8x16_t v25 = 0uLL;
    int8x16_t v26 = 0uLL;
    uint64_t v3 = *(unsigned int *)(a1 + 372);
    if ((int)v3 >= 1)
    {
      int v4 = *(_DWORD *)(a1 + 460);
      int v5 = *(_DWORD *)(a1 + 464);
      int v6 = (uint64_t *)(a1 + 376);
      while (1)
      {
        uint64_t v7 = *v6;
        if (!v4 && !*(_DWORD *)(a1 + 468)) {
          break;
        }
        if (v5) {
          goto LABEL_7;
        }
LABEL_8:
        ++v6;
        if (!--v3) {
          goto LABEL_12;
        }
      }
      v26.i8[*(int *)(v7 + 20)] = 1;
      if (!v5) {
        goto LABEL_8;
      }
LABEL_7:
      v25.i8[*(int *)(v7 + 24)] = 1;
      goto LABEL_8;
    }
LABEL_12:
    int16x8_t v8 = vaddl_high_s8(v26, v25);
    int16x8_t v9 = vaddl_s8(*(int8x8_t *)v26.i8, *(int8x8_t *)v25.i8);
    int v10 = vaddvq_s32(vaddq_s32(vaddl_s16(*(int16x4_t *)v9.i8, *(int16x4_t *)v8.i8), vaddl_high_s16(v9, v8)));
    if (v10)
    {
      emit_byte(a1, 255);
      emit_byte(a1, 204);
      __int16 v11 = 2 * v10 + 2;
      emit_byte(a1, SHIBYTE(v11));
      emit_byte(a1, v11 & 0xFE);
      uint64_t v12 = 0;
      uint64_t v13 = a1 + 224;
      do
      {
        if (v26.i8[v12])
        {
          emit_byte(a1, v12);
          emit_byte(a1, *(unsigned char *)(v13 + v12) + 16 * *(unsigned char *)(v13 + v12 + 16));
        }
        if (v25.i8[v12])
        {
          emit_byte(a1, v12 + 16);
          emit_byte(a1, *(unsigned char *)(v13 + v12 + 32));
        }
        ++v12;
      }
      while (v12 != 16);
    }
  }
  else if (*(int *)(a1 + 372) >= 1)
  {
    uint64_t v14 = 47;
    do
    {
      uint64_t v15 = *(void *)(a1 + 8 * v14);
      if (!*(_DWORD *)(a1 + 460) && !*(_DWORD *)(a1 + 468)) {
        emit_dht((void *)a1, *(_DWORD *)(v15 + 20), 0);
      }
      if (*(_DWORD *)(a1 + 464)) {
        emit_dht((void *)a1, *(_DWORD *)(v15 + 24), 1);
      }
      uint64_t v16 = v14 - 46;
      ++v14;
    }
    while (v16 < *(int *)(a1 + 372));
  }
  if (*(_DWORD *)(a1 + 316) != *(_DWORD *)(v2 + 56))
  {
    emit_byte(a1, 255);
    emit_byte(a1, 221);
    emit_byte(a1, 0);
    emit_byte(a1, 4);
    int v17 = *(_DWORD *)(a1 + 316);
    emit_byte(a1, SBYTE1(v17));
    emit_byte(a1, v17);
    *(_DWORD *)(v2 + 56) = *(_DWORD *)(a1 + 316);
  }
  emit_byte(a1, 255);
  emit_byte(a1, 218);
  int v18 = 2 * *(_DWORD *)(a1 + 372) + 6;
  emit_byte(a1, (unsigned __int16)(2 * *(_WORD *)(a1 + 372) + 6) >> 8);
  emit_byte(a1, v18 & 0xFE);
  emit_byte(a1, *(_DWORD *)(a1 + 372));
  if (*(int *)(a1 + 372) >= 1)
  {
    uint64_t v19 = 0;
    do
    {
      uint64_t v20 = *(_DWORD **)(a1 + 8 * v19 + 376);
      emit_byte(a1, *v20);
      if (*(_DWORD *)(a1 + 460) || *(_DWORD *)(a1 + 468)) {
        LOBYTE(v21) = 0;
      }
      else {
        int v21 = v20[5];
      }
      int v22 = *(_DWORD *)(a1 + 464);
      if (v22) {
        int v22 = v20[6];
      }
      emit_byte(a1, v22 + 16 * v21);
      ++v19;
    }
    while (v19 < *(int *)(a1 + 372));
  }
  emit_byte(a1, *(_DWORD *)(a1 + 460));
  emit_byte(a1, *(_DWORD *)(a1 + 464));
  char v23 = *(_DWORD *)(a1 + 472) + 16 * *(_DWORD *)(a1 + 468);

  return emit_byte(a1, v23);
}

uint64_t write_file_trailer(uint64_t a1)
{
  emit_byte(a1, 255);

  return emit_byte(a1, 217);
}

uint64_t write_tables_only(uint64_t a1)
{
  emit_byte(a1, 255);
  emit_byte(a1, 216);
  for (uint64_t i = 0; i != 4; ++i)
  {
    if (*(void *)(a1 + 8 * i + 112)) {
      emit_dqt(a1, i);
    }
  }
  if (!*(_DWORD *)(a1 + 292))
  {
    for (uint64_t j = 0; j != 4; ++j)
    {
      uint64_t v4 = a1 + 8 * j;
      if (*(void *)(v4 + 160)) {
        emit_dht((void *)a1, j, 0);
      }
      if (*(void *)(v4 + 192)) {
        emit_dht((void *)a1, j, 1);
      }
    }
  }
  emit_byte(a1, 255);

  return emit_byte(a1, 217);
}

uint64_t write_marker_header(uint64_t *a1, char a2, unsigned int a3)
{
  __int16 v3 = a3;
  if (a3 >= 0xFFFE)
  {
    uint64_t v6 = *a1;
    *(_DWORD *)(v6 + 40) = 12;
    (*(void (**)(uint64_t *))v6)(a1);
  }
  emit_byte((uint64_t)a1, 255);
  emit_byte((uint64_t)a1, a2);
  __int16 v7 = v3 + 2;
  emit_byte((uint64_t)a1, SHIBYTE(v7));

  return emit_byte((uint64_t)a1, v7);
}

uint64_t emit_byte(uint64_t result, char a2)
{
  uint64_t v2 = *(void *)(result + 40);
  __int16 v3 = (unsigned char *)(*(void *)v2)++;
  *__int16 v3 = a2;
  uint64_t v4 = *(void *)(v2 + 8) - 1;
  *(void *)(v2 + 8) = v4;
  if (!v4)
  {
    int v5 = (uint64_t *)result;
    uint64_t result = (*(uint64_t (**)(void))(v2 + 24))();
    if (!result)
    {
      uint64_t v6 = *v5;
      *(_DWORD *)(v6 + 40) = 25;
      __int16 v7 = *(uint64_t (**)(uint64_t *))v6;
      return v7(v5);
    }
  }
  return result;
}

uint64_t emit_dqt(uint64_t a1, int a2)
{
  char v2 = a2;
  uint64_t v4 = *(void *)(a1 + 8 * a2 + 112);
  if (!v4)
  {
    int v5 = *(void (***)(void))a1;
    *((_DWORD *)v5 + 10) = 54;
    *((_DWORD *)v5 + 12) = a2;
    (**(void (***)(uint64_t))a1)(a1);
  }
  uint64_t v6 = *(unsigned int *)(a1 + 488);
  if ((v6 & 0x80000000) != 0)
  {
    uint64_t v7 = 0;
  }
  else
  {
    LODWORD(v7) = 0;
    int16x8_t v8 = *(int **)(a1 + 480);
    uint64_t v9 = v6 + 1;
    do
    {
      uint64_t v10 = *v8++;
      if (*(unsigned __int16 *)(v4 + 2 * v10) > 0xFFu) {
        uint64_t v7 = 1;
      }
      else {
        uint64_t v7 = v7;
      }
      --v9;
    }
    while (v9);
  }
  if (!*(_DWORD *)(v4 + 128))
  {
    emit_byte(a1, 255);
    emit_byte(a1, 219);
    int v11 = *(_DWORD *)(a1 + 488);
    __int16 v12 = 2 * v11 + 5;
    __int16 v13 = v11 + 4;
    if (v7) {
      __int16 v14 = v12;
    }
    else {
      __int16 v14 = v13;
    }
    emit_byte(a1, SHIBYTE(v14));
    emit_byte(a1, v14);
    emit_byte(a1, v2 + 16 * v7);
    if ((*(_DWORD *)(a1 + 488) & 0x80000000) == 0)
    {
      uint64_t v15 = 0;
      do
      {
        __int16 v16 = *(_WORD *)(v4 + 2 * *(int *)(*(void *)(a1 + 480) + 4 * v15));
        if (v7) {
          emit_byte(a1, SHIBYTE(v16));
        }
        emit_byte(a1, v16);
      }
      while (v15++ < *(int *)(a1 + 488));
    }
    *(_DWORD *)(v4 + 128) = 1;
  }
  return v7;
}

uint64_t emit_sof(uint64_t a1, char a2)
{
  emit_byte(a1, 255);
  emit_byte(a1, a2);
  int v4 = 3 * *(_DWORD *)(a1 + 92) + 8;
  emit_byte(a1, (unsigned __int16)(3 * *(_WORD *)(a1 + 92) + 8) >> 8);
  emit_byte(a1, v4);
  if (*(_WORD *)(a1 + 86) || *(_DWORD *)(a1 + 80) >= 0x10000u)
  {
    int v5 = *(void (***)(void))a1;
    *((_DWORD *)v5 + 10) = 42;
    *((_DWORD *)v5 + 12) = 0xFFFF;
    (**(void (***)(uint64_t))a1)(a1);
  }
  emit_byte(a1, *(_DWORD *)(a1 + 88));
  int v6 = *(_DWORD *)(a1 + 84);
  emit_byte(a1, SBYTE1(v6));
  emit_byte(a1, v6);
  int v7 = *(_DWORD *)(a1 + 80);
  emit_byte(a1, SBYTE1(v7));
  emit_byte(a1, v7);
  uint64_t result = emit_byte(a1, *(_DWORD *)(a1 + 92));
  if (*(int *)(a1 + 92) >= 1)
  {
    int v9 = 0;
    uint64_t v10 = *(_DWORD **)(a1 + 104);
    do
    {
      emit_byte(a1, *v10);
      emit_byte(a1, v10[3] + 16 * v10[2]);
      uint64_t result = emit_byte(a1, v10[4]);
      ++v9;
      v10 += 24;
    }
    while (v9 < *(_DWORD *)(a1 + 92));
  }
  return result;
}

void *emit_dht(void *result, int a2, int a3)
{
  uint64_t v3 = (uint64_t)result;
  int v4 = &result[a2];
  int v5 = v4 + 24;
  int v6 = v4 + 20;
  if (a3) {
    int v7 = a2 + 16;
  }
  else {
    int v7 = a2;
  }
  if (a3) {
    int v6 = v5;
  }
  uint64_t v8 = *v6;
  if (!*v6)
  {
    int v9 = (uint64_t (**)(void))*result;
    *((_DWORD *)v9 + 10) = 52;
    *((_DWORD *)v9 + 12) = v7;
    uint64_t result = (void *)(*(uint64_t (**)(void *))*result)(result);
  }
  if (!*(_DWORD *)(v8 + 276))
  {
    emit_byte(v3, 255);
    emit_byte(v3, 196);
    uint8x16_t v10 = *(uint8x16_t *)(v8 + 1);
    uint16x8_t v11 = vmovl_high_u8(v10);
    uint16x8_t v12 = vmovl_u8(*(uint8x8_t *)v10.i8);
    v12.i32[0] = vaddvq_s32(vaddq_s32((int32x4_t)vaddl_u16(*(uint16x4_t *)v12.i8, *(uint16x4_t *)v11.i8), (int32x4_t)vaddl_high_u16(v12, v11)));
    uint64_t v13 = v12.u32[0];
    char v14 = v12.i8[0] + 19;
    emit_byte(v3, (unsigned __int16)(v12.i16[0] + 19) >> 8);
    emit_byte(v3, v14);
    emit_byte(v3, v7);
    for (uint64_t i = 0; i != 16; ++i)
      uint64_t result = (void *)emit_byte(v3, *(unsigned char *)(v8 + 1 + i));
    if (v13)
    {
      __int16 v16 = (char *)(v8 + 17);
      do
      {
        char v17 = *v16++;
        uint64_t result = (void *)emit_byte(v3, v17);
        --v13;
      }
      while (v13);
    }
    *(_DWORD *)(v8 + 276) = 1;
  }
  return result;
}

uint64_t jpeg_calc_jpeg_dimensions(uint64_t result)
{
  int v1 = (int32x2_t *)result;
  if (*(unsigned char *)(result + 51) || *(unsigned char *)(result + 55))
  {
    char v2 = *(uint64_t (***)(void))result;
    *((_DWORD *)v2 + 10) = 42;
    *((_DWORD *)v2 + 12) = 65500;
    uint64_t result = (**(uint64_t (***)(uint64_t))result)(result);
  }
  unsigned int v3 = v1[9].u32[0];
  uint64_t v4 = v1[59].i32[1];
  unsigned int v5 = v4 * v1[9].i32[1];
  if (v3 >= v5)
  {
    v1[10] = vmul_s32(v1[6], vdup_n_s32(v4));
    uint64_t v7 = 0x100000001;
  }
  else if (v5 <= 2 * v3)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 2);
    uint64_t result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 2);
    v1[10].i32[1] = result;
    uint64_t v7 = 0x200000002;
  }
  else if (3 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 3);
    uint64_t result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 3);
    v1[10].i32[1] = result;
    uint64_t v7 = 0x300000003;
  }
  else if (v5 <= 4 * v3)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 4);
    uint64_t result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 4);
    v1[10].i32[1] = result;
    uint64_t v7 = 0x400000004;
  }
  else if (5 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 5);
    uint64_t result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 5);
    v1[10].i32[1] = result;
    uint64_t v7 = 0x500000005;
  }
  else if (6 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 6);
    uint64_t result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 6);
    v1[10].i32[1] = result;
    uint64_t v7 = 0x600000006;
  }
  else if (7 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 7);
    uint64_t result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 7);
    v1[10].i32[1] = result;
    uint64_t v7 = 0x700000007;
  }
  else if (v5 <= 8 * v3)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 8);
    uint64_t result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 8);
    v1[10].i32[1] = result;
    uint64_t v7 = 0x800000008;
  }
  else if (9 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 9);
    uint64_t result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 9);
    v1[10].i32[1] = result;
    uint64_t v7 = 0x900000009;
  }
  else if (10 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 10);
    uint64_t result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 10);
    v1[10].i32[1] = result;
    uint64_t v7 = 0xA0000000ALL;
  }
  else if (11 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 11);
    uint64_t result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 11);
    v1[10].i32[1] = result;
    uint64_t v7 = 0xB0000000BLL;
  }
  else if (12 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 12);
    uint64_t result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 12);
    v1[10].i32[1] = result;
    uint64_t v7 = 0xC0000000CLL;
  }
  else if (13 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 13);
    uint64_t result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 13);
    v1[10].i32[1] = result;
    uint64_t v7 = 0xD0000000DLL;
  }
  else if (14 * v3 >= v5)
  {
    v1[10].i32[0] = jdiv_round_up(v1[6].u32[0] * v4, 14);
    uint64_t result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 14);
    v1[10].i32[1] = result;
    uint64_t v7 = 0xE0000000ELL;
  }
  else
  {
    uint64_t v6 = v1[6].u32[0] * v4;
    if (15 * v3 >= v5)
    {
      v1[10].i32[0] = jdiv_round_up(v6, 15);
      uint64_t result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 15);
      v1[10].i32[1] = result;
      uint64_t v7 = 0xF0000000FLL;
    }
    else
    {
      v1[10].i32[0] = jdiv_round_up(v6, 16);
      uint64_t result = jdiv_round_up(v1[59].i32[1] * (unint64_t)v1[6].u32[1], 16);
      v1[10].i32[1] = result;
      uint64_t v7 = 0x1000000010;
    }
  }
  v1[45] = (int32x2_t)v7;
  return result;
}

uint64_t _cg_jinit_compress_master(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 88);
  if (v2 != 8)
  {
    unsigned int v3 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v3 + 10) = 16;
    *((_DWORD *)v3 + 12) = v2;
    (**(void (***)(uint64_t))a1)(a1);
  }
  if (!*(_DWORD *)(a1 + 52) || (v4 = *(_DWORD *)(a1 + 48)) == 0 || (int v5 = *(_DWORD *)(a1 + 56), v5 <= 0))
  {
    uint64_t v6 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v6 + 10) = 33;
    (*v6)(a1);
    unsigned int v4 = *(_DWORD *)(a1 + 48);
    int v5 = *(_DWORD *)(a1 + 56);
  }
  if ((v5 * (unint64_t)v4) >> 32)
  {
    uint64_t v7 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v7 + 10) = 72;
    (*v7)(a1);
  }
  jpeg_calc_jpeg_dimensions(a1);
  _cg_jinit_c_master_control((uint64_t *)a1, 0);
  if (!*(_DWORD *)(a1 + 288))
  {
    _cg_jinit_color_converter((uint64_t *)a1);
    _cg_jinit_downsampler((uint64_t *)a1);
    _cg_jinit_c_prep_controller((uint64_t *)a1, 0);
  }
  _cg_jinit_forward_dct(a1);
  if (*(_DWORD *)(a1 + 292)) {
    jinit_arith_encoder(a1);
  }
  else {
    _cg_jinit_huff_encoder(a1);
  }
  int v8 = *(int *)(a1 + 272) > 1 || *(_DWORD *)(a1 + 296) != 0;
  _cg_jinit_c_coef_controller(a1, v8);
  _cg_jinit_c_main_controller((int *)a1, 0);
  _cg_jinit_marker_writer(a1);
  (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 48))(a1);
  int v9 = **(uint64_t (***)(uint64_t))(a1 + 528);

  return v9(a1);
}

uint64_t _cg_jpeg_fdct_ifast(uint64_t result, uint64_t a2, unsigned int a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3;
  do
  {
    int v5 = (int *)(result + 4 * v3);
    uint64_t v6 = (unsigned __int8 *)(*(void *)(a2 + v3) + v4);
    int v7 = *v6;
    int v8 = v6[7];
    int v9 = v8 + v7;
    int v10 = v7 - v8;
    int v11 = v6[1];
    int v12 = v6[6];
    int v13 = v12 + v11;
    int v14 = v11 - v12;
    int v15 = v6[2];
    int v16 = v6[5];
    int v17 = v16 + v15;
    int v18 = v15 - v16;
    int v19 = v6[3];
    LODWORD(v6) = v6[4];
    int v20 = v6 + v19;
    LODWORD(v6) = v19 - v6;
    int v21 = v20 + v9;
    int v22 = v9 - v20;
    int v23 = v17 + v13;
    int v24 = v13 - v17;
    int v25 = v21 + v23 - 1024;
    int v26 = v21 - v23;
    int v27 = 181 * (v24 + v22);
    int v28 = v22 + (v27 >> 8);
    int v29 = v22 - (v27 >> 8);
    LODWORD(v6) = v6 + v18;
    int v30 = v18 + v14;
    int v31 = v14 + v10;
    int v32 = (98 * ((int)v6 - v31)) >> 8;
    LODWORD(v6) = v32 + ((139 * (int)v6) >> 8);
    int v33 = v32 + ((334 * v31) >> 8);
    v30 *= 181;
    int v34 = v10 - (v30 >> 8);
    v5[4] = v26;
    v5[5] = v6 + v34;
    void v5[2] = v28;
    v5[3] = v34 - v6;
    LODWORD(v6) = v10 + (v30 >> 8);
    *int v5 = v25;
    v5[1] = v33 + v6;
    v5[6] = v29;
    v5[7] = v6 - v33;
    v3 += 8;
  }
  while (v3 != 64);
  uint64_t v35 = result + 224;
  uint64_t v36 = -32;
  v37.i64[0] = 0xB5000000B5;
  v37.i64[1] = 0xB5000000B5;
  v38.i64[0] = 0x6200000062;
  v38.i64[1] = 0x6200000062;
  v39.i64[0] = 0x8B0000008BLL;
  v39.i64[1] = 0x8B0000008BLL;
  int32x4_t v40 = vdupq_n_s32(0x14Eu);
  do
  {
    int8x16_t v41 = (int32x4_t *)(v35 + v36);
    int32x4_t v42 = *(int32x4_t *)(v35 + v36 - 192);
    int32x4_t v43 = *(int32x4_t *)(v35 + v36 + 32);
    int32x4_t v44 = vaddq_s32(v43, v42);
    int32x4_t v45 = vsubq_s32(v42, v43);
    int32x4_t v46 = *(int32x4_t *)(v35 + v36 - 160);
    int32x4_t v47 = *(int32x4_t *)(v35 + v36);
    int32x4_t v48 = vaddq_s32(v47, v46);
    int32x4_t v49 = vsubq_s32(v46, v47);
    int32x4_t v50 = *(int32x4_t *)(v35 + v36 - 128);
    int32x4_t v51 = *(int32x4_t *)(v35 + v36 - 32);
    int32x4_t v52 = vaddq_s32(v51, v50);
    int32x4_t v53 = vsubq_s32(v50, v51);
    int32x4_t v54 = *(int32x4_t *)(v35 + v36 - 96);
    int32x4_t v55 = *(int32x4_t *)(v35 + v36 - 64);
    int32x4_t v56 = vaddq_s32(v55, v54);
    int32x4_t v57 = vsubq_s32(v54, v55);
    int32x4_t v58 = vaddq_s32(v56, v44);
    int32x4_t v59 = vsubq_s32(v44, v56);
    int32x4_t v60 = vaddq_s32(v52, v48);
    v41[-12] = vaddq_s32(v58, v60);
    v41[-4] = vsubq_s32(v58, v60);
    int32x4_t v61 = vaddq_s32(vsubq_s32(v48, v52), v59);
    int32x4_t v62 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v61.i8, (int32x2_t)0xB5000000B5), 8uLL), vmull_high_s32(v61, v37), 8uLL);
    v41[-8] = vaddq_s32(v59, v62);
    *int8x16_t v41 = vsubq_s32(v59, v62);
    int32x4_t v63 = vaddq_s32(v57, v53);
    int32x4_t v64 = vaddq_s32(v53, v49);
    int32x4_t v65 = vaddq_s32(v49, v45);
    int32x4_t v66 = vsubq_s32(v63, v65);
    int32x4_t v67 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v66.i8, (int32x2_t)0x6200000062), 8uLL), vmull_high_s32(v66, v38), 8uLL);
    int32x4_t v68 = vaddq_s32(v67, vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v63.i8, (int32x2_t)0x8B0000008BLL), 8uLL), vmull_high_s32(v63, v39), 8uLL));
    int32x4_t v69 = vaddq_s32(v67, vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v65.i8, *(int32x2_t *)v40.i8), 8uLL), vmull_high_s32(v65, v40), 8uLL));
    int32x4_t v70 = vshrn_high_n_s64(vshrn_n_s64(vmull_s32(*(int32x2_t *)v64.i8, (int32x2_t)0xB5000000B5), 8uLL), vmull_high_s32(v64, v37), 8uLL);
    int32x4_t v71 = vaddq_s32(v45, v70);
    int32x4_t v72 = vsubq_s32(v45, v70);
    v41[-2] = vaddq_s32(v68, v72);
    v41[-6] = vsubq_s32(v72, v68);
    v41[-10] = vaddq_s32(v69, v71);
    v41[2] = vsubq_s32(v71, v69);
    v36 += 16;
  }
  while (v36);
  return result;
}

uint64_t _cg_jinit_2pass_quantizer(uint64_t a1)
{
  uint64_t v2 = (**(uint64_t (***)(void))(a1 + 8))();
  *(void *)(a1 + 656) = v2;
  *(void *)uint64_t v2 = start_pass_2_quant;
  *(void *)(v2 + 24) = new_color_map_2_quant;
  *(void *)(v2 + 64) = 0;
  *(void *)(v2 + 80) = 0;
  if (*(_DWORD *)(a1 + 144) != 3)
  {
    uint64_t v3 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v3 + 10) = 48;
    (*v3)(a1);
  }
  uint64_t v4 = 0;
  *(void *)(v2 + 48) = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 256);
  do
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 8))(a1, 1, 4096);
    *(void *)(*(void *)(v2 + 48) + v4) = result;
    v4 += 8;
  }
  while (v4 != 256);
  *(_DWORD *)(v2 + 56) = 1;
  if (!*(_DWORD *)(a1 + 132))
  {
    *(void *)(v2 + 32) = 0;
    goto LABEL_13;
  }
  uint64_t v6 = *(unsigned int *)(a1 + 120);
  if ((int)v6 < 8)
  {
    int v7 = 8;
    int v8 = 58;
LABEL_11:
    int v9 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v9 + 10) = v8;
    *((_DWORD *)v9 + 12) = v7;
    (**(void (***)(uint64_t))a1)(a1);
    goto LABEL_12;
  }
  if (v6 >= 0x101)
  {
    int v7 = 256;
    int v8 = 59;
    goto LABEL_11;
  }
LABEL_12:
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 16))(a1, 1, v6, 3);
  *(void *)(v2 + 32) = result;
  *(_DWORD *)(v2 + 40) = v6;
LABEL_13:
  if (*(_DWORD *)(a1 + 112))
  {
    *(_DWORD *)(a1 + 112) = 2;
    *(void *)(v2 + 64) = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 8))(a1, 1, 6 * (*(_DWORD *)(a1 + 136) + 2));
    return init_error_limit(a1);
  }
  return result;
}

void start_pass_2_quant(uint64_t a1, int a2)
{
  uint64_t v3 = *(void *)(a1 + 656);
  uint64_t v4 = *(void *)(v3 + 48);
  if (*(_DWORD *)(a1 + 112))
  {
    *(_DWORD *)(a1 + 112) = 2;
    int v5 = pass2_fs_dither;
    if (a2)
    {
LABEL_3:
      *(void *)(v3 + 8) = prescan_quantize;
      *(void *)(v3 + 16) = finish_pass1;
      *(_DWORD *)(v3 + 56) = 1;
      goto LABEL_16;
    }
  }
  else
  {
    int v5 = pass2_no_dither;
    if (a2) {
      goto LABEL_3;
    }
  }
  *(void *)(v3 + 8) = v5;
  *(void *)(v3 + 16) = finish_pass2;
  int v6 = *(_DWORD *)(a1 + 156);
  if (v6 < 1)
  {
    int v7 = 1;
    int v8 = 58;
  }
  else
  {
    if (v6 < 0x101) {
      goto LABEL_10;
    }
    int v7 = 256;
    int v8 = 59;
  }
  int v9 = *(void (***)(void))a1;
  *((_DWORD *)v9 + 10) = v8;
  *((_DWORD *)v9 + 12) = v7;
  (**(void (***)(uint64_t))a1)(a1);
LABEL_10:
  if (*(_DWORD *)(a1 + 112) == 2)
  {
    size_t v10 = 6 * (*(_DWORD *)(a1 + 136) + 2);
    int v11 = *(void **)(v3 + 64);
    if (!v11)
    {
      int v11 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, size_t))(*(void *)(a1 + 8) + 8))(a1, 1, v10);
      *(void *)(v3 + 64) = v11;
    }
    bzero(v11, v10);
    if (!*(void *)(v3 + 80)) {
      init_error_limit(a1);
    }
    *(_DWORD *)(v3 + 72) = 0;
  }
LABEL_16:
  if (*(_DWORD *)(v3 + 56))
  {
    for (uint64_t i = 0; i != 256; i += 8)
      bzero(*(void **)(v4 + i), 0x1000uLL);
    *(_DWORD *)(v3 + 56) = 0;
  }
}

uint64_t new_color_map_2_quant(uint64_t result)
{
  *(_DWORD *)(*(void *)(result + 656) + 56) = 1;
  return result;
}

uint64_t init_error_limit(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 656);
  uint64_t result = (**(uint64_t (***)(void))(a1 + 8))();
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  uint64_t v5 = result + 1020;
  *(void *)(v1 + 80) = result + 1020;
  do
  {
    *(_DWORD *)(v5 + 4 * v4) = v4;
    *(_DWORD *)(v5 + 4 * v3) = v3;
    ++v4;
    --v3;
  }
  while (v4 != 16);
  int v6 = 16;
  uint64_t v7 = 271;
  uint64_t v8 = 956;
  do
  {
    *(_DWORD *)(result + 4 * v7) = v6;
    *(_DWORD *)(result + v8) = -v6;
    v6 += ((v7++ - 254) & 1) == 0;
    v8 -= 4;
  }
  while (v7 != 303);
  uint64_t v9 = 1212;
  for (uint64_t i = 828; i != -4; i -= 4)
  {
    *(_DWORD *)(result + v9) = 32;
    *(_DWORD *)(result + i) = -32;
    v9 += 4;
  }
  return result;
}

uint64_t prescan_quantize(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(void *)(*(void *)(result + 656) + 48);
    int v6 = *(_DWORD *)(result + 136);
    do
    {
      if (v6)
      {
        uint64_t v7 = *(unsigned char **)(a2 + 8 * v4);
        int v8 = v6;
        do
        {
          uint64_t v9 = *(void *)(v5 + (*v7 & 0xF8)) + ((16 * v7[1]) & 0xFC0);
          unint64_t v10 = ((unint64_t)v7[2] >> 2) & 0x3E;
          int v11 = *(unsigned __int16 *)(v9 + v10);
          if (((v11 + 1) & 0x10000) == 0) {
            LOWORD(v11) = v11 + 1;
          }
          *(_WORD *)(v9 + v10) = v11;
          v7 += 3;
          --v8;
        }
        while (v8);
      }
      ++v4;
    }
    while (v4 != a4);
  }
  return result;
}

uint64_t finish_pass1(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 656);
  *(void *)(a1 + 160) = *(void *)(v2 + 32);
  uint64_t v56 = v2;
  int v3 = *(_DWORD *)(v2 + 40);
  uint64_t v4 = (**(uint64_t (***)(void))(a1 + 8))();
  *(_OWORD *)uint64_t v4 = xmmword_18898E9C0;
  *(void *)(v4 + 16) = 0x1F00000000;
  uint64_t v58 = v4;
  uint64_t v59 = a1;
  update_box(a1, v4);
  unsigned int v5 = 1;
  if (v3 < 2) {
    goto LABEL_35;
  }
  uint64_t v6 = 1;
  while (1)
  {
    if (v3 >= (unint64_t)(2 * v6))
    {
      uint64_t v7 = 0;
      uint64_t v12 = 0;
      uint64_t v13 = v6;
      uint64_t v10 = v58;
      uint64_t v14 = v58;
      do
      {
        if (*(void *)(v14 + 32) > v12 && *(uint64_t *)(v14 + 24) > 0)
        {
          uint64_t v12 = *(void *)(v14 + 32);
          uint64_t v7 = v14;
        }
        v14 += 40;
        --v13;
      }
      while (v13);
    }
    else
    {
      uint64_t v7 = 0;
      uint64_t v8 = 0;
      uint64_t v9 = v6;
      uint64_t v10 = v58;
      uint64_t v11 = v58;
      do
      {
        if (*(void *)(v11 + 24) > v8)
        {
          uint64_t v8 = *(void *)(v11 + 24);
          uint64_t v7 = v11;
        }
        v11 += 40;
        --v9;
      }
      while (v9);
    }
    if (!v7) {
      break;
    }
    uint64_t v15 = v10 + 40 * v6;
    *(_DWORD *)(v15 + 20) = *(_DWORD *)(v7 + 20);
    *(_OWORD *)uint64_t v15 = *(_OWORD *)v7;
    int v16 = *(_DWORD *)(v7 + 20);
    *(_DWORD *)(v15 + 16) = *(_DWORD *)(v7 + 16);
    int v17 = (_DWORD *)(v15 + 16);
    int v19 = *(_DWORD *)v7;
    int v18 = *(_DWORD *)(v7 + 4);
    int v20 = 16 * (v18 - *(_DWORD *)v7);
    int v22 = *(_DWORD *)(v7 + 8);
    int v21 = *(_DWORD *)(v7 + 12);
    int v23 = *(_DWORD *)(v7 + 16);
    BOOL v24 = v20 <= 12 * (v21 - v22);
    if (v20 <= 12 * (v21 - v22)) {
      int v20 = 12 * (v21 - v22);
    }
    if (v20 >= 8 * (v16 - v23)) {
      int v25 = v24;
    }
    else {
      int v25 = 2;
    }
    if (v25 == 2)
    {
      int v28 = v23 + v16;
      if (v23 + v16 < 0 != __OFADD__(v23, v16)) {
        ++v28;
      }
      int v27 = v28 >> 1;
      *(_DWORD *)(v7 + 20) = v27;
    }
    else if (v25 == 1)
    {
      int v17 = (_DWORD *)(v10 + 40 * v6 + 8);
      int v29 = v22 + v21;
      if (v22 + v21 < 0 != __OFADD__(v22, v21)) {
        ++v29;
      }
      int v27 = v29 >> 1;
      *(_DWORD *)(v7 + 12) = v27;
    }
    else
    {
      int v26 = v19 + v18;
      if (v19 + v18 < 0 != __OFADD__(v19, v18)) {
        ++v26;
      }
      int v27 = v26 >> 1;
      *(_DWORD *)(v7 + 4) = v26 >> 1;
      int v17 = (_DWORD *)(v10 + 40 * v6);
    }
    *int v17 = v27 + 1;
    update_box(a1, v7);
    update_box(a1, v15);
    if (++v6 == v3) {
      goto LABEL_34;
    }
  }
  int v3 = v6;
LABEL_34:
  unsigned int v5 = v3;
  if (v3 >= 1)
  {
LABEL_35:
    uint64_t v30 = 0;
    unsigned int v55 = v5;
    uint64_t v57 = v5;
    do
    {
      int v31 = (int *)(v58 + 40 * v30);
      int v32 = v31[1];
      uint64_t v33 = *v31;
      if ((int)v33 <= v32)
      {
        uint64_t v37 = 0;
        uint64_t v36 = 0;
        uint64_t v35 = 0;
        uint64_t v34 = 0;
        int32x4_t v38 = (int *)(v58 + 40 * v30);
        int v39 = v38[5];
        uint64_t v40 = v38[4];
        int v41 = v38[3];
        uint64_t v42 = v38[2];
        int v43 = v32 + 1;
        do
        {
          if ((int)v42 <= v41)
          {
            uint64_t v44 = v42;
            do
            {
              if ((int)v40 <= v39)
              {
                int v45 = (8 * v40) | 4;
                int v46 = v39 - v40 + 1;
                int32x4_t v47 = (unsigned __int16 *)(*(void *)(*(void *)(*(void *)(v59 + 656) + 48) + 8 * v33)
                                         + (v44 << 6)
                                         + 2 * v40);
                do
                {
                  unsigned int v48 = *v47++;
                  uint64_t v49 = v34 + v48;
                  uint64_t v50 = v35 + (int)v48 * (uint64_t)(int)((8 * v33) | 4);
                  uint64_t v51 = v36 + (int)v48 * (uint64_t)(int)((4 * v44) | 2);
                  uint64_t v52 = v37 + (int)v48 * (uint64_t)v45;
                  if (v48)
                  {
                    uint64_t v34 = v49;
                    uint64_t v35 = v50;
                    uint64_t v36 = v51;
                    uint64_t v37 = v52;
                  }
                  v45 += 8;
                  --v46;
                }
                while (v46);
              }
              ++v44;
            }
            while (v41 + 1 != v44);
          }
          ++v33;
        }
        while (v43 != v33);
      }
      else
      {
        uint64_t v34 = 0;
        uint64_t v35 = 0;
        uint64_t v36 = 0;
        uint64_t v37 = 0;
      }
      *(unsigned char *)(**(void **)(v59 + 160) + v30) = (v35 + (v34 >> 1)) / v34;
      *(unsigned char *)(*(void *)(*(void *)(v59 + 160) + 8) + v30) = (v36 + (v34 >> 1)) / v34;
      *(unsigned char *)(*(void *)(*(void *)(v59 + 160) + 16) + v30++) = (v37 + (v34 >> 1)) / v34;
    }
    while (v30 != v57);
    unsigned int v5 = v55;
  }
  *(_DWORD *)(v59 + 156) = v5;
  uint64_t v53 = *(void *)v59;
  *(_DWORD *)(v53 + 40) = 98;
  *(_DWORD *)(v53 + 48) = v5;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v59 + 8))(v59, 1);
  *(_DWORD *)(v56 + 56) = 1;
  return result;
}

uint64_t pass2_fs_dither(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v56 = result;
  if (a4 >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(void *)(result + 656);
    uint64_t v6 = *(void *)(v5 + 48);
    int v7 = *(_DWORD *)(result + 136);
    uint64_t result = *(void *)(result + 440);
    uint64_t v8 = *(void *)(v5 + 80);
    uint64_t v9 = *(uint64_t **)(v56 + 160);
    uint64_t v10 = *v9;
    uint64_t v11 = v9[1];
    uint64_t v12 = v9[2];
    uint64_t v44 = (v7 - 1);
    uint64_t v42 = (3 * v7 + 3);
    uint64_t v43 = (3 * v7 - 3);
    uint64_t v45 = a4;
    uint64_t v47 = *(void *)(v56 + 656);
    int v46 = *(_DWORD *)(v56 + 136);
    uint64_t v54 = *v9;
    uint64_t v55 = *(void *)(v56 + 440);
    uint64_t v52 = v12;
    uint64_t v53 = v6;
    uint64_t v51 = v8;
    do
    {
      uint64_t v13 = *(void *)(a2 + 8 * v4);
      uint64_t v14 = *(unsigned char **)(a3 + 8 * v4);
      uint64_t v50 = v4;
      if (*(_DWORD *)(v5 + 72))
      {
        int v15 = 0;
        v13 += v43;
        v14 += v44;
        int v16 = (_WORD *)(*(void *)(v5 + 64) + 2 * v42);
        int v17 = -3;
        uint64_t v18 = -1;
      }
      else
      {
        int v16 = *(_WORD **)(v5 + 64);
        int v17 = 3;
        int v15 = 1;
        uint64_t v18 = 1;
      }
      *(_DWORD *)(v5 + 72) = v15;
      if (v7)
      {
        int v19 = 0;
        __int16 v20 = 0;
        __int16 v21 = 0;
        __int16 v22 = 0;
        __int16 v23 = 0;
        __int16 v24 = 0;
        __int16 v25 = 0;
        int v26 = 0;
        int v27 = 0;
        uint64_t v60 = v17;
        uint64_t v61 = v17;
        int v28 = (unsigned __int8 *)(v13 + 2);
        int v29 = v16;
        uint64_t v57 = v18;
        do
        {
          __int16 v62 = v23;
          __int16 v63 = v22;
          __int16 v64 = v21;
          int v16 = &v29[v60];
          unint64_t v30 = *(unsigned __int8 *)(result
                                   + *(int *)(v8 + 4 * ((v19 + (__int16)v29[v60] + 8) >> 4))
                                   + (unint64_t)*(v28 - 2));
          unint64_t v31 = *(unsigned __int8 *)(result
                                   + *(int *)(v8 + 4 * ((v27 + (__int16)v29[v60 + 1] + 8) >> 4))
                                   + (unint64_t)*(v28 - 1));
          unint64_t v32 = *(unsigned __int8 *)(result
                                   + *(int *)(v8 + 4 * ((v26 + (__int16)v29[v60 + 2] + 8) >> 4))
                                   + (unint64_t)*v28);
          uint64_t v33 = (_WORD *)(*(void *)(v6 + 8 * (v30 >> 3)) + (v31 >> 2 << 6) + 2 * (v32 >> 3));
          unsigned int v34 = (unsigned __int16)*v33;
          if (!*v33)
          {
            uint64_t v35 = v11;
            __int16 v59 = v24;
            __int16 v58 = v25;
            fill_inverse_cmap(v56, v30 >> 3, v31 >> 2, v32 >> 3);
            __int16 v25 = v58;
            __int16 v24 = v59;
            uint64_t v8 = v51;
            uint64_t v12 = v52;
            uint64_t v11 = v35;
            uint64_t v18 = v57;
            uint64_t v10 = v54;
            uint64_t result = v55;
            uint64_t v6 = v53;
            unsigned int v34 = (unsigned __int16)*v33;
          }
          uint64_t v36 = v34 - 1;
          *uint64_t v14 = v36;
          int v37 = v30 - *(unsigned __int8 *)(v10 + v36);
          int v38 = v31 - *(unsigned __int8 *)(v11 + v36);
          int v39 = v32 - *(unsigned __int8 *)(v12 + v36);
          __int16 v22 = 5 * v37 + v25;
          __int16 v40 = 3 * (v31 - *(unsigned __int8 *)(v11 + v36)) + v64;
          __int16 v21 = 5 * v38 + v24;
          __int16 v41 = 3 * (v32 - *(unsigned __int8 *)(v12 + v36)) + v20;
          int v19 = 7 * v37;
          __int16 v20 = 5 * v39 + v62;
          int v27 = 7 * v38;
          *int v29 = 3 * (v30 - *(unsigned __int8 *)(v10 + v36)) + v63;
          v29[1] = v40;
          int v26 = 7 * v39;
          v14 += v18;
          v28 += v61;
          v29[2] = v41;
          int v29 = (_WORD *)((char *)v29 + v60 * 2);
          __int16 v23 = v39;
          __int16 v24 = v38;
          __int16 v25 = v37;
          --v7;
        }
        while (v7);
      }
      else
      {
        __int16 v22 = 0;
        __int16 v21 = 0;
        __int16 v20 = 0;
      }
      *int v16 = v22;
      v16[1] = v21;
      v16[2] = v20;
      uint64_t v4 = v50 + 1;
      uint64_t v5 = v47;
      int v7 = v46;
    }
    while (v50 + 1 != v45);
  }
  return result;
}

void pass2_no_dither(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = *(void *)(*(void *)(a1 + 656) + 48);
    int v8 = *(_DWORD *)(a1 + 136);
    uint64_t v9 = a4;
    do
    {
      if (v8)
      {
        uint64_t v10 = *(unsigned char **)(a3 + 8 * v6);
        uint64_t v11 = *(unsigned __int8 **)(a2 + 8 * v6);
        int v12 = v8;
        do
        {
          unint64_t v13 = (unint64_t)*v11 >> 3;
          unint64_t v14 = (unint64_t)v11[1] >> 2;
          unint64_t v15 = (unint64_t)v11[2] >> 3;
          int v16 = (__int16 *)(*(void *)(v7 + 8 * v13) + (v14 << 6) + 2 * v15);
          __int16 v17 = *v16;
          if (!*v16)
          {
            fill_inverse_cmap(a1, v13, v14, v15);
            LOBYTE(v17) = *(unsigned char *)v16;
          }
          *v10++ = v17 - 1;
          v11 += 3;
          --v12;
        }
        while (v12);
      }
      ++v6;
    }
    while (v6 != v9);
  }
}

uint64_t update_box(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(result + 656) + 48);
  LODWORD(v4) = *(_DWORD *)a2;
  int v3 = *(_DWORD *)(a2 + 4);
  int v5 = *(_DWORD *)(a2 + 8);
  int v6 = *(_DWORD *)(a2 + 12);
  uint64_t v7 = v5;
  int v8 = *(_DWORD *)(a2 + 16);
  int v9 = *(_DWORD *)(a2 + 20);
  uint64_t v10 = v8;
  if (v3 > *(_DWORD *)a2)
  {
    uint64_t v11 = (int)v4;
    uint64_t result = (v6 + 1);
    while (v5 > v6)
    {
LABEL_4:
      if (v3 + 1 == ++v11) {
        goto LABEL_14;
      }
    }
    uint64_t v12 = v5;
    while (v8 > v9)
    {
LABEL_11:
      if (result == ++v12) {
        goto LABEL_4;
      }
    }
    unint64_t v13 = (_WORD *)(*(void *)(v2 + 8 * v11) + (v12 << 6) + 2 * v8);
    int v14 = v9 - v8 + 1;
    while (!*v13)
    {
      ++v13;
      if (!--v14) {
        goto LABEL_11;
      }
    }
    *(_DWORD *)a2 = v11;
    LODWORD(v4) = v11;
  }
LABEL_14:
  if (v3 > (int)v4)
  {
    uint64_t v15 = v3;
    uint64_t result = (v6 + 1);
    while (v5 > v6)
    {
LABEL_17:
      BOOL v16 = v15-- <= (int)v4;
      if (v16) {
        goto LABEL_28;
      }
    }
    uint64_t v17 = v5;
    while (v8 > v9)
    {
LABEL_25:
      if (result == ++v17) {
        goto LABEL_17;
      }
    }
    uint64_t v18 = (_WORD *)(*(void *)(v2 + 8 * v15) + (v17 << 6) + 2 * v8);
    int v19 = v9 - v8 + 1;
    while (!*v18)
    {
      ++v18;
      if (!--v19) {
        goto LABEL_25;
      }
    }
    *(_DWORD *)(a2 + 4) = v15;
    int v3 = v15;
  }
LABEL_28:
  if (v6 > v5)
  {
    uint64_t result = (v3 + 1);
    while (v3 < (int)v4)
    {
LABEL_31:
      if (v6 + 1 == ++v7) {
        goto LABEL_41;
      }
    }
    uint64_t v20 = (int)v4;
    while (v8 > v9)
    {
LABEL_38:
      if (result == ++v20) {
        goto LABEL_31;
      }
    }
    __int16 v21 = (_WORD *)(*(void *)(v2 + 8 * v20) + (v7 << 6) + 2 * v8);
    int v22 = v9 - v8 + 1;
    while (!*v21)
    {
      ++v21;
      if (!--v22) {
        goto LABEL_38;
      }
    }
    *(_DWORD *)(a2 + 8) = v7;
    int v5 = v7;
  }
LABEL_41:
  if (v6 > v5)
  {
    uint64_t v23 = v6;
    uint64_t result = (v3 + 1);
    while (v3 < (int)v4)
    {
LABEL_44:
      BOOL v16 = v23-- <= v5;
      if (v16) {
        goto LABEL_55;
      }
    }
    uint64_t v24 = (int)v4;
    while (v8 > v9)
    {
LABEL_52:
      if (result == ++v24) {
        goto LABEL_44;
      }
    }
    __int16 v25 = (_WORD *)(*(void *)(v2 + 8 * v24) + (v23 << 6) + 2 * v8);
    int v26 = v9 - v8 + 1;
    while (!*v25)
    {
      ++v25;
      if (!--v26) {
        goto LABEL_52;
      }
    }
    *(_DWORD *)(a2 + 12) = v23;
    int v6 = v23;
  }
LABEL_55:
  if (v9 > v8)
  {
    uint64_t result = (v3 + 1);
    while (v3 < (int)v4)
    {
LABEL_58:
      if (v9 + 1 == ++v10) {
        goto LABEL_68;
      }
    }
    uint64_t v27 = (int)v4;
    while (v6 < v5)
    {
LABEL_65:
      if (result == ++v27) {
        goto LABEL_58;
      }
    }
    int v28 = (_WORD *)(*(void *)(v2 + 8 * v27) + ((uint64_t)v5 << 6) + 2 * v10);
    int v29 = v6 - v5 + 1;
    while (!*v28)
    {
      v28 += 32;
      if (!--v29) {
        goto LABEL_65;
      }
    }
    *(_DWORD *)(a2 + 16) = v10;
    int v8 = v10;
  }
LABEL_68:
  if (v9 > v8)
  {
    uint64_t v30 = v9;
    uint64_t result = (v3 + 1);
    while (v3 < (int)v4)
    {
LABEL_71:
      BOOL v16 = v30-- <= v8;
      if (v16) {
        goto LABEL_82;
      }
    }
    uint64_t v31 = (int)v4;
    while (v6 < v5)
    {
LABEL_79:
      if (result == ++v31) {
        goto LABEL_71;
      }
    }
    unint64_t v32 = (_WORD *)(*(void *)(v2 + 8 * v31) + ((uint64_t)v5 << 6) + 2 * v30);
    int v33 = v6 - v5 + 1;
    while (!*v32)
    {
      v32 += 32;
      if (!--v33) {
        goto LABEL_79;
      }
    }
    *(_DWORD *)(a2 + 20) = v30;
    int v9 = v30;
  }
LABEL_82:
  *(void *)(a2 + 24) = 12 * (v6 - v5) * (uint64_t)(12 * (v6 - v5))
                       + 16 * (v3 - (int)v4) * (uint64_t)(16 * (v3 - (int)v4))
                       + 8 * (v9 - v8) * (uint64_t)(8 * (v9 - v8));
  uint64_t v34 = 0;
  if (v3 >= (int)v4)
  {
    uint64_t result = (v6 + 1);
    uint64_t v4 = (int)v4;
    int v35 = v3 + 1;
    do
    {
      if (v6 >= v5)
      {
        uint64_t v36 = v5;
        do
        {
          if (v9 >= v8)
          {
            int v37 = (unsigned __int16 *)(*(void *)(v2 + 8 * v4) + (v36 << 6) + 2 * v8);
            int v38 = v9 - v8 + 1;
            do
            {
              if (*v37++) {
                ++v34;
              }
              --v38;
            }
            while (v38);
          }
          ++v36;
        }
        while (result != v36);
      }
      ++v4;
    }
    while (v35 != v4);
  }
  *(void *)(a2 + 32) = v34;
  return result;
}

void fill_inverse_cmap(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  __b[256] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(*(void *)(a1 + 656) + 48);
  memset(v78, 0, sizeof(v78));
  memset(v77, 0, sizeof(v77));
  uint64_t v9 = *(unsigned int *)(a1 + 156);
  bzero(__b, 0x800uLL);
  if ((int)v9 <= 0) {
    goto LABEL_43;
  }
  uint64_t v10 = 0;
  int v11 = (32 * (a2 >> 2)) | 4;
  uint64_t v12 = 4 * a3;
  unint64_t v13 = v12 & 0xFFFFFFFFFFFFFFE0 | 2;
  uint64_t v14 = 8 * (int)a4;
  unint64_t v15 = v14 & 0xFFFFFFFFFFFFFFE0 | 4;
  int v16 = (8 * a2) | 0x1C;
  uint64_t v17 = v12 | 0x1E;
  unsigned int v18 = (v13 + (v12 | 0x1E)) >> 1;
  uint64_t v19 = v14 | 0x1C;
  uint64_t v20 = *(uint64_t **)(a1 + 160);
  uint64_t v21 = *v20;
  uint64_t v22 = v20[1];
  uint64_t v23 = v20[2];
  uint64_t v24 = 0x7FFFFFFFLL;
  do
  {
    signed int v25 = *(unsigned __int8 *)(v21 + v10);
    int v26 = v25 - v11;
    if (v25 < v11)
    {
      uint64_t v27 = 2 * v26 * (uint64_t)(2 * v26);
      int v26 = v25 - v16;
LABEL_9:
      int v29 = 2 * v26;
      goto LABEL_10;
    }
    int v28 = v25 - v16;
    if (v25 > v16)
    {
      uint64_t v27 = 2 * v28 * (uint64_t)(2 * v28);
      goto LABEL_9;
    }
    if ((v11 + v16) >> 1 < v25)
    {
      uint64_t v27 = 0;
      goto LABEL_9;
    }
    uint64_t v27 = 0;
    int v29 = 2 * v28;
LABEL_10:
    uint64_t v30 = v29 * (uint64_t)v29;
    uint64_t v31 = *(unsigned __int8 *)(v22 + v10);
    uint64_t v32 = 3 * (v31 - (int)v13) * 3 * (v31 - (int)v13);
    uint64_t v33 = 3 * (v31 - (int)v17);
    uint64_t v34 = v33 * v33;
    if (v18 < v31) {
      uint64_t v34 = 3 * (v31 - (int)v13) * 3 * (v31 - (int)v13);
    }
    uint64_t v35 = v27 + v33 * v33;
    if ((int)v31 <= (int)v17)
    {
      uint64_t v35 = v27;
      uint64_t v32 = v34;
    }
    unint64_t v36 = v27 + 3 * (v31 - v13) * 3 * (v31 - v13);
    if ((int)v31 < (int)v13)
    {
      uint64_t v37 = 3 * (v31 - v17) * 3 * (v31 - v17);
    }
    else
    {
      unint64_t v36 = v35;
      uint64_t v37 = v32;
    }
    uint64_t v38 = v37 + v30;
    uint64_t v39 = *(unsigned __int8 *)(v23 + v10);
    uint64_t v40 = (v39 - (int)v15) * (v39 - (int)v15);
    uint64_t v41 = v39 - (int)v19;
    uint64_t v42 = v41 * v41;
    if ((v15 + v19) >> 1 < v39) {
      uint64_t v42 = (v39 - (int)v15) * (v39 - (int)v15);
    }
    unint64_t v43 = v36 + v41 * v41;
    if ((int)v39 <= (int)v19)
    {
      unint64_t v43 = v36;
      uint64_t v40 = v42;
    }
    unint64_t v44 = v36 + (v39 - v15) * (v39 - v15);
    if ((int)v39 < (int)v15)
    {
      uint64_t v45 = (v39 - v19) * (v39 - v19);
    }
    else
    {
      unint64_t v44 = v43;
      uint64_t v45 = v40;
    }
    uint64_t v46 = v38 + v45;
    __b[v10] = v44;
    if (v46 < v24) {
      uint64_t v24 = v46;
    }
    ++v10;
  }
  while (v9 != v10);
  uint64_t v47 = 0;
  int v48 = 0;
  do
  {
    if (__b[v47] <= v24) {
      *((unsigned char *)v78 + v48++) = v47;
    }
    ++v47;
  }
  while (v9 != v47);
  memset_pattern16(__b, &unk_18898E9D0, 0x400uLL);
  if (v48 >= 1)
  {
    uint64_t v49 = 0;
    uint64_t v50 = (int)v13;
    uint64_t v51 = (int)v15;
    do
    {
      uint64_t v52 = *((unsigned __int8 *)v78 + v49);
      uint64_t v53 = *(void **)(a1 + 160);
      int v54 = 2 * (v11 - *(unsigned __int8 *)(*v53 + v52));
      uint64_t v55 = v50 - *(unsigned __int8 *)(v53[1] + v52);
      uint64_t v56 = v51 - *(unsigned __int8 *)(v53[2] + v52);
      uint64_t v57 = 3 * v55 * 3 * v55 + v54 * (uint64_t)v54 + v56 * v56;
      uint64_t v58 = 32 * v54 + 256;
      uint64_t v59 = 72 * v55 + 144;
      uint64_t v60 = 16 * v56 + 64;
      int v61 = 3;
      __int16 v62 = __b;
      __int16 v63 = v77;
      do
      {
        int v64 = v61;
        int v65 = 7;
        uint64_t v66 = v59;
        uint64_t v67 = v57;
        do
        {
          uint64_t v68 = 0;
          int v69 = v65;
          uint64_t v70 = v60;
          uint64_t v71 = v67;
          do
          {
            if (v71 < v62[v68])
            {
              v62[v68] = v71;
              *__int16 v63 = v52;
            }
            v71 += v70;
            v70 += 128;
            ++v63;
            ++v68;
          }
          while ((v68 * 8) != 32);
          v67 += v66;
          v66 += 288;
          int v65 = v69 - 1;
          __int16 v62 = (void *)((char *)v62 + v68 * 8);
        }
        while (v69);
        v57 += v58;
        v58 += 512;
        int v61 = v64 - 1;
      }
      while (v64);
      ++v49;
    }
    while (v49 != v48);
  }
LABEL_43:
  uint64_t v72 = 0;
  uint64_t v73 = v77;
  do
  {
    uint64_t v74 = 0;
    uint64_t v75 = *(void *)(v8 + 8 * (v72 + (int)(a2 & 0xFFFFFFFC)))
        + ((2 * a4) & 0x1FFFFFFF8)
        + ((uint64_t)(int)(a3 & 0xFFFFFFF8) << 6);
    do
    {
      for (uint64_t i = 0; i != 4; ++i)
        *(_WORD *)(v75 + 2 * i) = *((unsigned __int8 *)v73 + i) + 1;
      ++v74;
      v75 += 64;
      uint64_t v73 = (_OWORD *)((char *)v73 + 4);
    }
    while (v74 != 8);
    ++v72;
  }
  while (v72 != 4);
}

uint64_t _cg_jpeg_CreateDecompress(char *a1, int a2, uint64_t a3)
{
  *((void *)a1 + 1) = 0;
  if (a2 != 90)
  {
    uint64_t v5 = *(void *)a1;
    *(_DWORD *)(v5 + 40) = 13;
    *(_DWORD *)(v5 + 48) = 90;
    *(_DWORD *)(*(void *)a1 + 52) = a2;
    (**(void (***)(char *))a1)(a1);
  }
  if (a3 != 664)
  {
    uint64_t v6 = *(void *)a1;
    *(_DWORD *)(v6 + 40) = 22;
    *(_DWORD *)(v6 + 48) = 664;
    *(_DWORD *)(*(void *)a1 + 52) = a3;
    (**(void (***)(char *))a1)(a1);
  }
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = *((void *)a1 + 3);
  bzero(a1, 0x298uLL);
  *(void *)a1 = v7;
  *((void *)a1 + 3) = v8;
  *((_DWORD *)a1 + 8) = 1;
  _cg_jinit_memory_mgr(a1);
  *((void *)a1 + 2) = 0;
  *((void *)a1 + 5) = 0;
  *((void *)a1 + 51) = 0;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  _cg_jinit_marker_reader((uint64_t)a1);
  uint64_t result = _cg_jinit_input_controller((uint64_t)a1);
  *((_DWORD *)a1 + 9) = 200;
  return result;
}

uint64_t _cg_jpeg_read_header(uint64_t a1, int a2)
{
  int v4 = *(_DWORD *)(a1 + 36);
  if ((v4 & 0xFFFFFFFE) != 0xC8)
  {
    uint64_t v5 = *(void (***)(void))a1;
    *((_DWORD *)v5 + 10) = 21;
    *((_DWORD *)v5 + 12) = v4;
    (**(void (***)(uint64_t))a1)(a1);
  }
  uint64_t v6 = _cg_jpeg_consume_input((uint64_t *)a1);
  if (v6 == 2)
  {
    if (a2)
    {
      uint64_t v7 = *(void *)a1;
      *(_DWORD *)(v7 + 40) = 53;
      (*(void (**)(uint64_t))v7)(a1);
    }
    _cg_jpeg_abort(a1);
  }
  return v6;
}

uint64_t _cg_jpeg_consume_input(uint64_t *a1)
{
  int v2 = *((_DWORD *)a1 + 9);
  uint64_t result = 1;
  switch(v2)
  {
    case 200:
      (*(void (**)(uint64_t *))(a1[76] + 8))(a1);
      (*(void (**)(uint64_t *))(a1[5] + 16))(a1);
      *((_DWORD *)a1 + 9) = 201;
      goto LABEL_6;
    case 201:
LABEL_6:
      uint64_t result = (*(uint64_t (**)(uint64_t *))a1[76])(a1);
      if (result != 1) {
        return result;
      }
      int v5 = *((_DWORD *)a1 + 14);
      switch(v5)
      {
        case 1:
          int v12 = 1;
          break;
        case 4:
          if (*((_DWORD *)a1 + 97) && (int v14 = *((unsigned __int8 *)a1 + 392), *((unsigned char *)a1 + 392)))
          {
            if (v14 != 2)
            {
              uint64_t v15 = *a1;
              *(_DWORD *)(v15 + 40) = 116;
              *(_DWORD *)(v15 + 48) = v14;
              (*(void (**)(uint64_t *, uint64_t))(*a1 + 8))(a1, 0xFFFFFFFFLL);
            }
            int v12 = 4;
            int v5 = 5;
          }
          else
          {
            int v5 = 4;
            int v12 = 4;
          }
          break;
        case 3:
          uint64_t v6 = (int *)a1[38];
          int v7 = *v6;
          int v8 = v6[24];
          int v9 = v6[48];
          if (v7 != 1 || v8 != 2 || v9 != 3)
          {
            if (v7 == 1 && v8 == 34 && v9 == 35)
            {
              int v12 = 2;
              int v5 = 7;
              break;
            }
            if (v7 == 82 && v8 == 71 && v9 == 66) {
              goto LABEL_33;
            }
            if (v7 == 114 && v8 == 103 && v9 == 98)
            {
              int v12 = 2;
              int v5 = 6;
              break;
            }
            if (!*((_DWORD *)a1 + 94))
            {
              if (*((_DWORD *)a1 + 97))
              {
                int v16 = *((unsigned __int8 *)a1 + 392);
                if (!*((unsigned char *)a1 + 392))
                {
LABEL_33:
                  int v5 = 2;
                  int v12 = 2;
                  break;
                }
                if (v16 != 1)
                {
                  uint64_t v17 = *a1;
                  *(_DWORD *)(v17 + 40) = 116;
                  *(_DWORD *)(v17 + 48) = v16;
                  (*(void (**)(uint64_t *, uint64_t))(*a1 + 8))(a1, 0xFFFFFFFFLL);
                }
              }
              else
              {
                uint64_t v18 = *a1;
                *(_DWORD *)(v18 + 48) = v7;
                *(_DWORD *)(v18 + 52) = v8;
                *(_DWORD *)(v18 + 56) = v9;
                *(_DWORD *)(v18 + 40) = 113;
                (*(void (**)(uint64_t *, uint64_t))(v18 + 8))(a1, 1);
              }
            }
          }
          int v12 = 2;
          int v5 = 3;
          break;
        default:
          int v5 = 0;
          int v12 = 0;
          break;
      }
      *((_DWORD *)a1 + 15) = v5;
      *((_DWORD *)a1 + 16) = v12;
      int v19 = *((_DWORD *)a1 + 139);
      *((_DWORD *)a1 + 17) = v19;
      *((_DWORD *)a1 + 18) = v19;
      a1[10] = 0x3FF0000000000000;
      *(_OWORD *)(a1 + 11) = xmmword_18898E7B0;
      *(_OWORD *)(a1 + 13) = xmmword_18898E9F0;
      a1[20] = 0;
      *(_OWORD *)(a1 + 15) = xmmword_18898EA00;
      uint64_t result = 1;
      *((_DWORD *)a1 + 9) = 202;
      return result;
    case 202:
      return result;
    case 203:
    case 204:
    case 205:
    case 206:
    case 207:
    case 208:
    case 210:
      int v4 = *(uint64_t (**)(uint64_t *))a1[76];
      return v4(a1);
    default:
      uint64_t v13 = *a1;
      *(_DWORD *)(v13 + 40) = 21;
      *(_DWORD *)(v13 + 48) = v2;
      (*(void (**)(uint64_t *))*a1)(a1);
      return 0;
  }
}

uint64_t _cg_jpeg_input_complete(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 36);
  if ((v2 - 211) <= 0xFFFFFFF4)
  {
    int v3 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v3 + 10) = 21;
    *((_DWORD *)v3 + 12) = v2;
    (**(void (***)(uint64_t))a1)(a1);
  }
  return *(unsigned int *)(*(void *)(a1 + 608) + 36);
}

uint64_t _cg_jpeg_has_multiple_scans(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 36);
  if ((v2 - 211) <= 0xFFFFFFF6)
  {
    int v3 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v3 + 10) = 21;
    *((_DWORD *)v3 + 12) = v2;
    (**(void (***)(uint64_t))a1)(a1);
  }
  return *(unsigned int *)(*(void *)(a1 + 608) + 32);
}

uint64_t _cg_jpeg_finish_decompress(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 36);
  if ((v2 - 205) > 1 || *(_DWORD *)(a1 + 88))
  {
    if (v2 == 210) {
      goto LABEL_10;
    }
    if (v2 != 207)
    {
      int v3 = *(void (***)(uint64_t))a1;
      *((_DWORD *)v3 + 10) = 21;
      *((_DWORD *)v3 + 12) = v2;
      (**(void (***)(uint64_t))a1)(a1);
      goto LABEL_10;
    }
  }
  else
  {
    if (*(_DWORD *)(a1 + 168) < *(_DWORD *)(a1 + 140))
    {
      int v4 = *(void (***)(uint64_t))a1;
      *((_DWORD *)v4 + 10) = 69;
      (*v4)(a1);
    }
    (*(void (**)(uint64_t))(*(void *)(a1 + 576) + 8))(a1);
  }
  *(_DWORD *)(a1 + 36) = 210;
LABEL_10:
  while (1)
  {
    uint64_t v5 = *(void *)(a1 + 608);
    if (*(_DWORD *)(v5 + 36)) {
      break;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t))v5)(a1);
    if (!result) {
      return result;
    }
  }
  (*(void (**)(uint64_t))(*(void *)(a1 + 40) + 48))(a1);
  _cg_jpeg_abort(a1);
  return 1;
}

uint64_t _cg_jinit_upsampler(uint64_t *a1)
{
  uint64_t result = (*(uint64_t (**)(void))a1[1])();
  uint64_t v3 = result;
  a1[80] = result;
  *(void *)uint64_t result = start_pass_upsample;
  *(void *)(result + 8) = sep_upsample;
  *(_DWORD *)(result + 16) = 0;
  if (*((_DWORD *)a1 + 100))
  {
    uint64_t v4 = *a1;
    *(_DWORD *)(v4 + 40) = 26;
    uint64_t result = (*(uint64_t (**)(uint64_t *))v4)(a1);
  }
  if (*((int *)a1 + 14) >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = v3 + 192;
    int v7 = (void *)(v3 + 104);
    int v8 = (int *)(a1[38] + 36);
    do
    {
      int v9 = *((_DWORD *)a1 + 106);
      int v10 = *(v8 - 7);
      int v11 = *v8;
      int v12 = v8[1] * *(v8 - 6) / *((_DWORD *)a1 + 107);
      int v13 = *((_DWORD *)a1 + 104);
      int v14 = *((_DWORD *)a1 + 105);
      *(_DWORD *)(v6 + 4 * v5) = v12;
      if (v8[4])
      {
        int v15 = v11 * v10 / v9;
        if (v15 != v13 || v12 != v14)
        {
          if (2 * v15 == v13 && v12 == v14)
          {
            uint64_t v22 = h2v1_upsample;
          }
          else
          {
            if (2 * v15 != v13 || 2 * v12 != v14)
            {
              int v19 = v13 / v15;
              if (v13 % v15 || (int v20 = v14 / v12, v14 % v12))
              {
                uint64_t v21 = *a1;
                *(_DWORD *)(v21 + 40) = 39;
                (*(void (**)(uint64_t *))v21)(a1);
              }
              else
              {
                *int v7 = int_upsample;
                uint64_t v25 = v6 + v5;
                *(unsigned char *)(v25 + 40) = v19;
                *(unsigned char *)(v25 + 50) = v20;
              }
              goto LABEL_25;
            }
            uint64_t v22 = h2v2_upsample;
          }
          *int v7 = v22;
LABEL_25:
          uint64_t v23 = *(uint64_t (**)(uint64_t *, uint64_t, uint64_t, void))(a1[1] + 16);
          uint64_t v24 = _cg_jround_up(*((unsigned int *)a1 + 34), *((int *)a1 + 104));
          uint64_t result = v23(a1, 1, v24, *((unsigned int *)a1 + 105));
          *(v7 - 10) = result;
          goto LABEL_26;
        }
        int v16 = fullsize_upsample;
      }
      else
      {
        int v16 = noop_upsample;
      }
      *int v7 = v16;
LABEL_26:
      v8 += 24;
      ++v5;
      ++v7;
    }
    while (v5 < *((int *)a1 + 14));
  }
  return result;
}

uint64_t start_pass_upsample(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 640);
  int v2 = *(_DWORD *)(result + 140);
  *(_DWORD *)(v1 + 184) = *(_DWORD *)(result + 420);
  *(_DWORD *)(v1 + 188) = v2;
  return result;
}

uint64_t sep_upsample(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, _DWORD *a6, int a7)
{
  uint64_t v11 = *(void *)(a1 + 640);
  int v12 = *(_DWORD *)(v11 + 184);
  int v13 = *(_DWORD *)(a1 + 420);
  if (v12 >= v13)
  {
    if (*(int *)(a1 + 56) >= 1)
    {
      uint64_t v15 = 0;
      uint64_t v16 = *(void *)(a1 + 304);
      uint64_t v17 = (void (**)(uint64_t, uint64_t, uint64_t, void))(v11 + 104);
      do
      {
        uint64_t v18 = v17 - 10;
        int v19 = *v17++;
        v19(a1, v16, *(void *)(a2 + 8 * v15) + 8 * (*(_DWORD *)(v11 + 192 + 4 * v15) * *a3), v18);
        ++v15;
        v16 += 96;
      }
      while (v15 < *(int *)(a1 + 56));
      int v13 = *(_DWORD *)(a1 + 420);
    }
    int v12 = 0;
    *(_DWORD *)(v11 + 184) = 0;
  }
  unsigned int v20 = v13 - v12;
  if (v20 >= *(_DWORD *)(v11 + 188)) {
    unsigned int v20 = *(_DWORD *)(v11 + 188);
  }
  if (v20 >= a7 - *a6) {
    unsigned int v21 = a7 - *a6;
  }
  else {
    unsigned int v21 = v20;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 648) + 8))(a1, v11 + 24);
  *a6 += v21;
  unsigned int v23 = *(_DWORD *)(v11 + 188) - v21;
  signed int v24 = *(_DWORD *)(v11 + 184) + v21;
  *(_DWORD *)(v11 + 184) = v24;
  *(_DWORD *)(v11 + 188) = v23;
  if (v24 >= *(_DWORD *)(a1 + 420)) {
    ++*a3;
  }
  return result;
}

void noop_upsample(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  *a4 = 0;
}

void fullsize_upsample(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  *a4 = a3;
}

uint64_t h2v1_upsample(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  int v4 = *(_DWORD *)(result + 420);
  if (v4 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *a4;
    do
    {
      uint64_t v7 = *(unsigned int *)(result + 136);
      if (v7)
      {
        int v8 = *(unsigned char **)(v6 + 8 * v5);
        int v9 = &v8[v7];
        int v10 = *(char **)(a3 + 8 * v5);
        do
        {
          char v11 = *v10++;
          *int v8 = v11;
          v8[1] = v11;
          v8 += 2;
        }
        while (v8 < v9);
        int v4 = *(_DWORD *)(result + 420);
      }
      ++v5;
    }
    while (v5 < v4);
  }
  return result;
}

char *h2v2_upsample(char *result, uint64_t a2, uint64_t a3, char **a4)
{
  if (*((int *)result + 105) >= 1)
  {
    uint64_t v5 = result;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    int v8 = *a4;
    do
    {
      uint64_t v9 = *((unsigned int *)v5 + 34);
      if (v9)
      {
        int v10 = *(unsigned char **)&v8[8 * v7];
        char v11 = &v10[v9];
        int v12 = *(char **)(a3 + 8 * v6);
        do
        {
          char v13 = *v12++;
          unsigned char *v10 = v13;
          v10[1] = v13;
          v10 += 2;
        }
        while (v10 < v11);
        size_t v14 = *((unsigned int *)v5 + 34);
      }
      else
      {
        size_t v14 = 0;
      }
      uint64_t result = _cg_jcopy_sample_rows(v8, v7, (uint64_t)v8, v7 | 1, 1, v14);
      ++v6;
      v7 += 2;
    }
    while (*((_DWORD *)v5 + 105) > (int)v7);
  }
  return result;
}

void *int_upsample(void *result, uint64_t a2, uint64_t a3, char **a4)
{
  if (*((int *)result + 105) >= 1)
  {
    int v4 = result;
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = *a4;
    uint64_t v8 = result[80] + *(int *)(a2 + 4);
    uint64_t v9 = *(unsigned __int8 *)(v8 + 242);
    size_t v10 = *(unsigned __int8 *)(v8 + 232);
    do
    {
      uint64_t v11 = *((unsigned int *)v4 + 34);
      if (v11)
      {
        int v12 = *(char **)&v7[8 * v6];
        char v13 = &v12[v11];
        size_t v14 = *(unsigned __int8 **)(a3 + 8 * v5);
        do
        {
          if (v10)
          {
            uint64_t result = memset(v12, *v14, v10);
            v12 += (v10 - 1) + 1;
          }
          ++v14;
        }
        while (v12 < v13);
      }
      if (v9 >= 2) {
        uint64_t result = _cg_jcopy_sample_rows(v7, v6, (uint64_t)v7, (int)v6 + 1, (int)v9 - 1, *((unsigned int *)v4 + 34));
      }
      ++v5;
      v6 += v9;
    }
    while (*((_DWORD *)v4 + 105) > (int)v6);
  }
  return result;
}

uint64_t _cg_jinit_d_post_controller(uint64_t a1, int a2)
{
  uint64_t result = (**(uint64_t (***)(void))(a1 + 8))();
  *(void *)(a1 + 600) = result;
  *(void *)uint64_t result = start_pass_dpost;
  *(void *)(result + 16) = 0;
  *(void *)(result + 24) = 0;
  if (*(_DWORD *)(a1 + 108))
  {
    uint64_t v5 = result;
    uint64_t v6 = *(unsigned int *)(a1 + 420);
    *(_DWORD *)(result + 32) = v6;
    uint64_t v7 = *(void *)(a1 + 8);
    int v8 = *(_DWORD *)(a1 + 136);
    int v9 = *(_DWORD *)(a1 + 144);
    uint64_t v10 = (v9 * v8);
    if (a2)
    {
      uint64_t v11 = *(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, void))(v7 + 32);
      uint64_t v12 = _cg_jround_up(*(unsigned int *)(a1 + 140), v6);
      uint64_t result = v11(a1, 1, 0, v10, v12, *(unsigned int *)(v5 + 32));
      *(void *)(v5 + 16) = result;
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))(v7 + 16))(a1, 1, (v9 * v8));
      *(void *)(v5 + 24) = result;
    }
  }
  return result;
}

uint64_t start_pass_dpost(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 600);
  if (a2 == 3)
  {
    if (!*(void *)(v2 + 16))
    {
      uint64_t v3 = *(void *)result;
      *(_DWORD *)(v3 + 40) = 3;
      uint64_t result = (*(uint64_t (**)(uint64_t))v3)(result);
    }
    int v4 = post_process_prepass;
    goto LABEL_13;
  }
  if (a2 == 2)
  {
    if (!*(void *)(v2 + 16))
    {
      uint64_t v5 = *(void *)result;
      *(_DWORD *)(v5 + 40) = 3;
      uint64_t result = (*(uint64_t (**)(uint64_t))v5)(result);
    }
    int v4 = post_process_2pass;
LABEL_13:
    *(void *)(v2 + 8) = v4;
    goto LABEL_16;
  }
  if (a2)
  {
    uint64_t v6 = *(void *)result;
    *(_DWORD *)(v6 + 40) = 3;
    uint64_t result = (*(uint64_t (**)(uint64_t))v6)(result);
  }
  else if (*(_DWORD *)(result + 108))
  {
    *(void *)(v2 + 8) = post_process_1pass;
    if (!*(void *)(v2 + 24))
    {
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(result + 8) + 56))();
      *(void *)(v2 + 24) = result;
    }
  }
  else
  {
    *(void *)(v2 + 8) = *(void *)(*(void *)(result + 640) + 8);
  }
LABEL_16:
  *(_DWORD *)(v2 + 36) = 0;
  *(_DWORD *)(v2 + 40) = 0;
  return result;
}

uint64_t post_process_1pass(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v9 = a1[75];
  (*(void (**)(void))(a1[80] + 8))();
  uint64_t result = (*(uint64_t (**)(void *, void, uint64_t, void))(a1[82] + 8))(a1, *(void *)(v9 + 24), a5 + 8 * *a6, 0);
  *a6 = *a6;
  return result;
}

uint64_t post_process_prepass(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v11 = a1[75];
  unsigned int v12 = *(_DWORD *)(v11 + 40);
  if (v12)
  {
    uint64_t v13 = *(void *)(v11 + 24);
  }
  else
  {
    uint64_t v13 = (*(uint64_t (**)(void *, void, void, void, uint64_t))(a1[1] + 56))(a1, *(void *)(v11 + 16), *(unsigned int *)(v11 + 36), *(unsigned int *)(v11 + 32), 1);
    *(void *)(v11 + 24) = v13;
    unsigned int v12 = *(_DWORD *)(v11 + 40);
  }
  uint64_t result = (*(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(a1[80] + 8))(a1, a2, a3, a4, v13, v11 + 40, *(unsigned int *)(v11 + 32));
  unsigned int v15 = *(_DWORD *)(v11 + 40);
  uint64_t v16 = v15 - v12;
  if (v15 > v12)
  {
    uint64_t result = (*(uint64_t (**)(void *, uint64_t, void, uint64_t))(a1[82] + 8))(a1, *(void *)(v11 + 24) + 8 * v12, 0, v16);
    *a6 += v16;
    unsigned int v15 = *(_DWORD *)(v11 + 40);
  }
  unsigned int v17 = *(_DWORD *)(v11 + 32);
  if (v15 >= v17) {
    *(void *)(v11 + 36) = *(_DWORD *)(v11 + 36) + v17;
  }
  return result;
}

uint64_t post_process_2pass(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, int a7)
{
  uint64_t v11 = *(void *)(a1 + 600);
  unsigned int v12 = *(_DWORD *)(v11 + 40);
  if (v12)
  {
    uint64_t v13 = *(void *)(v11 + 24);
  }
  else
  {
    uint64_t v13 = (*(uint64_t (**)(uint64_t, void, void, void, void))(*(void *)(a1 + 8) + 56))(a1, *(void *)(v11 + 16), *(unsigned int *)(v11 + 36), *(unsigned int *)(v11 + 32), 0);
    *(void *)(v11 + 24) = v13;
    unsigned int v12 = *(_DWORD *)(v11 + 40);
  }
  unsigned int v14 = *(_DWORD *)(v11 + 32) - v12;
  uint64_t v15 = *a6;
  if (v14 >= a7 - (int)v15) {
    unsigned int v14 = a7 - v15;
  }
  unsigned int v16 = *(_DWORD *)(a1 + 140) - *(_DWORD *)(v11 + 36);
  if (v14 >= v16) {
    uint64_t v17 = v16;
  }
  else {
    uint64_t v17 = v14;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 656) + 8))(a1, v13 + 8 * v12, a5 + 8 * v15, v17);
  *a6 += v17;
  unsigned int v19 = *(_DWORD *)(v11 + 40) + v17;
  *(_DWORD *)(v11 + 40) = v19;
  unsigned int v20 = *(_DWORD *)(v11 + 32);
  if (v19 >= v20) {
    *(void *)(v11 + 36) = *(_DWORD *)(v11 + 36) + v20;
  }
  return result;
}

void *KTX2ReadPlugin::KTX2ReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result = (void *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *uint64_t result = &unk_1ED4E2A08;
  result[55] = 0;
  return result;
}

void KTX2ReadPlugin::KTX2ReadPlugin(uint64_t a1, uint64_t a2)
{
}

void KTX2ReadPlugin::~KTX2ReadPlugin(KTX2ReadPlugin *this)
{
  *(void *)this = &unk_1ED4E2A08;
  uint64_t v2 = *((void *)this + 55);
  if (v2) {
    (**(void (***)(void))(v2 + 8))();
  }

  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  uint64_t vars8;

  KTX2ReadPlugin::~KTX2ReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t KTX2ReadPlugin::loadDataFromXPCObject(KTX2ReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_ktx", &length);
    if (length == 32)
    {
      uint64_t v6 = data;
      uint64_t result = 0;
      long long v7 = v6[1];
      *(_OWORD *)((char *)this + 440) = *v6;
      *(_OWORD *)((char *)this + 456) = v7;
      *((void *)this + 55) = 0;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t KTX2ReadPlugin::saveDataToXPCObject(KTX2ReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_ktx", (char *)this + 440, 0x20uLL);
  }
  return v4;
}

uint64_t KTX2ReadPlugin::initialize(KTX2ReadPlugin *this, IIODictionary *a2)
{
  uint64_t v24 = 0;
  memset(v23, 0, sizeof(v23));
  IIOScanner::IIOScanner((IIOScanner *)v23, *((IIOImageReadSession **)this + 3));
  uint64_t v22 = 0;
  if (!*((unsigned char *)this + 341)) {
    goto LABEL_19;
  }
  uint64_t KTXTexture = CreateKTXTexture(*((IIOImageReadSession **)this + 3));
  uint64_t v4 = KTXTexture;
  if (!KTXTexture) {
    goto LABEL_19;
  }
  *(void *)((char *)this + 228) = *(void *)(KTXTexture + 36);
  *((_WORD *)this + 120) = 8;
  if (!GetKtx2FormatInfo(*(_DWORD *)(KTXTexture + 120), &v22)) {
    goto LABEL_19;
  }
  uint64_t v5 = v22;
  *((_WORD *)this + 120) = v22[1];
  if ((v5[12] & 2) != 0) {
    *((unsigned char *)this + 345) = 1;
  }
  int v6 = *v5;
  if (v6 == 3)
  {
    char v7 = 5;
  }
  else
  {
    if (v6 != 4)
    {
      *((unsigned char *)this + 246) = 5;
      int v8 = (CFStringRef *)MEMORY[0x1E4F1DC18];
      goto LABEL_14;
    }
    char v7 = 3;
  }
  *((unsigned char *)this + 246) = v7;
  if (*((unsigned char *)this + 345)) {
    int v8 = (CFStringRef *)MEMORY[0x1E4F1DBE0];
  }
  else {
    int v8 = (CFStringRef *)MEMORY[0x1E4F1DC98];
  }
LABEL_14:
  *((void *)this + 20) = CGColorSpaceCreateWithName(*v8);
  *((_DWORD *)this + 81) = 1380401696;
  unsigned int v9 = *((_DWORD *)this + 57);
  unsigned int v10 = *((_DWORD *)this + 58);
  uint64_t v11 = *v22;
  if (v10 * (unint64_t)v9 * v11 > (unint64_t)IIOImageReadSession::getSize(*((IIOImageReadSession **)this
                                                                                         + 3)))
  {
    uint64_t v17 = *((unsigned int *)this + 57);
    uint64_t v18 = *((unsigned int *)this + 58);
    uint64_t v19 = *v22;
    unsigned int Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
    _cg_jpeg_mem_term("initialize", 153, "*** bad KTX: [%ldx%ld]  channels: %ld  fileSize: %d\n", v17, v18, v19, Size);
LABEL_19:
    kdebug_trace();
    uint64_t v15 = 4294967246;
    goto LABEL_20;
  }
  unsigned int v12 = *((unsigned __int16 *)this + 120);
  *((_WORD *)this + 121) = 4 * v12;
  *((_WORD *)this + 122) = 4;
  *((unsigned char *)this + 346) = 0;
  *((void *)this + 55) = v4;
  unsigned int v13 = *((_DWORD *)this + 57);
  if (v13 >> 30) {
    goto LABEL_19;
  }
  unint64_t v14 = 4 * v13 * (unint64_t)(v12 >> 3);
  if ((v14 & 0xFFFFFFFF00000000) != 0) {
    goto LABEL_19;
  }
  uint64_t v15 = 0;
  *((_DWORD *)this + 59) = v14;
  unsigned int v16 = v22;
  *((void *)this + 56) = *v22;
  *((void *)this + 57) = 4;
  *((_DWORD *)this + 116) = *((_DWORD *)v16 + 5);
  *((_WORD *)this + 188) = 1;
LABEL_20:
  IIOScanner::~IIOScanner((IIOScanner *)v23);
  return v15;
}

void sub_1886CBB88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

uint64_t KTX2ReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12) {
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2);
  }
  if (v2 == 1) {
    return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

IOSurfaceRef *KTX2ReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *BlockArray)
{
  v82[0] = 0;
  unint64_t v9 = *((void *)this + 56);
  unint64_t v8 = *((void *)this + 57);
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v10 = *((_DWORD *)this + 51);
    unsigned int v11 = v10 >> 24;
    uint64_t v12 = MEMORY[0x1E4F14390];
    if (v10 < 0)
    {
      int v13 = __maskrune(v11, 0x40000uLL);
      int v10 = *((_DWORD *)this + 51);
    }
    else
    {
      int v13 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v11 + 60) & 0x40000;
    }
    if (v13) {
      uint64_t v14 = (v10 >> 24);
    }
    else {
      uint64_t v14 = 46;
    }
    unsigned int v15 = v10 << 8 >> 24;
    if (v10 << 8 < 0)
    {
      int v16 = __maskrune(v15, 0x40000uLL);
      int v10 = *((_DWORD *)this + 51);
    }
    else
    {
      int v16 = *(_DWORD *)(v12 + 4 * v15 + 60) & 0x40000;
    }
    if (v16) {
      uint64_t v17 = (v10 << 8 >> 24);
    }
    else {
      uint64_t v17 = 46;
    }
    unsigned int v18 = (__int16)v10 >> 8;
    unint64_t v19 = v8;
    if (v10 << 16 < 0)
    {
      int v20 = __maskrune(v18, 0x40000uLL);
      int v10 = *((_DWORD *)this + 51);
    }
    else
    {
      int v20 = *(_DWORD *)(v12 + 4 * v18 + 60) & 0x40000;
    }
    if (v20) {
      uint64_t v21 = ((__int16)v10 >> 8);
    }
    else {
      uint64_t v21 = 46;
    }
    if ((v10 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v12 + 4 * (char)v10 + 60) & 0x40000) != 0) {
        goto LABEL_22;
      }
    }
    else if (__maskrune((char)v10, 0x40000uLL))
    {
LABEL_22:
      int v22 = *((_DWORD *)this + 51);
LABEL_25:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v14, v17, v21, (char)v22, iioTypeStr[a3], "virtual OSStatus KTX2ReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      unint64_t v8 = v19;
      goto LABEL_26;
    }
    LOBYTE(v22) = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  unsigned int v23 = (IIOImageRead **)*((void *)this + 3);
  if (v23) {
    IIOImageReadSession::mapData(v23);
  }
  if (a3 == 3)
  {
    uint64_t v73 = BlockArray;
    BlockArray = (IOSurfaceRef *)IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v30) = *((_DWORD *)this + 73);
    double v29 = (double)v30;
    unsigned int v31 = *((_DWORD *)this + 74);
    double v28 = (double)v31;
    memory_object_size_t v27 = *((unsigned int *)this + 75) * (unint64_t)v31;
    BaseAddress = (char *)_ImageIO_Malloc(v27, *((void *)this + 48), v82, (uint64_t)kImageMalloc_KTX2_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1) {
      return 0;
    }
    if (!BlockArray) {
      return BlockArray;
    }
    if (!*BlockArray) {
      return 0;
    }
    IOSurfaceLock(*BlockArray, 0, 0);
    BaseAddress = (char *)IOSurfaceGetBaseAddress(*BlockArray);
    size_t Height = IOSurfaceGetHeight(*BlockArray);
    uint64_t v73 = BlockArray;
    size_t BytesPerRow = IOSurfaceGetBytesPerRow(*BlockArray);
    BlockArray = 0;
    memory_object_size_t v27 = BytesPerRow * Height;
    v82[0] = v27;
    double v28 = 0.0;
    double v29 = 0.0;
  }
  if (!BaseAddress) {
    return BlockArray;
  }
  vImagePixelCount v32 = *((unsigned int *)this + 73);
  vImagePixelCount v33 = *((unsigned int *)this + 74);
  uint64_t v34 = BaseAddress;
  if (v9 >= v8
    || (uint64_t v34 = (char *)malloc_type_calloc(*((unsigned int *)this + 74), *((unsigned int *)this + 75), 0x4760B7BCuLL)) != 0)
  {
    uint64_t v74 = v34;
    uint64_t v75 = BaseAddress;
    int v72 = a3;
    int v78 = *((_DWORD *)this + 52);
    uint64_t v79 = v34;
    memory_object_size_t v80 = v27;
    mach_vm_size_t v69 = v27;
    uint64_t v81 = 0;
    uint64_t KTXTexture = *((void *)this + 55);
    if (!KTXTexture)
    {
      uint64_t KTXTexture = CreateKTXTexture(*((IIOImageReadSession **)this + 3));
      *((void *)this + 55) = KTXTexture;
    }
    (*(void (**)(void))(*(void *)(KTXTexture + 8) + 40))();
    unint64_t v70 = v8;
    unint64_t v71 = v9;
    if (v9 < v8)
    {
      uint64_t v36 = *((void *)this + 56);
      int v37 = *((unsigned __int16 *)this + 120);
      if (v36 == 3 && v37 == 8)
      {
        dest.data = v74;
        dest.height = v33;
        dest.width = v32;
        dest.rowBytes = (3 * v32 + 3) & 0x7FFFFFFFCLL;
        v76.data = BaseAddress;
        v76.height = v33;
        v76.width = v32;
        v76.rowBytes = 4 * v32;
        vImageConvert_RGB888toRGBA8888(&dest, 0, 0xFFu, &v76, 0, 0);
      }
      else if (v37 == 32)
      {
        if (*((unsigned char *)this + 345)) {
          int v55 = 1006632960;
        }
        else {
          int v55 = -1;
        }
        if (v33)
        {
          int v56 = 0;
          size_t v57 = (4 * v36);
          size_t v58 = (12 - 4 * v36);
          uint64_t v59 = v74;
          uint64_t v60 = BaseAddress;
          do
          {
            for (int i = v32; i; --i)
            {
              memcpy(v60, v59, v57);
              if (v57 != 12) {
                bzero(&v60[4 * *((void *)this + 56)], v58);
              }
              *((_DWORD *)v60 + 3) = v55;
              v59 += 4 * *((void *)this + 56);
              v60 += 16;
            }
            ++v56;
          }
          while (v56 != v33);
        }
      }
      else if (v37 == 16)
      {
        if (*((unsigned char *)this + 345)) {
          __int16 v62 = 15360;
        }
        else {
          __int16 v62 = -1;
        }
        if (v33)
        {
          int v63 = 0;
          size_t v64 = (2 * v36);
          size_t v65 = (6 - 2 * v36);
          uint64_t v66 = v74;
          uint64_t v67 = BaseAddress;
          do
          {
            for (int j = v32; j; --j)
            {
              memcpy(v67, v66, v64);
              if (v64 != 6) {
                bzero(&v67[2 * *((void *)this + 56)], v65);
              }
              *((_WORD *)v67 + 3) = v62;
              v66 += 2 * *((void *)this + 56);
              v67 += 8;
            }
            ++v63;
          }
          while (v63 != v33);
        }
      }
      else if (v37 == 8 && v33)
      {
        int v45 = 0;
        size_t v46 = (3 - v36);
        size_t v47 = *((void *)this + 56);
        uint64_t v49 = v74;
        int v48 = BaseAddress;
        do
        {
          for (int k = v32; k; --k)
          {
            memcpy(v48, v49, v47);
            if (v47 != 3) {
              bzero(&v48[*((void *)this + 56)], v46);
            }
            v48[3] = -1;
            v49 += *((void *)this + 56);
            v48 += 4;
          }
          ++v45;
        }
        while (v45 != v33);
      }
    }
    a3 = v72;
    BaseAddress = v75;
    if (*((_WORD *)this + 153) != 32 || *((_WORD *)this + 152) != 8) {
      goto LABEL_50;
    }
    dest.data = v75;
    uint64_t v38 = *(void *)((char *)this + 292);
    v39.i64[0] = v38;
    v39.i64[1] = HIDWORD(v38);
    *(int8x16_t *)&dest.height = vextq_s8(v39, v39, 8uLL);
    dest.rowBytes = *((unsigned int *)this + 75);
    int v40 = *((_DWORD *)this + 116);
    if (*((unsigned char *)this + 405))
    {
      if (v40 != 1) {
        goto LABEL_48;
      }
    }
    else if (v40)
    {
LABEL_48:
      if (*((unsigned char *)this + 406) == 1) {
        vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
      }
LABEL_50:
      if (v72 == 3)
      {
        uint64_t v43 = 0;
        v83.origin.x = 0.0;
        v83.origin.y = 0.0;
        v83.size.width = v29;
        v83.size.height = v28;
        **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, v75, v69, v83, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
        if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E4F1DB20]))
        {
          uint64_t v44 = 0;
        }
        else
        {
          v84.origin.x = 0.0;
          v84.origin.y = 0.0;
          v84.size.width = v29;
          v84.size.height = v28;
          *(CGRect *)(&v44 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v84);
          uint64_t v43 = v51;
          double v29 = v52;
          double v28 = v53;
        }
        unint64_t v41 = v71;
        uint64_t v42 = v74;
        BaseAddress = 0;
        *((void *)this + 15) = v43;
        *((void *)this + 16) = v44;
        *((double *)this + 17) = v29;
        *((double *)this + 18) = v28;
      }
      else
      {
        unint64_t v41 = v71;
        IOSurfaceUnlock(*v73, 0, 0);
        uint64_t v42 = v74;
      }
      BlockArray = 0;
      if (v41 < v70)
      {
        free(v42);
        BlockArray = 0;
      }
      goto LABEL_70;
    }
    LODWORD(v76.data) = 50331906;
    vImagePermuteChannels_ARGB8888(&dest, &dest, (const uint8_t *)&v76, 0x10u);
    goto LABEL_48;
  }
LABEL_70:
  if (a3 == 3 && BaseAddress) {
    _ImageIO_Free((unint64_t)BaseAddress, v82[0]);
  }
  return BlockArray;
}

uint64_t _cg_jpeg_start_decompress(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 36);
  if (v2 == 204) {
    goto LABEL_22;
  }
  if (v2 != 203)
  {
    if (v2 != 202)
    {
      uint64_t v4 = *(void (***)(void))a1;
      *((_DWORD *)v4 + 10) = 21;
      *((_DWORD *)v4 + 12) = v2;
      (**(void (***)(uint64_t))a1)(a1);
LABEL_22:
      return output_pass_setup(a1);
    }
    _cg_jinit_master_decompress(a1);
    if (*(_DWORD *)(a1 + 88))
    {
      *(_DWORD *)(a1 + 36) = 207;
      return 1;
    }
    *(_DWORD *)(a1 + 36) = 203;
  }
  if (!*(_DWORD *)(*(void *)(a1 + 608) + 32))
  {
LABEL_21:
    *(_DWORD *)(a1 + 180) = *(_DWORD *)(a1 + 172);
    goto LABEL_22;
  }
  uint64_t v5 = *(void *)(a1 + 16);
  while (1)
  {
    if (v5) {
      (*(void (**)(uint64_t))v5)(a1);
    }
    uint64_t result = (**(uint64_t (***)(uint64_t))(a1 + 608))(a1);
    if (!result) {
      return result;
    }
    if (result == 2) {
      goto LABEL_21;
    }
    uint64_t v5 = *(void *)(a1 + 16);
    if ((result & 0xFFFFFFFD) == 1 && v5 != 0)
    {
      uint64_t v7 = *(void *)(v5 + 16);
      uint64_t v8 = *(void *)(v5 + 8) + 1;
      *(void *)(v5 + 8) = v8;
      if (v8 >= v7) {
        *(void *)(v5 + 16) = v7 + *(unsigned int *)(a1 + 432);
      }
    }
  }
}

uint64_t output_pass_setup(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 36) != 204)
  {
    (**(void (***)(uint64_t))(a1 + 576))(a1);
    *(_DWORD *)(a1 + 168) = 0;
    *(_DWORD *)(a1 + 36) = 204;
  }
  if (*(_DWORD *)(*(void *)(a1 + 576) + 16))
  {
    unint64_t v2 = *(unsigned int *)(a1 + 168);
    do
    {
      while (1)
      {
        unint64_t v3 = *(unsigned int *)(a1 + 140);
        if (v2 < v3) {
          break;
        }
        (*(void (**)(uint64_t))(*(void *)(a1 + 576) + 8))(a1);
        (**(void (***)(uint64_t))(a1 + 576))(a1);
        unint64_t v2 = 0;
        *(_DWORD *)(a1 + 168) = 0;
        if (!*(_DWORD *)(*(void *)(a1 + 576) + 16)) {
          goto LABEL_12;
        }
      }
      uint64_t v4 = *(void *)(a1 + 16);
      if (v4)
      {
        *(void *)(v4 + 8) = v2;
        *(void *)(v4 + 16) = v3;
        (*(void (**)(uint64_t))v4)(a1);
        unint64_t v2 = *(unsigned int *)(a1 + 168);
      }
      (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)(a1 + 584) + 8))(a1, 0, a1 + 168, 0);
      BOOL v5 = *(unsigned int *)(a1 + 168) == v2;
      unint64_t v2 = *(unsigned int *)(a1 + 168);
    }
    while (!v5);
    return 0;
  }
  else
  {
LABEL_12:
    if (*(_DWORD *)(a1 + 92)) {
      int v6 = 206;
    }
    else {
      int v6 = 205;
    }
    *(_DWORD *)(a1 + 36) = v6;
    return 1;
  }
}

uint64_t _cg_jpeg_read_scanlines(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a1 + 36);
  if (v6 != 205)
  {
    uint64_t v7 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v7 + 10) = 21;
    *((_DWORD *)v7 + 12) = v6;
    (**(void (***)(uint64_t))a1)(a1);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 168);
  uint64_t v9 = *(unsigned int *)(a1 + 140);
  if (v8 >= v9)
  {
    uint64_t v12 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v12 + 10) = 126;
    ((void (*)(uint64_t, uint64_t))v12[1])(a1, 0xFFFFFFFFLL);
    return 0;
  }
  else
  {
    uint64_t v10 = *(void *)(a1 + 16);
    if (v10)
    {
      *(void *)(v10 + 8) = v8;
      *(void *)(v10 + 16) = v9;
      (*(void (**)(uint64_t))v10)(a1);
    }
    unsigned int v13 = 0;
    (*(void (**)(uint64_t, uint64_t, unsigned int *, uint64_t))(*(void *)(a1 + 584) + 8))(a1, a2, &v13, a3);
    uint64_t result = v13;
    *(_DWORD *)(a1 + 168) += v13;
  }
  return result;
}

uint64_t _cg_jpeg_read_raw_data(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v6 = *(_DWORD *)(a1 + 36);
  if (v6 != 206)
  {
    uint64_t v7 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v7 + 10) = 21;
    *((_DWORD *)v7 + 12) = v6;
    (**(void (***)(uint64_t))a1)(a1);
  }
  uint64_t v8 = *(unsigned int *)(a1 + 168);
  uint64_t v9 = *(unsigned int *)(a1 + 140);
  if (v8 >= v9)
  {
    unsigned int v13 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v13 + 10) = 126;
    ((void (*)(uint64_t, uint64_t))v13[1])(a1, 0xFFFFFFFFLL);
    return 0;
  }
  uint64_t v10 = *(void *)(a1 + 16);
  if (v10)
  {
    *(void *)(v10 + 8) = v8;
    *(void *)(v10 + 16) = v9;
    (*(void (**)(uint64_t))v10)(a1);
  }
  uint64_t v11 = (*(_DWORD *)(a1 + 428) * *(_DWORD *)(a1 + 420));
  if (v11 > a3)
  {
    uint64_t v12 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v12 + 10) = 24;
    (*v12)(a1);
  }
  if (!(*(unsigned int (**)(uint64_t, uint64_t))(*(void *)(a1 + 592) + 24))(a1, a2)) {
    return 0;
  }
  *(_DWORD *)(a1 + 168) += v11;
  return v11;
}

uint64_t _cg_jpeg_start_output(uint64_t a1, int a2)
{
  int v4 = *(_DWORD *)(a1 + 36);
  if (v4 != 204 && v4 != 207)
  {
    BOOL v5 = *(void (***)(void))a1;
    *((_DWORD *)v5 + 10) = 21;
    *((_DWORD *)v5 + 12) = v4;
    (**(void (***)(uint64_t))a1)(a1);
  }
  if (a2 <= 1) {
    int v6 = 1;
  }
  else {
    int v6 = a2;
  }
  if (*(_DWORD *)(*(void *)(a1 + 608) + 36) && v6 >= *(_DWORD *)(a1 + 172)) {
    int v6 = *(_DWORD *)(a1 + 172);
  }
  *(_DWORD *)(a1 + 180) = v6;

  return output_pass_setup(a1);
}

uint64_t _cg_jpeg_finish_output(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 36);
  if ((v2 - 205) > 1)
  {
    if (v2 == 208) {
      goto LABEL_6;
    }
LABEL_5:
    unint64_t v3 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v3 + 10) = 21;
    *((_DWORD *)v3 + 12) = v2;
    (**(void (***)(uint64_t))a1)(a1);
    goto LABEL_6;
  }
  if (!*(_DWORD *)(a1 + 88)) {
    goto LABEL_5;
  }
  (*(void (**)(uint64_t))(*(void *)(a1 + 576) + 8))(a1);
  *(_DWORD *)(a1 + 36) = 208;
LABEL_6:
  while (*(_DWORD *)(a1 + 172) <= *(_DWORD *)(a1 + 180))
  {
    uint64_t v4 = *(void *)(a1 + 608);
    if (*(_DWORD *)(v4 + 36)) {
      break;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t))v4)(a1);
    if (!result) {
      return result;
    }
  }
  *(_DWORD *)(a1 + 36) = 207;
  return 1;
}

uint64_t _cg_jpeg_idct_float(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  memset(v74, 0, sizeof(v74));
  int v6 = (__int16 *)(a3 + 64);
  uint64_t v7 = *(void *)(a2 + 88) + 128;
  unsigned int v8 = 9;
  uint64_t v9 = *(void *)(result + 440);
  do
  {
    uint64_t v10 = (float *)(v7 + v5);
    int v11 = (unsigned __int16)*(v6 - 24);
    int v12 = (unsigned __int16)*(v6 - 16);
    if (v11 | v12) {
      goto LABEL_9;
    }
    if (*(v6 - 8) || *v6 || v6[8] || v6[16] || v6[24])
    {
      LOWORD(v12) = 0;
LABEL_9:
      float v13 = *(v10 - 32) * (float)*(v6 - 32);
      float v14 = *(v10 - 16) * (float)(__int16)v12;
      float v15 = *v10 * (float)*v6;
      float v16 = v10[16] * (float)v6[16];
      float v17 = v13 + v15;
      float v18 = v13 - v15;
      float v19 = v14 + v16;
      float v20 = -(float)((float)(v14 + v16) - (float)((float)(v14 - v16) * 1.4142));
      float v21 = v17 + v19;
      float v22 = v17 - v19;
      float v23 = v18 + v20;
      float v24 = v18 - v20;
      float v25 = *(v10 - 24) * (float)(__int16)v11;
      float v26 = *(v10 - 8) * (float)*(v6 - 8);
      float v27 = v10[8] * (float)v6[8];
      float v28 = v10[24] * (float)v6[24];
      float v29 = v26 + v27;
      float v30 = v27 - v26;
      float v31 = v25 + v28;
      float v32 = v25 - v28;
      float v33 = v29 + v31;
      float v34 = (float)(v31 - v29) * 1.4142;
      float v35 = (float)(v30 + v32) * 1.8478;
      float v36 = (float)(v35 + (float)(v30 * -2.6131)) - v33;
      float v37 = v34 - v36;
      float v38 = (float)(v35 + (float)(v32 * -1.0824)) - v37;
      int8x16_t v39 = (float *)((char *)v74 + v5);
      *int8x16_t v39 = v21 + v33;
      v39[56] = v21 - v33;
      v39[8] = v23 + v36;
      v39[48] = v23 - v36;
      v39[16] = v24 + v37;
      v39[40] = v24 - v37;
      v39[24] = v22 + v38;
      float v40 = v22 - v38;
      uint64_t v41 = 8;
      goto LABEL_10;
    }
    float v40 = *(v10 - 32) * (float)*(v6 - 32);
    uint64_t v42 = (float *)((char *)v74 + v5);
    float *v42 = v40;
    v42[8] = v40;
    v42[16] = v40;
    v42[24] = v40;
    v42[32] = v40;
    v42[40] = v40;
    v42[48] = v40;
    uint64_t v41 = 14;
LABEL_10:
    *(float *)((char *)&v74[v41] + v5) = v40;
    --v8;
    v5 += 4;
    ++v6;
  }
  while (v8 > 1);
  uint64_t v43 = 0;
  uint64_t v44 = v9 - 384;
  do
  {
    int v45 = (float *)&v74[v43];
    size_t v46 = (unsigned char *)(*(void *)(a4 + v43 * 4) + a5);
    float v47 = v45[1];
    float v48 = *v45 + 512.5;
    float v49 = v45[4];
    float v50 = v45[5];
    float v51 = v48 + v49;
    float v52 = v45[2];
    float v53 = v45[3];
    float v54 = v45[6];
    float v55 = v45[7];
    float v56 = v52 + v54;
    float v57 = v48 - v49;
    float v58 = -(float)((float)(v52 + v54) - (float)((float)(v52 - v54) * 1.4142));
    float v59 = v50 + v53;
    float v60 = v50 - v53;
    float v61 = v51 + v56;
    float v62 = v51 - v56;
    float v63 = v47 + v55;
    float v64 = v47 - v55;
    float v65 = v59 + v63;
    float v66 = v63 - v59;
    float v67 = v57 + v58;
    float v68 = v57 - v58;
    float v69 = v66 * 1.4142;
    float v70 = (float)(v60 + v64) * 1.8478;
    float v71 = v70 + (float)(v64 * -1.0824);
    float v72 = (float)(v70 + (float)(v60 * -2.6131)) - v65;
    float v73 = v69 - v72;
    unsigned char *v46 = *(unsigned char *)(v44 + ((int)(float)(v61 + v65) & 0x3FFLL));
    v46[7] = *(unsigned char *)(v44 + ((int)(float)(v61 - v65) & 0x3FFLL));
    v46[1] = *(unsigned char *)(v44 + ((int)(float)(v67 + v72) & 0x3FFLL));
    v46[6] = *(unsigned char *)(v44 + ((int)(float)(v67 - v72) & 0x3FFLL));
    v46[2] = *(unsigned char *)(v44 + ((int)(float)(v68 + v73) & 0x3FFLL));
    v46[5] = *(unsigned char *)(v44 + ((int)(float)(v68 - v73) & 0x3FFLL));
    v46[3] = *(unsigned char *)(v44 + ((int)(float)(v62 + (float)(v71 - v73)) & 0x3FFLL));
    v46[4] = *(unsigned char *)(v44 + ((int)(float)(v62 - (float)(v71 - v73)) & 0x3FFLL));
    v43 += 2;
  }
  while (v43 != 16);
  return result;
}

void kdu_encoder::kdu_encoder(void *a1)
{
  *a1 = 0;
  operator new();
}

void sub_1886CCC20(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4018E1C327);
  _Unwind_Resume(a1);
}

int32x4_t *kd_encoder::init(uint64_t a1, int32x4_t *a2, uint64_t a3, int a4, uint64_t a5, kdu_thread_entity *a6, char *a7, float a8)
{
  float v35 = a2;
  if (*(void *)(a1 + 96) || *(void *)(a1 + 136)) {
    kd_encoder::init();
  }
  if (a6) {
    *(void *)(a1 + 136) = kdu_thread_entity::add_queue((uint64_t)a6, a1 + 8, a7, (uint64_t)"block encoder");
  }
  *(void *)(a1 + 24) = a2;
  *(void *)(a1 + 104) = a5;
  *(_WORD *)(a1 + 32) = kdu_subband::get_K_max((kdu_subband *)&v35);
  *(_WORD *)(a1 + 34) = kdu_subband::get_K_max_prime((kdu_subband *)&v35);
  *(unsigned char *)(a1 + 36) = kdu_subband::get_reversible((kdu_subband *)&v35);
  *(unsigned char *)(a1 + 37) = 0;
  *(float *)(a1 + 40) = kdu_subband::get_delta((kdu_subband *)&v35) * a8;
  float msb_wmse = kdu_subband::get_msb_wmse((kdu_subband *)&v35);
  *(_DWORD *)(a1 + 48) = 1065353216;
  *(float *)(a1 + 44) = msb_wmse;
  kdu_subband::get_roi_weight((kdu_subband *)&v35, (float *)(a1 + 48));
  int32x4_t v34 = 0uLL;
  kdu_subband::get_dims(&v35, &v34);
  int32x2_t v32 = 0;
  int32x2_t v33 = 0;
  kdu_subband::get_block_size((uint64_t *)&v35, &v33, &v32);
  uint64_t result = kdu_subband::get_valid_blocks((kdu_subband *)&v35, (int32x4_t *)(a1 + 52));
  __int32 v17 = v34.i32[2];
  *(void *)(a1 + 68) = v34.i64[1];
  __int16 v18 = v33.i16[0];
  *(_WORD *)(a1 + 78) = v32.i16[2];
  *(_WORD *)(a1 + 80) = v33.i16[2];
  *(_WORD *)(a1 + 82) = v18;
  *(unsigned char *)(a1 + 39) = 1;
  if (!a6)
  {
    *(_WORD *)(a1 + 84) = v18;
    float v23 = (_WORD *)(a1 + 84);
    *(_WORD *)(a1 + 76) = 0;
    LOWORD(v20) = v17;
    if (v17 > v18) {
      goto LABEL_23;
    }
    goto LABEL_22;
  }
  uint64_t result = (int32x4_t *)kdu_thread_entity::get_num_threads(a6);
  int v19 = *(__int16 *)(a1 + 82);
  int v20 = *(_DWORD *)(a1 + 68);
  if ((int)result > 1)
  {
    uint64_t v21 = *(__int16 *)(a1 + 82);
    if (v20 < v19) {
      uint64_t v21 = v20;
    }
    unint64_t v22 = (v21 * *(int *)(a1 + 72) + (v21 * *(int *)(a1 + 72) < 0 ? 0x1FFFuLL : 0)) >> 13;
    if (*(_DWORD *)(a1 + 64) <= (int)v22) {
      kd_encoder::init();
    }
    if ((int)v22 <= 1) {
      LODWORD(v22) = 1;
    }
    if (v22 >= 0x20) {
      LOBYTE(v22) = 32;
    }
    *(unsigned char *)(a1 + 39) = v22;
  }
  *(_WORD *)(a1 + 84) = v19;
  float v23 = (_WORD *)(a1 + 84);
  *(_WORD *)(a1 + 76) = 0;
  if (v20 <= v19)
  {
LABEL_22:
    _WORD *v23 = v20;
    goto LABEL_23;
  }
  uint64_t result = (int32x4_t *)kdu_thread_entity::get_num_threads(a6);
  if ((int)result >= 2)
  {
    signed int v24 = 8u / *(unsigned __int8 *)(a1 + 39) + 1;
    uint64_t result = (int32x4_t *)kdu_subband::get_band_idx((kdu_subband *)&v35);
    if ((int)result <= v24)
    {
      __int32 v25 = *(_DWORD *)(a1 + 68) - v32.i32[0];
      if (v25 >= *(__int16 *)(a1 + 82)) {
        LOWORD(v25) = *(_WORD *)(a1 + 82);
      }
      *(_WORD *)(a1 + 84) += v25;
      uint64_t v31 = kdu_node::access_resolution((kdu_node *)&v35);
      uint64_t result = (int32x4_t *)kdu_resolution::get_dwt_level((kdu_resolution *)&v31);
      *(_WORD *)(a1 + 76) = 64 - (_WORD)result;
    }
  }
LABEL_23:
  int v26 = 0;
  *(_WORD *)(a1 + 86) = 0;
  __int32 v27 = v32.i32[1];
  *(_WORD *)(a1 + 88) = v32.i16[0];
  *(_DWORD *)(a1 + 92) = 0;
  *(unsigned char *)(a1 + 38) = 0;
  __int32 v28 = *(_DWORD *)(a1 + 72);
  if (v27 < v28)
  {
    int v29 = -v27;
    if (a4) {
      int v30 = 7;
    }
    else {
      int v30 = 3;
    }
    int v26 = v30 & v29;
    *(unsigned char *)(a1 + 38) = v26;
  }
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 112) = 0;
  if (v34.i32[3] >= 1 && *(uint64_t *)((char *)v34.i64 + 4) > 0)
  {
    *(void *)(a1 + 96) = a3;
    kdu_sample_allocator::pre_alloc(a3, a4, 0, v28 + v26, *(__int16 *)(a1 + 84));
    operator new[]();
  }
  *(_DWORD *)(a1 + 68) = 0;
  return result;
}

void kd_encoder::~kd_encoder(kd_encoder *this)
{
  *(void *)this = &unk_1ED4DE910;
  *((void *)this + 1) = &unk_1ED4DE940;
  uint64_t v2 = *((void *)this + 14);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x20C8093837F09);
  }
  uint64_t v3 = *((void *)this + 15);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x20C8093837F09);
  }
  uint64_t v4 = *((void *)this + 16);
  if (v4) {
    MEMORY[0x18C11C0C0](v4, 0x10C80436913F5);
  }
  uint64_t v5 = *((void *)this + 13);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
  }
  uint64_t v6 = *((void *)this + 2);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  *((void *)this + 1) = &unk_1ED4DE9F0;
  *(void *)this = &unk_1ED4E4510;
}

{
  uint64_t vars8;

  kd_encoder::~kd_encoder(this);

  JUMPOUT(0x18C11C0E0);
}

void non-virtual thunk to'kd_encoder::~kd_encoder(kd_encoder *this)
{
}

{
  uint64_t vars8;

  kd_encoder::~kd_encoder((kd_encoder *)((char *)this - 8));

  JUMPOUT(0x18C11C0E0);
}

uint64_t kd_encoder::push(uint64_t result, int *a2, kdu_thread_entity *this)
{
  uint64_t v5 = result;
  if (!this && *(void *)(result + 136)) {
    kd_encoder::push();
  }
  if (!*a2) {
    return result;
  }
  if (!*(unsigned char *)(result + 37))
  {
    if (this) {
      kdu_thread_entity::acquire_lock(this, 3, 1);
    }
    int v6 = *(__int16 *)(v5 + 84);
    if (*(void *)(v5 + 112))
    {
      if (v6 >= 1)
      {
        uint64_t v7 = 0;
        int v8 = *(unsigned __int8 *)(v5 + 38);
        do
        {
          uint64_t v9 = kdu_sample_allocator::alloc16(*(kdu_sample_allocator **)(v5 + 96), 0, *(_DWORD *)(v5 + 72) + v8);
          int v8 = *(unsigned __int8 *)(v5 + 38);
          *(void *)(*(void *)(v5 + 112) + 8 * v7++) = v9 + 2 * *(unsigned __int8 *)(v5 + 38);
          uint64_t v10 = *(__int16 *)(v5 + 84);
        }
        while (v7 < v10);
LABEL_15:
        LOWORD(v6) = v10;
      }
    }
    else if (v6 >= 1)
    {
      uint64_t v11 = 0;
      int v12 = *(unsigned __int8 *)(v5 + 38);
      do
      {
        uint64_t v13 = kdu_sample_allocator::alloc32(*(kdu_sample_allocator **)(v5 + 96), 0, *(_DWORD *)(v5 + 72) + v12);
        int v12 = *(unsigned __int8 *)(v5 + 38);
        *(void *)(*(void *)(v5 + 120) + 8 * v11++) = v13 + 4 * *(unsigned __int8 *)(v5 + 38);
        uint64_t v10 = *(__int16 *)(v5 + 84);
      }
      while (v11 < v10);
      goto LABEL_15;
    }
    if (*(void *)(v5 + 128)) {
      BOOL v14 = (__int16)v6 < 1;
    }
    else {
      BOOL v14 = 1;
    }
    if (!v14)
    {
      uint64_t v15 = 0;
      do
        *(void *)(*(void *)(v5 + 128) + 8 * v15++) = kdu_sample_allocator::alloc16(*(kdu_sample_allocator **)(v5 + 96), 0, (*(_DWORD *)(v5 + 72) + 1) >> 1);
      while (v15 < *(__int16 *)(v5 + 84));
    }
    *(unsigned char *)(v5 + 37) = 1;
    if (this) {
      kdu_thread_entity::release_lock(this, 3);
    }
  }
  if (*(int *)(v5 + 68) <= 0) {
    kd_encoder::push();
  }
  int v16 = *(unsigned __int16 *)(v5 + 86);
  if (v16 == *(unsigned __int16 *)(v5 + 88))
  {
    __int32 v17 = *(kdu_thread_queue **)(v5 + 136);
    if (!v17) {
      kd_encoder::push();
    }
    kdu_thread_entity::process_jobs(this, v17, 0, 1);
    int v18 = *(__int16 *)(v5 + 84);
    int v19 = *(__int16 *)(v5 + 82);
    if (v18 <= v19) {
      __int16 v20 = 0;
    }
    else {
      __int16 v20 = *(_WORD *)(v5 + 82);
    }
    if (*(__int16 *)(v5 + 88) <= v19) {
      LOWORD(v16) = v20;
    }
    else {
      LOWORD(v16) = 0;
    }
    *(_WORD *)(v5 + 86) = v16;
    if (*(_DWORD *)(v5 + 68) < v19) {
      LOWORD(v19) = *(_DWORD *)(v5 + 68);
    }
    __int16 v21 = v19 + v16;
    *(_WORD *)(v5 + 88) = v21;
    if (v18 < v21) {
      kd_encoder::push();
    }
  }
  int v22 = *a2;
  if (*a2 != *(_DWORD *)(v5 + 72)) {
    kd_encoder::push();
  }
  uint64_t v23 = *(void *)(v5 + 120);
  if (v23)
  {
    signed int v24 = *(void **)(v23 + 8 * (__int16)v16);
    if ((*((unsigned char *)a2 + 6) & 2) != 0) {
      __int32 v25 = 0;
    }
    else {
      __int32 v25 = (const void *)*((void *)a2 + 1);
    }
    int v26 = 4 * v22;
  }
  else
  {
    signed int v24 = *(void **)(*(void *)(v5 + 112) + 8 * (__int16)v16);
    if ((*((unsigned char *)a2 + 6) & 2) != 0) {
      __int32 v25 = (const void *)*((void *)a2 + 1);
    }
    else {
      __int32 v25 = 0;
    }
    int v26 = 2 * v22;
  }
  memcpy(v24, v25, v26);
  uint64_t result = *(void *)(v5 + 104);
  if (result)
  {
    if (this)
    {
      kdu_thread_entity::acquire_lock(this, 4, 1);
      uint64_t result = *(void *)(v5 + 104);
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)result + 24))(result, *(void *)(*(void *)(v5 + 128) + 8 * *(__int16 *)(v5 + 86)), *(unsigned int *)(v5 + 72));
    if (this) {
      uint64_t result = kdu_thread_entity::release_lock(this, 4);
    }
  }
  --*(_DWORD *)(v5 + 68);
  unsigned __int16 v27 = *(_WORD *)(v5 + 86) + 1;
  *(_WORD *)(v5 + 86) = v27;
  if (*(unsigned __int16 *)(v5 + 88) == v27)
  {
    __int32 v28 = *(kdu_thread_queue **)(v5 + 136);
    int v29 = *(unsigned __int8 *)(v5 + 39);
    if (v28)
    {
      uint64_t result = kdu_thread_entity::add_jobs((uint64_t)this, v28, v29, *(unsigned __int16 *)(v5 + 76));
      if (!*(_WORD *)(v5 + 76) || *(_DWORD *)(v5 + 92)) {
        return result;
      }
      int v30 = *(__int16 *)(v5 + 82);
      if (*(__int16 *)(v5 + 88) > v30) {
        kd_encoder::push();
      }
      int v31 = 1;
      __int16 v32 = *(_WORD *)(v5 + 82);
    }
    else
    {
      if (v29 != 1) {
        kd_encoder::push();
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, kdu_thread_entity *, void))(*(void *)v5 + 24))(v5, this, *(unsigned int *)(v5 + 92));
      __int16 v32 = 0;
      LOWORD(v30) = *(_WORD *)(v5 + 82);
      int v31 = *(_DWORD *)(v5 + 92) + 1;
    }
    *(_WORD *)(v5 + 86) = v32;
    *(_DWORD *)(v5 + 92) = v31;
    if (*(_DWORD *)(v5 + 68) < (__int16)v30) {
      LOWORD(v30) = *(_DWORD *)(v5 + 68);
    }
    __int16 v33 = v30 + v32;
    *(_WORD *)(v5 + 88) = v33;
    if (*(__int16 *)(v5 + 84) < v33) {
      kd_encoder::push();
    }
  }
  return result;
}

void kd_encoder::do_job(kd_encoder *this, kdu_thread_entity *a2, int a3)
{
  signed int v5 = *((unsigned __int8 *)this + 39);
  int v6 = *((_DWORD *)this + 16);
  int v7 = *((_DWORD *)this + 13);
  uint64_t v8 = *((unsigned int *)this + 14);
  uint64_t v10 = *((void *)this + 14);
  uint64_t v9 = *((void *)this + 15);
  uint64_t v11 = *((void *)this + 16);
  int v12 = a3 / v5;
  if ((a3 / v5))
  {
    uint64_t v13 = *((__int16 *)this + 41);
    uint64_t v14 = v9 + 8 * v13;
    if (!v9) {
      uint64_t v14 = 0;
    }
    uint64_t v15 = v10 + 8 * v13;
    if (!v10) {
      uint64_t v15 = 0;
    }
    uint64_t v16 = v11 + 8 * v13;
    if (!v11) {
      uint64_t v16 = 0;
    }
    if (*((__int16 *)this + 42) > *((__int16 *)this + 41))
    {
      uint64_t v9 = v14;
      uint64_t v10 = v15;
      uint64_t v11 = v16;
    }
  }
  if (v12 >= *((_DWORD *)this + 15)) {
    kd_encoder::do_job();
  }
  uint64_t v132 = v9;
  uint64_t v127 = v10;
  uint64_t v134 = v11;
  if (v5 >= 2)
  {
    int v17 = a3 % v5 * v6;
    int v18 = v17 / v5;
    int v19 = (v6 + v17) / v5;
    int v6 = v19 - v18;
    if (v19 <= v18) {
      kd_encoder::do_job();
    }
    if (v18 < 1)
    {
      int v20 = 0;
    }
    else
    {
      uint64_t v8 = (v18 + v8);
      int v20 = *((__int16 *)this + 39) + (v18 - 1) * *((__int16 *)this + 40);
    }
    __int16 v21 = (uint64_t *)((char *)this + 24);
    unsigned int conservative_slope_threshold = kdu_subband::get_conservative_slope_threshold((kd_encoder *)((char *)this + 24));
    goto LABEL_19;
  }
  __int16 v21 = (uint64_t *)((char *)this + 24);
  unsigned int conservative_slope_threshold = kdu_subband::get_conservative_slope_threshold((kd_encoder *)((char *)this + 24));
  if (v6 >= 1)
  {
    int v20 = 0;
LABEL_19:
    int v129 = a2;
    uint64_t v130 = (v12 + v7);
    int v133 = (__int16 *)((char *)this + 32);
    int v138 = (unsigned __int16 *)((char *)this + 34);
    int v128 = v21;
    do
    {
      int v22 = (_DWORD *)kdu_subband::open_block(v21, v130 | (v8 << 32), 0, a2);
      if (!v22)
      {
        exception = __cxa_allocate_exception(4uLL);
        _DWORD *exception = -50;
        __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
      }
      uint64_t v23 = v22;
      signed int v24 = ((*v22 + 3) & 0xFFFFFFFC) * v22[1];
      if (v24 <= 0) {
        kd_encoder::do_job();
      }
      if (v22[28] < v24)
      {
        if (v24 <= 4096) {
          int v25 = 4096;
        }
        else {
          int v25 = ((*v22 + 3) & 0xFFFFFFFC) * v22[1];
        }
        kdu_block::set_max_samples((uint64_t)v22, v25);
      }
      uint64_t v26 = *(void *)v23;
      uint64_t v27 = HIDWORD(*(void *)v23);
      if (*((void *)v23 + 2) != *(void *)v23 || v23[3] || v23[2]) {
        kd_encoder::do_job();
      }
      int v28 = *((unsigned __int8 *)v23 + 24);
      if (*((unsigned char *)v23 + 24)) {
        int v29 = *(void *)v23;
      }
      else {
        int v29 = HIDWORD(*(void *)v23);
      }
      if (*((unsigned char *)v23 + 24)) {
        int v30 = HIDWORD(*(void *)v23);
      }
      else {
        int v30 = *(void *)v23;
      }
      if (v29 + v20 > *((_DWORD *)this + 18)) {
        kd_encoder::do_job();
      }
      int v135 = v29 + v20;
      int v136 = v8;
      int v31 = (unsigned int *)*((void *)v23 + 12);
      if (*((unsigned char *)v23 + 26)) {
        int v32 = v29 - 1;
      }
      else {
        int v32 = 0;
      }
      if (*((unsigned char *)v23 + 26)) {
        uint64_t v33 = -1;
      }
      else {
        uint64_t v33 = 1;
      }
      if (*((unsigned char *)v23 + 25)) {
        uint64_t v34 = -1;
      }
      else {
        uint64_t v34 = 1;
      }
      uint64_t v35 = v32 + (uint64_t)v20;
      if (*((unsigned char *)v23 + 25)) {
        uint64_t v36 = v30 - 1;
      }
      else {
        uint64_t v36 = 0;
      }
      int v137 = v6;
      if (v132)
      {
        float v37 = (void *)(v132 + 8 * v36);
        float v38 = (unsigned __int16 *)((char *)this + 32);
        if (*((unsigned char *)this + 36))
        {
          int v39 = *v133;
          if (v39 >= 32)
          {
            uint64_t v141 = 0;
            long long v139 = 0u;
            long long v140 = 0u;
            kdu_error::kdu_error((kdu_error *)&v139, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v139 + 16))(&v139, "Insufficient implementation precision available for true reversible compression!");
            kdu_error::~kdu_error((kdu_error *)&v139);
          }
          char v40 = 31 - v39;
          if (!*((unsigned char *)v23 + 24))
          {
            if (v30)
            {
              unsigned int v41 = 0;
              int v63 = v30;
              do
              {
                if (v29)
                {
                  uint64_t v64 = 0;
                  float v65 = (int *)(*v37 + 4 * (int)v35);
                  do
                  {
                    if (*v65 >= 0) {
                      unsigned int v66 = *v65 << v40;
                    }
                    else {
                      unsigned int v66 = (-*v65 << v40) | 0x80000000;
                    }
                    v31[v64] = v66;
                    v41 |= v66;
                    v65 += v33;
                    ++v64;
                  }
                  while (v29 != v64);
                }
                v37 += v34;
                v31 += v26 >> 32;
                --v63;
              }
              while (v63);
LABEL_139:
              int v28 = 0;
              goto LABEL_141;
            }
            goto LABEL_140;
          }
          if (!v30) {
            goto LABEL_111;
          }
          unsigned int v41 = 0;
          int v42 = v30;
          do
          {
            if (v29)
            {
              uint64_t v43 = (int *)(*v37 + 4 * (int)v35);
              uint64_t v44 = v31;
              int v45 = v29;
              do
              {
                if (*v43 >= 0) {
                  unsigned int v46 = *v43 << v40;
                }
                else {
                  unsigned int v46 = (-*v43 << v40) | 0x80000000;
                }
                *uint64_t v44 = v46;
                v41 |= v46;
                v43 += v33;
                v44 += v26 >> 32;
                --v45;
              }
              while (v45);
            }
            v37 += v34;
            ++v31;
            --v42;
          }
          while (v42);
        }
        else
        {
          float v55 = 1.0 / *((float *)this + 10);
          float v56 = v55 / (float)(1 << (*((_WORD *)this + 16) - 31));
          float v57 = v55 * (float)(int)(0x80000000 >> *((_WORD *)this + 16));
          if (*((__int16 *)this + 16) > 31) {
            float v57 = v56;
          }
          if (!*((unsigned char *)v23 + 24))
          {
            if (v26)
            {
              unsigned int v41 = 0;
              int v76 = *(void *)v23;
              do
              {
                if (v27)
                {
                  uint64_t v77 = 0;
                  int v78 = (float *)(*v37 + 4 * (int)v35);
                  do
                  {
                    float v79 = v57 * *v78;
                    unsigned int v80 = (int)v79;
                    if (v79 < 0.0) {
                      unsigned int v80 = (int)(float)-v79 | 0x80000000;
                    }
                    v31[v77] = v80;
                    v41 |= v80;
                    v78 += v33;
                    ++v77;
                  }
                  while (v29 != v77);
                }
                v37 += v34;
                v31 += v26 >> 32;
                --v76;
              }
              while (v76);
              goto LABEL_139;
            }
            goto LABEL_140;
          }
          if (!v27) {
            goto LABEL_111;
          }
          unsigned int v41 = 0;
          do
          {
            if (v26)
            {
              float v58 = (float *)(*v37 + 4 * (int)v35);
              float v59 = v31;
              int v60 = v29;
              do
              {
                float v61 = v57 * *v58;
                unsigned int v62 = (int)v61;
                if (v61 < 0.0) {
                  unsigned int v62 = (int)(float)-v61 | 0x80000000;
                }
                *float v59 = v62;
                v41 |= v62;
                v58 += v33;
                v59 += v26 >> 32;
                --v60;
              }
              while (v60);
            }
            v37 += v34;
            ++v31;
            LODWORD(v27) = v27 - 1;
          }
          while (v27);
        }
      }
      else
      {
        float v47 = (void *)(v127 + 8 * v36);
        float v38 = (unsigned __int16 *)((char *)this + 32);
        if (*((unsigned char *)this + 36))
        {
          int v48 = *v133;
          if (v48 >= 32) {
            kd_encoder::do_job();
          }
          char v49 = 31 - v48;
          if (!*((unsigned char *)v23 + 24))
          {
            if (v26)
            {
              unsigned int v41 = 0;
              int v81 = *(void *)v23;
              do
              {
                if (v27)
                {
                  uint64_t v82 = 0;
                  CGRect v83 = (__int16 *)(*v47 + 2 * (int)v35);
                  do
                  {
                    int v84 = *v83;
                    if (v84 >= 0) {
                      unsigned int v85 = v84 << v49;
                    }
                    else {
                      unsigned int v85 = (-v84 << v49) | 0x80000000;
                    }
                    v31[v82] = v85;
                    v41 |= v85;
                    v83 += v33;
                    ++v82;
                  }
                  while (v29 != v82);
                }
                v47 += v34;
                v31 += v26 >> 32;
                --v81;
              }
              while (v81);
              goto LABEL_139;
            }
            goto LABEL_140;
          }
          if (!v27) {
            goto LABEL_111;
          }
          unsigned int v41 = 0;
          do
          {
            if (v26)
            {
              float v50 = (__int16 *)(*v47 + 2 * (int)v35);
              float v51 = v31;
              int v52 = v29;
              do
              {
                int v53 = *v50;
                if (v53 >= 0) {
                  unsigned int v54 = v53 << v49;
                }
                else {
                  unsigned int v54 = (-v53 << v49) | 0x80000000;
                }
                unsigned int *v51 = v54;
                v41 |= v54;
                v50 += v33;
                v51 += v26 >> 32;
                --v52;
              }
              while (v52);
            }
            v47 += v34;
            ++v31;
            LODWORD(v27) = v27 - 1;
          }
          while (v27);
        }
        else
        {
          float v67 = 1.0 / (float)(*((float *)this + 10) * 8192.0);
          float v68 = v67 / (float)(1 << (*((_WORD *)this + 16) - 31));
          float v69 = v67 * (float)(int)(0x80000000 >> *((_WORD *)this + 16));
          if (*((__int16 *)this + 16) > 31) {
            float v69 = v68;
          }
          int v70 = (int)(float)(v69 + 0.5);
          if (!*((unsigned char *)v23 + 24))
          {
            if (v26)
            {
              unsigned int v41 = 0;
              int v86 = *(void *)v23;
              do
              {
                if (v27)
                {
                  uint64_t v87 = 0;
                  uint64_t v88 = (__int16 *)(*v47 + 2 * (int)v35);
                  do
                  {
                    int v89 = *v88 * v70;
                    unsigned int v90 = -v89 | 0x80000000;
                    if (v89 >= 0) {
                      unsigned int v90 = *v88 * v70;
                    }
                    v31[v87] = v90;
                    v41 |= v90;
                    v88 += v33;
                    ++v87;
                  }
                  while (v29 != v87);
                }
                v47 += v34;
                v31 += v26 >> 32;
                --v86;
              }
              while (v86);
              goto LABEL_139;
            }
LABEL_140:
            int v28 = 0;
            unsigned int v41 = 0;
            goto LABEL_141;
          }
          if (!v27)
          {
LABEL_111:
            unsigned int v41 = 0;
            int v28 = 1;
            goto LABEL_141;
          }
          unsigned int v41 = 0;
          do
          {
            if (v26)
            {
              float v71 = (__int16 *)(*v47 + 2 * (int)v35);
              float v72 = v31;
              int v73 = v29;
              do
              {
                int v74 = *v71 * v70;
                unsigned int v75 = -v74 | 0x80000000;
                if (v74 >= 0) {
                  unsigned int v75 = *v71 * v70;
                }
                *float v72 = v75;
                v41 |= v75;
                v71 += v33;
                v72 += v26 >> 32;
                --v73;
              }
              while (v73);
            }
            v47 += v34;
            ++v31;
            LODWORD(v27) = v27 - 1;
          }
          while (v27);
        }
      }
LABEL_141:
      int v91 = (__int16)*v138;
      int v92 = (__int16)*v38;
      BOOL v93 = __OFSUB__(v91, v92);
      int v94 = v91 - v92;
      if ((v94 < 0) ^ v93 | (v94 == 0))
      {
        int v97 = v137;
      }
      else
      {
        uint64_t v95 = *((void *)v23 + 12);
        if (v94 < v92)
        {
          uint64_t v141 = 0;
          long long v139 = 0u;
          long long v140 = 0u;
          kdu_error::kdu_error((kdu_error *)&v139, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v139 + 16))(&v139, "You have selected too small a value for the ROI up-shift parameter.  The up-shift should be at least as large as the largest number of magnitude bit-planes in any subband; otherwise, the foreground and background reg"
            "ions might not be properly distinguished by the decompressor.");
          kdu_error::~kdu_error((kdu_error *)&v139);
        }
        int v96 = -1 << ~(_BYTE)v92;
        if (v28)
        {
          int v97 = v137;
          if (v29)
          {
            int v98 = v29;
            do
            {
              if (v30)
              {
                uint64_t v99 = 0;
                do
                  *(_DWORD *)(v95 + 4 * v99++) &= v96;
                while (v30 != v99);
              }
              v95 += 4 * (v26 >> 32);
              --v98;
            }
            while (v98);
          }
          int v28 = 1;
        }
        else
        {
          int v97 = v137;
          if (v30)
          {
            int v100 = v30;
            do
            {
              if (v29)
              {
                uint64_t v101 = 0;
                do
                  *(_DWORD *)(v95 + 4 * v101++) &= v96;
                while (v29 != v101);
              }
              v95 += 4 * (v26 >> 32);
              --v100;
            }
            while (v100);
          }
          int v28 = 0;
        }
      }
      if (!v134) {
        goto LABEL_170;
      }
      int v102 = *v138;
      int v103 = *v38;
      if (v102 == v103)
      {
        if (v30)
        {
          float v104 = (void *)(v134 + 8 * v36);
          while (!v29)
          {
LABEL_168:
            v104 += v34;
            if (!--v30) {
              goto LABEL_171;
            }
          }
          float v105 = (unsigned char *)(*v104 + (int)v35);
          int v106 = v29;
          while (!*v105)
          {
            v105 += v33;
            if (!--v106) {
              goto LABEL_168;
            }
          }
LABEL_170:
          int v30 = 1;
        }
LABEL_171:
        uint64_t v107 = v38;
        __int16 v21 = v128;
        a2 = v129;
        goto LABEL_199;
      }
      int v108 = (__int16)v103;
      int v109 = (__int16)v102 - (__int16)v103;
      if (v109 < v108) {
        kd_encoder::do_job();
      }
      int v110 = (void *)(v134 + 8 * v36);
      uint64_t v111 = (unsigned int *)*((void *)v23 + 12);
      if (v28)
      {
        if (v30)
        {
          char v112 = 0;
          char v113 = 0;
          do
          {
            if (v29)
            {
              uint64_t v114 = (unsigned char *)(*v110 + (int)v35);
              char v115 = v111;
              int v116 = v29;
              do
              {
                if (*v114)
                {
                  char v112 = 1;
                }
                else
                {
                  unsigned int *v115 = ((*v115 & 0x7FFFFFFF) >> v109) | *v115 & 0x80000000;
                  char v113 = 1;
                }
                v114 += v33;
                v115 += v26 >> 32;
                --v116;
              }
              while (v116);
            }
            v110 += v34;
            ++v111;
            --v30;
          }
          while (v30);
LABEL_193:
          __int16 v21 = v128;
          a2 = v129;
          if ((v112 & 1) == 0) {
            unsigned int v41 = (v41 & 0x7FFFFFFF) >> v109;
          }
          goto LABEL_196;
        }
      }
      else if (v30)
      {
        char v112 = 0;
        char v113 = 0;
        do
        {
          if (v29)
          {
            uint64_t v117 = 0;
            uint64_t v118 = (unsigned char *)(*v110 + v35);
            do
            {
              if (*v118)
              {
                char v112 = 1;
              }
              else
              {
                v111[v117] = ((v111[v117] & 0x7FFFFFFF) >> v109) | v111[v117] & 0x80000000;
                char v113 = 1;
              }
              v118 += v33;
              ++v117;
            }
            while (v29 != v117);
          }
          v110 += v34;
          v111 += v26 >> 32;
          --v30;
        }
        while (v30);
        goto LABEL_193;
      }
      char v113 = 0;
      unsigned int v41 = (v41 & 0x7FFFFFFF) >> v109;
      __int16 v21 = v128;
      a2 = v129;
LABEL_196:
      BOOL v119 = (v113 & 1) == 0;
      uint64_t v107 = (unsigned __int16 *)((char *)this + 34);
      if (v119) {
        uint64_t v107 = v38;
      }
      int v30 = 1;
LABEL_199:
      int v120 = (__int16)*v107;
      if (v120 >= 31 && *((unsigned char *)this + 36) && (__int16)*v138 > (__int16)*v38 && !*((unsigned char *)v23 + 121))
      {
        *((unsigned char *)v23 + 121) = 1;
        uint64_t v141 = 0;
        long long v139 = 0u;
        long long v140 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)&v139, "Kakadu Core Warning:\n");
        kdu_warning::~kdu_warning((kdu_warning *)&v139);
      }
      if (v120 >= 31) {
        int v121 = 31;
      }
      else {
        int v121 = v120;
      }
      int v122 = v41 & 0x7FFFFFFF;
      if ((v41 & 0x7FFFFFFF) == 0)
      {
        v23[11] = 31;
LABEL_213:
        int v123 = 0;
        v23[11] = v121;
        goto LABEL_214;
      }
      int v123 = 3 * v121 + 1;
      int v124 = -1;
      do
      {
        v122 *= 2;
        ++v124;
        v123 -= 3;
      }
      while ((v122 & 0x80000000) == 0);
      v23[11] = v124;
      if (v124 >= v121) {
        goto LABEL_213;
      }
LABEL_214:
      v23[12] = v123;
      float v125 = *((float *)this + 11);
      if (v30) {
        float v125 = v125 * *((float *)this + 12);
      }
      (*(void (**)(void, _DWORD *, void, void, uint64_t, uint64_t, double))(**((void **)this + 2) + 16))(*((void *)this + 2), v23, *((unsigned __int8 *)this + 36), conservative_slope_threshold, 31, v35, v125);
      kdu_subband::close_block((uint64_t)v21, (kdu_block *)v23, (uint64_t)a2);
      uint64_t v8 = (v136 + 1);
      int v20 = v135;
      BOOL v93 = __OFSUB__(v97, 1);
      int v6 = v97 - 1;
    }
    while (!((v6 < 0) ^ v93 | (v6 == 0)));
  }
}

void sub_1886CE168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'kd_encoder::do_job(kd_encoder *this, kdu_thread_entity *a2, int a3)
{
}

void kd_encoder::kd_encoder(kd_encoder *this)
{
  *(void *)this = &unk_1ED4DE910;
  *((void *)this + 1) = &unk_1ED4DE940;
  kdu_block_encoder::kdu_block_encoder((kd_encoder *)((char *)this + 16));
}

void sub_1886CE22C(_Unwind_Exception *a1)
{
  *uint64_t v1 = &unk_1ED4E4510;
  v1[1] = &unk_1ED4DE9F0;
  _Unwind_Resume(a1);
}

void kd_multi_line::reset(kd_multi_line *this, int a2, float a3)
{
  char v4 = *((unsigned char *)this + 6);
  if ((v4 & 2) != 0) {
    signed int v5 = 0;
  }
  else {
    signed int v5 = (float *)*((void *)this + 1);
  }
  if ((*((unsigned char *)this + 6) & 2) != 0) {
    int v6 = (float *)*((void *)this + 1);
  }
  else {
    int v6 = 0;
  }
  int v7 = v4 & 1;
  if (*((unsigned __int8 *)this + 36) != v7) {
    kd_multi_line::reset();
  }
  if (v7)
  {
    if (v6)
    {
      int v8 = *((_DWORD *)this + 5);
      if (!a2) {
        goto LABEL_18;
      }
      if (v8 >= 1)
      {
        unsigned int v9 = v8 + 1;
        do
        {
          *(_WORD *)int v6 = a2;
          int v6 = (float *)((char *)v6 + 2);
          --v9;
        }
        while (v9 > 1);
      }
    }
    else
    {
      if (!v5) {
        kd_multi_line::reset();
      }
      int v13 = *((_DWORD *)this + 5);
      if (!a2)
      {
        size_t v10 = 4 * v13;
        int v6 = v5;
        goto LABEL_19;
      }
      if (v13 >= 1)
      {
        unsigned int v14 = v13 + 1;
        do
        {
          *(_DWORD *)v5++ = a2;
          --v14;
        }
        while (v14 > 1);
      }
    }
  }
  else if (v6)
  {
    if (a3 == 0.0)
    {
      int v8 = *((_DWORD *)this + 5);
LABEL_18:
      size_t v10 = 2 * v8;
LABEL_19:
      bzero(v6, v10);
      return;
    }
    int v15 = *((_DWORD *)this + 5);
    if (v15 >= 1)
    {
      __int16 v16 = vcvtmd_s64_f64((float)(a3 * 8192.0) + 0.5);
      unsigned int v17 = v15 + 1;
      do
      {
        *(_WORD *)int v6 = v16;
        int v6 = (float *)((char *)v6 + 2);
        --v17;
      }
      while (v17 > 1);
    }
  }
  else
  {
    int v11 = *((_DWORD *)this + 5);
    if (v11 >= 1)
    {
      unsigned int v12 = v11 + 1;
      do
      {
        *v5++ = a3;
        --v12;
      }
      while (v12 > 1);
    }
  }
}

uint64_t kd_multi_line::apply_offset(uint64_t this, int a2, float a3)
{
  if ((*(unsigned char *)(this + 6) & 2) != 0) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = *(float **)(this + 8);
  }
  if ((*(unsigned char *)(this + 6) & 2) != 0) {
    char v4 = *(_WORD **)(this + 8);
  }
  else {
    char v4 = 0;
  }
  if (*(unsigned char *)(this + 36))
  {
    if (a2)
    {
      int v5 = *(_DWORD *)(this + 20);
      if (v3)
      {
        if (v5 >= 1)
        {
          unsigned int v6 = v5 + 1;
          do
          {
            *(_DWORD *)v3++ += a2;
            --v6;
          }
          while (v6 > 1);
        }
      }
      else if (v5 >= 1)
      {
        unsigned int v9 = v5 + 1;
        do
        {
          *v4++ += a2;
          --v9;
        }
        while (v9 > 1);
      }
    }
  }
  else if (a3 != 0.0)
  {
    if (v3)
    {
      int v7 = *(_DWORD *)(this + 20);
      if (v7 >= 1)
      {
        unsigned int v8 = v7 + 1;
        do
        {
          *uint64_t v3 = *v3 + a3;
          ++v3;
          --v8;
        }
        while (v8 > 1);
      }
    }
    else
    {
      int v10 = *(_DWORD *)(this + 20);
      if (v10 >= 1)
      {
        __int16 v11 = vcvtmd_s64_f64((float)(a3 * 8192.0) + 0.5);
        unsigned int v12 = v10 + 1;
        do
        {
          *v4++ += v11;
          --v12;
        }
        while (v12 > 1);
      }
    }
  }
  return this;
}

uint64_t kd_multi_line::copy(uint64_t this, kd_multi_line *a2, int a3, float a4)
{
  int v4 = *((_DWORD *)a2 + 5);
  if (v4 != *(_DWORD *)(this + 20)) {
    kd_multi_line::copy();
  }
  if ((*(unsigned char *)(this + 6) & 2) != 0) {
    int v5 = 0;
  }
  else {
    int v5 = *(float **)(this + 8);
  }
  if ((*(unsigned char *)(this + 6) & 2) != 0) {
    unsigned int v6 = *(_WORD **)(this + 8);
  }
  else {
    unsigned int v6 = 0;
  }
  if ((*((unsigned char *)a2 + 6) & 2) != 0) {
    int v7 = 0;
  }
  else {
    int v7 = (float *)*((void *)a2 + 1);
  }
  if ((*((unsigned char *)a2 + 6) & 2) != 0) {
    unsigned int v8 = (__int16 *)*((void *)a2 + 1);
  }
  else {
    unsigned int v8 = 0;
  }
  if (*(unsigned char *)(this + 36))
  {
    if (!*((unsigned char *)a2 + 36)) {
      kd_multi_line::copy();
    }
    if (v5)
    {
      if (v4 >= 1)
      {
        unsigned int v9 = v4 + 1;
        do
        {
          float v10 = *v7++;
          *(_DWORD *)v5++ = LODWORD(v10) + a3;
          --v9;
        }
        while (v9 > 1);
      }
    }
    else if (v4 >= 1)
    {
      unsigned int v14 = v4 + 1;
      do
      {
        __int16 v15 = *v8++;
        *v6++ = v15 + a3;
        --v14;
      }
      while (v14 > 1);
    }
  }
  else if (v5)
  {
    if (*((unsigned char *)a2 + 36))
    {
      if (v4 >= 1)
      {
        float v11 = 1.0 / (float)(1 << *(_DWORD *)(this + 40));
        unsigned int v12 = v4 + 1;
        do
        {
          int v13 = *(_DWORD *)v7++;
          *v5++ = a4 + (float)((float)v13 * v11);
          --v12;
        }
        while (v12 > 1);
      }
    }
    else
    {
      int v18 = *((_DWORD *)a2 + 10);
      int v19 = *(_DWORD *)(this + 40);
      if (v18 == v19)
      {
        if (v4 >= 1)
        {
          unsigned int v20 = v4 + 1;
          do
          {
            float v21 = *v7++;
            *v5++ = v21 + a4;
            --v20;
          }
          while (v20 > 1);
        }
      }
      else if (v4 >= 1)
      {
        int v28 = 1 << v18;
        float v29 = (float)(1 << v19);
        unsigned int v30 = v4 + 1;
        do
        {
          float v31 = *v7++;
          *v5++ = a4 + (float)(v31 * (float)((float)v28 / v29));
          --v30;
        }
        while (v30 > 1);
      }
    }
  }
  else
  {
    double v16 = (float)(a4 * 8192.0) + 0.5;
    if (*((unsigned char *)a2 + 36)) {
      int v17 = 13;
    }
    else {
      int v17 = *((_DWORD *)a2 + 10);
    }
    unsigned int v22 = vcvtmd_s64_f64(v16);
    int v23 = v17 - *(_DWORD *)(this + 40);
    if (v23)
    {
      if (v23 < 1)
      {
        if (v4 >= 1)
        {
          int v32 = -v23;
          int v33 = (v22 << -(char)v23) + (1 << ~(_BYTE)v23);
          unsigned int v34 = v4 + 1;
          do
          {
            int v35 = *v8++;
            *v6++ = (v33 + v35) >> v32;
            --v34;
          }
          while (v34 > 1);
        }
      }
      else if (v4 >= 1)
      {
        unsigned int v26 = v4 + 1;
        do
        {
          __int16 v27 = *v8++;
          *v6++ = (v27 << v23) + v22;
          --v26;
        }
        while (v26 > 1);
      }
    }
    else if (v4 >= 1)
    {
      unsigned int v24 = v4 + 1;
      do
      {
        __int16 v25 = *v8++;
        *v6++ = v25 + v22;
        --v24;
      }
      while (v24 > 1);
    }
  }
  return this;
}

void kd_multi_transform::~kd_multi_transform(kd_multi_transform *this)
{
  *(void *)this = &unk_1ED4E4A10;
  for (int i = (void *)*((void *)this + 2); ; int i = (void *)*((void *)this + 2))
  {
    *((void *)this + 3) = i;
    if (!i) {
      break;
    }
    *((void *)this + 2) = i[6];
    (*(void (**)(void *))(*i + 8))(i);
  }
  while (1)
  {
    uint64_t v4 = *((void *)this + 5);
    *((void *)this + 6) = v4;
    if (!v4) {
      break;
    }
    uint64_t v3 = *(void *)(v4 + 8);
    *((void *)this + 5) = *(void *)(v4 + 16);
    if (v3) {
      MEMORY[0x18C11C0C0](v3, 0x20C8093837F09);
    }
    MEMORY[0x18C11C0E0](v4, 0x10A0C40AA2F9B3ELL);
  }
  uint64_t v5 = *((void *)this + 7);
  if (v5) {
    MEMORY[0x18C11C0C0](v5, 0x1020C80587BA0B9);
  }
  uint64_t v6 = *((void *)this + 4);
  if (v6)
  {
    uint64_t v7 = v6 - 16;
    uint64_t v8 = *(void *)(v6 - 8);
    if (v8)
    {
      uint64_t v9 = v6 - 160;
      uint64_t v10 = 160 * v8;
      do
      {
        kd_multi_component::~kd_multi_component((kd_multi_component *)(v9 + v10));
        v10 -= 160;
      }
      while (v10);
    }
    MEMORY[0x18C11C0C0](v7, 0x10A1C80A5FDC87BLL);
  }
  uint64_t v11 = *((void *)this + 14);
  if (v11) {
    MEMORY[0x18C11C0C0](v11, 0x1000C8052888210);
  }
  uint64_t v12 = *((void *)this + 16);
  if (v12) {
    MEMORY[0x18C11C0C0](v12, 0x1000C8052888210);
  }
  uint64_t v13 = *((void *)this + 11);
  if (v13) {
    MEMORY[0x18C11C0C0](v13, 0x1000C8077774924);
  }
}

{
  uint64_t vars8;

  kd_multi_transform::~kd_multi_transform(this);

  JUMPOUT(0x18C11C0E0);
}

void kd_multi_transform::construct(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  v9[0] = a3;
  v9[1] = a2;
  BOOL v6 = (a5 & 1) == 0 && kdu_tile::get_ycc((kdu_tile *)v9);
  *(unsigned char *)(a1 + 8) = v6;
  *(void *)uint64_t v7 = 0;
  *(void *)uint64_t v8 = 0;
  operator new();
}

void sub_1886CF614(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886CF620()
{
  _Unwind_Resume(v0);
}

uint64_t kd_multi_transform::get_scratch_ints(kd_multi_transform *this, int a2)
{
  int v2 = *((_DWORD *)this + 26);
  if (v2 < a2)
  {
    *((_DWORD *)this + 26) = v2 + a2;
    uint64_t v3 = *((void *)this + 14);
    if (v3) {
      MEMORY[0x18C11C0C0](v3, 0x1000C8052888210);
    }
    operator new[]();
  }
  return *((void *)this + 14);
}

uint64_t kd_multi_transform::propagate_knowledge(kd_multi_transform *this, int a2)
{
  if (*((unsigned char *)this + 8))
  {
    uint64_t v3 = *((void *)this + 5);
    if (*(int *)v3 <= 2) {
      kd_multi_transform::propagate_knowledge();
    }
    uint64_t v4 = 0;
    char v5 = 0;
    char v6 = 0;
    uint64_t v7 = *(uint64_t **)(v3 + 8);
    char v8 = a2;
    do
    {
      uint64_t v9 = (unsigned char *)v7[v4];
      v6 |= v9[36] != 0;
      v5 |= v9[37] != 0;
      v8 |= v9[38] != 0;
      ++v4;
    }
    while (v4 != 3);
    uint64_t v10 = 0;
    char v11 = 0;
    char v12 = v6 & 1;
    char v13 = v5 & 1;
    char v14 = v8 & 1;
    uint64_t v15 = *v7;
    int v16 = *(_DWORD *)(*v7 + 20);
    do
    {
      uint64_t v17 = v7[v10];
      *(unsigned char *)(v17 + 36) = v12;
      *(unsigned char *)(v17 + 37) = v13;
      *(unsigned char *)(v17 + 38) = v14;
      if (*(_DWORD *)(v17 + 20) != v16 || *(_DWORD *)(v17 + 16) != *(_DWORD *)(v15 + 16)) {
        char v11 = 1;
      }
      ++v10;
    }
    while (v10 != 3);
    char v18 = v11;
  }
  else
  {
    char v18 = 0;
  }
  LOBYTE(v19) = 0;
  uint64_t v20 = *((void *)this + 2);
  if (!v20)
  {
    char v21 = 0;
    if ((v18 & 1) == 0) {
      goto LABEL_101;
    }
LABEL_104:
    uint64_t v62 = 0;
    long long v60 = 0u;
    long long v61 = 0u;
    kdu_error::kdu_error((kdu_error *)&v60, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v60 + 16))(&v60, "Cannot implement multi-component transform.  It seems that image components which must be processed by a common transform block (or decorrelating colour transform) have incompatible dimensions.  This error may also be detected if the sub-sampling factors associated with an MCT output image component vary from tile to tile or if relative component size change from resolution level to resolution level (due to incompatible Part-2 downsampling factor style usage).  While these latter conditions might not be strictly illegal, they are clearly foolish.");
    kdu_error::~kdu_error((kdu_error *)&v60);
  }
  char v21 = 0;
  if ((v18 & 1) == 0)
  {
    char v21 = 0;
    int v19 = 0;
    do
    {
      int v22 = *(_DWORD *)(v20 + 24);
      if (*(unsigned char *)(v20 + 8))
      {
        int v23 = *(_DWORD *)(v20 + 12);
        if (v22 > v23) {
          kd_multi_transform::propagate_knowledge();
        }
        if (v23 >= 1)
        {
          uint64_t v24 = 0;
          char v18 = 0;
          uint64_t v25 = 40;
          while (1)
          {
            uint64_t v26 = *(void *)(v20 + 16);
            if (a2) {
              *(unsigned char *)(v26 + v25 - 2) = 1;
            }
            uint64_t v27 = v26 + v25;
            if (*(unsigned char *)(v26 + v25 - 1)) {
              goto LABEL_44;
            }
            uint64_t v28 = *(void *)(*(void *)(v20 + 32) + 8 * v24);
            if (*(unsigned __int8 *)(v28 + 38) != *(unsigned __int8 *)(v27 - 2))
            {
              int v19 = 1;
              *(unsigned char *)(v28 + 38) = 1;
              *(unsigned char *)(v27 - 2) = 1;
            }
            uint64_t v29 = v26 + v25;
            if (*(unsigned __int8 *)(v28 + 37) != *(unsigned __int8 *)(v26 + v25 - 3))
            {
              int v19 = 1;
              *(unsigned char *)(v28 + 37) = 1;
              *(unsigned char *)(v29 - 3) = 1;
            }
            if (*(unsigned __int8 *)(v28 + 36) != *(unsigned __int8 *)(v29 - 4))
            {
              int v19 = 1;
              *(unsigned char *)(v28 + 36) = 1;
              *(unsigned char *)(v29 - 4) = 1;
            }
            unsigned int v30 = (_DWORD *)(v28 + 16);
            float v31 = (_DWORD *)(v26 + v25 - 24);
            int v32 = *(_DWORD *)(v28 + 20);
            int v33 = *(_DWORD *)(v26 + v25 - 20);
            if (v32 != v33 || *v30 != *v31)
            {
              if (v32 || *v30)
              {
                if (v33 || (unsigned int v34 = (void *)(v28 + 16), *v31))
                {
                  int v19 = 1;
                  char v18 = 1;
                  goto LABEL_37;
                }
              }
              else
              {
                unsigned int v34 = (void *)(v26 + v25 - 24);
                float v31 = (_DWORD *)(v28 + 16);
              }
              *(void *)float v31 = *v34;
              int v19 = 1;
            }
LABEL_37:
            int v35 = *(_DWORD *)(v28 + 40);
            int v36 = *(_DWORD *)(v26 + v25);
            if (v35 != v36)
            {
              if (!v35)
              {
                *(_DWORD *)(v28 + 40) = v36;
LABEL_43:
                int v19 = 1;
                goto LABEL_44;
              }
              if (!v36)
              {
                *(_DWORD *)(v26 + v25) = v35;
                goto LABEL_43;
              }
              int v19 = 1;
              char v21 = 1;
            }
LABEL_44:
            ++v24;
            v25 += 80;
            if (v24 >= *(int *)(v20 + 12)) {
              goto LABEL_98;
            }
          }
        }
        char v18 = 0;
      }
      else
      {
        if (v22 < 1)
        {
          uint64_t v40 = 0;
          uint64_t v39 = 0;
          char v38 = 0;
          char v37 = 0;
          char v43 = a2;
        }
        else
        {
          char v37 = 0;
          char v38 = 0;
          uint64_t v39 = 0;
          uint64_t v40 = 0;
          unsigned int v41 = *(uint64_t **)(v20 + 32);
          uint64_t v42 = *(unsigned int *)(v20 + 24);
          char v43 = a2;
          do
          {
            uint64_t v44 = *v41;
            if (*v41)
            {
              BOOL v45 = *(_DWORD *)(v44 + 20) != v40 || *(_DWORD *)(v44 + 16) != v39;
              if (!(v38 & 1 | !v45))
              {
                uint64_t v39 = *(void *)(v44 + 16);
                uint64_t v40 = HIDWORD(*(void *)(v44 + 16));
                char v38 = 1;
              }
              v43 |= *(unsigned char *)(v44 + 38) != 0;
              v37 |= *(_DWORD *)(v44 + 40) == 0;
            }
            ++v41;
            --v42;
          }
          while (v42);
        }
        int v46 = *(_DWORD *)(v20 + 12);
        if (v46 < 1)
        {
          char v47 = 0;
        }
        else
        {
          char v47 = 0;
          uint64_t v48 = *(void *)(v20 + 16) + 20;
          uint64_t v49 = *(unsigned int *)(v20 + 12);
          do
          {
            BOOL v50 = *(_DWORD *)v48 != v40 || *(_DWORD *)(v48 - 4) != v39;
            if (!(v38 & 1 | !v50))
            {
              uint64_t v39 = *(void *)(v48 - 4);
              uint64_t v40 = HIDWORD(*(void *)(v48 - 4));
              char v38 = 1;
            }
            v43 |= *(unsigned char *)(v48 + 18) != 0;
            int v51 = *(_DWORD *)(v48 + 20);
            v48 += 80;
            v47 |= v51 == 0;
            --v49;
          }
          while (v49);
        }
        uint64_t v52 = v39 | (v40 << 32);
        if (v22 < 1)
        {
          char v18 = 0;
        }
        else
        {
          uint64_t v53 = 0;
          char v18 = 0;
          do
          {
            uint64_t v54 = *(void *)(*(void *)(v20 + 32) + 8 * v53);
            if (v54)
            {
              if (*(unsigned char *)(v54 + 38) != (v43 & 1))
              {
                int v19 = 1;
                *(unsigned char *)(v54 + 38) = 1;
              }
              if (*(_DWORD *)(v54 + 20) != v40 || *(_DWORD *)(v54 + 16) != v39)
              {
                if ((v38 & 1) == 0) {
                  kd_multi_transform::propagate_knowledge();
                }
                if (*(_DWORD *)(v54 + 20) || *(_DWORD *)(v54 + 16))
                {
                  int v19 = 1;
                  char v18 = 1;
                }
                else
                {
                  *(void *)(v54 + 16) = v52;
                  int v22 = *(_DWORD *)(v20 + 24);
                  int v19 = 1;
                }
              }
            }
            ++v53;
          }
          while (v53 < v22);
          int v46 = *(_DWORD *)(v20 + 12);
        }
        if (v46 >= 1)
        {
          uint64_t v55 = 0;
          uint64_t v56 = 0;
          int v57 = v43 & 1;
          do
          {
            uint64_t v58 = *(void *)(v20 + 16) + v55;
            if (*(unsigned __int8 *)(v58 + 38) != v57)
            {
              int v19 = 1;
              *(unsigned char *)(v58 + 38) = 1;
            }
            if (*(_DWORD *)(v58 + 20) != v40 || *(_DWORD *)(v58 + 16) != v39)
            {
              if ((v38 & 1) == 0) {
                kd_multi_transform::propagate_knowledge();
              }
              if (*(_DWORD *)(v58 + 20) || *(_DWORD *)(v58 + 16))
              {
                int v19 = 1;
                char v18 = 1;
              }
              else
              {
                *(void *)(v58 + 16) = v52;
                int v46 = *(_DWORD *)(v20 + 12);
                int v19 = 1;
              }
            }
            ++v56;
            v55 += 80;
          }
          while (v56 < v46);
        }
        v19 |= (*(uint64_t (**)(uint64_t, void, void))(*(void *)v20 + 32))(v20, v37 & 1, v47 & 1);
      }
LABEL_98:
      uint64_t v20 = *(void *)(v20 + 48);
    }
    while (v20 && (v18 & 1) == 0);
  }
  if (v18) {
    goto LABEL_104;
  }
LABEL_101:
  if (v21)
  {
    uint64_t v62 = 0;
    long long v60 = 0u;
    long long v61 = 0u;
    kdu_error::kdu_error((kdu_error *)&v60, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v60 + 16))(&v60, "Part-2 codestream declares a codestream component to have a different bit-depth (Sprecision) to the output component (Mprecision) with which it is directly associated.  While this is allowed, it makes very little sense, and Kakadu will not perform the required multiple scaling for irreversibly transformed components.");
    kdu_error::~kdu_error((kdu_error *)&v60);
  }
  return v19 & 1;
}

void sub_1886CFC9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886CFCA8()
{
  _Unwind_Resume(v0);
}

void kd_multi_transform::create_resources(kd_multi_transform *this)
{
  uint64_t v1 = this;
  uint64_t v2 = *((void *)this + 5);
  int v3 = *(_DWORD *)v2;
  if (*(int *)v2 < 1)
  {
    char v6 = 1;
  }
  else
  {
    uint64_t v4 = 0;
    char v5 = (kd_multi_transform *)((char *)this + 64);
    char v6 = 1;
    do
    {
      uint64_t v7 = *((void *)v1 + 4);
      if (*(void *)(*(void *)(v2 + 8) + 8 * v4) != v7 + 160 * v4 + 24) {
        kd_multi_transform::create_resources();
      }
      uint64_t v8 = v7 + 160 * v4;
      int v10 = *(_DWORD *)(v8 + 128);
      uint64_t v9 = (int *)(v8 + 128);
      BOOL v11 = *((unsigned __int8 *)v9 - 68) == (*((unsigned __int8 *)v9 - 67) ^ 1);
      if (v10 >= 1)
      {
        BOOL v49 = *((unsigned __int8 *)v9 - 68) == (*((unsigned __int8 *)v9 - 67) ^ 1);
        uint64_t v12 = 0;
        uint64_t v13 = 0;
        uint64_t v14 = v7 + 160 * v4;
        uint64_t v15 = (void *)(v14 + 136);
        int v16 = (int *)(v14 + 44);
        uint64_t v17 = (unsigned char *)(v14 + 62);
        do
        {
          kdu_line_buf::pre_create((kdu_line_buf *)(*v15 + v12), v5, *v16, *((unsigned char *)v9 - 68), *v17 == 0, 2u, 2);
          ++v13;
          v12 += 16;
        }
        while (v13 < *v9);
        uint64_t v1 = this;
        uint64_t v2 = *((void *)this + 5);
        int v3 = *(_DWORD *)v2;
        BOOL v11 = v49;
      }
      v6 &= v11;
      ++v4;
    }
    while (v4 < v3);
  }
  for (uint64_t i = *((void *)v1 + 2); i; uint64_t i = *(void *)(i + 48))
  {
    int v19 = *(_DWORD *)(i + 12);
    if (v19 >= 1)
    {
      uint64_t v20 = 0;
      for (uint64_t j = 0; j < v19; ++j)
      {
        uint64_t v22 = *(void *)(i + 16) + v20;
        int v23 = *(unsigned __int8 *)(v22 + 36);
        BOOL v24 = v23 == (*(unsigned __int8 *)(v22 + 37) ^ 1);
        if (!*(void *)(v22 + 56))
        {
          kdu_line_buf::pre_create((kdu_line_buf *)v22, (kd_multi_transform *)((char *)v1 + 64), *(_DWORD *)(v22 + 20), v23 != 0, *(unsigned char *)(v22 + 38) == 0, 2u, 2);
          int v19 = *(_DWORD *)(i + 12);
        }
        v6 &= v24;
        v20 += 80;
      }
    }
  }
  uint64_t v25 = *((void *)v1 + 6);
  int v26 = *(_DWORD *)v25;
  if (*(int *)v25 >= 1)
  {
    uint64_t v27 = 0;
    do
    {
      uint64_t v28 = *(void *)(*(void *)(v25 + 8) + 8 * v27);
      int v29 = *(unsigned __int8 *)(v28 + 36);
      BOOL v30 = v29 == (*(unsigned __int8 *)(v28 + 37) ^ 1);
      if (!*(void *)(v28 + 56) && !*(void *)(v28 + 64) && (*(_DWORD *)(v28 + 72) & 0x80000000) != 0)
      {
        kdu_line_buf::pre_create((kdu_line_buf *)v28, (kd_multi_transform *)((char *)v1 + 64), *(_DWORD *)(v28 + 20), v29 != 0, *(unsigned char *)(v28 + 38) == 0, 2u, 2);
        uint64_t v25 = *((void *)v1 + 6);
        int v26 = *(_DWORD *)v25;
      }
      v6 &= v30;
      ++v27;
    }
    while (v27 < v26);
  }
  if ((v6 & 1) == 0)
  {
    uint64_t v51 = 0;
    memset(v50, 0, sizeof(v50));
    kdu_error::kdu_error((kdu_error *)v50, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v50[0] + 16))(v50, "Cannot implement multi-component transform.  It seems that one or more transform steps require image samples to be treated as reversible, where other steps require the same image samples to be treated as irreversible.  This is illegal in Part-1 of the JPEG2000 standard.  Although Part-2 is not clear on the matter, Kakadu's implementation insists only that irreversibly compressed samples not be subjected to reversible multi-component transform processing during decompression -- this is eminently reasonable, since exact reversible processing of data which is not already exactly defined, makes no sense.  The reverse case, in which reversibly compressed data is processed using an irreversible multi-component transform, can make sense, particularly where there are multiple ways to render the same original reversibly compressed codestream components to MCT outputs.");
    kdu_error::~kdu_error((kdu_error *)v50);
  }
  kdu_sample_allocator::finalize((uint64_t)v1 + 64);
  int v31 = **((_DWORD **)v1 + 5);
  if (v31 >= 1)
  {
    for (uint64_t k = 0; k < v31; ++k)
    {
      uint64_t v33 = *((void *)v1 + 4);
      uint64_t v34 = v33 + 160 * k;
      int v36 = *(_DWORD *)(v34 + 128);
      int v35 = (int *)(v34 + 128);
      if (v36 >= 1)
      {
        uint64_t v37 = 0;
        uint64_t v38 = 0;
        uint64_t v39 = (void *)(v33 + 160 * k + 136);
        do
        {
          kdu_line_buf::create(*v39 + v37);
          ++v38;
          v37 += 16;
        }
        while (v38 < *v35);
        int v31 = **((_DWORD **)v1 + 5);
      }
    }
  }
  for (uint64_t m = *((void *)v1 + 2); m; uint64_t m = *(void *)(m + 48))
  {
    if (*(int *)(m + 12) >= 1)
    {
      uint64_t v41 = 0;
      uint64_t v42 = 0;
      do
      {
        uint64_t v43 = *(void *)(m + 16);
        if (!*(void *)(v43 + v41 + 56))
        {
          kdu_line_buf::create(v43 + v41);
          if (*(unsigned char *)(v43 + v41 + 39)) {
            kd_multi_line::reset((kd_multi_line *)(v43 + v41), *(_DWORD *)(v43 + v41 + 44), *(float *)(v43 + v41 + 48));
          }
        }
        ++v42;
        v41 += 80;
      }
      while (v42 < *(int *)(m + 12));
    }
  }
  uint64_t v44 = *((void *)v1 + 6);
  int v45 = *(_DWORD *)v44;
  if (*(int *)v44 >= 1)
  {
    uint64_t v46 = 0;
    do
    {
      uint64_t v47 = *(void *)(*(void *)(v44 + 8) + 8 * v46);
      if (!*(void *)(v47 + 56) && !*(void *)(v47 + 64) && (*(_DWORD *)(v47 + 72) & 0x80000000) != 0)
      {
        kdu_line_buf::create(*(void *)(*(void *)(v44 + 8) + 8 * v46));
        if (!*(unsigned char *)(v47 + 39)) {
          kd_multi_transform::create_resources();
        }
        kd_multi_line::reset((kd_multi_line *)v47, *(_DWORD *)(v47 + 44), *(float *)(v47 + 48));
        uint64_t v44 = *((void *)v1 + 6);
        int v45 = *(_DWORD *)v44;
      }
      ++v46;
    }
    while (v46 < v45);
  }
}

void sub_1886D00C4(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886D00D0()
{
  _Unwind_Resume(v0);
}

uint64_t kd_multi_transform::get_scratch_floats(kd_multi_transform *this, int a2)
{
  int v2 = *((_DWORD *)this + 30);
  if (v2 < a2)
  {
    *((_DWORD *)this + 30) = v2 + a2;
    uint64_t v3 = *((void *)this + 16);
    if (v3) {
      MEMORY[0x18C11C0C0](v3, 0x1000C8052888210);
    }
    operator new[]();
  }
  return *((void *)this + 16);
}

void kdu_multi_synthesis::create()
{
}

void kd_multi_synthesis::create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
}

void kd_multi_synthesis::~kd_multi_synthesis(kd_multi_synthesis *this)
{
  *(void *)this = &unk_1ED4E49A8;
  int v2 = (kd_multi_synthesis *)((char *)this + 8);
  *((void *)this + 1) = &unk_1ED4E49F0;
  uint64_t v3 = *((void *)this + 18);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C8052888210);
  }
  kd_multi_transform::~kd_multi_transform(v2);
  *(void *)this = &unk_1ED4E5570;
}

{
  uint64_t vars8;

  kd_multi_synthesis::~kd_multi_synthesis(this);

  JUMPOUT(0x18C11C0E0);
}

void non-virtual thunk to'kd_multi_synthesis::~kd_multi_synthesis(kd_multi_synthesis *this)
{
}

{
  uint64_t vars8;

  kd_multi_synthesis::~kd_multi_synthesis((kd_multi_synthesis *)((char *)this - 8));

  JUMPOUT(0x18C11C0E0);
}

BOOL kd_multi_synthesis::terminate_queues(BOOL result, kdu_thread_entity *this)
{
  if (this)
  {
    int v2 = *(kdu_thread_queue **)(result + 104);
    if (!v2 || !*(void *)(*(void *)(result + 40) + 16)) {
      kd_multi_synthesis::terminate_queues();
    }
    return kdu_thread_entity::terminate(this, v2, 1, 0);
  }
  return result;
}

uint64_t kd_multi_synthesis::get_size(kd_multi_synthesis *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v2 = *((void *)this + 7), *(_DWORD *)v2 <= (signed int)a2)) {
    kd_multi_synthesis::get_size();
  }
  return *(void *)(*(void *)(*(void *)(v2 + 8) + 8 * a2) + 16);
}

uint64_t kd_multi_synthesis::get_line(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v5 = *(void *)(a1 + 56), *(_DWORD *)v5 <= (signed int)a2)) {
    kd_multi_synthesis::get_line();
  }
  uint64_t result = kd_multi_synthesis::get_line(a1, *(void *)(*(void *)(v5 + 8) + 8 * a2), *(unsigned int *)(*(void *)(a1 + 144) + 4 * a2), a3);
  if (result) {
    ++*(_DWORD *)(*(void *)(a1 + 144) + 4 * a2);
  }
  return result;
}

uint64_t kd_multi_synthesis::get_line(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(void *)(a2 + 56)) {
    kd_multi_synthesis::get_line();
  }
  uint64_t v4 = a2;
  if (!*(unsigned char *)(a2 + 39))
  {
    int v7 = *(_DWORD *)(a2 + 24);
    if (v7 == a3)
    {
      int v8 = *(_DWORD *)(a2 + 32);
      if (v8 <= 0) {
        kd_multi_synthesis::get_line();
      }
LABEL_6:
      *(_DWORD *)(v4 + 32) = v8 - 1;
      uint64_t v9 = *(void *)(v4 + 64);
      if (v9) {
        --*(_DWORD *)(v9 + 44);
      }
      return v4;
    }
    if (v7 != a3 - 1) {
      kd_multi_synthesis::get_line();
    }
    if (*(int *)(a2 + 32) > 0) {
      return 0;
    }
    uint64_t v12 = *(void *)(a2 + 64);
    if (v12)
    {
      if (*(unsigned char *)(v12 + 8))
      {
        unint64_t v13 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - *(void *)(v12 + 16)) >> 4);
        if ((v13 & 0x80000000) != 0 || *(_DWORD *)(v12 + 24) <= (int)v13) {
          kd_multi_synthesis::get_line();
        }
        uint64_t v14 = *(void *)(v12 + 32);
        uint64_t v15 = 8 * (int)v13;
        int v16 = *(kd_multi_line **)(v14 + v15);
        if (!v16) {
          kd_multi_synthesis::get_line();
        }
        if (!kd_multi_synthesis::get_line(a1, *(void *)(v14 + v15), a3, a4)) {
          return 0;
        }
        *(_DWORD *)(v4 + 24) = a3;
        *(_DWORD *)(v4 + 32) = *(_DWORD *)(v4 + 28);
        kd_multi_line::copy(v4, v16, *(_DWORD *)(v4 + 44), *(float *)(v4 + 48));
      }
      else
      {
        if (*(int *)(v12 + 44) > 0) {
          return 0;
        }
        int v45 = *(_DWORD *)(v12 + 40);
        int v46 = *(_DWORD *)(v12 + 24);
        while (v45 < v46)
        {
          uint64_t v47 = *(void *)(*(void *)(v12 + 32) + 8 * v45);
          if (v47 && !*(unsigned char *)(v47 + 39))
          {
            if (!kd_multi_synthesis::get_line(a1, v47, a3, a4)) {
              return 0;
            }
            ++*(_DWORD *)(v47 + 32);
            uint64_t v48 = *(void *)(v47 + 64);
            if (v48) {
              ++*(_DWORD *)(v48 + 44);
            }
            int v45 = *(_DWORD *)(v12 + 40);
            int v46 = *(_DWORD *)(v12 + 24);
          }
          *(_DWORD *)(v12 + 40) = ++v45;
        }
        (*(void (**)(uint64_t))(*(void *)v12 + 40))(v12);
        if (*(int *)(v12 + 24) >= 1)
        {
          uint64_t v50 = 0;
          do
          {
            uint64_t v51 = *(void *)(*(void *)(v12 + 32) + 8 * v50);
            if (v51)
            {
              if (*(_DWORD *)(v51 + 24) != a3) {
                kd_multi_synthesis::get_line();
              }
              --*(_DWORD *)(v51 + 32);
              uint64_t v52 = *(void *)(v51 + 64);
              if (v52) {
                --*(_DWORD *)(v52 + 44);
              }
            }
            ++v50;
          }
          while (v50 < *(int *)(v12 + 24));
        }
        if (*(int *)(v12 + 12) >= 1)
        {
          uint64_t v53 = 0;
          uint64_t v54 = 0;
          do
          {
            uint64_t v55 = *(void *)(v12 + 16);
            uint64_t v56 = v55 + v53;
            if (*(_DWORD *)(v55 + v53 + 32) || *(_DWORD *)(v56 + 24) != v7) {
              kd_multi_synthesis::get_line();
            }
            *(_DWORD *)(v56 + 24) = a3;
            int v57 = *(_DWORD *)(v55 + v53 + 28);
            *(_DWORD *)(v56 + 32) = v57;
            *(_DWORD *)(v12 + 44) += v57;
            ++v54;
            v53 += 80;
          }
          while (v54 < *(int *)(v12 + 12));
        }
        *(_DWORD *)(v12 + 40) = 0;
      }
    }
    else
    {
      uint64_t v17 = *(unsigned int *)(a2 + 72);
      if ((v17 & 0x80000000) != 0) {
        kd_multi_synthesis::get_line();
      }
      uint64_t v18 = *(void *)(*(void *)(a1 + 48) + 8);
      if (*(void *)(v18 + 8 * v17) != a2) {
        kd_multi_synthesis::get_line();
      }
      BOOL v19 = v17 >= 3 || *(unsigned char *)(a1 + 16) == 0;
      int v20 = !v19;
      if (!v19)
      {
        uint64_t v21 = 0;
        while (1)
        {
          uint64_t v22 = *(void *)(v18 + v21);
          if (*(_DWORD *)(v22 + 24) != v7) {
            kd_multi_synthesis::get_line();
          }
          if (*(int *)(v22 + 32) >= 1) {
            return 0;
          }
          v21 += 8;
          if (v21 == 24)
          {
            LODWORD(v17) = 0;
            break;
          }
        }
      }
      unint64_t v23 = v17;
      uint64_t v24 = 160 * v17;
      do
      {
        uint64_t v25 = *(void *)(a1 + 40);
        uint64_t v26 = v25 + v24;
        int v27 = *(_DWORD *)(v25 + v24 + 112);
        if (!v27)
        {
          if (*(unsigned char *)(v26 + 104))
          {
            if (!a4 || (uint64_t v32 = v25 + v24, *(int *)(v25 + v24 + 120) <= 0)) {
              kd_multi_synthesis::get_line();
            }
            kdu_thread_entity::process_jobs((kdu_thread_entity *)a4, *(kdu_thread_queue **)(v32 + 16), 0, 1);
            int v33 = *(_DWORD *)(v32 + 116);
            int v27 = *(_DWORD *)(v32 + 120);
            *(_DWORD *)(v32 + 108) = v33;
            if (v33 <= 0) {
              int v34 = v27;
            }
            else {
              int v34 = 0;
            }
            int v35 = *(_DWORD *)(v32 + 40) - (v27 + a3);
            if (v35 >= *(_DWORD *)(v32 + 124)) {
              int v35 = *(_DWORD *)(v32 + 124);
            }
            *(_DWORD *)(v26 + 112) = v27;
            *(_DWORD *)(v32 + 116) = v34;
            *(_DWORD *)(v32 + 120) = v35;
            if (v35 >= 1)
            {
              kdu_thread_entity::add_jobs(a4, *(kdu_thread_queue **)(v32 + 16), 1, 0);
              int v27 = *(_DWORD *)(v26 + 112);
            }
          }
          else
          {
            int v36 = (_DWORD *)(v25 + v24);
            uint64_t v37 = *(void *)(v25 + v24 + 16);
            if (a4) {
              BOOL v38 = v37 == 0;
            }
            else {
              BOOL v38 = 1;
            }
            char v39 = !v38;
            if (a4 | v37 && (v39 & 1) == 0) {
              kd_multi_synthesis::get_line();
            }
            v36[27] = 0;
            int v40 = v36[10] - a3;
            if (v40 >= v36[31]) {
              int v40 = v36[31];
            }
            v36[29] = 0;
            v36[30] = v40;
            (*(void (**)(uint64_t, uint64_t, void))(*(void *)v36 + 16))(v26, a4, 0);
            int v27 = v36[30];
            *(_DWORD *)(v26 + 112) = v27;
            v36[30] = 0;
          }
        }
        uint64_t v28 = *(void *)(v26 + 136);
        uint64_t v29 = *(int *)(v26 + 108);
        *(_DWORD *)(v26 + 108) = v29 + 1;
        *(_OWORD *)(v26 + 24) = *(_OWORD *)(v28 + 16 * v29);
        *(_DWORD *)(v26 + 112) = v27 - 1;
        if (v23++ >= 2) {
          char v31 = 0;
        }
        else {
          char v31 = v20;
        }
        v24 += 160;
      }
      while ((v31 & 1) != 0);
      if (v20)
      {
        uint64_t v41 = *(uint64_t **)(*(void *)(a1 + 48) + 8);
        if (kdu_convert_ycc_to_rgb(*v41, v41[1], v41[2], -1))
        {
          uint64_t v59 = 0;
          memset(v58, 0, sizeof(v58));
          kdu_error::kdu_error((kdu_error *)v58, "Kakadu Core Error:\n");
          (*(void (**)(_OWORD *, const char *))(*(void *)&v58[0] + 16))(v58, "Corrupt JP2 data");
          kdu_error::~kdu_error((kdu_error *)v58);
        }
        for (uint64_t i = 0; i != 3; ++i)
        {
          uint64_t v43 = v41[i];
          kd_multi_line::apply_offset(v43, *(_DWORD *)(v43 + 44), *(float *)(v43 + 48));
          int v44 = *(_DWORD *)(v43 + 28);
          ++*(_DWORD *)(v43 + 24);
          *(_DWORD *)(v43 + 32) = v44;
        }
      }
      else
      {
        kd_multi_line::apply_offset(v4, *(_DWORD *)(v4 + 44), *(float *)(v4 + 48));
        int v49 = *(_DWORD *)(v4 + 28);
        ++*(_DWORD *)(v4 + 24);
        *(_DWORD *)(v4 + 32) = v49;
      }
    }
    if (*(_DWORD *)(v4 + 24) != a3 || (int v8 = *(_DWORD *)(v4 + 32), v8 <= 0)) {
      kd_multi_synthesis::get_line();
    }
    goto LABEL_6;
  }
  return v4;
}

void sub_1886D0C8C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886D0C98()
{
  _Unwind_Resume(v0);
}

BOOL kd_multi_synthesis::is_line_precise(kd_multi_synthesis *this, unsigned int a2)
{
  BOOL result = 0;
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v4 = *((void *)this + 7);
    if (v4) {
      return *(_DWORD *)v4 > (signed int)a2 && *(unsigned char *)(*(void *)(*(void *)(v4 + 8) + 8 * a2) + 38) != 0;
    }
  }
  return result;
}

BOOL kd_multi_synthesis::is_line_absolute(kd_multi_synthesis *this, unsigned int a2)
{
  BOOL result = 0;
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v4 = *((void *)this + 7);
    if (v4) {
      return *(_DWORD *)v4 > (signed int)a2 && *(unsigned char *)(*(void *)(*(void *)(v4 + 8) + 8 * a2) + 36) != 0;
    }
  }
  return result;
}

void kdu_multi_analysis::create()
{
}

void kd_multi_analysis::create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

void kd_multi_analysis::~kd_multi_analysis(kd_multi_analysis *this)
{
  *(void *)this = &unk_1ED4E4448;
  uint64_t v2 = (kd_multi_analysis *)((char *)this + 8);
  *((void *)this + 1) = &unk_1ED4E4490;
  uint64_t v3 = *((void *)this + 18);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C8052888210);
  }
  kd_multi_transform::~kd_multi_transform(v2);
  *(void *)this = &unk_1ED4E54D8;
}

{
  uint64_t vars8;

  kd_multi_analysis::~kd_multi_analysis(this);

  JUMPOUT(0x18C11C0E0);
}

void non-virtual thunk to'kd_multi_analysis::~kd_multi_analysis(kd_multi_analysis *this)
{
}

{
  uint64_t vars8;

  kd_multi_analysis::~kd_multi_analysis((kd_multi_analysis *)((char *)this - 8));

  JUMPOUT(0x18C11C0E0);
}

BOOL kd_multi_analysis::terminate_queues(BOOL result, kdu_thread_entity *this)
{
  if (this)
  {
    uint64_t v2 = *(kdu_thread_queue **)(result + 104);
    if (!v2 || !*(void *)(*(void *)(result + 40) + 16)) {
      kd_multi_analysis::terminate_queues();
    }
    return kdu_thread_entity::terminate(this, v2, 1, 0);
  }
  return result;
}

void *kd_multi_analysis::prepare_network_for_inversion(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[4];
  if (v2)
  {
    uint64_t v3 = 0;
    do
    {
      if (*(unsigned char *)(v2 + 8))
      {
        uint64_t v4 = *(unsigned int *)(v2 + 24);
        if ((int)v4 >= 1)
        {
          uint64_t v5 = 0;
          uint64_t v6 = 8 * (*(_DWORD *)(v2 + 12) & ~(*(int *)(v2 + 12) >> 31));
          uint64_t v7 = 8 * v4;
          uint64_t v8 = 28;
          do
          {
            if (v6 == v5) {
              kd_multi_analysis::prepare_network_for_inversion();
            }
            if (!*(_DWORD *)(*(void *)(v2 + 16) + v8))
            {
              uint64_t v9 = *(void *)(v2 + 32);
              uint64_t v10 = *(void *)(v9 + v5);
              if (v10)
              {
                --*(_DWORD *)(v10 + 28);
                *(void *)(v9 + v5) = 0;
              }
            }
            v5 += 8;
            v8 += 80;
          }
          while (v7 != v5);
        }
      }
      else
      {
        this = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 48))(v2);
        if (this)
        {
          uint64_t v11 = *(unsigned int *)(v2 + 12);
          if ((int)v11 >= 1)
          {
            uint64_t v12 = (unsigned char *)(*(void *)(v2 + 16) + 39);
            do
            {
              unsigned char *v12 = 1;
              v12 += 80;
              --v11;
            }
            while (v11);
          }
          uint64_t v13 = *(unsigned int *)(v2 + 24);
          if ((int)v13 >= 1)
          {
            uint64_t v14 = 0;
            uint64_t v15 = 8 * v13;
            do
            {
              uint64_t v16 = *(void *)(v2 + 32);
              uint64_t v17 = *(void *)(v16 + v14);
              if (v17)
              {
                --*(_DWORD *)(v17 + 28);
                *(void *)(v16 + v14) = 0;
              }
              v14 += 8;
            }
            while (v15 != v14);
          }
          uint64_t v3 = (uint64_t)this;
        }
      }
      uint64_t v2 = *(void *)(v2 + 56);
    }
    while (v2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  for (uint64_t i = v1[3]; i; uint64_t i = *(void *)(i + 48))
  {
    uint64_t v19 = *(unsigned int *)(i + 24);
    if ((int)v19 >= 1)
    {
      uint64_t v20 = 0;
      uint64_t v21 = 8 * v19;
      uint64_t v22 = 39;
      do
      {
        uint64_t v23 = *(void *)(i + 32);
        uint64_t v24 = *(void *)(v23 + v20);
        if (v24)
        {
          if (*(unsigned char *)(v24 + 39))
          {
            *(void *)(v23 + v20) = 0;
            --*(_DWORD *)(v24 + 28);
            if (*(unsigned char *)(i + 8)) {
              *(unsigned char *)(*(void *)(i + 16) + v22) = 1;
            }
          }
        }
        v20 += 8;
        v22 += 80;
      }
      while (v21 != v20);
    }
  }
  uint64_t v25 = (int *)v1[6];
  if (*v25 >= 1)
  {
    uint64_t v26 = 0;
    do
    {
      if (*(int *)(*(void *)(*((void *)v25 + 1) + 8 * v26) + 28) <= 0)
      {
        uint64_t v36 = 0;
        memset(v35, 0, sizeof(v35));
        kdu_error::kdu_error((kdu_error *)v35, "Kakadu Core Error:\n");
        (*(void (**)(_OWORD *, const char *))(*(void *)&v35[0] + 16))(v35, "Cannot perform forward multi-component transform based on the source image components supplied.  The multi-component transform is defined from the perspective of decompression (i.e., synthesis, or inverse transformation).  Not all of the defined transform blocks may be invertible.  Also, if the defined transform blocks do not use all codestream components to produce final output image components during decompression, it will not be possible to work back from the final image components to codestream components which can be subjected to spatial wavelet transformation and coding.  One of these conditions has been encountered with the configuration you are targeting during compression.");
        if (v3)
        {
          (*(void (**)(_OWORD *, const char *))(*(void *)&v35[0] + 16))(v35, "  The following additional explanation is available ---- ");
          (*(void (**)(_OWORD *, uint64_t))(*(void *)&v35[0] + 16))(v35, v3);
        }
        kdu_error::~kdu_error((kdu_error *)v35);
      }
      ++v26;
    }
    while (v26 < *v25);
  }
  uint64_t v27 = v1[7];
  int v28 = *(_DWORD *)v27;
  if (*(int *)v27 >= 1)
  {
    uint64_t v29 = 0;
    do
    {
      uint64_t v30 = v1[4];
      if (v30)
      {
        uint64_t v31 = *(void *)(*(void *)(v27 + 8) + 8 * v29);
        do
        {
          if (*(int *)(v31 + 28) < 2) {
            break;
          }
          uint64_t v32 = *(unsigned int *)(v30 + 24);
          if ((int)v32 >= 1)
          {
            int v33 = *(void **)(v30 + 32);
            while (*v33 != *(void *)(*(void *)(v27 + 8) + 8 * v29))
            {
              ++v33;
              if (!--v32) {
                goto LABEL_52;
              }
            }
            void *v33 = 0;
            uint64_t v27 = v1[7];
            uint64_t v34 = *(void *)(*(void *)(v27 + 8) + 8 * v29);
            --*(_DWORD *)(v34 + 28);
          }
LABEL_52:
          uint64_t v30 = *(void *)(v30 + 56);
        }
        while (v30);
        int v28 = *(_DWORD *)v27;
      }
      ++v29;
    }
    while (v29 < v28);
  }
  return this;
}

void sub_1886D15C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886D15D4()
{
  _Unwind_Resume(v0);
}

uint64_t kd_multi_analysis::get_size(kd_multi_analysis *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v2 = *((void *)this + 7), *(_DWORD *)v2 <= (signed int)a2)) {
    kd_multi_analysis::get_size();
  }
  return *(void *)(*(void *)(*(void *)(v2 + 8) + 8 * a2) + 16);
}

uint64_t kd_multi_analysis::exchange_line(uint64_t a1, unsigned int a2, kd_multi_line *this, uint64_t a4)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v5 = *(void *)(a1 + 56), *(_DWORD *)v5 <= (signed int)a2)) {
    kd_multi_analysis::exchange_line();
  }
  uint64_t v6 = *(unsigned int *)(*(void *)(a1 + 144) + 4 * a2);
  uint64_t v7 = *(void *)(*(void *)(v5 + 8) + 8 * a2);
  if ((int)v6 >= *(_DWORD *)(v7 + 16)) {
    return 0;
  }
  if (*(_DWORD *)(v7 + 28) != 1) {
    kd_multi_analysis::exchange_line();
  }
  if (this)
  {
    if ((kd_multi_line *)v7 != this || *((unsigned char *)this + 32)) {
      kd_multi_analysis::exchange_line();
    }
    uint64_t v10 = a2;
    kd_multi_line::apply_offset((uint64_t)this, -*((_DWORD *)this + 11), -*((float *)this + 12));
    kd_multi_analysis::advance_line(a1, (uint64_t)this, v6, a4);
    LODWORD(v6) = v6 + 1;
    *(_DWORD *)(*(void *)(a1 + 144) + 4 * v10) = v6;
  }
  if (*(_DWORD *)(v7 + 24) != v6 - 1) {
    kd_multi_analysis::exchange_line();
  }
  if (*(unsigned char *)(v7 + 32)) {
    return 0;
  }
  else {
    return v7;
  }
}

uint64_t kd_multi_analysis::advance_line(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(_DWORD *)(a2 + 28) != 1) {
    kd_multi_analysis::advance_line();
  }
  if (*(_DWORD *)(a2 + 24) != a3 - 1) {
    kd_multi_analysis::advance_line();
  }
  *(_DWORD *)(a2 + 24) = a3;
  *(unsigned char *)(a2 + 32) = 0;
  if (!*(unsigned char *)(a2 + 39))
  {
    uint64_t v7 = result;
    uint64_t v8 = *(void *)(a2 + 64);
    if (v8)
    {
      if (!*(unsigned char *)(v8 + 8))
      {
        *(unsigned char *)(a2 + 32) = 1;
        int v41 = *(_DWORD *)(v8 + 44);
        BOOL v34 = __OFSUB__(v41--, 1);
        *(_DWORD *)(v8 + 44) = v41;
        if (!((v41 < 0) ^ v34 | (v41 == 0))) {
          return result;
        }
        uint64_t v42 = *(unsigned int *)(v8 + 24);
        int v43 = *(_DWORD *)(v8 + 40);
        if (v43 < (int)v42)
        {
          uint64_t v44 = 8 * v43;
          do
          {
            uint64_t v45 = *(void *)(v8 + 32);
            uint64_t v46 = *(void *)(v45 + v44);
            if (v46)
            {
              if (*(unsigned char *)(v46 + 39))
              {
                *(void *)(v45 + v44) = 0;
              }
              else if (*(_DWORD *)(v46 + 24) < (int)a3 && *(unsigned char *)(v46 + 32))
              {
                return result;
              }
            }
            *(_DWORD *)(v8 + 40) = ++v43;
            v44 += 8;
          }
          while (v42 != v43);
        }
        if ((int)v42 >= 1)
        {
          uint64_t v47 = 0;
          uint64_t v48 = 8 * v42;
          do
          {
            uint64_t v49 = *(void *)(v8 + 32);
            uint64_t v50 = *(void *)(v49 + v47);
            if (v50 && *(_DWORD *)(v50 + 24) >= (int)a3)
            {
              int v51 = *(_DWORD *)(v50 + 28);
              BOOL v34 = __OFSUB__(v51, 1);
              int v52 = v51 - 1;
              if ((v52 < 0) ^ v34 | (v52 == 0)) {
                kd_multi_analysis::advance_line();
              }
              *(_DWORD *)(v50 + 28) = v52;
              *(void *)(v49 + v47) = 0;
            }
            v47 += 8;
          }
          while (v48 != v47);
        }
        BOOL result = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 56))(v8);
        int v53 = *(_DWORD *)(v8 + 24);
        if (v53 >= 1)
        {
          for (uint64_t i = 0; i < v53; ++i)
          {
            uint64_t v55 = *(void *)(*(void *)(v8 + 32) + 8 * i);
            if (v55)
            {
              BOOL result = kd_multi_analysis::advance_line(v7, v55, a3, a4);
              int v53 = *(_DWORD *)(v8 + 24);
            }
          }
        }
        if (*(int *)(v8 + 12) >= 1)
        {
          uint64_t v56 = 0;
          uint64_t v57 = 0;
          uint64_t v58 = *(void *)(v8 + 16);
          do
          {
            *(unsigned char *)(v58 + v56 + 32) = 0;
            uint64_t v58 = *(void *)(v8 + 16);
            int v59 = *(_DWORD *)(v58 + v56 + 28);
            if (v59 >= 1)
            {
              if (v59 != 1) {
                kd_multi_analysis::advance_line();
              }
              ++*(_DWORD *)(v8 + 44);
            }
            ++v57;
            v56 += 80;
          }
          while (v57 < *(int *)(v8 + 12));
        }
        *(_DWORD *)(v8 + 40) = 0;
        goto LABEL_89;
      }
      unint64_t v9 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - *(void *)(v8 + 16)) >> 4);
      if ((v9 & 0x80000000) != 0 || *(_DWORD *)(v8 + 24) <= (int)v9) {
        kd_multi_analysis::advance_line();
      }
      uint64_t v10 = *(void *)(v8 + 32);
      uint64_t v11 = *(void *)(v10 + 8 * (int)v9);
      int v12 = *(_DWORD *)(v11 + 28);
      if (*(_DWORD *)(v11 + 24) < (int)a3)
      {
        if (v12 < 1 || *(unsigned char *)(v11 + 39)) {
          kd_multi_analysis::advance_line();
        }
        kd_multi_line::copy(v11, (kd_multi_line *)a2, -*(_DWORD *)(v11 + 44), -*(float *)(v11 + 48));
        BOOL result = kd_multi_analysis::advance_line(v7, v11, a3, a4);
LABEL_89:
        if (*(unsigned char *)(a2 + 32)) {
          kd_multi_analysis::advance_line();
        }
        return result;
      }
      BOOL v34 = __OFSUB__(v12, 1);
      int v60 = v12 - 1;
      if ((v60 < 0) ^ v34 | (v60 == 0)) {
        kd_multi_analysis::advance_line();
      }
      *(_DWORD *)(v11 + 28) = v60;
      *(void *)(v10 + 8 * (int)v9) = 0;
    }
    else
    {
      uint64_t v13 = *(unsigned int *)(a2 + 72);
      if ((v13 & 0x80000000) != 0) {
        kd_multi_analysis::advance_line();
      }
      if (*(void *)(*(void *)(*(void *)(result + 48) + 8) + 8 * v13) != a2) {
        kd_multi_analysis::advance_line();
      }
      BOOL v14 = v13 >= 3 || *(unsigned char *)(result + 16) == 0;
      char v15 = !v14;
      if (v14)
      {
LABEL_30:
        int v20 = ~a3;
        unint64_t v21 = v13;
        uint64_t v22 = 160 * v13;
        do
        {
          uint64_t v23 = *(void *)(v7 + 40);
          uint64_t v24 = v23 + v22;
          int v25 = *(_DWORD *)(v23 + v22 + 112);
          if (!v25)
          {
            if (*(unsigned char *)(v24 + 104))
            {
              if (!a4) {
                kd_multi_analysis::advance_line();
              }
              uint64_t v26 = v23 + v22;
              int v27 = *(_DWORD *)(v23 + v22 + 120);
              if (v27)
              {
                kdu_thread_entity::process_jobs((kdu_thread_entity *)a4, *(kdu_thread_queue **)(v26 + 16), 0, 1);
                int v27 = 0;
                if (!*(_DWORD *)(v26 + 116)) {
                  int v27 = *(_DWORD *)(v26 + 120);
                }
              }
              int v28 = *(_DWORD *)(v26 + 108) - v27;
              *(_DWORD *)(v26 + 116) = v27;
              *(_DWORD *)(v26 + 120) = v28;
              if (v27 >= 1) {
                *(_DWORD *)(v26 + 108) = 0;
              }
              BOOL result = kdu_thread_entity::add_jobs(a4, *(kdu_thread_queue **)(v23 + v22 + 16), 1, 0);
            }
            else
            {
              uint64_t v29 = (_DWORD *)(v23 + v22);
              uint64_t v30 = *(void *)(v23 + v22 + 16);
              if (a4) {
                BOOL v31 = v30 == 0;
              }
              else {
                BOOL v31 = 1;
              }
              char v32 = !v31;
              if (a4 | v30 && (v32 & 1) == 0) {
                kd_multi_analysis::advance_line();
              }
              int v33 = v29[27];
              v29[29] = 0;
              v29[30] = v33;
              v29[27] = 0;
              BOOL result = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)v29 + 16))(v23 + v22, a4, 0);
              v29[30] = 0;
            }
            int v25 = *(_DWORD *)(v23 + v22 + 124);
            if (*(_DWORD *)(v23 + v22 + 40) + v20 < v25) {
              int v25 = *(_DWORD *)(v23 + v22 + 40) + v20;
            }
            *(_DWORD *)(v24 + 112) = v25;
          }
          BOOL v34 = __OFSUB__(v25, 1);
          int v35 = v25 - 1;
          if (v35 < 0 == v34)
          {
            uint64_t v36 = v23 + v22;
            uint64_t v37 = *(void *)(v23 + v22 + 136);
            uint64_t v38 = *(int *)(v23 + v22 + 108);
            *(_DWORD *)(v36 + 108) = v38 + 1;
            *(_OWORD *)(v36 + 24) = *(_OWORD *)(v37 + 16 * v38);
            *(_DWORD *)(v24 + 112) = v35;
          }
          if (v21++ >= 2) {
            char v40 = 0;
          }
          else {
            char v40 = v15;
          }
          v22 += 160;
        }
        while ((v40 & 1) != 0);
        goto LABEL_89;
      }
      uint64_t v16 = 0;
      *(unsigned char *)(a2 + 32) = 1;
      uint64_t v17 = *(uint64_t **)(*(void *)(result + 48) + 8);
      while (*(_DWORD *)(v17[v16] + 24) >= (int)a3)
      {
        if (++v16 == 3)
        {
          BOOL result = kdu_convert_rgb_to_ycc(*v17, v17[1], v17[2]);
          if (result)
          {
            uint64_t v62 = 0;
            memset(v61, 0, sizeof(v61));
            kdu_error::kdu_error((kdu_error *)v61, "Kakadu Core Error:\n");
            (*(void (**)(_OWORD *, const char *))(*(void *)&v61[0] + 16))(v61, "Corrupt JP2 data");
            kdu_error::~kdu_error((kdu_error *)v61);
          }
          for (uint64_t j = 0; j != 3; ++j)
          {
            uint64_t v19 = v17[j];
            if (!*(unsigned char *)(v19 + 32)) {
              kd_multi_analysis::advance_line();
            }
            *(unsigned char *)(v19 + 32) = 0;
          }
          LODWORD(v13) = 0;
          goto LABEL_30;
        }
      }
    }
  }
  return result;
}

void sub_1886D1C30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886D1C3C()
{
  _Unwind_Resume(v0);
}

BOOL kd_multi_analysis::is_line_precise(kd_multi_analysis *this, unsigned int a2)
{
  BOOL result = 0;
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v4 = *((void *)this + 7);
    if (v4) {
      return *(_DWORD *)v4 > (signed int)a2 && *(unsigned char *)(*(void *)(*(void *)(v4 + 8) + 8 * a2) + 38) != 0;
    }
  }
  return result;
}

BOOL kd_multi_analysis::is_line_absolute(kd_multi_analysis *this, unsigned int a2)
{
  BOOL result = 0;
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v4 = *((void *)this + 7);
    if (v4) {
      return *(_DWORD *)v4 > (signed int)a2 && *(unsigned char *)(*(void *)(*(void *)(v4 + 8) + 8 * a2) + 36) != 0;
    }
  }
  return result;
}

void kd_multi_null_block::initialize(uint64_t a1, int a2, int a3, uint64_t *a4, int a5, int a6, _DWORD *a7, _DWORD *a8, kd_multi_transform *a9)
{
  uint64_t v22 = a4;
  int v20 = a6;
  int v21 = a5;
  unint64_t scratch_ints = kd_multi_transform::get_scratch_ints(a9, a5 + 2 * a6);
  unint64_t scratch_floats = kd_multi_transform::get_scratch_floats(a9, a6);
  *(void *)uint64_t v19 = 0;
  kdu_tile::get_mct_block_info(&v22, a2, a3, &v19[1], v19, &v21, &v20, scratch_ints, (int *)(scratch_ints + 4 * a5), scratch_floats, (int *)(scratch_ints + 4 * a5 + 4 * a6), 0);
  if (*(void *)v19 == __PAIR64__(*a7, *a8))
  {
    unint64_t v18 = v20;
    *(_DWORD *)(a1 + 12) = v20;
    is_mul_ok(v18, 0x50uLL);
    operator new[]();
  }
  kd_multi_null_block::initialize();
}

void kd_multi_matrix_block::initialize(uint64_t a1, int a2, int a3, uint64_t *a4, int a5, int a6, _DWORD *a7, _DWORD *a8, kd_multi_transform *a9)
{
  uint64_t v22 = a4;
  int v20 = a6;
  int v21 = a5;
  unint64_t scratch_ints = kd_multi_transform::get_scratch_ints(a9, a6 + a5);
  unint64_t scratch_floats = kd_multi_transform::get_scratch_floats(a9, a6);
  *(void *)uint64_t v19 = 0;
  kdu_tile::get_mct_block_info(&v22, a2, a3, &v19[1], v19, &v21, &v20, scratch_ints, (int *)(scratch_ints + 4 * a5), scratch_floats, 0, 0);
  if (*(void *)v19 == __PAIR64__(*a7, *a8))
  {
    unint64_t v18 = v20;
    *(_DWORD *)(a1 + 12) = v20;
    is_mul_ok(v18, 0x50uLL);
    operator new[]();
  }
  kd_multi_matrix_block::initialize();
}

uint64_t kd_multi_matrix_block::normalize_coefficients(uint64_t this)
{
  uint64_t v1 = *(int *)(this + 24);
  uint64_t v2 = *(unsigned int *)(this + 24);
  if ((int)v1 < 1)
  {
    char v5 = 0;
  }
  else
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
    char v5 = 0;
    uint64_t v6 = *(void *)(this + 32);
    do
    {
      uint64_t v7 = *(void *)(v6 + 8 * v4);
      if (v7)
      {
        if (*(unsigned char *)(v7 + 39)) {
          kd_multi_matrix_block::normalize_coefficients();
        }
        int v8 = *(_DWORD *)(v7 + 40);
        if (v8)
        {
          v5 |= *(unsigned char *)(v7 + 38) != 0;
          uint64_t v9 = *(unsigned int *)(this + 12);
          if ((int)v9 >= 1)
          {
            float v10 = (float)(1 << v8);
            uint64_t v11 = (float *)(*(void *)(this + 64) + v3);
            do
            {
              float *v11 = *v11 * v10;
              v11 += v2;
              --v9;
            }
            while (v9);
          }
        }
        else
        {
          char v5 = 1;
        }
      }
      ++v4;
      v3 += 4;
    }
    while (v4 != v2);
  }
  uint64_t v12 = *(unsigned int *)(this + 12);
  if ((int)v12 >= 1)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = *(void *)(this + 16);
    do
    {
      int v16 = *(_DWORD *)(v15 + 80 * v14 + 40);
      if (v16)
      {
        v5 |= *(unsigned char *)(v15 + 80 * v14 + 38) != 0;
        if ((int)v2 >= 1)
        {
          float v17 = 1.0 / (float)(1 << v16);
          unint64_t v18 = (float *)(*(void *)(this + 64) + v13);
          uint64_t v19 = v2;
          do
          {
            *unint64_t v18 = v17 * *v18;
            ++v18;
            --v19;
          }
          while (v19);
        }
      }
      else
      {
        char v5 = 1;
      }
      ++v14;
      v13 += 4 * v1;
    }
    while (v14 != v12);
  }
  if (v5)
  {
    if ((int)v1 >= 1)
    {
      uint64_t v20 = *(void *)(this + 32);
      do
      {
        if (*(void *)v20) {
          *(unsigned char *)(*(void *)v20 + 38) = 1;
        }
        v20 += 8;
        --v2;
      }
      while (v2);
    }
    if ((int)v12 >= 1)
    {
      int v21 = (unsigned char *)(*(void *)(this + 16) + 38);
      do
      {
        *int v21 = 1;
        v21 += 80;
        --v12;
      }
      while (v12);
    }
  }
  return this;
}

void kd_multi_matrix_block::perform_transform(kd_multi_matrix_block *this)
{
  if (*((int *)this + 3) >= 1)
  {
    uint64_t v2 = 0;
    while (1)
    {
      uint64_t v3 = *((void *)this + 2);
      uint64_t v4 = (unsigned int *)(v3 + 80 * v2);
      uint64_t v5 = *v4;
      if ((*((unsigned char *)v4 + 6) & 2) != 0) {
        break;
      }
      uint64_t v6 = (float *)*((void *)v4 + 1);
      if (!v6) {
        break;
      }
      if ((int)v5 >= 1)
      {
        int v7 = *(_DWORD *)(v3 + 80 * v2 + 48);
        uint64_t v8 = *v4;
        uint64_t v9 = (_DWORD *)*((void *)v4 + 1);
        do
        {
          *v9++ = v7;
          --v8;
        }
        while (v8);
      }
      LODWORD(v10) = *((_DWORD *)this + 6);
      if ((int)v10 >= 1)
      {
        uint64_t v11 = 0;
        do
        {
          uint64_t v12 = *(void *)(*((void *)this + 4) + 8 * v11);
          if (v12)
          {
            float v13 = *(float *)(*((void *)this + 8) + 4 * ((int)v11 + (int)v10 * (int)v2));
            if (v13 != 0.0)
            {
              if ((*(unsigned char *)(v12 + 6) & 2) != 0) {
                uint64_t v14 = 0;
              }
              else {
                uint64_t v14 = *(float **)(v12 + 8);
              }
              if (*(unsigned char *)(v12 + 36))
              {
                int v15 = *(_DWORD *)(v12 + 40);
                if (v15 >= 1) {
                  float v13 = v13 * (float)(1.0 / (float)(1 << v15));
                }
                if ((int)v5 >= 1)
                {
                  uint64_t v16 = v5;
                  float v17 = v6;
                  do
                  {
                    int v18 = *(_DWORD *)v14++;
                    *float v17 = *v17 + (float)(v13 * (float)v18);
                    ++v17;
                    --v16;
                  }
                  while (v16);
                }
              }
              else if ((int)v5 >= 1)
              {
                uint64_t v19 = v5;
                uint64_t v20 = v6;
                do
                {
                  float v21 = *v14++;
                  *uint64_t v20 = *v20 + (float)(v13 * v21);
                  ++v20;
                  --v19;
                }
                while (v19);
              }
            }
          }
          ++v11;
          uint64_t v10 = *((int *)this + 6);
        }
        while (v11 < v10);
      }
LABEL_57:
      if (++v2 >= *((int *)this + 3)) {
        return;
      }
    }
    if (*((void *)this + 10))
    {
      if ((*((unsigned char *)v4 + 6) & 2) != 0)
      {
LABEL_29:
        uint64_t v22 = (_WORD *)*((void *)v4 + 1);
LABEL_32:
        uint64_t v23 = (int *)*((void *)this + 11);
        bzero(v23, 4 * (int)v5);
        LODWORD(v24) = *((_DWORD *)this + 6);
        if ((int)v24 >= 1)
        {
          uint64_t v25 = 0;
          uint64_t v26 = *((void *)this + 10);
          uint64_t v27 = *((void *)this + 4);
          do
          {
            int v28 = v25 + v24 * v2;
            int v29 = *(__int16 *)(v26 + 2 * v28);
            int v30 = *(unsigned __int16 *)(v26 + 2 * v28);
            uint64_t v31 = *(void *)(v27 + 8 * v25);
            if (v31) {
              BOOL v32 = v30 == 0;
            }
            else {
              BOOL v32 = 1;
            }
            if (!v32)
            {
              if ((*(unsigned char *)(v31 + 6) & 2) != 0) {
                int v33 = *(__int16 **)(v31 + 8);
              }
              else {
                int v33 = 0;
              }
              if (*(unsigned char *)(v31 + 36))
              {
                int v34 = *(_DWORD *)(v31 + 40);
                if (v34 <= 0) {
                  kd_multi_matrix_block::perform_transform();
                }
                int v35 = ((1 << (v34 - 14)) + v29) >> (v34 - 13);
                if (v34 < 0xE)
                {
                  char v36 = 13 - v34;
                }
                else
                {
                  LOWORD(v30) = v35;
                  char v36 = 0;
                }
                if ((int)v5 >= 1)
                {
                  uint64_t v37 = v5;
                  uint64_t v38 = v23;
                  do
                  {
                    int v39 = *v33++;
                    *v38++ += (v39 << v36) * (__int16)v30;
                    --v37;
                  }
                  while (v37);
                }
              }
              else if ((int)v5 >= 1)
              {
                uint64_t v40 = v5;
                int v41 = v23;
                do
                {
                  int v42 = *v33++;
                  *v41++ += v42 * v29;
                  --v40;
                }
                while (v40);
              }
            }
            ++v25;
            uint64_t v24 = *((int *)this + 6);
          }
          while (v25 < v24);
        }
        if ((int)v5 >= 1)
        {
          int v43 = *((_DWORD *)this + 24);
          unsigned int v44 = (vcvtmd_s64_f64((float)(*(float *)(v3 + 80 * v2 + 48) * 8192.0) + 0.5) << v43) + (1 << v43 >> 1);
          do
          {
            int v45 = *v23++;
            *v22++ = (int)(v44 + v45) >> v43;
            --v5;
          }
          while (v5);
        }
        goto LABEL_57;
      }
    }
    else
    {
      kd_multi_matrix_block::create_short_coefficients((uint64_t)this);
      if ((*((unsigned char *)v4 + 6) & 2) != 0) {
        goto LABEL_29;
      }
    }
    uint64_t v22 = 0;
    goto LABEL_32;
  }
}

uint64_t kd_multi_matrix_block::create_short_coefficients(uint64_t this)
{
  if (!*(void *)(this + 80))
  {
    uint64_t v1 = *(unsigned int *)(this + 12);
    uint64_t v2 = *(int *)(this + 24);
    if ((int)v1 >= 1)
    {
      uint64_t v3 = 0;
      uint64_t v4 = 0;
      float v5 = 0.00001;
      do
      {
        if ((int)v2 >= 1)
        {
          uint64_t v6 = *(void **)(this + 32);
          uint64_t v7 = *(unsigned int *)(this + 24);
          uint64_t v8 = v3;
          do
          {
            if (*v6)
            {
              float v9 = *(float *)(*(void *)(this + 64) + v8);
              if (v9 <= v5)
              {
                if (v9 < (float)-v5) {
                  float v5 = -v9;
                }
              }
              else
              {
                float v5 = *(float *)(*(void *)(this + 64) + v8);
              }
            }
            v8 += 4;
            ++v6;
            --v7;
          }
          while (v7);
        }
        ++v4;
        v3 += 4 * v2;
      }
      while (v4 != v1);
    }
    operator new[]();
  }
  return this;
}

const char *kd_multi_matrix_block::prepare_for_inversion(kd_multi_matrix_block *this)
{
  if (*((void *)this + 9)) {
    return 0;
  }
  int v2 = *((_DWORD *)this + 6);
  if (*((int *)this + 3) < 1)
  {
    int v3 = 0;
  }
  else
  {
    int v3 = 0;
    uint64_t v4 = (int *)(*((void *)this + 2) + 28);
    uint64_t v5 = *((unsigned int *)this + 3);
    do
    {
      int v6 = *v4;
      v4 += 20;
      if (v6 > 0) {
        ++v3;
      }
      --v5;
    }
    while (v5);
  }
  *((_DWORD *)this + 11) = v3;
  if (v3 < v2) {
    return "Encountered underdetermined system while trying to invert a multi-component transform block so as to convert "
  }
           "MCT output components into codestream components during compression.";
  if (v2 < 1) {
LABEL_17:
  }
    operator new[]();
  uint64_t v7 = *((void *)this + 4);
  uint64_t v1 = "Encountered an irreversible decorrelation transform block which operates on reversible codestream sample data.  W"
       "hile we allow such transforms to be processed during decompression, it is unreasonable to generate reversibly com"
       "pressed component samples using an irreversible inverse multi-component transform during compression.  Kakadu wil"
       "l not invert this transform during compression.  This can prevent the compression process from proceeding if ther"
       "e are no other paths back from the MCT output components to the codestream components.";
  uint64_t v8 = v2;
  while (!*(void *)v7 || !*(unsigned char *)(*(void *)v7 + 36))
  {
    v7 += 8;
    if (!--v8) {
      goto LABEL_17;
    }
  }
  return v1;
}

void kd_multi_matrix_block::perform_inverse(kd_multi_matrix_block *this)
{
  if (!*((void *)this + 9)) {
    kd_multi_matrix_block::perform_inverse();
  }
  if (*((int *)this + 6) >= 1)
  {
    for (uint64_t i = 0; i < *((int *)this + 6); ++i)
    {
      int v3 = *(unsigned int **)(*((void *)this + 4) + 8 * i);
      if (v3)
      {
        uint64_t v4 = *v3;
        if ((*((unsigned char *)v3 + 6) & 2) != 0 || (uint64_t v5 = (float *)*((void *)v3 + 1)) == 0)
        {
          if (*((void *)this + 10))
          {
            if ((*((unsigned char *)v3 + 6) & 2) != 0) {
              goto LABEL_24;
            }
LABEL_26:
            int v18 = 0;
          }
          else
          {
            kd_multi_matrix_block::create_short_inverse_coefficients((uint64_t)this);
            if ((*((unsigned char *)v3 + 6) & 2) == 0) {
              goto LABEL_26;
            }
LABEL_24:
            int v18 = (_WORD *)*((void *)v3 + 1);
          }
          uint64_t v19 = (int *)*((void *)this + 11);
          bzero(v19, 4 * (int)v4);
          int v20 = *((_DWORD *)this + 3);
          if (v20 >= 1)
          {
            uint64_t v21 = 0;
            uint64_t v22 = *((void *)this + 2);
            do
            {
              if (*(int *)(v22 + 80 * v21 + 28) >= 1)
              {
                uint64_t v23 = v22 + 80 * v21;
                uint64_t v24 = (*(unsigned char *)(v23 + 6) & 2) != 0 ? *(__int16 **)(v23 + 8) : 0;
                if ((int)v4 >= 1)
                {
                  int v25 = *(__int16 *)(*((void *)this + 10) + 2 * ((int)v21 + v20 * (int)i));
                  uint64_t v26 = v4;
                  uint64_t v27 = v19;
                  do
                  {
                    int v28 = *v24++;
                    *v27++ += v28 * v25;
                    --v26;
                  }
                  while (v26);
                  int v20 = *((_DWORD *)this + 3);
                }
              }
              ++v21;
            }
            while (v21 < v20);
          }
          if ((int)v4 >= 1)
          {
            int v29 = *((_DWORD *)this + 24);
            unsigned int v30 = (1 << v29 >> 1) - (vcvtmd_s64_f64((float)(*((float *)v3 + 12) * 8192.0) + 0.5) << v29);
            do
            {
              int v31 = *v19++;
              *v18++ = (int)(v30 + v31) >> v29;
              --v4;
            }
            while (v4);
          }
          continue;
        }
        if ((int)v4 >= 1)
        {
          float v6 = -*((float *)v3 + 12);
          uint64_t v7 = *v3;
          uint64_t v8 = (float *)*((void *)v3 + 1);
          do
          {
            *v8++ = v6;
            --v7;
          }
          while (v7);
        }
        int v9 = *((_DWORD *)this + 3);
        if (v9 >= 1)
        {
          for (uint64_t j = 0; j < v9; ++j)
          {
            uint64_t v11 = *((void *)this + 2);
            if (*(int *)(v11 + 80 * j + 28) >= 1)
            {
              uint64_t v12 = v11 + 80 * j;
              if ((*(unsigned char *)(v12 + 6) & 2) != 0) {
                float v13 = 0;
              }
              else {
                float v13 = *(float **)(v12 + 8);
              }
              if ((int)v4 >= 1)
              {
                float v14 = *(float *)(*((void *)this + 9) + 4 * ((int)j + v9 * (int)i));
                uint64_t v15 = v4;
                uint64_t v16 = v5;
                do
                {
                  float v17 = *v13++;
                  *uint64_t v16 = *v16 + (float)(v14 * v17);
                  ++v16;
                  --v15;
                }
                while (v15);
                int v9 = *((_DWORD *)this + 3);
              }
            }
          }
        }
      }
    }
  }
}

uint64_t kd_multi_matrix_block::create_short_inverse_coefficients(uint64_t this)
{
  if (!*(void *)(this + 80))
  {
    uint64_t v1 = *(unsigned int *)(this + 24);
    if ((int)v1 >= 1)
    {
      uint64_t v2 = 0;
      float v3 = 0.00001;
      do
      {
        if (*(void *)(*(void *)(this + 32) + 8 * v2))
        {
          uint64_t v4 = *(unsigned int *)(this + 12);
          if ((int)v4 >= 1)
          {
            uint64_t v5 = (float *)(*(void *)(this + 72) + 4 * (int)v4 * (int)v2);
            do
            {
              float v6 = *v5;
              if (*v5 <= v3)
              {
                if (v6 < (float)-v3) {
                  float v3 = -v6;
                }
              }
              else
              {
                float v3 = *v5;
              }
              ++v5;
              --v4;
            }
            while (v4);
          }
        }
        ++v2;
      }
      while (v2 != v1);
    }
    operator new[]();
  }
  return this;
}

void kd_multi_rxform_block::initialize(uint64_t a1, int a2, int a3, uint64_t *a4, int a5, int a6, _DWORD *a7, _DWORD *a8, kd_multi_transform *a9)
{
  uint64_t v19 = a4;
  int v17 = a6;
  int v18 = a5;
  if (a5 >= a6)
  {
    unint64_t scratch_ints = kd_multi_transform::get_scratch_ints(a9, 4 * a5);
    *(void *)uint64_t v16 = 0;
    kdu_tile::get_mct_block_info(&v19, a2, a3, &v16[1], v16, &v18, &v17, scratch_ints, (int *)(scratch_ints + 4 * a5), 0, (int *)(scratch_ints + 4 * a5 + 4 * a5), 0);
    if (*(void *)v16 == __PAIR64__(*a7, *a8))
    {
      *(_DWORD *)(a1 + 24) = a5;
      *(_DWORD *)(a1 + 12) = a5;
      is_mul_ok(a5, 0x50uLL);
      operator new[]();
    }
    kd_multi_rxform_block::initialize();
  }
  kd_multi_rxform_block::initialize();
}

const char *kd_multi_rxform_block::prepare_for_inversion(kd_multi_rxform_block *this)
{
  int v1 = *((_DWORD *)this + 3);
  if (v1 < 1)
  {
LABEL_5:
    float v3 = 0;
    *((_DWORD *)this + 11) = v1;
  }
  else
  {
    uint64_t v2 = (int *)(*((void *)this + 2) + 28);
    float v3 = "Reversible decorrelation transform block cannot be inverted unless all of its outputs can be computed by downst"
         "ream transform blocks, or by the application supplying them.";
    uint64_t v4 = *((unsigned int *)this + 3);
    while (1)
    {
      int v5 = *v2;
      v2 += 20;
      if (v5 < 1) {
        break;
      }
      if (!--v4) {
        goto LABEL_5;
      }
    }
  }
  return v3;
}

void kd_multi_rxform_block::perform_transform(kd_multi_rxform_block *this)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *((unsigned int *)this + 3);
  if (*((_DWORD *)this + 6) != v1) {
    kd_multi_rxform_block::perform_transform();
  }
  if ((int)v1 >= 1)
  {
    for (uint64_t i = 0; i != v1; ++i)
    {
      uint64_t v4 = (kd_multi_line *)(*((void *)this + 2) + 80 * i);
      int v5 = *(kd_multi_line **)(*((void *)this + 4) + 8 * i);
      if (v5) {
        kd_multi_line::copy((uint64_t)v4, v5, 0, 0.0);
      }
      else {
        kd_multi_line::reset(v4, 0, 0.0);
      }
    }
  }
  if ((v1 & 0x80000000) == 0)
  {
    uint64_t v6 = 0;
    uint64_t v7 = (int)v1 + 1;
    while (1)
    {
      if (v6 == v1) {
        int v8 = -1;
      }
      else {
        int v8 = ~v6;
      }
      uint64_t v9 = (v1 + v8);
      uint64_t v10 = (unsigned int *)(*((void *)this + 2) + 80 * (int)v9);
      int v40 = *v10;
      uint64_t v11 = *v10;
      if (!*((void *)this + 9)) {
        operator new[]();
      }
      int v12 = *(_DWORD *)(*((void *)this + 8) + 4 * (v6 + (int)v9 * (int)v7));
      if (v12 < 0 && v6 == v1) {
        int v14 = -v12;
      }
      else {
        int v14 = *(_DWORD *)(*((void *)this + 8) + 4 * (v6 + (int)v9 * (int)v7));
      }
      char v15 = -1;
      do
        ++v15;
      while (1 << v15 < v14);
      if (1 << v15 != v14)
      {
        uint64_t v42 = 0;
        memset(v41, 0, sizeof(v41));
        kdu_error::kdu_error((kdu_error *)v41, "Kakadu Core Error:\n");
        (*(void (**)(_OWORD *, const char *))(*(void *)&v41[0] + 16))(v41, "Multi-component reversible decorrelation transforms must have exact positive powers of 2 for the divisors which are used to scale and round the update terms.  The offending divisor is ");
        long long v46 = 0u;
        long long v47 = 0u;
        long long v44 = 0u;
        long long v45 = 0u;
        *(_OWORD *)int v43 = 0u;
        if (BYTE8(v41[0])) {
          sprintf(v43, "%x");
        }
        else {
          sprintf(v43, "%d");
        }
        (*(void (**)(_OWORD *, char *))(*(void *)&v41[0] + 16))(v41, v43);
        (*(void (**)(_OWORD *, const char *))(*(void *)&v41[0] + 16))(v41, ".");
        kdu_error::~kdu_error((kdu_error *)v41);
      }
      if ((int)v11 >= 1)
      {
        uint64_t v16 = (int *)*((void *)this + 9);
        uint64_t v17 = *v10;
        do
        {
          *v16++ = v14 >> 1;
          --v17;
        }
        while (v17);
      }
      char v18 = *((unsigned char *)v10 + 6);
      if ((v18 & 2) != 0 || !*((void *)v10 + 1))
      {
        if (v1)
        {
          for (uint64_t j = 0; j != v1; ++j)
          {
            if (j != v9)
            {
              int v29 = *(_DWORD *)(*((void *)this + 8) + 4 * (v6 + j * v7));
              if (v29)
              {
                uint64_t v30 = *((void *)this + 2) + 80 * j;
                int v31 = (*(unsigned char *)(v30 + 6) & 2) != 0 ? *(__int16 **)(v30 + 8) : 0;
                if ((int)v11 >= 1)
                {
                  BOOL v32 = (_DWORD *)*((void *)this + 9);
                  uint64_t v33 = v11;
                  do
                  {
                    int v34 = *v31++;
                    *v32++ += v29 * v34;
                    --v33;
                  }
                  while (v33);
                }
              }
            }
          }
        }
        if ((v18 & 2) != 0)
        {
          uint64_t v35 = *((void *)v10 + 1);
          if (v12 < 0)
          {
LABEL_67:
            if (v6 != v1) {
              kd_multi_rxform_block::perform_transform();
            }
            if ((int)v11 >= 1)
            {
              uint64_t v37 = 0;
              do
              {
                *(_WORD *)(v35 + 2 * v37) = (*(int *)(*((void *)this + 9) + 4 * v37) >> v15)
                                          - *(_WORD *)(v35 + 2 * v37);
                ++v37;
              }
              while (v40 != v37);
            }
            goto LABEL_76;
          }
        }
        else
        {
          uint64_t v35 = 0;
          if (v12 < 0) {
            goto LABEL_67;
          }
        }
        if ((int)v11 >= 1)
        {
          for (uint64_t k = 0; k != v11; ++k)
            *(_WORD *)(v35 + 2 * k) -= *(int *)(*((void *)this + 9) + 4 * k) >> v15;
        }
      }
      else
      {
        if (v1)
        {
          for (uint64_t m = 0; m != v1; ++m)
          {
            if (m != v9)
            {
              int v20 = *(_DWORD *)(*((void *)this + 8) + 4 * (v6 + m * v7));
              if (v20)
              {
                uint64_t v21 = *((void *)this + 2) + 80 * m;
                uint64_t v22 = (*(unsigned char *)(v21 + 6) & 2) != 0 ? 0 : *(int **)(v21 + 8);
                if ((int)v11 >= 1)
                {
                  uint64_t v23 = (_DWORD *)*((void *)this + 9);
                  uint64_t v24 = v11;
                  do
                  {
                    int v25 = *v22++;
                    *v23++ += v25 * v20;
                    --v24;
                  }
                  while (v24);
                }
              }
            }
          }
        }
        uint64_t v26 = *((void *)v10 + 1);
        if (v12 < 0)
        {
          if (v6 != v1) {
            kd_multi_rxform_block::perform_transform();
          }
          if ((int)v11 >= 1)
          {
            uint64_t v38 = 0;
            do
            {
              *(_DWORD *)(v26 + v38) = (*(int *)(*((void *)this + 9) + v38) >> v15) - *(_DWORD *)(v26 + v38);
              v38 += 4;
            }
            while (4 * v11 != v38);
          }
        }
        else if ((int)v11 >= 1)
        {
          uint64_t v27 = 0;
          do
          {
            *(_DWORD *)(v26 + v27) -= *(int *)(*((void *)this + 9) + v27) >> v15;
            v27 += 4;
          }
          while (4 * v11 != v27);
        }
      }
LABEL_76:
      if (++v6 == v1 + 1)
      {
        if ((int)v1 >= 1)
        {
          uint64_t v39 = 0;
          do
          {
            kd_multi_line::apply_offset(*((void *)this + 2) + v39, *(_DWORD *)(*((void *)this + 2) + v39 + 44), 0.0);
            v39 += 80;
          }
          while (80 * v1 != v39);
        }
        return;
      }
    }
  }
}

void sub_1886D3A98(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886D3AA4()
{
  _Unwind_Resume(v0);
}

uint64_t kd_multi_rxform_block::perform_inverse(uint64_t this)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(unsigned int *)(this + 12);
  if ((v1 & 0x80000000) != 0) {
    return this;
  }
  uint64_t v2 = this;
  uint64_t v3 = v1 + 1;
  uint64_t v4 = *(unsigned int *)(this + 12);
  do
  {
    uint64_t v5 = (v1 + ~((int)v4 % (int)v1));
    uint64_t v6 = (unsigned int *)(*(void *)(this + 16) + 80 * (int)v5);
    int v37 = *v6;
    uint64_t v7 = *v6;
    if (!*(void *)(this + 72)) {
      operator new[]();
    }
    int v8 = *(_DWORD *)(*(void *)(this + 64) + 4 * (v4 + (int)v5 * (int)v3));
    if (v8 < 0 && v4 == v1) {
      int v10 = -v8;
    }
    else {
      int v10 = *(_DWORD *)(*(void *)(this + 64) + 4 * (v4 + (int)v5 * (int)v3));
    }
    char v11 = -1;
    do
      ++v11;
    while (1 << v11 < v10);
    if (1 << v11 != v10)
    {
      uint64_t v39 = 0;
      memset(v38, 0, sizeof(v38));
      kdu_error::kdu_error((kdu_error *)v38, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v38[0] + 16))(v38, "Multi-component reversible decorrelation transforms must have exact positive powers of 2 for the divisors which are used to scale and round the update terms.  The offending divisor is ");
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      *(_OWORD *)int v40 = 0u;
      if (BYTE8(v38[0])) {
        sprintf(v40, "%x");
      }
      else {
        sprintf(v40, "%d");
      }
      (*(void (**)(_OWORD *, char *))(*(void *)&v38[0] + 16))(v38, v40);
      (*(void (**)(_OWORD *, const char *))(*(void *)&v38[0] + 16))(v38, ".");
      kdu_error::~kdu_error((kdu_error *)v38);
    }
    if ((int)v7 >= 1)
    {
      int v12 = *(int **)(this + 72);
      uint64_t v13 = *v6;
      do
      {
        *v12++ = v10 >> 1;
        --v13;
      }
      while (v13);
    }
    char v14 = *((unsigned char *)v6 + 6);
    if ((v14 & 2) == 0 && *((void *)v6 + 1))
    {
      if (v1)
      {
        for (uint64_t i = 0; i != v1; ++i)
        {
          if (i != v5)
          {
            int v16 = *(_DWORD *)(*(void *)(this + 64) + 4 * (v4 + i * v3));
            if (v16)
            {
              uint64_t v17 = *(void *)(this + 16) + 80 * i;
              char v18 = (*(unsigned char *)(v17 + 6) & 2) != 0 ? 0 : *(int **)(v17 + 8);
              if ((int)v7 >= 1)
              {
                uint64_t v19 = *(_DWORD **)(this + 72);
                uint64_t v20 = v7;
                do
                {
                  int v21 = *v18++;
                  *v19++ += v21 * v16;
                  --v20;
                }
                while (v20);
              }
            }
          }
        }
      }
      uint64_t v22 = *((void *)v6 + 1);
      if (v8 < 0)
      {
        if (v4 != v1) {
          kd_multi_rxform_block::perform_inverse();
        }
        if ((int)v7 >= 1)
        {
          uint64_t v34 = 0;
          do
          {
            *(_DWORD *)(v22 + v34) = (*(int *)(*(void *)(this + 72) + v34) >> v11) - *(_DWORD *)(v22 + v34);
            v34 += 4;
          }
          while (4 * v7 != v34);
        }
      }
      else if ((int)v7 >= 1)
      {
        uint64_t v23 = 0;
        do
        {
          *(_DWORD *)(v22 + v23) += *(int *)(*(void *)(this + 72) + v23) >> v11;
          v23 += 4;
        }
        while (4 * v7 != v23);
      }
      continue;
    }
    if (v1)
    {
      for (uint64_t j = 0; j != v1; ++j)
      {
        if (j != v5)
        {
          int v25 = *(_DWORD *)(*(void *)(this + 64) + 4 * (v4 + j * v3));
          if (v25)
          {
            uint64_t v26 = *(void *)(this + 16) + 80 * j;
            uint64_t v27 = (*(unsigned char *)(v26 + 6) & 2) != 0 ? *(__int16 **)(v26 + 8) : 0;
            if ((int)v7 >= 1)
            {
              int v28 = *(_DWORD **)(this + 72);
              uint64_t v29 = v7;
              do
              {
                int v30 = *v27++;
                *v28++ += v25 * v30;
                --v29;
              }
              while (v29);
            }
          }
        }
      }
    }
    if ((v14 & 2) != 0)
    {
      uint64_t v31 = *((void *)v6 + 1);
      if ((v8 & 0x80000000) == 0)
      {
LABEL_52:
        if ((int)v7 >= 1)
        {
          for (uint64_t k = 0; k != v7; ++k)
            *(_WORD *)(v31 + 2 * k) += *(int *)(*(void *)(this + 72) + 4 * k) >> v11;
        }
        continue;
      }
    }
    else
    {
      uint64_t v31 = 0;
      if ((v8 & 0x80000000) == 0) {
        goto LABEL_52;
      }
    }
    if (v4 != v1) {
      kd_multi_rxform_block::perform_inverse();
    }
    if ((int)v7 >= 1)
    {
      uint64_t v33 = 0;
      do
      {
        *(_WORD *)(v31 + 2 * v33) = (*(int *)(*(void *)(this + 72) + 4 * v33) >> v11) - *(_WORD *)(v31 + 2 * v33);
        ++v33;
      }
      while (v37 != v33);
    }
  }
  while (v4-- > 0);
  if ((int)v1 >= 1)
  {
    for (uint64_t m = 0; m != v1; ++m)
    {
      this = *(void *)(*(void *)(v2 + 32) + 8 * m);
      if (this) {
        this = kd_multi_line::copy(this, (kd_multi_line *)(*(void *)(v2 + 16) + 80 * m), -*(_DWORD *)(this + 44), 0.0);
      }
    }
  }
  return this;
}

void sub_1886D3F60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886D3F6C()
{
  _Unwind_Resume(v0);
}

void kd_multi_dependency_block::initialize(uint64_t a1, int a2, int a3, uint64_t *a4, int a5, int a6, _DWORD *a7, _DWORD *a8, kd_multi_transform *a9)
{
  uint64_t v19 = a4;
  int v17 = a6;
  int v18 = a5;
  if (a5 >= a6)
  {
    uint64_t v16 = 0;
    unint64_t scratch_ints = kd_multi_transform::get_scratch_ints(a9, 3 * a5);
    kdu_tile::get_mct_block_info(&v19, a2, a3, (int *)&v16 + 1, (int *)&v16, &v18, &v17, scratch_ints, (int *)(scratch_ints + 4 * a5), 0, 0, 0);
    if (v16 == __PAIR64__(*a7, *a8))
    {
      *(_DWORD *)(a1 + 24) = a5;
      *(_DWORD *)(a1 + 12) = a5;
      is_mul_ok(a5, 0x50uLL);
      operator new[]();
    }
    kd_multi_dependency_block::initialize();
  }
  kd_multi_dependency_block::initialize();
}

const char *kd_multi_dependency_block::prepare_for_inversion(kd_multi_dependency_block *this)
{
  int v1 = *((_DWORD *)this + 3);
  if (v1 < 1)
  {
LABEL_5:
    uint64_t v6 = *((unsigned int *)this + 6);
    if ((int)v6 < 1)
    {
LABEL_11:
      uint64_t v3 = 0;
      *((_DWORD *)this + 11) = v1;
    }
    else
    {
      uint64_t v7 = 0;
      uint64_t v8 = 8 * v6;
      uint64_t v3 = "Encountered an irreversible dependency transform block which operates on reversible codestream sample data.  "
           "While we allow such transforms to be processed during decompression, it is unreasonable to generate reversibl"
           "y compressed component samples using an irreversible inverse multi-component transform during compression.  K"
           "akadu will not invert this transform during compression.  This can prevent the compression process from proce"
           "eding if there are no other paths back from the MCT output components to the codestream components.";
      while (1)
      {
        if (!*((unsigned char *)this + 64))
        {
          uint64_t v9 = *(void *)(*((void *)this + 4) + v7);
          if (v9)
          {
            if (*(unsigned char *)(v9 + 36)) {
              break;
            }
          }
        }
        v7 += 8;
        if (v8 == v7) {
          goto LABEL_11;
        }
      }
    }
  }
  else
  {
    uint64_t v2 = (int *)(*((void *)this + 2) + 28);
    uint64_t v3 = "Dependency transform block cannot be inverted or partially inverted unless a contiguous prefix of the output co"
         "mponents can be computed by downstream transform blocks, or by the application supplying them.";
    uint64_t v4 = *((unsigned int *)this + 3);
    while (1)
    {
      int v5 = *v2;
      v2 += 20;
      if (v5 < 1) {
        break;
      }
      if (!--v4) {
        goto LABEL_5;
      }
    }
  }
  return v3;
}

uint64_t kd_multi_dependency_block::normalize_coefficients(uint64_t this)
{
  if (*(unsigned char *)(this + 64)) {
    return this;
  }
  uint64_t v1 = *(unsigned int *)(this + 12);
  if (v1 != *(_DWORD *)(this + 24)) {
    kd_multi_dependency_block::normalize_coefficients();
  }
  if ((int)v1 < 1) {
    return this;
  }
  uint64_t v2 = 0;
  int v3 = 0;
  uint64_t v4 = *(void *)(this + 32);
  uint64_t v5 = *(void *)(this + 16);
  uint64_t v6 = 4 * v1;
  uint64_t v7 = *(unsigned int *)(this + 12);
  for (uint64_t i = 1; ; ++i)
  {
    uint64_t v9 = *(void *)(v4 + 8 * v2);
    uint64_t v10 = v5 + 80 * v2;
    int v13 = *(_DWORD *)(v10 + 40);
    int v12 = (int *)(v10 + 40);
    int v11 = v13;
    if (v13) {
      break;
    }
    if (v9)
    {
      int v11 = *(_DWORD *)(v9 + 40);
      int *v12 = v11;
      int v3 = 1;
      goto LABEL_11;
    }
    if (++v2 == v1) {
      goto LABEL_24;
    }
    int v3 = 1;
LABEL_20:
    v7 += v1;
  }
  if (v9) {
    v3 |= *(_DWORD *)(v9 + 40) == 0;
  }
LABEL_11:
  BOOL v14 = *(unsigned char *)(v5 + 80 * v2 + 38) != 0;
  if (v11 >= 1)
  {
    float v15 = (float)(1 << v11);
    if (v2 < v1 - 1)
    {
      uint64_t v16 = (float *)(*(void *)(this + 88) + 4 * (v2 + v7));
      uint64_t v17 = v1;
      do
      {
        *uint64_t v16 = *v16 * v15;
        uint64_t v16 = (float *)((char *)v16 + v6);
        --v17;
      }
      while (i != v17);
    }
    float v18 = 1.0 / v15;
    if (v2)
    {
      uint64_t v19 = (float *)(*(void *)(this + 88) + v6 * v2);
      uint64_t v20 = v2;
      do
      {
        *uint64_t v19 = v18 * *v19;
        ++v19;
        --v20;
      }
      while (v20);
    }
    *(float *)(*(void *)(this + 96) + 4 * v2) = v18
                                                                * *(float *)(*(void *)(this + 96)
                                                                           + 4 * v2);
  }
  v3 |= v14;
  if (++v2 != v1) {
    goto LABEL_20;
  }
  if ((v3 & 1) == 0) {
    return this;
  }
LABEL_24:
  int v21 = (unsigned char *)(v5 + 38);
  do
  {
    *int v21 = 1;
    if (*(void *)v4) {
      *(unsigned char *)(*(void *)v4 + 38) = 1;
    }
    v4 += 8;
    v21 += 80;
    --v1;
  }
  while (v1);
  return this;
}

uint64_t kd_multi_dependency_block::create_short_matrix(uint64_t this)
{
  if (!*(void *)(this + 104) && !*(unsigned char *)(this + 64))
  {
    uint64_t v1 = *(unsigned int *)(this + 12);
    if (v1 == *(_DWORD *)(this + 24))
    {
      if ((int)v1 >= 1)
      {
        uint64_t v2 = 0;
        uint64_t v3 = 0;
        float v4 = 0.0;
        do
        {
          if (v3)
          {
            for (uint64_t i = 0; i != v3; ++i)
            {
              uint64_t v6 = *(void *)(this + 88) + v2;
              float v7 = *(float *)(v6 + 4 * i);
              if (v7 <= v4)
              {
                if (v7 < (float)-v4) {
                  float v4 = -v7;
                }
              }
              else
              {
                float v4 = *(float *)(v6 + 4 * i);
              }
            }
          }
          ++v3;
          v2 += 4 * v1;
        }
        while (v3 != v1);
      }
      operator new[]();
    }
    kd_multi_dependency_block::create_short_matrix();
  }
  return this;
}

uint64_t kd_multi_dependency_block::perform_transform(uint64_t this)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  int v1 = *(_DWORD *)(this + 12);
  if (*(_DWORD *)(this + 24) != v1) {
    kd_multi_dependency_block::perform_transform();
  }
  if (v1 >= 1)
  {
    uint64_t v2 = this;
    uint64_t v3 = 0;
    uint64_t v70 = *(unsigned int *)(this + 12);
    while (1)
    {
      if (v3 <= 1) {
        uint64_t v4 = 1;
      }
      else {
        uint64_t v4 = v3;
      }
      uint64_t v5 = (kd_multi_line *)(*(void *)(v2 + 16) + 80 * v3);
      uint64_t v6 = *(kd_multi_line **)(*(void *)(v2 + 32) + 8 * v3);
      int v7 = *(_DWORD *)v5;
      uint64_t v8 = *(unsigned int *)v5;
      if (!*(unsigned char *)(v2 + 64))
      {
        float v10 = *(float *)(*(void *)(v2 + 96) + 4 * v3);
        uint64_t v11 = *(void *)(v2 + 16) + 80 * v3;
        if (v6) {
          kd_multi_line::copy((uint64_t)v5, v6, 0, v10);
        }
        else {
          kd_multi_line::reset(v5, 0, v10);
        }
        uint64_t v12 = v70;
        if (v3)
        {
          if ((*(unsigned char *)(v11 + 6) & 2) != 0 || (long long v42 = *(float **)(v11 + 8)) == 0)
          {
            if (!*(void *)(v2 + 120)) {
              operator new[]();
            }
            if (!*(void *)(v2 + 104))
            {
              kd_multi_dependency_block::create_short_matrix(v2);
              uint64_t v12 = v70;
            }
            if ((*(unsigned char *)(v11 + 6) & 2) != 0) {
              uint64_t v51 = *(void *)(v11 + 8);
            }
            else {
              uint64_t v51 = 0;
            }
            int v52 = *(_DWORD *)(v2 + 112);
            if ((int)v8 >= 1)
            {
              int v53 = *(int **)(v2 + 120);
              uint64_t v54 = v8;
              do
              {
                *v53++ = 1 << v52 >> 1;
                --v54;
              }
              while (v54);
            }
            uint64_t v55 = 0;
            uint64_t v56 = *(void *)(v2 + 16);
            uint64_t v57 = *(void *)(v2 + 104);
            uint64_t v58 = v3 * v12;
            do
            {
              uint64_t v59 = v56 + 80 * v55;
              if ((*(unsigned char *)(v59 + 6) & 2) != 0) {
                int v60 = *(__int16 **)(v59 + 8);
              }
              else {
                int v60 = 0;
              }
              int v61 = *(__int16 *)(v57 + 2 * (v55 + v58));
              if (*(_WORD *)(v57 + 2 * (v55 + v58))) {
                BOOL v62 = v7 < 1;
              }
              else {
                BOOL v62 = 1;
              }
              if (!v62)
              {
                int v63 = *(_DWORD **)(v2 + 120);
                uint64_t v64 = v7;
                do
                {
                  int v65 = *v60++;
                  *v63++ += v65 * v61;
                  --v64;
                }
                while (v64);
              }
              ++v55;
            }
            while (v55 != v4);
            if ((int)v8 >= 1)
            {
              uint64_t v66 = 0;
              do
              {
                *(_WORD *)(v51 + 2 * v66) += *(int *)(*(void *)(v2 + 120) + 4 * v66) >> v52;
                ++v66;
              }
              while (v7 != v66);
            }
          }
          else
          {
            for (uint64_t i = 0; i != v3; ++i)
            {
              uint64_t v44 = *(void *)(v2 + 16) + 80 * i;
              if ((*(unsigned char *)(v44 + 6) & 2) != 0) {
                uint64_t v45 = 0;
              }
              else {
                uint64_t v45 = *(float **)(v44 + 8);
              }
              float v46 = *(float *)(*(void *)(v2 + 88) + 4 * (i + v3 * v70));
              if (v46 != 0.0 && (int)v8 >= 1)
              {
                uint64_t v48 = v8;
                uint64_t v49 = v42;
                do
                {
                  float v50 = *v45++;
                  float *v49 = *v49 + (float)(v50 * v46);
                  ++v49;
                  --v48;
                }
                while (v48);
              }
            }
          }
        }
        goto LABEL_99;
      }
      int v9 = *(_DWORD *)(*(void *)(v2 + 80) + 4 * v3);
      uint64_t v69 = *(void *)(v2 + 16) + 80 * v3;
      if (v6) {
        kd_multi_line::copy((uint64_t)v5, v6, v9, 0.0);
      }
      else {
        kd_multi_line::reset(v5, v9, 0.0);
      }
      uint64_t v12 = v70;
      if (v3)
      {
        uint64_t v13 = v3 * v70;
        int v14 = *(_DWORD *)(*(void *)(v2 + 72) + 4 * (v3 + (int)v70 * (int)v3));
        char v15 = -1;
        do
          int v16 = 1 << ++v15;
        while (1 << v15 < v14);
        if (v16 != v14)
        {
          uint64_t v72 = 0;
          memset(v71, 0, sizeof(v71));
          kdu_error::kdu_error((kdu_error *)v71, "Kakadu Core Error:\n");
          (*(void (**)(_OWORD *, const char *))(*(void *)&v71[0] + 16))(v71, "Multi-component reversible dependency transforms must have exact positive powers of 2 on the diagonal of their triangular coefficient matrix; these are the divisors used to scale and round the prediction terms.  The "
            "offending divisor is ");
          long long v76 = 0u;
          long long v77 = 0u;
          long long v74 = 0u;
          long long v75 = 0u;
          *(_OWORD *)int v73 = 0u;
          if (BYTE8(v71[0])) {
            sprintf(v73, "%x");
          }
          else {
            sprintf(v73, "%d");
          }
          (*(void (**)(_OWORD *, char *))(*(void *)&v71[0] + 16))(v71, v73);
          (*(void (**)(_OWORD *, const char *))(*(void *)&v71[0] + 16))(v71, ".");
          kdu_error::~kdu_error((kdu_error *)v71);
        }
        uint64_t v17 = *(_DWORD **)(v2 + 120);
        if (!v17) {
          operator new[]();
        }
        if ((int)v8 >= 1)
        {
          uint64_t v18 = v8;
          uint64_t v19 = *(int **)(v2 + 120);
          do
          {
            *v19++ = v16 >> 1;
            --v18;
          }
          while (v18);
        }
        uint64_t v12 = v70;
        uint64_t v20 = *(void *)(v69 + 8);
        if ((*(unsigned char *)(v69 + 6) & 2) != 0)
        {
          uint64_t v21 = *(void *)(v2 + 72);
LABEL_44:
          uint64_t v32 = 0;
          uint64_t v33 = *(void *)(v2 + 16);
          do
          {
            uint64_t v34 = v33 + 80 * v32;
            if ((*(unsigned char *)(v34 + 6) & 2) != 0) {
              uint64_t v35 = *(__int16 **)(v34 + 8);
            }
            else {
              uint64_t v35 = 0;
            }
            int v36 = *(_DWORD *)(v21 + 4 * (v32 + v13));
            if (v36) {
              BOOL v37 = (int)v8 < 1;
            }
            else {
              BOOL v37 = 1;
            }
            if (!v37)
            {
              uint64_t v38 = v8;
              uint64_t v39 = v17;
              do
              {
                int v40 = *v35++;
                *v39++ += v36 * v40;
                --v38;
              }
              while (v38);
            }
            ++v32;
          }
          while (v32 != v4);
          if ((int)v8 >= 1)
          {
            for (uint64_t j = 0; j != v8; ++j)
              *(_WORD *)(v20 + 2 * j) += *(int *)(*(void *)(v2 + 120) + 4 * j) >> v15;
          }
          goto LABEL_99;
        }
        uint64_t v21 = *(void *)(v2 + 72);
        if (!v20) {
          goto LABEL_44;
        }
        uint64_t v22 = 0;
        uint64_t v23 = *(void *)(v2 + 16);
        do
        {
          uint64_t v24 = v23 + 80 * v22;
          if ((*(unsigned char *)(v24 + 6) & 2) != 0) {
            int v25 = 0;
          }
          else {
            int v25 = *(int **)(v24 + 8);
          }
          int v26 = *(_DWORD *)(v21 + 4 * (v22 + v13));
          if (v26) {
            BOOL v27 = (int)v8 < 1;
          }
          else {
            BOOL v27 = 1;
          }
          if (!v27)
          {
            uint64_t v28 = v8;
            uint64_t v29 = v17;
            do
            {
              int v30 = *v25++;
              *v29++ += v30 * v26;
              --v28;
            }
            while (v28);
          }
          ++v22;
        }
        while (v22 != v4);
        if ((int)v8 >= 1)
        {
          uint64_t v31 = 0;
          do
          {
            *(_DWORD *)(v20 + v31) += *(int *)(*(void *)(v2 + 120) + v31) >> v15;
            v31 += 4;
          }
          while (4 * v8 != v31);
        }
      }
LABEL_99:
      if (++v3 == v12)
      {
        uint64_t v67 = 0;
        uint64_t v68 = 80 * v12;
        do
        {
          this = kd_multi_line::apply_offset(*(void *)(v2 + 16) + v67, *(_DWORD *)(*(void *)(v2 + 16) + v67 + 44), *(float *)(*(void *)(v2 + 16) + v67 + 48));
          v67 += 80;
        }
        while (v68 != v67);
        return this;
      }
    }
  }
  return this;
}

void sub_1886D4E20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886D4E2C()
{
  _Unwind_Resume(v0);
}

_DWORD *kd_multi_dependency_block::perform_inverse(_DWORD *this)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = this[3];
  if (this[6] != v1) {
    kd_multi_dependency_block::perform_inverse();
  }
  if ((int)v1 >= 1)
  {
    uint64_t v2 = (uint64_t)this;
    uint64_t v3 = 0;
    uint64_t v64 = this[3];
    do
    {
      if (v3 <= 1) {
        uint64_t v4 = 1;
      }
      else {
        uint64_t v4 = v3;
      }
      uint64_t v5 = *(void *)(v2 + 16);
      uint64_t v6 = (int *)(v5 + 80 * v3);
      uint64_t v7 = *(void *)(*(void *)(v2 + 32) + 8 * v3);
      int v8 = *v6;
      uint64_t v9 = *v6;
      if (*(unsigned char *)(v2 + 64))
      {
        if (!v3) {
          goto LABEL_72;
        }
        int v63 = (int *)(v5 + 80 * v3);
        uint64_t v10 = v3 * v1;
        int v11 = *(_DWORD *)(*(void *)(v2 + 72) + 4 * (v3 + (int)v1 * (int)v3));
        char v12 = -1;
        do
          int v13 = 1 << ++v12;
        while (1 << v12 < v11);
        if (v13 != v11)
        {
          uint64_t v66 = 0;
          memset(v65, 0, sizeof(v65));
          kdu_error::kdu_error((kdu_error *)v65, "Kakadu Core Error:\n");
          (*(void (**)(_OWORD *, const char *))(*(void *)&v65[0] + 16))(v65, "Multi-component reversible dependency transforms must have exact positive powers of 2 on the diagonal of their triangular coefficient matrix; these are the divisors used to scale and round the prediction terms.  The "
            "offending divisor is ");
          long long v70 = 0u;
          long long v71 = 0u;
          long long v68 = 0u;
          long long v69 = 0u;
          *(_OWORD *)uint64_t v67 = 0u;
          if (BYTE8(v65[0])) {
            sprintf(v67, "%x");
          }
          else {
            sprintf(v67, "%d");
          }
          (*(void (**)(_OWORD *, char *))(*(void *)&v65[0] + 16))(v65, v67);
          (*(void (**)(_OWORD *, const char *))(*(void *)&v65[0] + 16))(v65, ".");
          kdu_error::~kdu_error((kdu_error *)v65);
        }
        this = *(_DWORD **)(v2 + 120);
        if (!this) {
          operator new[]();
        }
        if ((int)v9 >= 1)
        {
          uint64_t v14 = *v6;
          char v15 = *(int **)(v2 + 120);
          do
          {
            *v15++ = v13 >> 1;
            --v14;
          }
          while (v14);
        }
        uint64_t v6 = v63;
        uint64_t v16 = *((void *)v63 + 1);
        if ((*((unsigned char *)v63 + 6) & 2) != 0)
        {
          uint64_t v17 = *(void *)(v2 + 16);
          uint64_t v18 = *(void *)(v2 + 72);
          uint64_t v1 = v64;
        }
        else
        {
          uint64_t v17 = *(void *)(v2 + 16);
          uint64_t v18 = *(void *)(v2 + 72);
          uint64_t v1 = v64;
          if (v16)
          {
            for (uint64_t i = 0; i != v4; ++i)
            {
              uint64_t v20 = v17 + 80 * i;
              if ((*(unsigned char *)(v20 + 6) & 2) != 0) {
                uint64_t v21 = 0;
              }
              else {
                uint64_t v21 = *(int **)(v20 + 8);
              }
              int v22 = *(_DWORD *)(v18 + 4 * (i + v10));
              if (v22) {
                BOOL v23 = (int)v9 < 1;
              }
              else {
                BOOL v23 = 1;
              }
              if (!v23)
              {
                uint64_t v24 = v9;
                int v25 = this;
                do
                {
                  int v26 = *v21++;
                  *v25++ += v26 * v22;
                  --v24;
                }
                while (v24);
              }
            }
            if ((int)v9 >= 1)
            {
              uint64_t v27 = 0;
              do
              {
                *(_DWORD *)(v16 + v27) -= *(int *)(*(void *)(v2 + 120) + v27) >> v12;
                v27 += 4;
              }
              while (4 * v9 != v27);
            }
            goto LABEL_72;
          }
        }
        for (uint64_t j = 0; j != v4; ++j)
        {
          uint64_t v39 = v17 + 80 * j;
          if ((*(unsigned char *)(v39 + 6) & 2) != 0) {
            int v40 = *(__int16 **)(v39 + 8);
          }
          else {
            int v40 = 0;
          }
          int v41 = *(_DWORD *)(v18 + 4 * (j + v10));
          if (v41) {
            BOOL v42 = (int)v9 < 1;
          }
          else {
            BOOL v42 = 1;
          }
          if (!v42)
          {
            uint64_t v43 = v9;
            uint64_t v44 = this;
            do
            {
              int v45 = *v40++;
              *v44++ += v41 * v45;
              --v43;
            }
            while (v43);
          }
        }
        if ((int)v9 >= 1)
        {
          for (uint64_t k = 0; k != v9; ++k)
            *(_WORD *)(v16 + 2 * k) -= *(int *)(*(void *)(v2 + 120) + 4 * k) >> v12;
        }
LABEL_72:
        if (v7)
        {
          this = (_DWORD *)kd_multi_line::copy(v7, (kd_multi_line *)v6, -*(_DWORD *)(v7 + 44) - *(_DWORD *)(*(void *)(v2 + 80) + 4 * v3), 0.0);
LABEL_99:
          uint64_t v1 = v64;
          goto LABEL_100;
        }
        goto LABEL_100;
      }
      if ((*((unsigned char *)v6 + 6) & 2) == 0)
      {
        uint64_t v28 = (float *)*((void *)v6 + 1);
        if (v28)
        {
          if (v3)
          {
            for (uint64_t m = 0; m != v3; ++m)
            {
              uint64_t v30 = *(void *)(v2 + 16) + 80 * m;
              if ((*(unsigned char *)(v30 + 6) & 2) != 0) {
                uint64_t v31 = 0;
              }
              else {
                uint64_t v31 = *(float **)(v30 + 8);
              }
              float v32 = *(float *)(*(void *)(v2 + 88) + 4 * (m + v3 * v1));
              if (v32 != 0.0 && (int)v9 >= 1)
              {
                uint64_t v34 = v9;
                uint64_t v35 = v28;
                do
                {
                  float v36 = *v31++;
                  *uint64_t v35 = *v35 - (float)(v36 * v32);
                  ++v35;
                  --v34;
                }
                while (v34);
              }
            }
          }
          goto LABEL_95;
        }
      }
      if (!v3) {
        goto LABEL_95;
      }
      if (*(void *)(v2 + 104))
      {
        if ((*((unsigned char *)v6 + 6) & 2) == 0) {
          goto LABEL_75;
        }
      }
      else
      {
        uint64_t v47 = *(void *)(*(void *)(v2 + 32) + 8 * v3);
        kd_multi_dependency_block::create_short_matrix(v2);
        uint64_t v6 = (int *)(v5 + 80 * v3);
        uint64_t v1 = v64;
        uint64_t v7 = v47;
        if ((*((unsigned char *)v6 + 6) & 2) == 0)
        {
LABEL_75:
          uint64_t v37 = 0;
          goto LABEL_76;
        }
      }
      uint64_t v37 = *((void *)v6 + 1);
LABEL_76:
      int v48 = *(_DWORD *)(v2 + 112);
      this = *(_DWORD **)(v2 + 120);
      if (!this) {
        operator new[]();
      }
      if ((int)v9 >= 1)
      {
        uint64_t v49 = v9;
        float v50 = *(int **)(v2 + 120);
        do
        {
          *v50++ = 1 << v48 >> 1;
          --v49;
        }
        while (v49);
      }
      uint64_t v51 = 0;
      uint64_t v52 = *(void *)(v2 + 16);
      uint64_t v53 = *(void *)(v2 + 104);
      uint64_t v54 = v3 * v1;
      do
      {
        uint64_t v55 = v52 + 80 * v51;
        if ((*(unsigned char *)(v55 + 6) & 2) != 0) {
          uint64_t v56 = *(__int16 **)(v55 + 8);
        }
        else {
          uint64_t v56 = 0;
        }
        int v57 = *(__int16 *)(v53 + 2 * (v51 + v54));
        if (*(_WORD *)(v53 + 2 * (v51 + v54))) {
          BOOL v58 = v8 < 1;
        }
        else {
          BOOL v58 = 1;
        }
        if (!v58)
        {
          uint64_t v59 = v8;
          int v60 = this;
          do
          {
            int v61 = *v56++;
            *v60++ += v61 * v57;
            --v59;
          }
          while (v59);
        }
        ++v51;
      }
      while (v51 != v4);
      if ((int)v9 >= 1)
      {
        uint64_t v62 = 0;
        do
        {
          *(_WORD *)(v37 + 2 * v62) -= *(int *)(*(void *)(v2 + 120) + 4 * v62) >> v48;
          ++v62;
        }
        while (v8 != v62);
      }
LABEL_95:
      if (v7)
      {
        if (*(unsigned char *)(v7 + 36) || *(unsigned char *)(v5 + 80 * v3 + 36)) {
          kd_multi_dependency_block::perform_inverse();
        }
        this = (_DWORD *)kd_multi_line::copy(v7, (kd_multi_line *)v6, 0, -(float)(*(float *)(v7 + 48)- (float)((float)((float)-(float)(1 << *(_DWORD *)(v5 + 80 * v3 + 40))/ (float)(1 << *(_DWORD *)(v7 + 40)))* *(float *)(*(void *)(v2 + 96) + 4 * v3))));
        goto LABEL_99;
      }
LABEL_100:
      ++v3;
    }
    while (v3 != v1);
  }
  return this;
}

void sub_1886D5440(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886D544C()
{
  _Unwind_Resume(v0);
}

void kd_multi_dwt_block::initialize(uint64_t a1, int a2, int a3, uint64_t *a4, int a5, int a6, _DWORD *a7, _DWORD *a8, kd_multi_transform *a9)
{
  v27[0] = a4;
  int v25 = a6;
  int v26 = a5;
  unint64_t scratch_ints = kd_multi_transform::get_scratch_ints(a9, 3 * a6 + 2 * a5);
  uint64_t v19 = (int *)(scratch_ints + 4 * a5);
  uint64_t v16 = &v19[a5];
  uint64_t v17 = &v16[a6];
  *(void *)uint64_t v24 = 0;
  unint64_t scratch_floats = kd_multi_transform::get_scratch_floats(a9, a6);
  kdu_tile::get_mct_block_info(v27, a2, a3, &v24[1], v24, &v26, &v25, scratch_ints, v16, scratch_floats, &v17[a6], 0);
  if (*(void *)v24 == __PAIR64__(*a7, *a8))
  {
    *(void *)BOOL v23 = 0;
    int v22 = 0;
    uint64_t v21 = 0;
    if (kdu_tile::get_mct_dwt_info((kdu_tile *)v27, a2, a3, (BOOL *)(a1 + 80), (int *)(a1 + 64), v23, &v22, (int *)(a1 + 84), (BOOL *)(a1 + 81), (BOOL *)(a1 + 82), &v21, v19, v17))
    {
      if (*(int *)(a1 + 64) > 0)
      {
        *(_DWORD *)(a1 + 120) = 0;
        *(_DWORD *)(a1 + 96) = 0;
        operator new[]();
      }
    }
    kd_multi_dwt_block::initialize();
  }
  kd_multi_dwt_block::initialize();
}

void sub_1886D62FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

const char *kd_multi_dwt_block::prepare_for_inversion(kd_multi_dwt_block *this)
{
  uint64_t v1 = *((unsigned int *)this + 16);
  if ((int)v1 <= 0) {
    kd_multi_dwt_block::prepare_for_inversion();
  }
  uint64_t v2 = *((void *)this + 9) + (v1 << 6);
  uint64_t v3 = *(unsigned int *)(v2 - 60);
  if ((int)v3 < 1)
  {
LABEL_7:
    *((_DWORD *)this + 11) = v3;
    uint64_t v7 = *((unsigned int *)this + 6);
    if ((int)v7 < 1)
    {
      return 0;
    }
    else
    {
      uint64_t v8 = 0;
      uint64_t v9 = 8 * v7;
      uint64_t v5 = "Encountered an irreversible DWT transform block which operates on reversible codestream sample data.  While w"
           "e allow such transforms to be processed during decompression, it is unreasonable to generate reversibly compr"
           "essed component samples using an irreversible inverse multi-component transform during compression.  Kakadu w"
           "ill not invert this transform during compression.  This can prevent the compression process from proceeding i"
           "f there are no other paths back from the MCT output components to the codestream components.";
      while (1)
      {
        if (!*((unsigned char *)this + 80))
        {
          uint64_t v10 = *(void *)(*((void *)this + 4) + v8);
          if (v10)
          {
            if (*(unsigned char *)(v10 + 36)) {
              break;
            }
          }
        }
        v8 += 8;
        if (v9 == v8) {
          return 0;
        }
      }
    }
  }
  else if (*(void *)(v2 - 48) == *(void *)(v2 - 64))
  {
    uint64_t v4 = *(void *)(v2 - 32);
    uint64_t v5 = "DWT transform block cannot be inverted unless all output components can be computed by downstream transform blo"
         "cks in the multi-component transform network, or by the application supplying them.";
    uint64_t v6 = v3;
    while (*(int *)(*(void *)v4 + 28) >= 1)
    {
      v4 += 8;
      if (!--v6) {
        goto LABEL_7;
      }
    }
  }
  else
  {
    return "DWT transform block cannot be inverted unless all output components can be computed by downstream transform b"
           "locks in the multi-component transform network, or by the application supplying them.";
  }
  return v5;
}

uint64_t kd_multi_dwt_block::normalize_coefficients(uint64_t this)
{
  if (!*(unsigned char *)(this + 80))
  {
    int v1 = *(_DWORD *)(this + 12);
    if (v1 < 1)
    {
      int v3 = 0;
      char v2 = 0;
    }
    else
    {
      char v2 = 0;
      int v3 = 0;
      uint64_t v4 = (_DWORD *)(*(void *)(this + 16) + 40);
      uint64_t v5 = *(unsigned int *)(this + 12);
      do
      {
        if (*v4 > v3) {
          int v3 = *v4;
        }
        v2 |= *((unsigned char *)v4 - 2) != 0;
        v4 += 20;
        --v5;
      }
      while (v5);
    }
    char v6 = (v3 == 0) | v2;
    LODWORD(v7) = *(_DWORD *)(this + 24);
    if ((int)v7 >= 1)
    {
      uint64_t v8 = *(uint64_t **)(this + 32);
      uint64_t v9 = *(unsigned int *)(this + 24);
      do
      {
        uint64_t v10 = *v8;
        if (*v8 && (*(unsigned char *)(v10 + 38) || !*(_DWORD *)(v10 + 40))) {
          char v6 = 1;
        }
        ++v8;
        --v9;
      }
      while (v9);
    }
    if (v1 >= 1)
    {
      uint64_t v11 = 0;
      for (uint64_t i = 0; i < v1; ++i)
      {
        uint64_t v13 = *(void *)(this + 16) + v11;
        *(unsigned char *)(v13 + 38) = v6 & 1;
        if (!*(unsigned char *)(v13 + 37)) {
          kd_multi_dwt_block::normalize_coefficients();
        }
        int v14 = *(_DWORD *)(v13 + 40);
        if (v14)
        {
          if (v14 != v3)
          {
            uint64_t v17 = 0;
            memset(v16, 0, sizeof(v16));
            kdu_error::kdu_error((kdu_error *)v16, "Kakadu Core Error:\n");
            (*(void (**)(_OWORD *, const char *))(*(void *)&v16[0] + 16))(v16, "Inconsistent bit-depths encountered amongst output image components produced by a DWT transform block embedded inside the multi-component transform network.  All output (i.e., synthesized) components produced by a single DWT block must be declared with the same bit-depth.  Anything else makes no sense, so Kakadu does not bother trying to accommodate this case.");
            kdu_error::~kdu_error((kdu_error *)v16);
          }
        }
        else
        {
          *(_DWORD *)(v13 + 40) = v3;
        }
        v11 += 80;
      }
      LODWORD(v7) = *(_DWORD *)(this + 24);
    }
    if ((int)v7 >= 1)
    {
      uint64_t v15 = *(void *)(this + 32);
      uint64_t v7 = v7;
      do
      {
        if (*(void *)v15) {
          *(unsigned char *)(*(void *)v15 + 38) = v6 & 1;
        }
        v15 += 8;
        --v7;
      }
      while (v7);
    }
  }
  return this;
}

void sub_1886D65F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886D65FC()
{
  _Unwind_Resume(v0);
}

uint64_t kd_multi_dwt_block::propagate_bit_depths(kd_multi_dwt_block *this, int a2, int a3)
{
  if ((a2 & 1) == 0 && !a3) {
    goto LABEL_28;
  }
  uint64_t v3 = *((unsigned int *)this + 3);
  if ((int)v3 >= 1)
  {
    int v4 = 0;
    uint64_t v5 = (int *)(*((void *)this + 2) + 40);
    uint64_t v6 = *((unsigned int *)this + 3);
    do
    {
      int v8 = *v5;
      v5 += 20;
      int v7 = v8;
      if (v8)
      {
        if (v4)
        {
          BOOL v15 = v4 == v7;
          int v4 = v7;
          if (!v15) {
            goto LABEL_28;
          }
        }
        else
        {
          int v4 = v7;
        }
      }
      --v6;
    }
    while (v6);
    if (v4) {
      goto LABEL_31;
    }
  }
  if (a2)
  {
LABEL_28:
    char v16 = 0;
    return v16 & 1;
  }
  uint64_t v9 = *((void *)this + 9);
  uint64_t v10 = *(unsigned int *)(v9 + 20);
  if ((int)v10 < 1)
  {
    int v4 = 0;
  }
  else
  {
    int v4 = 0;
    int v11 = 0;
    char v12 = *(uint64_t ***)(v9 + 40);
    do
    {
      if (*v12)
      {
        uint64_t v13 = **v12;
        if (v13)
        {
          int v14 = *(_DWORD *)(v13 + 40);
          if (v14)
          {
            if (v14 > v11) {
              int v11 = v14;
            }
            BOOL v15 = v14 < v4 || v4 == 0;
            if (v15) {
              int v4 = v14;
            }
          }
        }
      }
      ++v12;
      --v10;
    }
    while (v10);
    if (v4 <= 0 && v11 != v4) {
      goto LABEL_28;
    }
  }
LABEL_31:
  if (!a3)
  {
    char v16 = 0;
    if (!a2) {
      return v16 & 1;
    }
    goto LABEL_42;
  }
  if ((int)v3 < 1)
  {
    char v18 = 0;
  }
  else
  {
    char v18 = 0;
    uint64_t v19 = (int *)(*((void *)this + 2) + 40);
    do
    {
      if (!*v19)
      {
        *uint64_t v19 = v4;
        char v18 = 1;
      }
      v19 += 20;
      --v3;
    }
    while (v3);
  }
  char v16 = v18;
  if (a2)
  {
LABEL_42:
    uint64_t v20 = *((unsigned int *)this + 16);
    if ((int)v20 >= 1)
    {
      uint64_t v21 = 0;
      uint64_t v22 = *((void *)this + 9);
      do
      {
        uint64_t v23 = v22 + (v21 << 6);
        uint64_t v24 = *(unsigned int *)(v23 + 20);
        if ((int)v24 >= 1)
        {
          int v25 = *(uint64_t ***)(v23 + 40);
          if (v21) {
            int v26 = v4 + 1;
          }
          else {
            int v26 = v4;
          }
          do
          {
            if (*v25)
            {
              uint64_t v27 = **v25;
              if (v27)
              {
                if (!*(_DWORD *)(v27 + 40))
                {
                  *(_DWORD *)(v27 + 40) = v26;
                  char v16 = 1;
                }
              }
            }
            ++v25;
            --v24;
          }
          while (v24);
        }
        ++v21;
      }
      while (v21 != v20);
    }
  }
  return v16 & 1;
}

void kd_multi_dwt_block::perform_transform(kd_multi_dwt_block *this)
{
  if (*((int *)this + 16) < 1) {
    return;
  }
  uint64_t v2 = 0;
  do
  {
    uint64_t v3 = *((void *)this + 9);
    uint64_t v4 = v3 + (v2 << 6);
    uint64_t v6 = (int *)(v4 + 20);
    LODWORD(v5) = *(_DWORD *)(v4 + 20);
    uint64_t v79 = v3;
    if ((int)v5 < 1) {
      goto LABEL_53;
    }
    uint64_t v7 = 0;
    int v8 = (void *)(v4 + 40);
    uint64_t v9 = (void *)(v4 + 32);
    uint64_t v10 = (_DWORD *)(v4 + 16);
    int v11 = (float *)(v4 + 56);
    uint64_t v82 = v3 + (v2 << 6);
    char v12 = (float *)(v4 + 52);
    do
    {
      uint64_t v13 = *(uint64_t **)(*v8 + 8 * v7);
      if (!v13) {
        goto LABEL_10;
      }
      uint64_t v14 = *(void *)(*v9 + 8 * v7);
      uint64_t v15 = *v13;
      if (!*v13)
      {
        kd_multi_line::reset((kd_multi_line *)v14, 0, 0.0);
        goto LABEL_10;
      }
      if (*((unsigned char *)this + 80))
      {
        kd_multi_line::copy(v14, (kd_multi_line *)v15, 0, 0.0);
        goto LABEL_10;
      }
      if ((*v10 + v7)) {
        float v16 = *v11 * 0.5;
      }
      else {
        float v16 = *v12;
      }
      uint64_t v17 = *(unsigned int *)(v14 + 20);
      if ((*(unsigned char *)(v14 + 6) & 2) == 0)
      {
        char v18 = *(float **)(v14 + 8);
        if (v18)
        {
          if (*(unsigned char *)(v15 + 36))
          {
            if ((*(unsigned char *)(v15 + 6) & 2) != 0) {
              uint64_t v19 = 0;
            }
            else {
              uint64_t v19 = *(int **)(v15 + 8);
            }
            if ((int)v17 >= 1)
            {
              float v30 = v16 / (float)(1 << *(_DWORD *)(v14 + 40));
              do
              {
                int v31 = *v19++;
                *v18++ = v30 * (float)v31;
                --v17;
              }
              while (v17);
            }
          }
          else
          {
            if ((*(unsigned char *)(v15 + 6) & 2) != 0) {
              uint64_t v29 = 0;
            }
            else {
              uint64_t v29 = *(float **)(v15 + 8);
            }
            if ((int)v17 >= 1)
            {
              float v32 = (float)(v16 * (float)(1 << *(_DWORD *)(v15 + 40))) / (float)(1 << *(_DWORD *)(v14 + 40));
              do
              {
                float v33 = *v29++;
                *v18++ = v32 * v33;
                --v17;
              }
              while (v17);
            }
          }
          goto LABEL_10;
        }
      }
      if (*(unsigned char *)(v15 + 36)) {
        float v20 = 8192.0;
      }
      else {
        float v20 = (float)(1 << *(_DWORD *)(v15 + 40));
      }
      float v21 = (float)(v16 / (float)(1 << *(_DWORD *)(v14 + 40))) * v20;
      int v22 = 0;
      while (v21 < 16383.0)
      {
        float v21 = v21 + v21;
        ++v22;
      }
      while (v21 > 32767.0)
      {
        float v21 = v21 * 0.5;
        --v22;
      }
      if ((*(unsigned char *)(v15 + 6) & 2) != 0)
      {
        uint64_t v23 = *(__int16 **)(v15 + 8);
        if ((*(unsigned char *)(v14 + 6) & 2) != 0)
        {
LABEL_30:
          uint64_t v24 = *(_WORD **)(v14 + 8);
          goto LABEL_33;
        }
      }
      else
      {
        uint64_t v23 = 0;
        if ((*(unsigned char *)(v14 + 6) & 2) != 0) {
          goto LABEL_30;
        }
      }
      uint64_t v24 = 0;
LABEL_33:
      unsigned int v25 = vcvtmd_s64_f64(v21 + 0.5);
      if (v22 < 0)
      {
        if ((int)v17 >= 1)
        {
          int v27 = -v22;
          do
          {
            int v28 = (unsigned __int16)*v23++;
            *v24++ = (v28 * (unsigned __int16)v25) << v27;
            --v17;
          }
          while (v17);
        }
      }
      else if ((int)v17 >= 1)
      {
        do
        {
          int v26 = *v23++;
          *v24++ = (int)((1 << v22 >> 1) + v26 * v25) >> v22;
          --v17;
        }
        while (v17);
      }
LABEL_10:
      ++v7;
      uint64_t v5 = *v6;
    }
    while (v7 < v5);
    uint64_t v3 = v79;
    uint64_t v4 = v82;
LABEL_53:
    int v36 = *(_DWORD *)(v4 + 16);
    uint64_t v34 = (_DWORD *)(v4 + 16);
    int v35 = v36;
    if (*(v34 - 3) != 1)
    {
      uint64_t v41 = *((unsigned int *)this + 21);
      uint64_t v78 = v2;
      if ((int)v41 >= 1)
      {
        int v42 = v35 + v5;
        int v43 = v35 + v5 - 1;
        uint64_t v44 = (void *)(v3 + (v2 << 6) + 32);
        CGRect v83 = v34;
        while (1)
        {
          uint64_t v81 = v41;
          uint64_t v45 = v41 - 1;
          uint64_t v80 = v45;
          if (!((*v34 ^ v45) & 1) < (int)v5) {
            break;
          }
LABEL_98:
          uint64_t v41 = v80;
          uint64_t v34 = v83;
          if (v81 <= 1) {
            goto LABEL_99;
          }
        }
        uint64_t v46 = *((void *)this + 11) + 32 * v45;
        uint64_t v47 = (unsigned char *)(v46 + 1);
        uint64_t v48 = ((*v34 ^ v45) & 1) == 0;
        while (1)
        {
          uint64_t v49 = *(void *)(*v44 + 8 * v48);
          int v50 = *(_DWORD *)(v49 + 20);
          char v51 = *(unsigned char *)(v49 + 6);
          uint64_t v52 = *(void *)(v49 + 8);
          uint64_t v53 = (v51 & 2) != 0 ? v52 : 0;
          uint64_t v54 = (v51 & 2) != 0 ? 0 : v52;
          uint64_t v55 = *v47;
          if (*v47) {
            break;
          }
LABEL_93:
          if (v53)
          {
            perform_synthesis_lifting_step(v46, *((uint64_t **)this + 16), v53, v53, v50, 0);
          }
          else
          {
            if (!v54) {
              kd_multi_dwt_block::perform_transform();
            }
            perform_synthesis_lifting_step(v46, *((uint64_t **)this + 16), v54, v54, v50, 0);
          }
          v48 += 2;
          LODWORD(v5) = *v6;
          if (*v6 <= (int)v48) {
            goto LABEL_98;
          }
        }
        uint64_t v56 = 0;
        int v57 = *v83;
        int v58 = ((*v83 + v48) ^ 1) + 2 * *(__int16 *)(v46 + 4);
        while (1)
        {
          BOOL v59 = v58 < v35;
          if (v58 < v35 || (int v60 = v58, v58 >= v42))
          {
            int v60 = v58;
            do
            {
              if (v59)
              {
                if (*((unsigned char *)this + 82)) {
                  int v60 = 2 * v35 - v60;
                }
                else {
                  int v60 = ((v60 ^ v35) & 1) + v35;
                }
              }
              else if (*((unsigned char *)this + 82))
              {
                int v60 = 2 * v43 - v60;
              }
              else
              {
                int v60 = v43 - ((v60 ^ v43) & 1);
              }
              BOOL v59 = v60 < v35;
            }
            while (v60 < v35 || v60 >= v42);
          }
          int v61 = v60 - v57;
          if (v60 - v57 < 0 || v61 >= (int)v5) {
            kd_multi_dwt_block::perform_transform();
          }
          uint64_t v62 = *(void *)(*v44 + 8 * v61);
          if (v53)
          {
            if ((*(unsigned char *)(v62 + 6) & 2) != 0) {
              goto LABEL_91;
            }
          }
          else if ((*(unsigned char *)(v62 + 6) & 2) == 0)
          {
LABEL_91:
            uint64_t v63 = *(void *)(v62 + 8);
            goto LABEL_92;
          }
          uint64_t v63 = 0;
LABEL_92:
          *(void *)(*((void *)this + 16) + 8 * v56++) = v63;
          v58 += 2;
          if (v56 == v55) {
            goto LABEL_93;
          }
        }
      }
LABEL_99:
      uint64_t v2 = v78;
      uint64_t v3 = v79;
      if (*((unsigned char *)this + 80)) {
        goto LABEL_118;
      }
      uint64_t v64 = v79 + (v78 << 6);
      int v66 = *(_DWORD *)(v64 + 48);
      int v65 = (int *)(v64 + 48);
      if (v66 < 1 || (int)v5 < 1) {
        goto LABEL_118;
      }
      uint64_t v68 = 0;
      while (1)
      {
        uint64_t v69 = *(void *)(*(void *)(v79 + (v78 << 6) + 32) + 8 * v68);
        uint64_t v70 = *(unsigned int *)(v69 + 20);
        char v71 = *(unsigned char *)(v69 + 6);
        uint64_t v72 = *(float **)(v69 + 8);
        if ((v71 & 2) != 0) {
          break;
        }
        int v73 = *v65;
        if (!v72) {
          goto LABEL_111;
        }
        if ((int)v70 >= 1)
        {
          do
          {
            *uint64_t v72 = *v72 * (float)(1 << v73);
            ++v72;
            --v70;
          }
          while (v70);
        }
LABEL_113:
        if (++v68 >= *v6) {
          goto LABEL_118;
        }
      }
      int v73 = *v65;
LABEL_111:
      if ((int)v70 >= 1)
      {
        do
        {
          *(_WORD *)uint64_t v72 = *(unsigned __int16 *)v72 << v73;
          uint64_t v72 = (float *)((char *)v72 + 2);
          --v70;
        }
        while (v70);
      }
      goto LABEL_113;
    }
    if ((v35 & 1) != 0 && *((unsigned char *)this + 80))
    {
      uint64_t v37 = **(void **)(v3 + (v2 << 6) + 32);
      char v38 = *(unsigned char *)(v37 + 6);
      uint64_t v39 = *(int **)(v37 + 8);
      uint64_t v40 = *(unsigned int *)(v37 + 20);
      if ((v38 & 2) != 0 && v39)
      {
        if ((int)v40 >= 1)
        {
          do
          {
            *(_WORD *)uint64_t v39 = *(__int16 *)v39 >> 1;
            uint64_t v39 = (int *)((char *)v39 + 2);
            --v40;
          }
          while (v40);
        }
      }
      else if ((int)v40 >= 1)
      {
        do
        {
          *v39++ >>= 1;
          --v40;
        }
        while (v40);
      }
    }
    if (*(_DWORD *)(v3 + (v2 << 6) + 48)) {
      kd_multi_dwt_block::perform_transform();
    }
LABEL_118:
    uint64_t v74 = *((int *)this + 16);
    if (v2 >= v74 - 1 && *v6 >= 1)
    {
      uint64_t v75 = 0;
      long long v76 = v6;
      long long v77 = (void *)(v3 + (v2 << 6) + 32);
      do
      {
        kd_multi_line::apply_offset(*(void *)(*v77 + 8 * v75), *(_DWORD *)(*(void *)(*v77 + 8 * v75) + 44), *(float *)(*(void *)(*v77 + 8 * v75) + 48));
        ++v75;
      }
      while (v75 < *v76);
      LODWORD(v74) = *((_DWORD *)this + 16);
    }
    ++v2;
  }
  while (v2 < (int)v74);
}

uint64_t kd_multi_dwt_block::perform_inverse(uint64_t this)
{
  uint64_t v1 = *(unsigned int *)(this + 64);
  if ((int)v1 >= 1)
  {
    uint64_t v2 = this;
    do
    {
      uint64_t v3 = *(void *)(v2 + 72);
      uint64_t v4 = (v1 - 1);
      uint64_t v5 = (int *)(v3 + (v4 << 6));
      int v6 = v5[1];
      uint64_t v78 = v1 - 1;
      if (v6 == 1)
      {
        if (v5[12]) {
          kd_multi_dwt_block::perform_inverse();
        }
        if ((*(unsigned char *)v5 & 1) != 0 && *(unsigned char *)(v2 + 80))
        {
          uint64_t v7 = **(void **)(v3 + (v4 << 6) + 32);
          char v8 = *(unsigned char *)(v7 + 6);
          uint64_t v9 = *(_WORD **)(v7 + 8);
          uint64_t v10 = *(unsigned int *)(v7 + 20);
          if ((v8 & 2) != 0 && v9)
          {
            if ((int)v10 >= 1)
            {
              do
              {
                *v9++ *= 2;
                --v10;
              }
              while (v10);
            }
          }
          else if ((int)v10 >= 1)
          {
            do
            {
              *(_DWORD *)v9 *= 2;
              v9 += 2;
              --v10;
            }
            while (v10);
          }
        }
        goto LABEL_68;
      }
      if (!*(unsigned char *)(v2 + 80))
      {
        uint64_t v37 = v3 + (v4 << 6);
        char v38 = (int *)(v37 + 48);
        if (*(int *)(v37 + 48) >= 1)
        {
          int v40 = *(_DWORD *)(v37 + 20);
          uint64_t v39 = (int *)(v37 + 20);
          if (v40 >= 1)
          {
            uint64_t v41 = 0;
            while (1)
            {
              uint64_t v42 = *(void *)(*(void *)(v3 + (v4 << 6) + 32) + 8 * v41);
              uint64_t v43 = *(unsigned int *)(v42 + 20);
              char v44 = *(unsigned char *)(v42 + 6);
              uint64_t v45 = *(float **)(v42 + 8);
              if ((v44 & 2) != 0) {
                break;
              }
              int v46 = *v38;
              if (!v45) {
                goto LABEL_62;
              }
              if ((int)v43 >= 1)
              {
                do
                {
                  *uint64_t v45 = (float)(1.0 / (float)(1 << v46)) * *v45;
                  ++v45;
                  --v43;
                }
                while (v43);
              }
LABEL_64:
              if (++v41 >= *v39)
              {
                int v6 = v5[1];
                goto LABEL_13;
              }
            }
            int v46 = *v38;
LABEL_62:
            if ((int)v43 >= 1)
            {
              do
              {
                this = (((0x10000 << (v46 - 1) >> 16) + *(__int16 *)v45) >> v46);
                *(_WORD *)uint64_t v45 = this;
                uint64_t v45 = (float *)((char *)v45 + 2);
                --v43;
              }
              while (v43);
            }
            goto LABEL_64;
          }
        }
      }
LABEL_13:
      int v11 = *(_DWORD *)(v2 + 84);
      if (v11 < 1) {
        goto LABEL_68;
      }
      uint64_t v12 = 0;
      int v13 = *v5;
      int v14 = v6 + *v5;
      uint64_t v15 = v3 + (v4 << 6);
      int v17 = *(_DWORD *)(v15 + 20);
      v15 += 20;
      int v16 = v17;
      uint64_t v79 = (int *)(v15 - 4);
      uint64_t v80 = (int *)v15;
      char v18 = (void *)(v15 + 12);
      uint64_t v75 = v3;
      uint64_t v76 = v1;
      uint64_t v74 = (v1 - 1);
      do
      {
        if (!((*v79 ^ v12) & 1) >= v16) {
          goto LABEL_51;
        }
        uint64_t v77 = v12;
        uint64_t v19 = *(void *)(v2 + 88) + 32 * v12;
        float v20 = (unsigned char *)(v19 + 1);
        uint64_t v21 = ((*v79 ^ v12) & 1) == 0;
        do
        {
          uint64_t v22 = *(void *)(*v18 + 8 * v21);
          int v23 = *(_DWORD *)(v22 + 20);
          char v24 = *(unsigned char *)(v22 + 6);
          uint64_t v25 = *(void *)(v22 + 8);
          if ((v24 & 2) != 0) {
            uint64_t v26 = v25;
          }
          else {
            uint64_t v26 = 0;
          }
          if ((v24 & 2) != 0) {
            uint64_t v27 = 0;
          }
          else {
            uint64_t v27 = v25;
          }
          uint64_t v28 = *v20;
          if (*v20)
          {
            uint64_t v29 = 0;
            int v30 = *v79;
            int v31 = ((*v79 + v21) ^ 1) + 2 * *(__int16 *)(v19 + 4);
            do
            {
              BOOL v32 = v31 < v13;
              if (v31 < v13 || (int v33 = v31, v31 >= v14))
              {
                int v33 = v31;
                do
                {
                  if (v32)
                  {
                    if (*(unsigned char *)(v2 + 82)) {
                      int v33 = 2 * v13 - v33;
                    }
                    else {
                      int v33 = ((v33 ^ v13) & 1) + v13;
                    }
                  }
                  else if (*(unsigned char *)(v2 + 82))
                  {
                    int v33 = 2 * (v14 - 1) - v33;
                  }
                  else
                  {
                    int v33 = v14 - 1 - ((v33 ^ (v14 - 1)) & 1);
                  }
                  BOOL v32 = v33 < v13;
                }
                while (v33 < v13 || v33 >= v14);
              }
              int v34 = v33 - v30;
              if (v33 - v30 < 0 || v34 >= v16) {
                kd_multi_dwt_block::perform_inverse();
              }
              uint64_t v35 = *(void *)(*v18 + 8 * v34);
              if (v26)
              {
                if ((*(unsigned char *)(v35 + 6) & 2) != 0) {
                  goto LABEL_43;
                }
              }
              else if ((*(unsigned char *)(v35 + 6) & 2) == 0)
              {
LABEL_43:
                uint64_t v36 = *(void *)(v35 + 8);
                goto LABEL_44;
              }
              uint64_t v36 = 0;
LABEL_44:
              *(void *)(*(void *)(v2 + 128) + 8 * v29++) = v36;
              v31 += 2;
            }
            while (v29 != v28);
          }
          if (v26)
          {
            this = perform_analysis_lifting_step(v19, *(uint64_t **)(v2 + 128), v26, v26, v23, 0);
          }
          else
          {
            if (!v27) {
              kd_multi_dwt_block::perform_inverse();
            }
            this = perform_analysis_lifting_step(v19, *(uint64_t **)(v2 + 128), v27, v27, v23, 0);
          }
          v21 += 2;
          int v16 = *v80;
        }
        while (*v80 > (int)v21);
        int v11 = *(_DWORD *)(v2 + 84);
        uint64_t v3 = v75;
        uint64_t v1 = v76;
        uint64_t v4 = v74;
        uint64_t v12 = v77;
LABEL_51:
        ++v12;
      }
      while (v12 < v11);
LABEL_68:
      uint64_t v47 = v3 + (v4 << 6);
      uint64_t v48 = (int *)(v47 + 20);
      if (*(int *)(v47 + 20) >= 1)
      {
        uint64_t v49 = 0;
        int v50 = (void *)(v47 + 40);
        char v51 = (void *)(v47 + 32);
        uint64_t v52 = (_DWORD *)(v47 + 16);
        uint64_t v53 = (float *)(v47 + 56);
        uint64_t v54 = (float *)(v47 + 52);
        do
        {
          uint64_t v55 = *(uint64_t **)(*v50 + 8 * v49);
          if (v55)
          {
            this = *v55;
            if (*v55)
            {
              uint64_t v56 = *(void *)(*v51 + 8 * v49);
              if (*(unsigned char *)(v2 + 80))
              {
                this = kd_multi_line::copy(this, (kd_multi_line *)v56, -*(_DWORD *)(this + 44), -*(float *)(this + 48));
              }
              else
              {
                if ((*v52 + v49)) {
                  float v57 = *v53 * 0.5;
                }
                else {
                  float v57 = *v54;
                }
                if (*(unsigned char *)(this + 36)) {
                  kd_multi_dwt_block::perform_inverse();
                }
                uint64_t v58 = *(unsigned int *)(v56 + 20);
                float v59 = (float)(1 << *(_DWORD *)(v56 + 40)) / (float)(v57 * (float)(1 << *(_DWORD *)(this + 40)));
                if ((*(unsigned char *)(v56 + 6) & 2) != 0 || (int v60 = *(float **)(v56 + 8)) == 0)
                {
                  int v62 = 0;
                  while (v59 < 16383.0)
                  {
                    float v59 = v59 + v59;
                    ++v62;
                  }
                  while (v59 > 32767.0)
                  {
                    float v59 = v59 * 0.5;
                    --v62;
                  }
                  if ((*(unsigned char *)(v56 + 6) & 2) != 0) {
                    uint64_t v63 = *(__int16 **)(v56 + 8);
                  }
                  else {
                    uint64_t v63 = 0;
                  }
                  if ((*(unsigned char *)(this + 6) & 2) != 0) {
                    uint64_t v64 = *(_WORD **)(this + 8);
                  }
                  else {
                    uint64_t v64 = 0;
                  }
                  unsigned int v65 = vcvtmd_s64_f64(v59 + 0.5);
                  unsigned int v66 = vcvtmd_s64_f64((float)(*(float *)(this + 48) * 8192.0) + 0.5);
                  if (v62 < 0)
                  {
                    if ((int)v58 >= 1)
                    {
                      int v69 = -v62;
                      do
                      {
                        __int16 v70 = *v63++;
                        *v64++ = ((v70 * (_WORD)v65) << v69) - v66;
                        --v58;
                      }
                      while (v58);
                    }
                  }
                  else if ((int)v58 >= 1)
                  {
                    int v67 = (1 << v62 >> 1) - (v66 << v62);
                    do
                    {
                      int v68 = *v63++;
                      *v64++ = (int)(v67 + v68 * v65) >> v62;
                      --v58;
                    }
                    while (v58);
                  }
                }
                else
                {
                  if ((*(unsigned char *)(this + 6) & 2) != 0) {
                    int v61 = 0;
                  }
                  else {
                    int v61 = *(float **)(this + 8);
                  }
                  if ((int)v58 >= 1)
                  {
                    float v71 = -*(float *)(this + 48);
                    do
                    {
                      float v72 = *v60++;
                      *v61++ = v71 + (float)(v72 * v59);
                      --v58;
                    }
                    while (v58);
                  }
                }
              }
            }
          }
          ++v49;
        }
        while (v49 < *v48);
      }
      BOOL v73 = v1 < 2;
      uint64_t v1 = v78;
    }
    while (!v73);
  }
  return this;
}

void kd_multi_null_block::~kd_multi_null_block(kd_multi_null_block *this)
{
  kd_multi_block::~kd_multi_block(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t kd_multi_block::propagate_bit_depths(kd_multi_block *this)
{
  return 0;
}

const char *kd_multi_block::prepare_for_inversion(kd_multi_block *this)
{
  return "Unimplemented multi-component transform block inversion procedure.";
}

void kd_multi_matrix_block::~kd_multi_matrix_block(kd_multi_matrix_block *this)
{
  kd_multi_matrix_block::~kd_multi_matrix_block(this);

  JUMPOUT(0x18C11C0E0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t vars8;

  *(void *)this = &unk_1ED4E5318;
  uint64_t v2 = *((void *)this + 8);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C8052888210);
  }
  uint64_t v3 = *((void *)this + 9);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C8052888210);
  }
  uint64_t v4 = *((void *)this + 10);
  if (v4) {
    MEMORY[0x18C11C0C0](v4, 0x1000C80BDFB0063);
  }
  uint64_t v5 = *((void *)this + 11);
  if (v5) {
    MEMORY[0x18C11C0C0](v5, 0x1000C8052888210);
  }
  int v6 = *((void *)this + 13);
  if (v6) {
    MEMORY[0x18C11C0C0](v6, 0x1000C8000313F17);
  }

  kd_multi_block::~kd_multi_block(this);
}

void kd_multi_rxform_block::~kd_multi_rxform_block(kd_multi_rxform_block *this)
{
  kd_multi_rxform_block::~kd_multi_rxform_block(this);

  JUMPOUT(0x18C11C0E0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t vars8;

  *(void *)this = &unk_1ED4E5368;
  uint64_t v2 = *((void *)this + 8);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C8052888210);
  }
  uint64_t v3 = *((void *)this + 9);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C8052888210);
  }

  kd_multi_block::~kd_multi_block(this);
}

void kd_multi_dependency_block::~kd_multi_dependency_block(kd_multi_dependency_block *this)
{
  kd_multi_dependency_block::~kd_multi_dependency_block(this);

  JUMPOUT(0x18C11C0E0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t vars8;

  *(void *)this = &unk_1ED4E5628;
  uint64_t v2 = *((void *)this + 9);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C8052888210);
  }
  uint64_t v3 = *((void *)this + 10);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C8052888210);
  }
  uint64_t v4 = *((void *)this + 11);
  if (v4) {
    MEMORY[0x18C11C0C0](v4, 0x1000C8052888210);
  }
  uint64_t v5 = *((void *)this + 12);
  if (v5) {
    MEMORY[0x18C11C0C0](v5, 0x1000C8052888210);
  }
  int v6 = *((void *)this + 13);
  if (v6) {
    MEMORY[0x18C11C0C0](v6, 0x1000C80BDFB0063);
  }
  uint64_t v7 = *((void *)this + 15);
  if (v7) {
    MEMORY[0x18C11C0C0](v7, 0x1000C8052888210);
  }

  kd_multi_block::~kd_multi_block(this);
}

void kd_multi_dwt_block::~kd_multi_dwt_block(kd_multi_dwt_block *this)
{
  kd_multi_dwt_block::~kd_multi_dwt_block(this);

  JUMPOUT(0x18C11C0E0);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t vars8;

  *(void *)this = &unk_1ED4E4958;
  uint64_t v2 = *((void *)this + 9);
  if (v2)
  {
    uint64_t v3 = v2 - 16;
    uint64_t v4 = *(void *)(v2 - 8);
    if (v4)
    {
      uint64_t v5 = v2 - 64;
      int v6 = v4 << 6;
      do
      {
        kd_multi_dwt_level::~kd_multi_dwt_level((kd_multi_dwt_level *)(v5 + v6));
        v6 -= 64;
      }
      while (v6);
    }
    MEMORY[0x18C11C0C0](v3, 0x1080C80D9599B8ALL);
  }
  uint64_t v7 = *((void *)this + 11);
  if (v7) {
    MEMORY[0x18C11C0C0](v7, 0x1090C805C18EE7CLL);
  }
  char v8 = *((void *)this + 13);
  if (v8) {
    MEMORY[0x18C11C0C0](v8, 0x1000C8052888210);
  }
  uint64_t v9 = *((void *)this + 14);
  if (v9) {
    MEMORY[0x18C11C0C0](v9, 0x1000C8052888210);
  }
  uint64_t v10 = *((void *)this + 16);
  if (v10)
  {
    MEMORY[0x18C11C0C0](v10, 0x20C8093837F09);
    *((void *)this + 16) = 0;
  }

  kd_multi_block::~kd_multi_block(this);
}

void kd_multi_component::~kd_multi_component(kd_multi_component *this)
{
  *(void *)this = &unk_1ED4E4930;
  uint64_t v2 = *((void *)this + 18);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    *((void *)this + 18) = 0;
  }
  uint64_t v3 = *((void *)this + 19);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    *((void *)this + 19) = 0;
  }
  uint64_t v4 = *((void *)this + 17);
  if (v4) {
    MEMORY[0x18C11C0C0](v4, 0x1020C805730B0C9);
  }
  *(void *)this = &unk_1ED4DE9F0;
}

{
  uint64_t vars8;

  kd_multi_component::~kd_multi_component(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t kd_multi_component::do_job(uint64_t this, kdu_thread_entity *a2)
{
  if (*(int *)(this + 120) >= 1)
  {
    uint64_t v3 = this;
    int v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(v3 + 144);
      uint64_t v6 = *(void *)(v3 + 136) + 16 * (v4 + *(_DWORD *)(v3 + 116));
      if (v5) {
        this = (*(uint64_t (**)(uint64_t, uint64_t, kdu_thread_entity *))(*(void *)v5 + 24))(v5, v6, a2);
      }
      else {
        this = (*(uint64_t (**)(void, uint64_t, kdu_thread_entity *))(**(void **)(v3 + 152) + 16))(*(void *)(v3 + 152), v6, a2);
      }
      ++v4;
    }
    while (v4 < *(_DWORD *)(v3 + 120));
  }
  return this;
}

void kd_multi_block::~kd_multi_block(kd_multi_block *this)
{
  *(void *)this = &unk_1ED4E3108;
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1020C80587BA0B9);
  }
  uint64_t v3 = *((void *)this + 4);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x20C8093837F09);
  }
}

void kd_multi_dwt_level::~kd_multi_dwt_level(kd_multi_dwt_level *this)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x20C8093837F09);
  }
  uint64_t v3 = *((void *)this + 5);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x80C80B8603338);
  }
}

void _cg_jinit_c_master_control(uint64_t *a1, int a2)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (*(uint64_t (**)(void))a1[1])();
  a1[62] = v3;
  *(void *)uint64_t v3 = prepare_for_pass;
  *(void *)(v3 + 8) = pass_startup;
  *(void *)(v3 + 16) = finish_pass_master;
  *(_DWORD *)(v3 + 28) = 0;
  int v4 = *((_DWORD *)a1 + 119);
  if ((v4 - 17) <= 0xFFFFFFEF)
  {
    uint64_t v5 = *a1;
    *(_DWORD *)(v5 + 40) = 7;
    *(_DWORD *)(v5 + 48) = v4;
    *(_DWORD *)(*a1 + 52) = *((_DWORD *)a1 + 119);
    (*(void (**)(uint64_t *))*a1)(a1);
    int v4 = *((_DWORD *)a1 + 119);
  }
  if ((v4 - 2) > 5) {
    uint64_t v6 = _cg_jpeg_natural_order;
  }
  else {
    uint64_t v6 = (int *)*((void *)&off_1E53C0AB0 + v4 - 2);
  }
  a1[60] = (uint64_t)v6;
  if (v4 >= 8) {
    int v7 = 63;
  }
  else {
    int v7 = v4 * v4 - 1;
  }
  *((_DWORD *)a1 + 122) = v7;
  unsigned int v8 = *((_DWORD *)a1 + 21);
  if (!v8 || !*((_DWORD *)a1 + 20) || *((int *)a1 + 23) <= 0)
  {
    uint64_t v9 = *a1;
    *(_DWORD *)(v9 + 40) = 33;
    (*(void (**)(uint64_t *))v9)(a1);
    unsigned int v8 = *((_DWORD *)a1 + 21);
  }
  if (v8 > 0xFFDC || *((_DWORD *)a1 + 20) >= 0xFFDDu)
  {
    uint64_t v10 = *a1;
    *(_DWORD *)(v10 + 40) = 42;
    *(_DWORD *)(v10 + 48) = 65500;
    (*(void (**)(uint64_t *))*a1)(a1);
  }
  int v11 = *((_DWORD *)a1 + 22);
  if ((v11 - 13) <= 0xFFFFFFFA)
  {
    uint64_t v12 = *a1;
    *(_DWORD *)(v12 + 40) = 16;
    *(_DWORD *)(v12 + 48) = v11;
    (*(void (**)(uint64_t *))*a1)(a1);
  }
  int v13 = *((_DWORD *)a1 + 23);
  if (v13 >= 11)
  {
    uint64_t v14 = *a1;
    *(_DWORD *)(v14 + 40) = 27;
    *(_DWORD *)(v14 + 48) = v13;
    *(_DWORD *)(*a1 + 52) = 10;
    (*(void (**)(uint64_t *))*a1)(a1);
    int v13 = *((_DWORD *)a1 + 23);
  }
  a1[44] = 0x100000001;
  if (v13 < 1)
  {
    int v17 = 1;
  }
  else
  {
    int v15 = 0;
    int v16 = (int *)(a1[13] + 12);
    int v17 = 1;
    int v18 = 1;
    do
    {
      int v19 = *(v16 - 1);
      if ((v19 - 5) < 0xFFFFFFFC || (int v20 = *v16, (*v16 - 5) <= 0xFFFFFFFB))
      {
        uint64_t v21 = *a1;
        *(_DWORD *)(v21 + 40) = 19;
        (*(void (**)(uint64_t *))v21)(a1);
        int v18 = *((_DWORD *)a1 + 88);
        int v19 = *(v16 - 1);
        int v20 = *v16;
        int v17 = *((_DWORD *)a1 + 89);
        int v13 = *((_DWORD *)a1 + 23);
      }
      if (v18 <= v19) {
        int v18 = v19;
      }
      *((_DWORD *)a1 + 88) = v18;
      if (v17 <= v20) {
        int v17 = v20;
      }
      *((_DWORD *)a1 + 89) = v17;
      ++v15;
      v16 += 24;
    }
    while (v15 < v13);
    if (v13 >= 1)
    {
      int v22 = 0;
      int v23 = (_DWORD *)a1[13];
      while (1)
      {
        v23[1] = v22;
        int v24 = *((_DWORD *)a1 + 90);
        if (*((_DWORD *)a1 + 72))
        {
          v23[9] = v24;
          uint64_t v25 = v23 + 9;
          int v26 = *((_DWORD *)a1 + 91);
        }
        else
        {
          if (*((_DWORD *)a1 + 76)) {
            int v27 = 8;
          }
          else {
            int v27 = 4;
          }
          if (v24 <= v27)
          {
            int v28 = 1;
            do
            {
              int v29 = 2 * v28;
              if (*((_DWORD *)a1 + 88) % (2 * v28 * v23[2])) {
                break;
              }
              v28 *= 2;
            }
            while (v29 * v24 <= v27);
          }
          else
          {
            int v28 = 1;
          }
          v24 *= v28;
          v23[9] = v24;
          uint64_t v25 = v23 + 9;
          int v26 = *((_DWORD *)a1 + 91);
          if (v26 <= v27)
          {
            int v30 = 1;
            while (1)
            {
              int v32 = 2 * v30;
              if (*((_DWORD *)a1 + 89) % (2 * v30 * v23[3])) {
                goto LABEL_44;
              }
              v30 *= 2;
              if (v32 * v26 > v27)
              {
                int v30 = v32;
                goto LABEL_44;
              }
            }
          }
        }
        int v30 = 1;
LABEL_44:
        int v31 = v30 * v26;
        v23[10] = v30 * v26;
        if (v24 <= 2 * v30 * v26)
        {
          if (v31 > 2 * v24) {
            v23[10] = 2 * v24;
          }
        }
        else
        {
          *uint64_t v25 = 2 * v31;
        }
        v23[7] = jdiv_round_up((int)v23[2] * (unint64_t)*((unsigned int *)a1 + 20), *((int *)a1 + 119) * (uint64_t)*((int *)a1 + 88));
        v23[8] = jdiv_round_up((int)v23[3] * (unint64_t)*((unsigned int *)a1 + 21), *((int *)a1 + 119) * (uint64_t)*((int *)a1 + 89));
        v23[11] = jdiv_round_up((int)v23[9] * (uint64_t)(int)v23[2] * *((unsigned int *)a1 + 20), *((int *)a1 + 119) * (uint64_t)*((int *)a1 + 88));
        v23[12] = jdiv_round_up((int)v23[10] * (uint64_t)(int)v23[3] * *((unsigned int *)a1 + 21), *((int *)a1 + 119) * (uint64_t)*((int *)a1 + 89));
        v23[13] = 0;
        ++v22;
        v23 += 24;
        if (v22 >= *((_DWORD *)a1 + 23))
        {
          int v17 = *((_DWORD *)a1 + 89);
          break;
        }
      }
    }
  }
  *((_DWORD *)a1 + 92) = jdiv_round_up(*((unsigned int *)a1 + 21), *((int *)a1 + 119) * (uint64_t)v17);
  if (a1[35])
  {
    int v33 = (int *)a1[35];
    uint64_t v92 = 0;
    memset(v91, 0, sizeof(v91));
    bzero(__b, 0xA00uLL);
    if (*((int *)a1 + 68) <= 0)
    {
      uint64_t v34 = *a1;
      *(_DWORD *)(v34 + 40) = 20;
      *(_DWORD *)(v34 + 48) = 0;
      (*(void (**)(uint64_t *))*a1)(a1);
      int v33 = (int *)a1[35];
    }
    if (v33[5] || v33[6] != 63)
    {
      int v36 = 1;
      *((_DWORD *)a1 + 87) = 1;
      uint64_t v35 = *((unsigned int *)a1 + 23);
      if ((int)v35 >= 1)
      {
        memset(__b, 255, v35 << 8);
        int v36 = 1;
      }
    }
    else
    {
      *((_DWORD *)a1 + 87) = 0;
      uint64_t v35 = *((unsigned int *)a1 + 23);
      if ((int)v35 >= 1) {
        bzero(v91, 4 * v35);
      }
      int v36 = 0;
    }
    if (*((int *)a1 + 68) >= 1)
    {
      uint64_t v84 = v3;
      int v37 = 1;
      char v38 = v33;
      while (1)
      {
        uint64_t v39 = *v38;
        if ((v39 - 5) <= 0xFFFFFFFB
          && (uint64_t v40 = *a1,
              *(_DWORD *)(v40 + 40) = 27,
              *(_DWORD *)(v40 + 48) = v39,
              *(_DWORD *)(*a1 + 52) = 4,
              (*(void (**)(uint64_t *))*a1)(a1),
              (int)v39 < 1))
        {
          int v45 = 0;
        }
        else
        {
          uint64_t v41 = 0;
          do
          {
            int v42 = v38[v41 + 1];
            if (v42 < 0 || v42 >= *((_DWORD *)a1 + 23))
            {
              uint64_t v43 = *a1;
              *(_DWORD *)(v43 + 40) = 20;
              *(_DWORD *)(v43 + 48) = v37;
              (*(void (**)(uint64_t *))*a1)(a1);
            }
            if (v41 && v42 <= v38[(v41 - 1) + 1])
            {
              uint64_t v44 = *a1;
              *(_DWORD *)(v44 + 40) = 20;
              *(_DWORD *)(v44 + 48) = v37;
              (*(void (**)(uint64_t *))*a1)(a1);
            }
            ++v41;
          }
          while (v39 != v41);
          int v45 = 1;
        }
        uint64_t v46 = v38[5];
        int v89 = v38[6];
        unsigned int v47 = v38[7];
        int v48 = v38[8];
        if (!*((_DWORD *)a1 + 87))
        {
          if (__PAIR64__(v89, v46) != 0x3F00000000 || v47 || v48)
          {
            uint64_t v60 = *a1;
            *(_DWORD *)(v60 + 40) = 18;
            *(_DWORD *)(v60 + 48) = v37;
            (*(void (**)(uint64_t *))*a1)(a1);
          }
          if (v45)
          {
            uint64_t v61 = 0;
            do
            {
              uint64_t v62 = v38[v61 + 1];
              if (*((_DWORD *)v91 + v62))
              {
                uint64_t v63 = *a1;
                *(_DWORD *)(v63 + 40) = 20;
                *(_DWORD *)(v63 + 48) = v37;
                (*(void (**)(uint64_t *))*a1)(a1);
              }
              *((_DWORD *)v91 + v62) = 1;
              ++v61;
            }
            while (v39 != v61);
          }
          goto LABEL_123;
        }
        if (v46 > 0x3F
          || v89 < (int)v46
          || v89 > 63
          || (v47 & 0x80000000) != 0
          || (*((int *)a1 + 22) <= 8 ? (int v49 = 10) : (int v49 = 13), v47 > v49 || v48 < 0 || v48 > v49))
        {
          uint64_t v59 = *a1;
          *(_DWORD *)(v59 + 40) = 18;
          *(_DWORD *)(v59 + 48) = v37;
          (*(void (**)(uint64_t *))*a1)(a1);
          if (v46)
          {
LABEL_90:
            if (v39 == 1) {
              goto LABEL_92;
            }
LABEL_91:
            uint64_t v50 = *a1;
            *(_DWORD *)(v50 + 40) = 18;
            *(_DWORD *)(v50 + 48) = v37;
            (*(void (**)(uint64_t *))*a1)(a1);
            goto LABEL_92;
          }
        }
        else if (v46)
        {
          goto LABEL_90;
        }
        if (v89) {
          goto LABEL_91;
        }
LABEL_92:
        if (v45)
        {
          uint64_t v51 = 0;
          int v87 = v89 - v46 + 1;
          int v86 = &__b[v46];
          uint64_t v88 = v38;
          while (1)
          {
            uint64_t v52 = v38[v51 + 1];
            if (v46 && (__b[64 * v52] & 0x80000000) != 0)
            {
              uint64_t v53 = *a1;
              *(_DWORD *)(v53 + 40) = 18;
              *(_DWORD *)(v53 + 48) = v37;
              (*(void (**)(uint64_t *))*a1)(a1);
            }
            uint64_t v54 = v46;
            if ((int)v46 <= v89) {
              break;
            }
LABEL_98:
            ++v51;
            uint64_t v46 = v54;
            char v38 = v88;
            if (v51 == v39) {
              goto LABEL_123;
            }
          }
          uint64_t v55 = (int *)&v86[256 * v52];
          int v56 = v87;
          while (2)
          {
            if (*v55 < 0)
            {
              if (v47) {
                goto LABEL_106;
              }
            }
            else if (v47 != *v55 || v48 != v47 - 1)
            {
LABEL_106:
              uint64_t v58 = *a1;
              *(_DWORD *)(v58 + 40) = 18;
              *(_DWORD *)(v58 + 48) = v37;
              (*(void (**)(uint64_t *))*a1)(a1);
            }
            *v55++ = v48;
            if (!--v56) {
              goto LABEL_98;
            }
            continue;
          }
        }
LABEL_123:
        v38 += 9;
        if (v37++ >= *((_DWORD *)a1 + 68))
        {
          int v36 = *((_DWORD *)a1 + 87);
          LODWORD(v35) = *((_DWORD *)a1 + 23);
          uint64_t v3 = v84;
          break;
        }
      }
    }
    if (v36)
    {
      if ((int)v35 >= 1)
      {
        uint64_t v65 = 0;
        unsigned int v66 = __b;
        do
        {
          if ((*v66 & 0x80000000) != 0)
          {
            uint64_t v67 = *a1;
            *(_DWORD *)(v67 + 40) = 46;
            (*(void (**)(uint64_t *))v67)(a1);
            LODWORD(v35) = *((_DWORD *)a1 + 23);
          }
          v66 += 64;
          ++v65;
        }
        while (v65 < (int)v35);
      }
    }
    else if ((int)v35 >= 1)
    {
      uint64_t v68 = 0;
      do
      {
        if (!*((_DWORD *)v91 + v68))
        {
          uint64_t v69 = *a1;
          *(_DWORD *)(v69 + 40) = 46;
          (*(void (**)(uint64_t *))v69)(a1);
          LODWORD(v35) = *((_DWORD *)a1 + 23);
        }
        ++v68;
      }
      while (v68 < (int)v35);
    }
    if (*((int *)a1 + 119) <= 7)
    {
      if (*((int *)a1 + 68) < 1)
      {
        int v71 = 0;
      }
      else
      {
        uint64_t v70 = 0;
        int v71 = 0;
        float v72 = (long long *)a1[35];
        BOOL v73 = v72;
        do
        {
          if (v70 != v71)
          {
            uint64_t v74 = (uint64_t)v72 + 36 * v71;
            long long v75 = *v73;
            long long v76 = v73[1];
            *(_DWORD *)(v74 + 32) = *((_DWORD *)v73 + 8);
            *(_OWORD *)uint64_t v74 = v75;
            *(_OWORD *)(v74 + 16) = v76;
          }
          int v77 = *((_DWORD *)a1 + 122);
          if (*((_DWORD *)v72 + 9 * v71 + 5) <= v77)
          {
            uint64_t v78 = (uint64_t)v72 + 36 * v71;
            int v80 = *(_DWORD *)(v78 + 24);
            uint64_t v79 = (_DWORD *)(v78 + 24);
            if (v80 > v77) {
              _DWORD *v79 = v77;
            }
            ++v71;
          }
          ++v70;
          BOOL v73 = (long long *)((char *)v73 + 36);
        }
        while (v70 < *((int *)a1 + 68));
      }
      *((_DWORD *)a1 + 68) = v71;
    }
  }
  else
  {
    *((_DWORD *)a1 + 87) = 0;
    *((_DWORD *)a1 + 68) = 1;
  }
  int v81 = *((_DWORD *)a1 + 74);
  if (v81)
  {
    *((_DWORD *)a1 + 73) = 0;
  }
  else if (!*((_DWORD *)a1 + 73) && (*((_DWORD *)a1 + 87) || (*((_DWORD *)a1 + 119) - 2) < 6))
  {
    *((_DWORD *)a1 + 74) = 1;
    int v82 = a2;
    if (!a2) {
      goto LABEL_158;
    }
    goto LABEL_157;
  }
  if (!a2)
  {
    *(_DWORD *)(v3 + 44) = 0;
    *(void *)(v3 + 32) = 0;
    if (v81) {
      goto LABEL_160;
    }
LABEL_162:
    int v83 = *((_DWORD *)a1 + 68);
    goto LABEL_163;
  }
  if (!v81)
  {
    *(_DWORD *)(v3 + 44) = 0;
    *(void *)(v3 + 32) = 2;
    goto LABEL_162;
  }
LABEL_157:
  int v82 = 1;
LABEL_158:
  *(_DWORD *)(v3 + 44) = 0;
  *(_DWORD *)(v3 + 32) = v82;
  *(_DWORD *)(v3 + 36) = 0;
LABEL_160:
  int v83 = 2 * *((_DWORD *)a1 + 68);
LABEL_163:
  *(_DWORD *)(v3 + 40) = v83;
}

uint64_t prepare_for_pass(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 496);
  int v3 = v2[8];
  if (v3 == 2) {
    goto LABEL_16;
  }
  if (v3 == 1)
  {
    select_scan_parameters(a1);
    per_scan_setup(a1);
    if (*(_DWORD *)(a1 + 460) || !*(_DWORD *)(a1 + 468))
    {
      (**(void (***)(uint64_t, uint64_t))(a1 + 560))(a1, 1);
      uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t))(a1 + 520))(a1, 2);
      goto LABEL_21;
    }
    int v7 = v2[9] + 1;
    v2[8] = 2;
    v2[9] = v7;
LABEL_16:
    if (!*(_DWORD *)(a1 + 296))
    {
      select_scan_parameters(a1);
      per_scan_setup(a1);
    }
    (**(void (***)(uint64_t, void))(a1 + 560))(a1, 0);
    (**(void (***)(uint64_t, uint64_t))(a1 + 520))(a1, 2);
    if (!v2[11]) {
      (*(void (**)(uint64_t))(*(void *)(a1 + 528) + 8))(a1);
    }
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 528) + 16))(a1);
    goto LABEL_21;
  }
  if (v3)
  {
    uint64_t v6 = *(void *)a1;
    *(_DWORD *)(v6 + 40) = 49;
    uint64_t result = (*(uint64_t (**)(uint64_t))v6)(a1);
    goto LABEL_22;
  }
  select_scan_parameters(a1);
  per_scan_setup(a1);
  if (!*(_DWORD *)(a1 + 288))
  {
    (**(void (***)(uint64_t))(a1 + 536))(a1);
    (**(void (***)(uint64_t))(a1 + 544))(a1);
    (**(void (***)(uint64_t, void))(a1 + 512))(a1, 0);
  }
  (**(void (***)(uint64_t))(a1 + 552))(a1);
  (**(void (***)(uint64_t, void))(a1 + 560))(a1, *(unsigned int *)(a1 + 296));
  if ((int)v2[10] <= 1) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = 3;
  }
  (**(void (***)(uint64_t, uint64_t))(a1 + 520))(a1, v4);
  uint64_t result = (**(uint64_t (***)(uint64_t, void))(a1 + 504))(a1, 0);
  if (!*(_DWORD *)(a1 + 296))
  {
    v2[6] = 1;
    goto LABEL_22;
  }
LABEL_21:
  v2[6] = 0;
LABEL_22:
  int v8 = v2[9];
  int v9 = v2[10];
  v2[7] = v8 == v9 - 1;
  uint64_t v10 = *(void *)(a1 + 16);
  if (v10)
  {
    *(_DWORD *)(v10 + 24) = v8;
    *(_DWORD *)(v10 + 28) = v9;
  }
  return result;
}

uint64_t pass_startup(uint64_t a1)
{
  *(_DWORD *)(*(void *)(a1 + 496) + 24) = 0;
  (*(void (**)(void))(*(void *)(a1 + 528) + 8))();
  uint64_t v2 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 528) + 16);

  return v2(a1);
}

uint64_t finish_pass_master(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 496);
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 560) + 16))();
  int v4 = v2[8];
  switch(v4)
  {
    case 2:
      if (*(_DWORD *)(a1 + 296)) {
        v2[8] = 1;
      }
LABEL_8:
      ++v2[11];
      break;
    case 1:
      v2[8] = 2;
      break;
    case 0:
      v2[8] = 2;
      if (!*(_DWORD *)(a1 + 296)) {
        goto LABEL_8;
      }
      break;
  }
  ++v2[9];
  return result;
}

uint64_t select_scan_parameters(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void *)(result + 280);
  if (!v2)
  {
    LODWORD(v12) = *(_DWORD *)(result + 92);
    if ((int)v12 >= 5)
    {
      uint64_t v13 = *(void *)result;
      *(_DWORD *)(v13 + 40) = 27;
      *(_DWORD *)(v13 + 48) = v12;
      *(_DWORD *)(*(void *)result + 52) = 4;
      uint64_t result = (**(uint64_t (***)(uint64_t))result)(result);
      LODWORD(v12) = *(_DWORD *)(v1 + 92);
    }
    *(_DWORD *)(v1 + 372) = v12;
    if ((int)v12 >= 1)
    {
      uint64_t v14 = *(void *)(v1 + 104);
      uint64_t v12 = v12;
      int v15 = (void *)(v1 + 376);
      do
      {
        *v15++ = v14;
        v14 += 96;
        --v12;
      }
      while (v12);
    }
    goto LABEL_12;
  }
  int v3 = *(_DWORD *)(*(void *)(result + 496) + 44);
  uint64_t v4 = *(unsigned int *)(v2 + 36 * v3);
  *(_DWORD *)(result + 372) = v4;
  if ((int)v4 >= 1)
  {
    uint64_t v5 = *(void *)(result + 104);
    uint64_t v6 = (int *)(v2 + 36 * v3 + 4);
    int v7 = (void *)(result + 376);
    do
    {
      int v8 = *v6++;
      *v7++ = v5 + 96 * v8;
      --v4;
    }
    while (v4);
  }
  if (!*(_DWORD *)(result + 348))
  {
LABEL_12:
    int v10 = 0;
    *(_DWORD *)(v1 + 460) = 0;
    *(void *)(v1 + 464) = (*(_DWORD *)(v1 + 476) * *(_DWORD *)(v1 + 476) - 1);
    goto LABEL_13;
  }
  uint64_t v9 = v2 + 36 * v3;
  *(void *)(result + 460) = *(void *)(v9 + 20);
  int v11 = *(_DWORD *)(v9 + 28);
  int v10 = *(_DWORD *)(v9 + 32);
  *(_DWORD *)(result + 468) = v11;
LABEL_13:
  *(_DWORD *)(v1 + 472) = v10;
  return result;
}

uint64_t per_scan_setup(uint64_t result)
{
  uint64_t v1 = result;
  int v2 = *(_DWORD *)(result + 372);
  if (v2 == 1)
  {
    uint64_t v3 = *(void *)(result + 376);
    unsigned int v4 = *(_DWORD *)(v3 + 32);
    *(_DWORD *)(result + 408) = *(_DWORD *)(v3 + 28);
    *(_DWORD *)(result + 412) = v4;
    int v5 = *(_DWORD *)(v3 + 36);
    *(_DWORD *)(v3 + 64) = 1;
    *(_DWORD *)(v3 + 68) = v5;
    unsigned int v6 = *(_DWORD *)(v3 + 12);
    int v7 = v4 % v6;
    *(void *)(v3 + 56) = 0x100000001;
    if (!v7) {
      int v7 = v6;
    }
    *(_DWORD *)(v3 + 72) = 1;
    *(_DWORD *)(v3 + 76) = v7;
    *(void *)(result + 416) = 1;
  }
  else
  {
    if ((v2 - 5) <= 0xFFFFFFFB)
    {
      uint64_t v8 = *(void *)result;
      *(_DWORD *)(v8 + 40) = 27;
      *(_DWORD *)(v8 + 48) = v2;
      *(_DWORD *)(*(void *)result + 52) = 4;
      (**(void (***)(uint64_t))result)(result);
    }
    *(_DWORD *)(v1 + 408) = jdiv_round_up(*(unsigned int *)(v1 + 80), *(int *)(v1 + 476) * (uint64_t)*(int *)(v1 + 352));
    uint64_t result = jdiv_round_up(*(unsigned int *)(v1 + 84), *(int *)(v1 + 476) * (uint64_t)*(int *)(v1 + 356));
    *(void *)(v1 + 412) = result;
    if (*(int *)(v1 + 372) >= 1)
    {
      uint64_t v9 = 0;
      do
      {
        int v10 = *(_DWORD **)(v1 + 8 * v9 + 376);
        unsigned int v11 = v10[2];
        unsigned int v12 = v10[3];
        int v13 = v12 * v11;
        unsigned int v14 = v10[8];
        int v15 = v10[9] * v11;
        v10[16] = v12 * v11;
        v10[17] = v15;
        int v16 = v10[7] % v11;
        v10[14] = v11;
        v10[15] = v12;
        if (v16) {
          unsigned int v11 = v16;
        }
        if (v14 % v12) {
          unsigned int v12 = v14 % v12;
        }
        v10[18] = v11;
        v10[19] = v12;
        if (*(_DWORD *)(v1 + 416) + v13 >= 11)
        {
          uint64_t v17 = *(void *)v1;
          *(_DWORD *)(v17 + 40) = 14;
          uint64_t result = (*(uint64_t (**)(uint64_t))v17)(v1);
        }
        if (v13 >= 1)
        {
          unsigned int v18 = v13 + 1;
          do
          {
            uint64_t v19 = *(int *)(v1 + 416);
            *(_DWORD *)(v1 + 416) = v19 + 1;
            *(_DWORD *)(v1 + 4 * v19 + 420) = v9;
            --v18;
          }
          while (v18 > 1);
        }
        ++v9;
      }
      while (v9 < *(int *)(v1 + 372));
    }
  }
  int v20 = *(_DWORD *)(v1 + 320);
  if (v20 >= 1)
  {
    unint64_t v21 = *(unsigned int *)(v1 + 408) * (unint64_t)v20;
    if (v21 >= 0xFFFF) {
      LODWORD(v21) = 0xFFFF;
    }
    *(_DWORD *)(v1 + 316) = v21;
  }
  return result;
}

void kdrc_overlay::~kdrc_overlay(kdrc_overlay *this)
{
  *(void *)this = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  uint64_t v2 = *((void *)this + 13);
  uint64_t v3 = *((void *)this + 16);
  if (!v2)
  {
    *((void *)this + 15) = 0;
    goto LABEL_6;
  }
  do
  {
    uint64_t v4 = v2;
    uint64_t v2 = *(void *)(v2 + 24);
    *(void *)(v4 + 24) = v3;
    uint64_t v3 = v4;
  }
  while (v2);
  *((void *)this + 14) = v4;
  *((void *)this + 15) = 0;
  uint64_t v3 = v4;
  *((void *)this + 13) = 0;
  do
  {
    *((void *)this + 16) = *(void *)(v3 + 24);
    MEMORY[0x18C11C0E0]();
    uint64_t v3 = *((void *)this + 16);
LABEL_6:
    *((void *)this + 14) = v3;
  }
  while (v3);
}

uint64_t kdrc_overlay::set_geometry(uint64_t result, uint64_t a2, uint64_t a3, int a4, int a5, int a6, unint64_t a7, unint64_t a8, unint64_t a9)
{
  unint64_t v9 = HIDWORD(a7);
  unint64_t v10 = HIDWORD(a8);
  if (*(void *)(result + 24) != a2
    || *(void *)(result + 32) != a3
    || *(unsigned __int8 *)(result + 40) != a4
    || *(unsigned __int8 *)(result + 41) != a5
    || *(unsigned __int8 *)(result + 42) != a6
    || *(void *)(result + 44) != a7
    || *(_OWORD *)(result + 52) != __PAIR128__(a9, a8))
  {
    *(void *)(result + 24) = a2;
    *(void *)(result + 32) = a3;
    *(unsigned char *)(result + 40) = a4;
    *(unsigned char *)(result + 41) = a5;
    *(unsigned char *)(result + 42) = a6;
    *(void *)(result + 44) = a7;
    *(void *)(result + 52) = a8;
    *(void *)(result + 60) = a9;
    if (a4) {
      LODWORD(v11) = a8;
    }
    else {
      unint64_t v11 = HIDWORD(a8);
    }
    if (a4)
    {
      unint64_t v12 = HIDWORD(a7);
    }
    else
    {
      LODWORD(v10) = a8;
      LODWORD(v12) = a7;
    }
    if (a4) {
      LODWORD(v9) = a7;
    }
    uint64_t v13 = *(int *)(result + 20);
    uint64_t v14 = (int)v11 * (uint64_t)SHIDWORD(a3) * v13 / (int)v9;
    if ((int)v14 >= (int)((int)v10 * (uint64_t)(int)a3 * v13 / (int)v12)) {
      LODWORD(v14) = (int)v10 * (uint64_t)(int)a3 * v13 / (int)v12;
    }
    *(_DWORD *)(result + 68) = v14;
    uint64_t v15 = *(void *)(result + 104);
    if (v15)
    {
      uint64_t v16 = *(void *)(result + 128);
      do
      {
        uint64_t v17 = v15;
        uint64_t v15 = *(void *)(v15 + 24);
        *(void *)(v17 + 24) = v16;
        uint64_t v16 = v17;
      }
      while (v15);
      *(void *)(result + 104) = 0;
      *(void *)(result + 128) = v17;
    }
    *(void *)(result + 80) = 0;
    *(void *)(result + 88) = 0;
    *(void *)(result + 112) = 0;
    *(void *)(result + 120) = 0;
  }
  return result;
}

BOOL kdrc_overlay::set_buffer_surface(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  *(void *)&long long v41 = a3;
  *((void *)&v41 + 1) = a4;
  if (!*(void *)a1) {
    kdrc_overlay::set_buffer_surface();
  }
  if (*(int *)(a1 + 48) < 1 || *(int *)(a1 + 44) < 1 || *(int *)(a1 + 56) < 1 || *(int *)(a1 + 52) <= 0) {
    kdrc_overlay::set_buffer_surface();
  }
  long long v40 = *(_OWORD *)(a1 + 72);
  kdu_dims::operator&=(&v40, (int *)&v41);
  *(void *)(a1 + 88) = a2;
  *(_OWORD *)(a1 + 72) = v41;
  int v8 = HIDWORD(v40) + DWORD1(v40);
  int v9 = DWORD2(v40) + v40;
  unint64_t v10 = DWORD1(v41);
  int v11 = HIDWORD(v41) + DWORD1(v41);
  int v12 = DWORD2(v41) + v41;
  if (DWORD1(v40) == DWORD1(v41) && v11 == v8)
  {
    if (v12 > (int)v40 && v12 <= v9)
    {
      unint64_t v10 = DWORD1(v40);
      unsigned int v13 = v41;
      int v9 = v40;
      goto LABEL_21;
    }
    if (v9 <= (int)v41 || (v10 = DWORD1(v40), v13 = DWORD2(v40) + v40, int v9 = DWORD2(v41) + v41, (int)v40 > (int)v41))
    {
LABEL_36:
      unint64_t v38 = v41;
      unint64_t v39 = DWORD2(v41) | ((unint64_t)HIDWORD(v41) << 32);
      uint64_t v21 = *(void *)(a1 + 104);
      if (v21)
      {
        uint64_t v22 = *(void *)(a1 + 128);
        do
        {
          uint64_t v23 = v21;
          uint64_t v21 = *(void *)(v21 + 24);
          *(void *)(v23 + 24) = v22;
          uint64_t v22 = v23;
        }
        while (v21);
        *(void *)(a1 + 104) = 0;
        *(void *)(a1 + 128) = v23;
      }
      *(void *)(a1 + 112) = 0;
      goto LABEL_41;
    }
  }
  else
  {
    if (v40 != v41 || v12 != v9) {
      goto LABEL_36;
    }
    if (v11 <= SDWORD1(v40) || v11 > v8)
    {
      if (v8 <= SDWORD1(v41)) {
        goto LABEL_36;
      }
      unsigned int v13 = v40;
      unint64_t v10 = (HIDWORD(v40) + DWORD1(v40));
      int v8 = HIDWORD(v41) + DWORD1(v41);
      if (SDWORD1(v40) > SDWORD1(v41)) {
        goto LABEL_36;
      }
    }
    else
    {
      unsigned int v13 = v40;
      int v8 = DWORD1(v40);
    }
  }
LABEL_21:
  unint64_t v38 = v13 | (v10 << 32);
  unint64_t v39 = (v9 - v13) | ((unint64_t)(v8 - v10) << 32);
  uint64_t v14 = (void *)(a1 + 104);
  uint64_t v15 = *(void *)(a1 + 104);
  if (!v15)
  {
LABEL_41:
    *(void *)(a1 + 120) = 0;
    uint64_t v14 = (void *)(a1 + 104);
    goto LABEL_42;
  }
  uint64_t v16 = 0;
  do
  {
    uint64_t v17 = *(void *)(v15 + 24);
    if (kdu_dims::intersects((_DWORD *)(v15 + 8), &v41) && !kdu_dims::intersects((_DWORD *)(v15 + 8), &v38))
    {
      uint64_t v16 = v15;
    }
    else
    {
      unsigned int v18 = (void *)(v16 + 24);
      if (!v16) {
        unsigned int v18 = (void *)(a1 + 104);
      }
      *unsigned int v18 = v17;
      if (v15 == *(void *)(a1 + 112))
      {
        if (v17) {
          kdrc_overlay::set_buffer_surface();
        }
        *(void *)(a1 + 112) = v16;
      }
      *(void *)(v15 + 24) = *(void *)(a1 + 128);
      *(void *)(a1 + 128) = v15;
    }
    uint64_t v15 = v17;
  }
  while (v17);
  uint64_t v19 = *(void **)(a1 + 104);
  *(void *)(a1 + 120) = 0;
  if (!v19)
  {
LABEL_42:
    uint64_t v19 = 0;
    int v24 = 0;
    uint64_t v20 = *(void *)(a1 + 112);
    if (!v20) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }
  uint64_t v20 = *(void *)(a1 + 112);
  if (!v20) {
LABEL_73:
  }
    kdrc_overlay::set_buffer_surface();
LABEL_43:
  int v24 = v19;
  if (*(void *)(v20 + 24)) {
    goto LABEL_73;
  }
LABEL_44:
  uint64_t v25 = &v38;
  if (a5) {
    uint64_t v25 = (unint64_t *)&v41;
  }
  long long v37 = *(_OWORD *)v25;
  if (SHIDWORD(v37) >= 1 && SDWORD2(v37) >= 1)
  {
    kdrc_overlay::map_from_compositing_grid((kdrc_overlay *)a1, (int32x2_t *)&v37);
    uint64_t v36 = 0;
    jpx_meta_manager::load_matches((jpx_meta_manager *)(a1 + 8), 1, (int *)(a1 + 16), 0, 0);
    for (uint64_t i = 0; ; uint64_t i = v36)
    {
      uint64_t v36 = jpx_meta_manager::enumerate_matches((uint64_t *)(a1 + 8), i, *(unsigned int *)(a1 + 16), 0xFFFFFFFFLL, 0, v37, *((uint64_t *)&v37 + 1), *(unsigned int *)(a1 + 68), 0);
      if (!v36)
      {
        int v24 = (void *)*v14;
        return v24 != 0;
      }
      long long v35 = 0uLL;
      *(void *)&long long v35 = jpx_metanode::get_bounding_box((jpx_metanode *)&v36);
      *((void *)&v35 + 1) = v27;
      kdrc_overlay::map_to_compositing_grid((int32x2_t *)a1, (int32x2_t *)&v35);
      if (kdu_dims::intersects(&v35, &v38)) {
        goto LABEL_51;
      }
      if (!kdu_dims::intersects(&v35, &v41)) {
        continue;
      }
      int v31 = (void *)*v14;
      if (!*v14)
      {
LABEL_51:
        int v28 = *(_DWORD *)(a1 + 20);
        if (SHIDWORD(v35) >= v28 || SDWORD2(v35) >= v28)
        {
          uint64_t v30 = *(void *)(a1 + 128);
          if (!v30) {
            operator new();
          }
          *(void *)(a1 + 128) = *(void *)(v30 + 24);
          *(void *)(v30 + 24) = 0;
          uint64_t v32 = *(void *)(a1 + 112);
          if (v32) {
            int v33 = (void *)(v32 + 24);
          }
          else {
            int v33 = v14;
          }
          void *v33 = v30;
          *(void *)(a1 + 112) = v30;
          *(void *)uint64_t v30 = v36;
          *(_OWORD *)(v30 + 8) = v35;
          *(unsigned char *)(v30 + 32) = 0;
        }
      }
      else
      {
        while (*v31 != v36)
        {
          int v31 = (void *)v31[3];
          if (!v31) {
            goto LABEL_51;
          }
        }
      }
    }
  }
  return v24 != 0;
}

int32x2_t kdrc_overlay::map_from_compositing_grid(kdrc_overlay *this, int32x2_t *a2)
{
  int32x2_t v4 = vadd_s32(*a2, *(int32x2_t *)((char *)this + 60));
  *a2 = v4;
  uint64_t v5 = *((int *)this + 14);
  unint64_t v6 = v4.i32[1] * (uint64_t)(int)v5;
  int v7 = *((_DWORD *)this + 12);
  if (v7 <= 1) {
    unint64_t v8 = 1;
  }
  else {
    unint64_t v8 = v7;
  }
  if ((v6 & 0x8000000000000000) != 0)
  {
    unint64_t v9 = ~v6 / v8;
    if (v9 >> 31) {
      kdrc_overlay::map_from_compositing_grid();
    }
    LODWORD(v9) = ~v9;
  }
  else
  {
    unint64_t v9 = v6 / v8;
    if (v9 >> 31) {
      kdrc_overlay::map_from_compositing_grid();
    }
  }
  uint64_t v10 = *((int *)this + 13);
  unint64_t v11 = v4.i32[0] * (uint64_t)(int)v10;
  LODWORD(v12) = *((_DWORD *)this + 11);
  if ((int)v12 <= 1) {
    unint64_t v12 = 1;
  }
  else {
    unint64_t v12 = v12;
  }
  if ((v11 & 0x8000000000000000) != 0)
  {
    unint64_t v13 = ~v11 / v12;
    if (v13 >> 31) {
      kdrc_overlay::map_from_compositing_grid();
    }
    LODWORD(v13) = ~v13;
  }
  else
  {
    unint64_t v13 = v11 / v12;
    if (v13 >> 31) {
      kdrc_overlay::map_from_compositing_grid();
    }
  }
  uint64_t v14 = (a2[1].i32[1] + (uint64_t)v4.i32[1]) * v5;
  if (v14 <= 0)
  {
    unint64_t v16 = -v14 / v8;
    if (v16 >= 0x80000001) {
      goto LABEL_30;
    }
    unint64_t v15 = -(uint64_t)v16;
  }
  else
  {
    unint64_t v15 = (v14 - 1) / v8;
    if (v15 >= 0x7FFFFFFF) {
      goto LABEL_30;
    }
    LODWORD(v15) = v15 + 1;
  }
  uint64_t v17 = v10 * (a2[1].i32[0] + (uint64_t)v4.i32[0]);
  if (v17 <= 0)
  {
    unint64_t v19 = -v17 / v12;
    if (v19 < 0x80000001)
    {
      unint64_t v18 = -(uint64_t)v19;
      goto LABEL_27;
    }
LABEL_30:
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  unint64_t v18 = (v17 - 1) / v12;
  if (v18 >= 0x7FFFFFFF) {
    goto LABEL_30;
  }
  LODWORD(v18) = v18 + 1;
LABEL_27:
  *a2 = (int32x2_t)(v13 | ((unint64_t)v9 << 32));
  a2[1] = (int32x2_t)((v18 - v13) | ((unint64_t)(v15 - v9) << 32));
  kdu_dims::from_apparent((int32x4_t *)a2, *((unsigned __int8 *)this + 40), *((unsigned __int8 *)this + 41), *((unsigned __int8 *)this + 42));
  int32x2_t v20 = *(int32x2_t *)((char *)this + 32);
  int32x2_t v21 = vmul_s32(*a2, v20);
  int32x2_t result = vmul_s32(a2[1], v20);
  *a2 = v21;
  a2[1] = result;
  int v23 = v21.i32[1] - *((_DWORD *)this + 7);
  a2->i32[0] = v21.i32[0] - *((_DWORD *)this + 6);
  a2->i32[1] = v23;
  return result;
}

int32x4_t *kdrc_overlay::map_to_compositing_grid(int32x2_t *this, int32x2_t *a2)
{
  uint64_t v4 = (uint64_t)vadd_s32(*a2, this[3]);
  *a2 = (int32x2_t)v4;
  if (this[4].i32[1] <= 1) {
    unsigned int v5 = 1;
  }
  else {
    unsigned int v5 = this[4].u32[1];
  }
  if (v4 <= 0) {
    uint64_t v6 = -(int)(-HIDWORD(v4) / v5);
  }
  else {
    uint64_t v6 = (HIDWORD(v4) - 1) / v5 + 1;
  }
  int v7 = a2[1].i32[1] + HIDWORD(v4);
  if (this[4].i32[0] <= 1) {
    unsigned int v8 = 1;
  }
  else {
    unsigned int v8 = this[4].u32[0];
  }
  if ((int)v4 <= 0) {
    unsigned int v9 = -(int)(-(int)v4 / v8);
  }
  else {
    unsigned int v9 = ((int)v4 - 1) / v8 + 1;
  }
  int v10 = a2[1].i32[0] + v4;
  if (v7 <= 0) {
    unsigned int v11 = -(int)(-v7 / v5);
  }
  else {
    unsigned int v11 = (v7 - 1) / v5 + 1;
  }
  if (v10 <= 0) {
    unsigned int v12 = -(int)(-v10 / v8);
  }
  else {
    unsigned int v12 = (v10 - 1) / v8 + 1;
  }
  *a2 = (int32x2_t)(v9 | (unint64_t)(v6 << 32));
  a2[1] = (int32x2_t)((v12 - v9) | ((unint64_t)(v11 - v6) << 32));
  int32x2_t result = kdu_dims::to_apparent((int32x4_t *)a2, this[5].u8[0], this[5].u8[1], this[5].u8[2]);
  uint64_t v14 = (uint64_t)*a2;
  uint64_t v15 = this[6].i32[0];
  unint64_t v16 = (int)HIDWORD(*(unint64_t *)a2) * (uint64_t)(int)v15;
  int v17 = this[7].i32[0];
  if (v17 <= 1) {
    unint64_t v18 = 1;
  }
  else {
    unint64_t v18 = v17;
  }
  if ((v16 & 0x8000000000000000) != 0)
  {
    unint64_t v19 = ~v16 / v18;
    if (v19 >> 31) {
      kdrc_overlay::map_from_compositing_grid();
    }
    LODWORD(v19) = ~v19;
  }
  else
  {
    unint64_t v19 = v16 / v18;
    if (v19 >> 31) {
      kdrc_overlay::map_from_compositing_grid();
    }
  }
  uint64_t v20 = this[5].i32[1];
  unint64_t v21 = (int)v14 * (uint64_t)(int)v20;
  LODWORD(v22) = this[6].i32[1];
  if ((int)v22 <= 1) {
    unint64_t v22 = 1;
  }
  else {
    unint64_t v22 = v22;
  }
  if ((v21 & 0x8000000000000000) != 0)
  {
    unint64_t v23 = ~v21 / v22;
    if (v23 >> 31) {
      kdrc_overlay::map_from_compositing_grid();
    }
    LODWORD(v23) = ~v23;
  }
  else
  {
    unint64_t v23 = v21 / v22;
    if (v23 >> 31) {
      kdrc_overlay::map_from_compositing_grid();
    }
  }
  uint64_t v24 = (a2[1].i32[1] + (v14 >> 32)) * v15;
  if (v24 <= 0)
  {
    unint64_t v26 = -v24 / v18;
    if (v26 >= 0x80000001) {
      goto LABEL_48;
    }
    unint64_t v25 = -(uint64_t)v26;
  }
  else
  {
    unint64_t v25 = (v24 - 1) / v18;
    if (v25 >= 0x7FFFFFFF) {
      goto LABEL_48;
    }
    LODWORD(v25) = v25 + 1;
  }
  uint64_t v27 = v20 * (a2[1].i32[0] + (uint64_t)(int)v14);
  if (v27 <= 0)
  {
    unint64_t v29 = -v27 / v22;
    if (v29 < 0x80000001)
    {
      unint64_t v28 = -(uint64_t)v29;
      goto LABEL_45;
    }
LABEL_48:
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  unint64_t v28 = (v27 - 1) / v22;
  if (v28 >= 0x7FFFFFFF) {
    goto LABEL_48;
  }
  LODWORD(v28) = v28 + 1;
LABEL_45:
  *a2 = (int32x2_t)(v23 | ((unint64_t)v19 << 32));
  a2[1] = (int32x2_t)((v28 - v23) | ((unint64_t)(v25 - v19) << 32));
  __int32 v30 = v19 - this[8].i32[0];
  a2->i32[0] = v23 - this[7].i32[1];
  a2->i32[1] = v30;
  return result;
}

uint64_t kdrc_overlay::update_config(kdrc_overlay *this, int a2, int a3)
{
  if (a2 <= 1) {
    uint64_t v3 = 1;
  }
  else {
    uint64_t v3 = a2;
  }
  int v4 = *((_DWORD *)this + 24);
  int v5 = *((_DWORD *)this + 5);
  if (v4 == a3 && v3 == v5) {
    return 0;
  }
  *((_DWORD *)this + 24) = a3;
  BOOL v8 = (int)v3 < v5 && *((int *)this + 21) >= 1 && *((_DWORD *)this + 20) > 0;
  *((_DWORD *)this + 5) = v3;
  if (!*((_DWORD *)this + 12) || !*((_DWORD *)this + 11) || !*((_DWORD *)this + 14) || !*((_DWORD *)this + 13)) {
    return 0;
  }
  unint64_t v9 = *(void *)((char *)this + 44);
  unint64_t v10 = *(void *)((char *)this + 52);
  if (*((unsigned char *)this + 40)) {
    unint64_t v11 = *(void *)((char *)this + 44);
  }
  else {
    unint64_t v11 = HIDWORD(v9);
  }
  if (*((unsigned char *)this + 40))
  {
    v9 >>= 32;
    unint64_t v12 = *(void *)((char *)this + 52);
  }
  else
  {
    unint64_t v12 = HIDWORD(v10);
  }
  if (*((unsigned char *)this + 40)) {
    v10 >>= 32;
  }
  uint64_t v13 = *((int *)this + 8);
  uint64_t v14 = (int)v12 * v3 * *((int *)this + 9) / (int)v11;
  *((_DWORD *)this + 17) = v14;
  uint64_t v15 = (int)v10 * v3 * v13 / (int)v9;
  if ((int)v14 > (int)v15) {
    *((_DWORD *)this + 17) = v15;
  }
  int v17 = (uint64_t *)((char *)this + 104);
  uint64_t v16 = *((void *)this + 13);
  *((void *)this + 15) = 0;
  if (v16)
  {
    uint64_t v18 = 0;
    char v19 = 0;
    do
    {
      while (1)
      {
        uint64_t v20 = v16;
        if (v4 != a3) {
          *(unsigned char *)(v16 + 32) = 0;
        }
        uint64_t v16 = *(void *)(v16 + 24);
        if (*(_DWORD *)(v20 + 20) < (int)v3 && *(_DWORD *)(v20 + 16) < (int)v3) {
          break;
        }
        uint64_t v18 = v20;
        if (!v16) {
          goto LABEL_40;
        }
      }
      unint64_t v21 = (void *)(v18 + 24);
      if (!v18) {
        unint64_t v21 = (void *)((char *)this + 104);
      }
      *unint64_t v21 = v16;
      if (!v16)
      {
        if (v20 != *((void *)this + 14)) {
          kdrc_overlay::update_config();
        }
        *((void *)this + 14) = v18;
      }
      *(void *)(v20 + 24) = *((void *)this + 16);
      *((void *)this + 16) = v20;
      char v19 = 1;
    }
    while (v16);
LABEL_40:
    if (v8)
    {
      uint64_t v22 = *v17;
      if (*v17)
      {
        uint64_t v23 = *((void *)this + 16);
        do
        {
          uint64_t v24 = v22;
          uint64_t v22 = *(void *)(v22 + 24);
          *(void *)(v24 + 24) = v23;
          uint64_t v23 = v24;
        }
        while (v22);
        *((void *)this + 13) = 0;
        *((void *)this + 16) = v24;
      }
      goto LABEL_46;
    }
    if (v19)
    {
      uint64_t v32 = *v17;
      if (!*v17) {
        return 1;
      }
      uint64_t result = 1;
      do
      {
        *(unsigned char *)(v32 + 32) = 0;
        uint64_t v32 = *(void *)(v32 + 24);
      }
      while (v32);
      return result;
    }
    return 0;
  }
  if (!v8) {
    return 0;
  }
LABEL_46:
  *((void *)this + 14) = 0;
  long long v35 = *(_OWORD *)((char *)this + 72);
  kdrc_overlay::map_from_compositing_grid(this, (int32x2_t *)&v35);
  uint64_t v34 = 0;
  jpx_meta_manager::load_matches((kdrc_overlay *)((char *)this + 8), 1, (int *)this + 4, 0, 0);
  for (uint64_t i = 0; ; uint64_t i = v34)
  {
    uint64_t result = jpx_meta_manager::enumerate_matches((uint64_t *)this + 1, i, *((unsigned int *)this + 4), 0xFFFFFFFFLL, 0, v35, *((uint64_t *)&v35 + 1), *((unsigned int *)this + 17), 0);
    uint64_t v34 = result;
    if (!result) {
      break;
    }
    long long v33 = 0uLL;
    *(void *)&long long v33 = jpx_metanode::get_bounding_box((jpx_metanode *)&v34);
    *((void *)&v33 + 1) = v27;
    kdrc_overlay::map_to_compositing_grid((int32x2_t *)this, (int32x2_t *)&v33);
    if (kdu_dims::intersects(&v33, (_DWORD *)this + 18))
    {
      int v28 = *((_DWORD *)this + 5);
      if (SHIDWORD(v33) >= v28 || SDWORD2(v33) >= v28)
      {
        uint64_t v29 = *((void *)this + 16);
        if (!v29) {
          operator new();
        }
        *((void *)this + 16) = *(void *)(v29 + 24);
        *(void *)(v29 + 24) = 0;
        uint64_t v30 = *((void *)this + 14);
        if (v30) {
          int v31 = (void *)(v30 + 24);
        }
        else {
          int v31 = (void *)((char *)this + 104);
        }
        void *v31 = v29;
        *((void *)this + 14) = v29;
        *(void *)uint64_t v29 = v34;
        *(_OWORD *)(v29 + 8) = v33;
        *(unsigned char *)(v29 + 32) = 0;
      }
    }
  }
  return result;
}

uint64_t kdrc_overlay::process(kdrc_overlay *this, kdu_dims *a2)
{
  uint64_t v3 = *((void *)this + 11);
  if (!v3) {
    return 0;
  }
  uint64_t v5 = *((void *)this + 15);
  if (v5 == *((void *)this + 14)) {
    return 0;
  }
  if (!v5)
  {
    uint64_t v5 = *((void *)this + 13);
    *((void *)this + 15) = v5;
  }
  while (1)
  {
    if (*(unsigned char *)(v5 + 32))
    {
      uint64_t v6 = *(void *)(v5 + 24);
      if (!v6) {
        return 0;
      }
      goto LABEL_11;
    }
    if (*(_DWORD *)(v5 + 20) < *((_DWORD *)this + 21)) {
      goto LABEL_13;
    }
    int v7 = *(_DWORD *)(v5 + 16);
    int v8 = *((_DWORD *)this + 20);
    uint64_t v6 = *(void *)(v5 + 24);
    if (!v6) {
      break;
    }
    if (v7 < v8) {
      goto LABEL_13;
    }
LABEL_11:
    *((void *)this + 15) = v6;
    uint64_t v5 = v6;
  }
  if (v7 >= v8) {
    return 0;
  }
LABEL_13:
  unint64_t v9 = (int *)((char *)this + 72);
  if (((*(uint64_t (**)(void, uint64_t, void, void, void, void, void))(**(void **)this + 40))(*(void *)this, v3, *((void *)this + 9), *((void *)this + 10), *(void *)(v5 + 8), *(void *)(v5 + 16), *((unsigned int *)this + 4)) & 1) == 0)
  {
    *(_WORD *)((char *)&v13 + 1) = *(_WORD *)((char *)this + 41);
    LOBYTE(v13) = *((unsigned char *)this + 40);
    (*(void (**)(void, void, void, void, void, void, void, void, _DWORD, void, void, int, void, void, void))(**(void **)this + 48))(*(void *)this, *((void *)this + 11), *((void *)this + 9), *((void *)this + 10), *(void *)(*((void *)this + 15) + 8), *(void *)(*((void *)this + 15) + 16), *((unsigned int *)this + 4), **((void **)this + 15), *((_DWORD *)this + 24), *((void *)this + 3), *((void *)this + 4), v13, *(void *)((char *)this + 44), *(void *)((char *)this + 52), *(void *)((char *)this + 60));
  }
  uint64_t v10 = *((void *)this + 15);
  uint64_t v11 = 1;
  *(unsigned char *)(v10 + 32) = 1;
  long long v14 = *(_OWORD *)(v10 + 8);
  kdu_dims::operator&=(&v14, v9);
  *(_OWORD *)a2 = v14;
  return v11;
}

int32x4_t kdu_dims::from_apparent(int32x4_t *this, int a2, int a3, int a4)
{
  if (a4)
  {
    this->i32[1] = 1 - (this->i32[1] + this->i32[3]);
    if (!a3)
    {
LABEL_3:
      if (!a2) {
        return result;
      }
LABEL_7:
      int32x4_t result = vrev64q_s32(*this);
      *this = result;
      return result;
    }
  }
  else if (!a3)
  {
    goto LABEL_3;
  }
  this->i32[0] = 1 - (this->i32[0] + this->i32[2]);
  if (a2) {
    goto LABEL_7;
  }
  return result;
}

void kdrc_codestream::init(kdrc_codestream *this, kdu_compressed_source *a2)
{
  if (!*((void *)this + 36)) {
    kdu_codestream::create((kdrc_codestream *)((char *)this + 288), a2);
  }
  kdrc_codestream::init();
}

void kdrc_codestream::init(uint64_t a1, jx_codestream_source *a2)
{
  int v4 = a2;
  if (!*(void *)(a1 + 288))
  {
    uint64_t v2 = (kdu_codestream *)(a1 + 288);
    uint64_t v3 = (kdu_compressed_source *)(a1 + 8);
    jpx_codestream_source::open_stream(&v4, (jpx_input_box *)(a1 + 8));
    kdu_codestream::create(v2, v3);
  }
  kdrc_codestream::init();
}

void kdrc_codestream::init(kdrc_codestream *this, mj2_video_source *a2, uint64_t a3, uint64_t a4)
{
  if (!*((void *)this + 36))
  {
    int v7 = (kdrc_codestream *)((char *)this + 288);
    (*(void (**)(mj2_video_source *, uint64_t))(*(void *)a2 + 104))(a2, a3);
    (*(void (**)(mj2_video_source *, uint64_t, char *))(*(void *)a2 + 168))(a2, a4, (char *)this + 8);
    kdu_codestream::create(v7, (kdrc_codestream *)((char *)this + 8));
  }
  kdrc_codestream::init();
}

void kdrc_codestream::restart(kdrc_codestream *this, mj2_video_source *a2, uint64_t a3, uint64_t a4)
{
  if (*((void *)this + 36))
  {
    int v7 = (kdrc_codestream *)((char *)this + 288);
    int v8 = (kdrc_codestream *)((char *)this + 8);
    jpx_input_box::close((kdrc_codestream *)((char *)this + 8));
    (*(void (**)(mj2_video_source *, uint64_t))(*(void *)a2 + 104))(a2, a3);
    (*(void (**)(mj2_video_source *, uint64_t, kdu_compressed_source *))(*(void *)a2 + 168))(a2, a4, v8);
    kdu_codestream::restart(v7, v8);
  }
  kdrc_codestream::restart();
}

uint64_t kdrc_codestream::attach(kdrc_codestream *this, kdrc_stream *a2)
{
  if (*((void *)a2 + 142)) {
    kdrc_codestream::attach();
  }
  uint64_t v3 = *((void *)this + 40);
  *((void *)a2 + 143) = v3;
  *((void *)a2 + 144) = 0;
  if (v3)
  {
    if (*(void *)(v3 + 1152)) {
      kdrc_codestream::attach();
    }
    *(void *)(v3 + 1152) = a2;
    *((void *)this + 40) = a2;
    *((void *)a2 + 142) = this;
    do
    {
      if (*(unsigned char *)(v3 + 1068))
      {
        kdu_region_decompressor::finish((kdu_region_decompressor *)(v3 + 120));
        *(unsigned char *)(*(void *)(v3 + 1136) + 296) = 0;
        *(unsigned char *)(v3 + 1068) = 0;
      }
      uint64_t v3 = *(void *)(v3 + 1144);
    }
    while (v3);
  }
  else
  {
    *((void *)this + 40) = a2;
    *((void *)a2 + 142) = this;
  }
  if (*((unsigned char *)this + 296)) {
    kdrc_codestream::attach();
  }
  int v4 = (uint64_t *)((char *)this + 288);
  kdu_codestream::change_appearance(v4, 0, 0, 0);

  return kdu_codestream::apply_input_restrictions((uint64_t)v4, 0, 0, 0, 0, 0, 0);
}

double kdrc_codestream::detach(kdrc_codestream *this, kdrc_codestream **a2)
{
  if (a2[142] != this) {
    kdrc_codestream::detach();
  }
  uint64_t v2 = a2[144];
  uint64_t v3 = (kdrc_stream *)*((void *)this + 40);
  if (!v2)
  {
    if (v3 != (kdrc_stream *)a2) {
      kdrc_codestream::detach();
    }
    int v4 = a2[143];
    *((void *)this + 40) = v4;
    if (!v4)
    {
      a2[142] = 0;
      a2[143] = 0;
      a2[144] = 0;
LABEL_13:
      kdrc_codestream::~kdrc_codestream(this);
      JUMPOUT(0x18C11C0E0);
    }
    *((void *)v4 + 144) = 0;
    uint64_t v3 = v4;
    goto LABEL_9;
  }
  if (v3 == (kdrc_stream *)a2) {
    kdrc_codestream::detach();
  }
  *((void *)v2 + 143) = a2[143];
  int v4 = a2[143];
  if (v4) {
LABEL_9:
  }
    *((void *)v4 + 144) = a2[144];
  double result = 0.0;
  *((_OWORD *)a2 + 71) = 0u;
  a2[144] = 0;
  if (!v3) {
    goto LABEL_13;
  }
  return result;
}

uint64_t kdrc_codestream::move_to_head(uint64_t this, kdrc_stream *a2)
{
  if (*((void *)a2 + 142) != this) {
    kdrc_codestream::move_to_head();
  }
  uint64_t v2 = a2;
  uint64_t v3 = this;
  uint64_t v4 = *((void *)a2 + 144);
  uint64_t v5 = *(kdrc_stream **)(this + 320);
  if (v4)
  {
    if (v5 == a2) {
      kdrc_codestream::move_to_head();
    }
    *(void *)(v4 + 1144) = *((void *)a2 + 143);
    uint64_t v6 = (kdrc_stream *)*((void *)a2 + 143);
    if (!v6) {
      goto LABEL_10;
    }
  }
  else
  {
    if (v5 != a2) {
      kdrc_codestream::move_to_head();
    }
    uint64_t v6 = (kdrc_stream *)*((void *)a2 + 143);
    *(void *)(this + 320) = v6;
    if (!v6)
    {
      *((void *)a2 + 143) = 0;
      *((void *)a2 + 144) = 0;
      goto LABEL_14;
    }
    *((void *)v6 + 144) = 0;
    uint64_t v5 = v6;
  }
  *((void *)v6 + 144) = *((void *)a2 + 144);
LABEL_10:
  *((void *)a2 + 143) = v5;
  *((void *)a2 + 144) = 0;
  if (v5)
  {
    if (*((void *)v5 + 144)) {
      kdrc_codestream::move_to_head();
    }
    *((void *)v5 + 144) = a2;
  }
LABEL_14:
  *(void *)(this + 320) = a2;
  do
  {
    if (*((unsigned char *)v2 + 1068))
    {
      this = kdu_region_decompressor::finish((kdrc_stream *)((char *)v2 + 120));
      *(unsigned char *)(*((void *)v2 + 142) + 296) = 0;
      *((unsigned char *)v2 + 1068) = 0;
    }
    uint64_t v2 = (kdrc_stream *)*((void *)v2 + 143);
  }
  while (v2);
  if (*(unsigned char *)(v3 + 296)) {
    kdrc_codestream::move_to_head();
  }
  return this;
}

uint64_t kdrc_codestream::move_to_tail(uint64_t this, kdrc_stream *a2)
{
  if (*((void *)a2 + 142) != this) {
    kdrc_codestream::move_to_tail();
  }
  uint64_t v2 = a2;
  uint64_t v3 = this;
  uint64_t v4 = *((void *)a2 + 144);
  uint64_t v5 = (kdrc_stream **)(this + 320);
  uint64_t v6 = *(kdrc_stream **)(this + 320);
  if (v4)
  {
    if (v6 == a2) {
      kdrc_codestream::move_to_tail();
    }
    *(void *)(v4 + 1144) = *((void *)a2 + 143);
    int v7 = (kdrc_stream *)*((void *)a2 + 143);
    if (!v7) {
      goto LABEL_11;
    }
LABEL_10:
    *((void *)v7 + 144) = *((void *)a2 + 144);
    goto LABEL_11;
  }
  if (v6 != a2) {
    kdrc_codestream::move_to_tail();
  }
  int v7 = (kdrc_stream *)*((void *)a2 + 143);
  *uint64_t v5 = v7;
  if (v7)
  {
    *((void *)v7 + 144) = 0;
    goto LABEL_10;
  }
LABEL_11:
  uint64_t v8 = 0;
  unint64_t v9 = (void *)(this + 320);
  do
  {
    uint64_t v10 = v8;
    uint64_t v8 = *v9;
    unint64_t v9 = (void *)(*v9 + 1144);
  }
  while (v8);
  *((void *)a2 + 144) = v10;
  *((void *)a2 + 143) = 0;
  if (v10)
  {
    *(void *)(v10 + 1144) = a2;
    uint64_t v2 = *v5;
    if (!*v5) {
      goto LABEL_20;
    }
  }
  else
  {
    *uint64_t v5 = a2;
  }
  do
  {
    if (*((unsigned char *)v2 + 1068))
    {
      this = kdu_region_decompressor::finish((kdrc_stream *)((char *)v2 + 120));
      *(unsigned char *)(*((void *)v2 + 142) + 296) = 0;
      *((unsigned char *)v2 + 1068) = 0;
    }
    uint64_t v2 = (kdrc_stream *)*((void *)v2 + 143);
  }
  while (v2);
LABEL_20:
  if (*(unsigned char *)(v3 + 296)) {
    kdrc_codestream::move_to_tail();
  }
  return this;
}

uint64_t kdrc_stream::kdrc_stream(uint64_t a1, uint64_t a2, char a3, int a4, uint64_t a5, uint64_t a6)
{
  *(_OWORD *)(a1 + 1052) = 0u;
  bzero((void *)(a1 + 376), 0x210uLL);
  *(_OWORD *)(a1 + 936) = 0u;
  *(_OWORD *)(a1 + 952) = 0u;
  *(_OWORD *)(a1 + 920) = 0u;
  *(_OWORD *)(a1 + 972) = 0u;
  *(_OWORD *)(a1 + 988) = 0u;
  *(_OWORD *)(a1 + 1004) = 0u;
  *(_OWORD *)(a1 + 1020) = 0u;
  *(_OWORD *)(a1 + 1072) = 0u;
  *(_OWORD *)(a1 + 1088) = 0u;
  *(void *)a1 = a2;
  *(unsigned char *)(a1 + 8) = a3;
  *(_DWORD *)(a1 + 12) = a4;
  *(void *)(a1 + 32) = a5;
  *(void *)(a1 + 40) = a6;
  *(_WORD *)(a1 + 9) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 56) = 0x10000;
  *(unsigned char *)(a1 + 1068) = 0;
  *(unsigned char *)(a1 + 909) = 0;
  *(void *)(a1 + 1040) = 0;
  *(unsigned char *)(a1 + 1048) = 1;
  *(unsigned char *)(a1 + 1124) = 0;
  *(_DWORD *)(a1 + 1120) = 256;
  *(void *)(a1 + 1104) = -1;
  *(void *)(a1 + 1112) = 0;
  *(_OWORD *)(a1 + 1128) = 0u;
  *(_OWORD *)(a1 + 1144) = 0u;
  *(_OWORD *)(a1 + 360) = xmmword_18898EB80;
  return a1;
}

void sub_1886DA13C(_Unwind_Exception *a1)
{
  kdu_channel_mapping::~kdu_channel_mapping(v1);
  _Unwind_Resume(a1);
}

void kdrc_stream::~kdrc_stream(kdrc_stream *this)
{
  if (*((unsigned char *)this + 1068))
  {
    kdu_region_decompressor::finish((kdrc_stream *)((char *)this + 120));
    uint64_t v2 = (kdrc_codestream *)*((void *)this + 142);
    *((unsigned char *)v2 + 296) = 0;
    *((unsigned char *)this + 1068) = 0;
  }
  else
  {
    uint64_t v2 = (kdrc_codestream *)*((void *)this + 142);
    if (!v2) {
      goto LABEL_5;
    }
  }
  kdrc_codestream::detach(v2, (kdrc_codestream **)this);
  *((void *)this + 142) = 0;
LABEL_5:
  uint64_t v3 = (kdrc_overlay *)*((void *)this + 6);
  if (v3)
  {
    kdrc_overlay::~kdrc_overlay(v3);
    MEMORY[0x18C11C0E0]();
  }
  kdu_region_decompressor::~kdu_region_decompressor((kdrc_stream *)((char *)this + 120));
  kdu_channel_mapping::~kdu_channel_mapping((j2_colour_converter **)this + 8);
}

double kdrc_stream::init(kdrc_stream *this, kdu_compressed_source *a2, kdrc_codestream **a3)
{
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  if (*((void *)this + 6)) {
    kdrc_stream::init();
  }
  *(_WORD *)((char *)this + 9) = 0;
  *((_OWORD *)this + 69) = 0u;
  if (*((void *)this + 142)) {
    kdrc_stream::init();
  }
  if (!a3) {
    operator new();
  }
  kdrc_codestream::attach(a3[142], this);
  uint64_t v5 = (unsigned int **)*((void *)this + 142);
  if (v5 != (unsigned int **)a3[142]) {
    kdrc_stream::init();
  }
  int v6 = -1;
  *((_DWORD *)this + 90) = -1;
  *((_DWORD *)this + 93) = 0;
  kdu_channel_mapping::configure((kdrc_stream *)((char *)this + 64), v5[36]);
  if (*((int *)this + 16) >= 1) {
    int v6 = **((_DWORD **)this + 9);
  }
  *((_DWORD *)this + 91) = v6;
  *((_DWORD *)this + 92) = v6;
  *((_DWORD *)this + 226) = kdu_codestream::get_min_dwt_levels((kdu_codestream *)(*((void *)this + 142) + 288));
  kdrc_stream::configure_subsampling(this);
  *((unsigned char *)this + 908) = kdu_codestream::can_flip((kdu_codestream *)(*((void *)this + 142) + 288));
  *((unsigned char *)this + 1068) = 0;
  *((unsigned char *)this + 909) = 0;
  *(void *)&double result = kdrc_stream::invalidate_surface((__n128 *)this).n128_u64[0];
  return result;
}

void sub_1886DA354(void *a1)
{
  __cxa_begin_catch(a1);
  kdrc_codestream::~kdrc_codestream(v1);
  MEMORY[0x18C11C0E0]();
  __cxa_rethrow();
}

void sub_1886DA37C(_Unwind_Exception *a1)
{
}

void kdrc_stream::configure_subsampling(kdrc_stream *this)
{
  if ((*((_DWORD *)this + 92) & 0x80000000) != 0) {
    kdrc_stream::configure_subsampling();
  }
  int v2 = *((_DWORD *)this + 226);
  if (v2 < 33)
  {
    if (v2 < 0) {
      return;
    }
  }
  else
  {
    int v2 = 32;
    *((_DWORD *)this + 226) = 32;
  }
  uint64_t v3 = v2;
  do
  {
    kdu_codestream::apply_input_restrictions(*((void *)this + 142) + 288, 0, 0, v3, 0, 0, *((_DWORD *)this + 93));
    if (v3 == *((_DWORD *)this + 226) && (*((_DWORD *)this + 90) & 0x80000000) == 0)
    {
      int num_components = kdu_codestream::get_num_components((unsigned int **)(*((void *)this + 142) + 288), 1);
      if (num_components <= *((_DWORD *)this + 90))
      {
        *((_DWORD *)this + 92) = num_components - 1;
        *((_DWORD *)this + 90) = num_components - 1;
      }
    }
    unint64_t v12 = 0;
    kdu_codestream::get_subsampling((kd_codestream **)(*((void *)this + 142) + 288), *((_DWORD *)this + 92), (uint64_t)&v12, 1);
    uint64_t v5 = (char *)this + 8 * v3;
    unint64_t v6 = v12;
    *((void *)v5 + 47) = v12;
    unint64_t v7 = HIDWORD(v6);
    if ((*((_DWORD *)this + 90) & 0x80000000) != 0)
    {
      int v8 = *((_DWORD *)this + 16);
      if (v8 >= 1)
      {
        for (uint64_t i = 0; i < v8; ++i)
        {
          int v10 = *(_DWORD *)(*((void *)this + 9) + 4 * i);
          if (v10 != *((_DWORD *)this + 92))
          {
            kdu_codestream::get_subsampling((kd_codestream **)(*((void *)this + 142) + 288), v10, (uint64_t)&v12, 1);
            if (SHIDWORD(v12) >= (int)v7) {
              unint64_t v7 = v7;
            }
            else {
              unint64_t v7 = HIDWORD(v12);
            }
            if ((int)v12 < (int)v6) {
              LODWORD(v6) = v12;
            }
            int v8 = *((_DWORD *)this + 16);
          }
        }
      }
    }
    *((void *)v5 + 80) = v6 | (v7 << 32);
  }
  while (v3-- > 0);
}

__n128 kdrc_stream::invalidate_surface(__n128 *this)
{
  int v2 = (__n128 *)((char *)this + 1020);
  if (this[66].n128_u8[12])
  {
    kdu_region_decompressor::finish((kdu_region_decompressor *)&this[7].n128_i8[8]);
    *(unsigned char *)(this[71].n128_u64[0] + 296) = 0;
    this[66].n128_u8[12] = 0;
  }
  v2[2].n128_u64[0] = v2->n128_u64[0];
  v2[2].n128_u64[1] = 0;
  __n128 result = v2[2];
  this[68] = result;
  this[67] = result;
  this[70].n128_u8[4] = 0;
  this[70].n128_u32[0] = 256;
  return result;
}

void kdrc_stream::init(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a3;
  uint64_t v4 = a2;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  if (!*(void *)(a1 + 48))
  {
    *(_DWORD *)(a1 + 1104) = jpx_codestream_source::get_codestream_id((jpx_codestream_source *)&v4);
    operator new();
  }
  kdrc_stream::init();
}

void sub_1886DAB4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886DAB5C(void *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    kdrc_codestream::~kdrc_codestream(v2);
    MEMORY[0x18C11C0E0]();
    __cxa_rethrow();
  }
  sub_1886DABFC();
}

void sub_1886DAB90()
{
}

void sub_1886DAB9C()
{
  MEMORY[0x18C11C0E0](v0, 0x10B0C40F8FFDE3CLL);
  sub_1886DABFC();
}

void sub_1886DABD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886DABE8(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  sub_1886DABFC();
}

void sub_1886DABFC()
{
  _Unwind_Resume(v0);
}

void kdrc_stream::init(kdrc_stream *this, mj2_video_source *a2, uint64_t a3, unsigned int a4, kdrc_codestream **a5)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  *((void *)this + 2) = a2;
  *((_DWORD *)this + 6) = a3;
  *((_DWORD *)this + 7) = a4;
  if (!*((void *)this + 6))
  {
    *(_WORD *)((char *)this + 9) = 0;
    if (a4 > 1 || (int v10 = (*(uint64_t (**)(mj2_video_source *))(*(void *)a2 + 80))(a2), a4) && !v10)
    {
      *(void *)&long long v19 = 0;
      *(_OWORD *)int v17 = 0u;
      long long v18 = 0u;
      kdu_error::kdu_error((kdu_error *)v17, "Error in Kakadu Region Compositor:\n");
      kdu_error::~kdu_error((kdu_error *)v17);
    }
    (*(void (**)(mj2_video_source *, uint64_t))(*(void *)a2 + 104))(a2, a3);
    *((_DWORD *)this + 276) = mj2_video_source::get_stream_idx(a2, a4);
    *((_DWORD *)this + 277) = mj2_video_source::get_track_idx(a2) - 1;
    *((void *)this + 139) = 0;
    if (!*((void *)this + 142))
    {
      if (a5)
      {
        kdrc_codestream::attach(a5[142], this);
        uint64_t v11 = a5 + 142;
        uint64_t v12 = *((void *)this + 142);
        if (v12 != *v11) {
          kdrc_stream::init();
        }
        kdu_codestream::enable_restart((uint64_t *)(v12 + 288));
        *((_DWORD *)this + 90) = -1;
        *((_DWORD *)this + 93) = 0;
        uint64_t v13 = mj2_video_source::access_channels(a2);
        uint64_t v14 = mj2_video_source::access_palette(a2);
        uint64_t v15 = mj2_video_source::access_dimensions(a2);
        uint64_t v16 = mj2_video_source::access_colour(a2);
        kdu_channel_mapping::configure((j2_colour_converter **)this + 8, v16, v13, 0, v14, v15);
      }
      operator new();
    }
    kdrc_stream::init();
  }
  kdrc_stream::init();
}

void sub_1886DB060(void *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    kdrc_codestream::~kdrc_codestream(v2);
    MEMORY[0x18C11C0E0]();
    __cxa_rethrow();
  }
  sub_1886DB0F4();
}

void sub_1886DB094()
{
}

void sub_1886DB0A0()
{
  MEMORY[0x18C11C0E0](v0, 0x10B0C40F8FFDE3CLL);
  sub_1886DB0F4();
}

void sub_1886DB0C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886DB0D0(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886DB0E0(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  sub_1886DB0F4();
}

void sub_1886DB0F4()
{
  _Unwind_Resume(v0);
}

uint64_t kdrc_stream::change_frame(kdrc_stream *this, uint64_t a2)
{
  uint64_t result = *((void *)this + 2);
  if (result && *((_DWORD *)this + 6) != a2)
  {
    if (*((unsigned char *)this + 1068))
    {
      kdu_region_decompressor::finish((kdrc_stream *)((char *)this + 120));
      *(unsigned char *)(*((void *)this + 142) + 296) = 0;
      *((unsigned char *)this + 1068) = 0;
      uint64_t result = *((void *)this + 2);
    }
    *((_DWORD *)this + 6) = a2;
    (*(void (**)(uint64_t, uint64_t))(*(void *)result + 104))(result, a2);
    *((_DWORD *)this + 276) = mj2_video_source::get_stream_idx(*((mj2_video_source **)this + 2), *((_DWORD *)this + 7));
    uint64_t v5 = (kdrc_codestream *)*((void *)this + 142);
    if (v5) {
      kdrc_codestream::restart(v5, *((mj2_video_source **)this + 2), a2, *((unsigned int *)this + 7));
    }
    operator new();
  }
  return result;
}

void sub_1886DB270(void *a1)
{
  __cxa_begin_catch(a1);
  kdrc_codestream::~kdrc_codestream(v1);
  MEMORY[0x18C11C0E0]();
  __cxa_rethrow();
}

void sub_1886DB298(_Unwind_Exception *a1)
{
}

uint64_t *kdrc_stream::set_error_level(kdrc_stream *this, int a2)
{
  uint64_t v2 = *((void *)this + 142);
  if (!v2 || !*(void *)(v2 + 288)) {
    kdrc_stream::set_error_level();
  }
  uint64_t v3 = (uint64_t *)(v2 + 288);
  if (a2 == 2)
  {
    char v5 = 0;
LABEL_14:
    return kdu_codestream::set_resilient(v3, v5);
  }
  if (a2 != 1)
  {
    if (!a2)
    {
      return kdu_codestream::set_fast(v3);
    }
    char v5 = 1;
    goto LABEL_14;
  }

  return kdu_codestream::set_fussy(v3);
}

uint64_t kdrc_stream::set_mode(__n128 *this, uint64_t a2, unsigned __int32 a3)
{
  uint64_t v3 = a2;
  if ((int)a2 >= 0) {
    unsigned __int32 v5 = a3;
  }
  else {
    unsigned __int32 v5 = 0;
  }
  if (this[22].n128_u32[2] != a2 || this[23].n128_u32[1] != v5)
  {
    for (uint64_t i = *(void *)(this[71].n128_u64[0] + 320); i; uint64_t i = *(void *)(i + 1144))
    {
      if (*(unsigned char *)(i + 1068))
      {
        kdu_region_decompressor::finish((kdu_region_decompressor *)(i + 120));
        *(unsigned char *)(*(void *)(i + 1136) + 296) = 0;
        *(unsigned char *)(i + 1068) = 0;
      }
    }
    this[22].n128_u32[2] = v3;
    this[23].n128_u32[1] = v5;
    if ((v3 & 0x80000000) != 0) {
      LODWORD(v3) = this[22].n128_u32[3];
    }
    this[23].n128_u32[0] = v3;
    kdrc_stream::configure_subsampling((kdrc_stream *)this);
    this[56].n128_u8[13] = 0;
    this[65].n128_u64[0] = 0;
    kdrc_stream::invalidate_surface(this);
    return this[22].n128_u32[2];
  }
  return v3;
}

uint64_t kdrc_stream::set_thread_env(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(result + 32) != a2 && *(unsigned char *)(result + 1068))
  {
    uint64_t v4 = 0;
    memset(v3, 0, sizeof(v3));
    kdu_error::kdu_error((kdu_error *)v3);
    kdu_error::~kdu_error((kdu_error *)v3);
  }
  *(void *)(result + 32) = a2;
  *(void *)(result + 40) = a3;
  return result;
}

void sub_1886DB4A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886DB4B4()
{
  _Unwind_Resume(v0);
}

unint64_t kdrc_stream::set_scale(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4, unint64_t a5, unint64_t a6, unint64_t a7, int a8, float a9, unsigned __int8 a10, unsigned __int8 a11, int *a12)
{
  *(void *)&long long v98 = a2;
  *((void *)&v98 + 1) = a3;
  unint64_t v14 = HIDWORD(a6);
  unint64_t v15 = HIDWORD(a7);
  *a12 = 0;
  if (*(void *)(a1 + 16))
  {
    LODWORD(v16) = 0;
    LODWORD(v17) = 0;
    a2 = 0;
    a3 = 0;
    int v18 = 0;
    LODWORD(v19) = 0;
    long long v98 = 0uLL;
  }
  else
  {
    unint64_t v19 = HIDWORD(a2);
    unint64_t v17 = HIDWORD(a3);
    LODWORD(v16) = a3;
    int v18 = a2;
  }
  BOOL v20 = *(unsigned char *)(a1 + 909)
     && *(unsigned __int8 *)(a1 + 911) == a10
     && *(unsigned __int8 *)(a1 + 912) == a11
     && *(unsigned __int8 *)(a1 + 910) == a8
     && *(float *)(a1 + 916) == a9
     && *(_DWORD *)(a1 + 924) == v19
     && *(_DWORD *)(a1 + 920) == v18
     && *(_DWORD *)(a1 + 932) == v17
     && *(_DWORD *)(a1 + 928) == v16
     && *(void *)(a1 + 936) == a4
     && *(_OWORD *)(a1 + 944) == __PAIR128__(a6, a5)
     && *(_DWORD *)(a1 + 964) == HIDWORD(a7)
     && *(_DWORD *)(a1 + 960) == a7;
  *(unsigned char *)(a1 + 909) = 0;
  *(unsigned char *)(a1 + 911) = a10;
  *(unsigned char *)(a1 + 912) = a11;
  *(unsigned char *)(a1 + 910) = a8;
  *(float *)(a1 + 916) = a9;
  *(_OWORD *)(a1 + 920) = v98;
  *(void *)(a1 + 936) = a4;
  *(void *)(a1 + 944) = a5;
  *(void *)(a1 + 952) = a6;
  *(void *)(a1 + 960) = a7;
  if (((a10 & 1) != 0 || a11) && !*(unsigned char *)(a1 + 908))
  {
    uint64_t i = 0;
    unsigned int v43 = 0;
    uint64_t v44 = a12;
    int v45 = *a12 | 2;
LABEL_162:
    *uint64_t v44 = v45;
    return v43 | (unint64_t)(i << 32);
  }
  unint64_t v94 = a3;
  unint64_t v95 = HIDWORD(a4);
  unint64_t v22 = a2;
  int v23 = a7;
  BOOL v92 = v20;
  int v24 = a6;
  int v96 = a4;
  for (uint64_t i = *(void *)(*(void *)(a1 + 1136) + 320); i; uint64_t i = *(void *)(i + 1144))
  {
    if (*(unsigned char *)(i + 1068))
    {
      kdu_region_decompressor::finish((kdu_region_decompressor *)(i + 120));
      *(unsigned char *)(*(void *)(i + 1136) + 296) = 0;
      *(unsigned char *)(i + 1068) = 0;
    }
  }
  int v26 = v24;
  if (v14 && v24)
  {
    BOOL v27 = (int)v17 < 1 || (int)v16 < 1;
    int v28 = v27;
    unint64_t v29 = v94;
    if (v28 == 1)
    {
      uint64_t v30 = *(void *)(a1 + 1136);
      int v31 = *(_DWORD *)(v30 + 312) * v14;
      if ((int)v15 <= 1) {
        unsigned int v32 = 1;
      }
      else {
        unsigned int v32 = v15;
      }
      if (v31 <= 0) {
        unsigned int v33 = -(int)(-v31 / v32);
      }
      else {
        unsigned int v33 = (v31 - 1) / v32 + 1;
      }
      unint64_t v22 = 0;
      int v46 = *(_DWORD *)(v30 + 308) * v24;
      if (v23 <= 1) {
        unsigned int v47 = 1;
      }
      else {
        unsigned int v47 = v23;
      }
      unsigned int v48 = (v46 - 1) / v47;
      BOOL v27 = v46 <= 0;
      int v49 = -(int)(-v46 / v47);
      if (!v27) {
        int v49 = v48 + 1;
      }
      *((void *)&v98 + 1) = __PAIR64__(v33, v49);
      LODWORD(v16) = v49;
      unint64_t v17 = __PAIR64__(v33, v49) >> 32;
      unint64_t v29 = __PAIR64__(v33, v49);
    }
    BOOL v51 = SHIDWORD(a5) < 1 || (int)a5 < 1;
    BOOL v52 = !v51;
    if (v51) {
      unint64_t v53 = v29;
    }
    else {
      unint64_t v53 = a5;
    }
    if (v52) {
      int v42 = v96;
    }
    else {
      int v42 = 0;
    }
    if (v52) {
      int v41 = v95;
    }
    else {
      int v41 = 0;
    }
    if (v28)
    {
      uint64_t v38 = *(void *)(a1 + 1136);
      long long v98 = *(_OWORD *)(v38 + 300);
      LODWORD(v16) = DWORD2(v98);
      LODWORD(v17) = HIDWORD(v98);
    }
    else
    {
      int v54 = HIDWORD(v22) * v15;
      if ((int)v14 <= 1) {
        unsigned int v55 = 1;
      }
      else {
        unsigned int v55 = v14;
      }
      if (v54 <= 0) {
        unsigned int v56 = -(int)(-v54 / v55);
      }
      else {
        unsigned int v56 = (v54 - 1) / v55 + 1;
      }
      int v57 = v22 * v23;
      if (v24 <= 1) {
        unsigned int v58 = 1;
      }
      else {
        unsigned int v58 = v24;
      }
      if (v57 <= 0) {
        unsigned int v59 = -(int)(-v57 / v58);
      }
      else {
        unsigned int v59 = (v57 - 1) / v58 + 1;
      }
      int v60 = v16 + v22;
      int v61 = (v17 + HIDWORD(v22)) * v15;
      if (v61 <= 0) {
        unsigned int v62 = -(int)(-v61 / v55);
      }
      else {
        unsigned int v62 = (v61 - 1) / v55 + 1;
      }
      int v63 = v60 * v23;
      unsigned int v64 = (v60 * v23 - 1) / v58;
      int v65 = -(int)(-v63 / v58);
      if (v63 > 0) {
        int v65 = v64 + 1;
      }
      unint64_t v17 = v62 - v56;
      uint64_t v16 = v65 - v59;
      *((void *)&v98 + 1) = v16 | (v17 << 32);
      uint64_t v38 = *(void *)(a1 + 1136);
      unsigned int v66 = v56 + *(_DWORD *)(v38 + 304);
      LODWORD(v98) = v59 + *(_DWORD *)(v38 + 300);
      DWORD1(v98) = v66;
    }
    int v67 = *(_DWORD *)(a1 + 380);
    if (v67 < 1 || (int v68 = *(_DWORD *)(a1 + 376), v68 < 1))
    {
      uint64_t i = 0;
      unsigned int v43 = 0;
LABEL_161:
      uint64_t v44 = a12;
      int v45 = *a12 | 1;
      goto LABEL_162;
    }
    double v35 = (double)SHIDWORD(v53) / (double)(int)v17 * a9;
    double v37 = (double)(int)v53 / (double)(int)v16 * a9;
    double v39 = 2.0 / (double)SHIDWORD(v53);
    if ((int)v17 / v67 < SHIDWORD(v53)) {
      double v39 = 2.0 / (double)(int)v17 * (double)v67;
    }
    double v40 = 2.0 / (double)(int)v53;
    if ((int)v16 / v68 < (int)v53) {
      double v40 = 2.0 / (double)(int)v16 * (double)v68;
    }
  }
  else
  {
    double v34 = (double)*(int *)(a1 + 380);
    double v35 = a9 / v34;
    double v36 = (double)*(int *)(a1 + 376);
    double v37 = a9 / v36;
    uint64_t v38 = *(void *)(a1 + 1136);
    double v39 = 2.0 / (double)*(int *)(v38 + 312) * v34;
    double v40 = 2.0 / (double)*(int *)(v38 + 308) * v36;
    int v41 = v95;
    int v42 = v96;
  }
  uint64_t v69 = 0;
  uint64_t v70 = (int32x4_t *)(a1 + 972);
  if (v39 <= 0.1) {
    double v71 = v39;
  }
  else {
    double v71 = 0.1;
  }
  if (v40 <= 0.1) {
    double v72 = v40;
  }
  else {
    double v72 = 0.1;
  }
  for (uint64_t j = (int *)(a1 + 376); ; j += 2)
  {
    double v74 = v35 * (double)j[67];
    if (v74 >= 1.0 - v71)
    {
      double v75 = v37 * (double)j[66];
      if (v75 >= 1.0 - v72) {
        break;
      }
    }
    if (v69 >= *(int *)(a1 + 904))
    {
      uint64_t i = 0;
      unsigned int v43 = 0;
      *(_DWORD *)(a1 + 968) = v69;
      goto LABEL_161;
    }
    ++v69;
  }
  *(_DWORD *)(a1 + 968) = v69;
  double v76 = v35 * (double)j[1];
  double v77 = v37 * (double)*j;
  double v78 = floor(v76 + 0.5);
  double v79 = floor(v77 + 0.5);
  if (vabdd_f64(v78, v76) >= v71) {
    double v78 = v76;
  }
  else {
    double v74 = v74 * (v78 / v76);
  }
  if (vabdd_f64(v79, v77) >= v72) {
    double v79 = v77;
  }
  else {
    double v75 = v75 * (v79 / v77);
  }
  if (v74 < 1.0) {
    double v78 = v78 * (1.0 / v74);
  }
  BOOL v80 = v75 < 1.0;
  double v81 = v79 * (1.0 / v75);
  if (v80) {
    double v79 = v81;
  }
  signed int v82 = 1;
  *(_DWORD *)(a1 + 984) = 1;
  int v83 = vcvtpd_s64_f64(v78);
  *(_DWORD *)(a1 + 976) = v83;
  if ((v71 + 1.0) * v78 >= (double)v83)
  {
    signed int v84 = 1;
  }
  else
  {
    *(_DWORD *)(a1 + 984) = v17;
    if (!v14)
    {
      LODWORD(v17) = *(_DWORD *)(v38 + 312);
      *(_DWORD *)(a1 + 984) = v17;
    }
    if ((int)v17 <= 0) {
      kdrc_stream::set_scale();
    }
    if (v17 == 1)
    {
      signed int v84 = 1;
    }
    else
    {
      while (v78 * (double)(int)v17 > 1073741820.0)
      {
        signed int v84 = v17 >> 1;
        *(_DWORD *)(a1 + 984) = v17 >> 1;
        BOOL v27 = v17 > 3;
        LODWORD(v17) = v17 >> 1;
        if (!v27) {
          goto LABEL_124;
        }
      }
      signed int v84 = v17;
    }
LABEL_124:
    int v83 = vcvtpd_s64_f64(v78 * (double)v84);
    *(_DWORD *)(a1 + 976) = v83;
  }
  *(_DWORD *)(a1 + 980) = 1;
  int v85 = vcvtpd_s64_f64(v79);
  v70->i32[0] = v85;
  if ((v72 + 1.0) * v79 < (double)v85)
  {
    *(_DWORD *)(a1 + 980) = v16;
    if (!v26)
    {
      LODWORD(v16) = *(_DWORD *)(v38 + 308);
      *(_DWORD *)(a1 + 980) = v16;
    }
    if ((int)v16 <= 0) {
      kdrc_stream::set_scale();
    }
    if (v16 == 1)
    {
      signed int v82 = 1;
    }
    else
    {
      while (v79 * (double)(int)v16 > 1073741820.0)
      {
        signed int v82 = v16 >> 1;
        *(_DWORD *)(a1 + 980) = v16 >> 1;
        BOOL v27 = v16 > 3;
        LODWORD(v16) = v16 >> 1;
        if (!v27) {
          goto LABEL_135;
        }
      }
      signed int v82 = v16;
    }
LABEL_135:
    int v85 = vcvtpd_s64_f64(v79 * (double)v82);
    v70->i32[0] = v85;
  }
  if (v14 && v26)
  {
    LODWORD(i) = vcvtmd_s64_f64((double)v41 * ((double)v83 / (v78 * (double)v84) * a9) + 0.5);
    unsigned int v43 = vcvtmd_s64_f64((double)v42 * ((double)v85 / (v79 * (double)v82) * a9) + 0.5);
    kdu_codestream::apply_input_restrictions(v38 + 288, 0, 0, v69, 0, (int *)&v98, *(_DWORD *)(a1 + 372));
  }
  else
  {
    kdu_codestream::apply_input_restrictions(v38 + 288, 0, 0, v69, 0, 0, *(_DWORD *)(a1 + 372));
    uint64_t i = 0;
    unsigned int v43 = 0;
  }
  kdu_codestream::change_appearance((uint64_t *)(*(void *)(a1 + 1136) + 288), a8, a10, a11);
  if (a8) {
    int32x4_t *v70 = vrev64q_s32(*v70);
  }
  int32x4_t v97 = 0uLL;
  kdu_codestream::get_dims((kdu_codestream *)(*(void *)(a1 + 1136) + 288), *(_DWORD *)(a1 + 368), &v97, 1);
  if ((unsigned __int32)v97.i32[3] >> 18 || v97.i32[2] >= 0x40000 || v97.i32[2] < 0) {
    goto LABEL_161;
  }
  unint64_t render_dims = find_render_dims(v97.i64[0], v97.i64[1], v70->i64[0], *(void *)(a1 + 980));
  *(void *)(a1 + 988) = render_dims;
  *(void *)(a1 + 996) = v87;
  if (a8) {
    unsigned int v88 = v43;
  }
  else {
    unsigned int v88 = i;
  }
  if (a8) {
    unsigned int v89 = i;
  }
  else {
    unsigned int v89 = v43;
  }
  if (a11) {
    uint64_t i = 1 - v88 - HIDWORD(v87);
  }
  else {
    uint64_t i = v88;
  }
  if (a10) {
    unsigned int v43 = 1 - v89 - v87;
  }
  else {
    unsigned int v43 = v89;
  }
  *(void *)(a1 + 1004) = (render_dims - v43) | ((unint64_t)(HIDWORD(render_dims) - i) << 32);
  if (!v92)
  {
    *(void *)(a1 + 1040) = 0;
    kdrc_stream::invalidate_surface((__n128 *)a1);
  }
  *(unsigned char *)(a1 + 909) = 1;
  uint64_t v90 = *(void *)(a1 + 48);
  if (v90) {
    kdrc_overlay::set_geometry(v90, *(void *)(*(void *)(a1 + 1136) + 300), *(void *)(a1 + 8 * *(int *)(a1 + 968) + 376), a8, a10, a11, v70->i64[0], *(void *)(a1 + 980), *(void *)(a1 + 1004));
  }
  return v43 | (unint64_t)(i << 32);
}

uint64_t kdrc_stream::set_buffer_surface(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  *((void *)&v13 + 1) = a4;
  if (!*(unsigned char *)(a1 + 909)) {
    kdrc_stream::set_buffer_surface();
  }
  unint64_t v7 = (void *)(a1 + 1012);
  *(void *)(a1 + 1040) = a2;
  int v8 = *(_DWORD *)(a1 + 1008) + HIDWORD(a3);
  LODWORD(v13) = *(_DWORD *)(a1 + 1004) + a3;
  DWORD1(v13) = v8;
  *(void *)(a1 + 1012) = v13;
  unint64_t v9 = (int *)(a1 + 1020);
  uint64_t result = kdu_dims::operator&=(&v13, (int *)(a1 + 988));
  BOOL v11 = (void)v13 == __PAIR64__(*(_DWORD *)(a1 + 1024), *v9)
     && HIDWORD(v13) == *(_DWORD *)(a1 + 1032)
     && DWORD2(v13) == *(_DWORD *)(a1 + 1028);
  *(_OWORD *)unint64_t v9 = v13;
  if (a5)
  {
    if (*(unsigned char *)(a1 + 1068))
    {
      uint64_t result = kdu_region_decompressor::finish((kdu_region_decompressor *)(a1 + 120));
      *(unsigned char *)(*(void *)(a1 + 1136) + 296) = 0;
      *(unsigned char *)(a1 + 1068) = 0;
    }
    v7[5] = v7[1];
    v7[6] = 0;
    long long v12 = *(_OWORD *)(v7 + 5);
    *(_OWORD *)(a1 + 1088) = v12;
    *(_OWORD *)(a1 + 1072) = v12;
    *(unsigned char *)(a1 + 1124) = 0;
    *(_DWORD *)(a1 + 1120) = 256;
  }
  else if (!v11)
  {
    if (*(unsigned char *)(a1 + 1068))
    {
      kdu_dims::operator&=((_DWORD *)(a1 + 1072), v9);
      kdu_dims::operator&=((_DWORD *)(a1 + 1088), v9);
      if (*(int *)(a1 + 1100) < 1 || *(int *)(a1 + 1096) <= 0)
      {
        if (*(unsigned char *)(a1 + 1068))
        {
          kdu_region_decompressor::finish((kdu_region_decompressor *)(a1 + 120));
          *(unsigned char *)(*(void *)(a1 + 1136) + 296) = 0;
          *(unsigned char *)(a1 + 1068) = 0;
        }
      }
    }
    kdu_dims::operator&=((_DWORD *)(a1 + 1052), v9);
    return kdrc_stream::update_completion_status(a1);
  }
  return result;
}

uint64_t kdrc_stream::update_completion_status(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 1032);
  if (v1 < 1
    || (int v2 = *(_DWORD *)(this + 1028), v2 < 1)
    || *(_DWORD *)(this + 1024) == *(_DWORD *)(this + 1056)
    && *(_DWORD *)(this + 1020) == *(_DWORD *)(this + 1052)
    && v1 == *(_DWORD *)(this + 1064)
    && v2 == *(_DWORD *)(this + 1060))
  {
    LODWORD(v3) = 0;
    *(unsigned char *)(this + 1124) = 1;
  }
  else
  {
    *(unsigned char *)(this + 1124) = 0;
    int64_t v4 = v2 * (unint64_t)v1;
    uint64_t v5 = *(int *)(this + 1060) * (uint64_t)*(int *)(this + 1064);
    if (*(unsigned char *)(this + 1068)) {
      uint64_t v5 = v5
    }
         + *(int *)(this + 1080) * (uint64_t)*(int *)(this + 1084)
         - *(int *)(this + 1096) * (uint64_t)*(int *)(this + 1100);
    uint64_t v3 = ((v4 - v5) << 8) / v4;
  }
  *(_DWORD *)(this + 1120) = v3;
  return this;
}

uint64_t kdrc_stream::process(kdrc_stream *this, int a2, int32x2_t *a3, int *a4)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  *a4 = 0;
  if (!*((void *)this + 130)) {
    kdrc_stream::process();
  }
  int v8 = (char *)this + 972;
  if (!*((unsigned char *)this + 1068) && *((int *)this + 258) >= 1 && *((int *)this + 257) >= 1)
  {
    *(void *)((char *)this + 1052) = *(void *)((char *)this + 1020);
    *(void *)((char *)this + 1060) = 0;
    long long v14 = *(_OWORD *)((char *)this + 1020);
    *((_OWORD *)this + 67) = v14;
    *((_OWORD *)this + 68) = v14;
    if (*((int *)this + 271) >= 1 && *((int *)this + 270) >= 1)
    {
      uint64_t v15 = *((void *)this + 142);
      if (*(unsigned char *)(v15 + 296)) {
        kdrc_stream::process();
      }
      uint64_t v16 = (kdrc_stream *)((char *)this + 120);
      *((_DWORD *)this + 32) = 8;
      int v17 = *((_DWORD *)this + 90);
      if (v17 >= 0) {
        int v18 = 0;
      }
      else {
        int v18 = (int *)((char *)this + 64);
      }
      if ((kdu_region_decompressor::start(v16, *(kd_codestream **)(v15 + 288), v18, v17, *((_DWORD *)this + 242), *((_DWORD *)this + 14), *((void *)this + 134), *((void *)this + 135), *(void *)v8, *((void *)v8 + 1), 0, *((_DWORD *)this + 93), 1, *((void *)this + 4), *((char **)this + 5)) & 1) == 0)goto LABEL_72; {
      *(unsigned char *)(*((void *)this + 142) + 296) = 1;
      }
      *((unsigned char *)this + 1068) = 1;
    }
  }
  a3[1] = 0;
  if (*((unsigned char *)this + 1068))
  {
    uint64_t v9 = *((void *)this + 130);
    if (!*(unsigned char *)(v9 + 27)) {
      (*(void (**)(void, void))(*(void *)v9 + 24))(*((void *)this + 130), 0);
    }
    int v10 = *(_DWORD *)(v9 + 40);
    int v11 = *(_DWORD *)(v9 + 44);
    uint64_t v12 = *(void *)(v9 + 32);
    if (*((unsigned char *)this + 9))
    {
      uint64_t v41 = *(void *)(v9 + 32);
      char v13 = kdu_region_decompressor::process((uint64_t)this + 120, (uint64_t)&v41, 1u, v10, *((void *)v8 + 5), v11, a2, 0, (int *)this + 272, (uint64_t)a3, 8, 1);
    }
    else
    {
      if ((*((_DWORD *)this + 90) & 0x80000000) == 0
        || (uint64_t v34 = *((void *)this + 139)) == 0
        || !*(unsigned char *)(v34 + 232)
        || *((_DWORD *)this + 17) != *((_DWORD *)this + 16))
      {
        if (*((int *)this + 17) > 3)
        {
          long long v46 = 0u;
          long long v45 = 0u;
          uint64_t v41 = v12;
          uint64_t v42 = v12 + 1;
          uint64_t v43 = v12 + 2;
          uint64_t v44 = v12 + 3;
          if (!kdu_region_decompressor::process((uint64_t)this + 120, (uint64_t)&v41, 0, v10, *((void *)v8 + 5), v11, a2, 0, (int *)this + 272, (uint64_t)a3, 8, 1))goto LABEL_27; {
        }
          }
        else if ((kdu_region_decompressor::process((kdrc_stream *)((char *)this + 120), v12, *((void *)v8 + 5), v10, v11, a2, 0, (int *)this + 272, (uint64_t)a3) & 1) == 0)
        {
LABEL_27:
          *(unsigned char *)(*((void *)this + 142) + 296) = 0;
          *((unsigned char *)this + 1068) = 0;
          if (kdu_region_decompressor::finish((kdrc_stream *)((char *)this + 120)))
          {
            int min_dwt_levels = kdu_codestream::get_min_dwt_levels((kdu_codestream *)(*((void *)this + 142) + 288));
            *((_DWORD *)this + 226) = min_dwt_levels;
            if (min_dwt_levels < *((_DWORD *)this + 242))
            {
              *((_DWORD *)this + 242) = min_dwt_levels;
              *((unsigned char *)this + 909) = 0;
              int v20 = *a4 | 1;
LABEL_44:
              *a4 = v20;
              kdrc_stream::invalidate_surface((__n128 *)this);
              return 0;
            }
            if (*((unsigned char *)this + 912) || *((unsigned char *)this + 911))
            {
              BOOL can_flip = kdu_codestream::can_flip((kdu_codestream *)(*((void *)this + 142) + 288));
              *((unsigned char *)this + 908) = can_flip;
              if (!can_flip)
              {
                *((unsigned char *)this + 909) = 0;
                *(_WORD *)((char *)this + 911) = 0;
                int v20 = *a4 | 2;
                goto LABEL_44;
              }
            }
            unint64_t v22 = v8 + 80;
            kdu_dims::operator&=((_DWORD *)v8 + 20, (int *)this + 255);
            kdu_dims::operator&=((_DWORD *)this + 268, (int *)this + 255);
            int v23 = *((_DWORD *)this + 266);
            if (v23 < 1 || (int v24 = *((_DWORD *)v8 + 22), v24 <= 0))
            {
              *unint64_t v22 = *((_OWORD *)this + 67);
            }
            else
            {
              signed int v25 = *(_DWORD *)v22;
              uint64_t v26 = *((unsigned int *)v8 + 21);
              int v27 = v23 + v26;
              int v28 = v24 + *(_DWORD *)v22;
              int v29 = *((_DWORD *)this + 268);
              int v30 = *((_DWORD *)this + 269);
              int v31 = *((_DWORD *)this + 271) + v30;
              int v32 = *((_DWORD *)this + 270) + v29;
              if (v26 == v30 && v27 == v31)
              {
                if (v32 >= v25 && v28 >= v29)
                {
                  if (v25 >= v29) {
                    signed int v25 = *((_DWORD *)this + 268);
                  }
                  if (v28 <= v32) {
                    int v28 = *((_DWORD *)this + 270) + v29;
                  }
                }
              }
              else if (v25 == v29 && v28 == v32 && v31 >= (int)v26 && v27 >= v30)
              {
                uint64_t v26 = (int)v26 >= v30 ? v30 : v26;
                if (v27 <= v31) {
                  int v27 = *((_DWORD *)this + 271) + v30;
                }
              }
              *((void *)v8 + 10) = v25 | (unint64_t)(v26 << 32);
              *((void *)v8 + 11) = (v28 - v25) | ((unint64_t)(v27 - v26) << 32);
            }
            goto LABEL_68;
          }
LABEL_72:
          exception = __cxa_allocate_exception(4uLL);
          _DWORD *exception = 0;
          __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
        }
LABEL_25:
        if (*((int *)this + 275) >= 1 && *((int *)this + 274) > 0)
        {
LABEL_68:
          *a3 = vsub_s32(*a3, *(int32x2_t *)(v8 + 32));
          goto LABEL_69;
        }
        goto LABEL_27;
      }
      if (*((unsigned char *)this + 1048)) {
        uint64_t v35 = 2;
      }
      else {
        uint64_t v35 = 1;
      }
      uint64_t v36 = v12 + v35;
      if (*((unsigned char *)this + 1048)) {
        uint64_t v37 = 1;
      }
      else {
        uint64_t v37 = 2;
      }
      uint64_t v38 = v12 + v37;
      uint64_t v39 = 3;
      if (*((unsigned char *)this + 1048)) {
        uint64_t v39 = 0;
      }
      uint64_t v41 = v36;
      uint64_t v42 = v38;
      uint64_t v43 = v12 + v39;
      char v13 = kdu_region_decompressor::process((uint64_t)this + 120, (uint64_t)&v41, 1u, v10, *((void *)v8 + 5), v11, a2, 0, (int *)this + 272, (uint64_t)a3, 8, 1);
    }
    if ((v13 & 1) == 0) {
      goto LABEL_27;
    }
    goto LABEL_25;
  }
LABEL_69:
  kdrc_stream::update_completion_status((uint64_t)this);
  return 1;
}

double kdrc_stream::adjust_refresh(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  *(void *)&long long v21 = a2;
  *((void *)&v21 + 1) = a3;
  if (!*(unsigned char *)(a1 + 909)) {
    kdrc_stream::adjust_refresh();
  }
  long long v20 = *(_OWORD *)(a1 + 1020);
  int v5 = *(_DWORD *)(a1 + 1008);
  int v6 = *(_DWORD *)(a1 + 1004);
  LODWORD(v20) = v20 - v6;
  DWORD1(v20) -= v5;
  long long v19 = *(_OWORD *)(a1 + 1052);
  LODWORD(v19) = v19 - v6;
  DWORD1(v19) -= v5;
  unint64_t v7 = (uint64_t *)&v21;
  kdu_dims::operator&=(&v19, (int *)&v21);
  long long v22 = v21;
  kdu_dims::operator&=(&v22, (int *)&v20);
  unsigned int v9 = DWORD2(v22);
  if (SDWORD2(v22) < 1 || SHIDWORD(v22) < 1) {
    return kdrc_refresh::add_region(a4, *v7, v7[1]);
  }
  unsigned int v10 = v22;
  unint64_t v11 = DWORD1(v22);
  int v12 = DWORD1(v21);
  unsigned int v13 = DWORD1(v22) - DWORD1(v21);
  if (DWORD1(v22) - DWORD1(v21) < 0
    || (unsigned int v14 = HIDWORD(v22) + DWORD1(v22),
        unsigned int v15 = DWORD1(v21) - (HIDWORD(v22) + DWORD1(v22)) + HIDWORD(v21),
        (v15 & 0x80000000) != 0)
    || (uint64_t v16 = (v22 - v21), (v16 & 0x80000000) != 0)
    || (uint64_t v17 = (DWORD2(v22) + v22), v18 = (v21 - v17 + DWORD2(v21)), (v18 & 0x80000000) != 0))
  {
    kdrc_stream::adjust_refresh();
  }
  if (v22 != v21) {
    double result = kdrc_refresh::add_region(a4, v21, v16 | ((unint64_t)HIDWORD(v21) << 32));
  }
  if (v18) {
    double result = kdrc_refresh::add_region(a4, v17 | ((unint64_t)DWORD1(v21) << 32), v18 | ((unint64_t)HIDWORD(v21) << 32));
  }
  if (v11 != v12) {
    double result = kdrc_refresh::add_region(a4, v10 | ((unint64_t)DWORD1(v21) << 32), v9 | ((unint64_t)v13 << 32));
  }
  if (v15) {
    double result = kdrc_refresh::add_region(a4, v10 | ((unint64_t)v14 << 32), v9 | ((unint64_t)v15 << 32));
  }
  if (SHIDWORD(v19) >= 1 && SDWORD2(v19) >= 1)
  {
    unint64_t v7 = (uint64_t *)&v19;
    return kdrc_refresh::add_region(a4, *v7, v7[1]);
  }
  return result;
}

double kdrc_refresh::add_region(void *a1, uint64_t a2, uint64_t a3)
{
  *(void *)&long long v25 = a2;
  *((void *)&v25 + 1) = a3;
  if (SHIDWORD(a3) >= 1 && (int)a3 >= 1)
  {
    int v5 = a1 + 1;
    int v6 = (long long *)a1[1];
    if (v6)
    {
      unint64_t v7 = 0;
      do
      {
        while (1)
        {
          int v8 = v6;
          int v6 = (long long *)*((void *)v6 + 2);
          long long v26 = *v8;
          kdu_dims::operator&=(&v26, (int *)&v25);
          if (SDWORD2(v26) < 1 || SHIDWORD(v26) < 1) {
            goto LABEL_42;
          }
          if (v25 == v26) {
            return result;
          }
          int v11 = *((_DWORD *)v8 + 1);
          if (*v8 != v26) {
            break;
          }
          int v12 = v7 + 1;
          if (!v7) {
            int v12 = v5;
          }
          void *v12 = v6;
          *((void *)v8 + 2) = *a1;
          *a1 = v8;
          if (!v6) {
            goto LABEL_43;
          }
        }
        if (DWORD1(v26) == DWORD1(v25) && HIDWORD(v25) == HIDWORD(v26))
        {
          int v13 = DWORD2(v26) + v26;
          int v14 = DWORD2(v25) + v25;
          int v15 = v26 - v25;
          if (v26 == v25)
          {
            int v15 = v14 - v13;
            LODWORD(v25) = DWORD2(v26) + v26;
LABEL_26:
            DWORD2(v25) = v15;
            goto LABEL_42;
          }
          if (v14 == v13) {
            goto LABEL_26;
          }
        }
        else if (v26 == v25 && DWORD2(v25) == DWORD2(v26))
        {
          int v16 = HIDWORD(v26) + DWORD1(v26);
          int v17 = HIDWORD(v25) + DWORD1(v25);
          int v18 = DWORD1(v26) - DWORD1(v25);
          if (DWORD1(v26) == DWORD1(v25))
          {
            int v18 = v17 - v16;
            DWORD1(v25) = HIDWORD(v26) + DWORD1(v26);
LABEL_32:
            HIDWORD(v25) = v18;
            goto LABEL_42;
          }
          if (v17 == v16) {
            goto LABEL_32;
          }
        }
        else
        {
          if (DWORD1(v26) != v11)
          {
            int v19 = *(_DWORD *)v8;
LABEL_34:
            if (v19 == v26 && *((_DWORD *)v8 + 2) == DWORD2(v26))
            {
              int v22 = HIDWORD(v26) + DWORD1(v26);
              int v23 = *((_DWORD *)v8 + 3) + v11;
              if (DWORD1(v26) == v11)
              {
                *((_DWORD *)v8 + 1) = v22;
                *((_DWORD *)v8 + 3) = v23 - v22;
              }
              else if (v23 == v22)
              {
                *((_DWORD *)v8 + 3) = DWORD1(v26) - v11;
              }
            }
            goto LABEL_42;
          }
          int v19 = *(_DWORD *)v8;
          if (*((_DWORD *)v8 + 3) != HIDWORD(v26)) {
            goto LABEL_34;
          }
          int v20 = DWORD2(v26) + v26;
          int v21 = *((_DWORD *)v8 + 2) + v19;
          if (v26 == v19)
          {
            *(_DWORD *)int v8 = v20;
            *((_DWORD *)v8 + 2) = v21 - v20;
          }
          else if (v21 == v20)
          {
            *((_DWORD *)v8 + 2) = v26 - v19;
          }
        }
LABEL_42:
        unint64_t v7 = v8;
      }
      while (v6);
    }
LABEL_43:
    uint64_t v24 = *a1;
    if (!*a1) {
      operator new();
    }
    *a1 = *(void *)(v24 + 16);
    *(void *)(v24 + 16) = *v5;
    *int v5 = v24;
    double result = *(double *)&v25;
    *(_OWORD *)uint64_t v24 = v25;
  }
  return result;
}

uint64_t kdrc_layer::kdrc_layer(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 60) = 0;
  *(void *)(a1 + 52) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 152) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  memset_pattern16((void *)(a1 + 88), &unk_18898EB90, 0x10uLL);
  *(void *)&long long v3 = 0x100000001;
  *((void *)&v3 + 1) = 0x100000001;
  *(_OWORD *)(a1 + 104) = v3;
  *(unsigned char *)(a1 + 234) = 0;
  *(_WORD *)(a1 + 232) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  long long v4 = *(_OWORD *)(a1 + 36);
  *(_OWORD *)(a1 + 52) = v4;
  *(_OWORD *)(a1 + 128) = v4;
  *(unsigned char *)(a1 + 120) = 0;
  *(unsigned char *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 236) = -1;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = 0;
  return a1;
}

void kdrc_layer::~kdrc_layer(kdrc_layer *this)
{
  int v2 = (void *)*((void *)this + 22);
  if (v2)
  {
    void *v2 = 0;
    v2[10] = 0;
    v2[11] = 0;
    uint64_t v3 = v2[13];
    if (v3)
    {
      uint64_t v4 = v2[16];
      do
      {
        uint64_t v5 = v3;
        uint64_t v3 = *(void *)(v3 + 24);
        *(void *)(v5 + 24) = v4;
        uint64_t v4 = v5;
      }
      while (v3);
      v2[13] = 0;
      v2[16] = v5;
    }
    v2[14] = 0;
    v2[15] = 0;
  }
  uint64_t v6 = 0;
  char v7 = 1;
  do
  {
    char v8 = v7;
    unsigned int v9 = (kdrc_stream *)*((void *)this + v6 + 9);
    if (v9) {
      kdu_region_compositor::remove_stream(*(void *)this, v9, 1);
    }
    char v7 = 0;
    uint64_t v6 = 1;
  }
  while ((v8 & 1) != 0);
  unsigned int v10 = (kdu_compositor_buf *)*((void *)this + 18);
  if (v10) {
    kdu_region_compositor::internal_delete_buffer(*(kdu_region_compositor **)this, v10);
  }
  int v11 = (kdu_compositor_buf *)*((void *)this + 23);
  if (v11) {
    kdu_region_compositor::internal_delete_buffer(*(kdu_region_compositor **)this, v11);
  }
}

uint64_t kdu_region_compositor::remove_stream(uint64_t this, kdrc_stream *a2, int a3)
{
  uint64_t v4 = this;
  *((void *)a2 + 139) = 0;
  int v5 = *((_DWORD *)a2 + 277);
  if (v5 < 0) {
    a3 = 1;
  }
  char v7 = *(kdrc_stream **)(this + 496);
  if (v7)
  {
    if (v7 == a2)
    {
      unsigned int v9 = 0;
LABEL_10:
      unsigned int v10 = (void *)(this + 496);
      if (v9) {
        unsigned int v10 = (void *)((char *)v9 + 1128);
      }
      void *v10 = *((void *)a2 + 141);
      *((void *)a2 + 141) = *(void *)(this + 504);
      *(void *)(this + 504) = a2;
      *((unsigned char *)a2 + 1125) = 0;
      this = *((void *)a2 + 142);
      if (this) {
        this = kdrc_codestream::move_to_tail(this, a2);
      }
    }
    else
    {
      while (1)
      {
        char v8 = (kdrc_stream *)*((void *)v7 + 141);
        if (!v8) {
          break;
        }
        unsigned int v9 = v7;
        char v7 = (kdrc_stream *)*((void *)v7 + 141);
        if (v8 == a2) {
          goto LABEL_10;
        }
      }
    }
  }
  if (a3)
  {
    int v11 = *(kdrc_stream **)(v4 + 504);
    if (!v11) {
      goto LABEL_31;
    }
    if (v11 != a2)
    {
      while (1)
      {
        int v12 = (kdrc_stream *)*((void *)v11 + 141);
        if (!v12) {
          break;
        }
        int v13 = v11;
        int v11 = (kdrc_stream *)*((void *)v11 + 141);
        if (v12 == a2) {
          goto LABEL_21;
        }
      }
LABEL_31:
      kdu_region_compositor::remove_stream();
    }
    int v13 = 0;
LABEL_21:
    int v14 = (void *)(v4 + 504);
    if (v13) {
      int v14 = (void *)((char *)v13 + 1128);
    }
    *int v14 = *((void *)a2 + 141);
    kdrc_stream::~kdrc_stream(a2);
    this = MEMORY[0x18C11C0E0]();
    if (v5 < 0)
    {
      if (!*(void *)(v4 + 16) || !*(unsigned char *)(v4 + 158)) {
        kdu_region_compositor::remove_stream();
      }
      return jpx_input_box::close((jpx_input_box *)(v4 + 32));
    }
  }
  return this;
}

uint64_t kdu_region_compositor::internal_delete_buffer(kdu_region_compositor *this, kdu_compositor_buf *a2)
{
  if (*((unsigned char *)a2 + 24)) {
    return (*(uint64_t (**)(kdu_compositor_buf *))(*(void *)a2 + 8))(a2);
  }
  else {
    return (*(uint64_t (**)(void))(*(void *)this + 64))();
  }
}

uint64_t kdrc_layer::init(uint64_t a1, jx_layer_source *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, char a8, char a9)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  int v29 = a2;
  if (*(void *)(a1 + 72) || *(void *)(a1 + 80)) {
    kdrc_layer::init();
  }
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = a2;
  *(unsigned char *)(a1 + 32) = 0;
  *(void *)(a1 + 36) = a3;
  *(void *)(a1 + 44) = a4;
  *(void *)(a1 + 52) = a5;
  *(void *)(a1 + 60) = a6;
  *(_DWORD *)(a1 + 236) = jpx_layer_source::get_layer_id((jpx_layer_source *)&v29);
  *(unsigned char *)(a1 + 33) = a7;
  *(unsigned char *)(a1 + 34) = a8;
  *(unsigned char *)(a1 + 35) = a9;
  *(unsigned char *)(a1 + 120) = 0;
  uint64_t result = jpx_layer_source::have_stream_headers(&v29);
  if (result)
  {
    *(void *)int v27 = 0;
    uint64_t v28 = jpx_layer_source::access_channels((jpx_layer_source *)&v29);
    int v26 = 0;
    jp2_channels::get_colour_mapping((jp2_channels *)&v28, 0, &v27[1], v27, &v26);
    int v13 = kdu_region_compositor::add_active_stream(*(kdu_region_compositor **)a1, v26, *(_DWORD *)(a1 + 236));
    *(void *)(a1 + 72) = v13;
    if (!v13)
    {
      uint64_t v25 = 0;
      long long v23 = 0u;
      long long v24 = 0u;
      kdu_error::kdu_error((kdu_error *)&v23, "Error in Kakadu Region Compositor:\n");
      (*(void (**)(long long *, const char *))(v23 + 16))(&v23, "Unable to create compositing layer (index, starting from 0, equals ");
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      *(_OWORD *)int v30 = 0u;
      if (BYTE8(v23)) {
        sprintf(v30, "%x");
      }
      else {
        sprintf(v30, "%d");
      }
      (*(void (**)(long long *, char *))(v23 + 16))(&v23, v30);
      (*(void (**)(long long *, const char *))(v23 + 16))(&v23, "), since its primary codestream cannot be opened.");
      kdu_error::~kdu_error((kdu_error *)&v23);
    }
    *((void *)v13 + 139) = a1;
    int v14 = v26;
    *(_WORD *)(a1 + 232) = 0;
    uint64_t v15 = *(void *)(a1 + 72);
    if (*(_DWORD *)(v15 + 64) <= *(_DWORD *)(v15 + 68))
    {
      if ((int)jp2_channels::get_num_colours((jp2_channels *)&v28) >= 1)
      {
        unsigned int v16 = 0;
        int v17 = -1;
        int v18 = -1;
        int v19 = -1;
        while (jp2_channels::get_opacity_mapping((jp2_channels *)&v28, v16, &v27[1], v27, &v26) && v26 != v14)
        {
          if (v16)
          {
            if (v26 != v19 || v27[1] != v18 || v27[0] != v17)
            {
              uint64_t v25 = 0;
              long long v23 = 0u;
              long long v24 = 0u;
              kdu_warning::kdu_warning((kdu_warning *)&v23, "Warning in Kakadu Region Compositor:\n");
              (*(void (**)(long long *, const char *))(v23 + 16))(&v23, "Unable to render compositing layer (index, starting from 0, equals ");
              long long v33 = 0u;
              long long v34 = 0u;
              long long v31 = 0u;
              long long v32 = 0u;
              *(_OWORD *)int v30 = 0u;
              if (BYTE8(v23)) {
                sprintf(v30, "%x");
              }
              else {
                sprintf(v30, "%d");
              }
              (*(void (**)(long long *, char *))(v23 + 16))(&v23, v30);
              (*(void (**)(long long *, const char *))(v23 + 16))(&v23, ") with alpha blending, since there are multiple distinct alpha channels for a single set of colour channels.");
              kdu_warning::~kdu_warning((kdu_warning *)&v23);
              break;
            }
          }
          else
          {
            int v17 = v27[0];
            int v18 = v27[1];
            int v19 = v26;
          }
          if ((int)++v16 >= (int)jp2_channels::get_num_colours((jp2_channels *)&v28))
          {
            if (v19 < 0) {
              goto LABEL_34;
            }
            int v20 = kdu_region_compositor::add_active_stream(*(kdu_region_compositor **)a1, v19, *(_DWORD *)(a1 + 236));
            *(void *)(a1 + 80) = v20;
            if (v20)
            {
              *((void *)v20 + 139) = a1;
              *(unsigned char *)(a1 + 232) = 1;
              *(unsigned char *)(a1 + 233) = *(unsigned char *)(*(void *)(a1 + 80) + 10);
              goto LABEL_34;
            }
            uint64_t v25 = 0;
            long long v23 = 0u;
            long long v24 = 0u;
            kdu_warning::kdu_warning((kdu_warning *)&v23, "Warning in Kakadu Region Compositor:\n");
            (*(void (**)(long long *, const char *))(v23 + 16))(&v23, "Unable to render compositing layer (index, starting from 0, equals ");
            long long v33 = 0u;
            long long v34 = 0u;
            long long v31 = 0u;
            long long v32 = 0u;
            *(_OWORD *)int v30 = 0u;
            if (BYTE8(v23)) {
              sprintf(v30, "%x");
            }
            else {
              sprintf(v30, "%d");
            }
            (*(void (**)(long long *, char *))(v23 + 16))(&v23, v30);
            (*(void (**)(long long *, const char *))(v23 + 16))(&v23, ") with alpha blending, since the codestream containing the alpha data cannot be opened.");
            kdu_warning::~kdu_warning((kdu_warning *)&v23);
            break;
          }
        }
      }
    }
    else
    {
      *(unsigned char *)(a1 + 232) = 1;
      *(unsigned char *)(a1 + 233) = *(unsigned char *)(v15 + 10);
    }
    int v19 = -1;
LABEL_34:
    *(void *)int v30 = 0;
    uint64_t v22 = 0;
    *(void *)&long long v23 = 0;
    uint64_t result = jpx_layer_source::get_codestream_registration((uint64_t *)&v29, 0, v30, &v23, &v22);
    int v26 = result;
    if ((result & 0x80000000) == 0)
    {
      unsigned int v21 = 1;
      do
      {
        if (result == v14)
        {
          *(void *)(a1 + 88) = v23;
          *(void *)(a1 + 104) = v22;
        }
        else if (result == v19)
        {
          *(void *)(a1 + 96) = v23;
          *(void *)(a1 + 112) = v22;
        }
        uint64_t result = jpx_layer_source::get_codestream_registration((uint64_t *)&v29, v21++, v30, &v23, &v22);
        int v26 = result;
      }
      while ((result & 0x80000000) == 0);
    }
  }
  return result;
}

void sub_1886DD114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

kdrc_stream *kdu_region_compositor::add_active_stream(kdu_region_compositor *this, int a2, int a3)
{
  if (*((void *)this + 1)) {
    a3 = 0;
  }
  uint64_t v5 = *((void *)this + 62);
  if (v5)
  {
    uint64_t v6 = *((void *)this + 62);
    do
    {
      if (*(_DWORD *)(v6 + 1104) == a2 && (*(_DWORD *)(v6 + 1108) & 0x80000000) == 0) {
        break;
      }
      uint64_t v6 = *(void *)(v6 + 1128);
    }
    while (v6);
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *((void *)this + 63);
  if (!v7) {
    goto LABEL_35;
  }
  char v8 = 0;
  unsigned int v9 = (void *)((char *)this + 504);
  uint64_t v10 = *((void *)this + 63);
  while (1)
  {
    int v11 = (kdrc_stream *)v10;
    if (*(_DWORD *)(v10 + 1104) == a2)
    {
      if (!v6)
      {
        if (*(int *)(v10 + 1108) < 0) {
          uint64_t v6 = 0;
        }
        else {
          uint64_t v6 = v10;
        }
      }
      if (a3 < 0 || *(_DWORD *)(v10 + 1108) == a3) {
        break;
      }
    }
    uint64_t v10 = *(void *)(v10 + 1128);
    char v8 = v11;
    if (!v10)
    {
      uint64_t v12 = 0;
      while (1)
      {
        uint64_t v13 = v7;
        if ((*(_DWORD *)(v7 + 1108) & 0x80000000) != 0 && *(_DWORD *)(v7 + 1104) == a2) {
          break;
        }
        uint64_t v7 = *(void *)(v7 + 1128);
        uint64_t v12 = v13;
        if (!v7) {
          goto LABEL_35;
        }
      }
      if (v12) {
        uint64_t v15 = (void *)(v12 + 1128);
      }
      else {
        uint64_t v15 = (void *)((char *)this + 504);
      }
      *uint64_t v15 = *(void *)(v7 + 1128);
      kdrc_stream::~kdrc_stream((kdrc_stream *)v7);
      MEMORY[0x18C11C0E0]();
LABEL_35:
      operator new();
    }
  }
  if (v8) {
    unsigned int v9 = (void *)((char *)v8 + 1128);
  }
  *unsigned int v9 = *(void *)(v10 + 1128);
  *(void *)(v10 + 1128) = v5;
  *((void *)this + 62) = v10;
  *(unsigned char *)(v10 + 1125) = 1;
  uint64_t v14 = *(void *)(v10 + 1136);
  if (!v14)
  {
    uint64_t v19 = 0;
    *(_OWORD *)int v17 = 0u;
    long long v18 = 0u;
    kdu_error::kdu_error((kdu_error *)v17, "Error in Kakadu Region Compositor:\n");
    (*(void (**)(unsigned int *, const char *))(*(void *)v17 + 16))(v17, "Attempting to open a codestream which has already been found to contain an error.");
    kdu_error::~kdu_error((kdu_error *)v17);
  }
  kdrc_codestream::move_to_head(v14, (kdrc_stream *)v10);
  kdrc_stream::set_error_level(v11, *((_DWORD *)this + 78));
  *((_DWORD *)v11 + 14) = *((_DWORD *)this + 82);
  return v11;
}

void sub_1886DD480(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  kdu_region_compositor::remove_stream(v1, v2, 1);
  jpx_input_box::close((jpx_input_box *)(v1 + 32));
  JUMPOUT(0x1886DD40CLL);
}

void sub_1886DD4D4()
{
  MEMORY[0x18C11C0E0](v0, 0x10B0C4024755E16);
  JUMPOUT(0x1886DD4F0);
}

kdrc_stream *kdrc_layer::init(uint64_t a1, mj2_video_source *a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a1 + 72) || *(void *)(a1 + 80)) {
    kdrc_layer::init();
  }
  char v7 = a4;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = a3;
  *(_DWORD *)(a1 + 28) = a4;
  *(unsigned char *)(a1 + 32) = 0;
  *(void *)(a1 + 44) = 0;
  *(void *)(a1 + 36) = 0;
  *(void *)(a1 + 52) = a5;
  *(void *)(a1 + 60) = a6;
  *(_DWORD *)(a1 + 236) = mj2_video_source::get_track_idx(a2) - 1;
  *(unsigned char *)(a1 + 120) = 0;
  if ((a3 & 0x80000000) != 0 || (*(int (**)(mj2_video_source *))(*(void *)a2 + 96))(a2) <= (int)a3)
  {
    uint64_t v16 = 0;
    long long v14 = 0u;
    long long v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu Region Compositor:\n");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "Unable to create compositing layer for MJ2 track ");
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    *(_OWORD *)int v17 = 0u;
    if (BYTE8(v14)) {
      sprintf(v17, "%x");
    }
    else {
      sprintf(v17, "%d");
    }
    (*(void (**)(long long *, char *))(v14 + 16))(&v14, v17);
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, ": requested frame index is out of range.");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  int v10 = v7 & 1;
  if (v10 && !(*(unsigned int (**)(mj2_video_source *))(*(void *)a2 + 80))(a2))
  {
    uint64_t v16 = 0;
    long long v14 = 0u;
    long long v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu Region Compositor:\n");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "Unable to create compositing layer for MJ2 track ");
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    *(_OWORD *)int v17 = 0u;
    if (BYTE8(v14)) {
      sprintf(v17, "%x");
    }
    else {
      sprintf(v17, "%d");
    }
    (*(void (**)(long long *, char *))(v14 + 16))(&v14, v17);
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, ": requested field does not exist (source is progressive, not interlaced).");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  (*(void (**)(mj2_video_source *, uint64_t))(*(void *)a2 + 104))(a2, a3);
  uint64_t result = (kdrc_stream *)mj2_video_source::can_open_stream(a2, v10);
  if (result)
  {
    int stream_idx = mj2_video_source::get_stream_idx(a2, v10);
    if (stream_idx < 0) {
      kdrc_layer::init();
    }
    uint64_t result = kdu_region_compositor::add_active_stream(*(kdu_region_compositor **)a1, stream_idx, *(_DWORD *)(a1 + 236));
    *(void *)(a1 + 72) = result;
    if (!result)
    {
      uint64_t v16 = 0;
      long long v14 = 0u;
      long long v15 = 0u;
      kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu Region Compositor:\n");
      (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "Unable to create compositing layer for MJ2 track ");
      long long v20 = 0u;
      long long v21 = 0u;
      long long v18 = 0u;
      long long v19 = 0u;
      *(_OWORD *)int v17 = 0u;
      if (BYTE8(v14)) {
        sprintf(v17, "%x");
      }
      else {
        sprintf(v17, "%d");
      }
      (*(void (**)(long long *, char *))(v14 + 16))(&v14, v17);
      (*(void (**)(long long *, const char *))(v14 + 16))(&v14, ": codestream cannot be opened.");
      kdu_error::~kdu_error((kdu_error *)&v14);
    }
    *((void *)result + 139) = a1;
    *(_WORD *)(a1 + 232) = 0;
    uint64_t v13 = *(void *)(a1 + 72);
    if (*(_DWORD *)(v13 + 64) > *(_DWORD *)(v13 + 68))
    {
      *(unsigned char *)(a1 + 232) = 1;
      *(unsigned char *)(a1 + 233) = *(unsigned char *)(v13 + 10);
    }
    *(void *)(a1 + 104) = 0x100000001;
    *(void *)(a1 + 88) = 0x100000001;
  }
  return result;
}

void sub_1886DD9B8(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886DD9C4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

uint64_t kdrc_layer::change_frame(kdrc_layer *this, int a2, int a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)this + 9);
  uint64_t result = *((void *)this + 2);
  if (v5)
  {
    if (result)
    {
      if (*((_DWORD *)this + 6) != a2 || *((unsigned char *)this + 32))
      {
        if (a2 < 0 || (*(int (**)(uint64_t))(*(void *)result + 96))(result) <= a2)
        {
          uint64_t v28 = 0;
          memset(v27, 0, sizeof(v27));
          kdu_error::kdu_error((kdu_error *)v27, "Error in Kakadu Region Compositor:\n");
          (*(void (**)(_OWORD *, const char *))(*(void *)&v27[0] + 16))(v27, "Requested frame index for MJ2 track ");
          long long v32 = 0u;
          long long v33 = 0u;
          long long v30 = 0u;
          long long v31 = 0u;
          *(_OWORD *)int v29 = 0u;
          if (BYTE8(v27[0])) {
            sprintf(v29, "%x");
          }
          else {
            sprintf(v29, "%d");
          }
          (*(void (**)(_OWORD *, char *))(*(void *)&v27[0] + 16))(v27, v29);
          (*(void (**)(_OWORD *, const char *))(*(void *)&v27[0] + 16))(v27, " is out of range.");
          kdu_error::~kdu_error((kdu_error *)v27);
        }
        uint64_t v8 = 0;
        *((_DWORD *)this + 6) = a2;
        char v9 = 1;
        *((unsigned char *)this + 32) = 1;
        do
        {
          while (1)
          {
            char v10 = v9;
            int v11 = (char *)this + 8 * v8;
            uint64_t v13 = *((void *)v11 + 9);
            uint64_t v12 = (kdrc_stream **)(v11 + 72);
            char v9 = v13;
            if (!v13) {
              break;
            }
            unsigned int v14 = *((_DWORD *)this + 6);
            int v15 = *((_DWORD *)this + 7) & 1 ^ v8;
            if (v15) {
              BOOL v16 = 0;
            }
            else {
              BOOL v16 = *((_DWORD *)this + 7) == 3;
            }
            if (v16) {
              uint64_t v17 = v14 + 1;
            }
            else {
              uint64_t v17 = v14;
            }
            (*(void (**)(void, uint64_t))(**((void **)this + 2) + 104))(*((void *)this + 2), v17);
            uint64_t result = mj2_video_source::can_open_stream(*((mj2_video_source **)this + 2), v15);
            if (!result) {
              return result;
            }
            if (a3)
            {
              char v9 = 0;
              uint64_t v8 = 1;
              if ((v10 & 1) == 0) {
                goto LABEL_31;
              }
            }
            else
            {
              kdrc_stream::change_frame(*v12, v17);
              char v9 = 0;
              uint64_t v8 = 1;
              if ((v10 & 1) == 0) {
                goto LABEL_41;
              }
            }
          }
          uint64_t v8 = 1;
        }
        while ((v10 & 1) != 0);
        if (!a3) {
          goto LABEL_41;
        }
LABEL_31:
        uint64_t v18 = 0;
        char v19 = 1;
        do
        {
          char v20 = v19;
          long long v21 = (char *)this + 8 * v18;
          uint64_t v23 = *((void *)v21 + 9);
          uint64_t v22 = (kdrc_stream **)(v21 + 72);
          if (v23)
          {
            unsigned int v24 = *((_DWORD *)this + 6);
            if ((*((_DWORD *)this + 7) & 1) == v18 && *((_DWORD *)this + 7) == 3) {
              uint64_t v26 = v24 + 1;
            }
            else {
              uint64_t v26 = v24;
            }
            (*(void (**)(void, uint64_t))(**((void **)this + 2) + 104))(*((void *)this + 2), v26);
            kdrc_stream::change_frame(*v22, v26);
          }
          char v19 = 0;
          uint64_t v18 = 1;
        }
        while ((v20 & 1) != 0);
LABEL_41:
        *((unsigned char *)this + 32) = 0;
      }
      return 1;
    }
  }
  else
  {
    if (result) {
      *((_DWORD *)this + 6) = a2;
    }
    kdrc_layer::reinit(this);
    return *((void *)this + 9) != 0;
  }
  return result;
}

void sub_1886DDD18(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886DDD24()
{
  _Unwind_Resume(v0);
}

BOOL kdrc_layer::reinit(kdrc_layer *this)
{
  if (!*((void *)this + 9))
  {
    int v2 = (jx_layer_source *)*((void *)this + 1);
    if (v2) {
      kdrc_layer::init((uint64_t)this, v2, *(void *)((char *)this + 36), *(void *)((char *)this + 44), *(void *)((char *)this + 52), *(void *)((char *)this + 60), *((unsigned char *)this + 33), *((unsigned char *)this + 34), *((unsigned char *)this + 35));
    }
    else {
      kdrc_layer::init((uint64_t)this, *((mj2_video_source **)this + 2), *((unsigned int *)this + 6), *((_DWORD *)this + 7), *(void *)((char *)this + 52), *(void *)((char *)this + 60));
    }
  }
  return *((void *)this + 9) != 0;
}

__n128 *kdrc_layer::activate(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, char a6, char a7, char a8, unsigned int a9, int a10)
{
  if (*(void *)(a1 + 72))
  {
    if (*(void *)(a1 + 176)) {
      kdrc_layer::activate();
    }
    uint64_t v17 = 0;
    unint64_t v35 = HIDWORD(a2);
    unint64_t v18 = HIDWORD(a4);
    char v19 = 1;
    do
    {
      char v20 = v19;
      uint64_t v21 = a1 + 8 * v17;
      unsigned int v24 = *(__n128 **)(v21 + 72);
      uint64_t v23 = v21 + 72;
      uint64_t result = v24;
      if (v24)
      {
        if (!result[70].n128_u8[5])
        {
          uint64_t result = (__n128 *)kdu_region_compositor::add_active_stream(*(kdu_region_compositor **)a1, result[69].n128_i32[0], result[69].n128_i32[1]);
          if (result != *(__n128 **)v23) {
            kdrc_layer::activate();
          }
        }
        uint64_t result = (__n128 *)kdrc_stream::set_mode(result, 0xFFFFFFFFLL, 0);
        *(void *)(*(void *)v23 + 1112) = a1;
      }
      char v19 = 0;
      uint64_t v17 = 1;
    }
    while ((v20 & 1) != 0);
    *(unsigned char *)(a1 + 200) = 0;
    if (*(_DWORD *)(a1 + 56) != v18 || *(_DWORD *)(a1 + 52) != a4 || *(void *)(a1 + 60) != a5) {
      *(unsigned char *)(a1 + 120) = 0;
    }
    *(void *)(a1 + 52) = a4;
    *(void *)(a1 + 60) = a5;
    *(unsigned char *)(a1 + 33) = a6;
    *(unsigned char *)(a1 + 34) = a7;
    *(unsigned char *)(a1 + 35) = a8;
    if (*(void *)(a1 + 8))
    {
      uint64_t v25 = a3;
      if (*(_DWORD *)(a1 + 40) != v35
        || *(_DWORD *)(a1 + 36) != a2
        || (uint64_t v25 = a3, *(void *)(a1 + 44) != a3))
      {
        *(unsigned char *)(a1 + 120) = 0;
      }
      *(void *)(a1 + 36) = a2;
      *(void *)(a1 + 44) = v25;
    }
    else if (*(_DWORD *)(a1 + 28) != a10 {
           || (*(_DWORD *)(a1 + 24) != a9 || *(unsigned char *)(a1 + 32))
    }
           && (uint64_t result = (__n128 *)kdrc_layer::change_frame((kdrc_layer *)a1, a9, 1), (result & 1) == 0))
    {
      uint64_t v27 = 0;
      char v28 = 1;
      do
      {
        char v29 = v28;
        uint64_t v30 = a1 + 8 * v27;
        long long v33 = *(kdrc_stream **)(v30 + 72);
        long long v32 = (void *)(v30 + 72);
        long long v31 = v33;
        if (v33) {
          kdu_region_compositor::remove_stream(*(void *)a1, v31, 1);
        }
        char v28 = 0;
        *long long v32 = 0;
        uint64_t v27 = 1;
      }
      while ((v29 & 1) != 0);
      return (__n128 *)kdrc_layer::reinit((kdrc_layer *)a1);
    }
  }
  else
  {
    uint64_t v26 = *(jx_layer_source **)(a1 + 8);
    if (v26)
    {
      return (__n128 *)kdrc_layer::init(a1, v26, a2, a3, a4, a5, a6, a7, a8);
    }
    else
    {
      uint64_t v34 = *(mj2_video_source **)(a1 + 16);
      return (__n128 *)kdrc_layer::init(a1, v34, a9, a10, a4, a5);
    }
  }
  return result;
}

uint64_t kdrc_layer::deactivate(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = 0;
  char v3 = 1;
  do
  {
    char v4 = v3;
    uint64_t v5 = *(kdrc_stream **)(v1 + 8 * v2 + 72);
    if (v5) {
      this = kdu_region_compositor::remove_stream(*(void *)v1, v5, 0);
    }
    char v3 = 0;
    uint64_t v2 = 1;
  }
  while ((v4 & 1) != 0);
  uint64_t v6 = *(void **)(v1 + 176);
  if (v6)
  {
    *uint64_t v6 = 0;
    v6[10] = 0;
    v6[11] = 0;
    uint64_t v7 = v6[13];
    if (v7)
    {
      uint64_t v8 = v6[16];
      do
      {
        uint64_t v9 = v7;
        uint64_t v7 = *(void *)(v7 + 24);
        *(void *)(v9 + 24) = v8;
        uint64_t v8 = v9;
      }
      while (v7);
      v6[13] = 0;
      v6[16] = v9;
    }
    v6[14] = 0;
    v6[15] = 0;
    *(void *)(v1 + 176) = 0;
  }
  *(unsigned char *)(v1 + 200) = 0;
  *(unsigned char *)(v1 + 234) = 0;
  char v10 = *(kdu_compositor_buf **)(v1 + 184);
  if (v10)
  {
    this = kdu_region_compositor::internal_delete_buffer(*(kdu_region_compositor **)v1, v10);
    *(void *)(v1 + 184) = 0;
  }
  return this;
}

uint64_t kdrc_layer::set_scale(kdrc_layer *this, int a2, int a3, unsigned __int8 a4, float a5, int *a6)
{
  unsigned __int8 v29 = a3;
  unsigned __int8 v28 = a4;
  *a6 = 0;
  if (!*((void *)this + 9)) {
    return 0;
  }
  int v9 = a3;
  if (*((unsigned char *)this + 32)) {
    kdrc_layer::change_frame(this, *((_DWORD *)this + 6), 0);
  }
  int v12 = *((unsigned __int8 *)this + 33);
  int v13 = *((unsigned __int8 *)this + 35);
  if (a2)
  {
    if (*((unsigned char *)this + 34)) {
      unsigned __int8 v28 = a4 ^ 1;
    }
    if (v13)
    {
      unsigned int v14 = &v29;
LABEL_13:
      *unsigned int v14 = v9 ^ 1;
      int v9 = v29;
    }
  }
  else
  {
    if (*((unsigned char *)this + 34))
    {
      v9 ^= 1u;
      unsigned __int8 v29 = v9;
    }
    if (v13)
    {
      unsigned int v14 = &v28;
      LOBYTE(v9) = a4;
      goto LABEL_13;
    }
  }
  int v15 = v12 ^ a2;
  if (*((unsigned char *)this + 120))
  {
    int v16 = v28;
    BOOL v17 = *((unsigned __int8 *)this + 122) == v9
       && *((unsigned __int8 *)this + 123) == v28
       && *((unsigned __int8 *)this + 121) == v15
       && *((float *)this + 31) == a5;
  }
  else
  {
    BOOL v17 = 0;
    int v16 = v28;
  }
  uint64_t v18 = 0;
  *((unsigned char *)this + 120) = 0;
  *((unsigned char *)this + 122) = v9;
  *((unsigned char *)this + 123) = v16;
  *((unsigned char *)this + 121) = v15;
  char v19 = 1;
  *((float *)this + 31) = a5;
  while (1)
  {
    char v20 = v19;
    uint64_t v21 = (void *)((char *)this + 8 * v18);
    uint64_t v22 = v21[9];
    if (v22)
    {
      long long v27 = 0uLL;
      *(void *)&long long v27 = kdrc_stream::set_scale(v22, *(void *)((char *)this + 36), *(void *)((char *)this + 44), *(void *)((char *)this + 52), *(void *)((char *)this + 60), v21[11], v21[13], v15 != 0, a5, v9 != 0, v16 != 0, a6);
      *((void *)&v27 + 1) = v23;
      if (v20) {
        *((_OWORD *)this + 8) = v27;
      }
      else {
        kdu_dims::operator&=((_DWORD *)this + 32, (int *)&v27);
      }
      if (*((int *)this + 35) < 1 || *((int *)this + 34) <= 0) {
        break;
      }
    }
    char v19 = 0;
    uint64_t v18 = 1;
    if ((v20 & 1) == 0)
    {
      *((unsigned char *)this + 120) = 1;
      *((void *)this + 26) = 0;
      if (!v17)
      {
        unsigned int v24 = (kdu_compositor_buf *)*((void *)this + 18);
        if (v24)
        {
          kdu_region_compositor::internal_delete_buffer(*(kdu_region_compositor **)this, v24);
          *((void *)this + 18) = 0;
        }
        uint64_t v25 = (kdu_compositor_buf *)*((void *)this + 23);
        if (v25)
        {
          kdu_region_compositor::internal_delete_buffer(*(kdu_region_compositor **)this, v25);
          *((void *)this + 23) = 0;
          *((unsigned char *)this + 200) = 0;
        }
      }
      return *((void *)this + 16);
    }
  }
  return 0;
}

uint64_t kdrc_layer::set_buffer_surface(uint64_t result, void *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, int a7)
{
  if (a6) {
    int v7 = 0;
  }
  else {
    int v7 = a7;
  }
  *(void *)(result + 208) = a6;
  *(void *)(result + 216) = a2;
  *(void *)(result + 224) = a3;
  if (*(void *)(result + 72))
  {
    uint64_t v8 = (void **)result;
    if (*(unsigned char *)(result + 120))
    {
      if (a6)
      {
        BOOL v14 = 1;
      }
      else if (*(void *)(result + 176))
      {
        BOOL v14 = *(unsigned char *)(result + 234) != 0;
      }
      else
      {
        BOOL v14 = 0;
      }
      int v15 = *(kdu_compositor_buf **)(result + 144);
      uint64_t v27 = *(void *)(result + 160);
      uint64_t v28 = *(void *)(result + 152);
      unsigned __int8 v29 = a4;
      uint64_t v30 = a5;
      kdu_dims::operator&=(&v29, (int *)(result + 128));
      uint64_t v16 = v30;
      v8[19] = v29;
      v8[20] = (void *)v16;
      BOOL v17 = v8[18];
      if (v17 && *((_DWORD *)v8 + 43) >= SHIDWORD(v16) && *((_DWORD *)v8 + 42) >= (int)v16)
      {
        (*(void (**)(void *, BOOL))(*v17 + 16))(v17, v14);
        uint64_t buffer = (uint64_t)v8[18];
      }
      else
      {
        uint64_t buffer = kdu_region_compositor::internal_allocate_buffer((uint64_t)*v8, v16, v8 + 21);
        v8[18] = (void *)buffer;
      }
      if (*((unsigned char *)v8 + 232)) {
        int v19 = 0xFFFFFF;
      }
      else {
        int v19 = -1;
      }
      initialize_buffer_surface(buffer, (unint64_t)v8[19], (uint64_t)v8[20], 0, 0, 0, v19, v7);
      if (v15 && v15 != (kdu_compositor_buf *)v8[18]) {
        kdu_region_compositor::internal_delete_buffer((kdu_region_compositor *)*v8, v15);
      }
      uint64_t v20 = (uint64_t)v8[22];
      if (v20)
      {
        if (!*((unsigned char *)v8 + 234) && kdrc_overlay::set_buffer_surface(v20, 0, (uint64_t)v8[19], (uint64_t)v8[20], 0))
        {
          *((unsigned char *)v8 + 234) = 1;
          if (!a6)
          {
            if (v14) {
              kdrc_layer::set_buffer_surface();
            }
            if (v8[30] || v8[31] || a2 != a4 || a3 != a5 || v8[23]) {
              kdrc_layer::set_buffer_surface();
            }
            kdu_region_compositor::donate_compositing_buffer(*v8, (uint64_t)v8[18], (uint64_t)v8[19], (uint64_t)v8[20], (uint64_t)v8[21]);
            uint64_t v21 = (uint64_t)v8[18];
            v8[26] = (void *)v21;
            v8[18] = (void *)kdu_region_compositor::internal_allocate_buffer((uint64_t)*v8, v16, v8 + 21);
            if (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v21 + 16))(v21, 1) & 1) == 0) {
              initialize_buffer_surface(v21, (unint64_t)v8[19], (uint64_t)v8[20], 0, 0, 0, -1, 0);
            }
            initialize_buffer_surface((uint64_t)v8[18], (unint64_t)v8[19], (uint64_t)v8[20], v21, (uint64_t)v8[19], (uint64_t)v8[20], -1, 0);
          }
        }
        if (v8[22] && *((unsigned char *)v8 + 234))
        {
          uint64_t v22 = (kdu_compositor_buf *)v8[23];
          if (!v22 || *((_DWORD *)v8 + 49) < SHIDWORD(v16) || (uint64_t v23 = (uint64_t)v8[23], *((_DWORD *)v8 + 48) < (int)v16))
          {
            uint64_t v23 = kdu_region_compositor::internal_allocate_buffer((uint64_t)*v8, v16, v8 + 24);
            v8[23] = (void *)v23;
          }
          initialize_buffer_surface(v23, (unint64_t)v8[19], (uint64_t)v8[20], (uint64_t)v22, v28, v27, 0xFFFFFF, 0);
          if (v22)
          {
            if (v22 != (kdu_compositor_buf *)v8[23])
            {
              kdu_region_compositor::internal_delete_buffer((kdu_region_compositor *)*v8, v22);
              uint64_t v22 = (kdu_compositor_buf *)v8[23];
            }
          }
          else
          {
            uint64_t v22 = (kdu_compositor_buf *)v8[23];
          }
          kdrc_overlay::set_buffer_surface((uint64_t)v8[22], (uint64_t)v22, (uint64_t)v8[19], (uint64_t)v8[20], 0);
          while ((kdrc_overlay::process((kdrc_overlay *)v8[22], (kdu_dims *)&v29) & 1) != 0)
            ;
        }
      }
      uint64_t v24 = 0;
      char v25 = 1;
      do
      {
        char v26 = v25;
        uint64_t result = (uint64_t)v8[v24 + 9];
        if (result) {
          uint64_t result = kdrc_stream::set_buffer_surface(result, (uint64_t)v8[18], (uint64_t)v8[19], (uint64_t)v8[20], 1);
        }
        char v25 = 0;
        uint64_t v24 = 1;
      }
      while ((v26 & 1) != 0);
    }
  }
  return result;
}

uint64_t kdu_region_compositor::internal_allocate_buffer(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
  if (!result) {
    operator new[]();
  }
  *(void *)(result + 16) = *a3;
  return result;
}

uint64_t initialize_buffer_surface(uint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8)
{
  uint64_t v13 = result;
  v79[0] = a5;
  v79[1] = a6;
  if (!*(unsigned char *)(result + 27)) {
    uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)result + 24))(result, 0);
  }
  int v14 = *(_DWORD *)(v13 + 40);
  uint64_t v15 = *(int *)(v13 + 44);
  uint64_t v16 = *(char **)(v13 + 32);
  if (!a4) {
    goto LABEL_12;
  }
  if (!*(unsigned char *)(a4 + 27)) {
    uint64_t result = (*(uint64_t (**)(uint64_t, void))(*(void *)a4 + 24))(a4, 0);
  }
  uint64_t v17 = *(void *)(a4 + 32);
  if (v17
    && (uint64_t v18 = *(int *)(a4 + 44),
        unint64_t v80 = a2,
        uint64_t v81 = a3,
        uint64_t result = kdu_dims::operator&=(&v80, (int *)v79),
        uint64_t v19 = v81,
        (int)v81 >= 1)
    && (unint64_t v20 = HIDWORD(v81), v81 > 0))
  {
    unint64_t v21 = HIDWORD(a2);
    unint64_t v22 = HIDWORD(v80);
    int v23 = HIDWORD(v80) - HIDWORD(a2);
    int v24 = v80 - a2;
    int v25 = HIDWORD(v79[0]);
    int v26 = HIDWORD(v80) - HIDWORD(a2) + HIDWORD(v81);
    int v27 = v81 + v80 - a2;
    int v28 = HIDWORD(v80) - HIDWORD(v79[0]) + (v80 - LODWORD(v79[0])) * v18;
    uint64_t v29 = v17 + 4 * v28;
    if ((int)v80 - LODWORD(v79[0]) <= (int)v80 - (int)a2)
    {
      uint64_t v35 = v28;
      uint64_t v36 = &v16[4 * (int)v15 * ((int)a3 - 1)];
      uint64_t v37 = ((int)v81 - 1) * (int)v18;
      uint64_t v38 = v29 + 4 * v37;
      int v39 = a3 - v27;
      unint64_t v40 = HIDWORD(a3);
      if (a8)
      {
        v36 -= 4 * v39 * (int)v15;
      }
      else if (v39 >= 1)
      {
        do
        {
          if (SHIDWORD(a3) >= 1)
          {
            uint64_t v54 = 0;
            unsigned int v55 = HIDWORD(a3) + 1;
            do
            {
              *(_DWORD *)&v36[v54] = a7;
              --v55;
              v54 += 4;
            }
            while (v55 > 1);
          }
          v36 -= 4 * v15;
          BOOL v33 = __OFSUB__(v39--, 1);
        }
        while (!((v39 < 0) ^ v33 | (v39 == 0)));
      }
      uint64_t result = v23;
      uint64_t v56 = -v15;
      uint64_t v57 = a3 >> 32;
      if (HIDWORD(a3) - v26 < 1) {
        char v58 = 1;
      }
      else {
        char v58 = a8;
      }
      if (v23 < 1) {
        char v59 = 1;
      }
      else {
        char v59 = a8;
      }
      int v60 = v20 + 1;
      uint64_t v61 = -4 * v18;
      unsigned int v62 = v21 + v40 - v22 - v20 + 1;
      uint64_t v63 = 4 * (v19 >> 32) + 4 * v37 + 4 * v35 + v17 - 4;
      do
      {
        if (v25 <= (int)v21)
        {
          if (a8)
          {
            int v65 = &v36[4 * v23];
          }
          else
          {
            unsigned int v72 = v23 + 1;
            int v65 = v36;
            if (v23 >= 1)
            {
              do
              {
                *(_DWORD *)int v65 = a7;
                v65 += 4;
                --v72;
              }
              while (v72 > 1);
            }
          }
          uint64_t v73 = 0;
          int v74 = v60;
          do
          {
            *(_DWORD *)&v65[v73] = *(_DWORD *)(v38 + v73);
            --v74;
            v73 += 4;
          }
          while (v74 > 1);
          if ((v58 & 1) == 0)
          {
            double v75 = &v65[v73];
            unsigned int v76 = v62;
            do
            {
              *(_DWORD *)double v75 = a7;
              v75 += 4;
              --v76;
            }
            while (v76 > 1);
          }
        }
        else
        {
          if (a8)
          {
            unsigned int v64 = &v36[4 * v26];
          }
          else
          {
            unsigned int v64 = &v36[4 * v57];
            if ((int)v40 - v26 >= 1)
            {
              unsigned int v66 = v62;
              do
              {
                *((_DWORD *)v64 - 1) = a7;
                v64 -= 4;
                --v66;
              }
              while (v66 > 1);
            }
          }
          int v67 = (int *)v63;
          int v68 = v60;
          do
          {
            int v69 = *v67--;
            *((_DWORD *)v64 - 1) = v69;
            v64 -= 4;
            --v68;
          }
          while (v68 > 1);
          if ((v59 & 1) == 0)
          {
            uint64_t v70 = -4;
            unsigned int v71 = v23 + 1;
            do
            {
              *(_DWORD *)&v64[v70] = a7;
              --v71;
              v70 -= 4;
            }
            while (v71 > 1);
          }
        }
        v36 += 4 * v56;
        v38 += v61;
        v63 += v61;
        BOOL v33 = __OFSUB__(v19, 1);
        LODWORD(v19) = v19 - 1;
      }
      while (!(((int)v19 < 0) ^ v33 | (v19 == 0)));
      if (v24 >= 1 && (a8 & 1) == 0)
      {
        do
        {
          if ((int)v40 >= 1)
          {
            unsigned int v77 = v40 + 1;
            double v78 = v36;
            do
            {
              *(_DWORD *)double v78 = a7;
              v78 += 4;
              --v77;
            }
            while (v77 > 1);
          }
          v36 += 4 * v56;
          BOOL v33 = __OFSUB__(v24--, 1);
        }
        while (!((v24 < 0) ^ v33 | (v24 == 0)));
      }
    }
    else
    {
      if (a8)
      {
        v16 += 4 * (int)v15 * v24;
      }
      else if (v24 >= 1)
      {
        do
        {
          if (SHIDWORD(a3) >= 1)
          {
            unsigned int v41 = HIDWORD(a3) + 1;
            uint64_t v42 = v16;
            do
            {
              *v42++ = a7;
              --v41;
            }
            while (v41 > 1);
          }
          v16 += 4 * v15;
          BOOL v33 = __OFSUB__(v24--, 1);
        }
        while (!((v24 < 0) ^ v33 | (v24 == 0)));
      }
      if (HIDWORD(a3) - v26 < 1) {
        char v43 = 1;
      }
      else {
        char v43 = a8;
      }
      uint64_t result = (v20 + 1);
      unsigned int v44 = HIDWORD(a2) + HIDWORD(a3) - v22 - v20 + 1;
      do
      {
        if (a8)
        {
          long long v45 = &v16[4 * v23];
        }
        else
        {
          unsigned int v46 = v23 + 1;
          long long v45 = v16;
          if (v23 >= 1)
          {
            do
            {
              *(_DWORD *)long long v45 = a7;
              v45 += 4;
              --v46;
            }
            while (v46 > 1);
          }
        }
        uint64_t v47 = 0;
        int v48 = result;
        do
        {
          *(_DWORD *)&v45[v47] = *(_DWORD *)(v29 + v47);
          --v48;
          v47 += 4;
        }
        while (v48 > 1);
        if ((v43 & 1) == 0)
        {
          int v49 = &v45[v47];
          unsigned int v50 = v44;
          do
          {
            *(_DWORD *)int v49 = a7;
            v49 += 4;
            --v50;
          }
          while (v50 > 1);
        }
        v16 += 4 * v15;
        v29 += 4 * v18;
        BOOL v33 = __OFSUB__(v19, 1);
        LODWORD(v19) = v19 - 1;
      }
      while (!(((int)v19 < 0) ^ v33 | (v19 == 0)));
      if ((a8 & 1) == 0)
      {
        int v51 = a3 - v27;
        if ((int)a3 - v27 >= 1)
        {
          do
          {
            if (SHIDWORD(a3) >= 1)
            {
              unsigned int v52 = HIDWORD(a3) + 1;
              unint64_t v53 = v16;
              do
              {
                *v53++ = a7;
                --v52;
              }
              while (v52 > 1);
            }
            v16 += 4 * v15;
            BOOL v33 = __OFSUB__(v51--, 1);
          }
          while (!((v51 < 0) ^ v33 | (v51 == 0)));
        }
      }
    }
  }
  else
  {
LABEL_12:
    if ((a8 & 1) == 0)
    {
      if (v14 == 4)
      {
        if ((int)a3 >= 1)
        {
          unint64_t v30 = HIDWORD(a3);
          do
          {
            if ((int)v30 >= 1)
            {
              unsigned int v31 = HIDWORD(a3) + 1;
              long long v32 = v16;
              do
              {
                *v32++ = a7;
                --v31;
              }
              while (v31 > 1);
            }
            v16 += 4 * v15;
            BOOL v33 = __OFSUB__(a3, 1);
            LODWORD(a3) = a3 - 1;
          }
          while (!(((int)a3 < 0) ^ v33 | (a3 == 0)));
        }
      }
      else if ((int)a3 >= 1)
      {
        unsigned int v34 = a3 + 1;
        do
        {
          uint64_t result = (uint64_t)memset(v16, 255, v14 * HIDWORD(a3));
          --v34;
        }
        while (v34 > 1);
      }
    }
  }
  return result;
}

void *kdu_region_compositor::donate_compositing_buffer(void *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (result[49]) {
    kdu_region_compositor::donate_compositing_buffer();
  }
  if (result[50] != a3 || result[51] != a4) {
    kdu_region_compositor::donate_compositing_buffer();
  }
  uint64_t v5 = result[59];
  if (!v5 || !*(unsigned char *)(v5 + 234)) {
    kdu_region_compositor::donate_compositing_buffer();
  }
  result[49] = a2;
  result[52] = a5;
  return result;
}

uint64_t kdrc_layer::configure_overlay(uint64_t this, char a2, int a3, int a4)
{
  uint64_t v4 = *(void *)(this + 72);
  if (v4)
  {
    uint64_t v5 = this;
    if (*(void *)(this + 8))
    {
      if (a2)
      {
        this = *(void *)(this + 176);
        if (this) {
          goto LABEL_8;
        }
        uint64_t v8 = *(void **)(v4 + 48);
        *(void *)(v5 + 176) = v8;
        if (v8) {
          *uint64_t v8 = *(void *)v5;
        }
        kdrc_layer::update_overlay(v5, 0, 1);
        this = *(void *)(v5 + 176);
        if (this)
        {
LABEL_8:
          this = kdrc_overlay::update_config((kdrc_overlay *)this, a3, a4);
          if (this)
          {
            this = *(void *)(v5 + 184);
            if (this) {
              this = initialize_buffer_surface(this, *(void *)(v5 + 152), *(void *)(v5 + 160), 0, 0, 0, 0xFFFFFF, 0);
            }
            *(unsigned char *)(v5 + 200) = 1;
          }
        }
      }
      else
      {
        if (*(unsigned char *)(this + 234)) {
          *(unsigned char *)(this + 200) = 1;
        }
        int v9 = *(void **)(this + 176);
        if (v9)
        {
          *int v9 = 0;
          v9[10] = 0;
          v9[11] = 0;
          uint64_t v10 = v9[13];
          if (v10)
          {
            uint64_t v11 = v9[16];
            do
            {
              uint64_t v12 = v10;
              uint64_t v10 = *(void *)(v10 + 24);
              *(void *)(v12 + 24) = v11;
              uint64_t v11 = v12;
            }
            while (v10);
            v9[13] = 0;
            v9[16] = v12;
          }
          v9[14] = 0;
          v9[15] = 0;
          *(void *)(this + 176) = 0;
        }
        uint64_t v13 = *(kdu_compositor_buf **)(this + 184);
        if (v13)
        {
          this = kdu_region_compositor::internal_delete_buffer(*(kdu_region_compositor **)this, v13);
          *(void *)(v5 + 184) = 0;
        }
      }
    }
  }
  return this;
}

uint64_t kdrc_layer::update_overlay(uint64_t this, int a2, int a3)
{
  if (*(void *)(this + 72))
  {
    uint64_t v3 = this;
    this = *(void *)(this + 176);
    if (this)
    {
      if (*(unsigned char *)(v3 + 120))
      {
        if (a2)
        {
          *(void *)this = 0;
          *(void *)(this + 80) = 0;
          *(void *)(this + 88) = 0;
          uint64_t v6 = *(void *)(this + 104);
          if (v6)
          {
            uint64_t v7 = *(void *)(this + 128);
            do
            {
              uint64_t v8 = v6;
              uint64_t v6 = *(void *)(v6 + 24);
              *(void *)(v8 + 24) = v7;
              uint64_t v7 = v8;
            }
            while (v6);
            *(void *)(this + 104) = 0;
            *(void *)(this + 128) = v8;
          }
          *(void *)(this + 112) = 0;
          *(void *)(this + 120) = 0;
          this = *(void *)(v3 + 176);
          *(void *)this = *(void *)v3;
          if (*(void *)(v3 + 184))
          {
            initialize_buffer_surface(*(void *)(v3 + 184), *(void *)(v3 + 152), *(void *)(v3 + 160), 0, 0, 0, 0xFFFFFF, 0);
            this = *(void *)(v3 + 176);
          }
        }
        this = kdrc_overlay::set_buffer_surface(this, *(void *)(v3 + 184), *(void *)(v3 + 152), *(void *)(v3 + 160), 1);
        if (this)
        {
          if (!*(unsigned char *)(v3 + 234))
          {
            *(unsigned char *)(v3 + 234) = 1;
            if (!*(void *)(v3 + 208))
            {
              if (*(void *)(v3 + 240) || *(void *)(v3 + 248) || *(void *)(v3 + 184)) {
                kdrc_layer::update_overlay();
              }
              kdu_region_compositor::donate_compositing_buffer(*(void **)v3, *(void *)(v3 + 144), *(void *)(v3 + 152), *(void *)(v3 + 160), *(void *)(v3 + 168));
              *(void *)(v3 + 208) = *(void *)(v3 + 144);
              *(void *)(v3 + 144) = kdu_region_compositor::internal_allocate_buffer(*(void *)v3, *(void *)(v3 + 160), (void *)(v3 + 168));
              int v9 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 208) + 16))(*(void *)(v3 + 208), 1);
              if ((v9 & 1) == 0) {
                initialize_buffer_surface(*(void *)(v3 + 208), *(void *)(v3 + 152), *(void *)(v3 + 160), 0, 0, 0, -1, 0);
              }
              int v10 = v9 ^ 1;
              initialize_buffer_surface(*(void *)(v3 + 144), *(void *)(v3 + 152), *(void *)(v3 + 160), *(void *)(v3 + 208), *(void *)(v3 + 152), *(void *)(v3 + 160), -1, 0);
              uint64_t v11 = 0;
              char v12 = 1;
              do
              {
                char v13 = v12;
                this = *(void *)(v3 + 8 * v11 + 72);
                if (this) {
                  this = kdrc_stream::set_buffer_surface(this, *(void *)(v3 + 144), *(void *)(v3 + 152), *(void *)(v3 + 160), v10);
                }
                char v12 = 0;
                uint64_t v11 = 1;
              }
              while ((v13 & 1) != 0);
            }
            if (!*(void *)(v3 + 184))
            {
              uint64_t buffer = kdu_region_compositor::internal_allocate_buffer(*(void *)v3, *(void *)(v3 + 160), (void *)(v3 + 192));
              *(void *)(v3 + 184) = buffer;
              initialize_buffer_surface(buffer, *(void *)(v3 + 152), *(void *)(v3 + 160), 0, 0, 0, 0xFFFFFF, 0);
              this = kdrc_overlay::set_buffer_surface(*(void *)(v3 + 176), *(void *)(v3 + 184), *(void *)(v3 + 152), *(void *)(v3 + 160), 0);
            }
          }
          if ((a3 & 1) == 0)
          {
            do
              this = kdrc_overlay::process(*(kdrc_overlay **)(v3 + 176), (kdu_dims *)&v17);
            while ((this & 1) != 0);
          }
        }
        if (*(unsigned char *)(v3 + 234)) {
          BOOL v15 = a3 == 0;
        }
        else {
          BOOL v15 = 1;
        }
        if (!v15 && a2 != 0) {
          *(unsigned char *)(v3 + 200) = 1;
        }
      }
    }
  }
  return this;
}

uint64_t kdrc_layer::process_overlay(kdrc_layer *this, kdu_dims *a2)
{
  uint64_t v4 = (kdrc_overlay *)*((void *)this + 22);
  if (!v4)
  {
    if (!*((unsigned char *)this + 234))
    {
      uint64_t result = 0;
      *((unsigned char *)this + 200) = 0;
      *((unsigned char *)this + 234) = 0;
      return result;
    }
    int v6 = *((unsigned __int8 *)this + 200);
    *((unsigned char *)this + 200) = 0;
    *((unsigned char *)this + 234) = 0;
    if (v6)
    {
      uint64_t v7 = (kdu_compositor_buf *)*((void *)this + 18);
      *(_OWORD *)a2 = *(_OWORD *)((char *)this + 152);
      if (*((void *)this + 26)
        && kdu_region_compositor::retract_compositing_buffer(*(void *)this, (void *)this + 21))
      {
        uint64_t v8 = *((void *)this + 26);
        *((void *)this + 18) = v8;
        *((void *)this + 26) = 0;
        if (*((unsigned char *)this + 232)) {
          kdrc_layer::process_overlay();
        }
        initialize_buffer_surface(v8, *((void *)this + 19), *((void *)this + 20), (uint64_t)v7, *((void *)this + 19), *((void *)this + 20), -1, 0);
        (*(void (**)(void, void))(**((void **)this + 18) + 16))(*((void *)this + 18), 0);
        uint64_t v9 = 0;
        char v10 = 1;
        do
        {
          char v11 = v10;
          uint64_t v12 = *((void *)this + v9 + 9);
          if (v12) {
            kdrc_stream::set_buffer_surface(v12, *((void *)this + 18), *((void *)this + 19), *((void *)this + 20), 0);
          }
          char v10 = 0;
          uint64_t v9 = 1;
        }
        while ((v11 & 1) != 0);
        kdu_region_compositor::internal_delete_buffer(*(kdu_region_compositor **)this, v7);
      }
      return 1;
    }
    return 0;
  }
  if (!*((unsigned char *)this + 234)) {
    return 0;
  }
  if (*((unsigned char *)this + 200))
  {
    while ((kdrc_overlay::process(*((kdrc_overlay **)this + 22), a2) & 1) != 0)
      ;
    *(_OWORD *)a2 = *(_OWORD *)((char *)this + 152);
    *((unsigned char *)this + 200) = 0;
    return 1;
  }

  return kdrc_overlay::process(v4, a2);
}

uint64_t kdu_region_compositor::retract_compositing_buffer(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 472);
  if (!v2) {
    kdu_region_compositor::retract_compositing_buffer();
  }
  if (!*(void *)(a1 + 392)
    || *(void *)(v2 + 240)
    || *(unsigned char *)(v2 + 232)
    || *(unsigned char *)(v2 + 234)
    || *(int *)(a1 + 356) >= 1 && *(int *)(a1 + 352) > 0)
  {
    return 0;
  }
  *(void *)(a1 + 392) = 0;
  *a2 = *(void *)(a1 + 416);
  return 1;
}

uint64_t kdrc_layer::update_composition(uint64_t result, unint64_t a2, uint64_t a3, int a4)
{
  unint64_t v84 = a2;
  uint64_t v85 = a3;
  uint64_t v4 = *(void *)(result + 208);
  if (v4)
  {
    uint64_t v5 = result;
    if (*(unsigned char *)(result + 234))
    {
      if (*(void *)(*(void *)result + 472) == result)
      {
        uint64_t v40 = a3;
        int v41 = a2;
        unint64_t v42 = HIDWORD(a2);
        if (!*(unsigned char *)(v4 + 27)) {
          (*(void (**)(void, void))(*(void *)v4 + 24))(*(void *)(result + 208), 0);
        }
        int v43 = *(_DWORD *)(v4 + 40);
        uint64_t v44 = *(int *)(v4 + 44) * (uint64_t)v43;
        long long v45 = (char *)(*(void *)(v4 + 32)
                     + ((int)v42 - *(_DWORD *)(v5 + 220)) * v43
                     + (v41 - *(_DWORD *)(v5 + 216)) * (int)v44);
        if (v43 == 4)
        {
          if ((int)v40 >= 1)
          {
            do
            {
              if (SHIDWORD(v85) >= 1)
              {
                uint64_t v46 = 0;
                unsigned int v47 = HIDWORD(v85) + 1;
                do
                {
                  *(_DWORD *)&v45[v46] = a4;
                  v46 += 4;
                  --v47;
                }
                while (v47 > 1);
              }
              v45 += v44;
              BOOL v38 = __OFSUB__(v40, 1);
              LODWORD(v40) = v40 - 1;
            }
            while (!(((int)v40 < 0) ^ v38 | (v40 == 0)));
          }
        }
        else if ((int)v40 >= 1)
        {
          size_t v48 = v43 * HIDWORD(v40);
          uint64_t v49 = (int)v44;
          unsigned int v50 = v40 + 1;
          do
          {
            memset(v45, 255, v48);
            v45 += v49;
            --v50;
          }
          while (v50 > 1);
        }
      }
      kdu_dims::operator&=(&v84, (int *)(v5 + 152));
      uint64_t result = kdu_dims::operator&=(&v84, (int *)(v5 + 216));
      if (*(void *)(v5 + 72) && SHIDWORD(v85) >= 1 && (int)v85 >= 1)
      {
        if (!*(unsigned char *)(v5 + 120) || (uint64_t v11 = *(void *)(v5 + 144)) == 0) {
          kdrc_layer::update_composition();
        }
        if (!*(unsigned char *)(v11 + 27) || !*(unsigned char *)(v11 + 26)) {
          uint64_t result = (*(uint64_t (**)(void, uint64_t))(*(void *)v11 + 24))(*(void *)(v5 + 144), 1);
        }
        int v13 = *(_DWORD *)(v11 + 40);
        uint64_t v12 = *(int *)(v11 + 44);
        uint64_t v14 = (int)v12 * (uint64_t)v13;
        int v16 = v84;
        int v15 = HIDWORD(v84);
        uint64_t v17 = (unsigned char *)(*(void *)(v11 + 32)
                      + (HIDWORD(v84) - *(_DWORD *)(v5 + 156)) * v13
                      + ((int)v84 - *(_DWORD *)(v5 + 152)) * (int)v14);
        uint64_t v18 = *(void *)(v5 + 208);
        if (!*(unsigned char *)(v18 + 27) || !*(unsigned char *)(v18 + 26))
        {
          uint64_t result = (*(uint64_t (**)(void, uint64_t))(*(void *)v18 + 24))(*(void *)(v5 + 208), 1);
          int v16 = v84;
          int v15 = HIDWORD(v84);
        }
        int v20 = *(_DWORD *)(v18 + 40);
        uint64_t v19 = *(int *)(v18 + 44);
        uint64_t v21 = (int)v19 * (uint64_t)v20;
        unint64_t v22 = (unsigned char *)(*(void *)(v18 + 32)
                      + (v15 - *(_DWORD *)(v5 + 220)) * v20
                      + (v16 - *(_DWORD *)(v5 + 216)) * (int)v21);
        if (*(unsigned char *)(v5 + 232))
        {
          int v23 = v85;
          if (*(unsigned char *)(v5 + 233))
          {
            if ((int)v85 >= 1)
            {
              v6.n128_u64[0] = 0xFFFFFFF8FFFFFFF0;
              v7.n128_u64[0] = 0x800000010;
              v8.n128_u64[0] = 0xFF000000FFLL;
              __n128 v9 = 0uLL;
              do
              {
                if (SHIDWORD(v85) >= 1)
                {
                  uint64_t v24 = 0;
                  unsigned int v25 = HIDWORD(v85) + 1;
                  do
                  {
                    unint64_t v26 = *(unsigned int *)&v17[v24];
                    unsigned int v27 = *(_DWORD *)&v22[v24];
                    unsigned int v28 = kdrc_alpha_lut[v26 >> 24];
                    int v29 = HIBYTE(*(_DWORD *)&v17[v24]) + HIBYTE(v27) - ((int)(HIBYTE(v27) * v28) >> 14);
                    int v31 = v29 & ~(v29 >> 31);
                    if (v31 >= 255) {
                      int v31 = 255;
                    }
                    int v30 = *(_DWORD *)&v22[v24]
                        + v26
                        - ((int)(*(_DWORD *)&v22[v24] * v28) >> 14);
                    uint64_t result = v30 & ~(v30 >> 31);
                    int32x2_t v34 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)__PAIR64__(v26, v27), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
                    int32x2_t v32 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)__PAIR64__(v27, v26), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
                    int32x2_t v33 = vadd_s32(v32, v34);
                    v34.i32[1] = v32.i32[1];
                    int32x2_t v35 = vdup_n_s32(v28);
                    if ((int)result >= 255) {
                      int v36 = 255;
                    }
                    else {
                      int v36 = result;
                    }
                    uint32x2_t v37 = vshl_u32((uint32x2_t)vmin_s32(vmax_s32(vsub_s32(v33, vshr_n_s32(vmul_s32(v34, v35), 0xEuLL)), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x800000010);
                    *(_DWORD *)&v22[v24] = v37.i32[0] | (v31 << 24) | v36 | v37.i32[1];
                    v24 += 4;
                    --v25;
                  }
                  while (v25 > 1);
                }
                v17 += v12;
                v22 += v19;
                BOOL v38 = __OFSUB__(v23--, 1);
              }
              while (!((v23 < 0) ^ v38 | (v23 == 0)));
            }
          }
          else if ((int)v85 >= 1)
          {
            BOOL v53 = v13 != 4 || v20 != 4;
            v6.n128_u64[0] = 0xFF000000FFLL;
            v6.n128_u64[1] = 0xFF000000FFLL;
            __n128 v7 = 0uLL;
            do
            {
              if (SHIDWORD(v85) >= 1)
              {
                if (v53) {
                  kdrc_layer::update_composition();
                }
                uint64_t v54 = 0;
                unsigned int v55 = HIDWORD(v85) + 1;
                do
                {
                  uint64_t result = v22[v54 + 1];
                  uint64_t v56 = (const float *)&kdrc_alpha_lut[v17[v54]];
                  v8.n128_u8[0] = v17[v54 + 2];
                  LODWORD(v57) = v22[v54 + 2];
                  v8.n128_u8[4] = v17[v54 + 3];
                  HIDWORD(v57) = v22[v54 + 3];
                  v10.i8[0] = v22[v54];
                  v10.i8[2] = v17[v54 + 1];
                  v10.i16[2] = v8.n128_u16[0];
                  v10.i16[3] = v8.n128_i16[2];
                  int32x4_t v10 = (int32x4_t)vandq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)v10.i8), (int8x16_t)v6);
                  v58.i32[0] = 255;
                  v58.i32[1] = v22[v54 + 1];
                  v58.i64[1] = v57;
                  int32x4_t v59 = vsubq_s32(v10, v58);
                  v59.i32[0] = veorq_s8((int8x16_t)v10, (int8x16_t)v6).u32[0];
                  int32x4_t v60 = (int32x4_t)vld1q_dup_f32(v56);
                  v58.i32[0] = v10.i32[0];
                  __n128 v9 = (__n128)vminq_s32(vmaxq_s32(vsraq_n_s32(v58, vmulq_s32(v59, v60), 0xEuLL), (int32x4_t)0), (int32x4_t)v6);
                  v8.n128_u64[0] = (unint64_t)vmovn_s32((int32x4_t)v9);
                  v8.n128_u64[0] = (unint64_t)vmovn_s16((int16x8_t)v8);
                  *(_DWORD *)&v22[v54] = v8.n128_u32[0];
                  v54 += 4;
                  --v55;
                }
                while (v55 > 1);
              }
              v17 += (int)v14;
              v22 += (int)v21;
              BOOL v38 = __OFSUB__(v23--, 1);
            }
            while (!((v23 < 0) ^ v38 | (v23 == 0)));
          }
        }
        else if ((int)v85 >= 1)
        {
          unsigned int v51 = v85 + 1;
          do
          {
            uint64_t result = (uint64_t)memcpy(v22, v17, SHIDWORD(v85) * (uint64_t)v13);
            v17 += v14;
            v22 += v21;
            --v51;
          }
          while (v51 > 1);
        }
        uint64_t v61 = *(void *)(v5 + 184);
        if (v61)
        {
          if (!*(unsigned char *)(v61 + 27) || !*(unsigned char *)(v61 + 26)) {
            uint64_t result = (*(uint64_t (**)(void, uint64_t, __n128, __n128, __n128, __n128))(*(void *)v61 + 24))(*(void *)(v5 + 184), 1, v6, v7, v8, v9);
          }
          int v62 = *(_DWORD *)(v61 + 40);
          uint64_t v63 = *(int *)(v61 + 44);
          uint64_t v64 = *(void *)(v61 + 32);
          int v66 = v84;
          int v65 = HIDWORD(v84);
          int v67 = *(_DWORD *)(v5 + 152);
          int v68 = *(_DWORD *)(v5 + 156);
          uint64_t v69 = *(void *)(v5 + 208);
          if (!*(unsigned char *)(v69 + 27) || !*(unsigned char *)(v69 + 26)) {
            uint64_t result = (*(uint64_t (**)(void, uint64_t, __n128, __n128, __n128, __n128))(*(void *)v69 + 24))(*(void *)(v5 + 208), 1, v6, v7, v8, v9);
          }
          int v70 = v85;
          if ((int)v85 >= 1)
          {
            uint64_t v71 = v64 + (v65 - v68 + (v66 - v67) * (int)v63) * v62;
            uint64_t v72 = *(int *)(v69 + 44);
            uint64_t v73 = *(void *)(v69 + 32)
                + (HIDWORD(v84) - *(_DWORD *)(v5 + 220) + ((int)v84 - *(_DWORD *)(v5 + 216)) * (int)v72)
                * *(_DWORD *)(v69 + 40);
            do
            {
              if (SHIDWORD(v85) >= 1)
              {
                uint64_t v74 = 0;
                unsigned int v75 = HIDWORD(v85) + 1;
                do
                {
                  unint64_t v76 = *(unsigned int *)(v71 + v74);
                  unsigned int v77 = *(_DWORD *)(v73 + v74);
                  uint64_t result = *(unsigned int *)((char *)kdrc_alpha_lut + ((v76 >> 22) & 0x3FC));
                  int v78 = ((int)((HIBYTE(v77) ^ 0xFF) * result) >> 14) + HIBYTE(v77);
                  int v80 = v78 & ~(v78 >> 31);
                  if (v80 >= 255) {
                    int v80 = 255;
                  }
                  int v79 = (((*(_DWORD *)(v71 + v74) - v77) * (int)result) >> 14)
                      + v77;
                  int v81 = v79 & ~(v79 >> 31);
                  if (v81 >= 255) {
                    int v81 = 255;
                  }
                  int32x2_t v82 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v77), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
                  uint32x2_t v83 = vshl_u32((uint32x2_t)vmin_s32(vmax_s32(vsra_n_s32(v82, vmul_s32(vsub_s32((int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v76), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL), v82), vdup_n_s32(result)), 0xEuLL), 0), (int32x2_t)0xFF000000FFLL), (uint32x2_t)0x800000010);
                  *(_DWORD *)(v73 + v74) = v83.i32[0] | (v80 << 24) | v81 | v83.i32[1];
                  v74 += 4;
                  --v75;
                }
                while (v75 > 1);
              }
              v71 += v63;
              v73 += v72;
              BOOL v38 = __OFSUB__(v70--, 1);
            }
            while (!((v70 < 0) ^ v38 | (v70 == 0)));
          }
        }
      }
    }
  }
  return result;
}

uint64_t kdrc_refresh::adjust(uint64_t result, uint64_t a2, uint64_t a3)
{
  v9[0] = a2;
  v9[1] = a3;
  uint64_t v4 = (void *)(result + 8);
  uint64_t v3 = *(void *)(result + 8);
  if (v3)
  {
    uint64_t v5 = (void *)result;
    uint64_t v6 = 0;
    do
    {
      uint64_t v7 = *(void *)(v3 + 16);
      uint64_t result = kdu_dims::operator&=((_DWORD *)v3, (int *)v9);
      if (*(int *)(v3 + 12) < 1 || *(int *)(v3 + 8) <= 0)
      {
        __n128 v8 = (void *)(v6 + 16);
        if (!v6) {
          __n128 v8 = v4;
        }
        *__n128 v8 = v7;
        *(void *)(v3 + 16) = *v5;
        *uint64_t v5 = v3;
      }
      else
      {
        uint64_t v6 = v3;
      }
      uint64_t v3 = v7;
    }
    while (v7);
  }
  return result;
}

void kdrc_refresh::adjust(kdrc_refresh *this, kdrc_stream *a2)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v2)
  {
    do
    {
      uint64_t v5 = (uint64_t *)v2[2];
      kdrc_stream::adjust_refresh((uint64_t)a2, *v2, v2[1], this);
      v2[2] = *(void *)this;
      *(void *)this = v2;
      uint64_t v2 = v5;
    }
    while (v5);
  }
}

void kdu_region_compositor::kdu_region_compositor(uint64_t a1)
{
  *(void *)a1 = &unk_1ED4E5458;
  jpx_input_box::jpx_input_box((jpx_input_box *)(a1 + 32));
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 376) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 416) = 0;
  *(void *)(a1 + 400) = 0;
  kdu_region_compositor::init(a1);
}

void sub_1886DFB14(_Unwind_Exception *a1)
{
  jpx_input_box::~jpx_input_box(v1);
  _Unwind_Resume(a1);
}

void kdu_region_compositor::init(uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(unsigned char *)(a1 + 316) = 1;
  *(_DWORD *)(a1 + 320) = 256000;
  *(_DWORD *)(a1 + 312) = 0;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 416) = 0;
  *(_DWORD *)(a1 + 424) = -1;
  *(unsigned char *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 328) = 0x10000;
  *(unsigned char *)(a1 + 334) = 0;
  *(_WORD *)(a1 + 332) = 0;
  *(void *)(a1 + 336) = 1065353216;
  *(_DWORD *)(a1 + 428) = 257;
  *(unsigned char *)(a1 + 432) = 0;
  *(_DWORD *)(a1 + 436) = 0;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_OWORD *)(a1 + 496) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_DWORD *)(a1 + 440) = 1;
  operator new();
}

uint64_t kdu_region_compositor::create(uint64_t this, kdu_compressed_source *a2, int a3)
{
  if (*(void *)(this + 8) || *(void *)(this + 16) || *(void *)(this + 24))
  {
    uint64_t v4 = 0;
    memset(v3, 0, sizeof(v3));
    kdu_error::kdu_error((kdu_error *)v3, "Error in Kakadu Region Compositor:\n");
    kdu_error::~kdu_error((kdu_error *)v3);
  }
  *(void *)(this + 8) = a2;
  *(unsigned char *)(this + 316) = a3 >= 0;
  *(_DWORD *)(this + 320) = a3;
  return this;
}

void sub_1886DFCCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886DFCD8()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_region_compositor::create(uint64_t this, jpx_source *a2, int a3)
{
  if (*(void *)(this + 8) || *(void *)(this + 16) || *(void *)(this + 24))
  {
    uint64_t v4 = 0;
    memset(v3, 0, sizeof(v3));
    kdu_error::kdu_error((kdu_error *)v3, "Error in Kakadu Region Compositor:\n");
    kdu_error::~kdu_error((kdu_error *)v3);
  }
  *(void *)(this + 16) = a2;
  *(unsigned char *)(this + 316) = a3 >= 0;
  *(_DWORD *)(this + 320) = a3;
  return this;
}

void sub_1886DFDA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886DFDAC()
{
  _Unwind_Resume(v0);
}

kdrc_queue *kdu_region_compositor::pre_destroy(kdu_region_compositor *this)
{
  kdu_region_compositor::remove_compositing_layer((uint64_t)this, -1, 1);
  while (1)
  {
    uint64_t v2 = (kdrc_stream *)*((void *)this + 62);
    if (!v2) {
      break;
    }
    kdu_region_compositor::remove_stream((uint64_t)this, v2, 1);
  }
  while (1)
  {
    uint64_t v3 = (kdrc_stream *)*((void *)this + 63);
    if (!v3) {
      break;
    }
    kdu_region_compositor::remove_stream((uint64_t)this, v3, 1);
  }
  uint64_t v4 = (kdu_compositor_buf *)*((void *)this + 49);
  if (v4)
  {
    kdu_region_compositor::internal_delete_buffer(this, v4);
    *((void *)this + 49) = 0;
  }
  uint64_t v5 = (kdrc_refresh *)*((void *)this + 64);
  if (v5)
  {
    kdrc_refresh::~kdrc_refresh(v5);
    MEMORY[0x18C11C0E0]();
    *((void *)this + 64) = 0;
  }
  kdu_region_compositor::flush_composition_queue(this);
  while (1)
  {
    uint64_t result = (kdrc_queue *)*((void *)this + 58);
    *((void *)this + 57) = result;
    if (!result) {
      break;
    }
    *((void *)this + 58) = *((void *)result + 3);
    kdrc_queue::~kdrc_queue(result);
    MEMORY[0x18C11C0E0]();
  }
  return result;
}

uint64_t kdu_region_compositor::remove_compositing_layer(uint64_t this, int a2, int a3)
{
  uint64_t v5 = this;
  uint64_t v6 = *(void *)(this + 472);
  if (v6)
  {
    uint64_t v7 = 0;
    __n128 v8 = (void *)(this + 472);
    __n128 v9 = (uint64_t *)(this + 480);
    do
    {
      uint64_t v10 = *(void *)(v6 + 240);
      if (a2 < 0 || *(_DWORD *)(v6 + 236) == a2)
      {
        *(unsigned char *)(v5 + 429) = 1;
        this = kdrc_layer::deactivate(v6);
        if (v7)
        {
          uint64_t v11 = (uint64_t *)(v7 + 240);
        }
        else
        {
          uint64_t v11 = (uint64_t *)(v5 + 472);
          if (v6 != *v8) {
            kdu_region_compositor::remove_compositing_layer();
          }
        }
        uint64_t *v11 = v10;
        uint64_t v12 = *v9;
        if (v10)
        {
          if (v6 == v12) {
            kdu_region_compositor::remove_compositing_layer();
          }
          int v13 = (uint64_t *)(v10 + 248);
        }
        else
        {
          int v13 = (uint64_t *)(v5 + 480);
          if (v6 != v12) {
            kdu_region_compositor::remove_compositing_layer();
          }
        }
        uint64_t *v13 = v7;
        *(void *)(v6 + 240) = *(void *)(v5 + 488);
        *(void *)(v6 + 248) = 0;
        *(void *)(v5 + 488) = v6;
      }
      else
      {
        uint64_t v7 = v6;
      }
      uint64_t v6 = v10;
    }
    while (v10);
  }
  if (a3)
  {
    this = *(void *)(v5 + 488);
    if (this)
    {
      uint64_t v14 = 0;
      int v15 = (uint64_t *)(v5 + 488);
      do
      {
        uint64_t v16 = *(void *)(this + 240);
        if (a2 < 0 || *(_DWORD *)(this + 236) == a2)
        {
          uint64_t v17 = (uint64_t *)(v14 + 240);
          if (!v14) {
            uint64_t v17 = v15;
          }
          *uint64_t v17 = v16;
          kdrc_layer::~kdrc_layer((kdrc_layer *)this);
          MEMORY[0x18C11C0E0]();
        }
        else
        {
          uint64_t v14 = this;
        }
        this = v16;
      }
      while (v16);
    }
  }
  return this;
}

kdu_region_compositor *kdu_region_compositor::flush_composition_queue(kdu_region_compositor *this)
{
  uint64_t v1 = *((void *)this + 56);
  *((void *)this + 57) = v1;
  if (v1)
  {
    uint64_t v2 = this;
    uint64_t v3 = *((void *)this + 58);
    do
    {
      uint64_t v4 = *(void *)(v1 + 24);
      *((void *)v2 + 56) = v4;
      *(void *)(v1 + 24) = v3;
      *((void *)v2 + 58) = v1;
      if (*(void *)v1)
      {
        this = (kdu_region_compositor *)kdu_region_compositor::internal_delete_buffer(v2, *(kdu_compositor_buf **)v1);
        uint64_t v1 = *((void *)v2 + 58);
        *(void *)uint64_t v1 = 0;
        uint64_t v4 = *((void *)v2 + 56);
      }
      *((void *)v2 + 57) = v4;
      uint64_t v3 = v1;
      uint64_t v1 = v4;
    }
    while (v4);
  }
  return this;
}

uint64_t kdu_region_compositor::add_compositing_layer(uint64_t a1, int a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, int a7, int a8, char a9, unsigned int a10, int a11)
{
  unint64_t v13 = HIDWORD(a5);
  if (a9) {
    LODWORD(v13) = 1 - (HIDWORD(a6) + HIDWORD(a5));
  }
  LODWORD(v14) = 1 - (a6 + a5);
  if (!a8) {
    LODWORD(v14) = a5;
  }
  if (a7) {
    uint64_t v15 = HIDWORD(a6);
  }
  else {
    uint64_t v15 = a6;
  }
  if (a7) {
    uint64_t v16 = v14;
  }
  else {
    uint64_t v16 = v13;
  }
  if (a7) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = v14;
  }
  if (a7) {
    uint64_t v17 = a6;
  }
  else {
    uint64_t v17 = HIDWORD(a6);
  }
  *(_OWORD *)(a1 + 344) = 0u;
  *(_OWORD *)(a1 + 360) = 0u;
  if (*(void *)(a1 + 8))
  {
    if (a2)
    {
      uint64_t v53 = 0;
      long long v51 = 0uLL;
      long long v52 = 0uLL;
      kdu_error::kdu_error((kdu_error *)&v51, "Error in Kakadu Region Compositor:\n");
      kdu_error::~kdu_error((kdu_error *)&v51);
    }
    uint64_t v18 = *(kdrc_stream **)(a1 + 496);
    if (v18)
    {
      kdu_region_compositor::remove_stream(a1, v18, 0);
      if (*(void *)(a1 + 496)) {
        kdu_region_compositor::add_compositing_layer();
      }
    }
    kdu_region_compositor::add_active_stream((kdu_region_compositor *)a1, 0, 0);
    kdrc_stream::set_mode(*(__n128 **)(a1 + 496), 0xFFFFFFFFLL, 0);
    uint64_t result = 1;
    *(unsigned char *)(a1 + 429) = 1;
    return result;
  }
  char v20 = a8;
  char v21 = a7;
  uint64_t v49 = v14;
  uint64_t v24 = *(jpx_source **)(a1 + 16);
  if (v24)
  {
    uint64_t v47 = v16;
    uint64_t v48 = v17;
    int v50 = 0;
    BOOL v25 = jpx_source::count_compositing_layers(v24, &v50);
    if (!jpx_source::access_layer(*(jpx_source **)(a1 + 16), a2, 1))
    {
      if (a2 < 0 || (v50 <= a2 ? (BOOL v26 = v25) : (BOOL v26 = 0), v26))
      {
        uint64_t v53 = 0;
        long long v51 = 0u;
        long long v52 = 0u;
        kdu_error::kdu_error((kdu_error *)&v51, "Error in Kakadu Region Compositor:\n");
        goto LABEL_35;
      }
      return 0;
    }
  }
  else
  {
    unsigned int v27 = *(mj2_source **)(a1 + 24);
    if (!v27) {
      kdu_region_compositor::add_compositing_layer();
    }
    int track_type = mj2_source::get_track_type(v27, a2 + 1);
    if (track_type == -1) {
      return 0;
    }
    uint64_t v47 = v16;
    uint64_t v48 = v17;
    if (track_type != 1)
    {
      uint64_t v53 = 0;
      long long v51 = 0u;
      long long v52 = 0u;
      kdu_error::kdu_error((kdu_error *)&v51, "Error in Kakadu Region Compositor:\n");
LABEL_35:
      kdu_error::~kdu_error((kdu_error *)&v51);
    }
  }
  int v29 = (uint64_t *)(a1 + 472);
  while (1)
  {
    int v30 = *(kdrc_stream **)(a1 + 496);
    if (!v30 || *v29) {
      break;
    }
    kdu_region_compositor::remove_stream(a1, v30, 0);
  }
  jpx_input_box::close((jpx_input_box *)(a1 + 32));
  uint64_t v31 = *(void *)(a1 + 472);
  char v46 = v20;
  if (v31)
  {
    if (*(_DWORD *)(v31 + 236) == a2)
    {
      uint64_t v32 = 0;
      uint64_t v33 = *(void *)(a1 + 472);
LABEL_46:
      if (v32)
      {
        *(void *)(v32 + 240) = *(void *)(v33 + 240);
      }
      else
      {
        if (v33 != v31) {
          kdu_region_compositor::add_compositing_layer();
        }
        *int v29 = *(void *)(v31 + 240);
      }
      uint64_t v36 = *(void *)(v33 + 240);
      uint64_t v37 = *(void *)(a1 + 480);
      if (v36)
      {
        if (v33 == v37) {
          kdu_region_compositor::add_compositing_layer();
        }
        *(void *)(v36 + 248) = *(void *)(v33 + 248);
      }
      else
      {
        if (v33 != v37) {
          kdu_region_compositor::add_compositing_layer();
        }
        *(void *)(a1 + 480) = v32;
      }
      *(void *)(v33 + 240) = 0;
      *(void *)(v33 + 248) = 0;
      goto LABEL_69;
    }
    uint64_t v34 = *(void *)(a1 + 472);
    while (1)
    {
      uint64_t v33 = *(void *)(v34 + 240);
      if (!v33) {
        break;
      }
      uint64_t v32 = v34;
      uint64_t v34 = *(void *)(v34 + 240);
      if (*(_DWORD *)(v33 + 236) == a2) {
        goto LABEL_46;
      }
    }
  }
  uint64_t v33 = *(void *)(a1 + 488);
  if (!v33) {
LABEL_68:
  }
    operator new();
  if (*(_DWORD *)(v33 + 236) != a2)
  {
    uint64_t v38 = *(void *)(a1 + 488);
    while (1)
    {
      uint64_t v33 = *(void *)(v38 + 240);
      if (!v33) {
        goto LABEL_68;
      }
      uint64_t v35 = v38;
      uint64_t v38 = *(void *)(v38 + 240);
      if (*(_DWORD *)(v33 + 236) == a2) {
        goto LABEL_64;
      }
    }
  }
  uint64_t v35 = 0;
LABEL_64:
  if (v35) {
    int v39 = (void *)(v35 + 240);
  }
  else {
    int v39 = (void *)(a1 + 488);
  }
  *int v39 = *(void *)(v33 + 240);
  *(void *)(v33 + 240) = 0;
  *(void *)(v33 + 248) = 0;
LABEL_69:
  char v45 = v21;
  unint64_t v40 = a3;
  uint64_t v41 = *(void *)(a1 + 480);
  if (v41)
  {
    uint64_t v42 = v15;
    uint64_t v43 = a4;
    *(void *)(v33 + 248) = v41;
    uint64_t v44 = (uint64_t *)(v41 + 240);
    int v29 = (uint64_t *)(a1 + 480);
  }
  else
  {
    uint64_t v42 = v15;
    uint64_t v43 = a4;
    uint64_t v44 = (uint64_t *)(a1 + 480);
    if (*v29) {
      kdu_region_compositor::add_compositing_layer();
    }
  }
  *uint64_t v44 = v33;
  *int v29 = v33;
  *(unsigned char *)(a1 + 429) = 1;
  kdrc_layer::activate(v33, v40, v43, v49 | (v47 << 32), v42 | (v48 << 32), v45, v46, a9, a10, a11);
  return 1;
}

void sub_1886E0534(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886E0540(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(v15);
}

uint64_t kdu_region_compositor::set_single_component(kdu_region_compositor *this, int a2, uint64_t a3, unsigned __int32 a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *((unsigned char *)this + 429) = 1;
  for (uint64_t i = *((void *)this + 59); i; uint64_t i = *((void *)this + 59))
    kdu_region_compositor::remove_compositing_layer((uint64_t)this, *(_DWORD *)(i + 236), 0);
  if (*((void *)this + 60)) {
    kdu_region_compositor::set_single_component();
  }
  while (1)
  {
    __n128 v9 = (kdrc_stream *)*((void *)this + 62);
    if (!v9) {
      break;
    }
    kdu_region_compositor::remove_stream((uint64_t)this, v9, 0);
  }
  if (*((void *)this + 1))
  {
    if (a2)
    {
      *(void *)&long long v24 = 0;
      *(_OWORD *)unint64_t v22 = 0u;
      long long v23 = 0u;
      kdu_error::kdu_error((kdu_error *)v22, "Error in Kakadu Region Compositor:\n");
      kdu_error::~kdu_error((kdu_error *)v22);
    }
    goto LABEL_23;
  }
  uint64_t v10 = (jpx_source *)*((void *)this + 2);
  if (!v10)
  {
    unint64_t v13 = (mj2_source *)*((void *)this + 3);
    if (!v13) {
      kdu_region_compositor::set_single_component();
    }
    v18[0] = 0;
    *(void *)char v21 = 0;
    if (mj2_source::find_stream(v13, a2, v18, &v21[1], v21))
    {
      if (!v18[0])
      {
        *(void *)&long long v24 = 0;
        *(_OWORD *)unint64_t v22 = 0u;
        long long v23 = 0u;
        kdu_error::kdu_error((kdu_error *)v22, "Error in Kakadu Region Compositor:\n");
        kdu_error::~kdu_error((kdu_error *)v22);
      }
      uint64_t v14 = mj2_source::access_video_track(*((mj2_source **)this + 3), v18[0]);
      uint64_t v15 = (mj2_video_source *)v14;
      if (v14)
      {
        (*(void (**)(uint64_t, void))(*(void *)v14 + 104))(v14, v21[1]);
        if (mj2_video_source::can_open_stream(v15, v21[0])) {
          goto LABEL_23;
        }
      }
    }
    return 0xFFFFFFFFLL;
  }
  v18[0] = 0;
  int v11 = jpx_source::count_codestreams(v10, (int *)v18);
  if (!jpx_source::access_codestream(*((jpx_source **)this + 2), a2, 1))
  {
    if (a2 < 0 || ((int)v18[0] <= a2 ? (int v12 = v11) : (int v12 = 0), v12 == 1))
    {
      *(void *)&long long v24 = 0;
      *(_OWORD *)unint64_t v22 = 0u;
      long long v23 = 0u;
      kdu_error::kdu_error((kdu_error *)v22, "Error in Kakadu Region Compositor:\n");
      kdu_error::~kdu_error((kdu_error *)v22);
    }
    return 0xFFFFFFFFLL;
  }
LABEL_23:
  if (!kdu_region_compositor::add_active_stream(this, a2, -1))
  {
    uint64_t v20 = 0;
    *(_OWORD *)uint64_t v18 = 0u;
    long long v19 = 0u;
    kdu_error::kdu_error((kdu_error *)v18, "Error in Kakadu Region Compositor:\n");
    long long v25 = 0u;
    long long v26 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    *(_OWORD *)unint64_t v22 = 0u;
    if (LOBYTE(v18[2])) {
      sprintf(v22, "%x");
    }
    else {
      sprintf(v22, "%d");
    }
    (*(void (**)(unsigned int *, char *))(*(void *)v18 + 16))(v18, v22);
    (*(void (**)(unsigned int *, const char *))(*(void *)v18 + 16))(v18, ") cannot be opened.");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  uint64_t v16 = (__n128 *)*((void *)this + 62);
  if (v16[69].n128_u32[0] != a2) {
    kdu_region_compositor::set_single_component();
  }
  return kdrc_stream::set_mode(v16, a3, a4);
}

void sub_1886E09B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886E09C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(v17);
}

uint64_t kdu_region_compositor::set_scale(uint64_t this, int a2, int a3, int a4, float a5)
{
  *(_DWORD *)(this + 340) = 0;
  if (!*(unsigned char *)(this + 324)
    || *(unsigned __int8 *)(this + 334) != a2
    || *(unsigned __int8 *)(this + 332) != a3
    || *(unsigned __int8 *)(this + 333) != a4)
  {
    *(unsigned char *)(this + 334) = a2;
    *(unsigned char *)(this + 332) = a3;
    *(unsigned char *)(this + 333) = a4;
    *(float *)(this + 336) = a5;
    *(unsigned char *)(this + 324) = 1;
    *(unsigned char *)(this + 429) = 1;
LABEL_10:
    *(void *)(this + 408) = 0;
    uint64_t v6 = *(uint64_t **)(this + 512);
    uint64_t v7 = v6[1];
    if (v7)
    {
      uint64_t v8 = *v6;
      do
      {
        uint64_t v9 = v7;
        uint64_t v7 = *(void *)(v7 + 16);
        *(void *)(v9 + 16) = v8;
        uint64_t v8 = v9;
      }
      while (v7);
      *uint64_t v6 = v9;
      v6[1] = 0;
    }
    return this;
  }
  float v5 = *(float *)(this + 336);
  if (*(unsigned char *)(this + 429) || v5 != a5)
  {
    *(unsigned char *)(this + 334) = a2;
    *(unsigned char *)(this + 332) = a3;
    *(unsigned char *)(this + 333) = a4;
    *(float *)(this + 336) = a5;
    *(unsigned char *)(this + 324) = 1;
    *(unsigned char *)(this + 429) = 1;
    if (v5 != a5) {
      goto LABEL_10;
    }
  }
  return this;
}

void kdu_region_compositor::set_buffer_surface(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8 = (int *)(a1 + 400);
  if (*(void *)(a1 + 400) != a2 || *(void *)(a1 + 408) != a3 || *(_DWORD *)(a1 + 424) != a4) {
    kdu_region_compositor::flush_composition_queue((kdu_region_compositor *)a1);
  }
  uint64_t v9 = *(kdu_compositor_buf **)(a1 + 392);
  if (!v9)
  {
    *(_DWORD *)(a1 + 424) = a4;
    if (!*(unsigned char *)(a1 + 429))
    {
      uint64_t v12 = *(void *)(a1 + 400);
      uint64_t v13 = *(void *)(a1 + 408);
      *(void *)&long long v42 = a2;
      *((void *)&v42 + 1) = a3;
      uint64_t v16 = (uint64_t *)(a1 + 408);
      kdu_dims::operator&=(&v42, (int *)(a1 + 376));
      BOOL v11 = 0;
      *(_OWORD *)(a1 + 400) = v42;
      goto LABEL_18;
    }
LABEL_13:
    *(void *)(a1 + 400) = a2;
    *(void *)(a1 + 408) = a3;
    return;
  }
  int v10 = *(_DWORD *)(a1 + 424);
  BOOL v11 = v10 != a4;
  *(_DWORD *)(a1 + 424) = a4;
  if (*(unsigned char *)(a1 + 429)) {
    goto LABEL_13;
  }
  uint64_t v12 = *(void *)(a1 + 400);
  uint64_t v13 = *(void *)(a1 + 408);
  *(void *)&long long v42 = a2;
  *((void *)&v42 + 1) = a3;
  kdu_dims::operator&=(&v42, (int *)(a1 + 376));
  uint64_t v14 = *((void *)&v42 + 1);
  *(void *)(a1 + 400) = v42;
  *(void *)(a1 + 408) = v14;
  uint64_t v15 = (void *)(a1 + 416);
  if (*(_DWORD *)(a1 + 420) < SHIDWORD(v14) || *(_DWORD *)v15 < (int)v14) {
    *(void *)(a1 + 392) = kdu_region_compositor::internal_allocate_buffer(a1, v14, v15);
  }
  uint64_t v16 = (uint64_t *)(a1 + 408);
  if (v10 == a4)
  {
    uint64_t v17 = (uint64_t)v9;
    uint64_t v18 = v12;
    uint64_t v19 = v13;
  }
  else
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
  }
  initialize_buffer_surface(*(void *)(a1 + 392), *(void *)(a1 + 400), *(void *)(a1 + 408), v17, v18, v19, *(_DWORD *)(a1 + 424), 0);
  if (v9 != *(kdu_compositor_buf **)(a1 + 392)) {
    kdu_region_compositor::internal_delete_buffer((kdu_region_compositor *)a1, v9);
  }
LABEL_18:
  if (*(void *)(a1 + 472))
  {
    kdu_region_compositor::set_layer_buffer_surfaces(a1);
  }
  else
  {
    uint64_t v20 = *(void *)(a1 + 496);
    if (!v20 || *(void *)(v20 + 1128) || (uint64_t v21 = *(void *)(a1 + 392)) == 0) {
      kdu_region_compositor::set_buffer_surface();
    }
    kdrc_stream::set_buffer_surface(v20, v21, *(void *)(a1 + 400), *(void *)(a1 + 408), 0);
    *(unsigned char *)(a1 + 428) = 0;
  }
  *(void *)&long long v42 = v12;
  *((void *)&v42 + 1) = v13;
  kdu_dims::operator&=(&v42, v8);
  if (v11
    || (unsigned int v22 = DWORD2(v42), v23 = HIDWORD(*((void *)&v42 + 1)), SHIDWORD(v42) < 1)
    || *(uint64_t *)((char *)&v42 + 4) <= 0)
  {
    uint64_t v36 = *(uint64_t **)(a1 + 512);
    uint64_t v38 = v36[1];
    if (v38)
    {
      uint64_t v39 = *v36;
      do
      {
        uint64_t v40 = v38;
        uint64_t v38 = *(void *)(v38 + 16);
        *(void *)(v40 + 16) = v39;
        uint64_t v39 = v40;
      }
      while (v38);
      *uint64_t v36 = v40;
      v36[1] = 0;
    }
    unint64_t v37 = *(void *)(a1 + 400);
    uint64_t v35 = *(void *)(a1 + 408);
  }
  else
  {
    long long v24 = v16;
    uint64_t v25 = v42;
    kdrc_refresh::adjust(*(void *)(a1 + 512), *(void *)(a1 + 400), *(void *)(a1 + 408));
    uint64_t v26 = *(void *)(a1 + 400);
    uint64_t v27 = (HIDWORD(v25) - HIDWORD(v26));
    if ((v27 & 0x80000000) != 0
      || (uint64_t v28 = (v23 + HIDWORD(v25)),
          unsigned int v29 = *(_DWORD *)(a1 + 412) - v28 + HIDWORD(v26),
          (v29 & 0x80000000) != 0)
      || (uint64_t v30 = (v25 - v26), (v30 & 0x80000000) != 0)
      || (v31 = v22 + v25, uint64_t v32 = v26 - (v22 + v25) + *(_DWORD *)(a1 + 408),
                           (v32 & 0x80000000) != 0))
    {
      kdu_region_compositor::set_buffer_surface();
    }
    uint64_t v33 = *v24;
    if (HIDWORD(v25) != HIDWORD(v26)) {
      kdrc_refresh::add_region(*(void **)(a1 + 512), v26 & 0xFFFFFFFF00000000 | v25, v22 | (unint64_t)(v27 << 32));
    }
    if (v29) {
      kdrc_refresh::add_region(*(void **)(a1 + 512), (v28 << 32) | v25, v22 | ((unint64_t)v29 << 32));
    }
    unint64_t v34 = v33 & 0xFFFFFFFF00000000;
    if (SHIDWORD(v33) >= 1 && v25 != v26) {
      kdrc_refresh::add_region(*(void **)(a1 + 512), v26, v34 | v30);
    }
    if (SHIDWORD(v33) < 1 || !v32) {
      goto LABEL_47;
    }
    uint64_t v35 = v34 | v32;
    uint64_t v36 = *(uint64_t **)(a1 + 512);
    unint64_t v37 = v26 & 0xFFFFFFFF00000000 | v31;
  }
  kdrc_refresh::add_region(v36, v37, v35);
LABEL_47:
  for (uint64_t i = *(kdrc_stream **)(a1 + 496); i; uint64_t i = (kdrc_stream *)*((void *)i + 141))
    kdrc_refresh::adjust(*(kdrc_refresh **)(a1 + 512), i);
}

uint64_t kdu_region_compositor::set_layer_buffer_surfaces(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 480);
  if (v1)
  {
    uint64_t v2 = this;
    unint64_t v3 = *(void *)(this + 408);
    uint64_t v4 = *(unsigned int *)(this + 404);
    signed int v5 = *(_DWORD *)(this + 400);
    int v6 = v3 + v5;
    int v7 = HIDWORD(v3) + v4;
    do
    {
      this = kdrc_layer::set_buffer_surface(v1, *(void **)(v2 + 400), *(void *)(v2 + 408), (void *)(v5 | (unint64_t)(v4 << 32)), v3, *(void *)(v2 + 392), *(unsigned __int8 *)(v2 + 431));
      *(unsigned char *)(v2 + 428) = 0;
      if (!*(unsigned char *)(v1 + 232))
      {
        int v9 = *(_DWORD *)(v1 + 152);
        int v8 = *(_DWORD *)(v1 + 156);
        int v10 = *(_DWORD *)(v1 + 164) + v8;
        int v11 = *(_DWORD *)(v1 + 160) + v9;
        if (v4 == v8 && v7 == v10)
        {
          BOOL v21 = v6 <= v9 || v6 > v11;
          if (v5 >= v11 || v5 < v9) {
            int v23 = v5;
          }
          else {
            int v23 = *(_DWORD *)(v1 + 160) + v9;
          }
          BOOL v24 = !v21;
          if (v21) {
            int v25 = v23;
          }
          else {
            int v25 = v5;
          }
          if (!v24) {
            int v9 = v6;
          }
          if (v25 <= *(_DWORD *)(v2 + 400)) {
            signed int v5 = *(_DWORD *)(v2 + 400);
          }
          else {
            signed int v5 = v25;
          }
          if (v9 <= v5) {
            int v6 = v5;
          }
          else {
            int v6 = v9;
          }
          unint64_t v3 = v3 & 0xFFFFFFFF00000000 | (v6 - v5);
        }
        else if (v5 == v9 && v6 == v11)
        {
          BOOL v15 = v7 <= v8 || v7 > v10;
          if ((int)v4 >= v10 || (int)v4 < v8) {
            int v10 = v4;
          }
          BOOL v17 = !v15;
          if (v15) {
            int v18 = v10;
          }
          else {
            int v18 = v4;
          }
          if (!v17) {
            int v8 = v7;
          }
          int v19 = *(_DWORD *)(v2 + 404);
          if (v18 <= v19) {
            uint64_t v4 = v19;
          }
          else {
            uint64_t v4 = v18;
          }
          if (v8 <= (int)v4) {
            int v7 = v4;
          }
          else {
            int v7 = v8;
          }
          unint64_t v3 = v3 | ((unint64_t)(v7 - v4) << 32);
        }
      }
      uint64_t v1 = *(void *)(v1 + 248);
    }
    while (v1);
  }
  return this;
}

uint64_t kdu_region_compositor::get_total_composition_dims(kdu_region_compositor *this, kdu_dims *a2)
{
  if (!*((unsigned char *)this + 429) || (uint64_t result = kdu_region_compositor::update_composition(this), result))
  {
    *(_OWORD *)a2 = *(_OWORD *)((char *)this + 376);
    return 1;
  }
  return result;
}

uint64_t kdu_region_compositor::update_composition(kdu_region_compositor *this)
{
  *((_DWORD *)this + 85) = 0;
  if (!*((unsigned char *)this + 324)) {
    return 0;
  }
  uint64_t v2 = (int *)((char *)this + 340);
  uint64_t v3 = *((void *)this + 62);
  uint64_t v4 = *((void *)this + 59);
  if (!v3)
  {
    if (v4) {
      goto LABEL_12;
    }
    return 0;
  }
  if (!v4)
  {
    if (*(void *)(v3 + 1128)) {
      kdu_region_compositor::update_composition();
    }
    *((void *)this + 47) = kdrc_stream::set_scale(v3, 0, 0, 0, 0, 0, 0x100000001uLL, *((unsigned __int8 *)this + 334), *((float *)this + 84), *((_WORD *)this + 166), HIBYTE(*((_WORD *)this + 166)), v2);
    *((void *)this + 48) = v5;
    if (SHIDWORD(v5) < 1 || (int)v5 < 1)
    {
LABEL_10:
      uint64_t result = 0;
      *((unsigned char *)this + 324) = 0;
      return result;
    }
    uint64_t v35 = (int *)((char *)this + 376);
    goto LABEL_57;
  }
LABEL_12:
  char v8 = 0;
  unint64_t v9 = 0;
  int v10 = 0;
  int v11 = 0;
  int v12 = 0;
  do
  {
    if (v4 != *((void *)this + 59) || *(unsigned char *)(v4 + 232) || *(unsigned char *)(v4 + 234)) {
      char v8 = 1;
    }
    if (*(void *)(v4 + 72))
    {
      unint64_t v13 = kdrc_layer::set_scale((kdrc_layer *)v4, *((unsigned __int8 *)this + 334), *((unsigned __int8 *)this + 332), *((unsigned char *)this + 333), *((float *)this + 84), v2);
      if (v14 < 1 || v15 < 1) {
        goto LABEL_10;
      }
      if (v9 == v12 && v10 == v11)
      {
        int v12 = v15 + HIDWORD(v13);
        int v11 = v14 + v13;
        int v10 = v13;
        unint64_t v9 = HIDWORD(v13);
      }
      else
      {
        if ((int)v9 >= SHIDWORD(v13)) {
          unint64_t v9 = HIDWORD(v13);
        }
        else {
          unint64_t v9 = v9;
        }
        if (v10 >= (int)v13) {
          int v10 = v13;
        }
        if (v15 + HIDWORD(v13) > v12) {
          int v12 = v15 + HIDWORD(v13);
        }
        if (v11 <= v14 + (int)v13) {
          int v11 = v14 + v13;
        }
      }
    }
    uint64_t v4 = *(void *)(v4 + 240);
  }
  while (v4);
  uint64_t v35 = (int *)((char *)this + 376);
  uint64_t v17 = (v12 - v9);
  uint64_t v18 = (v11 - v10);
  *((void *)this + 47) = v10 | (v9 << 32);
  *((void *)this + 48) = v18 | (v17 << 32);
  if ((int)v17 < 1 || (int)v18 < 1 || *((int *)this + 89) > 0 && *((int *)this + 88) >= 1)
  {
    int v19 = *((_DWORD *)this + 89);
    if (v19 < 1 || (int v20 = *((_DWORD *)this + 88), v20 <= 0))
    {
      int v21 = *((_DWORD *)this + 90);
      int v22 = *((_DWORD *)this + 91);
      int v23 = *((_DWORD *)this + 93) - v22;
      int v20 = *((_DWORD *)this + 92);
    }
    else
    {
      int v21 = *((_DWORD *)this + 86);
      int v22 = *((_DWORD *)this + 87);
      int v23 = v19 - v22;
    }
    int v24 = v20 - v21;
    double v25 = *((float *)this + 84);
    unsigned int v26 = vcvtmd_s64_f64((double)v22 * v25);
    LODWORD(v27) = vcvtmd_s64_f64((double)v21 * v25);
    uint64_t v28 = vcvtpd_s64_f64(v25 * (double)v23) - v26;
    uint64_t v29 = vcvtpd_s64_f64(v25 * (double)v24) - v27;
    uint64_t v30 = v29 | (v28 << 32);
    uint64_t v31 = v28 | (v29 << 32);
    if (*((unsigned char *)this + 334)) {
      unsigned int v32 = v26;
    }
    else {
      unsigned int v32 = v27;
    }
    if (*((unsigned char *)this + 334))
    {
      uint64_t v33 = v31;
    }
    else
    {
      LODWORD(v27) = v26;
      uint64_t v33 = v30;
    }
    if (*((unsigned char *)this + 333)) {
      uint64_t v27 = (1 - v27 - HIDWORD(v33));
    }
    else {
      uint64_t v27 = v27;
    }
    LODWORD(v34) = 1 - v32 - v33;
    if (*((unsigned char *)this + 332)) {
      uint64_t v34 = v34;
    }
    else {
      uint64_t v34 = v32;
    }
    *((void *)this + 47) = v34 | (v27 << 32);
    *((void *)this + 48) = v33;
LABEL_57:
    kdu_dims::operator&=((_DWORD *)this + 100, v35);
    goto LABEL_58;
  }
  kdu_dims::operator&=((_DWORD *)this + 100, v35);
  if ((v8 & 1) == 0)
  {
    char v45 = (kdu_compositor_buf *)*((void *)this + 49);
    if (v45)
    {
      kdu_region_compositor::internal_delete_buffer(this, v45);
      *((void *)this + 49) = 0;
      *((void *)this + 52) = 0;
    }
    goto LABEL_64;
  }
LABEL_58:
  uint64_t v36 = *((unsigned int *)this + 102);
  uint64_t v37 = *((unsigned int *)this + 103);
  uint64_t buffer = *((void *)this + 49);
  if (buffer)
  {
    if ((int)v37 <= *((_DWORD *)this + 105) && (int)v36 <= *((_DWORD *)this + 104)) {
      goto LABEL_63;
    }
    kdu_region_compositor::internal_delete_buffer(this, *((kdu_compositor_buf **)this + 49));
    *((void *)this + 49) = 0;
  }
  uint64_t buffer = kdu_region_compositor::internal_allocate_buffer((uint64_t)this, v36 | (v37 << 32), (void *)this + 52);
  *((void *)this + 49) = buffer;
LABEL_63:
  initialize_buffer_surface(buffer, *((void *)this + 50), *((void *)this + 51), 0, 0, 0, *((_DWORD *)this + 106), 0);
LABEL_64:
  if (*((void *)this + 59))
  {
    kdu_region_compositor::set_layer_buffer_surfaces((uint64_t)this);
    for (uint64_t i = *((void *)this + 59); i; uint64_t i = *(void *)(i + 240))
      kdrc_layer::configure_overlay(i, *((unsigned char *)this + 430), *((_DWORD *)this + 110), *((_DWORD *)this + 109));
  }
  else
  {
    kdrc_stream::set_buffer_surface(*((void *)this + 62), *((void *)this + 49), *((void *)this + 50), *((void *)this + 51), 1);
  }
  uint64_t v40 = (uint64_t *)*((void *)this + 64);
  uint64_t v41 = v40[1];
  if (v41)
  {
    uint64_t v42 = *v40;
    do
    {
      uint64_t v43 = v41;
      uint64_t v41 = *(void *)(v41 + 16);
      *(void *)(v43 + 16) = v42;
      uint64_t v42 = v43;
    }
    while (v41);
    uint64_t *v40 = v43;
    v40[1] = 0;
  }
  kdrc_refresh::add_region(v40, *((void *)this + 50), *((void *)this + 51));
  for (uint64_t j = (kdrc_stream *)*((void *)this + 62); j; uint64_t j = (kdrc_stream *)*((void *)j + 141))
    kdrc_refresh::adjust(*((kdrc_refresh **)this + 64), j);
  *((_WORD *)this + 214) = 0;
  return 1;
}

uint64_t kdu_region_compositor::set_thread_env(void *a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    if (*(void *)(a2 + 32)) {
      uint64_t v4 = a2;
    }
    else {
      uint64_t v4 = 0;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  if (v4) {
    uint64_t v5 = a3;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v4 != a1[65] || v5 != a1[66])
  {
    for (uint64_t i = a1[62]; i; uint64_t i = *(void *)(i + 1128))
      kdrc_stream::set_thread_env(i, v4, v5);
    for (uint64_t j = a1[63]; j; uint64_t j = *(void *)(j + 1128))
      kdrc_stream::set_thread_env(j, v4, v5);
  }
  uint64_t result = a1[65];
  a1[65] = v4;
  a1[66] = v5;
  return result;
}

uint64_t kdu_region_compositor::process(kdu_region_compositor *this, int a2, kdu_dims *a3)
{
  *((_DWORD *)this + 85) = 0;
  if (*((unsigned char *)this + 429))
  {
    uint64_t result = kdu_region_compositor::update_composition(this);
    if (!result) {
      return result;
    }
  }
  if (*((unsigned char *)this + 428)) {
    return 0;
  }
  *((unsigned char *)this + 428) = 1;
  int v7 = (void *)*((void *)this + 64);
  uint64_t v8 = v7[1];
  if (!v8)
  {
    uint64_t v11 = *((void *)this + 62);
    if (!v11) {
      goto LABEL_29;
    }
    uint64_t v12 = 0;
    do
    {
      if (!*(unsigned char *)(v11 + 1124)
        && (*(unsigned char *)(v11 + 1068) || !*(unsigned char *)(*(void *)(v11 + 1136) + 296))
        && (!v12 || *(_DWORD *)(v11 + 1120) > *(_DWORD *)(v12 + 1120)))
      {
        uint64_t v12 = v11;
      }
      uint64_t v11 = *(void *)(v11 + 1128);
    }
    while (v11);
    if (v12)
    {
      if (*(unsigned char *)(v12 + 1124)) {
        kdu_region_compositor::process();
      }
      *((unsigned char *)this + 428) = 0;
      if ((kdrc_stream::process((kdrc_stream *)v12, a2, (int32x2_t *)a3, (int *)this + 85) & 1) == 0)
      {
        if (!*((_DWORD *)this + 85)) {
          kdu_region_compositor::process();
        }
        uint64_t result = 0;
        *((unsigned char *)this + 324) = 0;
        *((unsigned char *)this + 429) = 1;
        return result;
      }
    }
    else
    {
LABEL_29:
      uint64_t v13 = *((void *)this + 59);
      if (v13)
      {
        while (!*(unsigned char *)(v13 + 234) || (kdrc_layer::process_overlay((kdrc_layer *)v13, a3) & 1) == 0)
        {
          uint64_t v13 = *(void *)(v13 + 240);
          if (!v13) {
            goto LABEL_33;
          }
        }
        goto LABEL_7;
      }
    }
LABEL_33:
    if (*((unsigned char *)this + 428)) {
      return 0;
    }
    goto LABEL_8;
  }
  uint64_t v9 = *(void *)(v8 + 16);
  *(void *)(v8 + 16) = *v7;
  *int v7 = v8;
  v7[1] = v9;
  *(_OWORD *)a3 = *(_OWORD *)v8;
LABEL_7:
  *((unsigned char *)this + 428) = 0;
LABEL_8:
  if (!*((void *)this + 49)) {
    return 1;
  }
  uint64_t v10 = *((void *)this + 59);
  uint64_t result = 1;
  if (v10 && *((int *)a3 + 3) >= 1 && *((int *)a3 + 2) >= 1)
  {
    do
    {
      kdrc_layer::update_composition(v10, *(void *)a3, *((void *)a3 + 1), *((_DWORD *)this + 106));
      uint64_t v10 = *(void *)(v10 + 240);
    }
    while (v10);
    return 1;
  }
  return result;
}

void *kdu_region_compositor::reset(void *this)
{
  for (uint64_t i = this[62]; i; uint64_t i = *(void *)(i + 1128))
    *(unsigned char *)(i + 1124) = 0;
  if (this[49]) {
    this[51] = 0;
  }
  return this;
}

uint64_t kdu_region_compositor::get_next_codestream(kdu_region_compositor *this, kdrc_stream *a2, char a3, int a4)
{
  if (a2 && !*((unsigned char *)a2 + 1125))
  {
    int v7 = (char *)a2 + 1128;
    goto LABEL_9;
  }
  unsigned __int8 v4 = a3 ^ 1;
  uint64_t v5 = (char *)this + 496;
  if (a2) {
    uint64_t v5 = (char *)a2 + 1128;
  }
  uint64_t v6 = *(void *)v5;
  if (!v6 && (a3 & 1) == 0)
  {
    int v7 = (char *)this + 504;
LABEL_9:
    unsigned __int8 v4 = 0;
    uint64_t v6 = *(void *)v7;
  }
  if (v6)
  {
    uint64_t v8 = v6;
    while (a4)
    {
      if (*(void *)(*(void *)(v8 + 1136) + 320) == v8) {
        return v8;
      }
      uint64_t v8 = *(void *)(v8 + 1128);
      if (((v8 == 0) & v4) == 1)
      {
        unsigned __int8 v4 = 0;
        uint64_t v8 = *((void *)this + 63);
      }
      if (!v8) {
        return 0;
      }
    }
  }
  return v6;
}

uint64_t kdu_region_compositor::access_codestream(kdu_region_compositor *this, kdrc_stream *a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t v3 = *((void *)a2 + 142);
  uint64_t v4 = *(void *)(v3 + 320);
  if (v4)
  {
    do
    {
      if (*(unsigned char *)(v4 + 1068))
      {
        kdu_region_decompressor::finish((kdu_region_decompressor *)(v4 + 120));
        *(unsigned char *)(*(void *)(v4 + 1136) + 296) = 0;
        *(unsigned char *)(v4 + 1068) = 0;
      }
      uint64_t v4 = *(void *)(v4 + 1144);
    }
    while (v4);
    uint64_t v3 = *((void *)a2 + 142);
  }
  return *(void *)(v3 + 288);
}

uint64_t kdu_region_compositor::paint_overlay(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, uint64_t a10, int a11, int a12, char a13, char a14, char a15, uint64_t a16, uint64_t a17, unint64_t a18)
{
  v90[0] = (int32x2_t)a3;
  v90[1] = (int32x2_t)a4;
  uint64_t v89 = a8;
  int num_regions = jpx_metanode::get_num_regions((jpx_metanode *)&v89);
  uint64_t result = jpx_metanode::get_regions((jpx_metanode *)&v89);
  if (num_regions >= 1)
  {
    uint64_t v22 = result;
    uint64_t v23 = a10;
    if (a12 <= 1) {
      unsigned int v24 = 1;
    }
    else {
      unsigned int v24 = a12;
    }
    if (a11 <= 1) {
      unsigned int v25 = 1;
    }
    else {
      unsigned int v25 = a11;
    }
    uint64_t v26 = a16 >> 32;
    if (a17 >> 32 <= 1) {
      unint64_t v27 = 1;
    }
    else {
      unint64_t v27 = a17 >> 32;
    }
    LODWORD(result) = a16;
    if ((int)a17 <= 1) {
      unint64_t v28 = 1;
    }
    else {
      unint64_t v28 = (int)a17;
    }
    signed int v29 = ((char)a9 >> 7) & 0xFFFFFF00 | a9;
    if (v29 >= 2) {
      signed int v29 = 2;
    }
    if (v29 <= -2) {
      signed int v29 = -2;
    }
    uint64_t v30 = (int)a6 * (uint64_t)SHIDWORD(a6);
    if ((a9 & 0x100) != 0) {
      int v31 = 0;
    }
    else {
      int v31 = 0xFFFFFF;
    }
    int v82 = v31;
    signed int v81 = v29 << 29;
    uint64_t v86 = (a9 >> 8) % 6;
    unsigned int v84 = v25;
    unsigned int v85 = v24;
    unint64_t v83 = v27;
    do
    {
      uint64_t v32 = *(void *)v22;
      uint64_t v33 = (*(void *)v22 & 0xFFFFFFFF00000000) + v23;
      unint64_t v34 = HIDWORD(v33);
      if (v33 <= 0) {
        unsigned int v35 = -(int)(-HIDWORD(v33) / v24);
      }
      else {
        unsigned int v35 = (HIDWORD(v33) - 1) / v24 + 1;
      }
      int v36 = v32 + v23;
      if ((int)v32 + (int)v23 <= 0) {
        unsigned int v37 = -(int)(-v36 / v25);
      }
      else {
        unsigned int v37 = (v36 - 1) / v25 + 1;
      }
      int v38 = *(_DWORD *)(v22 + 12);
      BOOL v39 = __OFADD__(v34, v38);
      int v40 = v34 + v38;
      if ((v40 < 0) ^ v39 | (v40 == 0)) {
        unsigned int v41 = -(int)(-v40 / v24);
      }
      else {
        unsigned int v41 = (v40 - 1) / v24 + 1;
      }
      int v42 = *(_DWORD *)(v22 + 8) + v36;
      if (v42 <= 0) {
        unsigned int v43 = -(int)(-v42 / v25);
      }
      else {
        unsigned int v43 = (v42 - 1) / v25 + 1;
      }
      uint64_t v44 = v41 - v35;
      uint64_t v45 = v43 - v37;
      uint64_t v46 = v45 | (v44 << 32);
      uint64_t v47 = v44 | (v45 << 32);
      if (a13) {
        signed int v48 = v35;
      }
      else {
        signed int v48 = v37;
      }
      if (a13) {
        unsigned int v35 = v37;
      }
      else {
        uint64_t v47 = v46;
      }
      if (a15) {
        int v49 = 1 - v35 - HIDWORD(v47);
      }
      else {
        int v49 = v35;
      }
      if (a14) {
        signed int v48 = 1 - v48 - v47;
      }
      unint64_t v50 = (int)v26 * (uint64_t)v49;
      if ((v50 & 0x8000000000000000) != 0)
      {
        unint64_t v52 = ~v50 / v27;
        if (v52 >> 31) {
          kdrc_overlay::map_from_compositing_grid();
        }
        unint64_t v51 = ~v52;
      }
      else
      {
        unint64_t v51 = v50 / v27;
        if (v51 >> 31) {
          kdrc_overlay::map_from_compositing_grid();
        }
      }
      unint64_t v53 = (int)result * (uint64_t)v48;
      if ((v53 & 0x8000000000000000) != 0)
      {
        unint64_t v54 = ~v53 / v28;
        if (v54 >> 31) {
          kdrc_overlay::map_from_compositing_grid();
        }
        LODWORD(v54) = ~v54;
      }
      else
      {
        unint64_t v54 = v53 / v28;
        if (v54 >> 31) {
          kdrc_overlay::map_from_compositing_grid();
        }
      }
      uint64_t v55 = (int)v26 * (uint64_t)(v49 + HIDWORD(v47));
      if (v55 <= 0)
      {
        unint64_t v57 = -v55 / v27;
        if (v57 >= 0x80000001) {
          goto LABEL_97;
        }
        unint64_t v56 = -(uint64_t)v57;
      }
      else
      {
        unint64_t v56 = (v55 - 1) / v27;
        if (v56 >= 0x7FFFFFFF) {
          goto LABEL_97;
        }
        LODWORD(v56) = v56 + 1;
      }
      uint64_t v58 = (int)result * (uint64_t)(v48 + (int)v47);
      if (v58 <= 0)
      {
        unint64_t v60 = -v58 / v28;
        if (v60 >= 0x80000001)
        {
LABEL_97:
          exception = __cxa_allocate_exception(4uLL);
          _DWORD *exception = -50;
          __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
        }
        unint64_t v59 = -(uint64_t)v60;
      }
      else
      {
        unint64_t v59 = (v58 - 1) / v28;
        if (v59 >= 0x7FFFFFFF) {
          goto LABEL_97;
        }
        LODWORD(v59) = v59 + 1;
      }
      int v61 = v82;
      if (v30 > 63) {
        int v61 = 0;
      }
      if (v30 >= 64 && v86 <= 5) {
        int v61 = dword_18898EFE8[v86];
      }
      int v62 = v56 - v51;
      int v63 = v59 - v54;
      int v64 = v51 - HIDWORD(a18);
      int v65 = v54 - a18;
      int v66 = v61 - v81;
      unint64_t v87 = (v54 - a18) | ((v51 - HIDWORD(a18)) << 32);
      unint64_t v88 = (v59 - v54) | ((unint64_t)(v56 - v51) << 32);
      kdu_dims::operator&=(&v87, (int *)v90);
      unint64_t v87 = (unint64_t)vsub_s32((int32x2_t)v87, v90[0]);
      if (SHIDWORD(v88) >= 1)
      {
        int v67 = v88;
        if ((int)v88 >= 1)
        {
          if (*(unsigned char *)(a2 + 27)
            || ((*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, 0), int v67 = v88, (int)v88 >= 1))
          {
            uint64_t v68 = *(int *)(a2 + 44);
            uint64_t v69 = *(void *)(a2 + 32) + 4 * (HIDWORD(v87) + (int)v87 * (int)v68);
            uint64_t v70 = 4 * v68;
            do
            {
              if (SHIDWORD(v88) >= 1)
              {
                uint64_t v71 = 0;
                unsigned int v72 = HIDWORD(v88) + 1;
                do
                {
                  *(_DWORD *)(v69 + v71) = v66 - 1090519040;
                  v71 += 4;
                  --v72;
                }
                while (v72 > 1);
              }
              v69 += v70;
              BOOL v39 = __OFSUB__(v67--, 1);
            }
            while (!((v67 < 0) ^ v39 | (v67 == 0)));
          }
        }
      }
      LODWORD(v87) = v65 + 3;
      HIDWORD(v87) = v64 + 3;
      LODWORD(v88) = v63 - 6;
      HIDWORD(v88) = v62 - 6;
      kdu_dims::operator&=(&v87, (int *)v90);
      unint64_t v87 = (unint64_t)vsub_s32((int32x2_t)v87, v90[0]);
      int v73 = v88;
      if (SHIDWORD(v88) >= 1 && (int)v88 >= 1)
      {
        if (*(unsigned char *)(a2 + 27)
          || ((*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, 0), int v73 = v88, (int)v88 >= 1))
        {
          uint64_t v75 = *(int *)(a2 + 44);
          uint64_t v76 = *(void *)(a2 + 32) + 4 * (HIDWORD(v87) + (int)v87 * (int)v75);
          uint64_t v77 = 4 * v75;
          do
          {
            if (SHIDWORD(v88) >= 1)
            {
              uint64_t v78 = 0;
              unsigned int v79 = HIDWORD(v88) + 1;
              do
              {
                *(_DWORD *)(v76 + v78) = v66 + 1610612736;
                v78 += 4;
                --v79;
              }
              while (v79 > 1);
            }
            v76 += v77;
            BOOL v39 = __OFSUB__(v73--, 1);
          }
          while (!((v73 < 0) ^ v39 | (v73 == 0)));
        }
      }
      v22 += 20;
      BOOL v39 = __OFSUB__(num_regions--, 1);
      uint64_t v23 = a10;
      unsigned int v25 = v84;
      unsigned int v24 = v85;
      unint64_t v27 = v83;
      LODWORD(v26) = HIDWORD(a16);
      uint64_t result = (int)a16;
    }
    while (!((num_regions < 0) ^ v39 | (num_regions == 0)));
  }
  return result;
}

uint64_t kdu_region_compositor::allocate_buffer()
{
  return 0;
}

void kdrc_codestream::~kdrc_codestream(kdrc_codestream *this)
{
  if (*((void *)this + 40)) {
    __assert_rtn("~kdrc_codestream", "region_compositor_local.h", 217, "head == NULL");
  }
  if (*((void *)this + 36)) {
    kdu_codestream::destroy((kd_codestream **)this + 36);
  }
  jpx_input_box::~jpx_input_box((kdrc_codestream *)((char *)this + 8));
}

void kdu_channel_mapping::~kdu_channel_mapping(j2_colour_converter **this)
{
}

void kdrc_refresh::~kdrc_refresh(kdrc_refresh *this)
{
  for (uint64_t i = *((void *)this + 1); i; uint64_t i = *((void *)this + 1))
  {
    *((void *)this + 1) = *(void *)(i + 16);
    MEMORY[0x18C11C0E0]();
  }
  while (*(void *)this)
  {
    *(void *)this = *(void *)(*(void *)this + 16);
    MEMORY[0x18C11C0E0]();
  }
}

void kdrc_queue::~kdrc_queue(kdrc_queue *this)
{
  if (*(void *)this) {
    __assert_rtn("~kdrc_queue", "region_compositor_local.h", 59, "composition_buffer == NULL");
  }
}

uint64_t _cg_jpeg_idct_ifast(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 440);
  int v7 = (__int16 *)(a3 + 64);
  uint64_t v8 = *(void *)(a2 + 88) + 128;
  unsigned int v9 = 9;
  memset(v73, 0, sizeof(v73));
  do
  {
    uint64_t v10 = (_DWORD *)(v8 + v5);
    unsigned __int16 v11 = *(v7 - 16);
    if ((unsigned __int16)*(v7 - 24) | v11) {
      goto LABEL_9;
    }
    if (*(v7 - 8) || *v7 || v7[8] || v7[16] || v7[24])
    {
      unsigned __int16 v11 = 0;
LABEL_9:
      int v12 = *(v10 - 32) * *(v7 - 32);
      int v13 = *(v10 - 16) * (__int16)v11;
      int v14 = *v10 * *v7;
      int v15 = v10[16] * v7[16];
      int v16 = v14 + v12;
      int v17 = v12 - v14;
      int v18 = v15 + v13;
      int v19 = ((unint64_t)(362 * (v13 - v15)) >> 8) - (v15 + v13);
      int v20 = v18 + v16;
      int v21 = v16 - v18;
      int v22 = v19 + v17;
      int v23 = v17 - v19;
      int v24 = *(v10 - 24) * *(v7 - 24);
      int v25 = *(v10 - 8) * *(v7 - 8);
      int v26 = v10[8] * v7[8];
      int v27 = v10[24] * v7[24];
      int v28 = v26 + v25;
      int v29 = v26 - v25;
      int v30 = v27 + v24;
      int v31 = v24 - v27;
      int v32 = v30 + v28;
      unint64_t v33 = (unint64_t)(362 * (v30 - v28)) >> 8;
      unint64_t v34 = (_DWORD *)((char *)v73 + v5);
      _DWORD *v34 = v32 + v20;
      unint64_t v35 = (unint64_t)(473 * (v31 + v29)) >> 8;
      int v36 = v35 - (v32 + ((unint64_t)(669 * v29) >> 8));
      LODWORD(v33) = v33 - v36;
      v34[56] = v20 - v32;
      v34[8] = v36 + v22;
      int v37 = v35 - ((unint64_t)(277 * v31) >> 8) - v33;
      v34[48] = v22 - v36;
      v34[16] = v33 + v23;
      v34[40] = v23 - v33;
      v34[24] = v37 + v21;
      int v38 = v21 - v37;
      uint64_t v39 = 8;
      goto LABEL_10;
    }
    int v38 = *(v10 - 32) * *(v7 - 32);
    int v40 = (int *)((char *)v73 + v5);
    int *v40 = v38;
    v40[8] = v38;
    char v40[16] = v38;
    v40[24] = v38;
    v40[32] = v38;
    v40[40] = v38;
    v40[48] = v38;
    uint64_t v39 = 14;
LABEL_10:
    *(_DWORD *)((char *)&v73[v39] + v5) = v38;
    --v9;
    v5 += 4;
    ++v7;
  }
  while (v9 > 1);
  uint64_t v41 = v6 - 384;
  uint64_t v42 = 28;
  uint64_t v43 = a5;
  do
  {
    uint64_t v44 = (int *)((char *)v73 + v42);
    uint64_t v45 = (unsigned char *)(*a4 + v43);
    int v46 = *(_DWORD *)((char *)&v73[-1] + v42 - 8);
    unint64_t v47 = (*(_DWORD *)((char *)&v73[-1] + v42 - 12) + 16400);
    int v48 = *(_DWORD *)((char *)&v73[-1] + v42 - 4);
    if (*(void *)((char *)&v73[-1] + v42 - 8)) {
      goto LABEL_20;
    }
    if (*(v44 - 4)
      || *(_DWORD *)((char *)v73 + v42 - 12)
      || *(_DWORD *)((char *)v73 + v42 - 8)
      || *(_DWORD *)((char *)v73 + v42 - 4)
      || *(_DWORD *)((char *)v73 + v42))
    {
      int v48 = 0;
LABEL_20:
      int v50 = *(v44 - 4);
      int v49 = *(v44 - 3);
      int v51 = v49 + v47;
      int v52 = v47 - v49;
      int v54 = *(v44 - 2);
      int v53 = *(v44 - 1);
      int v55 = v53 + v48;
      int v56 = ((362 * (unint64_t)(v48 - v53)) >> 8) - (v53 + v48);
      int v57 = v55 + v51;
      int v58 = v51 - v55;
      int v59 = v56 + v52;
      int v60 = v52 - v56;
      int v61 = v50 + v54;
      unsigned int v62 = v54 - v50;
      int v63 = *v44;
      int v64 = v63 + v46;
      unsigned int v65 = v46 - v63;
      int v66 = v64 + v61;
      unint64_t v67 = (362 * (unint64_t)(v64 - v61)) >> 8;
      *uint64_t v45 = *(unsigned char *)(v41 + (((unint64_t)(v66 + v57) >> 5) & 0x3FF));
      unint64_t v68 = (473 * (unint64_t)(v65 + v62)) >> 8;
      int v69 = v66 + ((669 * (unint64_t)v62) >> 8);
      v45[7] = *(unsigned char *)(v41 + (((unint64_t)(v57 - v66) >> 5) & 0x3FF));
      v45[1] = *(unsigned char *)(v41 + (((unint64_t)(v68 - v69 + v59) >> 5) & 0x3FF));
      LODWORD(v67) = v67 - (v68 - v69);
      v45[6] = *(unsigned char *)(v41 + (((unint64_t)(v59 - (v68 - v69)) >> 5) & 0x3FF));
      v45[2] = *(unsigned char *)(v41 + (((unint64_t)(v67 + v60) >> 5) & 0x3FF));
      int v70 = v68 - ((277 * (unint64_t)v65) >> 8) - v67;
      v45[5] = *(unsigned char *)(v41 + (((unint64_t)(v60 - v67) >> 5) & 0x3FF));
      v45[3] = *(unsigned char *)(v41 + (((unint64_t)(v70 + v58) >> 5) & 0x3FF));
      uint64_t result = *(unsigned __int8 *)(v41 + (((unint64_t)(v58 - v70) >> 5) & 0x3FF));
      uint64_t v72 = 4;
      goto LABEL_21;
    }
    uint64_t result = *(unsigned __int8 *)(v41 + ((v47 >> 5) & 0x3FF));
    *(_DWORD *)uint64_t v45 = vdup_n_s8(result).u32[0];
    v45[4] = result;
    v45[5] = result;
    v45[6] = result;
    uint64_t v72 = 7;
LABEL_21:
    v45[v72] = result;
    ++a4;
    v42 += 32;
  }
  while (v42 != 284);
  return result;
}

uint64_t kdu_convert_rgb_to_ycc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(_DWORD *)a1;
  if (*(_DWORD *)a2 != *(_DWORD *)a1 || *(_DWORD *)a3 != v3) {
    return 0xFFFFFFFFLL;
  }
  int v5 = *(unsigned __int8 *)(a1 + 6);
  int v6 = *(unsigned __int8 *)(a2 + 6);
  if ((v5 ^ v6)) {
    return 0xFFFFFFFFLL;
  }
  int v7 = *(unsigned __int8 *)(a3 + 6);
  if ((v5 ^ v7)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v8 = *(__int16 **)(a1 + 8);
  if ((v5 & 2) == 0 && v8)
  {
    if ((v7 & 2) == 0)
    {
      uint64_t result = 0xFFFFFFFFLL;
      if ((v6 & 2) == 0)
      {
        uint64_t v10 = *(int **)(a2 + 8);
        if (v10)
        {
          unsigned __int16 v11 = *(int **)(a3 + 8);
          if (v11)
          {
            if (v5)
            {
              if (v3 >= 1)
              {
                unsigned int v12 = v3 + 1;
                do
                {
                  uint64_t result = 0;
                  int v13 = *v11 - *v10;
                  int v14 = *(_DWORD *)v8 - *v10;
                  *(_DWORD *)uint64_t v8 = (*(_DWORD *)v8 + 2 * *v10 + *v11) >> 2;
                  v8 += 2;
                  *v10++ = v13;
                  *v11++ = v14;
                  --v12;
                }
                while (v12 > 1);
                return result;
              }
              return 0;
            }
            if (v3 < 1) {
              return 0;
            }
            unsigned int v25 = v3 + 1;
            do
            {
              uint64_t result = 0;
              double v26 = *(float *)v8;
              double v27 = *(float *)v11;
              double v28 = *(float *)v10 * 0.587 + v26 * 0.299 + v27 * 0.114;
              double v29 = (v27 - v28) * 0.564334086;
              double v30 = v26 - v28;
              *(float *)&double v28 = v28;
              *(_DWORD *)uint64_t v8 = LODWORD(v28);
              v8 += 2;
              *(float *)&double v28 = v29;
              *v10++ = LODWORD(v28);
              *(float *)&double v30 = v30 * 0.713266762;
              *v11++ = LODWORD(v30);
              --v25;
            }
            while (v25 > 1);
          }
        }
      }
      return result;
    }
    return 0xFFFFFFFFLL;
  }
  if ((v7 & 2) == 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (v8)
  {
    if ((v6 & 2) != 0)
    {
      int v15 = *(__int16 **)(a2 + 8);
      if (v15)
      {
        int v16 = *(__int16 **)(a3 + 8);
        if (v16)
        {
          if (v5)
          {
            if (v3 < 1) {
              return 0;
            }
            unsigned int v17 = v3 + 1;
            do
            {
              uint64_t result = 0;
              int v18 = *v8;
              int v19 = *v15;
              int v20 = *v16;
              *v8++ = (v18 + 2 * v19 + v20) >> 2;
              *v15++ = v20 - v19;
              *v16++ = v18 - v19;
              --v17;
            }
            while (v17 > 1);
          }
          else
          {
            if (v3 < 1) {
              return 0;
            }
            unsigned int v21 = v3 + 1;
            do
            {
              uint64_t result = 0;
              int v22 = *v8;
              int v23 = *v16;
              int v24 = 9617 * *v15 + 4899 * v22 + 1868 * v23 + 0x2000;
              *v8++ = v24 >> 14;
              *v15++ = (9246 * (v23 - (v24 >> 14)) + 0x2000) >> 14;
              *v16++ = (11686 * (v22 - (v24 >> 14)) + 0x2000) >> 14;
              --v21;
            }
            while (v21 > 1);
          }
        }
      }
    }
  }
  return result;
}

uint64_t kdu_convert_ycc_to_rgb(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 >= 0) {
    int v4 = a4;
  }
  else {
    int v4 = *(_DWORD *)a1;
  }
  if (*(_DWORD *)a1 < v4 || *(_DWORD *)a2 < v4 || *(_DWORD *)a3 < v4) {
    return 0xFFFFFFFFLL;
  }
  int v7 = *(unsigned __int8 *)(a1 + 6);
  int v8 = *(unsigned __int8 *)(a2 + 6);
  if ((v7 ^ v8)) {
    return 0xFFFFFFFFLL;
  }
  int v9 = *(unsigned __int8 *)(a3 + 6);
  if ((v7 ^ v9)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = *(float **)(a1 + 8);
  if ((v7 & 2) == 0 && v10)
  {
    if ((v9 & 2) == 0)
    {
      uint64_t result = 0xFFFFFFFFLL;
      if ((v8 & 2) == 0)
      {
        unsigned int v12 = *(int **)(a2 + 8);
        if (v12)
        {
          int v13 = *(float **)(a3 + 8);
          if (v13)
          {
            if (v7)
            {
              if (v4 >= 1)
              {
                unsigned int v14 = v4 + 1;
                do
                {
                  uint64_t result = 0;
                  int v15 = *(_DWORD *)v10 - ((*(_DWORD *)v13 + *v12) >> 2);
                  int v16 = v15 + *v12;
                  *(_DWORD *)v10++ = v15 + *(_DWORD *)v13;
                  *v12++ = v15;
                  *(_DWORD *)v13++ = v16;
                  --v14;
                }
                while (v14 > 1);
                return result;
              }
              return 0;
            }
            if (v4 < 1) {
              return 0;
            }
            unsigned int v27 = v4 + 1;
            do
            {
              uint64_t result = 0;
              double v28 = *v10;
              double v29 = *(float *)v12;
              double v30 = *v13;
              float v31 = v28 + v30 * 1.402;
              *v10++ = v31;
              *(float *)&double v30 = v28 + v30 * -0.714136286 + v29 * -0.344136286;
              *v12++ = LODWORD(v30);
              *(float *)&double v28 = v28 + v29 * 1.772;
              *v13++ = *(float *)&v28;
              --v27;
            }
            while (v27 > 1);
          }
        }
      }
      return result;
    }
    return 0xFFFFFFFFLL;
  }
  if ((v9 & 2) == 0) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (v10)
  {
    if ((v8 & 2) != 0)
    {
      unsigned int v17 = *(__int16 **)(a2 + 8);
      if (v17)
      {
        int v18 = *(__int16 **)(a3 + 8);
        if (v18)
        {
          if (v7)
          {
            if (v4 < 1) {
              return 0;
            }
            unsigned int v19 = v4 + 1;
            do
            {
              uint64_t result = 0;
              int v20 = *v17;
              int v21 = *v18;
              unsigned int v22 = *(unsigned __int16 *)v10 - ((v21 + v20) >> 2);
              *(_WORD *)uint64_t v10 = *(_WORD *)v10 - ((v21 + v20) >> 2) + v21;
              uint64_t v10 = (float *)((char *)v10 + 2);
              *v17++ = v22;
              *v18++ = v22 + v20;
              --v19;
            }
            while (v19 > 1);
          }
          else
          {
            if (v4 < 1) {
              return 0;
            }
            unsigned int v23 = v4 + 1;
            do
            {
              uint64_t result = 0;
              int v24 = *v17;
              int v25 = *v18;
              int v26 = (*(__int16 *)v10 << 14) | 0x2000;
              *(_WORD *)uint64_t v10 = (v26 + 22970 * v25) >> 14;
              uint64_t v10 = (float *)((char *)v10 + 2);
              *v17++ = (v26 + 1073736186 * v24 + 1073730124 * v25) >> 14;
              *v18++ = (v26 + 29032 * v24) >> 14;
              --v23;
            }
            while (v23 > 1);
          }
        }
      }
    }
  }
  return result;
}

uint64_t jpeg_core_output_dimensions(uint64_t a1)
{
  uint64_t v2 = *(int *)(a1 + 556);
  unsigned int v3 = *(_DWORD *)(a1 + 72);
  unsigned int v4 = v2 * *(_DWORD *)(a1 + 68);
  if (v4 <= v3)
  {
    *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(*(unsigned int *)(a1 + 48), v2);
    uint64_t result = jdiv_round_up(*(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(void *)(a1 + 424) = 0x100000001;
    int v8 = 1;
  }
  else if (v4 <= 2 * v3)
  {
    *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(2 * *(unsigned int *)(a1 + 48), v2);
    uint64_t result = jdiv_round_up(2 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(void *)(a1 + 424) = 0x200000002;
    int v8 = 2;
  }
  else if (v4 <= 3 * v3)
  {
    *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(3 * *(unsigned int *)(a1 + 48), v2);
    uint64_t result = jdiv_round_up(3 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(void *)(a1 + 424) = 0x300000003;
    int v8 = 3;
  }
  else if (v4 <= 4 * v3)
  {
    *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(4 * *(unsigned int *)(a1 + 48), v2);
    uint64_t result = jdiv_round_up(4 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(void *)(a1 + 424) = 0x400000004;
    int v8 = 4;
  }
  else if (v4 <= 5 * v3)
  {
    *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(5 * *(unsigned int *)(a1 + 48), v2);
    uint64_t result = jdiv_round_up(5 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(void *)(a1 + 424) = 0x500000005;
    int v8 = 5;
  }
  else if (v4 <= 6 * v3)
  {
    *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(6 * *(unsigned int *)(a1 + 48), v2);
    uint64_t result = jdiv_round_up(6 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(void *)(a1 + 424) = 0x600000006;
    int v8 = 6;
  }
  else if (v4 <= 7 * v3)
  {
    *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(7 * *(unsigned int *)(a1 + 48), v2);
    uint64_t result = jdiv_round_up(7 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(void *)(a1 + 424) = 0x700000007;
    int v8 = 7;
  }
  else if (v4 <= 8 * v3)
  {
    *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(8 * *(unsigned int *)(a1 + 48), v2);
    uint64_t result = jdiv_round_up(8 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(void *)(a1 + 424) = 0x800000008;
    int v8 = 8;
  }
  else if (v4 <= 9 * v3)
  {
    *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(9 * *(unsigned int *)(a1 + 48), v2);
    uint64_t result = jdiv_round_up(9 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(void *)(a1 + 424) = 0x900000009;
    int v8 = 9;
  }
  else if (v4 <= 10 * v3)
  {
    *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(10 * *(unsigned int *)(a1 + 48), v2);
    uint64_t result = jdiv_round_up(10 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(void *)(a1 + 424) = 0xA0000000ALL;
    int v8 = 10;
  }
  else if (v4 <= 11 * v3)
  {
    int v8 = 11;
    *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(11 * *(unsigned int *)(a1 + 48), v2);
    uint64_t result = jdiv_round_up(11 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(void *)(a1 + 424) = 0xB0000000BLL;
  }
  else if (v4 <= 12 * v3)
  {
    *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(12 * *(unsigned int *)(a1 + 48), v2);
    uint64_t result = jdiv_round_up(12 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(void *)(a1 + 424) = 0xC0000000CLL;
    int v8 = 12;
  }
  else if (v4 <= 13 * v3)
  {
    int v8 = 13;
    *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(13 * *(unsigned int *)(a1 + 48), v2);
    uint64_t result = jdiv_round_up(13 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(void *)(a1 + 424) = 0xD0000000DLL;
  }
  else if (v4 <= 14 * v3)
  {
    *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(14 * *(unsigned int *)(a1 + 48), v2);
    uint64_t result = jdiv_round_up(14 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
    *(_DWORD *)(a1 + 140) = result;
    *(void *)(a1 + 424) = 0xE0000000ELL;
    int v8 = 14;
  }
  else
  {
    unsigned int v5 = 15 * v3;
    uint64_t v6 = *(unsigned int *)(a1 + 48);
    if (v4 <= v5)
    {
      *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(15 * v6, v2);
      uint64_t result = jdiv_round_up(15 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
      *(_DWORD *)(a1 + 140) = result;
      *(void *)(a1 + 424) = 0xF0000000FLL;
      int v8 = 15;
    }
    else
    {
      *(_DWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = jdiv_round_up(16 * v6, v2);
      uint64_t result = jdiv_round_up(16 * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556));
      *(_DWORD *)(a1 + 140) = result;
      *(void *)(a1 + 424) = 0x1000000010;
      int v8 = 16;
    }
  }
  int v9 = *(_DWORD *)(a1 + 56);
  if (v9 >= 1)
  {
    uint64_t v10 = (int *)(*(void *)(a1 + 304) + 40);
    do
    {
      *(v10 - 1) = v8;
      int *v10 = v8;
      v10 += 24;
      --v9;
    }
    while (v9);
  }
  return result;
}

uint64_t _cg_jinit_input_controller(uint64_t a1)
{
  uint64_t result = (**(uint64_t (***)(void))(a1 + 8))();
  *(void *)(a1 + 608) = result;
  *(void *)uint64_t result = consume_markers;
  *(void *)(result + 8) = reset_input_controller;
  *(void *)(result + 1jp2_colour_converter::clear(this + 6) = start_input_pass_0;
  *(void *)(result + 24) = finish_input_pass;
  *(void *)(result + 32) = 0;
  *(_DWORD *)(result + 40) = 1;
  return result;
}

uint64_t consume_markers(uint64_t *a1)
{
  uint64_t v1 = (_DWORD *)a1[76];
  uint64_t v2 = 2;
  if (v1[9]) {
    return v2;
  }
  while (1)
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t *))(a1[77] + 8))(a1);
    if (v5 != 1) {
      break;
    }
    int v7 = v1[10];
    if (v7)
    {
      if (v7 != 1)
      {
        if (*((_DWORD *)a1 + 112)) {
          goto LABEL_86;
        }
        goto LABEL_37;
      }
      if (*((_DWORD *)a1 + 13) > 0xFFDCu || *((_DWORD *)a1 + 12) >= 0xFFDDu)
      {
        int v8 = (void (**)(void))*a1;
        *((_DWORD *)v8 + 10) = 42;
        *((_DWORD *)v8 + 12) = 65500;
        (*(void (**)(uint64_t *))*a1)(a1);
      }
      int v9 = *((_DWORD *)a1 + 74);
      if ((v9 - 13) <= 0xFFFFFFFA)
      {
        uint64_t v10 = (void (**)(void))*a1;
        *((_DWORD *)v10 + 10) = 16;
        *((_DWORD *)v10 + 12) = v9;
        (*(void (**)(uint64_t *))*a1)(a1);
      }
      int v11 = *((_DWORD *)a1 + 14);
      if (v11 >= 11)
      {
        unsigned int v12 = (void (**)(void))*a1;
        *((_DWORD *)v12 + 10) = 27;
        *((_DWORD *)v12 + 12) = v11;
        *(_DWORD *)(*a1 + 52) = 10;
        (*(void (**)(uint64_t *))*a1)(a1);
        int v11 = *((_DWORD *)a1 + 14);
      }
      a1[52] = 0x100000001;
      if (v11 >= 1)
      {
        int v13 = 0;
        uint64_t v14 = a1[38] + 8;
        v6.n128_u64[0] = 0x100000001;
        do
        {
          if ((*(_DWORD *)v14 - 5) >= 0xFFFFFFFC && (*(_DWORD *)(v14 + 4) - 5) > 0xFFFFFFFB)
          {
            int32x2_t v16 = *(int32x2_t *)v14;
          }
          else
          {
            uint64_t v15 = *a1;
            *(_DWORD *)(v15 + 40) = 19;
            (*(void (**)(uint64_t *, __n128))v15)(a1, v6);
            v6.n128_u64[0] = a1[52];
            int32x2_t v16 = *(int32x2_t *)v14;
            int v11 = *((_DWORD *)a1 + 14);
          }
          v6.n128_u64[0] = (unint64_t)vmax_s32((int32x2_t)v6.n128_u64[0], v16);
          a1[52] = v6.n128_u64[0];
          ++v13;
          v14 += 96;
        }
        while (v13 < v11);
      }
      if (*((_DWORD *)a1 + 78) || *((_DWORD *)a1 + 79) && *((_DWORD *)a1 + 112))
      {
LABEL_21:
        int v17 = 8;
LABEL_22:
        *((_DWORD *)a1 + 139) = v17;
        a1[70] = (uint64_t)&_cg_jpeg_natural_order;
        *((_DWORD *)a1 + 142) = 63;
        goto LABEL_23;
      }
      int v24 = *((_DWORD *)a1 + 136);
      if (v24 > 79)
      {
        if (v24 > 167)
        {
          if (v24 > 223)
          {
            if (v24 == 224)
            {
              int v17 = 15;
              goto LABEL_22;
            }
            if (v24 == 255)
            {
              int v17 = 16;
              goto LABEL_22;
            }
          }
          else
          {
            if (v24 == 168)
            {
              int v17 = 13;
              goto LABEL_22;
            }
            if (v24 == 195)
            {
              int v17 = 14;
              goto LABEL_22;
            }
          }
        }
        else if (v24 > 119)
        {
          if (v24 == 120)
          {
            int v17 = 11;
            goto LABEL_22;
          }
          if (v24 == 143)
          {
            int v17 = 12;
            goto LABEL_22;
          }
        }
        else
        {
          if (v24 == 80)
          {
            int v17 = 9;
            goto LABEL_22;
          }
          if (v24 == 99)
          {
            int v17 = 10;
            goto LABEL_22;
          }
        }
      }
      else if (v24 > 23)
      {
        if (v24 > 47)
        {
          if (v24 == 48)
          {
            int v17 = 7;
            *((_DWORD *)a1 + 139) = 7;
            a1[70] = (uint64_t)&jpeg_natural_order7;
            int v25 = 48;
            goto LABEL_78;
          }
          if (v24 == 63) {
            goto LABEL_21;
          }
        }
        else
        {
          if (v24 == 24)
          {
            int v17 = 5;
            *((_DWORD *)a1 + 139) = 5;
            a1[70] = (uint64_t)&jpeg_natural_order5;
            int v25 = 24;
            goto LABEL_78;
          }
          if (v24 == 35)
          {
            int v17 = 6;
            *((_DWORD *)a1 + 139) = 6;
            a1[70] = (uint64_t)&jpeg_natural_order6;
            int v25 = 35;
            goto LABEL_78;
          }
        }
      }
      else if (v24 > 7)
      {
        if (v24 == 8)
        {
          int v17 = 3;
          *((_DWORD *)a1 + 139) = 3;
          a1[70] = (uint64_t)&jpeg_natural_order3;
          int v25 = 8;
          goto LABEL_78;
        }
        if (v24 == 15)
        {
          int v17 = 4;
          *((_DWORD *)a1 + 139) = 4;
          a1[70] = (uint64_t)&jpeg_natural_order4;
          int v25 = 15;
          goto LABEL_78;
        }
      }
      else
      {
        if (!v24)
        {
          int v17 = 1;
          *((_DWORD *)a1 + 139) = 1;
          a1[70] = (uint64_t)&_cg_jpeg_natural_order;
          *((_DWORD *)a1 + 142) = 0;
          goto LABEL_23;
        }
        if (v24 == 3)
        {
          int v17 = 2;
          *((_DWORD *)a1 + 139) = 2;
          a1[70] = (uint64_t)&jpeg_natural_order2;
          int v25 = 3;
LABEL_78:
          *((_DWORD *)a1 + 142) = v25;
          goto LABEL_23;
        }
      }
      uint64_t v26 = *a1;
      *(_DWORD *)(v26 + 40) = 17;
      *(_DWORD *)(v26 + 48) = *((_DWORD *)a1 + 135);
      *(_DWORD *)(*a1 + 52) = *((_DWORD *)a1 + 136);
      *(_DWORD *)(*a1 + 5jp2_colour_converter::clear(this + 6) = *((_DWORD *)a1 + 137);
      *(_DWORD *)(*a1 + 60) = *((_DWORD *)a1 + 138);
      (*(void (**)(uint64_t *))*a1)(a1);
      int v17 = *((_DWORD *)a1 + 139);
      int v11 = *((_DWORD *)a1 + 14);
LABEL_23:
      *((_DWORD *)a1 + 10jp2_colour_converter::clear(this + 6) = v17;
      *((_DWORD *)a1 + 107) = v17;
      if (v11 >= 1)
      {
        int v18 = 0;
        uint64_t v19 = a1[38] + 40;
        do
        {
          int v20 = *((_DWORD *)a1 + 139);
          *(_DWORD *)(v19 - 4) = v20;
          *(_DWORD *)uint64_t v19 = v20;
          *(_DWORD *)(v19 - 12) = jdiv_round_up(*(int *)(v19 - 32) * (unint64_t)*((unsigned int *)a1 + 12), *((int *)a1 + 104) * (uint64_t)v20);
          *(_DWORD *)(v19 - 8) = jdiv_round_up(*(int *)(v19 - 28) * (unint64_t)*((unsigned int *)a1 + 13), *((int *)a1 + 139) * (uint64_t)*((int *)a1 + 105));
          *(_DWORD *)(v19 + 4) = jdiv_round_up(*(int *)(v19 - 32) * (unint64_t)*((unsigned int *)a1 + 12), *((int *)a1 + 104));
          *(_DWORD *)(v19 + 8) = jdiv_round_up(*(int *)(v19 - 28) * (unint64_t)*((unsigned int *)a1 + 13), *((int *)a1 + 105));
          *(_DWORD *)(v19 + 12) = 1;
          *(void *)(v19 + 40) = 0;
          ++v18;
          v19 += 96;
        }
        while (v18 < *((_DWORD *)a1 + 14));
        int v17 = *((_DWORD *)a1 + 139);
      }
      *((_DWORD *)a1 + 108) = jdiv_round_up(*((unsigned int *)a1 + 13), *((int *)a1 + 105) * (uint64_t)v17);
      int v21 = *((_DWORD *)a1 + 112);
      BOOL v22 = v21 < *((_DWORD *)a1 + 14) || *((_DWORD *)a1 + 79) != 0;
      *(_DWORD *)(a1[76] + 32) = v22;
      if (v21)
      {
LABEL_86:
        v1[10] = 0;
        return 1;
      }
LABEL_37:
      v1[10] = 2;
    }
    else
    {
      if (!v1[8])
      {
        uint64_t v23 = *a1;
        *(_DWORD *)(v23 + 40) = 36;
        (*(void (**)(uint64_t *))v23)(a1);
      }
      if (*((_DWORD *)a1 + 112))
      {
        start_input_pass_0(a1);
        return 1;
      }
    }
  }
  if (v5 != 2) {
    return v5;
  }
  v1[9] = 1;
  if (v1[10])
  {
    if (*(_DWORD *)(a1[77] + 28))
    {
      uint64_t v27 = *a1;
      *(_DWORD *)(v27 + 40) = 62;
      (*(void (**)(uint64_t *))v27)(a1);
    }
  }
  else
  {
    int v28 = *((_DWORD *)a1 + 43);
    if (*((_DWORD *)a1 + 45) > v28) {
      *((_DWORD *)a1 + 45) = v28;
    }
  }
  return 2;
}

uint64_t reset_input_controller(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 608);
  *(void *)uint64_t v2 = consume_markers;
  *(void *)(v2 + 32) = 0;
  *(_DWORD *)(v2 + 40) = 1;
  (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
  uint64_t result = (**(uint64_t (***)(uint64_t))(a1 + 616))(a1);
  *(void *)(a1 + 192) = 0;
  return result;
}

uint64_t start_input_pass_0(uint64_t *a1)
{
  int v2 = *((_DWORD *)a1 + 112);
  if (v2 == 1)
  {
    uint64_t v3 = a1[57];
    unsigned int v4 = *(_DWORD *)(v3 + 32);
    *((_DWORD *)a1 + 122) = *(_DWORD *)(v3 + 28);
    *((_DWORD *)a1 + 123) = v4;
    *(void *)(v3 + 5jp2_colour_converter::clear(this + 6) = 0x100000001;
    LODWORD(v5) = 1;
    int v6 = *(_DWORD *)(v3 + 36);
    *(_DWORD *)(v3 + 64) = 1;
    *(_DWORD *)(v3 + 68) = v6;
    int v7 = v4 % *(_DWORD *)(v3 + 12);
    if (!v7) {
      int v7 = *(_DWORD *)(v3 + 12);
    }
    *(_DWORD *)(v3 + 72) = 1;
    *(_DWORD *)(v3 + 7jp2_colour_converter::clear(this + 6) = v7;
    a1[62] = 1;
LABEL_20:
    uint64_t v20 = 0;
    do
    {
      uint64_t v21 = a1[v20 + 57];
      if (!*(void *)(v21 + 80))
      {
        uint64_t v22 = *(unsigned int *)(v21 + 16);
        if (v22 > 3 || !a1[v22 + 25])
        {
          uint64_t v23 = (void (**)(void))*a1;
          *((_DWORD *)v23 + 10) = 54;
          *((_DWORD *)v23 + 12) = v22;
          (*(void (**)(uint64_t *))*a1)(a1);
        }
        uint64_t v24 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))a1[1])(a1, 1, 132);
        uint64_t v5 = a1[(int)v22 + 25];
        *(_OWORD *)uint64_t v24 = *(_OWORD *)v5;
        long long v25 = *(_OWORD *)(v5 + 16);
        long long v26 = *(_OWORD *)(v5 + 32);
        long long v27 = *(_OWORD *)(v5 + 64);
        *(_OWORD *)(v24 + 48) = *(_OWORD *)(v5 + 48);
        *(_OWORD *)(v24 + 64) = v27;
        *(_OWORD *)(v24 + 1jp2_colour_converter::clear(this + 6) = v25;
        *(_OWORD *)(v24 + 32) = v26;
        long long v28 = *(_OWORD *)(v5 + 80);
        long long v29 = *(_OWORD *)(v5 + 96);
        long long v30 = *(_OWORD *)(v5 + 112);
        *(_DWORD *)(v24 + 128) = *(_DWORD *)(v5 + 128);
        *(_OWORD *)(v24 + 9jp2_colour_converter::clear(this + 6) = v29;
        *(_OWORD *)(v24 + 112) = v30;
        *(_OWORD *)(v24 + 80) = v28;
        *(void *)(v21 + 80) = v24;
        LODWORD(v5) = *((_DWORD *)a1 + 112);
      }
      ++v20;
    }
    while (v20 < (int)v5);
    goto LABEL_27;
  }
  if ((v2 - 5) <= 0xFFFFFFFB)
  {
    int v8 = (void (**)(void))*a1;
    *((_DWORD *)v8 + 10) = 27;
    *((_DWORD *)v8 + 12) = v2;
    *(_DWORD *)(*a1 + 52) = 4;
    (*(void (**)(uint64_t *))*a1)(a1);
  }
  *((_DWORD *)a1 + 122) = jdiv_round_up(*((unsigned int *)a1 + 12), *((int *)a1 + 139) * (uint64_t)*((int *)a1 + 104));
  *((_DWORD *)a1 + 123) = jdiv_round_up(*((unsigned int *)a1 + 13), *((int *)a1 + 139) * (uint64_t)*((int *)a1 + 105));
  *((_DWORD *)a1 + 124) = 0;
  if (*((int *)a1 + 112) >= 1)
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = (_DWORD *)a1[v9 + 57];
      unsigned int v11 = v10[2];
      unsigned int v12 = v10[3];
      int v13 = v12 * v11;
      unsigned int v14 = v10[8];
      int v15 = v10[9] * v11;
      v10[16] = v12 * v11;
      v10[17] = v15;
      int v16 = v10[7] % v11;
      v10[14] = v11;
      v10[15] = v12;
      if (v16) {
        unsigned int v11 = v16;
      }
      if (v14 % v12) {
        unsigned int v12 = v14 % v12;
      }
      v10[18] = v11;
      v10[19] = v12;
      if (*((_DWORD *)a1 + 124) + v13 >= 11)
      {
        uint64_t v17 = *a1;
        *(_DWORD *)(v17 + 40) = 14;
        (*(void (**)(uint64_t *))v17)(a1);
      }
      if (v13 >= 1)
      {
        unsigned int v18 = v13 + 1;
        do
        {
          uint64_t v19 = *((int *)a1 + 124);
          *((_DWORD *)a1 + 124) = v19 + 1;
          *((_DWORD *)a1 + v19 + 125) = v9;
          --v18;
        }
        while (v18 > 1);
      }
      ++v9;
      uint64_t v5 = *((int *)a1 + 112);
    }
    while (v9 < v5);
    if ((int)v5 >= 1) {
      goto LABEL_20;
    }
  }
LABEL_27:
  (*(void (**)(uint64_t *))a1[78])(a1);
  uint64_t result = (*(uint64_t (**)(uint64_t *))a1[74])(a1);
  *(void *)a1[76] = *(void *)(a1[74] + 8);
  return result;
}

uint64_t finish_input_pass(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 624) + 16))();
  **(void **)(a1 + 608) = consume_markers;
  return result;
}

uint64_t jx_fragment_list::init(jx_fragment_list *this, jp2_input_box *a2)
{
  if (*((_DWORD *)a2 + 12) != 1718383476) {
    jx_fragment_list::init();
  }
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 1) = 0;
  unsigned __int16 v11 = 0;
  if (!jp2_input_box::read(a2, &v11))
  {
    uint64_t v10 = 0;
    long long v8 = 0u;
    long long v9 = 0u;
    kdu_error::kdu_error((kdu_error *)&v8, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v8 + 16))(&v8, "Error encountered reading fragment list (flst) box.  Unable to read the initial fragment count.");
    kdu_error::~kdu_error((kdu_error *)&v8);
  }
  for (*(void *)&v7[1] = this; v11; --v11)
  {
    v7[0] = 0;
    unsigned int v6 = 0;
    *(void *)uint64_t v5 = 0;
    if (!jp2_input_box::read(a2, &v6)
      || !jp2_input_box::read(a2, &v5[1])
      || !jp2_input_box::read(a2, v5)
      || !jp2_input_box::read(a2, v7))
    {
      uint64_t v10 = 0;
      long long v8 = 0u;
      long long v9 = 0u;
      kdu_error::kdu_error((kdu_error *)&v8, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v8 + 16))(&v8, "Error encountered reading fragment list (flst) box.  Contents of box terminated prematurely.");
      kdu_error::~kdu_error((kdu_error *)&v8);
    }
    jpx_fragment_list::add_fragment((uint64_t *)&v7[1], v7[0], v5[1] | ((unint64_t)v6 << 32), v5[0]);
  }
  return (*(uint64_t (**)(jp2_input_box *))(*(void *)a2 + 16))(a2);
}

void sub_1886E3628(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886E3634(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Resume(v13);
}

uint64_t *jpx_fragment_list::add_fragment(uint64_t *this, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *this;
  int v5 = *(_DWORD *)(*this + 4);
  if (v5 == *(_DWORD *)*this)
  {
    int v6 = 2 * v5 + 8;
    *(_DWORD *)uint64_t v4 = v6;
    is_mul_ok(v6, 0x18uLL);
    operator new[]();
  }
  unint64_t v7 = *(void *)(v4 + 8);
  long long v8 = (void *)(v7 + 24 * v5);
  if ((unint64_t)(v8 - 3) >= v7 && *((_DWORD *)v8 - 2) == a2 && (uint64_t v9 = *(v8 - 2), v9 + *(v8 - 3) == a3))
  {
    *(v8 - 2) = v9 + a4;
  }
  else
  {
    *(_DWORD *)(v4 + 4) = v5 + 1;
    unint64_t v10 = v7 + 24 * v5;
    *(_DWORD *)(v10 + 1jp2_colour_converter::clear(this + 6) = a2;
    *long long v8 = a3;
    *(void *)(v10 + 8) = a4;
  }
  *(void *)(v4 + 16) += a4;
  return this;
}

void jpx_input_box::jpx_input_box(jpx_input_box *this)
{
  jp2_input_box::jp2_input_box(this);
  *(void *)uint64_t v1 = &unk_1ED4E0E28;
  *(void *)(v1 + 184) = 0;
  *(void *)(v1 + 192) = 0;
  *(_DWORD *)(v1 + 240) = -1;
  *(_DWORD *)(v1 + 200) = -1;
  *(void *)(v1 + 272) = 0;
  *(_OWORD *)(v1 + 208) = 0u;
  *(_OWORD *)(v1 + 224) = 0u;
  *(void *)(v1 + 248) = 0;
  *(void *)(v1 + 25jp2_colour_converter::clear(this + 6) = 0;
  *(_DWORD *)(v1 + 264) = 0;
}

uint64_t jpx_input_box::open_next(jpx_input_box *this)
{
  if (*((void *)this + 32)) {
    return 0;
  }
  else {
    return jp2_input_box::open_next(this);
  }
}

uint64_t jpx_input_box::open_as(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  if (*(unsigned char *)(a1 + 126))
  {
    uint64_t v9 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  if (!a4)
  {
    uint64_t v9 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  *(void *)(a1 + 184) = a2;
  *(void *)(a1 + 25jp2_colour_converter::clear(this + 6) = a4;
  if (!*(void *)(a4 + 32)) {
    *(void *)(a1 + 192) = a3;
  }
  *(_OWORD *)(a1 + 8) = xmmword_18898D150;
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = a5;
  if (a2) {
    uint64_t v5 = *(void *)(a2 + 16);
  }
  else {
    uint64_t v5 = 0;
  }
  *(void *)(a1 + 5jp2_colour_converter::clear(this + 6) = v5;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = v5;
  *(void *)(a1 + 9jp2_colour_converter::clear(this + 6) = -1;
  *(void *)(a1 + 104) = -1;
  *(void *)(a1 + 112) = -1;
  *(_DWORD *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 124) = 0x10000;
  *(_DWORD *)(a1 + 128) = 3;
  *(_OWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = xmmword_18898D150;
  *(_DWORD *)(a1 + 17jp2_colour_converter::clear(this + 6) = 0;
  *(_DWORD *)(a1 + 200) = -1;
  *(_DWORD *)(a1 + 240) = -1;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 21jp2_colour_converter::clear(this + 6) = 0;
  return 1;
}

void sub_1886E39AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886E39B8()
{
  _Unwind_Resume(v0);
}

uint64_t jpx_input_box::close(jpx_input_box *this)
{
  int v2 = (FILE *)*((void *)this + 29);
  if (v2)
  {
    fclose(v2);
    *((void *)this + 29) = 0;
  }
  uint64_t v3 = *((void *)this + 34);
  if (v3)
  {
    MEMORY[0x18C11C0C0](v3, 0x1000C8077774924);
    *((void *)this + 34) = 0;
  }
  *((_DWORD *)this + 6jp2_colour_converter::clear(this + 6) = 0;
  *((_DWORD *)this + 50) = -1;
  *((_DWORD *)this + 60) = -1;
  *((void *)this + 23) = 0;
  *((void *)this + 24) = 0;
  *((void *)this + 27) = 0;
  *((void *)this + 28) = 0;
  *((void *)this + 2jp2_colour_converter::clear(this + 6) = 0;
  *((void *)this + 31) = 0;
  *((void *)this + 32) = 0;

  return jp2_input_box::close(this);
}

BOOL jpx_input_box::seek(jpx_input_box *this, uint64_t a2)
{
  if (*((void *)this + 32))
  {
    if (*((void *)this + 10)) {
      jpx_input_box::seek();
    }
    uint64_t v2 = *((void *)this + 17);
    if (v2 != a2)
    {
      if (a2 < 0)
      {
        uint64_t v3 = 0;
      }
      else
      {
        uint64_t v3 = *((void *)this + 11);
        if (v3 >= a2) {
          uint64_t v3 = a2;
        }
      }
      *((void *)this + 17) = v3;
      if ((*((_DWORD *)this + 50) & 0x80000000) != 0 || v3 < *((void *)this + 26) || v3 >= *((void *)this + 27))
      {
        *((_DWORD *)this + 50) = -1;
        *((void *)this + 27) = 0;
        *((void *)this + 28) = 0;
        *((void *)this + 2jp2_colour_converter::clear(this + 6) = 0;
      }
      else
      {
        *((void *)this + 28) += v3 - v2;
      }
    }
    return 1;
  }
  else
  {
    return jp2_input_box::seek(this, a2);
  }
}

size_t jpx_input_box::read(jpx_input_box *this, unsigned __int8 *a2, int64_t a3)
{
  int v3 = a3;
  uint64_t v4 = a2;
  if (*((void *)this + 32))
  {
    if ((int)a3 >= 1)
    {
      uint64_t v6 = 0;
      long long v7 = (void *)((char *)this + 192);
      uint64_t v8 = *((void *)this + 17);
      while (1)
      {
        if ((*((_DWORD *)this + 50) & 0x80000000) != 0 || v8 >= *((void *)this + 27))
        {
          if (v8 < 0) {
            goto LABEL_50;
          }
          uint64_t v9 = *((void *)this + 23);
          uint64_t v10 = *(unsigned int *)(v9 + 4);
          if ((int)v10 < 1) {
            goto LABEL_50;
          }
          uint64_t v11 = 0;
          uint64_t v12 = *(void *)(v9 + 8) + 8;
          uint64_t v13 = v8;
          while (1)
          {
            uint64_t v14 = v13 - *(void *)v12;
            if (v14 < 0) {
              break;
            }
            ++v11;
            v12 += 24;
            uint64_t v13 = v14;
            if (v10 == v11) {
              goto LABEL_50;
            }
          }
          *((_DWORD *)this + 50) = v11;
          if ((v11 & 0x80000000) != 0 || (int)v10 <= (int)v11)
          {
LABEL_50:
            *((_DWORD *)this + 50) = -1;
            return v6;
          }
          int v15 = *(_DWORD *)(v12 + 8);
          uint64_t v16 = *(void *)(v12 - 8);
          *((void *)this + 28) = v16;
          uint64_t v17 = *(void *)v12;
          *((void *)this + 28) = v16 + v13;
          uint64_t v18 = v8 - v13;
          *((void *)this + 2jp2_colour_converter::clear(this + 6) = v18;
          *((void *)this + 27) = v17 + v18;
          if (v15 != *((_DWORD *)this + 60))
          {
            uint64_t v19 = (FILE *)*((void *)this + 29);
            if (v19)
            {
              fclose(v19);
              *((void *)this + 29) = 0;
              *((_DWORD *)this + 60) = -1;
            }
            if (v15)
            {
              if (!*v7) {
                goto LABEL_50;
              }
              url = jp2_data_references::get_url((jpx_input_box *)((char *)this + 192), v15);
              if (!url) {
                goto LABEL_50;
              }
              if (*url)
              {
                uint64_t v21 = jpx_input_box::url_fopen(this, url);
                *((void *)this + 29) = v21;
                if (!v21) {
                  goto LABEL_50;
                }
              }
            }
            *((void *)this + 31) = 0;
            *((_DWORD *)this + 60) = v15;
          }
        }
        uint64_t v22 = *((void *)this + 28);
        uint64_t v23 = (FILE *)*((void *)this + 29);
        if (v22 != *((void *)this + 31))
        {
          if (v23)
          {
            fseek(*((FILE **)this + 29), v22, 0);
            uint64_t v22 = *((void *)this + 28);
            uint64_t v23 = (FILE *)*((void *)this + 29);
          }
          *((void *)this + 31) = v22;
        }
        uint64_t v24 = *((void *)this + 17);
        uint64_t v25 = v24 + v3;
        uint64_t v26 = *((void *)this + 27);
        unsigned int v27 = v26 - v24;
        if (v25 <= v26) {
          uint64_t v28 = v3;
        }
        else {
          uint64_t v28 = v27;
        }
        if (v23)
        {
          LODWORD(v28) = fread(v4, 1uLL, (int)v28, v23);
          if (!v28) {
            return v6;
          }
        }
        else
        {
          long long v29 = (void *)*((void *)this + 32);
          if (v29[4]) {
            return v6;
          }
          (*(void (**)(void *))(*v29 + 16))(v29);
          long long v30 = (void *)*((void *)this + 32);
          uint64_t v31 = *((void *)this + 17);
          if (v30[5] != v31)
          {
            int v32 = (FILE *)v30[2];
            if (v32)
            {
              fseek(v32, v31, 0);
            }
            else
            {
              uint64_t v33 = v30[3];
              if (v33) {
                (*(void (**)(uint64_t))(*(void *)v33 + 40))(v33);
              }
            }
          }
          uint64_t v34 = *((void *)this + 32);
          unint64_t v35 = *(FILE **)(v34 + 16);
          if (v35)
          {
            LODWORD(v28) = fread(v4, 1uLL, (int)v28, v35);
          }
          else
          {
            uint64_t v36 = *(void *)(v34 + 24);
            if (v36) {
              LODWORD(v28) = (*(uint64_t (**)(uint64_t, unsigned __int8 *, uint64_t))(*(void *)v36 + 32))(v36, v4, v28);
            }
          }
          int v37 = (void *)*((void *)this + 32);
          v37[5] = *((void *)this + 17) + (int)v28;
          (*(void (**)(void *))(*v37 + 24))(v37);
          if (!v28) {
            return v6;
          }
        }
        uint64_t v6 = (v28 + v6);
        v4 += (int)v28;
        uint64_t v8 = *((void *)this + 17) + (int)v28;
        *((void *)this + 17) = v8;
        *((void *)this + 28) += (int)v28;
        *((void *)this + 31) += (int)v28;
        BOOL v38 = __OFSUB__(v3, v28);
        v3 -= v28;
        if ((v3 < 0) ^ v38 | (v3 == 0)) {
          return v6;
        }
      }
    }
    return 0;
  }
  else
  {
    return jp2_input_box::read(this, a2, a3);
  }
}

FILE *jpx_input_box::url_fopen(jpx_input_box *this, const char *__s)
{
  uint64_t v2 = __s;
  int v4 = *(unsigned __int8 *)__s;
  if (!*__s || v4 != 47 && v4 != 92 && (__s[1] != 58 || (int v5 = *((unsigned __int8 *)__s + 2), v5 != 47) && v5 != 92))
  {
    uint64_t v6 = *(const char **)(*((void *)this + 32) + 8);
    if (v6)
    {
      int v7 = strlen(__s);
      int v8 = strlen(v6) + v7 + 2;
      int v9 = *((_DWORD *)this + 66);
      if (v8 > v9)
      {
        *((_DWORD *)this + 6jp2_colour_converter::clear(this + 6) = v8 + v9;
        uint64_t v10 = *((void *)this + 34);
        if (v10) {
          MEMORY[0x18C11C0C0](v10, 0x1000C8077774924);
        }
        operator new[]();
      }
      strcpy(*((char **)this + 34), v6);
      uint64_t v11 = (const char *)*((void *)this + 34);
      uint64_t v12 = (char *)&v11[strlen(v11)];
      do
      {
        uint64_t v13 = v12;
        if (v12 <= v11) {
          break;
        }
        --v12;
        int v14 = *(v13 - 1);
        if (v14 == 92) {
          break;
        }
      }
      while (v14 != 47);
      strcpy(v13, v2);
      uint64_t v2 = (const char *)*((void *)this + 34);
    }
  }

  return fopen(v2, "rb");
}

uint64_t jx_compatibility::init_ftyp(jx_compatibility *this, jp2_input_box *a2)
{
  if (*((_DWORD *)a2 + 12) != 1718909296) {
    jx_compatibility::init_ftyp();
  }
  *(void *)uint64_t v13 = 0;
  unsigned int v12 = 0;
  jp2_input_box::read(a2, &v13[1]);
  jp2_input_box::read(a2, v13);
  LOBYTE(v4) = 0;
  LOBYTE(v5) = 0;
  char v6 = 0;
  if (jp2_input_box::read(a2, &v12))
  {
    char v6 = 0;
    int v5 = 0;
    int v4 = 0;
    do
    {
      if (v12 == 1785755680) {
        int v7 = 1;
      }
      else {
        int v7 = v4;
      }
      if (v12 == 1785755746)
      {
        int v7 = 1;
        int v8 = 1;
      }
      else
      {
        int v8 = v5;
      }
      if (v12 == 1785737760)
      {
        char v6 = 1;
      }
      else
      {
        int v4 = v7;
        int v5 = v8;
      }
    }
    while (jp2_input_box::read(a2, &v12));
  }
  if (((*(uint64_t (**)(jp2_input_box *))(*(void *)a2 + 16))(a2) & 1) == 0)
  {
    uint64_t v11 = 0;
    memset(v10, 0, sizeof(v10));
    kdu_error::kdu_error((kdu_error *)v10, "Error in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v10[0] + 16))(v10, "JP2-family data source contains a malformed file type box.");
    kdu_error::~kdu_error((kdu_error *)v10);
  }
  if ((v6 | v4))
  {
    *(unsigned char *)this = v13[1] == 1785737760 || (v4 & 1) == 0;
    *((unsigned char *)this + 1) = v6 & 1;
    *((unsigned char *)this + 2) = v5 & 1;
    *((unsigned char *)this + 3) = 0;
  }
  return (v6 | v4) & 1;
}

void sub_1886E4164(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886E4170()
{
  _Unwind_Resume(v0);
}

void jx_compatibility::init_rreq(jx_compatibility *this, jp2_input_box *a2)
{
  if (*((_DWORD *)a2 + 12) == 1920099697)
  {
    __int16 v16 = 0;
    (*(void (**)(jp2_input_box *, __int16 *, uint64_t))(*(void *)a2 + 32))(a2, &v16, 1);
    if ((_BYTE)v16)
    {
      unsigned int v4 = 0;
      unsigned int v5 = 0;
      int v6 = 24;
      do
      {
        if (v6 >= 0) {
          int v7 = v6;
        }
        else {
          int v7 = 24;
        }
        v4 += v6 >> 31;
        (*(void (**)(jp2_input_box *, char *, uint64_t))(*(void *)a2 + 32))(a2, (char *)&v16 + 1, 1);
        *((_DWORD *)this + v4 + 10) |= HIBYTE(v16) << v7;
        if (v5 > 0x1E) {
          break;
        }
        ++v5;
        int v6 = v7 - 8;
      }
      while (v5 < v16);
      if ((_BYTE)v16)
      {
        unsigned int v8 = 0;
        unsigned int v9 = 0;
        int v10 = 24;
        do
        {
          if (v10 >= 0) {
            int v11 = v10;
          }
          else {
            int v11 = 24;
          }
          v8 += v10 >> 31;
          (*(void (**)(jp2_input_box *, char *, uint64_t))(*(void *)a2 + 32))(a2, (char *)&v16 + 1, 1);
          *((_DWORD *)this + v8 + 18) |= HIBYTE(v16) << v11;
          if (v9 > 0x1E) {
            break;
          }
          ++v9;
          int v10 = v11 - 8;
        }
        while (v9 < v16);
      }
    }
    unsigned __int16 v15 = 0;
    if (!jp2_input_box::read(a2, &v15))
    {
      uint64_t v14 = 0;
      memset(v13, 0, sizeof(v13));
      kdu_error::kdu_error((kdu_error *)v13, "Error in Kakadu File Format Support:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v13[0] + 16))(v13, "Malformed reader requirements (rreq) box found in JPX data source.  Box terminated unexpectedly.");
      kdu_error::~kdu_error((kdu_error *)v13);
    }
    *((unsigned char *)this + 3) = 1;
    int v12 = v15;
    *((_DWORD *)this + 3) = v15;
    *((_DWORD *)this + 4) = v12;
    operator new[]();
  }
  jx_compatibility::init_rreq();
}

void sub_1886E47E0(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886E47EC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

void jx_composition::add_frame(jx_composition *this)
{
  uint64_t v1 = *((void *)this + 60);
  if (v1)
  {
    if (*(unsigned char *)(v1 + 16)) {
      *((void *)this + 61) = v1;
    }
    operator new();
  }
  operator new();
}

void jx_composition::donate_composition_box(jx_composition *this, jp2_input_box *a2, jx_source *a3)
{
  if (*((unsigned char *)this + 214))
  {
    uint64_t v6 = 0;
    memset(v5, 0, sizeof(v5));
    kdu_warning::kdu_warning((kdu_warning *)v5, "Warning in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, "JPX data source appears to contain multiple composition boxes!! This is illegal.  All but first will be ignored.");
    kdu_warning::~kdu_warning((kdu_warning *)v5);
  }
  else
  {
    jp2_input_box::transplant((jx_composition *)((char *)this + 88), a2);
    *((_DWORD *)this + 114) = 0;
    jx_composition::finish(this, a3);
  }
}

void sub_1886E49AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL jx_composition::finish(jx_composition *this, jx_source *a2)
{
  if (!*(unsigned char *)this)
  {
    do
    {
      if (*((unsigned char *)this + 214)) {
        goto LABEL_7;
      }
      if (*((unsigned char *)a2 + 216)) {
        return *((unsigned char *)a2 + 216) != 0;
      }
    }
    while ((jx_source::parse_next_top_level_box(a2, 0) & 1) != 0);
    if (!*((unsigned char *)this + 214)) {
      return *((unsigned char *)a2 + 216) != 0;
    }
LABEL_7:
    if (*((_DWORD *)this + 34) != 1668246896) {
      jx_composition::finish();
    }
    unsigned int v5 = (jx_composition *)((char *)this + 88);
    if (!jp2_input_box::is_complete((jx_composition *)((char *)this + 88))) {
      return 0;
    }
    uint64_t v6 = (jx_composition *)((char *)this + 272);
    while (1)
    {
      while (1)
      {
        if (!*((unsigned char *)this + 398) && !jp2_input_box::open(v6, v5))
        {
          jp2_input_box::close(v5);
          uint64_t v2 = 1;
          *(unsigned char *)this = 1;
          jx_composition::assign_layer_indices((uint64_t)this);
          jx_composition::remove_invisible_instructions((uint64_t)this);
          return v2;
        }
        int v7 = *((_DWORD *)this + 80);
        if (v7 == 1768846196) {
          break;
        }
        if (v7 != 1668247668) {
          goto LABEL_72;
        }
        if (!jp2_input_box::is_complete(v6)) {
          return 0;
        }
        *(void *)int v37 = 0;
        LOBYTE(v33) = 0;
        if (!jp2_input_box::read(v6, &v37[1])
          || !jp2_input_box::read(v6, v37)
          || ((int v8 = (*(uint64_t (**)(jp2_input_box *, unsigned __int16 *, uint64_t))(*(void *)v6 + 32))(v6, &v33, 1), v9 = v37[1], v8 == 1)? (v10 = v37[1] == 0): (v10 = 1), !v10 ? (v11 = v37[0] == 0) : (v11 = 1), v11))
        {
          uint64_t v36 = 0;
          long long v34 = 0u;
          long long v35 = 0u;
          kdu_error::kdu_error((kdu_error *)&v34, "Error in Kakadu File Format Support:\n");
          (*(void (**)(long long *, const char *))(v34 + 16))(&v34, "Malformed Composition Options (copt) box found in JPX data source.  Insufficient or illegal field values encountered.  The height and width parameters must also be non-zero.");
          kdu_error::~kdu_error((kdu_error *)&v34);
        }
        *((_DWORD *)this + 117) = v37[0];
        *((_DWORD *)this + 11jp2_colour_converter::clear(this + 6) = v9;
        if (v33 == 255) {
          int v12 = 0;
        }
        else {
          int v12 = v33 + 1;
        }
        *((_DWORD *)this + 115) = v12;
LABEL_72:
        jp2_input_box::close(v6);
      }
      if (!jp2_input_box::is_complete(v6)) {
        return 0;
      }
      LOWORD(v37[0]) = 0;
      unsigned __int16 v33 = 0;
      v37[1] = 0;
      if (!jp2_input_box::read(v6, (unsigned __int16 *)v37)
        || !jp2_input_box::read(v6, &v33)
        || !jp2_input_box::read(v6, &v37[1]))
      {
        uint64_t v36 = 0;
        long long v34 = 0u;
        long long v35 = 0u;
        kdu_error::kdu_error((kdu_error *)&v34, "Error in Kakadu File Format Support:\n");
        (*(void (**)(long long *, const char *))(v34 + 16))(&v34, "Malformed Instruction Set (inst) box found in JPX data source.  Insufficient fields encountered.");
        kdu_error::~kdu_error((kdu_error *)&v34);
      }
      unsigned int v13 = LOWORD(v37[0]);
      if ((v37[0] & 0x27) != 0) {
        break;
      }
      jp2_input_box::close(v6);
      ++*((_DWORD *)this + 114);
    }
    uint64_t v14 = *((void *)this + 51) - (*((void *)this + 44) + *((int *)this + 112));
    int v15 = v33;
    while (1)
    {
      uint64_t v16 = *((void *)this + 60);
      if (v16) {
        uint64_t v17 = *(void *)(v16 + 32);
      }
      else {
        uint64_t v17 = 0;
      }
      if (jx_composition::parse_instruction(this, v13 & 1, (v13 >> 1) & 1, (v13 >> 2) & 1, (v13 >> 5) & 1))
      {
        int v18 = 0;
        do
        {
          uint64_t v19 = *(void *)(*((void *)this + 60) + 32);
          int v20 = v18 + 1;
          *(_DWORD *)(v19 + 1jp2_colour_converter::clear(this + 6) = *((_DWORD *)this + 114);
          *(_DWORD *)(v19 + 20) = v18;
          BOOL v21 = jx_composition::parse_instruction(this, v13 & 1, (v13 >> 1) & 1, (v13 >> 2) & 1, (v13 >> 5) & 1);
          int v18 = v20;
        }
        while (v21);
      }
      uint64_t v6 = (jx_composition *)((char *)this + 272);
      if (!*((unsigned char *)this + 397) && *((void *)this + 45) - *((void *)this + 51) + *((int *)this + 112) >= 1)
      {
        uint64_t v36 = 0;
        long long v34 = 0u;
        long long v35 = 0u;
        kdu_error::kdu_error((kdu_error *)&v34, "Error in Kakadu File Format Support:\n");
        (*(void (**)(long long *, const char *))(v34 + 16))(&v34, "Malformed Instruction Set (inst) box encountered in JPX data source.  Box appears to be too long.");
        kdu_error::~kdu_error((kdu_error *)&v34);
      }
      jp2_input_box::seek((jx_composition *)((char *)this + 272), v14);
      if (v15 <= 1) {
        goto LABEL_69;
      }
      uint64_t v22 = *((void *)this + 60);
      if (v22 == v16 || !*(_DWORD *)v22) {
        goto LABEL_69;
      }
      if (v16)
      {
        if (v22 != *(void *)(v16 + 48) || *(void *)(v16 + 32) != v17) {
          goto LABEL_69;
        }
      }
      else if (v22 != *((void *)this + 59))
      {
        goto LABEL_69;
      }
      int v23 = *((_DWORD *)this + 125);
      int v24 = *(_DWORD *)(v22 + 12);
      if (v23 < v24)
      {
        unsigned int v25 = 0x7FFFFFFF;
LABEL_57:
        uint64_t v27 = *(void *)(v22 + 24);
        if (v27)
        {
          int v28 = 0;
          int v29 = *(_DWORD *)(v22 + 12);
          do
          {
            int v30 = *(_DWORD *)(v27 + 8);
            if (v30 == v24)
            {
              ++v28;
            }
            else if (v30)
            {
              goto LABEL_69;
            }
            --v29;
            uint64_t v27 = *(void *)(v27 + 56);
          }
          while (v27);
          if (v29) {
LABEL_78:
          }
            jx_composition::finish();
        }
        else if (v24)
        {
          goto LABEL_78;
        }
        if ((v25 & 0x80000000) != 0) {
          jx_composition::finish();
        }
        if (v25 >= 2) {
          jx_composition::add_frame(this);
        }
        goto LABEL_69;
      }
      int v26 = v23 / v24;
      unsigned int v25 = v26 - 1;
      if (v26 != 1) {
        goto LABEL_57;
      }
LABEL_69:
      BOOL v31 = __OFSUB__(v15--, 1);
      if (v15 < 0 != v31)
      {
        ++*((_DWORD *)this + 114);
        unsigned int v5 = (jx_composition *)((char *)this + 88);
        goto LABEL_72;
      }
    }
  }
  return 1;
}

void sub_1886E4FA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886E4FB0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Resume(v13);
}

BOOL jx_source::parse_next_top_level_box(jx_source *this, int a2)
{
  if (*((unsigned char *)this + 216) || *((unsigned char *)this + 17))
  {
    if (a2) {
      jx_source::parse_next_top_level_box();
    }
    return 0;
  }
  if (a2) {
    goto LABEL_11;
  }
  if (*((unsigned char *)this + 158)) {
    jx_source::parse_next_top_level_box();
  }
  if (jp2_input_box::open_next((jx_source *)((char *)this + 32)))
  {
LABEL_11:
    *((unsigned char *)this + 17) = 1;
    int v4 = *((_DWORD *)this + 20);
    if (v4 > 1785737826)
    {
      if (v4 > 1785750375)
      {
        if (v4 == 1785750376)
        {
          unsigned int v9 = (jx_codestream_source *)*((void *)this + 138);
          if (!v9) {
            operator new();
          }
          uint64_t v10 = *((void *)this + 140);
          if (v10)
          {
            unsigned int v9 = *(jx_codestream_source **)(v10 + 856);
            if (!v9) {
              operator new();
            }
          }
          *((void *)this + 140) = v9;
          jx_codestream_source::donate_chdr_box(v9, (jx_source *)((char *)this + 32));
          if (*((unsigned char *)this + 158))
          {
            uint64_t v16 = 0;
            long long v14 = 0u;
            long long v15 = 0u;
            kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu File Format Support:\n");
            (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "top-level JP2 header box is still open, parsing failed.");
            kdu_error::~kdu_error((kdu_error *)&v14);
          }
          goto LABEL_62;
        }
        if (v4 == 1785752680 && !*((unsigned char *)this + 16)) {
          operator new();
        }
        goto LABEL_32;
      }
      if (v4 != 1785737827)
      {
        if (v4 == 1785737832)
        {
          if (*((unsigned char *)this + 408))
          {
            uint64_t v16 = 0;
            long long v14 = 0u;
            long long v15 = 0u;
            kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu File Format Support:\n");
            (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "JP2-family data source contains more than one top-level JP2 header (jp2h) box.");
            kdu_error::~kdu_error((kdu_error *)&v14);
          }
          *((unsigned char *)this + 408) = 1;
          jp2_input_box::transplant((jx_source *)((char *)this + 224), (jx_source *)((char *)this + 32));
          jx_source::finish_jp2_header_box(this);
          goto LABEL_62;
        }
        goto LABEL_32;
      }
    }
    else
    {
      if (v4 <= 1685348971)
      {
        if (v4 == 1634955107) {
          goto LABEL_35;
        }
        if (v4 == 1668246896)
        {
          jx_composition::donate_composition_box((jx_source *)((char *)this + 1336), (jx_source *)((char *)this + 32), this);
          if (*((unsigned char *)this + 158))
          {
            uint64_t v16 = 0;
            long long v14 = 0u;
            long long v15 = 0u;
            kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu File Format Support:\n");
            (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "top-level JP2 header box is still open, parsing failed.");
            kdu_error::~kdu_error((kdu_error *)&v14);
          }
          goto LABEL_62;
        }
LABEL_32:
        unint64_t v7 = *((unsigned int *)this + 569);
        if (v7)
        {
          if ((int)v7 < 1) {
            goto LABEL_55;
          }
          int v8 = (_DWORD *)*((void *)this + 285);
          if (*v8 != v4)
          {
            unint64_t v11 = 0;
            int v12 = v8 + 1;
            do
            {
              if (v7 - 1 == v11) {
                goto LABEL_55;
              }
              int v13 = v12[v11++];
            }
            while (v13 != v4);
            if (v11 >= v7)
            {
LABEL_55:
              jp2_input_box::close((jx_source *)((char *)this + 32));
LABEL_62:
              *((unsigned char *)this + 17) = 0;
              if (!*((unsigned char *)this + 16) || *((_DWORD *)this + 6) || *((int *)this + 5) < 1) {
                return 1;
              }
              if (!*((void *)this + 139)) {
                operator new();
              }
              return 0;
            }
          }
        }
LABEL_35:
        operator new();
      }
      if (v4 == 1685348972)
      {
        if (*((unsigned char *)this + 672))
        {
          uint64_t v16 = 0;
          long long v14 = 0u;
          long long v15 = 0u;
          kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu File Format Support:\n");
          (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "JP2-family data source appears to contain more than one data reference (dtbl) box.  At most one should be found in the file.");
          kdu_error::~kdu_error((kdu_error *)&v14);
        }
        *((unsigned char *)this + 672) = 1;
        jp2_input_box::transplant((jx_source *)((char *)this + 680), (jx_source *)((char *)this + 32));
        if (jp2_input_box::is_complete((jx_source *)((char *)this + 680)))
        {
          j2_data_references::init((jx_source *)((char *)this + 656), (jx_source *)((char *)this + 680));
          if (*((unsigned char *)this + 806)) {
            jx_source::parse_next_top_level_box();
          }
        }
        goto LABEL_62;
      }
      if (v4 != 1718903404) {
        goto LABEL_32;
      }
    }
    unsigned int v5 = (jx_codestream_source *)*((void *)this + 138);
    if (!v5) {
      operator new();
    }
    uint64_t v6 = *((void *)this + 141);
    if (v6)
    {
      unsigned int v5 = *(jx_codestream_source **)(v6 + 856);
      if (!v5) {
        operator new();
      }
    }
    *((void *)this + 141) = v5;
    jx_codestream_source::donate_codestream_box(v5, (jx_source *)((char *)this + 32));
    if (*((unsigned char *)this + 158))
    {
      uint64_t v16 = 0;
      long long v14 = 0u;
      long long v15 = 0u;
      kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "top-level JP2 header box is still open, parsing failed.");
      kdu_error::~kdu_error((kdu_error *)&v14);
    }
    goto LABEL_62;
  }
  BOOL result = jp2_family_src::is_top_level_complete(*(jp2_family_src **)this);
  if (result)
  {
    if ((jp2_input_box::open_next((jx_source *)((char *)this + 32)) & 1) == 0)
    {
      *((unsigned char *)this + 21jp2_colour_converter::clear(this + 6) = 1;
      if (!*((_DWORD *)this + 6) && *((int *)this + 5) >= 1) {
        operator new();
      }
      return 0;
    }
    goto LABEL_11;
  }
  return result;
}

void sub_1886E5818(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B0C40CB50D696);
  _Unwind_Resume(a1);
}

BOOL jx_composition::parse_instruction(jx_composition *this, int a2, int a3, int a4, int a5)
{
  if ((a2 & 1) == 0 && (a3 & 1) == 0 && (a4 & 1) == 0 && !a5) {
    return 0;
  }
  if (!a2)
  {
    if (!a3) {
      goto LABEL_18;
    }
LABEL_14:
    *(void *)uint64_t v17 = 0;
    if (!jp2_input_box::read((jx_composition *)((char *)this + 272), &v17[1]) && !a2) {
      return 0;
    }
    if (!jp2_input_box::read((jx_composition *)((char *)this + 272), v17))
    {
      uint64_t v16 = 0;
      long long v14 = 0u;
      long long v15 = 0u;
      kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "Malformed Instruction Set (inst) box found in JPX data source.  Terminated unexpectedly.");
      kdu_error::~kdu_error((kdu_error *)&v14);
    }
LABEL_18:
    *(void *)uint64_t v17 = 0;
    if (a4)
    {
      if (!jp2_input_box::read((jx_composition *)((char *)this + 272), &v17[1]) && (a2 & 1) == 0 && !a3) {
        return 0;
      }
      if (!jp2_input_box::read((jx_composition *)((char *)this + 272), v17))
      {
        uint64_t v16 = 0;
        long long v14 = 0u;
        long long v15 = 0u;
        kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu File Format Support:\n");
        (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "Malformed Instruction Set (inst) box found in JPX data source.  Terminated unexpectedly.");
        kdu_error::~kdu_error((kdu_error *)&v14);
      }
      if ((v17[1] & 0x80000000) == 0)
      {
        if (!a5) {
          goto LABEL_37;
        }
        goto LABEL_29;
      }
      v17[1] &= ~0x80000000;
    }
    if (!a5) {
      goto LABEL_37;
    }
LABEL_29:
    *(void *)int v12 = 0;
    *(void *)int v13 = 0;
    if (jp2_input_box::read((jx_composition *)((char *)this + 272), &v13[1]) || (a2 & 1) != 0 || (a3 & 1) != 0 || a4)
    {
      if (!jp2_input_box::read((jx_composition *)((char *)this + 272), v13)
        || !jp2_input_box::read((jx_composition *)((char *)this + 272), &v12[1])
        || !jp2_input_box::read((jx_composition *)((char *)this + 272), v12))
      {
        uint64_t v16 = 0;
        long long v14 = 0u;
        long long v15 = 0u;
        kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu File Format Support:\n");
        (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "Malformed Instruction Set (inst) box found in JPX data source.  Terminated unexpectedly.");
        kdu_error::~kdu_error((kdu_error *)&v14);
      }
LABEL_37:
      unint64_t v11 = (jx_frame *)*((void *)this + 60);
      if (v11)
      {
        if (!*(_DWORD *)v11) {
          jx_frame::add_instruction(v11);
        }
      }
      jx_composition::add_frame(this);
    }
    return 0;
  }
  *(void *)uint64_t v17 = 0;
  BOOL result = jp2_input_box::read((jx_composition *)((char *)this + 272), &v17[1]);
  if (result)
  {
    if (!jp2_input_box::read((jx_composition *)((char *)this + 272), v17))
    {
      uint64_t v16 = 0;
      long long v14 = 0u;
      long long v15 = 0u;
      kdu_error::kdu_error((kdu_error *)&v14, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "Malformed Instruction Set (inst) box found in JPX data source.  Terminated unexpectedly.");
      kdu_error::~kdu_error((kdu_error *)&v14);
    }
    if (!a3) {
      goto LABEL_18;
    }
    goto LABEL_14;
  }
  return result;
}

void sub_1886E5C74(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886E5C80(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

void jx_frame::add_instruction(jx_frame *this)
{
}

uint64_t jx_composition::assign_layer_indices(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 472);
  if (v1)
  {
    int v2 = 0;
    do
    {
      for (uint64_t i = *(void *)(v1 + 24); i; uint64_t i = *(void *)(i + 56))
      {
        if ((*(_DWORD *)i & 0x80000000) != 0) {
          *(_DWORD *)uint64_t i = v2++;
        }
        int v4 = *(_DWORD *)(i + 8);
        if (v4 >= 1)
        {
          uint64_t v5 = v1;
          uint64_t v6 = i;
          do
          {
            uint64_t v6 = *(void *)(v6 + 56);
            if (!v6)
            {
              int v7 = *(_DWORD *)(v5 + 4);
              if (v7 >= 1 && v1 != v5)
              {
                v4 -= *(_DWORD *)(v5 + 12) * v7;
                if (v4 <= 0)
                {
                  uint64_t v12 = 0;
                  memset(v11, 0, sizeof(v11));
                  kdu_error::kdu_error((kdu_error *)v11, "Error in Kakadu File Format Support:\n");
                  (*(void (**)(_OWORD *, const char *))(*(void *)&v11[0] + 16))(v11, "Illegal re-use count found in a compositing instruction within the JPX composition box.  The specified re-use counts found in the box lead to multiple conflicting definitions for the compositing layer which should be used by a particular instruction.");
                  kdu_error::~kdu_error((kdu_error *)v11);
                }
              }
              uint64_t v5 = *(void *)(v5 + 48);
              if (!v5) {
                goto LABEL_25;
              }
              uint64_t v6 = *(void *)(v5 + 24);
            }
            BOOL v9 = __OFSUB__(v4--, 1);
          }
          while (!((v4 < 0) ^ v9 | (v4 == 0)));
          if (v6) {
            BOOL v10 = v4 == 0;
          }
          else {
            BOOL v10 = 0;
          }
          if (v10) {
            *(_DWORD *)uint64_t v6 = *(_DWORD *)i;
          }
        }
LABEL_25:
        ;
      }
      uint64_t v1 = *(void *)(v1 + 48);
    }
    while (v1);
  }
  return this;
}

void sub_1886E5E90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886E5E9C()
{
  _Unwind_Resume(v0);
}

uint64_t jx_composition::remove_invisible_instructions(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 472);
  if (v1)
  {
    uint64_t v2 = this;
    int v3 = (void *)(this + 480);
    do
    {
      int v4 = (void *)(v1 + 24);
      this = *(void *)(v1 + 24);
      uint64_t v5 = *(void *)(v1 + 48);
      if (this)
      {
        do
        {
          uint64_t v6 = *(void *)(this + 56);
          if (!*(unsigned char *)(this + 12))
          {
            --*(_DWORD *)(v1 + 12);
            uint64_t v7 = *(void *)(this + 64);
            if (v7)
            {
              int v8 = (uint64_t *)(v7 + 56);
            }
            else
            {
              int v8 = (uint64_t *)(v1 + 24);
              if (*v4 != this) {
                jx_composition::remove_invisible_instructions();
              }
            }
            *int v8 = v6;
            if (v6)
            {
              BOOL v9 = (void *)(v6 + 64);
            }
            else
            {
              BOOL v9 = (void *)(v1 + 32);
              if (*(void *)(v1 + 32) != this) {
                jx_composition::remove_invisible_instructions();
              }
            }
            *BOOL v9 = v7;
            MEMORY[0x18C11C0E0]();
          }
          this = v6;
        }
        while (v6);
        if (*v4) {
          goto LABEL_22;
        }
      }
      if (*(_DWORD *)(v1 + 12)) {
        jx_composition::remove_invisible_instructions();
      }
      uint64_t v10 = *(void *)(v1 + 56);
      if (v10)
      {
        *(void *)(v10 + 48) = v5;
        *(_DWORD *)v10 += *(_DWORD *)v1;
        if (!v5) {
          goto LABEL_20;
        }
      }
      else
      {
        if (*(void *)(v2 + 472) != v1) {
          jx_composition::remove_invisible_instructions();
        }
        *(void *)(v2 + 472) = v5;
        if (!v5)
        {
LABEL_20:
          unint64_t v11 = v3;
          if (*v3 != v1) {
            jx_composition::remove_invisible_instructions();
          }
          goto LABEL_21;
        }
      }
      unint64_t v11 = (void *)(v5 + 56);
LABEL_21:
      void *v11 = v10;
      jx_frame::reset((jx_frame *)v1);
      this = MEMORY[0x18C11C0E0](v1, 0x1020C406ACA6742);
LABEL_22:
      uint64_t v1 = v5;
    }
    while (v5);
  }
  return this;
}

BOOL jpx_source::count_compositing_layers(jpx_source *this, int *a2)
{
  uint64_t v4 = *((void *)this + 1);
  if (v4 && *(unsigned char *)(v4 + 15))
  {
    if (!*(unsigned char *)(v4 + 16))
    {
      while (1)
      {
        uint64_t v4 = *((void *)this + 1);
        if (*(unsigned char *)(v4 + 216)) {
          break;
        }
        if (!jx_source::parse_next_top_level_box((jx_source *)v4, 0))
        {
          uint64_t v4 = *((void *)this + 1);
          break;
        }
      }
    }
    int v6 = *(_DWORD *)(v4 + 24);
    *a2 = v6;
    if (v6 <= 0 && *(unsigned char *)(v4 + 16)) {
      *a2 = 1;
    }
    return *(unsigned char *)(v4 + 216) || *(unsigned char *)(v4 + 16) != 0;
  }
  else
  {
    BOOL result = 0;
    *a2 = 0;
  }
  return result;
}

uint64_t jpx_source::access_layer(jpx_source *this, int a2, int a3)
{
  uint64_t v3 = *((void *)this + 1);
  if (!v3) {
    return 0;
  }
  int v4 = a2;
  uint64_t v5 = 0;
  if ((a2 & 0x80000000) == 0)
  {
    if (*(unsigned char *)(v3 + 15))
    {
      if (a2 && *(unsigned char *)(v3 + 16)) {
        return 0;
      }
      while (1)
      {
        uint64_t v8 = *((void *)this + 1);
        int v9 = *(_DWORD *)(v8 + 24);
        if (v9 > v4 || *(unsigned char *)(v8 + 216)) {
          break;
        }
        if (!jx_source::parse_next_top_level_box((jx_source *)v8, 0))
        {
          uint64_t v8 = *((void *)this + 1);
          int v9 = *(_DWORD *)(v8 + 24);
          break;
        }
      }
      if (v9 <= v4) {
        return 0;
      }
      uint64_t v5 = *(void *)(v8 + 1112);
      if (v4 >= 1)
      {
        do
        {
          uint64_t v5 = *(void *)(v5 + 800);
          --v4;
        }
        while (v4);
      }
      if (!jx_layer_source::finish((jx_layer_source *)v5)
        || a3 && !*(unsigned char *)(v5 + 13) && !jx_layer_source::check_stream_headers((jx_layer_source *)v5))
      {
        return 0;
      }
    }
  }
  return v5;
}

uint64_t jpx_layer_source::access_channels(jpx_layer_source *this)
{
  uint64_t v1 = *(void *)this;
  if (!*(void *)this || !*(unsigned char *)(v1 + 12)) {
    jpx_layer_source::access_channels();
  }
  return v1 + 608;
}

void jx_numlist::~jx_numlist(jx_numlist *this)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    BOOL v3 = v2 == (void)this + 8;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3) {
    MEMORY[0x18C11C0C0]();
  }
  uint64_t v4 = *((void *)this + 5);
  if (v4) {
    BOOL v5 = v4 == (void)this + 32;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5) {
    MEMORY[0x18C11C0C0]();
  }
}

unsigned int *jx_numlist::add_codestream(unsigned int *this, unsigned int a2)
{
  LODWORD(v2) = *this;
  if ((int)*this < 1)
  {
    int v6 = 0;
    if (v2)
    {
LABEL_9:
      int v8 = this[1];
      if ((int)v2 >= v8)
      {
        this[1] = v8 + 8;
        operator new[]();
      }
      uint64_t v7 = (unsigned int *)*((void *)this + 2);
    }
    else
    {
LABEL_6:
      uint64_t v2 = *((void *)this + 2);
      if (v2) {
        jx_numlist::add_codestream();
      }
      this[1] = 1;
      uint64_t v7 = this + 2;
      *((void *)this + 2) = this + 2;
    }
    *this = v2 + 1;
    v7[v6] = a2;
  }
  else
  {
    BOOL v3 = (int *)*((void *)this + 2);
    uint64_t v4 = *this;
    while (1)
    {
      int v5 = *v3++;
      if (v5 == a2) {
        break;
      }
      if (!--v4)
      {
        int v6 = *this;
        if (v2) {
          goto LABEL_9;
        }
        goto LABEL_6;
      }
    }
  }
  return this;
}

uint64_t jx_numlist::add_compositing_layer(uint64_t this, int a2)
{
  LODWORD(v2) = *(_DWORD *)(this + 24);
  if ((int)v2 < 1)
  {
    unsigned int v6 = 0;
    if (v2)
    {
LABEL_9:
      int v8 = *(_DWORD *)(this + 28);
      if ((int)v2 >= v8)
      {
        *(_DWORD *)(this + 28) = v8 + 8;
        operator new[]();
      }
      uint64_t v7 = *(void *)(this + 40);
    }
    else
    {
      uint64_t v2 = *(void *)(this + 40);
      if (v2) {
        jx_numlist::add_compositing_layer();
      }
      *(_DWORD *)(this + 28) = 1;
      uint64_t v7 = this + 32;
      *(void *)(this + 40) = this + 32;
    }
    *(_DWORD *)(this + 24) = v2 + 1;
    *(_DWORD *)(v7 + 4 * vjp2_colour_converter::clear(this + 6) = a2;
  }
  else
  {
    BOOL v3 = *(int **)(this + 40);
    uint64_t v4 = *(unsigned int *)(this + 24);
    while (1)
    {
      int v5 = *v3++;
      if (v5 == a2) {
        break;
      }
      if (!--v4)
      {
        unsigned int v6 = *(_DWORD *)(this + 24);
        goto LABEL_9;
      }
    }
  }
  return this;
}

uint64_t jx_regions::set_num_regions(uint64_t this, int a2)
{
  int v2 = a2 & ~(a2 >> 31);
  int v3 = *(_DWORD *)(this + 4);
  if (v2 <= v3)
  {
    *(_DWORD *)this = v2;
  }
  else
  {
    if (v2 != 1)
    {
      *(_DWORD *)(this + 4) = v3 + v2;
      is_mul_ok(v3 + v2, 0x14uLL);
      operator new[]();
    }
    if (v3) {
      BOOL v4 = 0;
    }
    else {
      BOOL v4 = *(void *)(this + 32) == 0;
    }
    if (!v4) {
      jx_regions::set_num_regions();
    }
    *(void *)this = 0x100000001;
    *(void *)(this + 32) = this + 8;
  }
  return this;
}

void jx_metanode::~jx_metanode(jx_metanode *this)
{
  switch(*((unsigned char *)this + 15))
  {
    case 0:
      uint64_t v2 = *((void *)this + 2);
      if (v2)
      {
        uint64_t v3 = 0x10A0C409059F215;
        goto LABEL_15;
      }
      break;
    case 1:
      int v8 = (jx_numlist *)*((void *)this + 2);
      if (v8)
      {
        jx_numlist::~jx_numlist(v8);
        uint64_t v3 = 0x1010C40B2C1990FLL;
        goto LABEL_15;
      }
      break;
    case 2:
      uint64_t v4 = *((void *)this + 2);
      if (v4)
      {
        uint64_t v5 = *(void *)(v4 + 32);
        if (v5) {
          BOOL v6 = v5 == v4 + 8;
        }
        else {
          BOOL v6 = 1;
        }
        if (!v6) {
          MEMORY[0x18C11C0C0]();
        }
        uint64_t v2 = v4;
        uint64_t v3 = 0x1020C40ED299F00;
LABEL_15:
        MEMORY[0x18C11C0E0](v2, v3);
      }
      break;
    case 3:
      uint64_t v7 = *((void *)this + 2);
      if (v7) {
        MEMORY[0x18C11C0C0](v7, 0x1000C8077774924);
      }
      break;
    default:
      break;
  }
  uint64_t v9 = *((void *)this + 3);
  if (*((unsigned char *)this + 14))
  {
    if (!v9) {
      goto LABEL_22;
    }
    jp2_input_box::~jp2_input_box((jp2_input_box *)(v9 + 184));
    jp2_input_box::~jp2_input_box((jp2_input_box *)v9);
    uint64_t v10 = 0x10A0C40BA7D9750;
  }
  else
  {
    if (!v9) {
      goto LABEL_22;
    }
    jp2_output_box::~jp2_output_box((jp2_output_box *)(v9 + 80));
    jp2_output_box::~jp2_output_box((jp2_output_box *)v9);
    uint64_t v10 = 0x10B0C40C8E48792;
  }
  MEMORY[0x18C11C0E0](v9, v10);
LABEL_22:
  uint64_t v11 = *((void *)this + 7);
  if (v11)
  {
    uint64_t v12 = *((void *)this + 11);
    if (v12)
    {
      *(void *)(v12 + 80) = *((void *)this + 10);
      uint64_t v13 = *((void *)this + 10);
      if (v13)
      {
LABEL_25:
        long long v14 = (void *)(v13 + 88);
LABEL_32:
        *long long v14 = v12;
        *((void *)this + 7) = 0;
        *((void *)this + 10) = 0;
        *((void *)this + 11) = 0;
        goto LABEL_33;
      }
    }
    else
    {
      if (*(jx_metanode **)(v11 + 64) != this)
      {
        long long v15 = "this == parent->head";
        int v16 = 2676;
        goto LABEL_42;
      }
      uint64_t v13 = *((void *)this + 10);
      *(void *)(v11 + 64) = v13;
      if (v13) {
        goto LABEL_25;
      }
    }
    uint64_t v17 = *(jx_metanode **)(v11 + 72);
    long long v14 = (void *)(v11 + 72);
    if (v17 == this) {
      goto LABEL_32;
    }
    long long v15 = "this == parent->tail";
    int v16 = 2683;
LABEL_42:
    __assert_rtn("~jx_metanode", "jpx.cpp", v16, v15);
  }
  if (*((void *)this + 10) || *((void *)this + 11))
  {
    long long v15 = "(next_sibling == NULL) && (prev_sibling == NULL)";
    int v16 = 2691;
    goto LABEL_42;
  }
LABEL_33:
  uint64_t v18 = *((void *)this + 12);
  if (v18) {
    jx_metagroup::unlink(v18, this);
  }
  if (*((void *)this + 13) || *((void *)this + 14) || *((void *)this + 12))
  {
    long long v15 = "(next_link == NULL) && (prev_link == NULL) && (metagroup == NULL)";
    int v16 = 2695;
    goto LABEL_42;
  }
  while (1)
  {
    uint64_t v19 = (jx_metanode *)*((void *)this + 8);
    if (!v19) {
      break;
    }
    jx_metanode::~jx_metanode(v19);
    MEMORY[0x18C11C0E0]();
  }
}

uint64_t jx_metagroup::unlink(uint64_t this, jx_metanode *a2)
{
  if (*((void *)a2 + 12) != this) {
    jx_metagroup::unlink();
  }
  uint64_t v2 = *((void *)a2 + 14);
  if (v2)
  {
    *(void *)(v2 + 104) = *((void *)a2 + 13);
    uint64_t v3 = *((void *)a2 + 13);
    if (v3)
    {
LABEL_4:
      uint64_t v4 = (void *)(v3 + 112);
      goto LABEL_8;
    }
  }
  else
  {
    if (*(jx_metanode **)this != a2) {
      jx_metagroup::unlink();
    }
    uint64_t v3 = *((void *)a2 + 13);
    *(void *)this = v3;
    if (v3) {
      goto LABEL_4;
    }
  }
  uint64_t v4 = (void *)(this + 8);
  if (*(jx_metanode **)(this + 8) != a2) {
    jx_metagroup::unlink();
  }
LABEL_8:
  void *v4 = v2;
  *((void *)a2 + 12) = 0;
  *((void *)a2 + 1++*((_DWORD *)this + 3) = 0;
  *((void *)a2 + 14) = 0;
  if (!*(void *)this)
  {
    uint64_t v5 = *(void *)(this + 16);
    if (v5)
    {
      if (*(_DWORD *)(v5 + 16)) {
        jx_metagroup::unlink();
      }
      unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((this - v5 - 128) >> 3);
      if ((v6 & 0xFFFFFFC0) != 0) {
        jx_metagroup::unlink();
      }
      uint64_t v7 = *(void *)(this + 16);
      return jx_roigroup::delete_child(v7, (v6 >> 3) | ((v6 & 7) << 32));
    }
  }
  return this;
}

void jx_metanode::add_numlist(jx_metanode *this, int a2, const int *a3, int a4, const int *a5)
{
}

jx_metanode **jx_meta_manager::link(jx_metanode **this, jx_metanode *a2)
{
  uint64_t v2 = a2;
  this[42] = a2;
  int v3 = *((unsigned __int8 *)a2 + 15);
  if (v3 == 2)
  {
    uint64_t v6 = 0;
    uint64_t v7 = (_DWORD *)*((void *)a2 + 2);
    int v8 = v7[2];
    int v9 = v7[3];
    int v11 = v7[4];
    int v10 = v7[5];
    if (v10 <= v11) {
      int v10 = v11;
    }
    do
    {
      uint64_t v12 = v6 + 1;
      if (v6 > 0x1E) {
        break;
      }
      int v13 = 8 << v6++;
    }
    while (v10 > v13);
    long long v14 = (int *)this[v12 + 9];
    if (!v14) {
      operator new();
    }
    if (v9 >= v14[9] || v8 >= v14[8]) {
      operator new();
    }
    int v16 = v9 - v14[7];
    if (v16 < 0 || (int v17 = v8 - v14[6], v17 < 0))
    {
LABEL_28:
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = -50;
      __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
    }
    while (1)
    {
      int v18 = v16 / v14[11];
      if (v18 > 7 || (int v19 = v17 / v14[10], v19 >= 8)) {
        jx_meta_manager::link();
      }
      int v20 = v14 + 32;
      uint64_t v21 = 8 * v19;
      if (v14[4] < 1) {
        break;
      }
      uint64_t v22 = *(int **)&v20[2 * v21 + 2 * v18];
      if (!v22) {
        operator new();
      }
      int v16 = v9 - v22[7];
      if ((v16 & 0x80000000) == 0)
      {
        int v17 = v8 - v22[6];
        long long v14 = v22;
        if ((v17 & 0x80000000) == 0) {
          continue;
        }
      }
      goto LABEL_28;
    }
    uint64_t v4 = (jx_metanode **)&v20[6 * (int)v21 + 6 * v18];
    v4[2] = (jx_metanode *)v14;
    uint64_t v2 = a2;
    *((void *)a2 + 12) = v4;
    uint64_t v5 = v4 + 1;
  }
  else if (v3 == 1)
  {
    uint64_t v4 = this + 7;
    *((void *)a2 + 12) = this + 7;
    uint64_t v5 = this + 8;
  }
  else
  {
    if (*((_DWORD *)a2 + 2) == 1718773093) {
      return this;
    }
    long long v15 = a2;
    while (1)
    {
      long long v15 = (jx_metanode *)*((void *)v15 + 7);
      if (!v15) {
        break;
      }
      if (*((unsigned __int8 *)v15 + 15) - 1 < 2) {
        return this;
      }
    }
    uint64_t v4 = this + 4;
    *((void *)a2 + 12) = this + 4;
    uint64_t v5 = this + 5;
  }
  int v24 = *v5;
  *((void *)v2 + 1++*((_DWORD *)this + 3) = 0;
  *((void *)v2 + 14) = v24;
  if (v24) {
    uint64_t v4 = (jx_metanode **)((char *)v24 + 104);
  }
  void *v4 = v2;
  *uint64_t v5 = v2;
  return this;
}

void sub_1886E6DFC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B0C40E01A6C06);
  _Unwind_Resume(a1);
}

uint64_t jx_metanode::update_completed_descendants(jx_metanode *this)
{
  if (!*((unsigned char *)this + 13) || !*((unsigned char *)this + 12)) {
    return 0xFFFFFFFFLL;
  }
  for (uint64_t i = *((void *)this + 7); i; this = (jx_metanode *)v2)
  {
    uint64_t v2 = i;
    if (!*((unsigned char *)this + 13) || *((_DWORD *)this + 13) != *((_DWORD *)this + 12)) {
      break;
    }
    int v3 = *(_DWORD *)(i + 52);
    if (v3 >= *(_DWORD *)(v2 + 48)) {
      return 0xFFFFFFFFLL;
    }
    *(_DWORD *)(v2 + 52) = v3 + 1;
    uint64_t i = *(void *)(v2 + 56);
  }
  return 0;
}

void jx_metanode::donate_input_box(jx_metanode *this, jp2_input_box *a2)
{
  if (!*((void *)this + 3) && !*((unsigned char *)this + 12) && !*((unsigned char *)this + 13))
  {
    *((unsigned char *)this + 14) = 1;
    operator new();
  }
  jx_metanode::donate_input_box();
}

void sub_1886E6F48(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A0C40BA7D9750);
  _Unwind_Resume(a1);
}

BOOL jx_metanode::finish_reading(jx_metanode *this)
{
  if (!*((unsigned char *)this + 14)) {
    return 1;
  }
  uint64_t v2 = *((void *)this + 3);
  if (!v2)
  {
    if (!*((unsigned char *)this + 12) || !*((unsigned char *)this + 13)) {
      jx_metanode::finish_reading();
    }
    return 1;
  }
  if (*((unsigned char *)this + 12))
  {
    while (!*((unsigned char *)this + 13))
    {
      uint64_t v7 = *((void *)this + 3);
      int v8 = *(jx_codestream_source **)(v7 + 368);
      if (v8)
      {
        if (!jx_codestream_source::finish(v8, 0)) {
          return 0;
        }
      }
      else
      {
        int v9 = *(jx_layer_source **)(v7 + 376);
        if (v9)
        {
          if (!jx_layer_source::finish(v9)) {
            return 0;
          }
        }
        else
        {
          if (!*(unsigned char *)(v7 + 126))
          {
            memset(v18, 0, 40);
            kdu_error::kdu_error((kdu_error *)v18, "Error in Kakadu File Format Support:\n");
            (*(void (**)(void *, const char *))(v18[0] + 16))(v18, "ASOC box not found");
            kdu_error::~kdu_error((kdu_error *)v18);
          }
          if (*(unsigned char *)(v7 + 310)) {
            jx_metanode::finish_reading();
          }
          if (jp2_input_box::open((jp2_input_box *)(v7 + 184), (jp2_input_box *)v7))
          {
            uint64_t v10 = *((void *)this + 3);
            int v11 = *(_DWORD *)(v10 + 232);
            if (v11 == 1634955107) {
              goto LABEL_37;
            }
            unint64_t v12 = *(unsigned int *)(*(void *)this + 436);
            if (!v12) {
              goto LABEL_37;
            }
            if ((int)v12 >= 1)
            {
              int v13 = *(_DWORD **)(*(void *)this + 440);
              if (*v13 == v11) {
                goto LABEL_37;
              }
              uint64_t v14 = 1;
              do
              {
                unint64_t v15 = v14;
                if (v12 == v14) {
                  break;
                }
                int v16 = v13[v14++];
              }
              while (v16 != v11);
              if (v15 < v12) {
LABEL_37:
              }
                operator new();
            }
            jp2_input_box::close((jp2_input_box *)(v10 + 184));
          }
          else
          {
            BOOL result = jp2_input_box::is_complete(*((jp2_input_box **)this + 3));
            if (!result) {
              return result;
            }
            *((unsigned char *)this + 1++*((_DWORD *)this + 3) = 1;
            jx_metanode::update_completed_descendants(this);
          }
        }
      }
    }
    uint64_t v3 = *((void *)this + 3);
    if (v3)
    {
      jp2_input_box::~jp2_input_box((jp2_input_box *)(v3 + 184));
      jp2_input_box::~jp2_input_box((jp2_input_box *)v3);
      MEMORY[0x18C11C0E0]();
    }
    *((void *)this + ++*((_DWORD *)this + 3) = 0;
    return 1;
  }
  if (!*(unsigned char *)(v2 + 310))
  {
    if (!*(unsigned char *)(v2 + 126)) {
      jx_metanode::finish_reading();
    }
    jp2_input_box::open((jp2_input_box *)(v2 + 184), (jp2_input_box *)v2);
    uint64_t v2 = *((void *)this + 3);
    if (!*(unsigned char *)(v2 + 310)) {
      return 0;
    }
    *((_DWORD *)this + 2) = *(_DWORD *)(v2 + 232);
  }
  BOOL result = jp2_input_box::is_complete((jp2_input_box *)(v2 + 184));
  *((unsigned char *)this + 12) = result;
  if (result)
  {
    uint64_t v5 = *((void *)this + 3);
    if (*(unsigned char *)(v5 + 309)) {
      LODWORD(vjp2_colour_converter::clear(this + 6) = -1;
    }
    else {
      uint64_t v6 = *(void *)(v5 + 272) - *(void *)(v5 + 320) + *(unsigned int *)(v5 + 360);
    }
    int v17 = *((_DWORD *)this + 2);
    if (v17 == 1852601204)
    {
      *((unsigned char *)this + 15) = 1;
      operator new();
    }
    if (v17 == 1919904100 && (int)v6 >= 2)
    {
      *((unsigned char *)this + 15) = 2;
      operator new();
    }
    if (v17 == 1818389536 && (int)v6 >= 1 && (int)v6 < 0x2000)
    {
      *((unsigned char *)this + 15) = 3;
      operator new[]();
    }
    *((unsigned char *)this + 15) = 0;
    if (v17 == 1970628964)
    {
      *((void *)this + 5) = 0;
      *((void *)this + 4) = 0;
      jp2_input_box::read((jp2_input_box *)(v5 + 184), (unsigned __int8 *)this + 32, 16);
    }
    operator new();
  }
  return result;
}

void sub_1886E7814(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886E7820(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Resume(v13);
}

BOOL jx_codestream_source::finish(jx_codestream_source *this, int a2)
{
  if (*((unsigned char *)this + 20))
  {
    if (!a2) {
      return 1;
    }
    uint64_t v4 = *((void *)this + 69);
    if (v4 < 0)
    {
      if (*((void *)this + 68)) {
        return 1;
      }
    }
    else if (v4 || *((_DWORD *)this + 140))
    {
      return 1;
    }
  }
  do
  {
    uint64_t v5 = *((void *)this + 65);
    if (v5 < 0)
    {
      if (!*((void *)this + 64)) {
        continue;
      }
    }
    else if (!v5 && !*((_DWORD *)this + 132))
    {
      continue;
    }
    if (!a2) {
      break;
    }
    uint64_t v6 = *((void *)this + 69);
    if (v6 < 0)
    {
      if (*((void *)this + 68)) {
        break;
      }
      continue;
    }
    if (v6 || *((_DWORD *)this + 140)) {
      break;
    }
  }
  while (!*((unsigned char *)this + 23)
       && !*(unsigned char *)(*(void *)this + 216)
       && (jx_source::parse_next_top_level_box(*(jx_source **)this, 0) & 1) != 0);
  if (!*((unsigned char *)this + 150)) {
    goto LABEL_59;
  }
  BOOL is_complete = jp2_input_box::is_complete((jx_codestream_source *)((char *)this + 24));
  int v19 = (int *)((char *)this + 16);
  while (*((unsigned char *)this + 334)
       || jp2_input_box::open((jx_codestream_source *)((char *)this + 208), (jx_codestream_source *)((char *)this + 24)))
  {
    BOOL result = jp2_input_box::is_complete((jx_codestream_source *)((char *)this + 208));
    int v8 = *((_DWORD *)this + 64);
    if (v8 > 1768449137)
    {
      if (v8 == 1885564018)
      {
        if (result) {
          j2_palette::init((jx_codestream_source *)((char *)this + 440), (jx_codestream_source *)((char *)this + 208));
        }
        return result;
      }
      if (v8 == 1768449138)
      {
        if (result) {
          j2_dimensions::init((jx_codestream_source *)((char *)this + 392), (jx_codestream_source *)((char *)this + 208));
        }
        return result;
      }
      goto LABEL_36;
    }
    if (v8 != 1651532643)
    {
      if (v8 == 1668112752)
      {
        if (result) {
          j2_component_map::init((jx_codestream_source *)((char *)this + 472), (jx_codestream_source *)((char *)this + 208));
        }
        return result;
      }
LABEL_36:
      if (jx_source::test_box_filter(*(jx_source **)this, v8))
      {
        if (!*((void *)this + 67)) {
          jx_metanode::add_numlist(*(jx_metanode **)(*(void *)this + 1864), 1, v19, 0, 0);
        }
        operator new();
      }
      jp2_input_box::close((jx_codestream_source *)((char *)this + 208));
      continue;
    }
    if (!result) {
      return result;
    }
    j2_dimensions::process_bpcc_box((jx_codestream_source *)((char *)this + 392), (jx_codestream_source *)((char *)this + 208));
    *((unsigned char *)this + 432) = 1;
  }
  if (is_complete)
  {
    jp2_input_box::close((jx_codestream_source *)((char *)this + 24));
    int v9 = (jx_metanode *)*((void *)this + 67);
    if (v9)
    {
      *((unsigned char *)v9 + 1++*((_DWORD *)this + 3) = 1;
      jx_metanode::update_completed_descendants(v9);
      uint64_t v10 = *((void *)this + 67);
      uint64_t v11 = *(void *)(v10 + 24);
      if (v11)
      {
        jp2_input_box::~jp2_input_box((jp2_input_box *)(v11 + 184));
        jp2_input_box::~jp2_input_box((jp2_input_box *)v11);
        MEMORY[0x18C11C0E0]();
        uint64_t v10 = *((void *)this + 67);
      }
      *(void *)(v10 + 24) = 0;
    }
    goto LABEL_58;
  }
  if ((*((_DWORD *)this + 100) & 0x80000000) == 0
    && *((unsigned char *)this + 432)
    && *((unsigned char *)this + 440)
    && *((int *)this + 125) >= 1)
  {
    uint64_t v12 = *((void *)this + 67);
    if (!v12) {
      jx_metanode::add_numlist(*(jx_metanode **)(*(void *)this + 1864), 1, v19, 0, 0);
    }
    *(void *)(*(void *)(v12 + 24) + 368) = 0;
    jp2_input_box::transplant(*(jp2_input_box **)(v12 + 24), (jx_codestream_source *)((char *)this + 24));
    if (*((unsigned char *)this + 150)) {
      jx_codestream_source::finish();
    }
  }
  else
  {
LABEL_58:
    if (*((unsigned char *)this + 150)) {
      return 0;
    }
  }
LABEL_59:
  if (!*((unsigned char *)this + 23))
  {
    uint64_t v13 = *((void *)this + 65);
    if (v13 < 0)
    {
      if (*((void *)this + 64)) {
        goto LABEL_60;
      }
    }
    else if (v13 || *((_DWORD *)this + 132))
    {
      goto LABEL_60;
    }
    if (*(unsigned char *)(*(void *)this + 216)) {
      goto LABEL_60;
    }
    return 0;
  }
LABEL_60:
  if (*((unsigned char *)this + 20))
  {
    if (!a2) {
      return 1;
    }
LABEL_86:
    uint64_t v17 = *((void *)this + 69);
    if ((v17 & 0x8000000000000000) == 0) {
      return v17 || *((_DWORD *)this + 140);
    }
    return *((void *)this + 68) != 0;
  }
  if ((*((_DWORD *)this + 100) & 0x80000000) != 0)
  {
    uint64_t v14 = *(void *)this;
    if (*(unsigned char *)(*(void *)this + 600)
      || (BOOL result = jx_source::finish_jp2_header_box(*(jx_source **)this), result))
    {
      if ((*(_DWORD *)(v14 + 616) & 0x80000000) != 0)
      {
        uint64_t v21 = 0;
        memset(v20, 0, sizeof(v20));
        kdu_error::kdu_error((kdu_error *)v20, "Error in Kakadu File Format Support:\n");
        (*(void (**)(_OWORD *, const char *))(*(void *)&v20[0] + 16))(v20, "JPX source contains no image header box for a codestream.  The image header (ihdr) box cannot be found in a codestream header (chdr) box, and does not exist within a default JP2 header (jp2h) box.");
        kdu_error::~kdu_error((kdu_error *)v20);
      }
      j2_dimensions::copy((jx_codestream_source *)((char *)this + 392), (j2_dimensions *)(v14 + 608));
    }
  }
  else
  {
    if (!*((unsigned char *)this + 440))
    {
      uint64_t v15 = *(void *)this;
      if (!*(unsigned char *)(*(void *)this + 600))
      {
        BOOL result = jx_source::finish_jp2_header_box(*(jx_source **)this);
        if (!result) {
          return result;
        }
      }
      if (*(unsigned char *)(v15 + 864)) {
        j2_palette::copy((jx_codestream_source *)((char *)this + 440), (j2_palette *)(v15 + 864));
      }
      if (!*((unsigned char *)this + 440)) {
        goto LABEL_85;
      }
    }
    if (*((int *)this + 125) > 0)
    {
LABEL_85:
      j2_dimensions::finalize((uint64_t)this + 392);
      j2_palette::finalize((uint64_t)this + 440);
      j2_component_map::finalize((uint64_t)this + 472, (jx_codestream_source *)((char *)this + 392), (jx_codestream_source *)((char *)this + 440));
      *((unsigned char *)this + 20) = 1;
      if (!a2) {
        return 1;
      }
      goto LABEL_86;
    }
    uint64_t v16 = *(void *)this;
    if (*(unsigned char *)(*(void *)this + 600)
      || (BOOL result = jx_source::finish_jp2_header_box(*(jx_source **)this), result))
    {
      if (*(int *)(v16 + 924) <= 0) {
        j2_component_map::init_missing_cmap(v16 + 896, (uint64_t)this + 392);
      }
      j2_component_map::copy((uint64_t)this + 472, v16 + 896);
    }
  }
  return result;
}

void sub_1886E7E0C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A0C40BA7D9750);
  _Unwind_Resume(a1);
}

BOOL jx_layer_source::finish(jx_layer_source *this)
{
  if (*((unsigned char *)this + 12)) {
    return 1;
  }
  do
  {
    uint64_t v3 = *((void *)this + 72);
    if (v3 < 0)
    {
      if (*((void *)this + 71)) {
        break;
      }
      goto LABEL_8;
    }
    if (v3 || *((_DWORD *)this + 146)) {
      break;
    }
LABEL_8:
    uint64_t v4 = *(jx_source **)this;
  }
  while (!*(unsigned char *)(*(void *)this + 216)
       && !*((unsigned char *)v4 + 16)
       && (jx_source::parse_next_top_level_box(v4, 0) & 1) != 0);
  if (!*((unsigned char *)this + 142)) {
    goto LABEL_57;
  }
  BOOL is_complete = jp2_input_box::is_complete((jx_layer_source *)((char *)this + 16));
  if (*((unsigned char *)this + 326)) {
    uint64_t v5 = (jx_layer_source *)((char *)this + 200);
  }
  else {
    uint64_t v5 = (jx_layer_source *)((char *)this + 16);
  }
  unint64_t v47 = (jx_layer_source *)((char *)this + 592);
  uint64_t v45 = (int *)((char *)this + 8);
  while (1)
  {
    if (!*((unsigned char *)this + 510) && (jp2_input_box::open((jx_layer_source *)((char *)this + 384), v5) & 1) == 0)
    {
      if (v5 != (jx_layer_source *)((char *)this + 200)) {
        break;
      }
      if (!jp2_input_box::is_complete((jx_layer_source *)((char *)this + 200))) {
        break;
      }
      if (!jp2_input_box::close((jx_layer_source *)((char *)this + 200))) {
        break;
      }
      uint64_t v5 = (jx_layer_source *)((char *)this + 16);
      if (!jp2_input_box::open((jx_layer_source *)((char *)this + 384), (jx_layer_source *)((char *)this + 16)))break; {
    }
      }
    if (*((_DWORD *)this + 108) == 1667723888)
    {
      if (!*((unsigned char *)this + 326))
      {
        jp2_input_box::transplant((jx_layer_source *)((char *)this + 200), (jx_layer_source *)((char *)this + 384));
        uint64_t v5 = (jx_layer_source *)((char *)this + 200);
        continue;
      }
      goto LABEL_24;
    }
    BOOL result = jp2_input_box::is_complete((jx_layer_source *)((char *)this + 384));
    int v6 = *((_DWORD *)this + 108);
    if (v6 <= 1668441446)
    {
      if (v6 == 1667523942) {
        goto LABEL_38;
      }
      if (v6 != 1668246642)
      {
LABEL_33:
        if (jx_source::test_box_filter(*(jx_source **)this, v6))
        {
          if (!*((void *)this + 99)) {
            jx_metanode::add_numlist(*(jx_metanode **)(*(void *)this + 1864), 0, 0, 1, v45);
          }
          operator new();
        }
LABEL_24:
        jp2_input_box::close((jx_layer_source *)((char *)this + 384));
        continue;
      }
      if (!result) {
        return result;
      }
      uint64_t v7 = (jx_layer_source *)((char *)this + 648);
      if (!*((unsigned char *)this + 326))
      {
        uint64_t v51 = 0;
        long long v49 = 0u;
        long long v50 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)&v49, "Warning in Kakadu File Format Support:\n");
        (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Colour description (colr) box found inside a compositing layer header (jplh) box, but not wrapped by a colour group (cgrp) box.  This is technically a violation of the JPX standard, but we will parse the box anyway.");
        kdu_warning::~kdu_warning((kdu_warning *)&v49);
        uint64_t v7 = (jx_layer_source *)((char *)this + 648);
      }
      do
      {
        int v8 = v7;
        uint64_t v7 = (j2_colour *)*((void *)v7 + 13);
      }
      while (v7);
      if (*(unsigned char *)v8) {
        operator new();
      }
      j2_colour::init(v8, (jx_layer_source *)((char *)this + 384));
    }
    else
    {
      if (v6 == 1668441447)
      {
        if (result) {
          jx_registration::init((jx_layer_source *)((char *)this + 760), (jx_layer_source *)((char *)this + 384));
        }
        return result;
      }
      if (v6 == 1869636468)
      {
LABEL_38:
        if (!result) {
          return result;
        }
        j2_channels::init((jx_layer_source *)((char *)this + 608), (jx_layer_source *)((char *)this + 384));
        continue;
      }
      if (v6 != 1919251232) {
        goto LABEL_33;
      }
      if (!result) {
        return result;
      }
      j2_resolution::init(v47, (jx_layer_source *)((char *)this + 384));
    }
  }
  if (is_complete)
  {
    jp2_input_box::close((jx_layer_source *)((char *)this + 16));
    int v9 = (jx_metanode *)*((void *)this + 99);
    if (v9)
    {
      *((unsigned char *)v9 + 1++*((_DWORD *)this + 3) = 1;
      jx_metanode::update_completed_descendants(v9);
      uint64_t v10 = *((void *)this + 99);
      uint64_t v11 = *(void *)(v10 + 24);
      if (v11)
      {
        jp2_input_box::~jp2_input_box((jp2_input_box *)(v11 + 184));
        jp2_input_box::~jp2_input_box((jp2_input_box *)v11);
        MEMORY[0x18C11C0E0](v12);
        uint64_t v10 = *((void *)this + 99);
      }
      *(void *)(v10 + 24) = 0;
    }
LABEL_56:
    if (!*((unsigned char *)this + 142)) {
      goto LABEL_57;
    }
    return 0;
  }
  if (!*((unsigned char *)this + 648)
    || *((unsigned char *)this + 326)
    || !*((_DWORD *)this + 153)
    || *(float *)v47 <= 0.0
    || *((int *)this + 191) < 1)
  {
    goto LABEL_56;
  }
  uint64_t v44 = *((void *)this + 99);
  if (!v44) {
    jx_metanode::add_numlist(*(jx_metanode **)(*(void *)this + 1864), 0, 0, 1, v45);
  }
  *(void *)(*(void *)(v44 + 24) + 37jp2_colour_converter::clear(this + 6) = 0;
  jp2_input_box::transplant(*(jp2_input_box **)(v44 + 24), (jx_layer_source *)((char *)this + 16));
  if (*((unsigned char *)this + 142)) {
    jx_layer_source::finish();
  }
LABEL_57:
  uint64_t v13 = *((void *)this + 72);
  if (v13 < 0)
  {
    if (!*((void *)this + 71))
    {
LABEL_62:
      if (!*(unsigned char *)(*(void *)this + 216) && !*(unsigned char *)(*(void *)this + 16)) {
        return 0;
      }
    }
  }
  else if (!v13 && !*((_DWORD *)this + 146))
  {
    goto LABEL_62;
  }
  jx_registration::finalize((void *)this + 95);
  LODWORD(v14) = *((_DWORD *)this + 191);
  if ((int)v14 >= 1)
  {
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    while (1)
    {
      codestreauint64_t m = (jx_codestream_source *)jx_source::get_codestream(*(jx_source **)this, *(_DWORD *)(*((void *)this + 96) + v15));
      if (!codestream) {
        break;
      }
      if (!jx_codestream_source::finish(codestream, 1)) {
        return 0;
      }
      ++v16;
      uint64_t v14 = *((int *)this + 191);
      v15 += 20;
      if (v16 >= v14) {
        goto LABEL_69;
      }
    }
    if (*(unsigned char *)(*(void *)this + 216))
    {
      uint64_t v51 = 0;
      long long v49 = 0u;
      long long v50 = 0u;
      kdu_error::kdu_error((kdu_error *)&v49, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Encountered a JPX compositing layer box which utilizes a non-existent codestream!");
      kdu_error::~kdu_error((kdu_error *)&v49);
    }
    return 0;
  }
LABEL_69:
  if (*((_DWORD *)this + 197) && *((_DWORD *)this + 196)) {
    goto LABEL_97;
  }
  *((void *)this + 98) = 0;
  if ((int)v14 <= 0)
  {
    int v24 = 0;
    int v25 = 0;
    int v26 = *((_DWORD *)this + 195);
    if (v26 <= 1) {
      int v26 = 1;
    }
    goto LABEL_90;
  }
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = *((void *)this + 96);
  while (2)
  {
    *(void *)&long long v49 = jx_source::get_codestream(*(jx_source **)this, *(_DWORD *)(v20 + v18));
    int v48 = jpx_codestream_source::access_dimensions((jx_codestream_source **)&v49, 0);
    uint64_t size = jp2_dimensions::get_size((jp2_dimensions *)&v48);
    uint64_t v20 = *((void *)this + 96);
    int v22 = *(_DWORD *)(v20 + v18 + 8) + *(_DWORD *)(v20 + v18 + 16) * HIDWORD(size);
    int v23 = *(_DWORD *)(v20 + v18 + 4) + *(_DWORD *)(v20 + v18 + 12) * size;
    if (!v18)
    {
      *((_DWORD *)this + 197) = v22;
      int v24 = v22;
LABEL_79:
      *((_DWORD *)this + 19jp2_colour_converter::clear(this + 6) = v23;
      int v25 = v23;
      goto LABEL_80;
    }
    int v24 = *((_DWORD *)this + 197);
    if (v22 < v24)
    {
      *((_DWORD *)this + 197) = v22;
      int v24 = v22;
    }
    int v25 = *((_DWORD *)this + 196);
    if (v23 < v25) {
      goto LABEL_79;
    }
LABEL_80:
    ++v19;
    v18 += 20;
    if (v19 < *((int *)this + 191)) {
      continue;
    }
    break;
  }
  int v26 = *((_DWORD *)this + 195);
  if (v26 <= 1) {
    int v26 = 1;
  }
  if (v24 > 0)
  {
    unsigned int v27 = (v24 - 1) / v26 + 1;
    goto LABEL_91;
  }
LABEL_90:
  unsigned int v27 = -(int)(-v24 / v26);
LABEL_91:
  *((_DWORD *)this + 197) = v27;
  int v28 = *((_DWORD *)this + 194);
  if (v28 <= 1) {
    int v28 = 1;
  }
  if (v25 <= 0) {
    unsigned int v29 = -(int)(-v25 / v28);
  }
  else {
    unsigned int v29 = (v25 - 1) / v28 + 1;
  }
  *((_DWORD *)this + 19jp2_colour_converter::clear(this + 6) = v29;
LABEL_97:
  int v30 = (jx_layer_source *)((char *)this + 648);
  if (*((unsigned char *)this + 648))
  {
LABEL_98:
    if (*((_DWORD *)this + 153)) {
      goto LABEL_103;
    }
    uint64_t v31 = *(void *)this;
    if (*(unsigned char *)(*(void *)this + 600) || (BOOL result = jx_source::finish_jp2_header_box(*(jx_source **)this)))
    {
      if (*(_DWORD *)(v31 + 940)) {
        j2_channels::copy((jx_layer_source *)((char *)this + 608), (j2_channels *)(v31 + 936));
      }
LABEL_103:
      if (*((float *)this + 148) > 0.0)
      {
LABEL_108:
        long long v34 = (char *)this + 648;
        do
        {
          unsigned int v35 = *((_DWORD *)v34 + 2);
          long long v34 = (char *)*((void *)v34 + 13);
          if (v34) {
            BOOL v36 = v35 == 0;
          }
          else {
            BOOL v36 = 0;
          }
        }
        while (v36);
        j2_channels::finalize((unsigned int *)this + 152, v35, 0);
        if (*((int *)this + 191) >= 1)
        {
          uint64_t v37 = 0;
          uint64_t v38 = 0;
          do
          {
            int v39 = *(_DWORD *)(*((void *)this + 96) + v37);
            uint64_t v40 = jx_source::get_codestream(*(jx_source **)this, v39);
            if (!v40) {
              jx_layer_source::finish();
            }
            j2_channels::find_cmap_channels((unsigned int *)this + 152, (j2_component_map *)(v40 + 472), v39);
            ++v38;
            v37 += 20;
          }
          while (v38 < *((int *)this + 191));
        }
        if (!j2_channels::all_cmap_channels_found((jx_layer_source *)((char *)this + 608)))
        {
          uint64_t v51 = 0;
          long long v49 = 0u;
          long long v50 = 0u;
          kdu_error::kdu_error((kdu_error *)&v49, "Error in Kakadu File Format Support:\n");
          (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "JP2/JPX source is internally inconsistent.  Either an explicit channel mapping box, or the set of channels implicitly identified by a colour space box, cannot all be associated with available code-stream image components.");
          kdu_error::~kdu_error((kdu_error *)&v49);
        }
        do
        {
          j2_colour::finalize(v30, (jx_layer_source *)((char *)this + 608));
          int v30 = (j2_colour *)*((void *)v30 + 13);
        }
        while (v30);
        BOOL result = 1;
        *((unsigned char *)this + 12) = 1;
      }
      else
      {
        uint64_t v32 = *(void *)this;
        if (*(unsigned char *)(*(void *)this + 600) || (BOOL result = jx_source::finish_jp2_header_box(*(jx_source **)this)))
        {
          float v33 = *(float *)(v32 + 1088);
          if (v33 > 0.0)
          {
            *((float *)this + 148) = v33;
            *((_DWORD *)this + 149) = *(_DWORD *)(v32 + 1092);
            *((void *)this + 75) = *(void *)(v32 + 1096);
          }
          goto LABEL_108;
        }
      }
    }
  }
  else
  {
    uint64_t v41 = *(void *)this;
    if (*(unsigned char *)(*(void *)this + 600) || (BOOL result = jx_source::finish_jp2_header_box(*(jx_source **)this)))
    {
      uint64_t v42 = (j2_colour *)(v41 + 976);
      uint64_t v43 = (jx_layer_source *)((char *)this + 648);
      do
      {
        if (!*(unsigned char *)v42) {
          break;
        }
        if (*(unsigned char *)v43) {
          operator new();
        }
        j2_colour::copy(v43, v42);
        uint64_t v42 = (j2_colour *)*((void *)v42 + 13);
      }
      while (v42);
      goto LABEL_98;
    }
  }
  return result;
}

void sub_1886E8764(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A0C40BA7D9750);
  _Unwind_Resume(a1);
}

uint64_t jx_metanode::load_recursive(uint64_t this)
{
  uint64_t v1 = this;
  if (*(unsigned char *)(this + 14) && *(void *)(this + 24) && (!*(unsigned char *)(this + 12) || !*(unsigned char *)(this + 13))) {
    this = jx_metanode::finish_reading((jx_metanode *)this);
  }
  for (uint64_t i = *(jx_metanode **)(v1 + 64); i; uint64_t i = (jx_metanode *)*((void *)i + 10))
  {
    if (*(_DWORD *)(v1 + 52) == *(_DWORD *)(v1 + 48)) {
      break;
    }
    this = jx_metanode::load_recursive(i);
  }
  return this;
}

uint64_t jpx_metanode::get_num_regions(jpx_metanode *this)
{
  uint64_t v1 = *(void *)this;
  if (!*(void *)this || *(unsigned char *)(v1 + 15) != 2) {
    return 0;
  }
  if (!*(unsigned char *)(v1 + 12)) {
    jpx_metanode::get_num_regions();
  }
  return **(unsigned int **)(v1 + 16);
}

uint64_t jpx_metanode::get_regions(jpx_metanode *this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this && *(unsigned char *)(v1 + 15) == 2) {
    return *(void *)(*(void *)(v1 + 16) + 32);
  }
  else {
    return 0;
  }
}

uint64_t jpx_metanode::get_bounding_box(jpx_metanode *this)
{
  uint64_t v1 = *(void *)this;
  if (*(void *)this && *(unsigned char *)(v1 + 15) == 2 && (uint64_t v2 = *(void *)(v1 + 16), *(int *)v2 >= 1)) {
    return *(void *)(v2 + 8);
  }
  else {
    return 0;
  }
}

uint64_t jx_source::get_codestream(jx_source *this, int a2)
{
  while (*((_DWORD *)this + 5) <= a2 && (jx_source::parse_next_top_level_box(this, 0) & 1) != 0)
    ;
  uint64_t result = *((void *)this + 138);
  if (a2 >= 1 && result)
  {
    do
    {
      uint64_t result = *(void *)(result + 856);
      if (a2 < 2) {
        break;
      }
      --a2;
    }
    while (result);
  }
  return result;
}

uint64_t jx_source::get_compositing_layer(jx_source *this, int a2)
{
  while (*((_DWORD *)this + 6) <= a2 && jx_source::parse_next_top_level_box(this, 0))
    ;
  uint64_t result = *((void *)this + 139);
  if (a2 >= 1 && result)
  {
    do
    {
      uint64_t result = *(void *)(result + 800);
      if (a2 < 2) {
        break;
      }
      --a2;
    }
    while (result);
  }
  return result;
}

uint64_t jx_roigroup::delete_child(uint64_t result, unint64_t a2)
{
  if ((int)a2 > 7 || (a2 & 0x8000000080000000) != 0 || (unint64_t v2 = HIDWORD(a2), SHIDWORD(a2) > 7)) {
LABEL_19:
  }
    jx_roigroup::delete_child();
  uint64_t v3 = result;
  while (1)
  {
    int v4 = v2 + 8 * a2;
    uint64_t v5 = v3 + 128;
    uint64_t v6 = v4;
    if (*(_DWORD *)(v3 + 16)) {
      break;
    }
    if (*(void *)(v5 + 24 * v4)) {
      jx_roigroup::delete_child();
    }
    for (uint64_t i = 128; i != 1664; i += 24)
    {
      if (*(void *)(v3 + i)) {
        return result;
      }
    }
LABEL_15:
    uint64_t v10 = *(_DWORD **)(v3 + 8);
    if (!v10)
    {
      uint64_t v11 = *(void *)v3 + 8 * *(int *)(v3 + 20);
      uint64_t v13 = *(void *)(v11 + 80);
      uint64_t v12 = (void *)(v11 + 80);
      if (v13 == v3)
      {
        void *v12 = 0;
        jx_roigroup::~jx_roigroup((jx_roigroup *)v3);
        JUMPOUT(0x18C11C0E0);
      }
      jx_roigroup::delete_child();
    }
    LODWORD(v2) = (*(_DWORD *)(v3 + 28) - v10[7]) / v10[11];
    LODWORD(a2) = (*(_DWORD *)(v3 + 24) - v10[6]) / v10[10];
    if ((a2 | v2) >= 8) {
      jx_roigroup::delete_child();
    }
    if (*(void *)&v10[2 * (v2 + 8 * a2) + 32] != v3) {
      jx_roigroup::delete_child();
    }
    uint64_t v3 = *(void *)(v3 + 8);
    if ((a2 & 0x80000000) != 0) {
      goto LABEL_19;
    }
  }
  uint64_t v7 = *(jx_roigroup **)(v5 + 8 * v4);
  if (!v7) {
    jx_roigroup::delete_child();
  }
  jx_roigroup::~jx_roigroup(v7);
  uint64_t result = MEMORY[0x18C11C0E0]();
  uint64_t v8 = 0;
  *(void *)(v5 + 8 * vjp2_colour_converter::clear(this + 6) = 0;
  while (!*(void *)(v5 + v8))
  {
    v8 += 8;
    if (v8 == 512) {
      goto LABEL_15;
    }
  }
  return result;
}

void jx_roigroup::~jx_roigroup(jx_roigroup *this)
{
  if (*((_DWORD *)this + 4))
  {
    unint64_t v2 = (jx_roigroup **)((char *)this + 128);
    for (unsigned int i = 65; i > 1; --i)
    {
      if (*v2)
      {
        jx_roigroup::~jx_roigroup(*v2);
        MEMORY[0x18C11C0E0]();
      }
      ++v2;
    }
  }
  jp2_output_box::~jp2_output_box((jx_roigroup *)((char *)this + 48));
}

void jx_meta_manager::jx_meta_manager(jx_meta_manager *this)
{
  *((void *)this + 5++*((_DWORD *)this + 3) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + ++*((_DWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + jp2_colour_converter::clear(this + 6) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 1++*((_DWORD *)this + 3) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 1jp2_colour_converter::clear(this + 6) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((void *)this + 42) = 0;
  *((void *)this + 54) = 0x600000006;
  operator new[]();
}

void sub_1886E8C58(_Unwind_Exception *a1)
{
  jp2_output_box::~jp2_output_box(v1);
  _Unwind_Resume(a1);
}

void jx_meta_manager::~jx_meta_manager(jx_meta_manager *this)
{
  unint64_t v2 = (jx_metanode *)*((void *)this + 3);
  if (v2)
  {
    jx_metanode::~jx_metanode(v2);
    MEMORY[0x18C11C0E0]();
  }
  *((void *)this + ++*((_DWORD *)this + 3) = 0;
  for (uint64_t i = 80; i != 336; i += 8)
  {
    int v4 = *(jx_roigroup **)((char *)this + i);
    if (v4)
    {
      jx_roigroup::~jx_roigroup(v4);
      MEMORY[0x18C11C0E0]();
    }
  }
  uint64_t v5 = *((void *)this + 55);
  if (v5) {
    MEMORY[0x18C11C0C0](v5, 0x1000C8052888210);
  }
  jp2_output_box::~jp2_output_box((jx_meta_manager *)((char *)this + 344));
}

BOOL jpx_meta_manager::load_matches(jpx_meta_manager *this, int a2, int *a3, int a4, int *a5)
{
  LODWORD(vjp2_colour_converter::clear(this + 6) = a4;
  LODWORD(v8) = a2;
  uint64_t v10 = *(void *)(*(void *)this + 336);
  while (jx_source::parse_next_top_level_box(*(jx_source **)(*(void *)this + 8), 0))
    ;
  if ((int)v8 >= 1)
  {
    uint64_t v8 = v8;
    do
    {
      int v11 = *a3++;
      codestreauint64_t m = (jx_codestream_source *)jx_source::get_codestream(*(jx_source **)(*(void *)this + 8), v11);
      if (codestream) {
        jx_codestream_source::finish(codestream, 0);
      }
      --v8;
    }
    while (v8);
  }
  if ((int)v6 >= 1)
  {
    uint64_t v6 = v6;
    do
    {
      int v13 = *a5++;
      compositing_layer = (jx_layer_source *)jx_source::get_compositing_layer(*(jx_source **)(*(void *)this + 8), v13);
      if (compositing_layer) {
        jx_layer_source::finish(compositing_layer);
      }
      --v6;
    }
    while (v6);
  }
  jx_metanode::load_recursive(*(void *)(*(void *)this + 24));
  return v10 != *(void *)(*(void *)this + 336);
}

uint64_t jpx_meta_manager::enumerate_matches(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  v67[0] = a6;
  v67[1] = a7;
  uint64_t v9 = *a1;
  if (!*a1) {
    return 0;
  }
  uint64_t v10 = a2;
  BOOL v11 = __OFSUB__(HIDWORD(a7), 1);
  if (SHIDWORD(a7) >= 1)
  {
    BOOL v11 = __OFSUB__(a7, 1);
    if ((int)a7 >= 1)
    {
      if (a2)
      {
        uint64_t v13 = *(void *)(a2 + 96);
        uint64_t v14 = *(int **)(v13 + 16);
        unsigned int v15 = -1431655765 * ((unint64_t)(v13 - (void)v14 - 128) >> 3);
        BOOL v11 = __OFSUB__(v15, 64);
        if (v15 >= 0x40) {
          jpx_meta_manager::enumerate_matches();
        }
        int v16 = v14[5];
        int v17 = v16 + 1;
        int v18 = v15 >> 3;
        int v19 = v15 - 8 * v18;
        int v20 = HIDWORD(a6) + (-8 << v16) + 1;
        uint64_t v21 = *(void *)(a2 + 104);
      }
      else
      {
        int v19 = 0;
        int v18 = 0;
        int v20 = 0;
        uint64_t v14 = 0;
        int v17 = 0;
        uint64_t v21 = 0;
      }
      int v32 = HIDWORD(a7) + HIDWORD(a6);
      int v33 = a7 + a6;
      if ((int)(a4 & a3) < 0 != v11) {
        uint64_t v34 = a5;
      }
      else {
        uint64_t v34 = 1;
      }
LABEL_49:
      uint64_t v35 = v17;
      BOOL v36 = v14;
      uint64_t v10 = v21;
      while (1)
      {
        if (!v14 && v35 > 31) {
          return v10;
        }
        if (v10) {
          break;
        }
        if (v14)
        {
          if (v19 <= 6 && v14[7] + v14[11] * (v19 + 1) < v32)
          {
            ++v19;
            goto LABEL_78;
          }
          if (v18 > 6 || v14[6] + v14[10] * (v18 + 1) >= v33)
          {
            uint64_t v14 = 0;
            uint64_t v21 = 0;
            uint64_t v41 = (_DWORD *)*((void *)v36 + 1);
            int v17 = v35;
            if (v41)
            {
              int v19 = (v36[7] - v41[7]) / v41[11];
              if (v19 > 7
                || (int v18 = (v36[6] - v41[6]) / v41[10], v18 < 0)
                || (uint64_t v21 = 0,
                    int v20 = HIDWORD(v67[0]) + (-8 << v41[5]) + 1,
                    uint64_t v14 = (int *)*((void *)v36 + 1),
                    int v17 = v35,
                    v18 >= 8))
              {
                jpx_meta_manager::enumerate_matches();
              }
            }
            goto LABEL_49;
          }
          int v40 = v20 - v14[7];
          if (v40 < 0)
          {
            int v19 = 0;
            ++v18;
LABEL_78:
            uint64_t v37 = v14;
            int v17 = v35;
          }
          else
          {
            ++v18;
            uint64_t v37 = v14;
            int v17 = v35;
            int v19 = v40 / v14[11];
          }
LABEL_79:
          int v43 = v19 + 8 * v18;
          if (v37[4] < 1)
          {
            uint64_t v14 = v37;
          }
          else
          {
            uint64_t v21 = 0;
            uint64_t v44 = *(int **)&v37[2 * v43 + 32];
            uint64_t v14 = v37;
            if (!v44) {
              goto LABEL_49;
            }
            while (1)
            {
              uint64_t v14 = v44;
              int v45 = (-8 << v44[5]) | 1;
              int v20 = v45 + HIDWORD(v67[0]);
              int v46 = v45 + HIDWORD(v67[0]) - v44[7];
              if (v46 < 0) {
                int v19 = 0;
              }
              else {
                int v19 = v46 / v44[11];
              }
              int v47 = v45 + LODWORD(v67[0]) - v44[6];
              if (v47 < 0) {
                int v18 = 0;
              }
              else {
                int v18 = v47 / v44[10];
              }
              if (v19 > 7 || v18 >= 8) {
                jpx_meta_manager::enumerate_matches();
              }
              int v43 = v19 + 8 * v18;
              if (v14[4] <= 0) {
                break;
              }
              uint64_t v44 = *(int **)&v14[2 * v43 + 32];
              if (!v44)
              {
                uint64_t v21 = 0;
                goto LABEL_49;
              }
            }
            uint64_t v37 = v14;
          }
          uint64_t v21 = 0;
          uint64_t v10 = *(void *)&v37[6 * v43 + 32];
          if (!v10) {
            goto LABEL_49;
          }
LABEL_95:
          if (*(unsigned char *)(v10 + 15) != 2 || (uint64_t v48 = *(void *)(v10 + 16)) == 0) {
            jpx_meta_manager::enumerate_matches();
          }
          if (*(_DWORD *)(v48 + 40) < (int)a8) {
            goto LABEL_126;
          }
          int v65 = v20;
          unsigned int v66 = a5;
          uint64_t v49 = a8;
          uint64_t v50 = a4;
          uint64_t v51 = a3;
          int v63 = v18;
          int v64 = v19;
          uint64_t v52 = v34;
          BOOL v53 = kdu_dims::intersects((_DWORD *)(v48 + 8), v67);
          uint64_t v34 = v52;
          int v18 = v63;
          int v19 = v64;
          a3 = v51;
          a4 = v50;
          a8 = v49;
          int v20 = v65;
          a5 = v66;
          if (!v53) {
            goto LABEL_126;
          }
          if (v34)
          {
            uint64_t v54 = *(void *)(v10 + 56);
            if (!v54) {
              goto LABEL_126;
            }
            while (1)
            {
              if (*(unsigned char *)(v54 + 15) == 1)
              {
                int v55 = *(unsigned int **)(v54 + 16);
                if (v55) {
                  break;
                }
              }
              uint64_t v54 = *(void *)(v54 + 56);
              if (!v54) {
                goto LABEL_126;
              }
            }
            if (v66 && !*((unsigned char *)v55 + 48)) {
              goto LABEL_126;
            }
            if ((v51 & 0x80000000) != 0)
            {
              BOOL v58 = 1;
            }
            else
            {
              uint64_t v56 = *v55;
              if ((int)v56 < 1)
              {
                LODWORD(v57) = 0;
              }
              else
              {
                uint64_t v57 = 0;
                while (*(_DWORD *)(*((void *)v55 + 2) + 4 * v57) != v51)
                {
                  if (v56 == ++v57)
                  {
                    LODWORD(v57) = *v55;
                    break;
                  }
                }
              }
              BOOL v58 = v57 != v56;
            }
            if ((v50 & 0x80000000) == 0)
            {
              uint64_t v59 = v55[6];
              if ((int)v59 < 1)
              {
                LODWORD(v60) = 0;
              }
              else
              {
                uint64_t v60 = 0;
                uint64_t v61 = *((void *)v55 + 5);
                while (*(_DWORD *)(v61 + 4 * v60) != v50)
                {
                  if (v59 == ++v60)
                  {
                    LODWORD(v60) = v59;
                    break;
                  }
                }
              }
              if (v60 == v59) {
                BOOL v58 = 0;
              }
            }
            if (!v58)
            {
LABEL_126:
              uint64_t v21 = *(void *)(v10 + 104);
              goto LABEL_49;
            }
          }
          return v10;
        }
        uint64_t v10 = 0;
        int v17 = v35 + 1;
        uint64_t v37 = *(int **)(*a1 + 8 * v35++ + 80);
        if (v37)
        {
          int v38 = (-8 << v37[5]) | 1;
          int v20 = v38 + HIDWORD(v67[0]);
          int v39 = v38 + HIDWORD(v67[0]) - v37[7];
          if (v39 < 0) {
            int v19 = 0;
          }
          else {
            int v19 = v39 / v37[11];
          }
          int v42 = v38 + LODWORD(v67[0]) - v37[6];
          if (v42 < 0) {
            int v18 = 0;
          }
          else {
            int v18 = v42 / v37[10];
          }
          uint64_t v14 = 0;
          uint64_t v21 = 0;
          if (v19 > 7) {
            goto LABEL_49;
          }
          uint64_t v21 = 0;
          if (v18 > 7) {
            goto LABEL_49;
          }
          goto LABEL_79;
        }
      }
      int v17 = v35;
      goto LABEL_95;
    }
  }
  if ((int)(a4 & a3) < 0 == v11 || a5)
  {
    int v23 = (uint64_t *)(v9 + 56);
    while (1)
    {
      while (1)
      {
        while (1)
        {
LABEL_15:
          int v24 = v23;
          if (v10)
          {
            if (*(uint64_t **)(v10 + 96) != v23) {
              jpx_meta_manager::enumerate_matches();
            }
            int v24 = (uint64_t *)(v10 + 104);
          }
          uint64_t v10 = *v24;
          if (!*v24) {
            return v10;
          }
          if (*(unsigned char *)(v10 + 15) == 1)
          {
            int v25 = *(unsigned int **)(v10 + 16);
            if (v25) {
              break;
            }
          }
        }
        if (a9) {
          break;
        }
LABEL_26:
        if (!a5 || *((unsigned char *)v25 + 48))
        {
          if ((a3 & 0x80000000) != 0) {
            goto LABEL_36;
          }
          uint64_t v27 = *v25;
          if ((int)v27 < 1)
          {
            LODWORD(v28) = 0;
          }
          else
          {
            uint64_t v28 = 0;
            while (*(_DWORD *)(*((void *)v25 + 2) + 4 * v28) != a3)
            {
              if (v27 == ++v28) {
                goto LABEL_15;
              }
            }
          }
          if (v28 != v27)
          {
LABEL_36:
            if ((a4 & 0x80000000) != 0) {
              return v10;
            }
            uint64_t v29 = v25[6];
            if ((int)v29 < 1)
            {
              LODWORD(v30) = 0;
            }
            else
            {
              uint64_t v30 = 0;
              uint64_t v31 = *((void *)v25 + 5);
              while (*(_DWORD *)(v31 + 4 * v30) != a4)
              {
                if (v29 == ++v30) {
                  goto LABEL_15;
                }
              }
            }
            if (v30 != v29) {
              return v10;
            }
          }
        }
      }
      uint64_t v26 = *(void *)(v10 + 64);
      if (v26)
      {
        while (*(unsigned char *)(v26 + 15) == 2)
        {
          uint64_t v26 = *(void *)(v26 + 104);
          if (!v26) {
            goto LABEL_15;
          }
        }
        goto LABEL_26;
      }
    }
  }
  if (a2)
  {
    if (*(void *)(a2 + 96) != v9 + 32) {
      jpx_meta_manager::enumerate_matches();
    }
    uint64_t v22 = a2 + 104;
  }
  else
  {
    uint64_t v22 = v9 + 32;
  }
  return *(void *)v22;
}

void jx_registration::init(jx_registration *this, jp2_input_box *a2)
{
  if (*((void *)this + 1))
  {
    uint64_t v10 = 0;
    long long v8 = 0u;
    long long v9 = 0u;
    kdu_error::kdu_error((kdu_error *)&v8, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v8 + 16))(&v8, "JPX data source appears to contain multiple JPX Codestream Registration (creg) boxes within the same compositing layer header (jplh) box.");
    kdu_error::~kdu_error((kdu_error *)&v8);
  }
  *((void *)this + ++*((_DWORD *)this + 3) = 0;
  *(_DWORD *)uint64_t v7 = 0;
  if (!jp2_input_box::read(a2, &v7[1]) || !jp2_input_box::read(a2, v7) || (int v4 = v7[1]) == 0 || !v7[0])
  {
    uint64_t v10 = 0;
    long long v8 = 0u;
    long long v9 = 0u;
    kdu_error::kdu_error((kdu_error *)&v8, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v8 + 16))(&v8, "Malformed Codestream Registration (creg) box found in JPX data source.  Insufficient or illegal fields encountered.");
    kdu_error::~kdu_error((kdu_error *)&v8);
  }
  *((_DWORD *)this + 4) = v7[0];
  *((_DWORD *)this + 5) = v4;
  if (*((unsigned char *)a2 + 125) {
    || (int v5 = *((_DWORD *)a2 + 44) + *((_DWORD *)a2 + 22) - *((_DWORD *)a2 + 34),
  }
        HIDWORD(vjp2_colour_converter::clear(this + 6) = -1431655765 * v5 + 715827882,
        LODWORD(vjp2_colour_converter::clear(this + 6) = HIDWORD(v6),
        (v6 >> 1) >= 0x2AAAAAAB))
  {
    uint64_t v10 = 0;
    long long v8 = 0u;
    long long v9 = 0u;
    kdu_error::kdu_error((kdu_error *)&v8, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v8 + 16))(&v8, "Malformed Codestream Registration (creg) box found in JPX data source.  Box size does not seem to be equal to 4+6k where k must be the number of referenced codestreams.");
    kdu_error::~kdu_error((kdu_error *)&v8);
  }
  if (v5 < 0)
  {
    uint64_t v10 = 0;
    long long v8 = 0u;
    long long v9 = 0u;
    kdu_error::kdu_error((kdu_error *)&v8, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v8 + 16))(&v8, "Malformed Codestream Registration.");
    kdu_error::~kdu_error((kdu_error *)&v8);
  }
  *(_DWORD *)this = v5 / 6;
  *((_DWORD *)this + 1) = v5 / 6;
  is_mul_ok(v5 / 6, 0x14uLL);
  operator new[]();
}

void sub_1886E991C(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886E9928(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

void *jx_registration::finalize(void *this)
{
  if (!this[1])
  {
    *this = 0x100000001;
    operator new[]();
  }
  return this;
}

uint64_t jx_codestream_source::donate_chdr_box(jx_codestream_source *this, jp2_input_box *a2)
{
  if (*((unsigned char *)this + 23))
  {
    unint64_t v2 = *(uint64_t (**)(jp2_input_box *))(*(void *)a2 + 16);
    return v2(a2);
  }
  int v5 = (char *)this + 512;
  uint64_t v6 = *((void *)this + 65);
  if (v6 < 0)
  {
    if (*(void *)v5) {
      goto LABEL_19;
    }
  }
  else if (v6 || *((_DWORD *)this + 132))
  {
LABEL_19:
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  if (*((unsigned char *)this + 150) || *((unsigned char *)this + 334)) {
    goto LABEL_19;
  }
  if (v6 < 0)
  {
    if (!*(void *)v5) {
      goto LABEL_14;
    }
LABEL_18:
    jx_codestream_source::donate_chdr_box();
  }
  if (*((_DWORD *)this + 132)) {
    goto LABEL_18;
  }
LABEL_14:
  jp2_input_box::transplant((jx_codestream_source *)((char *)this + 24), a2);
  *(_OWORD *)int v5 = *((_OWORD *)this + 2);
  *((_DWORD *)v5 + 4) = *((_DWORD *)this + 12);

  return jx_codestream_source::finish(this, 0);
}

uint64_t jx_codestream_source::donate_codestream_box(jx_codestream_source *this, jp2_input_box *a2)
{
  uint64_t v3 = (char *)this + 544;
  uint64_t v4 = *((void *)this + 69);
  if (v4 < 0)
  {
    if (!*(void *)v3) {
      goto LABEL_4;
    }
LABEL_13:
    jx_codestream_source::donate_codestream_box();
  }
  if (v4 || *((_DWORD *)this + 140)) {
    goto LABEL_13;
  }
LABEL_4:
  jp2_input_box::transplant((jx_codestream_source *)((char *)this + 568), a2);
  *(_OWORD *)uint64_t v3 = *((_OWORD *)this + 36);
  *((_DWORD *)v3 + 4) = *((_DWORD *)this + 148);
  if (*((_DWORD *)this + 154) != 1718903404
    || (uint64_t result = jx_codestream_source::parse_fragment_list(this), result))
  {
    uint64_t v6 = *((void *)this + 76);
    uint64_t result = !v6
          || !*(void *)(v6 + 32)
          || jp2_input_box::set_codestream_scope((jx_codestream_source *)((char *)this + 568), 0, 1);
    *((unsigned char *)this + 21) = result;
  }
  return result;
}

uint64_t jx_codestream_source::parse_fragment_list(jx_codestream_source *this)
{
  if (*((void *)this + 106)) {
    return 1;
  }
  if (*((_DWORD *)this + 154) != 1718903404) {
    jx_codestream_source::parse_fragment_list();
  }
  if (*((unsigned char *)this + 150)) {
    return 0;
  }
  uint64_t result = jp2_input_box::is_complete((jx_codestream_source *)((char *)this + 568));
  if (result)
  {
    while (1)
    {
      if (!*((unsigned char *)this + 334))
      {
        uint64_t result = jp2_input_box::open((jx_codestream_source *)((char *)this + 208), (jx_codestream_source *)((char *)this + 568));
        if (!result) {
          break;
        }
      }
      uint64_t v3 = (jx_codestream_source *)((char *)this + 208);
      if (*((_DWORD *)this + 64) == 1718383476)
      {
        uint64_t result = jp2_input_box::is_complete(v3);
        if (result) {
          operator new();
        }
        return result;
      }
      jp2_input_box::close(v3);
    }
  }
  return result;
}

BOOL jx_source::test_box_filter(jx_source *this, int a2)
{
  if (a2 == 1634955107) {
    return 1;
  }
  unint64_t v2 = *((unsigned int *)this + 569);
  if (!v2) {
    return 1;
  }
  if ((int)v2 < 1) {
    return 0;
  }
  uint64_t v3 = (_DWORD *)*((void *)this + 285);
  if (*v3 == a2) {
    return 1;
  }
  uint64_t v5 = 1;
  do
  {
    unint64_t v6 = v5;
    if (v2 == v5) {
      break;
    }
    int v7 = v3[v5++];
  }
  while (v7 != a2);
  return v6 < v2;
}

uint64_t jpx_codestream_source::get_codestream_id(jpx_codestream_source *this)
{
  uint64_t v1 = *(void *)this;
  if (!*(void *)this || !*(unsigned char *)(v1 + 20)) {
    jpx_codestream_source::get_codestream_id();
  }
  return *(unsigned int *)(v1 + 16);
}

uint64_t jx_codestream_source::is_stream_ready(jx_codestream_source *this)
{
  if (*((_DWORD *)this + 154) == 1718903404)
  {
    return jx_codestream_source::parse_fragment_list(this);
  }
  else if (*((unsigned char *)this + 21))
  {
    return 1;
  }
  else if (*((unsigned char *)this + 694))
  {
    uint64_t v3 = *((void *)this + 76);
    if (v3
      && *(void *)(v3 + 32)
      && !jp2_input_box::set_codestream_scope((jx_codestream_source *)((char *)this + 568), *((int *)this + 4), 1))
    {
      return *((unsigned char *)this + 21) != 0;
    }
    else
    {
      uint64_t result = 1;
      *((unsigned char *)this + 21) = 1;
    }
  }
  else
  {
    return 0;
  }
  return result;
}

char *jpx_codestream_source::access_dimensions(jx_codestream_source **this, int a2)
{
  unint64_t v2 = *this;
  if (!*this || !*((unsigned char *)v2 + 20)) {
    jpx_codestream_source::access_dimensions();
  }
  uint64_t v3 = (char *)v2 + 392;
  v6[1] = (char *)v2 + 392;
  if (a2)
  {
    if (!*((unsigned char *)v2 + 433))
    {
      uint64_t v4 = jpx_codestream_source::open_stream(this, 0);
      if (v4)
      {
        v6[0] = 0;
        kdu_codestream::create((kdu_codestream *)v6, v4);
      }
    }
  }
  return v3;
}

jpx_input_box *jpx_codestream_source::open_stream(jx_codestream_source **this, jpx_input_box *a2)
{
  uint64_t v3 = *this;
  if (!v3) {
    jpx_codestream_source::open_stream();
  }
  if (!jx_codestream_source::is_stream_ready(v3)) {
    return 0;
  }
  uint64_t v5 = *this;
  if (a2) {
    goto LABEL_8;
  }
  if (*((unsigned char *)v5 + 22))
  {
    if (*((unsigned char *)v5 + 694))
    {
      uint64_t v12 = 0;
      memset(v11, 0, sizeof(v11));
      kdu_error::kdu_error((kdu_error *)v11, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)v11);
    }
    a2 = (jx_codestream_source *)((char *)v5 + 568);
LABEL_8:
    uint64_t v6 = *((void *)v5 + 106);
    if (v6)
    {
      (*(void (**)(jpx_input_box *, uint64_t, uint64_t, void, uint64_t))(*(void *)a2 + 112))(a2, v6, *(void *)v5 + 656, *((void *)v5 + 1), 1785737827);
    }
    else
    {
      uint64_t v7 = *((void *)v5 + 1);
      long long v9 = *((_OWORD *)v5 + 34);
      uint64_t v10 = *((void *)v5 + 70);
      (*(void (**)(jpx_input_box *, uint64_t, long long *))(*(void *)a2 + 72))(a2, v7, &v9);
    }
    return a2;
  }
  if (!*((unsigned char *)v5 + 694)) {
    jpx_codestream_source::open_stream();
  }
  a2 = (jx_codestream_source *)((char *)v5 + 568);
  *((unsigned char *)v5 + 22) = 1;
  return a2;
}

void sub_1886EA048(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886EA054()
{
  _Unwind_Resume(v0);
}

uint64_t jpx_codestream_source::access_palette(jpx_codestream_source *this)
{
  uint64_t v1 = *(void *)this;
  if (!*(void *)this || !*(unsigned char *)(v1 + 20)) {
    jpx_codestream_source::access_palette();
  }
  return v1 + 440;
}

BOOL jx_layer_source::donate_jplh_box(jx_layer_source *this, jp2_input_box *a2)
{
  uint64_t v3 = (char *)this + 568;
  uint64_t v4 = *((void *)this + 72);
  if (v4 < 0)
  {
    if (*(void *)v3) {
      goto LABEL_11;
    }
  }
  else if (v4 || *((_DWORD *)this + 146))
  {
LABEL_11:
    jx_layer_source::donate_jplh_box();
  }
  if (*((unsigned char *)this + 142) || *((unsigned char *)this + 510)) {
    goto LABEL_11;
  }
  jp2_input_box::transplant((jx_layer_source *)((char *)this + 16), a2);
  *(_OWORD *)uint64_t v3 = *(_OWORD *)((char *)this + 24);
  *((_DWORD *)v3 + 4) = *((_DWORD *)this + 10);

  return jx_layer_source::finish(this);
}

uint64_t jx_layer_source::check_stream_headers(jx_layer_source *this)
{
  if (*((unsigned char *)this + 12))
  {
    if (*((int *)this + 191) < 1)
    {
LABEL_7:
      uint64_t result = 1;
      *((unsigned char *)this + 1++*((_DWORD *)this + 3) = 1;
      return result;
    }
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    while (1)
    {
      codestreauint64_t m = (jx_codestream_source *)jx_source::get_codestream(*(jx_source **)this, *(_DWORD *)(*((void *)this + 96) + v2));
      if (!codestream) {
        jx_layer_source::check_stream_headers();
      }
      if ((jx_codestream_source::is_stream_ready(codestream) & 1) == 0) {
        break;
      }
      ++v3;
      v2 += 20;
      if (v3 >= *((int *)this + 191)) {
        goto LABEL_7;
      }
    }
  }
  return 0;
}

uint64_t jpx_layer_source::get_layer_id(jpx_layer_source *this)
{
  uint64_t v1 = *(void *)this;
  if (!*(void *)this || !*(unsigned char *)(v1 + 12)) {
    jpx_layer_source::get_layer_id();
  }
  return *(unsigned int *)(v1 + 8);
}

uint64_t jpx_layer_source::access_colour(jpx_layer_source *this, int a2)
{
  uint64_t v2 = *(void *)this;
  if (!*(void *)this || !*(unsigned char *)(v2 + 12)) {
    jpx_layer_source::access_colour();
  }
  uint64_t result = v2 + 648;
  if (a2 >= 1)
  {
    do
    {
      uint64_t result = *(void *)(result + 104);
      if (a2 < 2) {
        break;
      }
      --a2;
    }
    while (result);
  }
  return result;
}

uint64_t jpx_layer_source::have_stream_headers(jx_layer_source **this)
{
  uint64_t v1 = *this;
  if (!v1) {
    jpx_layer_source::have_stream_headers();
  }
  if (*((unsigned char *)v1 + 13)) {
    return 1;
  }

  return jx_layer_source::check_stream_headers(v1);
}

uint64_t jpx_layer_source::get_codestream_registration(uint64_t *a1, unsigned int a2, void *a3, void *a4, void *a5)
{
  uint64_t v5 = *a1;
  if (!*a1 || !*(unsigned char *)(v5 + 12)) {
    jpx_layer_source::get_codestream_registration();
  }
  *a5 = *(void *)(v5 + 776);
  if ((a2 & 0x80000000) != 0 || *(_DWORD *)(*a1 + 764) <= (signed int)a2) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = 20 * a2;
  *a3 = *(void *)(*(void *)(*a1 + 768) + v6 + 4);
  *a4 = *(void *)(*(void *)(*a1 + 768) + v6 + 12);
  return *(unsigned int *)(*(void *)(*a1 + 768) + v6);
}

void jx_source::jx_source(jx_source *this, jp2_family_src *a2)
{
  *((_OWORD *)this + 38) = xmmword_18898D230;
  *((unsigned char *)this + 624) = 1;
  *((_DWORD *)this + 157) = 0;
  *((void *)this + 80) = 0;
  *((_OWORD *)this + 41) = 0u;
  jp2_input_box::jp2_input_box((jx_source *)((char *)this + 680));
  *((unsigned char *)this + 864) = 0;
  *(void *)((char *)this + 868) = 0;
  *(void *)((char *)this + 95jp2_colour_converter::clear(this + 6) = 0;
  *((void *)this + 121) = 0;
  *((void *)this + 111) = 0;
  *((void *)this + 110) = 0;
  *((unsigned char *)this + 89jp2_colour_converter::clear(this + 6) = 0;
  *(_OWORD *)((char *)this + 904) = 0u;
  *(_OWORD *)((char *)this + 920) = 0u;
  *(_OWORD *)((char *)this + 93jp2_colour_converter::clear(this + 6) = 0u;
  *(_DWORD *)((char *)this + 951) = 0;
  j2_colour::j2_colour((jx_source *)((char *)this + 976));
  *((_OWORD *)this + 68) = 0u;
  jx_compatibility::jx_compatibility((jx_source *)((char *)this + 1144));
  jx_composition::jx_composition((jx_source *)((char *)this + 1336));
  jx_meta_manager::jx_meta_manager((jx_source *)((char *)this + 1840));
}

void sub_1886EA474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, jp2_input_box *a9, jp2_input_box *a10)
{
  jx_meta_manager::~jx_meta_manager(v11);
  jx_composition::~jx_composition(v10);
  jx_compatibility::~jx_compatibility(v18);
  j2_colour::~j2_colour(v17);
  j2_channels::~j2_channels(v16);
  uint64_t v20 = v12[116];
  if (v20) {
    MEMORY[0x18C11C0C0](v20, 0x1000C808B6DE1C6);
  }
  j2_palette::~j2_palette(v15);
  jp2_input_box::~jp2_input_box(v14);
  j2_data_references::~j2_data_references((j2_data_references *)(v12 + 82));
  uint64_t v21 = v12[80];
  if (v21) {
    MEMORY[0x18C11C0C0](v21, 0x1000C8052888210);
  }
  jp2_input_box::~jp2_input_box(v13);
  jp2_input_box::~jp2_input_box(a9);
  jp2_input_box::~jp2_input_box(a10);
  _Unwind_Resume(a1);
}

void sub_1886EA530()
{
}

void sub_1886EA538()
{
}

void sub_1886EA540()
{
}

void jx_source::~jx_source(jx_source *this)
{
  for (uint64_t i = (jx_codestream_source *)*((void *)this + 138); i; uint64_t i = (jx_codestream_source *)*((void *)this + 138))
  {
    *((void *)this + 138) = *((void *)i + 107);
    jx_codestream_source::~jx_codestream_source(i);
    MEMORY[0x18C11C0E0]();
  }
  while (1)
  {
    uint64_t v3 = (jx_layer_source *)*((void *)this + 139);
    if (!v3) {
      break;
    }
    *((void *)this + 139) = *((void *)v3 + 100);
    jx_layer_source::~jx_layer_source(v3);
    MEMORY[0x18C11C0E0]();
  }
  while (1)
  {
    uint64_t v4 = (j2_colour *)*((void *)this + 135);
    if (!v4) {
      break;
    }
    *((void *)this + 135) = *((void *)v4 + 13);
    j2_colour::~j2_colour(v4);
    MEMORY[0x18C11C0E0]();
  }
  jx_meta_manager::~jx_meta_manager((jx_source *)((char *)this + 1840));
  jx_composition::~jx_composition((jx_source *)((char *)this + 1336));
  jx_compatibility::~jx_compatibility((jx_source *)((char *)this + 1144));
  j2_colour::~j2_colour((jx_source *)((char *)this + 976));
  j2_channels::~j2_channels((jx_source *)((char *)this + 936));
  uint64_t v5 = *((void *)this + 116);
  if (v5) {
    MEMORY[0x18C11C0C0](v5, 0x1000C808B6DE1C6);
  }
  j2_palette::~j2_palette((jx_source *)((char *)this + 864));
  jp2_input_box::~jp2_input_box((jx_source *)((char *)this + 680));
  j2_data_references::~j2_data_references((jx_source *)((char *)this + 656));
  uint64_t v6 = *((void *)this + 80);
  if (v6) {
    MEMORY[0x18C11C0C0](v6, 0x1000C8052888210);
  }
  jp2_input_box::~jp2_input_box((jx_source *)((char *)this + 416));
  jp2_input_box::~jp2_input_box((jx_source *)((char *)this + 224));
  jp2_input_box::~jp2_input_box((jx_source *)((char *)this + 32));
}

BOOL jp2_family_src::is_top_level_complete(jp2_family_src *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (!v1) {
    return 1;
  }
  char v3 = 0;
  (*(void (**)(uint64_t, uint64_t, void, void, char *))(*(void *)v1 + 80))(v1, 4, 0, 0, &v3);
  return v3 != 0;
}

BOOL jx_source::finish_jp2_header_box(jx_source *this)
{
  if (*((unsigned char *)this + 600)) {
    return 1;
  }
  while (!*((unsigned char *)this + 408))
  {
    if (*((unsigned char *)this + 216)) {
      return *((unsigned char *)this + 216) != 0;
    }
    if ((jx_source::parse_next_top_level_box(this, 0) & 1) == 0)
    {
      if (!*((unsigned char *)this + 408)) {
        return *((unsigned char *)this + 216) != 0;
      }
      break;
    }
  }
  if (!*((unsigned char *)this + 350))
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  uint64_t v7 = (jx_source *)((char *)this + 864);
  long long v8 = (float *)((char *)this + 1088);
  while (1)
  {
    while (1)
    {
      while (1)
      {
        if (!*((unsigned char *)this + 542)
          && !jp2_input_box::open((jx_source *)((char *)this + 416), (jx_source *)((char *)this + 224)))
        {
          if (!jp2_input_box::is_complete((jx_source *)((char *)this + 224))
            && ((*((_DWORD *)this + 154) & 0x80000000) != 0
             || !*((unsigned char *)this + 648)
             || !*(unsigned char *)v7
             || *((int *)this + 231) < 1
             || !*((_DWORD *)this + 235)
             || !*((unsigned char *)this + 976)
             || *v8 <= 0.0))
          {
            return 0;
          }
          jp2_input_box::close((jx_source *)((char *)this + 224));
          j2_resolution::finalize(v8);
          BOOL result = 1;
          *((unsigned char *)this + 600) = 1;
          return result;
        }
        BOOL result = jp2_input_box::is_complete((jx_source *)((char *)this + 416));
        int v3 = *((_DWORD *)this + 116);
        if (v3 <= 1668246641) {
          break;
        }
        if (v3 > 1885564017)
        {
          if (v3 == 1885564018)
          {
            if (result) {
              j2_palette::init(v7, (jx_source *)((char *)this + 416));
            }
            return result;
          }
          if (v3 == 1919251232)
          {
            if (!result) {
              return result;
            }
            j2_resolution::init((j2_resolution *)v8, (jx_source *)((char *)this + 416));
          }
          else
          {
LABEL_32:
            if ((jp2_input_box::close((jx_source *)((char *)this + 416)) & 1) == 0)
            {
              uint64_t v10 = 0;
              memset(v9, 0, sizeof(v9));
              kdu_error::kdu_error((kdu_error *)v9, "Error in Kakadu File Format Support:\n");
              (*(void (**)(_OWORD *, const char *))(*(void *)&v9[0] + 16))(v9, "sub_box.close failed - corrupt jp2 file");
              kdu_error::~kdu_error((kdu_error *)v9);
            }
          }
        }
        else
        {
          if (v3 != 1668246642)
          {
            if (v3 == 1768449138)
            {
              if (result) {
                j2_dimensions::init((jx_source *)((char *)this + 608), (jx_source *)((char *)this + 416));
              }
              return result;
            }
            goto LABEL_32;
          }
          if (!result) {
            return result;
          }
          uint64_t v4 = (jx_source *)((char *)this + 976);
          do
          {
            uint64_t v5 = v4;
            uint64_t v4 = (j2_colour *)*((void *)v4 + 13);
          }
          while (v4);
          if (*(unsigned char *)v5) {
            operator new();
          }
          j2_colour::init(v5, (jx_source *)((char *)this + 416));
        }
      }
      if (v3 != 1651532643) {
        break;
      }
      if (!result) {
        return result;
      }
      j2_dimensions::process_bpcc_box((jx_source *)((char *)this + 608), (jx_source *)((char *)this + 416));
      *((unsigned char *)this + 648) = 1;
    }
    if (v3 != 1667523942) {
      break;
    }
    if (!result) {
      return result;
    }
    j2_channels::init((jx_source *)((char *)this + 936), (jx_source *)((char *)this + 416));
  }
  if (v3 != 1668112752) {
    goto LABEL_32;
  }
  if (result) {
    j2_component_map::init((jx_source *)((char *)this + 896), (jx_source *)((char *)this + 416));
  }
  return result;
}

void sub_1886EAA48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886EAA54()
{
  _Unwind_Resume(v0);
}

void jpx_source::jpx_source(jpx_source *this)
{
  *(void *)this = &unk_1ED4DE880;
  *((void *)this + 1) = 0;
}

uint64_t jpx_source::open(jpx_source *this, jp2_family_src *a2, char a3)
{
  uint64_t v6 = *((void *)this + 1);
  if (!v6) {
    operator new();
  }
  if (*(unsigned char *)(v6 + 15))
  {
    uint64_t v18 = 0;
    long long v16 = 0u;
    long long v17 = 0u;
    kdu_error::kdu_error((kdu_error *)&v16, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v16);
  }
  if (*(jp2_family_src **)v6 != a2 || *((_DWORD *)a2 + 18) != *(_DWORD *)(v6 + 8))
  {
    jx_source::~jx_source((jx_source *)v6);
    MEMORY[0x18C11C0E0]();
    operator new();
  }
  if (*(unsigned char *)(v6 + 12)) {
    goto LABEL_9;
  }
  if (!*(unsigned char *)(v6 + 158))
  {
    long long v14 = xmmword_18898D150;
    int v15 = 0;
    if (!jp2_input_box::open((jp2_input_box *)(v6 + 32), (uint64_t)a2, &v14)) {
      goto LABEL_16;
    }
    uint64_t v6 = *((void *)this + 1);
  }
  if (!jp2_input_box::is_complete((jp2_input_box *)(v6 + 32)))
  {
LABEL_16:
    if (!*((void *)a2 + 4))
    {
      (*(void (**)(jpx_source *))(*(void *)this + 24))(this);
      if ((a3 & 1) == 0)
      {
        uint64_t v18 = 0;
        long long v16 = 0u;
        long long v17 = 0u;
        kdu_error::kdu_error((kdu_error *)&v16, "Error in Kakadu File Format Support:\n");
        kdu_error::~kdu_error((kdu_error *)&v16);
      }
      return 0xFFFFFFFFLL;
    }
    return 0;
  }
  unsigned int v13 = 0;
  uint64_t v8 = *((void *)this + 1);
  if (*(_DWORD *)(v8 + 80) != 1783636000
    || !jp2_input_box::read((jp2_input_box *)(v8 + 32), &v13)
    || v13 != 218793738
    || (uint64_t v9 = *((void *)this + 1), *(unsigned char *)(v9 + 157))
    || *(void *)(v9 + 120) - *(void *)(v9 + 168) + *(int *)(v9 + 208))
  {
    (*(void (**)(jpx_source *))(*(void *)this + 24))(this);
    if ((a3 & 1) == 0)
    {
      uint64_t v18 = 0;
      long long v16 = 0u;
      long long v17 = 0u;
      kdu_error::kdu_error((kdu_error *)&v16, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)&v16);
    }
    return 0xFFFFFFFFLL;
  }
  jp2_input_box::close((jp2_input_box *)(v9 + 32));
  uint64_t v6 = *((void *)this + 1);
  *(unsigned char *)(v6 + 12) = 1;
LABEL_9:
  if (!*(unsigned char *)(v6 + 13))
  {
    if (!*(unsigned char *)(v6 + 158))
    {
      if (!jp2_input_box::open_next((jp2_input_box *)(v6 + 32)))
      {
LABEL_31:
        if (!*((void *)a2 + 4))
        {
          (*(void (**)(jpx_source *))(*(void *)this + 24))(this);
          if ((a3 & 1) == 0)
          {
            uint64_t v18 = 0;
            long long v16 = 0u;
            long long v17 = 0u;
            kdu_error::kdu_error((kdu_error *)&v16, "Error in Kakadu File Format Support:\n");
            kdu_error::~kdu_error((kdu_error *)&v16);
          }
          return 0xFFFFFFFFLL;
        }
        return 0;
      }
      uint64_t v6 = *((void *)this + 1);
    }
    if (jp2_input_box::is_complete((jp2_input_box *)(v6 + 32)))
    {
      uint64_t v10 = (_DWORD *)*((void *)this + 1);
      if (v10[20] == 1718909296)
      {
        if (jx_compatibility::init_ftyp((jx_compatibility *)(v10 + 286), (jp2_input_box *)(v10 + 8)))
        {
          uint64_t v6 = *((void *)this + 1);
          if (*(unsigned char *)(v6 + 158)) {
            jpx_source::open();
          }
          *(unsigned char *)(v6 + 1++*((_DWORD *)this + 3) = 1;
          int v11 = *(unsigned __int8 *)(v6 + 1144);
          *(unsigned char *)(v6 + 1jp2_colour_converter::clear(this + 6) = v11;
          if (v11) {
            goto LABEL_11;
          }
          goto LABEL_42;
        }
        (*(void (**)(jpx_source *))(*(void *)this + 24))(this);
        if ((a3 & 1) == 0)
        {
          uint64_t v18 = 0;
          long long v16 = 0u;
          long long v17 = 0u;
          kdu_error::kdu_error((kdu_error *)&v16, "Error in Kakadu File Format Support:\n");
          kdu_error::~kdu_error((kdu_error *)&v16);
        }
      }
      else
      {
        (*(void (**)(jpx_source *))(*(void *)this + 24))(this);
        if ((a3 & 1) == 0)
        {
          uint64_t v18 = 0;
          long long v16 = 0u;
          long long v17 = 0u;
          kdu_error::kdu_error((kdu_error *)&v16, "Error in Kakadu File Format Support:\n");
          kdu_error::~kdu_error((kdu_error *)&v16);
        }
      }
      return 0xFFFFFFFFLL;
    }
    goto LABEL_31;
  }
  if (*(unsigned char *)(v6 + 16))
  {
LABEL_11:
    uint64_t result = 1;
    *(unsigned char *)(v6 + 15) = 1;
    return result;
  }
LABEL_42:
  if (*(unsigned char *)(v6 + 14)) {
    jpx_source::open();
  }
  if (!*(unsigned char *)(v6 + 158))
  {
    if (!jp2_input_box::open_next((jp2_input_box *)(v6 + 32)))
    {
LABEL_48:
      if (*((void *)a2 + 4)) {
        return 0;
      }
      (*(void (**)(jpx_source *))(*(void *)this + 24))(this);
      if ((a3 & 1) == 0)
      {
        uint64_t v18 = 0;
        long long v16 = 0u;
        long long v17 = 0u;
        kdu_error::kdu_error((kdu_error *)&v16, "Error in Kakadu File Format Support:\n");
        kdu_error::~kdu_error((kdu_error *)&v16);
      }
      return 0xFFFFFFFFLL;
    }
    uint64_t v6 = *((void *)this + 1);
  }
  if (*(_DWORD *)(v6 + 80) == 1920099697 && !jp2_input_box::is_complete((jp2_input_box *)(v6 + 32))) {
    goto LABEL_48;
  }
  uint64_t v12 = (_DWORD *)*((void *)this + 1);
  if (v12[20] == 1920099697) {
    jx_compatibility::init_rreq((jx_compatibility *)(v12 + 286), (jp2_input_box *)(v12 + 8));
  }
  jx_source::parse_next_top_level_box((jx_source *)v12, 1);
  uint64_t result = 1;
  *(unsigned char *)(*((void *)this + 1) + 15) = 1;
  return result;
}

void sub_1886EB0F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886EB100(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(v15);
}

BOOL jpx_source::close(jpx_source *this)
{
  uint64_t v2 = (jx_source *)*((void *)this + 1);
  if (!v2) {
    return 0;
  }
  BOOL v3 = *((unsigned char *)v2 + 15) != 0;
  jx_source::~jx_source(v2);
  MEMORY[0x18C11C0E0]();
  *((void *)this + 1) = 0;
  return v3;
}

uint64_t jpx_source::count_codestreams(jpx_source *this, int *a2)
{
  uint64_t v3 = *((void *)this + 1);
  if (v3 && (uint64_t v3 = *(unsigned __int8 *)(v3 + 15), v3))
  {
    while (1)
    {
      uint64_t v5 = *((void *)this + 1);
      if (*(unsigned char *)(v5 + 216)) {
        break;
      }
      if (!jx_source::parse_next_top_level_box((jx_source *)v5, 0))
      {
        uint64_t v5 = *((void *)this + 1);
        uint64_t v3 = *(unsigned char *)(v5 + 216) != 0;
        goto LABEL_8;
      }
    }
    uint64_t v3 = 1;
LABEL_8:
    int v6 = *(_DWORD *)(v5 + 20);
  }
  else
  {
    int v6 = 0;
  }
  *a2 = v6;
  return v3;
}

uint64_t jpx_source::access_codestream(jpx_source *this, int a2, int a3)
{
  uint64_t v3 = *((void *)this + 1);
  if (!v3) {
    return 0;
  }
  int v4 = a2;
  uint64_t v5 = 0;
  if ((a2 & 0x80000000) == 0 && *(unsigned char *)(v3 + 15))
  {
    while (1)
    {
      uint64_t v8 = *((void *)this + 1);
      if (*(_DWORD *)(v8 + 20) > v4 || *(unsigned char *)(v8 + 216)) {
        break;
      }
      if (!jx_source::parse_next_top_level_box((jx_source *)v8, 0))
      {
        if (!v4 && *(unsigned char *)(*((void *)this + 1) + 216))
        {
          uint64_t v13 = 0;
          long long v11 = 0u;
          long long v12 = 0u;
          kdu_error::kdu_error((kdu_error *)&v11, "Error in Kakadu File Format Support:\n");
          (*(void (**)(long long *, const char *))(v11 + 16))(&v11, "JPX data source appears to contain no codestreams at all.");
          goto LABEL_24;
        }
        return 0;
      }
    }
    uint64_t v5 = *(void *)(v8 + 1104);
    if (v4 >= 1)
    {
      do
      {
        uint64_t v5 = *(void *)(v5 + 856);
        --v4;
      }
      while (v4);
    }
    if (!jx_codestream_source::finish((jx_codestream_source *)v5, 1))
    {
      if (!*(unsigned char *)(*((void *)this + 1) + 216)) {
        return 0;
      }
      if (*(unsigned char *)(v5 + 20))
      {
        uint64_t v9 = *(void *)(v5 + 552);
        if (v9 < 0)
        {
          if (*(void *)(v5 + 544)) {
            return 0;
          }
        }
        else if (v9 || *(_DWORD *)(v5 + 560))
        {
          return 0;
        }
      }
      uint64_t v13 = 0;
      long long v11 = 0u;
      long long v12 = 0u;
      kdu_error::kdu_error((kdu_error *)&v11, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v11 + 16))(&v11, "JPX data source appears to contain an incomplete codestream.  Specifically, this either means that an embedded contiguous or fragmented codestream has been found without sufficient descriptive metadata, or that a codestream header box has been found without any matching embedded contiguous or fragmented codestream.  Both of these conditions are illegal for JPX and JP2 data sources.");
LABEL_24:
      kdu_error::~kdu_error((kdu_error *)&v11);
    }
    if (a3 && !jx_codestream_source::is_stream_ready((jx_codestream_source *)v5)) {
      return 0;
    }
  }
  return v5;
}

void sub_1886EB40C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886EB418()
{
  _Unwind_Resume(v0);
}

uint64_t jpx_source::access_meta_manager(jpx_source *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    return v1 + 1840;
  }
  else {
    return 0;
  }
}

void jpx_source::~jpx_source(jpx_source *this)
{
  *(void *)this = &unk_1ED4DE880;
  jpx_source::close(this);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1ED4DE880;
  jpx_source::close(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t jx_frame::reset(jx_frame *this)
{
  *((_DWORD *)this + ++*((_DWORD *)this + 3) = 0;
  for (uint64_t result = *((void *)this + 3); ; uint64_t result = *((void *)this + 3))
  {
    *((void *)this + 4) = result;
    if (!result) {
      break;
    }
    *((void *)this + ++*((_DWORD *)this + 3) = *(void *)(result + 56);
    MEMORY[0x18C11C0E0]();
  }
  return result;
}

void jx_metaread::jx_metaread(jx_metaread *this)
{
  jp2_input_box::jp2_input_box(this);
  jp2_input_box::jp2_input_box((jp2_input_box *)(v2 + 184));
  *((void *)this + 4jp2_colour_converter::clear(this + 6) = 0;
  *((void *)this + 47) = 0;
}

void sub_1886EB5B4(_Unwind_Exception *a1)
{
  jp2_input_box::~jp2_input_box(v1);
  _Unwind_Resume(a1);
}

uint64_t jx_roigroup::jx_roigroup(uint64_t a1, uint64_t a2, int a3, int a4)
{
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  jp2_output_box::jp2_output_box((jp2_output_box *)(a1 + 48));
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 1jp2_colour_converter::clear(this + 6) = a4;
  *(_DWORD *)(a1 + 20) = a3;
  int v8 = 128 << a3;
  *(_DWORD *)(a1 + 40) = 128 << a3;
  *(_DWORD *)(a1 + 44) = 128 << a3;
  if (a4 >= 1)
  {
    unsigned int v9 = a4 + 1;
    do
    {
      v8 *= 8;
      --v9;
    }
    while (v9 > 1);
    *(_DWORD *)(a1 + 40) = v8;
    *(_DWORD *)(a1 + 44) = v8;
  }
  int v10 = 8 * v8;
  *(_DWORD *)(a1 + 32) = v10;
  *(_DWORD *)(a1 + 3jp2_colour_converter::clear(this + 6) = v10;
  bzero((void *)(a1 + 128), 0x600uLL);
  return a1;
}

void jx_compatibility::jx_compatibility(jx_compatibility *this)
{
  *(unsigned char *)this = 0;
  *(void *)((char *)this + 1) = 0x101010101010101;
  *((_DWORD *)this + ++*((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 1++*((_DWORD *)this + 3) = 0;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 5jp2_colour_converter::clear(this + 6) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
}

void jx_composition::jx_composition(jx_composition *this)
{
  *((void *)this + 61) = 0;
  *((void *)this + 62) = 0;
  *(unsigned char *)this = 0;
  *(_OWORD *)((char *)this + 45jp2_colour_converter::clear(this + 6) = xmmword_18898E360;
  *((void *)this + 59) = 0;
  *((void *)this + 60) = 0;
}

void sub_1886EB718(_Unwind_Exception *a1)
{
  jp2_input_box::~jp2_input_box(v2);
  jp2_output_box::~jp2_output_box(v1);
  _Unwind_Resume(a1);
}

void jx_composition::~jx_composition(jx_composition *this)
{
  uint64_t v2 = (jx_frame *)*((void *)this + 59);
  for (*((void *)this + 60) = v2; v2; *((void *)this + 60) = v2)
  {
    *((void *)this + 59) = *((void *)v2 + 6);
    jx_frame::reset(v2);
    MEMORY[0x18C11C0E0](v2, 0x1020C406ACA6742);
    uint64_t v2 = (jx_frame *)*((void *)this + 59);
  }
  jp2_input_box::~jp2_input_box((jx_composition *)((char *)this + 272));
  jp2_input_box::~jp2_input_box((jx_composition *)((char *)this + 88));
  jp2_output_box::~jp2_output_box((jx_composition *)((char *)this + 8));
}

void jx_compatibility::~jx_compatibility(jx_compatibility *this)
{
  uint64_t v2 = *((void *)this + 3);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C807733839DLL);
  }
  uint64_t v3 = *((void *)this + 13);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C80D990E388);
  }
  jp2_output_box::~jp2_output_box((jx_compatibility *)((char *)this + 112));
}

void j2_data_references::~j2_data_references(j2_data_references *this)
{
  if (*((void *)this + 1))
  {
    int v2 = *(_DWORD *)this;
    if (*(int *)this < 1) {
      goto LABEL_8;
    }
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(*((void *)this + 1) + 8 * v3);
      if (v4)
      {
        MEMORY[0x18C11C0C0](v4, 0x1000C8077774924);
        int v2 = *(_DWORD *)this;
      }
      ++v3;
    }
    while (v3 < v2);
    if (*((void *)this + 1)) {
LABEL_8:
    }
      MEMORY[0x18C11C0C0]();
  }
}

void jx_codestream_source::~jx_codestream_source(jx_codestream_source *this)
{
  uint64_t v2 = *((void *)this + 106);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 8);
    if (v3) {
      MEMORY[0x18C11C0C0](v3, 0x1000C800CE834B2);
    }
    MEMORY[0x18C11C0E0](v2, 0x1020C40FBFA920DLL);
  }
  jpx_input_box::~jpx_input_box((jx_codestream_source *)((char *)this + 568));
  uint64_t v4 = *((void *)this + 63);
  if (v4) {
    MEMORY[0x18C11C0C0](v4, 0x1000C808B6DE1C6);
  }
  j2_palette::~j2_palette((jx_codestream_source *)((char *)this + 440));
  uint64_t v5 = *((void *)this + 53);
  if (v5) {
    MEMORY[0x18C11C0C0](v5, 0x1000C8052888210);
  }
  jp2_input_box::~jp2_input_box((jx_codestream_source *)((char *)this + 208));
  jp2_input_box::~jp2_input_box((jx_codestream_source *)((char *)this + 24));
}

void jx_layer_source::~jx_layer_source(jx_layer_source *this)
{
  for (uint64_t i = (j2_colour *)*((void *)this + 94); i; uint64_t i = (j2_colour *)*((void *)this + 94))
  {
    *((void *)this + 94) = *((void *)i + 13);
    j2_colour::~j2_colour(i);
    MEMORY[0x18C11C0E0]();
  }
  uint64_t v3 = *((void *)this + 96);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C80A86A77D5);
  }
  j2_colour::~j2_colour((jx_layer_source *)((char *)this + 648));
  j2_channels::~j2_channels((jx_layer_source *)((char *)this + 608));
  jp2_input_box::~jp2_input_box((jx_layer_source *)((char *)this + 384));
  jp2_input_box::~jp2_input_box((jx_layer_source *)((char *)this + 200));
  jp2_input_box::~jp2_input_box((jx_layer_source *)((char *)this + 16));
}

void jx_layer_source::jx_layer_source(jx_layer_source *this, jx_source *a2, int a3)
{
  *((void *)this + 71) = 0;
  *((void *)this + 72) = -1;
  *((_DWORD *)this + 14jp2_colour_converter::clear(this + 6) = 0;
  *(void *)((char *)this + 628) = 0;
  *((void *)this + 80) = 0;
  *((_OWORD *)this + 37) = 0u;
  *((_OWORD *)this + 38) = 0u;
  *(_DWORD *)((char *)this + 62++*((_DWORD *)this + 3) = 0;
  j2_colour::j2_colour((jx_layer_source *)((char *)this + 648));
  *(_OWORD *)((char *)this + 760) = 0u;
  *(_OWORD *)((char *)this + 77jp2_colour_converter::clear(this + 6) = 0u;
  *(void *)this = a2;
  *((_DWORD *)this + 2) = a3;
  *((_WORD *)this + jp2_colour_converter::clear(this + 6) = 0;
  *(_OWORD *)((char *)this + 792) = 0u;
}

void sub_1886EBAB0(_Unwind_Exception *a1)
{
  j2_channels::~j2_channels(v4);
  jp2_input_box::~jp2_input_box(v3);
  jp2_input_box::~jp2_input_box(v2);
  jp2_input_box::~jp2_input_box(v1);
  _Unwind_Resume(a1);
}

void jx_codestream_source::jx_codestream_source(jx_codestream_source *this, jx_source *a2, jp2_family_src *a3, int a4, char a5)
{
  jp2_input_box::jp2_input_box((jx_codestream_source *)((char *)this + 24));
  jp2_input_box::jp2_input_box((jx_codestream_source *)((char *)this + 208));
  *(_OWORD *)((char *)this + 392) = xmmword_18898D230;
  *((unsigned char *)this + 408) = 1;
  *((_DWORD *)this + 10++*((_DWORD *)this + 3) = 0;
  *((void *)this + 5++*((_DWORD *)this + 3) = 0;
  *((unsigned char *)this + 440) = 0;
  *(void *)((char *)this + 444) = 0;
  *((void *)this + 57) = 0;
  *((void *)this + 58) = 0;
  *((unsigned char *)this + 472) = 0;
  *((_OWORD *)this + 30) = 0u;
  *((_OWORD *)this + 31) = 0u;
  *((void *)this + 64) = 0;
  *((void *)this + 65) = -1;
  *((_DWORD *)this + 132) = 0;
  *((_OWORD *)this + 34) = xmmword_18898D150;
  *((_DWORD *)this + 140) = 0;
  jp2_input_box::jp2_input_box((jx_codestream_source *)((char *)this + 568));
  *((void *)this + 71) = &unk_1ED4E0E28;
  *((_OWORD *)this + 47) = 0u;
  *((_DWORD *)this + 202) = -1;
  *((_DWORD *)this + 192) = -1;
  *((void *)this + 105) = 0;
  *(_OWORD *)(v10 + 208) = 0u;
  *(_OWORD *)(v10 + 224) = 0u;
  *((_OWORD *)this + 51) = 0u;
  *((_DWORD *)this + 208) = 0;
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((_DWORD *)this + 4) = a4;
  *((unsigned char *)this + 2++*((_DWORD *)this + 3) = a5;
  *((_WORD *)this + 21jp2_colour_converter::clear(this + 6) = 0;
  *((_WORD *)this + 10) = 0;
  *((unsigned char *)this + 22) = 0;
  *((void *)this + 67) = 0;
  *((_OWORD *)this + 5++*((_DWORD *)this + 3) = 0u;
}

void sub_1886EBC20(_Unwind_Exception *a1)
{
  uint64_t v7 = *(void *)(v2 + 504);
  if (v7) {
    MEMORY[0x18C11C0C0](v7, 0x1000C808B6DE1C6);
  }
  jx_codestream_source::jx_codestream_source(v5, v4, v3);
  jp2_input_box::~jp2_input_box(v1);
  _Unwind_Resume(a1);
}

BOOL _cg_jpeg_calc_output_dimensions(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 36);
  if (v2 != 202)
  {
    uint64_t v3 = *(void (***)(void))a1;
    *((_DWORD *)v3 + 10) = 21;
    *((_DWORD *)v3 + 12) = v2;
    (**(void (***)(uint64_t))a1)(a1);
  }
  jpeg_core_output_dimensions(a1);
  int v4 = *(_DWORD *)(a1 + 56);
  if (v4 >= 1)
  {
    int v5 = 0;
    int v6 = *(_DWORD **)(a1 + 304);
    do
    {
      int v7 = *(_DWORD *)(a1 + 424);
      if (*(_DWORD *)(a1 + 92))
      {
        v6[9] = v7;
        int v8 = v6 + 9;
        int v9 = *(_DWORD *)(a1 + 428);
      }
      else
      {
        if (*(_DWORD *)(a1 + 100)) {
          int v10 = 8;
        }
        else {
          int v10 = 4;
        }
        if (v7 <= v10)
        {
          int v11 = 1;
          do
          {
            int v12 = 2 * v11;
            if (*(_DWORD *)(a1 + 416) % (2 * v11 * v6[2])) {
              break;
            }
            v11 *= 2;
          }
          while (v7 * v12 <= v10);
        }
        else
        {
          int v11 = 1;
        }
        v7 *= v11;
        v6[9] = v7;
        int v8 = v6 + 9;
        int v9 = *(_DWORD *)(a1 + 428);
        if (v9 <= v10)
        {
          int v13 = 1;
          while (1)
          {
            int v15 = 2 * v13;
            if (*(_DWORD *)(a1 + 420) % (2 * v13 * v6[3])) {
              goto LABEL_17;
            }
            v13 *= 2;
            if (v9 * v15 > v10)
            {
              int v13 = v15;
              goto LABEL_17;
            }
          }
        }
      }
      int v13 = 1;
LABEL_17:
      int v14 = v9 * v13;
      v6[10] = v9 * v13;
      if (v7 <= 2 * v9 * v13)
      {
        if (v14 > 2 * v7) {
          v6[10] = 2 * v7;
        }
      }
      else
      {
        int v7 = 2 * v14;
        *int v8 = 2 * v14;
      }
      v6[11] = jdiv_round_up((int)v6[2] * (uint64_t)v7 * *(unsigned int *)(a1 + 48), *(int *)(a1 + 556) * (uint64_t)*(int *)(a1 + 416));
      v6[12] = jdiv_round_up((int)v6[10] * (uint64_t)(int)v6[3] * *(unsigned int *)(a1 + 52), *(int *)(a1 + 556) * (uint64_t)*(int *)(a1 + 420));
      ++v5;
      v6 += 24;
      int v4 = *(_DWORD *)(a1 + 56);
    }
    while (v5 < v4);
  }
  int v16 = *(_DWORD *)(a1 + 64) - 1;
  if (v16 <= 6) {
    int v4 = dword_18898F0A0[v16];
  }
  if (*(_DWORD *)(a1 + 108)) {
    int v17 = 1;
  }
  else {
    int v17 = v4;
  }
  *(_DWORD *)(a1 + 144) = v4;
  *(_DWORD *)(a1 + 148) = v17;
  BOOL result = use_merged_upsample(a1);
  if (result) {
    int v19 = *(_DWORD *)(a1 + 420);
  }
  else {
    int v19 = 1;
  }
  *(_DWORD *)(a1 + 152) = v19;
  return result;
}

BOOL use_merged_upsample(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 400)
    && (*(_DWORD *)(a1 + 60) | 4) == 7
    && *(_DWORD *)(a1 + 56) == 3
    && *(_DWORD *)(a1 + 64) == 2
    && *(_DWORD *)(a1 + 144) == 3
    && !*(_DWORD *)(a1 + 396)
    && (int v2 = *(_DWORD **)(a1 + 304), v2[2] == 2)
    && v2[26] == 1
    && v2[50] == 1
    && (int)v2[3] <= 2
    && v2[27] == 1
    && v2[51] == 1
    && (int v3 = v2[9], v3 == *(_DWORD *)(a1 + 424))
    && v2[33] == v3
    && v2[57] == v3
    && (int v4 = v2[10], v4 == *(_DWORD *)(a1 + 428))
    && v2[34] == v4)
  {
    return v2[58] == v4;
  }
  else
  {
    return 0;
  }
}

uint64_t _cg_jinit_master_decompress(uint64_t a1)
{
  uint64_t v2 = (**(uint64_t (***)(void))(a1 + 8))();
  *(void *)(a1 + 57jp2_colour_converter::clear(this + 6) = v2;
  *(void *)uint64_t v2 = prepare_for_output_pass;
  *(void *)(v2 + 8) = finish_output_pass;
  *(_DWORD *)(v2 + 1jp2_colour_converter::clear(this + 6) = 0;
  int v3 = *(_DWORD *)(a1 + 296);
  if (v3 != 8)
  {
    int v4 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v4 + 10) = 16;
    *((_DWORD *)v4 + 12) = v3;
    (**(void (***)(uint64_t))a1)(a1);
  }
  _cg_jpeg_calc_output_dimensions(a1);
  int v5 = (_OWORD *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1280);
  uint64_t v6 = 0;
  *int v5 = 0u;
  v5[1] = 0u;
  _OWORD v5[2] = 0u;
  v5[3] = 0u;
  v5[4] = 0u;
  v5[5] = 0u;
  v5[6] = 0u;
  v5[7] = 0u;
  v5[8] = 0u;
  v5[9] = 0u;
  v5[10] = 0u;
  v5[11] = 0u;
  v5[12] = 0u;
  v5[13] = 0u;
  v5[14] = 0u;
  v5[15] = 0u;
  v5[16] = 0u;
  v5[17] = 0u;
  v5[18] = 0u;
  v5[19] = 0u;
  v5[20] = 0u;
  v5[21] = 0u;
  v5[22] = 0u;
  v5[23] = 0u;
  v5[24] = 0u;
  v5[25] = 0u;
  v5[26] = 0u;
  v5[27] = 0u;
  v5[28] = 0u;
  v5[29] = 0u;
  v5[30] = 0u;
  v5[31] = 0u;
  int8x16_t v7 = (int8x16_t)xmmword_18898F090;
  v8.i64[0] = 0x1010101010101010;
  v8.i64[1] = 0x1010101010101010;
  *(void *)(a1 + 440) = v5 + 32;
  do
  {
    v5[v6 + 32] = v7;
    ++v6;
    int8x16_t v7 = vaddq_s8(v7, v8);
  }
  while (v6 != 16);
  *(void *)&long long v9 = -1;
  *((void *)&v9 + 1) = -1;
  v5[79] = v9;
  v5[78] = v9;
  v5[77] = v9;
  v5[76] = v9;
  v5[75] = v9;
  v5[74] = v9;
  v5[73] = v9;
  v5[72] = v9;
  v5[71] = v9;
  v5[70] = v9;
  v5[69] = v9;
  v5[68] = v9;
  v5[67] = v9;
  v5[66] = v9;
  v5[65] = v9;
  v5[63] = v9;
  v5[64] = v9;
  v5[61] = v9;
  v5[62] = v9;
  v5[59] = v9;
  v5[60] = v9;
  v5[57] = v9;
  v5[58] = v9;
  v5[55] = v9;
  v5[56] = v9;
  v5[53] = v9;
  v5[54] = v9;
  v5[51] = v9;
  v5[52] = v9;
  v5[49] = v9;
  v5[50] = v9;
  v5[48] = v9;
  if (!*(_DWORD *)(a1 + 140) || (unsigned int v10 = *(_DWORD *)(a1 + 136)) == 0 || (v11 = *(_DWORD *)(a1 + 144), v11 <= 0))
  {
    int v12 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v12 + 10) = 33;
    (*v12)(a1);
    unsigned int v10 = *(_DWORD *)(a1 + 136);
    int v11 = *(_DWORD *)(a1 + 144);
  }
  if (((unint64_t)v10 * v11) >> 32)
  {
    int v13 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v13 + 10) = 72;
    (*v13)(a1);
  }
  *(_DWORD *)(v2 + 24) = 0;
  BOOL v14 = use_merged_upsample(a1);
  *(void *)(v2 + 32) = 0;
  *(_DWORD *)(v2 + 28) = v14;
  *(void *)(v2 + 40) = 0;
  if (*(_DWORD *)(a1 + 108))
  {
    if (!*(_DWORD *)(a1 + 88))
    {
      *(void *)(a1 + 128) = 0;
      *(_DWORD *)(a1 + 124) = 0;
    }
    if (*(_DWORD *)(a1 + 92))
    {
      int v15 = *(void (***)(uint64_t))a1;
      *((_DWORD *)v15 + 10) = 48;
      (*v15)(a1);
    }
    if (*(_DWORD *)(a1 + 144) == 3)
    {
      if (*(void *)(a1 + 160))
      {
        *(_DWORD *)(a1 + 128) = 1;
      }
      else if (*(_DWORD *)(a1 + 116))
      {
        *(_DWORD *)(a1 + 132) = 1;
      }
      else
      {
        *(_DWORD *)(a1 + 124) = 1;
      }
    }
    else
    {
      *(void *)(a1 + 124) = 1;
      *(_DWORD *)(a1 + 132) = 0;
      *(void *)(a1 + 160) = 0;
    }
    if (*(_DWORD *)(a1 + 124))
    {
      _cg_jinit_1pass_quantizer(a1);
      *(void *)(v2 + 32) = *(void *)(a1 + 656);
    }
    if (*(_DWORD *)(a1 + 132) || *(_DWORD *)(a1 + 128))
    {
      _cg_jinit_2pass_quantizer(a1);
      *(void *)(v2 + 40) = *(void *)(a1 + 656);
    }
  }
  else
  {
    *(void *)(a1 + 128) = 0;
    *(_DWORD *)(a1 + 124) = 0;
  }
  if (!*(_DWORD *)(a1 + 92))
  {
    if (*(_DWORD *)(v2 + 28))
    {
      _cg_jinit_merged_upsampler(a1);
    }
    else
    {
      _cg_jinit_color_deconverter(a1);
      _cg_jinit_upsampler((uint64_t *)a1);
    }
    _cg_jinit_d_post_controller(a1, *(_DWORD *)(a1 + 132));
  }
  _cg_jinit_inverse_dct(a1);
  if (*(_DWORD *)(a1 + 320)) {
    jinit_arith_decoder(a1);
  }
  else {
    _cg_jinit_huff_decoder(a1);
  }
  if (*(_DWORD *)(*(void *)(a1 + 608) + 32)) {
    BOOL v16 = 1;
  }
  else {
    BOOL v16 = *(_DWORD *)(a1 + 88) != 0;
  }
  _cg_jinit_d_coef_controller(a1, v16);
  if (!*(_DWORD *)(a1 + 92)) {
    _cg_jinit_d_main_controller((uint64_t *)a1, 0);
  }
  (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 48))(a1);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 608) + 16))(a1);
  uint64_t v18 = *(void *)(a1 + 16);
  if (v18 && !*(_DWORD *)(a1 + 88) && *(_DWORD *)(*(void *)(a1 + 608) + 32))
  {
    if (*(_DWORD *)(a1 + 316)) {
      int v19 = 3 * *(_DWORD *)(a1 + 56) + 2;
    }
    else {
      int v19 = *(_DWORD *)(a1 + 56);
    }
    uint64_t v20 = *(unsigned int *)(a1 + 432);
    *(void *)(v18 + 8) = 0;
    *(void *)(v18 + 1jp2_colour_converter::clear(this + 6) = v19 * v20;
    if (*(_DWORD *)(a1 + 132)) {
      int v21 = 3;
    }
    else {
      int v21 = 2;
    }
    *(_DWORD *)(v18 + 24) = 0;
    *(_DWORD *)(v18 + 28) = v21;
    ++*(_DWORD *)(v2 + 24);
  }
  return result;
}

uint64_t prepare_for_output_pass(uint64_t *a1)
{
  uint64_t v2 = a1[72];
  if (*(_DWORD *)(v2 + 16))
  {
    *(_DWORD *)(v2 + 1jp2_colour_converter::clear(this + 6) = 0;
    (*(void (**)(uint64_t *, void))a1[82])(a1, 0);
    uint64_t v3 = 2;
    (*(void (**)(uint64_t *, uint64_t))a1[75])(a1, 2);
LABEL_3:
    uint64_t result = (*(uint64_t (**)(uint64_t *, uint64_t))a1[73])(a1, v3);
    goto LABEL_7;
  }
  if (*((_DWORD *)a1 + 27) && !a1[20])
  {
    if (*((_DWORD *)a1 + 29) && *((_DWORD *)a1 + 33))
    {
      a1[82] = *(void *)(v2 + 40);
      *(_DWORD *)(v2 + 1jp2_colour_converter::clear(this + 6) = 1;
    }
    else if (*((_DWORD *)a1 + 31))
    {
      a1[82] = *(void *)(v2 + 32);
    }
    else
    {
      uint64_t v11 = *a1;
      *(_DWORD *)(v11 + 40) = 47;
      (*(void (**)(uint64_t *))v11)(a1);
    }
  }
  (*(void (**)(uint64_t *))a1[79])(a1);
  uint64_t result = (*(uint64_t (**)(uint64_t *))(a1[74] + 16))(a1);
  if (!*((_DWORD *)a1 + 23))
  {
    if (!*(_DWORD *)(v2 + 28)) {
      (*(void (**)(uint64_t *))a1[81])(a1);
    }
    (*(void (**)(uint64_t *))a1[80])(a1);
    if (*((_DWORD *)a1 + 27)) {
      (*(void (**)(uint64_t *, void))a1[82])(a1, *(unsigned int *)(v2 + 16));
    }
    if (*(_DWORD *)(v2 + 16)) {
      uint64_t v10 = 3;
    }
    else {
      uint64_t v10 = 0;
    }
    (*(void (**)(uint64_t *, uint64_t))a1[75])(a1, v10);
    uint64_t v3 = 0;
    goto LABEL_3;
  }
LABEL_7:
  uint64_t v5 = a1[2];
  if (v5)
  {
    int v6 = *(_DWORD *)(v2 + 24);
    int v7 = *(_DWORD *)(v2 + 16) ? 2 : 1;
    int v8 = v7 + v6;
    *(_DWORD *)(v5 + 24) = v6;
    *(_DWORD *)(v5 + 28) = v8;
    if (*((_DWORD *)a1 + 22))
    {
      if (!*(_DWORD *)(a1[76] + 36))
      {
        if (*((_DWORD *)a1 + 33)) {
          int v9 = 2;
        }
        else {
          int v9 = 1;
        }
        *(_DWORD *)(v5 + 28) = v9 + v8;
      }
    }
  }
  return result;
}

uint64_t finish_output_pass(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 576);
  if (*(_DWORD *)(result + 108)) {
    uint64_t result = (*(uint64_t (**)(void))(*(void *)(result + 656) + 16))();
  }
  ++*(_DWORD *)(v1 + 24);
  return result;
}

uint64_t _cg_jpeg_std_error(uint64_t result)
{
  *(void *)uint64_t result = error_exit;
  *(void *)(result + 8) = emit_message;
  *(void *)(result + 1jp2_colour_converter::clear(this + 6) = output_message;
  *(void *)(result + 24) = format_message;
  *(void *)(result + 32) = reset_error_mgr;
  *(_DWORD *)(result + 128) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(void *)(result + 13jp2_colour_converter::clear(this + 6) = 0;
  *(void *)(result + 144) = _cg_jpeg_std_message_table;
  *(_DWORD *)(result + 152) = 126;
  *(void *)(result + 160) = 0;
  *(void *)(result + 168) = 0;
  return result;
}

void error_exit(uint64_t a1)
{
}

uint64_t *emit_message(uint64_t *result, int a2)
{
  uint64_t v2 = *result;
  if (a2 < 0)
  {
    uint64_t v4 = *(void *)(v2 + 136);
    if (!v4 || *(int *)(v2 + 128) >= 3)
    {
      uint64_t result = (uint64_t *)(*(uint64_t (**)(void))(v2 + 16))();
      uint64_t v4 = *(void *)(v2 + 136);
    }
    *(void *)(v2 + 13jp2_colour_converter::clear(this + 6) = v4 + 1;
  }
  else if (*(_DWORD *)(v2 + 128) >= a2)
  {
    uint64_t v3 = *(uint64_t (**)(void))(v2 + 16);
    return (uint64_t *)v3();
  }
  return result;
}

uint64_t output_message(uint64_t a1)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = 0;
  memset(v2, 0, sizeof(v2));
  (*(void (**)(uint64_t, _OWORD *))(*(void *)a1 + 24))(a1, v2);
  return fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s\n", (const char *)v2);
}

uint64_t format_message(uint64_t *a1, char *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *(unsigned int *)(*a1 + 40);
  if ((int)v3 >= 1 && (int)v3 <= *(_DWORD *)(v2 + 152))
  {
    int v8 = (const char **)(*(void *)(v2 + 144) + 8 * v3);
  }
  else
  {
    uint64_t v4 = *(void *)(v2 + 160);
    if (!v4) {
      goto LABEL_9;
    }
    int v5 = *(_DWORD *)(v2 + 168);
    BOOL v6 = __OFSUB__(v3, v5);
    int v7 = v3 - v5;
    if (v7 < 0 != v6 || (int)v3 > *(_DWORD *)(v2 + 172)) {
      goto LABEL_9;
    }
    int v8 = (const char **)(v4 + 8 * v7);
  }
  int v9 = *v8;
  if (!v9)
  {
LABEL_9:
    *(_DWORD *)(v2 + 48) = v3;
    int v9 = **(const char ***)(v2 + 144);
  }
  uint64_t v10 = v9;
  while (1)
  {
    int v12 = *(unsigned __int8 *)v10++;
    int v11 = v12;
    if (!v12) {
      break;
    }
    if (v11 == 37)
    {
      if (*v10 == 115) {
        return sprintf(a2, v9, v2 + 48);
      }
      return sprintf(a2, v9, *(unsigned int *)(v2 + 48), *(unsigned int *)(v2 + 52), *(unsigned int *)(v2 + 56), *(unsigned int *)(v2 + 60), *(unsigned int *)(v2 + 64), *(unsigned int *)(v2 + 68), *(unsigned int *)(v2 + 72), *(unsigned int *)(v2 + 76));
    }
  }
  return sprintf(a2, v9, *(unsigned int *)(v2 + 48), *(unsigned int *)(v2 + 52), *(unsigned int *)(v2 + 56), *(unsigned int *)(v2 + 60), *(unsigned int *)(v2 + 64), *(unsigned int *)(v2 + 68), *(unsigned int *)(v2 + 72), *(unsigned int *)(v2 + 76));
}

uint64_t *reset_error_mgr(uint64_t *result)
{
  uint64_t v1 = *result;
  *(void *)(v1 + 13jp2_colour_converter::clear(this + 6) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  return result;
}

uint64_t _cg_jinit_downsampler(uint64_t *a1)
{
  uint64_t result = (*(uint64_t (**)(void))a1[1])();
  uint64_t v3 = result;
  a1[68] = result;
  *(void *)uint64_t result = start_pass_downsample;
  *(void *)(result + 8) = sep_downsample;
  *(_DWORD *)(result + 1jp2_colour_converter::clear(this + 6) = 0;
  if (*((_DWORD *)a1 + 75))
  {
    uint64_t v4 = *a1;
    *(_DWORD *)(v4 + 40) = 26;
    uint64_t result = (*(uint64_t (**)(uint64_t *))v4)(a1);
  }
  if (*((int *)a1 + 23) >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = v3 + 154;
    int v7 = (_DWORD *)(a1[13] + 40);
    int v8 = 1;
    while (1)
    {
      int v9 = *(v7 - 1) * *(v7 - 8);
      int v10 = *((_DWORD *)a1 + 90);
      int v11 = *v7 * *(v7 - 7) / *((_DWORD *)a1 + 91);
      int v12 = *((_DWORD *)a1 + 88);
      int v13 = *((_DWORD *)a1 + 89);
      *(_DWORD *)(v6 + 4 * v5 - 50) = v11;
      int v14 = v9 / v10;
      if (v12 == v14 && v13 == v11)
      {
        uint64_t v15 = v6 + 8 * v5;
        if (!*((_DWORD *)a1 + 77))
        {
          int v17 = fullsize_downsample;
          goto LABEL_24;
        }
        BOOL v16 = fullsize_smooth_downsample;
      }
      else
      {
        if (v12 == 2 * v14 && v13 == v11)
        {
          int v8 = 0;
          uint64_t v15 = v6 + 8 * v5;
          int v17 = h2v1_downsample;
LABEL_24:
          *(void *)(v15 - 130) = v17;
          goto LABEL_25;
        }
        if (v12 != 2 * v14 || v13 != 2 * v11)
        {
          int v19 = v12 / v14;
          if (v12 % v14 || (int v20 = v13 / v11, v13 % v11))
          {
            uint64_t v21 = *a1;
            *(_DWORD *)(v21 + 40) = 39;
            uint64_t result = (*(uint64_t (**)(uint64_t *))v21)(a1);
          }
          else
          {
            int v8 = 0;
            *(void *)(v6 + 8 * v5 - 130) = int_downsample;
            uint64_t v22 = (unsigned char *)(v6 + v5);
            *(v22 - 10) = v19;
            *uint64_t v22 = v20;
          }
          goto LABEL_25;
        }
        uint64_t v15 = v6 + 8 * v5;
        if (!*((_DWORD *)a1 + 77))
        {
          int v17 = h2v2_downsample;
          goto LABEL_24;
        }
        BOOL v16 = h2v2_smooth_downsample;
      }
      *(void *)(v15 - 130) = v16;
      *(_DWORD *)(v3 + 1jp2_colour_converter::clear(this + 6) = 1;
LABEL_25:
      v7 += 24;
      if (++v5 >= *((int *)a1 + 23))
      {
        if (*((_DWORD *)a1 + 77) && !v8)
        {
          uint64_t v23 = *a1;
          *(_DWORD *)(v23 + 40) = 101;
          int v24 = *(uint64_t (**)(uint64_t *, void))(v23 + 8);
          return v24(a1, 0);
        }
        return result;
      }
    }
  }
  return result;
}

uint64_t sep_downsample(uint64_t result, uint64_t a2, unsigned int a3, uint64_t a4, int a5)
{
  if (*(int *)(result + 92) >= 1)
  {
    uint64_t v8 = result;
    uint64_t v9 = 0;
    uint64_t v10 = *(void *)(result + 104);
    uint64_t v11 = a3;
    uint64_t v12 = *(void *)(result + 544) + 104;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v12 + 8 * v9 - 80))(v8, v10, *(void *)(a2 + 8 * v9) + 8 * v11, *(void *)(a4 + 8 * v9) + 8 * (*(_DWORD *)(v12 + 4 * v9) * a5));
      ++v9;
      v10 += 96;
    }
    while (v9 < *(int *)(v8 + 92));
  }
  return result;
}

unsigned __int8 *fullsize_smooth_downsample(unsigned __int8 *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = result;
  int v7 = *(_DWORD *)(a2 + 36) * *(_DWORD *)(a2 + 28);
  int v8 = *((_DWORD *)result + 89);
  uint64_t v9 = *((unsigned int *)result + 12);
  if (v8 >= -1 && v7 - (int)v9 >= 1)
  {
    uint64_t v11 = (uint64_t *)(a3 - 8);
    uint64_t v12 = (v8 + 2);
    do
    {
      uint64_t v13 = *v11++;
      uint64_t result = (unsigned __int8 *)memset((void *)(v13 + v9), *(unsigned __int8 *)(v13 + v9 - 1), (v7 + ~v9) + 1);
      --v12;
    }
    while (v12);
    int v8 = *((_DWORD *)v6 + 89);
  }
  if (v8 >= 1)
  {
    uint64_t v14 = 0;
    int v15 = *((_DWORD *)v6 + 77);
    int v16 = 0x10000 - (v15 << 9);
    int v17 = v15 << 6;
    do
    {
      uint64_t v18 = *(unsigned char **)(a4 + 8 * v14);
      int v19 = (void *)(a3 + 8 * v14);
      uint64_t result = (unsigned __int8 *)*(v19 - 1);
      ++v14;
      int v20 = *(unsigned __int8 **)(a3 + 8 * v14);
      int v21 = *(unsigned __int8 *)*v19;
      int v22 = *v20 + *result + v21;
      uint64_t v23 = (unsigned __int8 *)(*v19 + 1);
      int v24 = v20[1] + result[1] + *v23;
      *uint64_t v18 = ((v24 - v21 + 2 * v22) * v17 + v16 * v21 + 0x8000) >> 16;
      int v25 = v18 + 1;
      if (v7 != 2)
      {
        uint64_t v26 = 0;
        uint64_t v27 = v20 + 2;
        result += 2;
        do
        {
          int v28 = v24;
          int v24 = v27[v26] + result[v26] + v23[v26 + 1];
          v25[v26] = ((v22 + v28 - v23[v26] + v24) * v17 + v16 * v23[v26] + 0x8000) >> 16;
          ++v26;
          int v22 = v28;
        }
        while (v7 - 2 != v26);
        v25 += v26;
        v23 += v26;
        int v22 = v28;
      }
      *int v25 = ((v22 + 2 * v24 - *v23) * v17 + v16 * *v23 + 0x8000) >> 16;
    }
    while (v14 < *((int *)v6 + 89));
  }
  return result;
}

void *fullsize_downsample(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t v4 = (uint64_t *)a4;
  uint64_t result = _cg_jcopy_sample_rows(a3, 0, a4, 0, *(_DWORD *)(a1 + 356), *(unsigned int *)(a1 + 48));
  uint64_t v8 = *(unsigned int *)(a1 + 356);
  uint64_t v9 = *(unsigned int *)(a1 + 48);
  int v10 = *(_DWORD *)(a2 + 36) * *(_DWORD *)(a2 + 28);
  if ((int)v8 >= 1 && v10 - (int)v9 >= 1)
  {
    size_t v12 = (v10 + ~v9) + 1;
    do
    {
      uint64_t v13 = *v4++;
      uint64_t result = memset((void *)(v13 + v9), *(unsigned __int8 *)(v13 + v9 - 1), v12);
      --v8;
    }
    while (v8);
  }
  return result;
}

unsigned int *h2v1_downsample(unsigned int *result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6 = result;
  int v7 = *(_DWORD *)(a2 + 36) * *(_DWORD *)(a2 + 28);
  uint64_t v8 = result[89];
  uint64_t v9 = result[12];
  if ((int)v8 >= 1 && 2 * v7 - (int)v9 >= 1)
  {
    uint64_t v11 = a3;
    do
    {
      uint64_t v12 = *v11++;
      uint64_t result = (unsigned int *)memset((void *)(v12 + v9), *(unsigned __int8 *)(v12 + v9 - 1), (2 * v7 + ~v9) + 1);
      --v8;
    }
    while (v8);
    LODWORD(v8) = v6[89];
  }
  if ((int)v8 >= 1)
  {
    uint64_t v13 = 0;
    do
    {
      if (v7)
      {
        int v14 = 0;
        int v15 = (unsigned __int8 *)a3[v13];
        int v16 = *(unsigned char **)(a4 + 8 * v13);
        int v17 = v7;
        do
        {
          *v16++ = (v14 + *v15 + v15[1]) >> 1;
          v14 ^= 1u;
          v15 += 2;
          --v17;
        }
        while (v17);
        LODWORD(v8) = v6[89];
      }
      ++v13;
    }
    while (v13 < (int)v8);
  }
  return result;
}

unsigned int *h2v2_smooth_downsample(unsigned int *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = result;
  int v7 = *(_DWORD *)(a2 + 36) * *(_DWORD *)(a2 + 28);
  int v8 = result[89];
  uint64_t v9 = result[12];
  if (v8 >= -1 && 2 * v7 - (int)v9 >= 1)
  {
    uint64_t v11 = (uint64_t *)(a3 - 8);
    uint64_t v12 = (v8 + 2);
    do
    {
      uint64_t v13 = *v11++;
      uint64_t result = (unsigned int *)memset((void *)(v13 + v9), *(unsigned __int8 *)(v13 + v9 - 1), (2 * v7 + ~v9) + 1);
      --v12;
    }
    while (v12);
    int v8 = v6[89];
  }
  if (v8 >= 1)
  {
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    unsigned int v16 = v6[77];
    int v17 = -80 * v16 + 0x4000;
    int v18 = 16 * v16;
    do
    {
      int v19 = *(unsigned char **)(a4 + 8 * v15);
      int v21 = *(unsigned __int8 **)(a3 + 8 * v14 - 8);
      int v20 = *(unsigned __int8 **)(a3 + 8 * v14);
      int v22 = *(unsigned __int8 **)(a3 + ((8 * v14) | 8));
      v14 += 2;
      uint64_t v23 = *(unsigned __int8 **)(a3 + 8 * v14);
      int v24 = *v22 + *v20;
      int v25 = v24 + v20[1] + v22[1];
      int v26 = *v21;
      int v27 = *v23;
      int v28 = v20 + 2;
      uint64_t v29 = v22 + 2;
      int v30 = v24 + v26 + v21[1] + v27 + v23[1] + v20[2] + v22[2];
      uint64_t v31 = v21 + 2;
      int v32 = v23 + 2;
      *int v19 = ((v27 + v26 + v21[2] + v23[2] + 2 * v30) * v18 + v25 * v17 + 0x8000) >> 16;
      int v33 = v19 + 1;
      if (v7 != 2)
      {
        uint64_t v34 = 2;
        int v35 = v7 - 2;
        do
        {
          *v33++ = ((v21[v34 + 2]
                   + v21[v34 - 1]
                   + v23[v34 - 1]
                   + 2
                   * (v21[v34 + 1]
                    + v21[v34]
                    + v23[v34]
                    + v23[v34 + 1]
                    + v20[v34 - 1]
                    + v20[v34 + 2]
                    + v22[v34 - 1]
                    + v22[v34 + 2])
                   + v23[v34 + 2])
                  * v18
                  + (v20[v34 + 1] + v20[v34] + v22[v34] + v22[v34 + 1]) * v17
                  + 0x8000) >> 16;
          v34 += 2;
          --v35;
        }
        while (v35);
        int v32 = &v23[v34];
        uint64_t v31 = &v21[v34];
        uint64_t v29 = &v22[v34];
        int v28 = &v20[v34];
      }
      int v36 = v29[1] + v28[1];
      int v37 = v36 + *v28 + *v29;
      int v38 = v31[1];
      int v39 = v32[1];
      int v40 = v36 + *v31 + v38 + *v32 + v39 + *(v28 - 1) + *(v29 - 1);
      uint64_t result = (unsigned int *)*(v32 - 1);
      unsigned char *v33 = ((v39 + v38 + *(v31 - 1) + result + 2 * v40) * v18 + v37 * v17 + 0x8000) >> 16;
      ++v15;
    }
    while (v14 < (int)v6[89]);
  }
  return result;
}

unsigned int *h2v2_downsample(unsigned int *result, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6 = result;
  int v7 = *(_DWORD *)(a2 + 36) * *(_DWORD *)(a2 + 28);
  uint64_t v8 = result[89];
  uint64_t v9 = result[12];
  if ((int)v8 >= 1 && 2 * v7 - (int)v9 >= 1)
  {
    uint64_t v11 = a3;
    do
    {
      uint64_t v12 = *v11++;
      uint64_t result = (unsigned int *)memset((void *)(v12 + v9), *(unsigned __int8 *)(v12 + v9 - 1), (2 * v7 + ~v9) + 1);
      --v8;
    }
    while (v8);
    LODWORD(v8) = v6[89];
  }
  if ((int)v8 >= 1)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    do
    {
      if (v7)
      {
        uint64_t v15 = *(unsigned __int8 **)((char *)a3 + ((8 * v13) | 8));
        unsigned int v16 = (unsigned __int8 *)a3[v13];
        int v17 = *(unsigned char **)(a4 + 8 * v14);
        int v18 = 1;
        int v19 = v7;
        do
        {
          uint64_t result = (unsigned int *)v15[1];
          *v17++ = (v18 + *v16 + v16[1] + *v15 + result) >> 2;
          v18 ^= 3u;
          v16 += 2;
          v15 += 2;
          --v19;
        }
        while (v19);
        LODWORD(v8) = v6[89];
      }
      v13 += 2;
      ++v14;
    }
    while (v13 < (int)v8);
  }
  return result;
}

unsigned __int8 *int_downsample(unsigned __int8 *result, int *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v6 = result;
  int v7 = a2[9] * a2[7];
  uint64_t v8 = *((void *)result + 68) + a2[1];
  int v9 = *(unsigned __int8 *)(v8 + 144);
  uint64_t v10 = *(unsigned __int8 *)(v8 + 154);
  uint64_t v11 = *((unsigned int *)result + 89);
  uint64_t v12 = *((unsigned int *)result + 12);
  if ((int)v11 >= 1 && v7 * v9 - (int)v12 >= 1)
  {
    uint64_t v14 = a3;
    do
    {
      uint64_t v15 = *v14++;
      uint64_t result = (unsigned __int8 *)memset((void *)(v15 + v12), *(unsigned __int8 *)(v15 + v12 - 1), (v7 * v9 + ~v12) + 1);
      --v11;
    }
    while (v11);
    LODWORD(v11) = *((_DWORD *)v6 + 89);
  }
  if ((int)v11 >= 1)
  {
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    do
    {
      if (v7)
      {
        unsigned int v18 = 0;
        int v19 = 0;
        int v20 = *(unsigned char **)(a4 + 8 * v17);
        do
        {
          if (v10)
          {
            uint64_t v21 = 0;
            uint64_t v22 = 0;
            do
            {
              if (v9)
              {
                uint64_t result = (unsigned __int8 *)(a3[v21 + v16] + v18);
                int v23 = v9;
                do
                {
                  unsigned int v24 = *result++;
                  v22 += v24;
                  --v23;
                }
                while (v23);
              }
              ++v21;
            }
            while (v21 != v10);
          }
          else
          {
            uint64_t v22 = 0;
          }
          *v20++ = (v22 + ((v10 * v9) >> 1)) / (v10 * v9);
          ++v19;
          v18 += v9;
        }
        while (v19 != v7);
        LODWORD(v11) = *((_DWORD *)v6 + 89);
      }
      v16 += v10;
      ++v17;
    }
    while (v16 < (int)v11);
  }
  return result;
}

uint64_t Ktx2LoadLevelFace(int a1, int a2, int a3, int a4, int a5, size_t a6, void *__src, char *a8)
{
  if (!a8) {
    return 0;
  }
  uint64_t result = 0;
  if (!a2 && *(_DWORD *)a8 == a1)
  {
    uint64_t v11 = *(void **)(a8 + 4);
    if (v11)
    {
      if (*(void *)(a8 + 12) >= a6) {
        size_t v12 = a6;
      }
      else {
        size_t v12 = *(void *)(a8 + 12);
      }
      memcpy(v11, __src, v12);
      uint64_t result = 0;
      *(void *)(a8 + 20) = v12;
    }
    else
    {
      return 13;
    }
  }
  return result;
}

BOOL GetKtx2FormatInfo(int a1, void *a2)
{
  if (s_kFormatInfo[0] == a1)
  {
    unint64_t v2 = 0;
    BOOL result = 1;
LABEL_7:
    *a2 = &s_kFormatInfo[8 * v2 + 1];
  }
  else
  {
    unint64_t v4 = -1;
    uint64_t v5 = &dword_1E90FD270;
    while (v4 != 155)
    {
      int v6 = *v5;
      v5 += 8;
      ++v4;
      if (v6 == a1)
      {
        BOOL result = v4 < 0x9C;
        unint64_t v2 = v4 + 1;
        goto LABEL_7;
      }
    }
    return 0;
  }
  return result;
}

BOOL IsASTC(int a1)
{
  return (a1 - 157) < 0x1C || (a1 - 1000066000) < 0xE;
}

BOOL IsBCn(int a1)
{
  return (a1 - 131) < 0x10;
}

BOOL IsETC(int a1)
{
  return (a1 - 147) < 0xA;
}

BOOL IsPVRTC1(int a1)
{
  return (a1 & 0xFFFFFFFA) == 1000054000;
}

uint64_t Ktx2GetDataSize(int a1, int a2, int a3)
{
  if (s_kFormatInfo[0] == a1)
  {
    uint64_t v3 = 0;
LABEL_6:
    int v6 = &s_kFormatInfo[8 * v3];
    unint64_t v7 = (a2 + v6[3] - 1) / v6[3] * (unint64_t)((a3 + v6[4] - 1) / v6[4]);
    BOOL v8 = (v7 & 0xFFFFFFFF00000000) != 0;
    unint64_t v9 = v7 * (unint64_t)v6[5];
    if ((v7 & 0xFFFFFFFF00000000) == 0) {
      LODWORD(v7) = v9;
    }
    if ((v9 & 0xFFFFFFFF00000000) != 0 || v8) {
      return 0;
    }
    else {
      return v7;
    }
  }
  else
  {
    uint64_t v3 = 0;
    unint64_t v4 = &dword_1E90FD270;
    while (v3 != 156)
    {
      int v5 = *v4;
      v4 += 8;
      ++v3;
      if (v5 == a1) {
        goto LABEL_6;
      }
    }
    return 0;
  }
}

uint64_t CreateKTXTexture(IIOImageReadSession *this)
{
  uint64_t v5 = 0;
  memset(v4, 0, sizeof(v4));
  uint64_t v3 = 0;
  if (!CreateKtxStream((uint64_t)v4, this))
  {
    int v1 = ktxTexture2_CreateFromStream((uint64_t (**)(void, _OWORD *, uint64_t))v4, 0, &v3);
    if (v1) {
      _cg_jpeg_mem_term("CreateKTXTexture", 576, "*** ERROR: ktxTexture2_CreateFromStream failed to create ktxTexture2 [%d]\n", v1);
    }
  }
  return v3;
}

void IIO_Reader_ICO::createReadPlugin()
{
}

{
  operator new();
}

void sub_1886ED620(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4027E495FCLL);
  _Unwind_Resume(a1);
}

void sub_1886ED6C0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4027E495FCLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_ICO::getImageCount(IIO_Reader_ICO *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  if (a5) {
    *a5 = 0;
  }
  __int16 v9 = 0;
  int v8 = 0;
  uint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, &v8, 0, 6uLL);
  if (BytesAtOffset == 6) {
    uint64_t result = 0;
  }
  else {
    uint64_t result = 4294967246;
  }
  if (a5)
  {
    if (BytesAtOffset == 6)
    {
      uint64_t result = 0;
      *a5 = v9;
    }
  }
  return result;
}

uint64_t IIO_Reader_ICO::hasCustomImageCountProc(IIO_Reader_ICO *this)
{
  return 1;
}

void IIO_Reader_CUR::createReadPlugin()
{
}

{
  operator new();
}

void sub_1886ED7C8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4027E495FCLL);
  _Unwind_Resume(a1);
}

void sub_1886ED868(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C4027E495FCLL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_CUR::getImageCount(IIO_Reader_CUR *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(this);
  int v6 = *(uint64_t (**)(void))(*(void *)IIO_ReaderHandler::readerForType(ReaderHandler, 1229147936) + 32);

  return v6();
}

uint64_t IIO_Reader_CUR::hasCustomImageCountProc(IIO_Reader_CUR *this)
{
  return 1;
}

void IIO_Reader_LibJPEG::createReadPlugin()
{
}

{
  operator new();
}

void sub_1886ED980(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C406CE9806DLL);
  _Unwind_Resume(a1);
}

void sub_1886EDA3C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C406CE9806DLL);
  _Unwind_Resume(a1);
}

BOOL IIO_Reader_LibJPEG::testHeader(uint64_t a1, unsigned __int8 *a2)
{
  return *a2 == 255 && a2[1] == 216 && a2[2] == 255;
}

void IIO_Reader_LibJPEG::initImageAtOffset()
{
}

void sub_1886EDB3C(void *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C406CE9806DLL);
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1886EDB24);
}

uint64_t IIO_Reader_LibJPEG::initThumbnail(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  Source = (IIOImagePlus *)CGImageSourceGetSource(a2);
  Properties = (IIODictionary *)IIOImagePlus::getProperties(Source);
  uint64_t Session = CGImagePluginGetSession(a2);
  __int16 v9 = (IIOImageReadSession *)CGImageSourceGetSource(Session);
  unsigned int Size = IIOImageReadSession::getSize(v9);
  if (!Session) {
    return 4294967245;
  }
  unint64_t v11 = (unint64_t)Size;
  int v69 = 0;
  size_t v12 = IIOImageReadSession::retainBytePointer(v9, (const __CFData **)&v69, 0);
  uint64_t v13 = v12;
  if (v12)
  {
    unint64_t BytesAtOffset = v11;
    uint64_t v15 = (unsigned __int8 *)v12;
  }
  else
  {
    uint64_t v15 = (unsigned __int8 *)malloc_type_malloc(0x1000uLL, 0x84351B20uLL);
    unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(v9, v15, 0, 0x1000uLL);
  }
  if (BytesAtOffset < 0x1000 || *v15 != 255 || v15[1] != 216) {
    goto LABEL_18;
  }
  if (v11 - 10 <= 2)
  {
    _cg_jpeg_mem_term("initThumbnail", 133, "*** ERROR: bad APP marker offset (%ld)\n");
  }
  else
  {
    if (v15[2] == 255 && v15[3] == 224) {
      unint64_t v17 = __rev16(*((unsigned __int16 *)v15 + 2)) + 4;
    }
    else {
      unint64_t v17 = 2;
    }
    if (v17 < v11 - 10)
    {
      if (v15[v17] != 255 || v15[v17 + 1] != 225 || strncmp((const char *)&v15[v17 + 4], "Exif", 4uLL)) {
        goto LABEL_18;
      }
      unint64_t v21 = (unint64_t)&v15[BytesAtOffset];
      uint64_t v22 = &v15[v17 + 10];
      int v23 = *v22;
      if (v23 == 77)
      {
        if (v22[1] != 77 || v22[2]) {
          goto LABEL_75;
        }
        uint64_t v19 = 0;
        if (v22[3] != 42) {
          goto LABEL_45;
        }
      }
      else
      {
        if (v23 != 73 || v22[1] != 73 || v22[2] != 42) {
          goto LABEL_75;
        }
        uint64_t v19 = 0;
        if (v22[3])
        {
LABEL_45:
          uint64_t v20 = 0;
LABEL_76:
          unint64_t v18 = v17 + 10;
          goto LABEL_20;
        }
      }
      if ((unint64_t)(v22 + 8) > v21) {
        goto LABEL_45;
      }
      uint64_t v19 = 0;
      LODWORD(v24) = *((_DWORD *)v22 + 1);
      unsigned int v25 = bswap32(v24);
      unint64_t v24 = v23 == 77 ? v25 : v24;
      if (v24 < 8 || (unint64_t)__rev16(*(unsigned __int16 *)&v15[v17 + 2]) - 4 < v24) {
        goto LABEL_45;
      }
      int v26 = &v22[v24];
      int v27 = (unsigned __int16 *)(v26 + 2);
      if ((unint64_t)(v26 + 2) <= v21)
      {
        unsigned int v28 = *(unsigned __int16 *)v26;
        unsigned int v29 = bswap32(v28) >> 16;
        if (v23 == 77) {
          unsigned int v30 = v29;
        }
        else {
          unsigned int v30 = v28;
        }
        if ((BytesAtOffset - v17 - v24 - 12) / 0xC <= (unsigned __int16)v30) {
          goto LABEL_75;
        }
        if ((_WORD)v30)
        {
          int v65 = &v15[BytesAtOffset];
          int v64 = v23;
          do
          {
            if ((unint64_t)(v27 + 1) <= v21)
            {
              unsigned int v31 = *v27;
              unsigned int v32 = bswap32(v31) >> 16;
              if (v23 == 77) {
                LOWORD(v31) = v32;
              }
            }
            else
            {
              LOWORD(v31) = 0;
            }
            if ((unint64_t)(v27 + 2) <= v21)
            {
              unsigned int v33 = bswap32(v27[1]) >> 16;
              if (v23 != 77) {
                LOWORD(v3++*((_DWORD *)this + 3) = v27[1];
              }
            }
            else
            {
              LOWORD(v3++*((_DWORD *)this + 3) = 0;
            }
            if ((unint64_t)(v27 + 4) <= v21)
            {
              unsigned int v34 = *((_DWORD *)v27 + 1);
              __int16 v35 = bswap32(v34);
              if (v23 == 77) {
                LOWORD(v34) = v35;
              }
              if ((unsigned __int16)v31 == 274
                && (unsigned __int16)v33 == 3
                && (unsigned __int16)v34 == 1
                && (unint64_t)(v27 + 5) <= v21)
              {
                unsigned int v37 = v27[4];
                unsigned int v38 = bswap32(v37) >> 16;
                if (v23 == 77) {
                  LOWORD(v37) = v38;
                }
                if ((unsigned __int16)(v37 - 1) <= 7u)
                {
                  unsigned int v66 = v30;
                  int v39 = (unsigned __int16)v37;
                  IIONumber::IIONumber((IIONumber *)v68, (unsigned __int16)v37);
                  IIODictionary::setObjectForKey((uint64_t)Properties, (uint64_t)v68, @"Orientation");
                  IIONumber::~IIONumber((IIONumber *)v68);
                  IIONumber::IIONumber((IIONumber *)v67, v39);
                  IIODictionary::setObjectForKeyGroup(Properties, (uint64_t)v67, @"Orientation", @"{TIFF}");
                  IIONumber::~IIONumber((IIONumber *)v67);
                  int v23 = v64;
                  unint64_t v21 = (unint64_t)v65;
                  unsigned int v30 = v66;
                }
              }
            }
            --v30;
            v27 += 6;
          }
          while ((_WORD)v30);
        }
      }
      else if (BytesAtOffset - v17 - v24 - 12 < 0xC)
      {
LABEL_75:
        uint64_t v19 = 0;
        uint64_t v20 = 0;
        goto LABEL_76;
      }
      if ((unint64_t)(v27 + 2) <= v21)
      {
        unsigned int v40 = *(_DWORD *)v27;
        unsigned int v41 = bswap32(*(_DWORD *)v27);
        if (v23 == 77) {
          unsigned int v40 = v41;
        }
        unint64_t v18 = v17 + 10;
        if (!v40) {
          goto LABEL_19;
        }
        unint64_t v42 = v17 + 10 + v40;
        if (v69)
        {
          if (v11 <= v42 + 2) {
            goto LABEL_19;
          }
          uint64_t v15 = (unsigned __int8 *)v13 + v42;
          int64_t v43 = v11 - v42;
        }
        else
        {
          int v44 = v23;
          int64_t v43 = IIOImageReadSession::getBytesAtOffset(v9, v15, v42, 0x1000uLL);
          if ((unint64_t)v43 < 2) {
            goto LABEL_19;
          }
          int v23 = v44;
        }
        if (v43 >= 2)
        {
          unsigned int v45 = *(unsigned __int16 *)v15;
          unsigned int v46 = bswap32(v45) >> 16;
          if (v23 == 77) {
            unsigned int v45 = v46;
          }
          if ((v43 - 2) / 0xCuLL > (unsigned __int16)v45 && (unsigned __int16)v45 != 0)
          {
            uint64_t v48 = 0;
            uint64_t v20 = 0;
            uint64_t v19 = 0;
            unint64_t v49 = (unint64_t)&v15[v43];
            do
            {
              uint64_t v50 = &v15[v48];
              uint64_t v51 = &v15[v48 + 4];
              if ((unint64_t)v51 <= v49)
              {
                unsigned int v52 = *((unsigned __int16 *)v50 + 1);
                unsigned int v53 = bswap32(v52) >> 16;
                if (v23 == 77) {
                  LOWORD(v52) = v53;
                }
              }
              else
              {
                LOWORD(v52) = 0;
              }
              uint64_t v54 = (unsigned int *)(v50 + 6);
              if ((unint64_t)(v50 + 6) <= v49)
              {
                unsigned int v56 = *(unsigned __int16 *)v51;
                unsigned int v55 = bswap32(v56) >> 16;
                if (v23 != 77) {
                  LOWORD(v55) = v56;
                }
              }
              else
              {
                LOWORD(v55) = 0;
              }
              uint64_t v57 = (unsigned int *)&v15[v48 + 10];
              if ((unint64_t)v57 <= v49)
              {
                unsigned int v58 = *v54;
                __int16 v59 = bswap32(v58);
                if (v23 != 77) {
                  __int16 v59 = v58;
                }
                if ((unsigned __int16)v52 == 513 && (unsigned __int16)v55 == 4 && v59 == 1)
                {
                  if ((unint64_t)&v15[v48 + 14] <= v49)
                  {
                    unsigned int v60 = *v57;
                    unsigned int v62 = bswap32(v60);
                    if (v23 == 77) {
                      unsigned int v60 = v62;
                    }
                  }
                  else
                  {
                    unsigned int v60 = 0;
                  }
                  uint64_t v19 = v60;
                }
                else if ((unsigned __int16)v52 == 514 && (unsigned __int16)v55 == 4 && v59 == 1)
                {
                  if ((unint64_t)&v15[v48 + 14] <= v49)
                  {
                    unsigned int v61 = *v57;
                    unsigned int v63 = bswap32(v61);
                    if (v23 == 77) {
                      unsigned int v61 = v63;
                    }
                  }
                  else
                  {
                    unsigned int v61 = 0;
                  }
                  uint64_t v20 = v61;
                }
              }
              --v45;
              v48 += 12;
            }
            while ((_WORD)v45);
            goto LABEL_20;
          }
        }
        goto LABEL_19;
      }
      goto LABEL_75;
    }
    _cg_jpeg_mem_term("initThumbnail", 140, "*** ERROR: bad APP marker offset (%ld)\n");
  }
LABEL_18:
  unint64_t v18 = 0;
LABEL_19:
  uint64_t v19 = 0;
  uint64_t v20 = 0;
LABEL_20:
  if (v69) {
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)v9, v69);
  }
  else {
    free(v15);
  }
  uint64_t result = 4294967246;
  if (v19)
  {
    if (v20) {
      CGImagePluginInitThumbJPEGAtOffset(a2, (IIOImageReadSession *)(v19 + v18), v20, a4);
    }
  }
  return result;
}

void sub_1886EE1C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_LibJPEG::compareOptions(IIO_Reader_LibJPEG *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  memset(v17, 0, sizeof(v17));
  IIODictionary::IIODictionary((IIODictionary *)v17, a2);
  memset(v16, 0, sizeof(v16));
  IIODictionary::IIODictionary((IIODictionary *)v16, a3);
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v17, @"kCGImageSourceSubsampleFactor");
  unsigned int v5 = IIODictionary::getUint32ForKey((IIODictionary *)v16, @"kCGImageSourceSubsampleFactor");
  if (Uint32ForKey <= 1) {
    int v6 = 1;
  }
  else {
    int v6 = Uint32ForKey;
  }
  if (v5 <= 1) {
    int v7 = 1;
  }
  else {
    int v7 = v5;
  }
  if (v6 == v7
    && (BOOL v8 = IIODictionary::getBoolForKey((IIODictionary *)v17, @"kCGImageSourceUseCoreImage"),
        v8 == IIODictionary::getBoolForKey((IIODictionary *)v16, @"kCGImageSourceUseCoreImage"))
    && (CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey((IIODictionary *)v17, @"kCGImageSourceXMPSidecar"),
        CFDictionaryRef v10 = IIODictionary::getObjectForKey((IIODictionary *)v16, @"kCGImageSourceXMPSidecar"),
        (ObjectForKey != 0) == (v10 != 0))
    && (!ObjectForKey || !v10 || CFEqual(ObjectForKey, v10))
    && (int v11 = IIOSkipMetadata((IIODictionary *)v17), (v11 ^ 1 | IIOSkipMetadata((IIODictionary *)v16)) == 1)
    && (BOOL v12 = IIODictionary::getBoolForKey((IIODictionary *)v17, @"kCGImageSourceAddJPEGQualityInformation"),
        v12 == IIODictionary::getBoolForKey((IIODictionary *)v16, @"kCGImageSourceAddJPEGQualityInformation")))
  {
    BOOL BoolForKey = IIODictionary::getBoolForKey((IIODictionary *)v17, @"kCGImageSourceAddThumbnailInformation");
    uint64_t v13 = BoolForKey ^ IIODictionary::getBoolForKey((IIODictionary *)v16, @"kCGImageSourceAddThumbnailInformation") ^ 1u;
  }
  else
  {
    uint64_t v13 = 0;
  }
  IIODictionary::~IIODictionary((IIODictionary *)v16);
  IIODictionary::~IIODictionary((IIODictionary *)v17);
  return v13;
}

void sub_1886EE39C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

uint64_t IIO_Reader_LibJPEG::hasCustomCompareOptionsProc(IIO_Reader_LibJPEG *this)
{
  return 1;
}

uint64_t IIO_Reader_LibJPEG::hasCustomThumbnailProc(IIO_Reader_LibJPEG *this)
{
  return 1;
}

void IIOLogTypeMismatch(const void *a1, const char *a2, const char *a3)
{
  if (a1)
  {
    CFTypeID v5 = CFGetTypeID(a1);
    CFStringRef v6 = CFCopyTypeIDDescription(v5);
    if (v6)
    {
      CFStringRef v7 = v6;
      memset(v9, 0, sizeof(v9));
      IIOString::IIOString((IIOString *)v9, v6);
      BOOL v8 = (const char *)IIOString::utf8String((IIOString *)v9);
      LogError("IIOLogTypeMismatch", 30, "*** ERROR: %s() - bad parameter: expected '%s' -- got '%s'\n", a2, a3, v8);
      CFRelease(v7);
      IIOString::~IIOString((IIOString *)v9);
    }
  }
}

void sub_1886EE478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t IIONumber::uint8Num(CFNumberRef *this)
{
  unsigned __int8 valuePtr = 0;
  if (CFNumberGetValue(this[2], kCFNumberSInt8Type, &valuePtr)) {
    return valuePtr;
  }
  LogError("uint8Num", 286, "CFNumberGetValue/uint8Num failed\n");
  return 0;
}

uint64_t IIONumber::uint16Num(IIONumber *this)
{
  __int16 valuePtr = 0;
  CFNumberRef v2 = (const __CFNumber *)*((void *)this + 2);
  if (!v2) {
    goto LABEL_15;
  }
  if (!CFNumberGetValue(v2, kCFNumberSInt16Type, &valuePtr))
  {
    int v10 = 0;
    if (CFNumberGetValue(*((CFNumberRef *)this + 2), kCFNumberSInt32Type, &v10)) {
      LogError("uint16Num", 301, "CFNumberGetValue/uint16_t failed: %08X\n", v10);
    }
    if (!CFNumberGetValue(*((CFNumberRef *)this + 2), kCFNumberSInt32Type, &valuePtr))
    {
      uint64_t v9 = 0;
      if (CFNumberGetValue(*((CFNumberRef *)this + 2), kCFNumberLongType, &v9))
      {
        LOWORD(v++*((_DWORD *)this + 3) = v9;
        return (unsigned __int16)v3;
      }
      if (CFNumberIsFloatType(*((CFNumberRef *)this + 2)))
      {
        v8[0] = 0.0;
        if (CFNumberGetValue(*((CFNumberRef *)this + 2), kCFNumberDoubleType, v8)) {
          return (unsigned __int16)v8[0];
        }
      }
      CFTypeID v4 = CFGetTypeID(*((CFTypeRef *)this + 2));
      CFStringRef v5 = CFCopyTypeIDDescription(v4);
      if (v5)
      {
        memset(v8, 0, sizeof(v8));
        IIOString::IIOString((IIOString *)v8, v5);
        CFStringRef v6 = (const char *)IIOString::utf8String((IIOString *)v8);
        LogError("uint16Num", 320, "CFNumberGetValue/uint16_t failed - '%s'\n", v6);
        IIOString::~IIOString((IIOString *)v8);
      }
      else
      {
        LogError("uint16Num", 324, "CFNumberGetValue/uint16_t failed\n");
      }
LABEL_15:
      LOWORD(v++*((_DWORD *)this + 3) = 0;
      return (unsigned __int16)v3;
    }
  }
  LOWORD(v++*((_DWORD *)this + 3) = valuePtr;
  return (unsigned __int16)v3;
}

void sub_1886EE6B0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

float IIONumber::floatNum(IIONumber *this)
{
  float valuePtr = 0.0;
  CFNumberRef v2 = (const __CFNumber *)*((void *)this + 2);
  if (v2)
  {
    if (CFNumberGetValue(v2, kCFNumberFloatType, &valuePtr)) {
      return valuePtr;
    }
    CFNumberRef v4 = (const __CFNumber *)*((void *)this + 2);
    double v5 = 0.0;
    if (v4 && CFNumberGetValue(v4, kCFNumberDoubleType, &v5)) {
      return v5;
    }
  }
  else
  {
    double v5 = 0.0;
  }
  LogError("floatNum", 383, "CFNumberGetValue/float failed\n", *(void *)&v5);
  return 0.0;
}

double IIONumber::doubleNum(IIONumber *this)
{
  double valuePtr = 0.0;
  CFNumberRef v1 = (const __CFNumber *)*((void *)this + 2);
  if (v1 && CFNumberGetValue(v1, kCFNumberDoubleType, &valuePtr)) {
    return valuePtr;
  }
  LogError("doubleNum", 393, "CFNumberGetValue/double failed\n");
  return 0.0;
}

void IIOString::IIOString(IIOString *this, const __CFDictionary *a2, const __CFString *a3, ...)
{
  va_start(va, a3);
  *(void *)this = &unk_1ED4E5FF8;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = CFStringCreateWithFormatAndArguments((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, a3, va);
}

void *IIOString::IIOString(void *a1, int a2, CFIndex numBytes, UInt8 *bytes)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1ED4E5FF8;
  if (a2 == 2)
  {
    CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFDataRef v6 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, numBytes);
    a1[2] = CFStringCreateFromExternalRepresentation(v5, v6, 0x100u);
    CFRelease(v6);
  }
  else if (!a2)
  {
    a1[2] = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, numBytes, 0x600u, 0);
  }
  return a1;
}

const __CFString *IIOString::length(IIOString *this)
{
  CFStringRef result = (const __CFString *)*((void *)this + 2);
  if (result) {
    return (const __CFString *)CFStringGetLength(result);
  }
  return result;
}

const __CFArray *IIOArray::getObjectAtIndex(IIOArray *this, CFIndex a2)
{
  CFArrayRef result = (const __CFArray *)*((void *)this + 1);
  if (result) {
    return (const __CFArray *)CFArrayGetValueAtIndex(result, a2);
  }
  return result;
}

float IIOArray::getFloatAtIndex(IIOArray *this, CFIndex a2)
{
  CFArrayRef v2 = (const __CFArray *)*((void *)this + 1);
  if (!v2) {
    return 0.0;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(v2, a2);
  IIONumber::IIONumber((IIONumber *)v6, ValueAtIndex);
  float v4 = IIONumber::floatNum((IIONumber *)v6);
  IIONumber::~IIONumber((IIONumber *)v6);
  return v4;
}

void sub_1886EEA6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

double IIOArray::getDoubleAtIndex(IIOArray *this, CFIndex a2)
{
  CFArrayRef v2 = (const __CFArray *)*((void *)this + 1);
  if (!v2) {
    return 0.0;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(v2, a2);
  IIONumber::IIONumber((IIONumber *)v6, ValueAtIndex);
  double v4 = IIONumber::doubleNum((IIONumber *)v6);
  IIONumber::~IIONumber((IIONumber *)v6);
  return v4;
}

void sub_1886EEAE4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void IIODictionary::IIODictionary(IIODictionary *this, const IIODictionary *a2)
{
  *(void *)this = &unk_1ED4DFD78;
  CFDictionaryRef v3 = (const __CFDictionary *)*((void *)a2 + 1);
  if (v3) {
    CFMutableDictionaryRef MutableCopy = CFDictionaryCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, v3);
  }
  else {
    CFMutableDictionaryRef MutableCopy = 0;
  }
  *((void *)this + 1) = MutableCopy;
  *((unsigned char *)this + 1jp2_colour_converter::clear(this + 6) = MutableCopy != 0;
}

void IIODictionary::copy(IIODictionary *this)
{
}

void sub_1886EEC10(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIODictionary::getUint32ForKey(IIODictionary *this, const char *a2)
{
  IIOString::IIOString((IIOString *)v5, a2);
  CFDictionaryRef Uint32ForKey = IIODictionary::getUint32ForKey(this, v6);
  IIOString::~IIOString((IIOString *)v5);
  return Uint32ForKey;
}

void sub_1886EEC80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIODictionary::getUint64ForKey(IIODictionary *this, const char *a2)
{
  IIOString::IIOString((IIOString *)v5, a2);
  CFDictionaryRef Uint64ForKey = IIODictionary::getUint64ForKey(this, v6);
  IIOString::~IIOString((IIOString *)v5);
  return Uint64ForKey;
}

void sub_1886EECE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

double IIODictionary::getFloatForKeyGroup(IIODictionary *this, const __CFString *a2, const __CFString *a3)
{
  CFDictionaryRef GroupForKey = IIODictionary::getGroupForKey(this, a3, 0);
  if (!GroupForKey) {
    return 0.0;
  }
  Value = (IIODictionary *)CFDictionaryGetValue(GroupForKey, a2);

  *(float *)&double result = IIODictionary::getFloatFromValue(Value, (const __CFString *)Value);
  return result;
}

double IIODictionary::getDoubleForKeyGroup(IIODictionary *this, const __CFString *a2, const __CFString *a3)
{
  CFDictionaryRef GroupForKey = IIODictionary::getGroupForKey(this, a3, 0);
  if (!GroupForKey) {
    return 0.0;
  }
  Value = (IIODictionary *)CFDictionaryGetValue(GroupForKey, a2);

  return IIODictionary::getDoubleFromValue(Value, (const __CFString *)Value);
}

double IIODictionary::getDoubleFromRationalForKey(IIODictionary *this, const __CFString *a2)
{
  CFDictionaryRef v3 = (const __CFDictionary *)*((void *)this + 1);
  double v4 = 0.0;
  if (v3 && CFDictionaryContainsKey(v3, a2))
  {
    memset(v11, 0, sizeof(v11));
    CFDictionaryRef v6 = (const __CFDictionary *)*((void *)this + 1);
    if (v6) {
      Value = CFDictionaryGetValue(v6, a2);
    }
    else {
      Value = 0;
    }
    IIOArray::IIOArray((IIOArray *)v11, Value);
    double DoubleAtIndex = IIOArray::getDoubleAtIndex((IIOArray *)v11, 0);
    double v9 = IIOArray::getDoubleAtIndex((IIOArray *)v11, 1);
    if (v9 == 0.0) {
      double v4 = 0.0;
    }
    else {
      double v4 = DoubleAtIndex / v9;
    }
    IIOArray::~IIOArray((IIOArray *)v11);
  }
  return v4;
}

void sub_1886EEE58(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

const void *IIODictionary::getObjectForKey(IIODictionary *this, const char *a2)
{
  IIOString::IIOString((IIOString *)v6, a2);
  CFDictionaryRef v3 = (const __CFDictionary *)*((void *)this + 1);
  if (v3) {
    Value = CFDictionaryGetValue(v3, key);
  }
  else {
    Value = 0;
  }
  IIOString::~IIOString((IIOString *)v6);
  return Value;
}

void sub_1886EEEC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIODictionary::getObjectForKeyGroup(IIODictionary *this, const char *a2, const char *a3)
{
  IIOString::IIOString((IIOString *)v10, a2);
  CFStringRef v5 = v11;
  IIOString::IIOString((IIOString *)v8, a3);
  CFDictionaryRef ObjectForKeyGroup = IIODictionary::getObjectForKeyGroup(this, v5, v9);
  IIOString::~IIOString((IIOString *)v8);
  IIOString::~IIOString((IIOString *)v10);
  return ObjectForKeyGroup;
}

void sub_1886EEF50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

__CFArray *IIODictionary::getArrayObjectForPath(IIODictionary *this, const __CFString *a2)
{
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, @".");
  uint64_t v15 = 0;
  CFArrayRef theArray = 0;
  uint64_t v17 = 0;
  IIOArray::IIOArray((IIOArray *)&v15, ArrayBySeparatingStrings);
  if (theArray
    && (CFDictionaryRef v5 = (const __CFDictionary *)*((void *)this + 1), (Count = CFArrayGetCount(theArray)) != 0))
  {
    CFIndex v7 = 0;
    CFDictionaryRef Value = 0;
    uint64_t v9 = Count - 1;
    while (1)
    {
      if (theArray)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(theArray, v7);
        if (ValueAtIndex) {
          CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(v5, ValueAtIndex);
        }
      }
      if (!Value || v9 == v7) {
        break;
      }
      CFTypeID TypeID = CFDictionaryGetTypeID();
      ++v7;
      CFDictionaryRef v5 = Value;
      if (TypeID != CFGetTypeID(Value)) {
        goto LABEL_10;
      }
    }
  }
  else
  {
LABEL_10:
    CFDictionaryRef Value = 0;
  }
  CFRelease(ArrayBySeparatingStrings);
  if (Value)
  {
    CFTypeID v12 = CFGetTypeID(Value);
    if (v12 == CFArrayGetTypeID())
    {
      Mutable = Value;
    }
    else
    {
      Mutable = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
      CFArrayAppendValue(Mutable, Value);
      CFAutorelease(Mutable);
    }
  }
  else
  {
    Mutable = 0;
  }
  IIOArray::~IIOArray((IIOArray *)&v15);
  return Mutable;
}

void sub_1886EF0C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOArray::~IIOArray((IIOArray *)va);
  _Unwind_Resume(a1);
}

__CFArray *IIODictionary::getArrayObjectForPath(IIODictionary *this, const char *a2)
{
  IIOString::IIOString((IIOString *)v5, a2);
  ArrayObjectForPath = IIODictionary::getArrayObjectForPath(this, v6);
  IIOString::~IIOString((IIOString *)v5);
  return ArrayObjectForPath;
}

void sub_1886EF12C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

BOOL IIODictionary::getBoolForKey(IIODictionary *this, const char *a2)
{
  IIOString::IIOString((IIOString *)v5, a2);
  BOOL BoolForKey = IIODictionary::getBoolForKey(this, v6);
  IIOString::~IIOString((IIOString *)v5);
  return BoolForKey;
}

void sub_1886EF18C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIODictionary::getBoolForKeyGroup(IIODictionary *this, const __CFString *a2, const __CFString *a3)
{
  CFDictionaryRef result = IIODictionary::getGroupForKey(this, a3, 0);
  if (result)
  {
    CFDictionaryRef Value = (IIODictionary *)CFDictionaryGetValue(result, a2);
    return (const __CFDictionary *)IIODictionary::getBoolFromValue(Value, (const __CFString *)Value);
  }
  return result;
}

void IIODictionary::setObjectForKey(uint64_t a1, uint64_t a2, const char *a3)
{
  if (a3)
  {
    CFAllocatorRef v3 = *(__CFDictionary **)(a1 + 8);
    if (v3)
    {
      IIOString::IIOString((IIOString *)v5, a3);
      CFDictionarySetValue(v3, key, *(const void **)(a2 + 16));
      IIOString::~IIOString((IIOString *)v5);
    }
  }
}

void sub_1886EF250(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIODictionary::setObjectForKey(IIODictionary *this, const void *a2, const char *a3)
{
  if (a3)
  {
    CFAllocatorRef v3 = (__CFDictionary *)*((void *)this + 1);
    if (v3)
    {
      if (a2)
      {
        IIOString::IIOString((IIOString *)v5, a3);
        CFDictionarySetValue(v3, key, a2);
      }
      else
      {
        IIOString::IIOString((IIOString *)v5, a3);
        CFDictionaryRemoveValue(v3, key);
      }
      IIOString::~IIOString((IIOString *)v5);
    }
  }
}

void sub_1886EF2D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIODictionary::setObjectForKeyGroup(IIODictionary *this, const void *a2, const char *a3, const char *a4)
{
  if (a3)
  {
    if (a4)
    {
      if (*((void *)this + 1))
      {
        IIOString::IIOString((IIOString *)v8, a4);
        CFDictionaryRef GroupForKey = IIODictionary::getGroupForKey(this, (const __CFString *)key, 1);
        IIOString::~IIOString((IIOString *)v8);
        if (GroupForKey)
        {
          IIOString::IIOString((IIOString *)v8, a3);
          if (a2) {
            CFDictionarySetValue(GroupForKey, key, a2);
          }
          else {
            CFDictionaryRemoveValue(GroupForKey, key);
          }
          IIOString::~IIOString((IIOString *)v8);
        }
      }
    }
  }
}

void sub_1886EF3A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIODictionary::removeAllObjects(IIODictionary *this)
{
  uint64_t v1 = (__CFDictionary *)*((void *)this + 1);
  if (v1) {
    CFDictionaryRemoveAllValues(v1);
  }
}

void IIODictionary::appendDictionaryNoOverwrite(IIODictionary *this, const __CFDictionary **a2)
{
  CFArrayRef v2 = (__CFDictionary *)*((void *)this + 1);
  if (v2) {
    IIODictionaryAppendDictionary(v2, a2[1], 0);
  }
}

__CFArray *IIOArrayCreateDeepCopy(__CFArray *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t Count = CFArrayGetCount(a1);
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], Count, MEMORY[0x1E4F1D510]);
  if (Mutable)
  {
    double v4 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
    if (v4)
    {
      CFDictionaryRef v5 = v4;
      v14.location = 0;
      v14.size_t length = Count;
      CFArrayGetValues(a1, v14, v4);
      if (Count >= 1)
      {
        CFDictionaryRef v6 = v5;
        while (1)
        {
          CFTypeID v7 = CFGetTypeID(*v6);
          CFTypeID TypeID = CFDictionaryGetTypeID();
          CFTypeRef v9 = *v6;
          if (v7 == TypeID) {
            break;
          }
          CFTypeID v11 = CFGetTypeID(v9);
          if (v11 != CFArrayGetTypeID())
          {
            CFArrayAppendValue(Mutable, *v6);
            goto LABEL_13;
          }
          DeepCopy = (const void *)IIOArrayCreateDeepCopy((__CFArray *)*v6);
          if (DeepCopy) {
            goto LABEL_11;
          }
LABEL_13:
          ++v6;
          if (!--Count) {
            goto LABEL_14;
          }
        }
        DeepCopy = (const void *)IIODictionaryCreateDeepCopy((const __CFDictionary *)v9);
        if (!DeepCopy) {
          goto LABEL_13;
        }
LABEL_11:
        CFTypeID v12 = DeepCopy;
        CFArrayAppendValue(Mutable, DeepCopy);
        CFRelease(v12);
        goto LABEL_13;
      }
LABEL_14:
      free(v5);
    }
  }
  return Mutable;
}

void KTXWritePlugin::~KTXWritePlugin(KTXWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t KTXWritePlugin::writeKTXHeader(IIOImageWriteSession *this, unsigned int a2, unsigned int a3, int a4, unsigned int a5, char a6, int a7, int a8, int a9, int a10, char a11, char a12)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  long long v32 = 0u;
  long long v31 = 0u;
  __ptr[0] = 0xBB31312058544BABLL;
  __ptr[1] = 0x40302010A1A0A0DLL;
  int v27 = a7;
  int v28 = a8;
  int v29 = a9;
  int v30 = a10;
  if (a5 <= 4) {
    LODWORD(v31) = dword_18898F19C[a5];
  }
  *(void *)((char *)&v31 + 4) = __PAIR64__(a3, a2);
  *(void *)&long long v32 = 0x100000000;
  HIDWORD(v31) = a4;
  DWORD2(v32) = 1;
  *(_OWORD *)unsigned int v25 = *(_OWORD *)"KTXorientation";
  strcpy(&v25[15], "S=r,T=d");
  strcpy(v24, "ColorSpace_APPLE");
  v24[17] = a5 + 48;
  v24[18] = 0;
  int v18 = 19;
  int v19 = 23;
  strcpy(v23, "Compression_APPLE");
  strcpy(&v23[18], "APPL");
  long long v20 = xmmword_18898F140;
  char v21 = a6 + 48;
  char v22 = 0;
  if (a12) {
    char v13 = 52;
  }
  else {
    char v13 = 28;
  }
  int v16 = 18;
  int v17 = 23;
  int v15 = 0;
  if (a11) {
    v13 += 28;
  }
  HIDWORD(v32) = (v13 + 27) & 0xFC;
  if (IIOImageWriteSession::putBytes(this, __ptr, 0x40uLL) != 64) {
    return 4294967246;
  }
  IIOImageWriteSession::putBytes(this, &v19, 4uLL);
  IIOImageWriteSession::putBytes(this, v25, 0x17uLL);
  IIOImageWriteSession::putBytes(this, &v15, (24 - v19));
  if (a12)
  {
    IIOImageWriteSession::putBytes(this, &v18, 4uLL);
    IIOImageWriteSession::putBytes(this, v24, 0x13uLL);
    IIOImageWriteSession::putBytes(this, &v15, (20 - v18));
  }
  if (a11)
  {
    IIOImageWriteSession::putBytes(this, &v17, 4uLL);
    IIOImageWriteSession::putBytes(this, v23, 0x17uLL);
    IIOImageWriteSession::putBytes(this, &v15, (24 - v17));
  }
  IIOImageWriteSession::putBytes(this, &v16, 4uLL);
  IIOImageWriteSession::putBytes(this, &v20, 0x12uLL);
  IIOImageWriteSession::putBytes(this, &v15, (20 - v16));
  return 0;
}

uint64_t KTXWritePlugin::writeOneImage(KTXWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t KTXWritePlugin::writeOne(IIOImageWriteSession **this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  if (IIODictionary::containsKey(a3, @"kCGImagePropertyEncoder"))
  {
    CFDictionaryRef ObjectForKey = IIODictionary::getObjectForKey(a3, @"kCGImagePropertyEncoder");
    if (CFEqual(ObjectForKey, @"kCGImagePropertyPVREncoder"))
    {
      int v8 = 0;
      BOOL v9 = 0;
      int v10 = 1;
    }
    else if (CFEqual(ObjectForKey, @"kCGImagePropertyBCEncoder"))
    {
      int v10 = 0;
      BOOL v9 = 0;
      int v8 = 1;
    }
    else
    {
      int v8 = 0;
      int v10 = 0;
      BOOL v9 = CFEqual(ObjectForKey, @"kCGImagePropertyASTCEncoder") != 0;
    }
  }
  else
  {
    int v8 = 0;
    int v10 = 0;
    BOOL v9 = 0;
  }
  unsigned int v11 = IIOImageSource::count(a2);
  unsigned int v12 = IIO_Reader::testHeaderSize(a2);
  unsigned int v13 = v12;
  if (v9)
  {
    if ((gIIODebugFlags & 0x20000) != 0) {
      ImageIOLog("♦️  'KTX ' %d: writeOne saving image [ASTC] (%d x %d)\n", 222, v11, v12);
    }
    uint64_t v28 = 0;
    long long v26 = 0u;
    long long v27 = 0u;
    *(_OWORD *)uint64_t size = 0u;
    long long v25 = 0u;
    ASTCWritePlugin::ASTCWritePlugin((ASTCWritePlugin *)size, this[2], this[3], 1);
    uint64_t v14 = IIOWritePlugin::writeAll((IIOImageDestination **)size);
    ASTCWritePlugin::~ASTCWritePlugin((CommonASTCWritePlugin *)size, v15, v16);
    return v14;
  }
  if (v10)
  {
    if ((gIIODebugFlags & 0x20000) != 0) {
      ImageIOLog("♦️  'KTX ' %d: writeOne saving image [PVR] (%d x %d)\n", 228, v11, v12);
    }
    long long v25 = 0u;
    long long v26 = 0u;
    *(_OWORD *)uint64_t size = 0u;
    PVRWritePlugin::PVRWritePlugin((PVRWritePlugin *)size, this[2], this[3], 1);
    uint64_t v14 = IIOWritePlugin::writeAll((IIOImageDestination **)size);
    PVRWritePlugin::~PVRWritePlugin((PVRWritePlugin *)size);
    return v14;
  }
  if (v8)
  {
    if ((gIIODebugFlags & 0x20000) != 0) {
      ImageIOLog("♦️  'KTX ' %d: writeOne saving image [BC] (%d x %d)\n", 234, v11, v12);
    }
    uint64_t v28 = 0;
    long long v26 = 0u;
    long long v27 = 0u;
    *(_OWORD *)uint64_t size = 0u;
    long long v25 = 0u;
    BCWritePlugin::BCWritePlugin((BCWritePlugin *)size, this[2], this[3], 1);
    uint64_t v14 = IIOWritePlugin::writeAll((IIOImageDestination **)size);
    BCWritePlugin::~BCWritePlugin((BCWritePlugin *)size);
    return v14;
  }
  if ((gIIODebugFlags & 0x20000) != 0) {
    ImageIOLog("♦️  'KTX ' %d: writeOne saving image [uncompressed] (%d x %d)\n", 240, v11, v12);
  }
  unsigned int Error = _cg_GifLastError((uint64_t)a2);
  char AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a2);
  if (Error == 16) {
    int v20 = 5131;
  }
  else {
    int v20 = 5126;
  }
  if (Error == 16) {
    int v21 = 34842;
  }
  else {
    int v21 = 34836;
  }
  uint64_t v22 = KTXWritePlugin::writeKTXHeader(this[2], v11, v13, 0, 1u, AlphaInfo, v20, Error >> 3, 6408, v21, 0, 0);
  LODWORD(size[0]) = IIOImagePlus::sourceImageProvider(a2) * v13;
  IIOImageWriteSession::putBytes(this[2], size, 4uLL);
  int v23 = malloc_type_malloc(LODWORD(size[0]), 0xAA8CC375uLL);
  IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v23);
  IIOImageWriteSession::putBytes(this[2], v23, LODWORD(size[0]));
  free(v23);
  return v22;
}

void sub_1886EFAE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  BCWritePlugin::~BCWritePlugin((BCWritePlugin *)va);
  _Unwind_Resume(a1);
}

uint64_t KTXWritePlugin::WriteProc(KTXWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v9, this, a2, 1263818784);
  *(void *)&v9[0] = &unk_1ED4E2B30;
  uint64_t v5 = IIOWritePlugin::writeAll((IIOImageDestination **)v9);
  _cg_jpeg_mem_term(v9, v6, v7);
  return v5;
}

void sub_1886EFB9C(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t IIOFrameBufferCreateForBuffer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  if (IIOFrameBufferGetTypeID_onceToken != -1) {
    dispatch_once(&IIOFrameBufferGetTypeID_onceToken, &__block_literal_global_1);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v11 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 1jp2_colour_converter::clear(this + 6) = a1;
    *(void *)(Instance + 24) = a2;
    *(void *)(Instance + 32) = a3;
    *(void *)(Instance + 40) = a4;
    *(double *)(Instance + 48) = a5;
  }
  else
  {
    CFShow(@"Failed to allocate IIOFrameBufferRef");
  }
  return v11;
}

CFTypeRef IIOFrameBufferRetain(CFTypeRef cf)
{
  if (cf) {
    return CFRetain(cf);
  }
  return cf;
}

void IIOFrameBufferRelease(CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t IIOFrameBufferGetBuffer(uint64_t result)
{
  if (result) {
    return *(void *)(result + 16);
  }
  return result;
}

uint64_t IIOFrameBufferGetBufferSize(uint64_t result)
{
  if (result) {
    return *(void *)(result + 32);
  }
  return result;
}

uint64_t IIOFrameBufferGetFrameIndex(uint64_t a1)
{
  if (a1) {
    return *(void *)(a1 + 40);
  }
  else {
    return -1;
  }
}

double IIOFrameBufferGetDelayTime(uint64_t a1)
{
  if (a1) {
    return *(double *)(a1 + 48);
  }
  else {
    return 0.0;
  }
}

uint64_t IIOGIFFrameGetNumRowsDecoded(uint64_t result)
{
  if (result) {
    return *(void *)(result + 56);
  }
  return result;
}

uint64_t IIOGIFFrameSetNumRowsDecoded(uint64_t result, uint64_t a2)
{
  if (result) {
    *(void *)(result + 5jp2_colour_converter::clear(this + 6) = a2;
  }
  return result;
}

uint64_t IIOFrameBufferGetColorTable(uint64_t result)
{
  if (result) {
    return *(void *)(result + 64);
  }
  return result;
}

void *IIOFrameBufferSetColorTable(void *result, void *cf)
{
  if (result)
  {
    CFAllocatorRef v3 = result;
    CFDictionaryRef result = (void *)result[8];
    if (result != cf)
    {
      if (result) {
        CFRelease(result);
      }
      if (cf) {
        CFDictionaryRef result = CFRetain(cf);
      }
      else {
        CFDictionaryRef result = 0;
      }
      v3[8] = result;
    }
  }
  return result;
}

uint64_t __IIOFrameBufferGetTypeID_block_invoke()
{
  sIIOFrameBufferClass = 0;
  *(void *)algn_1EB2C0258 = "IIOFrameBuffer";
  qword_1EB2C0260 = (uint64_t)iioFrameBufInit;
  unk_1EB2C0268 = 0;
  qword_1EB2C0270 = (uint64_t)iioFrameBufFinalize;
  unk_1EB2C0278 = 0;
  qword_1EB2C0280 = 0;
  unk_1EB2C0288 = 0;
  qword_1EB2C0290 = (uint64_t)iioFrameBufCopyDebugDesc;
  uint64_t result = _CFRuntimeRegisterClass();
  sIIOFrameBufferID = result;
  return result;
}

double iioFrameBufInit(uint64_t a1)
{
  *(void *)(a1 + 64) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 1jp2_colour_converter::clear(this + 6) = 0u;
  return result;
}

double iioFrameBufFinalize(void *a1)
{
  CFAllocatorRef v3 = a1 + 2;
  unint64_t v2 = a1[2];
  if (v2) {
    _ImageIO_Free(v2, a1[3]);
  }
  double v4 = (const void *)a1[8];
  if (v4) {
    CFRelease(v4);
  }
  v3[6] = 0;
  double result = 0.0;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *(_OWORD *)CFAllocatorRef v3 = 0u;
  return result;
}

__CFString *iioFrameBufCopyDebugDesc(void *a1)
{
  Mutable = CFStringCreateMutable(0, 0);
  CFIndex v3 = CFGetRetainCount(a1);
  CFStringAppendFormat(Mutable, 0, @"IIOFrameBuffer %p retainCount: %d\n", a1, v3);
  CFStringAppendFormat(Mutable, 0, @"buffer = %p, bufferunsigned int Size = %ld, frameIndex = %ld, delayTime = %g\n", a1[2], a1[4], a1[5], a1[6]);
  return Mutable;
}

void PBMWritePlugin::~PBMWritePlugin(PBMWritePlugin *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t PBMWritePlugin::write_P1_ASCII(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("%s", "write_P1_ASCII");
  }
  size_t Width = CGImageGetWidth(image);
  size_t Height = CGImageGetHeight(image);
  unsigned int v7 = Height;
  int v16 = 0;
  asprintf(&v16, "P1\n# 1-bit pbm - black&white\n%ld %ld\n", Width, Height);
  if (!v16) {
    return 4294967246;
  }
  size_t v8 = strlen(v16);
  IIOImageWriteSession::putBytes(this[2], v16, v8);
  free(v16);
  *(void *)&v15.renderingIntent = 0;
  *(void *)&v15.bitsPerComponent = 0x800000008;
  CFStringRef v9 = (const __CFString *)*MEMORY[0x1E4F1DC00];
  *(void *)&v13[0] = &unk_1ED4DFD58;
  *((void *)&v13[0] + 1) = CGColorSpaceCreateWithName(v9);
  v15.colorSpace = (CGColorSpaceRef)*((void *)&v13[0] + 1);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)v13);
  memset(&v15.bitmapInfo, 0, 20);
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v13, image, &v15, 0);
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 0x40000000;
  _OWORD v11[2] = ___ZN14PBMWritePlugin14write_P1_ASCIIEP7CGImageP13IIODictionary_block_invoke;
  void v11[3] = &__block_descriptor_tmp_2;
  v11[4] = this;
  v11[5] = "%1d ";
  int v12 = 1;
  IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v13, 0, v7, 16, (uint64_t)v11);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v13);
  return 0;
}

void sub_1886F00D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

size_t ___ZN14PBMWritePlugin14write_P1_ASCIIEP7CGImageP13IIODictionary_block_invoke(size_t result, uint64_t a2, void *a3)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  if (a3[1])
  {
    size_t v4 = result;
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(result + 32);
    int v11 = 0;
    memset(__ptr, 0, sizeof(__ptr));
    while (!a3[2])
    {
      size_t v8 = 0;
LABEL_12:
      double result = IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v6 + 16), __ptr, v8);
      if ((unint64_t)++v5 >= a3[1]) {
        return result;
      }
    }
    uint64_t v7 = 0;
    size_t v8 = 0;
    uint64_t v9 = *a3 + a3[3] * v5;
    while (1)
    {
      double result = snprintf((char *)__ptr + v8, 100 - v8, *(const char **)(v4 + 40), *(unsigned __int8 *)(v9 + v7) < 0x81u);
      if ((int)result < 1) {
        break;
      }
      v8 += result;
      if (v8 > 100 - 5 * *(_DWORD *)(v4 + 48))
      {
        *((unsigned char *)__ptr + v8 - 1) = 10;
        IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v6 + 16), __ptr, v8);
        size_t v8 = 0;
      }
      if ((unint64_t)++v7 >= a3[2])
      {
        if (v8) {
          *((unsigned char *)__ptr + v8 - 1) = 10;
        }
        goto LABEL_12;
      }
    }
  }
  return result;
}

uint64_t PBMWritePlugin::write_P2_ASCII(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("%s", "write_P2_ASCII");
  }
  size_t Width = CGImageGetWidth(image);
  size_t Height = CGImageGetHeight(image);
  unsigned int BitsPerComponent = CGImageGetBitsPerComponent(image);
  int v19 = 0;
  if (BitsPerComponent <= 0xF) {
    uint32_t v8 = BitsPerComponent;
  }
  else {
    uint32_t v8 = 16;
  }
  if (BitsPerComponent <= 0xF) {
    int v9 = ~(-1 << BitsPerComponent);
  }
  else {
    int v9 = 0xFFFF;
  }
  asprintf(&v19, "P2\n# %d-bit pgm - grayscale\n%ld %ld\n%d\n", v8, Width, Height, v9);
  if (!v19) {
    return 4294967246;
  }
  size_t v10 = strlen(v19);
  IIOImageWriteSession::putBytes(this[2], v19, v10);
  free(v19);
  *(void *)&v18.renderingIntent = 0;
  v18.bitsPerComponent = v8;
  v18.bitsPerPixel = v8;
  CFStringRef v11 = (const __CFString *)*MEMORY[0x1E4F1DC00];
  *(void *)&v16[0] = &unk_1ED4DFD58;
  *((void *)&v16[0] + 1) = CGColorSpaceCreateWithName(v11);
  v18.colorSpace = (CGColorSpaceRef)*((void *)&v16[0] + 1);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)v16);
  memset(&v18.bitmapInfo, 0, 20);
  uint64_t v17 = 0;
  memset(v16, 0, sizeof(v16));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v16, image, &v18, 0);
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 0x40000000;
  unsigned int v13[2] = ___ZN14PBMWritePlugin14write_P2_ASCIIEP7CGImageP13IIODictionary_block_invoke;
  v13[3] = &__block_descriptor_tmp_7;
  v13[4] = this;
  v13[5] = "%3d ";
  uint32_t v14 = v8;
  int v15 = 1;
  IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v16, 0, Height, 16, (uint64_t)v13);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v16);
  return 0;
}

void sub_1886F0454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14PBMWritePlugin14write_P2_ASCIIEP7CGImageP13IIODictionary_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t result = IIOBitStream::CreateIIOBitStream(*(IIOBitStream **)a3, (void *)(*(void *)(a3 + 24) * *(void *)(a3 + 8)), "r", a4);
  if (result)
  {
    uint64_t v8 = result;
    int v15 = 0;
    memset(__ptr, 0, sizeof(__ptr));
    if (*(void *)(a3 + 8))
    {
      uint64_t v9 = 0;
      while (!*(void *)(a3 + 16))
      {
        size_t v11 = 0;
LABEL_14:
        IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v6 + 16), __ptr, v11);
        if ((unint64_t)++v9 >= *(void *)(a3 + 8)) {
          return (*(uint64_t (**)(uint64_t))(*(void *)v8 + 8))(v8);
        }
      }
      uint64_t v10 = 0;
      size_t v11 = 0;
      while (1)
      {
        unsigned int v13 = 0;
        if ((*(unsigned int (**)(uint64_t, void, unsigned int *))(*(void *)v8 + 24))(v8, *(unsigned __int16 *)(a1 + 48), &v13))
        {
          break;
        }
        int v12 = snprintf((char *)__ptr + v11, 100 - v11, *(const char **)(a1 + 40), v13);
        if (v12 < 1) {
          break;
        }
        v11 += v12;
        if (v11 > 100 - 5 * *(_DWORD *)(a1 + 52))
        {
          *((unsigned char *)__ptr + v11 - 1) = 10;
          IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v6 + 16), __ptr, v11);
          size_t v11 = 0;
        }
        if ((unint64_t)++v10 >= *(void *)(a3 + 16))
        {
          if (v11) {
            *((unsigned char *)__ptr + v11 - 1) = 10;
          }
          goto LABEL_14;
        }
      }
    }
    return (*(uint64_t (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  return result;
}

uint64_t PBMWritePlugin::write_P3_ASCII(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("%s", "write_P3_ASCII");
  }
  size_t Width = CGImageGetWidth(image);
  size_t Height = CGImageGetHeight(image);
  unsigned int BitsPerComponent = CGImageGetBitsPerComponent(image);
  int v19 = 0;
  if (BitsPerComponent <= 0xF) {
    uint32_t v8 = BitsPerComponent;
  }
  else {
    uint32_t v8 = 16;
  }
  if (BitsPerComponent <= 0xF) {
    int v9 = ~(-1 << BitsPerComponent);
  }
  else {
    int v9 = 0xFFFF;
  }
  asprintf(&v19, "P3\n# %d-bit ppm - RGB\n%ld %ld\n%d\n", v8, Width, Height, v9);
  if (!v19) {
    return 4294967246;
  }
  size_t v10 = strlen(v19);
  IIOImageWriteSession::putBytes(this[2], v19, v10);
  free(v19);
  *(void *)&v18.renderingIntent = 0;
  v18.bitsPerComponent = v8;
  v18.bitsPerPixel = 3 * v8;
  CFStringRef v11 = (const __CFString *)*MEMORY[0x1E4F1DC98];
  *(void *)&v16[0] = &unk_1ED4DFD58;
  *((void *)&v16[0] + 1) = CGColorSpaceCreateWithName(v11);
  v18.colorSpace = (CGColorSpaceRef)*((void *)&v16[0] + 1);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)v16);
  memset(&v18.bitmapInfo, 0, 20);
  uint64_t v17 = 0;
  memset(v16, 0, sizeof(v16));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v16, image, &v18, 0);
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 0x40000000;
  unsigned int v13[2] = ___ZN14PBMWritePlugin14write_P3_ASCIIEP7CGImageP13IIODictionary_block_invoke;
  v13[3] = &__block_descriptor_tmp_9;
  v13[4] = this;
  v13[5] = "%3d ";
  uint32_t v14 = v8;
  int v15 = 3;
  IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v16, 0, Height, 16, (uint64_t)v13);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v16);
  return 0;
}

void sub_1886F0844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN14PBMWritePlugin14write_P3_ASCIIEP7CGImageP13IIODictionary_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 32);
  int v17 = 0;
  memset(__ptr, 0, sizeof(__ptr));
  uint64_t result = IIOBitStream::CreateIIOBitStream(*(IIOBitStream **)a3, (void *)(*(void *)(a3 + 24) * *(void *)(a3 + 8)), "r", a4);
  uint64_t v8 = result;
  if (*(void *)(a3 + 8))
  {
    uint64_t v9 = 0;
    while (!*(void *)(a3 + 16))
    {
      size_t v11 = 0;
LABEL_16:
      uint64_t result = IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v6 + 16), __ptr, v11);
      if ((unint64_t)++v9 >= *(void *)(a3 + 8)) {
        goto LABEL_17;
      }
    }
    uint64_t v14 = v9;
    uint64_t v10 = 0;
    size_t v11 = 0;
LABEL_5:
    int v12 = 3;
    while (1)
    {
      unsigned int v15 = 0;
      if ((*(unsigned int (**)(uint64_t, void, unsigned int *))(*(void *)v8 + 24))(v8, *(unsigned __int16 *)(a1 + 48), &v15))
      {
        break;
      }
      int v13 = snprintf((char *)__ptr + v11, 100 - v11, *(const char **)(a1 + 40), v15);
      if (v13 < 1) {
        break;
      }
      v11 += v13;
      if (v11 > 100 - 5 * *(_DWORD *)(a1 + 52))
      {
        *((unsigned char *)__ptr + v11 - 1) = 10;
        IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(v6 + 16), __ptr, v11);
        size_t v11 = 0;
      }
      if (!--v12)
      {
        if ((unint64_t)++v10 < *(void *)(a3 + 16)) {
          goto LABEL_5;
        }
        if (v11) {
          *((unsigned char *)__ptr + v11 - 1) = 10;
        }
        uint64_t v9 = v14;
        goto LABEL_16;
      }
    }
  }
  else
  {
LABEL_17:
    if (!v8) {
      return result;
    }
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v8 + 8))(v8);
}

uint64_t PBMWritePlugin::write_P4_Binary(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("%s", "write_P4_Binary");
  }
  size_t Width = CGImageGetWidth(image);
  size_t Height = CGImageGetHeight(image);
  unsigned int v7 = Height;
  unsigned int v15 = 0;
  asprintf(&v15, "P4\n# 1-bit pbm - black&white\n%ld %ld\n", Width, Height);
  if (!v15) {
    return 4294967246;
  }
  size_t v8 = strlen(v15);
  IIOImageWriteSession::putBytes(this[2], v15, v8);
  free(v15);
  long long v16 = xmmword_18898F1E0;
  *(void *)&v14.renderingIntent = 0;
  *(void *)&v14.bitsPerComponent = 0x100000001;
  CFStringRef v9 = (const __CFString *)*MEMORY[0x1E4F1DC00];
  *(void *)&v12[0] = &unk_1ED4DFD58;
  *((void *)&v12[0] + 1) = CGColorSpaceCreateWithName(v9);
  v14.colorSpace = (CGColorSpaceRef)*((void *)&v12[0] + 1);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)v12);
  *(void *)&v14.bitmapInfo = 0;
  v14.decode = (const CGFloat *)&v16;
  v14.renderingIntent = kCGRenderingIntentDefault;
  uint64_t v13 = 0;
  memset(v12, 0, sizeof(v12));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v12, image, &v14, 0);
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 0x40000000;
  _OWORD v11[2] = ___ZN14PBMWritePlugin15write_P4_BinaryEP7CGImageP13IIODictionary_block_invoke;
  void v11[3] = &__block_descriptor_tmp_11;
  v11[4] = this;
  IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v12, 0, v7, 16, (uint64_t)v11);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v12);
  return 0;
}

void sub_1886F0C58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

size_t ___ZN14PBMWritePlugin15write_P4_BinaryEP7CGImageP13IIODictionary_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(*(void *)(a1 + 32) + 16), *(const void **)a3, *(void *)(a3 + 8) * *(void *)(a3 + 24));
}

uint64_t PBMWritePlugin::write_P5_Binary(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("%s", "write_P5_Binary");
  }
  size_t Width = CGImageGetWidth(image);
  size_t Height = CGImageGetHeight(image);
  unsigned int BitsPerComponent = CGImageGetBitsPerComponent(image);
  uint64_t v18 = 0;
  if (BitsPerComponent <= 0xF) {
    unsigned int v8 = BitsPerComponent;
  }
  else {
    unsigned int v8 = 16;
  }
  if (BitsPerComponent <= 0xF) {
    int v9 = ~(-1 << BitsPerComponent);
  }
  else {
    int v9 = 0xFFFF;
  }
  asprintf(&v18, "P5\n# %d-bit ppm - grayscale\n%ld %ld\n%d\n", v8, Width, Height, v9);
  if (!v18) {
    return 4294967246;
  }
  size_t v10 = strlen(v18);
  IIOImageWriteSession::putBytes(this[2], v18, v10);
  free(v18);
  *(void *)&v17.renderingIntent = 0;
  if (v8 <= 8) {
    uint32_t v11 = 8;
  }
  else {
    uint32_t v11 = 16;
  }
  v17.bitsPerComponent = v11;
  v17.bitsPerPixel = v11;
  CFStringRef v12 = (const __CFString *)*MEMORY[0x1E4F1DC00];
  *(void *)&v15[0] = &unk_1ED4DFD58;
  *((void *)&v15[0] + 1) = CGColorSpaceCreateWithName(v12);
  v17.colorSpace = (CGColorSpaceRef)*((void *)&v15[0] + 1);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)v15);
  memset(&v17.bitmapInfo, 0, 20);
  uint64_t v16 = 0;
  memset(v15, 0, sizeof(v15));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v15, image, &v17, 0);
  v14[0] = MEMORY[0x1E4F143A8];
  v14[1] = 0x40000000;
  v14[2] = ___ZN14PBMWritePlugin15write_P5_BinaryEP7CGImageP13IIODictionary_block_invoke;
  v14[3] = &__block_descriptor_tmp_13_0;
  v14[4] = this;
  IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v15, 0, Height, 16, (uint64_t)v14);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v15);
  return 0;
}

void sub_1886F0E94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

size_t ___ZN14PBMWritePlugin15write_P5_BinaryEP7CGImageP13IIODictionary_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(*(void *)(a1 + 32) + 16), *(const void **)a3, *(void *)(a3 + 8) * *(void *)(a3 + 24));
}

uint64_t PBMWritePlugin::write_P6_Binary(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  v20[6] = *MEMORY[0x1E4F143B8];
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("%s", "write_P6_Binary");
  }
  size_t Width = CGImageGetWidth(image);
  size_t Height = CGImageGetHeight(image);
  unsigned int BitsPerComponent = CGImageGetBitsPerComponent(image);
  unsigned int v8 = BitsPerComponent;
  int v19 = 0;
  if (BitsPerComponent <= 0xF) {
    unsigned int v9 = BitsPerComponent;
  }
  else {
    unsigned int v9 = 16;
  }
  if (BitsPerComponent <= 0xF) {
    unsigned int v10 = ~(-1 << BitsPerComponent);
  }
  else {
    unsigned int v10 = 0xFFFF;
  }
  asprintf(&v19, "P6\n# %d-bit ppm - RGB\n%ld %ld\n%d\n", v9, Width, Height, v10);
  if (!v19) {
    return 4294967246;
  }
  size_t v11 = strlen(v19);
  IIOImageWriteSession::putBytes(this[2], v19, v11);
  double v12 = (double)v10 / dbl_18898F1D0[v9 < 9];
  free(v19);
  v20[0] = 0;
  *(double *)&v20[1] = v12;
  _OWORD v20[2] = 0;
  *(double *)&v20[3] = v12;
  v20[4] = 0;
  *(double *)&v20[5] = v12;
  *(void *)&v18.renderingIntent = 0;
  *(int8x8_t *)&v18.bitsPerComponent = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v8 > 8), 0x1FuLL)), (int8x8_t)0x3000000010, (int8x8_t)0x1800000008);
  CFStringRef v13 = (const __CFString *)*MEMORY[0x1E4F1DC98];
  *(void *)&v16[0] = &unk_1ED4DFD58;
  *((void *)&v16[0] + 1) = CGColorSpaceCreateWithName(v13);
  v18.colorSpace = (CGColorSpaceRef)*((void *)&v16[0] + 1);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)v16);
  *(void *)&v18.bitmapInfo = 0;
  v18.decode = (const CGFloat *)v20;
  v18.renderingIntent = kCGRenderingIntentDefault;
  uint64_t v17 = 0;
  memset(v16, 0, sizeof(v16));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v16, image, &v18, 0);
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 0x40000000;
  v15[2] = ___ZN14PBMWritePlugin15write_P6_BinaryEP7CGImageP13IIODictionary_block_invoke;
  v15[3] = &__block_descriptor_tmp_15;
  v15[4] = this;
  IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v16, 0, Height, 16, (uint64_t)v15);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v16);
  return 0;
}

void sub_1886F1154(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

size_t ___ZN14PBMWritePlugin15write_P6_BinaryEP7CGImageP13IIODictionary_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(*(void *)(a1 + 32) + 16), *(const void **)a3, *(void *)(a3 + 8) * *(void *)(a3 + 24));
}

uint64_t PBMWritePlugin::write_Pf_Binary(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("%s", "write_Pf_Binary");
  }
  size_t Width = CGImageGetWidth(image);
  size_t Height = CGImageGetHeight(image);
  unsigned int v7 = Height;
  uint64_t v16 = 0;
  asprintf(&v16, "Pf\n%ld %ld\n-1\n", Width, Height);
  if (!v16) {
    return 4294967246;
  }
  size_t v8 = strlen(v16);
  IIOImageWriteSession::putBytes(this[2], v16, v8);
  free(v16);
  *(void *)&v15.renderingIntent = 0;
  *(void *)&v15.bitsPerComponent = 0x2000000020;
  CFStringRef v9 = (const __CFString *)*MEMORY[0x1E4F1DC00];
  *(void *)&v13[0] = &unk_1ED4DFD58;
  *((void *)&v13[0] + 1) = CGColorSpaceCreateWithName(v9);
  v15.colorSpace = (CGColorSpaceRef)*((void *)&v13[0] + 1);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)v13);
  v15.bitmapInfo = 8448;
  *(_OWORD *)&v15.version = 0uLL;
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v13, image, &v15, 0);
  v12[0] = MEMORY[0x1E4F143A8];
  v12[1] = 0x40000000;
  unsigned int v12[2] = ___ZN14PBMWritePlugin15write_Pf_BinaryEP7CGImageP13IIODictionary_block_invoke;
  v12[3] = &__block_descriptor_tmp_17;
  v12[4] = this;
  uint64_t v10 = IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v13, 0, v7, 16, (uint64_t)v12);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v13);
  return v10;
}

void sub_1886F1368(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

size_t ___ZN14PBMWritePlugin15write_Pf_BinaryEP7CGImageP13IIODictionary_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(*(void *)(a1 + 32) + 16), *(const void **)a3, *(void *)(a3 + 8) * *(void *)(a3 + 24));
}

uint64_t PBMWritePlugin::write_PF_Binary(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3)
{
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("%s", "write_PF_Binary");
  }
  size_t Width = CGImageGetWidth(image);
  size_t Height = CGImageGetHeight(image);
  unsigned int v7 = Height;
  vImage_CGImageFormat v15 = 0;
  asprintf(&v15, "PF\n%ld %ld\n-1\n", Width, Height);
  if (v15)
  {
    size_t v8 = strlen(v15);
    IIOImageWriteSession::putBytes(this[2], v15, v8);
    free(v15);
    *(void *)&v14.renderingIntent = 0;
    *(void *)&v14.bitsPerComponent = 0x6000000020;
    CFStringRef v9 = (const __CFString *)*MEMORY[0x1E4F1DC98];
    *(void *)&v12[0] = &unk_1ED4DFD58;
    *((void *)&v12[0] + 1) = CGColorSpaceCreateWithName(v9);
    v14.colorSpace = (CGColorSpaceRef)*((void *)&v12[0] + 1);
    IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)v12);
    v14.bitmapInfo = 8448;
    *(_OWORD *)&v14.version = 0uLL;
    uint64_t v13 = 0;
    memset(v12, 0, sizeof(v12));
    IIOPixelProvider::IIOPixelProvider((IIOPixelProvider *)v12, image, &v14, 0);
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 0x40000000;
    _OWORD v11[2] = ___ZN14PBMWritePlugin15write_PF_BinaryEP7CGImageP13IIODictionary_block_invoke;
    void v11[3] = &__block_descriptor_tmp_19_0;
    v11[4] = this;
    IIOPixelProvider::iterateOverImage((IIOPixelProvider *)v12, 0, v7, 16, (uint64_t)v11);
    IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)v12);
  }
  return 0;
}

void sub_1886F156C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  IIOPixelProvider::~IIOPixelProvider((IIOPixelProvider *)va);
  _Unwind_Resume(a1);
}

size_t ___ZN14PBMWritePlugin15write_PF_BinaryEP7CGImageP13IIODictionary_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return IIOImageWriteSession::putBytes(*(IIOImageWriteSession **)(*(void *)(a1 + 32) + 16), *(const void **)a3, *(void *)(a3 + 8) * *(void *)(a3 + 24));
}

uint64_t PBMWritePlugin::writeOneImage(IIOImageWriteSession **this, CGImageRef image, IIODictionary *a3, IIODictionary *a4)
{
  __int16 BitmapInfo = CGImageGetBitmapInfo(image);
  ColorSpace = CGImageGetColorSpace(image);
  CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
  unsigned int BitsPerComponent = CGImageGetBitsPerComponent(image);
  if (IIODictionary::containsKey(a3, @"kCGImageDestinationOptimizeForSize"))
  {
    BOOL BoolForKey = IIODictionary::getBoolForKey(a3, @"kCGImageDestinationOptimizeForSize");
    if ((BitmapInfo & 0x100) != 0) {
      goto LABEL_3;
    }
  }
  else
  {
    BOOL BoolForKey = BitsPerComponent > 8;
    if ((BitmapInfo & 0x100) != 0)
    {
LABEL_3:
      if (Model)
      {
        PBMWritePlugin::write_PF_Binary(this, image, v11);
        return 0;
      }
      else
      {
        return PBMWritePlugin::write_Pf_Binary(this, image, v11);
      }
    }
  }
  BOOL v15 = BitsPerComponent == 1 && Model == kCGColorSpaceModelMonochrome;
  if (BoolForKey)
  {
    if (v15)
    {
      return PBMWritePlugin::write_P4_Binary(this, image, v11);
    }
    else if (Model)
    {
      return PBMWritePlugin::write_P6_Binary(this, image, v11);
    }
    else
    {
      return PBMWritePlugin::write_P5_Binary(this, image, v11);
    }
  }
  else if (v15)
  {
    return PBMWritePlugin::write_P1_ASCII(this, image, v11);
  }
  else if (Model)
  {
    return PBMWritePlugin::write_P3_ASCII(this, image, v11);
  }
  else
  {
    return PBMWritePlugin::write_P2_ASCII(this, image, v11);
  }
}

uint64_t PBMWritePlugin::WriteProc(PBMWritePlugin *this, IIOImageDestination *a2, void *a3, void *a4, void *a5)
{
  uint64_t v10 = 0;
  memset(v9, 0, sizeof(v9));
  IIOWritePlugin::IIOWritePlugin((IIOWritePlugin *)v9, this, a2, 1346522400);
  *(void *)&v9[0] = &unk_1ED4E2BA8;
  uint64_t v5 = IIOWritePlugin::writeAll((IIOImageDestination **)v9);
  _cg_jpeg_mem_term(v9, v6, v7);
  return v5;
}

void sub_1886F1814(void *a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t IIOCreateDataWithContentsOfURL(void *a1)
{
  uint64_t v4 = 0;
  uint64_t v2 = [objc_alloc(MEMORY[0x1E4F1C9B8]) initWithContentsOfURL:a1 options:0 error:&v4];
  if (!v2 && (v4 || IIO_OSAppleInternalBuild()))
  {
    NSLog(&cfstr_ErrorCannotGet_1.isa, a1);
    NSLog(&cfstr_Error.isa, v4);
    NSLog(&cfstr_IsfileurlD.isa, [a1 isFileURL]);
    NSLog(&cfstr_Isfilereferenc.isa, [a1 isFileReferenceURL]);
    NSLog(&cfstr_IsproxyD.isa, [a1 isProxy]);
  }
  return v2;
}

uint64_t IIOIsAppSuspended()
{
  if (IIOIsAppSuspended::once != -1) {
    dispatch_once(&IIOIsAppSuspended::once, &__block_literal_global_2);
  }
  uint64_t v0 = (void *)gSharedApp;
  if (!gSharedApp) {
    return 1;
  }

  return (uint64_t)objc_msgSend(v0, sel_isSuspended);
}

Class __IIOIsAppSuspended_block_invoke()
{
  Class result = NSClassFromString(&cfstr_Uiapplication.isa);
  if (result)
  {
    Class result = (Class)[(objc_class *)result sharedApplication];
    gSharedApp = (uint64_t)result;
  }
  return result;
}

uint64_t RGBColorType::compare(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unsigned int v2 = a1[1];
  unsigned int v3 = a2[1];
  if (v2 > v3) {
    return 1;
  }
  if (v2 < v3) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v4 = *a1;
  unsigned int v5 = *a2;
  if (v4 > v5) {
    return 1;
  }
  if (v4 < v5) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = a1[2];
  unsigned int v8 = a2[2];
  BOOL v9 = v7 > v8;
  if (v7 >= v8) {
    unsigned int v10 = 0;
  }
  else {
    unsigned int v10 = -1;
  }
  if (v9) {
    return 1;
  }
  else {
    return v10;
  }
}

BOOL RGBColorType::isCloseTo(unsigned __int8 *a1, unsigned __int8 *a2)
{
  int v2 = *a1 - *a2;
  if (v2 < 0) {
    int v2 = *a2 - *a1;
  }
  if (v2 > 4) {
    return 0;
  }
  int v3 = a1[1] - a2[1];
  if (v3 < 0) {
    int v3 = a2[1] - a1[1];
  }
  if (v3 > 4) {
    return 0;
  }
  int v4 = a1[2] - a2[2];
  if (v4 < 0) {
    int v4 = a2[2] - a1[2];
  }
  return v4 < 5;
}

BOOL RGBColorMap::equalTo(void *a1, void *a2)
{
  uint64_t v2 = *(unsigned int *)a1;
  if (*a1 != *a2) {
    return 0;
  }
  if ((int)v2 < 1) {
    return 1;
  }
  int v3 = (unsigned __int8 *)a1[2];
  int v4 = (unsigned __int8 *)a2[2];
  uint64_t v5 = v2 - 1;
  do
  {
    int v6 = RGBColorType::compare(v3, v4);
    BOOL result = v6 == 0;
    BOOL v9 = v5-- != 0;
    if (v6) {
      break;
    }
    v4 += 3;
    v3 += 3;
  }
  while (v9);
  return result;
}

void ColorQuantization::ColorQuantization(ColorQuantization *this)
{
  *(void *)this = &unk_1ED4E4048;
}

void ColorQuantization::~ColorQuantization(ColorQuantization *this)
{
}

uint64_t ColorQuantization::hist3d(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, int a8, uint64_t *a9)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  int v15 = a8 - 1;
  if ((a8 - 1) > 5)
  {
    uint64_t v53 = 2;
    uint64_t v54 = 0;
    uint64_t v16 = 1;
    uint64_t v17 = 3;
  }
  else
  {
    uint64_t v16 = qword_18898F270[v15];
    uint64_t v53 = qword_18898F2A0[v15];
    uint64_t v54 = qword_18898F240[v15];
    uint64_t v17 = 4;
  }
  bzero(v55, 0x400uLL);
  for (uint64_t i = 0; i != 256; ++i)
    v55[i] = i * i;
  unint64_t v19 = a7[1];
  if (v19)
  {
    uint64_t v20 = 0;
    int v21 = 0;
    uint64_t v22 = *a7 + v54;
    unint64_t v24 = a7[2];
    uint64_t v23 = a7[3];
    uint64_t v25 = *a7 + v16;
    uint64_t v26 = *a7 + v53;
    do
    {
      if (v24)
      {
        uint64_t v27 = 0;
        uint64_t v28 = 0;
        uint64_t v29 = a9[5] + 2 * v21;
        do
        {
          uint64_t v30 = *(unsigned __int8 *)(v25 + v28);
          uint64_t v31 = *(unsigned __int8 *)(v22 + v28);
          uint64_t v32 = *(unsigned __int8 *)(v26 + v28);
          unsigned int v33 = (v30 >> 3)
              + 1
              + 1089 * (v31 >> 3)
              + 32 * ((v30 >> 3) + 1)
              + (v32 >> 3)
              + 1090;
          *(_WORD *)(v29 + 2 * v27) = (v30 >> 3)
                                    + 1
                                    + 1089 * (v31 >> 3)
                                    + 32 * ((v30 >> 3) + 1)
                                    + (v32 >> 3)
                                    + 1090;
          ++a2[v33];
          *(void *)(a3 + 8 * v33) += v31;
          *(void *)(a4 + 8 * v33) += v30;
          LODWORD(v31) = v55[v31];
          uint64_t v34 = *(void *)(a5 + 8 * v33) + v32;
          LODWORD(v30) = v55[v30];
          LODWORD(v32) = v55[v32];
          *(void *)(a5 + 8 * v3++*((_DWORD *)this + 3) = v34;
          v28 += v17;
          ++v27;
          *(double *)(a6 + 8 * v3++*((_DWORD *)this + 3) = *(double *)(a6 + 8 * v33) + (double)((int)v30 + (int)v31 + (int)v32);
        }
        while (v24 > v27);
        v21 += v27;
      }
      ++v20;
      v22 += v23;
      v25 += v23;
      v26 += v23;
    }
    while (v19 > v20);
  }
  uint64_t v35 = 0;
  uint64_t v36 = 35937;
  do
  {
    uint64_t v38 = *a2++;
    uint64_t v37 = v38;
    if (v38 > v35) {
      uint64_t v35 = v37;
    }
    --v36;
  }
  while (v36);
  uint64_t result = 0;
  uint64_t v40 = v35 + 1;
  uint64_t v41 = a9[2];
  uint64_t v42 = a9[3];
  uint64_t v43 = a9[4];
  char v44 = 1;
  uint64_t v46 = *a9;
  uint64_t v45 = a9[1];
  do
  {
    int v47 = (unsigned __int8 *)&unk_18898F220 + 3 * result;
    uint64_t v48 = *v47;
    uint64_t v49 = v47[1];
    uint64_t v50 = v47[2];
    unsigned int v51 = (v49 >> 3)
        + 1
        + 1089 * (v48 >> 3)
        + 32 * ((v49 >> 3) + 1)
        + (v50 >> 3)
        + 1090;
    *(void *)(v45 + 8 * v51) = v40;
    *(void *)(v41 + 8 * v51) = v40 * v48;
    *(void *)(v42 + 8 * v51) = v40 * v49;
    *(void *)(v43 + 8 * v51) = v40 * v50;
    double v52 = (double)(v55[v49] + v55[v48] + v55[v50]);
    LOBYTE(v48) = v44;
    *(double *)(v46 + 8 * v51) = (double)v40 * v52;
    uint64_t result = 1;
    char v44 = 0;
  }
  while ((v48 & 1) != 0);
  return result;
}

uint64_t *ColorQuantization::m3d(ColorQuantization *this, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, double *a6)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  int v6 = 1;
  do
  {
    int v26 = v6;
    uint64_t v29 = 0;
    *((void *)&v28[0] + 1) = 0;
    memset(&v28[1], 0, 240);
    uint64_t v31 = 0;
    memset(v30, 0, sizeof(v30));
    uint64_t v33 = 0;
    memset(v32, 0, sizeof(v32));
    uint64_t v35 = 0;
    memset(v34, 0, sizeof(v34));
    uint64_t v37 = 0;
    int v7 = 1;
    uint64_t v27 = a6;
    unsigned int v8 = a6;
    BOOL v9 = a5;
    uint64_t result = a4;
    size_t v11 = a3;
    double v12 = a2;
    memset(v36, 0, sizeof(v36));
    do
    {
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      uint64_t v15 = 0;
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      double v18 = 0.0;
      do
      {
        v17 += v12[v13 + 1123];
        v16 += v11[v13 + 1123];
        v15 += result[v13 + 1123];
        uint64_t v19 = v9[v13 + 1123];
        uint64_t v20 = *(void *)((char *)v36 + v13 * 8 + 8) + v17;
        *(void *)((char *)v36 + v13 * 8 + 8) = v20;
        v14 += v19;
        uint64_t v21 = *(void *)((char *)v34 + v13 * 8 + 8) + v16;
        *(void *)((char *)v34 + v13 * 8 + 8) = v21;
        uint64_t v22 = *(void *)((char *)v32 + v13 * 8 + 8) + v15;
        *(void *)((char *)v32 + v13 * 8 + 8) = v22;
        double v23 = v8[v13 + 1123];
        uint64_t v24 = *(void *)((char *)v30 + v13 * 8 + 8) + v14;
        *(void *)((char *)v30 + v13 * 8 + 8) = v24;
        double v18 = v18 + v23;
        double v25 = v18 + *(double *)((char *)v28 + v13 * 8 + 8);
        *(double *)((char *)v28 + v13 * 8 + 8) = v25;
        v12[v13 + 1123] = v12[v13 + 34] + v20;
        v11[v13 + 1123] = v11[v13 + 34] + v21;
        result[v13 + 1123] = result[v13 + 34] + v22;
        v9[v13 + 1123] = v9[v13 + 34] + v24;
        v8[v13 + 1123] = v25 + v8[v13 + 34];
        ++v13;
      }
      while (v13 != 32);
      ++v7;
      v12 += 33;
      v11 += 33;
      result += 33;
      v9 += 33;
      v8 += 33;
    }
    while (v7 != 33);
    int v6 = v26 + 1;
    a2 += 1089;
    a3 += 1089;
    a4 += 1089;
    a5 += 1089;
    a6 = v27 + 1089;
  }
  while (v26 != 32);
  return result;
}

uint64_t ColorQuantization::vol(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  int v3 = 1089 * a2[1];
  int v4 = 33 * a2[3];
  int v6 = a2[4];
  int v5 = a2[5];
  int v7 = 33 * a2[2];
  int v8 = 1089 * *a2;
  return *(void *)(a3 + 8 * (v4 + v3 + v5))
       + *(void *)(a3 + 8 * (v7 + v3 + v6))
       - (*(void *)(a3 + 8 * (v4 + v3 + v6))
        + *(void *)(a3 + 8 * (v7 + v3 + v5))
        + *(void *)(a3 + 8 * (v4 + v8 + v5)))
       + *(void *)(a3 + 8 * (v4 + v8 + v6))
       + *(void *)(a3 + 8 * (v7 + v8 + v5))
       - *(void *)(a3 + 8 * (v7 + v8 + v6));
}

uint64_t ColorQuantization::bottom(uint64_t a1, _DWORD *a2, int a3, uint64_t a4)
{
  switch(a3)
  {
    case 0:
      int v13 = a2[3];
      int v12 = a2[4];
      int v14 = v12 + 1089 * a2[1];
      int v15 = a2[2];
      uint64_t v16 = *(void *)(a4 + 8 * (v14 + v13 + 32 * v13));
      int v17 = 1089 * *a2;
      uint64_t v18 = *(void *)(a4 + 8 * (33 * v13 + v12 + v17));
      uint64_t v19 = *(void *)(a4 + 8 * (v15 + v12 + 32 * v15 + v17));
      uint64_t v10 = *(void *)(a4 + 8 * (v14 + v15 + 32 * v15)) + v18;
LABEL_7:
      uint64_t v11 = v16 + v19;
      return v10 - v11;
    case 1:
      int v20 = 33 * a2[2];
      int v21 = v20 + 1089 * a2[1];
      int v23 = a2[4];
      int v22 = a2[5];
      uint64_t v16 = *(void *)(a4 + 8 * (v21 + v22));
      int v24 = v20 + 1089 * *a2;
      uint64_t v25 = *(void *)(a4 + 8 * (v24 + v22));
      uint64_t v19 = *(void *)(a4 + 8 * (v24 + v23));
      uint64_t v10 = *(void *)(a4 + 8 * (v21 + v23)) + v25;
      goto LABEL_7;
    case 2:
      int v4 = 1089 * *a2;
      int v5 = a2[3] + v4 + 32 * a2[3];
      int v7 = a2[4];
      int v6 = a2[5];
      uint64_t v8 = *(void *)(a4 + 8 * (v5 + v6));
      int v9 = a2[2] + v4 + 32 * a2[2];
      uint64_t v10 = *(void *)(a4 + 8 * (v5 + v7)) + *(void *)(a4 + 8 * (v9 + v6));
      uint64_t v11 = v8 + *(void *)(a4 + 8 * (v9 + v7));
      return v10 - v11;
  }
  return 0;
}

uint64_t ColorQuantization::top(uint64_t a1, _DWORD *a2, int a3, int a4, uint64_t a5)
{
  switch(a3)
  {
    case 0:
      int v13 = a4 + 1089 * a2[1];
      int v15 = a2[2];
      int v14 = a2[3];
      uint64_t v8 = *(void *)(a5 + 8 * (v13 + v14 + 32 * v14));
      uint64_t v9 = *(void *)(a5 + 8 * (v13 + v15 + 32 * v15));
      int v16 = 1089 * *a2;
      uint64_t v11 = *(void *)(a5 + 8 * (v14 + a4 + 32 * v14 + v16));
      int v12 = v15 + a4 + 32 * v15 + v16;
      goto LABEL_6;
    case 1:
      int v19 = 33 * a4 + 1089 * a2[1];
      int v21 = a2[4];
      int v20 = a2[5];
      int v22 = 33 * a4 + 1089 * *a2;
      uint64_t v23 = *(void *)(a5 + 8 * (v22 + v20));
      uint64_t v17 = *(void *)(a5 + 8 * (v22 + v21));
      uint64_t v18 = *(void *)(a5 + 8 * (v19 + v20)) - (*(void *)(a5 + 8 * (v19 + v21)) + v23);
      return v18 + v17;
    case 2:
      int v5 = a2[3] + 1089 * a4 + 32 * a2[3];
      int v7 = a2[4];
      int v6 = a2[5];
      uint64_t v8 = *(void *)(a5 + 8 * (v5 + v6));
      uint64_t v9 = *(void *)(a5 + 8 * (v5 + v7));
      int v10 = a2[2] + 1089 * a4 + 32 * a2[2];
      uint64_t v11 = *(void *)(a5 + 8 * (v10 + v6));
      int v12 = v10 + v7;
LABEL_6:
      uint64_t v17 = *(void *)(a5 + 8 * v12);
      uint64_t v18 = v8 - (v9 + v11);
      return v18 + v17;
  }
  return 0;
}

double ColorQuantization::variance(uint64_t a1, _DWORD *a2, uint64_t *a3)
{
  uint64_t v5 = *a3;
  uint64_t v6 = ColorQuantization::vol(a1, a2, a3[2]);
  double v7 = (double)v6;
  uint64_t v8 = ColorQuantization::vol(v6, a2, a3[3]);
  double v9 = (double)v8;
  uint64_t v10 = ColorQuantization::vol(v8, a2, a3[4]);
  int v11 = 1089 * a2[1];
  int v12 = 33 * a2[3];
  int v14 = a2[4];
  int v13 = a2[5];
  int v15 = 33 * a2[2];
  int v16 = 1089 * *a2;
  double v17 = *(double *)(v5 + 8 * (v12 + v11 + v13))
      - *(double *)(v5 + 8 * (v12 + v11 + v14))
      - *(double *)(v5 + 8 * (v15 + v11 + v13))
      + *(double *)(v5 + 8 * (v15 + v11 + v14))
      - *(double *)(v5 + 8 * (v12 + v16 + v13))
      + *(double *)(v5 + 8 * (v12 + v16 + v14))
      + *(double *)(v5 + 8 * (v15 + v16 + v13))
      - *(double *)(v5 + 8 * (v15 + v16 + v14));
  return v17 - (v9 * v9 + v7 * v7 + (double)v10 * (double)v10) / (double)ColorQuantization::vol(v10, a2, a3[1]);
}

double ColorQuantization::maximize(uint64_t a1, _DWORD *a2, int a3, int a4, int a5, int *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  uint64_t v32 = a11[2];
  uint64_t v16 = ColorQuantization::bottom(a1, a2, a3, v32);
  uint64_t v30 = a11[3];
  uint64_t v31 = v16;
  uint64_t v17 = ColorQuantization::bottom(v16, a2, a3, v30);
  uint64_t v28 = a11[4];
  uint64_t v29 = v17;
  uint64_t v27 = ColorQuantization::bottom(v17, a2, a3, v28);
  uint64_t v18 = a11[1];
  uint64_t v19 = ColorQuantization::bottom(v27, a2, a3, v18);
  int v26 = a6;
  *a6 = -1;
  double v20 = 0.0;
  if (a4 < a5)
  {
    uint64_t v21 = v19;
    do
    {
      uint64_t v19 = ColorQuantization::top(v19, a2, a3, a4, v18);
      uint64_t v22 = v19 + v21;
      if (v19 + v21)
      {
        if (a10 != v22)
        {
          uint64_t v23 = ColorQuantization::top(v19, a2, a3, a4, v28);
          uint64_t v24 = ColorQuantization::top(v23, a2, a3, a4, v30);
          uint64_t v19 = ColorQuantization::top(v24, a2, a3, a4, v32);
          if (((double)(v24 + v29) * (double)(v24 + v29)
              + (double)(v19 + v31) * (double)(v19 + v31)
              + (double)(v23 + v27) * (double)(v23 + v27))
             / (double)v22
             + ((double)(a8 - (v24 + v29)) * (double)(a8 - (v24 + v29))
              + (double)(a7 - (v19 + v31)) * (double)(a7 - (v19 + v31))
              + (double)(a9 - (v23 + v27)) * (double)(a9 - (v23 + v27)))
             / (double)(a10 - v22) > v20)
          {
            *int v26 = a4;
            double v20 = ((double)(v24 + v29) * (double)(v24 + v29)
                 + (double)(v19 + v31) * (double)(v19 + v31)
                 + (double)(v23 + v27) * (double)(v23 + v27))
                / (double)v22
                + ((double)(a8 - (v24 + v29)) * (double)(a8 - (v24 + v29))
                 + (double)(a7 - (v19 + v31)) * (double)(a7 - (v19 + v31))
                 + (double)(a9 - (v23 + v27)) * (double)(a9 - (v23 + v27)))
                / (double)(a10 - v22);
          }
        }
      }
      ++a4;
    }
    while (a5 != a4);
  }
  return v20;
}

uint64_t ColorQuantization::cut(uint64_t a1, int *a2, _DWORD *a3, void *a4)
{
  uint64_t v28 = 0;
  int v27 = 0;
  uint64_t v7 = ColorQuantization::vol(a1, a2, a4[2]);
  uint64_t v8 = ColorQuantization::vol(v7, a2, a4[3]);
  uint64_t v9 = ColorQuantization::vol(v8, a2, a4[4]);
  uint64_t v10 = ColorQuantization::vol(v9, a2, a4[1]);
  int v11 = *a2;
  int v26 = a2[1];
  double v12 = ColorQuantization::maximize(v10, a2, 2, *a2 + 1, v26, (int *)&v28 + 1, v7, v8, v9, v10, a4);
  unsigned int v24 = a2[2];
  int v25 = a2[3];
  double v14 = ColorQuantization::maximize(v13, a2, 1, v24 + 1, v25, (int *)&v28, v7, v8, v9, v10, a4);
  int v15 = a2[4];
  int v16 = a2[5];
  double v18 = ColorQuantization::maximize(v17, a2, 0, v15 + 1, v16, &v27, v7, v8, v9, v10, a4);
  if (v12 < v14 || v12 < v18)
  {
    int v21 = v25;
    int v22 = v26;
    a3[1] = v26;
    a3[3] = v25;
    a3[5] = v16;
    if (v14 < v12 || v14 < v18)
    {
      int v15 = v27;
      a2[5] = v27;
      a3[4] = v15;
      *a3 = v11;
      unsigned int v20 = v24;
      a3[2] = v24;
      int v16 = a3[5];
    }
    else
    {
      unsigned int v20 = v28;
      a2[3] = v28;
      a3[2] = v20;
      *a3 = v11;
      a3[4] = v15;
      int v21 = a3[3];
    }
    goto LABEL_9;
  }
  int v11 = HIDWORD(v28);
  if ((v28 & 0x8000000000000000) == 0)
  {
    a3[5] = v16;
    *(void *)&long long v19 = __PAIR64__(v24, v26);
    unsigned int v20 = v24;
    int v21 = v25;
    *((void *)&v19 + 1) = __PAIR64__(v15, v25);
    *a3 = v11;
    *(_OWORD *)(a3 + 1) = v19;
    a2[1] = v11;
    int v22 = a3[1];
LABEL_9:
    a2[6] = (a2[3] - a2[2]) * (a2[1] - *a2) * (a2[5] - a2[4]);
    a3[6] = (v21 - v20) * (v22 - v11) * (v16 - v15);
    return 1;
  }
  return 0;
}

void ColorQuantization::mark(uint64_t a1, int *a2, char a3, uint64_t a4)
{
  int v4 = *a2;
  int v5 = a2[1];
  if (*a2 < v5)
  {
    int v6 = a2[3];
    int v7 = 1089 * v4 + 1122;
    do
    {
      uint64_t v8 = a2[2];
      if ((int)v8 < v6)
      {
        LODWORD(v9) = a2[5];
        int v10 = v7 + 33 * v8;
        do
        {
          uint64_t v11 = a2[4];
          if ((int)v11 < (int)v9)
          {
            do
            {
              *(unsigned char *)(a4 + 1 + v10 + v11) = a3;
              uint64_t v9 = a2[5];
              ++v11;
            }
            while (v11 < v9);
            int v6 = a2[3];
          }
          ++v8;
          v10 += 33;
        }
        while (v8 < v6);
        int v5 = a2[1];
      }
      ++v4;
      v7 += 1089;
    }
    while (v4 < v5);
  }
}

void ColorQuantization::addColorNode(uint64_t a1, uint64_t a2, __int16 a3, unsigned int a4, unsigned int a5, unsigned int a6, int a7)
{
  uint64_t v8 = a2;
  unsigned int v9 = (a5 >> 6) & 2 | (a4 >> 5) & 4 | (a6 >> 7);
  int v10 = a7 - 8;
  if (a7 == 8)
  {
    uint64_t v11 = a2;
  }
  else
  {
    unsigned int v12 = a6;
    unsigned int v13 = a5;
    unsigned int v14 = a4;
    do
    {
      uint64_t v15 = v9;
      uint64_t v11 = *(void *)(v8 + 8 * v9);
      if (!v11)
      {
        int v16 = malloc_type_malloc(0x40uLL, 0x80040A284212CuLL);
        *(void *)(v8 + 8 * v15) = v16;
        if (!v16) {
          return;
        }
        _OWORD v16[2] = 0u;
        void v16[3] = 0u;
        *int v16 = 0u;
        v16[1] = 0u;
        uint64_t v11 = *(void *)(v8 + 8 * v15);
      }
      unsigned int v17 = v14 >> 4;
      v14 *= 2;
      int v18 = v17 & 4 | (v13 >> 5) & 3;
      v13 *= 2;
      unsigned int v9 = v18 & 0xFFFFFFFE | (v12 >> 6) & 1;
      v12 *= 2;
      uint64_t v8 = v11;
    }
    while (!__CFADD__(v10++, 1));
  }
  if (!*(void *)(v11 + 8 * v9))
  {
    uint64_t v20 = v9;
    int v21 = malloc_type_malloc(2uLL, 0x1000040BDFB0063uLL);
    *(void *)(v11 + 8 * v20) = v21;
    if (v21) {
      *int v21 = a3;
    }
  }
}

uint64_t ColorQuantization::lookupColorNode(uint64_t a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 a4, unsigned int a5, int a6)
{
  while (1)
  {
    int v6 = *(unsigned __int8 **)&a2[8 * ((a3 >> 5) & 4 | (a4 >> 6) & 0xFE | (a5 >> 7) & 1)];
    if (!v6)
    {
      unint64_t v7 = 0;
      do
      {
        int v6 = *(unsigned __int8 **)&a2[8 * v7];
        if (v7 > 6) {
          break;
        }
        ++v7;
      }
      while (!v6);
    }
    if (a6 == 8) {
      break;
    }
    a3 *= 2;
    a4 *= 2;
    ++a6;
    a2 = v6;
    a5 *= 2;
  }
  return *v6;
}

void ColorQuantization::freeColorNodes(uint64_t a1, uint64_t a2, int a3)
{
  for (uint64_t i = 0; i != 64; i += 8)
  {
    unint64_t v7 = *(void **)(a2 + i);
    if (v7)
    {
      if (a3 <= 7)
      {
        ColorQuantization::freeColorNodes(a1);
        unint64_t v7 = *(void **)(a2 + i);
      }
      free(v7);
    }
  }
}

unint64_t ColorQuantization::reduceColorMap(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  if (a3)
  {
    int v4 = (unsigned char *)(3 * a3 + *(void *)(a2 + 16) + 2);
    unint64_t v5 = a3;
    do
    {
      if (*(v4 - 2)) {
        break;
      }
      if (*(v4 - 1)) {
        break;
      }
      if (*v4) {
        break;
      }
      v4 -= 3;
      --v5;
    }
    while (v5);
  }
  else
  {
    unint64_t v5 = 0;
  }
  if (v5 + 1 < a3) {
    unint64_t v6 = v5 + 1;
  }
  else {
    unint64_t v6 = a3;
  }
  if (a4) {
    return v6;
  }
  else {
    return a3;
  }
}

unsigned __int8 *ColorQuantization::sortColorMap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  while (1)
  {
    uint64_t v5 = a5;
    uint64_t v6 = a4;
    uint64_t v7 = a3;
    uint64_t v8 = a2;
    if (a5 - a4 == 1) {
      break;
    }
    uint64_t v16 = a1;
    int v17 = a5 + a4;
    if ((int)a5 + (int)a4 < 0 != __OFADD__(a5, a4)) {
      ++v17;
    }
    int v18 = v17 >> 1;
    long long v19 = (unsigned __int8 *)(a2 + 3 * (v17 >> 1));
    unsigned int v20 = *v19;
    unsigned int v21 = v19[1];
    unsigned int v22 = v19[2];
    uint64_t v23 = (__int16 *)(a2 + 3 * (int)a4);
    __int16 v24 = *v23;
    int v19[2] = *((unsigned char *)v23 + 2);
    *(_WORD *)long long v19 = v24;
    *(unsigned char *)uint64_t v23 = v20;
    *((unsigned char *)v23 + 1) = v21;
    *((unsigned char *)v23 + 2) = v22;
    char v25 = *(unsigned char *)(a3 + v18);
    *(unsigned char *)(a3 + v18) = *(unsigned char *)(a3 + (int)a4);
    *(unsigned char *)(a3 + (int)a4) = v25;
    int v26 = a4 + 1;
    int v27 = a5;
    while (1)
    {
      if (v26 <= v27)
      {
        uint64_t v28 = v27;
        int v29 = v27 + 1;
        uint64_t v30 = v27 - (uint64_t)v26 + 1;
        uint64_t v31 = (unsigned __int8 *)(v8 + 2 + 3 * v26);
        while (1)
        {
          unsigned int v32 = *(v31 - 1);
          if (v32 > v21) {
            break;
          }
          if (v32 >= v21)
          {
            unsigned int v33 = *(v31 - 2);
            if (v33 > v20 || v33 >= v20 && *v31 > v22) {
              break;
            }
          }
          ++v26;
          v31 += 3;
          if (!--v30)
          {
            int v26 = v29;
            break;
          }
        }
      }
      else
      {
        uint64_t v28 = v27;
      }
      uint64_t v34 = 0;
      uint64_t result = (unsigned __int8 *)(v8 + 1 + 3 * v28);
      int v35 = -1;
      uint64_t v36 = v7;
      while (1)
      {
        unsigned int v37 = *result;
        if (v37 <= v21)
        {
          if (v37 < v21) {
            break;
          }
          unsigned int v38 = *(result - 1);
          if (v38 <= v20 && (v38 < v20 || result[1] <= v22)) {
            break;
          }
        }
        --v36;
        --v34;
        --v35;
        result -= 3;
      }
      int v27 = v28 + v34;
      if (v26 >= (int)v28 + (int)v34) {
        break;
      }
      int v39 = result - 1;
      uint64_t v40 = (__int16 *)(v8 + 3 * v26);
      __int16 v41 = *v40;
      unsigned __int8 v42 = *((unsigned char *)v40 + 2);
      unsigned __int8 v43 = v39[2];
      __int16 *v40 = *(_WORD *)v39;
      *((unsigned char *)v40 + 2) = v43;
      *(_WORD *)int v39 = v41;
      v39[2] = v42;
      LOBYTE(v39) = *(unsigned char *)(v7 + v26);
      *(unsigned char *)(v7 + v2jp2_colour_converter::clear(this + 6) = *(unsigned char *)(v36 + v28);
      *(unsigned char *)(v36 + v28) = (_BYTE)v39;
    }
    __int16 v44 = *(_WORD *)(result - 1);
    *((unsigned char *)v23 + 2) = result[1];
    __int16 *v23 = v44;
    *(result - 1) = v20;
    *uint64_t result = v21;
    result[1] = v22;
    *(unsigned char *)(v7 + (int)vjp2_colour_converter::clear(this + 6) = *(unsigned char *)(v36 + v28);
    *(unsigned char *)(v36 + v28) = v25;
    if ((int)v28 + v35 > (int)v6) {
      uint64_t result = (unsigned __int8 *)ColorQuantization::sortColorMap(v16, v8, v7, v6);
    }
    a4 = v28 + v34 + 1;
    if ((int)a4 >= (int)v5) {
      return result;
    }
    a1 = v16;
    a2 = v8;
    a3 = v7;
    a5 = v5;
  }
  unsigned int v9 = (unsigned __int8 *)(a2 + 3 * (int)a4);
  int v10 = (unsigned __int8 *)(a2 + 3 * (int)a5);
  uint64_t result = (unsigned __int8 *)RGBColorType::compare(v9, v10);
  if ((int)result >= 1)
  {
    __int16 v12 = *(_WORD *)v9;
    unsigned __int8 v13 = v9[2];
    unsigned __int8 v14 = v10[2];
    *(_WORD *)unsigned int v9 = *(_WORD *)v10;
    _OWORD v9[2] = v14;
    *(_WORD *)int v10 = v12;
    _OWORD v10[2] = v13;
    char v15 = *(unsigned char *)(v7 + (int)v6);
    *(unsigned char *)(v7 + (int)vjp2_colour_converter::clear(this + 6) = *(unsigned char *)(v7 + (int)v5);
    *(unsigned char *)(v7 + (int)v5) = v15;
  }
  return result;
}

void ColorQuantization::quantizeBufferWithCustomColors(uint64_t a1, int a2, int a3, int a4, unsigned __int8 *a5, unsigned char *a6, unsigned __int8 *a7, unsigned char *a8, uint64_t a9)
{
  uint64_t v15 = a1;
  memset(v27, 0, sizeof(v27));
  if (a4 >= 1)
  {
    uint64_t v16 = 0;
    uint64_t v17 = a4;
    int v18 = (unsigned __int8 *)(a9 + 2);
    do
    {
      unsigned int v19 = *(v18 - 2);
      unsigned int v20 = *(v18 - 1);
      unsigned int v21 = *v18;
      v18 += 3;
      ColorQuantization::addColorNode(a1, (uint64_t)v27, v16++, v19, v20, v21, 1);
    }
    while (v17 != v16);
  }
  for (int i = a3 * a2; i; --i)
  {
    unsigned int v24 = *a5++;
    unsigned int v23 = v24;
    LOBYTE(v24) = *a6++;
    unsigned __int8 v25 = v24;
    unsigned int v26 = *a7++;
    a1 = ColorQuantization::lookupColorNode(a1, (unsigned __int8 *)v27, v23, v25, v26, 1);
    *a8++ = a1;
  }
  ColorQuantization::freeColorNodes(v15, (uint64_t)v27, 1);
}

uint64_t ColorQuantization::generateFromRGBImageWu(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _DWORD *a9)
{
  MEMORY[0x1F4188790](a1, a2);
  uint64_t v11 = v10;
  uint64_t v87 = v12;
  int v14 = v13;
  int v15 = v9;
  uint64_t v17 = v16;
  uint64_t v19 = v18;
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  uint64_t v21 = v16[1];
  uint64_t v20 = v16[2];
  uint64_t v101 = 0;
  memset(v105, 0, sizeof(v105));
  memset(v104, 0, sizeof(v104));
  memset(v103, 0, sizeof(v103));
  if ((v9 - 1) > 3)
  {
    uint64_t v82 = 0;
    int v22 = 256;
  }
  else
  {
    uint64_t v82 = qword_18898F2D0[v9 - 1];
    int v22 = 255;
  }
  unsigned int v88 = v22;
  LOWORD(v101) = v22;
  bzero(&v106, 0x1C00uLL);
  bzero(v102, 0x800uLL);
  uint64_t v81 = *v17;
  size_t v23 = (v21 * v20);
  uint64_t v100 = v23;
  unint64_t v94 = malloc_type_calloc(0x8C61uLL, 8uLL, 0x100004000313F17uLL);
  unsigned int v24 = malloc_type_calloc(0x8C61uLL, 8uLL, 0x100004000313F17uLL);
  unint64_t v95 = v24;
  int v91 = malloc_type_calloc(0x8C61uLL, 8uLL, 0x100004000313F17uLL);
  int v96 = v91;
  uint64_t v90 = malloc_type_calloc(0x8C61uLL, 8uLL, 0x100004000313F17uLL);
  int32x4_t v97 = v90;
  uint64_t v89 = malloc_type_calloc(0x8C61uLL, 8uLL, 0x100004000313F17uLL);
  long long v98 = v89;
  unsigned __int8 v25 = malloc_type_calloc(2uLL, v23, 0x676D6BE0uLL);
  unsigned int v26 = v94;
  uint64_t v99 = v25;
  if (!v94 || !v24 || !v91 || !v90 || !v89)
  {
LABEL_73:
    uint64_t v77 = 1;
    if (!v26) {
      goto LABEL_75;
    }
    goto LABEL_74;
  }
  int v27 = v25;
  if (v25)
  {
    int v83 = v14;
    uint64_t v84 = v19;
    int v85 = v21;
    int v86 = v20;
    uint64_t v28 = v17;
    int v29 = (double *)v94;
    uint64_t v30 = (ColorQuantization *)ColorQuantization::hist3d((uint64_t)v25, (uint64_t *)v24, (uint64_t)v91, (uint64_t)v90, (uint64_t)v89, (uint64_t)v94, v28, v15, (uint64_t *)&v94);
    uint64_t v92 = (uint64_t)v24;
    uint64_t v31 = (uint64_t)ColorQuantization::m3d(v30, (uint64_t *)v24, (uint64_t *)v91, (uint64_t *)v90, (uint64_t *)v89, v29);
    int v32 = 0;
    long long v106 = xmmword_18898F210;
    uint64_t v107 = 0x2000000000;
    uint64_t v33 = 1;
    while (1)
    {
      uint64_t v34 = v32;
      int v35 = (int *)&v106 + 7 * v32;
      uint64_t v31 = ColorQuantization::cut(v31, v35, (_DWORD *)&v106 + 7 * v33, &v94);
      if (v31)
      {
        double v36 = 0.0;
        double v37 = 0.0;
        if ((int)v108[7 * (int)v34] >= 2) {
          double v37 = ColorQuantization::variance(v31, v35, (uint64_t *)&v94);
        }
        v102[v34] = v37;
        if ((int)v108[7 * v33] >= 2) {
          double v36 = ColorQuantization::variance(v31, (_DWORD *)&v106 + 7 * v33, (uint64_t *)&v94);
        }
        v102[v33] = v36;
      }
      else
      {
        v102[v34] = 0.0;
        --v33;
      }
      double v38 = v102[0];
      if (v33 < 1)
      {
        int v32 = 0;
      }
      else
      {
        uint64_t v39 = 0;
        int v32 = 0;
        do
        {
          double v40 = v102[++v39];
          if (v40 > v38)
          {
            int v32 = v39;
            double v38 = v40;
          }
        }
        while (v33 != v39);
      }
      if (v38 <= 0.0) {
        break;
      }
      if (++v33 >= v88)
      {
        unsigned __int16 v41 = v88;
        goto LABEL_29;
      }
    }
    unsigned __int16 v41 = v33 + 1;
    LOWORD(v101) = v33 + 1;
LABEL_29:
    free(v29);
    unint64_t v94 = 0;
    uint64_t v42 = (uint64_t)malloc_type_calloc(0x8C61uLL, 1uLL, 0x100004077774924uLL);
    if (!v42)
    {
      uint64_t v77 = 0;
      goto LABEL_75;
    }
    unsigned __int8 v43 = (unsigned __int8 *)v42;
    int v93 = v41;
    if (v41)
    {
      uint64_t v44 = 0;
      uint64_t v45 = (int *)&v106;
      do
      {
        ColorQuantization::mark(v42, v45, v44, (uint64_t)v43);
        uint64_t v42 = ColorQuantization::vol(v46, v45, v92);
        uint64_t v47 = v42;
        if (v42)
        {
          uint64_t v48 = ColorQuantization::vol(v42, v45, (uint64_t)v91);
          double v49 = (double)v47;
          LODWORD(v47) = (int)((double)v48 / (double)v47 + 0.5);
          uint64_t v50 = ColorQuantization::vol(v48, v45, (uint64_t)v90);
          int v51 = (int)((double)v50 / v49 + 0.5);
          uint64_t v42 = ColorQuantization::vol(v50, v45, (uint64_t)v89);
          int v52 = (int)((double)v42 / v49 + 0.5);
        }
        else
        {
          LOBYTE(v52) = 0;
          LOBYTE(v51) = 0;
        }
        *((unsigned char *)v103 + v44) = v52;
        *((unsigned char *)v104 + v44) = v51;
        *((unsigned char *)v105 + v44++) = v47;
        v45 += 7;
      }
      while (v41 != v44);
    }
    if (v23)
    {
      uint64_t v53 = v27;
      do
      {
        _WORD *v53 = v43[(unsigned __int16)*v53];
        ++v53;
        --v23;
      }
      while (v23);
    }
    *a9 = 0;
    unsigned __int16 v54 = v41;
    if (v83)
    {
      *a9 = v41;
      unsigned __int16 v54 = v41 + 1;
      LOWORD(v101) = v41 + 1;
      uint64_t v55 = 3 * (unsigned __int16)(v41 + 1) + *(void *)(v87 + 16);
      *(_WORD *)(v55 - ++*((_DWORD *)this + 3) = 0;
      *(unsigned char *)(v55 - 1) = 0;
    }
    int v56 = 1;
    int v57 = v54 - 1;
    if (v54 != 1)
    {
      int v56 = 0;
      do
      {
        ++v56;
        BOOL v58 = v57 > 1;
        v57 >>= 1;
      }
      while (v58);
    }
    *(_DWORD *)uint64_t v87 = 1 << v56;
    *(_DWORD *)(v87 + 4) = v56;
    if (v41)
    {
      __int16 v59 = *(unsigned char **)(v87 + 16);
      uint64_t v60 = v41;
      unsigned int v61 = (char *)v103;
      unsigned int v62 = (char *)v104;
      unsigned int v63 = (char *)v105;
      do
      {
        char v64 = *v63++;
        *__int16 v59 = v64;
        char v65 = *v62++;
        v59[1] = v65;
        char v66 = *v61++;
        v59[2] = v66;
        v59 += 3;
        --v60;
      }
      while (v60);
    }
    if (v85)
    {
      int v67 = 0;
      unint64_t v68 = v11;
      do
      {
        for (int i = v86; i; --i)
        {
          char v70 = *v27;
          v27 += 2;
          *v68++ = v70;
        }
        ++v67;
      }
      while (v67 != v85);
    }
    if (v83)
    {
      uint64_t v71 = v100;
      if (v100 >= 1)
      {
        uint64_t v72 = (unsigned __int8 *)(v81 + v82);
        int v73 = v11;
        do
        {
          if (*v72 <= 0x3Fu) {
            unsigned char *v73 = *a9;
          }
          ++v73;
          v72 += 4;
          --v71;
        }
        while (v71);
      }
    }
    uint64_t v74 = (unsigned __int16)v101;
    if ((_WORD)v101)
    {
      uint64_t v75 = 0;
      do
      {
        *((unsigned char *)v105 + v75) = v75;
        ++v75;
      }
      while (v74 != v75);
      ColorQuantization::sortColorMap(v84, *(void *)(v87 + 16), (uint64_t)v105, 0, (v93 - 1));
      if (v74)
      {
        for (uint64_t j = 0; j != v74; ++j)
          *((unsigned char *)v104 + *((unsigned __int8 *)v105 + j)) = j;
      }
      if (!v85) {
        goto LABEL_72;
      }
    }
    else
    {
      ColorQuantization::sortColorMap(v84, *(void *)(v87 + 16), (uint64_t)v105, 0, (v93 - 1));
      if (!v85)
      {
LABEL_72:
        free(v43);
        unsigned int v26 = v94;
        goto LABEL_73;
      }
    }
    for (int k = 0; k != v85; ++k)
    {
      for (int m = v86; m; --m)
      {
        unsigned char *v11 = *((unsigned char *)v104 + *v11);
        ++v11;
      }
    }
    goto LABEL_72;
  }
  uint64_t v77 = 0;
LABEL_74:
  free(v26);
LABEL_75:
  if (v95) {
    free(v95);
  }
  if (v96) {
    free(v96);
  }
  if (v97) {
    free(v97);
  }
  if (v98) {
    free(v98);
  }
  if (v99) {
    free(v99);
  }
  return v77;
}

BOOL ColorQuantization::generateFromIndexedImage(int a1, uint64_t a2, CGImage *a3, int a4, int a5, int a6, CGColorSpaceRef space, uint64_t a8, unsigned char *a9, _DWORD *a10)
{
  if (a4 == 8)
  {
    int v49 = a4;
    int v14 = *(_DWORD *)(a2 + 16);
    uint64_t v15 = *(unsigned int *)(a2 + 8);
    BaseColorSpace = CGColorSpaceGetBaseColorSpace(space);
    CGColorSpaceModel Model = CGColorSpaceGetModel(BaseColorSpace);
    if (Model == kCGColorSpaceModelRGB) {
      size_t v18 = 3;
    }
    else {
      size_t v18 = 1;
    }
    ColorTableuint64_t Count = CGColorSpaceGetColorTableCount(space);
    uint64_t v20 = (uint8_t *)malloc_type_calloc(ColorTableCount, v18, 0xB1976154uLL);
    CGColorSpaceGetColorTable(space, v20);
    unint64_t v21 = 256;
    if (ColorTableCount < 0x100) {
      unint64_t v21 = ColorTableCount;
    }
    if (((v21 > 0xFF) & a6) != 0) {
      unint64_t v22 = 255;
    }
    else {
      unint64_t v22 = v21;
    }
    if (v22)
    {
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      unsigned __int8 v25 = v20;
      do
      {
        uint64_t v26 = *(void *)(a8 + 16);
        if (Model == kCGColorSpaceModelRGB)
        {
          int v27 = (unsigned char *)(v26 + v23);
          *int v27 = v20[v23];
          v27[1] = v20[v23 + 1];
          uint64_t v28 = &v20[3 * v24 + 2];
        }
        else
        {
          int v29 = (uint8_t *)(v26 + v23);
          *int v29 = *v25;
          v29[1] = *v25;
          uint64_t v28 = v25;
        }
        *(unsigned char *)(v26 + v23 + 2) = *v28;
        ++v24;
        v23 += 3;
        ++v25;
      }
      while (3 * v22 != v23);
    }
    free(v20);
    unint64_t v31 = ColorQuantization::reduceColorMap(v30, a8, v22, a6);
    *a10 = 0;
    if (a6)
    {
      *a10 = v31;
      uint64_t v32 = 3 * v31;
      LODWORD(v31) = v31 + 1;
      uint64_t v33 = *(void *)(a8 + 16) + v32;
      *(_WORD *)uint64_t v33 = 0;
      *(unsigned char *)(v33 + 2) = 0;
    }
    int v35 = 1;
    int v36 = v31 - 1;
    if (v31 != 1)
    {
      int v35 = 0;
      do
      {
        ++v35;
        BOOL v37 = v36 > 1;
        v36 >>= 1;
      }
      while (v37);
    }
    *(_DWORD *)a8 = 1 << v35;
    *(_DWORD *)(a8 + 4) = v35;
    CGImageGetDataProvider(a3);
    unsigned int BytesPerRow = CGImageGetBytesPerRow(a3);
    uint64_t v39 = (unsigned __int8 *)malloc_type_malloc(BytesPerRow, 0x4C6ED555uLL);
    if (a6)
    {
      if (v15)
      {
        uint64_t v40 = 0;
        char v41 = 0;
        while (1)
        {
          CGDataProviderGetBytesAtPosition();
          int v42 = v14;
          unsigned __int8 v43 = v39;
          if (v14) {
            break;
          }
LABEL_32:
          putchar(10);
          if (++v40 == v15) {
            goto LABEL_39;
          }
        }
        while (1)
        {
          *a9++ = *v43;
          if ((v41 & 1) == 0)
          {
            if ((char)v43[1] < 0)
            {
              char v41 = 0;
              goto LABEL_29;
            }
            *a10 = *v43;
          }
          char v41 = 1;
LABEL_29:
          v43 += 2;
          if (!--v42) {
            goto LABEL_32;
          }
        }
      }
    }
    else if (v15)
    {
      for (uint64_t i = 0; i != v15; ++i)
      {
        CGDataProviderGetBytesAtPosition();
        int v45 = v14;
        for (uint64_t j = (char *)v39; v45; --v45)
        {
          char v47 = *j++;
          *a9++ = v47;
        }
      }
    }
LABEL_39:
    free(v39);
    a4 = v49;
  }
  return a4 == 8;
}

uint64_t ColorQuantization::generateFromGrayImage(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6, uint64_t a7, unsigned char *a8, _DWORD *a9)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  int v14 = *(_DWORD *)(a2 + 16);
  int v50 = *(_DWORD *)(a2 + 8);
  size_t v15 = *(unsigned int *)(a2 + 24);
  bzero(v55, 0x400uLL);
  uint64_t v16 = malloc_type_malloc(v15, 0xFB889D1DuLL);
  if (!v16) {
    return 0;
  }
  size_t v18 = v16;
  IIOBitStreaint m = IIOBitStream::CreateIIOBitStream(*(IIOBitStream **)a2, (void *)(*(void *)(a2 + 24) * *(void *)(a2 + 8)), "r", v17);
  if (!IIOBitStream) {
    goto LABEL_72;
  }
  uint64_t v20 = IIOBitStream;
  int v49 = v18;
  int v21 = 1 << (a3 - 1);
  unsigned __int8 v48 = v21;
  if (v50)
  {
    int v22 = 0;
    unsigned int v23 = v21;
    while (1)
    {
      int v51 = v22;
      if (v14) {
        break;
      }
LABEL_20:
      int v22 = v51 + 1;
      if (v51 + 1 == v50) {
        goto LABEL_21;
      }
    }
    int v24 = 0;
    while (1)
    {
      uint64_t v54 = 0;
      if (((a4 < 7) & (0x54u >> a4)) != 0)
      {
        if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v20 + 24))(v20, a3, &v54)) {
          break;
        }
      }
      if ((*(unsigned int (**)(uint64_t, uint64_t, char *))(*(void *)v20 + 24))(v20, a3, (char *)&v54 + 4)
        || a4 <= 5
        && ((1 << a4) & 0x2A) != 0
        && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v20 + 24))(v20, a3, &v54))
      {
        break;
      }
      if (!a5 || v54 >= v23)
      {
        int v25 = BYTE4(v54);
        if (a3 <= 7)
        {
          int v26 = a3;
          do
          {
            v25 |= (v25 << v26);
            BOOL v27 = v26 < 4;
            v26 *= 2;
          }
          while (v27);
        }
        ++v55[v25];
      }
      if (++v24 == v14) {
        goto LABEL_20;
      }
    }
LABEL_66:
    uint64_t v46 = 0;
LABEL_67:
    size_t v18 = v49;
    goto LABEL_69;
  }
LABEL_21:
  (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  uint64_t v29 = 0;
  int v30 = 0;
  do
  {
    int v31 = v55[v29];
    BOOL v32 = v31 == 0;
    if (v31) {
      int v33 = v30;
    }
    else {
      int v33 = -1;
    }
    if (!v32) {
      ++v30;
    }
    v55[v29++] = v33;
  }
  while (v29 != 256);
  size_t v18 = v49;
  if (a5 && v30 == 256)
  {
    for (uint64_t i = 1; i != 256; ++i)
      --v55[i];
    int v56 = -1;
    int v30 = 255;
  }
  uint64_t v35 = 0;
  unsigned int v36 = 0;
  do
  {
    if ((v55[v35] & 0x80000000) == 0)
    {
      BOOL v37 = (unsigned char *)(*(void *)(a7 + 16) + 3 * v36);
      unsigned char *v37 = v35;
      v37[1] = v35;
      unsigned int v37[2] = v35;
      ++v36;
    }
    ++v35;
  }
  while (v35 != 256);
  if (v36 + 1 <= 0xFF) {
    bzero((void *)(*(void *)(a7 + 16) + 3 * (v36 + 1)), 3 * (254 - v36) + 3);
  }
  *a9 = 0;
  if (a5) {
    *a9 = v30++;
  }
  int v38 = 1;
  int v39 = v30 - 1;
  if (v30 != 1)
  {
    int v38 = 0;
    do
    {
      ++v38;
      BOOL v27 = v39 > 1;
      v39 >>= 1;
    }
    while (v27);
  }
  *(_DWORD *)a7 = 1 << v38;
  *(_DWORD *)(a7 + 4) = v38;
  uint64_t v40 = IIOBitStream::CreateIIOBitStream(*(IIOBitStream **)a2, (void *)(*(void *)(a2 + 24) * *(void *)(a2 + 8)), "r", v28);
  if (!v40)
  {
LABEL_72:
    uint64_t v46 = 0;
    goto LABEL_70;
  }
  uint64_t v20 = v40;
  if (v50)
  {
    int v41 = 0;
    while (1)
    {
      int v52 = v41;
      if (v14) {
        break;
      }
LABEL_64:
      int v41 = v52 + 1;
      if (v52 + 1 == v50)
      {
        uint64_t v46 = 1;
        goto LABEL_67;
      }
    }
    int v42 = 0;
    while (1)
    {
      uint64_t v54 = 0;
      if (((a4 < 7) & (0x54u >> a4)) != 0
        && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v20 + 24))(v20, a3, &v54)
        || (*(unsigned int (**)(uint64_t, uint64_t, char *))(*(void *)v20 + 24))(v20, a3, (char *)&v54 + 4)
        || a4 <= 5
        && ((1 << a4) & 0x2A) != 0
        && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v20 + 24))(v20, a3, &v54))
      {
        goto LABEL_66;
      }
      if (!a5) {
        break;
      }
      unsigned __int8 v43 = a9;
      if (v54 >= v48) {
        break;
      }
LABEL_63:
      *a8++ = *v43;
      if (++v42 == v14) {
        goto LABEL_64;
      }
    }
    int v44 = HIDWORD(v54);
    if (a3 == 1)
    {
      int v44 = 1 - HIDWORD(v54);
    }
    else if (a3 > 7)
    {
LABEL_62:
      unsigned __int8 v43 = &v55[v44];
      goto LABEL_63;
    }
    int v45 = a3;
    do
    {
      v44 |= v44 << v45;
      BOOL v27 = v45 < 4;
      v45 *= 2;
    }
    while (v27);
    goto LABEL_62;
  }
  uint64_t v46 = 1;
LABEL_69:
  (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
LABEL_70:
  free(v18);
  return v46;
}

uint64_t ColorQuantization::generateFromRGBImage(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6, uint64_t a7, unsigned char *a8, int *a9)
{
  size_t v13 = *(unsigned int *)(a2 + 24);
  unsigned int v56 = *(_DWORD *)(a2 + 8);
  unsigned int v59 = *(_DWORD *)(a2 + 16);
  size_t v14 = v56 * v59;
  size_t v15 = (unsigned __int8 *)malloc_type_malloc(v14, 0x9A53FCA6uLL);
  uint64_t v16 = malloc_type_malloc(v14, 0x3BBEF6C6uLL);
  uint64_t v17 = (unsigned __int8 *)malloc_type_malloc(v14, 0x780AB5A3uLL);
  if (a5) {
    size_t v18 = malloc_type_malloc(v14, 0x837D53F4uLL);
  }
  else {
    size_t v18 = 0;
  }
  IIOBitStreaint m = 0;
  uint64_t v55 = 0;
  if (v18) {
    char v20 = 0;
  }
  else {
    char v20 = a5;
  }
  if (v15) {
    BOOL v21 = v16 == 0;
  }
  else {
    BOOL v21 = 1;
  }
  BOOL v22 = v21 || v17 == 0;
  if (v22 || (v20 & 1) != 0) {
    goto LABEL_71;
  }
  uint64_t v54 = v18;
  int v24 = malloc_type_malloc(v13, 0x373E776uLL);
  if (v24)
  {
    IIOBitStreaint m = IIOBitStream::CreateIIOBitStream(*(IIOBitStream **)a2, (void *)(*(void *)(a2 + 24) * *(void *)(a2 + 8)), "r", v23);
    if (IIOBitStream)
    {
      uint64_t v55 = v24;
      int v52 = v16;
      uint64_t v53 = v15;
      int v51 = v17;
      if (v56)
      {
        int v25 = 0;
        unsigned int v26 = (1 << (a3 - 1));
        BOOL v58 = v18;
        BOOL v27 = v16;
        uint64_t v28 = v53;
        while (1)
        {
          int v57 = v25;
          if (v59) {
            break;
          }
LABEL_45:
          int v25 = v57 + 1;
          if (v57 + 1 == v56) {
            goto LABEL_46;
          }
        }
        int v29 = 0;
        while (1)
        {
          LODWORD(v60) = 0;
          uint64_t v63 = 0;
          unsigned int v62 = 255;
          if (a4 <= 6
            && ((1 << a4) & 0x54) != 0
            && (*(unsigned int (**)(uint64_t, uint64_t, unsigned int *))(*(void *)IIOBitStream + 24))(IIOBitStream, a3, &v62))
          {
            break;
          }
          if ((*(unsigned int (**)(uint64_t, uint64_t, void **))(*(void *)IIOBitStream + 24))(IIOBitStream, a3, &v60)|| (*(unsigned int (**)(uint64_t, uint64_t, char *))(*(void *)IIOBitStream + 24))(IIOBitStream, a3, (char *)&v63 + 4)|| (*(unsigned int (**)(uint64_t, uint64_t, uint64_t *))(*(void *)IIOBitStream + 24))(IIOBitStream, a3, &v63)|| ((a4 < 6) & a4) != 0&& (*(unsigned int (**)(uint64_t, uint64_t, unsigned int *))(*(void *)IIOBitStream + 24))(IIOBitStream, a3, &v62))
          {
            break;
          }
          unsigned int v30 = v62;
          if (a5 && v62 < v26)
          {
            LOBYTE(v31) = 0;
            LODWORD(v60) = 0;
            uint64_t v63 = 0;
          }
          else
          {
            LOBYTE(v31) = (_BYTE)v60;
          }
          int v31 = v31;
          if (a3 > 7)
          {
            HIDWORD(v6++*((_DWORD *)this + 3) = BYTE4(v63);
            int v36 = v63;
          }
          else
          {
            int v32 = a3;
            do
            {
              v31 |= (v31 << v32);
              BOOL v33 = v32 < 4;
              v32 *= 2;
            }
            while (v33);
            int v34 = BYTE4(v63);
            int v35 = a3;
            do
            {
              v34 |= (v34 << v35);
              BOOL v33 = v35 < 4;
              v35 *= 2;
            }
            while (v33);
            HIDWORD(v6++*((_DWORD *)this + 3) = v34;
            int v36 = v63;
            int v37 = a3;
            do
            {
              v36 |= (v36 << v37);
              BOOL v33 = v37 < 4;
              v37 *= 2;
            }
            while (v33);
          }
          LODWORD(v6++*((_DWORD *)this + 3) = v36;
          *v28++ = v31;
          *v27++ = BYTE4(v63);
          *v17++ = v63;
          if (a5) {
            *v58++ = v30 >= v26;
          }
          if (++v29 == v59) {
            goto LABEL_45;
          }
        }
        (*(void (**)(uint64_t))(*(void *)IIOBitStream + 8))(IIOBitStream);
        IIOBitStreaint m = 0;
        uint64_t v17 = v51;
        uint64_t v16 = v52;
        size_t v15 = v53;
        size_t v18 = v54;
      }
      else
      {
LABEL_46:
        (*(void (**)(uint64_t))(*(void *)IIOBitStream + 8))(IIOBitStream);
        if (*(int *)a7 < 1)
        {
          int v40 = 1 << a3;
          if (((a3 == 8) & a5) != 0) {
            int v40 = 255;
          }
          int v61 = v40;
          uint64_t v16 = v52;
          size_t v15 = v53;
          uint64_t v17 = v51;
          int v39 = a8;
          size_t v18 = v54;
          if (_cg_GifQuantizeBuffer(v59, v56) != 1)
          {
            IIOBitStreaint m = 0;
            goto LABEL_71;
          }
        }
        else
        {
          if (((*(_DWORD *)a7 == 256) & a5) != 0) {
            int v38 = 255;
          }
          else {
            int v38 = *(_DWORD *)a7;
          }
          int v61 = v38;
          uint64_t v60 = &unk_1ED4E4048;
          uint64_t v16 = v52;
          size_t v15 = v53;
          uint64_t v17 = v51;
          int v39 = a8;
          ColorQuantization::quantizeBufferWithCustomColors((uint64_t)&v60, v59, v56, v38, v53, v52, v51, a8, *(void *)(a7 + 16));
          size_t v18 = v54;
        }
        *a9 = 0;
        int v41 = v61;
        if (a5)
        {
          *a9 = v61;
          int v61 = v41 + 1;
          uint64_t v42 = *(void *)(a7 + 16) + 3 * v41;
          *(unsigned char *)(v42 + 2) = 0;
          *(_WORD *)uint64_t v42 = 0;
          IIOBitStreaint m = 1;
          if (v41)
          {
            int v43 = 0;
            do
            {
              ++v43;
              BOOL v33 = v41 > 1;
              v41 >>= 1;
            }
            while (v33);
          }
          else
          {
            int v43 = 1;
          }
          *(_DWORD *)a7 = 1 << v43;
          *(_DWORD *)(a7 + 4) = v43;
          if (v56 * v59)
          {
            uint64_t v46 = v18;
            int v47 = v56 * v59;
            do
            {
              if (!*v46) {
                *int v39 = *a9;
              }
              ++v39;
              ++v46;
              --v47;
            }
            while (v47);
            IIOBitStreaint m = 1;
          }
        }
        else
        {
          IIOBitStreaint m = 1;
          int v44 = 1;
          int v45 = v61 - 1;
          if (v61 != 1)
          {
            int v44 = 0;
            do
            {
              ++v44;
              BOOL v33 = v45 > 1;
              v45 >>= 1;
            }
            while (v33);
          }
          *(_DWORD *)a7 = 1 << v44;
          *(_DWORD *)(a7 + 4) = v44;
        }
      }
LABEL_71:
      int v24 = v55;
      if (!v15) {
        goto LABEL_73;
      }
    }
  }
  else
  {
    IIOBitStreaint m = 0;
  }
  free(v15);
LABEL_73:
  if (v16) {
    free(v16);
  }
  if (v17) {
    free(v17);
  }
  if (v18) {
    free(v18);
  }
  if (v24) {
    free(v24);
  }
  return IIOBitStream;
}

void *_TIFFmalloc(void *result)
{
  if (result) {
    return malloc_type_malloc((size_t)result, 0x2F5D605AuLL);
  }
  return result;
}

void *_TIFFcalloc(size_t a1, size_t a2)
{
  if (a1 && a2) {
    return malloc_type_calloc(a1, a2, 0xF58AE365uLL);
  }
  else {
    return 0;
  }
}

void *_TIFFrealloc(void *a1, size_t a2)
{
  return malloc_type_realloc(a1, a2, 0xCE847D52uLL);
}

size_t unixWarningHandler(const char *a1, const char *a2, va_list a3)
{
  uint64_t v5 = (FILE **)MEMORY[0x1E4F143C8];
  if (a1) {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s: ", a1);
  }
  fwrite("Warning, ", 9uLL, 1uLL, *v5);
  vfprintf(*v5, a2, a3);
  uint64_t v6 = *v5;

  return fwrite(".\n", 2uLL, 1uLL, v6);
}

size_t unixErrorHandler(const char *a1, char *a2, va_list a3)
{
  uint64_t v5 = (FILE **)MEMORY[0x1E4F143C8];
  if (a1) {
    fprintf((FILE *)*MEMORY[0x1E4F143C8], "%s: ", a1);
  }
  vfprintf(*v5, a2, a3);
  uint64_t v6 = *v5;

  return fwrite(".\n", 2uLL, 1uLL, v6);
}

void IIO_Reader_MPO::createReadPlugin()
{
}

{
  operator new();
}

void sub_1886F46DC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C400CA8C190);
  _Unwind_Resume(a1);
}

void sub_1886F477C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C400CA8C190);
  _Unwind_Resume(a1);
}

IIOImageRead *IIO_Reader_MPO::createGlobalInfoData(IIO_Reader_MPO *this, IIOImageReadSession *a2)
{
  uint64_t result = IIOImageReadSession::globalInfoForType(a2, *((_DWORD *)this + 6));
  if (result)
  {
    return (IIOImageRead *)GlobalMPOInfo::createDataRepresentation(result);
  }
  return result;
}

void IIO_Reader_MPO::updateGlobalInfo(IIO_Reader_MPO *this, IIOImageReadSession *a2, unsigned __int8 *a3)
{
}

void sub_1886F4868(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4078B77C84);
  _Unwind_Resume(a1);
}

BOOL IIO_Reader_MPO::testHeader(uint64_t a1, unsigned __int8 *a2)
{
  return *a2 == 255 && a2[1] == 216 && a2[2] == 255 && (a2[3] & 0xF0) == 0xE0;
}

uint64_t IIO_Reader_MPO::updateSourceProperties(IIO_Reader_MPO *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  uint64_t v8 = IIOImageReadSession::globalInfoForType(a2, *((_DWORD *)this + 6));
  if (!v8)
  {
    uint64_t v8 = ExamineMPOFile(a2);
    if (!v8) {
      return 4294967246;
    }
  }
  IIONumber::IIONumber((IIONumber *)v11, 1);
  IIODictionary::setObjectForKeyGroup(a3, v12, @"MPFormatVersion", @"{MPO}");
  IIONumber::~IIONumber((IIONumber *)v11);
  Entryuint64_t Count = GlobalMPOInfo::getEntryCount(v8);
  IIONumber::IIONumber((IIONumber *)v11, EntryCount);
  IIODictionary::setObjectForKeyGroup(a3, v12, @"MPNumberOfImages", @"{MPO}");
  IIONumber::~IIONumber((IIONumber *)v11);
  return 0;
}

void sub_1886F49A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_MPO::getImageCount(IIO_Reader_MPO *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  uint64_t v7 = IIOImageReadSession::globalInfoForType(a2, *((_DWORD *)this + 6));
  if (!v7)
  {
    uint64_t v7 = ExamineMPOFile(a2);
    if (!v7)
    {
      uint64_t v8 = 4294967244;
      if (!a5) {
        return v8;
      }
      goto LABEL_4;
    }
  }
  LODWORD(v7) = GlobalMPOInfo::getEntryCount(v7);
  uint64_t v8 = 0;
  if (a5) {
LABEL_4:
  }
    *a5 = v7;
  return v8;
}

BOOL IIO_Reader_MPO::compareOptions(IIO_Reader_MPO *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  memset(v11, 0, sizeof(v11));
  IIODictionary::IIODictionary((IIODictionary *)v11, a2);
  memset(v10, 0, sizeof(v10));
  IIODictionary::IIODictionary((IIODictionary *)v10, a3);
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v11, @"kCGImageSourceSubsampleFactor");
  unsigned int v5 = IIODictionary::getUint32ForKey((IIODictionary *)v10, @"kCGImageSourceSubsampleFactor");
  if (Uint32ForKey <= 1) {
    int v6 = 1;
  }
  else {
    int v6 = Uint32ForKey;
  }
  if (v5 <= 1) {
    int v7 = 1;
  }
  else {
    int v7 = v5;
  }
  BOOL v8 = v6 == v7;
  IIODictionary::~IIODictionary((IIODictionary *)v10);
  IIODictionary::~IIODictionary((IIODictionary *)v11);
  return v8;
}

void sub_1886F4AB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

uint64_t IIO_Reader_MPO::initThumbnail(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t Session = CGImagePluginGetSession(a2);
  Source = (IIOImageReadSession *)CGImageSourceGetSource(Session);
  int v7 = IIOImageReadSession::globalInfoForType(Source, *(_DWORD *)(a1 + 24));
  if (v7)
  {
    BOOL v8 = v7;
    if (GlobalMPOInfo::getEntryCount(v7) > a3)
    {
      EntryAtIndex = (_MPEntry *)GlobalMPOInfo::getEntryAtIndex(v8, a3);
      if (EntryAtIndex)
      {
        int v10 = EntryAtIndex;
        unsigned int v11 = _MPEntry::imageSize(EntryAtIndex);
        uint64_t v12 = _MPEntry::imageOffset(v10);
        uint64_t v13 = v12 ? IIOImageSource::cf(v8) + v12 : 0;
        uint64_t v16 = 0;
        size_t v14 = IIOImageReadSession::retainBytePointer(Source, (const __CFData **)&v16, 1);
        if (v14)
        {
          if ((IIOImageRead *)((unint64_t)v14 + v13 + v11) <= (IIOImageRead *)((char *)IIOImageReadSession::getSize(Source)
                                                                                     + (void)v14))
            operator new();
          if (v16) {
            IIOImageReadSession::releaseBytePointer((IIOImageRead **)Source, v16);
          }
        }
      }
    }
  }
  return 4294967245;
}

void sub_1886F4DB4(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1091C40E2C72B4ELL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_MPO::hasCustomImageCountProc(IIO_Reader_MPO *this)
{
  return 1;
}

uint64_t IIO_Reader_MPO::hasCustomCompareOptionsProc(IIO_Reader_MPO *this)
{
  return 1;
}

uint64_t IIO_Reader_MPO::hasCustomSourcePropertiesProc(IIO_Reader_MPO *this)
{
  return 1;
}

uint64_t IIO_Reader_MPO::hasCustomThumbnailProc(IIO_Reader_MPO *this)
{
  return 1;
}

void add_points_to_path(CGPath *a1, const CGPoint *a2, unint64_t a3, int a4)
{
  if (a3)
  {
    CGPathMoveToPoint(a1, 0, a2[1].x, 1.0 - a2[1].y);
    if (a3 >= 3)
    {
      uint64_t v8 = 0;
      p_y = &a2[2].y;
      do
      {
        if (a3 - 3 == v8) {
          uint64_t v10 = 0;
        }
        else {
          uint64_t v10 = v8 + 3;
        }
        CGPathAddCurveToPoint(a1, 0, *(p_y - 1), 1.0 - *p_y, a2[v10].x, 1.0 - a2[v10].y, a2[(v8 + 4) % a3].x, 1.0 - a2[(v8 + 4) % a3].y);
        unint64_t v11 = v8 + 5;
        p_y += 6;
        v8 += 3;
      }
      while (v11 < a3);
    }
    if (a4)
    {
      CGPathCloseSubpath(a1);
    }
  }
}

double read_point(unsigned __int8 *a1, unint64_t *a2)
{
  double result = (float)((float)(int)bswap32(*(_DWORD *)&a1[*a2 + 4]) * 0.000000059605);
  *a2 += 8;
  return result;
}

void *KTXReadPlugin::KTXReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  double result = (void *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *double result = &unk_1ED4E02B8;
  return result;
}

void KTXReadPlugin::KTXReadPlugin(uint64_t a1, uint64_t a2)
{
}

void KTXReadPlugin::~KTXReadPlugin(KTXReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t KTXReadPlugin::loadDataFromXPCObject(KTXReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_ktx", &length);
    if (length == 80)
    {
      int v6 = data;
      uint64_t result = 0;
      *(_OWORD *)((char *)this + 440) = *v6;
      long long v7 = v6[1];
      long long v8 = v6[2];
      long long v9 = v6[4];
      *(_OWORD *)((char *)this + 488) = v6[3];
      *(_OWORD *)((char *)this + 504) = v9;
      *(_OWORD *)((char *)this + 45jp2_colour_converter::clear(this + 6) = v7;
      *(_OWORD *)((char *)this + 472) = v8;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t KTXReadPlugin::saveDataToXPCObject(KTXReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_ktx", (char *)this + 440, 0x50uLL);
  }
  return v4;
}

uint64_t KTXReadPlugin::initialize(KTXReadPlugin *this, IIODictionary *a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  long long v33 = 0u;
  long long v34 = 0u;
  int8x16_t __dst = 0u;
  long long v32 = 0u;
  uint64_t v30 = 0;
  memset(v29, 0, sizeof(v29));
  IIOScanner::IIOScanner((IIOScanner *)v29, *((IIOImageReadSession **)this + 3));
  if (!*((unsigned char *)this + 341) || IIOScanner::getBytesAtOffset((IIOScanner *)v29, &__dst, 0, 0x40uLL) != 64) {
    goto LABEL_58;
  }
  SwapKTXHeader(&__dst);
  char v3 = __dst.i32[3] == 67305985;
  *((unsigned char *)this + 344) = __dst.i32[3] == 67305985;
  GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v29, v3);
  *((_WORD *)this + 159) = 0;
  unsigned int v4 = IIODictionary::containsKey(*((IIODictionary **)this + 6), @"kCGImageSourceMipmapLevel");
  unsigned int v5 = (IIODictionary *)*((void *)this + 6);
  if (v4)
  {
    LOWORD(vjp2_colour_converter::clear(this + 6) = (unsigned __int16)IIODictionary::getUint32ForKey(v5, @"kCGImageSourceMipmapLevel");
  }
  else
  {
    if ((IIODictionary::containsKey(v5, @"kCGImageSourceSubsampleFactor") & 1) == 0)
    {
      LOWORD(vjp2_colour_converter::clear(this + 6) = *((_WORD *)this + 159);
      goto LABEL_12;
    }
    unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(*((IIODictionary **)this + 6), @"kCGImageSourceSubsampleFactor");
    if (Uint32ForKey) {
      double v8 = log2((double)Uint32ForKey);
    }
    else {
      double v8 = 0.0;
    }
    int v6 = (int)v8;
  }
  *((_WORD *)this + 159) = v6;
LABEL_12:
  if (DWORD2(v34) <= (unsigned __int16)v6)
  {
    LOWORD(v9) = WORD4(v34) - 1;
    if (!DWORD2(v34)) {
      LOWORD(v9) = 0;
    }
    *((_WORD *)this + 159) = v9;
    unsigned int v9 = (unsigned __int16)v9;
  }
  else
  {
    unsigned int v9 = (unsigned __int16)v6;
  }
  *(uint32x2_t *)((char *)this + 228) = vshl_u32(*(uint32x2_t *)((char *)&v33 + 4), (uint32x2_t)vneg_s32(vdup_n_s32(v9)));
  if (v32 == 5131)
  {
    *((unsigned char *)this + 345) = 1;
    __int16 v10 = 16;
  }
  else
  {
    if (v32 != 5126)
    {
      *((_WORD *)this + 120) = 8;
      goto LABEL_23;
    }
    *((unsigned char *)this + 345) = 1;
    __int16 v10 = 32;
  }
  *((_WORD *)this + 120) = v10;
  *((unsigned char *)this + 249) = 1;
LABEL_23:
  if (SDWORD2(v32) <= 33318)
  {
    switch(DWORD2(v32))
    {
      case 0x1903:
      case 0x1904:
      case 0x1905:
        *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DBB8]);
        *((_DWORD *)this + 81) = 1196573017;
        *((unsigned char *)this + 24jp2_colour_converter::clear(this + 6) = 0;
        uint64_t v11 = 1;
        *((unsigned char *)this + 249) = 1;
        goto LABEL_28;
      case 0x1906:
        goto LABEL_37;
      case 0x1907:
        uint64_t v16 = (CFStringRef *)MEMORY[0x1E4F1DC98];
        if (*((unsigned char *)this + 345)) {
          uint64_t v16 = (CFStringRef *)MEMORY[0x1E4F1DBE0];
        }
        *((void *)this + 20) = CGColorSpaceCreateWithName(*v16);
        *((_DWORD *)this + 81) = 1380401696;
        *((unsigned char *)this + 24jp2_colour_converter::clear(this + 6) = 5;
        unsigned int v12 = 4;
        uint64_t v11 = 3;
        goto LABEL_41;
      case 0x1908:
        goto LABEL_31;
      case 0x1909:
        goto LABEL_27;
      default:
        if (DWORD2(v32)) {
          goto LABEL_37;
        }
        size_t v14 = "R11_EAC [0x%04X] not handled\n";
        uint64_t v15 = 245;
        switch(HIDWORD(v32))
        {
          case 0x9270:
            goto LABEL_57;
          case 0x9271:
            _cg_jpeg_mem_term("initialize", 248, "SIGNED_R11_EAC [0x%04X] not handled\n");
            break;
          case 0x9272:
            _cg_jpeg_mem_term("initialize", 251, "RG11_EAC [0x%04X] not handled\n");
            break;
          case 0x9273:
            _cg_jpeg_mem_term("initialize", 254, "SIGNED_RG11_EAC [0x%04X] not handled\n");
            break;
          case 0x9274:
            _cg_jpeg_mem_term("initialize", 257, "RGB8_ETC2 [0x%04X] not handled\n");
            break;
          case 0x9275:
            _cg_jpeg_mem_term("initialize", 260, "SRGB8_ETC2 [0x%04X] not handled\n");
            break;
          case 0x9276:
            _cg_jpeg_mem_term("initialize", 263, "RGB8_PUNCHTHROUGH_ALPHA1_ETC2 [0x%04X] not handled\n");
            break;
          case 0x9277:
            _cg_jpeg_mem_term("initialize", 266, "SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 [0x%04X] not handled\n");
            break;
          case 0x9278:
            _cg_jpeg_mem_term("initialize", 269, "RGBA8_ETC2_EAC [0x%04X] not handled\n");
            break;
          case 0x9279:
            _cg_jpeg_mem_term("initialize", 272, "SRGB8_ALPHA8_ETC2_EAC [0x%04X] not handled\n");
            break;
          default:
            if (HIDWORD(v32) == 36196)
            {
              _cg_jpeg_mem_term("initialize", 276, "GL_ETC1_RGB8_OES [0x%04X] not handled\n");
            }
            else
            {
              size_t v14 = "KTX compressed texture [0x%04X] not handled\n";
              uint64_t v15 = 280;
LABEL_57:
              _cg_jpeg_mem_term("initialize", v15, v14, HIDWORD(v32));
            }
            break;
        }
        break;
    }
    goto LABEL_58;
  }
  if ((DWORD2(v32) - 36244) >= 3)
  {
    if (DWORD2(v32) == 33319)
    {
      *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
      *((_DWORD *)this + 81) = 1380401696;
      *((unsigned char *)this + 24jp2_colour_converter::clear(this + 6) = 5;
      unsigned int v12 = 4;
      uint64_t v11 = 2;
      goto LABEL_42;
    }
    if (DWORD2(v32) == 36249)
    {
LABEL_31:
      uint64_t v13 = (CFStringRef *)MEMORY[0x1E4F1DC98];
      if (*((unsigned char *)this + 345)) {
        uint64_t v13 = (CFStringRef *)MEMORY[0x1E4F1DBE0];
      }
      *((void *)this + 20) = CGColorSpaceCreateWithName(*v13);
      *((_DWORD *)this + 81) = 1380401696;
      *((unsigned char *)this + 24jp2_colour_converter::clear(this + 6) = 3;
      unsigned int v12 = 4;
      uint64_t v11 = 4;
    }
    else
    {
LABEL_37:
      _cg_jpeg_mem_term("initialize", 287, "*** ERROR: KTX ktxHeader.glFormat [0x%04X] not handled\n", DWORD2(v32));
      unsigned int v12 = 0;
      uint64_t v11 = 0;
    }
  }
  else
  {
LABEL_27:
    *((void *)this + 20) = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
    *((_DWORD *)this + 81) = 1196573017;
    *((unsigned char *)this + 24jp2_colour_converter::clear(this + 6) = 0;
    uint64_t v11 = 1;
LABEL_28:
    unsigned int v12 = 1;
  }
LABEL_41:
  unsigned int v17 = *((_DWORD *)this + 57);
  uint64_t v18 = *((unsigned int *)this + 58);
  if (v17 * (unint64_t)v12 * v18 > (unint64_t)IIOImageReadSession::getSize(*((IIOImageReadSession **)this
                                                                                          + 3)))
  {
    uint64_t v26 = *((unsigned int *)this + 57);
    uint64_t v27 = *((unsigned int *)this + 58);
    unsigned int Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
    _cg_jpeg_mem_term("initialize", 371, "*** bad KTX: [%ldx%ld] fileSize: %d\n", v26, v27, Size);
LABEL_58:
    kdebug_trace();
    uint64_t v24 = 4294967246;
    goto LABEL_59;
  }
LABEL_42:
  unsigned int v19 = *((unsigned __int16 *)this + 120);
  *((_WORD *)this + 121) = v19 * v12;
  *((_WORD *)this + 122) = v12;
  *((unsigned char *)this + 34jp2_colour_converter::clear(this + 6) = 0;
  long long v20 = v32;
  *(int8x16_t *)((char *)this + 440) = __dst;
  *(_OWORD *)((char *)this + 45jp2_colour_converter::clear(this + 6) = v20;
  long long v21 = v34;
  *(_OWORD *)((char *)this + 472) = v33;
  *(_OWORD *)((char *)this + 488) = v21;
  unint64_t v22 = *((unsigned int *)this + 57) * (unint64_t)v12;
  if ((v22 & 0xFFFFFFFF00000000) != 0) {
    goto LABEL_58;
  }
  unint64_t v23 = v22 * (unint64_t)(v19 >> 3);
  if ((v23 & 0xFFFFFFFF00000000) != 0) {
    goto LABEL_58;
  }
  uint64_t v24 = 0;
  *((_DWORD *)this + 59) = v23;
  *((void *)this + 6++*((_DWORD *)this + 3) = v11;
  *((void *)this + 64) = v12;
  *((_WORD *)this + 188) = 1;
LABEL_59:
  IIOScanner::~IIOScanner((IIOScanner *)v29);
  return v24;
}

void sub_1886F5628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

uint64_t KTXReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12) {
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2);
  }
  if (v2 == 1) {
    return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

unint64_t KTXReadPlugin::calculateOffsetToRequestedImage(KTXReadPlugin *this, unint64_t a2)
{
  int v4 = *((unsigned __int16 *)this + 159);
  unsigned int v9 = 0;
  unsigned int v5 = *((_DWORD *)this + 122);
  if (v4)
  {
    if (v5) {
      int v6 = 1;
    }
    else {
      int v6 = *((_DWORD *)this + 123);
    }
    do
    {
      IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), a2, 0);
      IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), &v9, 4uLL);
      a2 += v9 * v6 + 4;
      --v4;
    }
    while (v4);
  }
  IIOImageReadSession::seek(*((IIOImageReadSession **)this + 3), a2, 0);
  IIOImageReadSession::getBytes(*((IIOImageReadSession **)this + 3), &v9, 4uLL);
  int v7 = v9;
  if (v5) {
    int v7 = v9 / v5;
  }
  return a2 + (*((_DWORD *)this + 52) * v7) + 4;
}

uint64_t KTXReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  int v5 = a3;
  v70[0] = 0;
  vImagePixelCount v8 = *((unsigned int *)this + 65);
  vImagePixelCount v9 = *((unsigned int *)this + 66);
  unint64_t v10 = *((void *)this + 63);
  unint64_t v67 = *((void *)this + 64);
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v11 = *((_DWORD *)this + 51);
    unsigned int v12 = v11 >> 24;
    uint64_t v13 = MEMORY[0x1E4F14390];
    if (v11 < 0)
    {
      int v14 = __maskrune(v12, 0x40000uLL);
      int v11 = *((_DWORD *)this + 51);
    }
    else
    {
      int v14 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v12 + 60) & 0x40000;
    }
    vImagePixelCount v15 = v8;
    if (v14) {
      uint64_t v16 = (v11 >> 24);
    }
    else {
      uint64_t v16 = 46;
    }
    unsigned int v17 = v11 << 8 >> 24;
    vImagePixelCount v18 = v9;
    if (v11 << 8 < 0)
    {
      int v19 = __maskrune(v17, 0x40000uLL);
      int v11 = *((_DWORD *)this + 51);
    }
    else
    {
      int v19 = *(_DWORD *)(v13 + 4 * v17 + 60) & 0x40000;
    }
    unint64_t v20 = v10;
    if (v19) {
      uint64_t v21 = (v11 << 8 >> 24);
    }
    else {
      uint64_t v21 = 46;
    }
    unsigned int v22 = (__int16)v11 >> 8;
    unint64_t v23 = a4;
    if (v11 << 16 < 0)
    {
      int v24 = __maskrune(v22, 0x40000uLL);
      int v11 = *((_DWORD *)this + 51);
    }
    else
    {
      int v24 = *(_DWORD *)(v13 + 4 * v22 + 60) & 0x40000;
    }
    if (v24) {
      uint64_t v25 = ((__int16)v11 >> 8);
    }
    else {
      uint64_t v25 = 46;
    }
    if ((v11 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v13 + 4 * (char)v11 + 60) & 0x40000) != 0) {
        goto LABEL_22;
      }
    }
    else if (__maskrune((char)v11, 0x40000uLL))
    {
LABEL_22:
      int v26 = *((_DWORD *)this + 51);
LABEL_25:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v16, v21, v25, (char)v26, iioTypeStr[a3], "virtual OSStatus KTXReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      a4 = v23;
      unint64_t v10 = v20;
      vImagePixelCount v9 = v18;
      vImagePixelCount v8 = v15;
      int v5 = a3;
      goto LABEL_26;
    }
    LOBYTE(v2jp2_colour_converter::clear(this + 6) = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  uint64_t v27 = (IIOImageRead **)*((void *)this + 3);
  if (v27) {
    IIOImageReadSession::mapData(v27);
  }
  if (v5 == 3)
  {
    uint64_t BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    unsigned int v34 = *((_DWORD *)this + 73);
    double v32 = (double)v34;
    unsigned int v35 = *((_DWORD *)this + 74);
    double v33 = (double)v35;
    unsigned int v36 = ((*((unsigned __int16 *)this + 153) + 7) >> 3) * v34;
    *((_DWORD *)this + 75) = v36;
    memory_object_size_t v31 = v35 * (unint64_t)v36;
    BaseAddress = (char *)_ImageIO_Malloc(v31, *((void *)this + 48), v70, (uint64_t)kImageMalloc_KTX_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (v5 != 1 || !a4 || !*a4) {
      return 0;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = (char *)IOSurfaceGetBaseAddress(*a4);
    size_t Height = IOSurfaceGetHeight(*a4);
    uint64_t BlockArray = 0;
    memory_object_size_t v31 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v70[0] = v31;
    double v32 = 0.0;
    double v33 = 0.0;
  }
  if (BaseAddress)
  {
    if (*((_DWORD *)this + 117) == 37488)
    {
      bzero(BaseAddress, v31);
      int v37 = 0;
LABEL_44:
      char v41 = 1;
      goto LABEL_71;
    }
    int v37 = BaseAddress;
    if (v10 >= v67 || (int v37 = malloc_type_calloc(v9, *((unsigned int *)this + 75), 0x473D2CF1uLL)) != 0)
    {
      unint64_t v38 = KTXReadPlugin::calculateOffsetToRequestedImage(this, *((unsigned int *)this + 125) + 64);
      IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v37, v38, v31);
      if (v10 >= v67) {
        goto LABEL_44;
      }
      size_t v39 = *((unsigned int *)this + 75);
      int v40 = *((_DWORD *)this + 114);
      if (v40 > 5125)
      {
        if (v40 == 5126)
        {
          if (v9)
          {
            for (uint64_t i = 0; i != v9; ++i)
            {
              if (v8)
              {
                int v52 = &BaseAddress[(v39 * i)];
                uint64_t v53 = &v37[(12 * v8 * i)];
                int v54 = v8;
                do
                {
                  int v55 = *((_DWORD *)v53 + 2);
                  *(void *)int v52 = *(void *)v53;
                  *((_DWORD *)v52 + 2) = v55;
                  *((_DWORD *)v52 + ++*((_DWORD *)this + 3) = 1065353216;
                  v53 += 12;
                  v52 += 16;
                  --v54;
                }
                while (v54);
              }
            }
          }
          goto LABEL_70;
        }
        if (v40 == 5131)
        {
          if (v9)
          {
            for (uint64_t j = 0; j != v9; ++j)
            {
              if (v8)
              {
                int v43 = &BaseAddress[(v39 * j)];
                int v44 = &v37[(6 * v8 * j)];
                int v45 = v8;
                do
                {
                  int v46 = *(_DWORD *)v44;
                  *((_WORD *)v43 + 2) = *((_WORD *)v44 + 2);
                  *(_DWORD *)int v43 = v46;
                  *((_WORD *)v43 + ++*((_DWORD *)this + 3) = 15360;
                  v44 += 6;
                  v43 += 8;
                  --v45;
                }
                while (v45);
              }
            }
          }
          goto LABEL_70;
        }
      }
      else
      {
        if (v40 == 5120)
        {
          if (*((_DWORD *)this + 116) == 33319 && v9)
          {
            for (uint64_t k = 0; k != v9; ++k)
            {
              if (v8)
              {
                unsigned __int8 v48 = &BaseAddress[(v39 * k)];
                int v49 = &v37[(2 * v8 * k)];
                int v50 = v8;
                do
                {
                  char *v48 = *v49 ^ 0x80;
                  v48[1] = v49[1] ^ 0x80;
                  *((_WORD *)v48 + 1) = -256;
                  v48 += 4;
                  v49 += 2;
                  --v50;
                }
                while (v50);
              }
            }
          }
          goto LABEL_70;
        }
        if (v40 == 5121)
        {
          dest.data = v37;
          dest.height = v9;
          dest.width = v8;
          dest.rowBytes = (3 * v8 + 3) & 0x7FFFFFFFCLL;
          v68.data = BaseAddress;
          v68.height = v9;
          v68.width = v8;
          v68.rowBytes = v39;
          vImageConvert_RGB888toRGBA8888(&dest, 0, 0xFFu, &v68, 0, 0);
LABEL_70:
          char v41 = 0;
LABEL_71:
          if (*((_WORD *)this + 153) == 32 && *((_WORD *)this + 152) == 8)
          {
            vImagePixelCount v56 = *((unsigned int *)this + 74);
            dest.data = BaseAddress;
            dest.height = v56;
            size_t v57 = *((unsigned int *)this + 75);
            dest.width = *((unsigned int *)this + 73);
            dest.rowBytes = v57;
            if (!*((unsigned char *)this + 405))
            {
              LODWORD(v68.data) = 50331906;
              vImagePermuteChannels_ARGB8888(&dest, &dest, (const uint8_t *)&v68, 0x10u);
            }
            if (*((unsigned char *)this + 406) == 1) {
              vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
            }
          }
          if (v5 == 3)
          {
            unint64_t v58 = *((void *)this + 64) * v8 * ((unint64_t)*((unsigned __int16 *)this + 152) >> 3);
            *((_DWORD *)this + 75) = v58;
            uint64_t v59 = 0;
            v71.origin.x = 0.0;
            v71.origin.y = 0.0;
            v71.size.width = v32;
            v71.size.height = v33;
            **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v31, v71, v58, *((unsigned __int8 *)this + 343));
            if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E4F1DB20]))
            {
              uint64_t v60 = 0;
            }
            else
            {
              v72.origin.x = 0.0;
              v72.origin.y = 0.0;
              v72.size.width = v32;
              v72.size.height = v33;
              *(CGRect *)(&v60 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v72);
              uint64_t v59 = v61;
              double v32 = v62;
              double v33 = v63;
            }
            *((void *)this + 15) = v59;
            *((void *)this + 1jp2_colour_converter::clear(this + 6) = v60;
            *((double *)this + 17) = v32;
            *((double *)this + 18) = v33;
          }
          else
          {
            IOSurfaceUnlock(*a4, 0, 0);
          }
          if (v37) {
            char v64 = v41;
          }
          else {
            char v64 = 1;
          }
          if ((v64 & 1) == 0) {
            free(v37);
          }
          return 0;
        }
      }
      _cg_jpeg_mem_term("decodeImageImp", 661, "*** ERROR: glType 0x%04x not handled\n", *((_DWORD *)this + 114));
      goto LABEL_70;
    }
    if (v5 == 3) {
      _ImageIO_Free((unint64_t)BaseAddress, v70[0]);
    }
  }
  return BlockArray;
}

void ___ZN14IIOImageSource14extractOptionsEP13IIODictionary_block_invoke(uint64_t a1, void *value)
{
  if (CFArrayContainsValue(*(CFArrayRef *)(a1 + 32), *(CFRange *)(a1 + 40), value))
  {
    int v4 = *(__CFSet **)(a1 + 56);
    CFSetAddValue(v4, value);
  }
}

void IIOImageSource::updateAllowedflags(IIOImageSource *this, CFSetRef theSet)
{
  int Count = CFSetGetCount(theSet);
  *((void *)this + 9) = 0;
  int v5 = (char *)this + 72;
  *((_DWORD *)v5 - 2) = Count;
  *((void *)v5 + 1) = 0;
  size_t v6 = CFSetGetCount(theSet);
  int v7 = (const void **)malloc_type_calloc(v6, 8uLL, 0x6004044C4A2DFuLL);
  CFSetGetValues(theSet, v7);
  if (v6)
  {
    vImagePixelCount v8 = (CFStringRef *)v7;
    do
    {
      unsigned int v9 = IIOGetIndexForType(*v8);
      unsigned int v10 = v9;
      if (v9 > 0x3F)
      {
        unsigned int v10 = v9 - 64;
        int v11 = (uint64_t *)(v5 + 8);
      }
      else
      {
        int v11 = (uint64_t *)v5;
      }
      IIOSetFlagAtIndex(v11, v10);
      ++v8;
      --v6;
    }
    while (v6);
  }

  free(v7);
}

void IIOImageSource::IIOImageSource(IIOImageSource *this, IIODictionary *a2)
{
  *(void *)this = &unk_1ED4E1420;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 2jp2_colour_converter::clear(this + 6) = 0;
  *((void *)this + 27) = 0;
  IIOImageSource::setup((uint64_t)this, 6);
  if (a2) {
    IIOImageSource::extractOptions(this, a2);
  }
}

void sub_1886F5FC8(_Unwind_Exception *exception_object)
{
  int v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 208) = v5;
    operator delete(v5);
  }
  size_t v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 152) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

uint64_t IIOImageSource::imageRead(IIOImageSource *this)
{
  return CGImageSourceGetSource(*((void *)this + 2));
}

uint64_t IIOImageSource::lock(IIOImageSource *this)
{
  return pthread_mutex_lock((pthread_mutex_t *)((char *)this + 224));
}

uint64_t IIOImageSource::unlock(IIOImageSource *this)
{
  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 224));
}

void IIOImageSource::removeImageFromSet(uint64_t a1, IIOImagePlus **a2, const void *a3)
{
  ImageProvider = (IIOImagePlus **)IIOImagePlus::getImageProvider(a2[3]);
  CFIndex Count = CFSetGetCount(*(CFSetRef *)(a1 + 184));
  vImagePixelCount v8 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
  if (v8)
  {
    unsigned int v9 = v8;
    CFSetGetValues(*(CFSetRef *)(a1 + 184), v8);
    if (Count >= 1)
    {
      unsigned int v10 = v9;
      while (*v10 != a3)
      {
        ++v10;
        if (!--Count) {
          goto LABEL_15;
        }
      }
      int v11 = (IIOImagePlus **)*MEMORY[0x1E4F1D260];
      if (ImageProvider && ImageProvider != v11) {
        CFRetain(ImageProvider);
      }
      if (a2 && v11 != a2) {
        CFRetain(a2);
      }
      CFSetRemoveValue(*(CFMutableSetRef *)(a1 + 184), *v10);
    }
LABEL_15:
    free(v9);
  }
}

const void **IIOImageSource::getAllImagePlusValues(CFArrayRef *this, uint64_t *a2)
{
  uint64_t Count = CFArrayGetCount(this[21]);
  int v5 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
  if (v5)
  {
    v7.location = 0;
    v7.size_t length = Count;
    CFArrayGetValues(this[21], v7, v5);
  }
  *a2 = Count;
  return v5;
}

uint64_t IIOImageSource::incrementalDataUpdated(IIOImageSource *this)
{
  return *((unsigned __int8 *)this + 33);
}

const char *IIOImageSource::updateDataProvider(IIOImageSource *this, CGDataProvider *a2, CGDataProvider *a3)
{
  Source = (IIOImageRead *)CGImageSourceGetSource(*((void *)this + 2));
  CFRange v7 = Source;
  if (Source && IIOImageRead::isFinal(Source))
  {
    return LogError("updateDataProvider", 861, "*** ERROR: image source was already finalized\n");
  }
  else
  {
    if ((gIIODebugFlags & 0x10000000) != 0)
    {
      CFDataRef v9 = CGDataProviderCopyData(a2);
      if (v9)
      {
        CFDataRef v10 = v9;
        if (a3) {
          int v11 = "imageDataProviderProg-final";
        }
        else {
          int v11 = "imageDataProviderProg-part";
        }
        ImageIO_saveImageData(v11, v10);
        CFRelease(v10);
      }
    }
    if (v7)
    {
      uint64_t result = (const char *)IIOImageRead::updateDataProvider(v7, a2, (int)a3);
    }
    else
    {
      uint64_t result = (const char *)CGImageReadCreateWithProvider(*((void *)this + 1), a2, a3);
      *((void *)this + 2) = result;
    }
    if ((gIIODebugFlags & 0x2000000000) != 0)
    {
      unsigned int v12 = "NO ";
      if (a3) {
        unsigned int v12 = "YES";
      }
      uint64_t result = ImageIOLog("    %s - isr=%p  provider=%p   final=%s\n", "updateDataProvider", *((const void **)this + 1), a2, v12);
    }
    *((_WORD *)this + 1jp2_colour_converter::clear(this + 6) = 256;
    if (a3)
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 288));
      *((_DWORD *)this + 28) = 0;
      return (const char *)pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 288));
    }
  }
  return result;
}

uint64_t IIOImageSource::setStatus(IIOImageSource *this, CGImageSourceStatus a2)
{
  int v4 = (pthread_mutex_t *)((char *)this + 288);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 288));
  *((_DWORD *)this + 28) = a2;

  return pthread_mutex_unlock(v4);
}

const char *IIOImageSource::updateData(IIOImageSource *this, const __CFData *a2, __CFData *a3)
{
  Source = (IIOImageRead *)CGImageSourceGetSource(*((void *)this + 2));
  CFRange v7 = Source;
  if (Source && IIOImageRead::isFinal(Source))
  {
    return LogError("updateData", 907, "*** ERROR: image source was already finalized\n");
  }
  if ((gIIODebugFlags & 0x10000000) != 0)
  {
    if (a3) {
      CFDataRef v9 = "imageDataProg-final";
    }
    else {
      CFDataRef v9 = "imageDataProg-part";
    }
    ImageIO_saveImageData(v9, a2);
  }
  if (v7)
  {
    unint64_t v10 = *((void *)this + 5);
    uint64_t result = (const char *)CFDataGetLength(a2);
    if (v10 > (unint64_t)result) {
      goto LABEL_22;
    }
    *((void *)this + 5) = CFDataGetLength(a2);
    uint64_t result = (const char *)IIOImageRead::updateData(v7, a2, (int)a3);
    if ((gIIODebugFlags & 0x2000000000) != 0)
    {
      if (a2) {
        CFDataGetLength(a2);
      }
      uint64_t result = ImageIOLog("    %s - update - isr=%p  rref=%p  data=%p  size=%8ld  final=%s\n");
    }
  }
  else
  {
    *((void *)this + 5) = CFDataGetLength(a2);
    uint64_t result = (const char *)CGImageReadCreateWithData(*((void *)this + 1), a2, a3);
    *((void *)this + 2) = result;
    if ((gIIODebugFlags & 0x2000000000) != 0)
    {
      if (a2) {
        CFDataGetLength(a2);
      }
      uint64_t result = ImageIOLog("    %s - new    - isr=%p  rref=%p  data=%p  size=%8ld  final=%s\n");
    }
  }
  *((_WORD *)this + 1jp2_colour_converter::clear(this + 6) = 256;
LABEL_22:
  if (a3)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 288));
    *((_DWORD *)this + 28) = 0;
    return (const char *)pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 288));
  }
  return result;
}

uint64_t IIOImageSource::imageSourceType(IIOImageSource *this)
{
  return *((unsigned __int8 *)this + 54);
}

uint64_t IIOImageSource::updateReader(uint64_t this, IIO_Reader *a2)
{
  if (a2)
  {
    if (*(void *)(this + 104)) {
      *(void *)(this + 104) = a2;
    }
  }
  return this;
}

uint64_t IIOImageSource::imageDataDidNotMatchRequestedHint(IIOImageSource *this)
{
  return *((unsigned __int8 *)this + 89);
}

uint64_t IIOImageSource::errorStatus(IIOImageSource *this)
{
  return *((unsigned int *)this + 88);
}

uint64_t IIOImageSource::shouldExposeMultiFrameContents(IIOImageSource *this)
{
  return *((unsigned __int8 *)this + 50);
}

uint64_t IIOImageSource::useImageSequence(IIOImageSource *this)
{
  return *((unsigned __int8 *)this + 52);
}

uint64_t IIOImageSource::canAnimate(IIO_Reader **this)
{
  if (!IIOImageSource::bindToReader((IIOImageSource *)this)) {
    return 4294967292;
  }
  CFStringRef v2 = (const __CFString *)IIO_Reader::utType(this[13]);
  if (!v2) {
    return 4294967292;
  }
  CFStringRef v3 = v2;
  if (CFStringCompare(v2, @"com.compuserve.gif", 0)
    && CFStringCompare(v3, @"public.png", 0)
    && CFStringCompare(v3, @"public.heics", 0)
    && CFStringCompare(v3, @"public.avis", 0)
    && CFStringCompare(v3, @"org.webmproject.webp", 0)
    && CFStringCompare(v3, @"public.jpeg-xl", 0))
  {
    return 4294967292;
  }
  else
  {
    return 0;
  }
}

uint64_t IIOImageSource::getType(IIO_Reader **this)
{
  if (!IIOImageSource::bindToReader((IIOImageSource *)this)) {
    return 0;
  }
  CFStringRef v2 = this[13];

  return IIO_Reader::utType(v2);
}

uint64_t IIOImageSource::isCloudTranscodable(IIO_Reader **this, const __CFDictionary **a2)
{
  if (!IIOImageSource::bindToReader((IIOImageSource *)this)
    || (CFStringRef v4 = (const __CFString *)IIO_Reader::utType(this[13])) == 0)
  {
    _cg_jpeg_mem_term("isCloudTranscodable", 1236, "*** can't get image source type\n");
    return 4294967292;
  }
  CFStringRef v5 = v4;
  if (CFStringCompare(v4, @"public.jpeg", 0))
  {
    if (CFEqual(v5, @"public.heic")) {
      return 0;
    }
    uint64_t v6 = 4294967292;
    if (CFStringCompare(v5, @"public.heics", 0))
    {
      if (CFStringCompare(v5, @"public.png", 0)) {
        return 4294967292;
      }
      else {
        return 0;
      }
    }
    return v6;
  }
  vImagePixelCount v8 = IIOImageSource::copyPropertiesAtIndex((IIOImageSource *)this, 0, a2);
  if (!v8) {
    return 4294967292;
  }
  CFDataRef v9 = v8;
  memset(v11, 0, sizeof(v11));
  IIODictionary::IIODictionary((IIODictionary *)v11, (const __CFDictionary *)v8);
  CFStringRef ObjectForKey = (const __CFString *)IIODictionary::getObjectForKey((IIODictionary *)v11, @"ColorModel");
  if (CFStringCompare(ObjectForKey, @"Gray", 0) && CFStringCompare(ObjectForKey, @"RGB", 0)) {
    uint64_t v6 = 4294967292;
  }
  else {
    uint64_t v6 = 0;
  }
  CFRelease(v9);
  IIODictionary::~IIODictionary((IIODictionary *)v11);
  return v6;
}

void sub_1886F6888(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CGImage *IIOImageSource::CGImageGetHash(IIOImageSource *this, CGImage *a2)
{
  CFNumberRef Property = (const __CFNumber *)CGImageGetProperty();
  if (Property)
  {
    IIONumber::IIONumber((IIONumber *)v15, Property);
    Hash = (CGImage *)IIONumber::uint64Num((IIONumber *)v15);
LABEL_3:
    IIONumber::~IIONumber((IIONumber *)v15);
    return Hash;
  }
  DataProvider = CGImageGetDataProvider(this);
  if (!DataProvider)
  {
    _cg_jpeg_mem_term("CGImageGetHash", 1294, "*** ERROR: cannot get CGDataProvider from image\n");
    return 0;
  }
  Hash = (CGImage *)IIOHashForDataProvider(DataProvider, (unint64_t)a2);
  if (Hash)
  {
    Masuint64_t k = (IIOImageSource *)CGImageGetMask();
    if (Mask) {
      Hash = (CGImage *)IIOImageSource::CGImageGetHash(Mask, Hash, v9);
    }
    ColorSpace = CGImageGetColorSpace(this);
    if (CGColorSpaceGetModel(ColorSpace) == kCGColorSpaceModelIndexed)
    {
      CFDataRef v11 = (const __CFData *)CGColorSpaceCopyColorTable();
      if (v11)
      {
        CFDataRef v12 = v11;
        CFIndex Length = CFDataGetLength(v11);
        BytePtr = CFDataGetBytePtr(v12);
        if (BytePtr && Length) {
          Hash = (CGImage *)IIOHashForBuffer(BytePtr, Length, (unint64_t)Hash);
        }
        CFRelease(v12);
      }
    }
    memset(v15, 0, sizeof(v15));
    IIONumber::IIONumber((IIONumber *)v15, (uint64_t)Hash);
    CGImageSetProperty();
    goto LABEL_3;
  }
  return Hash;
}

void sub_1886F69E8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOImageSource::iPlusGetStatusAtIndex(IIOImageSource *this, unint64_t a2)
{
  if (IIOImageSource::bindToReader(this)) {
    uint64_t Status = *((unsigned int *)this + 28);
  }
  else {
    uint64_t Status = 4294967292;
  }
  ImagePlus = (IIOImagePlus *)IIOImageSource::getImagePlus(this, a2);
  if (ImagePlus)
  {
    uint64_t Status = IIOImagePlus::getStatus(ImagePlus);
    if (Status == -1)
    {
      unint64_t v6 = IIOImageSource::updatedCount(this);
      int v8 = v6 < 2 || v6 - 1 <= a2;
      return (v8 << 31 >> 31);
    }
  }
  return Status;
}

CGImage *IIOImageSource::isColorOptimizedForSharing(CFSetRef *this, const __CFDictionary **a2)
{
  CFIndex Count = CFSetGetCount(this[23]);
  if (Count)
  {
    uint64_t v5 = Count;
    unint64_t v6 = (const void **)malloc_type_malloc(8 * Count, 0x2004093837F09uLL);
    if (v6)
    {
      CFRange v7 = v6;
      CFSetGetValues(this[23], v6);
      if (v5 < 1) {
        int IsOptimizedForSharing = 0;
      }
      else {
        int IsOptimizedForSharing = CGImageIsOptimizedForSharing();
      }
      free(v7);
    }
    else
    {
      int IsOptimizedForSharing = 0;
    }
    return (CGImage *)(IsOptimizedForSharing != 0);
  }
  else
  {
    uint64_t result = IIOImageSource::createImageAtIndex((IIOImageSource *)this, 0, a2, 0);
    if (result)
    {
      unint64_t v10 = result;
      uint64_t v11 = CGImageIsOptimizedForSharing();
      CGImageRelease(v10);
      return (CGImage *)v11;
    }
  }
  return result;
}

CFDictionaryRef IIOImageSource::copyProperties(IIOImageSource *this, IIODictionary *a2)
{
  CFDictionaryRef result = (CFDictionaryRef)IIOImageSource::getProperties(this, a2);
  if (result)
  {
    CFDictionaryRef v3 = (const __CFDictionary *)*((void *)result + 1);
    CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    return CFDictionaryCreateCopy(v4, v3);
  }
  return result;
}

uint64_t IIOImageSource::copyMetadataAtIndex(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3)
{
  if (!IIOImageSource::bindToReader(this)) {
    return 0;
  }
  uint64_t ImagePlus = IIOImageSource::makeImagePlus(this, a2, a3);
  CFRange v7 = ImagePlus
     ? (const void *)IIOImagePlus::getMetadata(*(IIOImagePlus **)(ImagePlus + 24))
     : IIOImageSource::getImageMetadataAtIndex((CFArrayRef *)this, a2);
  if (!v7 || v7 == (const void *)*MEMORY[0x1E4F1D260]) {
    return 0;
  }

  return CGImageMetadataCreateImmutableCopy((uint64_t)v7);
}

const void *IIOImageSource::getImageMetadataAtIndex(CFArrayRef *this, CFIndex a2)
{
  unsigned int Count = CFArrayGetCount(this[22]);
  if (a2 >= Count)
  {
    _cg_jpeg_mem_term("getImageMetadataAtIndex", 4002, "getImageMetadataAtIndex index (%d) larger than arrayCount (%d)\n", a2, Count);
    return 0;
  }
  else
  {
    CFDictionaryRef result = CFArrayGetValueAtIndex(this[22], a2);
    if (result == (const void *)*MEMORY[0x1E4F1D260]) {
      return 0;
    }
  }
  return result;
}

__CFArray *IIOImageSource::copyMetadataPropertiesAtIndex(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3, unsigned int *a4)
{
  if (!IIOImageSource::bindToReader(this)) {
    return 0;
  }
  uint64_t ImagePlus = IIOImageSource::makeImagePlus(this, a2, a3);
  unint64_t v9 = ImagePlus
     ? (void *)IIOImagePlus::getMetadata(*(IIOImagePlus **)(ImagePlus + 24))
     : IIOImageSource::getImageMetadataAtIndex((CFArrayRef *)this, a2);
  uint64_t v10 = (uint64_t)v9;
  if (!v9) {
    return 0;
  }
  TagWithPath = CGImageMetadataGetTagWithPath(v9, 0, @"tiff:Orientation");
  if (a4)
  {
    CFNumberRef Value = (const __CFNumber *)CGImageMetadataTagGetValue((uint64_t)TagWithPath);
    IIONumber::IIONumber((IIONumber *)v14, Value);
    *a4 = IIONumber::uint16Num((IIONumber *)v14);
    IIONumber::~IIONumber((IIONumber *)v14);
  }
  return CGImageMetadataCreateMetadataProperties(v10);
}

void sub_1886F6D80(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOImageSource::imageSourceCanBeUsedForJPEGResize(IIOImageSource *this, unsigned int a2)
{
  *gCrashMessage = 0;
  snprintf(gCrashMessage, 0x200uLL, "ImageIO: imageSourceCanBeUsedForJPEGResize: <CGImageSourceRef:%p> <CGImageReadRef:%p>\n", *((const void **)this + 1), *((const void **)this + 2));
  qword_1EB2BF498 = gCrashMessage;
  CFAllocatorRef v4 = (const void *)*((void *)this + 2);
  if (!v4)
  {
    int v8 = 0;
LABEL_10:
    LogError("imageSourceCanBeUsedForJPEGResize", 2115, "*** ERROR: invalid image source: <CGImageSourceRef:%p>  <CGImageReadRef:%p>", *((const void **)this + 1), v8);
    goto LABEL_11;
  }
  CFTypeID v5 = CFGetTypeID(v4);
  if (v5 != CGImageReadGetTypeID())
  {
    int v8 = (const void *)*((void *)this + 2);
    goto LABEL_10;
  }
  if ((IIOImageSource::bindToReader(this) & 1) == 0)
  {
LABEL_11:
    uint64_t result = 0;
    qword_1EB2BF498 = 0;
    return result;
  }
  uint64_t result = IIO_Reader::utType(*((IIO_Reader **)this + 13));
  qword_1EB2BF498 = 0;
  if (result)
  {
    if (CFStringCompare((CFStringRef)result, @"public.jpeg", 0))
    {
      uint64_t result = (uint64_t)IIOImageSource::isRAWFile(this);
      if (result)
      {
        IIOImageSource::updateThumbnailInfo(this, 0, 0, 0);
        IIOImageSource::getThumbnailInfoAtIndex((uint64_t)this, 0, a2, (uint64_t)v9);
        return v7 == 0;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

const __CFString *IIOImageSource::imageSourceCanBeUsedForHEICResize(IIO_Reader **this)
{
  CFStringRef result = (const __CFString *)IIOImageSource::bindToReader((IIOImageSource *)this);
  if (result)
  {
    CFStringRef result = (const __CFString *)IIO_Reader::utType(this[13]);
    if (result) {
      return (const __CFString *)(CFEqual(result, @"public.heic"));
    }
  }
  return result;
}

void ___ZN14IIOImageSource19updateThumbnailInfoEP13IIODictionaryPjS2__block_invoke(uint64_t a1, const __CFDictionary *a2)
{
  CFDictionaryRef v3 = *(void **)(a1 + 32);
  memset(v34, 0, sizeof(v34));
  IIODictionary::IIODictionary((IIODictionary *)v34, a2);
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v34, @"Width");
  unsigned int v5 = IIODictionary::getUint32ForKey((IIODictionary *)v34, @"Height");
  int v7 = *(_DWORD *)(a1 + 40);
  int v6 = *(_DWORD *)(a1 + 44);
  unsigned __int8 v33 = IIODictionary::getUint32ForKey((IIODictionary *)v34, @"Orientation");
  if (*(unsigned char *)(a1 + 48))
  {
    CFDictionaryRef Uint64ForKey = IIODictionary::getUint64ForKey((IIODictionary *)v34, @"JPEGOffset");
    unsigned int v9 = IIODictionary::getUint32ForKey((IIODictionary *)v34, @"JPEGLength");
    char v10 = 1;
  }
  else
  {
    CFDictionaryRef Uint64ForKey = IIODictionary::getUint64ForKey((IIODictionary *)v34, @"ThumbnailOffset");
    unsigned int v9 = IIODictionary::getUint32ForKey((IIODictionary *)v34, @"ThumbnailSize");
    char v10 = 0;
  }
  unsigned int v11 = *(_DWORD *)(a1 + 40);
  unsigned int v12 = *(_DWORD *)(a1 + 44);
  BOOL v14 = Uint32ForKey == v11 && v5 == v12;
  BOOL v15 = vabdd_f64((double)Uint32ForKey / (double)v5, (double)v11 / (double)v12) > 0.02;
  unint64_t v16 = v3[27];
  unint64_t v17 = v3[26];
  if (v17 >= v16)
  {
    char v32 = v10;
    int v19 = v6;
    uint64_t v20 = v3[25];
    unint64_t v21 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v17 - v20) >> 3);
    unint64_t v22 = v21 + 1;
    if (v21 + 1 > 0x666666666666666) {
      std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v23 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v16 - v20) >> 3);
    if (2 * v23 > v22) {
      unint64_t v22 = 2 * v23;
    }
    if (v23 >= 0x333333333333333) {
      unint64_t v24 = 0x666666666666666;
    }
    else {
      unint64_t v24 = v22;
    }
    if (v24) {
      uint64_t v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIOThumbnailInfo>>((uint64_t)(v3 + 27), v24);
    }
    else {
      uint64_t v25 = 0;
    }
    int v26 = &v25[40 * v21];
    *(void *)int v26 = Uint64ForKey;
    uint64_t v27 = &v25[40 * v24];
    *((_DWORD *)v26 + 2) = v9;
    *((_DWORD *)v26 + ++*((_DWORD *)this + 3) = Uint32ForKey;
    *((_DWORD *)v26 + 4) = v5;
    *((_DWORD *)v26 + 5) = v7;
    *((_DWORD *)v26 + jp2_colour_converter::clear(this + 6) = v19;
    *((_DWORD *)v26 + 7) = 0;
    v26[32] = v33;
    v26[33] = v32;
    v26[34] = v14;
    v26[35] = v15;
    *((_DWORD *)v26 + 9) = 0;
    vImagePixelCount v18 = v26 + 40;
    int v29 = (char *)v3[25];
    uint64_t v28 = (char *)v3[26];
    if (v28 != v29)
    {
      do
      {
        long long v30 = *(_OWORD *)(v28 - 40);
        long long v31 = *(_OWORD *)(v28 - 24);
        *((void *)v26 - 1) = *((void *)v28 - 1);
        *(_OWORD *)(v26 - 24) = v31;
        *(_OWORD *)(v26 - 40) = v30;
        v26 -= 40;
        v28 -= 40;
      }
      while (v28 != v29);
      uint64_t v28 = (char *)v3[25];
    }
    v3[25] = v26;
    v3[26] = v18;
    v3[27] = v27;
    if (v28) {
      operator delete(v28);
    }
  }
  else
  {
    *(void *)unint64_t v17 = Uint64ForKey;
    *(_DWORD *)(v17 + 8) = v9;
    *(_DWORD *)(v17 + 12) = Uint32ForKey;
    *(_DWORD *)(v17 + 1jp2_colour_converter::clear(this + 6) = v5;
    *(_DWORD *)(v17 + 20) = v7;
    *(_DWORD *)(v17 + 24) = v6;
    *(_DWORD *)(v17 + 28) = 0;
    *(unsigned char *)(v17 + 32) = v33;
    *(unsigned char *)(v17 + 3++*((_DWORD *)this + 3) = v10;
    *(unsigned char *)(v17 + 34) = v14;
    *(unsigned char *)(v17 + 35) = v15;
    vImagePixelCount v18 = (char *)(v17 + 40);
    *(_DWORD *)(v17 + 3jp2_colour_converter::clear(this + 6) = 0;
  }
  v3[26] = v18;
  IIODictionary::~IIODictionary((IIODictionary *)v34);
}

void sub_1886F71DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t IIOImageSource::getImageCacheAtIndex(IIOImageSource *this, unint64_t a2, const __CFDictionary **a3)
{
  if (!IIOImageSource::bindToReader(this)) {
    return 0;
  }
  IIOImageSource::makeImagePlus(this, a2, a3);

  return IIOLookupISR();
}

__IOSurface *IIOImageSource::createIOSurfaceAtIndex(IIOImageSource *this, unint64_t a2, IIODictionary *a3)
{
  int v16 = 0;
  IIODictionary::containsKey(a3, "kCGImageSourceSoftmaskData");
  IIODictionary::containsKey(a3, @"kCGImageSourceColorTransform");
  if (IIODictionary::containsKey(a3, @"kCGImageSourceThumbnailMaxPixelSize"))
  {
    IIODictionary::getUint32ForKey(a3, @"kCGImageSourceThumbnailMaxPixelSize");
    operator new();
  }
  int v7 = IIOImageSource::createImageAtIndex(this, a2, (const __CFDictionary **)a3, &v16);
  if (v7)
  {
    ColorSpace = CGImageGetColorSpace(v7);
    CGColorSpaceModel Model = CGColorSpaceGetModel(ColorSpace);
    if (Model >= kCGColorSpaceModelCMYK)
    {
      _cg_jpeg_mem_term("createIOSurfaceAtIndex", 3148, "*** ERROR: unsupported colorspace (csm=%d)\n", Model);
    }
    else
    {
      if (IIODictionary::containsKey(a3, @"kCGImageSourceUseNativeSurfaceFormat")) {
        BOOL BoolForKey = IIODictionary::getBoolForKey(a3, @"kCGImageSourceUseNativeSurfaceFormat");
      }
      else {
        BOOL BoolForKey = 0;
      }
      if (CGImageGetImageProvider())
      {
        CGImageProviderGetSize();
        operator new();
      }
      _cg_jpeg_mem_term("createIOSurfaceAtIndex", 3225, " CGImageGetImageProvider returned NULL, creating IOSurface from CGImage data.\n");
      if (!BoolForKey)
      {
        IOSurfaceFromImage = IIO_CreateIOSurfaceFromImage(v7, 1380401729);
        if (IOSurfaceFromImage)
        {
          CFTypeRef v11 = IOSurfaceCopyValue(IOSurfaceFromImage, @"IOSurfaceContentHeadroom");
          if (v11)
          {
            CFRelease(v11);
          }
          else
          {
            CGImageGetContentHeadroom();
            if (v12 >= 1.0)
            {
              IIONumber::IIONumber((IIONumber *)v14, v12);
              IOSurfaceSetValue(IOSurfaceFromImage, @"IOSurfaceContentHeadroom", value);
              IIONumber::~IIONumber((IIONumber *)v14);
            }
          }
        }
        goto LABEL_18;
      }
    }
    IOSurfaceFromImage = 0;
LABEL_18:
    CGImageRelease(v7);
    return IOSurfaceFromImage;
  }
  return 0;
}

void sub_1886F779C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

vImage_Error IIOImageSource::mergeSoftmask(IIOImageSource *this, IOSurfaceRef buffer, IIODictionary *a3)
{
  OSType PixelFormat = IOSurfaceGetPixelFormat(buffer);
  if (PixelFormat != 1380401729 && PixelFormat != 1111970369) {
    return 0;
  }
  size_t Width = IOSurfaceGetWidth(buffer);
  size_t Height = IOSurfaceGetHeight(buffer);
  size_t BytesPerRow = IOSurfaceGetBytesPerRow(buffer);
  CFDataRef ObjectForKey = (const __CFData *)IIODictionary::getObjectForKey(a3, "kCGImageSourceSoftmaskData");
  unint64_t Length = CFDataGetLength(ObjectForKey);
  unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(a3, "kCGImageSourceSoftmaskWidth");
  uint64_t v10 = Uint32ForKey;
  size_t v11 = IIODictionary::getUint32ForKey(a3, "kCGImageSourceSoftmaskHeight");
  unsigned int v12 = IIODictionary::getUint32ForKey(a3, "kCGImageSourceSoftmaskRowBytes");
  unsigned int v13 = IIODictionary::getUint32ForKey(a3, "kCGImageSourceSoftmaskBitsPerComponent");
  unsigned int v14 = v13;
  if (v13 <= 8 && (int v15 = 1, ((1 << v13) & 0x116) != 0))
  {
    vImage_Error v16 = 0;
  }
  else
  {
    _cg_jpeg_mem_term("mergeSoftmask", 3274, "*** ERROR: invalid softmask bitsPerComponent: %d (expected 1,2,4, or 8\n", v13);
    int v15 = 0;
    vImage_Error v16 = 4294967246;
  }
  if (v14 <= 8 && ((1 << v14) & 0x116) != 0)
  {
    if (Length < v14 * (unint64_t)v11)
    {
      _cg_jpeg_mem_term("mergeSoftmask", 3279, "*** ERROR: invalid softmask: %ldx%ld  dataSize: %ld\n  expected: %ld   (%d bpc)", Uint32ForKey, v11, Length, v14 * (unint64_t)v11, v14);
      return 4294967246;
    }
  }
  else if (!v15)
  {
    return v16;
  }
  BytePtr = (UInt8 *)CFDataGetBytePtr(ObjectForKey);
  if (v14 > 7)
  {
    vImagePixelCount v18 = 0;
    if (!v11) {
      goto LABEL_28;
    }
    goto LABEL_23;
  }
  vImagePixelCount v18 = malloc_type_calloc(Uint32ForKey, v11, 0x5A362CCFuLL);
  src.data = BytePtr;
  src.height = v11;
  src.width = Uint32ForKey;
  src.rowBytes = v12;
  dest.data = v18;
  dest.height = v11;
  dest.width = Uint32ForKey;
  dest.rowBytes = Uint32ForKey;
  switch(v14)
  {
    case 4u:
      vImageConvert_Planar4toPlanar8(&src, &dest, 0x10u);
      break;
    case 2u:
      vImageConvert_Planar2toPlanar8(&src, &dest, 0x10u);
      break;
    case 1u:
      vImageConvert_Planar1toPlanar8(&src, &dest, 0x10u);
      break;
  }
  BytePtr = (UInt8 *)v18;
  if (v11)
  {
LABEL_23:
    for (uint64_t i = 0; i != v11; ++i)
    {
      if (Uint32ForKey)
      {
        uint64_t v20 = &BytePtr[i * Uint32ForKey];
        unsigned int v21 = Uint32ForKey;
        do
        {
          *uint64_t v20 = ~*v20;
          ++v20;
          --v21;
        }
        while (v21);
      }
    }
  }
LABEL_28:
  src.data = BytePtr;
  src.height = v11;
  src.width = Uint32ForKey;
  src.rowBytes = Uint32ForKey;
  if (Width == Uint32ForKey && Height == v11)
  {
    unint64_t v22 = 0;
    vImagePixelCount v23 = Height;
    vImagePixelCount v24 = Width;
  }
  else
  {
    vImage_Buffer dest = src;
    unint64_t v22 = malloc_type_calloc(Width, Height, 0x902DA051uLL);
    src.data = v22;
    src.height = Height;
    src.width = Width;
    src.rowBytes = Width;
    vImage_Error v16 = vImageScale_Planar8(&dest, &src, 0, 0x10u);
    if (v16)
    {
      _cg_jpeg_mem_term("mergeSoftmask", 3340, "*** ERROR: vImageScale_Planar8 failed - err= %d\n", v16);
      if (!v22) {
        goto LABEL_42;
      }
      goto LABEL_41;
    }
    vImagePixelCount v23 = src.height;
    vImagePixelCount v24 = src.width;
  }
  if (v24 != Width || v23 != Height)
  {
    _cg_jpeg_mem_term("mergeSoftmask", 3347, "*** ERROR: invalid dimesions:  alpha: %ldx%ld   surface: %ldx%ld", v10, v11, Length, v11 * (unint64_t)v10);
    vImage_Error v16 = 4294967246;
    if (!v22) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  if (!IOSurfaceLock(buffer, 0, 0))
  {
    dest.data = IOSurfaceGetBaseAddress(buffer);
    dest.height = Height;
    dest.width = Width;
    dest.rowBytes = BytesPerRow;
    vImage_Error v16 = vImageOverwriteChannels_ARGB8888(&src, &dest, &dest, 1u, 0x10u);
    if (v16) {
      _cg_jpeg_mem_term("mergeSoftmask", 3357, "*** ERROR: vImageOverwriteChannels_ARGB8888 failed - err= %d\n", v16);
    }
    vImageClipToAlpha_RGBA8888(&dest, &dest, 0x10u);
    IOSurfaceUnlock(buffer, 0, 0);
    if (!v22) {
      goto LABEL_42;
    }
    goto LABEL_41;
  }
  vImage_Error v16 = 0;
  if (v22) {
LABEL_41:
  }
    free(v22);
LABEL_42:
  if (v18) {
    free(v18);
  }
  return v16;
}

uint64_t ___ZN14IIOImageSource14getCacheValuesEP13IIODictionaryPbS2__block_invoke()
{
  uint64_t v0 = "enabled";
  if ((((unint64_t)gIIODebugFlags >> 30) & 1) == 0) {
    uint64_t v0 = "disabled";
  }
  return _cg_jpeg_mem_term("getCacheValues_block_invoke", 3535, ">>> IMAGEIO_ENABLE_CACHE was set to: %d = caching is %s for all images\n", ((unint64_t)gIIODebugFlags >> 30) & 1, v0);
}

uint64_t IIOImageSource::copyAuxiliaryDataInfoAtIndex(IIOImageSource *this, unint64_t a2, __CFString *a3, IIODictionary *a4)
{
  IIO_LoadCMPhotoSymbols();
  if (CFEqual(@"kCGImageAuxiliaryDataTypeDisparity", a3))
  {
    int v8 = *(__CFString **)gIIO_kCMPhotoAuxiliaryImageTypeURN_Depth;
    uint64_t v9 = *(void *)gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Depth;
    uint64_t v10 = 1;
    goto LABEL_32;
  }
  if (CFEqual(@"kCGImageAuxiliaryDataTypeDepth", a3))
  {
    int v8 = *(__CFString **)gIIO_kCMPhotoAuxiliaryImageTypeURN_Depth;
    uint64_t v9 = *(void *)gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Depth;
    uint64_t v10 = 2;
    goto LABEL_32;
  }
  if (CFEqual(@"kCGImageAuxiliaryDataTypeAlpha", a3))
  {
    int v8 = *(__CFString **)gIIO_kCMPhotoAuxiliaryImageTypeURN_Alpha;
    uint64_t v9 = *(void *)gIIO_kCMPhotoAuxiliaryImageTypeURN_MIAF_Alpha;
    uint64_t v10 = 3;
    goto LABEL_32;
  }
  if (CFEqual(@"kCGImageAuxiliaryDataTypePortraitEffectsMatte", a3))
  {
    uint64_t v9 = 0;
    int v8 = *(__CFString **)gIIO_kCMPhotoAuxiliaryImageTypeURN_PortraitEffectsMatte;
    uint64_t v10 = 5;
    goto LABEL_32;
  }
  if (CFStringCompare(@"kCGImageAuxiliaryDataTypeSemanticSegmentationSkinMatte", a3, 0))
  {
    if (CFStringCompare(@"kCGImageAuxiliaryDataTypeSemanticSegmentationHairMatte", a3, 0))
    {
      if (CFStringCompare(@"kCGImageAuxiliaryDataTypeSemanticSegmentationTeethMatte", a3, 0))
      {
        if (CFStringCompare(@"kCGImageAuxiliaryDataTypeSemanticSegmentationGlassesMatte", a3, 0))
        {
          if (CFStringCompare(@"kCGImageAuxiliaryDataTypeSemanticSegmentationSkyMatte", a3, 0))
          {
            if (CFStringCompare(@"kCGImageAuxiliaryDataTypeHDRGainMap", a3, 0))
            {
              int v8 = @"kCGImageAuxiliaryDataTypeISOGainMap";
              if (CFEqual(@"kCGImageAuxiliaryDataTypeISOGainMap", a3))
              {
                uint64_t v9 = 0;
                uint64_t v10 = 98;
                goto LABEL_32;
              }
              goto LABEL_30;
            }
            char v12 = 0;
            int v11 = 3;
            unsigned int v13 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_HDRGainMap;
          }
          else
          {
            char v12 = 0;
            int v11 = 2;
            unsigned int v13 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkyMatte;
          }
        }
        else
        {
          char v12 = 0;
          int v11 = 1;
          unsigned int v13 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticGlassesMatte;
        }
      }
      else
      {
        int v11 = 0;
        char v12 = 1;
        unsigned int v13 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticTeethMatte;
      }
    }
    else
    {
      int v11 = 0;
      char v12 = 1;
      unsigned int v13 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticHairMatte;
    }
  }
  else
  {
    int v11 = 0;
    char v12 = 1;
    unsigned int v13 = &gIIO_kCMPhotoAuxiliaryImageTypeURN_SemanticSkinMatte;
  }
  unsigned int v14 = (CFStringRef *)*v13;
  int v8 = (__CFString *)*v14;
  if (*v14)
  {
    CFComparisonResult v15 = CFStringCompare(*v14, @"FIG_STRING_SYMBOL_NOT_FOUND", 0);
    if (v15) {
      char v16 = 1;
    }
    else {
      char v16 = v12;
    }
    if (v16)
    {
      if (v15)
      {
        uint64_t v9 = 0;
        uint64_t v10 = 4;
        goto LABEL_32;
      }
    }
    else
    {
      LogError("copyAuxiliaryDataInfoAtIndex", 3874, "*** ERROR: copyAuxiliaryDataInfoAtIndex - MediaToolbox symbol not found [%d]\n", v11);
    }
LABEL_48:
    CFDictionaryRef v25 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    IIOString::IIOString((IIOString *)&v25, a3);
    vImagePixelCount v24 = (const char *)IIOString::utf8String((IIOString *)&v25);
    LogError("copyAuxiliaryDataInfoAtIndex", 3922, "*** ERROR: unsupported auxiliaryDataType: '%s'\n", v24);
    IIOString::~IIOString((IIOString *)&v25);
    return 0;
  }
LABEL_30:
  if ((IIO_OSAppleInternalBuild() & 1) == 0) {
    goto LABEL_48;
  }
  uint64_t v9 = 0;
  uint64_t v10 = 99;
  int v8 = a3;
LABEL_32:
  if (!IIOImageSource::bindToReader(this)) {
    return 0;
  }
  uint64_t ImagePlus = (IIOImagePlus *)IIOImageSource::getImagePlus(this, a2);
  if (!ImagePlus)
  {
    CFDictionaryRef v25 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    IIODictionary::IIODictionary((IIODictionary *)&v25);
    uint64_t v23 = IIOImageSource::makeImagePlus(this, a2, &v25);
    if (v23)
    {
      uint64_t ImagePlus = *(IIOImagePlus **)(v23 + 24);
      IIODictionary::~IIODictionary((IIODictionary *)&v25);
      if (ImagePlus) {
        goto LABEL_34;
      }
    }
    else
    {
      IIODictionary::~IIODictionary((IIODictionary *)&v25);
    }
    return 0;
  }
LABEL_34:
  uint64_t Plugin = IIOImagePlus::readPlugin(ImagePlus);
  if (!Plugin) {
    goto LABEL_52;
  }
  uint64_t v19 = Plugin;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, __CFString *, IIODictionary *))(*(void *)Plugin + 168))(Plugin, v10, v8, a4);
  if (!result && v9 != 0) {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, IIODictionary *))(*(void *)v19 + 168))(v19, v10, v9, a4);
  }
  if (!result)
  {
LABEL_52:
    if ((*(unsigned int (**)(void))(**((void **)this + 13) + 192))(*((void *)this + 13)))
    {
      uint64_t v22 = IIOImageSource::cf(ImagePlus);
      return (*(uint64_t (**)(void, uint64_t, unint64_t, __CFString *))(**((void **)this + 13)
                                                                                        + 120))(*((void *)this + 13), v22, a2, a3);
    }
    return 0;
  }
  return result;
}

void sub_1886F810C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

const __CFDictionary *IIOImageSource::getPrimaryImageIndex(IIO_Reader **this)
{
  Properties = (IIODictionary *)IIOImageSource::getProperties((IIOImageSource *)this, 0);
  CFDictionaryRef v3 = this[13];
  if (!v3) {
    return 0;
  }
  if (IIO_Reader::osType(v3) != 1212500291)
  {
    if (IIO_Reader::osType(this[13]) == 1096173894 && Properties != 0) {
      goto LABEL_4;
    }
    return 0;
  }
  if (!Properties) {
    return 0;
  }
LABEL_4:

  return IIODictionary::getUint32ForKey(Properties, @"PrimaryImage");
}

uint64_t IIOImageSource::ignoreJPEGAuxImagesRequest(IIOImageSource *this)
{
  return *((char *)this + 51);
}

void IIOImageSource::animateWithBlock()
{
}

void sub_1886F828C(void *a1)
{
}

void sub_1886F8298(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4081D5CCAALL);
  _Unwind_Resume(a1);
}

IIOImagePlus *IIOImageSource::getAnimationReadPlugin(IIOImageSource *this)
{
  uint64_t result = (IIOImagePlus *)IIOImageSource::getImagePlus(this, 0);
  if (result)
  {
    return (IIOImagePlus *)IIOImagePlus::readPlugin(result);
  }
  return result;
}

CFStringRef _CGImageSourceCopyDescription(void *a1)
{
  if (a1)
  {
    uint64_t v2 = a1[3];
    CFDictionaryRef v3 = "";
    if (v2)
    {
      if (IIOImageSource::isProxy((IIOImageSource *)a1[3])) {
        CFDictionaryRef v3 = "Proxy";
      }
      CFAllocatorRef v4 = *(IIO_Reader **)(v2 + 104);
      if (v4)
      {
        uint64_t v5 = IIO_Reader::utType(v4);
        if (v5) {
          return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CGImageSource%s: %p> %p '%@'", v3, a1, v2, v5);
        }
      }
    }
  }
  else
  {
    uint64_t v2 = 0;
    CFDictionaryRef v3 = "";
  }
  return CFStringCreateWithFormat((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, @"<CGImageSource%s: %p> %p", v3, a1, v2);
}

__CFString *CGImageSourceGetTypeWithExtension(const __CFString *a1)
{
  IIOInitDebugFlags();
  uint64_t v2 = (IIO_ReaderHandler *)((unsigned __int16)gIIODebugFlags >> 14);
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((int)v2, "S", "CGImageSourceGetTypeWithExtension", 0, 0, -1, 0);
  }
  if (!a1) {
    return 0;
  }
  ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v2);

  return IIO_ReaderHandler::typeForPathExtension(ReaderHandler, a1);
}

IIO_Reader *CGImageSourceGetTypeWithDataProvider(uint64_t a1, __CFString *a2, BOOL *a3)
{
  IIOInitDebugFlags();
  int v6 = (IIO_ReaderHandler *)((unsigned __int16)gIIODebugFlags >> 14);
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((int)v6, "S", "CGImageSourceGetTypeWithDataProvider", 0, 0, -1, 0);
  }
  memset(v9, 0, sizeof(v9));
  uint64_t ReaderHandler = IIO_ReaderHandler::GetReaderHandler(v6);
  return IIO_ReaderHandler::typeForDataProvider(ReaderHandler, a1, a2, (uint64_t)v9, a3);
}

IIO_Reader *CGImageSourceGetTypeWithURL(const void *a1, __CFString *a2)
{
  IIOInitDebugFlags();
  CFAllocatorRef v4 = (IIO_ReaderHandler *)((unsigned __int16)gIIODebugFlags >> 14);
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((int)v4, "S", "CGImageSourceGetTypeWithURL", 0, 0, -1, 0);
  }
  long long v7 = 0uLL;
  uint64_t v8 = 0;
  uint64_t ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(v4);
  return IIO_ReaderHandler::typeFromURL(ReaderHandler, a1, a2, &v7);
}

CGImageSourceRef CGImageSourceCreateIncremental(CFDictionaryRef options)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if (options)
  {
    CFTypeID v2 = CFGetTypeID(options);
    if (v2 != CFDictionaryGetTypeID())
    {
      LogError("CGImageSourceCreateIncremental", 4717, "*** ERROR: CGImageSourceCreateIncremental: options parameter is not a CFDictionaryRef - ignoring\n");
      options = 0;
    }
  }
  memset(v4, 0, sizeof(v4));
  IIODictionary::IIODictionary((IIODictionary *)v4, options);
  operator new();
}

void sub_1886F8694(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  MEMORY[0x18C11C0E0](v2, 0x10E1C40A1B1CD90);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImageSourceUpdateDataProvider(CGImageSourceRef isrc, CGDataProviderRef provider, BOOL final)
{
  BOOL v3 = final;
  kdebug_trace();
  IIOInitDebugFlags();
  unsigned int v6 = (gIIODebugFlags >> 12) & 3;
  if (v6) {
    ImageIODebugOptions(v6, "A", "CGImageSourceUpdateDataProvider", 0, 0, -1, 0);
  }
  if (isrc)
  {
    if (provider)
    {
      CFTypeID v7 = CFGetTypeID(isrc);
      if (CGImageSourceGetTypeID::once != -1) {
        dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
      }
      if (v7 == CGImageSourceGetTypeID::id)
      {
        CFTypeID v8 = CFGetTypeID(provider);
        if (v8 == CGDataProviderGetTypeID())
        {
          uint64_t v9 = *((void *)isrc + 3);
          if (v9 && !IIOImageSource::isProxy(*((IIOImageSource **)isrc + 3)))
          {
            pthread_mutex_lock((pthread_mutex_t *)(v9 + 224));
            IIOImageSource::updateDataProvider((IIOImageSource *)v9, provider, (CGDataProvider *)v3);
            uint64_t v10 = *(IIO_Reader **)(v9 + 104);
            if (v10) {
              IIO_Reader::osType(v10);
            }
            Source = (_APP1XMP *)CGImageSourceGetSource(*(void *)(v9 + 16));
            if (Source) {
              _APP1XMP::getXmpData(Source);
            }
            pthread_mutex_unlock((pthread_mutex_t *)(v9 + 224));
          }
        }
        else
        {
          LogError("CGImageSourceUpdateDataProvider", 4759, "*** ERROR: CGImageSourceUpdateDataProvider: dataProvider is not a CGDataProviderRef\n");
        }
      }
      else
      {
        LogError("CGImageSourceUpdateDataProvider", 4758, "*** ERROR: CGImageSourceUpdateDataProvider: source is not a CGImageSourceRef\n");
      }
    }
    else
    {
      LogError("CGImageSourceUpdateDataProvider", 4757, "*** ERROR: CGImageSourceUpdateDataProvider: dataProvider is nil\n");
    }
  }
  else
  {
    LogError("CGImageSourceUpdateDataProvider", 4756, "*** ERROR: CGImageSourceUpdateDataProvider: source is nil\n");
  }

  kdebug_trace();
}

void CGImageSourceUpdateData(CGImageSourceRef isrc, CFDataRef data, BOOL final)
{
  BOOL v3 = final;
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  kdebug_trace();
  IIOInitDebugFlags();
  if ((gIIODebugFlags & 0x3000) == 0) {
    goto LABEL_50;
  }
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  *(_OWORD *)__str = 0u;
  if (!data || CFDataGetLength(data) < 9)
  {
    strcpy(__str, "(NULL)");
    goto LABEL_48;
  }
  BytePtr = CFDataGetBytePtr(data);
  CFIndex Length = CFDataGetLength(data);
  CFTypeID v8 = "NO ";
  if (v3) {
    CFTypeID v8 = "YES";
  }
  uint64_t v42 = v8;
  CFIndex v43 = Length;
  __darwin_ct_rune_t v9 = *BytePtr;
  int v41 = BytePtr[1];
  int v40 = BytePtr[2];
  int v39 = BytePtr[3];
  int v38 = BytePtr[4];
  int v37 = BytePtr[5];
  int v36 = BytePtr[6];
  int v35 = BytePtr[7];
  uint64_t v10 = MEMORY[0x1E4F14390];
  if ((v9 & 0x80) != 0)
  {
    if (__maskrune(v9, 0x40000uLL)) {
      goto LABEL_8;
    }
  }
  else if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * *BytePtr + 60) & 0x40000) != 0)
  {
LABEL_8:
    uint64_t v11 = *BytePtr;
    goto LABEL_12;
  }
  uint64_t v11 = 46;
LABEL_12:
  uint64_t v34 = v11;
  uint64_t v12 = BytePtr[1];
  if ((char)BytePtr[1] < 0)
  {
    if (__maskrune(v12, 0x40000uLL)) {
      goto LABEL_14;
    }
  }
  else if ((*(_DWORD *)(v10 + 4 * v12 + 60) & 0x40000) != 0)
  {
LABEL_14:
    uint64_t v13 = BytePtr[1];
    goto LABEL_17;
  }
  uint64_t v13 = 46;
LABEL_17:
  uint64_t v33 = v13;
  uint64_t v14 = BytePtr[2];
  if ((char)BytePtr[2] < 0)
  {
    if (__maskrune(v14, 0x40000uLL)) {
      goto LABEL_19;
    }
  }
  else if ((*(_DWORD *)(v10 + 4 * v14 + 60) & 0x40000) != 0)
  {
LABEL_19:
    uint64_t v15 = BytePtr[2];
    goto LABEL_22;
  }
  uint64_t v15 = 46;
LABEL_22:
  uint64_t v32 = v15;
  uint64_t v16 = BytePtr[3];
  if ((char)BytePtr[3] < 0)
  {
    if (__maskrune(v16, 0x40000uLL)) {
      goto LABEL_24;
    }
  }
  else if ((*(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000) != 0)
  {
LABEL_24:
    uint64_t v17 = BytePtr[3];
    goto LABEL_27;
  }
  uint64_t v17 = 46;
LABEL_27:
  uint64_t v31 = v17;
  uint64_t v18 = BytePtr[4];
  if ((char)BytePtr[4] < 0)
  {
    if (__maskrune(v18, 0x40000uLL)) {
      goto LABEL_29;
    }
  }
  else if ((*(_DWORD *)(v10 + 4 * v18 + 60) & 0x40000) != 0)
  {
LABEL_29:
    uint64_t v19 = BytePtr[4];
    goto LABEL_32;
  }
  uint64_t v19 = 46;
LABEL_32:
  uint64_t v20 = BytePtr[5];
  if ((char)BytePtr[5] < 0)
  {
    if (__maskrune(v20, 0x40000uLL)) {
      goto LABEL_34;
    }
  }
  else if ((*(_DWORD *)(v10 + 4 * v20 + 60) & 0x40000) != 0)
  {
LABEL_34:
    uint64_t v21 = BytePtr[5];
    goto LABEL_37;
  }
  uint64_t v21 = 46;
LABEL_37:
  uint64_t v22 = BytePtr[6];
  if ((char)BytePtr[6] < 0)
  {
    if (__maskrune(v22, 0x40000uLL)) {
      goto LABEL_39;
    }
  }
  else if ((*(_DWORD *)(v10 + 4 * v22 + 60) & 0x40000) != 0)
  {
LABEL_39:
    uint64_t v23 = BytePtr[6];
    goto LABEL_42;
  }
  uint64_t v23 = 46;
LABEL_42:
  uint64_t v24 = BytePtr[7];
  if ((char)BytePtr[7] < 0)
  {
    if (__maskrune(v24, 0x40000uLL)) {
      goto LABEL_44;
    }
LABEL_46:
    uint64_t v25 = 46;
    goto LABEL_47;
  }
  if ((*(_DWORD *)(v10 + 4 * v24 + 60) & 0x40000) == 0) {
    goto LABEL_46;
  }
LABEL_44:
  uint64_t v25 = BytePtr[7];
LABEL_47:
  snprintf(__str, 0x50uLL, "[%p]-(%ld) final:%s  | %02X %02X %02X %02X  %02X %02X %02X %02X | %c%c%c%c %c%c%c%c", data, v43, v42, v9, v41, v40, v39, v38, v37, v36, v35, v34, v33, v32, v31, v19,
    v21,
    v23,
    v25);
LABEL_48:
  unsigned int v26 = (gIIODebugFlags >> 12) & 3;
  if (v26) {
    ImageIODebugOptions(v26, "A", "CGImageSourceUpdateData", isrc, __str, -1, 0);
  }
LABEL_50:
  if (isrc)
  {
    if (data)
    {
      CFTypeID v27 = CFGetTypeID(isrc);
      if (CGImageSourceGetTypeID::once != -1) {
        dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
      }
      if (v27 == CGImageSourceGetTypeID::id)
      {
        CFTypeID v28 = CFGetTypeID(data);
        if (v28 == CFDataGetTypeID())
        {
          uint64_t v29 = *((void *)isrc + 3);
          if (v29 && !IIOImageSource::isProxy((IIOImageSource *)v29))
          {
            pthread_mutex_lock((pthread_mutex_t *)(v29 + 224));
            IIOImageSource::updateData((IIOImageSource *)v29, data, (__CFData *)v3);
            long long v30 = *(IIO_Reader **)(v29 + 104);
            if (v30) {
              IIO_Reader::osType(v30);
            }
            pthread_mutex_unlock((pthread_mutex_t *)(v29 + 224));
          }
        }
        else
        {
          LogError("CGImageSourceUpdateData", 4814, "*** ERROR: CGImageSourceUpdateData: data is not a CFDataRef\n");
        }
      }
      else
      {
        LogError("CGImageSourceUpdateData", 4813, "*** ERROR: CGImageSourceUpdateData: source is not a CGImageSourceRef\n");
      }
    }
    else
    {
      LogError("CGImageSourceUpdateData", 4812, "*** ERROR: CGImageSourceUpdateData: data is nil\n");
    }
  }
  else
  {
    LogError("CGImageSourceUpdateData", 4811, "*** ERROR: CGImageSourceUpdateData: source is nil\n");
  }
  kdebug_trace();
}

uint64_t CGImageSourceAddProperty(uint64_t a1, const __CFString *a2, const __CFString *a3, const void *a4)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if (a1 && (CFTypeID v8 = *(IIOImageSource **)(a1 + 24)) != 0 && !IIOImageSource::isProxy(v8))
  {
    IIOImageSource::addProperty(v8, a2, a3, a4);
    uint64_t v10 = (IIO_Reader *)*((void *)v8 + 13);
    if (v10) {
      IIO_Reader::osType(v10);
    }
  }
  else
  {
    LogError("CGImageSourceAddProperty", 4934, "image source parameter is nil\n");
  }

  return kdebug_trace();
}

CFDictionaryRef CGImageSourceCopyProperties(CGImageSourceRef isrc, CFDictionaryRef options)
{
  kdebug_trace();
  IIOInitDebugFlags();
  unsigned int v4 = (gIIODebugFlags >> 12) & 3;
  if (v4) {
    ImageIODebugOptions(v4, "A", "CGImageSourceCopyProperties", isrc, 0, -1, options);
  }
  if (!isrc)
  {
    LogError("CGImageSourceCopyProperties", 4952, "*** ERROR: CGImageSourceCopyProperties: source is nil\n");
LABEL_19:
    CFDictionaryRef v9 = 0;
    goto LABEL_20;
  }
  CFTypeID v5 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1) {
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
  }
  if (v5 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceCopyProperties", 4953, "*** ERROR: CGImageSourceCopyProperties: source is not a CGImageSourceRef\n");
    goto LABEL_19;
  }
  if (options)
  {
    CFTypeID v6 = CFGetTypeID(options);
    if (v6 != CFDictionaryGetTypeID())
    {
      LogError("CGImageSourceCopyProperties", 4956, "*** ERROR: CGImageSourceCopyProperties: options parameter is not a CFDictionaryRef - ignoring\n");
      options = 0;
    }
  }
  uint64_t v7 = *((void *)isrc + 3);
  if (!v7) {
    goto LABEL_19;
  }
  memset(v12, 0, sizeof(v12));
  IIODictionary::IIODictionary((IIODictionary *)v12, options);
  pthread_mutex_lock((pthread_mutex_t *)(v7 + 224));
  if (IIOImageSource::isProxy((IIOImageSource *)v7)) {
    CFDictionaryRef v8 = (const __CFDictionary *)IIOImageSource::proxyCopyProperties((IIODictionary **)v7, (IIODictionary *)v12);
  }
  else {
    CFDictionaryRef v8 = IIOImageSource::copyProperties((IIOImageSource *)v7, (IIODictionary *)v12);
  }
  CFDictionaryRef v9 = v8;
  uint64_t v10 = *(IIO_Reader **)(v7 + 104);
  if (v10) {
    IIO_Reader::osType(v10);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v7 + 224));
  IIODictionary::~IIODictionary((IIODictionary *)v12);
LABEL_20:
  kdebug_trace();
  return v9;
}

void sub_1886F90D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CGImage *CGImageSourceIsColorOptimizedForSharing(void *a1, const void *a2)
{
  IIOInitDebugFlags();
  int v4 = (unsigned __int16)gIIODebugFlags >> 14;
  if ((v4 & (gIIODebugFlags >> 12)) != 0) {
    ImageIODebugOptions(v4, "A", "CGImageSourceIsColorOptimizedForSharing", a1, 0, -1, 0);
  }
  if (a1)
  {
    CFTypeID v5 = CFGetTypeID(a1);
    if (CGImageSourceGetTypeID::once != -1) {
      dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
    }
    if (v5 == CGImageSourceGetTypeID::id)
    {
      if (a2)
      {
        CFTypeID v6 = CFGetTypeID(a2);
        if (v6 != CFDictionaryGetTypeID())
        {
          LogError("CGImageSourceIsColorOptimizedForSharing", 5000, "*** ERROR: CGImageSourceIsColorOptimizedForSharing: options parameter is not a CFDictionaryRef - ignoring\n");
          a2 = 0;
        }
      }
      uint64_t v7 = (CFSetRef *)a1[3];
      if (v7 && !IIOImageSource::isProxy((IIOImageSource *)v7))
      {
        memset(v10, 0, sizeof(v10));
        IIODictionary::IIODictionary((IIODictionary *)v10, (const __CFDictionary *)a2);
        CFDictionaryRef v8 = IIOImageSource::isColorOptimizedForSharing(v7, v10);
        IIODictionary::~IIODictionary((IIODictionary *)v10);
        return v8;
      }
    }
    else
    {
      LogError("CGImageSourceIsColorOptimizedForSharing", 4997, "*** ERROR: CGImageSourceIsColorOptimizedForSharing: source is not a CGImageSourceRef\n");
    }
  }
  else
  {
    LogError("CGImageSourceIsColorOptimizedForSharing", 4996, "*** ERROR: CGImageSourceIsColorOptimizedForSharing: source is nil\n");
  }
  return 0;
}

void sub_1886F9260(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImageSourceRemoveCacheAtIndex(CGImageSourceRef isrc, size_t index)
{
  kdebug_trace();
  IIOInitDebugFlags();
  unsigned int v4 = (gIIODebugFlags >> 12) & 3;
  if (v4) {
    ImageIODebugOptions(v4, "A", "CGImageSourceRemoveCacheAtIndex", isrc, 0, index, 0);
  }
  if (isrc)
  {
    CFTypeID v5 = CFGetTypeID(isrc);
    if (CGImageSourceGetTypeID::once != -1) {
      dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
    }
    if (v5 == CGImageSourceGetTypeID::id)
    {
      if (!CGImageSourceIsProxy((uint64_t)isrc))
      {
        uint64_t v6 = *((void *)isrc + 3);
        if (v6)
        {
          uint64_t Source = CGImageSourceGetSource(*(void *)(v6 + 16));
          if (Source) {
            IIOImageRead::removeCacheKey(Source, index);
          }
        }
      }
    }
    else
    {
      LogError("CGImageSourceRemoveCacheAtIndex", 5028, "*** ERROR: CGImageSourceRemoveCacheAtIndex: source is not a CGImageSourceRef\n");
    }
  }
  else
  {
    LogError("CGImageSourceRemoveCacheAtIndex", 5027, "*** ERROR: CGImageSourceRemoveCacheAtIndex: source is nil\n");
  }

  kdebug_trace();
}

uint64_t CGImageSourceGetImageCacheAtIndex(IIOImageSource **a1, unint64_t a2, const __CFDictionary *a3)
{
  IIOInitDebugFlags();
  memset(v12, 0, sizeof(v12));
  IIODictionary::IIODictionary((IIODictionary *)v12, a3);
  IIOPackSrcInputInfo((IIODictionary *)v12, a2);
  kdebug_trace();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceGetImageCacheAtIndex", a1, 0, -1, a3);
  }
  if (!a1)
  {
    LogError("CGImageSourceGetImageCacheAtIndex", 5252, "*** ERROR: CGImageSourceGetImageCacheAtIndex: source is nil\n");
LABEL_12:
    uint64_t ImageCacheAtIndex = 0;
    goto LABEL_18;
  }
  CFTypeID v6 = CFGetTypeID(a1);
  if (CGImageSourceGetTypeID::once != -1) {
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
  }
  if (v6 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceGetImageCacheAtIndex", 5253, "*** ERROR: CGImageSourceGetImageCacheAtIndex: source is not a CGImageSourceRef\n");
    goto LABEL_12;
  }
  if (a3)
  {
    CFTypeID v7 = CFGetTypeID(a3);
    if (v7 != CFDictionaryGetTypeID()) {
      LogError("CGImageSourceGetImageCacheAtIndex", 5256, "*** ERROR: CGImageSourceGetImageCacheAtIndex: options parameter is not a CFDictionaryRef - ignoring\n");
    }
  }
  CFDictionaryRef v8 = a1[3];
  if (!v8)
  {
    uint64_t ImageCacheAtIndex = 0;
    goto LABEL_18;
  }
  if (IIOImageSource::isProxy(a1[3])) {
    goto LABEL_12;
  }
  if (*((unsigned char *)v8 + 89))
  {
    LogError("CGImageSourceGetImageCacheAtIndex", 5263, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    goto LABEL_12;
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)v8 + 224));
  uint64_t ImageCacheAtIndex = IIOImageSource::getImageCacheAtIndex(v8, a2, v12);
  uint64_t v10 = (IIO_Reader *)*((void *)v8 + 13);
  if (v10) {
    IIO_Reader::osType(v10);
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)v8 + 224));
LABEL_18:
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v12);
  return ImageCacheAtIndex;
}

void sub_1886F95CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CGImageMetadataRef CGImageSourceCopyMetadataAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  kdebug_trace();
  IIOInitDebugFlags();
  unsigned int v6 = (gIIODebugFlags >> 12) & 3;
  if (v6) {
    ImageIODebugOptions(v6, "A", "CGImageSourceCopyMetadataAtIndex", isrc, 0, index, options);
  }
  if (!isrc)
  {
    LogError("CGImageSourceCopyMetadataAtIndex", 5343, "*** ERROR: CGImageSourceCopyMetadataAtIndex: source is nil\n");
LABEL_12:
    uint64_t v10 = 0;
    goto LABEL_16;
  }
  CFTypeID v7 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1) {
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
  }
  if (v7 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceCopyMetadataAtIndex", 5344, "*** ERROR: CGImageSourceCopyMetadataAtIndex: source is not a CGImageSourceRef\n");
    goto LABEL_12;
  }
  if (options)
  {
    CFTypeID v8 = CFGetTypeID(options);
    if (v8 != CFDictionaryGetTypeID())
    {
      LogError("CGImageSourceCopyMetadataAtIndex", 5347, "*** ERROR: CGImageSourceCopyMetadataAtIndex: options parameter is not a CFDictionaryRef - ignoring\n");
      options = 0;
    }
  }
  uint64_t v9 = *((void *)isrc + 3);
  if (!v9 || IIOImageSource::isProxy((IIOImageSource *)v9)) {
    goto LABEL_12;
  }
  memset(v13, 0, sizeof(v13));
  IIODictionary::IIODictionary((IIODictionary *)v13, options);
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 224));
  uint64_t v11 = *(IIO_Reader **)(v9 + 104);
  if (v11) {
    IIO_Reader::osType(v11);
  }
  uint64_t v10 = (const CGImageMetadata *)IIOImageSource::copyMetadataAtIndex((IIOImageSource *)v9, index, v13);
  pthread_mutex_unlock((pthread_mutex_t *)(v9 + 224));
  IIODictionary::~IIODictionary((IIODictionary *)v13);
LABEL_16:
  if ((gIIODebugFlags & 0x800000000000) != 0 && !v10) {
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CGImageSourceCopyMetadataAtIndex", 5363, "could not create CGImageMetadataRef");
  }
  kdebug_trace();
  return v10;
}

void sub_1886F980C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

__CFArray *CGImageSourceCopyMetadataPropertiesAtIndex(IIOImageSource **a1, unint64_t a2, const __CFDictionary *a3)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceCopyMetadataPropertiesAtIndex", a1, 0, -1, a3);
  }
  if (!a1)
  {
    LogError("CGImageSourceCopyMetadataPropertiesAtIndex", 5383, "*** ERROR: CGImageSourceCopyMetadataPropertiesAtIndex: source is nil\n");
LABEL_12:
    uint64_t v9 = 0;
    goto LABEL_20;
  }
  CFTypeID v6 = CFGetTypeID(a1);
  if (CGImageSourceGetTypeID::once != -1) {
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
  }
  if (v6 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceCopyMetadataPropertiesAtIndex", 5384, "*** ERROR: CGImageSourceCopyMetadataPropertiesAtIndex: source is not a CGImageSourceRef\n");
    goto LABEL_12;
  }
  if (a3)
  {
    CFTypeID v7 = CFGetTypeID(a3);
    if (v7 != CFDictionaryGetTypeID())
    {
      LogError("CGImageSourceCopyMetadataPropertiesAtIndex", 5387, "*** ERROR: CGImageSourceCopyMetadataPropertiesAtIndex: options parameter is not a CFDictionaryRef - ignoring\n");
      a3 = 0;
    }
  }
  CFTypeID v8 = a1[3];
  if (!v8 || IIOImageSource::isProxy(a1[3])) {
    goto LABEL_12;
  }
  if (*((unsigned char *)v8 + 89))
  {
    LogError("CGImageSourceCopyMetadataPropertiesAtIndex", 5394, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    goto LABEL_12;
  }
  unsigned int v13 = 1;
  pthread_mutex_lock((pthread_mutex_t *)((char *)v8 + 224));
  if (a3)
  {
    memset(v12, 0, sizeof(v12));
    IIODictionary::IIODictionary((IIODictionary *)v12, a3);
    uint64_t v9 = IIOImageSource::copyMetadataPropertiesAtIndex(v8, a2, v12, &v13);
    IIODictionary::~IIODictionary((IIODictionary *)v12);
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v10 = (IIO_Reader *)*((void *)v8 + 13);
  if (v10) {
    IIO_Reader::osType(v10);
  }
  pthread_mutex_unlock((pthread_mutex_t *)((char *)v8 + 224));
LABEL_20:
  if ((gIIODebugFlags & 0x800000000000) != 0 && !v9) {
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CGImageSourceCopyMetadataPropertiesAtIndex", 5409, "*** ERROR: CGImageSourceCopyMetadataPropertiesAtIndex returned NULL\n");
  }
  kdebug_trace();
  return v9;
}

void sub_1886F9A90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

__IOSurface *CGImageSourceCreateIOSurfaceAtIndex(IIOImageSource **a1, unint64_t a2, const __CFDictionary *a3)
{
  IIOInitDebugFlags();
  memset(v12, 0, sizeof(v12));
  IIODictionary::IIODictionary((IIODictionary *)v12, a3);
  IIOPackSrcInputInfo((IIODictionary *)v12, a2);
  kdebug_trace();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceCreateIOSurfaceAtIndex", a1, 0, -1, a3);
  }
  if (a1)
  {
    CFTypeID v6 = CFGetTypeID(a1);
    if (CGImageSourceGetTypeID::once != -1) {
      dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
    }
    if (v6 == CGImageSourceGetTypeID::id)
    {
      if (a3)
      {
        CFTypeID v7 = CFGetTypeID(a3);
        if (v7 != CFDictionaryGetTypeID()) {
          LogError("CGImageSourceCreateIOSurfaceAtIndex", 5439, "*** ERROR: CGImageSourceCreateIOSurfaceAtIndex: options parameter is not a CFDictionaryRef - ignoring\n");
        }
      }
      CFTypeID v8 = a1[3];
      if (v8 && !IIOImageSource::isProxy(a1[3]))
      {
        if (*((unsigned char *)v8 + 89))
        {
          LogError("CGImageSourceCreateIOSurfaceAtIndex", 5446, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
        }
        else
        {
          pthread_mutex_lock((pthread_mutex_t *)((char *)v8 + 224));
          IOSurfaceAtIndex = IIOImageSource::createIOSurfaceAtIndex(v8, a2, (IIODictionary *)v12);
          uint64_t v11 = (IIO_Reader *)*((void *)v8 + 13);
          if (v11) {
            IIO_Reader::osType(v11);
          }
          pthread_mutex_unlock((pthread_mutex_t *)((char *)v8 + 224));
          if (IOSurfaceAtIndex)
          {
            IOSurfaceGetWidth(IOSurfaceAtIndex);
            IOSurfaceGetHeight(IOSurfaceAtIndex);
            IOSurfaceGetPixelFormat(IOSurfaceAtIndex);
            goto LABEL_15;
          }
        }
      }
    }
    else
    {
      LogError("CGImageSourceCreateIOSurfaceAtIndex", 5436, "*** ERROR: CGImageSourceCreateIOSurfaceAtIndex: source is not a CGImageSourceRef\n");
    }
  }
  else
  {
    LogError("CGImageSourceCreateIOSurfaceAtIndex", 5435, "*** ERROR: CGImageSourceCreateIOSurfaceAtIndex: source is nil\n");
  }
  if ((gIIODebugFlags & 0x800000000000) != 0) {
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CGImageSourceCreateIOSurfaceAtIndex", 5460, "could not create IOSurfaceRef");
  }
  IOSurfaceAtIndex = 0;
LABEL_15:
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v12);
  return IOSurfaceAtIndex;
}

void sub_1886F9D04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CGImageSourceStatus CGImageSourceGetStatus(CGImageSourceRef isrc)
{
  kdebug_trace();
  IIOInitDebugFlags();
  unsigned int v2 = (gIIODebugFlags >> 12) & 3;
  if (v2) {
    ImageIODebugOptions(v2, "A", "CGImageSourceGetStatus", isrc, 0, -1, 0);
  }
  if (!isrc)
  {
    LogError("CGImageSourceGetStatus", 5482, "*** ERROR: CGImageSourceGetStatus: source is nil\n");
LABEL_9:
    CGImageSourceStatus v5 = kCGImageStatusInvalidData;
    goto LABEL_17;
  }
  CFTypeID v3 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1) {
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
  }
  if (v3 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceGetStatus", 5483, "*** ERROR: CGImageSourceGetStatus: source is not a CGImageSourceRef\n");
    goto LABEL_9;
  }
  uint64_t v4 = *((void *)isrc + 3);
  if (!v4 || IIOImageSource::isProxy(*((IIOImageSource **)isrc + 3))) {
    goto LABEL_9;
  }
  if (*(unsigned char *)(v4 + 89))
  {
    LogError("CGImageSourceGetStatus", 5488, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    goto LABEL_9;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 224));
  if (IIOImageSource::bindToReader((IIOImageSource *)v4)) {
    CGImageSourceStatus v5 = *(_DWORD *)(v4 + 112);
  }
  else {
    CGImageSourceStatus v5 = kCGImageStatusInvalidData;
  }
  CFTypeID v6 = *(IIO_Reader **)(v4 + 104);
  if (v6) {
    IIO_Reader::osType(v6);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 224));
LABEL_17:
  kdebug_trace();
  return v5;
}

CGImageSourceStatus CGImageSourceGetStatusAtIndex(CGImageSourceRef isrc, size_t index)
{
  kdebug_trace();
  IIOInitDebugFlags();
  unsigned int v4 = (gIIODebugFlags >> 12) & 3;
  if (v4) {
    ImageIODebugOptions(v4, "A", "CGImageSourceGetStatusAtIndex", isrc, 0, index, 0);
  }
  if (!isrc)
  {
    LogError("CGImageSourceGetStatusAtIndex", 5516, "*** ERROR: CGImageSourceGetStatusAtIndex: source is nil\n");
LABEL_9:
    CGImageSourceStatus StatusAtIndex = kCGImageStatusInvalidData;
    goto LABEL_17;
  }
  CFTypeID v5 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1) {
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
  }
  if (v5 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceGetStatusAtIndex", 5517, "*** ERROR: CGImageSourceGetStatusAtIndex: source is not a CGImageSourceRef\n");
    goto LABEL_9;
  }
  uint64_t v6 = *((void *)isrc + 3);
  if (!v6 || IIOImageSource::isProxy((IIOImageSource *)v6)) {
    goto LABEL_9;
  }
  if (*(unsigned char *)(v6 + 89))
  {
    LogError("CGImageSourceGetStatusAtIndex", 5522, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    goto LABEL_9;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v6 + 224));
  if (IIOImageSource::bindToReader((IIOImageSource *)v6)) {
    CGImageSourceStatus StatusAtIndex = IIOImageSource::iPlusGetStatusAtIndex((IIOImageSource *)v6, index);
  }
  else {
    CGImageSourceStatus StatusAtIndex = *(_DWORD *)(v6 + 112);
  }
  CFTypeID v8 = *(IIO_Reader **)(v6 + 104);
  if (v8) {
    IIO_Reader::osType(v8);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v6 + 224));
LABEL_17:
  kdebug_trace();
  return StatusAtIndex;
}

size_t CGImageSourceGetPrimaryImageIndex(CGImageSourceRef isrc)
{
  kdebug_trace();
  IIOInitDebugFlags();
  unsigned int v2 = (gIIODebugFlags >> 12) & 3;
  if (v2) {
    ImageIODebugOptions(v2, "A", "CGImageSourceGetPrimaryImageIndex", isrc, 0, -1, 0);
  }
  if (!isrc)
  {
    LogError("CGImageSourceGetPrimaryImageIndex", 5545, "*** ERROR: CGImageSourceGetPrimaryImageIndex: source is nil\n");
LABEL_20:
    size_t v6 = 0;
    goto LABEL_16;
  }
  CFTypeID v3 = CFGetTypeID(isrc);
  if (CGImageSourceGetTypeID::once != -1) {
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
  }
  if (v3 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceGetPrimaryImageIndex", 5546, "*** ERROR: CGImageSourceGetPrimaryImageIndex: source is not a CGImageSourceRef\n");
    goto LABEL_20;
  }
  uint64_t v4 = *((void *)isrc + 3);
  if (!v4)
  {
    size_t v6 = 0;
    goto LABEL_16;
  }
  if (*(unsigned char *)(v4 + 89))
  {
    LogError("CGImageSourceGetPrimaryImageIndex", 5551, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    goto LABEL_20;
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 224));
  if (IIOImageSource::isProxy((IIOImageSource *)v4)) {
    unsigned int PrimaryImageIndex = IIOImageSource::proxyGetPrimaryImageIndex((IIODictionary **)v4);
  }
  else {
    unsigned int PrimaryImageIndex = IIOImageSource::getPrimaryImageIndex((IIO_Reader **)v4);
  }
  size_t v6 = PrimaryImageIndex;
  CFTypeID v7 = *(IIO_Reader **)(v4 + 104);
  if (v7) {
    IIO_Reader::osType(v7);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 224));
LABEL_16:
  kdebug_trace();
  return v6;
}

CFDictionaryRef CGImageSourceCopyAuxiliaryDataInfoAtIndex(CGImageSourceRef isrc, size_t index, CFStringRef auxiliaryImageDataType)
{
  return (CFDictionaryRef)CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions(isrc, index, (__CFString *)auxiliaryImageDataType, 0);
}

__CFString *CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions(void *a1, unint64_t a2, __CFString *a3, const __CFDictionary *a4)
{
  IIOInitDebugFlags();
  if (a3 && CFStringCompare(a3, @"kCGImageAuxiliaryDataTypeHDRGainMap", 0)) {
    CFStringCompare(a3, @"kCGImageAuxiliaryDataTypeISOGainMap", 0);
  }
  kdebug_trace();
  if ((gIIODebugFlags & 0x3000) != 0)
  {
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    IIOString::IIOString((IIOString *)&v15, a3);
    unsigned int v8 = (gIIODebugFlags >> 12) & 3;
    if (v8)
    {
      uint64_t v9 = (const char *)IIOString::utf8String((IIOString *)&v15);
      ImageIODebugOptions(v8, "A", "CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions", a1, v9, a2, 0);
    }
    IIOString::~IIOString((IIOString *)&v15);
  }
  if (!a1)
  {
    LogError("CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions", 5607, "*** ERROR: CGImageSourceCopyAuxiliaryDataInfoAtIndex: source is nil\n");
LABEL_16:
    a3 = 0;
    goto LABEL_22;
  }
  if (!a3)
  {
    LogError("CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions", 5608, "*** ERROR: CGImageSourceCopyAuxiliaryDataInfoAtIndex: auxiliaryDataType is nil\n");
    goto LABEL_22;
  }
  CFTypeID v10 = CFGetTypeID(a1);
  if (CGImageSourceGetTypeID::once != -1) {
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
  }
  if (v10 != CGImageSourceGetTypeID::id)
  {
    LogError("CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions", 5609, "*** ERROR: CGImageSourceCopyAuxiliaryDataInfoAtIndex: source is not a CGImageSourceRef\n");
    goto LABEL_16;
  }
  CFTypeID v11 = CFGetTypeID(a3);
  if (v11 != CFStringGetTypeID())
  {
    LogError("CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions", 5610, "*** ERROR: CGImageSourceCopyAuxiliaryDataInfoAtIndex: auxiliaryDataType is not a CFStringRef\n");
    goto LABEL_16;
  }
  uint64_t v12 = a1[3];
  if (!v12 || IIOImageSource::isProxy((IIOImageSource *)v12)) {
    goto LABEL_16;
  }
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  IIODictionary::IIODictionary((IIODictionary *)&v15, a4);
  if (*(unsigned char *)(v12 + 89))
  {
    LogError("CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions", 5616, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    a3 = 0;
  }
  else
  {
    pthread_mutex_lock((pthread_mutex_t *)(v12 + 224));
    a3 = (__CFString *)IIOImageSource::copyAuxiliaryDataInfoAtIndex((IIOImageSource *)v12, a2, a3, (IIODictionary *)&v15);
    unsigned int v13 = *(IIO_Reader **)(v12 + 104);
    if (v13) {
      IIO_Reader::osType(v13);
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v12 + 224));
  }
  IIODictionary::~IIODictionary((IIODictionary *)&v15);
LABEL_22:
  if ((gIIODebugFlags & 0x800000000000) != 0 && !a3) {
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CGImageSourceCopyAuxiliaryDataInfoAtIndexWithOptions", 5625, "could not create AuxiliaryDataInfo dictionary");
  }
  kdebug_trace();
  return a3;
}

void sub_1886FA53C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageSourceIsCloudTranscodable(void *a1, const __CFDictionary *a2)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceIsCloudTranscodable", a1, 0, -1, a2);
  }
  memset(v8, 0, sizeof(v8));
  IIODictionary::IIODictionary((IIODictionary *)v8, a2);
  if (a1)
  {
    uint64_t v4 = a1[3];
    if (v4 && !IIOImageSource::isProxy((IIOImageSource *)v4))
    {
      size_t v6 = (pthread_mutex_t *)(v4 + 224);
      pthread_mutex_lock((pthread_mutex_t *)(v4 + 224));
      uint64_t isCloudTranscodable = IIOImageSource::isCloudTranscodable((IIO_Reader **)v4, v8);
      pthread_mutex_unlock(v6);
      goto LABEL_8;
    }
  }
  else
  {
    LogError("CGImageSourceIsCloudTranscodable", 5642, "*** ERROR: CGImageSourceIsCloudTranscodable: source is NULL\n");
  }
  uint64_t isCloudTranscodable = 4294967292;
LABEL_8:
  IIODictionary::~IIODictionary((IIODictionary *)v8);
  return isCloudTranscodable;
}

void sub_1886FA648(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageSourceCanAnimate(uint64_t a1)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceCanAnimate", 0, 0, -1, 0);
  }
  if (!a1)
  {
    LogError("CGImageSourceCanAnimate", 5670, "*** ERROR: CGImageSourceCanAnimate: source is NULL\n");
    return 4294967292;
  }
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2 || IIOImageSource::isProxy((IIOImageSource *)v2)) {
    return 4294967292;
  }
  if (*(unsigned char *)(v2 + 89))
  {
    LogError("CGImageSourceCanAnimate", 5675, "*** ERROR: invalid CGImageSourceRef (non-matching hint)\n");
    return 4294967292;
  }
  uint64_t v4 = (pthread_mutex_t *)(v2 + 224);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 224));
  uint64_t canAnimate = IIOImageSource::canAnimate((IIO_Reader **)v2);
  pthread_mutex_unlock(v4);
  return canAnimate;
}

uint64_t CGImageIsDecodable(const __CFDictionary *a1, const __CFDictionary *a2)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageIsDecodable", 0, 0, -1, a2);
  }
  memset(v8, 0, sizeof(v8));
  IIODictionary::IIODictionary((IIODictionary *)v8, a1);
  memset(v7, 0, sizeof(v7));
  IIODictionary::IIODictionary((IIODictionary *)v7, a2);
  if (!a1)
  {
    LogError("CGImageIsDecodable", 5697, "*** ERROR: CGImageIsDecodable: property dictionary is NULL\n");
LABEL_18:
    uint64_t v5 = 4294967292;
    goto LABEL_10;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFDictionaryGetTypeID())
  {
    LogError("CGImageIsDecodable", 5698, "*** ERROR: CGImageIsDecodable: property parameter is not a CFDictionary\n");
    goto LABEL_18;
  }
  if (!IIODictionary::containsKey((IIODictionary *)v8, @"ColorModel"))
  {
    _cg_jpeg_mem_term("CGImageIsDecodable", 5700, "*** dictionary contains no 'ColorModel'\n");
    goto LABEL_18;
  }
  if (!IIODictionary::containsKey((IIODictionary *)v8, @"PixelHeight"))
  {
    _cg_jpeg_mem_term("CGImageIsDecodable", 5701, "*** dictionary contains no 'PixelHeight'\n");
    goto LABEL_18;
  }
  if (!IIODictionary::containsKey((IIODictionary *)v8, @"PixelWidth"))
  {
    _cg_jpeg_mem_term("CGImageIsDecodable", 5702, "*** dictionary contains no 'PixelWidth'\n");
    goto LABEL_18;
  }
  if ((IIODictionary::containsKey((IIODictionary *)v8, @"Depth") & 1) == 0)
  {
    _cg_jpeg_mem_term("CGImageIsDecodable", 5703, "*** dictionary contains no 'Depth'\n");
    goto LABEL_18;
  }
  uint64_t v5 = 0;
LABEL_10:
  IIODictionary::~IIODictionary((IIODictionary *)v7);
  IIODictionary::~IIODictionary((IIODictionary *)v8);
  return v5;
}

void sub_1886FA8C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CGImage *CGImageGetHash(CGImage *Hash)
{
  if ((~gIIODebugFlags & 0xC000) == 0) {
    ImageIODebugOptions(3, "S", "CGImageGetHash", 0, 0, -1, 0);
  }
  if (Hash) {
    Hash = IIOImageSource::CGImageGetHash(Hash, 0);
  }
  else {
    _cg_jpeg_mem_term("CGImageGetHash", 5808, "*** ERROR: CGImageGetHash - image is NULL\n");
  }
  kdebug_trace();
  return Hash;
}

uint64_t CGImageSourceDisableRAWDecoding()
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceDisableRAWDecoding", 0, 0, -1, 0);
  }

  return IIODisableRAWDecoding();
}

uint64_t CGImageSourceDisableMetadataParsing()
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceDisableMetadataParsing", 0, 0, -1, 0);
  }

  return IIODisableMetadataParsing();
}

uint64_t CGImageSourceDisableCaching()
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceDisableCaching", 0, 0, -1, 0);
  }

  return IIODisableCaching();
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<IIOThumbnailInfo>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(40 * a2);
}

void std::__introsort<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *,false>(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = a2 - v10;
          unint64_t v12 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a2 - v10) >> 3);
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                if (*(_DWORD *)(a2 - 28) < *(_DWORD *)(v10 + 12))
                {
                  uint64_t v161 = *(void *)(v10 + 32);
                  long long v142 = *(_OWORD *)v10;
                  long long v151 = *(_OWORD *)(v10 + 16);
                  long long v52 = *(_OWORD *)(a2 - 40);
                  long long v53 = *(_OWORD *)(a2 - 24);
                  *(void *)(v10 + 32) = *(void *)(a2 - 8);
                  *(_OWORD *)unint64_t v10 = v52;
                  *(_OWORD *)(v10 + 1jp2_colour_converter::clear(this + 6) = v53;
                  *(void *)(a2 - 8) = v161;
                  *(_OWORD *)(a2 - 24) = v151;
                  *(_OWORD *)(a2 - 40) = v142;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((long long *)v10, (long long *)(v10 + 40), (long long *)(a2 - 40));
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(v10, v10 + 40, v10 + 80, a2 - 40);
                break;
              case 5uLL:
                int v54 = (long long *)(v10 + 40);
                int v55 = (long long *)(v10 + 80);
                vImagePixelCount v56 = (long long *)(v10 + 120);
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(v10, v10 + 40, v10 + 80, v10 + 120);
                if (*(_DWORD *)(a2 - 28) < *(_DWORD *)(v10 + 132))
                {
                  long long v57 = *v56;
                  long long v152 = *(_OWORD *)(v10 + 136);
                  uint64_t v58 = *(void *)(v10 + 152);
                  long long v59 = *(_OWORD *)(a2 - 24);
                  long long v60 = *(_OWORD *)(a2 - 40);
                  *(void *)(v10 + 152) = *(void *)(a2 - 8);
                  long long *v56 = v60;
                  *(_OWORD *)(v10 + 13jp2_colour_converter::clear(this + 6) = v59;
                  *(_OWORD *)(a2 - 24) = v152;
                  *(void *)(a2 - 8) = v58;
                  *(_OWORD *)(a2 - 40) = v57;
                  if (*(_DWORD *)(v10 + 132) < *(_DWORD *)(v10 + 92))
                  {
                    uint64_t v61 = *(void *)(v10 + 112);
                    long long v63 = *v55;
                    long long v62 = *(_OWORD *)(v10 + 96);
                    long long v64 = *(_OWORD *)(v10 + 136);
                    *int v55 = *v56;
                    *(_OWORD *)(v10 + 9jp2_colour_converter::clear(this + 6) = v64;
                    *(void *)(v10 + 112) = *(void *)(v10 + 152);
                    long long *v56 = v63;
                    *(_OWORD *)(v10 + 13jp2_colour_converter::clear(this + 6) = v62;
                    *(void *)(v10 + 152) = v61;
                    if (*(_DWORD *)(v10 + 92) < *(_DWORD *)(v10 + 52))
                    {
                      uint64_t v65 = *(void *)(v10 + 72);
                      long long v67 = *v54;
                      long long v66 = *(_OWORD *)(v10 + 56);
                      long long v68 = *(_OWORD *)(v10 + 96);
                      long long *v54 = *v55;
                      *(_OWORD *)(v10 + 5jp2_colour_converter::clear(this + 6) = v68;
                      *(void *)(v10 + 72) = *(void *)(v10 + 112);
                      *int v55 = v67;
                      *(_OWORD *)(v10 + 9jp2_colour_converter::clear(this + 6) = v66;
                      *(void *)(v10 + 112) = v65;
                      if (*(_DWORD *)(v10 + 52) < *(_DWORD *)(v10 + 12))
                      {
                        uint64_t v162 = *(void *)(v10 + 32);
                        long long v143 = *(_OWORD *)v10;
                        long long v153 = *(_OWORD *)(v10 + 16);
                        long long v69 = *(_OWORD *)(v10 + 56);
                        *(_OWORD *)unint64_t v10 = *v54;
                        *(_OWORD *)(v10 + 1jp2_colour_converter::clear(this + 6) = v69;
                        *(void *)(v10 + 32) = *(void *)(v10 + 72);
                        long long *v54 = v143;
                        *(_OWORD *)(v10 + 5jp2_colour_converter::clear(this + 6) = v153;
                        *(void *)(v10 + 72) = v162;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 959)
          {
            unint64_t v70 = v10 + 40;
            BOOL v72 = v10 == a2 || v70 == a2;
            if (a4)
            {
              if (!v72)
              {
                uint64_t v73 = 0;
                unint64_t v74 = v10;
                do
                {
                  unint64_t v75 = v70;
                  unsigned int v76 = *(_DWORD *)(v74 + 52);
                  if (v76 < *(_DWORD *)(v74 + 12))
                  {
                    int v127 = *(_DWORD *)(v75 + 8);
                    uint64_t v123 = *(void *)v75;
                    long long v144 = *(_OWORD *)(v74 + 56);
                    uint64_t v154 = *(void *)(v74 + 72);
                    uint64_t v77 = v73;
                    while (1)
                    {
                      uint64_t v78 = v10 + v77;
                      long long v79 = *(_OWORD *)(v10 + v77 + 16);
                      *(_OWORD *)(v78 + 40) = *(_OWORD *)(v10 + v77);
                      *(_OWORD *)(v78 + 5jp2_colour_converter::clear(this + 6) = v79;
                      *(void *)(v78 + 72) = *(void *)(v10 + v77 + 32);
                      if (!v77) {
                        break;
                      }
                      v77 -= 40;
                      if (v76 >= *(_DWORD *)(v78 - 28))
                      {
                        uint64_t v80 = v10 + v77 + 40;
                        goto LABEL_85;
                      }
                    }
                    uint64_t v80 = v10;
LABEL_85:
                    *(void *)uint64_t v80 = v123;
                    *(_DWORD *)(v80 + 8) = v127;
                    *(_DWORD *)(v80 + 12) = v76;
                    *(_OWORD *)(v80 + 1jp2_colour_converter::clear(this + 6) = v144;
                    *(void *)(v80 + 32) = v154;
                  }
                  unint64_t v70 = v75 + 40;
                  v73 += 40;
                  unint64_t v74 = v75;
                }
                while (v75 + 40 != a2);
              }
            }
            else if (!v72)
            {
              do
              {
                unint64_t v117 = v70;
                unsigned int v118 = *(_DWORD *)(a1 + 52);
                if (v118 < *(_DWORD *)(a1 + 12))
                {
                  int v129 = *(_DWORD *)(v70 + 8);
                  uint64_t v126 = *(void *)v70;
                  long long v147 = *(_OWORD *)(a1 + 56);
                  uint64_t v157 = *(void *)(a1 + 72);
                  do
                  {
                    long long v119 = *(_OWORD *)(v70 - 24);
                    *(_OWORD *)unint64_t v70 = *(_OWORD *)(v70 - 40);
                    *(_OWORD *)(v70 + 1jp2_colour_converter::clear(this + 6) = v119;
                    *(void *)(v70 + 32) = *(void *)(v70 - 8);
                    unsigned int v120 = *(_DWORD *)(v70 - 68);
                    v70 -= 40;
                  }
                  while (v118 < v120);
                  *(void *)unint64_t v70 = v126;
                  *(_DWORD *)(v70 + 8) = v129;
                  *(_DWORD *)(v70 + 12) = v118;
                  *(void *)(v70 + 32) = v157;
                  *(_OWORD *)(v70 + 1jp2_colour_converter::clear(this + 6) = v147;
                }
                unint64_t v70 = v117 + 40;
                a1 = v117;
              }
              while (v117 + 40 != a2);
            }
            return;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v81 = (v12 - 2) >> 1;
              int64_t v82 = v81;
              do
              {
                int64_t v83 = v82;
                if (v81 >= v82)
                {
                  uint64_t v84 = (2 * v82) | 1;
                  unint64_t v85 = v10 + 40 * v84;
                  if (2 * v83 + 2 < (uint64_t)v12)
                  {
                    unsigned int v86 = *(_DWORD *)(v10 + 40 * v84 + 12);
                    unsigned int v87 = *(_DWORD *)(v85 + 52);
                    v85 += 40 * (v86 < v87);
                    if (v86 < v87) {
                      uint64_t v84 = 2 * v83 + 2;
                    }
                  }
                  unsigned int v88 = *(_DWORD *)(v10 + 40 * v83 + 12);
                  if (*(_DWORD *)(v85 + 12) >= v88)
                  {
                    unint64_t v89 = v10 + 40 * v83;
                    int v128 = *(_DWORD *)(v89 + 8);
                    uint64_t v124 = *(void *)v89;
                    uint64_t v155 = *(void *)(v89 + 32);
                    long long v145 = *(_OWORD *)(v89 + 16);
                    do
                    {
                      unint64_t v90 = v85;
                      long long v91 = *(_OWORD *)v85;
                      long long v92 = *(_OWORD *)(v85 + 16);
                      *(void *)(v89 + 32) = *(void *)(v85 + 32);
                      *(_OWORD *)unint64_t v89 = v91;
                      *(_OWORD *)(v89 + 1jp2_colour_converter::clear(this + 6) = v92;
                      if (v81 < v84) {
                        break;
                      }
                      uint64_t v93 = (2 * v84) | 1;
                      unint64_t v85 = v10 + 40 * v93;
                      uint64_t v94 = 2 * v84 + 2;
                      if (v94 < (uint64_t)v12)
                      {
                        unsigned int v95 = *(_DWORD *)(v10 + 40 * v93 + 12);
                        unsigned int v96 = *(_DWORD *)(v85 + 52);
                        v85 += 40 * (v95 < v96);
                        if (v95 < v96) {
                          uint64_t v93 = v94;
                        }
                      }
                      unint64_t v89 = v90;
                      uint64_t v84 = v93;
                    }
                    while (*(_DWORD *)(v85 + 12) >= v88);
                    *(void *)unint64_t v90 = v124;
                    *(_DWORD *)(v90 + 8) = v128;
                    *(_DWORD *)(v90 + 12) = v88;
                    *(_OWORD *)(v90 + 1jp2_colour_converter::clear(this + 6) = v145;
                    *(void *)(v90 + 32) = v155;
                  }
                }
                int64_t v82 = v83 - 1;
              }
              while (v83);
              int64_t v97 = v11 / 0x28uLL;
              do
              {
                uint64_t v98 = 0;
                uint64_t v163 = *(void *)(v10 + 32);
                long long v146 = *(_OWORD *)v10;
                long long v156 = *(_OWORD *)(v10 + 16);
                unint64_t v99 = v10;
                do
                {
                  uint64_t v100 = v98 + 1;
                  unint64_t v101 = v99 + 40 * (v98 + 1);
                  uint64_t v102 = (2 * v98) | 1;
                  uint64_t v103 = 2 * v98 + 2;
                  if (v103 < v97)
                  {
                    unsigned int v104 = *(_DWORD *)(v99 + 40 * v100 + 12);
                    unsigned int v105 = *(_DWORD *)(v101 + 52);
                    v101 += 40 * (v104 < v105);
                    if (v104 < v105) {
                      uint64_t v102 = v103;
                    }
                  }
                  long long v106 = *(_OWORD *)v101;
                  long long v107 = *(_OWORD *)(v101 + 16);
                  *(void *)(v99 + 32) = *(void *)(v101 + 32);
                  *(_OWORD *)unint64_t v99 = v106;
                  *(_OWORD *)(v99 + 1jp2_colour_converter::clear(this + 6) = v107;
                  unint64_t v99 = v101;
                  uint64_t v98 = v102;
                }
                while (v102 <= (uint64_t)((unint64_t)(v97 - 2) >> 1));
                a2 -= 40;
                if (v101 == a2)
                {
                  *(void *)(v101 + 32) = v163;
                  *(_OWORD *)unint64_t v101 = v146;
                  *(_OWORD *)(v101 + 1jp2_colour_converter::clear(this + 6) = v156;
                }
                else
                {
                  long long v108 = *(_OWORD *)a2;
                  long long v109 = *(_OWORD *)(a2 + 16);
                  *(void *)(v101 + 32) = *(void *)(a2 + 32);
                  *(_OWORD *)unint64_t v101 = v108;
                  *(_OWORD *)(v101 + 1jp2_colour_converter::clear(this + 6) = v109;
                  *(void *)(a2 + 32) = v163;
                  *(_OWORD *)a2 = v146;
                  *(_OWORD *)(a2 + 1jp2_colour_converter::clear(this + 6) = v156;
                  uint64_t v110 = v101 - v10 + 40;
                  if (v110 >= 41)
                  {
                    unint64_t v111 = (v110 / 0x28uLL - 2) >> 1;
                    unsigned int v112 = *(_DWORD *)(v101 + 12);
                    if (*(_DWORD *)(v10 + 40 * v111 + 12) < v112)
                    {
                      int v138 = *(_DWORD *)(v101 + 8);
                      uint64_t v135 = *(void *)v101;
                      uint64_t v132 = *(void *)(v101 + 32);
                      long long v125 = *(_OWORD *)(v101 + 16);
                      do
                      {
                        unint64_t v113 = v101;
                        unint64_t v101 = v10 + 40 * v111;
                        long long v114 = *(_OWORD *)v101;
                        long long v115 = *(_OWORD *)(v101 + 16);
                        *(void *)(v113 + 32) = *(void *)(v101 + 32);
                        *(_OWORD *)unint64_t v113 = v114;
                        *(_OWORD *)(v113 + 1jp2_colour_converter::clear(this + 6) = v115;
                        if (!v111) {
                          break;
                        }
                        unint64_t v111 = (v111 - 1) >> 1;
                      }
                      while (*(_DWORD *)(v10 + 40 * v111 + 12) < v112);
                      *(void *)unint64_t v101 = v135;
                      *(_DWORD *)(v101 + 8) = v138;
                      *(_DWORD *)(v101 + 12) = v112;
                      *(void *)(v101 + 32) = v132;
                      *(_OWORD *)(v101 + 1jp2_colour_converter::clear(this + 6) = v125;
                    }
                  }
                }
              }
              while (v97-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 40 * (v12 >> 1);
          if ((unint64_t)v11 >= 0x1401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((long long *)a1, (long long *)(a1 + 40 * (v12 >> 1)), (long long *)(a2 - 40));
            uint64_t v15 = 5 * v13;
            uint64_t v16 = (long long *)(a1 + 40 * v13 - 40);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((long long *)(a1 + 40), v16, (long long *)(a2 - 80));
            uint64_t v17 = (long long *)(a1 + 40 + 8 * v15);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((long long *)(a1 + 80), v17, (long long *)(a2 - 120));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(v16, (long long *)v14, v17);
            uint64_t v158 = *(void *)(a1 + 32);
            long long v139 = *(_OWORD *)a1;
            long long v148 = *(_OWORD *)(a1 + 16);
            long long v18 = *(_OWORD *)v14;
            long long v19 = *(_OWORD *)(v14 + 16);
            *(void *)(a1 + 32) = *(void *)(v14 + 32);
            *(_OWORD *)a1 = v18;
            *(_OWORD *)(a1 + 1jp2_colour_converter::clear(this + 6) = v19;
            *(void *)(v14 + 32) = v158;
            *(_OWORD *)unint64_t v14 = v139;
            *(_OWORD *)(v14 + 1jp2_colour_converter::clear(this + 6) = v148;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((long long *)(a1 + 40 * (v12 >> 1)), (long long *)a1, (long long *)(a2 - 40));
          }
          --a3;
          if (a4) {
            break;
          }
          unsigned int v20 = *(_DWORD *)(a1 + 12);
          if (*(_DWORD *)(a1 - 28) < v20) {
            goto LABEL_12;
          }
          int v137 = *(_DWORD *)(a1 + 8);
          uint64_t v134 = *(void *)a1;
          long long v122 = *(_OWORD *)(a1 + 16);
          uint64_t v131 = *(void *)(a1 + 32);
          if (v20 >= *(_DWORD *)(a2 - 28))
          {
            unint64_t v40 = a1 + 40;
            do
            {
              unint64_t v10 = v40;
              if (v40 >= a2) {
                break;
              }
              unsigned int v41 = *(_DWORD *)(v40 + 12);
              v40 += 40;
            }
            while (v20 >= v41);
          }
          else
          {
            unint64_t v38 = a1;
            do
            {
              unint64_t v10 = v38 + 40;
              unsigned int v39 = *(_DWORD *)(v38 + 52);
              v38 += 40;
            }
            while (v20 >= v39);
          }
          unint64_t v42 = a2;
          if (v10 < a2)
          {
            unint64_t v43 = a2;
            do
            {
              unint64_t v42 = v43 - 40;
              unsigned int v44 = *(_DWORD *)(v43 - 28);
              v43 -= 40;
            }
            while (v20 < v44);
          }
          while (v10 < v42)
          {
            uint64_t v160 = *(void *)(v10 + 32);
            long long v141 = *(_OWORD *)v10;
            long long v150 = *(_OWORD *)(v10 + 16);
            long long v45 = *(_OWORD *)v42;
            long long v46 = *(_OWORD *)(v42 + 16);
            *(void *)(v10 + 32) = *(void *)(v42 + 32);
            *(_OWORD *)unint64_t v10 = v45;
            *(_OWORD *)(v10 + 1jp2_colour_converter::clear(this + 6) = v46;
            *(void *)(v42 + 32) = v160;
            *(_OWORD *)unint64_t v42 = v141;
            *(_OWORD *)(v42 + 1jp2_colour_converter::clear(this + 6) = v150;
            do
            {
              unsigned int v47 = *(_DWORD *)(v10 + 52);
              v10 += 40;
            }
            while (v20 >= v47);
            do
            {
              unsigned int v48 = *(_DWORD *)(v42 - 28);
              v42 -= 40;
            }
            while (v20 < v48);
          }
          uint64_t v49 = (long long *)(v10 - 40);
          BOOL v4 = v10 - 40 >= a1;
          BOOL v5 = v10 - 40 == a1;
          if (v10 - 40 != a1)
          {
            long long v50 = *v49;
            long long v51 = *(_OWORD *)(v10 - 24);
            *(void *)(a1 + 32) = *(void *)(v10 - 8);
            *(_OWORD *)a1 = v50;
            *(_OWORD *)(a1 + 1jp2_colour_converter::clear(this + 6) = v51;
          }
          a4 = 0;
          *(_DWORD *)(v10 - 32) = v137;
          *(void *)uint64_t v49 = v134;
          *(_DWORD *)(v10 - 28) = v20;
          *(void *)(v10 - 8) = v131;
          *(_OWORD *)(v10 - 24) = v122;
        }
        unsigned int v20 = *(_DWORD *)(a1 + 12);
LABEL_12:
        uint64_t v21 = 0;
        int v136 = *(_DWORD *)(a1 + 8);
        uint64_t v133 = *(void *)a1;
        uint64_t v130 = *(void *)(a1 + 32);
        long long v121 = *(_OWORD *)(a1 + 16);
        do
        {
          unsigned int v22 = *(_DWORD *)(a1 + v21 + 52);
          v21 += 40;
        }
        while (v22 < v20);
        unint64_t v23 = a1 + v21;
        unint64_t v24 = a2;
        if (v21 == 40)
        {
          unint64_t v27 = a2;
          while (v23 < v27)
          {
            unint64_t v25 = v27 - 40;
            unsigned int v28 = *(_DWORD *)(v27 - 28);
            v27 -= 40;
            if (v28 < v20) {
              goto LABEL_22;
            }
          }
          unint64_t v25 = v27;
        }
        else
        {
          do
          {
            unint64_t v25 = v24 - 40;
            unsigned int v26 = *(_DWORD *)(v24 - 28);
            v24 -= 40;
          }
          while (v26 >= v20);
        }
LABEL_22:
        if (v23 >= v25)
        {
          unint64_t v10 = v23;
        }
        else
        {
          unint64_t v29 = v25;
          unint64_t v10 = v23;
          do
          {
            uint64_t v159 = *(void *)(v10 + 32);
            long long v140 = *(_OWORD *)v10;
            long long v149 = *(_OWORD *)(v10 + 16);
            long long v30 = *(_OWORD *)v29;
            long long v31 = *(_OWORD *)(v29 + 16);
            *(void *)(v10 + 32) = *(void *)(v29 + 32);
            *(_OWORD *)unint64_t v10 = v30;
            *(_OWORD *)(v10 + 1jp2_colour_converter::clear(this + 6) = v31;
            *(void *)(v29 + 32) = v159;
            *(_OWORD *)unint64_t v29 = v140;
            *(_OWORD *)(v29 + 1jp2_colour_converter::clear(this + 6) = v149;
            do
            {
              unsigned int v32 = *(_DWORD *)(v10 + 52);
              v10 += 40;
            }
            while (v32 < v20);
            do
            {
              unsigned int v33 = *(_DWORD *)(v29 - 28);
              v29 -= 40;
            }
            while (v33 >= v20);
          }
          while (v10 < v29);
        }
        uint64_t v34 = (long long *)(v10 - 40);
        if (v10 - 40 != a1)
        {
          long long v35 = *v34;
          long long v36 = *(_OWORD *)(v10 - 24);
          *(void *)(a1 + 32) = *(void *)(v10 - 8);
          *(_OWORD *)a1 = v35;
          *(_OWORD *)(a1 + 1jp2_colour_converter::clear(this + 6) = v36;
        }
        *(_DWORD *)(v10 - 32) = v136;
        *(void *)uint64_t v34 = v133;
        *(_DWORD *)(v10 - 28) = v20;
        *(void *)(v10 - 8) = v130;
        *(_OWORD *)(v10 - 24) = v121;
        if (v23 >= v25) {
          break;
        }
LABEL_35:
        std::__introsort<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *,false>(a1, v10 - 40, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v37 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(a1, v10 - 40);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(v10, a2))
      {
        break;
      }
      if (!v37) {
        goto LABEL_35;
      }
    }
    a2 = v10 - 40;
    if (!v37) {
      continue;
    }
    break;
  }
}

long long *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(long long *result, long long *a2, long long *a3)
{
  unsigned int v3 = *((_DWORD *)a2 + 3);
  unsigned int v4 = *((_DWORD *)a3 + 3);
  if (v3 >= *((_DWORD *)result + 3))
  {
    if (v4 < v3)
    {
      long long v10 = *a2;
      long long v11 = a2[1];
      uint64_t v12 = *((void *)a2 + 4);
      uint64_t v13 = *((void *)a3 + 4);
      long long v14 = a3[1];
      *a2 = *a3;
      a2[1] = v14;
      *((void *)a2 + 4) = v13;
      *((void *)a3 + 4) = v12;
      *a3 = v10;
      a3[1] = v11;
      if (*((_DWORD *)a2 + 3) < *((_DWORD *)result + 3))
      {
        long long v15 = *result;
        long long v16 = result[1];
        uint64_t v17 = *((void *)result + 4);
        uint64_t v18 = *((void *)a2 + 4);
        long long v19 = a2[1];
        *uint64_t result = *a2;
        result[1] = v19;
        *((void *)result + 4) = v18;
        *((void *)a2 + 4) = v17;
        *a2 = v15;
        a2[1] = v16;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      long long v20 = *result;
      long long v21 = result[1];
      uint64_t v22 = *((void *)result + 4);
      uint64_t v23 = *((void *)a2 + 4);
      long long v24 = a2[1];
      *uint64_t result = *a2;
      result[1] = v24;
      *((void *)result + 4) = v23;
      *((void *)a2 + 4) = v22;
      *a2 = v20;
      a2[1] = v21;
      if (*((_DWORD *)a3 + 3) >= *((_DWORD *)a2 + 3)) {
        return result;
      }
      long long v5 = *a2;
      long long v6 = a2[1];
      uint64_t v7 = *((void *)a2 + 4);
      uint64_t v25 = *((void *)a3 + 4);
      long long v26 = a3[1];
      *a2 = *a3;
      a2[1] = v26;
      *((void *)a2 + 4) = v25;
    }
    else
    {
      long long v5 = *result;
      long long v6 = result[1];
      uint64_t v7 = *((void *)result + 4);
      uint64_t v8 = *((void *)a3 + 4);
      long long v9 = a3[1];
      *uint64_t result = *a3;
      result[1] = v9;
      *((void *)result + 4) = v8;
    }
    *((void *)a3 + 4) = v7;
    *a3 = v5;
    a3[1] = v6;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xCCCCCCCCCCCCCCCDLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(_DWORD *)(a2 - 28) < *(_DWORD *)(a1 + 12))
      {
        long long v6 = *(_OWORD *)a1;
        long long v7 = *(_OWORD *)(a1 + 16);
        uint64_t v8 = *(void *)(a1 + 32);
        uint64_t v9 = *(void *)(a2 - 8);
        long long v10 = *(_OWORD *)(a2 - 24);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 40);
        *(_OWORD *)(a1 + 1jp2_colour_converter::clear(this + 6) = v10;
        *(void *)(a1 + 32) = v9;
        *(void *)(a2 - 8) = v8;
        *(_OWORD *)(a2 - 24) = v7;
        *(_OWORD *)(a2 - 40) = v6;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((long long *)a1, (long long *)(a1 + 40), (long long *)(a2 - 40));
      return 1;
    case 4uLL:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(a1, a1 + 40, a1 + 80, a2 - 40);
      return 1;
    case 5uLL:
      long long v20 = (long long *)(a1 + 40);
      long long v21 = (long long *)(a1 + 80);
      uint64_t v22 = (long long *)(a1 + 120);
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(a1, a1 + 40, a1 + 80, a1 + 120);
      if (*(_DWORD *)(a2 - 28) >= *(_DWORD *)(a1 + 132)) {
        return 1;
      }
      long long v23 = *v22;
      long long v24 = *(_OWORD *)(a1 + 136);
      uint64_t v25 = *(void *)(a1 + 152);
      uint64_t v26 = *(void *)(a2 - 8);
      long long v27 = *(_OWORD *)(a2 - 24);
      *uint64_t v22 = *(_OWORD *)(a2 - 40);
      *(_OWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = v27;
      *(void *)(a1 + 152) = v26;
      *(void *)(a2 - 8) = v25;
      *(_OWORD *)(a2 - 24) = v24;
      *(_OWORD *)(a2 - 40) = v23;
      if (*(_DWORD *)(a1 + 132) >= *(_DWORD *)(a1 + 92)) {
        return 1;
      }
      uint64_t v28 = *(void *)(a1 + 112);
      long long v30 = *v21;
      long long v29 = *(_OWORD *)(a1 + 96);
      long long v31 = *(_OWORD *)(a1 + 136);
      *long long v21 = *v22;
      *(_OWORD *)(a1 + 9jp2_colour_converter::clear(this + 6) = v31;
      *(void *)(a1 + 112) = *(void *)(a1 + 152);
      *uint64_t v22 = v30;
      *(_OWORD *)(a1 + 13jp2_colour_converter::clear(this + 6) = v29;
      *(void *)(a1 + 152) = v28;
      if (*(_DWORD *)(a1 + 92) >= *(_DWORD *)(a1 + 52)) {
        return 1;
      }
      uint64_t v32 = *(void *)(a1 + 72);
      long long v34 = *v20;
      long long v33 = *(_OWORD *)(a1 + 56);
      long long v35 = *(_OWORD *)(a1 + 96);
      *long long v20 = *v21;
      *(_OWORD *)(a1 + 5jp2_colour_converter::clear(this + 6) = v35;
      *(void *)(a1 + 72) = *(void *)(a1 + 112);
      *long long v21 = v34;
      *(_OWORD *)(a1 + 9jp2_colour_converter::clear(this + 6) = v33;
      *(void *)(a1 + 112) = v32;
      if (*(_DWORD *)(a1 + 52) >= *(_DWORD *)(a1 + 12)) {
        return 1;
      }
      uint64_t v36 = *(void *)(a1 + 32);
      long long v38 = *(_OWORD *)a1;
      long long v37 = *(_OWORD *)(a1 + 16);
      long long v39 = *(_OWORD *)(a1 + 56);
      *(_OWORD *)a1 = *v20;
      *(_OWORD *)(a1 + 1jp2_colour_converter::clear(this + 6) = v39;
      *(void *)(a1 + 32) = *(void *)(a1 + 72);
      *long long v20 = v38;
      *(_OWORD *)(a1 + 5jp2_colour_converter::clear(this + 6) = v37;
      BOOL result = 1;
      *(void *)(a1 + 72) = v36;
      return result;
    default:
      uint64_t v11 = a1 + 80;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((long long *)a1, (long long *)(a1 + 40), (long long *)(a1 + 80));
      uint64_t v12 = a1 + 120;
      if (a1 + 120 == a2) {
        return 1;
      }
      uint64_t v13 = 0;
      int v14 = 0;
      break;
  }
  while (1)
  {
    unsigned int v15 = *(_DWORD *)(v12 + 12);
    if (v15 < *(_DWORD *)(v11 + 12))
    {
      int v43 = *(_DWORD *)(v12 + 8);
      long long v40 = *(_OWORD *)(v12 + 16);
      uint64_t v41 = *(void *)(v12 + 32);
      uint64_t v42 = *(void *)v12;
      uint64_t v16 = v13;
      while (1)
      {
        uint64_t v17 = a1 + v16;
        long long v18 = *(_OWORD *)(a1 + v16 + 96);
        *(_OWORD *)(v17 + 120) = *(_OWORD *)(a1 + v16 + 80);
        *(_OWORD *)(v17 + 13jp2_colour_converter::clear(this + 6) = v18;
        *(void *)(v17 + 152) = *(void *)(a1 + v16 + 112);
        if (v16 == -80) {
          break;
        }
        v16 -= 40;
        if (v15 >= *(_DWORD *)(v17 + 52))
        {
          uint64_t v19 = a1 + v16 + 120;
          goto LABEL_12;
        }
      }
      uint64_t v19 = a1;
LABEL_12:
      *(void *)uint64_t v19 = v42;
      *(_DWORD *)(v19 + 8) = v43;
      *(_DWORD *)(v19 + 12) = v15;
      *(_OWORD *)(v19 + 1jp2_colour_converter::clear(this + 6) = v40;
      *(void *)(v19 + 32) = v41;
      if (++v14 == 8) {
        return v12 + 40 == a2;
      }
    }
    uint64_t v11 = v12;
    v13 += 40;
    v12 += 40;
    if (v12 == a2) {
      return 1;
    }
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,IIOImageSource::updateThumbnailInfo(IIODictionary *,unsigned int *,unsigned int *)::$_0 &,IIOThumbnailInfo *>((long long *)a1, (long long *)a2, (long long *)a3);
  if (*(_DWORD *)(a4 + 12) < *(_DWORD *)(a3 + 12))
  {
    __n128 result = *(__n128 *)a3;
    long long v9 = *(_OWORD *)(a3 + 16);
    uint64_t v10 = *(void *)(a3 + 32);
    uint64_t v11 = *(void *)(a4 + 32);
    long long v12 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)(a3 + 1jp2_colour_converter::clear(this + 6) = v12;
    *(void *)(a3 + 32) = v11;
    *(void *)(a4 + 32) = v10;
    *(__n128 *)a4 = result;
    *(_OWORD *)(a4 + 1jp2_colour_converter::clear(this + 6) = v9;
    if (*(_DWORD *)(a3 + 12) < *(_DWORD *)(a2 + 12))
    {
      __n128 result = *(__n128 *)a2;
      long long v13 = *(_OWORD *)(a2 + 16);
      uint64_t v14 = *(void *)(a2 + 32);
      uint64_t v15 = *(void *)(a3 + 32);
      long long v16 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 1jp2_colour_converter::clear(this + 6) = v16;
      *(void *)(a2 + 32) = v15;
      *(void *)(a3 + 32) = v14;
      *(__n128 *)a3 = result;
      *(_OWORD *)(a3 + 1jp2_colour_converter::clear(this + 6) = v13;
      if (*(_DWORD *)(a2 + 12) < *(_DWORD *)(a1 + 12))
      {
        __n128 result = *(__n128 *)a1;
        long long v17 = *(_OWORD *)(a1 + 16);
        uint64_t v18 = *(void *)(a1 + 32);
        uint64_t v19 = *(void *)(a2 + 32);
        long long v20 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 1jp2_colour_converter::clear(this + 6) = v20;
        *(void *)(a1 + 32) = v19;
        *(void *)(a2 + 32) = v18;
        *(__n128 *)a2 = result;
        *(_OWORD *)(a2 + 1jp2_colour_converter::clear(this + 6) = v17;
      }
    }
  }
  return result;
}

void png_default_error(const char *a1)
{
  uint64_t v1 = (FILE **)MEMORY[0x1E4F143C8];
  uint64_t v2 = "undefined";
  if (a1) {
    uint64_t v2 = a1;
  }
  fprintf((FILE *)*MEMORY[0x1E4F143C8], "libpng error: %s", v2);
  fputc(10, *v1);
  abort();
}

unint64_t png_format_number(unint64_t a1, uint64_t a2, int a3, unint64_t a4)
{
  *(unsigned char *)(a2 - 1) = 0;
  unint64_t v4 = a2 - 1;
  if (v4 > a1)
  {
    int v5 = 0;
    int v6 = 0;
    int v7 = 1;
    while (2)
    {
      if (a4 || v6 < v7)
      {
        switch(a3)
        {
          case 1:
            goto LABEL_7;
          case 2:
            int v7 = 2;
LABEL_7:
            unint64_t v8 = a4 / 0xA;
            *(unsigned char *)--unint64_t v4 = png_format_number_digits[a4 % 0xA];
            goto LABEL_11;
          case 3:
            goto LABEL_10;
          case 4:
            int v7 = 2;
LABEL_10:
            *(unsigned char *)--unint64_t v4 = png_format_number_digits[a4 & 0xF];
            unint64_t v8 = a4 >> 4;
LABEL_11:
            ++v6;
            a4 = v8;
            goto LABEL_12;
          case 5:
            unint64_t v9 = a4 % 0xA;
            if (v5 || v9)
            {
              *(unsigned char *)--unint64_t v4 = png_format_number_digits[v9];
              int v5 = 1;
            }
            else
            {
              int v5 = 0;
            }
            int v7 = 5;
            a4 /= 0xAuLL;
            goto LABEL_19;
          default:
            a4 = 0;
LABEL_19:
            ++v6;
            if (a3 == 5 && v6 == 5 && v4 > a1)
            {
              if (v5)
              {
                *(unsigned char *)--unint64_t v4 = 46;
              }
              else
              {
                int v5 = 0;
                if (!a4) {
                  *(unsigned char *)--unint64_t v4 = 48;
                }
              }
              int v6 = 5;
            }
LABEL_12:
            if (v4 <= a1) {
              return v4;
            }
            continue;
        }
      }
      break;
    }
  }
  return v4;
}

uint64_t png_warning_parameter(uint64_t result, int a2, unsigned char *a3)
{
  uint64_t v3 = (a2 - 1);
  if (v3 <= 7 && result)
  {
    uint64_t v4 = result + 32 * v3;
    if (a3 && (LOBYTE(v5) = *a3) != 0)
    {
      unint64_t v6 = 0;
      do
      {
        unint64_t v7 = v6 + 1;
        *(unsigned char *)(v4 + vjp2_colour_converter::clear(this + 6) = v5;
        if (v6 > 0x1D) {
          break;
        }
        int v5 = a3[++v6];
      }
      while (v5);
    }
    else
    {
      unint64_t v7 = 0;
    }
    *(unsigned char *)(v4 + v7) = 0;
  }
  return result;
}

unsigned char *png_warning_parameter_signed(uint64_t a1, int a2, int a3, unint64_t a4)
{
  int v4 = a4;
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  memset(v13, 0, sizeof(v13));
  if ((a4 & 0x80000000) == 0) {
    a4 = a4;
  }
  else {
    a4 = -(int)a4;
  }
  __n128 result = (unsigned char *)png_format_number((unint64_t)v13, (uint64_t)&v14, a3, a4);
  if (v4 < 0 && result > (unsigned char *)v13) {
    *--__n128 result = 45;
  }
  uint64_t v8 = (a2 - 1);
  if (v8 <= 7 && a1)
  {
    uint64_t v9 = a1 + 32 * v8;
    LOBYTE(v10) = *result;
    if (*result)
    {
      unint64_t v11 = 0;
      do
      {
        unint64_t v12 = v11 + 1;
        *(unsigned char *)(v9 + v11) = v10;
        if (v11 > 0x1D) {
          break;
        }
        int v10 = result[++v11];
      }
      while (v10);
    }
    else
    {
      unint64_t v12 = 0;
    }
    *(unsigned char *)(v9 + v12) = 0;
  }
  return result;
}

uint64_t png_formatted_warning(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  unint64_t v3 = 0;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  memset(v14, 0, sizeof(v14));
  while (1)
  {
    int v4 = *a3;
    if (!*a3) {
      break;
    }
    if (!a2 || v4 != 64) {
      goto LABEL_19;
    }
    int v5 = a3 + 1;
    int v4 = a3[1];
    if (!a3[1])
    {
      LOBYTE(v4) = 64;
LABEL_19:
      int v5 = a3;
      goto LABEL_20;
    }
    uint64_t v6 = 0;
    uint64_t v7 = a2 - 32;
    do
    {
      int v8 = v6 + 1;
      v7 += 32;
      if (v6 == 9) {
        break;
      }
      int v9 = png_formatted_warning_valid_parameters[v6++];
    }
    while (v9 != v4);
    if (((v8 - 1) & 0xFFFFFFF8) == 0)
    {
      if (v3 <= 0xBE)
      {
        unint64_t v10 = 0;
        while (*(unsigned char *)(v7 + v10) && v10 <= 0x1F)
        {
          *((unsigned char *)v14 + v3 + v10) = *(unsigned char *)(v7 + v10);
          ++v10;
          if (v3 + v10 == 191)
          {
            unint64_t v3 = 191;
            goto LABEL_24;
          }
        }
        v3 += v10;
      }
LABEL_24:
      a3 += 2;
      unint64_t v12 = v3;
      goto LABEL_21;
    }
LABEL_20:
    a3 = v5 + 1;
    unint64_t v12 = v3 + 1;
    *((unsigned char *)v14 + v3++) = v4;
LABEL_21:
    if (v12 >= 0xBF) {
      goto LABEL_26;
    }
  }
  unint64_t v12 = v3;
LABEL_26:
  *((unsigned char *)v14 + v12) = 0;
  return png_warning(a1, v14);
}

uint64_t png_benign_error(uint64_t a1, char *a2)
{
  int v2 = *(_DWORD *)(a1 + 76);
  if ((*(unsigned char *)(a1 + 82) & 0x10) == 0)
  {
    if ((v2 & 0x8000) == 0 || !*(_DWORD *)(a1 + 312)) {
      _cg_png_error((void (**)(void))a1, a2);
    }
    png_chunk_error((void (**)(void))a1, a2);
  }
  if ((v2 & 0x8000) != 0 && *(_DWORD *)(a1 + 312))
  {
    return png_chunk_warning(a1, a2);
  }
  else
  {
    return png_warning(a1, a2);
  }
}

void png_chunk_error(void (**a1)(void), const char *a2)
{
  if (!a1) {
    _cg_png_error(0, a2);
  }
  memset(v3, 0, 214);
  png_format_buffer((uint64_t)a1, (uint64_t)v3, (uint64_t)a2);
  _cg_png_error(a1, (const char *)v3);
}

uint64_t png_app_warning(uint64_t a1, char *a2)
{
  if ((*(unsigned char *)(a1 + 82) & 0x20) == 0) {
    _cg_png_error((void (**)(void))a1, a2);
  }

  return png_warning(a1, a2);
}

void png_fixed_error(void (**a1)(void), uint64_t a2)
{
  LODWORD(v2) = 0;
  memset(v4, 0, sizeof(v4));
  int v5 = 0;
  qmemcpy(v3, "fixed point overflow in ", sizeof(v3));
  if (a2)
  {
    uint64_t v2 = 0;
    do
    {
      if (!*(unsigned char *)(a2 + v2)) {
        goto LABEL_6;
      }
      *((unsigned char *)v4 + v2) = *(unsigned char *)(a2 + v2);
      ++v2;
    }
    while (v2 != 195);
    LODWORD(v2) = 195;
  }
LABEL_6:
  v3[v2 + 24] = 0;
  _cg_png_error(a1, v3);
}

void *_TIFFGetFields()
{
  return &tiffFieldArray;
}

uint64_t _TIFFSetupFields(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (*(void *)(a1 + 1256))
  {
    unint64_t v11 = *(void *)(a1 + 1264);
    if (v11)
    {
      uint64_t v12 = 0;
      long long v13 = (void *)(a1 + 1256);
      unsigned int v14 = 1;
      do
      {
        uint64_t v15 = *(void *)(*v13 + 8 * v12);
        long long v16 = *(char **)(v15 + 32);
        if (v16 && *(_WORD *)(v15 + 24) == 65 && *(_DWORD *)(v15 + 12))
        {
          _TIFFfreeExt(a1, v16);
          _TIFFfreeExt(a1, (char *)v15);
          unint64_t v11 = *(void *)(a1 + 1264);
        }
        uint64_t v12 = v14;
      }
      while (v11 > v14++);
      _TIFFfreeExt(a1, *(char **)(a1 + 1256));
      void *v13 = 0;
      *(void *)(a1 + 1264) = 0;
    }
  }
  uint64_t result = _TIFFMergeFields(a1, *(int **)(a2 + 16), *(unsigned int *)(a2 + 8), a4, a5, a6, a7, a8);
  if (!result)
  {
    return TIFFErrorExtR(a1, "_TIFFSetupFields", "Setting up field info failed", v19, v20, v21, v22, v23, a9);
  }
  return result;
}

uint64_t TIFFFieldIsAnonymous(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t _TIFFMergeFields(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a3;
  *(void *)(a1 + 1272) = 0;
  unint64_t v11 = *(char **)(a1 + 1256);
  if (v11 && (uint64_t v12 = *(void *)(a1 + 1264)) != 0) {
    long long v13 = _TIFFCheckRealloc((const char **)a1, v11, v12 + a3, 8, (uint64_t)"for fields array", a6, a7, a8);
  }
  else {
    long long v13 = _TIFFCheckMalloc((const char **)a1, a3, 8, (uint64_t)"for fields array", a5, a6, a7, a8);
  }
  *(void *)(a1 + 125jp2_colour_converter::clear(this + 6) = v13;
  if (v13)
  {
    if (v8)
    {
      uint64_t v19 = v8;
      do
      {
        if (!TIFFFindField((void *)a1, *a2, 0))
        {
          uint64_t v20 = *(void *)(a1 + 1264);
          *(void *)(*(void *)(a1 + 1256) + 8 * v20) = a2;
          *(void *)(a1 + 1264) = v20 + 1;
        }
        a2 += 12;
        --v19;
      }
      while (v19);
      long long v13 = *(void **)(a1 + 1256);
    }
    qsort(v13, *(void *)(a1 + 1264), 8uLL, (int (__cdecl *)(const void *, const void *))tagCompare);
  }
  else
  {
    TIFFErrorExtR(a1, "_TIFFMergeFields", "Failed to allocate fields array", v14, v15, v16, v17, v18, v22);
    return 0;
  }
  return v8;
}

_DWORD *TIFFFindField(void *a1, int a2, int a3)
{
  memset(v7, 0, sizeof(v7));
  __key = v7;
  uint64_t result = (_DWORD *)a1[159];
  if (!result || *result != a2 || a3 && result[2] != a3)
  {
    int v5 = (const void *)a1[157];
    if (v5)
    {
      LODWORD(v7[0]) = a2;
      DWORD2(v7[0]) = a3;
      uint64_t result = bsearch(&__key, v5, a1[158], 8uLL, (int (__cdecl *)(const void *, const void *))tagCompare);
      if (result) {
        uint64_t result = *(_DWORD **)result;
      }
      a1[159] = result;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t tagCompare(int **a1, int **a2)
{
  uint64_t v2 = *a1;
  int v3 = **a1;
  int v4 = **a2;
  uint64_t result = (v3 - v4);
  if (v3 == v4)
  {
    int v6 = v2[2];
    if (v6) {
      return ((*a2)[2] - v6);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t TIFFDataWidth(unsigned int a1)
{
  if (a1 > 0x12) {
    return 0;
  }
  else {
    return dword_18898F3B8[a1];
  }
}

uint64_t TIFFFieldSetGetSize(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(int *)(result + 16);
    if (v1 > 0x33) {
      return 0;
    }
    else {
      return dword_18898F404[v1];
    }
  }
  return result;
}

_DWORD *TIFFFieldWithTag(void *a1, int a2)
{
  char v2 = a2;
  int v9 = TIFFFindField(a1, a2, 0);
  if (!v9) {
    TIFFWarningExtR((uint64_t)a1, "TIFFFieldWithTag", "Warning, unknown tag 0x%x", v4, v5, v6, v7, v8, v2);
  }
  return v9;
}

uint64_t TIFFFieldTag(unsigned int *a1)
{
  return *a1;
}

void *_TIFFCreateAnonField(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  unint64_t v11 = _TIFFmallocExt(a1, 48, a3, a4, a5, a6, a7, a8);
  uint64_t v12 = v11;
  if (v11)
  {
    _TIFFmemset(v11, 0, 0x30uLL);
    int v19 = 0;
    *(_DWORD *)uint64_t v12 = a2;
    *((_DWORD *)v12 + 1) = -131075;
    *((_DWORD *)v12 + 2) = v8;
    *((_DWORD *)v12 + ++*((_DWORD *)this + 3) = 1;
    if ((v8 - 1) <= 0x11) {
      int v19 = dword_18898F4D4[v8 - 1];
    }
    *((_DWORD *)v12 + 4) = v19;
    *((_DWORD *)v12 + 5) = v19;
    *((_DWORD *)v12 + jp2_colour_converter::clear(this + 6) = 16842817;
    uint64_t v20 = (char *)_TIFFmallocExt(a1, 32, v13, v14, v15, v16, v17, v18);
    v12[4] = v20;
    if (v20)
    {
      void v12[5] = 0;
      snprintf(v20, 0x20uLL, "Tag %d", a2);
    }
    else
    {
      _TIFFfreeExt((uint64_t)a1, (char *)v12);
      return 0;
    }
  }
  return v12;
}

uint64_t _TIFFCheckFieldIsValidForCodec(uint64_t a1, int a2)
{
  if (((a2 - 292) > 0x37 || ((1 << (a2 - 36)) & 0x80001C02000003) == 0)
    && ((a2 - 512) > 9 || ((1 << a2) & 0x38F) == 0)
    && a2 != 50674)
  {
    return 1;
  }
  uint64_t result = (uint64_t)_cg_TIFFIsCODECConfigured(*(unsigned __int16 *)(a1 + 120));
  if (result)
  {
    unsigned int v5 = *(unsigned __int16 *)(a1 + 120);
    if (v5 <= 0x8002)
    {
      switch(*(_WORD *)(a1 + 120))
      {
        case 2:
        case 3:
        case 4:
          goto LABEL_16;
        case 5:
        case 8:
          return a2 == 317;
        case 6:
          if ((a2 - 512) >= 0xA) {
            return 0;
          }
          uint64_t result = dword_18898F51C[a2 - 512];
          break;
        case 7:
          return a2 == 347;
        default:
          return 0;
      }
      return result;
    }
    if (*(unsigned __int16 *)(a1 + 120) > 0x8846u)
    {
      if (v5 == 34887) {
        return a2 == 50674;
      }
      if (v5 == 34925) {
        return a2 == 317;
      }
      int v6 = 50000;
    }
    else
    {
      if (v5 == 32771)
      {
LABEL_16:
        if ((a2 - 326) < 3) {
          return 1;
        }
        if (a2 == 293)
        {
          if (v5 == 4) {
            return 1;
          }
        }
        else if (a2 == 292 && v5 == 3)
        {
          return 1;
        }
        return 0;
      }
      if (v5 == 32909) {
        return a2 == 317;
      }
      int v6 = 32946;
    }
    if (v5 != v6) {
      return 0;
    }
    return a2 == 317;
  }
  return result;
}

uint64_t CGCreatePNGDataFromSVGData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGCreatePNGDataFromSVGData", 0, 0, -1, 0);
  }
  if (a1)
  {
    if (a3) {
      return 4294967292;
    }
    _cg_jpeg_mem_term("CGCreatePNGDataFromSVGData", 293, "*** ERROR: CGCreatePNGDataFromSVGData - pngData is NULL\n");
  }
  else
  {
    _cg_jpeg_mem_term("CGCreatePNGDataFromSVGData", 292, "*** ERROR: CGCreatePNGDataFromSVGData - svgData is NULL\n");
  }
  return 4294967246;
}

void *PDFReadPlugin::PDFReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result = (void *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *uint64_t result = &unk_1ED4E0690;
  result[56] = 0;
  result[57] = 0;
  result[55] = 0;
  return result;
}

void PDFReadPlugin::PDFReadPlugin(uint64_t a1, uint64_t a2)
{
}

void PDFReadPlugin::~PDFReadPlugin(PDFReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t PDFReadPlugin::loadDataFromXPCObject(PDFReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_pdf", &length);
    if (length == 24)
    {
      int v6 = data;
      uint64_t result = 0;
      long long v7 = *(_OWORD *)v6;
      *((void *)this + 57) = v6[2];
      *(_OWORD *)((char *)this + 440) = v7;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t PDFReadPlugin::saveDataToXPCObject(PDFReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_pdf", (char *)this + 440, 0x18uLL);
  }
  return v4;
}

uint64_t PDFReadPlugin::initialize(IIOImageReadSession **this, IIODictionary *a2)
{
  uint64_t v34 = 0;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v30, this[3]);
  *((void *)&v31 + 1) = 0;
  if ((IIOImageReadSession::isFinal(this[3]) & 1) == 0
    || (SessionPDFRef = CreateSessionPDFRef((off_t *)&v30, 0), (uint64_t v4 = SessionPDFRef) == 0))
  {
    uint64_t v28 = 4294967246;
    goto LABEL_47;
  }
  Page = CGPDFDocumentGetPage(SessionPDFRef, (*((_DWORD *)this + 52) + 1));
  int v6 = Page;
  if (!Page) {
    goto LABEL_40;
  }
  RotationAngle = (PDFReadPlugin *)CGPDFPageGetRotationAngle(Page);
  int v8 = (int)RotationAngle;
  PDFReadPlugin::getPageBox(RotationAngle, v6);
  if ((v8 / 90)) {
    double v11 = v10;
  }
  else {
    double v11 = v9;
  }
  if ((v8 / 90)) {
    double v12 = v9;
  }
  else {
    double v12 = v10;
  }
  if (IIODictionary::containsKey(this[6], @"kCGImageSourceDrawAnnotations")) {
    *((unsigned char *)this + 441) = IIODictionary::getBoolForKey(this[6], @"kCGImageSourceDrawAnnotations");
  }
  unint64_t v13 = *((unsigned int *)this + 53);
  if (!v13)
  {
    _cg_jpeg_mem_term("initialize", 113, "*** ERROR: PDF decode can only be used with 'CGImageSourceCreateThumbnailAtIndex'\n");
LABEL_40:
    char v27 = 0;
    uint64_t v28 = 4294967246;
    goto LABEL_46;
  }
  unint64_t v14 = (unint64_t)v11;
  unint64_t v15 = (unint64_t)v12;
  if ((unint64_t)v11 > v13 || v15 > v13)
  {
    float v17 = (float)v13;
    if (v14 <= v15) {
      unint64_t v18 = (unint64_t)v12;
    }
    else {
      unint64_t v18 = (unint64_t)v11;
    }
    float v19 = v17 / (float)v18;
    float v20 = floorf(v19 * (float)v14);
    if (v14 >= v15) {
      float v20 = v17;
    }
    float v21 = floorf(v19 * (float)v15);
    if (v14 > v15) {
      float v17 = v21;
    }
    if ((unint64_t)v20 <= 1) {
      unint64_t v14 = 1;
    }
    else {
      unint64_t v14 = (unint64_t)v20;
    }
    if ((unint64_t)v17 <= 1) {
      unint64_t v15 = 1;
    }
    else {
      unint64_t v15 = (unint64_t)v17;
    }
  }
  if (v14) {
    BOOL v22 = v15 == 0;
  }
  else {
    BOOL v22 = 1;
  }
  if (v22) {
    goto LABEL_40;
  }
  *((_DWORD *)this + 57) = v14;
  *((_DWORD *)this + 58) = v15;
  this[30] = (IIOImageReadSession *)0x5000400200008;
  *((_DWORD *)this + 59) = 4 * v14;
  *((unsigned char *)this + 344) = 0;
  *((unsigned char *)this + 34jp2_colour_converter::clear(this + 6) = 0;
  *((_DWORD *)this + 81) = 1380401696;
  int v23 = CGPDFPageContainsWideGamutContent();
  long long v24 = (CFStringRef *)MEMORY[0x1E4F1DB90];
  if (!v23) {
    long long v24 = (CFStringRef *)MEMORY[0x1E4F1DC98];
  }
  this[20] = CGColorSpaceCreateWithName(*v24);
  this[56] = (IIOImageReadSession *)v14;
  this[57] = (IIOImageReadSession *)v15;
  *((unsigned char *)this + 440) = *((_DWORD *)this + 53) != 0;
  unsigned int v25 = IIODictionary::containsKey(this[6], @"kCGImageSourceUsePDFBackgroundWhite");
  uint64_t v26 = this[6];
  if (v25)
  {
    *((unsigned char *)this + 442) = IIODictionary::getBoolForKey(v26, @"kCGImageSourceUsePDFBackgroundWhite");
  }
  else if (IIODictionary::containsKey(v26, @"kCGImageSourceUsePDFBackgroundBlack"))
  {
    *((unsigned char *)this + 44++*((_DWORD *)this + 3) = IIODictionary::getBoolForKey(this[6], @"kCGImageSourceUsePDFBackgroundBlack");
  }
  else if (*((_DWORD *)this + 53))
  {
    *((unsigned char *)this + 442) = 1;
  }
  uint64_t v28 = 0;
  char v27 = 1;
  this[45] = (IIOImageReadSession *)1;
  *((_WORD *)this + 188) = 1;
LABEL_46:
  CGPDFDocumentRelease(v4);
  if ((v27 & 1) == 0) {
LABEL_47:
  }
    kdebug_trace();
  IIOScanner::~IIOScanner((IIOScanner *)&v30);
  return v28;
}

void sub_1886FCB54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

double PDFReadPlugin::getPageBox(PDFReadPlugin *this, CGPDFPageRef page)
{
  CGRect BoxRect = CGPDFPageGetBoxRect(page, kCGPDFCropBox);
  CGFloat x = BoxRect.origin.x;
  CGFloat y = BoxRect.origin.y;
  CGFloat width = BoxRect.size.width;
  CGFloat height = BoxRect.size.height;
  CGRect v18 = CGPDFPageGetBoxRect(page, kCGPDFMediaBox);
  CGFloat v7 = v18.origin.x;
  CGFloat v8 = v18.origin.y;
  CGFloat v9 = v18.size.width;
  CGFloat v10 = v18.size.height;
  CGFloat v11 = x;
  CGFloat v12 = y;
  CGFloat v13 = width;
  CGFloat v14 = height;

  *(void *)&double result = (unint64_t)CGRectIntersection(*(CGRect *)&v11, *(CGRect *)&v7);
  return result;
}

CGFloat PDFReadPlugin::getPageDrawingTransform@<D0>(PDFReadPlugin *this@<X0>, CGPDFPage *a2@<X1>, CGRect a3@<0:D0, 8:D1, 16:D2, 24:D3>, uint64_t a4@<X8>)
{
  CGFloat width = a3.size.width;
  CGFloat height = a3.size.height;
  CGFloat y = a3.origin.y;
  CGFloat x = a3.origin.x;
  *(_OWORD *)(a4 + 1jp2_colour_converter::clear(this + 6) = 0u;
  *(_OWORD *)(a4 + 32) = 0u;
  *(_OWORD *)a4 = 0u;
  memset(&v51, 0, sizeof(v51));
  v52.origin.CGFloat x = PDFReadPlugin::getPageBox(this, a2);
  CGFloat v7 = v52.origin.x;
  CGFloat v8 = v52.origin.y;
  CGFloat v9 = v52.size.width;
  CGFloat v10 = v52.size.height;
  double MinX = CGRectGetMinX(v52);
  v53.origin.CGFloat x = v7;
  v53.origin.CGFloat y = v8;
  v53.size.CGFloat width = v9;
  v53.size.CGFloat height = v10;
  float MinY = CGRectGetMinY(v53);
  float v36 = MinY;
  v54.origin.CGFloat x = v7;
  v54.origin.CGFloat y = v8;
  v54.size.CGFloat width = v9;
  v54.size.CGFloat height = v10;
  float MaxX = CGRectGetMaxX(v54);
  v55.origin.CGFloat x = v7;
  v55.origin.CGFloat y = v8;
  v55.size.CGFloat width = v9;
  v55.size.CGFloat height = v10;
  double MaxY = CGRectGetMaxY(v55);
  v56.origin.CGFloat x = v7;
  v56.origin.CGFloat y = v8;
  v56.size.CGFloat width = v9;
  v56.size.CGFloat height = v10;
  float v14 = CGRectGetWidth(v56);
  v57.origin.CGFloat x = v7;
  v57.origin.CGFloat y = v8;
  v57.size.CGFloat width = v9;
  v57.size.CGFloat height = v10;
  float v15 = CGRectGetHeight(v57);
  int v16 = CGPDFPageGetRotationAngle(a2) % 360;
  int v17 = v16 + (v16 < 0 ? 0x168 : 0);
  if (v17 == 90)
  {
    float v19 = -v36;
    *(_OWORD *)a4 = xmmword_18898F550;
    *(_OWORD *)(a4 + 1jp2_colour_converter::clear(this + 6) = xmmword_18898F1E0;
    goto LABEL_6;
  }
  if (v17 == 180)
  {
    *(void *)a4 = 0xBFF0000000000000;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 1jp2_colour_converter::clear(this + 6) = 0;
    *(void *)(a4 + 24) = 0xBFF0000000000000;
    float v19 = MaxX;
    float MaxX = MaxY;
  }
  else
  {
    float v18 = MinX;
    if (v17 == 270)
    {
      float MaxX = -v18;
      *(_OWORD *)a4 = xmmword_18898F560;
      *(_OWORD *)(a4 + 1jp2_colour_converter::clear(this + 6) = xmmword_18898F570;
      float v19 = MaxY;
LABEL_6:
      float v20 = v14;
      float v14 = v15;
      goto LABEL_10;
    }
    float v19 = -v18;
    float MaxX = -v36;
    *(void *)a4 = 0x3FF0000000000000;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 1jp2_colour_converter::clear(this + 6) = 0;
    *(void *)(a4 + 24) = 0x3FF0000000000000;
  }
  float v20 = v15;
LABEL_10:
  float v38 = v20;
  *(double *)(a4 + 32) = v19;
  *(double *)(a4 + 40) = MaxX;
  CGAffineTransformMakeTranslation(&v51, (float)(v14 * -0.5), (float)(v20 * -0.5));
  long long v21 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)&t1.a = *(_OWORD *)a4;
  *(_OWORD *)&t1.c = v21;
  *(_OWORD *)&t1.tCGFloat x = *(_OWORD *)(a4 + 32);
  CGAffineTransform t2 = v51;
  CGAffineTransformConcat((CGAffineTransform *)a4, &t1, &t2);
  v58.origin.CGFloat x = x;
  v58.origin.CGFloat y = y;
  v58.size.CGFloat width = width;
  v58.size.CGFloat height = height;
  double v22 = CGRectGetMinX(v58);
  v59.origin.CGFloat x = x;
  v59.origin.CGFloat y = y;
  v59.size.CGFloat width = width;
  v59.size.CGFloat height = height;
  double v23 = CGRectGetMinY(v59);
  v60.origin.CGFloat x = x;
  v60.origin.CGFloat y = y;
  v60.size.CGFloat width = width;
  v60.size.CGFloat height = height;
  float v24 = CGRectGetWidth(v60);
  v61.origin.CGFloat x = x;
  v61.origin.CGFloat y = y;
  v61.size.CGFloat width = width;
  v61.size.CGFloat height = height;
  float v25 = CGRectGetHeight(v61);
  float v26 = v24 / v14;
  if ((float)(v24 / v14) < (float)(v25 / v38)) {
    float v26 = v25 / v38;
  }
  CGAffineTransformMakeScale(&v48, v26, v26);
  CGAffineTransform v51 = v48;
  long long v29 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)&v47.a = *(_OWORD *)a4;
  *(_OWORD *)&v47.c = v29;
  *(_OWORD *)&v47.tCGFloat x = *(_OWORD *)(a4 + 32);
  CGAffineTransform v46 = v48;
  CGAffineTransformConcat(&v48, &v47, &v46);
  long long v30 = *(_OWORD *)&v48.c;
  *(_OWORD *)a4 = *(_OWORD *)&v48.a;
  *(_OWORD *)(a4 + 1jp2_colour_converter::clear(this + 6) = v30;
  *(_OWORD *)(a4 + 32) = *(_OWORD *)&v48.tx;
  CGAffineTransformMakeTranslation(&v48, (float)(v24 * 0.5), (float)(v25 * 0.5));
  CGAffineTransform v51 = v48;
  long long v31 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)&v45.a = *(_OWORD *)a4;
  *(_OWORD *)&v45.c = v31;
  *(_OWORD *)&v45.tCGFloat x = *(_OWORD *)(a4 + 32);
  CGAffineTransform v44 = v48;
  CGAffineTransformConcat(&v48, &v45, &v44);
  long long v32 = *(_OWORD *)&v48.c;
  *(_OWORD *)a4 = *(_OWORD *)&v48.a;
  *(_OWORD *)(a4 + 1jp2_colour_converter::clear(this + 6) = v32;
  *(_OWORD *)(a4 + 32) = *(_OWORD *)&v48.tx;
  float v28 = v22;
  float v27 = v23;
  CGAffineTransformMakeTranslation(&v48, v28, v27);
  CGAffineTransform v51 = v48;
  long long v33 = *(_OWORD *)(a4 + 16);
  *(_OWORD *)&v43.a = *(_OWORD *)a4;
  *(_OWORD *)&v43.c = v33;
  *(_OWORD *)&v43.tCGFloat x = *(_OWORD *)(a4 + 32);
  CGAffineTransform v42 = v48;
  CGAffineTransformConcat(&v48, &v43, &v42);
  long long v34 = *(_OWORD *)&v48.c;
  *(_OWORD *)a4 = *(_OWORD *)&v48.a;
  *(_OWORD *)(a4 + 1jp2_colour_converter::clear(this + 6) = v34;
  CGFloat result = v48.tx;
  *(_OWORD *)(a4 + 32) = *(_OWORD *)&v48.tx;
  return result;
}

uint64_t PDFReadPlugin::decodeImageData(IIOImageReadSession **this, unsigned __int8 *a2)
{
  size_t v4 = *((unsigned int *)this + 66);
  size_t v5 = *((unsigned int *)this + 65);
  size_t v6 = *((unsigned int *)this + 75);
  uint64_t v21 = 0;
  memset(v20, 0, sizeof(v20));
  IIOScanner::IIOScanner((IIOScanner *)v20, this[3]);
  SessionPDFuint64_t Ref = CreateSessionPDFRef((off_t *)v20, 0);
  CGFloat v8 = SessionPDFRef;
  if (SessionPDFRef)
  {
    Page = CGPDFDocumentGetPage(SessionPDFRef, (*((_DWORD *)this + 52) + 1));
    CGFloat v10 = (PDFReadPlugin *)pthread_mutex_lock(&PDFReadPlugin::decodeImageData(unsigned char *,unsigned long)::lock);
    v23.size.CGFloat width = (double)v5;
    v23.size.CGFloat height = (double)v4;
    v23.origin.CGFloat x = 0.0;
    v23.origin.CGFloat y = 0.0;
    PDFReadPlugin::getPageDrawingTransform(v10, Page, v23, (uint64_t)&v19);
    CGAffineTransform v22 = v19;
    CGFloat v11 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
    if (v11)
    {
      if (PDFReadPlugin::decodeImageData(unsigned char *,unsigned long)::onceToken != -1) {
        dispatch_once(&PDFReadPlugin::decodeImageData(unsigned char *,unsigned long)::onceToken, &__block_literal_global_4);
      }
      if (*((unsigned char *)this + 443))
      {
        bzero(a2, v6 * (unint64_t)v4);
      }
      else if (*((unsigned char *)this + 440) || *((unsigned char *)this + 442))
      {
        memset(a2, 255, v6 * (unint64_t)v4);
      }
      if (*((unsigned char *)this + 440)) {
        int v13 = 5;
      }
      else {
        int v13 = 1;
      }
      if (*((unsigned char *)this + 440)) {
        int v14 = 8198;
      }
      else {
        int v14 = 8194;
      }
      if (*((unsigned char *)this + 405)) {
        uint32_t v15 = v13;
      }
      else {
        uint32_t v15 = v14;
      }
      int v16 = CGBitmapContextCreate(a2, v5, v4, 8uLL, v6, v11, v15);
      if (v16)
      {
        if (*((unsigned char *)this + 440)) {
          CGContextSetTextGreekingThreshold();
        }
        CGContextSetShouldSmoothFonts(v16, 0);
        CGAffineTransform v18 = v22;
        CGContextConcatCTM(v16, &v18);
        if (*((unsigned char *)this + 441)) {
          CGContextDrawPDFPageWithAnnotations();
        }
        else {
          CGContextDrawPDFPage(v16, Page);
        }
        CGContextRelease(v16);
        uint64_t v12 = 0;
      }
      else
      {
        _cg_jpeg_mem_term("decodeImageData", 319, "*** ERROR: CGBitmapContextCreate returned NULL\n");
        uint64_t v12 = 4294967243;
      }
      CGColorSpaceRelease(v11);
    }
    else
    {
      uint64_t v12 = 4294967243;
    }
    pthread_mutex_unlock(&PDFReadPlugin::decodeImageData(unsigned char *,unsigned long)::lock);
    CGPDFDocumentRelease(v8);
  }
  else
  {
    _cg_jpeg_mem_term("decodeImageData", 278, "*** could not create PDFDocument\n");
    uint64_t v12 = 4294967243;
  }
  IIOScanner::~IIOScanner((IIOScanner *)v20);
  return v12;
}

void sub_1886FD24C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

uint64_t PDFReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  memory_object_size_t v36 = 0;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v8 = *((_DWORD *)this + 51);
    unsigned int v9 = v8 >> 24;
    uint64_t v10 = MEMORY[0x1E4F14390];
    if (v8 < 0)
    {
      int v11 = __maskrune(v9, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
    }
    if (v11) {
      uint64_t v12 = (v8 >> 24);
    }
    else {
      uint64_t v12 = 46;
    }
    unsigned int v13 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      int v14 = __maskrune(v13, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    }
    if (v14) {
      uint64_t v15 = (v8 << 8 >> 24);
    }
    else {
      uint64_t v15 = 46;
    }
    unsigned int v16 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      int v17 = __maskrune(v16, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = ((__int16)v8 >> 8);
    }
    else {
      uint64_t v18 = 46;
    }
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0) {
        goto LABEL_22;
      }
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_22:
      uint64_t v19 = *((char *)this + 204);
LABEL_25:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus PDFReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    uint64_t v19 = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  uint64_t BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
  if (a3 == 3)
  {
    uint64_t v21 = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v27) = *((_DWORD *)this + 73);
    double v26 = (double)v27;
    unsigned int v28 = *((_DWORD *)this + 74);
    double v25 = (double)v28;
    memory_object_size_t v24 = *((unsigned int *)this + 75) * (unint64_t)v28;
    BaseAddress = (void *)_ImageIO_Malloc(v24, *((void *)this + 48), &v36, (uint64_t)kImageMalloc_PDF_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    uint64_t v21 = BlockArray;
    if (a3 != 1 || !a4 || !*a4) {
      return v21;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    size_t Height = IOSurfaceGetHeight(*a4);
    memory_object_size_t v24 = IOSurfaceGetBytesPerRow(*a4) * Height;
    memory_object_size_t v36 = v24;
    double v25 = 0.0;
    double v26 = 0.0;
  }
  if (BaseAddress)
  {
    uint64_t v29 = (*(uint64_t (**)(IIOReadPlugin *, void *, memory_object_size_t))(*(void *)this + 120))(this, BaseAddress, v24);
    if (v29)
    {
      uint64_t v21 = v29;
      *((_DWORD *)this + 2jp2_colour_converter::clear(this + 6) = 0;
      if (a3 == 3) {
        _ImageIO_Free((unint64_t)BaseAddress, v36);
      }
    }
    else if (a3 == 3)
    {
      uint64_t v30 = 0;
      v37.origin.CGFloat x = 0.0;
      v37.origin.CGFloat y = 0.0;
      v37.size.CGFloat width = v26;
      v37.size.CGFloat height = v25;
      **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v24, v37, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
      if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E4F1DB20]))
      {
        uint64_t v31 = 0;
      }
      else
      {
        v38.origin.CGFloat x = 0.0;
        v38.origin.CGFloat y = 0.0;
        v38.size.CGFloat width = v26;
        v38.size.CGFloat height = v25;
        *(CGRect *)(&v31 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v38);
        uint64_t v30 = v32;
        double v26 = v33;
        double v25 = v34;
      }
      uint64_t v21 = 0;
      *((void *)this + 15) = v30;
      *((void *)this + 1jp2_colour_converter::clear(this + 6) = v31;
      *((double *)this + 17) = v26;
      *((double *)this + 18) = v25;
    }
    else
    {
      IOSurfaceUnlock(*a4, 0, 0);
      return 0;
    }
  }
  return v21;
}

double BMPReadPlugin::BMPReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v5 = IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *(void *)uint64_t v5 = &unk_1ED4DF650;
  double result = 0.0;
  *(_OWORD *)(v5 + 440) = 0u;
  *(_OWORD *)(v5 + 45jp2_colour_converter::clear(this + 6) = 0u;
  *(_OWORD *)(v5 + 472) = 0u;
  return result;
}

void BMPReadPlugin::BMPReadPlugin(uint64_t a1, uint64_t a2)
{
}

void BMPReadPlugin::~BMPReadPlugin(BMPReadPlugin *this)
{
  IIOReadPlugin::~IIOReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t BMPReadPlugin::loadDataFromXPCObject(BMPReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = (long long *)xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_bmp", &length);
    if (length == 48)
    {
      size_t v6 = data;
      uint64_t result = 0;
      long long v7 = *v6;
      long long v8 = v6[2];
      *(_OWORD *)((char *)this + 45jp2_colour_converter::clear(this + 6) = v6[1];
      *(_OWORD *)((char *)this + 472) = v8;
      *(_OWORD *)((char *)this + 440) = v7;
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t BMPReadPlugin::saveDataToXPCObject(BMPReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_bmp", (char *)this + 440, 0x30uLL);
  }
  return v4;
}

void BMPReadPlugin::debugHeader(uint64_t a1, int *a2)
{
  int v2 = *a2;
  if (*a2 > 55)
  {
    if (v2 > 107)
    {
      if (v2 == 108)
      {
        ImageIOLog("bmp v4\n");
      }
      else if (v2 == 124)
      {
        ImageIOLog("bmp v5\n");
      }
    }
    else if (v2 == 56)
    {
      ImageIOLog("bmp v3 with RGBA masks\n");
    }
    else if (v2 == 64)
    {
      ImageIOLog("bmp OS2 v2\n");
    }
  }
  else if (v2 > 39)
  {
    if (v2 == 40)
    {
      ImageIOLog("bmp v3\n");
    }
    else if (v2 == 52)
    {
      ImageIOLog("bmp v3 with RGB masks\n");
    }
  }
  else if (v2 == 12)
  {
    ImageIOLog("bmp OS2 v1\n");
  }
  else if (v2 == 16)
  {
    ImageIOLog("bmp v2\n");
  }
}

uint64_t BMPReadPlugin::readHeader(uint64_t a1, uint64_t a2, IIOScanner *this)
{
  IIOScanner::seek(this, 0);
  IIOScanner::getVal8(this);
  IIOScanner::getVal8(this);
  unsigned int Val32 = IIOScanner::getVal32(this);
  IIOScanner::getVal32(this);
  uint64_t result = IIOScanner::getVal32(this);
  *(_DWORD *)(a1 + 448) = result;
  if (result)
  {
    unsigned int v8 = result;
    unint64_t v9 = *(void *)(a1 + 184);
    if (v9 <= result) {
      return 0;
    }
    if (v9 < Val32)
    {
      _cg_jpeg_mem_term("readHeader", 129, "*** fileHdr.filesize > fileSize (%d > %d) - continuing...\n", Val32, v9);
      unint64_t v9 = *(void *)(a1 + 184);
    }
    if (v9 <= 0x1A)
    {
      _cg_jpeg_mem_term("readHeader", 132, "*** fileSize (%d) too small\n");
      return 0;
    }
    if (v8 <= 0x19)
    {
      _cg_jpeg_mem_term("readHeader", 133, "*** dataOffset (%d) too small\n");
      return 0;
    }
    if (v9 <= v8)
    {
      _cg_jpeg_mem_term("readHeader", 134, "*** dataOffset (%d) too big\n");
      return 0;
    }
    int v10 = IIOScanner::getVal32(this);
    *(_DWORD *)a2 = v10;
    if (((v10 - 12) > 0x34 || ((1 << (v10 - 12)) & 0x10110010000011) == 0)
      && v10 != 124
      && v10 != 108)
    {
      return 0;
    }
    *(_DWORD *)(a2 + 4) = IIOScanner::getVal32(this);
    *(_DWORD *)(a2 + 8) = IIOScanner::getVal32(this);
    int Val16 = IIOScanner::getVal16(this);
    *(_WORD *)(a2 + 12) = Val16;
    if (*(_DWORD *)a2 != 12 && Val16 != 1) {
      return 0;
    }
    uint64_t v12 = IIOScanner::getVal16(this);
    *(_WORD *)(a2 + 14) = v12;
    unsigned int v13 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 == 12)
    {
      unsigned int v13 = 12;
      goto LABEL_36;
    }
    if (v12 != 1)
    {
      if (v12 == 2 && v13 == 40) {
        goto LABEL_20;
      }
      HIDWORD(v14) = v12;
      LODWORD(v14) = (v12 << 16) - 0x40000;
      unsigned int v15 = (unsigned __int16)(v14 >> 18);
      if (v15 > 7 || ((1 << v15) & 0xAB) == 0)
      {
        _cg_jpeg_mem_term("readHeader", 165, "*** ERROR: BMP-header-size: %d - does not support bpp: %d\n");
        return 0;
      }
    }
    if (v13 < 0x10) {
      goto LABEL_36;
    }
LABEL_20:
    uint64_t v12 = IIOScanner::getVal32(this);
    *(_DWORD *)(a2 + 1jp2_colour_converter::clear(this + 6) = v12;
    unsigned int v13 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 == 40 && v12 == 3)
    {
      *(_DWORD *)a2 = 52;
    }
    else if (v13 < 0x28)
    {
      goto LABEL_36;
    }
    *(_DWORD *)(a2 + 20) = IIOScanner::getVal32(this);
    *(_DWORD *)(a2 + 24) = IIOScanner::getVal32(this);
    *(_DWORD *)(a2 + 28) = IIOScanner::getVal32(this);
    *(_DWORD *)(a2 + 32) = IIOScanner::getVal32(this);
    uint64_t v12 = IIOScanner::getVal32(this);
    *(_DWORD *)(a2 + 3jp2_colour_converter::clear(this + 6) = v12;
    unsigned int v16 = *(_DWORD *)(a2 + 32);
    if (v16 >= 0x101)
    {
      _cg_jpeg_mem_term("readHeader", 186, "*** ERROR: unsupported number of colors in palette (%d)\n");
    }
    else
    {
      if (v12 <= v16)
      {
        unsigned int v13 = *(_DWORD *)a2;
        if (*(_DWORD *)a2 == 64)
        {
          unsigned int v13 = 64;
        }
        else if (v13 >= 0x34)
        {
          *(_DWORD *)(a2 + 40) = IIOScanner::getVal32(this);
          *(_DWORD *)(a2 + 44) = IIOScanner::getVal32(this);
          uint64_t v12 = IIOScanner::getVal32(this);
          *(_DWORD *)(a2 + 48) = v12;
          unsigned int v13 = *(_DWORD *)a2;
          if (*(_DWORD *)a2 >= 0x38u)
          {
            uint64_t v12 = IIOScanner::getVal32(this);
            *(_DWORD *)(a2 + 52) = v12;
            unsigned int v13 = *(_DWORD *)a2;
            if (*(_DWORD *)a2 >= 0x6Cu)
            {
              *(_DWORD *)(a2 + 5jp2_colour_converter::clear(this + 6) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 60) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 64) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 68) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 72) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 7jp2_colour_converter::clear(this + 6) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 80) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 84) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 88) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 92) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 9jp2_colour_converter::clear(this + 6) = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 100) = IIOScanner::getVal32(this);
              uint64_t v12 = IIOScanner::getVal32(this);
              *(_DWORD *)(a2 + 104) = v12;
              unsigned int v13 = *(_DWORD *)a2;
              if (*(_DWORD *)a2 >= 0x7Cu)
              {
                *(_DWORD *)(a2 + 108) = IIOScanner::getVal32(this);
                *(_DWORD *)(a2 + 112) = IIOScanner::getVal32(this);
                *(_DWORD *)(a2 + 11jp2_colour_converter::clear(this + 6) = IIOScanner::getVal32(this);
                uint64_t v12 = IIOScanner::getVal32(this);
                *(_DWORD *)(a2 + 120) = v12;
                unsigned int v13 = *(_DWORD *)a2;
              }
            }
          }
        }
LABEL_36:
        *(_DWORD *)(a1 + 452) = v13 + 14;
        if (*(unsigned char *)(a1 + 181))
        {
          BMPReadPlugin::debugHeader(v12, (int *)a2);
          unsigned int v13 = *(_DWORD *)a2;
        }
        if (v13 == 64)
        {
          int v17 = 40;
        }
        else
        {
          if (v13 != 12) {
            return 1;
          }
          *(_DWORD *)(a2 + 12) = *(_DWORD *)(a2 + 8);
          *(_WORD *)(a2 + 10) = 0;
          *(_WORD *)(a2 + 8) = *(_WORD *)(a2 + 6);
          *(_WORD *)(a2 + jp2_colour_converter::clear(this + 6) = 0;
          int v17 = 16;
        }
        *(_DWORD *)a2 = v17;
        return 1;
      }
      _cg_jpeg_mem_term("readHeader", 187, "*** ERROR: bad number of important colors (%d/%d)\n");
    }
    return 0;
  }
  return result;
}

uint64_t BMPReadPlugin::initialize(BMPReadPlugin *this, IIODictionary *a2)
{
  long long v74 = 0u;
  memset(v75, 0, 92);
  long long v73 = 0u;
  uint64_t v72 = 0;
  memset(v71, 0, sizeof(v71));
  IIOScanner::IIOScanner((IIOScanner *)v71, *((IIOImageReadSession **)this + 3));
  if (*((unsigned char *)this + 341) && (BMPReadPlugin::readHeader((uint64_t)this, (uint64_t)&v73, (IIOScanner *)v71) & 1) != 0)
  {
    int v3 = DWORD2(v73);
    uint64_t v4 = v73;
    if ((SDWORD2(v73) & 0x80000000) == 0) {
      unsigned int v5 = DWORD2(v73);
    }
    else {
      unsigned int v5 = -DWORD2(v73);
    }
    if (v73 == 40 && v74 == 3) {
      *((_DWORD *)this + 11++*((_DWORD *)this + 3) = 66;
    }
    unsigned int v6 = DWORD1(v73);
    bzero((char *)&v73 + v4, 124 - v4);
    if (DWORD2(v74) && HIDWORD(v74))
    {
      float v7 = (float)DWORD2(v74) * 0.0254;
      float v8 = (float)HIDWORD(v74) * 0.0254;
      if (fabsf(v7 + -72.0) < 0.05) {
        float v7 = 72.0;
      }
      if (fabsf(v8 + -72.0) < 0.05) {
        float v8 = 72.0;
      }
      if (fabsf(v7 + -96.0) >= 0.05) {
        float v9 = v7;
      }
      else {
        float v9 = 96.0;
      }
      if (fabsf(v8 + -96.0) >= 0.05) {
        float v10 = v8;
      }
      else {
        float v10 = 96.0;
      }
      if (ValidDPI(v9) && ValidDPI(v10))
      {
        uint64_t v11 = *((void *)this + 7);
        IIONumber::IIONumber((IIONumber *)v70, v9);
        IIODictionary::setObjectForKey(v11, (uint64_t)v70, @"DPIWidth");
        IIONumber::~IIONumber((IIONumber *)v70);
        uint64_t v12 = *((void *)this + 7);
        IIONumber::IIONumber((IIONumber *)v69, v10);
        IIODictionary::setObjectForKey(v12, (uint64_t)v69, @"DPIHeight");
        IIONumber::~IIONumber((IIONumber *)v69);
      }
    }
    *((_DWORD *)this + 57) = v6;
    *((_DWORD *)this + 58) = v5;
    int v13 = HIWORD(v73);
    *((_WORD *)this + 121) = HIWORD(v73);
    unsigned int v14 = v74;
    *((_DWORD *)this + 114) = v74;
    if (v6)
    {
      if (v3 && WORD6(v73) == 1)
      {
        unsigned int v15 = v73;
        if (v73 < 0x7C)
        {
          if (v73 >= 0x6C && DWORD2(v75[1]) > 1) {
            goto LABEL_164;
          }
        }
        else if ((DWORD2(v75[1]) > 4 || DWORD2(v75[1]) == 3) && DWORD2(v75[1]) != 1934772034)
        {
          goto LABEL_164;
        }
        if (v13 <= 15)
        {
          switch(v13)
          {
            case 1:
              if (!v14) {
                goto LABEL_73;
              }
              int v16 = 1;
              uint64_t v17 = 353;
              break;
            case 2:
              if (!v14) {
                goto LABEL_73;
              }
              int v16 = 2;
              uint64_t v17 = 356;
              break;
            case 4:
              if ((v14 | 2) == 2) {
                goto LABEL_73;
              }
              int v16 = 4;
              uint64_t v17 = 359;
              break;
            case 8:
              if (v14 < 2) {
                goto LABEL_73;
              }
              int v16 = 8;
              uint64_t v17 = 362;
              break;
            default:
              goto LABEL_164;
          }
          goto LABEL_163;
        }
        switch(v13)
        {
          case 16:
            if (v14)
            {
              if (v14 != 3)
              {
                int v16 = 16;
                uint64_t v17 = 365;
                goto LABEL_163;
              }
              goto LABEL_52;
            }
            goto LABEL_73;
          case 24:
            if (v14)
            {
              int v16 = 24;
              uint64_t v17 = 368;
              goto LABEL_163;
            }
            goto LABEL_58;
          case 32:
            if (v14)
            {
              if (v14 != 3)
              {
                int v16 = 32;
                uint64_t v17 = 371;
LABEL_163:
                _cg_jpeg_mem_term("initialize", v17, "bitsPerPixel: %d   compression: %d\n", v16, v14);
                break;
              }
LABEL_52:
              if (v73 < 0x34) {
                break;
              }
              v18.i64[0] = *((void *)&v75[0] + 1);
              if ((HIDWORD(v75[0]) & DWORD2(v75[0])) != 0
                || (v75[1] & DWORD2(v75[0])) != 0
                || (DWORD1(v75[1]) | LODWORD(v75[1])) & HIDWORD(v75[0]) | DWORD1(v75[1]) & (LODWORD(v75[1]) | DWORD2(v75[0])))
              {
                break;
              }
              v18.i64[1] = *(void *)&v75[1];
              int32x4_t v19 = (int32x4_t)vbicq_s8((int8x16_t)vpaddlq_u16(vpaddlq_u8((uint8x16_t)vcntq_s8((int8x16_t)v18))), (int8x16_t)vceqzq_s32(v18));
              v20.i32[0] = BMPReadPlugin::countBitsAndCalculateShift(unsigned int,int *,int *)::Mod37BitPosition[(DWORD2(v75[0]) & -DWORD2(v75[0])) % 0x25];
              v20.i32[1] = BMPReadPlugin::countBitsAndCalculateShift(unsigned int,int *,int *)::Mod37BitPosition[(HIDWORD(v75[0]) & -HIDWORD(v75[0])) % 0x25];
              v20.i32[2] = BMPReadPlugin::countBitsAndCalculateShift(unsigned int,int *,int *)::Mod37BitPosition[(v75[1] & -LODWORD(v75[1])) % 0x25];
              v20.i32[3] = BMPReadPlugin::countBitsAndCalculateShift(unsigned int,int *,int *)::Mod37BitPosition[(DWORD1(v75[1]) & -DWORD1(v75[1])) % 0x25];
              *((unsigned char *)this + 485) = v19.i8[8];
              *((unsigned char *)this + 484) = v19.i8[4];
              __int8 v21 = v19.i8[12];
              *((unsigned char *)this + 48++*((_DWORD *)this + 3) = v19.i8[0];
              int8x8_t v22 = vbic_s8((int8x8_t)vadd_s16(vmovn_s32(vaddq_s32(v19, v20)), (int16x4_t)0xF800F800F800F8), (int8x8_t)vmovn_s32(vceqzq_s32(v19)));
              goto LABEL_75;
            }
LABEL_58:
            if (IIODictionary::containsKey(*((IIODictionary **)this + 6), @"kCGImageSourceSubsampleFactor"))
            {
              unsigned int Uint32ForKey = IIODictionary::getUint32ForKey(*((IIODictionary **)this + 6), @"kCGImageSourceSubsampleFactor");
              *((_WORD *)this + 158) = 1;
              if (v6 >= v5) {
                unsigned int v24 = v5;
              }
              else {
                unsigned int v24 = v6;
              }
              if (Uint32ForKey > v24) {
                goto LABEL_73;
              }
              double v25 = (__int16 *)((char *)this + 316);
              if (Uint32ForKey >= 2)
              {
                if (Uint32ForKey >= 0x80)
                {
                  __int8 v21 = 0;
                  __int16 v26 = 128;
LABEL_181:
                  *double v25 = v26;
                  goto LABEL_74;
                }
                if (Uint32ForKey >= 0x40)
                {
                  __int8 v21 = 0;
                  __int16 v26 = 64;
                  goto LABEL_181;
                }
                if (Uint32ForKey >= 0x20)
                {
LABEL_171:
                  __int8 v21 = 0;
                  __int16 v26 = 32;
                  goto LABEL_181;
                }
                if (Uint32ForKey < 0x10)
                {
                  if (Uint32ForKey < 8)
                  {
                    if (Uint32ForKey < 4) {
                      goto LABEL_179;
                    }
LABEL_173:
                    __int8 v21 = 0;
                    __int16 v26 = 4;
                    goto LABEL_181;
                  }
LABEL_169:
                  __int8 v21 = 0;
                  __int16 v26 = 8;
                  goto LABEL_181;
                }
LABEL_72:
                __int8 v21 = 0;
                __int16 v26 = 16;
                goto LABEL_181;
              }
            }
            else
            {
              double v25 = (__int16 *)((char *)this + 316);
              *((_WORD *)this + 158) = 1;
            }
            if (*((unsigned __int8 *)this + 216) >= 2u)
            {
              unsigned int v27 = *((_DWORD *)this + 53);
              if (v27)
              {
                if (v27 < v6 >> 5 || v5 >> 5 > v27) {
                  goto LABEL_171;
                }
                if (v27 < v6 >> 4) {
                  goto LABEL_72;
                }
                if (v27 < v6 >> 3) {
                  goto LABEL_169;
                }
                if (v27 < v6 >> 2) {
                  goto LABEL_173;
                }
                if (v27 < v6 >> 1)
                {
LABEL_179:
                  __int8 v21 = 0;
                  __int16 v26 = 2;
                  goto LABEL_181;
                }
              }
              __int8 v21 = 0;
              __int16 v26 = 1;
              goto LABEL_181;
            }
LABEL_73:
            __int8 v21 = 0;
LABEL_74:
            int8x8_t v22 = 0;
LABEL_75:
            int8x8_t v68 = v22;
            int v28 = *((_DWORD *)this + 114);
            switch(v28)
            {
              case 0:
              case 3:
                unsigned int v29 = *((_DWORD *)this + 57);
                unint64_t v30 = v29 * (unint64_t)*((unsigned __int16 *)this + 121);
                if ((v30 & 0xFFFFFFFF00000000) != 0) {
                  goto LABEL_164;
                }
                unsigned int v31 = ((v30 + 31) >> 3) & 0x1FFFFFFC;
                unsigned int v32 = *((_DWORD *)this + 58);
                unint64_t v33 = v32 * (unint64_t)v31;
                if ((v33 & 0xFFFFFFFF00000000) != 0) {
                  goto LABEL_164;
                }
                if (!v31)
                {
                  _cg_jpeg_mem_term("initialize", 485, "*** ERROR: %dx%d - bpp=%d compression=%d --> rb=%d\n", v29, v32, *((unsigned __int16 *)this + 121), *((_DWORD *)this + 114), 0);
                  goto LABEL_164;
                }
                unint64_t v34 = v33;
LABEL_91:
                if (!v34) {
                  goto LABEL_164;
                }
                *((void *)this + 20) = 0;
                *((_DWORD *)this + 81) = 1380401696;
                *((unsigned char *)this + 34jp2_colour_converter::clear(this + 6) = 0;
                unsigned int v39 = *((unsigned __int16 *)this + 121);
                if (v39 > 8)
                {
                  switch(v39)
                  {
                    case 0x20u:
                      CGAffineTransform v47 = 0;
                      *((_WORD *)this + 120) = 8;
                      *((_DWORD *)this + 68) = 2097160;
                      if (v21) {
                        BOOL v57 = 0;
                      }
                      else {
                        BOOL v57 = v28 == 3;
                      }
                      if (v57 || v15 == 40) {
                        char v59 = 5;
                      }
                      else {
                        char v59 = 3;
                      }
                      *((_WORD *)this + 138) = 4;
                      *((unsigned char *)this + 24jp2_colour_converter::clear(this + 6) = v59;
                      *((unsigned char *)this + 278) = v59;
                      *((unsigned char *)this + 279) = 4;
                      *((_DWORD *)this + 67) = 4 * *((_DWORD *)this + 57);
                      unsigned int v39 = 32;
                      break;
                    case 0x18u:
                      CGAffineTransform v47 = 0;
                      *((_WORD *)this + 120) = 8;
                      *((void *)this + 34) = 0x405000400200008;
                      break;
                    case 0x10u:
                      CGAffineTransform v47 = 0;
                      *((_WORD *)this + 120) = 8;
                      *((_DWORD *)this + 68) = 2097160;
                      *((_WORD *)this + 138) = 4;
                      *((unsigned char *)this + 278) = 5;
                      unsigned int v39 = 16;
                      if (v28 == 3 && DWORD1(v75[1]))
                      {
                        CGAffineTransform v47 = 0;
                        *((unsigned char *)this + 24jp2_colour_converter::clear(this + 6) = 3;
                      }
                      break;
                    default:
                      CGAffineTransform v47 = 0;
                      break;
                  }
                  goto LABEL_147;
                }
                *((_DWORD *)this + 68) = 524296;
                *((_WORD *)this + 138) = 1;
                *((_DWORD *)this + 67) = *((_DWORD *)this + 59);
                unsigned int v40 = 1 << v39;
                if (v15 < 0x11) {
                  size_t v41 = 3;
                }
                else {
                  size_t v41 = 4;
                }
                unsigned int v42 = v41 << v39;
                BOOL v43 = LODWORD(v75[0]) != 0;
                BOOL v44 = LODWORD(v75[0]) < v40;
                if (v43 && v44) {
                  unint64_t v45 = (LODWORD(v75[0]) * v41);
                }
                else {
                  unint64_t v45 = v42;
                }
                if (v43 && v44) {
                  size_t v46 = LODWORD(v75[0]);
                }
                else {
                  size_t v46 = v40;
                }
                CGAffineTransform v47 = (unsigned __int8 *)malloc_type_calloc(v46, v41, 0x3F875340uLL);
                if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v47, *((unsigned int *)this + 113), v45) > v45)
                {
                  if (v47) {
                    free(v47);
                  }
                  goto LABEL_164;
                }
                int v48 = 0;
                uint64_t v49 = 0;
                size_t v50 = (v46 - 1);
                if (v46 <= 1) {
                  uint64_t v51 = 1;
                }
                else {
                  uint64_t v51 = v46;
                }
                uint64_t v52 = v51 + 2 * v51;
                do
                {
                  unsigned __int8 v53 = v47[v48 + 1];
                  unsigned __int8 v54 = v47[v48];
                  v47[v49] = v47[v48 + 2];
                  v47[(v49 + 1)] = v53;
                  v47[(v49 + 2)] = v54;
                  v49 += 3;
                  v48 += v41;
                }
                while (v52 != v49);
                unsigned int v55 = v15 + v45 + 14;
                unsigned int v56 = *((_DWORD *)this + 112);
                if (v56 < v55 && v56 + 4 < v55) {
                  *((_DWORD *)this + 112) = v55;
                }
                if (v46 != 2 || v13 != 1) {
                  goto LABEL_144;
                }
                if (*v47 == 255)
                {
                  if (v47[1] == 255 && v47[2] == 255 && !v47[3] && !v47[4] && !v47[5])
                  {
LABEL_182:
                    *((void *)this + 40) = 0x4752415900000000;
                    if (*v47 == 255 && v47[1] == 255 && v47[2] == 255 && !v47[3] && !v47[4] && !v47[5]) {
                      *((unsigned char *)this + 34jp2_colour_converter::clear(this + 6) = 1;
                    }
LABEL_146:
                    unsigned int v39 = *((unsigned __int16 *)this + 121);
                    *((_WORD *)this + 120) = v39;
                    *((unsigned char *)this + 24jp2_colour_converter::clear(this + 6) = 0;
LABEL_147:
                    *((unsigned char *)this + 344) = 0;
                    if (!*((_DWORD *)this + 59)) {
                      *((_DWORD *)this + 59) = ((*((_DWORD *)this + 57) * v39 + 31) >> 3) & 0x1FFFFFFC;
                    }
                    *((void *)this + 55) = v34;
                    int v61 = DWORD2(v73);
                    *((unsigned char *)this + 460) = SDWORD2(v73) > 0;
                    signed int v62 = *((unsigned __int16 *)this + 158);
                    if (v62 >= 2)
                    {
                      int v63 = SDWORD1(v73) / v62;
                      *((_DWORD *)this + 65) = SDWORD1(v73) / v62;
                      int v64 = v61 / v62;
                      if (v64 < 0) {
                        int v64 = -v64;
                      }
                      *((_DWORD *)this + 6jp2_colour_converter::clear(this + 6) = v64;
                      *((_DWORD *)this + 67) = 4 * v63;
                    }
                    *((void *)this + 45) = 1;
                    if (*((_DWORD *)this + 114) == 3)
                    {
                      *((_OWORD *)this + 29) = *(_OWORD *)((char *)v75 + 8);
                      *((unsigned char *)this + 480) = v68.i8[0];
                      *((unsigned char *)this + 481) = v68.i8[2];
                      *((unsigned char *)this + 482) = v68.i8[4];
                      *((unsigned char *)this + 48jp2_colour_converter::clear(this + 6) = v68.i8[6];
                      *((unsigned char *)this + 487) = v21;
                    }
                    unsigned int v65 = v39 / *((unsigned __int16 *)this + 120);
                    *((_WORD *)this + 122) = v65;
                    if (v65 == 1) {
                      *((_DWORD *)this + 67) = (*((_DWORD *)this + 57) + 3) & 0xFFFFFFFC;
                    }
                    if (*((_WORD *)this + 137) == 32) {
                      *((unsigned char *)this + 350) = 1;
                    }
                    *((_WORD *)this + 188) = 1;
                    if (v47) {
                      free(v47);
                    }
                    uint64_t v66 = 0;
                    goto LABEL_165;
                  }
                }
                else if (!*v47 && !v47[1] && !v47[2] && v47[3] == 255 && v47[4] == 255 && v47[5] == 255)
                {
                  goto LABEL_182;
                }
LABEL_144:
                CGRect v60 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
                *((void *)this + 20) = CGColorSpaceCreateIndexed(v60, v50, v47);
                *((void *)this + 40) = 0x5247422000000005;
                CGColorSpaceRelease(v60);
                if (*((_WORD *)this + 121) == 8)
                {
                  *((_DWORD *)this + 67) = 4 * *((_DWORD *)this + 57);
                  *(_DWORD *)((char *)this + 274) = 262176;
                }
                goto LABEL_146;
              case 1:
                unint64_t v34 = DWORD1(v74);
                unint64_t v35 = *((void *)this + 23);
                if (!DWORD1(v74) || v35 <= DWORD1(v74)) {
                  unint64_t v34 = v35 - *((unsigned int *)this + 112);
                }
                unint64_t v36 = v6 * (unint64_t)v5;
                if ((v36 & 0xFFFFFFFF00000000) != 0) {
                  goto LABEL_164;
                }
                if (35 * v35 > v36) {
                  goto LABEL_91;
                }
                _cg_jpeg_mem_term("initialize", 505, "malformed 8bitRLE-BMP?  %ld < (35 * %ld) = %ld   [%g]\n", v6 * (unint64_t)v5, v35, 35 * v35, (double)v36 / (double)v35);
                goto LABEL_164;
              case 2:
                unint64_t v34 = DWORD1(v74);
                unint64_t v37 = *((void *)this + 23);
                if (!DWORD1(v74) || v37 <= DWORD1(v74)) {
                  unint64_t v34 = v37 - *((unsigned int *)this + 112);
                }
                unint64_t v38 = v6 * (unint64_t)v5;
                if ((v38 & 0xFFFFFFFF00000000) != 0) {
                  goto LABEL_164;
                }
                if (130 * v37 > v38) {
                  goto LABEL_91;
                }
                _cg_jpeg_mem_term("initialize", 496, "malformed 4bitRLE-BMP?\n");
                goto LABEL_164;
              default:
                goto LABEL_164;
            }
        }
      }
    }
  }
LABEL_164:
  kdebug_trace();
  uint64_t v66 = 4294967246;
LABEL_165:
  IIOScanner::~IIOScanner((IIOScanner *)v71);
  return v66;
}

void sub_1886FE880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

uint64_t BMPReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  if (v2 == 12) {
    return IIOReadPlugin::setupImageProviderCallbackV2(a1, a2);
  }
  if (v2 == 1) {
    return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

uint64_t BMPReadPlugin::decodeRLE(BMPReadPlugin *this, unsigned __int8 *a2)
{
  if (*((void *)this + 55) <= 0x400uLL) {
    size_t v4 = 1024;
  }
  else {
    size_t v4 = *((void *)this + 55);
  }
  unsigned int v5 = (char *)malloc_type_calloc(v4, 1uLL, 0x5969A9C3uLL);
  if (v5)
  {
    unsigned int v6 = v5;
    int64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v5, *((unsigned int *)this + 112), *((void *)this + 55));
    if (BytesAtOffset == *((void *)this + 55))
    {
      if (*((unsigned char *)this + 460)) {
        uint64_t v8 = *((unsigned int *)this + 66) - 1;
      }
      else {
        uint64_t v8 = 0;
      }
      unint64_t v9 = 0;
      float v10 = &v6[BytesAtOffset];
      uint64_t v11 = v8 * *((unsigned int *)this + 75);
      char v12 = BytesAtOffset + (_BYTE)v6;
      uint64_t v13 = (uint64_t)v6;
LABEL_10:
      unint64_t v14 = 0;
      unsigned int v15 = &a2[v11];
      while (1)
      {
        while (1)
        {
          uint64_t v16 = 0;
          uint64_t v17 = 0;
          uint64_t v18 = v13;
          int64_t v19 = BytesAtOffset;
          unint64_t v20 = *((unsigned int *)this + 66);
          unint64_t v21 = v9;
          do
          {
            unint64_t v9 = v21;
            BOOL v22 = v20 >= v21;
            unint64_t v23 = v20 - v21;
            if (v23 == 0 || !v22) {
              goto LABEL_66;
            }
            uint64_t v24 = v16;
            if (v19 + v16 < 2) {
              goto LABEL_66;
            }
            unsigned int v25 = *(unsigned __int8 *)(v18 + v17);
            uint64_t v26 = *(unsigned __int8 *)(v18 + v17 + 1);
            if (*(unsigned char *)(v18 + v17)) {
              BOOL v27 = 0;
            }
            else {
              BOOL v27 = v26 == 0;
            }
            if (v27)
            {
              if (*((unsigned char *)this + 460)) {
                unint64_t v41 = v23 - 2;
              }
              else {
                unint64_t v41 = v9 + 1;
              }
              ++v9;
              uint64_t v11 = v41 * *((unsigned int *)this + 75);
              int64_t BytesAtOffset = v19 - v17 - 2;
              uint64_t v13 = v18 + v17 + 2;
              goto LABEL_10;
            }
            v17 += 2;
            v16 -= 2;
            if (v25) {
              BOOL v28 = 0;
            }
            else {
              BOOL v28 = v26 == 1;
            }
            unint64_t v21 = *((unsigned int *)this + 66);
          }
          while (v28);
          if (!v25 && v26 == 2)
          {
            uint64_t v29 = v19 - v17;
            if ((unint64_t)(v19 - v17 + 2) >= 4)
            {
              unint64_t v30 = (unsigned __int8 *)(v18 + v17);
              v14 += *v30;
              uint64_t v13 = (uint64_t)(v30 + 2);
              v9 += v30[1];
              int64_t BytesAtOffset = v29 - 2;
              continue;
            }
          }
          int64_t BytesAtOffset = v19 + v16;
          uint64_t v13 = v18 + v17;
          int v31 = *((_DWORD *)this + 114);
          if (v31 == 1) {
            break;
          }
          if (v31 != 2) {
            continue;
          }
          if (!v25)
          {
            if (v26)
            {
              unint64_t v35 = 0;
              while (v14 + v35 < *((unsigned int *)this + 65))
              {
                if (BytesAtOffset <= v35 >> 1) {
                  goto LABEL_66;
                }
                char v36 = *(unsigned char *)(v18 + (v35 >> 1) + v17);
                if ((v35 & 1) == 0) {
                  char v36 = *(unsigned char *)(v18 + (v35 >> 1) + v17) >> 4;
                }
                v15[v14 + v35++] = v36 & 0xF;
                if (v26 == v35)
                {
                  v14 += v35;
                  goto LABEL_60;
                }
              }
              v14 += v35;
            }
LABEL_60:
            unint64_t v40 = (((unint64_t)(v26 + 1) >> 1) & 1) + ((unint64_t)(v26 + 1) >> 1);
            uint64_t v13 = v18 + v17 + v40;
            goto LABEL_61;
          }
          for (unsigned int i = 0; i < v25; ++i)
          {
            if (v14 >= *((unsigned int *)this + 65)) {
              break;
            }
            char v33 = (i & 1) != 0 ? v26 : v26 >> 4;
            v15[v14++] = v33 & 0xF;
          }
        }
        if (!v25)
        {
          if (v18 + v26 + v17 > (unint64_t)v10) {
            LOBYTE(v2jp2_colour_converter::clear(this + 6) = v12 - v18 - v17;
          }
          if ((_BYTE)v26)
          {
            LOWORD(v2jp2_colour_converter::clear(this + 6) = v26;
            unint64_t v37 = (unsigned __int8 *)(v18 - v24 + 2);
            uint64_t v38 = v26;
            do
            {
              if (v14 >= *((unsigned int *)this + 65)) {
                break;
              }
              unsigned __int8 v39 = *v37++;
              v15[v14++] = v39;
              --v38;
            }
            while (v38);
          }
          else
          {
            LOWORD(v2jp2_colour_converter::clear(this + 6) = 0;
          }
          unint64_t v40 = ((_WORD)v26 + 1) & 0x1FE;
          uint64_t v13 = v18 + v40 + v17;
LABEL_61:
          int64_t BytesAtOffset = v19 - v40 - v17;
          continue;
        }
        for (unsigned int j = 0; j < v25; ++j)
        {
          if (v14 >= *((unsigned int *)this + 65)) {
            break;
          }
          v15[v14++] = v26;
        }
      }
    }
LABEL_66:
    free(v6);
  }
  return 1;
}

uint64_t BMPReadPlugin::decodeBitField(BMPReadPlugin *this, unsigned __int8 *a2, size_t a3)
{
  BOOL v6 = *((unsigned char *)this + 405) != 0;
  BOOL v7 = *((unsigned char *)this + 405) == 0;
  if (*((void *)this + 55) <= 0x400uLL) {
    size_t v8 = 1024;
  }
  else {
    size_t v8 = *((void *)this + 55);
  }
  unint64_t v9 = (char *)malloc_type_calloc(v8, 1uLL, 0xF5DA81FEuLL);
  if (v9)
  {
    float v10 = v9;
    if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, *((unsigned int *)this + 112), *((void *)this + 55)) == *((void *)this + 55))
    {
      int v11 = *((unsigned __int16 *)this + 121);
      if (v11 == 32)
      {
        int v36 = *((unsigned __int8 *)this + 460);
        int v37 = *((_DWORD *)this + 66);
        uint64_t v38 = a2;
        if (*((unsigned char *)this + 460)) {
          uint64_t v38 = &a2[(v37 - 1) * *((_DWORD *)this + 75)];
        }
        if (v37)
        {
          vImagePixelCount v39 = 0;
          LODWORD(v40) = *((_DWORD *)this + 65);
          unint64_t v41 = v10;
          do
          {
            if (v40)
            {
              unint64_t v42 = 0;
              BOOL v43 = v38;
              do
              {
                int v44 = *(_DWORD *)&v41[4 * v42];
                unsigned int v45 = *((_DWORD *)this + 116) & v44;
                unsigned int v46 = v45 << -*((unsigned char *)this + 480);
                unsigned int v47 = v45 >> *((unsigned char *)this + 480);
                if (*((char *)this + 480) >= 0) {
                  unsigned __int8 v48 = v47;
                }
                else {
                  unsigned __int8 v48 = v46;
                }
                v43[2 * v7] = v48;
                unsigned int v49 = *((_DWORD *)this + 117) & v44;
                unsigned int v50 = v49 << -*((unsigned char *)this + 481);
                unsigned int v51 = v49 >> *((unsigned char *)this + 481);
                if (*((char *)this + 481) >= 0) {
                  unsigned __int8 v52 = v51;
                }
                else {
                  unsigned __int8 v52 = v50;
                }
                v43[1] = v52;
                unsigned int v53 = *((_DWORD *)this + 118) & v44;
                unsigned int v54 = v53 << -*((unsigned char *)this + 482);
                unsigned int v55 = v53 >> *((unsigned char *)this + 482);
                if (*((char *)this + 482) >= 0) {
                  unsigned __int8 v56 = v55;
                }
                else {
                  unsigned __int8 v56 = v54;
                }
                v43[2 * v6] = v56;
                if (*((unsigned char *)this + 487))
                {
                  if (*((unsigned char *)this + 487) == 1)
                  {
                    if ((*((_DWORD *)this + 119) & v44) != 0) {
                      LOBYTE(v57) = -1;
                    }
                    else {
                      LOBYTE(v57) = 0;
                    }
                  }
                  else
                  {
                    int v58 = *((char *)this + 486);
                    unsigned int v59 = *((_DWORD *)this + 119) & v44;
                    if (v58 < 0) {
                      unsigned int v57 = v59 << -(char)v58;
                    }
                    else {
                      unsigned int v57 = v59 >> v58;
                    }
                  }
                }
                else
                {
                  LOBYTE(v57) = -1;
                }
                v43[3] = v57;
                ++v42;
                v43 += 4;
                unint64_t v40 = *((unsigned int *)this + 65);
              }
              while (v42 < v40);
              int v36 = *((unsigned __int8 *)this + 460);
            }
            v41 += *((unsigned int *)this + 59);
            uint64_t v60 = *((unsigned int *)this + 75);
            if (v36) {
              uint64_t v60 = -v60;
            }
            v38 += v60;
            ++v39;
            vImagePixelCount v61 = *((unsigned int *)this + 66);
          }
          while (v39 < v61);
        }
        else
        {
          vImagePixelCount v61 = 0;
        }
        if (*((unsigned char *)this + 406) == 1)
        {
          dest.data = a2;
          dest.CGFloat height = v61;
          size_t v62 = *((unsigned int *)this + 75);
          dest.CGFloat width = *((unsigned int *)this + 65);
          dest.rowBytes = v62;
          vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
        }
      }
      else if (v11 == 16)
      {
        if (*((_DWORD *)this + 116) == 63488
          && *((_DWORD *)this + 117) == 2016
          && *((_DWORD *)this + 118) == 31
          && !*((unsigned char *)this + 487))
        {
          if (*((unsigned char *)this + 460))
          {
            int v64 = malloc_type_malloc(a3, 0x1F5C34AEuLL);
            uint64_t v65 = *(void *)((char *)this + 228);
            v66.i64[0] = v65;
            v66.i64[1] = HIDWORD(v65);
            *(int8x16_t *)&dest.CGFloat height = vextq_s8(v66, v66, 8uLL);
            dest.rowBytes = *((unsigned int *)this + 59);
            vImagePixelCount v67 = *((unsigned int *)this + 74);
            v75.data = v64;
            v75.CGFloat height = v67;
            size_t v68 = *((unsigned int *)this + 75);
            v75.CGFloat width = *((unsigned int *)this + 73);
            v75.rowBytes = v68;
            dest.data = v10;
            if (*((unsigned char *)this + 405)) {
              vImageConvert_RGB565toRGBA8888(0xFFu, &dest, &v75, 0);
            }
            else {
              vImageConvert_RGB565toBGRA8888(0xFFu, &dest, &v75, 0);
            }
            vImage_Buffer dest = v75;
            v75.data = a2;
            vImage_Error v74 = vImageVerticalReflect_ARGB8888(&dest, &v75, 0x10u);
            free(v64);
          }
          else
          {
            uint64_t v69 = *(void *)((char *)this + 228);
            v70.i64[0] = v69;
            v70.i64[1] = HIDWORD(v69);
            *(int8x16_t *)&dest.CGFloat height = vextq_s8(v70, v70, 8uLL);
            dest.rowBytes = *((unsigned int *)this + 59);
            vImagePixelCount v71 = *((unsigned int *)this + 74);
            v75.data = a2;
            v75.CGFloat height = v71;
            size_t v72 = *((unsigned int *)this + 75);
            v75.CGFloat width = *((unsigned int *)this + 73);
            v75.rowBytes = v72;
            dest.data = v10;
            if (*((unsigned char *)this + 405)) {
              vImage_Error v73 = vImageConvert_RGB565toRGBA8888(0xFFu, &dest, &v75, 0);
            }
            else {
              vImage_Error v73 = vImageConvert_RGB565toBGRA8888(0xFFu, &dest, &v75, 0);
            }
            vImage_Error v74 = v73;
          }
          if (v74) {
            _cg_jpeg_mem_term("decodeBitField", 997, "    err = %d\n", v74);
          }
        }
        else
        {
          int v12 = *((unsigned __int8 *)this + 460);
          int v13 = *((_DWORD *)this + 66);
          if (*((unsigned char *)this + 460)) {
            a2 += ((v13 - 1) * *((_DWORD *)this + 75));
          }
          if (v13)
          {
            unint64_t v14 = 0;
            LODWORD(v15) = *((_DWORD *)this + 65);
            uint64_t v16 = v10;
            do
            {
              if (v15)
              {
                unint64_t v17 = 0;
                uint64_t v18 = (unsigned __int8 *)(v16 + 1);
                int64_t v19 = a2;
                do
                {
                  int v20 = *(v18 - 1);
                  int v21 = v20 | (*v18 << 8);
                  unsigned int v22 = v21 & *((_DWORD *)this + 116);
                  unsigned int v23 = v21 & *((_DWORD *)this + 117);
                  int v24 = *((_DWORD *)this + 118);
                  unsigned int v25 = v22 << -*((unsigned char *)this + 480);
                  unsigned int v26 = v22 >> *((unsigned char *)this + 480);
                  if (*((char *)this + 480) < 0) {
                    LOBYTE(v2jp2_colour_converter::clear(this + 6) = v25;
                  }
                  v19[2 * v7] = v26;
                  v19[2 * v7] = v26 | (v26 >> (8 - *((unsigned char *)this + 483)));
                  unsigned int v27 = v24 & v21;
                  unsigned int v28 = v23 << -*((unsigned char *)this + 481);
                  unsigned int v29 = v23 >> *((unsigned char *)this + 481);
                  if (*((char *)this + 481) < 0) {
                    LOBYTE(v29) = v28;
                  }
                  v19[1] = v29;
                  v19[1] = v29 | (v29 >> (8 - *((unsigned char *)this + 484)));
                  unsigned int v30 = v27 << -*((unsigned char *)this + 482);
                  unsigned int v31 = v27 >> *((unsigned char *)this + 482);
                  if (*((char *)this + 482) < 0) {
                    LOBYTE(v31) = v30;
                  }
                  v19[2 * v6] = v31;
                  v19[2 * v6] = v31 | (v31 >> (8 - *((unsigned char *)this + 485)));
                  if (*((unsigned char *)this + 487))
                  {
                    if (*((unsigned char *)this + 487) == 1)
                    {
                      if ((*((_DWORD *)this + 119) & v21) != 0) {
                        LOBYTE(v32) = -1;
                      }
                      else {
                        LOBYTE(v32) = 0;
                      }
                    }
                    else
                    {
                      int v33 = *((char *)this + 486);
                      int v34 = *((_DWORD *)this + 119);
                      if (v33 < 0) {
                        unsigned int v32 = (v34 & v20) << -(char)v33;
                      }
                      else {
                        unsigned int v32 = (v34 & v21) >> v33;
                      }
                    }
                  }
                  else
                  {
                    LOBYTE(v32) = -1;
                  }
                  v18 += 2;
                  v19[3] = v32;
                  ++v17;
                  v19 += 4;
                  unint64_t v15 = *((unsigned int *)this + 65);
                }
                while (v17 < v15);
                int v12 = *((unsigned __int8 *)this + 460);
              }
              v16 += *((unsigned int *)this + 59);
              uint64_t v35 = *((unsigned int *)this + 75);
              if (v12) {
                uint64_t v35 = -v35;
              }
              a2 += v35;
              ++v14;
            }
            while (v14 < *((unsigned int *)this + 66));
          }
        }
      }
    }
    free(v10);
  }
  return 1;
}

uint64_t BMPReadPlugin::decodeUncompressed(BMPReadPlugin *this, unsigned __int8 *a2)
{
  size_t v4 = 0;
  unsigned int v5 = *((unsigned __int16 *)this + 121);
  if (v5 <= 0xF)
  {
    if (v5 - 1 < 2 || v5 == 4)
    {
      int v7 = *((_DWORD *)this + 58);
      if (*((void *)this + 55) <= (unint64_t)(v7 * *((_DWORD *)this + 59))) {
        size_t v8 = (v7 * *((_DWORD *)this + 59));
      }
      else {
        size_t v8 = *((void *)this + 55);
      }
      unint64_t v9 = (char *)malloc_type_calloc(v8, 1uLL, 0x2FA52361uLL);
      if (!v9) {
        return 1;
      }
      size_t v4 = v9;
      if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v9, *((unsigned int *)this + 112), v8) != v8)goto LABEL_109; {
      int v10 = *((_DWORD *)this + 81);
      }
      if (v10 == 1380401696)
      {
        if (*((_DWORD *)this + 100) == 1768842360) {
          operator new();
        }
        operator new();
      }
      if (v10 == 1196573017) {
        operator new();
      }
    }
    else
    {
      if (v5 != 8) {
        goto LABEL_80;
      }
      int v15 = *((_DWORD *)this + 58);
      if (*((void *)this + 55) <= (unint64_t)(v15 * *((_DWORD *)this + 59))) {
        size_t v16 = (v15 * *((_DWORD *)this + 59));
      }
      else {
        size_t v16 = *((void *)this + 55);
      }
      unint64_t v17 = (char *)malloc_type_calloc(v16, 1uLL, 0x660B1A99uLL);
      if (!v17) {
        return 1;
      }
      size_t v4 = v17;
      if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v17, *((unsigned int *)this + 112), v16) != v16)goto LABEL_109; {
      unsigned int v18 = *((_DWORD *)this + 66);
      }
      if (v18)
      {
        unsigned int v19 = 0;
        int v20 = -1;
        do
        {
          unsigned int v21 = v18 + v20;
          if (!*((unsigned char *)this + 460)) {
            unsigned int v21 = v19;
          }
          memcpy(&a2[*((_DWORD *)this + 75) * v21], &v4[*((_DWORD *)this + 59) * v19++], *((unsigned int *)this + 59));
          unsigned int v18 = *((_DWORD *)this + 66);
          --v20;
        }
        while (v19 < v18);
      }
    }
    goto LABEL_79;
  }
  if (v5 == 16)
  {
    BOOL v22 = *((unsigned char *)this + 405) != 0;
    BOOL v23 = *((unsigned char *)this + 405) == 0;
    int v24 = *((_DWORD *)this + 58);
    if (*((void *)this + 55) <= (unint64_t)(v24 * *((_DWORD *)this + 59))) {
      size_t v25 = (v24 * *((_DWORD *)this + 59));
    }
    else {
      size_t v25 = *((void *)this + 55);
    }
    unsigned int v26 = (char *)malloc_type_calloc(v25, 1uLL, 0x35C20FBBuLL);
    if (!v26) {
      return 1;
    }
    size_t v4 = v26;
    if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v26, *((unsigned int *)this + 112), v25) != v25)goto LABEL_109; {
    unsigned int v27 = *((_DWORD *)this + 66);
    }
    if (v27)
    {
      unsigned int v28 = 0;
      unsigned int v29 = *((_DWORD *)this + 65);
      do
      {
        if (v29)
        {
          unsigned int v30 = 0;
          unsigned int v31 = v27 + ~v28;
          if (!*((unsigned char *)this + 460)) {
            unsigned int v31 = v28;
          }
          unsigned int v32 = &a2[*((_DWORD *)this + 75) * v31];
          int v33 = &v4[*((_DWORD *)this + 59) * v28 + 1];
          do
          {
            int v34 = *v33;
            int v35 = *(v33 - 1);
            v32[2 * v23] = (2 * v34) & 0xF8;
            v32[1] = ((v35 | (v34 << 8)) >> 2) & 0xF8;
            v32[2 * v22] = 8 * v35;
            v32[3] = -1;
            ++v30;
            v32 += 4;
            unsigned int v29 = *((_DWORD *)this + 65);
            v33 += 2;
          }
          while (v30 < v29);
          unsigned int v27 = *((_DWORD *)this + 66);
        }
        ++v28;
      }
      while (v28 < v27);
    }
    goto LABEL_79;
  }
  if (v5 != 24 && v5 != 32)
  {
LABEL_80:
    if (v5 == 32)
    {
      int v50 = *((unsigned __int8 *)this + 246);
      if (v50 != 5 && v50 != 3) {
        goto LABEL_97;
      }
    }
    else
    {
      if (v5 != 24
        || *((unsigned char *)this + 246) != 5
        || *((_DWORD *)this + 75) < (4 * *((_DWORD *)this + 65)))
      {
        goto LABEL_108;
      }
      int v50 = 5;
    }
    uint64_t v51 = *((unsigned int *)this + 66);
    if (v51)
    {
      uint64_t v52 = 0;
      unsigned int v53 = a2 + 3;
      char v54 = 1;
      do
      {
        if (*((_DWORD *)this + 65))
        {
          unsigned int v55 = &v53[(*((_DWORD *)this + 75) * v52)];
          int v56 = *((_DWORD *)this + 65);
          while (!*v55)
          {
            v55 += 4;
            if (!--v56) {
              goto LABEL_95;
            }
          }
          char v54 = 0;
        }
LABEL_95:
        ++v52;
      }
      while (v52 != v51);
      if ((v54 & 1) == 0)
      {
LABEL_97:
        if (*((unsigned char *)this + 405) && v50 != 5 && *((unsigned char *)this + 406) == 1)
        {
          vImagePixelCount v57 = *((unsigned int *)this + 66);
          src.data = a2;
          src.CGFloat height = v57;
          size_t v58 = *((unsigned int *)this + 75);
          src.CGFloat width = *((unsigned int *)this + 65);
          src.rowBytes = v58;
          vImagePremultiplyData_RGBA8888(&src, &src, 0x10u);
          if (v4) {
            goto LABEL_109;
          }
          return 1;
        }
        goto LABEL_108;
      }
      unsigned int v59 = 0;
      unsigned int v60 = *((_DWORD *)this + 65);
      do
      {
        if (v60)
        {
          unsigned int v61 = 0;
          size_t v62 = &v53[*((_DWORD *)this + 75) * v59];
          do
          {
            *size_t v62 = -1;
            v62 += 4;
            ++v61;
            unsigned int v60 = *((_DWORD *)this + 65);
          }
          while (v61 < v60);
          LODWORD(v51) = *((_DWORD *)this + 66);
        }
        ++v59;
      }
      while (v59 < v51);
    }
LABEL_108:
    if (v4) {
      goto LABEL_109;
    }
    return 1;
  }
  if (*((unsigned __int16 *)this + 158) <= 1u) {
    unsigned int v11 = 1;
  }
  else {
    unsigned int v11 = *((unsigned __int16 *)this + 158);
  }
  *((_WORD *)this + 158) = v11;
  int v64 = *((_DWORD *)this + 59);
  LODWORD(v12) = v64 * v11;
  int v13 = 1;
  v72[0] = 1;
  if (*((unsigned char *)this + 460))
  {
    int v14 = *((_DWORD *)this + 74) - 1;
    int v13 = -1;
  }
  else
  {
    int v14 = 0;
  }
  unsigned int v36 = *((_DWORD *)this + 112);
  int v37 = *((_DWORD *)this + 75);
  uint64_t v38 = (char *)malloc_type_calloc(v64 * v11, 1uLL, 0xC1C49B0CuLL);
  if (!v38) {
    return 1;
  }
  size_t v4 = v38;
  int v65 = v13;
  long long v71 = 0u;
  memset(&src, 0, sizeof(src));
  IIOSubsampler::IIOSubsampler((IIOSubsampler *)&src, *((_DWORD *)this + 57), *((_DWORD *)this + 59), (*((unsigned __int8 *)this + 247) << 12) | (*((unsigned __int8 *)this + 248) << 16) | ((*((unsigned char *)this + 249) != 0) << 8) | *((unsigned __int8 *)this + 246), *((_WORD *)this + 120), *((_WORD *)this + 121) >> 3, *((_WORD *)this + 158), 2 * (*((_WORD *)this + 121) != 32), *((_DWORD *)this + 73), *((_DWORD *)this + 75));
  v69.data = v4;
  v69.CGFloat height = 1;
  unsigned int v39 = *((_DWORD *)this + 58);
  size_t v40 = *((unsigned int *)this + 59);
  v69.CGFloat width = *((unsigned int *)this + 73);
  v69.rowBytes = v40;
  *(_OWORD *)&v68.data = xmmword_18898C840;
  size_t v41 = *((unsigned int *)this + 75);
  v68.CGFloat width = v69.width;
  v68.rowBytes = v41;
  if (!v39)
  {
LABEL_71:
    int v47 = *((unsigned __int16 *)this + 121);
    if (v47 == 24)
    {
      if (*((unsigned char *)this + 405))
      {
LABEL_77:
        IIOSubsampler::~IIOSubsampler((IIOSubsampler *)&src);
LABEL_79:
        unsigned int v5 = *((unsigned __int16 *)this + 121);
        goto LABEL_80;
      }
    }
    else if (v47 != 32 || !*((unsigned char *)this + 405))
    {
      goto LABEL_77;
    }
    *(_DWORD *)permuteMap = 50331906;
    vImagePixelCount v48 = *((unsigned int *)this + 74);
    dest.data = a2;
    dest.CGFloat height = v48;
    size_t v49 = *((unsigned int *)this + 75);
    dest.CGFloat width = *((unsigned int *)this + 73);
    dest.rowBytes = v49;
    vImagePermuteChannels_ARGB8888(&dest, &dest, permuteMap, 0x10u);
    goto LABEL_77;
  }
  unsigned int v42 = 0;
  int v43 = v14 * v37;
  unsigned int v44 = v14 + v65;
  int v45 = v65 * v37;
  while (1)
  {
    unsigned int v46 = v11 + v42;
    if (v11 + v42 > v39) {
      unsigned int v11 = v39 - v42;
    }
    unint64_t v12 = v46 <= v39 ? v12 : (v39 - v42) * v64;
    if (IIOImageReadSession::getBytesAtOffset(*((IIOImageReadSession **)this + 3), v4, v36, v12) != v12) {
      break;
    }
    if (*((unsigned __int16 *)this + 158) >= 2u)
    {
      v72[0] = 1;
      IIOSubsampler::subsample((IIOSubsampler *)&src, (unsigned __int8 *)v4, v11, &a2[v43], v72);
      goto LABEL_68;
    }
    if (*((_WORD *)this + 121) != 32)
    {
      v68.data = &a2[v43];
      vImageConvert_RGB888toBGRA8888(&v69, 0, 0xFFu, &v68, 0, 0x10u);
LABEL_68:
      if ((v44 & 0x80000000) != 0) {
        goto LABEL_71;
      }
      goto LABEL_69;
    }
    memcpy(&a2[v43], v4, (4 * *((_DWORD *)this + 73)));
    if ((v44 & 0x80000000) != 0) {
      goto LABEL_71;
    }
LABEL_69:
    if (v44 < *((_DWORD *)this + 74))
    {
      v36 += v12;
      v42 += v11;
      unsigned int v39 = *((_DWORD *)this + 58);
      v43 += v45;
      v44 += v65;
      if (v42 < v39) {
        continue;
      }
    }
    goto LABEL_71;
  }
  IIOSubsampler::~IIOSubsampler((IIOSubsampler *)&src);
LABEL_109:
  free(v4);
  return 1;
}

void sub_1886FF940(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C401865CEE3);
  _Unwind_Resume(a1);
}

uint64_t BMPReadPlugin::decodeImageData(BMPReadPlugin *this, unsigned __int8 *a2, size_t a3)
{
  int v3 = *((_DWORD *)this + 114);
  if ((v3 - 1) < 2)
  {
    BMPReadPlugin::decodeRLE(this, a2);
  }
  else if (v3 == 3)
  {
    BMPReadPlugin::decodeBitField(this, a2, a3);
  }
  else if (v3)
  {
    LogError("decodeImageData", 1413, "unknown BMP compression: %d\n", v3);
  }
  else
  {
    BMPReadPlugin::decodeUncompressed(this, a2);
  }
  return 0;
}

uint64_t BMPReadPlugin::decodeImageImp(IIOReadPlugin *this, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  unint64_t v39 = 0;
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v8 = *((_DWORD *)this + 51);
    unsigned int v9 = v8 >> 24;
    uint64_t v10 = MEMORY[0x1E4F14390];
    if (v8 < 0)
    {
      int v11 = __maskrune(v9, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
    }
    if (v11) {
      uint64_t v12 = (v8 >> 24);
    }
    else {
      uint64_t v12 = 46;
    }
    unsigned int v13 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      int v14 = __maskrune(v13, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    }
    if (v14) {
      uint64_t v15 = (v8 << 8 >> 24);
    }
    else {
      uint64_t v15 = 46;
    }
    unsigned int v16 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      int v17 = __maskrune(v16, 0x40000uLL);
      int v8 = *((_DWORD *)this + 51);
    }
    else
    {
      int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = ((__int16)v8 >> 8);
    }
    else {
      uint64_t v18 = 46;
    }
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0) {
        goto LABEL_22;
      }
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_22:
      uint64_t v19 = *((char *)this + 204);
LABEL_25:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v12, v15, v18, v19, iioTypeStr[a3], "virtual OSStatus BMPReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_26;
    }
    uint64_t v19 = 46;
    goto LABEL_25;
  }
LABEL_26:
  IIOReadPlugin::debugDecodeImage(this, a2);
  if (!*((unsigned char *)this + 414)) {
    return 4294967115;
  }
  if (*((unsigned __int16 *)this + 158) >= 2u)
  {
    unsigned int v20 = (*((_DWORD *)this + 73) * (*((unsigned __int16 *)this + 153) >> 3) + 15) & 0xFFFFFFF0;
    *((_DWORD *)this + 67) = v20;
    *((_DWORD *)this + 75) = v20;
  }
  unsigned int v21 = (IIOImageRead **)*((void *)this + 3);
  if (v21) {
    BOOL v22 = IIOImageReadSession::mapData(v21);
  }
  else {
    BOOL v22 = 0;
  }
  if (a3 == 3)
  {
    uint64_t BlockArray = IIOReadPlugin::allocateBlockArray(this, *((unsigned int *)this + 26));
    LODWORD(v29) = *((_DWORD *)this + 73);
    double v28 = (double)v29;
    unsigned int v30 = *((_DWORD *)this + 74);
    double v27 = (double)v30;
    memory_object_size_t v26 = *((unsigned int *)this + 75) * (unint64_t)v30;
    BaseAddress = (void *)_ImageIO_Malloc(v26, *((void *)this + 48), &v39, (uint64_t)kImageMalloc_BMP_Data[0], *((_DWORD *)this + 108), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4) {
      goto LABEL_46;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    size_t Height = IOSurfaceGetHeight(*a4);
    uint64_t BlockArray = 0;
    memory_object_size_t v26 = IOSurfaceGetBytesPerRow(*a4) * Height;
    unint64_t v39 = v26;
    double v27 = 0.0;
    double v28 = 0.0;
  }
  if (!BaseAddress) {
    goto LABEL_47;
  }
  bzero(BaseAddress, v26);
  uint64_t v31 = (*(uint64_t (**)(IIOReadPlugin *, void *, unint64_t))(*(void *)this + 120))(this, BaseAddress, v39);
  if (v31)
  {
    uint64_t BlockArray = v31;
    if (a3 == 3)
    {
      _ImageIO_Free((unint64_t)BaseAddress, v39);
      if (!v22) {
        return BlockArray;
      }
      goto LABEL_48;
    }
LABEL_47:
    if (!v22) {
      return BlockArray;
    }
    goto LABEL_48;
  }
  if (a3 != 3)
  {
    IOSurfaceUnlock(*a4, 0, 0);
LABEL_46:
    uint64_t BlockArray = 0;
    goto LABEL_47;
  }
  uint64_t v34 = 0;
  v40.origin.CGFloat x = 0.0;
  v40.origin.CGFloat y = 0.0;
  v40.size.CGFloat width = v28;
  v40.size.CGFloat height = v27;
  **((void **)this + 12) = IIOReadPlugin::createImageBlock(this, BaseAddress, v39, v40, *((unsigned int *)this + 75), *((unsigned __int8 *)this + 343));
  if (CGRectEqualToRect(*(CGRect *)((char *)this + 120), *MEMORY[0x1E4F1DB20]))
  {
    uint64_t v35 = 0;
  }
  else
  {
    v41.origin.CGFloat x = 0.0;
    v41.origin.CGFloat y = 0.0;
    v41.size.CGFloat width = v28;
    v41.size.CGFloat height = v27;
    *(CGRect *)(&v35 - 1) = CGRectUnion(*(CGRect *)((char *)this + 120), v41);
    uint64_t v34 = v36;
    double v28 = v37;
    double v27 = v38;
  }
  uint64_t BlockArray = 0;
  *((void *)this + 15) = v34;
  *((void *)this + 1jp2_colour_converter::clear(this + 6) = v35;
  *((double *)this + 17) = v28;
  *((double *)this + 18) = v27;
  if (v22)
  {
LABEL_48:
    unsigned int v32 = (const char **)*((void *)this + 3);
    if (v32) {
      IIOImageReadSession::unmapData(v32);
    }
  }
  return BlockArray;
}

uint64_t _cg_TIFFReadDirectory(uint64_t a1)
{
  unsigned int v242 = -1;
  int v2 = (int8x8_t *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 32);
  if (!v3)
  {
    uint64_t result = 0;
    *(void *)(a1 + 24) = 0;
    return result;
  }
  uint64_t result = _TIFFCheckDirNumberAndOffset(a1, *(_DWORD *)(a1 + 880) + 1, *(void *)(a1 + 32));
  if (result)
  {
    __vImage_Buffer src = 0;
    unsigned int v9 = TIFFFetchDirectory(a1, v3, &__src, v2, v5, v6, v7, v8);
    if (!v9)
    {
      char v236 = v3;
      unsigned int v21 = "Failed to read directory at offset %llu";
      goto LABEL_10;
    }
    unsigned int v15 = v9;
    int v16 = 0;
    unsigned int v17 = 0;
    ++*(_DWORD *)(a1 + 880);
    uint64_t v18 = (unsigned __int16 *)__src;
    uint64_t v19 = (unsigned __int16 *)__src;
    while (1)
    {
      unsigned int v20 = *v19;
      if (v17 > v20) {
        break;
      }
      unsigned int v17 = v20 + 1;
      ++v16;
      v19 += 16;
      if (v9 <= (unsigned __int16)v16) {
        goto LABEL_12;
      }
    }
    TIFFWarningExtR(a1, "TIFFReadDirectoryCheckOrder", "Invalid TIFF directory; tags are not sorted in ascending order",
      v10,
      v11,
      v12,
      v13,
      v14,
      v235);
    uint64_t v18 = (unsigned __int16 *)__src;
LABEL_12:
    int v22 = 0;
    for (unsigned int i = v18 + 16; v15 > (unsigned __int16)++v22; i += 16)
    {
      int v24 = *v18;
      size_t v25 = i;
      int v26 = v22;
      double v27 = i;
      do
      {
        int v28 = *v27;
        v27 += 16;
        if (v24 == v28) {
          *((unsigned char *)v25 + 24) = 1;
        }
        ++v26;
        size_t v25 = v27;
      }
      while (v15 > (unsigned __int16)v26);
      v18 += 16;
    }
    *(_DWORD *)(a1 + 16) &= 0xFBEFFFBF;
    (*(void (**)(uint64_t))(a1 + 1072))(a1);
    _cg_TIFFFreeDirectory(a1);
    TIFFDefaultDirectory(a1);
    uint64_t v35 = _TIFFmallocExt((void *)a1, 16 * v15, v29, v30, v31, v32, v33, v34);
    *(void *)(a1 + 45jp2_colour_converter::clear(this + 6) = v35;
    if (!v35)
    {
      uint64_t v52 = "TIFFReadDirectory";
      unsigned int v53 = "Failed to allocate memory for counting IFD data size at reading";
      goto LABEL_79;
    }
    v240 = (unsigned char *)(a1 + 72);
    _cg_TIFFSetField(a1, 284, v36, v37, v38, v39, v40, v41, 1);
    int v49 = 0;
    int v50 = (int8x8_t *)__src;
    uint64_t v51 = (unsigned __int16 *)__src;
    while (*v51 != 277)
    {
      v51 += 16;
      if (v15 <= (unsigned __int16)++v49) {
        goto LABEL_27;
      }
    }
    if (!TIFFFetchNormalTag(a1, v51, 0)) {
      goto LABEL_80;
    }
    *((unsigned char *)v51 + 24) = 1;
    int v50 = (int8x8_t *)__src;
LABEL_27:
    int v54 = 0;
    while (v50->i16[0] != 259)
    {
      v50 += 4;
      if (v15 <= (unsigned __int16)++v54)
      {
        if (!_cg_TIFFSetField(a1, 259, v42, v43, v44, v45, v46, v47, 1)) {
          goto LABEL_80;
        }
        goto LABEL_39;
      }
    }
    LOWORD(v241) = 0;
    int v56 = TIFFReadDirEntryShort(a1, v50, &v241, v48);
    if (v56 == 1) {
      int v56 = TIFFReadDirEntryPersampleShort(a1, (uint64_t)v50, &v241);
    }
    if (v56)
    {
      int v63 = "Compression";
      uint64_t v64 = a1;
      goto LABEL_36;
    }
    if (!_cg_TIFFSetField(a1, 259, v57, v58, v59, v60, v61, v62, (unsigned __int16)v241))
    {
LABEL_80:
      if (__src) {
        _TIFFfreeExt(a1, (char *)__src);
      }
      return 0;
    }
    v50[3].i8[0] = 1;
LABEL_39:
    int v65 = 0;
    int8x16_t v66 = (unsigned __int16 *)__src;
    while (1)
    {
      if (!*((unsigned char *)v66 + 24))
      {
        unsigned int v67 = *v66;
        TIFFReadDirectoryFindFieldInfo(a1, v67, (int *)&v242);
        uint64_t v68 = v242;
        if (v242 == -1)
        {
          TIFFWarningExtR(a1, "TIFFReadDirectory", "Unknown field with tag %hu (0x%hx) encountered", v37, v38, v39, v40, v41, v67);
          vImage_Error v74 = (int *)_TIFFCreateAnonField((void *)a1, *v66, v66[1], v69, v70, v71, v72, v73);
          if (!v74 || !_TIFFMergeFields(a1, v74, 1, v75, v76, v77, v78, v79))
          {
            TIFFWarningExtR(a1, "TIFFReadDirectory", "Registering anonymous field with tag %hu (0x%hx) failed", v75, v76, v77, v78, v79, *v66);
LABEL_57:
            *((unsigned char *)v66 + 24) = 1;
            goto LABEL_58;
          }
          unsigned int v67 = *v66;
          TIFFReadDirectoryFindFieldInfo(a1, v67, (int *)&v242);
          uint64_t v68 = v242;
          if (v242 == -1) {
            _cg_TIFFReadDirectory_cold_1();
          }
        }
        if (!*((unsigned char *)v66 + 24))
        {
          unint64_t v80 = *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 1256) + 8 * v68) + 24);
          if (!v80) {
            goto LABEL_57;
          }
          if (v67 - 256 <= 0x1C)
          {
            if (((1 << v67) & 0x10400003) != 0) {
              goto LABEL_56;
            }
            if (((1 << v67) & 0x820000) != 0)
            {
LABEL_61:
              *(_DWORD *)&v240[(v80 >> 3) & 0x1FFC] |= 1 << v80;
              goto LABEL_58;
            }
          }
          if (v67 - 322 <= 0x10)
          {
            int v81 = 1 << (v67 - 66);
            if ((v81 & 0x10003) != 0) {
              goto LABEL_56;
            }
            if ((v81 & 0xC) != 0) {
              goto LABEL_61;
            }
          }
          if (v67 - 32997 < 2)
          {
LABEL_56:
            if (!TIFFFetchNormalTag(a1, v66, 0)) {
              goto LABEL_80;
            }
            goto LABEL_57;
          }
          if (!_TIFFCheckFieldIsValidForCodec(a1, v67)) {
            goto LABEL_57;
          }
        }
      }
LABEL_58:
      ++v65;
      v66 += 16;
      if (v15 <= (unsigned __int16)v65)
      {
        if (*(_WORD *)(a1 + 120) == 6 && *(_WORD *)(a1 + 170) == 2)
        {
          if (!_TIFFFillStrilesInternal(a1, 1)) {
            goto LABEL_80;
          }
          int v82 = 0;
          int64_t v83 = (char *)__src + 8;
          while (*((_WORD *)v83 - 4) != 273)
          {
            ++v82;
            v83 += 4;
            if (v15 <= (unsigned __int16)v82) {
              goto LABEL_76;
            }
          }
          if (*v83 == 1)
          {
            int v84 = 0;
            unint64_t v85 = (char *)__src + 8;
            while (*((_WORD *)v85 - 4) != 279)
            {
              ++v84;
              v85 += 4;
              if (v15 <= (unsigned __int16)v84) {
                goto LABEL_76;
              }
            }
            if (*v85 == 1)
            {
              *(_WORD *)(a1 + 170) = 1;
              TIFFWarningExtR(a1, "TIFFReadDirectory", "Planarconfig tag value assumed incorrect, assuming data is contig instead of chunky", v37, v38, v39, v40, v41, v236);
            }
          }
        }
LABEL_76:
        if ((*v240 & 2) == 0)
        {
          unsigned int v86 = "ImageLength";
          goto LABEL_78;
        }
        int v87 = 0;
        int v88 = 0;
        unint64_t v89 = (int8x8_t *)__src;
        int8x16_t __dst = (unsigned __int16 *)(a1 + 288);
        unint64_t v90 = (unsigned __int16 *)(a1 + 256);
        while (2)
        {
          if (v89[3].i8[0]) {
            goto LABEL_86;
          }
          unsigned int v91 = v89->u16[0];
          if (v91 > 0x13F)
          {
            if (v89->u16[0] > 0x152u)
            {
              if (v91 - 340 < 2)
              {
                unsigned int v241 = 0;
                if (*(void *)&v89[1] != *(unsigned __int16 *)(a1 + 130))
                {
                  if ((EvaluateIFDdatasizeReading(a1, v89) & 1) == 0) {
                    goto LABEL_80;
                  }
                  int v100 = 1;
LABEL_242:
                  LODWORD(v107) = v89->u16[0];
LABEL_243:
                  v219 = TIFFFieldWithTag((void *)a1, v107);
                  if (v219) {
                    int v63 = (const char *)*((void *)v219 + 4);
                  }
                  else {
                    int v63 = "unknown tagname";
                  }
                  uint64_t v64 = a1;
                  int v56 = v100;
LABEL_36:
                  TIFFReadDirEntryOutputErr(v64, v56, "TIFFReadDirectory", (uint64_t)v63, 0, v60, v61, v62);
                  goto LABEL_80;
                }
                int v237 = v87;
                uint64_t v124 = v90;
                int v100 = TIFFReadDirEntryDoubleArray(a1, (uint64_t)v89, (__int32 **)&v241);
                if ((EvaluateIFDdatasizeReading(a1, v89) & 1) == 0) {
                  goto LABEL_80;
                }
                if (v100) {
                  goto LABEL_242;
                }
                int v131 = *(_DWORD *)(a1 + 16);
                *(_DWORD *)(a1 + 1jp2_colour_converter::clear(this + 6) = v131 | 0x400000;
                uint64_t v132 = v241;
                int v133 = _cg_TIFFSetField(a1, v89->u16[0], v125, v126, v127, v128, v129, v130, (uint64_t)v241);
                *(_DWORD *)(a1 + 1jp2_colour_converter::clear(this + 6) = v131;
                _TIFFfreeExt(a1, v132);
                if (!v133) {
                  goto LABEL_80;
                }
                unint64_t v90 = v124;
                int v87 = v237;
                goto LABEL_86;
              }
              if (v91 == 32996 || v91 == 339) {
                goto LABEL_109;
              }
              goto LABEL_141;
            }
            if (v91 == 320) {
              goto LABEL_102;
            }
            if (v91 == 324) {
              goto LABEL_116;
            }
            if (v91 != 325) {
              goto LABEL_141;
            }
          }
          else
          {
            if (v89->u16[0] <= 0x116u)
            {
              if (v91 != 255)
              {
                if (v91 != 258)
                {
                  if (v91 != 273) {
                    goto LABEL_141;
                  }
LABEL_116:
                  unsigned int v108 = v89->u16[1];
                  if ((v108 > 0x10 || ((1 << v108) & 0x10018) == 0)
                    && (*(_DWORD *)(a1 + 12) != 2 || v89->i16[1] || *(void *)&v89[1] || *(void *)&v89[2]))
                  {
                    long long v109 = TIFFFieldWithTag((void *)a1, v91);
                    if (v109) {
                      uint64_t v115 = *((void *)v109 + 4);
                    }
                    else {
                      LOBYTE(v115) = "unknown tagname";
                    }
                    TIFFWarningExtR(a1, "TIFFReadDirectory", "Invalid data type for tag %s", v110, v111, v112, v113, v114, v115);
                  }
                  uint64_t v161 = v90;
LABEL_164:
                  _TIFFmemcpy(v161, v89, 0x20uLL);
                  if ((EvaluateIFDdatasizeReading(a1, v89) & 1) == 0) {
                    goto LABEL_80;
                  }
                  goto LABEL_86;
                }
LABEL_109:
                LOWORD(v241) = 0;
                int v100 = TIFFReadDirEntryShort(a1, v89, &v241, v55);
                if (!EvaluateIFDdatasizeReading(a1, v89)) {
                  goto LABEL_80;
                }
                if (v100 == 1) {
                  int v100 = TIFFReadDirEntryPersampleShort(a1, (uint64_t)v89, &v241);
                }
                uint64_t v107 = v89->u16[0];
                if (v100) {
                  goto LABEL_243;
                }
                if (!_cg_TIFFSetField(a1, v107, v101, v102, v103, v104, v105, v106, (unsigned __int16)v241))goto LABEL_80; {
                if (v89->i16[0] == 258)
                }
                  int v87 = 1;
                goto LABEL_86;
              }
              LOWORD(v241) = 0;
              if (TIFFReadDirEntryShort(a1, v89, &v241, v55)) {
                goto LABEL_86;
              }
              if ((unsigned __int16)v241 == 2)
              {
                uint64_t v140 = 1;
              }
              else
              {
                if ((unsigned __int16)v241 != 3) {
                  goto LABEL_86;
                }
                uint64_t v140 = 2;
              }
              _cg_TIFFSetField(a1, 254, v134, v135, v136, v137, v138, v139, v140);
LABEL_86:
              ++v88;
              v89 += 4;
              if (v15 <= (unsigned __int16)v88)
              {
                CalcFinalIFDdatasizeReading(a1, v15);
                if (*(_WORD *)(a1 + 120) == 6)
                {
                  if (*(unsigned char *)(a1 + 73))
                  {
                    if (*(_WORD *)(a1 + 122) == 2)
                    {
                      *(_WORD *)(a1 + 122) = 6;
                      TIFFWarningExtR(a1, "TIFFReadDirectory", "Photometric tag value assumed incorrect, assuming data is YCbCr instead of RGB", v167, v168, v169, v170, v171, v236);
                    }
                  }
                  else
                  {
                    TIFFWarningExtR(a1, "TIFFReadDirectory", "Photometric tag is missing, assuming data is YCbCr", v167, v168, v169, v170, v171, v236);
                    if (!_cg_TIFFSetField(a1, 262, v172, v173, v174, v175, v176, v177, 6)) {
                      goto LABEL_80;
                    }
                  }
                  int v178 = *(_DWORD *)v240;
                  if ((*(_DWORD *)v240 & 0x40) == 0)
                  {
                    TIFFWarningExtR(a1, "TIFFReadDirectory", "BitsPerSample tag is missing, assuming 8 bits per sample", v167, v168, v169, v170, v171, v236);
                    if (!_cg_TIFFSetField(a1, 258, v179, v180, v181, v182, v183, v184, 8)) {
                      goto LABEL_80;
                    }
                    int v178 = *(_DWORD *)v240;
                  }
                  if ((v178 & 0x10000) == 0)
                  {
                    unsigned int v185 = *(unsigned __int16 *)(a1 + 122);
                    if (v185 == 2)
                    {
                      TIFFWarningExtR(a1, "TIFFReadDirectory", "SamplesPerPixel tag is missing, assuming correct SamplesPerPixel value is 3", v167, v168, v169, v170, v171, v236);
                      if (!_cg_TIFFSetField(a1, 277, v186, v187, v188, v189, v190, v191, 3)) {
                        goto LABEL_80;
                      }
                      unsigned int v185 = *(unsigned __int16 *)(a1 + 122);
                    }
                    if (v185 >= 2)
                    {
                      if (v185 == 6)
                      {
                        TIFFWarningExtR(a1, "TIFFReadDirectory", "SamplesPerPixel tag is missing, applying correct SamplesPerPixel value of 3", v167, v168, v169, v170, v171, v236);
                        uint64_t v192 = 3;
                        goto LABEL_186;
                      }
                    }
                    else
                    {
                      uint64_t v192 = 1;
LABEL_186:
                      if (!_cg_TIFFSetField(a1, 277, v166, v167, v168, v169, v170, v171, v192)) {
                        goto LABEL_80;
                      }
                    }
                  }
                }
                if ((*v240 & 4) != 0)
                {
                  uint64_t v194 = _cg_TIFFNumberOfTiles(a1, v165, v166, v167, v168, v169, v170, v171);
                  unsigned int v196 = *(_DWORD *)(a1 + 16) | 0x400;
                }
                else
                {
                  uint64_t v194 = _cg_TIFFNumberOfStrips(a1, v165, v166, v167, v168, v169, v170, v171);
                  int v195 = *(_DWORD *)(a1 + 132);
                  *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 88);
                  *(_DWORD *)(a1 + 104) = v195;
                  *(_DWORD *)(a1 + 108) = *(_DWORD *)(a1 + 96);
                  unsigned int v196 = *(_DWORD *)(a1 + 16) & 0xFFFFFBFF;
                }
                *(_DWORD *)(a1 + 228) = v194;
                *(_DWORD *)(a1 + 1jp2_colour_converter::clear(this + 6) = v196;
                if (!v194)
                {
                  if ((v196 & 0x400) != 0) {
                    long long v217 = "tiles";
                  }
                  else {
                    long long v217 = "strips";
                  }
                  TIFFErrorExtR(a1, "TIFFReadDirectory", "Cannot handle zero number of %s", v37, v38, v39, v40, v41, (char)v217);
                  goto LABEL_80;
                }
                *(_DWORD *)(a1 + 224) = v194;
                if (*(_WORD *)(a1 + 170) == 2) {
                  *(_DWORD *)(a1 + 224) = v194 / *(unsigned __int16 *)(a1 + 130);
                }
                if ((*(_DWORD *)v240 & 0x2000000) == 0)
                {
                  if (v194 == 1 && *(_WORD *)(a1 + 120) == 6 && (v196 & 0x400) == 0)
                  {
                    *(_DWORD *)v240 |= 0x2000000u;
                    goto LABEL_198;
                  }
                  if ((v196 & 0x400) != 0) {
                    unsigned int v86 = "TileOffsets";
                  }
                  else {
                    unsigned int v86 = "StripOffsets";
                  }
LABEL_78:
                  uint64_t v52 = "MissingRequired";
                  char v235 = (char)v86;
                  unsigned int v53 = "TIFF directory is missing required \"%s\" field";
LABEL_79:
                  TIFFErrorExtR(a1, v52, v53, v37, v38, v39, v40, v41, v235);
                  goto LABEL_80;
                }
LABEL_198:
                if (*(_DWORD *)(a1 + 12) != 2
                  || !*v90
                  || *(void *)(a1 + 264)
                  || *(_WORD *)(a1 + 258)
                  || *(void *)(a1 + 272)
                  || !*__dst
                  || *(void *)(a1 + 296)
                  || *(_WORD *)(a1 + 290)
                  || *(void *)(a1 + 304))
                {
                  if ((v196 & 0x1000000) == 0
                    && (*v90 && !TIFFFetchStripThing(a1, v90, v194, (void *)(a1 + 232))
                     || *__dst
                     && !TIFFFetchStripThing(a1, __dst, *(_DWORD *)(a1 + 228), (void *)(a1 + 240))))
                  {
                    goto LABEL_80;
                  }
                }
                else
                {
                  TIFFSetupStrips(a1, v193, v194, v37, v38, v39, v40, v41);
                }
                unsigned int v197 = *(unsigned __int16 *)(a1 + 122);
                int v198 = _TIFFGetMaxColorChannels(v197);
                if (v198)
                {
                  __int16 v199 = v198;
                  if (*(unsigned __int16 *)(a1 + 130) - *(unsigned __int16 *)(a1 + 212) > v198)
                  {
                    TIFFWarningExtR(a1, "TIFFReadDirectory", "Sum of Photometric type-related color channels and ExtraSamples doesn't match SamplesPerPixel. Defining non-color channels as ExtraSamples.", v37, v38, v39, v40, v41, v236);
                    uint64_t v200 = *(unsigned __int16 *)(a1 + 212);
                    unsigned __int16 v201 = *(_WORD *)(a1 + 130) - v199;
                    *(_WORD *)(a1 + 212) = v201;
                    float v207 = _TIFFcallocExt((void *)a1, v201, 2, v202, v203, v204, v205, v206);
                    if (!v207)
                    {
                      TIFFErrorExtR(a1, "TIFFReadDirectory", "Failed to allocate memory for temporary new sampleinfo array (%hu 16 bit elements)", v208, v209, v210, v211, v212, *(_WORD *)(a1 + 212));
                      goto LABEL_80;
                    }
                    uint64_t v213 = v207;
                    if (v200) {
                      memcpy(v207, *(const void **)(a1 + 216), 2 * v200);
                    }
                    _TIFFsetShortArrayExt((void *)a1, (char **)(a1 + 216), v213, *(unsigned __int16 *)(a1 + 212), v209, v210, v211, v212);
                    _TIFFfreeExt(a1, (char *)v213);
                    unsigned int v197 = *(unsigned __int16 *)(a1 + 122);
                  }
                }
                if (v197 == 3 && (*(unsigned char *)(a1 + 75) & 4) == 0)
                {
                  if (*(unsigned __int16 *)(a1 + 116) < 8u)
                  {
                    unsigned int v86 = "Colormap";
                    goto LABEL_78;
                  }
                  if (*(_WORD *)(a1 + 130) == 3) {
                    __int16 v214 = 2;
                  }
                  else {
                    __int16 v214 = 1;
                  }
                  *(_WORD *)(a1 + 122) = v214;
                }
                if (*(_WORD *)(a1 + 120) == 6) {
                  goto LABEL_260;
                }
                if ((*(unsigned char *)(a1 + 75) & 1) == 0)
                {
                  int v215 = *(unsigned __int16 *)(a1 + 170);
                  if (v215 == 2)
                  {
                    if (*(_DWORD *)(a1 + 228) == *(unsigned __int16 *)(a1 + 130)) {
                      goto LABEL_226;
                    }
                  }
                  else if (v215 != 1 || *(_DWORD *)(a1 + 228) <= 1u)
                  {
LABEL_226:
                    long long v216 = "TIFF directory is missing required \"StripByteCounts\" field, calculating from imagelength";
LABEL_238:
                    TIFFWarningExtR(a1, "TIFFReadDirectory", v216, v37, v38, v39, v40, v41, v236);
                    if ((EstimateStripByteCounts(a1, (uint64_t)__src, v15) & 0x80000000) != 0) {
                      goto LABEL_80;
                    }
                    goto LABEL_260;
                  }
                  unsigned int v86 = "StripByteCounts";
                  goto LABEL_78;
                }
                int v218 = *(_DWORD *)(a1 + 16);
                if (*(_DWORD *)(a1 + 228) == 1 && (v218 & 0x400) == 0)
                {
                  if (ByteCountLooksBad(a1))
                  {
                    long long v216 = "Bogus \"StripByteCounts\" field, ignoring and calculating from imagelength";
                    goto LABEL_238;
                  }
                  int v218 = *(_DWORD *)(a1 + 16);
                }
                if ((v218 & 0x1000000) == 0
                  && *(_WORD *)(a1 + 170) == 1
                  && *(_DWORD *)(a1 + 228) >= 3u
                  && *(_WORD *)(a1 + 120) == 1)
                {
                  uint64_t v220 = _TIFFGetStrileOffsetOrByteCountValue(a1, 0);
                  if (v220 != _TIFFGetStrileOffsetOrByteCountValue(a1, 1)
                    && _TIFFGetStrileOffsetOrByteCountValue(a1, 0)
                    && _TIFFGetStrileOffsetOrByteCountValue(a1, 1))
                  {
                    long long v216 = "Wrong \"StripByteCounts\" field, ignoring and calculating from imagelength";
                    goto LABEL_238;
                  }
                }
LABEL_260:
                if (__src)
                {
                  _TIFFfreeExt(a1, (char *)__src);
                  __vImage_Buffer src = 0;
                }
                if ((*(unsigned char *)(a1 + 74) & 8) == 0)
                {
                  unint64_t v221 = *(unsigned __int16 *)(a1 + 116);
                  if (v221 <= 0xF) {
                    __int16 v222 = ~(unsigned __int16)(-1 << v221);
                  }
                  else {
                    __int16 v222 = -1;
                  }
                  *(_WORD *)(a1 + 138) = v222;
                }
                (*(void (**)(uint64_t))(a1 + 952))(a1);
                if (*(_WORD *)(a1 + 170) == 1)
                {
                  int v230 = *(unsigned __int16 *)(a1 + 120);
                  if (*(_DWORD *)(a1 + 228) != 1) {
                    goto LABEL_273;
                  }
                  if (v230 != 1
                    || (*(_DWORD *)(a1 + 16) & 0x8400) != 0x8000
                    || (ChopUpSingleUncompressedStrip(a1), *(_WORD *)(a1 + 170) == 1))
                  {
                    int v230 = *(unsigned __int16 *)(a1 + 120);
LABEL_273:
                    if (v230 == 1
                      && (*(_DWORD *)(a1 + 16) & 0x8400) == 0x8000
                      && _cg_TIFFStripSize64(a1, v223, v224, v225, v226, v227, v228, v229) >> 31)
                    {
                      TryChopUpUncompressedBigTiff(a1, v223, v224, v225, v226, v227, v228, v229);
                    }
                  }
                }
                *(_DWORD *)(a1 + 16) &= 0xFFDFFFF7;
                *(_DWORD *)(a1 + 87jp2_colour_converter::clear(this + 6) = -1;
                *(_DWORD *)(a1 + 884) = -1;
                *(void *)(a1 + 928) = -1;
                *(void *)(a1 + 93jp2_colour_converter::clear(this + 6) = -1;
                uint64_t v231 = _cg_TIFFScanlineSize(a1, v223, v224, v225, v226, v227, v228, v229);
                *(void *)(a1 + 1104) = v231;
                if (v231)
                {
                  if ((*(unsigned char *)(a1 + 17) & 4) == 0)
                  {
                    if (!_cg_TIFFStripSize(a1, v232, v233, v10, v11, v12, v13, v14))
                    {
                      unsigned int v21 = "Cannot handle zero strip size";
                      goto LABEL_10;
                    }
                    return 1;
                  }
                  uint64_t v234 = _cg_TIFFTileSize(a1, v232, v233, v10, v11, v12, v13, v14);
                  *(void *)(a1 + 93jp2_colour_converter::clear(this + 6) = v234;
                  if (v234) {
                    return 1;
                  }
                  unsigned int v21 = "Cannot handle zero tile size";
                }
                else
                {
                  unsigned int v21 = "Cannot handle zero scanline size";
                }
LABEL_10:
                TIFFErrorExtR(a1, "TIFFReadDirectory", v21, v10, v11, v12, v13, v14, v236);
                return 0;
              }
              continue;
            }
            if (v91 - 280 < 2) {
              goto LABEL_109;
            }
            if (v91 != 279)
            {
              if (v91 == 301)
              {
LABEL_102:
                unsigned int v241 = 0;
                if (v87)
                {
                  unint64_t v92 = *(unsigned __int16 *)(a1 + 116);
                  if (v92 < 0x19)
                  {
                    int8x8_t v148 = v89[1];
                    if (v91 == 301 && *(void *)&v148 == 1 << v92 || *(void *)&v148 == 3 << v92)
                    {
                      int v149 = TIFFReadDirEntryShortArray(a1, (uint64_t)v89, &v241);
                      if ((EvaluateIFDdatasizeReading(a1, v89) & 1) == 0) {
                        goto LABEL_80;
                      }
                      if (!v149)
                      {
                        int v238 = v87;
                        uint64_t v162 = v90;
                        uint64_t v163 = (__int32 *)v241;
                        _cg_TIFFSetField(a1, v89->u16[0], v150, v151, v152, v153, v154, v155, (uint64_t)v241);
                        int v164 = (char *)v163;
                        unint64_t v90 = v162;
                        int v87 = v238;
                        _TIFFfreeExt(a1, v164);
                        goto LABEL_86;
                      }
                    }
                    else
                    {
                      if ((EvaluateIFDdatasizeReading(a1, v89) & 1) == 0) {
                        goto LABEL_80;
                      }
                      int v149 = 1;
                    }
                    long long v156 = TIFFFieldWithTag((void *)a1, v89->u16[0]);
                    if (v156) {
                      uint64_t v160 = (const char *)*((void *)v156 + 4);
                    }
                    else {
                      uint64_t v160 = "unknown tagname";
                    }
                    TIFFReadDirEntryOutputErr(a1, v149, "TIFFReadDirectory", (uint64_t)v160, 1, v157, v158, v159);
                  }
                  else
                  {
                    uint64_t v93 = TIFFFieldWithTag((void *)a1, v91);
                    if (v93) {
                      unint64_t v99 = (const char *)*((void *)v93 + 4);
                    }
                    else {
                      unint64_t v99 = "unknown tagname";
                    }
                    TIFFWarningExtR(a1, "TIFFReadDirectory", "Ignoring %s because BitsPerSample=%hu>24", v94, v95, v96, v97, v98, (char)v99);
                  }
                }
                else
                {
                  long long v141 = TIFFFieldWithTag((void *)a1, v91);
                  if (v141) {
                    long long v147 = (const char *)*((void *)v141 + 4);
                  }
                  else {
                    long long v147 = "unknown tagname";
                  }
                  TIFFWarningExtR(a1, "TIFFReadDirectory", "Ignoring %s since BitsPerSample tag not found", v142, v143, v144, v145, v146, (char)v147);
                }
                goto LABEL_86;
              }
LABEL_141:
              TIFFFetchNormalTag(a1, (unsigned __int16 *)v89, 1);
              goto LABEL_86;
            }
          }
          break;
        }
        unsigned int v116 = v89->u16[1];
        if ((v116 > 0x10 || ((1 << v116) & 0x10018) == 0)
          && (*(_DWORD *)(a1 + 12) != 2 || v89->i16[1] || *(void *)&v89[1] || *(void *)&v89[2]))
        {
          unint64_t v117 = TIFFFieldWithTag((void *)a1, v91);
          if (v117) {
            uint64_t v123 = *((void *)v117 + 4);
          }
          else {
            LOBYTE(v12++*((_DWORD *)this + 3) = "unknown tagname";
          }
          TIFFWarningExtR(a1, "TIFFReadDirectory", "Invalid data type for tag %s", v118, v119, v120, v121, v122, v123);
        }
        uint64_t v161 = (unsigned __int16 *)(a1 + 288);
        goto LABEL_164;
      }
    }
  }
  return result;
}

uint64_t _TIFFCheckDirNumberAndOffset(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (!a3) {
    return 0;
  }
  uint64_t v6 = *(void **)(a1 + 48);
  if (!v6)
  {
    uint64_t v6 = TIFFHashSetNew((uint64_t (*)())hashFuncOffsetToNumber, (BOOL (*)(uint64_t, uint64_t))equalFuncOffsetToNumber, MEMORY[0x1E4F14838]);
    *(void *)(a1 + 48) = v6;
    if (!v6) {
      goto LABEL_21;
    }
  }
  if (*(void *)(a1 + 56)) {
    goto LABEL_7;
  }
  uint64_t v12 = TIFFHashSetNew((uint64_t (*)())hashFuncNumberToOffset, equalFuncNumberToOffset, 0);
  *(void *)(a1 + 5jp2_colour_converter::clear(this + 6) = v12;
  if (!v12)
  {
LABEL_21:
    TIFFErrorExtR(a1, "_TIFFCheckDirNumberAndOffset", "Not enough memory", v7, v8, v9, v10, v11, v38);
    return 1;
  }
  uint64_t v6 = *(void **)(a1 + 48);
LABEL_7:
  *(void *)&long long v40 = a3;
  *((void *)&v40 + 1) = a2;
  uint64_t v13 = TIFFHashSetLookup((uint64_t)v6, (uint64_t)&v40);
  if (!v13)
  {
    unsigned int v20 = TIFFHashSetLookup(*(void *)(a1 + 56), (uint64_t)&v40);
    if (v20)
    {
      if (*v20 == a3) {
        return 1;
      }
      v39[0] = *v20;
      v39[1] = a2;
      unsigned int v21 = TIFFHashSetLookup(*(void *)(a1 + 56), (uint64_t)v39);
      if (v21) {
        TIFFHashSetRemove(*(void *)(a1 + 56), (uint64_t)v21);
      }
      int v22 = TIFFHashSetLookup(*(void *)(a1 + 48), (uint64_t)v39);
      if (v22) {
        TIFFHashSetRemove(*(void *)(a1 + 48), (uint64_t)v22);
      }
      BOOL v23 = malloc_type_malloc(0x10uLL, 0x1000040D9A13B51uLL);
      if (!v23) {
        return 0;
      }
      uint64_t v24 = (uint64_t)v23;
      _OWORD *v23 = v40;
      if (TIFFHashSetInsert(*(void *)(a1 + 48), (uint64_t)v23))
      {
        if (TIFFHashSetInsert(*(void *)(a1 + 56), v24)) {
          return 1;
        }
        uint64_t v30 = "Insertion in tif_map_dir_number_to_offset failed";
      }
      else
      {
        uint64_t v30 = "Insertion in tif_map_dir_offset_to_number failed";
      }
    }
    else
    {
      if ((int)TIFFHashSetSize(*(void *)(a1 + 48)) >= 0x100000)
      {
        TIFFErrorExtR(a1, "_TIFFCheckDirNumberAndOffset", "Cannot handle more than %u TIFF directories", v31, v32, v33, v34, v35, 0);
        return 0;
      }
      uint64_t v36 = malloc_type_malloc(0x10uLL, 0x1000040D9A13B51uLL);
      if (v36)
      {
        uint64_t v37 = (uint64_t)v36;
        *uint64_t v36 = v40;
        if (TIFFHashSetInsert(*(void *)(a1 + 48), (uint64_t)v36))
        {
          if (TIFFHashSetInsert(*(void *)(a1 + 56), v37)) {
            return 1;
          }
          uint64_t v30 = "Insertion in tif_map_dir_number_to_offset failed";
        }
        else
        {
          uint64_t v30 = "Insertion in tif_map_dir_offset_to_number failed";
        }
      }
      else
      {
        uint64_t v30 = "malloc(sizeof(TIFFOffsetAndDirNumber)) failed";
      }
    }
    TIFFErrorExtR(a1, "_TIFFCheckDirNumberAndOffset", v30, v25, v26, v27, v28, v29, v38);
    return 0;
  }
  if (*((_DWORD *)v13 + 2) == a2) {
    return 1;
  }
  TIFFWarningExtR(a1, "_TIFFCheckDirNumberAndOffset", "TIFF directory %d has IFD looping to directory %u at offset 0x%llx (%llu)", v14, v15, v16, v17, v18, a2 - 1);
  return 0;
}

char *TIFFFetchDirectory(uint64_t a1, uint64_t a2, void *a3, int8x8_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a3) {
    TIFFFetchDirectory_cold_1();
  }
  *(void *)(a1 + 24) = a2;
  if (a4) {
    *a4 = 0;
  }
  unsigned __int16 __dst = 0;
  int v11 = *(_DWORD *)(a1 + 16);
  unint64_t v12 = *(void *)(a1 + 24);
  if ((v11 & 0x800) == 0)
  {
    if (_TIFFSeekOK(a1, v12))
    {
      if ((*(unsigned char *)(a1 + 18) & 8) != 0)
      {
        int8x8_t v53 = 0;
        if ((*(uint64_t (**)(void, int8x8_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v53, 8) == 8)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            TIFFSwabLong8(&v53);
          }
          unsigned __int16 v18 = v53.i16[0];
          if (*(void *)&v53 <= 0x1000uLL)
          {
            unsigned __int16 __dst = v53.i16[0];
            unsigned int v19 = 20;
            goto LABEL_26;
          }
          goto LABEL_43;
        }
      }
      else if ((*(uint64_t (**)(void, unsigned __int16 *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &__dst, 2) == 2)
      {
        if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
          TIFFSwabShort(&__dst);
        }
        unsigned __int16 v18 = __dst;
        if (__dst <= 0x1000u)
        {
          unsigned int v19 = 12;
LABEL_26:
          uint64_t result = (char *)_TIFFCheckMalloc((const char **)a1, v18, v19, (uint64_t)"to read TIFF directory", a5, a6, a7, a8);
          if (!result) {
            return result;
          }
          uint64_t v24 = result;
          uint64_t v25 = (*(uint64_t (**)(void, char *, void))(a1 + 1208))(*(void *)(a1 + 1200), result, v19 * __dst);
          if (v25 == v19 * __dst)
          {
            if (!a4) {
              goto LABEL_67;
            }
            if ((*(unsigned char *)(a1 + 18) & 8) == 0)
            {
              v53.i32[0] = 0;
              if ((*(uint64_t (**)(void, int8x8_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v53, 4) != 4)v53.i32[0] = 0; {
              LOBYTE(v32) = *(unsigned char *)(a1 + 16);
              }
LABEL_33:
              if ((v32 & 0x80) != 0) {
                TIFFSwabLong((__int32 *)&v53, v31);
              }
              *a4 = (int8x8_t)v53.u32[0];
              goto LABEL_67;
            }
            if ((*(uint64_t (**)(void, int8x8_t *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), a4, 8) != 8) {
              *a4 = 0;
            }
            LOBYTE(v32) = *(unsigned char *)(a1 + 16);
            goto LABEL_60;
          }
          uint64_t v52 = *(const char **)a1;
          uint64_t v34 = "%.100s: Can not read TIFF directory";
LABEL_48:
          TIFFErrorExtR(a1, "TIFFFetchDirectory", v34, v26, v27, v28, v29, v30, (char)v52);
LABEL_83:
          _TIFFfreeExt(a1, v24);
          return 0;
        }
        goto LABEL_43;
      }
      TIFFErrorExtR(a1, "TIFFFetchDirectory", "%s: Can not read TIFF directory count", (uint64_t)a4, a5, a6, a7, a8, *(void *)a1);
    }
    else
    {
      TIFFErrorExtR(a1, "TIFFFetchDirectory", "%s: Seek error accessing TIFF directory", v13, v14, v15, v16, v17, *(void *)a1);
    }
    return 0;
  }
  if ((v12 & 0x8000000000000000) != 0) {
    goto LABEL_38;
  }
  if ((v11 & 0x80000) == 0)
  {
    if (v12 <= 0x7FFFFFFFFFFFFFFDLL)
    {
      unint64_t v20 = v12 + 2;
      if ((int64_t)(v12 + 2) <= *(void *)(a1 + 1176))
      {
        _TIFFmemcpy(&__dst, (const void *)(*(void *)(a1 + 1168) + v12), 2uLL);
        if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
          TIFFSwabShort(&__dst);
        }
        int v21 = __dst;
        if (__dst <= 0x1000u)
        {
          unsigned int v22 = 12;
          goto LABEL_50;
        }
LABEL_43:
        uint64_t v33 = "Sanity check on directory count failed, this is probably not a valid IFD offset";
        goto LABEL_44;
      }
    }
LABEL_38:
    uint64_t v33 = "Can not read TIFF directory count";
LABEL_44:
    TIFFErrorExtR(a1, "TIFFFetchDirectory", v33, (uint64_t)a4, a5, a6, a7, a8, (char)v52);
    return 0;
  }
  int8x8_t v53 = 0;
  if (v12 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_38;
  }
  unint64_t v20 = v12 + 8;
  if ((int64_t)(v12 + 8) > *(void *)(a1 + 1176)) {
    goto LABEL_38;
  }
  _TIFFmemcpy(&v53, (const void *)(*(void *)(a1 + 1168) + v12), 8uLL);
  if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
    TIFFSwabLong8(&v53);
  }
  if (*(void *)&v53 > 0x1000uLL) {
    goto LABEL_43;
  }
  int v21 = v53.u16[0];
  unsigned __int16 __dst = v53.i16[0];
  unsigned int v22 = 20;
LABEL_50:
  if (!v21)
  {
    uint64_t v33 = "Sanity check on directory count failed, zero tag directories not supported";
    goto LABEL_44;
  }
  unint64_t v35 = (*(uint64_t (**)(void))(a1 + 1240))(*(void *)(a1 + 1200));
  if (__dst * (unint64_t)v22 > v35)
  {
    TIFFWarningExtR(a1, "TIFFFetchDirectory", "Requested memory size for TIFF directory of %llu is greater than filesize %llu. Memory not allocated, TIFF directory not read", v36, v37, v38, v39, v40, __dst * v22);
    return 0;
  }
  uint64_t result = (char *)_TIFFCheckMalloc((const char **)a1, __dst, v22, (uint64_t)"to read TIFF directory", v37, v38, v39, v40);
  if (!result) {
    return result;
  }
  uint64_t v24 = result;
  size_t v41 = v22 * __dst;
  if ((int64_t)(v20 + v41) > *(void *)(a1 + 1176))
  {
    uint64_t v34 = "Can not read TIFF directory";
    goto LABEL_48;
  }
  _TIFFmemcpy(result, (const void *)(*(void *)(a1 + 1168) + v20), v41);
  if (!a4) {
    goto LABEL_67;
  }
  unint64_t v42 = v20 + v22 * __dst;
  int v32 = *(_DWORD *)(a1 + 16);
  if ((v32 & 0x80000) == 0)
  {
    v53.i32[0] = 0;
    if (v42 <= 0x7FFFFFFFFFFFFFFBLL && (int64_t)(v42 + 4) <= *(void *)(a1 + 1176))
    {
      _TIFFmemcpy(&v53, (const void *)(*(void *)(a1 + 1168) + v42), 4uLL);
      int v32 = *(_DWORD *)(a1 + 16);
    }
    goto LABEL_33;
  }
  if (v42 <= 0x7FFFFFFFFFFFFFF7 && (int64_t)(v42 + 8) <= *(void *)(a1 + 1176))
  {
    _TIFFmemcpy(a4, (const void *)(*(void *)(a1 + 1168) + v42), 8uLL);
    int v32 = *(_DWORD *)(a1 + 16);
  }
  else
  {
    *a4 = 0;
  }
LABEL_60:
  if ((v32 & 0x80) != 0) {
    TIFFSwabLong8(a4);
  }
LABEL_67:
  uint64_t v43 = _TIFFCheckMalloc((const char **)a1, __dst, 32, (uint64_t)"to read TIFF directory", v27, v28, v29, v30);
  if (!v43) {
    goto LABEL_83;
  }
  uint64_t v45 = v43;
  if (__dst)
  {
    unsigned int v46 = 0;
    uint64_t v47 = v43 + 2;
    uint8x8_t v48 = v24;
    do
    {
      *((unsigned char *)v47 + 8) = 0;
      int v49 = *(_DWORD *)(a1 + 16);
      if ((v49 & 0x80) != 0)
      {
        TIFFSwabShort(v48);
        int v49 = *(_DWORD *)(a1 + 16);
        *((_WORD *)v47 - 8) = *(_WORD *)v48;
        if ((v49 & 0x80) != 0)
        {
          TIFFSwabShort(v48 + 2);
          int v49 = *(_DWORD *)(a1 + 16);
        }
      }
      else
      {
        *((_WORD *)v47 - 8) = *(_WORD *)v48;
      }
      *((_WORD *)v47 - 7) = *((_WORD *)v48 + 1);
      int v50 = (int8x8_t *)(v48 + 4);
      if ((v49 & 0x80000) != 0)
      {
        if ((v49 & 0x80) != 0) {
          int8x8_t v44 = TIFFSwabLong8(v50);
        }
        *(v47 - 1) = *(void *)(v48 + 4);
        *uint64_t v47 = *(void *)(v48 + 12);
        uint64_t v51 = 20;
      }
      else
      {
        if ((v49 & 0x80) != 0) {
          int8x8_t v44 = TIFFSwabLong((__int32 *)v50, (uint8x8_t)v44);
        }
        *(v47 - 1) = *((unsigned int *)v48 + 1);
        *uint64_t v47 = 0;
        *(_DWORD *)uint64_t v47 = *((_DWORD *)v48 + 2);
        uint64_t v51 = 12;
      }
      v48 += v51;
      ++v46;
      v47 += 4;
    }
    while (v46 < __dst);
  }
  _TIFFfreeExt(a1, v24);
  *a3 = v45;
  return (char *)__dst;
}

uint64_t TIFFFetchNormalTag(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  unsigned int v155 = 0;
  __int16 v6 = *a2;
  TIFFReadDirectoryFindFieldInfo(a1, *a2, (int *)&v155);
  if (v155 == -1)
  {
    TIFFErrorExtR(a1, "TIFFFetchNormalTag", "No definition found for tag %hu", v7, v8, v9, v10, v11, v6);
    return 0;
  }
  uint64_t v13 = *(void *)(*(void *)(a1 + 1256) + 8 * v155);
  if (!v13) {
    TIFFFetchNormalTag_cold_1();
  }
  switch(*(_DWORD *)(v13 + 16))
  {
    case 0:
      TIFFErrorExtR(a1, "TIFFFetchNormalTag", "Defined set_field_type of custom tag %u (%s) is TIFF_SETGET_UNDEFINED and thus tag is not read from file", v7, v8, v9, v10, v11, *(_DWORD *)v13);
      return 1;
    case 1:
      *(double *)&__s = 0.0;
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_6();
      }
      int v14 = TIFFReadDirEntryByteArray(a1, (uint64_t)a2, &__s);
      if (v14) {
        goto LABEL_238;
      }
      uint64_t v15 = (char *)__s;
      if (*(double *)&__s == 0.0)
      {
        if ((EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2) & 1) == 0) {
          return 0;
        }
        size_t v17 = 0;
        goto LABEL_265;
      }
      uint64_t v16 = *((void *)a2 + 1);
      if (!v16) {
        goto LABEL_255;
      }
      if (__s->i8[v16 - 1])
      {
        if (*((void *)a2 + 1))
        {
          size_t v17 = 0;
          do
          {
            if (!__s->i8[v17]) {
              goto LABEL_256;
            }
            ++v17;
          }
          while (*((void *)a2 + 1) != v17);
          size_t v17 = *((void *)a2 + 1);
        }
        else
        {
LABEL_255:
          size_t v17 = 0;
        }
LABEL_256:
        if ((EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2) & 1) == 0) {
          goto LABEL_276;
        }
        goto LABEL_265;
      }
      size_t v17 = strlen((const char *)__s);
      if (!EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2)) {
        goto LABEL_276;
      }
LABEL_265:
      unint64_t v135 = *((unsigned int *)a2 + 2);
      if (v17 + 1 >= v135)
      {
        if (v17 + 1 > v135)
        {
          TIFFWarningExtR(a1, "TIFFFetchNormalTag", "ASCII value for tag \"%s\" does not end in null byte. Forcing it to be null", v128, v129, v130, v131, v132, *(void *)(v13 + 32));
          unint64_t v142 = *((void *)a2 + 1) + 1;
          if (HIDWORD(v142)) {
            TIFFFetchNormalTag_cold_5();
          }
          uint64_t v143 = _TIFFmallocExt((void *)a1, v142, v136, v137, v138, v139, v140, v141);
          if (!v143)
          {
LABEL_275:
            if (v15)
            {
LABEL_276:
              uint64_t v126 = a1;
              uint64_t v125 = v15;
LABEL_250:
              _TIFFfreeExt(v126, v125);
            }
            return 0;
          }
          uint64_t v150 = (uint64_t)v143;
          uint64_t v151 = *((void *)a2 + 1);
          if (v151)
          {
            _TIFFmemcpy(v143, v15, *((void *)a2 + 1));
            uint64_t v151 = *((unsigned int *)a2 + 2);
          }
          *(unsigned char *)(v150 + v151) = 0;
          if (v15) {
            _TIFFfreeExt(a1, v15);
          }
          int v44 = _cg_TIFFSetField(a1, *a2, v144, v145, v146, v147, v148, v149, v150);
          uint64_t v15 = (char *)v150;
          goto LABEL_278;
        }
      }
      else
      {
        TIFFWarningExtR(a1, "TIFFFetchNormalTag", "ASCII value for tag \"%s\" contains null byte in value; value incorrectly truncated during reading due to impl"
          "ementation limitations",
          v128,
          v129,
          v130,
          v131,
          v132,
          *(void *)(v13 + 32));
      }
      int v44 = _cg_TIFFSetField(a1, *a2, v127, v128, v129, v130, v131, v132, (uint64_t)v15);
      if (!v15) {
        goto LABEL_280;
      }
LABEL_278:
      uint64_t v133 = a1;
      uint64_t v134 = v15;
LABEL_279:
      _TIFFfreeExt(v133, v134);
LABEL_280:
      if (v44) {
        goto LABEL_238;
      }
      return 0;
    case 2:
      LOBYTE(__s) = 0;
      if (*(_WORD *)(v13 + 4) != 1) {
        TIFFFetchNormalTag_cold_8();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_7();
      }
      int v14 = TIFFReadDirEntryByte(a1, (int8x8_t *)a2, &__s, *(uint8x8_t *)&v12);
      if (v14) {
        goto LABEL_238;
      }
      uint64_t v21 = *a2;
      uint64_t v22 = __s;
      goto LABEL_40;
    case 3:
      LOBYTE(__s) = 0;
      if (*(_WORD *)(v13 + 4) != 1) {
        TIFFFetchNormalTag_cold_10();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_9();
      }
      int v14 = TIFFReadDirEntrySbyte(a1, (int8x8_t *)a2, (__int8 *)&__s, *(uint8x8_t *)&v12);
      if (v14) {
        goto LABEL_238;
      }
      uint64_t v21 = *a2;
      uint64_t v22 = (char)__s;
      goto LABEL_40;
    case 4:
      LOWORD(__s) = 0;
      if (*(_WORD *)(v13 + 4) != 1) {
        TIFFFetchNormalTag_cold_12();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_11();
      }
      int v14 = TIFFReadDirEntryShort(a1, (int8x8_t *)a2, &__s, *(uint8x8_t *)&v12);
      if (v14) {
        goto LABEL_238;
      }
      uint64_t v21 = *a2;
      uint64_t v22 = (unsigned __int16)__s;
      goto LABEL_40;
    case 5:
      LOWORD(__s) = 0;
      if (*(_WORD *)(v13 + 4) != 1) {
        TIFFFetchNormalTag_cold_14();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_13();
      }
      int v14 = TIFFReadDirEntrySshort(a1, (int8x8_t *)a2, &__s, *(uint8x8_t *)&v12);
      if (v14) {
        goto LABEL_238;
      }
      uint64_t v21 = *a2;
      uint64_t v22 = (__int16)__s;
      goto LABEL_40;
    case 6:
      LODWORD(__s) = 0;
      if (*(_WORD *)(v13 + 4) != 1) {
        TIFFFetchNormalTag_cold_16();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_15();
      }
      int v23 = TIFFReadDirEntryLong(a1, (int8x8_t *)a2, (__int32 *)&__s, *(uint8x8_t *)&v12);
      goto LABEL_38;
    case 7:
      LODWORD(__s) = 0;
      if (*(_WORD *)(v13 + 4) != 1) {
        TIFFFetchNormalTag_cold_18();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_17();
      }
      int v23 = TIFFReadDirEntrySlong(a1, (int8x8_t *)a2, (__int32 *)&__s, *(uint8x8_t *)&v12);
LABEL_38:
      int v14 = v23;
      if (v23) {
        goto LABEL_238;
      }
      uint64_t v21 = *a2;
      uint64_t v22 = __s;
LABEL_40:
      uint64_t result = _cg_TIFFSetField(a1, v21, v18, v19, v20, v9, v10, v11, v22);
      if (!result) {
        return result;
      }
      goto LABEL_238;
    case 8:
      *(double *)&__s = 0.0;
      if (*(_WORD *)(v13 + 4) != 1) {
        TIFFFetchNormalTag_cold_20();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_19();
      }
      int v25 = TIFFReadDirEntryLong8(a1, (int8x8_t *)a2, (int8x8_t *)&__s, *(uint8x8_t *)&v12);
      goto LABEL_62;
    case 9:
      *(double *)&__s = 0.0;
      if (*(_WORD *)(v13 + 4) != 1) {
        TIFFFetchNormalTag_cold_22();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_21();
      }
      int v25 = TIFFReadDirEntrySlong8(a1, (int8x8_t *)a2, (int8x8_t *)&__s, *(uint8x8_t *)&v12);
      goto LABEL_62;
    case 0xA:
      LODWORD(__s) = 0;
      if (*(_WORD *)(v13 + 4) != 1) {
        TIFFFetchNormalTag_cold_24();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_23();
      }
      int v14 = TIFFReadDirEntryFloat(a1, (int8x8_t *)a2, (__int32 *)&__s, v12);
      if (v14) {
        goto LABEL_238;
      }
      if (!EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2)) {
        return 0;
      }
      uint64_t v32 = *a2;
      *(double *)&uint64_t v33 = *(float *)&__s;
      goto LABEL_58;
    case 0xB:
      *(double *)&__s = 0.0;
      if (*(_WORD *)(v13 + 4) != 1) {
        TIFFFetchNormalTag_cold_26();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_25();
      }
      int v14 = TIFFReadDirEntryDouble(a1, (int8x8_t *)a2, (double *)&__s, v12);
      if (v14) {
        goto LABEL_238;
      }
      if (!EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2)) {
        return 0;
      }
      uint64_t v32 = *a2;
      uint64_t v33 = (uint64_t)__s;
LABEL_58:
      int v34 = _cg_TIFFSetField(a1, v32, v26, v27, v28, v29, v30, v31, v33);
      goto LABEL_65;
    case 0xC:
      *(double *)&__s = 0.0;
      if (*(_WORD *)(v13 + 4) != 1) {
        TIFFFetchNormalTag_cold_28();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_27();
      }
      int v25 = TIFFReadDirEntryIfd8(a1, (int8x8_t *)a2, (int8x8_t *)&__s, *(uint8x8_t *)&v12);
LABEL_62:
      int v14 = v25;
      if (v25) {
        goto LABEL_238;
      }
      if (!EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2)) {
        return 0;
      }
      int v34 = _cg_TIFFSetField(a1, *a2, v35, v36, v37, v38, v39, v40, (uint64_t)__s);
LABEL_65:
      if (!v34) {
        return 0;
      }
      goto LABEL_238;
    case 0xD:
      TIFFFetchNormalTag_cold_4();
    case 0xE:
      *(double *)&__s = 0.0;
      if (*(_WORD *)(v13 + 4) != 2) {
        TIFFFetchNormalTag_cold_31();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_30();
      }
      if (*((void *)a2 + 1) != 2)
      {
        TIFFWarningExtR(a1, "TIFFFetchNormalTag", "incorrect count for field \"%s\", expected 2, got %llu", v7, v8, v9, v10, v11, *(void *)(v13 + 32));
        return 0;
      }
      int v14 = TIFFReadDirEntryShortArray(a1, (uint64_t)a2, (char **)&__s);
      if (v14) {
        goto LABEL_238;
      }
      uint64_t v15 = (char *)__s;
      if (*(double *)&__s == 0.0) {
        TIFFFetchNormalTag_cold_29();
      }
      int v44 = _cg_TIFFSetField(a1, *a2, v41, v42, v43, v9, v10, v11, __s->u16[0]);
      goto LABEL_278;
    case 0x10:
      *(double *)&__s = 0.0;
      int v45 = *(__int16 *)(v13 + 4);
      if (v45 <= 0) {
        TIFFFetchNormalTag_cold_32();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_33();
      }
      if (*((void *)a2 + 1) != (unsigned __int16)v45) {
        goto LABEL_117;
      }
      int v46 = TIFFReadDirEntryByteArray(a1, (uint64_t)a2, &__s);
      goto LABEL_114;
    case 0x11:
      *(double *)&__s = 0.0;
      int v47 = *(__int16 *)(v13 + 4);
      if (v47 <= 0) {
        TIFFFetchNormalTag_cold_34();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_35();
      }
      if (*((void *)a2 + 1) != (unsigned __int16)v47) {
        goto LABEL_117;
      }
      int v46 = TIFFReadDirEntrySbyteArray(a1, (uint64_t)a2, &__s);
      goto LABEL_114;
    case 0x12:
      *(double *)&__s = 0.0;
      int v48 = *(__int16 *)(v13 + 4);
      if (v48 <= 0) {
        TIFFFetchNormalTag_cold_36();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_37();
      }
      if (*((void *)a2 + 1) != (unsigned __int16)v48) {
        goto LABEL_117;
      }
      int v46 = TIFFReadDirEntryShortArray(a1, (uint64_t)a2, (char **)&__s);
      goto LABEL_114;
    case 0x13:
      *(double *)&__s = 0.0;
      int v49 = *(__int16 *)(v13 + 4);
      if (v49 <= 0) {
        TIFFFetchNormalTag_cold_38();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_39();
      }
      if (*((void *)a2 + 1) != (unsigned __int16)v49) {
        goto LABEL_117;
      }
      int v46 = TIFFReadDirEntrySshortArray(a1, (uint64_t)a2, &__s);
      goto LABEL_114;
    case 0x14:
      *(double *)&__s = 0.0;
      int v50 = *(__int16 *)(v13 + 4);
      if (v50 <= 0) {
        TIFFFetchNormalTag_cold_40();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_41();
      }
      if (*((void *)a2 + 1) != (unsigned __int16)v50) {
        goto LABEL_117;
      }
      int v46 = TIFFReadDirEntryLongArray(a1, (uint64_t)a2, (__int32 **)&__s);
      goto LABEL_114;
    case 0x15:
      *(double *)&__s = 0.0;
      int v51 = *(__int16 *)(v13 + 4);
      if (v51 <= 0) {
        TIFFFetchNormalTag_cold_42();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_43();
      }
      if (*((void *)a2 + 1) != (unsigned __int16)v51) {
        goto LABEL_117;
      }
      int v46 = TIFFReadDirEntrySlongArray(a1, (uint64_t)a2, &__s);
      goto LABEL_114;
    case 0x16:
      *(double *)&__s = 0.0;
      int v52 = *(__int16 *)(v13 + 4);
      if (v52 <= 0) {
        TIFFFetchNormalTag_cold_44();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_45();
      }
      if (*((void *)a2 + 1) != (unsigned __int16)v52) {
        goto LABEL_117;
      }
      int v46 = TIFFReadDirEntryLong8ArrayWithLimit(a1, (uint64_t)a2, &__s, 0xFFFFFFFFFFFFFFFFLL);
      goto LABEL_114;
    case 0x17:
      *(double *)&__s = 0.0;
      int v53 = *(__int16 *)(v13 + 4);
      if (v53 <= 0) {
        TIFFFetchNormalTag_cold_46();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_47();
      }
      if (*((void *)a2 + 1) != (unsigned __int16)v53) {
        goto LABEL_117;
      }
      int v46 = TIFFReadDirEntrySlong8Array(a1, (uint64_t)a2, &__s);
      goto LABEL_114;
    case 0x18:
      *(double *)&__s = 0.0;
      int v54 = *(__int16 *)(v13 + 4);
      if (v54 <= 0) {
        TIFFFetchNormalTag_cold_48();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_49();
      }
      if (*((void *)a2 + 1) != (unsigned __int16)v54) {
        goto LABEL_117;
      }
      int v46 = TIFFReadDirEntryFloatArray(a1, (uint64_t)a2, &__s);
      goto LABEL_114;
    case 0x19:
      *(double *)&__s = 0.0;
      int v55 = *(__int16 *)(v13 + 4);
      if (v55 <= 0) {
        TIFFFetchNormalTag_cold_50();
      }
      if (*(unsigned char *)(v13 + 27)) {
        TIFFFetchNormalTag_cold_51();
      }
      if (*((void *)a2 + 1) != (unsigned __int16)v55)
      {
LABEL_117:
        TIFFWarningExtR(a1, "TIFFFetchNormalTag", "incorrect count for field \"%s\", expected %d, got %llu", v7, v8, v9, v10, v11, *(void *)(v13 + 32));
        return 0;
      }
      int v46 = TIFFReadDirEntryDoubleArray(a1, (uint64_t)a2, (__int32 **)&__s);
LABEL_114:
      int v14 = v46;
      if (v46) {
        goto LABEL_238;
      }
      if ((EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2) & 1) == 0) {
        goto LABEL_248;
      }
      uint64_t v62 = *a2;
      int v63 = (char *)__s;
      int v64 = _cg_TIFFSetField(a1, v62, v56, v57, v58, v59, v60, v61, (uint64_t)__s);
      goto LABEL_228;
    case 0x1B:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1) {
        TIFFFetchNormalTag_cold_53();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_52();
      }
      if (*((void *)a2 + 1) >> 16) {
        goto LABEL_173;
      }
      int v14 = TIFFReadDirEntryByteArray(a1, (uint64_t)a2, &__s);
      if (v14) {
        goto LABEL_238;
      }
      char v65 = EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2);
      uint64_t v72 = (char *)__s;
      if ((v65 & 1) == 0)
      {
        if (*(double *)&__s == 0.0) {
          return 0;
        }
        goto LABEL_259;
      }
      uint64_t v73 = *((void *)a2 + 1);
      if (*(double *)&__s == 0.0)
      {
        int v81 = 0;
        goto LABEL_284;
      }
      if (!v73 || !__s->i8[v73 - 1])
      {
        int v81 = (char *)__s;
        goto LABEL_284;
      }
      TIFFWarningExtR(a1, "TIFFFetchNormalTag", "ASCII value for ASCII array tag \"%s\" does not end in null byte. Forcing it to be null", v67, v68, v69, v70, v71, *(void *)(v13 + 32));
      unint64_t v80 = (char *)_TIFFmallocExt((void *)a1, (*((_DWORD *)a2 + 2) + 1), v74, v75, v76, v77, v78, v79);
      if (!v80)
      {
LABEL_259:
        uint64_t v126 = a1;
        uint64_t v125 = v72;
        goto LABEL_250;
      }
      int v81 = v80;
      uint64_t v82 = *((void *)a2 + 1);
      if (v82)
      {
        _TIFFmemcpy(v80, v72, *((void *)a2 + 1));
        uint64_t v82 = *((unsigned int *)a2 + 2);
      }
      v81[v82] = 0;
      ++*((void *)a2 + 1);
      _TIFFfreeExt(a1, v72);
      uint64_t v73 = *((void *)a2 + 1);
LABEL_284:
      int v122 = _cg_TIFFSetField(a1, *a2, v66, v67, v68, v69, v70, v71, (unsigned __int16)v73);
      if (v81)
      {
        uint64_t v123 = a1;
        uint64_t v124 = v81;
LABEL_245:
        _TIFFfreeExt(v123, v124);
      }
LABEL_246:
      if (!v122) {
        return 0;
      }
      int v14 = 0;
LABEL_238:
      if (v14)
      {
        TIFFReadDirEntryOutputErr(a1, v14, "TIFFFetchNormalTag", *(void *)(v13 + 32), a3, v9, v10, v11);
        return 0;
      }
      return 1;
    case 0x1C:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1) {
        TIFFFetchNormalTag_cold_55();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_54();
      }
      if (*((void *)a2 + 1) >> 16) {
        goto LABEL_173;
      }
      int v83 = TIFFReadDirEntryByteArray(a1, (uint64_t)a2, &__s);
      goto LABEL_237;
    case 0x1D:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1) {
        TIFFFetchNormalTag_cold_57();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_56();
      }
      if (*((void *)a2 + 1) >> 16) {
        goto LABEL_173;
      }
      int v83 = TIFFReadDirEntrySbyteArray(a1, (uint64_t)a2, &__s);
      goto LABEL_237;
    case 0x1E:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1) {
        TIFFFetchNormalTag_cold_59();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_58();
      }
      if (*((void *)a2 + 1) >> 16) {
        goto LABEL_173;
      }
      int v83 = TIFFReadDirEntryShortArray(a1, (uint64_t)a2, (char **)&__s);
      goto LABEL_237;
    case 0x1F:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1) {
        TIFFFetchNormalTag_cold_61();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_60();
      }
      if (*((void *)a2 + 1) >> 16) {
        goto LABEL_173;
      }
      int v83 = TIFFReadDirEntrySshortArray(a1, (uint64_t)a2, &__s);
      goto LABEL_237;
    case 0x20:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1) {
        TIFFFetchNormalTag_cold_63();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_62();
      }
      if (*((void *)a2 + 1) >> 16) {
        goto LABEL_173;
      }
      int v83 = TIFFReadDirEntryLongArray(a1, (uint64_t)a2, (__int32 **)&__s);
      goto LABEL_237;
    case 0x21:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1) {
        TIFFFetchNormalTag_cold_65();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_64();
      }
      if (*((void *)a2 + 1) >> 16) {
        goto LABEL_173;
      }
      int v83 = TIFFReadDirEntrySlongArray(a1, (uint64_t)a2, &__s);
      goto LABEL_237;
    case 0x22:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1) {
        TIFFFetchNormalTag_cold_67();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_66();
      }
      if (*((void *)a2 + 1) >> 16) {
        goto LABEL_173;
      }
      int v83 = TIFFReadDirEntryLong8ArrayWithLimit(a1, (uint64_t)a2, &__s, 0xFFFFFFFFFFFFFFFFLL);
      goto LABEL_237;
    case 0x23:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1) {
        TIFFFetchNormalTag_cold_69();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_68();
      }
      if (*((void *)a2 + 1) >> 16) {
        goto LABEL_173;
      }
      int v83 = TIFFReadDirEntrySlong8Array(a1, (uint64_t)a2, &__s);
      goto LABEL_237;
    case 0x24:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1) {
        TIFFFetchNormalTag_cold_71();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_70();
      }
      if (*((void *)a2 + 1) >> 16) {
        goto LABEL_173;
      }
      int v83 = TIFFReadDirEntryFloatArray(a1, (uint64_t)a2, &__s);
      goto LABEL_237;
    case 0x25:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1) {
        TIFFFetchNormalTag_cold_73();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_72();
      }
      if (*((void *)a2 + 1) >> 16) {
        goto LABEL_173;
      }
      int v83 = TIFFReadDirEntryDoubleArray(a1, (uint64_t)a2, (__int32 **)&__s);
      goto LABEL_237;
    case 0x26:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -1) {
        TIFFFetchNormalTag_cold_75();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_74();
      }
      if (*((void *)a2 + 1) >> 16)
      {
LABEL_173:
        int v14 = 1;
        goto LABEL_238;
      }
      int v83 = TIFFReadDirEntryIfd8Array(a1, (uint64_t)a2, &__s);
LABEL_237:
      int v14 = v83;
      if (v83) {
        goto LABEL_238;
      }
      if ((EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2) & 1) == 0) {
        goto LABEL_248;
      }
      uint64_t v121 = (char *)__s;
      int v122 = _cg_TIFFSetField(a1, *a2, v115, v116, v117, v118, v119, v120, a2[4]);
      if (!v121) {
        goto LABEL_246;
      }
      uint64_t v123 = a1;
      uint64_t v124 = v121;
      goto LABEL_245;
    case 0x27:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3) {
        TIFFFetchNormalTag_cold_77();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_76();
      }
      int v14 = TIFFReadDirEntryByteArray(a1, (uint64_t)a2, &__s);
      if (v14) {
        goto LABEL_238;
      }
      char v84 = EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2);
      uint64_t v15 = (char *)__s;
      if ((v84 & 1) == 0) {
        goto LABEL_275;
      }
      if (*(double *)&__s == 0.0)
      {
        unint64_t v99 = 0;
      }
      else
      {
        uint64_t v91 = *((void *)a2 + 1);
        if (v91 && __s->i8[v91 - 1])
        {
          TIFFWarningExtR(a1, "TIFFFetchNormalTag", "ASCII value for ASCII array tag \"%s\" does not end in null byte. Forcing it to be null", v86, v87, v88, v89, v90, *(void *)(v13 + 32));
          uint64_t v98 = (char *)_TIFFmallocExt((void *)a1, (*((_DWORD *)a2 + 2) + 1), v92, v93, v94, v95, v96, v97);
          if (!v98) {
            goto LABEL_276;
          }
          unint64_t v99 = v98;
          uint64_t v100 = *((void *)a2 + 1);
          if (v100)
          {
            _TIFFmemcpy(v98, v15, *((void *)a2 + 1));
            uint64_t v100 = *((unsigned int *)a2 + 2);
          }
          v99[v100] = 0;
          ++*((void *)a2 + 1);
          _TIFFfreeExt(a1, v15);
        }
        else
        {
          unint64_t v99 = (char *)__s;
        }
      }
      int v44 = _cg_TIFFSetField(a1, *a2, v85, v86, v87, v88, v89, v90, *((void *)a2 + 1));
      if (!v99) {
        goto LABEL_280;
      }
      uint64_t v133 = a1;
      uint64_t v134 = v99;
      goto LABEL_279;
    case 0x28:
      *(double *)&__s = 0.0;
      unsigned int v153 = 0;
      if (*(__int16 *)(v13 + 4) != -3) {
        TIFFFetchNormalTag_cold_79();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_78();
      }
      if (*(_DWORD *)v13 == 33723 && a2[1] == 4)
      {
        uint64_t v152 = 0;
        int v101 = TIFFReadDirEntryArrayWithLimit(a1, (uint64_t)a2, &v153, 4u, (void **)&v152, 0xFFFFFFFFFFFFFFFFLL);
        int v14 = v101;
        if (v101 || (uint64_t v103 = (char *)v152) == 0)
        {
          *(double *)&__s = 0.0;
          if (v101) {
            goto LABEL_238;
          }
        }
        else
        {
          unsigned int v104 = v153;
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            TIFFSwabArrayOfLong(v152, v153, v102);
          }
          __s = (int8x8_t *)v103;
          unsigned int v153 = 4 * v104;
        }
      }
      else
      {
        int v14 = TIFFReadDirEntryByteArray(a1, (uint64_t)a2, &__s);
        unsigned int v153 = *((void *)a2 + 1);
        if (v14) {
          goto LABEL_238;
        }
      }
      if ((EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2) & 1) == 0)
      {
LABEL_248:
        uint64_t v125 = (char *)__s;
        if (*(double *)&__s == 0.0) {
          return 0;
        }
        uint64_t v126 = a1;
        goto LABEL_250;
      }
      uint64_t v112 = *a2;
      int v63 = (char *)__s;
      uint64_t v113 = v153;
LABEL_227:
      int v64 = _cg_TIFFSetField(a1, v112, v106, v107, v108, v109, v110, v111, v113);
LABEL_228:
      int v114 = v64;
      if (v63) {
        _TIFFfreeExt(a1, v63);
      }
      if (v114) {
        goto LABEL_238;
      }
      return 0;
    case 0x29:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3) {
        TIFFFetchNormalTag_cold_81();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_80();
      }
      int v105 = TIFFReadDirEntrySbyteArray(a1, (uint64_t)a2, &__s);
      goto LABEL_224;
    case 0x2A:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3) {
        TIFFFetchNormalTag_cold_83();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_82();
      }
      int v105 = TIFFReadDirEntryShortArray(a1, (uint64_t)a2, (char **)&__s);
      goto LABEL_224;
    case 0x2B:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3) {
        TIFFFetchNormalTag_cold_85();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_84();
      }
      int v105 = TIFFReadDirEntrySshortArray(a1, (uint64_t)a2, &__s);
      goto LABEL_224;
    case 0x2C:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3) {
        TIFFFetchNormalTag_cold_87();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_86();
      }
      int v105 = TIFFReadDirEntryLongArray(a1, (uint64_t)a2, (__int32 **)&__s);
      goto LABEL_224;
    case 0x2D:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3) {
        TIFFFetchNormalTag_cold_89();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_88();
      }
      int v105 = TIFFReadDirEntrySlongArray(a1, (uint64_t)a2, &__s);
      goto LABEL_224;
    case 0x2E:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3) {
        TIFFFetchNormalTag_cold_91();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_90();
      }
      int v105 = TIFFReadDirEntryLong8ArrayWithLimit(a1, (uint64_t)a2, &__s, 0xFFFFFFFFFFFFFFFFLL);
      goto LABEL_224;
    case 0x2F:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3) {
        TIFFFetchNormalTag_cold_93();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_92();
      }
      int v105 = TIFFReadDirEntrySlong8Array(a1, (uint64_t)a2, &__s);
      goto LABEL_224;
    case 0x30:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3) {
        TIFFFetchNormalTag_cold_95();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_94();
      }
      int v105 = TIFFReadDirEntryFloatArray(a1, (uint64_t)a2, &__s);
      goto LABEL_224;
    case 0x31:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3) {
        TIFFFetchNormalTag_cold_97();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_96();
      }
      int v105 = TIFFReadDirEntryDoubleArray(a1, (uint64_t)a2, (__int32 **)&__s);
      goto LABEL_224;
    case 0x32:
      *(double *)&__s = 0.0;
      if (*(__int16 *)(v13 + 4) != -3) {
        TIFFFetchNormalTag_cold_99();
      }
      if (*(unsigned char *)(v13 + 27) != 1) {
        TIFFFetchNormalTag_cold_98();
      }
      int v105 = TIFFReadDirEntryIfd8Array(a1, (uint64_t)a2, &__s);
LABEL_224:
      int v14 = v105;
      if (v105) {
        goto LABEL_238;
      }
      if ((EvaluateIFDdatasizeReading(a1, (int8x8_t *)a2) & 1) == 0) {
        goto LABEL_248;
      }
      uint64_t v112 = *a2;
      uint64_t v113 = *((void *)a2 + 1);
      int v63 = (char *)__s;
      goto LABEL_227;
    case 0x33:
      TIFFFetchNormalTag_cold_3();
    default:
      TIFFFetchNormalTag_cold_2();
  }
}

uint64_t TIFFReadDirEntryShort(uint64_t a1, int8x8_t *a2, unsigned char *a3, uint8x8_t a4)
{
  if (*(void *)&a2[1] != 1) {
    return 1;
  }
  uint64_t result = 2;
  switch(a2->i16[1])
  {
    case 1:
      uint64_t result = 0;
      LOWORD(v8) = a2[2].u8[0];
      goto LABEL_26;
    case 3:
      *(_WORD *)a3 = a2[2].i16[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabShort(a3);
      }
      return 0;
    case 4:
    case 9:
      unsigned __int32 v7 = a2[2].u32[0];
      __dst.i32[0] = v7;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        unsigned __int32 v7 = __dst.i32[0];
      }
      if (HIWORD(v7)) {
        goto LABEL_24;
      }
      uint64_t result = 0;
LABEL_18:
      *(_WORD *)a3 = v7;
      break;
    case 6:
      unsigned int v8 = a2[2].i8[0];
      if (((v8 >> 5) & 4) != 0) {
        return (v8 >> 5) & 4;
      }
      uint64_t result = 0;
LABEL_26:
      *(_WORD *)a3 = v8;
      return result;
    case 8:
      unsigned __int32 v7 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        unsigned __int32 v7 = __dst.u16[0];
      }
      uint64_t result = (v7 >> 13) & 4;
      if (((v7 >> 13) & 4) == 0) {
        goto LABEL_18;
      }
      return result;
    case 0x10:
      int8x8_t __dst = 0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (!result) {
        goto LABEL_22;
      }
      return result;
    case 0x11:
      int8x8_t __dst = 0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (!result)
      {
LABEL_22:
        if (*(void *)&__dst >> 16)
        {
LABEL_24:
          uint64_t result = 4;
        }
        else
        {
          uint64_t result = 0;
          *(_WORD *)a3 = __dst.i16[0];
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TIFFReadDirEntryPersampleShort(uint64_t a1, uint64_t a2, _WORD *a3)
{
  if (*(void *)(a2 + 8) < (unint64_t)*(unsigned __int16 *)(a1 + 130)) {
    return 1;
  }
  double v12 = 0;
  uint64_t v3 = TIFFReadDirEntryShortArray(a1, a2, (char **)&v12);
  if (!v3)
  {
    __int16 v6 = (char *)v12;
    if (v12)
    {
      int v7 = *(unsigned __int16 *)(a1 + 130);
      int v8 = *(unsigned __int16 *)v12;
      *a3 = v8;
      uint64_t v9 = 2;
      while ((_WORD)--v7)
      {
        int v10 = *(unsigned __int16 *)&v6[v9];
        v9 += 2;
        if (v10 != v8)
        {
          uint64_t v3 = 5;
          goto LABEL_10;
        }
      }
      uint64_t v3 = 0;
LABEL_10:
      _TIFFfreeExt(a1, v6);
    }
  }
  return v3;
}

uint64_t TIFFReadDirEntryOutputErr(uint64_t a1, int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a5)
  {
    switch(a2)
    {
      case 1:
        uint64_t result = TIFFWarningExtR(a1, a3, "Incorrect count for \"%s\"; tag ignored", a4, a5, a6, a7, a8, a4);
        break;
      case 2:
        uint64_t result = TIFFWarningExtR(a1, a3, "Incompatible type for \"%s\"; tag ignored", a4, a5, a6, a7, a8, a4);
        break;
      case 3:
        uint64_t result = TIFFWarningExtR(a1, a3, "IO error during reading of \"%s\"; tag ignored", a4, a5, a6, a7, a8, a4);
        break;
      case 4:
        uint64_t result = TIFFWarningExtR(a1, a3, "Incorrect value for \"%s\"; tag ignored", a4, a5, a6, a7, a8, a4);
        break;
      case 5:
        uint64_t result = TIFFWarningExtR(a1, a3, "Cannot handle different values per sample for \"%s\"; tag ignored",
                   a4,
                   a5,
                   a6,
                   a7,
                   a8,
                   a4);
        break;
      case 6:
        uint64_t result = TIFFWarningExtR(a1, a3, "Sanity check on size of \"%s\" value failed; tag ignored",
                   a4,
                   a5,
                   a6,
                   a7,
                   a8,
                   a4);
        break;
      case 7:
        uint64_t result = TIFFWarningExtR(a1, a3, "Out of memory reading of \"%s\"; tag ignored", a4, a5, a6, a7, a8, a4);
        break;
      default:
        TIFFReadDirEntryOutputErr_cold_2();
    }
  }
  else
  {
    switch(a2)
    {
      case 1:
        uint64_t result = TIFFErrorExtR(a1, a3, "Incorrect count for \"%s\"", a4, a5, a6, a7, a8, a4);
        break;
      case 2:
        uint64_t result = TIFFErrorExtR(a1, a3, "Incompatible type for \"%s\"", a4, a5, a6, a7, a8, a4);
        break;
      case 3:
        uint64_t result = TIFFErrorExtR(a1, a3, "IO error during reading of \"%s\"", a4, a5, a6, a7, a8, a4);
        break;
      case 4:
        uint64_t result = TIFFErrorExtR(a1, a3, "Incorrect value for \"%s\"", a4, a5, a6, a7, a8, a4);
        break;
      case 5:
        uint64_t result = TIFFErrorExtR(a1, a3, "Cannot handle different values per sample for \"%s\"", a4, a5, a6, a7, a8, a4);
        break;
      case 6:
        uint64_t result = TIFFErrorExtR(a1, a3, "Sanity check on size of \"%s\" value failed", a4, a5, a6, a7, a8, a4);
        break;
      case 7:
        uint64_t result = TIFFErrorExtR(a1, a3, "Out of memory reading of \"%s\"", a4, a5, a6, a7, a8, a4);
        break;
      default:
        TIFFReadDirEntryOutputErr_cold_1();
    }
  }
  return result;
}

uint64_t TIFFReadDirectoryFindFieldInfo(uint64_t result, unsigned int a2, int *a3)
{
  int v3 = *(_DWORD *)(result + 1264);
  if (v3)
  {
    uint64_t v4 = *(void *)(result + 1256);
    int v5 = -1;
    while (1)
    {
      uint64_t v6 = (uint64_t)(v3 + v5 + (v3 + v5 < 0)) >> 1;
      unsigned int v7 = **(_DWORD **)(v4 + 8 * ((v3 + v5) / 2));
      if (v7 == a2) {
        break;
      }
      if (v7 >= a2) {
        int v3 = (v3 + v5) / 2;
      }
      else {
        int v5 = (v3 + v5) / 2;
      }
      if (v5 + 1 == v3) {
        goto LABEL_8;
      }
    }
    uint64_t v9 = v4 - 8;
    while (v6)
    {
      int v10 = v6 - 1;
      int v11 = **(_DWORD **)(v9 + 8 * v6--);
      if (v11 != a2)
      {
        int v8 = v10 + 1;
        goto LABEL_14;
      }
    }
    int v8 = 0;
  }
  else
  {
LABEL_8:
    int v8 = -1;
  }
LABEL_14:
  *a3 = v8;
  return result;
}

uint64_t _TIFFFillStriles(uint64_t a1)
{
  return _TIFFFillStrilesInternal(a1, 1);
}

uint64_t EvaluateIFDdatasizeReading(uint64_t a1, int8x8_t *a2)
{
  int v4 = TIFFDataWidth(a2->u16[1]);
  int8x8_t v11 = a2[1];
  if (v4) {
    BOOL v12 = ((unint64_t)v4 * (unsigned __int128)(unint64_t)v11) >> 64 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (!v12) {
    goto LABEL_11;
  }
  unint64_t v13 = *(void *)&v11 * v4;
  int v14 = *(_DWORD *)(a1 + 16);
  unint64_t v15 = 8;
  if ((v14 & 0x80000) == 0) {
    unint64_t v15 = 4;
  }
  if (v13 > v15)
  {
    uint64_t v16 = *(void *)(a1 + 440);
    if (__CFADD__(v13, v16))
    {
LABEL_11:
      TIFFErrorExtR(a1, "EvaluateIFDdatasizeReading", "Too large IFD data size", v5, v6, v7, v8, v9, v23);
      return 0;
    }
    *(void *)(a1 + 440) = v16 + v13;
    if ((v14 & 0x80000) != 0)
    {
      uint64_t v20 = *(void *)(a1 + 456);
      uint64_t v21 = *(unsigned int *)(a1 + 448);
      uint64_t v22 = (int8x8_t *)(v20 + 16 * v21);
      *uint64_t v22 = a2[2];
      if ((v14 & 0x80) != 0)
      {
        TIFFSwabLong8(v22);
        uint64_t v20 = *(void *)(a1 + 456);
        uint64_t v21 = *(unsigned int *)(a1 + 448);
      }
    }
    else
    {
      unsigned __int32 v18 = a2[2].u32[0];
      unsigned __int32 v24 = v18;
      if ((v14 & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&v24, v10);
        unsigned __int32 v18 = v24;
      }
      uint64_t v19 = v18;
      uint64_t v20 = *(void *)(a1 + 456);
      uint64_t v21 = *(unsigned int *)(a1 + 448);
      *(void *)(v20 + 16 * v21) = v19;
    }
    *(void *)(v20 + 16 * v21 + 8) = v13;
    *(_DWORD *)(a1 + 448) = v21 + 1;
  }
  return 1;
}

uint64_t TIFFReadDirEntryDoubleArray(uint64_t a1, uint64_t a2, __int32 **a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a2 + 2);
  BOOL v4 = v3 > 0x11;
  int v5 = (1 << v3) & 0x31F7A;
  if (v4 || v5 == 0) {
    return 2;
  }
  unsigned int v60 = 0;
  uint64_t v59 = 0;
  uint64_t result = TIFFReadDirEntryArrayWithLimit(a1, a2, &v60, 8u, (void **)&v59, 0xFFFFFFFFFFFFFFFFLL);
  if (result || (size_t v17 = (__int32 *)v59) == 0)
  {
    *a3 = 0;
  }
  else if (*(_WORD *)(a2 + 2) == 12)
  {
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabArrayOfLong8(v59, v60);
    }
    uint64_t result = 0;
    *a3 = v17;
  }
  else
  {
    uint64_t v18 = v60;
    uint64_t v19 = (double *)_TIFFmallocExt((void *)a1, 8 * v60, v11, v12, v13, v14, v15, v16);
    if (v19)
    {
      uint64_t v21 = v19;
      switch(*(_WORD *)(a2 + 2))
      {
        case 1:
          if (v18)
          {
            uint64_t v22 = v19;
            char v23 = v17;
            do
            {
              unsigned int v24 = *(unsigned __int8 *)v23;
              char v23 = (__int32 *)((char *)v23 + 1);
              *v22++ = (double)v24;
              LODWORD(v18) = v18 - 1;
            }
            while (v18);
          }
          break;
        case 3:
          if (v18)
          {
            int v25 = v19;
            uint64_t v26 = v17;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                TIFFSwabShort(v26);
              }
              unsigned int v27 = *(unsigned __int16 *)v26;
              uint64_t v26 = (__int32 *)((char *)v26 + 2);
              *v25++ = (double)v27;
              LODWORD(v18) = v18 - 1;
            }
            while (v18);
          }
          break;
        case 4:
          if (v18)
          {
            uint64_t v28 = v19;
            uint64_t v29 = v17;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                TIFFSwabLong(v29, *(uint8x8_t *)&v20);
              }
              unsigned int v30 = *v29++;
              double v20 = (double)v30;
              *v28++ = (double)v30;
              LODWORD(v18) = v18 - 1;
            }
            while (v18);
          }
          break;
        case 5:
          if (v18)
          {
            uint64_t v31 = v19;
            uint64_t v32 = v17;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
              {
                int8x8_t v35 = TIFFSwabLong(v32, *(uint8x8_t *)&v20);
                uint64_t v33 = (unsigned int *)(v32 + 1);
                unsigned int v34 = *v32;
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  TIFFSwabLong(v32 + 1, (uint8x8_t)v35);
                }
              }
              else
              {
                uint64_t v33 = (unsigned int *)(v32 + 1);
                unsigned int v34 = *v32;
              }
              if (*v33) {
                double v20 = (double)v34 / (double)*v33;
              }
              else {
                double v20 = 0.0;
              }
              v32 += 2;
              *v31++ = v20;
              LODWORD(v18) = v18 - 1;
            }
            while (v18);
          }
          break;
        case 6:
          if (v18)
          {
            uint64_t v36 = v19;
            uint64_t v37 = v17;
            do
            {
              int v38 = *(char *)v37;
              uint64_t v37 = (__int32 *)((char *)v37 + 1);
              *v36++ = (double)v38;
              LODWORD(v18) = v18 - 1;
            }
            while (v18);
          }
          break;
        case 8:
          if (v18)
          {
            uint64_t v39 = v19;
            uint64_t v40 = v17;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                TIFFSwabShort(v40);
              }
              int v41 = *(__int16 *)v40;
              uint64_t v40 = (__int32 *)((char *)v40 + 2);
              *v39++ = (double)v41;
              LODWORD(v18) = v18 - 1;
            }
            while (v18);
          }
          break;
        case 9:
          if (v18)
          {
            uint64_t v42 = v19;
            uint64_t v43 = v17;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                TIFFSwabLong(v43, *(uint8x8_t *)&v20);
              }
              int v44 = *v43++;
              double v20 = (double)v44;
              *v42++ = (double)v44;
              LODWORD(v18) = v18 - 1;
            }
            while (v18);
          }
          break;
        case 0xA:
          if (v18)
          {
            int v45 = v19;
            int v46 = v17;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
              {
                int8x8_t v49 = TIFFSwabLong(v46, *(uint8x8_t *)&v20);
                int v47 = (unsigned int *)(v46 + 1);
                int v48 = *v46;
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  TIFFSwabLong(v46 + 1, (uint8x8_t)v49);
                }
              }
              else
              {
                int v47 = (unsigned int *)(v46 + 1);
                int v48 = *v46;
              }
              if (*v47) {
                double v20 = (double)v48 / (double)*v47;
              }
              else {
                double v20 = 0.0;
              }
              v46 += 2;
              *v45++ = v20;
              LODWORD(v18) = v18 - 1;
            }
            while (v18);
          }
          break;
        case 0xB:
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            TIFFSwabArrayOfLong(v17, v18, *(uint8x8_t *)&v20);
          }
          if (v18)
          {
            uint64_t v56 = v21;
            uint64_t v57 = (float *)v17;
            do
            {
              float v58 = *v57++;
              *v56++ = v58;
              LODWORD(v18) = v18 - 1;
            }
            while (v18);
          }
          break;
        case 0x10:
          if (v18)
          {
            int v50 = v19;
            int v51 = (int8x8_t *)v17;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                TIFFSwabLong8(v51);
              }
              unint64_t v52 = (unint64_t)*v51++;
              *v50++ = (double)v52;
              LODWORD(v18) = v18 - 1;
            }
            while (v18);
          }
          break;
        case 0x11:
          if (v18)
          {
            int v53 = v19;
            int v54 = (int8x8_t *)v17;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                TIFFSwabLong8(v54);
              }
              uint64_t v55 = (uint64_t)*v54++;
              *v53++ = (double)v55;
              LODWORD(v18) = v18 - 1;
            }
            while (v18);
          }
          break;
        default:
          break;
      }
      _TIFFfreeExt(a1, (char *)v17);
      uint64_t result = 0;
      *a3 = (__int32 *)v21;
    }
    else
    {
      _TIFFfreeExt(a1, (char *)v17);
      return 7;
    }
  }
  return result;
}

uint64_t TIFFReadDirEntryShortArray(uint64_t a1, uint64_t a2, char **a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a2 + 2);
  BOOL v4 = v3 > 0x11;
  int v5 = (1 << v3) & 0x3035A;
  if (v4 || v5 == 0) {
    return 2;
  }
  unsigned int v49 = 0;
  int v48 = 0;
  uint64_t v16 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v49, 2u, (void **)&v48, 0xFFFFFFFFFFFFFFFFLL);
  if (v16 || (size_t v17 = v48) == 0)
  {
    *a3 = 0;
  }
  else
  {
    int v18 = *(unsigned __int16 *)(a2 + 2);
    if (v18 == 3)
    {
      *a3 = v48;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabArrayOfShort((uint64_t)v17, v49);
      }
      return 0;
    }
    else if (v18 == 8)
    {
      unsigned int v19 = v49;
      if (v49)
      {
        double v20 = v48;
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            TIFFSwabShort(v20);
          }
          int v21 = *(unsigned __int16 *)v20 >> 13;
          if ((v21 & 4) != 0) {
            break;
          }
          v20 += 2;
          if (!--v19) {
            goto LABEL_15;
          }
        }
        uint64_t v16 = v21 & 4;
        uint64_t v30 = a1;
        uint64_t v31 = v17;
LABEL_67:
        _TIFFfreeExt(v30, v31);
        return v16;
      }
LABEL_15:
      uint64_t v16 = 0;
      *a3 = v17;
    }
    else
    {
      unsigned int v22 = v49;
      char v23 = (char *)_TIFFmallocExt((void *)a1, 2 * v49, v10, v11, v12, v13, v14, v15);
      if (v23)
      {
        int v25 = v23;
        int v26 = *(unsigned __int16 *)(a2 + 2);
        switch(*(_WORD *)(a2 + 2))
        {
          case 1:
            if (v22)
            {
              unsigned int v27 = v23;
              uint64_t v28 = v17;
              do
              {
                __int16 v29 = *v28++;
                *(_WORD *)unsigned int v27 = v29;
                v27 += 2;
                --v22;
              }
              while (v22);
            }
            goto LABEL_63;
          case 2:
          case 3:
          case 5:
          case 7:
          case 8:
            goto LABEL_63;
          case 4:
            if (!v22) {
              goto LABEL_63;
            }
            int8x8_t v35 = v23;
            uint64_t v36 = (__int32 *)v17;
            while (1)
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                int8x8_t v24 = TIFFSwabLong(v36, (uint8x8_t)v24);
              }
              __int32 v37 = *v36;
              if (HIWORD(*v36)) {
                goto LABEL_64;
              }
              ++v36;
              *(_WORD *)int8x8_t v35 = v37;
              v35 += 2;
              if (!--v22) {
                goto LABEL_63;
              }
            }
          case 6:
            if (!v22) {
              goto LABEL_63;
            }
            int v38 = v23;
            uint64_t v39 = v17;
            while (1)
            {
              unsigned int v40 = *v39;
              if (((v40 >> 5) & 4) != 0) {
                break;
              }
              ++v39;
              *(_WORD *)int v38 = v40;
              v38 += 2;
              if (!--v22) {
                goto LABEL_63;
              }
            }
            uint64_t v16 = (v40 >> 5) & 4;
            goto LABEL_66;
          case 9:
            if (!v22) {
              goto LABEL_63;
            }
            int v41 = v23;
            uint64_t v42 = (__int32 *)v17;
            break;
          default:
            if (v26 == 16)
            {
              if (!v22) {
                goto LABEL_63;
              }
              int v44 = v23;
              int v45 = (int8x8_t *)v17;
              while (1)
              {
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  TIFFSwabLong8(v45);
                }
                int8x8_t v46 = *v45;
                if (*(unint64_t *)v45 >> 16) {
                  break;
                }
                ++v45;
                *(_WORD *)int v44 = v46.i16[0];
                v44 += 2;
                if (!--v22) {
                  goto LABEL_63;
                }
              }
            }
            else
            {
              if (v26 != 17 || !v22) {
                goto LABEL_63;
              }
              uint64_t v32 = v23;
              uint64_t v33 = (int8x8_t *)v17;
              while (1)
              {
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  TIFFSwabLong8(v33);
                }
                int8x8_t v34 = *v33;
                if (*(unint64_t *)v33 >> 16) {
                  break;
                }
                ++v33;
                *(_WORD *)uint64_t v32 = v34.i16[0];
                v32 += 2;
                if (!--v22) {
                  goto LABEL_63;
                }
              }
            }
            goto LABEL_64;
        }
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            int8x8_t v24 = TIFFSwabLong(v42, (uint8x8_t)v24);
          }
          __int32 v43 = *v42;
          if (HIWORD(*v42)) {
            break;
          }
          ++v42;
          *(_WORD *)int v41 = v43;
          v41 += 2;
          if (!--v22)
          {
LABEL_63:
            _TIFFfreeExt(a1, v17);
            uint64_t v16 = 0;
            *a3 = v25;
            return v16;
          }
        }
LABEL_64:
        uint64_t v16 = 4;
LABEL_66:
        _TIFFfreeExt(a1, v17);
        uint64_t v30 = a1;
        uint64_t v31 = v25;
        goto LABEL_67;
      }
      _TIFFfreeExt(a1, v17);
      return 7;
    }
  }
  return v16;
}

void CalcFinalIFDdatasizeReading(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 12))
  {
    qsort(*(void **)(a1 + 456), *(unsigned int *)(a1 + 448), 0x10uLL, (int (__cdecl *)(const void *, const void *))cmpTIFFEntryOffsetAndLength);
    int v4 = *(_DWORD *)(a1 + 16);
    unsigned int v5 = 20;
    if ((v4 & 0x80000) == 0) {
      unsigned int v5 = 12;
    }
    uint64_t v6 = 6;
    if ((v4 & 0x80000) != 0) {
      uint64_t v6 = 16;
    }
    unint64_t v7 = v6 + v5 * (unint64_t)a2 + *(void *)(a1 + 24);
    uint64_t v8 = *(unsigned int *)(a1 + 448);
    if (v8)
    {
      uint64_t v9 = 0;
      uint64_t v10 = (uint64_t *)(*(void *)(a1 + 456) + 8);
      do
      {
        uint64_t v11 = *(v10 - 1);
        if (v11 == v7)
        {
          uint64_t v12 = *v10;
          uint64_t v13 = *v10;
        }
        else
        {
          if (v11 != v7 + 1) {
            break;
          }
          uint64_t v12 = *v10;
          uint64_t v13 = *v10 + 1;
        }
        v10 += 2;
        v9 += v13;
        v7 += v12;
        --v8;
      }
      while (v8);
    }
    else
    {
      uint64_t v9 = 0;
    }
    uint64_t v14 = *(void *)(a1 + 32);
    if (v14)
    {
      if (v14 == v7 + 1) {
        ++v9;
      }
    }
    else
    {
      if ((*(uint64_t (**)(void, void, uint64_t))(a1 + 1224))(*(void *)(a1 + 1200), 0, 2) == v7)
      {
        uint64_t v15 = -1;
LABEL_25:
        *(void *)(a1 + 440) = v15;
        return;
      }
      int v4 = *(_DWORD *)(a1 + 16);
    }
    if ((v4 & 0x80000) != 0) {
      uint64_t v15 = v9 + 20 * a2 + 16;
    }
    else {
      uint64_t v15 = v9 + 12 * a2 + 6;
    }
    goto LABEL_25;
  }
}

uint64_t TIFFFetchStripThing(uint64_t a1, unsigned __int16 *a2, unsigned int a3, void *a4)
{
  __vImage_Buffer src = 0;
  unint64_t v8 = a3;
  int v9 = TIFFReadDirEntryLong8ArrayWithLimit(a1, (uint64_t)a2, (int8x8_t **)&__src, a3);
  if (v9)
  {
    int v10 = v9;
    uint64_t v11 = TIFFFieldWithTag((void *)a1, *a2);
    if (v11) {
      uint64_t v15 = (const char *)*((void *)v11 + 4);
    }
    else {
      uint64_t v15 = "unknown tagname";
    }
    TIFFReadDirEntryOutputErr(a1, v10, "TIFFFetchStripThing", (uint64_t)v15, 0, v12, v13, v14);
    return 0;
  }
  if (*((void *)a2 + 1) >= v8)
  {
    int8x8_t v24 = (char *)__src;
    goto LABEL_12;
  }
  uint64_t v16 = TIFFFieldWithTag((void *)a1, *a2);
  size_t v17 = getenv("LIBTIFF_STRILE_ARRAY_MAX_RESIZE_COUNT");
  if (!v17)
  {
    unsigned int v21 = 1000000;
    if (v16) {
      goto LABEL_7;
    }
LABEL_15:
    unsigned int v22 = "unknown tagname";
    goto LABEL_16;
  }
  unsigned int v21 = atoi(v17);
  if (!v16) {
    goto LABEL_15;
  }
LABEL_7:
  unsigned int v22 = (const char *)*((void *)v16 + 4);
LABEL_16:
  TIFFReadDirEntryOutputErr(a1, 1, "TIFFFetchStripThing", (uint64_t)v22, v21 >= a3, v18, v19, v20);
  if (v21 < a3)
  {
LABEL_24:
    _TIFFfreeExt(a1, (char *)__src);
    return 0;
  }
  if (a3 > 0xC80000 && 8 * v8 > (*(uint64_t (**)(void))(a1 + 1240))(*(void *)(a1 + 1200)))
  {
    TIFFWarningExtR(a1, "TIFFFetchStripThing", "Requested memory size for StripArray of %llu is greater than filesize %llu. Memory not allocated", v29, v25, v26, v27, v28, 8 * v8);
    goto LABEL_24;
  }
  uint64_t v30 = (char *)_TIFFCheckMalloc((const char **)a1, v8, 8, (uint64_t)"for strip array", v25, v26, v27, v28);
  if (!v30) {
    goto LABEL_24;
  }
  int8x8_t v24 = v30;
  uint64_t v31 = *((void *)a2 + 1);
  uint64_t v32 = (char *)__src;
  if (v31)
  {
    _TIFFmemcpy(v30, __src, 8 * *((void *)a2 + 1));
    uint64_t v31 = *((unsigned int *)a2 + 2);
  }
  _TIFFmemset(&v24[8 * v31], 0, 8 * (a3 - v31));
  _TIFFfreeExt(a1, v32);
LABEL_12:
  *a4 = v24;
  return 1;
}

uint64_t _TIFFGetMaxColorChannels(unsigned int a1)
{
  if (a1 > 0xA)
  {
LABEL_6:
    if (a1 != 32845) {
      return 0;
    }
    return 3;
  }
  uint64_t v1 = 1;
  if (((1 << a1) & 0x744) != 0) {
    return 3;
  }
  if (((1 << a1) & 0xB) == 0)
  {
    if (((1 << a1) & 0x30) != 0) {
      return 4;
    }
    goto LABEL_6;
  }
  return v1;
}

uint64_t EstimateStripByteCounts(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (!_TIFFFillStrilesInternal(a1, 0)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = *(unsigned int *)(a1 + 228);
  if (v10 <= 0xC80000)
  {
    unint64_t v13 = 0;
  }
  else
  {
    unint64_t v11 = 8 * v10;
    unint64_t v13 = (*(uint64_t (**)(void))(a1 + 1240))(*(void *)(a1 + 1200));
    if (v11 > v13)
    {
      TIFFWarningExtR(a1, "EstimateStripByteCounts", "Requested memory size for StripByteCounts of %llu is greater than filesize %llu. Memory not allocated", v12, v6, v7, v8, v9, v11);
      return 0xFFFFFFFFLL;
    }
  }
  uint64_t v14 = *(char **)(a1 + 240);
  if (v14) {
    _TIFFfreeExt(a1, v14);
  }
  uint64_t v15 = _TIFFCheckMalloc((const char **)a1, *(unsigned int *)(a1 + 228), 8, (uint64_t)"for \"StripByteCounts\" array", v6, v7, v8, v9);
  *(void *)(a1 + 240) = v15;
  if (!v15) {
    return 0xFFFFFFFFLL;
  }
  int v23 = *(_DWORD *)(a1 + 16);
  if (*(_WORD *)(a1 + 120) == 1)
  {
    if ((v23 & 0x400) != 0)
    {
      unint64_t v46 = _cg_TIFFTileSize64(a1, v16, v17, v18, v19, v20, v21, v22);
      uint64_t v47 = *(unsigned int *)(a1 + 228);
      if (v47)
      {
        int v48 = *(unint64_t **)(a1 + 240);
        do
        {
          *v48++ = v46;
          --v47;
        }
        while (v47);
      }
    }
    else
    {
      unint64_t v24 = _cg_TIFFScanlineSize64(a1, v16, v17, v18, v19, v20, v21, v22);
      uint64_t v25 = *(unsigned int *)(a1 + 228);
      if (v25)
      {
        uint64_t v26 = 0;
        BOOL v27 = !is_mul_ok(v24, (*(_DWORD *)(a1 + 92) / *(_DWORD *)(a1 + 224)));
        unint64_t v28 = v24 * (*(_DWORD *)(a1 + 92) / *(_DWORD *)(a1 + 224));
        uint64_t v29 = 8 * v25;
        while (!v27)
        {
          *(void *)(*(void *)(a1 + 240) + v2jp2_colour_converter::clear(this + 6) = v28;
          v26 += 8;
          if (v29 == v26) {
            goto LABEL_53;
          }
        }
        return 0xFFFFFFFFLL;
      }
    }
  }
  else
  {
    if ((v23 & 0x80000) != 0) {
      unint64_t v30 = 20 * a3 + 32;
    }
    else {
      unint64_t v30 = 12 * a3 + 14;
    }
    if (a3)
    {
      uint64_t v31 = (unint64_t *)(a2 + 8);
      while (1)
      {
        unsigned int v32 = TIFFDataWidth(*((unsigned __int16 *)v31 - 3));
        if (!v32) {
          break;
        }
        if (!is_mul_ok(v32, *v31)) {
          return 0xFFFFFFFFLL;
        }
        unint64_t v38 = *v31 * v32;
        if (v38 >= 9) {
          unint64_t v39 = *v31 * v32;
        }
        else {
          unint64_t v39 = 0;
        }
        if (v38 < 5) {
          unint64_t v38 = 0;
        }
        if ((*(unsigned char *)(a1 + 18) & 8) != 0) {
          unint64_t v38 = v39;
        }
        if (__CFADD__(v38, v30)) {
          return 0xFFFFFFFFLL;
        }
        v30 += v38;
        --a3;
        v31 += 4;
        if (!(_WORD)a3) {
          goto LABEL_32;
        }
      }
      TIFFErrorExtR(a1, "EstimateStripByteCounts", "Cannot determine size of unknown tag type %hu", v33, v34, v35, v36, v37, *((_WORD *)v31 - 3));
      return 0xFFFFFFFFLL;
    }
LABEL_32:
    if (!v13) {
      unint64_t v13 = (*(uint64_t (**)(void))(a1 + 1240))(*(void *)(a1 + 1200));
    }
    if (v13 >= v30) {
      unint64_t v40 = v30;
    }
    else {
      unint64_t v40 = 0;
    }
    unint64_t v41 = v13 - v40;
    if (*(_WORD *)(a1 + 170) == 2) {
      v41 /= *(unsigned __int16 *)(a1 + 130);
    }
    uint64_t v42 = *(unsigned int *)(a1 + 228);
    uint64_t v43 = *(void *)(a1 + 240);
    if (v42)
    {
      for (uint64_t i = 0; i != v42; ++i)
        *(void *)(v43 + 8 * i) = v41;
      uint64_t v45 = i - 1;
    }
    else
    {
      uint64_t v45 = 0xFFFFFFFFLL;
    }
    unint64_t v49 = *(void *)(*(void *)(a1 + 232) + 8 * v45);
    uint64_t v50 = *(void *)(v43 + 8 * v45);
    if (__CFADD__(v50, v49)) {
      return 0xFFFFFFFFLL;
    }
    if (v50 + v49 > v13)
    {
      BOOL v51 = v13 >= v49;
      unint64_t v52 = v13 - v49;
      if (!v51) {
        unint64_t v52 = 0;
      }
      *(void *)(v43 + 8 * v45) = v52;
    }
  }
LABEL_53:
  int v53 = *(_DWORD *)(a1 + 72);
  *(_DWORD *)(a1 + 72) = v53 | 0x1000000;
  if ((v53 & 0x20000) == 0) {
    *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 92);
  }
  return 1;
}

uint64_t ByteCountLooksBad(uint64_t a1)
{
  unint64_t v2 = _TIFFGetStrileOffsetOrByteCountValue(a1, 0);
  uint64_t result = _TIFFGetStrileOffsetOrByteCountValue(a1, 0);
  if (result)
  {
    if (v2)
    {
      if (*(_WORD *)(a1 + 120) != 1) {
        return 0;
      }
      unint64_t v4 = result;
      unint64_t v5 = (*(uint64_t (**)(void))(a1 + 1240))(*(void *)(a1 + 1200));
      if (v5 < v4 || v2 <= v5 - v4)
      {
        if (!*(_DWORD *)(a1 + 12))
        {
          unint64_t v14 = _cg_TIFFScanlineSize64(a1, v6, v7, v8, v9, v10, v11, v12);
          uint64_t v15 = *(unsigned int *)(a1 + 92);
          if (v15)
          {
            unint64_t v16 = v14;
            uint64_t v17 = (*(unsigned int *)(a1 + 92) * (unsigned __int128)v14) >> 64;
            uint64_t result = 1;
            if (v17 || v2 < v16 * v15) {
              return result;
            }
          }
        }
        return 0;
      }
    }
    return 1;
  }
  return result;
}

uint64_t TIFFGetStrileByteCount(uint64_t a1, uint64_t a2)
{
  return _TIFFGetStrileOffsetOrByteCountValue(a1, a2);
}

void ChopUpSingleUncompressedStrip(uint64_t a1)
{
  if (_TIFFGetStrileOffsetOrByteCountValue(a1, 0) || !*(_DWORD *)(a1 + 12))
  {
    uint64_t v2 = _TIFFGetStrileOffsetOrByteCountValue(a1, 0);
    if (*(_WORD *)(a1 + 170) != 1) {
      ChopUpSingleUncompressedStrip_cold_1();
    }
    unint64_t v9 = v2;
    if (*(_WORD *)(a1 + 122) != 6 || (*(unsigned char *)(a1 + 17) & 0x40) != 0) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = *(unsigned __int16 *)(a1 + 338);
    }
    unint64_t v11 = TIFFVTileSize64(a1, v10, v3, v4, v5, v6, v7, v8);
    unint64_t v12 = v11;
    if (v11 <= 0x2000)
    {
      if (!v11) {
        return;
      }
      uint64_t v13 = 0x2000u / (unsigned __int16)v11;
      uint64_t v10 = (v10 * v13);
      unint64_t v12 = v11 * v13;
    }
    if (v10)
    {
      if (v10 < *(_DWORD *)(a1 + 132))
      {
        unsigned int v14 = *(_DWORD *)(a1 + 92);
        if (v14 < -(int)v10)
        {
          unsigned int v15 = v10 + v14 - 1;
          if (v10 <= v15)
          {
            unsigned int v16 = v15 / v10;
            BOOL v17 = v15 / v10 >= 0xF4241 && *(_DWORD *)(a1 + 12) == 0;
            if (!v17
              || v9 < (*(uint64_t (**)(void))(a1 + 1240))(*(void *)(a1 + 1200))
              && v12 <= ((*(uint64_t (**)(void))(a1 + 1240))(*(void *)(a1 + 1200)) - v9) / (v16 - 1))
            {
              allocChoppedUpStripArrays(a1, v16, v12, v10);
            }
          }
        }
      }
    }
  }
}

void TryChopUpUncompressedBigTiff(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v9 = _cg_TIFFStripSize64(a1, a2, a3, a4, a5, a6, a7, a8);
  if (*(_WORD *)(a1 + 170) != 1) {
    TryChopUpUncompressedBigTiff_cold_5();
  }
  if (*(_WORD *)(a1 + 120) != 1) {
    TryChopUpUncompressedBigTiff_cold_4();
  }
  if ((*(_DWORD *)(a1 + 16) & 0x8400) != 0x8000) {
    TryChopUpUncompressedBigTiff_cold_3();
  }
  unint64_t v10 = v9;
  if (!(v9 >> 31)) {
    TryChopUpUncompressedBigTiff_cold_1();
  }
  if (_TIFFGetStrileOffsetOrByteCountValue(a1, 0) || !*(_DWORD *)(a1 + 12))
  {
    uint64_t v17 = *(_WORD *)(a1 + 122) != 6 || (*(unsigned char *)(a1 + 17) & 0x40) != 0 ? 1 : *(unsigned __int16 *)(a1 + 338);
    int v41 = v17;
    unint64_t v42 = TIFFVStripSize64(a1, v17, v11, v12, v13, v14, v15, v16);
    if (v42 - 0x80000000 >= 0xFFFFFFFF80000001)
    {
      unsigned int v18 = *(_DWORD *)(a1 + 228);
      if (v18)
      {
        uint64_t v19 = 0;
        do
        {
          unsigned int v20 = v18 - 1;
          unint64_t v21 = _TIFFGetStrileOffsetOrByteCountValue(a1, v19);
          if (v19 == v20)
          {
            if (v21 < TIFFVStripSize64(a1, (*(_DWORD *)(a1 + 92) - *(_DWORD *)(a1 + 132) * v19), v22, v23, v24, v25, v26, v27))return; {
          }
            }
          else
          {
            if (v21 != v10) {
              return;
            }
            if (v19)
            {
              uint64_t v28 = _TIFFGetStrileOffsetOrByteCountValue(a1, v19);
              uint64_t v29 = _TIFFGetStrileOffsetOrByteCountValue(a1, (v19 - 1));
              if (v28 != _TIFFGetStrileOffsetOrByteCountValue(a1, (v19 - 1)) + v29) {
                return;
              }
            }
          }
          uint64_t v19 = (v19 + 1);
          unsigned int v18 = *(_DWORD *)(a1 + 228);
        }
        while (v19 < v18);
        uint64_t v30 = v18 - 1;
      }
      else
      {
        uint64_t v30 = 0xFFFFFFFFLL;
      }
      unint64_t v31 = 0x20000000 / v42;
      if ((0x20000000 / v42) <= 1) {
        unint64_t v31 = 1;
      }
      else {
        unint64_t v31 = v31;
      }
      unint64_t v32 = v42 * v31;
      if ((v42 * v31) >> 31) {
        TryChopUpUncompressedBigTiff_cold_2();
      }
      uint64_t v33 = (v31 * v41);
      if (v33)
      {
        unsigned int v34 = *(_DWORD *)(a1 + 92);
        if (v34 < -(int)v33)
        {
          unsigned int v35 = v33 + v34 - 1;
          if (v33 <= v35)
          {
            unsigned int v36 = v35 / v33;
            BOOL v37 = v35 / v33 >= 0xF4241 && *(_DWORD *)(a1 + 12) == 0;
            if (!v37
              || (unint64_t v38 = _TIFFGetStrileOffsetOrByteCountValue(a1, v30),
                  unint64_t v39 = (*(uint64_t (**)(void))(a1 + 1240))(*(void *)(a1 + 1200)),
                  unint64_t v40 = _TIFFGetStrileOffsetOrByteCountValue(a1, (*(_DWORD *)(a1 + 228) - 1)),
                  v39 >= v38)
              && v40 <= v39 - v38)
            {
              allocChoppedUpStripArrays(a1, v36, v32, v33);
            }
          }
        }
      }
    }
  }
}

uint64_t hashFuncOffsetToNumber(void *a1)
{
  return *a1 ^ HIDWORD(*a1);
}

BOOL equalFuncOffsetToNumber(void *a1, void *a2)
{
  return *a1 == *a2;
}

uint64_t hashFuncNumberToOffset(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

BOOL equalFuncNumberToOffset(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 8) == *(_DWORD *)(a2 + 8);
}

uint64_t _TIFFGetOffsetFromDirNumber(uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t result = *(void *)(a1 + 56);
  if (result)
  {
    v5[0] = 0;
    v5[1] = a2;
    uint64_t result = (uint64_t)TIFFHashSetLookup(result, (uint64_t)v5);
    if (result)
    {
      *a3 = *(void *)result;
      return 1;
    }
  }
  return result;
}

uint64_t _TIFFRemoveEntryFromDirectoryListByOffset(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 48);
  if (v3)
  {
    uint64_t v14 = a2;
    uint64_t v15 = 0;
    uint64_t v4 = TIFFHashSetLookup(v3, (uint64_t)&v14);
    if (v4)
    {
      uint64_t v10 = (uint64_t)v4;
      LODWORD(v15) = *((_DWORD *)v4 + 2);
      uint64_t v11 = *(void *)(a1 + 56);
      if (!v11)
      {
        TIFFErrorExtR(a1, "_TIFFRemoveEntryFromDirectoryListByOffset", "Unexpectedly tif_map_dir_number_to_offset is missing but tif_map_dir_offset_to_number exists.", v5, v6, v7, v8, v9, v14);
        return 0;
      }
      uint64_t v12 = TIFFHashSetLookup(v11, (uint64_t)&v14);
      if (v12)
      {
        TIFFHashSetRemove(*(void *)(a1 + 56), (uint64_t)v12);
        TIFFHashSetRemove(*(void *)(a1 + 48), v10);
      }
    }
  }
  return 1;
}

uint64_t TIFFGetStrileOffset(uint64_t a1, uint64_t a2)
{
  return _TIFFGetStrileOffsetOrByteCountValue(a1, a2);
}

uint64_t TIFFGetStrileOffsetWithErr(uint64_t a1, uint64_t a2)
{
  return _TIFFGetStrileOffsetOrByteCountValue(a1, a2);
}

uint64_t _TIFFGetStrileOffsetOrByteCountValue(uint64_t a1, uint64_t a2)
{
  v10.n128_f64[0] = MEMORY[0x1F4188790](a1, a2);
  uint64_t v11 = v6;
  uint64_t v12 = (uint64_t *)v5;
  uint64_t v13 = (int8x8_t *)v4;
  unsigned int v14 = v3;
  uint64_t v15 = v2;
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  if (v6) {
    *uint64_t v6 = 0;
  }
  int v16 = *(_DWORD *)(v2 + 16);
  if ((v16 & 0x5000000) != 0x1000000) {
    goto LABEL_9;
  }
  if ((v16 & 0x2000000) == 0 || (unint64_t v17 = *(void *)(v4 + 8), v17 <= 4))
  {
    int v18 = _TIFFFillStrilesInternal(v2, 1);
    if (v11 && !v18) {
      _DWORD *v11 = 1;
    }
    goto LABEL_9;
  }
  if (v17 <= v3) {
    goto LABEL_65;
  }
  uint64_t v20 = *(unsigned int *)(v2 + 248);
  if (v20 <= v3)
  {
    int v21 = *(_DWORD *)(v2 + 248);
    if (v3 >= 0xF4241)
    {
      if (v3 > (unint64_t)(*(uint64_t (**)(void, __n128))(v2 + 1240))(*(void *)(v2 + 1200), v10) >> 2)
      {
        TIFFErrorExtR(v15, "_TIFFFetchStrileValue", "File too short", v5, (uint64_t)v6, v7, v8, v9, v65);
        goto LABEL_65;
      }
      int v21 = *(_DWORD *)(v15 + 248);
    }
    unsigned int v22 = *(_DWORD *)(v15 + 228);
    if (v21 || v22 >= 0x100000)
    {
      unsigned int v23 = v14 + 1 > 0x80000 ? v14 + 1 : 0x80000;
      unsigned int v24 = v23 << (v23 < 0x7FFFFFFF);
      if (v24 < v22) {
        unsigned int v22 = v24;
      }
    }
    if (v22 <= v14) {
      _TIFFGetStrileOffsetOrByteCountValue_cold_2();
    }
    uint64_t v25 = _TIFFreallocExt((void *)v15, *(char **)(v15 + 232), 8 * v22, v5, (uint64_t)v6, v7, v8, v9);
    unint64_t v31 = _TIFFreallocExt((void *)v15, *(char **)(v15 + 240), 8 * v22, v26, v27, v28, v29, v30);
    if (v25)
    {
      *(void *)(v15 + 232) = v25;
      if (v31)
      {
        *(void *)(v15 + 240) = v31;
        *(_DWORD *)(v15 + 248) = v22;
        memset(&v25[v20], 255, 8 * (v22 - v20));
        memset((void *)(*(void *)(v15 + 240) + 8 * v20), 255, 8 * (*(_DWORD *)(v15 + 248) - v20));
        goto LABEL_32;
      }
    }
    else if (v31)
    {
      *(void *)(v15 + 240) = v31;
    }
    TIFFErrorExtR(v15, "_TIFFFetchStrileValue", "Cannot allocate strip offset and bytecount arrays", v32, v33, v34, v35, v36, v65);
    _TIFFfreeExt(v15, *(char **)(v15 + 232));
    *(void *)(v15 + 232) = 0;
    _TIFFfreeExt(v15, *(char **)(v15 + 240));
    *(void *)(v15 + 240) = 0;
    *(_DWORD *)(v15 + 248) = 0;
  }
LABEL_32:
  uint64_t v37 = *v12;
  if (!*v12) {
    goto LABEL_65;
  }
  unsigned int v38 = *(_DWORD *)(v15 + 248);
  if (v38 <= v14) {
    goto LABEL_65;
  }
  if (*(void *)(v37 + 8 * v14) != -1) {
    goto LABEL_9;
  }
  if (*(void *)&v13[1] <= 4uLL) {
    _TIFFGetStrileOffsetOrByteCountValue_cold_1();
  }
  int v39 = *(_DWORD *)(v15 + 16);
  unsigned int v40 = v13->u16[1];
  if (v40 > 0xF)
  {
    if (v40 != 16 && v40 != 17) {
      goto LABEL_60;
    }
    uint64_t v41 = 8;
  }
  else
  {
    if (v40 != 3)
    {
      if (v40 == 4)
      {
        uint64_t v41 = 4;
        goto LABEL_44;
      }
LABEL_60:
      int v54 = "Invalid type for [Strip|Tile][Offset/ByteCount] tag";
LABEL_62:
      TIFFErrorExtR(v15, "_TIFFPartialReadStripArray", v54, v5, (uint64_t)v6, v7, v8, v9, v65);
      *(void *)(v37 + 8 * (int)v14) = 0;
      goto LABEL_64;
    }
    uint64_t v41 = 2;
  }
LABEL_44:
  uint64_t v70 = v41;
  bzero(v72, 0x2000uLL);
  if ((v39 & 0x80000) == 0)
  {
    unsigned __int32 v43 = v13[2].u32[0];
    v71.i32[0] = v43;
    if ((v39 & 0x80) != 0)
    {
      TIFFSwabLong((__int32 *)&v71, v42);
      unsigned __int32 v43 = v71.i32[0];
    }
    int8x8_t v44 = (int8x8_t)v43;
    goto LABEL_51;
  }
  int8x8_t v44 = v13[2];
  int8x8_t v71 = v44;
  if ((v39 & 0x80) != 0)
  {
    TIFFSwabLong8(&v71);
    int8x8_t v44 = v71;
  }
  if ((*(void *)&v44 & 0x8000000000000000) != 0)
  {
    char v65 = v14;
    int v54 = "Cannot read offset/size for strile %d";
    goto LABEL_62;
  }
LABEL_51:
  char v69 = v39;
  uint64_t v45 = *(void *)&v44 + (int)v70 * (uint64_t)(int)v14;
  unint64_t v46 = v45 & 0xFFFFFFFFFFFFF000;
  unint64_t v47 = (v45 & 0xFFFFFFFFFFFFF000) + 4096;
  if (v45 + v70 > v47) {
    unint64_t v47 = (v45 & 0xFFFFFFFFFFFFF000) + 0x2000;
  }
  if (*(void *)&v44 + v70 * (unint64_t)v38 < v47) {
    unint64_t v47 = *(void *)&v44 + v70 * (unint64_t)v38;
  }
  if (v47 <= v46)
  {
    TIFFErrorExtR(v15, "_TIFFPartialReadStripArray", "Cannot read offset/size for strile %d", v5, (uint64_t)v6, v7, v8, v9, v14);
    *(void *)(v37 + 8 * (int)v14) = 0;
    goto LABEL_64;
  }
  uint64_t v66 = v47 - v46;
  unint64_t v68 = v47;
  if (!_TIFFSeekOK(v15, v46))
  {
    *(void *)(v37 + 8 * (int)v14) = 0;
    goto LABEL_64;
  }
  if ((*(uint64_t (**)(void, unsigned char *, uint64_t))(v15 + 1208))(*(void *)(v15 + 1200), v72, v66) < v66)
  {
    TIFFErrorExtR(v15, "_TIFFPartialReadStripArray", "Cannot read offset/size for strile around ~%d", v48, v49, v50, v51, v52, v14);
LABEL_64:
    *(void *)(*v12 + 8 * v14) = 0;
    goto LABEL_65;
  }
  uint64_t v55 = v45 & 0xFFF;
  unsigned int v56 = ((unsigned __int16)v45 & 0xFFFu) / v70;
  if ((int)(v14 - v56) < 0) {
    unsigned int v56 = v14;
  }
  unsigned int v57 = v14 - v56;
  unint64_t v58 = v68;
  if (v14 - v56 < v38)
  {
    uint64_t v59 = 0;
    int v60 = -v56;
    uint64_t v61 = *(void *)&v44 + v70 + v70 * ((int)v14 + (uint64_t)v60);
    uint64_t v62 = &v72[v55 + (int)v70 * (uint64_t)v60];
    uint64_t v67 = v61;
    do
    {
      if (v61 + v59 > v58) {
        break;
      }
      int v63 = v13->u16[1];
      if (v63 == 16) {
        goto LABEL_78;
      }
      if (v63 == 4)
      {
        int8x8_t v64 = (int8x8_t)*(unsigned int *)&v62[v59];
        v71.i32[0] = *(_DWORD *)&v62[v59];
        if (v69 < 0)
        {
          int8x8_t v53 = TIFFSwabLong((__int32 *)&v71, (uint8x8_t)v53);
          uint64_t v61 = v67;
          unint64_t v58 = v68;
          int8x8_t v64 = (int8x8_t)v71.u32[0];
        }
        goto LABEL_82;
      }
      if (v63 != 3)
      {
LABEL_78:
        int8x8_t v64 = *(int8x8_t *)&v62[v59];
        int8x8_t v71 = v64;
        if (v69 < 0)
        {
          int8x8_t v53 = TIFFSwabLong8(&v71);
          uint64_t v61 = v67;
          unint64_t v58 = v68;
          int8x8_t v64 = v71;
        }
      }
      else
      {
        int8x8_t v64 = (int8x8_t)*(unsigned __int16 *)&v62[v59];
        v71.i16[0] = *(_WORD *)&v62[v59];
        if (v69 < 0)
        {
          TIFFSwabShort(&v71);
          uint64_t v61 = v67;
          unint64_t v58 = v68;
          int8x8_t v64 = (int8x8_t)v71.u16[0];
        }
      }
LABEL_82:
      *(int8x8_t *)(v37 + 8 * (int)v57) = v64;
      v59 += v70;
      ++v57;
    }
    while (v57 < v38);
  }
LABEL_9:
  if (*v12 && *(_DWORD *)(v15 + 228) > v14) {
    return *(void *)(*v12 + 8 * v14);
  }
LABEL_65:
  uint64_t result = 0;
  if (v11) {
    _DWORD *v11 = 1;
  }
  return result;
}

uint64_t TIFFGetStrileByteCountWithErr(uint64_t a1, uint64_t a2)
{
  return _TIFFGetStrileOffsetOrByteCountValue(a1, a2);
}

uint64_t _TIFFFillStrilesInternal(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 16);
  if ((v2 & 0x5000000) != 0x1000000) {
    return 1;
  }
  uint64_t v6 = a1 + 232;
  uint64_t v5 = *(char **)(a1 + 232);
  if ((v2 & 0x2000000) != 0)
  {
    _TIFFfreeExt(a1, v5);
    _TIFFfreeExt(a1, *(char **)(a1 + 240));
    *(void *)uint64_t v6 = 0;
    *(void *)(v6 + 8) = 0;
    *(_DWORD *)(v6 + 1jp2_colour_converter::clear(this + 6) = 0;
    *(_DWORD *)(a1 + 16) &= ~0x2000000u;
  }
  else if (v5)
  {
    return 1;
  }
  if (!*(void *)(a1 + 264)) {
    return 0;
  }
  uint64_t v7 = TIFFFetchStripThing(a1, (unsigned __int16 *)(a1 + 256), *(_DWORD *)(a1 + 228), (void *)v6);
  if (a2)
  {
    if (TIFFFetchStripThing(a1, (unsigned __int16 *)(a1 + 288), *(_DWORD *)(a1 + 228), (void *)(a1 + 240)))uint64_t v7 = v7; {
    else
    }
      uint64_t v7 = 0;
  }
  _TIFFmemset((void *)(a1 + 256), 0, 0x20uLL);
  _TIFFmemset((void *)(a1 + 288), 0, 0x20uLL);
  return v7;
}

uint64_t TIFFReadDirEntryCheckedLong8(uint64_t a1, int8x8_t *a2, int8x8_t *__dst, uint8x8_t a4)
{
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x80000) != 0)
  {
    *int8x8_t __dst = a2[2];
    if ((v5 & 0x80) == 0) {
      return 0;
    }
LABEL_8:
    TIFFSwabLong8(__dst);
    return 0;
  }
  unsigned __int32 v7 = a2[2].u32[0];
  unsigned __int32 v9 = v7;
  if ((v5 & 0x80) != 0)
  {
    TIFFSwabLong((__int32 *)&v9, a4);
    unsigned __int32 v7 = v9;
  }
  uint64_t result = TIFFReadDirEntryData(a1, v7, 8, __dst);
  if (!result)
  {
    if ((*(_DWORD *)(a1 + 16) & 0x80) == 0) {
      return 0;
    }
    goto LABEL_8;
  }
  return result;
}

uint64_t TIFFReadDirEntryData(uint64_t a1, uint64_t a2, int64_t __n, void *__dst)
{
  if (__n <= 0) {
    TIFFReadDirEntryData_cold_1();
  }
  if ((*(unsigned char *)(a1 + 17) & 8) == 0)
  {
    if (_TIFFSeekOK(a1, a2)
      && (*(uint64_t (**)(void, void *, int64_t))(a1 + 1208))(*(void *)(a1 + 1200), __dst, __n) == __n)
    {
      return 0;
    }
    return 3;
  }
  if (__CFADD__(__n, a2) || (unint64_t)(__n + a2) > *(void *)(a1 + 1176)) {
    return 3;
  }
  _TIFFmemcpy(__dst, (const void *)(*(void *)(a1 + 1168) + a2), __n);
  return 0;
}

uint64_t TIFFReadDirEntryArrayWithLimit(uint64_t a1, uint64_t a2, _DWORD *a3, unsigned int a4, void **a5, unint64_t a6)
{
  unsigned int v12 = TIFFDataWidth(*(unsigned __int16 *)(a2 + 2));
  unint64_t v18 = *(void *)(a2 + 8);
  if (v18 >= a6) {
    unint64_t v19 = a6;
  }
  else {
    unint64_t v19 = *(void *)(a2 + 8);
  }
  if (v19) {
    BOOL v20 = v12 == 0;
  }
  else {
    BOOL v20 = 1;
  }
  if (!v20)
  {
    unsigned int v22 = v12;
    if (v18 >= 0xA) {
      LODWORD(v2++*((_DWORD *)this + 3) = 10;
    }
    else {
      uint64_t v23 = *(void *)(a2 + 8);
    }
    if (v19 > 0x7FFFFFFF / v12 || v19 > 0x7FFFFFFF / a4) {
      return 6;
    }
    *a3 = v19;
    unint64_t v25 = v12 * v19;
    if (!v25) {
      TIFFReadDirEntryArrayWithLimit_cold_1();
    }
    if (v25 >= 0x6400001 && (*(uint64_t (**)(void))(a1 + 1240))(*(void *)(a1 + 1200)) < v25)
    {
      TIFFWarningExtR(a1, "ReadDirEntryArray", "Requested memory size for tag %d (0x%x) %u is greater than filesize %llu. Memory not allocated, tag not read", v26, v13, v14, v15, v16, *(_WORD *)a2);
      return 7;
    }
    int v27 = *(_DWORD *)(a1 + 16);
    if ((v27 & 0x800) != 0)
    {
      if (*(void *)(a1 + 1176) < v25) {
        return 3;
      }
    }
    else
    {
      int v28 = v27 & 0x80000;
      if (v25 >= 9 && v28 || v25 >= 5 && !v28)
      {
        uint64_t v29 = 0;
        uint64_t v35 = 0;
        goto LABEL_31;
      }
    }
    uint64_t v30 = _TIFFCheckMalloc((const char **)a1, *a3, (int)v22, (uint64_t)"ReadDirEntryArray", v13, v14, v15, v16);
    uint64_t v35 = v30;
    if (!v30) {
      return 7;
    }
    uint64_t v29 = v30;
    int v27 = *(_DWORD *)(a1 + 16);
LABEL_31:
    int v31 = v22 * v23;
    if ((v27 & 0x80000) != 0)
    {
      if (v31 > 8 || v25 > 8)
      {
        *(void *)uint64_t v34 = *(void *)(a2 + 16);
        if ((v27 & 0x80) != 0)
        {
          TIFFSwabLong8((int8x8_t *)v34);
          int v27 = *(_DWORD *)(a1 + 16);
        }
        uint64_t v32 = *(void *)v34;
        if ((v27 & 0x800) == 0) {
          goto LABEL_37;
        }
        goto LABEL_45;
      }
    }
    else if (v31 > 4 || v25 > 4)
    {
      v34[0] = *(_DWORD *)(a2 + 16);
      if ((v27 & 0x80) != 0)
      {
        TIFFSwabLong(v34, v17);
        int v27 = *(_DWORD *)(a1 + 16);
      }
      uint64_t v32 = v34[0];
      if ((v27 & 0x800) == 0)
      {
LABEL_37:
        uint64_t v33 = TIFFReadDirEntryDataAndRealloc(a1, v32, v25, (char **)&v35);
        goto LABEL_46;
      }
LABEL_45:
      uint64_t v33 = TIFFReadDirEntryData(a1, v32, v25, v29);
LABEL_46:
      uint64_t v21 = v33;
      if (v33)
      {
        _TIFFfreeExt(a1, (char *)v35);
        return v21;
      }
LABEL_48:
      uint64_t v21 = 0;
      *a5 = v35;
      return v21;
    }
    _TIFFmemcpy(v29, (const void *)(a2 + 16), v25);
    goto LABEL_48;
  }
  uint64_t v21 = 0;
  *a5 = 0;
  return v21;
}

uint64_t TIFFReadDirEntryDataAndRealloc(uint64_t a1, uint64_t a2, uint64_t a3, char **a4)
{
  if ((*(unsigned char *)(a1 + 17) & 8) != 0) {
    TIFFReadDirEntryDataAndRealloc_cold_1();
  }
  if (!_TIFFSeekOK(a1, a2)) {
    return 3;
  }
  uint64_t v12 = 0;
  uint64_t v13 = 0x100000;
  while (1)
  {
    if (a3 <= v12) {
      return 0;
    }
    BOOL v14 = a3 - v12 >= v13;
    BOOL v15 = v13 < 1048576000;
    BOOL v16 = v15 && v14;
    uint64_t v17 = v15 && v14 ? v13 : a3 - v12;
    unint64_t v18 = (char *)_TIFFreallocExt((void *)a1, *a4, v17 + v12, v7, v8, v9, v10, v11);
    if (!v18) {
      break;
    }
    if (v16) {
      v13 *= 10;
    }
    *a4 = v18;
    uint64_t v24 = (*(uint64_t (**)(void, char *, uint64_t))(a1 + 1208))(*(void *)(a1 + 1200), &v18[v12], v17);
    v12 += v24;
    if (v24 != v17) {
      return 3;
    }
  }
  TIFFErrorExtR(a1, *(const char **)a1, "Failed to allocate memory for %s (%lld elements of %lld bytes each)", v19, v20, v21, v22, v23, (char)"TIFFReadDirEntryArray");
  return 7;
}

uint64_t cmpTIFFEntryOffsetAndLength(void *a1, void *a2)
{
  if (*a1 >= *a2) {
    unsigned int v2 = 0;
  }
  else {
    unsigned int v2 = -1;
  }
  if (*a1 > *a2) {
    return 1;
  }
  else {
    return v2;
  }
}

uint64_t TIFFReadDirEntryByteArray(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a2 + 2);
  BOOL v4 = v3 > 0x11;
  int v5 = (1 << v3) & 0x303DE;
  if (v4 || v5 == 0) {
    return 2;
  }
  unsigned int v45 = 0;
  int8x8_t v44 = 0;
  uint64_t v16 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v45, 1u, &v44, 0xFFFFFFFFFFFFFFFFLL);
  if (v16 || (uint64_t v17 = (char *)v44) == 0)
  {
    *a3 = 0;
    return v16;
  }
  int v18 = *(unsigned __int16 *)(a2 + 2);
  if ((v18 - 1) < 2 || v18 == 7) {
    goto LABEL_14;
  }
  if (v18 == 6)
  {
    if (v45)
    {
      uint64_t v19 = 0;
      while (1)
      {
        int v20 = *((unsigned __int8 *)v44 + v19) >> 5;
        if ((v20 & 4) != 0) {
          break;
        }
        if (v45 == ++v19) {
          goto LABEL_14;
        }
      }
      uint64_t v16 = v20 & 4;
      _TIFFfreeExt(a1, (char *)v44);
      return v16;
    }
LABEL_14:
    uint64_t v16 = 0;
    *a3 = v44;
    return v16;
  }
  unsigned int v22 = v45;
  uint64_t v23 = (char *)_TIFFmallocExt((void *)a1, v45, v10, v11, v12, v13, v14, v15);
  if (v23)
  {
    unint64_t v25 = v23;
    switch(*(_WORD *)(a2 + 2))
    {
      case 3:
        if (!v22) {
          goto LABEL_63;
        }
        uint64_t v26 = v23;
        int v27 = v17;
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            TIFFSwabShort(v27);
          }
          unsigned int v28 = *(unsigned __int16 *)v27;
          if (v28 > 0xFF) {
            goto LABEL_64;
          }
          v27 += 2;
          *v26++ = v28;
          if (!--v22) {
            goto LABEL_63;
          }
        }
      case 4:
        if (!v22) {
          goto LABEL_63;
        }
        uint64_t v29 = v23;
        uint64_t v30 = (__int32 *)v17;
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            int8x8_t v24 = TIFFSwabLong(v30, (uint8x8_t)v24);
          }
          __int32 v31 = *v30;
          if (*v30 > 0xFF) {
            goto LABEL_64;
          }
          ++v30;
          *v29++ = v31;
          if (!--v22) {
            goto LABEL_63;
          }
        }
      case 8:
        if (!v22) {
          goto LABEL_63;
        }
        uint64_t v32 = v23;
        uint64_t v33 = v17;
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            TIFFSwabShort(v33);
          }
          unsigned int v34 = *(unsigned __int16 *)v33;
          if (v34 > 0xFF) {
            goto LABEL_64;
          }
          v33 += 2;
          *v32++ = v34;
          if (!--v22) {
            goto LABEL_63;
          }
        }
      case 9:
        if (!v22) {
          goto LABEL_63;
        }
        uint64_t v35 = v23;
        uint64_t v36 = (__int32 *)v17;
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            int8x8_t v24 = TIFFSwabLong(v36, (uint8x8_t)v24);
          }
          __int32 v37 = *v36;
          if (*v36 > 0xFF) {
            goto LABEL_64;
          }
          ++v36;
          *v35++ = v37;
          if (!--v22) {
            goto LABEL_63;
          }
        }
      case 0x10:
        if (!v22) {
          goto LABEL_63;
        }
        unsigned int v38 = v23;
        int v39 = (int8x8_t *)v17;
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            TIFFSwabLong8(v39);
          }
          int8x8_t v40 = *v39;
          if (*(void *)v39 > 0xFFuLL) {
            goto LABEL_64;
          }
          ++v39;
          *v38++ = v40.i8[0];
          if (!--v22) {
            goto LABEL_63;
          }
        }
      case 0x11:
        if (!v22) {
          goto LABEL_63;
        }
        uint64_t v41 = v23;
        uint8x8_t v42 = (int8x8_t *)v17;
        break;
      default:
        goto LABEL_63;
    }
    while (1)
    {
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabLong8(v42);
      }
      int8x8_t v43 = *v42;
      if (*(void *)v42 > 0xFFuLL) {
        break;
      }
      ++v42;
      *v41++ = v43.i8[0];
      if (!--v22)
      {
LABEL_63:
        _TIFFfreeExt(a1, v17);
        uint64_t v16 = 0;
        *a3 = v25;
        return v16;
      }
    }
LABEL_64:
    _TIFFfreeExt(a1, v17);
    _TIFFfreeExt(a1, v25);
    return 4;
  }
  else
  {
    _TIFFfreeExt(a1, v17);
    return 7;
  }
}

uint64_t TIFFReadDirEntryByte(uint64_t a1, int8x8_t *a2, unsigned char *a3, uint8x8_t a4)
{
  if (*(void *)&a2[1] != 1) {
    return 1;
  }
  uint64_t result = 2;
  switch(a2->i16[1])
  {
    case 1:
    case 7:
      uint64_t result = 0;
      LOBYTE(v7) = a2[2].i8[0];
      goto LABEL_4;
    case 3:
    case 8:
      unsigned int v8 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        unsigned int v8 = __dst.u16[0];
      }
      goto LABEL_11;
    case 4:
    case 9:
      unsigned int v8 = a2[2].u32[0];
      __dst.i32[0] = v8;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        unsigned int v8 = __dst.i32[0];
      }
LABEL_11:
      if (v8 > 0xFF) {
        goto LABEL_20;
      }
      uint64_t result = 0;
      *a3 = v8;
      break;
    case 6:
      unsigned int v7 = a2[2].u8[0];
      if (((v7 >> 5) & 4) != 0) {
        return (v7 >> 5) & 4;
      }
      uint64_t result = 0;
LABEL_4:
      *a3 = v7;
      return result;
    case 0x10:
      int8x8_t __dst = 0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (!result) {
        goto LABEL_18;
      }
      return result;
    case 0x11:
      int8x8_t __dst = 0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (!result)
      {
LABEL_18:
        if (*(void *)&__dst > 0xFFuLL)
        {
LABEL_20:
          uint64_t result = 4;
        }
        else
        {
          uint64_t result = 0;
          *a3 = __dst.i8[0];
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TIFFReadDirEntrySbyte(uint64_t a1, int8x8_t *a2, __int8 *a3, uint8x8_t a4)
{
  if (*(void *)&a2[1] != 1) {
    return 1;
  }
  uint64_t result = 2;
  switch(a2->i16[1])
  {
    case 1:
    case 7:
      unsigned int v7 = a2[2].u8[0];
      if (((v7 >> 5) & 4) == 0)
      {
        uint64_t result = 0;
        goto LABEL_14;
      }
      return (v7 >> 5) & 4;
    case 3:
      unsigned int v8 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        unsigned int v8 = __dst.u16[0];
      }
      goto LABEL_11;
    case 4:
      unsigned int v8 = a2[2].u32[0];
      __dst.i32[0] = v8;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        unsigned int v8 = __dst.i32[0];
      }
LABEL_11:
      if (v8 > 0x7F) {
        goto LABEL_25;
      }
      goto LABEL_22;
    case 6:
      uint64_t result = 0;
      LOBYTE(v7) = a2[2].i8[0];
LABEL_14:
      *a3 = v7;
      return result;
    case 8:
      unsigned int v8 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        unsigned int v8 = __dst.u16[0];
      }
      if (v8 != (unsigned __int16)(char)v8) {
        goto LABEL_25;
      }
      goto LABEL_22;
    case 9:
      unsigned int v8 = a2[2].u32[0];
      __dst.i32[0] = v8;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        unsigned int v8 = __dst.i32[0];
      }
      if (v8 != (char)v8) {
        goto LABEL_25;
      }
LABEL_22:
      uint64_t result = 0;
      *a3 = v8;
      return result;
    case 0x10:
      int8x8_t __dst = 0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (result) {
        return result;
      }
      __int8 v9 = __dst.i8[0];
      if (*(void *)&__dst > 0x7FuLL) {
        goto LABEL_25;
      }
      goto LABEL_28;
    case 0x11:
      int8x8_t __dst = 0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (result) {
        return result;
      }
      __int8 v9 = __dst.i8[0];
      if (*(void *)&__dst == __dst.i8[0])
      {
LABEL_28:
        uint64_t result = 0;
        *a3 = v9;
      }
      else
      {
LABEL_25:
        uint64_t result = 4;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TIFFReadDirEntrySshort(uint64_t a1, int8x8_t *a2, unsigned char *a3, uint8x8_t a4)
{
  if (*(void *)&a2[1] != 1) {
    return 1;
  }
  uint64_t result = 2;
  switch(a2->i16[1])
  {
    case 1:
      uint64_t result = 0;
      __int16 v7 = a2[2].u8[0];
      goto LABEL_15;
    case 3:
      unsigned __int32 v8 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        unsigned __int32 v8 = __dst.u16[0];
      }
      uint64_t result = (v8 >> 13) & 4;
      if (((v8 >> 13) & 4) == 0) {
        goto LABEL_23;
      }
      return result;
    case 4:
      unsigned __int32 v8 = a2[2].u32[0];
      __dst.i32[0] = v8;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        unsigned __int32 v8 = __dst.i32[0];
      }
      if (v8 >> 15) {
        goto LABEL_29;
      }
      goto LABEL_22;
    case 6:
      uint64_t result = 0;
      __int16 v7 = a2[2].i8[0];
LABEL_15:
      *(_WORD *)a3 = v7;
      return result;
    case 8:
      *(_WORD *)a3 = a2[2].i16[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabShort(a3);
      }
      return 0;
    case 9:
      unsigned __int32 v8 = a2[2].u32[0];
      __dst.i32[0] = v8;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        unsigned __int32 v8 = __dst.i32[0];
      }
      if (v8 != (__int16)v8) {
        goto LABEL_29;
      }
LABEL_22:
      uint64_t result = 0;
LABEL_23:
      *(_WORD *)a3 = v8;
      return result;
    case 0x10:
      int8x8_t __dst = 0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (result) {
        return result;
      }
      __int16 v9 = __dst.i16[0];
      if (!(*(void *)&__dst >> 15)) {
        goto LABEL_26;
      }
      goto LABEL_29;
    case 0x11:
      int8x8_t __dst = 0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (result) {
        return result;
      }
      __int16 v9 = __dst.i16[0];
      if (*(void *)&__dst == __dst.i16[0])
      {
LABEL_26:
        uint64_t result = 0;
        *(_WORD *)a3 = v9;
      }
      else
      {
LABEL_29:
        uint64_t result = 4;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TIFFReadDirEntryLong(uint64_t a1, int8x8_t *a2, __int32 *a3, uint8x8_t a4)
{
  if (*(void *)&a2[1] != 1) {
    return 1;
  }
  uint64_t result = 2;
  switch(a2->i16[1])
  {
    case 1:
      uint64_t result = 0;
      unsigned __int32 v7 = a2[2].u8[0];
      goto LABEL_28;
    case 3:
      unsigned __int32 v8 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        unsigned __int32 v8 = __dst.u16[0];
      }
      uint64_t result = 0;
      goto LABEL_21;
    case 4:
      *a3 = a2[2].i32[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabLong(a3, a4);
      }
      return 0;
    case 6:
      unsigned __int32 v7 = a2[2].i8[0];
      if (((v7 >> 5) & 4) != 0)
      {
        uint64_t result = (v7 >> 5) & 4;
      }
      else
      {
        uint64_t result = 0;
LABEL_28:
        *a3 = v7;
      }
      break;
    case 8:
      unsigned int v9 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        unsigned int v9 = __dst.u16[0];
      }
      uint64_t result = (v9 >> 13) & 4;
      if (((v9 >> 13) & 4) != 0) {
        return result;
      }
      unsigned __int32 v7 = (__int16)v9;
      goto LABEL_28;
    case 9:
      unsigned __int32 v8 = a2[2].u32[0];
      __dst.i32[0] = v8;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        unsigned __int32 v8 = __dst.i32[0];
      }
      uint64_t result = (v8 >> 29) & 4;
      if (((v8 >> 29) & 4) == 0) {
LABEL_21:
      }
        *a3 = v8;
      return result;
    case 0x10:
      int8x8_t __dst = 0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (!result) {
        goto LABEL_25;
      }
      return result;
    case 0x11:
      int8x8_t __dst = 0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (!result)
      {
LABEL_25:
        if (HIDWORD(*(void *)&__dst))
        {
          uint64_t result = 4;
        }
        else
        {
          uint64_t result = 0;
          *a3 = __dst.i32[0];
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TIFFReadDirEntrySlong(uint64_t a1, int8x8_t *a2, __int32 *a3, uint8x8_t a4)
{
  if (*(void *)&a2[1] != 1) {
    return 1;
  }
  uint64_t result = 2;
  switch(a2->i16[1])
  {
    case 1:
      uint64_t result = 0;
      __int32 v7 = a2[2].u8[0];
      goto LABEL_16;
    case 3:
      unsigned __int32 v8 = a2[2].u16[0];
      __dst.i16[0] = a2[2].i16[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        unsigned __int32 v8 = __dst.u16[0];
      }
      uint64_t result = 0;
      goto LABEL_11;
    case 4:
      unsigned __int32 v8 = a2[2].u32[0];
      __dst.i32[0] = v8;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, a4);
        unsigned __int32 v8 = __dst.i32[0];
      }
      uint64_t result = (v8 >> 29) & 4;
      if (((v8 >> 29) & 4) == 0) {
LABEL_11:
      }
        *a3 = v8;
      return result;
    case 6:
      uint64_t result = 0;
      __int32 v7 = a2[2].i8[0];
      goto LABEL_16;
    case 8:
      __int16 v9 = a2[2].i16[0];
      __dst.i16[0] = v9;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        __int16 v9 = __dst.i16[0];
      }
      uint64_t result = 0;
      __int32 v7 = v9;
LABEL_16:
      *a3 = v7;
      return result;
    case 9:
      *a3 = a2[2].i32[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabLong(a3, a4);
      }
      return 0;
    case 0x10:
      int8x8_t __dst = 0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (result) {
        return result;
      }
      __int32 v10 = __dst.i32[0];
      if (!(*(void *)&__dst >> 31)) {
        goto LABEL_22;
      }
      goto LABEL_25;
    case 0x11:
      int8x8_t __dst = 0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dst, a4);
      if (result) {
        return result;
      }
      __int32 v10 = __dst.i32[0];
      if (*(void *)&__dst == __dst.i32[0])
      {
LABEL_22:
        uint64_t result = 0;
        *a3 = v10;
      }
      else
      {
LABEL_25:
        uint64_t result = 4;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TIFFReadDirEntryLong8(uint64_t a1, int8x8_t *a2, int8x8_t *__dst, uint8x8_t a4)
{
  if (*(void *)&a2[1] != 1) {
    return 1;
  }
  uint64_t result = 2;
  switch(a2->i16[1])
  {
    case 1:
      uint64_t result = 0;
      int8x8_t v7 = (int8x8_t)a2[2].u8[0];
      goto LABEL_10;
    case 3:
      unsigned __int32 v8 = a2[2].u16[0];
      __dsta.i16[0] = a2[2].i16[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dsta);
        unsigned __int32 v8 = __dsta.u16[0];
      }
      goto LABEL_9;
    case 4:
      unsigned __int32 v8 = a2[2].u32[0];
      __dsta.i32[0] = v8;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dsta, a4);
        unsigned __int32 v8 = __dsta.i32[0];
      }
LABEL_9:
      uint64_t result = 0;
      int8x8_t v7 = (int8x8_t)v8;
      goto LABEL_10;
    case 6:
      v7.i32[0] = a2[2].u8[0];
      if ((((unsigned __int32)v7.i32[0] >> 5) & 4) != 0) {
        return ((unsigned __int32)v7.i32[0] >> 5) & 4;
      }
      uint64_t result = 0;
      int8x8_t v7 = (int8x8_t)v7.i8[0];
      goto LABEL_10;
    case 8:
      unsigned int v9 = a2[2].u16[0];
      __dsta.i16[0] = a2[2].i16[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dsta);
        unsigned int v9 = __dsta.u16[0];
      }
      uint64_t result = (v9 >> 13) & 4;
      if (((v9 >> 13) & 4) != 0) {
        return result;
      }
      int8x8_t v7 = (int8x8_t)(__int16)v9;
      goto LABEL_10;
    case 9:
      unsigned __int32 v10 = a2[2].u32[0];
      __dsta.i32[0] = v10;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dsta, a4);
        unsigned __int32 v10 = __dsta.i32[0];
      }
      uint64_t result = (v10 >> 29) & 4;
      if (((v10 >> 29) & 4) != 0) {
        return result;
      }
      int8x8_t v7 = (int8x8_t)(int)v10;
      goto LABEL_10;
    case 0x10:
      return TIFFReadDirEntryCheckedLong8(a1, a2, __dst, a4);
    case 0x11:
      int8x8_t __dsta = 0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dsta, a4);
      if (result) {
        return result;
      }
      int8x8_t v7 = __dsta;
      if (((*(void *)&__dsta >> 61) & 4) != 0)
      {
        uint64_t result = (*(void *)&__dsta >> 61) & 4;
      }
      else
      {
        uint64_t result = 0;
LABEL_10:
        *int8x8_t __dst = v7;
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t TIFFReadDirEntrySlong8(uint64_t a1, int8x8_t *a2, int8x8_t *__dst, uint8x8_t a4)
{
  if (*(void *)&a2[1] != 1) {
    return 1;
  }
  uint64_t result = 2;
  switch(a2->i16[1])
  {
    case 1:
      uint64_t result = 0;
      int8x8_t v7 = (int8x8_t)a2[2].u8[0];
      goto LABEL_17;
    case 3:
      unsigned __int32 v8 = a2[2].u16[0];
      __dsta.i16[0] = a2[2].i16[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dsta);
        unsigned __int32 v8 = __dsta.u16[0];
      }
      goto LABEL_9;
    case 4:
      unsigned __int32 v8 = a2[2].u32[0];
      __dsta.i32[0] = v8;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dsta, a4);
        unsigned __int32 v8 = __dsta.i32[0];
      }
LABEL_9:
      uint64_t result = 0;
      int8x8_t v7 = (int8x8_t)v8;
      goto LABEL_17;
    case 6:
      uint64_t result = 0;
      int8x8_t v7 = (int8x8_t)a2[2].i8[0];
      goto LABEL_17;
    case 8:
      __int16 v9 = a2[2].i16[0];
      __dsta.i16[0] = v9;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dsta);
        __int16 v9 = __dsta.i16[0];
      }
      uint64_t result = 0;
      int8x8_t v7 = (int8x8_t)v9;
      goto LABEL_17;
    case 9:
      __int32 v10 = a2[2].i32[0];
      __dsta.i32[0] = v10;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dsta, a4);
        __int32 v10 = __dsta.i32[0];
      }
      uint64_t result = 0;
      int8x8_t v7 = (int8x8_t)v10;
      goto LABEL_17;
    case 0x10:
      int8x8_t __dsta = 0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, &__dsta, a4);
      if (result) {
        return result;
      }
      int8x8_t v7 = __dsta;
      if (((*(void *)&__dsta >> 61) & 4) != 0)
      {
        uint64_t result = (*(void *)&__dsta >> 61) & 4;
      }
      else
      {
        uint64_t result = 0;
LABEL_17:
        *int8x8_t __dst = v7;
      }
      break;
    case 0x11:
      return TIFFReadDirEntryCheckedLong8(a1, a2, __dst, a4);
    default:
      return result;
  }
  return result;
}

uint64_t TIFFReadDirEntryFloat(uint64_t a1, int8x8_t *a2, __int32 *a3, double a4)
{
  if (*(void *)&a2[1] != 1) {
    return 1;
  }
  uint64_t result = 2;
  switch(a2->i16[1])
  {
    case 1:
      uint64_t result = 0;
      LOBYTE(a4) = a2[2].i8[0];
      *(float *)&a4 = (float)LODWORD(a4);
      break;
    case 3:
      unsigned int v7 = a2[2].u16[0];
      LOWORD(__dst) = a2[2].i16[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        unsigned int v7 = (unsigned __int16)__dst;
      }
      goto LABEL_9;
    case 4:
      unsigned int v7 = a2[2].u32[0];
      LODWORD(__dst) = v7;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, *(uint8x8_t *)&a4);
        unsigned int v7 = __dst;
      }
LABEL_9:
      uint64_t result = 0;
      *(float *)&a4 = (float)v7;
      break;
    case 5:
      *(double *)&uint64_t __dst = 0.0;
      uint64_t result = TIFFReadDirEntryCheckedRational(a1, (uint64_t)a2, (double *)&__dst, *(uint8x8_t *)&a4);
      if (!result) {
        goto LABEL_21;
      }
      return result;
    case 6:
      uint64_t result = 0;
      int v8 = a2[2].i8[0];
      goto LABEL_16;
    case 8:
      __int16 v9 = a2[2].i16[0];
      LOWORD(__dst) = v9;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dst);
        __int16 v9 = __dst;
      }
      uint64_t result = 0;
      int v8 = v9;
LABEL_16:
      *(float *)&a4 = (float)v8;
      break;
    case 9:
      int v10 = a2[2].i32[0];
      LODWORD(__dst) = v10;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dst, *(uint8x8_t *)&a4);
        int v10 = __dst;
      }
      uint64_t result = 0;
      *(float *)&a4 = (float)v10;
      break;
    case 0xA:
      *(double *)&uint64_t __dst = 0.0;
      uint64_t result = TIFFReadDirEntryCheckedSrational(a1, (uint64_t)a2, (double *)&__dst, *(uint8x8_t *)&a4);
      if (result) {
        return result;
      }
LABEL_21:
      a4 = *(double *)&__dst;
      goto LABEL_29;
    case 0xB:
      LODWORD(a4) = a2[2].i32[0];
      *a3 = LODWORD(a4);
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabLong(a3, *(uint8x8_t *)&a4);
      }
      return 0;
    case 0xC:
      *(double *)&uint64_t __dst = 0.0;
      uint64_t result = TIFFReadDirEntryCheckedDouble(a1, a2, (int8x8_t *)&__dst, *(uint8x8_t *)&a4);
      if (result) {
        return result;
      }
      a4 = *(double *)&__dst;
      uint64_t result = 4;
      if (*(double *)&__dst > 3.40282347e38 || *(double *)&__dst < -3.40282347e38) {
        return result;
      }
      uint64_t result = 0;
LABEL_29:
      *(float *)&a4 = a4;
      break;
    case 0x10:
      *(double *)&uint64_t __dst = 0.0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, (int8x8_t *)&__dst, *(uint8x8_t *)&a4);
      if (result) {
        return result;
      }
      *(float *)&a4 = (float)(unint64_t)__dst;
      break;
    case 0x11:
      *(double *)&uint64_t __dst = 0.0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, (int8x8_t *)&__dst, *(uint8x8_t *)&a4);
      if (result) {
        return result;
      }
      *(float *)&a4 = (float)__dst;
      break;
    default:
      return result;
  }
  *a3 = LODWORD(a4);
  return result;
}

uint64_t TIFFReadDirEntryDouble(uint64_t a1, int8x8_t *a2, double *__dst, double a4)
{
  if (*(void *)&a2[1] != 1) {
    return 1;
  }
  uint64_t result = 2;
  switch(a2->i16[1])
  {
    case 1:
      uint64_t result = 0;
      LOBYTE(a4) = a2[2].i8[0];
      goto LABEL_32;
    case 3:
      unsigned int v7 = a2[2].u16[0];
      LOWORD(__dsta) = a2[2].i16[0];
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dsta);
        unsigned int v7 = LOWORD(__dsta);
      }
      goto LABEL_9;
    case 4:
      unsigned int v7 = a2[2].u32[0];
      LODWORD(__dsta) = v7;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dsta, *(uint8x8_t *)&a4);
        unsigned int v7 = LODWORD(__dsta);
      }
LABEL_9:
      uint64_t result = 0;
      double v8 = (double)v7;
      break;
    case 5:
      return TIFFReadDirEntryCheckedRational(a1, (uint64_t)a2, __dst, *(uint8x8_t *)&a4);
    case 6:
      uint64_t result = 0;
      int v9 = a2[2].i8[0];
      goto LABEL_17;
    case 8:
      __int16 v10 = a2[2].i16[0];
      LOWORD(__dsta) = v10;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabShort(&__dsta);
        __int16 v10 = LOWORD(__dsta);
      }
      uint64_t result = 0;
      int v9 = v10;
LABEL_17:
      double v8 = (double)v9;
      break;
    case 9:
      int v11 = a2[2].i32[0];
      LODWORD(__dsta) = v11;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dsta, *(uint8x8_t *)&a4);
        int v11 = LODWORD(__dsta);
      }
      uint64_t result = 0;
      double v8 = (double)v11;
      break;
    case 0xA:
      return TIFFReadDirEntryCheckedSrational(a1, (uint64_t)a2, __dst, *(uint8x8_t *)&a4);
    case 0xB:
      LODWORD(a4) = a2[2].i32[0];
      LODWORD(__dsta) = LODWORD(a4);
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
      {
        TIFFSwabLong((__int32 *)&__dsta, *(uint8x8_t *)&a4);
        LODWORD(a4) = LODWORD(__dsta);
      }
      uint64_t result = 0;
      double v8 = *(float *)&a4;
      break;
    case 0xC:
      return TIFFReadDirEntryCheckedDouble(a1, a2, (int8x8_t *)__dst, *(uint8x8_t *)&a4);
    case 0x10:
      double __dsta = 0.0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, (int8x8_t *)&__dsta, *(uint8x8_t *)&a4);
      if (result) {
        return result;
      }
      a4 = __dsta;
LABEL_32:
      double v8 = (double)*(unint64_t *)&a4;
      break;
    case 0x11:
      double __dsta = 0.0;
      uint64_t result = TIFFReadDirEntryCheckedLong8(a1, a2, (int8x8_t *)&__dsta, *(uint8x8_t *)&a4);
      if (result) {
        return result;
      }
      double v8 = (double)*(uint64_t *)&__dsta;
      break;
    default:
      return result;
  }
  *uint64_t __dst = v8;
  return result;
}

uint64_t TIFFReadDirEntryIfd8(uint64_t a1, int8x8_t *a2, int8x8_t *__dst, uint8x8_t a4)
{
  if (*(void *)&a2[1] != 1) {
    return 1;
  }
  unsigned int v6 = a2->u16[1];
  uint64_t result = 2;
  if (v6 > 0xF)
  {
    if (v6 == 16 || v6 == 18)
    {
      return TIFFReadDirEntryCheckedLong8(a1, a2, __dst, a4);
    }
  }
  else if (v6 == 4 || v6 == 13)
  {
    unsigned __int32 v9 = a2[2].u32[0];
    unsigned __int32 v11 = v9;
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
    {
      TIFFSwabLong((__int32 *)&v11, a4);
      unsigned __int32 v9 = v11;
    }
    uint64_t result = 0;
    *uint64_t __dst = (int8x8_t)v9;
  }
  return result;
}

uint64_t TIFFReadDirEntrySbyteArray(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a2 + 2);
  BOOL v4 = v3 > 0x11;
  int v5 = (1 << v3) & 0x303DA;
  if (v4 || v5 == 0) {
    return 2;
  }
  unsigned int v45 = 0;
  int8x8_t v44 = 0;
  uint64_t v16 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v45, 1u, &v44, 0xFFFFFFFFFFFFFFFFLL);
  if (v16 || (uint64_t v17 = (char *)v44) == 0)
  {
    *a3 = 0;
    return v16;
  }
  int v18 = *(unsigned __int16 *)(a2 + 2);
  switch(v18)
  {
    case 7:
      goto LABEL_10;
    case 6:
      goto LABEL_14;
    case 1:
LABEL_10:
      if (v45)
      {
        uint64_t v19 = 0;
        while (1)
        {
          int v20 = *((unsigned __int8 *)v44 + v19) >> 5;
          if ((v20 & 4) != 0) {
            break;
          }
          if (v45 == ++v19) {
            goto LABEL_14;
          }
        }
        uint64_t v16 = v20 & 4;
        _TIFFfreeExt(a1, (char *)v44);
        return v16;
      }
LABEL_14:
      uint64_t v16 = 0;
      *a3 = v44;
      return v16;
  }
  unsigned int v22 = v45;
  uint64_t v23 = (char *)_TIFFmallocExt((void *)a1, v45, v10, v11, v12, v13, v14, v15);
  if (v23)
  {
    unint64_t v25 = v23;
    switch(*(_WORD *)(a2 + 2))
    {
      case 3:
        if (!v22) {
          goto LABEL_63;
        }
        uint64_t v26 = v23;
        int v27 = v17;
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            TIFFSwabShort(v27);
          }
          unsigned int v28 = *(unsigned __int16 *)v27;
          if (v28 > 0x7F) {
            goto LABEL_64;
          }
          v27 += 2;
          *v26++ = v28;
          if (!--v22) {
            goto LABEL_63;
          }
        }
      case 4:
        if (!v22) {
          goto LABEL_63;
        }
        uint64_t v29 = v23;
        uint64_t v30 = (__int32 *)v17;
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            int8x8_t v24 = TIFFSwabLong(v30, (uint8x8_t)v24);
          }
          __int32 v31 = *v30;
          if (*v30 > 0x7F) {
            goto LABEL_64;
          }
          ++v30;
          *v29++ = v31;
          if (!--v22) {
            goto LABEL_63;
          }
        }
      case 8:
        if (!v22) {
          goto LABEL_63;
        }
        uint64_t v32 = v23;
        uint64_t v33 = v17;
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            TIFFSwabShort(v33);
          }
          int v34 = *(unsigned __int16 *)v33;
          if (v34 != (unsigned __int16)(char)v34) {
            goto LABEL_64;
          }
          v33 += 2;
          *v32++ = v34;
          if (!--v22) {
            goto LABEL_63;
          }
        }
      case 9:
        if (!v22) {
          goto LABEL_63;
        }
        uint64_t v35 = v23;
        uint64_t v36 = (__int32 *)v17;
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            int8x8_t v24 = TIFFSwabLong(v36, (uint8x8_t)v24);
          }
          __int32 v37 = *v36;
          if (v37 != (char)v37) {
            goto LABEL_64;
          }
          ++v36;
          *v35++ = v37;
          if (!--v22) {
            goto LABEL_63;
          }
        }
      case 0x10:
        if (!v22) {
          goto LABEL_63;
        }
        unsigned int v38 = v23;
        int v39 = (int8x8_t *)v17;
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            TIFFSwabLong8(v39);
          }
          int8x8_t v40 = *v39;
          if (*(void *)v39 > 0x7FuLL) {
            goto LABEL_64;
          }
          ++v39;
          *v38++ = v40.i8[0];
          if (!--v22) {
            goto LABEL_63;
          }
        }
      case 0x11:
        if (!v22) {
          goto LABEL_63;
        }
        uint64_t v41 = v23;
        uint8x8_t v42 = (int8x8_t *)v17;
        break;
      default:
        goto LABEL_63;
    }
    while (1)
    {
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabLong8(v42);
      }
      int8x8_t v43 = *v42;
      if (*v42 != v42->i8[0]) {
        break;
      }
      ++v42;
      *v41++ = v43.i8[0];
      if (!--v22)
      {
LABEL_63:
        _TIFFfreeExt(a1, v17);
        uint64_t v16 = 0;
        *a3 = v25;
        return v16;
      }
    }
LABEL_64:
    _TIFFfreeExt(a1, v17);
    _TIFFfreeExt(a1, v25);
    return 4;
  }
  else
  {
    _TIFFfreeExt(a1, v17);
    return 7;
  }
}

uint64_t TIFFReadDirEntrySshortArray(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a2 + 2);
  BOOL v4 = v3 > 0x11;
  int v5 = (1 << v3) & 0x3035A;
  if (v4 || v5 == 0) {
    return 2;
  }
  unsigned int v47 = 0;
  unint64_t v46 = 0;
  uint64_t v16 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v47, 2u, &v46, 0xFFFFFFFFFFFFFFFFLL);
  if (v16 || (uint64_t v17 = (char *)v46) == 0)
  {
    *a3 = 0;
  }
  else
  {
    int v18 = *(unsigned __int16 *)(a2 + 2);
    if (v18 == 8)
    {
      *a3 = v46;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabArrayOfShort((uint64_t)v17, v47);
      }
      return 0;
    }
    else if (v18 == 3)
    {
      unsigned int v19 = v47;
      if (v47)
      {
        int v20 = v46;
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            TIFFSwabShort(v20);
          }
          int v21 = *(unsigned __int16 *)v20 >> 13;
          if ((v21 & 4) != 0) {
            break;
          }
          v20 += 2;
          if (!--v19) {
            goto LABEL_15;
          }
        }
        uint64_t v16 = v21 & 4;
        _TIFFfreeExt(a1, v17);
      }
      else
      {
LABEL_15:
        uint64_t v16 = 0;
        *a3 = v17;
      }
    }
    else
    {
      unsigned int v22 = v47;
      uint64_t v23 = (char *)_TIFFmallocExt((void *)a1, 2 * v47, v10, v11, v12, v13, v14, v15);
      if (v23)
      {
        unint64_t v25 = v23;
        int v26 = *(unsigned __int16 *)(a2 + 2);
        switch(*(_WORD *)(a2 + 2))
        {
          case 1:
            if (v22)
            {
              int v27 = v23;
              unsigned int v28 = v17;
              do
              {
                __int16 v29 = *v28++;
                *(_WORD *)int v27 = v29;
                v27 += 2;
                --v22;
              }
              while (v22);
            }
            goto LABEL_62;
          case 2:
          case 3:
          case 5:
          case 7:
          case 8:
            goto LABEL_62;
          case 4:
            if (!v22) {
              goto LABEL_62;
            }
            uint64_t v33 = v23;
            int v34 = (__int32 *)v17;
            while (1)
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                int8x8_t v24 = TIFFSwabLong(v34, (uint8x8_t)v24);
              }
              __int32 v35 = *v34;
              if (*v34 >> 15) {
                goto LABEL_64;
              }
              ++v34;
              *(_WORD *)uint64_t v33 = v35;
              v33 += 2;
              if (!--v22) {
                goto LABEL_62;
              }
            }
          case 6:
            if (v22)
            {
              uint64_t v36 = v23;
              __int32 v37 = v17;
              do
              {
                __int16 v38 = *v37++;
                *(_WORD *)uint64_t v36 = v38;
                v36 += 2;
                --v22;
              }
              while (v22);
            }
            goto LABEL_62;
          case 9:
            if (!v22) {
              goto LABEL_62;
            }
            int v39 = v23;
            int8x8_t v40 = (__int32 *)v17;
            break;
          default:
            if (v26 == 16)
            {
              if (!v22) {
                goto LABEL_62;
              }
              uint8x8_t v42 = v23;
              int8x8_t v43 = (int8x8_t *)v17;
              while (1)
              {
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  TIFFSwabLong8(v43);
                }
                int8x8_t v44 = *v43;
                if (*(unint64_t *)v43 >> 15) {
                  break;
                }
                ++v43;
                *(_WORD *)uint8x8_t v42 = v44.i16[0];
                v42 += 2;
                if (!--v22) {
                  goto LABEL_62;
                }
              }
            }
            else
            {
              if (v26 != 17 || !v22) {
                goto LABEL_62;
              }
              uint64_t v30 = v23;
              __int32 v31 = (int8x8_t *)v17;
              while (1)
              {
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  TIFFSwabLong8(v31);
                }
                int8x8_t v32 = *v31;
                if (*v31 != v31->i16[0]) {
                  break;
                }
                ++v31;
                *(_WORD *)uint64_t v30 = v32.i16[0];
                v30 += 2;
                if (!--v22) {
                  goto LABEL_62;
                }
              }
            }
            goto LABEL_64;
        }
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            int8x8_t v24 = TIFFSwabLong(v40, (uint8x8_t)v24);
          }
          __int32 v41 = *v40;
          if (v41 != (__int16)v41) {
            break;
          }
          ++v40;
          *(_WORD *)int v39 = v41;
          v39 += 2;
          if (!--v22)
          {
LABEL_62:
            _TIFFfreeExt(a1, v17);
            uint64_t v16 = 0;
            *a3 = v25;
            return v16;
          }
        }
LABEL_64:
        _TIFFfreeExt(a1, v17);
        _TIFFfreeExt(a1, v25);
        return 4;
      }
      else
      {
        _TIFFfreeExt(a1, v17);
        return 7;
      }
    }
  }
  return v16;
}

uint64_t TIFFReadDirEntryLongArray(uint64_t a1, uint64_t a2, __int32 **a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a2 + 2);
  BOOL v4 = v3 > 0x11;
  int v5 = (1 << v3) & 0x3035A;
  if (v4 || v5 == 0) {
    return 2;
  }
  unsigned int v49 = 0;
  uint64_t v48 = 0;
  uint64_t v16 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v49, 4u, (void **)&v48, 0xFFFFFFFFFFFFFFFFLL);
  if (v16 || (int v18 = v48) == 0)
  {
    *a3 = 0;
  }
  else
  {
    int v19 = *(unsigned __int16 *)(a2 + 2);
    if (v19 == 4)
    {
      *a3 = v48;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabArrayOfLong(v18, v49, (uint8x8_t)v17);
      }
      return 0;
    }
    else if (v19 == 9)
    {
      unsigned int v20 = v49;
      if (v49)
      {
        int v21 = v48;
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            int8x8_t v17 = TIFFSwabLong(v21, (uint8x8_t)v17);
          }
          unsigned int v22 = *v21 >> 29;
          if ((v22 & 4) != 0) {
            break;
          }
          ++v21;
          if (!--v20) {
            goto LABEL_15;
          }
        }
        uint64_t v16 = v22 & 4;
        uint64_t v30 = a1;
        __int32 v31 = (char *)v18;
LABEL_67:
        _TIFFfreeExt(v30, v31);
      }
      else
      {
LABEL_15:
        uint64_t v16 = 0;
        *a3 = v18;
      }
    }
    else
    {
      unsigned int v23 = v49;
      int8x8_t v24 = (char *)_TIFFmallocExt((void *)a1, 4 * v49, v10, v11, v12, v13, v14, v15);
      if (v24)
      {
        unint64_t v25 = v24;
        int v26 = *(unsigned __int16 *)(a2 + 2);
        switch(*(_WORD *)(a2 + 2))
        {
          case 1:
            if (v23)
            {
              int v27 = v24;
              unsigned int v28 = v18;
              do
              {
                int v29 = *(unsigned __int8 *)v28;
                unsigned int v28 = (__int32 *)((char *)v28 + 1);
                *(_DWORD *)int v27 = v29;
                v27 += 4;
                --v23;
              }
              while (v23);
            }
            goto LABEL_62;
          case 2:
          case 4:
          case 5:
          case 7:
            goto LABEL_62;
          case 3:
            if (v23)
            {
              __int32 v35 = v24;
              uint64_t v36 = v18;
              do
              {
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  TIFFSwabShort(v36);
                }
                int v37 = *(unsigned __int16 *)v36;
                uint64_t v36 = (__int32 *)((char *)v36 + 2);
                *(_DWORD *)__int32 v35 = v37;
                v35 += 4;
                --v23;
              }
              while (v23);
            }
            goto LABEL_62;
          case 6:
            if (!v23) {
              goto LABEL_62;
            }
            __int16 v38 = v24;
            int v39 = v18;
            while (1)
            {
              unsigned int v40 = *(char *)v39;
              if (((v40 >> 5) & 4) != 0) {
                break;
              }
              int v39 = (__int32 *)((char *)v39 + 1);
              *(_DWORD *)__int16 v38 = v40;
              v38 += 4;
              if (!--v23) {
                goto LABEL_62;
              }
            }
            uint64_t v16 = (v40 >> 5) & 4;
            goto LABEL_66;
          case 8:
            if (!v23) {
              goto LABEL_62;
            }
            __int32 v41 = v24;
            uint8x8_t v42 = v18;
            while (1)
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                TIFFSwabShort(v42);
              }
              unsigned int v43 = *(__int16 *)v42;
              if (((v43 >> 13) & 4) != 0) {
                break;
              }
              uint8x8_t v42 = (__int32 *)((char *)v42 + 2);
              *(_DWORD *)__int32 v41 = v43;
              v41 += 4;
              if (!--v23) {
                goto LABEL_62;
              }
            }
            uint64_t v16 = (v43 >> 13) & 4;
LABEL_66:
            _TIFFfreeExt(a1, (char *)v18);
            uint64_t v30 = a1;
            __int32 v31 = v25;
            goto LABEL_67;
          default:
            if (v26 == 16)
            {
              if (!v23) {
                goto LABEL_62;
              }
              int8x8_t v44 = v24;
              unsigned int v45 = (int8x8_t *)v18;
              while (1)
              {
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  TIFFSwabLong8(v45);
                }
                int8x8_t v46 = *v45;
                if (HIDWORD(*(unint64_t *)v45)) {
                  break;
                }
                ++v45;
                *(_DWORD *)int8x8_t v44 = v46.i32[0];
                v44 += 4;
                if (!--v23) {
                  goto LABEL_62;
                }
              }
            }
            else
            {
              if (v26 != 17 || !v23)
              {
LABEL_62:
                _TIFFfreeExt(a1, (char *)v18);
                uint64_t v16 = 0;
                *a3 = (__int32 *)v25;
                return v16;
              }
              int8x8_t v32 = v24;
              uint64_t v33 = (int8x8_t *)v18;
              while (1)
              {
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  TIFFSwabLong8(v33);
                }
                int8x8_t v34 = *v33;
                if (HIDWORD(*(unint64_t *)v33)) {
                  break;
                }
                ++v33;
                *(_DWORD *)int8x8_t v32 = v34.i32[0];
                v32 += 4;
                if (!--v23) {
                  goto LABEL_62;
                }
              }
            }
            uint64_t v16 = 4;
            goto LABEL_66;
        }
      }
      _TIFFfreeExt(a1, (char *)v18);
      return 7;
    }
  }
  return v16;
}

uint64_t TIFFReadDirEntrySlongArray(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a2 + 2);
  BOOL v4 = v3 > 0x11;
  int v5 = (1 << v3) & 0x3035A;
  if (v4 || v5 == 0) {
    return 2;
  }
  unsigned int v47 = 0;
  int8x8_t v46 = 0;
  uint64_t v16 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v47, 4u, &v46, 0xFFFFFFFFFFFFFFFFLL);
  if (v16 || (int v18 = (__int32 *)v46) == 0)
  {
    *a3 = 0;
    return v16;
  }
  int v19 = *(unsigned __int16 *)(a2 + 2);
  if (v19 == 9)
  {
    *a3 = v46;
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabArrayOfLong(v18, v47, (uint8x8_t)v17);
    }
    return 0;
  }
  if (v19 != 4)
  {
    unsigned int v23 = v47;
    int8x8_t v24 = (char *)_TIFFmallocExt((void *)a1, 4 * v47, v10, v11, v12, v13, v14, v15);
    if (!v24)
    {
      _TIFFfreeExt(a1, (char *)v18);
      return 7;
    }
    unint64_t v25 = v24;
    int v26 = *(unsigned __int16 *)(a2 + 2);
    switch(*(_WORD *)(a2 + 2))
    {
      case 1:
        if (v23)
        {
          int v27 = v24;
          unsigned int v28 = v18;
          do
          {
            int v29 = *(unsigned __int8 *)v28;
            unsigned int v28 = (__int32 *)((char *)v28 + 1);
            *(_DWORD *)int v27 = v29;
            v27 += 4;
            --v23;
          }
          while (v23);
        }
        goto LABEL_60;
      case 2:
      case 4:
      case 5:
      case 7:
        goto LABEL_60;
      case 3:
        if (v23)
        {
          uint64_t v33 = v24;
          int8x8_t v34 = v18;
          do
          {
            if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
              TIFFSwabShort(v34);
            }
            int v35 = *(unsigned __int16 *)v34;
            int8x8_t v34 = (__int32 *)((char *)v34 + 2);
            *(_DWORD *)uint64_t v33 = v35;
            v33 += 4;
            --v23;
          }
          while (v23);
        }
        goto LABEL_60;
      case 6:
        if (v23)
        {
          uint64_t v36 = v24;
          int v37 = v18;
          do
          {
            int v38 = *(char *)v37;
            int v37 = (__int32 *)((char *)v37 + 1);
            *(_DWORD *)uint64_t v36 = v38;
            v36 += 4;
            --v23;
          }
          while (v23);
        }
        goto LABEL_60;
      case 8:
        if (v23)
        {
          int v39 = v24;
          unsigned int v40 = v18;
          do
          {
            if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
              TIFFSwabShort(v40);
            }
            int v41 = *(__int16 *)v40;
            unsigned int v40 = (__int32 *)((char *)v40 + 2);
            *(_DWORD *)int v39 = v41;
            v39 += 4;
            --v23;
          }
          while (v23);
        }
        goto LABEL_60;
      default:
        if (v26 == 16)
        {
          if (v23)
          {
            uint8x8_t v42 = v24;
            unsigned int v43 = (int8x8_t *)v18;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                TIFFSwabLong8(v43);
              }
              int8x8_t v44 = *v43;
              if (*(unint64_t *)v43 >> 31) {
                goto LABEL_62;
              }
              ++v43;
              *(_DWORD *)uint8x8_t v42 = v44.i32[0];
              v42 += 4;
            }
            while (--v23);
          }
        }
        else if (v26 == 17 && v23)
        {
          uint64_t v30 = v24;
          __int32 v31 = (int8x8_t *)v18;
          while (1)
          {
            if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
              TIFFSwabLong8(v31);
            }
            int8x8_t v32 = *v31;
            if (*v31 != v31->i32[0]) {
              break;
            }
            ++v31;
            *(_DWORD *)uint64_t v30 = v32.i32[0];
            v30 += 4;
            if (!--v23) {
              goto LABEL_60;
            }
          }
LABEL_62:
          _TIFFfreeExt(a1, (char *)v18);
          _TIFFfreeExt(a1, v25);
          return 4;
        }
LABEL_60:
        _TIFFfreeExt(a1, (char *)v18);
        uint64_t v16 = 0;
        *a3 = v25;
        return v16;
    }
  }
  unsigned int v20 = v47;
  if (v47)
  {
    int v21 = (__int32 *)v46;
    while (1)
    {
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        int8x8_t v17 = TIFFSwabLong(v21, (uint8x8_t)v17);
      }
      unsigned int v22 = *v21 >> 29;
      if ((v22 & 4) != 0) {
        break;
      }
      ++v21;
      if (!--v20) {
        goto LABEL_15;
      }
    }
    uint64_t v16 = v22 & 4;
    _TIFFfreeExt(a1, (char *)v18);
  }
  else
  {
LABEL_15:
    uint64_t v16 = 0;
    *a3 = v18;
  }
  return v16;
}

uint64_t TIFFReadDirEntrySlong8Array(uint64_t a1, uint64_t a2, void *a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a2 + 2);
  BOOL v4 = v3 > 0x11;
  int v5 = (1 << v3) & 0x3035A;
  if (v4 || v5 == 0) {
    return 2;
  }
  unsigned int v45 = 0;
  int8x8_t v44 = 0;
  uint64_t v16 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v45, 8u, &v44, 0xFFFFFFFFFFFFFFFFLL);
  if (v16 || (int8x8_t v17 = (int8x8_t *)v44) == 0)
  {
    *a3 = 0;
  }
  else
  {
    int v18 = *(unsigned __int16 *)(a2 + 2);
    if (v18 == 17)
    {
      *a3 = v44;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabArrayOfLong8(v17, v45);
      }
      return 0;
    }
    else if (v18 == 16)
    {
      unsigned int v19 = v45;
      if (v45)
      {
        unsigned int v20 = (int8x8_t *)v44;
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            TIFFSwabLong8(v20);
          }
          if (((*(unint64_t *)v20 >> 61) & 4) != 0) {
            break;
          }
          ++v20;
          if (!--v19) {
            goto LABEL_15;
          }
        }
        uint64_t v16 = (*(unint64_t *)v20 >> 61) & 4;
        _TIFFfreeExt(a1, (char *)v17);
      }
      else
      {
LABEL_15:
        uint64_t v16 = 0;
        *a3 = v17;
      }
    }
    else
    {
      unsigned int v21 = v45;
      unsigned int v22 = _TIFFmallocExt((void *)a1, 8 * v45, v10, v11, v12, v13, v14, v15);
      if (v22)
      {
        int8x8_t v24 = v22;
        switch(*(_WORD *)(a2 + 2))
        {
          case 1:
            if (v21)
            {
              unint64_t v25 = v22;
              int v26 = v17;
              do
              {
                unsigned int v27 = v26->u8[0];
                int v26 = (int8x8_t *)((char *)v26 + 1);
                *v25++ = v27;
                --v21;
              }
              while (v21);
            }
            break;
          case 3:
            if (v21)
            {
              unsigned int v28 = v22;
              int v29 = v17;
              do
              {
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  TIFFSwabShort(v29);
                }
                unsigned int v30 = v29->u16[0];
                int v29 = (int8x8_t *)((char *)v29 + 2);
                *v28++ = v30;
                --v21;
              }
              while (v21);
            }
            break;
          case 4:
            if (v21)
            {
              __int32 v31 = v22;
              int8x8_t v32 = (__int32 *)v17;
              do
              {
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  int8x8_t v23 = TIFFSwabLong(v32, (uint8x8_t)v23);
                }
                unsigned __int32 v33 = *v32++;
                *v31++ = v33;
                --v21;
              }
              while (v21);
            }
            break;
          case 6:
            if (v21)
            {
              int8x8_t v34 = v22;
              int v35 = v17;
              do
              {
                uint64_t v36 = v35->i8[0];
                int v35 = (int8x8_t *)((char *)v35 + 1);
                *v34++ = v36;
                --v21;
              }
              while (v21);
            }
            break;
          case 8:
            if (v21)
            {
              int v37 = v22;
              int v38 = v17;
              do
              {
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  TIFFSwabShort(v38);
                }
                uint64_t v39 = v38->i16[0];
                int v38 = (int8x8_t *)((char *)v38 + 2);
                *v37++ = v39;
                --v21;
              }
              while (v21);
            }
            break;
          case 9:
            if (v21)
            {
              unsigned int v40 = v22;
              int v41 = (__int32 *)v17;
              do
              {
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  int8x8_t v23 = TIFFSwabLong(v41, (uint8x8_t)v23);
                }
                uint64_t v42 = *v41++;
                *v40++ = v42;
                --v21;
              }
              while (v21);
            }
            break;
          default:
            break;
        }
        _TIFFfreeExt(a1, (char *)v17);
        uint64_t v16 = 0;
        *a3 = v24;
      }
      else
      {
        _TIFFfreeExt(a1, (char *)v17);
        return 7;
      }
    }
  }
  return v16;
}

uint64_t TIFFReadDirEntryFloatArray(uint64_t a1, uint64_t a2, int8x8_t **a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a2 + 2);
  BOOL v4 = v3 > 0x11;
  int v5 = (1 << v3) & 0x31F7A;
  if (v4 || v5 == 0) {
    return 2;
  }
  unsigned int v62 = 0;
  uint64_t v61 = 0;
  uint64_t result = TIFFReadDirEntryArrayWithLimit(a1, a2, &v62, 4u, (void **)&v61, 0xFFFFFFFFFFFFFFFFLL);
  if (result || (int v18 = (int8x8_t *)v61) == 0)
  {
    *a3 = 0;
  }
  else if (*(_WORD *)(a2 + 2) == 11)
  {
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabArrayOfLong(v61, v62, v17);
    }
    uint64_t result = 0;
    *a3 = v18;
  }
  else
  {
    uint64_t v19 = v62;
    unsigned int v20 = (float *)_TIFFmallocExt((void *)a1, 4 * v62, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      unsigned int v22 = v20;
      switch(*(_WORD *)(a2 + 2))
      {
        case 1:
          if (v19)
          {
            int8x8_t v23 = v20;
            int8x8_t v24 = v18;
            do
            {
              unsigned int v25 = v24->u8[0];
              int8x8_t v24 = (int8x8_t *)((char *)v24 + 1);
              *v23++ = (float)v25;
              LODWORD(v19) = v19 - 1;
            }
            while (v19);
          }
          break;
        case 3:
          if (v19)
          {
            int v26 = v20;
            unsigned int v27 = v18;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                TIFFSwabShort(v27);
              }
              unsigned int v28 = v27->u16[0];
              unsigned int v27 = (int8x8_t *)((char *)v27 + 2);
              *v26++ = (float)v28;
              LODWORD(v19) = v19 - 1;
            }
            while (v19);
          }
          break;
        case 4:
          if (v19)
          {
            int v29 = v20;
            unsigned int v30 = (__int32 *)v18;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                int8x8_t v21 = TIFFSwabLong(v30, (uint8x8_t)v21);
              }
              unsigned int v31 = *v30++;
              *(float *)v21.i32 = (float)v31;
              *v29++ = (float)v31;
              LODWORD(v19) = v19 - 1;
            }
            while (v19);
          }
          break;
        case 5:
          if (v19)
          {
            int8x8_t v32 = v20;
            unsigned __int32 v33 = (__int32 *)v18;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
              {
                int8x8_t v21 = TIFFSwabLong(v33, (uint8x8_t)v21);
                int8x8_t v34 = (unsigned int *)(v33 + 1);
                unsigned int v35 = *v33;
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  int8x8_t v21 = TIFFSwabLong(v33 + 1, (uint8x8_t)v21);
                }
              }
              else
              {
                int8x8_t v34 = (unsigned int *)(v33 + 1);
                unsigned int v35 = *v33;
              }
              if (*v34) {
                *(float *)v21.i32 = (float)v35 / (float)*v34;
              }
              else {
                int8x8_t v21 = 0;
              }
              v33 += 2;
              *v32++ = *(float *)v21.i32;
              LODWORD(v19) = v19 - 1;
            }
            while (v19);
          }
          break;
        case 6:
          if (v19)
          {
            uint64_t v36 = v20;
            int v37 = v18;
            do
            {
              int v38 = v37->i8[0];
              int v37 = (int8x8_t *)((char *)v37 + 1);
              *v36++ = (float)v38;
              LODWORD(v19) = v19 - 1;
            }
            while (v19);
          }
          break;
        case 8:
          if (v19)
          {
            uint64_t v39 = v20;
            unsigned int v40 = v18;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                TIFFSwabShort(v40);
              }
              int v41 = v40->i16[0];
              unsigned int v40 = (int8x8_t *)((char *)v40 + 2);
              *v39++ = (float)v41;
              LODWORD(v19) = v19 - 1;
            }
            while (v19);
          }
          break;
        case 9:
          if (v19)
          {
            uint64_t v42 = v20;
            unsigned int v43 = (__int32 *)v18;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                int8x8_t v21 = TIFFSwabLong(v43, (uint8x8_t)v21);
              }
              int v44 = *v43++;
              *(float *)v21.i32 = (float)v44;
              *v42++ = (float)v44;
              LODWORD(v19) = v19 - 1;
            }
            while (v19);
          }
          break;
        case 0xA:
          if (v19)
          {
            unsigned int v45 = v20;
            int8x8_t v46 = (__int32 *)v18;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0)
              {
                int8x8_t v21 = TIFFSwabLong(v46, (uint8x8_t)v21);
                unsigned int v47 = (unsigned int *)(v46 + 1);
                int v48 = *v46;
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  int8x8_t v21 = TIFFSwabLong(v46 + 1, (uint8x8_t)v21);
                }
              }
              else
              {
                unsigned int v47 = (unsigned int *)(v46 + 1);
                int v48 = *v46;
              }
              if (*v47) {
                *(float *)v21.i32 = (float)v48 / (float)*v47;
              }
              else {
                int8x8_t v21 = 0;
              }
              v46 += 2;
              *v45++ = *(float *)v21.i32;
              LODWORD(v19) = v19 - 1;
            }
            while (v19);
          }
          break;
        case 0xC:
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            TIFFSwabArrayOfLong8(v18, v19);
          }
          if (v19)
          {
            uint64_t v55 = v22;
            unsigned int v56 = (double *)v18;
            do
            {
              double v57 = *v56++;
              double v58 = v57;
              double v59 = 3.40282347e38;
              if (v57 <= 3.40282347e38)
              {
                double v59 = v58;
                if (v58 < -3.40282347e38) {
                  double v59 = -3.40282347e38;
                }
              }
              float v60 = v59;
              *v55++ = v60;
              LODWORD(v19) = v19 - 1;
            }
            while (v19);
          }
          break;
        case 0x10:
          if (v19)
          {
            unsigned int v49 = v20;
            uint64_t v50 = v18;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                TIFFSwabLong8(v50);
              }
              unint64_t v51 = (unint64_t)*v50++;
              *v49++ = (float)v51;
              LODWORD(v19) = v19 - 1;
            }
            while (v19);
          }
          break;
        case 0x11:
          if (v19)
          {
            uint64_t v52 = v20;
            int8x8_t v53 = v18;
            do
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                TIFFSwabLong8(v53);
              }
              uint64_t v54 = (uint64_t)*v53++;
              *v52++ = (float)v54;
              LODWORD(v19) = v19 - 1;
            }
            while (v19);
          }
          break;
        default:
          break;
      }
      _TIFFfreeExt(a1, (char *)v18);
      uint64_t result = 0;
      *a3 = (int8x8_t *)v22;
    }
    else
    {
      _TIFFfreeExt(a1, (char *)v18);
      return 7;
    }
  }
  return result;
}

uint64_t TIFFReadDirEntryIfd8Array(uint64_t a1, uint64_t a2, int8x8_t **a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a2 + 2);
  BOOL v4 = v3 > 0x12;
  int v5 = (1 << v3) & 0x52010;
  if (v4 || v5 == 0) {
    return 2;
  }
  unsigned int v27 = 0;
  int v26 = 0;
  uint64_t result = TIFFReadDirEntryArrayWithLimit(a1, a2, &v27, 8u, (void **)&v26, 0xFFFFFFFFFFFFFFFFLL);
  if (result || (uint8x8_t v17 = v26) == 0)
  {
    *a3 = 0;
  }
  else if ((*(unsigned __int16 *)(a2 + 2) | 2) == 0x12)
  {
    *a3 = v26;
    if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
      TIFFSwabArrayOfLong8(v17, v27);
    }
    return 0;
  }
  else
  {
    unsigned int v18 = v27;
    uint64_t v19 = (int8x8_t *)_TIFFmallocExt((void *)a1, 8 * v27, v11, v12, v13, v14, v15, v16);
    if (v19)
    {
      int8x8_t v21 = v19;
      int v22 = *(unsigned __int16 *)(a2 + 2);
      if ((v22 == 13 || v22 == 4) && v18)
      {
        int8x8_t v23 = v19;
        int8x8_t v24 = (__int32 *)v17;
        do
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            int8x8_t v20 = TIFFSwabLong(v24, (uint8x8_t)v20);
          }
          unsigned __int32 v25 = *v24++;
          *v23++ = (int8x8_t)v25;
          --v18;
        }
        while (v18);
      }
      _TIFFfreeExt(a1, (char *)v17);
      uint64_t result = 0;
      *a3 = v21;
    }
    else
    {
      _TIFFfreeExt(a1, (char *)v17);
      return 7;
    }
  }
  return result;
}

uint64_t TIFFReadDirEntryCheckedRational(uint64_t a1, uint64_t a2, double *a3, uint8x8_t a4)
{
  uint64_t __dst = 0;
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x80000) != 0)
  {
    uint64_t __dst = *(void *)(a2 + 16);
    if ((v5 & 0x80) == 0)
    {
LABEL_9:
      double v9 = 0.0;
      if (__dst) {
        BOOL v10 = HIDWORD(__dst) == 0;
      }
      else {
        BOOL v10 = 1;
      }
      if (!v10) {
        double v9 = (double)__dst / (double)HIDWORD(__dst);
      }
      uint64_t result = 0;
      *a3 = v9;
      return result;
    }
LABEL_8:
    TIFFSwabArrayOfLong((__int32 *)&__dst, 2, a4);
    goto LABEL_9;
  }
  unsigned __int32 v7 = *(_DWORD *)(a2 + 16);
  unsigned __int32 v11 = v7;
  if ((v5 & 0x80) != 0)
  {
    TIFFSwabLong((__int32 *)&v11, a4);
    unsigned __int32 v7 = v11;
  }
  uint64_t result = TIFFReadDirEntryData(a1, v7, 8, &__dst);
  if (!result)
  {
    if ((*(_DWORD *)(a1 + 16) & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  return result;
}

uint64_t TIFFReadDirEntryCheckedSrational(uint64_t a1, uint64_t a2, double *a3, uint8x8_t a4)
{
  uint64_t __dst = 0;
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x80000) != 0)
  {
    uint64_t __dst = *(void *)(a2 + 16);
    if ((v5 & 0x80) == 0)
    {
LABEL_9:
      double v9 = 0.0;
      if (__dst) {
        BOOL v10 = HIDWORD(__dst) == 0;
      }
      else {
        BOOL v10 = 1;
      }
      if (!v10) {
        double v9 = (double)(int)__dst / (double)HIDWORD(__dst);
      }
      uint64_t result = 0;
      *a3 = v9;
      return result;
    }
LABEL_8:
    TIFFSwabArrayOfLong((__int32 *)&__dst, 2, a4);
    goto LABEL_9;
  }
  unsigned __int32 v7 = *(_DWORD *)(a2 + 16);
  unsigned __int32 v11 = v7;
  if ((v5 & 0x80) != 0)
  {
    TIFFSwabLong((__int32 *)&v11, a4);
    unsigned __int32 v7 = v11;
  }
  uint64_t result = TIFFReadDirEntryData(a1, v7, 8, &__dst);
  if (!result)
  {
    if ((*(_DWORD *)(a1 + 16) & 0x80) == 0) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  return result;
}

uint64_t TIFFReadDirEntryCheckedDouble(uint64_t a1, int8x8_t *a2, int8x8_t *__dst, uint8x8_t a4)
{
  int v5 = *(_DWORD *)(a1 + 16);
  if ((v5 & 0x80000) != 0)
  {
    *uint64_t __dst = a2[2];
    if ((v5 & 0x80) == 0) {
      return 0;
    }
LABEL_8:
    TIFFSwabLong8(__dst);
    return 0;
  }
  unsigned __int32 v7 = a2[2].u32[0];
  unsigned __int32 v9 = v7;
  if ((v5 & 0x80) != 0)
  {
    TIFFSwabLong((__int32 *)&v9, a4);
    unsigned __int32 v7 = v9;
  }
  uint64_t result = TIFFReadDirEntryData(a1, v7, 8, __dst);
  if (!result)
  {
    if ((*(_DWORD *)(a1 + 16) & 0x80) == 0) {
      return 0;
    }
    goto LABEL_8;
  }
  return result;
}

uint64_t TIFFReadDirEntryLong8ArrayWithLimit(uint64_t a1, uint64_t a2, int8x8_t **a3, unint64_t a4)
{
  unsigned int v4 = *(unsigned __int16 *)(a2 + 2);
  BOOL v5 = v4 > 0x11;
  int v6 = (1 << v4) & 0x3035A;
  if (v5 || v6 == 0) {
    return 2;
  }
  unsigned int v48 = 0;
  unsigned int v47 = 0;
  uint64_t v17 = TIFFReadDirEntryArrayWithLimit(a1, a2, &v48, 8u, (void **)&v47, a4);
  if (v17 || (unsigned int v18 = v47) == 0)
  {
    *a3 = 0;
  }
  else
  {
    int v19 = *(unsigned __int16 *)(a2 + 2);
    if (v19 == 16)
    {
      *a3 = v47;
      if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
        TIFFSwabArrayOfLong8(v18, v48);
      }
      return 0;
    }
    else if (v19 == 17)
    {
      unsigned int v20 = v48;
      if (v48)
      {
        int8x8_t v21 = v47;
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            TIFFSwabLong8(v21);
          }
          if (((*(unint64_t *)v21 >> 61) & 4) != 0) {
            break;
          }
          ++v21;
          if (!--v20) {
            goto LABEL_15;
          }
        }
        uint64_t v17 = (*(unint64_t *)v21 >> 61) & 4;
        uint64_t v29 = a1;
        unsigned int v30 = (char *)v18;
LABEL_64:
        _TIFFfreeExt(v29, v30);
        return v17;
      }
LABEL_15:
      uint64_t v17 = 0;
      *a3 = v18;
    }
    else
    {
      unsigned int v22 = v48;
      int8x8_t v23 = (char *)_TIFFmallocExt((void *)a1, 8 * v48, v11, v12, v13, v14, v15, v16);
      if (v23)
      {
        unsigned __int32 v25 = v23;
        switch(*(_WORD *)(a2 + 2))
        {
          case 1:
            if (v22)
            {
              int v26 = v23;
              unsigned int v27 = v18;
              do
              {
                unsigned int v28 = v27->u8[0];
                unsigned int v27 = (int8x8_t *)((char *)v27 + 1);
                *(void *)int v26 = v28;
                v26 += 8;
                --v22;
              }
              while (v22);
            }
            goto LABEL_59;
          case 3:
            if (v22)
            {
              unsigned int v31 = v23;
              int8x8_t v32 = v18;
              do
              {
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  TIFFSwabShort(v32);
                }
                unsigned int v33 = v32->u16[0];
                int8x8_t v32 = (int8x8_t *)((char *)v32 + 2);
                *(void *)unsigned int v31 = v33;
                v31 += 8;
                --v22;
              }
              while (v22);
            }
            goto LABEL_59;
          case 4:
            if (v22)
            {
              int8x8_t v34 = v23;
              unsigned int v35 = (__int32 *)v18;
              do
              {
                if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                  int8x8_t v24 = TIFFSwabLong(v35, (uint8x8_t)v24);
                }
                unsigned __int32 v36 = *v35++;
                *(void *)int8x8_t v34 = v36;
                v34 += 8;
                --v22;
              }
              while (v22);
            }
            goto LABEL_59;
          case 6:
            if (!v22) {
              goto LABEL_59;
            }
            int v37 = v23;
            int v38 = v18;
            while (1)
            {
              unsigned int v39 = v38->u8[0];
              if (((v39 >> 5) & 4) != 0) {
                break;
              }
              int v38 = (int8x8_t *)((char *)v38 + 1);
              *(void *)int v37 = (char)v39;
              v37 += 8;
              if (!--v22) {
                goto LABEL_59;
              }
            }
            uint64_t v17 = (v39 >> 5) & 4;
            goto LABEL_63;
          case 8:
            if (!v22) {
              goto LABEL_59;
            }
            unsigned int v40 = v23;
            int v41 = v18;
            while (1)
            {
              if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
                TIFFSwabShort(v41);
              }
              unsigned int v42 = v41->u16[0];
              if (((v42 >> 13) & 4) != 0) {
                break;
              }
              int v41 = (int8x8_t *)((char *)v41 + 2);
              *(void *)unsigned int v40 = (__int16)v42;
              v40 += 8;
              if (!--v22) {
                goto LABEL_59;
              }
            }
            uint64_t v17 = (v42 >> 13) & 4;
            goto LABEL_63;
          case 9:
            if (!v22) {
              goto LABEL_59;
            }
            unsigned int v43 = v23;
            int v44 = (__int32 *)v18;
            break;
          default:
            goto LABEL_59;
        }
        while (1)
        {
          if ((*(unsigned char *)(a1 + 16) & 0x80) != 0) {
            int8x8_t v24 = TIFFSwabLong(v44, (uint8x8_t)v24);
          }
          uint64_t v45 = *v44;
          if (((v45 >> 29) & 4) != 0) {
            break;
          }
          ++v44;
          *(void *)unsigned int v43 = v45;
          v43 += 8;
          if (!--v22)
          {
LABEL_59:
            _TIFFfreeExt(a1, (char *)v18);
            uint64_t v17 = 0;
            *a3 = (int8x8_t *)v25;
            return v17;
          }
        }
        uint64_t v17 = (v45 >> 29) & 4;
LABEL_63:
        _TIFFfreeExt(a1, (char *)v18);
        uint64_t v29 = a1;
        unsigned int v30 = v25;
        goto LABEL_64;
      }
      _TIFFfreeExt(a1, (char *)v18);
      return 7;
    }
  }
  return v17;
}

void allocChoppedUpStripArrays(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4)
{
  unint64_t v8 = _TIFFGetStrileOffsetOrByteCountValue(a1, 0);
  uint64_t v9 = _TIFFGetStrileOffsetOrByteCountValue(a1, (*(_DWORD *)(a1 + 228) - 1));
  uint64_t v10 = _TIFFGetStrileOffsetOrByteCountValue(a1, (*(_DWORD *)(a1 + 228) - 1));
  if (!__CFADD__(v10, v9))
  {
    unint64_t v15 = v10 + v9 - v8;
    if (v10 + v9 >= v8)
    {
      if (a2 <= 0x640000
        || 16 * (unint64_t)a2 <= (*(uint64_t (**)(void))(a1 + 1240))(*(void *)(a1 + 1200)))
      {
        uint64_t v17 = a2;
        unsigned int v18 = (char *)_TIFFCheckMalloc((const char **)a1, a2, 8, (uint64_t)"for chopped \"StripByteCounts\" array", v11, v12, v13, v14);
        int8x8_t v23 = (char *)_TIFFCheckMalloc((const char **)a1, a2, 8, (uint64_t)"for chopped \"StripOffsets\" array", v19, v20, v21, v22);
        unsigned int v30 = v23;
        if (v18 && v23)
        {
          if (a2)
          {
            unsigned int v31 = (unint64_t *)v23;
            int8x8_t v32 = v18;
            do
            {
              if (a3 >= v15) {
                a3 = v15;
              }
              *(void *)int8x8_t v32 = a3;
              v32 += 8;
              if (a3) {
                unint64_t v33 = v8;
              }
              else {
                unint64_t v33 = 0;
              }
              *v31++ = v33;
              v8 += a3;
              v15 -= a3;
              --v17;
            }
            while (v17);
          }
          *(_DWORD *)(a1 + 224) = a2;
          *(_DWORD *)(a1 + 228) = a2;
          _cg_TIFFSetField(a1, 278, v24, v25, v26, v27, v28, v29, a4);
          _TIFFfreeExt(a1, *(char **)(a1 + 240));
          _TIFFfreeExt(a1, *(char **)(a1 + 232));
          *(void *)(a1 + 232) = v30;
          *(void *)(a1 + 240) = v18;
          *(_DWORD *)(a1 + 16) |= 0x4000000u;
        }
        else
        {
          if (v18) {
            _TIFFfreeExt(a1, v18);
          }
          if (v30)
          {
            _TIFFfreeExt(a1, v30);
          }
        }
      }
      else
      {
        TIFFWarningExtR(a1, "allocChoppedUpStripArrays", "Requested memory size for StripByteCount and StripOffsets %llu is greater than filesize %llu. Memory not allocated", v16, v11, v12, v13, v14, 16 * a2);
      }
    }
  }
}

void BCTextureImp::~BCTextureImp(BCTextureImp *this, uint64_t a2, const char *a3)
{
  *(void *)this = &unk_1ED4DF0F0;
  if (*((void *)this + 3))
  {
    uint64_t Source = (IIOImageRead **)CGImageSourceGetSource(*((void *)this + 4));
    if (Source) {
      IIOImageReadSession::releaseBytePointer(Source, *((void **)this + 3));
    }
  }
  BOOL v5 = (const void *)*((void *)this + 4);
  if (v5) {
    CFRelease(v5);
  }
  *((void *)this + 4) = 0;

  _cg_jpeg_mem_term(this, a2, a3);
}

{
  uint64_t vars8;

  BCTextureImp::~BCTextureImp(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t BCTextureImp::loadDataFromXPCObject(BCTextureImp *this, xpc_object_t xdict)
{
  size_t length = 0;
  data = xpc_dictionary_get_data(xdict, "iio_xpc_plugin_data_bc_imp", &length);
  if (length == 544)
  {
    memcpy((char *)this + 16, data, 0x220uLL);
    *((void *)this + ++*((_DWORD *)this + 3) = 0;
    *((void *)this + 4) = 0;
    *((void *)this + 2) = 0;
  }
  return 0;
}

uint64_t BCTextureImp::saveDataToXPCObject(BCTextureImp *this, void *a2)
{
  return 0;
}

uint64_t BCTextureImp::textureDataLockData(BCTextureImp *this, IIOImageReadSession *a2, unint64_t a3, unint64_t a4, IIOImageRead **a5, unint64_t *a6, unint64_t *a7)
{
  if (!*((void *)this + 2))
  {
    *((void *)this + 2) = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)this + 3, 1);
    uint64_t v13 = (const void *)IIOImageSource::cf(a2);
    *((void *)this + 4) = v13;
    CFRetain(v13);
    if (!*((void *)this + 2)) {
      _cg_jpeg_mem_term("textureDataLockData", 140, "*** Can't access image data\n");
    }
  }
  if (a3 >= 0x1F) {
    a3 = 31;
  }
  *a5 = IIOImageReadSession::getSize(a2);
  uint64_t result = *((void *)this + 2);
  unint64_t v15 = (char *)this + 8 * a3 + 16;
  *a6 = *((void *)v15 + 4);
  *a7 = *((void *)v15 + 36);
  return result;
}

uint64_t BCReadPlugin::BCReadPlugin(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  int v6 = (void *)IIOReadPlugin::IIOReadPlugin(a1, a2, a3, a4, a5);
  *int v6 = &unk_1ED4DEFC8;
  v6[62] = 0;
  v6[63] = 0;
  unsigned __int32 v7 = operator new(0x248uLL);
  v7[1] = 0;
  unsigned __int16 v7[2] = 0;
  *unsigned __int32 v7 = &unk_1ED4EF2A0;
  *((_DWORD *)v7 + 8) = *(_DWORD *)(a1 + 208);
  _OWORD v7[3] = &unk_1ED4DF0F0;
  bzero(v7 + 5, 0x220uLL);
  *(void *)(a1 + 49jp2_colour_converter::clear(this + 6) = v7 + 3;
  *(void *)(a1 + 504) = v7;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 45jp2_colour_converter::clear(this + 6) = 0u;
  *(_OWORD *)(a1 + 472) = 0u;
  *(void *)(a1 + 488) = 0;
  return a1;
}

void sub_1887082C8(_Unwind_Exception *a1)
{
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

void BCReadPlugin::BCReadPlugin(uint64_t a1, uint64_t a2)
{
}

void sub_1887083A8(_Unwind_Exception *a1)
{
  IIOReadPlugin::~IIOReadPlugin(v1);
  _Unwind_Resume(a1);
}

void BCReadPlugin::~BCReadPlugin(BCReadPlugin *this)
{
  *(void *)this = &unk_1ED4DEFC8;
  unsigned int v2 = (const void *)*((void *)this + 61);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *((void *)this + 59);
  if (v3) {
    (**(void (***)(void))(v3 + 8))();
  }
  unsigned int v4 = (std::__shared_weak_count *)*((void *)this + 63);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }

  IIOReadPlugin::~IIOReadPlugin(this);
}

{
  uint64_t vars8;

  BCReadPlugin::~BCReadPlugin(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t BCReadPlugin::setupCallback(uint64_t a1, CFDictionaryRef *a2)
{
  int v2 = *(__int16 *)(a1 + 376);
  if (v2 == 13) {
    return IIOReadPlugin::setupImageProviderCallbackV3(a1, a2);
  }
  if (v2 == 1) {
    return IIOReadPlugin::setupCallback(a1, a2);
  }
  return 4294967246;
}

uint64_t BCReadPlugin::loadDataFromXPCObject(BCReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    size_t length = 0;
    data = (long long *)xpc_dictionary_get_data(a2, "iio_xpc_plugin_data_bc", &length);
    if (length == 48)
    {
      long long v6 = *data;
      long long v7 = data[2];
      *(_OWORD *)((char *)this + 45jp2_colour_converter::clear(this + 6) = data[1];
      *(_OWORD *)((char *)this + 472) = v7;
      *(_OWORD *)((char *)this + 440) = v6;
      *((void *)this + 59) = 0;
      return (*(uint64_t (**)(void, void *))(**((void **)this + 62) + 16))(*((void *)this + 62), a2);
    }
    else
    {
      return 4294967246;
    }
  }
  return result;
}

uint64_t BCReadPlugin::saveDataToXPCObject(BCReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!result)
  {
    iio_xpc_dictionary_add_databuffer(a2, "iio_xpc_plugin_data_bc", (char *)this + 440, 0x30uLL);
    BOOL v5 = *(uint64_t (**)(void))(**((void **)this + 62) + 24);
    return v5();
  }
  return result;
}

uint64_t BCReadPlugin::initialize(BCReadPlugin *this, IIODictionary *a2)
{
  v92[7] = *MEMORY[0x1E4F143B8];
  int __dst = 0;
  uint64_t v80 = 0;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v76, *((IIOImageReadSession **)this + 3));
  if (!*((unsigned char *)this + 341)) {
    goto LABEL_104;
  }
  uint64_t v3 = *((void *)this + 62);
  int v4 = *((_DWORD *)this + 51);
  switch(v4)
  {
    case 1262633838:
      long long v89 = 0u;
      long long v90 = 0u;
      int8x16_t v87 = 0u;
      long long v88 = 0u;
      if (IIOScanner::getBytesAtOffset((IIOScanner *)&v76, &v87, *((void *)this + 24), 0x40uLL) == 64)
      {
        SwapKTXHeader(&v87);
        __int32 v21 = v87.i32[3];
        *((_DWORD *)this + 11++*((_DWORD *)this + 3) = HIDWORD(v88);
        *((unsigned char *)this + 344) = v21 == 67305985;
        int32x2_t v74 = *(int32x2_t *)((char *)&v89 + 4);
        unsigned int Size = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
        LODWORD(v14) = v74.i32[0];
        if ((unint64_t)Size <= v74.u32[0])
        {
          uint64_t v71 = 573;
        }
        else
        {
          LODWORD(v20) = v74.i32[1];
          if ((unint64_t)Size > v74.u32[1])
          {
            *((uint32x2_t *)this + 57) = vshr_n_u32((uint32x2_t)vadd_s32(v74, (int32x2_t)0x300000003), 2uLL);
            unsigned int v23 = DWORD2(v90);
            unint64_t v24 = HIDWORD(v90) + 64;
            *((void *)this + 24) = v24;
            if (v23 >= 0x1F) {
              int v25 = 31;
            }
            else {
              int v25 = v23;
            }
            *((_DWORD *)this + 112) = v25;
            if (v25)
            {
              unint64_t v26 = 0;
              unint64_t v27 = v77;
              uint64_t v28 = v24;
              while (1)
              {
                *(void *)uint64_t v82 = 0;
                if (IIOScanner::getBytesAtOffset((IIOScanner *)&v76, v82, v28, 8uLL) != 8) {
                  break;
                }
                uint64_t v29 = v28 + 4;
                unint64_t v30 = v27 - (v28 + 4);
                if (v27 <= v28 + 4)
                {
                  *((_DWORD *)this + 112) = v26;
                  goto LABEL_58;
                }
                if (*(void *)v82 < v30) {
                  unint64_t v30 = *(void *)v82;
                }
                if (v26 <= 0x1F)
                {
                  uint64_t v31 = v3 + 8 * v26;
                  *(void *)(v31 + 48) = v29;
                  *(void *)(v31 + 304) = v30;
                }
                unint64_t v24 = v30 + v29;
                uint64_t v28 = ((v30 + 3) & 0xFFFFFFFFFFFFFFFCLL) + v29;
                if (++v26 >= *((unsigned int *)this + 112)) {
                  goto LABEL_58;
                }
              }
              _cg_jpeg_mem_term("initialize", 592, "*** BC - failed to read %d bytes\n", 8);
              goto LABEL_104;
            }
LABEL_58:
            unint64_t v32 = *((unsigned int *)this + 115) * (unint64_t)*((unsigned int *)this + 114);
            unsigned int v33 = BCReadPlugin::bytesPerBlock((BCReadPlugin *)*((unsigned int *)this + 113));
            if (!is_mul_ok(v32, v33))
            {
              _cg_jpeg_mem_term("initialize", 622, "*** ERROR: BC-image too big\n");
              goto LABEL_104;
            }
            if (*(void *)(v3 + 304) < v32 * v33)
            {
              _cg_jpeg_mem_term("initialize", 624, "*** ERROR: BC-levelSize too small\n");
              goto LABEL_104;
            }
            if (v24 > (unint64_t)IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3)))
            {
              uint64_t v72 = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
              _cg_jpeg_mem_term("initialize", 625, "***ERROR: BC (KTX) file truncated. File Size: %lu, expected %lu\n", v72, v24);
              goto LABEL_104;
            }
            *((void *)this + 55) = *(void *)(v3 + 304);
            *((void *)this + 24) += 4;
            goto LABEL_62;
          }
          uint64_t v71 = 574;
        }
        _cg_jpeg_mem_term("initialize", v71, "*** bad dimension: %d x %d  (fileSize: %d)\n", v74.i32[0], v74.i32[1], Size);
      }
LABEL_104:
      kdebug_trace();
      uint64_t v41 = 4294967246;
      goto LABEL_105;
    case 1261584963:
      long long v85 = 0u;
      long long v86 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      *(_OWORD *)uint64_t v82 = 0u;
      if (IIOScanner::getBytesAtOffset((IIOScanner *)&v76, v82, *((void *)this + 24), 0x50uLL) != 80
        || !IsKTX2Header(v82))
      {
        goto LABEL_104;
      }
      if (v83 != 1)
      {
        _cg_jpeg_mem_term("initialize", 646, "*** ERROR: Invalid typeSize (%d). typeSize must be 1 for block-compressed or supercompressed formats.");
        goto LABEL_104;
      }
      if ((unint64_t)v77 <= v84)
      {
        _cg_jpeg_mem_term("initialize", 647, "*** ERROR: Invalid numberOfArrayElements (%d).");
        goto LABEL_104;
      }
      if ((unint64_t)v77 <= v85)
      {
        _cg_jpeg_mem_term("initialize", 648, "*** ERROR: Invalid dfdOffset (%d).");
        goto LABEL_104;
      }
      if ((unint64_t)v77 <= DWORD1(v85))
      {
        _cg_jpeg_mem_term("initialize", 649, "*** ERROR: Invalid dfdLength (%d).");
        goto LABEL_104;
      }
      if ((unint64_t)v77 <= DWORD2(v85))
      {
        _cg_jpeg_mem_term("initialize", 650, "*** ERROR: Invalid kvdOffset (%d).");
        goto LABEL_104;
      }
      if ((unint64_t)v77 <= HIDWORD(v85))
      {
        _cg_jpeg_mem_term("initialize", 651, "*** ERROR: Invalid kvdLength (%d).");
        goto LABEL_104;
      }
      if ((unint64_t)v86 >= (unint64_t)v77)
      {
        _cg_jpeg_mem_term("initialize", 652, "*** ERROR: Invalid scgdOffset (%d).");
        goto LABEL_104;
      }
      if (*((void *)&v86 + 1) >= (unint64_t)v77)
      {
        _cg_jpeg_mem_term("initialize", 653, "*** ERROR: Invalid scgdLength (%d).");
        goto LABEL_104;
      }
      long long v91 = 0u;
      memset(v92, 0, 24);
      long long v89 = 0u;
      long long v90 = 0u;
      int8x16_t v87 = 0u;
      long long v88 = 0u;
      uint64_t v75 = 0;
      if (!CreateKtxStream((uint64_t)&v87, *((IIOImageReadSession **)this + 3)))
      {
        int v16 = ktxTexture2_CreateFromStream(&v87, 0, &v75);
        if (v16)
        {
          _cg_jpeg_mem_term("initialize", 662, "*** ERROR: ktxTexture2_CreateFromStream failed [%d]\n", v16);
          goto LABEL_104;
        }
        *((void *)this + 59) = v75;
        int v17 = v82[3];
        *((_DWORD *)this + 120) = v82[3];
        *((_DWORD *)this + 11++*((_DWORD *)this + 3) = GLFormatForVulkanFormat(v17);
        *((unsigned char *)this + 344) = 0;
        uint64_t v18 = *(void *)((char *)&v83 + 4);
        *((uint32x2_t *)this + 57) = vshr_n_u32((uint32x2_t)vadd_s32(*(int32x2_t *)((char *)&v83 + 4), (int32x2_t)0x300000003), 2uLL);
        int v19 = DWORD2(v84);
        if (DWORD2(v84) >= 0x1F) {
          int v19 = 31;
        }
        *((_DWORD *)this + 112) = v19;
        *((void *)this + 55) = *(void *)(v3 + 304);
        LODWORD(v20) = HIDWORD(v18);
        LODWORD(v14) = v18;
        goto LABEL_62;
      }
      goto LABEL_104;
    case 1145193326:
      memset(v92, 0, 44);
      long long v90 = 0u;
      long long v91 = 0u;
      long long v88 = 0u;
      long long v89 = 0u;
      int8x16_t v87 = 0u;
      memset(v82, 0, sizeof(v82));
      LODWORD(v8++*((_DWORD *)this + 3) = 0;
      if (IIOScanner::getBytesAtOffset((IIOScanner *)&v76, &__dst, *((void *)this + 24), 4uLL) != 4) {
        goto LABEL_104;
      }
      BOOL v5 = IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3));
      if (__dst != 542327876) {
        goto LABEL_104;
      }
      unint64_t v6 = (unint64_t)v5;
      *((void *)this + 24) = 4;
      if (IIOScanner::getBytesAtOffset((IIOScanner *)&v76, &v87, 4, 0x7CuLL) != 124) {
        goto LABEL_104;
      }
      __int32 v8 = v87.i32[1];
      if (v87.i8[4])
      {
        int v9 = v87.i8[4] & 6;
        uint64_t v10 = "*** ERROR: ddsHeader.dwFlags is missing 'has_DDSD_WIDTH'\n";
        if ((v87.i8[4] & 2) != 0) {
          unsigned int v11 = 362;
        }
        else {
          unsigned int v11 = 361;
        }
        if ((v87.i8[4] & 2) == 0) {
          uint64_t v10 = "*** ERROR: ddsHeader.dwFlags is missing 'DDSD_HEIGHT'\n";
        }
        if (v9 == 6) {
          uint64_t v12 = 363;
        }
        else {
          uint64_t v12 = v11;
        }
        if (v9 == 6) {
          uint64_t v13 = "*** ERROR: ddsHeader.dwFlags is missing 'DDSD_PIXELFORMAT'\n";
        }
        else {
          uint64_t v13 = v10;
        }
        if ((~v87.i32[1] & 0x1006) == 0)
        {
          *((void *)this + 24) += 124;
          *((unsigned char *)this + 344) = 0;
          uint64_t v14 = v87.u32[3];
          if ((v8 & 8) != 0)
          {
            unsigned __int32 v15 = v88;
          }
          else if ((v87.i32[3] + 3) >= 4)
          {
            unsigned __int32 v15 = (v87.i32[3] + 3) & 0xFFFFFFFC;
          }
          else
          {
            unsigned __int32 v15 = 4;
          }
          uint64_t v20 = v87.u32[2];
          if (v6 <= v87.u32[3])
          {
            uint64_t v73 = 375;
          }
          else
          {
            if (v6 > v87.u32[2])
            {
              if (v6 <= v15)
              {
                _cg_jpeg_mem_term("initialize", 377, "*** ERROR: bad pitchOrLinearSize: %d  (fileSize: %ld)\n", v15, v6);
                goto LABEL_104;
              }
              *((_DWORD *)this + 114) = (v87.i32[3] + 3) >> 2;
              *((_DWORD *)this + 115) = (v20 + 3) >> 2;
              if ((v8 & 0x20000) != 0)
              {
                unsigned int v42 = DWORD2(v88);
                if (DWORD2(v88))
                {
                  unsigned int v43 = v14 <= v20 ? v20 : v14;
                  double v7 = log((double)v43) / 0.693147181;
                  if (v42 > v7) {
                    *(void *)&double v7 = _cg_jpeg_mem_term("initialize", 386, "*** ERROR: bad dwMipMapCount (%d) max: %d\n", v42, v7).n128_u64[0];
                  }
                }
              }
              int v44 = bswap32(v92[0]);
              if (v44)
              {
                if (v44 != 1146630448)
                {
                  if (v44 == 1146639409)
                  {
                    uint64_t v45 = (2 * v14 + 6) & 0x3FFFFFFF8;
                    if (!v14) {
                      uint64_t v45 = 8;
                    }
                    unint64_t v46 = v45 * v20;
                    if (v6 <= v46 >> 2)
                    {
                      _cg_jpeg_mem_term("initialize", 407, "*** ERROR: corrupt file:  pitch*height: %ld  (fileSize: %ld)\n", v46, v6);
                      goto LABEL_104;
                    }
                  }
                  goto LABEL_102;
                }
                if (IIOScanner::getBytesAtOffset((IIOScanner *)&v76, v82, *((void *)this + 24), 0x14uLL) != 20) {
                  goto LABEL_104;
                }
                *((void *)this + 24) += 20;
                uint64_t v47 = dxgi_to_gl(v82[0]);
                *((_DWORD *)this + 11++*((_DWORD *)this + 3) = v47;
                if (v47 || v82[0] != 87) {
                  goto LABEL_103;
                }
                *((_DWORD *)this + 11++*((_DWORD *)this + 3) = 34952;
                *((_DWORD *)this + 121) = HIDWORD(v92[0]);
                *(_OWORD *)&v92[1] = xmmword_18898F730;
                int v48 = 33619971;
LABEL_151:
                *((_DWORD *)this + 11jp2_colour_converter::clear(this + 6) = v48;
                uint64_t v47 = 34952;
                goto LABEL_152;
              }
              if ((BYTE12(v91) & 0x40) == 0)
              {
LABEL_102:
                uint64_t v47 = fourcc_to_gl(v44);
                *((_DWORD *)this + 11++*((_DWORD *)this + 3) = v47;
LABEL_103:
                if (!v47) {
                  goto LABEL_104;
                }
LABEL_152:
                unsigned int v58 = DWORD2(v88);
                if (DWORD2(v88) >= 0x1F) {
                  unsigned int v58 = 31;
                }
                if ((v8 & 0x20000) == 0) {
                  unsigned int v58 = 1;
                }
                *((_DWORD *)this + 112) = v58;
                if (v58 <= 1) {
                  uint64_t v59 = 1;
                }
                else {
                  uint64_t v59 = v58;
                }
                unint64_t v60 = *((void *)this + 24);
                unint64_t v61 = 0;
                unsigned int v62 = BCReadPlugin::bytesPerBlock((BCReadPlugin *)v47);
                while (1)
                {
                  unsigned int v63 = (v14 >> v61) + 3;
                  if (v63 <= 7) {
                    uint64_t v64 = 1;
                  }
                  else {
                    uint64_t v64 = v63 >> 2;
                  }
                  unsigned int v65 = (v20 >> v61) + 3;
                  if (v65 <= 7) {
                    unsigned int v66 = 1;
                  }
                  else {
                    unsigned int v66 = v65 >> 2;
                  }
                  unint64_t v67 = v62 * (unint64_t)v66 * v64;
                  if (v61 <= 0x1F)
                  {
                    uint64_t v68 = v3 + 8 * v61;
                    *(void *)(v68 + 48) = v60;
                    *(void *)(v68 + 304) = v67;
                  }
                  BOOL v69 = __CFADD__(v60, v67);
                  v60 += v67;
                  if (v69) {
                    goto LABEL_104;
                  }
                  if (v60 > (unint64_t)IIOImageReadSession::getSize(*((IIOImageReadSession **)this + 3)))
                  {
                    *(void *)&double v70 = _cg_jpeg_mem_term("initialize", 544, "*** WARNING: file truncated. Only the first %lu miplevels of %lu complete\n", v61, *((unsigned int *)this + 112)).n128_u64[0];
                    *((_DWORD *)this + 112) = v61;
                    if (v61)
                    {
LABEL_173:
                      *((void *)this + 55) = *(void *)(v3 + 304);
                      goto LABEL_62;
                    }
                    _cg_jpeg_mem_term("initialize", 549, "*** ERROR: file to small to contain a single image / miplevel\n", v70);
                    goto LABEL_104;
                  }
                  if (v59 == ++v61) {
                    goto LABEL_173;
                  }
                }
              }
              *((_DWORD *)this + 11++*((_DWORD *)this + 3) = 34952;
              int v50 = HIDWORD(v92[0]);
              unsigned int v51 = v92[1];
              *((_DWORD *)this + 121) = HIDWORD(v92[0]);
              int v52 = bswap32(v51);
              int v53 = bswap32(HIDWORD(v92[1]));
              v92[1] = __PAIR64__(v53, v52);
              int v54 = bswap32(v92[2]);
              int v55 = bswap32(HIDWORD(v92[2]));
              v92[2] = __PAIR64__(v55, v54);
              if ((v53 & v52) != 0)
              {
                _cg_jpeg_mem_term("initialize", 449, "*** overlapping R-G channels\n", v7);
                goto LABEL_104;
              }
              if ((v54 & v52) != 0)
              {
                _cg_jpeg_mem_term("initialize", 450, "*** overlapping R-B channels\n", v7);
                goto LABEL_104;
              }
              if ((v54 & v53) != 0)
              {
                _cg_jpeg_mem_term("initialize", 451, "*** overlapping G-B channels\n", v7);
                goto LABEL_104;
              }
              if ((v55 & v52) != 0)
              {
                _cg_jpeg_mem_term("initialize", 453, "*** overlapping R-A channels\n", v7);
                goto LABEL_104;
              }
              if ((v55 & v53) != 0)
              {
                _cg_jpeg_mem_term("initialize", 454, "*** overlapping G-A channels\n", v7);
                goto LABEL_104;
              }
              if ((v55 & v54) != 0)
              {
                _cg_jpeg_mem_term("initialize", 455, "*** overlapping B-A channels\n", v7);
                goto LABEL_104;
              }
              int v56 = v53 | v52 | v54 | v55;
              if (v50 == 24)
              {
                if (v56 != -256)
                {
                  uint64_t v57 = 459;
LABEL_203:
                  _cg_jpeg_mem_term("initialize", v57, "*** overlapping RGBA channels?  bitMask: %08X\n", v53 | v52 | v54 | v55);
                  goto LABEL_104;
                }
              }
              else if (v56 != -1)
              {
                uint64_t v57 = 461;
                goto LABEL_203;
              }
              if (v52 > 65279)
              {
                if (v52 == 65280)
                {
                  int v48 = 0x2000000;
                }
                else
                {
                  if (v52 != 16711680) {
                    goto LABEL_104;
                  }
                  int v48 = 0x1000000;
                }
              }
              else if (v52 == -16777216)
              {
                int v48 = 0;
              }
              else
              {
                if (v52 != 255) {
                  goto LABEL_104;
                }
                int v48 = 50331648;
              }
              if (v53 > 65279)
              {
                if (v53 == 65280)
                {
                  v48 |= 0x20000u;
                }
                else
                {
                  if (v53 != 16711680) {
                    goto LABEL_104;
                  }
                  v48 |= 0x10000u;
                }
              }
              else if (v53 != -16777216)
              {
                if (v53 != 255) {
                  goto LABEL_104;
                }
                v48 |= 0x30000u;
              }
              if (v54 > 65279)
              {
                if (v54 == 65280)
                {
                  v48 |= 0x200u;
                }
                else
                {
                  if (v54 != 16711680) {
                    goto LABEL_104;
                  }
                  v48 |= 0x100u;
                }
              }
              else if (v54 != -16777216)
              {
                if (v54 != 255) {
                  goto LABEL_104;
                }
                v48 |= 0x300u;
              }
              if (v55 <= 254)
              {
                if (v55 == -16777216) {
                  goto LABEL_151;
                }
                if (v55) {
                  goto LABEL_104;
                }
              }
              else if (v55 != 255)
              {
                if (v55 == 65280)
                {
                  v48 |= 2u;
                }
                else
                {
                  if (v55 != 16711680) {
                    goto LABEL_104;
                  }
                  v48 |= 1u;
                }
                goto LABEL_151;
              }
              v48 |= 3u;
              goto LABEL_151;
            }
            uint64_t v73 = 376;
          }
          _cg_jpeg_mem_term("initialize", v73, "*** ERROR: bad dimension: %d x %d  (fileSize: %ld)\n", v87.i32[3], v87.i32[2], v6);
          goto LABEL_104;
        }
      }
      else
      {
        uint64_t v13 = "*** ERROR: ddsHeader.dwFlags is missing 'DDSD_CAPS'\n";
        uint64_t v12 = 360;
      }
      _cg_jpeg_mem_term("initialize", v12, v13);
      goto LABEL_104;
  }
  LODWORD(v14) = 0;
  LODWORD(v20) = 0;
LABEL_62:
  *((_DWORD *)this + 57) = v14;
  *((_DWORD *)this + 58) = v20;
  *(int32x2_t *)((char *)this + 292) = vshl_n_s32(*(int32x2_t *)((char *)this + 456), 2uLL);
  int v34 = *((_DWORD *)this + 113);
  char v35 = 2;
  __int16 v36 = 8;
  __int16 v37 = 32;
  if (v34 <= 36493)
  {
    if (v34 == 36283)
    {
      *((_DWORD *)this + 81) = 1196573017;
      *((_DWORD *)this + 60) = 524296;
      *((_WORD *)this + 122) = 1;
      *((unsigned char *)this + 247) = 2;
      if (*((_DWORD *)this + 121) == 24) {
        char v40 = 5;
      }
      else {
        char v40 = 3;
      }
      *((unsigned char *)this + 24jp2_colour_converter::clear(this + 6) = v40;
    }
    else
    {
      if (v34 != 36284)
      {
        char v38 = 2;
        if (v34 != 36286) {
          goto LABEL_69;
        }
        goto LABEL_68;
      }
      *((unsigned char *)this + 345) = 1;
      *((_DWORD *)this + 81) = 1196573017;
      *((void *)this + 30) = 0x100000100100010;
      LODWORD(v14) = 2 * v14;
    }
    unsigned int v39 = (CFStringRef *)MEMORY[0x1E4F1DC00];
    goto LABEL_76;
  }
  char v38 = 2;
  if ((v34 - 36494) < 2)
  {
LABEL_68:
    char v35 = 1;
    *((unsigned char *)this + 345) = 1;
    char v38 = 3;
    __int16 v36 = 16;
    __int16 v37 = 64;
  }
LABEL_69:
  *((_DWORD *)this + 81) = 1380401696;
  *((_WORD *)this + 121) = v37;
  *((_WORD *)this + 120) = v36;
  *((_WORD *)this + 122) = 4;
  *((unsigned char *)this + 247) = v35;
  *((unsigned char *)this + 24jp2_colour_converter::clear(this + 6) = 3;
  LODWORD(v14) = v14 << v38;
  unsigned int v39 = (CFStringRef *)MEMORY[0x1E4F1DC98];
LABEL_76:
  *((_DWORD *)this + 59) = v14;
  *((void *)this + 20) = CGColorSpaceCreateWithName(*v39);
  *((unsigned char *)this + 34jp2_colour_converter::clear(this + 6) = 0;
  getenv("IIO_useV3");
  *((_WORD *)this + 188) = 1;
  if (*((unsigned char *)this + 181)) {
    ImageIOLog("    BC:\n");
  }
  uint64_t v41 = 0;
LABEL_105:
  IIOScanner::~IIOScanner((IIOScanner *)&v76);
  return v41;
}

void sub_1887092C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

uint64_t dxgi_to_gl(int a1)
{
  int v1 = a1 - 71;
  if (a1 - 71) < 0x1D && ((0x1B0036DBu >> v1)) {
    return dword_18898F7A0[v1];
  }
  _cg_jpeg_mem_term("dxgi_to_gl", 1434, "*** ERROR: dxgi-format '%d' not handled\n", a1);
  return 0;
}

uint64_t fourcc_to_gl(int a1)
{
  if (a1 > 1111700818)
  {
    if (a1 > 1146639410)
    {
      if (a1 == 1146639413) {
        return 33779;
      }
      if (a1 == 1146639411) {
        return 33778;
      }
    }
    else
    {
      if (a1 == 1111700819) {
        return 36286;
      }
      if (a1 == 1146639409) {
        return 33777;
      }
    }
    return 0;
  }
  if (a1 == 1096042802) {
    return 36285;
  }
  if (a1 != 1111700563)
  {
    if (a1 == 1111700565) {
      return 36283;
    }
    return 0;
  }
  return 36284;
}

uint64_t BCReadPlugin::bytesPerBlock(BCReadPlugin *this)
{
  if ((this - 33776) >= 2
    && (this - 35916) >= 2
    && (this - 36283) >= 2)
  {
    return 16;
  }
  else
  {
    return 8;
  }
}

uint64_t GLFormatForVulkanFormat(int a1)
{
  if ((a1 - 131) > 0xF) {
    return 0;
  }
  else {
    return dword_18898F814[a1 - 131];
  }
}

uint64_t BCReadPlugin::decode8888toRGBX(BCReadPlugin *this, IIOImageReadSession *a2, vImage_Buffer *a3, CGImageAlphaInfo a4, BOOL a5)
{
  uint64_t v8 = *((void *)this + 62);
  unsigned int v9 = *((_DWORD *)this + 116);
  if (a5) {
    char v10 = 8;
  }
  else {
    char v10 = 24;
  }
  if (a5) {
    char v11 = 24;
  }
  else {
    char v11 = 8;
  }
  permuteMap[0] = v9 >> v10;
  permuteMap[1] = BYTE2(v9);
  permuteMap[2] = v9 >> v11;
  permuteMap[3] = v9;
  uint64_t v12 = *((unsigned int *)this + 52);
  if (v12 > 0x1F) {
    unint64_t v13 = 0;
  }
  else {
    unint64_t v13 = *(void *)(v8 + 8 * v12 + 48);
  }
  if (*((_DWORD *)this + 121) != 24)
  {
    unint64_t v21 = a3->height * a3->rowBytes;
    if (IIOImageReadSession::getBytesAtOffset(a2, a3->data, v13, v21) != v21) {
      return 4294967246;
    }
    vImagePermuteChannels_ARGB8888(a3, a3, permuteMap, 0x10u);
    if (a5) {
      vImagePremultiplyData_RGBA8888(a3, a3, 0x10u);
    }
    return 0;
  }
  size_t v14 = 3 * a3->width;
  unsigned __int32 v15 = malloc_type_malloc(v14, 0x39EEE7A2uLL);
  v24.data = v15;
  v24.CGFloat height = 1;
  v24.rowBytes = v14;
  long long v16 = *(_OWORD *)&a3->width;
  v24.CGFloat width = a3->width;
  *(_OWORD *)&v23.data = xmmword_18898C840;
  *(_OWORD *)&v23.CGFloat width = v16;
  if (!a3->height)
  {
LABEL_15:
    uint64_t v20 = 0;
    if (!v15) {
      return v20;
    }
LABEL_16:
    free(v15);
    return v20;
  }
  uint64_t v17 = 0;
  unsigned int v18 = 1;
  while (IIOImageReadSession::getBytesAtOffset(a2, v15, v13, v14) == v14)
  {
    v23.data = (char *)a3->data + a3->rowBytes * v17;
    vImageConvert_RGB888toRGBA8888(&v24, 0, 0xFFu, &v23, a5, 0x10u);
    uint64_t v17 = v18;
    BOOL v19 = a3->height > v18++;
    v13 += v14;
    if (!v19) {
      goto LABEL_15;
    }
  }
  uint64_t v20 = 4294967246;
  if (v15) {
    goto LABEL_16;
  }
  return v20;
}

uint64_t BCReadPlugin::decodeDXTCtoRGBX(BCReadPlugin *this, IIOImageReadSession *a2, vImage_Buffer *a3, int a4, int a5)
{
  if (a4 > 2) {
    at_alpha_t v8 = at_alpha_not_premultiplied;
  }
  else {
    at_alpha_t v8 = dword_18898F854[a4];
  }
  int v9 = *((_DWORD *)this + 113);
  if (v9 > 36282)
  {
    if (v9 <= 36491)
    {
      at_block_format_t v11 = at_block_format_bc4;
      at_texel_format_t v12 = at_texel_format_l8_unorm;
      switch(v9)
      {
        case 36283:
          goto LABEL_43;
        case 36284:
          at_block_format_t v11 = at_block_format_bc4s;
          at_texel_format_t v12 = at_texel_format_l16_float;
          goto LABEL_43;
        case 36285:
          if (a5) {
            at_texel_format_t v12 = at_texel_format_bgra8_unorm;
          }
          else {
            at_texel_format_t v12 = at_texel_format_rgba8_unorm;
          }
          at_block_format_t v11 = at_block_format_bc5;
          goto LABEL_43;
        case 36286:
          at_block_format_t v11 = at_block_format_bc5s;
          goto LABEL_42;
        default:
          goto LABEL_76;
      }
    }
    if ((v9 - 36492) >= 2)
    {
      if (v9 == 36494)
      {
        at_block_format_t v11 = at_block_format_bc6;
      }
      else
      {
        if (v9 != 36495) {
          goto LABEL_76;
        }
        at_block_format_t v11 = at_block_format_bc6u;
      }
LABEL_42:
      at_texel_format_t v12 = at_texel_format_rgba16_float;
      goto LABEL_43;
    }
    if (a5) {
      at_texel_format_t v12 = at_texel_format_bgra8_unorm;
    }
    else {
      at_texel_format_t v12 = at_texel_format_rgba8_unorm;
    }
    at_block_format_t v11 = at_block_format_bc7;
  }
  else
  {
    if (v9 > 35915)
    {
      if ((v9 - 35916) >= 2)
      {
        if (v9 != 35918)
        {
          int v10 = 35919;
LABEL_15:
          if (v9 == v10)
          {
            if (a5) {
              at_texel_format_t v12 = at_texel_format_bgra8_unorm;
            }
            else {
              at_texel_format_t v12 = at_texel_format_rgba8_unorm;
            }
            at_block_format_t v11 = at_block_format_bc3;
            goto LABEL_43;
          }
LABEL_76:
          _cg_jpeg_mem_term("decodeDXTCtoRGBX", 947, "*** BC - unknown GL pixel format [0x%X]\n", *((_DWORD *)this + 113));
          return 4294967246;
        }
        goto LABEL_28;
      }
    }
    else if ((v9 - 33776) >= 2)
    {
      if (v9 != 33778)
      {
        int v10 = 33779;
        goto LABEL_15;
      }
LABEL_28:
      if (a5) {
        at_texel_format_t v12 = at_texel_format_bgra8_unorm;
      }
      else {
        at_texel_format_t v12 = at_texel_format_rgba8_unorm;
      }
      at_block_format_t v11 = at_block_format_bc2;
      goto LABEL_43;
    }
    if (a5) {
      at_texel_format_t v12 = at_texel_format_bgra8_unorm;
    }
    else {
      at_texel_format_t v12 = at_texel_format_rgba8_unorm;
    }
    at_block_format_t v11 = at_block_format_bc1;
  }
LABEL_43:
  uint64_t v13 = *((void *)this + 62);
  int v44 = 0;
  size_t v14 = IIOImageReadSession::retainBytePointer(a2, (const __CFData **)&v44, 0);
  uint64_t v15 = *((unsigned int *)this + 52);
  if (v15 > 0x1F)
  {
    if (!v14) {
      goto LABEL_50;
    }
    size_t v17 = 0;
    uint64_t v18 = 0;
  }
  else
  {
    if (!v14) {
      goto LABEL_50;
    }
    uint64_t v16 = v13 + 8 * v15;
    size_t v17 = *(void *)(v16 + 304);
    uint64_t v18 = *(void *)(v16 + 48);
  }
  BOOL v19 = (char *)v14 + v18;
  if ((((unint64_t)v14 + v18) & 0xF) == 0)
  {
    unint64_t v26 = 0;
    goto LABEL_61;
  }
  IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v44);
  int v44 = 0;
LABEL_50:
  unsigned int Size = IIOImageReadSession::getSize(a2);
  uint64_t v21 = *((unsigned int *)this + 52);
  if (v21 > 0x1F) {
    uint64_t v22 = 0;
  }
  else {
    uint64_t v22 = *(IIOImageRead **)(v13 + 8 * v21 + 48);
  }
  size_t v17 = Size - v22;
  if (Size == v22) {
    goto LABEL_59;
  }
  BOOL v19 = malloc_type_malloc(Size - v22, 0xB636C175uLL);
  uint64_t v23 = *((unsigned int *)this + 52);
  if (v23 > 0x1F) {
    unint64_t v24 = 0;
  }
  else {
    unint64_t v24 = *(void *)(v13 + 8 * v23 + 48);
  }
  unint64_t BytesAtOffset = IIOImageReadSession::getBytesAtOffset(a2, v19, v24, v17);
  if (v17 != BytesAtOffset)
  {
    _cg_jpeg_mem_term("decodeDXTCtoRGBX", 987, "got: %ld expected: %ld\n", BytesAtOffset, v17);
    unint64_t v26 = v19;
    if (!v19) {
      goto LABEL_73;
    }
    goto LABEL_72;
  }
  unint64_t v26 = v19;
  if (v19)
  {
LABEL_61:
    unint64_t v27 = at_encoder_create(v12, v8, v11, v8, 0);
    if (v27)
    {
      uint64_t v28 = v27;
      vImagePixelCount height = a3->height;
      dest.texels = a3->data;
      size_t rowBytes = a3->rowBytes;
      dest.validSize.CGFloat x = a3->width;
      dest.validSize.CGFloat y = height;
      *((_DWORD *)&dest.validSize + ++*((_DWORD *)this + 3) = 0;
      dest.size_t rowBytes = rowBytes;
      dest.validSize.z = 1;
      dest.sliceBytes = 0;
      unint64_t v31 = *(void *)&dest.validSize.x;
      *(void *)&v45.CGFloat x = *(void *)&dest.validSize.x;
      v45.z = 1;
      unint64_t block_counts = (unint64_t)at_encoder_get_block_counts(v27, v45);
      unsigned int v33 = block_counts;
      unint64_t v34 = HIDWORD(block_counts);
      src.blocks = v19;
      src.size_t rowBytes = at_encoder_get_block_size(v28) * block_counts;
      src.sliceBytes = v34 * (unint64_t)v33 * at_encoder_get_block_size(v28);
      outunsigned int Size = 0;
      *(void *)&v46.CGFloat x = *(void *)&dest.validSize.x;
      v46.z = 1;
      v35.bits = at_block_get_features(v11, &src, v46, v17, &outSize, at_flags_default).bits;
      if (outSize > v17)
      {
        v36.bits = v35.bits;
        unint64_t v37 = HIDWORD(v31);
        _cg_jpeg_mem_term("decodeDXTCtoRGBX", 1018, "*** expected size > file size (%d > %d)\n", outSize, v17);
        unint64_t v38 = v17 / (v33 << (LODWORD(v36.bits) >> 5)) * ((v36.bits >> 22) & 0xFFF);
        if (v38 >= 0xFFFFFFFF) {
          LODWORD(v38) = -1;
        }
        if (v38 >= v37) {
          LODWORD(v38) = v37;
        }
        dest.validSize.CGFloat y = v38;
      }
      at_error_t v39 = at_encoder_decompress_texels(v28, &src, &dest, at_flags_default);
      if (v39) {
        LogError("decodeDXTCtoRGBX", 1031, "at_encoder_decompress_texels returned: %ld\n", v39);
      }
      CFRelease(v28);
    }
    if (!v26) {
      goto LABEL_73;
    }
LABEL_72:
    free(v26);
    goto LABEL_73;
  }
LABEL_59:
  _cg_jpeg_mem_term("decodeDXTCtoRGBX", 990, "*** tempLinearBuffer is nil\n");
LABEL_73:
  if (v44) {
    IIOImageReadSession::releaseBytePointer((IIOImageRead **)a2, v44);
  }
  return 0;
}

uint64_t BCReadPlugin::decodeDXTCtoRGBX(BCReadPlugin *this, void *a2, size_t a3, vImage_Buffer *a4, unsigned int a5, int a6)
{
  if (a5 > 2) {
    at_alpha_t v9 = at_alpha_not_premultiplied;
  }
  else {
    at_alpha_t v9 = dword_18898F854[a5];
  }
  int v10 = *((_DWORD *)this + 113);
  if (v10 > 36282)
  {
    if (v10 <= 36491)
    {
      at_block_format_t v12 = at_block_format_bc4;
      at_texel_format_t v13 = at_texel_format_l8_unorm;
      switch(v10)
      {
        case 36283:
          goto LABEL_43;
        case 36284:
          at_block_format_t v12 = at_block_format_bc4s;
          at_texel_format_t v13 = at_texel_format_l16_float;
          goto LABEL_43;
        case 36285:
          if (a6) {
            at_texel_format_t v13 = at_texel_format_bgra8_unorm;
          }
          else {
            at_texel_format_t v13 = at_texel_format_rgba8_unorm;
          }
          at_block_format_t v12 = at_block_format_bc5;
          goto LABEL_43;
        case 36286:
          at_block_format_t v12 = at_block_format_bc5s;
          goto LABEL_42;
        default:
          goto LABEL_54;
      }
    }
    if ((v10 - 36492) >= 2)
    {
      if (v10 == 36494)
      {
        at_block_format_t v12 = at_block_format_bc6;
      }
      else
      {
        if (v10 != 36495) {
          goto LABEL_54;
        }
        at_block_format_t v12 = at_block_format_bc6u;
      }
LABEL_42:
      at_texel_format_t v13 = at_texel_format_rgba16_float;
      goto LABEL_43;
    }
    if (a6) {
      at_texel_format_t v13 = at_texel_format_bgra8_unorm;
    }
    else {
      at_texel_format_t v13 = at_texel_format_rgba8_unorm;
    }
    at_block_format_t v12 = at_block_format_bc7;
  }
  else
  {
    if (v10 > 35915)
    {
      if ((v10 - 35916) >= 2)
      {
        if (v10 != 35918)
        {
          int v11 = 35919;
LABEL_15:
          if (v10 == v11)
          {
            if (a6) {
              at_texel_format_t v13 = at_texel_format_bgra8_unorm;
            }
            else {
              at_texel_format_t v13 = at_texel_format_rgba8_unorm;
            }
            at_block_format_t v12 = at_block_format_bc3;
            goto LABEL_43;
          }
LABEL_54:
          _cg_jpeg_mem_term("decodeDXTCtoRGBX", 1110, "*** BC - unknown GL pixel format\n");
          return 4294967246;
        }
        goto LABEL_28;
      }
    }
    else if ((v10 - 33776) >= 2)
    {
      if (v10 != 33778)
      {
        int v11 = 33779;
        goto LABEL_15;
      }
LABEL_28:
      if (a6) {
        at_texel_format_t v13 = at_texel_format_bgra8_unorm;
      }
      else {
        at_texel_format_t v13 = at_texel_format_rgba8_unorm;
      }
      at_block_format_t v12 = at_block_format_bc2;
      goto LABEL_43;
    }
    if (a6) {
      at_texel_format_t v13 = at_texel_format_bgra8_unorm;
    }
    else {
      at_texel_format_t v13 = at_texel_format_rgba8_unorm;
    }
    at_block_format_t v12 = at_block_format_bc1;
  }
LABEL_43:
  size_t v14 = at_encoder_create(v13, v9, v12, v9, 0);
  if (!v14) {
    return 4294967246;
  }
  uint64_t v15 = v14;
  vImagePixelCount height = a4->height;
  dest.texels = a4->data;
  size_t rowBytes = a4->rowBytes;
  dest.validSize.CGFloat x = a4->width;
  dest.validSize.CGFloat y = height;
  *((_DWORD *)&dest.validSize + ++*((_DWORD *)this + 3) = 0;
  dest.size_t rowBytes = rowBytes;
  dest.validSize.z = 1;
  dest.sliceBytes = 0;
  unsigned int v18 = height;
  *(void *)&v31.CGFloat x = *(void *)&dest.validSize.x;
  v31.z = 1;
  unint64_t block_counts = (unint64_t)at_encoder_get_block_counts(v14, v31);
  unsigned int v20 = block_counts;
  unint64_t v21 = HIDWORD(block_counts);
  src.blocks = a2;
  src.size_t rowBytes = at_encoder_get_block_size(v15) * block_counts;
  src.sliceBytes = v21 * (unint64_t)v20 * at_encoder_get_block_size(v15);
  outunsigned int Size = 0;
  *(void *)&v32.CGFloat x = *(void *)&dest.validSize.x;
  v32.z = 1;
  v22.bits = at_block_get_features(v12, &src, v32, a3, &outSize, at_flags_default).bits;
  if (outSize > a3)
  {
    v23.bits = v22.bits;
    _cg_jpeg_mem_term("decodeDXTCtoRGBX", 1153, "*** expected size > file size (%d > %d)\n", outSize, a3);
    unint64_t v24 = a3 / (v20 << (LODWORD(v23.bits) >> 5)) * ((v23.bits >> 22) & 0xFFF);
    if (v24 >= 0xFFFFFFFF) {
      LODWORD(v24) = -1;
    }
    if (v24 >= v18) {
      LODWORD(v24) = v18;
    }
    dest.validSize.CGFloat y = v24;
  }
  at_error_t v25 = at_encoder_decompress_texels(v15, &src, &dest, at_flags_default);
  if (v25)
  {
    LogError("decodeDXTCtoRGBX", 1166, "at_encoder_decompress_texels returned: %ld\n", v25);
    uint64_t v26 = 4294967246;
  }
  else
  {
    uint64_t v26 = 0;
  }
  CFRelease(v15);
  return v26;
}

uint64_t BCReadPlugin::decodeImageImp(uint64_t a1, IIODecodeParameter *a2, int a3, IOSurfaceRef *a4)
{
  v58[0] = 0;
  if (*(unsigned char *)(a1 + 410) == 1 && *(void *)(a1 + 392) != 16) {
    return 4294967246;
  }
  *(void *)(a1 + 392) = 16;
  *(_DWORD *)(a1 + 300) = ImageIOAlignRowBytes(*(unsigned int *)(a1 + 300), 0x10uLL);
  if ((gIIODebugFlags & 0x20000) != 0)
  {
    int v8 = *(_DWORD *)(a1 + 204);
    unsigned int v9 = v8 >> 24;
    uint64_t v10 = MEMORY[0x1E4F14390];
    if (v8 < 0)
    {
      int v11 = __maskrune(v9, 0x40000uLL);
      int v8 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
    }
    if (v11) {
      uint64_t v13 = (v8 >> 24);
    }
    else {
      uint64_t v13 = 46;
    }
    unsigned int v14 = v8 << 8 >> 24;
    if (v8 << 8 < 0)
    {
      int v15 = __maskrune(v14, 0x40000uLL);
      int v8 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      int v15 = *(_DWORD *)(v10 + 4 * v14 + 60) & 0x40000;
    }
    if (v15) {
      uint64_t v16 = (v8 << 8 >> 24);
    }
    else {
      uint64_t v16 = 46;
    }
    unsigned int v17 = (__int16)v8 >> 8;
    if (v8 << 16 < 0)
    {
      int v18 = __maskrune(v17, 0x40000uLL);
      int v8 = *(_DWORD *)(a1 + 204);
    }
    else
    {
      int v18 = *(_DWORD *)(v10 + 4 * v17 + 60) & 0x40000;
    }
    if (v18) {
      uint64_t v19 = ((__int16)v8 >> 8);
    }
    else {
      uint64_t v19 = 46;
    }
    if ((v8 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v10 + 4 * (char)v8 + 60) & 0x40000) != 0) {
        goto LABEL_25;
      }
    }
    else if (__maskrune((char)v8, 0x40000uLL))
    {
LABEL_25:
      int v20 = *(_DWORD *)(a1 + 204);
LABEL_28:
      ImageIOLog("♦️  '%c%c%c%c' [%s] %s\n", v13, v16, v19, (char)v20, iioTypeStr[a3], "virtual OSStatus BCReadPlugin::decodeImageImp(IIODecodeParameter *, IIOImageType, IOSurfaceRef *, CVPixelBufferRef *, CGImageBlockSetRef *)");
      goto LABEL_29;
    }
    LOBYTE(v20) = 46;
    goto LABEL_28;
  }
LABEL_29:
  IIOReadPlugin::debugDecodeImage((IIOReadPlugin *)a1, a2);
  unint64_t v21 = *(IIOImageRead ***)(a1 + 24);
  if (v21) {
    BOOL v22 = IIOImageReadSession::mapData(v21);
  }
  else {
    BOOL v22 = 0;
  }
  vImagePixelCount v23 = *(unsigned int *)(a1 + 292);
  vImagePixelCount v24 = *(unsigned int *)(a1 + 296);
  size_t v25 = *(unsigned int *)(a1 + 300);
  if (a3 == 3)
  {
    uint64_t BlockArray = IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, *(unsigned int *)(a1 + 104));
    unsigned int v31 = *(_DWORD *)(a1 + 296);
    LODWORD(v32) = *(_DWORD *)(a1 + 292);
    double v29 = (double)v31;
    double v30 = (double)v32;
    memory_object_size_t v52 = *(unsigned int *)(a1 + 300) * (unint64_t)v31;
    BaseAddress = (void *)_ImageIO_Malloc(v52, *(void *)(a1 + 384), v58, (uint64_t)kImageMalloc_BC_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
  }
  else
  {
    if (a3 != 1 || !a4 || !*a4)
    {
      uint64_t BlockArray = 0;
      goto LABEL_68;
    }
    IOSurfaceLock(*a4, 0, 0);
    BaseAddress = IOSurfaceGetBaseAddress(*a4);
    size_t Height = IOSurfaceGetHeight(*a4);
    uint64_t BlockArray = 0;
    memory_object_size_t v52 = IOSurfaceGetBytesPerRow(*a4) * Height;
    v58[0] = v52;
    double v29 = 0.0;
    double v30 = 0.0;
  }
  if (BaseAddress)
  {
    if (*(_DWORD *)(a1 + 204) == 1261584963)
    {
      Dataunsigned int Size = Ktx2GetDataSize(*(_DWORD *)(a1 + 480), v23, v24);
      if (DataSize)
      {
        unsigned int v51 = a4;
        BOOL v34 = v22;
        uint64_t v35 = DataSize;
        at_block_features_t v36 = malloc_type_calloc(DataSize, 1uLL, 0x771A58AuLL);
        unint64_t v37 = v36;
        if (v36)
        {
          int v54 = *(_DWORD *)(a1 + 208);
          int v55 = v36;
          uint64_t v56 = v35;
          size_t v57 = 0;
          uint64_t v38 = *(void *)(a1 + 472);
          if (v38)
          {
            BOOL v22 = v34;
            if (!(*(unsigned int (**)(void))(*(void *)(v38 + 8) + 40))())
            {
              dest.data = BaseAddress;
              dest.vImagePixelCount height = v24;
              dest.CGFloat width = v23;
              dest.size_t rowBytes = v25;
              if (*(void *)(a1 + 24)) {
                uint64_t BlockArray = BCReadPlugin::decodeDXTCtoRGBX((BCReadPlugin *)a1, v55, v57, &dest, *(unsigned __int8 *)(a1 + 310), *(unsigned char *)(a1 + 405) == 0);
              }
              a4 = v51;
              if (!BlockArray) {
                goto LABEL_48;
              }
LABEL_63:
              *(_DWORD *)(a1 + 104) = 0;
              goto LABEL_64;
            }
          }
          else
          {
            LogFault("decodeImageImp", 1256, "*** _bc._ktxTexture is NULL\n");
            BOOL v22 = v34;
          }
          uint64_t BlockArray = 4294967246;
          goto LABEL_64;
        }
        uint64_t BlockArray = 4294967188;
        BOOL v22 = v34;
      }
      else
      {
        unint64_t v37 = 0;
        uint64_t BlockArray = 4294967229;
      }
LABEL_64:
      if (a3 == 3) {
        _ImageIO_Free((unint64_t)BaseAddress, v58[0]);
      }
      if (!v37) {
        goto LABEL_68;
      }
LABEL_67:
      free(v37);
      goto LABEL_68;
    }
    dest.data = BaseAddress;
    dest.vImagePixelCount height = v24;
    dest.CGFloat width = v23;
    dest.size_t rowBytes = v25;
    uint64_t v41 = *(IIOImageReadSession **)(a1 + 24);
    if (v41)
    {
      int v42 = *(unsigned __int8 *)(a1 + 405);
      if (*(_DWORD *)(a1 + 452) == 34952) {
        uint64_t v43 = BCReadPlugin::decode8888toRGBX((BCReadPlugin *)a1, v41, &dest, v28, v42 == 0);
      }
      else {
        uint64_t v43 = BCReadPlugin::decodeDXTCtoRGBX((BCReadPlugin *)a1, v41, &dest, *(unsigned __int8 *)(a1 + 310), v42 == 0);
      }
      uint64_t BlockArray = v43;
    }
    unint64_t v37 = 0;
    if (!BlockArray)
    {
LABEL_48:
      if (*(_WORD *)(a1 + 306) == 32 && *(_WORD *)(a1 + 304) == 8 && *(unsigned char *)(a1 + 406) == 1)
      {
        dest.data = BaseAddress;
        uint64_t v39 = *(void *)(a1 + 292);
        v40.i64[0] = v39;
        v40.i64[1] = HIDWORD(v39);
        *(int8x16_t *)&dest.vImagePixelCount height = vextq_s8(v40, v40, 8uLL);
        dest.size_t rowBytes = *(unsigned int *)(a1 + 300);
        vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
      }
      if (a3 == 3)
      {
        uint64_t v46 = 0;
        v59.origin.CGFloat x = 0.0;
        v59.origin.CGFloat y = 0.0;
        v59.size.CGFloat width = v30;
        v59.size.vImagePixelCount height = v29;
        **(void **)(a1 + 9jp2_colour_converter::clear(this + 6) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, BaseAddress, v52, v59, *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
        if (CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E4F1DB20]))
        {
          uint64_t v47 = 0;
        }
        else
        {
          v60.origin.CGFloat x = 0.0;
          v60.origin.CGFloat y = 0.0;
          v60.size.CGFloat width = v30;
          v60.size.vImagePixelCount height = v29;
          *(CGRect *)(&v47 - 1) = CGRectUnion(*(CGRect *)(a1 + 120), v60);
          uint64_t v46 = v48;
          double v30 = v49;
          double v29 = v50;
        }
        uint64_t BlockArray = 0;
        *(void *)(a1 + 120) = v46;
        *(void *)(a1 + 128) = v47;
        *(double *)(a1 + 13jp2_colour_converter::clear(this + 6) = v30;
        *(double *)(a1 + 144) = v29;
        if (!v37) {
          goto LABEL_68;
        }
      }
      else
      {
        IOSurfaceUnlock(*a4, 0, 0);
        uint64_t BlockArray = 0;
        if (!v37) {
          goto LABEL_68;
        }
      }
      goto LABEL_67;
    }
    goto LABEL_63;
  }
LABEL_68:
  if (v22)
  {
    int v44 = *(const char ***)(a1 + 24);
    if (v44) {
      IIOImageReadSession::unmapData(v44);
    }
  }
  return BlockArray;
}

uint64_t BCReadPlugin::copyImageTextureData(uint64_t a1)
{
  int v2 = *(const void **)(a1 + 488);
  if (!v2)
  {
    long long v20 = xmmword_1ED4F09B0;
    long long v21 = *(_OWORD *)&off_1ED4F09C0;
    uint64_t v3 = IIOImageRead::imageCount(*(IIOImageRead **)(a1 + 32));
    memset(v19, 0, sizeof(v19));
    IIODictionary::IIODictionary((IIODictionary *)v19);
    IIONumber::IIONumber((IIONumber *)v18, *(_DWORD *)(a1 + 228));
    IIODictionary::setObjectForKey((uint64_t)v19, (uint64_t)v18, @"width");
    IIONumber::~IIONumber((IIONumber *)v18);
    IIONumber::IIONumber((IIONumber *)v17, *(_DWORD *)(a1 + 232));
    IIODictionary::setObjectForKey((uint64_t)v19, (uint64_t)v17, @"height");
    IIONumber::~IIONumber((IIONumber *)v17);
    int v4 = *(_DWORD *)(a1 + 452);
    if (v4 > 36282)
    {
      if ((v4 - 36283) < 2)
      {
        int v5 = 2;
        goto LABEL_15;
      }
      if ((v4 - 36285) < 2)
      {
        int v5 = 4;
        goto LABEL_15;
      }
    }
    else
    {
      int v5 = 8;
      if (v4 > 35915)
      {
        if ((v4 - 35916) < 2) {
          goto LABEL_15;
        }
        int v6 = -35918;
      }
      else
      {
        if ((v4 - 33776) < 2) {
          goto LABEL_15;
        }
        int v6 = -33778;
      }
      if ((v4 + v6) < 2)
      {
        int v5 = 16;
LABEL_15:
        IIONumber::IIONumber((IIONumber *)v16, v5 * *(_DWORD *)(a1 + 456));
        IIODictionary::setObjectForKey((uint64_t)v19, (uint64_t)v16, @"rowBytes");
        IIONumber::~IIONumber((IIONumber *)v16);
        IIONumber::IIONumber((IIONumber *)v15, *(_DWORD *)(a1 + 452));
        IIODictionary::setObjectForKey((uint64_t)v19, (uint64_t)v15, @"glInternalFormat");
        IIONumber::~IIONumber((IIONumber *)v15);
        IIONumber::IIONumber((IIONumber *)v14, v3);
        IIODictionary::setObjectForKey((uint64_t)v19, (uint64_t)v14, @"mipmapLevelCount");
        IIONumber::~IIONumber((IIONumber *)v14);
        IIONumber::IIONumber((IIONumber *)v13, 1);
        IIODictionary::setObjectForKey((uint64_t)v19, (uint64_t)v13, @"faceCount");
        IIONumber::~IIONumber((IIONumber *)v13);
        ColorSpace = (const void *)CGImageProviderGetColorSpace();
        IIODictionary::setObjectForKey((IIODictionary *)v19, ColorSpace, @"colorSpace");
        IIODictionary::setObjectForKey((IIODictionary *)v19, (const void *)*MEMORY[0x1E4F1CFC8], @"supportsTiledLayout");
        IIONumber::IIONumber((IIONumber *)v12, *(_DWORD *)(a1 + 452));
        IIODictionary::setObjectForKey((uint64_t)v19, (uint64_t)v12, @"pixelFormatGL");
        IIONumber::~IIONumber((IIONumber *)v12);
        int v8 = *(_DWORD *)(a1 + 452);
        if (v8 > 35918)
        {
          switch(v8)
          {
            case 36492:
              int v9 = 152;
              break;
            case 36493:
              int v9 = 153;
              break;
            case 36494:
              int v9 = 150;
              break;
            case 36495:
              int v9 = 151;
              break;
            default:
              if (v8 != 35919) {
                goto LABEL_31;
              }
              int v9 = 135;
              break;
          }
        }
        else
        {
          if (v8 <= 33778)
          {
            if ((v8 - 33776) < 2)
            {
              int v9 = 130;
              goto LABEL_35;
            }
            if (v8 == 33778)
            {
              int v9 = 132;
              goto LABEL_35;
            }
          }
          else
          {
            if ((v8 - 35916) < 2)
            {
              int v9 = 131;
              goto LABEL_35;
            }
            if (v8 == 33779)
            {
              int v9 = 134;
              goto LABEL_35;
            }
            if (v8 == 35918)
            {
              int v9 = 133;
              goto LABEL_35;
            }
          }
LABEL_31:
          int v9 = 0;
        }
LABEL_35:
        IIONumber::IIONumber((IIONumber *)v11, v9);
        IIODictionary::setObjectForKey((uint64_t)v19, (uint64_t)v11, @"pixelFormatMetal");
        IIONumber::~IIONumber((IIONumber *)v11);
        IIOImageSource::cf(*(IIOImageSource **)(a1 + 32));
        operator new();
      }
    }
    int v5 = 0;
    goto LABEL_15;
  }
  CFRetain(v2);
  return *(void *)(a1 + 488);
}

void sub_18870A854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  IIODictionary::~IIODictionary((IIODictionary *)(v11 - 104));
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<BCTextureImp>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED4EF2A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<BCTextureImp>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1ED4EF2A0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18C11C0E0);
}

uint64_t std::__shared_ptr_emplace<BCTextureImp>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void IIO_Reader_KTX2::createReadPlugin()
{
}

{
  operator new();
}

void sub_18870AA40(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40FF5C6BEALL);
  _Unwind_Resume(a1);
}

void sub_18870AAE0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40FF5C6BEALL);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader_KTX2::getImageCount(IIO_Reader_KTX2 *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = 0;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  IIOScanner::IIOScanner((IIOScanner *)&v15, a2);
  unsigned int v7 = v16;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v22 = 0u;
  long long __dst = 0u;
  long long v21 = 0u;
  if (IIOScanner::getBytesAtOffset((IIOScanner *)&v15, &__dst, 0, 0x50uLL) != 80)
  {
    unsigned int v8 = 1;
    goto LABEL_23;
  }
  memset(v14, 0, sizeof(v14));
  if (!(*(unsigned int (**)(IIO_Reader_KTX2 *, long long *, uint64_t, void, void *))(*(void *)this + 16))(this, &__dst, 80, 0, v14))
  {
LABEL_22:
    unsigned int v8 = 0;
LABEL_23:
    uint64_t v12 = 4294967246;
    if (!a5) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  if (HIDWORD(v23) + DWORD2(v23) > v7)
  {
    _cg_jpeg_mem_term("getImageCount", 85, "*** invalid KTX2 file: bytesOfKeyValueData: %d (fileSize: %d)\n");
    goto LABEL_22;
  }
  unsigned int v8 = DWORD2(v22);
  if (DWORD2(v22))
  {
    unsigned int v9 = DWORD2(v21);
    if (DWORD1(v21) < DWORD2(v21)) {
      unsigned int v9 = DWORD1(v21);
    }
    if (v9)
    {
      unsigned int v10 = 0;
      do
      {
        ++v10;
        BOOL v11 = v9 > 1;
        v9 >>= 1;
      }
      while (v11);
    }
    else
    {
      unsigned int v10 = 0;
    }
    uint64_t v12 = 0;
    if (DWORD2(v22) >= v10) {
      unsigned int v8 = v10;
    }
  }
  else
  {
    unsigned int v8 = 1;
    uint64_t v12 = 4294967246;
  }
  if (v8 > v7)
  {
    _cg_jpeg_mem_term("getImageCount", 100, "*** invalid KTX2 file: numberOfMipmapLevels: %d (fileSize: %d)\n");
    goto LABEL_22;
  }
  if (a5) {
LABEL_17:
  }
    *a5 = v8;
LABEL_18:
  IIOScanner::~IIOScanner((IIOScanner *)&v15);
  return v12;
}

void sub_18870ACB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

uint64_t IIO_Reader_KTX2::hasCustomImageCountProc(IIO_Reader_KTX2 *this)
{
  return 1;
}

void IIO_Reader::~IIO_Reader(IIO_Reader *this)
{
}

uint64_t IIO_Reader::createReadPlugin()
{
  return 0;
}

{
  return 0;
}

uint64_t IIO_Reader::canDecodeOOP(IIO_Reader *this)
{
  return 1;
}

uint64_t IIO_Reader::compareOptions(IIO_Reader *this, const __CFDictionary *a2, const __CFDictionary *a3)
{
  return 1;
}

uint64_t IIO_Reader::isReaderForRAWImageFormat(IIO_Reader *this)
{
  return 0;
}

uint64_t IIO_Reader::hasCustomSourcePropertiesProc(IIO_Reader *this)
{
  return 0;
}

uint64_t IIO_Reader::hasCustomThumbnailProc(IIO_Reader *this)
{
  return 0;
}

uint64_t IIO_Reader::canCreateCustomThumbnailSizes(IIO_Reader *this)
{
  return 0;
}

uint64_t IIO_Reader::hasCustomCopyAuxiliaryDataProc(IIO_Reader *this)
{
  return 0;
}

uint64_t IIO_Reader::addBasicProperties(IIO_Reader *this, unsigned __int8 *a2, unsigned int a3, __CFDictionary *a4, unsigned int *a5, const __CFData **a6)
{
  return 0;
}

uint64_t IIO_Reader::copyAuxiliaryDataInfo()
{
  return 0;
}

uint64_t IIO_Reader::updateGlobalInfo(IIO_Reader *this, IIOImageReadSession *a2, unsigned __int8 *a3)
{
  return 4294967292;
}

uint64_t IIO_Reader::createGlobalInfoData(IIO_Reader *this, IIOImageReadSession *a2)
{
  return 0;
}

uint64_t IIO_Reader::deserializeGlobalInfo(IIO_Reader *this, unsigned __int8 *a2)
{
  return 0;
}

uint64_t IIO_Reader::testHeader()
{
  return 0;
}

uint64_t IIO_Reader::xpcGetImageCount(IIO_Reader *this, _xpc_connection_s *a2, void *a3, void *a4)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!IIO_XPCServer()) {
    return 4294967246;
  }
  IIOIncrementImageCountCallCount();
  xpc_object_t source_dict = iio_xpc_get_source_dict(a3);
  xpc_object_t plugin_dict = iio_xpc_get_plugin_dict(a3);
  xpc_object_t v9 = iio_xpc_add_message_dict(a4);
  xpc_object_t v10 = iio_xpc_add_source_dict(a4);
  xpc_object_t v11 = iio_xpc_add_plugin_dict(a4);
  memset(v20, 0, sizeof(v20));
  IIOImageRead::IIOImageRead((IIOImageRead *)v20, a3);
  memset(v19, 0, sizeof(v19));
  IIOImageReadSession::IIOImageReadSession((IIOImageReadSession *)v19, (IIOImageRead *)v20);
  uint64_t v17 = 0;
  int64_t value = 0;
  xpc_object_t GlobalInfo = iio_xpc_dictionary_get_GlobalInfo(plugin_dict, &v17);
  if (v17) {
    (*(void (**)(IIO_Reader *, _OWORD *, xpc_object_t))(*(void *)this + 96))(this, v19, GlobalInfo);
  }
  if (source_dict) {
    xpc_object_t source_dict = iio_xpc_dictionary_copy_CFDictionary(source_dict, "iio_xpc_src_options");
  }
  memset(v16, 0, sizeof(v16));
  IIODictionary::IIODictionary((IIODictionary *)v16, (const __CFDictionary *)source_dict);
  uint64_t v13 = (*(uint64_t (**)(IIO_Reader *, _OWORD *, void *, char *, int64_t *))(*(void *)this + 32))(this, v19, v16, (char *)&value + 4, &value);
  IIOXPCLog("🔹 xpcGetImageCount - sending %d\n", value);
  xpc_dictionary_set_int64(v10, "iio_xpc_src_status", SHIDWORD(value));
  xpc_dictionary_set_uint64(v10, "iio_xpc_src_image_count", value);
  iio_xpc_dictionary_set_error_code(v9, v13);
  CFDataRef v14 = (const __CFData *)(*(uint64_t (**)(IIO_Reader *, _OWORD *))(*(void *)this + 104))(this, v19);
  if (v14)
  {
    iio_xpc_dictionary_add_GlobalInfo(v11, v14, *((_DWORD *)this + 6));
    CFRelease(v14);
  }
  if (source_dict) {
    CFRelease(source_dict);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v16);
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)v19);
  IIOImageRead::~IIOImageRead((IIOImageRead *)v20);
  return v13;
}

void sub_18870B044(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)va);
  IIOImageRead::~IIOImageRead((IIOImageRead *)va1);
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader::getImageCount(IIO_Reader *this, IIOImageReadSession *a2, IIODictionary *a3, CGImageSourceStatus *a4, unsigned int *a5)
{
  _cg_jpeg_mem_term("getImageCount", 522, "===========================================================\n", a4);
  int v7 = *((_DWORD *)this + 6);
  unsigned int v8 = v7 >> 24;
  uint64_t v9 = MEMORY[0x1E4F14390];
  if (v7 < 0)
  {
    int v10 = __maskrune(v8, 0x40000uLL);
    int v7 = *((_DWORD *)this + 6);
  }
  else
  {
    int v10 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v8 + 60) & 0x40000;
  }
  if (v10) {
    uint64_t v11 = (v7 >> 24);
  }
  else {
    uint64_t v11 = 46;
  }
  unsigned int v12 = v7 << 8 >> 24;
  if (v7 << 8 < 0)
  {
    int v13 = __maskrune(v12, 0x40000uLL);
    int v7 = *((_DWORD *)this + 6);
  }
  else
  {
    int v13 = *(_DWORD *)(v9 + 4 * v12 + 60) & 0x40000;
  }
  if (v13) {
    uint64_t v14 = (v7 << 8 >> 24);
  }
  else {
    uint64_t v14 = 46;
  }
  unsigned int v15 = (__int16)v7 >> 8;
  if (v7 << 16 < 0)
  {
    int v16 = __maskrune(v15, 0x40000uLL);
    int v7 = *((_DWORD *)this + 6);
  }
  else
  {
    int v16 = *(_DWORD *)(v9 + 4 * v15 + 60) & 0x40000;
  }
  if (v16) {
    uint64_t v17 = ((__int16)v7 >> 8);
  }
  else {
    uint64_t v17 = 46;
  }
  if ((v7 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v9 + 4 * (char)v7 + 60) & 0x40000) != 0) {
      goto LABEL_21;
    }
  }
  else if (__maskrune((char)v7, 0x40000uLL))
  {
LABEL_21:
    uint64_t v18 = *((char *)this + 24);
    goto LABEL_24;
  }
  uint64_t v18 = 46;
LABEL_24:
  *(void *)&double v19 = _cg_jpeg_mem_term("getImageCount", 523, "IIO_Reader [%c%c%c%c] did not implement 'getImageCount'\n", v11, v14, v17, v18).n128_u64[0];
  _cg_jpeg_mem_term("getImageCount", 524, "===========================================================\n", v19);
  if (a5) {
    *a5 = 1;
  }
  return 0;
}

uint64_t IIO_Reader::xpcUpdateSourceProperties(IIO_Reader *this, _xpc_connection_s *a2, void *a3, void *a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!IIO_XPCServer()) {
    return 4294967292;
  }
  IIOIncrementSourcePropertiesCallCount();
  xpc_object_t source_dict = iio_xpc_get_source_dict(a3);
  xpc_object_t v8 = iio_xpc_add_message_dict(a4);
  xpc_object_t v9 = iio_xpc_add_source_dict(a4);
  CFDictionaryRef v10 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(v8, "iio_xpc_msg_call_options");
  memset(v18, 0, sizeof(v18));
  IIODictionary::IIODictionary((IIODictionary *)v18, v10);
  CFDictionaryRef v11 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(source_dict, "iio_xpc_src_options");
  memset(v17, 0, sizeof(v17));
  IIODictionary::IIODictionary((IIODictionary *)v17, v11);
  CFDictionaryRef v12 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(source_dict, "iio_xpc_src_properties");
  memset(v16, 0, sizeof(v16));
  IIODictionary::IIODictionary((IIODictionary *)v16, v12, 1);
  memset(v19, 0, 480);
  IIOImageRead::IIOImageRead((IIOImageRead *)v19, a3);
  memset(&value[4], 0, 64);
  IIOImageReadSession::IIOImageReadSession((IIOImageReadSession *)&value[4], (IIOImageRead *)v19);
  *(_DWORD *)int64_t value = 0;
  uint64_t v13 = (*(uint64_t (**)(IIO_Reader *, unsigned char *, void *, void *, void *, unsigned char *))(*(void *)this + 56))(this, &value[4], v16, v17, v18, value);
  if (!v13)
  {
    IIOXPCLog("🔹 xpcUpdateSourceProperties...\n");
    iio_xpc_dictionary_add_CFDictionary(v9, "iio_xpc_src_properties");
    xpc_dictionary_set_int64(v9, "iio_xpc_src_status", *(int *)value);
  }
  iio_xpc_dictionary_set_error_code(v8, v13);
  if (v10) {
    CFRelease(v10);
  }
  if (v11) {
    CFRelease(v11);
  }
  if (v12) {
    CFRelease(v12);
  }
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)&value[4]);
  IIOImageRead::~IIOImageRead((IIOImageRead *)v19);
  IIODictionary::~IIODictionary((IIODictionary *)v16);
  IIODictionary::~IIODictionary((IIODictionary *)v17);
  IIODictionary::~IIODictionary((IIODictionary *)v18);
  return v13;
}

void sub_18870B47C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t IIO_Reader::updateSourceProperties(IIO_Reader *this, IIOImageReadSession *a2, IIODictionary *a3, IIODictionary *a4, IIODictionary *a5, CGImageSourceStatus *a6)
{
  ImageIOLog("=======================================================================\n", a2, a3, a4, a5, a6);
  int v7 = *((_DWORD *)this + 6);
  unsigned int v8 = v7 >> 24;
  uint64_t v9 = MEMORY[0x1E4F14390];
  if (v7 < 0)
  {
    int v10 = __maskrune(v8, 0x40000uLL);
    int v7 = *((_DWORD *)this + 6);
  }
  else
  {
    int v10 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v8 + 60) & 0x40000;
  }
  unsigned int v11 = v7 << 8 >> 24;
  if (v7 << 8 < 0)
  {
    int v12 = __maskrune(v11, 0x40000uLL);
    int v13 = *((_DWORD *)this + 6);
  }
  else
  {
    int v12 = *(_DWORD *)(v9 + 4 * v11 + 60) & 0x40000;
    int v13 = v7;
  }
  unsigned int v14 = (__int16)v13 >> 8;
  if (v13 << 16 < 0)
  {
    int v15 = __maskrune(v14, 0x40000uLL);
    int v16 = *((_DWORD *)this + 6);
  }
  else
  {
    int v15 = *(_DWORD *)(v9 + 4 * v14 + 60) & 0x40000;
    int v16 = v13;
  }
  if ((v16 << 24) <= 0x7F000000) {
    int v17 = *(_DWORD *)(v9 + 4 * (char)v16 + 60) & 0x40000;
  }
  else {
    int v17 = __maskrune((char)v16, 0x40000uLL);
  }
  if (v17) {
    uint64_t v18 = *((char *)this + 24);
  }
  else {
    uint64_t v18 = 46;
  }
  LODWORD(v19) = (__int16)v16 >> 8;
  if (v15) {
    uint64_t v19 = v19;
  }
  else {
    uint64_t v19 = 46;
  }
  LODWORD(v20) = v13 << 8 >> 24;
  if (v12) {
    uint64_t v20 = v20;
  }
  else {
    uint64_t v20 = 46;
  }
  if (v10) {
    uint64_t v21 = (v7 >> 24);
  }
  else {
    uint64_t v21 = 46;
  }
  ImageIOLog("IIO_Reader [%c%c%c%c] did not implement 'updateSourceProperties'\n", v21, v20, v19, v18);
  ImageIOLog("=======================================================================\n");
  return 4294967240;
}

uint64_t IIO_Reader::xpcInitImage(IIO_Reader *this, _xpc_connection_s *a2, void *a3, void *a4)
{
  if (IIO_XPCServer())
  {
    length[0] = 0;
    IIOIncrementInitImageCallCount();
    xpc_object_t source_dict = iio_xpc_get_source_dict(a3);
    xpc_object_t plugin_dict = iio_xpc_get_plugin_dict(a3);
    xpc_object_t v9 = iio_xpc_add_message_dict(a4);
    xpc_object_t v10 = iio_xpc_add_plugin_dict(a4);
    DataFromXPCDict = IIOImageRead::CreateDataFromXPCDict((IIOImageRead *)a3, v11);
    if (DataFromXPCDict)
    {
      int v13 = DataFromXPCDict;
      if (!plugin_dict || (data = xpc_dictionary_get_data(plugin_dict, "iio_xpc_plugin_init_data", length)) == 0)
      {
        uint64_t v30 = 4294967246;
LABEL_18:
        CFRelease(v13);
        return v30;
      }
      int v15 = data;
      CFDictionaryRef v16 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(source_dict, "iio_xpc_src_options");
      if (length[0] != 56)
      {
        IIOXPCLog("*** data mismatch?\n");
        IIOXPCLog("*** initDataSize: %8ld    sizeof(ReadPluginInitData): %8ld\n", length[0], 56);
        CGMutableImageMetadataRef Mutable = 0;
        uint64_t v30 = 4294967246;
        if (!v16) {
          goto LABEL_16;
        }
        goto LABEL_15;
      }
      memset(v79, 0, sizeof(v79));
      IIODictionary::IIODictionary((IIODictionary *)v79, v16);
      memset(v78, 0, sizeof(v78));
      IIODictionary::IIODictionary((IIODictionary *)v78);
      uint64_t v77 = 0;
      long long v75 = 0u;
      long long v76 = 0u;
      long long v74 = 0u;
      long long v17 = v15[2];
      uint64_t v77 = *((void *)v15 + 6);
      long long v76 = v17;
      CGMutableImageMetadataRef Mutable = CGImageMetadataCreateMutable();
      CFDictionaryRef v70 = v16;
      *(void *)&long long v74 = v79;
      *((void *)&v74 + 1) = v78;
      *(void *)&long long v75 = Mutable;
      *((void *)&v75 + 1) = v13;
      memset(v73, 0, sizeof(v73));
      IIODictionary::IIODictionary((IIODictionary *)v73);
      uint64_t v71 = v9;
      uint64_t v19 = (IIOReadPlugin *)(*(uint64_t (**)(IIO_Reader *, long long *))(*(void *)this + 240))(this, &v74);
      uint64_t v20 = v19;
      if (!v19)
      {
        uint64_t v30 = 4294967246;
        goto LABEL_88;
      }
      IIOReadPlugin::setUTIWithReader(v19, this);
      v72[0] = 0;
      xpc_object_t GlobalInfo = iio_xpc_dictionary_get_GlobalInfo(plugin_dict, v72);
      if (v72[0])
      {
        xpc_object_t v22 = GlobalInfo;
        uint64_t v23 = IIOImageSource::count(v20);
        (*(void (**)(IIO_Reader *, uint64_t, xpc_object_t, uint64_t))(*(void *)this + 96))(this, v23, v22, v72[0]);
      }
      uint64_t v24 = (*(uint64_t (**)(IIOImageSource *, void *))(*(void *)v20 + 96))(v20, v73);
      BOOL v69 = v10;
      int v68 = v24;
      if (v24 == -49)
      {
        int v25 = *((_DWORD *)v20 + 51);
        (*(void (**)(IIOImageSource *))(*(void *)v20 + 8))(v20);
        int Uint32ForKey = IIODictionary::getUint32ForKey((IIODictionary *)v73, @"NEW_PLUGIN_ostype");
        unsigned int v27 = v25 >> 24;
        uint64_t v28 = MEMORY[0x1E4F14390];
        if (v25 < 0) {
          int v29 = __maskrune(v25 >> 24, 0x40000uLL);
        }
        else {
          int v29 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v27 + 60) & 0x40000;
        }
        if (v29) {
          uint64_t v33 = v27;
        }
        else {
          uint64_t v33 = 46;
        }
        uint64_t v67 = v33;
        unsigned int v34 = v25 << 8 >> 24;
        if (v25 << 8 < 0) {
          int v35 = __maskrune(v25 << 8 >> 24, 0x40000uLL);
        }
        else {
          int v35 = *(_DWORD *)(v28 + 4 * v34 + 60) & 0x40000;
        }
        if (v35) {
          uint64_t v36 = v34;
        }
        else {
          uint64_t v36 = 46;
        }
        uint64_t v66 = v36;
        unsigned int v37 = (__int16)v25 >> 8;
        if (v25 << 16 < 0) {
          int v38 = __maskrune((__int16)v25 >> 8, 0x40000uLL);
        }
        else {
          int v38 = *(_DWORD *)(v28 + 4 * v37 + 60) & 0x40000;
        }
        if (v38) {
          uint64_t v39 = v37;
        }
        else {
          uint64_t v39 = 46;
        }
        uint64_t v65 = v39;
        if ((v25 << 24) <= 0x7F000000) {
          int v40 = *(_DWORD *)(v28 + 4 * (char)v25 + 60) & 0x40000;
        }
        else {
          int v40 = __maskrune((char)v25, 0x40000uLL);
        }
        if (v40) {
          uint64_t v41 = (char)v25;
        }
        else {
          uint64_t v41 = 46;
        }
        uint64_t v64 = v41;
        unsigned int v42 = Uint32ForKey >> 24;
        if (Uint32ForKey < 0) {
          int v43 = __maskrune(Uint32ForKey >> 24, 0x40000uLL);
        }
        else {
          int v43 = *(_DWORD *)(v28 + 4 * v42 + 60) & 0x40000;
        }
        if (v43) {
          uint64_t v44 = v42;
        }
        else {
          uint64_t v44 = 46;
        }
        uint64_t v63 = v44;
        unsigned int v45 = Uint32ForKey << 8 >> 24;
        if (Uint32ForKey << 8 < 0) {
          int v46 = __maskrune(Uint32ForKey << 8 >> 24, 0x40000uLL);
        }
        else {
          int v46 = *(_DWORD *)(v28 + 4 * v45 + 60) & 0x40000;
        }
        if (v46) {
          uint64_t v47 = v45;
        }
        else {
          uint64_t v47 = 46;
        }
        unsigned int v48 = (__int16)Uint32ForKey >> 8;
        if (Uint32ForKey << 16 < 0) {
          int v49 = __maskrune((__int16)Uint32ForKey >> 8, 0x40000uLL);
        }
        else {
          int v49 = *(_DWORD *)(v28 + 4 * v48 + 60) & 0x40000;
        }
        if ((Uint32ForKey << 24) <= 0x7F000000) {
          int v50 = *(_DWORD *)(v28 + 4 * (char)Uint32ForKey + 60) & 0x40000;
        }
        else {
          int v50 = __maskrune((char)Uint32ForKey, 0x40000uLL);
        }
        if (v49) {
          uint64_t v51 = v48;
        }
        else {
          uint64_t v51 = 46;
        }
        if (v50) {
          uint64_t v52 = (char)Uint32ForKey;
        }
        else {
          uint64_t v52 = 46;
        }
        _cg_jpeg_mem_term("xpcInitImage", 1104, "*** 🔄 ImageIO: plugin changed from '%c%c%c%c' to '%c%c%c%c'\n", v67, v66, v65, v64, v63, v47, v51, v52);
        kdebug_trace();
        CFDictionaryRef Uint64ForKey = IIODictionary::getUint64ForKey((IIODictionary *)v73, @"NEW_PLUGIN_dataOffset");
        uint64_t ReaderHandler = (IIO_ReaderHandler *)IIO_ReaderHandler::GetReaderHandler(Uint64ForKey);
        int v55 = IIO_ReaderHandler::readerForType(ReaderHandler, Uint32ForKey);
        unint64_t v32 = v55;
        if (!v55)
        {
          uint64_t v20 = 0;
          uint64_t v30 = 4294967247;
          goto LABEL_88;
        }
        *((void *)&v76 + 1) = Uint64ForKey;
        uint64_t v20 = (IIOImageSource *)(*(uint64_t (**)(IIO_Reader *, long long *))(*(void *)v55 + 240))(v55, &v74);
        IIOReadPlugin::setUTIWithReader(v20, v32);
        if (v25 == 1297108768) {
          IIODictionary::setObjectForKey((IIODictionary *)v73, (const void *)*MEMORY[0x1E4F1CFD0], @"OriginalPluginWasMPO");
        }
        uint64_t v56 = IIOImageSource::count(v20);
        (*(void (**)(IIO_Reader *, uint64_t, void, void, void))(*(void *)v32 + 32))(v32, v56, 0, 0, 0);
        uint64_t v24 = (*(uint64_t (**)(IIOImageSource *, void *))(*(void *)v20 + 96))(v20, v73);
      }
      else
      {
        unint64_t v32 = 0;
      }
      uint64_t v30 = v24;
      if (!v24)
      {
        memset(v72, 0, sizeof(v72));
        IIODictionary::IIODictionary((IIODictionary *)v72);
        IIOXPCLog("🔹 xpcInitImage...\n");
        (*(void (**)(IIOImageSource *, void *))(*(void *)v20 + 112))(v20, v69);
        ColorSpace = (CGColorSpace *)IIOReadPlugin::getColorSpace(v20);
        if (ColorSpace)
        {
          CFPropertyListRef v58 = CGColorSpaceCopyPropertyList(ColorSpace);
          if (v58)
          {
            IIODictionary::setObjectForKey((IIODictionary *)v72, v58, @"TEMP_COLORSPACE");
            CFRelease(v58);
          }
        }
        if (IIODictionary::getCount((IIODictionary *)v72)) {
          iio_xpc_dictionary_add_CFDictionary(v69, "iio_xpc_plugin_header_infoptr");
        }
        if (v68 == -49)
        {
          iio_xpc_dictionary_add_CFDictionary(v69, "iio_xpc_plugin_type_changed");
          if (!v32)
          {
LABEL_84:
            iio_xpc_dictionary_add_CFDictionary(v69, "iio_xpc_plugin_init_properties");
            uint64_t Position = IIOImageWriteSession::getPosition(v20);
            XPCObunsigned int j = CGImageMetadataCreateXPCObj(Position);
            if (XPCObj)
            {
              xpc_dictionary_set_value(v69, "iio_xpc_plugin_init_metadata", XPCObj);
              xpc_release(XPCObj);
            }
            IIODictionary::~IIODictionary((IIODictionary *)v72);
            uint64_t v30 = 0;
LABEL_89:
            iio_xpc_dictionary_set_error_code(v71, v30);
            if (v20) {
              (*(void (**)(IIOImageSource *))(*(void *)v20 + 8))(v20);
            }
            IIODictionary::~IIODictionary((IIODictionary *)v73);
            IIODictionary::~IIODictionary((IIODictionary *)v78);
            IIODictionary::~IIODictionary((IIODictionary *)v79);
            CFDictionaryRef v16 = v70;
            if (!v70) {
              goto LABEL_16;
            }
LABEL_15:
            CFRelease(v16);
LABEL_16:
            if (Mutable) {
              CFRelease(Mutable);
            }
            goto LABEL_18;
          }
          uint64_t v59 = IIOImageSource::count(v20);
        }
        else
        {
          uint64_t v59 = IIOImageSource::count(v20);
          unint64_t v32 = this;
        }
        CFDataRef v60 = (const __CFData *)(*(uint64_t (**)(IIO_Reader *, uint64_t))(*(void *)v32 + 104))(v32, v59);
        if (v60)
        {
          iio_xpc_dictionary_add_GlobalInfo(v69, v60, *((_DWORD *)this + 6));
          CFRelease(v60);
        }
        goto LABEL_84;
      }
LABEL_88:
      IIOXPCLog("serverPlugin->initialize returned: %d\n", v30);
      goto LABEL_89;
    }
  }
  return 4294967246;
}

void sub_18870BE80(void *a1)
{
}

void sub_18870BE94()
{
}

void sub_18870BEA0()
{
}

void sub_18870BEB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a30);
  IIODictionary::~IIODictionary((IIODictionary *)(v30 - 144));
  IIODictionary::~IIODictionary((IIODictionary *)(v30 - 120));
  _Unwind_Resume(a1);
}

uint64_t IIO_Reader::initializeThumbnail(const void ***a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  IIODebugCallbackPriv(*a1[1], "initThumbnail");
  unsigned int v8 = (uint64_t (*)(const void ***, uint64_t, uint64_t, uint64_t))(*a1)[11];

  return v8(a1, a2, a3, a4);
}

uint64_t IIO_Reader::initThumbnail()
{
  return 4294967245;
}

uint64_t IIO_Reader::xpcDecodeImage(IIO_Reader *this, _xpc_connection_s *a2, void *a3, void *a4)
{
  if (!IIO_XPCServer()) {
    return 4294967246;
  }
  memset(v87, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)v87);
  uint64_t v85 = 0;
  long long v86 = 0;
  IIOIncrementCopyIOSurfaceCallCount();
  xpc_object_t source_dict = iio_xpc_get_source_dict(a3);
  xpc_object_t plugin_dict = iio_xpc_get_plugin_dict(a3);
  xpc_object_t callback_dict = iio_xpc_get_callback_dict(a3);
  xpc_object_t v10 = iio_xpc_add_message_dict(a4);
  xpc_object_t v11 = iio_xpc_add_callback_dict(a4);
  DataFromXPCDict = IIOImageRead::CreateDataFromXPCDict((IIOImageRead *)a3, v12);
  if (source_dict) {
    CFDictionaryRef v14 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(source_dict, "iio_xpc_src_options");
  }
  else {
    CFDictionaryRef v14 = 0;
  }
  memset(v84, 0, sizeof(v84));
  IIODictionary::IIODictionary((IIODictionary *)v84, v14);
  if (source_dict) {
    CFDictionaryRef v16 = (const __CFDictionary *)iio_xpc_dictionary_copy_CFDictionary(source_dict, "iio_xpc_src_properties");
  }
  else {
    CFDictionaryRef v16 = 0;
  }
  memset(v83, 0, sizeof(v83));
  IIODictionary::IIODictionary((IIODictionary *)v83, v16);
  if (v16) {
    CFRelease(v16);
  }
  CGMutableImageMetadataRef Mutable = CGImageMetadataCreateMutable();
  xpc_object_t xdict = v11;
  long long v79 = v10;
  v82[5] = 0;
  _OWORD v82[6] = 0x10000;
  v82[3] = DataFromXPCDict;
  unsigned int v82[4] = 0;
  v82[0] = v84;
  v82[1] = v83;
  memory_object_size_t v82[2] = Mutable;
  uint64_t v18 = (*(uint64_t (**)(IIO_Reader *, void *))(*(void *)this + 240))(this, v82);
  uint64_t v19 = (IIOImageSource *)v18;
  uint64_t v15 = 4294967246;
  if (!v18 || !plugin_dict || !callback_dict) {
    goto LABEL_83;
  }
  (*(void (**)(uint64_t, xpc_object_t))(*(void *)v18 + 104))(v18, plugin_dict);
  *(void *)&v80[0] = 0;
  xpc_object_t GlobalInfo = iio_xpc_dictionary_get_GlobalInfo(plugin_dict, (uint64_t *)v80);
  if (*(void *)&v80[0])
  {
    xpc_object_t v21 = GlobalInfo;
    uint64_t v22 = IIOImageSource::count(v19);
    (*(void (**)(IIO_Reader *, uint64_t, xpc_object_t, void))(*(void *)this + 96))(this, v22, v21, *(void *)&v80[0]);
  }
  xpc_object_t v23 = iio_xpc_dictionary_copy_CFDictionary(callback_dict, "iio_xpc_cb_blockset_options");
  double CGRect = iio_xpc_dictionary_get_CGRect(callback_dict, "iio_xpc_cb_blockset_cgrect");
  double v26 = v25;
  double v28 = v27;
  double v30 = v29;
  iio_xpc_dictionary_get_CGSize(callback_dict, "iio_xpc_cb_blockset_dest_cgsize");
  double v32 = v31;
  double v34 = v33;
  if (source_dict)
  {
    unsigned int uint64 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_image_index");
    uint64_t v36 = xpc_dictionary_get_uint64(source_dict, "iio_xpc_src_image_type");
    if (v36 == 1)
    {
      xpc_object_t value = xpc_dictionary_get_value(callback_dict, "iio_xpc_cb_decode_iosurface");
      long long v86 = IOSurfaceLookupFromXPCObject(value);
      BOOL v38 = v86 != 0;
      uint64_t v36 = 1;
    }
    else
    {
      BOOL v38 = 0;
    }
  }
  else
  {
    unsigned int uint64 = 0;
    BOOL v38 = 0;
    uint64_t v36 = 3;
  }
  (*(void (**)(IIOImageSource *, xpc_object_t))(*(void *)v19 + 80))(v19, v23);
  uint64_t v81 = 0;
  memset(v80, 0, sizeof(v80));
  IIODecodeParameter::IIODecodeParameter(v80, 0, 0, uint64, v23, CGRect, v26, v28, v30, v32, v34);
  uint64_t v15 = (*(uint64_t (**)(IIOImageSource *, _OWORD *, uint64_t, __IOSurface **, uint64_t *, void))(*(void *)v19 + 216))(v19, v80, v36, &v86, &v85, 0);
  if (v23) {
    CFRelease(v23);
  }
  if (v36 == 3)
  {
    uint64_t v15 = IIOReadPlugin::addImageBlocksToXPCObject(v19, a4);
  }
  else if (v36 == 1 && v86)
  {
    if (!v38)
    {
      xpc_object_t XPCObject = IOSurfaceCreateXPCObject(v86);
      if (XPCObject)
      {
        xpc_dictionary_set_value(xdict, "iio_xpc_cb_decode_iosurface", XPCObject);
        xpc_release(XPCObject);
      }
    }
    CFRelease(v86);
  }
  IIODecodeParameter::~IIODecodeParameter((IIODecodeParameter *)v80);
  if (v15 != -181)
  {
    if (!v15)
    {
      int v40 = *((_DWORD *)this + 6);
      unsigned int v41 = v40 >> 24;
      if (v40 < 0)
      {
        int v42 = __maskrune(v41, 0x40000uLL);
        int v40 = *((_DWORD *)this + 6);
      }
      else
      {
        int v42 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v41 + 60) & 0x40000;
      }
      if (v42) {
        uint64_t v46 = (v40 >> 24);
      }
      else {
        uint64_t v46 = 46;
      }
      unsigned int v47 = v40 << 8 >> 24;
      if (v40 << 8 < 0)
      {
        int v48 = __maskrune(v47, 0x40000uLL);
        int v40 = *((_DWORD *)this + 6);
      }
      else
      {
        int v48 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v47 + 60) & 0x40000;
      }
      if (v48) {
        uint64_t v52 = (v40 << 8 >> 24);
      }
      else {
        uint64_t v52 = 46;
      }
      unsigned int v53 = (__int16)v40 >> 8;
      if (v40 << 16 < 0)
      {
        int v54 = __maskrune(v53, 0x40000uLL);
        int v40 = *((_DWORD *)this + 6);
      }
      else
      {
        int v54 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v53 + 60) & 0x40000;
      }
      if (v54) {
        uint64_t v58 = ((__int16)v40 >> 8);
      }
      else {
        uint64_t v58 = 46;
      }
      if ((v40 << 24) <= 0x7F000000)
      {
        if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v40 + 60) & 0x40000) != 0) {
          goto LABEL_67;
        }
      }
      else if (__maskrune((char)v40, 0x40000uLL))
      {
LABEL_67:
        uint64_t v59 = *((char *)this + 24);
LABEL_70:
        IIOXPCLog("🔹 xpcDecodeImage [%c%c%c%c]...\n", v46, v52, v58, v59);
        xpc_object_t v60 = iio_xpc_add_plugin_dict(a4);
        (*(void (**)(IIOImageSource *, xpc_object_t))(*(void *)v19 + 112))(v19, v60);
        uint64_t v61 = IIOImageSource::count(v19);
        CFDataRef v62 = (const __CFData *)(*(uint64_t (**)(IIO_Reader *, uint64_t))(*(void *)this + 104))(this, v61);
        if (v62)
        {
          iio_xpc_dictionary_add_GlobalInfo(v60, v62, *((_DWORD *)this + 6));
          CFRelease(v62);
        }
        uint64_t v15 = 0;
        goto LABEL_107;
      }
      uint64_t v59 = 46;
      goto LABEL_70;
    }
LABEL_83:
    int v65 = *((_DWORD *)this + 6);
    unsigned int v66 = v65 >> 24;
    uint64_t v67 = MEMORY[0x1E4F14390];
    if (v65 < 0)
    {
      int v68 = __maskrune(v66, 0x40000uLL);
      int v65 = *((_DWORD *)this + 6);
    }
    else
    {
      int v68 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v66 + 60) & 0x40000;
    }
    if (v68) {
      uint64_t v69 = (v65 >> 24);
    }
    else {
      uint64_t v69 = 46;
    }
    unsigned int v70 = v65 << 8 >> 24;
    if (v65 << 8 < 0)
    {
      int v71 = __maskrune(v70, 0x40000uLL);
      int v65 = *((_DWORD *)this + 6);
    }
    else
    {
      int v71 = *(_DWORD *)(v67 + 4 * v70 + 60) & 0x40000;
    }
    if (v71) {
      uint64_t v72 = (v65 << 8 >> 24);
    }
    else {
      uint64_t v72 = 46;
    }
    unsigned int v73 = (__int16)v65 >> 8;
    if (v65 << 16 < 0)
    {
      int v74 = __maskrune(v73, 0x40000uLL);
      int v65 = *((_DWORD *)this + 6);
    }
    else
    {
      int v74 = *(_DWORD *)(v67 + 4 * v73 + 60) & 0x40000;
    }
    if (v74) {
      uint64_t v75 = ((__int16)v65 >> 8);
    }
    else {
      uint64_t v75 = 46;
    }
    if ((v65 << 24) <= 0x7F000000)
    {
      if ((*(_DWORD *)(v67 + 4 * (char)v65 + 60) & 0x40000) != 0) {
        goto LABEL_103;
      }
    }
    else if (__maskrune((char)v65, 0x40000uLL))
    {
LABEL_103:
      uint64_t v76 = *((char *)this + 24);
LABEL_106:
      IIOXPCLog("♦️ xpcDecodeImage [%c%c%c%c] err=%d)\n", v69, v72, v75, v76, v15);
      goto LABEL_107;
    }
    uint64_t v76 = 46;
    goto LABEL_106;
  }
  int v43 = *((_DWORD *)this + 6);
  unsigned int v44 = v43 >> 24;
  if (v43 < 0)
  {
    int v45 = __maskrune(v44, 0x40000uLL);
    int v43 = *((_DWORD *)this + 6);
  }
  else
  {
    int v45 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v44 + 60) & 0x40000;
  }
  if (v45) {
    uint64_t v49 = (v43 >> 24);
  }
  else {
    uint64_t v49 = 46;
  }
  unsigned int v50 = v43 << 8 >> 24;
  if (v43 << 8 < 0)
  {
    int v51 = __maskrune(v50, 0x40000uLL);
    int v43 = *((_DWORD *)this + 6);
  }
  else
  {
    int v51 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v50 + 60) & 0x40000;
  }
  if (v51) {
    uint64_t v55 = (v43 << 8 >> 24);
  }
  else {
    uint64_t v55 = 46;
  }
  unsigned int v56 = (__int16)v43 >> 8;
  if (v43 << 16 < 0)
  {
    int v57 = __maskrune(v56, 0x40000uLL);
    int v43 = *((_DWORD *)this + 6);
  }
  else
  {
    int v57 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v56 + 60) & 0x40000;
  }
  if (v57) {
    uint64_t v63 = ((__int16)v43 >> 8);
  }
  else {
    uint64_t v63 = 46;
  }
  if ((v43 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)v43 + 60) & 0x40000) != 0) {
      goto LABEL_79;
    }
LABEL_81:
    uint64_t v64 = 46;
    goto LABEL_82;
  }
  if (!__maskrune((char)v43, 0x40000uLL)) {
    goto LABEL_81;
  }
LABEL_79:
  uint64_t v64 = *((char *)this + 24);
LABEL_82:
  uint64_t v15 = 4294967115;
  IIOXPCLog("❗️ request not handled [%c%c%c%c] err=%d)\n", v49, v55, v63, v64, -181);
LABEL_107:
  iio_xpc_dictionary_set_error_code(v79, v15);
  if (v14) {
    CFRelease(v14);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (DataFromXPCDict) {
    CFRelease(DataFromXPCDict);
  }
  if (v19) {
    (*(void (**)(IIOImageSource *))(*(void *)v19 + 8))(v19);
  }
  IIODictionary::~IIODictionary((IIODictionary *)v83);
  IIODictionary::~IIODictionary((IIODictionary *)v84);
  IIODictionary::~IIODictionary((IIODictionary *)v87);
  return v15;
}

void sub_18870C840(_Unwind_Exception *a1)
{
  IIODictionary::~IIODictionary((IIODictionary *)(v1 - 160));
  _Unwind_Resume(a1);
}

void sub_18870C860(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  IIODictionary::~IIODictionary((IIODictionary *)&a35);
  IIODictionary::~IIODictionary((IIODictionary *)(v35 - 200));
  JUMPOUT(0x18870C874);
}

uint64_t IIO_Reader::CopyIOSurfaceProc420f(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 8);
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v6 + 80))(v6, a3))
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v6 + 240))(v6, a1, a2, a3);
  (*(void (**)(uint64_t))(*(void *)v6 + 88))(v6);
  return v7;
}

void sub_18870C970(void *a1)
{
}

uint64_t IIO_Reader::CopyIOSurfaceSetProc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 8);
  if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v6 + 80))(v6, a3))
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v6 + 248))(v6, a1, a2, a3);
  (*(void (**)(uint64_t))(*(void *)v6 + 88))(v6);
  if ((gIIODebugFlags & 0x800000000000) != 0 && !v7) {
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CopyIOSurfaceSetProc", 1698, "could not create CGImageIOSurfaceSetRef");
  }
  return v7;
}

void sub_18870CAB0(void *a1)
{
}

void IIO_Reader_BMP::createReadPlugin()
{
}

{
  operator new();
}

void sub_18870CB28(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40D3E8E32CLL);
  _Unwind_Resume(a1);
}

void sub_18870CBC8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C40D3E8E32CLL);
  _Unwind_Resume(a1);
}

void *TIFFHashSetNew(uint64_t (*a1)(), BOOL (*a2)(uint64_t a1, uint64_t a2), uint64_t a3)
{
  uint64_t v6 = malloc_type_malloc(0x40uLL, 0x10A0040F3714300uLL);
  uint64_t v7 = v6;
  if (v6)
  {
    if (a1) {
      unsigned int v8 = a1;
    }
    else {
      unsigned int v8 = TIFFHashSetHashPointer;
    }
    if (a2) {
      xpc_object_t v9 = a2;
    }
    else {
      xpc_object_t v9 = TIFFHashSetEqualPointer;
    }
    *uint64_t v6 = v8;
    v6[1] = v9;
    void v6[2] = a3;
    *((_DWORD *)v6 + 8) = 0;
    xpc_object_t v10 = malloc_type_calloc(0x35uLL, 8uLL, 0x2004093837F09uLL);
    _OWORD v7[3] = v10;
    if (v10)
    {
      *(void *)((char *)v7 + 3jp2_colour_converter::clear(this + 6) = 0x3500000000;
      v7[6] = 0;
      *((_DWORD *)v7 + 14) = 0;
      *((unsigned char *)v7 + 60) = 0;
    }
    else
    {
      free(v7);
      return 0;
    }
  }
  return v7;
}

BOOL TIFFHashSetEqualPointer(uint64_t a1, uint64_t a2)
{
  return a1 == a2;
}

uint64_t TIFFHashSetSize(uint64_t a1)
{
  if (!a1) {
    TIFFHashSetSize_cold_1();
  }
  return *(unsigned int *)(a1 + 32);
}

void TIFFHashSetDestroy(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(_DWORD *)(a1 + 40);
    if (v2 >= 1)
    {
      for (uint64_t i = 0; i < v2; *(void *)(v4 + 8 * i++) = 0)
      {
        uint64_t v4 = *(void *)(a1 + 24);
        int v5 = *(void **)(v4 + 8 * i);
        if (v5)
        {
          do
          {
            uint64_t v6 = *(void (**)(void))(a1 + 16);
            if (v6) {
              v6(*v5);
            }
            uint64_t v7 = (void *)v5[1];
            free(v5);
            int v5 = v7;
          }
          while (v7);
          uint64_t v4 = *(void *)(a1 + 24);
          int v2 = *(_DWORD *)(a1 + 40);
        }
      }
    }
    *(unsigned char *)(a1 + 60) = 0;
    free(*(void **)(a1 + 24));
    unsigned int v8 = *(void **)(a1 + 48);
    if (v8)
    {
      do
      {
        xpc_object_t v9 = (void *)v8[1];
        free(v8);
        unsigned int v8 = v9;
      }
      while (v9);
    }
    free((void *)a1);
  }
}

uint64_t TIFFHashSetInsert(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    TIFFHashSetInsert_cold_1();
  }
  Ptr = TIFFHashSetFindPtr(a1, a2);
  if (Ptr)
  {
    int v5 = Ptr;
    uint64_t v6 = *(void (**)(uint64_t))(a1 + 16);
    if (v6) {
      v6(*Ptr);
    }
    *int v5 = a2;
    return 1;
  }
  int v7 = *(_DWORD *)(a1 + 32);
  if (v7 >= 2 * *(_DWORD *)(a1 + 40) / 3)
  {
    int v8 = *(_DWORD *)(a1 + 36);
  }
  else
  {
    if (!*(unsigned char *)(a1 + 60)) {
      goto LABEL_16;
    }
    int v8 = *(_DWORD *)(a1 + 36);
    if (v7 > *(_DWORD *)(a1 + 40) / 2 || v8 < 1) {
      goto LABEL_16;
    }
  }
  *(_DWORD *)(a1 + 3jp2_colour_converter::clear(this + 6) = v8 + 1;
  if (!TIFFHashSetRehash(a1))
  {
    --*(_DWORD *)(a1 + 36);
    goto LABEL_22;
  }
LABEL_16:
  unint64_t v10 = (*(uint64_t (**)(uint64_t))a1)(a2);
  unint64_t v11 = *(int *)(a1 + 40);
  int v12 = *(void **)(a1 + 48);
  if (v12)
  {
    void *v12 = 0;
    --*(_DWORD *)(a1 + 56);
    *(void *)(a1 + 48) = v12[1];
LABEL_20:
    void *v12 = a2;
    uint64_t v13 = *(void *)(a1 + 24);
    v12[1] = *(void *)(v13 + 8 * (v10 % v11));
    *(void *)(v13 + 8 * (v10 % v11)) = v12;
    ++*(_DWORD *)(a1 + 32);
    return 1;
  }
  int v12 = malloc_type_malloc(0x10uLL, 0xA0040BD48D6D6uLL);
  if (v12) {
    goto LABEL_20;
  }
LABEL_22:
  uint64_t v15 = *(void (**)(uint64_t))(a1 + 16);
  if (v15) {
    v15(a2);
  }
  return 0;
}

void *TIFFHashSetFindPtr(uint64_t a1, uint64_t a2)
{
  for (uint64_t i = *(void **)(*(void *)(a1 + 24)
                       + 8 * ((*(uint64_t (**)(uint64_t))a1)(a2) % (unint64_t)*(int *)(a1 + 40)));
        i;
        uint64_t i = (void *)i[1])
  {
    if ((*(uint64_t (**)(void, uint64_t))(a1 + 8))(*i, a2)) {
      break;
    }
  }
  return i;
}

BOOL TIFFHashSetRehash(uint64_t a1)
{
  int v2 = anPrimes[*(int *)(a1 + 36)];
  uint64_t v3 = malloc_type_calloc(v2, 8uLL, 0x2004093837F09uLL);
  if (v3)
  {
    int v4 = *(_DWORD *)(a1 + 40);
    if (v4 >= 1)
    {
      for (uint64_t i = 0; i < v4; ++i)
      {
        uint64_t v6 = *(void **)(*(void *)(a1 + 24) + 8 * i);
        if (v6)
        {
          do
          {
            unint64_t v7 = (*(uint64_t (**)(void))a1)(*v6);
            int v8 = (void *)v6[1];
            v6[1] = v3[v7 % v2];
            v3[v7 % v2] = v6;
            uint64_t v6 = v8;
          }
          while (v8);
          int v4 = *(_DWORD *)(a1 + 40);
        }
      }
    }
    free(*(void **)(a1 + 24));
    *(void *)(a1 + 24) = v3;
    *(_DWORD *)(a1 + 40) = v2;
    *(unsigned char *)(a1 + 60) = 0;
  }
  return v3 != 0;
}

void *TIFFHashSetLookup(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    TIFFHashSetLookup_cold_1();
  }
  uint64_t result = TIFFHashSetFindPtr(a1, a2);
  if (result) {
    return (void *)*result;
  }
  return result;
}

uint64_t TIFFHashSetRemove(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    TIFFHashSetRemove_cold_1();
  }
  int v4 = *(_DWORD *)(a1 + 36);
  BOOL v5 = __OFSUB__(v4, 1);
  int v6 = v4 - 1;
  if (v6 < 0 == v5 && *(_DWORD *)(a1 + 32) <= *(_DWORD *)(a1 + 40) / 2)
  {
    *(_DWORD *)(a1 + 3jp2_colour_converter::clear(this + 6) = v6;
    if (!TIFFHashSetRehash(a1))
    {
      uint64_t result = 0;
      ++*(_DWORD *)(a1 + 36);
      return result;
    }
  }
  unint64_t v7 = (*(uint64_t (**)(uint64_t))a1)(a2) % (unint64_t)*(int *)(a1 + 40);
  int v8 = *(void **)(*(void *)(a1 + 24) + 8 * (int)v7);
  if (!v8) {
    return 0;
  }
  if (((*(uint64_t (**)(void, uint64_t))(a1 + 8))(*v8, a2) & 1) == 0)
  {
    while (1)
    {
      unint64_t v10 = v8;
      int v8 = (void *)v8[1];
      if (!v8) {
        return 0;
      }
      if ((*(uint64_t (**)(void, uint64_t))(a1 + 8))(*v8, a2))
      {
        xpc_object_t v9 = v10 + 1;
        goto LABEL_11;
      }
    }
  }
  xpc_object_t v9 = (void *)(*(void *)(a1 + 24) + 8 * (int)v7);
LABEL_11:
  *xpc_object_t v9 = v8[1];
  unint64_t v11 = *(void (**)(void))(a1 + 16);
  if (v11) {
    v11(*v8);
  }
  int v12 = *(_DWORD *)(a1 + 56);
  if (v12 > 127)
  {
    free(v8);
  }
  else
  {
    v8[1] = *(void *)(a1 + 48);
    *(void *)(a1 + 48) = v8;
    *(_DWORD *)(a1 + 5jp2_colour_converter::clear(this + 6) = v12 + 1;
  }
  --*(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t CGImagePluginGetOptions(uint64_t a1)
{
  return *(void *)(IIOImagePlus::getOptions(*(IIOImagePlus **)(a1 + 24)) + 8);
}

uint64_t CGImagePluginGetProperties(uint64_t a1)
{
  return *(void *)(IIOImagePlus::getProperties(*(IIOImagePlus **)(a1 + 24)) + 8);
}

uint64_t CGImagePluginGetMetadata(uint64_t a1)
{
  return IIOImagePlus::getMetadata(*(IIOImagePlus **)(a1 + 24));
}

uint64_t CGImagePluginGetSession(uint64_t a1)
{
  return IIOImageSource::count(*(IIOImageSource **)(a1 + 24));
}

uint64_t CGImagePluginGetMatchToProfileOption(uint64_t a1)
{
  int MatchToProfileOption = IIOImagePlus::getMatchToProfileOption(*(IIOImagePlus **)(a1 + 24));
  uint64_t v2 = MEMORY[0x1E4F1CFD0];
  if (!MatchToProfileOption) {
    uint64_t v2 = MEMORY[0x1E4F1CFC8];
  }
  return *(void *)v2;
}

__n128 CGImagePluginSetImageBlockProc(uint64_t a1, uint64_t a2, CFTypeRef *a3, _DWORD *a4)
{
  if (a4)
  {
    uint64_t v5 = *(void *)(a2 + 32);
    int v6 = *(_DWORD *)(a2 + 40);
    uint64_t v7 = *(void *)(a2 + 48);
    int v8 = *(_DWORD *)(a2 + 56);
    int v9 = *(_DWORD *)(a2 + 60);
    uint64_t v10 = *(void *)(a1 + 24);
    long long v11 = *(_OWORD *)(a2 + 16);
    v14[0] = *(_OWORD *)a2;
    v14[1] = v11;
    uint64_t v15 = v5;
    int v16 = v6;
    int v17 = 0;
    uint64_t v18 = v7;
    int v19 = v8;
    int v20 = v9;
    int v21 = v9 & 0xF0000;
    int v22 = *(_DWORD *)(a2 + 64);
    IIOImagePlus::setGeometry(v10, a3, (uint64_t)v14);
    switch(*a4)
    {
      case 0:
        return _cg_jpeg_mem_term("CGImagePluginSetImageBlockProc", 187, "*** imageProvider callback version '0' no longer supported\n");
      case 1:
        uint64_t v13 = (IIOImagePlus *)v10;
        goto LABEL_10;
      case 2:
        uint64_t v13 = (IIOImagePlus *)v10;
        goto LABEL_10;
      case 3:
        uint64_t v13 = (IIOImagePlus *)v10;
LABEL_10:
        IIOImagePlus::setImageBlockProc(v13);
      default:
        __n128 result = _cg_jpeg_mem_term("CGImagePluginSetImageBlockProc", 206, "*** unknown imageProvider callback version [%d]\n");
        break;
    }
  }
  return result;
}

CGImageRef CGImagePluginSetImage(uint64_t a1, CGImage *a2)
{
  return IIOImagePlus::setImage(*(CGImageRef **)(a1 + 24), a2);
}

void CGImagePluginSetClipPath(uint64_t a1, const CGPath *a2)
{
}

uint64_t CGImagePluginSetJpegProvider(uint64_t a1, int a2)
{
  return IIOImagePlus::setJpegProvider(*(void *)(a1 + 24), a2);
}

__CFData *OFDCreatePDFDataFromURL(const __CFURL *a1)
{
  pthread_mutex_lock(&OFDCreatePDFDataFromURL::ofdLock);
  uint64_t v2 = _OFDCreatePDFDataFromURL(a1);
  pthread_mutex_unlock(&OFDCreatePDFDataFromURL::ofdLock);
  return v2;
}

void ASTCWritePlugin::ASTCWritePlugin(ASTCWritePlugin *this, IIOImageWriteSession *a2, IIOImageDestination *a3, char a4)
{
  CommonASTCWritePlugin::CommonASTCWritePlugin(this, a2, a3, 67);
  *(void *)uint64_t v5 = &unk_1ED4E3158;
  *(unsigned char *)(v5 + 62) = a4;
  *(unsigned char *)(v5 + 60) = a4 ^ 1;
  *(unsigned char *)(v5 + 6++*((_DWORD *)this + 3) = 1;
  *(void *)(v5 + 64) = 0;
}

void ASTCWritePlugin::ASTCWritePlugin(CommonASTCWritePlugin *a1, IIOImageWriteSession *a2, IIOImageDestination *a3, uint64_t a4)
{
  CommonASTCWritePlugin::CommonASTCWritePlugin(a1, a2, a3, 67);
  *(void *)uint64_t v5 = &unk_1ED4E3158;
  *(_WORD *)(v5 + 62) = 256;
  *(unsigned char *)(v5 + 60) = 0;
  *(void *)(v5 + 64) = a4;
}

void ASTCWritePlugin::~ASTCWritePlugin(CommonASTCWritePlugin *this, uint64_t a2, const char *a3)
{
  *(void *)this = &unk_1ED4E3158;
  CommonASTCWritePlugin::~CommonASTCWritePlugin(this, a2, a3);
}

void ASTCWritePlugin::~ASTCWritePlugin(ASTCWritePlugin *this, uint64_t a2, const char *a3)
{
  *(void *)this = &unk_1ED4E3158;
  CommonASTCWritePlugin::~CommonASTCWritePlugin(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

const __CFDictionary *ASTCWritePlugin::handleProperties(ASTCWritePlugin *this, IIODictionary *a2)
{
  CFDictionaryRef result = CommonASTCWritePlugin::handleProperties(this, a2);
  *((unsigned char *)this + 58) = 0;
  if (a2) {
    *((unsigned char *)this + 6++*((_DWORD *)this + 3) = 1;
  }
  return result;
}

uint64_t ASTCWritePlugin::writeASTCHeader(IIOImageWriteSession **this, int a2, int a3, int a4, char a5, char a6)
{
  int v7 = 1554098963;
  char v8 = a5;
  char v9 = a6;
  char v10 = 1;
  __int16 v11 = a2;
  char v12 = BYTE2(a2);
  __int16 v13 = a3;
  char v14 = BYTE2(a3);
  __int16 v15 = a4;
  char v16 = BYTE2(a4);
  if (IIOImageWriteSession::putBytes(this[2], &v7, 0x10uLL) == 64) {
    return 0;
  }
  else {
    return 4294967246;
  }
}

uint64_t ASTCWritePlugin::writeOneImage(ASTCWritePlugin *this, CGImage *a2, IIODictionary *a3, IIODictionary *a4)
{
  return 4294967240;
}

uint64_t ASTCWritePlugin::writeOne(ASTCWritePlugin *this, IIOImagePixelDataProvider *a2, IIODictionary *a3, IIODictionary *a4)
{
  (*(void (**)(ASTCWritePlugin *, IIODictionary *))(*(void *)this + 56))(this, a3);
  int AlphaInfo = IIOImagePixelDataProvider::getAlphaInfo(a2);
  __int16 BitmapInfo = IIOImagePixelDataProvider::getBitmapInfo(a2);
  IIOImageSource::imageReadRef(a2);
  CGImageGetImageProvider();
  char v8 = (void *)*MEMORY[0x1E4F1CFD0];
  uint64_t Property = CGImageProviderGetProperty();
  unsigned int v10 = *((_DWORD *)this + 13);
  if (v8 == (void *)Property)
  {
    CFNumberRef v11 = (const __CFNumber *)CGImageProviderGetProperty();
    if (v11)
    {
      IIONumber::IIONumber((IIONumber *)&imageSize, v11);
      unsigned int v10 = IIONumber::uint32Num((IIONumber *)&imageSize);
      IIONumber::~IIONumber((IIONumber *)&imageSize);
    }
  }
  int v12 = 0;
  at_alpha_t v13 = at_alpha_premultiplied;
  switch(AlphaInfo)
  {
    case 0:
    case 5:
    case 6:
      goto LABEL_7;
    case 1:
    case 2:
      break;
    case 3:
    case 4:
      at_alpha_t v13 = at_alpha_not_premultiplied;
      int v12 = 1;
      break;
    default:
      _cg_jpeg_mem_term("writeOne", 179, "### alpha not handled: %X\n", AlphaInfo);
LABEL_7:
      int v12 = 0;
      at_alpha_t v13 = at_alpha_opaque;
      break;
  }
  int v64 = v12;
  int v14 = *((_DWORD *)this + 11);
  int v68 = (void *)Property;
  if (v14 == 68)
  {
    char v63 = 4;
  }
  else
  {
    if (v14 == 136)
    {
      char v63 = 8;
      at_block_format_t v15 = at_block_format_astc_8x8_ldr;
      goto LABEL_14;
    }
    LogError("writeOne", 202, "blockSize: '%02X' not yet supported - falling back to '44'\n", v14);
    *(void *)((char *)this + 44) = 0x400000044;
    char v63 = 4;
    *((_DWORD *)this + 1++*((_DWORD *)this + 3) = 4;
  }
  at_block_format_t v15 = at_block_format_astc_4x4_ldr;
LABEL_14:
  SourceGeomColorSpace = (CGColorSpace *)IIOImagePlus::getSourceGeomColorSpace(a2);
  CGColorSpaceModel Model = CGColorSpaceGetModel(SourceGeomColorSpace);
  int Error = _cg_GifLastError((uint64_t)a2);
  int v71 = v8;
  unsigned int v66 = v10;
  if (Model == kCGColorSpaceModelRGB)
  {
    uint64_t v22 = 7;
    if ((BitmapInfo & 0x100) != 0) {
      uint64_t v22 = 10;
    }
    BOOL v20 = Error == 16;
    int v19 = (Error == 16) & ((unsigned __int16)(BitmapInfo & 0x100) >> 8);
    uint64_t v21 = 5;
    goto LABEL_21;
  }
  if (Model)
  {
    LOBYTE(v19) = 0;
    at_texel_format_t v23 = at_texel_format_invalid;
    CGColorSpaceModel Model = kCGColorSpaceModelRGB;
    goto LABEL_28;
  }
  if (Error == 16)
  {
    LOBYTE(v19) = 0;
    CGColorSpaceModel Model = kCGColorSpaceModelMonochrome;
    BOOL v20 = AlphaInfo == 0;
    uint64_t v21 = 4;
    uint64_t v22 = 2;
LABEL_21:
    if (v20) {
      at_texel_format_t v23 = v22;
    }
    else {
      at_texel_format_t v23 = v21;
    }
    goto LABEL_28;
  }
  LOBYTE(v19) = 0;
  CGColorSpaceModel Model = kCGColorSpaceModelMonochrome;
  if (AlphaInfo) {
    at_texel_format_t v23 = at_texel_format_la8_unorm;
  }
  else {
    at_texel_format_t v23 = at_texel_format_l8_unorm;
  }
LABEL_28:
  unsigned int v70 = IIOImageSource::count(a2);
  unsigned int v24 = IIO_Reader::testHeaderSize(a2);
  if (*((unsigned char *)this + 62))
  {
    if (Model)
    {
      if (IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E4F1DB90]))
      {
        unsigned int v25 = 3;
      }
      else if (IIO_CGColorSpaceNameMatchesName(SourceGeomColorSpace, (const __CFString *)*MEMORY[0x1E4F1DB78]))
      {
        unsigned int v25 = 2;
      }
      else
      {
        unsigned int v25 = 1;
      }
    }
    else
    {
      unsigned int v25 = 0;
    }
    int v26 = 0;
    int v27 = *((_DWORD *)this + 11);
    if (v27 > 135)
    {
      if (v27 > 201)
      {
        if (v27 == 202)
        {
          int v26 = 37820;
        }
        else if (v27 == 204)
        {
          int v26 = 37821;
        }
      }
      else
      {
        switch(v27)
        {
          case 165:
            int v26 = 37816;
            break;
          case 166:
          case 168:
            int v26 = 37817;
            break;
          case 167:
          case 169:
            break;
          case 170:
            int v26 = 37818;
            break;
          default:
            if (v27 == 136) {
              int v26 = 37815;
            }
            break;
        }
      }
    }
    else if (v27 <= 100)
    {
      switch(v27)
      {
        case 'D':
          int v26 = 37808;
          break;
        case 'T':
          int v26 = 37809;
          break;
        case 'U':
          int v26 = 37810;
          break;
      }
    }
    else if (v27 > 132)
    {
      if (v27 == 133)
      {
        int v26 = 37813;
      }
      else if (v27 == 134)
      {
        int v26 = 37814;
      }
    }
    else if (v27 == 101)
    {
      int v26 = 37811;
    }
    else if (v27 == 102)
    {
      int v26 = 37812;
    }
    KTXWritePlugin::writeKTXHeader(*((IIOImageWriteSession **)this + 2), v70, v24, 0, v25, AlphaInfo, 0, 1, 0, v26, *((unsigned char *)this + 57), *((unsigned char *)this + 63));
  }
  double v28 = at_encoder_create(v23, v13, v15, v13, 0);
  uint64_t v87 = 0;
  if (*((unsigned char *)this + 56))
  {
    char v29 = v19 ^ 1;
    if (*((unsigned char *)this + 60)) {
      char v29 = 1;
    }
    if ((v29 & 1) == 0)
    {
      float v30 = (float)((float)(*((float *)this + 10) / -0.0032) + 1.0) * 100.0;
      long long v85 = 0u;
      memset(v86, 0, sizeof(v86));
      long long v83 = 0u;
      long long v84 = 0u;
      imageunsigned int Size = 0u;
      long long v82 = 0u;
      if (astcenc_config_init(3u, *((_DWORD *)this + 12), *((_DWORD *)this + 13), 1u, 0, (uint64_t)&imageSize, v30))
      {
        LogError("writeOne", 323, "*** could not initialize astcenc codec\n");
LABEL_78:
        double v34 = 0;
        uint64_t v72 = 0;
LABEL_79:
        uint64_t v35 = 0;
        goto LABEL_124;
      }
      uint64_t v31 = IIOImagePlus::sourceImageProvider(a2);
      uint64_t v32 = 8 * v70;
      if (v31 != v32) {
        ASTCTextureImp::setLock_dataSize((uint64_t)a2, v32);
      }
      if (!*((unsigned char *)this + 61))
      {
        int v33 = DWORD1(imageSize);
        DWORD1(imageSize) |= 8u;
        if (v64) {
          DWORD1(imageSize) = v33 | 0xC;
        }
      }
      if (astcenc_context_alloc((uint64_t)&imageSize, 1))
      {
        LogError("writeOne", 339, "*** could not allocate astcenc context\n");
        goto LABEL_78;
      }
    }
  }
  if (!v28)
  {
    uint64_t v35 = 0;
    uint64_t v72 = 0;
    double v34 = 0;
    goto LABEL_126;
  }
  BOOL is_compression_monolithic = at_encoder_is_compression_monolithic(v28, at_flags_default);
  uint64_t v37 = IIOImagePlus::sourceImageProvider(a2);
  uint64_t v38 = v37;
  *(void *)&long long v83 = 0;
  imageunsigned int Size = 0u;
  long long v82 = 0u;
  memset(&dest, 0, sizeof(dest));
  unint64_t v77 = 0;
  uint64_t v78 = 0;
  p_imageunsigned int Size = 0;
  if (v71 != v68 || is_compression_monolithic)
  {
    uint64_t v39 = v24;
    unsigned int v40 = v70;
  }
  else
  {
    uint64_t v39 = v24;
    unsigned int v40 = v70;
    if (!*((unsigned char *)this + 60))
    {
      uint64_t v41 = v66;
      do
      {
        uint64_t v39 = v41;
        char v42 = v41 * v70;
        v41 *= 2;
      }
      while ((v42 & 0xF) != 0);
    }
  }
  uint64_t v43 = v39 * v37;
  uint64_t v72 = malloc_type_malloc(v39 * v37, 0xAE4BB495uLL);
  *(void *)&imageunsigned int Size = 0;
  *((void *)&imageSize + 1) = __PAIR64__(v24, v40);
  LODWORD(v82) = 1;
  *((void *)&v82 + 1) = v38;
  *(void *)&long long v83 = 0;
  unint64_t v77 = __PAIR64__(v24, v40);
  uint64_t v78 = 0x100000001;
  *(void *)&v88.CGFloat x = __PAIR64__(v24, v40);
  v88.z = 1;
  unint64_t block_counts = (unint64_t)at_encoder_get_block_counts(v28, v88);
  uint64_t v67 = v28;
  block_uint64_t size = at_encoder_get_block_size(v28);
  size_t v46 = block_counts * block_size;
  size_t v47 = (HIDWORD(block_counts) * block_counts) * block_size;
  dest.size_t rowBytes = v46;
  dest.sliceBytes = v47;
  int v48 = (char *)malloc_type_calloc(v47, 1uLL, 0x5C2AC7E0uLL);
  double v34 = v48;
  if (v47) {
    BOOL v49 = v48 == 0;
  }
  else {
    BOOL v49 = 1;
  }
  if (v49)
  {
    LogError("writeOne", 395, "*** could not allocate dest buffer [%d bytes]\n", v47);
    uint64_t v35 = 0;
    goto LABEL_124;
  }
  uint64_t v69 = v48;
  dest.blocks = v48;
  uint64_t v50 = 16 * *((unsigned __int8 *)this + 60);
  if (*((unsigned char *)this + 61)) {
    v50 |= 0x40uLL;
  }
  at_flags_t v65 = v50;
  if (!v24)
  {
LABEL_107:
    uint64_t v53 = *((void *)this + 8);
    if (v53)
    {
      uint64_t v35 = 4294967246;
      double v28 = v67;
      double v34 = v69;
      if ((*(uint64_t (**)(void))(*(void *)(v53 + 8) + 24))() == v47)
      {
        if ((*(unsigned int (**)(void))(*(void *)(*((void *)this + 8) + 8) + 64))()) {
          uint64_t v35 = 4294967246;
        }
        else {
          uint64_t v35 = 0;
        }
      }
      goto LABEL_124;
    }
    double v28 = v67;
    double v34 = v69;
    if (!*((unsigned char *)this + 62))
    {
      *((unsigned char *)this + 57) = 0;
      ASTCWritePlugin::writeASTCHeader((IIOImageWriteSession **)this, v70, v24, 1, v63, v63);
      IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), v69, v47);
      goto LABEL_79;
    }
    unint64_t v75 = 0;
    v76[0] = 0;
    if (*((unsigned char *)this + 57))
    {
      BOOL LZFSECompressedData = IIOWritePlugin::createLZFSECompressedData(this, (unsigned __int8 *)v69, v47, v76, (unsigned __int8 **)&v75);
      BOOL v55 = LZFSECompressedData;
      int v56 = v75;
      if (v75 < 9 || *(_DWORD *)v76[0] == 846755426 && *(_DWORD *)&v76[0][v75 - 4] == 611874402)
      {
        if (LZFSECompressedData)
        {
          uint64_t v35 = 0;
          goto LABEL_135;
        }
      }
      else
      {
        _cg_jpeg_mem_term("writeOne", 490, "    ERROR: bad LZFSE data (does not start/end with 'bvx2'/'bvx$')\n");
        if (v55)
        {
          uint64_t v35 = 4294967246;
          int v56 = v75;
LABEL_135:
          int __ptr = v56 + 8;
          IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), &__ptr, 4uLL);
          if ((gIIODebugFlags & 0x30000) != 0)
          {
            ImageIOLog("    KTX with LZFSE compressed ASTC data\n");
            if ((gIIODebugFlags & 0x30000) != 0)
            {
              ImageIOLog("            compressedLZFSEData: %p\n", v76[0]);
              if ((gIIODebugFlags & 0x30000) != 0)
              {
                ImageIOLog("            compressedLZFSESize: %d\n", v75);
                if ((gIIODebugFlags & 0x30000) != 0) {
                  ImageIOLog("                           type: 'LZFS'\n");
                }
              }
            }
          }
          int v73 = 1397119564;
          IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), &v73, 4uLL);
          IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), &v75, 4uLL);
          uint64_t v59 = (IIOImageWriteSession *)*((void *)this + 2);
          size_t v61 = v75;
          xpc_object_t v60 = v76[0];
          goto LABEL_146;
        }
      }
    }
    int __ptr = v47;
    size_t v62 = IIOImageWriteSession::putBytes(*((IIOImageWriteSession **)this + 2), &__ptr, 4uLL);
    if (v62 == 4) {
      uint64_t v35 = 0;
    }
    else {
      uint64_t v35 = 4294967246;
    }
    if (v62 != 4)
    {
LABEL_147:
      if (v76[0]) {
        free(v76[0]);
      }
      goto LABEL_124;
    }
    uint64_t v59 = (IIOImageWriteSession *)*((void *)this + 2);
    xpc_object_t v60 = (unsigned __int8 *)v69;
    size_t v61 = v47;
LABEL_146:
    IIOImageWriteSession::putBytes(v59, v60, v61);
    goto LABEL_147;
  }
  unsigned int v51 = 0;
  while (1)
  {
    if (v39 + (unint64_t)v51 > v24)
    {
      uint64_t v39 = v24 - v51;
      uint64_t v43 = v38 * v39;
    }
    HIDWORD(imageSize) = v39;
    *(void *)&imageunsigned int Size = v72;
    if (IIOImagePixelDataProvider::getBytes((uint64_t (**)(IIOImagePixelDataProvider *, void *))a2, v72) != v43)
    {
      LogError("writeOne", 425, "failed to read %ld bytes\n");
      goto LABEL_122;
    }
    dest.blocks = &v69[dest.rowBytes * (v51 / *((_DWORD *)this + 13))];
    if (!v87) {
      break;
    }
    HIDWORD(v77) = v39;
    p_imageunsigned int Size = &imageSize;
    *(_OWORD *)uint64_t v76 = xmmword_18898C3A0;
    unsigned int v52 = astcenc_compress_image(v87, (uint64_t)&v77);
    if (v52)
    {
      error_string = astcenc_get_error_string(v52);
      LogError("writeOne", 441, "*** ERROR: astcenc codec compress failed: %s\n", error_string);
      uint64_t v35 = 0;
      goto LABEL_123;
    }
LABEL_106:
    v51 += v39;
    if (v51 >= v24) {
      goto LABEL_107;
    }
  }
  if (at_encoder_compress_texels(v67, (const at_texel_region_t *)&imageSize, &dest, *((float *)this + 10), v65) >= 0.0) {
    goto LABEL_106;
  }
  LogError("writeOne", 448, "*** ERROR: at_encoder_compress_texels: %g (%ld)\n");
LABEL_122:
  uint64_t v35 = 4294967246;
LABEL_123:
  double v28 = v67;
  double v34 = v69;
LABEL_124:
  if (v28) {
    CFRelease(v28);
  }
LABEL_126:
  if (v87) {
    astcenc_context_free(v87);
  }
  if (v34) {
    free(v34);
  }
  if (v72) {
    free(v72);
  }
  return v35;
}

void sub_18870E080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

uint64_t ASTCWritePlugin::GetVkFormat(ASTCWritePlugin *this, IIODictionary *a2)
{
  if (IIODictionary::containsKey(this, @"kCGImagePropertyASTCBlockSize")) {
    BOOL v3 = IIODictionary::getUint32ForKey(this, @"kCGImagePropertyASTCBlockSize") == 136;
  }
  else {
    BOOL v3 = 0;
  }
  BOOL BoolForKey = IIODictionary::getBoolForKey(this, @"kCGImagePropertyASTCUseHDR");
  if (BoolForKey) {
    unsigned int v5 = 1000066007;
  }
  else {
    unsigned int v5 = 172;
  }
  if (BoolForKey) {
    unsigned int v6 = 1000066000;
  }
  else {
    unsigned int v6 = 158;
  }
  if (v3) {
    return v5;
  }
  else {
    return v6;
  }
}

void IIO_Writer_ASTC::~IIO_Writer_ASTC(IIO_Writer_ASTC *this, uint64_t a2, const char *a3)
{
  _cg_jpeg_mem_term(this, a2, a3);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIO_Writer_ASTC::write(IIO_Writer_ASTC *this, IIOImageWriteSession *a2, IIOImageDestination *a3)
{
  uint64_t v9 = 0;
  long long v8 = 0u;
  memset(v7, 0, sizeof(v7));
  CommonASTCWritePlugin::CommonASTCWritePlugin((CommonASTCWritePlugin *)v7, a2, a3, 67);
  *(void *)&v7[0] = &unk_1ED4E3158;
  HIWORD(v8) = 256;
  BYTE12(v8) = 1;
  uint64_t v9 = 0;
  uint64_t v3 = IIOWritePlugin::writeAll((IIOImageDestination **)v7);
  *(void *)&v7[0] = &unk_1ED4E3158;
  CommonASTCWritePlugin::~CommonASTCWritePlugin((CommonASTCWritePlugin *)v7, v4, v5);
  return v3;
}

void sub_18870E228(void *a1, uint64_t a2, const char *a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
}

uint64_t IIO_Writer::createWritePlugin(IIO_Writer *this, void *a2, void *a3)
{
  return 0;
}

uint64_t IIOFrameBufferQueue::IIOFrameBufferQueue(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4)
{
  *(void *)a1 = &unk_1ED4E4BA8;
  *(void *)(a1 + 8) = 0;
  int v7 = (void **)(a1 + 8);
  *(void *)(a1 + 1jp2_colour_converter::clear(this + 6) = 0;
  uint64_t v8 = a1 + 16;
  *(void *)(a1 + 32) = a2;
  *(unsigned char *)(a1 + 40) = 0;
  *(unsigned char *)(a1 + 224) = 0;
  *(unsigned char *)(a1 + 344) = 0;
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 41jp2_colour_converter::clear(this + 6) = 0;
  IIO_LoadCoreMediaSymbols();
  if (a4) {
    *int v7 = _Block_copy(a4);
  }
  *(_DWORD *)(a1 + 24) = 0;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 48), 0);
  pthread_cond_init((pthread_cond_t *)(a1 + 112), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 160), 0);
  pthread_cond_init((pthread_cond_t *)(a1 + 232), 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 280), 0);
  pthread_cond_init((pthread_cond_t *)(a1 + 352), 0);
  int v12 = 1;
  uint64_t v13 = a1;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  char v16 = getBufferDurationCallback;
  uint64_t v17 = 0;
  uint64_t v18 = compareBuffersCallback;
  uint64_t v19 = 0;
  BOOL v20 = getBufferSizeCallback;
  int v9 = gFunc_CMBufferQueueCreate(*MEMORY[0x1E4F1CF80], 0, &v12, v8);
  if (v9)
  {
    if ((gIIODebugFlags & 0x1000000000000) != 0) {
      ImageIOLog("*** CMBufferQueueCreate failed (status = %d)\n", v9);
    }
  }
  else
  {
    if (a3 <= 1) {
      a3 = 1;
    }
    unsigned int v10 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
    *(void *)(a1 + 400) = dispatch_queue_create("IIOFrameBufferQueue::producerQueue", v10);
    gFunc_CMBufferQueueInstallTriggerWithIntegerThreshold(*(void *)(a1 + 16), triggerFiredCallback, a1, 10, a3, a1 + 408);
    gFunc_CMBufferQueueInstallTriggerWithIntegerThreshold(*(void *)(a1 + 16), triggerFiredCallback, a1, 11, a3 - 1, a1 + 416);
  }
  return a1;
}

const char *getBufferDurationCallback@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return IIOFrameBufferQueue::_getBufferDuration(a1, a2);
}

uint64_t compareBuffersCallback(uint64_t a1, uint64_t a2)
{
  FrameIndeCGFloat x = IIOFrameBufferGetFrameIndex(a1);
  uint64_t v4 = IIOFrameBufferGetFrameIndex(a2);
  if (FrameIndex < v4) {
    return -1;
  }
  else {
    return FrameIndex > v4;
  }
}

void IIOFrameBufferQueue::~IIOFrameBufferQueue(NSObject **this)
{
  *this = &unk_1ED4E4BA8;
  IIOFrameBufferQueue::stop((IIOFrameBufferQueue *)this);
  uint64_t v2 = this[50];
  if (v2) {
    dispatch_release(v2);
  }
  uint64_t v3 = this[2];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = this[1];
  if (v4) {
    _Block_release(v4);
  }
}

{
  uint64_t vars8;

  IIOFrameBufferQueue::~IIOFrameBufferQueue(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t IIOFrameBufferQueue::stop(IIOFrameBufferQueue *this)
{
  if ((gIIODebugFlags & 0x1000000000000) != 0) {
    ImageIOLog("    IIOFrameBufferQueue::stop()\n");
  }
  atomic_store(1u, (unsigned __int8 *)this + 40);
  gFunc_CMBufferQueueReset(*((void *)this + 2));
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 160));
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 48));
  *((unsigned char *)this + 224) = 1;
  pthread_cond_broadcast((pthread_cond_t *)((char *)this + 232));
  pthread_cond_broadcast((pthread_cond_t *)((char *)this + 112));
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 160));
  pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 48));
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 280));
  while (*((unsigned char *)this + 344))
    pthread_cond_wait((pthread_cond_t *)((char *)this + 352), (pthread_mutex_t *)((char *)this + 280));

  return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 280));
}

void IIOFrameBufferQueue::startEnqueueingBuffers(IIOFrameBufferQueue *this, uint64_t a2)
{
  if (*((void *)this + 1))
  {
    if (!*((unsigned char *)this + 344))
    {
      uint64_t v6 = *((void *)this + 4);
      if (v6 <= a2)
      {
        LogError("startEnqueueingBuffers", 93, "Starting index: (%ld) out of range: (%d, %ld)\n", a2, 0, v6);
      }
      else
      {
        int v7 = dispatch_group_create();
        uint64_t v8 = *((void *)this + 50);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 0x40000000;
        block[2] = ___ZN19IIOFrameBufferQueue22startEnqueueingBuffersEl_block_invoke;
        block[3] = &__block_descriptor_tmp_5;
        block[4] = this;
        block[5] = a2;
        dispatch_group_async(v7, v8, block);
        int v9 = *((void *)this + 50);
        v10[0] = MEMORY[0x1E4F143A8];
        v10[1] = 0x40000000;
        _OWORD v10[2] = ___ZN19IIOFrameBufferQueue22startEnqueueingBuffersEl_block_invoke_2;
        void v10[3] = &__block_descriptor_tmp_6;
        v10[4] = this;
        v10[5] = v7;
        dispatch_group_notify(v7, v9, v10);
      }
      return;
    }
    uint64_t v3 = "Error: startEnqueueingBuffers called on already running queue\n";
    int v4 = 89;
  }
  else
  {
    uint64_t v3 = "CreateBuffers block is NULL\n";
    int v4 = 85;
  }

  LogError("startEnqueueingBuffers", v4, v3);
}

void ___ZN19IIOFrameBufferQueue22startEnqueueingBuffersEl_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  atomic_store(0, (unsigned __int8 *)(v1 + 40));
  *(unsigned char *)(v1 + 344) = 1;
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v1 + 40));
  if ((v3 & 1) == 0)
  {
    while (1)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v1 + 160));
      while (!*(unsigned char *)(v1 + 224))
        pthread_cond_wait((pthread_cond_t *)(v1 + 232), (pthread_mutex_t *)(v1 + 160));
      pthread_mutex_unlock((pthread_mutex_t *)(v1 + 160));
      unsigned __int8 v4 = atomic_load((unsigned __int8 *)(v1 + 40));
      if ((v4 & 1) == 0)
      {
        CFArrayRef v5 = (const __CFArray *)(*(uint64_t (**)(void))(*(void *)(v1 + 8) + 16))();
        CFIndex Count = CFArrayGetCount(v5);
        IIOFrameBufferQueue::_enqueueBuffers((IIOFrameBufferQueue *)v1, v5);
        CFRelease(v5);
        v2 += Count;
        if (v2 >= *(void *)(v1 + 32)) {
          break;
        }
      }
      unsigned __int8 v7 = atomic_load((unsigned __int8 *)(v1 + 40));
      if (v7) {
        return;
      }
    }
    uint64_t v8 = (void (*)(uint64_t))gFunc_CMBufferQueueMarkEndOfData;
    uint64_t v9 = *(void *)(v1 + 16);
    v8(v9);
  }
}

uint64_t IIOFrameBufferQueue::_enqueueBuffers(IIOFrameBufferQueue *this, const __CFArray *a2)
{
  unsigned __int8 v4 = (pthread_mutex_t *)((char *)this + 48);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 48));
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  void v6[2] = ___ZN19IIOFrameBufferQueue15_enqueueBuffersEPK9__CFArray_block_invoke;
  v6[3] = &__block_descriptor_tmp_12_0;
  v6[4] = this;
  IIOArrayEnumerateUsingBlock((uint64_t)a2, (uint64_t)v6);
  pthread_cond_broadcast((pthread_cond_t *)((char *)this + 112));
  return pthread_mutex_unlock(v4);
}

void ___ZN19IIOFrameBufferQueue22startEnqueueingBuffersEl_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 280));
  *(unsigned char *)(v2 + 344) = 0;
  pthread_cond_broadcast((pthread_cond_t *)(v2 + 352));
  pthread_mutex_unlock((pthread_mutex_t *)(v2 + 280));
  unsigned __int8 v3 = *(NSObject **)(a1 + 40);

  dispatch_release(v3);
}

const void *IIOFrameBufferQueue::getAndRetainBufferAtIndex(os_unfair_lock_s *this, uint64_t a2)
{
  if (*(void *)&this[8]._os_unfair_lock_opaque > a2)
  {
    unsigned __int8 v4 = this + 6;
    os_unfair_lock_lock(this + 6);
    HeadBuffer = (const void *)IIOFrameBufferQueue::_getHeadBuffer((IIOFrameBufferQueue *)this);
    FrameIndeCGFloat x = IIOFrameBufferGetFrameIndex((uint64_t)HeadBuffer);
    if (FrameIndex <= a2)
    {
      if (FrameIndex != -1 && FrameIndex >= a2)
      {
LABEL_11:
        IIOFrameBufferRetain(HeadBuffer);
        os_unfair_lock_unlock(v4);
        return HeadBuffer;
      }
    }
    else
    {
      if (a2) {
        LogWarning("getAndRetainBufferAtIndex", 155, "ImageIO IIOFrameBufferQueue: requesting an out-of-sequence frame\n");
      }
      IIOFrameBufferQueue::stop((IIOFrameBufferQueue *)this);
      IIOFrameBufferQueue::startEnqueueingBuffers((IIOFrameBufferQueue *)this, a2);
    }
    do
    {
      do
      {
        unsigned __int8 v7 = (const void *)gFunc_CMBufferQueueDequeueAndRetain(*(void *)&this[4]._os_unfair_lock_opaque);
        IIOFrameBufferRelease(v7);
        HeadBuffer = (const void *)IIOFrameBufferQueue::_getHeadBuffer((IIOFrameBufferQueue *)this);
        uint64_t v8 = IIOFrameBufferGetFrameIndex((uint64_t)HeadBuffer);
      }
      while (v8 == -1);
    }
    while (v8 < a2);
    goto LABEL_11;
  }
  return 0;
}

uint64_t IIOFrameBufferQueue::_getHeadBuffer(IIOFrameBufferQueue *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 48);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 48));
  while (gFunc_CMBufferQueueIsEmpty(*((void *)this + 2)))
  {
    if (gFunc_CMBufferQueueIsAtEndOfData(*((void *)this + 2))) {
      break;
    }
    if ((gIIODebugFlags & 0x1000000000000) != 0) {
      ImageIOLog("    Starting to wait on _isEmptyCond\n");
    }
    pthread_cond_wait((pthread_cond_t *)((char *)this + 112), v2);
  }
  pthread_mutex_unlock(v2);
  unsigned __int8 v3 = (uint64_t (*)(uint64_t))gFunc_CMBufferQueueGetHead;
  uint64_t v4 = *((void *)this + 2);

  return v3(v4);
}

const char *___ZN19IIOFrameBufferQueue15_enqueueBuffersEPK9__CFArray_block_invoke(const char *result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v4 = *((void *)result + 4);
  unsigned __int8 v5 = atomic_load((unsigned __int8 *)(v4 + 40));
  if ((v5 & 1) == 0)
  {
    CFDictionaryRef result = (const char *)gFunc_CMBufferQueueEnqueue(*(void *)(v4 + 16));
    if (result)
    {
      if ((gIIODebugFlags & 0x1000000000000) != 0) {
        CFDictionaryRef result = ImageIOLog("*** CMBufferQueueEnqueue() failed (status == %d)\n", result);
      }
      *a4 = 1;
    }
  }
  return result;
}

const char *IIOFrameBufferQueue::_getBufferDuration@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  IIOFrameBufferGetDelayTime(a1);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 1jp2_colour_converter::clear(this + 6) = 0;
  *(void *)a2 = 0;
  CFDictionaryRef result = (const char *)gFunc_CMTimeMakeWithSeconds(1000);
  if ((gIIODebugFlags & 0x1000000000000) != 0)
  {
    if (*(_DWORD *)(a2 + 12)) {
      return ImageIOLog("    DelayTime: %g\n");
    }
    else {
      return ImageIOLog("*** Failed to create CMTime (%g) for buffer\n");
    }
  }
  return result;
}

uint64_t IIOFrameBufferQueue::_triggerFired(uint64_t this, opaqueCMBufferQueueTriggerToken *a2)
{
  uint64_t v2 = this;
  if (*(opaqueCMBufferQueueTriggerToken **)(this + 408) == a2)
  {
    char v3 = 1;
    if ((gIIODebugFlags & 0x1000000000000) != 0)
    {
      uint64_t v4 = "    Trigger fired: _bufferQueueHitLowWaterMarkToken. Count = %ld\n";
LABEL_8:
      BufferCFIndex Count = gFunc_CMBufferQueueGetBufferCount(*(void *)(this + 16));
      ImageIOLog(v4, BufferCount);
    }
  }
  else
  {
    if (*(opaqueCMBufferQueueTriggerToken **)(this + 416) != a2) {
      return this;
    }
    char v3 = 0;
    if ((gIIODebugFlags & 0x1000000000000) != 0)
    {
      uint64_t v4 = "    Trigger fired: _bufferQueueClearedLowWaterMarkToken. Count = %ld\n";
      goto LABEL_8;
    }
  }
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 160));
  *(unsigned char *)(v2 + 224) = v3;
  pthread_cond_broadcast((pthread_cond_t *)(v2 + 232));

  return pthread_mutex_unlock((pthread_mutex_t *)(v2 + 160));
}

void PNGReadPlugin::PNGReadPlugin(uint64_t a1, uint64_t a2)
{
}

uint64_t PNGReadPlugin::loadDataFromXPCObject(PNGReadPlugin *this, void *a2)
{
  uint64_t result = IIOReadPlugin::loadDataFromXPCObject(this, a2);
  if (!result)
  {
    return PNGReadPlugin::LoadDataFromXPCObject(a2, (PNGReadPlugin *)((char *)this + 440));
  }
  return result;
}

uint64_t PNGReadPlugin::LoadDataFromXPCObject(void *a1, _OWORD *a2)
{
  size_t length = 0;
  data = (long long *)xpc_dictionary_get_data(a1, "iio_xpc_plugin_data_png", &length);
  if (length != 80) {
    return 4294967246;
  }
  long long v5 = data[1];
  long long v6 = data[2];
  long long v7 = data[4];
  a2[3] = data[3];
  a2[4] = v7;
  long long v8 = *data;
  a2[1] = v5;
  a2[2] = v6;
  *a2 = v8;
  *((void *)a2 + 8) = 0;
  *((void *)a2 + jp2_colour_converter::clear(this + 6) = 0;
  size_t size = 0;
  uint64_t v9 = (unsigned int *)xpc_dictionary_get_data(a1, "iio_xpc_plugin_data_png_idot", &size);
  if (v9)
  {
    unsigned int v10 = v9;
    if (size >= 4 && size == 12 * *v9 + 4)
    {
      CFNumberRef v11 = malloc_type_malloc(size, 0xB8E1E74CuLL);
      *((void *)a2 + jp2_colour_converter::clear(this + 6) = v11;
      memcpy(v11, v10, size);
    }
  }
  return 0;
}

uint64_t PNGReadPlugin::saveDataToXPCObject(PNGReadPlugin *this, void *a2)
{
  uint64_t v4 = IIOReadPlugin::saveDataToXPCObject(this, a2);
  if (!v4) {
    PNGReadPlugin::SaveDataToXPCObject(a2, (char *)this + 440);
  }
  return v4;
}

uint64_t PNGReadPlugin::SaveDataToXPCObject(void *a1, void *buffer)
{
  iio_xpc_dictionary_add_databuffer(a1, "iio_xpc_plugin_data_png", buffer, 0x50uLL);
  uint64_t v4 = (_DWORD *)*((void *)buffer + 6);
  if (v4) {
    iio_xpc_dictionary_add_databuffer(a1, "iio_xpc_plugin_data_png_idot", v4, (12 * *v4 + 4));
  }
  return 0;
}

uint64_t PNGReadPlugin::Read_user_chunkapPD(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a3 + 16);
  if (v3 >= 0xD)
  {
    uint64_t v4 = *(void *)(a3 + 8);
    if (*(_DWORD *)(v4 + 4) == 1953057648)
    {
      CFIndex v5 = bswap32(*(_DWORD *)(v4 + 8));
      if (v5 + 12 <= v3) {
        *(void *)(a1 + 64) = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (const UInt8 *)(v4 + 12), v5);
      }
      else {
        _cg_jpeg_mem_term("Read_user_chunkapPD", 770, "bad chunk-size in pKit data\n");
      }
    }
  }
  return 1;
}

void *PNGReadPlugin::HexString2bin(PNGReadPlugin *this, size_t size)
{
  uint64_t v4 = malloc_type_malloc(size, 0x55ED00FEuLL);
  CFIndex v5 = v4;
  if (v4)
  {
    size_t v6 = 0;
    if (size)
    {
      long long v7 = v4;
      do
      {
        if (!*(unsigned char *)this) {
          break;
        }
        __endptr = 0;
        char v12 = 0;
        *(_WORD *)__str = 0;
        int v8 = *(unsigned __int8 *)this;
        if (v8 != 10)
        {
          char v9 = *((unsigned char *)this + 1);
          this = (PNGReadPlugin *)((char *)this + 1);
          __str[0] = v8;
          __str[1] = v9;
          char v12 = 0;
          *v7++ = strtol(__str, &__endptr, 16);
          if (__endptr != &v12) {
            break;
          }
          ++v6;
        }
        this = (PNGReadPlugin *)((char *)this + 1);
      }
      while (v6 < size);
    }
    if (v6 != size)
    {
      free(v5);
      return 0;
    }
  }
  return v5;
}

uint64_t ___ZN13PNGReadPlugin24AddOrientationToMetadataEP13IIODictionaryS1_P15CGImageMetadataP14png_struct_defP12png_info_def_block_invoke(uint64_t result, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  if (*(_WORD *)(a2 + 8) == 274)
  {
    uint64_t v4 = *(void *)(*(void *)(result + 32) + 8);
    if (!*(_DWORD *)(v4 + 24))
    {
      *(_DWORD *)(v4 + 24) = *(_DWORD *)(a2 + 16);
      *a4 = 1;
    }
  }
  return result;
}

void handle_error(uint64_t a1, const char *a2)
{
  if (a2)
  {
    if (*a2) {
      LogError("handle_error", 268, "%s\n", a2);
    }
  }
  exception = __cxa_allocate_exception(4uLL);
  _DWORD *exception = -1;
  __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
}

uint64_t imagePNG_error_break(uint64_t a1)
{
  LogError("imagePNG_error_break", 384, "*** ERROR: imagePNG_error_break\n");
  *gCrashMessage = 0;
  if (a1) {
    uint64_t result = snprintf(gCrashMessage, 0x200uLL, "*** ERROR: PNG decode  %dx%d  bpc: %d  cs: %d\n", *(_DWORD *)(a1 + 280), *(_DWORD *)(a1 + 284), *(unsigned __int8 *)(a1 + 392), *(unsigned __int8 *)(a1 + 391));
  }
  else {
    uint64_t result = snprintf(gCrashMessage, 0x200uLL, "*** ERROR: PNG decode failed ('png' is NULL)\n");
  }
  qword_1EB2BF498 = gCrashMessage;
  return result;
}

unsigned __int8 *PNGReadPlugin::Compose(unsigned __int8 *__src, char *__dst, unsigned int a3, uint64_t a4, int a5)
{
  CFIndex v5 = __src;
  if (*(unsigned char *)(a4 + 126))
  {
    int v6 = *(unsigned __int8 *)(a4 + 222);
    if (a5)
    {
      if (a3)
      {
        long long v7 = __dst + 1;
        do
        {
          int v8 = v5[1];
          if (v5[1])
          {
            if (v8 == 255)
            {
              *(_WORD *)(v7 - 1) = *(_WORD *)v5;
            }
            else if (v6 == 1)
            {
              *long long v7 = v8 + (unsigned __int16)((v8 ^ 0xFF) * *v7 + 127) / 0xFFu;
              *(v7 - 1) = *v5 + (unsigned __int16)((v8 ^ 0xFF) * *(v7 - 1) + 127) / 0xFFu;
            }
            else
            {
              int v9 = 255 * v8;
              int v10 = (v8 ^ 0xFF) * *v7;
              *(v7 - 1) = (v9 * *v5 + v10 * *(v7 - 1)) / (v10 + v9);
              *long long v7 = (16843010 * (unint64_t)(v10 + v9)) >> 32;
            }
          }
          v5 += 2;
          v7 += 2;
          --a3;
        }
        while (a3);
      }
    }
    else if (v6 == 1)
    {
      dest.data = __src;
      dest.vImagePixelCount height = 1;
      dest.CGFloat width = a3;
      dest.size_t rowBytes = 4 * a3;
      v19.data = __dst;
      v19.vImagePixelCount height = 1;
      v19.CGFloat width = a3;
      v19.size_t rowBytes = dest.rowBytes;
      vImagePremultiplyData_RGBA8888(&dest, &dest, 0x10u);
      return (unsigned __int8 *)vImagePremultipliedAlphaBlend_BGRA8888(&dest, &v19, &v19, 0x10u);
    }
    else if (a3)
    {
      uint64_t v14 = __src + 1;
      uint64_t v15 = __dst + 1;
      do
      {
        int v16 = v14[2];
        if (v14[2])
        {
          if (v16 == 255)
          {
            *(_DWORD *)(v15 - 1) = *(_DWORD *)(v14 - 1);
          }
          else
          {
            int v17 = 255 * v16;
            int v18 = (v16 ^ 0xFF) * v15[2];
            *(v15 - 1) = (v17 * *(v14 - 1) + v18 * *(v15 - 1)) / (v18 + v17);
            *uint64_t v15 = (v17 * *v14 + v18 * *v15) / (v18 + v17);
            v15[1] = (v17 * v14[1] + v18 * v15[1]) / (v18 + v17);
            v15[2] = (16843010 * (unint64_t)(v18 + v17)) >> 32;
          }
        }
        v14 += 4;
        v15 += 4;
        --a3;
      }
      while (a3);
    }
  }
  else
  {
    unsigned int v11 = 3 * a3;
    if (a5) {
      unsigned int v11 = a3;
    }
    unsigned int v12 = (*(unsigned __int16 *)(a4 + 122) >> 3) * a3;
    if (v11 >= v12) {
      size_t v13 = v12;
    }
    else {
      size_t v13 = v11;
    }
    return (unsigned __int8 *)memcpy(__dst, __src, v13);
  }
  return __src;
}

const void *PNGReadPlugin::copyImageBlockSetAPNG(uint64_t a1, const void *a2, const void *a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  v76[0] = 0;
  memset(__n, 0, sizeof(__n));
  CGImageProviderSetProperty();
  IIOReadPlugin::debugCopyBlockSet((const char *)a1, a3, a4, a5, a6, a7, a8, a9);
  if (*(_DWORD *)(a1 + 104) != 1) {
    goto LABEL_81;
  }
  uint64_t v18 = *(unsigned int *)(a1 + 112);
  IIOReadPlugin::allocateBlockArray((IIOReadPlugin *)a1, 1uLL);
  *(void *)(a1 + 112) = 0x100000000;
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("     numberOfBlocksLeftToDecode: %d\n", 1);
  }
  vImage_Buffer v19 = (IIOImageReadSession *)IIOImageSource::count((IIOImageSource *)a1);
  BOOL v20 = IIOImageReadSession::globalInfoForType(v19, 1095781959);
  if (!v20)
  {
LABEL_81:
    BOOL v23 = 0;
    goto LABEL_82;
  }
  uint64_t v21 = (uint64_t)v20;
  uint64_t v22 = *(IIOImageRead ***)(a1 + 24);
  if (v22) {
    BOOL v23 = IIOImageReadSession::mapData(v22);
  }
  else {
    BOOL v23 = 0;
  }
  if (*(unsigned char *)(a1 + 466))
  {
    int v24 = *(_DWORD *)(a1 + 292);
    if (*(_DWORD *)(a1 + 300) < (4 * v24)) {
      *(_DWORD *)(a1 + 300) = ImageIOAlignRowBytes((4 * v24), *(void *)(a1 + 392));
    }
  }
  if (!GlobalPNGInfo::currentBuffer((GlobalPNGInfo *)v21, 0))
  {
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("                  currentBuffer: creating new %d x %d [%d]\n", *(_DWORD *)(a1 + 296), *(_DWORD *)(a1 + 292), *(_DWORD *)(a1 + 300));
    }
    size_t v26 = *(unsigned int *)(a1 + 296);
    size_t v27 = *(unsigned int *)(a1 + 300);
    unint64_t v28 = v26 * (unint64_t)v27;
    __n[0] = v26 * v27;
    if ((v28 & 0xFFFFFFFF00000000) == 0)
    {
      char v29 = (unsigned __int8 *)malloc_type_calloc(v26, v27, 0x431A0903uLL);
      if (v29)
      {
        GlobalPNGInfo::setCurrentBuffer((GlobalPNGInfo *)v21, v29, v28, 1);
        GlobalPNGInfo::setCurrentBufferRowBytes((GlobalPNGInfo *)v21, *(_DWORD *)(a1 + 300));
        GlobalPNGInfo::setCurrentBufferIndex((GlobalPNGInfo *)v21, -1);
        goto LABEL_17;
      }
    }
LABEL_82:
    unsigned int v66 = 0;
    goto LABEL_72;
  }
LABEL_17:
  uint64_t v69 = a2;
  BOOL v70 = v23;
  uint64_t v30 = *(unsigned int *)(a1 + 112);
  if (v30 < *(_DWORD *)(a1 + 116))
  {
    uint64_t v31 = a1 + 184;
    uint64_t v32 = (unsigned char *)(a1 + 440);
    uint64_t v71 = v21;
    uint64_t v72 = v18;
    while (1)
    {
      uint64_t v33 = v30 - v18;
      if (*(void *)(*(void *)(a1 + 96) + 8 * (v30 - v18))) {
        _cg_jpeg_mem_term("copyImageBlockSetAPNG", 2680, "*** _blockArray[%d] was cached - and already allocated\n", v30 - v18);
      }
      uint64_t v34 = *(unsigned int *)(a1 + 296);
      double v35 = (double)(unint64_t)(v30 * v34);
      *(void *)&__n[1] = 0;
      LODWORD(v25) = *(_DWORD *)(a1 + 292);
      double v36 = (double)v25;
      *(double *)&__n[3] = v35;
      *(double *)&__n[5] = v36;
      *(double *)&__n[7] = (double)v34;
      LODWORD(v3jp2_colour_converter::clear(this + 6) = *(_DWORD *)(a1 + 232);
      double v37 = (double)*(unint64_t *)&v36;
      if ((double)v34 + v35 > v37) {
        *(double *)&__n[7] = v37 - v35;
      }
      memory_object_size_t v38 = *(unsigned int *)(a1 + 300) * (unint64_t)v34;
      int64_t v39 = _ImageIO_Malloc(v38, *(void *)(a1 + 384), v76, (uint64_t)kImageMalloc_PNG_Data[0], *(_DWORD *)(a1 + 432), 0, 0);
      if (!v39)
      {
        unsigned int v66 = 0;
        BOOL v23 = v70;
        goto LABEL_72;
      }
      unsigned int v40 = (char *)v39;
      uint64_t v41 = *(void *)(a1 + 384);
      if (v41 && v39 % v41) {
        goto LABEL_69;
      }
      bzero((void *)v39, v38);
      unint64_t v42 = PNGReadPlugin::DecodeComposedImage(*(IIO_Reader **)(a1 + 24), v21, v31, v32, (uint64_t)&__n[1], v40, *(unsigned int *)(a1 + 300), *(_DWORD *)(a1 + 432));
      double v43 = *(double *)&__n[7];
      if (v42) {
        break;
      }
LABEL_56:
      if (v43 != 0.0)
      {
        *(unsigned char *)(a1 + 34++*((_DWORD *)this + 3) = 0;
        PNGReadPlugin::postProcess((PNGReadPlugin *)a1, (unsigned __int8 *)v40);
        *(void *)(*(void *)(a1 + 96) + 8 * v3++*((_DWORD *)this + 3) = IIOReadPlugin::createImageBlock((IIOReadPlugin *)a1, v40, v76[0], *(CGRect *)&__n[1], *(unsigned int *)(a1 + 300), *(unsigned __int8 *)(a1 + 343));
        CGFloat v57 = *(double *)&__n[3];
        CGFloat v56 = *(double *)&__n[1];
        CGFloat v59 = *(double *)&__n[7];
        CGFloat v58 = *(double *)&__n[5];
        if (!CGRectEqualToRect(*(CGRect *)(a1 + 120), *MEMORY[0x1E4F1DB20]))
        {
          v77.origin.CGFloat x = v56;
          v77.origin.CGFloat y = v57;
          v77.size.CGFloat width = v58;
          v77.size.vImagePixelCount height = v59;
          *(CGRect *)(&v25 - 1) = CGRectUnion(*(CGRect *)(a1 + 120), v77);
          CGFloat v56 = v60;
          CGFloat v57 = *(double *)&v25;
          CGFloat v58 = v61;
          CGFloat v59 = v62;
        }
        unsigned int v40 = 0;
        *(CGFloat *)(a1 + 120) = v56;
        *(CGFloat *)(a1 + 128) = v57;
        *(CGFloat *)(a1 + 13jp2_colour_converter::clear(this + 6) = v58;
        *(CGFloat *)(a1 + 144) = v59;
      }
      if (++v30 >= (unint64_t)*(unsigned int *)(a1 + 116)) {
        goto LABEL_63;
      }
    }
    double v44 = (double)v42;
    if (*(double *)&__n[7] != (double)v42)
    {
      if (*(double *)&__n[7] > (double)v42)
      {
        *(double *)&__n[7] = (double)v42;
        if ((gIIODebugFlags & 0x30000) != 0)
        {
          ImageIOLog(": error while decoding PNG image rect: (%5g, %5g, %5g, %5g)\n", *(double *)&__n[1], *(double *)&__n[3], *(double *)&__n[5], (double)v42);
          ImageIOLog("          blockLoop = %ld\n", v30);
          ImageIOLog("        _blockEnd-1 = %ld\n", *(unsigned int *)(a1 + 116) - 1);
        }
        double v43 = v44;
      }
      goto LABEL_56;
    }
    if (*(_DWORD *)(a1 + 208) >= *(_DWORD *)(v21 + 40)) {
      goto LABEL_69;
    }
    uint64_t v74 = v30 - v18;
    long long __dst = (char *)GlobalPNGInfo::currentBuffer((GlobalPNGInfo *)v21, __n);
    GlobalPNGInfo::setCurrentBufferIndex((GlobalPNGInfo *)v21, *(_DWORD *)(a1 + 208));
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("                  currentBuffer: setting index to %d\n", *(_DWORD *)(a1 + 208));
    }
    if ((uint64_t v45 = *(void *)(v21 + 8) + 34 * *(unsigned int *)(a1 + 208), v46 = *(_DWORD *)(v45 + 12), v46 < 0)
      || (int v47 = *(_DWORD *)(v45 + 16), v47 < 0)
      || (v49 = *(_DWORD *)(v45 + 4), v48 = *(_DWORD *)(v45 + 8), int v50 = *(unsigned __int8 *)(v45 + 24), v49 < 0)
      && v48 < 0
      || v46 + v49 > *(_DWORD *)(a1 + 292)
      || v47 + v48 > *(_DWORD *)(a1 + 296)
      || (size_t v51 = __n[0], v38 > __n[0]))
    {
LABEL_69:
      unsigned int v66 = 0;
      BOOL v23 = v70;
      goto LABEL_71;
    }
    uint64_t v52 = gIIODebugFlags & 0x30000;
    if (v50 == 2)
    {
      if (v52) {
        ImageIOLog("                  currentBuffer: *** currentBuffer not changed [PNG_DISPOSE_OP_PREVIOUS]\n");
      }
    }
    else
    {
      if (v52)
      {
        ImageIOLog("                  currentBuffer: *** imageData to currentBuffer -> memcpy\n");
        size_t v51 = __n[0];
      }
      memcpy(__dst, v40, v51);
      if (v50 == 1)
      {
        if ((gIIODebugFlags & 0x30000) != 0) {
          ImageIOLog("                  currentBuffer: dispose background - clearing rect\n");
        }
        uint64_t v31 = a1 + 184;
        if (v48)
        {
          int v53 = *(unsigned __int16 *)(a1 + 306) >> 3;
          size_t v54 = (v49 * v53);
          BOOL v55 = &__dst[*(_DWORD *)(a1 + 300) * v47 + v46 * v53];
          do
          {
            bzero(v55, v54);
            v55 += *(unsigned int *)(a1 + 300);
            --v48;
          }
          while (v48);
        }
        uint64_t v21 = v71;
        uint64_t v18 = v72;
        goto LABEL_55;
      }
    }
    uint64_t v21 = v71;
    uint64_t v18 = v72;
    uint64_t v31 = a1 + 184;
LABEL_55:
    uint64_t v32 = (unsigned char *)(a1 + 440);
    uint64_t v33 = v74;
    goto LABEL_56;
  }
  unsigned int v40 = 0;
LABEL_63:
  double v63 = *(double *)(a1 + 120);
  double v64 = *(double *)(a1 + 128);
  double v65 = *(double *)(a1 + 144);
  if (v65 != 0.0)
  {
    BOOL v23 = v70;
    if (a3)
    {
      unsigned int v66 = (const void *)IIOReadPlugin::imageBlockSetCreate(a1, (uint64_t)a3, *(unsigned int *)(a1 + 104), *(double *)(a1 + 136), v65, v63, v64, *(double *)(a1 + 136), *(double *)(a1 + 144), *(void *)(a1 + 96), v69);
      if (!v40) {
        goto LABEL_72;
      }
    }
    else
    {
      unsigned int v66 = 0;
      if (!v40) {
        goto LABEL_72;
      }
    }
LABEL_71:
    _ImageIO_Free((unint64_t)v40, v76[0]);
    goto LABEL_72;
  }
  _cg_jpeg_mem_term("copyImageBlockSetAPNG", 2799, ": pngCreateBlockSet - error while decoding PNG image rect: (%5g, %5g, %5g, %5g)\n", v63, v64, *(double *)(a1 + 136), v65);
  unsigned int v66 = 0;
  BOOL v23 = v70;
  if (v40) {
    goto LABEL_71;
  }
LABEL_72:
  if (a3) {
    IIOReadPlugin::freeBlockArray((IIOReadPlugin *)a1);
  }
  if (v23)
  {
    uint64_t v67 = *(const char ***)(a1 + 24);
    if (v67) {
      IIOImageReadSession::unmapData(v67);
    }
  }
  if (*(unsigned char *)(a1 + 181))
  {
    ImageIOLog("<<< copyImageBlockSetAPNG - PNG  [%p]\n", v66);
    ImageIOLog("===================================================================================================\n");
  }
  return v66;
}

unint64_t PNGReadPlugin::DecodeComposedImage(IIO_Reader *a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5, char *a6, unint64_t a7, task_t a8)
{
  unint64_t v8 = 0;
  memory_object_size_t v120 = 0;
  if (!a1) {
    return v8;
  }
  uint64_t v9 = a2;
  if (!a2 || !a6) {
    return v8;
  }
  double v13 = *(double *)(a5 + 24);
  int v105 = *(_DWORD *)(a3 + 140);
  int v14 = *(unsigned __int8 *)(a3 + 62);
  if ((gIIODebugFlags & 0x30000) != 0) {
    ImageIOLog("                   reading rows: %d ... %d\n", (unint64_t)*(double *)(a5 + 8), (unint64_t)(v13 + *(double *)(a5 + 8)));
  }
  unsigned int v91 = v14 - 5;
  unint64_t v99 = ((unint64_t)*(unsigned __int16 *)(a3 + 122) + 7) >> 3;
  uint64_t v96 = a5;
  unsigned int v104 = (GlobalPNGInfo *)v9;
  if (a4[20] != 7)
  {
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("    === decoding frame %d ===\n", *(_DWORD *)(a3 + 24));
    }
    unsigned int v16 = *(_DWORD *)(a3 + 24);
    if (v16 || !a4[31] || 0xF0F0F0F0F0F0F0F1 * ((uint64_t)(*(void *)(v9 + 16) - *(void *)(v9 + 8)) >> 1) <= 1)
    {
      int v17 = a4 + 59;
      if (!a4[59])
      {
        if (!v16)
        {
          unsigned int v18 = 0;
          goto LABEL_71;
        }
LABEL_58:
        unsigned int v18 = v16;
        double v37 = (unsigned __int8 *)(*(void *)(v9 + 8) + 34 * v16 + 24);
        do
        {
          if (*((_DWORD *)v37 - 5) == *(_DWORD *)(v9 + 32))
          {
            BOOL v38 = *((_DWORD *)v37 - 4) == *(_DWORD *)(v9 + 36) && v37[1] == 0;
            if (v38 && *v37 < 2u) {
              break;
            }
          }
          v37 -= 34;
          --v18;
        }
        while (v18);
LABEL_71:
        v110[0] = 0;
        unsigned int v40 = (const void *)GlobalPNGInfo::currentBuffer((GlobalPNGInfo *)v9, v110);
        uint64_t v41 = v40;
        if (v16 && v40)
        {
          if ((gIIODebugFlags & 0x30000) != 0) {
            ImageIOLog("                      currentBuffer: %p ", v40);
          }
          unsigned int v42 = GlobalPNGInfo::currentBufferIndex((GlobalPNGInfo *)v9);
          uint64_t v43 = gIIODebugFlags & 0x30000;
          if (v42 == v16 - 1)
          {
            unsigned int v44 = v42;
            size_t v45 = (unint64_t)(v13 * (double)a7);
            if (v43)
            {
              int v46 = GlobalPNGInfo::currentBufferIndex(v104);
              ImageIOLog("                      currentBuffer: bufferIndex=%d  currentIndex-1=%d\n", v46, v44);
            }
            if (v110[0] == v45)
            {
              memcpy(a6, v41, v45);
              if ((gIIODebugFlags & 0x30000) != 0)
              {
                ImageIOLog("                      currentBuffer: sizes match: %ld\n", v45);
                if ((gIIODebugFlags & 0x30000) != 0) {
                  ImageIOLog("                      currentBuffer: *** using currentBuffer -> memcpy\n");
                }
              }
              uint64_t v47 = *((void *)v104 + 1) + 34 * v44;
              int v48 = *(_DWORD *)(v47 + 8);
              BOOL v49 = *(unsigned char *)(v47 + 24) != 1 || v48 == 0;
              unsigned int v18 = v16;
              if (!v49)
              {
                int v50 = *(unsigned __int16 *)(a3 + 122) >> 3;
                size_t v51 = (*(_DWORD *)(v47 + 4) * v50);
                uint64_t v52 = &a6[*(_DWORD *)(a3 + 116) * *(_DWORD *)(v47 + 16) + *(_DWORD *)(v47 + 12) * v50];
                do
                {
                  bzero(v52, v51);
                  v52 += *(unsigned int *)(a3 + 116);
                  --v48;
                }
                while (v48);
LABEL_19:
                unsigned int v18 = v16;
              }
            }
            else if ((gIIODebugFlags & 0x30000) != 0)
            {
              ImageIOLog("                  currentBuffer: sizes don't match: buffer=%d  expected = %d\n");
            }
          }
          else if (v43)
          {
            GlobalPNGInfo::currentBufferIndex((GlobalPNGInfo *)v9);
            ImageIOLog("                  currentBuffer: bufferIndex=%d  currentIndex-1=%d -- can't use index\n");
          }
        }
        else
        {
          uint64_t v53 = gIIODebugFlags & 0x30000;
          if (v40)
          {
            if (v53) {
              ImageIOLog("                  currentBuffer: index is 0 - not using currentbufffer\n", v84, v85);
            }
          }
          else if (v53)
          {
            ImageIOLog("                  currentBuffer: buffer is nil / no framebuffer in place\n");
          }
        }
        if ((gIIODebugFlags & 0x30000) != 0)
        {
          size_t v54 = *v17 ? "YES" : "NO";
          ImageIOLog("            prpd._skipComposing: %s\n", v54);
          if ((gIIODebugFlags & 0x30000) != 0)
          {
            ImageIOLog("                     firstIndex: %d\n", v18);
            if ((gIIODebugFlags & 0x30000) != 0) {
              ImageIOLog("                   image frames: %d ... %d\n", v18, v16);
            }
          }
        }
        if (a4[37]) {
          uint64_t v55 = PNGReadPlugin::EnsureFrameBufferQueueExists(a1, (uint64_t)v104, (long long *)a3);
        }
        else {
          uint64_t v55 = 0;
        }
        if (v18 > v16) {
          return 0;
        }
        long long v86 = (IIOFrameBufferQueue *)v55;
        unint64_t v8 = 0;
        unint64_t v56 = v18;
        unint64_t v98 = v16;
        while (1)
        {
          uint64_t v57 = *((void *)v104 + 1) + 34 * v56;
          unint64_t v58 = *(unsigned int *)(v57 + 8);
          unsigned int v107 = *(_DWORD *)(v57 + 4);
          unint64_t v59 = *(unsigned int *)(v57 + 16);
          unsigned int cfa = *(_DWORD *)(v57 + 12);
          uint64_t v60 = *(unsigned __int8 *)(v57 + 24);
          uint64_t v61 = *(unsigned __int8 *)(v57 + 25);
          if ((gIIODebugFlags & 0x30000) != 0)
          {
            int v62 = *(unsigned __int16 *)(v57 + 20);
            int v63 = *(unsigned __int16 *)(v57 + 22);
            ImageIOLog("    #%d\n", v56);
            if ((gIIODebugFlags & 0x30000) != 0)
            {
              ImageIOLog("                           rect: {%d, %d, %d, %d}\n", cfa, v59, v107, v58);
              if ((gIIODebugFlags & 0x30000) != 0)
              {
                ImageIOLog("                          delay: %d / %d\n", v62, v63);
                if ((gIIODebugFlags & 0x30000) != 0)
                {
                  ImageIOLog("                   f_dispose_op: %d %s\n", v60, off_1E53C4520[v60]);
                  if ((gIIODebugFlags & 0x30000) != 0) {
                    ImageIOLog("                     f_blend_op: %d %s\n", v61, off_1E53C4538[v61]);
                  }
                }
              }
            }
          }
          unint64_t v64 = v98;
          if (v56 >= v98 || v60 != 2) {
            break;
          }
LABEL_164:
          BOOL v34 = v56++ == v64;
          if (v34) {
            return v8;
          }
        }
        if (v56 < v98 && v60 == 1)
        {
          if (v58)
          {
            int v65 = *(unsigned __int16 *)(a3 + 122) >> 3;
            size_t v66 = v107 * v65;
            uint64_t v67 = &a6[(*(_DWORD *)(a3 + 116) * v59) + cfa * v65];
            do
            {
              bzero(v67, v66);
              v67 += *(unsigned int *)(a3 + 116);
              --v58;
            }
            while (v58);
          }
          goto LABEL_164;
        }
        if (v107) {
          BOOL v68 = v58 == 0;
        }
        else {
          BOOL v68 = 1;
        }
        if (v68)
        {
          unint64_t v8 = v59;
          goto LABEL_164;
        }
        unint64_t v69 = v99 * (unint64_t)v107;
        unint64_t v70 = *(unsigned int *)(a3 + 116);
        if (v69 < v70) {
          unint64_t v70 = v99 * (unint64_t)v107;
        }
        size_t __na = v70;
        if (v86)
        {
          uint64_t v71 = IIOFrameBufferQueue::getAndRetainBufferAtIndex((os_unfair_lock_s *)v86, v56);
          if (v71)
          {
            CFTypeRef v87 = v71;
            Buffer = (unsigned __int8 *)IIOFrameBufferGetBuffer((uint64_t)v71);
            unint64_t v94 = 0;
LABEL_139:
            BOOL v76 = v61 == 0;
            if (v91 < 0xFFFFFFFC) {
              BOOL v76 = 1;
            }
            BOOL v95 = v76;
            if (v56) {
              BOOL v77 = v56 == v98;
            }
            else {
              BOOL v77 = 1;
            }
            if (v56) {
              BOOL v78 = v91 < 0xFFFFFFFC;
            }
            else {
              BOOL v78 = 1;
            }
            long long v79 = &a6[v99 * (unint64_t)cfa];
            if (v61) {
              int v80 = v78;
            }
            else {
              int v80 = 1;
            }
            while (1)
            {
              uint64_t v81 = *(unsigned int *)(a3 + 116);
              long long v82 = &v79[v59 * v81];
              if (v77) {
                break;
              }
              if (v60 == 1)
              {
                bzero(&v79[v59 * v81], __na);
                goto LABEL_158;
              }
              if (!v60)
              {
                if (!v95)
                {
LABEL_156:
                  PNGReadPlugin::Compose(Buffer, v82, v107, a3, v105 == 1196573017);
                  goto LABEL_158;
                }
                goto LABEL_152;
              }
LABEL_158:
              ++v59;
              Buffer += v69;
              if (!--v58)
              {
                if (v87) {
                  CFRelease(v87);
                }
                unint64_t v64 = v98;
                if (v94) {
                  _ImageIO_Free(v94, v120);
                }
                unint64_t v8 = (unint64_t)*(double *)(v96 + 24);
                goto LABEL_164;
              }
            }
            if (!v80) {
              goto LABEL_156;
            }
LABEL_152:
            memcpy(v82, Buffer, __na);
            goto LABEL_158;
          }
          _cg_jpeg_mem_term("DecodeComposedImage", 4042, "*** IIOFrameBufferQueue returned NULL for buffer at index: %ld\n");
        }
        else if (is_mul_ok(v58, v69))
        {
          int v73 = (unsigned __int8 *)_ImageIO_Malloc(v58 * v69, *(void *)(a3 + 200), &v120, (uint64_t)kImageMalloc_PNG_Data[0], a8, 0, 0);
          if (v73)
          {
            uint64_t v74 = v73;
            bzero(v73, v58 * v69);
            uint64_t v109 = 0;
            *(void *)uint64_t v110 = v56;
            double v111 = (double)cfa;
            double v112 = (double)v59;
            double v113 = (double)v107;
            double v114 = (double)v58;
            unint64_t v94 = (unint64_t)v74;
            uint64_t v115 = v74;
            unint64_t v116 = v99 * (unint64_t)v107;
            unint64_t v117 = v69 * v58;
            long long v118 = 0u;
            uint64_t v119 = 0;
            long long v108 = 0u;
            std::vector<IIODecodeFrameParams>::vector(&v108, 1uLL, (uint64_t)v110);
            unint64_t v75 = (IIOImageRead *)IIO_Reader::testHeaderSize(a1);
            PNGReadPlugin::DecodeUncomposedFrames(v75, (uint64_t)v104, a3, a4, (uint64_t **)&v108);
            Buffer = v115;
            v121[0] = (void **)&v108;
            std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](v121);
            IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)v110);
            CFTypeRef v87 = 0;
            goto LABEL_139;
          }
          _cg_jpeg_mem_term("DecodeComposedImage", 4055, "*** ImageIO_Malloc failed to alloc %ld bytes\n");
        }
        return v59;
      }
    }
    else
    {
      int v17 = a4 + 59;
      unsigned int v16 = 1;
      if (!a4[59]) {
        goto LABEL_58;
      }
    }
    if ((gIIODebugFlags & 0x30000) != 0) {
      ImageIOLog("                  currentBuffer: prpd._skipComposing=%d -> skipping currentbufffer\n", 1);
    }
    goto LABEL_19;
  }
  if (a4[37]) {
    uint64_t v15 = (os_unfair_lock_s *)PNGReadPlugin::EnsureFrameBufferQueueExists(a1, v9, (long long *)a3);
  }
  else {
    uint64_t v15 = 0;
  }
  unint64_t v19 = 0;
  unint64_t v8 = 0;
  uint64_t v93 = v15;
  while (1)
  {
    uint64_t v20 = *(void *)(v9 + 8) + 34 * v19;
    unsigned int v21 = *(_DWORD *)(v20 + 4);
    unint64_t v22 = *(unsigned int *)(v20 + 8);
    unsigned int v23 = *(_DWORD *)(v20 + 12);
    uint64_t v24 = *(unsigned int *)(v20 + 16);
    int v25 = *(unsigned __int8 *)(v20 + 24);
    int v97 = *(unsigned __int8 *)(v20 + 25);
    unsigned int v106 = v21;
    unint64_t v26 = v99 * (unint64_t)v21;
    size_t v27 = v26 >= *(unsigned int *)(a3 + 116) ? *(unsigned int *)(a3 + 116) : v99 * (unint64_t)v21;
    if (v15) {
      break;
    }
    if (!is_mul_ok(v22, v26)) {
      return v8;
    }
    uint64_t v30 = (unsigned __int8 *)_ImageIO_Malloc(v22 * v26, *(void *)(a3 + 200), &v120, (uint64_t)kImageMalloc_PNG_Data[0], a8, 0, 0);
    if (!v30)
    {
      _cg_jpeg_mem_term("DecodeComposedImage", 3768, "*** ImageIO_Malloc failed to alloc %ld bytes\n");
      return v8;
    }
    uint64_t v31 = v30;
    bzero(v30, v22 * v26);
    uint64_t v109 = 0;
    *(void *)uint64_t v110 = v19;
    double v111 = (double)v23;
    double v112 = (double)v24;
    double v113 = (double)v106;
    double v114 = (double)v22;
    size_t __n = (size_t)v31;
    uint64_t v115 = v31;
    unint64_t v116 = v26;
    unint64_t v117 = v26 * v22;
    long long v118 = 0u;
    uint64_t v119 = 0;
    long long v108 = 0u;
    std::vector<IIODecodeFrameParams>::vector(&v108, 1uLL, (uint64_t)v110);
    uint64_t v32 = (IIOImageRead *)IIO_Reader::testHeaderSize(a1);
    PNGReadPlugin::DecodeUncomposedFrames(v32, (uint64_t)v104, a3, a4, (uint64_t **)&v108);
    char v29 = v115;
    v121[0] = (void **)&v108;
    std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](v121);
    IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)v110);
    CFTypeRef cf = 0;
    if (v22)
    {
LABEL_32:
      uint64_t v33 = &a6[v99 * (unint64_t)v23];
      if (v19) {
        BOOL v34 = v97 == 0;
      }
      else {
        BOOL v34 = 1;
      }
      BOOL v35 = !v34 && v91 >= 0xFFFFFFFC;
      int v36 = !v35;
      while (v19 != *(_DWORD *)(a3 + 24))
      {
        if (v25 == 1)
        {
          bzero(&v33[v24 * *(unsigned int *)(a3 + 116)], v27);
          goto LABEL_49;
        }
        if (!v25)
        {
          if (!v36)
          {
LABEL_47:
            PNGReadPlugin::Compose(v29, &v33[v24 * *(unsigned int *)(a3 + 116)], v106, a3, v105 == 1196573017);
            goto LABEL_49;
          }
          goto LABEL_43;
        }
LABEL_49:
        ++v24;
        v29 += v26;
        if (!--v22) {
          goto LABEL_50;
        }
      }
      if (!v36) {
        goto LABEL_47;
      }
LABEL_43:
      memcpy(&v33[v24 * *(unsigned int *)(a3 + 116)], v29, v27);
      goto LABEL_49;
    }
LABEL_50:
    if (cf) {
      CFRelease(cf);
    }
    uint64_t v9 = (uint64_t)v104;
    if (__n) {
      _ImageIO_Free(__n, v120);
    }
    unint64_t v8 = (unint64_t)*(double *)(v96 + 24);
    BOOL v35 = v19++ >= *(unsigned int *)(a3 + 24);
    uint64_t v15 = v93;
    if (v35) {
      return v8;
    }
  }
  unint64_t v28 = IIOFrameBufferQueue::getAndRetainBufferAtIndex(v15, v19);
  if (v28)
  {
    CFTypeRef cf = v28;
    char v29 = (unsigned __int8 *)IIOFrameBufferGetBuffer((uint64_t)v28);
    size_t __n = 0;
    if (v22) {
      goto LABEL_32;
    }
    goto LABEL_50;
  }
  _cg_jpeg_mem_term("DecodeComposedImage", 3755, "*** IIOFrameBufferQueue returned NULL for buffer at index: %ld\n");
  return v8;
}

void sub_188710720(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void AddSubRect(CGRect *a1, CGRect a2)
{
  CGFloat height = a2.size.height;
  CGFloat width = a2.size.width;
  CGFloat y = a2.origin.y;
  CGFloat x = a2.origin.x;
  if (!CGRectEqualToRect(*a1, *MEMORY[0x1E4F1DB20]))
  {
    v8.origin.CGFloat x = x;
    v8.origin.CGFloat y = y;
    v8.size.CGFloat width = width;
    v8.size.CGFloat height = height;
    CGRect v7 = CGRectUnion(*a1, v8);
    CGFloat x = v7.origin.x;
    CGFloat y = v7.origin.y;
    CGFloat width = v7.size.width;
    CGFloat height = v7.size.height;
  }
  a1->origin.CGFloat x = x;
  a1->origin.CGFloat y = y;
  a1->size.CGFloat width = width;
  a1->size.CGFloat height = height;
}

uint64_t breakOnPngError(void)
{
  return _cg_jpeg_mem_term("breakOnPngError", 398, "breakOnPngError\n");
}

uint64_t PNGReadPlugin::EnsureFrameBufferQueueExists(IIO_Reader *a1, uint64_t a2, long long *a3)
{
  uint64_t v34 = 0;
  BOOL v35 = 0;
  uint64_t v4 = IIO_Reader::testHeaderSize(a1);
  std::string::basic_string[abi:ne180100]<0>(&__p, "PNGFrameBufferQueue");
  IIOImageRead::getClientValueForKey(v4, (const void **)&__p, &v34);
  if (SBYTE7(v19) < 0) {
    operator delete((void *)__p);
  }
  uint64_t v5 = v34;
  if (!v34)
  {
    long long v6 = a3[12];
    long long v7 = a3[14];
    long long v31 = a3[13];
    long long v32 = v7;
    long long v8 = a3[8];
    long long v9 = a3[10];
    long long v10 = a3[11];
    long long v27 = a3[9];
    long long v28 = v9;
    long long v29 = v10;
    long long v30 = v6;
    long long v11 = a3[4];
    long long v12 = a3[6];
    long long v13 = a3[7];
    long long v23 = a3[5];
    long long v24 = v12;
    long long v25 = v13;
    long long v26 = v8;
    long long v14 = *a3;
    long long v15 = a3[2];
    long long v16 = a3[3];
    long long v19 = a3[1];
    long long v20 = v15;
    uint64_t v33 = *((void *)a3 + 30);
    long long v21 = v16;
    long long v22 = v11;
    long long __p = v14;
    operator new();
  }
  if (v35) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v35);
  }
  return v5;
}

void sub_188710A7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, std::__shared_weak_count *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a11) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a11);
  }
  if (a17 < 0) {
    operator delete(__p);
  }
  long long v19 = *(std::__shared_weak_count **)(v17 - 88);
  if (v19) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v19);
  }
  _Unwind_Resume(a1);
}

__CFArray *___ZN13PNGReadPlugin28EnsureFrameBufferQueueExistsEP19IIOImageReadSessionP13GlobalPNGInfoRK14ReadPluginDataRK13PNGPluginDatalj_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v67 = 0;
  BOOL v68 = 0;
  unint64_t v69 = 0;
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CGMutableImageMetadataRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v59 = a2;
  for (i = 0; a2 < *(unsigned int *)(v8 + 40); uint64_t v8 = *(void *)(a1 + 32))
  {
    uint64_t v10 = *(unsigned __int16 *)(a1 + 162);
    memory_object_size_t v66 = 0;
    long long v11 = (_DWORD *)(*(void *)(v8 + 8) + 34 * a2);
    unint64_t v12 = v11[2];
    LODWORD(vjp2_colour_converter::clear(this + 6) = v11[3];
    LODWORD(v7) = v11[4];
    double v13 = (double)v6;
    double v14 = (double)v7;
    LODWORD(vjp2_colour_converter::clear(this + 6) = v11[1];
    double v15 = (double)v6;
    double v16 = (double)v12;
    v71.origin.CGFloat x = v13;
    v71.origin.CGFloat y = (double)v7;
    v71.size.CGFloat width = v15;
    v71.size.CGFloat height = (double)v12;
    if (CGRectIsEmpty(v71))
    {
      uint64_t v17 = 0;
      unint64_t v18 = 0;
    }
    else
    {
      unint64_t v18 = (unint64_t)((double)((unint64_t)(v10 + 7) >> 3) * v15);
      if (!is_mul_ok(v18, v12)) {
        goto LABEL_44;
      }
      size_t v19 = v18 * v12;
      long long v20 = (void *)_ImageIO_Malloc(v18 * v12, *(void *)(a1 + 240), &v66, (uint64_t)kImageMalloc_PNG_Data[0], *(_DWORD *)(a1 + 376), 0, 0);
      uint64_t v17 = v20;
      if (!v20) {
        goto LABEL_44;
      }
      bzero(v20, v19);
      i += v19;
    }
    length[0] = a2;
    *(double *)&length[1] = v13;
    *(double *)&long long v61 = v14;
    *((double *)&v61 + 1) = v15;
    *(double *)&long long v62 = v16;
    *((void *)&v62 + 1) = v17;
    *(void *)&long long v63 = v18;
    *((void *)&v63 + 1) = v66;
    *(void *)&long long v64 = 0;
    DWORD2(v64) = 0;
    uint64_t v65 = 0;
    long long v21 = v68;
    if (v68 >= v69)
    {
      long long v27 = v67;
      uint64_t v28 = 0x2E8BA2E8BA2E8BA3 * ((v68 - (char *)v67) >> 3);
      unint64_t v29 = v28 + 1;
      if ((unint64_t)(v28 + 1) > 0x2E8BA2E8BA2E8BALL) {
        std::vector<IIOTag *>::__throw_length_error[abi:ne180100]();
      }
      if (0x5D1745D1745D1746 * ((v69 - (char *)v67) >> 3) > v29) {
        unint64_t v29 = 0x5D1745D1745D1746 * ((v69 - (char *)v67) >> 3);
      }
      if ((unint64_t)(0x2E8BA2E8BA2E8BA3 * ((v69 - (char *)v67) >> 3)) >= 0x1745D1745D1745DLL) {
        unint64_t v30 = 0x2E8BA2E8BA2E8BALL;
      }
      else {
        unint64_t v30 = v29;
      }
      v70[4] = &v69;
      if (v30)
      {
        long long v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<IIODecodeFrameParams>>((uint64_t)&v69, v30);
        long long v27 = v67;
        long long v21 = v68;
      }
      else
      {
        long long v31 = 0;
      }
      long long v32 = &v31[88 * v28];
      long long v33 = v61;
      *(_OWORD *)long long v32 = *(_OWORD *)length;
      *((_OWORD *)v32 + 1) = v33;
      long long v34 = v62;
      long long v35 = v63;
      long long v36 = v64;
      *((void *)v32 + 10) = v65;
      *((_OWORD *)v32 + ++*((_DWORD *)this + 3) = v35;
      *((_OWORD *)v32 + 4) = v36;
      *((_OWORD *)v32 + 2) = v34;
      if (v21 == (char *)v27)
      {
        int64_t v39 = (uint64_t *)&v31[88 * v28];
      }
      else
      {
        double v37 = (uint64_t *)v21;
        BOOL v38 = &v31[88 * v28];
        do
        {
          int64_t v39 = (uint64_t *)(v38 - 88);
          long long v40 = *(_OWORD *)(v37 - 11);
          *(_OWORD *)(v38 - 72) = *(_OWORD *)(v37 - 9);
          *(_OWORD *)(v38 - 88) = v40;
          long long v41 = *(_OWORD *)(v37 - 7);
          long long v42 = *(_OWORD *)(v37 - 5);
          long long v43 = *(_OWORD *)(v37 - 3);
          *((void *)v38 - 1) = *(v37 - 1);
          *(_OWORD *)(v38 - 24) = v43;
          *(_OWORD *)(v38 - 40) = v42;
          *(_OWORD *)(v38 - 5jp2_colour_converter::clear(this + 6) = v41;
          v37 -= 11;
          v38 -= 88;
        }
        while (v37 != v27);
      }
      long long v26 = v32 + 88;
      uint64_t v67 = v39;
      BOOL v68 = v32 + 88;
      unsigned int v44 = v69;
      unint64_t v69 = &v31[88 * v30];
      v70[0] = v27;
      memory_object_size_t v70[2] = v21;
      v70[3] = v44;
      v70[1] = v27;
      std::__split_buffer<IIODecodeFrameParams>::~__split_buffer((uint64_t)v70);
    }
    else
    {
      long long v22 = v61;
      *(_OWORD *)BOOL v68 = *(_OWORD *)length;
      *((_OWORD *)v21 + 1) = v22;
      long long v23 = v62;
      long long v24 = v63;
      long long v25 = v64;
      *((void *)v21 + 10) = v65;
      *((_OWORD *)v21 + ++*((_DWORD *)this + 3) = v24;
      *((_OWORD *)v21 + 4) = v25;
      *((_OWORD *)v21 + 2) = v23;
      long long v26 = v21 + 88;
    }
    BOOL v68 = v26;
    IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)length);
    if ((i & 0xFFFFFFFFFFFF0000) != 0 && (unint64_t)(0x2E8BA2E8BA2E8BA3 * ((v68 - (char *)v67) >> 3)) > 2
      || i >> 20 != 0)
    {
      break;
    }
    ++a2;
  }
  if ((gIIODebugFlags & 0x1000000000000) != 0) {
    ImageIOLog("    Asking for frames at indexes: (%ld, %ld), %ld bytes\n", v59, 0x2E8BA2E8BA2E8BA3 * ((v68 - (char *)v67) >> 3), i);
  }
  uint64_t v47 = (IIOImageRead *)IIO_Reader::testHeaderSize(*(IIO_Reader **)(a1 + 288));
  PNGReadPlugin::DecodeUncomposedFrames(v47, *(void *)(a1 + 32), a1 + 40, (unsigned char *)(a1 + 296), &v67);
  int v50 = v67;
  size_t v51 = (uint64_t *)v68;
  if (v67 != (uint64_t *)v68)
  {
    do
    {
      uint64_t v52 = *(void *)(*(void *)(a1 + 32) + 8) + 34 * *v50;
      LOWORD(v48) = *(_WORD *)(v52 + 20);
      LOWORD(v49) = *(_WORD *)(v52 + 22);
      double v53 = (double)v48 / (double)v49;
      if (v53 == 0.0) {
        double v53 = 0.0333333333;
      }
      size_t v54 = (void *)IIOFrameBufferCreateForBuffer(v50[5], v50[7], v50[6] * *(unsigned int *)(v52 + 8), *v50, v53);
      IIOGIFFrameSetNumRowsDecoded((uint64_t)v54, v50[8]);
      uint64_t v55 = (IIOColorMap *)v50[10];
      if (v55)
      {
        length[0] = 0;
        SerializedData = IIOColorMap::createSerializedData(v55, (unint64_t *)length);
        if (SerializedData)
        {
          CFDataRef v57 = CFDataCreate(v4, (const UInt8 *)SerializedData, length[0]);
          if (v57)
          {
            IIOFrameBufferSetColorTable(v54, v57);
            CFRelease(v57);
          }
          free(SerializedData);
        }
      }
      CFArrayAppendValue(Mutable, v54);
      IIOFrameBufferRelease(v54);
      v50 += 11;
    }
    while (v50 != v51);
  }
LABEL_44:
  length[0] = (CFIndex)&v67;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100]((void ***)length);
  return Mutable;
}

void sub_188710FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  a14 = (void **)&a26;
  std::vector<IIODecodeFrameParams>::__destroy_vector::operator()[abi:ne180100](&a14);
  _Unwind_Resume(a1);
}

void handle_error_idot(uint64_t a1, unsigned char *a2)
{
  if (a2)
  {
    if (*a2) {
      _cg_jpeg_mem_term("handle_error_idot", 278, "PNG-iDOT", "%s\n", a2);
    }
  }
  exception = __cxa_allocate_exception(4uLL);
  _DWORD *exception = -1;
  __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
}

void PNGReadPlugin::DecodeFrameAPNG(IIOImageReadSession *a1, uint64_t a2, uint64_t a3, unsigned char *a4, uint64_t a5)
{
  uint64_t v10 = _cg_png_create_read_struct("1.6.43", 0, (uint64_t)handle_error, (uint64_t)handle_warning);
  unint64_t v30 = v10;
  _cg_png_create_info_struct((uint64_t)v10);
  unint64_t v12 = v11;
  unint64_t v29 = v11;
  if (v10 && v11)
  {
    _cg_png_set_option((uint64_t)v10, 2u, 3);
    _cg_png_set_benign_errors((uint64_t)v10, 1);
    _cg_png_set_read_fn(v10, (uint64_t)a1, (size_t (*)(size_t, void *, size_t))read_fn);
    _cg_png_set_keep_unknown_chunks_sized((uint64_t)v10, 3u, "CgBI", 4);
    a4[56] = 0;
    _cg_png_set_read_user_chunk_fn((uint64_t)v10, (uint64_t)a4, (uint64_t)PNGReadPlugin::Read_user_chunk_callback);
    _cg_png_read_info((uLong)v10, v12);
    if (*(unsigned char *)(a3 + 63) == 1) {
      _cg_png_set_swap((uint64_t)v10);
    }
    int v13 = _cg_png_set_interlace_handling((uint64_t)v10);
    PNGReadPlugin::Update_png_struct(a3, a4, (uint64_t)v10, v12);
    uint64_t v14 = *(void *)(a2 + 8) + 34 * *(void *)a5;
    unsigned int v16 = *(_DWORD *)(v14 + 4);
    unsigned int v15 = *(_DWORD *)(v14 + 8);
    if (*(uint64_t *)a5 < 1)
    {
      if (a4[31] && *(_DWORD *)(a3 + 48))
      {
        unsigned int v24 = 0;
        do
        {
          _cg_png_read_row_sized((uLong)v10, 0, 0, 0);
          ++v24;
        }
        while (v24 < *(_DWORD *)(a3 + 48));
      }
    }
    else
    {
      int v17 = *(_DWORD *)v14;
      IIOImageReadSession::seek(a1, *(void *)(v14 + 26), 0);
      _cg_png_set_num_frames_read((uint64_t)v10, (uint64_t)v12, *(_DWORD *)a5);
      _cg_png_set_next_seq_num((uint64_t)v10, (uint64_t)v12, v17);
      _cg_png_set_zstream_owner((uint64_t)v10, 0);
      zstreaint m = _cg_png_get_zstream((uint64_t)v10);
      *(void *)zstreaint m = 0;
      *(_DWORD *)(zstream + 8) = 0;
    }
    _cg_png_read_frame_head((uint64_t)v10, v12);
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    int v26 = 0;
    __int16 v25 = 0;
    _cg_png_get_next_frame_fcTL((uint64_t)v10, (uint64_t)v12, (_DWORD *)&v28 + 1, &v28, (_DWORD *)&v27 + 1, &v27, (_WORD *)&v26 + 1, &v26, (unsigned char *)&v25 + 1, &v25);
    if (v28 == __PAIR64__(v16, v15))
    {
      if (v13)
      {
        int v19 = 0;
        uint64_t v20 = *(void *)(a5 + 48);
        unsigned int v21 = v15;
        do
        {
          if (v21)
          {
            unsigned int v22 = 0;
            long long v23 = *(char **)(a5 + 40);
            do
            {
              _cg_png_read_row_sized((uLong)v10, v23, v20, 0);
              v23 += v20;
              ++v22;
              unsigned int v15 = v28;
            }
            while (v22 < v28);
            unsigned int v21 = v28;
          }
          ++v19;
        }
        while (v19 != v13);
      }
      *(void *)(a5 + 64) = v15;
    }
    else
    {
      LogError("DecodeFrameAPNG", 4784, "fcTL_CHUNK size mismatch\n");
    }
  }
  _cg_png_destroy_read_struct((uint64_t *)&v30, (void **)&v29, 0);
}

void sub_18871133C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
}

void sub_18871136C(_Unwind_Exception *a1)
{
}

void ___ZN13PNGReadPlugin22DecodeUncomposedFramesEP12IIOImageReadP13GlobalPNGInfoRK14ReadPluginDataRK13PNGPluginDataRNSt3__16vectorI20IIODecodeFrameParamsNSA_9allocatorISC_EEEE_block_invoke(uint64_t a1, uint64_t a2)
{
  memset(v4, 0, sizeof(v4));
  IIOImageReadSession::IIOImageReadSession((IIOImageReadSession *)v4, *(IIOImageRead **)(a1 + 32));
  PNGReadPlugin::DecodeFrameAPNG((IIOImageReadSession *)v4, *(void *)(a1 + 40), *(void *)(a1 + 48), *(unsigned char **)(a1 + 56), **(void **)(a1 + 64) + 88 * a2);
  IIOImageReadSession::~IIOImageReadSession((IIOImageReadSession *)v4);
}

void sub_1887113E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__split_buffer<IIODecodeFrameParams>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 1jp2_colour_converter::clear(this + 6) = i - 88;
    IIODecodeFrameParams::~IIODecodeFrameParams((IIODecodeFrameParams *)(i - 88));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::shared_ptr<IIOBaseObject>::shared_ptr[abi:ne180100]<IIOFrameBufferQueue,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_1887114B4(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::shared_ptr<IIOBaseObject>::shared_ptr[abi:ne180100]<IIOFrameBufferQueue,void>(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<IIOFrameBufferQueue *,std::shared_ptr<IIOBaseObject>::__shared_ptr_default_delete<IIOBaseObject,IIOFrameBufferQueue>,std::allocator<IIOFrameBufferQueue>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x18C11C0E0);
}

uint64_t std::__shared_ptr_pointer<IIOFrameBufferQueue *,std::shared_ptr<IIOBaseObject>::__shared_ptr_default_delete<IIOBaseObject,IIOFrameBufferQueue>,std::allocator<IIOFrameBufferQueue>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<IIOFrameBufferQueue *,std::shared_ptr<IIOBaseObject>::__shared_ptr_default_delete<IIOBaseObject,IIOFrameBufferQueue>,std::allocator<IIOFrameBufferQueue>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  if (v2 == v3) {
    return 1;
  }
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3)) {
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  }
  return 0;
}

uint64_t png_read_filter_row_sub4_a64(uint64_t result, uint64_t a2)
{
  unint64_t v6 = *(void *)(result + 8) + 15;
  if ((v6 & 0xFFFFFFFFFFFFFFC0) != 0)
  {
    unint64_t v7 = v6 & 0xFFFFFFFFFFFFFFC0;
    int8x16_t v8 = 0uLL;
    do
    {
      float32x4x4_t v16 = vld4q_f32((const float *)a2);
      v16.val[0] = (float32x4_t)vaddq_s8(v8, (int8x16_t)v16.val[0]);
      v16.val[1] = (float32x4_t)vaddq_s8((int8x16_t)v16.val[0], (int8x16_t)v16.val[1]);
      v16.val[2] = (float32x4_t)vaddq_s8((int8x16_t)v16.val[1], (int8x16_t)v16.val[2]);
      v16.val[3] = (float32x4_t)vaddq_s8((int8x16_t)v16.val[2], (int8x16_t)v16.val[3]);
      int8x16_t v9 = vaddq_s8(vaddq_s8(vextq_s8((int8x16_t)0, (int8x16_t)v16.val[3], 0xCuLL), vextq_s8((int8x16_t)0, (int8x16_t)v16.val[3], 8uLL)), vextq_s8((int8x16_t)0, (int8x16_t)v16.val[3], 4uLL));
      v16.val[0] = (float32x4_t)vaddq_s8(v9, (int8x16_t)v16.val[0]);
      v16.val[1] = (float32x4_t)vaddq_s8(v9, (int8x16_t)v16.val[1]);
      v16.val[2] = (float32x4_t)vaddq_s8(v9, (int8x16_t)v16.val[2]);
      v16.val[3] = (float32x4_t)vaddq_s8(v9, (int8x16_t)v16.val[3]);
      int8x16_t v8 = (int8x16_t)v16.val[3].u32[3];
      vst4q_f32((float *)a2, v16);
      a2 += 64;
      v7 -= 64;
    }
    while (v7);
    v6 &= 0x3Fu;
    int8x8_t v10 = (int8x8_t)*(unsigned int *)(a2 - 4);
  }
  else
  {
    int8x8_t v10 = 0;
  }
  if (v6 >= 0x10)
  {
    int8x8_t v11 = v10;
    do
    {
      v2.i32[0] = *(_DWORD *)a2;
      v3.i32[0] = *(_DWORD *)(a2 + 4);
      v4.i32[0] = *(_DWORD *)(a2 + 8);
      v5.i32[0] = *(_DWORD *)(a2 + 12);
      int8x8_t v12 = vadd_s8(v11, v2);
      int8x8_t v13 = vadd_s8(v12, v3);
      int8x8_t v14 = vadd_s8(v13, v4);
      int8x8_t v11 = vadd_s8(v14, v5);
      *(_DWORD *)a2 = v12.i32[0];
      *(_DWORD *)(a2 + 4) = v13.i32[0];
      *(_DWORD *)(a2 + 8) = v14.i32[0];
      *(_DWORD *)(a2 + 12) = v11.i32[0];
      a2 += 16;
      BOOL v15 = v6 >= 0x10;
      v6 -= 16;
    }
    while (v15);
  }
  return result;
}

uint8x16_t png_read_filter_row_avg4_a64(uint64_t a1, unsigned __int32 *a2, __int32 *a3, double a4, double a5, double a6, double a7, int8x16_t a8, int8x16_t a9, int8x16_t a10, int8x16_t a11)
{
  unint64_t v15 = *(void *)(a1 + 8) + 15;
  uint8x16_t v16 = 0uLL;
  do
  {
    a8.i32[0] = *a2;
    a9.i32[0] = a2[1];
    a10.i32[0] = a2[2];
    a11.i32[0] = a2[3];
    v11.i32[0] = *a3;
    v12.i32[0] = a3[1];
    v13.i32[0] = a3[2];
    v14.i32[0] = a3[3];
    a3 += 4;
    uint8x16_t result = (uint8x16_t)vaddq_s8((int8x16_t)vhaddq_u8(v16, v11), a8);
    uint8x16_t v18 = (uint8x16_t)vaddq_s8((int8x16_t)vhaddq_u8(result, v12), a9);
    uint8x16_t v19 = (uint8x16_t)vaddq_s8((int8x16_t)vhaddq_u8(v18, v13), a10);
    uint8x16_t v16 = (uint8x16_t)vaddq_s8((int8x16_t)vhaddq_u8(v19, v14), a11);
    *a2 = result.i32[0];
    a2[1] = v18.i32[0];
    a2[2] = v19.i32[0];
    a2[3] = v16.i32[0];
    a2 += 4;
    BOOL v20 = v15 >= 0x10;
    v15 -= 16;
  }
  while (v20);
  return result;
}

uint64_t _CGImagePlusCopyDebugDesc(const void *a1)
{
  return 0;
}

void IIOImagePlus::setClipPath(IIOImagePlus *this, const CGPath *a2)
{
  int8x8_t v4 = (const CGPath *)*((void *)this + 23);
  if (v4) {
    CGPathRelease(v4);
  }
  *((void *)this + 2++*((_DWORD *)this + 3) = a2;
}

uint64_t IIOImagePlus::setJpegProvider(uint64_t this, int a2)
{
  *(unsigned char *)(this + 192) |= 1u;
  *(_DWORD *)(this + 19jp2_colour_converter::clear(this + 6) = a2;
  return this;
}

CGImageRef IIOImagePlus::setImage(CGImageRef *this, CGImageRef image)
{
  CGImageGetWidth(image);
  CGImageGetHeight(image);
  CGImageGetBitsPerComponent(image);
  CGImageGetBitsPerPixel(image);
  CGImageGetBytesPerRow(image);
  CGImageGetColorSpace(image);
  CGImageGetAlphaInfo(image);
  _ImageIsFloat(image);
  _ImageGetEndianInfo(image);
  CGImageRelease(this[16]);
  CGImageRef result = CGImageRetain(image);
  this[16] = result;
  if (*((_DWORD *)this + 34) != -6) {
    *((_DWORD *)this + 34) = 0;
  }
  return result;
}

uint64_t IIOImagePlus::setRemoveCacheKey(uint64_t this, int a2)
{
  if (a2) {
    char v2 = 32;
  }
  else {
    char v2 = 0;
  }
  *(unsigned char *)(this + 192) = *(unsigned char *)(this + 192) & 0xDF | v2;
  return this;
}

uint64_t IIOImagePlus::setImageIndex(uint64_t this, uint64_t a2)
{
  *(void *)(this + 208) = a2;
  return this;
}

CFTypeRef IIOImagePlus::setMetadata(IIOImagePlus *this, CFTypeRef cf)
{
  int8x8_t v4 = (const void *)*((void *)this + 15);
  if (v4) {
    CFRelease(v4);
  }
  CFTypeRef result = CFRetain(cf);
  *((void *)this + 15) = result;
  return result;
}

void IIOImagePlus::clearProperties(IIODictionary **this)
{
  IIODictionary::removeAllObjects(this[14]);
  if (*((unsigned char *)this + 180))
  {
    char v2 = this[14];
    int8x8_t v3 = (const void *)*MEMORY[0x1E4F1A790];
    IIODictionary::setObjectForKey(v2, v3, @"kCGImageSourceColorTransformOption");
  }
}

void IIOImagePlus::appendProperties(IIODictionary **this, const __CFDictionary **a2)
{
}

CGMutableImageMetadataRef IIOImagePlus::clearMetadata(IIOImagePlus *this)
{
  CGMutableImageMetadataRef result = (CGMutableImageMetadataRef)*((void *)this + 15);
  if (result)
  {
    CFRelease(result);
    CGMutableImageMetadataRef result = CGImageMetadataCreateMutable();
    *((void *)this + 15) = result;
  }
  return result;
}

uint64_t IIOImagePlus::getMatchToProfileOption(IIOImagePlus *this)
{
  return *((unsigned __int8 *)this + 180);
}

uint64_t IIOImageProviderInfo::CopyIOSurfaceSet(uint64_t *a1, const void *a2, const __CFDictionary *a3)
{
  kdebug_trace();
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CopyIOSurfaceSet", a2, 0, -1, a3);
  }
  if (a1) {
    uint64_t v7 = IIOImageProviderInfo::copyIOSurfaceSet(*a1, v6, a3);
  }
  else {
    uint64_t v7 = 0;
  }
  kdebug_trace();
  return v7;
}

uint64_t IIOImagePlus::setReadPluginType(uint64_t this, int a2)
{
  *(_DWORD *)(this + 17jp2_colour_converter::clear(this + 6) = a2;
  return this;
}

void IIOImageProviderInfo::debugCallbackOptionsResult(int a1, CFDictionaryRef theDict, uint64_t a3)
{
  if (theDict && a3)
  {
    unint64_t valuePtr = 0;
    int64_t Count = CFDictionaryGetCount(theDict);
    int8x8_t v5 = (const void **)malloc_type_calloc(Count, 8uLL, 0x6004044C4A2DFuLL);
    uint8x16_t v13 = (const void **)malloc_type_calloc(Count, 8uLL, 0xC0040B8AA526DuLL);
    uint8x16_t v14 = v5;
    CFDictionaryGetKeysAndValues(theDict, v5, v13);
    if (Count >= 1)
    {
      CFStringRef v6 = (const __CFString *)*MEMORY[0x1E4F1DD38];
      CFStringRef v7 = (const __CFString *)*MEMORY[0x1E4F1DD48];
      CFStringRef v8 = (const __CFString *)*MEMORY[0x1E4F1DD18];
      CFStringRef theString2 = (const __CFString *)*MEMORY[0x1E4F1DD20];
      CFStringRef v9 = (const __CFString *)*MEMORY[0x1E4F1DD30];
      int8x8_t v10 = (CFNumberRef *)v13;
      uint8x16_t v11 = (CFStringRef *)v14;
      while (1)
      {
        CFStringRef v12 = *v11;
        if (CFEqual(*v11, v6)) {
          break;
        }
        if (CFEqual(v12, v7))
        {
          CFNumberGetValue(*v10, kCFNumberLongType, &valuePtr);
          if (valuePtr != 1 || CGImageBlockSetGetCount() == 1) {
            goto LABEL_20;
          }
          ImageIOLog("%s", "***************************************************************");
          ImageIOLog("*** bad blockCount: got %ld - expected: 1\n");
          goto LABEL_19;
        }
        if (CFStringCompare(v12, v8, 0))
        {
          if (CFStringCompare(v12, theString2, 0)) {
            goto LABEL_20;
          }
          CFNumberGetValue(*v10, kCFNumberLongType, &valuePtr);
          CGImageBlockSetGetImageBlock();
          if (!(CGImageBlockGetBytesPerRow() % valuePtr)) {
            goto LABEL_20;
          }
          ImageIOLog("%s", "***************************************************************");
          ImageIOLog("*** bad rowbytes alignment: %p (%d) is not %ld-byte aligned\n");
          goto LABEL_19;
        }
        CFNumberGetValue(*v10, kCFNumberLongType, &valuePtr);
        CGImageBlockSetGetImageBlock();
        if (CGImageBlockGetData() % valuePtr)
        {
          ImageIOLog("%s", "***************************************************************");
          ImageIOLog("*** bad baseAddressAlignment: %p is not %ld aligned\n");
LABEL_19:
          ImageIOLog("%s", "***************************************************************");
        }
LABEL_20:
        ++v10;
        ++v11;
        if (!--Count) {
          goto LABEL_21;
        }
      }
      if (CFStringCompare((CFStringRef)*v10, v9, 0) || CGImageBlockSetGetPixelSize() == 4) {
        goto LABEL_20;
      }
      ImageIOLog("%s", "***************************************************************");
      ImageIOLog("*** bad pixelSize: got %ld - expected: 4\n");
      goto LABEL_19;
    }
LABEL_21:
    free(v14);
    free(v13);
  }
}

void IIOImageProviderInfo::logBlockSetDecodingTime(uint64_t a1, uint64_t a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  if (a2)
  {
    if ((gIIODebugFlags & 8) != 0) {
      IIODebug_ShowBacktrace(1);
    }
    CGImageBlockSetGetRect();
    double v41 = v16;
    double v42 = v15;
    double v18 = v17;
    double v20 = v19;
    uint64_t Count = CGImageBlockSetGetCount();
    if (Count)
    {
      CGImageBlockSetGetImageBlock();
      uint64_t BytesPerRow = CGImageBlockGetBytesPerRow();
    }
    else
    {
      uint64_t BytesPerRow = 0;
    }
    CFDictionaryRef v23 = **(const __CFDictionary ***)(a1 + 112);
    if (v23 && (CFNumberRef Value = CFDictionaryGetValue(v23, @"kImageIOInfoHeader_session")) != 0)
    {
      __int16 v25 = (IIOImageRead *)CGImageReadSessionGetRead((uint64_t)Value);
      int v26 = IIOImageRead::copySourceInfo(v25);
    }
    else
    {
      int v26 = 0;
    }
    int v27 = *(_DWORD *)(a1 + 128);
    unsigned int v28 = v27 >> 24;
    uint64_t v29 = MEMORY[0x1E4F14390];
    if (v27 < 0) {
      int v30 = __maskrune(v27 >> 24, 0x40000uLL);
    }
    else {
      int v30 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v28 + 60) & 0x40000;
    }
    if (v30) {
      uint64_t v31 = v28;
    }
    else {
      uint64_t v31 = 46;
    }
    unsigned int v32 = v27 << 8 >> 24;
    if (v27 << 8 < 0) {
      int v33 = __maskrune(v27 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v33 = *(_DWORD *)(v29 + 4 * v32 + 60) & 0x40000;
    }
    if (v33) {
      uint64_t v34 = v32;
    }
    else {
      uint64_t v34 = 46;
    }
    unsigned int v35 = (__int16)v27 >> 8;
    if (v27 << 16 < 0) {
      int v36 = __maskrune((__int16)v27 >> 8, 0x40000uLL);
    }
    else {
      int v36 = *(_DWORD *)(v29 + 4 * v35 + 60) & 0x40000;
    }
    if (v36) {
      uint64_t v37 = v35;
    }
    else {
      uint64_t v37 = 46;
    }
    if ((v27 << 24) <= 0x7F000000) {
      int v38 = *(_DWORD *)(v29 + 4 * (char)v27 + 60) & 0x40000;
    }
    else {
      int v38 = __maskrune((char)v27, 0x40000uLL);
    }
    if (v38) {
      uint64_t v39 = (char)v27;
    }
    else {
      uint64_t v39 = 46;
    }
    long long v40 = "";
    if (v26) {
      long long v40 = v26;
    }
    ImageIOLog("    '%c%c%c%c' CopyImageBlockSet\tsRect={%g, %g, %g, %g}\tdSize={%g,%g}\tblkSet={%g, %g, %g, %g}\t#=%2d\trb=%ld\ttime: %g ms\t%s\n", v31, v34, v37, v39, a3, a4, a5, a6, a7, a8, v42, v41, v18, v20, Count, BytesPerRow, *(double *)(a1 + 136) * 1000.0,
      v40);
    if (v26)
    {
      free(v26);
    }
  }
  else
  {
    ImageIOLog("*** CopyImageBlockSet returned NULL\n");
  }
}

void IIOImageProviderInfo::logSurfaceDecodingTime(IIOImageProviderInfo *this, __IOSurface *a2)
{
  if ((gIIODebugFlags & 8) != 0) {
    IIODebug_ShowBacktrace(1);
  }
  CFDictionaryRef v4 = (const __CFDictionary *)**((void **)this + 14);
  if (v4 && (CFNumberRef Value = CFDictionaryGetValue(v4, @"kImageIOInfoHeader_session")) != 0)
  {
    uint64_t Source = (IIOImageRead **)CGImageSourceGetSource((uint64_t)Value);
    long long v43 = IIOImageReadSession::copySourceInfo(Source);
  }
  else
  {
    long long v43 = 0;
  }
  signed int PixelFormat = IOSurfaceGetPixelFormat(a2);
  size_t Width = IOSurfaceGetWidth(a2);
  size_t Height = IOSurfaceGetHeight(a2);
  int v10 = *((_DWORD *)this + 32);
  unsigned int v11 = v10 >> 24;
  uint64_t v12 = MEMORY[0x1E4F14390];
  size_t v44 = Height;
  if (v10 < 0)
  {
    int v42 = __maskrune(v11, 0x40000uLL);
    int v10 = *((_DWORD *)this + 32);
  }
  else
  {
    int v42 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v11 + 60) & 0x40000;
  }
  unsigned int v13 = v10 << 8 >> 24;
  size_t v45 = Width;
  if (v10 << 8 < 0)
  {
    int v41 = __maskrune(v13, 0x40000uLL);
    int v14 = *((_DWORD *)this + 32);
  }
  else
  {
    int v41 = *(_DWORD *)(v12 + 4 * v13 + 60) & 0x40000;
    int v14 = v10;
  }
  unsigned int v15 = (__int16)v14 >> 8;
  if (v14 << 16 < 0)
  {
    int v40 = __maskrune(v15, 0x40000uLL);
    int v16 = *((_DWORD *)this + 32);
  }
  else
  {
    int v40 = *(_DWORD *)(v12 + 4 * v15 + 60) & 0x40000;
    int v16 = v14;
  }
  if ((v16 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v12 + 4 * (char)v16 + 60) & 0x40000) != 0) {
      goto LABEL_18;
    }
  }
  else if (__maskrune((char)v16, 0x40000uLL))
  {
LABEL_18:
    uint64_t v17 = *((char *)this + 128);
    goto LABEL_21;
  }
  uint64_t v17 = 46;
LABEL_21:
  uint64_t v39 = v17;
  unsigned int v18 = PixelFormat >> 24;
  if (PixelFormat < 0) {
    int v38 = __maskrune(PixelFormat >> 24, 0x40000uLL);
  }
  else {
    int v38 = *(_DWORD *)(v12 + 4 * v18 + 60) & 0x40000;
  }
  unsigned int v19 = PixelFormat << 8 >> 24;
  int v46 = this;
  if (PixelFormat << 8 < 0) {
    int v20 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
  }
  else {
    int v20 = *(_DWORD *)(v12 + 4 * v19 + 60) & 0x40000;
  }
  unsigned int v21 = (__int16)PixelFormat >> 8;
  uint64_t v22 = v12;
  if (PixelFormat << 16 < 0)
  {
    int v24 = v20;
    int v25 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
    int v20 = v24;
    int v23 = v25;
  }
  else
  {
    int v23 = *(_DWORD *)(v12 + 4 * v21 + 60) & 0x40000;
  }
  unsigned int v26 = (char)PixelFormat;
  if ((PixelFormat << 24) <= 0x7F000000)
  {
    int v29 = *(_DWORD *)(v22 + 4 * (char)PixelFormat + 60) & 0x40000;
  }
  else
  {
    __darwin_ct_rune_t v27 = (char)PixelFormat;
    int v28 = v20;
    int v29 = __maskrune(v27, 0x40000uLL);
    int v20 = v28;
  }
  LODWORD(v30) = (__int16)v16 >> 8;
  if (v40) {
    uint64_t v30 = v30;
  }
  else {
    uint64_t v30 = 46;
  }
  LODWORD(v31) = v14 << 8 >> 24;
  if (v41) {
    uint64_t v31 = v31;
  }
  else {
    uint64_t v31 = 46;
  }
  LODWORD(v32) = v10 >> 24;
  if (v42) {
    uint64_t v32 = v32;
  }
  else {
    uint64_t v32 = 46;
  }
  if (v23) {
    uint64_t v33 = v21;
  }
  else {
    uint64_t v33 = 46;
  }
  if (v20) {
    uint64_t v34 = v19;
  }
  else {
    uint64_t v34 = 46;
  }
  if (v38) {
    uint64_t v35 = v18;
  }
  else {
    uint64_t v35 = 46;
  }
  if (v29) {
    uint64_t v36 = v26;
  }
  else {
    uint64_t v36 = 46;
  }
  uint64_t v37 = "";
  if (v43) {
    uint64_t v37 = v43;
  }
  ImageIOLog("    '%c%c%c%c' CopyIOSurface\tformat=(%c%c%c%c)\tsize=(%zu,%zu)\ttime: %g ms\t%s\n", v32, v31, v30, v39, v35, v34, v33, v36, v45, v44, *((double *)v46 + 17) * 1000.0, v37);

  free(v43);
}

void IIOImageProviderInfo::logSurfaceSetDecodingTime(uint64_t a1)
{
  if ((gIIODebugFlags & 8) != 0) {
    IIODebug_ShowBacktrace(1);
  }
  CFDictionaryRef v2 = **(const __CFDictionary ***)(a1 + 112);
  if (v2 && (CFNumberRef Value = CFDictionaryGetValue(v2, @"kImageIOInfoHeader_session")) != 0) {
    SessionCopySourceInfo = CGImageReadSessionCopySourceInfo((uint64_t)Value);
  }
  else {
    SessionCopySourceInfo = 0;
  }
  IOSurface = (__IOSurface *)CGImageSurfaceSetGetIOSurface();
  signed int PixelFormat = IOSurfaceGetPixelFormat(IOSurface);
  size_t Width = IOSurfaceGetWidth(IOSurface);
  size_t Height = IOSurfaceGetHeight(IOSurface);
  int v8 = *(_DWORD *)(a1 + 128);
  unsigned int v9 = v8 >> 24;
  uint64_t v10 = MEMORY[0x1E4F14390];
  size_t v42 = Height;
  if (v8 < 0)
  {
    int v40 = __maskrune(v9, 0x40000uLL);
    int v8 = *(_DWORD *)(a1 + 128);
  }
  else
  {
    int v40 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
  }
  unsigned int v11 = v8 << 8 >> 24;
  size_t v43 = Width;
  if (v8 << 8 < 0)
  {
    int v39 = __maskrune(v11, 0x40000uLL);
    int v12 = *(_DWORD *)(a1 + 128);
  }
  else
  {
    int v39 = *(_DWORD *)(v10 + 4 * v11 + 60) & 0x40000;
    int v12 = v8;
  }
  unsigned int v13 = (__int16)v12 >> 8;
  if (v12 << 16 < 0)
  {
    int v38 = __maskrune(v13, 0x40000uLL);
    int v14 = *(_DWORD *)(a1 + 128);
  }
  else
  {
    int v38 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    int v14 = v12;
  }
  if ((v14 << 24) <= 0x7F000000)
  {
    if ((*(_DWORD *)(v10 + 4 * (char)v14 + 60) & 0x40000) != 0) {
      goto LABEL_18;
    }
  }
  else if (__maskrune((char)v14, 0x40000uLL))
  {
LABEL_18:
    uint64_t v15 = *(char *)(a1 + 128);
    goto LABEL_21;
  }
  uint64_t v15 = 46;
LABEL_21:
  uint64_t v37 = v15;
  unsigned int v16 = PixelFormat >> 24;
  if (PixelFormat < 0) {
    int v36 = __maskrune(PixelFormat >> 24, 0x40000uLL);
  }
  else {
    int v36 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
  }
  unsigned int v17 = PixelFormat << 8 >> 24;
  uint64_t v44 = a1;
  if (PixelFormat << 8 < 0) {
    int v18 = __maskrune(PixelFormat << 8 >> 24, 0x40000uLL);
  }
  else {
    int v18 = *(_DWORD *)(v10 + 4 * v17 + 60) & 0x40000;
  }
  unsigned int v19 = (__int16)PixelFormat >> 8;
  uint64_t v20 = v10;
  if (PixelFormat << 16 < 0)
  {
    int v22 = v18;
    int v23 = __maskrune((__int16)PixelFormat >> 8, 0x40000uLL);
    int v18 = v22;
    int v21 = v23;
  }
  else
  {
    int v21 = *(_DWORD *)(v10 + 4 * v19 + 60) & 0x40000;
  }
  unsigned int v24 = (char)PixelFormat;
  if ((PixelFormat << 24) <= 0x7F000000)
  {
    int v27 = *(_DWORD *)(v20 + 4 * (char)PixelFormat + 60) & 0x40000;
  }
  else
  {
    __darwin_ct_rune_t v25 = (char)PixelFormat;
    int v26 = v18;
    int v27 = __maskrune(v25, 0x40000uLL);
    int v18 = v26;
  }
  LODWORD(v28) = (__int16)v14 >> 8;
  if (v38) {
    uint64_t v28 = v28;
  }
  else {
    uint64_t v28 = 46;
  }
  LODWORD(v29) = v12 << 8 >> 24;
  if (v39) {
    uint64_t v29 = v29;
  }
  else {
    uint64_t v29 = 46;
  }
  LODWORD(v30) = v8 >> 24;
  if (v40) {
    uint64_t v30 = v30;
  }
  else {
    uint64_t v30 = 46;
  }
  if (v21) {
    uint64_t v31 = v19;
  }
  else {
    uint64_t v31 = 46;
  }
  if (v18) {
    uint64_t v32 = v17;
  }
  else {
    uint64_t v32 = 46;
  }
  if (v36) {
    uint64_t v33 = v16;
  }
  else {
    uint64_t v33 = 46;
  }
  if (v27) {
    uint64_t v34 = v24;
  }
  else {
    uint64_t v34 = 46;
  }
  uint64_t v35 = "";
  if (SessionCopySourceInfo) {
    uint64_t v35 = SessionCopySourceInfo;
  }
  ImageIOLog("    '%c%c%c%c' CopyIOSurfaceSet\tformat=(%c%c%c%c)\tsize=(%zu,%zu)\ttime: %g ms\t%s\n", v30, v29, v28, v37, v33, v32, v31, v34, v43, v42, *(double *)(v44 + 136) * 1000.0, v35);

  free(SessionCopySourceInfo);
}

uint64_t IIOImageProviderInfo::copyIOSurfaceSet(uint64_t a1, uint64_t a2, const __CFDictionary *a3)
{
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "copyIOSurfaceSet", 0, 0, -1, a3);
  }
  IIOInitDebugFlags();
  if ((gIIODebugFlags & 0xC) != 0) {
    *(CFAbsoluteTime *)(a1 + 13jp2_colour_converter::clear(this + 6) = CFAbsoluteTimeGetCurrent();
  }
  if (*(void *)(a1 + 232))
  {
    int8x8_t v5 = *(CFTypeRef **)(a1 + 112);
    if (v5)
    {
      CFDictionaryRef v6 = (const __CFDictionary *)*v5;
      if (*v5)
      {
        CFTypeID v7 = CFGetTypeID(*v5);
        if (v7 == CFDictionaryGetTypeID())
        {
          pthread_mutex_lock((pthread_mutex_t *)(a1 + 144));
          int v8 = (const void *)*MEMORY[0x1E4F1CFD0];
          if (v8 == CFDictionaryGetValue(v6, @"kImageIOInfoHeader_pluginHandlesReMapping"))
          {
            BOOL v12 = 0;
            unsigned int v11 = 0;
          }
          else
          {
            CFNumberRef Value = CFDictionaryGetValue(v6, @"kImageIOInfoHeader_session");
            uint64_t v10 = (IIOImageRead *)CGImageReadSessionGetRead((uint64_t)Value);
            unsigned int v11 = (const char *)v10;
            if (v10) {
              BOOL v12 = IIOImageRead::mapData(v10);
            }
            else {
              BOOL v12 = 0;
            }
          }
          uint64_t v13 = (*(uint64_t (**)(void, void, const __CFDictionary *))(a1 + 232))(*(void *)(a1 + 112), *(void *)(a1 + 16), a3);
          if (v13 && (gIIODebugFlags & 0xC) != 0)
          {
            *(CFAbsoluteTime *)(a1 + 13jp2_colour_converter::clear(this + 6) = CFAbsoluteTimeGetCurrent() - *(double *)(a1 + 136);
            IIOImageProviderInfo::logSurfaceSetDecodingTime(a1);
          }
          if (v12 && v11) {
            IIOImageRead::unmapData(v11);
          }
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 144));
          if (v13) {
            return v13;
          }
          goto LABEL_24;
        }
      }
    }
    else
    {
      CFDictionaryRef v6 = 0;
    }
    LogFault("copyIOSurfaceSet", 2437, "header '%p' is not a CFDictionary...\n", v6);
    return 0;
  }
  uint64_t v13 = 0;
LABEL_24:
  if ((gIIODebugFlags & 0x800000000000) != 0)
  {
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "copyIOSurfaceSet", 2468, "returned ioSurfaceSet is NULL\n");
    return 0;
  }
  return v13;
}

uint64_t IIOIsOOPEnabled(void *a1)
{
  if (IIOIsOOPEnabled::onceToken != -1)
  {
    dispatch_once(&IIOIsOOPEnabled::onceToken, &__block_literal_global_6);
    if (!a1) {
      return IIOIsOOPEnabled::oopEnabled;
    }
    goto LABEL_3;
  }
  if (a1) {
LABEL_3:
  }
    *a1 = IIOIsOOPEnabled::info;
  return IIOIsOOPEnabled::oopEnabled;
}

uint64_t __IIOIsOOPEnabled_block_invoke()
{
  CFStringRef v0 = (const __CFString *)IIOGetBundleIdentifer();
  getprogname();
  if (IIO_OSAppleInternalBuild() && (getenv("RC_XBS") || getenv("XBS_IS_CHROOTED")))
  {
    LOBYTE(v1) = 0;
    CFDictionaryRef v2 = "disabled";
    int8x8_t v3 = "B&I";
    goto LABEL_52;
  }
  if (IIO_XPCServer())
  {
    LOBYTE(v1) = 0;
    CFDictionaryRef v2 = "disabled";
    int8x8_t v3 = "unsupported";
    goto LABEL_52;
  }
  if (v0)
  {
    CFComparisonResult v1 = CFStringCompare(v0, @"com.apple.MessagesAirlockService", 0);
    if (v1 == kCFCompareEqualTo) {
      goto LABEL_32;
    }
    CFComparisonResult v1 = CFStringCompare(v0, @"com.apple.MessagesBlastDoorService", 0);
    if (v1 == kCFCompareEqualTo) {
      goto LABEL_32;
    }
    CFComparisonResult v1 = CFStringCompare(v0, @"com.apple.IDSBlastDoorService", 0);
    if (v1 == kCFCompareEqualTo) {
      goto LABEL_32;
    }
    CFComparisonResult v1 = CFStringCompare(v0, @"com.apple.MediaAnalysisBlastDoorService", 0);
    if (v1 == kCFCompareEqualTo) {
      goto LABEL_32;
    }
    CFComparisonResult v1 = CFStringCompare(v0, @"com.apple.QuickLookThumbnailing.extension-secure", 0);
    if (v1 == kCFCompareEqualTo) {
      goto LABEL_32;
    }
    CFComparisonResult v1 = CFStringCompare(v0, @"com.apple.WebKit.WebContent.CaptivePortal", 0);
    if (v1 == kCFCompareEqualTo) {
      goto LABEL_32;
    }
    CFComparisonResult v1 = CFStringCompare(v0, @"com.apple.WebKit.WebContent.Crashy", 0);
    if (v1 == kCFCompareEqualTo) {
      goto LABEL_32;
    }
    CFComparisonResult v1 = CFStringCompare(v0, @"com.apple.WebKit.WebContent.Development", 0);
    if (v1 == kCFCompareEqualTo) {
      goto LABEL_32;
    }
    CFComparisonResult v1 = CFStringCompare(v0, @"com.apple.WebKit.WebContentExtension", 0);
    if (v1 == kCFCompareEqualTo) {
      goto LABEL_32;
    }
    CFComparisonResult v1 = CFStringCompare(v0, @"com.apple.WebKit.WebContent", 0);
    if (v1 == kCFCompareEqualTo) {
      goto LABEL_32;
    }
    CFComparisonResult v1 = CFStringCompare(v0, @"com.apple.WebKit.WebContentCaptivePortalExtension", 0);
    if (v1 == kCFCompareEqualTo) {
      goto LABEL_32;
    }
    CFComparisonResult v1 = CFStringCompare(v0, @"com.apple.quicklook.thumbnail.OfficeExtension", 0);
    if (v1 == kCFCompareEqualTo) {
      goto LABEL_32;
    }
    CFComparisonResult v1 = CFStringCompare(v0, @"com.apple.quicklook.thumbnail.AudiovisualExtension", 0);
    if (v1 == kCFCompareEqualTo) {
      goto LABEL_32;
    }
    CFComparisonResult v1 = CFStringCompare(v0, @"com.apple.quicklook.thumbnail.TextExtension", 0);
    if (v1 == kCFCompareEqualTo
      || (CFComparisonResult v1 = CFStringCompare(v0, @"com.apple.quicklook.thumbnail.ImageExtension", 0)) == kCFCompareEqualTo
      || (CFComparisonResult v1 = CFStringCompare(v0, @"com.google.Chrome.helper.renderer", 0)) == kCFCompareEqualTo
      || (CFComparisonResult v1 = CFStringCompare(v0, @"com.microsoft.edgemac.helper.renderer", 0)) == kCFCompareEqualTo
      || (CFComparisonResult v1 = CFStringCompare(v0, @"company.thebrowser.browser.helper.renderer", 0)) == kCFCompareEqualTo
      || (CFComparisonResult v1 = CFStringCompare(v0, @"com.brave.Browser.helper.renderer", 0)) == kCFCompareEqualTo
      || (CFComparisonResult v1 = CFStringCompare(v0, @"org.qt-project.Qt.QtWebEngineProcess", 0)) == kCFCompareEqualTo
      || (CFComparisonResult v1 = CFStringCompare(v0, @"com.operasoftware.Opera.helper", 0)) == kCFCompareEqualTo)
    {
LABEL_32:
      CFDictionaryRef v2 = "disabled";
      int8x8_t v3 = "always exempt process";
      goto LABEL_52;
    }
  }
  CFDictionaryRef v4 = getenv("IIOEnableOOP");
  if (v4)
  {
    if (atoi(v4))
    {
LABEL_31:
      CFDictionaryRef v2 = "enabled";
      LOBYTE(v1) = 1;
LABEL_39:
      int8x8_t v3 = "ENV";
      goto LABEL_52;
    }
  }
  else
  {
    CFPropertyListRef v5 = CFPreferencesCopyAppValue(@"IIOEnableOOP", (CFStringRef)*MEMORY[0x1E4F1D3D8]);
    if (!v5)
    {
      CFPropertyListRef v5 = CFPreferencesCopyValue(@"IIOEnableOOP", @"com.apple.ImageIO", (CFStringRef)*MEMORY[0x1E4F1D3F0], (CFStringRef)*MEMORY[0x1E4F1D3E0]);
      if (!v5) {
        goto LABEL_40;
      }
    }
    CFTypeID TypeID = CFBooleanGetTypeID();
    if (TypeID != CFGetTypeID(v5)) {
      goto LABEL_40;
    }
    if ((CFPropertyListRef)*MEMORY[0x1E4F1CFD0] == v5) {
      goto LABEL_31;
    }
  }
  if (IIO_OSAppleInternalBuild())
  {
    LOBYTE(v1) = 0;
    CFDictionaryRef v2 = "disabled";
    goto LABEL_39;
  }
LABEL_40:
  CFDictionaryRef v2 = "disabled";
  if (_os_feature_enabled_impl())
  {
    LOBYTE(v1) = 0;
    int8x8_t v3 = "FF-disabled";
    goto LABEL_52;
  }
  if (_os_feature_enabled_impl())
  {
    CFDictionaryRef v2 = "enabled";
    LOBYTE(v1) = 1;
    int8x8_t v3 = "FF-debug-enabled";
    goto LABEL_52;
  }
  LODWORD(v1) = ApplicationOptIn();
  if (v1 == kCFCompareGreaterThan)
  {
    CFDictionaryRef v2 = "enabled";
    goto LABEL_49;
  }
  if (!v1)
  {
LABEL_49:
    int8x8_t v3 = "application opt-in";
    goto LABEL_52;
  }
  if (ApplicationEnabled_LDM_off(v0, v7))
  {
    int8x8_t v3 = "always enabled process";
    LOBYTE(v1) = 1;
    CFDictionaryRef v2 = "enabled";
  }
  else
  {
    LODWORD(v1) = IIOLockDownModeEnabled();
    int8x8_t v3 = "LDM off";
    if (v1)
    {
      int8x8_t v3 = "LDM on";
      CFDictionaryRef v2 = "enabled";
    }
  }
LABEL_52:
  IIOIsOOPEnabled::oopEnabled = v1;
  IIOIsOOPEnabled::info = (uint64_t)v3;
  return ImageIOLogInternal("*** ImageIO OOP %s (%s)\n", v2, v3);
}

uint64_t ApplicationOptIn(void)
{
  MainBundle = CFBundleGetMainBundle();
  InfoDictionarCGFloat y = CFBundleGetInfoDictionary(MainBundle);
  if (!InfoDictionary) {
    return 0xFFFFFFFFLL;
  }
  CFNumberRef Value = CFDictionaryGetValue(InfoDictionary, @"NSImageIOEnableOutOfProcess");
  if (!Value) {
    return 0xFFFFFFFFLL;
  }
  int8x8_t v3 = Value;
  CFTypeID TypeID = CFBooleanGetTypeID();
  if (TypeID != CFGetTypeID(v3)) {
    return 0xFFFFFFFFLL;
  }
  if ((const void *)*MEMORY[0x1E4F1CFD0] == v3) {
    return 1;
  }
  return IIO_OSAppleInternalBuild() - 1;
}

CFStringRef ApplicationEnabled_LDM_off(const __CFString *result, const char *a2)
{
  if (result)
  {
    CFStringRef v2 = result;
    return (const __CFString *)(CFEqual(result, @"com.apple.SubcredentialUIService.SubcredentialInvitationMessagesExtension")|| CFEqual(v2, @"com.apple.gamecenter.GameCenterUIService.GameCenterMessageExtension")|| CFEqual(v2, @"com.apple.icloud.apps.messages.business.extension"));
  }
  return result;
}

uint64_t CGImageMetadataValueGetTypeID()
{
  IIOInitDebugFlags();
  unsigned int v0 = (unsigned __int16)gIIODebugFlags >> 14;
  if (v0 >= 2) {
    ImageIODebugOptions(v0, "S", "CGImageMetadataValueGetTypeID", 0, 0, -1, 0);
  }
  if (CGImageMetadataValueGetTypeID::once != -1) {
    dispatch_once(&CGImageMetadataValueGetTypeID::once, &__block_literal_global_7);
  }
  return CGImageMetadataValueGetTypeID::id;
}

double _CGImageMetadataValueFinalize(void *a1)
{
  unsigned int v2 = (gIIODebugFlags >> 12) & 3;
  if (v2) {
    ImageIODebugOptions(v2, "A", "_CGImageMetadataValueFinalize", 0, 0, -1, 0);
  }
  int8x8_t v3 = (const void *)a1[2];
  if (v3) {
    CFRelease(v3);
  }
  a1[2] = 0;
  CFDictionaryRef v4 = (const void *)a1[3];
  if (v4) {
    CFRelease(v4);
  }
  a1[3] = 0;
  CFPropertyListRef v5 = (const void *)a1[4];
  if (v5) {
    CFRelease(v5);
  }
  a1[4] = 0;
  CFDictionaryRef v6 = (const void *)a1[6];
  if (v6) {
    CFRelease(v6);
  }
  a1[6] = 0;
  double result = 0.0;
  *((_OWORD *)a1 + 1) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  return result;
}

CFStringRef _CGImageMetadataCopyDebugDesc(CFTypeRef cf)
{
  unsigned int v2 = (const void *)*((void *)cf + 2);
  if (v2)
  {
    uint64_t v3 = *((void *)cf + 6);
    CFTypeID v4 = CFGetTypeID(v2);
    CFTypeID TypeID = CFStringGetTypeID();
    CFTypeID v6 = TypeID;
    if (v3)
    {
      CFAllocatorRef v7 = CFGetAllocator(cf);
      if (v4 == v6)
      {
        uint64_t v16 = *((void *)cf + 2);
        ValueAtIndeCGFloat x = CFArrayGetValueAtIndex(*((CFArrayRef *)cf + 6), 0);
        CFTypeRef v15 = cf;
        CFStringRef v8 = @"<CGImageMetadataValue %p> (value = \"%@\", qualifier = \"%@\")";
      }
      else
      {
        CFTypeRef v15 = cf;
        CFStringRef v8 = @"<CGImageMetadataValue %p> (unimplemented description)";
      }
      return CFStringCreateWithFormat(v7, 0, v8, v15, v16, ValueAtIndex);
    }
    else if (v4 == TypeID)
    {
      CFAllocatorRef v11 = CFGetAllocator(cf);
      return CFStringCreateWithFormat(v11, 0, @"<CGImageMetadataValue %p> (xpc_object_t value = \"%@\")", cf, *((void *)cf + 2));
    }
    else
    {
      CFStringRef v12 = CFCopyDescription(*((CFTypeRef *)cf + 2));
      CFAllocatorRef v13 = CFGetAllocator(cf);
      CFStringRef v14 = CFStringCreateWithFormat(v13, 0, @"<CGImageMetadataValue %p> (value = \"%@\")", cf, v12);
      CFRelease(v12);
      return v14;
    }
  }
  else
  {
    CFAllocatorRef v9 = CFGetAllocator(cf);
    return CFStringCreateWithFormat(v9, 0, @"<CGImageMetadataValue %p>  (invalid)", cf);
  }
}

uint64_t __CGImageMetadataValueGetTypeID_block_invoke()
{
  uint64_t result = _CFRuntimeRegisterClass();
  CGImageMetadataValueGetTypeID::id = result;
  return result;
}

uint64_t CGImageMetadataValueGetValue(uint64_t a1)
{
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueGetValue", 0, 0, -1, 0);
  }
  if (a1) {
    return *(void *)(a1 + 16);
  }
  else {
    return 0;
  }
}

void CGImageMetadataValueAddQualifier(void *a1, const void *a2)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueAddQualifier", 0, 0, -1, 0);
  }
  if (a1)
  {
    if (a2)
    {
      CFTypeID v4 = CFGetTypeID(a1);
      if (v4 == CGImageMetadataValueGetTypeID())
      {
        CGMutableImageMetadataRef Mutable = (__CFArray *)a1[6];
        if (Mutable
          || (CGMutableImageMetadataRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]),
              (a1[6] = Mutable) != 0))
        {
          CFArrayAppendValue(Mutable, a2);
        }
      }
    }
  }
}

uint64_t CGImageMetadataValueGetQualifiers(uint64_t a1)
{
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueGetQualifiers", 0, 0, -1, 0);
  }
  if (a1) {
    return *(void *)(a1 + 48);
  }
  else {
    return 0;
  }
}

void CGImageMetadataValueSetNamespaceURI(uint64_t a1, const void *a2)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueSetNamespaceURI", 0, 0, -1, 0);
  }
  if (a1)
  {
    CFTypeID v4 = *(const void **)(a1 + 24);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 24) = 0;
    if (a2) {
      *(void *)(a1 + 24) = CFRetain(a2);
    }
  }
}

uint64_t CGImageMetadataValueGetNamespaceURI(uint64_t a1)
{
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueGetNamespaceURI", 0, 0, -1, 0);
  }
  if (a1) {
    return *(void *)(a1 + 24);
  }
  else {
    return 0;
  }
}

void CGImageMetadataValueSetSuggestedNamespacePrefix(uint64_t a1, const void *a2)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueSetSuggestedNamespacePrefix", 0, 0, -1, 0);
  }
  if (a1)
  {
    CFTypeID v4 = *(const void **)(a1 + 32);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 32) = 0;
    if (a2) {
      *(void *)(a1 + 32) = CFRetain(a2);
    }
  }
}

uint64_t CGImageMetadataValueGetSuggestedNamespacePrefix(uint64_t a1)
{
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueGetSuggestedNamespacePrefix", 0, 0, -1, 0);
  }
  if (a1) {
    return *(void *)(a1 + 32);
  }
  else {
    return 0;
  }
}

void CGImageMetadataValueSetIsAlternate(uint64_t a1, int a2)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueSetIsAlternate", 0, 0, -1, 0);
  }
  if (a1)
  {
    if (a2) {
      int v4 = 2048;
    }
    else {
      int v4 = 0;
    }
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 40) & 0xFFFFF7FF | v4;
  }
}

uint64_t CGImageMetadataValueIsAlternate(uint64_t a1)
{
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueIsAlternate", 0, 0, -1, 0);
  }
  if (a1) {
    return (*(unsigned __int8 *)(a1 + 41) >> 3) & 1;
  }
  else {
    return 0;
  }
}

void CGImageMetadataValueSetIsAlternateText(uint64_t a1, int a2)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueSetIsAlternateText", 0, 0, -1, 0);
  }
  if (a1)
  {
    if (a2) {
      int v4 = 4096;
    }
    else {
      int v4 = 0;
    }
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(a1 + 40) & 0xFFFFEFFF | v4;
  }
}

uint64_t CGImageMetadataValueIsAlternateText(uint64_t a1)
{
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageMetadataValueIsAlternateText", 0, 0, -1, 0);
  }
  if (a1) {
    return (*(unsigned __int8 *)(a1 + 41) >> 4) & 1;
  }
  else {
    return 0;
  }
}

uint64_t CGImageMetadataValueCreate(const void *a1)
{
  if (a1)
  {
    CGImageMetadataValueGetTypeID();
    uint64_t Instance = _CFRuntimeCreateInstance();
    if (Instance)
    {
      CFTypeRef v3 = CFRetain(a1);
      *(void *)(Instance + 48) = 0;
      *(void *)(Instance + 24) = 0;
      *(void *)(Instance + 32) = 0;
      *(void *)(Instance + 1jp2_colour_converter::clear(this + 6) = v3;
      *(_DWORD *)(Instance + 40) = 0;
    }
  }
  else
  {
    LogError("CGImageMetadataValueCreate", 365, "*** ERROR: parameter is NULL\n");
    return 0;
  }
  return Instance;
}

void WBMPReader::~WBMPReader(WBMPReader *this)
{
}

uint64_t WBMPReader::decodeBuffer(WBMPReader *this, vImage_Buffer *a2)
{
  memset(v12, 0, sizeof(v12));
  IIOPixelConverterGray::IIOPixelConverterGray((uint64_t)v12, 6, 1, 1u, 0, 6, 8u, 0, 0);
  vImagePixelCount width = a2->width;
  unint64_t v5 = (width + 7) >> 3;
  unsigned int v7 = *((_DWORD *)this + 4);
  uint64_t v6 = *((unsigned int *)this + 5);
  if (v6 + v5 * a2->height <= v7)
  {
    vImagePixelCount height = a2->height;
LABEL_6:
    srcs.data = (void *)(*((void *)this + 1) + v6);
    srcs.vImagePixelCount height = height;
    srcs.vImagePixelCount width = width;
    srcs.size_t rowBytes = ((width + 7) >> 3);
    uint64_t v8 = IIOPixelConverterGray::convert((IIOPixelConverterGray *)v12, &srcs, a2);
    goto LABEL_7;
  }
  if (v7 - v6 >= v5)
  {
    vImagePixelCount height = (v7 - v6) / v5;
    a2->vImagePixelCount height = height;
    goto LABEL_6;
  }
  uint64_t v8 = 4294967246;
LABEL_7:
  IIOPixelConverterGray::~IIOPixelConverterGray((IIOPixelConverterGray *)v12);
  return v8;
}

void sub_188713720(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  IIOPixelConverterGray::~IIOPixelConverterGray((IIOPixelConverterGray *)va);
  _Unwind_Resume(a1);
}

CGImageRef CGImageCreateWithWBMPData(const __CFData *a1)
{
  IIOInitDebugFlags();
  if ((unsigned __int16)gIIODebugFlags >> 14) {
    ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageCreateWithWBMPData", 0, 0, -1, 0);
  }
  CGDataProviderDirectCallbacks callbacks = *(CGDataProviderDirectCallbacks *)byte_1ED4F09D0;
  BytePtr = CFDataGetBytePtr(a1);
  unsigned int Length = CFDataGetLength(a1);
  uint64_t v4 = 0;
  int v5 = 0;
  unsigned int v42 = Length;
  v41[0] = &unk_1ED4DE5E0;
  v41[1] = BytePtr;
  uint64_t v6 = Length;
  while (Length != v4)
  {
    unsigned int v7 = v4 + 1;
    unsigned int v43 = v4 + 1;
    UInt8 v8 = BytePtr[v4];
    int v9 = v8 & 0x7F | (v5 << 7);
    ++v4;
    int v5 = v9;
    if ((v8 & 0x80) == 0)
    {
      if (v9)
      {
        if (v9 != -1) {
          _cg_jpeg_mem_term("CGImageCreateWithWBMPData", 163, "*** unsupported WBMP type [%d]\n", v9);
        }
      }
      else
      {
        int v10 = 0;
        uint64_t v11 = v7;
        if (v7 <= Length) {
          uint64_t v12 = Length;
        }
        else {
          uint64_t v12 = v7;
        }
        while (v11 != v12)
        {
          unsigned int v13 = v11 + 1;
          UInt8 v14 = BytePtr[v11];
          int v15 = v14 & 0x7F | (v10 << 7);
          ++v11;
          int v10 = v15;
          if ((v14 & 0x80) == 0)
          {
            if (v15 != -1)
            {
              int v16 = 0;
              unsigned int v17 = v13 + 1;
              if (Length >= (unint64_t)v13) {
                unint64_t v18 = Length - (unint64_t)v13;
              }
              else {
                unint64_t v18 = 0;
              }
              unsigned int v19 = &BytePtr[v13];
              while (v18)
              {
                char v20 = *v19++;
                int v21 = v20 & 0x7F | (v16 << 7);
                ++v17;
                --v18;
                int v16 = v21;
                if ((v20 & 0x80) == 0)
                {
                  if (v21 != -1)
                  {
                    int v22 = 0;
                    unint64_t v23 = v17 - 1;
                    if (v23 > Length) {
                      uint64_t v6 = v17 - 1;
                    }
                    uint64_t v24 = v23 - v6;
                    __darwin_ct_rune_t v25 = &BytePtr[v23];
                    while (v24)
                    {
                      unsigned int v43 = v17;
                      char v26 = *v25++;
                      int v27 = v26 & 0x7F | (v22 << 7);
                      ++v24;
                      ++v17;
                      int v22 = v27;
                      if ((v26 & 0x80) == 0)
                      {
                        if (v27 == -1) {
                          return 0;
                        }
                        vImagePixelCount v28 = (unsigned __int16)v21;
                        size_t v29 = ((unsigned __int16)v21 + 7) & 0x1FFF8;
                        vImagePixelCount v30 = (unsigned __int16)v27;
                        uint64_t v31 = malloc_type_malloc((unsigned __int16)v27 * v29, 0x3A086DFDuLL);
                        if (!v31) {
                          return 0;
                        }
                        uint64_t v32 = v31;
                        memset(v31, 192, (v30 * v29));
                        v40.data = v32;
                        v40.vImagePixelCount height = v30;
                        v40.vImagePixelCount width = v28;
                        v40.size_t rowBytes = (v28 + 7) & 0x1FFF8;
                        if (WBMPReader::decodeBuffer((WBMPReader *)v41, &v40)
                          || (CGDataProviderRef v35 = CGDataProviderCreateDirect(v32, (v30 * v29), &callbacks)) == 0)
                        {
                          free(v32);
                          return 0;
                        }
                        int v36 = v35;
                        CFStringRef v37 = (const __CFString *)*MEMORY[0x1E4F1DC00];
                        CGColorSpaceRef v38 = (CGColorSpaceRef)&unk_1ED4DFD58;
                        CGColorSpaceRef v39 = CGColorSpaceCreateWithName(v37);
                        CGImageRef v33 = CGImageCreate(v28, v30, 8uLL, 8uLL, v29, v39, 0, v36, 0, 0, kCGRenderingIntentDefault);
                        if (v33)
                        {
                          CGImageSetProperty();
                          CGImageSetProperty();
                          CGImageSetProperty();
                        }
                        CGDataProviderRelease(v36);
                        IIOColorSpace::~IIOColorSpace(&v38);
                        return v33;
                      }
                    }
                  }
                  return 0;
                }
              }
            }
            return 0;
          }
        }
      }
      return 0;
    }
  }
  return 0;
}

void sub_188713A64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)va);
  _Unwind_Resume(a1);
}

size_t getBytesAtPosition(char *a1, void *__dst, uint64_t a3, size_t __n)
{
  return __n;
}

size_t (*_cg_TIFFSetErrorHandler(size_t (*a1)(const char *a1, char *a2, va_list a3)))(const char *a1, char *a2, va_list a3)
{
  CFComparisonResult v1 = _TIFFerrorHandler;
  _TIFFerrorHandler = a1;
  return v1;
}

void *_cg_TIFFSetErrorHandlerExt(void *a1)
{
  CFComparisonResult v1 = _TIFFerrorHandlerExt;
  _TIFFerrorHandlerExt = a1;
  return v1;
}

uint64_t TIFFErrorExt(uint64_t result, const char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11 = result;
  if (_TIFFerrorHandler) {
    uint64_t result = _TIFFerrorHandler(a2, a3, &a9);
  }
  if (_TIFFerrorHandlerExt) {
    return _TIFFerrorHandlerExt(v11, a2, a3, &a9);
  }
  return result;
}

void *_TIFFErrorEarly(void *result, uint64_t a2, const char *a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!result
    || !*result
    || (uint64_t result = (void *)((uint64_t (*)(void, void, const char *, char *, char *))*result)(0, result[1], a3, a4, &a9), !result))
  {
    if (_TIFFerrorHandler) {
      uint64_t result = (void *)_TIFFerrorHandler(a3, a4, &a9);
    }
    if (_TIFFerrorHandlerExt) {
      return (void *)_TIFFerrorHandlerExt(a2, a3, a4, &a9);
    }
  }
  return result;
}

uint64_t TIFFErrorExtR(uint64_t result, const char *a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11 = result;
  if (!result
    || !*(void *)(result + 1328)
    || (uint64_t result = (*(uint64_t (**)(uint64_t, void, const char *, char *, char *))(result + 1328))(result, *(void *)(result + 1336), a2, a3, &a9), !result))
  {
    if (_TIFFerrorHandler) {
      uint64_t result = _TIFFerrorHandler(a2, a3, &a9);
    }
    if (_TIFFerrorHandlerExt)
    {
      if (v11) {
        uint64_t v12 = *(void *)(v11 + 1200);
      }
      else {
        uint64_t v12 = 0;
      }
      return ((uint64_t (*)(uint64_t, const char *, char *, char *))_TIFFerrorHandlerExt)(v12, a2, a3, &a9);
    }
  }
  return result;
}

uint64_t NotConfigured(uint64_t a1)
{
  *(void *)(a1 + 952) = _notConfigured;
  *(_DWORD *)(a1 + 944) = 0;
  *(void *)(a1 + 960) = _notConfigured;
  *(_DWORD *)(a1 + 984) = 0;
  *(void *)(a1 + 97jp2_colour_converter::clear(this + 6) = _notConfigured;
  return 1;
}

char **_cg_TIFFIsCODECConfigured(int a1)
{
  uint64_t result = _cg_TIFFFindCODEC(a1);
  if (result)
  {
    unsigned int v2 = (uint64_t (*)(uint64_t))result[2];
    if (v2) {
      return (char **)(v2 != NotConfigured);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t _notConfigured(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unsigned int v2 = _cg_TIFFFindCODEC(*(unsigned __int16 *)(a1 + 120));
  *(void *)__str = 0;
  uint64_t v11 = 0;
  int v12 = 0;
  CFTypeRef v3 = __str;
  snprintf(__str, 0x14uLL, "%hu", *(unsigned __int16 *)(a1 + 120));
  if (v2) {
    CFTypeRef v3 = *v2;
  }
  TIFFErrorExtR(a1, *(const char **)a1, "%s compression support is not configured", v4, v5, v6, v7, v8, (char)v3);
  return 0;
}

uint64_t CGImageCreateByConvertingExtendedSRGBToColorspace(CGImage *a1, CGColorSpace *a2, IIODictionary *a3)
{
  if ((gIIODebugFlags & 0x400000000) != 0) {
    ImageIOLog("    %s\n", "CGImageCreateByConvertingExtendedSRGBToColorspace");
  }
  double Current = CFAbsoluteTimeGetCurrent();
  uint64_t v5 = (const __CFString **)MEMORY[0x1E4F1DB90];
  if (CGImageCreateByConvertingExtendedSRGBToColorspace(CGImage *,CGColorSpace *,IIODictionary *)::gUseColorConversionCA) {
    goto LABEL_40;
  }
  if (IIOIsAppSuspended())
  {
    CGImageCreateByConvertingExtendedSRGBToColorspace(CGImage *,CGColorSpace *,IIODictionary *)::gUseColorConversionCA = 1;
    goto LABEL_40;
  }
  if (CGImageCreateByConvertingExtendedSRGBToColorspace(CGImage *,CGColorSpace *,IIODictionary *)::gUseColorConversionCA) {
    goto LABEL_40;
  }
  unsigned int v6 = 1111970369;
  size_t Width = CGImageGetWidth(a1);
  size_t Height = CGImageGetHeight(a1);
  if (a3)
  {
    if (IIODictionary::containsKey(a3, @"Depth"))
    {
      signed int Uint32ForKey = IIODictionary::getUint32ForKey(a3, @"Depth");
      unsigned int v6 = Uint32ForKey == 16 ? 1380411457 : 1111970369;
    }
    else
    {
      signed int Uint32ForKey = 8;
    }
    CFDataRef ObjectForKey = IIODictionary::getObjectForKey(a3, @"backgroundColor");
  }
  else
  {
    CFDataRef ObjectForKey = 0;
    signed int Uint32ForKey = 8;
  }
  IOSurfaceWithFormat = IIO_CreateIOSurfaceWithFormat(Width, Height, (Width * 4 * (Uint32ForKey / 8) + 15) & 0xFFFFFFFFFFFFFFF0, v6, 1, 0);
  if (!IOSurfaceWithFormat)
  {
LABEL_40:
    ColorSpace = CGImageGetColorSpace(a1);
    CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(a1);
    if (AlphaInfo) {
      int v31 = AlphaInfo;
    }
    else {
      int v31 = 5;
    }
    if (AlphaInfo) {
      uint32_t v32 = 64;
    }
    else {
      uint32_t v32 = 48;
    }
    v55.colorSpace = ColorSpace;
    v55.bitmapInfo = AlphaInfo | 0x1100;
    memset(&v55.version, 0, 20);
    *(void *)&v54.bitsPerComponent = 0x4000000010;
    v54.colorSpace = a2;
    v54.bitmapInfo = v31 | 0x1100;
    memset(&v54.version, 0, 20);
    v55.bitsPerComponent = 16;
    v55.bitsPerPixel = v32;
    CFStringRef v33 = (const __CFString *)*MEMORY[0x1E4F1DC98];
    uint64_t v52 = &unk_1ED4DFD58;
    CGColorSpaceRef v53 = 0;
    CGColorSpaceRef v53 = CGColorSpaceCreateWithName(v33);
    CFStringRef v34 = *v5;
    int v50 = &unk_1ED4DFD58;
    size_t v51 = 0;
    size_t v51 = CGColorSpaceCreateWithName(v34);
    operator new();
  }
  int v12 = IOSurfaceWithFormat;
  CFStringRef v13 = *v5;
  dest.data = &unk_1ED4DFD58;
  dest.vImagePixelCount height = (vImagePixelCount)CGColorSpaceCreateWithName(v13);
  IIO_IOSurfaceAddColorSpace(v12, (CGColorSpaceRef)dest.height);
  IOSurfaceContext = (CGContext *)IIO_CreateIOSurfaceContext(v12, (CGColorSpace *)dest.height);
  int v15 = IOSurfaceContext;
  if (!IOSurfaceContext) {
    goto LABEL_22;
  }
  if (ObjectForKey)
  {
    CGContextSetFillColorWithColor(IOSurfaceContext, ObjectForKey);
    double v16 = (double)Width;
    double v17 = (double)Height;
    v56.origin.CGFloat x = 0.0;
    v56.origin.CGFloat y = 0.0;
    v56.size.vImagePixelCount width = (double)Width;
    v56.size.vImagePixelCount height = (double)Height;
    CGContextFillRect(v15, v56);
  }
  else
  {
    CGContextClear();
    double v16 = (double)Width;
    double v17 = (double)Height;
  }
  v57.origin.CGFloat x = 0.0;
  v57.origin.CGFloat y = 0.0;
  v57.size.vImagePixelCount width = v16;
  v57.size.vImagePixelCount height = v17;
  CGContextDrawImage(v15, v57, a1);
  CGContextFlush(v15);
  memset(&v55, 0, 24);
  IIODictionary::IIODictionary((IIODictionary *)&v55);
  CGImageAlphaInfo v18 = CGImageGetAlphaInfo(a1);
  IIONumber::IIONumber((IIONumber *)&v54, v18);
  IIODictionary::setObjectForKey((uint64_t)&v55, (uint64_t)&v54, @"CGImageAlphaInfo");
  IIONumber::~IIONumber((IIONumber *)&v54);
  uint64_t v19 = CGImageCreateFromIOSurface(v12, v55.colorSpace);
  CGContextRelease(v15);
  IIODictionary::~IIODictionary((IIODictionary *)&v55);
  if (!v19)
  {
LABEL_22:
    uint64_t v20 = MEMORY[0x1E4F14390];
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 4 * HIBYTE(v6) + 60) & 0x40000) != 0) {
      uint64_t v21 = HIBYTE(v6);
    }
    else {
      uint64_t v21 = 46;
    }
    unsigned int v22 = (int)(v6 << 8) >> 24;
    if (((v6 << 8) & 0x80000000) != 0) {
      int v23 = __maskrune((int)(v6 << 8) >> 24, 0x40000uLL);
    }
    else {
      int v23 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v22 + 60) & 0x40000;
    }
    if (v23) {
      uint64_t v24 = v22;
    }
    else {
      uint64_t v24 = 46;
    }
    unsigned int v25 = (__int16)v6 >> 8;
    if (((v6 << 16) & 0x80000000) != 0) {
      int v26 = __maskrune((__int16)v6 >> 8, 0x40000uLL);
    }
    else {
      int v26 = *(_DWORD *)(v20 + 4 * v25 + 60) & 0x40000;
    }
    if (v26) {
      uint64_t v27 = v25;
    }
    else {
      uint64_t v27 = 46;
    }
    uint64_t v28 = 65;
    if ((*(_DWORD *)(v20 + 320) & 0x40000) == 0) {
      uint64_t v28 = 46;
    }
    _cg_jpeg_mem_term("CGImageCreateByConvertingExtendedSRGBToColorspace_CA", 170, "CGImageCreateFromIOSurface failed to create a CGImage from a '%c%c%c%c' surface\n", v21, v24, v27, v28);
    IIO_IOSurfaceRelease(v12);
    IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)&dest);
    goto LABEL_40;
  }
  CFRelease(v12);
  IIOColorSpace::~IIOColorSpace((CGColorSpaceRef *)&dest);
  uint64_t v35 = gIIODebugFlags;
  if ((gIIODebugFlags & 0x20000000000) != 0)
  {
    double v36 = (CFAbsoluteTimeGetCurrent() - Current) * 1000.0;
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 328) & 0x40000) != 0) {
      uint64_t v37 = 67;
    }
    else {
      uint64_t v37 = 46;
    }
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 320) & 0x40000) != 0) {
      uint64_t v38 = 65;
    }
    else {
      uint64_t v38 = 46;
    }
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 188) & 0x40000) != 0) {
      uint64_t v39 = 32;
    }
    else {
      uint64_t v39 = 46;
    }
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 188) & 0x40000) != 0) {
      uint64_t v40 = 32;
    }
    else {
      uint64_t v40 = 46;
    }
    ImageIOLog("    CGImageCreateByConvertingExtendedSRGBToColorspace - %g ms [%c%c%c%c]\n", v36, v37, v38, v39, v40);
    uint64_t v35 = gIIODebugFlags;
  }
  if ((v35 & 0x8000300000) != 0)
  {
    double v41 = (CFAbsoluteTimeGetCurrent() - Current) * 1000.0;
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 328) & 0x40000) != 0) {
      uint64_t v42 = 67;
    }
    else {
      uint64_t v42 = 46;
    }
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 320) & 0x40000) != 0) {
      uint64_t v43 = 65;
    }
    else {
      uint64_t v43 = 46;
    }
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 188) & 0x40000) != 0) {
      uint64_t v44 = 32;
    }
    else {
      uint64_t v44 = 46;
    }
    if ((*(_DWORD *)(MEMORY[0x1E4F14390] + 188) & 0x40000) != 0) {
      uint64_t v45 = 32;
    }
    else {
      uint64_t v45 = 46;
    }
    ImageIOLog("COL %s - time: %gms [%c%c%c%c]\n", "CGImageCreateByConvertingExtendedSRGBToColorspace", v41, v42, v43, v44, v45);
  }
  return v19;
}