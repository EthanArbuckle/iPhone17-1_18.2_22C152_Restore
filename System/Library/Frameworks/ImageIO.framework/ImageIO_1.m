const char *IIOLoadCoreVideoSymbols(void)
{
  void *v0;
  void *v1;
  char *v2;
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  char *v31;
  char *v32;
  char *v33;
  char *v34;
  char *v35;
  char *v36;
  char *v37;
  char *v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  char *v44;
  char *v45;
  char *v46;
  char *v47;
  char *v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  char *v57;
  char *v58;
  char *v59;
  char *v60;
  char *v61;
  char *v62;
  char *v63;
  char *v64;
  char *v65;
  char *v66;
  char *v67;
  char *v68;
  char *v69;
  char *v70;
  char *v71;
  char *v72;
  char *v73;
  char *v74;
  char *v75;
  char *v76;
  char *v77;
  char *v78;
  char *v79;
  char *v80;
  char *v81;
  const char *result;
  char *v83;
  char *v84;
  char __path[72];
  uint64_t v86;

  v86 = *MEMORY[0x1E4F143B8];
  strcpy(__path, "/System/Library/Frameworks/CoreVideo.framework/CoreVideo");
  v0 = dlopen(__path, 257);
  if (v0)
  {
    v1 = v0;
    gFunc_CVPixelBufferCreateWithBytes = dlsym(v0, "CVPixelBufferCreateWithBytes");
    if (!gFunc_CVPixelBufferCreateWithBytes)
    {
      v2 = dlerror();
      printf("❌  failed to load 'CVPixelBufferCreateWithBytes' [%s]\n", v2);
    }
    gFunc_CVPixelBufferRelease = (__n128 (*)(__n128))dlsym(v1, "CVPixelBufferRelease");
    if (!gFunc_CVPixelBufferRelease)
    {
      v3 = dlerror();
      printf("❌  failed to load 'CVPixelBufferRelease' [%s]\n", v3);
    }
    gFunc_CVPixelBufferRelease = (__n128 (*)(__n128))dlsym(v1, "CVPixelBufferRelease");
    if (!gFunc_CVPixelBufferRelease)
    {
      v4 = dlerror();
      printf("❌  failed to load 'CVPixelBufferRelease' [%s]\n", v4);
    }
    gFunc_CVPixelBufferLockBaseAddress = (uint64_t (*)(void, void))dlsym(v1, "CVPixelBufferLockBaseAddress");
    if (!gFunc_CVPixelBufferLockBaseAddress)
    {
      v5 = dlerror();
      printf("❌  failed to load 'CVPixelBufferLockBaseAddress' [%s]\n", v5);
    }
    gFunc_CVPixelBufferUnlockBaseAddress = (double (*)(void, void, __n128))dlsym(v1, "CVPixelBufferUnlockBaseAddress");
    if (!gFunc_CVPixelBufferUnlockBaseAddress)
    {
      v6 = dlerror();
      printf("❌  failed to load 'CVPixelBufferUnlockBaseAddress' [%s]\n", v6);
    }
    gFunc_CVPixelBufferGetWidth = (uint64_t (*)(void))dlsym(v1, "CVPixelBufferGetWidth");
    if (!gFunc_CVPixelBufferGetWidth)
    {
      v7 = dlerror();
      printf("❌  failed to load 'CVPixelBufferGetWidth' [%s]\n", v7);
    }
    gFunc_CVPixelBufferGetHeight = (uint64_t (*)(void))dlsym(v1, "CVPixelBufferGetHeight");
    if (!gFunc_CVPixelBufferGetHeight)
    {
      v8 = dlerror();
      printf("❌  failed to load 'CVPixelBufferGetHeight' [%s]\n", v8);
    }
    gFunc_CVPixelBufferGetIOSurface = (uint64_t (*)(void))dlsym(v1, "CVPixelBufferGetIOSurface");
    if (!gFunc_CVPixelBufferGetIOSurface)
    {
      v9 = dlerror();
      printf("❌  failed to load 'CVPixelBufferGetIOSurface' [%s]\n", v9);
    }
    gFunc_CVPixelBufferGetPixelFormatType = (uint64_t (*)(void))dlsym(v1, "CVPixelBufferGetPixelFormatType");
    if (!gFunc_CVPixelBufferGetPixelFormatType)
    {
      v10 = dlerror();
      printf("❌  failed to load 'CVPixelBufferGetPixelFormatType' [%s]\n", v10);
    }
    gFunc_CVPixelBufferGetBaseAddress = (uint64_t (*)(void))dlsym(v1, "CVPixelBufferGetBaseAddress");
    if (!gFunc_CVPixelBufferGetBaseAddress)
    {
      v11 = dlerror();
      printf("❌  failed to load 'CVPixelBufferGetBaseAddress' [%s]\n", v11);
    }
    gFunc_CVPixelBufferGetBytesPerRow = (uint64_t (*)(void))dlsym(v1, "CVPixelBufferGetBytesPerRow");
    if (!gFunc_CVPixelBufferGetBytesPerRow)
    {
      v12 = dlerror();
      printf("❌  failed to load 'CVPixelBufferGetBytesPerRow' [%s]\n", v12);
    }
    gFunc_CVPixelBufferGetDataSize = (uint64_t)dlsym(v1, "CVPixelBufferGetDataSize");
    if (!gFunc_CVPixelBufferGetDataSize)
    {
      v13 = dlerror();
      printf("❌  failed to load 'CVPixelBufferGetDataSize' [%s]\n", v13);
    }
    gFunc_CVPixelBufferIsPlanar = (uint64_t (*)(void))dlsym(v1, "CVPixelBufferIsPlanar");
    if (!gFunc_CVPixelBufferIsPlanar)
    {
      v14 = dlerror();
      printf("❌  failed to load 'CVPixelBufferIsPlanar' [%s]\n", v14);
    }
    gFunc_CVBufferSetAttachment = (uint64_t (*)(void, void, void, void))dlsym(v1, "CVBufferSetAttachment");
    if (!gFunc_CVBufferSetAttachment)
    {
      v15 = dlerror();
      printf("❌  failed to load 'CVBufferSetAttachment' [%s]\n", v15);
    }
    gFunc_CVPixelBufferCreateWithIOSurface = (uint64_t (*)(void, void, void, void))dlsym(v1, "CVPixelBufferCreateWithIOSurface");
    if (!gFunc_CVPixelBufferCreateWithIOSurface)
    {
      v16 = dlerror();
      printf("❌  failed to load 'CVPixelBufferCreateWithIOSurface' [%s]\n", v16);
    }
    gFunc_CVBufferCopyAttachment = dlsym(v1, "CVBufferCopyAttachment");
    if (!gFunc_CVBufferCopyAttachment)
    {
      v17 = dlerror();
      printf("❌  failed to load 'CVBufferCopyAttachment' [%s]\n", v17);
    }
    gFunc_CVBufferCopyAttachments = dlsym(v1, "CVBufferCopyAttachments");
    if (!gFunc_CVBufferCopyAttachments)
    {
      v18 = dlerror();
      printf("❌  failed to load 'CVBufferCopyAttachments' [%s]\n", v18);
    }
    gFunc_CVImageBufferCreateColorSpaceFromAttachments = dlsym(v1, "CVImageBufferCreateColorSpaceFromAttachments");
    if (!gFunc_CVImageBufferCreateColorSpaceFromAttachments)
    {
      v19 = dlerror();
      printf("❌  failed to load 'CVImageBufferCreateColorSpaceFromAttachments' [%s]\n", v19);
    }
    gFunc_CVImageBufferGetColorSpace = (uint64_t)dlsym(v1, "CVImageBufferGetColorSpace");
    if (!gFunc_CVImageBufferGetColorSpace)
    {
      v20 = dlerror();
      printf("❌  failed to load 'CVImageBufferGetColorSpace' [%s]\n", v20);
    }
    gFunc_CVImageBufferSetColorSpace = (uint64_t (*)(void, void))dlsym(v1, "CVImageBufferSetColorSpace");
    if (!gFunc_CVImageBufferSetColorSpace)
    {
      v21 = dlerror();
      printf("❌  failed to load 'CVImageBufferSetColorSpace' [%s]\n", v21);
    }
    gFunc_CVMetalTextureCacheCreate = dlsym(v1, "CVMetalTextureCacheCreate");
    if (!gFunc_CVMetalTextureCacheCreate)
    {
      v22 = dlerror();
      printf("❌  failed to load 'CVMetalTextureCacheCreate' [%s]\n", v22);
    }
    gFunc_CVMetalTextureCacheCreateTextureFromImage = dlsym(v1, "CVMetalTextureCacheCreateTextureFromImage");
    if (!gFunc_CVMetalTextureCacheCreateTextureFromImage)
    {
      v23 = dlerror();
      printf("❌  failed to load 'CVMetalTextureCacheCreateTextureFromImage' [%s]\n", v23);
    }
    gFunc_CVMetalTextureGetTexture = dlsym(v1, "CVMetalTextureGetTexture");
    if (!gFunc_CVMetalTextureGetTexture)
    {
      v24 = dlerror();
      printf("❌  failed to load 'CVMetalTextureGetTexture' [%s]\n", v24);
    }
    gFunc_CVPixelBufferGetHeightOfPlane = dlsym(v1, "CVPixelBufferGetHeightOfPlane");
    if (!gFunc_CVPixelBufferGetHeightOfPlane)
    {
      v25 = dlerror();
      printf("❌  failed to load 'CVPixelBufferGetHeightOfPlane' [%s]\n", v25);
    }
    gFunc_CVPixelBufferGetWidthOfPlane = dlsym(v1, "CVPixelBufferGetWidthOfPlane");
    if (!gFunc_CVPixelBufferGetWidthOfPlane)
    {
      v26 = dlerror();
      printf("❌  failed to load 'CVPixelBufferGetWidthOfPlane' [%s]\n", v26);
    }
    gFunc_CVPixelBufferGetBytesPerRowOfPlane = dlsym(v1, "CVPixelBufferGetBytesPerRowOfPlane");
    if (!gFunc_CVPixelBufferGetBytesPerRowOfPlane)
    {
      v27 = dlerror();
      printf("❌  failed to load 'CVPixelBufferGetBytesPerRowOfPlane' [%s]\n", v27);
    }
    gFunc_CVPixelBufferGetBaseAddressOfPlane = dlsym(v1, "CVPixelBufferGetBaseAddressOfPlane");
    if (!gFunc_CVPixelBufferGetBaseAddressOfPlane)
    {
      v28 = dlerror();
      printf("❌  failed to load 'CVPixelBufferGetBaseAddressOfPlane' [%s]\n", v28);
    }
    gFunc_CVPixelBufferRetain = dlsym(v1, "CVPixelBufferRetain");
    if (!gFunc_CVPixelBufferRetain)
    {
      v29 = dlerror();
      printf("❌  failed to load 'CVPixelBufferRetain' [%s]\n", v29);
    }
    gFunc_CVPixelFormatDescriptionCreateWithPixelFormatType = (uint64_t (*)(void, void))dlsym(v1, "CVPixelFormatDescriptionCreateWithPixelFormatType");
    if (!gFunc_CVPixelFormatDescriptionCreateWithPixelFormatType)
    {
      v30 = dlerror();
      printf("❌  failed to load 'CVPixelFormatDescriptionCreateWithPixelFormatType' [%s]\n", v30);
    }
    gFunc_CVColorPrimariesGetStringForIntegerCodePoint = dlsym(v1, "CVColorPrimariesGetStringForIntegerCodePoint");
    if (!gFunc_CVColorPrimariesGetStringForIntegerCodePoint)
    {
      v31 = dlerror();
      printf("❌  failed to load 'CVColorPrimariesGetStringForIntegerCodePoint' [%s]\n", v31);
    }
    gFunc_CVTransferFunctionGetStringForIntegerCodePoint = dlsym(v1, "CVTransferFunctionGetStringForIntegerCodePoint");
    if (!gFunc_CVTransferFunctionGetStringForIntegerCodePoint)
    {
      v32 = dlerror();
      printf("❌  failed to load 'CVTransferFunctionGetStringForIntegerCodePoint' [%s]\n", v32);
    }
    gFunc_CVYCbCrMatrixGetStringForIntegerCodePoint = dlsym(v1, "CVYCbCrMatrixGetStringForIntegerCodePoint");
    if (!gFunc_CVYCbCrMatrixGetStringForIntegerCodePoint)
    {
      v33 = dlerror();
      printf("❌  failed to load 'CVYCbCrMatrixGetStringForIntegerCodePoint' [%s]\n", v33);
    }
    gFunc_CVYCbCrMatrixGetIntegerCodePointForString = dlsym(v1, "CVYCbCrMatrixGetIntegerCodePointForString");
    if (!gFunc_CVYCbCrMatrixGetIntegerCodePointForString)
    {
      v34 = dlerror();
      printf("❌  failed to load 'CVYCbCrMatrixGetIntegerCodePointForString' [%s]\n", v34);
    }
    gIIO_kCVImageBufferAlphaChannelIsOpaque = (uint64_t)dlsym(v1, "kCVImageBufferAlphaChannelIsOpaque");
    if (!gIIO_kCVImageBufferAlphaChannelIsOpaque)
    {
      v35 = dlerror();
      printf("❌  failed to load 'kCVImageBufferAlphaChannelIsOpaque' [%s]\n", v35);
    }
    gIIO_kCVImageBufferAlphaChannelModeKey = (uint64_t)dlsym(v1, "kCVImageBufferAlphaChannelModeKey");
    if (!gIIO_kCVImageBufferAlphaChannelModeKey)
    {
      v36 = dlerror();
      printf("❌  failed to load 'kCVImageBufferAlphaChannelModeKey' [%s]\n", v36);
    }
    gIIO_kCVImageBufferAlphaChannelMode_StraightAlpha = (uint64_t)dlsym(v1, "kCVImageBufferAlphaChannelMode_StraightAlpha");
    if (!gIIO_kCVImageBufferAlphaChannelMode_StraightAlpha)
    {
      v37 = dlerror();
      printf("❌  failed to load 'kCVImageBufferAlphaChannelMode_StraightAlpha' [%s]\n", v37);
    }
    gIIO_kCVImageBufferAlphaChannelMode_PremultipliedAlpha = (uint64_t)dlsym(v1, "kCVImageBufferAlphaChannelMode_PremultipliedAlpha");
    if (!gIIO_kCVImageBufferAlphaChannelMode_PremultipliedAlpha)
    {
      v38 = dlerror();
      printf("❌  failed to load 'kCVImageBufferAlphaChannelMode_PremultipliedAlpha' [%s]\n", v38);
    }
    gIIO_kCVImageBufferCGColorSpaceKey = (uint64_t)dlsym(v1, "kCVImageBufferCGColorSpaceKey");
    if (!gIIO_kCVImageBufferCGColorSpaceKey)
    {
      v39 = dlerror();
      printf("❌  failed to load 'kCVImageBufferCGColorSpaceKey' [%s]\n", v39);
    }
    gIIO_kCVPixelBufferPixelFormatTypeKey = (uint64_t)dlsym(v1, "kCVPixelBufferPixelFormatTypeKey");
    if (!gIIO_kCVPixelBufferPixelFormatTypeKey)
    {
      v40 = dlerror();
      printf("❌  failed to load 'kCVPixelBufferPixelFormatTypeKey' [%s]\n", v40);
    }
    gIIO_kCVPixelBufferPixelFormatDescriptionKey = (uint64_t)dlsym(v1, "kCVPixelBufferPixelFormatDescriptionKey");
    if (!gIIO_kCVPixelBufferPixelFormatDescriptionKey)
    {
      v41 = dlerror();
      printf("❌  failed to load 'kCVPixelBufferPixelFormatDescriptionKey' [%s]\n", v41);
    }
    gIIO_kCVPixelFormatConstant = (uint64_t)dlsym(v1, "kCVPixelFormatConstant");
    if (!gIIO_kCVPixelFormatConstant)
    {
      v42 = dlerror();
      printf("❌  failed to load 'kCVPixelFormatConstant' [%s]\n", v42);
    }
    gIIO_kCVPixelFormatBitsPerBlock = (uint64_t)dlsym(v1, "kCVPixelFormatBitsPerBlock");
    if (!gIIO_kCVPixelFormatBitsPerBlock)
    {
      v43 = dlerror();
      printf("❌  failed to load 'kCVPixelFormatBitsPerBlock' [%s]\n", v43);
    }
    gIIO_kCVPixelBufferWidthKey = (uint64_t)dlsym(v1, "kCVPixelBufferWidthKey");
    if (!gIIO_kCVPixelBufferWidthKey)
    {
      v44 = dlerror();
      printf("❌  failed to load 'kCVPixelBufferWidthKey' [%s]\n", v44);
    }
    gIIO_kCVPixelBufferHeightKey = (uint64_t)dlsym(v1, "kCVPixelBufferHeightKey");
    if (!gIIO_kCVPixelBufferHeightKey)
    {
      v45 = dlerror();
      printf("❌  failed to load 'kCVPixelBufferHeightKey' [%s]\n", v45);
    }
    gIIO_kCVPixelBufferBytesPerRowAlignmentKey = (uint64_t)dlsym(v1, "kCVPixelBufferBytesPerRowAlignmentKey");
    if (!gIIO_kCVPixelBufferBytesPerRowAlignmentKey)
    {
      v46 = dlerror();
      printf("❌  failed to load 'kCVPixelBufferBytesPerRowAlignmentKey' [%s]\n", v46);
    }
    gIIO_kCVImageBufferYCbCrMatrixKey = (uint64_t)dlsym(v1, "kCVImageBufferYCbCrMatrixKey");
    if (!gIIO_kCVImageBufferYCbCrMatrixKey)
    {
      v47 = dlerror();
      printf("❌  failed to load 'kCVImageBufferYCbCrMatrixKey' [%s]\n", v47);
    }
    gIIO_kCVImageBufferYCbCrMatrix_ITU_R_2020 = (uint64_t)dlsym(v1, "kCVImageBufferYCbCrMatrix_ITU_R_2020");
    if (!gIIO_kCVImageBufferYCbCrMatrix_ITU_R_2020)
    {
      v48 = dlerror();
      printf("❌  failed to load 'kCVImageBufferYCbCrMatrix_ITU_R_2020' [%s]\n", v48);
    }
    gIIO_kCVImageBufferYCbCrMatrix_ITU_R_601_4 = (uint64_t)dlsym(v1, "kCVImageBufferYCbCrMatrix_ITU_R_601_4");
    if (!gIIO_kCVImageBufferYCbCrMatrix_ITU_R_601_4)
    {
      v49 = dlerror();
      printf("❌  failed to load 'kCVImageBufferYCbCrMatrix_ITU_R_601_4' [%s]\n", v49);
    }
    gIIO_kCVImageBufferYCbCrMatrix_ITU_R_709_2 = (uint64_t)dlsym(v1, "kCVImageBufferYCbCrMatrix_ITU_R_709_2");
    if (!gIIO_kCVImageBufferYCbCrMatrix_ITU_R_709_2)
    {
      v50 = dlerror();
      printf("❌  failed to load 'kCVImageBufferYCbCrMatrix_ITU_R_709_2' [%s]\n", v50);
    }
    gIIO_kCVPixelFormatContainsRGB = (uint64_t)dlsym(v1, "kCVPixelFormatContainsRGB");
    if (!gIIO_kCVPixelFormatContainsRGB)
    {
      v51 = dlerror();
      printf("❌  failed to load 'kCVPixelFormatContainsRGB' [%s]\n", v51);
    }
    gIIO_kCVPixelFormatContainsYCbCr = (uint64_t)dlsym(v1, "kCVPixelFormatContainsYCbCr");
    if (!gIIO_kCVPixelFormatContainsYCbCr)
    {
      v52 = dlerror();
      printf("❌  failed to load 'kCVPixelFormatContainsYCbCr' [%s]\n", v52);
    }
    gIIO_kCVPixelFormatContainsGrayscale = (uint64_t)dlsym(v1, "kCVPixelFormatContainsGrayscale");
    if (!gIIO_kCVPixelFormatContainsGrayscale)
    {
      v53 = dlerror();
      printf("❌  failed to load 'kCVPixelFormatContainsGrayscale' [%s]\n", v53);
    }
    gIIO_kCVPixelFormatHorizontalSubsampling = (uint64_t)dlsym(v1, "kCVPixelFormatHorizontalSubsampling");
    if (!gIIO_kCVPixelFormatHorizontalSubsampling)
    {
      v54 = dlerror();
      printf("❌  failed to load 'kCVPixelFormatHorizontalSubsampling' [%s]\n", v54);
    }
    gIIO_kCVPixelFormatVerticalSubsampling = (uint64_t)dlsym(v1, "kCVPixelFormatVerticalSubsampling");
    if (!gIIO_kCVPixelFormatVerticalSubsampling)
    {
      v55 = dlerror();
      printf("❌  failed to load 'kCVPixelFormatVerticalSubsampling' [%s]\n", v55);
    }
    gIIO_kCVImageBufferAmbientViewingEnvironmentKey = (uint64_t)dlsym(v1, "kCVImageBufferAmbientViewingEnvironmentKey");
    if (!gIIO_kCVImageBufferAmbientViewingEnvironmentKey)
    {
      v56 = dlerror();
      printf("❌  failed to load 'kCVImageBufferAmbientViewingEnvironmentKey' [%s]\n", v56);
    }
    gIIO_kCVImageBufferChromaLocationBottomFieldKey = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocationBottomFieldKey");
    if (!gIIO_kCVImageBufferChromaLocationBottomFieldKey)
    {
      v57 = dlerror();
      printf("❌  failed to load 'kCVImageBufferChromaLocationBottomFieldKey' [%s]\n", v57);
    }
    gIIO_kCVImageBufferChromaLocationTopFieldKey = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocationTopFieldKey");
    if (!gIIO_kCVImageBufferChromaLocationTopFieldKey)
    {
      v58 = dlerror();
      printf("❌  failed to load 'kCVImageBufferChromaLocationTopFieldKey' [%s]\n", v58);
    }
    gIIO_kCVImageBufferChromaLocation_Bottom = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocation_Bottom");
    if (!gIIO_kCVImageBufferChromaLocation_Bottom)
    {
      v59 = dlerror();
      printf("❌  failed to load 'kCVImageBufferChromaLocation_Bottom' [%s]\n", v59);
    }
    gIIO_kCVImageBufferChromaLocation_BottomLeft = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocation_BottomLeft");
    if (!gIIO_kCVImageBufferChromaLocation_BottomLeft)
    {
      v60 = dlerror();
      printf("❌  failed to load 'kCVImageBufferChromaLocation_BottomLeft' [%s]\n", v60);
    }
    gIIO_kCVImageBufferChromaLocation_Center = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocation_Center");
    if (!gIIO_kCVImageBufferChromaLocation_Center)
    {
      v61 = dlerror();
      printf("❌  failed to load 'kCVImageBufferChromaLocation_Center' [%s]\n", v61);
    }
    gIIO_kCVImageBufferChromaLocation_DV420 = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocation_DV420");
    if (!gIIO_kCVImageBufferChromaLocation_DV420)
    {
      v62 = dlerror();
      printf("❌  failed to load 'kCVImageBufferChromaLocation_DV420' [%s]\n", v62);
    }
    gIIO_kCVImageBufferChromaLocation_Left = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocation_Left");
    if (!gIIO_kCVImageBufferChromaLocation_Left)
    {
      v63 = dlerror();
      printf("❌  failed to load 'kCVImageBufferChromaLocation_Left' [%s]\n", v63);
    }
    gIIO_kCVImageBufferChromaLocation_Top = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocation_Top");
    if (!gIIO_kCVImageBufferChromaLocation_Top)
    {
      v64 = dlerror();
      printf("❌  failed to load 'kCVImageBufferChromaLocation_Top' [%s]\n", v64);
    }
    gIIO_kCVImageBufferChromaLocation_TopLeft = (uint64_t)dlsym(v1, "kCVImageBufferChromaLocation_TopLeft");
    if (!gIIO_kCVImageBufferChromaLocation_TopLeft)
    {
      v65 = dlerror();
      printf("❌  failed to load 'kCVImageBufferChromaLocation_TopLeft' [%s]\n", v65);
    }
    gIIO_kCVImageBufferChromaSubsamplingKey = (uint64_t)dlsym(v1, "kCVImageBufferChromaSubsamplingKey");
    if (!gIIO_kCVImageBufferChromaSubsamplingKey)
    {
      v66 = dlerror();
      printf("❌  failed to load 'kCVImageBufferChromaSubsamplingKey' [%s]\n", v66);
    }
    gIIO_kCVImageBufferChromaSubsampling_411 = (uint64_t)dlsym(v1, "kCVImageBufferChromaSubsampling_411");
    if (!gIIO_kCVImageBufferChromaSubsampling_411)
    {
      v67 = dlerror();
      printf("❌  failed to load 'kCVImageBufferChromaSubsampling_411' [%s]\n", v67);
    }
    gIIO_kCVImageBufferChromaSubsampling_420 = (uint64_t)dlsym(v1, "kCVImageBufferChromaSubsampling_420");
    if (!gIIO_kCVImageBufferChromaSubsampling_420)
    {
      v68 = dlerror();
      printf("❌  failed to load 'kCVImageBufferChromaSubsampling_420' [%s]\n", v68);
    }
    gIIO_kCVImageBufferChromaSubsampling_422 = (uint64_t)dlsym(v1, "kCVImageBufferChromaSubsampling_422");
    if (!gIIO_kCVImageBufferChromaSubsampling_422)
    {
      v69 = dlerror();
      printf("❌  failed to load 'kCVImageBufferChromaSubsampling_422' [%s]\n", v69);
    }
    gIIO_kCVImageBufferColorPrimariesKey = (uint64_t)dlsym(v1, "kCVImageBufferColorPrimariesKey");
    if (!gIIO_kCVImageBufferColorPrimariesKey)
    {
      v70 = dlerror();
      printf("❌  failed to load 'kCVImageBufferColorPrimariesKey' [%s]\n", v70);
    }
    gIIO_kCVImageBufferContentLightLevelInfoKey = (uint64_t)dlsym(v1, "kCVImageBufferContentLightLevelInfoKey");
    if (!gIIO_kCVImageBufferContentLightLevelInfoKey)
    {
      v71 = dlerror();
      printf("❌  failed to load 'kCVImageBufferContentLightLevelInfoKey' [%s]\n", v71);
    }
    gIIO_kCVImageBufferGammaLevelKey = (uint64_t)dlsym(v1, "kCVImageBufferGammaLevelKey");
    if (!gIIO_kCVImageBufferGammaLevelKey)
    {
      v72 = dlerror();
      printf("❌  failed to load 'kCVImageBufferGammaLevelKey' [%s]\n", v72);
    }
    gIIO_kCVImageBufferMasteringDisplayColorVolumeKey = (uint64_t)dlsym(v1, "kCVImageBufferMasteringDisplayColorVolumeKey");
    if (!gIIO_kCVImageBufferMasteringDisplayColorVolumeKey)
    {
      v73 = dlerror();
      printf("❌  failed to load 'kCVImageBufferMasteringDisplayColorVolumeKey' [%s]\n", v73);
    }
    gIIO_kCVImageBufferTransferFunctionKey = (uint64_t)dlsym(v1, "kCVImageBufferTransferFunctionKey");
    if (!gIIO_kCVImageBufferTransferFunctionKey)
    {
      v74 = dlerror();
      printf("❌  failed to load 'kCVImageBufferTransferFunctionKey' [%s]\n", v74);
    }
    gIIO_kCVImageBufferTransferFunction_UseGamma = (uint64_t)dlsym(v1, "kCVImageBufferTransferFunction_UseGamma");
    if (!gIIO_kCVImageBufferTransferFunction_UseGamma)
    {
      v75 = dlerror();
      printf("❌  failed to load 'kCVImageBufferTransferFunction_UseGamma' [%s]\n", v75);
    }
    gIIO_kCVImageBufferTransferFunction_ITU_R_2100_HLG = (uint64_t)dlsym(v1, "kCVImageBufferTransferFunction_ITU_R_2100_HLG");
    if (!gIIO_kCVImageBufferTransferFunction_ITU_R_2100_HLG)
    {
      v76 = dlerror();
      printf("❌  failed to load 'kCVImageBufferTransferFunction_ITU_R_2100_HLG' [%s]\n", v76);
    }
    gIIO_kCVImageBufferTransferFunction_SMPTE_ST_2084_PQ = (uint64_t)dlsym(v1, "kCVImageBufferTransferFunction_SMPTE_ST_2084_PQ");
    if (!gIIO_kCVImageBufferTransferFunction_SMPTE_ST_2084_PQ)
    {
      v77 = dlerror();
      printf("❌  failed to load 'kCVImageBufferTransferFunction_SMPTE_ST_2084_PQ' [%s]\n", v77);
    }
    gIIO_kCVPixelFormatPlanes = (uint64_t)dlsym(v1, "kCVPixelFormatPlanes");
    if (!gIIO_kCVPixelFormatPlanes)
    {
      v78 = dlerror();
      printf("❌  failed to load 'kCVPixelFormatPlanes' [%s]\n", v78);
    }
    gIIO_kCVPixelFormatBitsPerComponent = (uint64_t)dlsym(v1, "kCVPixelFormatBitsPerComponent");
    if (!gIIO_kCVPixelFormatBitsPerComponent)
    {
      v79 = dlerror();
      printf("❌  failed to load 'kCVPixelFormatBitsPerComponent' [%s]\n", v79);
    }
    gIIO_kCVPixelFormatComponentRange = (uint64_t)dlsym(v1, "kCVPixelFormatComponentRange");
    if (!gIIO_kCVPixelFormatComponentRange)
    {
      v80 = dlerror();
      printf("❌  failed to load 'kCVPixelFormatComponentRange' [%s]\n", v80);
    }
    gIIO_kCVPixelFormatComponentRange_FullRange = (uint64_t)dlsym(v1, "kCVPixelFormatComponentRange_FullRange");
    if (!gIIO_kCVPixelFormatComponentRange_FullRange)
    {
      v81 = dlerror();
      printf("❌  failed to load 'kCVPixelFormatComponentRange_FullRange' [%s]\n", v81);
    }
    result = (const char *)dlsym(v1, "kCVPixelFormatComponentRange_VideoRange");
    gIIO_kCVPixelFormatComponentRange_VideoRange = (uint64_t)result;
    if (!result)
    {
      v83 = dlerror();
      return (const char *)printf("❌  failed to load 'kCVPixelFormatComponentRange_VideoRange' [%s]\n", v83);
    }
  }
  else
  {
    v84 = dlerror();
    return LogError("IIOLoadCoreVideoSymbols", 220, "❌  Failed to load %s  [%s]\n", __path, v84);
  }
  return result;
}

BOOL ___Z15AppleEXREnabledv_block_invoke()
{
  BOOL result = IIOLoadAppleOpenExrSymbols();
  if (!result) {
    gAppleEXREnabled = 1;
  }
  return result;
}

void HEIFXMP::~HEIFXMP(HEIFXMP *this)
{
  *(void *)this = &unk_1ED4E5A18;
  JUMPOUT(0x18C11C0E0);
}

{
  *(void *)this = &unk_1ED4E5A18;
}

void IIOImageWriteSession::IIOImageWriteSession(IIOImageWriteSession *this, CFStringRef string)
{
  *(void *)this = &unk_1ED4E4FD8;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_WORD *)this + 36) = 1;
  *((void *)this + 10) = this;
  *((void *)this + 11) = this;
  *((_DWORD *)this + 19) = 0;
  if (!string)
  {
    *((_DWORD *)this + 19) = -50;
    return;
  }
  CFIndex MaximumSizeOfFileSystemRepresentation = CFStringGetMaximumSizeOfFileSystemRepresentation(string);
  v5 = (char *)malloc_type_malloc(MaximumSizeOfFileSystemRepresentation + 6, 0x4FDC185DuLL);
  if (CFStringGetFileSystemRepresentation(string, v5, MaximumSizeOfFileSystemRepresentation) == 1)
  {
    size_t v6 = strlen(v5);
    v7 = (IIOImageWriteSession *)reallocf(v5, v6 + 1);
    if (!v7) {
      return;
    }
    v5 = (char *)v7;
    TempFileName = IIOImageWriteSession::createTempFileName(v7, (char *)v7);
    if (TempFileName)
    {
      v9 = TempFileName;
      v10 = fopen(TempFileName, "w+b");
      *((void *)this + 4) = v10;
      if (v10)
      {
        *((unsigned char *)this + 73) = 1;
        if ((gIIODebugFlags & 0x200000000000) != 0) {
          ImageIOLog(">>> CGImageWriteSessionCreateWithFile: creating FILE* %p\n", v10);
        }
        *((void *)this + 6) = CFStringCreateWithFileSystemRepresentation((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v9);
        *((void *)this + 5) = CFRetain(string);
      }
      else
      {
        *((_DWORD *)this + 19) = *__error();
        int v11 = *__error();
        v12 = __error();
        v13 = strerror(*v12);
        LogError("IIOImageWriteSession", 122, "*** ERROR: cannot create: '%s'\n         error = %d (%s)\n", v9, v11, v13);
      }
      free(v9);
    }
    else
    {
      *((_DWORD *)this + 19) = -37;
    }
    goto LABEL_10;
  }
  *((_DWORD *)this + 19) = -4172;
  if (v5) {
LABEL_10:
  }
    free(v5);
}

char *IIOImageWriteSession::createTempFileName(IIOImageWriteSession *this, char *a2)
{
  if (_xpc_runtime_is_app_sandboxed())
  {
    v3 = (char *)_amkrtemp();
    if (v3) {
      return v3;
    }
    v4 = __error();
    LogWarning("createTempFileName", 496, " _amkrtemp(\"%s\") failed.  errno = %d\n", a2, *v4);
  }
  size_t v5 = strlen(a2);
  v3 = (char *)malloc_type_malloc(v5 + 7, 0x178ABBB0uLL);
  strncpy(v3, a2, v5 + 1);
  if ((_xpc_runtime_is_app_sandboxed() & 1) == 0)
  {
    size_t v6 = strrchr(v3, 47);
    if (v6) {
      v7 = v6 + 1;
    }
    else {
      v7 = v3;
    }
    size_t v8 = strlen(v7);
    memmove(v7 + 1, v7, v8 + 1);
    char *v7 = 46;
    strcat(v3, "-XXXX");
    mktemp(v3);
  }
  return v3;
}

void IIOImageDestination::IIOImageDestination(IIOImageDestination *this, const __CFURL *a2, IIO_Writer *a3, const __CFString *a4, uint64_t a5, IIODictionary *a6)
{
  *(void *)this = &unk_1ED4E4C20;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  IIOImageDestination::setup(this, 3);
  IIODictionary::getBoolForKey(a6, @"kCGImageDestinationShouldHideExtension");
  CFURLRef v11 = CGImageWriteSessionCreateWithURL(a2);
  *((void *)this + 2) = v11;
  if (v11)
  {
    *((void *)this + 3) = CGImageSourceGetSource((uint64_t)v11);
    *((void *)this + 8) = a3;
    *((void *)this + 9) = IIO_Writer::utType(a3);
    *((void *)this + 5) = a5;
    IIOImageDestination::setProperties(this, a6);
  }
  else
  {
    *((_DWORD *)this + 57) = -1;
  }
}

void sub_188610EC0(_Unwind_Exception *exception_object)
{
  v4 = (void *)v1[16];
  if (v4)
  {
    v1[17] = v4;
    operator delete(v4);
  }
  size_t v5 = *v2;
  if (*v2)
  {
    v1[14] = v5;
    operator delete(v5);
  }
  _Unwind_Resume(exception_object);
}

BOOL IIO_Reader_OpenEXR::testHeader(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL result = AppleEXREnabled();
  if (result) {
    return gFunc_axr_introspect_data(a2, a3, 0) == 0;
  }
  return result;
}

BOOL IIO_Reader_ICNS::testHeader(uint64_t a1, unsigned char *a2)
{
  return *a2 == 105 && a2[1] == 99 && a2[2] == 110 && a2[3] == 115;
}

BOOL IIO_Reader_TGA::testHeader(uint64_t a1, unsigned __int8 *a2)
{
  BOOL result = 0;
  if (a2[1] <= 1u)
  {
    unsigned int v2 = a2[2];
    BOOL v3 = v2 > 0xB;
    int v4 = (1 << v2) & 0xE0E;
    BOOL v5 = v3 || v4 == 0;
    if (!v5 && a2[7] <= 0x20u && (a2[12] || a2[13]) && (a2[14] || a2[15]))
    {
      unsigned int v6 = a2[16];
      if (v6 <= 0x20 && ((1 << v6) & 0x101018100) != 0 && a2[17] < 0x40u) {
        return 1;
      }
    }
  }
  return result;
}

BOOL IIO_Reader_PSD::testHeader(uint64_t a1, unsigned char *a2)
{
  return *a2 == 56
      && a2[1] == 66
      && a2[2] == 80
      && a2[3] == 83
      && !a2[4]
      && a2[5] - 1 < 2;
}

uint64_t IIO_Reader_PDF::testHeader(int a1, uint64_t a2, unint64_t a3, CFStringRef theString1)
{
  if (theString1 && CFEqual(theString1, @"com.adobe.pdf"))
  {
    unsigned int v6 = 1024;
    if (a3 < 0x400) {
      unsigned int v6 = a3;
    }
    if (v6 < 7) {
      return 0;
    }
  }
  else
  {
    unsigned int v6 = 10;
  }
  uint64_t v7 = v6 - 6;
  for (i = (unsigned char *)(a2 + 2);
        *(i - 2) != 37
     || *(i - 1) != 80
     || *i != 68
     || i[1] != 70
     || i[2] != 45
     || i[3] - 49 >= 2;
        ++i)
  {
    if (!--v7) {
      return 0;
    }
  }
  return 1;
}

BOOL IIO_Reader_ICO::testHeader(uint64_t a1, unsigned char *a2)
{
  BOOL result = 0;
  if (!*a2 && !a2[1] && a2[2] == 1 && !a2[3])
  {
    if (a2[4])
    {
      if (!a2[5]
        && a2[6] - 12 <= 0xFFFFFFF4
        && a2[7] - 12 <= 0xFFFFFFF4)
      {
        unsigned int v3 = a2[12];
        if (v3 <= 0x20 && ((1 << v3) & 0x101000113) != 0 && !a2[13]) {
          return 1;
        }
      }
    }
  }
  return result;
}

BOOL IIO_Reader_CUR::testHeader(uint64_t a1, unsigned char *a2)
{
  return !*a2 && !a2[1] && a2[2] == 2 && !a2[3] && a2[4] && !a2[5];
}

BOOL IIO_Reader_BMP::testHeader(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  if (*(unsigned char *)a2 == 66 && *(unsigned char *)(a2 + 1) == 77)
  {
    uint64_t v2 = *(unsigned int *)(a2 + 14);
    BOOL v3 = (v2 - 12) > 0x34 || ((1 << (v2 - 12)) & 0x10110010000011) == 0;
    if ((!v3 || v2 == 124 || v2 == 108) && v2 + 14 <= (unint64_t)*(unsigned int *)(a2 + 10)) {
      return 1;
    }
  }
  return result;
}

void IIOImageSource::IIOImageSource(IIOImageSource *this, const __CFString *a2, IIODictionary *a3)
{
  *(void *)this = &unk_1ED4E1420;
  *((void *)this + 18) = 0;
  *((void *)this + 19) = 0;
  *((void *)this + 20) = 0;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
  *((void *)this + 27) = 0;
  IIOImageSource::setup((uint64_t)this, 5);
  if (a3) {
    IIOImageSource::extractOptions(this, a3);
  }
  CFURLRef v6 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, kCFURLPOSIXPathStyle, 0);
  if (v6)
  {
    *((void *)this + 2) = CGImageReadCreateWithURL(*((void *)this + 1), v6, (unsigned __int8 *)1, *((unsigned __int8 *)this + 48), *((unsigned __int8 *)this + 49));
    CFRelease(v6);
  }
}

void sub_188611360(_Unwind_Exception *exception_object)
{
  BOOL v5 = *v3;
  if (*v3)
  {
    *(void *)(v1 + 208) = v5;
    operator delete(v5);
  }
  CFURLRef v6 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 152) = v6;
    operator delete(v6);
  }
  _Unwind_Resume(exception_object);
}

uint64_t HEIFReadPlugin::getDecodePixelFormatForBitDepth(HEIFReadPlugin *this, int a2)
{
  int v2 = *((_DWORD *)this + 81);
  if (v2 == 1196573017)
  {
    if (*((unsigned char *)this + 500)) {
      unsigned int v6 = 843264056;
    }
    else {
      unsigned int v6 = 1278226488;
    }
    unsigned int v7 = 1278226742;
    if (*((unsigned char *)this + 500)) {
      unsigned int v7 = 843264310;
    }
    if (a2 == 10) {
      return v7;
    }
    else {
      return v6;
    }
  }
  else if (v2 == 1380401696)
  {
    if (*((unsigned char *)this + 500)) {
      unsigned int v3 = 1111970369;
    }
    else {
      unsigned int v3 = 875704422;
    }
    if (*((unsigned char *)this + 500)) {
      unsigned int v4 = 1815491698;
    }
    else {
      unsigned int v4 = 2019963440;
    }
    if (a2 == 10) {
      return v4;
    }
    else {
      return v3;
    }
  }
  else
  {
    return 0;
  }
}

BOOL IIO_Reader_AI::testHeader(int a1, unsigned char *a2, int a3, CFStringRef theString1)
{
  if (!theString1) {
    return 0;
  }
  return CFEqual(theString1, @"com.adobe.illustrator.ai-image")
      && *a2 == 37
      && a2[1] == 80
      && a2[2] == 68
      && a2[3] == 70
      && a2[4] == 45;
}

char *IIOImageRead::copySourceInfo(IIOImageRead *this)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  size_t v8 = 0;
  bzero(__str, 0x400uLL);
  if (*((void *)this + 7))
  {
    _CFStringGetFileSystemRepresentation();
  }
  else
  {
    int v2 = (const void *)*((void *)this + 4);
    if (v2)
    {
      CFIndex Length = CFDataGetLength(*((CFDataRef *)this + 4));
      snprintf(__str, 0x400uLL, "(CFDataRef) %p @\"%ld bytes\"", v2, Length);
    }
  }
  unsigned int v4 = *((_DWORD *)this + 18) - 1;
  if (v4 > 9) {
    BOOL v5 = "[unknown]      %s";
  }
  else {
    BOOL v5 = off_1E53CC618[v4];
  }
  unsigned int v6 = __str;
  if (!__str[0]) {
    unsigned int v6 = "";
  }
  asprintf(&v8, v5, v6);
  return v8;
}

void FindNode()
{
  __assert_rtn("FindNode", "XMPCore_Impl.cpp", 1171, "(currNode == 0) || (currNode == *currPos)");
}

{
  __assert_rtn("FindNode", "XMPCore_Impl.cpp", 1172, "(currNode != 0) || (! createNodes)");
}

{
  __assert_rtn("FindNode", "XMPCore_Impl.cpp", 1111, "aliasPos != sRegisteredAliasMap->end()");
}

{
  __assert_rtn("FindNode", "XMPCore_Impl.cpp", 1131, "(arrayForm == 0) || (arrayForm & kXMP_PropValueIsArray)");
}

{
  __assert_rtn("FindNode", "XMPCore_Impl.cpp", 1132, "(arrayForm == 0) ? (aliasPos->second.size() == 2) : (aliasPos->second.size() == 3)");
}

{
  __assert_rtn("FindNode", "XMPCore_Impl.cpp", 1082, "(leafOptions == 0) || createNodes");
}

BOOL IIOLoadAppleOpenExrSymbols(void)
{
  v0 = dlopen("/usr/lib/libAppleEXR.dylib", 257);
  uint64_t v1 = v0;
  if (v0)
  {
    gFunc_axr_get_version = (uint64_t)dlsym(v0, "axr_get_version");
    gFunc_axr_channel_type_get_name = (uint64_t)dlsym(v1, "axr_channel_type_get_name");
    gFunc_axr_compression_get_name = dlsym(v1, "axr_compression_get_name");
    gFunc_axr_error_get_name = dlsym(v1, "axr_error_get_name");
    gFunc_axr_flags_get_name = (uint64_t)dlsym(v1, "axr_flags_get_name");
    gFunc_axr_line_order_get_name = (uint64_t)dlsym(v1, "axr_line_order_get_name");
    gFunc_axr_property_flags_get_name = (uint64_t)dlsym(v1, "axr_property_flags_get_name");
    gFunc_axr_type_get_name = (uint64_t)dlsym(v1, "axr_type_get_name");
    gFunc_axr_type_get_size = (uint64_t)dlsym(v1, "axr_type_get_size");
    gFunc_axr_introspect_data = dlsym(v1, "axr_introspect_data");
    gFunc_axr_data_create = dlsym(v1, "axr_data_create");
    gFunc_axr_data_create_logical_image_list = dlsym(v1, "axr_data_create_logical_image_list");
    gFunc_axr_data_get_channel_count = dlsym(v1, "axr_data_get_channel_count");
    gFunc_axr_data_get_channel_info = dlsym(v1, "axr_data_get_channel_info");
    gFunc_axr_data_get_layer_count = (uint64_t)dlsym(v1, "axr_data_get_layer_count");
    gFunc_axr_data_get_layer_info = (uint64_t)dlsym(v1, "axr_data_get_layer_info");
    gFunc_axr_data_get_level_count = (uint64_t)dlsym(v1, "axr_data_get_level_count");
    gFunc_axr_data_get_level_size = (uint64_t)dlsym(v1, "axr_data_get_level_size");
    gFunc_axr_data_get_part_count = dlsym(v1, "axr_data_get_part_count");
    gFunc_axr_data_get_part_info = dlsym(v1, "axr_data_get_part_info");
    gFunc_axr_data_get_property_count = (uint64_t (*)(void, void))dlsym(v1, "axr_data_get_property_count");
    gFunc_axr_data_get_property = (void *(*)(void *__return_ptr, void, void, void, void))dlsym(v1, "axr_data_get_property");
    gFunc_axr_decoder_create = (uint64_t)dlsym(v1, "axr_decoder_create");
    gFunc_axr_decoder_copy = (uint64_t)dlsym(v1, "axr_decoder_copy");
    gFunc_axr_decoder_append_channel = (uint64_t)dlsym(v1, "axr_decoder_append_channel");
    gFunc_axr_decoder_append_constant_value_channel = (uint64_t)dlsym(v1, "axr_decoder_append_constant_value_channel");
    gFunc_axr_decoder_clear_channel_list = (uint64_t)dlsym(v1, "axr_decoder_clear_channel_list");
    gFunc_axr_decoder_create_colorspace = dlsym(v1, "axr_decoder_create_colorspace");
    gFunc_axr_decoder_get_channel_count = dlsym(v1, "axr_decoder_get_channel_count");
    gFunc_axr_decoder_get_channel_info = (uint64_t)dlsym(v1, "axr_decoder_get_channel_info");
    gFunc_axr_decoder_get_data = (uint64_t)dlsym(v1, "axr_decoder_get_data");
    gFunc_axr_decoder_get_info = (uint64_t)dlsym(v1, "axr_decoder_get_info");
    gFunc_axr_decoder_get_read_pixels_info = dlsym(v1, "axr_decoder_get_read_pixels_info");
    gFunc_axr_decoder_get_read_planes_info = (uint64_t)dlsym(v1, "axr_decoder_get_read_planes_info");
    gFunc_axr_decoder_get_read_rgba_pixels_info = dlsym(v1, "axr_decoder_get_read_rgba_pixels_info");
    gFunc_axr_decoder_translate_channel_index = (uint64_t)dlsym(v1, "axr_decoder_translate_channel_index");
    gFunc_axr_decoder_set_subregion = (uint64_t)dlsym(v1, "axr_decoder_set_subregion");
    gFunc_axr_decoder_read_pixels = dlsym(v1, "axr_decoder_read_pixels");
    gFunc_axr_decoder_read_planes = (uint64_t)dlsym(v1, "axr_decoder_read_planes");
    gFunc_axr_decoder_read_rgba_pixels = dlsym(v1, "axr_decoder_read_rgba_pixels");
    gFunc_axr_encoder_append_part = dlsym(v1, "axr_encoder_append_part");
    gFunc_axr_encoder_compress = dlsym(v1, "axr_encoder_compress");
    gFunc_axr_encoder_create = dlsym(v1, "axr_encoder_create");
    gFunc_axr_part_append_attribute = (uint64_t)dlsym(v1, "axr_part_append_attribute");
    gFunc_axr_part_append_channels = dlsym(v1, "axr_part_append_channels");
    gFunc_axr_part_create = (uint64_t)dlsym(v1, "axr_part_create");
    gFunc_axr_part_set_preview = (uint64_t)dlsym(v1, "axr_part_set_preview");
    gFunc_axr_part_set_chromaticities = dlsym(v1, "axr_part_set_chromaticities");
    gFunc_axr_part_create_colorspace = dlsym(v1, "axr_part_create_colorspace");
    gFunc_axr_logical_image_list_create_decoder = dlsym(v1, "axr_logical_image_list_create_decoder");
    gFunc_axr_logical_image_list_deserialize = (uint64_t)dlsym(v1, "axr_logical_image_list_deserialize");
    gFunc_axr_logical_image_list_get_default_image_index = (uint64_t)dlsym(v1, "axr_logical_image_list_get_default_image_index");
    gFunc_axr_logical_image_list_get_default_view_index = (uint64_t)dlsym(v1, "axr_logical_image_list_get_default_view_index");
    gFunc_axr_logical_image_list_get_image_count = dlsym(v1, "axr_logical_image_list_get_image_count");
    gFunc_axr_logical_image_list_get_image_info = dlsym(v1, "axr_logical_image_list_get_image_info");
    gFunc_axr_logical_image_list_get_image_name = dlsym(v1, "axr_logical_image_list_get_image_name");
    gFunc_axr_logical_image_list_get_serialized_size = (uint64_t)dlsym(v1, "axr_logical_image_list_get_serialized_size");
    gFunc_axr_logical_image_list_get_view_count = dlsym(v1, "axr_logical_image_list_get_view_count");
    gFunc_axr_logical_image_list_get_view_name = dlsym(v1, "axr_logical_image_list_get_view_name");
    gFunc_axr_logical_image_list_is_equal = (uint64_t)dlsym(v1, "axr_logical_image_list_is_equal");
    gFunc_axr_logical_image_list_serialize = (uint64_t)dlsym(v1, "axr_logical_image_list_serialize");
  }
  return v1 != 0;
}

char *CodePoint_from_UTF8(char *result, unint64_t a2, unsigned int *a3, unint64_t *a4)
{
  if (!a2)
  {
    unint64_t v4 = 0;
    goto LABEL_5;
  }
  if ((*result & 0x80000000) == 0)
  {
    *a3 = *result;
    unint64_t v4 = 1;
LABEL_5:
    *a4 = v4;
    return result;
  }
  return CodePoint_from_UTF8_Multi(result, a2, a3, a4);
}

BOOL AppleEXREnabled(void)
{
  if (AppleEXREnabled(void)::onceToken != -1) {
    dispatch_once(&AppleEXREnabled(void)::onceToken, &__block_literal_global_0);
  }
  return (gAppleEXREnabled & 1) == 0;
}

uint64_t IIOGetOrientationFromXMPData(const char *a1, size_t __len)
{
  uint64_t v3 = __len;
  unint64_t v4 = strnstr(a1, "tiff:Orientation", __len);
  if (!v4) {
    return 1;
  }
  BOOL v5 = (unsigned __int8 *)(v4 + 16);
  if (v4 + 16 >= &a1[v3])
  {
LABEL_6:
    unsigned int v8 = 1;
  }
  else
  {
    uint64_t v6 = &a1[v3] - v4 - 16;
    while (1)
    {
      int v7 = *v5;
      if ((v7 - 58) >= 0xFFFFFFF6) {
        break;
      }
      ++v5;
      if (!--v6) {
        goto LABEL_6;
      }
    }
    unsigned int v8 = v7 - 48;
  }
  if (v8 - 9 < 0xFFFFFFF8) {
    return 1;
  }
  else {
    return v8;
  }
}

CFURLRef CGImageWriteSessionCreateWithURL(const __CFURL *a1)
{
  CFURLRef v1 = a1;
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    CFTypeID v2 = CFURLGetTypeID();
    if (v2 == CFGetTypeID(v1))
    {
      CFStringRef v3 = IIO_CFURLCopyResolvedFileSystemPath(v1);
      if (v3)
      {
        unint64_t v4 = v3;
        bzero(buffer, 0x402uLL);
        if (!CFURLGetFileSystemRepresentation(v1, 1u, buffer, 1026))
        {
          LogError("CGImageWriteSessionCreateWithURL", 775, "*** ERROR: invalid URL - CFURLGetFileSystemRepresentation failed\n");
          goto LABEL_14;
        }
        memset(&v9, 0, sizeof(v9));
        if (!stat((const char *)buffer, &v9) && (v9.st_mode & 0xF000) == 0x4000)
        {
          LogError("CGImageWriteSessionCreateWithURL", 782, "*** ERROR: invalid URL (directory vs. file)\n");
LABEL_14:
          CFURLRef v1 = 0;
          goto LABEL_15;
        }
        uint64_t v7 = CGImageWriteSessionCreateWithFile((uint64_t)v4);
LABEL_12:
        CFURLRef v1 = (const __CFURL *)v7;
LABEL_15:
        CFRelease(v4);
        return v1;
      }
      CFStringRef v5 = CFURLCopyScheme(v1);
      if (v5)
      {
        CFRelease(v5);
        CGDataConsumerRef v6 = CGDataConsumerCreateWithURL(v1);
        if (v6)
        {
          unint64_t v4 = v6;
          uint64_t v7 = CGImageWriteSessionCreateWithConsumer((uint64_t)v6);
          goto LABEL_12;
        }
        LogError("CGImageWriteSessionCreateWithURL", 795, "*** ERROR: invalid URL - CGDataConsumerCreateWithURL failed\n");
      }
      else
      {
        LogError("CGImageWriteSessionCreateWithURL", 791, "*** ERROR: invalid URL - cannot copy scheme\n");
      }
    }
    return 0;
  }
  return v1;
}

uint64_t CGImageWriteSessionCreateWithFile(uint64_t a1)
{
  if (a1) {
    operator new();
  }
  return 0;
}

void sub_188611F18(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10E1C408329B462);
  _Unwind_Resume(a1);
}

CFTypeID CGImageSourceGetTypeID(void)
{
  if (CGImageSourceGetTypeID::once != -1) {
    dispatch_once(&CGImageSourceGetTypeID::once, &__block_literal_global_164);
  }
  return CGImageSourceGetTypeID::id;
}

uint64_t CGImageSourceCreateWithFile(const void *a1, const void *a2)
{
  v8[128] = *MEMORY[0x1E4F143B8];
  IIOInitDebugFlags();
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFStringGetTypeID())
    {
      if (a2)
      {
        CFTypeID v5 = CFGetTypeID(a2);
        if (v5 != CFDictionaryGetTypeID())
        {
          LogError("CGImageSourceCreateWithFile", 4676, "*** ERROR: CGImageSourceCreateWithFile: options parameter is not a CFDictionaryRef - ignoring\n");
          a2 = 0;
        }
      }
      memset(v8, 0, 24);
      IIODictionary::IIODictionary((IIODictionary *)v8, (const __CFDictionary *)a2);
      operator new();
    }
    LogError("CGImageSourceCreateWithFile", 4673, "*** ERROR: CGImageSourceCreateWithFile: path is not a CFStringRef\n");
  }
  else
  {
    LogError("CGImageSourceCreateWithFile", 4672, "*** ERROR: CGImageSourceCreateWithFile: path is nil\n");
  }
  uint64_t v6 = gIIODebugFlags;
  if ((gIIODebugFlags & 0x3000) != 0)
  {
    bzero(v8, 0x400uLL);
    _CFStringGetFileSystemRepresentation();
    uint64_t v6 = gIIODebugFlags;
    if ((unsigned __int16)gIIODebugFlags >> 14)
    {
      ImageIODebugOptions((unsigned __int16)gIIODebugFlags >> 14, "S", "CGImageSourceCreateWithFile", 0, (const char *)v8, -1, (const __CFDictionary *)a2);
      uint64_t v6 = gIIODebugFlags;
    }
  }
  if ((v6 & 0x800000000000) != 0) {
    ImageIOLog("∆∆∆ ISSUE: %s:%d:  %s\n", "CGImageSourceCreateWithFile", 4699, "could not create CGImageSourceRef");
  }
  return 0;
}

void sub_188612174(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  MEMORY[0x18C11C0E0](v4, 0x10E1C40A1B1CD90);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

CGImageDestinationRef CGImageDestinationCreateWithURL(CFURLRef url, CFStringRef type, size_t count, CFDictionaryRef options)
{
  IIOInitDebugFlags();
  kdebug_trace();
  if (url)
  {
    if (type)
    {
      if (!count) {
        _cg_jpeg_mem_term("CGImageDestinationCreateWithURL", 4906, "*** CGImageDestinationCreateWithURL: capacity is 0\n");
      }
      CFTypeID v8 = CFGetTypeID(url);
      if (v8 == CFURLGetTypeID())
      {
        CFTypeID v9 = CFGetTypeID(type);
        if (v9 == CFStringGetTypeID())
        {
          if (options)
          {
            CFTypeID v10 = CFGetTypeID(options);
            if (v10 != CFDictionaryGetTypeID())
            {
              LogError("CGImageDestinationCreateWithURL", 4911, "*** ERROR: CGImageDestinationCreateWithURL: options parameter is not a CFDictionaryRef - ignoring\n");
              options = 0;
            }
          }
          if ((gIIODebugFlags & 0x3000) != 0)
          {
            CFStringRef v11 = IIO_CFURLCopyResolvedFileSystemPath(url);
            if (v11)
            {
              CFStringRef v12 = v11;
              uint64_t v19 = 0;
              uint64_t v20 = 0;
              uint64_t v21 = 0;
              IIOString::IIOString((IIOString *)&v19, 0, @"[%@] %@", type, v11);
              unsigned int v13 = (gIIODebugFlags >> 12) & 3;
              if (v13)
              {
                v14 = (const char *)IIOString::utf8String((IIOString *)&v19);
                ImageIODebugOptions(v13, "A", "CGImageDestinationCreateWithURL", 0, v14, -1, options);
              }
              CFRelease(v12);
              IIOString::~IIOString((IIOString *)&v19);
            }
          }
          uint64_t v19 = 0;
          uint64_t v20 = 0;
          uint64_t v21 = 0;
          v15 = IIODictionary::IIODictionary((IIODictionary *)&v19, options);
          WriterHandler = (IIO_WriterHandler *)IIO_WriterHandler::GetWriterHandler(v15);
          if (IIO_WriterHandler::findWriterForType(WriterHandler, type, (const __CFString *)count, (IIODictionary *)&v19, v17))
          {
            operator new();
          }
          IIODictionary::~IIODictionary((IIODictionary *)&v19);
          LogError("CGImageDestinationCreateWithURL", 4928, "*** ERROR: CGImageDestinationCreateWithURL: failed to create 'CGImageDestinationRef'\n");
        }
        else
        {
          LogError("CGImageDestinationCreateWithURL", 4908, "*** ERROR: CGImageDestinationCreateWithURL: type is not a CFStringRef\n");
        }
      }
      else
      {
        LogError("CGImageDestinationCreateWithURL", 4907, "*** ERROR: CGImageDestinationCreateWithURL: url is not a CFURLRef\n");
      }
    }
    else
    {
      LogError("CGImageDestinationCreateWithURL", 4904, "*** ERROR: CGImageDestinationCreateWithURL: type is nil\n");
    }
  }
  else
  {
    LogError("CGImageDestinationCreateWithURL", 4903, "*** ERROR: CGImageDestinationCreateWithURL: url is nil\n");
  }
  kdebug_trace();
  kdebug_trace();
  return 0;
}

void sub_1886124FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  MEMORY[0x18C11C0E0](v4, 0x10E1C40255C1624);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

void CGImageDestinationAddImageFromSource(CGImageDestinationRef idst, CGImageSourceRef isrc, size_t index, CFDictionaryRef properties)
{
  memset(v20, 0, sizeof(v20));
  IIODictionary::IIODictionary((IIODictionary *)v20, properties, 1);
  IIOPackDstInputInfo((IIODictionary *)v20);
  kdebug_trace();
  unsigned int v8 = (gIIODebugFlags >> 12) & 3;
  if (v8 < 2)
  {
    if (v8) {
      ImageIODebugOptions(1, "A", "CGImageDestinationAddImageFromSource", idst, 0, -1, properties);
    }
  }
  else
  {
    if (!isrc)
    {
      ImageIODebugOptions(v8, "A", "CGImageDestinationAddImageFromSource", idst, 0, -1, properties);
      if (idst)
      {
        uint64_t v12 = *((void *)idst + 3);
        goto LABEL_26;
      }
LABEL_30:
      LogError("CGImageDestinationAddImageFromSource", 5107, "*** ERROR: CGImageDestinationAddImageFromSource: destination is nil\n");
      goto LABEL_31;
    }
    CFStringRef v9 = CFCopyDescription(isrc);
    memset(v19, 0, sizeof(v19));
    IIOString::IIOString((IIOString *)v19, v9);
    unsigned int v10 = (gIIODebugFlags >> 12) & 3;
    if (v10)
    {
      CFStringRef v11 = (const char *)IIOString::utf8String((IIOString *)v19);
      ImageIODebugOptions(v10, "A", "CGImageDestinationAddImageFromSource", idst, v11, -1, properties);
    }
    CFRelease(v9);
    IIOString::~IIOString((IIOString *)v19);
  }
  if (!idst) {
    goto LABEL_30;
  }
  uint64_t v12 = *((void *)idst + 3);
  if (!isrc)
  {
LABEL_26:
    LogError("CGImageDestinationAddImageFromSource", 5109, "*** ERROR: CGImageDestinationAddImageFromSource: source is nil\n");
    goto LABEL_27;
  }
  CFTypeID v13 = CFGetTypeID(idst);
  if (CGImageDestinationGetTypeID::once != -1) {
    dispatch_once(&CGImageDestinationGetTypeID::once, &__block_literal_global_25);
  }
  if (v13 == CGImageDestinationGetTypeID::id)
  {
    CFTypeID v14 = CFGetTypeID(isrc);
    if (v14 == CGImageSourceGetTypeID())
    {
      if (properties)
      {
        CFTypeID v15 = CFGetTypeID(properties);
        if (v15 != CFDictionaryGetTypeID()) {
          LogError("CGImageDestinationAddImageFromSource", 5114, "*** ERROR: CGImageDestinationAddImageFromSource: properties parameter is not a CFDictionaryRef - ignoring\n");
        }
      }
      if (!CGImageSourceGetType(isrc))
      {
        LogError("CGImageDestinationAddImageFromSource", 5122, "*** ERROR: CGImageDestinationAddImageFromSource: source is not an image -- (CGImageSourceGetType() returned NULL)\n");
        int v18 = -65;
        goto LABEL_28;
      }
      size_t Count = CGImageSourceGetCount(isrc);
      if (Count > index)
      {
        if (v12)
        {
          IIOImageDestination::addImageFromSource((IIOImageDestination *)v12, isrc, index, (IIODictionary *)v20);
          v17 = *(IIO_Reader **)(v12 + 64);
          if (v17) {
            IIO_Reader::osType(v17);
          }
          int v18 = 0;
          goto LABEL_29;
        }
        goto LABEL_31;
      }
      LogError("CGImageDestinationAddImageFromSource", 5128, "*** ERROR: srcIndex (%ld) >= CGImageSourceGetCount (%ld)\n", index, Count);
    }
    else
    {
      LogError("CGImageDestinationAddImageFromSource", 5111, "*** ERROR: CGImageDestinationAddImageFromSource: source is not a CGImageSourceRef\n");
    }
  }
  else
  {
    LogError("CGImageDestinationAddImageFromSource", 5110, "*** ERROR: CGImageDestinationAddImageFromSource: destination is not a CGImageDestinationRef\n");
  }
LABEL_27:
  int v18 = -50;
LABEL_28:
  if (v12) {
LABEL_29:
  }
    *(_DWORD *)(v12 + 204) = v18;
LABEL_31:
  kdebug_trace();
  IIODictionary::~IIODictionary((IIODictionary *)v20);
}

void sub_188612870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  _Unwind_Resume(a1);
}

uint64_t CGImageCreatePixelBufferAttributesForHDRTarget(int a1, void *a2, void *a3, void *a4)
{
  IIOInitDebugFlags();
  IIO_LoadJPEGSymbols();

  return IIOCreatePixelBufferAttributesForHDRType(a1, a2, a3, a4);
}

uint64_t IIOCreatePixelBufferAttributesForHDRType(int a1, void *a2, void *a3, void *a4)
{
  unsigned int v8 = (void *)MEMORY[0x18C11CF40]();
  id v9 = a2;
  id v10 = a3;
  CFStringRef v11 = +[HDRImageConverter imageConverterWithOptions:v10];
  if ([v11 canProcessPixelBufferWithAttributes:v9])
  {
    uint64_t v12 = [v9 objectForKeyedSubscript:*(void *)gIIO_kCVPixelBufferWidthKey];
    uint64_t v13 = [v12 unsignedLongValue];

    CFTypeID v14 = [v9 objectForKeyedSubscript:*(void *)gIIO_kCVPixelBufferHeightKey];
    uint64_t v15 = [v14 unsignedLongValue];

    v16 = [v10 objectForKeyedSubscript:@"kCGTargetPixelFormat"];
    uint64_t v17 = [v16 unsignedIntValue];

    int v18 = [v9 objectForKeyedSubscript:*(void *)gIIO_kCVPixelBufferPixelFormatTypeKey];
    unint64_t v84 = v13;
    v82 = v8;
    unsigned int v19 = [v18 unsignedIntValue];

    if (v17) {
      uint64_t v20 = v17;
    }
    else {
      uint64_t v20 = v19;
    }
    uint64_t v21 = (void *)gFunc_CVPixelFormatDescriptionCreateWithPixelFormatType(0, v20);
    v81 = v21;
    v22 = [v21 objectForKeyedSubscript:*(void *)gIIO_kCVPixelFormatContainsYCbCr];
    unint64_t v83 = v15;
    int v79 = [v22 BOOLValue];

    v23 = [v9 objectForKeyedSubscript:*(void *)gIIO_kCVImageBufferCGColorSpaceKey];

    if (v17)
    {
      if ([v11 isPixelFormatSupported:v17]) {
        unsigned int v24 = v17;
      }
      else {
        unsigned int v24 = 0;
      }
      unsigned int v78 = v24;
    }
    else
    {
      unsigned int v78 = 0;
    }
    v26 = [v10 objectForKeyedSubscript:@"kCGTargetYCCMatrix"];
    if (v26 && ([v11 isYCCMatrixSupported:v26] & 1) == 0)
    {

      v26 = 0;
    }
    v86 = v26;
    name = [v10 objectForKeyedSubscript:@"kCGTargetColorSpace"];
    v27 = objc_msgSend(v10, "objectForKeyedSubscript:");

    v80 = a4;
    if (name)
    {
      v28 = CGColorSpaceCreateWithName(name);
      if (v28) {
        goto LABEL_22;
      }
      LogError("IIOCreatePixelBufferAttributesForHDRType", 645, "Unrecognized color space name: \"%s\"", (const char *)[(__CFString *)name UTF8String]);
    }
    if (!v27)
    {
      v28 = 0;
      BOOL v30 = 0;
      int v31 = 1;
      goto LABEL_24;
    }
    if ((gIIODebugFlags & 0x300000) != 0)
    {
      v29 = (id) CFCopyDescription(v27);
      ImageIOLog("☀️ Using provided alternate space: %s", (const char *)[(__CFString *)v29 UTF8String]);
    }
    v28 = (CGColorSpace *)v27;
LABEL_22:
    LODWORD(v27) = CGColorSpaceUsesExtendedRange(v28);
    BOOL v30 = CGColorSpaceUsesITUR_2100TF(v28);
    int v31 = 0;
LABEL_24:
    v88 = [v9 objectForKeyedSubscript:@"IOSurfaceContentHeadroom"];
    v85 = [v10 objectForKeyedSubscript:@"kCGTargetHeadroom"];
    if (v88 && v85)
    {
      [v88 floatValue];
      float v33 = v32;
      [v85 floatValue];
      float v35 = fminf(v33, v34);
    }
    else if (v88)
    {
      [v88 floatValue];
      float v35 = v36;
    }
    else
    {
      float v35 = 0.0;
    }
    if (a1 != 3)
    {
      if (a1 != 2)
      {
        if (a1 != 1)
        {
          id v37 = v86;
          LogError("IIOCreatePixelBufferAttributesForHDRType", 787, "Unsupported HDR type: %d", a1);
          uint64_t v25 = 4294967246;
LABEL_133:

          unsigned int v8 = v82;
          goto LABEL_134;
        }
        if ((v31 | v27 | v30))
        {
          id v37 = v86;
          CGColorSpaceRef v38 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DB90]);
        }
        else
        {
          id v37 = v86;
          CGColorSpaceRef v38 = CGColorSpaceRetain(v28);
        }
        v43 = v38;
        if (v79) {
          unsigned int v44 = 875704422;
        }
        else {
          unsigned int v44 = 1111970369;
        }
        if (v78) {
          uint64_t v45 = v78;
        }
        else {
          uint64_t v45 = v44;
        }
        if (v79)
        {
          v46 = v37;
          if (!v37) {
            v46 = *(void **)gIIO_kCVImageBufferYCbCrMatrix_ITU_R_601_4;
          }
        }
        else
        {
          v46 = 0;
        }
        id v49 = v46;
        v50 = 0;
        float v35 = 1.0;
LABEL_127:
        v68 = (void *)[objc_alloc(MEMORY[0x1E4F1CA60]) initWithCapacity:5];
        v69 = [NSNumber numberWithUnsignedLong:v84];
        [v68 setObject:v69 forKeyedSubscript:*(void *)gIIO_kCVPixelBufferWidthKey];

        v70 = [NSNumber numberWithUnsignedLong:v83];
        [v68 setObject:v70 forKeyedSubscript:*(void *)gIIO_kCVPixelBufferHeightKey];

        v71 = [NSNumber numberWithUnsignedInt:v45];
        [v68 setObject:v71 forKeyedSubscript:*(void *)gIIO_kCVPixelBufferPixelFormatTypeKey];

        [v68 setObject:v43 forKeyedSubscript:*(void *)gIIO_kCVImageBufferCGColorSpaceKey];
        [v68 setObject:v49 forKeyedSubscript:*(void *)gIIO_kCVImageBufferYCbCrMatrixKey];
        [v68 setObject:v50 forKeyedSubscript:@"kCGFlexRangeAlternateColorSpace"];
        if (v35 <= 0.0)
        {
          v73 = 0;
        }
        else
        {
          *(float *)&double v72 = v35;
          v73 = [NSNumber numberWithFloat:v72];
        }
        uint64_t v21 = v81;
        [v68 setObject:v73 forKeyedSubscript:@"IOSurfaceContentHeadroom"];
        if (v35 > 0.0) {

        }
        void *v80 = v68;
        uint64_t v25 = 0;
        goto LABEL_133;
      }
      if (((v31 | v27 ^ 1) & 1) == 0)
      {
        id v37 = v86;
        v43 = CGColorSpaceRetain(v28);
        if (v78) {
          uint64_t v45 = v78;
        }
        else {
          uint64_t v45 = 1380411457;
        }
        int v47 = v79;
        if (!v78) {
          int v47 = 0;
        }
        if (v47 == 1)
        {
          v48 = v86;
          if (!v86) {
            v48 = *(void **)gIIO_kCVImageBufferYCbCrMatrix_ITU_R_601_4;
          }
        }
        else
        {
          v48 = 0;
        }
        id v49 = v48;
        v50 = 0;
        goto LABEL_127;
      }
      float v89 = 0.0;
      if ((v31 | !v30))
      {
        id v37 = v86;
        CFStringRef v42 = (const __CFString *)IIODefaultHDRColorSpace((CGColorSpace *)v23);
        v43 = CGColorSpaceCreateWithName(v42);
      }
      else
      {
        id v37 = v86;
        v43 = CGColorSpaceRetain(v28);
        if (CGColorSpaceContainsFlexGTCInfo())
        {
          v51 = (void *)CGColorSpaceCopyFlexGTCInfo();
          if (+[HDRImage getGainMapHeadroom:&v89 fromFlexGTCInfo:v51]&& v35 < (float)(v89 + -0.01))
          {
            if ((gIIODebugFlags & 0x300000) != 0) {
              ImageIOLog("☀️ Requested headroom (%0.1f) is less than FlexGTC headroom (%0.1f), dropping FlexGTC info", v35, v89);
            }
            CGColorSpaceRelease((CGColorSpaceRef)v43);
            v43 = (void *)CGColorSpaceCopyBaseColorSpace();
            float v89 = 0.0;
          }
        }
      }
      if ((gIIODebugFlags & 0x300000) != 0)
      {
        v52 = (id) CFCopyDescription(v43);
        ImageIOLog("☀️ HDR output colorspace: %s", (const char *)[(__CFString *)v52 UTF8String]);
      }
      float v53 = v89;
      if (v89 == 0.0)
      {
        if (CGColorSpaceIsPQBased((CGColorSpaceRef)v43))
        {
          float v89 = 49.261;
          float v53 = 49.261;
LABEL_113:
          float v65 = fminf(v35, v53);
          if ((gIIODebugFlags & 0x300000) != 0) {
            ImageIOLog("☀️ HDR input headroom: %0.1f, destination: %0.1f, output headroom: %0.1f", v35, v53, v65);
          }
          if (v78) {
            uint64_t v45 = v78;
          }
          else {
            uint64_t v45 = 2019963440;
          }
          int v66 = v79;
          if (!v78) {
            int v66 = 1;
          }
          if (v66 == 1)
          {
            if (v37)
            {
              id v67 = v37;
            }
            else
            {
              IIODefaultHDRYCCMatrix((CGColorSpace *)v43);
              id v67 = (id)objc_claimAutoreleasedReturnValue();
            }
            id v49 = v67;
          }
          else
          {
            id v49 = 0;
          }
          v50 = 0;
          float v35 = v65;
          goto LABEL_127;
        }
        float v53 = v89;
      }
      if (v53 == 0.0)
      {
        if (CGColorSpaceIsHLGBased((CGColorSpaceRef)v43))
        {
          float v89 = 4.9261;
          float v53 = 4.9261;
        }
        else
        {
          float v53 = v89;
        }
      }
      goto LABEL_113;
    }
    v39 = [v10 objectForKeyedSubscript:@"kCGFlexRangeOptions"];

    if (!v39)
    {
      v43 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC00]);
      id v49 = 0;
      v50 = 0;
      uint64_t v45 = 1278226488;
      unint64_t v41 = 2;
      id v37 = v86;
LABEL_107:
      float v35 = 0.0;
      v83 /= v41;
      v84 /= v41;
      goto LABEL_127;
    }
    v76 = [v10 objectForKeyedSubscript:@"kCGFlexRangeOptions"];
    v40 = [v76 objectForKeyedSubscript:@"kCGFlexRangeSubsample"];
    v75 = v40;
    if (v40)
    {
      if ([v40 BOOLValue]) {
        unint64_t v41 = 2;
      }
      else {
        unint64_t v41 = 1;
      }
    }
    else
    {
      unint64_t v41 = 2;
    }
    v77 = [v76 objectForKeyedSubscript:@"kCGFlexRangeAlternateColorSpace"];
    if (!v77 || (objc_opt_class(), char isKindOfClass = objc_opt_isKindOfClass(), v55 = v77, (isKindOfClass & 1) == 0))
    {
      if ((v30 | v27) != 1)
      {
        IIODefaultHDRColorSpace((CGColorSpace *)v23);
        CFStringRef v57 = (const __CFString *)objc_claimAutoreleasedReturnValue();
        goto LABEL_90;
      }
      if (v23 && (int v90 = 0, CGColorSpaceGetCICPInfo()) && v90 == 12) {
        v56 = (void **)MEMORY[0x1E4F1DB90];
      }
      else {
        v56 = (void **)MEMORY[0x1E4F1DC98];
      }
      v55 = *v56;
    }
    CFStringRef v57 = v55;
LABEL_90:
    v50 = (__CFString *)v57;
    if (v78) {
      uint64_t v45 = v78;
    }
    else {
      uint64_t v45 = 1278226488;
    }
    int v58 = v79;
    if (!v78) {
      int v58 = 0;
    }
    if (v58 == 1)
    {
      v59 = v86;
      if (!v86)
      {
        v60 = CGColorSpaceCreateWithName(v57);
        if (v31) {
          v61 = (CGColorSpace *)v23;
        }
        else {
          v61 = v28;
        }
        v62 = [v76 objectForKeyedSubscript:@"kCGFlexRangeUseAlternateColor"];
        v63 = v62;
        if (v62 && ([v62 BOOLValue] & (v60 != 0)) != 0) {
          v61 = v60;
        }
        uint64_t v64 = IIODefaultHDRYCCMatrix(v61);
        CGColorSpaceRelease(v60);

        v59 = (void *)v64;
      }
      id v37 = v59;
      id v49 = v37;
    }
    else
    {
      id v49 = 0;
      id v37 = v86;
    }

    v43 = 0;
    goto LABEL_107;
  }
  uint64_t v25 = 4294967246;
LABEL_134:

  return v25;
}

void sub_1886133A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,void *a25)
{
  _Unwind_Resume(a1);
}

uint64_t CGImageConvertHDRPixelBufferToSDR(uint64_t a1, uint64_t a2, void *a3)
{
  IIOInitDebugFlags();
  IIO_LoadJPEGSymbols();

  return IIOConvertHDRData(a1, a2, a3);
}

uint64_t IIOConvertHDRData(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6 = (void *)MEMORY[0x18C11CF40]();
  id v7 = a3;
  unsigned int v8 = [v7 objectForKeyedSubscript:@"kCGImageAuxiliaryDataInfoMetadata"];

  id v9 = [[HDRImage alloc] initWithImageBuffer:a1 gainMapBuffer:0 gainMapMetadata:v8 imageProperties:v7];
  id v10 = [[HDRImage alloc] initWithImageBuffer:a2];
  CFStringRef v11 = +[HDRImageConverter imageConverterWithOptions:v7];
  if ([v11 convertImage:v9 toImage:v10]) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = 4294967246;
  }

  return v12;
}

void sub_188613688(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CGImageApplyHDRGainMap(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  IIOInitDebugFlags();
  IIO_LoadJPEGSymbols();

  return IIOApplyHDRGainMap(a1, a2, a3, a4);
}

uint64_t IIOApplyHDRGainMap(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  unsigned int v8 = (void *)MEMORY[0x18C11CF40]();
  id v9 = a4;
  id v10 = [v9 objectForKeyedSubscript:@"kCGImageAuxiliaryDataInfoMetadata"];

  CFStringRef v11 = [[HDRImage alloc] initWithImageBuffer:a1 gainMapBuffer:a2 gainMapMetadata:v10 imageProperties:v9];
  if ([(HDRImage *)v11 type] == 6)
  {
    uint64_t v12 = [v9 objectForKeyedSubscript:@"kCGFlexRangeAlternateColorSpace"];

    if (v12)
    {
      CFTypeID v13 = CFGetTypeID(v12);
      if (v13 == CGColorSpaceGetTypeID())
      {
        CFTypeID v14 = [(HDRImage *)v11 flexRangeParams];
        [v14 setAlternateColorSpace:v12];
      }
      else
      {
        LogError("IIOApplyHDRGainMap", 237, "kCGFlexRangeAlternateColorSpace option must be a CGColorSpace object");
      }
    }
    else
    {
      LogError("IIOApplyHDRGainMap", 235, "kCGFlexRangeAlternateColorSpace option must be set for FlexRange");
    }
  }
  uint64_t v15 = [v9 objectForKeyedSubscript:@"Orientation"];

  if (v15)
  {
    v16 = [v9 objectForKeyedSubscript:@"Orientation"];
    -[HDRImage setGainMapOrientation:](v11, "setGainMapOrientation:", [v16 intValue]);
  }
  uint64_t v17 = [[HDRImage alloc] initWithImageBuffer:a3];
  uint64_t v49 = a3;
  int v18 = [v9 objectForKeyedSubscript:@"kCGTargetHeadroom"];

  if (v18)
  {
    unsigned int v19 = [v9 objectForKeyedSubscript:@"kCGTargetHeadroom"];
    [v19 floatValue];
    float v21 = v20;
  }
  else
  {
    float v21 = 16.0;
  }
  [(HDRImage *)v11 headroom];
  float v23 = v22;
  [(HDRImage *)v17 headroom];
  if (v23 >= v21) {
    float v25 = v21;
  }
  else {
    float v25 = v23;
  }
  if (v25 >= *(float *)&v24) {
    float v26 = *(float *)&v24;
  }
  else {
    float v26 = v25;
  }
  if ((gIIODebugFlags & 0x300000) != 0)
  {
    [(HDRImage *)v11 headroom];
    float v28 = v27;
    [(HDRImage *)v17 headroom];
    ImageIOLog("☀️  gain map headroom: %0.1f requested: %0.1f capacity: %0.1f -> %0.1f\n", v28, v21, v29, v26);
  }
  *(float *)&double v24 = v26;
  [(HDRImage *)v17 setHeadroom:v24];
  BOOL v30 = +[HDRImageConverter imageConverterWithOptions:v9];
  int v31 = [v30 convertImage:v11 toImage:v17];
  id v32 = v9;
  float v33 = v32;
  if (v32)
  {
    float v34 = [v32 objectForKeyedSubscript:@"kCGGenerateFlexGTC"];
    int v35 = [v34 BOOLValue];

    float v36 = [v33 objectForKeyedSubscript:@"kCGImageSourceGenerateImageSpecificLumaScaling"];
    int v37 = [v36 BOOLValue];

    if ((v35 | v37) == 1)
    {
      if ((gIIODebugFlags & 0x300000) != 0) {
        ImageIOLog("☀️  generating FlexGTC info as requested...\n");
      }
      [(HDRImage *)v17 colorSpace];
      if (CGColorSpaceContainsFlexGTCInfo())
      {
        [(HDRImage *)v17 colorSpace];
        CGColorSpaceRef v38 = (void *)CGColorSpaceCopyFlexGTCInfo();
        v39 = v38;
        if ((gIIODebugFlags & 0x300000) != 0)
        {
          id v40 = [v38 description];
          ImageIOLog("☀️  destination already has FlexGTC info: %s\n", (const char *)[v40 UTF8String]);
        }
        float v50 = 0.0;
        if (+[HDRImage getGainMapHeadroom:&v50 fromFlexGTCInfo:v39]&& vabds_f32(v50, v26) > 0.01)
        {
          LogError("IIOApplyHDRGainMap", 270, "FlexGTC headroom (%0.01f) doesn't match target headroom (%0.01f)", v50, v26);
        }
      }
      else
      {
        unint64_t v41 = [v30 generateToneMappingCurveForImage:v11 targetHeadroom:v26];
        CFStringRef v42 = v41;
        if ((gIIODebugFlags & 0x300000) != 0)
        {
          id v43 = [v41 description];
          ImageIOLog("☀️  generated FlexGTC info: %s\n", (const char *)[v43 UTF8String]);
        }
        if (v42)
        {
          [(HDRImage *)v17 colorSpace];
          CopyWithFlexGTCInfo = (CGColorSpace *)IIO_ColorSpaceCreateCopyWithFlexGTCInfo();
          uint64_t v45 = CopyWithFlexGTCInfo;
          if ((gIIODebugFlags & 0x300000) != 0)
          {
            v46 = (id) CFCopyDescription(CopyWithFlexGTCInfo);
            ImageIOLog("☀️  generated FlexGTC space: %s\n", (const char *)[(__CFString *)v46 UTF8String]);
          }
          if (v45)
          {
            gFunc_CVImageBufferSetColorSpace(v49, v45);
            CGColorSpaceRelease(v45);
          }
          else
          {
            LogError("IIOApplyHDRGainMap", 283, "Failed to generate FlexGTC color space");
          }
        }
        else
        {
          LogError("IIOApplyHDRGainMap", 286, "Failed to generate FlexGTC info");
        }
      }
    }
  }
  if (v31) {
    uint64_t v47 = 0;
  }
  else {
    uint64_t v47 = 4294967246;
  }

  return v47;
}

void sub_188613C28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CGImageCreateHDRGainMap(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  IIOInitDebugFlags();
  IIO_LoadJPEGSymbols();

  return IIOConvertHDRGainMap(a1, 0, a2, a3, 0, a4);
}

uint64_t IIOCreateHDRGainMap(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  return IIOConvertHDRGainMap(a1, 0, a2, a3, 0, a4);
}

uint64_t CGImageConvertHDRGainMap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CGImageMetadata **a5, void *a6)
{
  IIOInitDebugFlags();
  IIO_LoadCMPhotoSymbols();

  return IIOConvertHDRGainMap(a1, a2, a3, a4, a5, a6);
}

uint64_t IIOConvertHDRGainMap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, CGImageMetadata **a5, void *a6)
{
  uint64_t v12 = (void *)MEMORY[0x18C11CF40]();
  id v13 = a6;
  CFTypeID v14 = [v13 objectForKeyedSubscript:@"kCGImageAuxiliaryDataInfoMetadata"];

  uint64_t v15 = [[HDRImage alloc] initWithImageBuffer:a1 gainMapBuffer:a2 gainMapMetadata:v14 imageProperties:v13];
  if ([(HDRImage *)v15 type] == 6)
  {
    v16 = [v13 objectForKeyedSubscript:@"kCGFlexRangeAlternateColorSpace"];

    if (v16)
    {
      CFTypeID v17 = CFGetTypeID(v16);
      if (v17 == CGColorSpaceGetTypeID())
      {
        int v18 = [(HDRImage *)v15 flexRangeParams];
        [v18 setAlternateColorSpace:v16];
      }
      else
      {
        LogError("IIOConvertHDRGainMap", 326, "kCGFlexRangeAlternateColorSpace option must be a CGColorSpace object");
      }
    }
    else
    {
      LogError("IIOConvertHDRGainMap", 324, "kCGFlexRangeAlternateColorSpace option must be set for FlexRange");
    }
  }
  unsigned int v19 = [v13 objectForKeyedSubscript:@"Orientation"];

  if (v19)
  {
    float v20 = [v13 objectForKeyedSubscript:@"Orientation"];
    -[HDRImage setGainMapOrientation:](v15, "setGainMapOrientation:", [v20 intValue]);
  }
  float v21 = [v13 objectForKeyedSubscript:@"kCGTargetHeadroom"];

  if (v21)
  {
    float v22 = [v13 objectForKeyedSubscript:@"kCGTargetHeadroom"];
    [v22 floatValue];
    double v24 = v23;
  }
  else
  {
    double v24 = 8.0;
  }
  [(HDRImage *)v15 headroom];
  double v26 = v25;
  if (v24 <= v26) {
    double v27 = v24;
  }
  else {
    double v27 = v26;
  }
  if ((gIIODebugFlags & 0x300000) != 0)
  {
    [(HDRImage *)v15 headroom];
    ImageIOLog("☀️  gain map headroom: %0.1f requested: %0.1f -> %0.1f\n", v28, v24, v27);
  }
  float v29 = [v13 objectForKeyedSubscript:@"kCGFlexRangeOptions"];
  if (v29 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
  {
    *(float *)&double v30 = v27;
    int v31 = +[HDRImage flexRangeParametersWithHeadroom:v29 options:v30];
  }
  else
  {
    int v31 = 0;
  }
  id v32 = [[HDRImage alloc] initWithImageBuffer:a3 gainMapBuffer:a4 flexRangeParameters:v31];
  float v33 = v27;
  *(float *)&double v34 = v33;
  [(HDRImage *)v32 setHeadroom:v34];
  int v35 = +[HDRImageConverter imageConverterWithOptions:v13];
  if ([v35 convertImage:v15 toImage:v32]
    && (!v31
      ? (*(float *)&double v36 = v33,
         int v37 = +[HDRImage createGainMapMetadataWithHeadroom:](HDRImage, "createGainMapMetadataWithHeadroom:", v36)): (int v37 = (CGImageMetadata *)[v31 createFlexRangeMetadata]), v37))
  {
    uint64_t v38 = 0;
    if (a5) {
      *a5 = v37;
    }
  }
  else
  {
    uint64_t v38 = 4294967246;
  }

  return v38;
}

void sub_188614120(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CGImageCreateFlexGTCInfo(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  IIOInitDebugFlags();
  IIO_LoadJPEGSymbols();

  return IIOCreateHDRFlexGTCInfo(a1, a2, a3, a4);
}

uint64_t IIOCreateHDRFlexGTCInfo(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  unsigned int v8 = (void *)MEMORY[0x18C11CF40]();
  id v9 = a4;
  id v10 = [v9 objectForKeyedSubscript:@"kCGImageAuxiliaryDataInfoMetadata"];

  CFStringRef v11 = [[HDRImage alloc] initWithImageBuffer:a1 gainMapBuffer:a2 gainMapMetadata:v10 imageProperties:v9];
  if ([(HDRImage *)v11 type] == 6)
  {
    uint64_t v12 = [v9 objectForKeyedSubscript:@"kCGFlexRangeAlternateColorSpace"];

    if (v12)
    {
      CFTypeID v13 = CFGetTypeID(v12);
      if (v13 == CGColorSpaceGetTypeID())
      {
        CFTypeID v14 = [(HDRImage *)v11 flexRangeParams];
        [v14 setAlternateColorSpace:v12];
      }
      else
      {
        LogError("IIOCreateHDRFlexGTCInfo", 400, "kCGFlexRangeAlternateColorSpace option must be a CGColorSpace object");
      }
    }
    else
    {
      LogError("IIOCreateHDRFlexGTCInfo", 398, "kCGFlexRangeAlternateColorSpace option must be set for FlexRange");
    }
  }
  uint64_t v15 = [v9 objectForKeyedSubscript:@"Orientation"];

  if (v15)
  {
    v16 = [v9 objectForKeyedSubscript:@"Orientation"];
    -[HDRImage setGainMapOrientation:](v11, "setGainMapOrientation:", [v16 intValue]);
  }
  CFTypeID v17 = [v9 objectForKeyedSubscript:@"kCGTargetHeadroom"];

  if (v17)
  {
    int v18 = [v9 objectForKeyedSubscript:@"kCGTargetHeadroom"];
    [v18 floatValue];
    double v20 = v19;
  }
  else
  {
    double v20 = 8.0;
  }
  [(HDRImage *)v11 headroom];
  double v22 = v21;
  if (v20 <= v22) {
    double v23 = v20;
  }
  else {
    double v23 = v22;
  }
  if ((gIIODebugFlags & 0x300000) != 0)
  {
    [(HDRImage *)v11 headroom];
    ImageIOLog("☀️ FlexGTC gain map headroom: %0.1f requested: %0.1f -> %0.1f\n", v24, v20, v23);
  }
  float v25 = +[HDRImageConverter imageConverterWithOptions:v9];
  double v26 = [v25 generateToneMappingCurveForImage:v11 targetHeadroom:v23];
  double v27 = v26;
  if ((gIIODebugFlags & 0x300000) != 0)
  {
    id v28 = [v26 description];
    ImageIOLog("☀️ FlexGTC curve data: %s", (const char *)[v28 UTF8String]);
  }
  if (a3 && v27) {
    *a3 = v27;
  }
  if (v27) {
    uint64_t v29 = 0;
  }
  else {
    uint64_t v29 = 4294967246;
  }

  return v29;
}

void sub_1886144B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CGImageCreateFlexRangeMetadata(uint64_t a1, uint64_t *a2)
{
  IIOInitDebugFlags();
  IIO_LoadCMPhotoSymbols();

  return IIOCreateFlexRangeMetadataFromDictionary(a1, a2);
}

uint64_t IIOCreateFlexRangeMetadataFromDictionary(uint64_t a1, uint64_t *a2)
{
  CFStringRef v3 = +[HDRFlexRangeParameters flexRangeParametersFromDictionary:a1];
  uint64_t v4 = v3;
  if (v3 && (uint64_t v5 = [v3 createFlexRangeMetadata]) != 0)
  {
    uint64_t v6 = 0;
    *a2 = v5;
  }
  else
  {
    uint64_t v6 = 4294967246;
  }

  return v6;
}

void sub_1886145CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CGImageCreateFlexRangeDictionary(uint64_t a1, void *a2)
{
  IIOInitDebugFlags();
  IIO_LoadCMPhotoSymbols();

  return IIOCreateFlexRangeDictionaryFromMetadata(a1, a2);
}

uint64_t IIOCreateFlexRangeDictionaryFromMetadata(uint64_t a1, void *a2)
{
  CFStringRef v3 = +[HDRFlexRangeParameters flexRangeParametersFromMetadata:a1];
  uint64_t v4 = v3;
  if (v3)
  {
    uint64_t v5 = [v3 createFlexRangeDictionary];
    uint64_t v6 = v5;
    if (v5)
    {
      uint64_t v7 = 0;
      *a2 = v5;
    }
    else
    {
      uint64_t v7 = 4294967246;
    }
  }
  else
  {
    uint64_t v7 = 4294967246;
  }

  return v7;
}

void sub_1886146A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double CGImageGetHDRGainMapHeadroom(uint64_t a1, uint64_t a2)
{
  return IIOHDRGainMapMetadataGetHeadroom(a1, a2);
}

float IIOHDRGainMapMetadataGetHeadroom(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void *)MEMORY[0x18C11CF40]();
  if (a1)
  {
    uint64_t v5 = +[HDRFlexRangeParameters flexRangeParametersFromMetadata:a1];
    uint64_t v6 = v5;
    if (v5)
    {
      [v5 baseHeadroom];
      float v8 = v7;
      [v6 alternateHeadroom];
      float v10 = exp2(fmaxf(v8, v9));
LABEL_6:

      goto LABEL_10;
    }
    float v13 = 0.0;
    if (+[HDRImage getGainMapHeadroom:&v13 fromMetadata:a1])
    {
      float v10 = v13;
      goto LABEL_6;
    }
  }
  float v12 = 0.0;
  if (+[HDRImage getGainMapHeadroom:&v12 fromProperties:a2])
  {
    float v10 = v12;
  }
  else
  {
    float v10 = 1.0;
  }
LABEL_10:
  return v10;
}

void sub_1886147D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double CGImageGetHDRPixelBufferHeadroom(uint64_t a1)
{
  return IIOHDRPixelBufferGetHeadroom(a1);
}

float IIOHDRPixelBufferGetHeadroom(uint64_t a1)
{
  if (a1)
  {
    CFTypeID v2 = (void *)MEMORY[0x18C11CF40]();
    CFStringRef v3 = (void *)gFunc_CVBufferCopyAttachment(a1, *(void *)gIIO_kCVImageBufferTransferFunctionKey, 0);
    uint64_t v4 = v3;
    if (v3)
    {
      if ([v3 isEqualToString:*(void *)gIIO_kCVImageBufferTransferFunction_ITU_R_2100_HLG]) {
        goto LABEL_9;
      }
      int v5 = [v4 isEqualToString:*(void *)gIIO_kCVImageBufferTransferFunction_SMPTE_ST_2084_PQ];
    }
    else
    {
      float v7 = (CGColorSpace *)gFunc_CVBufferCopyAttachment(a1, *(void *)gIIO_kCVImageBufferCGColorSpaceKey, 0);
      float v8 = v7;
      if (!v7)
      {
        float v6 = 1.0;
        goto LABEL_33;
      }
      int v5 = CGColorSpaceUsesITUR_2100TF(v7);
      CGColorSpaceRelease(v8);
    }
    float v6 = 1.0;
    if (v5)
    {
LABEL_9:
      float v9 = (void *)gFunc_CVBufferCopyAttachment(a1, @"IOSurfaceContentHeadroom", 0);
      if (v9
        || (IOSurface = (__IOSurface *)gFunc_CVPixelBufferGetIOSurface(a1)) != 0
        && (float v9 = (void *)IOSurfaceCopyValue(IOSurface, @"IOSurfaceContentHeadroom")) != 0)
      {
        [v9 floatValue];
        float v6 = v10;
      }
      else
      {
        float v12 = (void *)gFunc_CVBufferCopyAttachment(a1, *(void *)gIIO_kCVImageBufferMasteringDisplayColorVolumeKey, 0);
        float v13 = v12;
        if (v12 && [v12 length] == 24) {
          unsigned int v14 = *(_DWORD *)([v13 bytes] + 16);
        }
        else {
          unsigned int v14 = 0;
        }
        uint64_t v15 = (void *)gFunc_CVBufferCopyAttachment(a1, *(void *)gIIO_kCVImageBufferContentLightLevelInfoKey, 0);
        v16 = v15;
        if (v15 && [v15 length] == 4) {
          unsigned int v17 = *(unsigned __int16 *)[v16 bytes];
        }
        else {
          unsigned int v17 = 0;
        }
        float v18 = (float)__rev16(v17);
        float v19 = (float)bswap32(v14) * 0.0001;
        float v20 = 1000.0;
        if (v13) {
          float v20 = v19;
        }
        if (v19 <= v18 && v13 != 0) {
          float v18 = v19;
        }
        if (!v16) {
          float v18 = v20;
        }
        float v6 = fmaxf(v18 / 203.0, 1.0);

        float v9 = 0;
      }
    }
LABEL_33:

    return v6;
  }
  return 0.0;
}

void sub_188614A94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t IIOCreateHDRGainMapMetadata(CGImageMetadata **a1, float a2)
{
  uint64_t v4 = (void *)MEMORY[0x18C11CF40]();
  *(float *)&double v5 = a2;
  float v6 = +[HDRImage createGainMapMetadataWithHeadroom:v5];
  if (a1) {
    *a1 = v6;
  }
  if (v6) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = 4294967246;
  }
  return v7;
}

uint64_t IIODefaultHDRColorSpace(CGColorSpace *a1)
{
  if (a1) {
    CGColorSpaceGetCICPInfo();
  }
  return *MEMORY[0x1E4F1DC50];
}

uint64_t IIODefaultHDRYCCMatrix(CGColorSpace *a1)
{
  if (a1) {
    CGColorSpaceGetCICPInfo();
  }
  return *(void *)gIIO_kCVImageBufferYCbCrMatrix_ITU_R_601_4;
}

void sub_188614F30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1886151A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18861542C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18861566C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188615CB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void sub_188615EF8(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void sub_188615F80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188616180(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1886164A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_188616868(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188616988(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t xdr_CVPixelBufferCopyColorSpace(__CVBuffer *a1)
{
  uint64_t ColorSpaceFromAttachments = gFunc_CVBufferCopyAttachment(a1, *(void *)gIIO_kCVImageBufferCGColorSpaceKey, 0);
  if (!ColorSpaceFromAttachments)
  {
    CFStringRef v3 = (void *)gFunc_CVBufferCopyAttachments(a1, 1);
    uint64_t ColorSpaceFromAttachments = gFunc_CVImageBufferCreateColorSpaceFromAttachments();
  }
  return ColorSpaceFromAttachments;
}

void sub_188616A1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188616B54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188616D94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188616FD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188617078(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)HDRImage;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void __clang_call_terminate(void *a1)
{
}

void sub_188617468(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188617628(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188617760(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1886178F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188617A48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188617B78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188617C94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188617DB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1886181B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188618D8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,char a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a49, 8);
  _Block_object_dispose(&a60, 8);
  _Block_object_dispose(&a64, 8);
  _Block_object_dispose(&STACK[0x210], 8);
  _Block_object_dispose(&STACK[0x230], 8);
  _Block_object_dispose(&STACK[0x288], 8);
  _Block_object_dispose(&STACK[0x2A8], 8);
  _Block_object_dispose(&STACK[0x300], 8);
  _Block_object_dispose(&STACK[0x320], 8);
  _Block_object_dispose(&STACK[0x380], 8);
  _Block_object_dispose(&STACK[0x3A0], 8);
  _Block_object_dispose(&STACK[0x3F8], 8);
  _Block_object_dispose(&STACK[0x418], 8);
  _Block_object_dispose((const void *)(v66 - 248), 8);
  _Block_object_dispose((const void *)(v66 - 216), 8);
  _Block_object_dispose((const void *)(v66 - 128), 8);

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

__n128 __Block_byref_object_copy__64(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v3;
  *(__n128 *)(a1 + 48) = result;
  return result;
}

__n128 __Block_byref_object_copy__67(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 48);
  long long v3 = *(_OWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  return result;
}

void sub_18861911C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188619280(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188619430(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1886195E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188619938(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188619F80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18861A0E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18861A804(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18861A924(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18861A99C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18861AA14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18861AE40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18861AED4()
{
}

id HDRPixelTransformInDescription(uint64_t a1)
{
  uint64_t v2 = objc_msgSend(NSString, "stringWithFormat:", @"[%g,%g,%g,%g,%g,%g]", COERCE_FLOAT(*(void *)(a1 + 96)), COERCE_FLOAT(HIDWORD(*(void *)(a1 + 96))), COERCE_FLOAT(*(void *)(a1 + 104)), COERCE_FLOAT(HIDWORD(*(void *)(a1 + 104))), COERCE_FLOAT(*(void *)(a1 + 112)), COERCE_FLOAT(HIDWORD(*(void *)(a1 + 112))));
  long long v3 = (void *)v2;
  uint64_t v4 = NSString;
  double v5 = @"RGB";
  switch(*(_DWORD *)a1)
  {
    case 0:
      double v5 = @"N/A";
      goto LABEL_6;
    case 1:
      goto LABEL_6;
    case 2:
      float v6 = YCCMatrixToString(*(simd_float3x3 *)(a1 + 48));
      uint64_t v7 = HDRPixelRangeToString(*(__n128 *)(a1 + 16), *(__n128 *)(a1 + 32));
      float v8 = [v4 stringWithFormat:@"%@ %@ %@ affine: %@", @"YCC", v6, v7, v3];

      goto LABEL_7;
    case 3:
      double v5 = @"Y";
      goto LABEL_6;
    default:
      double v5 = @"???";
LABEL_6:
      float v8 = [NSString stringWithFormat:@"%@ affine: %@", v5, v2];
LABEL_7:

      return v8;
  }
}

void sub_18861B044(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__CFString *HDRColorTRCToString(uint64_t a1)
{
  uint64_t v1 = @"none";
  switch(*(_DWORD *)a1)
  {
    case 0:
      goto LABEL_23;
    case 1:
      objc_msgSend(NSString, "stringWithFormat:", @"Y = X^%g", *(float *)(a1 + 44), v7, v8, v9, v10, v11, v12, v13);
      goto LABEL_22;
    case 2:
      [NSString stringWithFormat:@"Y = (%g*X+%g)^%g [X >= %g], Y = 0 [X < %g]", *(float *)(a1 + 16), *(float *)(a1 + 20), *(float *)(a1 + 44), (float)((float)-*(float *)(a1 + 20) / *(float *)(a1 + 16)), (float)((float)-*(float *)(a1 + 20) / *(float *)(a1 + 16)), v11, v12, v13];
      goto LABEL_22;
    case 3:
      [NSString stringWithFormat:@"Y = (%g*X+%g)^%g + %g [X >= %g], Y = %g [X < %g]", *(float *)(a1 + 16), *(float *)(a1 + 20), *(float *)(a1 + 44), *(float *)(a1 + 24), (float)((float)-*(float *)(a1 + 20) / *(float *)(a1 + 16)), *(float *)(a1 + 24), (float)((float)-*(float *)(a1 + 20) / *(float *)(a1 + 16)), v13];
      goto LABEL_22;
    case 4:
      double v2 = *(float *)(a1 + 44);
      double v3 = *(float *)(a1 + 28);
      if (fabs(v2 + -2.4) < 0.0000999999975
        && fabs(v3 + -0.04045) < 0.0000999999975
        && fabs(*(float *)(a1 + 24) + -0.0773993808) < 0.0000999999975)
      {
        uint64_t v1 = @"sRGB -> Linear";
        goto LABEL_23;
      }
      [NSString stringWithFormat:@"Y = (%g*X+%g)^%g [X >= %g], Y = %g*X [X < %g]", *(float *)(a1 + 16), *(float *)(a1 + 20), *(void *)&v2, *(void *)&v3, *(float *)(a1 + 24), *(void *)&v3, v12, v13];
      goto LABEL_22;
    case 5:
      double v4 = *(float *)(a1 + 44);
      double v5 = *(float *)(a1 + 28);
      if (fabs(v4 + -0.416666667) >= 0.0000999999975
        || fabs(v5 + -0.00313080495) >= 0.0000999999975
        || fabs(*(float *)(a1 + 24) + -12.92) >= 0.0000999999975)
      {
        [NSString stringWithFormat:@"Y = (%g*X+%g)^%g + %g [X >= %g], Y = %g*X + %g [X < %g]", *(float *)(a1 + 16), *(float *)(a1 + 20), *(void *)&v4, *(float *)(a1 + 32), *(void *)&v5, *(float *)(a1 + 24), *(float *)(a1 + 36), *(void *)&v5];
LABEL_22:
        uint64_t v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        uint64_t v1 = @"Linear -> sRGB";
      }
LABEL_23:
      return v1;
    case 6:
      uint64_t v1 = @"LUT";
      goto LABEL_23;
    case 7:
      objc_msgSend(NSString, "stringWithFormat:", @"PQ EOTF (scale=%g)", *(float *)(a1 + 36), v7, v8, v9, v10, v11, v12, v13);
      goto LABEL_22;
    case 8:
      objc_msgSend(NSString, "stringWithFormat:", @"PQ EOTF Inv (scale=%g)", *(float *)(a1 + 36), v7, v8, v9, v10, v11, v12, v13);
      goto LABEL_22;
    case 9:
      [NSString stringWithFormat:@"HLG EOTF (scale=%g, black=%g)", (float)(*(float *)(a1 + 28) * 12.0), *(float *)(a1 + 36), v8, v9, v10, v11, v12, v13];
      goto LABEL_22;
    case 0xA:
      [NSString stringWithFormat:@"HLG EOTF Inv (scale=%g, black=%g)", *(float *)(a1 + 32), *(float *)(a1 + 36), v8, v9, v10, v11, v12, v13];
      goto LABEL_22;
    case 0xB:
      [NSString stringWithFormat:@"HLG EOTF Inv (scale=%g, black=%g) x OOTF (scale=%g, gamma=%g)", *(float *)(a1 + 32), *(float *)(a1 + 36), *(float *)(a1 + 40), (float)(*(float *)(a1 + 44) + 1.0), v10, v11, v12, v13];
      goto LABEL_22;
    default:
      uint64_t v1 = @"????";
      goto LABEL_23;
  }
}

__CFString *HDRColorMatrixToString(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v1 = @"identity";
  }
  else
  {
    double v2 = COERCE_FLOAT(*(_OWORD *)a1);
    double v3 = COERCE_FLOAT(HIDWORD(*(void *)(a1 + 16)));
    if (vabdd_f64(v2 / 0.822426, v3 / 0.96679826) >= 0.0000999999975
      || fabs(v3 / 0.96679826 + *(float *)(a1 + 40) / -0.9105512) >= 0.0000999999975)
    {
      if (vabdd_f64(v2 / 1.22500277, v3 / 1.04207075) >= 0.0000999999975
        || fabs(v3 / 1.04207075 + *(float *)(a1 + 40) / -1.09823489) >= 0.0000999999975)
      {
        if (vabdd_f64(v2 / 0.62737658, v3 / 0.91951445) >= 0.0000999999975
          || fabs(v3 / 0.91951445 + *(float *)(a1 + 40) / -0.895617337) >= 0.0000999999975)
        {
          double v4 = *(float *)(a1 + 40);
          if (vabdd_f64(v2 / 1.66059811, v3 / 1.1329555) >= 0.0000999999975
            || fabs(v3 / 1.1329555 + v4 / -1.1187012) >= 0.0000999999975)
          {
            objc_msgSend(NSString, "stringWithFormat:", @"{{%f,%f,%f},{%f,%f,%f},{%f,%f,%f}}", *(void *)&v2, COERCE_FLOAT(HIDWORD(*(void *)a1)), COERCE_FLOAT(*(void *)(a1 + 8)), COERCE_FLOAT(*(_OWORD *)(a1 + 16)), *(void *)&v3, COERCE_FLOAT(*(void *)(a1 + 24)), *(float *)(a1 + 32), *(float *)(a1 + 36), *(void *)&v4);
          }
          else
          {
            objc_msgSend(NSString, "stringWithFormat:", @"BT.2020 -> sRGB (scale=%g)", v3 / 1.1329555, v6, v7, v8, v9, v10, v11, v12, v13);
          }
        }
        else
        {
          objc_msgSend(NSString, "stringWithFormat:", @"sRGB -> BT.2020 (scale=%g)", v3 / 0.91951445, v6, v7, v8, v9, v10, v11, v12, v13);
        }
      }
      else
      {
        objc_msgSend(NSString, "stringWithFormat:", @"P3 -> sRGB (scale=%g)", v3 / 1.04207075, v6, v7, v8, v9, v10, v11, v12, v13);
      }
    }
    else
    {
      objc_msgSend(NSString, "stringWithFormat:", @"sRGB -> P3 (scale=%g)", v3 / 0.96679826, v6, v7, v8, v9, v10, v11, v12, v13);
    }
    uint64_t v1 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }

  return v1;
}

__CFString *HDRToneMappingToString(uint64_t a1)
{
  switch(*(_DWORD *)a1)
  {
    case 0:
      double v2 = @"none";
      break;
    case 1:
      double v3 = NSString;
      float v4 = *(float *)(a1 + 40);
      double v5 = @"PQ EETF (scale=%g)";
      goto LABEL_10;
    case 2:
      uint64_t v6 = [NSString stringWithFormat:@"HLG OOTF (scale=%g, gamma=%g)", *(float *)(a1 + 40), (float)(*(float *)(a1 + 44) + 1.0)];
      goto LABEL_11;
    case 3:
      double v2 = @"EXR Tone Mapping";
      break;
    case 4:
      double v3 = NSString;
      float v4 = *(float *)(a1 + 36);
      double v5 = @"RWTMO (scale=%g)";
      goto LABEL_10;
    case 5:
      double v3 = NSString;
      float v4 = *(float *)(a1 + 40);
      double v5 = @"FlexGTC (scale=%g)";
      goto LABEL_10;
    case 6:
      double v3 = NSString;
      float v4 = cbrtf((float)(unint64_t)[*(id *)(a1 + 64) length] * 0.125);
      double v5 = @"3D-LUT (grid=%0.f)";
LABEL_10:
      uint64_t v6 = objc_msgSend(v3, "stringWithFormat:", v5, v4);
LABEL_11:
      double v2 = (__CFString *)v6;
      break;
    default:
      double v2 = @"???";
      break;
  }
  if (!*(unsigned char *)(a1 + 128))
  {
    long long v7 = *(_OWORD *)(a1 + 96);
    v19[0] = *(_OWORD *)(a1 + 80);
    v19[1] = v7;
    long long v8 = *(_OWORD *)(a1 + 128);
    v19[2] = *(_OWORD *)(a1 + 112);
    void v19[3] = v8;
    uint64_t v9 = HDRColorMatrixToString((uint64_t)v19);
    uint64_t v10 = [(__CFString *)v2 stringByAppendingFormat:@" MAT(pre):%@", v9];

    double v2 = (__CFString *)v10;
  }
  int v12 = *(_DWORD *)(a1 + 144);
  uint64_t v11 = (_OWORD *)(a1 + 144);
  if (v12)
  {
    long long v13 = v11[3];
    v18[2] = v11[2];
    v18[3] = v13;
    v18[4] = v11[4];
    long long v14 = v11[1];
    v18[0] = *v11;
    v18[1] = v14;
    uint64_t v15 = HDRColorTRCToString((uint64_t)v18);
    uint64_t v16 = [(__CFString *)v2 stringByAppendingFormat:@" TRC(post):%@", v15];

    double v2 = (__CFString *)v16;
  }

  return v2;
}

void sub_18861B850(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__CFString *HDRGainMappingToString(float *a1)
{
  float v1 = *a1;
  if (!*(_DWORD *)a1)
  {
    double v2 = @"none";
    goto LABEL_9;
  }
  if (LODWORD(v1) == 2)
  {
    float v3 = a1[24];
    float v4 = a1[25];
    double v45 = v3;
    float v5 = a1[26];
    float v6 = a1[8];
    float v7 = a1[9];
    double v44 = v6;
    float v8 = a1[10];
    double v42 = a1[5];
    double v43 = a1[4];
    float v9 = a1[12];
    float v10 = a1[13];
    double v40 = v9;
    double v41 = a1[6];
    float v11 = a1[14];
    double v39 = v10;
    double v38 = a1[16];
    double v35 = a1[18];
    double v36 = a1[17];
    double v34 = a1[20];
    double v12 = a1[21];
    double v13 = a1[22];
    long long v14 = NSString;
    double v37 = exp2f(v3 * (float)(v6 + v9));
    double v15 = exp2f(v4 * (float)(v7 + v10));
    objc_msgSend(v14, "stringWithFormat:", @"FlexRange {Y = 2^([%g,%g,%g]*([%g,%g,%g] * (G^[%g,%g,%g]) + [%g,%g,%g])) * (X + [%g,%g,%g]) - [%g,%g,%g]} (headroom=[%g,%g,%g])", *(void *)&v45, v4, v5, *(void *)&v44, v7, v8, *(void *)&v43, *(void *)&v42, *(void *)&v41, *(void *)&v40, *(void *)&v39, v11, *(void *)&v38, *(void *)&v36, *(void *)&v35, *(void *)&v34,
      *(void *)&v12,
      *(void *)&v13,
      *(void *)&v37,
      *(void *)&v15,
      exp2f(v5 * (float)(v8 + v11)));
    goto LABEL_7;
  }
  if (LODWORD(v1) == 1)
  {
    objc_msgSend(NSString, "stringWithFormat:", @"Meteor+ {Y = (%g * (G^%g) + %g) * X} (headroom=%g)", a1[8], a1[4], a1[12], (float)(a1[8] + 1.0), v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28,
      v29,
      v30,
      v31,
      v32,
      v33);
LABEL_7:
    double v2 = (__CFString *)objc_claimAutoreleasedReturnValue();
    goto LABEL_9;
  }
  double v2 = @"???";
LABEL_9:

  return v2;
}

void sub_18861BEA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18861BF44()
{
}

id HDRPixelTransformOutDescription(simd_float3x3 *a1)
{
  if (a1->columns[0].i32[0] == 2)
  {
    int16x4_t v2 = *(int16x4_t *)a1[2].columns[0].f32;
    uint16x4_t v3 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x200020001);
    v3.i16[3] = v3.i16[2];
    if ((vminv_u16(v3) & 0x8000) != 0)
    {
      long long v14 = @"420";
    }
    else
    {
      uint16x4_t v4 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x400040002);
      v4.i16[3] = v4.i16[2];
      if ((vminv_u16(v4) & 0x8000) != 0)
      {
        long long v14 = @"420/2";
      }
      else
      {
        uint16x4_t v5 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x800080004);
        v5.i16[3] = v5.i16[2];
        if ((vminv_u16(v5) & 0x8000) != 0)
        {
          long long v14 = @"420/4";
        }
        else
        {
          uint16x4_t v6 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x100020001);
          v6.i16[3] = v6.i16[2];
          if ((vminv_u16(v6) & 0x8000) != 0)
          {
            long long v14 = @"422";
          }
          else
          {
            uint16x4_t v7 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x200040002);
            v7.i16[3] = v7.i16[2];
            if ((vminv_u16(v7) & 0x8000) != 0)
            {
              long long v14 = @"422/2";
            }
            else
            {
              uint16x4_t v8 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x400080004);
              v8.i16[3] = v8.i16[2];
              if ((vminv_u16(v8) & 0x8000) != 0)
              {
                long long v14 = @"422/4";
              }
              else
              {
                uint16x4_t v9 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x1000100010001);
                v9.i16[3] = v9.i16[2];
                if ((vminv_u16(v9) & 0x8000) != 0)
                {
                  long long v14 = @"444";
                }
                else
                {
                  uint16x4_t v10 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x2000200020002);
                  v10.i16[3] = v10.i16[2];
                  unsigned __int16 v11 = vminv_u16(v10);
                  uint16x4_t v12 = (uint16x4_t)vceq_s16(v2, (int16x4_t)0x4000400040004);
                  v12.i16[3] = v12.i16[2];
                  if ((vminv_u16(v12) & 0x8000) != 0) {
                    double v13 = @"444/4";
                  }
                  else {
                    double v13 = 0;
                  }
                  if ((v11 & 0x8000) != 0) {
                    long long v14 = @"444/2";
                  }
                  else {
                    long long v14 = v13;
                  }
                }
              }
            }
          }
        }
      }
    }
    uint64_t v18 = a1->columns[0].i32[0];
    if (v18 > 3) {
      uint64_t v19 = @"???";
    }
    else {
      uint64_t v19 = off_1E53C05D8[v18];
    }
    uint64_t v20 = NSString;
    uint64_t v21 = YCCMatrixToString(a1[1]);
    uint64_t v22 = HDRPixelRangeToString((__n128)a1->columns[1], (__n128)a1->columns[2]);
    uint64_t v17 = [v20 stringWithFormat:@"%@ %@ %@ subsample: %@", v19, v21, v22, v14];
  }
  else
  {
    objc_msgSend(NSString, "stringWithFormat:", @"1/%u", a1[2].columns[0].u16[0]);
    long long v14 = (__CFString *)objc_claimAutoreleasedReturnValue();
    uint64_t v15 = a1->columns[0].i32[0];
    if (v15 > 3) {
      uint64_t v16 = @"???";
    }
    else {
      uint64_t v16 = off_1E53C05D8[v15];
    }
    uint64_t v17 = [NSString stringWithFormat:@"%@ subsample: %@", v16, v14];
  }

  return v17;
}

void sub_18861C1E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__CFString *YCCMatrixToString(simd_float3x3 a1)
{
  double v1 = a1.columns[2].f32[0];
  if (fabs(v1 + -1.402) < 0.001 && fabs(a1.columns[1].f32[2] + -1.772) < 0.001) {
    return @"601(in)";
  }
  if (fabs(v1 + -1.5748) < 0.0001 && fabs(a1.columns[1].f32[2] + -1.8556) < 0.0001) {
    return @"709(in)";
  }
  if (fabs(v1 + -1.4746) < 0.0001 && fabs(a1.columns[1].f32[2] + -1.8814) < 0.0001) {
    return @"2020(in)";
  }
  double v3 = a1.columns[0].f32[0];
  if (fabs(v3 + -0.299) < 0.001 && fabs(a1.columns[1].f32[0] + -0.587) < 0.001 && fabs(v1 + -0.114) < 0.001) {
    return @"601(out)";
  }
  if (fabs(v3 + -0.2126) < 0.0001 && fabs(a1.columns[1].f32[0] + -0.7152) < 0.0001 && fabs(v1 + -0.0722) < 0.0001) {
    return @"709(out)";
  }
  if (fabs(v3 + -0.2627) >= 0.0001 || fabs(a1.columns[1].f32[0] + -0.678) >= 0.0001 || fabs(v1 + -0.0593) >= 0.0001) {
    return @"???";
  }
  return @"2020(out)";
}

__CFString *HDRPixelRangeToString(__n128 a1, __n128 a2)
{
  BOOL v4 = a1.n128_f32[0] == 1.0 && a1.n128_f32[1] == 1.0;
  if (v4 && a2.n128_f32[0] == 0.0 && a2.n128_f32[1] == 0.0)
  {
    uint16x4_t v5 = @"Full Range";
    return v5;
  }
  if (fabs(a1.n128_f32[0] + -1.0) >= 0.0000999999975) {
    goto LABEL_27;
  }
  if (fabsf(a1.n128_f32[1] + -1.0039) < 0.0001 || fabsf(a1.n128_f32[1] + -0.99608) < 0.0001)
  {
    uint16x4_t v5 = @"Full Range (8-bits)";
    goto LABEL_45;
  }
  if (fabsf(a1.n128_f32[1] + -1.001) < 0.0001 || fabsf(a1.n128_f32[1] + -0.99902) < 0.0001)
  {
    uint16x4_t v5 = @"Full Range (10-bits)";
    goto LABEL_45;
  }
  if (fabsf(a1.n128_f32[1] + -1.0002) < 0.0001 || fabsf(a1.n128_f32[1] + -0.99976) < 0.0001)
  {
    uint16x4_t v5 = @"Full Range (12-bits)";
    goto LABEL_45;
  }
  if (fabsf(a1.n128_f32[1] + -1.0) >= 0.0001 && fabsf(a1.n128_f32[1] + -0.99998) >= 0.0001)
  {
LABEL_27:
    if ((fabsf(a1.n128_f32[0] + -1.1644) >= 0.0001 || fabsf(a1.n128_f32[1] + -1.1384) >= 0.0001)
      && (fabsf(a1.n128_f32[0] + -0.85882) >= 0.0001 || fabsf(a1.n128_f32[1] + -0.87843) >= 0.0001))
    {
      if ((fabsf(a1.n128_f32[0] + -1.1678) >= 0.0001 || fabsf(a1.n128_f32[1] + -1.1417) >= 0.0001)
        && (fabsf(a1.n128_f32[0] + -0.85631) >= 0.0001 || fabsf(a1.n128_f32[1] + -0.87586) >= 0.0001))
      {
        if ((fabsf(a1.n128_f32[0] + -1.1687) >= 0.0001 || fabsf(a1.n128_f32[1] + -1.1426) >= 0.0001)
          && (fabsf(a1.n128_f32[0] + -0.85568) >= 0.0001 || fabsf(a1.n128_f32[1] + -0.87521) >= 0.0001))
        {
          if ((fabsf(a1.n128_f32[0] + -1.1689) >= 0.0001 || fabsf(a1.n128_f32[1] + -1.1428) >= 0.0001)
            && (fabsf(a1.n128_f32[0] + -0.85548) >= 0.0001 || fabsf(a1.n128_f32[1] + -0.87501) >= 0.0001))
          {
            objc_msgSend(NSString, "stringWithFormat:", @"[scale:(%f,%f,%f) offset:(%f,%f,%f)]", a1.n128_f32[0], a1.n128_f32[1], a1.n128_f32[2], a2.n128_f32[0], a2.n128_f32[1], a2.n128_f32[2], v2);
            uint16x4_t v5 = (__CFString *)objc_claimAutoreleasedReturnValue();
          }
          else
          {
            uint16x4_t v5 = @"Video Range (16-bits)";
          }
        }
        else
        {
          uint16x4_t v5 = @"Video Range (12-bits)";
        }
      }
      else
      {
        uint16x4_t v5 = @"Video Range (10-bits)";
      }
    }
    else
    {
      uint16x4_t v5 = @"Video Range (8-bits)";
    }
    goto LABEL_45;
  }
  uint16x4_t v5 = @"Full Range (16-bits)";
LABEL_45:
  return v5;
}

void sub_18861C8A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18861CD6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

void sub_18861D20C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_18861D5A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18861D670(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18861DC14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void sub_18861E0B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t xdr::PixelFormat::choosePixelFormat(int a1, int a2, void *a3)
{
  if (a1 <= 1278226735)
  {
    if (a1 > 875836533)
    {
      if (a1 > 1278226487)
      {
        if (a1 != 1278226488)
        {
          if (a1 == 1278226534)
          {
            if (!a2)
            {
              if (a3) {
                operator new();
              }
              return 1;
            }
            goto LABEL_91;
          }
          if (a1 == 1278226536)
          {
            if (!a2)
            {
              if (a3) {
                operator new();
              }
              return 1;
            }
            goto LABEL_91;
          }
          goto LABEL_66;
        }
LABEL_48:
        if (!a2)
        {
          if (a3) {
            operator new();
          }
          return 1;
        }
        goto LABEL_91;
      }
      if (a1 != 875836534)
      {
        if (a1 == 1111970369)
        {
          if (!a2)
          {
            if (a3) {
              operator new();
            }
            return 1;
          }
          goto LABEL_91;
        }
        goto LABEL_66;
      }
    }
    else if (a1 <= 875704933)
    {
      if (a1 != 875704422)
      {
        int v7 = 875704438;
LABEL_35:
        if (a1 != v7) {
          goto LABEL_66;
        }
      }
    }
    else if (a1 != 875704934 && a1 != 875704950)
    {
      int v7 = 875836518;
      goto LABEL_35;
    }
    if (a2 == 1)
    {
      if (a3) {
        operator new();
      }
      return 1;
    }
    goto LABEL_48;
  }
  if (a1 > 2016686639)
  {
    if (a1 > 2019963439)
    {
      if (a1 != 2019963440 && a1 != 2019963442)
      {
        int v6 = 2019963956;
LABEL_29:
        if (a1 == v6) {
          goto LABEL_30;
        }
        goto LABEL_66;
      }
    }
    else if (a1 != 2016686640 && a1 != 2016686642)
    {
      int v6 = 2016687156;
      goto LABEL_29;
    }
LABEL_30:
    if (a2)
    {
      if (a3) {
        operator new();
      }
      return 1;
    }
LABEL_63:
    if (a3) {
      operator new();
    }
    return 1;
  }
  if (a1 > 1380411456)
  {
    switch(a1)
    {
      case 1380411457:
        if (!a2)
        {
          if (a3) {
            operator new();
          }
          return 1;
        }
        goto LABEL_91;
      case 1815162994:
        if (!a2)
        {
          if (a3) {
            operator new();
          }
          return 1;
        }
        goto LABEL_91;
      case 1815491698:
        if (!a2)
        {
          if (a3) {
            operator new();
          }
          return 1;
        }
        goto LABEL_91;
    }
LABEL_66:
    unsigned int v9 = a1 >> 24;
    uint64_t v10 = MEMORY[0x1E4F14390];
    if (a1 < 0) {
      int v11 = __maskrune(a1 >> 24, 0x40000uLL);
    }
    else {
      int v11 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v9 + 60) & 0x40000;
    }
    if (v11) {
      uint64_t v12 = v9;
    }
    else {
      uint64_t v12 = 46;
    }
    unsigned int v13 = a1 << 8 >> 24;
    if (a1 << 8 < 0) {
      int v14 = __maskrune(a1 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v14 = *(_DWORD *)(v10 + 4 * v13 + 60) & 0x40000;
    }
    if (v14) {
      uint64_t v15 = v13;
    }
    else {
      uint64_t v15 = 46;
    }
    unsigned int v16 = (__int16)a1 >> 8;
    if (a1 << 16 < 0) {
      int v17 = __maskrune((__int16)a1 >> 8, 0x40000uLL);
    }
    else {
      int v17 = *(_DWORD *)(v10 + 4 * v16 + 60) & 0x40000;
    }
    if (v17) {
      uint64_t v18 = v16;
    }
    else {
      uint64_t v18 = 46;
    }
    if ((a1 << 24) <= 0x7F000000) {
      int v19 = *(_DWORD *)(v10 + 4 * (char)a1 + 60) & 0x40000;
    }
    else {
      int v19 = __maskrune((char)a1, 0x40000uLL);
    }
    if (v19) {
      uint64_t v20 = (char)a1;
    }
    else {
      uint64_t v20 = 46;
    }
    LogError("choosePixelFormat", 292, "Unsupported pixel format: '%c%c%c%c'", v12, v15, v18, v20);
    goto LABEL_91;
  }
  if (a1 != 1278226736)
  {
    if (a1 == 1380410945)
    {
      if (!a2)
      {
        if (a3) {
          operator new();
        }
        return 1;
      }
      goto LABEL_91;
    }
    goto LABEL_66;
  }
  if (!a2) {
    goto LABEL_63;
  }
LABEL_91:
  uint64_t v8 = 0;
  if (a3 && (gIIODebugFlags & 0x300000) != 0)
  {
    unsigned int v21 = a1 >> 24;
    if (a1 < 0) {
      int v22 = __maskrune(a1 >> 24, 0x40000uLL);
    }
    else {
      int v22 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v21 + 60) & 0x40000;
    }
    if (v22) {
      uint64_t v23 = v21;
    }
    else {
      uint64_t v23 = 46;
    }
    unsigned int v24 = a1 << 8 >> 24;
    if (a1 << 8 < 0) {
      int v25 = __maskrune(a1 << 8 >> 24, 0x40000uLL);
    }
    else {
      int v25 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v24 + 60) & 0x40000;
    }
    if (v25) {
      uint64_t v26 = v24;
    }
    else {
      uint64_t v26 = 46;
    }
    unsigned int v27 = (__int16)a1 >> 8;
    if (a1 << 16 < 0) {
      int v28 = __maskrune((__int16)a1 >> 8, 0x40000uLL);
    }
    else {
      int v28 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * v27 + 60) & 0x40000;
    }
    if (v28) {
      uint64_t v29 = v27;
    }
    else {
      uint64_t v29 = 46;
    }
    if ((a1 << 24) <= 0x7F000000) {
      int v30 = *(_DWORD *)(MEMORY[0x1E4F14390] + 4 * (char)a1 + 60) & 0x40000;
    }
    else {
      int v30 = __maskrune((char)a1, 0x40000uLL);
    }
    if (v30) {
      uint64_t v31 = (char)a1;
    }
    else {
      uint64_t v31 = 46;
    }
    if (*a3) {
      uint64_t v32 = (const char *)(*(uint64_t (**)(void))(*(void *)*a3 + 32))(*a3);
    }
    else {
      uint64_t v32 = "???";
    }
    ImageIOLog("☀️  PixelFormat::choosePixelFormat: '%c%c%c%c' plane: %u -> %s\n", v23, v26, v29, v31, a2, v32);
  }
  return v8;
}

void sub_18861E938(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18861EE74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
}

void sub_18861F4C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61)
{
}

void sub_18861F514()
{
}

void sub_18861FDB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  xdr::ColorBox<HDRColorTransformOut>::~ColorBox(&a61);
  xdr::ColorBox<HDRColorTransformOut>::~ColorBox(&a67);
  xdr::ColorBox<HDRColorTransformOut>::~ColorBox(&STACK[0x200]);
  _ZN3xdr8ImageBoxI20HDRPixelTransformOutLNS_7TextureIDv2_tDv2_fDv2_iE10AccessModeE1EED2Ev((uint64_t)&STACK[0x3C0]);
  _ZN3xdr8ImageBoxI20HDRPixelTransformOutLNS_7TextureIDv2_tDv2_fDv2_iE10AccessModeE1EED2Ev((uint64_t)&STACK[0x3E0]);
  _ZN3xdr8ImageBoxI20HDRPixelTransformOutLNS_7TextureIDv2_tDv2_fDv2_iE10AccessModeE1EED2Ev((uint64_t)&STACK[0x400]);
  _Unwind_Resume(a1);
}

void sub_18861FE14()
{
}

void sub_18861FE1C()
{
}

void sub_188620880(_Unwind_Exception *a1)
{
}

void sub_1886208E4()
{
}

void sub_1886208EC()
{
}

void sub_1886208F4()
{
}

void sub_188620B48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
}

void xdr::dispatch_compute_luma_gain_histogram<(unsigned short)2,(unsigned short)2,(unsigned short)4>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __int32 a6, uint16x4_t a7, double a8, uint32x4_t a9)
{
  uint16x4_t v12 = a7;
  a7.i32[0] = a6;
  int8x8_t v15 = (int8x8_t)vmovl_u16(a7).u64[0];
  a9.i64[0] = 0x700000007;
  uint32x2_t v16 = (uint32x2_t)vand_s8((int8x8_t)*(_OWORD *)&vaddw_u16(a9, a7), (int8x8_t)0xFFFF0000FFFFLL);
  uint32x2_t v27 = vshr_n_u32(v16, 3uLL);
  float32x2_t v17 = vadd_f32((float32x2_t)vorr_s8(vand_s8(v15, (int8x8_t)0xFFFF0000FFFFLL), (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000));
  __asm { FMOV            V3.2S, #1.0 }
  *(float32x2_t *)&long long v23 = vdiv_f32(_D3, v17);
  *((float32x2_t *)&v23 + 1) = vdiv_f32(0, v17);
  uint32x2_t v25 = vshr_n_u32(vsra_n_u32((uint32x2_t)0x700000007, v16, 3uLL), 3uLL);
  long long v26 = v23;
  unsigned int v24 = malloc_type_calloc(0x40uLL, 0x1000uLL, 0x1000040BAFFE814uLL);
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZN3xdr36dispatch_compute_luma_gain_histogramILt2ELt2ELt4EEEvRKNS_7imageInES3_RKNS_16colorTransformInERKNS_15gainTransformInERNS_11histogram2DEDv2_fDv2_t_block_invoke;
  block[3] = &__block_descriptor_104_e8_v16__0Q8l;
  __int16 v40 = v25.i16[2];
  __int16 v39 = v25.i16[0];
  __int16 v42 = v27.i16[2];
  __int16 v41 = v27.i16[0];
  uint64_t v33 = a1;
  uint64_t v34 = a2;
  uint64_t v35 = a3;
  uint64_t v36 = a4;
  double v37 = v24;
  uint16x4_t v38 = v12;
  long long v32 = v26;
  dispatch_apply(0x40uLL, 0, block);
  v29[0] = 0;
  v29[1] = v29;
  v29[2] = 0x2020000000;
  v29[3] = &v30;
  uint64_t v30 = 0;
  v28[0] = MEMORY[0x1E4F143A8];
  v28[1] = 3221225472;
  v28[2] = ___ZN3xdr36dispatch_compute_luma_gain_histogramILt2ELt2ELt4EEEvRKNS_7imageInES3_RKNS_16colorTransformInERKNS_15gainTransformInERNS_11histogram2DEDv2_fDv2_t_block_invoke_2;
  v28[3] = &unk_1E53C06A0;
  v28[5] = v24;
  v28[6] = a5;
  v28[4] = v29;
  dispatch_apply(0x20uLL, 0, v28);
  free(v24);
  _Block_object_dispose(v29, 8);
}

void xdr::PixelFormatBGRA8Unorm::~PixelFormatBGRA8Unorm(xdr::PixelFormatBGRA8Unorm *this)
{
}

double xdr::PixelFormatBGRA8Unorm::read(xdr::PixelFormatBGRA8Unorm *this, const unsigned __int8 *a2, int a3, uint8x8_t a4)
{
  a4.i32[0] = *(_DWORD *)&a2[4 * a3];
  int8x16_t v4 = (int8x16_t)vrev64q_s32((int32x4_t)vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a4)), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000)), (float32x4_t)vdupq_n_s32(0x437F0000u)));
  *(void *)&double result = vextq_s8(v4, v4, 0xCuLL).u64[0];
  return result;
}

int8x8_t xdr::PixelFormatBGRA8Unorm::write(int32x4_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int8x16_t v4 = (int8x16_t)vrev64q_s32(a1);
  float32x4_t v5 = (float32x4_t)vdupq_n_s32(0x437F0000u);
  v6.i64[0] = 0x3F0000003F000000;
  v6.i64[1] = 0x3F0000003F000000;
  int16x8_t v7 = (int16x8_t)vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v6, v5, (float32x4_t)vextq_s8(v4, v4, 0xCuLL)), (float32x4_t)0), v5));
  *(int16x4_t *)v7.i8 = vmovn_s32((int32x4_t)v7);
  int8x8_t result = vmovn_s16(v7);
  *(_DWORD *)(a3 + 4 * a4) = result.i32[0];
  return result;
}

const char *xdr::PixelFormatBGRA8Unorm::name(xdr::PixelFormatBGRA8Unorm *this)
{
  return "BGRA8Unorm";
}

void xdr::PixelFormatR8Unorm::~PixelFormatR8Unorm(xdr::PixelFormatR8Unorm *this)
{
}

__n64 xdr::PixelFormatR8Unorm::read(xdr::PixelFormatR8Unorm *this, const unsigned __int8 *a2, int a3, float a4)
{
  LOBYTE(a4) = a2[a3];
  result.n64_f32[0] = (float)LODWORD(a4) / 255.0;
  result.n64_u32[1] = 0;
  return result;
}

double xdr::PixelFormatR8Unorm::write(float32x4_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  float32x4_t v4 = (float32x4_t)vdupq_n_s32(0x437F0000u);
  v5.i64[0] = 0x3F0000003F000000;
  v5.i64[1] = 0x3F0000003F000000;
  *(void *)&double result = vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v5, v4, a1), (float32x4_t)0), v4).u64[0];
  *(unsigned char *)(a3 + a4) = (int)*(float *)&result;
  return result;
}

const char *xdr::PixelFormatR8Unorm::name(xdr::PixelFormatR8Unorm *this)
{
  return "R8Unorm";
}

void xdr::PixelFormatRG8Unorm::~PixelFormatRG8Unorm(xdr::PixelFormatRG8Unorm *this)
{
}

float32x2_t xdr::PixelFormatRG8Unorm::read(xdr::PixelFormatRG8Unorm *this, const unsigned __int8 *a2, int a3)
{
  uint64_t v3 = &a2[2 * a3];
  v4.i32[0] = *v3;
  v4.i32[1] = v3[1];
  return vdiv_f32(vadd_f32((float32x2_t)vorr_s8(v4, (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), (float32x2_t)vdup_n_s32(0x437F0000u));
}

double xdr::PixelFormatRG8Unorm::write(float32x4_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  float32x4_t v4 = (float32x4_t)vdupq_n_s32(0x437F0000u);
  float32x4_t v5 = (unsigned char *)(a3 + 2 * a4);
  v6.i64[0] = 0x3F0000003F000000;
  v6.i64[1] = 0x3F0000003F000000;
  *(void *)&double result = vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v6, v4, a1), (float32x4_t)0), v4)).u64[0];
  v5[1] = BYTE4(result);
  unsigned char *v5 = LOBYTE(result);
  return result;
}

const char *xdr::PixelFormatRG8Unorm::name(xdr::PixelFormatRG8Unorm *this)
{
  return "RG8Unorm";
}

void xdr::PixelFormatR16Unorm::~PixelFormatR16Unorm(xdr::PixelFormatR16Unorm *this)
{
}

__n64 xdr::PixelFormatR16Unorm::read(xdr::PixelFormatR16Unorm *this, const unsigned __int8 *a2, int a3, float a4)
{
  LOWORD(a4) = *(_WORD *)&a2[2 * a3];
  result.n64_f32[0] = (float)LODWORD(a4) / 65535.0;
  result.n64_u32[1] = 0;
  return result;
}

double xdr::PixelFormatR16Unorm::write(float32x4_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  float32x4_t v4 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
  v5.i64[0] = 0x3F0000003F000000;
  v5.i64[1] = 0x3F0000003F000000;
  *(void *)&double result = vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v5, v4, a1), (float32x4_t)0), v4).u64[0];
  *(_WORD *)(a3 + 2 * a4) = (int)*(float *)&result;
  return result;
}

const char *xdr::PixelFormatR16Unorm::name(xdr::PixelFormatR16Unorm *this)
{
  return "R16Unorm";
}

void xdr::PixelFormatRG16Unorm::~PixelFormatRG16Unorm(xdr::PixelFormatRG16Unorm *this)
{
}

float32x2_t xdr::PixelFormatRG16Unorm::read(xdr::PixelFormatRG16Unorm *this, const unsigned __int8 *a2, int a3)
{
  uint64_t v3 = &a2[4 * a3];
  v4.i32[0] = *(unsigned __int16 *)v3;
  v4.i32[1] = *((unsigned __int16 *)v3 + 1);
  return vdiv_f32(vadd_f32((float32x2_t)vorr_s8(v4, (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), (float32x2_t)vdup_n_s32(0x477FFF00u));
}

double xdr::PixelFormatRG16Unorm::write(float32x4_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  float32x4_t v4 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
  float32x4_t v5 = (_WORD *)(a3 + 4 * a4);
  v6.i64[0] = 0x3F0000003F000000;
  v6.i64[1] = 0x3F0000003F000000;
  *(void *)&double result = vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v6, v4, a1), (float32x4_t)0), v4)).u64[0];
  v5[1] = WORD2(result);
  _WORD *v5 = LOWORD(result);
  return result;
}

const char *xdr::PixelFormatRG16Unorm::name(xdr::PixelFormatRG16Unorm *this)
{
  return "RG16Unorm";
}

void xdr::PixelFormatR16Float::~PixelFormatR16Float(xdr::PixelFormatR16Float *this)
{
}

__n64 xdr::PixelFormatR16Float::read(xdr::PixelFormatR16Float *this, const unsigned __int8 *a2, int a3)
{
  _H0 = *(_WORD *)&a2[2 * a3];
  __asm { FCVT            S0, H0 }
  result.n64_u32[1] = 0;
  return result;
}

__int16 xdr::PixelFormatR16Float::write@<H0>(float _S0@<S0>, uint64_t a2@<X0>, uint64_t a3@<X1>, unsigned int a4@<W2>)
{
  __asm { FCVT            H0, S0 }
  *(_WORD *)(a3 + 2 * a4) = result;
  return result;
}

const char *xdr::PixelFormatR16Float::name(xdr::PixelFormatR16Float *this)
{
  return "R16Float";
}

void xdr::PixelFormatBGR10A2Unorm::~PixelFormatBGR10A2Unorm(xdr::PixelFormatBGR10A2Unorm *this)
{
}

double xdr::PixelFormatBGR10A2Unorm::read(xdr::PixelFormatBGR10A2Unorm *this, const unsigned __int8 *a2, int a3)
{
  uint64_t v3 = (const float *)&a2[4 * a3];
  uint32x4_t v4 = (uint32x4_t)vld1q_dup_f32(v3);
  *(void *)&double result = vmulq_f32(vcvtq_f32_u32((uint32x4_t)vandq_s8((int8x16_t)vshlq_u32(v4, (uint32x4_t)xmmword_18898C410), (int8x16_t)xmmword_18898C420)), (float32x4_t)xmmword_18898C430).u64[0];
  return result;
}

int32x2_t xdr::PixelFormatBGR10A2Unorm::write(int8x16_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  v4.i64[0] = 0x3F0000003F000000;
  v4.i64[1] = 0x3F0000003F000000;
  float32x4_t v5 = vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v4, (float32x4_t)xmmword_18898C440, (float32x4_t)vextq_s8(a1, a1, 0xCuLL)), (float32x4_t)0), (float32x4_t)xmmword_18898C440);
  v6.i64[0] = 0x4F0000004F000000;
  v6.i64[1] = 0x4F0000004F000000;
  int8x16_t v7 = (int8x16_t)vcgtq_f32(v5, v6);
  int32x4_t v8 = vcvtq_s32_f32(vsubq_f32(v5, (float32x4_t)vandq_s8((int8x16_t)v6, v7)));
  v6.i64[0] = 0x8000000080000000;
  v6.i64[1] = 0x8000000080000000;
  int8x16_t v9 = (int8x16_t)vshlq_u32((uint32x4_t)vaddq_s32((int32x4_t)vandq_s8(v7, (int8x16_t)v6), v8), (uint32x4_t)xmmword_18898C450);
  *(int32x2_t *)v9.i8 = vadd_s32(*(int32x2_t *)v9.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL));
  int32x2_t result = vadd_s32(*(int32x2_t *)v9.i8, vdup_lane_s32(*(int32x2_t *)v9.i8, 1));
  *(_DWORD *)(a3 + 4 * a4) = result.i32[0];
  return result;
}

const char *xdr::PixelFormatBGR10A2Unorm::name(xdr::PixelFormatBGR10A2Unorm *this)
{
  return "BGR10A2Unorm";
}

void xdr::PixelFormatRGBA16Float::~PixelFormatRGBA16Float(xdr::PixelFormatRGBA16Float *this)
{
}

double xdr::PixelFormatRGBA16Float::read(xdr::PixelFormatRGBA16Float *this, const unsigned __int8 *a2, int a3)
{
  *(void *)&double result = vcvtq_f32_f16(*(float16x4_t *)&a2[8 * a3]).u64[0];
  return result;
}

float16x4_t xdr::PixelFormatRGBA16Float::write(float32x4_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  float16x4_t result = vcvt_f16_f32(a1);
  *(float16x4_t *)(a3 + 8 * a4) = result;
  return result;
}

const char *xdr::PixelFormatRGBA16Float::name(xdr::PixelFormatRGBA16Float *this)
{
  return "RGBA16Float";
}

void xdr::PixelFormatRGBA16Unorm::~PixelFormatRGBA16Unorm(xdr::PixelFormatRGBA16Unorm *this)
{
}

double xdr::PixelFormatRGBA16Unorm::read(xdr::PixelFormatRGBA16Unorm *this, const unsigned __int8 *a2, int a3)
{
  *(void *)&double result = vdivq_f32(vaddq_f32((float32x4_t)vorrq_s8((int8x16_t)vmovl_u16(*(uint16x4_t *)&a2[8 * a3]), (int8x16_t)vdupq_n_s32(0x4B400000u)), (float32x4_t)vdupq_n_s32(0xCB400000)), (float32x4_t)vdupq_n_s32(0x477FFF00u)).u64[0];
  return result;
}

int16x4_t xdr::PixelFormatRGBA16Unorm::write(float32x4_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  float32x4_t v4 = (float32x4_t)vdupq_n_s32(0x477FFF00u);
  v5.i64[0] = 0x3F0000003F000000;
  v5.i64[1] = 0x3F0000003F000000;
  int16x4_t result = vmovn_s32(vcvtq_s32_f32(vminnmq_f32(vmaxnmq_f32(vmlaq_f32(v5, v4, a1), (float32x4_t)0), v4)));
  *(int16x4_t *)(a3 + 8 * a4) = result;
  return result;
}

const char *xdr::PixelFormatRGBA16Unorm::name(xdr::PixelFormatRGBA16Unorm *this)
{
  return "RGBA16Unorm";
}

void xdr::PixelFormatR32Float::~PixelFormatR32Float(xdr::PixelFormatR32Float *this)
{
}

double xdr::PixelFormatR32Float::read(xdr::PixelFormatR32Float *this, const unsigned __int8 *a2, int a3)
{
  *(void *)&double result = *(unsigned int *)&a2[4 * a3];
  return result;
}

void xdr::PixelFormatR32Float::write(float a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  *(float *)(a3 + 4 * a4) = a1;
}

const char *xdr::PixelFormatR32Float::name(xdr::PixelFormatR32Float *this)
{
  return "R32Float";
}

void xdr::PixelFormatRGBA32Float::~PixelFormatRGBA32Float(xdr::PixelFormatRGBA32Float *this)
{
}

__n128 xdr::PixelFormatRGBA32Float::read(xdr::PixelFormatRGBA32Float *this, const unsigned __int8 *a2, int a3)
{
  return *(__n128 *)&a2[16 * a3];
}

void xdr::PixelFormatRGBA32Float::write(__n128 a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  *(__n128 *)(a3 + 16 * a4) = a1;
}

const char *xdr::PixelFormatRGBA32Float::name(xdr::PixelFormatRGBA32Float *this)
{
  return "RGBA32Float";
}

void *_ZN3xdr8ImageBoxI19HDRPixelTransformInLNS_7TextureIDv2_tDv2_fDv2_iE10AccessModeE0EEC2EP10__CVBufferRKS1_(void *result, uint64_t a2, int *a3)
{
  *double result = a2;
  result[1] = a3;
  result[2] = 0;
  result[3] = 0;
  int v3 = *a3;
  if (*a3 == 3) {
    goto LABEL_4;
  }
  if (v3 == 2) {
    operator new();
  }
  if (v3 == 1) {
LABEL_4:
  }
    operator new();
  return result;
}

void sub_188621378(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C40AFB6B84ELL);
  _Unwind_Resume(a1);
}

uint64_t xdr::PixelBufferTexture::PixelBufferTexture(uint64_t a1, const void *a2, unsigned int a3, int a4)
{
  uint64_t v8 = a3;
  __int16 WidthOfPlane = gFunc_CVPixelBufferGetWidthOfPlane(a2, a3);
  __int16 HeightOfPlane = gFunc_CVPixelBufferGetHeightOfPlane(a2, v8);
  *(_DWORD *)(a1 + 8) = a4;
  *(_WORD *)(a1 + 12) = WidthOfPlane;
  *(_WORD *)(a1 + 14) = HeightOfPlane;
  *(void *)a1 = &unk_1ED4EEE80;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = CFRetain(a2);
  if (!gFunc_CVPixelBufferLockBaseAddress(a2, a4 == 0))
  {
    *(void *)(a1 + 24) = gFunc_CVPixelBufferGetBaseAddressOfPlane(a2, v8);
    *(void *)(a1 + 32) = gFunc_CVPixelBufferGetBytesPerRowOfPlane(a2, v8);
  }
  int PixelFormatType = gFunc_CVPixelBufferGetPixelFormatType(a2);
  xdr::PixelFormat::choosePixelFormat(PixelFormatType, a3, (void *)(a1 + 40));
  return a1;
}

void xdr::PixelBufferTexture::~PixelBufferTexture(xdr::PixelBufferTexture *this, __n128 a2)
{
  xdr::PixelBufferTexture::~PixelBufferTexture(this, a2);

  JUMPOUT(0x18C11C0E0);
}

{
  uint64_t v3;

  *(void *)this = &unk_1ED4EEE80;
  int v3 = *((void *)this + 5);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  gFunc_CVPixelBufferUnlockBaseAddress(*((void *)this + 2), *((_DWORD *)this + 2) == 0, a2);
  CFRelease(*((CFTypeRef *)this + 2));
}

double xdr::PixelBufferTexture::read(uint64_t a1, __int32 a2, uint16x4_t a3)
{
  a3.i32[0] = a2;
  int8x8_t v3 = (int8x8_t)vmovl_u16(a3).u64[0];
  v4.i32[0] = *(unsigned __int16 *)(a1 + 12);
  v4.i32[1] = *(unsigned __int16 *)(a1 + 14);
  int16x4_t v5 = (int16x4_t)vcgt_u32(v4, (uint32x2_t)vand_s8(v3, (int8x8_t)0xFFFF0000FFFFLL));
  if ((vminv_u16((uint16x4_t)vuzp1_s16(v5, v5)) & 0x8000) == 0) {
    return 0.0;
  }
  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6) {
    return 0.0;
  }
  uint64_t v7 = *(void *)(a1 + 24);
  if (!v7) {
    return 0.0;
  }
  (*(void (**)(void, uint64_t, void))(*(void *)v6 + 16))(*(void *)(a1 + 40), v7 + *(void *)(a1 + 32) * v3.u16[2], (unsigned __int16)a2);
  return result;
}

uint64_t xdr::PixelBufferTexture::write(uint64_t result, __int32 a2, double a3, uint16x4_t a4)
{
  a4.i32[0] = a2;
  int8x8_t v4 = (int8x8_t)vmovl_u16(a4).u64[0];
  v5.i32[0] = *(unsigned __int16 *)(result + 12);
  v5.i32[1] = *(unsigned __int16 *)(result + 14);
  int16x4_t v6 = (int16x4_t)vcgt_u32(v5, (uint32x2_t)vand_s8(v4, (int8x8_t)0xFFFF0000FFFFLL));
  if ((vminv_u16((uint16x4_t)vuzp1_s16(v6, v6)) & 0x8000) != 0)
  {
    uint64_t v7 = *(void *)(result + 40);
    if (v7)
    {
      uint64_t v8 = *(void *)(result + 24);
      if (v8) {
        return (*(uint64_t (**)(void, uint64_t, void))(*(void *)v7 + 24))(*(void *)(result + 40), v8 + *(void *)(result + 32) * v4.u16[2], (unsigned __int16)a2);
      }
    }
  }
  return result;
}

void *_ZN3xdr8ImageBoxI20HDRPixelTransformOutLNS_7TextureIDv2_tDv2_fDv2_iE10AccessModeE1EEC2EP10__CVBufferRKS1_(void *result, uint64_t a2, int *a3)
{
  *double result = a2;
  result[1] = a3;
  result[2] = 0;
  result[3] = 0;
  int v3 = *a3;
  if (*a3 == 3) {
    goto LABEL_4;
  }
  if (v3 == 2) {
    operator new();
  }
  if (v3 == 1) {
LABEL_4:
  }
    operator new();
  return result;
}

void sub_1886217A8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C40AFB6B84ELL);
  _Unwind_Resume(a1);
}

uint64_t xdr::ColorBox<HDRColorTransformIn>::ColorBox(uint64_t result, _DWORD *a2)
{
  *(void *)double result = a2;
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  if (*a2 == 6) {
    operator new();
  }
  int v2 = a2[20];
  if (v2 == 5) {
    operator new();
  }
  if (v2 == 6) {
    operator new();
  }
  if (a2[56] == 6) {
    operator new();
  }
  return result;
}

void sub_1886218E8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C40B7F8E0AELL);
  _Unwind_Resume(a1);
}

xdr::TableTexture *xdr::TableTexture::TableTexture(xdr::TableTexture *this, NSData *a2)
{
  int v3 = a2;
  unint64_t v4 = [(NSData *)v3 length];
  *((_DWORD *)this + 2) = 0;
  *((_WORD *)this + 6) = v4 >> 1;
  *(void *)this = &unk_1ED4EEE50;
  *((void *)this + 2) = 0;
  uint32x2_t v5 = v3;
  uint64_t v6 = [(NSData *)v5 bytes];
  *((void *)this + 4) = 0;
  *((void *)this + 3) = v6;
  uint64_t v7 = v5;
  *((void *)this + 2) = v7;
  xdr::PixelFormat::choosePixelFormat(1278226536, 0, (void *)this + 4);

  return this;
}

void sub_1886219CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void xdr::TableTexture::~TableTexture(xdr::TableTexture *this)
{
  xdr::TableTexture::~TableTexture(this);

  JUMPOUT(0x18C11C0E0);
}

{
  void *v1;
  uint64_t v2;

  *(void *)this = &unk_1ED4EEE50;
  uint64_t v1 = (void *)*((void *)this + 2);
  int v2 = *((void *)this + 4);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

double xdr::TableTexture::read(xdr::TableTexture *this, uint64_t a2)
{
  if (*((unsigned __int16 *)this + 6) <= a2) {
    return 0.0;
  }
  uint64_t v3 = *((void *)this + 4);
  if (!v3) {
    return 0.0;
  }
  uint64_t v5 = *((void *)this + 3);
  if (!v5) {
    return 0.0;
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 16))(v3, v5, a2);
  return result;
}

uint64_t xdr::TableTexture::write(uint64_t result, uint64_t a2)
{
  if (*(unsigned __int16 *)(result + 12) > a2)
  {
    uint64_t v2 = result;
    double result = *(void *)(result + 32);
    if (result)
    {
      uint64_t v4 = *(void *)(v2 + 24);
      if (v4) {
        return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)result + 24))(result, v4, a2);
      }
    }
  }
  return result;
}

int16x4_t *xdr::CubeTexture::CubeTexture(int16x4_t *this, NSData *a2)
{
  uint64_t v3 = a2;
  int16x4_t v4 = xdr::CubeTexture::cubeSize([(NSData *)v3 length] >> 3);
  this[1].i32[0] = 0;
  this[2] = v4;
  *this = (int16x4_t)&unk_1ED4F0940;
  this[3] = 0;
  uint64_t v5 = v3;
  uint64_t v6 = [(NSData *)v5 bytes];
  this[7] = 0;
  this[4] = (int16x4_t)v6;
  uint64_t v7 = v5;
  this[3] = (int16x4_t)v7;
  int16x4_t v8 = this[2];
  uint64_t v9 = 8 * v8.u16[0];
  this[5] = (int16x4_t)v9;
  this[6] = (int16x4_t)(v9 * (unint64_t)v8.u16[1]);
  xdr::PixelFormat::choosePixelFormat(1380411457, 0, &this[7]);

  return this;
}

void sub_188621BF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int16x4_t xdr::CubeTexture::cubeSize(unint64_t this)
{
  unsigned int v2 = llroundf(cbrtf((float)this));
  if (v2 * v2 * v2 != this) {
    xdr::CubeTexture::cubeSize();
  }
  return vdup_n_s16(v2);
}

void xdr::CubeTexture::~CubeTexture(xdr::CubeTexture *this)
{
  xdr::CubeTexture::~CubeTexture(this);

  JUMPOUT(0x18C11C0E0);
}

{
  void *v1;
  uint64_t v2;

  *(void *)this = &unk_1ED4F0940;
  uint64_t v1 = (void *)*((void *)this + 3);
  unsigned int v2 = *((void *)this + 7);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

double xdr::CubeTexture::read(uint16x4_t *a1, uint16x4_t a2)
{
  uint16x4_t v2 = vcgt_u16(a1[2], a2);
  v2.i16[3] = v2.i16[2];
  if ((vminv_u16(v2) & 0x8000) == 0) {
    return 0.0;
  }
  uint16x4_t v3 = a1[7];
  if (!*(void *)&v3) {
    return 0.0;
  }
  uint16x4_t v4 = a1[4];
  if (!*(void *)&v4) {
    return 0.0;
  }
  (*(void (**)(void, void, void))(**(void **)&v3 + 16))(*(void *)&a1[7], *(void *)&v4 + *(void *)&a1[5] * a2.u16[1] + *(void *)&a1[6] * a2.u16[2], a2.u16[0]);
  return result;
}

uint16x4_t *xdr::CubeTexture::write(uint16x4_t *result, double a2, uint16x4_t a3)
{
  uint16x4_t v3 = vcgt_u16(result[2], a3);
  v3.i16[3] = v3.i16[2];
  if ((vminv_u16(v3) & 0x8000) != 0)
  {
    uint16x4_t v4 = result[7];
    if (v4)
    {
      uint16x4_t v5 = result[4];
      if (v5) {
        return (uint16x4_t *)(*(uint64_t (**)(void, void, void))(**(void **)&v4 + 24))(*(void *)&result[7], *(void *)&v5 + *(void *)&result[5] * a3.u16[1] + *(void *)&result[6] * a3.u16[2], a3.u16[0]);
      }
    }
  }
  return result;
}

uint64_t xdr::ColorBox<HDRColorTransformOut>::ColorBox(uint64_t result, _DWORD *a2)
{
  *(void *)double result = a2;
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  if (a2[72] == 6) {
    operator new();
  }
  int v2 = a2[16];
  if (v2 == 5) {
    operator new();
  }
  if (v2 == 6) {
    operator new();
  }
  if (a2[52] == 6) {
    operator new();
  }
  return result;
}

void sub_188621EEC(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C40B7F8E0AELL);
  _Unwind_Resume(a1);
}

void *xdr::ColorBox<HDRColorTransformOut>::~ColorBox(void *a1)
{
  uint64_t v2 = a1[1];
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[2];
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[3];
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = a1[4];
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  return a1;
}

uint64_t _ZN3xdr8ImageBoxI20HDRPixelTransformOutLNS_7TextureIDv2_tDv2_fDv2_iE10AccessModeE1EED2Ev(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  return a1;
}

void ___ZN3xdr36dispatch_convert_image_to_image_loopILt1ELt1EEEvRKNS_7imageInERKNS_8imageOutERKNS_16colorTransformInERKNS_17colorTransformOutEDv2_t_block_invoke(uint64_t a1, __int16 a2, double a3, uint16x4_t a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = 0x100000000;
  int v11 = 1;
  if (*(_WORD *)(a1 + 80))
  {
    int v6 = 0;
    do
    {
      HIWORD(v9) = a2;
      LOWORD(v9) = v6;
      uint64_t v7 = *(float32x4_t **)(a1 + 56);
      *(double *)v8.i64 = xdr::convert_image_to_image(*(void *)(a1 + 48), *(void *)(a1 + 64), *(float32x4_t **)(a1 + 72), v9, &v10, *(int8x16_t *)(a1 + 32), a4);
      float32x4_t v12 = v8;
      xdr::image_write_loop<(unsigned short)1,(unsigned short)1>(v7, &v12, *(int16x4_t *)v8.f32);
      ++v6;
    }
    while (*(unsigned __int16 *)(a1 + 80) > (unsigned __int16)v6);
  }
}

double xdr::convert_image_to_image(uint64_t a1, uint64_t a2, float32x4_t *a3, __int32 a4, _DWORD *a5, int8x16_t a6, uint16x4_t a7)
{
  a7.i32[0] = a4;
  xdr::image_sample(a1, a5, COERCE_DOUBLE(vmla_f32((float32x2_t)*(_OWORD *)&vextq_s8(a6, a6, 8uLL), vadd_f32((float32x2_t)vorr_s8((int8x8_t)*(_OWORD *)&vmovl_u16(a7), (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), *(float32x2_t *)a6.i8)));
  *(double *)v10.i64 = xdr::apply_color_trc(a2, v9);
  xdr::apply_tone_mapping(a2 + 80, v10, v11, v12, v13);
  if (!*(unsigned char *)(a2 + 352))
  {
    float32x4_t v16 = *(float32x4_t *)(a2 + 320);
    float32x4_t v15 = *(float32x4_t *)(a2 + 336);
    int8x16_t v17 = (int8x16_t)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)(a2 + 304), v14.f32[0]), v16, *(float32x2_t *)v14.f32, 1), v15, v14, 2);
    float32x4_t v14 = (float32x4_t)v17;
  }
  if (!a3[3].i8[0])
  {
    float32x4_t v16 = a3[1];
    float32x4_t v15 = a3[2];
    int8x16_t v17 = (int8x16_t)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a3, v14.f32[0]), v16, *(float32x2_t *)v14.f32, 1), v15, v14, 2);
    float32x4_t v14 = (float32x4_t)v17;
  }
  xdr::apply_tone_mapping((uint64_t)&a3[4], v14, *(double *)v15.i64, *(double *)v16.i64, v17);

  return xdr::apply_color_trc((uint64_t)&a3[18], v18);
}

__int16 xdr::image_write_loop<(unsigned short)1,(unsigned short)1>@<H0>(float32x4_t *a1@<X0>, float32x4_t *a2@<X1>, int16x4_t a3@<D0>)
{
  __int32 v4 = a1[1].i32[0];
  if (v4 == 3)
  {
LABEL_4:
    if (a1[7].i16[0] != 1) {
      return a3.i16[0];
    }
    __n128 v6 = (__n128)vmlaq_f32(a1[3], *a2, a1[2]);
    uint64_t v5 = a1->i64[0];
    v6.n128_u32[3] = 1.0;
    goto LABEL_6;
  }
  if (v4 != 2)
  {
    if (v4 != 1) {
      return a3.i16[0];
    }
    goto LABEL_4;
  }
  a3 = *(int16x4_t *)a1[7].f32;
  uint16x4_t v8 = (uint16x4_t)vceq_s16(a3, (int16x4_t)0x200020001);
  v8.i16[3] = v8.i16[2];
  if ((vminv_u16(v8) & 0x8000) != 0) {
    return a3.i16[0];
  }
  uint16x4_t v9 = (uint16x4_t)vceq_s16(a3, (int16x4_t)0x100020001);
  v9.i16[3] = v9.i16[2];
  if ((vminv_u16(v9) & 0x8000) != 0) {
    return a3.i16[0];
  }
  a3 = vceq_s16(a3, (int16x4_t)0x1000100010001);
  a3.i16[3] = a3.i16[2];
  a3.i16[0] = vminv_u16((uint16x4_t)a3);
  if ((a3.i16[0] & 0x8000) == 0) {
    return a3.i16[0];
  }
  float32x4_t v10 = *a2;
  v10.i32[3] = 0;
  float32x4_t v11 = vmaxnmq_f32(v10, (float32x4_t)0);
  v11.i32[3] = 0;
  float32x4_t v12 = vminnmq_f32(v11, (float32x4_t)xmmword_18898C460);
  int8x16_t v14 = (int8x16_t)vmlaq_f32(a1[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a1[4], v12.f32[0]), a1[5], *(float32x2_t *)v12.f32, 1), a1[6], v12, 2), a1[2]);
  (*(void (**)(float))(*(void *)a1->i64[0] + 24))(*(float *)v14.i32);
  uint64_t v5 = a1->i64[1];
  v6.n128_u64[0] = vextq_s8(v14, v14, 4uLL).u64[0];
  v6.n128_u64[1] = 0x3F80000000000000;
LABEL_6:
  uint64_t v7 = *(void (**)(__n128))(*(void *)v5 + 24);

  v7(v6);
  return a3.i16[0];
}

void xdr::image_sample(uint64_t a1, _DWORD *a2, double a3)
{
  float32x2_t v5 = vadd_f32(*(float32x2_t *)(a1 + 128), vmla_lane_f32(vmul_n_f32(*(float32x2_t *)(a1 + 112), *(float *)&a3), *(float32x2_t *)(a1 + 120), *(float32x2_t *)&a3, 1));
  _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE6sampleERKNS_7SamplerES2_S3_(*(void *)a1, a2, v5, 0);
  if (*(_DWORD *)(a1 + 16) == 2) {
    _ZNK3xdr7TextureIDv2_tDv2_fDv2_iE6sampleERKNS_7SamplerES2_S3_(*(void *)(a1 + 8), a2, v5, 0);
  }
}

double xdr::apply_color_trc(uint64_t a1, float32x4_t a2)
{
  float32x4_t v2 = a2;
  switch(*(_DWORD *)a1)
  {
    case 1:
      float32x4_t v4 = vabsq_f32(a2);
      v4.i32[3] = 0;
      simd_float4 v11 = (simd_float4)vmaxnmq_f32(v4, (float32x4_t)xmmword_18898C4C0);
      v5.i64[0] = 0x8000000080000000;
      v5.i64[1] = 0x8000000080000000;
      __asm { FMOV            V3.4S, #1.0 }
      float32x4_t v113 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v2), (int8x16_t)vcgtzq_f32(v2)), vorrq_s8(vandq_s8((int8x16_t)v2, v5), _Q3), (int8x16_t)0);
      v11.i32[3] = 0;
      simd_float4 v12 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)(a1 + 44), 0);
      v12.i32[3] = 0;
      goto LABEL_12;
    case 2:
      float32x4_t v13 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 20), 0), a2, COERCE_FLOAT(*(_OWORD *)(a1 + 16)));
      float32x4_t v14 = vabsq_f32(v13);
      v14.i32[3] = 0;
      simd_float4 v15 = (simd_float4)vmaxnmq_f32(v14, (float32x4_t)xmmword_18898C4C0);
      v16.i64[0] = 0x8000000080000000;
      v16.i64[1] = 0x8000000080000000;
      float32x4_t v114 = v2;
      __asm { FMOV            V4.4S, #1.0 }
      float32x4_t v104 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v13), (int8x16_t)vcgtzq_f32(v13)), vorrq_s8(vandq_s8((int8x16_t)v13, v16), _Q4), (int8x16_t)0);
      v15.i32[3] = 0;
      simd_float4 v18 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)(a1 + 44), 0);
      v18.i32[3] = 0;
      float32x4_t v19 = (float32x4_t)_simd_pow_f4(v15, v18);
      *(float *)v20.i32 = (float)-*(float *)(a1 + 20) / *(float *)(a1 + 16);
      int8x16_t v21 = (int8x16_t)vmulq_f32(v19, v104);
      int32x4_t v22 = vcgtq_f32((float32x4_t)vdupq_lane_s32(v20, 0), v114);
      v22.i32[3] = 0;
      int8x16_t v23 = (int8x16_t)vcltzq_s32(v22);
      int8x16_t v24 = 0uLL;
      goto LABEL_8;
    case 3:
      float32x4_t v25 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 20), 0), a2, COERCE_FLOAT(*(_OWORD *)(a1 + 16)));
      float32x4_t v26 = vabsq_f32(v25);
      v26.i32[3] = 0;
      simd_float4 v27 = (simd_float4)vmaxnmq_f32(v26, (float32x4_t)xmmword_18898C4C0);
      v28.i64[0] = 0x8000000080000000;
      v28.i64[1] = 0x8000000080000000;
      float32x4_t v115 = v2;
      __asm { FMOV            V4.4S, #1.0 }
      float32x4_t v105 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v25), (int8x16_t)vcgtzq_f32(v25)), vorrq_s8(vandq_s8((int8x16_t)v25, v28), _Q4), (int8x16_t)0);
      v27.i32[3] = 0;
      simd_float4 v30 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)(a1 + 44), 0);
      v30.i32[3] = 0;
      float32x4_t v31 = (float32x4_t)_simd_pow_f4(v27, v30);
      float32x4_t v32 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 24), 0);
      *(float *)v33.i32 = (float)-*(float *)(a1 + 20) / *(float *)(a1 + 16);
      float32x4_t v34 = (float32x4_t)vdupq_lane_s32(v33, 0);
      int8x16_t v35 = (int8x16_t)vaddq_f32(v32, vmulq_f32(v31, v105));
      float32x4_t v36 = v115;
      goto LABEL_6;
    case 4:
      float32x4_t v37 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 20), 0), a2, COERCE_FLOAT(*(_OWORD *)(a1 + 16)));
      float32x4_t v38 = vabsq_f32(v37);
      v38.i32[3] = 0;
      simd_float4 v39 = (simd_float4)vmaxnmq_f32(v38, (float32x4_t)xmmword_18898C4C0);
      v40.i64[0] = 0x8000000080000000;
      v40.i64[1] = 0x8000000080000000;
      float32x4_t v116 = v2;
      __asm { FMOV            V4.4S, #1.0 }
      float32x4_t v106 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v37), (int8x16_t)vcgtzq_f32(v37)), vorrq_s8(vandq_s8((int8x16_t)v37, v40), _Q4), (int8x16_t)0);
      v39.i32[3] = 0;
      simd_float4 v42 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)(a1 + 44), 0);
      v42.i32[3] = 0;
      float32x4_t v43 = (float32x4_t)_simd_pow_f4(v39, v42);
      float32x4_t v36 = v116;
      int8x16_t v35 = (int8x16_t)vmulq_f32(v43, v106);
      float32x4_t v34 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 28), 0);
      float32x4_t v32 = vmulq_n_f32(v116, COERCE_FLOAT(*(void *)(a1 + 24)));
LABEL_6:
      int32x4_t v44 = vcgtq_f32(v34, v36);
      v44.i32[3] = 0;
      v2.i64[0] = vbslq_s8((int8x16_t)vcltzq_s32(v44), (int8x16_t)v32, v35).u64[0];
      return *(double *)v2.i64;
    case 5:
      float32x4_t v45 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 20), 0), a2, COERCE_FLOAT(*(_OWORD *)(a1 + 16)));
      float32x4_t v46 = vabsq_f32(v45);
      v46.i32[3] = 0;
      simd_float4 v47 = (simd_float4)vmaxnmq_f32(v46, (float32x4_t)xmmword_18898C4C0);
      v48.i64[0] = 0x8000000080000000;
      v48.i64[1] = 0x8000000080000000;
      float32x4_t v117 = v2;
      __asm { FMOV            V4.4S, #1.0 }
      float32x4_t v107 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v45), (int8x16_t)vcgtzq_f32(v45)), vorrq_s8(vandq_s8((int8x16_t)v45, v48), _Q4), (int8x16_t)0);
      v47.i32[3] = 0;
      simd_float4 v50 = (simd_float4)vdupq_lane_s32(*(int32x2_t *)(a1 + 44), 0);
      v50.i32[3] = 0;
      int8x16_t v21 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 32), 0), vmulq_f32((float32x4_t)_simd_pow_f4(v47, v50), v107));
      int8x16_t v24 = (int8x16_t)vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 36), 0), v117, COERCE_FLOAT(*(void *)(a1 + 24)));
      int32x4_t v51 = vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 28), 0), v117);
      v51.i32[3] = 0;
      int8x16_t v23 = (int8x16_t)vcltzq_s32(v51);
LABEL_8:
      v2.i64[0] = vbslq_s8(v23, v24, v21).u64[0];
      return *(double *)v2.i64;
    case 6:
      v2.i32[3] = 0;
      v52 = *(unsigned __int16 **)(a1 + 64);
      float32x4_t v53 = vmaxnmq_f32(v2, (float32x4_t)0);
      v53.i32[3] = 0;
      float32x4_t v118 = vminnmq_f32(v53, (float32x4_t)xmmword_18898C460);
      int v122 = 1;
      uint64_t v121 = 0x100000000;
      *(double *)v54.i64 = xdr::Texture<unsigned short,float,int>::sample(v52, &v121, 0, v118.f32[0], 1.0);
      int32x4_t v108 = v54;
      int v122 = 1;
      uint64_t v121 = 0x100000000;
      *(double *)v56.i64 = xdr::Texture<unsigned short,float,int>::sample(v52, &v121, 0, v118.f32[1], v55);
      int32x4_t v101 = v56;
      int v122 = 1;
      uint64_t v121 = 0x100000000;
      xdr::Texture<unsigned short,float,int>::sample(v52, &v121, 0, v118.f32[2], v57);
      v2.i64[0] = vzip1q_s32(v108, v101).u64[0];
      return *(double *)v2.i64;
    case 7:
      v58.i64[0] = 0x8000000080000000;
      v58.i64[1] = 0x8000000080000000;
      __asm { FMOV            V2.4S, #1.0 }
      float32x4_t v113 = vmulq_n_f32((float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a2), (int8x16_t)vcgtzq_f32(a2)), vorrq_s8(vandq_s8((int8x16_t)a2, v58), _Q2), (int8x16_t)0), COERCE_FLOAT(*(void *)(a1 + 36)));
      simd_float4 v60 = (simd_float4)vabsq_f32(a2);
      v60.i32[3] = 0;
      float32x4_t v61 = (float32x4_t)_simd_pow_f4(v60, (simd_float4)xmmword_18898C4A0);
      float32x4_t v62 = vaddq_f32(v61, (float32x4_t)vdupq_n_s32(0xBF560000));
      v62.i32[3] = 0;
      simd_float4 v11 = (simd_float4)vdivq_f32(vmaxnmq_f32(v62, (float32x4_t)0), vmlaq_f32((float32x4_t)vdupq_n_s32(0x4196D000u), (float32x4_t)vdupq_n_s32(0xC1958000), v61));
      v11.i32[3] = 0;
      simd_float4 v12 = (simd_float4)xmmword_18898C4B0;
      goto LABEL_12;
    case 8:
      v63.i64[0] = 0x8000000080000000;
      v63.i64[1] = 0x8000000080000000;
      __asm { FMOV            V1.4S, #1.0 }
      float32x4_t v109 = (float32x4_t)_Q1;
      float32x4_t v113 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v2), (int8x16_t)vcgtzq_f32(v2)), vorrq_s8(vandq_s8((int8x16_t)v2, v63), _Q1), (int8x16_t)0);
      simd_float4 v65 = (simd_float4)vmulq_n_f32(vabsq_f32(v2), COERCE_FLOAT(*(void *)(a1 + 36)));
      v65.i32[3] = 0;
      float32x4_t v66 = (float32x4_t)_simd_pow_f4(v65, (simd_float4)xmmword_18898C480);
      simd_float4 v11 = (simd_float4)vdivq_f32(vmlaq_f32((float32x4_t)vdupq_n_s32(0x3F560000u), (float32x4_t)vdupq_n_s32(0x4196D000u), v66), vmlaq_f32(v109, (float32x4_t)vdupq_n_s32(0x41958000u), v66));
      v11.i32[3] = 0;
      simd_float4 v12 = (simd_float4)xmmword_18898C490;
LABEL_12:
      float32x4_t v67 = (float32x4_t)_simd_pow_f4(v11, v12);
      goto LABEL_15;
    case 9:
      float32x4_t v68 = vabsq_f32(vmulq_n_f32(a2, COERCE_FLOAT(*(_OWORD *)(a1 + 32))));
      v69.i64[0] = 0x8000000080000000;
      v69.i64[1] = 0x8000000080000000;
      __asm
      {
        FMOV            V1.4S, #1.0
        FMOV            V3.4S, #3.0
      }
      float32x4_t v72 = vmulq_f32(v68, _Q3);
      v72.i32[3] = 0;
      float32x4_t v113 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v2), (int8x16_t)vcgtzq_f32(v2)), vorrq_s8(vandq_s8((int8x16_t)v2, v69), _Q1), (int8x16_t)0);
      int8x16_t v110 = (int8x16_t)vsqrtq_f32(v72);
      float32x4_t v100 = v68;
      __asm { FMOV            V1.4S, #12.0 }
      simd_float4 v74 = (simd_float4)vmlaq_f32(vnegq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 20), 0)), _Q1, v68);
      v74.i32[3] = 0;
      int8x16_t v75 = (int8x16_t)vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 24), 0), (float32x4_t)_simd_log_f4(v74), COERCE_FLOAT(*(_OWORD *)(a1 + 16)));
      int32x4_t v76 = vcgtq_f32(v100, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 28), 0));
      v76.i32[3] = 0;
      float32x4_t v67 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v76), v75, v110);
      goto LABEL_15;
    case 0xA:
      a2.i32[0] = *(_DWORD *)(a1 + 36);
      float32x4_t v77 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0), vabsq_f32(v2), 1.0 - a2.f32[0]);
      v77.i32[3] = 0;
      float32x4_t v78 = vmaxnmq_f32(v77, (float32x4_t)0);
      v77.i64[0] = 0x8000000080000000;
      v77.i64[1] = 0x8000000080000000;
      __asm { FMOV            V2.4S, #1.0 }
      float32x4_t v113 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v2), (int8x16_t)vcgtzq_f32(v2)), vorrq_s8(vandq_s8((int8x16_t)v2, (int8x16_t)v77), _Q2), (int8x16_t)0);
      float32x4_t v102 = v78;
      int8x16_t v111 = (int8x16_t)vmulq_n_f32(vmulq_f32(v78, v78), COERCE_FLOAT(*(_OWORD *)(a1 + 32)));
      simd_float4 v80 = (simd_float4)vdivq_f32(vsubq_f32(v78, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 24), 0)), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 16), 0));
      v80.i32[3] = 0;
      float32x4_t v81 = (float32x4_t)_simd_exp_f4(v80);
      v82.i64[0] = 0x3F0000003F000000;
      v82.i64[1] = 0x3F0000003F000000;
      int32x4_t v83 = vcgtq_f32(v102, v82);
      v83.i32[3] = 0;
      float32x4_t v67 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v83), (int8x16_t)vmulq_n_f32(vaddq_f32(v81, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 20), 0)), COERCE_FLOAT(*(void *)(a1 + 28))), v111);
LABEL_15:
      v2.i64[0] = vmulq_f32(v113, v67).u64[0];
      break;
    case 0xB:
      a2.i32[0] = *(_DWORD *)(a1 + 36);
      float32x4_t v85 = vmlaq_n_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0), vabsq_f32(v2), 1.0 - a2.f32[0]);
      v85.i32[3] = 0;
      float32x4_t v86 = vmaxnmq_f32(v85, (float32x4_t)0);
      v85.i64[0] = 0x8000000080000000;
      v85.i64[1] = 0x8000000080000000;
      __asm { FMOV            V2.4S, #1.0 }
      float32x4_t v119 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v2), (int8x16_t)vcgtzq_f32(v2)), vorrq_s8(vandq_s8((int8x16_t)v2, (int8x16_t)v85), _Q2), (int8x16_t)0);
      float32x4_t v103 = v86;
      int8x16_t v112 = (int8x16_t)vmulq_n_f32(vmulq_f32(v86, v86), COERCE_FLOAT(*(_OWORD *)(a1 + 32)));
      simd_float4 v88 = (simd_float4)vdivq_f32(vsubq_f32(v86, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 24), 0)), (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 16), 0));
      v88.i32[3] = 0;
      _Q0 = (float32x4_t)_simd_exp_f4(v88);
      v90.i64[0] = 0x3F0000003F000000;
      v90.i64[1] = 0x3F0000003F000000;
      int32x4_t v91 = vcgtq_f32(v103, v90);
      v91.i32[3] = 0;
      float32x4_t v92 = vmulq_f32(v119, (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v91), (int8x16_t)vmulq_n_f32(vaddq_f32(_Q0, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 20), 0)), COERCE_FLOAT(*(void *)(a1 + 28))), v112));
      _Q0.i32[0] = v92.i32[2];
      v91.i32[0] = v92.i32[1];
      _Q2 = *(float32x4_t *)(a1 + 48);
      float32x4_t v94 = vmulq_f32(_Q2, v92);
      float v95 = v92.f32[0];
      float32x4_t v120 = v92;
      float32x4_t v96 = vaddq_f32(v94, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v94.f32, 1));
      _Q3 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v94, 2), v96);
      _Q0.f32[0] = fmaxf(v95, fmaxf(*(float *)v91.i32, _Q0.f32[0]));
      __asm { FMLA            S3, S0, V2.S[3] }
      float v98 = fmaxf(fabsf(*(float *)_Q3.i32), 0.000061035);
      _Q2.i64[0] = 0x8000000080000000;
      _Q2.i64[1] = 0x8000000080000000;
      v96.i32[0] = 1.0;
      LODWORD(v99) = vbslq_s8((int8x16_t)_Q2, (int8x16_t)v96, _Q3).u32[0];
      if (*(float *)_Q3.i32 == 0.0) {
        float v99 = 0.0;
      }
      v2.i64[0] = vmulq_n_f32(v120, *(float *)(a1 + 40) * (float)(v99 * powf(v98, *(float *)(a1 + 44)))).u64[0];
      break;
    default:
      return *(double *)v2.i64;
  }
  return *(double *)v2.i64;
}

void xdr::apply_tone_mapping(uint64_t a1, float32x4_t a2, double a3, double a4, int8x16_t a5)
{
  float32x4_t v8 = *(float32x4_t *)(a1 + 64);
  float32x4_t v7 = *(float32x4_t *)(a1 + 80);
  float32x4_t v9 = *(float32x4_t *)(a1 + 96);
  if (!*(unsigned char *)(a1 + 112))
  {
    a5 = (int8x16_t)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v8, a2.f32[0]), v7, *(float32x2_t *)a2.f32, 1), v9, a2, 2);
    a2 = (float32x4_t)a5;
  }
  switch(*(_DWORD *)a1)
  {
    case 1:
      float v10 = *(float *)(a1 + 16);
      float v11 = *(float *)(a1 + 20);
      float v12 = *(float *)(a1 + 24);
      float v13 = *(float *)(a1 + 28);
      float v14 = *(float *)(a1 + 32);
      float v15 = *(float *)(a1 + 36);
      float v16 = *(float *)(a1 + 40);
      float32x4_t v17 = vmulq_f32(a2, *(float32x4_t *)(a1 + 48));
      float v72 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v17, 2), vaddq_f32(v17, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v17.f32, 1))).f32[0];
      float32x4_t v74 = a2;
      float v18 = powf(fminf(fmaxf(v72 / v16, 0.0), 1.0), 0.1593);
      float v19 = (float)((float)(v18 * 18.852) + 0.83594) / ((float)(v18 * 18.688) + 1.0);
      float v20 = powf(v19, 78.844);
      float v21 = xdr::pq_eetf<float>(v20, v11, v10, v13, v12, v14, v15);
      float v22 = 1.0;
      if (v72 > 0.0)
      {
        float v23 = powf(v21, 0.012683);
        float v22 = (float)(v16 * powf(fmaxf(v23 + -0.83594, 0.0) / (float)((float)(v23 * -18.688) + 18.852), 6.2774)) / v72;
      }
      a2 = vmulq_n_f32(v74, v22);
      break;
    case 2:
      _Q0 = *(float32x4_t *)(a1 + 48);
      _Q1 = vmulq_f32(a2, _Q0);
      _Q2 = (int8x16_t)vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)_Q1, 2), vaddq_f32(_Q1, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)_Q1.f32, 1)));
      _Q1.f32[0] = fmaxf(a2.f32[0], fmaxf(a2.f32[1], a2.f32[2]));
      __asm { FMLA            S2, S1, V0.S[3] }
      float v31 = *(float *)(a1 + 40);
      float v32 = fmaxf(fabsf(*(float *)_Q2.i32), 0.000061035);
      a5.i32[0] = 1.0;
      float32x4_t v75 = a2;
      v33.i64[0] = 0x8000000080000000;
      v33.i64[1] = 0x8000000080000000;
      a5.i32[0] = vbslq_s8(v33, a5, _Q2).u32[0];
      if (*(float *)_Q2.i32 == 0.0) {
        *(float *)a5.i32 = 0.0;
      }
      float v34 = *(float *)a5.i32;
      float v35 = powf(v32, *(float *)(a1 + 44));
      float32x4_t v36 = v75;
      float v37 = v31 * (float)(v34 * v35);
      goto LABEL_19;
    case 3:
      LODWORD(v38) = HIDWORD(*(void *)(a1 + 28));
      int32x2_t v73 = *(int32x2_t *)(a1 + 28);
      LODWORD(v76) = *(void *)(a1 + 36);
      float32x4_t v39 = vsubq_f32(a2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 16), 0));
      v39.i32[3] = 0;
      float32x4_t v67 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a1 + 24), 0);
      float32x4_t v68 = vmulq_n_f32(vmaxnmq_f32(v39, (float32x4_t)0), COERCE_FLOAT(*(void *)(a1 + 20)));
      __asm { FMOV            V0.4S, #1.0 }
      int8x16_t v70 = (int8x16_t)_Q0;
      simd_float4 v41 = (simd_float4)vmlaq_n_f32(_Q0, vsubq_f32(v68, v67), *(float *)v73.i32);
      v41.i32[3] = 0;
      float32x4_t v42 = (float32x4_t)_simd_log_f4(v41);
      int32x4_t v43 = vcgtq_f32(v68, v67);
      v43.i32[3] = 0;
      float32x4_t v69 = (float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v43), (int8x16_t)vaddq_f32(v67, vdivq_f32(v42, (float32x4_t)vdupq_lane_s32(v73, 0))), (int8x16_t)v68);
      float32x4_t v44 = vabsq_f32(v69);
      v44.i32[3] = 0;
      simd_float4 v45 = (simd_float4)vmaxnmq_f32(v44, (float32x4_t)xmmword_18898C4C0);
      v43.i64[0] = 0x8000000080000000;
      v43.i64[1] = 0x8000000080000000;
      float32x4_t v71 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v69), (int8x16_t)vcgtzq_f32(v69)), vorrq_s8(vandq_s8((int8x16_t)v69, (int8x16_t)v43), v70), (int8x16_t)0);
      v45.i32[3] = 0;
      simd_float4 v46 = (simd_float4)vdupq_lane_s32(v73, 1);
      v46.i32[3] = 0;
      float32x4_t v47 = (float32x4_t)_simd_pow_f4(v45, v46);
      if (v38 == 1.0) {
        unsigned int v48 = 0;
      }
      else {
        unsigned int v48 = -1;
      }
      int32x4_t v49 = vdupq_n_s32(v48);
      v49.i32[3] = 0;
      float32x4_t v50 = vmulq_n_f32((float32x4_t)vbslq_s8((int8x16_t)vcltzq_s32(v49), (int8x16_t)vmulq_f32(v47, v71), (int8x16_t)v69), v76);
      v50.i32[3] = 0;
      float32x4_t v51 = vmaxnmq_f32(v50, (float32x4_t)0);
      v51.i32[3] = 0;
      a2 = vminnmq_f32(v51, (float32x4_t)xmmword_18898C460);
      break;
    case 4:
      if (!*(unsigned char *)(a1 + 112)) {
        a2 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v8, a2.f32[0]), v7, *(float32x2_t *)a2.f32, 1), v9, a2, 2);
      }
      float32x4_t v52 = vmulq_n_f32(a2, COERCE_FLOAT(*(void *)(a1 + 36)));
      float v53 = fmaxf(v52.f32[0], fmaxf(v52.f32[1], v52.f32[2]));
      if (v53 >= 1.0)
      {
        float v63 = *(float *)(a1 + 52);
        float v64 = *(float *)(a1 + 48);
        float v65 = v53 * *(float *)(a1 + 56);
        float32x4_t v78 = v52;
        float v66 = xdr::rw_spline<float>((float *)(a1 + 16), v53);
        float32x4_t v52 = v78;
        if (v64 < v53) {
          float v66 = v63;
        }
        if (v53 < 1.0) {
          float v66 = v65;
        }
        float v54 = v66 / v53;
      }
      else
      {
        float v54 = *(float *)(a1 + 56);
      }
      a2 = vmulq_n_f32(v52, v54);
      break;
    case 5:
      float v55 = *(unsigned __int16 **)(a1 + 128);
      _Q1 = *(_OWORD *)(a1 + 48);
      _S2 = fmaxf(a2.f32[0], fmaxf(a2.f32[1], a2.f32[2]));
      __asm { FMLA            S0, S2, V1.S[3] }
      float v59 = *(float *)(a1 + 40);
      int v80 = 1;
      uint64_t v79 = 0x100000000;
      float32x4_t v77 = a2;
      double v60 = xdr::Texture<unsigned short,float,int>::sample(v55, &v79, 0, _S0, *(float *)&_Q1);
      float32x4_t v36 = v77;
      float v37 = v59 * *(float *)&v60;
LABEL_19:
      a2 = vmulq_n_f32(v36, v37);
      break;
    case 6:
      uint64_t v61 = *(void *)(a1 + 136);
      int v80 = 1;
      uint64_t v79 = 0x100000000;
      *(double *)v62.i64 = _ZNK3xdr7TextureIDv3_tDv3_fDv3_iE6sampleERKNS_7SamplerES2_S3_(v61, &v79, a2, (int32x4_t)0);
      a2 = v62;
      break;
    default:
      break;
  }
  xdr::apply_color_trc(a1 + 144, a2);
}

float xdr::pq_eetf<float>(float a1, float a2, float a3, float a4, float a5, float a6, float a7)
{
  float v7 = a3 - a2;
  float v8 = (float)(a1 - a2) / v7;
  float v9 = (float)(v8 - a6) * a7;
  float v10 = (1.0 - a6) * ((float)(v9 * (float)(v9 * v9)) + (float)(v9 * v9) * -2.0 + v9)
      + (1.0 - ((float)(v9 * v9) * 3.0 - (float)(v9 * (float)(v9 * v9)) * 2.0)) * a6
      + ((float)(v9 * v9) * 3.0 + (float)(v9 * (float)(v9 * v9)) * -2.0) * a5;
  if (v8 > a6) {
    float v8 = v10;
  }
  float v11 = (1.0 - v8) * (1.0 - v8);
  float v12 = v8 + (float)(a4 * (float)(v11 * v11));
  if (v8 > 1.0) {
    float v12 = v8;
  }
  if (v8 <= 0.0) {
    float v13 = a4;
  }
  else {
    float v13 = v12;
  }
  return a2 + (float)(v13 * v7);
}

float xdr::rw_spline<float>(float *a1, float a2)
{
  float v2 = (a2 + -1.0) * a1[4];
  float v3 = a1[3] * (float)(a1[2] + sqrtf(a1[1] + (float)(*a1 * a2)));
  if (*a1 == 0.0) {
    float v3 = v2;
  }
  return (float)(a1[10] * (float)((float)(1.0 - v3) * (float)(1.0 - v3))) + (v3 + (float)(1.0 - v3) * 2.0) * a1[9] * v3;
}

uint64_t ___ZN3xdr36dispatch_convert_image_to_image_loopILt2ELt1EEEvRKNS_7imageInERKNS_8imageOutERKNS_16colorTransformInERKNS_17colorTransformOutEDv2_t_block_invoke(uint64_t result, unsigned int a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v18 = 0x100000000;
  int v19 = 1;
  if (*(_WORD *)(result + 80))
  {
    uint64_t v3 = result;
    unsigned int v4 = 0;
    do
    {
      HIWORD(v15) = a2;
      LOWORD(v15) = v4;
      uint64_t v5 = *(void *)(v3 + 48);
      uint64_t v6 = *(void *)(v3 + 56);
      uint64_t v7 = *(void *)(v3 + 64);
      float v8 = *(float32x4_t **)(v3 + 72);
      int8x16_t v9 = *(int8x16_t *)(v3 + 32);
      long long v20 = 0u;
      long long v21 = 0u;
      int32x2_t v13 = (int32x2_t)vshl_u32((uint32x2_t)__PAIR64__(a2, v4), (uint32x2_t)1);
      int8x16_t v14 = v9;
      HIWORD(v17) = v13.i16[2];
      LOWORD(v17) = v13.i16[0];
      *(double *)&long long v10 = xdr::convert_image_to_image(v5, v7, v8, v17, &v18, v9, (uint16x4_t)v13);
      long long v20 = v10;
      *(int32x2_t *)&long long v10 = vadd_s32(v13, (int32x2_t)1);
      HIWORD(v16) = WORD2(v10);
      LOWORD(v16) = v10;
      *(double *)&long long v12 = xdr::convert_image_to_image(v5, v7, v8, v16, &v18, v14, v11);
      long long v21 = v12;
      double result = xdr::image_write_loop<(unsigned short)2,(unsigned short)1>(v6, (uint64_t)&v20, v15, *(uint16x4_t *)&v12);
      ++v4;
    }
    while (*(unsigned __int16 *)(v3 + 80) > (unsigned __int16)v4);
  }
  return result;
}

uint64_t xdr::image_write_loop<(unsigned short)2,(unsigned short)1>(uint64_t result, uint64_t a2, __int32 a3, uint16x4_t a4)
{
  uint64_t v5 = (float32x4_t *)result;
  a4.i32[0] = a3;
  uint32x2_t v6 = (uint32x2_t)vmovl_u16(a4).u64[0];
  int v7 = *(_DWORD *)(result + 16);
  if (v7 == 3)
  {
LABEL_4:
    if (*(_WORD *)(result + 112) == 1)
    {
      uint64_t v8 = 0;
      int32x2_t v9 = (int32x2_t)vshl_u32(v6, (uint32x2_t)1);
      char v10 = 1;
      do
      {
        char v11 = v10;
        __n128 v12 = (__n128)vmlaq_f32(v5[3], *(float32x4_t *)(a2 + 16 * v8), v5[2]);
        v12.n128_u32[3] = 1.0;
        int32x2_t v13 = vadd_s32((int32x2_t)v8, v9);
        HIWORD(v40) = v13.i16[2];
        LOWORD(v40) = v13.i16[0];
        double result = (*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[0] + 24))(v5->i64[0], v40, v12);
        char v10 = 0;
        uint64_t v8 = 1;
      }
      while ((v11 & 1) != 0);
    }
    return result;
  }
  if (v7 != 2)
  {
    if (v7 != 1) {
      return result;
    }
    goto LABEL_4;
  }
  int16x4_t v14 = *(int16x4_t *)(result + 112);
  uint16x4_t v15 = (uint16x4_t)vceq_s16(v14, (int16x4_t)0x200020001);
  v15.i16[3] = v15.i16[2];
  if ((vminv_u16(v15) & 0x8000) == 0)
  {
    uint16x4_t v16 = (uint16x4_t)vceq_s16(v14, (int16x4_t)0x100020001);
    v16.i16[3] = v16.i16[2];
    if ((vminv_u16(v16) & 0x8000) != 0)
    {
      uint64_t v27 = 0;
      int32x2_t v28 = (int32x2_t)vshl_u32(v6, (uint32x2_t)1);
      float32x2_t v29 = 0;
      char v30 = 1;
      do
      {
        float32x4_t v31 = *(float32x4_t *)(a2 + 16 * v27);
        char v32 = v30;
        v31.i32[3] = 0;
        float32x4_t v33 = vmaxnmq_f32(v31, (float32x4_t)0);
        v33.i32[3] = 0;
        float32x4_t v34 = vminnmq_f32(v33, (float32x4_t)xmmword_18898C460);
        int8x16_t v35 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v34.f32[0]), v5[5], *(float32x2_t *)v34.f32, 1), v5[6], v34, 2), v5[2]);
        float32x2_t v36 = (float32x2_t)vextq_s8(v35, v35, 4uLL).u64[0];
        v34.i32[0] = v35.i32[0];
        *(int32x2_t *)v35.i8 = vadd_s32((int32x2_t)v27, v28);
        HIWORD(v42) = v35.i16[2];
        float32x2_t v29 = vadd_f32(v29, v36);
        LOWORD(v42) = v35.i16[0];
        (*(void (**)(uint64_t, void, float32_t))(*(void *)v5->i64[0] + 24))(v5->i64[0], v42, v34.f32[0]);
        char v30 = 0;
        uint64_t v27 = 1;
      }
      while ((v32 & 1) != 0);
      v37.n128_u64[0] = (unint64_t)vmul_f32(v29, (float32x2_t)0x3F0000003F000000);
      v37.n128_u64[1] = 0x3F80000000000000;
      float v38 = *(uint64_t (**)(__n128))(*(void *)v5->i64[1] + 24);
      return v38(v37);
    }
    else
    {
      uint16x4_t v17 = (uint16x4_t)vceq_s16(v14, (int16x4_t)0x1000100010001);
      v17.i16[3] = v17.i16[2];
      if ((vminv_u16(v17) & 0x8000) != 0)
      {
        uint64_t v18 = 0;
        int32x2_t v19 = (int32x2_t)vshl_u32(v6, (uint32x2_t)1);
        char v20 = 1;
        do
        {
          char v21 = v20;
          float32x4_t v22 = *(float32x4_t *)(a2 + 16 * v18);
          v22.i32[3] = 0;
          float32x4_t v23 = vmaxnmq_f32(v22, (float32x4_t)0);
          v23.i32[3] = 0;
          float32x4_t v24 = vminnmq_f32(v23, (float32x4_t)xmmword_18898C460);
          int8x16_t v39 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v24.f32[0]), v5[5], *(float32x2_t *)v24.f32, 1), v5[6], v24, 2), v5[2]);
          int32x2_t v25 = vadd_s32((int32x2_t)v18, v19);
          HIWORD(v41) = v25.i16[2];
          LOWORD(v41) = v25.i16[0];
          (*(void (**)(uint64_t, void, float))(*(void *)v5->i64[0] + 24))(v5->i64[0], v41, *(float *)v39.i32);
          v26.n128_u64[0] = vextq_s8(v39, v39, 4uLL).u64[0];
          v26.n128_u64[1] = 0x3F80000000000000;
          double result = (*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[1] + 24))(v5->i64[1], v41, v26);
          char v20 = 0;
          uint64_t v18 = 1;
        }
        while ((v21 & 1) != 0);
      }
    }
  }
  return result;
}

float32x4_t *___ZN3xdr36dispatch_convert_image_to_image_loopILt2ELt2EEEvRKNS_7imageInERKNS_8imageOutERKNS_16colorTransformInERKNS_17colorTransformOutEDv2_t_block_invoke(float32x4_t *result, __int16 a2)
{
  uint64_t v6 = 0x100000000;
  int v7 = 1;
  if (result[5].i16[0])
  {
    uint64_t v3 = result;
    int v4 = 0;
    do
    {
      HIWORD(v5) = a2;
      LOWORD(v5) = v4;
      double result = xdr::convert_image_to_image_loop<(unsigned short)2,(unsigned short)2>(v3[3].i64[0], (float32x4_t *)v3[3].i64[1], v3[4].i64[0], (float32x4_t *)v3[4].i64[1], v5, &v6, (int8x16_t)v3[2]);
      ++v4;
    }
    while (v3[5].u16[0] > (unsigned __int16)v4);
  }
  return result;
}

float32x4_t *xdr::convert_image_to_image_loop<(unsigned short)2,(unsigned short)2>(uint64_t a1, float32x4_t *a2, uint64_t a3, float32x4_t *a4, __int32 a5, _DWORD *a6, int8x16_t a7)
{
  int8x16_t v24 = a7;
  uint64_t v13 = 0;
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  a7.i32[0] = a5;
  int32x2_t v14 = (int32x2_t)vmovl_u16(*(uint16x4_t *)a7.i8).u64[0];
  uint16x4_t v15 = 0;
  memset(v27, 0, sizeof(v27));
  int32x2_t v16 = vadd_s32(v14, v14);
  do
  {
    v17.i32[0] = 0;
    v17.i32[1] = v13;
    int32x2_t v18 = vadd_s32(v16, v17);
    HIWORD(v26) = v18.i16[2];
    LOWORD(v26) = v18.i16[0];
    *(double *)&long long v19 = xdr::convert_image_to_image(a1, a3, a4, v26, a6, v24, v15);
    char v20 = &v27[v13];
    *char v20 = v19;
    *(int32x2_t *)&long long v19 = vadd_s32((int32x2_t)__PAIR64__(v13, 1), v16);
    HIWORD(v25) = WORD2(v19);
    LOWORD(v25) = v19;
    *(double *)&long long v22 = xdr::convert_image_to_image(a1, a3, a4, v25, a6, v24, v21);
    v20[2] = v22;
    ++v13;
  }
  while (v13 != 2);
  return xdr::image_write_loop<(unsigned short)2,(unsigned short)2>(a2, (uint64_t)v27, a5, *(uint16x4_t *)&v22);
}

float32x4_t *xdr::image_write_loop<(unsigned short)2,(unsigned short)2>(float32x4_t *result, uint64_t a2, __int32 a3, uint16x4_t a4)
{
  __int32 v5 = result;
  a4.i32[0] = a3;
  int32x2_t v6 = (int32x2_t)vmovl_u16(a4).u64[0];
  __int32 v7 = result[1].i32[0];
  if (v7 != 3)
  {
    if (v7 == 2)
    {
      int16x4_t v20 = *(int16x4_t *)result[7].f32;
      uint16x4_t v21 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x200020001);
      v21.i16[3] = v21.i16[2];
      if ((vminv_u16(v21) & 0x8000) != 0)
      {
        uint64_t v47 = 0;
        int8x8_t v48 = (int8x8_t)vadd_s32(v6, v6);
        float32x2_t v49 = 0;
        char v50 = 1;
        float32x4_t v51 = 0uLL;
        float32x4_t v52 = (float32x4_t)xmmword_18898C460;
        do
        {
          uint64_t v53 = 0;
          char v54 = v50;
          char v55 = 1;
          do
          {
            float32x4_t v56 = *(float32x4_t *)(a2 + 32 * v53 + 16 * v47);
            char v57 = v55;
            v56.i32[3] = 0;
            float32x4_t v58 = vmaxnmq_f32(v56, v51);
            v58.i32[3] = 0;
            float32x4_t v59 = vminnmq_f32(v58, v52);
            int8x16_t v60 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v59.f32[0]), v5[5], *(float32x2_t *)v59.f32, 1), v5[6], v59, 2), v5[2]);
            float32x2_t v61 = (float32x2_t)vextq_s8(v60, v60, 4uLL).u64[0];
            v59.i32[0] = v60.i32[0];
            *(int8x8_t *)v60.i8 = vorr_s8((int8x8_t)__PAIR64__(v47, v53), v48);
            HIWORD(v100) = v60.i16[2];
            float32x2_t v49 = vadd_f32(v49, v61);
            LOWORD(v100) = v60.i16[0];
            (*(void (**)(uint64_t, void, float32_t))(*(void *)v5->i64[0] + 24))(v5->i64[0], v100, v59.f32[0]);
            float32x4_t v52 = (float32x4_t)xmmword_18898C460;
            float32x4_t v51 = 0uLL;
            char v55 = 0;
            uint64_t v53 = 1;
          }
          while ((v57 & 1) != 0);
          char v50 = 0;
          uint64_t v47 = 1;
        }
        while ((v54 & 1) != 0);
        uint64_t v18 = v5->i64[1];
        __asm { FMOV            V0.2S, #0.25 }
        v19.n128_u64[0] = (unint64_t)vmul_f32(v49, _D0);
      }
      else
      {
        uint16x4_t v22 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x100020001);
        v22.i16[3] = v22.i16[2];
        if ((vminv_u16(v22) & 0x8000) != 0)
        {
          uint64_t v64 = 0;
          int8x8_t v65 = (int8x8_t)vadd_s32(v6, v6);
          v20.i32[0] = a3;
          unsigned __int16 v93 = vmovl_u16((uint16x4_t)v20).u16[0];
          __int16 v66 = 2 * v6.i16[2];
          char v67 = 1;
          do
          {
            uint64_t v68 = 0;
            char v69 = v67;
            float32x2_t v70 = 0;
            char v71 = 1;
            do
            {
              float32x4_t v72 = *(float32x4_t *)(a2 + 32 * v68 + 16 * v64);
              char v73 = v71;
              v72.i32[3] = 0;
              float32x4_t v74 = vmaxnmq_f32(v72, (float32x4_t)0);
              v74.i32[3] = 0;
              float32x4_t v75 = vminnmq_f32(v74, (float32x4_t)xmmword_18898C460);
              int8x16_t v76 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v75.f32[0]), v5[5], *(float32x2_t *)v75.f32, 1), v5[6], v75, 2), v5[2]);
              float32x2_t v77 = (float32x2_t)vextq_s8(v76, v76, 4uLL).u64[0];
              v75.i32[0] = v76.i32[0];
              *(int8x8_t *)v76.i8 = vorr_s8((int8x8_t)__PAIR64__(v64, v68), v65);
              HIWORD(v99) = v76.i16[2];
              float32x2_t v70 = vadd_f32(v70, v77);
              LOWORD(v99) = v76.i16[0];
              (*(void (**)(uint64_t, void, float32_t))(*(void *)v5->i64[0] + 24))(v5->i64[0], v99, v75.f32[0]);
              char v71 = 0;
              uint64_t v68 = 1;
            }
            while ((v73 & 1) != 0);
            v78.n128_u64[0] = (unint64_t)vmul_f32(v70, (float32x2_t)0x3F0000003F000000);
            v78.n128_u64[1] = 0x3F80000000000000;
            HIWORD(v98) = v66 | v64;
            LOWORD(v98) = v93;
            double result = (float32x4_t *)(*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[1] + 24))(v5->i64[1], v98, v78);
            char v67 = 0;
            uint64_t v64 = 1;
          }
          while ((v69 & 1) != 0);
          return result;
        }
        uint16x4_t v23 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x1000100010001);
        v23.i16[3] = v23.i16[2];
        if ((vminv_u16(v23) & 0x8000) != 0)
        {
          uint64_t v79 = 0;
          int8x8_t v80 = (int8x8_t)vadd_s32(v6, v6);
          char v81 = 1;
          float32x4_t v82 = 0uLL;
          float32x4_t v83 = (float32x4_t)xmmword_18898C460;
          do
          {
            uint64_t v84 = 0;
            char v85 = v81;
            char v86 = 1;
            do
            {
              char v87 = v86;
              float32x4_t v88 = *(float32x4_t *)(a2 + 32 * v84 + 16 * v79);
              v88.i32[3] = 0;
              float32x4_t v89 = vmaxnmq_f32(v88, v82);
              v89.i32[3] = 0;
              float32x4_t v90 = vminnmq_f32(v89, v83);
              int8x16_t v95 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v90.f32[0]), v5[5], *(float32x2_t *)v90.f32, 1), v5[6], v90, 2), v5[2]);
              int8x8_t v91 = vorr_s8((int8x8_t)__PAIR64__(v79, v84), v80);
              HIWORD(v97) = v91.i16[2];
              LOWORD(v97) = v91.i16[0];
              (*(void (**)(uint64_t, void, float))(*(void *)v5->i64[0] + 24))(v5->i64[0], v97, *(float *)v95.i32);
              v92.n128_u64[0] = vextq_s8(v95, v95, 4uLL).u64[0];
              v92.n128_u64[1] = 0x3F80000000000000;
              double result = (float32x4_t *)(*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[1] + 24))(v5->i64[1], v97, v92);
              float32x4_t v83 = (float32x4_t)xmmword_18898C460;
              float32x4_t v82 = 0uLL;
              char v86 = 0;
              uint64_t v84 = 1;
            }
            while ((v87 & 1) != 0);
            char v81 = 0;
            uint64_t v79 = 1;
          }
          while ((v85 & 1) != 0);
          return result;
        }
        uint16x4_t v24 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x2000200020002);
        v24.i16[3] = v24.i16[2];
        if ((vminv_u16(v24) & 0x8000) == 0) {
          return result;
        }
        uint64_t v25 = 0;
        char v26 = 1;
        float32x4_t v27 = 0uLL;
        do
        {
          uint64_t v28 = 0;
          char v29 = v26;
          char v30 = 1;
          do
          {
            float32x4_t v31 = *(float32x4_t *)(a2 + 32 * v28 + 16 * v25);
            v31.i32[3] = 0;
            float32x4_t v32 = vmaxnmq_f32(v31, (float32x4_t)0);
            v32.i32[3] = 0;
            float32x4_t v33 = vminnmq_f32(v32, (float32x4_t)xmmword_18898C460);
            char v34 = v30;
            float32x4_t v27 = vaddq_f32(v27, vmlaq_f32(result[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(result[4], v33.f32[0]), result[5], *(float32x2_t *)v33.f32, 1), result[6], v33, 2), result[2]));
            uint64_t v28 = 1;
            char v30 = 0;
          }
          while ((v34 & 1) != 0);
          char v26 = 0;
          uint64_t v25 = 1;
        }
        while ((v29 & 1) != 0);
        v35.n128_f32[0] = 0.25 * v27.f32[0];
        v35.n128_u32[1] = 0;
        v35.n128_u32[2] = 0;
        v35.n128_u32[3] = 1.0;
        int8x16_t v94 = (int8x16_t)v27;
        (*(void (**)(__n128))(*(void *)result->i64[0] + 24))(v35);
        uint64_t v18 = v5->i64[1];
        __asm { FMOV            V1.2S, #0.25 }
        v19.n128_u64[0] = (unint64_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v94, v94, 4uLL), _D1);
      }
      v19.n128_u64[1] = 0x3F80000000000000;
LABEL_29:
      float v63 = *(uint64_t (**)(__n128))(*(void *)v18 + 24);
      return (float32x4_t *)v63(v19);
    }
    if (v7 != 1) {
      return result;
    }
  }
  int v8 = result[7].u16[0];
  if (v8 != 1)
  {
    if (v8 != 2) {
      return result;
    }
    uint64_t v9 = 0;
    float32x4_t v10 = 0uLL;
    char v11 = 1;
    do
    {
      char v12 = v11;
      float32x4_t v10 = vaddq_f32(vaddq_f32(v10, *(float32x4_t *)(a2 + 16 * v9)), *(float32x4_t *)(a2 + 16 * v9 + 32));
      uint64_t v9 = 1;
      char v11 = 0;
    }
    while ((v12 & 1) != 0);
    __asm { FMOV            V1.4S, #0.25 }
    __n128 v19 = (__n128)vmlaq_f32(result[3], vmulq_f32(v10, _Q1), result[2]);
    uint64_t v18 = result->i64[0];
    v19.n128_u32[3] = 1.0;
    goto LABEL_29;
  }
  uint64_t v37 = 0;
  int8x8_t v38 = (int8x8_t)vadd_s32(v6, v6);
  char v39 = 1;
  float v40 = 1.0;
  do
  {
    uint64_t v41 = 0;
    char v42 = v39;
    char v43 = 1;
    do
    {
      char v44 = v43;
      __n128 v45 = (__n128)vmlaq_f32(v5[3], *(float32x4_t *)(a2 + 32 * v41 + 16 * v37), v5[2]);
      v45.n128_f32[3] = v40;
      int8x8_t v46 = vorr_s8((int8x8_t)__PAIR64__(v37, v41), v38);
      HIWORD(v96) = v46.i16[2];
      LOWORD(v96) = v46.i16[0];
      double result = (float32x4_t *)(*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[0] + 24))(v5->i64[0], v96, v45);
      float v40 = 1.0;
      char v43 = 0;
      uint64_t v41 = 1;
    }
    while ((v44 & 1) != 0);
    char v39 = 0;
    uint64_t v37 = 1;
  }
  while ((v42 & 1) != 0);
  return result;
}

void ___ZN3xdr44dispatch_convert_gainmap_image_to_image_loopILt1ELt1EEEvRKNS_7imageInES3_RKNS_8imageOutERKNS_16colorTransformInERKNS_15gainTransformInERKNS_17colorTransformOutEDv2_t_block_invoke(uint64_t a1, __int16 a2, double a3, uint16x4_t a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v10 = 0x100000000;
  int v11 = 1;
  if (*(_WORD *)(a1 + 96))
  {
    int v6 = 0;
    do
    {
      HIWORD(v9) = a2;
      LOWORD(v9) = v6;
      __int32 v7 = *(float32x4_t **)(a1 + 64);
      *(double *)v8.i64 = xdr::convert_gainmap_image_to_image(*(void *)(a1 + 48), *(void *)(a1 + 56), *(float32x4_t **)(a1 + 72), *(void *)(a1 + 80), *(float32x4_t **)(a1 + 88), v9, &v10, *(int8x16_t *)(a1 + 32), a4);
      float32x4_t v12 = v8;
      xdr::image_write_loop<(unsigned short)1,(unsigned short)1>(v7, &v12, *(int16x4_t *)v8.f32);
      ++v6;
    }
    while (*(unsigned __int16 *)(a1 + 96) > (unsigned __int16)v6);
  }
}

double xdr::convert_gainmap_image_to_image(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4, float32x4_t *a5, __int32 a6, _DWORD *a7, int8x16_t a8, uint16x4_t a9)
{
  a9.i32[0] = a6;
  double v28 = COERCE_DOUBLE(vmla_f32((float32x2_t)*(_OWORD *)&vextq_s8(a8, a8, 8uLL), vadd_f32((float32x2_t)vorr_s8((int8x8_t)*(_OWORD *)&vmovl_u16(a9), (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), *(float32x2_t *)a8.i8));
  xdr::image_sample(a1, a7, v28);
  float32x4_t v27 = v14;
  xdr::image_sample(a2, a7, v28);
  float32x4_t v29 = v15;
  *(double *)v16.i64 = xdr::apply_color_trc((uint64_t)a3, v27);
  xdr::apply_tone_mapping((uint64_t)&a3[5], v16, v17, v18, v19);
  if (!a3[22].i8[0]) {
    float32x4_t v20 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a3[19], v20.f32[0]), a3[20], *(float32x2_t *)v20.f32, 1), a3[21], v20, 2);
  }
  *(double *)v21.i64 = xdr::apply_gain_mapping(a4, v20, v29);
  if (!*(unsigned char *)(a4 + 160))
  {
    float32x4_t v23 = *(float32x4_t *)(a4 + 128);
    float32x4_t v22 = *(float32x4_t *)(a4 + 144);
    int8x16_t v24 = (int8x16_t)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*(float32x4_t *)(a4 + 112), v21.f32[0]), v23, *(float32x2_t *)v21.f32, 1), v22, v21, 2);
    float32x4_t v21 = (float32x4_t)v24;
  }
  if (!a5[3].i8[0])
  {
    float32x4_t v23 = a5[1];
    float32x4_t v22 = a5[2];
    int8x16_t v24 = (int8x16_t)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a5, v21.f32[0]), v23, *(float32x2_t *)v21.f32, 1), v22, v21, 2);
    float32x4_t v21 = (float32x4_t)v24;
  }
  xdr::apply_tone_mapping((uint64_t)&a5[4], v21, *(double *)v22.i64, *(double *)v23.i64, v24);

  return xdr::apply_color_trc((uint64_t)&a5[18], v25);
}

double xdr::apply_gain_mapping(uint64_t a1, float32x4_t a2, float32x4_t a3)
{
  unint64_t v3 = a2.i64[0];
  if (*(_DWORD *)a1 == 2)
  {
    simd_float4 v14 = *(simd_float4 *)(a1 + 16);
    float32x4_t v15 = vabsq_f32(a3);
    v15.i32[3] = 0;
    simd_float4 v16 = (simd_float4)vmaxnmq_f32(v15, (float32x4_t)xmmword_18898C4C0);
    v17.i64[0] = 0x8000000080000000;
    v17.i64[1] = 0x8000000080000000;
    __asm { FMOV            V4.4S, #1.0 }
    v16.i32[3] = 0;
    v14.i32[3] = 0;
    simd_float4 v19 = (simd_float4)vmulq_f32(*(float32x4_t *)(a1 + 96), vmlaq_f32(*(float32x4_t *)(a1 + 48), vmulq_f32((float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a3), (int8x16_t)vcgtzq_f32(a3)), vorrq_s8(vandq_s8((int8x16_t)a3, v17), _Q4), (int8x16_t)0), (float32x4_t)_simd_pow_f4(v16, v14)), *(float32x4_t *)(a1 + 32)));
    v19.i32[3] = 0;
    unint64_t v3 = vmlaq_f32(vnegq_f32(*(float32x4_t *)(a1 + 80)), vaddq_f32(*(float32x4_t *)(a1 + 64), a2), (float32x4_t)_simd_exp2_f4(v19)).u64[0];
  }
  else if (*(_DWORD *)a1 == 1)
  {
    simd_float4 v5 = *(simd_float4 *)(a1 + 16);
    float32x4_t v6 = vabsq_f32(a3);
    v6.i32[3] = 0;
    simd_float4 v7 = (simd_float4)vmaxnmq_f32(v6, (float32x4_t)xmmword_18898C4C0);
    v8.i64[0] = 0x8000000080000000;
    v8.i64[1] = 0x8000000080000000;
    __asm { FMOV            V4.4S, #1.0 }
    v7.i32[3] = 0;
    v5.i32[3] = 0;
    unint64_t v3 = vmulq_f32(a2, vmlaq_f32(*(float32x4_t *)(a1 + 48), vmulq_f32((float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a3), (int8x16_t)vcgtzq_f32(a3)), vorrq_s8(vandq_s8((int8x16_t)a3, v8), _Q4), (int8x16_t)0), (float32x4_t)_simd_pow_f4(v7, v5)), *(float32x4_t *)(a1 + 32))).u64[0];
  }
  return *(double *)&v3;
}

uint64_t ___ZN3xdr44dispatch_convert_gainmap_image_to_image_loopILt2ELt1EEEvRKNS_7imageInES3_RKNS_8imageOutERKNS_16colorTransformInERKNS_15gainTransformInERKNS_17colorTransformOutEDv2_t_block_invoke(uint64_t result, unsigned int a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v20 = 0x100000000;
  int v21 = 1;
  if (*(_WORD *)(result + 96))
  {
    uint64_t v3 = result;
    unsigned int v4 = 0;
    do
    {
      HIWORD(v17) = a2;
      LOWORD(v17) = v4;
      uint64_t v5 = *(void *)(v3 + 48);
      uint64_t v6 = *(void *)(v3 + 56);
      uint64_t v7 = *(void *)(v3 + 64);
      int8x16_t v8 = *(float32x4_t **)(v3 + 72);
      uint64_t v9 = *(void *)(v3 + 80);
      uint64_t v10 = *(float32x4_t **)(v3 + 88);
      int8x16_t v11 = *(int8x16_t *)(v3 + 32);
      long long v22 = 0u;
      long long v23 = 0u;
      int32x2_t v15 = (int32x2_t)vshl_u32((uint32x2_t)__PAIR64__(a2, v4), (uint32x2_t)1);
      int8x16_t v16 = v11;
      HIWORD(v19) = v15.i16[2];
      LOWORD(v19) = v15.i16[0];
      *(double *)&long long v12 = xdr::convert_gainmap_image_to_image(v5, v6, v8, v9, v10, v19, &v20, v11, (uint16x4_t)v15);
      long long v22 = v12;
      *(int32x2_t *)&long long v12 = vadd_s32(v15, (int32x2_t)1);
      HIWORD(v18) = WORD2(v12);
      LOWORD(v18) = v12;
      *(double *)&long long v14 = xdr::convert_gainmap_image_to_image(v5, v6, v8, v9, v10, v18, &v20, v16, v13);
      long long v23 = v14;
      double result = xdr::image_write_loop<(unsigned short)2,(unsigned short)1>(v7, (uint64_t)&v22, v17, *(uint16x4_t *)&v14);
      ++v4;
    }
    while (*(unsigned __int16 *)(v3 + 96) > (unsigned __int16)v4);
  }
  return result;
}

float32x4_t *___ZN3xdr44dispatch_convert_gainmap_image_to_image_loopILt2ELt2EEEvRKNS_7imageInES3_RKNS_8imageOutERKNS_16colorTransformInERKNS_15gainTransformInERKNS_17colorTransformOutEDv2_t_block_invoke(float32x4_t *result, __int16 a2)
{
  uint64_t v6 = 0x100000000;
  int v7 = 1;
  if (result[6].i16[0])
  {
    uint64_t v3 = result;
    int v4 = 0;
    do
    {
      HIWORD(v5) = a2;
      LOWORD(v5) = v4;
      double result = xdr::convert_gainmap_image_to_image_loop<(unsigned short)2,(unsigned short)2>(v3[3].i64[0], v3[3].i64[1], (float32x4_t *)v3[4].i64[0], (float32x4_t *)v3[4].i64[1], v3[5].i64[0], (float32x4_t *)v3[5].i64[1], v5, &v6, (int8x16_t)v3[2]);
      ++v4;
    }
    while (v3[6].u16[0] > (unsigned __int16)v4);
  }
  return result;
}

float32x4_t *xdr::convert_gainmap_image_to_image_loop<(unsigned short)2,(unsigned short)2>(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4, uint64_t a5, float32x4_t *a6, __int32 a7, _DWORD *a8, int8x16_t a9)
{
  int8x16_t v28 = a9;
  uint64_t v15 = 0;
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  a9.i32[0] = a7;
  int32x2_t v16 = (int32x2_t)vmovl_u16(*(uint16x4_t *)a9.i8).u64[0];
  uint16x4_t v17 = 0;
  memset(v31, 0, sizeof(v31));
  int32x2_t v18 = vadd_s32(v16, v16);
  do
  {
    v19.i32[0] = 0;
    v19.i32[1] = v15;
    int32x2_t v20 = vadd_s32(v18, v19);
    HIWORD(v30) = v20.i16[2];
    LOWORD(v30) = v20.i16[0];
    *(double *)&long long v21 = xdr::convert_gainmap_image_to_image(a1, a2, a4, a5, a6, v30, a8, v28, v17);
    long long v22 = &v31[v15];
    _OWORD *v22 = v21;
    *(int32x2_t *)&long long v21 = vadd_s32((int32x2_t)__PAIR64__(v15, 1), v18);
    HIWORD(v29) = WORD2(v21);
    LOWORD(v29) = v21;
    *(double *)&long long v24 = xdr::convert_gainmap_image_to_image(a1, a2, a4, a5, a6, v29, a8, v28, v23);
    v22[2] = v24;
    ++v15;
  }
  while (v15 != 2);
  return xdr::image_write_loop<(unsigned short)2,(unsigned short)2>(a3, (uint64_t)v31, a7, *(uint16x4_t *)&v24);
}

void ___ZN3xdr44dispatch_convert_image_to_gainmap_image_loopILt1ELt1EEEvRKNS_7imageInERKNS_8imageOutES6_RKNS_16colorTransformInES9_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(uint64_t a1, __int16 a2, double a3, uint16x4_t a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v18 = 0x100000000;
  int v19 = 1;
  if (*(_WORD *)(a1 + 104))
  {
    int v6 = 0;
    do
    {
      HIWORD(v17) = a2;
      LOWORD(v17) = v6;
      uint64_t v7 = *(void *)(a1 + 48);
      int8x16_t v8 = *(float32x4_t **)(a1 + 56);
      uint64_t v10 = *(float32x4_t **)(a1 + 64);
      uint64_t v9 = *(float32x4_t **)(a1 + 72);
      int8x16_t v11 = *(float32x4_t **)(a1 + 80);
      long long v12 = *(float32x4_t **)(a1 + 88);
      uint64_t v13 = *(void *)(a1 + 96);
      int8x16_t v14 = *(int8x16_t *)(a1 + 32);
      float32x4_t v20 = 0uLL;
      *(double *)v15.i64 = xdr::convert_image_to_gainmap_image(v7, v9, v11, v12, v13, &v20, v17, &v18, v14, a4);
      float32x4_t v21 = v15;
      int16x4_t v16 = (int16x4_t)xdr::image_write_loop<(unsigned short)1,(unsigned short)1>(v8, &v21, *(int16x4_t *)v15.f32);
      xdr::image_write_loop<(unsigned short)1,(unsigned short)1>(v10, &v20, v16);
      ++v6;
    }
    while (*(unsigned __int16 *)(a1 + 104) > (unsigned __int16)v6);
  }
}

double xdr::convert_image_to_gainmap_image(uint64_t a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, uint64_t a5, _OWORD *a6, __int32 a7, _DWORD *a8, int8x16_t a9, uint16x4_t a10)
{
  a10.i32[0] = a7;
  xdr::image_sample(a1, a8, COERCE_DOUBLE(vmla_f32((float32x2_t)*(_OWORD *)&vextq_s8(a9, a9, 8uLL), vadd_f32((float32x2_t)vorr_s8((int8x8_t)*(_OWORD *)&vmovl_u16(a10), (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), *(float32x2_t *)a9.i8)));
  float32x4_t v34 = v15;
  *(double *)v16.i64 = xdr::apply_color_trc((uint64_t)a2, v15);
  xdr::apply_tone_mapping((uint64_t)&a2[5], v16, v17, v18, v19);
  if (!a2[22].i8[0]) {
    float32x4_t v20 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a2[19], v20.f32[0]), a2[20], *(float32x2_t *)v20.f32, 1), a2[21], v20, 2);
  }
  float32x4_t v35 = v20;
  *(double *)v21.i64 = xdr::apply_color_trc((uint64_t)a3, v34);
  xdr::apply_tone_mapping((uint64_t)&a3[5], v21, v22, v23, v24);
  float32x4_t v26 = v25;
  if (!a3[22].i8[0]) {
    float32x4_t v26 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a3[19], v25.f32[0]), a3[20], *(float32x2_t *)v25.f32, 1), a3[21], v25, 2);
  }
  *(double *)&long long v27 = xdr::apply_gain_transform(a5, v35, v26);
  *a6 = v27;
  if (a4[3].i8[0])
  {
    float32x4_t v31 = v35;
  }
  else
  {
    float32x4_t v28 = a4[1];
    int8x16_t v30 = (int8x16_t)v35;
    float32x4_t v29 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a4, v35.f32[0]), v28, *(float32x2_t *)v35.f32, 1), a4[2], v35, 2);
    float32x4_t v31 = v29;
  }
  xdr::apply_tone_mapping((uint64_t)&a4[4], v31, *(double *)v28.i64, *(double *)v29.i64, v30);

  return xdr::apply_color_trc((uint64_t)&a4[18], v32);
}

double xdr::apply_gain_transform(uint64_t a1, float32x4_t a2, float32x4_t a3)
{
  if (!*(unsigned char *)(a1 + 160))
  {
    float32x4_t v5 = *(float32x4_t *)(a1 + 128);
    float32x4_t v4 = *(float32x4_t *)(a1 + 144);
    float32x4_t v6 = *(float32x4_t *)(a1 + 112);
    a2 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v6, a2.f32[0]), v5, *(float32x2_t *)a2.f32, 1), v4, a2, 2);
    a3 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v6, a3.f32[0]), v5, *(float32x2_t *)a3.f32, 1), v4, a3, 2);
  }
  if (*(unsigned char *)(a1 + 208))
  {
    float32x4_t v7 = *(float32x4_t *)(a1 + 192);
    a2.i32[3] = fmaxf(a2.f32[0], fmaxf(a2.f32[1], a2.f32[2]));
    int8x16_t v8 = (int8x16_t)vmulq_f32(a2, v7);
    *(float32x2_t *)v8.i8 = vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v8, v8, 8uLL));
    a3.i32[3] = fmaxf(a3.f32[0], fmaxf(a3.f32[1], a3.f32[2]));
    int8x16_t v9 = (int8x16_t)vmulq_f32(a3, v7);
    *(float32x2_t *)v9.i8 = vadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v9, v9, 8uLL));
    a2 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v8.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v8.i8, 1)), 0);
    a3 = (float32x4_t)vdupq_lane_s32((int32x2_t)vadd_f32(*(float32x2_t *)v9.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v9.i8, 1)), 0);
  }
  int32x2_t v10 = *(int32x2_t *)(a1 + 176);
  a2.i32[3] = 0;
  double v11 = 0.0;
  float32x4_t v12 = vmaxnmq_f32(a2, (float32x4_t)0);
  v12.i32[3] = 0;
  float32x4_t v13 = (float32x4_t)vdupq_lane_s32(v10, 0);
  v13.i32[3] = 0;
  a3.i32[3] = 0;
  float32x4_t v14 = vmaxnmq_f32(a3, (float32x4_t)0);
  v14.i32[3] = 0;
  float32x4_t v15 = (float32x4_t)vdupq_lane_s32(v10, 1);
  float32x4_t v16 = vminnmq_f32(v12, v13);
  v15.i32[3] = 0;
  float32x4_t v17 = vminnmq_f32(v14, v15);
  if (*(_DWORD *)a1 == 2)
  {
    simd_float4 v19 = (simd_float4)vdivq_f32(vaddq_f32(v17, *(float32x4_t *)(a1 + 80)), vaddq_f32(v16, *(float32x4_t *)(a1 + 64)));
    v19.i32[3] = 0;
    simd_float4 v18 = _simd_log2_f4(v19);
    goto LABEL_9;
  }
  if (*(_DWORD *)a1 == 1)
  {
    simd_float4 v18 = (simd_float4)vdivq_f32(vaddq_f32(v17, *(float32x4_t *)(a1 + 64)), vaddq_f32(v16, *(float32x4_t *)(a1 + 64)));
LABEL_9:
    simd_float4 v20 = *(simd_float4 *)(a1 + 16);
    float32x4_t v21 = vmlaq_f32(*(float32x4_t *)(a1 + 48), (float32x4_t)v18, *(float32x4_t *)(a1 + 32));
    float32x4_t v22 = vabsq_f32(v21);
    v22.i32[3] = 0;
    simd_float4 v23 = (simd_float4)vmaxnmq_f32(v22, (float32x4_t)xmmword_18898C4C0);
    v24.i64[0] = 0x8000000080000000;
    v24.i64[1] = 0x8000000080000000;
    __asm { FMOV            V4.4S, #1.0 }
    v23.i32[3] = 0;
    v20.i32[3] = 0;
    *(void *)&double v11 = vmulq_f32((float32x4_t)_simd_pow_f4(v23, v20), (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v21), (int8x16_t)vcgtzq_f32(v21)), vorrq_s8(vandq_s8((int8x16_t)v21, v24), _Q4), (int8x16_t)0)).u64[0];
  }
  return v11;
}

uint64_t ___ZN3xdr44dispatch_convert_image_to_gainmap_image_loopILt2ELt1EEEvRKNS_7imageInERKNS_8imageOutES6_RKNS_16colorTransformInES9_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(uint64_t result, __int16 a2, double a3, uint16x4_t a4)
{
  uint64_t v8 = 0x100000000;
  int v9 = 1;
  if (*(_WORD *)(result + 104))
  {
    uint64_t v5 = result;
    int v6 = 0;
    do
    {
      HIWORD(v7) = a2;
      LOWORD(v7) = v6;
      double result = xdr::convert_image_to_gainmap_image_loop<(unsigned short)2,(unsigned short)1>(*(void *)(v5 + 48), *(void *)(v5 + 56), *(void *)(v5 + 64), *(float32x4_t **)(v5 + 72), *(float32x4_t **)(v5 + 80), *(float32x4_t **)(v5 + 88), *(void *)(v5 + 96), v7, *(int8x16_t *)(v5 + 32), a4, &v8);
      ++v6;
    }
    while (*(unsigned __int16 *)(v5 + 104) > (unsigned __int16)v6);
  }
  return result;
}

uint64_t xdr::convert_image_to_gainmap_image_loop<(unsigned short)2,(unsigned short)1>(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, uint64_t a7, __int32 a8, int8x16_t a9, uint16x4_t a10, _DWORD *a11)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  a10.i32[0] = a8;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  int32x2_t v24 = (int32x2_t)vshl_u32((uint32x2_t)*(_OWORD *)&vmovl_u16(a10), (uint32x2_t)1);
  HIWORD(v27) = v24.i16[2];
  LOWORD(v27) = v24.i16[0];
  *(double *)&long long v19 = xdr::convert_image_to_gainmap_image(a1, a4, a5, a6, a7, &v28, v27, a11, a9, (uint16x4_t)v24);
  long long v30 = v19;
  *(int32x2_t *)&long long v19 = vadd_s32(v24, (int32x2_t)1);
  HIWORD(v26) = WORD2(v19);
  LOWORD(v26) = v19;
  *(double *)&long long v21 = xdr::convert_image_to_gainmap_image(a1, a4, a5, a6, a7, &v29, v26, a11, a9, v20);
  long long v31 = v21;
  xdr::image_write_loop<(unsigned short)2,(unsigned short)1>(a2, (uint64_t)&v30, a8, *(uint16x4_t *)&v21);
  return xdr::image_write_loop<(unsigned short)2,(unsigned short)1>(a3, (uint64_t)&v28, a8, v22);
}

float32x4_t *___ZN3xdr44dispatch_convert_image_to_gainmap_image_loopILt2ELt2EEEvRKNS_7imageInERKNS_8imageOutES6_RKNS_16colorTransformInES9_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(float32x4_t *result, __int16 a2)
{
  uint64_t v6 = 0x100000000;
  int v7 = 1;
  if (result[6].i16[4])
  {
    uint64_t v3 = result;
    int v4 = 0;
    do
    {
      HIWORD(v5) = a2;
      LOWORD(v5) = v4;
      double result = xdr::convert_image_to_gainmap_image_loop<(unsigned short)2,(unsigned short)2>(v3[3].i64[0], (float32x4_t *)v3[3].i64[1], (float32x4_t *)v3[4].i64[0], (float32x4_t *)v3[4].i64[1], (float32x4_t *)v3[5].i64[0], (float32x4_t *)v3[5].i64[1], v3[6].i64[0], v5, (int8x16_t)v3[2], &v6);
      ++v4;
    }
    while (v3[6].u16[4] > (unsigned __int16)v4);
  }
  return result;
}

float32x4_t *xdr::convert_image_to_gainmap_image_loop<(unsigned short)2,(unsigned short)2>(uint64_t a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, uint64_t a7, __int32 a8, int8x16_t a9, _DWORD *a10)
{
  int8x16_t v31 = a9;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  a9.i32[0] = a8;
  uint16x4_t v17 = 0;
  memset(v35, 0, sizeof(v35));
  int32x2_t v18 = (int32x2_t)vmovl_u16(*(uint16x4_t *)a9.i8).u64[0];
  memset(v34, 0, sizeof(v34));
  int32x2_t v19 = vadd_s32(v18, v18);
  do
  {
    v20.i32[0] = 0;
    v20.i32[1] = v16;
    int32x2_t v21 = vadd_s32(v19, v20);
    HIWORD(v33) = v21.i16[2];
    LOWORD(v33) = v21.i16[0];
    *(double *)&long long v22 = xdr::convert_image_to_gainmap_image(a1, a4, a5, a6, a7, &v34[v15], v33, a10, v31, v17);
    v23.i32[1] = v16;
    v23.i32[0] = 1;
    uint16x4_t v24 = (uint16x4_t)vadd_s32(v23, v19);
    v35[v15] = v22;
    HIWORD(v32) = v24.i16[2];
    LOWORD(v32) = v24.i16[0];
    *(double *)&long long v25 = xdr::convert_image_to_gainmap_image(a1, a4, a5, a6, a7, &v34[v15 + 2], v32, a10, v31, v24);
    v35[v15 + 2] = v25;
    ++v16;
    ++v15;
  }
  while (v16 != 2);
  xdr::image_write_loop<(unsigned short)2,(unsigned short)2>(a2, (uint64_t)v35, a8, *(uint16x4_t *)&v25);
  return xdr::image_write_loop<(unsigned short)2,(unsigned short)2>(a3, (uint64_t)v34, a8, v26);
}

uint64_t ___ZN3xdr44dispatch_convert_image_to_gainmap_image_loopILt4ELt2EEEvRKNS_7imageInERKNS_8imageOutES6_RKNS_16colorTransformInES9_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(uint64_t result, __int16 a2, double a3, uint16x4_t a4)
{
  uint64_t v8 = 0x100000000;
  int v9 = 1;
  if (*(_WORD *)(result + 104))
  {
    uint64_t v5 = result;
    int v6 = 0;
    do
    {
      HIWORD(v7) = a2;
      LOWORD(v7) = v6;
      double result = xdr::convert_image_to_gainmap_image_loop<(unsigned short)4,(unsigned short)2>(*(void *)(v5 + 48), *(void *)(v5 + 56), *(void *)(v5 + 64), *(float32x4_t **)(v5 + 72), *(float32x4_t **)(v5 + 80), *(float32x4_t **)(v5 + 88), *(void *)(v5 + 96), v7, *(int8x16_t *)(v5 + 32), a4, &v8);
      ++v6;
    }
    while (*(unsigned __int16 *)(v5 + 104) > (unsigned __int16)v6);
  }
  return result;
}

uint64_t xdr::convert_image_to_gainmap_image_loop<(unsigned short)4,(unsigned short)2>(uint64_t a1, uint64_t a2, uint64_t a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, uint64_t a7, __int32 a8, int8x16_t a9, uint16x4_t a10, _DWORD *a11)
{
  int8x16_t v15 = a9;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  a10.i32[0] = a8;
  uint16x4_t v19 = (uint16x4_t)vmovl_u16(a10).u64[0];
  int32x2_t v20 = (int32x2_t)vshl_u32((uint32x2_t)v19, (uint32x2_t)0x100000002);
  memset(v33, 0, 128);
  memset(v32, 0, sizeof(v32));
  do
  {
    uint64_t v21 = 0;
    uint64_t v29 = v17;
    do
    {
      int32x2_t v22 = vadd_s32((int32x2_t)__PAIR64__(v18, v21), v20);
      HIWORD(v31) = v22.i16[2];
      LOWORD(v31) = v22.i16[0];
      *(double *)&long long v23 = xdr::convert_image_to_gainmap_image(a1, a4, a5, a6, a7, (_OWORD *)((char *)v32 + v17), v31, a11, v15, v19);
      int8x16_t v15 = a9;
      *(_OWORD *)&v33[v17] = v23;
      ++v21;
      v17 += 32;
    }
    while (v21 != 4);
    ++v18;
    uint64_t v17 = v29 + 16;
  }
  while (v18 != 2);
  xdr::image_write_loop<(unsigned short)4,(unsigned short)2>(a2, (uint64_t)v33, a8, *(uint16x4_t *)&v23);
  return xdr::image_write_loop<(unsigned short)4,(unsigned short)2>(a3, (uint64_t)v32, a8, v24);
}

uint64_t xdr::image_write_loop<(unsigned short)4,(unsigned short)2>(uint64_t result, uint64_t a2, __int32 a3, uint16x4_t a4)
{
  uint64_t v5 = (float32x4_t *)result;
  a4.i32[0] = a3;
  uint32x2_t v6 = (uint32x2_t)vmovl_u16(a4).u64[0];
  int v7 = *(_DWORD *)(result + 16);
  if (v7 == 3)
  {
LABEL_4:
    int v8 = *(unsigned __int16 *)(result + 112);
    if (v8 == 1)
    {
      uint64_t v52 = 0;
      int32x2_t v53 = (int32x2_t)vshl_u32(v6, (uint32x2_t)0x100000002);
      char v54 = 1;
      float v55 = 1.0;
      do
      {
        uint64_t v56 = 0;
        char v57 = v54;
        float32x4_t v58 = (float32x4_t *)(a2 + 16 * v52);
        do
        {
          float32x4_t v59 = *v58;
          v58 += 2;
          __n128 v60 = (__n128)vmlaq_f32(v5[3], v59, v5[2]);
          v60.n128_f32[3] = v55;
          int32x2_t v61 = vadd_s32((int32x2_t)__PAIR64__(v52, v56), v53);
          HIWORD(v143) = v61.i16[2];
          LOWORD(v143) = v61.i16[0];
          double result = (*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[0] + 24))(v5->i64[0], v143, v60);
          float v55 = 1.0;
          ++v56;
        }
        while (v56 != 4);
        char v54 = 0;
        uint64_t v52 = 1;
      }
      while ((v57 & 1) != 0);
    }
    else if (v8 == 2)
    {
      uint64_t v9 = 0;
      int32x2_t v10 = (int32x2_t)vshl_u32(v6, (uint32x2_t)1);
      char v11 = 1;
      __asm { FMOV            V0.4S, #0.25 }
      float32x4_t v140 = _Q0;
      do
      {
        uint64_t v17 = 0;
        char v18 = v11;
        char v19 = 1;
        float32x4_t v20 = 0uLL;
        do
        {
          char v21 = v19;
          float32x4_t v20 = vaddq_f32(vaddq_f32(v20, *(float32x4_t *)(a2 + (v9 << 6) + 16 * v17)), *(float32x4_t *)(a2 + 32 * ((2 * v9) | 1) + 16 * v17));
          uint64_t v17 = 1;
          char v19 = 0;
        }
        while ((v21 & 1) != 0);
        __n128 v22 = (__n128)vmlaq_f32(v5[3], vmulq_f32(v20, v140), v5[2]);
        v22.n128_u32[3] = 1.0;
        int32x2_t v23 = vadd_s32((int32x2_t)v9, v10);
        HIWORD(v144) = v23.i16[2];
        LOWORD(v144) = v23.i16[0];
        double result = (*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[0] + 24))(v5->i64[0], v144, v22);
        char v11 = 0;
        uint64_t v9 = 1;
      }
      while ((v18 & 1) != 0);
    }
    return result;
  }
  if (v7 != 2)
  {
    if (v7 != 1) {
      return result;
    }
    goto LABEL_4;
  }
  int16x4_t v24 = *(int16x4_t *)(result + 112);
  uint16x4_t v25 = (uint16x4_t)vceq_s16(v24, (int16x4_t)0x200020001);
  v25.i16[3] = v25.i16[2];
  if ((vminv_u16(v25) & 0x8000) != 0)
  {
    uint64_t v62 = 0;
    int32x2_t v63 = (int32x2_t)vshl_u32(v6, (uint32x2_t)0x100000002);
    int32x2_t v64 = (int32x2_t)vshl_u32(v6, (uint32x2_t)1);
    char v65 = 1;
    __asm { FMOV            V10.2S, #0.25 }
    do
    {
      uint64_t v67 = 0;
      char v68 = v65;
      float32x2_t v69 = 0;
      char v70 = 1;
      do
      {
        uint64_t v71 = 0;
        char v72 = v70;
        char v73 = 1;
        do
        {
          uint64_t v74 = v71 | (2 * v62);
          float32x4_t v75 = *(float32x4_t *)(a2 + 32 * v74 + 16 * v67);
          char v76 = v73;
          v75.i32[3] = 0;
          float32x4_t v77 = vmaxnmq_f32(v75, (float32x4_t)0);
          v77.i32[3] = 0;
          float32x4_t v78 = vminnmq_f32(v77, (float32x4_t)xmmword_18898C460);
          int8x16_t v79 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v78.f32[0]), v5[5], *(float32x2_t *)v78.f32, 1), v5[6], v78, 2), v5[2]);
          float32x2_t v80 = (float32x2_t)vextq_s8(v79, v79, 4uLL).u64[0];
          v78.i32[0] = v79.i32[0];
          *(int32x2_t *)v79.i8 = vadd_s32((int32x2_t)__PAIR64__(v67, v74), v63);
          HIWORD(v151) = v79.i16[2];
          float32x2_t v69 = vadd_f32(v69, v80);
          LOWORD(v151) = v79.i16[0];
          (*(void (**)(uint64_t, void, float32_t))(*(void *)v5->i64[0] + 24))(v5->i64[0], v151, v78.f32[0]);
          char v73 = 0;
          uint64_t v71 = 1;
        }
        while ((v76 & 1) != 0);
        char v70 = 0;
        uint64_t v67 = 1;
      }
      while ((v72 & 1) != 0);
      v81.n128_u64[0] = (unint64_t)vmul_f32(v69, _D10);
      v81.n128_u64[1] = 0x3F80000000000000;
      int32x2_t v82 = vadd_s32((int32x2_t)v62, v64);
      HIWORD(v150) = v82.i16[2];
      LOWORD(v150) = v82.i16[0];
      double result = (*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[1] + 24))(v5->i64[1], v150, v81);
      char v65 = 0;
      uint64_t v62 = 1;
    }
    while ((v68 & 1) != 0);
  }
  else
  {
    uint16x4_t v26 = (uint16x4_t)vceq_s16(v24, (int16x4_t)0x100020001);
    v26.i16[3] = v26.i16[2];
    if ((vminv_u16(v26) & 0x8000) != 0)
    {
      uint64_t v83 = 0;
      int32x2_t v84 = (int32x2_t)vshl_u32(v6, (uint32x2_t)0x100000002);
      int v85 = 2 * a3;
      __int16 v86 = 2 * v6.i16[2];
      v87.i32[1] = 1065353216;
      char v88 = 1;
      do
      {
        uint64_t v89 = 0;
        char v90 = v88;
        uint64_t v91 = 2 * v83;
        v87.i32[0] = v85 | v83;
        unsigned __int16 v139 = vmovl_u16(v87).u16[0];
        char v92 = 1;
        do
        {
          uint64_t v93 = 0;
          char v94 = v92;
          float32x2_t v95 = 0;
          char v96 = 1;
          do
          {
            uint64_t v97 = v93 | v91;
            float32x4_t v98 = *(float32x4_t *)(a2 + 32 * v97 + 16 * v89);
            char v99 = v96;
            v98.i32[3] = 0;
            float32x4_t v100 = vmaxnmq_f32(v98, (float32x4_t)0);
            v100.i32[3] = 0;
            float32x4_t v101 = vminnmq_f32(v100, (float32x4_t)xmmword_18898C460);
            int8x16_t v102 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v101.f32[0]), v5[5], *(float32x2_t *)v101.f32, 1), v5[6], v101, 2), v5[2]);
            float32x2_t v103 = (float32x2_t)vextq_s8(v102, v102, 4uLL).u64[0];
            v101.i32[0] = v102.i32[0];
            *(int32x2_t *)v102.i8 = vadd_s32((int32x2_t)__PAIR64__(v89, v97), v84);
            HIWORD(v149) = v102.i16[2];
            float32x2_t v95 = vadd_f32(v95, v103);
            LOWORD(v149) = v102.i16[0];
            (*(void (**)(uint64_t, void, float32_t))(*(void *)v5->i64[0] + 24))(v5->i64[0], v149, v101.f32[0]);
            char v96 = 0;
            uint64_t v93 = 1;
          }
          while ((v99 & 1) != 0);
          v104.n128_u64[0] = (unint64_t)vmul_f32(v95, (float32x2_t)0x3F0000003F000000);
          v104.n128_u64[1] = 0x3F80000000000000;
          HIWORD(v148) = v86 | v89;
          LOWORD(v148) = v139;
          double result = (*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[1] + 24))(v5->i64[1], v148, v104);
          char v92 = 0;
          uint64_t v89 = 1;
        }
        while ((v94 & 1) != 0);
        char v88 = 0;
        uint64_t v83 = 1;
      }
      while ((v90 & 1) != 0);
    }
    else
    {
      uint16x4_t v27 = (uint16x4_t)vceq_s16(v24, (int16x4_t)0x1000100010001);
      v27.i16[3] = v27.i16[2];
      if ((vminv_u16(v27) & 0x8000) != 0)
      {
        uint64_t v105 = 0;
        int32x2_t v106 = (int32x2_t)vshl_u32(v6, (uint32x2_t)0x100000002);
        char v107 = 1;
        float32x4_t v108 = 0uLL;
        float32x4_t v109 = (float32x4_t)xmmword_18898C460;
        do
        {
          uint64_t v110 = 0;
          char v111 = v107;
          int8x16_t v112 = (float32x4_t *)(a2 + 16 * v105);
          do
          {
            float32x4_t v113 = *v112;
            v112 += 2;
            float32x4_t v114 = v113;
            v114.i32[3] = 0;
            float32x4_t v115 = vmaxnmq_f32(v114, v108);
            v115.i32[3] = 0;
            float32x4_t v116 = vminnmq_f32(v115, v109);
            int32x2_t v117 = vadd_s32((int32x2_t)__PAIR64__(v105, v110), v106);
            int8x16_t v141 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v116.f32[0]), v5[5], *(float32x2_t *)v116.f32, 1), v5[6], v116, 2), v5[2]);
            HIWORD(v147) = v117.i16[2];
            LOWORD(v147) = v117.i16[0];
            (*(void (**)(uint64_t, void, float))(*(void *)v5->i64[0] + 24))(v5->i64[0], v147, *(float *)v141.i32);
            v118.n128_u64[0] = vextq_s8(v141, v141, 4uLL).u64[0];
            v118.n128_u64[1] = 0x3F80000000000000;
            double result = (*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[1] + 24))(v5->i64[1], v147, v118);
            float32x4_t v109 = (float32x4_t)xmmword_18898C460;
            float32x4_t v108 = 0uLL;
            ++v110;
          }
          while (v110 != 4);
          char v107 = 0;
          uint64_t v105 = 1;
        }
        while ((v111 & 1) != 0);
      }
      else
      {
        uint16x4_t v28 = (uint16x4_t)vceq_s16(v24, (int16x4_t)0x2000200020002);
        v28.i16[3] = v28.i16[2];
        if ((vminv_u16(v28) & 0x8000) != 0)
        {
          unsigned int v119 = 0;
          int32x2_t v120 = (int32x2_t)vshl_u32(v6, (uint32x2_t)1);
          char v121 = 1;
          float32x4_t v122 = 0uLL;
          float32x4_t v123 = (float32x4_t)xmmword_18898C460;
          __asm { FMOV            V10.2S, #0.25 }
          do
          {
            uint64_t v125 = 0;
            char v126 = v121;
            char v127 = 1;
            float32x4_t v128 = 0uLL;
            do
            {
              uint64_t v129 = 0;
              char v130 = v127;
              char v131 = 1;
              do
              {
                float32x4_t v132 = *(float32x4_t *)(a2 + 32 * v129 + 16 * v125);
                v132.i32[3] = 0;
                float32x4_t v133 = vmaxnmq_f32(v132, v122);
                v133.i32[3] = 0;
                float32x4_t v134 = vminnmq_f32(v133, v123);
                char v135 = v131;
                float32x4_t v128 = vaddq_f32(v128, vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v134.f32[0]), v5[5], *(float32x2_t *)v134.f32, 1), v5[6], v134, 2), v5[2]));
                uint64_t v129 = 1;
                char v131 = 0;
              }
              while ((v135 & 1) != 0);
              char v127 = 0;
              uint64_t v125 = 1;
            }
            while ((v130 & 1) != 0);
            v136.n128_f32[0] = 0.25 * v128.f32[0];
            v136.n128_u32[1] = 0;
            v136.n128_u32[2] = 0;
            v136.n128_u32[3] = 1.0;
            int32x2_t v137 = vadd_s32((int32x2_t)v119, v120);
            HIWORD(v146) = v137.i16[2];
            LOWORD(v146) = v137.i16[0];
            int8x16_t v142 = (int8x16_t)v128;
            (*(void (**)(uint64_t, void, __n128))(*(void *)v5->i64[0] + 24))(v5->i64[0], v146, v136);
            v138.n128_u64[0] = (unint64_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v142, v142, 4uLL), _D10);
            v138.n128_u64[1] = 0x3F80000000000000;
            double result = (*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[1] + 24))(v5->i64[1], v146, v138);
            float32x4_t v123 = (float32x4_t)xmmword_18898C460;
            float32x4_t v122 = 0uLL;
            char v121 = 0;
            unsigned int v119 = 1;
          }
          while ((v126 & 1) != 0);
        }
        else
        {
          uint16x4_t v29 = (uint16x4_t)vceq_s16(v24, (int16x4_t)0x200040002);
          v29.i16[3] = v29.i16[2];
          if ((vminv_u16(v29) & 0x8000) != 0)
          {
            uint64_t v30 = 0;
            int32x2_t v31 = (int32x2_t)vshl_u32(v6, (uint32x2_t)1);
            float32x2_t v32 = 0;
            char v33 = 1;
            float32x4_t v34 = 0uLL;
            float32x4_t v35 = (float32x4_t)xmmword_18898C460;
            __asm { FMOV            V10.2S, #0.25 }
            do
            {
              uint64_t v37 = 0;
              char v38 = v33;
              char v39 = 1;
              float32x4_t v40 = 0uLL;
              do
              {
                uint64_t v41 = 0;
                char v42 = v39;
                char v43 = 1;
                do
                {
                  float32x4_t v44 = *(float32x4_t *)(a2 + 32 * (v41 | (2 * v30)) + 16 * v37);
                  v44.i32[3] = 0;
                  float32x4_t v45 = vmaxnmq_f32(v44, v34);
                  v45.i32[3] = 0;
                  float32x4_t v46 = vminnmq_f32(v45, v35);
                  char v47 = v43;
                  float32x4_t v40 = vaddq_f32(v40, vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v46.f32[0]), v5[5], *(float32x2_t *)v46.f32, 1), v5[6], v46, 2), v5[2]));
                  uint64_t v41 = 1;
                  char v43 = 0;
                }
                while ((v47 & 1) != 0);
                char v39 = 0;
                uint64_t v37 = 1;
              }
              while ((v42 & 1) != 0);
              v48.n128_f32[0] = 0.25 * v40.f32[0];
              v48.n128_u32[1] = 0;
              v48.n128_u32[2] = 0;
              float32x2_t v32 = vmla_f32(v32, _D10, (float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v40, (int8x16_t)v40, 4uLL));
              v48.n128_u32[3] = 1.0;
              int32x2_t v49 = vadd_s32((int32x2_t)v30, v31);
              HIWORD(v145) = v49.i16[2];
              LOWORD(v145) = v49.i16[0];
              (*(void (**)(uint64_t, void, __n128))(*(void *)v5->i64[0] + 24))(v5->i64[0], v145, v48);
              float32x4_t v35 = (float32x4_t)xmmword_18898C460;
              float32x4_t v34 = 0uLL;
              char v33 = 0;
              uint64_t v30 = 1;
            }
            while ((v38 & 1) != 0);
            v50.n128_u64[0] = (unint64_t)vmul_f32(v32, (float32x2_t)0x3F0000003F000000);
            v50.n128_u64[1] = 0x3F80000000000000;
            float32x4_t v51 = *(uint64_t (**)(__n128))(*(void *)v5->i64[1] + 24);
            return v51(v50);
          }
        }
      }
    }
  }
  return result;
}

float32x4_t *___ZN3xdr44dispatch_convert_image_to_gainmap_image_loopILt4ELt4EEEvRKNS_7imageInERKNS_8imageOutES6_RKNS_16colorTransformInES9_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(float32x4_t *result, __int16 a2, double a3, uint16x4_t a4)
{
  uint64_t v8 = 0x100000000;
  int v9 = 1;
  if (result[6].i16[4])
  {
    uint64_t v5 = result;
    int v6 = 0;
    do
    {
      HIWORD(v7) = a2;
      LOWORD(v7) = v6;
      double result = xdr::convert_image_to_gainmap_image_loop<(unsigned short)4,(unsigned short)4>(v5[3].i64[0], (float32x4_t *)v5[3].i64[1], (float32x4_t *)v5[4].i64[0], (float32x4_t *)v5[4].i64[1], (float32x4_t *)v5[5].i64[0], (float32x4_t *)v5[5].i64[1], v5[6].i64[0], v7, (int8x16_t)v5[2], a4, &v8);
      ++v6;
    }
    while (v5[6].u16[4] > (unsigned __int16)v6);
  }
  return result;
}

float32x4_t *xdr::convert_image_to_gainmap_image_loop<(unsigned short)4,(unsigned short)4>(uint64_t a1, float32x4_t *a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, uint64_t a7, __int32 a8, int8x16_t a9, uint16x4_t a10, _DWORD *a11)
{
  int8x16_t v15 = a9;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  a10.i32[0] = a8;
  int32x2_t v19 = (int32x2_t)vmovl_u16(a10).u64[0];
  memset(v33, 0, sizeof(v33));
  int32x2_t v20 = vshl_n_s32(v19, 2uLL);
  memset(v32, 0, sizeof(v32));
  do
  {
    uint64_t v21 = 0;
    uint64_t v29 = v17;
    do
    {
      int32x2_t v22 = vadd_s32((int32x2_t)__PAIR64__(v18, v21), v20);
      HIWORD(v31) = v22.i16[2];
      LOWORD(v31) = v22.i16[0];
      *(double *)v23.i64 = xdr::convert_image_to_gainmap_image(a1, a4, a5, a6, a7, (float32_t *)((char *)v32[0].f32 + v17), v31, a11, v15, (uint16x4_t)v19);
      int8x16_t v15 = a9;
      *(float32x4_t *)((char *)v33 + v17) = v23;
      ++v21;
      v17 += 64;
    }
    while (v21 != 4);
    ++v18;
    uint64_t v17 = v29 + 16;
  }
  while (v18 != 4);
  xdr::image_write_loop<(unsigned short)4,(unsigned short)4>(a2, v33, a8, *(uint16x4_t *)v23.f32);
  return xdr::image_write_loop<(unsigned short)4,(unsigned short)4>(a3, v32, a8, v24);
}

float32x4_t *xdr::image_write_loop<(unsigned short)4,(unsigned short)4>(float32x4_t *result, float32x4_t *a2, __int32 a3, uint16x4_t a4)
{
  uint64_t v5 = result;
  a4.i32[0] = a3;
  int32x2_t v6 = (int32x2_t)vmovl_u16(a4).u64[0];
  __int32 v7 = result[1].i32[0];
  if (v7 == 3) {
    goto LABEL_4;
  }
  if (v7 != 2)
  {
    if (v7 != 1) {
      return result;
    }
LABEL_4:
    int v8 = result[7].u16[0];
    switch(v8)
    {
      case 1:
        uint64_t v52 = 0;
        int32x2_t v53 = vshl_n_s32(v6, 2uLL);
        float v54 = 1.0;
        do
        {
          uint64_t v55 = 0;
          uint64_t v56 = a2;
          do
          {
            float32x4_t v57 = *v56;
            v56 += 4;
            __n128 v58 = (__n128)vmlaq_f32(v5[3], v57, v5[2]);
            v58.n128_f32[3] = v54;
            int32x2_t v59 = vadd_s32((int32x2_t)__PAIR64__(v52, v55), v53);
            HIWORD(v185) = v59.i16[2];
            LOWORD(v185) = v59.i16[0];
            double result = (float32x4_t *)(*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[0] + 24))(v5->i64[0], v185, v58);
            float v54 = 1.0;
            ++v55;
          }
          while (v55 != 4);
          ++v52;
          ++a2;
        }
        while (v52 != 4);
        break;
      case 2:
        uint64_t v60 = 0;
        int8x8_t v61 = (int8x8_t)vadd_s32(v6, v6);
        char v62 = 1;
        __asm { FMOV            V0.4S, #0.25 }
        float32x4_t v182 = _Q0;
        do
        {
          uint64_t v64 = 0;
          char v65 = v62;
          char v66 = 1;
          do
          {
            uint64_t v67 = 0;
            char v68 = v66;
            char v69 = 1;
            float32x4_t v70 = 0uLL;
            do
            {
              char v71 = v69;
              float32x4_t v70 = vaddq_f32(vaddq_f32(v70, a2[8 * v64 + (v67 | (2 * v60))]), a2[4 * ((2 * v64) | 1) + (v67 | (2 * v60))]);
              uint64_t v67 = 1;
              char v69 = 0;
            }
            while ((v71 & 1) != 0);
            __n128 v72 = (__n128)vmlaq_f32(v5[3], vmulq_f32(v70, v182), v5[2]);
            v72.n128_u32[3] = 1.0;
            int8x8_t v73 = vorr_s8((int8x8_t)__PAIR64__(v60, v64), v61);
            HIWORD(v186) = v73.i16[2];
            LOWORD(v186) = v73.i16[0];
            double result = (float32x4_t *)(*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[0] + 24))(v5->i64[0], v186, v72);
            char v66 = 0;
            uint64_t v64 = 1;
          }
          while ((v68 & 1) != 0);
          char v62 = 0;
          uint64_t v60 = 1;
        }
        while ((v65 & 1) != 0);
        break;
      case 4:
        uint64_t v9 = 0;
        float32x4_t v10 = 0uLL;
        do
        {
          for (uint64_t i = 0; i != 16; i += 4)
            float32x4_t v10 = vaddq_f32(v10, a2[i]);
          ++v9;
          ++a2;
        }
        while (v9 != 4);
        __asm { FMOV            V1.4S, #0.25 }
        __n128 v18 = (__n128)vmlaq_f32(result[3], vmulq_f32(v10, _Q1), result[2]);
        uint64_t v17 = result->i64[0];
        v18.n128_u32[3] = 1.0;
LABEL_12:
        int32x2_t v19 = *(uint64_t (**)(__n128))(*(void *)v17 + 24);
        return (float32x4_t *)v19(v18);
      default:
        return result;
    }
    return result;
  }
  int16x4_t v20 = *(int16x4_t *)result[7].f32;
  uint16x4_t v21 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x200020001);
  v21.i16[3] = v21.i16[2];
  if ((vminv_u16(v21) & 0x8000) != 0)
  {
    uint64_t v74 = 0;
    int32x2_t v75 = vshl_n_s32(v6, 2uLL);
    int8x8_t v76 = (int8x8_t)vadd_s32(v6, v6);
    char v77 = 1;
    __asm { FMOV            V10.2S, #0.25 }
    do
    {
      uint64_t v79 = 0;
      char v178 = v77;
      char v80 = 1;
      do
      {
        uint64_t v81 = 0;
        char v82 = v80;
        float32x2_t v83 = 0;
        char v84 = 1;
        do
        {
          uint64_t v85 = 0;
          char v86 = v84;
          uint64_t v87 = v81 | (2 * v74);
          char v88 = 1;
          do
          {
            uint64_t v89 = v85 | (2 * v79);
            float32x4_t v90 = a2[4 * v89 + v87];
            char v91 = v88;
            v90.i32[3] = 0;
            float32x4_t v92 = vmaxnmq_f32(v90, (float32x4_t)0);
            v92.i32[3] = 0;
            float32x4_t v93 = vminnmq_f32(v92, (float32x4_t)xmmword_18898C460);
            int8x16_t v94 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v93.f32[0]), v5[5], *(float32x2_t *)v93.f32, 1), v5[6], v93, 2), v5[2]);
            float32x2_t v95 = (float32x2_t)vextq_s8(v94, v94, 4uLL).u64[0];
            v93.i32[0] = v94.i32[0];
            *(int32x2_t *)v94.i8 = vadd_s32((int32x2_t)__PAIR64__(v87, v89), v75);
            HIWORD(v195) = v94.i16[2];
            float32x2_t v83 = vadd_f32(v83, v95);
            LOWORD(v195) = v94.i16[0];
            (*(void (**)(uint64_t, void, float32_t))(*(void *)v5->i64[0] + 24))(v5->i64[0], v195, v93.f32[0]);
            char v88 = 0;
            uint64_t v85 = 1;
          }
          while ((v91 & 1) != 0);
          char v84 = 0;
          uint64_t v81 = 1;
        }
        while ((v86 & 1) != 0);
        v96.n128_u64[0] = (unint64_t)vmul_f32(v83, _D10);
        v96.n128_u64[1] = 0x3F80000000000000;
        int8x8_t v97 = vorr_s8((int8x8_t)__PAIR64__(v74, v79), v76);
        HIWORD(v194) = v97.i16[2];
        LOWORD(v194) = v97.i16[0];
        double result = (float32x4_t *)(*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[1] + 24))(v5->i64[1], v194, v96);
        char v80 = 0;
        uint64_t v79 = 1;
      }
      while ((v82 & 1) != 0);
      char v77 = 0;
      uint64_t v74 = 1;
    }
    while ((v178 & 1) != 0);
  }
  else
  {
    uint16x4_t v22 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x100020001);
    v22.i16[3] = v22.i16[2];
    if ((vminv_u16(v22) & 0x8000) != 0)
    {
      uint64_t v98 = 0;
      int32x2_t v99 = vshl_n_s32(v6, 2uLL);
      int v100 = 2 * a3;
      __int16 v101 = 4 * v6.i16[2];
      char v102 = 1;
      v6.i32[1] = 1065353216;
      do
      {
        uint64_t v103 = 0;
        char v104 = v102;
        uint64_t v105 = 2 * v98;
        v6.i32[0] = v100 | v98;
        unsigned __int16 v179 = vmovl_u16((uint16x4_t)v6).u16[0];
        do
        {
          uint64_t v106 = 0;
          float32x2_t v107 = 0;
          char v108 = 1;
          do
          {
            uint64_t v109 = v106 | v105;
            float32x4_t v110 = a2[4 * v109 + v103];
            char v111 = v108;
            v110.i32[3] = 0;
            float32x4_t v112 = vmaxnmq_f32(v110, (float32x4_t)0);
            v112.i32[3] = 0;
            float32x4_t v113 = vminnmq_f32(v112, (float32x4_t)xmmword_18898C460);
            int8x16_t v114 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v113.f32[0]), v5[5], *(float32x2_t *)v113.f32, 1), v5[6], v113, 2), v5[2]);
            float32x2_t v115 = (float32x2_t)vextq_s8(v114, v114, 4uLL).u64[0];
            v113.i32[0] = v114.i32[0];
            *(int32x2_t *)v114.i8 = vadd_s32((int32x2_t)__PAIR64__(v103, v109), v99);
            HIWORD(v193) = v114.i16[2];
            float32x2_t v107 = vadd_f32(v107, v115);
            LOWORD(v193) = v114.i16[0];
            (*(void (**)(uint64_t, void, float32_t))(*(void *)v5->i64[0] + 24))(v5->i64[0], v193, v113.f32[0]);
            char v108 = 0;
            uint64_t v106 = 1;
          }
          while ((v111 & 1) != 0);
          v116.n128_u64[0] = (unint64_t)vmul_f32(v107, (float32x2_t)0x3F0000003F000000);
          v116.n128_u64[1] = 0x3F80000000000000;
          HIWORD(v192) = v101 + v103;
          LOWORD(v192) = v179;
          double result = (float32x4_t *)(*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[1] + 24))(v5->i64[1], v192, v116);
          ++v103;
        }
        while (v103 != 4);
        char v102 = 0;
        uint64_t v98 = 1;
      }
      while ((v104 & 1) != 0);
    }
    else
    {
      uint16x4_t v23 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x1000100010001);
      v23.i16[3] = v23.i16[2];
      if ((vminv_u16(v23) & 0x8000) != 0)
      {
        uint64_t v117 = 0;
        int32x2_t v118 = vshl_n_s32(v6, 2uLL);
        float32x4_t v119 = 0uLL;
        float32x4_t v120 = (float32x4_t)xmmword_18898C460;
        do
        {
          uint64_t v121 = 0;
          float32x4_t v122 = a2;
          do
          {
            float32x4_t v123 = *v122;
            v122 += 4;
            float32x4_t v124 = v123;
            v124.i32[3] = 0;
            float32x4_t v125 = vmaxnmq_f32(v124, v119);
            v125.i32[3] = 0;
            float32x4_t v126 = vminnmq_f32(v125, v120);
            int32x2_t v127 = vadd_s32((int32x2_t)__PAIR64__(v117, v121), v118);
            int8x16_t v183 = (int8x16_t)vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v126.f32[0]), v5[5], *(float32x2_t *)v126.f32, 1), v5[6], v126, 2), v5[2]);
            HIWORD(v191) = v127.i16[2];
            LOWORD(v191) = v127.i16[0];
            (*(void (**)(uint64_t, void, float))(*(void *)v5->i64[0] + 24))(v5->i64[0], v191, *(float *)v183.i32);
            v128.n128_u64[0] = vextq_s8(v183, v183, 4uLL).u64[0];
            v128.n128_u64[1] = 0x3F80000000000000;
            double result = (float32x4_t *)(*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[1] + 24))(v5->i64[1], v191, v128);
            float32x4_t v120 = (float32x4_t)xmmword_18898C460;
            float32x4_t v119 = 0uLL;
            ++v121;
          }
          while (v121 != 4);
          ++v117;
          ++a2;
        }
        while (v117 != 4);
      }
      else
      {
        uint16x4_t v24 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x2000200020002);
        v24.i16[3] = v24.i16[2];
        if ((vminv_u16(v24) & 0x8000) != 0)
        {
          int v129 = 0;
          int8x8_t v130 = (int8x8_t)vadd_s32(v6, v6);
          char v131 = 1;
          float32x4_t v132 = 0uLL;
          float32x4_t v133 = (float32x4_t)xmmword_18898C460;
          __asm { FMOV            V10.2S, #0.25 }
          do
          {
            int v135 = 0;
            char v136 = v131;
            char v137 = 1;
            do
            {
              uint64_t v138 = 0;
              char v139 = v137;
              float32x4_t v140 = 0uLL;
              char v141 = 1;
              do
              {
                uint64_t v142 = 0;
                char v143 = v141;
                char v144 = 1;
                do
                {
                  float32x4_t v145 = a2[4 * v142 + v138];
                  v145.i32[3] = 0;
                  float32x4_t v146 = vmaxnmq_f32(v145, v132);
                  v146.i32[3] = 0;
                  float32x4_t v147 = vminnmq_f32(v146, v133);
                  char v148 = v144;
                  float32x4_t v140 = vaddq_f32(v140, vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v147.f32[0]), v5[5], *(float32x2_t *)v147.f32, 1), v5[6], v147, 2), v5[2]));
                  uint64_t v142 = 1;
                  char v144 = 0;
                }
                while ((v148 & 1) != 0);
                char v141 = 0;
                uint64_t v138 = 1;
              }
              while ((v143 & 1) != 0);
              v149.n128_f32[0] = 0.25 * v140.f32[0];
              v149.n128_u32[1] = 0;
              v149.n128_u32[2] = 0;
              v149.n128_u32[3] = 1.0;
              int8x8_t v150 = vorr_s8((int8x8_t)__PAIR64__(v129, v135), v130);
              HIWORD(v190) = v150.i16[2];
              LOWORD(v190) = v150.i16[0];
              int8x16_t v184 = (int8x16_t)v140;
              (*(void (**)(uint64_t, void, __n128))(*(void *)v5->i64[0] + 24))(v5->i64[0], v190, v149);
              v151.n128_u64[0] = (unint64_t)vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8(v184, v184, 4uLL), _D10);
              v151.n128_u64[1] = 0x3F80000000000000;
              double result = (float32x4_t *)(*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[1] + 24))(v5->i64[1], v190, v151);
              float32x4_t v133 = (float32x4_t)xmmword_18898C460;
              float32x4_t v132 = 0uLL;
              char v137 = 0;
              int v135 = 1;
            }
            while ((v139 & 1) != 0);
            char v131 = 0;
            int v129 = 1;
          }
          while ((v136 & 1) != 0);
        }
        else
        {
          uint16x4_t v25 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x200040002);
          v25.i16[3] = v25.i16[2];
          if ((vminv_u16(v25) & 0x8000) == 0)
          {
            uint16x4_t v26 = (uint16x4_t)vceq_s16(v20, (int16x4_t)0x400040002);
            v26.i16[3] = v26.i16[2];
            if ((vminv_u16(v26) & 0x8000) == 0) {
              return result;
            }
            uint64_t v27 = 0;
            int8x8_t v28 = (int8x8_t)vadd_s32(v6, v6);
            float32x2_t v29 = 0;
            char v30 = 1;
            float32x4_t v31 = 0uLL;
            float32x4_t v32 = (float32x4_t)xmmword_18898C460;
            __asm { FMOV            V10.2S, #0.25 }
            do
            {
              uint64_t v34 = 0;
              char v35 = v30;
              char v36 = 1;
              do
              {
                uint64_t v37 = 0;
                char v38 = v36;
                float32x4_t v39 = 0uLL;
                char v40 = 1;
                do
                {
                  uint64_t v41 = 0;
                  char v42 = v40;
                  uint64_t v43 = v37 | (2 * v27);
                  char v44 = 1;
                  do
                  {
                    float32x4_t v45 = a2[4 * (v41 | (2 * v34)) + v43];
                    v45.i32[3] = 0;
                    float32x4_t v46 = vmaxnmq_f32(v45, v31);
                    v46.i32[3] = 0;
                    float32x4_t v47 = vminnmq_f32(v46, v32);
                    char v48 = v44;
                    float32x4_t v39 = vaddq_f32(v39, vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v47.f32[0]), v5[5], *(float32x2_t *)v47.f32, 1), v5[6], v47, 2), v5[2]));
                    uint64_t v41 = 1;
                    char v44 = 0;
                  }
                  while ((v48 & 1) != 0);
                  char v40 = 0;
                  uint64_t v37 = 1;
                }
                while ((v42 & 1) != 0);
                float32x2_t v49 = (float32x2_t)vextq_s8((int8x16_t)v39, (int8x16_t)v39, 4uLL).u64[0];
                v50.n128_f32[0] = 0.25 * v39.f32[0];
                v50.n128_u32[1] = 0;
                v50.n128_u32[2] = 0;
                float32x2_t v29 = vmla_f32(v29, _D10, v49);
                v50.n128_u32[3] = 1.0;
                int8x8_t v51 = vorr_s8((int8x8_t)__PAIR64__(v27, v34), v28);
                HIWORD(v187) = v51.i16[2];
                LOWORD(v187) = v51.i16[0];
                (*(void (**)(uint64_t, void, __n128))(*(void *)v5->i64[0] + 24))(v5->i64[0], v187, v50);
                float32x4_t v32 = (float32x4_t)xmmword_18898C460;
                float32x4_t v31 = 0uLL;
                char v36 = 0;
                uint64_t v34 = 1;
              }
              while ((v38 & 1) != 0);
              char v30 = 0;
              uint64_t v27 = 1;
            }
            while ((v35 & 1) != 0);
            uint64_t v17 = v5->i64[1];
            v18.n128_u64[0] = (unint64_t)vmul_f32(v29, _D10);
            v18.n128_u64[1] = 0x3F80000000000000;
            goto LABEL_12;
          }
          uint64_t v152 = 0;
          int8x8_t v153 = (int8x8_t)vadd_s32(v6, v6);
          v20.i32[0] = a3;
          unsigned __int32 v180 = vmovl_u16((uint16x4_t)v20).u32[0];
          int v154 = 2 * v6.i32[1];
          char v155 = 1;
          __asm { FMOV            V9.2S, #0.25 }
          do
          {
            uint64_t v157 = 0;
            char v158 = v155;
            LODWORD(v159) = v180;
            HIDWORD(v159) = v154 | v152;
            uint64_t v181 = v159;
            float32x2_t v160 = 0;
            char v161 = 1;
            do
            {
              uint64_t v162 = 0;
              char v163 = v161;
              float32x4_t v164 = 0uLL;
              char v165 = 1;
              do
              {
                uint64_t v166 = 0;
                char v167 = v165;
                uint64_t v168 = v162 | (2 * v152);
                char v169 = 1;
                do
                {
                  float32x4_t v170 = a2[4 * (v166 | (2 * v157)) + v168];
                  v170.i32[3] = 0;
                  float32x4_t v171 = vmaxnmq_f32(v170, (float32x4_t)0);
                  v171.i32[3] = 0;
                  float32x4_t v172 = vminnmq_f32(v171, (float32x4_t)xmmword_18898C460);
                  char v173 = v169;
                  float32x4_t v164 = vaddq_f32(v164, vmlaq_f32(v5[3], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v5[4], v172.f32[0]), v5[5], *(float32x2_t *)v172.f32, 1), v5[6], v172, 2), v5[2]));
                  uint64_t v166 = 1;
                  char v169 = 0;
                }
                while ((v173 & 1) != 0);
                char v165 = 0;
                uint64_t v162 = 1;
              }
              while ((v167 & 1) != 0);
              float32x2_t v174 = (float32x2_t)vextq_s8((int8x16_t)v164, (int8x16_t)v164, 4uLL).u64[0];
              v175.n128_f32[0] = 0.25 * v164.f32[0];
              v175.n128_u32[1] = 0;
              v175.n128_u32[2] = 0;
              float32x2_t v160 = vmla_f32(v160, _D9, v174);
              v175.n128_u32[3] = 1.0;
              int8x8_t v176 = vorr_s8((int8x8_t)__PAIR64__(v152, v157), v153);
              HIWORD(v189) = v176.i16[2];
              LOWORD(v189) = v176.i16[0];
              (*(void (**)(uint64_t, void, __n128))(*(void *)v5->i64[0] + 24))(v5->i64[0], v189, v175);
              char v161 = 0;
              uint64_t v157 = 1;
            }
            while ((v163 & 1) != 0);
            HIWORD(v188) = WORD2(v181);
            LOWORD(v188) = v181;
            v177.n128_u64[0] = (unint64_t)vmul_f32(v160, (float32x2_t)0x3F0000003F000000);
            v177.n128_u64[1] = 0x3F80000000000000;
            double result = (float32x4_t *)(*(uint64_t (**)(uint64_t, void, __n128))(*(void *)v5->i64[1] + 24))(v5->i64[1], v188, v177);
            char v155 = 0;
            uint64_t v152 = 1;
          }
          while ((v158 & 1) != 0);
        }
      }
    }
  }
  return result;
}

void ___ZN3xdr52dispatch_convert_gainmap_image_to_gainmap_image_loopILt1ELt1EEEvRKNS_7imageInES3_RKNS_8imageOutES6_RKNS_16colorTransformInERKNS_15gainTransformInES9_SC_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(uint64_t a1, unsigned __int16 a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v18 = 0x100000000;
  int v19 = 1;
  if (*(_WORD *)(a1 + 128))
  {
    int v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(a1 + 48);
      uint64_t v6 = *(void *)(a1 + 56);
      __int32 v7 = *(float32x4_t **)(a1 + 64);
      int v8 = *(float32x4_t **)(a1 + 72);
      uint64_t v9 = *(float32x4_t **)(a1 + 80);
      float32x4_t v10 = *(float32x4_t **)(a1 + 88);
      char v11 = *(float32x4_t **)(a1 + 96);
      float32x4_t v12 = *(float32x4_t **)(a1 + 104);
      float32x4_t v13 = *(float32x4_t **)(a1 + 112);
      uint64_t v14 = *(void *)(a1 + 120);
      int8x16_t v15 = *(int8x16_t *)(a1 + 32);
      float32x4_t v20 = 0uLL;
      *(double *)v16.i64 = xdr::convert_gainmap_image_to_gainmap_image(v5, v6, v9, v10, v11, v12, v13, v14, v15, &v20, v4, a2, &v18);
      float32x4_t v21 = v16;
      int16x4_t v17 = (int16x4_t)xdr::image_write_loop<(unsigned short)1,(unsigned short)1>(v7, &v21, *(int16x4_t *)v16.f32);
      xdr::image_write_loop<(unsigned short)1,(unsigned short)1>(v8, &v20, v17);
      ++v4;
    }
    while (*(unsigned __int16 *)(a1 + 128) > (unsigned __int16)v4);
  }
}

double xdr::convert_gainmap_image_to_gainmap_image(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, float32x4_t *a7, uint64_t a8, int8x16_t a9, _OWORD *a10, unsigned __int16 a11, unsigned __int16 a12, _DWORD *a13)
{
  v20.i32[0] = a11;
  v20.i32[1] = a12;
  double v45 = COERCE_DOUBLE(vmla_f32((float32x2_t)*(_OWORD *)&vextq_s8(a9, a9, 8uLL), vadd_f32((float32x2_t)vorr_s8(v20, (int8x8_t)vdup_n_s32(0x4B400000u)), (float32x2_t)vdup_n_s32(0xCB400000)), *(float32x2_t *)a9.i8));
  xdr::image_sample(a1, a13, v45);
  float32x4_t v43 = v21;
  xdr::image_sample(a2, a13, v45);
  float32x4_t v44 = v22;
  *(double *)v23.i64 = xdr::apply_color_trc((uint64_t)a3, v43);
  xdr::apply_tone_mapping((uint64_t)&a3[5], v23, v24, v25, v26);
  if (!a3[22].i8[0]) {
    float32x4_t v27 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a3[19], v27.f32[0]), a3[20], *(float32x2_t *)v27.f32, 1), a3[21], v27, 2);
  }
  *(double *)v28.i64 = xdr::apply_gain_mapping((uint64_t)a4, v27, v44);
  if (!a4[10].i8[0]) {
    float32x4_t v28 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a4[7], v28.f32[0]), a4[8], *(float32x2_t *)v28.f32, 1), a4[9], v28, 2);
  }
  float32x4_t v46 = v28;
  *(double *)v29.i64 = xdr::apply_color_trc((uint64_t)a5, v43);
  xdr::apply_tone_mapping((uint64_t)&a5[5], v29, v30, v31, v32);
  if (!a5[22].i8[0]) {
    float32x4_t v33 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a5[19], v33.f32[0]), a5[20], *(float32x2_t *)v33.f32, 1), a5[21], v33, 2);
  }
  *(double *)v34.i64 = xdr::apply_gain_mapping((uint64_t)a6, v33, v44);
  float32x4_t v35 = v34;
  if (!a6[10].i8[0]) {
    float32x4_t v35 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a6[7], v34.f32[0]), a6[8], *(float32x2_t *)v34.f32, 1), a6[9], v34, 2);
  }
  *(double *)&long long v36 = xdr::apply_gain_transform(a8, v46, v35);
  *a10 = v36;
  if (a7[3].i8[0])
  {
    float32x4_t v40 = v46;
  }
  else
  {
    float32x4_t v37 = a7[1];
    int8x16_t v39 = (int8x16_t)v46;
    float32x4_t v38 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(*a7, v46.f32[0]), v37, *(float32x2_t *)v46.f32, 1), a7[2], v46, 2);
    float32x4_t v40 = v38;
  }
  xdr::apply_tone_mapping((uint64_t)&a7[4], v40, *(double *)v37.i64, *(double *)v38.i64, v39);

  return xdr::apply_color_trc((uint64_t)&a7[18], v41);
}

uint64_t ___ZN3xdr52dispatch_convert_gainmap_image_to_gainmap_image_loopILt2ELt1EEEvRKNS_7imageInES3_RKNS_8imageOutES6_RKNS_16colorTransformInERKNS_15gainTransformInES9_SC_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(uint64_t result, __int16 a2, double a3, uint16x4_t a4)
{
  uint64_t v8 = 0x100000000;
  int v9 = 1;
  if (*(_WORD *)(result + 128))
  {
    uint64_t v5 = result;
    int v6 = 0;
    do
    {
      HIWORD(v7) = a2;
      LOWORD(v7) = v6;
      double result = xdr::convert_gainmap_image_to_gainmap_image_loop<(unsigned short)2,(unsigned short)1>(*(void *)(v5 + 48), *(void *)(v5 + 56), *(void *)(v5 + 64), *(void *)(v5 + 72), *(float32x4_t **)(v5 + 80), *(float32x4_t **)(v5 + 88), *(float32x4_t **)(v5 + 96), *(float32x4_t **)(v5 + 104), *(int8x16_t *)(v5 + 32), a4, *(float32x4_t **)(v5 + 112), *(void *)(v5 + 120), v7, &v8);
      ++v6;
    }
    while (*(unsigned __int16 *)(v5 + 128) > (unsigned __int16)v6);
  }
  return result;
}

uint64_t xdr::convert_gainmap_image_to_gainmap_image_loop<(unsigned short)2,(unsigned short)1>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, float32x4_t *a5, float32x4_t *a6, float32x4_t *a7, float32x4_t *a8, int8x16_t a9, uint16x4_t a10, float32x4_t *a11, uint64_t a12, __int32 a13, _DWORD *a14)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  a10.i32[0] = a13;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  int32x2_t v24 = (int32x2_t)vshl_u32((uint32x2_t)*(_OWORD *)&vmovl_u16(a10), (uint32x2_t)1);
  *(double *)&long long v20 = xdr::convert_gainmap_image_to_gainmap_image(a1, a2, a5, a6, a7, a8, a11, a12, a9, &v28, v24.u16[0], v24.u16[2], a14);
  long long v30 = v20;
  *(int32x2_t *)&long long v20 = vadd_s32(v24, (int32x2_t)1);
  *(double *)&long long v21 = xdr::convert_gainmap_image_to_gainmap_image(a1, a2, a5, a6, a7, a8, a11, a12, a9, &v29, v20, WORD2(v20), a14);
  long long v31 = v21;
  xdr::image_write_loop<(unsigned short)2,(unsigned short)1>(a3, (uint64_t)&v30, a13, *(uint16x4_t *)&v21);
  return xdr::image_write_loop<(unsigned short)2,(unsigned short)1>(a4, (uint64_t)&v28, a13, v22);
}

float32x4_t *___ZN3xdr52dispatch_convert_gainmap_image_to_gainmap_image_loopILt2ELt2EEEvRKNS_7imageInES3_RKNS_8imageOutES6_RKNS_16colorTransformInERKNS_15gainTransformInES9_SC_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(float32x4_t *result, __int16 a2)
{
  uint64_t v6 = 0x100000000;
  int v7 = 1;
  if (result[8].i16[0])
  {
    uint64_t v3 = result;
    int v4 = 0;
    do
    {
      HIWORD(v5) = a2;
      LOWORD(v5) = v4;
      double result = xdr::convert_gainmap_image_to_gainmap_image_loop<(unsigned short)2,(unsigned short)2>(v3[3].i64[0], v3[3].i64[1], (float32x4_t *)v3[4].i64[0], (float32x4_t *)v3[4].i64[1], (float32x4_t *)v3[5].i64[0], (float32x4_t *)v3[5].i64[1], (float32x4_t *)v3[6].i64[0], (float32x4_t *)v3[6].i64[1], (int8x16_t)v3[2], (float32x4_t *)v3[7].i64[0], v3[7].i64[1], v5, &v6);
      ++v4;
    }
    while (v3[8].u16[0] > (unsigned __int16)v4);
  }
  return result;
}

float32x4_t *xdr::convert_gainmap_image_to_gainmap_image_loop<(unsigned short)2,(unsigned short)2>(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, float32x4_t *a7, float32x4_t *a8, int8x16_t a9, float32x4_t *a10, uint64_t a11, __int32 a12, _DWORD *a13)
{
  int8x16_t v31 = a9;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  a9.i32[0] = a12;
  int32x2_t v15 = (int32x2_t)vmovl_u16(*(uint16x4_t *)a9.i8).u64[0];
  memset(v33, 0, sizeof(v33));
  memset(v32, 0, sizeof(v32));
  int32x2_t v16 = vadd_s32(v15, v15);
  do
  {
    v22.i32[0] = 0;
    v22.i32[1] = v14;
    int32x2_t v23 = vadd_s32(v16, v22);
    *(double *)&long long v24 = xdr::convert_gainmap_image_to_gainmap_image(a1, a2, a5, a6, a7, a8, a10, a11, v31, &v32[v13], v23.u16[0], v23.u16[2], a13);
    v33[v13] = v24;
    DWORD1(v24) = v14;
    LODWORD(v24) = 1;
    *(int32x2_t *)&long long v24 = vadd_s32(*(int32x2_t *)&v24, v16);
    *(double *)&long long v25 = xdr::convert_gainmap_image_to_gainmap_image(a1, a2, a5, a6, a7, a8, a10, a11, v31, &v32[v13 + 2], v24, WORD2(v24), a13);
    v33[v13 + 2] = v25;
    ++v14;
    ++v13;
  }
  while (v14 != 2);
  xdr::image_write_loop<(unsigned short)2,(unsigned short)2>(a3, (uint64_t)v33, a12, *(uint16x4_t *)&v25);
  return xdr::image_write_loop<(unsigned short)2,(unsigned short)2>(a4, (uint64_t)v32, a12, v26);
}

uint64_t ___ZN3xdr52dispatch_convert_gainmap_image_to_gainmap_image_loopILt4ELt2EEEvRKNS_7imageInES3_RKNS_8imageOutES6_RKNS_16colorTransformInERKNS_15gainTransformInES9_SC_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(uint64_t result, __int16 a2, double a3, uint16x4_t a4)
{
  uint64_t v8 = 0x100000000;
  int v9 = 1;
  if (*(_WORD *)(result + 128))
  {
    uint64_t v5 = result;
    int v6 = 0;
    do
    {
      HIWORD(v7) = a2;
      LOWORD(v7) = v6;
      double result = xdr::convert_gainmap_image_to_gainmap_image_loop<(unsigned short)4,(unsigned short)2>(*(void *)(v5 + 48), *(void *)(v5 + 56), *(void *)(v5 + 64), *(void *)(v5 + 72), *(float32x4_t **)(v5 + 80), *(float32x4_t **)(v5 + 88), *(float32x4_t **)(v5 + 96), *(float32x4_t **)(v5 + 104), *(int8x16_t *)(v5 + 32), a4, *(float32x4_t **)(v5 + 112), *(void *)(v5 + 120), v7, &v8);
      ++v6;
    }
    while (*(unsigned __int16 *)(v5 + 128) > (unsigned __int16)v6);
  }
  return result;
}

uint64_t xdr::convert_gainmap_image_to_gainmap_image_loop<(unsigned short)4,(unsigned short)2>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, float32x4_t *a5, float32x4_t *a6, float32x4_t *a7, float32x4_t *a8, int8x16_t a9, uint16x4_t a10, float32x4_t *a11, uint64_t a12, __int32 a13, _DWORD *a14)
{
  int8x16_t v16 = a9;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  a10.i32[0] = a13;
  int32x2_t v21 = (int32x2_t)vshl_u32((uint32x2_t)*(_OWORD *)&vmovl_u16(a10), (uint32x2_t)0x100000002);
  memset(v34, 0, sizeof(v34));
  memset(v33, 0, sizeof(v33));
  long long v30 = a6;
  int8x16_t v31 = a5;
  do
  {
    uint64_t v22 = 0;
    uint64_t v29 = v19;
    do
    {
      int32x2_t v23 = vadd_s32((int32x2_t)__PAIR64__(v20, v22), v21);
      *(double *)&long long v24 = xdr::convert_gainmap_image_to_gainmap_image(a1, a2, a5, a6, a7, a8, a11, a12, v16, (_OWORD *)((char *)v33 + v19), v23.u16[0], v23.u16[2], a14);
      int8x16_t v16 = a9;
      a6 = v30;
      a5 = v31;
      *(_OWORD *)((char *)v34 + v19) = v24;
      ++v22;
      v19 += 32;
    }
    while (v22 != 4);
    ++v20;
    uint64_t v19 = v29 + 16;
  }
  while (v20 != 2);
  xdr::image_write_loop<(unsigned short)4,(unsigned short)2>(a3, (uint64_t)v34, a13, *(uint16x4_t *)&v24);
  return xdr::image_write_loop<(unsigned short)4,(unsigned short)2>(a4, (uint64_t)v33, a13, v25);
}

float32x4_t *___ZN3xdr52dispatch_convert_gainmap_image_to_gainmap_image_loopILt4ELt4EEEvRKNS_7imageInES3_RKNS_8imageOutES6_RKNS_16colorTransformInERKNS_15gainTransformInES9_SC_RKNS_17colorTransformOutERKNS_16gainTransformOutEDv2_t_block_invoke(float32x4_t *result, __int16 a2, double a3, uint16x4_t a4)
{
  uint64_t v8 = 0x100000000;
  int v9 = 1;
  if (result[8].i16[0])
  {
    uint64_t v5 = result;
    int v6 = 0;
    do
    {
      HIWORD(v7) = a2;
      LOWORD(v7) = v6;
      double result = xdr::convert_gainmap_image_to_gainmap_image_loop<(unsigned short)4,(unsigned short)4>(v5[3].i64[0], v5[3].i64[1], (float32x4_t *)v5[4].i64[0], (float32x4_t *)v5[4].i64[1], (float32x4_t *)v5[5].i64[0], (float32x4_t *)v5[5].i64[1], (float32x4_t *)v5[6].i64[0], (float32x4_t *)v5[6].i64[1], (int8x16_t)v5[2], a4, (float32x4_t *)v5[7].i64[0], v5[7].i64[1], v7, &v8);
      ++v6;
    }
    while (v5[8].u16[0] > (unsigned __int16)v6);
  }
  return result;
}

float32x4_t *xdr::convert_gainmap_image_to_gainmap_image_loop<(unsigned short)4,(unsigned short)4>(uint64_t a1, uint64_t a2, float32x4_t *a3, float32x4_t *a4, float32x4_t *a5, float32x4_t *a6, float32x4_t *a7, float32x4_t *a8, int8x16_t a9, uint16x4_t a10, float32x4_t *a11, uint64_t a12, __int32 a13, _DWORD *a14)
{
  int8x16_t v16 = a9;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  a10.i32[0] = a13;
  memset(v34, 0, sizeof(v34));
  int32x2_t v21 = vshl_n_s32((int32x2_t)*(_OWORD *)&vmovl_u16(a10), 2uLL);
  memset(v33, 0, sizeof(v33));
  long long v30 = a6;
  int8x16_t v31 = a5;
  do
  {
    uint64_t v22 = 0;
    uint64_t v29 = v19;
    do
    {
      int32x2_t v23 = vadd_s32((int32x2_t)__PAIR64__(v20, v22), v21);
      *(double *)v24.i64 = xdr::convert_gainmap_image_to_gainmap_image(a1, a2, a5, a6, a7, a8, a11, a12, v16, (float32_t *)((char *)v33[0].f32 + v19), v23.u16[0], v23.u16[2], a14);
      int8x16_t v16 = a9;
      a6 = v30;
      a5 = v31;
      *(float32x4_t *)((char *)v34 + v19) = v24;
      ++v22;
      v19 += 64;
    }
    while (v22 != 4);
    ++v20;
    uint64_t v19 = v29 + 16;
  }
  while (v20 != 4);
  xdr::image_write_loop<(unsigned short)4,(unsigned short)4>(a3, v34, a13, *(uint16x4_t *)v24.f32);
  return xdr::image_write_loop<(unsigned short)4,(unsigned short)4>(a4, v33, a13, v25);
}

void ___ZN3xdr36dispatch_compute_luma_gain_histogramILt2ELt2ELt4EEEvRKNS_7imageInES3_RKNS_16colorTransformInERKNS_15gainTransformInERNS_11histogram2DEDv2_fDv2_t_block_invoke(uint64_t a1, unint64_t a2)
{
  uint16x4_t v2 = (uint16x4_t)0x100000000;
  uint64_t v14 = 0x100000000;
  int v15 = 1;
  if (*(_WORD *)(a1 + 98))
  {
    unsigned int v5 = 0;
    v6.i32[0] = a2 & 7;
    v6.i32[1] = a2 >> 3;
    v2.i16[0] = *(_WORD *)(a1 + 96);
    v2.i16[2] = *(_WORD *)(a1 + 98);
    int32x2_t v12 = v6;
    do
    {
      unsigned __int16 v7 = v2.u16[2];
      if (v2.i16[0])
      {
        unsigned int v8 = 0;
        do
        {
          int8x8_t v9 = (int8x8_t)vmla_s32((int32x2_t)__PAIR64__(v5, v8), (int32x2_t)v2, v6);
          v10.i32[0] = *(unsigned __int16 *)(a1 + 100);
          v10.i32[1] = *(unsigned __int16 *)(a1 + 102);
          int16x4_t v11 = (int16x4_t)vcgt_u32(v10, (uint32x2_t)vand_s8(v9, (int8x8_t)0xFFFF0000FFFFLL));
          if ((vminv_u16((uint16x4_t)vuzp1_s16(v11, v11)) & 0x8000) != 0)
          {
            HIWORD(v13) = v9.i16[2];
            LOWORD(v13) = v9.i16[0];
            uint16x4_t v2 = xdr::compute_luma_gain_histogram_loop<(unsigned short)2,(unsigned short)2,(unsigned short)4>(*(void *)(a1 + 48), *(void *)(a1 + 56), *(float32x4_t **)(a1 + 64), *(void *)(a1 + 72), *(void *)(a1 + 80) + (a2 << 12), v13, &v14, *(uint16x4_t *)(a1 + 88), *(int8x16_t *)(a1 + 32));
            int32x2_t v6 = v12;
            v2.i16[0] = *(_WORD *)(a1 + 96);
            v2.i16[2] = *(_WORD *)(a1 + 98);
            unsigned __int16 v7 = v2.u16[2];
          }
          ++v8;
        }
        while ((unsigned __int16)v8 < v2.u16[0]);
      }
      ++v5;
    }
    while ((unsigned __int16)v5 < v7);
  }
}

uint16x4_t xdr::compute_luma_gain_histogram_loop<(unsigned short)2,(unsigned short)2,(unsigned short)4>(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4, uint64_t a5, __int32 a6, _DWORD *a7, uint16x4_t a8, int8x16_t a9)
{
  float32x2_t v54 = (float32x2_t)a8;
  int v15 = 0;
  a8.i32[0] = a6;
  int32x2_t v16 = (int32x2_t)vmovl_u16(a8).u64[0];
  int8x8_t v17 = (int8x8_t)vadd_s32(v16, v16);
  float32x2_t v57 = (float32x2_t)vextq_s8(a9, a9, 8uLL).u64[0];
  float32x2_t v58 = *(float32x2_t *)a9.i8;
  uint64_t v18 = (uint64_t)&a3[5];
  float32x2_t v19 = 0;
  int8x8_t v20 = (int8x8_t)vdup_n_s32(0x4B400000u);
  float32x2_t v21 = (float32x2_t)vdup_n_s32(0xCB400000);
  float32x4_t v56 = (float32x4_t)vdupq_n_s32(0x3EAAAAABu);
  char v22 = 1;
  __asm
  {
    FMOV            V8.2S, #4.0
    FMOV            V0.4S, #1.0
  }
  int8x16_t v55 = _Q0;
  do
  {
    int v29 = 0;
    char v30 = v22;
    char v31 = 1;
    do
    {
      char v32 = v31;
      double v33 = COERCE_DOUBLE(vmla_f32(v57, vmul_f32(vadd_f32(vadd_f32((float32x2_t)vorr_s8(vand_s8(vorr_s8((int8x8_t)__PAIR64__(v15, v29), v17), (int8x8_t)0xFFFF0000FFFFLL), v20), v21), (float32x2_t)0x3F0000003F000000), _D8), v58));
      xdr::image_sample(a1, a7, v33);
      float32x4_t v59 = v34;
      xdr::image_sample(a2, a7, v33);
      float32x4_t v61 = v35;
      *(double *)v36.i64 = xdr::apply_color_trc((uint64_t)a3, v59);
      xdr::apply_tone_mapping(v18, v36, v37, v38, v39);
      if (!a3[22].i8[0]) {
        float32x4_t v40 = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a3[19], v40.f32[0]), a3[20], *(float32x2_t *)v40.f32, 1), a3[21], v40, 2);
      }
      *(double *)v41.i64 = xdr::apply_gain_mapping(a4, v40, v61);
      float32x4_t v42 = v41;
      float32x4_t v43 = v61;
      if ((*(_DWORD *)a4 - 1) <= 1)
      {
        float32x4_t v44 = vabsq_f32(v61);
        v44.i32[3] = 0;
        simd_float4 v45 = *(simd_float4 *)(a4 + 16);
        simd_float4 v46 = (simd_float4)vmaxnmq_f32(v44, (float32x4_t)xmmword_18898C4C0);
        v47.i64[0] = 0x8000000080000000;
        v47.i64[1] = 0x8000000080000000;
        float32x4_t v60 = (float32x4_t)vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f32(v61), (int8x16_t)vcgtzq_f32(v61)), vorrq_s8(vandq_s8((int8x16_t)v61, v47), v55), (int8x16_t)0);
        float32x4_t v62 = v42;
        v46.i32[3] = 0;
        v45.i32[3] = 0;
        float32x4_t v48 = (float32x4_t)_simd_pow_f4(v46, v45);
        float32x4_t v42 = v62;
        float32x4_t v43 = vmulq_f32(v60, v48);
      }
      char v31 = 0;
      float32x4_t v49 = vmulq_f32(v42, v56);
      v49.f32[0] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v49, 2), vaddq_f32(v49, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v49.f32, 1))).f32[0];
      v49.f32[0] = v49.f32[0] + (float)((float)(fmaxf(v42.f32[0], fmaxf(v42.f32[1], v42.f32[2])) - v49.f32[0]) * 0.5);
      float32x4_t v50 = vmulq_f32(v43, v56);
      v49.i32[1] = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v50, 2), vaddq_f32(v50, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v50.f32, 1))).u32[0];
      float32x2_t v19 = vadd_f32(v19, *(float32x2_t *)v49.f32);
      int v29 = 1;
    }
    while ((v32 & 1) != 0);
    char v22 = 0;
    int v15 = 1;
  }
  while ((v30 & 1) != 0);
  __asm { FMOV            V0.2S, #0.25 }
  int16x4_t v52 = (int16x4_t)vcvt_n_s32_f32(vmul_f32(vmul_f32(v54, _D0), v19), 5uLL);
  uint16x4_t result = vmin_u16((uint16x4_t)vuzp1_s16(v52, v52).u32[0], (uint16x4_t)2031647);
  ++*(_DWORD *)(a5 + ((unint64_t)result.u16[0] << 7) + 4 * result.u16[1]);
  return result;
}

void *___ZN3xdr36dispatch_compute_luma_gain_histogramILt2ELt2ELt4EEEvRKNS_7imageInES3_RKNS_16colorTransformInERKNS_15gainTransformInERNS_11histogram2DEDv2_fDv2_t_block_invoke_2(void *result, uint64_t a2)
{
  uint64_t v2 = 0;
  unint64_t v3 = 0;
  uint64_t v4 = result[5] + (a2 << 7);
  uint64_t v5 = result[6] + (a2 << 7);
  do
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    do
    {
      v7 += *(unsigned int *)(v4 + v6);
      v6 += 4096;
    }
    while (v6 != 0x40000);
    *(_DWORD *)(v5 + 4 * v2) = v7;
    v3 += v7;
    ++v2;
    v4 += 4;
  }
  while (v2 != 32);
  atomic_fetch_add_explicit(*(atomic_ullong *volatile *)(*(void *)(result[4] + 8) + 24), v3, memory_order_relaxed);
  return result;
}

void sub_188627D10(_Unwind_Exception *a1)
{
  unsigned int v8 = v7;

  _Unwind_Resume(a1);
}

void sub_188627E54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188627EC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)HDRImageConverter_Metal;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_188627F90(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188628190(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188628450(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1886288B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188628EE0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18862912C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188629314(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_188629420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void sub_1886294F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_18862962C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_188629890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_188629B14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_188629E38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_18862A030(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_18862A164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_18862A2B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_18862A338(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18862A5E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18862AB40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,uint64_t a27,void *a28,void *a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36)
{
  _Unwind_Resume(a1);
}

void sub_18862B264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30,uint64_t a31,void *a32,void *a33,void *a34,void *a35,uint64_t a36,uint64_t a37,void *a38,void *a39,void *a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,void *a46)
{
  _Unwind_Resume(a1);
}

void sub_18862BA18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,void *a35,void *a36,uint64_t a37,void *a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,void *a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,void *a50,void *a51,void *a52)
{
  _Unwind_Resume(a1);
}

void sub_18862C36C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,void *a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,void *a58,void *a59,void *a60,void *a61,void *a62,void *a63)
{
  _Unwind_Resume(a1);
}

void sub_18862C9C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22,uint64_t a23,void *a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30,void *a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36)
{
  _Unwind_Resume(a1);
}

void sub_18862CFF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

void sub_18862D144(_Unwind_Exception *a1)
{
  unint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void sub_18862D1F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18862D318(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18862D768(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_18862D940(_Unwind_Exception *a1)
{
  uint64_t v6 = v4;

  _Unwind_Resume(a1);
}

void sub_18862DA10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_18862DB40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_18862E07C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35)
{
  _Unwind_Resume(a1);
}

void sub_18862E1B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18862E2D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18862E404(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18862E514(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18862E5B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18862E660(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18862EB1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18862EC34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_18862ECDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_18862ED7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_18862EE1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_18862EEC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void sub_18862EF80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_18862F380(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t _cg_jinit_huff_encoder(uint64_t a1)
{
  uint64_t result = (**(uint64_t (***)(void))(a1 + 8))();
  uint64_t v3 = 0;
  *(void *)(a1 + 560) = result;
  *(void *)uint64_t result = start_pass_huff;
  *(_OWORD *)(result + 64) = 0u;
  *(_OWORD *)(result + 80) = 0u;
  do
  {
    uint64_t v4 = (_OWORD *)(result + v3);
    v4[6] = 0uLL;
    v4[10] = 0uLL;
    v4[8] = 0uLL;
    v3 += 16;
  }
  while (v3 != 32);
  if (*(_DWORD *)(a1 + 348)) {
    *(void *)(result + 240) = 0;
  }
  return result;
}

void start_pass_huff(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 560);
  if (a2)
  {
    *(void *)(v4 + 16) = finish_pass_gather;
    if (!*(_DWORD *)(a1 + 348))
    {
      uint64_t v5 = encode_mcu_gather;
LABEL_13:
      *(void *)(v4 + 8) = v5;
      goto LABEL_17;
    }
  }
  else
  {
    *(void *)(v4 + 16) = finish_pass_huff;
    if (!*(_DWORD *)(a1 + 348))
    {
      uint64_t v5 = encode_mcu_huff;
      goto LABEL_13;
    }
  }
  *(void *)(v4 + 216) = a1;
  *(_DWORD *)(v4 + 192) = a2;
  int v6 = *(_DWORD *)(a1 + 460);
  if (*(_DWORD *)(a1 + 468))
  {
    if (v6)
    {
      *(void *)(v4 + 8) = encode_mcu_AC_refine;
      if (!*(void *)(v4 + 240)) {
        *(void *)(v4 + 240) = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1000);
      }
      goto LABEL_16;
    }
    uint64_t v7 = encode_mcu_DC_refine;
  }
  else if (v6)
  {
    uint64_t v7 = encode_mcu_AC_first;
  }
  else
  {
    uint64_t v7 = encode_mcu_DC_first;
  }
  *(void *)(v4 + 8) = v7;
LABEL_16:
  int v8 = *(_DWORD *)(*(void *)(a1 + 376) + 24);
  *(_DWORD *)(v4 + 228) = 0;
  *(_DWORD *)(v4 + 232) = 0;
  *(_DWORD *)(v4 + 224) = v8;
LABEL_17:
  if (*(int *)(a1 + 372) >= 1)
  {
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = *(void *)(a1 + 8 * v9 + 376);
      if (!*(_DWORD *)(a1 + 460) && !*(_DWORD *)(a1 + 468))
      {
        signed int v11 = *(_DWORD *)(v10 + 20);
        uint64_t v12 = v11;
        if (a2)
        {
          if (v11 >= 4)
          {
            __int32 v13 = *(void (***)(void))a1;
            *((_DWORD *)v13 + 10) = 52;
            *((_DWORD *)v13 + 12) = v11;
            (**(void (***)(uint64_t))a1)(a1);
          }
          uint64_t v14 = v4 + 8 * v12;
          int8x8_t v17 = *(void **)(v14 + 128);
          int32x2_t v16 = (void *)(v14 + 128);
          int v15 = v17;
          if (!v17)
          {
            int v15 = (void *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2056);
            void *v16 = v15;
          }
          bzero(v15, 0x808uLL);
        }
        else
        {
          jpeg_make_c_derived_tbl(a1, 1, v11, (void *)(v4 + 8 * v11 + 64));
        }
        *(_DWORD *)(v4 + 36 + 4 * v9) = 0;
      }
      if (*(_DWORD *)(a1 + 464))
      {
        signed int v18 = *(_DWORD *)(v10 + 24);
        uint64_t v19 = v18;
        if (a2)
        {
          if (v18 >= 4)
          {
            int8x8_t v20 = *(void (***)(void))a1;
            *((_DWORD *)v20 + 10) = 52;
            *((_DWORD *)v20 + 12) = v18;
            (**(void (***)(uint64_t))a1)(a1);
          }
          uint64_t v21 = v4 + 8 * v19;
          float32x4_t v24 = *(void **)(v21 + 160);
          int32x2_t v23 = (void *)(v21 + 160);
          char v22 = v24;
          if (!v24)
          {
            char v22 = (void *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2056);
            void *v23 = v22;
          }
          bzero(v22, 0x808uLL);
        }
        else
        {
          jpeg_make_c_derived_tbl(a1, 0, v18, (void *)(v4 + 8 * v18 + 96));
        }
      }
      ++v9;
    }
    while (v9 < *(int *)(a1 + 372));
  }
  *(void *)(v4 + 24) = 0;
  *(_DWORD *)(v4 + 32) = 0;
  *(void *)(v4 + 56) = *(unsigned int *)(a1 + 316);
}

void finish_pass_gather(uint64_t a1)
{
  v17[2] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 560);
  if (*(_DWORD *)(a1 + 348)) {
    emit_eobrun(*(void *)(a1 + 560));
  }
  v17[0] = 0;
  v17[1] = 0;
  v16[0] = 0;
  v16[1] = 0;
  if (*(int *)(a1 + 372) >= 1)
  {
    uint64_t v3 = 47;
    do
    {
      uint64_t v4 = *(void *)(a1 + 8 * v3);
      if (!*(_DWORD *)(a1 + 460) && !*(_DWORD *)(a1 + 468))
      {
        uint64_t v5 = *(int *)(v4 + 20);
        if (!*((_DWORD *)v17 + v5))
        {
          uint64_t v6 = a1 + 8 * v5;
          uint64_t v9 = *(void *)(v6 + 160);
          int v8 = (uint64_t *)(v6 + 160);
          uint64_t v7 = v9;
          if (!v9)
          {
            uint64_t v7 = _cg_jpeg_alloc_huff_table(a1);
            *int v8 = v7;
          }
          jpeg_gen_optimal_table((uint64_t *)a1, v7, *(void *)(v2 + 8 * v5 + 128));
          *((_DWORD *)v17 + v5) = 1;
        }
      }
      if (*(_DWORD *)(a1 + 464))
      {
        uint64_t v10 = *(int *)(v4 + 24);
        if (!*((_DWORD *)v16 + v10))
        {
          uint64_t v11 = a1 + 8 * v10;
          uint64_t v14 = *(void *)(v11 + 192);
          __int32 v13 = (uint64_t *)(v11 + 192);
          uint64_t v12 = v14;
          if (!v14)
          {
            uint64_t v12 = _cg_jpeg_alloc_huff_table(a1);
            uint64_t *v13 = v12;
          }
          jpeg_gen_optimal_table((uint64_t *)a1, v12, *(void *)(v2 + 8 * v10 + 160));
          *((_DWORD *)v16 + v10) = 1;
        }
      }
      uint64_t v15 = v3 - 46;
      ++v3;
    }
    while (v15 < *(int *)(a1 + 372));
  }
}

__n128 finish_pass_huff(uint64_t *a1)
{
  uint64_t v2 = a1[70];
  uint64_t v3 = (uint64_t *)a1[5];
  uint64_t v4 = *v3;
  if (*((_DWORD *)a1 + 87))
  {
    *(void *)(v2 + 200) = v4;
    *(void *)(v2 + 208) = v3[1];
    emit_eobrun(v2);
    flush_bits_e(v2);
    uint64_t v6 = (void *)a1[5];
    *uint64_t v6 = *(void *)(v2 + 200);
    v6[1] = *(void *)(v2 + 208);
  }
  else
  {
    uint64_t v7 = v3[1];
    uint64_t v12 = v4;
    uint64_t v13 = v7;
    __n128 v8 = *(__n128 *)(v2 + 40);
    long long v14 = *(_OWORD *)(v2 + 24);
    __n128 v15 = v8;
    int32x2_t v16 = a1;
    if (!flush_bits_s((uint64_t)&v12))
    {
      uint64_t v9 = *a1;
      *(_DWORD *)(v9 + 40) = 25;
      (*(void (**)(uint64_t *))v9)(a1);
    }
    uint64_t v10 = (void *)a1[5];
    uint64_t v11 = v13;
    void *v10 = v12;
    v10[1] = v11;
    __n128 result = v15;
    *(_OWORD *)(v2 + 24) = v14;
    *(__n128 *)(v2 + 40) = result;
  }
  return result;
}

uint64_t encode_mcu_DC_first(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = a1[70];
  uint64_t v5 = (uint64_t *)a1[5];
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  *(void *)(v4 + 200) = v7;
  *(void *)(v4 + 208) = v6;
  if (*((_DWORD *)a1 + 79) && !*(_DWORD *)(v4 + 56)) {
    emit_restart_e(v4, *(_DWORD *)(v4 + 60));
  }
  if (*((int *)a1 + 104) >= 1)
  {
    uint64_t v8 = 0;
    do
    {
      uint64_t v9 = *((int *)a1 + v8 + 105);
      uint64_t v10 = *(int *)(a1[v9 + 47] + 20);
      int v11 = **(__int16 **)(a2 + 8 * v8) >> *((_DWORD *)a1 + 118);
      uint64_t v12 = v4 + 4 * v9;
      int v13 = *(_DWORD *)(v12 + 36);
      *(_DWORD *)(v12 + 36) = v11;
      int v14 = v11 - v13;
      if (v11 == v13)
      {
        unsigned int v15 = 0;
      }
      else
      {
        if (v14 >= 0) {
          unsigned int v16 = v11 - v13;
        }
        else {
          unsigned int v16 = v13 - v11;
        }
        unsigned int v17 = -1;
        do
        {
          ++v17;
          BOOL v18 = v16 > 1;
          v16 >>= 1;
        }
        while (v18);
        unsigned int v15 = v17 + 1;
        if (v17 >= 0xB)
        {
          uint64_t v19 = *a1;
          *(_DWORD *)(v19 + 40) = 6;
          (*(void (**)(uint64_t *))v19)(a1);
        }
      }
      unsigned int v20 = v15;
      if (*(_DWORD *)(v4 + 192))
      {
        ++*(void *)(*(void *)(v4 + 8 * v10 + 128) + 8 * v15);
      }
      else
      {
        uint64_t v21 = *(void *)(v4 + 8 * v10 + 64);
        unsigned int v22 = *(_DWORD *)(v21 + 4 * v15);
        uint64_t v23 = v21 + v15;
        int v24 = *(char *)(v23 + 1024);
        if (*(unsigned char *)(v23 + 1024)
          || (double v33 = *(uint64_t **)(v4 + 216),
              uint64_t v34 = *v33,
              *(_DWORD *)(v34 + 40) = 41,
              (*(void (**)(uint64_t *))v34)(v33),
              !*(_DWORD *)(v4 + 192)))
        {
          uint64_t v25 = ~(-1 << v24) & v22;
          int v26 = *(_DWORD *)(v4 + 32) + v24;
          uint64_t v27 = (v25 << (24 - (*(unsigned char *)(v4 + 32) + v24))) | *(void *)(v4 + 24);
          if (v26 < 8)
          {
            int v32 = v26;
          }
          else
          {
            do
            {
              long long v28 = *(unsigned char **)(v4 + 200);
              *(void *)(v4 + 200) = v28 + 1;
              unsigned char *v28 = BYTE2(v27);
              uint64_t v29 = *(void *)(v4 + 208) - 1;
              *(void *)(v4 + 208) = v29;
              if (!v29) {
                dump_buffer_e((void *)v4);
              }
              if ((~v27 & 0xFF0000) == 0)
              {
                char v30 = *(unsigned char **)(v4 + 200);
                *(void *)(v4 + 200) = v30 + 1;
                *char v30 = 0;
                uint64_t v31 = *(void *)(v4 + 208) - 1;
                *(void *)(v4 + 208) = v31;
                if (!v31) {
                  dump_buffer_e((void *)v4);
                }
              }
              v27 <<= 8;
              int v32 = v26 - 8;
              BOOL v18 = v26 <= 15;
              v26 -= 8;
            }
            while (!v18);
          }
          *(void *)(v4 + 24) = v27;
          *(_DWORD *)(v4 + 32) = v32;
        }
      }
      if (v20 && !*(_DWORD *)(v4 + 192))
      {
        int v35 = *(_DWORD *)(v4 + 32) + v20;
        unint64_t v36 = ((unint64_t)(~(-1 << v20) & (v14 + (v14 >> 31))) << (24
                                                                                      - (*(unsigned char *)(v4 + 32)
                                                                                       + v20))) | *(void *)(v4 + 24);
        if (v35 < 8)
        {
          int v41 = *(_DWORD *)(v4 + 32) + v20;
        }
        else
        {
          do
          {
            double v37 = *(unsigned char **)(v4 + 200);
            *(void *)(v4 + 200) = v37 + 1;
            *double v37 = BYTE2(v36);
            uint64_t v38 = *(void *)(v4 + 208) - 1;
            *(void *)(v4 + 208) = v38;
            if (!v38) {
              dump_buffer_e((void *)v4);
            }
            if ((~v36 & 0xFF0000) == 0)
            {
              int8x16_t v39 = *(unsigned char **)(v4 + 200);
              *(void *)(v4 + 200) = v39 + 1;
              unsigned char *v39 = 0;
              uint64_t v40 = *(void *)(v4 + 208) - 1;
              *(void *)(v4 + 208) = v40;
              if (!v40) {
                dump_buffer_e((void *)v4);
              }
            }
            v36 <<= 8;
            int v41 = v35 - 8;
            BOOL v18 = v35 <= 15;
            v35 -= 8;
          }
          while (!v18);
        }
        *(void *)(v4 + 24) = v36;
        *(_DWORD *)(v4 + 32) = v41;
      }
      ++v8;
    }
    while (v8 < *((int *)a1 + 104));
  }
  float32x4_t v42 = (void *)a1[5];
  uint64_t v43 = *(void *)(v4 + 208);
  *float32x4_t v42 = *(void *)(v4 + 200);
  v42[1] = v43;
  int v44 = *((_DWORD *)a1 + 79);
  if (v44)
  {
    int v45 = *(_DWORD *)(v4 + 56);
    if (!v45)
    {
      *(_DWORD *)(v4 + 60) = (*(_DWORD *)(v4 + 60) + 1) & 7;
      int v45 = v44;
    }
    *(_DWORD *)(v4 + 56) = v45 - 1;
  }
  return 1;
}

uint64_t encode_mcu_AC_first(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a1[70];
  uint64_t v5 = (uint64_t *)a1[5];
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  *(void *)(v4 + 200) = v7;
  *(void *)(v4 + 208) = v6;
  if (*((_DWORD *)a1 + 79) && !*(_DWORD *)(v4 + 56)) {
    emit_restart_e(v4, *(_DWORD *)(v4 + 60));
  }
  int v8 = *((_DWORD *)a1 + 116);
  uint64_t v9 = *((int *)a1 + 115);
  if ((int)v9 <= v8)
  {
    int v10 = 0;
    int v11 = *((_DWORD *)a1 + 118);
    uint64_t v12 = a1[60];
    int v13 = v8 + 1;
    uint64_t v14 = *a2;
    do
    {
      int v15 = *(__int16 *)(v14 + 2 * *(int *)(v12 + 4 * v9));
      if (*(_WORD *)(v14 + 2 * *(int *)(v12 + 4 * v9))
        && (v15 >= 0 ? (unsigned int v16 = v15 >> v11) : (unsigned int v16 = -v15 >> v11),
            v15 < 0 ? (unsigned int v17 = ~(-v15 >> v11)) : (unsigned int v17 = v15 >> v11),
            v16))
      {
        if (*(_DWORD *)(v4 + 228)) {
          emit_eobrun(v4);
        }
        if (v10 >= 16)
        {
          do
          {
            emit_ac_symbol(v4, *(_DWORD *)(v4 + 224), 240);
            BOOL v18 = v10 > 0x1F;
            v10 -= 16;
          }
          while (v18);
        }
        if (v16 >= 2)
        {
          unsigned int v20 = 0;
          do
          {
            ++v20;
            BOOL v18 = v16 > 3;
            v16 >>= 1;
          }
          while (v18);
          int v19 = v20 + 1;
          if (v20 >= 0xA)
          {
            uint64_t v21 = *a1;
            *(_DWORD *)(v21 + 40) = 6;
            (*(void (**)(uint64_t *))v21)(a1);
          }
        }
        else
        {
          int v19 = 1;
        }
        emit_ac_symbol(v4, *(_DWORD *)(v4 + 224), v19 + 16 * v10);
        if (*(_DWORD *)(v4 + 192))
        {
          int v10 = 0;
        }
        else
        {
          uint64_t v22 = ~(-1 << v19) & v17;
          int v23 = *(_DWORD *)(v4 + 32) + v19;
          uint64_t v24 = (v22 << (24 - (*(unsigned char *)(v4 + 32) + v19))) | *(void *)(v4 + 24);
          if (v23 < 8)
          {
            int v29 = v23;
          }
          else
          {
            do
            {
              uint64_t v25 = *(unsigned char **)(v4 + 200);
              *(void *)(v4 + 200) = v25 + 1;
              *uint64_t v25 = BYTE2(v24);
              uint64_t v26 = *(void *)(v4 + 208) - 1;
              *(void *)(v4 + 208) = v26;
              if (!v26) {
                dump_buffer_e((void *)v4);
              }
              if ((~v24 & 0xFF0000) == 0)
              {
                uint64_t v27 = *(unsigned char **)(v4 + 200);
                *(void *)(v4 + 200) = v27 + 1;
                unsigned char *v27 = 0;
                uint64_t v28 = *(void *)(v4 + 208) - 1;
                *(void *)(v4 + 208) = v28;
                if (!v28) {
                  dump_buffer_e((void *)v4);
                }
              }
              v24 <<= 8;
              int v29 = v23 - 8;
              BOOL v18 = v23 <= 15;
              v23 -= 8;
            }
            while (!v18);
          }
          int v10 = 0;
          *(void *)(v4 + 24) = v24;
          *(_DWORD *)(v4 + 32) = v29;
        }
      }
      else
      {
        ++v10;
      }
      ++v9;
    }
    while (v13 != v9);
    if (v10 >= 1)
    {
      int v30 = *(_DWORD *)(v4 + 228) + 1;
      *(_DWORD *)(v4 + 228) = v30;
      if (v30 == 0x7FFF) {
        emit_eobrun(v4);
      }
    }
  }
  uint64_t v31 = (void *)a1[5];
  uint64_t v32 = *(void *)(v4 + 208);
  *uint64_t v31 = *(void *)(v4 + 200);
  v31[1] = v32;
  int v33 = *((_DWORD *)a1 + 79);
  if (v33)
  {
    int v34 = *(_DWORD *)(v4 + 56);
    if (!v34)
    {
      *(_DWORD *)(v4 + 60) = (*(_DWORD *)(v4 + 60) + 1) & 7;
      int v34 = v33;
    }
    *(_DWORD *)(v4 + 56) = v34 - 1;
  }
  return 1;
}

uint64_t encode_mcu_DC_refine(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 560);
  uint64_t v5 = *(uint64_t **)(a1 + 40);
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  *(void *)(v4 + 200) = v7;
  *(void *)(v4 + 208) = v6;
  if (*(_DWORD *)(a1 + 316) && !*(_DWORD *)(v4 + 56)) {
    emit_restart_e(v4, *(_DWORD *)(v4 + 60));
  }
  int v8 = *(_DWORD *)(a1 + 416);
  if (v8 >= 1)
  {
    uint64_t v9 = 0;
    int v10 = *(_DWORD *)(a1 + 472);
    do
    {
      if (!*(_DWORD *)(v4 + 192))
      {
        int v11 = *(_DWORD *)(v4 + 32);
        unint64_t v12 = ((unint64_t)((**(__int16 **)(a2 + 8 * v9) >> v10) & 1) << (23 - v11)) | *(void *)(v4 + 24);
        if (v11 < 7)
        {
          int v18 = v11 + 1;
        }
        else
        {
          int v13 = v11 + 9;
          do
          {
            uint64_t v14 = *(unsigned char **)(v4 + 200);
            *(void *)(v4 + 200) = v14 + 1;
            unsigned char *v14 = BYTE2(v12);
            uint64_t v15 = *(void *)(v4 + 208) - 1;
            *(void *)(v4 + 208) = v15;
            if (!v15) {
              dump_buffer_e((void *)v4);
            }
            if ((~v12 & 0xFF0000) == 0)
            {
              unsigned int v16 = *(unsigned char **)(v4 + 200);
              *(void *)(v4 + 200) = v16 + 1;
              unsigned char *v16 = 0;
              uint64_t v17 = *(void *)(v4 + 208) - 1;
              *(void *)(v4 + 208) = v17;
              if (!v17) {
                dump_buffer_e((void *)v4);
              }
            }
            v12 <<= 8;
            v13 -= 8;
          }
          while (v13 > 15);
          int v8 = *(_DWORD *)(a1 + 416);
          int v18 = v13 - 8;
        }
        *(void *)(v4 + 24) = v12;
        *(_DWORD *)(v4 + 32) = v18;
      }
      ++v9;
    }
    while (v9 < v8);
  }
  int v19 = *(void **)(a1 + 40);
  uint64_t v20 = *(void *)(v4 + 208);
  *int v19 = *(void *)(v4 + 200);
  v19[1] = v20;
  int v21 = *(_DWORD *)(a1 + 316);
  if (v21)
  {
    int v22 = *(_DWORD *)(v4 + 56);
    if (!v22)
    {
      *(_DWORD *)(v4 + 60) = (*(_DWORD *)(v4 + 60) + 1) & 7;
      int v22 = v21;
    }
    *(_DWORD *)(v4 + 56) = v22 - 1;
  }
  return 1;
}

uint64_t encode_mcu_AC_refine(uint64_t a1, uint64_t *a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 560);
  uint64_t v5 = *(void **)(a1 + 40);
  *(void *)(v4 + 200) = *v5;
  *(void *)(v4 + 208) = v5[1];
  if (*(_DWORD *)(a1 + 316) && !*(_DWORD *)(v4 + 56)) {
    emit_restart_e(v4, *(_DWORD *)(v4 + 60));
  }
  int v6 = *(_DWORD *)(a1 + 464);
  int v7 = *(_DWORD *)(a1 + 460);
  uint64_t v39 = a1;
  if (v7 <= v6)
  {
    int v10 = 0;
    int v11 = *(_DWORD *)(a1 + 472);
    uint64_t v12 = *a2;
    uint64_t v13 = v7;
    int v14 = v6 + 1;
    uint64_t v40 = *(void *)(a1 + 480);
    uint64_t v15 = (int *)(v40 + 4 * v7);
    unsigned int v16 = (unsigned int *)v42 + v7;
    memset(v42, 0, sizeof(v42));
    do
    {
      uint64_t v17 = *v15++;
      int v18 = *(__int16 *)(v12 + 2 * v17);
      if (v18 < 0) {
        int v18 = -v18;
      }
      unsigned int v19 = v18 >> v11;
      *v16++ = v19;
      if (v19 == 1) {
        int v10 = v7;
      }
      ++v7;
    }
    while (v14 != v7);
    int v9 = 0;
    uint64_t v20 = 0;
    uint64_t v41 = v10;
    int v21 = (unsigned char *)(*(void *)(v4 + 240) + *(unsigned int *)(v4 + 232));
    do
    {
      int v22 = *((_DWORD *)v42 + v13);
      if (v22)
      {
        if ((int)v20 < 16)
        {
          uint64_t v8 = v20;
          unsigned int v23 = v9;
        }
        else
        {
          uint64_t v8 = v20;
          unsigned int v23 = v9;
          if (v13 <= v41)
          {
            do
            {
              emit_eobrun(v4);
              emit_ac_symbol(v4, *(_DWORD *)(v4 + 224), 240);
              uint64_t v8 = (v20 - 16);
              emit_buffered_bits(v4, v21, v9);
              int v9 = 0;
              unsigned int v23 = 0;
              int v21 = *(unsigned char **)(v4 + 240);
              BOOL v24 = v20 > 0x1F;
              LODWORD(v20) = v20 - 16;
            }
            while (v24);
          }
        }
        if (v22 < 2)
        {
          emit_eobrun(v4);
          emit_ac_symbol(v4, *(_DWORD *)(v4 + 224), (16 * v8) | 1);
          if (!*(_DWORD *)(v4 + 192))
          {
            int v25 = *(_DWORD *)(v4 + 32);
            unint64_t v26 = ((unint64_t)((*(unsigned __int16 *)(v12 + 2 * *(int *)(v40 + 4 * v13)) >> 15) ^ 1u) << (23 - v25)) | *(void *)(v4 + 24);
            if (v25 < 7)
            {
              int v32 = v25 + 1;
            }
            else
            {
              int v27 = v25 + 9;
              do
              {
                uint64_t v28 = *(unsigned char **)(v4 + 200);
                *(void *)(v4 + 200) = v28 + 1;
                unsigned char *v28 = BYTE2(v26);
                uint64_t v29 = *(void *)(v4 + 208) - 1;
                *(void *)(v4 + 208) = v29;
                if (!v29) {
                  dump_buffer_e((void *)v4);
                }
                if ((~v26 & 0xFF0000) == 0)
                {
                  int v30 = *(unsigned char **)(v4 + 200);
                  *(void *)(v4 + 200) = v30 + 1;
                  *int v30 = 0;
                  uint64_t v31 = *(void *)(v4 + 208) - 1;
                  *(void *)(v4 + 208) = v31;
                  if (!v31) {
                    dump_buffer_e((void *)v4);
                  }
                }
                v26 <<= 8;
                v27 -= 8;
              }
              while (v27 > 15);
              int v32 = v27 - 8;
            }
            *(void *)(v4 + 24) = v26;
            *(_DWORD *)(v4 + 32) = v32;
          }
          emit_buffered_bits(v4, v21, v23);
          uint64_t v8 = 0;
          int v9 = 0;
          int v21 = *(unsigned char **)(v4 + 240);
        }
        else
        {
          int v9 = v23 + 1;
          v21[v23] = v22 & 1;
        }
      }
      else
      {
        uint64_t v8 = (v20 + 1);
      }
      ++v13;
      uint64_t v20 = v8;
    }
    while (v14 != v13);
  }
  else
  {
    LODWORD(v8) = 0;
    int v9 = 0;
  }
  if ((int)v8 > 0 || v9)
  {
    int v33 = *(_DWORD *)(v4 + 228) + 1;
    unsigned int v34 = *(_DWORD *)(v4 + 232) + v9;
    *(_DWORD *)(v4 + 228) = v33;
    *(_DWORD *)(v4 + 232) = v34;
    if (v33 == 0x7FFF || v34 >= 0x3AA) {
      emit_eobrun(v4);
    }
  }
  int v35 = *(void **)(v39 + 40);
  *int v35 = *(void *)(v4 + 200);
  v35[1] = *(void *)(v4 + 208);
  int v36 = *(_DWORD *)(v39 + 316);
  if (v36)
  {
    int v37 = *(_DWORD *)(v4 + 56);
    if (!v37)
    {
      *(_DWORD *)(v4 + 60) = (*(_DWORD *)(v4 + 60) + 1) & 7;
      int v37 = v36;
    }
    *(_DWORD *)(v4 + 56) = v37 - 1;
  }
  return 1;
}

uint64_t encode_mcu_gather(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = a1[70];
  if (*((_DWORD *)a1 + 79))
  {
    int v4 = *(_DWORD *)(v3 + 56);
    if (!v4)
    {
      if (*((int *)a1 + 93) < 1)
      {
        int v4 = *((_DWORD *)a1 + 79);
      }
      else
      {
        uint64_t v5 = 0;
        do
          *(_DWORD *)(v3 + 36 + 4 * v5++) = 0;
        while (v5 < *((int *)a1 + 93));
        int v4 = *((_DWORD *)a1 + 79);
      }
    }
    *(_DWORD *)(v3 + 56) = v4 - 1;
  }
  if (*((int *)a1 + 104) >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v33 = v3;
    uint64_t v34 = a2;
    do
    {
      uint64_t v7 = *((int *)a1 + v6 + 105);
      uint64_t v8 = a1[v7 + 47];
      int v9 = *(__int16 **)(a2 + 8 * v6);
      uint64_t v10 = v3 + 4 * v7;
      int v12 = *(_DWORD *)(v10 + 36);
      int v11 = (_DWORD *)(v10 + 36);
      uint64_t v13 = *(void *)(v3 + 8 * *(int *)(v8 + 20) + 128);
      int v14 = *(void **)(v3 + 8 * *(int *)(v8 + 24) + 160);
      uint64_t v15 = *((unsigned int *)a1 + 122);
      uint64_t v16 = a1[60];
      LODWORD(v8) = *v9;
      int v17 = v8 - v12;
      if (v8 == v12)
      {
        unsigned int v18 = 0;
      }
      else
      {
        if (v17 >= 0) {
          unsigned int v19 = v17;
        }
        else {
          unsigned int v19 = -v17;
        }
        unsigned int v20 = -1;
        do
        {
          ++v20;
          BOOL v21 = v19 > 1;
          v19 >>= 1;
        }
        while (v21);
        unsigned int v18 = v20 + 1;
        if (v20 >= 0xB)
        {
          uint64_t v22 = *a1;
          *(_DWORD *)(v22 + 40) = 6;
          (*(void (**)(uint64_t *))v22)(a1);
        }
      }
      ++*(void *)(v13 + 8 * v18);
      if ((int)v15 >= 1)
      {
        unsigned int v23 = 0;
        uint64_t v24 = v15 + 1;
        uint64_t v25 = 1;
        do
        {
          while (1)
          {
            signed int v26 = v23;
            LOWORD(v23) = v9[*(int *)(v16 + 4 * v25)];
            if (!(_WORD)v23) {
              break;
            }
            if (v26 >= 16)
            {
              if (v26 >= 31) {
                int v27 = 31;
              }
              else {
                int v27 = v26;
              }
              unsigned int v28 = v26 - v27 + 15;
              signed int v26 = v26 - (v28 & 0xFFFFFFF0) - 16;
              v14[240] += (v28 >> 4) + 1;
            }
            if ((v23 & 0x8000u) != 0) {
              unsigned int v23 = -(__int16)v23;
            }
            unsigned int v23 = (unsigned __int16)v23;
            if ((unsigned __int16)v23 >= 2u)
            {
              unsigned int v30 = 0;
              do
              {
                ++v30;
                BOOL v21 = v23 > 3;
                v23 >>= 1;
              }
              while (v21);
              int v29 = v30 + 1;
              if (v30 >= 0xA)
              {
                uint64_t v31 = *a1;
                *(_DWORD *)(v31 + 40) = 6;
                (*(void (**)(uint64_t *))v31)(a1);
              }
            }
            else
            {
              int v29 = 1;
            }
            unsigned int v23 = 0;
            ++v14[16 * v26 + v29];
            if (++v25 == v24) {
              goto LABEL_42;
            }
          }
          unsigned int v23 = v26 + 1;
          ++v25;
        }
        while (v25 != v24);
        if ((v26 & 0x80000000) == 0) {
          ++*v14;
        }
      }
LABEL_42:
      uint64_t v3 = v33;
      a2 = v34;
      *int v11 = **(__int16 **)(v34 + 8 * v6++);
    }
    while (v6 < *((int *)a1 + 104));
  }
  return 1;
}

uint64_t encode_mcu_huff(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = (int *)a1;
  uint64_t v4 = a1[70];
  float32x4_t v124 = 0;
  long long v122 = 0u;
  long long v123 = 0u;
  long long v121 = 0u;
  uint64_t v5 = (void *)a1[5];
  uint64_t v6 = v5[1];
  *(void *)&long long v121 = *v5;
  *((void *)&v121 + 1) = v6;
  long long v7 = *(_OWORD *)(v4 + 40);
  long long v122 = *(_OWORD *)(v4 + 24);
  long long v123 = v7;
  float32x4_t v124 = a1;
  if (*((_DWORD *)a1 + 79) && !*(_DWORD *)(v4 + 56))
  {
    int v106 = *(_DWORD *)(v4 + 60);
    uint64_t result = flush_bits_s((uint64_t)&v121);
    if (!result) {
      return result;
    }
    float32x2_t v107 = (unsigned char *)v121;
    *(void *)&long long v121 = v121 + 1;
    *float32x2_t v107 = -1;
    if (--*((void *)&v121 + 1))
    {
      char v108 = (unsigned char *)v121;
    }
    else
    {
      uint64_t v109 = v124[5];
      uint64_t result = (*(uint64_t (**)(void))(v109 + 24))();
      if (!result) {
        return result;
      }
      char v108 = *(unsigned char **)v109;
      *((void *)&v121 + 1) = *(void *)(v109 + 8);
    }
    *(void *)&long long v121 = v108 + 1;
    *char v108 = v106 - 48;
    float32x4_t v110 = (int *)v124;
    uint64_t v6 = --*((void *)&v121 + 1);
    if (!*((void *)&v121 + 1))
    {
      uint64_t v111 = v124[5];
      uint64_t result = (*(uint64_t (**)(uint64_t *))(v111 + 24))(v124);
      if (!result) {
        return result;
      }
      uint64_t v6 = *(void *)(v111 + 8);
      *(void *)&long long v121 = *(void *)v111;
      *((void *)&v121 + 1) = v6;
    }
    if (v110[93] >= 1)
    {
      uint64_t v112 = 0;
      do
        *((_DWORD *)&v122 + v112++ + 3) = 0;
      while (v112 < v110[93]);
    }
  }
  if (v3[104] >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v115 = a2;
    do
    {
      uint64_t v9 = v3[v8 + 105];
      uint64_t v117 = v8;
      uint64_t v10 = *(__int16 **)(a2 + 8 * v8);
      int v11 = (char *)&v121 + 4 * v9;
      int v12 = *((_DWORD *)v11 + 7);
      __n128 v116 = v11 + 28;
      uint64_t v13 = *(void *)&v3[2 * v9 + 94];
      uint64_t v14 = *(void *)(v4 + 8 * *(int *)(v13 + 20) + 64);
      uint64_t v15 = v124;
      uint64_t v119 = *((unsigned int *)v124 + 122);
      float32x4_t v120 = *(unsigned int **)(v4 + 8 * *(int *)(v13 + 24) + 96);
      uint64_t v118 = v124[60];
      LODWORD(v13) = *v10;
      int v16 = v13 - v12;
      if (v13 == v12)
      {
        unsigned int v17 = 0;
      }
      else
      {
        if (v16 >= 0) {
          unsigned int v18 = v16;
        }
        else {
          unsigned int v18 = -v16;
        }
        unsigned int v19 = -1;
        do
        {
          ++v19;
          BOOL v20 = v18 > 1;
          v18 >>= 1;
        }
        while (v20);
        unsigned int v17 = v19 + 1;
        if (v19 >= 0xB)
        {
          uint64_t v21 = *v124;
          *(_DWORD *)(v21 + 40) = 6;
          (*(void (**)(uint64_t *))v21)(v15);
        }
      }
      unsigned int v22 = *(_DWORD *)(v14 + 4 * v17);
      uint64_t v23 = v14 + v17;
      int v24 = *(char *)(v23 + 1024);
      if (!*(unsigned char *)(v23 + 1024))
      {
        uint64_t v25 = *v15;
        *(_DWORD *)(v25 + 40) = 41;
        (*(void (**)(uint64_t *))v25)(v15);
      }
      int v26 = DWORD2(v122) + v24;
      unint64_t v27 = ((unint64_t)(~(-1 << v24) & v22) << (24 - (BYTE8(v122) + v24))) | v122;
      if (DWORD2(v122) + v24 < 8)
      {
        int v33 = DWORD2(v122) + v24;
      }
      else
      {
        do
        {
          unsigned int v28 = (unsigned char *)v121;
          *(void *)&long long v121 = v121 + 1;
          unsigned char *v28 = BYTE2(v27);
          uint64_t v6 = --*((void *)&v121 + 1);
          if (!*((void *)&v121 + 1))
          {
            uint64_t v29 = v124[5];
            uint64_t result = (*(uint64_t (**)(void))(v29 + 24))();
            if (!result) {
              return result;
            }
            uint64_t v6 = *(void *)(v29 + 8);
            *(void *)&long long v121 = *(void *)v29;
            *((void *)&v121 + 1) = v6;
          }
          if ((~v27 & 0xFF0000) == 0)
          {
            uint64_t v31 = (unsigned char *)v121;
            *(void *)&long long v121 = v121 + 1;
            *uint64_t v31 = 0;
            uint64_t v6 = --*((void *)&v121 + 1);
            if (!*((void *)&v121 + 1))
            {
              uint64_t v32 = v124[5];
              uint64_t result = (*(uint64_t (**)(void))(v32 + 24))();
              if (!result) {
                return result;
              }
              uint64_t v6 = *(void *)(v32 + 8);
              *(void *)&long long v121 = *(void *)v32;
              *((void *)&v121 + 1) = v6;
            }
          }
          v27 <<= 8;
          int v33 = v26 - 8;
          BOOL v20 = v26 <= 15;
          v26 -= 8;
        }
        while (!v20);
      }
      unsigned int v34 = v17;
      *(void *)&long long v122 = v27;
      DWORD2(v122) = v33;
      if (v17)
      {
        int v35 = v33 + v17;
        v27 |= (unint64_t)(~(-1 << v34) & (v16 + (v16 >> 31))) << (24
                                                                                      - (v33
                                                                                       + v34));
        if ((int)(v33 + v34) < 8)
        {
          v33 += v34;
        }
        else
        {
          do
          {
            int v36 = (unsigned char *)v121;
            *(void *)&long long v121 = v121 + 1;
            *int v36 = BYTE2(v27);
            uint64_t v6 = --*((void *)&v121 + 1);
            if (!*((void *)&v121 + 1))
            {
              uint64_t v37 = v124[5];
              uint64_t result = (*(uint64_t (**)(void))(v37 + 24))();
              if (!result) {
                return result;
              }
              uint64_t v6 = *(void *)(v37 + 8);
              *(void *)&long long v121 = *(void *)v37;
              *((void *)&v121 + 1) = v6;
            }
            if ((~v27 & 0xFF0000) == 0)
            {
              uint64_t v38 = (unsigned char *)v121;
              *(void *)&long long v121 = v121 + 1;
              *uint64_t v38 = 0;
              uint64_t v6 = --*((void *)&v121 + 1);
              if (!*((void *)&v121 + 1))
              {
                uint64_t v39 = v124[5];
                uint64_t result = (*(uint64_t (**)(void))(v39 + 24))();
                if (!result) {
                  return result;
                }
                uint64_t v6 = *(void *)(v39 + 8);
                *(void *)&long long v121 = *(void *)v39;
                *((void *)&v121 + 1) = v6;
              }
            }
            v27 <<= 8;
            int v33 = v35 - 8;
            BOOL v20 = v35 <= 15;
            v35 -= 8;
          }
          while (!v20);
        }
        *(void *)&long long v122 = v27;
        DWORD2(v122) = v33;
      }
      uint64_t v40 = v118;
      if ((int)v119 >= 1)
      {
        uint64_t v41 = 1;
        int8x16_t v114 = (uint64_t *)v3;
        do
        {
          int v42 = 0;
          uint64_t v43 = v41;
          while (1)
          {
            uint64_t v44 = *(int *)(v40 + 4 * v43);
            int v45 = v10[v44];
            if (v10[v44]) {
              break;
            }
            ++v42;
            if (v119 + 1 == ++v43)
            {
              unsigned int v88 = *v120;
              int v89 = *((char *)v120 + 1024);
              if (!*((unsigned char *)v120 + 1024))
              {
                float32x4_t v90 = v124;
                uint64_t v91 = *v124;
                *(_DWORD *)(v91 + 40) = 41;
                (*(void (**)(uint64_t *))v91)(v90);
              }
              uint64_t v92 = ~(-1 << v89) & v88;
              int v93 = v33 + v89;
              unint64_t v94 = (v92 << (24 - (v33 + v89))) | v27;
              uint64_t v3 = (int *)v114;
              if (v33 + v89 < 8)
              {
                int v101 = v33 + v89;
              }
              else
              {
                do
                {
                  float32x2_t v95 = (unsigned char *)v121;
                  *(void *)&long long v121 = v121 + 1;
                  *float32x2_t v95 = BYTE2(v94);
                  uint64_t v6 = --*((void *)&v121 + 1);
                  if (!*((void *)&v121 + 1))
                  {
                    __n128 v96 = (uint64_t *)v124[5];
                    uint64_t result = ((uint64_t (*)(void))v96[3])();
                    if (!result) {
                      return result;
                    }
                    uint64_t v97 = *v96;
                    uint64_t v6 = v96[1];
                    *(void *)&long long v121 = v97;
                    *((void *)&v121 + 1) = v6;
                  }
                  if ((~v94 & 0xFF0000) == 0)
                  {
                    uint64_t v98 = (unsigned char *)v121;
                    *(void *)&long long v121 = v121 + 1;
                    *uint64_t v98 = 0;
                    uint64_t v6 = --*((void *)&v121 + 1);
                    if (!*((void *)&v121 + 1))
                    {
                      int32x2_t v99 = (uint64_t *)v124[5];
                      uint64_t result = ((uint64_t (*)(void))v99[3])();
                      if (!result) {
                        return result;
                      }
                      uint64_t v100 = *v99;
                      uint64_t v6 = v99[1];
                      *(void *)&long long v121 = v100;
                      *((void *)&v121 + 1) = v6;
                    }
                  }
                  v94 <<= 8;
                  int v101 = v93 - 8;
                  BOOL v20 = v93 <= 15;
                  v93 -= 8;
                }
                while (!v20);
              }
              *(void *)&long long v122 = v94;
              DWORD2(v122) = v101;
              goto LABEL_118;
            }
          }
          uint64_t v113 = v4;
          if (v42 < 0x10)
          {
            int v58 = v42;
          }
          else
          {
            do
            {
              unsigned int v46 = v120[240];
              int v47 = *((char *)v120 + 1264);
              if (!*((unsigned char *)v120 + 1264))
              {
                float32x4_t v48 = v124;
                uint64_t v49 = *v124;
                *(_DWORD *)(v49 + 40) = 41;
                (*(void (**)(uint64_t *))v49)(v48);
              }
              uint64_t v50 = ~(-1 << v47) & v46;
              unsigned int v51 = v33 + v47;
              v27 |= v50 << (24 - (v33 + v47));
              if (v33 + v47 < 8)
              {
                v33 += v47;
              }
              else
              {
                do
                {
                  int16x4_t v52 = (unsigned char *)v121;
                  *(void *)&long long v121 = v121 + 1;
                  unsigned char *v52 = BYTE2(v27);
                  uint64_t v6 = --*((void *)&v121 + 1);
                  if (!*((void *)&v121 + 1))
                  {
                    int32x2_t v53 = (uint64_t *)v124[5];
                    uint64_t result = ((uint64_t (*)(void))v53[3])();
                    if (!result) {
                      return result;
                    }
                    uint64_t v54 = *v53;
                    uint64_t v6 = v53[1];
                    *(void *)&long long v121 = v54;
                    *((void *)&v121 + 1) = v6;
                  }
                  if ((~v27 & 0xFF0000) == 0)
                  {
                    int8x16_t v55 = (unsigned char *)v121;
                    *(void *)&long long v121 = v121 + 1;
                    unsigned char *v55 = 0;
                    uint64_t v6 = --*((void *)&v121 + 1);
                    if (!*((void *)&v121 + 1))
                    {
                      float32x4_t v56 = (uint64_t *)v124[5];
                      uint64_t result = ((uint64_t (*)(void))v56[3])();
                      if (!result) {
                        return result;
                      }
                      uint64_t v57 = *v56;
                      uint64_t v6 = v56[1];
                      *(void *)&long long v121 = v57;
                      *((void *)&v121 + 1) = v6;
                    }
                  }
                  v27 <<= 8;
                  int v33 = v51 - 8;
                  BOOL v20 = v51 > 0xF;
                  v51 -= 8;
                }
                while (v20);
              }
              *(void *)&long long v122 = v27;
              DWORD2(v122) = v33;
              int v58 = v42 - 16;
              BOOL v20 = v42 <= 31;
              v42 -= 16;
            }
            while (!v20);
          }
          if (v45 >= 0) {
            unsigned int v59 = v45;
          }
          else {
            unsigned int v59 = -v45;
          }
          if (v59 >= 2)
          {
            unsigned int v61 = 0;
            do
            {
              ++v61;
              BOOL v20 = v59 > 3;
              v59 >>= 1;
            }
            while (v20);
            int v60 = v61 + 1;
            if (v61 >= 0xA)
            {
              float32x4_t v62 = v124;
              uint64_t v63 = *v124;
              *(_DWORD *)(v63 + 40) = 6;
              (*(void (**)(uint64_t *))v63)(v62);
            }
          }
          else
          {
            int v60 = 1;
          }
          int v64 = v60 + 16 * v58;
          unsigned int v65 = v120[v64];
          uint64_t v66 = (uint64_t)v120 + v64;
          int v67 = *(char *)(v66 + 1024);
          if (!*(unsigned char *)(v66 + 1024))
          {
            char v68 = v124;
            uint64_t v69 = *v124;
            *(_DWORD *)(v69 + 40) = 41;
            (*(void (**)(uint64_t *))v69)(v68);
          }
          uint64_t v70 = ~(-1 << v67) & v65;
          unsigned int v71 = v33 + v67;
          unint64_t v72 = (v70 << (24 - (v33 + v67))) | v27;
          if (v33 + v67 < 8)
          {
            unsigned int v79 = v33 + v67;
            uint64_t v4 = v113;
          }
          else
          {
            uint64_t v4 = v113;
            do
            {
              int8x8_t v73 = (unsigned char *)v121;
              *(void *)&long long v121 = v121 + 1;
              unsigned char *v73 = BYTE2(v72);
              uint64_t v6 = --*((void *)&v121 + 1);
              if (!*((void *)&v121 + 1))
              {
                uint64_t v74 = (uint64_t *)v124[5];
                uint64_t result = ((uint64_t (*)(void))v74[3])();
                if (!result) {
                  return result;
                }
                uint64_t v75 = *v74;
                uint64_t v6 = v74[1];
                *(void *)&long long v121 = v75;
                *((void *)&v121 + 1) = v6;
              }
              if ((~v72 & 0xFF0000) == 0)
              {
                int8x8_t v76 = (unsigned char *)v121;
                *(void *)&long long v121 = v121 + 1;
                unsigned char *v76 = 0;
                uint64_t v6 = --*((void *)&v121 + 1);
                if (!*((void *)&v121 + 1))
                {
                  char v77 = (uint64_t *)v124[5];
                  uint64_t result = ((uint64_t (*)(void))v77[3])();
                  if (!result) {
                    return result;
                  }
                  uint64_t v78 = *v77;
                  uint64_t v6 = v77[1];
                  *(void *)&long long v121 = v78;
                  *((void *)&v121 + 1) = v6;
                }
              }
              v72 <<= 8;
              unsigned int v79 = v71 - 8;
              BOOL v20 = v71 > 0xF;
              v71 -= 8;
            }
            while (v20);
          }
          unsigned int v80 = v79 + v60;
          unint64_t v27 = ((unint64_t)(~(-1 << v60) & (v45 + (v45 >> 15))) << (24
                                                                                        - (v79
                                                                                         + v60))) | v72;
          if ((int)(v79 + v60) < 8)
          {
            int v33 = v79 + v60;
          }
          else
          {
            do
            {
              uint64_t v81 = (unsigned char *)v121;
              *(void *)&long long v121 = v121 + 1;
              unsigned char *v81 = BYTE2(v27);
              uint64_t v6 = --*((void *)&v121 + 1);
              if (!*((void *)&v121 + 1))
              {
                char v82 = (uint64_t *)v124[5];
                uint64_t result = ((uint64_t (*)(void))v82[3])();
                if (!result) {
                  return result;
                }
                uint64_t v83 = *v82;
                uint64_t v6 = v82[1];
                *(void *)&long long v121 = v83;
                *((void *)&v121 + 1) = v6;
              }
              if ((~v27 & 0xFF0000) == 0)
              {
                char v84 = (unsigned char *)v121;
                *(void *)&long long v121 = v121 + 1;
                *char v84 = 0;
                uint64_t v6 = --*((void *)&v121 + 1);
                if (!*((void *)&v121 + 1))
                {
                  uint64_t v85 = (uint64_t *)v124[5];
                  uint64_t result = ((uint64_t (*)(void))v85[3])();
                  if (!result) {
                    return result;
                  }
                  uint64_t v86 = *v85;
                  uint64_t v6 = v85[1];
                  *(void *)&long long v121 = v86;
                  *((void *)&v121 + 1) = v6;
                }
              }
              v27 <<= 8;
              int v33 = v80 - 8;
              BOOL v20 = v80 > 0xF;
              v80 -= 8;
            }
            while (v20);
          }
          *(void *)&long long v122 = v27;
          DWORD2(v122) = v33;
          uint64_t v41 = v43 + 1;
          BOOL v87 = v119 == v43;
          uint64_t v3 = (int *)v114;
          uint64_t v40 = v118;
        }
        while (!v87);
      }
LABEL_118:
      a2 = v115;
      *__n128 v116 = **(__int16 **)(v115 + 8 * v117);
      uint64_t v8 = v117 + 1;
    }
    while (v117 + 1 < v3[104]);
  }
  char v102 = (void *)*((void *)v3 + 5);
  *char v102 = v121;
  v102[1] = v6;
  long long v103 = v123;
  *(_OWORD *)(v4 + 24) = v122;
  *(_OWORD *)(v4 + 40) = v103;
  int v104 = v3[79];
  if (v104)
  {
    int v105 = *(_DWORD *)(v4 + 56);
    if (!v105)
    {
      *(_DWORD *)(v4 + 60) = (*(_DWORD *)(v4 + 60) + 1) & 7;
      int v105 = v104;
    }
    *(_DWORD *)(v4 + 56) = v105 - 1;
  }
  return 1;
}

void jpeg_make_c_derived_tbl(uint64_t a1, int a2, unsigned int a3, void *a4)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  memset(v35, 0, 257);
  if (a3 >= 4)
  {
    uint64_t v8 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v8 + 10) = 52;
    *((_DWORD *)v8 + 12) = a3;
    (**(void (***)(uint64_t))a1)(a1);
  }
  uint64_t v9 = a1 + 8 * (int)a3;
  uint64_t v10 = (uint64_t *)(v9 + 160);
  int v11 = (uint64_t *)(v9 + 192);
  if (a2) {
    int v11 = v10;
  }
  uint64_t v12 = *v11;
  if (!*v11) {
    uint64_t v12 = _cg_jpeg_std_huff_table(a1, a2, a3);
  }
  uint64_t v13 = (_OWORD *)*a4;
  if (!*a4)
  {
    uint64_t v13 = (_OWORD *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1280);
    *a4 = v13;
  }
  int v33 = a2;
  LODWORD(v14) = 0;
  for (uint64_t i = 1; i != 17; ++i)
  {
    size_t v16 = *(unsigned __int8 *)(v12 + i);
    if ((int)v14 + (int)v16 >= 257)
    {
      unsigned int v17 = *(void (***)(uint64_t))a1;
      *((_DWORD *)v17 + 10) = 9;
      (*v17)(a1);
    }
    if (v16)
    {
      memset(&v35[(int)v14], i, v16);
      LODWORD(v14) = v14 + v16;
    }
  }
  bzero(v34, 0x404uLL);
  v35[(int)v14] = 0;
  int v18 = v35[0];
  if (v35[0])
  {
    unsigned int v19 = 0;
    int v20 = 0;
    char v21 = v35[0];
    do
    {
      if (v18 == v21)
      {
        unsigned int v22 = &v34[v20];
        uint64_t v23 = &v35[v20 + 1];
        do
        {
          *v22++ = v19++;
          int v24 = *v23++;
          ++v20;
        }
        while (v18 == v24);
      }
      if (1 << v18 <= v19)
      {
        uint64_t v25 = *(void (***)(uint64_t))a1;
        *((_DWORD *)v25 + 10) = 9;
        (*v25)(a1);
      }
      v19 *= 2;
      ++v18;
      char v21 = v35[v20];
    }
    while (v21);
  }
  v13[79] = 0u;
  v13[78] = 0u;
  v13[77] = 0u;
  v13[76] = 0u;
  v13[75] = 0u;
  v13[74] = 0u;
  v13[73] = 0u;
  v13[72] = 0u;
  v13[71] = 0u;
  v13[70] = 0u;
  v13[69] = 0u;
  v13[68] = 0u;
  v13[67] = 0u;
  v13[66] = 0u;
  v13[65] = 0u;
  v13[64] = 0u;
  if ((int)v14 >= 1)
  {
    int v26 = (unsigned __int8 *)(v12 + 17);
    unint64_t v27 = v35;
    unsigned int v28 = v34;
    uint64_t v14 = v14;
    do
    {
      unsigned int v30 = *v26++;
      uint64_t v29 = v30;
      if (v33 && v29 > 0xF || *((unsigned char *)v13 + v29 + 1024))
      {
        uint64_t v31 = *(void (***)(uint64_t))a1;
        *((_DWORD *)v31 + 10) = 9;
        (*v31)(a1);
      }
      int v32 = *v28++;
      *((_DWORD *)v13 + v29) = v32;
      LOBYTE(v32) = *v27++;
      *((unsigned char *)v13 + v29 + 1024) = v32;
      --v14;
    }
    while (v14);
  }
}

uint64_t emit_eobrun(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 228);
  if (v1)
  {
    uint64_t v2 = result;
    if (v1 == 1)
    {
      unsigned int v3 = 0;
    }
    else
    {
      unsigned int v4 = -1;
      do
      {
        ++v4;
        BOOL v5 = v1 > 3;
        v1 >>= 1;
      }
      while (v5);
      unsigned int v3 = v4 + 1;
      if (v4 >= 0xE)
      {
        uint64_t v6 = *(uint64_t **)(result + 216);
        uint64_t v7 = *v6;
        *(_DWORD *)(v7 + 40) = 41;
        (*(void (**)(uint64_t *))v7)(v6);
      }
    }
    emit_ac_symbol(v2, *(_DWORD *)(v2 + 224), 16 * v3);
    if (v3 && !*(_DWORD *)(v2 + 192))
    {
      unint64_t v8 = *(unsigned int *)(v2 + 228) & (unint64_t)~(-1 << v3);
      int v9 = *(_DWORD *)(v2 + 32) + v3;
      unint64_t v10 = (v8 << (24 - v9)) | *(void *)(v2 + 24);
      if (v9 < 8)
      {
        int v15 = v9;
      }
      else
      {
        do
        {
          int v11 = *(unsigned char **)(v2 + 200);
          *(void *)(v2 + 200) = v11 + 1;
          *int v11 = BYTE2(v10);
          uint64_t v12 = *(void *)(v2 + 208) - 1;
          *(void *)(v2 + 208) = v12;
          if (!v12) {
            dump_buffer_e((void *)v2);
          }
          if ((~v10 & 0xFF0000) == 0)
          {
            uint64_t v13 = *(unsigned char **)(v2 + 200);
            *(void *)(v2 + 200) = v13 + 1;
            unsigned char *v13 = 0;
            uint64_t v14 = *(void *)(v2 + 208) - 1;
            *(void *)(v2 + 208) = v14;
            if (!v14) {
              dump_buffer_e((void *)v2);
            }
          }
          v10 <<= 8;
          int v15 = v9 - 8;
          BOOL v5 = v9 <= 15;
          v9 -= 8;
        }
        while (!v5);
      }
      *(void *)(v2 + 24) = v10;
      *(_DWORD *)(v2 + 32) = v15;
    }
    *(_DWORD *)(v2 + 228) = 0;
    uint64_t result = emit_buffered_bits(v2, *(unsigned char **)(v2 + 240), *(_DWORD *)(v2 + 232));
    *(_DWORD *)(v2 + 232) = 0;
  }
  return result;
}

double jpeg_gen_optimal_table(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  bzero(__b, 0x404uLL);
  unint64_t v6 = 0;
  *(void *)(a3 + 2048) = 1;
  int v7 = 256;
  while (1)
  {
    if (!*(void *)(a3 + 8 * v6)) {
      goto LABEL_5;
    }
    if (v6 > 0xFF) {
      break;
    }
    __b[v7] = v6;
    int v7 = v6;
LABEL_5:
    ++v6;
  }
  __b[v7] = -1;
  unsigned int v8 = __b[256];
  if ((__b[256] & 0x80000000) == 0)
  {
    int v9 = (unsigned char *)(a2 + 17);
    do
    {
      unsigned int v10 = __b[v8];
      if ((v10 & 0x80000000) != 0)
      {
        int v12 = 256;
      }
      else
      {
        uint64_t v11 = *(void *)(a3 + 8 * v8);
        int v12 = 256;
        int v13 = v8;
        do
        {
          if (*(void *)(a3 + 8 * v10) > v11)
          {
            unsigned int v8 = v10;
            int v12 = v13;
            uint64_t v11 = *(void *)(a3 + 8 * v10);
          }
          int v13 = v10;
          unsigned int v10 = __b[v10];
        }
        while ((v10 & 0x80000000) == 0);
        unsigned int v10 = __b[v8];
      }
      __b[v12] = v10;
      *v9++ = v8;
      unsigned int v8 = __b[256];
    }
    while ((__b[256] & 0x80000000) == 0);
  }
  char v47 = 0;
  long long v45 = 0u;
  long long v46 = 0u;
  bzero(v44, 0x404uLL);
  memset(__b, 255, sizeof(__b));
LABEL_17:
  uint64_t v14 = 0;
  LODWORD(v15) = -1;
  uint64_t v16 = 1000000000;
  while (1)
  {
    do
    {
      uint64_t v17 = *(void *)(a3 + 8 * v14);
      if (v17) {
        BOOL v18 = v17 <= v16;
      }
      else {
        BOOL v18 = 0;
      }
      int v19 = !v18;
      if (v19) {
        uint64_t v15 = v15;
      }
      else {
        uint64_t v15 = v14;
      }
      if (!v19) {
        uint64_t v16 = *(void *)(a3 + 8 * v14);
      }
      ++v14;
    }
    while (v14 != 257);
    uint64_t v20 = 0;
    LODWORD(v21) = -1;
    uint64_t v22 = 1000000000;
    do
    {
      uint64_t v23 = *(void *)(a3 + 8 * v20);
      if (v23) {
        BOOL v24 = v23 <= v22;
      }
      else {
        BOOL v24 = 0;
      }
      BOOL v25 = !v24 || v15 == v20;
      if (v25) {
        uint64_t v21 = v21;
      }
      else {
        uint64_t v21 = v20;
      }
      if (!v25) {
        uint64_t v22 = *(void *)(a3 + 8 * v20);
      }
      ++v20;
    }
    while (v20 != 257);
    if ((v21 & 0x80000000) != 0) {
      break;
    }
    *(void *)(a3 + 8 * (int)v15) += *(void *)(a3 + 8 * v21);
    *(void *)(a3 + 8 * v21) = 0;
    ++v44[(int)v15];
    uint64_t v26 = __b[(int)v15];
    if ((v26 & 0x80000000) != 0)
    {
      uint64_t v15 = (int)v15;
    }
    else
    {
      do
      {
        uint64_t v15 = v26;
        ++v44[v26];
        uint64_t v26 = __b[v26];
      }
      while ((v26 & 0x80000000) == 0);
    }
    uint64_t v14 = 0;
    __b[v15] = v21;
    ++v44[v21];
    uint64_t v27 = __b[v21];
    LODWORD(v15) = -1;
    uint64_t v16 = 1000000000;
    if ((v27 & 0x80000000) == 0)
    {
      do
      {
        ++v44[v27];
        uint64_t v27 = __b[v27];
      }
      while ((v27 & 0x80000000) == 0);
      goto LABEL_17;
    }
  }
  for (uint64_t i = 0; i != 257; ++i)
  {
    uint64_t v29 = (int)v44[i];
    if (v29)
    {
      if ((int)v29 >= 33)
      {
        uint64_t v30 = *a1;
        *(_DWORD *)(v30 + 40) = 40;
        (*(void (**)(uint64_t *))v30)(a1);
      }
      ++*((unsigned char *)&v45 + v29);
    }
  }
  unint64_t v31 = 32;
  uint64_t v32 = 29;
  do
  {
    char v33 = *((unsigned char *)&v45 + v31);
    if (v33)
    {
      unint64_t v34 = v31 - 1;
      do
      {
        unint64_t v35 = v31 - 2;
        if (!*((unsigned char *)&v45 + v31 - 2))
        {
          uint64_t v36 = v32;
          do
          {
            if (v36 == -1)
            {
              uint64_t v37 = *a1;
              *(_DWORD *)(v37 + 40) = 40;
              (*(void (**)(uint64_t *))v37)(a1);
            }
          }
          while (!*((unsigned __int8 *)&v45 + v36--));
          unint64_t v35 = v36 + 1;
        }
        *((unsigned char *)&v45 + v31) = v33 - 2;
        ++*((unsigned char *)&v45 + v34);
        *((unsigned char *)&v45 + (int)v35 + 1) += 2;
        --*((unsigned char *)&v45 + v35);
        char v33 = *((unsigned char *)&v45 + v31);
      }
      while (v33);
    }
    else
    {
      unint64_t v34 = v31 - 1;
    }
    --v32;
    BOOL v18 = v31 > 0x11;
    unint64_t v31 = v34;
  }
  while (v18);
  uint64_t v39 = (char *)&v46 + 1;
  do
  {
    int v41 = *--v39;
    char v40 = v41;
  }
  while (!v41);
  unsigned char *v39 = v40 - 1;
  double result = *(double *)&v45;
  *(_OWORD *)a2 = v45;
  *(unsigned char *)(a2 + 16) = v46;
  *(_DWORD *)(a2 + 276) = 0;
  return result;
}

uint64_t emit_ac_symbol(uint64_t result, int a2, int a3)
{
  uint64_t v3 = result;
  if (*(_DWORD *)(result + 192))
  {
    uint64_t v4 = *(void *)(result + 8 * a2 + 160);
    ++*(void *)(v4 + 8 * a3);
  }
  else
  {
    uint64_t v5 = *(void *)(result + 8 * a2 + 96);
    unsigned int v6 = *(_DWORD *)(v5 + 4 * a3);
    uint64_t v7 = v5 + a3;
    int v8 = *(char *)(v7 + 1024);
    if (*(unsigned char *)(v7 + 1024)
      || (int v9 = *(uint64_t **)(result + 216),
          uint64_t v10 = *v9,
          *(_DWORD *)(v10 + 40) = 41,
          double result = (*(uint64_t (**)(uint64_t *))v10)(v9),
          !*(_DWORD *)(v3 + 192)))
    {
      uint64_t v11 = ~(-1 << v8) & v6;
      int v12 = *(_DWORD *)(v3 + 32) + v8;
      uint64_t v13 = (v11 << (24 - (*(unsigned char *)(v3 + 32) + v8))) | *(void *)(v3 + 24);
      if (v12 < 8)
      {
        int v18 = v12;
      }
      else
      {
        do
        {
          uint64_t v14 = *(unsigned char **)(v3 + 200);
          *(void *)(v3 + 200) = v14 + 1;
          unsigned char *v14 = BYTE2(v13);
          uint64_t v15 = *(void *)(v3 + 208) - 1;
          *(void *)(v3 + 208) = v15;
          if (!v15) {
            double result = dump_buffer_e((void *)v3);
          }
          if ((~v13 & 0xFF0000) == 0)
          {
            uint64_t v16 = *(unsigned char **)(v3 + 200);
            *(void *)(v3 + 200) = v16 + 1;
            unsigned char *v16 = 0;
            uint64_t v17 = *(void *)(v3 + 208) - 1;
            *(void *)(v3 + 208) = v17;
            if (!v17) {
              double result = dump_buffer_e((void *)v3);
            }
          }
          v13 <<= 8;
          int v18 = v12 - 8;
          BOOL v19 = v12 <= 15;
          v12 -= 8;
        }
        while (!v19);
      }
      *(void *)(v3 + 24) = v13;
      *(_DWORD *)(v3 + 32) = v18;
    }
  }
  return result;
}

uint64_t emit_buffered_bits(uint64_t result, unsigned char *a2, int a3)
{
  if (a3)
  {
    uint64_t v3 = result;
    if (!*(_DWORD *)(result + 192))
    {
      int v4 = a3;
LABEL_4:
      int v6 = *(_DWORD *)(v3 + 32);
      unint64_t v7 = ((unint64_t)(*a2 & 1) << (23 - v6)) | *(void *)(v3 + 24);
      if (v6 < 7)
      {
        int v13 = v6 + 1;
      }
      else
      {
        int v8 = v6 + 9;
        do
        {
          int v9 = *(unsigned char **)(v3 + 200);
          *(void *)(v3 + 200) = v9 + 1;
          unsigned char *v9 = BYTE2(v7);
          uint64_t v10 = *(void *)(v3 + 208) - 1;
          *(void *)(v3 + 208) = v10;
          if (!v10) {
            double result = dump_buffer_e((void *)v3);
          }
          if ((~v7 & 0xFF0000) == 0)
          {
            uint64_t v11 = *(unsigned char **)(v3 + 200);
            *(void *)(v3 + 200) = v11 + 1;
            *uint64_t v11 = 0;
            uint64_t v12 = *(void *)(v3 + 208) - 1;
            *(void *)(v3 + 208) = v12;
            if (!v12) {
              double result = dump_buffer_e((void *)v3);
            }
          }
          v7 <<= 8;
          v8 -= 8;
        }
        while (v8 > 15);
        int v13 = v8 - 8;
      }
      *(void *)(v3 + 24) = v7;
      *(_DWORD *)(v3 + 32) = v13;
      while (--v4)
      {
        ++a2;
        if (!*(_DWORD *)(v3 + 192)) {
          goto LABEL_4;
        }
      }
    }
  }
  return result;
}

uint64_t dump_buffer_e(void *a1)
{
  uint64_t v2 = *(void *)(a1[27] + 40);
  uint64_t result = (*(uint64_t (**)(void))(v2 + 24))();
  if (!result)
  {
    int v4 = (uint64_t *)a1[27];
    uint64_t v5 = *v4;
    *(_DWORD *)(v5 + 40) = 25;
    uint64_t result = (*(uint64_t (**)(uint64_t *))v5)(v4);
  }
  uint64_t v6 = *(void *)(v2 + 8);
  a1[25] = *(void *)v2;
  a1[26] = v6;
  return result;
}

uint64_t flush_bits_e(uint64_t result)
{
  uint64_t v1 = result;
  if (!*(_DWORD *)(result + 192))
  {
    int v2 = *(_DWORD *)(result + 32);
    if (v2 >= 1)
    {
      uint64_t v3 = (127 << (17 - v2)) | *(void *)(result + 24);
      int v4 = v2 + 15;
      do
      {
        uint64_t v5 = *(unsigned char **)(v1 + 200);
        *(void *)(v1 + 200) = v5 + 1;
        unsigned char *v5 = BYTE2(v3);
        uint64_t v6 = *(void *)(v1 + 208) - 1;
        *(void *)(v1 + 208) = v6;
        if (!v6) {
          uint64_t result = dump_buffer_e((void *)v1);
        }
        if ((~v3 & 0xFF0000) == 0)
        {
          unint64_t v7 = *(unsigned char **)(v1 + 200);
          *(void *)(v1 + 200) = v7 + 1;
          unsigned char *v7 = 0;
          uint64_t v8 = *(void *)(v1 + 208) - 1;
          *(void *)(v1 + 208) = v8;
          if (!v8) {
            uint64_t result = dump_buffer_e((void *)v1);
          }
        }
        LODWORD(v3) = v3 << 8;
        v4 -= 8;
      }
      while (v4 > 15);
    }
  }
  *(void *)(v1 + 24) = 0;
  *(_DWORD *)(v1 + 32) = 0;
  return result;
}

uint64_t flush_bits_s(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 24);
  if (v2 >= 1)
  {
    uint64_t v3 = (127 << (17 - v2)) | *(void *)(a1 + 16);
    int v4 = v2 + 15;
    do
    {
      uint64_t v5 = (unsigned char *)(*(void *)a1)++;
      unsigned char *v5 = BYTE2(v3);
      uint64_t v6 = *(void *)(a1 + 8) - 1;
      *(void *)(a1 + 8) = v6;
      if (!v6)
      {
        uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 40);
        uint64_t result = (*(uint64_t (**)(void))(v7 + 24))();
        if (!result) {
          return result;
        }
        uint64_t v9 = *(void *)(v7 + 8);
        *(void *)a1 = *(void *)v7;
        *(void *)(a1 + 8) = v9;
      }
      if ((~v3 & 0xFF0000) == 0)
      {
        uint64_t v10 = (unsigned char *)(*(void *)a1)++;
        unsigned char *v10 = 0;
        uint64_t v11 = *(void *)(a1 + 8) - 1;
        *(void *)(a1 + 8) = v11;
        if (!v11)
        {
          uint64_t v12 = *(void *)(*(void *)(a1 + 48) + 40);
          uint64_t result = (*(uint64_t (**)(void))(v12 + 24))();
          if (!result) {
            return result;
          }
          uint64_t v13 = *(void *)(v12 + 8);
          *(void *)a1 = *(void *)v12;
          *(void *)(a1 + 8) = v13;
        }
      }
      LODWORD(v3) = v3 << 8;
      v4 -= 8;
    }
    while (v4 > 15);
  }
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = 0;
  return 1;
}

uint64_t emit_restart_e(uint64_t a1, char a2)
{
  uint64_t result = emit_eobrun(a1);
  if (!*(_DWORD *)(a1 + 192))
  {
    uint64_t result = flush_bits_e(a1);
    uint64_t v5 = *(unsigned char **)(a1 + 200);
    *(void *)(a1 + 200) = v5 + 1;
    unsigned char *v5 = -1;
    uint64_t v6 = *(void *)(a1 + 208) - 1;
    *(void *)(a1 + 208) = v6;
    if (!v6) {
      uint64_t result = dump_buffer_e((void *)a1);
    }
    uint64_t v7 = *(unsigned char **)(a1 + 200);
    *(void *)(a1 + 200) = v7 + 1;
    unsigned char *v7 = a2 - 48;
    uint64_t v8 = *(void *)(a1 + 208) - 1;
    *(void *)(a1 + 208) = v8;
    if (!v8) {
      uint64_t result = dump_buffer_e((void *)a1);
    }
  }
  uint64_t v9 = *(void *)(a1 + 216);
  if (*(_DWORD *)(v9 + 460))
  {
    *(_DWORD *)(a1 + 228) = 0;
    *(_DWORD *)(a1 + 232) = 0;
  }
  else if (*(int *)(v9 + 372) >= 1)
  {
    uint64_t v10 = 0;
    do
      *(_DWORD *)(a1 + 36 + 4 * v10++) = 0;
    while (v10 < *(int *)(v9 + 372));
  }
  return result;
}

uint64_t xf20toRGB16f<(ImageIOVectorLevel)0>::operator()(uint64_t a1, unsigned __int16 **a2, unsigned __int16 **a3, void *a4, __int16 *a5)
{
  unint64_t v5 = a4[1];
  uint64_t v6 = (__int16 *)&kDefaultXF20ToRGB16fConversion;
  if (a5) {
    uint64_t v6 = a5;
  }
  if (v5)
  {
    unint64_t v7 = 0;
    uint64_t v8 = a2[3];
    uint64_t v9 = a3[3];
    unint64_t v11 = a4[2];
    uint64_t v10 = a4[3];
    uint64_t v12 = (_WORD *)*a4;
    uint64_t v13 = *a3;
    uint64_t v15 = *a2;
    unint64_t v14 = (unint64_t)a2[1];
    do
    {
      if ((v7 | 1) >= v14) {
        uint64_t v16 = v15;
      }
      else {
        uint64_t v16 = (unsigned __int16 *)((char *)v15 + (void)v8);
      }
      uint64_t v17 = (_WORD *)((char *)v12 + v10);
      if ((v7 | 1) >= v5) {
        uint64_t v17 = v12;
      }
      if (v11 >= 2)
      {
        unint64_t v18 = 0;
        uint64_t v20 = v13;
        uint64_t v21 = v16;
        uint64_t v22 = v15;
        BOOL v19 = v12;
        do
        {
          _H7 = *v6;
          __asm { FCVT            S7, H7 }
          _H16 = v6[1];
          __asm { FCVT            S16, H16 }
          _H17 = v6[2];
          __asm { FCVT            S17, H17 }
          float v33 = (float)((float)(v20[1] >> 6) / 1023.0) - _S16;
          _S5 = (float)((float)(*v20 >> 6) / 1023.0) - _S17;
          LOWORD(_S16) = v6[3];
          __asm { FCVT            S16, H16 }
          LOWORD(_S17) = v6[4];
          __asm { FCVT            S17, H17 }
          float v37 = (float)((float)((float)(*v22 >> 6) / 1023.0) - _S7) * _S16;
          _S18 = v37 + (float)(v33 * _S17);
          _H19 = v6[6];
          __asm { FCVT            S19, H19 }
          _H20 = v6[5];
          __asm { FCVT            S20, H20 }
          float v43 = v37 + (float)(v33 * _S19);
          _H22 = v6[7];
          __asm { FCVT            S22, H22 }
          _S1 = v37 + (float)(_S5 * _S22);
          float v47 = (float)((float)((float)(v22[1] >> 6) / 1023.0) - _S7) * _S16;
          _S21 = v43 + (float)(_S5 * _S20);
          _S23 = v47 + (float)(v33 * _S17);
          float v50 = v47 + (float)(v33 * _S19);
          _S2 = v47 + (float)(_S5 * _S22);
          float v52 = (float)((float)((float)(*v21 >> 6) / 1023.0) - _S7) * _S16;
          _S24 = v50 + (float)(_S5 * _S20);
          _S25 = v52 + (float)(v33 * _S17);
          float v55 = v52 + (float)(v33 * _S19);
          _S3 = v52 + (float)(_S5 * _S22);
          _S4 = (float)((float)((float)(v21[1] >> 6) / 1023.0) - _S7) * _S16;
          _S7 = v55 + (float)(_S5 * _S20);
          _S16 = _S4 + (float)(v33 * _S17);
          _S6 = (float)(_S4 + (float)(v33 * _S19)) + (float)(_S5 * _S20);
          __asm
          {
            FCVT            H17, S25
            FCVT            H3, S3
          }
          _WORD *v17 = LOWORD(_S17);
          v17[2] = LOWORD(_S3);
          _S3 = _S4 + (float)(_S5 * _S22);
          __asm
          {
            FCVT            H4, S7
            FCVT            H5, S16
          }
          void v17[3] = LOWORD(_S5);
          v17[1] = LOWORD(_S4);
          __asm { FCVT            H4, S6 }
          v17[4] = LOWORD(_S4);
          __asm { FCVT            H3, S3 }
          v17[5] = LOWORD(_S3);
          __asm { FCVT            H3, S18 }
          v17 += 6;
          *BOOL v19 = LOWORD(_S3);
          __asm { FCVT            H3, S21 }
          v19[1] = LOWORD(_S3);
          __asm
          {
            FCVT            H1, S1
            FCVT            H3, S23
          }
          v19[2] = LOWORD(_S1);
          void v19[3] = LOWORD(_S3);
          __asm { FCVT            H1, S24 }
          _OWORD v19[4] = LOWORD(_S1);
          __asm { FCVT            H1, S2 }
          v19[5] = LOWORD(_S1);
          v19 += 6;
          unint64_t v62 = v18 + 4;
          v18 += 2;
          v22 += 2;
          v21 += 2;
          v20 += 2;
        }
        while (v62 <= v11);
      }
      else
      {
        unint64_t v18 = 0;
        BOOL v19 = v12;
      }
      if (v18 < v11)
      {
        _H5 = *v6;
        __asm { FCVT            S5, H5 }
        _H6 = v6[1];
        __asm { FCVT            S6, H6 }
        float v67 = (float)((float)(*(unsigned __int16 *)((char *)v13 + ((2 * v18) | 2)) >> 6) / 1023.0) - _S6;
        LOWORD(_S6) = v6[2];
        __asm { FCVT            S6, H6 }
        _S3 = (float)((float)(v13[v18] >> 6) / 1023.0) - _S6;
        LOWORD(_S6) = v6[3];
        __asm { FCVT            S6, H6 }
        float v71 = (float)((float)((float)(v15[v18] >> 6) / 1023.0) - _S5) * _S6;
        _H7 = v6[4];
        __asm { FCVT            S7, H7 }
        _S16 = v71 + (float)(v67 * _S7);
        _H17 = v6[6];
        __asm { FCVT            S17, H17 }
        _H19 = v6[5];
        __asm { FCVT            S19, H19 }
        _S18 = (float)(v71 + (float)(v67 * _S17)) + (float)(_S3 * _S19);
        _H20 = v6[7];
        __asm { FCVT            S20, H20 }
        _S1 = v71 + (float)(_S3 * _S20);
        float v83 = (float)((float)((float)(v16[v18] >> 6) / 1023.0) - _S5) * _S6;
        _S5 = v83 + (float)(v67 * _S7);
        _S4 = (float)(v83 + (float)(v67 * _S17)) + (float)(_S3 * _S19);
        _S2 = v83 + (float)(_S3 * _S20);
        __asm { FCVT            H3, S5 }
        _WORD *v17 = LOWORD(_S3);
        __asm { FCVT            H3, S4 }
        v17[1] = LOWORD(_S3);
        __asm { FCVT            H2, S2 }
        v17[2] = LOWORD(_S2);
        __asm { FCVT            H2, S16 }
        *BOOL v19 = LOWORD(_S2);
        __asm { FCVT            H2, S18 }
        v19[1] = LOWORD(_S2);
        __asm { FCVT            H1, S1 }
        v19[2] = LOWORD(_S1);
      }
      v15 += (uint64_t)v8;
      uint64_t v13 = (unsigned __int16 *)((char *)v13 + (void)v9);
      v12 += v10;
      v7 += 2;
    }
    while (v7 < v5);
  }
  return 0;
}

uint64_t xf20toRGBA1010102<(ImageIOVectorLevel)0>::operator()(uint64_t a1, unsigned __int16 **a2, unsigned __int16 **a3, unint64_t **a4, char *a5)
{
  unint64_t v10 = (unint64_t)a4[1];
  unint64_t v11 = (char *)&kDefaultXF20ToRGB16fConversion;
  if (a5) {
    unint64_t v11 = a5;
  }
  if (v10)
  {
    unint64_t v12 = 0;
    uint64_t v13 = a2[3];
    unint64_t v14 = a3[3];
    unint64_t v16 = (unint64_t)a4[2];
    uint64_t v15 = a4[3];
    uint64_t v17 = *a4;
    unint64_t v18 = *a3;
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x447FC000u);
    __asm { FMOV            V3.2S, #1.0 }
    uint64_t v26 = *a2;
    unint64_t v25 = (unint64_t)a2[1];
    do
    {
      if ((v12 | 1) >= v25) {
        uint64_t v27 = v26;
      }
      else {
        uint64_t v27 = (unsigned __int16 *)((char *)v26 + (void)v13);
      }
      unsigned int v28 = (unint64_t *)((char *)v17 + (void)v15);
      if ((v12 | 1) >= v10) {
        unsigned int v28 = v17;
      }
      if (v16 >= 2)
      {
        uint64_t v31 = 0;
        _D16.i16[0] = *(_WORD *)v11;
        __asm { FCVT            S20, H16 }
        _D16.i32[0] = *(_DWORD *)(v11 + 2);
        _D16 = (float16x4_t)vrev64_s32((int32x2_t)*(_OWORD *)&vcvtq_f32_f16(_D16));
        _H17 = *((_WORD *)v11 + 3);
        __asm { FCVT            S17, H17 }
        _H18 = *((_WORD *)v11 + 6);
        __asm { FCVT            S18, H18 }
        v9.i32[0] = *((_DWORD *)v11 + 2);
        _D19.i16[0] = *((_WORD *)v11 + 7);
        __asm { FCVT            S19, H19 }
        _D19 = (float16x4_t)vdup_lane_s32((int32x2_t)_D19, 0);
        _D20 = (float32x2_t)vdup_lane_s32((int32x2_t)_D20, 0);
        float16x4_t v9 = (float16x4_t)vcvtq_f32_f16(v9).u64[0];
        float32x2_t v36 = (float32x2_t)vrev64_s32((int32x2_t)v9);
        float v37 = v18;
        uint64_t v38 = v27;
        uint64_t v39 = v26;
        uint64_t v30 = v17;
        do
        {
          v40.i32[0] = *v39;
          v40.i32[1] = v39[1];
          v41.i32[0] = *v38;
          float32x2_t v42 = vdiv_f32(vcvt_f32_u32(vshr_n_u32(v40, 6uLL)), v19);
          v41.i32[1] = v38[1];
          v40.i32[0] = *v37;
          v40.i32[1] = v37[1];
          _D23 = vsub_f32(vdiv_f32(vcvt_f32_u32(vshr_n_u32(v40, 6uLL)), v19), (float32x2_t)_D16);
          float32x2_t v44 = vmul_n_f32(vsub_f32(vdiv_f32(vcvt_f32_u32(vshr_n_u32(v41, 6uLL)), v19), _D20), _S17);
          __asm { FMLA            S26, S18, V23.S[1] }
          float32x2_t v46 = (float32x2_t)__PAIR64__(v44.u32[1], _S26);
          __asm { FMLA            S26, S18, V23.S[1] }
          float32x2_t v48 = (float32x2_t)vrev64_s32((int32x2_t)_D23);
          _D29 = (float32x2_t)__PAIR64__(_S26, v44.u32[0]);
          float32x2_t v50 = vminnm_f32(vmla_f32(v46, v36, _D23), _D3);
          float32x2_t v51 = vminnm_f32(vmla_f32(_D29, (float32x2_t)v9, v48), _D3);
          float32x2_t v52 = vminnm_f32(vmla_n_f32(v44, (float32x2_t)_D19, _D23.f32[0]), _D3);
          float32x2_t v53 = vmul_n_f32(vsub_f32(v42, _D20), _S17);
          __asm { FMLA            S29, S18, V23.S[1] }
          float32x2_t v54 = (float32x2_t)__PAIR64__(v53.u32[1], _D29.u32[0]);
          __asm { FMLA            S29, S18, V23.S[1] }
          float32x2_t v55 = (float32x2_t)__PAIR64__(_D29.u32[0], v53.u32[0]);
          float32x2_t v56 = vmla_n_f32(v53, (float32x2_t)_D19, _D23.f32[0]);
          float32x2_t v57 = vminnm_f32(vmla_f32(v54, v36, _D23), _D3);
          float32x2_t v58 = vminnm_f32(vmla_f32(v55, (float32x2_t)v9, v48), _D3);
          float32x2_t v59 = vminnm_f32(v56, _D3);
          *v28++ = *(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32(vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v50, v19), (int8x8_t)vcgtz_f32(v50)))), (uint32x2_t)0x140000000ALL), (int8x8_t)vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v52, v19), (int8x8_t)vcgtz_f32(v52))))), (int8x8_t)vshl_u32(vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v51, v19), (int8x8_t)vcgtz_f32(v51)))), (uint32x2_t)0xA00000014)) | 0xC0000000C0000000;
          *v30++ = *(void *)&vorr_s8(vorr_s8((int8x8_t)vshl_u32(vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v57, v19), (int8x8_t)vcgtz_f32(v57)))), (uint32x2_t)0x140000000ALL), (int8x8_t)vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v59, v19), (int8x8_t)vcgtz_f32(v59))))), (int8x8_t)vshl_u32(vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v58, v19), (int8x8_t)vcgtz_f32(v58)))), (uint32x2_t)0xA00000014)) | 0xC0000000C0000000;
          unint64_t v29 = v31 + 2;
          unint64_t v60 = v31 + 4;
          v39 += 2;
          v38 += 2;
          v37 += 2;
          v31 += 2;
        }
        while (v60 <= v16);
      }
      else
      {
        unint64_t v29 = 0;
        uint64_t v30 = v17;
      }
      if (v29 < v16)
      {
        _D18.i16[0] = *(_WORD *)v11;
        __asm { FCVT            S18, H18 }
        _D19.i16[0] = *((_WORD *)v11 + 3);
        __asm { FCVT            S19, H19 }
        v61.f32[0] = (float)((float)((float)(v26[v29] >> 6) / 1023.0) - _D18.f32[0]) * *(float *)_D19.i32;
        _H20 = *((_WORD *)v11 + 6);
        __asm { FCVT            S20, H20 }
        _H21 = *((_WORD *)v11 + 7);
        __asm { FCVT            S21, H21 }
        float v66 = (float)((float)((float)(v27[v29] >> 6) / 1023.0) - _D18.f32[0]) * *(float *)_D19.i32;
        _D18.i16[0] = *(unsigned __int16 *)((char *)v18 + ((2 * v29) | 2));
        _D18.i16[2] = v18[v29];
        _D19.i32[0] = *(_DWORD *)(v11 + 2);
        float16x4_t v67 = (float16x4_t)vcvtq_f32_f16(_D19).u64[0];
        _D18 = vsub_f32(vdiv_f32(vcvt_f32_u32(vshr_n_u32((uint32x2_t)vand_s8((int8x8_t)_D18, (int8x8_t)0xFFFF0000FFFFLL), 6uLL)), v19), (float32x2_t)v67);
        v67.i32[0] = *((_DWORD *)v11 + 2);
        _D19 = (float16x4_t)vcvtq_f32_f16(v67).u64[0];
        float v68 = vmlas_n_f32(v61.f32[0], _S20, _D18.f32[0]);
        float32x2_t v69 = (float32x2_t)__PAIR64__(COERCE_UNSIGNED_INT(vmlas_n_f32(v66, _S20, _D18.f32[0])), LODWORD(v66));
        __asm { FMLA            S17, S21, V18.S[1] }
        float32x2_t v71 = vminnm_f32(vmla_f32(v69, (float32x2_t)_D19, _D18), _D3);
        float v72 = fminf(_S17, 1.0);
        uint32x2_t v73 = vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v71, v19), (int8x8_t)vcgtz_f32(v71))));
        if (v72 <= 0.0) {
          float v74 = 0.0;
        }
        else {
          float v74 = v72 * 1023.0;
        }
        unsigned int v75 = rintf(v74);
        int32x2_t v76 = (int32x2_t)vshl_u32(v73, (uint32x2_t)0xA00000014);
        _D20 = (float32x2_t)vdup_lane_s32(v76, 1);
        __asm { FMLA            S23, S21, V18.S[1] }
        unsigned __int32 v78 = vorr_s8((int8x8_t)v76, (int8x8_t)_D20).u32[0] | v75 | 0xC0000000;
        float v79 = fminf(_S23, 1.0);
        if (v79 <= 0.0) {
          float v80 = 0.0;
        }
        else {
          float v80 = v79 * 1023.0;
        }
        v61.f32[1] = v68;
        float32x2_t v81 = vminnm_f32(vmla_f32(v61, (float32x2_t)_D19, _D18), _D3);
        int32x2_t v82 = (int32x2_t)vshl_u32(vcvt_u32_f32(vrndx_f32((float32x2_t)vand_s8((int8x8_t)vmul_f32(v81, v19), (int8x8_t)vcgtz_f32(v81)))), (uint32x2_t)0xA00000014);
        *(_DWORD *)unsigned int v28 = v78;
        _D16 = (float16x4_t)vorr_s8((int8x8_t)v82, (int8x8_t)vdup_lane_s32(v82, 1));
        *(_DWORD *)uint64_t v30 = _D16.i32[0] | rintf(v80) | 0xC0000000;
      }
      v26 += (uint64_t)v13;
      unint64_t v18 = (unsigned __int16 *)((char *)v18 + (void)v14);
      uint64_t v17 = (unint64_t *)((char *)v17 + 2 * (void)v15);
      v12 += 2;
    }
    while (v12 < v10);
  }
  return 0;
}

uint64_t ConvertXF20toRGB16f(unsigned __int16 **a1, unsigned __int16 **a2, void *a3, __int16 *a4)
{
  uint64_t VectorLevel = ImageIOSIMD_GetVectorLevel();
  if (VectorLevel) {
    return xf20toRGB16f<(ImageIOVectorLevel)1>::operator()((uint64_t)&v10, (uint64_t)a1, (uint64_t)a2, (uint64_t)a3, a4);
  }
  xf20toRGB16f<(ImageIOVectorLevel)0>::operator()(VectorLevel, a1, a2, a3, a4);
  return 0;
}

uint64_t ConvertXF20toRGBA1010102(unsigned __int16 **a1, unsigned __int16 **a2, unint64_t **a3, __int16 *a4)
{
  uint64_t VectorLevel = ImageIOSIMD_GetVectorLevel();
  if (VectorLevel) {
    return xf20toRGBA1010102<(ImageIOVectorLevel)1>::operator()((uint64_t)&v10, (uint64_t)a1, (uint64_t)a2, (uint64_t)a3, a4);
  }
  xf20toRGBA1010102<(ImageIOVectorLevel)0>::operator()(VectorLevel, a1, a2, a3, (char *)a4);
  return 0;
}

void *GetXF20toRGB16fConversionInfo(int a1, int a2)
{
  int v2 = &kDefaultXF20ToRGB16fConversion;
  if (a2) {
    int v2 = &kXF20ToRGB16fConversion_Rec601_VideoRange;
  }
  uint64_t v3 = &kXF20ToRGB16fConversion_Rec2020_FullRange;
  if (a2) {
    uint64_t v3 = &kXF20ToRGB16fConversion_Rec2020_VideoRange;
  }
  int v4 = &kXF20ToRGB16fConversion_Rec709_FullRange;
  if (a2) {
    int v4 = &kXF20ToRGB16fConversion_Rec709_VideoRange;
  }
  if (a1 != 1) {
    int v4 = 0;
  }
  if ((a1 - 9) >= 2) {
    unint64_t v5 = v4;
  }
  else {
    unint64_t v5 = v3;
  }
  if ((a1 - 5) >= 2) {
    return v5;
  }
  else {
    return v2;
  }
}

uint64_t xf20toRGB16f<(ImageIOVectorLevel)1>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int16 *a5)
{
  uint64_t v116 = *MEMORY[0x1E4F143B8];
  long long v111 = 0uLL;
  VEC::xf20Constants::xf20Constants((uint64_t)&v111, a5);
  uint64_t v8 = *(uint16x8_t **)a2;
  float16x4_t v9 = *(uint16x8_t **)a3;
  unint64_t v11 = *(int8x16_t **)a4;
  unint64_t v10 = *(void *)(a4 + 8);
  unint64_t v12 = *(void *)(a4 + 16);
  v13.i32[1] = *(_DWORD *)((char *)&v111 + 10);
  float16x8_t v14 = (float16x8_t)vdupq_lane_s16(*(int16x4_t *)((char *)&v111 + 6), 2);
  int16x8_t v15 = vdupq_lane_s16(*(int16x4_t *)((char *)&v111 + 6), 3);
  float16x8_t v16 = (float16x8_t)vdupq_lane_s32(*(int32x2_t *)((char *)&v111 + 6), 0);
  float16x8_t v17 = (float16x8_t)vrev32q_s16((int16x8_t)v16);
  v15.i16[1] = WORD1(v111);
  float16x8_t v18 = (float16x8_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 0);
  v13.i16[0] = HIWORD(v111);
  v13.i16[1] = WORD2(v111);
  float16x8_t v19 = (float16x8_t)vdupq_lane_s32(v13, 0);
  char v90 = v10;
  if (v10 >= 2)
  {
    uint64_t v20 = 0;
    uint64_t v93 = *(void *)(a3 + 24);
    uint64_t v94 = *(void *)(a2 + 24);
    unint64_t v91 = v10 >> 1;
    uint64_t v92 = *(void *)(a4 + 24);
    float16x8_t v21 = (float16x8_t)vdupq_n_s16(0x1401u);
    float16x8_t v22 = (float16x8_t)vdupq_n_s16(0xBC01u);
    int8x16_t v23 = (int8x16_t)xmmword_18898C740;
    int8x16_t v24 = (int8x16_t)xmmword_18898C750;
    int8x16_t v25 = (int8x16_t)xmmword_18898C760;
    float16x8_t v102 = v16;
    float16x8_t v104 = v14;
    float16x8_t v98 = v17;
    float16x8_t v100 = v18;
    float16x8_t v96 = v19;
    float16x8_t v106 = v22;
    float16x8_t v107 = v21;
    do
    {
      uint64_t v26 = (uint16x8_t *)((char *)v8 + v94);
      uint64_t v27 = (int8x16_t *)((char *)v11 + v92);
      if (v12 >= 8)
      {
        uint64_t v28 = 0;
        uint64_t v31 = v8;
        uint64_t v30 = v9;
        unint64_t v29 = v11;
        do
        {
          uint16x8_t v32 = *v31++;
          unsigned long long v33 = *(_OWORD *)&vshrq_n_u16(v32, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400);
          uint16x8_t v34 = *v26++;
          float16x8_t v35 = vmlaq_f16(v22, v21, (float16x8_t)v33);
          unsigned long long v36 = *(_OWORD *)&vshrq_n_u16(v34, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400);
          uint16x8_t v37 = *v30++;
          float16x8_t v38 = vmlaq_f16(v22, v21, (float16x8_t)v36);
          float16x8_t v39 = vmlaq_f16(v22, v21, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(v37, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
          float16x8_t v40 = vmlaq_f16(vmlaq_f16(v14, (float16x8_t)vrev32q_s16((int16x8_t)v39), v17), v39, v16);
          int16x8_t v41 = (int16x8_t)vmlaq_f16(v19, v39, v18);
          float16x8_t v42 = (float16x8_t)vtrn2q_s16(v41, v41);
          float16x8_t v43 = (float16x8_t)vtrn1q_s16(v41, v41);
          int16x8_t v44 = (int16x8_t)vmlaq_n_f16(v42, v35, *(short float *)&v111);
          int16x8_t v45 = (int16x8_t)vmlaq_n_f16(v42, v38, *(short float *)&v111);
          int16x8_t v46 = (int16x8_t)vmlaq_n_f16(v40, v35, *(short float *)&v111);
          int16x8_t v47 = (int16x8_t)vmlaq_n_f16(v40, v38, *(short float *)&v111);
          v124.val[1] = (int8x16_t)vmlaq_n_f16(v43, v35, *(short float *)&v111);
          v121.val[1] = (int8x16_t)vmlaq_n_f16(v43, v38, *(short float *)&v111);
          v117.val[0] = (int8x16_t)vzip2q_s16(v44, v46);
          v124.val[0] = (int8x16_t)vzip1q_s16(v44, v46);
          int8x16_t v48 = vqtbl2q_s8(v124, v23);
          v117.val[1] = v124.val[1];
          v124.val[0] = vextq_s8(v124.val[0], v117.val[0], 0xCuLL);
          int8x16_t *v29 = v48;
          v29[1] = vqtbl2q_s8(v124, v25);
          v29[2] = vqtbl2q_s8(v117, v24);
          v29 += 3;
          v117.val[0] = (int8x16_t)vzip2q_s16(v45, v47);
          v121.val[0] = (int8x16_t)vzip1q_s16(v45, v47);
          int8x16_t v49 = vqtbl2q_s8(v121, v23);
          v117.val[1] = v121.val[1];
          v121.val[0] = vextq_s8(v121.val[0], v117.val[0], 0xCuLL);
          int8x16_t *v27 = v49;
          v27[1] = vqtbl2q_s8(v121, v25);
          v27[2] = vqtbl2q_s8(v117, v24);
          v27 += 3;
          unint64_t v50 = v28 + 16;
          v28 += 8;
        }
        while (v50 <= v12);
      }
      else
      {
        uint64_t v28 = 0;
        unint64_t v29 = v11;
        uint64_t v30 = v9;
        uint64_t v31 = v8;
      }
      if ((v12 & 7) != 0)
      {
        uint64_t v95 = v12 - v28;
        uint16x8_t v109 = 0u;
        uint16x8_t __dst = 0u;
        uint16x8_t v108 = 0u;
        size_t v51 = 2 * (v12 - v28);
        memcpy(&__dst, v31, v51);
        memcpy(&v109, v26, v51);
        memcpy(&v108, v30, (v51 + 2) & 0xFFFFFFFFFFFFFFFCLL);
        float16x8_t v52 = vmlaq_f16(v106, v107, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(__dst, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
        float16x8_t v53 = vmlaq_f16(v106, v107, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(v109, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
        float16x8_t v54 = vmlaq_f16(v106, v107, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(v108, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
        float16x8_t v55 = vmlaq_f16(vmlaq_f16(v104, (float16x8_t)vrev32q_s16((int16x8_t)v54), v98), v54, v102);
        int16x8_t v56 = (int16x8_t)vmlaq_f16(v96, v54, v100);
        float16x8_t v57 = (float16x8_t)vtrn2q_s16(v56, v56);
        float16x8_t v58 = (float16x8_t)vtrn1q_s16(v56, v56);
        int16x8_t v59 = (int16x8_t)vmlaq_n_f16(v57, v52, *(short float *)&v111);
        int16x8_t v60 = (int16x8_t)vmlaq_n_f16(v57, v53, *(short float *)&v111);
        int16x8_t v61 = (int16x8_t)vmlaq_n_f16(v55, v52, *(short float *)&v111);
        int16x8_t v62 = (int16x8_t)vmlaq_n_f16(v55, v53, *(short float *)&v111);
        v125.val[1] = (int8x16_t)vmlaq_n_f16(v58, v52, *(short float *)&v111);
        v122.val[1] = (int8x16_t)vmlaq_n_f16(v58, v53, *(short float *)&v111);
        v118.val[0] = (int8x16_t)vzip2q_s16(v59, v61);
        v125.val[0] = (int8x16_t)vzip1q_s16(v59, v61);
        int8x16_t v63 = vqtbl2q_s8(v125, (int8x16_t)xmmword_18898C740);
        v118.val[1] = v125.val[1];
        int8x16_t v64 = vqtbl2q_s8(v118, (int8x16_t)xmmword_18898C750);
        v125.val[0] = vextq_s8(v125.val[0], v118.val[0], 0xCuLL);
        int8x16_t __src = v63;
        int8x16_t v113 = vqtbl2q_s8(v125, (int8x16_t)xmmword_18898C760);
        v118.val[0] = (int8x16_t)vzip2q_s16(v60, v62);
        v122.val[0] = (int8x16_t)vzip1q_s16(v60, v62);
        int8x16_t v65 = vqtbl2q_s8(v122, (int8x16_t)xmmword_18898C740);
        v118.val[1] = v122.val[1];
        v122.val[0] = vextq_s8(v122.val[0], v118.val[0], 0xCuLL);
        int8x16_t v114 = v64;
        v115[0] = v65;
        v115[1] = vqtbl2q_s8(v122, (int8x16_t)xmmword_18898C760);
        v115[2] = vqtbl2q_s8(v118, (int8x16_t)xmmword_18898C750);
        memcpy(v29, &__src, 6 * v95);
        memcpy(v27, v115, 6 * v95);
        int8x16_t v25 = (int8x16_t)xmmword_18898C760;
        int8x16_t v24 = (int8x16_t)xmmword_18898C750;
        int8x16_t v23 = (int8x16_t)xmmword_18898C740;
        float16x8_t v22 = v106;
        float16x8_t v21 = v107;
        float16x8_t v19 = v96;
        float16x8_t v17 = v98;
        float16x8_t v18 = v100;
        float16x8_t v16 = v102;
        float16x8_t v14 = v104;
      }
      uint64_t v8 = (uint16x8_t *)((char *)v8 + 2 * v94);
      float16x4_t v9 = (uint16x8_t *)((char *)v9 + v93);
      unint64_t v11 = (int8x16_t *)((char *)v11 + 2 * v92);
      ++v20;
    }
    while (v20 != v91);
  }
  if (v90)
  {
    if (v12 >= 8)
    {
      uint64_t v66 = 0;
      float16x8_t v67 = (float16x8_t)vdupq_n_s16(0x1401u);
      float16x8_t v68 = (float16x8_t)vdupq_n_s16(0xBC01u);
      do
      {
        uint16x8_t v69 = *v8++;
        float16x8_t v70 = vmlaq_f16(v68, v67, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(v69, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
        uint16x8_t v71 = *v9++;
        float16x8_t v72 = vmlaq_f16(v68, v67, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(v71, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
        float16x8_t v73 = vmlaq_f16(vmlaq_f16(v14, (float16x8_t)vrev32q_s16((int16x8_t)v72), v17), v72, v16);
        int16x8_t v74 = (int16x8_t)vmlaq_f16(v19, v72, v18);
        int16x8_t v75 = (int16x8_t)vmlaq_n_f16((float16x8_t)vtrn2q_s16(v74, v74), v70, *(short float *)&v111);
        int16x8_t v76 = (int16x8_t)vmlaq_n_f16(v73, v70, *(short float *)&v111);
        v126.val[1] = (int8x16_t)vmlaq_n_f16((float16x8_t)vtrn1q_s16(v74, v74), v70, *(short float *)&v111);
        v123.val[0] = (int8x16_t)vzip2q_s16(v75, v76);
        v126.val[0] = (int8x16_t)vzip1q_s16(v75, v76);
        int8x16_t v77 = vqtbl2q_s8(v126, (int8x16_t)xmmword_18898C740);
        v123.val[1] = v126.val[1];
        v126.val[0] = vextq_s8(v126.val[0], v123.val[0], 0xCuLL);
        *unint64_t v11 = v77;
        v11[1] = vqtbl2q_s8(v126, (int8x16_t)xmmword_18898C760);
        v11[2] = vqtbl2q_s8(v123, (int8x16_t)xmmword_18898C750);
        v11 += 3;
        unint64_t v78 = v66 + 16;
        v66 += 8;
      }
      while (v78 <= v12);
    }
    else
    {
      uint64_t v66 = 0;
    }
    if ((v12 & 7) != 0)
    {
      uint64_t v79 = v12 - v66;
      uint16x8_t v109 = 0u;
      uint16x8_t __dst = 0u;
      size_t v80 = 2 * (v12 - v66);
      float16x8_t v103 = v16;
      float16x8_t v105 = v14;
      float16x8_t v99 = v17;
      float16x8_t v101 = v18;
      float16x8_t v97 = v19;
      memcpy(&__dst, v8, v80);
      memcpy(&v109, v9, (v80 + 2) & 0xFFFFFFFFFFFFFFFCLL);
      float16x8_t v81 = (float16x8_t)vdupq_n_s16(0x1401u);
      float16x8_t v82 = (float16x8_t)vdupq_n_s16(0xBC01u);
      float16x8_t v83 = vmlaq_f16(v82, v81, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(__dst, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
      float16x8_t v84 = vmlaq_f16(v82, v81, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(v109, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
      int16x8_t v85 = (int16x8_t)vmlaq_f16(v97, v84, v101);
      int16x8_t v86 = (int16x8_t)vmlaq_n_f16((float16x8_t)vtrn2q_s16(v85, v85), v83, *(short float *)&v111);
      int16x8_t v87 = (int16x8_t)vmlaq_n_f16(vmlaq_f16(vmlaq_f16(v105, (float16x8_t)vrev32q_s16((int16x8_t)v84), v99), v84, v103), v83, *(short float *)&v111);
      v119.val[1] = (int8x16_t)vmlaq_n_f16((float16x8_t)vtrn1q_s16(v85, v85), v83, *(short float *)&v111);
      v120.val[0] = (int8x16_t)vzip2q_s16(v86, v87);
      v119.val[0] = (int8x16_t)vzip1q_s16(v86, v87);
      int8x16_t v88 = vqtbl2q_s8(v119, (int8x16_t)xmmword_18898C740);
      v120.val[1] = v119.val[1];
      v119.val[0] = vextq_s8(v119.val[0], v120.val[0], 0xCuLL);
      int8x16_t __src = v88;
      int8x16_t v113 = vqtbl2q_s8(v119, (int8x16_t)xmmword_18898C760);
      int8x16_t v114 = vqtbl2q_s8(v120, (int8x16_t)xmmword_18898C750);
      memcpy(v11, &__src, 6 * v79);
    }
  }
  return 0;
}

uint64_t xf20toRGBA1010102<(ImageIOVectorLevel)1>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __int16 *a5)
{
  *(_OWORD *)float32x4_t v134 = 0uLL;
  VEC::xf20Constants::xf20Constants((uint64_t)v134, a5);
  uint64_t v8 = *(uint16x8_t **)a2;
  float16x4_t v9 = *(uint16x8_t **)a3;
  unint64_t v11 = *(int32x4_t **)a4;
  unint64_t v10 = *(void *)(a4 + 8);
  unint64_t v12 = *(void *)(a4 + 16);
  v13.i32[1] = *(_DWORD *)&v134[5];
  float16x8_t v14 = (float16x8_t)vdupq_lane_s16(*(int16x4_t *)&v134[3], 2);
  int16x8_t v15 = vdupq_lane_s16(*(int16x4_t *)&v134[3], 3);
  float16x8_t v16 = (float16x8_t)vdupq_lane_s32(*(int32x2_t *)&v134[3], 0);
  float16x8_t v17 = (float16x8_t)vrev32q_s16((int16x8_t)v16);
  *(short float *)&v15.i16[1] = v134[1];
  float16x8_t v18 = (float16x8_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 0);
  *(short float *)v13.i16 = v134[7];
  *(short float *)&v13.i16[1] = v134[2];
  float16x8_t v19 = (float16x8_t)vdupq_lane_s32(v13, 0);
  if (v10 >= 2)
  {
    uint64_t v20 = 0;
    uint64_t v112 = *(void *)(a3 + 24);
    uint64_t v113 = *(void *)(a2 + 24);
    unint64_t v110 = v10 >> 1;
    uint64_t v111 = *(void *)(a4 + 24);
    float16x8_t v21 = (float16x8_t)vdupq_n_s16(0x1401u);
    float16x8_t v22 = (float16x8_t)vdupq_n_s16(0xBC01u);
    float16x8_t v23 = (float16x8_t)vdupq_n_s16(0x63FEu);
    uint64_t v109 = *(void *)(a4 + 8);
    v24.i64[0] = 0x3C003C003C003C00;
    v24.i64[1] = 0x3C003C003C003C00;
    v25.i64[0] = 0x300000003;
    v25.i64[1] = 0x300000003;
    float16x8_t v121 = v16;
    float16x8_t v123 = v14;
    float16x8_t v117 = v17;
    float16x8_t v119 = v18;
    float16x8_t v115 = v19;
    float16x8_t v125 = v22;
    float16x8_t v126 = v21;
    float16x8_t v127 = v23;
    do
    {
      uint64_t v26 = (uint16x8_t *)((char *)v8 + v113);
      uint64_t v27 = (int32x4_t *)((char *)v11 + v111);
      if (v12 >= 8)
      {
        uint64_t v32 = 0;
        short float v33 = v134[0];
        uint64_t v31 = v8;
        uint64_t v30 = v9;
        unint64_t v29 = v11;
        do
        {
          uint16x8_t v34 = *v31++;
          float16x8_t v35 = vmlaq_f16(v22, v21, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(v34, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
          uint16x8_t v36 = *v26++;
          float16x8_t v37 = vmlaq_f16(v22, v21, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(v36, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
          uint16x8_t v38 = *v30++;
          float16x8_t v39 = vmlaq_f16(v22, v21, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(v38, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
          float16x8_t v40 = vmlaq_f16(vmlaq_f16(v14, (float16x8_t)vrev32q_s16((int16x8_t)v39), v17), v39, v16);
          int16x8_t v41 = (int16x8_t)vmlaq_f16(v19, v39, v18);
          float16x8_t v42 = (float16x8_t)vtrn2q_s16(v41, v41);
          float16x8_t v43 = (float16x8_t)vtrn1q_s16(v41, v41);
          float16x8_t v44 = vmlaq_n_f16(v40, v35, v33);
          float16x8_t v45 = vmlaq_n_f16(v43, v35, v33);
          uint16x8_t v46 = vcvtnq_u16_f16(vmulq_f16(vminq_f16(vmlaq_n_f16(v42, v35, v33), v24), v23));
          uint16x8_t v47 = vcvtnq_u16_f16(vmulq_f16(vminq_f16(v44, v24), v23));
          uint16x8_t v48 = vcvtnq_u16_f16(vmulq_f16(vminq_f16(v45, v24), v23));
          int32x4_t *v29 = vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v48.i8), vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v47.i8), vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v46.i8), v25, 0xAuLL), 0xAuLL), 0xAuLL);
          v29[1] = vsliq_n_s32((int32x4_t)vmovl_high_u16(v48), vsliq_n_s32((int32x4_t)vmovl_high_u16(v47), vsliq_n_s32((int32x4_t)vmovl_high_u16(v46), v25, 0xAuLL), 0xAuLL), 0xAuLL);
          v29 += 2;
          uint16x8_t v49 = vcvtnq_u16_f16(vmulq_f16(vminq_f16(vmlaq_n_f16(v42, v37, v33), v24), v23));
          uint16x8_t v50 = vcvtnq_u16_f16(vmulq_f16(vminq_f16(vmlaq_n_f16(v40, v37, v33), v24), v23));
          uint16x8_t v51 = vcvtnq_u16_f16(vmulq_f16(vminq_f16(vmlaq_n_f16(v43, v37, v33), v24), v23));
          int32x4_t *v27 = vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v51.i8), vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v50.i8), vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v49.i8), v25, 0xAuLL), 0xAuLL), 0xAuLL);
          v27[1] = vsliq_n_s32((int32x4_t)vmovl_high_u16(v51), vsliq_n_s32((int32x4_t)vmovl_high_u16(v50), vsliq_n_s32((int32x4_t)vmovl_high_u16(v49), v25, 0xAuLL), 0xAuLL), 0xAuLL);
          v27 += 2;
          uint64_t v28 = v32 + 8;
          unint64_t v52 = v32 + 16;
          v32 += 8;
        }
        while (v52 <= v12);
      }
      else
      {
        uint64_t v28 = 0;
        unint64_t v29 = v11;
        uint64_t v30 = v9;
        uint64_t v31 = v8;
      }
      if ((v12 & 7) != 0)
      {
        uint64_t v114 = v12 - v28;
        uint16x8_t v132 = 0u;
        uint16x8_t __dst = 0u;
        uint16x8_t v131 = 0u;
        size_t v53 = 2 * (v12 - v28);
        memcpy(&__dst, v31, v53);
        memcpy(&v132, v26, v53);
        memcpy(&v131, v30, (v53 + 2) & 0xFFFFFFFFFFFFFFFCLL);
        float16x8_t v54 = vmlaq_f16(v125, v126, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(__dst, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
        float16x8_t v55 = vmlaq_f16(v125, v126, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(v132, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
        float16x8_t v56 = vmlaq_f16(v125, v126, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(v131, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
        float16x8_t v57 = vmlaq_f16(vmlaq_f16(v123, (float16x8_t)vrev32q_s16((int16x8_t)v56), v117), v56, v121);
        int16x8_t v58 = (int16x8_t)vmlaq_f16(v115, v56, v119);
        float16x8_t v59 = (float16x8_t)vtrn2q_s16(v58, v58);
        float16x8_t v60 = (float16x8_t)vtrn1q_s16(v58, v58);
        float16x8_t v61 = vmlaq_n_f16(v59, v54, v134[0]);
        float16x8_t v62 = vmlaq_n_f16(v57, v54, v134[0]);
        float16x8_t v63 = vmlaq_n_f16(v60, v54, v134[0]);
        v54.i64[0] = 0x3C003C003C003C00;
        v54.i64[1] = 0x3C003C003C003C00;
        float16x8_t v64 = (float16x8_t)vcvtnq_u16_f16(vmulq_f16(vminq_f16(v61, v54), v127));
        v65.i64[0] = 0x3C003C003C003C00;
        v65.i64[1] = 0x3C003C003C003C00;
        float16x8_t v66 = (float16x8_t)vcvtnq_u16_f16(vmulq_f16(vminq_f16(v62, v65), v127));
        v62.i64[0] = 0x3C003C003C003C00;
        v62.i64[1] = 0x3C003C003C003C00;
        uint16x8_t v67 = vcvtnq_u16_f16(vmulq_f16(vminq_f16(v63, v62), v127));
        v68.i64[0] = 0x300000003;
        v68.i64[1] = 0x300000003;
        int32x4_t __src = vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v67.i8), vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v66.i8), vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v64.i8), v68, 0xAuLL), 0xAuLL), 0xAuLL);
        int32x4_t v130 = vsliq_n_s32((int32x4_t)vmovl_high_u16(v67), vsliq_n_s32((int32x4_t)vmovl_high_u16((uint16x8_t)v66), vsliq_n_s32((int32x4_t)vmovl_high_u16((uint16x8_t)v64), v68, 0xAuLL), 0xAuLL), 0xAuLL);
        v64.i64[0] = 0x3C003C003C003C00;
        v64.i64[1] = 0x3C003C003C003C00;
        uint16x8_t v69 = vcvtnq_u16_f16(vmulq_f16(vminq_f16(vmlaq_n_f16(v59, v55, v134[0]), v64), v127));
        v59.i64[0] = 0x3C003C003C003C00;
        v59.i64[1] = 0x3C003C003C003C00;
        uint16x8_t v70 = vcvtnq_u16_f16(vmulq_f16(vminq_f16(vmlaq_n_f16(v57, v55, v134[0]), v59), v127));
        v66.i64[0] = 0x3C003C003C003C00;
        v66.i64[1] = 0x3C003C003C003C00;
        uint16x8_t v71 = vcvtnq_u16_f16(vmulq_f16(vminq_f16(vmlaq_n_f16(v60, v55, v134[0]), v66), v127));
        v61.i64[0] = 0x300000003;
        v61.i64[1] = 0x300000003;
        v128[0] = (uint16x8_t)vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v71.i8), vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v70.i8), vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v69.i8), (int32x4_t)v61, 0xAuLL), 0xAuLL), 0xAuLL);
        v128[1] = (uint16x8_t)vsliq_n_s32((int32x4_t)vmovl_high_u16(v71), vsliq_n_s32((int32x4_t)vmovl_high_u16(v70), vsliq_n_s32((int32x4_t)vmovl_high_u16(v69), (int32x4_t)v61, 0xAuLL), 0xAuLL), 0xAuLL);
        memcpy(v29, &__src, 4 * v114);
        memcpy(v27, v128, 4 * v114);
        v25.i64[0] = 0x300000003;
        v25.i64[1] = 0x300000003;
        v24.i64[0] = 0x3C003C003C003C00;
        v24.i64[1] = 0x3C003C003C003C00;
        float16x8_t v21 = v126;
        float16x8_t v23 = v127;
        float16x8_t v14 = v123;
        float16x8_t v22 = v125;
        LOBYTE(v10) = v109;
        float16x8_t v19 = v115;
        float16x8_t v17 = v117;
        float16x8_t v18 = v119;
        float16x8_t v16 = v121;
      }
      uint64_t v8 = (uint16x8_t *)((char *)v8 + 2 * v113);
      float16x4_t v9 = (uint16x8_t *)((char *)v9 + v112);
      unint64_t v11 = (int32x4_t *)((char *)v11 + 2 * v111);
      ++v20;
    }
    while (v20 != v110);
  }
  if (v10)
  {
    if (v12 >= 8)
    {
      uint64_t v73 = 0;
      float16x8_t v74 = (float16x8_t)vdupq_n_s16(0x1401u);
      float16x8_t v75 = (float16x8_t)vdupq_n_s16(0xBC01u);
      short float v76 = v134[0];
      v77.i64[0] = 0x3C003C003C003C00;
      v77.i64[1] = 0x3C003C003C003C00;
      float16x8_t v78 = (float16x8_t)vdupq_n_s16(0x63FEu);
      v79.i64[0] = 0x300000003;
      v79.i64[1] = 0x300000003;
      do
      {
        uint16x8_t v80 = *v8++;
        float16x8_t v81 = vmlaq_f16(v75, v74, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(v80, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
        uint16x8_t v82 = *v9++;
        float16x8_t v83 = vmlaq_f16(v75, v74, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(v82, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
        float16x8_t v84 = vmlaq_f16(vmlaq_f16(v14, (float16x8_t)vrev32q_s16((int16x8_t)v83), v17), v83, v16);
        int16x8_t v85 = (int16x8_t)vmlaq_f16(v19, v83, v18);
        float16x8_t v86 = (float16x8_t)vtrn2q_s16(v85, v85);
        float16x8_t v87 = vmlaq_n_f16(v84, v81, v76);
        float16x8_t v88 = vmlaq_n_f16((float16x8_t)vtrn1q_s16(v85, v85), v81, v76);
        uint16x8_t v89 = vcvtnq_u16_f16(vmulq_f16(vminq_f16(vmlaq_n_f16(v86, v81, v76), v77), v78));
        uint16x8_t v90 = vcvtnq_u16_f16(vmulq_f16(vminq_f16(v87, v77), v78));
        uint16x8_t v91 = vcvtnq_u16_f16(vmulq_f16(vminq_f16(v88, v77), v78));
        *unint64_t v11 = vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v91.i8), vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v90.i8), vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v89.i8), v79, 0xAuLL), 0xAuLL), 0xAuLL);
        v11[1] = vsliq_n_s32((int32x4_t)vmovl_high_u16(v91), vsliq_n_s32((int32x4_t)vmovl_high_u16(v90), vsliq_n_s32((int32x4_t)vmovl_high_u16(v89), v79, 0xAuLL), 0xAuLL), 0xAuLL);
        v11 += 2;
        uint64_t v72 = v73 + 8;
        unint64_t v92 = v73 + 16;
        v73 += 8;
      }
      while (v92 <= v12);
    }
    else
    {
      uint64_t v72 = 0;
    }
    if ((v12 & 7) != 0)
    {
      uint64_t v93 = v12 - v72;
      v128[0] = 0u;
      uint16x8_t __dst = 0u;
      size_t v94 = 2 * (v12 - v72);
      float16x8_t v122 = v16;
      float16x8_t v124 = v14;
      float16x8_t v118 = v17;
      float16x8_t v120 = v18;
      float16x8_t v116 = v19;
      memcpy(v128, v8, v94);
      memcpy(&__dst, v9, (v94 + 2) & 0xFFFFFFFFFFFFFFFCLL);
      float16x8_t v95 = (float16x8_t)vdupq_n_s16(0x1401u);
      float16x8_t v96 = (float16x8_t)vdupq_n_s16(0xBC01u);
      float16x8_t v97 = vmlaq_f16(v96, v95, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(v128[0], 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
      float16x8_t v98 = vmlaq_f16(v96, v95, (float16x8_t)(*(_OWORD *)&vshrq_n_u16(__dst, 6uLL) | __PAIR128__(0x6400640064006400, 0x6400640064006400)));
      int16x8_t v99 = (int16x8_t)vmlaq_f16(v116, v98, v120);
      float16x8_t v100 = (float16x8_t)vtrn2q_s16(v99, v99);
      float16x8_t v101 = vmlaq_n_f16(vmlaq_f16(vmlaq_f16(v124, (float16x8_t)vrev32q_s16((int16x8_t)v98), v118), v98, v122), v97, v134[0]);
      float16x8_t v102 = vmlaq_n_f16((float16x8_t)vtrn1q_s16(v99, v99), v97, v134[0]);
      v98.i64[0] = 0x3C003C003C003C00;
      v98.i64[1] = 0x3C003C003C003C00;
      float16x8_t v103 = vminq_f16(vmlaq_n_f16(v100, v97, v134[0]), v98);
      float16x8_t v104 = (float16x8_t)vdupq_n_s16(0x63FEu);
      uint16x8_t v105 = vcvtnq_u16_f16(vmulq_f16(v103, v104));
      uint16x8_t v106 = vcvtnq_u16_f16(vmulq_f16(vminq_f16(v101, v98), v104));
      uint16x8_t v107 = vcvtnq_u16_f16(vmulq_f16(vminq_f16(v102, v98), v104));
      v104.i64[0] = 0x300000003;
      v104.i64[1] = 0x300000003;
      int32x4_t __src = vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v107.i8), vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v106.i8), vsliq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v105.i8), (int32x4_t)v104, 0xAuLL), 0xAuLL), 0xAuLL);
      int32x4_t v130 = vsliq_n_s32((int32x4_t)vmovl_high_u16(v107), vsliq_n_s32((int32x4_t)vmovl_high_u16(v106), vsliq_n_s32((int32x4_t)vmovl_high_u16(v105), (int32x4_t)v104, 0xAuLL), 0xAuLL), 0xAuLL);
      memcpy(v11, &__src, 4 * v93);
    }
  }
  return 0;
}

__int16 VEC::xf20Constants::xf20Constants@<H0>(uint64_t a1@<X0>, __int16 *a2@<X1>)
{
  int v2 = (__int16 *)&kDefaultXF20ToRGB16fConversion;
  if (a2) {
    int v2 = a2;
  }
  _H0 = v2[3];
  *(_WORD *)a1 = _H0;
  _H1 = v2[4];
  *(_WORD *)(a1 + 2) = _H1;
  _H2 = *v2;
  __asm
  {
    FCVT            S2, H2
    FCVT            S0, H0
  }
  _H3 = v2[1];
  __asm
  {
    FCVT            S3, H3
    FCVT            S1, H1
  }
  _S1 = (float)(_S1 * _S3) + (float)(_S2 * _S0);
  __asm { FCVT            H1, S1 }
  *(short float *)(a1 + 4) = -*(short float *)&_S1;
  LOWORD(_S1) = v2[5];
  *(_WORD *)(a1 + 6) = LOWORD(_S1);
  _H4 = v2[6];
  *(_WORD *)(a1 + 8) = _H4;
  __asm { FCVT            S4, H4 }
  float v18 = (float)(_S3 * _S4) + (float)(_S2 * _S0);
  LOWORD(_S4) = v2[2];
  __asm
  {
    FCVT            S4, H4
    FCVT            S1, H1
  }
  _S1 = v18 + (float)(_S4 * _S1);
  __asm { FCVT            H1, S1 }
  *(short float *)(a1 + 10) = -*(short float *)&_S1;
  LOWORD(_S1) = v2[7];
  *(_WORD *)(a1 + 12) = LOWORD(_S1);
  __asm { FCVT            S1, H1 }
  _S0 = (float)(_S4 * _S1) + (float)(_S2 * _S0);
  __asm { FCVT            H0, S0 }
  *(short float *)&__int16 result = -*(short float *)&_S0;
  *(short float *)(a1 + 14) = *(short float *)&result;
  return result;
}

void *reallocarray(void *a1, unint64_t a2, unint64_t a3)
{
  if (a2 && (a3 | a2) >> 32 && !is_mul_ok(a2, a3))
  {
    uint64_t v3 = __error();
    __int16 result = 0;
    int *v3 = 12;
  }
  else
  {
    uint64_t v5 = a3 * a2;
    __int16 result = malloc_type_realloc(a1, a3 * a2, 0x198D5A97uLL);
    if (v5 <= 0 && result != 0) {
      __break(0x5519u);
    }
  }
  return result;
}

char *_cg_GifMakeMapObject(int a1, char *a2)
{
  unsigned int v4 = 1;
  do
  {
    int v5 = 1 << v4;
    if (v4 > 8) {
      break;
    }
    ++v4;
  }
  while (v5 < a1);
  if (v5 != a1) {
    return 0;
  }
  uint64_t v6 = malloc_type_malloc(0x18uLL, 0x1020040D090CC53uLL);
  if (!v6) {
    return (char *)v6;
  }
  __int16 result = (char *)malloc_type_calloc(a1, 3uLL, 0x100004033FC2DF1uLL);
  size_t v8 = 3 * a1;
  float16x4_t v9 = &result[v8];
  if (!result) {
    float16x4_t v9 = 0;
  }
  if (result <= v9 && (a1 & 0x80000000) == 0 && (uint64_t)(0xAAAAAAAAAAAAAAABLL * (v9 - result)) >= a1)
  {
    v6[2] = result;
    *(_DWORD *)uint64_t v6 = a1;
    if (result)
    {
      unsigned int v10 = 0;
      do
        ++v10;
      while (v10 <= 8 && 1 << v10 < a1);
      *((_DWORD *)v6 + 1) = v10;
      *((unsigned char *)v6 + 8) = 0;
      if (!a2) {
        return (char *)v6;
      }
      if (&a2[v8] >= a2)
      {
        memcpy(result, a2, v8);
        return (char *)v6;
      }
      goto LABEL_21;
    }
    free(v6);
    return 0;
  }
LABEL_21:
  __break(0x5519u);
  return result;
}

void _cg_GifFreeMapObject(void **a1)
{
  if (a1)
  {
    free(a1[2]);
    free(a1);
  }
}

void GifFreeExtensionFromSavedImage(uint64_t a1)
{
  int v2 = *(void **)(a1 + 48);
  if (v2)
  {
    if (*(int *)(a1 + 40) >= 1)
    {
      uint64_t v3 = 0;
      uint64_t v4 = 8;
      do
      {
        free(*(void **)(*(void *)(a1 + 48) + v4));
        ++v3;
        v4 += 24;
      }
      while (v3 < *(int *)(a1 + 40));
      int v2 = *(void **)(a1 + 48);
    }
    free(v2);
    *(_DWORD *)(a1 + 40) = 0;
    *(void *)(a1 + 48) = 0;
  }
}

void GifFreeExtensionFromGifFile(uint64_t a1)
{
  int v2 = *(void **)(a1 + 72);
  if (v2)
  {
    if (*(int *)(a1 + 64) >= 1)
    {
      uint64_t v3 = 0;
      uint64_t v4 = 8;
      do
      {
        free(*(void **)(*(void *)(a1 + 72) + v4));
        ++v3;
        v4 += 24;
      }
      while (v3 < *(int *)(a1 + 64));
      int v2 = *(void **)(a1 + 72);
    }
    free(v2);
    *(_DWORD *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
  }
}

void GifFreeSavedImages(uint64_t a1)
{
  if (a1)
  {
    int v2 = *(void **)(a1 + 56);
    if (v2)
    {
      unint64_t v3 = (unint64_t)v2 + 56 * *(int *)(a1 + 24);
      if ((unint64_t)v2 >= v3)
      {
LABEL_14:
        free(v2);
        *(_DWORD *)(a1 + 24) = 0;
        *(void *)(a1 + 56) = 0;
      }
      else
      {
        unint64_t v4 = *(void *)(a1 + 56);
        while ((unint64_t)v2 <= v4)
        {
          unint64_t v5 = v4 + 56;
          if (v4 + 56 > v3) {
            break;
          }
          uint64_t v6 = *(void ***)(v4 + 16);
          if (v6)
          {
            free(v6[2]);
            free(v6);
            *(void *)(v4 + 16) = 0;
          }
          unint64_t v7 = *(void **)(v4 + 32);
          if (v7) {
            free(v7);
          }
          if (v4 >= v3) {
            break;
          }
          GifFreeExtensionFromSavedImage(v4);
          v4 += 56;
          if (v5 >= *(void *)(a1 + 56) + 56 * *(int *)(a1 + 24))
          {
            int v2 = *(void **)(a1 + 56);
            goto LABEL_14;
          }
        }
        __break(0x5519u);
      }
    }
  }
}

_OWORD *_cg_EGifOpen(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v6 = malloc_type_malloc(0x70uLL, 0x10A00402F952F05uLL);
  if (v6)
  {
    unint64_t v7 = v6;
    v6[5] = 0u;
    v6[6] = 0u;
    v6[3] = 0u;
    v6[4] = 0u;
    v6[1] = 0u;
    v6[2] = 0u;
    *uint64_t v6 = 0u;
    size_t v8 = malloc_type_malloc(0x4150uLL, 0x10A0040B4BDD98EuLL);
    if (v8)
    {
      float16x4_t v9 = v8;
      bzero(v8, 0x4150uLL);
      inited = _InitHashTable();
      v9[2088] = inited;
      if (inited)
      {
        *((void *)v7 + 12) = v9;
        v9[5] = 0;
        *(_DWORD *)float16x4_t v9 = 1;
        v9[7] = a2;
        *((void *)v7 + 11) = a1;
        *((unsigned char *)v9 + 16712) = 0;
        *((_DWORD *)v7 + 20) = 0;
        return v7;
      }
      free(v7);
      unint64_t v11 = v9;
    }
    else
    {
      unint64_t v11 = v7;
    }
    free(v11);
  }
  unint64_t v7 = 0;
  if (a3) {
    *a3 = 7;
  }
  return v7;
}

const char *EGifGetGifVersion(const char *result)
{
  uint64_t v1 = *((void *)result + 12);
  uint64_t v2 = *((unsigned int *)result + 6);
  if ((int)v2 < 1)
  {
LABEL_17:
    uint64_t v11 = *((unsigned int *)result + 16);
    if ((int)v11 >= 1)
    {
      unint64_t v12 = (int *)(*((void *)result + 9) + 16);
      do
      {
        int v14 = *v12;
        v12 += 6;
        int v13 = v14;
        int v15 = (1 << (v14 + 7)) & 0x61;
        if ((v14 - 249) <= 6 && v15 != 0 || v13 == 1) {
          *(unsigned char *)(v1 + 16712) = 1;
        }
        --v11;
      }
      while (v11);
    }
    if (*(unsigned char *)(v1 + 16712)) {
      return "GIF89a";
    }
    else {
      return "GIF87a";
    }
  }
  else
  {
    uint64_t v3 = 0;
    uint64_t v4 = *((void *)result + 7);
    while (1)
    {
      uint64_t v5 = *(unsigned int *)(v4 + 56 * v3 + 40);
      if ((int)v5 >= 1) {
        break;
      }
LABEL_16:
      if (++v3 == v2) {
        goto LABEL_17;
      }
    }
    unint64_t v6 = *(void *)(v4 + 56 * v3 + 48);
    unint64_t v7 = v6 + 24 * v5;
    while (v6 < v7)
    {
      int v8 = *(_DWORD *)(v6 + 16);
      if ((v8 - 249) <= 6 && ((1 << (v8 + 7)) & 0x61) != 0 || v8 == 1) {
        *(unsigned char *)(v1 + 16712) = 1;
      }
      v6 += 24;
      if (!--v5) {
        goto LABEL_16;
      }
    }
    __break(0x5519u);
  }
  return result;
}

size_t _cg_EGifPutScreenDesc(uint64_t a1, __int16 a2, __int16 a3, int a4, __int16 a5, int *a6)
{
  char v26 = 0;
  __int16 v25 = 0;
  unint64_t v7 = *(_WORD **)(a1 + 96);
  if ((*v7 & 2) != 0)
  {
    size_t result = 0;
    int v9 = 3;
    goto LABEL_27;
  }
  if (*v7)
  {
    GifVersion = (char *)EGifGetGifVersion((const char *)a1);
    size_t result = strlen(GifVersion);
    if (GifVersion < &GifVersion[result])
    {
      int v16 = InternalWrite(a1, GifVersion, result);
      size_t result = strlen(GifVersion);
      if (result != v16)
      {
LABEL_26:
        size_t result = 0;
        int v9 = 2;
        goto LABEL_27;
      }
      *(_WORD *)a1 = a2;
      *(_WORD *)(a1 + 2) = a3;
      *(_WORD *)(a1 + 4) = a4;
      *(_WORD *)(a1 + 6) = a5;
      if (!a6)
      {
        int v19 = 0;
        *(void *)(a1 + 16) = 0;
        goto LABEL_15;
      }
      int v17 = *a6;
      float v18 = (char *)*((void *)a6 + 2);
      if (!v18 || v17 >= 1)
      {
        size_t result = (size_t)_cg_GifMakeMapObject(*a6, v18);
        if (!result || v17 >= 1)
        {
          *(void *)(a1 + 16) = result;
          if (!result)
          {
            int v9 = 7;
            goto LABEL_27;
          }
          int v19 = 128;
LABEL_15:
          __int16 __ptr = a2;
          InternalWrite(a1, &__ptr, 2uLL);
          __int16 v28 = a3;
          InternalWrite(a1, &v28, 2uLL);
          if (a6)
          {
            int v20 = (a6[1] + 255) | v19 | (16 * a4 + 240);
            LOBYTE(v25) = (*((unsigned char *)a6 + 4) - 1) | v19 | (16 * a4 - 16);
            if (!*((unsigned char *)a6 + 8)) {
              goto LABEL_20;
            }
            char v21 = v20 | 8;
          }
          else
          {
            char v21 = v19 | (16 * a4 - 16) | 7;
          }
          LOBYTE(v25) = v21;
LABEL_20:
          HIBYTE(v25) = a5;
          char v26 = *(unsigned char *)(a1 + 8);
          InternalWrite(a1, &v25, 3uLL);
          if (!a6 || *a6 < 1)
          {
LABEL_25:
            *v7 |= 2u;
            return 1;
          }
          uint64_t v22 = 0;
          uint64_t v23 = 0;
          while (1)
          {
            float16x8_t v24 = (__int16 *)(*((void *)a6 + 2) + v22);
            __int16 v25 = *v24;
            char v26 = *((unsigned char *)v24 + 2);
            if (InternalWrite(a1, &v25, 3uLL) != 3) {
              goto LABEL_26;
            }
            ++v23;
            v22 += 3;
            if (v23 >= *a6) {
              goto LABEL_25;
            }
          }
        }
      }
    }
    __break(0x5519u);
    return result;
  }
  size_t result = 0;
  int v9 = 10;
LABEL_27:
  *(_DWORD *)(a1 + 80) = v9;
  return result;
}

size_t InternalWrite(uint64_t a1, void *__ptr, size_t a3)
{
  uint64_t v3 = *(void *)(a1 + 96);
  uint64_t v4 = *(uint64_t (**)(void))(v3 + 56);
  if (!v4) {
    return fwrite(__ptr, 1uLL, a3, *(FILE **)(v3 + 40));
  }

  return v4();
}

void _cg_EGifPutImageDesc(uint64_t a1, __int16 a2, __int16 a3, int a4, int a5, int a6, int *a7)
{
  __int16 v32 = 0;
  uint64_t v14 = *(void *)(a1 + 96);
  if ((*(_WORD *)v14 & 4) != 0 && *(void *)(v14 + 32) >= 0xFFFF0001uLL)
  {
    int v15 = 4;
LABEL_38:
    *(_DWORD *)(a1 + 80) = v15;
    return;
  }
  if ((*(_WORD *)v14 & 1) == 0)
  {
    int v15 = 10;
    goto LABEL_38;
  }
  *(_WORD *)(a1 + 32) = a2;
  *(_WORD *)(a1 + 34) = a3;
  *(_WORD *)(a1 + 36) = a4;
  *(_WORD *)(a1 + 38) = a5;
  *(unsigned char *)(a1 + 40) = a6;
  if (a7)
  {
    int v16 = *(void ***)(a1 + 48);
    if (v16)
    {
      _cg_GifFreeMapObject(v16);
      *(void *)(a1 + 48) = 0;
    }
    int v17 = *a7;
    float v18 = (char *)*((void *)a7 + 2);
    if (v18 && v17 < 1 || (MapObject = _cg_GifMakeMapObject(*a7, v18)) != 0 && v17 < 1)
    {
      __break(0x5519u);
      return;
    }
    *(void *)(a1 + 48) = MapObject;
    if (!MapObject)
    {
      int v15 = 7;
      goto LABEL_38;
    }
    char v20 = 0x80;
  }
  else
  {
    char v20 = 0;
    *(void *)(a1 + 48) = 0;
  }
  char __ptr = 44;
  InternalWrite(a1, &__ptr, 1uLL);
  __int16 v33 = a2;
  InternalWrite(a1, &v33, 2uLL);
  __int16 v34 = a3;
  InternalWrite(a1, &v34, 2uLL);
  __int16 v35 = a4;
  InternalWrite(a1, &v35, 2uLL);
  __int16 v36 = a5;
  InternalWrite(a1, &v36, 2uLL);
  if (a6) {
    char v21 = 64;
  }
  else {
    char v21 = 0;
  }
  char v22 = v20 | v21;
  if (a7)
  {
    char __ptr = (*((unsigned char *)a7 + 4) - 1) | v22;
    InternalWrite(a1, &__ptr, 1uLL);
    if (*a7 >= 1)
    {
      uint64_t v23 = 0;
      uint64_t v24 = 0;
      while (1)
      {
        uint64_t v25 = *((void *)a7 + 2) + v23;
        char __ptr = *(unsigned char *)v25;
        __int16 v32 = *(_WORD *)(v25 + 1);
        if (InternalWrite(a1, &__ptr, 3uLL) != 3) {
          break;
        }
        ++v24;
        v23 += 3;
        if (v24 >= *a7) {
          goto LABEL_26;
        }
      }
      int v15 = 2;
      goto LABEL_38;
    }
  }
  else
  {
    char __ptr = v22;
    InternalWrite(a1, &__ptr, 1uLL);
  }
LABEL_26:
  uint64_t v26 = *(void *)(a1 + 16);
  uint64_t v27 = *(void *)(a1 + 48);
  if (!(v26 | v27))
  {
    int v15 = 5;
    goto LABEL_38;
  }
  *(_WORD *)v14 |= 4u;
  *(void *)(v14 + 32) = a5 * (uint64_t)a4;
  if (v27) {
    uint64_t v26 = v27;
  }
  uint64_t v28 = *(void *)(a1 + 96);
  int v29 = *(_DWORD *)(v26 + 4);
  if (v29 <= 2) {
    __int16 v30 = 2;
  }
  else {
    __int16 v30 = v29;
  }
  char v37 = v30;
  InternalWrite(a1, &v37, 1uLL);
  *(unsigned char *)(v28 + 64) = 0;
  *(_WORD *)(v28 + 4) = v30;
  *(_WORD *)(v28 + 6) = 1 << v30;
  *(_WORD *)(v28 + 8) = (1 << v30) + 1;
  *(_WORD *)(v28 + 10) = (1 << v30) + 2;
  *(_WORD *)(v28 + 12) = v30 + 1;
  *(_WORD *)(v28 + 14) = 1 << (v30 + 1);
  *(_WORD *)(v28 + 18) = 4097;
  *(_WORD *)(v28 + 22) = 0;
  *(void *)(v28 + 24) = 0;
  _ClearHashTable(*(void **)(v28 + 16704));
  if (!EGifCompressOutput(a1, *(__int16 *)(v28 + 6))) {
    *(_DWORD *)(a1 + 80) = 8;
  }
}

uint64_t _cg_EGifPutLine(uint64_t result, unsigned __int8 *a2, signed int a3)
{
  uint64_t v3 = *(void *)(result + 96);
  if ((*(_WORD *)v3 & 1) == 0)
  {
    int v4 = 10;
LABEL_7:
    *(_DWORD *)(result + 80) = v4;
    return 0;
  }
  if (!a3 && *(_WORD *)(result + 36)) {
    goto LABEL_18;
  }
  unint64_t v5 = *(void *)(v3 + 32);
  if (v5 < a3)
  {
    int v4 = 6;
    goto LABEL_7;
  }
  *(void *)(v3 + 32) = v5 - a3;
  unint64_t v6 = &CodeMask[*(__int16 *)(v3 + 4)];
  if (v6 < &CodeMask[9] && v6 >= CodeMask)
  {
    if (a3 >= 1)
    {
      uint64_t v8 = a3;
      char v9 = *v6;
      unsigned int v10 = a2;
      do
      {
        *v10++ &= v9;
        --v8;
      }
      while (v8);
    }
    if ((a3 & 0x80000000) == 0) {
      return EGifCompressLine(result, a2, a3);
    }
  }
LABEL_18:
  __break(0x5519u);
  return result;
}

uint64_t EGifCompressLine(uint64_t result, unsigned __int8 *a2, signed int a3)
{
  size_t v4 = result;
  uint64_t v5 = *(void *)(result + 96);
  unint64_t v6 = *(void **)(v5 + 16704);
  int v7 = *(__int16 *)(v5 + 18);
  if (v7 == 4097)
  {
    if (!a3)
    {
LABEL_25:
      __break(0x5519u);
      return result;
    }
    int v7 = *a2;
    unsigned int v8 = 1;
  }
  else
  {
    unsigned int v8 = 0;
  }
  if ((int)v8 < a3)
  {
    char v9 = &a2[a3];
    unsigned int v10 = &a2[v8];
    unint64_t v11 = a3 - (unint64_t)v8;
    while (v10 < v9 && v10 >= a2)
    {
      int v12 = *v10;
      size_t result = _ExistsHashTable((unint64_t)v6, v12 | (v7 << 8));
      int v13 = result;
      if ((result & 0x80000000) != 0)
      {
        if (!EGifCompressOutput(v4, v7)) {
          goto LABEL_24;
        }
        int v14 = *(__int16 *)(v5 + 10);
        if (v14 < 4095)
        {
          ++*(_WORD *)(v5 + 10);
          size_t result = _InsertHashTable((unint64_t)v6, v12 | (v7 << 8), v14);
        }
        else
        {
          if (!EGifCompressOutput(v4, *(__int16 *)(v5 + 6))) {
            goto LABEL_24;
          }
          *(_WORD *)(v5 + 10) = *(_WORD *)(v5 + 8) + 1;
          __int16 v15 = *(_WORD *)(v5 + 4) + 1;
          *(_WORD *)(v5 + 12) = v15;
          *(_WORD *)(v5 + 14) = 1 << v15;
          size_t result = (uint64_t)_ClearHashTable(v6);
        }
        int v13 = v12;
      }
      ++v10;
      int v7 = v13;
      if (!--v11) {
        goto LABEL_19;
      }
    }
    goto LABEL_25;
  }
  int v13 = v7;
LABEL_19:
  *(_WORD *)(v5 + 18) = v13;
  if (*(void *)(v5 + 32)
    || EGifCompressOutput(v4, v13)
    && EGifCompressOutput(v4, *(__int16 *)(v5 + 8))
    && EGifCompressOutput(v4, 4096))
  {
    return 1;
  }
LABEL_24:
  size_t result = 0;
  *(_DWORD *)(v4 + 80) = 8;
  return result;
}

uint64_t _cg_EGifPutExtension(uint64_t a1, int a2, int a3, void *a4)
{
  int v11 = a3;
  char v10 = 0;
  __int16 __ptr = 0;
  if (**(_WORD **)(a1 + 96))
  {
    if (a2)
    {
      int v7 = a3;
      LOBYTE(__ptr) = 33;
      HIBYTE(__ptr) = a2;
      char v10 = a3;
      InternalWrite(a1, &__ptr, 3uLL);
    }
    else
    {
      InternalWrite(a1, &v11, 1uLL);
      int v7 = v11;
    }
    InternalWrite(a1, a4, v7);
    LOBYTE(__ptr) = 0;
    uint64_t v5 = 1;
    InternalWrite(a1, &__ptr, 1uLL);
  }
  else
  {
    uint64_t v5 = 0;
    *(_DWORD *)(a1 + 80) = 10;
  }
  return v5;
}

uint64_t _cg_EGifPutExtensionLeader(uint64_t a1, char a2)
{
  __ptr[2] = 0;
  if (**(_WORD **)(a1 + 96))
  {
    __ptr[0] = 33;
    __ptr[1] = a2;
    InternalWrite(a1, __ptr, 2uLL);
    return 1;
  }
  else
  {
    uint64_t v2 = 0;
    *(_DWORD *)(a1 + 80) = 10;
  }
  return v2;
}

uint64_t _cg_EGifPutExtensionBlock(uint64_t a1, int a2, void *a3)
{
  if (**(_WORD **)(a1 + 96))
  {
    char __ptr = a2;
    uint64_t v4 = 1;
    InternalWrite(a1, &__ptr, 1uLL);
    InternalWrite(a1, a3, a2);
  }
  else
  {
    uint64_t v4 = 0;
    *(_DWORD *)(a1 + 80) = 10;
  }
  return v4;
}

uint64_t _cg_EGifPutExtensionTrailer(uint64_t a1)
{
  if (**(_WORD **)(a1 + 96))
  {
    char __ptr = 0;
    uint64_t v1 = 1;
    InternalWrite(a1, &__ptr, 1uLL);
  }
  else
  {
    uint64_t v1 = 0;
    *(_DWORD *)(a1 + 80) = 10;
  }
  return v1;
}

uint64_t _cg_EGifCloseFile(uint64_t result, int *a2)
{
  if (result)
  {
    uint64_t v2 = (void *)result;
    uint64_t v3 = *(void **)(result + 96);
    if (!v3) {
      return 0;
    }
    if ((*(_WORD *)v3 & 1) == 0)
    {
      if (a2)
      {
        int v5 = 10;
LABEL_16:
        *a2 = v5;
        goto LABEL_17;
      }
      goto LABEL_17;
    }
    unint64_t v6 = (FILE *)*((void *)v3 + 5);
    char __ptr = 59;
    InternalWrite(result, &__ptr, 1uLL);
    int v7 = (void **)v2[6];
    if (v7)
    {
      _cg_GifFreeMapObject(v7);
      v2[6] = 0;
    }
    unsigned int v8 = (void **)v2[2];
    if (v8)
    {
      _cg_GifFreeMapObject(v8);
      v2[2] = 0;
    }
    char v9 = (void *)*((void *)v3 + 2088);
    if (v9) {
      free(v9);
    }
    free(v3);
    if (v6 && fclose(v6))
    {
      if (a2)
      {
        int v5 = 9;
        goto LABEL_16;
      }
LABEL_17:
      free(v2);
      return 0;
    }
    free(v2);
    if (a2) {
      *a2 = 0;
    }
    return 1;
  }
  return result;
}

uint64_t EGifCompressOutput(size_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  if (a2 == 4096)
  {
    if (*(__int16 *)(v4 + 22) < 1)
    {
      unsigned int v6 = 1;
    }
    else
    {
      uint64_t v5 = *(void *)(v4 + 24);
      unsigned int v6 = 1;
      do
      {
        if (!EGifBufferedOutput(a1, (unsigned char *)(v4 + 64), v5)) {
          unsigned int v6 = 0;
        }
        uint64_t v5 = *(void *)(v4 + 24) >> 8;
        *(void *)(v4 + 24) = v5;
        int v7 = (__int16)(*(_WORD *)(v4 + 22) - 8);
        *(_WORD *)(v4 + 22) -= 8;
      }
      while (v7 > 0);
    }
    *(_WORD *)(v4 + 22) = 0;
    if (EGifBufferedOutput(a1, (unsigned char *)(v4 + 64), 4096)) {
      uint64_t v11 = v6;
    }
    else {
      uint64_t v11 = 0;
    }
  }
  else
  {
    __int16 v8 = *(_WORD *)(v4 + 22);
    uint64_t v9 = ((uint64_t)a2 << v8) | *(void *)(v4 + 24);
    *(void *)(v4 + 24) = v9;
    __int16 v10 = *(_WORD *)(v4 + 12) + v8;
    *(_WORD *)(v4 + 22) = v10;
    if (v10 < 8)
    {
      uint64_t v11 = 1;
    }
    else
    {
      LODWORD(v11) = 1;
      do
      {
        if (EGifBufferedOutput(a1, (unsigned char *)(v4 + 64), v9)) {
          uint64_t v11 = v11;
        }
        else {
          uint64_t v11 = 0;
        }
        uint64_t v9 = *(void *)(v4 + 24) >> 8;
        *(void *)(v4 + 24) = v9;
        int v12 = (__int16)(*(_WORD *)(v4 + 22) - 8);
        *(_WORD *)(v4 + 22) -= 8;
      }
      while (v12 > 7);
    }
  }
  if (a2 <= 4095 && *(__int16 *)(v4 + 10) >= *(__int16 *)(v4 + 14))
  {
    __int16 v13 = *(_WORD *)(v4 + 12) + 1;
    *(_WORD *)(v4 + 12) = v13;
    *(_WORD *)(v4 + 14) = 1 << v13;
  }
  return v11;
}

size_t EGifBufferedOutput(size_t result, unsigned char *__ptr, int a3)
{
  uint64_t v4 = result;
  if (a3 == 4096)
  {
    if (!*__ptr
      || InternalWrite(result, __ptr, *__ptr + 1) == *__ptr + 1)
    {
      *char __ptr = 0;
      uint64_t v5 = 1;
      if (InternalWrite(v4, __ptr, 1uLL) == 1) {
        return v5;
      }
    }
    goto LABEL_15;
  }
  char v6 = a3;
  int v7 = *__ptr;
  if (v7 == 255)
  {
    size_t result = InternalWrite(result, __ptr, 0x100uLL);
    if (result != *__ptr + 1)
    {
LABEL_15:
      uint64_t v5 = 0;
      *(_DWORD *)(v4 + 80) = 2;
      return v5;
    }
    int v7 = 0;
  }
  uint64_t v8 = (v7 + 1);
  *char __ptr = v8;
  uint64_t v9 = &__ptr[v8];
  if (v9 >= __ptr + 256 || v9 < __ptr)
  {
    __break(0x5519u);
    return result;
  }
  unsigned char *v9 = v6;
  return 1;
}

unint64_t _cg_GifQuantizeBuffer(uint64_t a1, uint64_t a2)
{
  MEMORY[0x1F4188790](a1, a2);
  unint64_t v3 = v2;
  uint64_t v5 = v4;
  int v7 = v6;
  uint64_t v9 = v8;
  uint64_t v11 = v10;
  __int16 v13 = v12;
  unsigned int v15 = v14;
  unsigned int v17 = v16;
  *(void *)unsigned __int16 v179 = *MEMORY[0x1E4F143B8];
  bzero(v175, 0x2000uLL);
  uint64_t v18 = *v13;
  unint64_t result = (unint64_t)malloc_type_malloc(0xC0000uLL, 0x1020040EFA1817AuLL);
  if (result) {
    unint64_t v20 = result + 786432;
  }
  else {
    unint64_t v20 = 0;
  }
  if (!result) {
    return result;
  }
  char v21 = (char *)result;
  unint64_t v22 = 0;
  unint64_t v23 = (unint64_t)&v11[v15 * (unint64_t)v17];
  unint64_t v24 = (unint64_t)&v9[v15 * (unint64_t)v17];
  unint64_t v25 = (unint64_t)&v7[v15 * (unint64_t)v17];
  unint64_t v26 = v3 + v18;
  unint64_t v27 = result;
  unint64_t v174 = (unint64_t)&v5[v15 * (unint64_t)v17];
  uint64_t v28 = v11;
  do
  {
    if (v27 >= v20 || v27 < result) {
      goto LABEL_211;
    }
    *(unsigned char *)unint64_t v27 = v22 >> 10;
    *(unsigned char *)(v27 + 1) = (v22 >> 5) & 0x1F;
    *(unsigned char *)(v27 + 2) = v22 & 0x1F;
    *(void *)(v27 + 8) = 0;
    ++v22;
    v27 += 24;
  }
  while (v22 != 0x8000);
  uint64_t v29 = v15 * v17;
  if ((int)v29 >= 1)
  {
    uint64_t v30 = v15 * v17;
    uint64_t v31 = v11;
    __int16 v32 = v9;
    __int16 v33 = v7;
    do
    {
      if ((unint64_t)v31 >= v23
        || v31 < v11
        || (unint64_t)v32 >= v24
        || v32 < v9
        || (unint64_t)v33 >= v25
        || v33 < v7)
      {
        goto LABEL_211;
      }
      unint64_t v34 = (*v31 << 7) & 0x7C00 | (32 * (((unint64_t)*v32 >> 3) & 0x1F)) | ((unint64_t)*v33 >> 3);
      unint64_t v35 = result + 24 * v34;
      if (v35 >= v20 || v35 < result) {
        goto LABEL_211;
      }
      ++*(void *)(result + 24 * v34 + 8);
      ++v33;
      ++v32;
      ++v31;
      --v30;
    }
    while (v30);
  }
  uint64_t v37 = 0;
  for (uint64_t i = 0; i != 256; ++i)
  {
    uint64_t v39 = 0;
    unint64_t v40 = (unint64_t)&v175[32 * i];
    *(_DWORD *)(v40 + 8) = 0;
    unint64_t v41 = v40 | 3;
    *(void *)(v40 + 16) = 0;
    *(void *)(v40 + 24) = 0;
    float16x8_t v42 = &v175[v37];
    do
    {
      float16x8_t v43 = &v42[v39];
      if ((unint64_t)&v42[v39] >= v41 || (unint64_t)v43 < v40) {
        goto LABEL_211;
      }
      unsigned char *v43 = 0;
      float16x8_t v45 = v43 + 3;
      if ((unint64_t)v45 >= (v40 | 6) || (unint64_t)v45 < v41) {
        goto LABEL_211;
      }
      *float16x8_t v45 = -1;
      ++v39;
    }
    while (v39 != 3);
    v37 += 32;
  }
  uint64_t v46 = 0;
  uint64_t v47 = 8;
  do
  {
    if (*(uint64_t *)&v21[v47] > 0) {
      break;
    }
    ++v46;
    v47 += 24;
  }
  while (v46 != 0x8000);
  uint16x8_t v48 = &v21[24 * v46];
  if (v48)
  {
    if ((unint64_t)v48 >= v20 || v48 < v21) {
      goto LABEL_211;
    }
  }
  v178[0] = &v21[24 * v46];
  unint64_t v50 = (unint64_t)(v48 + 24);
  if (v46 > 0x7FFE)
  {
    int v52 = 1;
    unint64_t v53 = (unint64_t)v48;
  }
  else
  {
    uint64_t v51 = 24 * v46;
    int v52 = 1;
    unint64_t v53 = (unint64_t)v48;
    do
    {
      unint64_t v54 = (unint64_t)&v21[v51 + 24];
      if (v54 >= v20 || v54 < (unint64_t)v21) {
        goto LABEL_211;
      }
      if (*(uint64_t *)&v21[v51 + 32] >= 1)
      {
        if (v53 + 24 > v50 || (unint64_t)v48 > v53) {
          goto LABEL_211;
        }
        *(void *)(v53 + 16) = v54;
        ++v52;
        uint16x8_t v48 = v21;
        unint64_t v50 = v20;
        unint64_t v53 = (unint64_t)&v21[v51 + 24];
      }
      v51 += 24;
    }
    while (v51 != 786408);
  }
  if (v53 + 24 > v50 || (unint64_t)v48 > v53) {
    goto LABEL_211;
  }
  *(void *)(v53 + 16) = 0;
  *(_DWORD *)&v176[5] = v52;
  unint64_t v177 = v15 * (unint64_t)v17;
  int v56 = *v13;
  if (*v13 < 2)
  {
    int v58 = 1;
    goto LABEL_143;
  }
  unint64_t v165 = v3 + v18;
  uint64_t v166 = v15 * v17;
  uint64_t v162 = v11;
  char v163 = v9;
  float32x4_t v164 = v5;
  char v167 = v13;
  uint64_t v168 = v21;
  int v169 = *v13;
  unsigned int v57 = 0;
  unint64_t v173 = v20;
  int v58 = 1;
  float16x8_t v59 = v175;
  float32x4_t v171 = &v9[v15 * (unint64_t)v17];
  float32x4_t v172 = &v11[v15 * (unint64_t)v17];
  float32x4_t v170 = &v7[v15 * (unint64_t)v17];
  do
  {
    unsigned int v60 = 0;
    int v61 = -1;
    float16x8_t v62 = v176;
    do
    {
      unint64_t v63 = (unint64_t)&v175[32 * v60];
      if (v63 >= (unint64_t)v179 || v63 < (unint64_t)v175) {
        goto LABEL_211;
      }
      uint64_t v65 = 0;
      unint64_t v66 = v63 | 3;
      unint64_t v67 = v63 | 6;
      int32x4_t v68 = (_DWORD *)(v63 + 8);
      do
      {
        uint16x8_t v69 = &v62[v65];
        if ((unint64_t)&v62[v65] >= v67 || (unint64_t)v69 < v66) {
          goto LABEL_211;
        }
        int v71 = *v69;
        if (v61 < v71 && *v68 >= 2u)
        {
          SortRGBAxis = v65;
          unsigned int v57 = v60;
          int v61 = v71;
        }
        ++v65;
      }
      while (v65 != 3);
      ++v60;
      v62 += 32;
    }
    while (v60 != v58);
    if (v61 == -1) {
      goto LABEL_141;
    }
    uint64_t v72 = &v175[32 * v57];
    if (v72 >= v179 || v72 < v175) {
      goto LABEL_211;
    }
    uint64_t v73 = &v175[32 * v57];
    float16x8_t v75 = v73 + 8;
    uint64_t v74 = *((unsigned int *)v73 + 2);
    short float v76 = (unint64_t *)malloc_type_malloc(8 * v74, 0x2004093837F09uLL);
    if (v76) {
      float16x8_t v77 = (char *)&v76[v74];
    }
    else {
      float16x8_t v77 = 0;
    }
    if (!v76)
    {
      free(v168);
      return 0;
    }
    float16x8_t v78 = v76;
    uint64_t v81 = *((void *)v73 + 3);
    uint16x8_t v80 = (unint64_t *)(v73 + 24);
    uint64_t v79 = v81;
    size_t v82 = *v75;
    if (v82 && v79)
    {
      float16x8_t v83 = (char *)v76;
      unint64_t v84 = 1;
      while (v83 < v77 && v83 >= (char *)v76)
      {
        *(void *)float16x8_t v83 = v79;
        v83 += 8;
        if (v84 < v82)
        {
          uint64_t v79 = *(void *)(v79 + 16);
          ++v84;
          if (v79) {
            continue;
          }
        }
        goto LABEL_91;
      }
LABEL_211:
      __break(0x5519u);
    }
LABEL_91:
    qsort(v76, v82, 8uLL, (int (__cdecl *)(const void *, const void *))SortCmpRtn);
    uint64_t v85 = (*v75 - 1);
    if (*v75 != 1)
    {
      float16x8_t v86 = v78 + 1;
      uint64_t v87 = (*v75 - 1);
      while (v86 < (unint64_t *)v77 && v86 >= v78)
      {
        *(void *)(*(v86 - 1) + 16) = *v86;
        ++v86;
        if (!--v87) {
          goto LABEL_98;
        }
      }
      goto LABEL_211;
    }
    uint64_t v85 = 0;
LABEL_98:
    float16x8_t v88 = &v78[v85];
    if (v88 >= (unint64_t *)v77 || v88 < v78) {
      goto LABEL_211;
    }
    *(void *)(*v88 + 16) = 0;
    unint64_t v89 = *v78;
    unint64_t *v80 = *v78;
    free(v78);
    uint16x8_t v90 = &v178[4 * v57 - 1];
    uint64_t v91 = *(void *)(v89 + 8);
    unint64_t v92 = *(void *)(v89 + 16);
    if (v92)
    {
      uint64_t v93 = *(void *)(v92 + 8);
      uint64_t v94 = (*v90 >> 1) - v91 - v93;
      unint64_t v23 = (unint64_t)v172;
      unint64_t v20 = v173;
      unint64_t v25 = (unint64_t)v170;
      unint64_t v24 = (unint64_t)v171;
      if (v94 >= 0 && (unint64_t v95 = *(void *)(v92 + 16)) != 0)
      {
        int v96 = 2;
        do
        {
          unint64_t v89 = v92;
          unint64_t v92 = v95;
          int v97 = v96;
          v91 += v93;
          uint64_t v93 = *(void *)(v95 + 8);
          v94 -= v93;
          if (v94 < 0) {
            break;
          }
          unint64_t v95 = *(void *)(v95 + 16);
          ++v96;
        }
        while (v95);
      }
      else
      {
        int v97 = 1;
      }
    }
    else
    {
      int v97 = 1;
      unint64_t v23 = (unint64_t)v172;
      unint64_t v20 = v173;
      unint64_t v25 = (unint64_t)v170;
      unint64_t v24 = (unint64_t)v171;
    }
    uint64_t v98 = SortRGBAxis;
    int16x8_t v99 = (char *)(v89 + SortRGBAxis);
    if ((unint64_t)v99 >= v89 + 3 || (unint64_t)v99 < v89) {
      goto LABEL_211;
    }
    float16x8_t v101 = &v175[32 * v58];
    if (v101 >= v179 || v101 < v175) {
      goto LABEL_211;
    }
    uint64_t v102 = 0;
    char v103 = *v99;
    char v104 = *(unsigned char *)(v92 + SortRGBAxis);
    unint64_t v105 = (unint64_t)&v175[32 * v58];
    *(void *)(v105 + 24) = v92;
    char v106 = 8 * v103;
    char v107 = 8 * v104;
    *(void *)(v89 + 16) = 0;
    *(void *)(v105 + 16) = v91;
    *v90 -= v91;
    unint64_t v108 = (unint64_t)&v175[32 * v57];
    unint64_t v109 = v108 | 3;
    *(_DWORD *)(v105 + 8) = *v75 - v97;
    _DWORD *v75 = v97;
    unint64_t v110 = v108 | 6;
    uint64_t v111 = v101 + 3;
    unint64_t v112 = v105 | 3;
    unint64_t v113 = v105 | 6;
    do
    {
      uint64_t v114 = &v72[v102];
      BOOL v115 = &v72[v102] < v72 + 3 && v114 >= v72;
      float16x8_t v116 = &v59[v102 + 32];
      if (!v115 || v116 >= v111 || v116 < v101) {
        goto LABEL_211;
      }
      char v120 = *v114;
      float16x8_t v119 = v114 + 3;
      *float16x8_t v116 = v120;
      if ((unint64_t)v119 >= v110) {
        goto LABEL_211;
      }
      if ((unint64_t)v119 < v109) {
        goto LABEL_211;
      }
      float16x8_t v121 = &v59[v102 + 35];
      if ((unint64_t)v121 >= v113 || (unint64_t)v121 < v112) {
        goto LABEL_211;
      }
      *float16x8_t v121 = *v119;
      ++v102;
    }
    while (v102 != 3);
    float16x8_t v122 = &v101[v98];
    if (&v101[v98] >= v111) {
      goto LABEL_211;
    }
    if (v122 < v101) {
      goto LABEL_211;
    }
    float16x8_t v123 = (unsigned char *)(v112 + v98);
    if (v112 + v98 >= v113) {
      goto LABEL_211;
    }
    if ((unint64_t)v123 < v112) {
      goto LABEL_211;
    }
    *v123 += *v122 - v107;
    *float16x8_t v122 = v107;
    float16x8_t v124 = &v72[v98];
    if (&v72[v98] < v72) {
      goto LABEL_211;
    }
    float16x8_t v125 = (unsigned char *)(v109 + v98);
    if ((unint64_t)v125 < v109) {
      goto LABEL_211;
    }
    *float16x8_t v125 = v106 - *v124;
    ++v58;
    v59 += 32;
  }
  while (v58 != v169);
  int v58 = v169;
LABEL_141:
  uint64_t v5 = v164;
  uint64_t v28 = v162;
  uint64_t v9 = v163;
  __int16 v13 = v167;
  char v21 = v168;
  int v56 = *v167;
  uint64_t v29 = v166;
  unint64_t v26 = v165;
LABEL_143:
  if (v58 < v56 && v58 < v56)
  {
    uint64_t v127 = v56;
    unint64_t v128 = v3 + 3 * v58;
    uint64_t v129 = v127 - v58;
    while (v128 < v26 && v128 >= v3)
    {
      *(unsigned char *)(v128 + 2) = 0;
      *(_WORD *)unint64_t v128 = 0;
      v128 += 3;
      if (!--v129) {
        goto LABEL_151;
      }
    }
    goto LABEL_211;
  }
LABEL_151:
  uint64_t v130 = 0;
  unint64_t v131 = v3 + v58;
  do
  {
    uint16x8_t v132 = &v175[32 * v130];
    if (v132 >= v179 || v132 < v175) {
      goto LABEL_211;
    }
    uint64_t v134 = *((unsigned int *)v132 + 2);
    if ((int)v134 >= 1)
    {
      int v135 = (unsigned __int8 *)v178[4 * v130];
      if (v135)
      {
        uint64_t v136 = 0;
        uint64_t v137 = 0;
        uint64_t v138 = 0;
        do
        {
          v135[3] = v130;
          v136 += *v135;
          v137 += v135[1];
          v138 += v135[2];
          int v135 = (unsigned __int8 *)*((void *)v135 + 2);
        }
        while (v135);
      }
      else
      {
        uint64_t v138 = 0;
        uint64_t v137 = 0;
        uint64_t v136 = 0;
      }
      char v139 = (unsigned char *)(v3 + 3 * v130);
      if ((unint64_t)v139 >= v131 || (unint64_t)v139 < v3) {
        goto LABEL_211;
      }
      *char v139 = 8 * v136 / v134;
      v139[1] = 8 * v137 / v134;
      v139[2] = 8 * v138 / v134;
    }
    ++v130;
  }
  while (v130 != v58);
  if ((int)v29 >= 1)
  {
    int v141 = 0;
    int v142 = 0;
    int v143 = 0;
    char v144 = v28;
    float32x4_t v145 = v9;
    float32x4_t v146 = v7;
    float32x4_t v147 = v5;
    while ((unint64_t)v144 < v23
         && v144 >= v28
         && (unint64_t)v145 < v24
         && v145 >= v9
         && (unint64_t)v146 < v25
         && v146 >= v7)
    {
      unint64_t v148 = (*v144 << 7) & 0x7C00 | (32 * (((unint64_t)*v145 >> 3) & 0x1F)) | ((unint64_t)*v146 >> 3);
      __n128 v149 = &v21[24 * v148];
      BOOL v150 = (unint64_t)v149 < v20 && v149 >= v21;
      BOOL v151 = !v150 || (unint64_t)v147 >= v174;
      if (v151 || v147 < v5) {
        break;
      }
      uint64_t v153 = v21[24 * v148 + 3];
      *float32x4_t v147 = v153;
      int v154 = (unsigned __int8 *)(v3 + 3 * v153);
      if ((unint64_t)v154 >= v131 || (unint64_t)v154 < v3) {
        break;
      }
      int v156 = *v144++;
      int v157 = *v154 - v156;
      if (v157 < 0) {
        int v157 = -v157;
      }
      if (v143 <= v157) {
        int v143 = v157;
      }
      int v158 = *v145++;
      int v159 = v154[1] - v158;
      if (v159 < 0) {
        int v159 = -v159;
      }
      if (v142 <= v159) {
        int v142 = v159;
      }
      int v160 = *v146++;
      int v161 = v154[2] - v160;
      if (v161 < 0) {
        int v161 = -v161;
      }
      if (v141 <= v161) {
        int v141 = v161;
      }
      ++v147;
      if (!--v29) {
        goto LABEL_208;
      }
    }
    goto LABEL_211;
  }
  int v143 = 0;
  int v142 = 0;
  int v141 = 0;
LABEL_208:
  fprintf((FILE *)*MEMORY[0x1E4F143C8], "Quantization L(0) errors: Red = %d, Green = %d, Blue = %d.\n", v143, v142, v141);
  free(v21);
  int *v13 = v58;
  return 1;
}

unint64_t *SortCmpRtn(unint64_t *result, void *a2)
{
  unint64_t v2 = *result;
  unint64_t v3 = *result + 3;
  unint64_t v4 = *result + SortRGBAxis;
  if (v4 < v3 && v4 >= v2)
  {
    uint64_t v6 = (SortRGBAxis + 1) % 3u;
    int v7 = (unsigned __int8 *)(v2 + v6);
    if (v2 + v6 < v3 && (unint64_t)v7 >= v2)
    {
      uint64_t v9 = (SortRGBAxis + 2) % 3u;
      __int16 v10 = (unsigned __int8 *)(v2 + v9);
      if (v2 + v9 < v3 && (unint64_t)v10 >= v2) {
        return (unint64_t *)(((*(unsigned __int8 *)(v2 + SortRGBAxis) << 16) | (*v7 << 8) | *v10)
      }
                                  - ((*(unsigned __int8 *)(*a2 + SortRGBAxis) << 16) | (*(unsigned __int8 *)(*a2 + v6) << 8) | *(unsigned __int8 *)(*a2 + v9)));
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t _cg_DGifGetScreenDesc(uint64_t a1)
{
  char v15 = 0;
  __int16 __ptr = 0;
  if ((**(_WORD **)(a1 + 96) & 8) == 0)
  {
    uint64_t result = 0;
    int v3 = 111;
LABEL_3:
    *(_DWORD *)(a1 + 80) = v3;
    return result;
  }
  uint64_t result = DGifGetWord(a1, (_WORD *)a1);
  if (result)
  {
    uint64_t result = DGifGetWord(a1, (_WORD *)(a1 + 2));
    if (result)
    {
      uint64_t v4 = *(void *)(a1 + 96);
      uint64_t v5 = *(int (**)(uint64_t, __int16 *, uint64_t))(v4 + 48);
      if (v5) {
        size_t v6 = v5(a1, &__ptr, 3);
      }
      else {
        size_t v6 = fread(&__ptr, 1uLL, 3uLL, *(FILE **)(v4 + 40));
      }
      if (v6 == 3)
      {
        int v7 = (char)__ptr;
        *(_WORD *)(a1 + 4) = (((char)__ptr >> 4) & 7) + 1;
        *(_WORD *)(a1 + 6) = HIBYTE(__ptr);
        *(unsigned char *)(a1 + 8) = v15;
        if ((v7 & 0x80000000) == 0)
        {
          *(void *)(a1 + 16) = 0;
          return 1;
        }
        uint64_t result = (uint64_t)_cg_GifMakeMapObject(1 << ((v7 & 7) + 1), 0);
        *(void *)(a1 + 16) = result;
        if (!result)
        {
          int v3 = 109;
          goto LABEL_3;
        }
        *(unsigned char *)(result + 8) = (v7 & 8) != 0;
        uint64_t v8 = *(int *)result;
        uint64_t v9 = 3 * v8;
        uint64_t v10 = *(void *)(a1 + 96);
        uint64_t v11 = *(int (**)(uint64_t))(v10 + 48);
        if (!v11)
        {
          uint64_t v9 = (int)v9;
          size_t v13 = fread(*(void **)(result + 16), 1uLL, (int)v9, *(FILE **)(v10 + 40));
LABEL_24:
          if (v13 != v9)
          {
            _cg_GifFreeMapObject(*(void ***)(a1 + 16));
            uint64_t result = 0;
            *(void *)(a1 + 16) = 0;
            int v3 = 102;
            goto LABEL_3;
          }
          return 1;
        }
        if (*(void *)(result + 16)) {
          BOOL v12 = (int)v8 < 1;
        }
        else {
          BOOL v12 = 0;
        }
        if (!v12)
        {
          size_t v13 = v11(a1);
          goto LABEL_24;
        }
        __break(0x5519u);
      }
      else
      {
        *(_DWORD *)(a1 + 80) = 102;
        _cg_GifFreeMapObject(*(void ***)(a1 + 16));
        uint64_t result = 0;
        *(void *)(a1 + 16) = 0;
      }
    }
  }
  return result;
}

uint64_t _cg_DGifOpen(uint64_t a1, int (*a2)(uint64_t, _DWORD *, uint64_t), int *a3)
{
  size_t v6 = malloc_type_malloc(0x70uLL, 0x10A00402F952F05uLL);
  if (v6)
  {
    uint64_t v7 = (uint64_t)v6;
    v6[5] = 0u;
    v6[6] = 0u;
    v6[3] = 0u;
    v6[4] = 0u;
    v6[1] = 0u;
    v6[2] = 0u;
    *size_t v6 = 0u;
    uint64_t v8 = (char *)malloc_type_calloc(1uLL, 0x4150uLL, 0x10A0040B4BDD98EuLL);
    if (!v8)
    {
      if (a3) {
        *a3 = 109;
      }
      goto LABEL_22;
    }
    uint64_t v9 = v8;
    *(_DWORD *)((char *)__ptr + 3) = 0;
    __ptr[0] = 0;
    bzero(v8 + 4, 0x414CuLL);
    *(void *)(v7 + 96) = v9;
    *(_DWORD *)uint64_t v9 = 8;
    *((void *)v9 + 6) = a2;
    *(void *)(v7 + 88) = a1;
    *(unsigned char *)(v7 + 104) = 0;
    if (a2) {
      size_t v10 = a2(v7, __ptr, 6);
    }
    else {
      size_t v10 = fread(__ptr, 1uLL, 6uLL, 0);
    }
    if (v10 != 6)
    {
      if (a3)
      {
        int v13 = 102;
        goto LABEL_20;
      }
LABEL_21:
      free(v9);
LABEL_22:
      free((void *)v7);
      return 0;
    }
    BYTE2(__ptr[1]) = 0;
    if (LOWORD(__ptr[0]) != 18759 || BYTE2(__ptr[0]) != 70)
    {
      if (a3)
      {
        int v13 = 103;
LABEL_20:
        *a3 = v13;
        goto LABEL_21;
      }
      goto LABEL_21;
    }
    if (_cg_DGifGetScreenDesc(v7))
    {
      *(_DWORD *)(v7 + 80) = 0;
      v9[16712] = HIBYTE(__ptr[0]) == 57;
      return v7;
    }
    free(v9);
    free((void *)v7);
    if (!a3) {
      return 0;
    }
    uint64_t v7 = 0;
    int v11 = 104;
  }
  else
  {
    if (!a3) {
      return 0;
    }
    uint64_t v7 = 0;
    int v11 = 109;
  }
  *a3 = v11;
  return v7;
}

uint64_t DGifGetWord(uint64_t a1, _WORD *a2)
{
  __int16 __ptr = 0;
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = *(int (**)(uint64_t, __int16 *, uint64_t))(v4 + 48);
  if (v5) {
    size_t v6 = v5(a1, &__ptr, 2);
  }
  else {
    size_t v6 = fread(&__ptr, 1uLL, 2uLL, *(FILE **)(v4 + 40));
  }
  if (v6 == 2)
  {
    *a2 = __ptr;
    return 1;
  }
  else
  {
    uint64_t result = 0;
    *(_DWORD *)(a1 + 80) = 102;
  }
  return result;
}

uint64_t _cg_DGifGetRecordType(uint64_t a1, int *a2)
{
  uint64_t v3 = *(void *)(a1 + 96);
  if ((*(_WORD *)v3 & 8) != 0)
  {
    char __ptr = 0;
    uint64_t v7 = *(int (**)(uint64_t, char *, uint64_t))(v3 + 48);
    if (v7) {
      size_t v8 = v7(a1, &__ptr, 1);
    }
    else {
      size_t v8 = fread(&__ptr, 1uLL, 1uLL, *(FILE **)(v3 + 40));
    }
    if (v8 == 1)
    {
      switch(__ptr)
      {
        case '!':
          int v9 = 3;
          break;
        case ';':
          int v9 = 4;
          break;
        case ',':
          int v9 = 2;
          break;
        default:
          uint64_t result = 0;
          *a2 = 0;
          int v5 = 107;
          goto LABEL_12;
      }
      *a2 = v9;
      return 1;
    }
    uint64_t result = 0;
    int v5 = 102;
  }
  else
  {
    uint64_t result = 0;
    int v5 = 111;
  }
LABEL_12:
  *(_DWORD *)(a1 + 80) = v5;
  return result;
}

char *_cg_DGifGetImageDesc(uint64_t a1)
{
  char v32 = 0;
  __int16 __ptr = 0;
  uint64_t v2 = *(void *)(a1 + 96);
  if ((*(_WORD *)v2 & 8) == 0)
  {
    uint64_t result = 0;
    int v4 = 111;
LABEL_3:
    *(_DWORD *)(a1 + 80) = v4;
    return result;
  }
  int v5 = (long long *)(a1 + 32);
  uint64_t result = (char *)DGifGetWord(a1, (_WORD *)(a1 + 32));
  if (result)
  {
    uint64_t result = (char *)DGifGetWord(a1, (_WORD *)(a1 + 34));
    if (result)
    {
      uint64_t result = (char *)DGifGetWord(a1, (_WORD *)(a1 + 36));
      if (result)
      {
        uint64_t result = (char *)DGifGetWord(a1, (_WORD *)(a1 + 38));
        if (result)
        {
          uint64_t v6 = *(void *)(a1 + 96);
          uint64_t v7 = *(int (**)(uint64_t, __int16 *, uint64_t))(v6 + 48);
          if (v7) {
            size_t v8 = v7(a1, &__ptr, 1);
          }
          else {
            size_t v8 = fread(&__ptr, 1uLL, 1uLL, *(FILE **)(v6 + 40));
          }
          if (v8 == 1)
          {
            char v9 = __ptr;
            *(unsigned char *)(a1 + 40) = (__ptr & 0x40) != 0;
            size_t v10 = *(void ***)(a1 + 48);
            if (v10)
            {
              _cg_GifFreeMapObject(v10);
              *(void *)(a1 + 48) = 0;
              if ((__ptr & 0x80) == 0) {
                goto LABEL_25;
              }
            }
            else if ((v9 & 0x80) == 0)
            {
              goto LABEL_25;
            }
            uint64_t result = _cg_GifMakeMapObject(1 << ((v9 & 7) + 1), 0);
            *(void *)(a1 + 48) = result;
            if (!result) {
              goto LABEL_54;
            }
            int v11 = *(_DWORD *)result;
            uint64_t v12 = (3 * *(_DWORD *)result);
            uint64_t v13 = *(void *)(a1 + 96);
            unsigned int v14 = *(int (**)(uint64_t))(v13 + 48);
            if (v14)
            {
              if (*((void *)result + 2) && v11 < 1) {
                goto LABEL_55;
              }
              size_t v15 = v14(a1);
            }
            else
            {
              size_t v15 = fread(*((void **)result + 2), 1uLL, (3 * v11), *(FILE **)(v13 + 40));
            }
            if (v15 == v12)
            {
LABEL_25:
              uint64_t result = *(char **)(a1 + 56);
              if (result)
              {
                uint64_t v16 = *(unsigned int *)(a1 + 24);
                if ((int)v16 < 1) {
                  goto LABEL_55;
                }
                uint64_t result = (char *)reallocarray(result, v16 + 1, 0x38uLL);
                if (!result)
                {
LABEL_54:
                  int v4 = 109;
                  goto LABEL_3;
                }
                int v17 = *(_DWORD *)(a1 + 24);
                if ((int)v16 < v17 || v17 < -1) {
                  goto LABEL_55;
                }
                uint64_t v18 = result;
                int v19 = v17 + 1;
                *(_DWORD *)(a1 + 24) = v19;
                *(void *)(a1 + 56) = result;
              }
              else
              {
                uint64_t result = (char *)malloc_type_malloc(0x38uLL, 0x10300409283B079uLL);
                unint64_t v20 = result + 56;
                if (!result) {
                  unint64_t v20 = 0;
                }
                if (v20 - result < 1) {
                  goto LABEL_55;
                }
                uint64_t v18 = result;
                *(void *)(a1 + 56) = result;
                int v19 = 1;
                *(_DWORD *)(a1 + 24) = 1;
                if (!result)
                {
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = 0;
                  *(void *)(a1 + 56) = 0;
                  goto LABEL_54;
                }
              }
              uint64_t v21 = v19 - 1;
              unint64_t v22 = (unint64_t)&v18[56 * v19];
              unint64_t v23 = (unint64_t)&v18[56 * v21];
              if (v23 >= v22 || v23 < (unint64_t)v18) {
                goto LABEL_55;
              }
              long long v24 = *v5;
              *(void *)(v23 + 16) = *(void *)(a1 + 48);
              *(_OWORD *)unint64_t v23 = v24;
              uint64_t v25 = *(void *)(a1 + 48);
              if (!v25) {
                goto LABEL_49;
              }
              int v26 = *(_DWORD *)v25;
              unint64_t v27 = *(char **)(v25 + 16);
              if (v27 && v26 < 1) {
                goto LABEL_55;
              }
              uint64_t result = _cg_GifMakeMapObject(*(_DWORD *)v25, v27);
              BOOL v28 = result && v26 <= 0;
              BOOL v29 = !v28;
              if (v23 + 56 > v22 || !v29) {
                goto LABEL_55;
              }
              *(void *)(v23 + 16) = result;
              if (result)
              {
LABEL_49:
                if (v23 + 56 <= v22)
                {
                  uint64_t v30 = &v18[56 * v21];
                  *((void *)v30 + 6) = 0;
                  *((void *)v30 + 3) = 0;
                  *((void *)v30 + 4) = 0;
                  *((_DWORD *)v30 + 10) = 0;
                  *(void *)(v2 + 32) = *(__int16 *)(a1 + 38) * (uint64_t)*(__int16 *)(a1 + 36);
                  return (char *)DGifSetupDecompress(a1);
                }
LABEL_55:
                __break(0x5519u);
                return result;
              }
              goto LABEL_54;
            }
            _cg_GifFreeMapObject(*(void ***)(a1 + 48));
            uint64_t result = 0;
            *(_DWORD *)(a1 + 80) = 102;
          }
          else
          {
            *(_DWORD *)(a1 + 80) = 102;
            _cg_GifFreeMapObject(*(void ***)(a1 + 48));
            uint64_t result = 0;
          }
          *(void *)(a1 + 48) = 0;
        }
      }
    }
  }
  return result;
}

uint64_t DGifSetupDecompress(uint64_t a1)
{
  unsigned __int8 __ptr = 0;
  uint64_t v2 = *(void *)(a1 + 96);
  uint64_t v3 = *(unsigned int (**)(uint64_t, unsigned __int8 *, uint64_t))(v2 + 48);
  if (v3)
  {
    if (v3(a1, &__ptr, 1)) {
      goto LABEL_3;
    }
    return 0;
  }
  if (!fread(&__ptr, 1uLL, 1uLL, *(FILE **)(v2 + 40))) {
    return 0;
  }
LABEL_3:
  __int16 v4 = __ptr;
  if (__ptr < 9u)
  {
    *(unsigned char *)(v2 + 64) = 0;
    *(_WORD *)(v2 + 4) = v4;
    uint64_t v5 = 1;
    *(_WORD *)(v2 + 6) = 1 << v4;
    *(_WORD *)(v2 + 8) = (1 << v4) + 1;
    *(_WORD *)(v2 + 10) = (1 << v4) + 2;
    __int16 v6 = v4 + 1;
    *(_WORD *)(v2 + 12) = v6;
    *(_WORD *)(v2 + 14) = 1 << v6;
    *(_DWORD *)(v2 + 20) = 0;
    *(_WORD *)(v2 + 16) = 4112;
    *(void *)(v2 + 24) = 0;
    memset((void *)(v2 + 8512), 16, 0x2000uLL);
  }
  else
  {
    uint64_t v5 = 0;
    *(_DWORD *)(a1 + 80) = 102;
  }
  return v5;
}

size_t _cg_DGifGetLine(size_t result, char *a2, uint64_t a3)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(result + 96);
  if ((*(_WORD *)v4 & 8) == 0)
  {
    int v5 = 111;
LABEL_10:
    uint64_t result = 0;
    *(_DWORD *)(v3 + 80) = v5;
    return result;
  }
  if (!a3)
  {
    if (*(_WORD *)(result + 36))
    {
LABEL_20:
      __break(0x5519u);
      return result;
    }
    unint64_t v9 = *(void *)(v4 + 32);
    __int16 v6 = (unint64_t *)(v4 + 32);
    if (v9 <= 0xFFFF0000)
    {
      a3 = 0;
      goto LABEL_13;
    }
LABEL_9:
    int v5 = 108;
    goto LABEL_10;
  }
  uint64_t v7 = *(void *)(v4 + 32);
  __int16 v6 = (unint64_t *)(v4 + 32);
  unint64_t v8 = v7 - (int)a3;
  *__int16 v6 = v8;
  if (v8 > 0xFFFF0000) {
    goto LABEL_9;
  }
  if ((a3 & 0x80000000) != 0) {
    goto LABEL_20;
  }
LABEL_13:
  uint64_t result = DGifDecompressLine(result, a2, a3);
  if (result)
  {
    if (*v6)
    {
      return 1;
    }
    else
    {
      uint64_t v10 = 0;
      do
      {
        uint64_t result = _cg_DGifGetCodeNext(v3, (uint64_t)&v10);
        if (!result) {
          break;
        }
        uint64_t result = 1;
      }
      while (v10);
    }
  }
  return result;
}

size_t DGifDecompressLine(size_t result, char *a2, uint64_t a3)
{
  uint64_t v3 = *(_WORD **)(result + 96);
  uint64_t v4 = (__int16)v3[10];
  if ((int)v4 > 4095) {
    return 0;
  }
  size_t v6 = result;
  int v74 = (__int16)v3[4];
  int v7 = (__int16)v3[3];
  int v8 = (__int16)v3[8];
  if (v3[10] && (int)a3 >= 1)
  {
    uint64_t v9 = (__int16)v3[10];
    unsigned int v10 = v4 - 1;
    if ((int)a3 - 1 < v10) {
      unsigned int v10 = a3 - 1;
    }
    uint64_t v11 = v10 + 1;
    uint64_t v12 = v11;
    uint64_t v13 = (char *)v3 + 319;
    unsigned int v14 = a2;
    while (1)
    {
      size_t v15 = &v13[v9];
      if (&v13[v9] >= (char *)v3 + 4415 || v15 < (char *)v3 + 320) {
        break;
      }
      *v14++ = *v15;
      --v9;
      if (!--v11)
      {
        uint64_t v4 = v9;
        goto LABEL_16;
      }
    }
LABEL_136:
    __break(0x5519u);
  }
  else
  {
    uint64_t v12 = 0;
LABEL_16:
    if ((int)v12 >= (int)a3)
    {
      LOWORD(v21) = v4;
      LOWORD(v4) = v8;
LABEL_132:
      v3[8] = v4;
      v3[10] = v21;
      return 1;
    }
    else
    {
      int v73 = v7;
      int v17 = v3 + 4256;
      uint64_t v18 = v3 + 8352;
      int v19 = (char *)v3 + 8511;
      int v76 = 0;
      int64_t v20 = (int)a3;
      uint16x8_t v70 = (char *)(v3 + 160);
      uint64_t v21 = v4;
      size_t v71 = (size_t)&a2[a3];
      uint64_t v72 = (char *)v3 + 4415;
      while (1)
      {
        uint64_t v75 = v21;
        int64_t v22 = v20;
        unint64_t v23 = v19;
        uint64_t v24 = v12;
        uint64_t v25 = a3;
        size_t v26 = v6;
        uint64_t result = DGifDecompressInput(v6, &v76);
        if (!result) {
          break;
        }
        LODWORD(v4) = v76;
        if (v76 == v74)
        {
          uint64_t result = 0;
          *(_DWORD *)(v26 + 80) = 113;
          return result;
        }
        if (v76 == v73)
        {
          memset(v3 + 4256, 16, 0x2000uLL);
          v3[5] = v3[4] + 1;
          LOWORD(v4) = v3[2] + 1;
          v3[6] = v4;
          v3[7] = 1 << v4;
          LODWORD(v4) = 4112;
          v3[8] = 4112;
          size_t v6 = v26;
          a3 = v25;
          uint64_t v12 = v24;
          int v19 = v23;
          int64_t v20 = v22;
          uint64_t v21 = v75;
        }
        else
        {
          if (v76 >= v73)
          {
            __int16 v33 = &v17[v76];
            BOOL v34 = v33 < v18 && v33 >= v17;
            size_t v6 = v26;
            a3 = v25;
            uint64_t v12 = v24;
            int v19 = v23;
            int64_t v20 = v22;
            BOOL v28 = (char *)v3 + 4415;
            uint64_t v35 = v75;
            if (!v34) {
              goto LABEL_136;
            }
            if (*v33 == 4112)
            {
              if (v76 == (__int16)v3[5] - 2)
              {
                LOBYTE(v36) = v8;
                if (v8 > v73)
                {
                  int v37 = 4097;
                  int v36 = v8;
                  do
                  {
                    if (!--v37) {
                      break;
                    }
                    if (v36 > 4095) {
                      goto LABEL_71;
                    }
                    uint16x8_t v38 = &v17[v36];
                    if (v38 >= v18 || v38 < v17) {
                      goto LABEL_136;
                    }
                    int v36 = *v38;
                  }
                  while (v36 > v73);
                }
              }
              else
              {
                LOBYTE(v36) = v76;
                if (v76 > v73)
                {
                  int v40 = 4097;
                  int v36 = v76;
                  do
                  {
                    if (!--v40) {
                      break;
                    }
                    if (v36 > 4095)
                    {
LABEL_71:
                      LOBYTE(v36) = 16;
                      break;
                    }
                    unint64_t v41 = &v17[v36];
                    if (v41 >= v18 || v41 < v17) {
                      goto LABEL_136;
                    }
                    int v36 = *v41;
                  }
                  while (v36 > v73);
                }
              }
              float16x8_t v45 = &v70[(int)v75];
              if (v45 >= v72 || v45 < v70) {
                goto LABEL_136;
              }
              *float16x8_t v45 = v36;
              uint64_t v47 = &v72[(__int16)v3[5] - 2];
              if (v47 >= v19 || v47 < v72) {
                goto LABEL_136;
              }
              uint64_t v35 = (v75 + 1);
              *uint64_t v47 = v36;
              int v39 = v8;
            }
            else
            {
              int v39 = v76;
            }
            if ((int)v35 > 4094) {
              goto LABEL_133;
            }
            uint64_t v49 = 0;
            uint64_t v50 = (int)v35;
            uint64_t v51 = v35 << 32;
            uint64_t v52 = (uint64_t)v3 + (int)v35 + 320;
            while (v39 > v73 && v39 <= 4095)
            {
              unint64_t v53 = &v72[v39];
              if (v53 >= v19) {
                goto LABEL_136;
              }
              if (v53 < v72) {
                goto LABEL_136;
              }
              unint64_t v54 = (char *)(v52 + v49);
              if (v52 + v49 >= (unint64_t)v72) {
                goto LABEL_136;
              }
              if (v54 < v70) {
                goto LABEL_136;
              }
              *unint64_t v54 = *v53;
              float16x8_t v55 = &v17[v39];
              if (v55 >= v18 || v55 < v17) {
                goto LABEL_136;
              }
              int v39 = *v55;
              ++v49;
              v51 += 0x100000000;
              if ((int)v35 + v49 == 4095) {
                goto LABEL_133;
              }
            }
            if (v39 >= 4096)
            {
LABEL_133:
              uint64_t result = 0;
              *(_DWORD *)(v6 + 80) = 112;
              return result;
            }
            int v56 = &v70[v51 >> 32];
            if (v56 >= v72 || v56 < v70) {
              goto LABEL_136;
            }
            uint64_t v57 = (v35 + 1);
            *int v56 = v39;
            uint64_t v21 = v57 + v49;
            if (v57 + v49 && (int)v24 < (int)v25)
            {
              uint64_t v58 = 0;
              uint64_t v59 = (int)v35 + v49;
              unsigned int v60 = v3 + 160;
              while (1)
              {
                int v61 = (char *)v60 + v50 + v49;
                BOOL v62 = v61 < v72 && v61 >= v70;
                uint64_t result = (size_t)&a2[(int)v24 + v58];
                BOOL v63 = !v62 || result >= v71;
                if (v63 || result < (unint64_t)a2) {
                  goto LABEL_136;
                }
                uint64_t v65 = v58 + 1;
                *(unsigned char *)uint64_t result = *((unsigned char *)v60 + v59);
                if (v59 != v58)
                {
                  uint64_t result = v65 + (int)v24;
                  unsigned int v60 = (_WORD *)((char *)v60 - 1);
                  ++v58;
                  if ((uint64_t)result < v20) {
                    continue;
                  }
                }
                uint64_t v21 = (v57 + v49 - v65);
                uint64_t v12 = (v24 + v65);
                break;
              }
            }
          }
          else
          {
            unint64_t v27 = &a2[(int)v24];
            size_t v6 = v26;
            int v19 = v23;
            int64_t v20 = v22;
            BOOL v28 = (char *)v3 + 4415;
            uint64_t v21 = v75;
            if ((unint64_t)v27 >= v71 || v27 < a2) {
              goto LABEL_136;
            }
            a3 = v25;
            uint64_t v12 = (v24 + 1);
            char *v27 = v76;
          }
          if (v8 != 4112)
          {
            BOOL v29 = &v17[(__int16)v3[5] - 2];
            if (v29 >= v18 || v29 < v17) {
              goto LABEL_136;
            }
            if (*v29 == 4112)
            {
              unsigned __int16 *v29 = v8;
              uint64_t v30 = (__int16)v3[5];
              if (v4 == (__int16)v3[5] - 2)
              {
                if (v8 > v73)
                {
                  int v31 = 4097;
                  do
                  {
                    if (!--v31) {
                      break;
                    }
                    if (v8 > 4095)
                    {
                      LOBYTE(v8) = 16;
                      break;
                    }
                    char v32 = &v17[v8];
                    if (v32 >= v18 || v32 < v17) {
                      goto LABEL_136;
                    }
                    int v8 = *v32;
                  }
                  while (v8 > v73);
                }
                unint64_t v66 = &v28[v30 - 2];
                if (v66 >= v19 || v66 < v28) {
                  goto LABEL_136;
                }
                *unint64_t v66 = v8;
              }
              else
              {
                LOBYTE(v42) = v4;
                if ((int)v4 > v73)
                {
                  int v43 = 4097;
                  int v42 = v4;
                  do
                  {
                    if (!--v43) {
                      break;
                    }
                    if (v42 > 4095)
                    {
                      LOBYTE(v42) = 16;
                      break;
                    }
                    float16x8_t v44 = &v17[v42];
                    if (v44 >= v18 || v44 < v17) {
                      goto LABEL_136;
                    }
                    int v42 = *v44;
                  }
                  while (v42 > v73);
                }
                int32x4_t v68 = &v28[v30 - 2];
                if (v68 >= v19 || v68 < v28) {
                  goto LABEL_136;
                }
                char *v68 = v42;
              }
            }
          }
        }
        int v8 = v4;
        if ((int)v12 >= (int)a3) {
          goto LABEL_132;
        }
      }
    }
  }
  return result;
}

uint64_t _cg_DGifGetCodeNext(uint64_t a1, uint64_t a2)
{
  unsigned __int8 __ptr = 0;
  uint64_t v4 = *(void *)(a1 + 96);
  int v5 = *(int (**)(uint64_t, unsigned __int8 *, uint64_t))(v4 + 48);
  if (v5) {
    size_t v6 = v5(a1, &__ptr, 1);
  }
  else {
    size_t v6 = fread(&__ptr, 1uLL, 1uLL, *(FILE **)(v4 + 40));
  }
  if (v6 != 1) {
    goto LABEL_12;
  }
  size_t v7 = __ptr;
  if (!__ptr)
  {
    *(void *)a2 = 0;
    *(unsigned char *)(v4 + 64) = 0;
    uint64_t result = 1;
    *(void *)(v4 + 32) = 0;
    return result;
  }
  *(void *)a2 = v4 + 64;
  *(unsigned char *)(v4 + 64) = v7;
  uint64_t v8 = *(void *)(a1 + 96);
  uint64_t v9 = *(int (**)(uint64_t, uint64_t))(v8 + 48);
  size_t v10 = v9 ? v9(a1, *(void *)a2 + 1) : fread((void *)(*(void *)a2 + 1), 1uLL, v7, *(FILE **)(v8 + 40));
  if (v10 == __ptr) {
    return 1;
  }
LABEL_12:
  uint64_t result = 0;
  *(_DWORD *)(a1 + 80) = 102;
  return result;
}

uint64_t _cg_DGifGetExtension(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 96);
  if ((*(_WORD *)v4 & 8) != 0)
  {
    unsigned __int8 __ptr = 0;
    uint64_t v9 = *(int (**)(uint64_t, unsigned __int8 *, uint64_t))(v4 + 48);
    if (v9) {
      size_t v10 = v9(a1, &__ptr, 1);
    }
    else {
      size_t v10 = fread(&__ptr, 1uLL, 1uLL, *(FILE **)(v4 + 40));
    }
    if (v10 == 1)
    {
      *a2 = __ptr;
      return _cg_DGifGetExtensionNext(a1, a3);
    }
    uint64_t result = 0;
    int v6 = 102;
  }
  else
  {
    uint64_t result = 0;
    int v6 = 111;
  }
  *(_DWORD *)(a1 + 80) = v6;
  return result;
}

uint64_t _cg_DGifGetExtensionNext(uint64_t a1, uint64_t a2)
{
  unsigned __int8 __ptr = 0;
  uint64_t v4 = *(void *)(a1 + 96);
  int v5 = *(int (**)(uint64_t, unsigned __int8 *, uint64_t))(v4 + 48);
  if (v5) {
    size_t v6 = v5(a1, &__ptr, 1);
  }
  else {
    size_t v6 = fread(&__ptr, 1uLL, 1uLL, *(FILE **)(v4 + 40));
  }
  if (v6 == 1)
  {
    size_t v7 = __ptr;
    if (!__ptr)
    {
      *(void *)a2 = 0;
      return 1;
    }
    *(void *)a2 = v4 + 64;
    *(unsigned char *)(v4 + 64) = v7;
    uint64_t v8 = *(void *)(a1 + 96);
    uint64_t v9 = *(int (**)(uint64_t, uint64_t))(v8 + 48);
    if (v9) {
      size_t v10 = v9(a1, *(void *)a2 + 1);
    }
    else {
      size_t v10 = fread((void *)(*(void *)a2 + 1), 1uLL, v7, *(FILE **)(v8 + 40));
    }
    if (v10 == __ptr) {
      return 1;
    }
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 80) = 102;
  return result;
}

uint64_t _cg_DGifExtensionToGCB(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  if (a1 != 4) {
    return 0;
  }
  *(_DWORD *)a3 = (*a2 >> 2) & 7;
  *(unsigned char *)(a3 + 4) = (*a2 & 2) != 0;
  *(_DWORD *)(a3 + 8) = *(unsigned __int16 *)(a2 + 1);
  if (*a2) {
    int v3 = a2[3];
  }
  else {
    int v3 = -1;
  }
  *(_DWORD *)(a3 + 12) = v3;
  return 1;
}

uint64_t _cg_DGifCloseFile(uint64_t a1, _DWORD *a2)
{
  if (*(unsigned char *)(a1 + 104)) {
    return 0;
  }
  *(unsigned char *)(a1 + 104) = 1;
  if (!*(void *)(a1 + 96)) {
    return 0;
  }
  uint64_t v4 = *(void ***)(a1 + 48);
  if (v4)
  {
    _cg_GifFreeMapObject(v4);
    *(void *)(a1 + 48) = 0;
  }
  int v5 = *(void ***)(a1 + 16);
  if (v5)
  {
    _cg_GifFreeMapObject(v5);
    *(void *)(a1 + 16) = 0;
  }
  if (*(void *)(a1 + 56))
  {
    GifFreeSavedImages(a1);
    *(_DWORD *)(a1 + 24) = 0;
    *(void *)(a1 + 56) = 0;
  }
  GifFreeExtensionFromGifFile(a1);
  size_t v6 = *(FILE ***)(a1 + 96);
  if ((*(_WORD *)v6 & 8) == 0)
  {
    if (a2) {
      *a2 = 111;
    }
LABEL_17:
    free(v6);
    free((void *)a1);
    return 0;
  }
  if (v6[5])
  {
    if (fclose(v6[5]))
    {
      if (a2) {
        *a2 = 110;
      }
      size_t v6 = *(FILE ***)(a1 + 96);
      goto LABEL_17;
    }
    size_t v6 = *(FILE ***)(a1 + 96);
  }
  free(v6);
  free((void *)a1);
  if (a2) {
    *a2 = 0;
  }
  return 1;
}

uint64_t _cg_DGifGetCode(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  int v3 = *(_WORD **)(a1 + 96);
  if ((*v3 & 8) != 0)
  {
    *a2 = (__int16)v3[2];
    return _cg_DGifGetCodeNext(a1, a3);
  }
  else
  {
    *(_DWORD *)(a1 + 80) = 111;
    return 0;
  }
}

size_t DGifDecompressInput(size_t result, _DWORD *a2)
{
  size_t v2 = result;
  uint64_t v3 = *(void *)(result + 96);
  int v4 = *(__int16 *)(v3 + 12);
  if (v4 > 12)
  {
LABEL_2:
    uint64_t result = 0;
    int v5 = 112;
    goto LABEL_3;
  }
  int v7 = *(__int16 *)(v3 + 22);
  if (v7 >= v4)
  {
LABEL_24:
    uint64_t v21 = (char *)&DGifDecompressInput_CodeMasks + 2 * (__int16)v4;
    if (v21 < byte_18898C7A4 && v21 >= (char *)&DGifDecompressInput_CodeMasks)
    {
      unint64_t v23 = *(void *)(v3 + 24);
      *a2 = v23 & *((_WORD *)&DGifDecompressInput_CodeMasks + (__int16)v4);
      *(void *)(v3 + 24) = v23 >> v4;
      *(_WORD *)(v3 + 22) = v7 - v4;
      int v24 = *(__int16 *)(v3 + 10);
      if (v24 <= 4096)
      {
        *(_WORD *)(v3 + 10) = v24 + 1;
        int v25 = *(__int16 *)(v3 + 14);
        if ((__int16)v4 <= 11 && v24 >= v25)
        {
          *(_WORD *)(v3 + 14) = 2 * v25;
          *(_WORD *)(v3 + 12) = v4 + 1;
        }
      }
      return 1;
    }
    else
    {
LABEL_37:
      __break(0x5519u);
    }
    return result;
  }
  uint64_t v9 = (unsigned __int8 *)(v3 + 64);
  LOBYTE(v8) = *(unsigned char *)(v3 + 64);
  size_t v10 = (unsigned char *)(v3 + 65);
  while ((_BYTE)v8)
  {
    uint64_t v11 = *v10;
    unsigned char *v10 = v11 + 1;
    uint64_t v12 = &v9[v11];
    if ((unint64_t)v12 >= v3 + 320 || v12 < v9) {
      goto LABEL_37;
    }
    uint64_t v14 = *v12;
LABEL_23:
    LOBYTE(v8) = v8 - 1;
    *(unsigned char *)(v3 + 64) = v8;
    *(void *)(v3 + 24) |= v14 << v7;
    __int16 v20 = v7 + 8;
    int v7 = (__int16)(v7 + 8);
    *(_WORD *)(v3 + 22) = v20;
    if (v7 >= (__int16)v4) {
      goto LABEL_24;
    }
  }
  uint64_t v15 = *(void *)(v2 + 96);
  uint64_t v16 = *(int (**)(size_t, uint64_t, uint64_t))(v15 + 48);
  if (v16) {
    size_t v17 = v16(v2, v3 + 64, 1);
  }
  else {
    size_t v17 = fread((void *)(v3 + 64), 1uLL, 1uLL, *(FILE **)(v15 + 40));
  }
  if (v17 == 1)
  {
    if (!*v9) {
      goto LABEL_2;
    }
    uint64_t v18 = *(void *)(v2 + 96);
    int v19 = *(int (**)(size_t, uint64_t))(v18 + 48);
    uint64_t result = v19 ? v19(v2, v3 + 65) : fread((void *)(v3 + 65), 1uLL, *v9, *(FILE **)(v18 + 40));
    uint64_t v8 = *v9;
    if (result == v8)
    {
      uint64_t v14 = *(unsigned __int8 *)(v3 + 65);
      *(unsigned char *)(v3 + 65) = 2;
      LOWORD(v7) = *(_WORD *)(v3 + 22);
      LOWORD(v4) = *(_WORD *)(v3 + 12);
      goto LABEL_23;
    }
  }
  uint64_t result = 0;
  int v5 = 102;
LABEL_3:
  *(_DWORD *)(v2 + 80) = v5;
  return result;
}

void *_InitHashTable()
{
  v0 = malloc_type_malloc(0x8000uLL, 0x1000040B0612BB1uLL);
  uint64_t v1 = v0;
  if (v0) {
    memset(v0, 255, 0x8000uLL);
  }
  return v1;
}

void *_ClearHashTable(void *a1)
{
  return memset(a1, 255, 0x8000uLL);
}

unint64_t _InsertHashTable(unint64_t result, unsigned int a2, __int16 a3)
{
  for (unsigned int i = a2 ^ (a2 >> 12); ; LOWORD(i) = i + 1)
  {
    i &= 0x1FFFu;
    int v4 = (int *)(result + 4 * i);
    if ((unint64_t)v4 >= result + 0x8000 || (unint64_t)v4 < result)
    {
      __break(0x5519u);
      return result;
    }
    if (*v4 >= 0xFFFFF000) {
      break;
    }
  }
  int *v4 = a3 & 0xFFF | (a2 << 12);
  return result;
}

uint64_t _ExistsHashTable(unint64_t a1, unsigned int a2)
{
  LOWORD(v2) = (a2 ^ (a2 >> 12)) & 0x1FFF;
  uint64_t v3 = (unsigned int *)(a1 + 4 * (unsigned __int16)v2);
  if ((unint64_t)v3 < a1 + 0x8000 && (unint64_t)v3 >= a1)
  {
    while (1)
    {
      unsigned int v5 = *v3;
      if (v5 >> 12 == 0xFFFFF) {
        break;
      }
      if (v5 >> 12 == a2) {
        return v5 & 0xFFF;
      }
      unsigned int v2 = ((_WORD)v2 + 1) & 0x1FFF;
      uint64_t v3 = (unsigned int *)(a1 + 4 * v2);
      if ((unint64_t)v3 >= a1 + 0x8000 || (unint64_t)v3 < a1) {
        goto LABEL_12;
      }
    }
  }
  else
  {
LABEL_12:
    __break(0x5519u);
  }
  return 0xFFFFFFFFLL;
}

uint64_t CreatePropertiesFromAppleMakerNote(unsigned __int8 *a1, uint64_t a2)
{
  kdebug_trace();
  int v11 = 0;
  uint64_t v10 = 0;
  *(void *)uint64_t v9 = 0;
  memset(v8, 0, sizeof(v8));
  IIOScanner::IIOScanner((IIOScanner *)v8, a1, a2, 0);
  if ((unint64_t)(a2 - 64513) > 0xFFFFFFFFFFFF040ELL)
  {
    IIOScanner::skip((uint64_t)v8, 10);
    int Val16 = IIOScanner::getVal16((IIOScanner *)v8);
    if (Val16 == 1)
    {
      int v5 = IIOScanner::getVal16((IIOScanner *)v8);
      if (v5 == 19789)
      {
        char v6 = 0;
LABEL_8:
        GlobalHEIFInfo::setShouldExposeMultiFrameContents((uint64_t)v8, v6);
        if (&a1[12 * IIOScanner::getVal16((IIOScanner *)v8) + 10] <= &a1[a2]) {
          operator new();
        }
        goto LABEL_11;
      }
      if (v5 == 18761)
      {
        char v6 = 1;
        goto LABEL_8;
      }
    }
    else
    {
      _cg_jpeg_mem_term("CreatePropertiesFromAppleMakerNote", 193, "*** ERROR: cannot handle version '%d' makernote\n", Val16);
    }
LABEL_11:
    kdebug_trace();
    goto LABEL_12;
  }
  _cg_jpeg_mem_term("CreatePropertiesFromAppleMakerNote", 185, "*** ERROR: bad makerNote length: %d\n", a2);
LABEL_12:
  IIOScanner::~IIOScanner((IIOScanner *)v8);
  return 0;
}

void sub_188636E8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  IIOScanner::~IIOScanner((IIOScanner *)va);
  _Unwind_Resume(a1);
}

void IIOTag::updateTypeAndCount(IIOTag *this)
{
  *((unsigned char *)this + 40) = 1;
  switch(*((_WORD *)this + 4))
  {
    case 1:
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
    case 0xA:
    case 0xD:
    case 0xE:
    case 0xF:
    case 0x10:
    case 0x12:
    case 0x14:
    case 0x19:
    case 0x1B:
    case 0x1C:
    case 0x1E:
    case 0x1F:
    case 0x22:
    case 0x26:
    case 0x28:
    case 0x2C:
    case 0x2D:
    case 0x2E:
    case 0x2F:
    case 0x32:
    case 0x33:
    case 0x34:
    case 0x35:
    case 0x36:
    case 0x37:
    case 0x38:
    case 0x39:
    case 0x3A:
    case 0x3B:
    case 0x3C:
    case 0x3D:
    case 0x3F:
    case 0x41:
    case 0x42:
    case 0x43:
    case 0x44:
    case 0x45:
    case 0x46:
    case 0x47:
    case 0x48:
    case 0x49:
    case 0x4A:
    case 0x52:
    case 0x53:
    case 0x55:
    case 0x58:
    case 0x59:
      __int16 v2 = 9;
      goto LABEL_3;
    case 2:
    case 3:
    case 0x31:
    case 0x3E:
    case 0x40:
    case 0x4C:
    case 0x4E:
    case 0x4F:
    case 0x50:
    case 0x51:
    case 0x54:
    case 0x5A:
      goto LABEL_23;
    case 8:
    case 0x24:
      *((_WORD *)this + 5) = 10;
      unsigned int StringLenMax = 3;
      goto LABEL_4;
    case 0xB:
    case 0x11:
    case 0x15:
    case 0x18:
    case 0x20:
    case 0x29:
    case 0x2A:
    case 0x2B:
      *((_WORD *)this + 5) = 2;
      unsigned int StringLenMax = 36;
      goto LABEL_4;
    case 0xC:
    case 0x13:
      __int16 v7 = 10;
      goto LABEL_20;
    case 0x16:
      *((_WORD *)this + 5) = 7;
      *((unsigned char *)this + 40) = 0;
      goto LABEL_24;
    case 0x17:
    case 0x25:
      __int16 v2 = 16;
      goto LABEL_3;
    case 0x1A:
      *((_WORD *)this + 5) = 2;
      unsigned int StringLenMax = 5;
      goto LABEL_4;
    case 0x1D:
    case 0x21:
    case 0x27:
    case 0x30:
    case 0x4B:
    case 0x4D:
      __int16 v2 = 10;
LABEL_3:
      *((_WORD *)this + 5) = v2;
      unsigned int StringLenMax = 1;
      goto LABEL_4;
    case 0x23:
      __int16 v7 = 9;
LABEL_20:
      *((_WORD *)this + 5) = v7;
      unsigned int StringLenMax = 2;
      goto LABEL_4;
    case 0x57:
      *((_WORD *)this + 5) = 2;
      unsigned int StringLenMax = IIOTag::getStringLenMax(this, 0x24u);
      goto LABEL_4;
    default:
      if (IIO_OSAppleInternalBuild())
      {
        LogError("updateTypeAndCount", 745, "*** ERROR: Unknown AppleMakerNote tag '%d'. If this tagID was added recently, please file a bug against ImageIO to add support for the new tagID.\n", *((unsigned __int16 *)this + 4));
        *((unsigned char *)this + 40) = 0;
LABEL_23:
        *((_WORD *)this + 5) = 7;
LABEL_24:
        unsigned int StringLenMax = IIOTag::getByteCountOfCFObject(this);
LABEL_4:
        *((_DWORD *)this + 3) = StringLenMax;
      }
      else
      {
        LogError("updateTypeAndCount", 752, "*** ERROR: Unknown AppleMakerNote tag '%d' - ignoring...\n", *((unsigned __int16 *)this + 4));
        unsigned int StringLenMax = *((_DWORD *)this + 3);
      }
      uint64_t v4 = StringLenMax;
      uint64_t SizeForTiffType = GetSizeForTiffType(*((unsigned __int16 *)this + 5));
      *((void *)this + 2) = SizeForTiffType * v4;
      if (SizeForTiffType * v4 && *((_WORD *)this + 5) == 2)
      {
        memset(v8, 0, sizeof(v8));
        IIOString::IIOString((IIOString *)v8, *((const void **)this + 4));
        unsigned int v6 = IIOString::length((IIOString *)v8);
        if (v6)
        {
          if (*((unsigned char *)IIOString::utf8String((IIOString *)v8) + v6 - 1))
          {
            *((_DWORD *)this + 3) += GetSizeForTiffType(*((unsigned __int16 *)this + 5));
            *((void *)this + 2) += GetSizeForTiffType(*((unsigned __int16 *)this + 5));
          }
        }
        IIOString::~IIOString((IIOString *)v8);
      }
      return;
  }
}

void sub_188637130(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

void IIOTag::~IIOTag(IIOTag *this)
{
}

void IIOTag::CreateTagWithProperty(IIOTag *this, const void *a2, const void *a3)
{
}

void sub_188637358(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10C1C40C78C77A5);
  _Unwind_Resume(a1);
}

uint64_t IIOTag::getStringLenMax(IIOTag *this, unsigned int a2)
{
  CFStringRef v3 = (const __CFString *)*((void *)this + 4);
  CFTypeID TypeID = CFStringGetTypeID();
  if (TypeID != CFGetTypeID(v3)) {
    return 0;
  }
  LODWORD(result) = CFStringGetLength(v3);
  if (result >= a2) {
    return a2;
  }
  else {
    return result;
  }
}

CFIndex IIOTag::getByteCountOfCFObject(IIOTag *this)
{
  CFDataRef v1 = (const __CFData *)*((void *)this + 4);
  if (!*((unsigned char *)this + 40)) {
    goto LABEL_7;
  }
  CFTypeID TypeID = CFDataGetTypeID();
  if (TypeID == CFGetTypeID(v1)) {
    return CFDataGetLength(v1);
  }
  CFTypeID v4 = CFStringGetTypeID();
  if (v4 == CFGetTypeID(v1))
  {
    memset(v9, 0, sizeof(v9));
    IIOString::IIOString((IIOString *)v9, v1);
    int v5 = (const char *)IIOString::utf8String((IIOString *)v9);
    if (v5) {
      CFIndex Length = strlen(v5) + 1;
    }
    else {
      CFIndex Length = 0;
    }
    IIOString::~IIOString((IIOString *)v9);
  }
  else
  {
LABEL_7:
    CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v1, kCFPropertyListBinaryFormat_v1_0, 0, 0);
    if (Data)
    {
      CFDataRef v7 = Data;
      CFIndex Length = CFDataGetLength(Data);
      CFRelease(v7);
    }
    else
    {
      return 0;
    }
  }
  return Length;
}

void sub_1886374C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

BOOL IIOTag::TagCompare(IIOTag *this, IIOTag *a2, IIOTag *a3)
{
  return *((unsigned __int16 *)this + 4) < *((unsigned __int16 *)a2 + 4);
}

uint64_t IIOTag::writePropertyAndData(IIOTag *this, IIOWriteStream *a2, IIOWriteStream *a3)
{
  IIOWriteStream::write16((uint64_t)a2, *((_WORD *)this + 4));
  IIOWriteStream::write16((uint64_t)a2, *((_WORD *)this + 5));
  IIOWriteStream::write32((uint64_t)a2, *((_DWORD *)this + 3));
  if (*((void *)this + 2) > 4uLL)
  {
    int v7 = *((_DWORD *)this + 12);
    unsigned int v8 = IIOImageSource::count(a3) + v7;
    IIOWriteStream::write32((uint64_t)a2, v8);
    *((_DWORD *)this + 6) = v8;
    return IIOTag::writeData((CFTypeRef *)this, a3);
  }
  else
  {
    uint64_t result = IIOTag::writeData((CFTypeRef *)this, a2);
    if ((result & 0xFFFFFFFC) == 0)
    {
      *(_DWORD *)uint64_t v9 = 0;
      return (uint64_t)IIOWriteStream::writeBytes(a2, v9, (4 - result));
    }
  }
  return result;
}

uint64_t IIOTag::writeData(CFTypeRef *this, IIOWriteStream *a2)
{
  uint64_t v20 = 0;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2000000000;
  uint64_t v23 = 0;
  uint64_t v16 = 0;
  size_t v17 = &v16;
  uint64_t v18 = 0x2000000000;
  uint64_t v19 = 0;
  CFTypeID v4 = CFGetTypeID(this[4]);
  CFTypeID TypeID = (IIOTag *)CFArrayGetTypeID();
  if ((IIOTag *)v4 == TypeID) {
    operator new();
  }
  switch(*((_WORD *)this + 5))
  {
    case 1:
    case 2:
    case 6:
    case 7:
      size_t v6 = IIOTag::writeBytes((IIOTag *)this, a2);
      goto LABEL_21;
    case 3:
    case 8:
      if ((IIOTag *)v4 == TypeID)
      {
        void v17[3] = (uint64_t)this[2] + v21[3];
        int v7 = v14;
        v14[0] = MEMORY[0x1E4F143A8];
        v14[1] = 0x40000000;
        unsigned int v8 = &unk_1E53C09C8;
        uint64_t v9 = ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke_2;
        goto LABEL_13;
      }
      IIOTag::writeBits16(TypeID, a2, (const __CFNumber *)this[4]);
      size_t v6 = 2;
      goto LABEL_21;
    case 4:
    case 9:
    case 0xD:
      if ((IIOTag *)v4 == TypeID)
      {
        void v17[3] = (uint64_t)this[2] + v21[3];
        int v7 = v13;
        v13[0] = MEMORY[0x1E4F143A8];
        v13[1] = 0x40000000;
        unsigned int v8 = &unk_1E53C09F0;
        uint64_t v9 = ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke_3;
        goto LABEL_13;
      }
      IIOTag::writeBits32(TypeID, a2, (const __CFNumber *)this[4]);
      size_t v6 = 4;
      goto LABEL_21;
    case 5:
    case 0xA:
      if ((IIOTag *)v4 == TypeID)
      {
        void v17[3] = (uint64_t)this[2] + v21[3];
        int v7 = v15;
        v15[0] = MEMORY[0x1E4F143A8];
        v15[1] = 0x40000000;
        unsigned int v8 = &unk_1E53BFC18;
        uint64_t v9 = ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke;
        goto LABEL_13;
      }
      IIOTag::writeRational(TypeID, a2, (const __CFNumber *)this[4]);
      goto LABEL_20;
    case 0x10:
    case 0x11:
    case 0x12:
      if ((IIOTag *)v4 == TypeID)
      {
        void v17[3] = (uint64_t)this[2] + v21[3];
        int v7 = v12;
        v12[0] = MEMORY[0x1E4F143A8];
        v12[1] = 0x40000000;
        unsigned int v8 = &unk_1E53C0A18;
        uint64_t v9 = ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke_4;
LABEL_13:
        v7[2] = v9;
        v7[3] = v8;
        v7[6] = this;
        v7[7] = a2;
        v7[4] = &v20;
        v7[5] = &v16;
        IIOArray::enumerate(0, (uint64_t)v7);
      }
      else
      {
        IIOTag::writeBits64(TypeID, a2, (const __CFNumber *)this[4]);
LABEL_20:
        size_t v6 = 8;
LABEL_21:
        v21[3] = v6;
      }
LABEL_14:
      uint64_t v10 = v21[3];
      _Block_object_dispose(&v16, 8);
      _Block_object_dispose(&v20, 8);
      return v10;
    default:
      _cg_jpeg_mem_term("writeData", 894, "*** unhandled tagType (%d) for tagID %d\n", *((unsigned __int16 *)this + 5), *((unsigned __int16 *)this + 4));
      goto LABEL_14;
  }
}

void sub_188637930(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10A1C4047070A01);
  _Block_object_dispose((const void *)(v2 - 112), 8);
  _Block_object_dispose((const void *)(v2 - 80), 8);
  _Unwind_Resume(a1);
}

size_t IIOTag::writeBytes(IIOTag *this, IIOWriteStream *a2)
{
  if (!*((unsigned char *)this + 40)) {
    goto LABEL_7;
  }
  CFTypeID TypeID = CFDataGetTypeID();
  if (TypeID == CFGetTypeID(*((CFTypeRef *)this + 4)))
  {
    CFDataRef Data = (const __CFData *)CFRetain(*((CFTypeRef *)this + 4));
    goto LABEL_8;
  }
  CFTypeID v6 = CFStringGetTypeID();
  if (v6 != CFGetTypeID(*((CFTypeRef *)this + 4)))
  {
LABEL_7:
    CFDataRef Data = CFPropertyListCreateData((CFAllocatorRef)*MEMORY[0x1E4F1CF80], *((CFPropertyListRef *)this + 4), kCFPropertyListBinaryFormat_v1_0, 0, 0);
LABEL_8:
    CFDataRef v10 = Data;
    if (!Data) {
      return 0;
    }
    unint64_t Length = CFDataGetLength(Data);
    size_t v12 = *((void *)this + 2);
    if (Length < v12) {
      size_t v12 = CFDataGetLength(v10);
    }
    BytePtr = (unsigned __int8 *)CFDataGetBytePtr(v10);
    IIOWriteStream::writeBytes(a2, BytePtr, v12);
    CFRelease(v10);
    return v12;
  }
  memset(v19, 0, sizeof(v19));
  IIOString::IIOString((IIOString *)v19, *((const void **)this + 4));
  int v7 = (const char *)IIOString::utf8String((IIOString *)v19);
  unsigned int v8 = (unsigned __int8 *)v7;
  if (v7) {
    unsigned int v9 = strlen(v7);
  }
  else {
    unsigned int v9 = 0;
  }
  size_t v14 = v9;
  size_t v12 = *((void *)this + 2);
  if (v12 - 1 <= v9)
  {
    if (v12 - 1 < v9)
    {
      LogError("writeBytes", 929, "*** ERROR: {MakerApple} tag-%d: expected string length: %d (got: %d) --> clipping\n", *((unsigned __int16 *)this + 4), v12 - 1, v9);
      size_t v12 = *((void *)this + 2);
    }
    IIOWriteStream::writeBytes(a2, v8, v12);
  }
  else
  {
    LogError("writeBytes", 936, "*** ERROR: {MakerApple} tag-%d: expected string length: %d (got: %d) --> padding\n", *((unsigned __int16 *)this + 4), v12 - 1, v9);
    IIOWriteStream::writeBytes(a2, v8, v14);
    unsigned __int8 v18 = 46;
    if (*((void *)this + 2) - 1 > v14)
    {
      unsigned int v15 = v14 + 1;
      do
        IIOWriteStream::writeBytes(a2, &v18, 1uLL);
      while (*((void *)this + 2) - 1 > (unint64_t)v15++);
    }
    unsigned __int8 v18 = 0;
    IIOWriteStream::writeBytes(a2, &v18, 1uLL);
    size_t v12 = 0;
  }
  IIOString::~IIOString((IIOString *)v19);
  return v12;
}

void sub_188637BD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIOString::~IIOString((IIOString *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke(uint64_t a1, const __CFNumber *a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = IIOTag::writeRational((IIOTag *)a1, *(IIOWriteStream **)(a1 + 56), a2);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += 8;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) >= *(void *)(*(void *)(*(void *)(a1 + 40) + 8)
                                                                                + 24))
    *a4 = 1;
  return result;
}

uint64_t IIOTag::writeRational(IIOTag *this, IIOWriteStream *a2, const __CFNumber *a3)
{
  IIONumber::IIONumber((IIONumber *)v7, a3);
  float v4 = IIONumber::floatNum((IIONumber *)v7);
  IIONumber::~IIONumber((IIONumber *)v7);
  unsigned int v6 = 1;
  v7[0] = 0;
  SRationalApprox(v4, (int *)v7, &v6);
  IIOWriteStream::write32((uint64_t)a2, v7[0]);
  IIOWriteStream::write32((uint64_t)a2, v6);
  return 8;
}

void sub_188637CE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke_2(uint64_t a1, const __CFNumber *a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = IIOTag::writeBits16((IIOTag *)a1, *(IIOWriteStream **)(a1 + 56), a2);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += 2;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) >= *(void *)(*(void *)(*(void *)(a1 + 40) + 8)
                                                                                + 24))
    *a4 = 1;
  return result;
}

uint64_t IIOTag::writeBits16(IIOTag *this, IIOWriteStream *a2, const __CFNumber *a3)
{
  IIONumber::IIONumber((IIONumber *)v6, a3);
  __int16 v4 = IIONumber::uint16Num((IIONumber *)v6);
  IIONumber::~IIONumber((IIONumber *)v6);
  IIOWriteStream::write16((uint64_t)a2, v4);
  return 2;
}

void sub_188637DB4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke_3(uint64_t a1, const __CFNumber *a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = IIOTag::writeBits32((IIOTag *)a1, *(IIOWriteStream **)(a1 + 56), a2);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += 4;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) >= *(void *)(*(void *)(*(void *)(a1 + 40) + 8)
                                                                                + 24))
    *a4 = 1;
  return result;
}

uint64_t IIOTag::writeBits32(IIOTag *this, IIOWriteStream *a2, const __CFNumber *a3)
{
  IIONumber::IIONumber((IIONumber *)v6, a3);
  unsigned int v4 = IIONumber::uint32Num((IIONumber *)v6);
  IIONumber::~IIONumber((IIONumber *)v6);
  IIOWriteStream::write32((uint64_t)a2, v4);
  return 4;
}

void sub_188637E88(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN6IIOTag9writeDataEP14IIOWriteStream_block_invoke_4(uint64_t a1, const __CFNumber *a2, uint64_t a3, unsigned char *a4)
{
  uint64_t result = IIOTag::writeBits64((IIOTag *)a1, *(IIOWriteStream **)(a1 + 56), a2);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += 8;
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) >= *(void *)(*(void *)(*(void *)(a1 + 40) + 8)
                                                                                + 24))
    *a4 = 1;
  return result;
}

uint64_t IIOTag::writeBits64(IIOTag *this, IIOWriteStream *a2, const __CFNumber *a3)
{
  IIONumber::IIONumber((IIONumber *)v6, a3);
  unint64_t v4 = IIONumber::uint64Num((IIONumber *)v6);
  IIONumber::~IIONumber((IIONumber *)v6);
  IIOWriteStream::write64((uint64_t)a2, v4);
  return 8;
}

void sub_188637F5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  IIONumber::~IIONumber((IIONumber *)va);
  _Unwind_Resume(a1);
}

void AppleMakerNoteWriter::AppleMakerNoteWriter(AppleMakerNoteWriter *this, const __CFDictionary *a2, char a3)
{
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *(void *)this = &unk_1ED4E4E70;
  *((void *)this + 1) = a2;
  *((unsigned char *)this + 16) = a3;
  memset(v5, 0, sizeof(v5));
  IIODictionary::IIODictionary((IIODictionary *)v5, a2);
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = ___ZN20AppleMakerNoteWriterC2EPK14__CFDictionaryb_block_invoke;
  v4[3] = &__block_descriptor_tmp_19;
  v4[4] = this;
  IIODictionary::enumerate((uint64_t)v5, v4);
  IIODictionary::~IIODictionary((IIODictionary *)v5);
}

void sub_18863803C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  IIODictionary::~IIODictionary((IIODictionary *)va);
  unsigned int v9 = *v7;
  if (*v7)
  {
    *(void *)(v6 + 32) = v9;
    operator delete(v9);
  }
  _Unwind_Resume(a1);
}

void ___ZN20AppleMakerNoteWriterC2EPK14__CFDictionaryb_block_invoke(int a1, IIOTag *this, void *a3)
{
  if ((void *)*MEMORY[0x1E4F1D260] != a3) {
    IIOTag::CreateTagWithProperty(this, a3, a3);
  }
}

void AppleMakerNoteWriter::~AppleMakerNoteWriter(AppleMakerNoteWriter *this)
{
  *(void *)this = &unk_1ED4E4E70;
  uint64_t v2 = (void *)*((void *)this + 3);
  CFStringRef v3 = (void *)*((void *)this + 4);
  if (v2 != v3)
  {
    do
    {
      if (*v2) {
        (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
      }
      ++v2;
    }
    while (v2 != v3);
    uint64_t v2 = (void *)*((void *)this + 3);
  }
  *((void *)this + 4) = v2;
  if (v2) {
    operator delete(v2);
  }
}

{
  uint64_t vars8;

  AppleMakerNoteWriter::~AppleMakerNoteWriter(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t AppleMakerNoteWriter::writePropertiesAndData(AppleMakerNoteWriter *this, IIOWriteStream *a2, IIOWriteStream *a3)
{
  IIOWriteStream::writeBytes(a2, "Apple iOS", 0xAuLL);
  IIOWriteStream::write16((uint64_t)a2, 1);
  if (*((unsigned char *)this + 16)) {
    __int16 v6 = 18761;
  }
  else {
    __int16 v6 = 19789;
  }
  IIOWriteStream::write16((uint64_t)a2, v6);
  IIOWriteStream::write16((uint64_t)a2, (*((_DWORD *)this + 8) - *((_DWORD *)this + 6)) >> 3);
  uint64_t v7 = *((void *)this + 3);
  unsigned int v8 = (char *)*((void *)this + 4);
  unint64_t v9 = 126 - 2 * __clz((uint64_t)&v8[-v7] >> 3);
  unsigned int v15 = IIOTag::TagCompare;
  if (v8 == (char *)v7) {
    uint64_t v10 = 0;
  }
  else {
    uint64_t v10 = v9;
  }
  std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **,false>(v7, v8, (uint64_t (**)(uint64_t, uint64_t))&v15, v10, 1);
  size_t v12 = (IIOTag **)*((void *)this + 3);
  int v11 = (IIOTag **)*((void *)this + 4);
  while (v12 != v11)
  {
    uint64_t v13 = *v12++;
    IIOTag::writePropertyAndData(v13, a2, a3);
  }
  return IIOWriteStream::write32((uint64_t)a2, 0);
}

void AppleMakerNoteWriter::writeToBuffer(AppleMakerNoteWriter *this, unsigned __int8 *__b, size_t a3)
{
  __int16 v6 = (uint64_t *)*((void *)this + 3);
  int v5 = (uint64_t *)*((void *)this + 4);
  uint64_t v7 = 12 * (v5 - v6) + 20;
  for (uint64_t i = a3 - v7; v6 != v5; *(void *)(v9 + 48) = v7)
    uint64_t v9 = *v6++;
  memset(__b, 85, a3);
  uint64_t v13 = 0;
  memset(v12, 0, sizeof(v12));
  IIOWriteStream::IIOWriteStream((IIOWriteStream *)v12, __b, v7, *((unsigned char *)this + 16));
  uint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  IIOWriteStream::IIOWriteStream((IIOWriteStream *)v10, &__b[v7], i, *((unsigned char *)this + 16));
  AppleMakerNoteWriter::writePropertiesAndData(this, (IIOWriteStream *)v12, (IIOWriteStream *)v10);
  IIOWriteStream::~IIOWriteStream((IIOWriteStream *)v10);
  IIOWriteStream::~IIOWriteStream((IIOWriteStream *)v12);
}

void sub_18863840C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

uint64_t AppleMakerNoteGetLength(const __CFDictionary *a1)
{
  long long v8 = 0u;
  long long v9 = 0u;
  long long v7 = 0u;
  AppleMakerNoteWriter::AppleMakerNoteWriter((AppleMakerNoteWriter *)&v7, a1, 0);
  if (*((void *)&v8 + 1) == (void)v9)
  {
    uint64_t v1 = 0;
  }
  else
  {
    uint64_t v1 = 0;
    uint64_t v2 = (uint64_t *)*((void *)&v8 + 1);
    do
    {
      uint64_t v3 = *v2++;
      unint64_t v4 = *(void *)(v3 + 16);
      if (v4 <= 4) {
        unint64_t v4 = 0;
      }
      v1 += v4;
    }
    while (v2 != (uint64_t *)v9);
  }
  uint64_t v5 = v1 + 12 * ((uint64_t)(v9 - *((void *)&v8 + 1)) >> 3) + 20;
  AppleMakerNoteWriter::~AppleMakerNoteWriter((AppleMakerNoteWriter *)&v7);
  return v5;
}

void AppleMakerNoteWriteToBuffer(const __CFDictionary *a1, unsigned __int8 *a2, size_t a3, char a4)
{
  kdebug_trace();
  memset(v8, 0, sizeof(v8));
  AppleMakerNoteWriter::AppleMakerNoteWriter((AppleMakerNoteWriter *)v8, a1, a4);
  AppleMakerNoteWriter::writeToBuffer((AppleMakerNoteWriter *)v8, a2, a3);
  kdebug_trace();
  AppleMakerNoteWriter::~AppleMakerNoteWriter((AppleMakerNoteWriter *)v8);
}

void sub_188638570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::vector<IIOTag *>::__throw_length_error[abi:ne180100]()
{
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E53BF798, MEMORY[0x1E4FBA1C8]);
}

void sub_1886385E4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  uint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D0] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  uint64_t v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E4FBA350], MEMORY[0x1E4FBA1F8]);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **,false>(uint64_t result, char *a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4, char a5)
{
  uint64_t v10 = (char *)result;
LABEL_2:
  uint64_t v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    uint64_t v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = a2 - v11;
    unint64_t v15 = (a2 - v11) >> 3;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t result = (*a3)(*((void *)a2 - 1), *(void *)v11);
          if (result)
          {
            uint64_t v22 = *(void *)v11;
            *(void *)uint64_t v11 = *((void *)a2 - 1);
            *((void *)a2 - 1) = v22;
          }
          break;
        case 3uLL:
          uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v11, (void *)v11 + 1, (void *)a2 - 1, (unsigned int (**)(void))a3);
          break;
        case 4uLL:
          uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v11, (void *)v11 + 1, (void *)v11 + 2, (void *)a2 - 1, (unsigned int (**)(void))a3);
          break;
        case 5uLL:
          uint64_t result = std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v11, (void *)v11 + 1, (void *)v11 + 2, (void *)v11 + 3, (void *)a2 - 1, (unsigned int (**)(void))a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 191) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **,IIOTag **>(v11, a2, (uint64_t *)a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    size_t v17 = &v11[8 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x401)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v11, &v11[8 * (v15 >> 1)], (void *)a2 - 1, (unsigned int (**)(void))a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((void *)v11 + 1, (void *)v17 - 1, (void *)a2 - 2, (unsigned int (**)(void))a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((void *)v11 + 2, &v11[8 * v16 + 8], (void *)a2 - 3, (unsigned int (**)(void))a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((void *)v17 - 1, v17, &v11[8 * v16 + 8], (unsigned int (**)(void))a3);
      uint64_t v18 = *(void *)v11;
      *(void *)uint64_t v11 = *(void *)v17;
      *(void *)size_t v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(&v11[8 * (v15 >> 1)], v11, (void *)a2 - 1, (unsigned int (**)(void))a3);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (((*a3)(*((void *)v11 - 1), *(void *)v11) & 1) == 0)
    {
      uint64_t result = (uint64_t)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,IIOTag **,BOOL (*&)(IIOTag *,IIOTag *)>((uint64_t *)v11, (uint64_t *)a2, a3);
      uint64_t v11 = (char *)result;
      goto LABEL_19;
    }
LABEL_14:
    uint64_t v19 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,IIOTag **,BOOL (*&)(IIOTag *,IIOTag *)>((uint64_t *)v11, (uint64_t *)a2, a3);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v11, v19, (unsigned int (**)(void))a3);
    uint64_t v11 = (char *)(v19 + 1);
    uint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(v19 + 1, a2, (unsigned int (**)(void))a3);
    if (result)
    {
      a4 = -v13;
      a2 = (char *)v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      uint64_t result = std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **,false>(v10, v19, a3, -v13, a5 & 1);
      uint64_t v11 = (char *)(v19 + 1);
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((uint64_t)v11, (uint64_t *)a2, a3);
  }
  else
  {
    return std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((uint64_t)v11, a2, a3);
  }
}

uint64_t std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(uint64_t result, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  if ((uint64_t *)result != a2)
  {
    unint64_t v4 = (void *)result;
    char v5 = (uint64_t *)(result + 8);
    if ((uint64_t *)(result + 8) != a2)
    {
      uint64_t v7 = 0;
      long long v8 = (uint64_t *)result;
      do
      {
        uint64_t v10 = *v8;
        uint64_t v9 = v8[1];
        long long v8 = v5;
        uint64_t result = (*a3)(v9, v10);
        if (result)
        {
          uint64_t v11 = *v8;
          uint64_t v12 = v7;
          while (1)
          {
            *(void *)((char *)v4 + v12 + 8) = *(void *)((char *)v4 + v12);
            if (!v12) {
              break;
            }
            uint64_t result = (*a3)(v11, *(void *)((char *)v4 + v12 - 8));
            v12 -= 8;
            if ((result & 1) == 0)
            {
              uint64_t v13 = (void *)((char *)v4 + v12 + 8);
              goto LABEL_10;
            }
          }
          uint64_t v13 = v4;
LABEL_10:
          void *v13 = v11;
        }
        char v5 = v8 + 1;
        v7 += 8;
      }
      while (v8 + 1 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(uint64_t result, void *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  if ((void *)result != a2)
  {
    unint64_t v4 = (void *)result;
    for (uint64_t i = (void *)(result + 8); v4 + 1 != a2; uint64_t i = v4 + 1)
    {
      uint64_t v8 = *v4;
      uint64_t v7 = v4[1];
      unint64_t v4 = i;
      uint64_t result = (*a3)(v7, v8);
      if (result)
      {
        uint64_t v9 = *v4;
        uint64_t v10 = v4;
        do
        {
          uint64_t v11 = v10;
          uint64_t v12 = *--v10;
          *uint64_t v11 = v12;
          uint64_t result = (*a3)(v9, *(v11 - 2));
        }
        while ((result & 1) != 0);
        void *v10 = v9;
      }
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(void *a1, void *a2, void *a3, unsigned int (**a4)(void))
{
  char v8 = ((uint64_t (*)(void, void))*a4)(*a2, *a1);
  uint64_t result = ((uint64_t (*)(void, void))*a4)(*a3, *a2);
  if ((v8 & 1) == 0)
  {
    if (!result) {
      return result;
    }
    uint64_t v11 = *a2;
    *a2 = *a3;
    *a3 = v11;
    if (!((unsigned int (*)(void, void))*a4)(*a2, *a1)) {
      return 1;
    }
    uint64_t v12 = *a1;
    *a1 = *a2;
    *a2 = v12;
    return 2;
  }
  uint64_t v10 = *a1;
  if (!result)
  {
    *a1 = *a2;
    *a2 = v10;
    if (!(*a4)(*a3)) {
      return 1;
    }
    uint64_t v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    return 2;
  }
  *a1 = *a3;
  *a3 = v10;
  return 1;
}

uint64_t *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,IIOTag **,BOOL (*&)(IIOTag *,IIOTag *)>(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  unint64_t v4 = a2;
  uint64_t v6 = *a1;
  if ((*a3)(*a1, *(a2 - 1)))
  {
    uint64_t v7 = a1;
    do
    {
      uint64_t v8 = v7[1];
      ++v7;
    }
    while (((*a3)(v6, v8) & 1) == 0);
  }
  else
  {
    uint64_t v9 = a1 + 1;
    do
    {
      uint64_t v7 = v9;
      if (v9 >= v4) {
        break;
      }
      ++v9;
    }
    while (!(*a3)(v6, *v7));
  }
  if (v7 < v4)
  {
    do
      uint64_t v10 = *--v4;
    while (((*a3)(v6, v10) & 1) != 0);
  }
  while (v7 < v4)
  {
    uint64_t v11 = *v7;
    uint64_t *v7 = *v4;
    uint64_t *v4 = v11;
    do
    {
      uint64_t v12 = v7[1];
      ++v7;
    }
    while (!(*a3)(v6, v12));
    do
      uint64_t v13 = *--v4;
    while (((*a3)(v6, v13) & 1) != 0);
  }
  if (v7 - 1 != a1) {
    *a1 = *(v7 - 1);
  }
  *(v7 - 1) = v6;
  return v7;
}

uint64_t *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,IIOTag **,BOOL (*&)(IIOTag *,IIOTag *)>(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t))
{
  uint64_t v6 = 0;
  uint64_t v7 = *a1;
  do
    char v8 = (*a3)(a1[++v6], v7);
  while ((v8 & 1) != 0);
  uint64_t v9 = &a1[v6];
  uint64_t v10 = &a1[v6 - 1];
  if (v6 == 1)
  {
    do
    {
      if (v9 >= a2) {
        break;
      }
      uint64_t v12 = *--a2;
    }
    while (((*a3)(v12, v7) & 1) == 0);
  }
  else
  {
    do
      uint64_t v11 = *--a2;
    while (!(*a3)(v11, v7));
  }
  if (v9 < a2)
  {
    uint64_t v13 = a2;
    uint64_t v14 = v9;
    do
    {
      uint64_t v15 = *v14;
      uint64_t *v14 = *v13;
      uint64_t *v13 = v15;
      do
      {
        uint64_t v16 = v14[1];
        ++v14;
      }
      while (((*a3)(v16, v7) & 1) != 0);
      do
        uint64_t v17 = *--v13;
      while (!(*a3)(v17, v7));
    }
    while (v14 < v13);
    uint64_t v10 = v14 - 1;
  }
  if (v10 != a1) {
    *a1 = *v10;
  }
  uint64_t *v10 = v7;
  return v10;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(void *a1, void *a2, unsigned int (**a3)(void))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (((unsigned int (*)(void, void))*a3)(*(a2 - 1), *a1))
      {
        uint64_t v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v9 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a1 + 1, a1 + 2, a3);
      uint64_t v10 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    if (((unsigned int (*)(void, void))*a3)(*v10, *v9))
    {
      uint64_t v13 = *v10;
      uint64_t v14 = v11;
      while (1)
      {
        uint64_t v15 = (char *)a1 + v14;
        *(void *)((char *)a1 + v14 + 24) = *(void *)((char *)a1 + v14 + 16);
        if (v14 == -16) {
          break;
        }
        v14 -= 8;
        if ((((uint64_t (*)(uint64_t, void))*a3)(v13, *((void *)v15 + 1)) & 1) == 0)
        {
          uint64_t v16 = (void *)((char *)a1 + v14 + 24);
          goto LABEL_12;
        }
      }
      uint64_t v16 = a1;
LABEL_12:
      void *v16 = v13;
      if (++v12 == 8) {
        return v10 + 1 == a2;
      }
    }
    uint64_t v9 = v10;
    v11 += 8;
    if (++v10 == a2) {
      return 1;
    }
  }
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(void *a1, void *a2, void *a3, void *a4, unsigned int (**a5)(void))
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a2, a3, a5);
  uint64_t result = ((uint64_t (*)(void, void))*a5)(*a4, *a3);
  if (result)
  {
    uint64_t v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    uint64_t result = ((uint64_t (*)(void, void))*a5)(*a3, *a2);
    if (result)
    {
      uint64_t v12 = *a2;
      *a2 = *a3;
      *a3 = v12;
      uint64_t result = ((uint64_t (*)(void, void))*a5)(*a2, *a1);
      if (result)
      {
        uint64_t v13 = *a1;
        *a1 = *a2;
        *a2 = v13;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(void *a1, void *a2, void *a3, void *a4, void *a5, unsigned int (**a6)(void))
{
  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, a2, a3, a4, a6);
  uint64_t result = ((uint64_t (*)(void, void))*a6)(*a5, *a4);
  if (result)
  {
    uint64_t v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    uint64_t result = ((uint64_t (*)(void, void))*a6)(*a4, *a3);
    if (result)
    {
      uint64_t v14 = *a3;
      *a3 = *a4;
      *a4 = v14;
      uint64_t result = ((uint64_t (*)(void, void))*a6)(*a3, *a2);
      if (result)
      {
        uint64_t v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
        uint64_t result = ((uint64_t (*)(void, void))*a6)(*a2, *a1);
        if (result)
        {
          uint64_t v16 = *a1;
          *a1 = *a2;
          *a2 = v16;
        }
      }
    }
  }
  return result;
}

uint64_t *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **,IIOTag **>(char *a1, char *a2, uint64_t *a3, uint64_t (**a4)(uint64_t, uint64_t))
{
  if (a1 != a2)
  {
    uint64_t v8 = a2 - a1;
    uint64_t v9 = (a2 - a1) >> 3;
    if (a2 - a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[8 * v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((uint64_t)a1, (unsigned int (**)(void, void))a4, v9, v12);
        v12 -= 8;
        --v11;
      }
      while (v11);
    }
    uint64_t v13 = a2;
    if (a2 != (char *)a3)
    {
      uint64_t v14 = (uint64_t *)a2;
      do
      {
        if ((*a4)(*v14, *(void *)a1))
        {
          uint64_t v15 = *v14;
          uint64_t *v14 = *(void *)a1;
          *(void *)a1 = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((uint64_t)a1, (unsigned int (**)(void, void))a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      uint64_t v13 = (char *)a3;
    }
    if (v8 >= 9)
    {
      uint64_t v16 = (unint64_t)v8 >> 3;
      uint64_t v17 = a2 - 8;
      do
      {
        uint64_t v18 = *(void *)a1;
        uint64_t v19 = (char *)std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(a1, (unsigned int (**)(void, void))a4, v16);
        if (v17 == v19)
        {
          *(void *)uint64_t v19 = v18;
        }
        else
        {
          *(void *)uint64_t v19 = *(void *)v17;
          *(void *)uint64_t v17 = v18;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>((uint64_t)a1, (uint64_t)(v19 + 8), a4, (v19 + 8 - a1) >> 3);
        }
        v17 -= 8;
      }
      while (v16-- > 2);
    }
    return (uint64_t *)v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(uint64_t result, unsigned int (**a2)(void, void), uint64_t a3, void *a4)
{
  unint64_t v4 = a3 - 2;
  if (a3 >= 2)
  {
    char v5 = a4;
    uint64_t v6 = result;
    int64_t v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v10 = ((uint64_t)a4 - result) >> 2;
      uint64_t v11 = v10 + 1;
      uint64_t v12 = (void *)(result + 8 * (v10 + 1));
      uint64_t v13 = v10 + 2;
      if (v10 + 2 < a3 && (*a2)(*v12, v12[1]))
      {
        ++v12;
        uint64_t v11 = v13;
      }
      uint64_t result = ((uint64_t (*)(void, void))*a2)(*v12, *v5);
      if ((result & 1) == 0)
      {
        uint64_t v14 = *v5;
        do
        {
          uint64_t v15 = v12;
          void *v5 = *v12;
          if (v7 < v11) {
            break;
          }
          uint64_t v16 = (2 * v11) | 1;
          uint64_t v12 = (void *)(v6 + 8 * v16);
          if (2 * v11 + 2 < a3)
          {
            if ((*a2)(*v12, v12[1]))
            {
              ++v12;
              uint64_t v16 = 2 * v11 + 2;
            }
          }
          uint64_t result = ((uint64_t (*)(void, uint64_t))*a2)(*v12, v14);
          char v5 = v15;
          uint64_t v11 = v16;
        }
        while (!result);
        void *v15 = v14;
      }
    }
  }
  return result;
}

void *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(void *a1, unsigned int (**a2)(void, void), uint64_t a3)
{
  uint64_t v6 = 0;
  uint64_t v7 = a3 - 2;
  if (a3 < 2) {
    uint64_t v7 = a3 - 1;
  }
  uint64_t v8 = v7 >> 1;
  do
  {
    uint64_t v9 = &a1[v6 + 1];
    uint64_t v10 = (2 * v6) | 1;
    uint64_t v11 = 2 * v6 + 2;
    if (v11 < a3 && (*a2)(a1[v6 + 1], a1[v6 + 2]))
    {
      ++v9;
      uint64_t v10 = v11;
    }
    *a1 = *v9;
    a1 = v9;
    uint64_t v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(IIOTag *,IIOTag *),IIOTag **>(uint64_t result, uint64_t a2, uint64_t (**a3)(uint64_t, uint64_t), uint64_t a4)
{
  unint64_t v4 = a4 - 2;
  if (a4 >= 2)
  {
    uint64_t v6 = result;
    unint64_t v7 = v4 >> 1;
    uint64_t v8 = (uint64_t *)(result + 8 * (v4 >> 1));
    uint64_t v9 = (uint64_t *)(a2 - 8);
    uint64_t result = (*a3)(*v8, *(void *)(a2 - 8));
    if (result)
    {
      uint64_t v10 = *v9;
      do
      {
        uint64_t v11 = v8;
        uint64_t *v9 = *v8;
        if (!v7) {
          break;
        }
        unint64_t v7 = (v7 - 1) >> 1;
        uint64_t v8 = (uint64_t *)(v6 + 8 * v7);
        uint64_t result = (*a3)(*v8, v10);
        uint64_t v9 = v11;
      }
      while ((result & 1) != 0);
      *uint64_t v11 = v10;
    }
  }
  return result;
}

void kd_roi_level_node::~kd_roi_level_node(kd_roi_level_node *this)
{
  *(void *)this = &unk_1ED4E44B0;
  if (*((unsigned char *)this + 17)) {
    __assert_rtn("~kd_roi_level_node", "roi.cpp", 55, "!active");
  }
  if (*((void *)this + 5))
  {
    int v2 = *((_DWORD *)this + 7);
    if (v2 < 1) {
      goto LABEL_9;
    }
    for (uint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(void *)(*((void *)this + 5) + 8 * i);
      if (v4)
      {
        MEMORY[0x18C11C0C0](v4, 0x1000C8077774924);
        int v2 = *((_DWORD *)this + 7);
      }
    }
    if (*((void *)this + 5)) {
LABEL_9:
    }
      MEMORY[0x18C11C0C0]();
  }
  *(void *)this = &unk_1ED4DF4B0;
}

{
  uint64_t vars8;

  kd_roi_level_node::~kd_roi_level_node(this);

  JUMPOUT(0x18C11C0E0);
}

void *kd_roi_level_node::pull(kd_roi_level_node *this, unsigned __int8 *__dst, int a3)
{
  if (!*((unsigned char *)this + 17) || *((_DWORD *)this + 5) != a3 || *((int *)this + 6) < 1) {
    kd_roi_level_node::pull();
  }
  while (!*((_DWORD *)this + 9))
    kd_roi_level::advance(*((kd_roi_level **)this + 1));
  uint64_t result = memcpy(__dst, *(const void **)(*((void *)this + 5) + 8 * *((int *)this + 8)), a3);
  int v7 = *((_DWORD *)this + 8);
  int v8 = *((_DWORD *)this + 9) - 1;
  int v9 = *((_DWORD *)this + 6);
  if (v7 + 1 == *((_DWORD *)this + 7)) {
    int v10 = 0;
  }
  else {
    int v10 = v7 + 1;
  }
  *((_DWORD *)this + 8) = v10;
  *((_DWORD *)this + 9) = v8;
  *((_DWORD *)this + 6) = v9 - 1;
  return result;
}

unsigned char *kd_roi_level::advance(kd_roi_level *this)
{
  if (!*(void *)this) {
    kd_roi_level::advance();
  }
  int v2 = *((_DWORD *)this + 12);
  int v3 = *((_DWORD *)this + 14) + v2;
  int v4 = *((_DWORD *)this + 16);
  if (v4 >= v3) {
    kd_roi_level::advance();
  }
  if (*((unsigned char *)this + 108))
  {
    char v5 = (char *)this + 8 * (v4 & 1);
    int v6 = *((_DWORD *)v5 + 19) + v4;
    int v7 = *((_DWORD *)v5 + 23) + v4;
    if (v6 <= v2) {
      int v4 = *((_DWORD *)this + 12);
    }
    else {
      int v4 = v6;
    }
    if (v7 >= v3) {
      int v8 = v3 - 1;
    }
    else {
      int v8 = v7;
    }
    if (v8 - v4 + 1 > *((_DWORD *)this + 28)) {
      kd_roi_level::advance();
    }
  }
  else
  {
    int v8 = *((_DWORD *)this + 16);
  }
  int v10 = *((_DWORD *)this + 17);
  int v9 = *((_DWORD *)this + 18);
  if (v8 >= v9 + v10)
  {
    int v11 = *((_DWORD *)this + 28);
    do
    {
      int v12 = *((_DWORD *)this + 29) + v9;
      if (v12 < v11) {
        int v11 = 0;
      }
      (*(void (**)(void, void, void))(**(void **)this + 24))(*(void *)this, *(void *)(*((void *)this + 15) + 8 * (v12 - v11)), *((unsigned int *)this + 15));
      int v9 = *((_DWORD *)this + 18);
      int v11 = *((_DWORD *)this + 28);
      if (v9 == v11)
      {
        int v13 = *((_DWORD *)this + 29) + 1;
        *((_DWORD *)this + 29) = v13;
        int v10 = *((_DWORD *)this + 17) + 1;
        *((_DWORD *)this + 17) = v10;
        if (v13 == v9) {
          *((_DWORD *)this + 29) = 0;
        }
      }
      else
      {
        *((_DWORD *)this + 18) = ++v9;
        int v10 = *((_DWORD *)this + 17);
      }
    }
    while (v8 >= v9 + v10);
  }
  if (v4 - v10 < 0) {
    kd_roi_level::advance();
  }
  int v14 = *((_DWORD *)this + 29) + v4 - v10;
  if (v14 >= *((_DWORD *)this + 28)) {
    int v15 = *((_DWORD *)this + 28);
  }
  else {
    int v15 = 0;
  }
  int v16 = v14 - v15;
  uint64_t result = memcpy(*((void **)this + 16), *(const void **)(*((void *)this + 15) + 8 * (v14 - v15)), *((int *)this + 15));
  if (v4 < v8)
  {
    do
    {
      if (v16 + 1 == *((_DWORD *)this + 28)) {
        int v16 = 0;
      }
      else {
        ++v16;
      }
      int v18 = *((_DWORD *)this + 15);
      if (v18 >= 1)
      {
        uint64_t v19 = (unsigned char *)*((void *)this + 16);
        char v20 = *(char **)(*((void *)this + 15) + 8 * v16);
        unsigned int v21 = v18 + 1;
        do
        {
          char v22 = *v20++;
          *v19++ |= v22;
          --v21;
        }
        while (v21 > 1);
      }
      ++v4;
    }
    while (v4 != v8);
  }
  if (*((unsigned char *)this + 108)) {
    unsigned int v23 = 2 * (*((_DWORD *)this + 16) & 1);
  }
  else {
    unsigned int v23 = 0;
  }
  if (*((unsigned char *)this + 109))
  {
    uint64_t v24 = 0;
    uint64_t v25 = v23;
    char v26 = 1;
    do
    {
      char v27 = v26;
      if (!*((unsigned char *)this + v25 + 40))
      {
        BOOL v28 = (kd_roi_level_node *)*((void *)this + v25 + 1);
        if (!v28) {
          kd_roi_level::advance();
        }
        uint64_t result = (unsigned char *)kd_roi_level_node::advance(v28);
        if (result)
        {
          BOOL v29 = (char *)this + 8 * v24;
          uint64_t v30 = *((int *)v29 + 20);
          int v31 = *((_DWORD *)v29 + 24);
          int v32 = *((_DWORD *)this + 13);
          uint64_t v33 = ((_BYTE)v32 + (_BYTE)v24) & 1;
          LODWORD(v34) = *((_DWORD *)this + 15) + ~v33;
          int v35 = ((int)v34 >> 1) + 1;
          uint64_t v36 = *((void *)this + 16);
          uint64_t v37 = v36 + v33;
          if ((v34 & 0x80000000) != 0 || ((v33 + v30) & 0x80000000) == 0)
          {
            int v44 = ((int)v34 >> 1) + 1;
          }
          else
          {
            uint64_t v38 = v23 ^ v32;
            uint64_t v39 = v38 << 63 >> 63;
            uint64_t v40 = v36 + v33 - (v38 & 1);
            do
            {
              char v41 = 0;
              if (v31 >= (int)v34) {
                int v42 = v34;
              }
              else {
                int v42 = v31;
              }
              if (v42 >= -(int)v33)
              {
                uint64_t v43 = 0;
                char v41 = 0;
                do
                  v41 |= *(unsigned char *)(v40 + v43++);
                while (v39 + v43 - 1 < v42);
              }
              *result++ = v41;
              int v44 = v35 - 1;
              LODWORD(v34) = v34 - 2;
              v37 += 2;
              if (v35 <= 1) {
                break;
              }
              LODWORD(v33) = v33 + 2;
              v39 -= 2;
              --v35;
            }
            while (v33 + v30 < 0);
          }
          if (v44 < 1 || (int)v34 < v31)
          {
            int v48 = v44;
          }
          else
          {
            do
            {
              if ((int)v30 <= v31)
              {
                char v45 = 0;
                int v46 = v31 - v30 + 1;
                uint64_t v47 = v30;
                do
                {
                  v45 |= *(unsigned char *)(v37 + v47++);
                  --v46;
                }
                while (v46);
              }
              else
              {
                char v45 = 0;
              }
              *result++ = v45;
              int v48 = v44 - 1;
              LODWORD(v34) = v34 - 2;
              v37 += 2;
              if (v44 <= 1) {
                break;
              }
              --v44;
            }
            while ((int)v34 >= v31);
          }
          if (v48 >= 1)
          {
            uint64_t v34 = (int)v34;
            do
            {
              if (v34 >= v30)
              {
                char v49 = 0;
                uint64_t v50 = v30;
                do
                  v49 |= *(unsigned char *)(v37 + v50);
                while (v50++ < v34);
              }
              else
              {
                char v49 = 0;
              }
              *result++ = v49;
              v34 -= 2;
              v37 += 2;
              BOOL v52 = __OFSUB__(v48--, 1);
            }
            while (!((v48 < 0) ^ v52 | (v48 == 0)));
          }
        }
      }
      char v26 = 0;
      ++v25;
      ++v23;
      uint64_t v24 = 1;
    }
    while ((v27 & 1) != 0);
  }
  else
  {
    unint64_t v53 = (kd_roi_level_node *)*((void *)this + v23 + 1);
    if (!v53) {
      kd_roi_level::advance();
    }
    uint64_t result = (unsigned char *)kd_roi_level_node::advance(v53);
    if (result) {
      uint64_t result = memcpy(result, *((const void **)this + 16), *((int *)this + 15));
    }
  }
  ++*((_DWORD *)this + 16);
  if (*((_DWORD *)this + 11) == 4)
  {
    uint64_t result = (unsigned char *)(*(uint64_t (**)(void))(**(void **)this + 16))();
    *(void *)this = 0;
  }
  return result;
}

uint64_t kd_roi_level_node::advance(kd_roi_level_node *this)
{
  if (*((unsigned char *)this + 17))
  {
    int v2 = *((_DWORD *)this + 9);
    if (*((_DWORD *)this + 6) <= v2) {
      kd_roi_level_node::advance();
    }
    int v3 = *((_DWORD *)this + 7);
    if (v2 == v3) {
      operator new[]();
    }
    int v5 = *((_DWORD *)this + 9);
    int v6 = *((_DWORD *)this + 8) + v5;
    if (v6 >= v3) {
      int v7 = *((_DWORD *)this + 7);
    }
    else {
      int v7 = 0;
    }
    *((_DWORD *)this + 9) = v5 + 1;
    return *(void *)(*((void *)this + 5) + 8 * (v6 - v7));
  }
  else
  {
    uint64_t result = 0;
    *((unsigned char *)this + 16) = 0;
  }
  return result;
}

_DWORD *kd_roi_level_node::release(kd_roi_level_node *this)
{
  *((_WORD *)this + 8) = 0;
  return kd_roi_level::notify_release(*((_DWORD **)this + 1), this);
}

_DWORD *kd_roi_level::notify_release(_DWORD *this, kd_roi_level_node *a2)
{
  int v2 = this;
  uint64_t v3 = 0;
  while (*(kd_roi_level_node **)&this[2 * v3 + 2] != a2)
  {
    if (++v3 == 4) {
      goto LABEL_9;
    }
  }
  int v4 = (char *)this + v3;
  if (v4[40]) {
LABEL_9:
  }
    kd_roi_level::notify_release();
  v4[40] = 1;
  int v5 = this[11] + 1;
  this[11] = v5;
  if (v5 == 4)
  {
    this = (_DWORD *)(*(uint64_t (**)(void))(**(void **)this + 16))();
    *int v2 = 0;
  }
  return this;
}

void kdu_roi_level::create()
{
}

void sub_188639E5C(void *a1)
{
  __cxa_begin_catch(a1);
  if (*v1) {
    kdu_roi_level::create(*v1);
  }
  std::bad_array_new_length *v1 = 0;
  __cxa_rethrow();
}

void sub_188639E78(_Unwind_Exception *a1)
{
}

void kd_roi_level::init(int32x4_t *a1, int32x4_t *a2, uint64_t a3)
{
  int v18 = a2;
  a1->i64[0] = a3;
  kdu_node::get_dims(&v18, a1 + 3);
  uint64_t v4 = 0;
  a1[2].i32[3] = 0;
  while (1)
  {
    uint64_t v17 = (int32x4_t *)kdu_node::access_child((kdu_node *)&v18, v4);
    if (v17) {
      break;
    }
    ++a1[2].i32[3];
    a1->i64[v4 + 1] = 0;
    a1[2].i8[v4++ + 8] = 1;
    if (v4 == 4)
    {
      uint64_t v6 = a1[1].i64[0];
      uint64_t v5 = a1[1].i64[1];
      a1[6].i8[13] = v6 != 0;
      int v7 = v5 != 0;
      a1[6].i8[12] = v7;
      float v15 = 0.0;
      v16.i32[0] = 0;
      LODWORD(v17) = 0;
      *(_WORD *)int v14 = 0;
      if (v6)
      {
        kdu_node::get_kernel_info((kdu_node *)&v18, v16.i32, (float *)&v17, &v15, &v14[1], v14, a1[5].i32, a1[6].i32, &a1[5].i32[2], &a1[6].i32[2], 0);
        int v7 = a1[6].u8[12];
      }
      int v8 = 1;
      if (v7)
      {
        kdu_node::get_kernel_info((kdu_node *)&v18, v16.i32, (float *)&v17, &v15, &v14[1], v14, &a1[4].i32[3], &a1[5].i32[3], &a1[5].i32[1], &a1[6].i32[1], 1);
        uint64_t v9 = 0;
        int v10 = 0;
        do
        {
          char v11 = v8;
          int v12 = &a1->i8[8 * v9];
          if (v10 <= *((_DWORD *)v12 + 23)) {
            int v10 = *((_DWORD *)v12 + 23);
          }
          int v13 = *((_DWORD *)v12 + 19);
          if (v10 <= -v13) {
            int v10 = -v13;
          }
          uint64_t v9 = 1;
          LOBYTE(v8) = 0;
        }
        while ((v11 & 1) != 0);
        int v8 = (2 * v10) | 1;
      }
      a1[7].i32[0] = v8;
      operator new[]();
    }
  }
  int32x4_t v16 = 0uLL;
  kdu_node::get_dims(&v17, &v16);
  operator new();
}

kd_roi_level *kdu_roi_level::destroy(kd_roi_level **this)
{
  uint64_t result = *this;
  if (result)
  {
    kd_roi_level::~kd_roi_level(result);
    uint64_t result = (kd_roi_level *)MEMORY[0x18C11C0E0]();
  }
  *this = 0;
  return result;
}

uint64_t kdu_roi_level::acquire_node(kdu_roi_level *this, unsigned int a2)
{
  if (a2 >= 4) {
    kdu_roi_level::acquire_node();
  }
  uint64_t result = *(void *)(*(void *)this + 8 * a2 + 8);
  if (result)
  {
    if (!*(unsigned char *)(result + 16)) {
      kdu_roi_level::acquire_node();
    }
    *(_WORD *)(result + 16) = 256;
  }
  return result;
}

void kd_roi_level::~kd_roi_level(kd_roi_level *this)
{
  for (uint64_t i = 8; i != 40; i += 8)
  {
    uint64_t v3 = *(void *)((char *)this + i);
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  if (*((void *)this + 15))
  {
    int v4 = *((_DWORD *)this + 28);
    if (v4 < 1) {
      goto LABEL_12;
    }
    for (uint64_t j = 0; j < v4; ++j)
    {
      uint64_t v6 = *(void *)(*((void *)this + 15) + 8 * j);
      if (v6)
      {
        MEMORY[0x18C11C0C0](v6, 0x1000C8077774924);
        int v4 = *((_DWORD *)this + 28);
      }
    }
    if (*((void *)this + 15)) {
LABEL_12:
    }
      MEMORY[0x18C11C0C0]();
  }
  uint64_t v7 = *((void *)this + 16);
  if (v7) {
    MEMORY[0x18C11C0C0](v7, 0x1000C8077774924);
  }
  if (*(void *)this) {
    (*(void (**)(void))(**(void **)this + 16))(*(void *)this);
  }
}

uint64_t kd_tile::kd_tile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(void *)(a1 + 104) = 0;
  uint64_t v10 = a1 + 104;
  *(_DWORD *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 212) = 0u;
  *(_OWORD *)(a1 + 228) = 0u;
  *(void *)(a1 + 244) = 0;
  *(void *)a1 = a2;
  *(void *)(a1 + 24) = a3;
  if (*(void *)(a3 + 16))
  {
    uint64_t v14 = 0;
    memset(v13, 0, sizeof(v13));
    kdu_error::kdu_error((kdu_error *)v13, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v13[0] + 16))(v13, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v13[0] + 16))(v13, "tref->tile == NULL");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v13[0] + 16))(v13, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v13);
  }
  *(void *)(a1 + 12) = a4;
  *(_DWORD *)(a1 + 8) = HIDWORD(a4) + *(_DWORD *)(a2 + 224) * a4;
  *(unsigned char *)(a1 + 184) = 0;
  *(unsigned char *)(a1 + 288) = 0;
  *(void *)(a1 + 32) = 0;
  uint64_t v11 = *(void *)(a2 + 8);
  if (v11 && ((*(uint64_t (**)(void))(**(void **)(v11 + 552) + 24))(*(void *)(v11 + 552)) & 2) != 0) {
    kd_precinct_pointer_server::initialize(v10, *(kd_buf_server **)(a2 + 48));
  }
  *(void *)(a1 + 212) = a5;
  *(void *)(a1 + 220) = a6;
  *(void *)(a1 + 236) = 0;
  *(unsigned char *)(a1 + 328) = 0;
  *(unsigned char *)(a1 + 287) = 0;
  *(_DWORD *)(a1 + 320) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(void *)(a1 + 256) = 0;
  *(unsigned char *)(a1 + 297) = 0;
  *(void *)(a1 + 289) = 0;
  *(unsigned char *)(a1 + 316) = 0;
  *(void *)(a1 + 308) = 0;
  *(void *)(a1 + 300) = 0;
  return a1;
}

void sub_18863A4B8(_Unwind_Exception *a1)
{
  kd_precinct_pointer_server::disable(v1);
  _Unwind_Resume(a1);
}

uint64_t kd_precinct_pointer_server::initialize(uint64_t this, kd_buf_server *a2)
{
  if (*(void *)this) {
    kd_precinct_pointer_server::initialize();
  }
  *(void *)(this + 40) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(_DWORD *)(this + 56) = 0;
  *(_WORD *)(this + 60) = 0;
  *(_DWORD *)(this + 72) = 0;
  *(void *)this = a2;
  *(void *)(this + 8) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  *(_DWORD *)(this + 32) = 0;
  return this;
}

void kd_tile::~kd_tile(kd_tile *this)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (*(kd_tile **)(*(void *)this + 440) == this)
  {
    *(void *)&long long v20 = 0;
    *(_OWORD *)int v18 = 0u;
    long long v19 = 0u;
    kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "Assert ");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "this != codestream->active_tile");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  if (*((unsigned char *)this + 288)) {
    kd_tile::remove_from_in_progress_list((uint64_t *)this);
  }
  int v2 = (kd_pp_markers *)*((void *)this + 10);
  if (v2)
  {
    kd_pp_markers::~kd_pp_markers(v2);
    MEMORY[0x18C11C0E0]();
  }
  uint64_t v3 = *((void *)this + 11);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  if (*((void *)this + 3))
  {
    int v4 = **(kdu_message ***)this;
    if (!v4 || *((unsigned char *)this + 287)) {
      goto LABEL_17;
    }
    (*(void (**)(void, const char *))(*(void *)v4 + 16))(**(void **)this, "\n>> New attributes for tile ");
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    *(_OWORD *)int v18 = 0u;
    if (*((unsigned char *)v4 + 8)) {
      sprintf(v18, "%x");
    }
    else {
      sprintf(v18, "%d");
    }
    (*(void (**)(kdu_message *, char *))(*(void *)v4 + 16))(v4, v18);
    (*(void (**)(kdu_message *, const char *))(*(void *)v4 + 16))(v4, ":\n");
    kdu_params::textualize_attributes(*(void *)(*(void *)this + 24), v4, *((_DWORD *)this + 2), *((_DWORD *)this + 2), 1);
    (*(void (**)(kdu_message *, void))(*(void *)v4 + 32))(v4, 0);
    if (*((void *)this + 3))
    {
LABEL_17:
      if (!*((unsigned char *)this + 287) && !*((unsigned char *)this + 290))
      {
        for (int i = 1; ; ++i)
        {
          int32x4_t v16 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(*(void *)this + 24), i);
          if (!v16) {
            break;
          }
          uint64_t v17 = kdu_params::access_unique(v16, *((_DWORD *)this + 2), -1, 0);
          if (v17) {
            (*(void (**)(uint64_t))(*(void *)v17 + 16))(v17);
          }
        }
      }
    }
  }
  uint64_t v5 = *((void *)this + 12);
  if (v5) {
    MEMORY[0x18C11C0E0](v5, 0x1020C40539952E0);
  }
  uint64_t v6 = *((void *)this + 34);
  if (v6)
  {
    uint64_t v7 = v6 - 16;
    uint64_t v8 = *(void *)(v6 - 8);
    if (v8)
    {
      uint64_t v9 = v6 - 224;
      uint64_t v10 = 224 * v8;
      do
      {
        kd_tile_comp::~kd_tile_comp((kd_tile_comp *)(v9 + v10));
        v10 -= 224;
      }
      while (v10);
    }
    MEMORY[0x18C11C0C0](v7, 0x10A0C802A3299D9);
  }
  while (1)
  {
    uint64_t v11 = (kd_mct_stage *)*((void *)this + 32);
    *((void *)this + 33) = v11;
    if (!v11) {
      break;
    }
    *((void *)this + 32) = *((void *)v11 + 7);
    kd_mct_stage::~kd_mct_stage(v11);
    MEMORY[0x18C11C0E0]();
  }
  uint64_t v12 = *((void *)this + 3);
  if (v12 && *(kd_tile **)(v12 + 16) != this)
  {
    *(void *)&long long v20 = 0;
    *(_OWORD *)int v18 = 0u;
    long long v19 = 0u;
    kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "Assert ");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "tile_ref->tile == this");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  if (*((unsigned char *)this + 290))
  {
    if (!*((void *)this + 3))
    {
      *(void *)&long long v20 = 0;
      *(_OWORD *)int v18 = 0u;
      long long v19 = 0u;
      kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "Assert ");
      (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "tile_ref != NULL");
      (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v18);
    }
    kd_tile::withdraw_from_unloadable_list((uint64_t *)this);
    uint64_t v13 = 0;
    uint64_t v14 = *((void *)this + 3);
  }
  else
  {
    uint64_t v14 = *((void *)this + 3);
    if (*((unsigned char *)this + 287))
    {
      if (!v14)
      {
        *(void *)&long long v20 = 0;
        *(_OWORD *)int v18 = 0u;
        long long v19 = 0u;
        kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "Assert ");
        (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "tile_ref != NULL");
        (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, " FAILED");
        kdu_error::~kdu_error((kdu_error *)v18);
      }
      uint64_t v13 = 0;
    }
    else
    {
      if (!v14) {
        goto LABEL_35;
      }
      uint64_t v13 = -1;
    }
  }
  *(void *)(v14 + 16) = v13;
  kd_buf_server::augment_structure_bytes(*(void *)(*(void *)this + 48), -*((_DWORD *)this + 70));
LABEL_35:
  kd_precinct_pointer_server::disable((uint64_t *)this + 13);
}

void sub_18863AB94(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t *kd_tile::remove_from_in_progress_list(uint64_t *this)
{
  if (*((unsigned char *)this + 288))
  {
    uint64_t v1 = *this;
    int v2 = *(_DWORD *)(*this + 360);
    if (v2 <= 0)
    {
      uint64_t v7 = 0;
      long long v5 = 0u;
      long long v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v5 + 16))(&v5, "Assert ");
      (*(void (**)(long long *, const char *))(v5 + 16))(&v5, "codestream->num_incomplete_tiles > 0");
      (*(void (**)(long long *, const char *))(v5 + 16))(&v5, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
    *(_DWORD *)(v1 + 360) = v2 - 1;
    uint64_t v3 = this[6];
    if (v3)
    {
      *(void *)(v3 + 40) = this[5];
      uint64_t v4 = this[5];
      if (v4)
      {
LABEL_6:
        *(void *)(v4 + 48) = this[6];
LABEL_13:
        *((unsigned char *)this + 288) = 0;
        this[5] = 0;
        this[6] = 0;
        return this;
      }
    }
    else
    {
      if (*(uint64_t **)(v1 + 336) != this)
      {
        uint64_t v7 = 0;
        long long v5 = 0u;
        long long v6 = 0u;
        kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v5 + 16))(&v5, "Assert ");
        (*(void (**)(long long *, const char *))(v5 + 16))(&v5, "this == codestream->tiles_in_progress_head");
        (*(void (**)(long long *, const char *))(v5 + 16))(&v5, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v5);
      }
      uint64_t v4 = this[5];
      *(void *)(v1 + 336) = v4;
      if (v4) {
        goto LABEL_6;
      }
    }
    if (*(uint64_t **)(v1 + 344) != this)
    {
      uint64_t v7 = 0;
      long long v5 = 0u;
      long long v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v5 + 16))(&v5, "Assert ");
      (*(void (**)(long long *, const char *))(v5 + 16))(&v5, "this == codestream->tiles_in_progress_tail");
      (*(void (**)(long long *, const char *))(v5 + 16))(&v5, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
    *(void *)(v1 + 344) = this[6];
    goto LABEL_13;
  }
  return this;
}

void sub_18863AE94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18863AEA0()
{
  _Unwind_Resume(v0);
}

unsigned char *kdu_message::operator<<(unsigned char *a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  long long v6 = 0u;
  long long v7 = 0u;
  long long v4 = 0u;
  long long v5 = 0u;
  *(_OWORD *)uint64_t v3 = 0u;
  if (a1[8]) {
    sprintf(v3, "%x");
  }
  else {
    sprintf(v3, "%d");
  }
  (*(void (**)(unsigned char *, char *))(*(void *)a1 + 16))(a1, v3);
  return a1;
}

{
  char v3[16];
  long long v4;
  long long v5;
  long long v6;
  long long v7;
  uint64_t v8;

  uint64_t v8 = *MEMORY[0x1E4F143B8];
  long long v6 = 0u;
  long long v7 = 0u;
  long long v4 = 0u;
  long long v5 = 0u;
  *(_OWORD *)uint64_t v3 = 0u;
  if (a1[8]) {
    sprintf(v3, "%x");
  }
  else {
    sprintf(v3, "%u");
  }
  (*(void (**)(unsigned char *, char *))(*(void *)a1 + 16))(a1, v3);
  return a1;
}

uint64_t *kd_tile::withdraw_from_unloadable_list(uint64_t *this)
{
  if (!*((unsigned char *)this + 290))
  {
    uint64_t v8 = 0;
    long long v6 = 0u;
    long long v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v6 + 16))(&v6, "Assert ");
    (*(void (**)(long long *, const char *))(v6 + 16))(&v6, "is_unloadable");
    (*(void (**)(long long *, const char *))(v6 + 16))(&v6, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  uint64_t v1 = this[8];
  if (v1)
  {
    *(void *)(v1 + 56) = this[7];
    uint64_t v2 = this[7];
    if (v2)
    {
LABEL_5:
      *(void *)(v2 + 64) = this[8];
      uint64_t v3 = *this;
      goto LABEL_12;
    }
  }
  else
  {
    if (*(uint64_t **)(*this + 480) != this)
    {
      uint64_t v8 = 0;
      long long v6 = 0u;
      long long v7 = 0u;
      kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v6 + 16))(&v6, "Assert ");
      (*(void (**)(long long *, const char *))(v6 + 16))(&v6, "codestream->unloadable_tiles_head == this");
      (*(void (**)(long long *, const char *))(v6 + 16))(&v6, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v6);
    }
    uint64_t v2 = this[7];
    *(void *)(*this + 480) = v2;
    if (v2) {
      goto LABEL_5;
    }
  }
  uint64_t v3 = *this;
  if (*(uint64_t **)(*this + 488) != this)
  {
    uint64_t v8 = 0;
    long long v6 = 0u;
    long long v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v6 + 16))(&v6, "Assert ");
    (*(void (**)(long long *, const char *))(v6 + 16))(&v6, "codestream->unloadable_tiles_tail == this");
    (*(void (**)(long long *, const char *))(v6 + 16))(&v6, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  *(void *)(v3 + 488) = this[8];
LABEL_12:
  long long v4 = this + 7;
  if (*(uint64_t **)(v3 + 496) == this) {
    *(void *)(v3 + 496) = *v4;
  }
  void *v4 = 0;
  this[8] = 0;
  int v5 = *(_DWORD *)(v3 + 504);
  *(_DWORD *)(v3 + 504) = v5 - 1;
  if (v5 <= 0)
  {
    uint64_t v8 = 0;
    long long v6 = 0u;
    long long v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v6 + 16))(&v6, "Assert ");
    (*(void (**)(long long *, const char *))(v6 + 16))(&v6, "codestream->num_unloadable_tiles >= 0");
    (*(void (**)(long long *, const char *))(v6 + 16))(&v6, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  *((unsigned char *)this + 290) = 0;
  return this;
}

void sub_18863B344(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18863B350()
{
  _Unwind_Resume(v0);
}

uint64_t kd_buf_server::augment_structure_bytes(uint64_t this, int a2)
{
  uint64_t v2 = *(void *)(this + 40) + a2;
  *(void *)(this + 40) = v2;
  if (v2 < 0) {
    kd_buf_server::augment_structure_bytes();
  }
  if (v2 > *(void *)(this + 48)) {
    *(void *)(this + 48) = v2;
  }
  return this;
}

uint64_t kd_tile::release(kd_tile *this)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (!*((void *)this + 3) || *(kd_tile **)(*(void *)this + 440) == this)
  {
    *(void *)&long long v32 = 0;
    *(_OWORD *)uint64_t v30 = 0u;
    long long v31 = 0u;
    kdu_error::kdu_error((kdu_error *)v30, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v30 + 16))(v30, "Assert ");
    (*(void (**)(char *, const char *))(*(void *)v30 + 16))(v30, "(tile_ref != NULL) && (this != codestream->active_tile)");
    (*(void (**)(char *, const char *))(*(void *)v30 + 16))(v30, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v30);
  }
  if (*(void *)(*(void *)this + 8) && !*((unsigned char *)this + 287) && *((unsigned char *)this + 184))
  {
    *((void *)this + 4) = 0;
    uint64_t v3 = (kd_pp_markers *)*((void *)this + 10);
    if (v3)
    {
      kd_pp_markers::~kd_pp_markers(v3);
      MEMORY[0x18C11C0E0]();
      *((void *)this + 10) = 0;
    }
    uint64_t v4 = *((void *)this + 11);
    if (v4)
    {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
      *((void *)this + 11) = 0;
    }
    uint64_t v5 = *((void *)this + 12);
    if (v5)
    {
      MEMORY[0x18C11C0E0](v5, 0x1020C40539952E0);
      *((void *)this + 12) = 0;
    }
    kd_precinct_pointer_server::disable((uint64_t *)this + 13);
    long long v6 = this;
    int v7 = *((_DWORD *)this + 47);
    if (v7 >= 1)
    {
      for (uint64_t i = 0; i < v7; ++i)
      {
        uint64_t v9 = *((void *)v6 + 34);
        uint64_t v10 = v9 + 224 * i;
        int v13 = *(_DWORD *)(v10 + 68);
        uint64_t v12 = (int *)(v10 + 68);
        int v11 = v13;
        if ((v13 & 0x80000000) == 0)
        {
          uint64_t v14 = 0;
          float v15 = (void *)(v9 + 224 * i + 176);
          do
          {
            if (*(_DWORD *)(*v15 + 704 * v14 + 192) * *(_DWORD *)(*v15 + 704 * v14 + 196) >= 1)
            {
              uint64_t v16 = 0;
              uint64_t v17 = (uint64_t *)(*v15 + 704 * v14 + 232);
              uint64_t v18 = 8 * (*(_DWORD *)(*v15 + 704 * v14 + 192) * *(_DWORD *)(*v15 + 704 * v14 + 196));
              do
              {
                uint64_t v19 = *v17;
                uint64_t v20 = *(void *)(*v17 + v16);
                if (v20) {
                  BOOL v21 = (*(void *)(*v17 + v16) & 1) == 0;
                }
                else {
                  BOOL v21 = 0;
                }
                if (v21)
                {
                  *(void *)(v20 + 8) = 0;
                  kd_precinct::closing((unsigned __int8 **)v20);
                  kd_precinct_size_class::release(*(kd_precinct_size_class **)(v20 + 72), (kd_precinct *)v20);
                }
                *(void *)(v19 + v16) = 0;
                v16 += 8;
              }
              while (v18 != v16);
              int v11 = *v12;
            }
          }
          while (v14++ < v11);
          long long v6 = this;
          int v7 = *((_DWORD *)this + 47);
        }
      }
    }
    uint64_t v23 = **(kdu_message ***)v6;
    if (v23)
    {
      if (*((unsigned char *)v6 + 287)) {
        goto LABEL_45;
      }
      (*(void (**)(void, const char *))(*(void *)v23 + 16))(**(void **)v6, "\n>> New attributes for tile ");
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      *(_OWORD *)uint64_t v30 = 0u;
      if (*((unsigned char *)v23 + 8)) {
        sprintf(v30, "%x");
      }
      else {
        sprintf(v30, "%d");
      }
      (*(void (**)(kdu_message *, char *))(*(void *)v23 + 16))(v23, v30);
      (*(void (**)(kdu_message *, const char *))(*(void *)v23 + 16))(v23, ":\n");
      kdu_params::textualize_attributes(*(void *)(*(void *)this + 24), v23, *((_DWORD *)this + 2), *((_DWORD *)this + 2), 1);
      (*(void (**)(kdu_message *, void))(*(void *)v23 + 32))(v23, 0);
      long long v6 = this;
    }
    if (!*((unsigned char *)v6 + 287) && !*((unsigned char *)v6 + 290))
    {
      uint64_t v24 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(*(void *)v6 + 24), 1);
      long long v6 = this;
      if (v24)
      {
        int v25 = 2;
        do
        {
          uint64_t v26 = kdu_params::access_unique(v24, *((_DWORD *)v6 + 2), -1, 0);
          if (v26) {
            (*(void (**)(uint64_t))(*(void *)v26 + 16))(v26);
          }
          uint64_t v24 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(*(void *)this + 24), v25++);
          long long v6 = this;
        }
        while (v24);
      }
    }
LABEL_45:
    if (*(kd_tile **)(*((void *)v6 + 3) + 16) != v6)
    {
      *(void *)&long long v32 = 0;
      *(_OWORD *)uint64_t v30 = 0u;
      long long v31 = 0u;
      kdu_error::kdu_error((kdu_error *)v30, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v30 + 16))(v30, "Assert ");
      (*(void (**)(char *, const char *))(*(void *)v30 + 16))(v30, "tile_ref->tile == this");
      (*(void (**)(char *, const char *))(*(void *)v30 + 16))(v30, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v30);
    }
    if (*((unsigned char *)v6 + 290))
    {
      kd_tile::withdraw_from_unloadable_list((uint64_t *)v6);
      long long v6 = this;
      uint64_t v27 = *((void *)this + 3);
    }
    else
    {
      uint64_t v27 = *((void *)v6 + 3);
      if (!*((unsigned char *)v6 + 287))
      {
        *(void *)(v27 + 16) = -1;
        goto LABEL_51;
      }
    }
    *(void *)(v27 + 16) = 0;
LABEL_51:
    uint64_t result = kd_buf_server::augment_structure_bytes(*(void *)(*(void *)v6 + 48), -*((_DWORD *)v6 + 70));
    *((_DWORD *)this + 70) = 0;
    *((void *)this + 3) = 0;
    *((_DWORD *)this + 2) = -1;
    uint64_t v28 = *(void *)this;
    *((void *)this + 9) = *(void *)(*(void *)this + 512);
    *(void *)(v28 + 512) = this;
    return result;
  }
  kd_tile::~kd_tile(this);
  return MEMORY[0x18C11C0E0]();
}

void sub_18863B984(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18863B990(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

void kd_tile::initialize(kd_tile *this)
{
  if (*((unsigned char *)this + 293))
  {
    uint64_t v15 = 0;
    *(_OWORD *)int v13 = 0u;
    long long v14 = 0u;
    kdu_error::kdu_error((kdu_error *)v13, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, "Assert ");
    (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, "!needs_reinit");
    (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v13);
  }
  uint64_t v2 = *(void *)this;
  *((_DWORD *)this + 47) = *(_DWORD *)(*(void *)this + 168);
  *(void *)((char *)this + 300) = 0;
  if (!*(void *)(v2 + 8)
    || *((unsigned char *)this + 292)
    || (*((void *)this + 4) = **((void **)this + 3), (kd_tile::read_tile_part_header(this) & 1) != 0))
  {
    uint64_t v3 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(*(void *)this + 24), "COD");
    if (!v3)
    {
      uint64_t v15 = 0;
      *(_OWORD *)int v13 = 0u;
      long long v14 = 0u;
      kdu_error::kdu_error((kdu_error *)v13, "Kakadu Core Error:\n");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, "Assert ");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, "cod != NULL");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v13);
    }
    uint64_t v12 = (kdu_params *)kdu_params::access_relation(v3, *((_DWORD *)this + 2), -1, 0, 1);
    uint64_t v4 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(*(void *)this + 24), "QCD");
    if (!v4)
    {
      uint64_t v15 = 0;
      *(_OWORD *)int v13 = 0u;
      long long v14 = 0u;
      kdu_error::kdu_error((kdu_error *)v13, "Kakadu Core Error:\n");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, "Assert ");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, "qcd != NULL");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v13);
    }
    kdu_params::access_relation(v4, *((_DWORD *)this + 2), -1, 0, 1);
    uint64_t v5 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(*(void *)this + 24), "RGN");
    if (!v5)
    {
      uint64_t v15 = 0;
      *(_OWORD *)int v13 = 0u;
      long long v14 = 0u;
      kdu_error::kdu_error((kdu_error *)v13, "Kakadu Core Error:\n");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, "Assert ");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, "rgn != NULL");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v13);
    }
    kdu_params::access_relation(v5, *((_DWORD *)this + 2), -1, 0, 1);
    long long v6 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(*(void *)this + 24), "ORG");
    if (!v6)
    {
      uint64_t v15 = 0;
      *(_OWORD *)int v13 = 0u;
      long long v14 = 0u;
      kdu_error::kdu_error((kdu_error *)v13, "Kakadu Core Error:\n");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, "Assert ");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, "org != NULL");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v13);
    }
    int v7 = (kdu_params *)kdu_params::access_relation(v6, *((_DWORD *)this + 2), -1, 0, 1);
    if (!kdu_params::get(v12, "Cuse_sop", 0, 0, (BOOL *)this + 284, 1, 1, 1)
      || !kdu_params::get(v12, "Cuse_eph", 0, 0, (BOOL *)this + 285, 1, 1, 1)
      || !kdu_params::get(v12, "Cycc", 0, 0, (BOOL *)this + 286, 1, 1, 1)
      || !kdu_params::get(v12, "Calign_blk_last", 0, 0, (int *)this + 61, 1, 1, 1)
      || !kdu_params::get(v12, "Calign_blk_last", 0, 1, (int *)this + 62, 1, 1, 1)
      || (kdu_params::get(v12, "Clayers", 0, 0, (int *)this + 48, 1, 1, 1) & 1) == 0)
    {
      uint64_t v15 = 0;
      *(_OWORD *)int v13 = 0u;
      long long v14 = 0u;
      kdu_error::kdu_error((kdu_error *)v13, "Kakadu Core Error:\n");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, "Corrupt jp2 file: invalid COD parameters ");
      kdu_error::~kdu_error((kdu_error *)v13);
    }
    int v8 = *((_DWORD *)this + 48);
    uint64_t v9 = *(void *)this;
    if (v8 > *(_DWORD *)(*(void *)this + 256)) {
      *(_DWORD *)(v9 + 256) = v8;
    }
    if (*(void *)(v9 + 16))
    {
      v13[0] = 0;
      if ((kdu_params::get(v7, "ORGtparts", 0, 0, v13, 1, 1, 1) & 1) == 0) {
        v13[0] = 0;
      }
      if ((kdu_params::get(v7, "ORGgen_plt", 0, 0, (BOOL *)this + 294, 1, 1, 1) & 1) == 0) {
        *((unsigned char *)this + 294) = 0;
      }
      char v10 = v13[0];
      *((unsigned char *)this + 295) = v13[0] & 1;
      *((unsigned char *)this + 296) = (v10 & 4) != 0;
      *((unsigned char *)this + 297) = (v10 & 2) != 0;
    }
    if (*((void *)this + 32))
    {
      uint64_t v15 = 0;
      *(_OWORD *)int v13 = 0u;
      long long v14 = 0u;
      kdu_error::kdu_error((kdu_error *)v13, "Kakadu Core Error:\n");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, "Assert ");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, "mct_head == NULL");
      (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v13);
    }
    if (*(unsigned char *)(*(void *)this + 164)) {
      kd_mct_stage::create_stages((void *)this + 32, (uint64_t *)this + 33, *(kdu_params **)(*(void *)this + 24), *((_DWORD *)this + 2), *((unsigned int *)this + 47), *(void *)(*(void *)this + 312), *(_DWORD *)(*(void *)this + 176), *(void *)(*(void *)this + 320));
    }
    unint64_t v11 = *((int *)this + 47);
    *((_DWORD *)this + 49) = *((_DWORD *)this + 48);
    is_mul_ok(v11, 0xE0uLL);
    operator new[]();
  }
  uint64_t v15 = 0;
  *(_OWORD *)int v13 = 0u;
  long long v14 = 0u;
  kdu_error::kdu_error((kdu_error *)v13, "Kakadu Core Error:\n");
  (*(void (**)(int *, const char *))(*(void *)v13 + 16))(v13, "read_failure in kd_tile::initialize ");
  kdu_error::~kdu_error((kdu_error *)v13);
}

void sub_18863DFD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
}

void sub_18863DFE0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  _Unwind_Resume(v45);
}

uint64_t kd_tile::read_tile_part_header(kd_tile *this)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)this;
  if (!*(void *)(*(void *)this + 8))
  {
    *(void *)&long long v71 = 0;
    *(_OWORD *)uint16x8_t v69 = 0u;
    long long v70 = 0u;
    kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Assert ");
    (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "codestream->in != NULL");
    (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v69);
  }
  if (*(unsigned char *)(v2 + 418))
  {
    if (*((_DWORD *)this + 76))
    {
      *(void *)&long long v71 = 0;
      *(_OWORD *)uint16x8_t v69 = 0u;
      long long v70 = 0u;
      kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Assert ");
      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "next_tpart == 0");
      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v69);
    }
    if (*((unsigned char *)this + 290)) {
      kd_tile::withdraw_from_unloadable_list((uint64_t *)this);
    }
    kd_codestream::unload_tiles_to_cache_threshold(*(void *)this);
    if (kd_compressed_input::set_tileheader_scope(*(kd_compressed_input **)(*(void *)this + 8)))
    {
      uint64_t v3 = *(kdu_params **)(*(void *)this + 24);
      if (kd_marker::read(*(kd_marker **)(*(void *)this + 32), 0, 0))
      {
        do
        {
          uint64_t v4 = *(void *)(*(void *)this + 32);
          uint64_t v5 = *(unsigned __int16 *)(v4 + 16);
          if (v5 == 65377)
          {
            *(void *)&long long v71 = 0;
            *(_OWORD *)uint16x8_t v69 = 0u;
            long long v70 = 0u;
            kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "You cannot use PPM or PPT marker segments (packed packet headers) with cached compressed data sources.");
            kdu_error::~kdu_error((kdu_error *)v69);
          }
          kdu_params::translate_marker_segment(v3, v5, *(unsigned int *)(v4 + 20), *(unsigned __int8 **)(v4 + 32), *((_DWORD *)this + 2), 0);
        }
        while ((kd_marker::read(*(kd_marker **)(*(void *)this + 32), 0, 0) & 1) != 0);
      }
      if (!*(unsigned char *)(*(void *)(*(void *)this + 8) + 544))
      {
        *(void *)&long long v71 = 0;
        *(_OWORD *)uint16x8_t v69 = 0u;
        long long v70 = 0u;
        kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Found non-marker code while parsing tile header marker segments.  Chances are that a marker segment length field is incorrect!");
        kdu_error::~kdu_error((kdu_error *)v69);
      }
      kdu_params::finalize_all(v3, *((_DWORD *)this + 2), 1);
    }
    else
    {
      *((unsigned char *)this + 287) = 1;
    }
    *(void *)((char *)this + 300) = 0x100000001;
    ++*(_DWORD *)(*(void *)this + 460);
    *((unsigned char *)this + 328) = 1;
    if (*((unsigned char *)this + 291))
    {
      *(void *)&long long v71 = 0;
      *(_OWORD *)uint16x8_t v69 = 0u;
      long long v70 = 0u;
      kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Assert ");
      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "!closed");
      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v69);
    }
    kd_tile::adjust_unloadability((uint64_t *)this);
    return 1;
  }
  if (*((unsigned char *)this + 328))
  {
LABEL_17:
    if (*(kd_tile **)(v2 + 440) == this)
    {
      *(void *)&long long v71 = 0;
      *(_OWORD *)uint16x8_t v69 = 0u;
      long long v70 = 0u;
      kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Assert ");
      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "this != codestream->active_tile");
      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v69);
    }
    return 0;
  }
  if (*((int *)this + 75) >= 1 && *((int *)this + 76) >= 255)
  {
    kd_tile::finished_reading(this);
    uint64_t v2 = *(void *)this;
    goto LABEL_17;
  }
  uint64_t v7 = *(void *)(v2 + 440);
  while (2)
  {
    if (!v7) {
      goto LABEL_46;
    }
    *(void *)&v66[0] = 0;
    uint64_t v68 = 0;
    if (!*(void *)(v7 + 96))
    {
      *(void *)&long long v71 = 0;
      *(_OWORD *)uint16x8_t v69 = 0u;
      long long v70 = 0u;
      kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Invalid code-stream!\n");
      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "\t'active->sequencer' is NULL");
      kdu_error::~kdu_error((kdu_error *)v69);
    }
    do
    {
      int v8 = kd_packet_sequencer::next_in_sequence(*(uint64_t **)(v7 + 96), (uint64_t *)v66, &v68);
      if (!v8) {
        break;
      }
      uint64_t v9 = *v8;
      if (!*v8)
      {
        uint64_t v9 = kd_precinct_ref::instantiate_precinct(v8, *(uint64_t *)&v66[0], v68);
        goto LABEL_42;
      }
      if ((v9 & 1) == 0 && !*(unsigned char *)(v9 + 17))
      {
        if (v9 == 3)
        {
          uint64_t v9 = 0;
        }
        else if (*(unsigned char *)(v9 + 20))
        {
          kd_precinct_size_class::withdraw_from_inactive_list(*(void *)(v9 + 72), (kd_precinct *)v9);
          kd_precinct::activate(v9);
        }
LABEL_42:
        if (!kd_precinct::desequence_packet((kd_precinct *)v9)) {
          break;
        }
      }
    }
    while (v7 == *(void *)(*(void *)this + 440));
    if (v7 == *(void *)(*(void *)this + 440))
    {
      *(void *)(*(void *)this + 440) = 0;
      kd_tile::adjust_unloadability((uint64_t *)v7);
    }
LABEL_46:
    if (*(kd_tile **)(*((void *)this + 3) + 16) != this)
    {
      *(void *)&long long v71 = 0;
      *(_OWORD *)uint16x8_t v69 = 0u;
      long long v70 = 0u;
      kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Assert ");
      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "tile_ref->tile == this");
      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v69);
    }
    uint64_t v10 = *(void *)this;
    uint64_t v11 = *(void *)(*(void *)this + 72);
    if (!v11)
    {
      if (*(__int16 *)(*(void *)(v10 + 32) + 16) != -112)
      {
        int v13 = *(unsigned char **)(v10 + 8);
        if (!v13[544])
        {
          uint64_t v14 = *(void *)(v10 + 448);
          if (v14 <= 0)
          {
            *(void *)&long long v71 = 0;
            *(_OWORD *)uint16x8_t v69 = 0u;
            long long v70 = 0u;
            kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Assert ");
            (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "codestream->next_sot_address > 0");
            (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, " FAILED");
            kdu_error::~kdu_error((kdu_error *)v69);
          }
          uint64_t offset = kd_compressed_input::get_offset(*(kd_compressed_input **)(v10 + 8));
          (*(void (**)(unsigned char *, uint64_t))(*(void *)v13 + 16))(v13, v14 - offset);
          kd_marker::read(*(kd_marker **)(*(void *)this + 32), 0, 0);
LABEL_69:
          uint64_t v10 = *(void *)this;
        }
      }
LABEL_70:
      *(void *)(v10 + 448) = 0;
      goto LABEL_71;
    }
    uint64_t v12 = (uint64_t *)*((void *)this + 4);
    if (v12)
    {
      kd_compressed_input::seek(*(void *)(v10 + 8), *v12);
      *((void *)this + 4) = *(void *)(*((void *)this + 4) + 8);
      kd_marker::read(*(kd_marker **)(*(void *)this + 32), 0, 0);
      uint64_t v10 = *(void *)this;
      goto LABEL_71;
    }
    if (*(unsigned char *)(v11 + 24) || (uint64_t v16 = (void *)*((void *)this + 3), *v16) && !v16[1])
    {
      *((_DWORD *)this + 75) = *((_DWORD *)this + 76);
      kd_tile::finished_reading(this);
      return 0;
    }
    if (*(__int16 *)(*(void *)(v10 + 32) + 16) == -112
      && *(_DWORD *)(v10 + 224) == 1
      && *(_DWORD *)(v10 + 220) == 1)
    {
      goto LABEL_70;
    }
    uint64_t v17 = *(void *)(v10 + 8);
    uint64_t v18 = *(void *)(v10 + 448);
    if (*(unsigned char *)(v17 + 544)) {
      BOOL v19 = 1;
    }
    else {
      BOOL v19 = v18 < 1;
    }
    if (!v19)
    {
      kd_compressed_input::seek(v17, v18);
      kd_marker::read(*(kd_marker **)(*(void *)this + 32), 0, 0);
      goto LABEL_69;
    }
    if (v18 < 0) {
      return 0;
    }
LABEL_71:
    if (!*(unsigned char *)(*(void *)(v10 + 8) + 544))
    {
      uint64_t v20 = *(void *)(v10 + 32);
      if (*(__int16 *)(v20 + 16) != -112)
      {
        *(void *)&long long v71 = 0;
        *(_OWORD *)uint16x8_t v69 = 0u;
        long long v70 = 0u;
        kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Invalid marker code found in code-stream!\n");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "\tExpected SOT marker and got ");
        print_marker_code(*(unsigned __int16 *)(*(void *)(*(void *)this + 32) + 16), (kdu_message *)v69);
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, ".");
        kdu_error::~kdu_error((kdu_error *)v69);
      }
      if (*(_DWORD *)(v20 + 20) != 8)
      {
        *(void *)&long long v71 = 0;
        *(_OWORD *)uint16x8_t v69 = 0u;
        long long v70 = 0u;
        kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Assert ");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "seg_length == 8");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, " FAILED");
        kdu_error::~kdu_error((kdu_error *)v69);
      }
      BOOL v21 = *(unsigned __int16 **)(v20 + 32);
      int v65 = __rev16(*v21);
      unsigned int v22 = *(_DWORD *)(v21 + 1);
      unsigned int v64 = *((unsigned __int8 *)v21 + 6);
      int v23 = *((unsigned __int8 *)v21 + 7);
      int v24 = *(_DWORD *)(v10 + 224);
      if (v65 >= *(_DWORD *)(v10 + 220) * v24)
      {
        *(void *)&long long v71 = 0;
        *(_OWORD *)uint16x8_t v69 = 0u;
        long long v70 = 0u;
        kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Corrupt SOT marker segment found in codestream: tile-number lies outside the range of available tiles derived from the SIZ marker segment.");
        kdu_error::~kdu_error((kdu_error *)v69);
      }
      uint64_t v25 = (v65 / v24);
      uint64_t v26 = (v65 % v24);
      int v27 = v26 - *(_DWORD *)(v10 + 232);
      int v28 = v25 - *(_DWORD *)(v10 + 228);
      if (v27 < 0 || v28 < 0 || (int v29 = *(_DWORD *)(v10 + 240), v27 >= v29) || v28 >= *(_DWORD *)(v10 + 236))
      {
        *(void *)&long long v71 = 0;
        *(_OWORD *)uint16x8_t v69 = 0u;
        long long v70 = 0u;
        kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Assert ");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "(rel_sot_idx.x >= 0) && (rel_sot_idx.y >= 0) && (rel_sot_idx.x < codestream->tile_indices.size.x) && (rel_sot_idx.y < codestream->tile_indices.size.y)");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, " FAILED");
        kdu_error::~kdu_error((kdu_error *)v69);
      }
      uint64_t v30 = *(void *)(v10 + 328);
      uint64_t v31 = kd_compressed_input::get_offset(*(kd_compressed_input **)(v10 + 8));
      uint64_t v63 = bswap32(v22);
      uint64_t v32 = v30 + 24 * v27;
      uint64_t v33 = v29 * v28;
      long long v34 = (void *)(v32 + 24 * v33);
      uint64_t v35 = *(void *)this;
      uint64_t v62 = v31 - *(int *)(*(void *)(*(void *)this + 32) + 20) - 4;
      if (!*(void *)(*(void *)this + 448))
      {
        *(void *)(v35 + 448) = v62 + v63;
        uint64_t v40 = *(void *)(v35 + 72);
        if (v40)
        {
          if (!*(unsigned char *)(v40 + 24) && (!*v34 || *(void *)(v32 + 24 * (int)v33 + 8)))
          {
            kd_tpart_pointer_server::add_tpart(v40, (void *)(v32 + 24 * v33), v62);
            if (!v63)
            {
              *(void *)(v32 + 24 * (int)v33 + 8) = 0;
              *(void *)(*(void *)this + 448) = -1;
            }
          }
        }
      }
      uint64_t v36 = *(void *)(v32 + 24 * (int)v33 + 16);
      if (v36 == -1)
      {
LABEL_88:
        uint64_t v37 = *(void *)this;
        uint64_t v38 = *(kd_pp_markers **)(*(void *)this + 40);
        if (v38)
        {
          kd_pp_markers::ignore_tpart(v38);
          uint64_t v37 = *(void *)this;
        }
        uint64_t v39 = *(void *)(v37 + 32);
        *(_WORD *)(v39 + 16) = 0;
        *(_DWORD *)(v39 + 20) = 0;
        *(unsigned char *)(v39 + 40) = 0;
        goto LABEL_91;
      }
      if (v36)
      {
        if (*(unsigned char *)(v36 + 328)) {
          goto LABEL_88;
        }
        if (*(unsigned char *)(v36 + 293))
        {
          if (!*(unsigned char *)(*(void *)this + 408))
          {
            *(void *)&long long v71 = 0;
            *(_OWORD *)uint16x8_t v69 = 0u;
            long long v70 = 0u;
            kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Assert ");
            (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "codestream->allow_restart");
            (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, " FAILED");
            kdu_error::~kdu_error((kdu_error *)v69);
          }
          kd_tile::reinitialize((kd_tile *)v36);
          goto LABEL_91;
        }
      }
      if ((kd_tile *)v36 != this)
      {
        if (*(void *)(*(void *)this + 72))
        {
          if (v36)
          {
            if (!*(void *)(v36 + 32))
            {
              uint64_t v41 = *(void *)(v32 + 24 * (int)v33 + 8);
              *(void *)(v36 + 32) = v41;
              if (!v41)
              {
                *(void *)(v36 + 32) = *v34;
                int v42 = *(_DWORD *)(v36 + 304);
                if (v42 >= 2)
                {
                  for (int i = 1; i < v42; ++i)
                  {
                    uint64_t v44 = *(void *)(*(void *)(v36 + 32) + 8);
                    *(void *)(v36 + 32) = v44;
                    if (!v44)
                    {
                      *(void *)&long long v71 = 0;
                      *(_OWORD *)uint16x8_t v69 = 0u;
                      long long v70 = 0u;
                      kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
                      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Assert ");
                      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "active->tpart_ptrs != NULL");
                      (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, " FAILED");
                      kdu_error::~kdu_error((kdu_error *)v69);
                    }
                  }
                }
              }
            }
          }
          goto LABEL_91;
        }
        if (!v63)
        {
          kd_tile::finished_reading(this);
          return 0;
        }
      }
      if (!v36)
      {
        kd_codestream::create_tile(*(void *)this, v25 | (v26 << 32));
        goto LABEL_91;
      }
      if (*(_DWORD *)(v36 + 8) != v65)
      {
        *(void *)&long long v71 = 0;
        *(_OWORD *)uint16x8_t v69 = 0u;
        long long v70 = 0u;
        kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Assert ");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "active->t_num == sot_tnum");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, " FAILED");
        kdu_error::~kdu_error((kdu_error *)v69);
      }
      if (*(_DWORD *)(v36 + 304) != v64)
      {
        uint64_t v67 = 0;
        memset(v66, 0, sizeof(v66));
        kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
        (*(void (**)(_OWORD *, const char *))(*(void *)&v66[0] + 16))(v66, "Missing or out-of-sequence tile-parts for tile number ");
        long long v72 = 0u;
        long long v73 = 0u;
        long long v70 = 0u;
        long long v71 = 0u;
        *(_OWORD *)uint16x8_t v69 = 0u;
        if (BYTE8(v66[0])) {
          sprintf(v69, "%x");
        }
        else {
          sprintf(v69, "%d");
        }
        (*(void (**)(_OWORD *, char *))(*(void *)&v66[0] + 16))(v66, v69);
        (*(void (**)(_OWORD *, const char *))(*(void *)&v66[0] + 16))(v66, " in code-stream!");
        kdu_error::~kdu_error((kdu_error *)v66);
      }
      if (v23)
      {
        int v45 = *(_DWORD *)(v36 + 300);
        if (v45)
        {
          if (v45 != v23)
          {
            *(void *)&long long v71 = 0;
            *(_OWORD *)uint16x8_t v69 = 0u;
            long long v70 = 0u;
            kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "The number of tile-parts for tile number ");
            int v46 = kdu_message::operator<<(v69);
            (*(void (**)(unsigned char *, const char *))(*(void *)v46 + 16))(v46, " is identified by different non-zero values in different SOT markers for the tile!");
            kdu_error::~kdu_error((kdu_error *)v69);
          }
        }
        else
        {
          *(_DWORD *)(v36 + 300) = v23;
        }
      }
      if (*(unsigned char *)(v36 + 290)) {
        kd_tile::withdraw_from_unloadable_list((uint64_t *)v36);
      }
      kd_codestream::unload_tiles_to_cache_threshold(*(void *)this);
      uint64_t v47 = *(kdu_params **)(*(void *)this + 24);
      int v48 = (kdu_params *)kdu_params::access_cluster(v47, "COD");
      char v49 = (kdu_params *)kdu_params::access_relation(v48, v65, -1, 0, 1);
      if (!v49)
      {
        *(void *)&long long v71 = 0;
        *(_OWORD *)uint16x8_t v69 = 0u;
        long long v70 = 0u;
        kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Assert ");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "cod != NULL");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, " FAILED");
        kdu_error::~kdu_error((kdu_error *)v69);
      }
      uint64_t v50 = (kdu_params *)kdu_params::access_cluster(v47, "POC");
      uint64_t v51 = (kdu_params *)kdu_params::access_relation(v50, v65, -1, 0, 1);
      if (!v51)
      {
        *(void *)&long long v71 = 0;
        *(_OWORD *)uint16x8_t v69 = 0u;
        long long v70 = 0u;
        kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Assert ");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "poc != NULL");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, " FAILED");
        kdu_error::~kdu_error((kdu_error *)v69);
      }
      if (*(void *)(v36 + 80))
      {
        *(void *)&long long v71 = 0;
        *(_OWORD *)uint16x8_t v69 = 0u;
        long long v70 = 0u;
        kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Assert ");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "active->ppt_markers == NULL");
        (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, " FAILED");
        kdu_error::~kdu_error((kdu_error *)v69);
      }
      if (!kd_marker::read(*(kd_marker **)(*(void *)this + 32), 0, 0))
      {
LABEL_172:
        if (!*(unsigned char *)(*(void *)(*(void *)this + 8) + 544))
        {
          *(void *)&long long v71 = 0;
          *(_OWORD *)uint16x8_t v69 = 0u;
          long long v70 = 0u;
          kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Found non-marker code while looking for SOD marker to terminate a tile-part header.  Chances are that a marker segment length field is incorrect!");
          kdu_error::~kdu_error((kdu_error *)v69);
        }
        return 0;
      }
      do
      {
        uint64_t v52 = *(void *)(*(void *)this + 32);
        int v53 = *(unsigned __int16 *)(v52 + 16);
        switch(v53)
        {
          case 65368:
            kd_precinct_pointer_server::add_plt_marker(v36 + 104, v52, v49, v51);
            break;
          case 65377:
            if (!*(_DWORD *)(*(void *)this + 160))
            {
              *(void *)&long long v71 = 0;
              *(_OWORD *)uint16x8_t v69 = 0u;
              long long v70 = 0u;
              kdu_warning::kdu_warning((kdu_warning *)v69, "Kakadu Core Warning:\n");
              (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Profile violation detected (code-stream is technically illegal).  PPT marker segments may not appear within a Profile-0 code-stream.  You should set \"Sprofile\" to 1 or 2.");
              *(_DWORD *)(*(void *)this + 160) = 2;
              kdu_warning::~kdu_warning((kdu_warning *)v69);
            }
            uint64_t v54 = *(void *)(v36 + 80);
            if (!v54) {
              operator new();
            }
            kd_pp_markers::add_marker(v54, *(void *)(*(void *)this + 32));
          case 65427:
            goto LABEL_150;
          default:
            kdu_params::translate_marker_segment(v47, *(unsigned __int16 *)(v52 + 16), *(unsigned int *)(v52 + 20), *(unsigned __int8 **)(v52 + 32), v65, v64);
            break;
        }
      }
      while ((kd_marker::read(*(kd_marker **)(*(void *)this + 32), 0, 0) & 1) != 0);
      if (!v53) {
        goto LABEL_172;
      }
LABEL_150:
      kdu_params::finalize_all(v47, v65, 1);
      uint64_t v55 = kd_compressed_input::get_offset(*(kd_compressed_input **)(*(void *)this + 8));
      int v56 = *(kd_pp_markers **)(*(void *)this + 40);
      if (*(void *)(v36 + 80))
      {
        if (v56)
        {
          *(void *)&long long v71 = 0;
          *(_OWORD *)uint16x8_t v69 = 0u;
          long long v70 = 0u;
          kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Use of both PPM and PPT marker segments is illegal!");
          kdu_error::~kdu_error((kdu_error *)v69);
        }
        uint64_t v57 = *(kd_pph_input **)(v36 + 88);
        if (!v57) {
          operator new();
        }
        kd_pp_markers::transfer_tpart(*(kd_pp_markers **)(v36 + 80), v57);
        uint64_t v58 = *(kd_pp_markers **)(v36 + 80);
        if (v58)
        {
          kd_pp_markers::~kd_pp_markers(v58);
          MEMORY[0x18C11C0E0]();
        }
        *(void *)(v36 + 80) = 0;
        goto LABEL_162;
      }
      uint64_t v59 = v63;
      if (v56)
      {
        unsigned int v60 = *(kd_pph_input **)(v36 + 88);
        if (!v60) {
          operator new();
        }
        kd_pp_markers::transfer_tpart(v56, v60);
LABEL_162:
        uint64_t v59 = v63;
      }
      if (v59)
      {
        uint64_t v61 = v62 + v59;
        if (v61 - v55 < 0)
        {
          *(void *)&long long v71 = 0;
          *(_OWORD *)uint16x8_t v69 = 0u;
          long long v70 = 0u;
          kdu_error::kdu_error((kdu_error *)v69, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "Assert ");
          (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, "tpart_body_length >= 0");
          (*(void (**)(char *, const char *))(*(void *)v69 + 16))(v69, " FAILED");
          kdu_error::~kdu_error((kdu_error *)v69);
        }
        kd_precinct_pointer_server::start_tpart_body((uint64_t *)(v36 + 104), v55, v61 - v55, v49, v51, *(void *)(v36 + 88) != 0, 0);
      }
      else
      {
        kd_precinct_pointer_server::start_tpart_body((uint64_t *)(v36 + 104), v55, 0, v49, v51, *(void *)(v36 + 88) != 0, 1);
      }
      ++*(_DWORD *)(v36 + 304);
      *(void *)(*(void *)this + 440) = v36;
      kd_tile::adjust_unloadability((uint64_t *)v36);
      ++*(_DWORD *)(*(void *)this + 460);
LABEL_91:
      uint64_t v7 = *(void *)(*(void *)this + 440);
      if ((kd_tile *)v7 == this) {
        return 1;
      }
      continue;
    }
    break;
  }
  if (*(void *)(v10 + 448)) {
    return 0;
  }
  uint64_t result = 0;
  *(void *)(v10 + 448) = -1;
  return result;
}

void sub_18863FD64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18863FD70(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  _Unwind_Resume(v21);
}

void kd_tile_comp::initialize_kernel_parameters(kd_tile_comp *this, int a2, kdu_kernels *a3)
{
  BOOL v3 = *((unsigned char *)this + 76);
  kd_create_dwt_description(*((_DWORD *)this + 20), a2, *(kdu_params **)(*(void *)this + 24), *(_DWORD *)(*((void *)this + 1) + 8), &v3, (BOOL *)this + 84, (BOOL *)this + 85, (int *)this + 22, (void *)this + 12, (void *)this + 14);
}

void sub_1886403CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886403D8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Resume(v13);
}

float kd_tile::find_multicomponent_energy_gain(kd_tile *this, int a2, int a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (a3 && *(_DWORD *)(*(void *)this + 184))
  {
    uint64_t v44 = 0;
    memset(v43, 0, sizeof(v43));
    kdu_error::kdu_error((kdu_error *)v43, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(void *)v43 + 16))(v43, "Assert ");
    (*(void (**)(int *, const char *))(*(void *)v43 + 16))(v43, "codestream->component_access_mode == KDU_WANT_OUTPUT_COMPONENTS");
    (*(void (**)(int *, const char *))(*(void *)v43 + 16))(v43, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v43);
  }
  uint64_t v4 = *((void *)this + 32);
  if (!v4)
  {
    if (a2 > 2 || !*((unsigned char *)this + 286) || *((int *)this + 47) < 3)
    {
      uint64_t v26 = *(void *)(*(void *)this + 320);
      if (!a3
        || (v27 = *(_DWORD *)(v26 + 48 * a2 + 16), double v20 = 0.0, (v27 & 0x80000000) == 0)
        && *(unsigned char *)(*((void *)this + 34) + 224 * v27 + 185))
      {
        int v28 = 1 << *(_DWORD *)(v26 + 48 * a2);
        double v20 = 1.0 / (float)v28 * (1.0 / (float)v28);
      }
      goto LABEL_61;
    }
    memset(v43, 0, 24);
    uint64_t v24 = *((void *)this + 34);
    if (*(unsigned char *)(v24 + 224 * a2 + 76))
    {
      if (a2 == 1)
      {
        *(int64x2_t *)uint64_t v43 = vdupq_n_s64(0x3FB0000000000000uLL);
        *(void *)&v43[4] = 0x3FE2000000000000;
        goto LABEL_55;
      }
      if (a2)
      {
        *(void *)&v43[4] = 0x3FB0000000000000;
        _Q0 = xmmword_18898C810;
LABEL_54:
        *(_OWORD *)uint64_t v43 = _Q0;
LABEL_55:
        uint64_t v33 = 0;
        long long v34 = (_DWORD *)(*(void *)(*(void *)this + 320) + 16);
        double v20 = 0.0;
        do
        {
          if (!a3 || (*v34 & 0x80000000) == 0 && *(unsigned char *)(v24 + 224 * *v34 + 185))
          {
            double v35 = 1.0 / (float)(1 << *(v34 - 4));
            double v20 = v20 + *(double *)&v43[v33] * v35 * v35;
          }
          v33 += 2;
          v34 += 12;
        }
        while (v33 != 6);
        goto LABEL_61;
      }
    }
    else
    {
      if (a2 == 1)
      {
        *(_OWORD *)&v43[2] = xmmword_18898C820;
        goto LABEL_55;
      }
      if (a2)
      {
        _Q0 = xmmword_18898C830;
        goto LABEL_54;
      }
    }
    *(void *)&v43[4] = 0x3FF0000000000000;
    __asm { FMOV            V0.2D, #1.0 }
    goto LABEL_54;
  }
  float v5 = 1.0;
  int v6 = a2;
  int v7 = a2;
  while (1)
  {
    int v42 = -1;
    v43[0] = 0;
    int v8 = *(_DWORD *)(v4 + 32);
    uint64_t v41 = (int *)(v4 + 32);
    if (v8 <= 0) {
      break;
    }
LABEL_10:
    for (uint64_t i = 0; i < v8; ++i)
    {
      uint64_t v10 = *(void *)(v4 + 40);
      if (!a3 || *(_DWORD *)(v10 + 152 * i + 36))
      {
        uint64_t v11 = v10 + 152 * i;
        int v14 = *(_DWORD *)(v11 + 8);
        int v13 = (int *)(v11 + 8);
        int v12 = v14;
        if (v14 >= 1)
        {
          uint64_t v15 = 0;
          uint64_t v16 = v10 + 152 * i;
          do
          {
            if (!a3 || *(unsigned char *)(*(void *)(v16 + 24) + v15))
            {
              int v17 = *(_DWORD *)(*(void *)(v16 + 16) + 4 * v15);
              if (v17 >= v6 && v17 <= v7)
              {
                uint64_t v19 = *(void *)(v4 + 48);
                if (v19) {
                  float v5 = *(float *)(*(void *)(v19 + 24) + 48 * v17 + 44);
                }
                kd_mct_block::analyze_sensitivity(v16, v15, v5, v43, &v42, a3);
                int v12 = *v13;
              }
            }
            ++v15;
          }
          while (v15 < v12);
          int v8 = *v41;
        }
      }
    }
    int v7 = v42;
    int v6 = v43[0];
    uint64_t v4 = *(void *)(v4 + 56);
    if (!v4)
    {
      double v20 = 0.0;
      if (v43[0] <= v42)
      {
        BOOL v21 = (float *)(*(void *)(*((void *)this + 33) + 24) + 48 * v43[0] + 44);
        int v22 = v42 - v43[0] + 1;
        do
        {
          if (*((unsigned char *)v21 - 4) || (a3 & 1) == 0)
          {
            double v23 = (float)(*v21 / (float)(1 << *((_DWORD *)v21 - 11)));
            double v20 = v20 + v23 * v23;
          }
          v21 += 12;
          --v22;
        }
        while (v22);
      }
      goto LABEL_61;
    }
  }
  while (1)
  {
    uint64_t v4 = *(void *)(v4 + 56);
    if (!v4) {
      break;
    }
    int v42 = -1;
    v43[0] = 0;
    int v8 = *(_DWORD *)(v4 + 32);
    if (v8 >= 1)
    {
      int v6 = 0;
      uint64_t v41 = (int *)(v4 + 32);
      int v7 = -1;
      goto LABEL_10;
    }
  }
  double v20 = 0.0;
LABEL_61:
  double v36 = (double)(1 << *(_DWORD *)(*(void *)(*(void *)this + 312) + 104 * a2 + 16));
  double v37 = v20 * (v36 * v36);
  if (v37 < 0.0001) {
    return 0.0001;
  }
  return v37;
}

void sub_1886408C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886408D0()
{
  _Unwind_Resume(v0);
}

void kd_resolution::build_decomposition_structure(kd_resolution *this, kdu_params *a2, kdu_kernels *a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  *(_DWORD *)unsigned int v27 = 3;
  memset(v28, 0, 98);
  memset(&v27[2], 0, 98);
  *((unsigned char *)this + 222) = 1;
  if (*((unsigned char *)this + 24))
  {
    if (a2)
    {
      kdu_params::get(a2, "Cdecomp", *((unsigned __int8 *)this + 25) - 1, 0, (int *)v27, 1, 1, 1);
      uint64_t v4 = *(unsigned int *)v27;
    }
    else
    {
      uint64_t v4 = 3;
    }
    uint64_t v5 = cod_params::transpose_decomp((cod_params *)v4);
    *((unsigned char *)this + 222) = cod_params::expand_decomp_bands(*(unsigned int *)v27, (uint64_t)v28, v6) - 1;
    cod_params::expand_decomp_bands(v5, (uint64_t)&v27[2], v7);
  }
  else
  {
    v28[0] = 0;
  }
  if (*((void *)this + 30))
  {
    uint64_t v26 = 0;
    long long v24 = 0u;
    long long v25 = 0u;
    kdu_error::kdu_error((kdu_error *)&v24, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v24 + 16))(&v24, "Assert ");
    (*(void (**)(long long *, const char *))(v24 + 16))(&v24, "subbands == NULL");
    (*(void (**)(long long *, const char *))(v24 + 16))(&v24, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v24);
  }
  unsigned int v8 = *((unsigned __int8 *)this + 222);
  if (v8 > 3) {
    operator new[]();
  }
  *((void *)this + 30) = (char *)this + 256;
  if (v8)
  {
    uint64_t v9 = 0;
    int v10 = *((unsigned __int8 *)this + 24);
    uint64_t v11 = (char *)this + 306;
    do
    {
      *(void *)(v11 - 50) = 0;
      *(void *)(v11 - 42) = this;
      *uint64_t v11 = 1;
      if (v10) {
        __int16 v12 = v28[v9 + 1];
      }
      else {
        __int16 v12 = 0;
      }
      v11[5] = v9;
      *((_WORD *)v11 + 1) = v12;
      v11 += 144;
      ++v9;
    }
    while (v8 != v9);
    unsigned __int8 v13 = *((unsigned char *)this + 222);
    if (v13)
    {
      for (unint64_t i = 0; i < v13; *(unsigned char *)(v18 + 144 * i++ + 56) = v16)
      {
        unsigned int v15 = *((unsigned __int8 *)this + 24);
        if (*((unsigned char *)this + 24)) {
          unsigned int v15 = (unsigned __int16)v27[i + 3];
        }
        uint64_t v16 = 0;
        unsigned int v17 = __rev16(v15);
        uint64_t v18 = *((void *)this + 30);
        if ((v13 & 0xFE) != 0) {
          uint64_t v19 = v13;
        }
        else {
          uint64_t v19 = 1;
        }
        for (uint64_t j = 52; *(unsigned __int16 *)(v18 + j) != v17; j += 144)
        {
          if (v19 == ++v16)
          {
            uint64_t v26 = 0;
            long long v24 = 0u;
            long long v25 = 0u;
            kdu_error::kdu_error((kdu_error *)&v24, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v24 + 16))(&v24, "Assert ");
            (*(void (**)(long long *, const char *))(v24 + 16))(&v24, "k < num_subbands");
            (*(void (**)(long long *, const char *))(v24 + 16))(&v24, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v24);
          }
        }
      }
    }
  }
  if (*((void *)this + 28))
  {
    uint64_t v26 = 0;
    long long v24 = 0u;
    long long v25 = 0u;
    kdu_error::kdu_error((kdu_error *)&v24, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v24 + 16))(&v24, "Assert ");
    (*(void (**)(long long *, const char *))(v24 + 16))(&v24, "intermediate_nodes == NULL");
    (*(void (**)(long long *, const char *))(v24 + 16))(&v24, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v24);
  }
  unsigned int v21 = 0;
  int v22 = 0;
  *((unsigned char *)this + 223) = 0;
  int v23 = *(_DWORD *)v27;
  while (1)
  {
    v21 += 2;
    if (((v23 >> v21) & 3) != 0) {
      *((unsigned char *)this + 223) = ++v22;
    }
    if (v21 >= 0x1D) {
      operator new[]();
    }
  }
}

void sub_1886413F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886413FC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  _Unwind_Resume(v21);
}

uint64_t check_coding_partition(uint64_t result, unint64_t a2)
{
  unsigned int v2 = a2;
  if ((result & 0xFFFFFFFEFFFFFFFELL) != 0)
  {
    uint64_t v9 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v7 + 16))(&v7, "Coding partitions (code-blocks and precinct partitions) must have origin coordinates equal to 1 or 0 only!");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  unint64_t v3 = HIDWORD(a2);
  if (SHIDWORD(a2) >= 2)
  {
    while ((v3 & 1) == 0)
    {
      LODWORD(v4) = v3 >> 1;
      BOOL v5 = v3 > 3;
      LODWORD(v3) = v3 >> 1;
      if (!v5) {
        goto LABEL_8;
      }
    }
    goto LABEL_15;
  }
  unint64_t v4 = HIDWORD(a2);
LABEL_8:
  if (v4 != 1) {
    goto LABEL_15;
  }
  if ((int)a2 >= 2)
  {
    while ((v2 & 1) == 0)
    {
      unsigned int v6 = v2 >> 1;
      BOOL v5 = v2 > 3;
      v2 >>= 1;
      if (!v5) {
        goto LABEL_14;
      }
    }
    goto LABEL_15;
  }
  unsigned int v6 = a2;
LABEL_14:
  if (v6 != 1)
  {
LABEL_15:
    uint64_t v9 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v7 + 16))(&v7, "Coding partitions (namely, code-block and precinct partitions) must have exact power-of-2 dimensions!");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  return result;
}

void sub_1886415B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886415C4()
{
  _Unwind_Resume(v0);
}

unint64_t get_partition_indices(uint64_t a1, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = (HIDWORD(a3) - HIDWORD(a1));
  unsigned int v5 = a3 - a1;
  if (!a2) {
    goto LABEL_15;
  }
  unint64_t v6 = HIDWORD(a2);
  if (!HIDWORD(a2)) {
    goto LABEL_15;
  }
  if (SHIDWORD(a2) <= 1) {
    LODWORD(v6) = 1;
  }
  uint64_t v4 = (v4 & 0x80000000) != 0 ? ~(~v4 / v6) : v4 / v6;
  unsigned int v7 = (int)a2 <= 1 ? 1 : a2;
  if ((v5 & 0x80000000) != 0) {
    unsigned int v5 = ~(~v5 / v7);
  }
  else {
    v5 /= v7;
  }
  if ((int)a3 - (int)a1 + a4 <= 0)
  {
    if ((v4 & 0x80000000) != 0)
    {
LABEL_19:
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = -50;
      __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
    }
  }
  else
  {
LABEL_15:
    if ((v4 & 0x80000000) != 0) {
      goto LABEL_19;
    }
  }
  if ((v5 & 0x80000000) != 0) {
    goto LABEL_19;
  }
  return v5 | (unint64_t)(v4 << 32);
}

uint64_t kdu_dims::operator&=(_DWORD *a1, int *a2)
{
  int v3 = *a1;
  int v2 = a1[1];
  int v4 = *a2;
  int v5 = a2[1];
  int v6 = a2[3] + v5;
  if (a1[3] + v2 < v6) {
    int v6 = a1[3] + v2;
  }
  if (a1[2] + *a1 >= a2[2] + *a2) {
    int v7 = a2[2] + v4;
  }
  else {
    int v7 = a1[2] + *a1;
  }
  if (v2 < v5)
  {
    a1[1] = v5;
    int v2 = v5;
  }
  if (v3 < v4)
  {
    *a1 = v4;
    int v3 = v4;
  }
  uint64_t v8 = (v6 - v2);
  uint64_t v9 = (v7 - v3);
  *((void *)a1 + 1) = v9 | (v8 << 32);
  if ((v8 & 0x80000000) != 0)
  {
    a1[3] = 0;
    if ((v9 & 0x80000000) == 0) {
      return *(void *)a1;
    }
LABEL_14:
    a1[2] = 0;
    return *(void *)a1;
  }
  if ((v9 & 0x80000000) != 0) {
    goto LABEL_14;
  }
  return *(void *)a1;
}

uint64_t kd_resolution::complete_initialization(kd_resolution *this)
{
  int v2 = 0;
  *((_DWORD *)this + 54) = 0;
  int v3 = (_OWORD *)((char *)this + 168);
  int v4 = (_DWORD *)((char *)this + 100);
  int v5 = (int *)((char *)this + 48);
  char v6 = 1;
  do
  {
    int v7 = 0;
    char v8 = v6;
    int v38 = v2;
    char v9 = 1;
    do
    {
      char v10 = v9;
      *(_OWORD *)int v4 = *v3;
      *(int32x2_t *)((char *)this + 100) = vmla_s32(*(int32x2_t *)((char *)this + 100), *(int32x2_t *)((char *)this + 108), vadd_s32(*(int32x2_t *)((char *)this + 184), (int32x2_t)__PAIR64__(v7, v38)));
      uint64_t result = kdu_dims::operator&=(v4, v5);
      if (*((int *)this + 28) >= 1 && *((int *)this + 27) >= 1)
      {
        if (*((unsigned char *)this + 223))
        {
          uint64_t v12 = 0;
          unint64_t v13 = 0;
          do
          {
            uint64_t v14 = *((void *)this + 28) + v12;
            LODWORD(v15) = *(_DWORD *)(*(void *)v14 + 68);
            LODWORD(v16) = *(_DWORD *)(*(void *)v14 + 72);
            unsigned int v17 = *(unsigned __int8 *)(v14 + 48);
            unsigned int v18 = *(unsigned __int8 *)(v14 + 49);
            int v19 = *(_DWORD *)(*(void *)v14 + 80) + v16;
            int v20 = *(_DWORD *)(*(void *)v14 + 76) + v15;
            uint64_t result = ((int)(v19 - v17 + 1) >> 1);
            if (v17 <= 1) {
              uint64_t v16 = ((int)(v16 - v17 + 1) >> 1);
            }
            else {
              uint64_t v16 = v16;
            }
            if (v17 <= 1) {
              int v19 = (int)(v19 - v17 + 1) >> 1;
            }
            if (v18 <= 1) {
              uint64_t v15 = ((int)(v15 - v18 + 1) >> 1);
            }
            else {
              uint64_t v15 = v15;
            }
            if (v18 <= 1) {
              int v20 = (int)(v20 - v18 + 1) >> 1;
            }
            *(void *)(v14 + 68) = v15 | (v16 << 32);
            *(void *)(v14 + 76) = (v20 - v15) | ((unint64_t)(v19 - v16) << 32);
            ++v13;
            v12 += 136;
          }
          while (v13 < *((unsigned __int8 *)this + 223));
        }
        if (*((unsigned char *)this + 222))
        {
          unint64_t v21 = 0;
          int v22 = 0;
          do
          {
            uint64_t v23 = *((void *)this + 30);
            long long v24 = (unsigned __int8 *)(v23 + 144 * v21);
            unsigned int v25 = *(_DWORD *)(*(void *)v24 + 68);
            LODWORD(v26) = *(_DWORD *)(*(void *)v24 + 72);
            int v27 = *(_DWORD *)(*(void *)v24 + 76);
            unsigned int v28 = v24[48];
            unsigned int v29 = v24[49];
            int v30 = v27 + v25;
            if (v28 <= 1) {
              uint64_t v26 = ((int)(v26 - v28 + 1) >> 1);
            }
            else {
              uint64_t v26 = v26;
            }
            int v31 = (int)(v30 - v29 + 1) >> 1;
            BOOL v32 = v29 > 1;
            if (v29 <= 1) {
              uint64_t v33 = ((int)(v25 - v29 + 1) >> 1);
            }
            else {
              uint64_t v33 = v25;
            }
            if (v32) {
              int v34 = v30;
            }
            else {
              int v34 = v31;
            }
            uint64_t result = get_partition_indices(*(void *)(v23 + 144 * v21 + 76), *(void *)(v23 + 144 * v21 + 84), v33 | (v26 << 32), v34 - (int)v33);
            v22 += HIDWORD(v35) * v35;
            if (HIDWORD(v35) * (int)v35 >= 2)
            {
              do
              {
                uint64_t v36 = ((HIDWORD(v35) + 1) >> 1);
                uint64_t v37 = (((int)v35 + 1) >> 1);
                uint64_t v35 = v37 | (v36 << 32);
                LODWORD(v36) = v36 * v37;
                v22 += v36;
              }
              while ((int)v36 > 1);
            }
            ++v21;
          }
          while (v21 < *((unsigned __int8 *)this + 222));
        }
        else
        {
          int v22 = 0;
        }
        if (v22 > *((_DWORD *)this + 54)) {
          *((_DWORD *)this + 54) = v22;
        }
      }
      char v9 = 0;
      int v7 = 1;
    }
    while ((v10 & 1) != 0);
    char v6 = 0;
    int v2 = 1;
  }
  while ((v8 & 1) != 0);
  return result;
}

uint64_t kd_tile::set_elements_of_interest(int **this)
{
  uint64_t v1 = this;
  int v2 = *this;
  if (this[32] && !*((void *)v2 + 2) && !v2[46])
  {
    kd_mct_stage::apply_output_restrictions(this[33], *((void *)v2 + 40), 0, 0);
    int v2 = *v1;
  }
  int v3 = v2[63];
  if (v3 >= *((_DWORD *)v1 + 48)) {
    int v3 = *((_DWORD *)v1 + 48);
  }
  *((_DWORD *)v1 + 49) = v3;
  long long v143 = *(_OWORD *)((char *)v1 + 212);
  uint64_t result = kdu_dims::operator&=(&v143, v2 + 66);
  *(_OWORD *)((char *)v1 + 228) = v143;
  if (*((void *)*v1 + 1) && !*((unsigned char *)*v1 + 417))
  {
    *((_DWORD *)v1 + 50) = *((_DWORD *)v1 + 49);
    *((_DWORD *)v1 + 52) = 0;
    int v132 = 1;
  }
  else
  {
    int v132 = 0;
  }
  if (*((int *)v1 + 47) >= 1)
  {
    unint64_t v5 = 0;
    int v135 = v1;
    while (1)
    {
      char v6 = v1[34];
      int v7 = &v6[56 * v5];
      *((unsigned char *)v7 + 185) = 1;
      v7[39] = -1082130432;
      char v8 = *v1;
      if (!*((void *)*v1 + 2)) {
        break;
      }
      LOBYTE(v6[56 * v5 + 46]) = 1;
LABEL_21:
      unint64_t v13 = &v6[56 * v5];
      int v14 = v13[7];
      if (!*(void *)(v13 + 7))
      {
        uint64_t v145 = 0;
        long long v143 = 0u;
        long long v144 = 0u;
        kdu_error::kdu_error((kdu_error *)&v143, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v143 + 16))(&v143, "File corruption: tc->sub_sampling = (0,0)\n");
        kdu_error::~kdu_error((kdu_error *)&v143);
      }
      int v15 = *((_DWORD *)v1 + 57);
      int v16 = *((_DWORD *)v1 + 58);
      int v17 = *((_DWORD *)v1 + 59);
      int v18 = *((_DWORD *)v1 + 60);
      if (v13[8] <= 1) {
        unsigned int v19 = 1;
      }
      else {
        unsigned int v19 = v13[8];
      }
      if (v16 <= 0) {
        uint64_t v20 = -(int)(-v16 / v19);
      }
      else {
        uint64_t v20 = (v16 - 1) / v19 + 1;
      }
      BOOL v21 = __OFADD__(v18, v16);
      int v22 = v18 + v16;
      if ((v22 < 0) ^ v21 | (v22 == 0)) {
        unsigned int v23 = -(int)(-v22 / v19);
      }
      else {
        unsigned int v23 = (v22 - 1) / v19 + 1;
      }
      if (v14 <= 1) {
        unsigned int v24 = 1;
      }
      else {
        unsigned int v24 = v14;
      }
      if (v15 <= 0) {
        unsigned int v25 = -(int)(-v15 / v24);
      }
      else {
        unsigned int v25 = (v15 - 1) / v24 + 1;
      }
      BOOL v21 = __OFADD__(v17, v15);
      int v26 = v17 + v15;
      if ((v26 < 0) ^ v21 | (v26 == 0)) {
        unsigned int v27 = -(int)(-v26 / v24);
      }
      else {
        unsigned int v27 = (v26 - 1) / v24 + 1;
      }
      unint64_t v131 = v5;
      unsigned int v28 = &v6[56 * v5];
      *(void *)(v28 + 13) = v25 | (unint64_t)(v20 << 32);
      uint64_t v136 = v28 + 13;
      unint64_t v29 = (v27 - v25) | ((unint64_t)(v23 - v20) << 32);
      unsigned int v30 = v28[17];
      *(void *)(v28 + 15) = v29;
      LODWORD(v29) = v30 - (*v1)[61];
      v28[18] = v29;
      int v31 = v28 + 18;
      if ((v29 & 0x80000000) == 0)
      {
        BOOL v32 = &v6[56 * v5];
        uint64_t v34 = *((void *)v32 + 22);
        uint64_t v33 = v32 + 44;
        if (!v34)
        {
          uint64_t v145 = 0;
          long long v143 = 0u;
          long long v144 = 0u;
          kdu_error::kdu_error((kdu_error *)&v143, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v143 + 16))(&v143, "File corruption: tc->resolutions = NULL\n");
          kdu_error::~kdu_error((kdu_error *)&v143);
        }
        if ((v30 & 0x80000000) == 0)
        {
          uint64_t v35 = &v6[56 * v131];
          uint64_t v36 = v35 + 34;
          uint64_t v37 = v35 + 35;
          int v38 = v35 + 36;
          uint64_t v39 = v35 + 37;
          uint64_t v137 = v35 + 46;
          uint64_t v40 = v30;
          int v141 = v36;
          int v142 = v37;
          float32x4_t v133 = v33;
          uint64_t v134 = v31;
          do
          {
            uint64_t v139 = v40;
            uint64_t v140 = *v33;
            uint64_t v41 = *v33 + 704 * v40;
            uint64_t v44 = *(void *)(v41 + 32);
            uint64_t v42 = v41 + 32;
            uint64_t v43 = v44;
            if (v44)
            {
              uint64_t v45 = v40;
              uint64_t v46 = *(void *)(v43 + 32);
              uint64_t v47 = *(void *)(v43 + 40);
              unsigned int v48 = *(unsigned __int8 *)(v42 + 48);
              unsigned int v49 = *(unsigned __int8 *)(v42 + 49);
              if (v45 >= *v31)
              {
                int v65 = HIDWORD(v47) + HIDWORD(v46);
                LODWORD(v47) = v47 + v46;
                int v66 = (int)(HIDWORD(v47) + HIDWORD(v46) - v48 + 1) >> 1;
                BOOL v67 = v48 > 1;
                if (v48 <= 1) {
                  uint64_t v68 = ((int)(HIDWORD(v46) - v48 + 1) >> 1);
                }
                else {
                  uint64_t v68 = HIDWORD(v46);
                }
                if (!v67) {
                  int v65 = v66;
                }
                if (v49 <= 1) {
                  uint64_t v46 = ((int)(v46 - v49 + 1) >> 1);
                }
                else {
                  uint64_t v46 = v46;
                }
                if (v49 <= 1) {
                  int v62 = (int)(v47 - v49 + 1) >> 1;
                }
                else {
                  int v62 = v47;
                }
                uint64_t v63 = v46 | (v68 << 32);
                uint64_t v64 = (v65 - v68);
              }
              else
              {
                int v50 = *v36;
                int v51 = *v37;
                int v52 = HIDWORD(v47) + HIDWORD(v46);
                int v53 = v47 + v46;
                if (*(unsigned char *)(v42 + 48)) {
                  int v54 = *v39;
                }
                else {
                  int v54 = *v37;
                }
                if (*(unsigned char *)(v42 + 48)) {
                  int v55 = *v38;
                }
                else {
                  int v55 = *v36;
                }
                unsigned int v56 = (int)(HIDWORD(v46) - (v54 + v48) + 1) >> 1;
                int v57 = (int)(v52 - (v55 + v48) + 1) >> 1;
                BOOL v58 = v48 > 1;
                if (v48 <= 1) {
                  uint64_t v59 = v56;
                }
                else {
                  uint64_t v59 = HIDWORD(v46);
                }
                if (!v58) {
                  int v52 = v57;
                }
                if (*(unsigned char *)(v42 + 49))
                {
                  int v51 = *v39;
                  int v50 = *v38;
                }
                unsigned int v60 = (int)(v46 - (v51 + v49) + 1) >> 1;
                int v61 = (int)(v53 - (v50 + v49) + 1) >> 1;
                if (v49 <= 1) {
                  uint64_t v46 = v60;
                }
                else {
                  uint64_t v46 = v46;
                }
                if (v49 <= 1) {
                  int v62 = v61;
                }
                else {
                  int v62 = v53;
                }
                uint64_t v63 = v46 | (v59 << 32);
                uint64_t v64 = (v52 - v59);
              }
              *(void *)(v42 + 32) = v63;
              *(void *)(v42 + 40) = (v62 - v46) | (unint64_t)(v64 << 32);
            }
            else
            {
              *(_OWORD *)(v42 + 32) = *v136;
            }
            uint64_t result = kdu_dims::operator&=((_DWORD *)(v42 + 32), (int *)(v42 + 16));
            uint64_t v70 = v139;
            uint64_t v69 = v140;
            uint64_t v71 = v140 + 704 * v139;
            *(void *)(v71 + 84) = 0;
            long long v72 = (uint64_t *)(v71 + 84);
            v72[1] = 0;
            if (v139 <= *v31 && *v137)
            {
              uint64_t v138 = v72;
              uint64_t v73 = v140 + 704 * v139;
              int v76 = *(unsigned __int8 *)(v73 + 223);
              uint64_t v75 = (unsigned __int8 *)(v73 + 223);
              LODWORD(v74) = v76;
              if (v76)
              {
                uint64_t v77 = 0;
                unint64_t v78 = 0;
                do
                {
                  uint64_t v79 = *(void *)(v140 + 704 * v139 + 224) + v77;
                  LODWORD(v80) = *(_DWORD *)(*(void *)v79 + 32);
                  LODWORD(v81) = *(_DWORD *)(*(void *)v79 + 36);
                  unsigned int v82 = *(unsigned __int8 *)(v79 + 48);
                  unsigned int v83 = *(unsigned __int8 *)(v79 + 49);
                  int v84 = *v36;
                  int v85 = *(_DWORD *)(*(void *)v79 + 44) + v81;
                  int v86 = *(_DWORD *)(*(void *)v79 + 40) + v80;
                  if (*(unsigned char *)(v79 + 48)) {
                    int v87 = *v39;
                  }
                  else {
                    int v87 = *v142;
                  }
                  if (*(unsigned char *)(v79 + 48)) {
                    int v88 = *v38;
                  }
                  else {
                    int v88 = *v36;
                  }
                  unsigned int v89 = (int)(v81 - (v87 + v82) + 1) >> 1;
                  int v90 = (int)(v85 - (v88 + v82) + 1) >> 1;
                  if (v82 <= 1) {
                    uint64_t v81 = v89;
                  }
                  else {
                    uint64_t v81 = v81;
                  }
                  if (v82 <= 1) {
                    int v85 = v90;
                  }
                  if (*(unsigned char *)(v79 + 49)) {
                    int v91 = *v39;
                  }
                  else {
                    int v91 = *v142;
                  }
                  if (*(unsigned char *)(v79 + 49)) {
                    int v84 = *v38;
                  }
                  unsigned int v92 = (int)(v80 - (v91 + v83) + 1) >> 1;
                  int v93 = (int)(v86 - (v84 + v83) + 1) >> 1;
                  if (v83 <= 1) {
                    uint64_t v80 = v92;
                  }
                  else {
                    uint64_t v80 = v80;
                  }
                  if (v83 <= 1) {
                    int v86 = v93;
                  }
                  *(void *)(v79 + 32) = v80 | (v81 << 32);
                  *(void *)(v79 + 40) = (v86 - v80) | ((unint64_t)(v85 - v81) << 32);
                  uint64_t v94 = v79 + 32;
                  kdu_dims::operator&=((_DWORD *)v94, (int *)(v94 - 16));
                  ++v78;
                  *(void *)(v94 + 28) = 0;
                  *(void *)(v94 + 20) = 0;
                  unint64_t v74 = *v75;
                  v77 += 136;
                }
                while (v78 < v74);
                uint64_t v1 = v135;
                uint64_t v70 = v139;
                uint64_t v69 = v140;
              }
              uint64_t v95 = v69 + 704 * v70;
              int v97 = *(unsigned __int8 *)(v95 + 222);
              int v96 = (unsigned __int8 *)(v95 + 222);
              if (v97)
              {
                uint64_t v98 = 0;
                unint64_t v99 = 0;
                float16x8_t v100 = (uint64_t *)(v140 + 704 * v70 + 240);
                do
                {
                  uint64_t v101 = *v100;
                  uint64_t v102 = *(_DWORD **)(*v100 + v98);
                  if (!v102)
                  {
                    uint64_t v145 = 0;
                    long long v143 = 0u;
                    long long v144 = 0u;
                    kdu_error::kdu_error((kdu_error *)&v143, "Kakadu Core Error:\n");
                    (*(void (**)(long long *, const char *))(v143 + 16))(&v143, "corrupt file: band->parent == NULL\n");
                    kdu_error::~kdu_error((kdu_error *)&v143);
                  }
                  LODWORD(v103) = v102[8];
                  LODWORD(v104) = v102[9];
                  int v105 = v102[10];
                  uint64_t v106 = v101 + v98;
                  unsigned int v107 = *(unsigned __int8 *)(v101 + v98 + 48);
                  unsigned int v108 = *(unsigned __int8 *)(v101 + v98 + 49);
                  int v109 = *v141;
                  int v110 = v102[11] + v104;
                  int v111 = v105 + v103;
                  if (*(unsigned char *)(v101 + v98 + 48)) {
                    int v112 = *v39;
                  }
                  else {
                    int v112 = *v142;
                  }
                  if (*(unsigned char *)(v101 + v98 + 48)) {
                    int v113 = *v38;
                  }
                  else {
                    int v113 = *v141;
                  }
                  unsigned int v114 = (int)(v104 - (v112 + v107) + 1) >> 1;
                  int v115 = (int)(v110 - (v113 + v107) + 1) >> 1;
                  if (v107 <= 1) {
                    uint64_t v104 = v114;
                  }
                  else {
                    uint64_t v104 = v104;
                  }
                  if (v107 <= 1) {
                    int v110 = v115;
                  }
                  if (*(unsigned char *)(v101 + v98 + 49)) {
                    int v116 = *v39;
                  }
                  else {
                    int v116 = *v142;
                  }
                  if (*(unsigned char *)(v101 + v98 + 49)) {
                    int v109 = *v38;
                  }
                  unsigned int v117 = (int)(v103 - (v116 + v108) + 1) >> 1;
                  int v118 = (int)(v111 - (v109 + v108) + 1) >> 1;
                  if (v108 <= 1) {
                    uint64_t v103 = v117;
                  }
                  else {
                    uint64_t v103 = v103;
                  }
                  if (v108 <= 1) {
                    int v111 = v118;
                  }
                  *(void *)(v106 + 32) = v103 | (v104 << 32);
                  *(void *)(v106 + 40) = (v111 - v103) | ((unint64_t)(v110 - v104) << 32);
                  kdu_dims::operator&=((_DWORD *)(v106 + 32), (int *)(v106 + 16));
                  *(void *)(v106 + 108) = get_partition_indices(*(void *)(v106 + 76), *(void *)(v106 + 84), *(void *)(v106 + 32), *(void *)(v106 + 40));
                  *(void *)(v106 + 116) = v119;
                  if (*(int *)(v106 + 44) >= 1 && *(int *)(v106 + 40) >= 1) {
                    kd_node::adjust_cover(*(void *)(v101 + v98), *(void *)(v106 + 32), *(void *)(v106 + 40), *(unsigned __int8 *)(v106 + 48), *(unsigned __int8 *)(v106 + 49));
                  }
                  ++v99;
                  v98 += 144;
                }
                while (v99 < *v96);
                LODWORD(v74) = *v75;
                uint64_t v1 = v135;
              }
              uint64_t v36 = v141;
              if (v74)
              {
                char v120 = (void *)(v140 + 704 * v139 + 224);
                unint64_t v121 = v74 + 1;
                uint64_t v122 = 136 * v74;
                do
                {
                  uint64_t v123 = *v120 + v122;
                  if (*(int *)(v123 - 92) >= 1 && *(int *)(v123 - 96) >= 1) {
                    kd_node::adjust_cover(*(void *)(v123 - 136), *(void *)(*v120 + v122 - 84), *(void *)(*v120 + v122 - 76), *(unsigned __int8 *)(*v120 + v122 - 88), *(unsigned __int8 *)(*v120 + v122 - 87));
                  }
                  --v121;
                  v122 -= 136;
                }
                while (v121 > 1);
              }
              uint64_t v124 = v140 + 704 * v139;
              *(void *)(v124 + 200) = get_partition_indices(*(void *)(v124 + 168), *(void *)(v124 + 176), *v138, v138[1]);
              *(void *)(v124 + 208) = v125;
              uint64_t result = kdu_dims::operator&=((_DWORD *)(v124 + 200), (int *)(v124 + 184));
              uint64_t v70 = v139;
              uint64_t v33 = v133;
              int v31 = v134;
              uint64_t v37 = v142;
              if (v132)
              {
                uint64_t v70 = v139;
                *((_DWORD *)v1 + 52) += *(_DWORD *)(v140 + 704 * v139 + 212)
                                      * *((_DWORD *)v1 + 50)
                                      * *(_DWORD *)(v140 + 704 * v139 + 208);
              }
            }
            else
            {
              uint64_t v126 = v140 + 704 * v139;
              *(void *)(v126 + 200) = 0;
              *(void *)(v126 + 208) = 0;
            }
            uint64_t v40 = v70 - 1;
          }
          while (v70 > 0);
        }
      }
      unint64_t v5 = v131 + 1;
      if ((uint64_t)(v131 + 1) >= *((int *)v1 + 47)) {
        return result;
      }
    }
    if (v8[46] == 1)
    {
      int v9 = *(_DWORD *)(*((void *)v8 + 39) + 104 * v5 + 88);
    }
    else
    {
      char v10 = v1[32];
      if (!v10)
      {
        if (v5 <= 2 && *((unsigned char *)v1 + 286))
        {
          uint64_t v127 = 0;
          unint64_t v128 = &v6[56 * v5];
          *((unsigned char *)v128 + 184) = 0;
          uint64_t v129 = v128 + 46;
          uint64_t v130 = 16;
          while (v127 >= v8[44] || (*(_DWORD *)(*((void *)v8 + 40) + v130) & 0x80000000) != 0)
          {
            ++v127;
            v130 += 48;
            if (v127 == 3) {
              goto LABEL_21;
            }
          }
          *uint64_t v129 = 1;
          goto LABEL_21;
        }
        BOOL v12 = (uint64_t)v5 < v8[44] && *(_DWORD *)(*((void *)v8 + 40) + 48 * v5 + 16) >= 0;
        uint64_t v11 = &v6[56 * v5];
        goto LABEL_20;
      }
      int v9 = *(_DWORD *)(*((void *)v10 + 1) + 4 * v5);
    }
    uint64_t v11 = &v6[56 * v5];
    BOOL v12 = v9 >= 0;
LABEL_20:
    *((unsigned char *)v11 + 184) = v12;
    goto LABEL_21;
  }
  return result;
}

void sub_188642334(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188642340(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  _Unwind_Resume(v21);
}

uint64_t kd_tile::finished_reading(kd_tile *this)
{
  if (!*((unsigned char *)this + 292)) {
    return 0;
  }
  if (*(kd_tile **)(*(void *)this + 440) == this)
  {
    if (*((unsigned char *)this + 328))
    {
      uint64_t v19 = 0;
      memset(v18, 0, sizeof(v18));
      kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v18[0] + 16))(v18, "Assert ");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v18[0] + 16))(v18, "!exhausted");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v18[0] + 16))(v18, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v18);
    }
    *(void *)(*(void *)this + 440) = 0;
    kd_tile::adjust_unloadability((uint64_t *)this);
  }
  else
  {
    kd_tile::adjust_unloadability((uint64_t *)this);
    if (*((unsigned char *)this + 328)) {
      return 0;
    }
  }
  *((unsigned char *)this + 328) = 1;
  if (*((unsigned char *)this + 291))
  {
    if (!*(unsigned char *)(*(void *)this + 408))
    {
      kd_tile::release(this);
      return 1;
    }
  }
  else
  {
    int v3 = *((_DWORD *)this + 47);
    if (v3 >= 1)
    {
      for (uint64_t i = 0; i < v3; ++i)
      {
        uint64_t v5 = *((void *)this + 34);
        uint64_t v6 = v5 + 224 * i;
        int v9 = *(_DWORD *)(v6 + 68);
        char v8 = (int *)(v6 + 68);
        int v7 = v9;
        if ((v9 & 0x80000000) == 0)
        {
          uint64_t v10 = 0;
          uint64_t v11 = (void *)(v5 + 224 * i + 176);
          do
          {
            if (*(_DWORD *)(*v11 + 704 * v10 + 192) * *(_DWORD *)(*v11 + 704 * v10 + 196) >= 1)
            {
              uint64_t v12 = 0;
              unint64_t v13 = (void *)(*v11 + 704 * v10 + 232);
              uint64_t v14 = 8 * (*(_DWORD *)(*v11 + 704 * v10 + 192) * *(_DWORD *)(*v11 + 704 * v10 + 196));
              do
              {
                int v15 = *(uint64_t **)(*v13 + v12);
                if (v15) {
                  BOOL v16 = (*(void *)(*v13 + v12) & 1) == 0;
                }
                else {
                  BOOL v16 = 0;
                }
                if (v16) {
                  kd_precinct::finished_desequencing(v15);
                }
                v12 += 8;
              }
              while (v14 != v12);
              int v7 = *v8;
            }
          }
          while (v10++ < v7);
          int v3 = *((_DWORD *)this + 47);
        }
      }
    }
  }
  return 0;
}

void sub_188642588(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188642594()
{
  _Unwind_Resume(v0);
}

void kd_tile::recycle(kd_tile *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*((_DWORD *)this + 70))
  {
    uint64_t v90 = 0;
    long long v88 = 0u;
    long long v89 = 0u;
    kdu_error::kdu_error((kdu_error *)&v88, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v88 + 16))(&v88, "Assert ");
    (*(void (**)(long long *, const char *))(v88 + 16))(&v88, "structure_bytes == 0");
    (*(void (**)(long long *, const char *))(v88 + 16))(&v88, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v88);
  }
  if (*((void *)this + 3) || (*((_DWORD *)this + 2) & 0x80000000) == 0 || !*((unsigned char *)this + 184))
  {
    uint64_t v90 = 0;
    long long v88 = 0u;
    long long v89 = 0u;
    kdu_error::kdu_error((kdu_error *)&v88, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v88 + 16))(&v88, "Assert ");
    (*(void (**)(long long *, const char *))(v88 + 16))(&v88, "(tile_ref == NULL) && (t_num < 0) && is_typical");
    (*(void (**)(long long *, const char *))(v88 + 16))(&v88, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v88);
  }
  *((void *)this + 3) = a2;
  *(void *)((char *)this + 12) = a3;
  uint64_t v7 = *(void *)this;
  *((_DWORD *)this + 2) = HIDWORD(a3) + *(_DWORD *)(*(void *)this + 224) * a3;
  *((unsigned char *)this + 184) = 0;
  *(void *)((char *)this + 212) = a4;
  *(void *)((char *)this + 220) = a5;
  *(void *)((char *)this + 236) = 0;
  *((void *)this + 9) = 0;
  if (*((void *)this + 10)
    || *((void *)this + 11)
    || *((void *)this + 12)
    || *((void *)this + 7)
    || *((void *)this + 8))
  {
    uint64_t v90 = 0;
    long long v88 = 0u;
    long long v89 = 0u;
    kdu_error::kdu_error((kdu_error *)&v88, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v88 + 16))(&v88, "Assert ");
    (*(void (**)(long long *, const char *))(v88 + 16))(&v88, "(ppt_markers == NULL) && (packed_headers == NULL) && (sequencer == NULL) && (unloadable_next == NULL) && (unloadable_prev == NULL)");
    (*(void (**)(long long *, const char *))(v88 + 16))(&v88, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v88);
  }
  *((unsigned char *)this + 328) = 0;
  *((unsigned char *)this + 287) = 0;
  *((_DWORD *)this + 80) = 0;
  *((unsigned char *)this + 293) = 0;
  *(_DWORD *)((char *)this + 289) = 0;
  *((unsigned char *)this + 316) = 0;
  *(void *)((char *)this + 308) = 0;
  *(void *)((char *)this + 300) = 0;
  if (*((_DWORD *)this + 47) != *(_DWORD *)(v7 + 168))
  {
    uint64_t v90 = 0;
    long long v88 = 0u;
    long long v89 = 0u;
    kdu_error::kdu_error((kdu_error *)&v88, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v88 + 16))(&v88, "Assert ");
    (*(void (**)(long long *, const char *))(v88 + 16))(&v88, "num_components == codestream->num_components");
    (*(void (**)(long long *, const char *))(v88 + 16))(&v88, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v88);
  }
  if (*(void *)(v7 + 8))
  {
    *((void *)this + 4) = **((void **)this + 3);
    int v78 = kd_tile::read_tile_part_header(this) ^ 1;
    uint64_t v7 = *(void *)this;
  }
  else
  {
    LOBYTE(v78) = 0;
  }
  if ((kdu_params::check_typical_tile(*(kdu_params **)(v7 + 24), *((_DWORD *)this + 2)) & 1) == 0 && (v78 & 1) == 0)
  {
    uint64_t v8 = *((void *)this + 34);
    if (v8)
    {
      uint64_t v9 = v8 - 16;
      uint64_t v10 = *(void *)(v8 - 8);
      if (v10)
      {
        uint64_t v11 = v8 - 224;
        uint64_t v12 = 224 * v10;
        do
        {
          kd_tile_comp::~kd_tile_comp((kd_tile_comp *)(v11 + v12));
          v12 -= 224;
        }
        while (v12);
      }
      MEMORY[0x18C11C0C0](v9, 0x10A0C802A3299D9);
    }
    unint64_t v13 = (kd_mct_stage *)*((void *)this + 32);
    *((void *)this + 34) = 0;
    while (1)
    {
      *((void *)this + 33) = v13;
      if (!v13) {
        break;
      }
      *((void *)this + 32) = *((void *)v13 + 7);
      kd_mct_stage::~kd_mct_stage(v13);
      MEMORY[0x18C11C0E0]();
      unint64_t v13 = (kd_mct_stage *)*((void *)this + 32);
    }
    *((unsigned char *)this + 292) = 1;
    *(_DWORD *)((char *)this + 294) = 0;
    kd_tile::initialize(this);
  }
  *((unsigned char *)this + 184) = 1;
  int v15 = *((_DWORD *)this + 47);
  int v14 = *((_DWORD *)this + 48);
  *((_DWORD *)this + 49) = v14;
  uint64_t v16 = *((void *)this + 34);
  *((_DWORD *)this + 51) = 0;
  if (v15 < 1)
  {
    int v77 = 0;
  }
  else
  {
    unsigned int v86 = 0;
    unsigned int v82 = HIDWORD(a5) + HIDWORD(a4) - 1;
    int v83 = a5 + a4;
    int v84 = HIDWORD(a5) + HIDWORD(a4);
    unsigned int v80 = -(HIDWORD(a5) + HIDWORD(a4));
    unsigned int v81 = a5 + a4 - 1;
    unsigned int v79 = -(a5 + a4);
    int v17 = 336;
    do
    {
      *(_WORD *)(v16 + 184) = 257;
      *(_DWORD *)(v16 + 156) = -1082130432;
      if (*(int *)(v16 + 32) <= 1) {
        unsigned int v18 = 1;
      }
      else {
        unsigned int v18 = *(_DWORD *)(v16 + 32);
      }
      if (a4 <= 0) {
        uint64_t v19 = -(int)(-HIDWORD(a4) / v18);
      }
      else {
        uint64_t v19 = (HIDWORD(a4) - 1) / v18 + 1;
      }
      if (v84 <= 0) {
        int v20 = -(int)(v80 / v18);
      }
      else {
        int v20 = v82 / v18 + 1;
      }
      if (*(int *)(v16 + 28) <= 1) {
        unsigned int v21 = 1;
      }
      else {
        unsigned int v21 = *(_DWORD *)(v16 + 28);
      }
      if ((int)a4 <= 0) {
        unsigned int v22 = -(int)(-(int)a4 / v21);
      }
      else {
        unsigned int v22 = ((int)a4 - 1) / v21 + 1;
      }
      if (v83 <= 0) {
        int v23 = -(int)(v79 / v21);
      }
      else {
        int v23 = v81 / v21 + 1;
      }
      v17 += 224;
      *(void *)(v16 + 36) = v22 | (unint64_t)(v19 << 32);
      *(void *)(v16 + 44) = (v23 - v22) | ((unint64_t)(v20 - v19) << 32);
      uint64_t v24 = *(unsigned int *)(v16 + 68);
      *(_DWORD *)(v16 + 72) = v24;
      if ((v24 & 0x80000000) == 0)
      {
        do
        {
          uint64_t v25 = *(void *)(v16 + 176);
          if (v24 == *(_DWORD *)(v16 + 68))
          {
            uint64_t v26 = v25 + 704 * v24;
            *(_OWORD *)(v26 + 48) = *(_OWORD *)(v16 + 36);
            uint64_t v27 = *(void *)(v26 + 48);
            unint64_t v28 = *(void *)(v26 + 56);
          }
          else
          {
            uint64_t v29 = v25 + 704 * v24;
            int v31 = *(_DWORD **)(v29 + 32);
            uint64_t v30 = v29 + 32;
            LODWORD(v32) = v31[4];
            LODWORD(v33) = v31[5];
            unsigned int v34 = *(unsigned __int8 *)(v30 + 48);
            unsigned int v35 = *(unsigned __int8 *)(v30 + 49);
            int v36 = v31[7] + v33;
            int v37 = v31[6] + v32;
            if (v34 <= 1) {
              uint64_t v33 = ((int)(v33 - v34 + 1) >> 1);
            }
            else {
              uint64_t v33 = v33;
            }
            if (v34 <= 1) {
              int v36 = (int)(v36 - v34 + 1) >> 1;
            }
            if (v35 <= 1) {
              uint64_t v32 = ((int)(v32 - v35 + 1) >> 1);
            }
            else {
              uint64_t v32 = v32;
            }
            if (v35 <= 1) {
              int v37 = (int)(v37 - v35 + 1) >> 1;
            }
            uint64_t v27 = v32 | (v33 << 32);
            unint64_t v28 = (v37 - v32) | ((unint64_t)(v36 - v33) << 32);
            *(void *)(v30 + 16) = v27;
            *(void *)(v30 + 24) = v28;
          }
          uint64_t v38 = v25 + 704 * v24;
          int v40 = *(_DWORD *)(v38 + 196);
          uint64_t v39 = (int *)(v38 + 196);
          *(void *)(v39 - 45) = 0;
          int v41 = *(v39 - 1) * v40;
          *(void *)(v39 + 1) = get_partition_indices(*(void *)(v39 - 7), *(void *)(v39 - 5), v27, v28);
          *(void *)(v39 + 3) = v42;
          *(_OWORD *)(v39 - 3) = *(_OWORD *)(v39 + 1);
          int v87 = *(v39 - 1) * *v39;
          if (v41 != v87)
          {
            uint64_t v43 = *(void *)(v25 + 704 * v24 + 232);
            if (v43)
            {
              uint64_t v46 = *(void *)(v43 - 8);
              uint64_t v45 = v43 - 8;
              uint64_t v44 = v46;
              if (v46)
              {
                uint64_t v47 = 8 * v44;
                do
                {
                  kd_precinct_ref::~kd_precinct_ref((kd_precinct_ref *)(v45 + v47));
                  v47 -= 8;
                }
                while (v47);
              }
              MEMORY[0x18C11C0C0](v45 - 8, 0x1000C8000313F17);
            }
            operator new[]();
          }
          *((_DWORD *)this + 51) += v87;
          uint64_t v48 = *(void *)this;
          if (v86 <= 3 && !v24 && *(int *)(v48 + 160) <= 1)
          {
            uint64_t v49 = *(void *)(v25 + 8);
            if (*(_DWORD *)(v49 + 32) * *(_DWORD *)(v25 + 60) > 128
              || *(_DWORD *)(v49 + 28) * *(_DWORD *)(v25 + 56) >= 129)
            {
              uint64_t v90 = 0;
              long long v88 = 0u;
              long long v89 = 0u;
              kdu_warning::kdu_warning((kdu_warning *)&v88, "Kakadu Core Warning:\n");
              (*(void (**)(long long *, const char *))(v88 + 16))(&v88, "Profile violation detected (code-stream is technically illegal).  Profile-0 and Profile-1 code-streams must have sufficient DWT levels to permit extraction of a low resolution image which is no larger than 128x128.   Try setting a larger value for \"Clevels\" or else set \"Sprofile\" to 2.");
              *(_DWORD *)(*(void *)this + 160) = 2;
              kdu_warning::~kdu_warning((kdu_warning *)&v88);
              uint64_t v48 = *(void *)this;
            }
          }
          if (!*(_DWORD *)(v48 + 160)
            && *(int *)(v25 + 704 * v24 + 60) <= 128
            && *(int *)(v25 + 704 * v24 + 56) <= 128
            && *(v39 - 1) * (uint64_t)*v39 >= 2)
          {
            uint64_t v90 = 0;
            long long v88 = 0u;
            long long v89 = 0u;
            kdu_warning::kdu_warning((kdu_warning *)&v88, "Kakadu Core Warning:\n");
            (*(void (**)(long long *, const char *))(v88 + 16))(&v88, "Profile violation detected (code-stream is technically illegal).  Profile-0 code-streams may have multiple precincts only in those tile-component resolutions whose dimensions are greater than 128x128.");
            *(_DWORD *)(*(void *)this + 160) = 2;
            kdu_warning::~kdu_warning((kdu_warning *)&v88);
          }
          uint64_t v50 = v25 + 704 * v24;
          int v52 = *(unsigned __int8 *)(v50 + 223);
          int v51 = (unsigned __int8 *)(v50 + 223);
          if (v52)
          {
            uint64_t v53 = 0;
            unint64_t v54 = 0;
            do
            {
              uint64_t v55 = *(void *)(v25 + 704 * v24 + 224) + v53;
              LODWORD(v56) = *(_DWORD *)(*(void *)v55 + 16);
              LODWORD(v57) = *(_DWORD *)(*(void *)v55 + 20);
              unsigned int v58 = *(unsigned __int8 *)(v55 + 48);
              unsigned int v59 = *(unsigned __int8 *)(v55 + 49);
              int v60 = *(_DWORD *)(*(void *)v55 + 28) + v57;
              int v61 = *(_DWORD *)(*(void *)v55 + 24) + v56;
              if (v58 <= 1) {
                uint64_t v57 = ((int)(v57 - v58 + 1) >> 1);
              }
              else {
                uint64_t v57 = v57;
              }
              if (v58 <= 1) {
                int v60 = (int)(v60 - v58 + 1) >> 1;
              }
              if (v59 <= 1) {
                uint64_t v56 = ((int)(v56 - v59 + 1) >> 1);
              }
              else {
                uint64_t v56 = v56;
              }
              if (v59 <= 1) {
                int v61 = (int)(v61 - v59 + 1) >> 1;
              }
              *(void *)(v55 + 16) = v56 | (v57 << 32);
              *(void *)(v55 + 24) = (v61 - v56) | ((unint64_t)(v60 - v57) << 32);
              ++v54;
              v53 += 136;
            }
            while (v54 < *v51);
          }
          uint64_t v62 = v25 + 704 * v24;
          int v64 = *(unsigned __int8 *)(v62 + 222);
          uint64_t v63 = (unsigned __int8 *)(v62 + 222);
          if (v64)
          {
            uint64_t v65 = 0;
            unint64_t v66 = 0;
            do
            {
              uint64_t v67 = *(void *)(v25 + 704 * v24 + 240) + v65;
              LODWORD(v68) = *(_DWORD *)(*(void *)v67 + 16);
              LODWORD(v69) = *(_DWORD *)(*(void *)v67 + 20);
              unsigned int v70 = *(unsigned __int8 *)(v67 + 48);
              unsigned int v71 = *(unsigned __int8 *)(v67 + 49);
              int v72 = *(_DWORD *)(*(void *)v67 + 28) + v69;
              int v73 = *(_DWORD *)(*(void *)v67 + 24) + v68;
              if (v70 <= 1) {
                uint64_t v69 = ((int)(v69 - v70 + 1) >> 1);
              }
              else {
                uint64_t v69 = v69;
              }
              if (v70 <= 1) {
                int v72 = (int)(v72 - v70 + 1) >> 1;
              }
              if (v71 <= 1) {
                uint64_t v68 = ((int)(v68 - v71 + 1) >> 1);
              }
              else {
                uint64_t v68 = v68;
              }
              if (v71 <= 1) {
                int v73 = (int)(v73 - v71 + 1) >> 1;
              }
              uint64_t v74 = v68 | (v69 << 32);
              *(void *)(v67 + 16) = v74;
              *(void *)(v67 + 24) = (v73 - v68) | ((unint64_t)(v72 - v69) << 32);
              *(void *)(v67 + 92) = get_partition_indices(*(void *)(v67 + 76), *(void *)(v67 + 84), v74, v73 - (int)v68);
              *(void *)(v67 + 100) = v75;
              ++v66;
              v65 += 144;
            }
            while (v66 < *v63);
          }
          v17 += 704 + 8 * v87;
          kd_resolution::complete_initialization((kd_resolution *)(v25 + 704 * v24));
        }
        while (v24-- > 0);
      }
      v16 += 224;
      ++v86;
    }
    while ((signed int)v86 < *((_DWORD *)this + 47));
    int v14 = *((_DWORD *)this + 48);
    int v77 = *((_DWORD *)this + 51);
  }
  *((_DWORD *)this + 50) = v14;
  *((_DWORD *)this + 52) = v77 * v14;
  *((unsigned char *)this + 292) = 1;
  *(void *)((char *)this + 308) = 0;
  *((unsigned char *)this + 316) = 0;
  if (*((void *)this + 12))
  {
    uint64_t v90 = 0;
    long long v88 = 0u;
    long long v89 = 0u;
    kdu_error::kdu_error((kdu_error *)&v88, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v88 + 16))(&v88, "Assert ");
    (*(void (**)(long long *, const char *))(v88 + 16))(&v88, "sequencer == NULL");
    (*(void (**)(long long *, const char *))(v88 + 16))(&v88, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v88);
  }
  operator new();
}

void sub_188643318(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1020C40539952E0);
  _Unwind_Resume(a1);
}

uint64_t *kd_tile::restart(kd_tile *this)
{
  uint64_t v1 = this;
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  int v2 = **(kdu_message ***)this;
  if (v2)
  {
    if (*((unsigned char *)this + 288))
    {
      kd_tile::remove_from_in_progress_list((uint64_t *)this);
      int v2 = **(kdu_message ***)v1;
    }
    (*(void (**)(kdu_message *, const char *))(*(void *)v2 + 16))(v2, "\n>> New attributes for tile ");
    long long v49 = 0u;
    long long v50 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    *(_OWORD *)uint64_t v46 = 0u;
    if (*((unsigned char *)v2 + 8)) {
      sprintf(v46, "%x");
    }
    else {
      sprintf(v46, "%d");
    }
    (*(void (**)(kdu_message *, char *))(*(void *)v2 + 16))(v2, v46);
    (*(void (**)(kdu_message *, const char *))(*(void *)v2 + 16))(v2, ":\n");
    kdu_params::textualize_attributes(*(void *)(*(void *)v1 + 24), v2, *((_DWORD *)v1 + 2), *((_DWORD *)v1 + 2), 1);
    (*(void (**)(kdu_message *, void))(*(void *)v2 + 32))(v2, 0);
  }
  *((unsigned char *)v1 + 184) = 0;
  *((void *)v1 + 4) = 0;
  uint64_t v3 = *((void *)v1 + 11);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *((void *)v1 + 11) = 0;
  uint64_t result = kd_precinct_pointer_server::disable((uint64_t *)v1 + 13);
  *(_WORD *)((char *)v1 + 291) = 0;
  *((unsigned char *)v1 + 293) = 1;
  int v6 = *((_DWORD *)v1 + 47);
  int v5 = *((_DWORD *)v1 + 48);
  *((_DWORD *)v1 + 50) = v5;
  int v7 = *((_DWORD *)v1 + 51) * v5;
  *(void *)((char *)v1 + 236) = 0;
  *((unsigned char *)v1 + 328) = 0;
  *((_DWORD *)v1 + 52) = v7;
  *((unsigned char *)v1 + 316) = 0;
  *((_DWORD *)v1 + 80) = 0;
  *((_DWORD *)v1 + 78) = 0;
  *((void *)v1 + 38) = 0;
  *((_DWORD *)v1 + 75) = 0;
  if (v6 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v43 = (int *)v1;
    do
    {
      uint64_t v9 = *((void *)v1 + 34);
      uint64_t v44 = v8;
      uint64_t v10 = v9 + 224 * v8;
      int v12 = *(_DWORD *)(v10 + 68);
      uint64_t v11 = (int *)(v10 + 68);
      *((_WORD *)v11 + 58) = 257;
      v11[22] = -1082130432;
      v11[1] = v12;
      *((_OWORD *)v11 - 1) = *((_OWORD *)v11 - 2);
      if ((v12 & 0x80000000) == 0)
      {
        uint64_t v13 = 0;
        uint64_t v45 = (uint64_t *)(v9 + 224 * v8 + 176);
        do
        {
          uint64_t v14 = *v45;
          uint64_t v15 = *v45 + 704 * v13;
          int v17 = *(unsigned __int8 *)(v15 + 223);
          uint64_t v16 = (unsigned __int8 *)(v15 + 223);
          *(void *)(v16 - 207) = 0;
          long long v18 = *(_OWORD *)(v16 - 175);
          *(_OWORD *)(v16 - 139) = v18;
          *(_OWORD *)(v16 - 159) = v18;
          *(_OWORD *)(v16 - 23) = *(_OWORD *)(v16 - 39);
          if (v17)
          {
            uint64_t v19 = 0;
            unint64_t v20 = 0;
            do
            {
              unsigned int v21 = (_OWORD *)(*(void *)(v14 + 704 * v13 + 224) + v19);
              long long v22 = v21[1];
              *(_OWORD *)((char *)v21 + 52) = v22;
              v21[2] = v22;
              ++v20;
              v19 += 136;
            }
            while (v20 < *v16);
          }
          uint64_t v23 = v14 + 704 * v13;
          int v25 = *(unsigned __int8 *)(v23 + 222);
          uint64_t v24 = (unsigned __int8 *)(v23 + 222);
          if (v25)
          {
            uint64_t v26 = 0;
            unint64_t v27 = 0;
            do
            {
              unint64_t v28 = (_OWORD *)(*(void *)(v14 + 704 * v13 + 240) + v26);
              v28[2] = v28[1];
              *(_OWORD *)((char *)v28 + 108) = *(_OWORD *)((char *)v28 + 92);
              ++v27;
              v26 += 144;
            }
            while (v27 < *v24);
          }
          uint64_t v29 = v14 + 704 * v13;
          int v32 = *(_DWORD *)(v29 + 192);
          int v31 = (int *)(v29 + 192);
          int v30 = v32;
          if (v32 >= 1)
          {
            int v33 = 0;
            uint64_t v34 = v14 + 704 * v13;
            int v37 = *(_DWORD *)(v34 + 196);
            uint64_t v36 = v34 + 196;
            int v35 = v37;
            do
            {
              if (v35 >= 1)
              {
                for (uint64_t i = 0; i < v35; *(void *)(v39 + 8 * i++) = 0)
                {
                  uint64_t v39 = *(void *)(v36 + 36) + 8 * v33 * v35;
                  uint64_t v40 = *(void *)(v39 + 8 * i);
                  if (v40) {
                    BOOL v41 = (*(void *)(v39 + 8 * i) & 1) == 0;
                  }
                  else {
                    BOOL v41 = 0;
                  }
                  if (v41)
                  {
                    *(void *)(v40 + 8) = 0;
                    kd_precinct::closing((unsigned __int8 **)v40);
                    uint64_t result = (uint64_t *)kd_precinct_size_class::release(*(kd_precinct_size_class **)(v40 + 72), (kd_precinct *)v40);
                    int v35 = *(_DWORD *)v36;
                  }
                }
                int v30 = *v31;
              }
              ++v33;
            }
            while (v33 < v30);
          }
        }
        while (v13++ < *v11);
      }
      uint64_t v1 = (kd_tile *)v43;
      uint64_t v8 = v44 + 1;
    }
    while (v44 + 1 < v43[47]);
  }
  return result;
}

uint64_t kd_tile::reinitialize(kd_tile *this)
{
  if (!*((unsigned char *)this + 293) || *((unsigned char *)this + 289))
  {
    uint64_t v15 = 0;
    long long v13 = 0u;
    long long v14 = 0u;
    kdu_error::kdu_error((kdu_error *)&v13, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v13 + 16))(&v13, "Assert ");
    (*(void (**)(long long *, const char *))(v13 + 16))(&v13, "needs_reinit && !is_open");
    (*(void (**)(long long *, const char *))(v13 + 16))(&v13, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v13);
  }
  *((unsigned char *)this + 293) = 0;
  uint64_t v2 = *((void *)this + 3);
  if (*(kd_tile **)(v2 + 16) != this)
  {
    uint64_t v15 = 0;
    long long v13 = 0u;
    long long v14 = 0u;
    kdu_error::kdu_error((kdu_error *)&v13, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v13 + 16))(&v13, "Assert ");
    (*(void (**)(long long *, const char *))(v13 + 16))(&v13, "tile_ref->tile == this");
    (*(void (**)(long long *, const char *))(v13 + 16))(&v13, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v13);
  }
  *((void *)this + 4) = *(void *)v2;
  uint64_t v3 = *(void *)this;
  if (*(void *)(*(void *)this + 8))
  {
    if (!kd_tile::read_tile_part_header(this))
    {
      int v11 = 1;
      goto LABEL_23;
    }
    uint64_t v3 = *(void *)this;
  }
  if (kdu_params::any_changes(*(kdu_params **)(v3 + 24)))
  {
    uint64_t v4 = *((void *)this + 12);
    if (v4) {
      MEMORY[0x18C11C0E0](v4, 0x1020C40539952E0);
    }
    *((void *)this + 12) = 0;
    uint64_t v5 = *((void *)this + 34);
    if (v5)
    {
      uint64_t v6 = v5 - 16;
      uint64_t v7 = *(void *)(v5 - 8);
      if (v7)
      {
        uint64_t v8 = v5 - 224;
        uint64_t v9 = 224 * v7;
        do
        {
          kd_tile_comp::~kd_tile_comp((kd_tile_comp *)(v8 + v9));
          v9 -= 224;
        }
        while (v9);
      }
      MEMORY[0x18C11C0C0](v6, 0x10A0C802A3299D9);
    }
    uint64_t v10 = (kd_mct_stage *)*((void *)this + 32);
    *((void *)this + 34) = 0;
    while (1)
    {
      *((void *)this + 33) = v10;
      if (!v10) {
        break;
      }
      *((void *)this + 32) = *((void *)v10 + 7);
      kd_mct_stage::~kd_mct_stage(v10);
      MEMORY[0x18C11C0E0]();
      uint64_t v10 = (kd_mct_stage *)*((void *)this + 32);
    }
    *(_DWORD *)((char *)this + 294) = 0;
    *((unsigned char *)this + 292) = 1;
    kd_buf_server::augment_structure_bytes(*(void *)(*(void *)this + 48), -*((_DWORD *)this + 70));
    *((_DWORD *)this + 70) = 0;
    kd_tile::initialize(this);
  }
  int v11 = 0;
LABEL_23:
  *((unsigned char *)this + 292) = 1;
  kd_packet_sequencer::init(*((kd_packet_sequencer **)this + 12));
  if (!*(unsigned char *)(*(void *)this + 417))
  {
    kd_tile::set_elements_of_interest((int **)this);
    if (!v11) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
  if (v11) {
LABEL_25:
  }
    kd_tile::finished_reading(this);
LABEL_26:
  uint64_t result = kdu_params::check_typical_tile(*(kdu_params **)(*(void *)this + 24), *((_DWORD *)this + 2));
  *((unsigned char *)this + 184) = result;
  return result;
}

void sub_188643AD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188643ADC()
{
  _Unwind_Resume(v0);
}

uint64_t *kd_tile::open(kd_tile *this)
{
  uint64_t v1 = (uint64_t *)this;
  if (*((unsigned char *)this + 289))
  {
    uint64_t v58 = 0;
    long long v56 = 0u;
    long long v57 = 0u;
    kdu_error::kdu_error((kdu_error *)&v56, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v56 + 16))(&v56, "You must close a tile before you can re-open it.");
    kdu_error::~kdu_error((kdu_error *)&v56);
  }
  if (!*((void *)this + 34))
  {
    uint64_t v58 = 0;
    long long v56 = 0u;
    long long v57 = 0u;
    kdu_error::kdu_error((kdu_error *)&v56, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v56 + 16))(&v56, "kd_tile::initialize failed.");
    kdu_error::~kdu_error((kdu_error *)&v56);
  }
  uint64_t v2 = *(void *)this;
  if (*(unsigned char *)(*(void *)this + 417))
  {
    kd_tile::set_elements_of_interest((int **)this);
    uint64_t v2 = *v1;
  }
  if (*(void *)(v2 + 16))
  {
    if (*((unsigned char *)v1 + 288) || v1[5])
    {
      uint64_t v58 = 0;
      long long v56 = 0u;
      long long v57 = 0u;
      kdu_error::kdu_error((kdu_error *)&v56, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v56 + 16))(&v56, "Assert ");
      (*(void (**)(long long *, const char *))(v56 + 16))(&v56, "(!is_in_progress) && (in_progress_next == NULL)");
      (*(void (**)(long long *, const char *))(v56 + 16))(&v56, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v56);
    }
    uint64_t v3 = *(void *)(v2 + 344);
    v1[6] = v3;
    uint64_t v4 = (uint64_t **)(v3 ? v3 + 40 : v2 + 336);
    _DWORD *v4 = v1;
    *(void *)(v2 + 344) = v1;
    *((unsigned char *)v1 + 288) = 1;
    if (*((int *)v1 + 47) >= 1)
    {
      uint64_t v5 = 0;
      uint64_t v43 = v1;
      do
      {
        uint64_t v6 = v1[34];
        uint64_t v7 = *(void *)(*v1 + 352) + 88 * v5;
        uint64_t v8 = v6 + 224 * v5;
        unsigned int v10 = *(_DWORD *)(v8 + 68);
        uint64_t v9 = (_DWORD *)(v8 + 68);
        uint64_t v11 = v10;
        if ((v10 & 0x80000000) != 0)
        {
LABEL_76:
          unsigned int v39 = 33 - v11;
          do
          {
            kd_global_rescomp::notify_tile_status(v7, *(uint64_t *)((char *)v1 + 212), *(uint64_t *)((char *)v1 + 220), 0);
            int v37 = *((_DWORD *)v1 + 47);
            v7 += 88 * v37;
            --v39;
          }
          while (v39 > 1);
          goto LABEL_78;
        }
        BOOL v41 = v9;
        uint64_t v42 = v5;
        char v47 = 0;
        uint64_t v45 = (uint64_t *)(v6 + 224 * v5 + 176);
        uint64_t v12 = v11;
        do
        {
          uint64_t v13 = *v45;
          uint64_t v14 = *v45 + 704 * v12;
          uint64_t v15 = *(void *)(v14 + 16);
          v47 |= v15 != 0;
          if ((v47 & 1) == 0)
          {
            *(void *)(v14 + 16) = v7;
            kd_global_rescomp::notify_tile_status(v7, *(uint64_t *)((char *)v1 + 212), *(uint64_t *)((char *)v1 + 220), 1);
            if (!*(unsigned char *)(v13 + 704 * v12 + 24)) {
              goto LABEL_71;
            }
            uint64_t v16 = v13 + 704 * v12;
            int v18 = *(_DWORD *)(v16 + 196);
            int v17 = (int *)(v16 + 196);
            if (v18 < 1) {
              goto LABEL_71;
            }
            uint64_t v46 = (int *)(v13 + 704 * v12 + 192);
            if (*v46 < 1) {
              goto LABEL_71;
            }
            int v19 = 0;
            uint64_t v44 = v12;
            unint64_t v20 = (int32x2_t *)(v13 + 704 * v12);
            int32x2_t v50 = v20[16];
            int32x2_t v21 = v20[17];
            int32x2_t v22 = *(int32x2_t *)(v17 - 3);
            int32x2_t v54 = 0;
            int32x2_t v55 = 0;
            int32x2_t v23 = v20[22];
            int32x2_t v24 = vmla_s32(v20[21], v23, v22);
            long long v48 = (int *)&v20[6];
            int32x2_t v49 = v21;
            int v25 = v20 + 29;
            while (2)
            {
              int v51 = v19;
              if (v19)
              {
                if (*v17 >= 2 && *(void *)&v50 != 0)
                {
                  int v26 = *v17 - 1;
                  if ((v19 & 2) != 0) {
                    goto LABEL_33;
                  }
LABEL_27:
                  int v27 = 0;
LABEL_38:
                  int32x2_t v54 = vmla_s32(v24, v23, (int32x2_t)__PAIR64__(v26, v27));
                  int32x2_t v55 = v23;
                  kdu_dims::operator&=(&v54, v48);
                  if ((!*(void *)&v50 || v55.i32[1] == 1 && (v54.i8[4] & 1) == 0)
                    && (!*(void *)&v49 || v55.i32[0] == 1 && (v54.i8[0] & 1) == 0))
                  {
                    if (v50)
                    {
                      int v30 = 1;
                    }
                    else
                    {
                      if (v26)
                      {
                        uint64_t v58 = 0;
                        long long v56 = 0u;
                        long long v57 = 0u;
                        kdu_error::kdu_error((kdu_error *)&v56, "Kakadu Core Error:\n");
                        (*(void (**)(long long *, const char *))(v56 + 16))(&v56, "Assert ");
                        (*(void (**)(long long *, const char *))(v56 + 16))(&v56, "p_idx.x == 0");
                        (*(void (**)(long long *, const char *))(v56 + 16))(&v56, " FAILED");
                        kdu_error::~kdu_error((kdu_error *)&v56);
                      }
                      int v30 = *v17;
                    }
                    int v53 = v30;
                    if (v49)
                    {
                      int v31 = 1;
LABEL_54:
                      uint64_t v52 = v26;
                      while (v53 < 1)
                      {
LABEL_67:
                        ++v27;
                        BOOL v36 = __OFSUB__(v31--, 1);
                        if ((v31 < 0) ^ v36 | (v31 == 0)) {
                          goto LABEL_69;
                        }
                      }
                      uint64_t v32 = v52;
                      int v33 = v53 + 1;
                      while (2)
                      {
                        uint64_t v34 = (uint64_t *)(*(void *)v25 + 8 * (v32 + *v17 * (uint64_t)v27));
                        uint64_t v35 = *v34;
                        if (!*v34) {
                          goto LABEL_63;
                        }
                        if (v35 == 3)
                        {
                          uint64_t v35 = 0;
                          goto LABEL_66;
                        }
                        if (v35)
                        {
LABEL_63:
                          uint64_t v35 = kd_precinct_ref::instantiate_precinct(v34, v14, v27 | (unint64_t)(v32 << 32));
                        }
                        else
                        {
                          if (*(unsigned char *)(v35 + 20))
                          {
                            kd_precinct_size_class::withdraw_from_inactive_list(*(void *)(v35 + 72), (kd_precinct *)v35);
                            goto LABEL_65;
                          }
                          if (*(unsigned char *)(v35 + 19)) {
LABEL_65:
                          }
                            kd_precinct::activate(v35);
                        }
LABEL_66:
                        kd_global_rescomp::add_ready_precinct(v7, (void *)v35);
                        --v33;
                        ++v32;
                        if (v33 <= 1) {
                          goto LABEL_67;
                        }
                        continue;
                      }
                    }
                    if (v27)
                    {
                      uint64_t v58 = 0;
                      long long v56 = 0u;
                      long long v57 = 0u;
                      kdu_error::kdu_error((kdu_error *)&v56, "Kakadu Core Error:\n");
                      (*(void (**)(long long *, const char *))(v56 + 16))(&v56, "Assert ");
                      (*(void (**)(long long *, const char *))(v56 + 16))(&v56, "p_idx.y == 0");
                      (*(void (**)(long long *, const char *))(v56 + 16))(&v56, " FAILED");
                      kdu_error::~kdu_error((kdu_error *)&v56);
                    }
                    int v31 = *v46;
                    if (*v46 >= 1) {
                      goto LABEL_54;
                    }
                  }
                }
              }
              else
              {
                int v26 = 0;
                if ((v19 & 2) == 0) {
                  goto LABEL_27;
                }
LABEL_33:
                if (*v46 >= 2 && *(void *)&v49 != 0)
                {
                  int v27 = *v46 - 1;
                  goto LABEL_38;
                }
              }
LABEL_69:
              int v19 = v51 + 1;
              if (v51 == 3)
              {
                uint64_t v1 = v43;
                uint64_t v12 = v44;
                goto LABEL_71;
              }
              continue;
            }
          }
          if (v15 != v7)
          {
            uint64_t v58 = 0;
            long long v56 = 0u;
            long long v57 = 0u;
            kdu_error::kdu_error((kdu_error *)&v56, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v56 + 16))(&v56, "Assert ");
            (*(void (**)(long long *, const char *))(v56 + 16))(&v56, "res->rescomp == rc");
            (*(void (**)(long long *, const char *))(v56 + 16))(&v56, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v56);
          }
LABEL_71:
          int v37 = *((_DWORD *)v1 + 47);
          v7 += 88 * v37;
        }
        while (v12-- > 0);
        if (v47)
        {
          uint64_t v5 = v42;
        }
        else
        {
          uint64_t v5 = v42;
          LODWORD(v11) = *v41;
          if ((int)*v41 <= 31) {
            goto LABEL_76;
          }
        }
LABEL_78:
        ++v5;
      }
      while (v5 < v37);
    }
  }
  *((unsigned char *)v1 + 289) = 1;
  uint64_t result = kd_tile::adjust_unloadability(v1);
  ++*(_DWORD *)(*v1 + 260);
  return result;
}

void sub_1886442D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886442DC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  _Unwind_Resume(v25);
}

uint64_t *kd_tile::adjust_unloadability(uint64_t *this)
{
  uint64_t v1 = *this;
  if (*(unsigned char *)(*this + 417) && (*(void *)(v1 + 72) || *(unsigned char *)(v1 + 418)))
  {
    if (*((unsigned char *)this + 289) || *(uint64_t **)(v1 + 440) == this)
    {
      if (*((unsigned char *)this + 290))
      {
        return kd_tile::withdraw_from_unloadable_list(this);
      }
    }
    else if (!*((unsigned char *)this + 290))
    {
      return (uint64_t *)kd_tile::add_to_unloadable_list((uint64_t)this);
    }
  }
  else if (*((unsigned char *)this + 290))
  {
    kd_tile::adjust_unloadability();
  }
  return this;
}

uint64_t kd_node::adjust_cover(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  if ((a3 & 0x8000000080000000) == 0)
  {
    if (a4 <= 1) {
      uint64_t v5 = a4 + 2 * HIDWORD(a2);
    }
    else {
      uint64_t v5 = HIDWORD(a2);
    }
    if (a4 <= 1) {
      int v6 = a4 + 2 * (HIDWORD(a3) + HIDWORD(a2)) - 1;
    }
    else {
      int v6 = HIDWORD(a3) + HIDWORD(a2);
    }
    if (a5 <= 1) {
      uint64_t v7 = a5 + 2 * a2;
    }
    else {
      uint64_t v7 = a2;
    }
    if (a5 <= 1) {
      int v8 = a5 + 2 * (a3 + a2) - 1;
    }
    else {
      int v8 = a3 + a2;
    }
    int v9 = *(_DWORD *)(result + 64);
    if (v9 < 1 || (int v10 = *(_DWORD *)(result + 60), v10 <= 0))
    {
      *(void *)(result + 52) = v7 | (v5 << 32);
      *(void *)(result + 60) = (v8 - v7) | ((unint64_t)(v6 - v5) << 32);
    }
    else
    {
      int v11 = *(_DWORD *)(result + 56) - v5;
      if (v11 < 1)
      {
        LODWORD(v5) = *(_DWORD *)(result + 56);
      }
      else
      {
        *(_DWORD *)(result + 56) = v5;
        v9 += v11;
        *(_DWORD *)(result + 64) = v9;
      }
      int v12 = v6 - v5;
      if (v12 > v9) {
        *(_DWORD *)(result + 64) = v12;
      }
      int v13 = *(_DWORD *)(result + 52) - v7;
      if (v13 < 1)
      {
        LODWORD(v7) = *(_DWORD *)(result + 52);
      }
      else
      {
        *(_DWORD *)(result + 52) = v7;
        v10 += v13;
        *(_DWORD *)(result + 60) = v10;
      }
      int v14 = v8 - v7;
      if (v14 > v10) {
        *(_DWORD *)(result + 60) = v14;
      }
    }
  }
  return result;
}

uint64_t kd_tile::add_to_unloadable_list(uint64_t this)
{
  uint64_t v1 = this;
  if (*(unsigned char *)(this + 290))
  {
    uint64_t v7 = 0;
    long long v5 = 0u;
    long long v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v5 + 16))(&v5, "Assert ");
    (*(void (**)(long long *, const char *))(v5 + 16))(&v5, "!is_unloadable");
    (*(void (**)(long long *, const char *))(v5 + 16))(&v5, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void *)(*(void *)this + 488);
  *(void *)(this + 56) = 0;
  *(void *)(this + 64) = v3;
  if (v3)
  {
    uint64_t v4 = (void *)(v3 + 56);
  }
  else
  {
    if (*(void *)(v2 + 480))
    {
      uint64_t v7 = 0;
      long long v5 = 0u;
      long long v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v5 + 16))(&v5, "Assert ");
      (*(void (**)(long long *, const char *))(v5 + 16))(&v5, "codestream->unloadable_tiles_head == NULL");
      (*(void (**)(long long *, const char *))(v5 + 16))(&v5, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
    uint64_t v4 = (void *)(v2 + 480);
  }
  void *v4 = this;
  *(void *)(v2 + 488) = this;
  ++*(_DWORD *)(v2 + 504);
  *(unsigned char *)(this + 290) = 1;
  if (!*(void *)(v2 + 496))
  {
    this = kdu_dims::intersects((_DWORD *)(this + 212), (_DWORD *)(v2 + 264));
    if ((this & 1) == 0) {
      *(void *)(*(void *)v1 + 496) = v1;
    }
  }
  return this;
}

void sub_1886446C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886446CC()
{
  _Unwind_Resume(v0);
}

BOOL kdu_dims::intersects(_DWORD *a1, _DWORD *a2)
{
  int v2 = a1[1];
  int v3 = a1[3];
  int v4 = a2[1];
  if (v3 + v2 <= v4) {
    return 0;
  }
  int v5 = a1[2];
  if (v5 + *a1 <= *a2) {
    return 0;
  }
  int v6 = a2[3];
  if (v2 >= v6 + v4) {
    return 0;
  }
  int v7 = a2[2];
  if (*a1 >= v7 + *a2) {
    return 0;
  }
  return v3 > 0 && v5 > 0 && v6 > 0 && v7 > 0;
}

uint64_t kd_precinct::desequence_packet(kd_precinct *this)
{
  if (*((unsigned char *)this + 17) || *((unsigned char *)this + 18)) {
    kd_precinct::desequence_packet();
  }
  int v2 = *(kd_tile **)(*(void *)(*(void *)this + 8) + 8);
  uint64_t packet = kd_precinct::read_packet((uint64_t **)this);
  if (packet)
  {
    int v4 = *((_DWORD *)this + 7) + 1;
    *((_DWORD *)this + 7) = v4;
    if (v4 == *((_DWORD *)v2 + 48)) {
      kd_precinct::finished_desequencing((uint64_t *)this);
    }
    ++*((_DWORD *)v2 + 78);
    if (*((unsigned char *)this + 21))
    {
      if (*((_DWORD *)this + 7) <= *((_DWORD *)v2 + 50))
      {
        int v5 = *((_DWORD *)v2 + 77) + 1;
        *((_DWORD *)v2 + 77) = v5;
        if (v5 == *((_DWORD *)v2 + 52)) {
          kd_tile::finished_reading(v2);
        }
      }
    }
  }
  return packet;
}

uint64_t kd_compressed_input::get_offset(kd_compressed_input *this)
{
  if (*((unsigned char *)this + 608)) {
    kd_compressed_input::get_offset();
  }
  return *((void *)this + 70) - (void)this + *((void *)this + 66) - 14;
}

uint64_t *kd_precinct::finished_desequencing(uint64_t *this)
{
  if (!*((unsigned char *)this + 17))
  {
    *((unsigned char *)this + 17) = 1;
    if (!*((_DWORD *)this + 7))
    {
      *((unsigned char *)this + 18) = 1;
      this[5] = 0;
    }
    if (!*((_DWORD *)this + 9)) {
      return kd_precinct::release(this);
    }
  }
  return this;
}

uint64_t kd_tile::generate_tile_part(kd_tile *this, int a2, unsigned __int16 *a3)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 77) == *((_DWORD *)this + 52)) {
    return 0;
  }
  if (!*((unsigned char *)this + 288))
  {
    *(void *)&long long v67 = 0;
    *(_OWORD *)uint64_t v65 = 0u;
    long long v66 = 0u;
    kdu_error::kdu_error((kdu_error *)v65, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v65 + 16))(v65, "Assert ");
    (*(void (**)(char *, const char *))(*(void *)v65 + 16))(v65, "is_in_progress");
    (*(void (**)(char *, const char *))(*(void *)v65 + 16))(v65, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v65);
  }
  int v4 = *((_DWORD *)this + 76);
  if (v4 >= 255)
  {
    uint64_t v64 = 0;
    long long v62 = 0u;
    long long v63 = 0u;
    kdu_error::kdu_error((kdu_error *)&v62, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "Too many tile-parts for tile ");
    long long v68 = 0u;
    long long v69 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    *(_OWORD *)uint64_t v65 = 0u;
    if (BYTE8(v62)) {
      sprintf(v65, "%x");
    }
    else {
      sprintf(v65, "%d");
    }
    (*(void (**)(long long *, char *))(v62 + 16))(&v62, v65);
    (*(void (**)(long long *, const char *))(v62 + 16))(&v62, ".  No tile may have more than 255 parts.");
    kdu_error::~kdu_error((kdu_error *)&v62);
  }
  if (*(int *)(*(void *)this + 104) >= 1 && *(_DWORD *)(*(void *)this + 108) <= v4)
  {
    uint64_t v64 = 0;
    long long v62 = 0u;
    long long v63 = 0u;
    kdu_error::kdu_error((kdu_error *)&v62, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "Too many tile-parts for tile ");
    long long v68 = 0u;
    long long v69 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    *(_OWORD *)uint64_t v65 = 0u;
    if (BYTE8(v62)) {
      sprintf(v65, "%x");
    }
    else {
      sprintf(v65, "%d");
    }
    (*(void (**)(long long *, char *))(v62 + 16))(&v62, v65);
    long long v68 = 0u;
    long long v69 = 0u;
    long long v66 = 0u;
    long long v67 = 0u;
    *(_OWORD *)uint64_t v65 = 0u;
    if (BYTE8(v62)) {
      sprintf(v65, "%x");
    }
    else {
      sprintf(v65, "%d");
    }
    (*(void (**)(long long *, char *))(v62 + 16))(&v62, v65);
    (*(void (**)(long long *, const char *))(v62 + 16))(&v62, ".");
    kdu_error::~kdu_error((kdu_error *)&v62);
  }
  uint64_t v5 = *(void *)this;
  if (*(_DWORD *)(*(void *)this + 364) < a2)
  {
    *(void *)&long long v67 = 0;
    *(_OWORD *)uint64_t v65 = 0u;
    long long v66 = 0u;
    kdu_error::kdu_error((kdu_error *)v65, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v65 + 16))(v65, "Assert ");
    (*(void (**)(char *, const char *))(*(void *)v65 + 16))(v65, "max_layers <= codestream->num_sized_layers");
    (*(void (**)(char *, const char *))(*(void *)v65 + 16))(v65, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v65);
  }
  uint64_t v6 = *((unsigned int *)this + 76);
  *((_DWORD *)this + 76) = v6 + 1;
  int marker_segments = kdu_params::generate_marker_segments(*(kdu_params **)(v5 + 24), 0, *((_DWORD *)this + 2), v6);
  bzero(v65, 0x400uLL);
  int v8 = *(_DWORD **)this;
  if (!*(_DWORD *)(*(void *)this + 160))
  {
    int v9 = v8[114];
    if ((v9 & 0x80000000) == 0)
    {
      if (v9 != *((_DWORD *)this + 2))
      {
        uint64_t v64 = 0;
        long long v62 = 0u;
        long long v63 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)&v62, "Kakadu Core Warning:\n");
        (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "Profile violation detected (code-stream is technically illegal).  In a Profile-0 code-stream, all first tile-parts of all tiles must appear first, in exactly the same order as their respective tile numbers.");
        *(_DWORD *)(*(void *)this + 160) = 2;
        kdu_warning::~kdu_warning((kdu_warning *)&v62);
        int v8 = *(_DWORD **)this;
        int v9 = *(_DWORD *)(*(void *)this + 456);
      }
      if (v9 + 1 == v8[55] * v8[56]) {
        int v10 = -1;
      }
      else {
        int v10 = v9 + 1;
      }
      v8[114] = v10;
    }
  }
  uint64_t v60 = 0;
  uint64_t v61 = 0;
  kd_packet_sequencer::save_state(*((unsigned char **)this + 12));
  int v11 = kd_packet_sequencer::next_in_sequence(*((uint64_t **)this + 12), &v61, &v60);
  if (!v11)
  {
LABEL_71:
    --*((_DWORD *)this + 76);
    kd_packet_sequencer::restore_state(*((uint64_t **)this + 12));
    return 0;
  }
  int v12 = 0;
  uint64_t v13 = marker_segments + 14;
  int v55 = -1;
  int v57 = -1;
  int v14 = -1;
  LODWORD(v15) = -1;
  while (1)
  {
    uint64_t v16 = *v11;
    if (!*v11) {
      goto LABEL_35;
    }
    if (v16 == 3) {
      goto LABEL_135;
    }
    if (v16)
    {
LABEL_35:
      uint64_t v16 = kd_precinct_ref::instantiate_precinct(v11, v61, v60);
      if (!v16)
      {
LABEL_135:
        uint64_t v64 = 0;
        long long v62 = 0u;
        long long v63 = 0u;
        kdu_error::kdu_error((kdu_error *)&v62, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "Assert ");
        (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "precinct != NULL");
        (*(void (**)(long long *, const char *))(v62 + 16))(&v62, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v62);
      }
    }
    else
    {
      if (*(unsigned char *)(v16 + 20))
      {
        kd_precinct_size_class::withdraw_from_inactive_list(*(void *)(v16 + 72), (kd_precinct *)v16);
LABEL_38:
        kd_precinct::activate(v16);
        goto LABEL_39;
      }
      if (*(unsigned char *)(v16 + 19)) {
        goto LABEL_38;
      }
    }
LABEL_39:
    if (*(int *)(v16 + 36) > 0) {
      break;
    }
    int v17 = *(_DWORD *)(v16 + 28);
    if (v17 >= *((_DWORD *)this + 48))
    {
      uint64_t v64 = 0;
      long long v62 = 0u;
      long long v63 = 0u;
      kdu_error::kdu_error((kdu_error *)&v62, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "Assert ");
      (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "layer_idx < num_layers");
      (*(void (**)(long long *, const char *))(v62 + 16))(&v62, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v62);
    }
    if (v14 < 0)
    {
      int v14 = *(unsigned __int8 *)(*(void *)v16 + 24);
      int v57 = *(_DWORD *)(*(void *)(*(void *)v16 + 8) + 24);
      int v55 = *(_DWORD *)(v16 + 28);
    }
    if (*((unsigned char *)this + 295) && v14 != *(unsigned __int8 *)(*(void *)v16 + 24)
      || *((unsigned char *)this + 296) && v57 != *(_DWORD *)(*(void *)(*(void *)v16 + 8) + 24)
      || *((unsigned char *)this + 297) && v55 != v17)
    {
      break;
    }
    uint64_t v18 = *(void *)(v16 + 40);
    if (!v18 || (uint64_t v19 = *(void *)(v18 + 8 * v17)) == 0)
    {
      uint64_t v64 = 0;
      long long v62 = 0u;
      long long v63 = 0u;
      kdu_error::kdu_error((kdu_error *)&v62, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "Attempting to generate tile-part data without first determining packet lengths.  This may be a consequence of incomplete simulation of the packet construction process.");
      kdu_error::~kdu_error((kdu_error *)&v62);
    }
    v13 += v19;
    if (*((unsigned char *)this + 294))
    {
      if ((v15 & 0x80000000) != 0)
      {
        LODWORD(v15) = 0;
        *(_DWORD *)uint64_t v65 = 5;
      }
      int v20 = 1;
      if (v19 >= 128)
      {
        do
        {
          unint64_t v21 = (unint64_t)v19 >> 14;
          uint64_t v19 = (unint64_t)v19 >> 7;
          ++v20;
        }
        while (v21);
      }
      int v22 = *(_DWORD *)&v65[4 * v15];
      *(_DWORD *)&v65[4 * v15] = v22 + v20;
      if (v22 + v20 >= 65538)
      {
        *(_DWORD *)&v65[4 * v15] = v22;
        if ((int)v15 >= 255)
        {
          uint64_t v64 = 0;
          long long v62 = 0u;
          long long v63 = 0u;
          kdu_error::kdu_error((kdu_error *)&v62, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "Cannot satisfy the request to generate PLT marker segments!  There are so many packets in one tile-part that it is beyond the capacity of the maximum 256 marker segments to represent length information for all tile-parts!!");
          kdu_error::~kdu_error((kdu_error *)&v62);
        }
        v13 += v22;
        uint64_t v15 = (int)v15 + 1;
        *(_DWORD *)&v65[4 * v15] = v20 + 5;
      }
    }
    ++*(_DWORD *)(v16 + 28);
    ++*((_DWORD *)this + 77);
    int v11 = kd_packet_sequencer::next_in_sequence(*((uint64_t **)this + 12), &v61, &v60);
    ++v12;
    if (!v11) {
      goto LABEL_65;
    }
  }
  if (!v12) {
    goto LABEL_71;
  }
LABEL_65:
  if ((v15 & 0x80000000) == 0) {
    v13 += *(int *)&v65[4 * v15];
  }
  if (v13 >= 0x100000000)
  {
    uint64_t v64 = 0;
    long long v62 = 0u;
    long long v63 = 0u;
    kdu_error::kdu_error((kdu_error *)&v62, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "Length of current tile-part exceeds the maximum value which can be represented by the 32-bit length field in the SOT marker!  You will have to split the code-stream into smaller tile-parts -- see the \"ORGtparts\" parameter attribute.");
    kdu_error::~kdu_error((kdu_error *)&v62);
  }
  int32x2_t v23 = *(kdu_output **)(*(void *)this + 16);
  uint64_t v54 = *((void *)v23 + 65);
  uint64_t v56 = *((void *)v23 + 68);
  kdu_output::put(v23, 255);
  kdu_output::put(v23, 144);
  kdu_output::put(v23, 0);
  kdu_output::put(v23, 10);
  int v24 = *((_DWORD *)this + 2);
  kdu_output::put(v23, SBYTE1(v24));
  kdu_output::put(v23, v24);
  kdu_output::put(v23, v13);
  kdu_output::put(v23, *((unsigned char *)this + 304) - 1);
  if (*(int *)(*(void *)this + 104) < 1)
  {
    if (*((_DWORD *)this + 77) == *((_DWORD *)this + 52)) {
      int v25 = *((_DWORD *)this + 76);
    }
    else {
      LOBYTE(v25) = 0;
    }
  }
  else
  {
    int v25 = *(_DWORD *)(*(void *)this + 108);
  }
  kdu_output::put(v23, v25);
  **(void **)(*(void *)this + 368) += (int)(kdu_params::generate_marker_segments(*(kdu_params **)(*(void *)this + 24), v23, *((_DWORD *)this + 2), (*((_DWORD *)this + 76) - 1))+ 12);
  if ((int)v15 >= 0)
  {
    if (!*((unsigned char *)this + 294))
    {
      uint64_t v64 = 0;
      long long v62 = 0u;
      long long v63 = 0u;
      kdu_error::kdu_error((kdu_error *)&v62, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "Assert ");
      (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "insert_plt_segments");
      (*(void (**)(long long *, const char *))(v62 + 16))(&v62, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v62);
    }
    kd_packet_sequencer::restore_state(*((uint64_t **)this + 12));
    int v27 = 0;
    LODWORD(v28) = -1;
    while (1)
    {
      uint64_t v29 = (kd_precinct **)kd_packet_sequencer::next_in_sequence(*((uint64_t **)this + 12), &v61, &v60);
      if (!v29)
      {
        uint64_t v64 = 0;
        long long v62 = 0u;
        long long v63 = 0u;
        kdu_error::kdu_error((kdu_error *)&v62, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "Assert ");
        (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "p_ref != NULL");
        (*(void (**)(long long *, const char *))(v62 + 16))(&v62, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v62);
      }
      uint64_t v30 = (uint64_t)*v29;
      if (*v29)
      {
        if (v30 == 3)
        {
          uint64_t v30 = 0;
          goto LABEL_90;
        }
        if ((v30 & 1) == 0)
        {
          if (*(unsigned char *)(v30 + 20))
          {
            kd_precinct_size_class::withdraw_from_inactive_list(*(void *)(v30 + 72), *v29);
            kd_precinct::activate(v30);
          }
          else if (*(unsigned char *)(v30 + 19))
          {
            kd_precinct::activate((uint64_t)*v29);
          }
          goto LABEL_90;
        }
      }
      uint64_t v30 = kd_precinct_ref::instantiate_precinct((uint64_t *)v29, v61, v60);
LABEL_90:
      if ((v28 & 0x80000000) != 0 || !*(_DWORD *)&v65[4 * v28])
      {
        kdu_output::put(v23, 255);
        kdu_output::put(v23, 88);
        uint64_t v28 = (int)v28 + 1;
        int v31 = &v65[4 * v28];
        int v32 = *(_DWORD *)v31;
        char v33 = *(_DWORD *)v31 - 2;
        kdu_output::put(v23, (unsigned __int16)(*(_DWORD *)v31 - 2) >> 8);
        kdu_output::put(v23, v33);
        kdu_output::put(v23, v28);
        *(_DWORD *)int v31 = v32 - 5;
      }
      int v34 = 0;
      uint64_t v35 = *(void *)(*(void *)(v30 + 40) + 8 * *(int *)(v30 + 28));
      do
      {
        uint64_t v36 = v35 >> v34;
        v34 += 7;
      }
      while (v36 > 127);
      int v37 = v34 - 7;
      do
      {
        kdu_output::put(v23, (v35 >> v37) & 0x7F | ((v37 != 0) << 7));
        --*(_DWORD *)&v65[4 * (int)v28];
        BOOL v38 = v37 <= 6;
        v37 -= 7;
      }
      while (!v38);
      ++*(_DWORD *)(v30 + 28);
      ++*((_DWORD *)this + 77);
      if (++v27 == v12)
      {
        if (*(_DWORD *)&v65[4 * (int)v28])
        {
          uint64_t v64 = 0;
          long long v62 = 0u;
          long long v63 = 0u;
          kdu_error::kdu_error((kdu_error *)&v62, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "Assert ");
          (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "plt_seg_lengths[current_plt_seg] == 0");
          (*(void (**)(long long *, const char *))(v62 + 16))(&v62, " FAILED");
          kdu_error::~kdu_error((kdu_error *)&v62);
        }
        break;
      }
    }
  }
  kdu_output::put(v23, 255);
  kdu_output::put(v23, 147);
  **(void **)(*(void *)this + 368) += 2;
  kd_packet_sequencer::restore_state(*((uint64_t **)this + 12));
  while (2)
  {
    unsigned int v39 = (kd_precinct **)kd_packet_sequencer::next_in_sequence(*((uint64_t **)this + 12), &v61, &v60);
    if (!v39)
    {
      uint64_t v64 = 0;
      long long v62 = 0u;
      long long v63 = 0u;
      kdu_error::kdu_error((kdu_error *)&v62, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "Assert ");
      (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "p_ref != NULL");
      (*(void (**)(long long *, const char *))(v62 + 16))(&v62, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v62);
    }
    uint64_t v40 = (uint64_t)*v39;
    if (*v39) {
      BOOL v41 = ((unint64_t)*v39 & 1) == 0;
    }
    else {
      BOOL v41 = 0;
    }
    if (v41)
    {
      if (*(unsigned char *)(v40 + 20))
      {
        kd_precinct_size_class::withdraw_from_inactive_list(*(void *)(v40 + 72), *v39);
        kd_precinct::activate(v40);
      }
      else if (*(unsigned char *)(v40 + 19))
      {
        kd_precinct::activate((uint64_t)*v39);
      }
    }
    else
    {
      uint64_t v40 = kd_precinct_ref::instantiate_precinct((uint64_t *)v39, v61, v60);
    }
    uint64_t v42 = *(int *)(v40 + 28);
    if ((int)v42 < a2)
    {
      uint64_t v43 = kd_precinct::write_packet((kd_precinct *)v40, a3[v42], 0);
      uint64_t v44 = *(void *)this;
      uint64_t v45 = *(void *)(*(void *)this + 368);
      goto LABEL_119;
    }
    BOOL v46 = (int)v42 < *(_DWORD *)(*(void *)this + 364);
    uint64_t v43 = kd_precinct::write_packet((kd_precinct *)v40, 0, 1);
    uint64_t v44 = *(void *)this;
    uint64_t v45 = *(void *)(*(void *)this + 368);
    if (v46) {
LABEL_119:
    }
      char v47 = (void *)(v45 + 8 * v42);
    else {
      char v47 = (void *)(v45 + 8 * *(int *)(v44 + 364) - 8);
    }
    *v47 += v43;
    if (--v12) {
      continue;
    }
    break;
  }
  if (v13 != *((void *)v23 + 68) - (v56 + v54) + *((void *)v23 + 65))
  {
    uint64_t v64 = 0;
    long long v62 = 0u;
    long long v63 = 0u;
    kdu_error::kdu_error((kdu_error *)&v62, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "Assert ");
    (*(void (**)(long long *, const char *))(v62 + 16))(&v62, "tpart_bytes == (out->get_bytes_written() - start_bytes)");
    (*(void (**)(long long *, const char *))(v62 + 16))(&v62, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v62);
  }
  int v49 = *(_DWORD *)(v44 + 104);
  uint64_t v48 = v44 + 104;
  ++*(_DWORD *)(v48 + 356);
  if (v49 >= 1) {
    kd_tlm_generator::add_tpart_length(v48, *((_DWORD *)this + 2), v13);
  }
  if (*((_DWORD *)this + 77) != *((_DWORD *)this + 52)) {
    return v13;
  }
  if (*(int *)(*(void *)this + 104) >= 1)
  {
    int v50 = *(_DWORD *)(*(void *)this + 108);
    int v51 = *((_DWORD *)this + 76);
    while (v50 > v51)
    {
      kdu_output::put(v23, 255);
      kdu_output::put(v23, 144);
      kdu_output::put(v23, 0);
      kdu_output::put(v23, 10);
      int v52 = *((_DWORD *)this + 2);
      kdu_output::put(v23, SBYTE1(v52));
      kdu_output::put(v23, v52);
      kdu_output::put(v23, 12);
      kdu_output::put(v23, *((unsigned char *)this + 304));
      kdu_output::put(v23, *(unsigned char *)(*(void *)this + 108));
      kdu_output::put(v23, 255);
      kdu_output::put(v23, 147);
      uint64_t v53 = *(void *)this;
      **(void **)(*(void *)this + 368) += 14;
      kd_tlm_generator::add_tpart_length(v53 + 104, *((_DWORD *)this + 2), 0xEuLL);
      int v51 = *((_DWORD *)this + 76) + 1;
      *((_DWORD *)this + 76) = v51;
      int v50 = *(_DWORD *)(*(void *)this + 108);
    }
  }
  kd_tile::remove_from_in_progress_list((uint64_t *)this);
  if (!*((unsigned char *)this + 291)) {
    return v13;
  }
  uint64_t result = v13;
  if (!*(unsigned char *)(*(void *)this + 408))
  {
    kd_tile::release(this);
    return v13;
  }
  return result;
}

void sub_188645BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

uint64_t kdu_output::put(kdu_output *this, int a2)
{
  return 4;
}

uint64_t kdu_output::put(kdu_output *this, char a2)
{
  int v4 = (unsigned char *)*((void *)this + 65);
  if (v4 == *((unsigned char **)this + 66))
  {
    (*(void (**)(kdu_output *))(*(void *)this + 16))(this);
    int v4 = (unsigned char *)*((void *)this + 65);
    if ((unint64_t)v4 >= *((void *)this + 66)) {
      kdu_output::put();
    }
  }
  *((void *)this + 65) = v4 + 1;
  unsigned char *v4 = a2;
  return 1;
}

uint64_t kd_precinct::write_packet(kd_precinct *this, unsigned int a2, char a3)
{
  char v3 = a3;
  uint64_t v5 = *(void *)(*(void *)(*(void *)this + 8) + 8);
  uint64_t v6 = *(kdu_output **)(**(void **)this + 16);
  if (a3)
  {
    uint64_t v7 = 0;
    uint64_t v39 = 0x700000000;
    uint64_t v40 = 0;
    BOOL v41 = v6;
  }
  else
  {
    if (*(unsigned char *)(*(void *)this + 222))
    {
      unint64_t v9 = 0;
      uint64_t v7 = 0;
      do
      {
        uint64_t v10 = *((void *)this + 6);
        if (!*((_DWORD *)this + 7)) {
          kd_block::reset_output_tree(*(void *)(v10 + 32 * v9 + 24), *(void *)(v10 + 32 * v9 + 16));
        }
        uint64_t v11 = v10 + 32 * v9;
        int v12 = *(_DWORD *)(v11 + 16) * *(_DWORD *)(v11 + 20);
        if (v12 >= 1)
        {
          uint64_t v13 = 0;
          int v14 = (void *)(v11 + 24);
          uint64_t v15 = 40 * v12;
          do
          {
            v7 += (int)kd_block::start_packet((kd_block *)(*v14 + v13), *((_DWORD *)this + 7), a2);
            v13 += 40;
          }
          while (v15 != v13);
        }
        ++v9;
      }
      while (v9 < *(unsigned __int8 *)(*(void *)this + 222));
      uint64_t v16 = *(void *)(*(void *)(*(void *)this + 8) + 8);
      char v3 = a3;
    }
    else
    {
      uint64_t v7 = 0;
      uint64_t v16 = *(void *)(*(void *)(*(void *)this + 8) + 8);
    }
    if (*(unsigned char *)(v16 + 284))
    {
      kdu_output::put(v6, 255);
      kdu_output::put(v6, 145);
      kdu_output::put(v6, 0);
      kdu_output::put(v6, 4);
      int v17 = *(_DWORD *)(v5 + 308);
      kdu_output::put(v6, SBYTE1(v17));
      kdu_output::put(v6, v17);
      v7 += 6;
    }
    uint64_t v39 = 0x800000000;
    uint64_t v40 = 0;
    BOOL v41 = v6;
    kd_header_out::put_bit((unsigned __int8 *)&v39, 1u);
    uint64_t v18 = *(void *)this;
    if (*(unsigned char *)(*(void *)this + 222))
    {
      unint64_t v19 = 0;
      do
      {
        uint64_t v20 = *((void *)this + 6) + 32 * v19;
        int v21 = *(_DWORD *)(v20 + 16) * *(_DWORD *)(v20 + 20);
        if (v21 >= 1)
        {
          uint64_t v22 = 0;
          int32x2_t v23 = (void *)(v20 + 24);
          uint64_t v24 = 40 * v21;
          do
          {
            kd_block::write_packet_header((unsigned __int8 *)(*v23 + v22), (kd_header_out *)&v39, *((_DWORD *)this + 7), 0);
            v22 += 40;
          }
          while (v24 != v22);
          uint64_t v18 = *(void *)this;
        }
        ++v19;
      }
      while (v19 < *(unsigned __int8 *)(v18 + 222));
    }
  }
  uint64_t v25 = v7 + (int)kd_header_out::finish((kd_header_out *)&v39);
  if (*(unsigned char *)(*(void *)(*(void *)(*(void *)this + 8) + 8) + 285))
  {
    kdu_output::put(v6, 255);
    kdu_output::put(v6, 146);
    v25 += 2;
  }
  if ((v3 & 1) == 0)
  {
    uint64_t v26 = *(void *)this;
    if (*(unsigned char *)(*(void *)this + 222))
    {
      unint64_t v27 = 0;
      do
      {
        uint64_t v28 = *((void *)this + 6) + 32 * v27;
        int v29 = *(_DWORD *)(v28 + 16) * *(_DWORD *)(v28 + 20);
        if (v29 >= 1)
        {
          uint64_t v30 = 0;
          int v31 = (void *)(v28 + 24);
          uint64_t v32 = 40 * v29;
          do
          {
            kd_block::write_body_bytes((_DWORD *)(*v31 + v30), v6);
            v30 += 40;
          }
          while (v32 != v30);
          uint64_t v26 = *(void *)this;
        }
        ++v27;
      }
      while (v27 < *(unsigned __int8 *)(v26 + 222));
    }
  }
  uint64_t v33 = *((int *)this + 7);
  if (v25 != *(void *)(*((void *)this + 5) + 8 * v33))
  {
    uint64_t v38 = 0;
    memset(v37, 0, sizeof(v37));
    kdu_error::kdu_error((kdu_error *)v37, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v37[0] + 16))(v37, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v37[0] + 16))(v37, "check_bytes == packet_bytes[next_layer_idx]");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v37[0] + 16))(v37, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v37);
  }
  int v34 = v33 + 1;
  *((_DWORD *)this + 7) = v34;
  ++*(_DWORD *)(v5 + 308);
  if (v34 == *(_DWORD *)(v5 + 192)) {
    kd_global_rescomp::close_ready_precinct(*(kd_global_rescomp **)(*(void *)this + 16), this);
  }
  return v25;
}

void sub_188646148(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188646154()
{
  _Unwind_Resume(v0);
}

kdu_thread_entity *kdu_tile::close(uint64_t **a1, kdu_thread_entity *this)
{
  if (this) {
    kdu_thread_entity::acquire_lock(this, 0, 1);
  }
  int v29 = this;
  char v3 = *a1;
  if (!*((unsigned char *)*a1 + 289))
  {
    uint64_t v35 = 0;
    long long v33 = 0u;
    long long v34 = 0u;
    kdu_error::kdu_error((kdu_error *)&v33, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v33 + 16))(&v33, "Assert ");
    (*(void (**)(long long *, const char *))(v33 + 16))(&v33, "0");
    (*(void (**)(long long *, const char *))(v33 + 16))(&v33, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v33);
  }
  uint64_t v4 = *v3;
  --*(_DWORD *)(*v3 + 260);
  *((unsigned char *)v3 + 289) = 0;
  if (*((unsigned char *)v3 + 291))
  {
    uint64_t v35 = 0;
    long long v33 = 0u;
    long long v34 = 0u;
    kdu_error::kdu_error((kdu_error *)&v33, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v33 + 16))(&v33, "Assert ");
    (*(void (**)(long long *, const char *))(v33 + 16))(&v33, "!state->closed");
    (*(void (**)(long long *, const char *))(v33 + 16))(&v33, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v33);
  }
  if (*(void *)(v4 + 8) && *((int *)v3 + 47) >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v3[34];
      uint64_t v7 = v6 + 224 * v5;
      int v8 = *(_DWORD *)(v7 + 68);
      uint64_t v32 = (int *)(v7 + 68);
      if ((v8 & 0x80000000) == 0)
      {
        uint64_t v9 = 0;
        uint64_t v31 = v5;
        uint64_t v10 = (void *)(v6 + 224 * v5 + 176);
        do
        {
          uint64_t v11 = *v10 + 704 * v9;
          int v14 = *(_DWORD *)(v11 + 200);
          uint64_t v12 = v11 + 200;
          int v13 = v14;
          uint64_t v16 = (int *)(v12 + 8);
          int v15 = *(_DWORD *)(v12 + 8);
          if (v15 >= 1)
          {
            int v17 = 0;
            int v18 = v13 - *(_DWORD *)(v12 - 16);
            uint64_t v19 = *v10 + 704 * v9;
            int v22 = *(_DWORD *)(v19 + 212);
            uint64_t v21 = v19 + 212;
            int v20 = v22;
            uint64_t v23 = 8 * (*(_DWORD *)(v12 + 4) - *(_DWORD *)(v12 - 12));
            do
            {
              if (v20 >= 1)
              {
                for (uint64_t i = 0; i < v20; ++i)
                {
                  uint64_t v25 = *(uint64_t **)(*(void *)(v21 + 20) + 8 * v18 * *(_DWORD *)(v21 - 16) + v23 + 8 * i);
                  if (v25) {
                    BOOL v26 = (*(void *)(*(void *)(v21 + 20) + 8 * v18 * *(_DWORD *)(v21 - 16) + v23 + 8 * i) & 1) == 0;
                  }
                  else {
                    BOOL v26 = 0;
                  }
                  if (v26)
                  {
                    kd_precinct::release(v25);
                    int v20 = *(_DWORD *)v21;
                  }
                }
                int v15 = *v16;
              }
              ++v17;
              ++v18;
            }
            while (v17 < v15);
            int v8 = *v32;
          }
        }
        while (v9++ < v8);
        uint64_t v5 = v31;
        char v3 = *a1;
      }
      ++v5;
    }
    while (v5 < *((int *)v3 + 47));
    uint64_t v4 = *v3;
  }
  if ((!*(unsigned char *)(v4 + 417) || *((unsigned char *)v3 + 287))
    && ((*((unsigned char *)v3 + 291) = 1, *(void *)(v4 + 8)) && *((unsigned char *)v3 + 328)
     || *(void *)(v4 + 16) && *((_DWORD *)v3 + 77) == *((_DWORD *)v3 + 52))
    && !*(unsigned char *)(v4 + 408))
  {
    kd_tile::release((kd_tile *)v3);
    *a1 = 0;
  }
  else
  {
    kd_tile::adjust_unloadability(v3);
  }
  *a1 = 0;
  uint64_t result = v29;
  if (v29) {
    return (kdu_thread_entity *)kdu_thread_entity::release_lock(v29, 0);
  }
  return result;
}

void sub_188646514(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188646520(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Resume(v13);
}

uint64_t kdu_thread_entity::acquire_lock(kdu_thread_entity *this, int a2, int a3)
{
  if (a2 < 0
    || *((_DWORD *)this + 12) <= a2
    || (uint64_t v4 = *((void *)this + 7),
        uint64_t v5 = v4 + 80 * a2,
        uint64_t v7 = *(kdu_thread_entity **)(v5 + 72),
        uint64_t v6 = (void *)(v5 + 72),
        v7 == this))
  {
    kdu_thread_entity::acquire_lock();
  }
  if (a3 && **((unsigned char **)this + 5))
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = *(_DWORD *)(*((void *)this + 5) + 4);
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  uint64_t result = v4 + 80 * a2;
  if (*(unsigned char *)(result + 64)) {
    uint64_t result = pthread_mutex_lock((pthread_mutex_t *)result);
  }
  *uint64_t v6 = this;
  return result;
}

uint64_t kdu_thread_entity::release_lock(kdu_thread_entity *this, int a2)
{
  if (a2 < 0
    || *((_DWORD *)this + 12) <= a2
    || (uint64_t v2 = *((void *)this + 7),
        uint64_t v3 = v2 + 80 * a2,
        uint64_t v5 = *(kdu_thread_entity **)(v3 + 72),
        uint64_t v4 = (void *)(v3 + 72),
        v5 != this))
  {
    kdu_thread_entity::release_lock();
  }
  uint64_t result = v2 + 80 * a2;
  void *v4 = 0;
  if (*(unsigned char *)(result + 64))
  {
    return pthread_mutex_unlock((pthread_mutex_t *)result);
  }
  return result;
}

uint64_t *kd_precinct::release(uint64_t *this)
{
  uint64_t v1 = *(void *)*this;
  if (!*(void *)(v1 + 8)) {
    kd_precinct::release();
  }
  *((_DWORD *)this + 9) = 0;
  *((unsigned char *)this + 19) = 1;
  if (*((unsigned char *)this + 18) || *((unsigned char *)this + 17) && !*(unsigned char *)(v1 + 417))
  {
    this = (uint64_t *)this[1];
    uint64_t v2 = (void *)*this;
    if (*this) {
      BOOL v3 = (*this & 1) == 0;
    }
    else {
      BOOL v3 = 0;
    }
    if (!v3) {
      kd_precinct::release();
    }
    if (!*((unsigned char *)v2 + 20))
    {
      *((unsigned char *)v2 + 19) = 1;
      if (!*((unsigned char *)v2 + 18)
        || *(unsigned char *)(*(void *)*v2 + 418)
        || (int v4 = *((_DWORD *)v2 + 8)) != 0 && v4 != *((_DWORD *)v2 + 7))
      {
        return kd_precinct_ref::close(this);
      }
      else
      {
        uint64_t v5 = (uint64_t *)v2[9];
        return kd_precinct_size_class::move_to_inactive_list(v5, (kd_precinct *)v2);
      }
    }
  }
  return this;
}

uint64_t kdu_tile::get_tile_idx(unsigned __int8 ***this)
{
  LODWORD(v1) = *((_DWORD *)*this + 3);
  uint64_t v2 = **this;
  int v3 = v2[409];
  int v4 = v2[410];
  int v5 = v2[411];
  BOOL v6 = v3 == 0;
  if (v3) {
    unsigned int v7 = *((_DWORD *)*this + 3);
  }
  else {
    unsigned int v7 = *((_DWORD *)*this + 4);
  }
  if (!v6) {
    LODWORD(v1) = *((_DWORD *)*this + 4);
  }
  if (v5) {
    uint64_t v8 = -v7;
  }
  else {
    uint64_t v8 = v7;
  }
  if (v4) {
    uint64_t v1 = -(int)v1;
  }
  else {
    uint64_t v1 = v1;
  }
  return v1 | (v8 << 32);
}

BOOL kdu_tile::get_ycc(kdu_tile *this)
{
  uint64_t v1 = *(void *)this;
  if (*(unsigned char *)(*(void *)this + 286) && *(int *)(v1 + 188) >= 3)
  {
    uint64_t v3 = 184;
    while (*(unsigned char *)(*(void *)(v1 + 272) + v3))
    {
      v3 += 224;
      if (v3 == 856)
      {
        if (*(_DWORD *)(*(void *)v1 + 184) != 1) {
          return 1;
        }
        uint64_t v4 = 88;
        do
        {
          int v5 = *(_DWORD *)(*(void *)(*(void *)v1 + 312) + v4);
          if (v5 < 0)
          {
            uint64_t v8 = 0;
            memset(v7, 0, sizeof(v7));
            kdu_error::kdu_error((kdu_error *)v7, "Kakadu Core Error:\n");
            (*(void (**)(_OWORD *, const char *))(*(void *)&v7[0] + 16))(v7, "Assert ");
            (*(void (**)(_OWORD *, const char *))(*(void *)&v7[0] + 16))(v7, "apparent_idx >= 0");
            (*(void (**)(_OWORD *, const char *))(*(void *)&v7[0] + 16))(v7, " FAILED");
            kdu_error::~kdu_error((kdu_error *)v7);
          }
          BOOL result = *(unsigned char *)(*(void *)(v1 + 272) + 224 * v5 + 185) != 0;
          if (!*(unsigned char *)(*(void *)(v1 + 272) + 224 * v5 + 185)) {
            break;
          }
          BOOL v6 = v4 == 296;
          v4 += 104;
        }
        while (!v6);
        return result;
      }
    }
  }
  return 0;
}

void sub_188646900(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18864690C()
{
  _Unwind_Resume(v0);
}

void kdu_tile::set_components_of_interest(uint64_t **this, signed int a2, unsigned int *a3)
{
  uint64_t v3 = a3;
  uint64_t v4 = *this;
  uint64_t v5 = **this;
  int v6 = *(_DWORD *)(v5 + 184);
  if (v6 || !v4[32])
  {
    uint64_t v7 = v4[34];
    BOOL v8 = v6 == 1;
    uint64_t v9 = 180;
    if (v8) {
      uint64_t v9 = 172;
    }
    uint64_t v10 = *(unsigned int *)(v5 + v9);
    if (a2)
    {
      if (a3)
      {
        if ((int)v10 >= 1)
        {
          uint64_t v11 = (unsigned char *)(v7 + 185);
          uint64_t v12 = v10;
          do
          {
            *uint64_t v11 = 0;
            v11 += 224;
            --v12;
          }
          while (v12);
        }
        if (a2 >= 1)
        {
          uint64_t v13 = a2;
          do
          {
            int v15 = *v3++;
            int v14 = v15;
            if ((v15 & 0x80000000) == 0 && v14 < (int)v10) {
              *(unsigned char *)(v7 + 224 * v14 + 185) = 1;
            }
            --v13;
          }
          while (v13);
        }
      }
      else if ((int)v10 >= 1)
      {
        uint64_t v18 = 0;
        uint64_t v19 = (v10 + 1) & 0x1FFFFFFFELL;
        uint64x2_t v20 = (uint64x2_t)vdupq_n_s64(v10 - 1);
        int64x2_t v21 = (int64x2_t)xmmword_18898C840;
        int v22 = (BOOL *)(v7 + 409);
        int64x2_t v23 = vdupq_n_s64(2uLL);
        do
        {
          int32x2_t v24 = vmovn_s64((int64x2_t)vcgeq_u64(v20, (uint64x2_t)v21));
          if (v24.i8[0]) {
            *(v22 - 224) = v18 < a2;
          }
          if (v24.i8[4]) {
            BOOL *v22 = v18 + 1 < a2;
          }
          v18 += 2;
          int64x2_t v21 = vaddq_s64(v21, v23);
          v22 += 448;
        }
        while (v19 != v18);
      }
    }
    else if ((int)v10 >= 1)
    {
      int v17 = (unsigned char *)(v7 + 185);
      do
      {
        unsigned char *v17 = 1;
        v17 += 224;
        --v10;
      }
      while (v10);
    }
  }
  else
  {
    kd_mct_stage::apply_output_restrictions((int *)v4[33], *(void *)(v5 + 320), a2, a3);
    uint64_t v4 = *this;
  }
  uint64_t v25 = *((unsigned int *)v4 + 47);
  if ((int)v25 >= 1)
  {
    BOOL v26 = (_DWORD *)(v4[34] + 156);
    do
    {
      _DWORD *v26 = -1082130432;
      v26 += 56;
      --v25;
    }
    while (v25);
  }
}

uint64_t kdu_tile::get_mct_block_info(uint64_t **this, int a2, int a3, int *a4, int *a5, int *a6, int *a7, unint64_t a8, int *a9, unint64_t a10, int *a11, int *a12)
{
  int v16 = a3;
  uint64_t v18 = (float *)a10;
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = **this;
  int v20 = *(_DWORD *)(v19 + 184);
  if (v20 == 1 || (uint64_t v21 = (*this)[32]) == 0)
  {
    if (a3 | a2) {
      return 0;
    }
    uint64_t v27 = 172;
    if (v20 != 1) {
      uint64_t v27 = 180;
    }
    int v28 = *(_DWORD *)(v19 + v27);
    *a5 = v28;
    *a7 = v28;
    *a6 = v28;
    *a4 = v28;
    BOOL ycc = kdu_tile::get_ycc((kdu_tile *)this);
    BOOL v30 = v20 == 1 || !ycc;
    if (v30)
    {
      uint64_t v108 = -1;
      unsigned int v109 = -1;
      unint64_t v43 = (unint64_t)a11;
      if (!ycc)
      {
        int v41 = 0;
LABEL_55:
        unint64_t v37 = a10;
        goto LABEL_56;
      }
    }
    else
    {
      uint64_t v42 = 16;
      unint64_t v43 = (unint64_t)a11;
      while (1)
      {
        unsigned int v44 = *(_DWORD *)(*(void *)(v19 + 320) + v42);
        if ((v44 & 0x80000000) == 0)
        {
          if (*(unsigned char *)((*this)[34] + 224 * v44 + 185)) {
            break;
          }
        }
        v42 += 48;
        if (v42 == 160)
        {
          int v41 = 0;
          uint64_t v108 = -1;
          unsigned int v109 = -1;
          goto LABEL_55;
        }
      }
      uint64_t v108 = -1;
      unsigned int v109 = -1;
    }
    uint64_t v31 = 0;
    uint64_t v32 = *this;
    uint64_t v33 = **this;
    unsigned int v34 = *a4;
    uint64_t v35 = (int *)(*(void *)(v33 + 312) + 88);
    uint64_t v36 = 16;
    unint64_t v37 = a10;
    do
    {
      int v38 = *v35;
      v35 += 26;
      *((_DWORD *)&v108 + v31) = v38;
      if (v38 < 0 || (uint64_t v39 = *(int *)(v33 + 176), v31 > v39))
      {
LABEL_196:
        exception = __cxa_allocate_exception(4uLL);
        _DWORD *exception = -50;
        __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
      }
      if (v20 != 1)
      {
        if (v31 >= v39) {
          goto LABEL_196;
        }
        unsigned int v40 = *(_DWORD *)(*(void *)(v19 + 320) + v36);
        if ((v40 & 0x80000000) != 0) {
          goto LABEL_196;
        }
        if (!*(unsigned char *)(v32[34] + 224 * v40 + 185)) {
          *a4 = ++v34;
        }
      }
      ++v31;
      v36 += 48;
    }
    while (v31 != 3);
    int v41 = 1;
LABEL_56:
    uint64_t v49 = *a4;
    int v50 = *a5;
    if (*a5 >= 1)
    {
      uint64_t v51 = 0;
      int v52 = (unsigned __int8 *)((*this)[34] + 185);
      do
      {
        int v53 = *v52;
        v52 += 224;
        if (!v53)
        {
          --*a4;
          --*a6;
          --*a7;
          int v50 = *a5;
        }
        ++v51;
      }
      while (v51 < v50);
    }
    if (a9)
    {
      if (v50 < 1)
      {
        int v55 = 0;
      }
      else
      {
        uint64_t v54 = 0;
        int v55 = 0;
        uint64_t v56 = (unsigned __int8 *)((*this)[34] + 185);
        do
        {
          int v57 = *v56;
          v56 += 224;
          if (v57)
          {
            a9[v55++] = v54;
            int v50 = *a5;
          }
          ++v54;
        }
        while (v54 < v50);
      }
      if (v55 != *a7)
      {
        uint64_t v107 = 0;
        long long v105 = 0u;
        long long v106 = 0u;
        kdu_error::kdu_error((kdu_error *)&v105, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "Assert ");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "k == num_block_outputs");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v105);
      }
    }
    if (v37 | v43)
    {
      int v58 = *a5;
      if (*a5 >= 1)
      {
        uint64_t v59 = 0;
        int v60 = 0;
        uint64_t v61 = (unsigned __int8 *)((*this)[34] + 185);
        uint64_t v62 = 20;
        uint64_t v63 = 96;
        while (1)
        {
          int v64 = *v61;
          v61 += 224;
          if (v64) {
            break;
          }
LABEL_84:
          ++v59;
          v62 += 48;
          v63 += 104;
          if (v59 >= v58) {
            goto LABEL_89;
          }
        }
        if (v20 == 1) {
          uint64_t v65 = (uint64_t *)(*(void *)(v19 + 312) + v63);
        }
        else {
          uint64_t v65 = (uint64_t *)(*(void *)(v19 + 320) + 48 * *(int *)(*(void *)(v19 + 320) + v62) + 8);
        }
        uint64_t v66 = *v65;
        if (*(unsigned char *)(v66 + 20))
        {
          int v67 = 0;
          if (!v43)
          {
LABEL_81:
            if (v37) {
              *(float *)(v37 + 4 * v60) = (float)v67;
            }
            ++v60;
            int v58 = *a5;
            goto LABEL_84;
          }
        }
        else
        {
          int v67 = 1 << (*(_DWORD *)(v66 + 16) - 1);
          if (!v43) {
            goto LABEL_81;
          }
        }
        *(_DWORD *)(v43 + 4 * v60) = v67;
        goto LABEL_81;
      }
      int v60 = 0;
LABEL_89:
      if (v60 != *a7)
      {
        uint64_t v107 = 0;
        long long v105 = 0u;
        long long v106 = 0u;
        kdu_error::kdu_error((kdu_error *)&v105, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "Assert ");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "k == num_block_outputs");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v105);
      }
    }
    if (!(a8 | (unint64_t)a12)) {
      return 1;
    }
    if (v20 != 1)
    {
      char v68 = v41 ^ 1;
      if (!a12) {
        char v68 = 1;
      }
      if ((v68 & 1) == 0)
      {
        *(void *)a12 = 0x100000000;
        a12[2] = 2;
      }
      if (v41) {
        int v69 = 3;
      }
      else {
        int v69 = 0;
      }
      int v70 = *a5;
      if (*a5 < 1)
      {
        int v72 = 0;
      }
      else
      {
        uint64_t v71 = 0;
        int v72 = 0;
        int v73 = (unsigned __int8 *)((*this)[34] + 185);
        uint64_t v74 = 20;
        do
        {
          int v75 = *v73;
          v73 += 224;
          if (v75)
          {
            int v76 = *(_DWORD *)(*(void *)(v19 + 320) + v74);
            if ((v41 & (v76 < 3)) != 0) {
              int v77 = *(_DWORD *)(*(void *)(v19 + 320) + v74);
            }
            else {
              int v77 = v69;
            }
            if (a12) {
              a12[v77] = v76;
            }
            if (a8) {
              *(_DWORD *)(a8 + 4 * v72) = v77;
            }
            v69 += !(v41 & (v76 < 3));
            ++v72;
            int v70 = *a5;
          }
          ++v71;
          v74 += 48;
        }
        while (v71 < v70);
      }
      if (v69 != *a4)
      {
        uint64_t v107 = 0;
        long long v105 = 0u;
        long long v106 = 0u;
        kdu_error::kdu_error((kdu_error *)&v105, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "Assert ");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "non_ycc_idx == num_stage_inputs");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v105);
      }
      if (v72 != *a6)
      {
        uint64_t v107 = 0;
        long long v105 = 0u;
        long long v106 = 0u;
        kdu_error::kdu_error((kdu_error *)&v105, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "Assert ");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "k == num_block_inputs");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v105);
      }
      return 1;
    }
    if ((int)v49 < 1)
    {
      int v79 = 0;
LABEL_154:
      if (v79 != *a6)
      {
        uint64_t v107 = 0;
        long long v105 = 0u;
        long long v106 = 0u;
        kdu_error::kdu_error((kdu_error *)&v105, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "Assert ");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "k == num_block_inputs");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v105);
      }
      return 1;
    }
    uint64_t v78 = 0;
    int v79 = 0;
    if (v41) {
      int v80 = 3;
    }
    else {
      int v80 = 0;
    }
    uint64_t v81 = v108;
    uint64_t v82 = HIDWORD(v108);
    uint64_t v83 = v109;
    uint64_t v84 = 185;
    while (1)
    {
      if (v81 == v78)
      {
        int v85 = 0;
        if (a12) {
          goto LABEL_120;
        }
        goto LABEL_121;
      }
      if (v82 == v78)
      {
        int v85 = 1;
        if (a12) {
          goto LABEL_120;
        }
        goto LABEL_121;
      }
      if (v83 == v78) {
        break;
      }
      if (*(unsigned char *)((*this)[34] + v84))
      {
        int v85 = v80++;
        if (!a12) {
          goto LABEL_121;
        }
LABEL_120:
        a12[v85] = v78;
LABEL_121:
        if (a8) {
          *(_DWORD *)(a8 + 4 * v79) = v85;
        }
        ++v79;
      }
      ++v78;
      v84 += 224;
      if (v49 == v78) {
        goto LABEL_154;
      }
    }
    int v85 = 2;
    if (a12) {
      goto LABEL_120;
    }
    goto LABEL_121;
  }
  if (a2 >= 1)
  {
    do
    {
      unsigned int v22 = a2;
      uint64_t v21 = *(void *)(v21 + 56);
      --a2;
    }
    while (v22 >= 2 && v21);
    if (!v21) {
      return 0;
    }
  }
  *a4 = *(_DWORD *)(v21 + 4);
  *a5 = *(_DWORD *)(v21 + 20);
  if (a12)
  {
    if (a2)
    {
      uint64_t v107 = 0;
      long long v105 = 0u;
      long long v106 = 0u;
      kdu_error::kdu_error((kdu_error *)&v105, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "Assert ");
      (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "stage_idx == 0");
      (*(void (**)(long long *, const char *))(v105 + 16))(&v105, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v105);
    }
    int v23 = *(_DWORD *)v21;
    if (*(int *)v21 < 1)
    {
      int v25 = 0;
    }
    else
    {
      uint64_t v24 = 0;
      int v25 = 0;
      do
      {
        if (v25 >= *(_DWORD *)(v21 + 4)) {
          break;
        }
        int v26 = *(_DWORD *)(*(void *)(v21 + 8) + 4 * v24);
        if ((v26 & 0x80000000) == 0)
        {
          if (v26 != v25)
          {
            uint64_t v107 = 0;
            long long v105 = 0u;
            long long v106 = 0u;
            kdu_error::kdu_error((kdu_error *)&v105, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "Assert ");
            (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "stage->input_required_indices[n] == m");
            (*(void (**)(long long *, const char *))(v105 + 16))(&v105, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v105);
          }
          a12[v25++] = v24;
          int v23 = *(_DWORD *)v21;
        }
        ++v24;
      }
      while (v24 < v23);
    }
    if (v25 != *(_DWORD *)(v21 + 4))
    {
      uint64_t v107 = 0;
      long long v105 = 0u;
      long long v106 = 0u;
      kdu_error::kdu_error((kdu_error *)&v105, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "Assert ");
      (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "m == stage->num_required_inputs");
      (*(void (**)(long long *, const char *))(v105 + 16))(&v105, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v105);
    }
  }
  int v45 = *(_DWORD *)(v21 + 32);
  if (v45 <= a3) {
    return 0;
  }
  uint64_t v46 = *(void *)(v21 + 40);
  if (v45 >= 1)
  {
    int v47 = 0;
    unint64_t v48 = a8;
    do
    {
      if (*(int *)(v46 + 36) >= 1)
      {
        if (!v16) {
          goto LABEL_136;
        }
        --v16;
      }
      ++v47;
      v46 += 152;
    }
    while (v45 != v47);
    return 0;
  }
  int v47 = 0;
  unint64_t v48 = a8;
LABEL_136:
  unint64_t v86 = (unint64_t)a11;
  if (v47 == v45) {
    return 0;
  }
  *a6 = *(_DWORD *)(v46 + 12);
  *a7 = *(_DWORD *)(v46 + 36);
  if (v48)
  {
    int v88 = *(_DWORD *)(v46 + 8);
    if (v88 < 1)
    {
      int v90 = 0;
    }
    else
    {
      uint64_t v89 = 0;
      int v90 = 0;
      do
      {
        if (v90 >= *(_DWORD *)(v46 + 12)) {
          break;
        }
        if (*(unsigned char *)(*(void *)(v46 + 24) + v89))
        {
          int v91 = *(_DWORD *)(*(void *)(v21 + 8) + 4 * *(int *)(*(void *)(v46 + 16) + 4 * v89));
          if (v91 < 0)
          {
            uint64_t v107 = 0;
            long long v105 = 0u;
            long long v106 = 0u;
            kdu_error::kdu_error((kdu_error *)&v105, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "Assert ");
            (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "stage->input_required_indices[idx] >= 0");
            (*(void (**)(long long *, const char *))(v105 + 16))(&v105, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v105);
          }
          *(_DWORD *)(v48 + 4 * v90++) = v91;
          int v88 = *(_DWORD *)(v46 + 8);
        }
        ++v89;
      }
      while (v89 < v88);
    }
    BOOL v30 = v90 == *(_DWORD *)(v46 + 12);
    unint64_t v86 = (unint64_t)a11;
    if (!v30)
    {
      uint64_t v107 = 0;
      long long v105 = 0u;
      long long v106 = 0u;
      kdu_error::kdu_error((kdu_error *)&v105, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "Assert ");
      (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "m == block->num_required_inputs");
      (*(void (**)(long long *, const char *))(v105 + 16))(&v105, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v105);
    }
  }
  if (a9)
  {
    int v92 = *(_DWORD *)(v46 + 32);
    if (v92 < 1)
    {
      int v94 = 0;
    }
    else
    {
      uint64_t v93 = 0;
      int v94 = 0;
      do
      {
        if (v94 >= *(_DWORD *)(v46 + 36)) {
          break;
        }
        uint64_t v95 = *(void *)(v21 + 24);
        int v96 = *(_DWORD *)(*(void *)(v46 + 40) + 4 * v93);
        if (*(unsigned char *)(v95 + 48 * v96 + 40))
        {
          a9[v94++] = *(_DWORD *)(v95 + 48 * v96 + 16);
          int v92 = *(_DWORD *)(v46 + 32);
        }
        ++v93;
      }
      while (v93 < v92);
    }
    if (v94 != *(_DWORD *)(v46 + 36))
    {
      uint64_t v107 = 0;
      long long v105 = 0u;
      long long v106 = 0u;
      kdu_error::kdu_error((kdu_error *)&v105, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "Assert ");
      (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "m == block->num_apparent_outputs");
      (*(void (**)(long long *, const char *))(v105 + 16))(&v105, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v105);
    }
  }
  if (*(void *)(v46 + 64) && !*(void *)(v46 + 80))
  {
    if (a10 | v86)
    {
      int v99 = *(_DWORD *)(v46 + 32);
      if (v99 < 1)
      {
        int v101 = 0;
      }
      else
      {
        uint64_t v100 = 0;
        int v101 = 0;
        do
        {
          if (v101 >= *(_DWORD *)(v46 + 36)) {
            break;
          }
          if (*(unsigned char *)(*(void *)(v21 + 24) + 48 * *(int *)(*(void *)(v46 + 40) + 4 * v100) + 40))
          {
            BOOL v102 = v18 != 0;
            LODWORD(v105) = 0;
            kdu_params::get(*(kdu_params **)(v46 + 64), "Mvector_coeffs", v100, 0, (float *)&v105, 1, 1, 1);
            uint64_t v18 = (float *)a10;
            if (v102) {
              *(_DWORD *)(a10 + 4 * v101) = v105;
            }
            if (a11) {
              a11[v101] = vcvtmd_s64_f64(*(float *)&v105 + 0.5);
            }
            ++v101;
            int v99 = *(_DWORD *)(v46 + 32);
          }
          ++v100;
        }
        while (v100 < v99);
      }
      if (v101 != *(_DWORD *)(v46 + 36))
      {
        uint64_t v107 = 0;
        long long v105 = 0u;
        long long v106 = 0u;
        kdu_error::kdu_error((kdu_error *)&v105, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "Assert ");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, "m == block->num_apparent_outputs");
        (*(void (**)(long long *, const char *))(v105 + 16))(&v105, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v105);
      }
    }
    return 1;
  }
  if (a10)
  {
    uint64_t v97 = *(unsigned int *)(v46 + 36);
    if ((int)v97 >= 1) {
      bzero((void *)a10, 4 * v97);
    }
  }
  if (!v86 || *(int *)(v46 + 36) < 1) {
    return 1;
  }
  uint64_t v98 = 0;
  uint64_t result = 1;
  do
    *(_DWORD *)(v86 + 4 * v98++) = 0;
  while (v98 < *(int *)(v46 + 36));
  return result;
}

void sub_188647C34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188647C40(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Resume(v13);
}

uint64_t kdu_tile::get_mct_matrix_info(kdu_tile *this, int a2, int a3, float *a4)
{
  if (*(_DWORD *)(**(void **)this + 184)) {
    return 0;
  }
  uint64_t v6 = *(void *)(*(void *)this + 256);
  if (a2 >= 1 && v6)
  {
    do
    {
      uint64_t v6 = *(void *)(v6 + 56);
      if (a2 < 2) {
        break;
      }
      --a2;
    }
    while (v6);
  }
  if (!v6) {
    return 0;
  }
  int v7 = *(_DWORD *)(v6 + 32);
  if (v7 <= a3) {
    return 0;
  }
  uint64_t v8 = *(void *)(v6 + 40);
  if (v7 >= 1)
  {
    for (int i = 0; i != v7; ++i)
    {
      if (*(int *)(v8 + 36) >= 1)
      {
        if (!a3) {
          goto LABEL_18;
        }
        --a3;
      }
      v8 += 152;
    }
    return 0;
  }
  int i = 0;
LABEL_18:
  if (i == v7 || !*(void *)(v8 + 72) || *(unsigned char *)(v8 + 57) || *(unsigned char *)(v8 + 56)) {
    return 0;
  }
  if (a4)
  {
    int v10 = *(_DWORD *)(v8 + 32);
    if (v10 < 1)
    {
      int v12 = 0;
    }
    else
    {
      uint64_t v11 = 0;
      int v12 = 0;
      int v13 = 0;
      do
      {
        int v14 = *(_DWORD *)(v8 + 8);
        if (*(unsigned char *)(*(void *)(v6 + 24) + 48 * *(int *)(*(void *)(v8 + 40) + 4 * v11) + 40))
        {
          if (v14 >= 1)
          {
            for (uint64_t j = 0; j < v14; ++j)
            {
              if (*(unsigned char *)(*(void *)(v8 + 24) + j))
              {
                LODWORD(v16[0]) = 0;
                kdu_params::get(*(kdu_params **)(v8 + 72), "Mmatrix_coeffs", v13 + j, 0, (float *)v16, 1, 1, 1);
                a4[v12++] = *(float *)v16;
                int v14 = *(_DWORD *)(v8 + 8);
              }
            }
            int v10 = *(_DWORD *)(v8 + 32);
            v13 += j;
          }
        }
        else
        {
          v13 += v14;
        }
        ++v11;
      }
      while (v11 < v10);
    }
    if (v12 != *(_DWORD *)(v8 + 12) * *(_DWORD *)(v8 + 36))
    {
      uint64_t v17 = 0;
      memset(v16, 0, sizeof(v16));
      kdu_error::kdu_error((kdu_error *)v16, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v16[0] + 16))(v16, "Assert ");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v16[0] + 16))(v16, "c_out==(block->num_apparent_outputs*block->num_required_inputs)");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v16[0] + 16))(v16, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v16);
    }
  }
  return 1;
}

void sub_188647F9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188647FA8()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_tile::get_mct_rxform_info(kdu_tile *this, int a2, int a3, int *a4, int *a5)
{
  if (*(_DWORD *)(**(void **)this + 184)) {
    return 0;
  }
  uint64_t v8 = *(void *)(*(void *)this + 256);
  if (a2 >= 1 && v8)
  {
    do
    {
      uint64_t v8 = *(void *)(v8 + 56);
      if (a2 < 2) {
        break;
      }
      --a2;
    }
    while (v8);
  }
  if (!v8) {
    return 0;
  }
  int v9 = *(_DWORD *)(v8 + 32);
  if (v9 <= a3) {
    return 0;
  }
  uint64_t v10 = *(void *)(v8 + 40);
  if (v9 >= 1)
  {
    for (int i = 0; i != v9; ++i)
    {
      if (*(int *)(v10 + 36) >= 1)
      {
        if (!a3) {
          goto LABEL_17;
        }
        --a3;
      }
      v10 += 152;
    }
    return 0;
  }
  int i = 0;
LABEL_17:
  if (i == v9 || !*(void *)(v10 + 72) || *(unsigned char *)(v10 + 57) || !*(unsigned char *)(v10 + 56)) {
    return 0;
  }
  if (*(_DWORD *)(v10 + 12) != *(_DWORD *)(v10 + 8))
  {
    uint64_t v19 = 0;
    long long v17 = 0u;
    long long v18 = 0u;
    kdu_error::kdu_error((kdu_error *)&v17, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v17 + 16))(&v17, "Assert ");
    (*(void (**)(long long *, const char *))(v17 + 16))(&v17, "block->num_required_inputs == block->num_inputs");
    (*(void (**)(long long *, const char *))(v17 + 16))(&v17, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v17);
  }
  if (a4)
  {
    uint64_t v12 = (*(_DWORD *)(v10 + 12) + *(_DWORD *)(v10 + 12) * *(_DWORD *)(v10 + 12));
    if ((int)v12 >= 1)
    {
      for (uint64_t j = 0; j != v12; ++j)
      {
        LODWORD(v17) = 0;
        kdu_params::get(*(kdu_params **)(v10 + 72), "Mmatrix_coeffs", j, 0, (float *)&v17, 1, 1, 1);
        a4[j] = vcvtmd_s64_f64(*(float *)&v17 + 0.5);
      }
    }
  }
  if (a5)
  {
    int v14 = *(_DWORD *)(v10 + 32);
    if (v14 < 1)
    {
      int v16 = 0;
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 0;
      do
      {
        if (v16 >= *(_DWORD *)(v10 + 36)) {
          break;
        }
        if (*(unsigned char *)(*(void *)(v8 + 24) + 48 * *(int *)(*(void *)(v10 + 40) + 4 * v15) + 40))
        {
          a5[v16++] = v15;
          int v14 = *(_DWORD *)(v10 + 32);
        }
        ++v15;
      }
      while (v15 < v14);
    }
    if (v16 != *(_DWORD *)(v10 + 36))
    {
      uint64_t v19 = 0;
      long long v17 = 0u;
      long long v18 = 0u;
      kdu_error::kdu_error((kdu_error *)&v17, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v17 + 16))(&v17, "Assert ");
      (*(void (**)(long long *, const char *))(v17 + 16))(&v17, "m == block->num_apparent_outputs");
      (*(void (**)(long long *, const char *))(v17 + 16))(&v17, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v17);
    }
  }
  return 1;
}

void sub_188648308(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188648314()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_tile::get_mct_dependency_info(kdu_tile *this, int a2, int a3, BOOL *a4, unint64_t a5, unint64_t a6, unint64_t a7, unint64_t a8, int *a9)
{
  if (*(_DWORD *)(**(void **)this + 184)) {
    return 0;
  }
  uint64_t v14 = *(void *)(*(void *)this + 256);
  if (a2 >= 1 && v14)
  {
    do
    {
      uint64_t v14 = *(void *)(v14 + 56);
      if (a2 < 2) {
        break;
      }
      --a2;
    }
    while (v14);
  }
  if (!v14) {
    return 0;
  }
  int v15 = *(_DWORD *)(v14 + 32);
  if (v15 <= a3) {
    return 0;
  }
  uint64_t v16 = *(void *)(v14 + 40);
  if (v15 >= 1)
  {
    for (int i = 0; i != v15; ++i)
    {
      if (*(int *)(v16 + 36) >= 1)
      {
        if (!a3) {
          goto LABEL_17;
        }
        --a3;
      }
      v16 += 152;
    }
    return 0;
  }
  int i = 0;
LABEL_17:
  if (i == v15 || !*(void *)(v16 + 80) || *(unsigned char *)(v16 + 57)) {
    return 0;
  }
  *a4 = *(unsigned char *)(v16 + 56);
  if (*(unsigned char *)(v16 + 56))
  {
    if (a5 | a6)
    {
      uint64_t v31 = 0;
      long long v29 = 0u;
      long long v30 = 0u;
      kdu_error::kdu_error((kdu_error *)&v29, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v29 + 16))(&v29, "Assert ");
      (*(void (**)(long long *, const char *))(v29 + 16))(&v29, "(irrev_coefficients == NULL) && (irrev_offsets == NULL)");
      (*(void (**)(long long *, const char *))(v29 + 16))(&v29, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v29);
    }
    if (a7)
    {
      int v18 = *(_DWORD *)(v16 + 12) + *(_DWORD *)(v16 + 12) * *(_DWORD *)(v16 + 12);
      if (v18 >= 4)
      {
        uint64_t v19 = 0;
        uint64_t v20 = (v18 >> 1) - 1;
        do
        {
          LODWORD(v29) = 0;
          kdu_params::get(*(kdu_params **)(v16 + 80), "Mtriang_coeffs", v19, 0, (float *)&v29, 1, 1, 1);
          *(_DWORD *)(a7 + 4 * v19++) = vcvtmd_s64_f64(*(float *)&v29 + 0.5);
        }
        while (v20 != v19);
      }
    }
    if (a8 && *(int *)(v16 + 12) >= 1)
    {
      uint64_t v21 = 0;
      do
      {
        LODWORD(v29) = 0;
        kdu_params::get(*(kdu_params **)(v16 + 64), "Mvector_coeffs", v21, 0, (float *)&v29, 1, 1, 1);
        *(_DWORD *)(a8 + 4 * v21++) = vcvtmd_s64_f64(*(float *)&v29 + 0.5);
      }
      while (v21 < *(int *)(v16 + 12));
    }
  }
  else
  {
    if (a7 | a8)
    {
      uint64_t v31 = 0;
      long long v29 = 0u;
      long long v30 = 0u;
      kdu_error::kdu_error((kdu_error *)&v29, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v29 + 16))(&v29, "Assert ");
      (*(void (**)(long long *, const char *))(v29 + 16))(&v29, "(rev_coefficients == NULL) && (rev_offsets == NULL)");
      (*(void (**)(long long *, const char *))(v29 + 16))(&v29, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v29);
    }
    if (a5)
    {
      int v22 = (*(_DWORD *)(v16 + 12) - 1) * *(_DWORD *)(v16 + 12);
      if (v22 >= 2)
      {
        uint64_t v23 = 0;
        uint64_t v24 = v22 >> 1;
        do
        {
          LODWORD(v29) = 0;
          kdu_params::get(*(kdu_params **)(v16 + 80), "Mtriang_coeffs", v23, 0, (float *)&v29, 1, 1, 1);
          *(_DWORD *)(a5 + 4 * v23++) = v29;
        }
        while (v24 != v23);
      }
    }
    if (a6 && *(int *)(v16 + 12) >= 1)
    {
      uint64_t v25 = 0;
      do
      {
        LODWORD(v29) = 0;
        kdu_params::get(*(kdu_params **)(v16 + 64), "Mvector_coeffs", v25, 0, (float *)&v29, 1, 1, 1);
        *(_DWORD *)(a6 + 4 * v25++) = v29;
      }
      while (v25 < *(int *)(v16 + 12));
    }
  }
  if (a9)
  {
    int v26 = *(_DWORD *)(v16 + 32);
    if (v26 < 1)
    {
      int v28 = 0;
    }
    else
    {
      uint64_t v27 = 0;
      int v28 = 0;
      do
      {
        if (v28 >= *(_DWORD *)(v16 + 36)) {
          break;
        }
        if (*(unsigned char *)(*(void *)(v14 + 24) + 48 * *(int *)(*(void *)(v16 + 40) + 4 * v27) + 40))
        {
          a9[v28++] = v27;
          int v26 = *(_DWORD *)(v16 + 32);
        }
        ++v27;
      }
      while (v27 < v26);
    }
    if (v28 != *(_DWORD *)(v16 + 36))
    {
      uint64_t v31 = 0;
      long long v29 = 0u;
      long long v30 = 0u;
      kdu_error::kdu_error((kdu_error *)&v29, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v29 + 16))(&v29, "Assert ");
      (*(void (**)(long long *, const char *))(v29 + 16))(&v29, "m == block->num_apparent_outputs");
      (*(void (**)(long long *, const char *))(v29 + 16))(&v29, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v29);
    }
  }
  return 1;
}

void sub_188648890(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18864889C()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_tile::get_mct_dwt_info(kdu_tile *this, int a2, int a3, BOOL *a4, int *a5, int *a6, int *a7, int *a8, BOOL *a9, BOOL *a10, const float **a11, int *a12, int *a13)
{
  if (*(_DWORD *)(**(void **)this + 184)) {
    return 0;
  }
  uint64_t v14 = *(void *)(*(void *)this + 256);
  if (a2 >= 1 && v14)
  {
    do
    {
      uint64_t v14 = *(void *)(v14 + 56);
      if (a2 < 2) {
        break;
      }
      --a2;
    }
    while (v14);
  }
  if (!v14) {
    return 0;
  }
  int v15 = *(_DWORD *)(v14 + 32);
  if (v15 <= a3) {
    return 0;
  }
  uint64_t v16 = *(void *)(v14 + 40);
  if (v15 >= 1)
  {
    for (int i = 0; i != v15; ++i)
    {
      if (*(int *)(v16 + 36) >= 1)
      {
        if (!a3) {
          goto LABEL_18;
        }
        --a3;
      }
      v16 += 152;
    }
    return 0;
  }
  int i = 0;
LABEL_18:
  if (i == v15) {
    return 0;
  }
  if (!*(void *)(v16 + 104)) {
    return 0;
  }
  int v18 = *(_DWORD *)(v16 + 92);
  if (v18 < 1 || *(unsigned char *)(v16 + 57)) {
    return 0;
  }
  *a4 = *(unsigned char *)(v16 + 56);
  *a5 = v18;
  int v19 = *(_DWORD *)(v16 + 96);
  *a6 = v19;
  *a7 = *(_DWORD *)(v16 + 8) + v19;
  *a8 = *(_DWORD *)(v16 + 88);
  *a9 = *(unsigned char *)(v16 + 100);
  *a10 = *(unsigned char *)(v16 + 101);
  *a11 = *(const float **)(v16 + 112);
  if (a12)
  {
    int v20 = *(_DWORD *)(v16 + 8);
    if (v20 < 1)
    {
      int v22 = 0;
    }
    else
    {
      uint64_t v21 = 0;
      int v22 = 0;
      do
      {
        if (v22 >= *(_DWORD *)(v16 + 12)) {
          break;
        }
        if (*(unsigned char *)(*(void *)(v16 + 24) + v21))
        {
          a12[v22++] = v21;
          int v20 = *(_DWORD *)(v16 + 8);
        }
        ++v21;
      }
      while (v21 < v20);
    }
    if (v22 != *(_DWORD *)(v16 + 12))
    {
      uint64_t v28 = 0;
      long long v26 = 0u;
      long long v27 = 0u;
      kdu_error::kdu_error((kdu_error *)&v26, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v26 + 16))(&v26, "Assert ");
      (*(void (**)(long long *, const char *))(v26 + 16))(&v26, "m == block->num_required_inputs");
      (*(void (**)(long long *, const char *))(v26 + 16))(&v26, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v26);
    }
  }
  if (a13)
  {
    int v23 = *(_DWORD *)(v16 + 32);
    if (v23 < 1)
    {
      int v25 = 0;
    }
    else
    {
      uint64_t v24 = 0;
      int v25 = 0;
      do
      {
        if (v25 >= *(_DWORD *)(v16 + 36)) {
          break;
        }
        if (*(unsigned char *)(*(void *)(v14 + 24) + 48 * *(int *)(*(void *)(v16 + 40) + 4 * v24) + 40))
        {
          a13[v25++] = v24;
          int v23 = *(_DWORD *)(v16 + 32);
        }
        ++v24;
      }
      while (v24 < v23);
    }
    if (v25 != *(_DWORD *)(v16 + 36))
    {
      uint64_t v28 = 0;
      long long v26 = 0u;
      long long v27 = 0u;
      kdu_error::kdu_error((kdu_error *)&v26, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v26 + 16))(&v26, "Assert ");
      (*(void (**)(long long *, const char *))(v26 + 16))(&v26, "m == block->num_apparent_outputs");
      (*(void (**)(long long *, const char *))(v26 + 16))(&v26, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v26);
    }
  }
  return *(void *)(v16 + 104);
}

void sub_188648C30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188648C3C()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_tile::access_component(uint64_t **this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v2 = *this;
  uint64_t v3 = **this;
  if (*(_DWORD *)(v3 + 172) <= (signed int)a2) {
    return 0;
  }
  int v4 = -991146299 * ((uint64_t)(*(void *)(*(void *)(v3 + 312) + 104 * a2 + 96) - *(void *)(v3 + 312)) >> 3);
  if (v4 < 0 || *((_DWORD *)v2 + 47) <= v4)
  {
    uint64_t v8 = 0;
    memset(v7, 0, sizeof(v7));
    kdu_error::kdu_error((kdu_error *)v7, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v7[0] + 16))(v7, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v7[0] + 16))(v7, "(true_idx >= 0) && (true_idx < state->num_components)");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v7[0] + 16))(v7, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v7);
  }
  uint64_t v5 = v2[34] + 224 * v4;
  if (*(unsigned char *)(v5 + 184)) {
    return v5;
  }
  else {
    return 0;
  }
}

void sub_188648DBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188648DC8()
{
  _Unwind_Resume(v0);
}

void kd_tile_comp::~kd_tile_comp(kd_tile_comp *this)
{
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C80451B5BE8);
  }
  uint64_t v3 = *((void *)this + 13);
  if (v3 && v3 != *((void *)this + 12)) {
    MEMORY[0x18C11C0C0](v3, 0x1000C80451B5BE8);
  }
  uint64_t v4 = *((void *)this + 14);
  if (v4) {
    MEMORY[0x18C11C0C0](v4, 0x1000C8052888210);
  }
  uint64_t v5 = *((void *)this + 15);
  if (v5 && v5 != *((void *)this + 14)) {
    MEMORY[0x18C11C0C0](v5, 0x1000C8052888210);
  }
  uint64_t v6 = *((void *)this + 22);
  if (v6)
  {
    uint64_t v7 = v6 - 16;
    uint64_t v8 = *(void *)(v6 - 8);
    if (v8)
    {
      uint64_t v9 = v6 - 704;
      uint64_t v10 = 704 * v8;
      do
      {
        kd_resolution::~kd_resolution((kd_resolution *)(v9 + v10));
        v10 -= 704;
      }
      while (v10);
    }
    MEMORY[0x18C11C0C0](v7, 0x10A0C80EE9AF17DLL);
  }
}

uint64_t kdu_tile_comp::get_reversible(kdu_tile_comp *this)
{
  return *(unsigned __int8 *)(*(void *)this + 76);
}

uint64_t kdu_tile_comp::get_bit_depth(kdu_tile_comp *this, int a2)
{
  uint64_t v2 = *(void *)this;
  uint64_t result = *(unsigned int *)(*(void *)(*(void *)this + 16) + 16);
  if (a2) {
    return (*(_DWORD *)(v2 + 160) + result);
  }
  return result;
}

uint64_t kdu_tile_comp::access_resolution(uint64_t **this, int a2)
{
  if (a2 < 0 || (uint64_t v2 = *this, *((_DWORD *)*this + 18) < a2))
  {
    uint64_t v8 = 0;
    long long v6 = 0u;
    long long v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v6 + 16))(&v6, "Attempting to access a non-existent resolution level within some tile-component.  Problem almost certainly caused by trying to discard more resolution levels than the number of DWT levels used to compress a tile-component.");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  uint64_t v3 = v2[22];
  if (!*(unsigned char *)(v3 + 704 * a2 + 221))
  {
    uint64_t v4 = *v2;
    if (*(unsigned char *)(v4 + 410) || *(unsigned char *)(v4 + 411))
    {
      uint64_t v8 = 0;
      long long v6 = 0u;
      long long v7 = 0u;
      kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v6);
    }
  }
  return v3 + 704 * a2;
}

void sub_188649028(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188649034()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_tile_comp::access_resolution(uint64_t **this)
{
  return kdu_tile_comp::access_resolution(this, *((_DWORD *)*this + 18));
}

uint64_t create_child_node(_DWORD *a1, unsigned int a2, char a3, uint64_t a4, _DWORD *a5, uint64_t a6, _DWORD *a7, unsigned int a8, int a9, unsigned int a10, char a11, char a12, int a13, uint64_t a14, int a15, uint64_t a16, uint64_t a17)
{
  if ((a9 - 1) >= 3)
  {
    uint64_t v48 = 0;
    long long v46 = 0u;
    long long v47 = 0u;
    kdu_error::kdu_error((kdu_error *)&v46, "Kakadu Core Error:\n");
    (*(void (**)(void))(v46 + 16))();
    (*(void (**)(long long *, const char *))(v46 + 16))(&v46, "(sub_level >= 1) && (sub_level <= 3)");
    (*(void (**)(long long *, const char *))(v46 + 16))(&v46, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v46);
  }
  if (a9 == 2) {
    unsigned int v17 = 0;
  }
  else {
    unsigned int v17 = a8 >> 2;
  }
  uint64_t v18 = a8 & 3;
  if ((a8 & 3) != 0)
  {
    int v19 = (*a5)++;
    uint64_t v20 = a4 + 136 * v19;
    uint64_t v21 = v20;
  }
  else
  {
    uint64_t v21 = 0;
    int v22 = (*a7)++;
    uint64_t v20 = a6 + 144 * v22;
  }
  *(void *)uint64_t v20 = a1;
  if (a3)
  {
    *(unsigned char *)(v20 + 48) = a2 & 1;
    if (a13 >= 3)
    {
      uint64_t v48 = 0;
      long long v46 = 0u;
      long long v47 = 0u;
      kdu_error::kdu_error((kdu_error *)&v46, "Kakadu Core Error:\n");
      (*(void (**)(void))(v46 + 16))();
      (*(void (**)(long long *, const char *))(v46 + 16))(&v46, "num_hor_extra_stages < 3");
      (*(void (**)(long long *, const char *))(v46 + 16))(&v46, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v46);
    }
    int v43 = a13 + 1;
    *(unsigned char *)(a14 + a13) = (a2 & 1) != 0;
    if (a2) {
      char v23 = 1;
    }
    else {
      char v23 = a11;
    }
    if ((a2 & 1) != 0 && a11)
    {
      *(unsigned char *)(*(void *)(v20 + 8) + 221) = 0;
      char v40 = 1;
    }
    else
    {
      char v40 = v23;
    }
  }
  else
  {
    *(unsigned char *)(v20 + 48) = 2;
    char v40 = a11;
    if (a2)
    {
      uint64_t v48 = 0;
      long long v46 = 0u;
      long long v47 = 0u;
      kdu_error::kdu_error((kdu_error *)&v46, "Kakadu Core Error:\n");
      (*(void (**)(void))(v46 + 16))();
      (*(void (**)(long long *, const char *))(v46 + 16))(&v46, "!(child_idx & 1)");
      (*(void (**)(long long *, const char *))(v46 + 16))(&v46, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v46);
    }
    int v43 = a13;
  }
  char v24 = a12;
  if ((a3 & 2) != 0)
  {
    int v26 = (a2 >> 1) & 1;
    *(unsigned char *)(v20 + 49) = (a2 & 2) != 0;
    if (a15 >= 3)
    {
      uint64_t v48 = 0;
      long long v46 = 0u;
      long long v47 = 0u;
      kdu_error::kdu_error((kdu_error *)&v46, "Kakadu Core Error:\n");
      (*(void (**)(void))(v46 + 16))();
      (*(void (**)(long long *, const char *))(v46 + 16))(&v46, "num_vert_extra_stages < 3");
      (*(void (**)(long long *, const char *))(v46 + 16))(&v46, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v46);
    }
    int v25 = a15 + 1;
    *(unsigned char *)(a16 + a15) = v26 != 0;
    if (v26) {
      char v27 = 1;
    }
    else {
      char v27 = a12;
    }
    if (v26 && a12)
    {
      *(unsigned char *)(*(void *)(v20 + 8) + 221) = 0;
      char v24 = 1;
    }
    else
    {
      char v24 = v27;
    }
  }
  else
  {
    *(unsigned char *)(v20 + 49) = 2;
    if ((a2 & 2) != 0)
    {
      uint64_t v48 = 0;
      long long v46 = 0u;
      long long v47 = 0u;
      kdu_error::kdu_error((kdu_error *)&v46, "Kakadu Core Error:\n");
      (*(void (**)(void))(v46 + 16))();
      (*(void (**)(long long *, const char *))(v46 + 16))(&v46, "!(child_idx & 2)");
      (*(void (**)(long long *, const char *))(v46 + 16))(&v46, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v46);
    }
    int v25 = a15;
  }
  if (v21)
  {
    if ((a8 & 3) != 0)
    {
      if (a8) {
        int v28 = *(_DWORD *)(*(void *)(*(void *)(v20 + 8) + 8) + 88);
      }
      else {
        LOBYTE(v28) = 0;
      }
      *(unsigned char *)(v21 + 120) = v28;
      if ((a8 & 2) != 0) {
        int v29 = *(_DWORD *)(*(void *)(*(void *)(v20 + 8) + 8) + 88);
      }
      else {
        LOBYTE(v29) = 0;
      }
      *(unsigned char *)(v21 + 121) = v29;
      operator new[]();
    }
    uint64_t v48 = 0;
    long long v46 = 0u;
    long long v47 = 0u;
    kdu_error::kdu_error((kdu_error *)&v46, "Kakadu Core Error:\n");
    (*(void (**)(void))(v46 + 16))();
    (*(void (**)(long long *, const char *))(v46 + 16))(&v46, "next_branch_mask != 0");
    (*(void (**)(long long *, const char *))(v46 + 16))(&v46, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v46);
  }
  LODWORD(v30) = a1[4];
  LODWORD(v31) = a1[5];
  unsigned int v32 = *(unsigned __int8 *)(v20 + 48);
  unsigned int v33 = *(unsigned __int8 *)(v20 + 49);
  int v34 = a1[7] + v31;
  int v35 = a1[6] + v30;
  if (v32 <= 1) {
    uint64_t v31 = ((int)(v31 - v32 + 1) >> 1);
  }
  else {
    uint64_t v31 = v31;
  }
  if (v32 <= 1) {
    int v34 = (int)(v34 - v32 + 1) >> 1;
  }
  if (v33 <= 1) {
    uint64_t v30 = ((int)(v30 - v33 + 1) >> 1);
  }
  else {
    uint64_t v30 = v30;
  }
  if (v33 <= 1) {
    int v35 = (int)(v35 - v33 + 1) >> 1;
  }
  *(void *)(v20 + 16) = v30 | (v31 << 32);
  *(void *)(v20 + 24) = (v35 - v30) | ((unint64_t)(v34 - v31) << 32);
  if ((a8 & 3) != 0)
  {
    uint64_t v36 = v20;
    for (uint64_t i = 0; i != 4; ++i)
    {
      if (i == (v18 & i))
      {
        HIDWORD(v39) = v43;
        BYTE1(v39) = v24;
        LOBYTE(v39) = v40;
        *(void *)(8 * i + 0x58) = create_child_node(0, i, v18, a4, a5, a6, a7, v17 & 3, __PAIR64__(a10, a9 + 1), v39, a14, v25, a16, a17);
        v17 >>= 2;
      }
    }
  }
  else
  {
    if (!*(unsigned char *)(v20 + 50))
    {
      uint64_t v48 = 0;
      long long v46 = 0u;
      long long v47 = 0u;
      kdu_error::kdu_error((kdu_error *)&v46, "Kakadu Core Error:\n");
      (*(void (**)(void))(v46 + 16))();
      (*(void (**)(long long *, const char *))(v46 + 16))(&v46, "result->is_leaf");
      (*(void (**)(long long *, const char *))(v46 + 16))(&v46, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v46);
    }
    uint64_t v36 = v20;
    *(unsigned char *)(v20 + 54) = a10;
  }
  return v36;
}

void sub_18864997C()
{
  kdu_error::~kdu_error((kdu_error *)(v0 - 128));
}

void sub_188649988()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_resolution::which(kdu_resolution *this)
{
  if (!*(void *)this)
  {
    uint64_t v3 = 0;
    memset(v2, 0, sizeof(v2));
    kdu_error::kdu_error((kdu_error *)v2, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v2[0] + 16))(v2, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v2[0] + 16))(v2, "state != NULL");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v2[0] + 16))(v2, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v2);
  }
  return *(unsigned __int8 *)(*(void *)this + 24);
}

void sub_188649AE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188649AF4()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_resolution::get_dwt_level(kdu_resolution *this)
{
  return *(unsigned __int8 *)(*(void *)this + 25);
}

int32x4_t *kdu_resolution::get_dims(int32x4_t **this, int32x4_t *a2)
{
  if (!*this)
  {
    uint64_t v6 = 0;
    long long v4 = 0u;
    long long v5 = 0u;
    kdu_error::kdu_error((kdu_error *)&v4, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v4 + 16))(&v4, "Assert ");
    (*(void (**)(long long *, const char *))(v4 + 16))(&v4, "state != NULL");
    (*(void (**)(long long *, const char *))(v4 + 16))(&v4, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v4);
  }
  *a2 = (*this)[4];
  uint64_t v2 = (unsigned __int8 *)(*this)->i64[0];
  if (!v2)
  {
    uint64_t v6 = 0;
    long long v4 = 0u;
    long long v5 = 0u;
    kdu_error::kdu_error((kdu_error *)&v4, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v4 + 16))(&v4, "Assert ");
    (*(void (**)(long long *, const char *))(v4 + 16))(&v4, "state->codestream != NULL");
    (*(void (**)(long long *, const char *))(v4 + 16))(&v4, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v4);
  }
  return kdu_dims::to_apparent(a2, v2[409], v2[410], v2[411]);
}

void sub_188649CF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188649D00()
{
  _Unwind_Resume(v0);
}

int32x4_t *kdu_dims::to_apparent(int32x4_t *this, int a2, int a3, int a4)
{
  if (a2)
  {
    *this = vrev64q_s32(*this);
    if (!a4)
    {
LABEL_3:
      if (!a3) {
        return this;
      }
LABEL_7:
      this->i32[0] = 1 - (this->i32[0] + this->i32[2]);
      return this;
    }
  }
  else if (!a4)
  {
    goto LABEL_3;
  }
  this->i32[1] = 1 - (this->i32[1] + this->i32[3]);
  if (a3) {
    goto LABEL_7;
  }
  return this;
}

uint64_t kd_precinct::load_required_packets(uint64_t this)
{
  if (*(unsigned char *)(this + 18))
  {
    uint64_t v1 = this;
    uint64_t v2 = *(void *)(this + 40);
    if (v2)
    {
      if (!*(_DWORD *)(this + 32))
      {
        if (!*(unsigned char *)(this + 17) || *(_DWORD *)(this + 28) < *(_DWORD *)(this + 24)) {
          kd_precinct::load_required_packets();
        }
        this = kd_compressed_input::seek(*(void *)(**(void **)this + 8), v2);
        do
        {
          if (*(_DWORD *)(v1 + 32) >= *(_DWORD *)(v1 + 24)) {
            break;
          }
          this = kd_precinct::read_packet((uint64_t **)v1);
        }
        while ((this & 1) != 0);
      }
    }
  }
  return this;
}

uint64_t kdu_resolution::get_reversible(kdu_resolution *this)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)this + 8) + 76);
}

uint64_t kdu_resolution::propagate_roi(kdu_resolution *this)
{
  return *(unsigned __int8 *)(*(void *)this + 220);
}

uint64_t kdu_resolution::access_node(kdu_resolution *this)
{
  if (!*(void *)this)
  {
    uint64_t v3 = 0;
    memset(v2, 0, sizeof(v2));
    kdu_error::kdu_error((kdu_error *)v2, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v2[0] + 16))(v2, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v2[0] + 16))(v2, "state != NULL");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v2[0] + 16))(v2, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v2);
  }
  return *(void *)this + 32;
}

void sub_188649F00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188649F0C()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_resolution::access_subband(kdu_resolution *this, int a2)
{
  uint64_t v2 = *(void *)this;
  int v3 = a2 - (*(unsigned char *)(*(void *)this + 24) != 0);
  if (v3 < 0 || v3 >= *(unsigned __int8 *)(v2 + 222))
  {
    uint64_t v8 = 0;
    memset(v7, 0, sizeof(v7));
    kdu_error::kdu_error((kdu_error *)v7, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v7[0] + 16))(v7, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v7[0] + 16))(v7, "(band_idx >= 0) && (band_idx < state->num_subbands)");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v7[0] + 16))(v7, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v7);
  }
  uint64_t v4 = *(void *)(v2 + 240);
  int v5 = a2 - (*(unsigned char *)(*(void *)this + 24) != 0);
  if (*(unsigned char *)(*(void *)v2 + 409)) {
    int v5 = *(unsigned __int8 *)(v4 + 144 * v3 + 56);
  }
  return v4 + 144 * v5;
}

void sub_18864A054(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18864A060()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_node::access_child(kdu_node *this, unsigned int a2)
{
  if (a2 >= 4)
  {
    uint64_t v12 = 0;
    long long v10 = 0u;
    long long v11 = 0u;
    kdu_error::kdu_error((kdu_error *)&v10, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v10 + 16))(&v10, "Assert ");
    (*(void (**)(long long *, const char *))(v10 + 16))(&v10, "(child_idx >= 0) && (child_idx <= 3)");
    (*(void (**)(long long *, const char *))(v10 + 16))(&v10, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v10);
  }
  uint64_t v2 = *(void *)this;
  if (*(unsigned char *)(*(void *)this + 50)) {
    return 0;
  }
  unsigned int v5 = __rbit32(a2) >> 30;
  if (*(unsigned char *)(**(void **)(v2 + 8) + 409)) {
    signed int v6 = v5;
  }
  else {
    signed int v6 = a2;
  }
  uint64_t v3 = *(void *)(v2 + 8 * v6 + 88);
  if (v3)
  {
    uint64_t v7 = *(void *)(v3 + 8);
    if (!*(unsigned char *)(v7 + 24))
    {
      uint64_t v8 = v7 + 32;
      if (v6) {
        BOOL v9 = 0;
      }
      else {
        BOOL v9 = v3 == v8;
      }
      if (!v9)
      {
        uint64_t v12 = 0;
        long long v10 = 0u;
        long long v11 = 0u;
        kdu_error::kdu_error((kdu_error *)&v10, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v10 + 16))(&v10, "Assert ");
        (*(void (**)(long long *, const char *))(v10 + 16))(&v10, "(child_idx==LL_BAND) && (result==&(result->resolution->node))");
        (*(void (**)(long long *, const char *))(v10 + 16))(&v10, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v10);
      }
      uint64_t v3 = *(void *)(v3 + 88);
      if (!*(unsigned char *)(v3 + 50))
      {
        uint64_t v12 = 0;
        long long v10 = 0u;
        long long v11 = 0u;
        kdu_error::kdu_error((kdu_error *)&v10, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v10 + 16))(&v10, "Assert ");
        (*(void (**)(long long *, const char *))(v10 + 16))(&v10, "result->is_leaf");
        (*(void (**)(long long *, const char *))(v10 + 16))(&v10, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v10);
      }
    }
  }
  return v3;
}

void sub_18864A344(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18864A350()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_node::access_subband(kdu_node *this)
{
  if (*(unsigned char *)(*(void *)this + 50)) {
    return *(void *)this;
  }
  else {
    return 0;
  }
}

uint64_t kdu_node::access_resolution(kdu_node *this)
{
  return *(void *)(*(void *)this + 8);
}

int32x4_t *kdu_node::get_dims(int32x4_t **this, int32x4_t *a2)
{
  uint64_t v4 = *(unsigned __int8 **)(*this)->i64[1];
  *a2 = (*this)[2];
  uint64_t result = kdu_dims::to_apparent(a2, v4[409], v4[410], v4[411]);
  if (*((_WORD *)v4 + 205))
  {
    signed int v6 = *this;
    if (*this == (int32x4_t *)((*this)->i64[1] + 32))
    {
      int v8 = 0;
      int v7 = 0;
    }
    else
    {
      int v7 = 0;
      int v8 = 0;
      do
      {
        if (v4[409]) {
          int v9 = v6[3].u8[1];
        }
        else {
          int v9 = v6[3].u8[0];
        }
        if (v4[409]) {
          int v10 = v6[3].u8[0];
        }
        else {
          int v10 = v6[3].u8[1];
        }
        if (v9 == 1 && v4[411])
        {
          if (v8)
          {
            uint64_t v14 = 0;
            long long v12 = 0u;
            long long v13 = 0u;
            kdu_error::kdu_error((kdu_error *)&v12, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v12 + 16))(&v12, "Assert ");
            (*(void (**)(long long *, const char *))(v12 + 16))(&v12, "!offset.x");
            (*(void (**)(long long *, const char *))(v12 + 16))(&v12, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v12);
          }
          int v8 = 1;
        }
        if (v10 == 1 && v4[410])
        {
          if (v7)
          {
            uint64_t v14 = 0;
            long long v12 = 0u;
            long long v13 = 0u;
            kdu_error::kdu_error((kdu_error *)&v12, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v12 + 16))(&v12, "Assert ");
            (*(void (**)(long long *, const char *))(v12 + 16))(&v12, "!offset.y");
            (*(void (**)(long long *, const char *))(v12 + 16))(&v12, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v12);
          }
          int v7 = 1;
        }
        signed int v6 = (int32x4_t *)v6->i64[0];
      }
      while (v6 != (int32x4_t *)(v6->i64[1] + 32));
    }
    __int32 v11 = a2->i32[1] - v8;
    a2->i32[0] -= v7;
    a2->i32[1] = v11;
  }
  return result;
}

void sub_18864A620(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18864A62C()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_node::get_kernel_id(kdu_node *this)
{
  return *(unsigned int *)(*(void *)(*(void *)(*(void *)this + 8) + 8) + 80);
}

uint64_t kdu_node::get_kernel_info(kdu_node *this, int *a2, float *a3, float *a4, BOOL *a5, BOOL *a6, int *a7, int *a8, int *a9, int *a10, BOOL a11)
{
  uint64_t v11 = *(void *)(*(void *)(*(void *)this + 8) + 8);
  uint64_t v12 = 410;
  if (!a11) {
    uint64_t v12 = 411;
  }
  int v13 = *(unsigned __int8 *)(*(void *)v11 + v12);
  *a2 = *(_DWORD *)(v11 + 88);
  *a3 = *(float *)(v11 + 128);
  *a4 = *(float *)(v11 + 132);
  *a5 = *(unsigned char *)(v11 + 84);
  *a6 = *(unsigned char *)(v11 + 85);
  if (v13)
  {
    *a7 = -*(_DWORD *)(v11 + 140);
    *a8 = -*(_DWORD *)(v11 + 136);
    *a9 = -*(_DWORD *)(v11 + 148);
    int v14 = -*(_DWORD *)(v11 + 144);
    uint64_t v15 = v11 + 104;
  }
  else
  {
    *a7 = *(_DWORD *)(v11 + 136);
    *a8 = *(_DWORD *)(v11 + 140);
    *a9 = *(_DWORD *)(v11 + 144);
    int v14 = *(_DWORD *)(v11 + 148);
    uint64_t v15 = v11 + 96;
  }
  *a10 = v14;
  return *(void *)v15;
}

uint64_t kdu_node::get_kernel_coefficients(kdu_node *this, int a2)
{
  uint64_t v2 = *(void **)(*(void *)(*(void *)this + 8) + 8);
  uint64_t v3 = 410;
  if (!a2) {
    uint64_t v3 = 411;
  }
  uint64_t v4 = 15;
  if (!*(unsigned char *)(*v2 + v3)) {
    uint64_t v4 = 14;
  }
  return v2[v4];
}

uint64_t kdu_node::get_bibo_gains(kdu_node *this, int *a2, int a3)
{
  uint64_t v3 = *(uint64_t **)this;
  int v4 = (*(unsigned char *)(**(void **)(*(void *)this + 8) + 409) != 0) ^ a3;
  if (*(unsigned char *)(*(void *)this + 50))
  {
    *a2 = 0;
    uint64_t v5 = *v3;
    uint64_t v6 = *(void *)(*v3 + 128);
    if (v4) {
      unsigned __int8 v7 = *(unsigned char *)(v5 + 121);
    }
    else {
      unsigned __int8 v7 = *(unsigned char *)(v5 + 120);
    }
    return v6 + 4 * (v7 & 0xFE);
  }
  else if (v4)
  {
    *a2 = *((unsigned __int8 *)v3 + 121);
    return v3[16] + 4 * *((unsigned __int8 *)v3 + 120) + 4;
  }
  else
  {
    *a2 = *((unsigned __int8 *)v3 + 120);
    return v3[16];
  }
}

uint64_t kdu_subband::get_band_idx(kdu_subband *this)
{
  if (*(unsigned char *)(*(void *)(*(void *)this + 8) + 24)) {
    return *(unsigned __int8 *)(*(void *)this + 55) + 1;
  }
  else {
    return *(unsigned __int8 *)(*(void *)this + 55);
  }
}

uint64_t kdu_subband::get_K_max(kdu_subband *this)
{
  return *(unsigned __int8 *)(*(void *)this + 58);
}

uint64_t kdu_subband::get_K_max_prime(kdu_subband *this)
{
  return *(unsigned __int8 *)(*(void *)this + 59);
}

uint64_t kdu_subband::get_reversible(kdu_subband *this)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)(*(void *)this + 8) + 8) + 76);
}

float kdu_subband::get_delta(kdu_subband *this)
{
  float result = 0.0;
  if (!*(unsigned char *)(*(void *)(*(void *)(*(void *)this + 8) + 8) + 76)) {
    return *(float *)(*(void *)this + 60);
  }
  return result;
}

float kdu_subband::get_msb_wmse(kdu_subband *this)
{
  uint64_t v1 = *(void *)this;
  uint64_t v2 = *(void **)(*(void *)this + 8);
  float result = 1.0;
  if (!*(void *)(*v2 + 8))
  {
    double v4 = *(float *)(v1 + 60);
    unsigned int v5 = *(unsigned __int8 *)(v1 + 59);
    if (v5 < 0x1F)
    {
      char v6 = *(unsigned char *)(v1 + 59);
    }
    else
    {
      do
      {
        double v4 = v4 * 1073741820.0;
        char v6 = v5 - 30;
        BOOL v7 = v5 > 0x3C;
        v5 -= 30;
      }
      while (v7);
    }
    double v8 = v4 * (double)(1 << (v6 - 1)) * (v4 * (double)(1 << (v6 - 1))) * *(float *)(v1 + 64);
    float v9 = *(float *)(v2[1] + 152);
    double v10 = v9;
    BOOL v7 = v9 <= 0.0;
    double v11 = 1.0;
    if (!v7) {
      double v11 = v10;
    }
    return v8 * v11 * *(float *)(v1 + 68) * *(float *)(v1 + 68);
  }
  return result;
}

BOOL kdu_subband::get_roi_weight(kdu_subband *this, float *a2)
{
  float v2 = *(float *)(*(void *)this + 72);
  if (v2 >= 0.0) {
    *a2 = v2 * v2;
  }
  return v2 >= 0.0;
}

int32x4_t *kdu_subband::get_dims(int32x4_t **this, int32x4_t *a2)
{
  double v4 = *(unsigned __int8 **)(*this)->i64[1];
  *a2 = (*this)[2];
  float result = kdu_dims::to_apparent(a2, v4[409], v4[410], v4[411]);
  if (*((_WORD *)v4 + 205))
  {
    char v6 = *this;
    if (*this == (int32x4_t *)((*this)->i64[1] + 32))
    {
      int v8 = 0;
      int v7 = 0;
    }
    else
    {
      int v7 = 0;
      int v8 = 0;
      do
      {
        if (v4[409]) {
          int v9 = v6[3].u8[1];
        }
        else {
          int v9 = v6[3].u8[0];
        }
        if (v4[409]) {
          int v10 = v6[3].u8[0];
        }
        else {
          int v10 = v6[3].u8[1];
        }
        if (v9 == 1 && v4[411])
        {
          if (v8)
          {
            uint64_t v14 = 0;
            long long v12 = 0u;
            long long v13 = 0u;
            kdu_error::kdu_error((kdu_error *)&v12, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v12 + 16))(&v12, "Assert ");
            (*(void (**)(long long *, const char *))(v12 + 16))(&v12, "!offset.x");
            (*(void (**)(long long *, const char *))(v12 + 16))(&v12, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v12);
          }
          int v8 = 1;
        }
        if (v10 == 1 && v4[410])
        {
          if (v7)
          {
            uint64_t v14 = 0;
            long long v12 = 0u;
            long long v13 = 0u;
            kdu_error::kdu_error((kdu_error *)&v12, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v12 + 16))(&v12, "Assert ");
            (*(void (**)(long long *, const char *))(v12 + 16))(&v12, "!offset.y");
            (*(void (**)(long long *, const char *))(v12 + 16))(&v12, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v12);
          }
          int v7 = 1;
        }
        char v6 = (int32x4_t *)v6->i64[0];
      }
      while (v6 != (int32x4_t *)(v6->i64[1] + 32));
    }
    __int32 v11 = a2->i32[1] - v8;
    a2->i32[0] -= v7;
    a2->i32[1] = v11;
  }
  return result;
}

void sub_18864AB80(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18864AB8C()
{
  _Unwind_Resume(v0);
}

int32x4_t *kdu_subband::get_valid_blocks(kdu_subband *this, int32x4_t *a2)
{
  float v2 = **(unsigned __int8 ***)(*(void *)this + 8);
  *a2 = *(int32x4_t *)(*(void *)this + 108);
  return kdu_dims::to_apparent(a2, v2[409], v2[410], v2[411]);
}

int32x2_t kdu_subband::get_block_size(uint64_t *a1, int32x2_t *a2, int32x2_t *a3)
{
  unsigned int v5 = **(unsigned char ***)(*a1 + 8);
  *a2 = *(int32x2_t *)(*a1 + 84);
  uint64_t v6 = *a1;
  int v7 = **(unsigned __int8 ***)(*a1 + 8);
  int v8 = *(_DWORD *)(*a1 + 108);
  int v9 = *(_DWORD *)(*a1 + 116);
  int v10 = v7[409];
  int v11 = v7[410];
  int v12 = v7[411];
  BOOL v13 = v10 == 0;
  if (v10) {
    int v14 = *(_DWORD *)(*a1 + 112);
  }
  else {
    int v14 = *(_DWORD *)(*a1 + 108);
  }
  if (v13)
  {
    int v8 = *(_DWORD *)(*a1 + 112);
    int v15 = *(_DWORD *)(*a1 + 116);
  }
  else
  {
    int v15 = *(_DWORD *)(*a1 + 120);
  }
  if (v13) {
    int v9 = *(_DWORD *)(*a1 + 120);
  }
  int v16 = 1 - v8 - v9;
  if (v12) {
    int v17 = v16;
  }
  else {
    int v17 = v8;
  }
  int v18 = 1 - v14 - v15;
  if (!v11) {
    int v18 = v14;
  }
  if (v5[411]) {
    int v17 = -v17;
  }
  if (v5[410]) {
    int v18 = -v18;
  }
  if (v5[409]) {
    int v19 = v18;
  }
  else {
    int v19 = v17;
  }
  if (!v5[409]) {
    int v17 = v18;
  }
  long long v21 = *(_OWORD *)(v6 + 76);
  LODWORD(v21) = v21 + DWORD2(v21) * v17;
  DWORD1(v21) += v19 * HIDWORD(v21);
  kdu_dims::operator&=(&v21, (int *)(v6 + 32));
  *a3 = *(int32x2_t *)((char *)&v21 + 8);
  if (v5[409])
  {
    *a2 = vrev64_s32(*a2);
    int32x2_t result = vrev64_s32(*a3);
    *a3 = result;
  }
  return result;
}

uint64_t kdu_subband::open_block(uint64_t *a1, unint64_t a2, _DWORD *a3, kdu_thread_entity *a4)
{
  unint64_t v4 = HIDWORD(a2);
  unsigned int v5 = (_DWORD *)*a1;
  uint64_t v6 = *(void *)(*a1 + 8);
  uint64_t v7 = *(void *)v6;
  if (*(unsigned char *)(*(void *)v6 + 411)) {
    LODWORD(v4) = -HIDWORD(a2);
  }
  if (*(unsigned char *)(*(void *)v6 + 410)) {
    int v8 = -(int)a2;
  }
  else {
    int v8 = a2;
  }
  if (*(unsigned char *)(*(void *)v6 + 409)) {
    int v9 = v8;
  }
  else {
    int v9 = v4;
  }
  if (!*(unsigned char *)(*(void *)v6 + 409)) {
    LODWORD(v4) = v8;
  }
  int v10 = v5[28];
  int v11 = v4 - v5[27];
  if (v9 - v10 < 0 || v9 - v10 >= v5[30] || v11 < 0 || v11 >= v5[29])
  {
    uint64_t v51 = 0;
    long long v49 = 0u;
    long long v50 = 0u;
    kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Assert ");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "(block_idx.x >= 0) && (block_idx.x < state->region_indices.size.x) && (block_idx.y >= 0) && (block_idx.y < state->region_indices.size.y)");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v49);
  }
  uint64_t v12 = *(void *)(*(void *)(v6 + 8) + 8);
  if (!*(unsigned char *)(v12 + 289))
  {
    uint64_t v51 = 0;
    long long v49 = 0u;
    long long v50 = 0u;
    kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Assert ");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "tile->is_open");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v49);
  }
  int v13 = v9;
  int v14 = v4;
  uint64_t v15 = ((v9 >> v5[34]) - *(_DWORD *)(v6 + 188));
  uint64_t v16 = (((int)v4 >> v5[33]) - *(_DWORD *)(v6 + 184));
  int v17 = *(_DWORD *)(v6 + 196);
  uint64_t v18 = (v15 + v16 * v17);
  if ((v18 & 0x80000000) != 0 || *(int *)(v6 + 192) * (uint64_t)v17 <= v18) {
    return 0;
  }
  uint64_t v19 = *(void *)(v6 + 232);
  uint64_t v20 = *(void *)(v19 + 8 * v18);
  if (v20) {
    BOOL v21 = (*(void *)(v19 + 8 * v18) & 1) == 0;
  }
  else {
    BOOL v21 = 0;
  }
  if (v21 && !*(unsigned char *)(v20 + 20) && !*(unsigned char *)(v20 + 19))
  {
    BOOL v22 = 0;
    goto LABEL_38;
  }
  BOOL v22 = a4 != 0;
  if (a4)
  {
    kdu_thread_entity::acquire_lock(a4, 0, 1);
    uint64_t v19 = *(void *)(v6 + 232);
    uint64_t v20 = *(void *)(v19 + 8 * v18);
  }
  if (!v20) {
    goto LABEL_35;
  }
  if (v20 == 3) {
    goto LABEL_37;
  }
  if (v20)
  {
LABEL_35:
    uint64_t v24 = kd_precinct_ref::instantiate_precinct((uint64_t *)(v19 + 8 * v18), v6, (v15 << 32) | v16);
    if (v24)
    {
      uint64_t v20 = v24;
      goto LABEL_38;
    }
LABEL_37:
    uint64_t v51 = 0;
    long long v49 = 0u;
    long long v50 = 0u;
    kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "You are permitted to open each code-block only once from an open tile before closing that tile.  If the codestream object is marked as persistent, you may re-open code-blocks only after re-opening their containing tiles.");
    kdu_error::~kdu_error((kdu_error *)&v49);
  }
  if (*(unsigned char *)(v20 + 20))
  {
    kd_precinct_size_class::withdraw_from_inactive_list(*(void *)(v20 + 72), (kd_precinct *)v20);
    kd_precinct::activate(v20);
LABEL_38:
    int v25 = a4;
    goto LABEL_39;
  }
  int v25 = a4;
  if (*(unsigned char *)(v20 + 19)) {
    kd_precinct::activate(v20);
  }
LABEL_39:
  if (*(void *)(v7 + 8) && *(_DWORD *)(v20 + 32) < *(_DWORD *)(v20 + 24))
  {
    if (v25) {
      char v26 = v22;
    }
    else {
      char v26 = 1;
    }
    if ((v26 & 1) == 0)
    {
      LOBYTE(v22) = 1;
      kdu_thread_entity::acquire_lock(v25, 0, 1);
    }
    if (*(unsigned char *)(v7 + 418) || *(unsigned char *)(v12 + 328))
    {
LABEL_48:
      kd_precinct::load_required_packets(v20);
      if (!v22) {
        goto LABEL_52;
      }
      goto LABEL_51;
    }
    while (1)
    {
      if (*(_DWORD *)(v20 + 28) >= *(_DWORD *)(v20 + 24)) {
        goto LABEL_48;
      }
      if (v12 != *(void *)(v7 + 440) && (kd_tile::read_tile_part_header((kd_tile *)v12) & 1) == 0)
      {
        if (*(unsigned char *)(v12 + 291))
        {
          uint64_t v51 = 0;
          long long v49 = 0u;
          long long v50 = 0u;
          kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Assert ");
          (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "!tile->closed");
          (*(void (**)(long long *, const char *))(v49 + 16))(&v49, " FAILED");
          kdu_error::~kdu_error((kdu_error *)&v49);
        }
        kd_tile::finished_reading((kd_tile *)v12);
        goto LABEL_48;
      }
      *(void *)&long long v47 = 0;
      uint64_t v48 = 0;
      int v41 = *(uint64_t **)(v12 + 96);
      if (!v41)
      {
        uint64_t v51 = 0;
        long long v49 = 0u;
        long long v50 = 0u;
        kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Corrupt jp2 data: tile->sequencer = NULL");
        kdu_error::~kdu_error((kdu_error *)&v49);
      }
      uint64_t v42 = kd_packet_sequencer::next_in_sequence(v41, (uint64_t *)&v47, &v48);
      if (!v42) {
        goto LABEL_90;
      }
      uint64_t v43 = *v42;
      if (*v42)
      {
        if ((v43 & 1) != 0 || *(unsigned char *)(v43 + 17)) {
          goto LABEL_91;
        }
        if (v43 == 3)
        {
          uint64_t v43 = 0;
        }
        else if (*(unsigned char *)(v43 + 20))
        {
          kd_precinct_size_class::withdraw_from_inactive_list(*(void *)(v43 + 72), (kd_precinct *)v43);
          kd_precinct::activate(v43);
        }
      }
      else
      {
        uint64_t v43 = kd_precinct_ref::instantiate_precinct(v42, v47, v48);
      }
      if ((kd_precinct::desequence_packet((kd_precinct *)v43) & 1) == 0) {
LABEL_90:
      }
        kd_tile::read_tile_part_header((kd_tile *)v12);
LABEL_91:
      if (*(unsigned char *)(v12 + 328)) {
        goto LABEL_48;
      }
    }
  }
  if (v22) {
LABEL_51:
  }
    kdu_thread_entity::release_lock(v25, 0);
LABEL_52:
  uint64_t v27 = *a1;
  long long v47 = *(_OWORD *)(*a1 + 76);
  LODWORD(v47) = v47 + DWORD2(v47) * v14;
  DWORD1(v47) += HIDWORD(v47) * v13;
  kdu_dims::operator&=(&v47, (int *)(v27 + 16));
  if (SDWORD2(v47) * (uint64_t)SHIDWORD(v47) <= 0)
  {
    uint64_t v51 = 0;
    long long v49 = 0u;
    long long v50 = 0u;
    kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Assert ");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "band_dims.area() > 0");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v49);
  }
  uint64_t v28 = *(void *)(v20 + 48);
  uint64_t v29 = *(unsigned __int8 *)(*a1 + 55);
  int v30 = v13 - *(_DWORD *)(v28 + 32 * v29 + 12);
  int v31 = v14 - *(_DWORD *)(v28 + 32 * v29 + 8);
  if (v30 < 0 || v31 < 0 || (uint64_t v32 = v28 + 32 * v29, v30 >= *(_DWORD *)(v32 + 20)) || v31 >= *(_DWORD *)(v32 + 16))
  {
    uint64_t v51 = 0;
    long long v49 = 0u;
    long long v50 = 0u;
    kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Assert ");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "(block_idx.x >= 0) && (block_idx.y >= 0) && (block_idx.x < pband->block_indices.size.x) && (block_idx.y < pband->block_indices.size.y)");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v49);
  }
  if (v25) {
    uint64_t v23 = *((void *)v25 + 10) + 144;
  }
  else {
    uint64_t v23 = *(void *)(v7 + 56);
  }
  if (*(void *)(v23 + 168))
  {
    uint64_t v51 = 0;
    long long v49 = 0u;
    long long v50 = 0u;
    kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Assert ");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "result->precinct == NULL");
    (*(void (**)(long long *, const char *))(v49 + 16))(&v49, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v49);
  }
  *(void *)(v23 + 168) = v20;
  *(void *)(v23 + 176) = *(void *)(v28 + 32 * v29 + 24) + 40 * v30 + 40 * *(_DWORD *)(v28 + 32 * v29 + 20) * v31;
  *(void *)uint64_t v23 = *((void *)&v47 + 1);
  unsigned int v33 = (int *)(*a1 + 32);
  long long v49 = v47;
  kdu_dims::operator&=(&v49, v33);
  int v34 = v49;
  int v35 = DWORD1(v49);
  *(void *)(v23 + 16) = *((void *)&v49 + 1);
  int v36 = v35 - DWORD1(v47);
  *(_DWORD *)(v23 + 8) = v34 - v47;
  *(_DWORD *)(v23 + 12) = v36;
  uint64_t v37 = *a1;
  *(_DWORD *)(v23 + 28) = *(_DWORD *)(*(void *)(*(void *)(*a1 + 8) + 8) + 172);
  *(_DWORD *)(v23 + 32) = *(unsigned __int8 *)(v37 + 54);
  *(_DWORD *)(v23 + 40) = *(unsigned __int8 *)(v37 + 59);
  *(_WORD *)(v23 + 25) = *(_WORD *)(v7 + 410);
  *(unsigned char *)(v23 + 24) = *(unsigned char *)(v7 + 409);
  *(unsigned char *)(v23 + 36) = *(unsigned char *)(v7 + 412);
  *(unsigned char *)(v23 + 37) = *(unsigned char *)(v7 + 414);
  int v38 = *(kd_block **)(v23 + 176);
  if (*(void *)(v7 + 8))
  {
    uint64_t v39 = a3;
    if (v38 && kd_block::retrieve_data(v38, (kdu_block *)v23, *(_DWORD *)(v20 + 24)))
    {
      uint64_t v51 = 0;
      long long v49 = 0u;
      long long v50 = 0u;
      kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Corrupt JP2 data");
      goto LABEL_70;
    }
  }
  else
  {
    uint64_t v39 = a3;
    if (*(void *)v38)
    {
      uint64_t v51 = 0;
      long long v49 = 0u;
      long long v50 = 0u;
      kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Attempting to open the same code-block more than once for writing!");
LABEL_70:
      kdu_error::~kdu_error((kdu_error *)&v49);
    }
  }
  if (v39) {
    _DWORD *v39 = *(_DWORD *)(*(void *)(*(void *)(*(void *)v20 + 8) + 8) + 304) - 1;
  }
  return v23;
}

void sub_18864B760(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18864B76C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(v17);
}

double kdu_subband::close_block(uint64_t a1, kdu_block *a2, uint64_t a3)
{
  unint64_t v4 = (int *)*((void *)a2 + 21);
  unsigned int v5 = (kd_block *)*((void *)a2 + 22);
  uint64_t v6 = **(void **)(*(void *)a1 + 8);
  if (!v4)
  {
    uint64_t v16 = 0;
    long long v14 = 0u;
    long long v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "Assert ");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "precinct != NULL");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  if (a3)
  {
    uint64_t v7 = *(int **)(a3 + 80);
    if (v7 + 36 == (int *)a2)
    {
      *((void *)a2 + 21) = 0;
      block_state = (kd_block *)kd_thread_env::get_block_state((kd_thread_env *)v7, (kd_codestream *)v6, (kd_precinct *)v4, v5);
      if (!*(void *)(v6 + 8))
      {
        kd_block::store_data(block_state, a2, (kd_thread_buf_server *)(v7 + 8290));
        if (*(void *)(v6 + 64)) {
          kd_compressed_stats::update_stats((uint64_t)(v7 + 82), (int *)a2);
        }
        if (!*(void *)(v6 + 16)) {
          kd_thread_env::flush((uint64_t)v7, 1);
        }
      }
      if (v7[8302] >= 6) {
        kd_thread_env::flush((uint64_t)v7, 0);
      }
      return result;
    }
LABEL_7:
    uint64_t v16 = 0;
    long long v14 = 0u;
    long long v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "Assert ");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "((env == NULL) && (result == cs->block)) || ((env != NULL) && (result == &(env->get_state()->block)))");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  if (*(kdu_block **)(v6 + 56) != a2) {
    goto LABEL_7;
  }
  *((void *)a2 + 21) = 0;
  if (v4[9] <= 0)
  {
    uint64_t v16 = 0;
    long long v14 = 0u;
    long long v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "Assert ");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "precinct->num_outstanding_blocks > 0");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  if (*(void *)(v6 + 8))
  {
    if (!*(unsigned char *)(v6 + 417)) {
      kd_block::cleanup((uint64_t)v5, *(kd_buf_server **)(v6 + 48));
    }
    int v10 = v4[9] - 1;
    v4[9] = v10;
    if (!v10) {
      kd_precinct::release((uint64_t *)v4);
    }
  }
  else
  {
    uint64_t v11 = *(void *)(v6 + 64);
    if (v11)
    {
      int updated = kd_compressed_stats::update_stats(v11, (int *)a2);
      kd_compressed_stats::update_quant_slope_thresholds(*(void *)(v6 + 64));
    }
    else
    {
      int updated = 0;
    }
    if (*(void *)v5)
    {
      uint64_t v16 = 0;
      long long v14 = 0u;
      long long v15 = 0u;
      kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "Assert ");
      (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "block->empty()");
      (*(void (**)(long long *, const char *))(v14 + 16))(&v14, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v14);
    }
    kd_block::store_data(v5, a2, *(kd_buf_server **)(v6 + 48));
    int v13 = v4[9] - 1;
    v4[9] = v13;
    if (updated && !*(unsigned char *)(v6 + 422))
    {
      kd_codestream::trim_compressed_data(v6);
      int v13 = v4[9];
    }
    if (!v13) {
      *(void *)&double result = kd_global_rescomp::add_ready_precinct(*(void *)(*(void *)v4 + 16), v4).n128_u64[0];
    }
  }
  return result;
}

void sub_18864BCB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18864BCBC()
{
  _Unwind_Resume(v0);
}

uint64_t kd_thread_env::get_block_state(kd_thread_env *this, kd_codestream *a2, kd_precinct *a3, kd_block *a4)
{
  int v8 = (_DWORD *)((char *)this + 33208);
  if (*((_DWORD *)this + 8302) == 8) {
    kd_thread_env::flush((uint64_t)this, 1);
  }
  *((void *)this + 16) = a2;
  uint64_t result = (uint64_t)this + 33216;
  int v10 = 8;
  while (*(void *)(result + 40))
  {
    result += 56;
    if (!--v10) {
      return 0;
    }
  }
  ++*v8;
  *(void *)(result + 40) = a3;
  *(void *)(result + 48) = a4;
  *(unsigned char *)(*((void *)this + 17) + 88) = 1;
  return result;
}

uint64_t kd_compressed_stats::update_stats(uint64_t a1, int *a2)
{
  float v2 = (_DWORD *)(a1 + 32808);
  uint64_t v3 = *(void *)(a1 + 32) + *a2 * (uint64_t)a2[1];
  *(void *)(a1 + 32) = v3;
  uint64_t v4 = a2[12];
  if ((int)v4 >= 1)
  {
    LODWORD(v5) = 0;
    uint64_t v6 = (int *)*((void *)a2 + 7);
    uint64_t v7 = (unsigned __int16 *)*((void *)a2 + 8);
    do
    {
      uint64_t v8 = *v6++;
      uint64_t v5 = v8 + (int)v5;
      LODWORD(v8) = *v7++;
      unint64_t v9 = v8;
      if (v8)
      {
        unint64_t v10 = v9 >> 4;
        if (*v2 > (int)v10) {
          *float v2 = v10;
        }
        if (*(_DWORD *)(a1 + 32812) < (int)v10) {
          *(_DWORD *)(a1 + 32812) = v10;
        }
        uint64_t v11 = a1 + 8 * v10;
        uint64_t v12 = *(void *)(v11 + 40) + v5;
        LODWORD(v5) = 0;
        *(void *)(v11 + 40) = v12;
      }
      --v4;
    }
    while (v4);
  }
  if (!*(unsigned char *)(a1 + 32824)) {
    return 0;
  }
  uint64_t v13 = *(void *)(a1 + 16);
  if (v3 <= v13) {
    return 0;
  }
  *(void *)(a1 + 16) = v13 + ((*(void *)(a1 + 8) + 7) >> 4);
  return 1;
}

uint64_t kd_block::cleanup(uint64_t this, kd_buf_server *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = *(void **)this;
  for (*(void *)(this + 8) = *(void *)this; v4; *(void *)(v3 + 8) = *(void *)v3)
  {
    *(void *)uint64_t v3 = *v4;
    this = kd_buf_server::release((uint64_t)a2, (uint64_t)v4);
    uint64_t v4 = *(void **)v3;
  }
  *(unsigned char *)(v3 + 18) = -1;
  return this;
}

uint64_t kd_compressed_stats::update_quant_slope_thresholds(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 32812);
  uint64_t v2 = *(int *)(this + 32808);
  if (v1 >= (int)v2)
  {
    uint64_t v3 = 0;
    double v4 = *(double *)this;
    uint64_t v5 = v1;
    int v1 = v2 - 1;
    uint64_t v6 = v5;
    while (1)
    {
      v3 += *(void *)(this + 40 + 8 * v6);
      if (v3 > (uint64_t)(*(double *)this * (double)(uint64_t)(*(void *)(this + 24) + *(void *)(this + 32)))) {
        break;
      }
      BOOL v7 = v6-- <= v2;
      if (v7)
      {
        LODWORD(v6) = v2 - 1;
        break;
      }
    }
    uint64_t v8 = 0;
    *(_DWORD *)(this + 32816) = v6;
    while (1)
    {
      v8 += *(void *)(this + 40 + 8 * v5);
      if (v8 > (uint64_t)(v4 * (double)*(uint64_t *)(this + 8))) {
        break;
      }
      BOOL v7 = v5-- <= v2;
      if (v7) {
        goto LABEL_14;
      }
    }
    int v1 = v5;
  }
  else
  {
    *(_DWORD *)(this + 32816) = v1;
  }
LABEL_14:
  *(_DWORD *)(this + 32820) = v1;
  return this;
}

uint64_t kdu_subband::get_conservative_slope_threshold(kdu_subband *this)
{
  uint64_t v1 = **(void **)(*(void *)this + 8);
  uint64_t v2 = *(void *)(v1 + 64);
  if (v2)
  {
    int v3 = 16 * *(_DWORD *)(v2 + 32816);
    BOOL v4 = __OFSUB__(v3, 1);
    int v5 = v3 - 1;
    if ((v5 < 0) ^ v4 | (v5 == 0)) {
      LOWORD(v5) = 1;
    }
  }
  else
  {
    LOWORD(v5) = 1;
  }
  unsigned int v6 = *(unsigned __int16 *)(v1 + 464);
  if (v6 <= (unsigned __int16)v5) {
    return (unsigned __int16)v5;
  }
  else {
    return v6;
  }
}

uint64_t kd_precinct::initialize(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  int v7 = *((_DWORD *)a2 + 47) + HIDWORD(a3);
  uint64_t v8 = *(void *)(v5 + 8);
  int v9 = *((_DWORD *)a2 + 46) + a3;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 13) = 0;
  *(_WORD *)(a1 + 21) = 1;
  if (*(void *)(v6 + 8))
  {
    if (!*(unsigned char *)(v6 + 417))
    {
      if (*(_DWORD *)(v5 + 72) < (int)*((unsigned __int8 *)a2 + 24)
        || !*(unsigned char *)(v5 + 184)
        || (int v10 = *((_DWORD *)a2 + 51), v7 < v10)
        || (int v11 = *((_DWORD *)a2 + 50), v9 < v11)
        || v7 >= *((_DWORD *)a2 + 53) + v10
        || v9 >= *((_DWORD *)a2 + 52) + v11)
      {
        *(unsigned char *)(a1 + 21) = 0;
      }
    }
  }
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(v8 + 196);
  *(void *)(a1 + 36) = 0;
  *(void *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 44) = 0;
  *(_OWORD *)((char *)a2 + 100) = *(_OWORD *)(a2 + 21);
  int v12 = *((_DWORD *)a2 + 26) + *((_DWORD *)a2 + 28) * v7;
  *((_DWORD *)a2 + 25) += *((_DWORD *)a2 + 27) * v9;
  *((_DWORD *)a2 + 26) = v12;
  uint64_t result = kdu_dims::operator&=((_DWORD *)a2 + 25, (int *)a2 + 12);
  if (*((int *)a2 + 28) < 1 || *((int *)a2 + 27) <= 0)
  {
    uint64_t v62 = 0;
    memset(v61, 0, sizeof(v61));
    kdu_error::kdu_error((kdu_error *)v61, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v61[0] + 16))(v61, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v61[0] + 16))(v61, "(resolution->node.prec_dims.size.x > 0) && (resolution->node.prec_dims.size.y > 0)");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v61[0] + 16))(v61, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v61);
  }
  uint64_t v57 = v8;
  BOOL v14 = *(unsigned char *)(v6 + 417) && !*(unsigned char *)(v8 + 289)
     || *(_DWORD *)(v5 + 72) < (int)*((unsigned __int8 *)a2 + 24)
     || *(unsigned char *)(v5 + 184) == 0;
  *(void *)(a1 + 48) = a1 + 80;
  uint64_t v15 = *((unsigned __int8 *)a2 + 222);
  uint64_t v60 = a1 + 80 + 32 * v15;
  if (*((unsigned char *)a2 + 223))
  {
    uint64_t v16 = 0;
    unint64_t v17 = 0;
    do
    {
      uint64_t v18 = a2[28] + v16;
      LODWORD(v19) = *(_DWORD *)(*(void *)v18 + 68);
      LODWORD(v20) = *(_DWORD *)(*(void *)v18 + 72);
      unsigned int v21 = *(unsigned __int8 *)(v18 + 48);
      unsigned int v22 = *(unsigned __int8 *)(v18 + 49);
      int v23 = *(_DWORD *)(*(void *)v18 + 80) + v20;
      int v24 = *(_DWORD *)(*(void *)v18 + 76) + v19;
      uint64_t result = ((int)(v23 - v21 + 1) >> 1);
      if (v21 <= 1) {
        uint64_t v20 = ((int)(v20 - v21 + 1) >> 1);
      }
      else {
        uint64_t v20 = v20;
      }
      if (v21 <= 1) {
        int v23 = (int)(v23 - v21 + 1) >> 1;
      }
      if (v22 <= 1) {
        uint64_t v19 = ((int)(v19 - v22 + 1) >> 1);
      }
      else {
        uint64_t v19 = v19;
      }
      if (v22 <= 1) {
        int v24 = (int)(v24 - v22 + 1) >> 1;
      }
      *(void *)(v18 + 68) = v19 | (v20 << 32);
      *(void *)(v18 + 76) = (v24 - v19) | ((unint64_t)(v23 - v20) << 32);
      ++v17;
      v16 += 136;
    }
    while (v17 < *((unsigned __int8 *)a2 + 223));
    LODWORD(v15) = *((unsigned __int8 *)a2 + 222);
  }
  if (v15)
  {
    uint64_t v25 = 0;
    do
    {
      uint64_t v26 = *(void *)(a1 + 48);
      uint64_t v27 = a2[30];
      uint64_t v28 = (unsigned __int8 *)(v27 + 144 * v25);
      *(void *)(v26 + 32 * v25) = v28;
      LODWORD(v29) = *(_DWORD *)(*(void *)v28 + 68);
      LODWORD(v30) = *(_DWORD *)(*(void *)v28 + 72);
      unsigned int v31 = v28[48];
      unsigned int v32 = v28[49];
      int v33 = *(_DWORD *)(*(void *)v28 + 76) + v29;
      if (v31 <= 1) {
        uint64_t v30 = ((int)(v30 - v31 + 1) >> 1);
      }
      else {
        uint64_t v30 = v30;
      }
      if (v32 <= 1) {
        uint64_t v29 = ((int)(v29 - v32 + 1) >> 1);
      }
      else {
        uint64_t v29 = v29;
      }
      if (v32 <= 1) {
        int v33 = (int)(v33 - v32 + 1) >> 1;
      }
      uint64_t v34 = v27 + 144 * v25;
      unint64_t partition_indices = get_partition_indices(*(void *)(v34 + 76), *(void *)(v34 + 84), v29 | (v30 << 32), v33 - (int)v29);
      uint64_t v58 = v25;
      uint64_t v36 = v26 + 32 * v25;
      *(void *)(v36 + 16) = v37;
      uint64_t v38 = v36 + 16;
      *(void *)(v38 - 8) = partition_indices;
      uint64_t result = (uint64_t)kd_block::build_tree(v37, (void **)&v60, *(int *)(*(void *)(a1 + 72) + 24) + a1 - v60);
      *(void *)(v38 + 8) = result;
      v61[0] = 0uLL;
      v61[0] = *(_OWORD *)(v34 + 76);
      int v39 = DWORD2(v61[0]);
      int v59 = DWORD1(v61[0]) + *(_DWORD *)(v38 - 4) * HIDWORD(v61[0]);
      int v40 = LODWORD(v61[0]) + *(_DWORD *)(v38 - 8) * DWORD2(v61[0]);
      uint64_t v41 = *(void *)(v38 + 8);
      if (*(void *)(v6 + 8))
      {
        LODWORD(v61[0]) += *(_DWORD *)(v38 - 8) * DWORD2(v61[0]);
        int v42 = *(_DWORD *)v38;
        if (*(int *)v38 >= 1)
        {
          int v43 = 0;
          uint64_t v44 = v26 + 32 * v58;
          int v47 = *(_DWORD *)(v44 + 20);
          long long v46 = (int *)(v44 + 20);
          int v45 = v47;
          uint64_t v48 = v28 + 32;
          do
          {
            DWORD1(v61[0]) = v59;
            if (v45 >= 1)
            {
              int v49 = 0;
              do
              {
                unsigned int v50 = *(_DWORD *)(a2[1] + 172);
                if (v50 >= 0x100) {
                  kd_precinct::initialize();
                }
                *(unsigned char *)(v41 + 25) = v50;
                if (v14 || (uint64_t result = kdu_dims::intersects(v61, v48), (result & 1) == 0))
                {
                  if (!*(unsigned char *)(v6 + 417)) {
                    *(unsigned char *)(v41 + 18) = -1;
                  }
                }
                else
                {
                  ++*(_DWORD *)(a1 + 36);
                }
                ++v49;
                DWORD1(v61[0]) += HIDWORD(v61[0]);
                v41 += 40;
                int v45 = *v46;
              }
              while (v49 < *v46);
              int v39 = DWORD2(v61[0]);
              int v40 = v61[0];
              int v42 = *(_DWORD *)v38;
            }
            ++v43;
            v40 += v39;
            LODWORD(v61[0]) = v40;
          }
          while (v43 < v42);
        }
      }
      else
      {
        int v51 = *(_DWORD *)v38;
        if (*(int *)v38 >= 1)
        {
          int v52 = 0;
          int v53 = *(_DWORD *)(v26 + 32 * v25 + 20);
          do
          {
            if (v53 >= 1)
            {
              unsigned int v54 = *(_DWORD *)(a2[1] + 172);
              if (v54 > 0xFF)
              {
                *(void *)&v61[0] = __PAIR64__(v59, v40);
                __assert_rtn("set_modes", "compressed_local.h", 3522, "modes == (modes & 0xFF)");
              }
              int v55 = *(_DWORD *)(a1 + 36);
              int v56 = v53;
              do
              {
                *(unsigned char *)(v41 + 25) = v54;
                v41 += 40;
                --v56;
              }
              while (v56);
              *(_DWORD *)(a1 + 36) = v53 + v55;
            }
            ++v52;
            v40 += v39;
          }
          while (v52 != v51);
        }
      }
      uint64_t v25 = v58 + 1;
    }
    while (v58 + 1 < (unint64_t)*((unsigned __int8 *)a2 + 222));
  }
  if (!*(_DWORD *)(a1 + 36) && *(void *)(v6 + 8)) {
    *(unsigned char *)(a1 + 19) = 1;
  }
  if (*(unsigned char *)(v57 + 287)) {
    *(_DWORD *)(a1 + 32) = -1;
  }
  return result;
}

void sub_18864C524(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18864C530()
{
  _Unwind_Resume(v0);
}

unsigned __int8 **kd_precinct::closing(unsigned __int8 **this)
{
  uint64_t v1 = this;
  if (this[1])
  {
    uint64_t v12 = 0;
    memset(v11, 0, sizeof(v11));
    kdu_error::kdu_error((kdu_error *)v11, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v11[0] + 16))(v11, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v11[0] + 16))(v11, "ref == NULL");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v11[0] + 16))(v11, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v11);
  }
  uint64_t v2 = *this;
  if ((*this)[222])
  {
    unint64_t v3 = 0;
    BOOL v4 = *(kd_buf_server **)(*(void *)v2 + 48);
    do
    {
      uint64_t v5 = (uint64_t)&v1[6][32 * v3];
      uint64_t v7 = *(void *)(v5 + 24);
      uint64_t v6 = (void *)(v5 + 24);
      if (v7)
      {
        int v8 = *(_DWORD *)&v1[6][32 * v3 + 16] * *(_DWORD *)&v1[6][32 * v3 + 20];
        if (v8 >= 1)
        {
          uint64_t v9 = 0;
          uint64_t v10 = 40 * v8;
          do
          {
            this = (unsigned __int8 **)kd_block::cleanup(*v6 + v9, v4);
            v9 += 40;
          }
          while (v10 != v9);
          uint64_t v2 = *v1;
        }
        *uint64_t v6 = 0;
      }
      ++v3;
    }
    while (v3 < v2[222]);
  }
  if (!*((unsigned char *)v1 + 18))
  {
    this = (unsigned __int8 **)v1[5];
    if (this)
    {
      this = (unsigned __int8 **)MEMORY[0x18C11C0C0](this, 0x1000C8000313F17);
      v1[5] = 0;
    }
  }
  return this;
}

void sub_18864C6E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18864C6F0()
{
  _Unwind_Resume(v0);
}

uint64_t kd_precinct::activate(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void *)(*(void *)this + 8);
  uint64_t v4 = *(void *)(v3 + 8);
  if (!*(unsigned char *)(this + 19) || *(_DWORD *)(this + 36) || !*(unsigned char *)(v4 + 289))
  {
    uint64_t v22 = 0;
    memset(v21, 0, sizeof(v21));
    kdu_error::kdu_error((kdu_error *)v21, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v21[0] + 16))(v21, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v21[0] + 16))(v21, "released && (num_outstanding_blocks == 0) && tile->is_open");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v21[0] + 16))(v21, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v21);
  }
  *(unsigned char *)(this + 19) = 0;
  *(_DWORD *)(this + 24) = *(_DWORD *)(v4 + 196);
  if (*(_DWORD *)(v3 + 72) >= (int)*(unsigned __int8 *)(v2 + 24) && *(unsigned char *)(v3 + 184) && *(unsigned char *)(v2 + 222))
  {
    unint64_t v5 = 0;
    do
    {
      uint64_t v6 = *(void *)(v1 + 48);
      uint64_t v7 = *(void *)(v2 + 240);
      v21[0] = 0uLL;
      v21[0] = *(_OWORD *)(v7 + 144 * v5 + 76);
      int v8 = (_DWORD *)(v6 + 32 * v5);
      uint64_t v10 = v8 + 4;
      int v9 = v8[4];
      int v11 = DWORD2(v21[0]);
      int v12 = v8[3];
      int v13 = LODWORD(v21[0]) + v8[2] * DWORD2(v21[0]);
      LODWORD(v21[0]) = v13;
      if (v9 >= 1)
      {
        int v14 = 0;
        int v15 = DWORD1(v21[0]) + v12 * HIDWORD(v21[0]);
        int v18 = v8[5];
        unint64_t v17 = v8 + 5;
        int v16 = v18;
        uint64_t v19 = (_DWORD *)(v7 + 144 * v5 + 32);
        do
        {
          DWORD1(v21[0]) = v15;
          if (v16 >= 1)
          {
            int v20 = 0;
            do
            {
              this = kdu_dims::intersects(v21, v19);
              if (this) {
                ++*(_DWORD *)(v1 + 36);
              }
              ++v20;
              DWORD1(v21[0]) += HIDWORD(v21[0]);
              int v16 = *v17;
            }
            while (v20 < *v17);
            int v11 = DWORD2(v21[0]);
            int v13 = v21[0];
            int v9 = *v10;
          }
          ++v14;
          v13 += v11;
          LODWORD(v21[0]) = v13;
        }
        while (v14 < v9);
        uint64_t v2 = *(void *)v1;
      }
      ++v5;
    }
    while (v5 < *(unsigned __int8 *)(v2 + 222));
  }
  return this;
}

void sub_18864C934(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18864C940()
{
  _Unwind_Resume(v0);
}

uint64_t kd_precinct::read_packet(uint64_t **this)
{
  int v2 = *((_DWORD *)this + 8);
  if (v2 < 0)
  {
    if (!*((unsigned char *)this + 18))
    {
      uint64_t v50 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "Assert ");
      (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "addressable");
      (*(void (**)(long long *, const char *))(v48 + 16))(&v48, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v48);
    }
    return 0;
  }
  uint64_t v3 = **this;
  uint64_t v4 = *(void *)((*this)[1] + 8);
  if (v2 >= *(_DWORD *)(v4 + 192))
  {
    uint64_t v50 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "Assert ");
    (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "num_packets_read < tile->num_layers");
    (*(void (**)(long long *, const char *))(v48 + 16))(&v48, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v48);
  }
  if (!*((unsigned char *)this + 18) && v4 != *(void *)(v3 + 440))
  {
    uint64_t v50 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "Assert ");
    (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "addressable || (tile == codestream->active_tile)");
    (*(void (**)(long long *, const char *))(v48 + 16))(&v48, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v48);
  }
  uint64_t v5 = *(void *)((*this)[1] + 8);
  int v6 = *(unsigned __int8 *)(v5 + 284);
  int v7 = *(unsigned char *)(v5 + 284) && *(unsigned char *)(v3 + 413) && *(unsigned char *)(v3 + 412) != 0;
  if (*((unsigned char *)this + 16)) {
    return kd_precinct::handle_corrupt_packet((kd_precinct *)this);
  }
  int v9 = *(unsigned __int8 *)(v5 + 285);
  if (!*(unsigned char *)(v4 + 316)) {
    goto LABEL_25;
  }
  unsigned int v10 = *(_DWORD *)(v4 + 320);
  if (v10 >= 0x10000)
  {
    uint64_t v50 = 0;
    long long v48 = 0u;
    long long v49 = 0u;
    kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "Assert ");
    (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "(sop_num >= 0) && (sop_num < (1<<16))");
    (*(void (**)(long long *, const char *))(v48 + 16))(&v48, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v48);
  }
  if ((_WORD)v10 != (unsigned __int16)*(_DWORD *)(v4 + 312)) {
    return kd_precinct::handle_corrupt_packet((kd_precinct *)this);
  }
  if (*(unsigned char *)(v4 + 316))
  {
    unsigned int v11 = *(_DWORD *)(v4 + 320);
    if (v11 >= 0x10000)
    {
      uint64_t v50 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "Assert ");
      (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "(sop_num >= 0) && (sop_num < (1<<16))");
      (*(void (**)(long long *, const char *))(v48 + 16))(&v48, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v48);
    }
    if ((_WORD)v11 != (unsigned __int16)*(_DWORD *)(v4 + 312))
    {
      uint64_t v50 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "Assert ");
      (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "compare_sop_num(tile->next_sop_sequence_num, tile->next_input_packet_num) == 0");
      (*(void (**)(long long *, const char *))(v48 + 16))(&v48, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v48);
    }
    *(unsigned char *)(v4 + 316) = 0;
  }
  else
  {
LABEL_25:
    uint64_t v12 = *(void *)(v3 + 32);
    while (kd_marker::read((kd_marker *)v12, 1, v7))
    {
      uint64_t v12 = *(void *)(v3 + 32);
      int v13 = *(unsigned __int16 *)(v12 + 16);
      if (v13 == 65424)
      {
        if (*(unsigned char *)(*(void *)(v3 + 8) + 544)) {
          goto LABEL_37;
        }
        *(void *)(v3 + 440) = 0;
        kd_tile::adjust_unloadability((uint64_t *)v4);
        return 0;
      }
      if (v6 && v13 == 65425)
      {
        if (*((unsigned char *)this + 18)) {
          break;
        }
        unsigned int v27 = __rev16(**(unsigned __int16 **)(v12 + 32));
        if (!compare_sop_num(v27, *(_DWORD *)(v4 + 312))) {
          break;
        }
        if (!*(unsigned char *)(v3 + 412))
        {
          uint64_t v50 = 0;
          long long v48 = 0u;
          long long v49 = 0u;
          kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "Out-of-sequence SOP marker found while attempting to read a packet from the code-stream!\n");
          (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "\tFound sequence number ");
          uint64_t v41 = kdu_message::operator<<(&v48);
          (*(void (**)(unsigned char *, const char *))(*(void *)v41 + 16))(v41, ", but expected ");
          int v42 = kdu_message::operator<<(v41);
          (*(void (**)(unsigned char *, const char *))(*(void *)v42 + 16))(v42, ".\n");
          (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "Use the resilient option if you would like to try to recover from this error.");
          kdu_error::~kdu_error((kdu_error *)&v48);
        }
        *(unsigned char *)(v4 + 316) = 1;
        *(_DWORD *)(v4 + 320) = v27;
        return kd_precinct::handle_corrupt_packet((kd_precinct *)this);
      }
      if ((v7 & 1) == 0)
      {
        if (!*(unsigned char *)(v3 + 412))
        {
          uint64_t v50 = 0;
          long long v48 = 0u;
          long long v49 = 0u;
          kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "Illegal marker code found while attempting to read a packet from the code-stream!\n");
          (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "\tIllegal marker code is ");
          print_marker_code(*(unsigned __int16 *)(*(void *)(v3 + 32) + 16), (kdu_message *)&v48);
          (*(void (**)(long long *, const char *))(v48 + 16))(&v48, ".\n");
          (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "Use the resilient option if you would like to try to recover from this error.");
          kdu_error::~kdu_error((kdu_error *)&v48);
        }
        return kd_precinct::handle_corrupt_packet((kd_precinct *)this);
      }
    }
  }
  uint64_t v14 = *(void *)(v3 + 8);
  if (*(unsigned char *)(v14 + 544))
  {
LABEL_37:
    kd_tile::finished_reading((kd_tile *)v4);
    if (!*((_DWORD *)this + 8) && *((unsigned char *)this + 18))
    {
      uint64_t v8 = 0;
      *((_DWORD *)this + 8) = -1;
      return v8;
    }
    return 0;
  }
  if (*(unsigned char *)(v3 + 416) && (*((_DWORD *)this + 8) >= *((_DWORD *)this + 6) || !*((unsigned char *)this + 21)))
  {
    int v45 = 1;
    kd_compressed_input::set_suspend(v14, 1);
  }
  else
  {
    int v45 = 0;
  }
  uint64_t v16 = *(void *)(v4 + 88);
  if (!v16) {
    uint64_t v16 = *(void *)(v3 + 8);
  }
  char v17 = 0;
  v47[0] = v16;
  v47[1] = 0;
  if (!*(unsigned char *)(v3 + 412))
  {
    if (!*(unsigned char *)(v3 + 414)) {
      goto LABEL_53;
    }
    char v17 = 1;
  }
  *(unsigned char *)(v16 + 547) = v17;
  *(_WORD *)(v16 + 545) = 1;
LABEL_53:
  int v44 = v9;
  if (kd_header_in::get_bit((kd_header_in *)v47) && (int v18 = *this, *((unsigned char *)*this + 222)))
  {
    unint64_t v19 = 0;
    uint64_t v20 = 0;
    do
    {
      uint64_t v21 = (uint64_t)&this[6][4 * v19];
      int v22 = *(_DWORD *)(v21 + 16);
      if (v22 >= 1)
      {
        int v23 = *(kd_block **)(v21 + 24);
        int v24 = (int *)(v21 + 20);
        do
        {
          if (*v24 >= 1)
          {
            int v25 = *v24 + 1;
            do
            {
              v20 += (int)kd_block::parse_packet_header(v23, (kd_header_in *)v47, *(kd_buf_server **)(v3 + 48), *((_DWORD *)this + 8));
              int v23 = (kd_block *)((char *)v23 + 40);
              --v25;
            }
            while (v25 > 1);
          }
          BOOL v26 = __OFSUB__(v22--, 1);
        }
        while (!((v22 < 0) ^ v26 | (v22 == 0)));
        int v18 = *this;
      }
      ++v19;
    }
    while (v19 < *((unsigned __int8 *)v18 + 222));
  }
  else
  {
    uint64_t v20 = 0;
  }
  kd_header_in::finish((uint64_t)v47);
  if (*(unsigned char *)(v16 + 545))
  {
    *(unsigned char *)(v16 + 545) = 0;
    if (*(unsigned char *)(v16 + 544))
    {
      *(unsigned char *)(v16 + 546) = 0;
    }
    else if (*(unsigned char *)(v16 + 546))
    {
      uint64_t v50 = 0;
      long long v48 = 0u;
      long long v49 = 0u;
      kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "Assert ");
      (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "0");
      (*(void (**)(long long *, const char *))(v48 + 16))(&v48, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v48);
    }
  }
  if (v44)
  {
    unsigned __int8 v46 = 0;
    if (kd_input::get((kd_input *)v16, &v46)) {
      int v28 = v46;
    }
    else {
      int v28 = 0;
    }
    if (kd_input::get((kd_input *)v16, &v46)) {
      int v28 = v46 | (v28 << 8);
    }
    if (*(unsigned char *)(v16 + 544))
    {
      if (v16 == *(void *)(v4 + 88))
      {
        uint64_t v50 = 0;
        long long v48 = 0u;
        long long v49 = 0u;
        kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "Exhausted PPM/PPT marker segment data while attempting to parse a packet header!");
        kdu_error::~kdu_error((kdu_error *)&v48);
      }
      if (!*(unsigned char *)(*(void *)(v3 + 8) + 544))
      {
        uint64_t v50 = 0;
        long long v48 = 0u;
        long long v49 = 0u;
        kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "Assert ");
        (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "codestream->in->failed()");
        (*(void (**)(long long *, const char *))(v48 + 16))(&v48, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v48);
      }
      kd_tile::finished_reading((kd_tile *)v4);
      if (!*((_DWORD *)this + 8) && *((unsigned char *)this + 18)) {
        *((_DWORD *)this + 8) = -1;
      }
      if (v45) {
        kd_compressed_input::set_suspend(*(void *)(v3 + 8), 0);
      }
      return 0;
    }
    if (v28 != 65426)
    {
      if (!*(unsigned char *)(v3 + 412) || v16 != *(void *)(v3 + 8))
      {
        uint64_t v50 = 0;
        long long v48 = 0u;
        long long v49 = 0u;
        kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "Expected to find EPH marker following packet header.  Found ");
        print_marker_code(v28, (kdu_message *)&v48);
        (*(void (**)(long long *, const char *))(v48 + 16))(&v48, " instead.");
        kdu_error::~kdu_error((kdu_error *)&v48);
      }
      if (!v45) {
        return kd_precinct::handle_corrupt_packet((kd_precinct *)this);
      }
      uint64_t v40 = v16;
LABEL_127:
      kd_compressed_input::set_suspend(v40, 0);
      return kd_precinct::handle_corrupt_packet((kd_precinct *)this);
    }
  }
  if (v20 >= 1)
  {
    if (*(unsigned char *)(v3 + 412))
    {
      char v29 = 0;
    }
    else
    {
      if (!*(unsigned char *)(v3 + 414)) {
        goto LABEL_101;
      }
      char v29 = 1;
    }
    uint64_t v30 = *(void *)(v3 + 8);
    *(unsigned char *)(v30 + 547) = v29;
    *(_WORD *)(v30 + 545) = 1;
LABEL_101:
    unsigned int v31 = *this;
    if (*((unsigned char *)*this + 222))
    {
      unint64_t v32 = 0;
      do
      {
        uint64_t v33 = (uint64_t)&this[6][4 * v32];
        int v34 = *(_DWORD *)(v33 + 16);
        if (v34 >= 1)
        {
          uint64_t v35 = *(void *)(v33 + 24);
          uint64_t v36 = (int *)(v33 + 20);
          do
          {
            if (*v36 >= 1)
            {
              int v37 = *v36 + 1;
              do
              {
                uint64_t v38 = *(kd_input **)(v3 + 8);
                if (*((unsigned char *)v38 + 544))
                {
                  exception = __cxa_allocate_exception(4uLL);
                  _DWORD *exception = -1;
                  __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
                }
                kd_block::read_body_bytes(v35, v38, *(kd_buf_server **)(v3 + 48));
                v35 += 40;
                --v37;
              }
              while (v37 > 1);
            }
            BOOL v26 = __OFSUB__(v34--, 1);
          }
          while (!((v34 < 0) ^ v26 | (v34 == 0)));
          unsigned int v31 = *this;
        }
        ++v32;
      }
      while (v32 < *((unsigned __int8 *)v31 + 222));
    }
  }
  int v39 = *(unsigned char **)(v3 + 8);
  if (v39[545])
  {
    v39[545] = 0;
    if (v39[544])
    {
      v39[546] = 0;
    }
    else if (v39[546])
    {
      if (!*(unsigned char *)(v3 + 412))
      {
        uint64_t v50 = 0;
        long long v48 = 0u;
        long long v49 = 0u;
        kdu_error::kdu_error((kdu_error *)&v48, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v48 + 16))(&v48, "Packet body terminated with an FF!");
        kdu_error::~kdu_error((kdu_error *)&v48);
      }
      kd_input::putback((uint64_t)v39, 255);
      if (!v45) {
        return kd_precinct::handle_corrupt_packet((kd_precinct *)this);
      }
      uint64_t v40 = *(void *)(v3 + 8);
      goto LABEL_127;
    }
  }
  ++*((_DWORD *)this + 8);
  if (v45) {
    kd_compressed_input::set_suspend(*(void *)(v3 + 8), 0);
  }
  return 1;
}

void sub_18864D804(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18864D810(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, uint64_t a11, uint64_t a12, long long a13, long long a14, uint64_t a15)
{
  _Unwind_Resume(v15);
}

void sub_18864DE20()
{
}

void sub_18864DE34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18864DE40()
{
}

uint64_t compare_sop_num(unsigned int a1, int a2)
{
  if (a1 >= 0x10000)
  {
    uint64_t v6 = 0;
    memset(v5, 0, sizeof(v5));
    kdu_error::kdu_error((kdu_error *)v5, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, "(sop_num >= 0) && (sop_num < (1<<16))");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v5);
  }
  unsigned int v2 = a1 - a2;
  if ((_WORD)a1 == (_WORD)a2) {
    return 0;
  }
  if ((unsigned __int16)(a1 - a2) >= 0x8001u && (int)(a1 - a2) <= 0) {
    return v2 - 0x10000;
  }
  else {
    return v2;
  }
}

void sub_18864DFF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18864E000()
{
  _Unwind_Resume(v0);
}

uint64_t kd_precinct::handle_corrupt_packet(kd_precinct *this)
{
  if (*((unsigned char *)this + 18))
  {
    uint64_t v30 = 0;
    long long v28 = 0u;
    long long v29 = 0u;
    kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v28 + 16))(&v28, "Encountered a corrupted packet while using packet length information to access the compressed data source in a random access fashion.  To process corrupted code-streams in an error resilient manner, you must disable seeking on the compressed data source (i.e., force sequential access) as well as enabling the resilient parsing mode.");
    kdu_error::~kdu_error((kdu_error *)&v28);
  }
  uint64_t v1 = *(uint64_t **)(*(void *)(*(void *)this + 8) + 8);
  unsigned int v2 = (void *)*v1;
  int v3 = *(unsigned __int8 *)(*v1 + 413);
  *((unsigned char *)this + 16) = 1;
  BOOL v4 = v3 == 0;
  BOOL v5 = *((unsigned char *)v1 + 316) == 0;
  BOOL v6 = v3 == 0;
  while (!v5)
  {
    unsigned int v9 = *((_DWORD *)v1 + 80);
    int v10 = *((_DWORD *)v1 + 78);
    if (v9 >= 0x10000)
    {
      uint64_t v30 = 0;
      long long v28 = 0u;
      long long v29 = 0u;
      kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v28 + 16))(&v28, "Assert ");
      (*(void (**)(long long *, const char *))(v28 + 16))(&v28, "(sop_num >= 0) && (sop_num < (1<<16))");
      (*(void (**)(long long *, const char *))(v28 + 16))(&v28, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v28);
    }
LABEL_13:
    int v13 = v9 - v10;
    if ((_WORD)v9 == (_WORD)v10) {
      goto LABEL_42;
    }
    if ((unsigned __int16)(v9 - v10) >= 0x8001u && v13 <= 0) {
      v13 -= 0x10000;
    }
    if (v13 <= 0)
    {
LABEL_42:
      int v24 = 0;
      *((unsigned char *)v1 + 316) = 0;
      BOOL v6 = v4;
    }
    else
    {
      unsigned int v15 = *((_DWORD *)v1 + 80);
      int v16 = *((_DWORD *)v1 + 78);
      if (v15 >= 0x10000)
      {
        uint64_t v30 = 0;
        long long v28 = 0u;
        long long v29 = 0u;
        kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v28 + 16))(&v28, "Assert ");
        (*(void (**)(long long *, const char *))(v28 + 16))(&v28, "(sop_num >= 0) && (sop_num < (1<<16))");
        (*(void (**)(long long *, const char *))(v28 + 16))(&v28, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v28);
      }
      int v17 = v15 - v16;
      if ((_WORD)v15 == (_WORD)v16) {
        goto LABEL_31;
      }
      if ((unsigned __int16)(v15 - v16) >= 0x8001u && v17 <= 0) {
        v17 -= 0x10000;
      }
      if (v17 < 4 || v6)
      {
LABEL_31:
        unsigned int v19 = *((_DWORD *)v1 + 80);
        int v20 = *((_DWORD *)v1 + 51);
        int v21 = *((_DWORD *)v1 + 48);
        if (v19 >= 0x10000)
        {
          uint64_t v30 = 0;
          long long v28 = 0u;
          long long v29 = 0u;
          kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v28 + 16))(&v28, "Assert ");
          (*(void (**)(long long *, const char *))(v28 + 16))(&v28, "(sop_num >= 0) && (sop_num < (1<<16))");
          (*(void (**)(long long *, const char *))(v28 + 16))(&v28, " FAILED");
          kdu_error::~kdu_error((kdu_error *)&v28);
        }
        signed int v22 = v19 - v21 * v20;
        if ((_WORD)v19 == (_WORD)v21 * (_WORD)v20) {
          goto LABEL_41;
        }
        if ((unsigned __int16)(v19 - v21 * v20) >= 0x8001u && v22 <= 0) {
          v22 -= 0x10000;
        }
        if (v22 < 0)
        {
          int v24 = *((unsigned __int8 *)v1 + 316);
        }
        else
        {
LABEL_41:
          int v24 = 0;
          *((unsigned char *)v1 + 316) = 0;
          BOOL v6 = v4;
        }
      }
      else
      {
        int v24 = 0;
        *((unsigned char *)v1 + 316) = 0;
        BOOL v6 = 1;
      }
    }
    BOOL v5 = 1;
    if (v24)
    {
      int v25 = *((_DWORD *)this + 8);
      if (v25 >= *((_DWORD *)v1 + 48))
      {
        uint64_t v30 = 0;
        long long v28 = 0u;
        long long v29 = 0u;
        kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v28 + 16))(&v28, "Assert ");
        (*(void (**)(long long *, const char *))(v28 + 16))(&v28, "num_packets_read < tile->num_layers");
        (*(void (**)(long long *, const char *))(v28 + 16))(&v28, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v28);
      }
      *((_DWORD *)this + 8) = v25 + 1;
      return 1;
    }
  }
  uint64_t v7 = v2[4];
  while ((kd_marker::read((kd_marker *)v7, 1, 1) & 1) != 0)
  {
    uint64_t v7 = v2[4];
    int v8 = *(unsigned __int16 *)(v7 + 16);
    if (v8 == 65425)
    {
      unsigned int v11 = *(unsigned __int8 **)(v7 + 32);
      int v12 = *v11;
      *((_DWORD *)v1 + 80) = v12 << 8;
      unsigned int v9 = v11[1] | (v12 << 8);
      *((_DWORD *)v1 + 80) = v9;
      *((unsigned char *)v1 + 316) = 1;
      int v10 = *((_DWORD *)v1 + 78);
      goto LABEL_13;
    }
    if (v8 == 65424)
    {
      v2[55] = 0;
      kd_tile::adjust_unloadability(v1);
      return 0;
    }
  }
  if (!*(unsigned char *)(v2[1] + 544))
  {
    uint64_t v30 = 0;
    long long v28 = 0u;
    long long v29 = 0u;
    kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v28 + 16))(&v28, "Assert ");
    (*(void (**)(long long *, const char *))(v28 + 16))(&v28, "codestream->in->failed()");
    (*(void (**)(long long *, const char *))(v28 + 16))(&v28, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v28);
  }
  kd_tile::finished_reading((kd_tile *)v1);
  return 0;
}

void sub_18864E634(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18864E640(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

uint64_t kd_compressed_input::set_suspend(uint64_t this, int a2)
{
  if (!*(unsigned char *)(this + 608))
  {
    uint64_t v2 = *(void *)(this + 592);
    if (v2) {
      BOOL v3 = 1;
    }
    else {
      BOOL v3 = a2 == 0;
    }
    if (v3)
    {
      if (v2)
      {
        if ((a2 & 1) == 0)
        {
          unint64_t v4 = *(void *)(this + 528);
          uint64_t v5 = v4 - v2 + *(void *)(this + 584);
          *(void *)(this + 584) = v5;
          *(void *)(this + 592) = 0;
          uint64_t v6 = *(void *)(this + 568) + v5 - *(void *)(this + 560);
          uint64_t v7 = *(void *)(this + 536);
          uint64_t v8 = v7 - this - 14;
          BOOL v9 = v6 < v8;
          uint64_t v10 = v6 - v8;
          if (v9)
          {
            *(void *)(this + 600) = v7;
            unint64_t v11 = v7 + v10;
            *(void *)(this + 536) = v11;
            if (v11 < v4)
            {
              *(unsigned char *)(this + 544) = 1;
              *(void *)(this + 584) = v5 - v4 + v11;
              *(void *)(this + 536) = v4;
            }
          }
        }
      }
    }
    else
    {
      *(void *)(this + 592) = *(void *)(this + 528);
      unint64_t v12 = *(void *)(this + 600);
      if (v12)
      {
        if (v12 <= *(void *)(this + 536)) {
          kd_compressed_input::set_suspend();
        }
        *(void *)(this + 536) = v12;
        *(void *)(this + 600) = 0;
      }
    }
  }
  return this;
}

uint64_t kd_header_in::get_bit(kd_header_in *this)
{
  int v2 = *((_DWORD *)this + 3);
  if (!v2)
  {
    if (*((unsigned __int8 *)this + 8) == 255) {
      int v3 = 7;
    }
    else {
      int v3 = 8;
    }
    *((_DWORD *)this + 3) = v3;
    if (!kd_input::get(*(kd_input **)this, (unsigned __int8 *)this + 8))
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = this;
    }
    int v2 = *((_DWORD *)this + 3);
  }
  int v4 = v2 - 1;
  *((_DWORD *)this + 3) = v4;
  return (*((unsigned __int8 *)this + 8) >> v4) & 1;
}

uint64_t kd_header_in::finish(uint64_t this)
{
  if (!*(_DWORD *)(this + 12))
  {
    uint64_t v1 = this;
    if (*(unsigned __int8 *)(this + 8) == 255)
    {
      *(_DWORD *)(this + 12) = 7;
      this = kd_input::get(*(kd_input **)this, (unsigned __int8 *)(this + 8));
      if ((this & 1) == 0)
      {
        exception = __cxa_allocate_exception(8uLL);
        void *exception = v1;
      }
    }
  }
  return this;
}

uint64_t kd_input::get(kd_input *this, unsigned __int8 *a2)
{
  if (*((unsigned char *)this + 544)) {
    return 0;
  }
  uint64_t v5 = (unsigned __int8 *)*((void *)this + 66);
  if (v5 == *((unsigned __int8 **)this + 67))
  {
    uint64_t result = (*(uint64_t (**)(kd_input *))(*(void *)this + 24))(this);
    if (!result) {
      return result;
    }
    uint64_t v5 = (unsigned __int8 *)*((void *)this + 66);
  }
  *((void *)this + 66) = v5 + 1;
  unsigned int v6 = *v5;
  *a2 = v6;
  if (*((unsigned char *)this + 545))
  {
    if (*((unsigned char *)this + 546))
    {
      if (v6 >= 0x90)
      {
        kd_input::process_unexpected_marker((unsigned __int8 *)this, v6);
        unsigned int v6 = *a2;
      }
    }
    *((unsigned char *)this + 546) = v6 == 255;
  }
  return 1;
}

uint64_t kd_input::putback(uint64_t this, char a2)
{
  if (*(unsigned char *)(this + 544)) {
    kd_input::putback();
  }
  if (*(unsigned char *)(this + 545)) {
    kd_input::putback();
  }
  unint64_t v2 = *(void *)(this + 528);
  if (v2 <= this + 8) {
    kd_input::putback();
  }
  *(void *)(this + 528) = v2 - 1;
  *(unsigned char *)(v2 - 1) = a2;
  return this;
}

uint64_t kd_precinct::simulate_packet(kd_precinct *this, uint64_t *a2, int a3, unsigned int a4, int a5, char a6, uint64_t a7, int a8)
{
  uint64_t v10 = a2;
  int v12 = *((_DWORD *)this + 6);
  uint64_t v56 = *(void *)(*(void *)(*(void *)this + 8) + 8);
  if (v12 != *(_DWORD *)(v56 + 192))
  {
    uint64_t v65 = 0;
    long long v63 = 0u;
    long long v64 = 0u;
    kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v63 + 16))(&v63, "Assert ");
    (*(void (**)(long long *, const char *))(v63 + 16))(&v63, "required_layers == tile->num_layers");
    (*(void (**)(long long *, const char *))(v63 + 16))(&v63, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v63);
  }
  int v13 = *(kd_buf_server **)(**(void **)this + 48);
  if (v12 <= a3)
  {
    uint64_t v65 = 0;
    long long v63 = 0u;
    long long v64 = 0u;
    kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v63 + 16))(&v63, "Assert ");
    (*(void (**)(long long *, const char *))(v63 + 16))(&v63, "layer_idx < required_layers");
    (*(void (**)(long long *, const char *))(v63 + 16))(&v63, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v63);
  }
  if (*((_DWORD *)this + 9))
  {
    uint64_t v65 = 0;
    long long v63 = 0u;
    long long v64 = 0u;
    kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v63 + 16))(&v63, "You may not currently flush compressed code-stream data without completing the compression of all code-blocks in all precincts of all tiles.");
    kdu_error::~kdu_error((kdu_error *)&v63);
  }
  uint64_t v14 = *((void *)this + 5);
  if (!v14)
  {
    if (a3)
    {
      uint64_t v65 = 0;
      long long v63 = 0u;
      long long v64 = 0u;
      kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v63 + 16))(&v63, "Assert ");
      (*(void (**)(long long *, const char *))(v63 + 16))(&v63, "layer_idx == 0");
      (*(void (**)(long long *, const char *))(v63 + 16))(&v63, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v63);
    }
    operator new[]();
  }
  if (!a3)
  {
    uint64_t v15 = *((unsigned int *)this + 6);
    if ((int)v15 >= 1)
    {
      uint64_t v16 = 0;
      uint64_t v17 = 3;
      if (!*(unsigned char *)(v56 + 285)) {
        uint64_t v17 = 1;
      }
      uint64_t v18 = 8 * v15;
      do
      {
        *(void *)(*((void *)this + 5) + v16) = v17;
        v16 += 8;
      }
      while (v18 != v16);
      uint64_t v14 = *((void *)this + 5);
    }
  }
  *(void *)(v14 + 8 * a3) = 0;
  if (a8)
  {
    if (!a5 || (a6 & 1) == 0)
    {
      uint64_t v65 = 0;
      long long v63 = 0u;
      long long v64 = 0u;
      kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v63 + 16))(&v63, "Assert ");
      (*(void (**)(long long *, const char *))(v63 + 16))(&v63, "last_layer && finalize_layer");
      (*(void (**)(long long *, const char *))(v63 + 16))(&v63, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v63);
    }
    uint64_t v19 = *(void *)this;
    if (*(unsigned char *)(*(void *)this + 222))
    {
      unint64_t v20 = 0;
      do
      {
        uint64_t v21 = *((void *)this + 6) + 32 * v20;
        int v22 = *(_DWORD *)(v21 + 16) * *(_DWORD *)(v21 + 20);
        if (v22 >= 1)
        {
          uint64_t v23 = 0;
          int v24 = (void *)(v21 + 24);
          uint64_t v25 = 40 * v22;
          do
          {
            kd_block::trim_data((kd_block *)(*v24 + v23), a4, v13);
            v23 += 40;
          }
          while (v25 != v23);
          uint64_t v19 = *(void *)this;
        }
        ++v20;
      }
      while (v20 < *(unsigned __int8 *)(v19 + 222));
      uint64_t v57 = *(unsigned __int8 *)(v19 + 222);
    }
    else
    {
      uint64_t v57 = 0;
    }
  }
  else
  {
    uint64_t v57 = *(unsigned __int8 *)(*(void *)this + 222);
  }
  int v26 = 0;
  while (1)
  {
    uint64_t v27 = 7;
    if (!*(unsigned char *)(v56 + 284)) {
      uint64_t v27 = 1;
    }
    uint64_t *v10 = v27;
    if (*(unsigned char *)(v56 + 285)) {
      uint64_t *v10 = v27 + 2;
    }
    if (*(unsigned char *)(*(void *)this + 222)) {
      break;
    }
    uint64_t v29 = 0;
LABEL_58:
    v62[0] = 0x800000000;
    v62[1] = 0;
    v62[2] = 0;
    kd_header_out::put_bit((unsigned __int8 *)v62, 1u);
    uint64_t v42 = *(void *)this;
    if (*(unsigned char *)(*(void *)this + 222))
    {
      unint64_t v43 = 0;
      do
      {
        uint64_t v44 = *((void *)this + 6) + 32 * v43;
        int v45 = *(_DWORD *)(v44 + 16) * *(_DWORD *)(v44 + 20);
        if (v45 >= 1)
        {
          uint64_t v46 = 0;
          int v47 = (void *)(v44 + 24);
          uint64_t v48 = 40 * v45;
          do
          {
            kd_block::write_packet_header((unsigned __int8 *)(*v47 + v46), (kd_header_out *)v62, a3, 1);
            v46 += 40;
          }
          while (v48 != v46);
          uint64_t v42 = *(void *)this;
        }
        ++v43;
      }
      while (v43 < *(unsigned __int8 *)(v42 + 222));
    }
    uint64_t v10 = a2;
    uint64_t v49 = *a2 + (int)(kd_header_out::finish((kd_header_out *)v62) - 1);
    *a2 = v49;
    uint64_t result = v49 + v29;
    if (v49 + v29 > a7)
    {
      if (a5)
      {
        if (!a8)
        {
          uint64_t v65 = 0;
          long long v63 = 0u;
          long long v64 = 0u;
          kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v63 + 16))(&v63, "Assert ");
          (*(void (**)(long long *, const char *))(v63 + 16))(&v63, "trim_to_limit");
          (*(void (**)(long long *, const char *))(v63 + 16))(&v63, " FAILED");
          kdu_error::~kdu_error((kdu_error *)&v63);
        }
        uint64_t v50 = v57;
        while (1)
        {
          uint64_t v57 = v50;
          uint64_t v51 = (int)v50;
          while (1)
          {
            uint64_t v52 = *((void *)this + 6);
            if (!v26) {
              break;
            }
            if (kd_block::trim_data((kd_block *)(*(void *)(v52 + 32 * (int)v50 + 24) + 40 * --v26), (unsigned __int16)(a4 + 1), v13))goto LABEL_81; {
          }
            }
          if ((int)v50 <= 0)
          {
            uint64_t v65 = 0;
            long long v63 = 0u;
            long long v64 = 0u;
            kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v63 + 16))(&v63, "Assert ");
            (*(void (**)(long long *, const char *))(v63 + 16))(&v63, "last_trimmed_subband >= 0");
            (*(void (**)(long long *, const char *))(v63 + 16))(&v63, " FAILED");
            kdu_error::~kdu_error((kdu_error *)&v63);
          }
          uint64_t v50 = (v50 - 1);
          int v26 = *(_DWORD *)(v52 + 32 * v51 - 16) * *(_DWORD *)(v52 + 32 * v51 - 12);
        }
      }
      return result;
    }
    if (a5 && *(unsigned char *)(*(void *)this + 222))
    {
      uint64_t v53 = 0;
      unint64_t v54 = 0;
      do
      {
        kd_block::save_output_tree(*(void *)(*((void *)this + 6) + v53 + 24), *(void *)(*((void *)this + 6) + v53 + 16));
        ++v54;
        v53 += 32;
      }
      while (v54 < *(unsigned __int8 *)(*(void *)this + 222));
LABEL_81:
      uint64_t v10 = a2;
    }
    uint64_t v55 = *v10 + v29;
    if (v55 <= a7)
    {
      *(void *)(*((void *)this + 5) + 8 * a3) = v55;
      return *v10 + v29;
    }
  }
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  while (1)
  {
    uint64_t v30 = *((void *)this + 6);
    uint64_t v31 = v30 + 32 * v28;
    uint64_t v34 = *(void *)(v31 + 24);
    uint64_t v33 = (void *)(v31 + 24);
    uint64_t v32 = v34;
    unint64_t v35 = *(v33 - 1);
    if (a3) {
      kd_block::restore_output_tree(v32, v35);
    }
    else {
      kd_block::reset_output_tree(v32, v35);
    }
    int v36 = *((_DWORD *)v33 - 2) * *(_DWORD *)(v30 + 32 * v28 + 20);
    if (v36 >= 1)
    {
      uint64_t v37 = 0;
      uint64_t v38 = 40 * v36;
      do
      {
        v29 += (int)kd_block::start_packet((kd_block *)(*v33 + v37), a3, a4);
        v37 += 40;
      }
      while (v38 != v37);
    }
    uint64_t result = *a2 + v29;
    char v40 = a5 ^ 1;
    if (result <= a7) {
      char v40 = 1;
    }
    if ((v40 & 1) == 0 && (a8 & 1) == 0)
    {
      uint64_t v65 = 0;
      long long v63 = 0u;
      long long v64 = 0u;
      kdu_error::kdu_error((kdu_error *)&v63, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v63 + 16))(&v63, "Assert ");
      (*(void (**)(long long *, const char *))(v63 + 16))(&v63, "trim_to_limit");
      (*(void (**)(long long *, const char *))(v63 + 16))(&v63, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v63);
    }
    if (result > a7 && a5 == 0) {
      return result;
    }
    if (++v28 >= (unint64_t)*(unsigned __int8 *)(*(void *)this + 222)) {
      goto LABEL_58;
    }
  }
}

void sub_18864F350(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18864F35C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  _Unwind_Resume(v19);
}

unsigned __int8 *kd_header_out::put_bit(unsigned __int8 *this, unsigned int a2)
{
  if (a2 >= 2) {
    kd_header_out::put_bit();
  }
  char v2 = a2;
  int v3 = (char *)this;
  int v4 = *((_DWORD *)this + 1);
  if (v4)
  {
    char v5 = 2 * *this;
  }
  else
  {
    this = (unsigned __int8 *)*((void *)this + 2);
    if (this) {
      this = (unsigned __int8 *)kdu_output::put((kdu_output *)this, *v3);
    }
    char v5 = 0;
    ++*((_DWORD *)v3 + 2);
    if (*v3 == 255) {
      int v4 = 7;
    }
    else {
      int v4 = 8;
    }
  }
  char *v3 = v5 + v2;
  *((_DWORD *)v3 + 1) = v4 - 1;
  return this;
}

uint64_t kd_header_out::finish(kd_header_out *this)
{
  int v2 = *((_DWORD *)this + 1);
  if (v2 >= 8) {
    return *((unsigned int *)this + 2);
  }
  int v3 = *(unsigned __int8 *)this << v2;
  *(unsigned char *)this = v3;
  int v4 = (kdu_output *)*((void *)this + 2);
  if (v4)
  {
    kdu_output::put(v4, v3);
    LOBYTE(v3) = *(unsigned char *)this;
  }
  uint64_t result = (*((_DWORD *)this + 2) + 1);
  *((_DWORD *)this + 2) = result;
  if ((_BYTE)v3 == 0xFF)
  {
    if (*((void *)this + 2))
    {
      kdu_output::put(*((kdu_output **)this + 2), 0);
      LODWORD(result) = *((_DWORD *)this + 2);
    }
    uint64_t result = (result + 1);
    *((_DWORD *)this + 2) = result;
  }
  return result;
}

uint64_t *kd_precinct_ref::close(uint64_t *this)
{
  uint64_t v1 = *this;
  if (*this) {
    BOOL v2 = (*this & 1) == 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (v2)
  {
    int v3 = this;
    if (*(uint64_t **)(v1 + 8) != this)
    {
      uint64_t v6 = 0;
      memset(v5, 0, sizeof(v5));
      kdu_error::kdu_error((kdu_error *)v5, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, "Assert ");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, "precinct->ref == this");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v5);
    }
    *(void *)(v1 + 8) = 0;
    kd_precinct::closing((unsigned __int8 **)v1);
    if (*(unsigned char *)(v1 + 18)) {
      uint64_t v4 = (2 * *(void *)(v1 + 40)) | 1;
    }
    else {
      uint64_t v4 = 3;
    }
    uint64_t *v3 = v4;
    return (uint64_t *)kd_precinct_size_class::release(*(kd_precinct_size_class **)(v1 + 72), (kd_precinct *)v1);
  }
  return this;
}

void sub_18864F62C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18864F638()
{
  _Unwind_Resume(v0);
}

void *kd_precinct_size_class::augment_free_list(kd_precinct_size_class *this)
{
  int v2 = *((_DWORD *)this + 6);
  if (v2 < 0)
  {
    uint64_t v7 = 0;
    long long v5 = 0u;
    long long v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v5 + 16))(&v5, "Heap exhausted.  Unable to allocate memory for code-block state information.");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  uint64_t result = malloc_type_malloc(v2, 0x15484E2BuLL);
  if (!result)
  {
    uint64_t v7 = 0;
    long long v5 = 0u;
    long long v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v5 + 16))(&v5, "Heap exhausted.  Unable to allocate sufficient memory for code-block state information.");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  result[9] = this;
  result[7] = *((void *)this + 4);
  *((void *)this + 4) = result;
  uint64_t v4 = *((int *)this + 6);
  ++*((_DWORD *)this + 7);
  *(void *)(*(void *)this + 8) += v4;
  return result;
}

void sub_18864F778(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18864F784()
{
  _Unwind_Resume(v0);
}

uint64_t *kd_precinct_size_class::move_to_inactive_list(uint64_t *this, kd_precinct *a2)
{
  if (*((void *)a2 + 8) || *((void *)a2 + 7) || *((unsigned char *)a2 + 20))
  {
    uint64_t v6 = 0;
    memset(v5, 0, sizeof(v5));
    kdu_error::kdu_error((kdu_error *)v5, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, "Assert ");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, "(precinct->prev == NULL) && (precinct->next == NULL) && !precinct->inactive");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, " FAILED");
    kdu_error::~kdu_error((kdu_error *)v5);
  }
  *((unsigned char *)a2 + 20) = 1;
  uint64_t v2 = *this;
  uint64_t v3 = *(void *)(*this + 24);
  *((void *)a2 + 8) = v3;
  if (v3) {
    uint64_t v4 = (void *)(v3 + 56);
  }
  else {
    uint64_t v4 = (void *)(v2 + 16);
  }
  void *v4 = a2;
  *(void *)(v2 + 24) = a2;
  return this;
}

void sub_18864F8D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18864F8E0()
{
  _Unwind_Resume(v0);
}

uint64_t kd_precinct_size_class::withdraw_from_inactive_list(uint64_t this, kd_precinct *a2)
{
  if (!*((unsigned char *)a2 + 20))
  {
    uint64_t v6 = 0;
    long long v4 = 0u;
    long long v5 = 0u;
    kdu_error::kdu_error((kdu_error *)&v4, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v4 + 16))(&v4, "Assert ");
    (*(void (**)(long long *, const char *))(v4 + 16))(&v4, "precinct->inactive");
    (*(void (**)(long long *, const char *))(v4 + 16))(&v4, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v4);
  }
  uint64_t v2 = *((void *)a2 + 8);
  if (v2)
  {
    *(void *)(v2 + 56) = *((void *)a2 + 7);
    uint64_t v3 = *((void *)a2 + 7);
    if (v3)
    {
LABEL_5:
      *(void *)(v3 + 64) = *((void *)a2 + 8);
      goto LABEL_12;
    }
  }
  else
  {
    if (*(kd_precinct **)(*(void *)this + 16) != a2)
    {
      uint64_t v6 = 0;
      long long v4 = 0u;
      long long v5 = 0u;
      kdu_error::kdu_error((kdu_error *)&v4, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v4 + 16))(&v4, "Assert ");
      (*(void (**)(long long *, const char *))(v4 + 16))(&v4, "precinct == server->inactive_head");
      (*(void (**)(long long *, const char *))(v4 + 16))(&v4, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v4);
    }
    uint64_t v3 = *((void *)a2 + 7);
    *(void *)(*(void *)this + 16) = v3;
    if (v3) {
      goto LABEL_5;
    }
  }
  if (*(kd_precinct **)(*(void *)this + 24) != a2)
  {
    uint64_t v6 = 0;
    long long v4 = 0u;
    long long v5 = 0u;
    kdu_error::kdu_error((kdu_error *)&v4, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v4 + 16))(&v4, "Assert ");
    (*(void (**)(long long *, const char *))(v4 + 16))(&v4, "precinct == server->inactive_tail");
    (*(void (**)(long long *, const char *))(v4 + 16))(&v4, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v4);
  }
  *(void *)(*(void *)this + 24) = *((void *)a2 + 8);
LABEL_12:
  *((unsigned char *)a2 + 20) = 0;
  *((void *)a2 + 7) = 0;
  *((void *)a2 + 8) = 0;
  return this;
}

void sub_18864FBC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18864FBD0()
{
  _Unwind_Resume(v0);
}

uint64_t kd_precinct_server::get(kd_precinct_server *this, int a2, int a3)
{
  uint64_t v4 = *(void *)this;
  if (!*(void *)this) {
LABEL_5:
  }
    operator new();
  while (*(_DWORD *)(v4 + 16) != a2 || *(_DWORD *)(v4 + 20) != a3)
  {
    uint64_t v4 = *(void *)(v4 + 40);
    if (!v4) {
      goto LABEL_5;
    }
  }
  for (uint64_t i = *((void *)this + 2); i; uint64_t i = *((void *)this + 2))
  {
    if (*(void *)(*((void *)this + 4) + 56) >= *(void *)(*((void *)this + 4) + 40)
                                                    + 220 * *(void *)(*((void *)this + 4) + 24))
      break;
    if (!*(unsigned char *)(i + 19) || !*(unsigned char *)(i + 20))
    {
      uint64_t v8 = 0;
      memset(v7, 0, sizeof(v7));
      kdu_error::kdu_error((kdu_error *)v7, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v7[0] + 16))(v7, "Assert ");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v7[0] + 16))(v7, "tmp->released && tmp->inactive");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v7[0] + 16))(v7, " FAILED");
      kdu_error::~kdu_error((kdu_error *)v7);
    }
    kd_precinct_ref::close(*(uint64_t **)(i + 8));
  }
  return kd_precinct_size_class::get((kd_precinct_size_class *)v4);
}

void sub_18864FDDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18864FDE8()
{
  _Unwind_Resume(v0);
}

uint64_t kd_precinct_size_class::get(kd_precinct_size_class *this)
{
  uint64_t v2 = *((void *)this + 4);
  if (!v2)
  {
    kd_precinct_size_class::augment_free_list(this);
    uint64_t v2 = *((void *)this + 4);
  }
  *((void *)this + 4) = *(void *)(v2 + 56);
  *(void *)(v2 + 56) = 0;
  *(void *)(v2 + 64) = 0;
  kd_buf_server::augment_structure_bytes(*((void *)this + 1), *((_DWORD *)this + 6));
  return v2;
}

uint64_t kd_precinct_ref::instantiate_precinct(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = kd_precinct_server::get(*(kd_precinct_server **)(*(void *)a2 + 80), *(_DWORD *)(a2 + 216), *(unsigned __int8 *)(a2 + 222));
  kd_precinct::initialize(v6, (uint64_t *)a2, a3);
  *(void *)(v6 + 8) = a1;
  uint64_t v7 = *a1;
  if (*a1)
  {
    *(unsigned char *)(v6 + 18) = 1;
    *(void *)(v6 + 40) = v7 >> 1;
    *a1 = v6;
    if (v6)
    {
      uint64_t v17 = 0;
      long long v15 = 0u;
      long long v16 = 0u;
      kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v15 + 16))(&v15, "Assert ");
      (*(void (**)(long long *, const char *))(v15 + 16))(&v15, "!(state & 1)");
      (*(void (**)(long long *, const char *))(v15 + 16))(&v15, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v15);
    }
    if (!*(unsigned char *)(*(void *)a2 + 415))
    {
      if (*(int *)(v6 + 36) <= 0)
      {
        uint64_t v17 = 0;
        long long v15 = 0u;
        long long v16 = 0u;
        kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v15 + 16))(&v15, "Assert ");
        (*(void (**)(long long *, const char *))(v15 + 16))(&v15, "result->num_outstanding_blocks > 0");
        (*(void (**)(long long *, const char *))(v15 + 16))(&v15, " FAILED");
        kdu_error::~kdu_error((kdu_error *)&v15);
      }
      *(unsigned char *)(v6 + 17) = 1;
      uint64_t v10 = *(int **)(*(void *)(a2 + 8) + 8);
      goto LABEL_19;
    }
  }
  else
  {
    if (v7)
    {
      uint64_t v17 = 0;
      long long v15 = 0u;
      long long v16 = 0u;
      kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v15 + 16))(&v15, "Assert ");
      (*(void (**)(long long *, const char *))(v15 + 16))(&v15, "state == 0");
      (*(void (**)(long long *, const char *))(v15 + 16))(&v15, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v15);
    }
    *a1 = v6;
    if (v6)
    {
      uint64_t v17 = 0;
      long long v15 = 0u;
      long long v16 = 0u;
      kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v15 + 16))(&v15, "Assert ");
      (*(void (**)(long long *, const char *))(v15 + 16))(&v15, "!(state & 1)");
      (*(void (**)(long long *, const char *))(v15 + 16))(&v15, " FAILED");
      kdu_error::~kdu_error((kdu_error *)&v15);
    }
    uint64_t v8 = *(void *)a2;
    if (*(unsigned char *)(*(void *)a2 + 418) || *(unsigned char *)(v8 + 415))
    {
      uint64_t v9 = *(void *)(a2 + 8);
      uint64_t v10 = *(int **)(v9 + 8);
      uint64_t v11 = HIDWORD(a3) + *(_DWORD *)(a2 + 196) * (int)a3;
      if (*(unsigned char *)(a2 + 24))
      {
        uint64_t v12 = -704 * *(unsigned __int8 *)(a2 + 24);
        do
        {
          v11 += *(int *)(a2 + v12 + 192) * (uint64_t)*(int *)(a2 + v12 + 196);
          v12 += 704;
        }
        while (v12);
      }
      uint64_t v13 = v10[2] + (*(int *)(v9 + 24) + v11 * v10[47]) * *(int *)(v8 + 224) * *(int *)(v8 + 220);
      *(unsigned char *)(v6 + 18) = 1;
      *(void *)(v6 + 40) = ~v13;
      if (!*(unsigned char *)(*(void *)a2 + 415))
      {
        *(unsigned char *)(v6 + 17) = 1;
LABEL_19:
        *(_DWORD *)(v6 + 28) = v10[48];
      }
    }
  }
  return v6;
}

void sub_18865028C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188650298()
{
  _Unwind_Resume(v0);
}

uint64_t kd_precinct_size_class::release(kd_precinct_size_class *this, kd_precinct *a2)
{
  if (*((unsigned char *)a2 + 20)) {
    kd_precinct_size_class::withdraw_from_inactive_list((uint64_t)this, a2);
  }
  *((void *)a2 + 7) = *((void *)this + 4);
  *((void *)this + 4) = a2;
  uint64_t v4 = *((void *)this + 1);
  int v5 = -*((_DWORD *)this + 6);

  return kd_buf_server::augment_structure_bytes(v4, v5);
}

BOOL kd_precinct_ref::set_address(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 <= 0)
  {
    uint64_t v16 = 0;
    long long v14 = 0u;
    long long v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "Assert ");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "seek_address > 0");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  uint64_t v4 = *(void *)(a2 + 8);
  int v5 = *(kd_tile **)(v4 + 8);
  uint64_t v6 = *a1;
  if (*a1) {
    BOOL v7 = (*a1 & 1) == 0;
  }
  else {
    BOOL v7 = 0;
  }
  if (!v7)
  {
    uint64_t v8 = *(void *)v5;
    *a1 = (2 * a4) | 1;
    if (!*(unsigned char *)(v8 + 417))
    {
      if (*(_DWORD *)(v4 + 72) < (int)*(unsigned __int8 *)(a2 + 24)) {
        return *((_DWORD *)v5 + 77) != *((_DWORD *)v5 + 52) || (kd_tile::finished_reading(v5) & 1) == 0;
      }
      if (!*(unsigned char *)(v4 + 184)) {
        return *((_DWORD *)v5 + 77) != *((_DWORD *)v5 + 52) || (kd_tile::finished_reading(v5) & 1) == 0;
      }
      int v9 = *(_DWORD *)(a2 + 188) + HIDWORD(a3);
      int v10 = *(_DWORD *)(a2 + 204);
      if (v9 < v10) {
        return *((_DWORD *)v5 + 77) != *((_DWORD *)v5 + 52) || (kd_tile::finished_reading(v5) & 1) == 0;
      }
      int v11 = *(_DWORD *)(a2 + 184) + a3;
      int v12 = *(_DWORD *)(a2 + 200);
      if (v11 < v12 || v9 >= *(_DWORD *)(a2 + 212) + v10 || v11 >= *(_DWORD *)(a2 + 208) + v12) {
        return *((_DWORD *)v5 + 77) != *((_DWORD *)v5 + 52) || (kd_tile::finished_reading(v5) & 1) == 0;
      }
    }
LABEL_18:
    *((_DWORD *)v5 + 77) += *((_DWORD *)v5 + 50);
    return *((_DWORD *)v5 + 77) != *((_DWORD *)v5 + 52) || (kd_tile::finished_reading(v5) & 1) == 0;
  }
  if (*(_DWORD *)(v6 + 28))
  {
    uint64_t v16 = 0;
    long long v14 = 0u;
    long long v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "Assert ");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "precinct->next_layer_idx == 0");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, " FAILED");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  *(_DWORD *)(v6 + 28) = *((_DWORD *)v5 + 48);
  *(unsigned char *)(v6 + 18) = 1;
  *(void *)(v6 + 40) = a4;
  kd_precinct::finished_desequencing((uint64_t *)v6);
  if (*(unsigned char *)(v6 + 21)) {
    goto LABEL_18;
  }
  return *((_DWORD *)v5 + 77) != *((_DWORD *)v5 + 52) || (kd_tile::finished_reading(v5) & 1) == 0;
}

void sub_1886505F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188650604()
{
  _Unwind_Resume(v0);
}

uint64_t *kd_precinct_pointer_server::disable(uint64_t *this)
{
  if (*this)
  {
    for (uint64_t i = this; ; this = (uint64_t *)kd_buf_server::release(*i, (uint64_t)v2))
    {
      uint64_t v2 = (uint64_t *)i[1];
      i[2] = (uint64_t)v2;
      if (!v2) {
        break;
      }
      i[1] = *v2;
    }
    uint64_t *i = 0;
  }
  return this;
}

void kd_mct_stage::~kd_mct_stage(kd_mct_stage *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C8052888210);
  }
  uint64_t v3 = *((void *)this + 3);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1020C806B39A6A2);
  }
  uint64_t v4 = *((void *)this + 5);
  if (v4)
  {
    uint64_t v5 = v4 - 16;
    uint64_t v6 = *(void *)(v4 - 8);
    if (v6)
    {
      uint64_t v7 = v4 - 152;
      uint64_t v8 = 152 * v6;
      do
      {
        kd_mct_block::~kd_mct_block((kd_mct_block *)(v7 + v8));
        v8 -= 152;
      }
      while (v8);
    }
    MEMORY[0x18C11C0C0](v5, 0x10B0C80C861A3ACLL);
  }
}

void kd_mct_block::~kd_mct_block(kd_mct_block *this)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C8052888210);
  }
  uint64_t v3 = *((void *)this + 3);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C8077774924);
  }
  uint64_t v4 = *((void *)this + 5);
  if (v4) {
    MEMORY[0x18C11C0C0](v4, 0x1000C8052888210);
  }
  uint64_t v5 = *((void *)this + 13);
  if (v5) {
    MEMORY[0x18C11C0C0](v5, 0x1000C80451B5BE8);
  }
  uint64_t v6 = *((void *)this + 14);
  if (v6) {
    MEMORY[0x18C11C0C0](v6, 0x1000C8052888210);
  }
  uint64_t v7 = *((void *)this + 18);
  if (v7) {
    MEMORY[0x18C11C0C0](v7, 0x1000C8052888210);
  }
  uint64_t v8 = *((void *)this + 6);
  if (v8)
  {
    uint64_t v11 = *(void *)(v8 - 8);
    uint64_t v10 = v8 - 8;
    uint64_t v9 = v11;
    if (v11)
    {
      uint64_t v12 = 24 * v9;
      do
      {
        uint64_t v13 = *(void *)(v10 + v12);
        if (v13) {
          MEMORY[0x18C11C0C0](v13, 0x1000C8052888210);
        }
        v12 -= 24;
      }
      while (v12);
    }
    MEMORY[0x18C11C0C0](v10 - 8, 0x1080C80C4643742);
  }
}

void kd_resolution::~kd_resolution(kd_resolution *this)
{
  uint64_t v2 = *((void *)this + 20);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C8052888210);
  }
  unsigned int v3 = *((unsigned __int8 *)this + 223);
  if (*((unsigned char *)this + 223))
  {
    unint64_t v4 = 0;
    uint64_t v5 = 128;
    do
    {
      uint64_t v6 = *(void *)(*((void *)this + 28) + v5);
      if (v6)
      {
        MEMORY[0x18C11C0C0](v6, 0x1000C8052888210);
        unsigned int v3 = *((unsigned __int8 *)this + 223);
      }
      ++v4;
      v5 += 136;
    }
    while (v4 < v3);
  }
  uint64_t v7 = *((void *)this + 29);
  if (v7)
  {
    uint64_t v10 = *(void *)(v7 - 8);
    uint64_t v9 = v7 - 8;
    uint64_t v8 = v10;
    if (v10)
    {
      uint64_t v11 = 8 * v8;
      do
      {
        kd_precinct_ref::~kd_precinct_ref((kd_precinct_ref *)(v9 + v11));
        v11 -= 8;
      }
      while (v11);
    }
    MEMORY[0x18C11C0C0](v9 - 8, 0x1000C8000313F17);
  }
  uint64_t v12 = *((void *)this + 31);
  if (v12) {
    MEMORY[0x18C11C0C0](v12, 0x1020C8068AD3B9FLL);
  }
  uint64_t v13 = *((void *)this + 28);
  if (v13) {
    MEMORY[0x18C11C0C0](v13, 0x10A0C80A1ACF372);
  }
}

void kd_precinct_ref::~kd_precinct_ref(kd_precinct_ref *this)
{
  if (*(void *)this) {
    BOOL v1 = (*(void *)this & 1) == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (v1) {
    kd_precinct_ref::close((uint64_t *)this);
  }
}

void _cg_JP2ResetSource(void *a1)
{
}

void sub_188650A38(void *a1)
{
}

void *_cg_JP2TearDownJP2Storage(void *result)
{
  BOOL v1 = (void *)result[7];
  if (v1)
  {
    uint64_t v2 = (jp2_family_src *)v1[1];
    if (v2) {
      jp2_family_src::close(v2);
    }
    uint64_t v3 = v1[2];
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    if (*v1) {
      (*(void (**)(void))(*(void *)*v1 + 8))(*v1);
    }
    uint64_t v4 = v1[3];
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t result = (void *)v1[1];
    if (result)
    {
      uint64_t v5 = *(uint64_t (**)(void))(*result + 8);
      return (void *)v5();
    }
  }
  return result;
}

void OpenJP2Input()
{
}

void sub_188650D80(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10B1C4077C1191CLL);
  _Unwind_Resume(a1);
}

uint64_t JP2SetOptimalScalingFactor(void *a1)
{
  uint64_t v2 = a1[7];
  float v3 = 1.0;
  kdu_region_compositor::set_scale(*(void *)(v2 + 24), 0, 0, 0, 1.0);
  long long v12 = 0uLL;
  kdu_region_compositor::get_total_composition_dims(*(kdu_region_compositor **)(v2 + 24), (kdu_dims *)&v12);
  unint64_t v4 = a1[20];
  unint64_t v5 = a1[21];
  if (v5 >= 2)
  {
    do
    {
      float v3 = v3 * 0.5;
      BOOL v6 = v5 > 3;
      v5 >>= 1;
    }
    while (v6);
  }
  if (v4 >= 0x10)
  {
    double v7 = (double)v4;
    while ((float)(v3 * (float)(unint64_t)SHIDWORD(v12)) * 0.5 >= v7
         || (float)(v3 * (float)(unint64_t)SDWORD2(v12)) * 0.5 >= v7)
      float v3 = v3 * 0.5;
  }
  float v9 = 0.015625;
  if (v3 >= 0.015625) {
    float v9 = v3;
  }
  *(float *)(v2 + 48) = v9;
  while (1)
  {
    kdu_region_compositor::set_scale(*(void *)(v2 + 24), 0, 0, 0, v9);
    uint64_t total_composition_dims = kdu_region_compositor::get_total_composition_dims(*(kdu_region_compositor **)(v2 + 24), (kdu_dims *)(v2 + 32));
    if (total_composition_dims) {
      break;
    }
    float v9 = *(float *)(v2 + 48) + *(float *)(v2 + 48);
    *(float *)(v2 + 48) = v9;
    if (v9 > 1.0)
    {
      *(_OWORD *)(v2 + 32) = v12;
      fwrite("get_total_composition_dims never succeeded\n", 0x2BuLL, 1uLL, (FILE *)*MEMORY[0x1E4F143C8]);
      return total_composition_dims;
    }
  }
  return total_composition_dims;
}

void _cg_JP2SetupDecompressor(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 56) = malloc_type_calloc(0x38uLL, 1uLL, 0x628993D8uLL);
  OpenJP2Input();
}

void sub_188651278(void *a1)
{
  __cxa_begin_catch(a1);
  jp2_family_src::close(*(jp2_family_src **)(v1 + 8));
  __cxa_end_catch();
  JUMPOUT(0x188651240);
}

void sub_1886512CC(_Unwind_Exception *a1)
{
}

uint64_t _cg_JP2DecompressBlock(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5)
{
  uint64_t v10 = *(void *)(a1 + 56);
  BytePtr = *(const UInt8 **)(a1 + 152);
  if (!BytePtr)
  {
    CFDataRef v23 = *(const __CFData **)(a1 + 144);
    if (!v23) {
      goto LABEL_23;
    }
    BytePtr = CFDataGetBytePtr(v23);
    if (!BytePtr) {
      goto LABEL_23;
    }
  }
  unint64_t v12 = *(void *)(a1 + 128);
  v25[0] = 0;
  v25[1] = 0;
  if ((a2 & 0x80000000) != 0 || (unint64_t v13 = *(void *)(a1 + 64), v13 < (int)a4 + (int)a2))
  {
    long long v15 = "origin_x >= 0 && origin_x + size_x <= info->width";
    int v16 = 692;
    goto LABEL_28;
  }
  if ((a3 & 0x80000000) != 0 || (unint64_t v14 = *(void *)(a1 + 72), v14 < (int)(a5 + a3)))
  {
    long long v15 = "origin_y >= 0 && origin_y + size_y <= info->height";
    int v16 = 693;
    goto LABEL_28;
  }
  long long v15 = "size_x > 0 && size_x <= info->width";
  int v16 = 694;
  if ((int)a4 < 1 || v13 < (int)a4) {
LABEL_28:
  }
    __assert_rtn("_cg_JP2DecompressBlock", "JP2LibDecompress.cpp", v16, v15);
  if (a5 < 1 || v14 < a5)
  {
    long long v15 = "size_y > 0 && size_y <= info->height";
    int v16 = 695;
    goto LABEL_28;
  }
  if (!v10) {
    abort();
  }
  unint64_t v17 = v12 >> 3;
  uint64_t v18 = *(void *)(v10 + 24);
  *(void *)(v18 + 536) = BytePtr;
  *(_DWORD *)(v18 + 548) = a4;
  *(_DWORD *)(v18 + 544) = v17;
  kdu_region_compositor::set_buffer_surface(v18, a3 | (unint64_t)(a2 << 32), a5 | (unint64_t)(a4 << 32), -1);
  *(void *)(a1 + 184) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  uint64_t v19 = (a5 * a4 * v17);
  while (1)
  {
    unint64_t v20 = *(unsigned char **)(v10 + 24);
    if (v20[428])
    {
      if (!v20[429]) {
        break;
      }
    }
    if (((*(uint64_t (**)(unsigned char *, uint64_t, void *))(*(void *)v20 + 32))(v20, v19, v25) & 1) == 0) {
      break;
    }
    int v21 = *(unsigned __int8 *)(a1 + 178);
    if (*(unsigned char *)(a1 + 178))
    {
      if (*(_DWORD *)(a1 + 48)) {
        int v21 = -1;
      }
      else {
        int v21 = 0;
      }
    }
    if (v21)
    {
      uint64_t v22 = 0xFFFFFFFFLL;
      goto LABEL_24;
    }
  }
LABEL_23:
  uint64_t v22 = 0;
LABEL_24:
  kdu_region_compositor::reset(*(void **)(v10 + 24));
  *(_OWORD *)(*(void *)(v10 + 24) + 536) = 0u;
  return v22;
}

void sub_1886514C4(void *a1)
{
}

void _cg_JP2TearDownDecompressor(void *a1)
{
  uint64_t v2 = (void *)a1[7];
  if (v2)
  {
    _cg_JP2TearDownJP2Storage(a1);
    free(v2);
  }
  float v3 = (const void *)a1[18];
  if (v3)
  {
    CFRelease(v3);
  }
}

void _cg_JP2GetDisplayResolution(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  *a2 = 1116733440;
  *a3 = 1116733440;
}

void *_cg_JP2GetPalette(uint64_t a1, int a2, _DWORD *a3, int *a4)
{
  *a3 = 0;
  *a4 = 0;
  if (!a1) {
    return 0;
  }
  if (!*(unsigned char *)(a1 + 179)) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 56);
  if (!v4) {
    return 0;
  }
  uint64_t v15 = jpx_source::access_codestream(*(jpx_source **)(v4 + 16), 0, 1);
  if (!v15) {
    return 0;
  }
  uint64_t v14 = jpx_codestream_source::access_palette((jpx_codestream_source *)&v15);
  if (!v14) {
    return 0;
  }
  int num_entries = jp2_palette::get_num_entries((jp2_palette *)&v14);
  int num_luts = jp2_palette::get_num_luts((jp2_palette *)&v14);
  if (num_luts >= a2) {
    int v10 = a2;
  }
  else {
    int v10 = num_luts;
  }
  if (v10 >= 1)
  {
    unsigned int v11 = 0;
    while ((int)jp2_palette::get_bit_depth((jp2_palette *)&v14, v11) <= 8)
    {
      if (v10 == ++v11) {
        goto LABEL_13;
      }
    }
    return 0;
  }
LABEL_13:
  *a3 = num_entries;
  *a4 = v10;
  unint64_t v12 = malloc_type_malloc(v10 * num_entries, 0xE4D35983uLL);
  if (v12) {
    operator new[]();
  }
  return v12;
}

void MyJP2Source::~MyJP2Source(MyJP2Source *this)
{
  *(void *)this = &unk_1ED4E53B8;
}

{
  *(void *)this = &unk_1ED4E53B8;
  JUMPOUT(0x18C11C0E0);
}

uint64_t kdu_compressed_source::close(kdu_compressed_source *this)
{
  return 1;
}

uint64_t MyJP2Source::get_capabilities(MyJP2Source *this)
{
  return 3;
}

uint64_t MyJP2Source::read(MyJP2Source *this, unsigned __int8 *a2, int a3)
{
  uint64_t v5 = *((void *)this + 1);
  *((void *)this + 2) += a3;
  uint64_t result = (*(uint64_t (**)(void, unsigned __int8 *, void))(v5 + 24))(*(void *)v5, a2, a3);
  if ((int)result < a3) {
    *(_DWORD *)(*((void *)this + 1) + 48) = -1;
  }
  return result;
}

uint64_t MyJP2Source::seek(MyJP2Source *this, uint64_t a2)
{
  *((void *)this + 2) = a2;
  (*(void (**)(void, uint64_t))(*((void *)this + 1) + 32))(**((void **)this + 1), *(void *)(*((void *)this + 1) + 16) + a2);
  return 1;
}

uint64_t kdu_compressed_source::get_pos(kdu_compressed_source *this)
{
  return -1;
}

uint64_t kdu_compressed_source::set_tileheader_scope(kdu_compressed_source *this)
{
  return 0;
}

uint64_t kdu_compressed_source::set_precinct_scope(kdu_compressed_source *this)
{
  return 0;
}

uint64_t kdu_compressed_source::get_capabilities(kdu_compressed_source *this)
{
  return 1;
}

uint64_t kdu_compressed_source::seek(kdu_compressed_source *this)
{
  return 0;
}

void jp2_family_src::~jp2_family_src(jp2_family_src *this)
{
  jp2_family_src::~jp2_family_src(this);

  JUMPOUT(0x18C11C0E0);
}

{
  *(void *)this = &unk_1ED4E3048;
  jp2_family_src::close(this);
}

void MyRegionCompositor::~MyRegionCompositor(MyRegionCompositor *this)
{
  MyRegionCompositor::~MyRegionCompositor(this);

  JUMPOUT(0x18C11C0E0);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1ED4E4860;
  kdu_region_compositor::pre_destroy(this);
  *(_OWORD *)((char *)this + 536) = 0u;

  kdu_region_compositor::~kdu_region_compositor(this);
}

uint64_t kdu_region_compositor::custom_paint_overlay()
{
  return 0;
}

uint64_t MyRegionCompositor::allocate_buffer(uint64_t a1)
{
  if (*(void *)(a1 + 536)) {
    operator new();
  }
  return 0;
}

uint64_t MyRegionCompositor::delete_buffer(uint64_t a1, uint64_t a2)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t))(*(void *)a2 + 8))(a2);
  }
  return result;
}

void kdu_region_compositor::~kdu_region_compositor(kdu_region_compositor *this)
{
  *(void *)this = &unk_1ED4E5458;
  off_1ED4E5468(this);
  jpx_input_box::~jpx_input_box((kdu_region_compositor *)((char *)this + 32));
}

{
  uint64_t vars8;

  kdu_region_compositor::~kdu_region_compositor(this);

  JUMPOUT(0x18C11C0E0);
}

void jpx_input_box::~jpx_input_box(jpx_input_box *this)
{
  *(void *)this = &unk_1ED4E0E28;
  off_1ED4E0E38(this);

  jp2_input_box::~jp2_input_box(this);
}

{
  uint64_t vars8;

  jpx_input_box::~jpx_input_box(this);

  JUMPOUT(0x18C11C0E0);
}

void MyCompositorBuf::~MyCompositorBuf(MyCompositorBuf *this)
{
  *((void *)this + 4) = 0;
  *(void *)this = &unk_1ED4E4A30;
}

{
  *((void *)this + 4) = 0;
  *(void *)this = &unk_1ED4E4A30;
  JUMPOUT(0x18C11C0E0);
}

uint64_t kdu_compositor_buf::set_read_accessibility(kdu_compositor_buf *this)
{
  *((unsigned char *)this + 25) = 1;
  return 1;
}

uint64_t kdu_compositor_buf::lock_buf(uint64_t this, char a2)
{
  *(unsigned char *)(this + 26) = 1;
  *(unsigned char *)(this + 27) = a2;
  return this;
}

void kdu_compositor_buf::~kdu_compositor_buf(kdu_compositor_buf *this)
{
  *(void *)this = &unk_1ED4E4A30;
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    MEMORY[0x18C11C0C0](v1, 0x1000C8077774924);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_1ED4E4A30;
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    MEMORY[0x18C11C0C0](v1, 0x1000C8077774924);
  }

  JUMPOUT(0x18C11C0E0);
}

double kd_thread_group::get_queue(kd_thread_group *this)
{
  uint64_t v2 = (char *)*((void *)this + 801);
  if (v2)
  {
    float v3 = (char *)*((void *)v2 + 7);
  }
  else
  {
    uint64_t v4 = malloc_type_malloc(0x34087uLL, 0xD5807C5AuLL);
    void *v4 = *((void *)this + 802);
    *((void *)this + 802) = v4;
    bzero(v4 + 1, 0x3407FuLL);
    uint64_t v5 = -(v4 + 8) & 0x7F;
    BOOL v6 = (char *)v4 + v5 + 8;
    double v7 = (char *)*((void *)this + 801);
    uint64_t v2 = (char *)v4 + v5 - 6648;
    unsigned int v8 = v5 ^ 0x35A7F;
    do
    {
      float v3 = v7;
      *((void *)v2 + 839) = v7;
      double v7 = v6;
      v6 += 6656;
      v2 += 6656;
      v8 -= 6656;
    }
    while (v8 >> 10 > 0xC);
  }
  *((void *)this + 801) = v3;
  *((void *)v2 + 7) = 0;
  *((void *)v2 + 2) = this;
  double result = NAN;
  *((void *)v2 + 47) = -1;
  *((_DWORD *)v2 + 24) = -1;
  return result;
}

double kd_thread_group::release_queues(kd_thread_group *a1, uint64_t a2, char a3)
{
  for (uint64_t i = *(kdu_thread_queue **)(a2 + 48); i; uint64_t i = *(kdu_thread_queue **)(a2 + 48))
  {
    *(void *)(a2 + 48) = *((void *)i + 4);
    kd_thread_group::release_queues(a1, i, 0);
  }
  if ((a3 & 1) == 0)
  {
    double result = 0.0;
    *(_OWORD *)(a2 + 352) = 0u;
    *(_OWORD *)(a2 + 368) = 0u;
    *(_OWORD *)(a2 + 320) = 0u;
    *(_OWORD *)(a2 + 336) = 0u;
    *(_OWORD *)(a2 + 288) = 0u;
    *(_OWORD *)(a2 + 304) = 0u;
    *(_OWORD *)(a2 + 256) = 0u;
    *(_OWORD *)(a2 + 272) = 0u;
    *(_OWORD *)(a2 + 224) = 0u;
    *(_OWORD *)(a2 + 240) = 0u;
    *(_OWORD *)(a2 + 192) = 0u;
    *(_OWORD *)(a2 + 208) = 0u;
    *(_OWORD *)(a2 + 160) = 0u;
    *(_OWORD *)(a2 + 176) = 0u;
    *(_OWORD *)(a2 + 128) = 0u;
    *(_OWORD *)(a2 + 144) = 0u;
    *(_OWORD *)(a2 + 96) = 0u;
    *(_OWORD *)(a2 + 112) = 0u;
    *(_OWORD *)(a2 + 64) = 0u;
    *(_OWORD *)(a2 + 80) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    *(void *)(a2 + 56) = *((void *)a1 + 801);
    *((void *)a1 + 801) = a2;
  }
  return result;
}

kdu_thread_queue *kdu_thread_queue::find_unassigned_job(kdu_thread_queue *this, int a2)
{
  uint64_t v2 = this;
  int v3 = *((_DWORD *)this + 27);
  if (!v3)
  {
    unsigned int v5 = 0;
    BOOL v6 = 0;
    uint64_t v7 = (uint64_t)this;
    do
    {
      uint64_t v8 = *(unsigned int *)(v7 + 116);
      if (*(_DWORD *)(v7 + 112) > v5)
      {
        BOOL v6 = (int *)v7;
        unsigned int v5 = *(_DWORD *)(v7 + 112);
      }
      if ((int)v8 < 1)
      {
LABEL_9:
        this = *(kdu_thread_queue **)(v7 + 24);
        if (this) {
          goto LABEL_12;
        }
      }
      else
      {
        float v9 = (int *)(v7 + 132);
        while (1)
        {
          int v10 = *v9;
          v9 += 8;
          if (v10 == a2) {
            break;
          }
          if (!--v8) {
            goto LABEL_9;
          }
        }
      }
      if (*(int *)(v7 + 104) < 1)
      {
        if (v6)
        {
          if (v6[25] <= 0) {
            kdu_thread_queue::find_unassigned_job();
          }
          return kdu_thread_queue::make_secondary_job_runnable((kdu_thread_queue *)v6);
        }
        else
        {
          if (*(_DWORD *)(v7 + 100)) {
            kdu_thread_queue::find_unassigned_job();
          }
          return 0;
        }
      }
      kdu_thread_queue::make_primary_jobs_runnable(v7);
      this = v2;
LABEL_12:
      int v3 = *((_DWORD *)this + 27);
      uint64_t v7 = (uint64_t)this;
    }
    while (!v3);
  }
LABEL_21:
  while (v3 > *((_DWORD *)this + 22))
  {
    this = (kdu_thread_queue *)*((void *)this + 6);
    if (!this) {
      goto LABEL_32;
    }
    unsigned int v11 = 0;
    do
    {
      int v3 = *((_DWORD *)this + 27);
      if (v3 >= 1)
      {
        unsigned int v11 = this;
        if (!*((_DWORD *)this + 19)) {
          goto LABEL_21;
        }
      }
      this = (kdu_thread_queue *)*((void *)this + 4);
    }
    while (this);
    if (!v11) {
LABEL_32:
    }
      kdu_thread_queue::find_unassigned_job();
    int v3 = *((_DWORD *)v11 + 27);
    this = v11;
  }
  return this;
}

uint64_t kdu_thread_queue::make_primary_jobs_runnable(uint64_t this)
{
  uint64_t v1 = (_DWORD *)this;
  int v2 = *(_DWORD *)(this + 84);
  if (*(_DWORD *)(this + 104) > v2)
  {
    uint64_t v3 = *(void *)(this + 48);
    if (v3)
    {
      do
      {
        if (*(int *)(v3 + 104) >= 1) {
          this = kdu_thread_queue::make_primary_jobs_runnable((kdu_thread_queue *)v3);
        }
        uint64_t v3 = *(void *)(v3 + 32);
      }
      while (v3);
      int v2 = v1[21];
    }
  }
  if (v2 >= 1)
  {
    int v4 = v1[22] + v2;
    v1[21] = 0;
    v1[22] = v4;
    unsigned int v5 = v1;
    do
    {
      int v6 = v5[27] + v2;
      v5[26] -= v2;
      v5[27] = v6;
      unsigned int v5 = (_DWORD *)*((void *)v5 + 3);
    }
    while (v5);
  }
  if (v1[26]) {
    kdu_thread_queue::make_primary_jobs_runnable();
  }
  return this;
}

kdu_thread_queue *kdu_thread_queue::make_secondary_job_runnable(kdu_thread_queue *this)
{
  int v1 = *((_DWORD *)this + 25);
  if (v1 < 1 || (int v2 = this, !*((_DWORD *)this + 28)) || *((_DWORD *)this + 27) || *((_DWORD *)this + 26)) {
    kdu_thread_queue::make_secondary_job_runnable();
  }
  if (v1 == *((_DWORD *)this + 20))
  {
    if (!*((_DWORD *)this + 18)) {
      kdu_thread_queue::make_secondary_job_runnable();
    }
    int v3 = *((_DWORD *)this + 22) + 1;
    *((_DWORD *)this + 22) = v3;
    if (v3 == v1) {
      *((_DWORD *)this + 18) = 0;
    }
    int v4 = this;
    do
    {
      int v5 = *((_DWORD *)v4 + 26);
      int v6 = *((_DWORD *)v4 + 27) + 1;
      *((_DWORD *)v4 + 27) = v6;
      if (v5 + v6 == *((_DWORD *)v4 + 25)) {
        *((_DWORD *)v4 + 28) = 0;
      }
      int v4 = (kdu_thread_queue *)*((void *)v4 + 3);
    }
    while (v4);
  }
  else
  {
    uint64_t v7 = *((void *)this + 6);
    if (!v7) {
      goto LABEL_56;
    }
    uint64_t v8 = 0;
    unsigned int v9 = 0;
    unsigned int v10 = 0;
    do
    {
      unsigned int v11 = *(_DWORD *)(v7 + 112);
      if (v11)
      {
        if (*(_DWORD *)(v7 + 100))
        {
          if (*(_DWORD *)(v7 + 108) || *(_DWORD *)(v7 + 104) || *(_DWORD *)(v7 + 88) || *(_DWORD *)(v7 + 84)) {
            kdu_thread_queue::make_secondary_job_runnable();
          }
          if (v11 <= v9) {
            unsigned int v12 = v9;
          }
          else {
            unsigned int v12 = *(_DWORD *)(v7 + 112);
          }
          if (v8) {
            unsigned int v13 = v10;
          }
          else {
            unsigned int v13 = *(_DWORD *)(v7 + 112);
          }
          if (v8)
          {
            uint64_t v14 = v8;
          }
          else
          {
            unsigned int v12 = v10;
            uint64_t v14 = (kdu_thread_queue *)v7;
          }
          BOOL v15 = v11 > v10;
          if (v11 <= v10) {
            unsigned int v9 = v12;
          }
          else {
            unsigned int v9 = v10;
          }
          if (v11 <= v10) {
            unsigned int v10 = v13;
          }
          else {
            unsigned int v10 = *(_DWORD *)(v7 + 112);
          }
          if (v15) {
            uint64_t v8 = (kdu_thread_queue *)v7;
          }
          else {
            uint64_t v8 = v14;
          }
        }
        else
        {
          *(_DWORD *)(v7 + 112) = 0;
        }
      }
      uint64_t v7 = *(void *)(v7 + 32);
    }
    while (v7);
    if (!v8) {
LABEL_56:
    }
      kdu_thread_queue::make_secondary_job_runnable();
    uint64_t secondary_job_runnable = kdu_thread_queue::make_secondary_job_runnable(v8);
    unsigned int v17 = *((_DWORD *)v8 + 28);
    if (v9 > v17) {
      unsigned int v17 = v9;
    }
    unsigned int v18 = *((_DWORD *)v2 + 18);
    if (v18)
    {
      if (*((_DWORD *)v2 + 20) <= *((_DWORD *)v2 + 21) + *((_DWORD *)v2 + 22)) {
        kdu_thread_queue::make_secondary_job_runnable();
      }
      if (v18 > v17) {
        unsigned int v17 = *((_DWORD *)v2 + 18);
      }
    }
    *((_DWORD *)v2 + 28) = v17;
    int v2 = (kdu_thread_queue *)secondary_job_runnable;
    if (!secondary_job_runnable) {
      kdu_thread_queue::make_secondary_job_runnable();
    }
  }
  return v2;
}

uint64_t kdu_thread_queue::make_subtree_jobs_runnable(uint64_t this)
{
  int v1 = (_DWORD *)this;
  int v2 = *(_DWORD *)(this + 80);
  int v3 = *(_DWORD *)(this + 88);
  int v4 = v2 - v3;
  if (*(_DWORD *)(this + 100) - *(_DWORD *)(this + 108) > v2 - v3)
  {
    uint64_t v5 = *(void *)(this + 48);
    if (v5)
    {
      do
      {
        if (*(_DWORD *)(v5 + 100) > *(_DWORD *)(v5 + 108)) {
          this = kdu_thread_queue::make_subtree_jobs_runnable((kdu_thread_queue *)v5);
        }
        uint64_t v5 = *(void *)(v5 + 32);
      }
      while (v5);
      int v2 = v1[20];
      int v3 = v1[22];
      int v4 = v2 - v3;
    }
  }
  if (v4 >= 1)
  {
    int v6 = v1[21];
    v1[21] = 0;
    v1[22] = v2;
    uint64_t v7 = v1;
    v1[18] = 0;
    do
    {
      int v8 = v7[27] + v4;
      int v9 = v7[25];
      int v10 = v7[26] - v6;
      v7[26] = v10;
      v7[27] = v8;
      if (v10 + v8 == v9) {
        v7[28] = 0;
      }
      uint64_t v7 = (_DWORD *)*((void *)v7 + 3);
    }
    while (v7);
    int v3 = v2;
  }
  BOOL v11 = v1[27] == v1[25] && v3 == v2;
  if (!v11 || v1[26]) {
    kdu_thread_queue::make_subtree_jobs_runnable();
  }
  return this;
}

uint64_t kdu_thread_queue::install_synchronization_point(kdu_thread_queue *this, kdu_worker *a2, char a3, int a4)
{
  if (*((_DWORD *)this + 27) < *((_DWORD *)this + 25)) {
    kdu_thread_queue::make_subtree_jobs_runnable((uint64_t)this);
  }
  uint64_t v8 = *((int *)this + 29);
  if ((int)v8 >= 8) {
    kdu_thread_queue::install_synchronization_point();
  }
  *((_DWORD *)this + 29) = v8 + 1;
  int v9 = *((_DWORD *)this + 20);
  int v10 = v9 + *((_DWORD *)this + 23);
  int v11 = *((_DWORD *)this + 19) + v9;
  unsigned int v12 = (char *)this + 32 * v8;
  *((_DWORD *)v12 + 32) = 0;
  unsigned int v13 = v12 + 128;
  *((_DWORD *)v13 - 2) = v10;
  *((_DWORD *)v13 - 1) = v11;
  *((_DWORD *)v13 + 1) = a4;
  *((void *)v13 + 1) = a2;
  v13[16] = a3;
  v13[17] = 0;
  uint64_t result = 1;
  if (!v8 && v11 <= 0)
  {
    BOOL v15 = (kdu_thread_queue *)*((void *)this + 6);
    if (!v15) {
      goto LABEL_12;
    }
    do
    {
      if (kdu_thread_queue::install_synchronization_point(v15, 0, 0, -1)) {
        ++*(_DWORD *)v13;
      }
      BOOL v15 = (kdu_thread_queue *)*((void *)v15 + 4);
    }
    while (v15);
    if (*(int *)v13 > 0)
    {
      return 1;
    }
    else
    {
LABEL_12:
      uint64_t result = 0;
      *((_DWORD *)this + 29) = 0;
    }
  }
  return result;
}

BOOL kdu_event::set(kdu_event *this)
{
  uint64_t v1 = 1;
  if (!*((unsigned char *)this + 48))
  {
    *((unsigned char *)this + 48) = 1;
    if (*((unsigned char *)this + 49)) {
      int v2 = pthread_cond_broadcast((pthread_cond_t *)this);
    }
    else {
      int v2 = pthread_cond_signal((pthread_cond_t *)this);
    }
    return v2 == 0;
  }
  return v1;
}

BOOL kdu_thread_entity::terminate(kdu_thread_entity *this, kdu_thread_queue *a2, char a3, int *a4)
{
  int v6 = a2;
  kdu_thread_entity::synchronize(this, a2);
  uint64_t v8 = (unsigned __int8 *)*((void *)this + 5);
  int v9 = *v8;
  if (a4 && *v8) {
    *a4 = *((_DWORD *)v8 + 1);
  }
  if (!v6)
  {
    uint64_t v10 = *((void *)this + 4);
    if (!*(void *)(v10 + 1224)) {
      return v9 == 0;
    }
    int v6 = (kdu_thread_queue *)(v10 + 1176);
    a3 = 1;
  }
  if (*((_DWORD *)v6 + 20) != *((_DWORD *)v6 + 25)) {
    kdu_thread_entity::terminate();
  }
  uint64_t v11 = *((void *)this + 4);
  if (*(unsigned char *)(v11 + 2160))
  {
    pthread_mutex_lock((pthread_mutex_t *)(v11 + 2096));
    uint64_t v11 = *((void *)this + 4);
  }
  uint64_t v12 = *(unsigned int *)(v11 + 128);
  if ((int)v12 >= 1)
  {
    for (uint64_t i = 0; i != v12; ++i)
    {
      uint64_t v14 = *(void *)(v11 + 8 * i + 136);
      BOOL v15 = *(kdu_thread_queue **)(v14 + 64);
      if (v15 == v6) {
        char v16 = a3;
      }
      else {
        char v16 = 0;
      }
      if (v15 && (v16 & 1) == 0)
      {
        if (v15 == v6) {
          goto LABEL_24;
        }
        do
        {
          BOOL v15 = (kdu_thread_queue *)*((void *)v15 + 3);
          if (v15) {
            BOOL v17 = v15 == v6;
          }
          else {
            BOOL v17 = 1;
          }
        }
        while (!v17);
        if (v15) {
LABEL_24:
        }
          *(void *)(v14 + 64) = 0;
      }
    }
  }
  if ((a3 & 1) == 0)
  {
    if (*((_DWORD *)v6 + 20)) {
      kdu_thread_entity::terminate();
    }
    uint64_t v18 = *((void *)v6 + 5);
    if (!v18)
    {
      uint64_t v30 = *((void *)v6 + 3);
      if (*(kdu_thread_queue **)(v30 + 48) != v6) {
        kdu_thread_entity::terminate();
      }
      uint64_t v19 = *((void *)v6 + 4);
      *(void *)(v30 + 48) = v19;
      if (!v19) {
        goto LABEL_31;
      }
      goto LABEL_30;
    }
    *(void *)(v18 + 32) = *((void *)v6 + 4);
    uint64_t v19 = *((void *)v6 + 4);
    if (v19) {
LABEL_30:
    }
      *(void *)(v19 + 40) = v18;
  }
LABEL_31:
  if (*(unsigned char *)(v11 + 2160))
  {
    pthread_mutex_unlock((pthread_mutex_t *)(v11 + 2096));
    uint64_t v11 = *((void *)this + 4);
  }
  double v20 = kd_thread_group::release_queues((kd_thread_group *)v11, (uint64_t)v6, a3);
  uint64_t v21 = *((void *)this + 4);
  if (!*(void *)(v21 + 1224))
  {
    if (*((_DWORD *)this + 2) || *(_DWORD *)(v21 + 1168)) {
      kdu_thread_entity::terminate();
    }
    (*(void (**)(kdu_thread_entity *, void, double))(*(void *)this + 56))(this, **((unsigned __int8 **)this + 5), v20);
    int v22 = 1;
    *((unsigned char *)this + 72) = 1;
    uint64_t v23 = *((void *)this + 4);
    if (*(unsigned char *)(v23 + 2160))
    {
      pthread_mutex_lock((pthread_mutex_t *)(v23 + 2096));
      uint64_t v23 = *((void *)this + 4);
    }
    *(_DWORD *)(v23 + 1168) = 1;
    *(unsigned char *)(v23 + 2088) = 1;
    LODWORD(v24) = *(_DWORD *)(v23 + 128);
    if ((int)v24 >= 2)
    {
      uint64_t v25 = 1;
      uint64_t v26 = 2224;
      do
      {
        kdu_event::set((kdu_event *)(v23 + v26));
        ++v25;
        uint64_t v23 = *((void *)this + 4);
        uint64_t v24 = *(int *)(v23 + 128);
        v26 += 56;
      }
      while (v25 < v24);
      int v22 = *(_DWORD *)(v23 + 1168);
    }
    if (v22 < (int)v24)
    {
      do
      {
        kdu_event::wait((pthread_cond_t *)(v23 + 2168), (pthread_mutex_t *)(v23 + 2096));
        uint64_t v23 = *((void *)this + 4);
        LODWORD(v24) = *(_DWORD *)(v23 + 128);
      }
      while (*(_DWORD *)(v23 + 1168) < (int)v24);
    }
    if (*(_DWORD *)(v23 + 1560)) {
      kdu_thread_entity::terminate();
    }
    *(unsigned char *)(v23 + 2088) = 0;
    *(_DWORD *)(v23 + 1168) = 0;
    if ((int)v24 >= 1)
    {
      uint64_t v24 = v24;
      uint64_t v27 = v23 + 136;
      do
      {
        if (!*(unsigned char *)(*(void *)v27 + 72)) {
          kdu_thread_entity::terminate();
        }
        *(unsigned char *)(*(void *)v27 + 72) = 0;
        v27 += 8;
        --v24;
      }
      while (v24);
    }
    uint64_t v28 = *((void *)this + 5);
    *(unsigned char *)uint64_t v28 = 0;
    *(_DWORD *)(v28 + 4) = -1;
    if (*(unsigned char *)(v23 + 2160)) {
      pthread_mutex_unlock((pthread_mutex_t *)(v23 + 2096));
    }
  }
  return v9 == 0;
}

BOOL kdu_mutex::unlock(kdu_mutex *this)
{
  return *((unsigned char *)this + 64) && pthread_mutex_unlock((pthread_mutex_t *)this) == 0;
}

uint64_t kdu_thread_entity::get_num_threads(kdu_thread_entity *this)
{
  uint64_t v1 = *((void *)this + 4);
  if (v1) {
    return *(unsigned int *)(v1 + 128);
  }
  else {
    return 0;
  }
}

uint64_t kdu_thread_entity::add_queue(uint64_t a1, uint64_t a2, char *a3, uint64_t a4)
{
  uint64_t v5 = *(kd_thread_group **)(a1 + 32);
  if (!v5) {
    return 0;
  }
  if (a3) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = (char *)v5 + 1176;
  }
  kd_thread_group::get_queue(v5);
  uint64_t v10 = v9;
  *(_DWORD *)uint64_t v9 = *(_DWORD *)v8 + 1;
  *(void *)(v9 + 8) = a4;
  *(void *)(v9 + 64) = a2;
  *(void *)(v9 + 24) = v8;
  uint64_t v11 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v11 + 2160)) {
    pthread_mutex_lock((pthread_mutex_t *)(v11 + 2096));
  }
  uint64_t v12 = *((void *)v8 + 6);
  *(void *)(v10 + 32) = v12;
  if (v12) {
    *(void *)(v12 + 40) = v10;
  }
  *((void *)v8 + 6) = v10;
  uint64_t v13 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v13 + 2160)) {
    pthread_mutex_unlock((pthread_mutex_t *)(v13 + 2096));
  }
  return v10;
}

uint64_t kdu_thread_entity::add_jobs(uint64_t this, kdu_thread_queue *a2, int a3, int a4)
{
  if (a3 < 0) {
    kdu_thread_entity::add_jobs();
  }
  uint64_t v7 = this;
  uint64_t v8 = *(void *)(this + 32);
  if (*(unsigned char *)(v8 + 2160)) {
    this = pthread_mutex_lock((pthread_mutex_t *)(v8 + 2096));
  }
  if (**(unsigned char **)(v7 + 40))
  {
    kdu_mutex::unlock((kdu_mutex *)(*(void *)(v7 + 32) + 2096));
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = *(_DWORD *)(*(void *)(v7 + 40) + 4);
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  int v9 = *((_DWORD *)a2 + 20);
  int v10 = *((_DWORD *)a2 + 21);
  int v11 = *((_DWORD *)a2 + 22);
  int v12 = v9 - (v10 + v11);
  if ((v12 | a3) < 0) {
    kdu_thread_entity::add_jobs();
  }
  if (!(v12 | a3)) {
    goto LABEL_61;
  }
  if (a4) {
    int v13 = a3;
  }
  else {
    int v13 = 0;
  }
  if (a4) {
    int v14 = 0;
  }
  else {
    int v14 = a3;
  }
  int v15 = v12 + v14;
  int v16 = v9 + a3;
  int v17 = v15 + v10;
  *((_DWORD *)a2 + 20) = v9 + a3;
  *((_DWORD *)a2 + 21) = v15 + v10;
  uint64_t v18 = *(void *)(v7 + 32);
  int v19 = *(_DWORD *)(v18 + 648);
  if (v19 < 1 || v16 < 1)
  {
    int v21 = 0;
    if (!v13)
    {
LABEL_29:
      if (v17 + v11 != v16) {
        kdu_thread_entity::add_jobs();
      }
      *((_DWORD *)a2 + 18) = 0;
      uint64_t v26 = a2;
      do
      {
        int v27 = *((_DWORD *)v26 + 25) + a3;
        int v28 = *((_DWORD *)v26 + 26) + v15;
        *((_DWORD *)v26 + 25) = v27;
        *((_DWORD *)v26 + 26) = v28;
        int v29 = *((_DWORD *)v26 + 27) + v21;
        *((_DWORD *)v26 + 27) = v29;
        if (v29 + v28 == v27) {
          *((_DWORD *)v26 + 28) = 0;
        }
        uint64_t v26 = (kdu_thread_queue *)*((void *)v26 + 3);
      }
      while (v26);
      goto LABEL_34;
    }
  }
  else
  {
    *((_DWORD *)a2 + 21) = 0;
    if (!v17)
    {
      if (!v13) {
        kdu_thread_entity::add_jobs();
      }
      --v13;
      int v17 = 1;
    }
    int v21 = v17;
    int v15 = -v10;
    v11 += v17;
    *((_DWORD *)a2 + 22) = v11;
    int v17 = 0;
    if (!v13) {
      goto LABEL_29;
    }
  }
  if (!a4) {
    kdu_thread_entity::add_jobs();
  }
  uint64_t v22 = -a4;
  *((_DWORD *)a2 + 18) = v22;
  uint64_t v23 = a2;
  do
  {
    int v24 = *((_DWORD *)v23 + 26) + v15;
    *((_DWORD *)v23 + 25) += a3;
    *((_DWORD *)v23 + 26) = v24;
    uint64_t v25 = *((unsigned int *)v23 + 28);
    *((_DWORD *)v23 + 27) += v21;
    if (v25 < v22)
    {
      *((_DWORD *)v23 + 28) = v22;
      uint64_t v25 = v22;
    }
    uint64_t v23 = (kdu_thread_queue *)*((void *)v23 + 3);
    uint64_t v22 = v25;
  }
  while (v23);
LABEL_34:
  if (v19 >= 1)
  {
    int v30 = v11 - 1;
    if (v11 >= 1 && !*((_DWORD *)a2 + 19) && (*((_DWORD *)a2 + 24) & 0x80000000) != 0)
    {
      uint64_t v31 = *(unsigned int *)(v18 + 128);
      if ((int)v31 < 1) {
        goto LABEL_72;
      }
      uint64_t v32 = 0;
      int v33 = -1;
      int v34 = 0x7FFFFFFF;
      do
      {
        uint64_t v35 = v18 + 8 * v32;
        if (!*(void *)(v35 + 656))
        {
          int v36 = *(kdu_thread_queue **)(*(void *)(v35 + 136) + 64);
          if (v36)
          {
            int v37 = *(_DWORD *)v36;
            int v38 = *(_DWORD *)a2;
            if (*(_DWORD *)a2 <= *(_DWORD *)v36)
            {
              int v39 = 0;
              char v40 = a2;
            }
            else
            {
              int v39 = 0;
              char v40 = a2;
              do
              {
                ++v39;
                char v40 = (kdu_thread_queue *)*((void *)v40 + 3);
                int v38 = *(_DWORD *)v40;
              }
              while (*(_DWORD *)v40 > v37);
            }
            while (v37 > v38)
            {
              ++v39;
              int v36 = (kdu_thread_queue *)*((void *)v36 + 3);
              int v37 = *(_DWORD *)v36;
            }
            while (v40 != v36)
            {
              v39 += 2;
              char v40 = (kdu_thread_queue *)*((void *)v40 + 3);
              int v36 = (kdu_thread_queue *)*((void *)v36 + 3);
            }
          }
          else
          {
            int v39 = 0;
          }
          if (v39 < v34)
          {
            int v33 = v32;
            int v34 = v39;
          }
        }
        ++v32;
      }
      while (v32 != v31);
      if (v33 < 1 || *(void *)(v18 + 8 * v33 + 656)) {
LABEL_72:
      }
        kdu_thread_entity::add_jobs();
      *((_DWORD *)a2 + 19) = 1;
      *((_DWORD *)a2 + 20) = v16 - 1;
      *((_DWORD *)a2 + 22) = v30;
      uint64_t v41 = a2;
      do
      {
        --*((_DWORD *)v41 + 25);
        --*((_DWORD *)v41 + 27);
        uint64_t v41 = (kdu_thread_queue *)*((void *)v41 + 3);
      }
      while (v41);
      int v42 = *((_DWORD *)a2 + 23);
      *((_DWORD *)a2 + 23) = v42 + 1;
      *((_DWORD *)a2 + 24) = v42;
      *(void *)(v18 + 8 * v33 + 656) = a2;
      uint64_t v43 = *(void *)(v7 + 32);
      --*(_DWORD *)(v43 + 648);
      this = kdu_event::set((kdu_event *)(v43 + 56 * v33 + 2168));
LABEL_61:
      uint64_t v18 = *(void *)(v7 + 32);
    }
  }
  if (*(unsigned char *)(v18 + 2160))
  {
    return pthread_mutex_unlock((pthread_mutex_t *)(v18 + 2096));
  }
  return this;
}

BOOL kdu_thread_entity::synchronize(kdu_thread_entity *this, kdu_thread_queue *a2)
{
  uint64_t v2 = *((void *)this + 4);
  if (!v2) {
    return 1;
  }
  if (*(int *)(v2 + 5752) >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 72;
    do
    {
      if (*(kdu_thread_entity **)(*(void *)(v2 + 5760) + v6) == this)
      {
        (*(void (**)(kdu_thread_entity *, void))(*(void *)this + 32))(this, 0);
        uint64_t v2 = *((void *)this + 4);
      }
      ++v5;
      v6 += 80;
    }
    while (v5 < *(int *)(v2 + 5752));
  }
  if (a2) {
    goto LABEL_10;
  }
  if (*(void *)(v2 + 1224))
  {
    a2 = (kdu_thread_queue *)(v2 + 1176);
LABEL_10:
    if (*(unsigned char *)(v2 + 2160)) {
      pthread_mutex_lock((pthread_mutex_t *)(v2 + 2096));
    }
    if (!*((void *)a2 + 6) && *((_DWORD *)a2 + 20) + *((_DWORD *)a2 + 23)) {
      kdu_thread_entity::synchronize();
    }
    if (kdu_thread_queue::install_synchronization_point(a2, 0, 0, *((_DWORD *)this + 2)))
    {
      uint64_t v7 = *((void *)this + 4);
      if (*(unsigned char *)(v7 + 2160)) {
        pthread_mutex_unlock((pthread_mutex_t *)(v7 + 2096));
      }
      char v8 = kdu_thread_entity::process_jobs(this, a2, 1, 0);
      uint64_t v9 = *((void *)this + 4);
      if (*(unsigned char *)(v9 + 2160)) {
        pthread_mutex_lock((pthread_mutex_t *)(v9 + 2096));
      }
      int v10 = *((_DWORD *)a2 + 29);
      if (v8)
      {
        if (v10 < 1
          || (int v11 = *((_DWORD *)a2 + 33), v11 != *((_DWORD *)this + 2))
          || !kdu_thread_queue::check_condition(a2, 1, v11))
        {
          kdu_thread_entity::synchronize();
        }
        uint64_t v12 = *((int *)a2 + 29);
        uint64_t v13 = v12 - 1;
        *((_DWORD *)a2 + 29) = v12 - 1;
        if ((int)v12 >= 2)
        {
          uint64_t v14 = 0;
          int v15 = (_OWORD *)((char *)a2 + 152);
          do
          {
            ++v14;
            long long v16 = v15[1];
            *(v15 - 2) = *v15;
            *(v15 - 1) = v16;
            v15 += 2;
          }
          while (v14 < v13);
          kdu_thread_entity::process_outstanding_sync_points(this, a2);
        }
      }
      else if (v10 && *((_DWORD *)a2 + 33) == *((_DWORD *)this + 2))
      {
        kdu_thread_entity::synchronize();
      }
    }
    uint64_t v18 = *((void *)this + 4);
    if (*(unsigned char *)(v18 + 2160)) {
      pthread_mutex_unlock((pthread_mutex_t *)(v18 + 2096));
    }
  }
  return **((unsigned char **)this + 5) == 0;
}

uint64_t kdu_thread_entity::process_jobs(kdu_thread_entity *this, kdu_thread_queue *a2, int a3, int a4)
{
  uint64_t v8 = *((void *)this + 4);
  if (!a2 && v8 && !*((_DWORD *)this + 2)) {
    kdu_thread_entity::process_jobs();
  }
  if (*(unsigned char *)(v8 + 2160)) {
    pthread_mutex_lock((pthread_mutex_t *)(v8 + 2096));
  }
  if (a2)
  {
    if ((a3 & 1) == 0)
    {
      int v9 = *((_DWORD *)a2 + 21);
      if (v9 >= 1)
      {
        int v10 = *((_DWORD *)a2 + 22) + v9;
        *((_DWORD *)a2 + 21) = 0;
        *((_DWORD *)a2 + 22) = v10;
        int v11 = a2;
        do
        {
          int v12 = *((_DWORD *)v11 + 27) + v9;
          *((_DWORD *)v11 + 26) -= v9;
          *((_DWORD *)v11 + 27) = v12;
          int v11 = (kdu_thread_queue *)*((void *)v11 + 3);
        }
        while (v11);
      }
    }
  }
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  while (1)
  {
    int v15 = v13 ? v13 : a2;
    if (!v15)
    {
      int v15 = (kdu_thread_queue *)*((void *)this + 8);
      if (!v15) {
        break;
      }
    }
    if (!v14) {
      goto LABEL_65;
    }
LABEL_18:
    if (**((unsigned char **)this + 5) && (a4 & 1) != 0)
    {
LABEL_184:
      kdu_mutex::unlock((kdu_mutex *)(*((void *)this + 4) + 2096));
      goto LABEL_185;
    }
    if (a2
      || (uint64_t v24 = *((void *)this + 4), v25 = *(_DWORD *)(v24 + 1560), v25 < 1)
      || *(void *)(v24 + 8 * *((int *)this + 2) + 656) != 1)
    {
      if (!v14) {
        goto LABEL_161;
      }
      uint64_t v16 = *((void *)this + 4);
      uint64_t v17 = v16 + 8 * *((int *)this + 2);
      if (*(kdu_thread_queue **)(v17 + 656) == v14)
      {
        int v23 = *((_DWORD *)v14 + 24);
        if (v23 < 0) {
          kdu_thread_entity::process_jobs();
        }
        *((_DWORD *)v14 + 24) = -1;
        *(void *)(v17 + 656) = 1;
        uint64_t v16 = *((void *)this + 4);
      }
      else
      {
        int v18 = *((_DWORD *)v14 + 20);
        BOOL v19 = __OFSUB__(v18, 1);
        int v20 = v18 - 1;
        if (v20 < 0 != v19 || (int v21 = *((_DWORD *)v14 + 22), v21 <= 0)) {
          kdu_thread_entity::process_jobs();
        }
        *((_DWORD *)v14 + 20) = v20;
        *((_DWORD *)v14 + 22) = v21 - 1;
        uint64_t v22 = v14;
        do
        {
          --*((_DWORD *)v22 + 25);
          --*((_DWORD *)v22 + 27);
          uint64_t v22 = (kdu_thread_queue *)*((void *)v22 + 3);
        }
        while (v22);
        ++*((_DWORD *)v14 + 19);
        int v23 = *((_DWORD *)v14 + 23);
        *((_DWORD *)v14 + 23) = v23 + 1;
      }
      if (*(unsigned char *)(v16 + 2160)) {
        pthread_mutex_unlock((pthread_mutex_t *)(v16 + 2096));
      }
      (*(void (**)(void))(**((void **)v14 + 8) + 16))();
      uint64_t v30 = *((void *)this + 4);
      if (*(unsigned char *)(v30 + 2160)) {
        pthread_mutex_lock((pthread_mutex_t *)(v30 + 2096));
      }
      int v31 = *((_DWORD *)v14 + 19);
      if (**((unsigned char **)this + 5))
      {
        if (v31) {
          kdu_thread_entity::process_jobs();
        }
LABEL_43:
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        if (a4) {
          goto LABEL_184;
        }
      }
      else
      {
        if (v31 <= 0) {
          kdu_thread_entity::process_jobs();
        }
        if (*((void *)v14 + 6)) {
          goto LABEL_47;
        }
        uint64_t v49 = *((void *)v14 + 3);
        if (!v49 || !*(_DWORD *)(v49 + 108)) {
          goto LABEL_47;
        }
        if (*((int *)v14 + 29) < 1) {
          goto LABEL_109;
        }
        int v50 = *((_DWORD *)v14 + 30);
        if (v23 >= v50) {
          goto LABEL_109;
        }
        if (*(int *)(v49 + 116) < 1 || *(int *)(v49 + 128) <= 0) {
          kdu_thread_entity::process_jobs();
        }
        if (*((int *)v14 + 22) > 0)
        {
          if (*((_DWORD *)v14 + 23) >= v50)
          {
LABEL_47:
            if (((*(uint64_t (**)(kdu_thread_entity *))(*(void *)this + 48))(this) & 1) == 0)
            {
              uint64_t v48 = 0;
              int v31 = *((_DWORD *)v14 + 19);
              goto LABEL_110;
            }
            uint64_t v32 = *((void *)this + 4);
            if (*(unsigned char *)(v32 + 2160)) {
              pthread_mutex_unlock((pthread_mutex_t *)(v32 + 2096));
            }
            (*(void (**)(kdu_thread_entity *, void))(*(void *)this + 40))(this, **((unsigned __int8 **)this + 5));
            uint64_t v33 = *((void *)this + 4);
            if (*(unsigned char *)(v33 + 2160)) {
              pthread_mutex_lock((pthread_mutex_t *)(v33 + 2096));
            }
            int v31 = *((_DWORD *)v14 + 19);
            if (**((unsigned char **)this + 5))
            {
              if (v31) {
                kdu_thread_entity::process_jobs();
              }
              goto LABEL_43;
            }
          }
LABEL_109:
          uint64_t v48 = 0;
          goto LABEL_110;
        }
        uint64_t v48 = *(kdu_thread_queue **)(v49 + 48);
        if (!v48) {
          goto LABEL_47;
        }
        while (*((int *)v48 + 29) < 1 || *((int *)v48 + 22) < 1 || *((_DWORD *)v48 + 23) >= *((_DWORD *)v48 + 30))
        {
          uint64_t v48 = (kdu_thread_queue *)*((void *)v48 + 4);
          if (!v48) {
            goto LABEL_47;
          }
        }
LABEL_110:
        *((_DWORD *)v14 + 19) = v31 - 1;
        if (*((int *)v14 + 29) >= 1)
        {
          int v51 = 0;
          do
          {
            if (v23 < *((_DWORD *)v14 + 8 * v51 + 30))
            {
              uint64_t v52 = (uint64_t)v14 + 32 * v51 + 120;
              int v55 = *(_DWORD *)(v52 + 4);
              uint64_t v53 = (int *)(v52 + 4);
              int v54 = v55;
              if (v55 <= 0) {
                kdu_thread_entity::process_jobs();
              }
              int v56 = v54 - 1;
              *uint64_t v53 = v56;
              if (!v51)
              {
                if (v56) {
                  goto LABEL_116;
                }
                uint64_t v57 = (_DWORD *)((char *)v14 + 128);
                if (*((_DWORD *)v14 + 32)) {
                  kdu_thread_entity::process_jobs();
                }
                uint64_t v58 = (kdu_thread_queue *)*((void *)v14 + 6);
                if (!v58) {
                  goto LABEL_123;
                }
                do
                {
                  if (kdu_thread_queue::install_synchronization_point(v58, 0, 0, -1)) {
                    ++*v57;
                  }
                  uint64_t v58 = (kdu_thread_queue *)*((void *)v58 + 4);
                }
                while (v58);
                if (*v57) {
LABEL_116:
                }
                  int v51 = 0;
                else {
LABEL_123:
                }
                  int v51 = (int)(kdu_thread_entity::process_outstanding_sync_points(this, v14) << 31) >> 31;
              }
            }
            ++v51;
          }
          while (v51 < *((_DWORD *)v14 + 29));
        }
        unsigned int v59 = *((_DWORD *)v14 + 95);
        if ((v59 & 0x80000000) == 0)
        {
          if (*((_DWORD *)v14 + 21)) {
            kdu_thread_entity::process_jobs();
          }
          if (!(*((_DWORD *)v14 + 22) + *((_DWORD *)v14 + 19)))
          {
            if (v59 == *((_DWORD *)this + 2)) {
              kdu_thread_entity::process_jobs();
            }
            kdu_event::set((kdu_event *)(*((void *)this + 4) + 56 * v59 + 2168));
          }
        }
        if (a2 && kdu_thread_queue::check_condition(a2, a3, *((_DWORD *)this + 2)))
        {
          if (v48) {
            kdu_thread_entity::process_jobs();
          }
          goto LABEL_161;
        }
        if (!v48)
        {
          if (*((int *)v14 + 22) <= 0) {
            uint64_t v48 = 0;
          }
          else {
            uint64_t v48 = v14;
          }
        }
        *((void *)this + 8) = v14;
        uint64_t v13 = v14;
        uint64_t v14 = v48;
      }
    }
    else
    {
      if (*(int *)(v24 + 128) <= 1) {
        kdu_thread_entity::process_jobs();
      }
      uint64_t v26 = *(void *)(v24 + 1568);
      if (v25 < 2)
      {
        LODWORD(v28) = 1;
      }
      else
      {
        uint64_t v27 = 0;
        do
        {
          *(void *)(v24 + 8 * v27 + 1568) = *(void *)(v24 + 8 * v27 + 1576);
          uint64_t v24 = *((void *)this + 4);
          uint64_t v28 = *(int *)(v24 + 1560);
          uint64_t v29 = v27 + 2;
          ++v27;
        }
        while (v29 < v28);
      }
      *(_DWORD *)(v24 + 1560) = v28 - 1;
      if (*(unsigned char *)(v24 + 2160)) {
        pthread_mutex_unlock((pthread_mutex_t *)(v24 + 2096));
      }
      if ((*(unsigned int (**)(kdu_thread_entity *))(*(void *)this + 48))(this)) {
        (*(void (**)(kdu_thread_entity *, void))(*(void *)this + 40))(this, **((unsigned __int8 **)this + 5));
      }
      (*(void (**)(uint64_t, kdu_thread_entity *, uint64_t))(*(void *)v26 + 16))(v26, this, 0xFFFFFFFFLL);
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      uint64_t v60 = *((void *)this + 4);
      if (*(unsigned char *)(v60 + 2160))
      {
        pthread_mutex_lock((pthread_mutex_t *)(v60 + 2096));
        uint64_t v13 = 0;
        uint64_t v14 = 0;
      }
    }
  }
  int v15 = (kdu_thread_queue *)(*((void *)this + 4) + 1176);
  if (v14) {
    goto LABEL_18;
  }
LABEL_65:
  while (!a2)
  {
    if (*(_DWORD *)(*((void *)this + 4) + 1560))
    {
      uint64_t v14 = 0;
      goto LABEL_18;
    }
LABEL_69:
    unassigned_job = kdu_thread_queue::find_unassigned_job(v15, *((_DWORD *)this + 2));
    if (unassigned_job)
    {
      uint64_t v14 = unassigned_job;
      goto LABEL_18;
    }
    uint64_t v38 = *((void *)this + 4);
    if (*(unsigned char *)(v38 + 2089)
      || ((int v34 = **((unsigned __int8 **)this + 5), **((unsigned char **)this + 5)) ? (v39 = a4 == 0) : (v39 = 1), !v39))
    {
      if (*(unsigned char *)(v38 + 2160)) {
        pthread_mutex_unlock((pthread_mutex_t *)(v38 + 2096));
      }
      if (!a4) {
        return 0;
      }
LABEL_185:
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = *(_DWORD *)(*((void *)this + 5) + 4);
      __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
    }
    if (a2)
    {
      if (a3)
      {
        if (*((int *)a2 + 29) < 1 || (int v40 = *((_DWORD *)a2 + 33), v40 != *((_DWORD *)this + 2))) {
          kdu_thread_entity::process_jobs();
        }
        *((_DWORD *)a2 + 94) = v40;
      }
      else
      {
        int v40 = *((_DWORD *)this + 2);
        *((_DWORD *)a2 + 95) = v40;
      }
    }
    else
    {
      if (*(unsigned char *)(v38 + 2088) && !*((unsigned char *)this + 72))
      {
        if (*(unsigned char *)(v38 + 2160))
        {
          pthread_mutex_unlock((pthread_mutex_t *)(v38 + 2096));
          int v34 = **((unsigned __int8 **)this + 5);
        }
        (*(void (**)(kdu_thread_entity *, BOOL))(*(void *)this + 56))(this, v34 != 0);
        uint64_t v35 = *((void *)this + 4);
        if (*(unsigned char *)(v35 + 2160))
        {
          pthread_mutex_lock((pthread_mutex_t *)(v35 + 2096));
          uint64_t v35 = *((void *)this + 4);
        }
        *((unsigned char *)this + 72) = 1;
        int v36 = *(_DWORD *)(v35 + 1168) + 1;
        *(_DWORD *)(v35 + 1168) = v36;
        if (v36 == *(_DWORD *)(v35 + 128))
        {
          kdu_event::set((kdu_event *)(v35 + 2168));
          uint64_t v35 = *((void *)this + 4);
        }
        int v15 = (kdu_thread_queue *)(v35 + 1176);
        continue;
      }
      int v40 = *((_DWORD *)this + 2);
      if (!v40) {
        kdu_thread_entity::process_jobs();
      }
      uint64_t v41 = v38 + 8 * v40;
      if (!*(void *)(v41 + 656)) {
        kdu_thread_entity::process_jobs();
      }
      ++*(_DWORD *)(v38 + 648);
      *(void *)(v41 + 656) = 0;
      uint64_t v38 = *((void *)this + 4);
    }
    uint64_t v42 = v38 + 56 * v40;
    *(unsigned char *)(v42 + 2216) = 0;
    kdu_event::wait((pthread_cond_t *)(v42 + 2168), (pthread_mutex_t *)(v38 + 2096));
    if (a2)
    {
      if (a3) {
        *((_DWORD *)a2 + 94) = -1;
      }
      else {
        *((_DWORD *)a2 + 95) = -1;
      }
    }
    else
    {
      uint64_t v43 = *((void *)this + 4);
      uint64_t v44 = (kdu_thread_queue **)(v43 + 8 * *((int *)this + 2) + 656);
      uint64_t v14 = *v44;
      if (*v44)
      {
        if (v14 == (kdu_thread_queue *)1) {
          kdu_thread_entity::process_jobs();
        }
        if (v14 != (kdu_thread_queue *)(v43 + 1176))
        {
          if ((*((_DWORD *)v14 + 24) & 0x80000000) != 0) {
            kdu_thread_entity::process_jobs();
          }
          goto LABEL_18;
        }
        *uint64_t v44 = (kdu_thread_queue *)1;
      }
      else
      {
        if (*(int *)(v43 + 648) <= 0) {
          kdu_thread_entity::process_jobs();
        }
        *uint64_t v44 = (kdu_thread_queue *)1;
        uint64_t v45 = *((void *)this + 4);
        --*(_DWORD *)(v45 + 648);
        int v46 = *(unsigned __int8 *)(v45 + 2088);
        int v47 = (kdu_thread_queue *)(v45 + 1176);
        if (v46) {
          int v15 = v47;
        }
      }
    }
  }
  if (!kdu_thread_queue::check_condition(a2, a3, *((_DWORD *)this + 2))) {
    goto LABEL_69;
  }
  if (**((unsigned char **)this + 5)) {
    BOOL v62 = a4 == 0;
  }
  else {
    BOOL v62 = 1;
  }
  if (!v62) {
    goto LABEL_184;
  }
LABEL_161:
  uint64_t v63 = *((void *)this + 4);
  if (*(unsigned char *)(v63 + 2160)) {
    pthread_mutex_unlock((pthread_mutex_t *)(v63 + 2096));
  }
  if ((*(unsigned int (**)(kdu_thread_entity *))(*(void *)this + 48))(this)) {
    (*(void (**)(kdu_thread_entity *, void))(*(void *)this + 40))(this, **((unsigned __int8 **)this + 5));
  }
  return 1;
}

void sub_1886536C8(_Unwind_Exception *a1)
{
}

BOOL kdu_thread_queue::check_condition(kdu_thread_queue *this, int a2, int a3)
{
  if (a2)
  {
    if (*((int *)this + 29) <= 0) {
      kdu_thread_queue::check_condition();
    }
    if (*((_DWORD *)this + 33) != a3 || *((_DWORD *)this + 31)) {
      return 0;
    }
    return *((_DWORD *)this + 32) == 0;
  }
  else
  {
    if (*((_DWORD *)this + 21)) {
      kdu_thread_entity::process_jobs();
    }
    return *((_DWORD *)this + 22) + *((_DWORD *)this + 19) == 0;
  }
}

uint64_t kdu_thread_entity::process_outstanding_sync_points(kdu_thread_entity *this, kdu_thread_queue *a2)
{
  int v2 = *((_DWORD *)a2 + 29);
  if (v2 < 1)
  {
    char v5 = 0;
  }
  else
  {
    char v5 = 0;
    uint64_t v6 = (char *)a2 + 120;
    uint64_t v7 = (char *)a2 + 152;
    while (*((int *)a2 + 31) <= 0 && *((int *)a2 + 32) <= 0)
    {
      unsigned int v8 = *((_DWORD *)a2 + 33);
      uint64_t v9 = *((void *)a2 + 17);
      if ((v8 & 0x80000000) == 0)
      {
        if (v9) {
          kdu_thread_entity::process_outstanding_sync_points();
        }
        if (v8 == *((_DWORD *)a2 + 94)) {
          kdu_event::set((kdu_event *)(*((void *)this + 4) + 56 * v8 + 2168));
        }
        return v5 & 1;
      }
      if (v9)
      {
        if (*((unsigned char *)a2 + 145)) {
          return v5 & 1;
        }
        uint64_t v10 = *((void *)this + 4);
        if (*((unsigned char *)a2 + 144) && *(int *)(v10 + 128) >= 2 && (uint64_t v11 = *(int *)(v10 + 1560), (int)v11 <= 63))
        {
          *(_DWORD *)(v10 + 1560) = v11 + 1;
          *(void *)(v10 + 8 * v11 + 1568) = v9;
          uint64_t v12 = *((void *)this + 4);
          int v13 = *(_DWORD *)(v12 + 648);
          BOOL v14 = __OFSUB__(v13, 1);
          int v15 = v13 - 1;
          if (v15 < 0 == v14)
          {
            uint64_t v16 = *(unsigned int *)(v12 + 128);
            if ((int)v16 < 2) {
LABEL_44:
            }
              kdu_thread_entity::process_outstanding_sync_points();
            uint64_t v17 = (void *)(v12 + 664);
            uint64_t v18 = 56 * v16;
            uint64_t v19 = -2224;
            while (*v17)
            {
              ++v17;
              v19 -= 56;
              if (v18 + v19 == -2168) {
                goto LABEL_44;
              }
            }
            *(_DWORD *)(v12 + 648) = v15;
            void *v17 = v12 + 1176;
            kdu_event::set((kdu_event *)(*((void *)this + 4) - v19));
          }
        }
        else
        {
          *((unsigned char *)a2 + 145) = 1;
          if (*(unsigned char *)(v10 + 2160))
          {
            pthread_mutex_unlock((pthread_mutex_t *)(v10 + 2096));
            uint64_t v9 = *((void *)a2 + 17);
          }
          (*(void (**)(uint64_t, kdu_thread_entity *, uint64_t))(*(void *)v9 + 16))(v9, this, 0xFFFFFFFFLL);
          if ((*(unsigned int (**)(kdu_thread_entity *))(*(void *)this + 48))(this)) {
            (*(void (**)(kdu_thread_entity *, void))(*(void *)this + 40))(this, **((unsigned __int8 **)this + 5));
          }
          uint64_t v20 = *((void *)this + 4);
          if (*(unsigned char *)(v20 + 2160)) {
            pthread_mutex_lock((pthread_mutex_t *)(v20 + 2096));
          }
          *((unsigned char *)a2 + 145) = 0;
        }
        BOOL v21 = 0;
        *((void *)a2 + 17) = 0;
        int v2 = *((_DWORD *)a2 + 29);
      }
      else
      {
        BOOL v21 = *((void *)a2 + 3) != 0;
      }
      int v22 = v2--;
      *((_DWORD *)a2 + 29) = v2;
      if (v22 >= 2) {
        memmove(v6, v7, 32 * v2);
      }
      if (v21)
      {
        int v23 = (int *)*((void *)a2 + 3);
        if (v23[29] < 1 || (int v24 = v23[32], v24 < 1) || v23[31]) {
          kdu_thread_entity::process_outstanding_sync_points();
        }
        int v25 = v24 - 1;
        v23[32] = v25;
        if (!v25)
        {
          kdu_thread_entity::process_outstanding_sync_points(this, (kdu_thread_queue *)v23);
          int v2 = *((_DWORD *)a2 + 29);
        }
      }
      char v5 = 1;
      if (v2 <= 0) {
        return v5 & 1;
      }
    }
  }
  return v5 & 1;
}

uint64_t kdu_event::wait(pthread_cond_t *this, pthread_mutex_t *a2)
{
  if (LOBYTE(this[1].__sig)) {
    return 1;
  }
  while (BYTE2(this[1].__sig) && !pthread_cond_wait(this, a2))
  {
    if (LOBYTE(this[1].__sig))
    {
      uint64_t result = 1;
      goto LABEL_8;
    }
  }
  uint64_t result = 0;
LABEL_8:
  if (!BYTE1(this[1].__sig)) {
    LOBYTE(this[1].__sig) = 0;
  }
  return result;
}

void kdu_channel_mapping::kdu_channel_mapping(kdu_channel_mapping *this)
{
  *(_DWORD *)this = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  kdu_channel_mapping::clear(this);
}

void sub_188653AD0(_Unwind_Exception *a1)
{
  jp2_colour_converter::clear((j2_colour_converter **)(v1 + 48));
  _Unwind_Resume(a1);
}

j2_colour_converter *kdu_channel_mapping::clear(kdu_channel_mapping *this)
{
  if (*((void *)this + 5))
  {
    int v2 = *(_DWORD *)this;
    if (*(int *)this < 1) {
      goto LABEL_8;
    }
    uint64_t v3 = 0;
    do
    {
      uint64_t v4 = *(void *)(*((void *)this + 5) + 8 * v3);
      if (v4)
      {
        MEMORY[0x18C11C0C0](v4, 0x1000C80BDFB0063);
        int v2 = *(_DWORD *)this;
      }
      ++v3;
    }
    while (v3 < v2);
    if (*((void *)this + 5)) {
LABEL_8:
    }
      MEMORY[0x18C11C0C0]();
  }
  *((void *)this + 5) = 0;
  uint64_t v5 = *((void *)this + 1);
  if (v5) {
    MEMORY[0x18C11C0C0](v5, 0x1000C8052888210);
  }
  *((void *)this + 1) = 0;
  uint64_t v6 = *((void *)this + 2);
  if (v6) {
    MEMORY[0x18C11C0C0](v6, 0x1000C8052888210);
  }
  *((void *)this + 2) = 0;
  uint64_t v7 = *((void *)this + 3);
  if (v7) {
    MEMORY[0x18C11C0C0](v7, 0x1000C8077774924);
  }
  *((void *)this + 3) = 0;
  *(void *)this = 0;
  *((_DWORD *)this + 8) = 0;

  return jp2_colour_converter::clear((j2_colour_converter **)this + 6);
}

_DWORD *kdu_channel_mapping::set_num_channels(_DWORD *this, int a2)
{
  if (a2 < 0) {
    kdu_channel_mapping::set_num_channels();
  }
  if (*this < a2) {
    operator new[]();
  }
  *this = a2;
  return this;
}

uint64_t kdu_channel_mapping::configure(kdu_channel_mapping *a1, unsigned int *a2)
{
  uint64_t v9 = a2;
  kdu_channel_mapping::clear(a1);
  if ((int)kdu_codestream::get_num_components(&v9, 1) < 3) {
    int v3 = 1;
  }
  else {
    int v3 = 3;
  }
  kdu_channel_mapping::set_num_channels(a1, v3);
  uint64_t v8 = 0;
  kdu_codestream::get_subsampling((kd_codestream **)&v9, 0, (uint64_t)&v8, 1);
  if (*(int *)a1 < 1)
  {
    LODWORD(v4) = 0;
  }
  else
  {
    uint64_t v4 = 0;
    do
    {
      *(_DWORD *)(*((void *)a1 + 1) + 4 * v4) = v4;
      *(_DWORD *)(*((void *)a1 + 2) + 4 * v4) = kdu_codestream::get_bit_depth((kdu_codestream *)&v9, v4, 1);
      *(unsigned char *)(*((void *)a1 + 3) + v4) = kdu_codestream::get_signed((kdu_codestream *)&v9, v4, 1);
      uint64_t v7 = 0;
      kdu_codestream::get_subsampling((kd_codestream **)&v9, v4, (uint64_t)&v7, 1);
      if (v7 != v8) {
        break;
      }
      ++v4;
    }
    while (v4 < *(int *)a1);
  }
  int v5 = *(_DWORD *)a1;
  if ((int)v4 < *(_DWORD *)a1)
  {
    int v5 = 1;
    *(_DWORD *)a1 = 1;
  }
  *((_DWORD *)a1 + 1) = v5;
  return 1;
}

void kdu_channel_mapping::configure(j2_colour_converter **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v9 = a3;
  uint64_t v7 = a6;
  uint64_t v8 = a5;
  kdu_channel_mapping::clear((kdu_channel_mapping *)a1);
  jp2_colour_converter::init(a1 + 6);
}

void sub_188654264(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188654270(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

uint64_t kdu_channel_mapping::add_alpha_to_configuration(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, char a6)
{
  uint64_t v27 = a4;
  uint64_t v28 = a2;
  uint64_t v26 = a5;
  int num_colours = jp2_channels::get_num_colours((jp2_channels *)&v28);
  kdu_channel_mapping::set_num_channels((_DWORD *)a1, *(_DWORD *)(a1 + 4));
  if (num_colours < 1) {
    return 0;
  }
  unsigned int v10 = 0;
  int v11 = -1;
  int v12 = -1;
  do
  {
    int v13 = v12;
    *(void *)int v25 = 0;
    int v14 = v11;
    int v24 = 0;
    int v12 = -1;
    if (jp2_channels::get_opacity_mapping((jp2_channels *)&v28, v10, v25, &v25[1], &v24))
    {
      int v11 = -1;
      if (v24 == a3)
      {
        int v12 = v25[0];
        if (v10)
        {
          BOOL v15 = v13 == v25[0] || v14 == v25[1];
          if (v15) {
            int v12 = v13;
          }
          else {
            int v12 = -1;
          }
          if (v15) {
            int v11 = v14;
          }
          else {
            int v11 = -1;
          }
        }
        else
        {
          int v11 = v25[1];
        }
      }
    }
    else
    {
      int v11 = -1;
    }
    ++v10;
  }
  while (num_colours != v10);
  if (v12 < 0 && (a6 & 1) == 0)
  {
    for (unsigned int i = 0; i != num_colours; ++i)
    {
      *(void *)int v25 = 0;
      int v24 = 0;
      unsigned int v17 = -1;
      if (jp2_channels::get_premult_mapping((jp2_channels *)&v28, i, v25, &v25[1], &v24))
      {
        int v18 = -1;
        if (v24 == a3)
        {
          unsigned int v17 = v25[0];
          if (i)
          {
            BOOL v19 = v12 == v25[0] || v11 == v25[1];
            if (v19) {
              unsigned int v17 = v12;
            }
            else {
              unsigned int v17 = -1;
            }
            if (v19) {
              int v18 = v11;
            }
            else {
              int v18 = -1;
            }
          }
          else
          {
            int v18 = v25[1];
          }
        }
      }
      else
      {
        int v18 = -1;
      }
      int v11 = v18;
      int v12 = v17;
    }
    if ((v17 & 0x80000000) == 0) {
      goto LABEL_37;
    }
    return 0;
  }
  unsigned int v17 = v12;
  int v18 = v11;
  if (v12 < 0) {
    return 0;
  }
LABEL_37:
  kdu_channel_mapping::set_num_channels((_DWORD *)a1, *(_DWORD *)(a1 + 4) + 1);
  uint64_t v20 = *(int *)(a1 + 4);
  *(_DWORD *)(*(void *)(a1 + 8) + 4 * v20) = v17;
  if ((v18 & 0x80000000) == 0)
  {
    int num_entries = jp2_palette::get_num_entries((jp2_palette *)&v27);
    if (num_entries <= 1024)
    {
      int v22 = 0;
      do
        ++v22;
      while (1 << v22 < num_entries);
      *(_DWORD *)(a1 + 32) = v22;
      if (!*(void *)(*(void *)(a1 + 40) + 8 * v20)) {
        operator new[]();
      }
      kdu_channel_mapping::add_alpha_to_configuration();
    }
    kdu_channel_mapping::add_alpha_to_configuration();
  }
  *(_DWORD *)(*(void *)(a1 + 16) + 4 * v20) = jp2_dimensions::get_bit_depth((jp2_dimensions *)&v26, v17);
  *(unsigned char *)(*(void *)(a1 + 24) + v20) = jp2_dimensions::get_signed((jp2_dimensions *)&v26, v17);
  return 1;
}

void kdu_region_decompressor::kdu_region_decompressor(kdu_region_decompressor *this)
{
  *(void *)this = &unk_1ED4E55B8;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 13) = 0;
  *(void *)((char *)this + 44) = 0;
  *((unsigned char *)this + 40) = 1;
  *((void *)this + 14) = 0;
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 2) = 0;
  *((unsigned char *)this + 120) = 0;
  *((_DWORD *)this + 55) = 0;
  *(void *)((char *)this + 188) = 0;
  *((void *)this + 29) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 7) = 0;
  *(_DWORD *)((char *)this + 79) = 0;
  *(void *)((char *)this + 84) = 0;
  *(void *)((char *)this + 100) = 0;
  *(void *)((char *)this + 92) = 0;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 156) = 0u;
  *(_OWORD *)((char *)this + 140) = 0u;
  *(_OWORD *)((char *)this + 124) = 0u;
  *((void *)this + 25) = 0;
  *((void *)this + 26) = 0;
}

void kdu_region_decompressor::~kdu_region_decompressor(kdu_region_decompressor *this)
{
  *(void *)this = &unk_1ED4E55B8;
  *((unsigned char *)this + 80) = 1;
  kdu_region_decompressor::finish(this);
  uint64_t v2 = *((void *)this + 25);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1020C809FEE3416);
  }
  uint64_t v3 = *((void *)this + 26);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C8052888210);
  }
  uint64_t v4 = *((void *)this + 21);
  if (v4) {
    MEMORY[0x18C11C0C0](v4, 0x1020C80E3042B83);
  }
  uint64_t v5 = *((void *)this + 29);
  if (v5) {
    MEMORY[0x18C11C0C0](v5, 0x10C80436913F5);
  }
  uint64_t v6 = *((void *)this + 8);
  if (v6) {
    MEMORY[0x18C11C0C0](v6, 0x1000C8077774924);
  }
}

{
  uint64_t vars8;

  kdu_region_decompressor::~kdu_region_decompressor(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t kdu_region_decompressor::finish(kdu_region_decompressor *this)
{
  uint64_t v2 = (kdu_thread_entity *)*((void *)this + 2);
  if (v2)
  {
    uint64_t v3 = (kdu_thread_queue *)*((void *)this + 3);
    if (v3) {
      kdu_thread_entity::terminate(v2, v3, 0, 0);
    }
  }
  *((void *)this + 3) = 0;
  if (*((unsigned char *)this + 80))
  {
    uint64_t v4 = 0;
  }
  else
  {
    if (*((unsigned char *)this + 120)) {
      kdu_tile::close((uint64_t **)this + 14, *((kdu_thread_entity **)this + 2));
    }
    uint64_t v4 = 1;
  }
  uint64_t v5 = *((void *)this + 4);
  *((unsigned char *)this + 120) = 0;
  *((unsigned char *)this + 80) = 0;
  *((void *)this + 2) = 0;
  if (v5) {
    kdu_multi_synthesis::destroy((uint64_t *)this + 4);
  }
  if (*((int *)this + 48) >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 32;
    do
    {
      uint64_t v8 = *((void *)this + 25) + v7;
      *(void *)(v8 - 8) = 0;
      *(_DWORD *)uint64_t v8 = 0;
      *(_WORD *)(v8 + 6) = 0;
      *(void *)(v8 + 8) = 0;
      uint64_t v9 = *((void *)this + 25) + v7;
      *(_DWORD *)(v9 + 16) = 0;
      *(_WORD *)(v9 + 22) = 0;
      *(void *)(v9 + 24) = 0;
      ++v6;
      v7 += 112;
    }
    while (v6 < *((int *)this + 48));
  }
  if (*((int *)this + 40) >= 1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    do
    {
      for (uint64_t i = 0; i != 48; i += 16)
      {
        uint64_t v13 = *((void *)this + 21) + v10 + i;
        *(_DWORD *)(v13 + 8) = 0;
        *(_WORD *)(v13 + 14) = 0;
        *(void *)(v13 + 16) = 0;
      }
      uint64_t v14 = *((void *)this + 21) + 96 * v11++;
      *(_OWORD *)(v14 + 72) = 0uLL;
      *(_OWORD *)(v14 + 56) = 0uLL;
      v10 += 96;
    }
    while (v11 < *((int *)this + 40));
  }
  *((void *)this + 9) = 0;
  *((_DWORD *)this + 11) = 0;
  *((_DWORD *)this + 12) = 0;
  *((unsigned char *)this + 40) = 1;
  *((_DWORD *)this + 48) = 0;
  *(void *)((char *)this + 148) = 0;
  *(void *)((char *)this + 140) = 0;
  return v4;
}

uint64_t kdu_region_decompressor::set_num_channels(uint64_t this, int a2)
{
  uint64_t v2 = this;
  if (*(_DWORD *)(this + 156) < a2)
  {
    *(_DWORD *)(this + 156) = a2;
    uint64_t v3 = *(void *)(this + 168);
    int v4 = a2;
    if (v3)
    {
      MEMORY[0x18C11C0C0](v3, 0x1020C80E3042B83);
      int v4 = *(_DWORD *)(v2 + 156);
    }
    is_mul_ok(v4, 0x60uLL);
    operator new[]();
  }
  *(_DWORD *)(this + 160) = a2;
  *(_DWORD *)(this + 164) = a2;
  if (a2 >= 1)
  {
    uint64_t v5 = a2;
    uint64_t v6 = (unsigned char *)(*(void *)(this + 168) + 92);
    do
    {
      *(void *)(v6 - 92) = 0;
      *(void *)(v6 - 12) = 0;
      *((_DWORD *)v6 - 1) = 0;
      *uint64_t v6 = 0;
      v6 += 96;
      --v5;
    }
    while (v5);
  }
  return this;
}

uint64_t kdu_region_decompressor::add_component(kdu_region_decompressor *this, int a2)
{
  uint64_t v2 = *((unsigned int *)this + 48);
  if ((int)v2 < 1)
  {
LABEL_5:
    if (v2 == *((_DWORD *)this + 47))
    {
      int v6 = (2 * v2) | 1;
      *((_DWORD *)this + 47) = v6;
      is_mul_ok(v6, 0x70uLL);
      operator new[]();
    }
    *((_DWORD *)this + 48) = v2 + 1;
    uint64_t v8 = *((void *)this + 25);
    *(_DWORD *)(*((void *)this + 26) + 4 * (int)v2) = a2;
    uint64_t result = v8 + 112 * (int)v2;
    *(_DWORD *)uint64_t result = v2;
    *(_DWORD *)(result + 8) = 0;
    *(unsigned char *)(result + 17) = 0;
  }
  else
  {
    uint64_t v3 = 0;
    int v4 = (int *)*((void *)this + 26);
    while (1)
    {
      int v5 = *v4++;
      if (v5 == a2) {
        return *((void *)this + 25) + v3;
      }
      v3 += 112;
      if (112 * v2 == v3) {
        goto LABEL_5;
      }
    }
  }
  return result;
}

unint64_t find_render_dims(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4 = a4 >> 32;
  uint64_t v5 = (a3 >> 32) - 1;
  uint64_t v6 = SHIDWORD(a3) * (uint64_t)SHIDWORD(a1) - (v5 >> 1);
  if (a4 >> 32 <= 1) {
    unint64_t v4 = 1;
  }
  if (v6 <= 0)
  {
    unint64_t v8 = ((v5 >> 1) - SHIDWORD(a3) * (uint64_t)SHIDWORD(a1)) / v4;
    if (v8 >= 0x80000001) {
      goto LABEL_24;
    }
    unint64_t v7 = -(uint64_t)v8;
  }
  else
  {
    unint64_t v7 = (v6 - 1) / v4;
    if (v7 >= 0x7FFFFFFF) {
      goto LABEL_24;
    }
    LODWORD(v7) = v7 + 1;
  }
  uint64_t v9 = v5 >> 1;
  uint64_t v10 = (int)(((a2 & 0xFFFFFFFF00000000) + a1) >> 32) * (uint64_t)SHIDWORD(a3);
  BOOL v11 = v10 <= v9;
  uint64_t v12 = v10 - v9;
  if (v11)
  {
    if (-v12 / v4 >= 0x80000001) {
      goto LABEL_24;
    }
  }
  else if ((v12 - 1) / v4 >= 0x7FFFFFFF)
  {
    goto LABEL_24;
  }
  unint64_t v13 = (int)a4;
  uint64_t v14 = (int)a3 - 1;
  uint64_t v15 = (int)a3 * (uint64_t)(int)a1 - (v14 >> 1);
  if ((int)a4 <= 1) {
    unint64_t v13 = 1;
  }
  if (v15 <= 0)
  {
    unint64_t v17 = ((v14 >> 1) - (int)a3 * (uint64_t)(int)a1) / v13;
    if (v17 >= 0x80000001) {
      goto LABEL_24;
    }
    unint64_t v16 = -(uint64_t)v17;
  }
  else
  {
    unint64_t v16 = (v15 - 1) / v13;
    if (v16 >= 0x7FFFFFFF) {
      goto LABEL_24;
    }
    LODWORD(v16) = v16 + 1;
  }
  uint64_t v18 = v14 >> 1;
  uint64_t v19 = ((int)a2 + (int)a1) * (uint64_t)(int)a3;
  BOOL v11 = v19 <= v18;
  uint64_t v20 = v19 - v18;
  if (!v11)
  {
    if ((v20 - 1) / v13 < 0x7FFFFFFF) {
      return v16 | ((unint64_t)v7 << 32);
    }
LABEL_24:
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  if (-v20 / v13 >= 0x80000001) {
    goto LABEL_24;
  }
  return v16 | ((unint64_t)v7 << 32);
}

uint64_t kdu_region_decompressor::start(kdu_region_decompressor *this, kd_codestream *a2, int *a3, int a4, int a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, int a12, char a13, uint64_t a14, char *a15)
{
  uint64_t v21 = a14;
  *((void *)&v94 + 1) = a8;
  v95[0] = a2;
  *(void *)&long long v94 = a7;
  *((void *)this + 2) = a14;
  if (a14) {
    uint64_t v21 = kdu_thread_entity::add_queue(a14, 0, a15, (uint64_t)"region decompressor");
  }
  *(void *)((char *)this + 140) = 0;
  *((void *)this + 3) = v21;
  *((void *)this + 9) = a2;
  *((unsigned char *)this + 81) = a11;
  *((unsigned char *)this + 82) = a13;
  *((unsigned char *)this + 80) = 0;
  *((unsigned char *)this + 120) = 0;
  *((_DWORD *)this + 54) = a5;
  *((_DWORD *)this + 48) = 0;
  *((_WORD *)this + 92) = 0;
  *((void *)this + 22) = 0;
  *(void *)((char *)this + 148) = 0;
  if (a3)
  {
    if (*a3 <= 0)
    {
      uint64_t v93 = 0;
      long long v91 = 0u;
      long long v92 = 0u;
      kdu_error::kdu_error((kdu_error *)&v91, "Error in Kakadu Region Decompressor:\n");
      kdu_error::~kdu_error((kdu_error *)&v91);
    }
    kdu_region_decompressor::set_num_channels((uint64_t)this, *a3);
    int v22 = a3[1];
    *((_DWORD *)this + 41) = v22;
    if (v22 > *((_DWORD *)this + 40))
    {
      uint64_t v93 = 0;
      long long v91 = 0u;
      long long v92 = 0u;
      kdu_error::kdu_error((kdu_error *)&v91, "Error in Kakadu Region Decompressor:\n");
      kdu_error::~kdu_error((kdu_error *)&v91);
    }
    uint64_t v23 = *((void *)a3 + 6);
    *((void *)this + 22) = a3 + 12;
    if (v23 && jp2_colour_converter::is_non_trivial((jp2_colour_converter *)(a3 + 12)))
    {
      uint64_t v24 = *((void *)this + 22);
    }
    else
    {
      uint64_t v24 = 0;
      *((void *)this + 22) = 0;
    }
    *((unsigned char *)this + 184) = v24 != 0;
    if (*a3 >= 1)
    {
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      do
      {
        uint64_t v27 = kdu_region_decompressor::add_component(this, *(_DWORD *)(*((void *)a3 + 1) + 4 * v26));
        uint64_t v28 = *((void *)this + 21);
        *(void *)(v28 + v25) = v27;
        int v29 = a3[8];
        if (v29 <= 0)
        {
          *(void *)(v28 + v25 + 80) = 0;
        }
        else
        {
          uint64_t v30 = *(void *)(*((void *)a3 + 5) + 8 * v26);
          *(void *)(v28 + v25 + 80) = v30;
          if (v30) {
            *(_DWORD *)(v27 + 8) = v29;
          }
        }
        uint64_t v31 = v28 + v25;
        *(_DWORD *)(v31 + 88) = *(_DWORD *)(*((void *)a3 + 2) + 4 * v26);
        *(unsigned char *)(v31 + 92) = *(unsigned char *)(*((void *)a3 + 3) + v26++);
        *(void *)(v31 + 64) = 0;
        *(void *)(v31 + 72) = 0;
        *(void *)(v31 + 56) = 0;
        v25 += 96;
      }
      while (v26 < *a3);
    }
  }
  else
  {
    kdu_region_decompressor::set_num_channels((uint64_t)this, 1);
    uint64_t v32 = kdu_region_decompressor::add_component(this, a4);
    uint64_t v33 = (uint64_t *)*((void *)this + 21);
    *uint64_t v33 = v32;
    v33[10] = 0;
  }
  if (SHIDWORD(a10) < 1 || (int)a10 <= 0)
  {
    uint64_t v93 = 0;
    long long v91 = 0u;
    long long v92 = 0u;
    kdu_error::kdu_error((kdu_error *)&v91, "Error in Kakadu Region Decompressor:\n");
    kdu_error::~kdu_error((kdu_error *)&v91);
  }
  if (SHIDWORD(a9) < SHIDWORD(a10) || (int)a9 < (int)a10)
  {
    uint64_t v93 = 0;
    long long v91 = 0u;
    long long v92 = 0u;
    kdu_error::kdu_error((kdu_error *)&v91, "Error in Kakadu Region Decompressor:\n");
    kdu_error::~kdu_error((kdu_error *)&v91);
  }
  int v34 = a12;
  kdu_codestream::apply_input_restrictions((uint64_t)v95, *((_DWORD *)this + 48), *((void *)this + 26), a5, a6, 0, a12);
  int v84 = a5;
  uint64_t v35 = (int32x4_t *)**((void **)this + 21);
  uint64_t v89 = 0;
  uint64_t v90 = 0;
  kdu_codestream::get_subsampling(v95, v35->i32[0], (uint64_t)&v90, 1);
  int v36 = v90;
  int v37 = HIDWORD(v90);
  LODWORD(v38) = *((_DWORD *)this + 48);
  if ((int)v38 >= 1)
  {
    uint64_t v82 = v35;
    int v83 = a6;
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    do
    {
      uint64_t v41 = *((void *)this + 25);
      uint64_t v42 = v41 + v39;
      *(_DWORD *)(v41 + v39 + 4) = kdu_codestream::get_bit_depth((kdu_codestream *)v95, *(_DWORD *)(v41 + v39), 1);
      *(unsigned char *)(v42 + 16) = kdu_codestream::get_signed((kdu_codestream *)v95, *(_DWORD *)(v41 + v39), 1);
      *(_DWORD *)(v42 + 12) = 0;
      kdu_codestream::get_subsampling(v95, *(_DWORD *)(v41 + v39), (uint64_t)&v89, 1);
      if (SHIDWORD(v89) > v37) {
        int v37 = HIDWORD(v89);
      }
      uint64_t v88 = SHIDWORD(a9) * (uint64_t)SHIDWORD(v89);
      uint64_t v86 = SHIDWORD(a10) * (uint64_t)SHIDWORD(v90);
      if ((int)v89 > v36) {
        int v36 = v89;
      }
      uint64_t v87 = (int)a9 * (uint64_t)(int)v89;
      uint64_t v85 = (int)a10 * (uint64_t)(int)v90;
      if ((reduce_ratio_to_ints(&v88, &v86) & 1) == 0 || (reduce_ratio_to_ints(&v87, &v85) & 1) == 0)
      {
        uint64_t v93 = 0;
        long long v91 = 0u;
        long long v92 = 0u;
        kdu_error::kdu_error((kdu_error *)&v91, "Error in Kakadu Region Decompressor:\n");
        (*(void (**)(long long *, const char *))(v91 + 16))(&v91, "Unable to represent all component expansion factors as rational numbers whose numerator and denominator can both be expressed as 32-bit signed integers.  This is a very unusual condition.");
        kdu_error::~kdu_error((kdu_error *)&v91);
      }
      int v43 = v88;
      int v44 = v86;
      if (v88 < v86 || v87 < v85)
      {
        uint64_t v93 = 0;
        long long v91 = 0u;
        long long v92 = 0u;
        kdu_error::kdu_error((kdu_error *)&v91, "Error in Kakadu Region Decompressor:\n");
        kdu_error::~kdu_error((kdu_error *)&v91);
      }
      uint64_t v45 = v88 / v86;
      if (!(v88 % v86))
      {
        v88 /= v86;
        uint64_t v86 = 1;
        int v44 = 1;
        int v43 = v45;
      }
      int v46 = v87;
      int v47 = v85;
      uint64_t v48 = v87 / v85;
      if (!(v87 % v85))
      {
        v87 /= v85;
        uint64_t v85 = 1;
        int v47 = 1;
        int v46 = v48;
      }
      uint64_t v49 = v41 + v39;
      *(_DWORD *)(v49 + 80) = v46;
      *(_DWORD *)(v49 + 84) = v43;
      *(_DWORD *)(v49 + 88) = v47;
      *(_DWORD *)(v49 + 92) = v44;
      *(void *)(v49 + 96) = 0;
      unsigned int v50 = *(_DWORD *)(v41 + v39);
      int v51 = (int8x8_t *)(v41 + v39 + 104);
      kdu_codestream::get_registration(v95, v50, *(void *)(v49 + 88), v51, 1);
      if (v39)
      {
        if (*((unsigned char *)this + 184))
        {
          uint64_t v52 = (_DWORD *)*((void *)this + 25);
          if (*(_DWORD *)(v49 + 80) != v52[20] || *(_DWORD *)(v49 + 88) != v52[22] || v51->i32[0] != v52[26]) {
            *((_WORD *)this + 92) = 256;
          }
        }
      }
      ++v40;
      uint64_t v38 = *((int *)this + 48);
      v39 += 112;
    }
    while (v40 < v38);
    int v34 = a12;
    a6 = v83;
    uint64_t v35 = v82;
  }
  uint64_t v53 = *((unsigned int *)this + 40);
  if ((int)v53 >= 1)
  {
    uint64_t v54 = *((void *)this + 21) + 88;
    uint64_t v55 = *((unsigned int *)this + 40);
    do
    {
      if (!*(_DWORD *)v54)
      {
        uint64_t v56 = *(void *)(v54 - 88);
        *(_DWORD *)uint64_t v54 = *(_DWORD *)(v56 + 4);
        *(unsigned char *)(v54 + 4) = *(unsigned char *)(v56 + 16);
      }
      v54 += 96;
      --v55;
    }
    while (v55);
    uint64_t v57 = (_WORD *)(*((void *)this + 21) + 94);
    do
    {
      uint64_t v58 = *(void *)(v57 - 47);
      ++*(_DWORD *)(v58 + 12);
      *uint64_t v57 = 0;
      if (!*(void *)(v57 - 7))
      {
        int v59 = *((_DWORD *)this + 2);
        if (v59 >= 16) {
          int v59 = 16;
        }
        int v60 = *(_DWORD *)(v58 + 4);
        BOOL v61 = __OFSUB__(v59, v60);
        int v62 = v59 - v60;
        if (!((v62 < 0) ^ v61 | (v62 == 0))) {
          *uint64_t v57 = ((0x10000 << v62) - 0x10000) / ((-1 << v62) + (1 << v59));
        }
      }
      v57 += 48;
      --v53;
    }
    while (v53);
  }
  kdu_codestream::apply_input_restrictions((uint64_t)v95, v38, *((void *)this + 26), v84, a6, 0, v34);
  kdu_codestream::get_dims((kdu_codestream *)v95, v35->i32[0], v35 + 4, 1);
  *(void *)((char *)this + 140) = find_render_dims(v35[4].i64[0], v35[4].i64[1], v35[5].i64[0], v35[5].i64[1]);
  *(void *)((char *)this + 148) = v63;
  long long v91 = *(_OWORD *)((char *)this + 140);
  kdu_dims::operator&=(&v91, (int *)&v94);
  if (v94 != v91)
  {
    uint64_t v93 = 0;
    long long v91 = 0u;
    long long v92 = 0u;
    kdu_error::kdu_error((kdu_error *)&v91, "Error in Kakadu Region Decompressor:\n");
    kdu_error::~kdu_error((kdu_error *)&v91);
  }
  __int32 v64 = v35[5].i32[3];
  LODWORD(v65) = v35[5].i32[1];
  unint64_t v66 = SDWORD1(v94) * (uint64_t)v64;
  if ((int)v65 <= 1) {
    unint64_t v65 = 1;
  }
  else {
    unint64_t v65 = v65;
  }
  if ((v66 & 0x8000000000000000) != 0)
  {
    unint64_t v67 = ~v66 / v65;
    if (v67 >> 31) {
      goto LABEL_92;
    }
    LODWORD(v67) = ~v67;
  }
  else
  {
    unint64_t v67 = v66 / v65;
    if (v67 >> 31) {
      goto LABEL_83;
    }
  }
  uint64_t v68 = v64 * (uint64_t)(HIDWORD(v91) + DWORD1(v94));
  if (v68 <= 0)
  {
    unint64_t v70 = -v68 / v65;
    if (v70 > 0x80000000) {
      goto LABEL_94;
    }
    unint64_t v69 = -(uint64_t)v70;
  }
  else
  {
    unint64_t v69 = (v68 - 1) / v65;
    if (v69 > 0x7FFFFFFE) {
      goto LABEL_94;
    }
    LODWORD(v69) = v69 + 1;
  }
  __int32 v71 = v35[5].i32[2];
  LODWORD(v72) = v35[5].i32[0];
  unint64_t v73 = (int)v94 * (uint64_t)v71;
  if ((int)v72 <= 1) {
    unint64_t v72 = 1;
  }
  else {
    unint64_t v72 = v72;
  }
  if ((v73 & 0x8000000000000000) != 0)
  {
    unint64_t v74 = ~v73 / v72;
    if (!(v74 >> 31))
    {
      LODWORD(v74) = ~v74;
      goto LABEL_86;
    }
LABEL_92:
    int v75 = "(num >= (kdu_long) KDU_INT32_MIN)";
    int v76 = 254;
LABEL_93:
    __assert_rtn("long_floor_ratio", "kdu_utils.h", v76, v75);
  }
  unint64_t v74 = v73 / v72;
  if (v74 >> 31)
  {
LABEL_83:
    int v75 = "(num <= (kdu_long) KDU_INT32_MAX)";
    int v76 = 259;
    goto LABEL_93;
  }
LABEL_86:
  uint64_t v77 = v71 * (uint64_t)(DWORD2(v91) + (int)v94);
  if (v77 <= 0)
  {
    unint64_t v79 = -v77 / v72;
    if (v79 <= 0x80000000)
    {
      unint64_t v78 = -(uint64_t)v79;
      goto LABEL_91;
    }
LABEL_94:
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  unint64_t v78 = (v77 - 1) / v72;
  if (v78 >= 0x7FFFFFFF) {
    goto LABEL_94;
  }
  LODWORD(v78) = v78 + 1;
LABEL_91:
  long long v91 = 0uLL;
  kdu_codestream::map_region(v95, v35->i32[0], (v74 - 2 * v36 / (int)v90) | ((unint64_t)(v67 - 2 * v37 / SHIDWORD(v90)) << 32), (2 * v36 / (int)v90 - (v74 - 2 * v36 / (int)v90) + v78) | ((unint64_t)(2 * v37 / SHIDWORD(v90) - (v67 - 2 * v37 / SHIDWORD(v90)) + v69) << 32), (uint64_t)&v91, 1);
  kdu_codestream::apply_input_restrictions((uint64_t)v95, *((_DWORD *)this + 48), *((void *)this + 26), v84, a6, (int *)&v91, v34);
  kdu_codestream::get_valid_tiles((kdu_codestream *)v95, (int32x4_t *)((char *)this + 84));
  *(void *)((char *)this + 100) = *(void *)((char *)this + 84);
  *((unsigned char *)this + 120) = 0;
  return 1;
}

void sub_1886557C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886557D0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  if (v24 == 1)
  {
    uint64_t v26 = (unsigned int *)__cxa_begin_catch(v25);
    if (a9) {
      (*(void (**)(uint64_t, void))(*(void *)a9 + 32))(a9, *v26);
    }
    kdu_region_decompressor::finish(v23);
    __cxa_end_catch();
    JUMPOUT(0x188655758);
  }
  _Unwind_Resume(v25);
}

uint64_t reduce_ratio_to_ints(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  if (*a1 < 1) {
    return 0;
  }
  uint64_t v3 = *a2;
  if (*a2 < 1) {
    return 0;
  }
  if (!(v2 % (unint64_t)v3))
  {
    *a1 = v2 / (unint64_t)v3;
    uint64_t v3 = 1;
    *a2 = 1;
    uint64_t v2 = *a1;
  }
  if (v2 <= 0x7FFFFFFF && !((unint64_t)v3 >> 31)) {
    return 1;
  }
  uint64_t v5 = 2;
  while (1)
  {
    if (v2 >= v3) {
      uint64_t v6 = v3;
    }
    else {
      uint64_t v6 = v2;
    }
    while (v2 % v5 || v3 % v5)
    {
      if (++v5 >= v6) {
        return 0;
      }
    }
    *a1 = v2 / v5;
    uint64_t v3 = *a2 / v5;
    *a2 = v3;
    uint64_t v2 = *a1;
    if (*a1 <= 0x7FFFFFFF)
    {
      uint64_t v4 = 1;
      if (v3 <= 0x7FFFFFFF) {
        break;
      }
    }
  }
  return v4;
}

kdu_thread_entity *kdu_region_decompressor::open_tile(kdu_region_decompressor *this)
{
  if (*((unsigned char *)this + 120)) {
    kdu_region_decompressor::open_tile();
  }
  if (*((_DWORD *)this + 25) - *((_DWORD *)this + 21) >= *((_DWORD *)this + 23)
    || *((_DWORD *)this + 26) - *((_DWORD *)this + 22) >= *((_DWORD *)this + 24))
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  unint64_t v2 = *(void *)((char *)this + 100);
  *((void *)this + 14) = kdu_codestream::open_tile((uint64_t *)this + 9, v2, *((kdu_thread_entity **)this + 2));
  if ((int)kdu_codestream::get_min_dwt_levels((kdu_region_decompressor *)((char *)this + 72)) >= *((_DWORD *)this + 54)
    && kdu_codestream::can_flip((kdu_region_decompressor *)((char *)this + 72)))
  {
    *((unsigned char *)this + 120) = 1;
    int v3 = *((_DWORD *)this + 26) + 1;
    *((_DWORD *)this + 26) = v3;
    int v4 = *((_DWORD *)this + 22);
    if (v3 - v4 >= *((_DWORD *)this + 24))
    {
      ++*((_DWORD *)this + 25);
      *((_DWORD *)this + 26) = v4;
    }
    if (*((int *)this + 48) >= 1)
    {
      uint64_t v5 = 0;
      uint64_t v6 = 0;
      do
      {
        unint64_t v7 = (int32x4_t *)(*((void *)this + 25) + v5);
        v7[1].i64[1] = 0;
        v7[1].i8[1] = *((unsigned char *)this + 81) ^ 1;
        v7[1].i8[3] = 0;
        kdu_codestream::get_tile_dims((uint64_t *)this + 9, v2, v7->i32[0], v7 + 4, 1);
        ++v6;
        v5 += 112;
      }
      while (v6 < *((int *)this + 48));
    }
    kdu_multi_synthesis::create();
  }
  unint64_t v8 = (kdu_thread_entity *)*((void *)this + 2);

  return kdu_tile::close((uint64_t **)this + 14, v8);
}

uint64_t kdu_line_buf::pre_create(kdu_line_buf *this, kdu_sample_allocator *a2, int a3, char a4, int a5, unsigned __int8 a6, char a7)
{
  if (*((unsigned char *)this + 7) || *((void *)this + 1)) {
    kdu_line_buf::pre_create();
  }
  *(_DWORD *)this = a3;
  if (a5) {
    char v11 = 2;
  }
  else {
    char v11 = 0;
  }
  *((unsigned char *)this + 6) = v11 | a4;
  *((void *)this + 1) = a2;
  *((unsigned char *)this + 4) = a6;
  if (a5) {
    char v12 = 7;
  }
  else {
    char v12 = 3;
  }
  unsigned __int8 v13 = (v12 & -a7) + a7;
  *((unsigned char *)this + 5) = v13;
  kdu_sample_allocator::pre_alloc((uint64_t)a2, a5, a6, a3 + v13, 1);
  uint64_t result = kdu_sample_allocator::pre_alloc((uint64_t)a2, a5, *((unsigned __int8 *)this + 4), *((unsigned __int8 *)this + 5) + a3, 1);
  *((unsigned char *)this + 7) = 1;
  return result;
}

uint64_t kdu_sample_allocator::finalize(uint64_t this)
{
  if (!*(unsigned char *)this) {
    kdu_sample_allocator::finalize();
  }
  *(unsigned char *)this = 0;
  int v1 = *(_DWORD *)(this + 4);
  if (v1 > *(_DWORD *)(this + 12))
  {
    *(_DWORD *)(this + 12) = v1;
    uint64_t v2 = *(void *)(this + 24);
    if (v2) {
      MEMORY[0x18C11C0C0](v2, 0x1000C8077774924);
    }
    operator new[]();
  }
  if (v1 && !*(void *)(this + 16)) {
    kdu_sample_allocator::finalize();
  }
  return this;
}

uint64_t kdu_line_buf::create(uint64_t this)
{
  if (*(unsigned char *)(this + 7))
  {
    uint64_t v1 = this;
    *(unsigned char *)(this + 7) = 0;
    char v2 = *(unsigned char *)(this + 6);
    int v3 = *(kdu_sample_allocator **)(this + 8);
    int v4 = *(unsigned __int8 *)(v1 + 4);
    int v5 = *(_DWORD *)v1 + *(unsigned __int8 *)(v1 + 5);
    if ((v2 & 2) != 0) {
      this = kdu_sample_allocator::alloc16(v3, v4, v5);
    }
    else {
      this = kdu_sample_allocator::alloc32(v3, v4, v5);
    }
    *(void *)(v1 + 8) = this;
  }
  return this;
}

uint64_t *kdu_region_decompressor::close_tile(kdu_region_decompressor *this)
{
  if (!*((unsigned char *)this + 120)) {
    kdu_region_decompressor::close_tile();
  }
  char v2 = (kdu_thread_entity *)*((void *)this + 2);
  if (v2 && *((void *)this + 3))
  {
    kdu_thread_entity::terminate(*((kdu_thread_entity **)this + 2), *((kdu_thread_queue **)this + 3), 1, 0);
    char v2 = (kdu_thread_entity *)*((void *)this + 2);
  }
  *((unsigned char *)this + 120) = 0;
  kdu_tile::close((uint64_t **)this + 14, v2);
  uint64_t result = (uint64_t *)((char *)this + 32);
  if (*((void *)this + 4)) {
    uint64_t result = (uint64_t *)kdu_multi_synthesis::destroy(result);
  }
  if (*((int *)this + 48) >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = *((void *)this + 25) + v4;
      *(void *)(v6 + 24) = 0;
      *(_DWORD *)(v6 + 32) = 0;
      *(_WORD *)(v6 + 54) = 0;
      *(void *)(v6 + 56) = 0;
      ++v5;
      *(void *)(v6 + 38) = 0;
      *(void *)(v6 + 44) = 0;
      v4 += 112;
    }
    while (v5 < *((int *)this + 48));
  }
  if (*((int *)this + 40) >= 1)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    do
    {
      for (uint64_t i = 0; i != 48; i += 16)
      {
        uint64_t v10 = *((void *)this + 21) + v7 + i;
        *(_DWORD *)(v10 + 8) = 0;
        *(_WORD *)(v10 + 14) = 0;
        *(void *)(v10 + 16) = 0;
      }
      char v11 = (void *)(*((void *)this + 21) + 96 * v8++);
      v11[7] = 0;
      v11[8] = 0;
      v11[9] = 0;
      v7 += 96;
    }
    while (v8 < *((int *)this + 40));
  }
  *((_DWORD *)this + 11) = 0;
  *((_DWORD *)this + 12) = 0;
  *((unsigned char *)this + 40) = 1;
  return result;
}

uint64_t kdu_multi_synthesis::destroy(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result)
  {
    (*(void (**)(uint64_t))(*(void *)result + 16))(result);
    uint64_t result = *a1;
    if (*a1) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  *a1 = 0;
  return result;
}

uint64_t kdu_region_decompressor::process(uint64_t a1, uint64_t a2, unsigned __int8 a3, int a4, uint64_t a5, int a6, int a7, int a8, int *a9, uint64_t a10, int a11, char a12)
{
  if (((*(_DWORD *)(a1 + 164) == 1) & a3) != 0) {
    int v12 = 2;
  }
  else {
    int v12 = 0;
  }
  int v13 = v12 + *(_DWORD *)(a1 + 160);
  *(_DWORD *)(a1 + 224) = v13;
  if (v13 > *(_DWORD *)(a1 + 220))
  {
    *(_DWORD *)(a1 + 220) = v13;
    uint64_t v14 = *(void *)(a1 + 232);
    if (v14) {
      MEMORY[0x18C11C0C0](v14, 0x10C80436913F5);
    }
    operator new[]();
  }
  if (v13 >= 1)
  {
    uint64_t v15 = 0;
    do
    {
      *(void *)(*(void *)(a1 + 232) + v15) = *(void *)(a2 + v15);
      v15 += 8;
    }
    while (8 * v13 != v15);
    if (v13 >= 5)
    {
      uint64_t v16 = 8 * v13;
      uint64_t v17 = 32;
      do
      {
        *(void *)(*(void *)(a1 + 232) + v17) = 0;
        v17 += 8;
      }
      while (v16 != v17);
    }
  }
  if (a12) {
    int v18 = a4;
  }
  else {
    int v18 = 1;
  }

  return kdu_region_decompressor::process_generic((kdu_region_decompressor *)a1, 1, a4, a5, v18 * a6, a7, a8, a9, a10, a11, 0);
}

uint64_t kdu_region_decompressor::process_generic(kdu_region_decompressor *this, int a2, int a3, uint64_t a4, int a5, int a6, int a7, int *a8, uint64_t a9, int a10, unsigned __int8 a11)
{
  uint64_t v11 = a9;
  *(void *)(a9 + 8) = 0;
  if (*((unsigned char *)this + 80)) {
    return 0;
  }
  BOOL v13 = a8[3] < 1 || a8[2] < 1;
  if (v13) {
    return 0;
  }
  if (!*((unsigned char *)this + 120))
  {
    kdu_region_decompressor::open_tile(this);
    if (!*((unsigned char *)this + 120)) {
      return 0;
    }
  }
  v515[0] = *(_OWORD *)((char *)this + 124);
  kdu_dims::operator&=(v515, a8);
  unint64_t v22 = *((void *)&v515[0] + 1);
  if (SDWORD2(v515[0]) >= 1)
  {
    uint64_t v23 = HIDWORD(*((void *)&v515[0] + 1));
    if (*((uint64_t *)&v515[0] + 1) > 0)
    {
      int v509 = v515[0];
      uint64_t v24 = HIDWORD(*(void *)&v515[0]);
      int v502 = a8[3] + a8[1];
      int v503 = HIDWORD(v515[0]) + DWORD1(v515[0]);
      if (HIDWORD(v515[0]) + DWORD1(v515[0]) != v502 && *((_DWORD *)this + 26) == *((_DWORD *)this + 22)) {
        __assert_rtn("process_generic", "kdu_region_decompressor.cpp", 2650, "last_tile_in_row || (next_tile_idx.x != valid_tiles.pos.x)");
      }
      v501 = a8;
      v505 = (_DWORD *)((char *)this + 124);
      int v25 = DWORD2(v515[0]) + LODWORD(v515[0]);
      *(void *)a9 = *(void *)&v515[0];
      *(void *)(a9 + 8) = v22;
      *(_DWORD *)(a9 + 8) = 0;
      unint64_t v504 = v22;
      if (a5 || a6 >= 1)
      {
        int v26 = *(int *)(**((void **)this + 21) + 84)
            * (uint64_t)a6
            * *(int *)(**((void **)this + 21) + 80)
            / (SHIDWORD(v22)
             * (uint64_t)*(int *)(**((void **)this + 21) + 92)
             * *(int *)(**((void **)this + 21) + 88))
            + 1;
        if (a5)
        {
          if (*v505 + v26 <= v25) {
            int v31 = *(int *)(**((void **)this + 21) + 84)
          }
                * (uint64_t)a6
                * *(int *)(**((void **)this + 21) + 80)
                / (SHIDWORD(v22)
                 * (uint64_t)*(int *)(**((void **)this + 21) + 92)
                 * *(int *)(**((void **)this + 21) + 88))
                + 1;
          else {
            int v31 = v25 - *v505;
          }
          if (v31 > 0)
          {
            uint64_t v32 = *((unsigned int *)this + 56);
            int v33 = v24;
            if ((int)v32 >= 1)
            {
              uint64_t v34 = 0;
              uint64_t v35 = (((int)v24 - HIDWORD(a4)) * a3 + (v509 - (int)a4) * (uint64_t)a5) * a2;
              do
              {
                uint64_t v36 = *((void *)this + 29);
                uint64_t v37 = *(void *)(v36 + v34);
                if (v37) {
                  *(void *)(v36 + v34) = v37 + v35;
                }
                v34 += 8;
              }
              while (8 * v32 != v34);
            }
            goto LABEL_44;
          }
LABEL_822:
          exception = __cxa_allocate_exception(4uLL);
          _DWORD *exception = -1;
          __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
        }
      }
      else
      {
        int v26 = v22;
      }
      if (!(a7 / (int)v23))
      {
        uint64_t v516 = 0;
        memset(v515, 0, sizeof(v515));
        kdu_error::kdu_error((kdu_error *)v515, "Error in Kakadu Region Decompressor:\n");
        (*(void (**)(void))(*(void *)&v515[0] + 16))();
        kdu_error::~kdu_error((kdu_error *)v515);
      }
      if (v26 >= a7 / (int)v23) {
        int v38 = a7 / (int)v23;
      }
      else {
        int v38 = v26;
      }
      if (*v505 + v38 <= v25) {
        int v31 = v38;
      }
      else {
        int v31 = v25 - *v505;
      }
      uint64_t v11 = a9;
      if (v31 >= 1)
      {
        a5 = *(_DWORD *)(a9 + 12) * a3;
        LODWORD(v32) = *((_DWORD *)this + 56);
        int v33 = *(_DWORD *)(a9 + 4);
LABEL_44:
        int v514 = *((_DWORD *)this + 32);
        int v513 = v33 - v514;
        uint64_t v39 = *(unsigned int *)(v11 + 12);
        v500 = "(dp != NULL) && indices.is_absolute() && (indices.get_width() >= i)";
        uint64_t v40 = a3;
        uint64_t v511 = a5 * a2;
        uint64_t v512 = (int)(v32 - a11);
        int v41 = *((_DWORD *)this + 48);
        int v506 = a3;
        int v507 = v33;
        int v508 = a2;
        while (1)
        {
          int v510 = v31;
          if (v41 >= 1)
          {
            for (uint64_t i = 0; i < *((int *)this + 48); ++i)
            {
              uint64_t v43 = *((void *)this + 25);
              int v44 = (unsigned int *)(v43 + 112 * i);
              if ((int)v44[18] <= 0)
              {
                uint64_t v51 = v43 + 112 * i;
                uint64_t v53 = *(void *)(v51 + 24);
                uint64_t v52 = (void *)(v51 + 24);
                if (!v53)
                {
                  uint64_t v54 = v43 + 112 * i;
                  unsigned int v56 = *(_DWORD *)(v54 + 32);
                  v54 += 32;
                  uint64_t v55 = v56;
                  void *v52 = v54;
                  uint64_t v57 = *(void **)(v54 + 8);
                  if ((*(unsigned char *)(v54 + 6) & 2) == 0 && v57)
                  {
LABEL_808:
                    v496 = __cxa_allocate_exception(4uLL);
                    _DWORD *v496 = -50;
                    __cxa_throw(v496, MEMORY[0x1E4FBA3A8], 0);
                  }
                  if (v55) {
                    bzero(v57, 2 * v55);
                  }
                  *(unsigned char *)(v43 + 112 * i + 19) = 1;
                }
                continue;
              }
              uint64_t v45 = v43 + 112 * i;
              int v48 = *(_DWORD *)(v45 + 96);
              int v46 = (_DWORD *)(v45 + 96);
              int v47 = v48;
              unsigned int v50 = (uint64_t *)(v46 - 18);
              uint64_t v49 = *((void *)v46 - 9);
              if (v48 <= 0)
              {
                if (v49)
                {
                  _DWORD *v46 = *(_DWORD *)(v43 + 112 * i + 80) + v47;
                  uint64_t *v50 = 0;
                }
              }
              else if (v49)
              {
                continue;
              }
              uint64_t v58 = (*(uint64_t (**)(void, void, void))(**((void **)this + 4) + 32))(*((void *)this + 4), *v44, *((void *)this + 2));
              uint64_t *v50 = v58;
              if (!v58) {
                goto LABEL_808;
              }
              int v59 = *(_DWORD *)(v43 + 112 * i + 8);
              if (v59 >= 1)
              {
                uint64_t v60 = v43 + 112 * i;
                if ((*(unsigned char *)(v60 + 54) & 2) == 0)
                {
                  int v61 = 218;
                  goto LABEL_795;
                }
                int v61 = 218;
                if ((*(unsigned char *)(v60 + 54) & 1) == 0) {
                  goto LABEL_795;
                }
                uint64_t v62 = v43 + 112 * i;
                uint64_t v63 = *(_WORD **)(v62 + 56);
                if (!v63) {
                  goto LABEL_795;
                }
                int v64 = *(_DWORD *)v58;
                if (*(_DWORD *)(v62 + 48) < *(_DWORD *)v58) {
                  goto LABEL_795;
                }
                int v65 = *(_DWORD *)(v60 + 4);
                int v66 = *(unsigned __int8 *)(v60 + 16);
                unint64_t v67 = *(__int16 **)(v58 + 8);
                if ((*(unsigned char *)(v58 + 6) & 2) != 0)
                {
                  if (*(unsigned char *)(v58 + 6))
                  {
                    if (!v67)
                    {
LABEL_814:
                      int v61 = 249;
                      goto LABEL_816;
                    }
                    if (v64 >= 1)
                    {
                      unsigned int v90 = (0x8000 << v65) >> 16;
                      if (v66) {
                        __int16 v91 = 0;
                      }
                      else {
                        __int16 v91 = v90;
                      }
                      int v92 = -65536 << v59;
                      int v93 = -65536 << v59 >> 16;
                      int v94 = ~(v92 >> 16);
                      unsigned int v95 = v64 + 1;
                      do
                      {
                        __int16 v96 = *v67++;
                        __int16 v97 = v96 + v91;
                        int v98 = (__int16)(v96 + v91);
                        if (v98 >= 0) {
                          __int16 v99 = v94;
                        }
                        else {
                          __int16 v99 = 0;
                        }
                        if ((v93 & v98) != 0) {
                          __int16 v97 = v99;
                        }
                        *v63++ = v97;
                        --v95;
                      }
                      while (v95 > 1);
                    }
                  }
                  else
                  {
                    if (!v67)
                    {
LABEL_815:
                      int v61 = 281;
LABEL_816:
                      v495 = "0";
LABEL_794:
                      v500 = (char *)v495;
LABEL_795:
                      __assert_rtn("convert_samples_to_palette_indices", "kdu_region_decompressor.cpp", v61, v500);
                    }
                    if (v59 > 0xC)
                    {
                      int v61 = 256;
                      v495 = "downshift > 0";
                      goto LABEL_794;
                    }
                    if (v64 >= 1)
                    {
                      char v75 = 13 - v59;
                      int v76 = ((0x8000 << (13 - v59)) + ((v66 == 0) << 28)) >> 16;
                      int v77 = -65536 << v59;
                      int v78 = ~(0xFFFF << v59);
                      unsigned int v79 = v64 + 1;
                      do
                      {
                        int v80 = *v67++;
                        int v81 = (v76 + v80) >> v75;
                        if ((v81 & 0x8000) != 0) {
                          __int16 v82 = 0;
                        }
                        else {
                          __int16 v82 = v78;
                        }
                        if ((v77 & (v81 << 16)) != 0) {
                          LOWORD(v81) = v82;
                        }
                        *v63++ = v81;
                        --v79;
                      }
                      while (v79 > 1);
                    }
                  }
                }
                else if (*(unsigned char *)(v58 + 6))
                {
                  if (!v67) {
                    goto LABEL_814;
                  }
                  int v83 = 1 << v65 >> 1;
                  if (v66) {
                    int v84 = 0;
                  }
                  else {
                    int v84 = v83;
                  }
                  if (v64 >= 1)
                  {
                    int v85 = -1 << v59;
                    unsigned int v86 = v64 + 1;
                    do
                    {
                      int v87 = *(_DWORD *)v67;
                      v67 += 2;
                      int v88 = v87 + v84;
                      if (v87 + v84 < 0 != __OFADD__(v87, v84)) {
                        __int16 v89 = 0;
                      }
                      else {
                        __int16 v89 = ~(_WORD)v85;
                      }
                      if ((v88 & v85) != 0) {
                        LOWORD(v88) = v89;
                      }
                      *v63++ = v88;
                      --v86;
                    }
                    while (v86 > 1);
                  }
                }
                else
                {
                  if (!v67) {
                    goto LABEL_815;
                  }
                  float v68 = (float)(1 << v59);
                  float v69 = (float)(v68 * 0.5) + 0.5;
                  if (v66) {
                    float v69 = 0.5;
                  }
                  if (v64 >= 1)
                  {
                    int v70 = -1 << v59;
                    unsigned int v71 = v64 + 1;
                    do
                    {
                      float v72 = *(float *)v67;
                      v67 += 2;
                      int v73 = (int)(float)(v69 + (float)(v72 * v68));
                      if (v73 >= 0) {
                        __int16 v74 = ~(_WORD)v70;
                      }
                      else {
                        __int16 v74 = 0;
                      }
                      if ((v70 & v73) != 0) {
                        LOWORD(v73) = v74;
                      }
                      *v63++ = v73;
                      --v71;
                    }
                    while (v71 > 1);
                  }
                }
              }
              *(unsigned char *)(v43 + 112 * i + 19) = 1;
              --v44[18];
              ++v44[16];
            }
          }
          if (*((int *)this + 40) < 1) {
            goto LABEL_652;
          }
          uint64_t v100 = 0;
          char v101 = 0;
          do
          {
            uint64_t v102 = *((void *)this + 21);
            uint64_t v103 = *(void *)(v102 + 96 * v100);
            if (!*(unsigned char *)(v103 + 19)) {
              goto LABEL_645;
            }
            if (*(unsigned char *)(v103 + 18)) {
              BOOL v104 = v507 == v514;
            }
            else {
              BOOL v104 = 0;
            }
            if (v104 && (long long v105 = *(_DWORD **)(v103 + 24), (int)v39 <= *v105))
            {
              *(void *)(v102 + 96 * v100 + 64) = v105;
            }
            else
            {
              uint64_t v106 = v102 + 96 * v100;
              uint64_t v107 = *(void *)(v106 + 64);
              *(void *)(v106 + 56) = v107;
              uint64_t v108 = v106 + 8;
              BOOL v109 = v106 + 8 == v107;
              uint64_t v110 = v106 + 8 + 16 * v109;
              *(void *)(v106 + 64) = v110;
              if (!v107) {
                *(void *)(v106 + 56) = v110;
              }
              int v111 = *(_WORD **)(v102 + 96 * v100 + 80);
              if (v111)
              {
                uint64_t v112 = v108 + 16 * v109;
                if ((*(unsigned char *)(v112 + 6) & 2) == 0)
                {
                  int v113 = 314;
LABEL_811:
                  int v115 = "interpolate_and_map";
                  int v116 = "(dp != NULL) && !dst->is_absolute()";
                  goto LABEL_802;
                }
                int v113 = 314;
                if (*(unsigned char *)(v112 + 6)) {
                  goto LABEL_811;
                }
                unsigned int v114 = *(_WORD **)(v112 + 8);
                int v115 = "interpolate_and_map";
                int v116 = "(dp != NULL) && !dst->is_absolute()";
                if (!v114) {
                  goto LABEL_802;
                }
                int v117 = *(_DWORD *)(v103 + 48);
                if (v117)
                {
                  int v118 = *(_DWORD *)(v103 + 100);
                  int v119 = *(_DWORD *)(v103 + 84);
                  int v120 = *(_DWORD *)(v103 + 92);
                  int v121 = v118 - v120 * v513;
                  if (v120 == 1)
                  {
                    if (v121 <= 0)
                    {
                      int v122 = 0;
                      do
                      {
                        v121 += v119;
                        ++v122;
                      }
                      while (v121 < 1);
                      v117 -= v122;
                    }
                    else
                    {
                      int v122 = 0;
                    }
                  }
                  else
                  {
                    int v122 = 0;
                    if (v121 <= -v119)
                    {
                      int v139 = v119 + v118 - v120 * v513;
                      int v140 = 1 - v119;
                      if (v139 <= 1 - v119) {
                        int v141 = 1 - v119;
                      }
                      else {
                        int v141 = v139;
                      }
                      unsigned int v142 = v141 - v139 - (v139 < v140);
                      if (v119 <= 1) {
                        unsigned int v143 = 1;
                      }
                      else {
                        unsigned int v143 = *(_DWORD *)(v103 + 84);
                      }
                      if (v139 >= v140) {
                        int v144 = v142 / v143;
                      }
                      else {
                        int v144 = v142 / v143 + 1;
                      }
                      int v122 = v144 + 1;
                      v121 += (v144 + 1) * v119;
                      v117 += ~v144;
                    }
                  }
                  if (v117 <= 1) {
                    int v152 = 1;
                  }
                  else {
                    int v152 = v117;
                  }
                  if (v117 <= 0) {
                    int v153 = v117 - 1;
                  }
                  else {
                    int v153 = 0;
                  }
                  if ((*(unsigned char *)(v103 + 54) & 2) == 0 || (uint64_t v154 = *(void *)(v103 + 56)) == 0)
                  {
                    int v113 = 360;
                    int v115 = "interpolate_and_map";
                    int v116 = "sp != NULL";
                    goto LABEL_802;
                  }
                  char v155 = (__int16 *)(v154 + 2 * (v153 + v122));
                  uint64_t v157 = *v155;
                  int v156 = v155 + 1;
                  int v158 = (unsigned __int16)v111[v157];
                  int v159 = v152 - 1;
                  if (v120 == 1)
                  {
                    if ((int)v39 < 1 || v121 < 1)
                    {
                      signed int v160 = v39;
                    }
                    else
                    {
                      signed int v160 = v39;
                      do
                      {
                        unsigned int v161 = v160;
                        *v114++ = v158;
                        --v160;
                        if (v161 < 2) {
                          break;
                        }
                        BOOL v13 = v121-- > 1;
                      }
                      while (v13);
                    }
                    int v166 = v160 / v119;
                    if (v160 / v119 >= v159) {
                      int v167 = v152 - 1;
                    }
                    else {
                      int v167 = v160 / v119;
                    }
                    if (v119 == 1)
                    {
                      if (v167 >= 1)
                      {
                        unsigned int v171 = v167 + 1;
                        do
                        {
                          uint64_t v172 = *v156++;
                          *v114++ = v111[v172];
                          --v171;
                        }
                        while (v171 > 1);
                      }
                    }
                    else if (v119 == 2)
                    {
                      if (v167 >= 1)
                      {
                        unsigned int v168 = v167 + 1;
                        do
                        {
                          uint64_t v169 = *v156++;
                          __int16 v170 = v111[v169];
                          *unsigned int v114 = v170;
                          v114[1] = v170;
                          v114 += 2;
                          --v168;
                        }
                        while (v168 > 1);
                      }
                    }
                    else if (v167 >= 1)
                    {
                      int v173 = v167;
                      do
                      {
                        uint64_t v174 = *v156++;
                        __int16 v175 = v111[v174];
                        int v176 = v119;
                        do
                        {
                          *v114++ = v175;
                          --v176;
                        }
                        while (v176);
                        BOOL v28 = __OFSUB__(v173--, 1);
                      }
                      while (!((v173 < 0) ^ v28 | (v173 == 0)));
                    }
                    int v177 = v160 - v167 * v119;
                    if (v159 > v166) {
                      uint64_t v178 = 0;
                    }
                    else {
                      uint64_t v178 = -1;
                    }
                    if (v177 >= 1)
                    {
                      unsigned int v179 = v177 + 1;
                      do
                      {
                        *v114++ = v111[v156[v178]];
                        --v179;
                      }
                      while (v179 > 1);
                    }
                  }
                  else if ((int)v39 >= 1)
                  {
                    int v162 = v39 + 1;
                    int v163 = v158;
                    while (1)
                    {
                      if (v121 < 1 && v159 >= 1)
                      {
                        v121 += v119;
                        if (v121 < 1)
                        {
                          int v113 = 408;
                          int v115 = "interpolate_and_map";
                          goto LABEL_801;
                        }
                        uint64_t v164 = *v156++;
                        int v163 = v158;
                        int v158 = (unsigned __int16)v111[v164];
                        --v159;
                      }
                      unsigned int v165 = ((__int16)v158 + (__int16)v163) >> 1;
                      if (v121 >= (3 * v119) >> 2) {
                        unsigned int v165 = v163 + (((__int16)v158 - (__int16)v163 + 2) >> 2);
                      }
                      if (v121 <= v119 >> 1) {
                        unsigned int v165 = v158 + (((__int16)v163 - (__int16)v158 + 2) >> 2);
                      }
                      if (v121 <= v119 >> 2) {
                        LOWORD(v165) = v158;
                      }
                      *v114++ = v165;
                      v121 -= v120;
                      if (--v162 <= 1) {
                        goto LABEL_633;
                      }
                    }
                  }
                }
                else if ((int)v39 >= 1)
                {
                  unsigned int v138 = v39 + 1;
                  do
                  {
                    *v114++ = *v111;
                    --v138;
                  }
                  while (v138 > 1);
                }
                goto LABEL_633;
              }
              uint64_t v123 = *(void *)(v103 + 24);
              char v124 = *(unsigned char *)(v123 + 6);
              if ((v124 & 2) != 0) {
                uint64_t v125 = *(void *)(v123 + 8);
              }
              else {
                uint64_t v125 = 0;
              }
              if ((*(unsigned char *)(v123 + 6) & 2) != 0) {
                uint64_t v126 = 0;
              }
              else {
                uint64_t v126 = *(void *)(v123 + 8);
              }
              uint64_t v127 = v108 + 16 * v109;
              char v128 = *(unsigned char *)(v127 + 6);
              uint64_t v129 = *(_WORD **)(v127 + 8);
              if ((v128 & 2) != 0) {
                uint64_t v130 = *(void **)(v127 + 8);
              }
              else {
                uint64_t v130 = 0;
              }
              if ((v128 & 2) != 0) {
                unint64_t v131 = 0;
              }
              else {
                unint64_t v131 = v129;
              }
              if (v128)
              {
                int v113 = 448;
                int v115 = "interpolate_and_convert";
                int v116 = "!dst->is_absolute()";
                goto LABEL_802;
              }
              int v132 = *(_DWORD *)v123;
              if (*(_DWORD *)v123)
              {
                int v133 = *(_DWORD *)(v103 + 100);
                int v134 = *(_DWORD *)(v103 + 84);
                int v135 = *(_DWORD *)(v103 + 92);
                int v136 = v133 - v135 * v513;
                if (v135 == 1)
                {
                  if (v136 <= 0)
                  {
                    int v137 = 0;
                    do
                    {
                      v136 += v134;
                      ++v137;
                    }
                    while (v136 < 1);
                    v132 -= v137;
                  }
                  else
                  {
                    int v137 = 0;
                  }
                }
                else
                {
                  int v137 = 0;
                  if (v136 <= -v134)
                  {
                    int v146 = v134 + v133 - v135 * v513;
                    int v147 = 1 - v134;
                    if (v146 <= 1 - v134) {
                      int v148 = 1 - v134;
                    }
                    else {
                      int v148 = v146;
                    }
                    unsigned int v149 = v148 - v146 - (v146 < v147);
                    if (v134 <= 1) {
                      unsigned int v150 = 1;
                    }
                    else {
                      unsigned int v150 = *(_DWORD *)(v103 + 84);
                    }
                    BOOL v13 = v146 < v147;
                    int v151 = v149 / v150;
                    if (v13) {
                      ++v151;
                    }
                    int v137 = v151 + 1;
                    v136 += (v151 + 1) * v134;
                    v132 += ~v151;
                  }
                }
                int v180 = (3 * v134) >> 2;
                int v181 = v134 >> 1;
                int v182 = v134 >> 2;
                if (v132 <= 1) {
                  int v183 = 1;
                }
                else {
                  int v183 = v132;
                }
                if (v132 <= 0) {
                  int v184 = v132 - 1;
                }
                else {
                  int v184 = 0;
                }
                int v185 = v184 + v137;
                if (v124)
                {
                  int v193 = *(_DWORD *)(v103 + 4);
                  char v194 = v193 - 13;
                  char v195 = 13 - v193;
                  if (!v125)
                  {
                    if (v126 && v130)
                    {
                      v213 = (int *)(v126 + 4 * v185);
                      int v215 = *v213;
                      v214 = v213 + 1;
                      int v216 = v183 - 1;
                      int v217 = v215 << v195;
                      int v218 = v215 >> v194;
                      if (v193 < 13) {
                        int v218 = v217;
                      }
                      if (v135 == 1)
                      {
                        if ((int)v39 < 1 || v136 < 1)
                        {
                          signed int v219 = v39;
                        }
                        else
                        {
                          signed int v219 = v39;
                          do
                          {
                            unsigned int v220 = v219;
                            *v129++ = v218;
                            --v219;
                            if (v220 < 2) {
                              break;
                            }
                            BOOL v13 = v136-- > 1;
                          }
                          while (v13);
                        }
                        int v326 = v219 / v134;
                        if (v219 / v134 >= v216) {
                          int v327 = v183 - 1;
                        }
                        else {
                          int v327 = v219 / v134;
                        }
                        if (v134 == 1 && v193 <= 12)
                        {
                          if (v327 >= 1)
                          {
                            unsigned int v328 = v327 + 1;
                            do
                            {
                              int v329 = *v214++;
                              *v129++ = v329 << v195;
                              --v328;
                            }
                            while (v328 > 1);
                          }
                        }
                        else if (v134 == 1)
                        {
                          if (v327 >= 1)
                          {
                            unsigned int v330 = v327 + 1;
                            do
                            {
                              int v331 = *v214++;
                              *v129++ = v331 >> v194;
                              --v330;
                            }
                            while (v330 > 1);
                          }
                        }
                        else if (v134 == 2)
                        {
                          if (v327 >= 1)
                          {
                            unsigned int v377 = v327 + 1;
                            do
                            {
                              int v378 = *v214++;
                              int v379 = v378 << v195;
                              int v380 = v378 >> v194;
                              if (v193 < 13) {
                                LOWORD(v380) = v379;
                              }
                              *uint64_t v129 = v380;
                              v129[1] = v380;
                              v129 += 2;
                              --v377;
                            }
                            while (v377 > 1);
                          }
                        }
                        else
                        {
                          int v385 = v327;
                          if (v327 >= 1)
                          {
                            do
                            {
                              int v386 = *v214 >> v194;
                              if (v193 < 13) {
                                LOWORD(v386) = *v214 << v195;
                              }
                              int v387 = v134;
                              do
                              {
                                *v129++ = v386;
                                --v387;
                              }
                              while (v387);
                              ++v214;
                              BOOL v28 = __OFSUB__(v385--, 1);
                            }
                            while (!((v385 < 0) ^ v28 | (v385 == 0)));
                          }
                        }
                        int v388 = v219 - v327 * v134;
                        if (v216 > v326) {
                          uint64_t v389 = 0;
                        }
                        else {
                          uint64_t v389 = -1;
                        }
                        if (v388 >= 1)
                        {
                          unsigned int v390 = v388 + 1;
                          do
                          {
                            int v391 = v214[v389];
                            int v392 = v391 << v195;
                            int v393 = v391 >> v194;
                            if (v193 < 13) {
                              LOWORD(v393) = v392;
                            }
                            *v129++ = v393;
                            --v390;
                          }
                          while (v390 > 1);
                        }
                      }
                      else
                      {
                        int v283 = v39 + 1;
                        int v284 = v218;
                        if ((int)v39 >= 1)
                        {
                          do
                          {
                            if (v136 < 1)
                            {
                              int v285 = v216 - 1;
                              if (v216 >= 1)
                              {
                                v136 += v134;
                                if (v136 < 1)
                                {
                                  int v113 = 652;
                                  goto LABEL_800;
                                }
                                int v286 = *v214++;
                                int v287 = v286 << v195;
                                int v288 = v286 >> v194;
                                int v284 = v218;
                                if (v193 >= 13) {
                                  int v218 = v288;
                                }
                                else {
                                  int v218 = v287;
                                }
                                int v216 = v285;
                              }
                            }
                            unsigned int v289 = v284 + ((v218 - v284 + 2) >> 2);
                            if (v136 < v180) {
                              unsigned int v289 = (v218 + v284) >> 1;
                            }
                            if (v136 <= v181) {
                              unsigned int v289 = v218 + ((v284 - v218 + 2) >> 2);
                            }
                            if (v136 <= v182) {
                              LOWORD(v289) = v218;
                            }
                            *v129++ = v289;
                            v136 -= v135;
                            --v283;
                          }
                          while (v283 > 1);
                        }
                      }
                    }
                    else
                    {
                      int v113 = 750;
                      if (!v126)
                      {
LABEL_821:
                        int v115 = "interpolate_and_convert";
                        int v116 = "0";
                        goto LABEL_802;
                      }
                      int v115 = "interpolate_and_convert";
                      int v116 = "0";
                      if (!v131) {
                        goto LABEL_802;
                      }
                      char v241 = v193 - 29;
                      int v242 = 29 - v193;
                      v243 = (int *)(v126 + 4 * v185);
                      int v245 = *v243;
                      v244 = v243 + 1;
                      int v246 = v183 - 1;
                      int v247 = v245 << v242;
                      int v248 = v245 >> v241;
                      if (v242 > 0) {
                        int v248 = v247;
                      }
                      if (v135 == 1)
                      {
                        if ((int)v39 < 1 || v136 < 1)
                        {
                          signed int v249 = v39;
                        }
                        else
                        {
                          signed int v249 = v39;
                          do
                          {
                            unsigned int v250 = v249;
                            *(_DWORD *)uint64_t v129 = v248;
                            v129 += 2;
                            --v249;
                            if (v250 < 2) {
                              break;
                            }
                            BOOL v13 = v136-- > 1;
                          }
                          while (v13);
                        }
                        int v339 = v249 / v134;
                        if (v249 / v134 >= v246) {
                          int v340 = v183 - 1;
                        }
                        else {
                          int v340 = v249 / v134;
                        }
                        if (v134 == 1 && v242 >= 1)
                        {
                          if (v340 >= 1)
                          {
                            unsigned int v341 = v340 + 1;
                            do
                            {
                              int v342 = *v244++;
                              *(_DWORD *)uint64_t v129 = v342 << v242;
                              v129 += 2;
                              --v341;
                            }
                            while (v341 > 1);
                          }
                        }
                        else if (v134 == 1)
                        {
                          if (v340 >= 1)
                          {
                            unsigned int v343 = v340 + 1;
                            do
                            {
                              int v344 = *v244++;
                              *(_DWORD *)uint64_t v129 = v344 >> v241;
                              v129 += 2;
                              --v343;
                            }
                            while (v343 > 1);
                          }
                        }
                        else if (v134 == 2)
                        {
                          if (v340 >= 1)
                          {
                            unsigned int v381 = v340 + 1;
                            do
                            {
                              int v382 = *v244++;
                              int v383 = v382 << v242;
                              int v384 = v382 >> v241;
                              if (v242 > 0) {
                                int v384 = v383;
                              }
                              *(_DWORD *)uint64_t v129 = v384;
                              *((_DWORD *)v129 + 1) = v384;
                              v129 += 4;
                              --v381;
                            }
                            while (v381 > 1);
                          }
                        }
                        else
                        {
                          int v394 = v340;
                          if (v340 >= 1)
                          {
                            do
                            {
                              int v395 = *v244++;
                              int v396 = v395 << v242;
                              int v397 = v395 >> v241;
                              if (v242 > 0) {
                                int v397 = v396;
                              }
                              int v398 = v134;
                              do
                              {
                                *(_DWORD *)uint64_t v129 = v397;
                                v129 += 2;
                                --v398;
                              }
                              while (v398);
                              BOOL v28 = __OFSUB__(v394--, 1);
                            }
                            while (!((v394 < 0) ^ v28 | (v394 == 0)));
                          }
                        }
                        int v399 = v249 - v340 * v134;
                        if (v246 > v339) {
                          uint64_t v400 = 0;
                        }
                        else {
                          uint64_t v400 = -1;
                        }
                        if (v399 >= 1)
                        {
                          unsigned int v401 = v399 + 1;
                          do
                          {
                            int v402 = v244[v400];
                            int v403 = v402 << v242;
                            int v404 = v402 >> v241;
                            if (v242 > 0) {
                              int v404 = v403;
                            }
                            *(_DWORD *)uint64_t v129 = v404;
                            v129 += 2;
                            --v401;
                          }
                          while (v401 > 1);
                        }
                      }
                      else
                      {
                        int v297 = v39 + 1;
                        int v298 = v248;
                        if ((int)v39 >= 1)
                        {
                          do
                          {
                            if (v136 < 1)
                            {
                              int v299 = v246 - 1;
                              if (v246 >= 1)
                              {
                                v136 += v134;
                                if (v136 < 1)
                                {
                                  int v113 = 728;
                                  goto LABEL_800;
                                }
                                int v300 = *v244++;
                                int v301 = v300 << v242;
                                int v302 = v300 >> v241;
                                int v298 = v248;
                                if (v242 <= 0) {
                                  int v248 = v302;
                                }
                                else {
                                  int v248 = v301;
                                }
                                int v246 = v299;
                              }
                            }
                            int v303 = v298 + ((v248 - v298 + 2) >> 2);
                            if (v136 < v180) {
                              int v303 = (v248 + v298) >> 1;
                            }
                            if (v136 <= v181) {
                              int v303 = v248 + ((v298 - v248 + 2) >> 2);
                            }
                            if (v136 <= v182) {
                              int v303 = v248;
                            }
                            *(_DWORD *)uint64_t v129 = v303;
                            v129 += 2;
                            v136 -= v135;
                            --v297;
                          }
                          while (v297 > 1);
                        }
                      }
                    }
                    goto LABEL_633;
                  }
                  if (!v130)
                  {
                    int v113 = 502;
                    goto LABEL_805;
                  }
                  v196 = (__int16 *)(v125 + 2 * v185);
                  int v198 = *v196;
                  v197 = (unsigned __int16 *)(v196 + 1);
                  int v199 = v183 - 1;
                  int v200 = v198 << v195;
                  int v201 = v198 >> v194;
                  if (v193 < 13) {
                    int v201 = v200;
                  }
                  if (v135 != 1)
                  {
                    if ((int)v39 >= 1)
                    {
                      int v225 = v39 + 1;
                      int v226 = v201;
                      do
                      {
                        if (v136 < 1)
                        {
                          int v227 = v199 - 1;
                          if (v199 >= 1)
                          {
                            v136 += v134;
                            if (v136 < 1)
                            {
                              int v113 = 578;
                              goto LABEL_800;
                            }
                            int v228 = (__int16)*v197++;
                            int v229 = v228 << v195;
                            int v230 = v228 >> v194;
                            int v226 = v201;
                            if (v193 >= 13) {
                              int v201 = v230;
                            }
                            else {
                              int v201 = v229;
                            }
                            int v199 = v227;
                          }
                        }
                        unsigned int v231 = ((__int16)v201 + (__int16)v226) >> 1;
                        if (v136 >= v180) {
                          unsigned int v231 = v226 + (((__int16)v201 - (__int16)v226 + 2) >> 2);
                        }
                        if (v136 <= v181) {
                          unsigned int v231 = v201 + (((__int16)v226 - (__int16)v201 + 2) >> 2);
                        }
                        if (v136 <= v182) {
                          LOWORD(v231) = v201;
                        }
                        *v129++ = v231;
                        v136 -= v135;
                        --v225;
                      }
                      while (v225 > 1);
                    }
                    goto LABEL_633;
                  }
                  if ((int)v39 < 1 || v136 < 1)
                  {
                    signed int v202 = v39;
                  }
                  else
                  {
                    signed int v202 = v39;
                    do
                    {
                      unsigned int v203 = v202;
                      *v129++ = v201;
                      --v202;
                      if (v203 < 2) {
                        break;
                      }
                      BOOL v13 = v136-- > 1;
                    }
                    while (v13);
                  }
                  int v255 = v202 / v134;
                  if (v202 / v134 >= v199) {
                    int v256 = v183 - 1;
                  }
                  else {
                    int v256 = v202 / v134;
                  }
                  if (v134 != 1)
                  {
                    if (v134 == 2)
                    {
                      if (v256 >= 1)
                      {
                        unsigned int v257 = v256 + 1;
                        do
                        {
                          int v258 = (__int16)*v197++;
                          int v259 = v258 << v195;
                          int v260 = v258 >> v194;
                          if (v193 < 13) {
                            LOWORD(v260) = v259;
                          }
                          *uint64_t v129 = v260;
                          v129[1] = v260;
                          v129 += 2;
                          --v257;
                        }
                        while (v257 > 1);
                        goto LABEL_471;
                      }
LABEL_472:
                      int v271 = v256;
                    }
                    else
                    {
                      int v270 = v256;
                      int v271 = v256;
                      if (v256 >= 1)
                      {
                        do
                        {
                          int v272 = (__int16)*v197++;
                          int v273 = v272 << v195;
                          int v274 = v272 >> v194;
                          if (v193 < 13) {
                            LOWORD(v274) = v273;
                          }
                          int v275 = v134;
                          do
                          {
                            *v129++ = v274;
                            --v275;
                          }
                          while (v275);
                          BOOL v28 = __OFSUB__(v270--, 1);
                        }
                        while (!((v270 < 0) ^ v28 | (v270 == 0)));
LABEL_471:
                        int v271 = 0;
                      }
                    }
                    int v312 = v202 - v256 * v134;
                    if (v312 >= 1)
                    {
                      v313 = (__int16 *)&v197[v271];
                      if (v199 > v255) {
                        uint64_t v314 = 0;
                      }
                      else {
                        uint64_t v314 = -1;
                      }
                      int v315 = v313[v314];
                      v316 = &v129[v271 * v134];
                      int v317 = v315 << v195;
                      if (v193 >= 13) {
                        LOWORD(v317) = v315 >> v194;
                      }
                      unsigned int v318 = v312 + 1;
                      do
                      {
                        *v316++ = v317;
                        --v318;
                      }
                      while (v318 > 1);
                    }
                    goto LABEL_633;
                  }
                  if (v193 >= 13)
                  {
                    if (v256 >= 1)
                    {
                      unsigned int v310 = v256 + 1;
                      do
                      {
                        int v311 = (__int16)*v197++;
                        *v129++ = v311 >> v194;
                        --v310;
                      }
                      while (v310 > 1);
                      goto LABEL_471;
                    }
                  }
                  else if (v256 >= 1)
                  {
                    unsigned int v263 = v256 + 1;
                    do
                    {
                      int v264 = *v197++;
                      *v129++ = v264 << v195;
                      --v263;
                    }
                    while (v263 > 1);
                    goto LABEL_471;
                  }
                  goto LABEL_472;
                }
                if (!v125)
                {
                  if (v126 && v130)
                  {
                    v204 = (float *)(v126 + 4 * v185);
                    float v206 = *v204;
                    v205 = v204 + 1;
                    int v207 = v183 - 1;
                    int v208 = (int)(float)(0.5 - (float)(v206 * 8192.0));
                    int v209 = (int)(float)((float)(v206 * 8192.0) + 0.5);
                    if ((float)(v206 * 8192.0) < 0.0) {
                      int v210 = -v208;
                    }
                    else {
                      LOWORD(v210) = v209;
                    }
                    if (v135 == 1)
                    {
                      if ((int)v39 < 1 || v136 < 1)
                      {
                        signed int v211 = v39;
                      }
                      else
                      {
                        signed int v211 = v39;
                        do
                        {
                          unsigned int v212 = v211;
                          *v129++ = v210;
                          --v211;
                          if (v212 < 2) {
                            break;
                          }
                          BOOL v13 = v136-- > 1;
                        }
                        while (v13);
                      }
                      int v319 = v211 / v134;
                      if (v211 / v134 >= v207) {
                        int v320 = v183 - 1;
                      }
                      else {
                        int v320 = v211 / v134;
                      }
                      if (v134 == 1)
                      {
                        if (v320 >= 1)
                        {
                          int v345 = v320 + 1;
                          do
                          {
                            float v346 = *v205++;
                            int v347 = (int)(float)(0.5 - (float)(v346 * 8192.0));
                            int v348 = (int)(float)((float)(v346 * 8192.0) + 0.5);
                            if ((float)(v346 * 8192.0) < 0.0) {
                              int v349 = -v347;
                            }
                            else {
                              LOWORD(v349) = v348;
                            }
                            *v129++ = v349;
                            --v345;
                          }
                          while (v345 > 1);
                        }
                      }
                      else if (v134 == 2)
                      {
                        if (v320 >= 1)
                        {
                          int v321 = v320 + 1;
                          do
                          {
                            float v322 = *v205++;
                            int v323 = (int)(float)(0.5 - (float)(v322 * 8192.0));
                            int v324 = (int)(float)((float)(v322 * 8192.0) + 0.5);
                            if ((float)(v322 * 8192.0) < 0.0) {
                              int v325 = -v323;
                            }
                            else {
                              LOWORD(v325) = v324;
                            }
                            *uint64_t v129 = v325;
                            v129[1] = v325;
                            v129 += 2;
                            --v321;
                          }
                          while (v321 > 1);
                        }
                      }
                      else
                      {
                        int v350 = v320;
                        if (v320 >= 1)
                        {
                          do
                          {
                            float v351 = *v205++;
                            int v352 = (int)(float)(0.5 - (float)(v351 * 8192.0));
                            int v353 = (int)(float)((float)(v351 * 8192.0) + 0.5);
                            if ((float)(v351 * 8192.0) < 0.0) {
                              int v354 = -v352;
                            }
                            else {
                              LOWORD(v354) = v353;
                            }
                            int v355 = v134;
                            do
                            {
                              *v129++ = v354;
                              --v355;
                            }
                            while (v355);
                            BOOL v28 = __OFSUB__(v350--, 1);
                          }
                          while (!((v350 < 0) ^ v28 | (v350 == 0)));
                        }
                      }
                      int v356 = v211 - v320 * v134;
                      if (v207 > v319) {
                        uint64_t v357 = 0;
                      }
                      else {
                        uint64_t v357 = -1;
                      }
                      if (v356 >= 1)
                      {
                        int v358 = v356 + 1;
                        do
                        {
                          float v359 = v205[v357] * 8192.0;
                          if (v359 < 0.0) {
                            int v360 = -(int)(float)(0.5 - v359);
                          }
                          else {
                            LOWORD(v360) = (int)(float)(v359 + 0.5);
                          }
                          *v129++ = v360;
                          --v358;
                        }
                        while (v358 > 1);
                      }
                    }
                    else
                    {
                      int v276 = v39 + 1;
                      __int16 v277 = v210;
                      if ((int)v39 >= 1)
                      {
                        do
                        {
                          if (v136 < 1)
                          {
                            int v278 = v207 - 1;
                            if (v207 >= 1)
                            {
                              v136 += v134;
                              if (v136 < 1)
                              {
                                int v113 = 899;
                                goto LABEL_800;
                              }
                              float v279 = *v205++;
                              int v280 = (int)(float)(0.5 - (float)(v279 * 8192.0));
                              int v281 = (int)(float)((float)(v279 * 8192.0) + 0.5);
                              __int16 v277 = v210;
                              if ((float)(v279 * 8192.0) < 0.0) {
                                int v210 = -v280;
                              }
                              else {
                                LOWORD(v210) = v281;
                              }
                              int v207 = v278;
                            }
                          }
                          unsigned int v282 = ((__int16)v210 + v277) >> 1;
                          if (v136 >= v180) {
                            LOWORD(v282) = v277 + (((__int16)v210 - v277 + 2) >> 2);
                          }
                          if (v136 <= v181) {
                            LOWORD(v282) = v210 + ((v277 - (__int16)v210 + 2) >> 2);
                          }
                          if (v136 <= v182) {
                            LOWORD(v282) = v210;
                          }
                          *v129++ = v282;
                          v136 -= v135;
                          --v276;
                        }
                        while (v276 > 1);
                      }
                    }
                  }
                  else
                  {
                    int v113 = 1006;
                    if (!v126) {
                      goto LABEL_821;
                    }
                    int v115 = "interpolate_and_convert";
                    int v116 = "0";
                    if (!v131) {
                      goto LABEL_802;
                    }
                    v232 = (float *)(v126 + 4 * v185);
                    float v234 = *v232;
                    v233 = v232 + 1;
                    int v235 = v183 - 1;
                    int v236 = (int)(float)(0.5 - (float)(v234 * 536870000.0));
                    int v237 = (int)(float)((float)(v234 * 536870000.0) + 0.5);
                    if ((float)(v234 * 536870000.0) < 0.0) {
                      int v238 = -v236;
                    }
                    else {
                      int v238 = v237;
                    }
                    if (v135 == 1)
                    {
                      if ((int)v39 < 1 || v136 < 1)
                      {
                        signed int v239 = v39;
                      }
                      else
                      {
                        signed int v239 = v39;
                        do
                        {
                          unsigned int v240 = v239;
                          *(_DWORD *)uint64_t v129 = v238;
                          v129 += 2;
                          --v239;
                          if (v240 < 2) {
                            break;
                          }
                          BOOL v13 = v136-- > 1;
                        }
                        while (v13);
                      }
                      int v332 = v239 / v134;
                      if (v239 / v134 >= v235) {
                        int v333 = v183 - 1;
                      }
                      else {
                        int v333 = v239 / v134;
                      }
                      if (v134 == 1)
                      {
                        if (v333 >= 1)
                        {
                          int v361 = v333 + 1;
                          do
                          {
                            float v362 = *v233++;
                            int v363 = (int)(float)(0.5 - (float)(v362 * 536870000.0));
                            int v364 = (int)(float)((float)(v362 * 536870000.0) + 0.5);
                            if ((float)(v362 * 536870000.0) < 0.0) {
                              int v365 = -v363;
                            }
                            else {
                              int v365 = v364;
                            }
                            *(_DWORD *)uint64_t v129 = v365;
                            v129 += 2;
                            --v361;
                          }
                          while (v361 > 1);
                        }
                      }
                      else if (v134 == 2)
                      {
                        if (v333 >= 1)
                        {
                          int v334 = v333 + 1;
                          do
                          {
                            float v335 = *v233++;
                            int v336 = (int)(float)(0.5 - (float)(v335 * 536870000.0));
                            int v337 = (int)(float)((float)(v335 * 536870000.0) + 0.5);
                            if ((float)(v335 * 536870000.0) < 0.0) {
                              int v338 = -v336;
                            }
                            else {
                              int v338 = v337;
                            }
                            *(_DWORD *)uint64_t v129 = v338;
                            *((_DWORD *)v129 + 1) = v338;
                            v129 += 4;
                            --v334;
                          }
                          while (v334 > 1);
                        }
                      }
                      else
                      {
                        int v366 = v333;
                        if (v333 >= 1)
                        {
                          do
                          {
                            float v367 = *v233++;
                            int v368 = (int)(float)(0.5 - (float)(v367 * 536870000.0));
                            int v369 = (int)(float)((float)(v367 * 536870000.0) + 0.5);
                            if ((float)(v367 * 536870000.0) < 0.0) {
                              int v370 = -v368;
                            }
                            else {
                              int v370 = v369;
                            }
                            int v371 = v134;
                            do
                            {
                              *(_DWORD *)uint64_t v129 = v370;
                              v129 += 2;
                              --v371;
                            }
                            while (v371);
                            BOOL v28 = __OFSUB__(v366--, 1);
                          }
                          while (!((v366 < 0) ^ v28 | (v366 == 0)));
                        }
                      }
                      int v372 = v239 - v333 * v134;
                      if (v235 > v332) {
                        uint64_t v373 = 0;
                      }
                      else {
                        uint64_t v373 = -1;
                      }
                      if (v372 >= 1)
                      {
                        int v374 = v372 + 1;
                        do
                        {
                          float v375 = v233[v373] * 536870000.0;
                          if (v375 < 0.0) {
                            int v376 = -(int)(float)(0.5 - v375);
                          }
                          else {
                            int v376 = (int)(float)(v375 + 0.5);
                          }
                          *(_DWORD *)uint64_t v129 = v376;
                          v129 += 2;
                          --v374;
                        }
                        while (v374 > 1);
                      }
                    }
                    else
                    {
                      int v290 = v39 + 1;
                      int v291 = v238;
                      if ((int)v39 >= 1)
                      {
                        do
                        {
                          if (v136 < 1)
                          {
                            int v292 = v235 - 1;
                            if (v235 >= 1)
                            {
                              v136 += v134;
                              if (v136 < 1)
                              {
                                int v113 = 983;
                                goto LABEL_800;
                              }
                              float v293 = *v233++;
                              int v294 = (int)(float)(0.5 - (float)(v293 * 536870000.0));
                              int v295 = (int)(float)((float)(v293 * 536870000.0) + 0.5);
                              int v291 = v238;
                              if ((float)(v293 * 536870000.0) < 0.0) {
                                int v238 = -v294;
                              }
                              else {
                                int v238 = v295;
                              }
                              int v235 = v292;
                            }
                          }
                          int v296 = v291 + ((v238 - v291 + 2) >> 2);
                          if (v136 < v180) {
                            int v296 = (v238 + v291) >> 1;
                          }
                          if (v136 <= v181) {
                            int v296 = v238 + ((v291 - v238 + 2) >> 2);
                          }
                          if (v136 <= v182) {
                            int v296 = v238;
                          }
                          *(_DWORD *)uint64_t v129 = v296;
                          v129 += 2;
                          v136 -= v135;
                          --v290;
                        }
                        while (v290 > 1);
                      }
                    }
                  }
                  goto LABEL_633;
                }
                if (!v130)
                {
                  int v113 = 756;
LABEL_805:
                  int v115 = "interpolate_and_convert";
                  int v116 = "dp16 != NULL";
                  goto LABEL_802;
                }
                unsigned int v186 = (__int16 *)(v125 + 2 * v185);
                __int16 v189 = *v186;
                unsigned int v187 = v186 + 1;
                __int16 v188 = v189;
                int v190 = v183 - 1;
                if (v135 != 1)
                {
                  int v221 = v39 + 1;
                  __int16 v222 = v188;
                  if ((int)v39 >= 1)
                  {
                    while (1)
                    {
                      if (v136 < 1 && v190 >= 1)
                      {
                        v136 += v134;
                        if (v136 < 1)
                        {
                          int v113 = 817;
LABEL_800:
                          int v115 = "interpolate_and_convert";
LABEL_801:
                          int v116 = "expand_counter > 0";
LABEL_802:
                          __assert_rtn(v115, "kdu_region_decompressor.cpp", v113, v116);
                        }
                        __int16 v222 = v188;
                        __int16 v223 = *v187++;
                        __int16 v188 = v223;
                        --v190;
                      }
                      unsigned int v224 = (v188 + v222) >> 1;
                      if (v136 >= v180) {
                        LOWORD(v224) = v222 + ((v188 - v222 + 2) >> 2);
                      }
                      if (v136 <= v181) {
                        LOWORD(v224) = v188 + ((v222 - v188 + 2) >> 2);
                      }
                      if (v136 <= v182) {
                        LOWORD(v224) = v188;
                      }
                      *v129++ = v224;
                      v136 -= v135;
                      if (--v221 <= 1) {
                        goto LABEL_633;
                      }
                    }
                  }
                  goto LABEL_633;
                }
                if ((int)v39 < 1 || v136 < 1)
                {
                  signed int v191 = v39;
                }
                else
                {
                  signed int v191 = v39;
                  do
                  {
                    unsigned int v192 = v191;
                    *v129++ = v188;
                    --v191;
                    if (v192 < 2) {
                      break;
                    }
                    BOOL v13 = v136-- > 1;
                  }
                  while (v13);
                }
                int v251 = v191 / v134;
                if (v191 / v134 >= v190) {
                  int v252 = v183 - 1;
                }
                else {
                  int v252 = v191 / v134;
                }
                if (v134 == 1)
                {
                  if (v252 < 1) {
                    goto LABEL_460;
                  }
                  unsigned int v261 = v252 + 1;
                  do
                  {
                    __int16 v262 = *v187++;
                    *v129++ = v262;
                    --v261;
                  }
                  while (v261 > 1);
                }
                else
                {
                  if (v134 == 2)
                  {
                    if (v252 >= 1)
                    {
                      unsigned int v253 = v252 + 1;
                      do
                      {
                        __int16 v254 = *v187++;
                        *uint64_t v129 = v254;
                        v129[1] = v254;
                        v129 += 2;
                        --v253;
                      }
                      while (v253 > 1);
                      goto LABEL_387;
                    }
LABEL_460:
                    int v266 = v252;
LABEL_461:
                    int v304 = v191 - v252 * v134;
                    if (v304 >= 1)
                    {
                      v305 = &v187[v266];
                      v306 = &v129[v266 * v134];
                      if (v190 > v251) {
                        uint64_t v307 = 0;
                      }
                      else {
                        uint64_t v307 = -1;
                      }
                      __int16 v308 = v305[v307];
                      unsigned int v309 = v304 + 1;
                      do
                      {
                        *v306++ = v308;
                        --v309;
                      }
                      while (v309 > 1);
                    }
                    goto LABEL_633;
                  }
                  int v265 = v252;
                  int v266 = v252;
                  if (v252 < 1) {
                    goto LABEL_461;
                  }
                  do
                  {
                    __int16 v268 = *v187++;
                    __int16 v267 = v268;
                    int v269 = v134;
                    do
                    {
                      *v129++ = v267;
                      --v269;
                    }
                    while (v269);
                    BOOL v28 = __OFSUB__(v265--, 1);
                  }
                  while (!((v265 < 0) ^ v28 | (v265 == 0)));
                }
LABEL_387:
                int v266 = 0;
                goto LABEL_461;
              }
              if (v130)
              {
                if ((int)v39 >= 1)
                {
                  unint64_t v131 = v130;
                  size_t v145 = 2 * v39;
LABEL_244:
                  bzero(v131, v145);
                }
              }
              else if ((int)v39 >= 1)
              {
                size_t v145 = 4 * v39;
                goto LABEL_244;
              }
            }
LABEL_633:
            int v405 = *(unsigned __int16 *)(v102 + 96 * v100 + 94);
            if (*(_WORD *)(v102 + 96 * v100 + 94))
            {
              uint64_t v406 = *(void *)(v102 + 96 * v100 + 64);
              if (*(_DWORD *)v406 < (int)v39)
              {
                int v113 = 1018;
                int v115 = "apply_white_stretch";
                int v116 = "num_cols <= line->get_width()";
                goto LABEL_802;
              }
              char v407 = *(unsigned char *)(v406 + 6);
              v408 = *(__int16 **)(v406 + 8);
              if ((v407 & 2) != 0 && v408)
              {
                if ((int)v39 >= 1)
                {
                  unsigned int v409 = v39 + 1;
                  do
                  {
                    __int16 *v408 = *v408 - ((-4096 * v405) >> 16) + ((*v408 * v405) >> 16);
                    ++v408;
                    --v409;
                  }
                  while (v409 > 1);
                }
              }
              else if ((int)v39 >= 1)
              {
                unsigned int v410 = v39 + 1;
                do
                {
                  *(_DWORD *)v408 += ((*(int *)v408 >> 16) + 4096) * v405;
                  v408 += 2;
                  --v410;
                }
                while (v410 > 1);
              }
            }
            char v101 = 1;
LABEL_645:
            ++v100;
          }
          while (v100 < *((int *)this + 40));
          if (((*((unsigned char *)this + 184) != 0) & v101) == 1)
          {
            int v411 = *((_DWORD *)this + 41);
            if (v411 > 2)
            {
              v413 = (void *)*((void *)this + 21);
              v412 = (uint64_t *)*((void *)this + 22);
              uint64_t v414 = v413[8];
              uint64_t v415 = v413[20];
              uint64_t v416 = v413[32];
              if (v411 == 3) {
                jp2_colour_converter::convert_rgb(v412, v414, v415, v416, v39);
              }
              else {
                jp2_colour_converter::convert_rgb4(v412, v414, v415, v416, v413[44], v39);
              }
            }
            else
            {
              jp2_colour_converter::convert_lum(*((uint64_t **)this + 22), *(void *)(*((void *)this + 21) + 64), v39);
            }
          }
LABEL_652:
          int v41 = *((_DWORD *)this + 48);
          if (v41 < 1) {
            goto LABEL_658;
          }
          v417 = (_DWORD *)(*((void *)this + 25) + 72);
          char v418 = 1;
          uint64_t v419 = *((unsigned int *)this + 48);
          do
          {
            *((unsigned char *)v417 - 53) = 0;
            if ((int)v417[6] <= 0) {
              v418 &= *v417 < 1;
            }
            v417 += 28;
            --v419;
          }
          while (v419);
          if (v418)
          {
LABEL_658:
            if (*v505 == v509)
            {
              if (*((int *)this + 40) >= 1)
              {
                for (uint64_t j = 0; j < *((int *)this + 40); ++j)
                {
                  uint64_t v421 = *((void *)this + 21);
                  v422 = *(int **)(v421 + 96 * j);
                  if (v422[22] == 1)
                  {
                    if (*((unsigned char *)this + 185) && (v422[24] > 1 || v422[18] < 1))
                    {
                      uint64_t v434 = v421 + 96 * j;
                      *(void *)(v434 + 72) = v434 + 40;
                      char v435 = *(unsigned char *)(v434 + 46);
                      if ((v435 & 2) != 0) {
                        v436 = *(void **)(v421 + 96 * j + 48);
                      }
                      else {
                        v436 = 0;
                      }
                      uint64_t v446 = *(void *)(v421 + 96 * j + 64);
                      if ((*(unsigned char *)(v446 + 6) & 2) != 0)
                      {
                        v447 = *(const void **)(v446 + 8);
                        if (!v436) {
                          goto LABEL_700;
                        }
LABEL_698:
                        size_t v448 = 2 * (int)v39;
                      }
                      else
                      {
                        v447 = 0;
                        if (v436) {
                          goto LABEL_698;
                        }
LABEL_700:
                        if ((v435 & 2) != 0)
                        {
                          v436 = 0;
                          if ((*(unsigned char *)(v446 + 6) & 2) == 0) {
                            goto LABEL_726;
                          }
LABEL_702:
                          v447 = 0;
                        }
                        else
                        {
                          v436 = *(void **)(v421 + 96 * j + 48);
                          if ((*(unsigned char *)(v446 + 6) & 2) != 0) {
                            goto LABEL_702;
                          }
LABEL_726:
                          v447 = *(const void **)(v446 + 8);
                        }
                        size_t v448 = 4 * (int)v39;
                      }
                      memcpy(v436, v447, v448);
                      continue;
                    }
                    *(void *)(v421 + 96 * j + 72) = *(void *)(v421 + 96 * j + 64);
                  }
                  else
                  {
                    uint64_t v423 = v421 + 96 * j;
                    *(void *)(v423 + 72) = v423 + 40;
                    uint64_t v424 = *(void *)(v423 + 56);
                    if (!v424 || (uint64_t v425 = *(void *)(v421 + 96 * j + 64)) == 0)
                    {
                      v497 = __cxa_allocate_exception(4uLL);
                      _DWORD *v497 = -50;
                      __cxa_throw(v497, MEMORY[0x1E4FBA3A8], 0);
                    }
                    int v426 = v422[24];
                    int v427 = v422[20];
                    int v428 = (3 * v427) >> 2;
                    int v429 = v427 >> 1;
                    int v430 = v427 >> 2;
                    if ((*(unsigned char *)(v421 + 96 * j + 46) & 2) != 0 && (v431 = *(_WORD **)(v421 + 96 * j + 48)) != 0)
                    {
                      if ((*(unsigned char *)(v424 + 6) & 2) != 0) {
                        v432 = *(__int16 **)(v424 + 8);
                      }
                      else {
                        v432 = 0;
                      }
                      if ((*(unsigned char *)(v425 + 6) & 2) == 0)
                      {
                        int v438 = 1069;
LABEL_818:
                        __assert_rtn("interpolate_between_lines", "kdu_region_decompressor.cpp", v438, "(sp1 != NULL) && (sp2 != NULL) && (dp != NULL)");
                      }
                      int v438 = 1069;
                      if (!v432) {
                        goto LABEL_818;
                      }
                      v453 = *(__int16 **)(v425 + 8);
                      if (!v453) {
                        goto LABEL_818;
                      }
                      if (v430 >= v426)
                      {
                        if ((int)v39 >= 1)
                        {
                          unsigned int v458 = v39 + 1;
                          do
                          {
                            __int16 v459 = *v453++;
                            *v431++ = v459;
                            --v458;
                          }
                          while (v458 > 1);
                        }
                      }
                      else if (v429 >= v426)
                      {
                        if ((int)v39 >= 1)
                        {
                          unsigned int v464 = v39 + 1;
                          do
                          {
                            int v466 = *v453++;
                            int v465 = v466;
                            int v467 = *v432++;
                            *v431++ = v465 + ((v467 - v465 + 2) >> 2);
                            --v464;
                          }
                          while (v464 > 1);
                        }
                      }
                      else if (v428 <= v426)
                      {
                        unsigned int v468 = v39 + 1;
                        if ((int)v39 >= 1)
                        {
                          do
                          {
                            int v470 = *v432++;
                            int v469 = v470;
                            int v471 = *v453++;
                            *v431++ = v469 + ((v471 - v469 + 2) >> 2);
                            --v468;
                          }
                          while (v468 > 1);
                        }
                      }
                      else if ((int)v39 >= 1)
                      {
                        unsigned int v454 = v39 + 1;
                        do
                        {
                          int v456 = *v453++;
                          int v455 = v456;
                          int v457 = *v432++;
                          *v431++ = (v457 + v455) >> 1;
                          --v454;
                        }
                        while (v454 > 1);
                      }
                    }
                    else
                    {
                      if ((*(unsigned char *)(v424 + 6) & 2) != 0) {
                        v433 = 0;
                      }
                      else {
                        v433 = *(int **)(v424 + 8);
                      }
                      if ((*(unsigned char *)(v425 + 6) & 2) != 0) {
                        v437 = 0;
                      }
                      else {
                        v437 = *(int **)(v425 + 8);
                      }
                      int v438 = 1096;
                      if ((*(unsigned char *)(v421 + 96 * j + 46) & 2) != 0) {
                        goto LABEL_818;
                      }
                      if (!v433) {
                        goto LABEL_818;
                      }
                      if (!v437) {
                        goto LABEL_818;
                      }
                      v439 = *(int **)(v421 + 96 * j + 48);
                      if (!v439) {
                        goto LABEL_818;
                      }
                      if (v430 >= v426)
                      {
                        if ((int)v39 >= 1)
                        {
                          unsigned int v444 = v39 + 1;
                          do
                          {
                            int v445 = *v437++;
                            *v439++ = v445;
                            --v444;
                          }
                          while (v444 > 1);
                        }
                      }
                      else if (v429 >= v426)
                      {
                        if ((int)v39 >= 1)
                        {
                          unsigned int v449 = v39 + 1;
                          do
                          {
                            int v451 = *v437++;
                            int v450 = v451;
                            int v452 = *v433++;
                            *v439++ = v450 + ((v452 - v450 + 2) >> 2);
                            --v449;
                          }
                          while (v449 > 1);
                        }
                      }
                      else if (v428 <= v426)
                      {
                        unsigned int v460 = v39 + 1;
                        if ((int)v39 >= 1)
                        {
                          do
                          {
                            int v462 = *v433++;
                            int v461 = v462;
                            int v463 = *v437++;
                            *v439++ = v461 + ((v463 - v461 + 2) >> 2);
                            --v460;
                          }
                          while (v460 > 1);
                        }
                      }
                      else if ((int)v39 >= 1)
                      {
                        unsigned int v440 = v39 + 1;
                        do
                        {
                          int v442 = *v437++;
                          int v441 = v442;
                          int v443 = *v433++;
                          *v439++ = (v443 + v441) >> 1;
                          --v440;
                        }
                        while (v440 > 1);
                      }
                    }
                  }
                }
              }
              if (*((unsigned char *)this + 185))
              {
                int v472 = *((_DWORD *)this + 41);
                if (v472 > 2)
                {
                  v474 = (void *)*((void *)this + 21);
                  v473 = (uint64_t *)*((void *)this + 22);
                  uint64_t v475 = v474[9];
                  uint64_t v476 = v474[21];
                  uint64_t v477 = v474[33];
                  if (v472 == 3) {
                    jp2_colour_converter::convert_rgb(v473, v475, v476, v477, v39);
                  }
                  else {
                    jp2_colour_converter::convert_rgb4(v473, v475, v476, v477, v474[45], v39);
                  }
                }
                else
                {
                  jp2_colour_converter::convert_lum(*((uint64_t **)this + 22), *(void *)(*((void *)this + 21) + 72), v39);
                }
              }
              if (*((int *)this + 56) >= 1)
              {
                uint64_t v478 = 0;
                while (1)
                {
                  v479 = *(_WORD **)(*((void *)this + 29) + 8 * v478);
                  if (v479)
                  {
                    uint64_t v480 = *((void *)this + 21);
                    if (v478)
                    {
                      if (v478 >= *((int *)this + 40)) {
                        uint64_t v481 = 0;
                      }
                      else {
                        uint64_t v481 = v478;
                      }
                      v480 += 96 * v481;
                    }
                    if (v478 >= v512 && a11)
                    {
                      if (v508 != 1) {
                        __assert_rtn("process_generic", "kdu_region_decompressor.cpp", 2976, "sample_bytes == 1");
                      }
                      unsigned int v482 = v39 + 1;
                      if ((int)v39 >= 1)
                      {
                        do
                        {
                          *(unsigned char *)v479 = -1;
                          v479 = (_WORD *)((char *)v479 + v40);
                          --v482;
                        }
                        while (v482 > 1);
                      }
                      goto LABEL_769;
                    }
                    if (a10)
                    {
                      BOOL v483 = 0;
                      if (v508 != 1)
                      {
                        int v484 = a10;
                        if (v508 != 2)
                        {
                          int v498 = 3007;
                          goto LABEL_820;
                        }
                        goto LABEL_768;
                      }
                      int v485 = a10;
                    }
                    else
                    {
                      if (v508 == 2)
                      {
                        int v484 = *(_DWORD *)(v480 + 88);
                        BOOL v483 = *(unsigned char *)(v480 + 92) != 0;
LABEL_768:
                        transfer_fixed_point(*(void *)(v480 + 72), v39, v506, v479, v484, v483);
                        goto LABEL_769;
                      }
                      if (v508 != 1)
                      {
                        int v498 = 2993;
LABEL_820:
                        __assert_rtn("process_generic", "kdu_region_decompressor.cpp", v498, "0");
                      }
                      int v485 = *(_DWORD *)(v480 + 88);
                      BOOL v483 = *(unsigned char *)(v480 + 92) != 0;
                    }
                    transfer_fixed_point(*(void *)(v480 + 72), v39, v506, v479, v485, v483);
                  }
LABEL_769:
                  ++v478;
                  uint64_t v486 = *((int *)this + 56);
                  if (v478 >= v486)
                  {
                    if ((int)v486 >= 1)
                    {
                      uint64_t v487 = 0;
                      uint64_t v488 = 8 * *((unsigned int *)this + 56);
                      do
                      {
                        uint64_t v489 = *((void *)this + 29);
                        uint64_t v490 = *(void *)(v489 + v487);
                        if (v490) {
                          *(void *)(v489 + v487) = v490 + v511;
                        }
                        v487 += 8;
                      }
                      while (v488 != v487);
                    }
                    break;
                  }
                }
              }
              ++v509;
              unint64_t v504 = (v504 - 1) | v504 & 0xFFFFFFFF00000000;
              ++*(_DWORD *)(a9 + 8);
              if (v503 == v502)
              {
                int v491 = *v505 + 1;
                int v492 = v491 - *v501;
                if (v491 <= *v501) {
                  __assert_rtn("process_generic", "kdu_region_decompressor.cpp", 3021, "y > 0");
                }
                int *v501 = v491;
                v501[2] -= v492;
              }
            }
            int v41 = *((_DWORD *)this + 48);
            if (v41 >= 1)
            {
              v493 = (_DWORD *)(*((void *)this + 25) + 96);
              uint64_t v494 = *((unsigned int *)this + 48);
              do
              {
                *v493 -= *(v493 - 2);
                v493 += 28;
                --v494;
              }
              while (v494);
            }
            ++*((_DWORD *)this + 31);
            --*((_DWORD *)this + 33);
          }
          --v31;
          if (v510 <= 1)
          {
            if (SHIDWORD(v504) < 1 || (int)v504 <= 0) {
              goto LABEL_785;
            }
            return 1;
          }
        }
      }
      goto LABEL_822;
    }
  }
  if (*((_DWORD *)this + 26) == *((_DWORD *)this + 22))
  {
    int v27 = *((_DWORD *)this + 33) + *((_DWORD *)this + 31);
    BOOL v28 = __OFSUB__(v27, *a8);
    int v29 = v27 - *a8;
    if (!((v29 < 0) ^ v28 | (v29 == 0)))
    {
      int v30 = a8[2];
      if (v29 >= v30) {
        int v29 = a8[2];
      }
      *a8 += v29;
      a8[2] = v30 - v29;
    }
  }
LABEL_785:
  kdu_region_decompressor::close_tile(this);
  return 1;
}

void sub_1886586C4()
{
  kdu_error::~kdu_error((kdu_error *)(v0 - 160));
}

void sub_1886586D4()
{
  if (v2 == 1)
  {
    uint64_t v3 = *(unsigned int *)__cxa_begin_catch(v1);
    *(unsigned char *)(v0 + 80) = 1;
    uint64_t v4 = *(void *)(v0 + 16);
    if (v4) {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v4 + 32))(v4, v3);
    }
    __cxa_end_catch();
    JUMPOUT(0x18865648CLL);
  }
  _Unwind_Resume(v1);
}

uint64_t kdu_region_decompressor::process(kdu_region_decompressor *this, uint64_t a2, uint64_t a3, int a4, int a5, int a6, int a7, int *a8, uint64_t a9)
{
  int v9 = *((_DWORD *)this + 41);
  if (v9 == 2)
  {
    uint64_t v18 = 0;
    memset(v17, 0, sizeof(v17));
    kdu_error::kdu_error((kdu_error *)v17, "Error in Kakadu Region Decompressor:\n");
    kdu_error::~kdu_error((kdu_error *)v17);
  }
  if (v9 == 1) {
    int v10 = 4;
  }
  else {
    int v10 = v9 + 1;
  }
  *((_DWORD *)this + 56) = v10;
  if (*((_DWORD *)this + 55) < v10)
  {
    *((_DWORD *)this + 55) = v10;
    uint64_t v11 = *((void *)this + 29);
    if (v11) {
      MEMORY[0x18C11C0C0](v11, 0x10C80436913F5);
    }
    operator new[]();
  }
  if (a4 == 4)
  {
    **((void **)this + 29) = a2;
    *(void *)(*((void *)this + 29) + 8) = a2 + 1;
    *(void *)(*((void *)this + 29) + 16) = a2 + 2;
    *(void *)(*((void *)this + 29) + 24) = a2 + 3;
    unsigned __int8 v12 = *((_DWORD *)this + 40) == *((_DWORD *)this + 41);
  }
  else
  {
    uint64_t v13 = *((unsigned int *)this + 40);
    if ((int)v13 < 1)
    {
      LODWORD(v13) = 0;
    }
    else
    {
      for (uint64_t i = 0; i != v13; ++i)
        *(void *)(*((void *)this + 29) + 8 * i) = a2 + i;
    }
    uint64_t v15 = *((unsigned int *)this + 56);
    if ((int)v13 < (int)v15)
    {
      uint64_t v13 = v13;
      do
        *(void *)(*((void *)this + 29) + 8 * v13++) = 0;
      while (v15 != v13);
    }
    unsigned __int8 v12 = 0;
  }
  return kdu_region_decompressor::process_generic(this, 1, a4, a3, a5 * a4, a6, a7, a8, a9, 8, v12);
}

void sub_188658980(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18865898C()
{
  _Unwind_Resume(v0);
}

uint64_t transfer_fixed_point(uint64_t result, int a2, int a3, unsigned char *a4, int a5, int a6)
{
  if (*(_DWORD *)result < a2) {
    transfer_fixed_point();
  }
  uint64_t v6 = *(__int16 **)(result + 8);
  if ((*(unsigned char *)(result + 6) & 2) == 0)
  {
    if ((*(unsigned char *)(result + 6) & 1) == 0 && v6)
    {
      if (a5 > 8)
      {
        char v20 = a5 - 29;
        if (a5 < 0x1D) {
          char v20 = 0;
        }
        char v21 = 29 - a5;
        if (a5 > 0x1D) {
          char v21 = 0;
        }
        unsigned int v22 = (1 << v21) >> 1;
        int v23 = -128 >> v20;
        if (a6)
        {
          unsigned int v24 = 127;
        }
        else
        {
          int v23 = 0;
          unsigned int v24 = 255;
        }
        if (!a6) {
          v22 += 4096;
        }
        if (a2 >= 1)
        {
          signed int v25 = v24 >> v20;
          unsigned int v26 = a2 + 1;
          do
          {
            int v27 = *(_DWORD *)v6;
            v6 += 2;
            int v28 = (int)(v27 + v22) >> v21;
            if (v28 >= v25) {
              int v29 = v25;
            }
            else {
              int v29 = v28;
            }
            if (v28 >= v23) {
              int v30 = v29;
            }
            else {
              int v30 = v23;
            }
            *a4 = v30 << v20;
            a4 += a3;
            --v26;
          }
          while (v26 > 1);
        }
      }
      else
      {
        char v7 = 29 - a5;
        int v8 = (1 << (29 - a5) >> 1) + 0x10000000;
        int v9 = -1 << a5;
        if (a6)
        {
          if (a2 >= 1)
          {
            unsigned int v10 = a2 + 1;
            do
            {
              int v11 = *(_DWORD *)v6;
              v6 += 2;
              int v12 = (v11 + v8) >> v7;
              if (v12 >= 0) {
                char v13 = ~(_BYTE)v9;
              }
              else {
                char v13 = 0;
              }
              if ((v12 & v9) != 0) {
                LOBYTE(v12) = v13;
              }
              *a4 = v12 - ((1 << a5) >> 1);
              a4 += a3;
              --v10;
            }
            while (v10 > 1);
          }
        }
        else if (a2 >= 1)
        {
          unsigned int v40 = a2 + 1;
          do
          {
            int v41 = *(_DWORD *)v6;
            v6 += 2;
            int v42 = (v41 + v8) >> v7;
            if (v42 >= 0) {
              char v43 = ~(_BYTE)v9;
            }
            else {
              char v43 = 0;
            }
            if ((v42 & v9) != 0) {
              LOBYTE(v42) = v43;
            }
            *a4 = v42;
            a4 += a3;
            --v40;
          }
          while (v40 > 1);
        }
      }
      return result;
    }
LABEL_85:
    transfer_fixed_point();
  }
  if (!v6) {
    goto LABEL_85;
  }
  if (*(unsigned char *)(result + 6)) {
    transfer_fixed_point();
  }
  if (a5 > 8)
  {
    char v31 = a5 - 13;
    if (a5 < 0xD) {
      char v31 = 0;
    }
    char v32 = 13 - a5;
    if (a5 > 0xD) {
      char v32 = 0;
    }
    unsigned int v33 = (1 << v32) >> 1;
    int v34 = -128 >> v31;
    if (a6)
    {
      unsigned int v35 = 127;
    }
    else
    {
      int v34 = 0;
      unsigned int v35 = 255;
    }
    if (!a6) {
      v33 += 4096;
    }
    if (a2 >= 1)
    {
      int v36 = v35 >> v31;
      unsigned int v37 = a2 + 1;
      do
      {
        int v38 = *v6++;
        int v39 = (int)(v33 + v38) >> v32;
        uint64_t result = (__int16)v39;
        if ((int)result > v36) {
          int v39 = v36;
        }
        if ((int)result < (__int16)v34) {
          int v39 = v34;
        }
        *a4 = v39 << v31;
        a4 += a3;
        --v37;
      }
      while (v37 > 1);
    }
  }
  else
  {
    char v14 = 13 - a5;
    unsigned int v15 = ((0x8000 << (13 - a5)) >> 16) + 4096;
    if (a6)
    {
      if (a2 >= 1)
      {
        unsigned int v16 = a2 + 1;
        do
        {
          int v17 = *v6++;
          int v18 = (v17 + (__int16)v15) >> v14;
          if ((v18 & 0x8000) != 0) {
            char v19 = 0;
          }
          else {
            char v19 = ~(-1 << a5);
          }
          if (((-65536 << a5) & (v18 << 16)) != 0) {
            LOBYTE(v18) = v19;
          }
          *a4 = v18 - ((0x8000 << a5) >> 16);
          a4 += a3;
          --v16;
        }
        while (v16 > 1);
      }
    }
    else if (a2 >= 1)
    {
      unsigned int v44 = a2 + 1;
      do
      {
        int v45 = *v6++;
        int v46 = (v45 + (__int16)v15) >> v14;
        if ((v46 & 0x8000) != 0) {
          char v47 = 0;
        }
        else {
          char v47 = ~(-1 << a5);
        }
        if (((-65536 << a5) & (v46 << 16)) != 0) {
          LOBYTE(v46) = v47;
        }
        *a4 = v46;
        a4 += a3;
        --v44;
      }
      while (v44 > 1);
    }
  }
  return result;
}

uint64_t transfer_fixed_point(uint64_t result, int a2, int a3, _WORD *a4, int a5, int a6)
{
  if (*(_DWORD *)result < a2) {
    transfer_fixed_point();
  }
  uint64_t v6 = *(__int16 **)(result + 8);
  if ((*(unsigned char *)(result + 6) & 2) == 0)
  {
    if ((*(unsigned char *)(result + 6) & 1) == 0 && v6)
    {
      if (a5 > 16)
      {
        char v21 = a5 - 29;
        if (a5 < 0x1D) {
          char v21 = 0;
        }
        char v22 = 29 - a5;
        if (a5 > 0x1D) {
          char v22 = 0;
        }
        unsigned int v23 = (1 << v22) >> 1;
        int v24 = -32768 >> v21;
        if (a6)
        {
          unsigned int v25 = 0x7FFF;
        }
        else
        {
          int v24 = 0;
          unsigned int v25 = 0xFFFF;
        }
        if (!a6) {
          v23 += 4096;
        }
        if (a2 >= 1)
        {
          signed int v26 = v25 >> v21;
          unsigned int v27 = a2 + 1;
          do
          {
            int v28 = *(_DWORD *)v6;
            v6 += 2;
            int v29 = (int)(v28 + v23) >> v22;
            if (v29 >= v26) {
              int v30 = v26;
            }
            else {
              int v30 = v29;
            }
            if (v29 >= v24) {
              int v31 = v30;
            }
            else {
              int v31 = v24;
            }
            *a4 = (v31 << v21);
            --v27;
            a4 += a3;
          }
          while (v27 > 1);
        }
      }
      else
      {
        char v7 = 29 - a5;
        int v8 = (1 << (29 - a5) >> 1) + 0x10000000;
        int v9 = -1 << a5;
        if (a6)
        {
          if (a2 >= 1)
          {
            unsigned int v10 = a2 + 1;
            do
            {
              int v11 = *(_DWORD *)v6;
              v6 += 2;
              int v12 = (v11 + v8) >> v7;
              if (v12 >= 0) {
                __int16 v13 = ~(_WORD)v9;
              }
              else {
                __int16 v13 = 0;
              }
              if ((v12 & v9) != 0) {
                LOWORD(v12) = v13;
              }
              *a4 = v12 - ((1 << a5) >> 1);
              --v10;
              a4 += a3;
            }
            while (v10 > 1);
          }
        }
        else if (a2 >= 1)
        {
          unsigned int v35 = a2 + 1;
          do
          {
            int v36 = *(_DWORD *)v6;
            v6 += 2;
            int v37 = (v36 + v8) >> v7;
            if (v37 >= 0) {
              __int16 v38 = ~(_WORD)v9;
            }
            else {
              __int16 v38 = 0;
            }
            if ((v37 & v9) != 0) {
              LOWORD(v37) = v38;
            }
            *a4 = v37;
            --v35;
            a4 += a3;
          }
          while (v35 > 1);
        }
      }
      return result;
    }
LABEL_98:
    transfer_fixed_point();
  }
  if (!v6) {
    goto LABEL_98;
  }
  if (*(unsigned char *)(result + 6)) {
    transfer_fixed_point();
  }
  char v14 = a5 - 13;
  if (a5 > 13)
  {
    if (a5 > 0x10)
    {
      int v43 = -32768 >> v14;
      if (a6)
      {
        unsigned int v44 = 0x7FFF;
      }
      else
      {
        int v43 = 0;
        unsigned int v44 = 0xFFFF;
      }
      if (a6) {
        int v45 = 0;
      }
      else {
        int v45 = 4096;
      }
      if (a2 >= 1)
      {
        signed int v46 = v44 >> v14;
        unsigned int v47 = a2 + 1;
        do
        {
          int v48 = *v6++;
          int v49 = v45 + v48;
          if (v45 + v48 >= v46) {
            signed int v50 = v46;
          }
          else {
            signed int v50 = v49;
          }
          if (v49 >= v43) {
            int v51 = v50;
          }
          else {
            int v51 = v43;
          }
          *a4 = v51 << v14;
          --v47;
          a4 += a3;
        }
        while (v47 > 1);
      }
    }
    else if (a6)
    {
      if (a2 >= 1)
      {
        unsigned int v32 = a2 + 1;
        do
        {
          __int16 v33 = *v6++;
          int v34 = (__int16)(v33 + 4096) & ~((__int16)(v33 + 4096) >> 31);
          if (v34 >= 0x1FFF) {
            int v34 = 0x1FFF;
          }
          *a4 = (v34 + 61440) << v14;
          --v32;
          a4 += a3;
        }
        while (v32 > 1);
      }
    }
    else if (a2 >= 1)
    {
      unsigned int v52 = a2 + 1;
      do
      {
        __int16 v53 = *v6++;
        int v54 = (__int16)(v53 + 4096) & ~((__int16)(v53 + 4096) >> 31);
        if (v54 >= 0x1FFF) {
          int v54 = 0x1FFF;
        }
        *a4 = v54 << v14;
        --v52;
        a4 += a3;
      }
      while (v52 > 1);
    }
  }
  else
  {
    char v15 = 13 - a5;
    unsigned int v16 = ((0x8000 << (13 - a5)) >> 16) + 4096;
    if (a6)
    {
      if (a2 >= 1)
      {
        unsigned int v17 = a2 + 1;
        do
        {
          int v18 = *v6++;
          int v19 = (v18 + (__int16)v16) >> v15;
          if ((v19 & 0x8000) != 0) {
            __int16 v20 = 0;
          }
          else {
            __int16 v20 = ~(-1 << a5);
          }
          if (((-65536 << a5) & (v19 << 16)) != 0) {
            LOWORD(v19) = v20;
          }
          *a4 = v19 - ((0x8000 << a5) >> 16);
          --v17;
          a4 += a3;
        }
        while (v17 > 1);
      }
    }
    else if (a2 >= 1)
    {
      unsigned int v39 = a2 + 1;
      do
      {
        int v40 = *v6++;
        int v41 = (v40 + (__int16)v16) >> v15;
        if ((v41 & 0x8000) != 0) {
          __int16 v42 = 0;
        }
        else {
          __int16 v42 = ~(-1 << a5);
        }
        if (((-65536 << a5) & (v41 << 16)) != 0) {
          LOWORD(v41) = v42;
        }
        *a4 = v41;
        --v39;
        a4 += a3;
      }
      while (v39 > 1);
    }
  }
  return result;
}

uint64_t kdu_sample_allocator::pre_alloc(uint64_t this, int a2, int a3, int a4, int a5)
{
  if (!*(unsigned char *)this) {
    kdu_sample_allocator::pre_alloc();
  }
  if (a2) {
    char v5 = 1;
  }
  else {
    char v5 = 2;
  }
  *(_DWORD *)(this + 4) += ((((a4 << v5) + 15) & 0xFFFFFFF0) + (((a3 << v5) + 15) & 0xFFFFFFF0)) * a5;
  return this;
}

uint64_t kdu_sample_allocator::alloc16(kdu_sample_allocator *this, int a2, int a3)
{
  if (*(unsigned char *)this) {
    kdu_sample_allocator::alloc16();
  }
  signed int v3 = (a2 + 7) & 0xFFFFFFF8;
  uint64_t v4 = *((void *)this + 2);
  int v5 = *((_DWORD *)this + 1);
  uint64_t v6 = *((int *)this + 2);
  int v7 = v6 + 2 * (((a3 + 7) & 0x7FFFFFF8) + v3);
  *((_DWORD *)this + 2) = v7;
  if (v7 > v5) {
    kdu_sample_allocator::alloc16();
  }
  return v4 + v6 + 2 * v3;
}

uint64_t kdu_sample_allocator::alloc32(kdu_sample_allocator *this, int a2, int a3)
{
  if (*(unsigned char *)this) {
    kdu_sample_allocator::alloc32();
  }
  signed int v3 = (a2 + 3) & 0xFFFFFFFC;
  uint64_t v4 = *((void *)this + 2);
  int v5 = *((_DWORD *)this + 1);
  uint64_t v6 = *((int *)this + 2);
  int v7 = v6 + 4 * (((a3 + 3) & 0x3FFFFFFC) + v3);
  *((_DWORD *)this + 2) = v7;
  if (v7 > v5) {
    kdu_sample_allocator::alloc32();
  }
  return v4 + v6 + 4 * v3;
}

void kdu_block::kdu_block(kdu_block *this)
{
  *((void *)this + 16) = 0;
  *((_DWORD *)this + 34) = 0;
  *((void *)this + 18) = 0;
  *((_WORD *)this + 18) = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  *(_DWORD *)((char *)this + 23) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 7) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *((_WORD *)this + 60) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 22) = 0;
  *((void *)this + 20) = 0;
}

void kdu_block::~kdu_block(kdu_block *this)
{
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C8052888210);
  }
  uint64_t v3 = *((void *)this + 8);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C80BDFB0063);
  }
  uint64_t v4 = *((void *)this + 9);
  if (v4) {
    MEMORY[0x18C11C0C0](v4 - 1, 0x1000C8077774924);
  }
  uint64_t v5 = *((void *)this + 16);
  if (v5) {
    MEMORY[0x18C11C0C0](v5, 0x1000C8052888210);
  }
  uint64_t v6 = *((void *)this + 13);
  if (v6) {
    MEMORY[0x18C11C0C0](v6, 0x1000C8052888210);
  }
}

uint64_t kdu_block::set_max_passes(uint64_t this, int a2, int a3)
{
  int v3 = *(_DWORD *)(this + 88);
  if (v3 < a2)
  {
    uint64_t v4 = this;
    if (v3) {
      BOOL v5 = a3 == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5) {
      operator new[]();
    }
    uint64_t v6 = *(void *)(this + 56);
    if (v6) {
      MEMORY[0x18C11C0C0](v6, 0x1000C8052888210);
    }
    uint64_t v7 = *(void *)(v4 + 64);
    if (v7) {
      MEMORY[0x18C11C0C0](v7, 0x1000C80BDFB0063);
    }
    operator new[]();
  }
  return this;
}

uint64_t kdu_block::set_max_bytes(uint64_t this, int a2, int a3)
{
  int v3 = *(_DWORD *)(this + 92);
  if (v3 < a2)
  {
    if (v3) {
      BOOL v4 = a3 == 0;
    }
    else {
      BOOL v4 = 1;
    }
    if (!v4) {
      operator new[]();
    }
    uint64_t v5 = *(void *)(this + 72);
    if (v5) {
      MEMORY[0x18C11C0C0](v5 - 1, 0x1000C8077774924);
    }
    operator new[]();
  }
  return this;
}

uint64_t kdu_block::set_max_samples(uint64_t this, int a2)
{
  if (*(_DWORD *)(this + 112) < a2)
  {
    uint64_t v2 = *(void *)(this + 128);
    if (v2) {
      MEMORY[0x18C11C0C0](v2, 0x1000C8052888210);
    }
    operator new[]();
  }
  return this;
}

uint64_t kdu_block::set_max_contexts(uint64_t this, int a2)
{
  if (*(_DWORD *)(this + 116) < a2)
  {
    uint64_t v2 = *(void *)(this + 104);
    if (v2) {
      MEMORY[0x18C11C0C0](v2, 0x1000C8052888210);
    }
    operator new[]();
  }
  return this;
}

uint64_t kd_block::parse_packet_header(kd_block *this, kd_header_in *a2, kd_buf_server *a3, unsigned __int16 a4)
{
  *((_WORD *)this + 13) = 0;
  if (*((unsigned char *)this + 24))
  {
    uint64_t result = kd_header_in::get_bit(a2);
    if (!result) {
      return result;
    }
  }
  else
  {
    if (*((unsigned __int16 *)this + 11) != *((unsigned __int16 *)this + 10))
    {
      exception = __cxa_allocate_exception(4uLL);
      int v51 = 999;
LABEL_100:
      _DWORD *exception = v51;
      signed int v50 = (struct type_info *)MEMORY[0x1E4FBA3A8];
      goto LABEL_95;
    }
    int v8 = (kd_block *)*((void *)this + 4);
    if (v8)
    {
      int v9 = 0;
      unsigned int v10 = this;
      do
      {
        int v11 = v10;
        unsigned int v10 = v8;
        *((void *)v11 + 4) = v9;
        int v8 = (kd_block *)*((void *)v8 + 4);
        int v9 = v11;
      }
      while (v8);
    }
    else
    {
      int v11 = 0;
      unsigned int v10 = this;
    }
    uint64_t v12 = 0;
    __int16 v13 = 0;
    *((void *)v10 + 4) = v11;
    unsigned int v14 = (unsigned __int16)(a4 + 1);
    do
    {
      if (*((unsigned __int16 *)v10 + 11) >= (unsigned __int16)v12)
      {
        uint64_t v15 = *((unsigned __int16 *)v10 + 10);
        LOWORD(v12) = *((_WORD *)v10 + 11);
      }
      else
      {
        *((_WORD *)v10 + 11) = v12;
        *((_WORD *)v10 + 10) = v12;
        uint64_t v15 = v12;
      }
      if ((unsigned __int16)v12 == (unsigned __int16)v15 && v14 > (unsigned __int16)v12)
      {
        LOWORD(v15) = v12;
        do
        {
          *((_WORD *)v10 + 11) = v15 + 1;
          int bit = kd_header_in::get_bit(a2);
          uint64_t v15 = *((unsigned __int16 *)v10 + 10);
          if (!bit)
          {
            uint64_t v15 = (v15 + 1);
            *((_WORD *)v10 + 10) = v15;
          }
          unsigned int v18 = *((unsigned __int16 *)v10 + 11);
        }
        while (v18 == (unsigned __int16)v15 && v14 > v18);
      }
      __int16 v20 = (kd_block *)*((void *)v10 + 4);
      *((void *)v10 + 4) = v13;
      uint64_t v12 = v15;
      __int16 v13 = v10;
      unsigned int v10 = v20;
    }
    while (v20);
    int v21 = *((unsigned __int16 *)this + 11);
    int v22 = *((unsigned __int16 *)this + 10);
    if (v21 != v22 && v22 != a4)
    {
      exception = __cxa_allocate_exception(2uLL);
      __int16 v49 = 21;
      goto LABEL_94;
    }
    if (v21 == v22) {
      return 0;
    }
  }
  int v23 = *((unsigned __int8 *)this + 18);
  if (*((unsigned char *)this + 24))
  {
    if (v23 != 255) {
      goto LABEL_56;
    }
    goto LABEL_57;
  }
  if (*((unsigned char *)this + 17)) {
    goto LABEL_53;
  }
  do
  {
    int v24 = (kd_block *)*((void *)this + 4);
    if (v24)
    {
      unsigned int v25 = 0;
      signed int v26 = this;
      do
      {
        unsigned int v27 = v26;
        signed int v26 = v24;
        *((void *)v27 + 4) = v25;
        int v24 = (kd_block *)*((void *)v24 + 4);
        unsigned int v25 = v27;
      }
      while (v24);
    }
    else
    {
      unsigned int v27 = 0;
      signed int v26 = this;
    }
    uint64_t v28 = 0;
    int v29 = 0;
    *((void *)v26 + 4) = v27;
    unsigned __int8 v30 = *((unsigned char *)this + 24) + 1;
    do
    {
      if (*((unsigned __int8 *)v26 + 24) >= v28)
      {
        uint64_t v31 = *((unsigned __int8 *)v26 + 17);
        LOBYTE(v28) = *((unsigned char *)v26 + 24);
      }
      else
      {
        *((unsigned char *)v26 + 24) = v28;
        *((unsigned char *)v26 + 17) = v28;
        uint64_t v31 = v28;
      }
      if (v31 == v28 && v28 < v30)
      {
        LOBYTE(v31) = v28;
        while (1)
        {
          *((unsigned char *)v26 + 24) = v31 + 1;
          int v32 = kd_header_in::get_bit(a2);
          uint64_t v31 = *((unsigned __int8 *)v26 + 17);
          if (!v32)
          {
            uint64_t v31 = (v31 + 1);
            *((unsigned char *)v26 + 17) = v31;
            if (v31 >= 0x4Bu) {
              break;
            }
          }
          unsigned int v33 = *((unsigned __int8 *)v26 + 24);
          if (v33 != v31 || v33 >= v30) {
            goto LABEL_51;
          }
        }
        *((unsigned char *)this + 24) = 0;
        *((unsigned char *)this + 18) = 0;
        exception = __cxa_allocate_exception(2uLL);
        __int16 v49 = 74;
LABEL_94:
        *(_WORD *)exception = v49;
        signed int v50 = (struct type_info *)MEMORY[0x1E4FBA3D0];
LABEL_95:
        __cxa_throw(exception, v50, 0);
      }
LABEL_51:
      int v34 = (kd_block *)*((void *)v26 + 4);
      *((void *)v26 + 4) = v29;
      uint64_t v28 = v31;
      int v29 = v26;
      signed int v26 = v34;
    }
    while (v34);
  }
  while (*((unsigned __int8 *)this + 17) == *((unsigned __int8 *)this + 24));
LABEL_53:
  *((_WORD *)this + 11) = 0;
  *((unsigned char *)this + 24) = 3;
  if (*((unsigned char *)this + 19))
  {
    exception = __cxa_allocate_exception(4uLL);
    int v51 = 998;
    goto LABEL_100;
  }
  if (v23 != 255)
  {
    kd_block::start_buffering(this, a3);
LABEL_56:
    kd_block::put_byte(this, SHIBYTE(a4), a3);
    kd_block::put_byte(this, a4, a3);
  }
LABEL_57:
  int v35 = kd_header_in::get_bit(a2);
  int v36 = v35 + 1;
  if (v35 >= 1)
  {
    v36 += kd_header_in::get_bit(a2);
    if (v36 >= 3)
    {
      v36 += kd_header_in::get_bits(a2, 2);
      if (v36 >= 6)
      {
        v36 += kd_header_in::get_bits(a2, 5);
        if (v36 >= 37) {
          v36 += kd_header_in::get_bits(a2, 7);
        }
      }
    }
  }
  while (kd_header_in::get_bit(a2))
  {
    int v37 = *((unsigned __int8 *)this + 24);
    if (v37 == 255) {
      goto LABEL_96;
    }
    *((unsigned char *)this + 24) = v37 + 1;
  }
  int v38 = *((unsigned __int8 *)this + 19);
  if (v36 >= 1)
  {
    char v39 = *((unsigned char *)this + 25);
    while (1)
    {
      if ((v39 & 4) != 0) {
        int v40 = 1;
      }
      else {
        int v40 = v36;
      }
      if ((-1431655765 * (v38 - 10)) >= 0x55555556) {
        unsigned int v41 = 1;
      }
      else {
        unsigned int v41 = 2;
      }
      if (v38 <= 9) {
        unsigned int v41 = 10 - v38;
      }
      if (v41 >= v36) {
        unsigned int v41 = v36;
      }
      int v42 = (v39 & 5) == 1 ? v41 : v40;
      int v43 = -2;
      do
        int v44 = 1 << (v43++ + 2);
      while (v44 <= v42);
      int bits = kd_header_in::get_bits(a2, *((unsigned __int8 *)this + 24) + v43);
      if (bits >= 0x8000) {
        break;
      }
      int v46 = *((unsigned __int16 *)this + 13);
      if (bits >= 0x10000 - v46) {
        break;
      }
      *((_WORD *)this + 13) = v46 + bits;
      v36 -= v42;
      if (v23 != 255)
      {
        if (v36 <= 0) {
          __int16 v47 = bits;
        }
        else {
          __int16 v47 = bits | 0x8000;
        }
        kd_block::put_byte(this, SHIBYTE(v47), a3);
        kd_block::put_byte(this, v47, a3);
        kd_block::put_byte(this, v42, a3);
      }
      v38 += v42;
      if (v36 <= 0) {
        goto LABEL_90;
      }
    }
LABEL_96:
    exception = __cxa_allocate_exception(2uLL);
    __int16 v49 = 13;
    goto LABEL_94;
  }
LABEL_90:
  *((unsigned char *)this + 19) = v38;
  if (v23 != 255) {
    *((unsigned char *)this + 18) = v38;
  }
  return *((unsigned __int16 *)this + 13);
}

uint64_t kd_block::start_buffering(kd_block *this, kd_buf_server *a2)
{
  if (*(void *)this) {
    kd_block::start_buffering();
  }
  uint64_t result = kd_buf_server::get(a2);
  *(void *)this = result;
  *((void *)this + 1) = result;
  *((unsigned char *)this + 16) = 0;
  return result;
}

uint64_t kd_block::put_byte(kd_block *this, char a2, kd_buf_server *a3)
{
  uint64_t result = *((void *)this + 1);
  if (!result) {
    kd_block::put_byte();
  }
  unsigned int v6 = *((unsigned __int8 *)this + 16);
  if (v6 == 55)
  {
    *((unsigned char *)this + 16) = 0;
    uint64_t result = kd_buf_server::get(a3);
    **((void **)this + 1) = result;
    *((void *)this + 1) = result;
    unsigned int v6 = *((unsigned __int8 *)this + 16);
  }
  *((unsigned char *)this + 16) = v6 + 1;
  *(unsigned char *)(result + v6 + 9) = a2;
  return result;
}

uint64_t kd_header_in::get_bits(kd_header_in *this, int a2)
{
  if (a2 < 1) {
    return 0;
  }
  int v2 = a2;
  LODWORD(v4) = 0;
  unsigned int v6 = (unsigned __int8 *)this + 8;
  unsigned int v5 = *((unsigned __int8 *)this + 8);
  int v7 = *((_DWORD *)this + 3);
  do
  {
    if (!v7)
    {
      if (v5 == 255) {
        int v8 = 7;
      }
      else {
        int v8 = 8;
      }
      *((_DWORD *)this + 3) = v8;
      if (!kd_input::get(*(kd_input **)this, v6))
      {
        exception = __cxa_allocate_exception(8uLL);
        void *exception = this;
      }
      int v7 = *((_DWORD *)this + 3);
      unsigned int v5 = *((unsigned __int8 *)this + 8);
    }
    if (v2 >= v7) {
      int v9 = v7;
    }
    else {
      int v9 = v2;
    }
    v7 -= v9;
    *((_DWORD *)this + 3) = v7;
    uint64_t v4 = (v5 >> v7) & ~(255 << v9) | (v4 << v9);
    BOOL v10 = __OFSUB__(v2, v9);
    v2 -= v9;
  }
  while (!((v2 < 0) ^ v10 | (v2 == 0)));
  return v4;
}

uint64_t kd_block::read_body_bytes(uint64_t this, kd_input *a2, kd_buf_server *a3)
{
  int v3 = *(unsigned __int16 *)(this + 26);
  *(_WORD *)(this + 26) = 0;
  if (v3)
  {
    uint64_t v6 = this;
    if (*(unsigned __int8 *)(this + 18) == 255)
    {
      if (*(void *)this)
      {
        exception = __cxa_allocate_exception(4uLL);
        _DWORD *exception = -1;
        __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
      }
      uint64_t v12 = kd_buf_server::get(a3);
      do
      {
        if (*((unsigned char *)a2 + 544)) {
          break;
        }
        int v13 = v3 >= 55 ? 55 : v3;
        kd_input::read(a2, (unsigned __int8 *)(v12 + 9), v13);
        BOOL v11 = __OFSUB__(v3, v13);
        v3 -= v13;
      }
      while (!((v3 < 0) ^ v11 | (v3 == 0)));
      return kd_buf_server::release((uint64_t)a3, v12);
    }
    else
    {
      unsigned __int8 v7 = *(unsigned char *)(this + 16);
      do
      {
        if (v7 == 55)
        {
          uint64_t v8 = kd_buf_server::get(a3);
          unsigned __int8 v7 = 0;
          **(void **)(v6 + 8) = v8;
          *(void *)(v6 + 8) = v8;
          *(unsigned char *)(v6 + 16) = 0;
          int v9 = 55;
        }
        else
        {
          int v9 = 55 - v7;
          uint64_t v8 = *(void *)(v6 + 8);
        }
        if (v3 >= v9) {
          int v10 = v9;
        }
        else {
          int v10 = v3;
        }
        this = kd_input::read(a2, (unsigned __int8 *)(v8 + v7 + 9), v10);
        if (!this) {
          break;
        }
        unsigned __int8 v7 = *(unsigned char *)(v6 + 16) + this;
        *(unsigned char *)(v6 + 16) = v7;
        *(_WORD *)(v6 + 22) += this;
        BOOL v11 = __OFSUB__(v3, this);
        v3 -= this;
      }
      while (!((v3 < 0) ^ v11 | (v3 == 0)));
    }
  }
  return this;
}

uint64_t kd_block::retrieve_data(kd_block *this, kdu_block *a2, int a3)
{
  int v3 = *((unsigned __int8 *)this + 18);
  if (v3 == 255)
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = 1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  *((_DWORD *)a2 + 12) = 0;
  *((_DWORD *)a2 + 11) = *((unsigned __int8 *)this + 17);
  if (!*((unsigned char *)this + 24)) {
    return 0;
  }
  int v7 = *((unsigned __int16 *)this + 11);
  if (v7 + 2 > *((_DWORD *)a2 + 23))
  {
    kdu_block::set_max_bytes((uint64_t)a2, v7 + 4096, 0);
    int v3 = *((unsigned __int8 *)this + 18);
  }
  if (*((_DWORD *)a2 + 22) < v3)
  {
    kdu_block::set_max_passes((uint64_t)a2, v3 + 32, 0);
    int v3 = *((unsigned __int8 *)this + 18);
  }
  int v8 = *((unsigned __int16 *)this + 11);
  int v9 = (unsigned __int8 *)*((void *)a2 + 9);
  v27[0] = *(uint64_t **)this;
  v27[1] = 0;
  if (!v3) {
    return 0;
  }
  int v10 = 0;
  uint64_t v11 = 0;
  while (2)
  {
    int byte = kd_block_reader::get_byte((kd_block_reader *)v27);
    int v13 = kd_block_reader::get_byte((kd_block_reader *)v27) | (byte << 8);
    if (v13 >= a3) {
      return 0;
    }
    uint64_t v14 = v11;
    if (*((_DWORD *)a2 + 12) != v10) {
      kd_block::retrieve_data();
    }
    do
    {
      int v15 = (char)kd_block_reader::get_byte((kd_block_reader *)v27);
      int v16 = kd_block_reader::get_byte((kd_block_reader *)v27);
      int v17 = kd_block_reader::get_byte((kd_block_reader *)v27);
      if (v17)
      {
        unsigned int v18 = v16 & 0xFFFF00FF | (v15 << 8);
        if (v15 >= 0) {
          int v19 = v18;
        }
        else {
          int v19 = v18 & 0x7FFF;
        }
        uint64_t v14 = v14;
        if (v14 <= *((unsigned __int8 *)this + 18)) {
          uint64_t v20 = *((unsigned __int8 *)this + 18);
        }
        else {
          uint64_t v20 = v14;
        }
        int v21 = v17 + 1;
        while (v20 != v14)
        {
          *(_DWORD *)(*((void *)a2 + 7) + 4 * v14) = v19;
          *(_WORD *)(*((void *)a2 + 8) + 2 * v14++) = 0;
          --v21;
          int v19 = 0;
          if (v21 <= 1) {
            goto LABEL_21;
          }
        }
        return 0xFFFFFFFFLL;
      }
LABEL_21:
      ;
    }
    while (v15 < 0);
    if (!(_BYTE)v14) {
      kd_block::retrieve_data();
    }
    *(_WORD *)(*((void *)a2 + 8) + 2 * v14 - 2) = ~(_WORD)v13;
    if (v11 < v14)
    {
      while (1)
      {
        int v22 = *(_DWORD *)(*((void *)a2 + 7) + 4 * v11);
        BOOL v23 = __OFSUB__(v8, v22);
        v8 -= v22;
        if (v8 < 0 != v23) {
          return 0;
        }
        *((_DWORD *)a2 + 12) = v11 + 1;
        if (v22 >= 1)
        {
          do
          {
            int bytes = kd_block_reader::get_bytes(v27, v9, v22);
            v9 += bytes;
            BOOL v23 = __OFSUB__(v22, bytes);
            v22 -= bytes;
          }
          while (!((v22 < 0) ^ v23 | (v22 == 0)));
        }
        LOBYTE(v11) = v11 + 1;
        if (v11 >= v14)
        {
          uint64_t v11 = v14;
          break;
        }
      }
    }
    uint64_t result = 0;
    int v10 = v11;
    if (v11 < *((unsigned __int8 *)this + 18)) {
      continue;
    }
    return result;
  }
}

uint64_t kd_block_reader::get_byte(kd_block_reader *this)
{
  int v1 = *((_DWORD *)this + 2);
  int v2 = *(void **)this;
  if (v1 == 55)
  {
    *((_DWORD *)this + 2) = 0;
    int v2 = (void *)*v2;
    *(void *)this = v2;
    if (!v2)
    {
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
    }
    int v1 = 0;
  }
  *((_DWORD *)this + 2) = v1 + 1;
  return *((unsigned __int8 *)v2 + v1 + 9);
}

uint64_t kd_block_reader::get_bytes(uint64_t **this, unsigned __int8 *a2, int a3)
{
  LODWORD(v3) = *((_DWORD *)this + 2);
  if (v3 == 55)
  {
    LODWORD(v3) = 0;
    *((_DWORD *)this + 2) = 0;
    uint64_t v4 = (uint64_t *)**this;
    *this = v4;
    if (!v4)
    {
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
    }
  }
  int v5 = v3 + a3;
  if ((int)v3 + a3 >= 55) {
    int v5 = 55;
  }
  if ((int)v3 >= v5)
  {
    int v6 = v3;
  }
  else
  {
    uint64_t v3 = (int)v3;
    do
      *a2++ = *((unsigned char *)*this + v3++ + 9);
    while (v5 != v3);
    LODWORD(v3) = *((_DWORD *)this + 2);
    int v6 = v5;
  }
  *((_DWORD *)this + 2) = v6;
  return (v5 - v3);
}

uint64_t kd_block::store_data(kd_block *this, kdu_block *a2, kd_buf_server *a3)
{
  if (*((_DWORD *)a2 + 7) != *((unsigned __int8 *)this + 25)) {
    kd_block::store_data();
  }
  int v4 = *((_DWORD *)a2 + 11);
  if (v4 >= 255) {
    kd_block::store_data();
  }
  if (*((int *)a2 + 12) > 255) {
    kd_block::store_data();
  }
  if (*(void *)this) {
    kd_block::store_data();
  }
  *((unsigned char *)this + 17) = v4;
  uint64_t result = kd_block::start_buffering(this, a3);
  int v8 = *((_DWORD *)a2 + 12);
  *((unsigned char *)this + 18) = v8;
  if (v8 < 1)
  {
    if ((*((_DWORD *)a2 + 23) & 0x80000000) == 0) {
      goto LABEL_23;
    }
LABEL_29:
    kd_block::store_data();
  }
  uint64_t v9 = 0;
  int v10 = 0;
  do
  {
    __int16 v11 = *(_WORD *)(*((void *)a2 + 8) + 2 * v9);
    kd_block::put_byte(this, SHIBYTE(v11), a3);
    kd_block::put_byte(this, v11, a3);
    unsigned int v12 = *(_DWORD *)(*((void *)a2 + 7) + 4 * v9);
    if (v12 >= 0x10000) {
      kd_block::store_data();
    }
    v10 += v12;
    kd_block::put_byte(this, SBYTE1(v12), a3);
    uint64_t result = kd_block::put_byte(this, v12, a3);
    ++v9;
  }
  while (v9 < *((int *)a2 + 12));
  if (v10 > *((_DWORD *)a2 + 23)) {
    goto LABEL_29;
  }
  if (v10 >= 1)
  {
    int v13 = (char *)*((void *)a2 + 9);
    do
    {
      int v14 = *((unsigned __int8 *)this + 16);
      if (v14 == 55)
      {
        uint64_t result = kd_buf_server::get(a3);
        **((void **)this + 1) = result;
        *((void *)this + 1) = result;
        *((unsigned char *)this + 16) = 0;
        int v15 = 55;
      }
      else
      {
        int v15 = 55 - v14;
      }
      if (v15 >= v10) {
        int v15 = v10;
      }
      if (v15)
      {
        int v16 = v15;
        do
        {
          char v17 = *v13++;
          uint64_t v18 = *((void *)this + 1);
          uint64_t v19 = *((unsigned __int8 *)this + 16);
          *((unsigned char *)this + 16) = v19 + 1;
          *(unsigned char *)(v18 + v19 + 9) = v17;
          --v16;
        }
        while (v16);
      }
      v10 -= v15;
    }
    while (v10 >= 1);
  }
LABEL_23:
  *((void *)this + 1) = *(void *)this;
  *((unsigned char *)this + 16) = 0;
  return result;
}

uint64_t *kd_block::store_data(kd_block *this, kdu_block *a2, kd_thread_buf_server *a3)
{
  int v3 = *((_DWORD *)a2 + 11);
  if (v3 >= 255) {
    kd_block::store_data();
  }
  if (*((int *)a2 + 12) > 255) {
    kd_block::store_data();
  }
  if (*(void *)this) {
    kd_block::store_data();
  }
  *((unsigned char *)this + 17) = v3;
  uint64_t result = kd_block::start_buffering(this, a3);
  int v8 = *((_DWORD *)a2 + 12);
  *((unsigned char *)this + 18) = v8;
  if (v8 < 1)
  {
    if ((*((_DWORD *)a2 + 23) & 0x80000000) == 0) {
      goto LABEL_22;
    }
LABEL_27:
    kd_block::store_data();
  }
  uint64_t v9 = 0;
  int v10 = 0;
  do
  {
    __int16 v11 = *(_WORD *)(*((void *)a2 + 8) + 2 * v9);
    kd_block::put_byte(this, SHIBYTE(v11), a3);
    kd_block::put_byte(this, v11, a3);
    unsigned int v12 = *(_DWORD *)(*((void *)a2 + 7) + 4 * v9);
    if (v12 >= 0x10000) {
      kd_block::store_data();
    }
    v10 += v12;
    kd_block::put_byte(this, SBYTE1(v12), a3);
    uint64_t result = kd_block::put_byte(this, v12, a3);
    ++v9;
  }
  while (v9 < *((int *)a2 + 12));
  if (v10 > *((_DWORD *)a2 + 23)) {
    goto LABEL_27;
  }
  if (v10 >= 1)
  {
    int v13 = (char *)*((void *)a2 + 9);
    do
    {
      int v14 = *((unsigned __int8 *)this + 16);
      if (v14 == 55)
      {
        uint64_t result = kd_thread_buf_server::get(a3);
        **((void **)this + 1) = result;
        *((void *)this + 1) = result;
        *((unsigned char *)this + 16) = 0;
        int v15 = 55;
      }
      else
      {
        int v15 = 55 - v14;
      }
      if (v15 >= v10) {
        int v15 = v10;
      }
      if (v15)
      {
        int v16 = v15;
        do
        {
          char v17 = *v13++;
          uint64_t v18 = *((void *)this + 1);
          uint64_t v19 = *((unsigned __int8 *)this + 16);
          *((unsigned char *)this + 16) = v19 + 1;
          *(unsigned char *)(v18 + v19 + 9) = v17;
          --v16;
        }
        while (v16);
      }
      v10 -= v15;
    }
    while (v10 >= 1);
  }
LABEL_22:
  *((void *)this + 1) = *(void *)this;
  *((unsigned char *)this + 16) = 0;
  return result;
}

uint64_t *kd_block::start_buffering(kd_block *this, kd_thread_buf_server *a2)
{
  if (*(void *)this) {
    kd_block::start_buffering();
  }
  uint64_t result = kd_thread_buf_server::get(a2);
  *(void *)this = result;
  *((void *)this + 1) = result;
  *((unsigned char *)this + 16) = 0;
  return result;
}

uint64_t *kd_block::put_byte(kd_block *this, char a2, kd_thread_buf_server *a3)
{
  uint64_t result = (uint64_t *)*((void *)this + 1);
  if (!result) {
    kd_block::put_byte();
  }
  unsigned int v6 = *((unsigned __int8 *)this + 16);
  if (v6 == 55)
  {
    *((unsigned char *)this + 16) = 0;
    uint64_t result = kd_thread_buf_server::get(a3);
    **((void **)this + 1) = result;
    *((void *)this + 1) = result;
    unsigned int v6 = *((unsigned __int8 *)this + 16);
  }
  *((unsigned char *)this + 16) = v6 + 1;
  *((unsigned char *)result + v6 + 9) = a2;
  return result;
}

uint64_t *kd_thread_buf_server::get(kd_thread_buf_server *this)
{
  uint64_t result = (uint64_t *)*((void *)this + 3);
  if (!result)
  {
    kd_thread_buf_server::augment_local_store(this, 0);
    uint64_t result = (uint64_t *)*((void *)this + 3);
  }
  uint64_t v3 = *result;
  *((void *)this + 3) = *result;
  if (!v3) {
    *((void *)this + 4) = 0;
  }
  *uint64_t result = 0;
  --*((_DWORD *)this + 3);
  return result;
}

uint64_t kd_block::trim_data(kd_block *this, unsigned int a2, kd_buf_server *a3)
{
  if (!*((unsigned char *)this + 18)) {
    return 0;
  }
  int v5 = this;
  unsigned int v6 = 0;
  int v7 = 0;
  int v8 = 0;
  unsigned int v9 = 0;
  char v10 = *((unsigned char *)this + 16);
  uint64_t v24 = *((void *)this + 1);
  *((void *)this + 1) = *(void *)this;
  *((unsigned char *)this + 16) = 0;
  while (1)
  {
    int byte = kd_block::get_byte(v5);
    int v12 = kd_block::get_byte(v5) | (byte << 8);
    if (v12 - 1 < a2) {
      break;
    }
    int v13 = kd_block::get_byte(v5);
    v8 += kd_block::get_byte(v5) + (v13 << 8);
    unsigned int v14 = v9 + 1;
    if (v12)
    {
      int v7 = v8;
      unsigned int v6 = v9 + 1;
    }
    unsigned int v15 = *((unsigned __int8 *)v5 + 18);
    ++v9;
    if (v14 >= v15)
    {
      unsigned int v9 = v14;
      goto LABEL_9;
    }
  }
  unsigned int v15 = *((unsigned __int8 *)v5 + 18);
LABEL_9:
  *((void *)v5 + 1) = v24;
  *((unsigned char *)v5 + 16) = v10;
  if (v9 == v15) {
    return 0;
  }
  int v17 = 4 * v6 + 55;
  uint64_t v18 = v5;
  do
  {
    uint64_t v18 = *(kd_block **)v18;
    v17 -= 55;
  }
  while (v17 > 55);
  if (4 * (v15 - v6))
  {
    int v19 = 4 * v6 - 4 * v15;
    do
    {
      if (v17 == 55)
      {
        int v17 = 0;
        uint64_t v18 = *(kd_block **)v18;
      }
      uint64_t v20 = (char *)v18 + v17++;
      v20[9] = 0;
    }
    while (!__CFADD__(v19++, 1));
    unsigned int v15 = *((unsigned __int8 *)v5 + 18);
  }
  int v22 = v7 + 4 * v15 + 55;
  do
  {
    int v5 = *(kd_block **)v5;
    v22 -= 55;
  }
  while (v22 > 55);
  while (1)
  {
    BOOL v23 = *(kd_block **)v5;
    if (!*(void *)v5) {
      break;
    }
    *(void *)int v5 = *(void *)v23;
    kd_buf_server::release((uint64_t)a3, (uint64_t)v23);
  }
  return 1;
}

uint64_t kd_block::get_byte(kd_block *this)
{
  unsigned int v1 = *((unsigned __int8 *)this + 16);
  if (v1 == 55)
  {
    *((unsigned char *)this + 16) = 0;
    int v2 = (uint64_t *)*((void *)this + 1);
    uint64_t v3 = *v2;
    *((void *)this + 1) = *v2;
    if (!v3) {
      kd_block::get_byte();
    }
    unsigned int v1 = 0;
  }
  else
  {
    uint64_t v3 = *((void *)this + 1);
  }
  *((unsigned char *)this + 16) = v1 + 1;
  return *(unsigned __int8 *)(v3 + v1 + 9);
}

uint64_t kd_block::start_packet(kd_block *this, int a2, unsigned int a3)
{
  __int16 v4 = a2;
  if (a2)
  {
    LODWORD(v6) = *((unsigned __int8 *)this + 19);
    int v7 = *((unsigned __int8 *)this + 18);
  }
  else
  {
    *((unsigned char *)this + 19) = 0;
    *((void *)this + 1) = *(void *)this;
    *((unsigned char *)this + 16) = 0;
    *((_WORD *)this + 10) = -1;
    int v7 = *((unsigned __int8 *)this + 18);
    if (!*((unsigned char *)this + 18)) {
      *((unsigned char *)this + 17) = -1;
    }
    uint64_t v6 = *((void *)this + 4);
    if (v6)
    {
      while (1)
      {
        unsigned int v17 = *((unsigned __int8 *)this + 17);
        if (*(unsigned __int8 *)(v6 + 17) <= v17) {
          break;
        }
        *(unsigned char *)(v6 + 17) = v17;
        uint64_t v6 = *(void *)(v6 + 32);
        if (!v6) {
          goto LABEL_3;
        }
      }
      LODWORD(v6) = 0;
    }
  }
LABEL_3:
  *((unsigned char *)this + 22) = 0;
  *((_WORD *)this + 13) = 0;
  int v8 = v7 - v6;
  if (v7 == v6)
  {
    uint64_t result = 0;
    *((_WORD *)this + 10) = -1;
  }
  else
  {
    uint64_t v10 = *((void *)this + 1);
    char v11 = *((unsigned char *)this + 16);
    if (v8 >= 1)
    {
      int v12 = 0;
      unsigned int v13 = 0;
      do
      {
        int byte = kd_block::get_byte(this);
        int v15 = kd_block::get_byte(this) | (byte << 8);
        if (v15 - 1 < a3) {
          break;
        }
        int v16 = kd_block::get_byte(this);
        ++v12;
        v13 += kd_block::get_byte(this) + (v16 << 8);
        if (v15)
        {
          *((unsigned char *)this + 22) = v12;
          if (v13 >= 0x10000) {
            kd_block::start_packet();
          }
          *((_WORD *)this + 13) = v13;
        }
      }
      while (v8 != v12);
      LODWORD(v6) = *((unsigned __int8 *)this + 19);
    }
    *((void *)this + 1) = v10;
    *((unsigned char *)this + 16) = v11;
    if (!v6)
    {
      if (*((unsigned char *)this + 22))
      {
        *((_WORD *)this + 10) = v4;
        for (uint64_t i = *((void *)this + 4); i; uint64_t i = *(void *)(i + 32))
        {
          unsigned int v19 = *((unsigned __int16 *)this + 10);
          if (*(unsigned __int16 *)(i + 20) <= v19) {
            break;
          }
          *(_WORD *)(i + 20) = v19;
        }
      }
      else
      {
        *((_WORD *)this + 10) = -1;
      }
    }
    return *((unsigned __int16 *)this + 13);
  }
  return result;
}

unsigned __int8 *kd_block::write_packet_header(unsigned __int8 *this, kd_header_out *a2, __int16 a3, int a4)
{
  uint64_t v5 = (uint64_t)this;
  int v6 = this[22];
  if (this[19])
  {
    this = kd_header_out::put_bit((unsigned __int8 *)a2, v6 != 0);
    if (!v6) {
      return this;
    }
    goto LABEL_24;
  }
  int v7 = *((unsigned __int16 *)this + 10);
  if (!this[22])
  {
    if (v7 == 0xFFFF) {
      goto LABEL_6;
    }
LABEL_11:
    kd_block::write_packet_header();
  }
  if (v7 == 0xFFFF) {
    goto LABEL_11;
  }
LABEL_6:
  *((_WORD *)this + 11) = a3;
  uint64_t v8 = *((void *)this + 4);
  if (v8)
  {
    unsigned int v9 = 0;
    uint64_t v10 = this;
    do
    {
      char v11 = v10;
      uint64_t v10 = (unsigned __int8 *)v8;
      *((void *)v11 + 4) = v9;
      uint64_t v8 = *(void *)(v8 + 32);
      unsigned int v9 = v11;
    }
    while (v8);
  }
  else
  {
    char v11 = 0;
    uint64_t v10 = this;
  }
  LOWORD(v12) = 0;
  unsigned int v13 = 0;
  *((void *)v10 + 4) = v11;
  unsigned __int16 v14 = *((_WORD *)this + 11) + 1;
  do
  {
    unsigned int v15 = *((unsigned __int16 *)v10 + 11);
    if (v15 < (unsigned __int16)v12)
    {
      *((_WORD *)v10 + 11) = v12;
      LOWORD(v15) = v12;
    }
    unsigned int v12 = *((unsigned __int16 *)v10 + 10);
    if (v12 >= (unsigned __int16)v15 && (unsigned __int16)v15 < v14)
    {
      do
      {
        *((_WORD *)v10 + 11) = v15 + 1;
        this = kd_header_out::put_bit((unsigned __int8 *)a2, (unsigned __int16)v12 <= (unsigned __int16)v15);
        unsigned int v12 = *((unsigned __int16 *)v10 + 10);
        unsigned int v15 = *((unsigned __int16 *)v10 + 11);
      }
      while (v12 >= v15 && v15 < v14);
    }
    if (v12 >= (unsigned __int16)v15) {
      LOWORD(v12) = v15;
    }
    int v16 = (unsigned __int8 *)*((void *)v10 + 4);
    *((void *)v10 + 4) = v13;
    unsigned int v13 = v10;
    uint64_t v10 = v16;
  }
  while (v16);
  *(unsigned char *)(v5 + 22) = v6;
  if (v6)
  {
LABEL_24:
    if (!*(unsigned char *)(v5 + 19))
    {
      *(unsigned char *)(v5 + 24) = 0;
      do
      {
        uint64_t v17 = *(void *)(v5 + 32);
        if (v17)
        {
          uint64_t v18 = 0;
          uint64_t v19 = v5;
          do
          {
            uint64_t v20 = v19;
            uint64_t v19 = v17;
            *(void *)(v20 + 32) = v18;
            uint64_t v17 = *(void *)(v17 + 32);
            uint64_t v18 = v20;
          }
          while (v17);
        }
        else
        {
          uint64_t v20 = 0;
          uint64_t v19 = v5;
        }
        LOBYTE(v21) = 0;
        uint64_t v22 = 0;
        *(void *)(v19 + 32) = v20;
        unsigned __int8 v23 = *(unsigned char *)(v5 + 24) + 1;
        do
        {
          unsigned int v24 = *(unsigned __int8 *)(v19 + 24);
          if (v24 < v21)
          {
            *(unsigned char *)(v19 + 24) = v21;
            LOBYTE(v24) = v21;
          }
          unsigned int v21 = *(unsigned __int8 *)(v19 + 17);
          if (v21 >= v24 && v24 < v23)
          {
            do
            {
              *(unsigned char *)(v19 + 24) = v24 + 1;
              kd_header_out::put_bit((unsigned __int8 *)a2, v21 <= v24);
              unsigned int v21 = *(unsigned __int8 *)(v19 + 17);
              unsigned int v24 = *(unsigned __int8 *)(v19 + 24);
            }
            while (v21 >= v24 && v24 < v23);
          }
          if (v21 >= v24) {
            LOBYTE(v21) = v24;
          }
          uint64_t v25 = *(void *)(v19 + 32);
          *(void *)(v19 + 32) = v22;
          uint64_t v22 = v19;
          uint64_t v19 = v25;
        }
        while (v25);
      }
      while (*(unsigned __int8 *)(v5 + 24) <= *(unsigned __int8 *)(v5 + 17));
      *(unsigned char *)(v5 + 24) = 3;
    }
    int v26 = *(unsigned __int8 *)(v5 + 22) - 1;
    if (v26 >= 1) {
      unsigned int v27 = 1;
    }
    else {
      unsigned int v27 = *(unsigned __int8 *)(v5 + 22) - 1;
    }
    int v28 = v26 - v27;
    kd_header_out::put_bit((unsigned __int8 *)a2, v27);
    if (v27)
    {
      unsigned int v29 = v28 >= 1 ? 1 : v28;
      int v30 = v28 - v29;
      kd_header_out::put_bit((unsigned __int8 *)a2, v29);
      if (v29)
      {
        unsigned int v31 = 3;
        unsigned int v32 = v30 >= 3 ? 3 : v30;
        do
          kd_header_out::put_bit((unsigned __int8 *)a2, (v32 >> (v31-- - 2)) & 1);
        while (v31 > 1);
        int v28 = v30 - v32;
        if (v30 >= 3)
        {
          unsigned int v33 = v28 >= 31 ? 31 : v28;
          for (unsigned int i = 6; i > 1; --i)
            kd_header_out::put_bit((unsigned __int8 *)a2, (v33 >> (i - 2)) & 1);
          int v35 = v28 - v33;
          BOOL v36 = v28 < 31;
          int v28 = v35;
          if (!v36)
          {
            if (v35 >= 127) {
              unsigned int v37 = 127;
            }
            else {
              unsigned int v37 = v35;
            }
            for (unsigned int j = 8; j > 1; --j)
              kd_header_out::put_bit((unsigned __int8 *)a2, (v37 >> (j - 2)) & 1);
            int v28 = v35 - v37;
          }
        }
      }
    }
    if (v28) {
      kd_block::write_packet_header();
    }
    char v39 = *(unsigned char *)(v5 + 25);
    uint64_t v71 = *(void *)(v5 + 8);
    char v70 = *(unsigned char *)(v5 + 16);
    unsigned int v40 = *(unsigned __int8 *)(v5 + 22);
    char v81 = v39;
    int v41 = 0;
    if (*(unsigned char *)(v5 + 22))
    {
      int v42 = *(unsigned __int8 *)(v5 + 19);
      int v73 = v39 & 5;
      do
      {
        int v79 = v41;
        int v43 = 0;
        if ((v39 & 4) != 0) {
          int v44 = 1;
        }
        else {
          int v44 = v40;
        }
        if ((-1431655765 * (v42 - 10)) >= 0x55555556) {
          unsigned int v45 = 1;
        }
        else {
          unsigned int v45 = 2;
        }
        if (v42 <= 9) {
          unsigned int v45 = 10 - v42;
        }
        if (v45 >= v40) {
          unsigned int v45 = v40;
        }
        if (v73 == 1) {
          int v46 = v45;
        }
        else {
          int v46 = v44;
        }
        char v47 = -2;
        do
        {
          int v48 = v43;
          int v49 = 1 << (v47 + 2);
          ++v47;
          ++v43;
        }
        while (v49 <= v46);
        int v75 = *(unsigned __int8 *)(v5 + 24);
        signed int v77 = v40;
        if (v46 < 1)
        {
          int v50 = 0;
        }
        else
        {
          int v50 = 0;
          unsigned int v51 = v46 + 1;
          do
          {
            kd_block::get_byte((kd_block *)v5);
            kd_block::get_byte((kd_block *)v5);
            int byte = kd_block::get_byte((kd_block *)v5);
            v50 += kd_block::get_byte((kd_block *)v5) + (byte << 8);
            --v51;
          }
          while (v51 > 1);
        }
        if (v50 >= 1 << (v75 + v47))
        {
          int v53 = v75 + v48;
          do
          {
            kd_header_out::put_bit((unsigned __int8 *)a2, 1u);
            ++*(unsigned char *)(v5 + 24);
            int v54 = 1 << v53++;
          }
          while (v50 >= v54);
        }
        int v41 = v50 + v79;
        v42 += v46;
        unsigned int v40 = v77 - v46;
        char v39 = v81;
      }
      while (v77 > v46);
    }
    if (v41 != *(unsigned __int16 *)(v5 + 26)) {
      kd_block::write_packet_header();
    }
    this = kd_header_out::put_bit((unsigned __int8 *)a2, 0);
    *(void *)(v5 + 8) = v71;
    *(unsigned char *)(v5 + 16) = v70;
    unsigned int v55 = *(unsigned __int8 *)(v5 + 22);
    if (*(unsigned char *)(v5 + 22))
    {
      int v56 = 0;
      int v57 = *(unsigned __int8 *)(v5 + 19);
      int v74 = v39 & 5;
      do
      {
        int v58 = 0;
        if ((v39 & 4) != 0) {
          int v59 = 1;
        }
        else {
          int v59 = v55;
        }
        if ((-1431655765 * (v57 - 10)) >= 0x55555556) {
          unsigned int v60 = 1;
        }
        else {
          unsigned int v60 = 2;
        }
        if (v57 <= 9) {
          unsigned int v60 = 10 - v57;
        }
        if (v60 >= v55) {
          unsigned int v60 = v55;
        }
        if (v74 == 1) {
          int v61 = v60;
        }
        else {
          int v61 = v59;
        }
        int v62 = -2;
        do
        {
          int v63 = v58;
          int v64 = 1 << (v62++ + 2);
          ++v58;
        }
        while (v64 <= v61);
        int v65 = *(unsigned __int8 *)(v5 + 24);
        signed int v78 = v55;
        int v80 = v56;
        int v76 = v57;
        int v66 = 0;
        if (v61 >= 1)
        {
          unsigned int v67 = v61 + 1;
          do
          {
            kd_block::get_byte((kd_block *)v5);
            kd_block::get_byte((kd_block *)v5);
            int v68 = kd_block::get_byte((kd_block *)v5);
            this = (unsigned __int8 *)kd_block::get_byte((kd_block *)v5);
            v66 += this + (v68 << 8);
            --v67;
          }
          while (v67 > 1);
        }
        if (v66 >= 1 << (v65 + v62)) {
          kd_block::write_packet_header();
        }
        if (v65 + v62 >= 1)
        {
          do
            this = kd_header_out::put_bit((unsigned __int8 *)a2, (v66 >> (v65 + v63-- - 2)) & 1);
          while ((v65 + v63) > 1);
        }
        int v56 = v66 + v80;
        int v57 = v61 + v76;
        unsigned int v55 = v78 - v61;
        char v39 = v81;
      }
      while (v78 > v61);
    }
    else
    {
      int v56 = 0;
    }
    if (v56 != *(unsigned __int16 *)(v5 + 26)) {
      kd_block::write_packet_header();
    }
    if (a4)
    {
      *(void *)(v5 + 8) = v71;
      *(unsigned char *)(v5 + 16) = v70;
    }
    else
    {
      char v69 = *(unsigned char *)(v5 + 19);
      if (!v69) {
        *(_WORD *)(v5 + 20) = 4 * *(unsigned __int8 *)(v5 + 18);
      }
      *(unsigned char *)(v5 + 19) = *(unsigned char *)(v5 + 22) + v69;
      *(unsigned char *)(v5 + 22) = 0;
    }
  }
  return this;
}

_DWORD *kd_block::write_body_bytes(_DWORD *this, kdu_output *a2)
{
  int v2 = *((unsigned __int16 *)this + 13);
  if (*((_WORD *)this + 13))
  {
    __int16 v4 = this;
    unsigned __int16 v5 = *((_WORD *)this + 10);
    int v6 = *(char **)this;
    int v7 = (unsigned __int16)(v5
                          - 55
                          * ((((unsigned __int16)(v5 - ((10725 * v5) >> 16)) >> 1)
                            + ((10725 * v5) >> 16)) >> 5));
    int v8 = v5 + 55;
    while (1)
    {
      v8 -= 55;
      if (v8 < 55) {
        break;
      }
      int v6 = *(char **)v6;
      if (!v6) {
        kd_block::write_body_bytes();
      }
    }
    *((_WORD *)this + 10) = v5 + v2;
    *((_WORD *)this + 13) = 0;
    do
    {
      if (!v6) {
        kd_block::write_body_bytes();
      }
      if (55 - v7 >= v2) {
        int v9 = v2;
      }
      else {
        int v9 = 55 - v7;
      }
      v2 -= v9;
      this = kdu_output::write(a2, &v6[v7 + 9], v9);
      int v7 = 0;
      int v6 = *(char **)v6;
    }
    while (v2 > 0);
    *((unsigned char *)v4 + 22) = 0;
  }
  return this;
}

_DWORD *kdu_output::write(_DWORD *this, char *a2, int a3)
{
  if (a3 >= 1)
  {
    int v3 = a3;
    unsigned __int16 v5 = this;
    do
    {
      int v6 = v5[132] - v5[130];
      if (!v6)
      {
        this = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(void *)v5 + 16))(v5);
        int v6 = v5[132] - v5[130];
      }
      if (v3 < v6) {
        int v6 = v3;
      }
      if (v6)
      {
        int v7 = v6;
        do
        {
          char v8 = *a2++;
          int v9 = (unsigned char *)*((void *)v5 + 65);
          *((void *)v5 + 65) = v9 + 1;
          unsigned char *v9 = v8;
          --v7;
        }
        while (v7);
      }
      v3 -= v6;
    }
    while (v3 >= 1);
  }
  return this;
}

char *kd_block::build_tree(unint64_t a1, void **a2, uint64_t a3)
{
  int v3 = a1;
  unint64_t v4 = HIDWORD(a1);
  signed int v5 = HIDWORD(a1) * a1;
  if (HIDWORD(a1) * a1 < 0) {
    kd_block::build_tree();
  }
  int v6 = 1;
  if (v5 >= 2)
  {
    int v7 = a1;
    unint64_t v8 = HIDWORD(a1);
    do
    {
      LODWORD(v8) = ((int)v8 + 1) >> 1;
      int v7 = (v7 + 1) >> 1;
      v5 += v7 * v8;
      ++v6;
    }
    while (v7 * (int)v8 > 1);
  }
  if (!v5) {
    return 0;
  }
  int v9 = (char *)*a2;
  *a2 = (char *)*a2 + 40 * v5;
  if (40 * v5 > a3)
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -1;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  signed int v10 = v5;
  bzero(v9, 40 * v5);
  int v11 = 0;
  unsigned int v12 = v9;
  do
  {
    if (v3 >= 1)
    {
      unsigned int v13 = 0;
      unsigned __int16 v14 = &v12[40 * v3 * (int)v4];
      do
      {
        if ((int)v4 >= 1)
        {
          unsigned int v15 = 0;
          do
          {
            *((void *)v12 + 4) = &v14[40 * (v13 >> 1) * (((int)v4 + 1) >> 1) + 40 * (v15 >> 1)];
            if (v11 == v6 - 1)
            {
              if (v15 | v13) {
                kd_block::build_tree();
              }
              *((void *)v12 + 4) = 0;
            }
            ++v15;
            v12 += 40;
          }
          while (v4 != v15);
        }
        ++v13;
      }
      while (v13 != v3);
    }
    int v3 = (v3 + 1) >> 1;
    ++v11;
    LODWORD(v4) = ((int)v4 + 1) >> 1;
  }
  while (v11 != v6);
  if (v12 != &v9[40 * v10]) {
    kd_block::build_tree();
  }
  return v9;
}

uint64_t kd_block::reset_output_tree(uint64_t result, unint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = HIDWORD(a2);
    if (HIDWORD(a2))
    {
      int v3 = 0;
      char v4 = 1;
      while ((v4 & 1) == 0)
      {
        if ((int)a2 >= 1)
        {
          int v5 = 0;
          do
          {
            if ((int)v2 >= 1)
            {
              int v6 = v2;
              do
              {
                *(unsigned char *)(result + 24) = 0;
                *(unsigned char *)(result + 17) = -1;
                *(_DWORD *)(result + 20) = 0xFFFF;
                result += 40;
                --v6;
              }
              while (v6);
            }
            ++v5;
          }
          while (v5 != a2);
          int v3 = v2 & ~((int)v2 >> 31);
          goto LABEL_13;
        }
        int v7 = 0;
LABEL_14:
        char v4 = 0;
        LODWORD(a2) = ((int)a2 + 1) >> 1;
        LODWORD(v2) = ((int)v2 + 1) >> 1;
        if (v3 <= 1 && v7 <= 1) {
          return result;
        }
      }
      result += 40 * (int)a2 * (int)v2;
      int v3 = v2;
LABEL_13:
      int v7 = a2;
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t kd_block::save_output_tree(uint64_t result, unint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = HIDWORD(a2);
    if (HIDWORD(a2))
    {
      int v3 = 0;
      char v4 = 1;
      do
      {
        if ((int)a2 < 1)
        {
          unsigned int v12 = 0;
        }
        else
        {
          int v5 = 0;
          int v3 = v2 & ~((int)v2 >> 31);
          do
          {
            if ((int)v2 >= 1)
            {
              int v6 = 0;
              do
              {
                if (v4)
                {
                  int v7 = *(unsigned __int8 *)(result + 22);
                  int v8 = *(unsigned __int8 *)(result + 16) + 4 * v7;
                  if (v8 < 0x38)
                  {
                    char v10 = *(unsigned char *)(result + 16) + 4 * v7;
                  }
                  else
                  {
                    int v9 = *(void **)(result + 8);
                    do
                    {
                      int v9 = (void *)*v9;
                      *(void *)(result + 8) = v9;
                      if (!v9) {
                        kd_block::save_output_tree();
                      }
                      char v10 = v8 - 55;
                      BOOL v11 = v8 <= 110;
                      v8 -= 55;
                    }
                    while (!v11);
                  }
                  *(unsigned char *)(result + 16) = v10;
                  *(unsigned char *)(result + 19) += v7;
                  *(unsigned char *)(result + 22) = 0;
                  *(unsigned char *)(result + 20) = *(unsigned char *)(result + 24);
                }
                else
                {
                  *(_WORD *)uint64_t result = *(_WORD *)(result + 20);
                  *(_WORD *)(result + 8) = *(_WORD *)(result + 22);
                  *(unsigned char *)(result + 16) = *(unsigned char *)(result + 24);
                }
                ++v6;
                result += 40;
              }
              while (v6 != v2);
            }
            ++v5;
          }
          while (v5 != a2);
          unsigned int v12 = a2;
        }
        char v4 = 0;
        LODWORD(a2) = ((int)a2 + 1) >> 1;
        LODWORD(v2) = ((int)v2 + 1) >> 1;
      }
      while (v3 > 1 || v12 > 1);
    }
  }
  return result;
}

uint64_t kd_block::restore_output_tree(uint64_t result, unint64_t a2)
{
  if (a2)
  {
    unint64_t v2 = HIDWORD(a2);
    if (HIDWORD(a2))
    {
      int v3 = 0;
      char v4 = 1;
      do
      {
        if (v4)
        {
          if ((int)a2 >= 1)
          {
            int v5 = 0;
            do
            {
              if ((int)v2 >= 1)
              {
                int v6 = v2;
                do
                {
                  *(unsigned char *)(result + 24) = *(unsigned char *)(result + 20);
                  result += 40;
                  --v6;
                }
                while (v6);
              }
              ++v5;
            }
            while (v5 != a2);
LABEL_18:
            int v3 = v2 & ~((int)v2 >> 31);
            unsigned int v9 = a2;
            goto LABEL_20;
          }
        }
        else if ((int)a2 >= 1)
        {
          int v7 = 0;
          do
          {
            if ((int)v2 >= 1)
            {
              int v8 = v2;
              do
              {
                *(_WORD *)(result + 20) = *(_WORD *)result;
                *(_WORD *)(result + 22) = *(_WORD *)(result + 8);
                *(unsigned char *)(result + 24) = *(unsigned char *)(result + 16);
                result += 40;
                --v8;
              }
              while (v8);
            }
            ++v7;
          }
          while (v7 != a2);
          goto LABEL_18;
        }
        unsigned int v9 = 0;
LABEL_20:
        char v4 = 0;
        LODWORD(a2) = ((int)a2 + 1) >> 1;
        LODWORD(v2) = ((int)v2 + 1) >> 1;
      }
      while (v3 > 1 || v9 > 1);
    }
  }
  return result;
}

void *_cg_jinit_color_converter(uint64_t *a1)
{
  uint64_t result = (void *)(*(uint64_t (**)(void))a1[1])();
  int v3 = result;
  a1[67] = (uint64_t)result;
  *uint64_t result = null_method;
  unsigned int v4 = *((_DWORD *)a1 + 15);
  if (v4 > 7) {
    goto LABEL_53;
  }
  if (((1 << v4) & 0xCC) == 0)
  {
    if (((1 << v4) & 0x30) != 0)
    {
      if (*((_DWORD *)a1 + 14) == 4) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
    if (v4 == 1)
    {
      if (*((_DWORD *)a1 + 14) == 1) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
LABEL_53:
    if (*((int *)a1 + 14) > 0) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  if (*((_DWORD *)a1 + 14) != 3)
  {
LABEL_4:
    uint64_t v5 = *a1;
    *(_DWORD *)(v5 + 40) = 10;
    uint64_t result = (void *)(*(uint64_t (**)(uint64_t *))v5)(a1);
  }
LABEL_5:
  if (*((_DWORD *)a1 + 85) && (*((_DWORD *)a1 + 24) | 4) != 6)
  {
    uint64_t v6 = *a1;
    *(_DWORD *)(v6 + 40) = 28;
    uint64_t result = (void *)(*(uint64_t (**)(uint64_t *))v6)(a1);
  }
  int v7 = *((_DWORD *)a1 + 24);
  switch(v7)
  {
    case 1:
      if (*((_DWORD *)a1 + 23) != 1)
      {
        uint64_t v12 = *a1;
        *(_DWORD *)(v12 + 40) = 11;
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t *))v12)(a1);
      }
      switch(*((_DWORD *)a1 + 15))
      {
        case 1:
        case 3:
        case 7:
          BOOL v11 = grayscale_convert;
          goto LABEL_58;
        case 2:
          void *v3 = rgb_ycc_start;
          BOOL v11 = rgb_gray_convert;
          goto LABEL_58;
        default:
          goto LABEL_50;
      }
    case 2:
    case 6:
      if (*((_DWORD *)a1 + 23) != 3)
      {
        uint64_t v8 = *a1;
        *(_DWORD *)(v8 + 40) = 11;
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t *))v8)(a1);
        int v7 = *((_DWORD *)a1 + 24);
      }
      if (*((_DWORD *)a1 + 15) != v7)
      {
        uint64_t v9 = *a1;
        *(_DWORD *)(v9 + 40) = 28;
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t *))v9)(a1);
      }
      int v10 = *((_DWORD *)a1 + 85);
      if (v10 == 1)
      {
        BOOL v11 = rgb_rgb1_convert;
      }
      else
      {
        if (v10) {
          goto LABEL_50;
        }
        BOOL v11 = rgb_convert;
      }
      goto LABEL_58;
    case 3:
      if (*((_DWORD *)a1 + 23) != 3)
      {
        uint64_t v13 = *a1;
        *(_DWORD *)(v13 + 40) = 11;
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t *))v13)(a1);
      }
      int v14 = *((_DWORD *)a1 + 15);
      if (v14 == 3) {
        goto LABEL_57;
      }
      if (v14 != 2) {
        goto LABEL_50;
      }
      goto LABEL_49;
    case 4:
      if (*((_DWORD *)a1 + 23) != 4)
      {
        uint64_t v15 = *a1;
        *(_DWORD *)(v15 + 40) = 11;
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t *))v15)(a1);
      }
      if (*((_DWORD *)a1 + 15) != 4) {
        goto LABEL_37;
      }
      goto LABEL_57;
    case 5:
      if (*((_DWORD *)a1 + 23) != 4)
      {
        uint64_t v17 = *a1;
        *(_DWORD *)(v17 + 40) = 11;
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t *))v17)(a1);
      }
      int v18 = *((_DWORD *)a1 + 15);
      if (v18 == 5) {
        goto LABEL_57;
      }
      if (v18 != 4) {
        goto LABEL_50;
      }
      void *v3 = rgb_ycc_start;
      BOOL v11 = cmyk_ycck_convert;
      goto LABEL_58;
    case 7:
      if (*((_DWORD *)a1 + 23) != 3)
      {
        uint64_t v19 = *a1;
        *(_DWORD *)(v19 + 40) = 11;
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t *))v19)(a1);
      }
      int v20 = *((_DWORD *)a1 + 15);
      switch(v20)
      {
        case 7:
          goto LABEL_57;
        case 3:
          uint64_t v24 = a1[13];
          *(_DWORD *)(v24 + 148) = 1;
          *(_DWORD *)(v24 + 244) = 1;
LABEL_57:
          BOOL v11 = null_convert;
          goto LABEL_58;
        case 2:
          uint64_t v21 = a1[13];
          *(_DWORD *)(v21 + 148) = 1;
          *(_DWORD *)(v21 + 244) = 1;
LABEL_49:
          void *v3 = rgb_ycc_start;
          BOOL v11 = rgb_ycc_convert;
LABEL_58:
          v3[1] = v11;
          return result;
      }
LABEL_50:
      uint64_t v22 = *a1;
      *(_DWORD *)(v22 + 40) = 28;
      unsigned __int8 v23 = *(uint64_t (**)(uint64_t *))v22;
      return (void *)v23(a1);
    default:
      if (v7 == *((_DWORD *)a1 + 15) && *((_DWORD *)a1 + 23) == *((_DWORD *)a1 + 14)) {
        goto LABEL_57;
      }
LABEL_37:
      uint64_t v16 = *a1;
      *(_DWORD *)(v16 + 40) = 28;
      uint64_t result = (void *)(*(uint64_t (**)(uint64_t *))v16)(a1);
      goto LABEL_57;
  }
}

uint64_t grayscale_convert(uint64_t result, unsigned char **a2, void *a3, unsigned int a4, int a5)
{
  if (a5 >= 1)
  {
    int v5 = *(_DWORD *)(result + 48);
    uint64_t v6 = *(int *)(result + 56);
    do
    {
      if (v5)
      {
        int v7 = *(unsigned char **)(*a3 + 8 * a4);
        uint64_t v8 = *a2;
        int v9 = v5;
        do
        {
          *v7++ = *v8;
          v8 += v6;
          --v9;
        }
        while (v9);
      }
      ++a2;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

void *rgb_ycc_start(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 536);
  uint64_t result = (void *)(**(uint64_t (***)(void))(a1 + 8))();
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  *(void *)(v1 + 16) = result;
  uint64_t v10 = 0x8000;
  do
  {
    *uint64_t result = v8;
    result[256] = v5;
    result[512] = v10;
    uint64_t v11 = v9 + 8421375;
    v9 += 0x8000;
    result[1792] = v7;
    v8 += 19595;
    v7 -= 5329;
    result[768] = v3;
    result[1024] = v4;
    result[1280] = v11;
    result[1536] = v6;
    ++result;
    v6 -= 27439;
    v5 += 38470;
    v10 += 7471;
    v4 -= 21710;
    v3 -= 11058;
  }
  while (v9 != 0x800000);
  return result;
}

uint64_t rgb_gray_convert(uint64_t result, unsigned __int8 **a2, void *a3, unsigned int a4, int a5)
{
  if (a5 >= 1)
  {
    uint64_t v5 = *(void *)(*(void *)(result + 536) + 16);
    uint64_t v6 = *(unsigned int *)(result + 48);
    do
    {
      if (v6)
      {
        uint64_t v7 = *(unsigned char **)(*a3 + 8 * a4);
        uint64_t v8 = *a2;
        uint64_t v9 = v6;
        do
        {
          *v7++ = (*(_DWORD *)(v5 + 8 * v8[1] + 2048)
                 + *(void *)(v5 + 8 * *v8)
                 + *(_DWORD *)(v5 + 8 * v8[2] + 4096)) >> 16;
          v8 += 3;
          --v9;
        }
        while (v9);
      }
      ++a2;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t rgb_convert(uint64_t result, unsigned char **a2, void *a3, unsigned int a4, int a5)
{
  if (a5 >= 1)
  {
    uint64_t v5 = *(unsigned int *)(result + 48);
    do
    {
      if (v5)
      {
        uint64_t v6 = *(unsigned char **)(*a3 + 8 * a4);
        uint64_t v7 = *(unsigned char **)(a3[1] + 8 * a4);
        uint64_t v8 = *(unsigned char **)(a3[2] + 8 * a4);
        uint64_t v9 = *a2;
        uint64_t v10 = v5;
        do
        {
          *v6++ = *v9;
          *v7++ = v9[1];
          *v8++ = v9[2];
          v9 += 3;
          --v10;
        }
        while (v10);
      }
      ++a2;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t rgb_rgb1_convert(uint64_t result, unsigned char **a2, void *a3, unsigned int a4, int a5)
{
  if (a5 >= 1)
  {
    uint64_t v5 = *(unsigned int *)(result + 48);
    do
    {
      if (v5)
      {
        uint64_t v6 = *(unsigned char **)(*a3 + 8 * a4);
        uint64_t v7 = *(unsigned char **)(a3[1] + 8 * a4);
        uint64_t v8 = *(unsigned char **)(a3[2] + 8 * a4);
        uint64_t v9 = *a2;
        uint64_t v10 = v5;
        do
        {
          char v11 = v9[1];
          char v12 = v9[2];
          *v6++ = (*v9 - v11) ^ 0x80;
          *v7++ = v11;
          *v8++ = (v12 - v11) ^ 0x80;
          v9 += 3;
          --v10;
        }
        while (v10);
      }
      ++a2;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t rgb_ycc_convert(uint64_t result, unsigned __int8 **a2, void *a3, unsigned int a4, int a5)
{
  if (a5 >= 1)
  {
    uint64_t v5 = *(void *)(*(void *)(result + 536) + 16);
    uint64_t v6 = *(unsigned int *)(result + 48);
    do
    {
      if (v6)
      {
        uint64_t v7 = *(unsigned char **)(*a3 + 8 * a4);
        uint64_t v8 = *(unsigned char **)(a3[1] + 8 * a4);
        uint64_t v9 = *(unsigned char **)(a3[2] + 8 * a4);
        uint64_t v10 = *a2;
        uint64_t v11 = v6;
        do
        {
          uint64_t v12 = v5 + 8 * *v10;
          uint64_t v13 = (_DWORD *)(v5 + 8 * v10[1]);
          int v14 = (_DWORD *)(v5 + 8 * v10[2]);
          *v7++ = (v13[512] + *(void *)v12 + v14[1024]) >> 16;
          int v15 = v14[2560];
          uint64_t result = (v13[2048] + *(_DWORD *)(v12 + 6144) + v15) >> 16;
          *v8++ = (v13[2048] + *(_DWORD *)(v12 + 6144) + v15) >> 16;
          *v9++ = (v13[3072] + *(_DWORD *)(v12 + 10240) + v14[3584]) >> 16;
          v10 += 3;
          --v11;
        }
        while (v11);
      }
      ++a2;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

uint64_t null_convert(uint64_t result, uint64_t *a2, uint64_t a3, unsigned int a4, int a5)
{
  if (a5 >= 1)
  {
    int v5 = *(_DWORD *)(result + 48);
    uint64_t v6 = *(unsigned int *)(result + 92);
    int v7 = *(_DWORD *)(result + 92);
    do
    {
      if (v7 >= 1)
      {
        uint64_t v8 = 0;
        do
        {
          if (v5)
          {
            uint64_t v9 = *(unsigned char **)(*(void *)(a3 + 8 * v8) + 8 * a4);
            uint64_t v10 = *a2;
            int v11 = v5;
            do
            {
              *v9++ = *(unsigned char *)(v10 + v8);
              v10 += (int)v6;
              --v11;
            }
            while (v11);
          }
          ++v8;
        }
        while (v8 != v6);
      }
      ++a2;
      ++a4;
    }
    while (a5-- > 1);
  }
  return result;
}

uint64_t cmyk_ycck_convert(uint64_t result, unsigned char **a2, void *a3, unsigned int a4, int a5)
{
  if (a5 >= 1)
  {
    uint64_t v5 = *(void *)(*(void *)(result + 536) + 16);
    uint64_t v6 = *(unsigned int *)(result + 48);
    do
    {
      if (v6)
      {
        int v7 = *(unsigned char **)(*a3 + 8 * a4);
        uint64_t v8 = *(unsigned char **)(a3[1] + 8 * a4);
        uint64_t v9 = *(unsigned char **)(a3[2] + 8 * a4);
        uint64_t v10 = *(unsigned char **)(a3[3] + 8 * a4);
        uint64_t v11 = v6;
        uint64_t v12 = *a2;
        do
        {
          unsigned __int8 v13 = ~*v12;
          int v14 = v12[1] ^ 0xFF;
          int v15 = v12[2] ^ 0xFF;
          *v10++ = v12[3];
          *v7++ = (*(void *)(v5 + 8 * (v14 | 0x100u))
                 + *(void *)(v5 + 8 * v13)
                 + *(void *)(v5 + 8 * (v15 | 0x200u))) >> 16;
          *v8++ = (*(void *)(v5 + 8 * (v14 | 0x400u))
                 + *(void *)(v5 + 8 * (v13 | 0x300u))
                 + *(void *)(v5 + 8 * (v15 | 0x500u))) >> 16;
          unsigned int v16 = v13 | 0x500;
          unsigned int v17 = v14 | 0x600;
          uint64_t result = *(void *)(v5 + 8 * v16);
          *v9++ = (*(void *)(v5 + 8 * v17)
                 + result
                 + *(void *)(v5 + 8 * (v15 | 0x700u))) >> 16;
          v12 += 4;
          --v11;
        }
        while (v11);
      }
      ++a2;
      ++a4;
    }
    while (a5-- >= 2);
  }
  return result;
}

void *_cg_jinit_c_prep_controller(uint64_t *a1, int a2)
{
  if (a2)
  {
    uint64_t v3 = *a1;
    *(_DWORD *)(v3 + 40) = 3;
    (*(void (**)(uint64_t *))v3)(a1);
  }
  uint64_t result = (void *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))a1[1])(a1, 1, 112);
  uint64_t v5 = result;
  a1[64] = (uint64_t)result;
  *uint64_t result = start_pass_prep;
  if (*(_DWORD *)(a1[68] + 16))
  {
    result[1] = pre_process_context;
    uint64_t v16 = *((int *)a1 + 89);
    uint64_t result = (void *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))a1[1])(a1, 1, 8 * *((_DWORD *)a1 + 23) * 5 * (int)v16);
    if (*((int *)a1 + 23) >= 1)
    {
      uint64_t v6 = result;
      uint64_t v7 = 0;
      uint64_t v8 = a1[13];
      uint64_t v15 = (3 * v16);
      uint64_t v14 = 40 * v16;
      uint64_t v9 = &result[4 * (int)v16];
      do
      {
        uint64_t v10 = (char *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, uint64_t))(a1[1] + 16))(a1, 1, (uint64_t)(*((int *)a1 + 90) * (unint64_t)*(unsigned int *)(v8 + 28) * *((int *)a1 + 88))/ *(int *)(v8 + 8), v15);
        uint64_t result = memcpy(&v6[v16], v10, 8 * (int)v15);
        if ((int)v16 >= 1)
        {
          uint64_t v11 = 0;
          do
          {
            v6[v11] = *(void *)&v10[16 * v16 + v11 * 8];
            v9[v11] = *(void *)&v10[v11 * 8];
            ++v11;
          }
          while (v16 != v11);
        }
        v5[v7 + 2] = &v6[v16];
        uint64_t v6 = (void *)((char *)v6 + v14);
        ++v7;
        v8 += 96;
        uint64_t v9 = (void *)((char *)v9 + v14);
      }
      while (v7 < *((int *)a1 + 23));
    }
  }
  else
  {
    result[1] = pre_process_data;
    if (*((int *)a1 + 23) >= 1)
    {
      uint64_t v12 = 0;
      unsigned __int8 v13 = (unsigned int *)(a1[13] + 28);
      do
      {
        uint64_t result = (void *)(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, void))(a1[1] + 16))(a1, 1, (uint64_t)(*((int *)a1 + 90) * (unint64_t)*v13 * *((int *)a1 + 88)) / (int)*(v13 - 5), *((unsigned int *)a1 + 89));
        v5[v12++ + 2] = result;
        v13 += 24;
      }
      while (v12 < *((int *)a1 + 23));
    }
  }
  return result;
}

void *start_pass_prep(void *result, int a2)
{
  unint64_t v2 = result;
  uint64_t v3 = (_DWORD *)result[64];
  if (a2)
  {
    uint64_t v4 = *result;
    *(_DWORD *)(v4 + 40) = 3;
    uint64_t result = (void *)(*(uint64_t (**)(void *))v4)(result);
  }
  int v5 = *((_DWORD *)v2 + 13);
  v3[25] = 0;
  v3[26] = 0;
  v3[24] = v5;
  v3[27] = 2 * *((_DWORD *)v2 + 89);
  return result;
}

char *pre_process_context(char *result, uint64_t a2, _DWORD *a3, unsigned int a4, uint64_t a5, unsigned int *a6, unsigned int a7)
{
  if (*a6 < a7)
  {
    unsigned int v7 = a7;
    unsigned int v9 = a4;
    uint64_t v11 = result;
    uint64_t v12 = (_DWORD *)*((void *)result + 64);
    int v35 = 3 * *((_DWORD *)result + 89);
    int v38 = v12 + 4;
    do
    {
      uint64_t v13 = *a3;
      if (v9 <= v13)
      {
        if (v12[24]) {
          return result;
        }
        int v20 = v12[25];
        int v21 = v12[27];
        if (v20 < v21)
        {
          int v22 = *((_DWORD *)v11 + 23);
          if (v22 >= 1)
          {
            for (uint64_t i = 0; i < v22; ++i)
            {
              int v24 = v12[25];
              int v25 = v12[27];
              if (v24 < v25)
              {
                int v26 = *(char **)&v12[2 * i + 4];
                size_t v27 = *((unsigned int *)v11 + 12);
                int v28 = v24 - 1;
                do
                  _cg_jcopy_sample_rows(v26, v28, (uint64_t)v26, v24++, 1, v27);
                while (v25 != v24);
                int v22 = *((_DWORD *)v11 + 23);
              }
            }
            int v21 = v12[27];
            unsigned int v7 = a7;
            unsigned int v9 = a4;
          }
          v12[25] = v21;
          uint64_t v29 = *a6;
LABEL_28:
          uint64_t result = (char *)(*(uint64_t (**)(char *, _DWORD *, void, uint64_t, uint64_t))(*((void *)v11 + 68)
                                                                                                 + 8))(v11, v38, v12[26], a5, v29);
          ++*a6;
          int v30 = *((_DWORD *)v11 + 89);
          int v31 = v12[25];
          int v32 = v12[26] + v30;
          if (v32 >= v35) {
            int v32 = 0;
          }
          v12[26] = v32;
          if (v31 >= v35)
          {
            int v31 = 0;
            v12[25] = 0;
          }
          v12[27] = v31 + v30;
          LODWORD(v29) = *a6;
          continue;
        }
      }
      else
      {
        if (v12[27] - v12[25] >= v9 - v13) {
          int v14 = v9 - v13;
        }
        else {
          int v14 = v12[27] - v12[25];
        }
        uint64_t result = (char *)(*(uint64_t (**)(char *, uint64_t, _DWORD *))(*((void *)v11 + 67) + 8))(v11, a2 + 8 * v13, v38);
        if (v12[24] == *((_DWORD *)v11 + 13))
        {
          int v15 = *((_DWORD *)v11 + 23);
          if (v15 >= 1)
          {
            uint64_t v16 = 0;
            int v17 = *((_DWORD *)v11 + 89);
            do
            {
              if (v17 >= 1)
              {
                int v18 = 0;
                int v19 = -1;
                do
                {
                  uint64_t result = _cg_jcopy_sample_rows(*(char **)&v12[2 * v16 + 4], 0, *(void *)&v12[2 * v16 + 4], v19, 1, *((unsigned int *)v11 + 12));
                  int v17 = *((_DWORD *)v11 + 89);
                  ++v18;
                  --v19;
                }
                while (v18 < v17);
                int v15 = *((_DWORD *)v11 + 23);
              }
              ++v16;
            }
            while (v16 < v15);
          }
        }
        *a3 += v14;
        int v20 = v12[25] + v14;
        v12[24] -= v14;
        v12[25] = v20;
        int v21 = v12[27];
        unsigned int v9 = a4;
      }
      uint64_t v29 = *a6;
      if (v20 == v21) {
        goto LABEL_28;
      }
    }
    while (v29 < v7);
  }
  return result;
}

char *pre_process_data(char *result, uint64_t a2, unsigned int *a3, unsigned int a4, uint64_t a5, unsigned int *a6, unsigned int a7)
{
  unsigned int v7 = *a3;
  if (*a3 < a4)
  {
    unsigned int v8 = a7;
    uint64_t v10 = a5;
    unsigned int v11 = a4;
    uint64_t v13 = a2;
    int v14 = result;
    uint64_t v15 = *((void *)result + 64);
    uint64_t v41 = v15 + 16;
    do
    {
      if (*a6 >= v8) {
        return result;
      }
      if (*((_DWORD *)v14 + 89) - *(_DWORD *)(v15 + 100) >= v11 - v7) {
        int v16 = v11 - v7;
      }
      else {
        int v16 = *((_DWORD *)v14 + 89) - *(_DWORD *)(v15 + 100);
      }
      uint64_t result = (char *)(*(uint64_t (**)(char *, uint64_t, uint64_t))(*((void *)v14 + 67) + 8))(v14, v13 + 8 * v7, v41);
      *a3 += v16;
      int v17 = *(_DWORD *)(v15 + 100) + v16;
      BOOL v18 = *(_DWORD *)(v15 + 96) == v16;
      *(_DWORD *)(v15 + 96) -= v16;
      *(_DWORD *)(v15 + 100) = v17;
      int v19 = *((_DWORD *)v14 + 89);
      if (v18 && v17 < v19)
      {
        int v21 = *((_DWORD *)v14 + 23);
        if (v21 >= 1)
        {
          for (uint64_t i = 0; i < v21; ++i)
          {
            int v23 = *(_DWORD *)(v15 + 100);
            int v24 = *((_DWORD *)v14 + 89);
            if (v23 < v24)
            {
              int v25 = *(char **)(v15 + 8 * i + 16);
              size_t v26 = *((unsigned int *)v14 + 12);
              int v27 = v23 - 1;
              do
                _cg_jcopy_sample_rows(v25, v27, (uint64_t)v25, v23++, 1, v26);
              while (v24 != v23);
              int v21 = *((_DWORD *)v14 + 23);
            }
          }
          int v19 = *((_DWORD *)v14 + 89);
          unsigned int v8 = a7;
          uint64_t v10 = a5;
          unsigned int v11 = a4;
          uint64_t v13 = a2;
        }
        *(_DWORD *)(v15 + 100) = v19;
      }
      else if (v17 != v19)
      {
        goto LABEL_23;
      }
      uint64_t result = (char *)(*(uint64_t (**)(char *, uint64_t, void, uint64_t, void))(*((void *)v14 + 68) + 8))(v14, v41, 0, v10, *a6);
      *(_DWORD *)(v15 + 100) = 0;
      ++*a6;
LABEL_23:
      if (!*(_DWORD *)(v15 + 96) && *a6 < v8)
      {
        int v28 = *((_DWORD *)v14 + 23);
        if (v28 >= 1)
        {
          uint64_t v29 = 0;
          int v30 = (_DWORD *)*((void *)v14 + 13);
          do
          {
            int v31 = v30[10] * v30[3] / *((_DWORD *)v14 + 91);
            int v32 = *a6 * v31;
            if (v32 < (int)(v31 * v8))
            {
              unsigned int v33 = *(char **)(v10 + 8 * v29);
              size_t v34 = (v30[9] * v30[7]);
              int v35 = v32 - 1;
              int v36 = v31 * (v8 - *a6);
              do
              {
                uint64_t result = _cg_jcopy_sample_rows(v33, v35, (uint64_t)v33, v32++, 1, v34);
                --v36;
              }
              while (v36);
              int v28 = *((_DWORD *)v14 + 23);
              unsigned int v8 = a7;
              uint64_t v10 = a5;
            }
            ++v29;
            v30 += 24;
          }
          while (v29 < v28);
        }
        *a6 = v8;
        return result;
      }
      unsigned int v7 = *a3;
    }
    while (*a3 < v11);
  }
  return result;
}

uint64_t _cg_jpeg_idct_islow(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  uint64_t v76 = *(void *)(a1 + 440);
  uint64_t v6 = (__int16 *)(a3 + 64);
  uint64_t v7 = *(void *)(a2 + 88) + 128;
  unsigned int v8 = 9;
  memset(v78, 0, sizeof(v78));
  do
  {
    unsigned int v9 = (_DWORD *)(v7 + v5);
    unsigned __int16 v10 = *(v6 - 16);
    if ((unsigned __int16)*(v6 - 24) | v10) {
      goto LABEL_9;
    }
    if (*(v6 - 8) || *v6 || v6[8] || v6[16] || v6[24])
    {
      unsigned __int16 v10 = 0;
LABEL_9:
      uint64_t v11 = *v9 * *v6;
      uint64_t v12 = ((uint64_t)(*(v9 - 32) * *(v6 - 32)) << 13) | 0x400;
      uint64_t v13 = v12 + (v11 << 13);
      uint64_t v14 = v12 - (v11 << 13);
      uint64_t v15 = (int)*(v9 - 16) * (uint64_t)(__int16)v10;
      uint64_t v16 = (int)v9[16] * (uint64_t)v6[16];
      uint64_t v17 = 4433 * (v15 + v16);
      uint64_t v18 = v17 + 6270 * v15;
      uint64_t v19 = v17 - 15137 * v16;
      uint64_t v20 = v18 + v13;
      uint64_t v21 = v13 - v18;
      uint64_t v22 = v19 + v14;
      uint64_t v23 = v14 - v19;
      uint64_t v24 = (int)v9[24] * (uint64_t)v6[24];
      uint64_t v25 = (int)v9[8] * (uint64_t)v6[8];
      int v26 = *(v9 - 8);
      uint64_t v27 = (int)*(v9 - 24) * (uint64_t)*(v6 - 24);
      uint64_t v28 = v24 + v26 * (uint64_t)*(v6 - 8);
      uint64_t v29 = 9633 * (v25 + v27 + v28);
      uint64_t v30 = v29 - 16069 * v28;
      uint64_t v31 = v29 - 3196 * (v25 + v27);
      uint64_t v32 = -7373 * (v24 + v27);
      uint64_t v33 = v32 + 2446 * v24 + v30;
      uint64_t v34 = v32 + 12299 * v27 + v31;
      uint64_t v35 = -20995 * (v25 + v26 * (uint64_t)*(v6 - 8));
      uint64_t v36 = v35 + 16819 * v25 + v31;
      uint64_t v37 = v35 + 25172 * v26 * (uint64_t)*(v6 - 8) + v30;
      int v38 = (_DWORD *)((char *)v78 + v5);
      *int v38 = (unint64_t)(v34 + v20) >> 11;
      v38[56] = (unint64_t)(v20 - v34) >> 11;
      v38[8] = (unint64_t)(v37 + v22) >> 11;
      v38[48] = (unint64_t)(v22 - v37) >> 11;
      v38[16] = (unint64_t)(v36 + v23) >> 11;
      v38[40] = (unint64_t)(v23 - v36) >> 11;
      v38[24] = (unint64_t)(v33 + v21) >> 11;
      unint64_t v39 = (unint64_t)(v21 - v33) >> 11;
      uint64_t v40 = 8;
      goto LABEL_10;
    }
    LODWORD(v39) = 4 * *(v6 - 32) * *(v9 - 32);
    uint64_t v41 = (_DWORD *)((char *)v78 + v5);
    *uint64_t v41 = v39;
    v41[8] = v39;
    v41[16] = v39;
    v41[24] = v39;
    v41[32] = v39;
    v41[40] = v39;
    v41[48] = v39;
    uint64_t v40 = 14;
LABEL_10:
    *(_DWORD *)((char *)&v78[v40] + v5) = v39;
    --v8;
    v5 += 4;
    ++v6;
  }
  while (v8 > 1);
  uint64_t v42 = v76 - 384;
  uint64_t v43 = 28;
  uint64_t result = 4294959923;
  do
  {
    unsigned int v45 = (int *)((char *)v78 + v43);
    int v46 = (unsigned char *)(*a4 + a5);
    int v47 = *(_DWORD *)((char *)&v78[-1] + v43 - 8);
    unint64_t v48 = *(int *)((char *)&v78[-1] + v43 - 12) + 16400;
    uint64_t v49 = *(unsigned int *)((char *)&v78[-1] + v43 - 4);
    if (v47) {
      BOOL v50 = 0;
    }
    else {
      BOOL v50 = v49 == 0;
    }
    if (!v50) {
      goto LABEL_24;
    }
    if (*(v45 - 4)
      || *(_DWORD *)((char *)v78 + v43 - 12)
      || *(_DWORD *)((char *)v78 + v43 - 8)
      || *(_DWORD *)((char *)v78 + v43 - 4)
      || *(_DWORD *)((char *)v78 + v43))
    {
      LODWORD(v49) = 0;
LABEL_24:
      int v52 = *(v45 - 4);
      int v51 = *(v45 - 3);
      int v53 = v48 + v51;
      int v54 = (v48 + v51) << 13;
      int v55 = (v48 - v51) << 13;
      int v57 = *(v45 - 2);
      int v56 = *(v45 - 1);
      int v58 = 4433 * (v56 + v49);
      int v59 = v58 + 6270 * v49;
      int v60 = v58 - 15137 * v56;
      int v61 = v59 + (v53 << 13);
      int v62 = v54 - v59;
      int v63 = v60 + v55;
      int v64 = v55 - v60;
      int v65 = *v45;
      int v66 = 9633 * (v52 + v65 + v57 + v47);
      int v67 = v66 - 16069 * (v52 + v65);
      int v68 = v66 - 3196 * (v57 + v47);
      int v69 = -7373 * (v65 + v47);
      int v70 = v69 + 12299 * v47 + v68;
      unsigned char *v46 = *(unsigned char *)(v42 + (((unint64_t)(v70 + v61) >> 18) & 0x3FF));
      unint64_t v71 = (v61 - v70);
      int v72 = -20995 * (v52 + v57);
      int v73 = v72 + 25172 * v52 + v67;
      v46[7] = *(unsigned char *)(v42 + ((v71 >> 18) & 0x3FF));
      v46[1] = *(unsigned char *)(v42 + (((unint64_t)(v73 + v63) >> 18) & 0x3FF));
      unsigned int v74 = v72 + 16819 * v57 + v68;
      v46[6] = *(unsigned char *)(v42 + (((unint64_t)(v63 - v73) >> 18) & 0x3FF));
      v46[2] = *(unsigned char *)(v42 + (((unint64_t)(v74 + v64) >> 18) & 0x3FF));
      LODWORD(v71) = v69 + 2446 * v65 + v67;
      v46[5] = *(unsigned char *)(v42 + (((unint64_t)(v64 - v74) >> 18) & 0x3FF));
      v46[3] = *(unsigned char *)(v42 + (((unint64_t)(v71 + v62) >> 18) & 0x3FF));
      LOBYTE(v74) = *(unsigned char *)(v42 + (((unint64_t)(v62 - v71) >> 18) & 0x3FF));
      uint64_t v75 = 4;
      goto LABEL_25;
    }
    unsigned int v74 = *(unsigned __int8 *)(v42 + ((v48 >> 5) & 0x3FF));
    *(_DWORD *)int v46 = vdup_n_s8(v74).u32[0];
    v46[4] = v74;
    v46[5] = v74;
    v46[6] = v74;
    uint64_t v75 = 7;
LABEL_25:
    v46[v75] = v74;
    ++a4;
    v43 += 32;
  }
  while (v43 != 284);
  return result;
}

uint64_t jpeg_idct_7x7(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  uint64_t v61 = *(void *)(a1 + 440);
  int v64 = 0;
  memset(v63, 0, sizeof(v63));
  uint64_t v6 = *(void *)(a2 + 88);
  do
  {
    uint64_t v7 = (_DWORD *)v63 + v5;
    unsigned int v8 = (_DWORD *)(v6 + 4 * v5);
    unsigned int v9 = (__int16 *)(a3 + 2 * v5);
    uint64_t v10 = ((uint64_t)(*v8 * *v9) << 13) | 0x400;
    uint64_t v11 = (int)v8[16] * (uint64_t)v9[16];
    uint64_t v12 = (int)v8[32] * (uint64_t)v9[32];
    uint64_t v13 = (int)v8[48] * (uint64_t)v9[48];
    uint64_t v14 = 7223 * (v12 - v13);
    uint64_t v15 = 2578 * (v11 - v12);
    uint64_t v16 = v10 - 15083 * v12 + v15 + v14;
    uint64_t v17 = v10 + 10438 * (v11 + v13);
    uint64_t v18 = v14 - 637 * v13 + v17;
    uint64_t v19 = v15 - 20239 * v11 + v17;
    unint64_t v20 = v10 + 11585 * (v12 - (v11 + v13));
    uint64_t v21 = (int)v8[8] * (uint64_t)v9[8];
    uint64_t v22 = (int)v8[24] * (uint64_t)v9[24];
    uint64_t v23 = (int)v8[40] * (uint64_t)v9[40];
    uint64_t v24 = 7663 * (v21 + v22);
    uint64_t v25 = 1395 * (v21 - v22);
    uint64_t v26 = v24 - v25;
    uint64_t v27 = v24 + v25 - 11295 * (v22 + v23);
    uint64_t v28 = 5027 * (v21 + v23);
    uint64_t v29 = v28 + v26;
    uint64_t v30 = v28 + 15326 * v23 - 11295 * (v22 + v23);
    _DWORD *v7 = (unint64_t)(v29 + v18) >> 11;
    v7[42] = (unint64_t)(v18 - v29) >> 11;
    v7[7] = (unint64_t)(v27 + v16) >> 11;
    v7[35] = (unint64_t)(v16 - v27) >> 11;
    v7[14] = (unint64_t)(v30 + v19) >> 11;
    v7[28] = (unint64_t)(v19 - v30) >> 11;
    v7[21] = v20 >> 11;
    ++v5;
  }
  while (v5 != 7);
  uint64_t v31 = 0;
  uint64_t v32 = v61 - 384;
  uint64_t result = 11585;
  do
  {
    uint64_t v34 = *a4++;
    int v35 = *(_DWORD *)((char *)v63 + v31 + 4);
    int v36 = (*(_DWORD *)((char *)v63 + v31) << 13) + 134348800;
    int v38 = *(_DWORD *)((char *)&v63[1] + v31 + 4);
    int v37 = *(_DWORD *)((char *)&v63[1] + v31 + 8);
    int v39 = *(_DWORD *)((char *)&v63[1] + v31);
    int v40 = 7223 * (v39 - v37);
    int v42 = *(_DWORD *)((char *)v63 + v31 + 8);
    int v41 = *(_DWORD *)((char *)v63 + v31 + 12);
    int v43 = 2578 * (v42 - v39);
    int v44 = v43 + v40;
    int v45 = v37 + v42;
    int v46 = v40 - 637 * v37;
    int v47 = 7663 * (v41 + v35);
    int v48 = v43 - 20239 * v42;
    int v49 = 1395 * (v35 - v41);
    int v50 = v47 - v49;
    int v51 = v47 + v49;
    int v52 = v36 + 10438 * v45;
    int v53 = v46 + v52;
    int v54 = 5027 * (v38 + v35);
    int v55 = v50 + v54;
    int v56 = v36 - 15083 * v39 + v44;
    int v57 = (unsigned char *)(v34 + a5);
    *int v57 = *(unsigned char *)(v32 + (((unint64_t)(v55 + v53) >> 18) & 0x3FF));
    int v58 = -11295 * (v38 + v41);
    int v59 = v51 + v58;
    v57[6] = *(unsigned char *)(v32 + (((unint64_t)(v53 - v55) >> 18) & 0x3FF));
    int v60 = v54 + 15326 * v38 + v58;
    v57[1] = *(unsigned char *)(v32 + (((unint64_t)(v59 + v56) >> 18) & 0x3FF));
    v57[5] = *(unsigned char *)(v32 + (((unint64_t)(v56 - v59) >> 18) & 0x3FF));
    v57[2] = *(unsigned char *)(v32 + (((unint64_t)(v60 + v48 + v52) >> 18) & 0x3FF));
    v57[4] = *(unsigned char *)(v32 + (((unint64_t)(v48 + v52 - v60) >> 18) & 0x3FF));
    v57[3] = *(unsigned char *)(v32 + (((unint64_t)(v36 + 11585 * (v39 - v45)) >> 18) & 0x3FF));
    v31 += 28;
  }
  while (v31 != 196);
  return result;
}

uint64_t jpeg_idct_6x6(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 440);
  memset(v43, 0, sizeof(v43));
  uint64_t v7 = *(void *)(a2 + 88);
  do
  {
    unsigned int v8 = (_DWORD *)v43 + v5;
    unsigned int v9 = (_DWORD *)(v7 + 4 * v5);
    uint64_t v10 = (__int16 *)(a3 + 2 * v5);
    uint64_t v11 = ((uint64_t)(*v9 * *v10) << 13) | 0x400;
    uint64_t v12 = (int)v9[32] * (uint64_t)v10[32];
    uint64_t v13 = v11 + 5793 * v12;
    unint64_t v14 = (unint64_t)(v11 - 11586 * v12) >> 11;
    uint64_t v15 = 10033 * (int)v9[16] * (uint64_t)v10[16];
    uint64_t v16 = v15 + v13;
    uint64_t v17 = v13 - v15;
    uint64_t v18 = (int)v9[8] * (uint64_t)v10[8];
    uint64_t v19 = (int)v9[24] * (uint64_t)v10[24];
    uint64_t v20 = (int)v9[40] * (uint64_t)v10[40];
    uint64_t v21 = 2998 * (v18 + v20);
    uint64_t v22 = v21 + ((v18 + v19) << 13);
    uint64_t v23 = v21 + ((v20 - v19) << 13);
    LODWORD(v18) = v18 - (v19 + v20);
    *unsigned int v8 = (unint64_t)(v22 + v16) >> 11;
    v8[30] = (unint64_t)(v16 - v22) >> 11;
    v8[6] = v14 + 4 * v18;
    v8[24] = v14 - 4 * v18;
    v8[12] = (unint64_t)(v23 + v17) >> 11;
    v8[18] = (unint64_t)(v17 - v23) >> 11;
    ++v5;
  }
  while (v5 != 6);
  uint64_t v24 = 0;
  uint64_t v25 = v6 - 384;
  uint64_t v26 = a5;
  do
  {
    uint64_t v27 = *a4++;
    uint64_t v28 = (unsigned char *)(v27 + v26);
    int v29 = *(_DWORD *)((char *)v43 + v24 + 4);
    int v30 = *(_DWORD *)((char *)&v43[1] + v24);
    int v31 = *(_DWORD *)((char *)&v43[1] + v24 + 4);
    int v32 = (*(_DWORD *)((char *)v43 + v24) << 13) + 134348800;
    int v33 = v32 + 5793 * v30;
    int v34 = *(_DWORD *)((char *)v43 + v24 + 12);
    int v35 = 10033 * *(_DWORD *)((char *)v43 + v24 + 8);
    int v36 = 2998 * (v31 + v29);
    int v37 = v36 + ((v34 + v29) << 13);
    int v38 = v31 - v34;
    int v39 = v29 - (v34 + v31);
    int v40 = v32 - 11586 * v30;
    unsigned char *v28 = *(unsigned char *)(v25 + (((unint64_t)(v37 + v33 + v35) >> 18) & 0x3FF));
    int v41 = v36 + (v38 << 13);
    v28[5] = *(unsigned char *)(v25 + (((unint64_t)(v33 + v35 - v37) >> 18) & 0x3FF));
    v28[1] = *(unsigned char *)(v25 + (((unint64_t)(v40 + (v39 << 13)) >> 18) & 0x3FF));
    v28[4] = *(unsigned char *)(v25 + (((unint64_t)(v40 - (v39 << 13)) >> 18) & 0x3FF));
    v28[2] = *(unsigned char *)(v25 + (((unint64_t)(v41 + v33 - v35) >> 18) & 0x3FF));
    uint64_t result = *(unsigned __int8 *)(v25 + (((unint64_t)(v33 - v35 - v41) >> 18) & 0x3FF));
    v28[3] = result;
    v24 += 24;
  }
  while (v24 != 144);
  return result;
}

uint64_t jpeg_idct_5x5(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 440);
  int v44 = 0;
  memset(v43, 0, sizeof(v43));
  uint64_t v7 = *(void *)(a2 + 88);
  do
  {
    unsigned int v8 = (_DWORD *)v43 + v5;
    unsigned int v9 = (_DWORD *)(v7 + 4 * v5);
    uint64_t v10 = (__int16 *)(a3 + 2 * v5);
    uint64_t v11 = ((uint64_t)(*v9 * *v10) << 13) | 0x400;
    uint64_t v12 = (int)v9[16] * (uint64_t)v10[16];
    int v13 = v9[32];
    uint64_t v14 = 6476 * (v12 + v13 * (uint64_t)v10[32]);
    uint64_t v15 = v12 - v13 * (uint64_t)v10[32];
    uint64_t v16 = v11 + 2896 * v15;
    uint64_t v17 = v16 + v14;
    uint64_t v18 = v16 - v14;
    unint64_t v19 = v11 + 0x7FFFFFFD2C0 * v15;
    uint64_t v20 = (int)v9[8] * (uint64_t)v10[8];
    uint64_t v21 = (int)v9[24] * (uint64_t)v10[24];
    uint64_t v22 = 6810 * (v20 + v21);
    uint64_t v23 = v22 + 4209 * v20;
    uint64_t v24 = v22 - 17828 * v21;
    *unsigned int v8 = (unint64_t)(v23 + v17) >> 11;
    v8[20] = (unint64_t)(v17 - v23) >> 11;
    v8[5] = (unint64_t)(v24 + v18) >> 11;
    v8[15] = (unint64_t)(v18 - v24) >> 11;
    v8[10] = v19 >> 11;
    ++v5;
  }
  while (v5 != 5);
  uint64_t v25 = 0;
  uint64_t v26 = v6 - 384;
  uint64_t result = a5;
  do
  {
    uint64_t v28 = *a4++;
    int v29 = *(_DWORD *)((char *)v43 + v25 + 4);
    int v30 = (unsigned char *)(v28 + result);
    int v31 = (*(_DWORD *)((char *)v43 + v25) << 13) + 134348800;
    int v32 = *(_DWORD *)((char *)v43 + v25 + 8);
    int v33 = *(_DWORD *)((char *)v43 + v25 + 12);
    int v34 = *(_DWORD *)((char *)&v43[1] + v25);
    int v35 = 6476 * (v34 + v32);
    int v36 = v32 - v34;
    int v37 = v31 + 2896 * v36;
    int v38 = 6810 * (v33 + v29);
    int v39 = v37 + v35;
    int v40 = v38 + 4209 * v29;
    int v41 = v38 - 17828 * v33;
    *int v30 = *(unsigned char *)(v26 + (((unint64_t)(v40 + v37 + v35) >> 18) & 0x3FF));
    int v42 = v37 - v35;
    v30[4] = *(unsigned char *)(v26 + (((unint64_t)(v39 - v40) >> 18) & 0x3FF));
    v30[1] = *(unsigned char *)(v26 + (((unint64_t)(v41 + v42) >> 18) & 0x3FF));
    v30[3] = *(unsigned char *)(v26 + (((unint64_t)(v42 - v41) >> 18) & 0x3FF));
    v30[2] = *(unsigned char *)(v26 + (((unint64_t)(v31 + 268423872 * v36) >> 18) & 0x3FF));
    v25 += 20;
  }
  while (v25 != 100);
  return result;
}

uint64_t _cg_jpeg_idct_4x4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 440);
  memset(v38, 0, sizeof(v38));
  uint64_t v7 = *(void *)(a2 + 88);
  do
  {
    unsigned int v8 = (_DWORD *)v38 + v5;
    unsigned int v9 = (_DWORD *)(v7 + 4 * v5);
    uint64_t v10 = (__int16 *)(a3 + 2 * v5);
    int v11 = *v9 * *v10;
    int v12 = v9[16] * v10[16];
    int v13 = v12 + v11;
    int v14 = 4 * (v12 + v11);
    int v15 = v11 - v12;
    uint64_t v16 = (int)v9[8] * (uint64_t)v10[8];
    uint64_t v17 = (int)v9[24] * (uint64_t)v10[24];
    uint64_t v18 = 4433 * (v16 + v17) + 1024;
    unint64_t v19 = (unint64_t)(v18 + 6270 * v16) >> 11;
    unint64_t v20 = (unint64_t)(v18 - 15137 * v17) >> 11;
    *unsigned int v8 = v19 + 4 * v13;
    v8[12] = v14 - v19;
    _OWORD v8[4] = v20 + 4 * v15;
    v8[8] = 4 * v15 - v20;
    ++v5;
  }
  while (v5 != 4);
  uint64_t v21 = 0;
  uint64_t v22 = v6 - 384;
  uint64_t v23 = a5;
  do
  {
    uint64_t v24 = *a4++;
    uint64_t v25 = (unsigned char *)(v24 + v23);
    int v26 = DWORD1(v38[v21]);
    int v27 = DWORD2(v38[v21]);
    int v28 = HIDWORD(v38[v21]);
    int v29 = LODWORD(v38[v21]) + 16400;
    int v30 = v29 + v27;
    int v31 = (v29 + v27) << 13;
    int v32 = v29 - v27;
    int v33 = 4433 * (v28 + v26);
    int v34 = v32 << 13;
    int v35 = v33 + 6270 * v26;
    int v36 = v33 - 15137 * v28;
    *uint64_t v25 = *(unsigned char *)(v22 + (((unint64_t)(v35 + (v30 << 13)) >> 18) & 0x3FF));
    v25[3] = *(unsigned char *)(v22 + (((unint64_t)(v31 - v35) >> 18) & 0x3FF));
    uint64_t result = *(unsigned __int8 *)(v22 + (((unint64_t)(v36 + (v32 << 13)) >> 18) & 0x3FF));
    v25[1] = result;
    int v25[2] = *(unsigned char *)(v22 + (((unint64_t)(v34 - v36) >> 18) & 0x3FF));
    ++v21;
  }
  while (v21 != 4);
  return result;
}

uint64_t jpeg_idct_3x3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 440);
  int v26 = 0;
  memset(v25, 0, sizeof(v25));
  uint64_t v7 = *(void *)(a2 + 88);
  do
  {
    unsigned int v8 = (_DWORD *)v25 + v5;
    unsigned int v9 = (_DWORD *)(v7 + 4 * v5);
    uint64_t v10 = (__int16 *)(a3 + 2 * v5);
    uint64_t v11 = ((uint64_t)(*v9 * *v10) << 13) | 0x400;
    uint64_t v12 = (int)v9[16] * (uint64_t)v10[16];
    uint64_t v13 = v11 + 5793 * v12;
    uint64_t v14 = 10033 * (int)v9[8] * (uint64_t)v10[8];
    *unsigned int v8 = (unint64_t)(v14 + v13) >> 11;
    v8[6] = (unint64_t)(v13 - v14) >> 11;
    _OWORD v8[3] = (unint64_t)(v11 + 0x7FFFFFFD2BELL * v12) >> 11;
    ++v5;
  }
  while (v5 != 3);
  uint64_t v15 = 0;
  uint64_t v16 = v6 - 384;
  do
  {
    uint64_t v17 = *a4++;
    uint64_t v18 = (unsigned char *)(v17 + a5);
    int v19 = (*(_DWORD *)((char *)v25 + v15) << 13) + 134348800;
    int v20 = *(_DWORD *)((char *)v25 + v15 + 8);
    int v21 = v19 + 5793 * v20;
    unint64_t v22 = (v19 + 268423870 * v20);
    int v23 = 10033 * *(_DWORD *)((char *)v25 + v15 + 4);
    *uint64_t v18 = *(unsigned char *)(v16 + (((unint64_t)(v21 + v23) >> 18) & 0x3FF));
    uint64_t result = *(unsigned __int8 *)(v16 + (((unint64_t)(v21 - v23) >> 18) & 0x3FF));
    _OWORD v18[2] = result;
    v18[1] = *(unsigned char *)(v16 + ((v22 >> 18) & 0x3FF));
    v15 += 12;
  }
  while (v15 != 36);
  return result;
}

uint64_t _cg_jpeg_idct_2x2(uint64_t result, uint64_t a2, unsigned __int16 *a3, void *a4, unsigned int a5)
{
  uint64_t v5 = *(void *)(result + 440) - 384;
  uint64_t v6 = *(_DWORD **)(a2 + 88);
  int v7 = *v6 * *a3 + 4100;
  int v8 = v6[8] * a3[8];
  int v9 = v8 + v7;
  int v10 = v7 - v8;
  int v11 = v6[1] * a3[1];
  LODWORD(v6) = v6[9] * a3[9];
  int v12 = v6 + v11;
  LODWORD(v6) = v11 - v6;
  uint64_t v13 = (unsigned char *)(*a4 + a5);
  unsigned char *v13 = *(unsigned char *)(v5 + (((unint64_t)(v12 + v9) >> 3) & 0x3FF));
  v13[1] = *(unsigned char *)(v5 + (((unint64_t)(v9 - v12) >> 3) & 0x3FF));
  uint64_t v14 = (unsigned char *)(a4[1] + a5);
  unsigned char *v14 = *(unsigned char *)(v5 + (((unint64_t)(v6 + v10) >> 3) & 0x3FF));
  v14[1] = *(unsigned char *)(v5 + (((unint64_t)(v10 - v6) >> 3) & 0x3FF));
  return result;
}

uint64_t _cg_jpeg_idct_1x1(uint64_t result, uint64_t a2, unsigned __int16 *a3, void *a4, unsigned int a5)
{
  *(unsigned char *)(*a4 + a5) = *(unsigned char *)(*(void *)(result + 440)
                                  + (((unint64_t)(**(_DWORD **)(a2 + 88) * *a3 + 4100) >> 3) & 0x3FF)
                                  - 384);
  return result;
}

uint64_t jpeg_idct_9x9(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 440);
  memset(v72, 0, sizeof(v72));
  uint64_t v7 = *(void *)(a2 + 88);
  do
  {
    int v8 = (_DWORD *)(v7 + 4 * v5);
    int v9 = (__int16 *)(a3 + 2 * v5);
    uint64_t v10 = (int)v8[16] * (uint64_t)v9[16];
    uint64_t v11 = ((uint64_t)(*v8 * *v9) << 13) | 0x400;
    int v12 = v8[32];
    uint64_t v13 = (int)v8[48] * (uint64_t)v9[48];
    uint64_t v14 = v11 + 5793 * v13;
    uint64_t v15 = v11 - 11586 * v13;
    uint64_t v16 = (int)v8[8] * (uint64_t)v9[8];
    uint64_t v17 = (int)v8[40] * (uint64_t)v9[40];
    uint64_t v18 = v16 + v17;
    uint64_t v19 = v16 - v17;
    int v20 = v8[56];
    uint64_t v21 = v16 + v20 * (uint64_t)v9[56];
    uint64_t v22 = v17 - v20 * (uint64_t)v9[56];
    uint64_t v23 = v19 - v20 * (uint64_t)v9[56];
    uint64_t v24 = v10 - v12 * (uint64_t)v9[32];
    uint64_t v25 = v15 + 5793 * v24;
    unint64_t v26 = v15 + 0x7FFFFFFD2BELL * v24;
    uint64_t v27 = v12 * (uint64_t)v9[32];
    uint64_t v28 = 10887 * (v10 + v27);
    v10 *= 8875;
    uint64_t v29 = 2012 * v27;
    uint64_t v30 = v28 - 2012 * v27 + v14;
    uint64_t v31 = v14 - v28 + v10;
    uint64_t v32 = v14 - v10 + v29;
    uint64_t v33 = -10033 * (int)v8[24] * (uint64_t)v9[24];
    v22 *= 11409;
    v18 *= 7447;
    uint64_t v34 = v33 - v22 + v18;
    uint64_t v35 = v18 - v33;
    uint64_t v36 = v22 + v33;
    int v37 = (_DWORD *)v72 + v5;
    uint64_t v38 = v35 + 3962 * v21;
    uint64_t v39 = v36 + 3962 * v21;
    *int v37 = (unint64_t)(v38 + v30) >> 11;
    v23 *= 10033;
    v37[64] = (unint64_t)(v30 - v38) >> 11;
    v37[8] = (unint64_t)(v23 + v25) >> 11;
    v37[56] = (unint64_t)(v25 - v23) >> 11;
    v37[16] = (unint64_t)(v34 + v31) >> 11;
    v37[48] = (unint64_t)(v31 - v34) >> 11;
    v37[24] = (unint64_t)(v39 + v32) >> 11;
    v37[40] = (unint64_t)(v32 - v39) >> 11;
    v37[32] = v26 >> 11;
    ++v5;
  }
  while (v5 != 8);
  uint64_t v40 = 0;
  uint64_t v41 = v6 - 384;
  uint64_t result = 4294957263;
  do
  {
    int v43 = &v72[v40];
    int v44 = v43[1];
    int v45 = v43[6];
    int v46 = v43[7];
    int v47 = (*v43 << 13) + 134348800;
    int v48 = v47 + 5793 * v45;
    int v49 = v43[2];
    int v50 = v43[3];
    int v51 = v43[4];
    LODWORD(v43) = v43[5];
    int v52 = v47 - 11586 * v45;
    int v53 = v49 - v51;
    int v54 = v52 + 5793 * (v49 - v51);
    int v55 = 10887 * (v51 + v49);
    v49 *= 8875;
    unint64_t v56 = (v52 + 268423870 * v53);
    int v57 = 2012 * v51;
    int v58 = v55 - 2012 * v51 + v48;
    int v59 = v48 - v55;
    int v60 = v48 - v49;
    int v61 = v59 + v49;
    v50 *= -10033;
    int v62 = 7447 * (v43 + v44);
    int v63 = 3962 * (v46 + v44);
    int v64 = v60 + v57;
    int v65 = v62 - v50 + v63;
    int v66 = v43 - v46;
    LODWORD(v43) = v44 - (v43 + v46);
    int v67 = (unsigned char *)(*(void *)(a4 + v40 * 4) + a5);
    *int v67 = *(unsigned char *)(v41 + (((unint64_t)(v65 + v58) >> 18) & 0x3FF));
    LODWORD(v43) = 10033 * v43;
    v67[8] = *(unsigned char *)(v41 + (((unint64_t)(v58 - v65) >> 18) & 0x3FF));
    v67[1] = *(unsigned char *)(v41 + (((unint64_t)(v43 + v54) >> 18) & 0x3FF));
    v66 *= 11409;
    int v68 = v50 - v66 + v62;
    v67[7] = *(unsigned char *)(v41 + (((unint64_t)(v54 - v43) >> 18) & 0x3FF));
    v67[2] = *(unsigned char *)(v41 + (((unint64_t)(v68 + v61) >> 18) & 0x3FF));
    int v69 = v66 + v50 + v63;
    v67[6] = *(unsigned char *)(v41 + (((unint64_t)(v61 - v68) >> 18) & 0x3FF));
    v67[3] = *(unsigned char *)(v41 + (((unint64_t)(v69 + v64) >> 18) & 0x3FF));
    v67[5] = *(unsigned char *)(v41 + (((unint64_t)(v64 - v69) >> 18) & 0x3FF));
    v67[4] = *(unsigned char *)(v41 + ((v56 >> 18) & 0x3FF));
    v40 += 2;
  }
  while (v40 != 18);
  return result;
}

uint64_t jpeg_idct_10x10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  uint64_t v72 = *(void *)(a1 + 440);
  memset(v74, 0, sizeof(v74));
  uint64_t v6 = *(void *)(a2 + 88);
  do
  {
    uint64_t v7 = (_DWORD *)(v6 + 4 * v5);
    int v8 = (__int16 *)(a3 + 2 * v5);
    uint64_t v9 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    uint64_t v10 = (int)v7[32] * (uint64_t)v8[32];
    uint64_t v11 = v9 + 9373 * v10;
    uint64_t v12 = v9 - 3580 * v10;
    unint64_t v13 = v9 - 11586 * v10;
    uint64_t v14 = (int)v7[16] * (uint64_t)v8[16];
    uint64_t v15 = (int)v7[48] * (uint64_t)v8[48];
    uint64_t v16 = 6810 * (v14 + v15);
    uint64_t v17 = v16 + 4209 * v14;
    uint64_t v18 = v16 - 17828 * v15;
    uint64_t v19 = v17 + v11;
    uint64_t v20 = v11 - v17;
    uint64_t v21 = v18 + v12;
    uint64_t v22 = v12 - v18;
    uint64_t v23 = (int)v7[8] * (uint64_t)v8[8];
    uint64_t v24 = (int)v7[24] * (uint64_t)v8[24];
    uint64_t v25 = (int)v7[40] * (uint64_t)v8[40];
    LODWORD(v8) = v8[56];
    LODWORD(v7) = v7[56];
    uint64_t v26 = v24 + (int)v7 * (uint64_t)(int)v8;
    uint64_t v27 = v24 - (int)v7 * (uint64_t)(int)v8;
    uint64_t v28 = 2531 * v27 + (v25 << 13);
    uint64_t v29 = 7791 * v26 + 11443 * v23 + v28;
    uint64_t v30 = 1812 * v23 - 7791 * v26 + v28;
    uint64_t v31 = 4815 * v26;
    uint64_t v32 = -6627 * v27 + (v25 << 13);
    LODWORD(v27) = v23 - v25 - v27;
    uint64_t v33 = 10323 * v23 - (v31 + v32);
    uint64_t v34 = 5260 * v23 - v31;
    uint64_t v35 = (_DWORD *)v74 + v5;
    uint64_t v36 = v34 + v32;
    *uint64_t v35 = (unint64_t)(v29 + v19) >> 11;
    v35[72] = (unint64_t)(v19 - v29) >> 11;
    v35[8] = (unint64_t)(v33 + v21) >> 11;
    v35[64] = (unint64_t)(v21 - v33) >> 11;
    v35[16] = (v13 >> 11) + 4 * v27;
    v35[56] = (v13 >> 11) - 4 * v27;
    v35[24] = (unint64_t)(v36 + v22) >> 11;
    v35[48] = (unint64_t)(v22 - v36) >> 11;
    v35[32] = (unint64_t)(v30 + v20) >> 11;
    v35[40] = (unint64_t)(v20 - v30) >> 11;
    ++v5;
  }
  while (v5 != 8);
  uint64_t v37 = 0;
  uint64_t v38 = v72 - 384;
  uint64_t result = 2531;
  do
  {
    uint64_t v40 = &v74[v37];
    uint64_t v41 = *(void *)(a4 + v37 * 4);
    int v42 = v40[1];
    int v43 = v40[4];
    int v44 = v40[5];
    int v45 = (*v40 << 13) + 134348800;
    int v46 = v45 + 9373 * v43;
    int v47 = v45 - 3580 * v43;
    int v49 = v40[2];
    int v48 = v40[3];
    int v50 = v45 - 11586 * v43;
    uint64_t v51 = a4;
    int v53 = v40[6];
    int v52 = v40[7];
    LODWORD(v40) = 6810 * (v53 + v49);
    int v54 = v40 + 4209 * v49;
    int v55 = v40 - 17828 * v53;
    int v56 = v54 + v46;
    LODWORD(v40) = v46 - v54;
    int v57 = v55 + v47;
    int v58 = v52 + v48;
    int v59 = v48 - v52;
    int v60 = v47 - v55;
    int v61 = 2531 * v59 + (v44 << 13);
    int v62 = 7791 * v58 + 11443 * v42 + v61;
    int v63 = (unsigned char *)(v41 + a5);
    int v64 = 1812 * v42 - 7791 * v58 + v61;
    int v65 = 4815 * v58;
    unint64_t v66 = (v62 + v56);
    unint64_t v67 = (v56 - v62);
    int v68 = -6627 * v59 + (v44 << 13);
    unsigned char *v63 = *(unsigned char *)(v38 + ((v66 >> 18) & 0x3FF));
    LODWORD(v66) = 10323 * v42 - (v65 + v68);
    v63[9] = *(unsigned char *)(v38 + ((v67 >> 18) & 0x3FF));
    int v69 = v42 - v44 - v59;
    v63[1] = *(unsigned char *)(v38 + (((unint64_t)(v66 + v57) >> 18) & 0x3FF));
    v63[8] = *(unsigned char *)(v38 + (((unint64_t)(v57 - v66) >> 18) & 0x3FF));
    int v70 = 5260 * v42 - v65;
    v63[2] = *(unsigned char *)(v38 + (((unint64_t)(v50 + (v69 << 13)) >> 18) & 0x3FF));
    v63[7] = *(unsigned char *)(v38 + (((unint64_t)(v50 - (v69 << 13)) >> 18) & 0x3FF));
    v63[3] = *(unsigned char *)(v38 + (((unint64_t)(v70 + v68 + v60) >> 18) & 0x3FF));
    unint64_t v71 = (v60 - (v70 + v68));
    a4 = v51;
    v63[6] = *(unsigned char *)(v38 + ((v71 >> 18) & 0x3FF));
    v63[4] = *(unsigned char *)(v38 + (((unint64_t)(v64 + v40) >> 18) & 0x3FF));
    v63[5] = *(unsigned char *)(v38 + (((unint64_t)(v40 - v64) >> 18) & 0x3FF));
    v37 += 2;
  }
  while (v37 != 20);
  return result;
}

uint64_t jpeg_idct_11x11(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  uint64_t v79 = *(void *)(a1 + 440);
  memset(v82, 0, sizeof(v82));
  uint64_t v6 = *(void *)(a2 + 88);
  do
  {
    uint64_t v7 = (_DWORD *)(v6 + 4 * v5);
    int v8 = (__int16 *)(a3 + 2 * v5);
    int v9 = *v7 * *v8;
    uint64_t v10 = (int)v7[16] * (uint64_t)v8[16];
    uint64_t v11 = (int)v7[32] * (uint64_t)v8[32];
    uint64_t v12 = (int)v7[48] * (uint64_t)v8[48];
    uint64_t v13 = (int)v7[8] * (uint64_t)v8[8];
    uint64_t v14 = (int)v7[24] * (uint64_t)v8[24];
    uint64_t v15 = (int)v7[40] * (uint64_t)v8[40];
    uint64_t v16 = (int)v7[56] * (uint64_t)v8[56];
    uint64_t v17 = v10 + v12 - v11;
    uint64_t v18 = v13 + v16;
    uint64_t v19 = 3264 * (v13 + v14 + v15 + v16);
    uint64_t v20 = 7274 * (v13 + v14);
    uint64_t v21 = 5492 * (v13 + v15);
    uint64_t v22 = v20 - 7562 * v13 + v21;
    uint64_t v23 = v19 - 9527 * (v14 + v15);
    uint64_t v24 = v21 - 9766 * v15 + v23;
    uint64_t v25 = v20 + 16984 * v14 - 14731 * (v14 + v16) + v23;
    uint64_t v26 = v19 + 3000 * v18;
    uint64_t v27 = v22 + v26;
    uint64_t v28 = -14731 * (v14 + v16) + 17223 * v16 + v26;
    uint64_t v29 = (_DWORD *)v82 + v5;
    uint64_t v30 = ((uint64_t)v9 << 13) | 0x400;
    uint64_t v31 = -12019 * v14 + 8203 * v15;
    uint64_t v32 = v30 + 11116 * v17;
    uint64_t v33 = 20862 * (v11 - v12);
    uint64_t v34 = v32 + 3529 * (v11 - v10);
    uint64_t v35 = v32 + v33;
    uint64_t v36 = v31 - 13802 * v16 + v19;
    uint64_t v37 = v34 - 14924 * v11 + v33;
    uint64_t v38 = v35 + 17333 * v12;
    _DWORD *v29 = (unint64_t)(v27 + v38) >> 11;
    v29[80] = (unint64_t)(v38 - v27) >> 11;
    unint64_t v39 = v25 + v37;
    unint64_t v40 = v37 - v25;
    uint64_t v41 = v32 - 9467 * (v10 + v12);
    v29[8] = v39 >> 11;
    uint64_t v42 = -11395 * v10 + 15929 * v11 + v41;
    uint64_t v43 = v41 - 6461 * v12;
    v29[16] = (unint64_t)(v24 + v43) >> 11;
    v29[64] = (unint64_t)(v43 - v24) >> 11;
    v29[72] = v40 >> 11;
    uint64_t v44 = v34 - 12399 * v10;
    v29[24] = (unint64_t)(v28 + v44) >> 11;
    v29[56] = (unint64_t)(v44 - v28) >> 11;
    v29[32] = (unint64_t)(v36 + v42) >> 11;
    v29[48] = (unint64_t)(v42 - v36) >> 11;
    v29[40] = (unint64_t)(v30 + 0x7FFFFFFD2BFLL * v17) >> 11;
    ++v5;
  }
  while (v5 != 8);
  uint64_t v45 = 0;
  uint64_t v46 = v79 - 384;
  do
  {
    int v47 = &v82[v45];
    int v48 = v47[1];
    int v49 = (unsigned char *)(*(void *)(a4 + v45 * 4) + a5);
    int v50 = (*v47 << 13) + 134348800;
    int v51 = v47[4];
    int v52 = v47[5];
    int v54 = v47[6];
    int v53 = v47[7];
    int v55 = 20862 * (v51 - v54);
    int v56 = v47[2];
    int v57 = v47[3];
    int v58 = v54 + v56 - v51;
    int v59 = v50 + 11116 * v58;
    LODWORD(v47) = v59 + 3529 * (v51 - v56);
    int v60 = v47 - 14924 * v51;
    int v61 = v59 + v55 + 17333 * v54;
    int v62 = v47 - 12399 * v56;
    int v63 = v59 - 9467 * (v54 + v56);
    int v64 = -11395 * v56 + 15929 * v51;
    unint64_t v65 = (v50 + 268423871 * v58);
    int v66 = v63 - 6461 * v54;
    int v67 = 3264 * (v57 + v48 + v52 + v53);
    int v68 = 7274 * (v57 + v48);
    int v69 = v64 + v63;
    int v70 = 5492 * (v52 + v48);
    int v71 = v67 + 3000 * (v53 + v48);
    int v72 = v60 + v55;
    int v73 = v68 - 7562 * v48 + v70 + v71;
    *int v49 = *(unsigned char *)(v46 + (((unint64_t)(v73 + v61) >> 18) & 0x3FF));
    int v74 = v67 - 9527 * (v52 + v57);
    int v75 = v70 - 9766 * v52 + v74;
    int v76 = v68 + 16984 * v57 - 14731 * (v53 + v57) + v74;
    v49[10] = *(unsigned char *)(v46 + (((unint64_t)(v61 - v73) >> 18) & 0x3FF));
    v49[1] = *(unsigned char *)(v46 + (((unint64_t)(v76 + v72) >> 18) & 0x3FF));
    LOBYTE(v73) = *(unsigned char *)(v46 + (((unint64_t)(v72 - v76) >> 18) & 0x3FF));
    uint64_t result = (-14731 * (v53 + v57) + 17223 * v53 + v71);
    v49[9] = v73;
    v49[2] = *(unsigned char *)(v46 + (((unint64_t)(v75 + v66) >> 18) & 0x3FF));
    v49[8] = *(unsigned char *)(v46 + (((unint64_t)(v66 - v75) >> 18) & 0x3FF));
    v49[3] = *(unsigned char *)(v46 + (((unint64_t)(result + v62) >> 18) & 0x3FF));
    int v78 = -12019 * v57 + 8203 * v52 - 13802 * v53 + v67;
    v49[7] = *(unsigned char *)(v46 + (((unint64_t)(v62 - result) >> 18) & 0x3FF));
    v49[4] = *(unsigned char *)(v46 + (((unint64_t)(v78 + v69) >> 18) & 0x3FF));
    v49[6] = *(unsigned char *)(v46 + (((unint64_t)(v69 - v78) >> 18) & 0x3FF));
    v49[5] = *(unsigned char *)(v46 + ((v65 >> 18) & 0x3FF));
    v45 += 2;
  }
  while (v45 != 22);
  return result;
}

unsigned char *jpeg_idct_12x12(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  uint64_t v78 = *(void *)(a1 + 440);
  memset(v81, 0, sizeof(v81));
  uint64_t v6 = *(void *)(a2 + 88);
  do
  {
    uint64_t v7 = (_DWORD *)(v6 + 4 * v5);
    int v8 = (__int16 *)(a3 + 2 * v5);
    uint64_t v9 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    uint64_t v10 = 10033 * (int)v7[32] * (uint64_t)v8[32];
    uint64_t v11 = v10 + v9;
    uint64_t v12 = v9 - v10;
    uint64_t v13 = (int)v7[16] * (uint64_t)v8[16];
    uint64_t v14 = (int)v7[48] * (uint64_t)v8[48];
    uint64_t v15 = v9 + ((v13 - v14) << 13);
    uint64_t v16 = v9 - ((v13 - v14) << 13);
    uint64_t v17 = 11190 * v13 + (v14 << 13);
    uint64_t v18 = v17 + v11;
    uint64_t v19 = v11 - v17;
    uint64_t v20 = 2998 * v13 - (v14 << 13);
    uint64_t v21 = v20 + v12;
    uint64_t v22 = v12 - v20;
    uint64_t v23 = (int)v7[8] * (uint64_t)v8[8];
    uint64_t v24 = (int)v7[24] * (uint64_t)v8[24];
    uint64_t v25 = (int)v7[40] * (uint64_t)v8[40];
    LODWORD(v8) = v8[56];
    LODWORD(v7) = v7[56];
    uint64_t v26 = 10703 * v24;
    uint64_t v27 = -4433 * v24;
    uint64_t v28 = 7053 * (v23 + v25 + (int)v7 * (uint64_t)(int)v8);
    uint64_t v29 = v28 + 2139 * (v23 + v25);
    uint64_t v30 = v24 - v25;
    uint64_t v31 = v26 + 2295 * v23 + v29;
    uint64_t v32 = -8565 * (v25 + (int)v7 * (uint64_t)(int)v8);
    uint64_t v33 = v27 - 12112 * v25 - 8565 * (v25 + (int)v7 * (uint64_t)(int)v8) + v29;
    uint64_t v34 = (int)v7 * (uint64_t)(int)v8;
    uint64_t v35 = v23 - v34;
    uint64_t v36 = v27 - 5540 * v23 - 16244 * v34;
    uint64_t v37 = (_DWORD *)v81 + v5;
    uint64_t v38 = 12998 * v34 - v26 + v32 + v28;
    uint64_t v39 = v36 + v28;
    uint64_t v40 = 4433 * (v35 + v30);
    uint64_t v41 = v40 + 6270 * v35;
    uint64_t v42 = v40 - 15137 * v30;
    *uint64_t v37 = (unint64_t)(v31 + v18) >> 11;
    v37[88] = (unint64_t)(v18 - v31) >> 11;
    v37[8] = (unint64_t)(v41 + v15) >> 11;
    v37[80] = (unint64_t)(v15 - v41) >> 11;
    v37[16] = (unint64_t)(v33 + v21) >> 11;
    v37[72] = (unint64_t)(v21 - v33) >> 11;
    v37[24] = (unint64_t)(v38 + v22) >> 11;
    v37[64] = (unint64_t)(v22 - v38) >> 11;
    v37[32] = (unint64_t)(v42 + v16) >> 11;
    v37[56] = (unint64_t)(v16 - v42) >> 11;
    v37[40] = (unint64_t)(v39 + v19) >> 11;
    v37[48] = (unint64_t)(v19 - v39) >> 11;
    ++v5;
  }
  while (v5 != 8);
  uint64_t v43 = 0;
  uint64_t v44 = v78 - 384;
  do
  {
    uint64_t v45 = &v81[v43];
    int v46 = v45[1];
    int v47 = (*v45 << 13) + 134348800;
    int v48 = v45[5];
    int v49 = 10033 * v45[4];
    int v50 = v47 + v49;
    int v51 = v45[2];
    int v52 = v45[3];
    int v53 = v45[6];
    LODWORD(v45) = v45[7];
    int v54 = v47 - v49;
    int v55 = v47 + ((v51 - v53) << 13);
    int v56 = v47 - ((v51 - v53) << 13);
    int v57 = 11190 * v51 + (v53 << 13);
    int v58 = v57 + v50;
    int v59 = v50 - v57;
    int v60 = 2998 * v51 - (v53 << 13);
    int v61 = 10703 * v52;
    int v62 = -4433 * v52;
    int v63 = v60 + v54;
    int v64 = 7053 * (v48 + v46 + v45);
    int v65 = v64 + 2139 * (v48 + v46);
    int v66 = v54 - v60;
    int v67 = 10703 * v52 + 2295 * v46 + v65;
    int v68 = -8565 * (v45 + v48);
    int v69 = -4433 * v52 - 12112 * v48 - 8565 * (v45 + v48) + v65;
    int v70 = v52 - v48;
    uint64_t result = (unsigned char *)(*(void *)(a4 + v43 * 4) + a5);
    *uint64_t result = *(unsigned char *)(v44 + (((unint64_t)(v67 + v58) >> 18) & 0x3FF));
    unint64_t v72 = (v58 - v67);
    int v73 = 4433 * (v46 - v45 + v70);
    int v74 = v73 + 6270 * (v46 - v45);
    result[11] = *(unsigned char *)(v44 + ((v72 >> 18) & 0x3FF));
    result[1] = *(unsigned char *)(v44 + (((unint64_t)(v74 + v55) >> 18) & 0x3FF));
    int v75 = 12998 * v45 - v61 + v64 + v68;
    result[10] = *(unsigned char *)(v44 + (((unint64_t)(v55 - v74) >> 18) & 0x3FF));
    result[2] = *(unsigned char *)(v44 + (((unint64_t)(v69 + v63) >> 18) & 0x3FF));
    result[9] = *(unsigned char *)(v44 + (((unint64_t)(v63 - v69) >> 18) & 0x3FF));
    int v76 = v62 - 5540 * v46 - 16244 * v45 + v64;
    result[3] = *(unsigned char *)(v44 + (((unint64_t)(v75 + v66) >> 18) & 0x3FF));
    LOBYTE(v66) = *(unsigned char *)(v44 + (((unint64_t)(v66 - v75) >> 18) & 0x3FF));
    int v77 = v73 - 15137 * v70;
    result[8] = v66;
    result[4] = *(unsigned char *)(v44 + (((unint64_t)(v77 + v56) >> 18) & 0x3FF));
    result[7] = *(unsigned char *)(v44 + (((unint64_t)(v56 - v77) >> 18) & 0x3FF));
    result[5] = *(unsigned char *)(v44 + (((unint64_t)(v76 + v59) >> 18) & 0x3FF));
    result[6] = *(unsigned char *)(v44 + (((unint64_t)(v59 - v76) >> 18) & 0x3FF));
    v43 += 2;
  }
  while (v43 != 24);
  return result;
}

uint64_t jpeg_idct_13x13(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  uint64_t v85 = *(void *)(a1 + 440);
  memset(v88, 0, sizeof(v88));
  uint64_t v6 = *(void *)(a2 + 88);
  do
  {
    uint64_t v7 = (_DWORD *)(v6 + 4 * v5);
    int v8 = (__int16 *)(a3 + 2 * v5);
    int v9 = v8[16];
    int v10 = v7[16];
    uint64_t v11 = v10 * (uint64_t)v8[16];
    uint64_t v12 = (int)v7[32] * (uint64_t)v8[32];
    int v13 = v7[48];
    uint64_t v14 = v12 + v13 * (uint64_t)v8[48];
    uint64_t v15 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    uint64_t v16 = v12 - v13 * (uint64_t)v8[48];
    uint64_t v17 = v15 + 793 * v16;
    uint64_t v18 = (int)v7[8] * (uint64_t)v8[8];
    uint64_t v19 = (int)v7[24] * (uint64_t)v8[24];
    uint64_t v20 = (int)v7[40] * (uint64_t)v8[40];
    LODWORD(v8) = v8[56];
    LODWORD(v7) = v7[56];
    uint64_t v21 = 10832 * (v18 + v19);
    uint64_t v22 = 9534 * (v18 + v20);
    uint64_t v23 = v18 + (int)v7 * (uint64_t)(int)v8;
    uint64_t v24 = 9465 * v14 + 11249 * v11 + v17;
    uint64_t v25 = -2773 * (v19 + v20);
    uint64_t v26 = v21 - 16549 * v18 + v22 + 7682 * v23;
    uint64_t v27 = -9534 * (v19 + (int)v7 * (uint64_t)(int)v8);
    uint64_t v28 = v21 + 6859 * v19 + v25 - 9534 * (v19 + (int)v7 * (uint64_t)(int)v8);
    uint64_t v29 = -9465 * v14 + 4108 * v11 + v17;
    uint64_t v30 = (int)v7 * (uint64_t)(int)v8;
    uint64_t v31 = v15 + 3989 * v16;
    uint64_t v32 = v25 - 12879 * v20 + v22 - 5384 * (v20 + v30);
    uint64_t v33 = 2592 * v14 - 10258 * v11 + v31;
    uint64_t v34 = -2592 * v14 + 8672 * v11 + v31;
    v14 *= 3570;
    uint64_t v35 = v27 + 18068 * v30 + 7682 * v23 - 5384 * (v20 + v30);
    uint64_t v36 = -v14 - 1396 * v11;
    uint64_t v37 = v16 - v10 * (uint64_t)v9;
    uint64_t v38 = (_DWORD *)v88 + v5;
    uint64_t v39 = v15 - 7678 * v16;
    uint64_t v40 = v14 - 6581 * v11 + v39;
    uint64_t v41 = v36 + v39;
    *uint64_t v38 = (unint64_t)(v26 + v24) >> 11;
    v38[96] = (unint64_t)(v24 - v26) >> 11;
    v38[8] = (unint64_t)(v28 + v34) >> 11;
    v38[88] = (unint64_t)(v34 - v28) >> 11;
    v38[16] = (unint64_t)(v32 + v29) >> 11;
    uint64_t v42 = 7682 * (v20 - v19) + 2773 * v23;
    v38[80] = (unint64_t)(v29 - v32) >> 11;
    v38[24] = (unint64_t)(v35 + v41) >> 11;
    v38[72] = (unint64_t)(v41 - v35) >> 11;
    uint64_t v43 = v42 + 2611 * v18 - 3818 * v19;
    v38[32] = (unint64_t)(v43 + v40) >> 11;
    v38[64] = (unint64_t)(v40 - v43) >> 11;
    uint64_t v44 = v42 + 3150 * v20 - 14273 * v30;
    v38[40] = (unint64_t)(v44 + v33) >> 11;
    v38[56] = (unint64_t)(v33 - v44) >> 11;
    v38[48] = (unint64_t)(v15 + 11585 * v37) >> 11;
    ++v5;
  }
  while (v5 != 8);
  uint64_t v45 = 0;
  uint64_t v46 = v85 - 384;
  do
  {
    int v47 = &v88[v45];
    int v48 = v47[1];
    int v50 = v47[4];
    int v49 = v47[5];
    int v51 = (*v47 << 13) + 134348800;
    int v52 = v47[6];
    int v53 = v47[7];
    int v54 = v52 + v50;
    int v55 = v50 - v52;
    int v56 = 9465 * (v52 + v50);
    int v57 = v51 + 793 * v55;
    int v59 = v47[2];
    int v58 = v47[3];
    int v60 = 4108 * v59 - v56;
    int v61 = v56 + 11249 * v59 + v57;
    int v62 = v51 + 3989 * v55;
    int v63 = -2592 * v54 + 8672 * v59;
    LODWORD(v47) = 2592 * v54 - 10258 * v59;
    v54 *= 3570;
    int v64 = v47 + v62;
    int v65 = v51 - 7678 * v55;
    int v66 = -v54 - 1396 * v59;
    int v67 = v54 - 6581 * v59 + v65;
    int v68 = v60 + v57;
    unint64_t v69 = (v51 + 11585 * (v55 - v59));
    int v70 = 10832 * (v58 + v48);
    int v71 = v63 + v62;
    int v72 = 9534 * (v49 + v48);
    int v73 = v66 + v65;
    int v74 = v70 - 16549 * v48 + v72 + 7682 * (v53 + v48);
    int v75 = -2773 * (v49 + v58);
    int v76 = v70 + 6859 * v58 + v75 - 9534 * (v53 + v58);
    int v77 = v75 - 12879 * v49 + v72 - 5384 * (v53 + v49);
    uint64_t v78 = (unsigned char *)(*(void *)(a4 + v45 * 4) + a5);
    *uint64_t v78 = *(unsigned char *)(v46 + (((unint64_t)(v74 + v61) >> 18) & 0x3FF));
    v78[12] = *(unsigned char *)(v46 + (((unint64_t)(v61 - v74) >> 18) & 0x3FF));
    int v79 = -9534 * (v53 + v58) + 18068 * v53 + 7682 * (v53 + v48) - 5384 * (v53 + v49);
    v78[1] = *(unsigned char *)(v46 + (((unint64_t)(v76 + v71) >> 18) & 0x3FF));
    v78[11] = *(unsigned char *)(v46 + (((unint64_t)(v71 - v76) >> 18) & 0x3FF));
    v78[2] = *(unsigned char *)(v46 + (((unint64_t)(v77 + v68) >> 18) & 0x3FF));
    unint64_t v80 = (v68 - v77);
    int v81 = 7682 * (v49 - v58) + 2773 * (v53 + v48);
    v78[10] = *(unsigned char *)(v46 + ((v80 >> 18) & 0x3FF));
    v78[3] = *(unsigned char *)(v46 + (((unint64_t)(v79 + v73) >> 18) & 0x3FF));
    int v82 = v81 + 2611 * v48 - 3818 * v58;
    v78[9] = *(unsigned char *)(v46 + (((unint64_t)(v73 - v79) >> 18) & 0x3FF));
    v78[4] = *(unsigned char *)(v46 + (((unint64_t)(v82 + v67) >> 18) & 0x3FF));
    int v83 = v81 + 3150 * v49 - 14273 * v53;
    v78[8] = *(unsigned char *)(v46 + (((unint64_t)(v67 - v82) >> 18) & 0x3FF));
    uint64_t result = *(unsigned __int8 *)(v46 + (((unint64_t)(v83 + v64) >> 18) & 0x3FF));
    v78[5] = result;
    v78[7] = *(unsigned char *)(v46 + (((unint64_t)(v64 - v83) >> 18) & 0x3FF));
    v78[6] = *(unsigned char *)(v46 + ((v69 >> 18) & 0x3FF));
    v45 += 2;
  }
  while (v45 != 26);
  return result;
}

uint64_t jpeg_idct_14x14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v92 = *MEMORY[0x1E4F143B8];
  uint64_t v88 = *(void *)(a1 + 440);
  memset(v91, 0, sizeof(v91));
  uint64_t v6 = *(void *)(a2 + 88);
  do
  {
    uint64_t v7 = (_DWORD *)(v6 + 4 * v5);
    int v8 = (__int16 *)(a3 + 2 * v5);
    uint64_t v9 = (int)v7[32] * (uint64_t)v8[32];
    uint64_t v10 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    uint64_t v11 = v10 + 10438 * v9;
    uint64_t v12 = v10 + 2578 * v9;
    uint64_t v13 = v10 - 7223 * v9;
    uint64_t v14 = (int)v7[16] * (uint64_t)v8[16];
    uint64_t v15 = (int)v7[48] * (uint64_t)v8[48];
    uint64_t v16 = 9058 * (v14 + v15);
    uint64_t v17 = v16 + 2237 * v14;
    uint64_t v18 = v16 - 14084 * v15;
    uint64_t v19 = 5027 * v14 - 11295 * v15;
    uint64_t v20 = v17 + v11;
    uint64_t v21 = v11 - v17;
    uint64_t v22 = v18 + v12;
    uint64_t v23 = v12 - v18;
    uint64_t v24 = v19 + v13;
    uint64_t v25 = v13 - v19;
    uint64_t v26 = (int)v7[8] * (uint64_t)v8[8];
    uint64_t v27 = (int)v7[24] * (uint64_t)v8[24];
    uint64_t v28 = (int)v7[40] * (uint64_t)v8[40];
    uint64_t v29 = (int)v7[56] * (uint64_t)v8[56];
    uint64_t v30 = 10935 * (v26 + v27);
    uint64_t v31 = 9810 * (v26 + v28);
    uint64_t v32 = v30 - 9232 * v26 + v31;
    uint64_t v33 = -1297 * (v27 + v28) - (v29 << 13);
    uint64_t v34 = v30 - 3474 * v27 + v33;
    uint64_t v35 = v31 - 19447 * v28 + v33;
    uint64_t v36 = 6164 * (v26 + v28);
    uint64_t v37 = v26 - v27;
    uint64_t v38 = 11512 * (v28 - v27);
    uint64_t v39 = v38 - 13850 * v28 + v36;
    uint64_t v40 = v36 - 8693 * v26;
    uint64_t v41 = v38 + 5529 * v27;
    uint64_t v42 = 3826 * v37 - (v29 << 13);
    uint64_t v43 = v40 + v42;
    uint64_t v44 = v41 + v42;
    uint64_t v45 = (_DWORD *)v91 + v5;
    uint64_t v46 = v32 + (v29 << 13);
    uint64_t v47 = v39 + (v29 << 13);
    LODWORD(v29) = v37 - v28 + v29;
    *uint64_t v45 = (unint64_t)(v46 + v20) >> 11;
    v45[104] = (unint64_t)(v20 - v46) >> 11;
    v45[8] = (unint64_t)(v34 + v22) >> 11;
    v45[96] = (unint64_t)(v22 - v34) >> 11;
    v45[16] = (unint64_t)(v35 + v24) >> 11;
    unint64_t v48 = (unint64_t)(v10 - 11586 * v9) >> 11;
    v45[88] = (unint64_t)(v24 - v35) >> 11;
    v45[24] = v48 + 4 * v29;
    v45[80] = v48 - 4 * v29;
    v45[32] = (unint64_t)(v47 + v25) >> 11;
    v45[72] = (unint64_t)(v25 - v47) >> 11;
    v45[40] = (unint64_t)(v44 + v23) >> 11;
    v45[64] = (unint64_t)(v23 - v44) >> 11;
    v45[48] = (unint64_t)(v43 + v21) >> 11;
    v45[56] = (unint64_t)(v21 - v43) >> 11;
    ++v5;
  }
  while (v5 != 8);
  uint64_t v49 = 0;
  uint64_t v50 = v88 - 384;
  do
  {
    int v51 = &v91[v49];
    int v52 = v51[1];
    int v53 = (*v51 << 13) + 134348800;
    int v55 = v51[4];
    int v54 = v51[5];
    int v56 = v53 + 10438 * v55;
    int v57 = v53 + 2578 * v55;
    int v58 = v53 - 7223 * v55;
    int v60 = v51[2];
    int v59 = v51[3];
    int v61 = v51[6];
    int v62 = v51[7];
    int v63 = v53 - 11586 * v55;
    LODWORD(v51) = 9058 * (v61 + v60);
    int v64 = v51 + 2237 * v60;
    int v65 = v51 - 14084 * v61;
    LODWORD(v51) = 5027 * v60 - 11295 * v61;
    int v66 = v64 + v56;
    int v67 = v56 - v64;
    int v68 = v51 + v58;
    LODWORD(v51) = v58 - v51;
    int v69 = v65 + v57;
    int v70 = 10935 * (v59 + v52);
    int v71 = 9810 * (v54 + v52);
    int v72 = v70 - 9232 * v52 + v71 + (v62 << 13);
    int v73 = v57 - v65;
    int v74 = -1297 * (v54 + v59) - (v62 << 13);
    int v75 = v70 - 3474 * v59 + v74;
    int v76 = v71 - 19447 * v54 + v74;
    int v77 = -13850 * v54 + (v62 << 13);
    int v78 = 3826 * (v52 - v59) - (v62 << 13);
    int v79 = v52 - v59 - v54 + v62;
    unint64_t v80 = (unsigned char *)(*(void *)(a4 + v49 * 4) + a5);
    unsigned char *v80 = *(unsigned char *)(v50 + (((unint64_t)(v72 + v66) >> 18) & 0x3FF));
    v80[13] = *(unsigned char *)(v50 + (((unint64_t)(v66 - v72) >> 18) & 0x3FF));
    v80[1] = *(unsigned char *)(v50 + (((unint64_t)(v75 + v69) >> 18) & 0x3FF));
    v80[12] = *(unsigned char *)(v50 + (((unint64_t)(v69 - v75) >> 18) & 0x3FF));
    v80[2] = *(unsigned char *)(v50 + (((unint64_t)(v76 + v68) >> 18) & 0x3FF));
    int v81 = 6164 * (v54 + v52);
    int v82 = 11512 * (v54 - v59);
    LOBYTE(v66) = *(unsigned char *)(v50 + (((unint64_t)(v68 - v76) >> 18) & 0x3FF));
    uint64_t result = 4294958603;
    int v84 = v81 - 8693 * v52;
    v80[11] = v66;
    int v85 = v77 + v82 + v81;
    v80[3] = *(unsigned char *)(v50 + (((unint64_t)(v63 + (v79 << 13)) >> 18) & 0x3FF));
    v80[10] = *(unsigned char *)(v50 + (((unint64_t)(v63 - (v79 << 13)) >> 18) & 0x3FF));
    v80[4] = *(unsigned char *)(v50 + (((unint64_t)(v85 + v51) >> 18) & 0x3FF));
    int v86 = v84 + v78;
    int v87 = v82 + 5529 * v59 + v78;
    v80[9] = *(unsigned char *)(v50 + (((unint64_t)(v51 - v85) >> 18) & 0x3FF));
    v80[5] = *(unsigned char *)(v50 + (((unint64_t)(v87 + v73) >> 18) & 0x3FF));
    v80[8] = *(unsigned char *)(v50 + (((unint64_t)(v73 - v87) >> 18) & 0x3FF));
    v80[6] = *(unsigned char *)(v50 + (((unint64_t)(v86 + v67) >> 18) & 0x3FF));
    v80[7] = *(unsigned char *)(v50 + (((unint64_t)(v67 - v86) >> 18) & 0x3FF));
    v49 += 2;
  }
  while (v49 != 28);
  return result;
}

uint64_t jpeg_idct_15x15(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  uint64_t v90 = *(void *)(a1 + 440);
  memset(v93, 0, sizeof(v93));
  uint64_t v6 = *(void *)(a2 + 88);
  do
  {
    uint64_t v7 = (_DWORD *)(v6 + 4 * v5);
    int v8 = (__int16 *)(a3 + 2 * v5);
    uint64_t v9 = (int)v7[16] * (uint64_t)v8[16];
    uint64_t v10 = (int)v7[48] * (uint64_t)v8[48];
    uint64_t v11 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    int v12 = v7[32];
    uint64_t v13 = v11 - 3580 * v10;
    uint64_t v14 = v11 + 9373 * v10;
    uint64_t v15 = v9 - v12 * (uint64_t)v8[32];
    uint64_t v16 = v9 + v12 * (uint64_t)v8[32];
    uint64_t v17 = 11795 * v9;
    uint64_t v18 = 374 * v15 + 10958 * v16 + v14;
    uint64_t v19 = 11795 * v9 - 10958 * v16 + 374 * v15 + v13;
    uint64_t v20 = -3271 * v15 - 4482 * v16 + v14;
    uint64_t v21 = 4482 * v16 - v17 + -3271 * v15 + v13;
    uint64_t v22 = 6476 * v16;
    uint64_t v23 = 2896 * v15 + 6476 * v16 + v13;
    uint64_t v24 = v14 - v22 + 2896 * v15;
    uint64_t v25 = (int)v7[8] * (uint64_t)v8[8];
    uint64_t v26 = (int)v7[24] * (uint64_t)v8[24];
    int v27 = v8[40];
    int v28 = v7[40];
    uint64_t v29 = 10033 * v28 * (uint64_t)v8[40];
    uint64_t v30 = (int)v7[56] * (uint64_t)v8[56];
    uint64_t v31 = -11018 * v26;
    uint64_t v32 = v29 + 11522 * (v25 - v30);
    uint64_t v33 = 11018 * v26 + 20131 * v30 + v32;
    uint64_t v34 = -6810 * v26 - 9113 * v25 + v32;
    uint64_t v35 = v26 - v30;
    uint64_t v36 = -6810 * v26 + 3897 * v25 - v29;
    uint64_t v37 = (_DWORD *)v93 + v5;
    uint64_t v38 = 4712 * (v25 + v30);
    uint64_t v39 = v36 + v38;
    uint64_t v40 = v29 + v31 - 7121 * v30 + v38;
    *uint64_t v37 = (unint64_t)(v33 + v18) >> 11;
    v37[112] = (unint64_t)(v18 - v33) >> 11;
    uint64_t v41 = 6810 * (v35 + v25);
    uint64_t v42 = v41 + 4209 * v25;
    v37[8] = (unint64_t)(v42 + v23) >> 11;
    v37[104] = (unint64_t)(v23 - v42) >> 11;
    uint64_t v43 = v11 - 11586 * v10;
    uint64_t v44 = v43 + 5792 * v15;
    uint64_t v45 = 10033 * (v25 - v30 - v28 * (uint64_t)v27);
    v37[16] = (unint64_t)(v45 + v44) >> 11;
    v37[96] = (unint64_t)(v44 - v45) >> 11;
    v37[24] = (unint64_t)(v39 + v19) >> 11;
    v37[88] = (unint64_t)(v19 - v39) >> 11;
    uint64_t v46 = v41 - 17828 * v35;
    v37[32] = (unint64_t)(v46 + v24) >> 11;
    v37[80] = (unint64_t)(v24 - v46) >> 11;
    v37[40] = (unint64_t)(v40 + v20) >> 11;
    v37[72] = (unint64_t)(v20 - v40) >> 11;
    v37[48] = (unint64_t)(v34 + v21) >> 11;
    v37[64] = (unint64_t)(v21 - v34) >> 11;
    v37[56] = (unint64_t)(v43 + 0x7FFFFFFD2C0 * v15) >> 11;
    ++v5;
  }
  while (v5 != 8);
  uint64_t v47 = 0;
  uint64_t v48 = v90 - 384;
  do
  {
    uint64_t v49 = &v93[v47];
    uint64_t v50 = (unsigned char *)(*(void *)(a4 + v47 * 4) + a5);
    int v51 = v49[1];
    int v52 = (*v49 << 13) + 134348800;
    int v53 = v49[6];
    int v54 = v49[7];
    int v55 = v52 - 3580 * v53;
    int v56 = v52 + 9373 * v53;
    int v57 = v49[2];
    int v58 = v49[3];
    int v59 = v49[4];
    int v60 = v49[5];
    LODWORD(v49) = v52 - 11586 * v53;
    int v61 = v57 - v59;
    int v62 = v59 + v57;
    v57 *= 11795;
    int v63 = 374 * v61 + 10958 * v62 + v56;
    int v64 = v57 - 10958 * v62 + 374 * v61;
    int v65 = -3271 * v61 - 4482 * v62 + v56;
    int v66 = 4482 * v62 - v57 - 3271 * v61;
    v62 *= 6476;
    int v67 = 2896 * v61;
    int v68 = v64 + v55;
    int v69 = 2896 * v61 + v62 + v55;
    int v70 = v56 - v62;
    int v71 = v49 + 5792 * v61;
    unint64_t v72 = (v49 + 268423872 * v61);
    int v73 = v66 + v55;
    int v74 = 10033 * v60;
    int v75 = v58 - v54;
    int v76 = -11018 * v58;
    int v77 = 10033 * v60 + 11522 * (v51 - v54);
    int v78 = v70 + v67;
    int v79 = 11018 * v58 + 20131 * v54 + v77;
    unint64_t v80 = (v79 + v63);
    unint64_t v81 = (v63 - v79);
    int v82 = 6810 * (v58 - v54 + v51);
    unsigned char *v50 = *(unsigned char *)(v48 + ((v80 >> 18) & 0x3FF));
    LODWORD(v80) = v82 + 4209 * v51;
    v50[14] = *(unsigned char *)(v48 + ((v81 >> 18) & 0x3FF));
    v50[1] = *(unsigned char *)(v48 + (((unint64_t)(v80 + v69) >> 18) & 0x3FF));
    int v83 = 10033 * (v51 - v54 - v60);
    v50[13] = *(unsigned char *)(v48 + (((unint64_t)(v69 - v80) >> 18) & 0x3FF));
    v58 *= -6810;
    v50[2] = *(unsigned char *)(v48 + (((unint64_t)(v83 + v71) >> 18) & 0x3FF));
    LODWORD(v81) = 4712 * (v54 + v51);
    unint64_t v84 = (v71 - v83);
    int v85 = v58 + 3897 * v51 - v74 + v81;
    v50[12] = *(unsigned char *)(v48 + ((v84 >> 18) & 0x3FF));
    int v86 = v82 - 17828 * v75;
    v50[3] = *(unsigned char *)(v48 + (((unint64_t)(v85 + v68) >> 18) & 0x3FF));
    uint64_t result = (v74 + v76);
    v50[11] = *(unsigned char *)(v48 + (((unint64_t)(v68 - v85) >> 18) & 0x3FF));
    v50[4] = *(unsigned char *)(v48 + (((unint64_t)(v86 + v78) >> 18) & 0x3FF));
    int v88 = result - 7121 * v54 + v81;
    v50[10] = *(unsigned char *)(v48 + (((unint64_t)(v78 - v86) >> 18) & 0x3FF));
    v50[5] = *(unsigned char *)(v48 + (((unint64_t)(v88 + v65) >> 18) & 0x3FF));
    int v89 = v58 - 9113 * v51 + v77;
    v50[9] = *(unsigned char *)(v48 + (((unint64_t)(v65 - v88) >> 18) & 0x3FF));
    v50[6] = *(unsigned char *)(v48 + (((unint64_t)(v89 + v73) >> 18) & 0x3FF));
    v50[8] = *(unsigned char *)(v48 + (((unint64_t)(v73 - v89) >> 18) & 0x3FF));
    v50[7] = *(unsigned char *)(v48 + ((v72 >> 18) & 0x3FF));
    v47 += 2;
  }
  while (v47 != 30);
  return result;
}

uint64_t jpeg_idct_16x16(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v117 = *MEMORY[0x1E4F143B8];
  uint64_t v110 = *(void *)(a1 + 440);
  memset(v116, 0, sizeof(v116));
  uint64_t v113 = *(void *)(a2 + 88);
  do
  {
    uint64_t v6 = (_DWORD *)(v113 + 4 * v5);
    uint64_t v7 = (__int16 *)(a3 + 2 * v5);
    uint64_t v8 = (int)v6[32] * (uint64_t)v7[32];
    uint64_t v9 = 10703 * v8;
    uint64_t v10 = ((uint64_t)(*v6 * *v7) << 13) | 0x400;
    v8 *= 4433;
    uint64_t v11 = v9 + v10;
    uint64_t v12 = v10 - v9;
    uint64_t v13 = v8 + v10;
    uint64_t v14 = v10 - v8;
    uint64_t v15 = (int)v6[16] * (uint64_t)v7[16];
    uint64_t v16 = (int)v6[48] * (uint64_t)v7[48];
    uint64_t v17 = 2260 * (v15 - v16);
    uint64_t v18 = 11363 * (v15 - v16);
    uint64_t v19 = v18 + 20995 * v16;
    uint64_t v20 = v17 + 7373 * v15;
    uint64_t v21 = v18 - 4926 * v15;
    uint64_t v22 = v17 - 4176 * v16;
    uint64_t v23 = v19 + v11;
    uint64_t v115 = v11 - v19;
    uint64_t v24 = v20 + v13;
    uint64_t v25 = v13 - v20;
    uint64_t v26 = v21 + v14;
    uint64_t v27 = v14 - v21;
    uint64_t v28 = v22 + v12;
    uint64_t v29 = v12 - v22;
    uint64_t v30 = (int)v6[8] * (uint64_t)v7[8];
    uint64_t v31 = (int)v6[24] * (uint64_t)v7[24];
    int v32 = v7[40];
    int v33 = v6[40];
    int v34 = v7[56];
    int v35 = v6[56];
    uint64_t v36 = v30 + v33 * (uint64_t)v7[40];
    uint64_t v37 = 11086 * (v30 + v31);
    uint64_t v38 = 10217 * v36;
    uint64_t v39 = 8956 * (v30 + v35 * (uint64_t)v34);
    uint64_t v40 = 7350 * (v30 - v35 * (uint64_t)v34);
    uint64_t v41 = 5461 * v36;
    uint64_t v42 = 3363 * (v30 - v31);
    uint64_t v43 = v37 - 18730 * v30 + 10217 * v36 + v39;
    uint64_t v44 = v42 - 15038 * v30 + 5461 * v36 + v40;
    uint64_t v45 = 1136 * (v31 + v33 * (uint64_t)v32);
    uint64_t v46 = v31 + v35 * (uint64_t)v34;
    uint64_t v47 = -5461 * v46;
    uint64_t v48 = v37 + 589 * v31 + v45 - 5461 * v46;
    uint64_t v49 = v33 * (uint64_t)v32;
    uint64_t v50 = 11529 * (v49 - v31);
    v46 *= -10217;
    uint64_t v51 = v42 + 16154 * v31 + v50 + v46;
    uint64_t v52 = v45 - 9222 * v49 + v38 - 11086 * (v49 + v35 * (uint64_t)v34);
    uint64_t v53 = v35 * (uint64_t)v34;
    uint64_t v54 = v47 + 8728 * v53 + v39 - 11086 * (v49 + v53);
    uint64_t v55 = v53 - v49;
    uint64_t v56 = v46 + 25733 * v53 + v40 + 3363 * (v53 - v49);
    uint64_t v57 = v41 + 3363 * v55;
    int v58 = (_DWORD *)v116 + v5;
    uint64_t v59 = v50 - 6278 * v49 + v57;
    *int v58 = (unint64_t)(v43 + v23) >> 11;
    v58[120] = (unint64_t)(v23 - v43) >> 11;
    v58[8] = (unint64_t)(v48 + v24) >> 11;
    v58[112] = (unint64_t)(v24 - v48) >> 11;
    v58[16] = (unint64_t)(v52 + v26) >> 11;
    v58[104] = (unint64_t)(v26 - v52) >> 11;
    v58[24] = (unint64_t)(v54 + v28) >> 11;
    v58[96] = (unint64_t)(v28 - v54) >> 11;
    v58[32] = (unint64_t)(v56 + v29) >> 11;
    v58[88] = (unint64_t)(v29 - v56) >> 11;
    v58[40] = (unint64_t)(v59 + v27) >> 11;
    v58[80] = (unint64_t)(v27 - v59) >> 11;
    v58[48] = (unint64_t)(v51 + v25) >> 11;
    v58[72] = (unint64_t)(v25 - v51) >> 11;
    v58[56] = (unint64_t)(v44 + v115) >> 11;
    v58[64] = (unint64_t)(v115 - v44) >> 11;
    ++v5;
  }
  while (v5 != 8);
  uint64_t v60 = 0;
  uint64_t v61 = v110 - 384;
  do
  {
    int v62 = &v116[v60];
    int v63 = v62[1];
    int v64 = v62[4];
    int v65 = v62[5];
    int v66 = (*v62 << 13) + 134348800;
    int v67 = 10703 * v64;
    v64 *= 4433;
    int v68 = v66 + v67;
    int v69 = v66 - v67;
    int v71 = v62[2];
    int v70 = v62[3];
    int v72 = v66 + v64;
    int v73 = v62[6];
    int v74 = v62[7];
    int v75 = 2260 * (v71 - v73);
    int v76 = v66 - v64;
    LODWORD(v62) = 11363 * (v71 - v73);
    int v77 = v62 + 20995 * v73;
    int v78 = v75 + 7373 * v71;
    int v79 = v62 - 4926 * v71;
    int v80 = v75 - 4176 * v73;
    int v81 = v77 + v68;
    LODWORD(v62) = v68 - v77;
    int v82 = v78 + v72;
    int v83 = v72 - v78;
    int v84 = v79 + v76;
    uint64_t result = (v76 - v79);
    int v86 = 11086 * (v70 + v63);
    int v87 = 10217 * (v65 + v63);
    int v88 = 8956 * (v74 + v63);
    int v89 = v80 + v69;
    int v90 = 7350 * (v63 - v74);
    int v91 = 5461 * (v65 + v63);
    int v92 = 3363 * (v63 - v70);
    int v93 = v69 - v80;
    int v94 = v86 - 18730 * v63 + v87 + v88;
    int v95 = v92 - 15038 * v63 + v91 + v90;
    int v96 = 1136 * (v65 + v70);
    int v97 = v96 - 9222 * v65;
    int v98 = v86 + 589 * v70 + v96 - 5461 * (v74 + v70);
    int v99 = v97 + v87 - 11086 * (v74 + v65);
    int v100 = -5461 * (v74 + v70) + 8728 * v74 + v88 - 11086 * (v74 + v65);
    char v101 = (unsigned char *)(*(void *)(a4 + v60 * 4) + a5);
    *char v101 = *(unsigned char *)(v61 + (((unint64_t)(v94 + v81) >> 18) & 0x3FF));
    v101[15] = *(unsigned char *)(v61 + (((unint64_t)(v81 - v94) >> 18) & 0x3FF));
    v101[1] = *(unsigned char *)(v61 + (((unint64_t)(v98 + v82) >> 18) & 0x3FF));
    int v102 = -10217 * (v74 + v70);
    int v103 = v102 + 25733 * v74;
    int v104 = 3363 * (v74 - v65);
    int v105 = v103 + v90 + v104;
    v101[14] = *(unsigned char *)(v61 + (((unint64_t)(v82 - v98) >> 18) & 0x3FF));
    v101[2] = *(unsigned char *)(v61 + (((unint64_t)(v99 + v84) >> 18) & 0x3FF));
    v101[13] = *(unsigned char *)(v61 + (((unint64_t)(v84 - v99) >> 18) & 0x3FF));
    v101[3] = *(unsigned char *)(v61 + (((unint64_t)(v100 + v89) >> 18) & 0x3FF));
    v101[12] = *(unsigned char *)(v61 + (((unint64_t)(v89 - v100) >> 18) & 0x3FF));
    v101[4] = *(unsigned char *)(v61 + (((unint64_t)(v105 + v93) >> 18) & 0x3FF));
    int v106 = v92 + 16154 * v70;
    int v107 = 11529 * (v65 - v70);
    int v108 = v107 - 6278 * v65 + v91 + v104;
    v101[11] = *(unsigned char *)(v61 + (((unint64_t)(v93 - v105) >> 18) & 0x3FF));
    v101[5] = *(unsigned char *)(v61 + (((unint64_t)(v108 + result) >> 18) & 0x3FF));
    int v109 = v106 + v107 + v102;
    v101[10] = *(unsigned char *)(v61 + (((unint64_t)(result - v108) >> 18) & 0x3FF));
    v101[6] = *(unsigned char *)(v61 + (((unint64_t)(v109 + v83) >> 18) & 0x3FF));
    v101[9] = *(unsigned char *)(v61 + (((unint64_t)(v83 - v109) >> 18) & 0x3FF));
    v101[7] = *(unsigned char *)(v61 + (((unint64_t)(v95 + v62) >> 18) & 0x3FF));
    v101[8] = *(unsigned char *)(v61 + (((unint64_t)(v62 - v95) >> 18) & 0x3FF));
    v60 += 2;
  }
  while (v60 != 32);
  return result;
}

uint64_t jpeg_idct_16x8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  uint64_t v91 = *(void *)(a1 + 440);
  uint64_t v6 = (__int16 *)(a3 + 64);
  uint64_t v7 = *(void *)(a2 + 88) + 128;
  unsigned int v8 = 9;
  memset(v94, 0, sizeof(v94));
  do
  {
    uint64_t v9 = (_DWORD *)(v7 + v5);
    unsigned __int16 v10 = *(v6 - 16);
    if ((unsigned __int16)*(v6 - 24) | v10) {
      goto LABEL_9;
    }
    if (*(v6 - 8) || *v6 || v6[8] || v6[16] || v6[24])
    {
      unsigned __int16 v10 = 0;
LABEL_9:
      uint64_t v11 = *v9 * *v6;
      uint64_t v12 = ((uint64_t)(*(v9 - 32) * *(v6 - 32)) << 13) | 0x400;
      uint64_t v13 = v12 + (v11 << 13);
      uint64_t v14 = v12 - (v11 << 13);
      uint64_t v15 = (int)*(v9 - 16) * (uint64_t)(__int16)v10;
      uint64_t v16 = (int)v9[16] * (uint64_t)v6[16];
      uint64_t v17 = 4433 * (v15 + v16);
      uint64_t v18 = v17 + 6270 * v15;
      uint64_t v19 = v17 - 15137 * v16;
      uint64_t v20 = v18 + v13;
      uint64_t v21 = v13 - v18;
      uint64_t v22 = v19 + v14;
      uint64_t v23 = v14 - v19;
      uint64_t v24 = (int)v9[24] * (uint64_t)v6[24];
      uint64_t v25 = (int)v9[8] * (uint64_t)v6[8];
      uint64_t v26 = (int)*(v9 - 8) * (uint64_t)*(v6 - 8);
      uint64_t v27 = (int)*(v9 - 24) * (uint64_t)*(v6 - 24);
      uint64_t v28 = 9633 * (v25 + v27 + v24 + v26);
      uint64_t v29 = v28 - 16069 * (v24 + v26);
      uint64_t v30 = v28 - 3196 * (v25 + v27);
      uint64_t v31 = -7373 * (v24 + v27);
      uint64_t v32 = v31 + 2446 * v24 + v29;
      uint64_t v33 = v31 + 12299 * v27 + v30;
      uint64_t v34 = -20995 * (v25 + v26);
      uint64_t v35 = v34 + 16819 * v25 + v30;
      uint64_t v36 = v34 + 25172 * v26 + v29;
      uint64_t v37 = (_DWORD *)((char *)v94 + v5);
      *uint64_t v37 = (unint64_t)(v33 + v20) >> 11;
      v37[56] = (unint64_t)(v20 - v33) >> 11;
      v37[8] = (unint64_t)(v36 + v22) >> 11;
      v37[48] = (unint64_t)(v22 - v36) >> 11;
      v37[16] = (unint64_t)(v35 + v23) >> 11;
      v37[40] = (unint64_t)(v23 - v35) >> 11;
      v37[24] = (unint64_t)(v32 + v21) >> 11;
      unint64_t v38 = (unint64_t)(v21 - v32) >> 11;
      uint64_t v39 = 8;
      goto LABEL_10;
    }
    LODWORD(v38) = 4 * *(v6 - 32) * *(v9 - 32);
    uint64_t v40 = (_DWORD *)((char *)v94 + v5);
    _DWORD *v40 = v38;
    v40[8] = v38;
    v40[16] = v38;
    v40[24] = v38;
    v40[32] = v38;
    v40[40] = v38;
    v40[48] = v38;
    uint64_t v39 = 14;
LABEL_10:
    *(_DWORD *)((char *)&v94[v39] + v5) = v38;
    --v8;
    v5 += 4;
    ++v6;
  }
  while (v8 > 1);
  uint64_t v41 = 0;
  uint64_t v42 = v91 - 384;
  do
  {
    uint64_t v43 = &v94[v41];
    int v44 = v43[1];
    int v45 = v43[4];
    int v46 = v43[5];
    int v47 = (*v43 << 13) + 134348800;
    int v48 = 10703 * v45;
    v45 *= 4433;
    int v49 = v47 + v48;
    int v50 = v47 - v48;
    int v52 = v43[2];
    int v51 = v43[3];
    int v53 = v47 + v45;
    int v54 = v43[6];
    int v55 = v43[7];
    int v56 = 2260 * (v52 - v54);
    int v57 = v47 - v45;
    LODWORD(v43) = 11363 * (v52 - v54);
    int v58 = v43 + 20995 * v54;
    int v59 = v56 + 7373 * v52;
    int v60 = v43 - 4926 * v52;
    int v61 = v56 - 4176 * v54;
    int v62 = v58 + v49;
    LODWORD(v43) = v49 - v58;
    int v63 = v59 + v53;
    int v64 = v53 - v59;
    int v65 = v60 + v57;
    uint64_t result = (v57 - v60);
    int v67 = 11086 * (v51 + v44);
    int v68 = 10217 * (v46 + v44);
    int v69 = 8956 * (v55 + v44);
    int v70 = v61 + v50;
    int v71 = 7350 * (v44 - v55);
    int v72 = 5461 * (v46 + v44);
    int v73 = 3363 * (v44 - v51);
    int v74 = v50 - v61;
    int v75 = v67 - 18730 * v44 + v68 + v69;
    int v76 = v73 - 15038 * v44 + v72 + v71;
    int v77 = 1136 * (v46 + v51);
    int v78 = v77 - 9222 * v46;
    int v79 = v67 + 589 * v51 + v77 - 5461 * (v55 + v51);
    int v80 = v78 + v68 - 11086 * (v55 + v46);
    int v81 = -5461 * (v55 + v51) + 8728 * v55 + v69 - 11086 * (v55 + v46);
    int v82 = (unsigned char *)(*(void *)(a4 + v41 * 4) + a5);
    unsigned char *v82 = *(unsigned char *)(v42 + (((unint64_t)(v75 + v62) >> 18) & 0x3FF));
    v82[15] = *(unsigned char *)(v42 + (((unint64_t)(v62 - v75) >> 18) & 0x3FF));
    v82[1] = *(unsigned char *)(v42 + (((unint64_t)(v79 + v63) >> 18) & 0x3FF));
    int v83 = -10217 * (v55 + v51);
    int v84 = v83 + 25733 * v55;
    int v85 = 3363 * (v55 - v46);
    int v86 = v84 + v71 + v85;
    v82[14] = *(unsigned char *)(v42 + (((unint64_t)(v63 - v79) >> 18) & 0x3FF));
    v82[2] = *(unsigned char *)(v42 + (((unint64_t)(v80 + v65) >> 18) & 0x3FF));
    v82[13] = *(unsigned char *)(v42 + (((unint64_t)(v65 - v80) >> 18) & 0x3FF));
    v82[3] = *(unsigned char *)(v42 + (((unint64_t)(v81 + v70) >> 18) & 0x3FF));
    v82[12] = *(unsigned char *)(v42 + (((unint64_t)(v70 - v81) >> 18) & 0x3FF));
    v82[4] = *(unsigned char *)(v42 + (((unint64_t)(v86 + v74) >> 18) & 0x3FF));
    int v87 = v73 + 16154 * v51;
    int v88 = 11529 * (v46 - v51);
    int v89 = v88 - 6278 * v46 + v72 + v85;
    v82[11] = *(unsigned char *)(v42 + (((unint64_t)(v74 - v86) >> 18) & 0x3FF));
    v82[5] = *(unsigned char *)(v42 + (((unint64_t)(v89 + result) >> 18) & 0x3FF));
    int v90 = v87 + v88 + v83;
    v82[10] = *(unsigned char *)(v42 + (((unint64_t)(result - v89) >> 18) & 0x3FF));
    v82[6] = *(unsigned char *)(v42 + (((unint64_t)(v90 + v64) >> 18) & 0x3FF));
    v82[9] = *(unsigned char *)(v42 + (((unint64_t)(v64 - v90) >> 18) & 0x3FF));
    v82[7] = *(unsigned char *)(v42 + (((unint64_t)(v76 + v43) >> 18) & 0x3FF));
    v82[8] = *(unsigned char *)(v42 + (((unint64_t)(v43 - v76) >> 18) & 0x3FF));
    v41 += 2;
  }
  while (v41 != 16);
  return result;
}

uint64_t jpeg_idct_14x7(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  uint64_t v69 = *(void *)(a1 + 440);
  memset(v72, 0, sizeof(v72));
  uint64_t v6 = *(void *)(a2 + 88);
  do
  {
    uint64_t v7 = (_DWORD *)v72 + v5;
    unsigned int v8 = (_DWORD *)(v6 + 4 * v5);
    uint64_t v9 = (__int16 *)(a3 + 2 * v5);
    uint64_t v10 = ((uint64_t)(*v8 * *v9) << 13) | 0x400;
    uint64_t v11 = (int)v8[16] * (uint64_t)v9[16];
    uint64_t v12 = (int)v8[32] * (uint64_t)v9[32];
    uint64_t v13 = (int)v8[48] * (uint64_t)v9[48];
    uint64_t v14 = 7223 * (v12 - v13);
    uint64_t v15 = 2578 * (v11 - v12);
    uint64_t v16 = v10 - 15083 * v12 + v15 + v14;
    uint64_t v17 = v10 + 10438 * (v11 + v13);
    uint64_t v18 = v14 - 637 * v13 + v17;
    uint64_t v19 = v15 - 20239 * v11 + v17;
    unint64_t v20 = v10 + 11585 * (v12 - (v11 + v13));
    uint64_t v21 = (int)v8[8] * (uint64_t)v9[8];
    uint64_t v22 = (int)v8[24] * (uint64_t)v9[24];
    uint64_t v23 = (int)v8[40] * (uint64_t)v9[40];
    uint64_t v24 = 7663 * (v21 + v22);
    uint64_t v25 = 1395 * (v21 - v22);
    uint64_t v26 = v24 - v25;
    uint64_t v27 = v24 + v25 - 11295 * (v22 + v23);
    uint64_t v28 = 5027 * (v21 + v23);
    uint64_t v29 = v28 + v26;
    uint64_t v30 = v28 + 15326 * v23 - 11295 * (v22 + v23);
    _DWORD *v7 = (unint64_t)(v29 + v18) >> 11;
    v7[48] = (unint64_t)(v18 - v29) >> 11;
    v7[8] = (unint64_t)(v27 + v16) >> 11;
    v7[40] = (unint64_t)(v16 - v27) >> 11;
    v7[16] = (unint64_t)(v30 + v19) >> 11;
    v7[32] = (unint64_t)(v19 - v30) >> 11;
    v7[24] = v20 >> 11;
    ++v5;
  }
  while (v5 != 8);
  uint64_t v31 = 0;
  uint64_t v32 = v69 - 384;
  do
  {
    uint64_t v33 = &v72[v31];
    int v34 = v33[1];
    int v35 = (*v33 << 13) + 134348800;
    int v36 = v33[4];
    int v37 = v33[5];
    int v38 = v35 + 10438 * v36;
    int v39 = v35 + 2578 * v36;
    int v40 = v35 - 7223 * v36;
    int v42 = v33[2];
    int v41 = v33[3];
    int v43 = v33[6];
    int v44 = v33[7];
    int v45 = v35 - 11586 * v36;
    LODWORD(v33) = 9058 * (v43 + v42);
    int v46 = v33 + 2237 * v42;
    int v47 = v33 - 14084 * v43;
    LODWORD(v33) = 5027 * v42 - 11295 * v43;
    int v48 = v46 + v38;
    int v49 = v38 - v46;
    int v50 = v33 + v40;
    LODWORD(v33) = v40 - v33;
    int v51 = v47 + v39;
    int v52 = 10935 * (v41 + v34);
    int v53 = 9810 * (v37 + v34);
    int v54 = v52 - 9232 * v34 + v53 + (v44 << 13);
    int v55 = v39 - v47;
    int v56 = -1297 * (v37 + v41) - (v44 << 13);
    int v57 = v52 - 3474 * v41 + v56;
    int v58 = v53 - 19447 * v37 + v56;
    int v59 = -13850 * v37 + (v44 << 13);
    int v60 = 3826 * (v34 - v41) - (v44 << 13);
    int v61 = v34 - v41 - v37 + v44;
    int v62 = (unsigned char *)(*(void *)(a4 + v31 * 4) + a5);
    unsigned char *v62 = *(unsigned char *)(v32 + (((unint64_t)(v54 + v48) >> 18) & 0x3FF));
    v62[13] = *(unsigned char *)(v32 + (((unint64_t)(v48 - v54) >> 18) & 0x3FF));
    v62[1] = *(unsigned char *)(v32 + (((unint64_t)(v57 + v51) >> 18) & 0x3FF));
    v62[12] = *(unsigned char *)(v32 + (((unint64_t)(v51 - v57) >> 18) & 0x3FF));
    v62[2] = *(unsigned char *)(v32 + (((unint64_t)(v58 + v50) >> 18) & 0x3FF));
    int v63 = 6164 * (v37 + v34);
    int v64 = 11512 * (v37 - v41);
    LOBYTE(v48) = *(unsigned char *)(v32 + (((unint64_t)(v50 - v58) >> 18) & 0x3FF));
    uint64_t result = 4294958603;
    int v66 = v63 - 8693 * v34;
    v62[11] = v48;
    int v67 = v59 + v64 + v63;
    void v62[3] = *(unsigned char *)(v32 + (((unint64_t)(v45 + (v61 << 13)) >> 18) & 0x3FF));
    v62[10] = *(unsigned char *)(v32 + (((unint64_t)(v45 - (v61 << 13)) >> 18) & 0x3FF));
    v62[4] = *(unsigned char *)(v32 + (((unint64_t)(v67 + v33) >> 18) & 0x3FF));
    int v68 = v64 + 5529 * v41 + v60;
    v62[9] = *(unsigned char *)(v32 + (((unint64_t)(v33 - v67) >> 18) & 0x3FF));
    v62[5] = *(unsigned char *)(v32 + (((unint64_t)(v68 + v55) >> 18) & 0x3FF));
    v62[8] = *(unsigned char *)(v32 + (((unint64_t)(v55 - v68) >> 18) & 0x3FF));
    v62[6] = *(unsigned char *)(v32 + (((unint64_t)(v66 + v60 + v49) >> 18) & 0x3FF));
    v62[7] = *(unsigned char *)(v32 + (((unint64_t)(v49 - (v66 + v60)) >> 18) & 0x3FF));
    v31 += 2;
  }
  while (v31 != 14);
  return result;
}

uint64_t jpeg_idct_12x6(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 440);
  memset(v59, 0, sizeof(v59));
  uint64_t v7 = *(void *)(a2 + 88);
  do
  {
    unsigned int v8 = (_DWORD *)v59 + v5;
    uint64_t v9 = (_DWORD *)(v7 + 4 * v5);
    uint64_t v10 = (__int16 *)(a3 + 2 * v5);
    uint64_t v11 = ((uint64_t)(*v9 * *v10) << 13) | 0x400;
    uint64_t v12 = (int)v9[32] * (uint64_t)v10[32];
    uint64_t v13 = v11 + 5793 * v12;
    unint64_t v14 = (unint64_t)(v11 - 11586 * v12) >> 11;
    uint64_t v15 = 10033 * (int)v9[16] * (uint64_t)v10[16];
    uint64_t v16 = v15 + v13;
    uint64_t v17 = v13 - v15;
    uint64_t v18 = (int)v9[8] * (uint64_t)v10[8];
    uint64_t v19 = (int)v9[24] * (uint64_t)v10[24];
    uint64_t v20 = (int)v9[40] * (uint64_t)v10[40];
    uint64_t v21 = 2998 * (v18 + v20);
    uint64_t v22 = v21 + ((v18 + v19) << 13);
    uint64_t v23 = v21 + ((v20 - v19) << 13);
    LODWORD(v18) = v18 - (v19 + v20);
    *unsigned int v8 = (unint64_t)(v22 + v16) >> 11;
    v8[40] = (unint64_t)(v16 - v22) >> 11;
    v8[8] = v14 + 4 * v18;
    v8[32] = v14 - 4 * v18;
    v8[16] = (unint64_t)(v23 + v17) >> 11;
    v8[24] = (unint64_t)(v17 - v23) >> 11;
    ++v5;
  }
  while (v5 != 8);
  uint64_t v24 = 0;
  uint64_t v25 = v6 - 384;
  do
  {
    uint64_t v26 = &v59[v24];
    int v27 = v26[1];
    int v28 = (*v26 << 13) + 134348800;
    int v29 = v26[5];
    int v30 = 10033 * v26[4];
    int v31 = v28 + v30;
    int v33 = v26[2];
    int v32 = v26[3];
    int v34 = v26[6];
    int v35 = v26[7];
    int v36 = v28 - v30;
    int v37 = v28 + ((v33 - v34) << 13);
    int v38 = v28 - ((v33 - v34) << 13);
    int v39 = 11190 * v33 + (v34 << 13);
    int v40 = v39 + v31;
    LODWORD(v26) = v31 - v39;
    int v41 = 2998 * v33 - (v34 << 13);
    int v42 = 10703 * v32;
    int v43 = -4433 * v32;
    int v44 = v41 + v36;
    int v45 = 7053 * (v29 + v27 + v35);
    int v46 = v45 + 2139 * (v29 + v27);
    int v47 = v36 - v41;
    int v48 = 10703 * v32 + 2295 * v27 + v46;
    int v49 = -8565 * (v35 + v29);
    int v50 = -4433 * v32 - 12112 * v29 - 8565 * (v35 + v29) + v46;
    int v51 = v32 - v29;
    int v52 = (unsigned char *)(*(void *)(a4 + v24 * 4) + a5);
    unsigned char *v52 = *(unsigned char *)(v25 + (((unint64_t)(v48 + v40) >> 18) & 0x3FF));
    unint64_t v53 = (v40 - v48);
    uint64_t result = (4433 * (v27 - v35 + v51));
    int v55 = result + 6270 * (v27 - v35);
    v52[11] = *(unsigned char *)(v25 + ((v53 >> 18) & 0x3FF));
    v52[1] = *(unsigned char *)(v25 + (((unint64_t)(v55 + v37) >> 18) & 0x3FF));
    int v56 = 12998 * v35 - v42 + v45 + v49;
    v52[10] = *(unsigned char *)(v25 + (((unint64_t)(v37 - v55) >> 18) & 0x3FF));
    v52[2] = *(unsigned char *)(v25 + (((unint64_t)(v50 + v44) >> 18) & 0x3FF));
    v52[9] = *(unsigned char *)(v25 + (((unint64_t)(v44 - v50) >> 18) & 0x3FF));
    int v57 = v43 - 5540 * v27 - 16244 * v35 + v45;
    v52[3] = *(unsigned char *)(v25 + (((unint64_t)(v56 + v47) >> 18) & 0x3FF));
    int v58 = result - 15137 * v51;
    v52[8] = *(unsigned char *)(v25 + (((unint64_t)(v47 - v56) >> 18) & 0x3FF));
    v52[4] = *(unsigned char *)(v25 + (((unint64_t)(v58 + v38) >> 18) & 0x3FF));
    v52[7] = *(unsigned char *)(v25 + (((unint64_t)(v38 - v58) >> 18) & 0x3FF));
    v52[5] = *(unsigned char *)(v25 + (((unint64_t)(v57 + v26) >> 18) & 0x3FF));
    v52[6] = *(unsigned char *)(v25 + (((unint64_t)(v26 - v57) >> 18) & 0x3FF));
    v24 += 2;
  }
  while (v24 != 12);
  return result;
}

uint64_t jpeg_idct_10x5(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 440);
  memset(v56, 0, sizeof(v56));
  uint64_t v7 = *(void *)(a2 + 88);
  do
  {
    unsigned int v8 = (_DWORD *)v56 + v5;
    uint64_t v9 = (_DWORD *)(v7 + 4 * v5);
    uint64_t v10 = (__int16 *)(a3 + 2 * v5);
    uint64_t v11 = ((uint64_t)(*v9 * *v10) << 13) | 0x400;
    uint64_t v12 = (int)v9[16] * (uint64_t)v10[16];
    int v13 = v9[32];
    uint64_t v14 = 6476 * (v12 + v13 * (uint64_t)v10[32]);
    uint64_t v15 = v12 - v13 * (uint64_t)v10[32];
    uint64_t v16 = v11 + 2896 * v15;
    uint64_t v17 = v16 + v14;
    uint64_t v18 = v16 - v14;
    unint64_t v19 = v11 + 0x7FFFFFFD2C0 * v15;
    uint64_t v20 = (int)v9[8] * (uint64_t)v10[8];
    uint64_t v21 = (int)v9[24] * (uint64_t)v10[24];
    uint64_t v22 = 6810 * (v20 + v21);
    uint64_t v23 = v22 + 4209 * v20;
    uint64_t v24 = v22 - 17828 * v21;
    *unsigned int v8 = (unint64_t)(v23 + v17) >> 11;
    v8[32] = (unint64_t)(v17 - v23) >> 11;
    v8[8] = (unint64_t)(v24 + v18) >> 11;
    v8[24] = (unint64_t)(v18 - v24) >> 11;
    v8[16] = v19 >> 11;
    ++v5;
  }
  while (v5 != 8);
  uint64_t v25 = 0;
  uint64_t v26 = v6 - 384;
  uint64_t result = 2531;
  do
  {
    int v28 = &v56[v25];
    int v29 = v28[1];
    int v30 = v28[4];
    int v31 = v28[5];
    int v32 = (*v28 << 13) + 134348800;
    int v33 = v32 + 9373 * v30;
    int v34 = v32 - 3580 * v30;
    int v36 = v28[2];
    int v35 = v28[3];
    int v37 = v32 - 11586 * v30;
    int v39 = v28[6];
    int v38 = v28[7];
    LODWORD(v28) = 6810 * (v39 + v36);
    int v40 = v28 + 4209 * v36;
    int v41 = v28 - 17828 * v39;
    int v42 = v40 + v33;
    LODWORD(v28) = v33 - v40;
    int v43 = v41 + v34;
    int v44 = v38 + v35;
    int v45 = v35 - v38;
    int v46 = v34 - v41;
    int v47 = 2531 * v45 + (v31 << 13);
    int v48 = 7791 * v44 + 11443 * v29 + v47;
    int v49 = (unsigned char *)(*(void *)(a4 + v25 * 4) + a5);
    int v50 = 1812 * v29 - 7791 * v44 + v47;
    int v51 = 4815 * v44;
    unint64_t v52 = (v48 + v42);
    unint64_t v53 = (v42 - v48);
    int v54 = -6627 * v45 + (v31 << 13);
    *int v49 = *(unsigned char *)(v26 + ((v52 >> 18) & 0x3FF));
    LODWORD(v52) = 10323 * v29 - (v51 + v54);
    v49[9] = *(unsigned char *)(v26 + ((v53 >> 18) & 0x3FF));
    int v55 = v29 - v31 - v45;
    v49[1] = *(unsigned char *)(v26 + (((unint64_t)(v52 + v43) >> 18) & 0x3FF));
    v49[8] = *(unsigned char *)(v26 + (((unint64_t)(v43 - v52) >> 18) & 0x3FF));
    v49[2] = *(unsigned char *)(v26 + (((unint64_t)(v37 + (v55 << 13)) >> 18) & 0x3FF));
    LODWORD(v53) = 5260 * v29 - v51 + v54;
    v49[7] = *(unsigned char *)(v26 + (((unint64_t)(v37 - (v55 << 13)) >> 18) & 0x3FF));
    v49[3] = *(unsigned char *)(v26 + (((unint64_t)(v53 + v46) >> 18) & 0x3FF));
    v49[6] = *(unsigned char *)(v26 + (((unint64_t)(v46 - v53) >> 18) & 0x3FF));
    v49[4] = *(unsigned char *)(v26 + (((unint64_t)(v50 + v28) >> 18) & 0x3FF));
    v49[5] = *(unsigned char *)(v26 + (((unint64_t)(v28 - v50) >> 18) & 0x3FF));
    v25 += 2;
  }
  while (v25 != 10);
  return result;
}

uint64_t jpeg_idct_8x4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 440);
  memset(v56, 0, sizeof(v56));
  uint64_t v7 = *(void *)(a2 + 88);
  do
  {
    unsigned int v8 = (_DWORD *)v56 + v5;
    uint64_t v9 = (_DWORD *)(v7 + 4 * v5);
    uint64_t v10 = (__int16 *)(a3 + 2 * v5);
    int v11 = *v9 * *v10;
    int v12 = v9[16] * v10[16];
    int v13 = v12 + v11;
    int v14 = 4 * (v12 + v11);
    int v15 = v11 - v12;
    uint64_t v16 = (int)v9[8] * (uint64_t)v10[8];
    uint64_t v17 = (int)v9[24] * (uint64_t)v10[24];
    uint64_t v18 = 4433 * (v16 + v17) + 1024;
    unint64_t v19 = (unint64_t)(v18 + 6270 * v16) >> 11;
    unint64_t v20 = (unint64_t)(v18 - 15137 * v17) >> 11;
    *unsigned int v8 = v19 + 4 * v13;
    v8[24] = v14 - v19;
    v8[8] = v20 + 4 * v15;
    v8[16] = 4 * v15 - v20;
    ++v5;
  }
  while (v5 != 8);
  uint64_t v21 = 0;
  uint64_t v22 = v6 - 384;
  uint64_t result = 4294959923;
  do
  {
    uint64_t v24 = &v56[v21];
    uint64_t v25 = (unsigned char *)(*(void *)(a4 + v21 * 4) + a5);
    int v26 = v24[1];
    int v27 = *v24 + 16400;
    int v28 = v24[4];
    int v29 = v24[5];
    int v30 = v27 + v28;
    int v31 = v27 - v28;
    int v32 = v24[6];
    int v33 = v24[7];
    int v34 = v30 << 13;
    int v35 = v24[2];
    LODWORD(v24) = v24[3];
    int v36 = 4433 * (v32 + v35);
    int v37 = v36 + 6270 * v35;
    int v38 = v36 - 15137 * v32;
    int v39 = v24 + v33;
    int v40 = 9633 * (v26 + v29 + v24 + v33);
    int v41 = v37 + (v30 << 13);
    int v42 = v40 - 3196 * (v26 + v29);
    int v43 = -7373 * (v26 + v33);
    int v44 = v43 + 12299 * v26 + v42;
    int v45 = v43 + 2446 * v33;
    int v46 = -20995 * (v24 + v29);
    int v47 = v46 + 16819 * v29;
    LODWORD(v24) = v46 + 25172 * v24;
    unint64_t v48 = (v44 + v41);
    int v49 = v40 - 16069 * v39;
    unint64_t v50 = (v41 - v44);
    int v51 = v31 << 13;
    *uint64_t v25 = *(unsigned char *)(v22 + ((v48 >> 18) & 0x3FF));
    int v52 = v38 + (v31 << 13);
    LODWORD(v24) = v24 + v49;
    int v53 = v51 - v38;
    v25[7] = *(unsigned char *)(v22 + ((v50 >> 18) & 0x3FF));
    int v54 = v47 + v42;
    v25[1] = *(unsigned char *)(v22 + (((unint64_t)(v24 + v52) >> 18) & 0x3FF));
    v25[6] = *(unsigned char *)(v22 + (((unint64_t)(v52 - v24) >> 18) & 0x3FF));
    int v55 = v45 + v49;
    _OWORD v25[2] = *(unsigned char *)(v22 + (((unint64_t)(v54 + v53) >> 18) & 0x3FF));
    v25[5] = *(unsigned char *)(v22 + (((unint64_t)(v53 - v54) >> 18) & 0x3FF));
    v25[3] = *(unsigned char *)(v22 + (((unint64_t)(v55 + v34 - v37) >> 18) & 0x3FF));
    v25[4] = *(unsigned char *)(v22 + (((unint64_t)(v34 - v37 - v55) >> 18) & 0x3FF));
    v21 += 2;
  }
  while (v21 != 8);
  return result;
}

uint64_t jpeg_idct_6x3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 440);
  uint64_t v35 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v7 = *(void *)(a2 + 88);
  do
  {
    unsigned int v8 = (_DWORD *)v34 + v5;
    uint64_t v9 = (_DWORD *)(v7 + 4 * v5);
    uint64_t v10 = (__int16 *)(a3 + 2 * v5);
    uint64_t v11 = ((uint64_t)(*v9 * *v10) << 13) | 0x400;
    uint64_t v12 = (int)v9[16] * (uint64_t)v10[16];
    uint64_t v13 = v11 + 5793 * v12;
    uint64_t v14 = 10033 * (int)v9[8] * (uint64_t)v10[8];
    *unsigned int v8 = (unint64_t)(v14 + v13) >> 11;
    v8[12] = (unint64_t)(v13 - v14) >> 11;
    v8[6] = (unint64_t)(v11 + 0x7FFFFFFD2BELL * v12) >> 11;
    ++v5;
  }
  while (v5 != 6);
  uint64_t v15 = 0;
  uint64_t v16 = v6 - 384;
  uint64_t v17 = a5;
  do
  {
    uint64_t v18 = *a4++;
    unint64_t v19 = (unsigned char *)(v18 + v17);
    int v20 = *(_DWORD *)((char *)v34 + v15 + 4);
    int v21 = *(_DWORD *)((char *)&v34[1] + v15);
    int v22 = *(_DWORD *)((char *)&v34[1] + v15 + 4);
    int v23 = (*(_DWORD *)((char *)v34 + v15) << 13) + 134348800;
    int v24 = v23 + 5793 * v21;
    int v25 = *(_DWORD *)((char *)v34 + v15 + 12);
    int v26 = 10033 * *(_DWORD *)((char *)v34 + v15 + 8);
    int v27 = 2998 * (v22 + v20);
    int v28 = v27 + ((v25 + v20) << 13);
    int v29 = v22 - v25;
    int v30 = v20 - (v25 + v22);
    int v31 = v23 - 11586 * v21;
    *unint64_t v19 = *(unsigned char *)(v16 + (((unint64_t)(v28 + v24 + v26) >> 18) & 0x3FF));
    int v32 = v27 + (v29 << 13);
    v19[5] = *(unsigned char *)(v16 + (((unint64_t)(v24 + v26 - v28) >> 18) & 0x3FF));
    v19[1] = *(unsigned char *)(v16 + (((unint64_t)(v31 + (v30 << 13)) >> 18) & 0x3FF));
    _OWORD v19[4] = *(unsigned char *)(v16 + (((unint64_t)(v31 - (v30 << 13)) >> 18) & 0x3FF));
    v19[2] = *(unsigned char *)(v16 + (((unint64_t)(v32 + v24 - v26) >> 18) & 0x3FF));
    uint64_t result = *(unsigned __int8 *)(v16 + (((unint64_t)(v24 - v26 - v32) >> 18) & 0x3FF));
    void v19[3] = result;
    v15 += 24;
  }
  while (v15 != 72);
  return result;
}

uint64_t jpeg_idct_4x2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 440);
  memset(v28, 0, sizeof(v28));
  uint64_t v7 = *(void *)(a2 + 88);
  do
  {
    unsigned int v8 = (void *)v28 + v5;
    uint64_t v9 = (int *)(v7 + 4 * v5);
    uint64_t v10 = (__int16 *)(a3 + 2 * v5);
    uint64_t v11 = *v9 * (uint64_t)*v10;
    LODWORD(v10) = v10[8];
    LODWORD(v9) = v9[8];
    *unsigned int v8 = v11 + (int)v9 * (uint64_t)(int)v10;
    _OWORD v8[4] = v11 - (int)v9 * (uint64_t)(int)v10;
    ++v5;
  }
  while (v5 != 4);
  uint64_t v12 = 0;
  uint64_t v13 = v6 - 384;
  uint64_t v14 = v28;
  uint64_t v15 = 1;
  uint64_t v16 = a5;
  do
  {
    uint64_t v17 = (unsigned char *)(*(void *)(a4 + 8 * v12) + v16);
    int v18 = *v14 + 4100;
    int v19 = v14[4];
    int v20 = v14[2];
    int v21 = v14[6];
    int v22 = 4433 * (v21 + v20);
    int v23 = v22 + 6270 * v20;
    int v24 = v22 - 15137 * v21;
    unsigned char *v17 = *(unsigned char *)(v13 + (((unint64_t)(v23 + ((v18 + v19) << 13)) >> 16) & 0x3FF));
    unint64_t v25 = ((unint64_t)(((v18 + v19) << 13) - v23) >> 16) & 0x3FF;
    int v26 = v18 - v19;
    void v17[3] = *(unsigned char *)(v13 + v25);
    v17[1] = *(unsigned char *)(v13 + (((unint64_t)(v24 + (v26 << 13)) >> 16) & 0x3FF));
    uint64_t result = v15;
    _OWORD v17[2] = *(unsigned char *)(v13 + (((unint64_t)((v26 << 13) - v24) >> 16) & 0x3FF));
    v14 += 8;
    uint64_t v12 = 1;
    uint64_t v15 = 0;
  }
  while ((result & 1) != 0);
  return result;
}

uint64_t jpeg_idct_2x1(uint64_t result, uint64_t a2, unsigned __int16 *a3, void *a4, unsigned int a5)
{
  uint64_t v5 = *(void *)(result + 440) - 384;
  uint64_t v6 = *(_DWORD **)(a2 + 88);
  uint64_t v7 = (unsigned char *)(*a4 + a5);
  int v8 = *v6 * *a3 + 4100;
  LODWORD(v6) = v6[1] * a3[1];
  unsigned char *v7 = *(unsigned char *)(v5 + (((unint64_t)(v6 + v8) >> 3) & 0x3FF));
  v7[1] = *(unsigned char *)(v5 + (((unint64_t)(v8 - v6) >> 3) & 0x3FF));
  return result;
}

uint64_t jpeg_idct_8x16(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  uint64_t v94 = *(void *)(a1 + 440);
  memset(v100, 0, sizeof(v100));
  uint64_t v97 = *(void *)(a2 + 88);
  do
  {
    uint64_t v6 = (_DWORD *)(v97 + 4 * v5);
    uint64_t v7 = (__int16 *)(a3 + 2 * v5);
    uint64_t v8 = (int)v6[32] * (uint64_t)v7[32];
    uint64_t v9 = 10703 * v8;
    uint64_t v10 = ((uint64_t)(*v6 * *v7) << 13) | 0x400;
    v8 *= 4433;
    uint64_t v11 = v9 + v10;
    uint64_t v12 = v10 - v9;
    uint64_t v13 = v8 + v10;
    uint64_t v14 = v10 - v8;
    uint64_t v15 = (int)v6[16] * (uint64_t)v7[16];
    uint64_t v16 = (int)v6[48] * (uint64_t)v7[48];
    uint64_t v17 = 2260 * (v15 - v16);
    uint64_t v18 = 11363 * (v15 - v16);
    uint64_t v19 = v18 + 20995 * v16;
    uint64_t v20 = v17 + 7373 * v15;
    uint64_t v21 = v18 - 4926 * v15;
    uint64_t v22 = v17 - 4176 * v16;
    uint64_t v23 = v19 + v11;
    uint64_t v99 = v11 - v19;
    uint64_t v24 = v20 + v13;
    uint64_t v25 = v13 - v20;
    uint64_t v26 = v21 + v14;
    uint64_t v27 = v14 - v21;
    uint64_t v28 = v22 + v12;
    uint64_t v29 = v12 - v22;
    uint64_t v30 = (int)v6[8] * (uint64_t)v7[8];
    uint64_t v31 = (int)v6[24] * (uint64_t)v7[24];
    LODWORD(v22) = v7[40];
    int v32 = v6[40];
    int v33 = v7[56];
    int v34 = v6[56];
    uint64_t v35 = v30 + v32 * (uint64_t)v7[40];
    uint64_t v36 = 11086 * (v30 + v31);
    uint64_t v37 = 10217 * v35;
    uint64_t v38 = 8956 * (v30 + v34 * (uint64_t)v33);
    uint64_t v39 = 7350 * (v30 - v34 * (uint64_t)v33);
    uint64_t v40 = 5461 * v35;
    uint64_t v41 = 3363 * (v30 - v31);
    uint64_t v42 = v36 - 18730 * v30 + 10217 * v35 + v38;
    uint64_t v43 = v41 - 15038 * v30 + 5461 * v35 + v39;
    uint64_t v44 = 1136 * (v31 + v32 * (uint64_t)(int)v22);
    uint64_t v45 = v31 + v34 * (uint64_t)v33;
    uint64_t v46 = -5461 * v45;
    uint64_t v47 = v36 + 589 * v31 + v44 - 5461 * v45;
    uint64_t v48 = v32 * (uint64_t)(int)v22;
    uint64_t v49 = 11529 * (v48 - v31);
    v45 *= -10217;
    uint64_t v50 = v41 + 16154 * v31 + v49 + v45;
    uint64_t v51 = v44 - 9222 * v48 + v37 - 11086 * (v48 + v34 * (uint64_t)v33);
    uint64_t v52 = v38 - 11086 * (v48 + v34 * (uint64_t)v33);
    uint64_t v53 = v34 * (uint64_t)v33;
    uint64_t v54 = v46 + 8728 * v53 + v52;
    uint64_t v55 = 3363 * (v53 - v48);
    uint64_t v56 = v45 + 25733 * v53 + v39 + v55;
    uint64_t v57 = (_DWORD *)v100 + v5;
    uint64_t v58 = v49 - 6278 * v48 + v40 + v55;
    *uint64_t v57 = (unint64_t)(v42 + v23) >> 11;
    v57[120] = (unint64_t)(v23 - v42) >> 11;
    v57[8] = (unint64_t)(v47 + v24) >> 11;
    v57[112] = (unint64_t)(v24 - v47) >> 11;
    v57[16] = (unint64_t)(v51 + v26) >> 11;
    v57[104] = (unint64_t)(v26 - v51) >> 11;
    v57[24] = (unint64_t)(v54 + v28) >> 11;
    v57[96] = (unint64_t)(v28 - v54) >> 11;
    v57[32] = (unint64_t)(v56 + v29) >> 11;
    v57[88] = (unint64_t)(v29 - v56) >> 11;
    v57[40] = (unint64_t)(v58 + v27) >> 11;
    v57[80] = (unint64_t)(v27 - v58) >> 11;
    v57[48] = (unint64_t)(v50 + v25) >> 11;
    v57[72] = (unint64_t)(v25 - v50) >> 11;
    v57[56] = (unint64_t)(v43 + v99) >> 11;
    v57[64] = (unint64_t)(v99 - v43) >> 11;
    ++v5;
  }
  while (v5 != 8);
  uint64_t v59 = 0;
  uint64_t v60 = v94 - 384;
  uint64_t result = 4294959923;
  do
  {
    int v62 = &v100[v59];
    int v63 = (unsigned char *)(*(void *)(a4 + v59 * 4) + a5);
    int v64 = v62[1];
    int v65 = *v62 + 16400;
    int v66 = v62[4];
    int v67 = v62[5];
    int v68 = v65 + v66;
    int v69 = v65 - v66;
    int v70 = v62[6];
    int v71 = v62[7];
    int v72 = v68 << 13;
    int v73 = v62[2];
    LODWORD(v62) = v62[3];
    int v74 = 4433 * (v70 + v73);
    int v75 = v74 + 6270 * v73;
    int v76 = v74 - 15137 * v70;
    int v77 = v62 + v71;
    int v78 = 9633 * (v64 + v67 + v62 + v71);
    int v79 = v75 + (v68 << 13);
    int v80 = v78 - 3196 * (v64 + v67);
    int v81 = -7373 * (v64 + v71);
    int v82 = v81 + 12299 * v64 + v80;
    int v83 = v81 + 2446 * v71;
    int v84 = -20995 * (v62 + v67);
    int v85 = v84 + 16819 * v67;
    LODWORD(v62) = v84 + 25172 * v62;
    unint64_t v86 = (v82 + v79);
    int v87 = v78 - 16069 * v77;
    unint64_t v88 = (v79 - v82);
    int v89 = v69 << 13;
    unsigned char *v63 = *(unsigned char *)(v60 + ((v86 >> 18) & 0x3FF));
    int v90 = v76 + (v69 << 13);
    LODWORD(v62) = v62 + v87;
    int v91 = v89 - v76;
    v63[7] = *(unsigned char *)(v60 + ((v88 >> 18) & 0x3FF));
    int v92 = v85 + v80;
    v63[1] = *(unsigned char *)(v60 + (((unint64_t)(v62 + v90) >> 18) & 0x3FF));
    v63[6] = *(unsigned char *)(v60 + (((unint64_t)(v90 - v62) >> 18) & 0x3FF));
    int v93 = v83 + v87;
    v63[2] = *(unsigned char *)(v60 + (((unint64_t)(v92 + v91) >> 18) & 0x3FF));
    v63[5] = *(unsigned char *)(v60 + (((unint64_t)(v91 - v92) >> 18) & 0x3FF));
    v63[3] = *(unsigned char *)(v60 + (((unint64_t)(v93 + v72 - v75) >> 18) & 0x3FF));
    v63[4] = *(unsigned char *)(v60 + (((unint64_t)(v72 - v75 - v93) >> 18) & 0x3FF));
    v59 += 2;
  }
  while (v59 != 32);
  return result;
}

uint64_t jpeg_idct_7x14(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  uint64_t v79 = *(void *)(a1 + 440);
  uint64_t v82 = 0;
  memset(v81, 0, sizeof(v81));
  uint64_t v6 = *(void *)(a2 + 88);
  do
  {
    uint64_t v7 = (_DWORD *)(v6 + 4 * v5);
    uint64_t v8 = (__int16 *)(a3 + 2 * v5);
    uint64_t v9 = (int)v7[32] * (uint64_t)v8[32];
    uint64_t v10 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    uint64_t v11 = v10 + 10438 * v9;
    uint64_t v12 = v10 + 2578 * v9;
    uint64_t v13 = v10 - 7223 * v9;
    uint64_t v14 = (int)v7[16] * (uint64_t)v8[16];
    uint64_t v15 = (int)v7[48] * (uint64_t)v8[48];
    uint64_t v16 = 9058 * (v14 + v15);
    uint64_t v17 = v16 + 2237 * v14;
    uint64_t v18 = v16 - 14084 * v15;
    uint64_t v19 = 5027 * v14 - 11295 * v15;
    uint64_t v20 = v17 + v11;
    uint64_t v21 = v11 - v17;
    uint64_t v22 = v18 + v12;
    uint64_t v23 = v12 - v18;
    uint64_t v24 = v19 + v13;
    uint64_t v25 = v13 - v19;
    uint64_t v26 = (int)v7[8] * (uint64_t)v8[8];
    uint64_t v27 = (int)v7[24] * (uint64_t)v8[24];
    uint64_t v28 = (int)v7[40] * (uint64_t)v8[40];
    uint64_t v29 = (int)v7[56] * (uint64_t)v8[56];
    uint64_t v30 = 10935 * (v26 + v27);
    uint64_t v31 = 9810 * (v26 + v28);
    uint64_t v32 = v30 - 9232 * v26 + v31;
    uint64_t v33 = -1297 * (v27 + v28) - (v29 << 13);
    uint64_t v34 = v30 - 3474 * v27 + v33;
    uint64_t v35 = v31 - 19447 * v28 + v33;
    uint64_t v36 = 6164 * (v26 + v28);
    uint64_t v37 = v26 - v27;
    uint64_t v38 = 11512 * (v28 - v27);
    uint64_t v39 = v38 - 13850 * v28 + v36;
    uint64_t v40 = v36 - 8693 * v26;
    uint64_t v41 = v38 + 5529 * v27;
    uint64_t v42 = 3826 * v37 - (v29 << 13);
    uint64_t v43 = v40 + v42;
    uint64_t v44 = v41 + v42;
    uint64_t v45 = (_DWORD *)v81 + v5;
    uint64_t v46 = v32 + (v29 << 13);
    uint64_t v47 = v39 + (v29 << 13);
    LODWORD(v29) = v37 - v28 + v29;
    *uint64_t v45 = (unint64_t)(v46 + v20) >> 11;
    v45[91] = (unint64_t)(v20 - v46) >> 11;
    v45[7] = (unint64_t)(v34 + v22) >> 11;
    v45[84] = (unint64_t)(v22 - v34) >> 11;
    v45[14] = (unint64_t)(v35 + v24) >> 11;
    unint64_t v48 = (unint64_t)(v10 - 11586 * v9) >> 11;
    v45[77] = (unint64_t)(v24 - v35) >> 11;
    v45[21] = v48 + 4 * v29;
    v45[70] = v48 - 4 * v29;
    v45[28] = (unint64_t)(v47 + v25) >> 11;
    v45[63] = (unint64_t)(v25 - v47) >> 11;
    v45[35] = (unint64_t)(v44 + v23) >> 11;
    v45[56] = (unint64_t)(v23 - v44) >> 11;
    v45[42] = (unint64_t)(v43 + v21) >> 11;
    v45[49] = (unint64_t)(v21 - v43) >> 11;
    ++v5;
  }
  while (v5 != 7);
  uint64_t v49 = 0;
  uint64_t v50 = v79 - 384;
  uint64_t result = 11585;
  do
  {
    uint64_t v52 = *a4++;
    int v53 = *(_DWORD *)((char *)v81 + v49 + 4);
    int v54 = (*(_DWORD *)((char *)v81 + v49) << 13) + 134348800;
    int v56 = *(_DWORD *)((char *)&v81[1] + v49 + 4);
    int v55 = *(_DWORD *)((char *)&v81[1] + v49 + 8);
    int v57 = *(_DWORD *)((char *)&v81[1] + v49);
    int v58 = 7223 * (v57 - v55);
    int v60 = *(_DWORD *)((char *)v81 + v49 + 8);
    int v59 = *(_DWORD *)((char *)v81 + v49 + 12);
    int v61 = 2578 * (v60 - v57);
    int v62 = v61 + v58;
    int v63 = v55 + v60;
    int v64 = v58 - 637 * v55;
    int v65 = 7663 * (v59 + v53);
    int v66 = v61 - 20239 * v60;
    int v67 = 1395 * (v53 - v59);
    int v68 = v65 - v67;
    int v69 = v65 + v67;
    int v70 = v54 + 10438 * v63;
    int v71 = v64 + v70;
    int v72 = 5027 * (v56 + v53);
    int v73 = v68 + v72;
    int v74 = v54 - 15083 * v57 + v62;
    int v75 = (unsigned char *)(v52 + a5);
    unsigned char *v75 = *(unsigned char *)(v50 + (((unint64_t)(v73 + v71) >> 18) & 0x3FF));
    int v76 = -11295 * (v56 + v59);
    int v77 = v69 + v76;
    v75[6] = *(unsigned char *)(v50 + (((unint64_t)(v71 - v73) >> 18) & 0x3FF));
    int v78 = v72 + 15326 * v56 + v76;
    v75[1] = *(unsigned char *)(v50 + (((unint64_t)(v77 + v74) >> 18) & 0x3FF));
    v75[5] = *(unsigned char *)(v50 + (((unint64_t)(v74 - v77) >> 18) & 0x3FF));
    v75[2] = *(unsigned char *)(v50 + (((unint64_t)(v78 + v66 + v70) >> 18) & 0x3FF));
    v75[4] = *(unsigned char *)(v50 + (((unint64_t)(v66 + v70 - v78) >> 18) & 0x3FF));
    v75[3] = *(unsigned char *)(v50 + (((unint64_t)(v54 + 11585 * (v57 - v63)) >> 18) & 0x3FF));
    v49 += 28;
  }
  while (v49 != 392);
  return result;
}

uint64_t jpeg_idct_6x12(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  uint64_t v61 = *(void *)(a1 + 440);
  memset(v63, 0, sizeof(v63));
  uint64_t v6 = *(void *)(a2 + 88);
  do
  {
    uint64_t v7 = (_DWORD *)(v6 + 4 * v5);
    uint64_t v8 = (__int16 *)(a3 + 2 * v5);
    uint64_t v9 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    uint64_t v10 = 10033 * (int)v7[32] * (uint64_t)v8[32];
    uint64_t v11 = v10 + v9;
    uint64_t v12 = v9 - v10;
    uint64_t v13 = (int)v7[16] * (uint64_t)v8[16];
    uint64_t v14 = (int)v7[48] * (uint64_t)v8[48];
    uint64_t v15 = v9 + ((v13 - v14) << 13);
    uint64_t v16 = v9 - ((v13 - v14) << 13);
    uint64_t v17 = 11190 * v13 + (v14 << 13);
    uint64_t v18 = v17 + v11;
    uint64_t v19 = v11 - v17;
    uint64_t v20 = 2998 * v13 - (v14 << 13);
    uint64_t v21 = v20 + v12;
    uint64_t v22 = v12 - v20;
    uint64_t v23 = (int)v7[8] * (uint64_t)v8[8];
    uint64_t v24 = (int)v7[24] * (uint64_t)v8[24];
    uint64_t v25 = (int)v7[40] * (uint64_t)v8[40];
    LODWORD(v8) = v8[56];
    LODWORD(v7) = v7[56];
    uint64_t v26 = 10703 * v24;
    uint64_t v27 = -4433 * v24;
    uint64_t v28 = 7053 * (v23 + v25 + (int)v7 * (uint64_t)(int)v8);
    uint64_t v29 = v28 + 2139 * (v23 + v25);
    uint64_t v30 = v24 - v25;
    uint64_t v31 = v26 + 2295 * v23 + v29;
    uint64_t v32 = -8565 * (v25 + (int)v7 * (uint64_t)(int)v8);
    uint64_t v33 = v27 - 12112 * v25 - 8565 * (v25 + (int)v7 * (uint64_t)(int)v8) + v29;
    uint64_t v34 = (int)v7 * (uint64_t)(int)v8;
    uint64_t v35 = 12998 * v34 - v26 + v32;
    uint64_t v36 = v23 - v34;
    uint64_t v37 = (_DWORD *)v63 + v5;
    uint64_t v38 = v35 + v28;
    uint64_t v39 = v27 - 5540 * v23 - 16244 * v34 + v28;
    uint64_t v40 = 4433 * (v36 + v30);
    uint64_t v41 = v40 + 6270 * v36;
    uint64_t v42 = v40 - 15137 * v30;
    *uint64_t v37 = (unint64_t)(v31 + v18) >> 11;
    v37[66] = (unint64_t)(v18 - v31) >> 11;
    v37[6] = (unint64_t)(v41 + v15) >> 11;
    v37[60] = (unint64_t)(v15 - v41) >> 11;
    v37[12] = (unint64_t)(v33 + v21) >> 11;
    v37[54] = (unint64_t)(v21 - v33) >> 11;
    v37[18] = (unint64_t)(v38 + v22) >> 11;
    v37[48] = (unint64_t)(v22 - v38) >> 11;
    v37[24] = (unint64_t)(v42 + v16) >> 11;
    v37[42] = (unint64_t)(v16 - v42) >> 11;
    v37[30] = (unint64_t)(v39 + v19) >> 11;
    v37[36] = (unint64_t)(v19 - v39) >> 11;
    ++v5;
  }
  while (v5 != 6);
  uint64_t v43 = 0;
  uint64_t v44 = v61 - 384;
  do
  {
    uint64_t v45 = *a4++;
    uint64_t v46 = (unsigned char *)(v45 + a5);
    int v47 = *(_DWORD *)((char *)v63 + v43 + 4);
    int v48 = *(_DWORD *)((char *)&v63[1] + v43);
    int v49 = *(_DWORD *)((char *)&v63[1] + v43 + 4);
    int v50 = (*(_DWORD *)((char *)v63 + v43) << 13) + 134348800;
    int v51 = v50 + 5793 * v48;
    int v52 = *(_DWORD *)((char *)v63 + v43 + 12);
    int v53 = 10033 * *(_DWORD *)((char *)v63 + v43 + 8);
    int v54 = 2998 * (v49 + v47);
    int v55 = v54 + ((v52 + v47) << 13);
    int v56 = v49 - v52;
    int v57 = v47 - (v52 + v49);
    int v58 = v50 - 11586 * v48;
    unsigned char *v46 = *(unsigned char *)(v44 + (((unint64_t)(v55 + v51 + v53) >> 18) & 0x3FF));
    int v59 = v54 + (v56 << 13);
    v46[5] = *(unsigned char *)(v44 + (((unint64_t)(v51 + v53 - v55) >> 18) & 0x3FF));
    v46[1] = *(unsigned char *)(v44 + (((unint64_t)(v58 + (v57 << 13)) >> 18) & 0x3FF));
    v46[4] = *(unsigned char *)(v44 + (((unint64_t)(v58 - (v57 << 13)) >> 18) & 0x3FF));
    v46[2] = *(unsigned char *)(v44 + (((unint64_t)(v59 + v51 - v53) >> 18) & 0x3FF));
    uint64_t result = *(unsigned __int8 *)(v44 + (((unint64_t)(v51 - v53 - v59) >> 18) & 0x3FF));
    v46[3] = result;
    v43 += 24;
  }
  while (v43 != 288);
  return result;
}

uint64_t jpeg_idct_5x10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v55 = *(void *)(a1 + 440);
  uint64_t v58 = 0;
  memset(v57, 0, sizeof(v57));
  uint64_t v6 = *(void *)(a2 + 88);
  do
  {
    uint64_t v7 = (_DWORD *)(v6 + 4 * v5);
    uint64_t v8 = (__int16 *)(a3 + 2 * v5);
    uint64_t v9 = ((uint64_t)(*v7 * *v8) << 13) | 0x400;
    uint64_t v10 = (int)v7[32] * (uint64_t)v8[32];
    uint64_t v11 = v9 + 9373 * v10;
    uint64_t v12 = v9 - 3580 * v10;
    unint64_t v13 = v9 - 11586 * v10;
    uint64_t v14 = (int)v7[16] * (uint64_t)v8[16];
    uint64_t v15 = (int)v7[48] * (uint64_t)v8[48];
    uint64_t v16 = 6810 * (v14 + v15);
    uint64_t v17 = v16 + 4209 * v14;
    uint64_t v18 = v16 - 17828 * v15;
    uint64_t v19 = v17 + v11;
    uint64_t v20 = v11 - v17;
    uint64_t v21 = v18 + v12;
    uint64_t v22 = v12 - v18;
    uint64_t v23 = (int)v7[8] * (uint64_t)v8[8];
    uint64_t v24 = (int)v7[24] * (uint64_t)v8[24];
    uint64_t v25 = (int)v7[40] * (uint64_t)v8[40];
    LODWORD(v8) = v8[56];
    LODWORD(v7) = v7[56];
    uint64_t v26 = v24 + (int)v7 * (uint64_t)(int)v8;
    uint64_t v27 = v24 - (int)v7 * (uint64_t)(int)v8;
    uint64_t v28 = 2531 * v27 + (v25 << 13);
    uint64_t v29 = 7791 * v26 + 11443 * v23 + v28;
    uint64_t v30 = 1812 * v23 - 7791 * v26 + v28;
    uint64_t v31 = 4815 * v26;
    uint64_t v32 = -6627 * v27 + (v25 << 13);
    LODWORD(v27) = v23 - v25 - v27;
    uint64_t v33 = 10323 * v23 - (v31 + v32);
    uint64_t v34 = 5260 * v23 - v31;
    uint64_t v35 = (_DWORD *)v57 + v5;
    uint64_t v36 = v34 + v32;
    *uint64_t v35 = (unint64_t)(v29 + v19) >> 11;
    v35[45] = (unint64_t)(v19 - v29) >> 11;
    v35[5] = (unint64_t)(v33 + v21) >> 11;
    v35[40] = (unint64_t)(v21 - v33) >> 11;
    v35[10] = (v13 >> 11) + 4 * v27;
    v35[35] = (v13 >> 11) - 4 * v27;
    v35[15] = (unint64_t)(v36 + v22) >> 11;
    v35[30] = (unint64_t)(v22 - v36) >> 11;
    v35[20] = (unint64_t)(v30 + v20) >> 11;
    v35[25] = (unint64_t)(v20 - v30) >> 11;
    ++v5;
  }
  while (v5 != 5);
  uint64_t v37 = 0;
  uint64_t v38 = v55 - 384;
  uint64_t result = a5;
  do
  {
    uint64_t v40 = *a4++;
    int v41 = *(_DWORD *)((char *)v57 + v37 + 4);
    uint64_t v42 = (unsigned char *)(v40 + a5);
    int v43 = (*(_DWORD *)((char *)v57 + v37) << 13) + 134348800;
    int v44 = *(_DWORD *)((char *)v57 + v37 + 8);
    int v45 = *(_DWORD *)((char *)v57 + v37 + 12);
    int v46 = *(_DWORD *)((char *)&v57[1] + v37);
    int v47 = 6476 * (v46 + v44);
    int v48 = v44 - v46;
    int v49 = v43 + 2896 * v48;
    int v50 = 6810 * (v45 + v41);
    int v51 = v49 + v47;
    int v52 = v50 + 4209 * v41;
    int v53 = v50 - 17828 * v45;
    *uint64_t v42 = *(unsigned char *)(v38 + (((unint64_t)(v52 + v49 + v47) >> 18) & 0x3FF));
    int v54 = v49 - v47;
    v42[4] = *(unsigned char *)(v38 + (((unint64_t)(v51 - v52) >> 18) & 0x3FF));
    v42[1] = *(unsigned char *)(v38 + (((unint64_t)(v53 + v54) >> 18) & 0x3FF));
    v42[3] = *(unsigned char *)(v38 + (((unint64_t)(v54 - v53) >> 18) & 0x3FF));
    v42[2] = *(unsigned char *)(v38 + (((unint64_t)(v43 + 268423872 * v48) >> 18) & 0x3FF));
    v37 += 20;
  }
  while (v37 != 200);
  return result;
}

uint64_t jpeg_idct_4x8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  uint64_t v58 = *(void *)(a1 + 440);
  uint64_t v6 = (__int16 *)(a3 + 64);
  uint64_t v7 = *(void *)(a2 + 88) + 128;
  unsigned int v8 = 5;
  memset(v60, 0, sizeof(v60));
  do
  {
    uint64_t v9 = (_DWORD *)(v7 + v5);
    unsigned __int16 v10 = *(v6 - 16);
    if ((unsigned __int16)*(v6 - 24) | v10) {
      goto LABEL_9;
    }
    if (*(v6 - 8) || *v6 || v6[8] || v6[16] || v6[24])
    {
      unsigned __int16 v10 = 0;
LABEL_9:
      uint64_t v11 = *v9 * *v6;
      uint64_t v12 = ((uint64_t)(*(v9 - 32) * *(v6 - 32)) << 13) | 0x400;
      uint64_t v13 = v12 + (v11 << 13);
      uint64_t v14 = v12 - (v11 << 13);
      uint64_t v15 = (int)*(v9 - 16) * (uint64_t)(__int16)v10;
      uint64_t v16 = (int)v9[16] * (uint64_t)v6[16];
      uint64_t v17 = 4433 * (v15 + v16);
      uint64_t v18 = v17 + 6270 * v15;
      uint64_t v19 = v17 - 15137 * v16;
      uint64_t v20 = v18 + v13;
      uint64_t v21 = v13 - v18;
      uint64_t v22 = v19 + v14;
      uint64_t v23 = v14 - v19;
      uint64_t v24 = (int)v9[24] * (uint64_t)v6[24];
      uint64_t v25 = (int)v9[8] * (uint64_t)v6[8];
      int v26 = *(v9 - 8);
      uint64_t v27 = (int)*(v9 - 24) * (uint64_t)*(v6 - 24);
      uint64_t v28 = v24 + v26 * (uint64_t)*(v6 - 8);
      uint64_t v29 = 9633 * (v25 + v27 + v28);
      uint64_t v30 = v29 - 16069 * v28;
      uint64_t v31 = v29 - 3196 * (v25 + v27);
      uint64_t v32 = -7373 * (v24 + v27);
      uint64_t v33 = v32 + 2446 * v24 + v30;
      uint64_t v34 = v32 + 12299 * v27 + v31;
      uint64_t v35 = -20995 * (v25 + v26 * (uint64_t)*(v6 - 8));
      uint64_t v36 = v35 + 16819 * v25 + v31;
      uint64_t v37 = v35 + 25172 * v26 * (uint64_t)*(v6 - 8) + v30;
      uint64_t v38 = (_DWORD *)((char *)v60 + v5);
      *uint64_t v38 = (unint64_t)(v34 + v20) >> 11;
      v38[28] = (unint64_t)(v20 - v34) >> 11;
      _OWORD v38[4] = (unint64_t)(v37 + v22) >> 11;
      v38[24] = (unint64_t)(v22 - v37) >> 11;
      v38[8] = (unint64_t)(v36 + v23) >> 11;
      v38[20] = (unint64_t)(v23 - v36) >> 11;
      v38[12] = (unint64_t)(v33 + v21) >> 11;
      unint64_t v39 = (unint64_t)(v21 - v33) >> 11;
      uint64_t v40 = 4;
      goto LABEL_10;
    }
    LODWORD(v39) = 4 * *(v6 - 32) * *(v9 - 32);
    int v41 = (_DWORD *)((char *)v60 + v5);
    *int v41 = v39;
    v41[4] = v39;
    v41[8] = v39;
    v41[12] = v39;
    v41[16] = v39;
    v41[20] = v39;
    v41[24] = v39;
    uint64_t v40 = 7;
LABEL_10:
    *(_DWORD *)((char *)&v60[v40] + v5) = v39;
    --v8;
    v5 += 4;
    ++v6;
  }
  while (v8 > 1);
  uint64_t v42 = 0;
  uint64_t v43 = v58 - 384;
  do
  {
    uint64_t v44 = *a4++;
    int v45 = (unsigned char *)(v44 + a5);
    int v46 = DWORD1(v60[v42]);
    int v47 = DWORD2(v60[v42]);
    int v48 = HIDWORD(v60[v42]);
    int v49 = LODWORD(v60[v42]) + 16400;
    int v50 = v49 + v47;
    int v51 = (v49 + v47) << 13;
    int v52 = v49 - v47;
    int v53 = 4433 * (v48 + v46);
    int v54 = v52 << 13;
    int v55 = v53 + 6270 * v46;
    int v56 = v53 - 15137 * v48;
    *int v45 = *(unsigned char *)(v43 + (((unint64_t)(v55 + (v50 << 13)) >> 18) & 0x3FF));
    v45[3] = *(unsigned char *)(v43 + (((unint64_t)(v51 - v55) >> 18) & 0x3FF));
    uint64_t result = *(unsigned __int8 *)(v43 + (((unint64_t)(v56 + (v52 << 13)) >> 18) & 0x3FF));
    v45[1] = result;
    v45[2] = *(unsigned char *)(v43 + (((unint64_t)(v54 - v56) >> 18) & 0x3FF));
    ++v42;
  }
  while (v42 != 8);
  return result;
}

uint64_t jpeg_idct_3x6(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v5 = 0;
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 440);
  uint64_t v35 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v7 = *(void *)(a2 + 88);
  do
  {
    unsigned int v8 = (_DWORD *)v34 + v5;
    uint64_t v9 = (_DWORD *)(v7 + 4 * v5);
    unsigned __int16 v10 = (__int16 *)(a3 + 2 * v5);
    uint64_t v11 = ((uint64_t)(*v9 * *v10) << 13) | 0x400;
    uint64_t v12 = (int)v9[32] * (uint64_t)v10[32];
    uint64_t v13 = v11 + 5793 * v12;
    unint64_t v14 = (unint64_t)(v11 - 11586 * v12) >> 11;
    uint64_t v15 = 10033 * (int)v9[16] * (uint64_t)v10[16];
    uint64_t v16 = v15 + v13;
    uint64_t v17 = v13 - v15;
    uint64_t v18 = (int)v9[8] * (uint64_t)v10[8];
    uint64_t v19 = (int)v9[24] * (uint64_t)v10[24];
    uint64_t v20 = (int)v9[40] * (uint64_t)v10[40];
    uint64_t v21 = 2998 * (v18 + v20);
    uint64_t v22 = v21 + ((v18 + v19) << 13);
    uint64_t v23 = v21 + ((v20 - v19) << 13);
    LODWORD(v18) = v18 - (v19 + v20);
    *unsigned int v8 = (unint64_t)(v22 + v16) >> 11;
    v8[15] = (unint64_t)(v16 - v22) >> 11;
    _OWORD v8[3] = v14 + 4 * v18;
    v8[12] = v14 - 4 * v18;
    v8[6] = (unint64_t)(v23 + v17) >> 11;
    v8[9] = (unint64_t)(v17 - v23) >> 11;
    ++v5;
  }
  while (v5 != 3);
  uint64_t v24 = 0;
  uint64_t v25 = v6 - 384;
  do
  {
    uint64_t v26 = *a4++;
    uint64_t v27 = (unsigned char *)(v26 + a5);
    int v28 = (*(_DWORD *)((char *)v34 + v24) << 13) + 134348800;
    int v29 = *(_DWORD *)((char *)v34 + v24 + 8);
    int v30 = v28 + 5793 * v29;
    unint64_t v31 = (v28 + 268423870 * v29);
    int v32 = 10033 * *(_DWORD *)((char *)v34 + v24 + 4);
    unsigned char *v27 = *(unsigned char *)(v25 + (((unint64_t)(v30 + v32) >> 18) & 0x3FF));
    uint64_t result = *(unsigned __int8 *)(v25 + (((unint64_t)(v30 - v32) >> 18) & 0x3FF));
    v27[2] = result;
    v27[1] = *(unsigned char *)(v25 + ((v31 >> 18) & 0x3FF));
    v24 += 12;
  }
  while (v24 != 72);
  return result;
}

uint64_t jpeg_idct_2x4(uint64_t a1, uint64_t a2, __int16 *a3, uint64_t *a4, unsigned int a5)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)(a1 + 440);
  memset(v26, 0, sizeof(v26));
  uint64_t v6 = v26;
  uint64_t v7 = *(int **)(a2 + 88);
  char v8 = 1;
  do
  {
    char v9 = v8;
    uint64_t v10 = *v7 * (uint64_t)*a3;
    int v11 = v7[16];
    uint64_t v12 = (v10 + v11 * (uint64_t)a3[16]) << 13;
    uint64_t v13 = v10 - v11 * (uint64_t)a3[16];
    uint64_t v14 = v7[8] * (uint64_t)a3[8];
    uint64_t v15 = v7[24] * (uint64_t)a3[24];
    uint64_t v16 = 4433 * (v14 + v15);
    uint64_t v17 = v16 + 6270 * v14;
    uint64_t v18 = v16 - 15137 * v15;
    uint64_t result = v17 + v12;
    *uint64_t v6 = v17 + v12;
    v6[6] = v12 - v17;
    v6[2] = v18 + (v13 << 13);
    v6[4] = (v13 << 13) - v18;
    ++a3;
    ++v7;
    ++v6;
    char v8 = 0;
  }
  while ((v9 & 1) != 0);
  uint64_t v20 = 0;
  uint64_t v21 = v5 - 384;
  do
  {
    uint64_t v22 = *a4++;
    uint64_t v23 = (unsigned char *)(v22 + a5);
    int v24 = LODWORD(v26[v20]) + 33587200;
    int v25 = DWORD2(v26[v20]);
    unsigned char *v23 = *(unsigned char *)(v21 + (((unint64_t)(v24 + v25) >> 16) & 0x3FF));
    v23[1] = *(unsigned char *)(v21 + (((unint64_t)(v24 - v25) >> 16) & 0x3FF));
    ++v20;
  }
  while (v20 != 4);
  return result;
}

uint64_t jpeg_idct_1x2(uint64_t result, uint64_t a2, unsigned __int16 *a3, void *a4, unsigned int a5)
{
  uint64_t v5 = *(void *)(result + 440) - 384;
  uint64_t v6 = *(_DWORD **)(a2 + 88);
  int v7 = *v6 * *a3 + 4100;
  LODWORD(v6) = v6[8] * a3[8];
  *(unsigned char *)(*a4 + a5) = *(unsigned char *)(v5 + (((unint64_t)(v6 + v7) >> 3) & 0x3FF));
  *(unsigned char *)(a4[1] + a5) = *(unsigned char *)(v5 + (((unint64_t)(v7 - v6) >> 3) & 0x3FF));
  return result;
}

double _cg_jpeg_CreateCompress(char *a1, int a2, uint64_t a3)
{
  *((void *)a1 + 1) = 0;
  if (a2 != 90)
  {
    uint64_t v5 = *(void *)a1;
    *(_DWORD *)(v5 + 40) = 13;
    *(_DWORD *)(v5 + 48) = 90;
    *(_DWORD *)(*(void *)a1 + 52) = a2;
    (**(void (***)(char *))a1)(a1);
  }
  if (a3 != 584)
  {
    uint64_t v6 = *(void *)a1;
    *(_DWORD *)(v6 + 40) = 22;
    *(_DWORD *)(v6 + 48) = 584;
    *(_DWORD *)(*(void *)a1 + 52) = a3;
    (**(void (***)(char *))a1)(a1);
  }
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = *((void *)a1 + 3);
  bzero(a1, 0x248uLL);
  *(void *)a1 = v7;
  *((void *)a1 + 3) = v8;
  *((_DWORD *)a1 + 8) = 0;
  _cg_jinit_memory_mgr(a1);
  *((void *)a1 + 2) = 0;
  *((void *)a1 + 5) = 0;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *((void *)a1 + 17) = 0;
  memset_pattern16(a1 + 144, "d", 0x10uLL);
  double result = 0.0;
  *((_OWORD *)a1 + 12) = 0u;
  *((_OWORD *)a1 + 13) = 0u;
  *((_OWORD *)a1 + 10) = 0u;
  *((_OWORD *)a1 + 11) = 0u;
  *((_DWORD *)a1 + 119) = 8;
  *((void *)a1 + 60) = _cg_jpeg_natural_order;
  *((_DWORD *)a1 + 122) = 63;
  *((void *)a1 + 71) = 0;
  *((void *)a1 + 8) = 0x3FF0000000000000;
  *((_DWORD *)a1 + 9) = 100;
  return result;
}

uint64_t _cg_jpeg_suppress_tables(uint64_t result, int a2)
{
  for (uint64_t i = 0; i != 32; i += 8)
  {
    uint64_t v3 = *(void *)(result + 112 + i);
    if (v3) {
      *(_DWORD *)(v3 + 128) = a2;
    }
  }
  for (uint64_t j = 0; j != 32; j += 8)
  {
    uint64_t v5 = *(void *)(result + j + 160);
    if (v5) {
      *(_DWORD *)(v5 + 276) = a2;
    }
    uint64_t v6 = *(void *)(result + j + 192);
    if (v6) {
      *(_DWORD *)(v6 + 276) = a2;
    }
  }
  return result;
}

uint64_t _cg_jpeg_finish_compress(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 36);
  if ((v2 - 101) >= 2)
  {
    if (v2 == 103) {
      goto LABEL_8;
    }
    uint64_t v5 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v5 + 10) = 21;
    *((_DWORD *)v5 + 12) = v2;
    uint64_t v4 = *(void (***)(uint64_t))a1;
  }
  else
  {
    if (*(_DWORD *)(a1 + 344) < *(_DWORD *)(a1 + 52))
    {
      uint64_t v3 = *(void (***)(uint64_t))a1;
      *((_DWORD *)v3 + 10) = 69;
      (*v3)(a1);
    }
    uint64_t v4 = (void (**)(uint64_t))(*(void *)(a1 + 496) + 16);
  }
  (*v4)(a1);
LABEL_8:
  for (uint64_t i = *(void *)(a1 + 496); !*(_DWORD *)(i + 28); uint64_t i = *(void *)(a1 + 496))
  {
    (*(void (**)(uint64_t))i)(a1);
    unint64_t v7 = *(unsigned int *)(a1 + 368);
    if (v7)
    {
      for (unint64_t j = 0; j < v7; ++j)
      {
        uint64_t v9 = *(void *)(a1 + 16);
        if (v9)
        {
          *(void *)(v9 + 8) = j;
          *(void *)(v9 + 16) = v7;
          (*(void (**)(uint64_t))v9)(a1);
        }
        if (!(*(unsigned int (**)(uint64_t, void))(*(void *)(a1 + 520) + 8))(a1, 0))
        {
          uint64_t v10 = *(void (***)(uint64_t))a1;
          *((_DWORD *)v10 + 10) = 25;
          (*v10)(a1);
        }
        unint64_t v7 = *(unsigned int *)(a1 + 368);
      }
    }
    (*(void (**)(uint64_t))(*(void *)(a1 + 496) + 16))(a1);
  }
  (*(void (**)(uint64_t))(*(void *)(a1 + 528) + 24))(a1);
  (*(void (**)(uint64_t))(*(void *)(a1 + 40) + 32))(a1);

  return _cg_jpeg_abort(a1);
}

uint64_t _cg_jpeg_write_tables(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 36);
  if (v2 != 100)
  {
    uint64_t v3 = *(void (***)(void))a1;
    *((_DWORD *)v3 + 10) = 21;
    *((_DWORD *)v3 + 12) = v2;
    (**(void (***)(uint64_t))a1)(a1);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
  (*(void (**)(uint64_t))(*(void *)(a1 + 40) + 16))(a1);
  _cg_jinit_marker_writer(a1);
  (*(void (**)(uint64_t))(*(void *)(a1 + 528) + 32))(a1);
  uint64_t v4 = *(uint64_t (**)(uint64_t))(*(void *)(a1 + 40) + 32);

  return v4(a1);
}

double mq_encoder::start(mq_encoder *this, unsigned __int8 *a2, int a3)
{
  if (!*((unsigned char *)this + 56))
  {
    uint64_t v3 = 0;
    uint64_t v4 = &dword_1E91058F8;
    do
    {
      uint64_t v5 = dword_18898C910[v3 >> 1];
      *(v4 - 4) = mq_encoder::p_bar_table[v5] + (v3 << 31);
      *((void *)v4 - 1) = (char *)&mq_encoder::transition_table + 32 * (v3 & 1 | (2 * v5));
      uint64_t v6 = dword_18898C9CC[v3 >> 1];
      BOOL v8 = v3 >> 1 != 46 && mq_encoder::p_bar_table[v3 >> 1] == 22017;
      int v9 = v3 & 1 ^ v8;
      int *v4 = mq_encoder::p_bar_table[v6] + (v9 << 31);
      *((void *)v4 + 1) = (char *)&mq_encoder::transition_table + 32 * (v9 | (2 * v6));
      ++v3;
      v4 += 8;
    }
    while (v3 != 94);
    *((unsigned char *)this + 56) = 1;
  }
  if (*((unsigned char *)this + 35)) {
    mq_encoder::start();
  }
  if (*((void *)this + 2)) {
    mq_encoder::start();
  }
  if (*((void *)this + 5) || *((void *)this + 6)) {
    mq_encoder::start();
  }
  if (!a2) {
    mq_encoder::start();
  }
  *(_WORD *)((char *)this + 35) = 1;
  *((unsigned char *)this + 34) = a3;
  *((void *)this + 2) = a2;
  *((unsigned char *)this + 33) = 0;
  if (a3)
  {
    *(void *)&double result = 0x8000;
    *(_OWORD *)this = xmmword_18898C900;
    *((void *)this + 3) = a2 - 1;
    *((unsigned char *)this + 32) = *(a2 - 1);
  }
  else
  {
    *((void *)this + 3) = a2;
    *(void *)&double result = 8;
    *((void *)this + 1) = 8;
  }
  return result;
}

unsigned __int8 *mq_encoder::terminate(mq_encoder *this, int a2)
{
  if (!*((unsigned char *)this + 35)) {
    mq_encoder::terminate();
  }
  if (*((unsigned char *)this + 33)) {
    mq_encoder::terminate();
  }
  if (!*((unsigned char *)this + 34))
  {
    int v11 = *((_DWORD *)this + 2);
    int v12 = *((_DWORD *)this + 3);
    uint64_t v13 = (unsigned char *)*((void *)this + 3);
    if (a2)
    {
      uint64_t v10 = (unsigned __int8 *)*((void *)this + 3);
      if (v11 == 8)
      {
LABEL_29:
        *((_DWORD *)this + 2) = v11;
        *((_DWORD *)this + 3) = v12;
        *((void *)this + 3) = v13;
        goto LABEL_30;
      }
      int v14 = *((_DWORD *)this + 3);
      if (v11 >= 1)
      {
        unsigned int v15 = v11 + 1;
        int v14 = *((_DWORD *)this + 3);
        do
        {
          int v14 = (2 * v14) | 1;
          --v15;
        }
        while (v15 > 1);
        *((_DWORD *)this + 2) = 0;
        *((_DWORD *)this + 3) = v14;
      }
      *((void *)this + 3) = v13 + 1;
      unsigned char *v13 = v14;
LABEL_28:
      uint64_t v10 = (unsigned __int8 *)*((void *)this + 3);
      if (!a2) {
        goto LABEL_30;
      }
      goto LABEL_29;
    }
    if (v12 == 255)
    {
      if (v11) {
        mq_encoder::terminate();
      }
      int v16 = 0;
      *((void *)this + 3) = v13 + 1;
      unsigned char *v13 = -1;
      int v17 = 7;
    }
    else
    {
      if (v11 == 8)
      {
        uint64_t v10 = (unsigned __int8 *)*((void *)this + 3);
        goto LABEL_30;
      }
      int v16 = *((_DWORD *)this + 3);
      int v17 = *((_DWORD *)this + 2);
      if (v11 < 1) {
        goto LABEL_27;
      }
    }
    int v18 = 0;
    unsigned int v19 = v17 + 1;
    do
    {
      int v16 = v18 + 2 * v16;
      int v18 = 1 - v18;
      --v19;
    }
    while (v19 > 1);
    *((_DWORD *)this + 2) = 0;
    *((_DWORD *)this + 3) = v16;
LABEL_27:
    uint64_t v20 = (unsigned char *)*((void *)this + 3);
    *((void *)this + 3) = v20 + 1;
    *uint64_t v20 = v16;
    goto LABEL_28;
  }
  int v5 = *(_DWORD *)this;
  int v4 = *((_DWORD *)this + 1);
  uint64_t v6 = *((void *)this + 3);
  uint64_t v24 = *((void *)this + 1);
  *((_DWORD *)this + 1) = v4 << v24;
  if ((int)v24 <= 11)
  {
    int v7 = 12 - v24;
    do
    {
      mq_encoder::transfer_byte((uint64_t)this);
      int v8 = *((_DWORD *)this + 2);
      *((_DWORD *)this + 1) <<= v8;
      BOOL v9 = __OFSUB__(v7, v8);
      v7 -= v8;
    }
    while (!((v7 < 0) ^ v9 | (v7 == 0)));
  }
  mq_encoder::transfer_byte((uint64_t)this);
  uint64_t v10 = (unsigned __int8 *)*((void *)this + 3);
  if (a2)
  {
    *(_DWORD *)this = v5;
    *((_DWORD *)this + 1) = v4;
    *((void *)this + 1) = v24;
    *((void *)this + 3) = v6;
  }
  *(unsigned char *)(*((void *)this + 2) - 1) = *((unsigned char *)this + 32);
LABEL_30:
  uint64_t v21 = this;
  do
  {
    uint64_t v22 = (uint64_t)v21;
    uint64_t v21 = (mq_encoder *)*((void *)v21 + 5);
  }
  while (v21);
  while ((mq_encoder *)v22 != this)
  {
    if (!*(unsigned char *)(v22 + 36)) {
      mq_encoder::find_truncation_point(v22, v10);
    }
    uint64_t v22 = *(void *)(v22 + 48);
  }
  *((unsigned char *)this + 35) = 0;
  if (a2)
  {
    mq_encoder::find_truncation_point((uint64_t)this, v10);
    return (unsigned __int8 *)*((void *)this + 3);
  }
  else
  {
    if (*((unsigned __int8 **)this + 3) != v10) {
      mq_encoder::terminate();
    }
    if ((unint64_t)v10 > *((void *)this + 2) && *(v10 - 1) == 255) {
      *((void *)this + 3) = --v10;
    }
    *((unsigned char *)this + 36) = 1;
  }
  return v10;
}

uint64_t mq_encoder::transfer_byte(uint64_t this)
{
  if (*(unsigned char *)(this + 33)) {
    mq_encoder::transfer_byte();
  }
  int v1 = *(_DWORD *)(this + 12);
  if (v1 == 255)
  {
    int v2 = *(unsigned char **)(this + 24);
    *(void *)(this + 24) = v2 + 1;
    *int v2 = -1;
    int v3 = *(_DWORD *)(this + 4);
  }
  else
  {
    unsigned int v4 = *(_DWORD *)(this + 4);
    int v5 = ((v4 >> 27) & 1) + v1;
    *(_DWORD *)(this + 12) = v5;
    *(_DWORD *)(this + 4) = v4 & 0xF7FFFFFF;
    uint64_t v6 = *(unsigned char **)(this + 24);
    *(void *)(this + 24) = v6 + 1;
    *uint64_t v6 = v5;
    int v3 = *(_DWORD *)(this + 4);
    if (*(_DWORD *)(this + 12) != 255)
    {
      *(_DWORD *)(this + 12) = v3 >> 19;
      int v7 = v3 & 0x7FFFF;
      int v8 = 8;
      goto LABEL_7;
    }
  }
  *(_DWORD *)(this + 12) = v3 >> 20;
  int v7 = v3 & 0xFFFFF;
  int v8 = 7;
LABEL_7:
  *(_DWORD *)(this + 4) = v7;
  *(_DWORD *)(this + 8) = v8;
  return this;
}

uint64_t mq_encoder::find_truncation_point(uint64_t this, unsigned __int8 *a2)
{
  if (*(unsigned char *)(this + 35)) {
    mq_encoder::find_truncation_point();
  }
  if (*(unsigned char *)(this + 36)) {
    mq_encoder::find_truncation_point();
  }
  if (*(unsigned char *)(this + 34))
  {
    uint64_t v2 = *(void *)(this + 16);
    char v3 = *(unsigned char *)(v2 - 1);
    *(unsigned char *)(v2 - 1) = 0;
    LODWORD(v2) = *(_DWORD *)(this + 4);
    int v4 = *(_DWORD *)(this + 8);
    int v5 = *(_DWORD *)(this + 12);
    int v6 = v2 << v4;
    int v7 = (*(_DWORD *)this + v2) << v4;
    if ((v6 & 0x8000000) != 0) {
      int v8 = v5 + 1;
    }
    else {
      int v8 = *(_DWORD *)(this + 12);
    }
    if ((v7 & 0x8000000) != 0) {
      int v9 = v5 + 1;
    }
    else {
      int v9 = *(_DWORD *)(this + 12);
    }
    if (v8 > 255 || v9 <= 255)
    {
      if ((v7 & 0x8000000) != 0) {
        v7 -= 0x8000000;
      }
      if ((v6 & 0x8000000) != 0) {
        v6 -= 0x8000000;
      }
      uint64_t v10 = *(unsigned __int8 **)(this + 24);
      unsigned int v11 = -1;
      char v12 = 8;
      while (1)
      {
        if (v10 >= a2) {
          mq_encoder::find_truncation_point();
        }
        uint64_t v13 = v10 + 1;
        *(void *)(this + 24) = v10 + 1;
        int v14 = *v10;
        int v15 = v14 << (8 - v12);
        *(_DWORD *)(this + 12) = v14;
        int v8 = ((v8 - v15) << v12) + (v6 >> (27 - v12));
        int v6 = (v6 << v12) & 0x7FFFFFE;
        int v9 = ((v9 - v15) << v12) + (v7 >> (27 - v12));
        int v7 = (v7 << v12) & 0x7FFFFFE;
        if (v14 == 255) {
          char v12 = 7;
        }
        else {
          char v12 = 8;
        }
        ++v11;
        uint64_t v10 = v13;
        if (v8 <= 255)
        {
          uint64_t v10 = v13;
          if (v9 >= 256) {
            break;
          }
        }
      }
      if (v11 >= 5) {
        mq_encoder::find_truncation_point();
      }
    }
    *(unsigned char *)(*(void *)(this + 16) - 1) = v3;
  }
  else if (*(_DWORD *)(this + 8) != 8)
  {
    ++*(void *)(this + 24);
  }
  unint64_t v16 = *(void *)(this + 16);
  unint64_t v17 = *(void *)(this + 24);
  if (v17 > v16 && *(unsigned __int8 *)(v17 - 1) == 255) {
    *(void *)(this + 24) = --v17;
  }
  uint64_t v18 = v17 - v16;
  if (v18 >= 2)
  {
    unsigned int v19 = (unsigned __int8 *)(v17 - 2);
    do
    {
      if (v19[1] != 127) {
        break;
      }
      if (*v19 != 255) {
        break;
      }
      *(void *)(this + 24) = v19;
      v18 -= 2;
      v19 -= 2;
    }
    while (v18 > 1);
  }
  *(unsigned char *)(this + 36) = 1;
  return this;
}

void mq_encoder::mq_encode(mq_encode *this, int a2, int *a3)
{
  if (!*((unsigned char *)this + 34) || !*((unsigned char *)this + 35) || (a2 & 0x7FFFFFFF) != 0 || *((unsigned char *)this + 33)) {
    mq_encoder::mq_encode();
  }
  int v4 = *a3;
  int v5 = *a3 & 0x7FFF;
  int v6 = *(_DWORD *)this - v5;
  *(_DWORD *)this = v6;
  if ((v4 ^ a2) < 0)
  {
    if (v6 >= v5) {
      *(_DWORD *)this = v5;
    }
    else {
      *((_DWORD *)this + 1) += v5;
    }
    *(_OWORD *)a3 = *(_OWORD *)(*((void *)a3 + 1) + 16);
    int v7 = *(_DWORD *)this;
    do
    {
      v7 *= 2;
      int v8 = *((_DWORD *)this + 2);
      int v9 = 2 * *((_DWORD *)this + 1);
      *(_DWORD *)this = v7;
      *((_DWORD *)this + 1) = v9;
      *((_DWORD *)this + 2) = v8 - 1;
      if (v8 == 1)
      {
        mq_encoder::transfer_byte((uint64_t)this);
        int v7 = *(_DWORD *)this;
      }
    }
    while (v7 < 0x8000);
  }
  else if (v6 < 0x8000)
  {
    if (v6 >= v5) {
      *((_DWORD *)this + 1) += v5;
    }
    else {
      *(_DWORD *)this = v5;
    }
    *(_OWORD *)a3 = *(_OWORD *)*((void *)a3 + 1);
    int v10 = *(_DWORD *)this;
    do
    {
      v10 *= 2;
      int v11 = *((_DWORD *)this + 2);
      int v12 = 2 * *((_DWORD *)this + 1);
      *(_DWORD *)this = v10;
      *((_DWORD *)this + 1) = v12;
      *((_DWORD *)this + 2) = v11 - 1;
      if (v11 == 1)
      {
        mq_encoder::transfer_byte((uint64_t)this);
        int v10 = *(_DWORD *)this;
      }
    }
    while (v10 < 0x8000);
  }
  else
  {
    *((_DWORD *)this + 1) += v5;
  }
}

void mq_encoder::mq_encode_run(mq_encoder *this, int a2)
{
  if (!*((unsigned char *)this + 34) || !*((unsigned char *)this + 35) || *((unsigned char *)this + 33)) {
    mq_encoder::mq_encode_run();
  }
  v4[1] = &unk_1E9106468;
  v4[0] = dword_1E90FD190;
  mq_encoder::mq_encode(this, (a2 << 30) & 0x80000000, (int *)v4);
  mq_encoder::mq_encode(this, a2 << 31, (int *)v4);
}

uint64_t (**_cg_jinit_d_main_controller(uint64_t *a1, int a2))(uint64_t result, int a2)
{
  double result = (uint64_t (**)(uint64_t, int))(*(uint64_t (**)(void))a1[1])();
  int v5 = result;
  a1[73] = (uint64_t)result;
  *double result = start_pass_main;
  if (a2)
  {
    uint64_t v6 = *a1;
    *(_DWORD *)(v6 + 40) = 3;
    double result = (uint64_t (**)(uint64_t, int))(*(uint64_t (**)(uint64_t *))v6)(a1);
  }
  int v7 = *((_DWORD *)a1 + 107);
  if (*(_DWORD *)(a1[80] + 16))
  {
    if (v7 <= 1)
    {
      uint64_t v8 = *a1;
      *(_DWORD *)(v8 + 40) = 48;
      (*(void (**)(uint64_t *))v8)(a1);
      int v7 = *((_DWORD *)a1 + 107);
    }
    uint64_t v9 = a1[73];
    double result = (uint64_t (**)(uint64_t, int))(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))a1[1])(a1, 1, 16 * *((int *)a1 + 14));
    uint64_t v10 = *((int *)a1 + 14);
    *(void *)(v9 + 112) = result;
    *(void *)(v9 + 120) = &result[v10];
    if ((int)v10 >= 1)
    {
      uint64_t v11 = 0;
      int v12 = v7 + 4;
      uint64_t v13 = (int *)(a1[38] + 40);
      do
      {
        int v14 = *(v13 - 7);
        int v15 = *v13;
        v13 += 24;
        int v16 = v15 * v14 / *((_DWORD *)a1 + 107);
        double result = (uint64_t (**)(uint64_t, int))(*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))a1[1])(a1, 1, 16 * v16 * v12);
        unint64_t v17 = &result[v16];
        *(void *)(*(void *)(v9 + 112) + 8 * v11) = v17;
        *(void *)(*(void *)(v9 + 120) + 8 * v11++) = &v17[v16 * v12];
        uint64_t v10 = *((int *)a1 + 14);
      }
      while (v11 < v10);
    }
    int v7 = *((_DWORD *)a1 + 107) + 2;
  }
  else
  {
    *((_DWORD *)v5 + 25) = v7;
    LODWORD(v10) = *((_DWORD *)a1 + 14);
  }
  if ((int)v10 >= 1)
  {
    uint64_t v18 = 0;
    unsigned int v19 = v5 + 2;
    uint64_t v20 = (_DWORD *)(a1[38] + 40);
    do
    {
      double result = (uint64_t (**)(uint64_t, int))(*(uint64_t (**)(uint64_t *, uint64_t, void, void))(a1[1] + 16))(a1, 1, (*(v20 - 1) * *(v20 - 3)), (*v20 * *(v20 - 7) / *((_DWORD *)a1 + 107) * v7));
      v19[v18++] = (uint64_t (*)(uint64_t, int))result;
      v20 += 24;
    }
    while (v18 < *((int *)a1 + 14));
  }
  return result;
}

uint64_t start_pass_main(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 584);
  if (a2 == 2)
  {
    *(void *)(v2 + 8) = process_data_crank_post;
  }
  else if (a2)
  {
    uint64_t v20 = *(void *)result;
    *(_DWORD *)(v20 + 40) = 3;
    return (*(uint64_t (**)(uint64_t))v20)(result);
  }
  else if (*(_DWORD *)(*(void *)(result + 640) + 16))
  {
    *(void *)(v2 + 8) = process_data_context_main;
    uint64_t v3 = *(unsigned int *)(result + 56);
    if ((int)v3 >= 1)
    {
      uint64_t v4 = 0;
      int v5 = *(_DWORD *)(result + 428);
      uint64_t v6 = *(void *)(result + 304);
      do
      {
        int v7 = *(_DWORD *)(v6 + 40) * *(_DWORD *)(v6 + 12) / v5;
        uint64_t v8 = *(void **)(*(void *)(v2 + 112) + 8 * v4);
        uint64_t v9 = *(void *)(*(void *)(v2 + 120) + 8 * v4);
        double result = *(void *)(v2 + 8 * v4 + 16);
        uint64_t v10 = (v7 * (v5 + 2));
        if ((int)v10 >= 1)
        {
          uint64_t v11 = *(uint64_t **)(v2 + 8 * v4 + 16);
          int v12 = *(void **)(*(void *)(v2 + 120) + 8 * v4);
          uint64_t v13 = *(void **)(*(void *)(v2 + 112) + 8 * v4);
          do
          {
            uint64_t v14 = *v11++;
            *v12++ = v14;
            *v13++ = v14;
            --v10;
          }
          while (v10);
        }
        if (v7 >= 1)
        {
          LODWORD(v15) = 2 * v7;
          uint64_t v16 = v7 * v5;
          uint64_t v17 = v7 * (v5 - 2);
          if (2 * v7 <= 1) {
            uint64_t v15 = 1;
          }
          else {
            uint64_t v15 = v15;
          }
          do
          {
            *(void *)(v9 + 8 * v17) = *(void *)(result + 8 * v16);
            *(void *)(v9 + 8 * v16) = *(void *)(result + 8 * v17);
            result += 8;
            v9 += 8;
            --v15;
          }
          while (v15);
          uint64_t v18 = -(uint64_t)v7;
          do
            v8[v18] = *v8;
          while (!__CFADD__(v18++, 1));
        }
        ++v4;
        v6 += 96;
      }
      while (v4 != v3);
    }
    *(void *)(v2 + 128) = 0;
    *(_DWORD *)(v2 + 136) = 0;
    *(_DWORD *)(v2 + 104) = 0;
  }
  else
  {
    *(void *)(v2 + 8) = process_data_simple_main;
    *(_DWORD *)(v2 + 96) = *(_DWORD *)(v2 + 100);
  }
  return result;
}

int32x2_t process_data_context_main(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v8 = *(int32x2_t **)(a1 + 584);
  if (!v8[13].i32[0])
  {
    if (!(*(unsigned int (**)(uint64_t, void))(*(void *)(a1 + 592) + 24))(a1, *(void *)&v8[v8[16].i32[0] + 14]))return result; {
    v8[13].i32[0] = 1;
    }
    ++v8[17].i32[0];
  }
  __int32 v10 = v8[16].i32[1];
  if (!v10)
  {
LABEL_9:
    int v11 = *(_DWORD *)(a1 + 428);
    v8[12].i32[0] = 0;
    v8[12].i32[1] = v11 - 1;
    if (v8[17].i32[0] == *(_DWORD *)(a1 + 432))
    {
      uint64_t v12 = *(unsigned int *)(a1 + 56);
      if ((int)v12 >= 1)
      {
        uint64_t v13 = 0;
        uint64_t v14 = *(_DWORD **)(a1 + 304);
        uint64_t v15 = *(void *)(a1 + 584);
        uint64_t v16 = (void *)(v15 + 8 * *(int *)(v15 + 128) + 112);
        do
        {
          int v17 = v14[10] * v14[3];
          int v18 = v17 / v11;
          int v19 = v14[12] % v17;
          if (!v19) {
            int v19 = v14[10] * v14[3];
          }
          if (!v13) {
            *(_DWORD *)(v15 + 100) = (v19 - 1) / v18 + 1;
          }
          if (v18 >= 1)
          {
            uint64_t v20 = *(void *)(*v16 + 8 * v13);
            LODWORD(v21) = 2 * v18;
            uint64_t v22 = v19 - 1;
            if ((int)v21 <= 1) {
              uint64_t v21 = 1;
            }
            else {
              uint64_t v21 = v21;
            }
            uint64_t v23 = (void *)(v20 + 8 * v19);
            do
            {
              *v23++ = *(void *)(v20 + 8 * v22);
              --v21;
            }
            while (v21);
          }
          ++v13;
          v14 += 24;
        }
        while (v13 != v12);
      }
    }
    v8[16].i32[1] = 1;
    goto LABEL_24;
  }
  if (v10 != 1)
  {
    if (v10 != 2) {
      return result;
    }
    (*(void (**)(uint64_t, void, int32x2_t *, void, uint64_t, _DWORD *, uint64_t))(*(void *)(a1 + 600)
                                                                                             + 8))(a1, *(void *)&v8[v8[16].i32[0] + 14], v8 + 12, v8[12].u32[1], a2, a3, a4);
    if (v8[12].i32[0] < (unsigned __int32)v8[12].i32[1]) {
      return result;
    }
    v8[16].i32[1] = 0;
    if (*a3 >= a4) {
      return result;
    }
    goto LABEL_9;
  }
LABEL_24:
  (*(void (**)(uint64_t, void, int32x2_t *, void, uint64_t, _DWORD *, uint64_t))(*(void *)(a1 + 600) + 8))(a1, *(void *)&v8[v8[16].i32[0] + 14], v8 + 12, v8[12].u32[1], a2, a3, a4);
  if (v8[12].i32[0] >= (unsigned __int32)v8[12].i32[1])
  {
    signed int v24 = *(_DWORD *)(a1 + 428);
    if (v8[17].i32[0] == 1)
    {
      uint64_t v25 = *(unsigned int *)(a1 + 56);
      if ((int)v25 >= 1)
      {
        uint64_t v26 = 0;
        uint64_t v27 = *(void *)(a1 + 304);
        uint64_t v28 = *(void *)(a1 + 584);
        int v29 = v24 + 2;
        do
        {
          int v30 = *(_DWORD *)(v27 + 40) * *(_DWORD *)(v27 + 12) / v24;
          if (v30 >= 1)
          {
            uint64_t v31 = 0;
            uint64_t v32 = *(void *)(*(void *)(v28 + 112) + 8 * v26);
            uint64_t v33 = *(void *)(*(void *)(v28 + 120) + 8 * v26);
            uint64_t v34 = 8 * (*(_DWORD *)(v27 + 40) * *(_DWORD *)(v27 + 12) / v24);
            int v35 = v30 * (v24 + 1);
            uint64_t v36 = v33 + 8 * v30 * v29;
            uint64_t v37 = v32 + 8 * v30 * v29;
            uint64_t v38 = v33 - 8 * v30;
            uint64_t v39 = v32 - 8 * v30;
            uint64_t v40 = v33 + 8 * v35;
            uint64_t v41 = v32 + 8 * v35;
            do
            {
              *(void *)(v39 + v31) = *(void *)(v41 + v31);
              *(void *)(v38 + v31) = *(void *)(v40 + v31);
              *(void *)(v37 + v31) = *(void *)(v32 + v31);
              *(void *)(v36 + v31) = *(void *)(v33 + v31);
              v31 += 8;
            }
            while (v34 != v31);
          }
          ++v26;
          v27 += 96;
        }
        while (v26 != v25);
      }
    }
    int v42 = v8[16].i32[0] ^ 1;
    v8[13].i32[0] = 0;
    int32x2_t result = vadd_s32(vdup_n_s32(v24), (int32x2_t)0x200000001);
    v8[12] = result;
    v8[16].i32[0] = v42;
    v8[16].i32[1] = 2;
  }
  return result;
}

uint64_t process_data_simple_main(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = a1[73];
  uint64_t v9 = *(unsigned int *)(v8 + 100);
  if (*(_DWORD *)(v8 + 96) >= v9)
  {
    uint64_t result = (*(uint64_t (**)(void *, uint64_t))(a1[74] + 24))(a1, v8 + 16);
    if (!result) {
      return result;
    }
    *(_DWORD *)(v8 + 96) = 0;
    uint64_t v9 = *(unsigned int *)(v8 + 100);
  }
  int v11 = *(uint64_t (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(a1[75] + 8);

  return v11(a1, v8 + 16, v8 + 96, v9, a2, a3, a4);
}

uint64_t process_data_crank_post(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 600) + 8))();
}

__n128 _cg_jinit_inverse_dct(uint64_t a1)
{
  uint64_t v2 = (uint64_t (**)(uint64_t))(**(uint64_t (***)(void))(a1 + 8))();
  *(void *)(a1 + 632) = v2;
  *uint64_t v2 = start_pass;
  if (*(int *)(a1 + 56) >= 1)
  {
    uint64_t v4 = 0;
    int v5 = v2 + 11;
    uint64_t v6 = (void *)(*(void *)(a1 + 304) + 88);
    do
    {
      int v7 = (_OWORD *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 256);
      *uint64_t v6 = v7;
      v6 += 12;
      __n128 result = 0uLL;
      _OWORD *v7 = 0u;
      v7[1] = 0u;
      _OWORD v7[2] = 0u;
      v7[3] = 0u;
      v7[4] = 0u;
      v7[5] = 0u;
      unsigned int v7[6] = 0u;
      v7[7] = 0u;
      v7[8] = 0u;
      v7[9] = 0u;
      v7[10] = 0u;
      v7[11] = 0u;
      v7[12] = 0u;
      v7[13] = 0u;
      v7[14] = 0u;
      v7[15] = 0u;
      *((_DWORD *)v5 + v4++) = -1;
    }
    while (v4 < *(int *)(a1 + 56));
  }
  return result;
}

uint64_t start_pass(uint64_t result)
{
  if (*(int *)(result + 56) >= 1)
  {
    int v1 = (int *)result;
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    int v4 = 0;
    uint64_t v5 = *(void *)(result + 632);
    uint64_t v6 = *(void *)(result + 304);
    float64x2_t v8 = (float64x2_t)xmmword_18898CB60;
    float64x2_t v7 = (float64x2_t)unk_18898CB70;
    float64x2_t v10 = (float64x2_t)start_pass_aanscalefactor;
    float64x2_t v9 = (float64x2_t)unk_18898CB50;
    __asm { FMOV            V17.2D, #0.125 }
    float64x2_t v51 = _Q17;
    do
    {
      int v16 = *(_DWORD *)(v6 + 36);
      int v17 = *(_DWORD *)(v6 + 40) + (v16 << 8);
      int v18 = _cg_jpeg_idct_1x1;
      if (v17 > 1805)
      {
        if (v17 > 3077)
        {
          if (v17 > 3597)
          {
            if (v17 > 4103)
            {
              if (v17 == 4104)
              {
                int v4 = 0;
                int v18 = jpeg_idct_16x8;
                goto LABEL_83;
              }
              if (v17 == 4112)
              {
                int v4 = 0;
                int v18 = jpeg_idct_16x16;
                goto LABEL_83;
              }
            }
            else
            {
              if (v17 == 3598)
              {
                int v4 = 0;
                int v18 = jpeg_idct_14x14;
                goto LABEL_83;
              }
              if (v17 == 3855)
              {
                int v4 = 0;
                int v18 = jpeg_idct_15x15;
                goto LABEL_83;
              }
            }
          }
          else if (v17 > 3340)
          {
            if (v17 == 3341)
            {
              int v4 = 0;
              int v18 = jpeg_idct_13x13;
              goto LABEL_83;
            }
            if (v17 == 3591)
            {
              int v4 = 0;
              int v18 = jpeg_idct_14x7;
              goto LABEL_83;
            }
          }
          else
          {
            if (v17 == 3078)
            {
              int v4 = 0;
              int v18 = jpeg_idct_12x6;
              goto LABEL_83;
            }
            if (v17 == 3084)
            {
              int v4 = 0;
              int v18 = jpeg_idct_12x12;
              goto LABEL_83;
            }
          }
        }
        else if (v17 > 2312)
        {
          if (v17 > 2569)
          {
            if (v17 == 2570)
            {
              int v4 = 0;
              int v18 = jpeg_idct_10x10;
              goto LABEL_83;
            }
            if (v17 == 2827)
            {
              int v4 = 0;
              int v18 = jpeg_idct_11x11;
              goto LABEL_83;
            }
          }
          else
          {
            if (v17 == 2313)
            {
              int v4 = 0;
              int v18 = jpeg_idct_9x9;
              goto LABEL_83;
            }
            if (v17 == 2565)
            {
              int v4 = 0;
              int v18 = jpeg_idct_10x5;
              goto LABEL_83;
            }
          }
        }
        else if (v17 > 2055)
        {
          if (v17 == 2056)
          {
            unsigned int v19 = v1[24];
            if (v19 < 3)
            {
              uint64_t v3 = *(&off_1ED4F0988 + (int)v19);
              int v4 = v1[24];
              goto LABEL_84;
            }
            int v50 = *(uint64_t (***)(int *))v1;
            *(_DWORD *)(*(void *)v1 + 40) = 49;
            goto LABEL_104;
          }
          if (v17 == 2064)
          {
            int v4 = 0;
            int v18 = jpeg_idct_8x16;
            goto LABEL_83;
          }
        }
        else
        {
          if (v17 == 1806)
          {
            int v4 = 0;
            int v18 = jpeg_idct_7x14;
            goto LABEL_83;
          }
          if (v17 == 2052)
          {
            int v4 = 0;
            int v18 = jpeg_idct_8x4;
            goto LABEL_83;
          }
        }
      }
      else if (v17 > 1027)
      {
        if (v17 > 1538)
        {
          if (v17 > 1547)
          {
            if (v17 == 1548)
            {
              int v4 = 0;
              int v18 = jpeg_idct_6x12;
              goto LABEL_83;
            }
            if (v17 == 1799)
            {
              int v4 = 0;
              int v18 = jpeg_idct_7x7;
              goto LABEL_83;
            }
          }
          else
          {
            if (v17 == 1539)
            {
              int v4 = 0;
              int v18 = jpeg_idct_6x3;
              goto LABEL_83;
            }
            if (v17 == 1542)
            {
              int v4 = 0;
              int v18 = jpeg_idct_6x6;
              goto LABEL_83;
            }
          }
        }
        else if (v17 > 1284)
        {
          if (v17 == 1285)
          {
            int v4 = 0;
            int v18 = jpeg_idct_5x5;
            goto LABEL_83;
          }
          if (v17 == 1290)
          {
            int v4 = 0;
            int v18 = jpeg_idct_5x10;
            goto LABEL_83;
          }
        }
        else
        {
          if (v17 == 1028)
          {
            int v4 = 0;
            int v18 = _cg_jpeg_idct_4x4;
            goto LABEL_83;
          }
          if (v17 == 1032)
          {
            int v4 = 0;
            int v18 = jpeg_idct_4x8;
            goto LABEL_83;
          }
        }
      }
      else if (v17 > 515)
      {
        if (v17 > 773)
        {
          if (v17 == 774)
          {
            int v4 = 0;
            int v18 = jpeg_idct_3x6;
            goto LABEL_83;
          }
          if (v17 == 1026)
          {
            int v4 = 0;
            int v18 = jpeg_idct_4x2;
            goto LABEL_83;
          }
        }
        else
        {
          if (v17 == 516)
          {
            int v4 = 0;
            int v18 = jpeg_idct_2x4;
            goto LABEL_83;
          }
          if (v17 == 771)
          {
            int v4 = 0;
            int v18 = jpeg_idct_3x3;
            goto LABEL_83;
          }
        }
      }
      else if (v17 > 512)
      {
        if (v17 == 513)
        {
          int v4 = 0;
          int v18 = jpeg_idct_2x1;
          goto LABEL_83;
        }
        if (v17 == 514)
        {
          int v4 = 0;
          int v18 = _cg_jpeg_idct_2x2;
          goto LABEL_83;
        }
      }
      else
      {
        if (v17 == 257)
        {
          int v4 = 0;
          goto LABEL_83;
        }
        if (v17 == 258)
        {
          int v4 = 0;
          int v18 = jpeg_idct_1x2;
LABEL_83:
          uint64_t v3 = v18;
          goto LABEL_84;
        }
      }
      int v49 = *(uint64_t (***)(int *))v1;
      *((_DWORD *)v49 + 10) = 7;
      *((_DWORD *)v49 + 12) = v16;
      *(_DWORD *)(*(void *)v1 + 52) = *(_DWORD *)(v6 + 40);
      int v50 = *(uint64_t (***)(int *))v1;
LABEL_104:
      __n128 result = (*v50)(v1);
      _Q17 = v51;
      float64x2_t v10 = (float64x2_t)start_pass_aanscalefactor;
      float64x2_t v9 = (float64x2_t)unk_18898CB50;
      float64x2_t v8 = (float64x2_t)xmmword_18898CB60;
      float64x2_t v7 = (float64x2_t)unk_18898CB70;
LABEL_84:
      *(void *)(v5 + 8 * v2 + 8) = v3;
      if (*(_DWORD *)(v6 + 52))
      {
        uint64_t v20 = v5 + 4 * v2;
        int v22 = *(_DWORD *)(v20 + 88);
        uint64_t v21 = (int *)(v20 + 88);
        if (v22 != v4)
        {
          uint64_t v23 = *(void *)(v6 + 80);
          if (v23)
          {
            *uint64_t v21 = v4;
            if (v4 == 2)
            {
              uint64_t v27 = 0;
              int v28 = 0;
              uint64_t v29 = *(void *)(v6 + 88);
              do
              {
                double v30 = *(double *)((char *)&start_pass_aanscalefactor + v27);
                int v31 = v28 + 8;
                uint16x8_t v32 = *(uint16x8_t *)(v23 + 2 * v28);
                uint32x4_t v33 = vmovl_u16(*(uint16x4_t *)v32.i8);
                v34.i64[0] = v33.u32[0];
                v34.i64[1] = v33.u32[1];
                float64x2_t v35 = vcvtq_f64_u64(v34);
                v34.i64[0] = v33.u32[2];
                v34.i64[1] = v33.u32[3];
                float64x2_t v36 = vcvtq_f64_u64(v34);
                uint32x4_t v37 = vmovl_high_u16(v32);
                v34.i64[0] = v37.u32[0];
                v34.i64[1] = v37.u32[1];
                float64x2_t v38 = vcvtq_f64_u64(v34);
                v34.i64[0] = v37.u32[2];
                v34.i64[1] = v37.u32[3];
                uint64_t v39 = (float32x4_t *)(v29 + 4 * v28);
                float32x4_t *v39 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_f64(vmulq_f64(vmulq_n_f64(v35, v30), v10), _Q17)), vmulq_f64(vmulq_f64(vmulq_n_f64(v36, v30), v9), _Q17));
                v39[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmulq_f64(vmulq_f64(vmulq_n_f64(v38, v30), v8), _Q17)), vmulq_f64(vmulq_f64(vmulq_n_f64(vcvtq_f64_u64(v34), v30), v7), _Q17));
                v27 += 8;
                int v28 = v31;
              }
              while (v27 != 64);
            }
            else if (v4 == 1)
            {
              uint64_t v40 = 0;
              uint64_t v41 = *(int32x4_t **)(v6 + 88);
              do
              {
                uint16x8_t v42 = *(uint16x8_t *)(v23 + v40 * 16);
                int32x4_t v43 = (int32x4_t)vmovl_u16(*(uint16x4_t *)v42.i8);
                int32x4_t v44 = (int32x4_t)vmovl_high_u16(v42);
                int16x8_t v45 = (int16x8_t)start_pass_aanscales[v40];
                int32x4_t v46 = vmovl_s16(*(int16x4_t *)v45.i8);
                int32x4_t v47 = vmovl_high_s16(v45);
                *uint64_t v41 = vrshrn_high_n_s64(vrshrn_n_s64(vmull_s32(*(int32x2_t *)v46.i8, *(int32x2_t *)v43.i8), 0xCuLL), vmull_high_s32(v46, v43), 0xCuLL);
                v41[1] = vrshrn_high_n_s64(vrshrn_n_s64(vmull_s32(*(int32x2_t *)v47.i8, *(int32x2_t *)v44.i8), 0xCuLL), vmull_high_s32(v47, v44), 0xCuLL);
                v41 += 2;
                ++v40;
              }
              while (v40 != 8);
            }
            else if (v4)
            {
              int v48 = *(uint64_t (***)(int *))v1;
              *((_DWORD *)v48 + 10) = 49;
              __n128 result = (*v48)(v1);
              _Q17 = v51;
              float64x2_t v10 = (float64x2_t)start_pass_aanscalefactor;
              float64x2_t v9 = (float64x2_t)unk_18898CB50;
              float64x2_t v8 = (float64x2_t)xmmword_18898CB60;
              float64x2_t v7 = (float64x2_t)unk_18898CB70;
            }
            else
            {
              uint64_t v24 = 0;
              uint64_t v25 = *(uint32x4_t **)(v6 + 88);
              do
              {
                uint16x8_t v26 = *(uint16x8_t *)(v23 + v24);
                *uint64_t v25 = vmovl_u16(*(uint16x4_t *)v26.i8);
                v25[1] = vmovl_high_u16(v26);
                v25 += 2;
                v24 += 16;
              }
              while (v24 != 128);
            }
          }
        }
      }
      ++v2;
      v6 += 96;
    }
    while (v2 < v1[14]);
  }
  return result;
}

uint64_t jdiv_round_up(uint64_t a1, uint64_t a2)
{
  return (a1 + a2 - 1) / a2;
}

uint64_t _cg_jround_up(uint64_t a1, uint64_t a2)
{
  return (a1 + a2 - 1) / a2 * a2;
}

char *_cg_jcopy_sample_rows(char *result, int a2, uint64_t a3, int a4, int a5, size_t __n)
{
  if (a5 >= 1)
  {
    size_t v6 = __n;
    float64x2_t v7 = (void **)(a3 + 8 * a4);
    unsigned int v8 = a5 + 1;
    float64x2_t v9 = (const void **)&result[8 * a2];
    do
    {
      int v11 = *v9++;
      float64x2_t v10 = v11;
      uint64_t v12 = *v7++;
      __n128 result = (char *)memcpy(v12, v10, v6);
      --v8;
    }
    while (v8 > 1);
  }
  return result;
}

void *_cg_jcopy_block_row(void *__src, void *__dst, unsigned int a3)
{
  return memcpy(__dst, __src, (unint64_t)a3 << 7);
}

void kd_create_dwt_description(int a1, int a2, kdu_params *this, int a4, BOOL *a5, BOOL *a6, BOOL *a7, int *a8, void *a9, void *a10)
{
  *a9 = 0;
  *a10 = 0;
  *a8 = 0;
  if (a1 != -1)
  {
    *a6 = 1;
    *a7 = 1;
    if (a1)
    {
      if (a1 == 1)
      {
        *a5 = 1;
        *a8 = 2;
        operator new[]();
      }
      kd_create_dwt_description();
    }
    *a5 = 0;
    *a8 = 4;
    operator new[]();
  }
  int v16 = (kdu_params *)kdu_params::access_cluster(this, "ATK");
  if (!v16 || (v17 = (kdu_params *)kdu_params::access_relation(v16, a4, -1, a2, 1), (int v18 = v17) == 0))
  {
    uint64_t v24 = 0;
    *(_OWORD *)int v22 = 0u;
    long long v23 = 0u;
    kdu_error::kdu_error((kdu_error *)v22, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(void *)v22 + 16))(v22, "Unable to find ATK marker segment referenced from within an COD/COC or MCC marker segment.");
    kdu_error::~kdu_error((kdu_error *)v22);
  }
  v22[0] = 0;
  if (kdu_params::get(v17, "Ksymmetric", 0, 0, a6, 1, 1, 1)
    && kdu_params::get(v18, "Kextension", 0, 0, v22, 1, 1, 1)
    && (kdu_params::get(v18, "Kreversible", 0, 0, a5, 1, 1, 1) & 1) != 0)
  {
    *a7 = v22[0] == 1;
    int v21 = 0;
    int v19 = 0;
    if (kdu_params::get(v18, "Ksteps", 0, 0, &v21, 1, 1, 1))
    {
      int v20 = 0;
      int v19 = 0;
      do
      {
        v20 += v21;
        ++v19;
      }
      while ((kdu_params::get(v18, "Ksteps", v19, 0, &v21, 1, 1, 1) & 1) != 0);
    }
    *a8 = v19;
    operator new[]();
  }
  kd_create_dwt_description();
}

void sub_188664ABC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188664AC8()
{
  _Unwind_Resume(v0);
}

unsigned char *print_marker_code(int a1, kdu_message *a2)
{
  uint64_t v3 = "SOC";
  switch(a1)
  {
    case 65359:
      goto LABEL_31;
    case 65360:
    case 65364:
    case 65366:
    case 65369:
    case 65370:
    case 65371:
    case 65378:
    case 65381:
    case 65382:
    case 65383:
    case 65384:
    case 65385:
    case 65386:
    case 65387:
    case 65388:
    case 65389:
    case 65390:
    case 65391:
    case 65392:
    case 65393:
    case 65398:
LABEL_7:
      char v4 = *((unsigned char *)a2 + 8);
      *((unsigned char *)a2 + 8) = 1;
      (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "0x");
      __n128 result = kdu_message::operator<<(a2);
      *((unsigned char *)a2 + 8) = v4;
      return result;
    case 65361:
      uint64_t v3 = "SIZ";
      goto LABEL_31;
    case 65362:
      uint64_t v3 = "COD";
      goto LABEL_31;
    case 65363:
      uint64_t v3 = "COC";
      goto LABEL_31;
    case 65365:
      uint64_t v3 = "TLM";
      goto LABEL_31;
    case 65367:
      uint64_t v3 = "PLM";
      goto LABEL_31;
    case 65368:
      uint64_t v3 = "PLT";
      goto LABEL_31;
    case 65372:
      uint64_t v3 = "QCD";
      goto LABEL_31;
    case 65373:
      uint64_t v3 = "QCC";
      goto LABEL_31;
    case 65374:
      uint64_t v3 = "RGN";
      goto LABEL_31;
    case 65375:
      uint64_t v3 = "POC";
      goto LABEL_31;
    case 65376:
      uint64_t v3 = "PPM";
      goto LABEL_31;
    case 65377:
      uint64_t v3 = "PPT";
      goto LABEL_31;
    case 65379:
      uint64_t v3 = "CRG";
      goto LABEL_31;
    case 65380:
      uint64_t v3 = "COM";
      goto LABEL_31;
    case 65394:
      uint64_t v3 = "DFS";
      goto LABEL_31;
    case 65395:
      uint64_t v3 = "ADS";
      goto LABEL_31;
    case 65396:
      uint64_t v3 = "MCT";
      goto LABEL_31;
    case 65397:
      uint64_t v3 = "MCC";
      goto LABEL_31;
    case 65399:
      uint64_t v3 = "MCO";
      goto LABEL_31;
    case 65400:
      uint64_t v3 = "CBD";
      goto LABEL_31;
    case 65401:
      uint64_t v3 = "ATK";
      goto LABEL_31;
    default:
      switch(a1)
      {
        case 65424:
          uint64_t v3 = "SOT";
          break;
        case 65425:
          uint64_t v3 = "SOP";
          break;
        case 65426:
          uint64_t v3 = "EPH";
          break;
        case 65427:
          uint64_t v3 = "SOD";
          break;
        default:
          if (a1 != 65497) {
            goto LABEL_7;
          }
          uint64_t v3 = "EOC";
          break;
      }
LABEL_31:
      (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "<");
      (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, v3);
      size_t v6 = *(uint64_t (**)(kdu_message *, const char *))(*(void *)a2 + 16);
      return (unsigned char *)v6(a2, ">");
  }
}

unsigned __int8 *kd_input::process_unexpected_marker(unsigned __int8 *this, int a2)
{
  if (!this[545]) {
    kd_input::process_unexpected_marker();
  }
  uint64_t v3 = this;
  this[545] = 0;
  int v4 = this[544];
  if (this[544]) {
    this[546] = 0;
  }
  unsigned int v5 = a2 | 0xFFFFFF00;
  if (this[547])
  {
LABEL_13:
    if (!v4)
    {
      kd_input::putback((kd_input *)v3, v5);
      exception = __cxa_allocate_exception(2uLL);
      _WORD *exception = v5;
      __cxa_throw(exception, MEMORY[0x1E4FBA3D0], 0);
    }
    kd_input::process_unexpected_marker();
  }
  if ((a2 & 0xFE) == 0x90)
  {
    unsigned __int8 v10 = 0;
    this = (unsigned __int8 *)kd_input::get((kd_input *)this, &v10);
    if (this)
    {
      int v6 = v10;
      if (kd_input::get((kd_input *)v3, &v10))
      {
        int v7 = v10 | (v6 << 8);
        if (v5 == -111) {
          int v8 = 4;
        }
        else {
          int v8 = 10;
        }
        kd_input::putback((uint64_t)v3, v10);
        this = (unsigned __int8 *)kd_input::putback((uint64_t)v3, v6);
        if (v7 == v8)
        {
          int v4 = v3[544];
          goto LABEL_13;
        }
      }
      else
      {
        v3[544] = 0;
        this = (unsigned __int8 *)kd_input::putback((uint64_t)v3, a2);
      }
    }
    else
    {
      v3[544] = 0;
    }
  }
  v3[545] = 1;
  v3[546] = a2 == 255;
  return this;
}

uint64_t kd_input::putback(kd_input *this, __int16 a2)
{
  char v2 = HIBYTE(a2);
  kd_input::putback((uint64_t)this, a2);

  return kd_input::putback((uint64_t)this, v2);
}

uint64_t kd_input::read(kd_input *this, unsigned __int8 *a2, int a3)
{
  if (*((unsigned char *)this + 544)) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = a3 < 1;
  }
  if (v3) {
    return 0;
  }
  int v4 = a3;
  uint64_t v7 = 0;
  do
  {
    int v8 = *((_DWORD *)this + 134) - *((_DWORD *)this + 132);
    if (!v8)
    {
      if (!(*(unsigned int (**)(kd_input *))(*(void *)this + 24))(this)) {
        return v7;
      }
      int v8 = *((_DWORD *)this + 134) - *((_DWORD *)this + 132);
      if (v8 <= 0) {
        kd_input::read();
      }
    }
    if (v8 >= v4) {
      int v9 = v4;
    }
    else {
      int v9 = v8;
    }
    int v10 = v9;
    int v11 = v9;
    if (*((unsigned char *)this + 545))
    {
      do
      {
        uint64_t v12 = (unsigned __int8 *)*((void *)this + 66);
        *((void *)this + 66) = v12 + 1;
        unsigned int v13 = *v12;
        *a2++ = v13;
        if (*((unsigned char *)this + 546) && v13 >= 0x90) {
          kd_input::process_unexpected_marker((unsigned __int8 *)this, v13);
        }
        *((unsigned char *)this + 546) = v13 == 255;
        --v10;
      }
      while (v10);
    }
    else
    {
      do
      {
        uint64_t v14 = (unsigned __int8 *)*((void *)this + 66);
        *((void *)this + 66) = v14 + 1;
        *a2++ = *v14;
        --v11;
      }
      while (v11);
    }
    uint64_t v7 = (v9 + v7);
    BOOL v15 = __OFSUB__(v4, v9);
    v4 -= v9;
  }
  while (!((v4 < 0) ^ v15 | (v4 == 0)));
  return v7;
}

uint64_t kd_input::ignore(kd_input *this, uint64_t a2)
{
  if (*((unsigned char *)this + 544)) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = a2 < 1;
  }
  if (v2) {
    return 0;
  }
  uint64_t v3 = a2;
  uint64_t v5 = 0;
  do
  {
    uint64_t v6 = *((void *)this + 66);
    int v7 = *((_DWORD *)this + 134) - v6;
    if (!v7)
    {
      if (!(*(unsigned int (**)(kd_input *))(*(void *)this + 24))(this)) {
        return v5;
      }
      uint64_t v6 = *((void *)this + 66);
      int v7 = *((_DWORD *)this + 134) - v6;
      if (v7 <= 0) {
        kd_input::ignore();
      }
    }
    if (v3 >= v7) {
      int v8 = v7;
    }
    else {
      int v8 = v3;
    }
    if (*((unsigned char *)this + 545))
    {
      if (v8)
      {
        char v9 = *((unsigned char *)this + 546);
        int v10 = v8;
        do
        {
          int v11 = (unsigned __int8 *)*((void *)this + 66);
          *((void *)this + 66) = v11 + 1;
          unsigned int v12 = *v11;
          if (v9 && v12 >= 0x90) {
            kd_input::process_unexpected_marker((unsigned __int8 *)this, *v11);
          }
          char v9 = v12 == 255;
          *((unsigned char *)this + 546) = v12 == 255;
          --v10;
        }
        while (v10);
      }
    }
    else
    {
      *((void *)this + 66) = v6 + v8;
    }
    v5 += v8;
    v3 -= v8;
  }
  while (v3 > 0);
  return v5;
}

uint64_t kd_compressed_input::set_max_bytes(uint64_t this, uint64_t a2)
{
  if (!*(unsigned char *)(this + 608) && *(void *)(this + 568) > a2)
  {
    uint64_t v2 = 0x3FFFFFFFFFFFFFFFLL;
    if (a2 < 0x3FFFFFFFFFFFFFFFLL) {
      uint64_t v2 = a2;
    }
    *(void *)(this + 568) = v2;
    if (!*(void *)(this + 592))
    {
      uint64_t v3 = *(void *)(this + 584) + v2;
      uint64_t v4 = *(void *)(this + 536);
      uint64_t v5 = v4 - this - 14;
      uint64_t v6 = v3 - *(void *)(this + 560);
      BOOL v7 = v6 < v5;
      uint64_t v8 = v6 - v5;
      if (v7)
      {
        unint64_t v9 = v4 + v8;
        *(void *)(this + 536) = v9;
        unint64_t v10 = *(void *)(this + 528);
        if (v9 < v10)
        {
          *(unsigned char *)(this + 544) = 1;
          *(void *)(this + 536) = v10;
        }
      }
    }
  }
  return this;
}

BOOL kd_compressed_input::load_buf(kd_compressed_input *this)
{
  unint64_t v1 = *((void *)this + 67);
  if (v1 != *((void *)this + 66)) {
    kd_compressed_input::load_buf();
  }
  uint64_t v3 = (char *)this + 14;
  *((void *)this + 66) = (char *)this + 14;
  unint64_t v4 = *((void *)this + 70) + v1 - ((void)this + 14);
  *((void *)this + 70) = v4;
  if (*((unsigned char *)this + 608))
  {
    int v5 = (*(uint64_t (**)(void))(**((void **)this + 69) + 32))(*((void *)this + 69));
    uint64_t v6 = *((void *)this + 66);
  }
  else
  {
    unint64_t v7 = *((void *)this + 74);
    if (v7)
    {
      if (*((void *)this + 75)) {
        kd_compressed_input::load_buf();
      }
      if (v7 < (unint64_t)v3 || v7 > v1) {
        kd_compressed_input::load_buf();
      }
      *((void *)this + 73) += v1 - v7;
      *((void *)this + 67) = v3;
      *((void *)this + 74) = v3;
      uint64_t v8 = *(uint64_t (**)(void))(**((void **)this + 69) + 32);
    }
    else
    {
      *((void *)this + 75) = 0;
      uint64_t v9 = *((void *)this + 71) - v4 + *((void *)this + 73);
      *((void *)this + 67) = v3;
      if (v9 < 1)
      {
        BOOL result = 0;
        *((unsigned char *)this + 544) = 1;
        return result;
      }
      uint64_t v8 = *(uint64_t (**)(void))(**((void **)this + 69) + 32);
    }
    int v5 = v8();
    uint64_t v6 = *((void *)this + 67);
  }
  *((void *)this + 67) = v6 + v5;
  if (!v5) {
    *((unsigned char *)this + 544) = 1;
  }
  return *((unsigned char *)this + 544) == 0;
}

uint64_t kd_compressed_input::set_tileheader_scope(kd_compressed_input *this)
{
  *((unsigned char *)this + 608) = 1;
  *((void *)this + 66) = (char *)this + 14;
  uint64_t v2 = (*(uint64_t (**)(void))(**((void **)this + 69) + 56))(*((void *)this + 69));
  uint64_t v3 = *((void *)this + 69);
  if (v2)
  {
    int v4 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v3 + 32))(v3, *((void *)this + 66), 512);
    *((void *)this + 67) = *((void *)this + 66) + v4;
    if (v4 < 0) {
      kd_compressed_input::set_tileheader_scope();
    }
    BOOL v5 = v4 == 0;
  }
  else
  {
    if (((*(uint64_t (**)(uint64_t))(*(void *)v3 + 24))(v3) & 4) == 0)
    {
      uint64_t v8 = 0;
      memset(v7, 0, sizeof(v7));
      kdu_error::kdu_error((kdu_error *)v7, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v7[0] + 16))(v7, "Attempting to load cached tile header data from a compressed data source which does not appear to support caching.  It is possible that the source has been incorrectly implemented.");
      kdu_error::~kdu_error((kdu_error *)v7);
    }
    *((void *)this + 67) = *((void *)this + 66);
    BOOL v5 = 1;
  }
  *((unsigned char *)this + 544) = v5;
  return v2;
}

void sub_18866562C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188665638()
{
  _Unwind_Resume(v0);
}

uint64_t kd_compressed_input::seek(uint64_t this, uint64_t a2)
{
  if (*(unsigned char *)(this + 545)) {
    kd_compressed_input::seek();
  }
  uint64_t v2 = this;
  if (a2 < 0)
  {
    *(unsigned char *)(this + 608) = 1;
    *(void *)(this + 536) = this + 14;
    *(void *)(this + 528) = this + 14;
    if (((*(uint64_t (**)(void, uint64_t))(**(void **)(this + 552) + 64))(*(void *)(this + 552), ~a2) & 1) == 0)
    {
      uint64_t v16 = 0;
      long long v14 = 0u;
      long long v15 = 0u;
      kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "Attempting to load cached precinct packets from a compressed data source which does not appear to support caching.  It is possible that the source has been incorrectly implemented.");
      kdu_error::~kdu_error((kdu_error *)&v14);
    }
    this = (*(uint64_t (**)(void, void, uint64_t))(**(void **)(v2 + 552) + 32))(*(void *)(v2 + 552), *(void *)(v2 + 528), 512);
    *(void *)(v2 + 536) = *(void *)(v2 + 528) + (int)this;
    BOOL v12 = this == 0;
    goto LABEL_13;
  }
  uint64_t v3 = this + 14;
  uint64_t v4 = *(void *)(this + 560);
  uint64_t v5 = *(void *)(this + 528);
  uint64_t v6 = v4 - (this + 14);
  if (v6 + v5 == a2) {
    return this;
  }
  uint64_t v7 = ~v3 + v5 + v4;
  if (v7 > *(void *)(this + 576)) {
    *(void *)(this + 576) = v7;
  }
  uint64_t v8 = *(void *)(this + 568);
  if (v8 <= a2)
  {
    *(unsigned char *)(this + 544) = 1;
    *(void *)(this + 560) = v8;
    *(void *)(this + 536) = v3;
    goto LABEL_15;
  }
  uint64_t v9 = *(void *)(this + 536);
  *(unsigned char *)(this + 544) = 0;
  BOOL v10 = __OFSUB__(a2, v4);
  uint64_t v11 = a2 - v4;
  if (v11 < 0 == v10 && v6 + v9 > a2)
  {
    v3 += v11;
LABEL_15:
    *(void *)(this + 528) = v3;
    return this;
  }
  *(void *)(this + 560) = a2;
  *(void *)(this + 536) = v3;
  *(void *)(this + 528) = v3;
  if (((*(uint64_t (**)(void))(**(void **)(this + 552) + 40))(*(void *)(this + 552)) & 1) == 0)
  {
    uint64_t v16 = 0;
    long long v14 = 0u;
    long long v15 = 0u;
    kdu_error::kdu_error((kdu_error *)&v14, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v14 + 16))(&v14, "Attempting to seek inside a compressed data source which does not appear to support seeking.  The source may have been implemented incorrectly.");
    kdu_error::~kdu_error((kdu_error *)&v14);
  }
  if ((uint64_t)(*(void *)(v2 + 568) - *(void *)(v2 + 560)) >= 512) {
    uint64_t v13 = 512;
  }
  else {
    uint64_t v13 = *(void *)(v2 + 568) - *(void *)(v2 + 560);
  }
  this = (*(uint64_t (**)(void, void, uint64_t))(**(void **)(v2 + 552) + 32))(*(void *)(v2 + 552), *(void *)(v2 + 528), v13);
  *(void *)(v2 + 536) = *(void *)(v2 + 528) + (int)this;
  if (!this)
  {
    BOOL v12 = 1;
LABEL_13:
    *(unsigned char *)(v2 + 544) = v12;
  }
  return this;
}

void sub_1886658CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886658D8()
{
  _Unwind_Resume(v0);
}

uint64_t kd_compressed_input::ignore(kd_compressed_input *this, uint64_t a2)
{
  if (((*(uint64_t (**)(void))(**((void **)this + 69) + 24))(*((void *)this + 69)) & 2) != 0)
  {
    uint64_t v5 = a2 - (void)this;
    uint64_t v6 = *((void *)this + 70) + *((void *)this + 66);
    kd_compressed_input::seek((uint64_t)this, v5 + v6 - 14);
    return *((void *)this + 70) - v6 + *((void *)this + 66);
  }
  else
  {
    return kd_input::ignore(this, a2);
  }
}

void kd_pph_input::~kd_pph_input(kd_pph_input *this)
{
  *(void *)this = &unk_1ED4DF450;
  *((void *)this + 70) = 0;
  while (1)
  {
    uint64_t v2 = (void *)*((void *)this + 69);
    *((void *)this + 71) = v2;
    if (!v2) {
      break;
    }
    *((void *)this + 69) = *v2;
    kd_buf_server::release(*((void *)this + 73), (uint64_t)v2);
  }
  *(void *)this = &unk_1ED4E5F88;
}

{
  uint64_t vars8;

  kd_pph_input::~kd_pph_input(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t kd_buf_server::release(uint64_t result, uint64_t a2)
{
  uint64_t v2 = 0;
  char v3 = *(unsigned char *)(a2 + 8);
  do
  {
    if ((*(char *)(a2 - ((unint64_t)(v3 & 0x3F) << 6) + 8 + v2) & 0x80000000) == 0)
    {
      *(void *)a2 = 0;
      *(unsigned char *)(a2 + 8) = v3 & 0x7F;
      return result;
    }
    v2 += 64;
  }
  while (v2 != 256);
  uint64_t v4 = *(void *)(result + 24);
  if (v4 <= 0) {
    kd_buf_server::release();
  }
  *(void *)a2 = *(void *)(result + 8);
  *(unsigned char *)(a2 + 8) = v3 & 0x7F;
  *(void *)(result + 8) = a2;
  *(void *)(result + 24) = v4 - 1;
  return result;
}

uint64_t kd_pph_input::add_bytes(uint64_t this, char *a2, int a3)
{
  if (a3 >= 1)
  {
    int v3 = a3;
    uint64_t v5 = this;
    while (*(void *)(v5 + 568))
    {
      int v6 = *(_DWORD *)(v5 + 580);
      if (v6 == 55)
      {
        this = kd_buf_server::get(*(kd_buf_server **)(v5 + 584));
        **(void **)(v5 + 568) = this;
        *(void *)(v5 + 568) = this;
LABEL_7:
        int v6 = 0;
        *(_DWORD *)(v5 + 580) = 0;
      }
      int v7 = 55 - v6;
      if (v7 >= v3) {
        int v7 = v3;
      }
      if (v7)
      {
        int v8 = v7;
        do
        {
          char v9 = *a2++;
          uint64_t v10 = *(void *)(v5 + 568);
          uint64_t v11 = *(int *)(v5 + 580);
          *(_DWORD *)(v5 + 580) = v11 + 1;
          *(unsigned char *)(v10 + v11 + 9) = v9;
          --v8;
        }
        while (v8);
      }
      v3 -= v7;
      if (v3 < 1) {
        return this;
      }
    }
    this = kd_buf_server::get(*(kd_buf_server **)(v5 + 584));
    *(void *)(v5 + 552) = this;
    *(void *)(v5 + 560) = this;
    *(void *)(v5 + 568) = this;
    *(_DWORD *)(v5 + 576) = 0;
    goto LABEL_7;
  }
  return this;
}

uint64_t kd_buf_server::get(kd_buf_server *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (!v2)
  {
    if (*((void *)this + 3) != *((void *)this + 2)) {
      kd_buf_server::get();
    }
    kd_buf_server::alloc_pages(this);
    uint64_t v2 = *((void *)this + 1);
  }
  char v3 = *(unsigned char *)(v2 + 8);
  unsigned int v4 = v3 & 0x3F;
  uint64_t v5 = v2 - ((unint64_t)(v3 & 0x3F) << 6);
  if ((v3 & 0x3F) != 0)
  {
    uint64_t v6 = v3 & 0x3F;
    uint64_t result = v2 - (v6 << 6);
    do
    {
      int v8 = *(char *)(result + 8);
      if ((v8 & 0x80000000) == 0)
      {
        *(unsigned char *)(result + 8) = v8 | 0x80;
        return result;
      }
      result += 64;
      --v6;
    }
    while (v6);
    *(unsigned char *)(v2 + 8) = v3 | 0x80;
    if (v4 <= 2) {
      goto LABEL_11;
    }
LABEL_14:
    *((void *)this + 1) = *(void *)v2;
    *(void *)uint64_t v2 = 0;
    uint64_t v12 = *((void *)this + 3);
    uint64_t v11 = *((void *)this + 4);
    *((void *)this + 3) = v12 + 1;
    if (v12 >= v11) {
      *((void *)this + 4) = v11 + 1;
    }
  }
  else
  {
    *(unsigned char *)(v2 + 8) = v3 | 0x80;
LABEL_11:
    unsigned int v9 = 3;
    while (1)
    {
      uint64_t v10 = v5 + ((unint64_t)v9 << 6);
      if ((*(char *)(v10 + 8) & 0x80000000) == 0) {
        break;
      }
      if (--v9 <= v4) {
        goto LABEL_14;
      }
    }
    *((void *)this + 1) = v10;
    *(void *)uint64_t v10 = *(void *)v2;
    *(void *)uint64_t v2 = 0;
  }
  return v2;
}

uint64_t kd_pph_input::load_buf(kd_pph_input *this)
{
  if (!*((void *)this + 70)) {
    goto LABEL_20;
  }
  *((void *)this + 67) = (char *)this + 14;
  *((void *)this + 66) = (char *)this + 14;
  for (int i = 506; i >= 1; i -= v6)
  {
    int v2 = *((_DWORD *)this + 144);
    char v3 = (void *)*((void *)this + 70);
    unsigned int v4 = (void *)*((void *)this + 71);
    if (v2 == 55)
    {
      if (v3 == v4)
      {
        int v2 = 55;
      }
      else
      {
        char v3 = (void *)*v3;
        *((void *)this + 70) = v3;
        *((_DWORD *)this + 144) = 0;
        if (!v3) {
          kd_pph_input::load_buf();
        }
        int v2 = 0;
      }
    }
    if (v3 == v4) {
      int v5 = *((_DWORD *)this + 145);
    }
    else {
      int v5 = 55;
    }
    int v6 = v5 - v2;
    if (v6 < 0) {
      kd_pph_input::load_buf();
    }
    if (!v6) {
      break;
    }
    if (v6 >= i) {
      int v6 = i;
    }
    int v7 = v6;
    do
    {
      uint64_t v8 = *((void *)this + 70);
      uint64_t v9 = *((int *)this + 144);
      *((_DWORD *)this + 144) = v9 + 1;
      LOBYTE(v8) = *(unsigned char *)(v8 + v9 + 9);
      uint64_t v10 = (unsigned char *)*((void *)this + 67);
      *((void *)this + 67) = v10 + 1;
      unsigned char *v10 = v8;
      --v7;
    }
    while (v7);
  }
  if (*((void *)this + 66) != *((void *)this + 67)) {
    return 1;
  }
LABEL_20:
  uint64_t v11 = 0;
  *((unsigned char *)this + 544) = 1;
  return v11;
}

uint64_t kd_marker::kd_marker(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 8);
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = v2;
  *(_WORD *)(result + 16) = *(_WORD *)(a2 + 16);
  LODWORD(v2) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(result + 20) = v2;
  *(_DWORD *)(result + 24) = v2;
  if (v2) {
    operator new[]();
  }
  *(void *)(result + 32) = 0;
  *(unsigned char *)(result + 40) = 0;
  return result;
}

uint64_t kd_marker::read(kd_marker *this, char a2, int a3)
{
  char v3 = *(kd_input **)this;
  if (!*(void *)this) {
    kd_marker::read();
  }
  unsigned __int8 v26 = 0;
  if (*((unsigned char *)v3 + 545))
  {
    *((unsigned char *)v3 + 545) = 0;
    if (*((unsigned char *)v3 + 544)) {
      *((unsigned char *)v3 + 546) = 0;
    }
  }
  int v6 = 0;
  char v7 = a2 ^ 1;
  while (1)
  {
    uint64_t v8 = *(kd_input **)this;
    if (v6 != 255)
    {
      if ((kd_input::get(v8, &v26) & 1) == 0) {
        goto LABEL_69;
      }
      if (a3 && v26 != 255)
      {
        while ((kd_input::get(*(kd_input **)this, &v26) & 1) != 0)
        {
          if (v26 == 255)
          {
            uint64_t v8 = *(kd_input **)this;
            goto LABEL_14;
          }
        }
        goto LABEL_69;
      }
      uint64_t v8 = *(kd_input **)this;
      if (v26 != 255)
      {
        kd_input::putback((uint64_t)v8, v26);
        goto LABEL_69;
      }
    }
LABEL_14:
    if ((kd_input::get(v8, &v26) & 1) == 0) {
      goto LABEL_69;
    }
    unsigned int v9 = v26;
    *((_WORD *)this + 8) = v26 | 0xFF00;
    if (v9 > 0x8F) {
      char v10 = 1;
    }
    else {
      char v10 = v7;
    }
    if (v9 - 144 < 2)
    {
      if ((v10 & 1) == 0) {
        kd_marker::read();
      }
      if ((kd_input::get(*(kd_input **)this, &v26) & 1) == 0) {
        goto LABEL_69;
      }
      *((_DWORD *)this + 5) = v26 << 8;
      if ((kd_input::get(*(kd_input **)this, &v26) & 1) == 0) {
        goto LABEL_69;
      }
      int v11 = *((_DWORD *)this + 5) + v26;
      *((_DWORD *)this + 5) = v11;
      int v12 = *((unsigned __int16 *)this + 8);
      if (v12 != 65425 || v11 == 4)
      {
        char v10 = 1;
        if (v12 != 65424 || v11 == 10) {
          goto LABEL_39;
        }
        int v18 = *(kd_input **)this;
        kd_input::putback(*(void *)this, v11);
        kd_input::putback((uint64_t)v18, SBYTE1(v11));
        uint64_t v25 = 0;
        long long v23 = 0u;
        long long v24 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)&v23, "Kakadu Core Warning:\n");
        (*(void (**)(long long *, const char *))(v23 + 16))(&v23, "Skipping over corrupt SOT marker code!");
      }
      else
      {
        uint64_t v13 = *(kd_input **)this;
        kd_input::putback(*(void *)this, v11);
        kd_input::putback((uint64_t)v13, SBYTE1(v11));
        uint64_t v25 = 0;
        long long v23 = 0u;
        long long v24 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)&v23, "Kakadu Core Warning:\n");
        (*(void (**)(long long *, const char *))(v23 + 16))(&v23, "Skipping over corrupt SOP marker code!");
      }
      kdu_warning::~kdu_warning((kdu_warning *)&v23);
      char v10 = 0;
LABEL_39:
      unsigned __int8 v26 = *((unsigned char *)this + 16);
      goto LABEL_40;
    }
    if (v9 == 217)
    {
      uint64_t result = kd_input::get(*(kd_input **)this, &v26);
      if (!result) {
        goto LABEL_62;
      }
      int v15 = *(unsigned __int8 *)(*((void *)this + 1) + 412);
      kd_input::putback(*(void *)this, v26);
      if (!v15)
      {
        uint64_t result = 0;
        *(unsigned char *)(*(void *)this + 544) = 1;
LABEL_62:
        *((_DWORD *)this + 5) = 0;
LABEL_63:
        *((_WORD *)this + 8) = 0;
        return result;
      }
      unsigned __int8 v26 = *((unsigned char *)this + 16);
      uint64_t v25 = 0;
      long long v23 = 0u;
      long long v24 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v23, "Kakadu Core Warning:\n");
      (*(void (**)(long long *, const char *))(v23 + 16))(&v23, "Disregarding non-terminal EOC marker.");
      kdu_warning::~kdu_warning((kdu_warning *)&v23);
      char v10 = 0;
    }
    else
    {
      BOOL v16 = (v9 & 0xF0) == 48;
      char v17 = v10 ^ 1;
      if (!v16) {
        char v17 = 1;
      }
      if ((v17 & 1) == 0)
      {
        unsigned __int8 v26 = 0;
        if (!*((unsigned char *)this + 40))
        {
          uint64_t v25 = 0;
          long long v23 = 0u;
          long long v24 = 0u;
          kdu_warning::kdu_warning((kdu_warning *)&v23, "Kakadu Core Warning:\n");
          (*(void (**)(long long *, const char *))(v23 + 16))(&v23, "Encountered one or more marker codes in the range 0xFF30 to 0xFF3F.  These are to be ignored.");
          kdu_warning::~kdu_warning((kdu_warning *)&v23);
        }
        *((unsigned char *)this + 40) = 1;
        goto LABEL_42;
      }
    }
LABEL_40:
    if ((a3 & 1) == 0)
    {
      int v19 = *((unsigned __int16 *)this + 8);
      if (v10) {
        goto LABEL_46;
      }
      kd_input::putback(*(kd_input **)this, v19);
      goto LABEL_69;
    }
    if (v10) {
      break;
    }
LABEL_42:
    int v6 = v26;
  }
  int v19 = *((unsigned __int16 *)this + 8);
LABEL_46:
  uint64_t result = 1;
  if (v19 > 65423)
  {
    if ((v19 - 65424) < 2) {
      goto LABEL_49;
    }
    if ((v19 - 65426) >= 2 && v19 != 65497) {
      goto LABEL_73;
    }
  }
  else
  {
    if ((v19 - 65359) > 0x2A) {
      goto LABEL_73;
    }
    if (((1 << (v19 - 79)) & 0x7780037E35CLL) != 0) {
      goto LABEL_49;
    }
    if (v19 != 65359)
    {
LABEL_73:
      uint64_t v25 = 0;
      long long v23 = 0u;
      long long v24 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v23, "Kakadu Core Warning:\n");
      (*(void (**)(long long *, const char *))(v23 + 16))(&v23, "Unrecognized/unimplemented marker code, ");
      print_marker_code(*((unsigned __int16 *)this + 8), (kdu_message *)&v23);
      (*(void (**)(long long *, const char *))(v23 + 16))(&v23, ", found in code-stream.");
      kdu_warning::~kdu_warning((kdu_warning *)&v23);
      LOWORD(v19) = *((_WORD *)this + 8);
LABEL_49:
      if ((v19 & 0xFFFE) == 0xFF90)
      {
        int v20 = *((_DWORD *)this + 5);
      }
      else
      {
        if ((kd_input::get(*(kd_input **)this, &v26) & 1) == 0)
        {
          uint64_t result = 0;
          goto LABEL_63;
        }
        *((_DWORD *)this + 5) = v26 << 8;
        if ((kd_input::get(*(kd_input **)this, &v26) & 1) == 0) {
          goto LABEL_69;
        }
        int v20 = *((_DWORD *)this + 5) + v26;
        *((_DWORD *)this + 5) = v20;
      }
      int v21 = v20 - 2;
      *((_DWORD *)this + 5) = v20 - 2;
      if (v20 <= 1) {
        goto LABEL_69;
      }
      if (v21 > *((_DWORD *)this + 6))
      {
        *((_DWORD *)this + 6) = 2 * v21;
        uint64_t v22 = *((void *)this + 4);
        if (v22) {
          MEMORY[0x18C11C0C0](v22, 0x1000C8077774924);
        }
        operator new[]();
      }
      if ((int)kd_input::read(*(kd_input **)this, *((unsigned __int8 **)this + 4), v21) < *((_DWORD *)this + 5))
      {
LABEL_69:
        uint64_t result = 0;
        *((_WORD *)this + 8) = 0;
        *((_DWORD *)this + 5) = 0;
        return result;
      }
      return 1;
    }
  }
  return result;
}

void sub_1886663E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void kd_pp_markers::~kd_pp_markers(kd_pp_markers *this)
{
  for (uint64_t i = *((void *)this + 1); i; uint64_t i = *((void *)this + 1))
  {
    *((void *)this + 1) = *(void *)(i + 48);
    uint64_t v3 = *(void *)(i + 32);
    if (v3) {
      MEMORY[0x18C11C0C0](v3, 0x1000C8077774924);
    }
    MEMORY[0x18C11C0E0](i, 0x1030C406C6F31B6);
  }
}

void kd_pp_markers::add_marker(uint64_t a1, uint64_t a2)
{
  if (*(int *)(a2 + 20) <= 0)
  {
    uint64_t v3 = 0;
    memset(v2, 0, sizeof(v2));
    kdu_error::kdu_error((kdu_error *)v2, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v2[0] + 16))(v2, "PPM/PPT marker segments must be at least 3 bytes long!");
    kdu_error::~kdu_error((kdu_error *)v2);
  }
  operator new();
}

void sub_188666694(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886666A0()
{
  _Unwind_Resume(v0);
}

void kd_pp_markers::transfer_tpart(kd_pp_markers *this, kd_pph_input *a2)
{
  uint64_t v4 = *((void *)this + 1);
  if (*(unsigned char *)this)
  {
    if (!v4)
    {
LABEL_5:
      uint64_t v21 = 0;
      long long v19 = 0u;
      long long v20 = 0u;
      kdu_error::kdu_error((kdu_error *)&v19, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v19 + 16))(&v19, "Insufficient packet header data in PPM marker segments!");
      kdu_error::~kdu_error((kdu_error *)&v19);
    }
    while (1)
    {
      int v5 = *(_DWORD *)(v4 + 60);
      int v6 = *(_DWORD *)(v4 + 20);
      if (v5 != v6) {
        break;
      }
      kd_pp_markers::advance_list(this);
      uint64_t v4 = *((void *)this + 1);
      if (!v4) {
        goto LABEL_5;
      }
    }
    if (v6 - v5 <= 3)
    {
      uint64_t v21 = 0;
      long long v19 = 0u;
      long long v20 = 0u;
      kdu_error::kdu_error((kdu_error *)&v19, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v19 + 16))(&v19, "Encountered malformed PPM marker: 4-byte Nppm values may not straddle multiple PPM marker segments.  Problem is most likely due to a previously incorrect Nppm value.");
      kdu_error::~kdu_error((kdu_error *)&v19);
    }
    uint64_t v7 = *(void *)(v4 + 32);
    uint64_t v8 = v5 + 1;
    *(_DWORD *)(v4 + 60) = v8;
    int v9 = *(unsigned __int8 *)(v7 + v5);
    uint64_t v10 = v5 + 2;
    *(_DWORD *)(v4 + 60) = v10;
    LODWORD(v8) = (v9 << 16) | (*(unsigned __int8 *)(v7 + v8) << 8);
    uint64_t v11 = v5 + 3;
    *(_DWORD *)(v4 + 60) = v11;
    LODWORD(v8) = v8 | *(unsigned __int8 *)(v7 + v10);
    *(_DWORD *)(v4 + 60) = v5 + 4;
    int v12 = *(unsigned __int8 *)(v7 + v11) | (v8 << 8);
  }
  else
  {
    int v12 = 0x7FFFFFFF;
  }
  BOOL v13 = v12 > 0;
  if (v4) {
    BOOL v14 = v12 < 1;
  }
  else {
    BOOL v14 = 1;
  }
  if (!v14)
  {
    do
    {
      uint64_t v15 = *(int *)(v4 + 60);
      if (*(_DWORD *)(v4 + 20) - (int)v15 >= v12) {
        int v16 = v12;
      }
      else {
        int v16 = *(_DWORD *)(v4 + 20) - v15;
      }
      kd_pph_input::add_bytes((uint64_t)a2, (char *)(*(void *)(v4 + 32) + v15), v16);
      uint64_t v4 = *((void *)this + 1);
      int v17 = *(_DWORD *)(v4 + 60) + v16;
      *(_DWORD *)(v4 + 60) = v17;
      if (v17 == *(_DWORD *)(v4 + 20))
      {
        kd_pp_markers::advance_list(this);
        uint64_t v4 = *((void *)this + 1);
      }
      v12 -= v16;
      BOOL v13 = v12 > 0;
    }
    while (v4 && v12 > 0);
  }
  if (*(unsigned char *)this) {
    BOOL v18 = !v13;
  }
  else {
    BOOL v18 = 1;
  }
  if (!v18)
  {
    uint64_t v21 = 0;
    long long v19 = 0u;
    long long v20 = 0u;
    kdu_error::kdu_error((kdu_error *)&v19, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v19 + 16))(&v19, "Insufficient packet header data in PPM marker segments, or else Nppm values must be incorrect!");
    kdu_error::~kdu_error((kdu_error *)&v19);
  }
}

void sub_188666940(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18866694C()
{
  _Unwind_Resume(v0);
}

void kd_pp_markers::advance_list(kd_pp_markers *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (v1 && *(_DWORD *)(v1 + 60) == *(_DWORD *)(v1 + 20))
  {
    *((void *)this + 1) = *(void *)(v1 + 48);
    uint64_t v2 = *(void *)(v1 + 32);
    if (v2) {
      MEMORY[0x18C11C0C0](v2, 0x1000C8077774924);
    }
    JUMPOUT(0x18C11C0E0);
  }
  kd_pp_markers::advance_list();
}

void kd_pp_markers::ignore_tpart(kd_pp_markers *this)
{
  if (*(unsigned char *)this)
  {
    unsigned int v2 = 0;
    int v3 = 0x7FFFFFFF;
    BOOL v4 = 1;
    do
    {
      while (1)
      {
        uint64_t v5 = *((void *)this + 1);
        if (!v5)
        {
          uint64_t v18 = 0;
          long long v16 = 0u;
          long long v17 = 0u;
          kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v16 + 16))(&v16, "Insufficient packet header data in PPM marker segments!");
          kdu_error::~kdu_error((kdu_error *)&v16);
        }
        uint64_t v6 = *(int *)(v5 + 60);
        if (v6 != *(_DWORD *)(v5 + 20)) {
          break;
        }
        kd_pp_markers::advance_list(this);
        if (!v4) {
          goto LABEL_11;
        }
      }
      uint64_t v7 = *(void *)(v5 + 32);
      *(_DWORD *)(v5 + 60) = v6 + 1;
      int v3 = *(unsigned __int8 *)(v7 + v6) | (v3 << 8);
      BOOL v4 = v2++ < 3;
    }
    while (v2 != 4);
  }
  else
  {
    int v3 = 0x7FFFFFFF;
  }
LABEL_11:
  uint64_t v8 = *((void *)this + 1);
  BOOL v9 = v3 > 0;
  if (v8) {
    BOOL v10 = v3 < 1;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    do
    {
      int v11 = *(_DWORD *)(v8 + 20);
      int v12 = *(_DWORD *)(v8 + 60);
      if (v11 - v12 >= v3) {
        int v13 = v3;
      }
      else {
        int v13 = v11 - v12;
      }
      int v14 = v13 + v12;
      *(_DWORD *)(v8 + 60) = v14;
      if (v14 == v11)
      {
        kd_pp_markers::advance_list(this);
        uint64_t v8 = *((void *)this + 1);
      }
      v3 -= v13;
      BOOL v9 = v3 > 0;
    }
    while (v8 && v3 > 0);
  }
  if (*(unsigned char *)this) {
    BOOL v15 = !v9;
  }
  else {
    BOOL v15 = 1;
  }
  if (!v15)
  {
    uint64_t v18 = 0;
    long long v16 = 0u;
    long long v17 = 0u;
    kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v16 + 16))(&v16, "Insufficient packet header data in PPM marker segments, or else Nppm values must be incorrect!");
    kdu_error::~kdu_error((kdu_error *)&v16);
  }
}

void sub_188666BD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188666BDC()
{
  _Unwind_Resume(v0);
}

BOOL kd_tlm_generator::init(kd_tlm_generator *this, int a2, int a3)
{
  *((_DWORD *)this + 3) = 0;
  *(void *)this = 0;
  *((void *)this + 3) = 0;
  uint64_t v6 = *((void *)this + 4);
  if (v6) {
    MEMORY[0x18C11C0C0](v6, 0x1000C80CE7E837CLL);
  }
  int v7 = 0;
  unsigned int v8 = 0;
  if (a3 >= 255) {
    int v9 = 255;
  }
  else {
    int v9 = a3;
  }
  if (a3 < 0) {
    int v9 = 1;
  }
  *(_DWORD *)this = a2;
  *((_DWORD *)this + 1) = v9;
  unsigned int v10 = v9 * a2;
  *(void *)((char *)this + 12) = v10;
  *((void *)this + 3) = 0;
  int v11 = v10;
  do
  {
    if (v11 >= 10921) {
      int v12 = 10921;
    }
    else {
      int v12 = v11;
    }
    v11 -= v12;
    v7 += 6 * v12 + 6;
    if (v11 < 1) {
      break;
    }
  }
  while (v8++ < 0xFE);
  *((_DWORD *)this + 2) = v7;
  if (v11 < 1) {
    operator new[]();
  }
  *((_DWORD *)this + 3) = 0;
  *(void *)this = 0;
  *((void *)this + 3) = 0;
  uint64_t v14 = *((void *)this + 4);
  if (v14) {
    MEMORY[0x18C11C0C0](v14, 0x1000C80CE7E837CLL);
  }
  return v11 < 1;
}

uint64_t kd_tlm_generator::add_tpart_length(uint64_t this, unsigned int a2, unint64_t a3)
{
  if (*(int *)this >= 1)
  {
    int v3 = *(_DWORD *)(this + 16);
    if (v3 >= *(_DWORD *)(this + 12)) {
      kd_tlm_generator::add_tpart_length();
    }
    if ((a2 & 0x80000000) != 0 || *(_DWORD *)this <= a2) {
      kd_tlm_generator::add_tpart_length();
    }
    uint64_t v4 = *(void *)(this + 32) + 8 * v3;
    *(_WORD *)uint64_t v4 = a2;
    *(_DWORD *)(v4 + 4) = a3;
    if (HIDWORD(a3))
    {
      uint64_t v6 = 0;
      memset(v5, 0, sizeof(v5));
      kdu_error::kdu_error((kdu_error *)v5, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, "Attempting to write TLM (tile-part length) data where one tile-part's length cannot be represented as an unsigned 32-bit value.");
      kdu_error::~kdu_error((kdu_error *)v5);
    }
    *(_DWORD *)(this + 16) = v3 + 1;
    *(void *)(this + 24) += a3;
  }
  return this;
}

void sub_188666E04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188666E10()
{
  _Unwind_Resume(v0);
}

int *kd_tlm_generator::write_dummy_tlms(int *this, kd_compressed_output *a2)
{
  if (*this >= 1) {
    operator new[]();
  }
  return this;
}

uint64_t kd_tlm_generator::write_tlms(uint64_t this, kdu_compressed_target *a2, int a3, uint64_t a4)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (*(int *)this >= 1)
  {
    uint64_t v5 = *(void *)(this + 24) + a4 + *(int *)(this + 8);
    int v6 = *(_DWORD *)(this + 4) * a3;
    if (v6 >= 1)
    {
      int v7 = 0;
      int v8 = 0;
      do
      {
        if (!v7)
        {
          if (v8 >= 256) {
            kd_tlm_generator::write_tlms();
          }
          v5 -= 6;
          ++v8;
          int v7 = 10921;
        }
        if (v6 >= v7) {
          int v9 = v7;
        }
        else {
          int v9 = v6;
        }
        v7 -= v9;
        v5 -= 6 * v9;
        BOOL v10 = __OFSUB__(v6, v9);
        v6 -= v9;
      }
      while (!((v6 < 0) ^ v10 | (v6 == 0)));
    }
    if (((*(uint64_t (**)(kdu_compressed_target *, uint64_t))(*(void *)a2 + 24))(a2, v5) & 1) == 0)
    {
      uint64_t v12 = 0;
      memset(v11, 0, sizeof(v11));
      kdu_error::kdu_error((kdu_error *)v11, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)v11);
    }
    operator new[]();
  }
  return this;
}

void sub_188667344(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188667350(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

void kd_tpart_pointer_server::~kd_tpart_pointer_server(kd_tpart_pointer_server *this)
{
  for (uint64_t i = *(void *)this; *(void *)this; uint64_t i = *(void *)this)
  {
    *(void *)this = *(void *)(i + 48);
    uint64_t v3 = *(void *)(i + 32);
    if (v3) {
      MEMORY[0x18C11C0C0](v3, 0x1000C8077774924);
    }
    MEMORY[0x18C11C0E0](i, 0x1030C40DF1BA421);
  }
  while (1)
  {
    uint64_t v4 = *((void *)this + 1);
    if (!v4) {
      break;
    }
    *((void *)this + 1) = *(void *)(v4 + 512);
    MEMORY[0x18C11C0E0]();
  }
}

void kd_tpart_pointer_server::add_tlm_marker(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 24) = 0;
  if (*(__int16 *)(a2 + 16) == -171)
  {
    if (*(int *)(a2 + 20) <= 3)
    {
      uint64_t v3 = 0;
      memset(v2, 0, sizeof(v2));
      kdu_error::kdu_error((kdu_error *)v2, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v2[0] + 16))(v2, "TLM marker segments must be at least 6 bytes long!");
      kdu_error::~kdu_error((kdu_error *)v2);
    }
    operator new();
  }
  kd_tpart_pointer_server::add_tlm_marker();
}

void sub_1886675B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886675C4()
{
  _Unwind_Resume(v0);
}

void *kd_tpart_pointer_server::add_tpart(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t result = *(void **)(a1 + 16);
  if (!result) {
    operator new();
  }
  *(void *)(a1 + 16) = result[1];
  *uint64_t result = a3;
  result[1] = 0;
  uint64_t v5 = a2 + 1;
  if (*a2)
  {
    if (!*v5) {
      kd_tpart_pointer_server::add_tpart();
    }
    int v6 = (void *)(*v5 + 8);
  }
  else
  {
    int v6 = a2 + 1;
    uint64_t v5 = a2;
  }
  *int v6 = result;
  void *v5 = result;
  return result;
}

uint64_t *kd_tpart_pointer_server::translate_markers(uint64_t *result, uint64_t a2, int a3, uint64_t a4)
{
  if (result[1]) {
    kd_tpart_pointer_server::translate_markers();
  }
  uint64_t v4 = (uint64_t)result;
  uint64_t v5 = *result;
  if (*result)
  {
    int v9 = -1;
    do
    {
      uint64_t v10 = *(void *)(v5 + 32);
      unsigned int v11 = *(unsigned __int8 *)(v10 + 1);
      int v12 = (v11 >> 4) & 3;
      uint64_t v32 = v5;
      if (v12)
      {
        if (v12 == 2)
        {
          char v14 = 0;
          int v13 = 0;
        }
        else
        {
          if (v12 != 1)
          {
            uint64_t v35 = 0;
            long long v33 = 0u;
            long long v34 = 0u;
            kdu_error::kdu_error((kdu_error *)&v33, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v33 + 16))(&v33, "Illegal Stlm field encountered in TLM marker segment!");
            kdu_error::~kdu_error((kdu_error *)&v33);
          }
          int v13 = 0;
          char v14 = 1;
        }
      }
      else
      {
        char v14 = 0;
        int v13 = 1;
      }
      BOOL v15 = (unsigned __int8 *)(v10 + 2);
      int v16 = *(_DWORD *)(v5 + 20) - 2;
      if ((v11 & 0x40) != 0) {
        int v17 = 4;
      }
      else {
        int v17 = 2;
      }
      int v18 = v12 + v17;
      int v19 = v16 / v18;
      int v20 = v16 / v18 * v18;
      if (v19 < 1 || v16 != v20)
      {
        uint64_t v35 = 0;
        long long v33 = 0u;
        long long v34 = 0u;
        kdu_error::kdu_error((kdu_error *)&v33, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v33 + 16))(&v33, "Malformed TLM marker segment encountered in main header.  Segment length is inconsistent with the number of bytes used to represent pointer info for each tile-part.");
        kdu_error::~kdu_error((kdu_error *)&v33);
      }
      while (1)
      {
        if (v13)
        {
          ++v9;
        }
        else
        {
          int v9 = *v15;
          if (v14)
          {
            ++v15;
          }
          else
          {
            int v22 = v15[1];
            v15 += 2;
            int v9 = v22 | (v9 << 8);
          }
        }
        if (v9 >= a3)
        {
          uint64_t v35 = 0;
          long long v33 = 0u;
          long long v34 = 0u;
          kdu_error::kdu_error((kdu_error *)&v33, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v33 + 16))(&v33, "Illegal TLM marker segment data encountered in main header.  An illegal tile number has been identified, either explicitly or implicitly (through the rule that missing tile identifiers are legal only when tiles appear in order with only one tile-part each).");
          kdu_error::~kdu_error((kdu_error *)&v33);
        }
        kd_tpart_pointer_server::add_tpart(v4, (void *)(a4 + 24 * v9), a2);
        unint64_t v23 = __rev16(*(unsigned __int16 *)v15);
        if ((v11 & 0x40) != 0)
        {
          unint64_t v24 = (v23 << 16) | ((unint64_t)v15[2] << 8);
          uint64_t v25 = v15[3];
          v15 += 4;
          unint64_t v23 = v24 | v25;
        }
        else
        {
          v15 += 2;
        }
        if (v23 <= 0xD) {
          break;
        }
        a2 += v23;
        if (!--v19)
        {
          char v26 = 0;
          uint64_t v27 = v32;
          goto LABEL_33;
        }
      }
      uint64_t v35 = 0;
      long long v33 = 0u;
      long long v34 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v33, "Kakadu Core Warning:\n");
      (*(void (**)(long long *, const char *))(v33 + 16))(&v33, "TLM marker segments contain one or more illegal lengths (< 14 bytes).  Proceeding with incomplete tile-part length information.");
      uint64_t v27 = v32;
      kdu_warning::~kdu_warning((kdu_warning *)&v33);
      char v26 = 1;
LABEL_33:
      *(void *)uint64_t v4 = *(void *)(v27 + 48);
      uint64_t v28 = *(void *)(v27 + 32);
      if (v28) {
        MEMORY[0x18C11C0C0](v28, 0x1000C8077774924);
      }
      uint64_t result = (uint64_t *)MEMORY[0x18C11C0E0](v27, 0x1030C40DF1BA421);
      uint64_t v5 = *(void *)v4;
      if (*(void *)v4) {
        char v29 = v26;
      }
      else {
        char v29 = 1;
      }
    }
    while ((v29 & 1) == 0);
    *(unsigned char *)(v4 + 24) = 1;
    if (a3 >= 1)
    {
      uint64_t v30 = a3;
      int v31 = (void *)(a4 + 8);
      do
      {
        *int v31 = 0;
        v31 += 3;
        --v30;
      }
      while (v30);
    }
  }
  return result;
}

void sub_188667A24(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188667A30(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

uint64_t kd_precinct_pointer_server::add_plt_marker(uint64_t result, uint64_t a2, kdu_params *this, kdu_params *a4)
{
  if (*(void *)result)
  {
    uint64_t v6 = result;
    int v7 = *(unsigned __int8 **)(a2 + 32);
    int v8 = *(_DWORD *)(a2 + 20);
    int v9 = v8 - 1;
    if (v8 < 1 || (int v10 = *v7, v10 != *(unsigned __int8 *)(result + 61)))
    {
      uint64_t v28 = 0;
      long long v26 = 0u;
      long long v27 = 0u;
      kdu_error::kdu_error((kdu_error *)&v26, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v26 + 16))(&v26, "PLT marker segments appear out of order within one or more tile-part headers.  While this is not illegal, it is highly inadvisable since it prevents immediate condensation of the pointer information by efficient parsers.  To process this code-stream, you will have to open it again, with file seeking disabled.");
      kdu_error::~kdu_error((kdu_error *)&v26);
    }
    *(unsigned char *)(result + 61) = v10 + 1;
    if (*(_DWORD *)(result + 48))
    {
      uint64_t v28 = 0;
      long long v26 = 0u;
      long long v27 = 0u;
      kdu_error::kdu_error((kdu_error *)&v26, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v26 + 16))(&v26, "There appears to be a problem with the PLT marker segments included in the input code-stream.  The PLT marker segments encountered so far do not have sufficient length information to describe the lengths of all packets in the tile-parts encountered so far.  To process this code-stream, you will have to open it again, with file seeking disabled.");
      kdu_error::~kdu_error((kdu_error *)&v26);
    }
    *(void *)uint64_t v25 = 0;
    int v24 = 0;
    if (!kdu_params::get(this, "Clayers", 0, 0, v25, 1, 1, 1)
      || (uint64_t result = kdu_params::get(this, "Corder", 0, 0, &v24, 1, 1, 1), (result & 1) == 0))
    {
      exception = __cxa_allocate_exception(4uLL);
      _DWORD *exception = -1;
      __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
    }
    int v11 = *(_DWORD *)(v6 + 56);
    int v12 = v25[0];
    if (v11)
    {
      if (v11 != v25[0])
      {
LABEL_16:
        uint64_t result = (uint64_t)kd_precinct_pointer_server::disable((uint64_t *)v6);
        if (*(unsigned char *)(v6 + 60))
        {
          uint64_t v28 = 0;
          long long v26 = 0u;
          long long v27 = 0u;
          kdu_error::kdu_error((kdu_error *)&v26, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v26 + 16))(&v26, "Unexpected change in coding parameters or packet sequencing detected while parsing packet length information in PLT marker segments.  While this is not illegal, it is highly inadvisable.  To process this code-stream, open it again with file seeking disabled!");
          kdu_error::~kdu_error((kdu_error *)&v26);
        }
        return result;
      }
    }
    else
    {
      *(_DWORD *)(v6 + 56) = v25[0];
    }
    if (v12 >= 2)
    {
      if (v24 < 2) {
        goto LABEL_16;
      }
      uint64_t result = kdu_params::get(a4, "Porder", 0, 0, &v25[1], 1, 1, 1);
      if (result) {
        goto LABEL_16;
      }
    }
    if (!*(void *)(v6 + 8))
    {
      uint64_t result = *(void *)v6;
      if (*(void *)v6)
      {
        uint64_t result = kd_buf_server::get((kd_buf_server *)result);
        *(void *)(v6 + 8) = result;
        *(void *)(v6 + 16) = result;
      }
    }
    if (v8 >= 2)
    {
      int v13 = (char *)(v7 + 1);
      do
      {
        if (!*(_DWORD *)(v6 + 72))
        {
          *(_DWORD *)(v6 + 72) = *(_DWORD *)(v6 + 56);
          *(void *)(v6 + 64) = 0;
        }
        unint64_t v14 = 0;
        do
        {
          if (!v9)
          {
            uint64_t v28 = 0;
            long long v26 = 0u;
            long long v27 = 0u;
            kdu_error::kdu_error((kdu_error *)&v26, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v26 + 16))(&v26, "Malformed PLT marker segment encountered in tile-part header.  Segment terminates part of the way through a multi-byte packet length specification!");
            kdu_error::~kdu_error((kdu_error *)&v26);
          }
          char v15 = *v13++;
          --v9;
          unint64_t v16 = v15 & 0x7F | (v14 << 7);
          unint64_t v14 = v16;
        }
        while (v15 < 0);
        uint64_t v17 = *(void *)(v6 + 64) + v16;
        *(void *)(v6 + 64) = v17;
        int v18 = *(_DWORD *)(v6 + 72) - 1;
        *(_DWORD *)(v6 + 72) = v18;
        if (!v18)
        {
          int v19 = 0;
          do
          {
            uint64_t v20 = v17 >> v19;
            v19 += 7;
          }
          while (v20 > 127);
          int v21 = v19 - 7;
          do
          {
            uint64_t result = kd_precinct_pointer_server::record_byte((kd_precinct_pointer_server *)v6, (*(uint64_t *)(v6 + 64) >> v21) & 0x7Fu | ((v21 != 0) << 7));
            BOOL v22 = v21 <= 6;
            v21 -= 7;
          }
          while (!v22);
          ++*(_DWORD *)(v6 + 32);
        }
      }
      while (v9 + 1 > 1);
    }
  }
  return result;
}

void sub_188667E1C(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188667E28(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

uint64_t kd_precinct_pointer_server::record_byte(kd_precinct_pointer_server *this, char a2)
{
  uint64_t result = *((void *)this + 2);
  if (!result) {
    kd_precinct_pointer_server::record_byte();
  }
  int v5 = *((_DWORD *)this + 7);
  if (v5 == 55)
  {
    uint64_t result = kd_buf_server::get(*(kd_buf_server **)this);
    int v5 = 0;
    **((void **)this + 2) = result;
    *((void *)this + 2) = result;
  }
  *((_DWORD *)this + 7) = v5 + 1;
  *(unsigned char *)(result + v5 + 9) = a2;
  return result;
}

uint64_t *kd_precinct_pointer_server::start_tpart_body(uint64_t *this, uint64_t a2, int a3, kdu_params *a4, kdu_params *a5, char a6, char a7)
{
  char v7 = a7 ^ 1;
  *((unsigned char *)this + 61) = 0;
  if (a3) {
    char v7 = 0;
  }
  if ((v7 & 1) == 0)
  {
    int v8 = this;
    if (*this)
    {
      if (this[1] || *((unsigned char *)this + 60))
      {
        int v18 = 0;
        int v16 = 0;
        int v17 = 0;
        if ((a6 & 1) != 0
          || (this = (uint64_t *)kdu_params::get(a4, "Clayers", 0, 0, &v17, 1, 1, 1), !this)
          || v17 != *((_DWORD *)v8 + 14)
          || v17 >= 2
          && ((kdu_params::get(a5, "Porder", 0, 0, &v18, 1, 1, 1) & 1) != 0
           || (this = (uint64_t *)kdu_params::get(a4, "Corder", 0, 0, &v16, 1, 1, 1), !this)
           || v16 <= 1))
        {
          this = kd_precinct_pointer_server::disable(v8);
          if (*((unsigned char *)v8 + 60))
          {
            uint64_t v15 = 0;
            memset(v14, 0, sizeof(v14));
            kdu_error::kdu_error((kdu_error *)v14, "Kakadu Core Error:\n");
            (*(void (**)(_OWORD *, const char *))(*(void *)&v14[0] + 16))(v14, "Unexpected change in coding parameters or packet sequencing detected after parsing packet length information in PLT marker segments.  While this is not illegal, it is highly inadvisable.  To process this code-stream, open it again with file seeking disabled!");
            kdu_error::~kdu_error((kdu_error *)v14);
          }
        }
        v8[5] = a2;
        *((_DWORD *)v8 + 12) = a3;
        *((unsigned char *)v8 + 52) = a7;
      }
      else
      {
        return kd_precinct_pointer_server::disable(this);
      }
    }
  }
  return this;
}

void sub_188668098(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886680A4()
{
  _Unwind_Resume(v0);
}

uint64_t kd_precinct_pointer_server::pop_address(kd_precinct_pointer_server *this)
{
  if (!*(void *)this) {
    return 0;
  }
  if (!*((_DWORD *)this + 8) && !*((unsigned char *)this + 52) && *((_DWORD *)this + 12))
  {
    uint64_t v8 = 0;
    long long v6 = 0u;
    long long v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v6 + 16))(&v6, "Unexpectedly ran out of packet length information while processing tile-parts.  Most likely cause is that PLT marker segments are malformed, incomplete, or do not appear until after the packets whose lengths they describe.  All of these conditions are violations of the standard!");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  if (!*((_DWORD *)this + 12) && !*((unsigned char *)this + 52)) {
    return -1;
  }
  int64_t v2 = 0;
  do
  {
    if (*((void *)this + 1) == *((void *)this + 2) && *((_DWORD *)this + 6) >= *((_DWORD *)this + 7))
    {
      uint64_t v8 = 0;
      long long v6 = 0u;
      long long v7 = 0u;
      kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v6 + 16))(&v6, "kd_precinct_pointer_server runs into file corruption");
      kdu_error::~kdu_error((kdu_error *)&v6);
    }
    char byte = kd_precinct_pointer_server::retrieve_byte(this);
    int64_t v2 = byte & 0x7F | (unint64_t)(v2 << 7);
  }
  while (byte < 0);
  --*((_DWORD *)this + 8);
  if (!*((unsigned char *)this + 52))
  {
    uint64_t v4 = *((unsigned int *)this + 12);
    if (v2 > v4)
    {
      uint64_t v8 = 0;
      long long v6 = 0u;
      long long v7 = 0u;
      kdu_error::kdu_error((kdu_error *)&v6, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v6 + 16))(&v6, "Tile-part holds some but not all the packets of a precinct for which PLT information is being used to extract precinct addresses for random access.  In particular, the current tile has its packets sequenced so that all packets of any given precinct appear consecutively and yet a tile-part boundary has been inserted between the packets of a precinct.  While this is not illegal, it indicates very poor judgement in the placement of tile-part boundaries.  To process this code-stream, you will have to open it again with file seeking disabled.");
      kdu_error::~kdu_error((kdu_error *)&v6);
    }
    *((_DWORD *)this + 12) = v4 - v2;
  }
  *((unsigned char *)this + 60) = 1;
  uint64_t result = *((void *)this + 5);
  *((void *)this + 5) = result + v2;
  return result;
}

void sub_1886682AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886682B8()
{
  _Unwind_Resume(v0);
}

uint64_t kd_precinct_pointer_server::retrieve_byte(kd_precinct_pointer_server *this)
{
  int64_t v2 = (void *)*((void *)this + 1);
  int v3 = *((_DWORD *)this + 6);
  if (v2 != *((void **)this + 2))
  {
    if (v3 != 55) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  if (v3 == 55 && *((int *)this + 7) > 55)
  {
LABEL_6:
    *((void *)this + 1) = *v2;
    *((_DWORD *)this + 6) = 0;
    kd_buf_server::release(*(void *)this, (uint64_t)v2);
    int64_t v2 = (void *)*((void *)this + 1);
    int v3 = *((_DWORD *)this + 6);
  }
LABEL_7:
  *((_DWORD *)this + 6) = v3 + 1;
  return *((unsigned __int8 *)v2 + v3 + 9);
}

void kd_buf_server::~kd_buf_server(kd_buf_server *this)
{
  if (*((_DWORD *)this + 16)) {
    __assert_rtn("~kd_buf_server", "codestream.cpp", 1690, "num_users == 0");
  }
  if (*((void *)this + 3))
  {
    uint64_t v5 = 0;
    long long v3 = 0u;
    long long v4 = 0u;
    kdu_warning::kdu_warning((kdu_warning *)&v3, "Kakadu Core Warning:\n");
    (*(void (**)(long long *, const char *))(v3 + 16))(&v3, "The compressed data buffer server is being destroyed before all allocated buffers have been returned.  The problem is most likely connected with a bug in the code-block destruction code.");
    kdu_warning::~kdu_warning((kdu_warning *)&v3);
  }
  if (*((void *)this + 5))
  {
    uint64_t v5 = 0;
    long long v3 = 0u;
    long long v4 = 0u;
    kdu_warning::kdu_warning((kdu_warning *)&v3, "Kakadu Core Warning:\n");
    (*(void (**)(long long *, const char *))(v3 + 16))(&v3, "The compressed data buffer server is being destroyed before all size accounting associated with fixed data structures has been completed.  This is most likely due to a bug in the memory accounting logic used for dynamic cache management.");
    kdu_warning::~kdu_warning((kdu_warning *)&v3);
  }
  while (1)
  {
    int64_t v2 = *(void **)this;
    if (!*(void *)this) {
      break;
    }
    *(void *)this = *v2;
    free(v2);
  }
}

void *kd_buf_server::alloc_pages(kd_buf_server *this)
{
  uint64_t result = malloc_type_malloc(0x4108uLL, 0xA483F4B5uLL);
  long long v3 = (void *)*((void *)this + 1);
  *uint64_t result = *(void *)this;
  *(void *)this = result;
  uint64_t v4 = -(char)((_BYTE)result + 8);
  unsigned int v5 = 16640 - -(char)((_BYTE)result + 8);
  long long v6 = (void *)((char *)result + v4 + 8);
  uint64_t v7 = *((void *)this + 2);
  uint64_t v8 = (uint64_t)result + v4 + 16;
  do
  {
    uint64_t v9 = 0;
    int v10 = v6;
    int v11 = (unsigned char *)v8;
    do
    {
      *((void *)v11 - 1) = 0;
      *int v11 = v9;
      v11 += 64;
      ++v9;
    }
    while (v9 != 4);
    void *v10 = v3;
    ++v7;
    long long v6 = v10 + 32;
    v8 += 256;
    long long v3 = v10;
    BOOL v12 = v5 > 0x1FF;
    v5 -= 256;
  }
  while (v12);
  *((void *)this + 1) = v10;
  *((void *)this + 2) = v7;
  return result;
}

uint64_t *kd_buf_server::get_page_block(kd_buf_server *this, int a2, uint64_t **a3)
{
  *a3 = 0;
  if (a2 < 1)
  {
    uint64_t result = 0;
  }
  else
  {
    int v5 = a2;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = (uint64_t *)*((void *)this + 1);
    do
    {
      uint64_t v9 = v8;
      if (!v8)
      {
        kd_buf_server::alloc_pages(this);
        uint64_t v7 = 0;
        uint64_t v9 = (uint64_t *)*((void *)this + 1);
      }
      uint64_t v10 = 0;
      uint64_t v8 = (uint64_t *)*v9;
      uint64_t v11 = v9[1] & 0x7F;
      BOOL v12 = &v9[-8 * v11];
      do
      {
        if (SLOBYTE(v9[v10 + 1 + -8 * v11]) < 0)
        {
          uint64_t v7 = v9;
          uint64_t result = (uint64_t *)v6;
          goto LABEL_17;
        }
        v10 += 8;
      }
      while (v10 != 32);
      uint64_t v13 = 0;
      uint64_t v14 = 0;
      if (v7) {
        uint64_t v15 = v7;
      }
      else {
        uint64_t v15 = (void *)((char *)this + 8);
      }
      void *v15 = v8;
      ++*((void *)this + 3);
      int v16 = *a3;
      do
      {
        int v17 = &v12[v13];
        LOBYTE(v12[v13 + 1]) |= 0x80u;
        uint64_t result = &v12[v13];
        if (v16)
        {
          uint64_t *v16 = (uint64_t)v17;
          uint64_t result = (uint64_t *)v6;
        }
        int v16 = &v12[8 * v14];
        *a3 = v17;
        ++v14;
        v13 += 8;
        uint64_t v6 = (uint64_t)result;
      }
      while (v13 != 32);
      --v5;
      v12[24] = 0;
      uint64_t v6 = (uint64_t)result;
LABEL_17:
      ;
    }
    while (v5 > 0);
  }
  uint64_t v19 = *((void *)this + 3);
  if (v19 > *((void *)this + 4)) {
    *((void *)this + 4) = v19;
  }
  return result;
}

int32x2_t kd_thread_buf_server::augment_local_store(kd_thread_buf_server *this, int a2)
{
  *((unsigned char *)this + 40) = 1;
  uint64_t v2 = *(void *)this;
  uint64_t v3 = *(void *)(*(void *)this + 128);
  if (!v3) {
    kd_thread_buf_server::augment_local_store();
  }
  int v5 = *((_DWORD *)this + 2);
  if (v5)
  {
    int v6 = v5 - *((_DWORD *)this + 3);
    if (v6 < 1) {
      return result;
    }
  }
  else
  {
    int v6 = 4 * *((_DWORD *)this + 4) + 4;
    if (v6 <= 32) {
      int v6 = 32;
    }
  }
  unsigned int v7 = (v6 - 1) >> 2;
  int v8 = v7 + 1;
  unsigned int v9 = 4 * (v7 + 1);
  uint64_t v13 = 0;
  if (a2)
  {
    page_block = kd_buf_server::get_page_block(*(kd_buf_server **)(v3 + 48), v7 + 1, &v13);
  }
  else
  {
    kdu_thread_entity::acquire_lock(*(kdu_thread_entity **)(v2 + 136), 0, 1);
    page_block = kd_buf_server::get_page_block(*(kd_buf_server **)(*(void *)(*(void *)this + 128) + 48), v8, &v13);
    kdu_thread_entity::release_lock(*(kdu_thread_entity **)(*(void *)this + 136), 0);
  }
  uint64_t v11 = (uint64_t **)*((void *)this + 4);
  if (!v11) {
    uint64_t v11 = (uint64_t **)((char *)this + 24);
  }
  *uint64_t v11 = page_block;
  *((void *)this + 4) = v13;
  int32x2_t result = vadd_s32(*(int32x2_t *)((char *)this + 12), vdup_n_s32(v9));
  *(int32x2_t *)((char *)this + 12) = result;
  return result;
}

uint64_t kd_thread_env::flush(uint64_t this, int a2)
{
  uint64_t v2 = this + 33168;
  uint64_t v3 = *(void *)(this + 128);
  int v4 = *(_DWORD *)(this + 33208);
  if (v3)
  {
    if (v4 < 1) {
      return this;
    }
    uint64_t v6 = this;
    if (*(void *)(v3 + 64) && *(void *)(this + 360))
    {
      kdu_thread_entity::acquire_lock(*(kdu_thread_entity **)(this + 136), 1, 1);
      int updated = kd_compressed_stats::update_stats(*(kd_compressed_stats **)(*(void *)(v6 + 128) + 64), (kd_compressed_stats *)(v6 + 328));
      uint64_t v8 = *(void *)(v6 + 128);
      if (updated) {
        BOOL v9 = *(unsigned char *)(v8 + 422) == 0;
      }
      else {
        BOOL v9 = 0;
      }
      kd_compressed_stats::update_quant_slope_thresholds(*(void *)(v8 + 64));
      this = kdu_thread_entity::release_lock(*(kdu_thread_entity **)(v6 + 136), 1);
      if (*(int *)(v2 + 40) < 1)
      {
        if (!v9) {
          return this;
        }
        BOOL v9 = 1;
        goto LABEL_35;
      }
    }
    else
    {
      BOOL v9 = 0;
    }
    kdu_thread_entity::acquire_lock(*(kdu_thread_entity **)(v6 + 136), 2, 1);
    char v10 = 0;
    uint64_t v11 = (void *)(v2 + 96);
    for (unsigned int i = 9; i > 1; --i)
    {
      uint64_t v13 = *(v11 - 1);
      if (v13)
      {
        int v14 = *(_DWORD *)(v13 + 36);
        if (v14 <= 0) {
          kd_thread_env::flush();
        }
        if (v14 == 1)
        {
          char v10 = 1;
        }
        else
        {
          if (!*(void *)(*(void *)(v6 + 128) + 8))
          {
            uint64_t v15 = v11 - 6;
            uint64_t v16 = *v11;
            uint64_t v17 = *(v11 - 6);
            *(void *)uint64_t v16 = v17;
            *(void *)(v16 + 8) = v17;
            *(_DWORD *)(v16 + 16) = *((_DWORD *)v11 - 8);
            void *v15 = 0;
            v15[1] = 0;
            uint64_t v13 = *(v11 - 1);
            int v14 = *(_DWORD *)(v13 + 36);
          }
          *(_DWORD *)(v13 + 36) = v14 - 1;
          *(v11 - 1) = 0;
          *uint64_t v11 = 0;
          --*(_DWORD *)(v2 + 40);
        }
      }
      v11 += 7;
    }
    this = kdu_thread_entity::release_lock(*(kdu_thread_entity **)(v6 + 136), 2);
    if (*(_DWORD *)(v2 + 40))
    {
      if ((v10 & 1) == 0) {
        kd_thread_env::flush();
      }
      int v18 = 1;
    }
    else
    {
      *(unsigned char *)(*(void *)(v6 + 136) + 88) = 0;
      int v18 = v10 & 1;
    }
    if (*(unsigned char *)(v2 + 32))
    {
      int v19 = *(_DWORD *)(v2 + 4);
      int v20 = 4 * (*(_DWORD *)(v2 + 8) - v19);
      if (v20 > *(_DWORD *)v2) {
        *(_DWORD *)uint64_t v2 = v20;
      }
      *(_DWORD *)(v2 + 8) = v19;
    }
    if ((v9 | v18))
    {
      if ((v9 | a2) != 1)
      {
        this = kdu_thread_entity::try_lock(*(kdu_thread_entity **)(v6 + 136), 0, 1);
        BOOL v9 = 0;
        if (!this) {
          return this;
        }
        goto LABEL_36;
      }
LABEL_35:
      kdu_thread_entity::acquire_lock(*(kdu_thread_entity **)(v6 + 136), 0, 1);
LABEL_36:
      int v21 = (uint64_t *)(v2 + 48);
      for (unsigned int j = 9; j > 1; --j)
      {
        uint64_t v23 = v21[5];
        if (v23)
        {
          if (!*(void *)(*(void *)(v6 + 128) + 8))
          {
            uint64_t v24 = v21[6];
            uint64_t v25 = *v21;
            *(void *)uint64_t v24 = *v21;
            *(void *)(v24 + 8) = v25;
            *(_DWORD *)(v24 + 16) = *((_DWORD *)v21 + 4);
            *int v21 = 0;
            v21[1] = 0;
          }
          if (*(_DWORD *)(v23 + 36) != 1) {
            kd_thread_env::flush();
          }
          *(_DWORD *)(v23 + 36) = 0;
          v21[5] = 0;
          v21[6] = 0;
          --*(_DWORD *)(v2 + 40);
          uint64_t v26 = *(void *)(v6 + 128);
          if (*(void *)(v26 + 8))
          {
            kd_precinct::release((uint64_t *)v23);
          }
          else if (*(void *)(v26 + 16))
          {
            kd_global_rescomp::add_ready_precinct(*(void *)(*(void *)v23 + 16), (void *)v23);
          }
        }
        v21 += 7;
      }
      long long v27 = *(kdu_thread_entity **)(v6 + 136);
      *((unsigned char *)v27 + 88) = 0;
      if (v9)
      {
        kdu_thread_entity::acquire_lock(v27, 2, 1);
        kd_codestream::trim_compressed_data(*(void *)(v6 + 128));
        kdu_thread_entity::release_lock(*(kdu_thread_entity **)(v6 + 136), 2);
      }
      if (*(unsigned char *)(v2 + 32)) {
        kd_thread_buf_server::augment_local_store((kd_thread_buf_server *)(v6 + 33160), 1);
      }
      this = kdu_thread_entity::release_lock(*(kdu_thread_entity **)(v6 + 136), 0);
      if (*(_DWORD *)(v2 + 40)) {
        kd_thread_env::flush();
      }
    }
  }
  else if (v4)
  {
    kd_thread_env::flush();
  }
  return this;
}

uint64_t kd_compressed_stats::update_stats(kd_compressed_stats *this, kd_compressed_stats *a2)
{
  uint64_t v2 = (int *)((char *)a2 + 32808);
  *((void *)this + 4) += *((void *)a2 + 4);
  *((void *)a2 + 4) = 0;
  int v3 = *((_DWORD *)a2 + 8202);
  if (v3 < *((_DWORD *)this + 8202)) {
    *((_DWORD *)this + 8202) = v3;
  }
  int v4 = *((_DWORD *)a2 + 8203);
  if (v4 > *((_DWORD *)this + 8203))
  {
    *((_DWORD *)this + 8203) = v4;
    int v4 = *((_DWORD *)a2 + 8203);
  }
  uint64_t v5 = *v2;
  if ((int)v5 <= v4)
  {
    uint64_t v6 = 8 * v5 + 40;
    unsigned int v7 = (void *)((char *)a2 + v6);
    uint64_t v8 = (void *)((char *)this + v6);
    int v9 = v4 - v5 + 1;
    do
    {
      *v8++ += *v7;
      *v7++ = 0;
      --v9;
    }
    while (v9);
  }
  *(void *)uint64_t v2 = 4095;
  if (!*((unsigned char *)this + 32824)) {
    return 0;
  }
  uint64_t v10 = *((void *)this + 2);
  if (*((void *)this + 4) <= v10) {
    return 0;
  }
  *((void *)this + 2) = v10 + ((*((void *)this + 1) + 7) >> 4);
  return 1;
}

uint64_t kdu_thread_entity::try_lock(kdu_thread_entity *this, int a2, int a3)
{
  if (a2 < 0
    || *((_DWORD *)this + 12) <= a2
    || (uint64_t v4 = *((void *)this + 7),
        uint64_t v5 = v4 + 80 * a2,
        unsigned int v7 = *(kdu_thread_entity **)(v5 + 72),
        uint64_t v6 = (void *)(v5 + 72),
        v7 == this))
  {
    kdu_thread_entity::try_lock();
  }
  if (a3 && **((unsigned char **)this + 5))
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = *(_DWORD *)(*((void *)this + 5) + 4);
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  uint64_t v8 = v4 + 80 * a2;
  if (!*(unsigned char *)(v8 + 64) || pthread_mutex_trylock((pthread_mutex_t *)v8)) {
    return 0;
  }
  *uint64_t v6 = this;
  return 1;
}

__n128 kd_global_rescomp::add_ready_precinct(uint64_t a1, void *a2)
{
  if (a2[8] || a2[7] || (int v3 = (void *)(a1 + 48), *(void **)(a1 + 48) == a2)) {
    kd_global_rescomp::add_ready_precinct();
  }
  uint64_t v4 = *(void *)(a1 + 56);
  a2[8] = v4;
  if (v4) {
    int v3 = (void *)(v4 + 56);
  }
  void *v3 = a2;
  *(void *)(a1 + 56) = a2;
  uint64_t v5 = *a2;
  uint64_t v6 = (a2[1] - *(void *)(*a2 + 232)) >> 3;
  int v7 = *(_DWORD *)(*a2 + 196);
  int v8 = (int)v6 / v7;
  int v9 = *(_DWORD *)(*a2 + 184);
  LODWORD(v6) = *(_DWORD *)(*a2 + 188) - (int)v6 / v7 * v7 + v6;
  long long v15 = *(_OWORD *)(*a2 + 168);
  LODWORD(v15) = v15 + DWORD2(v15) * (v9 + v8);
  DWORD1(v15) += HIDWORD(v15) * v6;
  kdu_dims::operator&=(&v15, (int *)(v5 + 48));
  *(void *)(a1 + 64) += SDWORD2(v15) * (uint64_t)SHIDWORD(v15);
  __asm { FMOV            V0.2D, #-1.0 }
  *(__n128 *)(a1 + 72) = result;
  return result;
}

uint64_t kd_codestream::trim_compressed_data(uint64_t this)
{
  uint64_t v1 = *(void *)(this + 64);
  if (v1)
  {
    int v2 = 16 * *(_DWORD *)(v1 + 32820);
    unsigned __int16 v3 = v2 < 2 ? 1 : v2 - 1;
    if (v2 >= 2)
    {
      uint64_t v4 = this;
      int v5 = *(_DWORD *)(this + 168);
      uint64_t v6 = *(void *)(this + 352) + 2816 * v5;
      int v7 = 32;
      unsigned int v8 = v3;
      do
      {
        int v19 = v7;
        if (v5 >= 1)
        {
          for (int i = 0; i < v5; ++i)
          {
            uint64_t v10 = *(void **)(v6 + 48);
            if (v10)
            {
              uint64_t v20 = v6;
              do
              {
                uint64_t v11 = *v10;
                if (*(unsigned char *)(*v10 + 222))
                {
                  unint64_t v12 = 0;
                  do
                  {
                    uint64_t v13 = v10[6] + 32 * v12;
                    int v15 = *(_DWORD *)(v13 + 20);
                    int v14 = (_DWORD *)(v13 + 20);
                    if (*(v14 - 1) * v15 >= 1)
                    {
                      uint64_t v16 = 0;
                      uint64_t v17 = 0;
                      int v18 = (void *)(v10[6] + 32 * v12 + 24);
                      do
                      {
                        this = kd_block::trim_data((kd_block *)(*v18 + v16), v8, *(kd_buf_server **)(v4 + 48));
                        ++v17;
                        v16 += 40;
                      }
                      while (v17 < *(v14 - 1) * *v14);
                      uint64_t v11 = *v10;
                    }
                    ++v12;
                  }
                  while (v12 < *(unsigned __int8 *)(v11 + 222));
                }
                uint64_t v10 = (void *)v10[7];
              }
              while (v10);
              int v5 = *(_DWORD *)(v4 + 168);
              uint64_t v6 = v20;
            }
            v6 += 88;
          }
        }
        int v7 = v19 - 1;
        v6 -= 176 * v5;
      }
      while (v19);
    }
  }
  return this;
}

uint64_t kd_packet_sequencer::init(kd_packet_sequencer *this)
{
  uint64_t v1 = *(void *)this;
  if (!*(unsigned char *)(*(void *)this + 292)) {
    kd_packet_sequencer::init();
  }
  *((_DWORD *)this + 2) = 0;
  *((unsigned char *)this + 12) = 1;
  if (*(int *)(v1 + 188) >= 1)
  {
    uint64_t v2 = 0;
    while (1)
    {
      uint64_t v3 = *(void *)(v1 + 272);
      unsigned int v4 = *(_DWORD *)(v3 + 224 * v2 + 68);
      if ((signed int)v4 > *((_DWORD *)this + 2)) {
        *((_DWORD *)this + 2) = v4;
      }
      uint64_t v5 = v3 + 224 * v2;
      uint64_t v6 = (unsigned int *)(v5 + 28);
      int v7 = *(_DWORD *)(v5 + 32);
      if (v7 >= 2) {
        break;
      }
      unsigned int v9 = v7;
LABEL_12:
      if (v9 != 1) {
        goto LABEL_19;
      }
      unsigned int v11 = *v6;
      if ((int)*v6 >= 2)
      {
        while ((v11 & 1) == 0)
        {
          unsigned int v12 = v11 >> 1;
          BOOL v10 = v11 > 3;
          v11 >>= 1;
          if (!v10) {
            goto LABEL_18;
          }
        }
LABEL_19:
        *((unsigned char *)this + 12) = 0;
        goto LABEL_20;
      }
      unsigned int v12 = *v6;
LABEL_18:
      if (v12 != 1) {
        goto LABEL_19;
      }
LABEL_20:
      if ((v4 & 0x80000000) == 0)
      {
        uint64_t v13 = 0;
        uint64_t v14 = v3 + 224 * v2;
        uint64_t v15 = *(void *)(v14 + 176);
        uint64_t v16 = (int *)(v14 + 200);
        uint64_t v17 = (int *)(v14 + 196);
        uint64_t v18 = 704 * v4 + 704;
        while (1)
        {
          uint64_t v19 = v15 + v13;
          int v20 = (*(_DWORD *)(v15 + v13 + 180) << *(unsigned char *)(v15 + v13 + 26)) * v7;
          if (v13)
          {
            int v21 = *v16;
            if (v20 < *v16)
            {
              int *v16 = v20;
              int v21 = v20;
            }
            int v22 = (*(_DWORD *)(v19 + 176) << *(unsigned char *)(v15 + v13 + 27)) * *v6;
            if (v22 >= *v17) {
              goto LABEL_29;
            }
          }
          else
          {
            unsigned int v23 = *v6;
            int *v16 = v20;
            int v22 = (*(_DWORD *)(v19 + 176) << *(unsigned char *)(v19 + 27)) * v23;
            int v21 = v20;
          }
          int *v17 = v22;
LABEL_29:
          v13 += 704;
          if (v18 == v13) {
            goto LABEL_32;
          }
        }
      }
      int v21 = *(_DWORD *)(v3 + 224 * v2 + 200);
LABEL_32:
      int v24 = *(_DWORD *)(v1 + 216);
      int v25 = *(_DWORD *)(v1 + 248);
      uint64_t v26 = (*(_DWORD *)(v1 + 212) - *(_DWORD *)(v1 + 244));
      unint64_t v27 = v26 | ((unint64_t)(v24 - v25) << 32);
      uint64_t v28 = v3 + 224 * v2;
      *(void *)(v28 + 188) = v27;
      char v29 = (int *)(v28 + 188);
      unsigned int v32 = *(_DWORD *)(v28 + 192);
      uint64_t v30 = (int *)(v28 + 192);
      unsigned int v31 = v32;
      if (v21 <= 1) {
        unsigned int v33 = 1;
      }
      else {
        unsigned int v33 = v21;
      }
      if ((v31 & 0x80000000) != 0) {
        unsigned int v34 = ~(~v31 / v33);
      }
      else {
        unsigned int v34 = v31 / v33;
      }
      int v35 = v34 * v21;
      *uint64_t v30 = v35;
      int v36 = v30[1];
      if (v36 <= 1) {
        unsigned int v37 = 1;
      }
      else {
        unsigned int v37 = v30[1];
      }
      unsigned int v38 = v26 / v37;
      unsigned int v39 = ~v26 / v37;
      if ((int)v26 < 0) {
        int v40 = ~v39;
      }
      else {
        int v40 = v38;
      }
      int v41 = v40 * v36;
      int *v29 = v41;
      uint64_t v1 = *(void *)this;
      int v42 = *(_DWORD *)(*(void *)this + 244);
      *uint64_t v30 = v35 + *(_DWORD *)(*(void *)this + 248);
      int *v29 = v42 + v41;
      if (++v2 >= *(int *)(v1 + 188)) {
        goto LABEL_45;
      }
    }
    unsigned int v8 = v7;
    while ((v8 & 1) == 0)
    {
      unsigned int v9 = v8 >> 1;
      BOOL v10 = v8 > 3;
      v8 >>= 1;
      if (!v10) {
        goto LABEL_12;
      }
    }
    goto LABEL_19;
  }
LABEL_45:
  *((void *)this + 2) = (*(_DWORD *)(v1 + 220) + *(_DWORD *)(v1 + 212)) | ((unint64_t)(*(_DWORD *)(v1 + 224) + *(_DWORD *)(v1 + 216)) << 32);
  *((unsigned char *)this + 24) = 0;
  *((void *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;

  return kd_packet_sequencer::next_progression(this);
}

uint64_t kd_packet_sequencer::next_progression(kd_packet_sequencer *this)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (int *)((char *)this + 32);
  uint64_t v3 = (kdu_params *)*((void *)this + 13);
  if (v3)
  {
LABEL_2:
    int v4 = kdu_params::get(v3, "Porder", *((_DWORD *)this + 28), 0, (int *)this + 9, 1, 1, 1);
    uint64_t v5 = (kdu_params *)*((void *)this + 13);
    if (v4)
    {
      int v6 = *((_DWORD *)this + 28);
LABEL_4:
      kdu_params::get(v5, "Porder", v6, 1, (int *)this + 10, 1, 1, 1);
      kdu_params::get(*((kdu_params **)this + 13), "Porder", *((_DWORD *)this + 28), 2, (int *)this + 11, 1, 1, 1);
      kdu_params::get(*((kdu_params **)this + 13), "Porder", *((_DWORD *)this + 28), 3, (int *)this + 12, 1, 1, 1);
      kdu_params::get(*((kdu_params **)this + 13), "Porder", *((_DWORD *)this + 28), 4, (int *)this + 13, 1, 1, 1);
      kdu_params::get(*((kdu_params **)this + 13), "Porder", *((_DWORD *)this + 28), 5, v2, 1, 1, 1);
      if ((*((_DWORD *)this + 10) || *((_DWORD *)this + 9))
        && !*((_DWORD *)this + 28)
        && !*(_DWORD *)(*((void *)this + 13) + 24)
        && !*(_DWORD *)(**(void **)this + 160))
      {
        *(void *)&long long v40 = 0;
        *(_OWORD *)unsigned int v38 = 0u;
        long long v39 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)v38, "Kakadu Core Warning:\n");
        (*(void (**)(char *, const char *))(*(void *)v38 + 16))(v38, "Profile violation detected (code-stream is technically illegal).  In a Profile-0 code-stream, the first progression specification found in the first POC marker segment of the main or any tile header may not describe a progression which starts from resolution or component indices other than 0.");
        *(_DWORD *)(**(void **)this + 160) = 2;
        kdu_warning::~kdu_warning((kdu_warning *)v38);
      }
      ++*((_DWORD *)this + 28);
      uint64_t v7 = *(void *)this;
      int v8 = *(_DWORD *)(*(void *)this + 192);
      if (*((_DWORD *)this + 11) > v8) {
        *((_DWORD *)this + 11) = v8;
      }
      goto LABEL_30;
    }
    int v11 = *((_DWORD *)v5 + 6) + 1;
    unsigned int v12 = (kdu_params *)kdu_params::access_relation(*((kdu_params **)this + 13), *(_DWORD *)(*(void *)this + 8), -1, v11, 1);
    if (v12 && (uint64_t v5 = v12, (kdu_params::get(v12, "Porder", 0, 0, (int *)this + 9, 1, 1, 1) & 1) != 0))
    {
      if (v11 < *(_DWORD *)(*(void *)this + 304))
      {
        int v6 = 0;
        *((void *)this + 13) = v5;
        *((_DWORD *)this + 28) = 0;
        goto LABEL_4;
      }
    }
    else if (!*(void *)(**(void **)this + 8))
    {
      uint64_t v37 = 0;
      memset(v36, 0, sizeof(v36));
      kdu_error::kdu_error((kdu_error *)v36, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v36[0] + 16))(v36, "Supplied progression order attributes for tile ");
      long long v41 = 0u;
      long long v42 = 0u;
      long long v39 = 0u;
      long long v40 = 0u;
      *(_OWORD *)unsigned int v38 = 0u;
      if (BYTE8(v36[0])) {
        sprintf(v38, "%x");
      }
      else {
        sprintf(v38, "%d");
      }
      (*(void (**)(_OWORD *, char *))(*(void *)&v36[0] + 16))(v36, v38);
      (*(void (**)(_OWORD *, const char *))(*(void *)&v36[0] + 16))(v36, " are insuffient to cover all packets for the tile!");
      kdu_error::~kdu_error((kdu_error *)v36);
    }
    return 0;
  }
  unsigned int v9 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(**(void **)this + 24), "POC");
  *((void *)this + 13) = v9;
  if (!v9) {
    kd_packet_sequencer::next_progression();
  }
  BOOL v10 = (kdu_params *)kdu_params::access_relation(v9, *(_DWORD *)(*(void *)this + 8), -1, 0, 1);
  *((void *)this + 13) = v10;
  if (!v10) {
    kd_packet_sequencer::next_progression();
  }
  if (kdu_params::get(v10, "Porder", 0, 0, (int *)this + 9, 1, 1, 1))
  {
    uint64_t v3 = (kdu_params *)*((void *)this + 13);
    if (v3) {
      goto LABEL_2;
    }
  }
  else
  {
    *((void *)this + 13) = 0;
  }
  uint64_t v14 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(**(void **)this + 24), "COD");
  uint64_t v15 = (kdu_params *)kdu_params::access_relation(v14, *(_DWORD *)(*(void *)this + 8), -1, 0, 1);
  if ((kdu_params::get(v15, "Corder", 0, 0, v2, 1, 1, 1) & 1) == 0) {
    kd_packet_sequencer::next_progression();
  }
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 10) = 0;
  uint64_t v7 = *(void *)this;
  *((_DWORD *)this + 11) = *(_DWORD *)(*(void *)this + 192);
  int v16 = *(_DWORD *)(v7 + 188);
  *((_DWORD *)this + 12) = *((_DWORD *)this + 2) + 1;
  *((_DWORD *)this + 13) = v16;
LABEL_30:
  int v17 = *((_DWORD *)this + 13);
  int v18 = *(_DWORD *)(v7 + 188);
  if (v17 > v18)
  {
    *((_DWORD *)this + 13) = v18;
    int v17 = v18;
  }
  int v19 = *((_DWORD *)this + 2);
  if (*((_DWORD *)this + 12) > v19) {
    *((_DWORD *)this + 12) = v19 + 1;
  }
  int v20 = *((_DWORD *)this + 9);
  uint64_t v21 = *((int *)this + 10);
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 15) = v21;
  *((_DWORD *)this + 17) = 0;
  *((_DWORD *)this + 18) = 0;
  int v22 = *((_DWORD *)this + 8);
  *((_DWORD *)this + 16) = v20;
  if ((v22 - 2) < 2)
  {
    if (!*((unsigned char *)this + 12))
    {
      *(void *)&long long v40 = 0;
      *(_OWORD *)unsigned int v38 = 0u;
      long long v39 = 0u;
      kdu_error::kdu_error((kdu_error *)v38, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v38 + 16))(v38, "Attempting to use a spatially progressive packet sequence where position order dominates component order. This is illegal when the component sub-sampling factors are not exact powers of 2!");
      kdu_error::~kdu_error((kdu_error *)v38);
    }
    if (v18 >= 1)
    {
      unint64_t v23 = 0;
      int v24 = *(_DWORD **)(v7 + 272);
      uint64_t v25 = 224 * v18;
      do
      {
        if (v23)
        {
          uint64_t v26 = &v24[v23 / 4];
          int v27 = v24[v23 / 4 + 50];
          if (v27 < *((_DWORD *)this + 22))
          {
            *((_DWORD *)this + 22) = v27;
            *((_DWORD *)this + 20) = v26[48];
          }
          int v28 = v26[49];
          if (v28 >= *((_DWORD *)this + 21)) {
            goto LABEL_46;
          }
        }
        else
        {
          *((_DWORD *)this + 22) = v24[50];
          *((_DWORD *)this + 20) = v24[48];
          int v28 = v24[49];
        }
        *((_DWORD *)this + 21) = v28;
        *((_DWORD *)this + 19) = v24[v23 / 4 + 47];
LABEL_46:
        v23 += 224;
      }
      while (v25 != v23);
    }
    uint64_t v29 = *(void *)((char *)this + 76);
    goto LABEL_51;
  }
  if (v22 == 4 && (int)v21 < v17)
  {
    uint64_t v29 = *(void *)(*(void *)(v7 + 272) + 224 * v21 + 188);
    *(void *)((char *)this + 76) = v29;
    *(void *)((char *)this + 84) = *(void *)(*(void *)(v7 + 272) + 224 * v21 + 196);
LABEL_51:
    *(void *)((char *)this + 92) = v29;
    uint64_t v30 = *(unsigned int *)(v7 + 188);
    if ((int)v30 >= 1)
    {
      uint64_t v31 = 0;
      uint64_t v32 = *(void *)(v7 + 272);
      do
      {
        uint64_t v33 = *(unsigned int *)(v32 + 224 * v31 + 68);
        if ((v33 & 0x80000000) == 0)
        {
          uint64_t v34 = v33 + 1;
          int v35 = (void *)(*(void *)(v32 + 224 * v31 + 176) + 688);
          do
          {
            *int v35 = 0;
            v35 += 88;
            --v34;
          }
          while (v34);
        }
        ++v31;
      }
      while (v31 != v30);
    }
  }
  return 1;
}

void sub_188669710(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

unsigned char *kd_packet_sequencer::save_state(unsigned char *this)
{
  long long v1 = *((_OWORD *)this + 3);
  *(_OWORD *)(this + 120) = *((_OWORD *)this + 2);
  *(_OWORD *)(this + 136) = v1;
  *(_OWORD *)(this + 184) = *((_OWORD *)this + 6);
  long long v2 = *((_OWORD *)this + 4);
  *(_OWORD *)(this + 168) = *((_OWORD *)this + 5);
  *((_DWORD *)this + 50) = *((_DWORD *)this + 28);
  *(_OWORD *)(this + 152) = v2;
  uint64_t v3 = *(void *)this;
  *(_DWORD *)(v3 + 324) = *(_DWORD *)(*(void *)this + 308);
  if (*(int *)(v3 + 188) >= 1)
  {
    uint64_t v4 = 0;
    do
    {
      uint64_t v5 = *(void *)(v3 + 272);
      uint64_t v6 = v5 + 224 * v4;
      int v8 = *(_DWORD *)(v6 + 68);
      uint64_t v7 = (int *)(v6 + 68);
      *(_OWORD *)(v7 + 34) = *(_OWORD *)(v7 + 30);
      if ((v8 & 0x80000000) == 0)
      {
        uint64_t v9 = 0;
        BOOL v10 = (uint64_t *)(v5 + 224 * v4 + 176);
        do
        {
          uint64_t v11 = *v10;
          uint64_t v12 = *v10 + 704 * v9;
          *(void *)(v12 + 696) = *(void *)(v12 + 688);
          int v13 = *(_DWORD *)(v12 + 192) * *(_DWORD *)(v12 + 196);
          if (v13 >= 1)
          {
            uint64_t v14 = 0;
            uint64_t v15 = (void *)(v11 + 704 * v9 + 232);
            uint64_t v16 = 8 * v13;
            do
            {
              uint64_t v17 = *(void *)(*v15 + v14);
              if (v17) {
                BOOL v18 = (*(void *)(*v15 + v14) & 1) == 0;
              }
              else {
                BOOL v18 = 0;
              }
              if (v18) {
                *(_DWORD *)(v17 + 32) = *(_DWORD *)(v17 + 28);
              }
              v14 += 8;
            }
            while (v16 != v14);
          }
        }
        while (v9++ < *v7);
      }
      ++v4;
      uint64_t v3 = *(void *)this;
    }
    while (v4 < *(int *)(*(void *)this + 188));
  }
  this[24] = 1;
  return this;
}

uint64_t *kd_packet_sequencer::restore_state(uint64_t *this)
{
  if (!*((unsigned char *)this + 24)) {
    kd_packet_sequencer::restore_state();
  }
  long long v1 = *(_OWORD *)(this + 17);
  *((_OWORD *)this + 2) = *(_OWORD *)(this + 15);
  *((_OWORD *)this + 3) = v1;
  *((_DWORD *)this + 28) = *((_DWORD *)this + 50);
  long long v2 = *(_OWORD *)(this + 23);
  long long v3 = *(_OWORD *)(this + 19);
  *((_OWORD *)this + 5) = *(_OWORD *)(this + 21);
  *((_OWORD *)this + 6) = v2;
  *((_OWORD *)this + 4) = v3;
  uint64_t v4 = *this;
  *(_DWORD *)(v4 + 308) = *(_DWORD *)(*this + 324);
  if (*(int *)(v4 + 188) >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = *(void *)(v4 + 272);
      uint64_t v7 = v6 + 224 * v5;
      int v9 = *(_DWORD *)(v7 + 68);
      int v8 = (int *)(v7 + 68);
      *(_OWORD *)(v8 + 30) = *(_OWORD *)(v8 + 34);
      if ((v9 & 0x80000000) == 0)
      {
        uint64_t v10 = 0;
        uint64_t v11 = (uint64_t *)(v6 + 224 * v5 + 176);
        do
        {
          uint64_t v12 = *v11;
          uint64_t v13 = *v11 + 704 * v10;
          *(void *)(v13 + 688) = *(void *)(v13 + 696);
          uint64_t v14 = (*(_DWORD *)(v13 + 192) * *(_DWORD *)(v13 + 196));
          if ((int)v14 >= 1)
          {
            uint64_t v15 = *(uint64_t **)(v12 + 704 * v10 + 232);
            do
            {
              uint64_t v17 = *v15++;
              uint64_t v16 = v17;
              uint64_t v18 = v17 & 1;
              if (v17) {
                BOOL v19 = v18 == 0;
              }
              else {
                BOOL v19 = 0;
              }
              if (v19) {
                *(_DWORD *)(v16 + 28) = *(_DWORD *)(v16 + 32);
              }
              --v14;
            }
            while (v14);
          }
        }
        while (v10++ < *v8);
      }
      ++v5;
      uint64_t v4 = *this;
    }
    while (v5 < *(int *)(*this + 188));
  }
  return this;
}

uint64_t *kd_packet_sequencer::next_in_sequence(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  if (*(_DWORD *)(*a1 + 308) == *(_DWORD *)(*a1 + 208)) {
    return 0;
  }
  while (1)
  {
    switch(*((_DWORD *)a1 + 8))
    {
      case 0:
        uint64_t v6 = kd_packet_sequencer::next_in_lrcp(a1, a2, a3);
        break;
      case 1:
        uint64_t v6 = kd_packet_sequencer::next_in_rlcp(a1, a2, a3);
        break;
      case 2:
        uint64_t v6 = (uint64_t *)kd_packet_sequencer::next_in_rpcl(a1, a2, a3);
        break;
      case 3:
        uint64_t v6 = (uint64_t *)kd_packet_sequencer::next_in_pcrl(a1, a2, a3);
        break;
      case 4:
        uint64_t v6 = (uint64_t *)kd_packet_sequencer::next_in_cprl((uint64_t)a1, a2, a3);
        break;
      default:
        kd_packet_sequencer::next_in_sequence();
    }
    uint64_t v7 = v6;
    if (v6) {
      break;
    }
    if ((kd_packet_sequencer::next_progression((kd_packet_sequencer *)a1) & 1) == 0) {
      return 0;
    }
  }
  uint64_t v9 = *v6;
  if (*v6) {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *a1;
  if (*(void *)(*(void *)*a1 + 8) && (!v9 || !*(_DWORD *)(v9 + 28)))
  {
    uint64_t v12 = *(void *)(v10 + 104);
    uint64_t v11 = (kd_precinct_pointer_server *)(v10 + 104);
    if (v12)
    {
      uint64_t v13 = kd_precinct_pointer_server::pop_address(v11);
      if (v13 >= 1)
      {
        if (!kd_precinct_ref::set_address(v7, *a2, *a3, v13)) {
          return 0;
        }
        return v7;
      }
      if ((v13 & 0x8000000000000000) == 0) {
        return v7;
      }
      return 0;
    }
  }
  return v7;
}

uint64_t *kd_packet_sequencer::next_in_lrcp(_DWORD *a1, void *a2, void *a3)
{
  int v3 = a1[11];
  int v4 = a1[14];
  if (v4 >= v3) {
    return 0;
  }
  int v5 = a1[12];
  int v6 = a1[16];
  while (v6 >= v5)
  {
LABEL_25:
    a1[14] = ++v4;
    int v6 = a1[9];
    a1[16] = v6;
    if (v4 == v3) {
      return 0;
    }
  }
  int v7 = a1[13];
  LODWORD(v8) = a1[15];
  uint64_t v9 = v6;
  while ((int)v8 >= v7)
  {
LABEL_24:
    ++v9;
    LODWORD(v8) = a1[10];
    a1[15] = v8;
    a1[16] = v9;
    if (v5 == v9) {
      goto LABEL_25;
    }
  }
  uint64_t v10 = *(void *)(*(void *)a1 + 272);
  uint64_t v8 = (int)v8;
  while (1)
  {
    if (v9 <= *(int *)(v10 + 224 * v8 + 68))
    {
      uint64_t v11 = *(void *)(v10 + 224 * v8 + 176);
      int v12 = *(_DWORD *)(v11 + 704 * v9 + 192);
      uint64_t v13 = (int)a1[17];
      if ((int)v13 < v12) {
        break;
      }
    }
LABEL_23:
    a1[15] = ++v8;
    a1[17] = 0;
    if (v7 == v8) {
      goto LABEL_24;
    }
  }
  uint64_t v14 = v11 + 704 * v9;
  uint64_t v15 = *(int *)(v14 + 196);
  uint64_t v16 = (void *)(v14 + 232);
  int v17 = a1[18];
  uint64_t v18 = 8 * (int)v13 * (uint64_t)(int)v15;
  while (v17 >= (int)v15)
  {
LABEL_22:
    int v17 = 0;
    *(void *)(a1 + 17) = ++v13;
    v18 += 8 * v15;
    if (v12 == v13) {
      goto LABEL_23;
    }
  }
  BOOL v19 = (uint64_t *)(*v16 + v18 + 8 * v17);
  while (1)
  {
    uint64_t v20 = *v19;
    if (!*v19) {
      break;
    }
    if ((v20 & 1) == 0 && !*(unsigned char *)(v20 + 17))
    {
      int v21 = *(_DWORD *)(v20 + 28);
      if (v21 < v4 && v4 != 0) {
        goto LABEL_30;
      }
      if (v21 == v4) {
        goto LABEL_28;
      }
    }
    a1[18] = ++v17;
    ++v19;
    if (v15 == v17) {
      goto LABEL_22;
    }
  }
  if (v4) {
LABEL_30:
  }
    kd_packet_sequencer::next_in_lrcp();
LABEL_28:
  *a2 = v11 + 704 * v9;
  *a3 = *(void *)(a1 + 17);
  return v19;
}

uint64_t *kd_packet_sequencer::next_in_rlcp(_DWORD *a1, void *a2, void *a3)
{
  int v3 = a1[12];
  uint64_t v4 = (int)a1[16];
  if ((int)v4 >= v3) {
    return 0;
  }
  int v5 = a1[11];
  int v6 = a1[14];
  while (v6 >= v5)
  {
LABEL_25:
    int v6 = 0;
    a1[16] = ++v4;
    a1[14] = 0;
    if (v3 == v4) {
      return 0;
    }
  }
  int v7 = a1[13];
  int v8 = a1[15];
  while (v8 >= v7)
  {
LABEL_24:
    ++v6;
    int v8 = a1[10];
    a1[14] = v6;
    a1[15] = v8;
    if (v6 == v5) {
      goto LABEL_25;
    }
  }
  uint64_t v9 = *(void *)(*(void *)a1 + 272);
  uint64_t v10 = v8;
  while (1)
  {
    if (v4 <= *(int *)(v9 + 224 * v10 + 68))
    {
      uint64_t v11 = *(void *)(v9 + 224 * v10 + 176);
      int v12 = *(_DWORD *)(v11 + 704 * v4 + 192);
      uint64_t v13 = (int)a1[17];
      if ((int)v13 < v12) {
        break;
      }
    }
LABEL_23:
    a1[15] = ++v10;
    a1[17] = 0;
    if (v7 == v10) {
      goto LABEL_24;
    }
  }
  uint64_t v14 = v11 + 704 * v4;
  uint64_t v15 = *(int *)(v14 + 196);
  uint64_t v16 = (void *)(v14 + 232);
  int v17 = a1[18];
  uint64_t v18 = 8 * (int)v13 * (uint64_t)(int)v15;
  while (v17 >= (int)v15)
  {
LABEL_22:
    int v17 = 0;
    *(void *)(a1 + 17) = ++v13;
    v18 += 8 * v15;
    if (v12 == v13) {
      goto LABEL_23;
    }
  }
  BOOL v19 = (uint64_t *)(*v16 + v18 + 8 * v17);
  while (1)
  {
    uint64_t v20 = *v19;
    if (!*v19) {
      break;
    }
    if ((v20 & 1) == 0 && !*(unsigned char *)(v20 + 17))
    {
      int v21 = *(_DWORD *)(v20 + 28);
      if (v21 < v6 && v6 != 0) {
        goto LABEL_30;
      }
      if (v21 == v6) {
        goto LABEL_28;
      }
    }
    a1[18] = ++v17;
    ++v19;
    if (v15 == v17) {
      goto LABEL_22;
    }
  }
  if (v6) {
LABEL_30:
  }
    kd_packet_sequencer::next_in_rlcp();
LABEL_28:
  *a2 = v11 + 704 * v4;
  *a3 = *(void *)(a1 + 17);
  return v19;
}

uint64_t kd_packet_sequencer::next_in_rpcl(uint64_t *a1, void *a2, void *a3)
{
  if (*((int *)a1 + 11) >= 1)
  {
    int v3 = *((_DWORD *)a1 + 16);
    int v4 = *((_DWORD *)a1 + 12);
    if (v3 < v4)
    {
      int v5 = *((_DWORD *)a1 + 23);
      int v6 = *((_DWORD *)a1 + 4);
      while (1)
      {
        if (v5 < v6)
        {
          int v7 = *((_DWORD *)a1 + 24);
          int v8 = *((_DWORD *)a1 + 5);
          do
          {
            if (v7 < v8)
            {
              int v9 = *((_DWORD *)a1 + 15);
              int v10 = *((_DWORD *)a1 + 13);
              do
              {
                if (v9 < v10)
                {
                  while (1)
                  {
                    uint64_t v11 = *a1;
                    uint64_t v12 = *(void *)(*a1 + 272);
                    int v13 = *((_DWORD *)a1 + 16);
                    if (v13 <= *(_DWORD *)(v12 + 224 * v9 + 68))
                    {
                      uint64_t v14 = *(void *)(v12 + 224 * v9 + 176);
                      uint64_t v15 = v14 + 704 * v13;
                      uint64_t v16 = *(void *)(v15 + 688);
                      *(uint64_t *)((char *)a1 + 68) = v16;
                      unint64_t v17 = HIDWORD(v16);
                      int v18 = *(_DWORD *)(v15 + 196);
                      if (v18 > SHIDWORD(v16) && *(_DWORD *)(v14 + 704 * v13 + 192) > (int)v16)
                      {
                        uint64_t v19 = *(void *)(v14 + 704 * v13 + 232) + 8 * (v16 >> 32);
                        int v20 = v18 * v16;
                        uint64_t v21 = *(void *)(v19 + 8 * v18 * (int)v16);
                        if (v21
                          && ((v21 & 1) != 0 || *(unsigned char *)(v21 + 17) || *(_DWORD *)(v21 + 28) >= *((_DWORD *)a1 + 11)))
                        {
                          *((_DWORD *)a1 + 18) = HIDWORD(v16) + 1;
                          if (HIDWORD(v16) + 1 >= v18) {
                            *(uint64_t *)((char *)a1 + 68) = (v16 + 1);
                          }
                          *(void *)(v15 + 688) = *(uint64_t *)((char *)a1 + 68);
                          int v9 = *((_DWORD *)a1 + 15);
                          int v10 = *((_DWORD *)a1 + 13);
                        }
                        else
                        {
                          int v23 = *(_DWORD *)(v15 + 184);
                          uint64_t v22 = v15 + 184;
                          int v24 = *(_DWORD *)(v11 + 244)
                              + (((v23 + v16) * *(_DWORD *)(v14 + 704 * v13 + 176)) << *(unsigned char *)(v14 + 704 * v13 + 27))
                              * *(_DWORD *)(v12 + 224 * v9 + 28);
                          if (v24 < *((_DWORD *)a1 + 19) || v24 == *((_DWORD *)a1 + 23))
                          {
                            int v25 = *(_DWORD *)(v11 + 248)
                                + (((*(_DWORD *)(v22 + 4) + v17) * *(_DWORD *)(v14 + 704 * v13 + 180)) << *(unsigned char *)(v14 + 704 * v13 + 26))
                                * *(_DWORD *)(v12 + 224 * v9 + 32);
                            if (v25 < *((_DWORD *)a1 + 20) || v25 == *((_DWORD *)a1 + 24))
                            {
                              uint64_t v26 = v19 + 8 * v20;
                              *a2 = v14 + 704 * v13;
                              *a3 = *(uint64_t *)((char *)a1 + 68);
                              return v26;
                            }
                          }
                        }
                      }
                    }
                    *((_DWORD *)a1 + 15) = ++v9;
                    if (v9 >= v10)
                    {
                      int v7 = *((_DWORD *)a1 + 24);
                      int v8 = *((_DWORD *)a1 + 5);
                      break;
                    }
                  }
                }
                v7 += *((_DWORD *)a1 + 22);
                *((_DWORD *)a1 + 24) = v7;
                int v9 = *((_DWORD *)a1 + 10);
                *((_DWORD *)a1 + 15) = v9;
              }
              while (v7 < v8);
              int v5 = *((_DWORD *)a1 + 23);
              int v6 = *((_DWORD *)a1 + 4);
            }
            int v7 = *((_DWORD *)a1 + 20);
            v5 += *((_DWORD *)a1 + 21);
            *((_DWORD *)a1 + 23) = v5;
            *((_DWORD *)a1 + 24) = v7;
          }
          while (v5 < v6);
          int v3 = *((_DWORD *)a1 + 16);
          int v4 = *((_DWORD *)a1 + 12);
        }
        uint64_t v26 = 0;
        *((_DWORD *)a1 + 16) = ++v3;
        int v5 = *((_DWORD *)a1 + 19);
        *((_DWORD *)a1 + 23) = v5;
        if (v3 >= v4) {
          return v26;
        }
      }
    }
  }
  return 0;
}

uint64_t kd_packet_sequencer::next_in_pcrl(uint64_t *a1, void *a2, void *a3)
{
  if (*((int *)a1 + 11) >= 1)
  {
    int v3 = *((_DWORD *)a1 + 23);
    int v4 = *((_DWORD *)a1 + 4);
    if (v3 < v4)
    {
      int v5 = *((_DWORD *)a1 + 24);
      int v6 = *((_DWORD *)a1 + 5);
      while (1)
      {
        if (v5 < v6)
        {
          LODWORD(v7) = *((_DWORD *)a1 + 15);
          int v8 = *((_DWORD *)a1 + 13);
          do
          {
            if ((int)v7 < v8)
            {
              int v9 = *((_DWORD *)a1 + 16);
              int v10 = *((_DWORD *)a1 + 12);
              do
              {
                if (v9 < v10)
                {
                  uint64_t v11 = *a1;
                  uint64_t v12 = *(void *)(*a1 + 272);
                  LODWORD(v7) = *((_DWORD *)a1 + 15);
                  if (v9 <= *(_DWORD *)(v12 + 224 * (int)v7 + 68))
                  {
                    uint64_t v7 = (int)v7;
                    while (1)
                    {
                      uint64_t v13 = *(void *)(v12 + 224 * v7 + 176);
                      uint64_t v14 = v13 + 704 * v9;
                      uint64_t v15 = *(void *)(v14 + 688);
                      *(uint64_t *)((char *)a1 + 68) = v15;
                      unint64_t v16 = HIDWORD(v15);
                      int v17 = *(_DWORD *)(v14 + 196);
                      if (v17 > SHIDWORD(v15) && *(_DWORD *)(v13 + 704 * v9 + 192) > (int)v15)
                      {
                        uint64_t v18 = *(void *)(v13 + 704 * v9 + 232) + 8 * (v15 >> 32);
                        int v19 = v17 * v15;
                        uint64_t v20 = *(void *)(v18 + 8 * v17 * (int)v15);
                        if (v20
                          && ((v20 & 1) != 0 || *(unsigned char *)(v20 + 17) || *(_DWORD *)(v20 + 28) >= *((_DWORD *)a1 + 11)))
                        {
                          *((_DWORD *)a1 + 18) = HIDWORD(v15) + 1;
                          if (HIDWORD(v15) + 1 >= v17) {
                            *(uint64_t *)((char *)a1 + 68) = (v15 + 1);
                          }
                          *(void *)(v14 + 688) = *(uint64_t *)((char *)a1 + 68);
                          int v9 = *((_DWORD *)a1 + 16);
                          int v10 = *((_DWORD *)a1 + 12);
                        }
                        else
                        {
                          int v22 = *(_DWORD *)(v14 + 184);
                          uint64_t v21 = v14 + 184;
                          int v23 = *(_DWORD *)(v11 + 244)
                              + (((v22 + v15) * *(_DWORD *)(v13 + 704 * v9 + 176)) << *(unsigned char *)(v13 + 704 * v9 + 27))
                              * *(_DWORD *)(v12 + 224 * v7 + 28);
                          if (v23 < *((_DWORD *)a1 + 19) || v23 == *((_DWORD *)a1 + 23))
                          {
                            int v24 = *(_DWORD *)(v11 + 248)
                                + (((*(_DWORD *)(v21 + 4) + v16) * *(_DWORD *)(v13 + 704 * v9 + 180)) << *(unsigned char *)(v13 + 704 * v9 + 26))
                                * *(_DWORD *)(v12 + 224 * v7 + 32);
                            if (v24 < *((_DWORD *)a1 + 20) || v24 == *((_DWORD *)a1 + 24))
                            {
                              uint64_t v26 = v18 + 8 * v19;
                              *a2 = v13 + 704 * v9;
                              *a3 = *(uint64_t *)((char *)a1 + 68);
                              return v26;
                            }
                          }
                        }
                      }
                      *((_DWORD *)a1 + 16) = v9 + 1;
                      if (v9 + 1 >= v10)
                      {
                        LODWORD(v7) = *((_DWORD *)a1 + 15);
                        break;
                      }
                      uint64_t v11 = *a1;
                      uint64_t v12 = *(void *)(*a1 + 272);
                      uint64_t v7 = *((int *)a1 + 15);
                      if (v9++ >= *(_DWORD *)(v12 + 224 * v7 + 68))
                      {
                        LODWORD(v7) = *((_DWORD *)a1 + 15);
                        break;
                      }
                    }
                  }
                  int v8 = *((_DWORD *)a1 + 13);
                }
                LODWORD(v7) = v7 + 1;
                int v9 = *((_DWORD *)a1 + 9);
                *((_DWORD *)a1 + 15) = v7;
                *((_DWORD *)a1 + 16) = v9;
              }
              while ((int)v7 < v8);
              int v5 = *((_DWORD *)a1 + 24);
              int v6 = *((_DWORD *)a1 + 5);
            }
            v5 += *((_DWORD *)a1 + 22);
            *((_DWORD *)a1 + 24) = v5;
            LODWORD(v7) = *((_DWORD *)a1 + 10);
            *((_DWORD *)a1 + 15) = v7;
          }
          while (v5 < v6);
          int v3 = *((_DWORD *)a1 + 23);
          int v4 = *((_DWORD *)a1 + 4);
        }
        uint64_t v26 = 0;
        int v5 = *((_DWORD *)a1 + 20);
        v3 += *((_DWORD *)a1 + 21);
        *((_DWORD *)a1 + 23) = v3;
        *((_DWORD *)a1 + 24) = v5;
        if (v3 >= v4) {
          return v26;
        }
      }
    }
  }
  return 0;
}

uint64_t kd_packet_sequencer::next_in_cprl(uint64_t a1, void *a2, void *a3)
{
  if (*(int *)(a1 + 44) >= 1)
  {
    LODWORD(v3) = *(_DWORD *)(a1 + 60);
    int v4 = *(_DWORD *)(a1 + 52);
    if ((int)v3 < v4)
    {
      LODWORD(v5) = *(_DWORD *)(a1 + 92);
      int v6 = *(_DWORD *)(a1 + 16);
      while (1)
      {
        if ((int)v5 < v6)
        {
          uint64_t v7 = *(void *)(*(void *)a1 + 272) + 224 * (int)v3;
          int v8 = (_DWORD *)(v7 + 68);
          int v9 = (uint64_t *)(v7 + 176);
          int v10 = (_DWORD *)(v7 + 28);
          uint64_t v11 = (_DWORD *)(v7 + 32);
          int v12 = *(_DWORD *)(a1 + 96);
          int v13 = *(_DWORD *)(a1 + 20);
          do
          {
            if (v12 < v13)
            {
              int v14 = *(_DWORD *)(a1 + 64);
              int v15 = *(_DWORD *)(a1 + 48);
              do
              {
                if (v14 < v15)
                {
                  if (v14 <= *v8)
                  {
                    while (1)
                    {
                      uint64_t v16 = *v9;
                      uint64_t v17 = *v9 + 704 * v14;
                      uint64_t v18 = *(void *)(v17 + 688);
                      *(void *)(a1 + 68) = v18;
                      int v19 = *(_DWORD *)(v17 + 196);
                      if (v19 > SHIDWORD(v18) && *(_DWORD *)(v16 + 704 * v14 + 192) > (int)v18)
                      {
                        uint64_t v20 = *(void *)(v16 + 704 * v14 + 232) + 8 * (v18 >> 32);
                        int v21 = v19 * v18;
                        uint64_t v22 = *(void *)(v20 + 8 * v19 * (int)v18);
                        if (v22
                          && ((v22 & 1) != 0 || *(unsigned char *)(v22 + 17) || *(_DWORD *)(v22 + 28) >= *(_DWORD *)(a1 + 44)))
                        {
                          *(_DWORD *)(a1 + 72) = HIDWORD(v18) + 1;
                          if (HIDWORD(v18) + 1 >= v19) {
                            *(void *)(a1 + 68) = (v18 + 1);
                          }
                          *(void *)(v17 + 688) = *(void *)(a1 + 68);
                          int v14 = *(_DWORD *)(a1 + 64);
                          int v15 = *(_DWORD *)(a1 + 48);
                        }
                        else
                        {
                          int v24 = *(_DWORD *)(v17 + 184);
                          uint64_t v23 = v17 + 184;
                          int v25 = *(_DWORD *)(*(void *)a1 + 244)
                              + (((v24 + v18) * *(_DWORD *)(v16 + 704 * v14 + 176)) << *(unsigned char *)(v16 + 704 * v14 + 27))
                              * *v10;
                          if (v25 < *(_DWORD *)(a1 + 76) || v25 == *(_DWORD *)(a1 + 92))
                          {
                            int v26 = *(_DWORD *)(*(void *)a1 + 248)
                                + (((*(_DWORD *)(v23 + 4) + HIDWORD(v18)) * *(_DWORD *)(v16 + 704 * v14 + 180)) << *(unsigned char *)(v16 + 704 * v14 + 26))
                                * *v11;
                            if (v26 < *(_DWORD *)(a1 + 80) || v26 == *(_DWORD *)(a1 + 96))
                            {
                              uint64_t v29 = v20 + 8 * v21;
                              *a2 = v16 + 704 * v14;
                              *a3 = *(void *)(a1 + 68);
                              return v29;
                            }
                          }
                        }
                      }
                      *(_DWORD *)(a1 + 64) = v14 + 1;
                      if (v14 + 1 < v15 && v14++ < *v8) {
                        continue;
                      }
                      break;
                    }
                  }
                  int v12 = *(_DWORD *)(a1 + 96);
                  int v13 = *(_DWORD *)(a1 + 20);
                }
                v12 += *(_DWORD *)(a1 + 88);
                *(_DWORD *)(a1 + 96) = v12;
                int v14 = *(_DWORD *)(a1 + 36);
                *(_DWORD *)(a1 + 64) = v14;
              }
              while (v12 < v13);
              LODWORD(v5) = *(_DWORD *)(a1 + 92);
              int v6 = *(_DWORD *)(a1 + 16);
            }
            int v12 = *(_DWORD *)(a1 + 80);
            LODWORD(v5) = v5 + *(_DWORD *)(a1 + 84);
            *(_DWORD *)(a1 + 92) = v5;
            *(_DWORD *)(a1 + 96) = v12;
          }
          while ((int)v5 < v6);
          LODWORD(v3) = *(_DWORD *)(a1 + 60);
          int v4 = *(_DWORD *)(a1 + 52);
        }
        uint64_t v3 = (int)v3 + 1;
        *(_DWORD *)(a1 + 60) = v3;
        if ((int)v3 >= v4) {
          break;
        }
        uint64_t v28 = *(void *)(*(void *)a1 + 272) + 224 * v3;
        uint64_t v5 = *(void *)(v28 + 188);
        *(void *)(a1 + 76) = v5;
        *(void *)(a1 + 84) = *(void *)(v28 + 196);
        *(void *)(a1 + 92) = v5;
      }
    }
  }
  return 0;
}

uint64_t *kd_global_rescomp::close_all(uint64_t *this)
{
  uint64_t v1 = this[6];
  this[7] = v1;
  if (v1)
  {
    long long v2 = this;
    do
    {
      v2[6] = *(void *)(v1 + 56);
      *(void *)(v1 + 56) = 0;
      *(void *)(v1 + 64) = 0;
      this = kd_precinct_ref::close(*(uint64_t **)(v1 + 8));
      uint64_t v1 = v2[6];
      v2[7] = v1;
    }
    while (v1);
  }
  return this;
}

__n128 kd_global_rescomp::initialize(kd_global_rescomp *this, kd_codestream *a2, int a3, int a4)
{
  kd_global_rescomp::close_all((uint64_t *)this);
  *(void *)this = a2;
  *((_DWORD *)this + 2) = a3;
  *((_DWORD *)this + 3) = a4;
  int v8 = *((_DWORD *)a2 + 66);
  int v9 = *((_DWORD *)a2 + 67);
  uint64_t v10 = *((void *)a2 + 39);
  uint64_t v11 = (unsigned int *)(v10 + 104 * a4);
  if ((int)v11[1] <= 1) {
    unsigned int v12 = 1;
  }
  else {
    unsigned int v12 = v11[1];
  }
  if (v9 <= 0) {
    signed int v13 = ~(-v9 / v12);
  }
  else {
    signed int v13 = (v9 - 1) / v12;
  }
  int v14 = *((_DWORD *)a2 + 69) + v9;
  if ((int)*v11 <= 1) {
    unsigned int v15 = 1;
  }
  else {
    unsigned int v15 = *v11;
  }
  if (v8 <= 0) {
    signed int v16 = ~(-v8 / v15);
  }
  else {
    signed int v16 = (v8 - 1) / v15;
  }
  int v17 = *((_DWORD *)a2 + 68) + v8;
  if (v14 <= 0) {
    signed int v18 = ~(-v14 / v12);
  }
  else {
    signed int v18 = (v14 - 1) / v12;
  }
  if (v17 <= 0) {
    signed int v19 = ~(-v17 / v15);
  }
  else {
    signed int v19 = (v17 - 1) / v15;
  }
  uint64_t v20 = v10 + 104 * a4 + a3;
  uint64_t v21 = ((v19 >> *(unsigned char *)(v20 + 54)) - (v16 >> *(unsigned char *)(v20 + 54)))
      * (uint64_t)((v18 >> *(unsigned char *)(v20 + 21)) - (v13 >> *(unsigned char *)(v20 + 21)));
  *((void *)this + 2) = v21;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = v21;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 6) = 0;
  __asm { FMOV            V0.2D, #-1.0 }
  *(__n128 *)((char *)this + 72) = result;
  return result;
}

__n128 kd_global_rescomp::notify_tile_status(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 312);
  int v5 = *(_DWORD *)(a1 + 12);
  int v6 = (unsigned int *)(v4 + 104 * v5);
  if ((int)v6[1] <= 1) {
    unsigned int v7 = 1;
  }
  else {
    unsigned int v7 = v6[1];
  }
  if (a2 <= 0) {
    signed int v8 = ~(-HIDWORD(a2) / v7);
  }
  else {
    signed int v8 = (HIDWORD(a2) - 1) / v7;
  }
  int v9 = HIDWORD(a3) + HIDWORD(a2);
  if ((int)*v6 <= 1) {
    unsigned int v10 = 1;
  }
  else {
    unsigned int v10 = *v6;
  }
  if ((int)a2 <= 0) {
    signed int v11 = ~(-(int)a2 / v10);
  }
  else {
    signed int v11 = ((int)a2 - 1) / v10;
  }
  int v12 = a3 + a2;
  if (v9 <= 0) {
    signed int v13 = ~(-v9 / v7);
  }
  else {
    signed int v13 = (v9 - 1) / v7;
  }
  if (v12 <= 0) {
    signed int v14 = ~(-v12 / v10);
  }
  else {
    signed int v14 = (v12 - 1) / v10;
  }
  uint64_t v15 = v4 + 104 * v5 + *(int *)(a1 + 8);
  uint64_t v16 = ((v14 >> *(unsigned char *)(v15 + 54)) - (v11 >> *(unsigned char *)(v15 + 54)))
      * (uint64_t)((v13 >> *(unsigned char *)(v15 + 21)) - (v8 >> *(unsigned char *)(v15 + 21)));
  uint64_t v17 = *(void *)(a1 + 32) + v16;
  *(void *)(a1 + 32) = v17;
  if (a4) {
    *(void *)(a1 + 24) += v16;
  }
  else {
    *(void *)(a1 + 40) -= v16;
  }
  if (v17 > *(void *)(a1 + 16) || (*(void *)(a1 + 40) & 0x8000000000000000) != 0) {
    kd_global_rescomp::notify_tile_status();
  }
  __asm { FMOV            V0.2D, #-1.0 }
  *(__n128 *)(a1 + 72) = result;
  return result;
}

uint64_t *kd_global_rescomp::close_ready_precinct(kd_global_rescomp *this, kd_precinct *a2)
{
  uint64_t v4 = *((void *)a2 + 8);
  if (v4)
  {
    *(void *)(v4 + 56) = *((void *)a2 + 7);
    uint64_t v5 = *((void *)a2 + 7);
    if (v5)
    {
LABEL_3:
      int v6 = (void *)(v5 + 64);
      goto LABEL_7;
    }
  }
  else
  {
    if (*((kd_precinct **)this + 6) != a2) {
      kd_global_rescomp::close_ready_precinct();
    }
    uint64_t v5 = *((void *)a2 + 7);
    *((void *)this + 6) = v5;
    if (v5) {
      goto LABEL_3;
    }
  }
  int v6 = (void *)((char *)this + 56);
  if (*((kd_precinct **)this + 7) != a2) {
    kd_global_rescomp::close_ready_precinct();
  }
LABEL_7:
  *int v6 = v4;
  *((void *)a2 + 7) = 0;
  *((void *)a2 + 8) = 0;
  uint64_t v7 = *(void *)a2;
  uint64_t v8 = (*((void *)a2 + 1) - *(void *)(*(void *)a2 + 232)) >> 3;
  int v9 = *(_DWORD *)(*(void *)a2 + 196);
  int v10 = (int)v8 / v9;
  int v11 = *(_DWORD *)(*(void *)a2 + 184);
  LODWORD(v8) = *(_DWORD *)(*(void *)a2 + 188) - (int)v8 / v9 * v9 + v8;
  long long v20 = *(_OWORD *)(*(void *)a2 + 168);
  LODWORD(v20) = v20 + DWORD2(v20) * (v11 + v10);
  DWORD1(v20) += HIDWORD(v20) * v8;
  kdu_dims::operator&=(&v20, (int *)(v7 + 48));
  int v13 = DWORD2(v20);
  int v12 = HIDWORD(v20);
  *((void *)this + 8) -= SDWORD2(v20) * (uint64_t)SHIDWORD(v20);
  *((void *)this + 5) -= v13 * (uint64_t)v12;
  __asm { FMOV            V0.2D, #-1.0 }
  *(_OWORD *)((char *)this + 72) = _Q0;
  return kd_precinct_ref::close(*((uint64_t **)a2 + 1));
}

unsigned char *kd_codestream_comment::set_text(unsigned char *this, int a2, unsigned __int8 *a3)
{
  if (*this) {
    kd_codestream_comment::set_text();
  }
  uint64_t v4 = this;
  *this = 1;
  unsigned int v5 = a2 - 1;
  if (a2 >= 1)
  {
    if (*((_DWORD *)this + 1) < a2)
    {
      *((_DWORD *)this + 1) = a2;
      uint64_t v6 = *((void *)this + 2);
      if (v6) {
        MEMORY[0x18C11C0C0](v6, 0x1000C8077774924);
      }
      operator new[]();
    }
    uint64_t v7 = (void *)*((void *)this + 2);
    void v4[2] = a2;
    this = memcpy(v7, a3, a2);
    uint64_t v8 = *((void *)v4 + 2);
    if (*(unsigned char *)(v8 + v5)) {
      *(unsigned char *)(v8 + a2) = 0;
    }
    else {
      --v4[2];
    }
  }
  return this;
}

uint64_t kd_codestream_comment::write_marker(kd_codestream_comment *this, kdu_output *a2, int a3)
{
  *(unsigned char *)this = 1;
  if (!a3)
  {
    int v8 = 0;
    if (!a2) {
      return (v8 + *((_DWORD *)this + 2) + 6);
    }
    goto LABEL_10;
  }
  if (a3 <= 6) {
    int v5 = 6;
  }
  else {
    int v5 = a3;
  }
  int v6 = v5 - 6;
  int v7 = *((_DWORD *)this + 2);
  int v8 = v6 - v7;
  if (v6 < v7)
  {
    int v8 = 0;
    *((_DWORD *)this + 2) = v6;
    *(unsigned char *)(*((void *)this + 2) + v6) = 0;
  }
  if (a2)
  {
LABEL_10:
    kdu_output::put(a2, 255);
    kdu_output::put(a2, 100);
    int v9 = v8 + *((_DWORD *)this + 2) + 4;
    kdu_output::put(a2, (unsigned __int16)(v8 + *((_WORD *)this + 4) + 4) >> 8);
    kdu_output::put(a2, v9);
    kdu_output::put(a2, 0);
    kdu_output::put(a2, 1);
    kdu_output::write(a2, *((char **)this + 2), *((_DWORD *)this + 2));
    if (v8 >= 1)
    {
      int v10 = v8;
      do
      {
        kdu_output::put(a2, 0);
        --v10;
      }
      while (v10);
    }
  }
  return (v8 + *((_DWORD *)this + 2) + 6);
}

uint64_t kdu_codestream_comment::put_text(kdu_codestream_comment *this, const char *__s)
{
  uint64_t v2 = *(void *)this;
  if (!*(void *)this || *(unsigned char *)v2) {
    return 0;
  }
  int v5 = *(_DWORD *)(v2 + 8) + strlen(__s);
  int v6 = *(_DWORD *)(v2 + 4);
  if (v5 > v6)
  {
    *(_DWORD *)(v2 + 4) = v5 + v6 + 80;
    operator new[]();
  }
  *(_DWORD *)(v2 + 8) = v5;
  strcat(*(char **)(v2 + 16), __s);
  return 1;
}

void kd_mct_stage::create_stages(void *a1, uint64_t *a2, kdu_params *this, int a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  *a2 = 0;
  *a1 = 0;
  int v9 = (kdu_params *)kdu_params::access_cluster(this, "MCO");
  int v34 = 0;
  if (v9)
  {
    uint64_t v23 = (kdu_params *)kdu_params::access_relation(v9, a4, -1, 0, 1);
    if (v23)
    {
      int v10 = kdu_params::get(v23, "Mnum_stages", 0, 0, &v34, 1, 1, 1);
      int v11 = v34 ? v10 : 0;
      if (v11 == 1)
      {
        int v26 = (kdu_params *)kdu_params::access_cluster(this, "MCC");
        kdu_params::access_cluster(this, "MCT");
        if (v34 >= 1)
        {
          __asm { FMOV            V10.2S, #1.0 }
          int v32 = 0;
          int v33 = 0;
          if ((kdu_params::get(v23, "Mstages", 0, 0, &v33, 1, 1, 1) & (v26 != 0)) == 1)
          {
            uint64_t v17 = (kdu_params *)kdu_params::access_relation(v26, a4, -1, v33, 1);
            uint64_t v29 = v17;
            if (v17)
            {
              if (kdu_params::get(v17, "Mstage_collections", 0, 0, &v32, 1, 1, 1)
                && (kdu_params::get(v29, "Mstage_collections", 0, 1, &v32, 1, 1, 1) & 1) != 0)
              {
                operator new();
              }
            }
          }
          uint64_t v31 = 0;
          memset(v30, 0, sizeof(v30));
          kdu_error::kdu_error((kdu_error *)v30, "Kakadu Core Error:\n");
          (*(void (**)(_OWORD *, const char *))(*(void *)&v30[0] + 16))(v30, "Unable to access the description of stage ");
          long long v38 = 0u;
          long long v39 = 0u;
          long long v37 = 0u;
          *(_OWORD *)int v35 = 0u;
          long long v36 = 0u;
          if (BYTE8(v30[0])) {
            sprintf(v35, "%x");
          }
          else {
            sprintf(v35, "%d");
          }
          (*(void (**)(_OWORD *, char *))(*(void *)&v30[0] + 16))(v30, v35);
          kdu_error::~kdu_error((kdu_error *)v30);
        }
        uint64_t v18 = *a2;
        int v19 = *(_DWORD *)(*a2 + 16);
        if (v19 > a7)
        {
          *(void *)&long long v37 = 0;
          *(_OWORD *)int v35 = 0u;
          long long v36 = 0u;
          kdu_error::kdu_error((kdu_error *)v35, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)v35);
        }
        if (v19 >= 1)
        {
          uint64_t v20 = 0;
          uint64_t v21 = 0;
          do
          {
            uint64_t v22 = *(void *)(v18 + 24) + v20;
            *(unsigned char *)(v22 + 4) = *(unsigned char *)(a8 + v20 + 4);
            *(_DWORD *)uint64_t v22 = *(_DWORD *)(a8 + v20);
            if (a4 < 0 && !*(void *)(v22 + 8))
            {
              *(void *)&long long v37 = 0;
              *(_OWORD *)int v35 = 0u;
              long long v36 = 0u;
              kdu_error::kdu_error((kdu_error *)v35, "Kakadu Core Error:\n");
              (*(void (**)(char *, const char *))(*(void *)v35 + 16))(v35, "Although not strictly illegal, the present Part-2 codestream contains insufficient information to determine the dimensions of all image components output by the multi-component transform, based on main header marker segments.  The fact that this is not illegal is almost certainly an oversight in the development of the Part-2 syntax, but Kakadu cannot work with such codestreams.");
              kdu_error::~kdu_error((kdu_error *)v35);
            }
            ++v21;
            v20 += 48;
          }
          while (v21 < *(int *)(v18 + 16));
        }
        kd_mct_stage::apply_output_restrictions((int *)v18, a8, 0, 0);
      }
    }
  }
}

void sub_18866C2B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
}

void sub_18866C2C0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  _Unwind_Resume(v41);
}

void kd_mct_stage::apply_output_restrictions(int *a1, uint64_t a2, unsigned int a3, unsigned int *a4)
{
  uint64_t v5 = a3;
  do
  {
    a1[5] = 0;
    uint64_t v6 = *((void *)a1 + 7);
    if (v6)
    {
      if (a2 || (uint64_t v7 = a1[4], v7 != *(_DWORD *)v6)) {
        kd_mct_stage::apply_output_restrictions();
      }
      if ((int)v7 < 1)
      {
        int v8 = 0;
      }
      else
      {
        int v8 = 0;
        uint64_t v9 = 0;
        uint64_t v10 = *((void *)a1 + 3);
        uint64_t v11 = *(void *)(v6 + 8);
        uint64_t v12 = v10 + 20;
        do
        {
          *(_DWORD *)uint64_t v12 = 0;
          if ((*(_DWORD *)(v11 + 4 * v9) & 0x80000000) != 0)
          {
            *(_DWORD *)(v12 - 4) = -1;
            *(unsigned char *)(v12 + 20) = 0;
          }
          else
          {
            *(_DWORD *)(v10 + 48 * v8 + 20) = v9;
            *(_DWORD *)(v12 - 4) = v8;
            a1[5] = v8 + 1;
            *(unsigned char *)(v12 + 20) = 1;
            if (*(_DWORD *)(v11 + 4 * v9) != v8++) {
              kd_mct_stage::apply_output_restrictions();
            }
          }
          ++v9;
          v12 += 48;
        }
        while (v7 != v9);
      }
      if (v8 != *(_DWORD *)(v6 + 4)) {
        kd_mct_stage::apply_output_restrictions();
      }
      goto LABEL_35;
    }
    if (!a2) {
      kd_mct_stage::apply_output_restrictions();
    }
    uint64_t v14 = a1[4];
    if ((int)v14 < 1)
    {
      int v15 = 0;
      if (!a4) {
        goto LABEL_35;
      }
      goto LABEL_29;
    }
    int v15 = 0;
    uint64_t v16 = (uint64_t *)(a2 + 16);
    uint64_t v17 = (BOOL *)(*((void *)a1 + 3) + 40);
    do
    {
      uint64_t v18 = *v16;
      *((void *)v17 - 3) = *v16;
      BOOL *v17 = 0;
      if ((v18 & 0x80000000) != 0) {
        goto LABEL_22;
      }
      a1[5] = ++v15;
      if (v5)
      {
        if (a4) {
          goto LABEL_22;
        }
        BOOL v19 = (int)v18 < (int)v5;
      }
      else
      {
        BOOL v19 = 1;
      }
      BOOL *v17 = v19;
LABEL_22:
      v16 += 6;
      v17 += 48;
      --v14;
    }
    while (v14);
    if (!a4) {
      goto LABEL_35;
    }
LABEL_29:
    if ((int)v5 >= 1)
    {
      do
      {
        unsigned int v21 = *a4++;
        unsigned int v20 = v21;
        if ((v21 & 0x80000000) == 0 && (int)v20 < v15)
        {
          uint64_t v22 = *((void *)a1 + 3);
          int v23 = *(_DWORD *)(v22 + 48 * v20 + 20);
          if (*(_DWORD *)(v22 + 48 * v23 + 16) != v20) {
            kd_mct_stage::apply_output_restrictions();
          }
          *(unsigned char *)(v22 + 48 * v23 + 40) = 1;
        }
        --v5;
      }
      while (v5);
    }
LABEL_35:
    a1[1] = 0;
    if (*a1 >= 1)
    {
      uint64_t v24 = 0;
      uint64_t v25 = *((void *)a1 + 1);
      do
        *(_DWORD *)(v25 + 4 * v24++) = -1;
      while (v24 < *a1);
    }
    if (a1[8] >= 1)
    {
      uint64_t v26 = 0;
      while (1)
      {
        uint64_t v27 = *((void *)a1 + 5);
        uint64_t v28 = v27 + 152 * v26;
        *(_DWORD *)(v28 + 12) = 0;
        uint64_t v29 = (_DWORD *)(v28 + 12);
        uint64_t v30 = (_DWORD *)(v28 + 8);
        size_t v31 = *(unsigned int *)(v28 + 8);
        if (*(int *)(v28 + 8) >= 1)
        {
          uint64_t v32 = v27;
          bzero(*(void **)(v27 + 152 * v26 + 24), v31);
          uint64_t v27 = v32;
          uint64_t v30 = (_DWORD *)(v28 + 8);
        }
        uint64_t v33 = v27 + 152 * v26;
        *(_DWORD *)(v33 + 36) = 0;
        int v34 = (_DWORD *)(v33 + 36);
        uint64_t v35 = *(v34 - 1);
        if ((int)v35 < 1) {
          goto LABEL_58;
        }
        int v36 = 0;
        uint64_t v37 = *((void *)a1 + 3);
        uint64_t v38 = v27 + 152 * v26;
        long long v41 = *(int **)(v38 + 40);
        uint64_t v40 = (int **)(v38 + 40);
        long long v39 = v41;
        uint64_t v42 = *(v34 - 1);
        do
        {
          int v44 = *v39++;
          int v43 = v44;
          if (*(unsigned char *)(v37 + 48 * v44 + 40))
          {
            if ((*(_DWORD *)(v37 + 48 * v43 + 16) & 0x80000000) != 0 || *(void *)(v37 + 48 * v43 + 24) != v28) {
              kd_mct_stage::apply_output_restrictions();
            }
            *(_DWORD *)(v37 + 48 * v43 + 36) = v36++;
            *int v34 = v36;
          }
          --v42;
        }
        while (v42);
        if (!v36) {
          goto LABEL_58;
        }
        if (v36 != v31 && !*(void *)(v27 + 152 * v26 + 72)) {
          break;
        }
        if ((int)v31 >= 1)
        {
          int16x8_t v45 = v30;
          uint64_t v46 = v27;
          memset(*(void **)(v27 + 152 * v26 + 24), 1, v31);
          uint64_t v27 = v46;
          uint64_t v30 = v45;
          _DWORD *v29 = v31;
LABEL_54:
          uint64_t v47 = 0;
          uint64_t v48 = v27 + 152 * v26;
          uint64_t v49 = *(void *)(v48 + 24);
          int v50 = (void *)(v48 + 16);
          do
          {
            if (*(unsigned char *)(v49 + v47))
            {
              *(_DWORD *)(*((void *)a1 + 1) + 4 * *(int *)(*v50 + 4 * v47)) = 0;
              LODWORD(v31) = *v30;
            }
            ++v47;
          }
          while (v47 < (int)v31);
        }
LABEL_58:
        if (++v26 >= a1[8]) {
          goto LABEL_129;
        }
      }
      if (*(void *)(v27 + 152 * v26 + 80))
      {
        size_t v51 = 0;
        uint64_t v52 = 0;
        uint64_t v53 = *((void *)a1 + 3);
        int v54 = *v40;
        do
        {
          if (*(unsigned __int8 *)(v53 + 48 * v54[v52++] + 40))
          {
            _DWORD *v29 = v52;
            size_t v51 = v52;
          }
        }
        while (v35 != v52);
        if ((int)v51 >= 1)
        {
          int v56 = v30;
          uint64_t v57 = v27;
          memset(*(void **)(v27 + 152 * v26 + 24), 1, v51);
          uint64_t v27 = v57;
          uint64_t v30 = v56;
        }
      }
      else if (*(unsigned char *)(v27 + 152 * v26 + 57))
      {
        int v58 = 0;
        for (uint64_t i = 0; i != v35; ++i)
        {
          if (i < (int)v31 && *(unsigned char *)(*((void *)a1 + 3) + 48 * (*v40)[i] + 40))
          {
            *(unsigned char *)(*(void *)(v27 + 152 * v26 + 24) + i) = 1;
            _DWORD *v29 = ++v58;
          }
        }
      }
      else
      {
        int v60 = *(unsigned char **)(v27 + 152 * v26 + 144);
        uint64_t v110 = v27;
        int v111 = v30;
        if (!v60) {
          operator new[]();
        }
        if ((int)v31 >= 1)
        {
          uint64_t v61 = *((void *)a1 + 3);
          int v62 = *v40;
          size_t v63 = v31;
          uint64_t v64 = *(unsigned char **)(v27 + 152 * v26 + 144);
          do
          {
            int v65 = *v62++;
            *v64++ = *(unsigned char *)(v61 + 48 * v65 + 40);
            --v63;
          }
          while (v63);
        }
        uint64_t v66 = v27 + 152 * v26;
        int v67 = *(_DWORD *)(v66 + 92);
        int v68 = *(_DWORD *)(v66 + 96);
        int v69 = v68 + v31;
        if (v67 >= 1)
        {
          int v70 = 0;
          int v71 = &v60[(int)v31];
          uint64_t v72 = v27 + 152 * v26;
          int v73 = (void *)(v72 + 24);
          int v109 = v60;
          int v108 = v67;
          int v106 = (_DWORD *)(v72 + 124);
          int v107 = v71;
          int v104 = (_DWORD *)(v72 + 132);
          int v105 = (_DWORD *)(v72 + 120);
          int v102 = (void *)(v72 + 24);
          int v103 = (_DWORD *)(v72 + 128);
          do
          {
            uint64_t v74 = v68;
            int v75 = &v71[-v68];
            if (v68 < v69)
            {
              int v76 = &v60[-v68];
              int v112 = v70;
              bzero(v71, (v69 + ~v68) + 1);
              int v73 = v102;
              int v71 = v107;
              int v70 = v112;
              int v67 = v108;
              int v60 = v109;
              uint64_t v27 = v110;
              uint64_t v30 = v111;
              uint64_t v77 = v74;
              do
              {
                if (v76[v77])
                {
                  int v78 = ((v77 - *v106) & 1) + v77 - *v106;
                  int v79 = (v77 - *v105) & 0xFFFFFFFE;
                  while (v78 <= v79)
                  {
                    BOOL v80 = v78 < (int)v74;
                    if (v78 < (int)v74 || (int v81 = v78, v78 >= v69))
                    {
                      int v81 = v78;
                      do
                      {
                        if (v80) {
                          int v82 = 2 * v74;
                        }
                        else {
                          int v82 = 2 * v69 - 2;
                        }
                        int v81 = v82 - v81;
                        BOOL v80 = v81 < (int)v74;
                      }
                      while (v81 < (int)v74 || v81 >= v69);
                    }
                    v75[v81] = 1;
                    v78 += 2;
                  }
                  int v84 = (v77 - *v104) | 1;
                  int v85 = v77 - *v103 + ((v77 - *v103) | 0xFFFFFFFE) + 1;
                  while (v84 <= v85)
                  {
                    BOOL v86 = v84 < (int)v74;
                    if (v84 < (int)v74 || (int v87 = v84, v84 >= v69))
                    {
                      int v87 = v84;
                      do
                      {
                        if (v86) {
                          int v88 = 2 * v74;
                        }
                        else {
                          int v88 = 2 * v69 - 2;
                        }
                        int v87 = v88 - v87;
                        BOOL v86 = v87 < (int)v74;
                      }
                      while (v87 < (int)v74 || v87 >= v69);
                    }
                    v75[v87] = 1;
                    v84 += 2;
                  }
                }
                ++v77;
              }
              while (v77 != v69);
            }
            LODWORD(v90) = v69 + (~(_BYTE)v69 | 0xFFFFFFFE);
            if ((int)v90 >= (int)(v74 | 1))
            {
              uint64_t v90 = (int)v90;
              uint64_t v91 = v31 - 1;
              do
              {
                if ((int)v31 <= 0) {
                  kd_mct_stage::apply_output_restrictions();
                }
                *(unsigned char *)(*v73 + v91) = v75[v90];
                *v29 += v75[v90];
                v90 -= 2;
                LODWORD(v31) = v31 - 1;
                --v91;
              }
              while (v90 >= (int)(v74 | 1));
            }
            int v68 = ((int)v74 + 1) >> 1;
            int v69 = (v69 + 1) >> 1;
            if (v68 < v69)
            {
              int v92 = 2 * v68;
              uint64_t v93 = v69 - (uint64_t)v68;
              uint64_t v94 = v60;
              do
              {
                *v94++ = v75[v92];
                v92 += 2;
                --v93;
              }
              while (v93);
            }
            ++v70;
          }
          while (v70 != v67);
        }
        if (v69 > v68)
        {
          uint64_t v95 = v69;
          uint64_t v96 = v31 - 1;
          uint64_t v97 = (uint64_t)&v60[-v68 - 1];
          do
          {
            if ((int)v31 <= 0) {
              kd_mct_stage::apply_output_restrictions();
            }
            *(unsigned char *)(*(void *)(v27 + 152 * v26 + 24) + v96) = *(unsigned char *)(v97 + v95);
            *v29 += *(unsigned __int8 *)(v97 + v95);
            LODWORD(v31) = v31 - 1;
            --v96;
            --v95;
          }
          while (v95 > v68);
        }
        if (v31) {
          kd_mct_stage::apply_output_restrictions();
        }
        LODWORD(v31) = *v30;
      }
      if ((int)v31 < 1) {
        goto LABEL_58;
      }
      goto LABEL_54;
    }
LABEL_129:
    if (a1[1]) {
      kd_mct_stage::apply_output_restrictions();
    }
    int v98 = *a1;
    if (*a1 >= 1)
    {
      uint64_t v99 = 0;
      uint64_t v100 = *((void *)a1 + 1);
      do
      {
        if ((*(_DWORD *)(v100 + 4 * v99) & 0x80000000) == 0)
        {
          int v101 = a1[1];
          a1[1] = v101 + 1;
          *(_DWORD *)(v100 + 4 * v99) = v101;
          int v98 = *a1;
        }
        ++v99;
      }
      while (v99 < v98);
    }
    a2 = 0;
    uint64_t v5 = 0;
    a4 = 0;
    a1 = (int *)*((void *)a1 + 6);
  }
  while (a1);
}

uint64_t kd_mct_block::analyze_sensitivity(uint64_t this, int a2, float a3, int *a4, int *a5, char a6)
{
  if (*(unsigned char *)(this + 57))
  {
    int v7 = *(_DWORD *)(*(void *)(this + 40) + 4 * a2);
    uint64_t v8 = *(void *)(*(void *)this + 24);
    if (*(unsigned char *)(v8 + 48 * v7 + 40) || (a6 & 1) == 0)
    {
      uint64_t v9 = *a4;
      int v10 = *a5;
      if ((int)v9 <= *a5)
      {
        if ((int)v9 > v7)
        {
          uint64_t v26 = (_DWORD *)(v8 + 48 * (int)v9 - 4);
          do
          {
            --v9;
            _DWORD *v26 = 0;
            v26 -= 12;
          }
          while (v9 > v7);
          *a4 = v9;
          int v10 = *a5;
        }
        if (v10 < v7)
        {
          uint64_t v27 = v7 - (uint64_t)v10;
          uint64_t v28 = (_DWORD *)(v8 + 48 * v10 + 92);
          do
          {
            _DWORD *v28 = 0;
            v28 += 12;
            --v27;
          }
          while (v27);
          *a5 = v7;
        }
      }
      else
      {
        *a5 = v7;
        *a4 = v7;
        *(_DWORD *)(v8 + 48 * v7 + 44) = 0;
      }
      *(float *)(v8 + 48 * v7 + 44) = *(float *)(v8 + 48 * v7 + 44) + a3;
    }
  }
  else
  {
    if (!*(void *)(this + 48))
    {
      is_mul_ok(*(int *)(this + 8), 0x18uLL);
      operator new[]();
    }
    uint64_t v11 = *(void *)(this + 48);
    if (*(__int16 *)(v11 + 24 * a2 + 2) >= 1)
    {
      uint64_t v12 = 0;
      uint64_t v13 = *(unsigned __int16 *)(v11 + 24 * a2 + 2);
      uint64_t v14 = (__int16 *)(v11 + 24 * a2);
      uint64_t v17 = *v14;
      int v15 = (uint64_t *)(v14 + 4);
      uint64_t v16 = v17;
      uint64_t v18 = *(void *)(this + 40);
      uint64_t v19 = *(void *)(*(void *)this + 24);
      do
      {
        this = *(unsigned int *)(v18 + 4 * (v12 + v16));
        if (*(unsigned char *)(v19 + 48 * (int)this + 40) || (a6 & 1) == 0)
        {
          int v20 = *(_DWORD *)(v18 + 4 * (v12 + v16));
          uint64_t v21 = *a4;
          int v22 = *a5;
          if ((int)v21 <= *a5)
          {
            if ((int)v21 > (int)this)
            {
              int v23 = (_DWORD *)(v19 - 4 + 48 * (int)v21);
              do
              {
                --v21;
                _DWORD *v23 = 0;
                v23 -= 12;
              }
              while (v21 > (int)this);
              *a4 = v21;
              int v22 = *a5;
            }
            if (v22 < (int)this)
            {
              uint64_t v24 = (int)this - (uint64_t)v22;
              uint64_t v25 = (_DWORD *)(v19 + 92 + 48 * v22);
              do
              {
                *uint64_t v25 = 0;
                v25 += 12;
                --v24;
              }
              while (v24);
              *a5 = this;
            }
          }
          else
          {
            *a5 = this;
            *a4 = this;
            *(_DWORD *)(v19 + 48 * (int)this + 44) = 0;
          }
          this = *v15;
          *(float *)(v19 + 48 * v20 + 44) = *(float *)(v19 + 48 * v20 + 44)
                                            + (float)(a3 * *(float *)(*v15 + 4 * v12));
        }
        ++v12;
      }
      while (v12 != v13);
    }
  }
  return this;
}

void kd_mct_block::create_matrix_ss_model(kd_mct_block *this)
{
}

void kd_mct_block::create_rxform_ss_model(kd_mct_block *this)
{
  if (*((_DWORD *)this + 2) == *((_DWORD *)this + 8)) {
    operator new[]();
  }
  kd_mct_block::create_rxform_ss_model();
}

void kd_mct_block::create_dependency_ss_model(kd_mct_block *this)
{
  if (*((_DWORD *)this + 2) == *((_DWORD *)this + 8)) {
    operator new[]();
  }
  kd_mct_block::create_dependency_ss_model();
}

uint64_t kd_mct_block::create_dwt_ss_model(kd_mct_block *this)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  int v60 = *((_DWORD *)this + 2);
  if (v60 != *((_DWORD *)this + 8)) {
    kd_mct_block::create_dwt_ss_model();
  }
  uint64_t v1 = this;
  uint64_t result = *((void *)this + 18);
  int v71 = v1;
  if (!result) {
    operator new[]();
  }
  int v63 = *((_DWORD *)v1 + 23);
  if (v63 >= 1)
  {
    int v59 = 0;
    uint64_t v3 = result - 4 * *((int *)v1 + 24);
    int v61 = v60 - 1;
    while (1)
    {
      BOOL v4 = v63 != *((_DWORD *)v1 + 23);
      int v5 = v63 - 1;
      do
      {
        uint64_t result = v4;
        BOOL v62 = v4 << v5;
        int v6 = *((_DWORD *)v1 + 24) + ~(v4 << v5);
        int v7 = (v6 + v60) >> v63;
        int v58 = v6 >> v63;
        if (v6 >> v63 < v7)
        {
          uint64_t v8 = (4 * result) ^ 4;
          uint64_t v66 = (char *)&v81[-2] + v8;
          int v67 = (float *)((char *)v1 + 4 * result + 136);
          int v65 = (char *)&v79 + v8;
          uint64_t v70 = result;
          LODWORD(v9) = ((v58 + 1) << v63) + v62;
          *(_DWORD *)(v3 + 4 * (int)v9) = 1065353216;
          int v10 = *((_DWORD *)v1 + 24);
          int v11 = v10 - 1;
          __int16 v64 = v10;
          int v12 = v61 + v10;
          int v13 = v9;
          int v14 = v63 - 1;
          int v68 = v61 + v10;
          int v69 = v10 - 1;
          while (1)
          {
            int v15 = ((v11 >> v14) + 1) << v14;
            uint64_t v16 = v12 & (-1 << v14);
            BOOL v17 = v13 >= v15 && (int)v9 <= (int)v16;
            if (!v17) {
              kd_mct_block::create_dwt_ss_model();
            }
            if (v15 == v16)
            {
              if (v13 != v9) {
                kd_mct_block::create_dwt_ss_model();
              }
              if (result && v14 == v5) {
                *(float *)(v3 + 4 * (int)v9) = *(float *)(v3 + 4 * (int)v9) * 0.5;
              }
              int v13 = v9;
              goto LABEL_84;
            }
            int v18 = 1 << v14;
            v82[0] = (v15 & (1 << v14)) + v15;
            v82[1] = v15 | (1 << v14);
            v81[0] = v16 - (v16 & (1 << v14));
            v81[1] = v16 - v18 + (v16 & v18);
            uint64_t v79 = 0;
            uint64_t v80 = 0;
            int v19 = 2 << v14;
            if (v14 == v5)
            {
              if (v13 != v9) {
                kd_mct_block::create_dwt_ss_model();
              }
              *(float *)(v3 + 4 * (int)v9) = *v67 * *(float *)(v3 + 4 * (int)v9);
              *((_DWORD *)&v79 + result) = v9;
              v81[result - 2] = v9;
              uint64_t v21 = v65;
              int v20 = v66;
            }
            else
            {
              if (((v9 | v13) & v18) != 0) {
                kd_mct_block::create_dwt_ss_model();
              }
              if (v13 <= (int)v9)
              {
                uint64_t v22 = v13;
                do
                {
                  *(float *)(v3 + 4 * v22) = *((float *)v1 + 34) * *(float *)(v3 + 4 * v22);
                  v22 += v19;
                }
                while (v22 <= (int)v9);
              }
              LODWORD(v23) = v13 + v18;
              if (v13 + v18 < (int)v9)
              {
                uint64_t v23 = (int)v23;
                do
                {
                  *(_DWORD *)(v3 + 4 * v23) = 0;
                  v23 += v19;
                }
                while (v23 < (int)v9);
              }
              LODWORD(v80) = v13;
              LODWORD(v79) = v9;
              uint64_t v21 = (_DWORD *)&v79 + 1;
              int v20 = (_DWORD *)&v80 + 1;
            }
            *int v20 = 0;
            *uint64_t v21 = -1;
            uint64_t v24 = *((unsigned int *)v1 + 22);
            if ((int)v24 >= 1) {
              break;
            }
LABEL_84:
            BOOL v17 = v14-- <= 0;
            if (v17)
            {
              uint64_t v57 = (_WORD *)(*((void *)v1 + 6) + 24 * v59);
              *uint64_t v57 = v13 - v64;
              v57[1] = v9 - v13 + 1;
              operator new[]();
            }
          }
          uint64_t v25 = (int *)*((void *)v1 + 13);
          uint64_t v26 = (float *)*((void *)v1 + 14);
          uint64_t v27 = *((unsigned int *)v1 + 22);
          uint64_t v72 = v26;
          do
          {
            uint64_t v28 = *v25;
            v25 += 4;
            v26 += v28;
            --v27;
          }
          while (v27);
          uint64_t v29 = *((void *)v1 + 13);
          int v73 = v14;
          char v78 = v14 + 1;
          int v75 = 2 * v15;
          int v30 = *((unsigned __int8 *)v1 + 101);
          int v74 = 2 * v16;
          int v77 = v15;
          uint64_t v76 = v29;
          while (2)
          {
            char v31 = v24 - 1;
            uint64_t v32 = (int *)(v29 + 16 * (v24 - 1));
            uint64_t v33 = *v32;
            v26 -= v33;
            if ((v24 - 1)) {
              int v34 = v18;
            }
            else {
              int v34 = -v18;
            }
            int v35 = *(_DWORD *)((unint64_t)&v80 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v31 & 1)));
            int v36 = *(_DWORD *)((unint64_t)&v79 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v31 & 1)));
            if (v35 <= v36)
            {
              int v37 = v32[1];
              int v38 = (v37 << v78) + v34;
              int v39 = ((v33 + v37 - 1) << v78) + v34;
              BOOL v40 = !(((_BYTE)v24 - 1) & 1);
              LODWORD(v41) = v35 - v39;
              int v42 = v82[v40];
              if (v35 - v39 < v42 || v75 - v42 - v38 >= v35) {
                LODWORD(v41) = v82[v40];
              }
              int v43 = v36 - v38;
              int v44 = v81[v40];
              if (v36 - v38 > v44 || v74 - v44 - v39 <= v36) {
                int v43 = v81[v40];
              }
              int v45 = v81[v40 - 2];
              int v46 = *((_DWORD *)&v79 + v40);
              if (v45 > v46)
              {
                v81[v40 - 2] = v41;
                goto LABEL_47;
              }
              if ((int)v41 >= v45)
              {
                if (v43 > v46) {
LABEL_47:
                }
                  *((_DWORD *)&v79 + v40) = v43;
              }
              else
              {
                v81[v40 - 2] = v41;
              }
              for (; v13 > (int)v41; v13 -= v18)
                *(_DWORD *)(v3 + 4 * (v13 - v18)) = 0;
              if ((int)v9 < v43)
              {
                uint64_t v47 = (int)v9;
                do
                {
                  uint64_t v9 = v47 + v18;
                  *(_DWORD *)(v3 + 4 * v18 + 4 * v47) = 0;
                  uint64_t v47 = v9;
                }
                while (v9 < v43);
              }
              int v48 = v15;
              int v49 = v16;
              if (!v30)
              {
                int v48 = *(_DWORD *)((unint64_t)v82 | (4 * (v31 & 1)));
                int v49 = *(_DWORD *)((unint64_t)v81 & 0xFFFFFFFFFFFFFFFBLL | (4 * (v31 & 1)));
              }
              if ((int)v41 <= v43)
              {
                uint64_t v50 = v16;
                uint64_t v41 = (int)v41;
                do
                {
                  if (v38 <= v39)
                  {
                    int v51 = v38;
                    uint64_t v52 = v26;
                    do
                    {
                      int v53 = v51 + v41;
                      BOOL v54 = v51 + (int)v41 < v48;
                      if (v51 + (int)v41 < v48 || v53 > v49)
                      {
                        do
                        {
                          if (v30)
                          {
                            int v56 = 2 * v49 - v53;
                            int v53 = 2 * v48 - v53;
                            if (!v54) {
                              int v53 = v56;
                            }
                          }
                          else if (v54)
                          {
                            int v53 = v48;
                          }
                          else
                          {
                            int v53 = v49;
                          }
                          BOOL v54 = v53 < v48;
                        }
                        while (v53 < v48 || v53 > v49);
                      }
                      if (v53 >= v35 && v53 <= v36) {
                        *(float *)(v3 + 4 * v41) = *(float *)(v3 + 4 * v41) - (float)(*(float *)(v3 + 4 * v53) * *v52);
                      }
                      v51 += v19;
                      ++v52;
                    }
                    while (v51 <= v39);
                  }
                  v41 += v19;
                }
                while (v41 <= v43);
                int v15 = v77;
                uint64_t v16 = v50;
                uint64_t v29 = v76;
              }
            }
            BOOL v17 = v24-- <= 1;
            if (v17)
            {
              uint64_t v1 = v71;
              int v11 = v69;
              int v5 = v63 - 1;
              uint64_t result = v70;
              int v12 = v68;
              int v14 = v73;
              if (v26 != v72) {
                kd_mct_block::create_dwt_ss_model();
              }
              goto LABEL_84;
            }
            continue;
          }
        }
        int v59 = v59 + v7 - v58;
        BOOL v4 = 1;
      }
      while (!result);
      BOOL v17 = v63-- <= 1;
      if (v17) {
        goto LABEL_92;
      }
    }
  }
  int v59 = 0;
LABEL_92:
  if (v59 != *((_DWORD *)v1 + 2)) {
    kd_mct_block::create_dwt_ss_model();
  }
  return result;
}

void kd_codestream::construct_common(kd_codestream *this)
{
  *(_WORD *)((char *)this + 281) = 257;
  *((unsigned char *)this + 420) = 0;
  *((void *)this + 36) = 0x3FF0000000000000;
  (*(void (**)(void, BOOL))(**((void **)this + 3) + 72))(*((void *)this + 3), *((void *)this + 2) == 0);
  if (kdu_params::get(*((kdu_params **)this + 3), "Sprofile", 0, 0, (int *)this + 40, 1, 1, 1))
  {
    if (kdu_params::get(*((kdu_params **)this + 3), "Scomponents", 0, 0, (int *)this + 42, 1, 1, 1))
    {
      if (kdu_params::get(*((kdu_params **)this + 3), "Ssize", 0, 0, (int *)this + 49, 1, 1, 1))
      {
        if (kdu_params::get(*((kdu_params **)this + 3), "Ssize", 0, 1, (int *)this + 50, 1, 1, 1))
        {
          if (kdu_params::get(*((kdu_params **)this + 3), "Sorigin", 0, 0, (int *)this + 47, 1, 1, 1))
          {
            if (kdu_params::get(*((kdu_params **)this + 3), "Sorigin", 0, 1, (int *)this + 48, 1, 1, 1))
            {
              if (kdu_params::get(*((kdu_params **)this + 3), "Stiles", 0, 0, (int *)this + 53, 1, 1, 1))
              {
                if (kdu_params::get(*((kdu_params **)this + 3), "Stiles", 0, 1, (int *)this + 54, 1, 1, 1))
                {
                  int v7 = (int *)((char *)this + 204);
                  if (kdu_params::get(*((kdu_params **)this + 3), "Stile_origin", 0, 0, (int *)this + 51, 1, 1, 1))
                  {
                    uint64_t v8 = (int *)((char *)this + 208);
                    if (kdu_params::get(*((kdu_params **)this + 3), "Stile_origin", 0, 1, (int *)this + 52, 1, 1, 1))
                    {
                      if (*((_DWORD *)this + 40)) {
                        int v2 = -1;
                      }
                      else {
                        int v2 = 0;
                      }
                      *((_DWORD *)this + 114) = v2;
                      int v3 = *((_DWORD *)this + 47);
                      int v4 = *((_DWORD *)this + 48);
                      int v5 = *((_DWORD *)this + 50) - v4;
                      int v6 = *((_DWORD *)this + 49) - v3;
                      *((_DWORD *)this + 49) = v6;
                      *((_DWORD *)this + 50) = v5;
                      if (v6 >= 1
                        && v5 >= 1
                        && *v8 <= v4
                        && *v7 <= v3
                        && *((_DWORD *)this + 54) + *v8 > v4
                        && *((_DWORD *)this + 53) + *v7 > v3)
                      {
                        is_mul_ok(*((int *)this + 42), 0x68uLL);
                        operator new[]();
                      }
                      uint64_t v10 = 0;
                      memset(v9, 0, sizeof(v9));
                      kdu_error::kdu_error((kdu_error *)v9, "Kakadu Core Error:\n");
                      (*(void (**)(_OWORD *, const char *))(*(void *)&v9[0] + 16))(v9, "Illegal canvas coordinates: the first tile is required to have a non-empty intersection with the image on the high resolution grid.");
                      kdu_error::~kdu_error((kdu_error *)v9);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  kd_codestream::construct_common();
}

void sub_18866E948(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

void kd_codestream::read_main_header(kd_codestream *this)
{
  if (*((void *)this + 1))
  {
    char v2 = 0;
    int v3 = (__int16 *)*((void *)this + 4);
    while ((kd_marker::read((kd_marker *)v3, 0, 0) & 1) != 0)
    {
      uint64_t v4 = *((void *)this + 4);
      int v5 = *(unsigned __int16 *)(v4 + 16);
      switch(v5)
      {
        case 65365:
          uint64_t v7 = *((void *)this + 9);
          if (v7) {
            kd_tpart_pointer_server::add_tlm_marker(v7, v4);
          }
          char v2 = 1;
          break;
        case 65380:
          if (*(int *)(v4 + 20) >= 3)
          {
            uint64_t v8 = *(unsigned char **)(v4 + 32);
            if (!*v8 && v8[1] == 1) {
              operator new();
            }
          }
          break;
        case 65376:
          if (*((unsigned char *)this + 418))
          {
            uint64_t v18 = 0;
            long long v16 = 0u;
            long long v17 = 0u;
            kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v16 + 16))(&v16, "You cannot use PPM or PPT marker segments (packed packet headers) with cached compressed data sources.");
            kdu_error::~kdu_error((kdu_error *)&v16);
          }
          if (!*((_DWORD *)this + 40))
          {
            uint64_t v18 = 0;
            long long v16 = 0u;
            long long v17 = 0u;
            kdu_warning::kdu_warning((kdu_warning *)&v16, "Kakadu Core Warning:\n");
            (*(void (**)(long long *, const char *))(v16 + 16))(&v16, "Profile violation detected (code-stream is technically illegal).  PPM marker segments may not appear within a Profile-0 code-stream.  You should set \"Sprofile\" to 1 or 2.");
            *((_DWORD *)this + 40) = 2;
            kdu_warning::~kdu_warning((kdu_warning *)&v16);
          }
          uint64_t v6 = *((void *)this + 5);
          if (!v6) {
            operator new();
          }
          kd_pp_markers::add_marker(v6, *((void *)this + 4));
        default:
          kdu_params::translate_marker_segment(*((kdu_params **)this + 3), *(unsigned __int16 *)(v4 + 16), *(unsigned int *)(v4 + 20), *(unsigned __int8 **)(v4 + 32), -1, 0);
          break;
      }
      int v3 = (__int16 *)*((void *)this + 4);
      if (v3[8] == -112) {
        goto LABEL_25;
      }
    }
    if (!*(unsigned char *)(*((void *)this + 1) + 544))
    {
      uint64_t v18 = 0;
      long long v16 = 0u;
      long long v17 = 0u;
      kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v16 + 16))(&v16, "Main code-stream header appears corrupt!");
      kdu_error::~kdu_error((kdu_error *)&v16);
    }
LABEL_25:
    kdu_params::finalize_all(*((kdu_params **)this + 3), -1, 1);
    uint64_t v9 = (kd_tpart_pointer_server *)*((void *)this + 9);
    if (v9)
    {
      if (*((void *)this + 5))
      {
        kd_tpart_pointer_server::~kd_tpart_pointer_server(v9);
        MEMORY[0x18C11C0E0]();
        *((void *)this + 9) = 0;
        if (v2)
        {
          uint64_t v18 = 0;
          long long v16 = 0u;
          long long v17 = 0u;
          kdu_warning::kdu_warning((kdu_warning *)&v16, "Kakadu Core Warning:\n");
          (*(void (**)(long long *, const char *))(v16 + 16))(&v16, "Dynamic indexing of tile-parts, whether by TLM (tile-part length) marker segments or otherwise, cannot be used by the current implementation when PPM (packed packet header) marker segments are also used.");
          kdu_warning::~kdu_warning((kdu_warning *)&v16);
        }
      }
      else
      {
        int v10 = *((_DWORD *)this + 56);
        if (v10 != *((_DWORD *)this + 60) || (int v11 = *((_DWORD *)this + 55), v11 != *((_DWORD *)this + 59))) {
          kd_codestream::read_main_header();
        }
        uint64_t v12 = *((void *)this + 1);
        if (*(unsigned char *)(v12 + 608))
        {
          uint64_t v13 = -12;
        }
        else
        {
          uint64_t v14 = ~(v12 + 14) + *(void *)(v12 + 528) + *(void *)(v12 + 560);
          uint64_t v15 = *(void *)(v12 + 576);
          if (v14 > v15)
          {
            *(void *)(v12 + 576) = v14;
            uint64_t v15 = v14;
          }
          uint64_t v13 = v15 - 11;
        }
        kd_tpart_pointer_server::translate_markers((uint64_t *)v9, v13, v11 * v10, *((void *)this + 41));
      }
    }
    kd_codestream::finalize_construction(this);
  }
}

void sub_18866EE30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

void kd_codestream::construct_output_comp_info(kd_codestream *this)
{
  if (!*((void *)this + 40))
  {
    int v8 = 0;
    kdu_params::get(*((kdu_params **)this + 3), "Sextensions", 0, 0, &v8, 1, 1, 1);
    *((unsigned char *)this + 164) = BYTE1(v8) & 1;
    char v2 = (int *)((char *)this + 176);
    int v3 = 0;
    if (kdu_params::get(*((kdu_params **)this + 3), "Mcomponents", 0, 0, (int *)this + 44, 1, 1, 1)) {
      int v3 = *v2 > 0;
    }
    if (*((unsigned __int8 *)this + 164) != v3)
    {
      uint64_t v7 = 0;
      long long v5 = 0u;
      long long v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
    if (v3)
    {
      int v4 = *v2;
    }
    else
    {
      int v4 = *((_DWORD *)this + 42);
      *((_DWORD *)this + 44) = v4;
    }
    if (v4 >= 17)
    {
      uint64_t v7 = 0;
      long long v5 = 0u;
      long long v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v5 + 16))(&v5, "num_output_components too big.");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
    *((_DWORD *)this + 45) = v4;
    is_mul_ok(v4, 0x30uLL);
    operator new[]();
  }
  kd_codestream::construct_output_comp_info();
}

void sub_18866F170(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18866F17C()
{
  _Unwind_Resume(v0);
}

void kd_codestream::finalize_construction(kd_codestream *this)
{
  if (!*((void *)this + 40)) {
    kd_codestream::construct_output_comp_info(this);
  }
  if (!*((unsigned char *)this + 420))
  {
    *((unsigned char *)this + 420) = 1;
    uint64_t v2 = kdu_params::access_cluster(*((kdu_params **)this + 3), "CRG");
    if (*((int *)this + 42) >= 1)
    {
      int v3 = (kdu_params *)v2;
      uint64_t v4 = 0;
      uint64_t v5 = 8;
      do
      {
        uint64_t v6 = *((void *)this + 39);
        if (!v3
          || !kdu_params::get(v3, "CRGoffset", v4, 0, (float *)(v6 + v5 + 4), 1, 1, 1)
          || (kdu_params::get(v3, "CRGoffset", v4, 1, (float *)(v6 + v5), 1, 1, 1) & 1) == 0)
        {
          *(void *)(v6 + v5) = 0;
        }
        ++v4;
        v5 += 104;
      }
      while (v4 < *((int *)this + 42));
    }
    uint64_t v7 = kdu_params::access_cluster(*((kdu_params **)this + 3), "COD");
    uint64_t v8 = *((unsigned int *)this + 42);
    if ((int)v8 >= 1)
    {
      uint64_t v9 = (kdu_params *)v7;
      uint64_t v10 = 0;
      uint64_t v11 = 55;
      do
      {
        uint64_t v12 = *((void *)this + 39);
        uint64_t v13 = (kdu_params *)kdu_params::access_relation(v9, -1, v10, 0, 1);
        uint64_t v14 = 0;
        uint64_t v15 = v12 + v11;
        do
        {
          int v25 = 3;
          kdu_params::get(v13, "Cdecomp", v14, 0, &v25, 1, 1, 1);
          long long v16 = (unsigned char *)(v15 + v14);
          *(v16 - 33) = (v25 & 1) + *(unsigned char *)(v15 + v14 - 34);
          unsigned char *v16 = ((v25 & 2) != 0) + *(unsigned char *)(v15 + v14++ - 1);
        }
        while (v14 != 32);
        ++v10;
        uint64_t v8 = *((int *)this + 42);
        v11 += 104;
      }
      while (v10 < v8);
    }
    if (*((void *)this + 2))
    {
      long long v17 = (kd_global_rescomp *)*((void *)this + 44);
      if (!v17)
      {
        is_mul_ok(33 * (int)v8, 0x58uLL);
        operator new[]();
      }
      for (int i = 0; i != 33; ++i)
      {
        if ((int)v8 >= 1)
        {
          int v19 = 0;
          do
          {
            kd_global_rescomp::initialize(v17, this, i, v19++);
            long long v17 = (kd_global_rescomp *)((char *)v17 + 88);
            uint64_t v8 = *((unsigned int *)this + 42);
          }
          while (v19 < (int)v8);
        }
      }
    }
    if (*((unsigned char *)this + 164))
    {
      kd_mct_stage::create_stages((void *)this + 18, (uint64_t *)this + 19, *((kdu_params **)this + 3), -1, v8, *((void *)this + 39), *((_DWORD *)this + 44), *((void *)this + 40));
      uint64_t v20 = *((void *)this + 19);
      if (v20)
      {
        uint64_t v21 = *((unsigned int *)this + 44);
        if ((int)v21 >= 1)
        {
          uint64_t v22 = (uint64_t *)(*(void *)(v20 + 24) + 8);
          uint64_t v23 = (void *)(*((void *)this + 40) + 8);
          do
          {
            uint64_t v24 = *v22;
            v22 += 6;
            void *v23 = v24;
            v23 += 6;
            --v21;
          }
          while (v21);
        }
      }
    }
  }
}

uint64_t kd_codestream::restrict_to_fragment(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  *(void *)&long long v31 = a2;
  *((void *)&v31 + 1) = a3;
  if (!*(void *)(a1 + 16)) {
    kd_codestream::restrict_to_fragment();
  }
  uint64_t v8 = (_DWORD *)(a1 + 188);
  uint64_t result = kdu_dims::operator&=(&v31, (int *)(a1 + 188));
  int v11 = DWORD2(v31);
  int v10 = HIDWORD(v31);
  *(double *)(a1 + 288) = (double)(SDWORD2(v31) * (uint64_t)SHIDWORD(v31))
                        / (double)(*(int *)(a1 + 196) * (uint64_t)*(int *)(a1 + 200));
  *(_DWORD *)(a1 + 296) = a4;
  *(void *)(a1 + 304) = a5;
  int v12 = *(_DWORD *)(a1 + 212);
  int v13 = *(_DWORD *)(a1 + 216);
  int v14 = DWORD1(v31) - *(_DWORD *)(a1 + 208);
  int v15 = v31 - *(_DWORD *)(a1 + 204);
  uint64_t v16 = (v14 / v13);
  uint64_t v17 = (v15 / v12);
  int v18 = (v10 + v14) / v13;
  int v19 = (v15 + v11) / v12;
  if (v14 != v16 * v13 || v15 != v17 * v12 || v18 * v13 != v10 + v14 || v19 * v12 != v15 + v11)
  {
    uint64_t v30 = 0;
    long long v28 = 0u;
    long long v29 = 0u;
    kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v28);
  }
  BOOL v20 = __OFSUB__(v18, v16);
  uint64_t v21 = (v18 - v16);
  if (((int)v21 < 0) ^ v20 | (v21 == 0) || v19 <= (int)v17)
  {
    uint64_t v30 = 0;
    long long v28 = 0u;
    long long v29 = 0u;
    kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v28);
  }
  uint64_t v22 = (v19 - v17);
  int v23 = v22 * v21;
  if ((int)v22 * (int)v21 <= 0) {
    kd_codestream::restrict_to_fragment();
  }
  int v24 = *(_DWORD *)(a1 + 220) * *(_DWORD *)(a1 + 224);
  int v25 = v23 + a4;
  if (v24 < v23 + a4)
  {
    uint64_t v30 = 0;
    long long v28 = 0u;
    long long v29 = 0u;
    kdu_error::kdu_error((kdu_error *)&v28, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v28);
  }
  *(unsigned char *)(a1 + 281) = a4 == 0;
  *(unsigned char *)(a1 + 282) = v24 == v25;
  if (v21 != *(_DWORD *)(a1 + 240) || v22 != *(_DWORD *)(a1 + 236))
  {
    uint64_t v26 = *(void *)(a1 + 328);
    if (v26) {
      MEMORY[0x18C11C0C0](v26, 0x20C80960023A9);
    }
    *(void *)(a1 + 328) = 0;
    *(void *)(a1 + 228) = v17 | (v16 << 32);
    *(void *)(a1 + 236) = (v21 << 32) | v22;
    long long v27 = v31;
    *(_OWORD *)uint64_t v8 = v31;
    *(_OWORD *)(a1 + 264) = v27;
    operator new[]();
  }
  if (__PAIR64__(v16, v17) != *(void *)(a1 + 228)
    || __PAIR64__(*(_DWORD *)(a1 + 192), *v8) != (void)v31
    || *(_DWORD *)(a1 + 200) != HIDWORD(v31)
    || a4
    || v24 != v25
    || *(_DWORD *)(a1 + 196) != DWORD2(v31))
  {
    kd_codestream::restrict_to_fragment();
  }
  return result;
}

void sub_18866F7F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18866F800()
{
  _Unwind_Resume(v0);
}

void kd_codestream::restart(kd_codestream *this)
{
  uint64_t v2 = (kd_pp_markers *)*((void *)this + 5);
  if (v2)
  {
    kd_pp_markers::~kd_pp_markers(v2);
    MEMORY[0x18C11C0E0]();
  }
  *((void *)this + 5) = 0;
  int v3 = (kd_tpart_pointer_server *)*((void *)this + 9);
  if (v3)
  {
    kd_tpart_pointer_server::~kd_tpart_pointer_server(v3);
    MEMORY[0x18C11C0E0]();
  }
  *((void *)this + 9) = 0;
  uint64_t v4 = *((void *)this + 8);
  if (v4) {
    MEMORY[0x18C11C0E0](v4, 0x1000C404E6BD753);
  }
  *((void *)this + 8) = 0;
  *((_DWORD *)this + 29) = 0;
  *((void *)this + 13) = 0;
  *((void *)this + 16) = 0;
  uint64_t v5 = *((void *)this + 17);
  if (v5) {
    MEMORY[0x18C11C0C0](v5, 0x1000C80CE7E837CLL);
  }
  *((unsigned char *)this + 420) = 0;
  *((void *)this + 49) = 0;
  *((void *)this + 50) = 0;
  uint64_t v6 = *((void *)this + 46);
  if (v6) {
    MEMORY[0x18C11C0C0](v6, 0x1000C8000313F17);
  }
  uint64_t v7 = *((void *)this + 47);
  if (v7) {
    MEMORY[0x18C11C0C0](v7, 0x1000C8000313F17);
  }
  uint64_t v8 = *((void *)this + 48);
  if (v8) {
    MEMORY[0x18C11C0C0](v8, 0x1000C80BDFB0063);
  }
  *((_DWORD *)this + 97) = 0;
  *(void *)((char *)this + 372) = 0;
  *(void *)((char *)this + 364) = 0;
  *(void *)((char *)this + 380) = 0;
  uint64_t v9 = *((void *)this + 40);
  if (v9) {
    MEMORY[0x18C11C0C0](v9, 0x1020C806B39A6A2);
  }
  *((void *)this + 40) = 0;
  *((void *)this + 22) = 0;
  int v10 = (void *)*((void *)this + 41);
  if (!v10) {
    kd_codestream::restart();
  }
  int v11 = *((_DWORD *)this + 59);
  if (v11 >= 1)
  {
    int v12 = 0;
    int v13 = *((_DWORD *)this + 60);
    do
    {
      if (v13 >= 1)
      {
        for (int i = 0; i < v13; ++i)
        {
          void *v10 = 0;
          v10[1] = 0;
          int v15 = (kd_tile *)v10[2];
          if (v15)
          {
            if (v15 == (kd_tile *)-1) {
              kd_codestream::restart();
            }
            if (*((unsigned char *)v15 + 289))
            {
              uint64_t v20 = 0;
              memset(v19, 0, sizeof(v19));
              kdu_error::kdu_error((kdu_error *)v19, "Kakadu Core Error:\n");
              kdu_error::~kdu_error((kdu_error *)v19);
            }
            kd_tile::restart(v15);
            int v13 = *((_DWORD *)this + 60);
          }
          v10 += 3;
        }
        int v11 = *((_DWORD *)this + 59);
      }
      ++v12;
    }
    while (v12 < v11);
  }
  while (1)
  {
    uint64_t v16 = (kd_tile *)*((void *)this + 64);
    if (!v16) {
      break;
    }
    *((void *)this + 64) = *((void *)v16 + 9);
    if (*((void *)v16 + 3)) {
      kd_codestream::restart();
    }
    kd_tile::~kd_tile(v16);
    MEMORY[0x18C11C0E0]();
  }
  while (1)
  {
    uint64_t v18 = *((void *)this + 11);
    *((void *)this + 12) = v18;
    if (!v18) {
      break;
    }
    *((void *)this + 11) = *(void *)(v18 + 24);
    uint64_t v17 = *(void *)(v18 + 16);
    if (v17) {
      MEMORY[0x18C11C0C0](v17, 0x1000C8077774924);
    }
    MEMORY[0x18C11C0E0](v18, 0x1030C40D4B01E93);
  }
  *(_WORD *)((char *)this + 421) = 0;
  *((void *)this + 53) = 0;
  kdu_params::clear_marks(*((void *)this + 3));
  if (*((void *)this + 1)) {
    kd_codestream::read_main_header(this);
  }
  if (!*((void *)this + 40)) {
    kd_codestream::construct_output_comp_info(this);
  }
  *((unsigned char *)this + 419) = 0;
  *((_DWORD *)this + 65) = 0;
  *(void *)this = 0;
  *((void *)this + 56) = 0;
  *((void *)this + 57) = 0;
  *((void *)this + 55) = 0;
}

void sub_18866FB38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18866FB44()
{
  _Unwind_Resume(v0);
}

uint64_t kd_codestream::set_reserved_layer_info_bytes(uint64_t this, int a2)
{
  uint64_t v3 = this;
  uint64_t v5 = (void *)(this + 88);
  uint64_t v4 = *(void *)(this + 88);
  if (v4)
  {
    uint64_t v6 = *(void *)(v4 + 16);
    BOOL v7 = v6 == 0;
    if (v6) {
      uint64_t v8 = *(const char **)(v4 + 16);
    }
    else {
      uint64_t v8 = "";
    }
    this = strncmp(v8, "Kdu-Layer-Info: ", 0x10uLL);
    if (this)
    {
      while (1)
      {
        uint64_t v9 = v4;
        uint64_t v4 = *(void *)(v4 + 24);
        if (!v4) {
          break;
        }
        uint64_t v6 = *(void *)(v4 + 16);
        BOOL v7 = v6 == 0;
        if (v6) {
          int v10 = *(const char **)(v4 + 16);
        }
        else {
          int v10 = "";
        }
        this = strncmp(v10, "Kdu-Layer-Info: ", 0x10uLL);
        if (!this) {
          goto LABEL_13;
        }
      }
    }
    else
    {
      uint64_t v9 = 0;
LABEL_13:
      int v11 = (void *)(v9 + 24);
      if (!v9) {
        int v11 = v5;
      }
      *int v11 = *(void *)(v4 + 24);
      if (!v7) {
        MEMORY[0x18C11C0C0](v6, 0x1000C8077774924);
      }
      this = MEMORY[0x18C11C0E0](v4, 0x1030C40D4B01E93);
      if (v4 == *(void *)(v3 + 96)) {
        *(void *)(v3 + 96) = v9;
      }
    }
  }
  *(_DWORD *)(v3 + 432) = 17 * a2 + 74;
  return this;
}

uint64_t kd_codestream::gen_layer_info_comment(uint64_t this, int a2, uint64_t *a3, unsigned __int16 *a4)
{
  if (*(_DWORD *)(this + 432)) {
    operator new();
  }
  return this;
}

uint64_t kd_codestream::freeze_comments(uint64_t this)
{
  if (!*(unsigned char *)(this + 421))
  {
    uint64_t v1 = this;
    uint64_t v2 = *(void *)(this + 88);
    if (!v2) {
LABEL_8:
    }
      operator new();
    while (1)
    {
      uint64_t v3 = *(void *)(v2 + 16) ? *(const char **)(v2 + 16) : "";
      this = strcmp(v3, "Kakadu-v5.2.1");
      if (!this) {
        break;
      }
      uint64_t v2 = *(void *)(v2 + 24);
      if (!v2) {
        goto LABEL_8;
      }
    }
    *(unsigned char *)(v1 + 421) = 1;
  }
  return this;
}

void kd_codestream::~kd_codestream(kd_codestream *this)
{
  uint64_t v2 = *((void *)this + 39);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1020C8091F5070ALL);
  }
  uint64_t v3 = *((void *)this + 40);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1020C806B39A6A2);
  }
  uint64_t v4 = *((void *)this + 44);
  if (v4)
  {
    uint64_t v5 = *(void *)(v4 - 8);
    if (v5)
    {
      uint64_t v6 = 88 * v5;
      do
      {
        kd_global_rescomp::close_all((uint64_t *)(v4 - 88 + v6));
        v6 -= 88;
      }
      while (v6);
    }
    MEMORY[0x18C11C0C0](v4 - 16, 0x1020C8067899110);
  }
  *((void *)this + 55) = 0;
  uint64_t v7 = *((void *)this + 41);
  if (!v7) {
    goto LABEL_24;
  }
  int v8 = *((_DWORD *)this + 59);
  if (v8 < 1) {
    goto LABEL_23;
  }
  int v9 = 0;
  int v10 = *((_DWORD *)this + 60);
  int v11 = "abs_idx == tref->tile->t_idx";
  int v12 = "codestream.cpp";
  int v13 = "~kd_codestream";
  do
  {
    if (v10 < 1) {
      goto LABEL_21;
    }
    for (int i = 0; i < v10; ++i)
    {
      int v15 = *(kd_tile **)(v7 + 16);
      if ((unint64_t)v15 + 1 >= 2)
      {
        if (i + *((_DWORD *)this + 58) != *((_DWORD *)v15 + 4) || *((_DWORD *)this + 57) + v9 != *((_DWORD *)v15 + 3))
        {
          int v27 = 4732;
          goto LABEL_50;
        }
        kd_tile::~kd_tile(v15);
        MEMORY[0x18C11C0E0]();
        if ((unint64_t)(*(void *)(v7 + 16) + 1) > 1)
        {
          int v27 = 4735;
          int v11 = "(tref->tile == NULL) || (tref->tile == KD_EXPIRED_TILE)";
          goto LABEL_50;
        }
      }
      v7 += 24;
      int v10 = *((_DWORD *)this + 60);
    }
    int v8 = *((_DWORD *)this + 59);
LABEL_21:
    ++v9;
  }
  while (v9 < v8);
  uint64_t v7 = *((void *)this + 41);
  if (v7) {
LABEL_23:
  }
    MEMORY[0x18C11C0C0](v7, 0x20C80960023A9);
LABEL_24:
  uint64_t v16 = (kd_tile *)*((void *)this + 64);
  if (v16)
  {
    int v11 = "typ->tile_ref == NULL";
    int v12 = "codestream.cpp";
    int v13 = "~kd_codestream";
    while (1)
    {
      *((void *)this + 64) = *((void *)v16 + 9);
      if (*((void *)v16 + 3)) {
        break;
      }
      kd_tile::~kd_tile(v16);
      MEMORY[0x18C11C0E0]();
      uint64_t v16 = (kd_tile *)*((void *)this + 64);
      if (!v16) {
        goto LABEL_28;
      }
    }
    int v27 = 4745;
LABEL_50:
    __assert_rtn(v13, v12, v27, v11);
  }
LABEL_28:
  uint64_t v17 = *((void *)this + 1);
  if (v17)
  {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
    *((void *)this + 1) = 0;
  }
  uint64_t v18 = *((void *)this + 2);
  if (v18)
  {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
    *((void *)this + 2) = 0;
  }
  uint64_t v19 = *((void *)this + 3);
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 16))(v19);
  }
  uint64_t v20 = *((void *)this + 4);
  if (v20)
  {
    uint64_t v21 = *(void *)(v20 + 32);
    if (v21) {
      MEMORY[0x18C11C0C0](v21, 0x1000C8077774924);
    }
    MEMORY[0x18C11C0E0](v20, 0x1030C40051CB91CLL);
  }
  uint64_t v22 = (kd_pp_markers *)*((void *)this + 5);
  if (v22)
  {
    kd_pp_markers::~kd_pp_markers(v22);
    MEMORY[0x18C11C0E0]();
  }
  int v23 = (kd_precinct_size_class **)*((void *)this + 10);
  if (v23)
  {
    kd_precinct_server::~kd_precinct_server(v23);
    MEMORY[0x18C11C0E0]();
  }
  int v24 = (kdu_block *)*((void *)this + 7);
  if (v24)
  {
    kdu_block::~kdu_block(v24);
    MEMORY[0x18C11C0E0]();
  }
  uint64_t v25 = *((void *)this + 8);
  if (v25) {
    MEMORY[0x18C11C0E0](v25, 0x1000C404E6BD753);
  }
  uint64_t v26 = (kd_tpart_pointer_server *)*((void *)this + 9);
  if (!v26) {
    goto LABEL_53;
  }
  kd_tpart_pointer_server::~kd_tpart_pointer_server(v26);
  while (1)
  {
    MEMORY[0x18C11C0E0]();
LABEL_53:
    uint64_t v28 = *((void *)this + 11);
    *((void *)this + 12) = v28;
    if (!v28) {
      break;
    }
    uint64_t v29 = *(void *)(v28 + 16);
    *((void *)this + 11) = *(void *)(v28 + 24);
    if (v29) {
      MEMORY[0x18C11C0C0](v29, 0x1000C8077774924);
    }
  }
  uint64_t v30 = *((void *)this + 46);
  if (v30) {
    MEMORY[0x18C11C0C0](v30, 0x1000C8000313F17);
  }
  uint64_t v31 = *((void *)this + 47);
  if (v31) {
    MEMORY[0x18C11C0C0](v31, 0x1000C8000313F17);
  }
  uint64_t v32 = *((void *)this + 48);
  if (v32) {
    MEMORY[0x18C11C0C0](v32, 0x1000C80BDFB0063);
  }
  uint64_t v33 = (kd_buf_server *)*((void *)this + 6);
  if (!v33) {
    goto LABEL_70;
  }
  int v34 = *((_DWORD *)v33 + 16);
  if (v34 <= 0)
  {
    int v11 = "num_users > 0";
    int v27 = 216;
    int v12 = "compressed_local.h";
    int v13 = "detach";
    goto LABEL_50;
  }
  int v35 = v34 - 1;
  *((_DWORD *)v33 + 16) = v35;
  if (v35) {
    goto LABEL_70;
  }
  kd_buf_server::~kd_buf_server(v33);
  while (1)
  {
    MEMORY[0x18C11C0E0]();
LABEL_70:
    int v36 = (kd_mct_stage *)*((void *)this + 18);
    *((void *)this + 19) = v36;
    if (!v36) {
      break;
    }
    *((void *)this + 18) = *((void *)v36 + 7);
    kd_mct_stage::~kd_mct_stage(v36);
  }
  uint64_t v37 = *((void *)this + 17);
  if (v37) {
    MEMORY[0x18C11C0C0](v37, 0x1000C80CE7E837CLL);
  }
}

uint64_t kd_codestream::create_tile(uint64_t a1, uint64_t a2)
{
  int v2 = HIDWORD(a2) - *(_DWORD *)(a1 + 232);
  if (v2 < 0
    || (int v5 = a2 - *(_DWORD *)(a1 + 228), v5 < 0)
    || (int v6 = *(_DWORD *)(a1 + 240), v6 <= v2)
    || *(_DWORD *)(a1 + 236) <= v5)
  {
    kd_codestream::create_tile();
  }
  uint64_t v7 = *(void *)(a1 + 328) + 24 * v2 + 24 * v6 * v5;
  int v8 = (kd_tile **)(v7 + 16);
  if (*(void *)(v7 + 16)) {
    kd_codestream::create_tile();
  }
  long long v12 = *(_OWORD *)(a1 + 204);
  LODWORD(v12) = v12 + DWORD2(v12) * a2;
  DWORD1(v12) += HIDWORD(v12) * HIDWORD(a2);
  kdu_dims::operator&=(&v12, (int *)(a1 + 188));
  if (SHIDWORD(v12) < 1 || *(uint64_t *)((char *)&v12 + 4) <= 0)
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  if (!*(void *)(a1 + 8)
    || *(unsigned char *)(a1 + 417)
    || *(unsigned char *)(a1 + 408)
    || kdu_dims::intersects(&v12, (_DWORD *)(a1 + 264)))
  {
    int v9 = *(kd_tile **)(a1 + 512);
    if (v9)
    {
      *int v8 = v9;
      *(void *)(a1 + 512) = *((void *)v9 + 9);
      kd_tile::recycle(v9, v7, a2, v12, *((uint64_t *)&v12 + 1));
    }
    operator new();
  }
  uint64_t result = -1;
  *int v8 = (kd_tile *)-1;
  return result;
}

void sub_188670548(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1020C403DE16A90);
  _Unwind_Resume(a1);
}

uint64_t kd_codestream::simulate_output(kdu_params **this, uint64_t *a2, int a3, unsigned int a4, int a5, int a6, uint64_t a7, uint64_t *a8)
{
  uint64_t v13 = 0;
  *a2 = 0;
  if (a3)
  {
    if (!a6) {
      goto LABEL_18;
    }
  }
  else if (*((unsigned char *)this + 281) && !*((unsigned char *)this + 422))
  {
    uint64_t v49 = (int)(kdu_params::generate_marker_segments(this[3], 0, -1, 0) + 2);
    *a2 = v49;
    if (!*((unsigned char *)this + 421))
    {
      kd_codestream::freeze_comments((uint64_t)this);
      uint64_t v49 = *a2;
    }
    uint64_t v50 = this[11];
    if (v50)
    {
      do
      {
        *(unsigned char *)uint64_t v50 = 1;
        v49 += *((_DWORD *)v50 + 2) + 6;
        uint64_t v50 = (kdu_params *)*((void *)v50 + 3);
      }
      while (v50);
      *a2 = v49;
    }
    uint64_t v13 = v49 + *((int *)this + 108);
    *a2 = v13;
  }
  else
  {
    uint64_t v13 = 0;
  }
  for (int i = this[42]; i; int i = (kdu_params *)*((void *)i + 5))
  {
    if (a3) {
      uint64_t v15 = 0;
    }
    else {
      uint64_t v15 = (int)(kdu_params::generate_marker_segments(this[3], 0, *((_DWORD *)i + 2), *((unsigned int *)i + 76)) + 14);
    }
    if (a6)
    {
      int v16 = *((_DWORD *)i + 48);
      if (v16 > a3 + 1)
      {
        int v17 = *((_DWORD *)i + 51) * (v16 + ~a3);
        if (*((unsigned char *)i + 285)) {
          int v18 = 3;
        }
        else {
          int v18 = 1;
        }
        v15 += v17 * v18;
      }
    }
    *a2 += v15;
    v13 += v15;
  }
LABEL_18:
  if (v13 <= a7)
  {
    int v53 = this;
    BOOL v54 = a2;
    int v20 = *((_DWORD *)this + 42);
    uint64_t v21 = (uint64_t)this[44] + 2816 * v20;
    int v22 = 32;
    __asm { FMOV            V0.2D, #1.0 }
    long long v52 = _Q0;
    uint64_t v28 = a8;
    uint64_t v55 = a7;
    while (1)
    {
      int v51 = v22;
      if (v20 >= 1) {
        break;
      }
LABEL_80:
      int v22 = v51 - 1;
      v21 -= 176 * v20;
      if (!v51) {
        return v13;
      }
    }
    int v29 = 0;
    while (1)
    {
      uint64_t v30 = *(void *)(v21 + 48);
      if (v30) {
        break;
      }
LABEL_79:
      ++v29;
      v21 += 88;
      if (v29 >= v20) {
        goto LABEL_80;
      }
    }
    uint64_t v31 = *(void *)(v21 + 40);
    uint64_t v32 = *(void *)(v21 + 64);
    double v33 = *(double *)(v21 + 72);
    if (v33 < 0.0)
    {
      BOOL v34 = v31 < 1 || v31 < v32;
      if (v34) {
        kd_codestream::simulate_output();
      }
      if (v31 != v32)
      {
        uint64_t v36 = *(void *)(v21 + 32);
        uint64_t v37 = *(void *)(v21 + 16) - v36;
        if (v37 < 1)
        {
          double v38 = (double)v31;
        }
        else
        {
          if (v37 > v32 + v31) {
            kd_codestream::simulate_output();
          }
          double v38 = (double)v37 * (double)*(uint64_t *)(v21 + 24) / (double)v36 + (double)(v31 - v37);
        }
        double v33 = (double)v32 / v38;
        if (v33 > 1.0) {
          double v33 = 1.0;
        }
        *(double *)(v21 + 72) = v33;
        *(double *)(v21 + 80) = 1.0 / v33;
        if (a8) {
          goto LABEL_33;
        }
        goto LABEL_41;
      }
      *(_OWORD *)(v21 + 72) = v52;
      double v33 = 1.0;
    }
    if (a8)
    {
LABEL_33:
      uint64_t v35 = *a8;
LABEL_42:
      uint64_t v39 = 0;
      uint64_t v40 = 0;
      uint64_t v41 = (uint64_t)(v33 * (double)v35);
      if (v41 <= 1) {
        uint64_t v41 = 1;
      }
      uint64_t v57 = v32;
      uint64_t v58 = v31;
      if (v31 == v32) {
        uint64_t v42 = a7 - v13;
      }
      else {
        uint64_t v42 = (uint64_t)(v33 * (double)(a7 - v13));
      }
      if (v31 == v32) {
        uint64_t v43 = v35;
      }
      else {
        uint64_t v43 = v41 - 1;
      }
      v64[0] = 0;
      uint64_t v56 = v43;
      while (1)
      {
        if (*(_DWORD *)(v30 + 28))
        {
          uint64_t v63 = 0;
          memset(v62, 0, sizeof(v62));
          kdu_error::kdu_error((kdu_error *)v62, "Kakadu Core Error:\n");
          (*(void (**)(_OWORD *, const char *))(*(void *)&v62[0] + 16))(v62, "Attempting to run rate-control simulation on a precinct for which one or more packets have already been written to the code-stream.  Problem is most likely caused by trying to use the incremental code-stream flushing feature with one of the progression orders, LRCP or RLCP.");
          kdu_error::~kdu_error((kdu_error *)v62);
        }
        if (*(_DWORD *)(*(void *)(*(void *)(*(void *)v30 + 8) + 8) + 192) > a3)
        {
          v64[0] = 0;
          if (v28)
          {
            char v44 = a5 & a6;
            if (v43 < 0) {
              char v44 = 0;
            }
            if ((v44 & 1) == 0) {
              kd_codestream::simulate_output();
            }
            if (a4 == 0xFFFF) {
              kd_codestream::simulate_output();
            }
            uint64_t v45 = kd_precinct::simulate_packet((kd_precinct *)v30, v64, a3, (unsigned __int16)(a4 + 1), 0, 1, 0x10000000000000, 0);
            if (v45 + v43 >= v42 - v39) {
              uint64_t v46 = v42 - v39;
            }
            else {
              uint64_t v46 = v45 + v43;
            }
            if (v46 < v45) {
              kd_codestream::simulate_output();
            }
            uint64_t v47 = kd_precinct::simulate_packet((kd_precinct *)v30, v64, a3, a4, 1, 1, v46, 1);
            BOOL v34 = v46 < v47;
            uint64_t v43 = v46 - v47;
            if (v34) {
              kd_codestream::simulate_output();
            }
          }
          else
          {
            uint64_t v47 = kd_precinct::simulate_packet((kd_precinct *)v30, v64, a3, a4, a5, a6, v42 - v39, 0);
          }
          v39 += v47;
          v40 += v64[0];
          if (v39 > v42) {
            break;
          }
        }
        uint64_t v30 = *(void *)(v30 + 56);
        if (!v30) {
          goto LABEL_71;
        }
      }
      if (a5) {
        kd_codestream::simulate_output();
      }
LABEL_71:
      if (v58 == v57)
      {
        *v54 += v40;
        a8 = v28;
        if (!v28) {
          goto LABEL_77;
        }
      }
      else
      {
        double v48 = *(double *)(v21 + 80);
        *v54 += (uint64_t)(v48 * (double)v40) + 1;
        uint64_t v39 = (uint64_t)(v48 * (double)v39) + 1;
        a8 = v28;
        if (!v28)
        {
LABEL_77:
          v13 += v39;
          a7 = v55;
          if (v13 > v55) {
            return v13;
          }
          int v20 = *((_DWORD *)v53 + 42);
          goto LABEL_79;
        }
        uint64_t v43 = (*v28 + ~(uint64_t)(v48 * (double)(v56 - v43))) & ~((*v28 + ~(uint64_t)(v48 * (double)(v56 - v43))) >> 63);
      }
      *a8 = v43;
      goto LABEL_77;
    }
LABEL_41:
    uint64_t v35 = 0;
    goto LABEL_42;
  }
  if (a5) {
    kd_codestream::simulate_output();
  }
  return v13;
}

void sub_188670AB0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188670ABC()
{
  _Unwind_Resume(v0);
}

double kd_codestream::calculate_min_header_cost(kd_codestream *this)
{
  if (*((void *)this + 49)) {
    kd_codestream::calculate_min_header_cost();
  }
  *((void *)this + 49) = 0;
  *((void *)this + 50) = 0;
  if (*((unsigned char *)this + 281)) {
    *((void *)this + 49) += (int)(kdu_params::generate_marker_segments(*((kdu_params **)this + 3), 0, -1, 0) + 2);
  }
  if (!*((unsigned char *)this + 421)) {
    kd_codestream::freeze_comments((uint64_t)this);
  }
  if (*((unsigned char *)this + 281))
  {
    uint64_t v3 = *((void *)this + 11);
    for (i = *((void *)this + 49); v3; uint64_t v3 = *(void *)(v3 + 24))
    {
      *(unsigned char *)uint64_t v3 = 1;
      i += *(_DWORD *)(v3 + 8) + 6;
    }
    *((void *)this + 49) = i + *((int *)this + 108);
  }
  int v5 = *((_DWORD *)this + 59);
  if (v5 < 1)
  {
    if (((*((int *)this + 49) * (uint64_t)*((int *)this + 50)) & 0x8000000000000000) == 0) {
      return result;
    }
LABEL_32:
    kd_codestream::calculate_min_header_cost();
  }
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  int v8 = 0;
  uint64_t v9 = *((void *)this + 41);
  int v10 = *((_DWORD *)this + 60);
  do
  {
    if (v10 >= 1)
    {
      for (int j = 0; j < v10; ++j)
      {
        int v12 = *((_DWORD *)this + 58);
        int v13 = *((_DWORD *)this + 56);
        if (j + v12 >= v13 || (int v14 = *((_DWORD *)this + 57), v14 + v8 >= *((_DWORD *)this + 55))) {
          kd_codestream::calculate_min_header_cost();
        }
        *((void *)this + 49) += (int)(kdu_params::generate_marker_segments(*((kdu_params **)this + 3), 0, j + v12 + v13 * (v8 + v14), 0)+ 14);
        uint64_t v15 = *(void *)(v9 + 16);
        if ((unint64_t)(v15 + 1) >= 2)
        {
          v6 += *(int *)(v15 + 220) * (uint64_t)*(int *)(v15 + 224);
          uint64_t v16 = *(int *)(v15 + 204);
          if (*(unsigned char *)(v15 + 285)) {
            uint64_t v17 = 2 * v16;
          }
          else {
            uint64_t v17 = 0;
          }
          v7 += v16 + v17;
          if (*(unsigned char *)(v15 + 284)) {
            v7 += 6 * (int)v16;
          }
        }
        v9 += 24;
        int v10 = *((_DWORD *)this + 60);
      }
      int v5 = *((_DWORD *)this + 59);
    }
    ++v8;
  }
  while (v8 < v5);
  uint64_t v18 = *((int *)this + 49) * (uint64_t)*((int *)this + 50);
  if (v18 < v6) {
    goto LABEL_32;
  }
  if (v6 >= 1)
  {
    double result = (double)v18 / (double)v6 * (double)v7;
    *((void *)this + 50) = (uint64_t)result;
  }
  return result;
}

void kd_codestream::pcrd_opt(kd_codestream *this, int a2, double a3)
{
  if (a3 <= 0.5) {
    double v4 = a3;
  }
  else {
    double v4 = 0.5;
  }
  if (!*((void *)this + 49)) {
    kd_codestream::calculate_min_header_cost(this);
  }
  uint64_t v60 = 0;
  LODWORD(v5) = *((_DWORD *)this + 91);
  if (*(void *)(*((void *)this + 47) + 8 * ((int)v5 - 1)))
  {
    uint64_t v55 = 0;
  }
  else
  {
    uint64_t v55 = kd_codestream::simulate_output((kdu_params **)this, &v60, 0, 0, 0, 0, 0x10000000000000, 0);
    LODWORD(v5) = *((_DWORD *)this + 91);
  }
  int v6 = v5 - 1;
  if ((int)v5 < 1)
  {
    LODWORD(v7) = 0;
  }
  else
  {
    uint64_t v7 = 0;
    while (*(void *)(*((void *)this + 47) + 8 * v7))
    {
      if (v5 == ++v7) {
        goto LABEL_45;
      }
    }
  }
  if ((int)v7 < v6)
  {
    int v8 = (void *)*((void *)this + 47);
    uint64_t v9 = *v8;
    if (*v8)
    {
      uint64_t v10 = 0;
      do
      {
        int v11 = &v8[v10++];
        uint64_t v12 = *((void *)this + 49) + v9 + *((void *)this + 50) * v10;
        *int v11 = v12;
        uint64_t v9 = v11[1];
      }
      while (v9);
    }
    else
    {
      LODWORD(v10) = 0;
      uint64_t v12 = 0;
    }
    if ((int)v10 < v6)
    {
      uint64_t v13 = v6;
      uint64_t v57 = v8 + 1;
      BOOL v54 = v8;
      do
      {
        uint64_t v14 = (int)v10;
        uint64_t v15 = v8[(int)v10];
        if (v15)
        {
          LODWORD(v10) = v10 + 1;
          uint64_t v12 = v15;
        }
        else
        {
          uint64_t v16 = 0;
          int v17 = v10;
          do
          {
            uint64_t v10 = v16;
            uint64_t v18 = v57[v14 + v16];
            if (v18)
            {
              int v19 = v17 + v16;
              goto LABEL_30;
            }
            ++v16;
          }
          while (v14 + v10 + 1 < v13);
          int v19 = v5 - 2;
          uint64_t v18 = v55;
          if (1 - v5 + v14 + v16) {
            kd_codestream::pcrd_opt();
          }
LABEL_30:
          uint64_t v20 = *((void *)this + 49);
          uint64_t v21 = *((void *)this + 50);
          uint64_t v22 = v18 - (v20 + v21 * (v19 + 2));
          if (v22 <= 1) {
            uint64_t v22 = 1;
          }
          double v23 = (double)v22;
          if (v12)
          {
            long double v24 = (double)(v12 - (v20 + v21 * v14));
          }
          else
          {
            if (v17) {
              kd_codestream::pcrd_opt();
            }
            long double v24 = exp2((double)((int)v10 + 2) * -0.5) * v23;
          }
          if (v24 <= 0.0) {
            kd_codestream::pcrd_opt();
          }
          double v25 = log(v24);
          double v26 = log(v23);
          if ((int)v14 <= v19)
          {
            double v27 = v26;
            uint64_t v28 = 0;
            double v29 = (double)((int)v10 + 2);
            LODWORD(v10) = v19 + 1;
            uint64_t v30 = &v8[v14];
            int v31 = v10 - v17;
            uint64_t v32 = v14 + 1;
            do
            {
              v30[v28] = *((void *)this + 49)
                       + (uint64_t)exp(v27 * ((double)((int)v28 + 1) / v29) + (1.0 - (double)((int)v28 + 1) / v29) * v25)
                       + *((void *)this + 50) * (v32 + v28);
              ++v28;
            }
            while (v31 != v28);
            int v8 = v54;
            int v6 = v5 - 1;
          }
          else
          {
            LODWORD(v10) = v17;
          }
        }
      }
      while ((int)v10 < v6);
    }
  }
LABEL_45:
  if ((int)v5 >= 1)
  {
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t v36 = *((void *)this + 47);
    int v37 = 0x10000;
    do
    {
      uint64_t v38 = (v5 - 1);
      uint64_t v39 = *(void *)(*((void *)this + 46) + 8 * v33) + v34;
      uint64_t v40 = *(void *)(v36 + 8 * v33);
      uint64_t v58 = v39;
      if (v40)
      {
        if (*((unsigned char *)this + 282)) {
          v40 -= 2;
        }
        double v41 = (double)*((uint64_t *)this + 50);
        if (!v33) {
          double v41 = v41 + (double)*((uint64_t *)this + 49);
        }
        if (v39 >= 1 && v4 > 0.0 && v39 < v40) {
          double v41 = v41 - (double)(uint64_t)((double)v39 / (double)v40 * v41);
        }
        uint64_t v42 = v40 - v35 - v39;
        uint64_t v43 = v35;
        if (v4 <= 0.0 || v42 <= (uint64_t)v41) {
          uint64_t v44 = v42;
        }
        else {
          uint64_t v44 = v42 - (uint64_t)(v4 * ((double)v42 - v41));
        }
      }
      else
      {
        if (v33 != v38) {
          kd_codestream::pcrd_opt();
        }
        uint64_t v43 = v35;
        uint64_t v42 = 0x10000000000000;
        int v37 = 1;
        uint64_t v44 = 0x10000000000000;
      }
      int v45 = 0;
      if (v37 <= 1) {
        int v46 = 1;
      }
      else {
        int v46 = v37;
      }
      int v47 = v46 - 1;
      do
      {
        int v48 = v46 + v45;
        if (v46 + v45 >= 0x20000) {
          kd_codestream::pcrd_opt();
        }
        int v49 = v48 >> 1;
        uint64_t v50 = kd_codestream::simulate_output((kdu_params **)this, &v60, v33, (unsigned __int16)(v48 >> 1), 0, v33 == v38, v42, 0);
        if (v50 <= v42)
        {
          if (v50 >= v44) {
            goto LABEL_73;
          }
          int v46 = v49;
          int v47 = v49;
        }
        else
        {
          int v45 = v49 + 1;
        }
      }
      while (v46 > v45);
      int v49 = v47;
LABEL_73:
      uint64_t v51 = v43;
      uint64_t v34 = v58;
      uint64_t v52 = v42
          - kd_codestream::simulate_output((kdu_params **)this, &v60, v33, (unsigned __int16)v49, 0, v33 == v38, 0x10000000000000, 0);
      uint64_t v59 = v52;
      if (v49 >= 1 && v33 == v38 && v52 >= 1 && a2) {
        uint64_t v53 = kd_codestream::simulate_output((kdu_params **)this, &v60, v33, (unsigned __int16)--v49, 1, 1, v42, &v59);
      }
      else {
        uint64_t v53 = kd_codestream::simulate_output((kdu_params **)this, &v60, v33, (unsigned __int16)v49, 1, v33 == v38, 0x10000000000000, 0);
      }
      *(_WORD *)(*((void *)this + 48) + 2 * v33) = v49;
      uint64_t v35 = v53 + v51;
      uint64_t v36 = *((void *)this + 47);
      if (!*(void *)(v36 + 8 * v33))
      {
        if (v33 != v38) {
          kd_codestream::pcrd_opt();
        }
        *(void *)(v36 + 8 * v33) = v35 + v58 + 2 * *((unsigned __int8 *)this + 282);
      }
      int v37 = v49 + 1;
      ++v33;
      uint64_t v5 = *((int *)this + 91);
    }
    while (v33 < v5);
  }
}

BOOL kd_codestream::generate_codestream(kd_codestream *this, int a2)
{
  if (!*((void *)this + 2)) {
    kd_codestream::generate_codestream();
  }
  if (!*((void *)this + 46) || !*((void *)this + 48)) {
    kd_codestream::generate_codestream();
  }
  if (*((_DWORD *)this + 91) < a2)
  {
    uint64_t v23 = 0;
    long long v21 = 0u;
    long long v22 = 0u;
    kdu_error::kdu_error((kdu_error *)&v21, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v21);
  }
  if (!*((unsigned char *)this + 422))
  {
    *((unsigned char *)this + 422) = 1;
    if (*((unsigned char *)this + 281))
    {
      double v4 = (kdu_output *)*((void *)this + 2);
      kdu_output::put(v4, 255);
      kdu_output::put(v4, 79);
      **((void **)this + 46) += 2;
      **((void **)this + 46) += (int)kdu_params::generate_marker_segments(*((kdu_params **)this + 3), *((kdu_output **)this + 2), -1, 0);
      if (!*((unsigned char *)this + 421)) {
        kd_codestream::freeze_comments((uint64_t)this);
      }
      for (uint64_t i = (kd_codestream_comment *)*((void *)this + 11); i; uint64_t i = (kd_codestream_comment *)*((void *)i + 3))
        **((void **)this + 46) += (int)kd_codestream_comment::write_marker(i, *((kdu_output **)this + 2), 0);
    }
    if (*((_DWORD *)this + 26)) {
      kd_codestream::generate_codestream();
    }
    int v6 = (kdu_params *)kdu_params::access_cluster(*((kdu_params **)this + 3), "ORG");
    if (!v6) {
      kd_codestream::generate_codestream();
    }
    int v20 = 0;
    if (!kdu_params::get(v6, "ORGgen_tlm", 0, 0, &v20, 1, 1, 1) || v20 < 1) {
      goto LABEL_25;
    }
    if (v20 >= 0x100) {
      int v20 = 255;
    }
    uint64_t v7 = (void *)*((void *)this + 2);
    (*(void (**)(void *))(*v7 + 16))(v7);
    uint64_t v8 = v7[67];
    if ((*(unsigned int (**)(uint64_t, void))(*(void *)v8 + 24))(v8, 0))
    {
      (*(void (**)(uint64_t))(*(void *)v8 + 32))(v8);
      if (kd_tlm_generator::init((kd_codestream *)((char *)this + 104), *((_DWORD *)this + 55) * *((_DWORD *)this + 56), v20))
      {
        if (*((unsigned char *)this + 281)) {
          kd_tlm_generator::write_dummy_tlms((int *)this + 26, *((kd_compressed_output **)this + 2));
        }
        goto LABEL_25;
      }
      uint64_t v23 = 0;
      long long v21 = 0u;
      long long v22 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v21, "Kakadu Core Warning:\n");
    }
    else
    {
      uint64_t v23 = 0;
      long long v21 = 0u;
      long long v22 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v21, "Kakadu Core Warning:\n");
    }
    kdu_warning::~kdu_warning((kdu_warning *)&v21);
LABEL_25:
    if (*((void *)this + 53)) {
      kd_codestream::generate_codestream();
    }
    uint64_t v9 = *(void *)(*((void *)this + 2) + 544)
       - *((void *)this + 2)
       + *(void *)(*((void *)this + 2) + 520)
       - 8;
    *((void *)this + 53) = v9;
    if (!*((unsigned char *)this + 281) && v9) {
      kd_codestream::generate_codestream();
    }
    goto LABEL_28;
  }
  do
  {
LABEL_28:
    uint64_t v10 = (kd_tile *)*((void *)this + 42);
    if (!v10) {
      break;
    }
    char v11 = 1;
    do
    {
      uint64_t v12 = (kd_tile *)*((void *)v10 + 5);
      uint64_t v13 = *((void *)v10 + 3);
      uint64_t tile_part = kd_tile::generate_tile_part(v10, a2, *((unsigned __int16 **)this + 48));
      BOOL v16 = *(void *)(v13 + 16) == -1 || tile_part < 1;
      v11 &= v16;
      uint64_t v10 = v12;
    }
    while (v12);
  }
  while ((v11 & 1) == 0);
  int v17 = *((_DWORD *)this + 90);
  if (!v17)
  {
    uint64_t v18 = (kdu_compressed_target **)*((void *)this + 2);
    if (*((int *)this + 26) >= 1)
    {
      (*((void (**)(void))*v18 + 2))(*((void *)this + 2));
      kd_tlm_generator::write_tlms((uint64_t)this + 104, v18[67], *((_DWORD *)this + 74), *((void *)this + 38));
      uint64_t v18 = (kdu_compressed_target **)*((void *)this + 2);
    }
    if (*((unsigned char *)this + 282))
    {
      kdu_output::put((kdu_output *)v18, 255);
      kdu_output::put((kdu_output *)v18, 217);
      **((void **)this + 46) += 2;
      uint64_t v18 = (kdu_compressed_target **)*((void *)this + 2);
    }
    (*((void (**)(kdu_compressed_target **))*v18 + 2))(v18);
    int v17 = *((_DWORD *)this + 90);
  }
  return v17 == 0;
}

void sub_18867165C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

uint64_t kd_codestream::unload_tiles_to_cache_threshold(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 504);
  if (v1 >= 1)
  {
    uint64_t v2 = this;
    uint64_t v3 = (_DWORD *)(this + 264);
    do
    {
      if (v1 <= *(_DWORD *)(v2 + 508)
        && *(void *)(*(void *)(v2 + 48) + 56) >= *(void *)(*(void *)(v2 + 48) + 40)
                                                     + 220 * *(void *)(*(void *)(v2 + 48) + 24))
      {
        break;
      }
      uint64_t v4 = *(void *)(v2 + 496);
      if (!v4) {
        goto LABEL_12;
      }
      while (1)
      {
        BOOL v5 = kdu_dims::intersects((_DWORD *)(v4 + 212), v3);
        uint64_t v6 = *(void *)(v2 + 496);
        if (!v5) {
          break;
        }
        uint64_t v4 = *(void *)(v6 + 56);
        *(void *)(v2 + 496) = v4;
        if (!v4) {
          goto LABEL_12;
        }
      }
      if (v6)
      {
        if (!*(unsigned char *)(v6 + 290)) {
          kd_codestream::unload_tiles_to_cache_threshold();
        }
      }
      else
      {
LABEL_12:
        uint64_t v6 = *(void *)(v2 + 480);
      }
      this = kd_tile::release((kd_tile *)v6);
      int v1 = *(_DWORD *)(v2 + 504);
    }
    while (v1 > 0);
  }
  return this;
}

void kdu_codestream::create(kdu_codestream *this, siz_params *a2, kdu_compressed_target *a3, kdu_dims *a4)
{
  if (a3)
  {
    if (!*(void *)this) {
      operator new();
    }
  }
  kdu_codestream::create();
}

void sub_1886718B8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void kdu_codestream::create(kdu_codestream *this, kdu_compressed_source *a2)
{
  if (!*(void *)this) {
    operator new();
  }
  kdu_codestream::create();
}

void sub_188671B68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188671B74()
{
  _Unwind_Resume(v0);
}

void kdu_codestream::restart(kdu_codestream *this, kdu_compressed_source *a2)
{
  if (!*(unsigned char *)(*(void *)this + 408))
  {
    *(void *)&long long v5 = 0;
    long long v3 = 0u;
    long long v4 = 0u;
    kdu_error::kdu_error((kdu_error *)&v3, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v3);
  }
  uint64_t v2 = *(void *)(*(void *)this + 8);
  if (!v2)
  {
    *(void *)&long long v5 = 0;
    long long v3 = 0u;
    long long v4 = 0u;
    kdu_error::kdu_error((kdu_error *)&v3, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v3);
  }
  (*(void (**)(uint64_t, kdu_compressed_source *))(*(void *)v2 + 8))(v2, a2);
  operator new();
}

void sub_18867212C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188672138(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(v17);
}

uint64_t kdu_codestream::destroy(kd_codestream **this)
{
  uint64_t v2 = *this;
  if (!v2) {
    kdu_codestream::destroy();
  }
  kd_codestream::~kd_codestream(v2);
  uint64_t result = MEMORY[0x18C11C0E0]();
  *this = 0;
  return result;
}

uint64_t kdu_codestream::augment_cache_threshold(kdu_codestream *this, int a2)
{
  uint64_t v2 = *(void *)(*(void *)this + 48);
  uint64_t result = *(void *)(v2 + 56) + a2;
  *(void *)(v2 + 56) = result;
  return result;
}

uint64_t *kdu_codestream::enable_restart(uint64_t *this)
{
  uint64_t v1 = *this;
  if (!*(unsigned char *)(*this + 408))
  {
    if (*(unsigned char *)(v1 + 419))
    {
      uint64_t v3 = 0;
      memset(v2, 0, sizeof(v2));
      kdu_error::kdu_error((kdu_error *)v2, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)v2);
    }
    *(unsigned char *)(v1 + 408) = 1;
  }
  return this;
}

void sub_1886722AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886722B8()
{
  _Unwind_Resume(v0);
}

uint64_t *kdu_codestream::set_persistent(uint64_t *this)
{
  uint64_t v1 = *this;
  if (*(void *)(*this + 8))
  {
    if (*(unsigned char *)(v1 + 419))
    {
      uint64_t v3 = 0;
      memset(v2, 0, sizeof(v2));
      kdu_error::kdu_error((kdu_error *)v2, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v2[0] + 16))(v2, "You may only set the codestream object into its \"persistent\" mode prior to opening the first tile.");
      kdu_error::~kdu_error((kdu_error *)v2);
    }
    *(unsigned char *)(v1 + 417) = 1;
  }
  return this;
}

void sub_188672364(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188672370()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_codestream::access_siz(kdu_codestream *this)
{
  return *(void *)(*(void *)this + 24);
}

uint64_t kdu_codestream::set_max_bytes(kdu_codestream *this, uint64_t a2, char a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)this;
  if (*(unsigned char *)(*(void *)this + 419)) {
    kdu_codestream::set_max_bytes();
  }
  uint64_t result = *(void *)(v3 + 8);
  if (result)
  {
    *(unsigned char *)(v3 + 416) = a3;
    uint64_t result = kd_compressed_input::set_max_bytes(result, a2);
    if (*(unsigned char *)(*(void *)(*(void *)this + 8) + 544))
    {
      uint64_t v9 = 0;
      memset(v8, 0, sizeof(v8));
      kdu_error::kdu_error((kdu_error *)v8, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v8[0] + 16))(v8, "Attempting to impose too small a limit on the number of code-stream bytes. ");
      long long v13 = 0u;
      long long v14 = 0u;
      long long v11 = 0u;
      long long v12 = 0u;
      *(_OWORD *)uint64_t v10 = 0u;
      if (BYTE8(v8[0])) {
        sprintf(v10, "%x");
      }
      else {
        sprintf(v10, "%d");
      }
      (*(void (**)(_OWORD *, char *))(*(void *)&v8[0] + 16))(v8, v10);
      (*(void (**)(_OWORD *, const char *))(*(void *)&v8[0] + 16))(v8, " bytes is insufficient to accomodate even the main header!");
      kdu_error::~kdu_error((kdu_error *)v8);
    }
  }
  else if (*(void *)(v3 + 16))
  {
    if (*(void *)(v3 + 64))
    {
      *(void *)&long long v12 = 0;
      *(_OWORD *)uint64_t v10 = 0u;
      long long v11 = 0u;
      kdu_error::kdu_error((kdu_error *)v10, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v10 + 16))(v10, "\"kdu_codestream::set_max_bytes\" may not be called multiple times.");
      kdu_error::~kdu_error((kdu_error *)v10);
    }
    if (*(int *)(v3 + 168) >= 1)
    {
      signed int v6 = 0;
      uint64_t v7 = 0;
      do
      {
        memset(v10, 0, sizeof(v10));
        kdu_codestream::get_dims(this, v6, (int32x4_t *)v10, 0);
        v7 += *(int *)&v10[8] * (uint64_t)*(int *)&v10[12];
        ++v6;
      }
      while (v6 < *(_DWORD *)(*(void *)this + 168));
    }
    operator new();
  }
  return result;
}

void sub_188672670(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18867267C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

int32x4_t *kdu_codestream::get_dims(kdu_codestream *this, unsigned int a2, int32x4_t *a3, int a4)
{
  uint64_t v6 = *(void *)this;
  if ((a2 & 0x80000000) != 0)
  {
    *a3 = *(int32x4_t *)(v6 + 264);
    goto LABEL_28;
  }
  if (*(unsigned char *)(v6 + 420))
  {
    if (!a4) {
      goto LABEL_8;
    }
  }
  else
  {
    kd_codestream::finalize_construction((kd_codestream *)v6);
    uint64_t v6 = *(void *)this;
    if (!a4) {
      goto LABEL_8;
    }
  }
  if (!*(_DWORD *)(v6 + 184))
  {
    uint64_t v9 = (int **)(*(void *)(v6 + 320) + 48 * *(int *)(*(void *)(v6 + 320) + 48 * a2 + 20) + 8);
    goto LABEL_10;
  }
LABEL_8:
  uint64_t v9 = (int **)(*(void *)(v6 + 312) + 104 * a2 + 96);
LABEL_10:
  uint64_t v10 = *v9;
  int v11 = *(_DWORD *)(v6 + 268);
  int v12 = *(_DWORD *)(v6 + 276) + v11;
  long long v13 = (char *)v10 + *(int *)(v6 + 244);
  char v14 = v13[54];
  int v15 = *v10;
  int v16 = v10[1] << v13[21];
  if (v16 <= 1) {
    unsigned int v17 = 1;
  }
  else {
    unsigned int v17 = v16;
  }
  if (v11 <= 0) {
    uint64_t v18 = -(int)(-v11 / v17);
  }
  else {
    uint64_t v18 = (v11 - 1) / v17 + 1;
  }
  int v19 = *(_DWORD *)(v6 + 264);
  unsigned int v20 = v15 << v14;
  if (v12 <= 0) {
    unsigned int v21 = -(int)(-v12 / v17);
  }
  else {
    unsigned int v21 = (v12 - 1) / v17 + 1;
  }
  int v22 = *(_DWORD *)(v6 + 272) + v19;
  if ((int)v20 <= 1) {
    unsigned int v20 = 1;
  }
  if (v19 <= 0) {
    unsigned int v23 = -(int)(-v19 / v20);
  }
  else {
    unsigned int v23 = (v19 - 1) / v20 + 1;
  }
  if (v22 <= 0) {
    unsigned int v24 = -(int)(-v22 / v20);
  }
  else {
    unsigned int v24 = (v22 - 1) / v20 + 1;
  }
  a3->i64[0] = v23 | (unint64_t)(v18 << 32);
  a3->i64[1] = (v24 - v23) | ((unint64_t)(v21 - v18) << 32);
LABEL_28:
  int v25 = *(unsigned __int8 *)(*(void *)this + 409);
  int v26 = *(unsigned __int8 *)(*(void *)this + 410);
  int v27 = *(unsigned __int8 *)(*(void *)this + 411);

  return kdu_dims::to_apparent(a3, v25, v26, v27);
}

void *kdu_codestream::set_resilient(void *this, char a2)
{
  uint64_t v2 = (unsigned char *)*this;
  v2[412] = 1;
  v2[413] = a2;
  v2[414] = 0;
  return this;
}

uint64_t *kdu_codestream::set_fussy(uint64_t *this)
{
  uint64_t v1 = *this;
  *(unsigned char *)(v1 + 412) = 0;
  *(unsigned char *)(v1 + 414) = 1;
  return this;
}

uint64_t *kdu_codestream::set_fast(uint64_t *this)
{
  uint64_t v1 = *this;
  *(unsigned char *)(v1 + 412) = 0;
  *(unsigned char *)(v1 + 414) = 0;
  return this;
}

uint64_t kdu_codestream::apply_input_restrictions(uint64_t result, int a2, int a3, int a4, int a5, int *a6, int a7)
{
  uint64_t v10 = result;
  uint64_t v11 = *(void *)result;
  if (*(void *)(*(void *)result + 16))
  {
    uint64_t v39 = 0;
    long long v37 = 0u;
    long long v38 = 0u;
    kdu_error::kdu_error((kdu_error *)&v37, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v37);
  }
  if (*(unsigned char *)(v11 + 419))
  {
    if (*(_DWORD *)(v11 + 260))
    {
      uint64_t v39 = 0;
      long long v37 = 0u;
      long long v38 = 0u;
      kdu_error::kdu_error((kdu_error *)&v37, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v37 + 16))(&v37, "You may apply restrictions to the resolution or number of image components only after closing all open tiles.");
      kdu_error::~kdu_error((kdu_error *)&v37);
    }
    if (!*(unsigned char *)(v11 + 417))
    {
      uint64_t v39 = 0;
      long long v37 = 0u;
      long long v38 = 0u;
      kdu_error::kdu_error((kdu_error *)&v37, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v37 + 16))(&v37, "You may not apply restrictions to the resolution or number of image components after the first tile access, unless the codestream object is set up to be persistent.");
      kdu_error::~kdu_error((kdu_error *)&v37);
    }
  }
  *(_DWORD *)(v11 + 244) = a4;
  if (a5 >= 1) {
    int v12 = a5;
  }
  else {
    int v12 = 0xFFFF;
  }
  *(_DWORD *)(v11 + 252) = v12;
  *(_OWORD *)(v11 + 264) = *(_OWORD *)(v11 + 188);
  if (a6) {
    uint64_t result = kdu_dims::operator&=((_DWORD *)(*(void *)result + 264), a6);
  }
  uint64_t v13 = *(void *)v10;
  *(void *)(v13 + 496) = *(void *)(*(void *)v10 + 480);
  *(_DWORD *)(v13 + 184) = a7;
  if (a7)
  {
    if (a7 != 1) {
      kdu_codestream::apply_input_restrictions();
    }
    if (a2 < 0 || (int v14 = *(_DWORD *)(v13 + 168), v14 <= a2))
    {
      uint64_t v39 = 0;
      long long v37 = 0u;
      long long v38 = 0u;
      kdu_error::kdu_error((kdu_error *)&v37, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v37);
    }
    *(_DWORD *)(v13 + 180) = 0;
    int v15 = v14 - a2;
    if (v15 > a3 && a3 > 0) {
      int v15 = a3;
    }
    *(_DWORD *)(v13 + 172) = v15;
    uint64_t v17 = *(void *)v10;
    if (*(int *)(*(void *)v10 + 168) >= 1)
    {
      uint64_t v18 = 0;
      uint64_t v19 = 0;
      int v20 = 0;
      do
      {
        int v21 = v19 - a2;
        uint64_t v22 = *(void *)(v17 + 312) + v18;
        if ((int)v19 - a2 >= *(_DWORD *)(v17 + 172)) {
          int v21 = -1;
        }
        *(_DWORD *)(v22 + 88) = v21;
        *(void *)(v22 + 96) = 0;
        uint64_t v17 = *(void *)v10;
        if ((v21 & 0x80000000) == 0)
        {
          uint64_t v23 = *(void *)(v17 + 312) + 104 * v20++;
          *(void *)(v23 + 96) = v22;
        }
        ++v19;
        v18 += 104;
      }
      while (v19 < *(int *)(v17 + 168));
    }
  }
  else
  {
    uint64_t v24 = *(unsigned int *)(v13 + 168);
    *(_DWORD *)(v13 + 172) = v24;
    if ((int)v24 >= 1)
    {
      uint64_t v25 = 0;
      uint64_t v26 = *(void *)(v13 + 312);
      do
      {
        *(_DWORD *)(v26 + 88) = v25;
        *(void *)(v26 + 96) = v26;
        ++v25;
        v26 += 104;
      }
      while (v24 != v25);
    }
    if (a2 < 0 || (int v27 = *(_DWORD *)(v13 + 176), v27 <= a2))
    {
      uint64_t v39 = 0;
      long long v37 = 0u;
      long long v38 = 0u;
      kdu_error::kdu_error((kdu_error *)&v37, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v37);
    }
    int v28 = v27 - a2;
    if (v28 > a3 && a3 > 0) {
      int v28 = a3;
    }
    *(_DWORD *)(v13 + 180) = v28;
    uint64_t v30 = *(void *)v10;
    if (*(int *)(*(void *)v10 + 176) >= 1)
    {
      uint64_t v31 = 0;
      uint64_t v32 = 0;
      int v33 = 0;
      do
      {
        int v34 = v32 - a2;
        uint64_t v35 = *(void *)(v30 + 320) + v31;
        if ((int)v32 - a2 >= *(_DWORD *)(v30 + 180)) {
          int v34 = -1;
        }
        *(_DWORD *)(v35 + 16) = v34;
        *(_DWORD *)(v35 + 20) = 0;
        uint64_t v30 = *(void *)v10;
        if ((v34 & 0x80000000) == 0)
        {
          uint64_t v36 = *(void *)(v30 + 320) + 48 * v33++;
          *(_DWORD *)(v36 + 20) = v32;
        }
        ++v32;
        v31 += 48;
      }
      while (v32 < *(int *)(v30 + 176));
    }
  }
  return result;
}

void sub_188672CA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188672CAC()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_codestream::apply_input_restrictions(uint64_t a1, int a2, uint64_t a3, int a4, int a5, int *a6, int a7)
{
  uint64_t result = kdu_codestream::apply_input_restrictions(a1, 0, 0, a4, a5, a6, a7);
  if (a7 == 1)
  {
    uint64_t v23 = *(void *)a1;
    int v24 = *(_DWORD *)(*(void *)a1 + 168);
    if (v24 >= 1)
    {
      uint64_t v25 = (void *)(*(void *)(v23 + 312) + 96);
      uint64_t v26 = *(unsigned int *)(*(void *)a1 + 168);
      do
      {
        *uint64_t v25 = 0;
        *((_DWORD *)v25 - 2) = -1;
        v25 += 13;
        --v26;
      }
      while (v26);
    }
    *(_DWORD *)(v23 + 172) = a2;
    if (a2 >= 1)
    {
      uint64_t v27 = 0;
      int v28 = 0;
      do
      {
        if (v27 < v24)
        {
          int v29 = *(_DWORD *)(a3 + 4 * v27);
          if (v29 < v24)
          {
            uint64_t v30 = *(void *)(v23 + 312);
            uint64_t v31 = v30 + 104 * v29;
            unsigned int v33 = *(_DWORD *)(v31 + 88);
            uint64_t v32 = (_DWORD *)(v31 + 88);
            uint64_t result = v33;
            if ((v33 & 0x80000000) != 0)
            {
              *uint64_t v32 = v28;
              *(void *)(v30 + 104 * v28++ + 96) = v30 + 104 * v29;
            }
          }
        }
        ++v27;
      }
      while (a2 != v27);
    }
  }
  else
  {
    if (a7) {
      kdu_codestream::apply_input_restrictions();
    }
    uint64_t v12 = *(void *)a1;
    int v13 = *(_DWORD *)(*(void *)a1 + 176);
    if (v13 >= 1)
    {
      int v14 = (void *)(*(void *)(v12 + 320) + 16);
      uint64_t v15 = *(unsigned int *)(*(void *)a1 + 176);
      do
      {
        void *v14 = 0xFFFFFFFFLL;
        v14 += 6;
        --v15;
      }
      while (v15);
    }
    *(_DWORD *)(v12 + 180) = a2;
    if (a2 >= 1)
    {
      uint64_t v16 = 0;
      int v17 = 0;
      do
      {
        if (v16 < v13)
        {
          int v18 = *(_DWORD *)(a3 + 4 * v16);
          if (v18 < v13)
          {
            uint64_t v19 = *(void *)(v12 + 320);
            uint64_t v20 = v19 + 48 * v18;
            unsigned int v22 = *(_DWORD *)(v20 + 16);
            int v21 = (_DWORD *)(v20 + 16);
            uint64_t result = v22;
            if ((v22 & 0x80000000) != 0)
            {
              *int v21 = v17;
              *(_DWORD *)(v19 + 48 * v17++ + 20) = v18;
            }
          }
        }
        ++v16;
      }
      while (a2 != v16);
    }
  }
  return result;
}

uint64_t *kdu_codestream::change_appearance(uint64_t *this, char a2, char a3, char a4)
{
  uint64_t v4 = *this;
  if (*(unsigned char *)(*this + 419))
  {
    if (*(_DWORD *)(v4 + 260))
    {
      uint64_t v7 = 0;
      long long v5 = 0u;
      long long v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v5 + 16))(&v5, "You may change the apparent geometry of the code-stream only after closing all open tiles.");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
    if (!*(unsigned char *)(v4 + 417))
    {
      uint64_t v7 = 0;
      long long v5 = 0u;
      long long v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v5 + 16))(&v5, "You may not change the apparent geometry of the code-stream after the first tile access, unless the codestream object is set up to be persistent.");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
  }
  *(unsigned char *)(v4 + 409) = a2;
  *(unsigned char *)(v4 + 410) = a3;
  *(unsigned char *)(v4 + 411) = a4;
  return this;
}

void sub_188672FA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188672FB0()
{
  _Unwind_Resume(v0);
}

int32x4_t *kdu_codestream::get_tile_dims(uint64_t *a1, uint64_t a2, unsigned int a3, int32x4_t *a4, int a5)
{
  uint64_t v5 = *a1;
  if (*(unsigned char *)(*a1 + 411)) {
    int v6 = -HIDWORD(a2);
  }
  else {
    int v6 = HIDWORD(a2);
  }
  if (*(unsigned char *)(*a1 + 410)) {
    int v7 = -(int)a2;
  }
  else {
    int v7 = a2;
  }
  if (*(unsigned char *)(*a1 + 409)) {
    int v8 = v7;
  }
  else {
    int v8 = v6;
  }
  if (*(unsigned char *)(*a1 + 409)) {
    int v9 = v6;
  }
  else {
    int v9 = v7;
  }
  if (v8 < 0 || v8 >= *(_DWORD *)(v5 + 224) || v9 < 0 || v9 >= *(_DWORD *)(v5 + 220)) {
    kdu_codestream::get_tile_dims();
  }
  *a4 = *(int32x4_t *)(v5 + 204);
  int v14 = a4->i32[1] + a4->i32[3] * v8;
  a4->i32[0] += a4->i32[2] * v9;
  a4->i32[1] = v14;
  kdu_dims::operator&=(a4, (int *)(*a1 + 188));
  if (!*(void *)(*a1 + 16)) {
    kdu_dims::operator&=(a4, (int *)(*a1 + 264));
  }
  int v15 = a4->i32[0];
  int v16 = a4->i32[1];
  __int32 v17 = a4->i32[2];
  __int32 v18 = a4->i32[3];
  if ((a3 & 0x80000000) != 0)
  {
    int v20 = 1;
    int v21 = 1;
    goto LABEL_28;
  }
  uint64_t v19 = *a1;
  if (*(unsigned char *)(*a1 + 420))
  {
    if (!a5) {
      goto LABEL_26;
    }
  }
  else
  {
    kd_codestream::finalize_construction((kd_codestream *)v19);
    uint64_t v19 = *a1;
    if (!a5) {
      goto LABEL_26;
    }
  }
  if (!*(_DWORD *)(v19 + 184))
  {
    unsigned int v22 = (int **)(*(void *)(v19 + 320) + 48 * *(int *)(*(void *)(v19 + 320) + 48 * a3 + 20) + 8);
    goto LABEL_27;
  }
LABEL_26:
  unsigned int v22 = (int **)(*(void *)(v19 + 312) + 104 * a3 + 96);
LABEL_27:
  uint64_t v23 = *v22;
  int v24 = *v23;
  uint64_t v25 = (char *)v23 + *(int *)(v19 + 244);
  int v20 = v23[1] << v25[21];
  int v21 = v24 << v25[54];
LABEL_28:
  if (v20 <= 1) {
    unsigned int v26 = 1;
  }
  else {
    unsigned int v26 = v20;
  }
  if (v16 <= 0) {
    uint64_t v27 = -(int)(-v16 / v26);
  }
  else {
    uint64_t v27 = (v16 - 1) / v26 + 1;
  }
  int v28 = v18 + v16;
  if (v21 <= 1) {
    unsigned int v29 = 1;
  }
  else {
    unsigned int v29 = v21;
  }
  if (v15 <= 0) {
    unsigned int v30 = -(int)(-v15 / v29);
  }
  else {
    unsigned int v30 = (v15 - 1) / v29 + 1;
  }
  int v31 = v17 + v15;
  if (v28 <= 0) {
    unsigned int v32 = -(int)(-v28 / v26);
  }
  else {
    unsigned int v32 = (v28 - 1) / v26 + 1;
  }
  if (v31 <= 0) {
    unsigned int v33 = -(int)(-v31 / v29);
  }
  else {
    unsigned int v33 = (v31 - 1) / v29 + 1;
  }
  a4->i64[0] = v30 | (unint64_t)(v27 << 32);
  a4->i64[1] = (v33 - v30) | ((unint64_t)(v32 - v27) << 32);
  int v34 = *(unsigned __int8 *)(*a1 + 409);
  int v35 = *(unsigned __int8 *)(*a1 + 410);
  int v36 = *(unsigned __int8 *)(*a1 + 411);

  return kdu_dims::to_apparent(a4, v34, v35, v36);
}

uint64_t kdu_codestream::get_num_components(unsigned int **this, int a2)
{
  uint64_t v2 = *this;
  if (a2 && !v2[46]) {
    uint64_t v3 = v2 + 45;
  }
  else {
    uint64_t v3 = v2 + 43;
  }
  return *v3;
}

uint64_t kdu_codestream::get_bit_depth(kdu_codestream *this, unsigned int a2, int a3)
{
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v3 = *(void *)this;
    if (a3 && !*(_DWORD *)(v3 + 184))
    {
      if (*(_DWORD *)(v3 + 180) > (signed int)a2)
      {
        uint64_t v4 = (unsigned int *)(*(void *)(v3 + 320) + 48 * *(int *)(*(void *)(v3 + 320) + 48 * a2 + 20));
        return *v4;
      }
    }
    else if (*(_DWORD *)(v3 + 172) > (signed int)a2)
    {
      uint64_t v4 = (unsigned int *)(*(void *)(*(void *)(v3 + 312) + 104 * a2 + 96) + 16);
      return *v4;
    }
  }
  return 0;
}

BOOL kdu_codestream::get_signed(kdu_codestream *this, unsigned int a2, int a3)
{
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v3 = *(void *)this;
    if (a3 && !*(_DWORD *)(v3 + 184))
    {
      if (*(_DWORD *)(v3 + 180) > (signed int)a2)
      {
        uint64_t v4 = (unsigned __int8 *)(*(void *)(v3 + 320) + 48 * *(int *)(*(void *)(v3 + 320) + 48 * a2 + 20) + 4);
        return *v4 != 0;
      }
    }
    else if (*(_DWORD *)(v3 + 172) > (signed int)a2)
    {
      uint64_t v4 = (unsigned __int8 *)(*(void *)(*(void *)(v3 + 312) + 104 * a2 + 96) + 20);
      return *v4 != 0;
    }
  }
  return 0;
}

void kdu_codestream::get_subsampling(kd_codestream **a1, int a2, uint64_t a3, int a4)
{
  int v8 = *a1;
  if (*((unsigned char *)v8 + 420))
  {
    if (a2 < 0) {
      goto LABEL_14;
    }
  }
  else
  {
    kd_codestream::finalize_construction(v8);
    if (a2 < 0) {
      goto LABEL_14;
    }
  }
  int v9 = *a1;
  if (!a4 || *((_DWORD *)v9 + 46))
  {
    if (*((_DWORD *)v9 + 43) > a2)
    {
      uint64_t v10 = (uint64_t **)(*((void *)v9 + 39) + 104 * a2 + 96);
      goto LABEL_9;
    }
LABEL_14:
    *(void *)a3 = 0;
    return;
  }
  int v17 = *((_DWORD *)v9 + 45);
  if (v17 >= 5 || v17 <= a2) {
    goto LABEL_14;
  }
  uint64_t v10 = (uint64_t **)(*((void *)v9 + 40) + 48 * *(int *)(*((void *)v9 + 40) + 48 * a2 + 20) + 8);
LABEL_9:
  uint64_t v11 = *v10;
  uint64_t v12 = *v11;
  *(void *)a3 = *v11;
  int v13 = *a1;
  int v14 = (char *)v11 + *((int *)*a1 + 61);
  int v15 = HIDWORD(v12) << v14[21];
  *(_DWORD *)(a3 + 4) = v15;
  int v16 = v12 << v14[54];
  *(_DWORD *)a3 = v16;
  if (*((unsigned char *)v13 + 409))
  {
    *(_DWORD *)a3 = v15;
    *(_DWORD *)(a3 + 4) = v16;
  }
}

void kdu_codestream::get_registration(kd_codestream **a1, unsigned int a2, uint64_t a3, int8x8_t *a4, int a5)
{
  uint64_t v10 = *a1;
  if (*((unsigned char *)v10 + 420))
  {
    if ((a2 & 0x80000000) != 0) {
      goto LABEL_12;
    }
  }
  else
  {
    kd_codestream::finalize_construction(v10);
    if ((a2 & 0x80000000) != 0) {
      goto LABEL_12;
    }
  }
  uint64_t v11 = *a1;
  if (a5 && !*((_DWORD *)v11 + 46))
  {
    if (*((_DWORD *)v11 + 45) > (signed int)a2)
    {
      uint64_t v12 = (int32x2_t **)(*((void *)v11 + 40) + 48 * *(int *)(*((void *)v11 + 40) + 48 * a2 + 20) + 8);
      goto LABEL_9;
    }
  }
  else if (*((_DWORD *)v11 + 43) > (signed int)a2)
  {
    uint64_t v12 = (int32x2_t **)(*((void *)v11 + 39) + 104 * a2 + 96);
LABEL_9:
    int8x8_t v13 = (int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(*((unsigned char *)v11 + 409) == 0), 0x1FuLL));
    __asm { FMOV            V2.2D, #0.5 }
    int8x8_t v19 = (int8x8_t)vmovn_s64(vcvtq_s64_f64(vrndmq_f64(vaddq_f64(vcvtq_f64_f32(vmul_f32((float32x2_t)vrev64_s32((*v12)[1]), vcvt_f32_s32((int32x2_t)vbsl_s8(v13, (int8x8_t)a3, (int8x8_t)vrev64_s32((int32x2_t)a3))))), _Q2))));
    LODWORD(_Q2.f64[0]) = *((unsigned __int8 *)v11 + 410);
    HIDWORD(_Q2.f64[0]) = *((unsigned __int8 *)v11 + 411);
    int8x8_t v20 = vbsl_s8(v13, v19, (int8x8_t)vrev64_s32((int32x2_t)v19));
    *a4 = vbsl_s8((int8x8_t)vceqz_s32(*(int32x2_t *)&_Q2.f64[0]), v20, (int8x8_t)vneg_s32((int32x2_t)v20));
    return;
  }
LABEL_12:
  *a4 = 0;
}

uint64_t kdu_codestream::get_min_dwt_levels(kdu_codestream *this)
{
  uint64_t v2 = *(void *)this;
  uint64_t result = *(unsigned int *)(*(void *)this + 248);
  if ((int)result >= 33)
  {
    int v8 = 0;
    uint64_t v4 = (kdu_params *)kdu_params::access_cluster(*(kdu_params **)(v2 + 24), "COD");
    char v5 = kdu_params::get(v4, "Clevels", 0, 0, &v8, 1, 1, 1);
    uint64_t v6 = *(void *)this;
    if (v5)
    {
      uint64_t v7 = v8;
      uint64_t result = *(unsigned int *)(v6 + 248);
      if (v8 < (int)result)
      {
        *(_DWORD *)(v6 + 248) = v8;
        uint64_t result = v7;
      }
    }
    else
    {
      uint64_t result = *(unsigned int *)(v6 + 248);
    }
    if ((int)result >= 33)
    {
      uint64_t result = 32;
      *(_DWORD *)(v6 + 248) = 32;
    }
  }
  return result;
}

BOOL kdu_codestream::can_flip(kdu_codestream *this)
{
  uint64_t v1 = *(void *)this;
  if (!*(unsigned char *)(*(void *)this + 280)) {
    return 1;
  }
  if (*(unsigned char *)(v1 + 411)) {
    return 0;
  }
  return *(unsigned char *)(v1 + 410) == 0;
}

uint64_t kdu_codestream::map_region(void *a1, unsigned int a2, unint64_t a3, unint64_t a4, uint64_t a5, int a6)
{
  unint64_t v8 = HIDWORD(a3);
  unint64_t v9 = HIDWORD(a4);
  uint64_t v10 = *a1;
  if (*(unsigned char *)(v10 + 411)) {
    LODWORD(v8) = 1 - (HIDWORD(a4) + HIDWORD(a3));
  }
  if (*(unsigned char *)(v10 + 410)) {
    unsigned int v11 = 1 - (a4 + a3);
  }
  else {
    unsigned int v11 = a3;
  }
  if (*(unsigned char *)(v10 + 409)) {
    int v12 = a4;
  }
  else {
    int v12 = HIDWORD(a4);
  }
  if (*(unsigned char *)(v10 + 409))
  {
    uint64_t v13 = v11;
  }
  else
  {
    LODWORD(v9) = a4;
    uint64_t v13 = v8;
  }
  if (*(unsigned char *)(v10 + 409)) {
    unsigned int v14 = v8;
  }
  else {
    unsigned int v14 = v11;
  }
  int v15 = v13 + v12;
  int v16 = v14 + v9;
  if ((a2 & 0x80000000) == 0)
  {
    if (*(unsigned char *)(v10 + 420))
    {
      if (!a6) {
        goto LABEL_21;
      }
    }
    else
    {
      kd_codestream::finalize_construction((kd_codestream *)v10);
      uint64_t v10 = *a1;
      if (!a6) {
        goto LABEL_21;
      }
    }
    if (!*(_DWORD *)(v10 + 184))
    {
      int8x8_t v19 = (_DWORD **)(*(void *)(v10 + 320) + 48 * *(int *)(*(void *)(v10 + 320) + 48 * a2 + 20) + 8);
      goto LABEL_23;
    }
LABEL_21:
    int8x8_t v19 = (_DWORD **)(*(void *)(v10 + 312) + 104 * a2 + 96);
LABEL_23:
    int8x8_t v20 = *v19;
    int v21 = (char *)v20 + *(int *)(v10 + 244);
    int v22 = v20[1] << v21[21];
    uint64_t v13 = (v22 * v13);
    LODWORD(v20) = *v20 << v21[54];
    v14 *= v20;
    v15 *= v22;
    v16 *= v20;
  }
  *(void *)a5 = v14 | (unint64_t)(v13 << 32);
  *(void *)(a5 + 8) = (v16 - v14) | ((unint64_t)(v15 - v13) << 32);
  uint64_t v23 = (int *)(*a1 + 188);

  return kdu_dims::operator&=((_DWORD *)a5, v23);
}

int32x4_t *kdu_codestream::get_valid_tiles(kdu_codestream *this, int32x4_t *a2)
{
  unsigned int v2 = *(_DWORD *)(*(void *)this + 268) - *(_DWORD *)(*(void *)this + 208);
  unsigned int v3 = *(_DWORD *)(*(void *)this + 264) - *(_DWORD *)(*(void *)this + 204);
  int v4 = *(_DWORD *)(*(void *)this + 276);
  int v5 = v4 + v2;
  unsigned int v6 = *(_DWORD *)(*(void *)this + 216);
  if ((int)v6 <= 1) {
    unsigned int v6 = 1;
  }
  if ((v2 & 0x80000000) != 0) {
    unsigned int v7 = ~(~v2 / v6);
  }
  else {
    unsigned int v7 = v2 / v6;
  }
  int v8 = *(_DWORD *)(*(void *)this + 272);
  a2->i32[1] = v7;
  if (v5 <= 0) {
    unsigned int v9 = -(int)(-v5 / v6);
  }
  else {
    unsigned int v9 = (v5 - 1) / v6 + 1;
  }
  int v10 = v8 + v3;
  unsigned int v11 = v9 - v7;
  if (v4 <= 0) {
    __int32 v12 = 0;
  }
  else {
    __int32 v12 = v11;
  }
  a2->i32[3] = v12;
  unsigned int v13 = *(_DWORD *)(*(void *)this + 212);
  if ((int)v13 <= 1) {
    unsigned int v13 = 1;
  }
  if ((v3 & 0x80000000) != 0) {
    unsigned int v14 = ~(~v3 / v13);
  }
  else {
    unsigned int v14 = v3 / v13;
  }
  a2->i32[0] = v14;
  if (v10 <= 0) {
    unsigned int v15 = -(int)(-v10 / v13);
  }
  else {
    unsigned int v15 = (v10 - 1) / v13 + 1;
  }
  unsigned int v16 = v15 - v14;
  if (v8 <= 0) {
    __int32 v17 = 0;
  }
  else {
    __int32 v17 = v16;
  }
  a2->i32[2] = v17;
  return kdu_dims::to_apparent(a2, *(unsigned __int8 *)(*(void *)this + 409), *(unsigned __int8 *)(*(void *)this + 410), *(unsigned __int8 *)(*(void *)this + 411));
}

uint64_t kdu_codestream::open_tile(uint64_t *a1, unint64_t a2, kdu_thread_entity *this)
{
  int v4 = a2;
  unint64_t v6 = HIDWORD(a2);
  if (this) {
    kdu_thread_entity::acquire_lock(this, 0, 1);
  }
  uint64_t v7 = *a1;
  *(unsigned char *)(v7 + 419) = 1;
  if (!*(unsigned char *)(v7 + 420))
  {
    kd_codestream::finalize_construction((kd_codestream *)v7);
    uint64_t v7 = *a1;
  }
  if (*(unsigned char *)(v7 + 411)) {
    unsigned int v8 = -(int)v6;
  }
  else {
    unsigned int v8 = v6;
  }
  if (*(unsigned char *)(v7 + 410)) {
    LODWORD(v9) = -v4;
  }
  else {
    LODWORD(v9) = v4;
  }
  if (*(unsigned char *)(v7 + 409)) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = v8;
  }
  if (*(unsigned char *)(v7 + 409)) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = v9;
  }
  if ((v10 & 0x80000000) != 0
    || (int)v10 >= *(_DWORD *)(v7 + 224)
    || (v9 & 0x80000000) != 0
    || (int)v9 >= *(_DWORD *)(v7 + 220))
  {
    kdu_codestream::open_tile();
  }
  unsigned int v11 = v10 - *(_DWORD *)(v7 + 232);
  if ((v11 & 0x80000000) != 0
    || (int v12 = v9 - *(_DWORD *)(v7 + 228), v12 < 0)
    || (int v13 = *(_DWORD *)(v7 + 240), v13 <= (int)v11)
    || *(_DWORD *)(v7 + 236) <= v12)
  {
    kdu_codestream::open_tile();
  }
  uint64_t v14 = *(void *)(v7 + 328) + 24 * v11 + 24 * v13 * v12;
  uint64_t tile = *(void *)(v14 + 16);
  if (tile == -1) {
    goto LABEL_34;
  }
  if (tile)
  {
    if (*(unsigned char *)(tile + 293))
    {
      if (!*(unsigned char *)(v7 + 408) || *(void *)v14) {
        kdu_codestream::open_tile();
      }
      kd_tile::reinitialize(*(kd_tile **)(v14 + 16));
    }
  }
  else
  {
    uint64_t tile = kd_codestream::create_tile(v7, v9 | (v10 << 32));
  }
  if (tile == -1 || *(unsigned char *)(tile + 291))
  {
LABEL_34:
    uint64_t v18 = 0;
    memset(v17, 0, sizeof(v17));
    kdu_error::kdu_error((kdu_error *)v17, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v17[0] + 16))(v17, "Attempting to access a tile which has already been discarded or closed!");
    kdu_error::~kdu_error((kdu_error *)v17);
  }
  if (*(void *)(tile + 24) != v14) {
    kdu_codestream::open_tile();
  }
  kd_tile::open((kd_tile *)tile);
  if (this) {
    kdu_thread_entity::release_lock(this, 0);
  }
  return tile;
}

void sub_188673A44(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188673A50()
{
  _Unwind_Resume(v0);
}

void kdu_codestream::flush(uint64_t *a1, void *a2, unsigned int a3, __int16 *a4, int a5, int a6, kdu_thread_entity *this, double a8)
{
  unsigned int v8 = this;
  if (this) {
    kdu_thread_entity::acquire_lock(this, 0, 1);
  }
  signed int v16 = a3 - 1;
  if ((int)a3 < 1 || (uint64_t v17 = *a1, !*(void *)(*a1 + 16))) {
    kdu_codestream::flush();
  }
  if (!*(unsigned char *)(v17 + 420))
  {
    kd_codestream::finalize_construction((kd_codestream *)v17);
    uint64_t v17 = *a1;
  }
  uint64_t v18 = *(_WORD **)(v17 + 384);
  if (!*(void *)(v17 + 376))
  {
    if (!v18 && !*(void *)(v17 + 368))
    {
      *(_DWORD *)(v17 + 364) = a3;
      operator new[]();
    }
    kdu_codestream::flush();
  }
  if (!v18 || !*(void *)(v17 + 368)) {
    kdu_codestream::flush();
  }
  if (*(_DWORD *)(v17 + 364) != a3)
  {
    uint64_t v48 = 0;
    *(_OWORD *)int v46 = 0u;
    long long v47 = 0u;
    kdu_error::kdu_error((kdu_error *)v46, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)v46);
  }
  int v19 = (unsigned __int16)*v18;
  if (*v18) {
    BOOL v20 = 0;
  }
  else {
    BOOL v20 = *(void *)(*(void *)(v17 + 376) + 8 * v16) == 0;
  }
  char v21 = !v20;
  if (a4 && *v18 && *a4)
  {
    uint64_t v22 = a3;
    uint64_t v23 = a4;
    do
    {
      __int16 v24 = *v23++;
      *v18++ = v24;
      --v22;
    }
    while (v22);
  }
  *(_DWORD *)(v17 + 432) = 0;
  if (a6 && !*(unsigned char *)(v17 + 422) && *(unsigned char *)(v17 + 281)) {
    kd_codestream::set_reserved_layer_info_bytes(v17, a3);
  }
  uint64_t v45 = v16;
  if (v19)
  {
    uint64_t v25 = v8;
    char v26 = v21;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    v46[0] = 0;
    uint64_t v29 = *a1;
    do
    {
      v28 += kd_codestream::simulate_output((kdu_params **)v29, v46, v27, *(unsigned __int16 *)(*(void *)(v29 + 384) + 2 * v27), 1, a3 - 1 == v27, 0x10000000000000, 0);
      uint64_t v29 = *a1;
      *(void *)(*(void *)(*a1 + 376) + 8 * v27++) = v28;
    }
    while (a3 != v27);
    char v21 = v26;
    unsigned int v8 = v25;
  }
  else
  {
    uint64_t v30 = *a1;
    if (a5)
    {
      int v31 = *(_DWORD *)(v30 + 168);
      if (v31 < 1)
      {
        BOOL v36 = 1;
      }
      else
      {
        int v32 = 33 * v31;
        unsigned int v33 = (uint64_t *)(*(void *)(v30 + 352) + 64);
        do
        {
          uint64_t v34 = *v33;
          uint64_t v35 = *(v33 - 3);
          BOOL v36 = *v33 >= v35;
          if (v32 < 2) {
            break;
          }
          --v32;
          v33 += 11;
        }
        while (v34 >= v35);
      }
    }
    else
    {
      BOOL v36 = 0;
    }
    kd_codestream::pcrd_opt((kd_codestream *)v30, v36, a8);
  }
  uint64_t v37 = *a1;
  if (*(_DWORD *)(*a1 + 432) && *(unsigned char *)(v37 + 281) && !*(unsigned char *)(v37 + 422))
  {
    kd_codestream::gen_layer_info_comment(v37, a3, *(uint64_t **)(v37 + 376), *(unsigned __int16 **)(v37 + 384));
    uint64_t v37 = *a1;
  }
  kd_codestream::generate_codestream((kd_codestream *)v37, a3);
  uint64_t v38 = a3;
  if (a4)
  {
    uint64_t v39 = *(__int16 **)(*a1 + 384);
    uint64_t v40 = a3;
    do
    {
      __int16 v41 = *v39++;
      *a4++ = v41;
      --v40;
    }
    while (v40);
  }
  if (a2)
  {
    uint64_t v42 = 0;
    uint64_t v43 = *(uint64_t **)(*a1 + 368);
    do
    {
      uint64_t v44 = *v43++;
      v42 += v44;
      *a2++ = v42;
      --v38;
    }
    while (v38);
  }
  if (!v19)
  {
    bzero(*(void **)(*a1 + 384), 2 * a3);
    if ((v21 & 1) == 0) {
      *(void *)(*(void *)(*a1 + 376) + 8 * v45) = 0;
    }
  }
  if (v8) {
    kdu_thread_entity::release_lock(v8, 0);
  }
}

void sub_188673E64(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188673E70()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_codestream::ready_for_flush(uint64_t *a1, kdu_thread_entity *this)
{
  uint64_t v2 = *a1;
  if (!*a1 || !*(void *)(v2 + 16)) {
    return 0;
  }
  if (this)
  {
    kdu_thread_entity::acquire_lock(this, 0, 1);
    uint64_t v2 = *a1;
  }
  uint64_t v5 = *(void *)(v2 + 336);
  if (!v5)
  {
LABEL_18:
    if (this) {
      kdu_thread_entity::release_lock(this, 0);
    }
    return 0;
  }
  while (1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = 0;
    unint64_t v6 = kd_packet_sequencer::next_in_sequence(*(uint64_t **)(v5 + 96), &v10, &v9);
    if (v6) {
      break;
    }
LABEL_17:
    uint64_t v5 = *(void *)(v5 + 40);
    if (!v5) {
      goto LABEL_18;
    }
  }
  uint64_t v7 = *v6;
  if (!*v6) {
    goto LABEL_12;
  }
  if (v7 == 3) {
    goto LABEL_24;
  }
  if (v7)
  {
LABEL_12:
    uint64_t v7 = kd_precinct_ref::instantiate_precinct(v6, v10, v9);
    if (!v7) {
LABEL_24:
    }
      kdu_codestream::ready_for_flush();
  }
  else
  {
    if (*(unsigned char *)(v7 + 20))
    {
      kd_precinct_size_class::withdraw_from_inactive_list(*(void *)(v7 + 72), (kd_precinct *)v7);
    }
    else if (!*(unsigned char *)(v7 + 19))
    {
      goto LABEL_16;
    }
    kd_precinct::activate(v7);
  }
LABEL_16:
  if (*(_DWORD *)(v7 + 36)) {
    goto LABEL_17;
  }
  if (this) {
    kdu_thread_entity::release_lock(this, 0);
  }
  return 1;
}

void kd_compressed_input::~kd_compressed_input(kd_compressed_input *this)
{
  *(void *)this = &unk_1ED4E5F88;
}

{
  *(void *)this = &unk_1ED4E5F88;
  JUMPOUT(0x18C11C0E0);
}

void kd_compressed_output::~kd_compressed_output(kd_compressed_output *this)
{
  kd_compressed_output::~kd_compressed_output(this);

  JUMPOUT(0x18C11C0E0);
}

{
  *(void *)this = &unk_1ED4E51C8;
  kd_compressed_output::flush_buf((uint64_t)this);
  *(void *)this = &unk_1ED4DE968;
}

uint64_t kd_compressed_output::flush_buf(uint64_t this)
{
  uint64_t v1 = this;
  unint64_t v2 = *(void *)(this + 520);
  uint64_t v3 = this + 8;
  if (v2 > this + 8)
  {
    this = (*(uint64_t (**)(void, uint64_t, void))(**(void **)(this + 536) + 40))(*(void *)(this + 536), v3, (v2 - v3));
    unint64_t v2 = *(void *)(v1 + 520);
  }
  *(void *)(v1 + 544) += v2 - v3;
  *(void *)(v1 + 520) = v3;
  return this;
}

void kd_precinct_server::~kd_precinct_server(kd_precinct_size_class **this)
{
  unint64_t v2 = *this;
  if (v2)
  {
    do
    {
      *this = (kd_precinct_size_class *)*((void *)v2 + 5);
      kd_precinct_size_class::~kd_precinct_size_class(v2);
      MEMORY[0x18C11C0E0]();
      unint64_t v2 = *this;
    }
    while (*this);
  }
}

void kd_precinct_size_class::~kd_precinct_size_class(kd_precinct_size_class *this)
{
  for (uint64_t i = (void *)*((void *)this + 4); i; uint64_t i = (void *)*((void *)this + 4))
  {
    *((void *)this + 4) = i[7];
    free(i);
    --*((_DWORD *)this + 7);
  }
}

void _cg_jinit_d_coef_controller(uint64_t a1, int a2)
{
  int v4 = (uint64_t (**)(uint64_t))(**(uint64_t (***)(void))(a1 + 8))();
  *(void *)(a1 + 592) = v4;
  kdu_params *v4 = start_input_pass;
  void v4[2] = start_output_pass;
  v4[27] = 0;
  if (a2)
  {
    if (*(int *)(a1 + 56) >= 1)
    {
      uint64_t v5 = 0;
      unint64_t v6 = (unsigned int *)(*(void *)(a1 + 304) + 28);
      do
      {
        unsigned int v7 = *(v6 - 4);
        if (*(_DWORD *)(a1 + 316)) {
          uint64_t v8 = 3 * v7;
        }
        else {
          uint64_t v8 = v7;
        }
        uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 40);
        uint64_t v10 = _cg_jround_up(*v6, (int)*(v6 - 5));
        uint64_t v11 = _cg_jround_up(v6[1], (int)*(v6 - 4));
        v4[v5++ + 17] = (uint64_t (*)(uint64_t))v9(a1, 1, 1, v10, v11, v8);
        v6 += 24;
      }
      while (v5 < *(int *)(a1 + 56));
    }
    v4[1] = consume_data;
    v4[3] = (uint64_t (*)(uint64_t))decompress_data;
    int v12 = (uint64_t (*)(uint64_t))(v4 + 17);
  }
  else
  {
    int v13 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 8))(a1, 1, 1280);
    uint64_t v14 = 0;
    int64x2_t v15 = (int64x2_t)xmmword_18898C840;
    int64x2_t v16 = vdupq_n_s64((unint64_t)v13);
    int64x2_t v17 = vdupq_n_s64(2uLL);
    do
    {
      *(int64x2_t *)&v4[v14 + 7] = vaddq_s64(v16, vshlq_n_s64(v15, 7uLL));
      int64x2_t v15 = vaddq_s64(v15, v17);
      v14 += 2;
    }
    while (v14 != 10);
    if (!*(_DWORD *)(a1 + 568)) {
      bzero(v13, 0x500uLL);
    }
    int v12 = 0;
    v4[1] = (uint64_t (*)(uint64_t))dummy_consume_data;
    v4[3] = (uint64_t (*)(uint64_t))decompress_onepass;
  }
  v4[4] = v12;
}

uint64_t start_input_pass(uint64_t result)
{
  *(_DWORD *)(result + 176) = 0;
  return start_iMCU_row(result);
}

uint64_t start_output_pass(uint64_t result)
{
  uint64_t v1 = result;
  unint64_t v2 = *(void **)(result + 592);
  if (v2[4])
  {
    if (*(_DWORD *)(result + 104) && *(_DWORD *)(result + 316) && *(void *)(result + 192))
    {
      uint64_t result = v2[27];
      if (!result)
      {
        uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(v1 + 8))(v1, 1, 24 * *(int *)(v1 + 56));
        v2[27] = result;
      }
      if (*(int *)(v1 + 56) >= 1)
      {
        uint64_t v3 = 0;
        uint64_t v4 = 0;
        int v5 = 0;
        uint64_t v6 = *(void *)(v1 + 304);
        while (1)
        {
          unsigned int v7 = *(_WORD **)(v6 + 80);
          if (!v7) {
            break;
          }
          if (!*v7) {
            break;
          }
          if (!v7[1]) {
            break;
          }
          if (!v7[8]) {
            break;
          }
          if (!v7[16]) {
            break;
          }
          if (!v7[9]) {
            break;
          }
          if (!v7[2]) {
            break;
          }
          uint64_t v8 = *(void *)(v1 + 192);
          if ((*(_DWORD *)(v8 + (v4 << 8)) & 0x80000000) != 0) {
            break;
          }
          uint64_t v9 = v8 + v3;
          for (uint64_t i = 4; i != 24; i += 4)
          {
            *(_DWORD *)(result + i) = *(_DWORD *)(v9 + i);
            if (*(_DWORD *)(v9 + i)) {
              int v5 = 1;
            }
          }
          result += 24;
          ++v4;
          v6 += 96;
          v3 += 256;
          if (v4 >= *(int *)(v1 + 56))
          {
            uint64_t v11 = decompress_smooth_data;
            if (v5) {
              goto LABEL_24;
            }
            break;
          }
        }
      }
    }
    uint64_t v11 = decompress_data;
LABEL_24:
    v2[3] = v11;
  }
  *(_DWORD *)(v1 + 184) = 0;
  return result;
}

uint64_t consume_data(uint64_t a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *(_DWORD **)(a1 + 592);
  memset(v21, 0, sizeof(v21));
  if (*(int *)(a1 + 448) >= 1)
  {
    uint64_t v3 = 0;
    do
    {
      *((void *)v21 + v3) = (*(uint64_t (**)(uint64_t, void, void, void, uint64_t))(*(void *)(a1 + 8)
                                                                                                  + 64))(a1, *(void *)&v2[2 * *(int *)(*(void *)(a1 + 8 * v3 + 456) + 4) + 34], (*(_DWORD *)(*(void *)(a1 + 8 * v3 + 456) + 12) * *(_DWORD *)(a1 + 176)), *(unsigned int *)(*(void *)(a1 + 8 * v3 + 456) + 12), 1);
      ++v3;
    }
    while (v3 < *(int *)(a1 + 448));
  }
  int v4 = v2[12];
  uint64_t v5 = (int)v2[11];
  if ((int)v5 >= v4)
  {
LABEL_20:
    unsigned int v20 = *(_DWORD *)(a1 + 176) + 1;
    *(_DWORD *)(a1 + 176) = v20;
    if (v20 >= *(_DWORD *)(a1 + 432))
    {
      (*(void (**)(uint64_t))(*(void *)(a1 + 608) + 24))(a1);
      return 4;
    }
    else
    {
      start_iMCU_row(a1);
      return 3;
    }
  }
  else
  {
    unsigned int v6 = v2[10];
    unsigned int v7 = *(_DWORD *)(a1 + 488);
    while (v6 >= v7)
    {
LABEL_19:
      unsigned int v6 = 0;
      v2[10] = 0;
      if (++v5 >= v4) {
        goto LABEL_20;
      }
    }
    while (1)
    {
      uint64_t v8 = *(unsigned int *)(a1 + 448);
      if ((int)v8 >= 1)
      {
        uint64_t v9 = 0;
        int v10 = 0;
        do
        {
          uint64_t v11 = *(void *)(a1 + 8 * v9 + 456);
          uint64_t v12 = *(unsigned int *)(v11 + 60);
          if ((int)v12 >= 1)
          {
            uint64_t v13 = 0;
            int v14 = *(_DWORD *)(v11 + 56);
            uint64_t v15 = *((void *)v21 + v9);
            do
            {
              if (v14 >= 1)
              {
                unint64_t v16 = *(void *)(v15 + 8 * (v13 + v5)) + ((unint64_t)(v14 * v6) << 7);
                int64x2_t v17 = (unint64_t *)&v2[2 * v10 + 14];
                v10 += v14;
                int v18 = v14;
                do
                {
                  *v17++ = v16;
                  v16 += 128;
                  --v18;
                }
                while (v18);
              }
              ++v13;
            }
            while (v13 != v12);
          }
          ++v9;
        }
        while (v9 != v8);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, _DWORD *))(*(void *)(a1 + 624) + 8))(a1, v2 + 14);
      if (!result) {
        break;
      }
      ++v6;
      unsigned int v7 = *(_DWORD *)(a1 + 488);
      if (v6 >= v7)
      {
        int v4 = v2[12];
        goto LABEL_19;
      }
    }
    v2[10] = v6;
    v2[11] = v5;
  }
  return result;
}

uint64_t decompress_data(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = *(void *)(a1 + 592);
  unsigned int v18 = *(_DWORD *)(a1 + 432) - 1;
  while (1)
  {
    int v3 = *(_DWORD *)(a1 + 172);
    int v4 = *(_DWORD *)(a1 + 180);
    if (v3 >= v4 && (v3 != v4 || *(_DWORD *)(a1 + 176) > *(_DWORD *)(a1 + 184))) {
      break;
    }
    uint64_t result = (**(uint64_t (***)(uint64_t))(a1 + 608))(a1);
    if (!result) {
      return result;
    }
  }
  if (*(int *)(a1 + 56) >= 1)
  {
    uint64_t v20 = 0;
    unsigned int v6 = *(_DWORD **)(a1 + 304);
    do
    {
      if (v6[13])
      {
        uint64_t v7 = (*(uint64_t (**)(uint64_t, void, void, void, void))(*(void *)(a1 + 8) + 64))(a1, *(void *)(v19 + 8 * v20 + 136), (v6[3] * *(_DWORD *)(a1 + 184)), v6[3], 0);
        if (*(_DWORD *)(a1 + 184) >= v18) {
          unint64_t v8 = v6[8] == (v6[8] / v6[3]) * (unint64_t)v6[3]
        }
             ? v6[3]
             : v6[8] - (v6[8] / v6[3]) * (unint64_t)v6[3];
        else {
          unint64_t v8 = v6[3];
        }
        if ((int)v8 >= 1)
        {
          uint64_t v9 = 0;
          int v10 = *(void (**)(uint64_t, _DWORD *, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 632) + 8 * v20 + 8);
          uint64_t v11 = *(void *)(a2 + 8 * v20);
          unsigned int v12 = v6[7];
          do
          {
            if (v12)
            {
              uint64_t v13 = 0;
              unsigned int v14 = 0;
              uint64_t v15 = *(void *)(v7 + 8 * v9);
              do
              {
                v10(a1, v6, v15, v11, v13);
                v15 += 128;
                uint64_t v13 = (v6[9] + v13);
                ++v14;
                unsigned int v12 = v6[7];
              }
              while (v14 < v12);
            }
            v11 += 8 * (int)v6[10];
            ++v9;
          }
          while (v9 != v8);
        }
      }
      v6 += 24;
      ++v20;
    }
    while (v20 < *(int *)(a1 + 56));
  }
  unsigned int v16 = *(_DWORD *)(a1 + 184) + 1;
  *(_DWORD *)(a1 + 184) = v16;
  if (v16 < *(_DWORD *)(a1 + 432)) {
    return 3;
  }
  else {
    return 4;
  }
}

uint64_t dummy_consume_data()
{
  return 0;
}

uint64_t decompress_onepass(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD **)(a1 + 592);
  unsigned int v4 = *(_DWORD *)(a1 + 432);
  int v5 = v3[12];
  int v34 = v3[11];
  if (v34 < v5)
  {
    unsigned int v32 = *(_DWORD *)(a1 + 488) - 1;
    unsigned int v37 = v4 - 1;
    unsigned int v6 = (void **)(v3 + 14);
    unsigned int v7 = v3[10];
    uint64_t v29 = *(_DWORD **)(a1 + 592);
    while (1)
    {
      if (v7 > v32) {
        goto LABEL_33;
      }
      do
      {
        if (*(_DWORD *)(a1 + 568)) {
          bzero(*v6, (uint64_t)*(int *)(a1 + 496) << 7);
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, void **))(*(void *)(a1 + 624) + 8))(a1, v6);
        if (!result)
        {
          v29[10] = v7;
          v29[11] = v34;
          return result;
        }
        int v9 = *(_DWORD *)(a1 + 448);
        if (v9 >= 1)
        {
          uint64_t v10 = 0;
          int v11 = 0;
          unsigned int v31 = v7;
          while (1)
          {
            unsigned int v12 = *(int **)(a1 + 8 * v10 + 456);
            if (v12[13]) {
              break;
            }
            v11 += v12[16];
LABEL_30:
            if (++v10 >= v9) {
              goto LABEL_31;
            }
          }
          int v13 = v12[15];
          if (v13 < 1) {
            goto LABEL_30;
          }
          uint64_t v33 = v10;
          int v14 = 0;
          uint64_t v15 = v12[1];
          unsigned int v16 = *(void (**)(uint64_t, int *, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 632) + 8 * v15 + 8);
          uint64_t v17 = 18;
          if (v7 < v32) {
            uint64_t v17 = 14;
          }
          int v18 = v12[v17];
          unsigned int v36 = v12[17] * v7;
          int v19 = v12[10];
          uint64_t v20 = *(void *)(a2 + 8 * v15) + 8 * v19 * v34;
          int v38 = v18;
          if (v18 <= 1) {
            uint64_t v21 = 1;
          }
          else {
            uint64_t v21 = v18;
          }
          uint64_t v35 = v21;
          while (2)
          {
            if (*(_DWORD *)(a1 + 176) >= v37)
            {
              if (v14 + v34 < v12[19] && v38 >= 1) {
                goto LABEL_24;
              }
            }
            else
            {
              if (v38 < 1) {
                goto LABEL_27;
              }
LABEL_24:
              uint64_t v23 = v6;
              __int16 v24 = &v6[v11];
              uint64_t v25 = v35;
              uint64_t v26 = v36;
              do
              {
                uint64_t v27 = (uint64_t)*v24++;
                v16(a1, v12, v27, v20, v26);
                uint64_t v26 = (v12[9] + v26);
                --v25;
              }
              while (v25);
              int v19 = v12[10];
              int v13 = v12[15];
              unsigned int v6 = v23;
            }
LABEL_27:
            v11 += v12[14];
            v20 += 8 * v19;
            if (++v14 >= v13)
            {
              int v9 = *(_DWORD *)(a1 + 448);
              unsigned int v7 = v31;
              uint64_t v10 = v33;
              goto LABEL_30;
            }
            continue;
          }
        }
LABEL_31:
        ++v7;
      }
      while (v7 <= v32);
      int v3 = v29;
      int v5 = v29[12];
LABEL_33:
      unsigned int v7 = 0;
      v3[10] = 0;
      if (++v34 >= v5)
      {
        unsigned int v4 = *(_DWORD *)(a1 + 432);
        break;
      }
    }
  }
  ++*(_DWORD *)(a1 + 184);
  unsigned int v28 = *(_DWORD *)(a1 + 176) + 1;
  *(_DWORD *)(a1 + 176) = v28;
  if (v28 >= v4)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 608) + 24))(a1);
    return 4;
  }
  else
  {
    start_iMCU_row(a1);
    return 3;
  }
}

uint64_t start_iMCU_row(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 592);
  if (*(int *)(result + 448) < 2)
  {
    uint64_t v3 = *(void *)(result + 456);
    if (*(_DWORD *)(result + 176) >= (*(_DWORD *)(result + 432) - 1)) {
      int v2 = *(_DWORD *)(v3 + 76);
    }
    else {
      int v2 = *(_DWORD *)(v3 + 12);
    }
  }
  else
  {
    int v2 = 1;
  }
  *(_DWORD *)(v1 + 48) = v2;
  *(void *)(v1 + 40) = 0;
  return result;
}

uint64_t decompress_smooth_data(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  uint64_t v70 = *(void *)(a1 + 592);
  unsigned int v76 = *(_DWORD *)(a1 + 432) - 1;
  long long v108 = 0u;
  long long v109 = 0u;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  long long __dst = 0u;
  long long v103 = 0u;
  while (1)
  {
    int v3 = *(_DWORD *)(v2 + 172);
    int v4 = *(_DWORD *)(v2 + 180);
    if (v3 > v4) {
      break;
    }
    uint64_t v5 = *(void *)(v2 + 608);
    if (*(_DWORD *)(v5 + 36)) {
      break;
    }
    if (v3 == v4)
    {
      unsigned int v6 = *(_DWORD *)(v2 + 184);
      if (!*(_DWORD *)(v2 + 540)) {
        ++v6;
      }
      if (*(_DWORD *)(v2 + 176) > v6) {
        break;
      }
    }
    uint64_t result = (*(uint64_t (**)(uint64_t))v5)(v2);
    if (!result) {
      return result;
    }
  }
  if (*(int *)(v2 + 56) >= 1)
  {
    uint64_t v71 = 0;
    uint64_t v8 = *(void *)(v2 + 304);
    uint64_t v89 = v2;
    while (!*(_DWORD *)(v8 + 52))
    {
LABEL_116:
      v8 += 96;
      if (++v71 >= *(int *)(v2 + 56)) {
        goto LABEL_117;
      }
    }
    unsigned int v9 = *(_DWORD *)(v2 + 184);
    if (v9 < v76)
    {
      unsigned int v10 = *(_DWORD *)(v8 + 12);
      uint64_t v13 = 2 * v10;
      LODWORD(v12) = v10;
      if (v9)
      {
LABEL_18:
        uint64_t v14 = (*(uint64_t (**)(uint64_t, void, void, void, void))(*(void *)(v2 + 8) + 64))(v2, *(void *)(v70 + 8 * v71 + 136), v10 * (v9 - 1), v10 + v13, 0)+ 8 * *(int *)(v8 + 12);
        goto LABEL_21;
      }
    }
    else
    {
      unsigned int v10 = *(_DWORD *)(v8 + 12);
      unsigned int v11 = *(_DWORD *)(v8 + 32) % v10;
      if (v11) {
        uint64_t v12 = v11;
      }
      else {
        uint64_t v12 = v10;
      }
      uint64_t v13 = v12;
      if (v9) {
        goto LABEL_18;
      }
    }
    uint64_t v14 = (*(uint64_t (**)(uint64_t, void, void, uint64_t, void))(*(void *)(v2 + 8) + 64))(v2, *(void *)(v70 + 8 * v71 + 136), 0, v13, 0);
LABEL_21:
    uint64_t v72 = (v12 - 1);
    if ((int)v12 >= 1)
    {
      uint64_t v15 = 0;
      uint64_t v93 = *(void (**)(uint64_t, uint64_t, long long *, uint64_t, uint64_t))(*(void *)(v2 + 632) + 8 * v71 + 8);
      uint64_t v95 = *(void *)(a2 + 8 * v71);
      unsigned int v16 = *(unsigned __int16 **)(v8 + 80);
      uint64_t v17 = v16[2];
      uint64_t v18 = v16[9];
      uint64_t v19 = v16[16];
      uint64_t v90 = (_DWORD *)(*(void *)(v70 + 216) + 4 * (6 * v71));
      uint64_t v20 = v16[8];
      int v21 = *v16;
      uint64_t v22 = v16[1];
      int v92 = 9 * v21;
      int v91 = 36 * v21;
      unint64_t v87 = v22 << 8;
      uint64_t v88 = v22 << 7;
      uint64_t v86 = v20 << 7;
      unint64_t v85 = v20 << 8;
      unint64_t v83 = v19 << 8;
      uint64_t v84 = v19 << 7;
      uint64_t v81 = v18 << 7;
      int v82 = 5 * v21;
      uint64_t v79 = v17 << 7;
      unint64_t v80 = v18 << 8;
      unint64_t v78 = v17 << 8;
      uint64_t v73 = v12;
      uint64_t v74 = v14;
      uint64_t v94 = v8;
      unsigned int v75 = v9;
      do
      {
        uint64_t v23 = *(__int16 **)(v14 + 8 * v15);
        __int16 v24 = v23;
        if (v9 | v15) {
          __int16 v24 = *(__int16 **)(v14 + 8 * v15 - 8);
        }
        if (v9 < v76 || (uint64_t v25 = *(__int16 **)(v14 + 8 * v15), v15 != v72)) {
          uint64_t v25 = *(__int16 **)(v14 + 8 * v15 + 8);
        }
        uint64_t v77 = v15;
        uint64_t v26 = 0;
        unsigned int v27 = 0;
        int v30 = *v24;
        unsigned int v28 = v24 + 64;
        int v29 = v30;
        int v33 = *v25;
        unsigned int v31 = v25 + 64;
        int v32 = v33;
        unsigned int v34 = *(_DWORD *)(v8 + 28) - 1;
        int v35 = v33;
        int v99 = *v23;
        int v101 = v99;
        int v98 = v29;
        int v100 = v29;
        do
        {
          int v97 = v100;
          int v100 = v98;
          int v36 = v101;
          int v101 = v99;
          int v96 = v35;
          int v35 = v32;
          _cg_jcopy_block_row(v23, &__dst, 1u);
          if (v27 < v34)
          {
            int v98 = *v28;
            int v99 = v23[64];
            int v32 = *v31;
          }
          int v37 = v90[1];
          if (v37) {
            BOOL v38 = WORD1(__dst) == 0;
          }
          else {
            BOOL v38 = 0;
          }
          if (v38)
          {
            uint64_t v39 = v91 * (uint64_t)(v36 - v99);
            unint64_t v40 = (v88 - v39) / v87;
            if (1 << v37 <= (int)v40) {
              int v41 = (1 << v37) - 1;
            }
            else {
              int v41 = (v88 - v39) / v87;
            }
            if (v37 > 0) {
              LODWORD(v40) = v41;
            }
            if (1 << v37 <= (int)((v39 + v88) / v87)) {
              int v42 = (1 << v37) - 1;
            }
            else {
              LOWORD(v42) = (v39 + v88) / v87;
            }
            if (v37 >= 1) {
              LOWORD(v43) = v42;
            }
            else {
              LOWORD(v43) = (v39 + v88) / v87;
            }
            if (v39 < 0) {
              int v43 = -(int)v40;
            }
            WORD1(__dst) = v43;
          }
          int v44 = v90[2];
          if (v44 && !(_WORD)v103)
          {
            uint64_t v45 = v91 * (uint64_t)(v100 - v35);
            unint64_t v46 = (v86 - v45) / v85;
            if (1 << v44 <= (int)v46) {
              int v47 = (1 << v44) - 1;
            }
            else {
              int v47 = (v86 - v45) / v85;
            }
            if (v44 > 0) {
              LODWORD(v46) = v47;
            }
            if (1 << v44 <= (int)((v45 + v86) / v85)) {
              int v48 = (1 << v44) - 1;
            }
            else {
              LOWORD(v48) = (v45 + v86) / v85;
            }
            if (v44 >= 1) {
              LOWORD(v49) = v48;
            }
            else {
              LOWORD(v49) = (v45 + v86) / v85;
            }
            if (v45 < 0) {
              int v49 = -(int)v46;
            }
            LOWORD(v103) = v49;
          }
          int v50 = v90[3];
          if (v50 && !(_WORD)v104)
          {
            uint64_t v51 = v92 * (uint64_t)(v100 - 2 * v101 + v35);
            unint64_t v52 = (v84 - v51) / v83;
            if (1 << v50 <= (int)v52) {
              int v53 = (1 << v50) - 1;
            }
            else {
              int v53 = (v84 - v51) / v83;
            }
            if (v50 > 0) {
              LODWORD(v52) = v53;
            }
            if (1 << v50 <= (int)((v51 + v84) / v83)) {
              int v54 = (1 << v50) - 1;
            }
            else {
              LOWORD(v54) = (v51 + v84) / v83;
            }
            if (v50 >= 1) {
              LOWORD(v55) = v54;
            }
            else {
              LOWORD(v55) = (v51 + v84) / v83;
            }
            if (v51 < 0) {
              int v55 = -(int)v52;
            }
            LOWORD(v104) = v55;
          }
          int v56 = v90[4];
          if (v56 && !WORD1(v103))
          {
            uint64_t v57 = v82 * (uint64_t)(v97 - (v96 + v98) + v32);
            unint64_t v58 = (v81 - v57) / v80;
            if (1 << v56 <= (int)v58) {
              int v59 = (1 << v56) - 1;
            }
            else {
              int v59 = (v81 - v57) / v80;
            }
            if (v56 > 0) {
              LODWORD(v58) = v59;
            }
            if (1 << v56 <= (int)((v57 + v81) / v80)) {
              int v60 = (1 << v56) - 1;
            }
            else {
              LOWORD(v60) = (v57 + v81) / v80;
            }
            if (v56 >= 1) {
              LOWORD(v61) = v60;
            }
            else {
              LOWORD(v61) = (v57 + v81) / v80;
            }
            if (v57 < 0) {
              int v61 = -(int)v58;
            }
            WORD1(v103) = v61;
          }
          int v62 = v90[5];
          if (v62 && !WORD2(__dst))
          {
            uint64_t v63 = v92 * (uint64_t)(v36 - 2 * v101 + v99);
            unint64_t v64 = (v79 - v63) / v78;
            if (1 << v62 <= (int)v64) {
              int v65 = (1 << v62) - 1;
            }
            else {
              int v65 = (v79 - v63) / v78;
            }
            if (v62 > 0) {
              LODWORD(v64) = v65;
            }
            if (1 << v62 <= (int)((v63 + v79) / v78)) {
              int v66 = (1 << v62) - 1;
            }
            else {
              LOWORD(v66) = (v63 + v79) / v78;
            }
            if (v62 >= 1) {
              LOWORD(v67) = v66;
            }
            else {
              LOWORD(v67) = (v63 + v79) / v78;
            }
            if (v63 < 0) {
              int v67 = -(int)v64;
            }
            WORD2(__dst) = v67;
          }
          uint64_t v2 = v89;
          v93(v89, v94, &__dst, v95, v26);
          v23 += 64;
          uint64_t v26 = (*(_DWORD *)(v94 + 36) + v26);
          ++v27;
          v31 += 64;
          v28 += 64;
        }
        while (v27 <= v34);
        uint64_t v8 = v94;
        v95 += 8 * *(int *)(v94 + 40);
        uint64_t v15 = v77 + 1;
        uint64_t v14 = v74;
        unsigned int v9 = v75;
      }
      while (v77 + 1 != v73);
    }
    goto LABEL_116;
  }
LABEL_117:
  unsigned int v68 = *(_DWORD *)(v2 + 184) + 1;
  *(_DWORD *)(v2 + 184) = v68;
  if (v68 < *(_DWORD *)(v2 + 432)) {
    return 3;
  }
  else {
    return 4;
  }
}

uint64_t kdu_kernels::clear(uint64_t this)
{
  uint64_t v1 = 0;
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)(this + 32) = _D0;
  *(_DWORD *)this = -1;
  *(_WORD *)(this + 4) = 0;
  *(unsigned char *)(this + 6) = 0;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  *(void *)(this + 8) = 0;
  *(_DWORD *)(this + 48) = 0;
  *(void *)(this + 40) = 0;
  *(void *)(this + 56) = 0;
  *(void *)(this + 64) = 0;
  *(_DWORD *)(this + 72) = 0;
  *(void *)(this + 80) = 0;
  *(void *)(this + 88) = 0;
  *(_DWORD *)(this + 96) = 0;
  *(_DWORD *)(this + 120) = 0;
  *(void *)(this + 104) = 0;
  *(void *)(this + 112) = 0;
  *(void *)(this + 128) = 0;
  *(void *)(this + 136) = 0;
  *(void *)(this + 144) = 0xFFFFFFFF00000004;
  *(void *)(this + 152) = 0;
  *(void *)(this + 160) = 0;
  do
  {
    uint64_t v7 = this + v1;
    *(_DWORD *)(v7 + 168) = -1;
    *(void *)(v7 + 176) = 0;
    *(_DWORD *)(v7 + 408) = -1;
    *(void *)(v7 + 416) = 0;
    v1 += 16;
  }
  while (v1 != 240);
  return this;
}

uint64_t kdu_kernels::reset(kdu_kernels *this)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C80451B5BE8);
  }
  uint64_t v3 = *((void *)this + 3);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C8052888210);
  }
  uint64_t v4 = *((void *)this + 7);
  if (v4) {
    MEMORY[0x18C11C0C0](v4 - 4 * *((int *)this + 10), 0x1000C8052888210);
  }
  uint64_t v5 = *((void *)this + 10);
  if (v5) {
    MEMORY[0x18C11C0C0](v5 - 4 * *((int *)this + 16), 0x1000C8052888210);
  }
  uint64_t v6 = *((void *)this + 13);
  if (v6) {
    MEMORY[0x18C11C0C0](v6 - 4 * *((int *)this + 22), 0x1000C8052888210);
  }
  uint64_t v7 = *((void *)this + 16);
  if (v7) {
    MEMORY[0x18C11C0C0](v7 - 4 * *((int *)this + 28), 0x1000C8052888210);
  }
  uint64_t v8 = *((void *)this + 19);
  if (v8) {
    MEMORY[0x18C11C0C0](v8 - 4 * *((int *)this + 37), 0x1000C8052888210);
  }
  uint64_t v9 = *((void *)this + 20);
  if (v9) {
    MEMORY[0x18C11C0C0](v9 - 4 * *((int *)this + 37), 0x1000C8052888210);
  }
  uint64_t v10 = *((void *)this + 17);
  if (v10) {
    MEMORY[0x18C11C0C0](v10, 0x1000C8000313F17);
  }

  return kdu_kernels::clear((uint64_t)this);
}

uint64_t kdu_kernels::enlarge_work_buffers(uint64_t this, int a2)
{
  if (*(_DWORD *)(this + 148) < a2) {
    operator new[]();
  }
  return this;
}

uint64_t kdu_kernels::expand_and_convolve(kdu_kernels *this, float **a2, int a3, float *a4, int a5, float **a6)
{
  uint64_t v12 = (a5 + 2 * a3);
  kdu_kernels::enlarge_work_buffers((uint64_t)this, a5 + 2 * a3);
  uint64_t v13 = (uint64_t)*a2;
  uint64_t v14 = (uint64_t)*a6;
  uint64_t v15 = *((void *)this + 19);
  if (v13 != v15 && v13 != *((void *)this + 20)) {
    kdu_kernels::expand_and_convolve();
  }
  if (v14 != v15 && v14 != *((void *)this + 20)) {
    kdu_kernels::expand_and_convolve();
  }
  if ((int)v12 > *((_DWORD *)this + 37)) {
    kdu_kernels::expand_and_convolve();
  }
  if ((v12 & 0x80000000) == 0) {
    bzero((void *)(v14 + 4 * -(int)v12), 4 * (v12 + a5 + 2 * a3) + 4);
  }
  if ((a3 & 0x80000000) == 0)
  {
    uint64_t v16 = -a3;
    if (a5 >= 0) {
      int v17 = a5;
    }
    else {
      int v17 = -a5;
    }
    int v18 = -2 * a3;
    int v19 = a5 + v17 + 1;
    do
    {
      if ((a5 & 0x80000000) == 0)
      {
        float v20 = *(float *)(v13 + 4 * v16);
        int v21 = v19;
        uint64_t v22 = &a4[-a5];
        uint64_t v23 = (float *)(v14 + 4 * -a5 + 4 * v18);
        do
        {
          float v24 = *v22++;
          float *v23 = *v23 + (float)(v20 * v24);
          ++v23;
          --v21;
        }
        while (v21);
      }
      ++v16;
      v18 += 2;
    }
    while (a3 + 1 != v16);
  }
  return v12;
}

void kdu_kernels::init(kdu_kernels *this, int a2, char a3)
{
  kdu_kernels::reset(this);
  *(_DWORD *)this = a2;
  *((unsigned char *)this + 4) = a3;
  *(_WORD *)((char *)this + 5) = 257;
  if (a2)
  {
    if (a2 == 1)
    {
      *((void *)this + 1) = 0x200000002;
      operator new[]();
    }
    uint64_t v7 = 0;
    memset(v6, 0, sizeof(v6));
    kdu_error::kdu_error((kdu_error *)v6, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)v6);
  }
  *((void *)this + 1) = 0x200000004;
  operator new[]();
}

void sub_1886757EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886757F8()
{
  _Unwind_Resume(v0);
}

void kdu_kernels::derive_taps_and_gains(kdu_kernels *this)
{
  uint64_t v1 = *MEMORY[0x1E4F143B8];
  operator new[]();
}

void kdu_kernels::init(uint64_t a1, int a2, uint64_t a3, uint64_t a4, char a5, char a6, char a7)
{
  *(_DWORD *)a1 = -1;
  *(unsigned char *)(a1 + 4) = a7;
  *(unsigned char *)(a1 + 5) = a5;
  *(unsigned char *)(a1 + 6) = a6;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = 0;
  operator new[]();
}

uint64_t kdu_kernels::get_impulse_response(_DWORD *a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  switch(a2)
  {
    case 0:
      if (a4) {
        *a4 = a1[11];
      }
      if (a5) {
        *a5 = a1[12];
      }
      *a3 = a1[10];
      uint64_t v5 = a1 + 14;
      break;
    case 1:
      if (a4) {
        *a4 = a1[17];
      }
      if (a5) {
        *a5 = a1[18];
      }
      *a3 = a1[16];
      uint64_t v5 = a1 + 20;
      break;
    case 2:
      if (a4) {
        *a4 = a1[23];
      }
      if (a5) {
        *a5 = a1[24];
      }
      *a3 = a1[22];
      uint64_t v5 = a1 + 26;
      break;
    case 3:
      if (a4) {
        *a4 = a1[29];
      }
      if (a5) {
        *a5 = a1[30];
      }
      *a3 = a1[28];
      uint64_t v5 = a1 + 32;
      break;
    default:
      kdu_kernels::get_impulse_response();
  }
  return *(void *)v5;
}

double kdu_kernels::get_energy_gain(kdu_kernels *this, int a2, int a3, BOOL *a4)
{
  if (a3 >= 4) {
    kdu_kernels::get_energy_gain();
  }
  int v5 = a2;
  int v7 = ~(-1 << a3);
  if (a3)
  {
    for (uint64_t i = 0; i != a3; ++i)
    {
      if (a4[i]) {
        int v9 = 1 << i;
      }
      else {
        int v9 = 0;
      }
      v7 += v9;
    }
  }
  uint64_t v10 = (char *)this + 168;
  int v11 = *((_DWORD *)this + 36);
  double v12 = 1.0;
  if (v11 < a2)
  {
    do
    {
      --v5;
      double v12 = v12 + v12;
    }
    while (v5 > v11);
    int v5 = *((_DWORD *)this + 36);
  }
  if (v7 <= 14 && *(_DWORD *)&v10[16 * v7] == v5)
  {
    double v13 = *(double *)&v10[16 * v7 + 8];
  }
  else
  {
    int v29 = (int *)&v10[16 * v7];
    uint64_t v30 = v7;
    unsigned int v31 = (char *)this + 168;
    uint64_t v14 = (float **)((char *)this + 152);
    uint64_t v15 = (float **)((char *)this + 160);
    **((_DWORD **)this + 19) = 1065353216;
    if (a3 < 1)
    {
      int v16 = 0;
    }
    else
    {
      int v16 = 0;
      unint64_t v17 = a3 + 1;
      int v18 = (float **)((char *)this + 152);
      do
      {
        uint64_t v14 = v15;
        if (a4[(v17 - 2)]) {
          uint64_t v19 = 128;
        }
        else {
          uint64_t v19 = 104;
        }
        if (a4[(v17 - 2)]) {
          uint64_t v20 = 112;
        }
        else {
          uint64_t v20 = 88;
        }
        int v16 = kdu_kernels::expand_and_convolve(this, v18, v16, *(float **)((char *)this + v19), *(_DWORD *)((char *)this + v20), v14);
        --v17;
        uint64_t v15 = v18;
        int v18 = v14;
      }
      while (v17 > 1);
    }
    if (v5 < 1)
    {
      uint64_t v22 = v14;
    }
    else
    {
      unsigned int v21 = v5 + 1;
      do
      {
        uint64_t v22 = v15;
        int v16 = kdu_kernels::expand_and_convolve(this, v14, v16, *((float **)this + 13), *((_DWORD *)this + 22), v15);
        --v21;
        uint64_t v15 = v14;
        uint64_t v14 = v22;
      }
      while (v21 > 1);
    }
    if (v16 > *((_DWORD *)this + 37)) {
      kdu_kernels::get_energy_gain();
    }
    if (v16 < 0)
    {
      double v13 = 0.0;
      uint64_t v26 = v30;
      uint64_t v25 = v31;
    }
    else
    {
      uint64_t v23 = &(*v22)[-v16];
      int v24 = (2 * v16) | 1;
      double v13 = 0.0;
      uint64_t v26 = v30;
      uint64_t v25 = v31;
      do
      {
        float v27 = *v23++;
        double v13 = v13 + v27 * v27;
        --v24;
      }
      while (v24);
    }
    if ((int)v26 <= 14 && *v29 < v5)
    {
      int *v29 = v5;
      *(double *)&v25[16 * v26 + 8] = v13;
    }
  }
  return v12 * v13;
}

double kdu_kernels::get_bibo_gain(kdu_kernels *this, int a2, int a3, BOOL *a4)
{
  if (a3 >= 4) {
    kdu_kernels::get_bibo_gain();
  }
  int v5 = ~(-1 << a3);
  if (a3)
  {
    for (uint64_t i = 0; i != a3; ++i)
    {
      if (a4[i]) {
        int v7 = 1 << i;
      }
      else {
        int v7 = 0;
      }
      v5 += v7;
    }
  }
  uint64_t v8 = (char *)this + 408;
  uint64_t v9 = v5;
  uint64_t v10 = (int *)((char *)this + 16 * v5 + 408);
  if (*((_DWORD *)this + 36) >= a2) {
    int v11 = a2;
  }
  else {
    int v11 = *((_DWORD *)this + 36);
  }
  if (v5 <= 14) {
    double v12 = (double *)((char *)this + 16 * v5 + 408);
  }
  else {
    double v12 = 0;
  }
  if (v5 <= 14 && *v10 == v11) {
    return *(double *)&v8[16 * v5 + 8];
  }
  double v19 = 0.0;
  double v20 = 0.0;
  int v14 = a3 - 1;
  if (a3 < 1)
  {
    if (v11 < 1)
    {
      return 1.0;
    }
    else
    {
      kdu_kernels::get_bibo_gains(this, v11 - 1, 0, 0, &v20, &v19);
      if (v9) {
        kdu_kernels::get_bibo_gain();
      }
      double result = v20;
      if (*(_DWORD *)v12 < v11)
      {
        *(_DWORD *)double v12 = v11;
        v12[1] = result;
      }
    }
  }
  else
  {
    kdu_kernels::get_bibo_gains(this, v11, a3 - 1, a4, &v20, &v19);
    if (a4[v14])
    {
      double result = v19;
      if ((int)v9 <= 14)
      {
        if (*v10 < v11)
        {
          int *v10 = v11;
          *(double *)&v8[16 * v9 + 8] = result;
        }
        uint64_t v15 = -(uint64_t)(1 << v14);
        int v16 = &v10[-4 * (1 << v14)];
        if (*v16 < v11)
        {
          int *v16 = v11;
          double v17 = v20;
LABEL_33:
          *(double *)&v10[4 * v15 + 2] = v17;
          return result;
        }
        if (*v16 == v11 && *(double *)&v10[-4 * (1 << v14) + 2] != v20) {
          kdu_kernels::get_bibo_gain();
        }
      }
    }
    else
    {
      double result = v20;
      if ((int)v9 <= 14)
      {
        if (*v10 < v11)
        {
          int *v10 = v11;
          *(double *)&v8[16 * v9 + 8] = result;
        }
        uint64_t v15 = 1 << v14;
        int v18 = &v10[4 * v15];
        if (*v18 < v11)
        {
          *int v18 = v11;
          double v17 = v19;
          goto LABEL_33;
        }
        if (*v18 == v11 && *(double *)&v10[4 * v15 + 2] != v19) {
          kdu_kernels::get_bibo_gain();
        }
      }
    }
  }
  return result;
}

uint64_t kdu_kernels::get_bibo_gains(kdu_kernels *this, int a2, int a3, BOOL *a4, double *a5, double *a6)
{
  if (*((_DWORD *)this + 36) >= a2) {
    int v10 = a2;
  }
  else {
    int v10 = *((_DWORD *)this + 36);
  }
  kdu_kernels::enlarge_work_buffers((uint64_t)this, 1);
  int v11 = (_DWORD *)*((void *)this + 19);
  uint64_t v12 = *((void *)this + 20);
  *int v11 = 1065353216;
  *a6 = 1.0;
  *a5 = 1.0;
  if (v10 + a3 >= 0)
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    uint64_t v17 = 0;
    int v91 = ~v10;
    uint64_t v93 = (v10 + a3 + 1);
    uint64_t v94 = v10;
    double v18 = 1.0;
    int v19 = 1;
    do
    {
      uint64_t v95 = v13;
      if (v13 > v94 && a4[(int)v13 + v91])
      {
        if ((int)v15 <= (int)v14)
        {
          double v20 = (int *)(v12 + 4 * (int)v15);
          unsigned int v21 = &v11[(int)v15];
          int v22 = v14 - v15 + 1;
          do
          {
            int v23 = *v20++;
            *v21++ = v23;
            --v22;
          }
          while (v22);
        }
        *a5 = *a6;
        uint64_t v17 = v15;
        uint64_t v16 = v14;
      }
      else
      {
        if ((int)v17 <= (int)v16)
        {
          int v24 = &v11[(int)v17];
          uint64_t v25 = (_DWORD *)(v12 + 4 * (int)v17);
          int v26 = v16 - v17 + 1;
          do
          {
            int v27 = *v24++;
            *v25++ = v27;
            --v26;
          }
          while (v26);
        }
        *a6 = v18;
      }
      if (((int)v16 + (int)v17 < 0) ^ __OFADD__(v16, v17) | (v16 + v17 == 0)) {
        int v28 = -(int)v17;
      }
      else {
        int v28 = v16;
      }
      int v29 = *((_DWORD *)this + 2);
      int v30 = v28 + *((_DWORD *)this + 3) * v19 * v29;
      if (v30 > *((_DWORD *)this + 37))
      {
        kdu_kernels::enlarge_work_buffers((uint64_t)this, v30);
        int v11 = (_DWORD *)*((void *)this + 19);
        uint64_t v12 = *((void *)this + 20);
        int v29 = *((_DWORD *)this + 2);
      }
      int v31 = 2 * v19;
      if (v29 < 1)
      {
        uint64_t v15 = v17;
        uint64_t v14 = v16;
      }
      else
      {
        uint64_t v32 = 0;
        uint64_t v14 = v16;
        uint64_t v15 = v17;
        do
        {
          if ((int)v17 <= (int)v16)
          {
            uint64_t v33 = *((void *)this + 3);
            unsigned int v34 = (int *)(*((void *)this + 2) + 16 * v32);
            int v36 = *v34;
            uint64_t v35 = v34[1];
            int v37 = (2 * v35 - 1) * v19;
            if (v37 + (int)v17 < (int)v15)
            {
              int v38 = *((_DWORD *)this + 37);
              uint64_t v39 = (int)v15;
              int v40 = 1 - v15;
              do
              {
                int v41 = v39 - 1;
                uint64_t v42 = v39 - 1;
                if (v39 < 1) {
                  int v41 = v40;
                }
                if (v41 > v38) {
                  goto LABEL_89;
                }
                *(_DWORD *)(v12 - 4 + 4 * v39) = 0;
                ++v40;
                --v39;
              }
              while (v42 > v37 + (int)v17);
              uint64_t v15 = v42;
            }
            int v43 = v35 + v36 - 1;
            int v44 = v16 + (2 * v43 - 1) * v19;
            if (v44 > (int)v14)
            {
              int v45 = *((_DWORD *)this + 37);
              uint64_t v46 = (int)v14;
              int v47 = ~v14;
              int v48 = v14 + 1;
              do
              {
                if (v46 >= -1) {
                  int v49 = v48;
                }
                else {
                  int v49 = v47;
                }
                if (v49 > v45) {
                  goto LABEL_89;
                }
                *(_DWORD *)(v12 + 4 + 4 * v46) = 0;
                --v47;
                ++v48;
                ++v46;
              }
              while (v44 != v46);
              uint64_t v14 = (v16 + (2 * v43 - 1) * v19);
            }
            if ((int)v35 <= v43)
            {
              int v50 = (float *)(v33 + 4 * v32);
              int v51 = v35 + v36;
              do
              {
                unint64_t v52 = (float *)(v12 + 4 * ((int)v17 + (uint64_t)v37));
                int v53 = v16 - v17 + 1;
                int v54 = (float *)&v11[(int)v17];
                do
                {
                  float v55 = *v54++;
                  float *v52 = *v52 + (float)(v55 * *v50);
                  ++v52;
                  --v53;
                }
                while (v53);
                ++v35;
                v50 += v29;
                v37 += v31;
              }
              while (v51 != v35);
            }
            *a6 = 0.0;
            double v56 = 0.0;
            if ((int)v15 <= (int)v14)
            {
              uint64_t v57 = (float *)(v12 + 4 * (int)v15);
              int v58 = ~v14 + v15;
              do
              {
                float v59 = *v57++;
                double v56 = v56 + fabsf(v59);
                BOOL v60 = __CFADD__(v58++, 1);
              }
              while (!v60);
              *a6 = v56;
            }
            *(double *)(*((void *)this + 17) + 8 * v32) = v56;
          }
          if ((int)v15 <= (int)v14)
          {
            uint64_t v61 = v32 | 1;
            if ((v32 | 1) < v29)
            {
              uint64_t v62 = *((void *)this + 3);
              uint64_t v63 = (int *)(*((void *)this + 2) + 16 * v61);
              int v65 = *v63;
              uint64_t v64 = v63[1];
              int v66 = ((2 * v64) | 1) * v19;
              if (v66 + (int)v15 < (int)v17)
              {
                uint64_t v67 = (int)v17;
                while (1)
                {
                  int v68 = (int)v67 >= 0 ? v67 : -(int)v67;
                  if (v68 >= v30) {
                    break;
                  }
                  uint64_t v17 = v67 - 1;
                  v11[v67 - 1] = 0;
                  uint64_t v67 = v17;
                  if (v17 <= v66 + (int)v15) {
                    goto LABEL_59;
                  }
                }
LABEL_89:
                exception = __cxa_allocate_exception(4uLL);
                _DWORD *exception = -1;
                __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
              }
LABEL_59:
              int v69 = v64 + v65 - 1;
              int v70 = v14 + ((2 * v69) | 1) * v19;
              if (v70 > (int)v16)
              {
                int v71 = *((_DWORD *)this + 37);
                if ((int)v16 > v71) {
                  int v71 = v16;
                }
                uint64_t v72 = v71 - (uint64_t)(int)v16;
                uint64_t v73 = (int)v16 - (uint64_t)v70;
                uint64_t v74 = &v11[(int)v16 + 1];
                do
                {
                  if (!v72) {
                    goto LABEL_89;
                  }
                  *v74++ = 0;
                  --v72;
                  BOOL v60 = __CFADD__(v73++, 1);
                }
                while (!v60);
                uint64_t v16 = v14 + ((2 * v69) | 1) * v19;
              }
              if ((int)v64 <= v69)
              {
                unsigned int v75 = (float *)(v62 + 4 * v61);
                int v76 = v64 + v65;
                do
                {
                  uint64_t v77 = (float *)&v11[(int)v15 + (uint64_t)v66];
                  int v78 = v14 - v15 + 1;
                  uint64_t v79 = (float *)(v12 + 4 * (int)v15);
                  do
                  {
                    float v80 = *v79++;
                    float *v77 = *v77 + (float)(v80 * *v75);
                    ++v77;
                    --v78;
                  }
                  while (v78);
                  ++v64;
                  v75 += v29;
                  v66 += v31;
                }
                while (v76 != v64);
              }
              *a5 = 0.0;
              double v81 = 0.0;
              if ((int)v17 <= (int)v16)
              {
                int v82 = (float *)&v11[(int)v17];
                int v83 = ~v16 + v17;
                do
                {
                  float v84 = *v82++;
                  double v81 = v81 + fabsf(v84);
                  BOOL v60 = __CFADD__(v83++, 1);
                }
                while (!v60);
                *a5 = v81;
              }
              *(double *)(*((void *)this + 17) + 8 * v61) = v81;
            }
          }
          v32 += 2;
        }
        while (v29 > (int)v32);
      }
      if ((int)v15 <= (int)v14)
      {
        unint64_t v85 = (float *)(v12 + 4 * (int)v15);
        int v86 = v14 - v15 + 1;
        do
        {
          float *v85 = *((float *)this + 9) * *v85;
          ++v85;
          --v86;
        }
        while (v86);
      }
      *a6 = *a6 * *((float *)this + 9);
      if ((int)v17 <= (int)v16)
      {
        unint64_t v87 = (float *)&v11[(int)v17];
        int v88 = v16 - v17 + 1;
        do
        {
          *unint64_t v87 = *((float *)this + 8) * *v87;
          ++v87;
          --v88;
        }
        while (v88);
      }
      double v18 = *a5 * *((float *)this + 8);
      *a5 = v18;
      uint64_t v13 = v95 + 1;
      v19 *= 2;
    }
    while (v95 + 1 != v93);
  }
  return *((void *)this + 17);
}

uint64_t _cg_jpeg_fdct_float(uint64_t result, uint64_t a2, unsigned int a3)
{
  for (uint64_t i = 0; i != 64; i += 8)
  {
    uint64_t v4 = (unsigned __int8 *)(*(void *)(a2 + i) + a3);
    int v5 = *v4;
    int v6 = v4[7];
    float v7 = (float)(v6 + v5);
    int v8 = v5 - v6;
    int v9 = v4[1];
    int v10 = v4[6];
    float v11 = (float)v8;
    float v12 = (float)(v10 + v9);
    float v13 = (float)(v9 - v10);
    int v14 = v4[2];
    int v15 = v4[5];
    float v16 = (float)(v15 + v14);
    int v17 = v14 - v15;
    int v18 = v4[3];
    LODWORD(v4) = v4[4];
    int v19 = v4 + v18;
    float v20 = (float)(v18 - (int)v4);
    unsigned int v21 = (float *)(result + 4 * i);
    float v22 = v7 + (float)v19;
    float v23 = v7 - (float)v19;
    float v24 = v12 + v16;
    float v25 = v12 - v16;
    float v26 = (float)(v24 + v22) + -1024.0;
    float v27 = v22 - v24;
    float v28 = (float)(v25 + v23) * 0.70711;
    float v29 = v23 + v28;
    float v30 = v23 - v28;
    float v31 = (float)v17 + v20;
    float v32 = v13 + (float)v17;
    float v33 = v11 + v13;
    float v34 = (float)(v31 - v33) * 0.38268;
    float v35 = v34 + (float)(v31 * 0.5412);
    float v36 = v34 + (float)(v33 * 1.3066);
    float v37 = v32 * 0.70711;
    float v38 = v37 + v11;
    float v39 = v11 - v37;
    *unsigned int v21 = v26;
    v21[1] = v38 + v36;
    v21[4] = v27;
    v21[5] = v39 + v35;
    _OWORD v21[2] = v29;
    v21[3] = v39 - v35;
    v21[6] = v30;
    v21[7] = v38 - v36;
  }
  uint64_t v40 = result + 224;
  uint64_t v41 = -32;
  float32x4_t v42 = (float32x4_t)vdupq_n_s32(0x3F3504F3u);
  float32x4_t v43 = (float32x4_t)vdupq_n_s32(0x3EC3EF15u);
  float32x4_t v44 = (float32x4_t)vdupq_n_s32(0x3F0A8BD4u);
  float32x4_t v45 = (float32x4_t)vdupq_n_s32(0x3FA73D75u);
  do
  {
    uint64_t v46 = (float32x4_t *)(v40 + v41);
    float32x4_t v47 = *(float32x4_t *)(v40 + v41 - 192);
    float32x4_t v48 = *(float32x4_t *)(v40 + v41 + 32);
    float32x4_t v49 = vaddq_f32(v47, v48);
    float32x4_t v50 = vsubq_f32(v47, v48);
    float32x4_t v51 = *(float32x4_t *)(v40 + v41 - 160);
    float32x4_t v52 = *(float32x4_t *)(v40 + v41);
    float32x4_t v53 = vaddq_f32(v51, v52);
    float32x4_t v54 = vsubq_f32(v51, v52);
    float32x4_t v55 = *(float32x4_t *)(v40 + v41 - 128);
    float32x4_t v56 = *(float32x4_t *)(v40 + v41 - 32);
    float32x4_t v57 = vaddq_f32(v55, v56);
    float32x4_t v58 = vsubq_f32(v55, v56);
    float32x4_t v59 = *(float32x4_t *)(v40 + v41 - 96);
    float32x4_t v60 = *(float32x4_t *)(v40 + v41 - 64);
    float32x4_t v61 = vaddq_f32(v59, v60);
    float32x4_t v62 = vsubq_f32(v59, v60);
    float32x4_t v63 = vaddq_f32(v49, v61);
    float32x4_t v64 = vsubq_f32(v49, v61);
    float32x4_t v65 = vaddq_f32(v53, v57);
    v46[-12] = vaddq_f32(v65, v63);
    v46[-4] = vsubq_f32(v63, v65);
    float32x4_t v66 = vmulq_f32(vaddq_f32(vsubq_f32(v53, v57), v64), v42);
    v46[-8] = vaddq_f32(v64, v66);
    float32x4_t *v46 = vsubq_f32(v64, v66);
    float32x4_t v67 = vaddq_f32(v58, v62);
    float32x4_t v68 = vaddq_f32(v54, v58);
    float32x4_t v69 = vaddq_f32(v50, v54);
    float32x4_t v70 = vmulq_f32(vsubq_f32(v67, v69), v43);
    float32x4_t v71 = vmlaq_f32(v70, v44, v67);
    float32x4_t v72 = vmlaq_f32(v70, v45, v69);
    float32x4_t v73 = vmulq_f32(v68, v42);
    float32x4_t v74 = vaddq_f32(v50, v73);
    float32x4_t v75 = vsubq_f32(v50, v73);
    v46[-2] = vaddq_f32(v75, v71);
    v46[-6] = vsubq_f32(v75, v71);
    v46[-10] = vaddq_f32(v74, v72);
    uint64_t v46[2] = vsubq_f32(v74, v72);
    v41 += 16;
  }
  while (v41);
  return result;
}

uint64_t jp2_family_src::open(jp2_family_src *this, kdu_compressed_source *a2)
{
  if (*((_OWORD *)this + 1) != 0 || *((void *)this + 4))
  {
    uint64_t v7 = 0;
    long long v5 = 0u;
    long long v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  if (*((void *)this + 1)) {
    jp2_family_src::open();
  }
  ++*((_DWORD *)this + 18);
  uint64_t result = (*(uint64_t (**)(kdu_compressed_source *))(*(void *)a2 + 24))(a2);
  if ((result & 1) == 0)
  {
    uint64_t v7 = 0;
    long long v5 = 0u;
    long long v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  *((void *)this + 3) = a2;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = -1;
  *((void *)this + 7) = -1;
  *((_DWORD *)this + 16) = -1;
  *((unsigned char *)this + 68) = (result & 2) != 0;
  return result;
}

void sub_188676E3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188676E48()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_family_src::close(jp2_family_src *this)
{
  uint64_t v2 = (FILE *)*((void *)this + 2);
  if (v2) {
    fclose(v2);
  }
  *((void *)this + 2) = 0;
  uint64_t result = *((void *)this + 1);
  if (result) {
    uint64_t result = MEMORY[0x18C11C0C0](result, 0x1000C8077774924);
  }
  *((void *)this + 1) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = -1;
  *((void *)this + 6) = -1;
  *((void *)this + 7) = -1;
  *((_DWORD *)this + 16) = -1;
  return result;
}

void jp2_input_box::jp2_input_box(jp2_input_box *this)
{
  *(void *)this = &unk_1ED4E0DA8;
  *(_OWORD *)((char *)this + 8) = xmmword_18898D150;
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((_DWORD *)this + 12) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = -1;
  *((void *)this + 13) = -1;
  *((void *)this + 14) = -1;
  *((_DWORD *)this + 30) = -1;
  *(_DWORD *)((char *)this + 125) = 0;
  *((_DWORD *)this + 32) = 0;
  *(_OWORD *)((char *)this + 136) = xmmword_18898D150;
  *((_DWORD *)this + 44) = 0;
}

void jp2_input_box::~jp2_input_box(jp2_input_box *this)
{
  *(void *)this = &unk_1ED4E0DA8;
  jp2_input_box::close(this);
  *(void *)this = &unk_1ED4E53B8;
}

{
  uint64_t vars8;

  jp2_input_box::~jp2_input_box(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t jp2_input_box::read_box_header(jp2_input_box *this, int a2)
{
  uint64_t v4 = -1;
  *((void *)this + 13) = -1;
  long long v5 = (unint64_t *)((char *)this + 104);
  *((_DWORD *)this + 12) = 0;
  *(_WORD *)((char *)this + 125) = 0;
  *((void *)this + 9) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 18) = -1;
  *((void *)this + 14) = -1;
  uint64_t v6 = *((void *)this + 1);
  *((unsigned char *)this + 124) = v6 >= 0;
  if (*(void *)(*((void *)this + 5) + 32))
  {
    uint64_t v6 = *((int *)this + 6);
    uint64_t v4 = *((void *)this + 2);
    int v7 = 4;
  }
  else
  {
    int v7 = -1;
  }
  *((void *)this + 17) = v6;
  *((void *)this + 12) = v4;
  *((_DWORD *)this + 30) = v7;
  *((unsigned char *)this + 126) = 1;
  *((void *)this + 10) = v6;
  *((void *)this + 11) = 0x7FFFFFFFFFFFFFFFLL;
  uint64_t v8 = *((void *)this + 4);
  if (v8 && !*(unsigned char *)(v8 + 125)) {
    *((void *)this + 11) = *(void *)(v8 + 88);
  }
  *((_DWORD *)this + 44) = 0;
  int v9 = (unsigned __int8 *)this + 152;
  if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(void *)this + 32))(this, (char *)this + 152, 8) < 8) {
    goto LABEL_8;
  }
  uint64_t v11 = 0;
  unsigned int v12 = 5;
  uint64_t v13 = 152;
  do
  {
    uint64_t v11 = *((unsigned __int8 *)this + v13) | (unint64_t)(v11 << 8);
    --v12;
    ++v13;
  }
  while (v12 > 1);
  int v14 = 0;
  *((void *)this + 7) = v11;
  unsigned int v15 = 5;
  uint64_t v16 = 156;
  do
  {
    int v14 = *((unsigned __int8 *)this + v16) | (v14 << 8);
    --v15;
    ++v16;
  }
  while (v15 > 1);
  *((_DWORD *)this + 12) = v14;
  if (v14 == 1885891684)
  {
    *((void *)this + 11) = 0x7FFFFFFFFFFFFFFFLL;
    uint64_t v17 = *((void *)this + 4);
    if (v17) {
      *(void *)(v17 + 88) = 0x7FFFFFFFFFFFFFFFLL;
    }
    if (v11 < 28)
    {
      *((_DWORD *)this + 12) = 0;
      *(_WORD *)((char *)this + 125) = 0;
      *((void *)this + 9) = 0;
      *((void *)this + 7) = 0;
      *((void *)this + 18) = -1;
      unint64_t *v5 = -1;
      v5[1] = -1;
      uint64_t v62 = 0;
      long long v60 = 0u;
      long long v61 = 0u;
      kdu_error::kdu_error((kdu_error *)&v60, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v60 + 16))(&v60, "Illegal placeholder box encountered.  Placeholders must not use the extended length field and must have a length of at least 28 bytes!");
      kdu_error::~kdu_error((kdu_error *)&v60);
    }
    uint64_t v18 = 8;
    *((void *)this + 8) = 8;
  }
  else
  {
    uint64_t v18 = 8;
    *((void *)this + 8) = 8;
    if (v11 == 1)
    {
      *((void *)this + 8) = 16;
      if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(void *)this + 32))(this, (char *)this + 152, 8) < 8)goto LABEL_8; {
      uint64_t v11 = 0;
      }
      unsigned int v19 = 9;
      float v20 = (unsigned __int8 *)this + 152;
      do
      {
        unsigned int v21 = *v20++;
        uint64_t v11 = v21 | (unint64_t)(v11 << 8);
        --v19;
      }
      while (v19 > 1);
      *((void *)this + 7) = v11;
      uint64_t v18 = *((void *)this + 8);
    }
  }
  *((unsigned char *)this + 125) = v11 == 0;
  uint64_t v22 = v11 - v18;
  if (v11 && v22 < 0)
  {
    *((_DWORD *)this + 12) = 0;
    *(_WORD *)((char *)this + 125) = 0;
    *((void *)this + 9) = 0;
    *((void *)this + 7) = 0;
    *((void *)this + 18) = -1;
    unint64_t *v5 = -1;
    v5[1] = -1;
    uint64_t v62 = 0;
    long long v60 = 0u;
    long long v61 = 0u;
    kdu_error::kdu_error((kdu_error *)&v60, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v60 + 16))(&v60, "Illegal box length field encountered in JP2 file.");
    kdu_error::~kdu_error((kdu_error *)&v60);
  }
  *((void *)this + 9) = v11;
  if (v11 || *((_DWORD *)this + 12))
  {
    if (v14 != 1885891684)
    {
      uint64_t v51 = *((void *)this + 17);
      uint64_t v52 = v51 + v22;
      if (v22 < 0) {
        uint64_t v52 = 0x7FFFFFFFFFFFFFFFLL;
      }
      *((void *)this + 10) = v51;
      *((void *)this + 11) = v52;
      return 1;
    }
    if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(void *)this + 32))(this, (char *)this + 152, 20) >= 20)
    {
      unint64_t v23 = 0;
      int v24 = *((unsigned __int8 *)this + 155);
      unsigned int v25 = 9;
      uint64_t v26 = 156;
      do
      {
        unint64_t v23 = *((unsigned __int8 *)this + v26) | (v23 << 8);
        --v25;
        ++v26;
      }
      while (v25 > 1);
      unint64_t v27 = 0;
      unsigned int v28 = 5;
      uint64_t v29 = 164;
      do
      {
        unint64_t v27 = *((unsigned __int8 *)this + v29) | (v27 << 8);
        --v28;
        ++v29;
      }
      while (v28 > 1);
      int v30 = 0;
      *((void *)this + 7) = v27;
      unsigned int v31 = 5;
      uint64_t v32 = 168;
      do
      {
        int v30 = *((unsigned __int8 *)this + v32) | (v30 << 8);
        --v31;
        ++v32;
      }
      while (v31 > 1);
      *((_DWORD *)this + 12) = v30;
      uint64_t v33 = 8;
      *((void *)this + 8) = 8;
      if (v27 == 1)
      {
        *((void *)this + 8) = 16;
        if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(void *)this + 32))(this, (char *)this + 152, 8) < 8)goto LABEL_8; {
        unint64_t v27 = 0;
        }
        unsigned int v34 = 9;
        float v35 = (unsigned __int8 *)this + 152;
        do
        {
          unsigned int v36 = *v35++;
          unint64_t v27 = v36 | (v27 << 8);
          --v34;
        }
        while (v34 > 1);
        *((void *)this + 7) = v27;
        uint64_t v33 = *((void *)this + 8);
      }
      *((unsigned char *)this + 125) = v27 == 0;
      uint64_t v37 = v27 - v33;
      if (v27 && v37 < 0)
      {
        *((_DWORD *)this + 12) = 0;
        *(_WORD *)((char *)this + 125) = 0;
        *((void *)this + 9) = 0;
        *((void *)this + 7) = 0;
        *((void *)this + 18) = -1;
        unint64_t *v5 = -1;
        v5[1] = -1;
        uint64_t v62 = 0;
        long long v60 = 0u;
        long long v61 = 0u;
        kdu_error::kdu_error((kdu_error *)&v60, "Error in Kakadu File Format Support:\n");
        (*(void (**)(long long *, const char *))(v60 + 16))(&v60, "Illegal box length field encountered in JP2 file.");
        kdu_error::~kdu_error((kdu_error *)&v60);
      }
      if ((a2 & v24 & 1) != 0 || (v24 & 6) == 0)
      {
        *((void *)this + 12) = v23;
        *((void *)this + 17) = 0;
        *((void *)this + 10) = 0;
        if ((v24 & 1) == 0)
        {
          *((_DWORD *)this + 12) = 0;
          *((void *)this + 11) = 0;
          return 1;
        }
        uint64_t v53 = 0x7FFFFFFFFFFFFFFFLL;
        if (v37 >= 0) {
          uint64_t v53 = v37;
        }
LABEL_80:
        *((void *)this + 11) = v53;
        return 1;
      }
      *((unsigned char *)this + 124) = 0;
      if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(void *)this + 32))(this, (char *)this + 152, 16) >= 16)
      {
        unint64_t v38 = 0;
        unsigned int v39 = 9;
        uint64_t v40 = 152;
        do
        {
          unint64_t v38 = *((unsigned __int8 *)this + v40) | (v38 << 8);
          --v39;
          ++v40;
        }
        while (v39 > 1);
        unint64_t v41 = 0;
        unsigned int v42 = 5;
        uint64_t v43 = 160;
        do
        {
          unint64_t v41 = *((unsigned __int8 *)this + v43) | (v41 << 8);
          --v42;
          ++v43;
        }
        while (v42 > 1);
        int v44 = 0;
        unsigned int v45 = 5;
        uint64_t v46 = 164;
        do
        {
          int v44 = *((unsigned __int8 *)this + v46) | (v44 << 8);
          --v45;
          ++v46;
        }
        while (v45 > 1);
        *((_DWORD *)this + 12) = v44;
        if (v41 == 1)
        {
          if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(void *)this + 32))(this, (char *)this + 152, 8) < 8)goto LABEL_8; {
          unint64_t v41 = 0;
          }
          unsigned int v47 = 9;
          float32x4_t v48 = (unsigned __int8 *)this + 152;
          do
          {
            unsigned int v49 = *v48++;
            unint64_t v41 = v49 | (v41 << 8);
            --v47;
          }
          while (v47 > 1);
          unint64_t v50 = v41 - 16;
        }
        else
        {
          unint64_t v50 = v41 - 8;
        }
        if ((v24 & 2) != 0)
        {
          if (v41 && (v50 & 0x8000000000000000) != 0)
          {
            *((_DWORD *)this + 12) = 0;
            *(_WORD *)((char *)this + 125) = 0;
            *((void *)this + 9) = 0;
            *((void *)this + 7) = 0;
            *((void *)this + 18) = -1;
            unint64_t *v5 = -1;
            v5[1] = -1;
            uint64_t v62 = 0;
            long long v60 = 0u;
            long long v61 = 0u;
            kdu_error::kdu_error((kdu_error *)&v60, "Error in Kakadu File Format Support:\n");
            (*(void (**)(long long *, const char *))(v60 + 16))(&v60, "Illegal box length field encountered in stream equivalent box header embedded within a JP2 placeholder box.");
            kdu_error::~kdu_error((kdu_error *)&v60);
          }
        }
        else
        {
          *((_DWORD *)this + 12) = 0;
        }
        if ((v24 & 4) == 0)
        {
          *((void *)this + 12) = v38;
          *((void *)this + 17) = 0;
          uint64_t v53 = 0x7FFFFFFFFFFFFFFFLL;
          if (v50 < 0x7FFFFFFFFFFFFFFFLL) {
            uint64_t v53 = v50;
          }
          *((void *)this + 10) = 0;
          goto LABEL_80;
        }
        if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(void *)this + 32))(this, (char *)this + 152, 8) >= 8)
        {
          unint64_t v54 = 0;
          unsigned int v55 = 9;
          uint64_t v56 = 152;
          do
          {
            unint64_t v54 = *((unsigned __int8 *)this + v56) | (v54 << 8);
            --v55;
            ++v56;
          }
          while (v55 > 1);
          *((void *)this + 13) = v54;
          *((void *)this + 14) = v54 + 1;
          if ((v24 & 8) == 0) {
            goto LABEL_89;
          }
          if ((*(int (**)(jp2_input_box *, char *, uint64_t))(*(void *)this + 32))(this, (char *)this + 152, 4) > 3)
          {
            unsigned int v57 = 0;
            unint64_t v54 = *v5;
            for (unsigned int i = 5; i > 1; --i)
            {
              int v59 = *v9++;
              unsigned int v57 = v59 | (v57 << 8);
            }
            *((void *)this + 14) = v54 + v57;
LABEL_89:
            *((_DWORD *)this + 12) = 1785737827;
            *((_DWORD *)this + 30) = 3;
            *((void *)this + 12) = 0;
            *((void *)this + 17) = 0;
            *((void *)this + 18) = v54;
            *((_OWORD *)this + 5) = xmmword_18898D160;
            return 1;
          }
        }
      }
    }
LABEL_8:
    uint64_t result = 0;
    *((_DWORD *)this + 12) = 0;
    *(_WORD *)((char *)this + 125) = 0;
    *((void *)this + 9) = 0;
    *((void *)this + 7) = 0;
    *((void *)this + 18) = -1;
    unint64_t *v5 = -1;
    v5[1] = -1;
    return result;
  }
  return 0;
}

void sub_188677800(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867780C()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_input_box::open(jp2_input_box *this, uint64_t a2, long long *a3)
{
  if (*((unsigned char *)this + 126))
  {
    uint64_t v17 = 0;
    long long v15 = 0u;
    long long v16 = 0u;
    kdu_error::kdu_error((kdu_error *)&v15, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v15);
  }
  *((unsigned char *)this + 127) = 0;
  long long v5 = *a3;
  *((_DWORD *)this + 6) = *((_DWORD *)a3 + 4);
  *(_OWORD *)((char *)this + 8) = v5;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = a2;
  if (!*(void *)(a2 + 32) || (*((void *)this + 2) & 0x8000000000000000) == 0) {
    goto LABEL_5;
  }
  uint64_t v10 = *((void *)this + 1);
  if (v10 < 0) {
    jp2_input_box::open();
  }
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((_DWORD *)this + 6) = 0;
  if (v10)
  {
    while (1)
    {
      uint64_t result = jp2_input_box::read_box_header(this, 1);
      if (!result) {
        break;
      }
      *((unsigned char *)this + 126) = 0;
      uint64_t v11 = *((void *)this + 1);
      uint64_t v12 = *((void *)this + 7);
      uint64_t v13 = v12 + v11;
      if (v10 >= v12 + v11)
      {
        if (v12 <= 0)
        {
          uint64_t v17 = 0;
          long long v15 = 0u;
          long long v16 = 0u;
          kdu_error::kdu_error((kdu_error *)&v15, "Error in Kakadu File Format Support:\n");
          kdu_error::~kdu_error((kdu_error *)&v15);
        }
        *((void *)this + 1) = v13;
        *((_DWORD *)this + 6) += *((_DWORD *)this + 18);
      }
      else
      {
        uint64_t v13 = *((void *)this + 8) + v11;
        if (v10 < v13)
        {
          uint64_t v17 = 0;
          long long v15 = 0u;
          long long v16 = 0u;
          kdu_error::kdu_error((kdu_error *)&v15, "Error in Kakadu File Format Support:\n");
          kdu_error::~kdu_error((kdu_error *)&v15);
        }
        uint64_t v14 = *((void *)this + 12);
        *((void *)this + 1) = v13;
        *((void *)this + 2) = v14;
        *((_DWORD *)this + 6) = *((void *)this + 10);
        if (!*((_DWORD *)this + 12) || !*((unsigned char *)this + 124))
        {
          uint64_t v17 = 0;
          long long v15 = 0u;
          long long v16 = 0u;
          kdu_error::kdu_error((kdu_error *)&v15, "Error in Kakadu File Format Support:\n");
          kdu_error::~kdu_error((kdu_error *)&v15);
        }
      }
      if (v13 == v10) {
        goto LABEL_5;
      }
    }
  }
  else
  {
LABEL_5:
    int box_header = jp2_input_box::read_box_header(this, 0);
    uint64_t result = 0;
    if (box_header)
    {
      if (!*((_DWORD *)this + 12))
      {
        *((unsigned char *)this + 126) = 0;
        uint64_t v17 = 0;
        long long v15 = 0u;
        long long v16 = 0u;
        kdu_error::kdu_error((kdu_error *)&v15, "Error in Kakadu File Format Support:\n");
        kdu_error::~kdu_error((kdu_error *)&v15);
      }
      if (*(void *)(a2 + 32) && *((_DWORD *)this + 12) == 1785737827)
      {
        int v8 = 6;
        int v9 = 4;
      }
      else
      {
        int v8 = 3;
        int v9 = 1;
      }
      *((_DWORD *)this + 32) = v9;
      if (*(unsigned char *)(a2 + 68)) {
        *((_DWORD *)this + 32) = v8;
      }
      return 1;
    }
  }
  return result;
}

void sub_188677B94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188677BA0()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_input_box::open(jp2_input_box *this, jp2_input_box *a2)
{
  if (*((unsigned char *)this + 126))
  {
    uint64_t v13 = 0;
    long long v11 = 0u;
    long long v12 = 0u;
    kdu_error::kdu_error((kdu_error *)&v11, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v11);
  }
  if (*((unsigned char *)a2 + 127) || !*((unsigned char *)a2 + 126))
  {
    uint64_t v13 = 0;
    long long v11 = 0u;
    long long v12 = 0u;
    kdu_error::kdu_error((kdu_error *)&v11, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v11 + 16))(&v11, "Attempting to open a sub-box of a box which is not itself open, or which has already been locked by another open sub-box which has not yet been closed.");
    kdu_error::~kdu_error((kdu_error *)&v11);
  }
  *((void *)this + 4) = a2;
  *((void *)this + 5) = *((void *)a2 + 5);
  if (*((unsigned char *)a2 + 124)) {
    uint64_t v4 = *((void *)a2 + 8) + *((void *)a2 + 1) + *((void *)a2 + 17) - *((void *)a2 + 10);
  }
  else {
    uint64_t v4 = -1;
  }
  *((void *)this + 1) = v4;
  while (1)
  {
    if (*(void *)(*((void *)this + 5) + 32))
    {
      if (*((_DWORD *)a2 + 30) != 4)
      {
        uint64_t v13 = 0;
        long long v11 = 0u;
        long long v12 = 0u;
        kdu_error::kdu_error((kdu_error *)&v11, "Error in Kakadu File Format Support:\n");
        (*(void (**)(long long *, const char *))(v11 + 16))(&v11, "Attempting to open a sub-box of a contiguous codestream box (may be a stream equivalent contiguous codestream for a real original box, which might have had sub-boxes), but you should have checked.");
        kdu_error::~kdu_error((kdu_error *)&v11);
      }
      *((void *)this + 2) = *((void *)a2 + 12);
      int v5 = *((_DWORD *)a2 + 34);
    }
    else
    {
      *((void *)this + 2) = -1;
      int v5 = -1;
    }
    *((_DWORD *)this + 6) = v5;
    uint64_t box_header = jp2_input_box::read_box_header(this, 0);
    if (!box_header) {
      break;
    }
    if (!*((_DWORD *)this + 12))
    {
      (*(void (**)(jp2_input_box *))(*(void *)this + 16))(this);
      if (v4 != *((void *)this + 1) && !*((_DWORD *)this + 12)) {
        continue;
      }
    }
    uint64_t v7 = *((void *)this + 5);
    if (*(void *)(v7 + 32) && *((_DWORD *)this + 12) == 1785737827)
    {
      int v8 = 6;
      int v9 = 4;
    }
    else
    {
      int v8 = 3;
      int v9 = 1;
    }
    *((_DWORD *)this + 32) = v9;
    if (*(unsigned char *)(v7 + 68)) {
      *((_DWORD *)this + 32) = v8;
    }
    *((unsigned char *)a2 + 127) = 1;
    return box_header;
  }
  return box_header;
}

void sub_188677E78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188677E84()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_input_box::open_next(jp2_input_box *this)
{
  if (!*((void *)this + 5) || *((unsigned char *)this + 126))
  {
    uint64_t v9 = 0;
    memset(v8, 0, sizeof(v8));
    kdu_error::kdu_error((kdu_error *)v8, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v8);
  }
  if (*((void *)this + 4)) {
    return (*(uint64_t (**)(jp2_input_box *))(*(void *)this + 80))(this);
  }
  do
  {
    if (*((unsigned char *)this + 125)) {
      return 0;
    }
    uint64_t v3 = *((void *)this + 1);
    if ((v3 & 0x8000000000000000) == 0) {
      *((void *)this + 1) = *((void *)this + 7) + v3;
    }
    if (*(void *)(*((void *)this + 5) + 32))
    {
      if ((*((void *)this + 2) & 0x8000000000000000) != 0) {
        jp2_input_box::open_next();
      }
      *((_DWORD *)this + 6) += *((_DWORD *)this + 18);
    }
    uint64_t result = jp2_input_box::read_box_header(this, 0);
    if (!result) {
      return result;
    }
    int v4 = *((_DWORD *)this + 12);
    if (v4) {
      break;
    }
    (*(void (**)(jp2_input_box *))(*(void *)this + 16))(this);
    int v4 = *((_DWORD *)this + 12);
  }
  while (!v4);
  uint64_t v5 = *((void *)this + 5);
  if (*(void *)(v5 + 32)) {
    BOOL v6 = v4 == 1785737827;
  }
  else {
    BOOL v6 = 0;
  }
  if (v6) {
    int v7 = 4;
  }
  else {
    int v7 = 1;
  }
  *((_DWORD *)this + 32) = v7;
  if (*(unsigned char *)(v5 + 68)) {
    *((_DWORD *)this + 32) = v7 | 2;
  }
  return 1;
}

void sub_188678040(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867804C()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_input_box::close(jp2_input_box *this)
{
  if (!*((unsigned char *)this + 126)) {
    return 1;
  }
  uint64_t v2 = *((void *)this + 5);
  if (v2 && *(void *)(v2 + 32)) {
    jp2_input_box::is_complete(this);
  }
  *((unsigned char *)this + 126) = 0;
  *((_DWORD *)this + 12) = 0;
  *((_DWORD *)this + 32) = 0;
  int v3 = *((unsigned __int8 *)this + 125);
  if (*((unsigned char *)this + 125) || (uint64_t v4 = *((void *)this + 11), *((void *)this + 17) >= v4))
  {
    uint64_t result = 1;
  }
  else
  {
    uint64_t result = 0;
    *((void *)this + 17) = v4;
  }
  uint64_t v6 = *((void *)this + 4);
  if (v6)
  {
    *(unsigned char *)(v6 + 127) = 0;
    uint64_t v7 = *((void *)this + 9);
    *(void *)(v6 + 136) += v7;
    if (v3)
    {
      if (!v7) {
        *(void *)(v6 + 136) = *((void *)this + 17);
      }
      int v8 = *(uint64_t (**)(uint64_t))(*(void *)v6 + 16);
      return v8(v6);
    }
  }
  return result;
}

BOOL jp2_input_box::is_complete(jp2_input_box *this)
{
  if (!*((unsigned char *)this + 126)) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 5);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(void *)(v2 + 32);
  if (!v3) {
    return 1;
  }
  if ((*((void *)this + 12) & 0x8000000000000000) != 0 || (*((_DWORD *)this + 30) & 0x80000000) != 0) {
    jp2_input_box::is_complete();
  }
  int v5 = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 80))(v3);
  return *((_DWORD *)this + 30) == 4 && !*((unsigned char *)this + 125) && *((void *)this + 11) <= v5;
}

uint64_t jp2_input_box::transplant(jp2_input_box *this, jp2_input_box *a2)
{
  if (*((unsigned char *)this + 126)) {
    BOOL v2 = 1;
  }
  else {
    BOOL v2 = *((unsigned char *)a2 + 126) == 0;
  }
  if (v2)
  {
    uint64_t v8 = 0;
    memset(v7, 0, sizeof(v7));
    kdu_error::kdu_error((kdu_error *)v7, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v7);
  }
  long long v3 = *(_OWORD *)((char *)a2 + 8);
  *((_DWORD *)this + 6) = *((_DWORD *)a2 + 6);
  *(_OWORD *)((char *)this + 8) = v3;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = *((void *)a2 + 5);
  *((_DWORD *)this + 12) = *((_DWORD *)a2 + 12);
  *(_OWORD *)((char *)this + 56) = *(_OWORD *)((char *)a2 + 56);
  *(_OWORD *)((char *)this + 72) = *(_OWORD *)((char *)a2 + 72);
  *(_OWORD *)((char *)this + 88) = *(_OWORD *)((char *)a2 + 88);
  *(_OWORD *)((char *)this + 104) = *(_OWORD *)((char *)a2 + 104);
  *((_DWORD *)this + 30) = *((_DWORD *)a2 + 30);
  *((unsigned char *)this + 124) = *((unsigned char *)a2 + 124);
  *((unsigned char *)this + 125) = *((unsigned char *)a2 + 125);
  *((_WORD *)this + 63) = 1;
  *((_DWORD *)this + 32) = *((_DWORD *)a2 + 32);
  *(_OWORD *)((char *)this + 136) = *(_OWORD *)((char *)a2 + 136);
  int v4 = *((_DWORD *)a2 + 44);
  *((_DWORD *)this + 44) = v4;
  if (v4 >= 1)
  {
    uint64_t v5 = 0;
    do
    {
      *((unsigned char *)this + v5 + 152) = *((unsigned char *)a2 + v5 + 152);
      ++v5;
    }
    while (v5 < *((int *)this + 44));
  }
  return (*(uint64_t (**)(jp2_input_box *))(*(void *)a2 + 16))(a2);
}

void sub_18867839C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886783A8()
{
  _Unwind_Resume(v0);
}

BOOL jp2_input_box::seek(jp2_input_box *this, uint64_t a2)
{
  if (!*((unsigned char *)this + 126) || *((unsigned char *)this + 127))
  {
    uint64_t v7 = 0;
    memset(v6, 0, sizeof(v6));
    kdu_error::kdu_error((kdu_error *)v6, "Error in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v6[0] + 16))(v6, "Attempting to seek inside a JP2 box which is not open, or is sharing its read pointer with an open sub-box.");
    kdu_error::~kdu_error((kdu_error *)v6);
  }
  int v2 = *(unsigned __int8 *)(*((void *)this + 5) + 68);
  if (*(unsigned char *)(*((void *)this + 5) + 68))
  {
    uint64_t v3 = *((void *)this + 10);
    uint64_t v4 = *((void *)this + 11);
    if (v3 + a2 < v4) {
      uint64_t v4 = v3 + a2;
    }
    if (v4 > v3) {
      uint64_t v3 = v4;
    }
    *((void *)this + 17) = v3;
    *((_DWORD *)this + 44) = 0;
  }
  return v2 != 0;
}

void sub_188678484(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188678490()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_input_box::set_tileheader_scope(jp2_input_box *this, int a2)
{
  if (!*((unsigned char *)this + 126)) {
    return 0;
  }
  uint64_t v3 = *((void *)this + 5);
  if (!v3) {
    return 0;
  }
  uint64_t result = *(void *)(v3 + 32);
  if (!result) {
    return result;
  }
  if ((*((void *)this + 18) & 0x8000000000000000) != 0) {
    return 0;
  }
  *((_DWORD *)this + 30) = 1;
  *((void *)this + 12) = a2;
  *((void *)this + 10) = 0;
  *((void *)this + 17) = 0;
  (*(void (**)(uint64_t, uint64_t))(*(void *)result + 80))(result, 1);
  *((void *)this + 11) = 0x7FFFFFFFFFFFFFFFLL;
  return 0;
}

uint64_t jp2_input_box::set_precinct_scope(jp2_input_box *this, uint64_t a2)
{
  if (!*((unsigned char *)this + 126)) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 5);
  if (!v2 || !*(void *)(v2 + 32) || (*((void *)this + 18) & 0x8000000000000000) != 0) {
    return 0;
  }
  *((_DWORD *)this + 30) = 0;
  *((void *)this + 12) = a2;
  *((void *)this + 17) = 0;
  *((_OWORD *)this + 5) = xmmword_18898D160;
  return 1;
}

BOOL jp2_input_box::set_codestream_scope(jp2_input_box *this, uint64_t a2, int a3)
{
  if (!*((unsigned char *)this + 126)) {
    return 0;
  }
  uint64_t v3 = *((void *)this + 5);
  if (!v3 || *((void *)this + 13) > a2 || *((void *)this + 14) <= a2) {
    return 0;
  }
  *((_DWORD *)this + 30) = 3;
  *((void *)this + 12) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 18) = a2;
  *((_OWORD *)this + 5) = xmmword_18898D160;
  if (!a3) {
    return 1;
  }
  char v5 = 0;
  (*(void (**)(void, uint64_t, uint64_t, void, char *))(**(void **)(v3 + 32) + 80))(*(void *)(v3 + 32), 3, a2, 0, &v5);
  return v5 != 0;
}

size_t jp2_input_box::read(jp2_input_box *this, unsigned __int8 *a2, int64_t a3)
{
  if (!*((void *)this + 5) || !*((unsigned char *)this + 126) || *((unsigned char *)this + 127))
  {
    uint64_t v37 = 0;
    long long v35 = 0u;
    long long v36 = 0u;
    kdu_error::kdu_error((kdu_error *)&v35, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v35 + 16))(&v35, "Illegal attempt to read from a JP2 box which is either not open or else has an open sub-box.");
    kdu_error::~kdu_error((kdu_error *)&v35);
  }
  uint64_t v6 = *((void *)this + 11) - *((void *)this + 17);
  if (v6 < (int)a3 && *((unsigned char *)this + 125) == 0) {
    int64_t v8 = v6;
  }
  else {
    int64_t v8 = a3;
  }
  if ((int)v8 < 1) {
    return 0;
  }
  if (v8 > (int)a3)
  {
    uint64_t v37 = 0;
    long long v35 = 0u;
    long long v36 = 0u;
    kdu_warning::kdu_warning((kdu_warning *)&v35, "Warning in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v35 + 16))(&v35, "Corrupt JP2 Data");
    kdu_warning::~kdu_warning((kdu_warning *)&v35);
    int64_t v8 = a3;
  }
  (*(void (**)(void))(**((void **)this + 5) + 16))(*((void *)this + 5));
  uint64_t v9 = *((void *)this + 5);
  uint64_t v10 = *(void *)(v9 + 32);
  if (v10)
  {
    if (!*(unsigned char *)(v9 + 68)) {
      jp2_input_box::read();
    }
    int v11 = *((_DWORD *)this + 30);
    if (v11 == 4) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = *((void *)this + 18);
    }
    uint64_t v16 = *((void *)this + 12);
    if (*(void *)(v9 + 48) != v16 || *(_DWORD *)(v9 + 64) != v11 || *(void *)(v9 + 56) != v12)
    {
      *(_DWORD *)(v9 + 64) = v11;
      *(void *)(v9 + 48) = v16;
      *(void *)(v9 + 56) = v12;
      *(void *)(v9 + 40) = 0;
      (*(void (**)(uint64_t))(*(void *)v10 + 160))(v10);
      uint64_t v9 = *((void *)this + 5);
    }
    if (*(void *)(v9 + 40) != *((void *)this + 17))
    {
      char v17 = (*(uint64_t (**)(void))(**(void **)(v9 + 32) + 40))(*(void *)(v9 + 32));
      uint64_t v9 = *((void *)this + 5);
      if ((v17 & 1) == 0)
      {
        (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
        uint64_t v37 = 0;
        long long v35 = 0u;
        long long v36 = 0u;
        kdu_error::kdu_error((kdu_error *)&v35, "Error in Kakadu File Format Support:\n");
        (*(void (**)(long long *, const char *))(v35 + 16))(&v35, "Caching source does not appear to support seeking!");
        kdu_error::~kdu_error((kdu_error *)&v35);
      }
    }
    size_t v13 = (*(uint64_t (**)(void, unsigned __int8 *, int64_t))(**(void **)(v9 + 32) + 32))(*(void *)(v9 + 32), a2, v8);
    uint64_t v18 = *((void *)this + 17) + (int)v13;
    *((void *)this + 17) = v18;
    unsigned int v19 = (void *)*((void *)this + 5);
    v19[5] = v18;
    if ((int)v13 < (int)v8) {
      v19[6] = -1;
    }
    (*(void (**)(void *))(*v19 + 24))(v19);
    if ((int)v13 < (int)v8)
    {
      char v34 = 0;
      int v20 = (*(uint64_t (**)(void, void, uint64_t, void, char *))(**(void **)(*((void *)this + 5)
                                                                                             + 32)
                                                                               + 80))(*(void *)(*((void *)this + 5) + 32), *((unsigned int *)this + 30), v12, *((void *)this + 12), &v34);
      if (v34)
      {
        if (*((void *)this + 17) == v20)
        {
          uint64_t v21 = v20;
          if (!*((unsigned char *)this + 125) && *((_DWORD *)this + 30) == 4)
          {
            uint64_t v22 = *((void *)this + 11);
            if (v22 != v20 && v22 != 0x7FFFFFFFFFFFFFFFLL)
            {
              uint64_t v37 = 0;
              long long v35 = 0u;
              long long v36 = 0u;
              kdu_error::kdu_error((kdu_error *)&v35, "Error in Kakadu File Format Support:\n");
              (*(void (**)(long long *, const char *))(v35 + 16))(&v35, "Cached data-bin appears to be complete yet terminates prior to the end of the current JP2 box.");
              kdu_error::~kdu_error((kdu_error *)&v35);
            }
            *((void *)this + 11) = v20;
            return v13;
          }
LABEL_60:
          *((void *)this + 11) = v21;
          *((unsigned char *)this + 125) = 0;
        }
      }
    }
  }
  else
  {
    uint64_t v14 = *(void *)(v9 + 40);
    uint64_t v15 = *((void *)this + 17);
    if (*(unsigned char *)(v9 + 68))
    {
      if (v14 != v15)
      {
        if (*(void *)(v9 + 16))
        {
          fseek(*(FILE **)(v9 + 16), v15, 0);
        }
        else
        {
          uint64_t v27 = *(void *)(v9 + 24);
          if (v27) {
            (*(void (**)(uint64_t))(*(void *)v27 + 40))(v27);
          }
        }
      }
    }
    else
    {
      for (; v14 < v15; uint64_t v15 = *((void *)this + 17))
      {
        uint64_t v23 = v14 + 24;
        unsigned int v24 = v15 - v14;
        if (v23 <= v15) {
          uint64_t v25 = 24;
        }
        else {
          uint64_t v25 = v24;
        }
        uint64_t v26 = *(FILE **)(v9 + 16);
        if (v26)
        {
          uint64_t v25 = (int)v25;
          fread((char *)this + 152, 1uLL, (int)v25, v26);
        }
        else
        {
          (*(void (**)(void, char *, uint64_t))(**(void **)(v9 + 24) + 32))(*(void *)(v9 + 24), (char *)this + 152, v25);
          uint64_t v25 = (int)v25;
        }
        uint64_t v9 = *((void *)this + 5);
        uint64_t v14 = *(void *)(v9 + 40) + v25;
        *(void *)(v9 + 40) = v14;
      }
      if (v14 != v15)
      {
        (*(void (**)(uint64_t))(*(void *)v9 + 24))(v9);
        uint64_t v37 = 0;
        long long v35 = 0u;
        long long v36 = 0u;
        kdu_error::kdu_error((kdu_error *)&v35, "Error in Kakadu File Format Support:\n");
        (*(void (**)(long long *, const char *))(v35 + 16))(&v35, "Non-seekable JP2 sources must be read sequentially.  You are attempting to read from multiple boxes simultaneously.");
        kdu_error::~kdu_error((kdu_error *)&v35);
      }
    }
    uint64_t v28 = *((void *)this + 5);
    uint64_t v29 = *(FILE **)(v28 + 16);
    if (v29)
    {
      size_t v13 = fread(a2, 1uLL, (int)v8, v29);
    }
    else
    {
      uint64_t v30 = *(void *)(v28 + 24);
      size_t v13 = v8;
      if (v30) {
        size_t v13 = (*(uint64_t (**)(uint64_t, unsigned __int8 *, int64_t))(*(void *)v30 + 32))(v30, a2, v8);
      }
    }
    uint64_t v31 = *((void *)this + 17) + (int)v13;
    *((void *)this + 17) = v31;
    uint64_t v32 = (void *)*((void *)this + 5);
    v32[5] = v31;
    (*(void (**)(void *))(*v32 + 24))(v32);
    if ((int)v13 < (int)v8 && *((unsigned char *)this + 125))
    {
      uint64_t v21 = *((void *)this + 17);
      goto LABEL_60;
    }
  }
  return v13;
}

void sub_188678CB4(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188678CC0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

BOOL jp2_input_box::read(jp2_input_box *this, unsigned int *a2)
{
  uint64_t v2 = *((int *)this + 44);
  if ((int)v2 >= 4) {
    jp2_input_box::read();
  }
  int v5 = *((_DWORD *)this + 44)
     + (*(uint64_t (**)(jp2_input_box *, char *, void))(*(void *)this + 32))(this, (char *)this + v2 + 152, (4 - v2));
  *((_DWORD *)this + 44) = v5;
  if (v5 >= 4)
  {
    if (v5 != 4) {
      jp2_input_box::read();
    }
    unsigned int v6 = *((unsigned __int8 *)this + 152);
    *a2 = v6;
    int v7 = *((unsigned __int8 *)this + 153) | (v6 << 8);
    *a2 = v7;
    int v8 = *((unsigned __int8 *)this + 154) | (v7 << 8);
    *a2 = v8;
    *a2 = *((unsigned __int8 *)this + 155) | (v8 << 8);
    *((_DWORD *)this + 44) = 0;
  }
  return v5 > 3;
}

BOOL jp2_input_box::read(jp2_input_box *this, unsigned __int16 *a2)
{
  int v4 = *((_DWORD *)this + 44);
  if (v4 >= 2)
  {
    uint64_t v9 = 0;
    memset(v8, 0, sizeof(v8));
    kdu_error::kdu_error((kdu_error *)v8, "Error in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v8[0] + 16))(v8, "Attempting to read a 2-byte word from a JP2 box, after first reading a partial 4-byte word!");
    kdu_error::~kdu_error((kdu_error *)v8);
  }
  int v5 = *((_DWORD *)this + 44)
     + (*(uint64_t (**)(jp2_input_box *, char *, void))(*(void *)this + 32))(this, (char *)this + v4 + 152, (2 - v4));
  *((_DWORD *)this + 44) = v5;
  if (v5 >= 2)
  {
    if (v5 != 2) {
      jp2_input_box::read();
    }
    unsigned __int16 v6 = *((unsigned __int8 *)this + 152);
    *a2 = v6;
    *a2 = *((unsigned __int8 *)this + 153) | (unsigned __int16)(v6 << 8);
    *((_DWORD *)this + 44) = 0;
  }
  return v5 > 1;
}

void sub_188678ED8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188678EE4()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_family_tgt::open(uint64_t this, kdu_compressed_target *a2)
{
  if (*(void *)(this + 8) || *(void *)(this + 16))
  {
    uint64_t v3 = 0;
    memset(v2, 0, sizeof(v2));
    kdu_error::kdu_error((kdu_error *)v2, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v2);
  }
  *(void *)(this + 16) = a2;
  *(void *)(this + 24) = 0;
  *(unsigned char *)(this + 32) = 0;
  return this;
}

void sub_188678F94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188678FA0()
{
  _Unwind_Resume(v0);
}

FILE *jp2_family_tgt::close(jp2_family_tgt *this)
{
  uint64_t v3 = (void *)((char *)this + 8);
  uint64_t result = (FILE *)*((void *)this + 1);
  if (result) {
    uint64_t result = (FILE *)fclose(result);
  }
  *((unsigned char *)this + 32) = 0;
  void *v3 = 0;
  v3[1] = 0;
  return result;
}

void jp2_output_box::jp2_output_box(jp2_output_box *this)
{
  *(void *)this = &unk_1ED4E3098;
  *((_DWORD *)this + 2) = 0;
  *((unsigned char *)this + 72) = 0;
  *((unsigned char *)this + 12) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 7) = -1;
  *((void *)this + 8) = 0;
}

void jp2_output_box::~jp2_output_box(jp2_output_box *this)
{
  *(void *)this = &unk_1ED4E3098;
  uint64_t v2 = *((void *)this + 8);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C8077774924);
  }
  *(void *)this = &unk_1ED4E5410;
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1ED4E3098;
  uint64_t v2 = *((void *)this + 8);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C8077774924);
  }
  *(void *)this = &unk_1ED4E5410;

  JUMPOUT(0x18C11C0E0);
}

uint64_t jp2_output_box::open(uint64_t this, jp2_family_tgt *a2, int a3, int a4)
{
  if (*(_DWORD *)(this + 8))
  {
    uint64_t v6 = 0;
    long long v4 = 0u;
    long long v5 = 0u;
    kdu_error::kdu_error((kdu_error *)&v4, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v4);
  }
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = 0;
  if (a2)
  {
    if (*((unsigned char *)a2 + 32))
    {
      uint64_t v6 = 0;
      long long v4 = 0u;
      long long v5 = 0u;
      kdu_error::kdu_error((kdu_error *)&v4, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)&v4);
    }
  }
  else if (a4)
  {
    jp2_output_box::open();
  }
  if (*(void *)(this + 64) || *(_DWORD *)(this + 32)) {
    jp2_output_box::open();
  }
  *(_DWORD *)(this + 8) = a3;
  *(unsigned char *)(this + 12) = a4;
  *(void *)(this + 16) = a2;
  *(void *)(this + 40) = 0;
  *(void *)(this + 48) = -1;
  *(void *)(this + 56) = -1;
  *(unsigned char *)(this + 72) = 0;
  *(unsigned char *)(this + 73) = a4;
  *(unsigned char *)(this + 74) = 0;
  if (a4) {
    return jp2_output_box::write_header((jp2_output_box *)this);
  }
  return this;
}

void sub_188679290(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867929C()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_output_box::write_header(jp2_output_box *this)
{
  if (!*((_DWORD *)this + 2) || !*((void *)this + 2) && !*((void *)this + 3)) {
    jp2_output_box::write_header();
  }
  if (!*((unsigned char *)this + 73)) {
    jp2_output_box::write_header();
  }
  if ((*((void *)this + 7) & 0x8000000000000000) == 0) {
    jp2_output_box::write_header();
  }
  uint64_t v2 = *((void *)this + 5);
  *((void *)this + 5) = -16;
  if (*((unsigned char *)this + 12))
  {
    if (*((unsigned char *)this + 74)) {
      jp2_output_box::write_header();
    }
    unsigned int v8 = 0;
  }
  else
  {
    unint64_t v3 = *((void *)this + 6);
    if ((v3 & 0x8000000000000000) != 0) {
      jp2_output_box::write_header();
    }
    uint64_t v4 = 16;
    if (v3 < 0x1FFFFFFF8) {
      uint64_t v4 = 8;
    }
    if (*((unsigned char *)this + 74)) {
      uint64_t v5 = v4 + v3 + 8;
    }
    else {
      uint64_t v5 = v4 + v3;
    }
    if (v3 > 0x1FFFFFFF7 || *((unsigned char *)this + 74))
    {
      unsigned int v8 = 0x1000000;
      (*(void (**)(jp2_output_box *, unsigned int *, uint64_t))(*(void *)this + 40))(this, &v8, 4);
      unsigned int v8 = bswap32(*((_DWORD *)this + 2));
      (*(void (**)(jp2_output_box *, unsigned int *, uint64_t))(*(void *)this + 40))(this, &v8, 4);
      HIBYTE(v8) = BYTE4(v5);
      BYTE2(v8) = BYTE5(v5);
      BYTE1(v8) = BYTE6(v5);
      LOBYTE(v8) = HIBYTE(v5);
      (*(void (**)(jp2_output_box *, unsigned int *, uint64_t))(*(void *)this + 40))(this, &v8, 4);
      unsigned int v6 = bswap32(v5);
      goto LABEL_19;
    }
    unsigned int v8 = bswap32(v5);
  }
  (*(void (**)(jp2_output_box *, unsigned int *, uint64_t))(*(void *)this + 40))(this, &v8, 4);
  unsigned int v6 = bswap32(*((_DWORD *)this + 2));
LABEL_19:
  unsigned int v8 = v6;
  uint64_t result = (*(uint64_t (**)(jp2_output_box *, unsigned int *, uint64_t))(*(void *)this + 40))(this, &v8, 4);
  *((void *)this + 5) = v2;
  return result;
}

uint64_t jp2_output_box::open(uint64_t this, jp2_output_box *a2, int a3, int a4)
{
  uint64_t v5 = (jp2_output_box *)this;
  if (*(_DWORD *)(this + 8))
  {
    uint64_t v7 = 0;
    memset(v6, 0, sizeof(v6));
    kdu_error::kdu_error((kdu_error *)v6, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v6);
  }
  if (*(void *)(this + 64) || *(_DWORD *)(this + 32)) {
    jp2_output_box::open();
  }
  *(_DWORD *)(this + 8) = a3;
  *(unsigned char *)(this + 12) = a4;
  *(void *)(this + 16) = 0;
  *(void *)(this + 24) = a2;
  *(void *)(this + 40) = 0;
  *(void *)(this + 48) = -1;
  *(void *)(this + 56) = -1;
  *(unsigned char *)(this + 72) = 0;
  *(unsigned char *)(this + 73) = a4;
  *(unsigned char *)(this + 74) = 0;
  if (a4)
  {
    jp2_output_box::set_rubber_length((uint64_t)a2);
    if (!*((unsigned char *)a2 + 12) || !*((unsigned char *)a2 + 73)) {
      jp2_output_box::open();
    }
    return jp2_output_box::write_header(v5);
  }
  return this;
}

void sub_1886795D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886795E0()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_output_box::set_rubber_length(uint64_t this)
{
  if (!*(_DWORD *)(this + 8)) {
    jp2_output_box::set_rubber_length();
  }
  uint64_t v1 = this;
  if ((*(void *)(this + 16) || *(void *)(this + 24)) && !*(unsigned char *)(this + 12))
  {
    if (*(unsigned char *)(this + 73))
    {
      uint64_t v11 = 0;
      long long v9 = 0u;
      long long v10 = 0u;
      kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v9 + 16))(&v9, "Attempting to set a rubber length for a JP2 box whose total length has already been declared, or is to be written at the end.");
      kdu_error::~kdu_error((kdu_error *)&v9);
    }
    if ((*(void *)(this + 56) & 0x8000000000000000) == 0)
    {
      uint64_t v11 = 0;
      long long v9 = 0u;
      long long v10 = 0u;
      kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v9 + 16))(&v9, "Attempting to set a rubber length for a JP2 box which is currently inside a rewrite section.");
      kdu_error::~kdu_error((kdu_error *)&v9);
    }
    uint64_t v2 = *(jp2_output_box **)(this + 24);
    if (v2) {
      jp2_output_box::set_rubber_length(v2);
    }
    *(unsigned char *)(v1 + 12) = 1;
    *(unsigned char *)(v1 + 73) = 1;
    this = jp2_output_box::write_header((jp2_output_box *)v1);
    if (*(void *)(v1 + 64))
    {
      uint64_t v3 = *(void *)(v1 + 24);
      if (v3)
      {
        *(unsigned char *)(v1 + 72) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 40))(v3) ^ 1;
      }
      else
      {
        uint64_t v4 = *(void *)(v1 + 16);
        uint64_t v5 = *(FILE **)(v4 + 8);
        if (v5)
        {
          size_t v6 = fwrite(*(const void **)(v1 + 64), 1uLL, *(void *)(v1 + 40), v5);
          uint64_t v7 = *(void *)(v1 + 40);
          *(unsigned char *)(v1 + 72) = v6 != v7;
        }
        else
        {
          uint64_t v8 = *(void *)(v4 + 16);
          if (!v8) {
            jp2_output_box::set_rubber_length();
          }
          *(unsigned char *)(v1 + 72) = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 40))(v8) ^ 1;
          uint64_t v7 = *(void *)(v1 + 40);
        }
        *(void *)(*(void *)(v1 + 16) + 24) += v7;
      }
      this = *(void *)(v1 + 64);
      if (this) {
        this = MEMORY[0x18C11C0C0](this, 0x1000C8077774924);
      }
      *(_DWORD *)(v1 + 32) = 0;
      *(void *)(v1 + 64) = 0;
    }
  }
  return this;
}

void sub_188679800(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867980C()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_output_box::open_next(jp2_output_box *this)
{
  if (*((void *)this + 3))
  {
    uint64_t v1 = *(uint64_t (**)(void))(*(void *)this + 64);
  }
  else
  {
    if (!*((void *)this + 2))
    {
      uint64_t v4 = 0;
      memset(v3, 0, sizeof(v3));
      kdu_error::kdu_error((kdu_error *)v3, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)v3);
    }
    uint64_t v1 = *(uint64_t (**)(void))(*(void *)this + 56);
  }
  return v1();
}

void sub_18867993C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188679948()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_output_box::set_target_size(uint64_t this, uint64_t a2)
{
  uint64_t v2 = this;
  if (*(unsigned char *)(this + 12))
  {
    uint64_t v11 = 0;
    long long v9 = 0u;
    long long v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v9 + 16))(&v9, "Attempting to set the target size of a JP2 box which has already been assigned a rubber length.");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  if (*(unsigned char *)(this + 73))
  {
    uint64_t v11 = 0;
    long long v9 = 0u;
    long long v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v9 + 16))(&v9, "Attempting to set the target size of a JP2 box whose content length is already known, or is to be written at the end.");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  if ((*(void *)(this + 56) & 0x8000000000000000) == 0)
  {
    uint64_t v11 = 0;
    long long v9 = 0u;
    long long v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v9 + 16))(&v9, "Attempting to set the target size of a JP2 box which is currently inside a rewrite section.");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  if (!*(_DWORD *)(this + 8)) {
    jp2_output_box::set_target_size();
  }
  if (*(void *)(this + 16) || *(void *)(this + 24))
  {
    *(void *)(this + 48) = a2;
    if (*(void *)(this + 40) > a2)
    {
      uint64_t v11 = 0;
      long long v9 = 0u;
      long long v10 = 0u;
      kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v9 + 16))(&v9, "Attempting to set the target size of a JP2 box to which a larger number of bytes has already been written.");
      kdu_error::~kdu_error((kdu_error *)&v9);
    }
    *(unsigned char *)(this + 73) = 1;
    this = jp2_output_box::write_header((jp2_output_box *)this);
    if (*(void *)(v2 + 64))
    {
      uint64_t v3 = *(void *)(v2 + 24);
      if (v3)
      {
        *(unsigned char *)(v2 + 72) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 40))(v3) ^ 1;
      }
      else
      {
        uint64_t v4 = *(void *)(v2 + 16);
        uint64_t v5 = *(FILE **)(v4 + 8);
        if (v5)
        {
          size_t v6 = fwrite(*(const void **)(v2 + 64), 1uLL, *(void *)(v2 + 40), v5);
          uint64_t v7 = *(void *)(v2 + 40);
          *(unsigned char *)(v2 + 72) = v6 != v7;
        }
        else
        {
          uint64_t v8 = *(void *)(v4 + 16);
          if (!v8) {
            jp2_output_box::set_target_size();
          }
          *(unsigned char *)(v2 + 72) = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 40))(v8) ^ 1;
          uint64_t v7 = *(void *)(v2 + 40);
        }
        *(void *)(*(void *)(v2 + 16) + 24) += v7;
      }
      this = *(void *)(v2 + 64);
      if (this) {
        this = MEMORY[0x18C11C0C0](this, 0x1000C8077774924);
      }
      *(_DWORD *)(v2 + 32) = 0;
      *(void *)(v2 + 64) = 0;
    }
  }
  return this;
}

void sub_188679C24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188679C30()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_output_box::write_header_last(uint64_t this)
{
  uint64_t v1 = this;
  if (!*(_DWORD *)(this + 8))
  {
    uint64_t v7 = 0;
    long long v5 = 0u;
    long long v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  if (!*(unsigned char *)(this + 73) && !*(unsigned char *)(this + 74))
  {
    uint64_t v2 = *(void *)(this + 16);
    if (v2)
    {
      if (*(void *)(v2 + 8)
        || (uint64_t v3 = *(void *)(v2 + 16)) != 0
        && (char v4 = (*(uint64_t (**)(uint64_t, void))(*(void *)v3 + 24))(v3, 0),
            (*(void (**)(void))(**(void **)(*(void *)(v1 + 16) + 16) + 32))(*(void *)(*(void *)(v1 + 16) + 16)),
            (v4 & 1) != 0))
      {
        *(unsigned char *)(v1 + 74) = 1;
        this = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v1 + 48))(v1, 0x7FFFFFFFFFFFFFFFLL);
        if (!*(unsigned char *)(v1 + 73)) {
          jp2_output_box::write_header_last();
        }
        return this;
      }
    }
    else if (!*(void *)(this + 24))
    {
      return this;
    }
    uint64_t v7 = 0;
    long long v5 = 0u;
    long long v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  return this;
}

void sub_188679E1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188679E28()
{
  _Unwind_Resume(v0);
}

BOOL jp2_output_box::close(jp2_output_box *this)
{
  if (!*((_DWORD *)this + 2)) {
    return 1;
  }
  (*(void (**)(jp2_output_box *))(*(void *)this + 32))(this);
  uint64_t v2 = *((void *)this + 6);
  if (v2 < 0 || *((unsigned char *)this + 74))
  {
    *((void *)this + 6) = *((void *)this + 5);
  }
  else if (v2 != *((void *)this + 5))
  {
    uint64_t v20 = 0;
    memset(v19, 0, sizeof(v19));
    kdu_error::kdu_error((kdu_error *)v19, "Error in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v19[0] + 16))(v19, "Attempting to close an output JP2 box whose length was defined ahead of time, having written less bytes than indicated by that length value.");
    kdu_error::~kdu_error((kdu_error *)v19);
  }
  if (*((void *)this + 2) || *((void *)this + 3))
  {
    if (*((unsigned char *)this + 73))
    {
      if (*((void *)this + 8)) {
        jp2_output_box::close();
      }
    }
    else
    {
      *((unsigned char *)this + 73) = 1;
      jp2_output_box::write_header(this);
      if (*((void *)this + 8))
      {
        uint64_t v4 = *((void *)this + 3);
        if (v4)
        {
          *((unsigned char *)this + 72) = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 40))(v4) ^ 1;
        }
        else
        {
          uint64_t v6 = *((void *)this + 2);
          uint64_t v7 = *(FILE **)(v6 + 8);
          if (v7)
          {
            size_t v8 = fwrite(*((const void **)this + 8), 1uLL, *((void *)this + 5), v7);
            uint64_t v9 = *((void *)this + 5);
            *((unsigned char *)this + 72) = v8 != v9;
          }
          else
          {
            uint64_t v10 = *(void *)(v6 + 16);
            if (!v10) {
              jp2_output_box::close();
            }
            *((unsigned char *)this + 72) = (*(uint64_t (**)(uint64_t))(*(void *)v10 + 40))(v10) ^ 1;
            uint64_t v9 = *((void *)this + 5);
          }
          *(void *)(*((void *)this + 2) + 24) += v9;
        }
        uint64_t v11 = *((void *)this + 8);
        if (v11) {
          MEMORY[0x18C11C0C0](v11, 0x1000C8077774924);
        }
        *((_DWORD *)this + 8) = 0;
        *((void *)this + 8) = 0;
      }
    }
  }
  else
  {
    uint64_t v5 = *((void *)this + 8);
    if (v5) {
      MEMORY[0x18C11C0C0](v5, 0x1000C8077774924);
    }
    *((_DWORD *)this + 8) = 0;
    *((void *)this + 8) = 0;
    *(_WORD *)((char *)this + 73) = 0;
  }
  if (*((unsigned char *)this + 74))
  {
    uint64_t v12 = (void *)*((void *)this + 2);
    if (v12)
    {
      size_t v13 = (FILE *)v12[1];
      if (v13)
      {
        fflush(v13);
        uint64_t v14 = *((void *)this + 2);
        uint64_t v15 = *(void *)(v14 + 24);
        uint64_t v16 = v15 - *((void *)this + 6) - 16;
        *(void *)(v14 + 24) = v16;
        fseek(*(FILE **)(v14 + 8), v16, 0);
        jp2_output_box::write_header(this);
        fseek(*(FILE **)(*((void *)this + 2) + 8), v15, 0);
LABEL_34:
        *(void *)(*((void *)this + 2) + 24) = v15;
        goto LABEL_35;
      }
      uint64_t v17 = v12[2];
      if (v17)
      {
        uint64_t v15 = v12[3];
        v12[3] = v15 - (*((void *)this + 6) + 16);
        if (((*(uint64_t (**)(uint64_t))(*(void *)v17 + 24))(v17) & 1) == 0) {
          jp2_output_box::close();
        }
        jp2_output_box::write_header(this);
        (*(void (**)(void))(**(void **)(*((void *)this + 2) + 16) + 32))(*(void *)(*((void *)this + 2) + 16));
        goto LABEL_34;
      }
    }
    jp2_output_box::close();
  }
LABEL_35:
  *((_DWORD *)this + 2) = 0;
  if (*((unsigned char *)this + 12))
  {
    uint64_t v18 = *((void *)this + 2);
    if (v18) {
      *(unsigned char *)(v18 + 32) = 1;
    }
  }
  return *((unsigned char *)this + 72) == 0;
}

void sub_18867A178(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867A184()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_output_box::start_rewrite(jp2_output_box *this, uint64_t a2)
{
  if (!*((_DWORD *)this + 2)) {
    return 0;
  }
  uint64_t result = 0;
  if ((a2 & 0x8000000000000000) == 0 && (*((void *)this + 7) & 0x8000000000000000) != 0)
  {
    uint64_t v5 = *((void *)this + 5);
    if (v5 < a2) {
      return 0;
    }
    *((void *)this + 7) = v5;
    *((void *)this + 5) = v5 - a2;
    if (*((unsigned char *)this + 73))
    {
      uint64_t v6 = *((void *)this + 2);
      if (v6)
      {
        uint64_t v7 = *(FILE **)(v6 + 8);
        if (v7)
        {
          if (a2)
          {
            fflush(v7);
            uint64_t v8 = *((void *)this + 2);
            uint64_t v9 = *(void *)(v8 + 24) - a2;
            *(void *)(v8 + 24) = v9;
            fseek(*(FILE **)(v8 + 8), v9, 0);
          }
          return 1;
        }
        uint64_t v11 = *(void *)(v6 + 16);
        if (v11 && (*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v11 + 24))(v11, a2))
        {
          *(void *)(*((void *)this + 2) + 24) -= a2;
          return 1;
        }
      }
      else
      {
        uint64_t v10 = *((void *)this + 3);
        if (v10 && ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v10 + 24))(v10, a2) & 1) != 0) {
          return 1;
        }
      }
      uint64_t result = 0;
      *((void *)this + 7) = -1;
      *((void *)this + 5) += a2;
      return result;
    }
    return 1;
  }
  return result;
}

BOOL jp2_output_box::end_rewrite(jp2_output_box *this)
{
  uint64_t v1 = *((void *)this + 7);
  if ((v1 & 0x8000000000000000) == 0)
  {
    uint64_t v3 = *((void *)this + 5);
    uint64_t v4 = v1 - v3;
    if (v1 - v3 < 0) {
      jp2_output_box::end_rewrite();
    }
    *((void *)this + 5) = v1;
    *((void *)this + 7) = -1;
    if (*((unsigned char *)this + 73))
    {
      uint64_t v5 = *((void *)this + 2);
      if (v5)
      {
        uint64_t v6 = *(FILE **)(v5 + 8);
        if (v6)
        {
          if (v1 != v3)
          {
            fflush(v6);
            uint64_t v7 = *((void *)this + 2);
            uint64_t v8 = *(void *)(v7 + 24) + v4;
            *(void *)(v7 + 24) = v8;
            fseek(*(FILE **)(v7 + 8), v8, 0);
          }
        }
        else
        {
          uint64_t v10 = *(void *)(v5 + 16);
          if (!v10 || !(*(unsigned int (**)(uint64_t))(*(void *)v10 + 32))(v10)) {
            jp2_output_box::end_rewrite();
          }
          *(void *)(*((void *)this + 2) + 24) += v4;
        }
      }
      else
      {
        uint64_t v9 = *((void *)this + 3);
        if (!v9) {
          jp2_output_box::end_rewrite();
        }
        if (((*(uint64_t (**)(uint64_t))(*(void *)v9 + 32))(v9) & 1) == 0) {
          jp2_output_box::end_rewrite();
        }
      }
    }
  }
  return v1 >= 0;
}

BOOL jp2_output_box::write(jp2_output_box *this, const unsigned __int8 *__ptr, size_t __nitems)
{
  if (!*((_DWORD *)this + 2) || *((unsigned char *)this + 72)) {
    return 0;
  }
  int v5 = __nitems;
  uint64_t v6 = *((void *)this + 7);
  size_t v7 = __nitems;
  if ((v6 & 0x8000000000000000) == 0)
  {
    uint64_t v8 = *((void *)this + 5);
    uint64_t v9 = v8 + (int)__nitems;
    unsigned int v10 = v6 - v8;
    if (v9 > v6) {
      size_t v7 = v10;
    }
    else {
      size_t v7 = __nitems;
    }
  }
  if ((int)v7 <= 0) {
    return v7 == v5;
  }
  uint64_t v11 = *((void *)this + 6);
  uint64_t v12 = *((void *)this + 5) + v7;
  *((void *)this + 5) = v12;
  if ((v11 & 0x8000000000000000) == 0 && v12 > v11)
  {
    uint64_t v23 = 0;
    memset(v22, 0, sizeof(v22));
    kdu_error::kdu_error((kdu_error *)v22, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v22);
  }
  if (!*((unsigned char *)this + 73))
  {
    uint64_t v16 = *((void *)this + 5);
    uint64_t v17 = *((int *)this + 8);
    if (v16 > v17)
    {
      if ((*((void *)this + 7) & 0x8000000000000000) != 0)
      {
        *((_DWORD *)this + 8) = v16 + v17 + 1024;
        operator new[]();
      }
      jp2_output_box::write();
    }
    memcpy((void *)(*((void *)this + 8) + (int)v16 - (int)v7), __ptr, v7);
    return v7 == v5;
  }
  uint64_t v13 = *((void *)this + 3);
  if (v13)
  {
    int v14 = (*(uint64_t (**)(uint64_t, const unsigned __int8 *, size_t))(*(void *)v13 + 40))(v13, __ptr, v7);
    int v15 = v14 ^ 1;
    *((unsigned char *)this + 72) = v14 ^ 1;
  }
  else
  {
    uint64_t v18 = *((void *)this + 2);
    unsigned int v19 = *(FILE **)(v18 + 8);
    if (v19)
    {
      int v15 = fwrite(__ptr, 1uLL, v7, v19) != v7;
    }
    else
    {
      uint64_t v21 = *(void *)(v18 + 16);
      if (!v21) {
        jp2_output_box::write();
      }
      int v15 = (*(uint64_t (**)(uint64_t, const unsigned __int8 *, size_t))(*(void *)v21 + 40))(v21, __ptr, v7) ^ 1;
    }
    *((unsigned char *)this + 72) = v15;
    *(void *)(*((void *)this + 2) + 24) += v7;
  }
  if (v7 != v5) {
    return 0;
  }
  return v15 == 0;
}

void sub_18867A650(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867A65C()
{
  _Unwind_Resume(v0);
}

void j2_dimensions::copy(j2_dimensions *this, j2_dimensions *a2)
{
  uint64_t v2 = this;
  jp2_dimensions::init((uint64_t *)&v2, *(void *)a2, *((_DWORD *)a2 + 5), *((unsigned char *)a2 + 24), *((_DWORD *)a2 + 2));
}

void jp2_dimensions::init(uint64_t *a1, uint64_t a2, int a3, unsigned __int8 a4, int a5)
{
  if (*a1)
  {
    if (*(_DWORD *)(*a1 + 20))
    {
      uint64_t v7 = 0;
      memset(v6, 0, sizeof(v6));
      kdu_error::kdu_error((kdu_error *)v6, "Error in Kakadu File Format Support:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v6[0] + 16))(v6, "JP2 dimensions may be initialized only once!");
      kdu_error::~kdu_error((kdu_error *)v6);
    }
    if (a3 > 0)
    {
      *(void *)*a1 = a2;
      uint64_t v5 = *a1;
      *(_DWORD *)(v5 + 20) = a3;
      *(_WORD *)(v5 + 24) = a4;
      *(_DWORD *)(v5 + 8) = a5;
      *(_DWORD *)(v5 + 12) = 2;
      *(unsigned char *)(v5 + 16) = 1;
      operator new[]();
    }
    jp2_dimensions::init();
  }
  jp2_dimensions::init();
}

void sub_18867A80C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867A818()
{
  _Unwind_Resume(v0);
}

void j2_dimensions::init(j2_dimensions *this, jp2_input_box *a2)
{
  if (*((_DWORD *)this + 5))
  {
    uint64_t v12 = 0;
    long long v10 = 0u;
    long long v11 = 0u;
    kdu_error::kdu_error((kdu_error *)&v10, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v10);
  }
  if (*((_DWORD *)a2 + 12) == 1768449138)
  {
    *(void *)uint64_t v9 = 0;
    unsigned __int16 v8 = 0;
    __int16 v7 = 0;
    __int16 v6 = 0;
    if (!jp2_input_box::read(a2, &v9[1])
      || !jp2_input_box::read(a2, v9)
      || !jp2_input_box::read(a2, &v8)
      || (*(unsigned int (**)(jp2_input_box *, char *, uint64_t))(*(void *)a2 + 32))(a2, (char *)&v7 + 1, 1) != 1|| (*(unsigned int (**)(jp2_input_box *, __int16 *, uint64_t))(*(void *)a2 + 32))(a2, &v7, 1) != 1|| (*(unsigned int (**)(jp2_input_box *, char *, uint64_t))(*(void *)a2 + 32))(a2, (char *)&v6 + 1, 1) != 1|| (*(unsigned int (**)(jp2_input_box *, __int16 *, uint64_t))(*(void *)a2 + 32))(a2, &v6, 1) != 1)
    {
      uint64_t v12 = 0;
      long long v10 = 0u;
      long long v11 = 0u;
      kdu_error::kdu_error((kdu_error *)&v10, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v10 + 16))(&v10, "Malformed image header box (ihdr) found in JP2-family data source.  Not all fields were present.");
      kdu_error::~kdu_error((kdu_error *)&v10);
    }
    if (((*(uint64_t (**)(jp2_input_box *))(*(void *)a2 + 16))(a2) & 1) == 0)
    {
      uint64_t v12 = 0;
      long long v10 = 0u;
      long long v11 = 0u;
      kdu_error::kdu_error((kdu_error *)&v10, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v10 + 16))(&v10, "Malformed image header box (ihdr) found in JP2-family data source.  The box appears to be too long.");
      kdu_error::~kdu_error((kdu_error *)&v10);
    }
    int v4 = v8;
    if ((v8 - 1) >> 14
      || v7 > 9u
      || HIBYTE(v6) > 1u
      || v6 > 1u
      || HIBYTE(v7) != 255 && (HIBYTE(v7) & 0x7Eu) >= 0x26)
    {
      uint64_t v12 = 0;
      long long v10 = 0u;
      long long v11 = 0u;
      kdu_error::kdu_error((kdu_error *)&v10, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v10 + 16))(&v10, "Malformed image header box (ihdr) found in JP2-family data source.  The box contains fields which do not conform to their legal range.");
      kdu_error::~kdu_error((kdu_error *)&v10);
    }
    unsigned int v5 = v9[0];
    if ((v9[1] & 0x80000000) == 0 && (v9[0] & 0x80000000) == 0)
    {
      *(_DWORD *)this = v9[1];
      *((_DWORD *)this + 1) = v5;
      *((_DWORD *)this + 5) = v4;
      *((unsigned char *)this + 24) = HIBYTE(v6) != 0;
      *((unsigned char *)this + 25) = (_BYTE)v6 != 0;
      *((_DWORD *)this + 2) = v7;
      operator new[]();
    }
    uint64_t v12 = 0;
    long long v10 = 0u;
    long long v11 = 0u;
    kdu_error::kdu_error((kdu_error *)&v10, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v10 + 16))(&v10, "Sorry: Cannot process JP2-family data sources whose image header box contains height or width values larger than 2^{31}-1.");
    kdu_error::~kdu_error((kdu_error *)&v10);
  }
  j2_dimensions::init();
}

void sub_18867ACB8(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18867ACC4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

uint64_t j2_dimensions::process_bpcc_box(j2_dimensions *this, jp2_input_box *a2)
{
  unsigned __int8 v12 = 0;
  if (*((int *)this + 5) >= 1)
  {
    uint64_t v4 = 0;
    while ((*(unsigned int (**)(jp2_input_box *, unsigned __int8 *, uint64_t))(*(void *)a2 + 32))(a2, &v12, 1) == 1)
    {
      unsigned int v5 = v12 & 0x7F;
      if (v5 >= 0x26)
      {
        uint64_t v11 = 0;
        long long v9 = 0u;
        long long v10 = 0u;
        kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
        (*(void (**)(long long *, const char *))(v9 + 16))(&v9, "Malformed bits per component (bpcc) box found in JP2-family data source.  The box contains an illegal bit-depth specifier.  Bit depths may not exceed 38 bits per sample.");
        goto LABEL_7;
      }
      int v6 = ~v5;
      if ((v12 & 0x80u) == 0) {
        int v7 = v12 + 1;
      }
      else {
        int v7 = v6;
      }
      *(_DWORD *)(*((void *)this + 4) + 4 * v4++) = v7;
      if (v4 >= *((int *)this + 5)) {
        goto LABEL_12;
      }
    }
    uint64_t v11 = 0;
    long long v9 = 0u;
    long long v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v9 + 16))(&v9, "Malformed bits per component (bpcc) box found in JP2-family data source.  The box contains insufficient bit-depth specifiers.");
LABEL_7:
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
LABEL_12:
  uint64_t result = (*(uint64_t (**)(jp2_input_box *))(*(void *)a2 + 16))(a2);
  if ((result & 1) == 0)
  {
    uint64_t v11 = 0;
    long long v9 = 0u;
    long long v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v9 + 16))(&v9, "Malformed bits per component (bpcc) box found in JP2-family data source.  The box appears to be too long.");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  return result;
}

void sub_18867AF10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867AF1C()
{
  _Unwind_Resume(v0);
}

uint64_t j2_dimensions::finalize(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 20);
  if (v1 < 1) {
    goto LABEL_7;
  }
  uint64_t v2 = *(int **)(this + 32);
  uint64_t v3 = *(unsigned int *)(this + 20);
  do
  {
    int v5 = *v2++;
    int v4 = v5;
    if (!v5 || (v4 - 39) < 0xFFFFFFB3) {
      goto LABEL_7;
    }
    --v3;
  }
  while (v3);
  if ((v1 - 16385) <= 0xFFFFBFFF)
  {
LABEL_7:
    uint64_t v8 = 0;
    long long v6 = 0u;
    long long v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  if (*(_DWORD *)(this + 8) >= 0xAu)
  {
    uint64_t v8 = 0;
    long long v6 = 0u;
    long long v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  return this;
}

void sub_18867B06C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867B078()
{
  _Unwind_Resume(v0);
}

uint64_t j2_dimensions::save_boxes(j2_dimensions *this, jp2_output_box *a2)
{
  j2_dimensions::finalize((uint64_t)this);
  uint64_t v4 = *((unsigned int *)this + 5);
  if ((int)v4 < 2) {
    goto LABEL_7;
  }
  char v5 = 0;
  long long v6 = (int *)*((void *)this + 4);
  int v9 = *v6;
  long long v7 = v6 + 1;
  int v8 = v9;
  uint64_t v10 = v4 - 1;
  do
  {
    int v11 = *v7++;
    if (v11 != v8) {
      char v5 = -1;
    }
    --v10;
  }
  while (v10);
  if (!v5)
  {
LABEL_7:
    int v12 = **((_DWORD **)this + 4);
    if (v12 <= 0) {
      char v5 = ~(_BYTE)v12 | 0x80;
    }
    else {
      char v5 = v12 - 1;
    }
  }
  long long v24 = 0uLL;
  uint64_t v28 = 0;
  uint64_t v23 = (void (**)(void **, void **, uint64_t))&unk_1ED4E3098;
  long long v25 = 0uLL;
  long long v26 = 0uLL;
  long long v27 = 0xFFFFFFFFFFFFFFFFLL;
  jp2_output_box::open((uint64_t)&v23, a2, 1768449138, 0);
  LODWORD(v17) = bswap32(*(_DWORD *)this);
  v23[5]((void **)&v23, (void **)&v17, 4);
  LODWORD(v17) = bswap32(*((_DWORD *)this + 1));
  v23[5]((void **)&v23, (void **)&v17, 4);
  LOWORD(v17) = bswap32(*((unsigned __int16 *)this + 10)) >> 16;
  v23[5]((void **)&v23, (void **)&v17, 2);
  LOBYTE(v17) = v5;
  v23[5]((void **)&v23, (void **)&v17, 1);
  LOBYTE(v17) = *((_DWORD *)this + 2);
  v23[5]((void **)&v23, (void **)&v17, 1);
  LOBYTE(v17) = *((unsigned char *)this + 24);
  v23[5]((void **)&v23, (void **)&v17, 1);
  LOBYTE(v17) = *((unsigned char *)this + 25);
  v23[5]((void **)&v23, (void **)&v17, 1);
  jp2_output_box::close((jp2_output_box *)&v23);
  if (v5 == -1)
  {
    long long v18 = 0uLL;
    uint64_t v22 = 0;
    uint64_t v17 = (void (**)(void **, unsigned char *, uint64_t))&unk_1ED4E3098;
    long long v19 = 0uLL;
    long long v20 = 0uLL;
    long long v21 = 0xFFFFFFFFFFFFFFFFLL;
    jp2_output_box::open((uint64_t)&v17, a2, 1651532643, 0);
    if (*((int *)this + 5) >= 1)
    {
      uint64_t v13 = 0;
      do
      {
        int v14 = *(_DWORD *)(*((void *)this + 4) + 4 * v13);
        if (v14 <= 0) {
          char v15 = ~(_BYTE)v14 | 0x80;
        }
        else {
          char v15 = v14 - 1;
        }
        char v29 = v15;
        v17[5]((void **)&v17, &v29, 1);
        ++v13;
      }
      while (v13 < *((int *)this + 5));
    }
    jp2_output_box::close((jp2_output_box *)&v17);
    uint64_t v17 = (void (**)(void **, unsigned char *, uint64_t))&unk_1ED4E3098;
    if (*((void *)&v21 + 1)) {
      MEMORY[0x18C11C0C0](*((void *)&v21 + 1), 0x1000C8077774924);
    }
  }
  uint64_t v23 = (void (**)(void **, void **, uint64_t))&unk_1ED4E3098;
  uint64_t result = *((void *)&v27 + 1);
  if (*((void *)&v27 + 1)) {
    return MEMORY[0x18C11C0C0](*((void *)&v27 + 1), 0x1000C8077774924);
  }
  return result;
}

void sub_18867B458(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  jp2_output_box::~jp2_output_box((jp2_output_box *)va);
  jp2_output_box::~jp2_output_box((jp2_output_box *)va1);
  _Unwind_Resume(a1);
}

void jp2_dimensions::init(jp2_dimensions *this, siz_params *a2, unsigned __int8 a3)
{
  *(void *)uint64_t v9 = 0;
  *(void *)uint64_t v10 = 0;
  int v8 = 0;
  if (kdu_params::get(a2, "Ssize", 0, 0, v10, 1, 1, 1)
    && kdu_params::get(a2, "Ssize", 0, 1, &v10[1], 1, 1, 1)
    && kdu_params::get(a2, "Sorigin", 0, 0, v9, 1, 1, 1)
    && kdu_params::get(a2, "Sorigin", 0, 1, &v9[1], 1, 1, 1)
    && (kdu_params::get(a2, "Scomponents", 0, 0, &v8, 1, 1, 1) & 1) != 0)
  {
    *(int32x2_t *)uint64_t v10 = vsub_s32(*(int32x2_t *)v10, *(int32x2_t *)v9);
    jp2_dimensions::init((uint64_t *)this, *(uint64_t *)v10, v8, a3, 7);
  }
  uint64_t v7 = 0;
  memset(v6, 0, sizeof(v6));
  kdu_error::kdu_error((kdu_error *)v6, "Error in Kakadu File Format Support:\n");
  kdu_error::~kdu_error((kdu_error *)v6);
}

void sub_18867B74C(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18867B758(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

uint64_t *jp2_dimensions::set_precision(uint64_t *this, unsigned int a2, int a3, int a4)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v4 = *this) == 0 || *(_DWORD *)(v4 + 20) <= (signed int)a2) {
    jp2_dimensions::set_precision();
  }
  if (a4) {
    int v5 = -a3;
  }
  else {
    int v5 = a3;
  }
  *(_DWORD *)(*(void *)(v4 + 32) + 4 * a2) = v5;
  return this;
}

uint64_t jp2_dimensions::finalize_compatibility(uint64_t this, kdu_params *a2)
{
  if (a2)
  {
    uint64_t v2 = this;
    if (*(_DWORD *)(*(void *)this + 8) == 7)
    {
      this = kdu_params::access_cluster(a2, "SIZ");
      if (this)
      {
        uint64_t v4 = (kdu_params *)this;
        this = kdu_params::get((kdu_params *)this, "Sprofile", 0, 0, (int *)(*(void *)v2 + 12), 1, 1, 1);
        if (*(_DWORD *)(*(void *)v2 + 12) == 3)
        {
          int v16 = 0;
          this = kdu_params::get(v4, "Sextensions", 0, 0, &v16, 1, 1, 1);
          __int16 v5 = v16;
          if ((v16 & 0xFFFFFCFF) != 0) {
            *(unsigned char *)(*(void *)v2 + 16) = 0;
          }
          if ((v5 & 0x100) != 0)
          {
            if (*(unsigned char *)(*(void *)v2 + 16))
            {
              int v14 = 1;
              int v15 = 1;
              kdu_params::get(v4, "Stiles", 0, 0, &v14, 1, 1, 1);
              kdu_params::get(v4, "Stiles", 0, 1, &v15, 1, 1, 1);
              int v6 = v15 * v14;
              uint64_t v7 = (kdu_params *)kdu_params::access_cluster(a2, "MCO");
              this = kdu_params::access_cluster(a2, "MCC");
              if ((v6 & 0x80000000) == 0)
              {
                int v8 = (kdu_params *)this;
                int v9 = -1;
                while (1)
                {
                  int v13 = 0;
                  if (v7)
                  {
                    this = kdu_params::access_relation(v7, v9, -1, 0, 0);
                    if (this)
                    {
                      this = kdu_params::get((kdu_params *)this, "Mnum_stages", 0, 0, &v13, 1, 1, 1);
                      if (this)
                      {
                        if (v13 != 1) {
                          break;
                        }
                      }
                    }
                  }
                  if (v8)
                  {
                    this = kdu_params::access_relation(v8, v9, -1, 0, 0);
                    if (this)
                    {
                      uint64_t v10 = (kdu_params *)this;
                      do
                      {
                        int v12 = 0;
                        this = kdu_params::get(v10, "Mstage_xforms", 0, 0, &v12, 1, 1, 1);
                        if (this)
                        {
                          if (v12 != 1) {
                            goto LABEL_25;
                          }
                          this = kdu_params::get(v10, "Mstage_xforms", 1, 0, &v12, 1, 1, 1);
                          if (this) {
                            goto LABEL_25;
                          }
                          int v11 = 1;
                          this = kdu_params::get(v10, "Mstage_xforms", 0, 3, &v11, 1, 1, 1);
                          if (v11) {
                            goto LABEL_25;
                          }
                        }
                        uint64_t v10 = (kdu_params *)*((void *)v10 + 11);
                      }
                      while (v10);
                    }
                  }
                  if (++v9 == v6) {
                    return this;
                  }
                }
LABEL_25:
                *(unsigned char *)(*(void *)v2 + 16) = 0;
              }
            }
          }
        }
      }
    }
  }
  return this;
}

uint64_t jp2_dimensions::get_size(jp2_dimensions *this)
{
  if (!*(void *)this) {
    jp2_dimensions::get_size();
  }
  return **(void **)this;
}

uint64_t jp2_dimensions::get_bit_depth(jp2_dimensions *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v2 = *(void *)this) == 0 || *(_DWORD *)(v2 + 20) <= (signed int)a2) {
    jp2_dimensions::get_bit_depth();
  }
  int v3 = *(_DWORD *)(*(void *)(v2 + 32) + 4 * a2);
  if (v3 >= 0) {
    return v3;
  }
  else {
    return -v3;
  }
}

uint64_t jp2_dimensions::get_signed(jp2_dimensions *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v2 = *(void *)this) == 0 || *(_DWORD *)(v2 + 20) <= (signed int)a2) {
    jp2_dimensions::get_signed();
  }
  return *(_DWORD *)(*(void *)(v2 + 32) + 4 * a2) >> 31;
}

void j2_palette::copy(j2_palette *this, j2_palette *a2)
{
  if (!*((void *)this + 2) && !*((void *)this + 3))
  {
    *(unsigned char *)this = *(unsigned char *)a2;
    *(void *)((char *)this + 4) = *(void *)((char *)a2 + 4);
    operator new[]();
  }
  uint64_t v3 = 0;
  memset(v2, 0, sizeof(v2));
  kdu_error::kdu_error((kdu_error *)v2, "Error in Kakadu File Format Support:\n");
  kdu_error::~kdu_error((kdu_error *)v2);
}

void sub_18867BC94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867BCA0()
{
  _Unwind_Resume(v0);
}

void j2_palette::init(j2_palette *this, jp2_input_box *a2)
{
  if (*((_DWORD *)this + 1))
  {
    uint64_t v11 = 0;
    long long v9 = 0u;
    long long v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  *(unsigned char *)this = 1;
  if (*((_DWORD *)a2 + 12) == 1885564018)
  {
    unsigned __int16 v8 = 0;
    unsigned __int8 v7 = 0;
    if (jp2_input_box::read(a2, &v8))
    {
      int v4 = (*(uint64_t (**)(jp2_input_box *, unsigned __int8 *, uint64_t))(*(void *)a2 + 32))(a2, &v7, 1);
      int v5 = v8;
      BOOL v6 = v4 != 1 || v8 == 0;
      if (!v6 && v8 <= 0x400u)
      {
        if (v7)
        {
          *((_DWORD *)this + 1) = v7;
          *((_DWORD *)this + 2) = v5;
          operator new[]();
        }
      }
    }
    uint64_t v11 = 0;
    long long v9 = 0u;
    long long v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v9 + 16))(&v9, "Malformed palette (pclr) box found in JP2-family data source.  Insufficient or illegal fields encountered.");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  j2_palette::init();
}

void sub_18867C258(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18867C264(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

uint64_t j2_palette::finalize(uint64_t this)
{
  int v1 = *(_DWORD *)(this + 4);
  if (v1)
  {
    if (v1 < 1) {
      goto LABEL_9;
    }
    uint64_t v2 = *(int **)(this + 16);
    uint64_t v3 = *(unsigned int *)(this + 4);
    do
    {
      int v5 = *v2++;
      int v4 = v5;
      if (!v5 || (v4 - 33) < 0xFFFFFFBF) {
        goto LABEL_9;
      }
      --v3;
    }
    while (v3);
    if ((v1 - 256) < 0xFFFFFF01 || (*(_DWORD *)(this + 8) - 1025) <= 0xFFFFFBFF)
    {
LABEL_9:
      uint64_t v7 = 0;
      memset(v6, 0, sizeof(v6));
      kdu_error::kdu_error((kdu_error *)v6, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)v6);
    }
  }
  return this;
}

void sub_18867C38C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867C398()
{
  _Unwind_Resume(v0);
}

uint64_t j2_palette::save_box(uint64_t this, jp2_output_box *a2)
{
  if (*(_DWORD *)(this + 4))
  {
    uint64_t v3 = this;
    j2_palette::finalize(this);
    long long v17 = 0uLL;
    uint64_t v21 = 0;
    int v16 = (void (**)(void **, unsigned __int8 *, uint64_t))&unk_1ED4E3098;
    long long v18 = 0uLL;
    long long v19 = 0uLL;
    long long v20 = 0xFFFFFFFFFFFFFFFFLL;
    jp2_output_box::open((uint64_t)&v16, a2, 1885564018, 0);
    *(_WORD *)unsigned __int8 __ptr = bswap32(*(unsigned __int16 *)(v3 + 8)) >> 16;
    v16[5]((void **)&v16, __ptr, 2);
    __ptr[0] = *(_DWORD *)(v3 + 4);
    v16[5]((void **)&v16, __ptr, 1);
    LODWORD(v4) = *(_DWORD *)(v3 + 4);
    if ((int)v4 >= 1)
    {
      uint64_t v5 = 0;
      do
      {
        int v6 = *(_DWORD *)(*(void *)(v3 + 16) + 4 * v5);
        if (v6 <= 0) {
          unsigned __int8 v7 = ~(_BYTE)v6 | 0x80;
        }
        else {
          unsigned __int8 v7 = v6 - 1;
        }
        __ptr[0] = v7;
        v16[5]((void **)&v16, __ptr, 1);
        ++v5;
        uint64_t v4 = *(int *)(v3 + 4);
      }
      while (v5 < v4);
    }
    int v8 = *(_DWORD *)(v3 + 8);
    if (v8 >= 1)
    {
      for (uint64_t i = 0; i < v8; ++i)
      {
        *(_DWORD *)unsigned __int8 __ptr = 0;
        if ((int)v4 >= 1)
        {
          uint64_t v10 = 0;
          do
          {
            int v11 = *(_DWORD *)(*(void *)(v3 + 16) + 4 * v10);
            if (v11 >= 0) {
              unsigned int v12 = *(_DWORD *)(*(void *)(v3 + 16) + 4 * v10);
            }
            else {
              unsigned int v12 = -v11;
            }
            if (v12 - 33 <= 0xFFFFFFDF) {
              __assert_rtn("save_box", "jp2.cpp", 2583, "(entry_bytes > 0) && (entry_bytes <= 4)");
            }
            size_t v13 = (v12 + 7) >> 3;
            unsigned int v14 = ((v11 | 0x7FFFFFFFu) + *(_DWORD *)(*(void *)(*(void *)(v3 + 24) + 8 * v10) + 4 * i) + 1) >> -(char)v12;
            __ptr[v13 - 1] = v14;
            if (v12 >= 9)
            {
              __ptr[(v13 - 2)] = BYTE1(v14);
              if (v12 >= 0x11)
              {
                __ptr[(v13 - 3)] = BYTE2(v14);
                if (v12 >= 0x19) {
                  __ptr[(v13 - 4)] = HIBYTE(v14);
                }
              }
            }
            jp2_output_box::write((jp2_output_box *)&v16, __ptr, v13);
            ++v10;
            uint64_t v4 = *(int *)(v3 + 4);
          }
          while (v10 < v4);
          int v8 = *(_DWORD *)(v3 + 8);
        }
      }
    }
    jp2_output_box::close((jp2_output_box *)&v16);
    int v16 = (void (**)(void **, unsigned __int8 *, uint64_t))&unk_1ED4E3098;
    this = *((void *)&v20 + 1);
    if (*((void *)&v20 + 1)) {
      return MEMORY[0x18C11C0C0](*((void *)&v20 + 1), 0x1000C8077774924);
    }
  }
  return this;
}

void sub_18867C668(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a19) {
    MEMORY[0x18C11C0C0](a19, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

uint64_t jp2_palette::get_num_entries(jp2_palette *this)
{
  if (!*(void *)this) {
    jp2_palette::get_num_entries();
  }
  return *(unsigned int *)(*(void *)this + 8);
}

uint64_t jp2_palette::get_num_luts(jp2_palette *this)
{
  if (!*(void *)this) {
    jp2_palette::get_num_luts();
  }
  return *(unsigned int *)(*(void *)this + 4);
}

uint64_t jp2_palette::get_bit_depth(jp2_palette *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v2 = *(void *)this) == 0 || *(_DWORD *)(v2 + 4) <= (signed int)a2) {
    jp2_palette::get_bit_depth();
  }
  int v3 = *(_DWORD *)(*(void *)(v2 + 16) + 4 * a2);
  if (v3 >= 0) {
    return v3;
  }
  else {
    return -v3;
  }
}

uint64_t jp2_palette::get_signed(jp2_palette *this, unsigned int a2)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v2 = *(void *)this) == 0 || *(_DWORD *)(v2 + 4) <= (signed int)a2) {
    jp2_palette::get_signed();
  }
  return *(_DWORD *)(*(void *)(v2 + 16) + 4 * a2) >> 31;
}

uint64_t *jp2_palette::get_lut(uint64_t *result, unsigned int a2, uint64_t a3)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v3 = *result) == 0 || *(_DWORD *)(v3 + 4) <= (signed int)a2) {
    jp2_palette::get_lut();
  }
  if (*(int *)(v3 + 8) >= 1)
  {
    uint64_t v4 = 0;
    uint64_t v5 = *(void *)(*(void *)(v3 + 24) + 8 * a2);
    do
    {
      *(_WORD *)(a3 + 2 * v4) = (*(_DWORD *)(v5 + 4 * v4) + 0x40000) >> 19;
      ++v4;
    }
    while (v4 < *(int *)(*result + 8));
  }
  return result;
}

void j2_component_map::copy(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a1 + 8) && !*(void *)(a1 + 16) && !*(void *)(a1 + 32))
  {
    *(unsigned char *)a1 = *(unsigned char *)a2;
    int v2 = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a1 + 24) = v2;
    *(_DWORD *)(a1 + 28) = v2;
    operator new[]();
  }
  uint64_t v4 = 0;
  memset(v3, 0, sizeof(v3));
  kdu_error::kdu_error((kdu_error *)v3, "Error in Kakadu File Format Support:\n");
  kdu_error::~kdu_error((kdu_error *)v3);
}

void sub_18867C8E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867C8F0()
{
  _Unwind_Resume(v0);
}

void j2_component_map::init(j2_component_map *this, jp2_input_box *a2)
{
  if (*((_DWORD *)a2 + 12) == 1668112752)
  {
    *(unsigned char *)this = 1;
    if (*((void *)this + 4) || *((_DWORD *)this + 7))
    {
      uint64_t v6 = 0;
      long long v4 = 0u;
      long long v5 = 0u;
      kdu_error::kdu_error((kdu_error *)&v4, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)&v4);
    }
    if (*((unsigned char *)a2 + 125)
      || ((int v2 = *((_DWORD *)a2 + 44) + *((_DWORD *)a2 + 22) - *((_DWORD *)a2 + 34)) != 0
        ? (BOOL v3 = (v2 & 3) == 0)
        : (BOOL v3 = 0),
          !v3))
    {
      uint64_t v6 = 0;
      long long v4 = 0u;
      long long v5 = 0u;
      kdu_error::kdu_error((kdu_error *)&v4, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v4 + 16))(&v4, "Malformed component mapping (cmap) box encountered in JP2-family data source.  The body of any such box must contain exactly four bytes for each cmap-channel and there must be at least one cmap-channel.");
      kdu_error::~kdu_error((kdu_error *)&v4);
    }
    *((_DWORD *)this + 7) = v2 >> 2;
    if (v2 <= 3)
    {
      uint64_t v6 = 0;
      long long v4 = 0u;
      long long v5 = 0u;
      kdu_error::kdu_error((kdu_error *)&v4, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v4 + 16))(&v4, "Malformed component mapping (cmap) box encountered in JP2-family data source.  The body of the box does not appear to contain any channel mappings.");
      kdu_error::~kdu_error((kdu_error *)&v4);
    }
    *((_DWORD *)this + 6) = v2 >> 2;
    operator new[]();
  }
  j2_component_map::init();
}

void sub_18867CC54(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18867CC60(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

void j2_component_map::init_missing_cmap(uint64_t a1, uint64_t a2)
{
  if (!*(void *)(a1 + 32) && !*(_DWORD *)(a1 + 28))
  {
    int v2 = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a1 + 24) = v2;
    *(_DWORD *)(a1 + 28) = v2;
    operator new[]();
  }
  j2_component_map::init_missing_cmap();
}

unsigned char *j2_component_map::save_box(unsigned char *this, jp2_output_box *a2, int a3)
{
  if (*this) {
    BOOL v3 = 0;
  }
  else {
    BOOL v3 = a3 == 0;
  }
  if (!v3)
  {
    long long v4 = this;
    long long v8 = 0uLL;
    uint64_t v12 = 0;
    unsigned __int8 v7 = (void (**)(void **, _WORD *, uint64_t))&unk_1ED4E3098;
    long long v9 = 0uLL;
    long long v10 = 0uLL;
    long long v11 = 0xFFFFFFFFFFFFFFFFLL;
    jp2_output_box::open((uint64_t)&v7, a2, 1668112752, 0);
    if (*((int *)v4 + 7) >= 1)
    {
      uint64_t v5 = 0;
      uint64_t v6 = 0;
      do
      {
        __int16 v13 = bswap32(*(unsigned __int16 *)(*((void *)v4 + 4) + v5)) >> 16;
        v7[5]((void **)&v7, &v13, 2);
        if ((*(_DWORD *)(*((void *)v4 + 4) + v5 + 4) & 0x80000000) != 0)
        {
          __int16 v13 = 0;
          v7[5]((void **)&v7, &v13, 2);
        }
        else
        {
          LOBYTE(v13) = 1;
          v7[5]((void **)&v7, &v13, 1);
          LOBYTE(v13) = *(_DWORD *)(*((void *)v4 + 4) + v5 + 4);
          v7[5]((void **)&v7, &v13, 1);
        }
        ++v6;
        v5 += 16;
      }
      while (v6 < *((int *)v4 + 7));
    }
    jp2_output_box::close((jp2_output_box *)&v7);
    unsigned __int8 v7 = (void (**)(void **, _WORD *, uint64_t))&unk_1ED4E3098;
    this = (unsigned char *)*((void *)&v11 + 1);
    if (*((void *)&v11 + 1)) {
      return (unsigned char *)MEMORY[0x18C11C0C0](*((void *)&v11 + 1), 0x1000C8077774924);
    }
  }
  return this;
}

void sub_18867CF2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  jp2_output_box::~jp2_output_box((jp2_output_box *)va);
  _Unwind_Resume(a1);
}

uint64_t j2_component_map::finalize(uint64_t this, j2_dimensions *a2, j2_palette *a3)
{
  *(void *)(this + 8) = a2;
  BOOL v3 = (jp2_dimensions *)(this + 8);
  *(void *)(this + 16) = a3;
  long long v4 = (jp2_palette *)(this + 16);
  if (!a2) {
    j2_component_map::finalize();
  }
  if (!a3) {
    jp2_palette::get_num_luts();
  }
  uint64_t v5 = this;
  int v6 = *((_DWORD *)a2 + 5);
  int v7 = *((_DWORD *)a3 + 1);
  if (v7 < 1)
  {
    if (*(unsigned char *)this)
    {
      uint64_t v17 = 0;
      long long v15 = 0u;
      long long v16 = 0u;
      kdu_error::kdu_error((kdu_error *)&v15, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v15 + 16))(&v15, "JP2-family data source appears to contain a Component Mapping (cmap) box without any matching Palette (pclr) box.  Palette and Component Mapping boxes must be in one-to-one correspondence.");
      kdu_error::~kdu_error((kdu_error *)&v15);
    }
    if (!*(_DWORD *)(this + 28))
    {
      *(_DWORD *)(this + 24) = v6;
      *(_DWORD *)(this + 28) = v6;
      uint64_t v14 = *(void *)(this + 32);
      if (v14) {
        MEMORY[0x18C11C0C0](v14, 0x1000C808B6DE1C6);
      }
      operator new[]();
    }
    j2_component_map::finalize();
  }
  *(unsigned char *)this = 1;
  if (*(int *)(this + 28) >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = 0;
    do
    {
      uint64_t v10 = *(void *)(v5 + 32);
      int v11 = *(_DWORD *)(v10 + v8);
      if (v11 < 0 || v11 >= v6 || (signed int v12 = *(_DWORD *)(v10 + v8 + 4), v12 >= v7))
      {
        uint64_t v17 = 0;
        long long v15 = 0u;
        long long v16 = 0u;
        kdu_error::kdu_error((kdu_error *)&v15, "Error in Kakadu File Format Support:\n");
        (*(void (**)(long long *, const char *))(v15 + 16))(&v15, "JP2-family data source appears to contain an illegal Component Mapping (cmap) box, one of whose channels refers to a non-existent image component or palette lookup table.");
        kdu_error::~kdu_error((kdu_error *)&v15);
      }
      uint64_t v13 = v10 + v8;
      if (v12 < 0)
      {
        *(_DWORD *)(v13 + 8) = jp2_dimensions::get_bit_depth(v3, *(_DWORD *)(v10 + v8));
        this = jp2_dimensions::get_signed(v3, *(_DWORD *)(v10 + v8));
      }
      else
      {
        *(_DWORD *)(v13 + 8) = jp2_palette::get_bit_depth(v4, v12);
        this = jp2_palette::get_signed(v4, *(_DWORD *)(v13 + 4));
      }
      *(unsigned char *)(v10 + v8 + 12) = this;
      ++v9;
      v8 += 16;
    }
    while (v9 < *(int *)(v5 + 28));
  }
  return this;
}

void sub_18867D1D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867D1E0()
{
  _Unwind_Resume(v0);
}

uint64_t j2_component_map::add_cmap_channel(j2_component_map *this, signed int a2, signed int a3)
{
  long long v4 = (j2_component_map *)((char *)this + 8);
  uint64_t v3 = *((void *)this + 1);
  if (!v3 || (v7 = (j2_component_map *)((char *)this + 16), (uint64_t v6 = *((void *)this + 2)) == 0)) {
    j2_component_map::add_cmap_channel();
  }
  if (a3 < 0) {
    int v8 = -1;
  }
  else {
    int v8 = a3;
  }
  uint64_t v9 = *((unsigned int *)this + 7);
  if ((int)v9 < 1)
  {
LABEL_11:
    if (a2 < 0 || *(_DWORD *)(v3 + 20) <= a2 || v8 >= *(_DWORD *)(v6 + 4))
    {
      uint64_t v21 = 0;
      memset(v20, 0, sizeof(v20));
      kdu_error::kdu_error((kdu_error *)v20, "Error in Kakadu File Format Support:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v20[0] + 16))(v20, "Attempting to create a Component Mapping (cmap) box, one of whose channels refers to a non-existent image component or palette lookup table.");
      kdu_error::~kdu_error((kdu_error *)v20);
    }
    if (!*(unsigned char *)this) {
      j2_component_map::add_cmap_channel();
    }
    long long v19 = v4;
    int v13 = *((_DWORD *)this + 6);
    int v12 = *((_DWORD *)this + 7);
    if (v12 >= v13)
    {
      *((_DWORD *)this + 6) = v12 + v13 + 3;
      operator new[]();
    }
    uint64_t v14 = *((void *)this + 4);
    uint64_t v15 = v12;
    long long v16 = (unsigned int *)(v14 + 16 * v12);
    *((_DWORD *)this + 7) = v12 + 1;
    unsigned int *v16 = a2;
    uint64_t v17 = v16 + 2;
    v16[1] = v8;
    if (a3 < 0)
    {
      _DWORD *v17 = jp2_dimensions::get_bit_depth(v19, a2);
      char v18 = jp2_dimensions::get_signed(v19, *v16);
    }
    else
    {
      _DWORD *v17 = jp2_palette::get_bit_depth(v7, a3);
      char v18 = jp2_palette::get_signed(v7, v16[1]);
    }
    *(unsigned char *)(v14 + 16 * v15 + 12) = v18;
    return (*((_DWORD *)this + 7) - 1);
  }
  else
  {
    uint64_t result = 0;
    int v11 = (_DWORD *)(*((void *)this + 4) + 4);
    while (*(v11 - 1) != a2 || *v11 != v8)
    {
      v11 += 4;
      if (v9 == ++result) {
        goto LABEL_11;
      }
    }
  }
  return result;
}

void sub_18867D43C(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18867D448()
{
  _Unwind_Resume(v0);
}

void j2_channels::copy(j2_channels *this, j2_channels *a2)
{
  if (!*((void *)this + 1) && !*((void *)this + 4))
  {
    int v2 = *((_DWORD *)a2 + 1);
    *(_DWORD *)this = v2;
    *((_DWORD *)this + 1) = v2;
    operator new[]();
  }
  uint64_t v4 = 0;
  memset(v3, 0, sizeof(v3));
  kdu_error::kdu_error((kdu_error *)v3, "Error in Kakadu File Format Support:\n");
  kdu_error::~kdu_error((kdu_error *)v3);
}

void sub_18867D628(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867D634()
{
  _Unwind_Resume(v0);
}

uint64_t j2_channels::init(j2_channels *this, jp2_input_box *a2)
{
  if (*((void *)this + 1)
    || *((void *)this + 4)
    || *((unsigned char *)this + 17)
    || *((unsigned char *)this + 18)
    || *((unsigned char *)this + 16))
  {
    uint64_t v21 = 0;
    long long v19 = 0u;
    long long v20 = 0u;
    kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v19);
  }
  int v4 = *((_DWORD *)a2 + 12);
  if (v4 == 1869636468)
  {
    LOBYTE(v18) = 0;
    if ((*(unsigned int (**)(jp2_input_box *, unsigned __int16 *, uint64_t))(*(void *)a2 + 32))(a2, &v18, 1) != 1|| v18 >= 3u)
    {
      uint64_t v21 = 0;
      long long v19 = 0u;
      long long v20 = 0u;
      kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v19 + 16))(&v19, "Malformed opacity (opct) box found in JPX data source.  Failed to read valid Otyp field.");
      kdu_error::~kdu_error((kdu_error *)&v19);
    }
    if (v18 == 1)
    {
      *((unsigned char *)this + 18) = 1;
    }
    else
    {
      if ((_BYTE)v18)
      {
        LOBYTE(v17) = 0;
        if ((*(unsigned int (**)(jp2_input_box *, unsigned __int16 *, uint64_t))(*(void *)a2 + 32))(a2, &v17, 1) != 1)
        {
          uint64_t v21 = 0;
          long long v19 = 0u;
          long long v20 = 0u;
          kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
          (*(void (**)(long long *, const char *))(v19 + 16))(&v19, "Malformed opacity (opct) box found in JPX data source.  Failed to read valid Nch field.");
          kdu_error::~kdu_error((kdu_error *)&v19);
        }
        *((unsigned char *)this + 16) = 1;
        int v14 = v17;
        *(_DWORD *)this = v17;
        *((_DWORD *)this + 1) = v14;
        operator new[]();
      }
      *((unsigned char *)this + 17) = 1;
    }
    uint64_t result = (*(uint64_t (**)(jp2_input_box *))(*(void *)a2 + 16))(a2);
    if ((result & 1) == 0)
    {
      uint64_t v21 = 0;
      long long v19 = 0u;
      long long v20 = 0u;
      kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v19 + 16))(&v19, "Malformed opacity (opct) box found in JPX data source.  The box appears to be too long.");
LABEL_49:
      kdu_error::~kdu_error((kdu_error *)&v19);
    }
  }
  else
  {
    if (v4 != 1667523942) {
      j2_channels::init();
    }
    unsigned __int16 v18 = 0;
    BOOL v5 = jp2_input_box::read(a2, &v18);
    unsigned int v15 = v18;
    if (!v5 || !v18)
    {
      uint64_t v21 = 0;
      long long v19 = 0u;
      long long v20 = 0u;
      kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v19 + 16))(&v19, "Malformed channel definition (cdef) box found in JP2-family data source.  Missing or invalid fields.");
      kdu_error::~kdu_error((kdu_error *)&v19);
    }
    unsigned int v6 = 0;
    do
    {
      unsigned __int16 v17 = 0;
      *(_DWORD *)long long v16 = 0;
      if (!jp2_input_box::read(a2, &v17)
        || !jp2_input_box::read(a2, &v16[1])
        || !jp2_input_box::read(a2, v16)
        || (unsigned int v7 = v16[1], (unsigned __int16)(v16[1] + 1) >= 4u))
      {
        uint64_t v21 = 0;
        long long v19 = 0u;
        long long v20 = 0u;
        kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
        (*(void (**)(long long *, const char *))(v19 + 16))(&v19, "Malformed channel definition (cdef) box found in JP2-family data source.  Missing or invalid channel association information.");
        kdu_error::~kdu_error((kdu_error *)&v19);
      }
      int v8 = v16[0];
      if (v16[0] != 0xFFFF && v16[1] <= 2u)
      {
        if (v16[0]) {
          uint64_t v9 = v16[0] - 1;
        }
        else {
          uint64_t v9 = 0;
        }
        if (v9 >= *(_DWORD *)this)
        {
          *(_DWORD *)this += v9 + 3;
          operator new[]();
        }
        if (v9 >= *((_DWORD *)this + 1)) {
          *((_DWORD *)this + 1) = v9 + 1;
        }
        uint64_t v10 = *((void *)this + 1);
        uint64_t v11 = v10 + (v9 << 6);
        if ((*(_DWORD *)(v11 + 4 * v7) & 0x80000000) == 0)
        {
          uint64_t v21 = 0;
          long long v19 = 0u;
          long long v20 = 0u;
          kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
          (*(void (**)(long long *, const char *))(v19 + 16))(&v19, "Malformed channel definition (cdef) box found in JP2-family data source.  The box appears to provide multiple channels with the same Assoc/Typ values.");
          kdu_error::~kdu_error((kdu_error *)&v19);
        }
        *(_DWORD *)(v11 + 4 * v7) = v17;
        if (!v8) {
          *(unsigned char *)(v10 + (v9 << 6) + v7 + 48) = 1;
        }
      }
      ++v6;
    }
    while (v6 < v15);
    uint64_t result = (*(uint64_t (**)(jp2_input_box *))(*(void *)a2 + 16))(a2);
    if ((result & 1) == 0)
    {
      uint64_t v21 = 0;
      long long v19 = 0u;
      long long v20 = 0u;
      kdu_error::kdu_error((kdu_error *)&v19, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v19 + 16))(&v19, "Malformed channel definition (cdef) box found in JP2-family data source.  The box appears to be too long.");
      goto LABEL_49;
    }
  }
  return result;
}

void sub_18867DDF0(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18867DDFC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

unsigned int *j2_channels::finalize(unsigned int *this, unsigned int a2, int a3)
{
  unint64_t v3 = this[1];
  if (a2)
  {
    unint64_t v4 = a2;
    if (v3 > a2)
    {
      uint64_t v28 = 0;
      long long v26 = 0u;
      long long v27 = 0u;
      kdu_error::kdu_error((kdu_error *)&v26, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)&v26);
    }
  }
  else
  {
    unint64_t v4 = this[1];
  }
  if (*((void *)this + 4))
  {
    if (v3 != v4)
    {
      uint64_t v28 = 0;
      long long v26 = 0u;
      long long v27 = 0u;
      kdu_error::kdu_error((kdu_error *)&v26, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v26 + 16))(&v26, "Malformed opacity (opct) box encountered in a JPX file indicates a different number of colour channels to that associated with the specified colour space.");
      kdu_error::~kdu_error((kdu_error *)&v26);
    }
    BOOL v5 = 0;
    if (a3) {
      goto LABEL_39;
    }
  }
  else if (v3 >= v4)
  {
    BOOL v5 = 0;
    unint64_t v4 = this[1];
    if (a3)
    {
LABEL_39:
      if (v4)
      {
        unint64_t v16 = 0;
        uint64_t v17 = 4;
        do
        {
          if (*((unsigned char *)this + 16)
            && ((*(_DWORD *)(*((void *)this + 1) + v17) & 0x80000000) == 0 || (v5[2] & 0x80000000) == 0))
          {
            uint64_t v28 = 0;
            long long v26 = 0u;
            long long v27 = 0u;
            kdu_error::kdu_error((kdu_error *)&v26, "Error in Kakadu File Format Support:\n");
            kdu_error::~kdu_error((kdu_error *)&v26);
          }
          ++v16;
          v17 += 64;
        }
        while (v16 < v4);
      }
      return this;
    }
  }
  else
  {
    if (v4 > *this)
    {
      *this = v4;
      operator new[]();
    }
    if (this[1] || *((unsigned char *)this + 17) || *((unsigned char *)this + 18))
    {
      BOOL v5 = 0;
    }
    else
    {
      BOOL v5 = 0;
      if (!*((unsigned char *)this + 16) && (int)v4 >= 1)
      {
        uint64_t v22 = 0;
        uint64_t v23 = (_DWORD *)*((void *)this + 1);
        long long v24 = v23;
        do
        {
          long long v25 = v24;
          if (a3)
          {
            v24[3] = 0;
            long long v25 = &v23[16 * v22 + 6];
          }
          *long long v25 = v22++;
          v24 += 16;
        }
        while (v4 != v22);
        BOOL v5 = v24 - 16;
      }
    }
    this[1] = v4;
    if (a3) {
      goto LABEL_39;
    }
  }
  if (v4 >= 2)
  {
    uint64_t v6 = *((void *)this + 1);
    unint64_t v7 = 1;
    uint64_t v8 = 64;
    do
    {
      uint64_t v9 = 0;
      uint64_t v10 = v6 + v8;
      do
      {
        if (*(unsigned char *)(v6 + v9 + 48))
        {
          if ((*(_DWORD *)(v10 + 4 * v9) & 0x80000000) == 0)
          {
            uint64_t v28 = 0;
            long long v26 = 0u;
            long long v27 = 0u;
            kdu_error::kdu_error((kdu_error *)&v26, "Error in Kakadu File Format Support:\n");
            (*(void (**)(long long *, const char *))(v26 + 16))(&v26, "Malformed channel definition (cdef) box found in JP2-family data source.  The box appears to provide multiple channels with the same Assoc/Typ values.");
            kdu_error::~kdu_error((kdu_error *)&v26);
          }
          int v11 = *(_DWORD *)(v6 + 4 * v9);
          if (v11 < 0) {
            j2_channels::finalize();
          }
          *(_DWORD *)(v10 + 4 * v9) = v11;
        }
        ++v9;
      }
      while (v9 != 3);
      ++v7;
      unint64_t v4 = this[1];
      v8 += 64;
    }
    while (v7 < v4);
  }
  if (*((unsigned char *)this + 17))
  {
    if (!v4) {
      return this;
    }
    unint64_t v12 = 0;
    int v13 = (_DWORD *)(*((void *)this + 1) + 4);
    do
    {
      *(v13 - 1) = v12;
      _DWORD *v13 = this[1];
      v13 += 16;
      ++v12;
      unint64_t v4 = this[1];
    }
    while (v12 < v4);
  }
  else if (*((unsigned char *)this + 18))
  {
    if (!v4) {
      return this;
    }
    unint64_t v14 = 0;
    unsigned int v15 = (_DWORD *)(*((void *)this + 1) + 8);
    do
    {
      *(v15 - 2) = v14;
      _DWORD *v15 = this[1];
      v15 += 16;
      ++v14;
      unint64_t v4 = this[1];
    }
    while (v14 < v4);
  }
  else if (*((void *)this + 4))
  {
    if (!v4) {
      return this;
    }
    unint64_t v18 = 0;
    long long v19 = (_DWORD *)*((void *)this + 1);
    do
    {
      *long long v19 = v18;
      v19 += 16;
      ++v18;
      unint64_t v4 = this[1];
    }
    while (v18 < v4);
  }
  if (v4)
  {
    uint64_t v20 = 0;
    for (unint64_t i = 0; i < v4; ++i)
    {
      if ((*(_DWORD *)(*((void *)this + 1) + v20) & 0x80000000) != 0)
      {
        uint64_t v28 = 0;
        long long v26 = 0u;
        long long v27 = 0u;
        kdu_error::kdu_error((kdu_error *)&v26, "Error in Kakadu File Format Support:\n");
        kdu_error::~kdu_error((kdu_error *)&v26);
      }
      v20 += 64;
    }
  }
  return this;
}

void sub_18867E3A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867E3B4()
{
  _Unwind_Resume(v0);
}

BOOL j2_channels::all_cmap_channels_found(j2_channels *this)
{
  unint64_t v1 = *((unsigned int *)this + 1);
  if (v1)
  {
    unint64_t v2 = 0;
    BOOL v3 = 0;
    uint64_t v4 = *((void *)this + 1);
LABEL_3:
    uint64_t v5 = 0;
    while ((*(_DWORD *)(v4 + v5) & 0x80000000) != 0 || (*(_DWORD *)(v4 + v5 + 12) & 0x80000000) == 0)
    {
      v5 += 4;
      if (v5 == 12)
      {
        ++v2;
        v4 += 64;
        BOOL v3 = v2 >= v1;
        if (v2 != v1) {
          goto LABEL_3;
        }
        return 1;
      }
    }
  }
  else
  {
    return 1;
  }
  return v3;
}

unsigned int *j2_channels::find_cmap_channels(unsigned int *this, j2_component_map *a2, int a3)
{
  uint64_t v4 = this;
  if (this[1])
  {
    uint64_t v5 = this + 5;
    signed int v6 = this[5];
    this[5] = *((_DWORD *)a2 + 7) + v6;
  }
  else
  {
    this = j2_channels::finalize(this, *((_DWORD *)a2 + 7), 0);
    uint64_t v5 = v4 + 5;
    signed int v6 = v4[5];
    unsigned int v7 = v4[1];
    void v4[5] = *((_DWORD *)a2 + 7) + v6;
    if (!v7) {
      return this;
    }
  }
  unint64_t v8 = 0;
  char v9 = 1;
  uint64_t v10 = 24;
  char v34 = v4;
  do
  {
    uint64_t v11 = *((void *)v4 + 1);
    uint64_t v12 = v11 + (v8 << 6);
    long long v35 = (unsigned char *)(v12 + 60);
    long long v36 = (_DWORD *)(v12 + 56);
    uint64_t v13 = v11 + v10;
    uint64_t v14 = -12;
    do
    {
      int v15 = *(_DWORD *)(v13 + v14 - 12);
      if (v15 < 0)
      {
        if (v14 == -12) {
          j2_channels::find_cmap_channels();
        }
      }
      else
      {
        int v16 = v15 - v6;
        if (v15 < v6 || v15 >= *v5)
        {
          v9 &= *(_DWORD *)(v13 + v14) >= 0;
        }
        else
        {
          uint64_t v17 = v13 + v14;
          *(_DWORD *)(v13 + v14) = a3;
          j2_component_map::verify_channel_query_idx((uint64_t)a2, v16);
          *(_DWORD *)(v17 + 12) = *(_DWORD *)(*((void *)a2 + 4) + 16 * v16);
          this = (unsigned int *)j2_component_map::verify_channel_query_idx((uint64_t)a2, v16);
          *(_DWORD *)(v17 + 24) = *(_DWORD *)(*((void *)a2 + 4) + 16 * v16 + 4);
          if (v14 == -12)
          {
            j2_component_map::verify_channel_query_idx((uint64_t)a2, v16);
            *long long v36 = *(_DWORD *)(*((void *)a2 + 4) + 16 * v16 + 8);
            this = (unsigned int *)j2_component_map::verify_channel_query_idx((uint64_t)a2, v16);
            *long long v35 = *(unsigned char *)(*((void *)a2 + 4) + 16 * v16 + 12);
          }
        }
      }
      v14 += 4;
    }
    while (v14);
    ++v8;
    uint64_t v4 = v34;
    unint64_t v18 = v34[1];
    v10 += 64;
  }
  while (v8 < v18);
  if (v9)
  {
    long long v19 = (unsigned __int8 *)*((void *)v34 + 4);
    if (v19)
    {
      if (v18)
      {
        unint64_t v20 = 0;
        signed int v21 = v34[6];
        do
        {
          uint64_t v22 = *((void *)v34 + 1);
          uint64_t v23 = v22 + (v20 << 6);
          int v26 = *(_DWORD *)(v23 + 56);
          long long v25 = (int *)(v23 + 56);
          int v24 = v26;
          if (v26 <= 0) {
            j2_channels::find_cmap_channels();
          }
          signed int v27 = (v24 - 1) >> 3;
          if (v27 >= v21 || v20 == v18 - 1 && v27 + 1 != v21)
          {
            uint64_t v39 = 0;
            memset(v38, 0, sizeof(v38));
            kdu_error::kdu_error((kdu_error *)v38, "Error in Kakadu File Format Support:\n");
            (*(void (**)(_OWORD *, const char *))(*(void *)&v38[0] + 16))(v38, "Malformed opacity (opct) box in JPX data source.  The length of a chroma key specification is incompatible with the bit-depths of the colour channels.");
            kdu_error::~kdu_error((kdu_error *)v38);
          }
          int v28 = 0;
          uint64_t v29 = v22 + (v20 << 6);
          *(_DWORD *)(v29 + 52) = 0;
          uint64_t v30 = v29 + 52;
          int v31 = *(unsigned __int8 *)(v30 + 8);
          int v32 = v27 + 2;
          do
          {
            *(_DWORD *)uint64_t v30 = v28 << 8;
            unsigned __int8 v33 = *v19++;
            int v28 = v33 | (v28 << 8);
            *(_DWORD *)uint64_t v30 = v28;
            if (v31)
            {
              if (*v25 <= 31)
              {
                int v28 = v28 << -(char)*v25 >> -(char)*v25;
                *(_DWORD *)uint64_t v30 = v28;
              }
            }
            --v32;
          }
          while (v32 > 1);
          ++v20;
          unint64_t v18 = v34[1];
        }
        while (v20 < v18);
      }
    }
  }
  return this;
}

void sub_18867E734(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18867E740()
{
  _Unwind_Resume(v0);
}

unsigned int *j2_channels::add_cmap_channels(unsigned int *this, j2_component_map *a2, int a3)
{
  uint64_t v5 = this;
  if (this[1])
  {
    unsigned int v6 = this[5];
    this[5] = *((_DWORD *)a2 + 7) + v6;
  }
  else
  {
    this = j2_channels::finalize(this, *((_DWORD *)a2 + 7), 1);
    unsigned int v7 = v5[1];
    unsigned int v6 = v5[5];
    v5[5] = *((_DWORD *)a2 + 7) + v6;
    if (!v7) {
      return this;
    }
  }
  unint64_t v8 = 0;
  uint64_t v9 = 24;
  do
  {
    uint64_t v10 = *((void *)v5 + 1);
    uint64_t v11 = v10 + (v8 << 6);
    uint64_t v17 = v9;
    unint64_t v18 = (_DWORD *)(v11 + 56);
    uint64_t v12 = (unsigned char *)(v11 + 60);
    uint64_t v13 = v10 + v9;
    uint64_t v14 = -12;
    do
    {
      if (*(_DWORD *)(v13 + v14) == a3)
      {
        uint64_t v15 = v13 + v14;
        if ((*(_DWORD *)(v13 + v14 - 12) & 0x80000000) == 0) {
          j2_channels::add_cmap_channels();
        }
        this = (unsigned int *)j2_component_map::add_cmap_channel(a2, *(_DWORD *)(v15 + 12), *(_DWORD *)(v15 + 24));
        *(_DWORD *)(v15 - 12) = this + v6;
        if (v14 == -12)
        {
          int v16 = (int)this;
          j2_component_map::verify_channel_query_idx((uint64_t)a2, (int)this);
          *unint64_t v18 = *(_DWORD *)(*((void *)a2 + 4) + 16 * v16 + 8);
          this = (unsigned int *)j2_component_map::verify_channel_query_idx((uint64_t)a2, v16);
          unsigned char *v12 = *(unsigned char *)(*((void *)a2 + 4) + 16 * v16 + 12);
          if (*((unsigned char *)v5 + 16))
          {
            if (v8 != v16)
            {
              uint64_t v20 = 0;
              memset(v19, 0, sizeof(v19));
              kdu_error::kdu_error((kdu_error *)v19, "Error in Kakadu File Format Support:\n");
              (*(void (**)(_OWORD *, const char *))(*(void *)&v19[0] + 16))(v19, "Attempting to create a JPX file which uses chroma-keys in an incompatible manner across compositing layers which share a common codestream.  The JPX file format has insufficient flexibility in its channel mapping rules to allow arbitrary binding between image components and colour channels at the same time as chroma keying.");
              kdu_error::~kdu_error((kdu_error *)v19);
            }
          }
        }
        else if (*((unsigned char *)v5 + 16))
        {
          j2_channels::add_cmap_channels();
        }
      }
      v14 += 4;
    }
    while (v14);
    ++v8;
    uint64_t v9 = v17 + 64;
  }
  while (v8 < v5[1]);
  return this;
}

void sub_18867E91C(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18867E928()
{
  _Unwind_Resume(v0);
}

uint64_t j2_channels::save_box(uint64_t this, jp2_output_box *a2, char a3)
{
  uint64_t v3 = *(unsigned int *)(this + 4);
  if (v3)
  {
    uint64_t v4 = this;
    if (*(void *)(this + 32)) {
      j2_channels::save_box();
    }
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(this + 8);
    unsigned int v7 = (int *)(v6 + 64);
    unint64_t v8 = (BOOL *)(v6 + 48);
    do
    {
      if (v3 < 2)
      {
        LODWORD(v10) = 1;
      }
      else
      {
        uint64_t v9 = v7;
        uint64_t v10 = 1;
        while (1)
        {
          int v11 = *v9;
          v9 += 16;
          if (v11 != *(_DWORD *)(v6 + 4 * v5)) {
            break;
          }
          if (v3 == ++v10)
          {
            LODWORD(v10) = v3;
            break;
          }
        }
      }
      BOOL v12 = v10 == v3;
      uint64_t v13 = v3;
      uint64_t v14 = v8;
      do
      {
        BOOL *v14 = v12;
        v14 += 64;
        --v13;
      }
      while (v13);
      ++v5;
      ++v7;
      ++v8;
    }
    while (v5 != 3);
    uint64_t v15 = 0;
    BOOL v16 = *(unsigned char *)(this + 16) != 0;
    char v17 = a3 ^ 1;
    if (*(unsigned char *)(this + 16)) {
      char v17 = 1;
    }
    unint64_t v18 = (int *)v6;
    while (1)
    {
      int v19 = *v18;
      v18 += 16;
      if (v15 != v19) {
        break;
      }
      if (v3 == ++v15) {
        goto LABEL_21;
      }
    }
    if (*(unsigned char *)(this + 16)) {
      j2_channels::save_box();
    }
    char v17 = 0;
    BOOL v16 = 1;
LABEL_21:
    if (!*(unsigned char *)(v6 + 49) || !*(unsigned char *)(v6 + 50))
    {
      if (*(unsigned char *)(this + 16)) {
        j2_channels::save_box();
      }
      char v17 = 0;
      BOOL v16 = 1;
    }
    int v21 = *(_DWORD *)(v6 + 4);
    int v20 = *(_DWORD *)(v6 + 8);
    if (v21 < 0)
    {
      if (v20 < 0)
      {
        char v23 = v17 ^ 1;
        if (!*(unsigned char *)(this + 16)) {
          char v23 = 1;
        }
        if (v23)
        {
          if (!v16) {
            return this;
          }
          goto LABEL_48;
        }
        goto LABEL_40;
      }
    }
    else if ((v20 & 0x80000000) == 0)
    {
LABEL_48:
      long long v48 = 0uLL;
      uint64_t v52 = 0;
      unsigned int v47 = (void (**)(void **, _OWORD *, uint64_t))&unk_1ED4E3098;
      long long v49 = 0uLL;
      long long v50 = 0uLL;
      long long v51 = 0xFFFFFFFFFFFFFFFFLL;
      jp2_output_box::open((uint64_t)&v47, a2, 1667523942, 0);
      uint64_t v27 = *(unsigned int *)(v4 + 4);
      if (v27)
      {
        uint64_t v28 = 0;
        unsigned int v29 = 0;
        uint64_t v30 = *(void *)(v4 + 8);
        do
        {
          for (uint64_t i = 0; i != 3; ++i)
          {
            if ((*(_DWORD *)(v30 + 4 * i + 24) & 0x80000000) == 0 && (!v28 || !*(unsigned char *)(v30 + i + 48))) {
              ++v29;
            }
          }
          ++v28;
          v30 += 64;
        }
        while (v28 != v27);
      }
      else
      {
        unsigned int v29 = 0;
      }
      LOWORD(v45[0]) = bswap32(v29) >> 16;
      v47[5]((void **)&v47, v45, 2);
      if (*(_DWORD *)(v4 + 4))
      {
        uint64_t v32 = 0;
        unint64_t v33 = 0;
        do
        {
          for (uint64_t j = 0; j != 3; ++j)
          {
            uint64_t v35 = *(void *)(v4 + 8);
            if ((*(_DWORD *)(v35 + v32 + 4 * j + 24) & 0x80000000) == 0)
            {
              if (*(unsigned char *)(v35 + v32 + j + 48)) {
                char v36 = 0;
              }
              else {
                char v36 = v33 + 1;
              }
              if (*(unsigned char *)(v35 + v32 + j + 48)) {
                char v37 = 0;
              }
              else {
                char v37 = (unsigned __int16)(v33 + 1) >> 8;
              }
              if (*(unsigned char *)(v35 + v32 + j + 48)) {
                BOOL v38 = v33 == 0;
              }
              else {
                BOOL v38 = 1;
              }
              if (v38)
              {
                LOWORD(v45[0]) = bswap32(*(_DWORD *)(v35 + v32 + 4 * j)) >> 16;
                v47[5]((void **)&v47, v45, 2);
                LOWORD(v45[0]) = bswap32(j) >> 16;
                v47[5]((void **)&v47, v45, 2);
                BYTE1(v45[0]) = v36;
                LOBYTE(v45[0]) = v37;
                v47[5]((void **)&v47, v45, 2);
              }
            }
          }
          ++v33;
          v32 += 64;
        }
        while (v33 < *(unsigned int *)(v4 + 4));
      }
      goto LABEL_88;
    }
    if (v21 == v3)
    {
      if ((v17 & 1) == 0) {
        goto LABEL_48;
      }
    }
    else
    {
      if (v20 == v3) {
        char v22 = v17;
      }
      else {
        char v22 = 0;
      }
      if ((v22 & 1) == 0) {
        goto LABEL_48;
      }
    }
LABEL_40:
    long long v48 = 0uLL;
    uint64_t v52 = 0;
    unsigned int v47 = (void (**)(void **, _OWORD *, uint64_t))&unk_1ED4E3098;
    long long v49 = 0uLL;
    long long v50 = 0uLL;
    long long v51 = 0xFFFFFFFFFFFFFFFFLL;
    jp2_output_box::open((uint64_t)&v47, a2, 1869636468, 0);
    uint64_t v24 = *(void *)(v4 + 8);
    int v26 = *(_DWORD *)(v24 + 4);
    int v25 = *(_DWORD *)(v24 + 8);
    if (v26 < 0)
    {
      if (v25 < 0)
      {
        if (*(unsigned char *)(v4 + 16))
        {
          LOBYTE(v45[0]) = 2;
          v47[5]((void **)&v47, v45, 1);
          if (*(_DWORD *)(v4 + 4) >= 0x100u)
          {
            uint64_t v46 = 0;
            memset(v45, 0, sizeof(v45));
            kdu_error::kdu_error((kdu_error *)v45, "Error in Kakadu File Format Support:\n");
            (*(void (**)(_OWORD *, const char *))(*(void *)&v45[0] + 16))(v45, "Attempting to write a JPX opacity box with chroma key values for more than 255 channels.  This is not possible within the syntactic constraints of the opct box.");
            kdu_error::~kdu_error((kdu_error *)v45);
          }
          LOBYTE(v45[0]) = *(_DWORD *)(v4 + 4);
          v47[5]((void **)&v47, v45, 1);
          if (!*(_DWORD *)(v4 + 4)) {
            goto LABEL_88;
          }
          uint64_t v39 = 0;
          uint64_t v40 = "channels[n].bit_depth > 0";
          while (1)
          {
            int v41 = *(_DWORD *)(*(void *)(v4 + 8) + (v39 << 6) + 56);
            if (v41 <= 0) {
              break;
            }
            signed int v42 = (v41 - 1) & 0xFFFFFFF8;
            do
            {
              LOBYTE(v45[0]) = *(int *)(*(void *)(v4 + 8) + (v39 << 6) + 52) >> v42;
              v47[5]((void **)&v47, v45, 1);
              BOOL v43 = v42 <= 7;
              v42 -= 8;
            }
            while (!v43);
            if (++v39 >= (unint64_t)*(unsigned int *)(v4 + 4)) {
              goto LABEL_88;
            }
          }
          int v44 = 3531;
        }
        else
        {
          uint64_t v40 = "have_chroma_key";
          int v44 = 3520;
        }
      }
      else
      {
        if (!*(unsigned char *)(v4 + 16))
        {
          LOBYTE(v45[0]) = 1;
          v47[5]((void **)&v47, v45, 1);
LABEL_88:
          jp2_output_box::close((jp2_output_box *)&v47);
          unsigned int v47 = (void (**)(void **, _OWORD *, uint64_t))&unk_1ED4E3098;
          this = *((void *)&v51 + 1);
          if (*((void *)&v51 + 1)) {
            return MEMORY[0x18C11C0C0](*((void *)&v51 + 1), 0x1000C8077774924);
          }
          return this;
        }
        uint64_t v40 = "!have_chroma_key";
        int v44 = 3515;
      }
    }
    else
    {
      if (v25 < 0 && !*(unsigned char *)(v4 + 16))
      {
        LOBYTE(v45[0]) = 0;
        v47[5]((void **)&v47, v45, 1);
        goto LABEL_88;
      }
      uint64_t v40 = "(channels->cmap_channel[2] < 0) && !have_chroma_key";
      int v44 = 3510;
    }
    __assert_rtn("save_box", "jp2.cpp", v44, v40);
  }
  return this;
}

void sub_18867EFE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867EFF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  jp2_output_box::~jp2_output_box((jp2_output_box *)va);
  _Unwind_Resume(v6);
}

void jp2_channels::init(jp2_channels *this, int a2)
{
  uint64_t v2 = *(void *)this;
  if (*(void *)this)
  {
    if (!*(void *)(v2 + 8) && !*(void *)(v2 + 32))
    {
      *(_DWORD *)uint64_t v2 = a2;
      *(_DWORD *)(v2 + 4) = a2;
      operator new[]();
    }
    uint64_t v4 = 0;
    memset(v3, 0, sizeof(v3));
    kdu_error::kdu_error((kdu_error *)v3, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v3);
  }
  jp2_channels::init();
}

void sub_18867F158(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867F164()
{
  _Unwind_Resume(v0);
}

uint64_t *jp2_channels::set_colour_mapping(uint64_t *this, unsigned int a2, int a3, int a4, int a5)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v5 = *this) == 0 || *(_DWORD *)(v5 + 4) <= a2) {
    jp2_channels::set_colour_mapping();
  }
  uint64_t v6 = (_DWORD *)(*(void *)(v5 + 8) + ((unint64_t)a2 << 6));
  v6[3] = a5;
  if (a4 < 0) {
    int v7 = -1;
  }
  else {
    int v7 = a4;
  }
  v6[6] = a3;
  v6[9] = v7;
  return this;
}

uint64_t *jp2_channels::set_opacity_mapping(uint64_t *this, unsigned int a2, int a3, int a4, int a5)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v5 = *this) == 0 || *(_DWORD *)(v5 + 4) <= a2) {
    jp2_channels::set_opacity_mapping();
  }
  uint64_t v6 = (_DWORD *)(*(void *)(v5 + 8) + ((unint64_t)a2 << 6));
  v6[4] = a5;
  if (a4 < 0) {
    int v7 = -1;
  }
  else {
    int v7 = a4;
  }
  v6[7] = a3;
  v6[10] = v7;
  return this;
}

uint64_t *jp2_channels::set_premult_mapping(uint64_t *this, unsigned int a2, int a3, int a4, int a5)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v5 = *this) == 0 || *(_DWORD *)(v5 + 4) <= a2) {
    jp2_channels::set_premult_mapping();
  }
  uint64_t v6 = (_DWORD *)(*(void *)(v5 + 8) + ((unint64_t)a2 << 6));
  v6[5] = a5;
  v6[8] = a3;
  v6[11] = a4;
  return this;
}

uint64_t jp2_channels::get_num_colours(jp2_channels *this)
{
  if (!*(void *)this) {
    jp2_channels::get_num_colours();
  }
  return *(unsigned int *)(*(void *)this + 4);
}

BOOL jp2_channels::get_colour_mapping(jp2_channels *this, unsigned int a2, int *a3, int *a4, int *a5)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v5 = *(void *)this) == 0 || *(_DWORD *)(v5 + 4) <= a2)
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  uint64_t v6 = (_DWORD *)(*(void *)(v5 + 8) + ((unint64_t)a2 << 6));
  int v7 = v6[3];
  if ((v7 & 0x80000000) == 0)
  {
    *a5 = v7;
    *a3 = v6[6];
    *a4 = v6[9];
  }
  return v7 >= 0;
}

BOOL jp2_channels::get_opacity_mapping(jp2_channels *this, unsigned int a2, int *a3, int *a4, int *a5)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v5 = *(void *)this) == 0 || *(_DWORD *)(v5 + 4) <= a2) {
    jp2_channels::get_opacity_mapping();
  }
  uint64_t v6 = (_DWORD *)(*(void *)(v5 + 8) + ((unint64_t)a2 << 6));
  int v7 = v6[4];
  if ((v7 & 0x80000000) == 0)
  {
    *a5 = v7;
    *a3 = v6[7];
    *a4 = v6[10];
  }
  return v7 >= 0;
}

BOOL jp2_channels::get_premult_mapping(jp2_channels *this, unsigned int a2, int *a3, int *a4, int *a5)
{
  if ((a2 & 0x80000000) != 0 || (uint64_t v5 = *(void *)this) == 0 || *(_DWORD *)(v5 + 4) <= a2) {
    jp2_channels::get_premult_mapping();
  }
  uint64_t v6 = (_DWORD *)(*(void *)(v5 + 8) + ((unint64_t)a2 << 6));
  int v7 = v6[5];
  if ((v7 & 0x80000000) == 0)
  {
    *a5 = v7;
    *a3 = v6[8];
    *a4 = v6[11];
  }
  return v7 >= 0;
}

BOOL jp2_channels::has_opacity(jp2_channels *this)
{
  unint64_t v1 = *(unsigned int *)(*(void *)this + 4);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = *(void *)(*(void *)this + 8);
  if ((*(_DWORD *)(v2 + 16) & 0x80000000) == 0) {
    return 1;
  }
  uint64_t v4 = (int *)(v2 + 80);
  uint64_t v5 = 1;
  do
  {
    unint64_t v6 = v5;
    if (v1 == v5) {
      break;
    }
    int v7 = *v4;
    v4 += 16;
    ++v5;
  }
  while (v7 < 0);
  return v6 < v1;
}

BOOL jp2_channels::has_premultiplied_opacity(jp2_channels *this)
{
  unint64_t v1 = *(unsigned int *)(*(void *)this + 4);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = *(void *)(*(void *)this + 8);
  if ((*(_DWORD *)(v2 + 20) & 0x80000000) == 0) {
    return 1;
  }
  uint64_t v4 = (int *)(v2 + 84);
  uint64_t v5 = 1;
  do
  {
    unint64_t v6 = v5;
    if (v1 == v5) {
      break;
    }
    int v7 = *v4;
    v4 += 16;
    ++v5;
  }
  while (v7 < 0);
  return v6 < v1;
}

uint64_t j2_resolution::init(uint64_t this, float a2)
{
  if (*(float *)this > 0.0)
  {
    uint64_t v3 = 0;
    memset(v2, 0, sizeof(v2));
    kdu_error::kdu_error((kdu_error *)v2, "Error in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v2[0] + 16))(v2, "JP2 resolution information may be initialized only once!");
    kdu_error::~kdu_error((kdu_error *)v2);
  }
  *(float *)this = a2;
  *(float *)(this + 4) = a2;
  *(void *)(this + 8) = 0;
  return this;
}

void sub_18867F500(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867F50C()
{
  _Unwind_Resume(v0);
}

uint64_t j2_resolution::init(j2_resolution *this, jp2_input_box *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (*(float *)this > 0.0)
  {
    uint64_t v10 = 0;
    memset(v9, 0, sizeof(v9));
    kdu_error::kdu_error((kdu_error *)v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v9[0] + 16))(v9, "JP2-family data source contains multiple instances of the resolution (res) box within the same JP2 header box or compositing layer header box!");
    kdu_error::~kdu_error((kdu_error *)v9);
  }
  if (!jp2_input_box::is_complete(a2)) {
    j2_resolution::init();
  }
  *((void *)&v9[1] + 1) = 0;
  long long v18 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  uint64_t v19 = 0;
  *(void *)&v9[0] = &unk_1ED4E0DA8;
  *(_OWORD *)((char *)v9 + 8) = xmmword_18898D150;
  uint64_t v10 = 0;
  long long v11 = 0uLL;
  long long v12 = 0uLL;
  long long v13 = 0uLL;
  uint64_t v14 = 0;
  uint64_t v15 = -1;
  uint64_t v16 = -1;
  uint64_t v17 = -1;
  LODWORD(v18) = -1;
  DWORD2(v18) = 0;
  *(_DWORD *)((char *)&v18 + 5) = 0;
  uint64_t v20 = -1;
  while (1)
  {
    int v4 = jp2_input_box::open((jp2_input_box *)v9, a2);
    if (!v4) {
      break;
    }
    if (!jp2_input_box::is_complete((jp2_input_box *)v9))
    {
      jp2_input_box::close((jp2_input_box *)v9);
      (*(void (**)(jp2_input_box *, void))(*(void *)a2 + 40))(a2, 0);
      goto LABEL_16;
    }
    if ((DWORD2(v11) - 1919251299) >= 2) {
      jp2_input_box::close((jp2_input_box *)v9);
    }
    else {
      j2_resolution::parse_sub_box(this, (jp2_input_box *)v9);
    }
  }
  if (*((float *)this + 3) <= 0.0 && *((float *)this + 2) <= 0.0)
  {
    uint64_t v8 = 0;
    long long v6 = 0u;
    long long v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v6 + 16))(&v6, "The JP2 resolution box must contain at least one of the capture or display resolution sub-boxes.");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  if (((*(uint64_t (**)(jp2_input_box *))(*(void *)a2 + 16))(a2) & 1) == 0)
  {
    uint64_t v8 = 0;
    long long v6 = 0u;
    long long v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v6 + 16))(&v6, "Malformed resolution box found in JP2-family data source.  Box appears to be too long.");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
LABEL_16:
  jp2_input_box::~jp2_input_box((jp2_input_box *)v9);
  return v4 ^ 1u;
}

void sub_18867F80C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867F818(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  jp2_input_box::~jp2_input_box((jp2_input_box *)va);
  _Unwind_Resume(v6);
}

uint64_t j2_resolution::parse_sub_box(j2_resolution *this, jp2_input_box *a2)
{
  *(_DWORD *)uint64_t v24 = 0;
  *(_DWORD *)int v25 = 0;
  __int16 v23 = 0;
  if (!jp2_input_box::read(a2, &v25[1])
    || !jp2_input_box::read(a2, v25)
    || !jp2_input_box::read(a2, &v24[1])
    || !jp2_input_box::read(a2, v24)
    || (*(unsigned int (**)(jp2_input_box *, char *, uint64_t))(*(void *)a2 + 32))(a2, (char *)&v23 + 1, 1) != 1|| ((*(unsigned int (**)(jp2_input_box *, __int16 *, uint64_t))(*(void *)a2 + 32))(a2, &v23, 1) == 1? (v5 = v25[0] == 0): (v5 = 1), !v5 ? (BOOL v6 = v24[0] == 0) : (BOOL v6 = 1), !v6 ? (v7 = v25[1] == 0) : (v7 = 1), !v7 ? (v8 = v24[1] == 0) : (v8 = 1), v8))
  {
    uint64_t v22 = 0;
    long long v20 = 0u;
    long long v21 = 0u;
    kdu_error::kdu_error((kdu_error *)&v20, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v20 + 16))(&v20, "Malformed capture or display resolution sub-box found in JP2-family data source.  Insufficient or illegal data fields.");
    kdu_error::~kdu_error((kdu_error *)&v20);
  }
  double v9 = (double)v25[0];
  double v10 = (double)v25[1] / v9;
  int v11 = SHIBYTE(v23);
  if (SHIBYTE(v23) < 0)
  {
    double v9 = 0.100000001;
    do
    {
      double v10 = v10 * 0.100000001;
      LOWORD(v11) = v11 + 1;
    }
    while ((v11 & 0x100) == 0);
  }
  else
  {
    if (!HIBYTE(v23)) {
      goto LABEL_29;
    }
    double v9 = 10.0;
    do
    {
      double v10 = v10 * 10.0;
      --v11;
    }
    while ((_BYTE)v11);
  }
  HIBYTE(v23) = 0;
LABEL_29:
  LOWORD(v9) = v24[1];
  LOWORD(v4) = v24[0];
  int v12 = (char)v23;
  double v13 = (double)*(unint64_t *)&v9 / (double)v4;
  if ((char)v23 < 0)
  {
    do
    {
      double v13 = v13 * 0.100000001;
      LOWORD(v12) = v12 + 1;
    }
    while ((v12 & 0x100) == 0);
  }
  else
  {
    if (!(_BYTE)v23) {
      goto LABEL_35;
    }
    do
    {
      double v13 = v13 * 10.0;
      --v12;
    }
    while ((_BYTE)v12);
  }
  LOBYTE(v23) = 0;
LABEL_35:
  int v14 = *((_DWORD *)a2 + 12);
  if (v14 == 1919251300)
  {
    float v17 = v13 / v10;
    *(float *)this = v17;
    if (*((float *)this + 3) <= 0.0) {
      *((float *)this + 1) = v17;
    }
    float v18 = v10;
    *((float *)this + 2) = v18;
  }
  else
  {
    if (v14 != 1919251299) {
      j2_resolution::parse_sub_box();
    }
    float v15 = v13 / v10;
    *((float *)this + 1) = v15;
    if (*((float *)this + 2) <= 0.0) {
      *(float *)this = v15;
    }
    float v16 = v10;
    *((float *)this + 3) = v16;
  }
  uint64_t result = (*(uint64_t (**)(jp2_input_box *))(*(void *)a2 + 16))(a2);
  if ((result & 1) == 0)
  {
    uint64_t v22 = 0;
    long long v20 = 0u;
    long long v21 = 0u;
    kdu_error::kdu_error((kdu_error *)&v20, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v20 + 16))(&v20, "Malformed capture or display resolution sub-box found in JP2-family data source.  Box appears to be too long.");
    kdu_error::~kdu_error((kdu_error *)&v20);
  }
  return result;
}

void sub_18867FB78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18867FB84()
{
  _Unwind_Resume(v0);
}

float *j2_resolution::finalize(float *this)
{
  if (*this <= 0.0) {
    *this = 1.0;
  }
  if (this[1] <= 0.0) {
    this[1] = 1.0;
  }
  return this;
}

float *j2_resolution::save_box(float *this, jp2_output_box *a2)
{
  uint64_t v2 = this;
  BOOL v3 = fabs(*this + -1.0) > 0.00999999978;
  double v4 = fabs(this[1] + -1.0);
  BOOL v5 = v4 > 0.00999999978;
  float v6 = this[3];
  int v7 = this[2] > 0.0 || v3;
  if ((v7 & 1) != 0 || v4 > 0.00999999978 || v6 > 0.0)
  {
    long long v13 = 0uLL;
    uint64_t v17 = 0;
    int v12 = &unk_1ED4E3098;
    long long v14 = 0uLL;
    long long v15 = 0uLL;
    long long v16 = 0xFFFFFFFFFFFFFFFFLL;
    BOOL v8 = (j2_resolution *)jp2_output_box::open((uint64_t)&v12, a2, 1919251232, 0);
    if (v7)
    {
      float v9 = 1.0;
      if (v2[2] > 0.0) {
        float v9 = v2[2];
      }
      BOOL v8 = (j2_resolution *)j2_resolution::save_sub_box(v8, (jp2_output_box *)&v12, 1919251300, v9, (float)(*v2 * v9));
      BOOL v10 = fabs((float)(v2[1] / *v2) + -1.0) >= 0.00999999978;
      BOOL v5 = v4 > 0.00999999978 && v10;
    }
    if (v5 || v6 > 0.0)
    {
      float v11 = 1.0;
      if (v2[3] > 0.0) {
        float v11 = v2[3];
      }
      j2_resolution::save_sub_box(v8, (jp2_output_box *)&v12, 1919251299, v11, (float)(v2[1] * v11));
    }
    jp2_output_box::close((jp2_output_box *)&v12);
    int v12 = &unk_1ED4E3098;
    this = (float *)*((void *)&v16 + 1);
    if (*((void *)&v16 + 1)) {
      return (float *)MEMORY[0x18C11C0C0](*((void *)&v16 + 1), 0x1000C8077774924);
    }
  }
  return this;
}

void sub_18867FD88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t j2_resolution::save_sub_box(j2_resolution *this, jp2_output_box *a2, int a3, double a4, double a5)
{
  if (a4 >= 1.0)
  {
    int v6 = 0;
  }
  else
  {
    int v5 = 0;
    do
    {
      int v6 = v5 - 1;
      a4 = a4 * 10.0;
      if (a4 >= 1.0) {
        break;
      }
      BOOL v14 = v5-- <= -127;
    }
    while (!v14);
  }
  if (a4 <= 1.0 || v6 > 126)
  {
    char v7 = v6;
  }
  else
  {
    do
    {
      char v7 = v6 + 1;
      a4 = a4 * 0.1;
      if (a4 <= 1.0) {
        break;
      }
      BOOL v14 = v6++ < 126;
    }
    while (v14);
  }
  double v8 = a4 * 32768.0 + 0.5;
  if (a5 >= 1.0)
  {
    int v10 = 0;
  }
  else
  {
    int v9 = 0;
    do
    {
      int v10 = v9 - 1;
      a5 = a5 * 10.0;
      if (a5 >= 1.0) {
        break;
      }
      BOOL v14 = v9-- <= -127;
    }
    while (!v14);
  }
  signed int v11 = (int)v8;
  if (a5 <= 1.0 || v10 > 126)
  {
    char v12 = v10;
  }
  else
  {
    do
    {
      char v12 = v10 + 1;
      a5 = a5 * 0.1;
      if (a5 <= 1.0) {
        break;
      }
      BOOL v14 = v10++ < 126;
    }
    while (v14);
  }
  unsigned int v13 = (int)(a5 * 32768.0 + 0.5);
  BOOL v14 = v13 - 0x10000 < 0xFFFF0001 || v11 < 1;
  if (v14 || v11 >= 0x10000)
  {
    uint64_t v18 = 0;
    long long v16 = 0u;
    long long v17 = 0u;
    kdu_error::kdu_error((kdu_error *)&v16, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v16 + 16))(&v16, "Unable to save resolution information having illegal or ridiculously small or large values!");
    kdu_error::~kdu_error((kdu_error *)&v16);
  }
  *((void *)&v16 + 1) = 0;
  uint64_t v18 = 0;
  uint64_t v21 = 0;
  *(void *)&long long v16 = &unk_1ED4E3098;
  long long v17 = 0uLL;
  long long v19 = 0uLL;
  long long v20 = 0xFFFFFFFFFFFFFFFFLL;
  jp2_output_box::open((uint64_t)&v16, a2, a3, 0);
  __int16 v22 = bswap32(v11) >> 16;
  (*(void (**)(long long *, __int16 *, uint64_t))(v16 + 40))(&v16, &v22, 2);
  __int16 v22 = 128;
  (*(void (**)(long long *, __int16 *, uint64_t))(v16 + 40))(&v16, &v22, 2);
  __int16 v22 = bswap32(v13) >> 16;
  (*(void (**)(long long *, __int16 *, uint64_t))(v16 + 40))(&v16, &v22, 2);
  __int16 v22 = 128;
  (*(void (**)(long long *, __int16 *, uint64_t))(v16 + 40))(&v16, &v22, 2);
  LOBYTE(v22) = v7;
  (*(void (**)(long long *, __int16 *, uint64_t))(v16 + 40))(&v16, &v22, 1);
  LOBYTE(v22) = v12;
  (*(void (**)(long long *, __int16 *, uint64_t))(v16 + 40))(&v16, &v22, 1);
  jp2_output_box::close((jp2_output_box *)&v16);
  *(void *)&long long v16 = &unk_1ED4E3098;
  uint64_t result = *((void *)&v20 + 1);
  if (*((void *)&v20 + 1)) {
    return MEMORY[0x18C11C0C0](*((void *)&v20 + 1), 0x1000C8077774924);
  }
  return result;
}

void sub_18868015C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188680168()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_resolution::init(jp2_resolution *this, float a2)
{
  uint64_t v2 = *(void *)this;
  if (!v2) {
    jp2_resolution::init();
  }

  return j2_resolution::init(v2, a2);
}

float **jp2_resolution::set_resolution(float **this, float a2, int a3)
{
  BOOL v3 = *this;
  if (!*this || *v3 <= 0.0) {
    jp2_resolution::set_resolution();
  }
  uint64_t v4 = 3;
  if (a3) {
    uint64_t v4 = 2;
  }
  v3[v4] = a2;
  return this;
}

uint64_t j2_icc_profile::init(uint64_t this, unsigned __int8 *a2, unsigned int a3, char a4)
{
  uint64_t v4 = this;
  *(void *)this = a2;
  if (a3 <= 3)
  {
    uint64_t v20 = 0;
    long long v18 = 0u;
    long long v19 = 0u;
    kdu_error::kdu_error((kdu_error *)&v18, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v18 + 16))(&v18, "Embedded ICC profile in JP2 colour description box has invalid data size.");
    kdu_error::~kdu_error((kdu_error *)&v18);
  }
  *(_DWORD *)(this + 8) = 4;
  int v5 = bswap32(*(_DWORD *)a2);
  *(_DWORD *)(this + 8) = v5;
  if ((a4 & 1) == 0) {
    *(void *)this = 0;
  }
  int v6 = v5;
  if (v5 > 100000000)
  {
    uint64_t v20 = 0;
    long long v18 = 0u;
    long long v19 = 0u;
    kdu_error::kdu_error((kdu_error *)&v18, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v18 + 16))(&v18, "Embedded ICC profile in JP2 colour description box has corrupt size field.");
    kdu_error::~kdu_error((kdu_error *)&v18);
  }
  if (v5 <= 131)
  {
    uint64_t v20 = 0;
    long long v18 = 0u;
    long long v19 = 0u;
    kdu_error::kdu_error((kdu_error *)&v18, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v18 + 16))(&v18, "Embedded ICC profile in JP2 colour description box does not have a complete header.");
    kdu_error::~kdu_error((kdu_error *)&v18);
  }
  if (v5 > (int)a3)
  {
    uint64_t v20 = 0;
    long long v18 = 0u;
    long long v19 = 0u;
    kdu_error::kdu_error((kdu_error *)&v18, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v18 + 16))(&v18, "Embedded ICC profile length does not match length specified in ICC header.\n");
    kdu_error::~kdu_error((kdu_error *)&v18);
  }
  if ((a4 & 1) == 0) {
    operator new[]();
  }
  int v7 = bswap32(*(_DWORD *)(*(void *)this + 12));
  switch(v7)
  {
    case 1835955314:
      *(unsigned char *)(this + 22) = 1;
      break;
    case 1886549106:
      *(unsigned char *)(this + 23) = 1;
      break;
    case 1935896178:
      *(unsigned char *)(this + 21) = 1;
      break;
  }
  if (v6 >= 20) {
    int v7 = bswap32(*(_DWORD *)(*(void *)this + 16));
  }
  if (v7 <= 1129142602)
  {
    if (v7 > 943934545)
    {
      if (v7 > 1111706705)
      {
        if (v7 == 1111706706)
        {
          int v9 = 11;
        }
        else
        {
          if (v7 != 1128483922)
          {
            int v8 = 1129142560;
            goto LABEL_58;
          }
          int v9 = 12;
        }
      }
      else
      {
        switch(v7)
        {
          case 943934546:
            int v9 = 8;
            break;
          case 960711762:
            int v9 = 9;
            break;
          case 1094929490:
            int v9 = 10;
            break;
          default:
            goto LABEL_125;
        }
      }
    }
    else
    {
      if (v7 <= 893602897)
      {
        if (v7 == 843271250)
        {
          int v9 = 2;
          goto LABEL_60;
        }
        if (v7 == 860048466) {
          goto LABEL_59;
        }
        if (v7 != 876825682) {
          goto LABEL_125;
        }
        goto LABEL_114;
      }
      switch(v7)
      {
        case 893602898:
          int v9 = 5;
          break;
        case 910380114:
          int v9 = 6;
          break;
        case 927157330:
          int v9 = 7;
          break;
        default:
          goto LABEL_125;
      }
    }
  }
  else
  {
    if (v7 > 1213421087)
    {
      if (v7 <= 1380401695)
      {
        if (v7 == 1213421088 || v7 == 1281450528) {
          goto LABEL_59;
        }
        int v8 = 1282766368;
      }
      else
      {
        if (v7 <= 1497588337)
        {
          if (v7 != 1380401696)
          {
            int v8 = 1482250784;
            goto LABEL_58;
          }
LABEL_59:
          int v9 = 3;
          goto LABEL_60;
        }
        if (v7 == 1497588338) {
          goto LABEL_59;
        }
        int v8 = 1501067552;
      }
LABEL_58:
      if (v7 == v8) {
        goto LABEL_59;
      }
LABEL_125:
      uint64_t v20 = 0;
      long long v18 = 0u;
      long long v19 = 0u;
      kdu_error::kdu_error((kdu_error *)&v18, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v18 + 16))(&v18, "Unknown colour space signature found in embedded ICC profile within a JP2-family data source's colour description (colr) box.");
      kdu_error::~kdu_error((kdu_error *)&v18);
    }
    if (v7 <= 1178815569)
    {
      if (v7 != 1129142603)
      {
        if (v7 != 1145261138)
        {
          if (v7 == 1162038354)
          {
            int v9 = 14;
            goto LABEL_60;
          }
          goto LABEL_125;
        }
        int v9 = 13;
        goto LABEL_60;
      }
LABEL_114:
      int v9 = 4;
      goto LABEL_60;
    }
    if (v7 == 1178815570)
    {
      int v9 = 15;
    }
    else
    {
      if (v7 != 1196573017)
      {
        int v8 = 1212961568;
        goto LABEL_58;
      }
      int v9 = 1;
    }
  }
LABEL_60:
  *(_DWORD *)(this + 12) = v9;
  if (v6 >= 24) {
    int v7 = bswap32(*(_DWORD *)(*(void *)this + 20));
  }
  if (v7 == 1281450528)
  {
    *(unsigned char *)(this + 20) = 0;
  }
  else
  {
    if (v7 != 1482250784)
    {
      uint64_t v20 = 0;
      long long v18 = 0u;
      long long v19 = 0u;
      kdu_error::kdu_error((kdu_error *)&v18, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v18 + 16))(&v18, "Unknown PCS signature found in embedded ICC profile within a JP2-family data source's colour description (colr) box.");
      kdu_error::~kdu_error((kdu_error *)&v18);
    }
    *(unsigned char *)(this + 20) = 1;
  }
  if (v6 >= 132) {
    int v7 = bswap32(*(_DWORD *)(*(void *)this + 128));
  }
  *(_DWORD *)(this + 16) = v7;
  *(void *)(this + 28) = 0;
  uint64_t v10 = 40;
  *(_DWORD *)(this + 36) = 0;
  do
  {
    *(_DWORD *)(this + v10) = 0;
    v10 += 4;
  }
  while (v10 != 52);
  if (v7 >= 1)
  {
    int v11 = 0;
    int v12 = 140;
    do
    {
      *(void *)long long v17 = 0;
      unsigned int v16 = 0;
      if (!j2_icc_profile::read((j2_icc_profile *)v4, &v17[1], v12 - 8)
        || !j2_icc_profile::read((j2_icc_profile *)v4, v17, v12 - 4)
        || (this = j2_icc_profile::read((j2_icc_profile *)v4, &v16, v12), !this)
        || v17[0] >= 0x5F5E101)
      {
        uint64_t v20 = 0;
        long long v18 = 0u;
        long long v19 = 0u;
        kdu_error::kdu_error((kdu_error *)&v18, "Error in Kakadu File Format Support:\n");
        (*(void (**)(long long *, const char *))(v18 + 16))(&v18, "Embedded ICC profile in JP2 colour description box is corrupt!");
        kdu_error::~kdu_error((kdu_error *)&v18);
      }
      if ((int)v17[1] <= 1733843289)
      {
        switch(v17[1])
        {
          case 0x62545243u:
            this = j2_icc_profile::get_curve_data_offset((j2_icc_profile *)v4, v17[0], v16);
            *(_DWORD *)(v4 + 36) = this;
            break;
          case 0x6258595Au:
            this = j2_icc_profile::get_xyz_data_offset((j2_icc_profile *)v4, v17[0], v16);
            *(_DWORD *)(v4 + 48) = this;
            break;
          case 0x67545243u:
            this = j2_icc_profile::get_curve_data_offset((j2_icc_profile *)v4, v17[0], v16);
            *(_DWORD *)(v4 + 32) = this;
            break;
        }
        goto LABEL_94;
      }
      if ((int)v17[1] > 1918128706)
      {
        if (v17[1] != 1918128707)
        {
          if (v17[1] == 1918392666)
          {
            this = j2_icc_profile::get_xyz_data_offset((j2_icc_profile *)v4, v17[0], v16);
            *(_DWORD *)(v4 + 40) = this;
          }
          goto LABEL_94;
        }
      }
      else
      {
        if (v17[1] == 1733843290)
        {
          this = j2_icc_profile::get_xyz_data_offset((j2_icc_profile *)v4, v17[0], v16);
          *(_DWORD *)(v4 + 44) = this;
          goto LABEL_94;
        }
        if (v17[1] != 1800688195) {
          goto LABEL_94;
        }
      }
      this = j2_icc_profile::get_curve_data_offset((j2_icc_profile *)v4, v17[0], v16);
      *(_DWORD *)(v4 + 28) = this;
LABEL_94:
      ++v11;
      v12 += 12;
    }
    while (v11 < *(_DWORD *)(v4 + 16));
  }
  *(unsigned char *)(v4 + 24) = 0;
  int v13 = *(_DWORD *)(v4 + 12);
  if (v13 >= 4)
  {
    uint64_t v20 = 0;
    long long v18 = 0u;
    long long v19 = 0u;
    kdu_error::kdu_error((kdu_error *)&v18, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v18 + 16))(&v18, "Embedded ICC profile has wrong number of TRCs.");
    kdu_error::~kdu_error((kdu_error *)&v18);
  }
  if (v13 >= 1)
  {
    for (uint64_t i = 0; i < v13; ++i)
    {
      if (!*(_DWORD *)(v4 + 28 + 4 * i))
      {
        if (*(unsigned char *)(v4 + 21))
        {
          *(unsigned char *)(v4 + 24) = 1;
        }
        else if (*(unsigned char *)(v4 + 22))
        {
          uint64_t v20 = 0;
          long long v18 = 0u;
          long long v19 = 0u;
          kdu_error::kdu_error((kdu_error *)&v18, "Error in Kakadu File Format Support:\n");
          (*(void (**)(long long *, const char *))(v18 + 16))(&v18, "Embedded ICC profile in JP2 colour description box specifies a display profile, but does not contain a complete set of tone reproduction curves!  This condition is not compatible with any legal ICC profile.");
          kdu_error::~kdu_error((kdu_error *)&v18);
        }
      }
    }
    if (v13 == 3)
    {
      for (uint64_t j = 0; j != 12; j += 4)
      {
        if (!*(_DWORD *)(v4 + 40 + j))
        {
          if (*(unsigned char *)(v4 + 21))
          {
            *(unsigned char *)(v4 + 24) = 1;
          }
          else if (*(unsigned char *)(v4 + 22))
          {
            uint64_t v20 = 0;
            long long v18 = 0u;
            long long v19 = 0u;
            kdu_error::kdu_error((kdu_error *)&v18, "Error in Kakadu File Format Support:\n");
            (*(void (**)(long long *, const char *))(v18 + 16))(&v18, "Embedded ICC profile in JP2 colour description box specifies a 3 colour display profile, but does not contain a complete set of primary colorant specifications.");
            kdu_error::~kdu_error((kdu_error *)&v18);
          }
        }
      }
    }
  }
  return this;
}

void sub_188680BF8()
{
}

void sub_188680C00(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188680C0C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

BOOL j2_icc_profile::read(j2_icc_profile *this, unsigned int *a2, int a3)
{
  int v3 = *((_DWORD *)this + 2) - 3;
  if (v3 > a3)
  {
    uint64_t v4 = (unsigned __int8 *)(*(void *)this + a3);
    unsigned int v5 = *v4;
    *a2 = v5;
    int v6 = v4[1] | (v5 << 8);
    *a2 = v6;
    int v7 = v4[2] | (v6 << 8);
    *a2 = v7;
    *a2 = v4[3] | (v7 << 8);
  }
  return v3 > a3;
}

uint64_t j2_icc_profile::get_curve_data_offset(j2_icc_profile *this, int a2, int a3)
{
  if (a3 + a2 > *((_DWORD *)this + 2))
  {
    uint64_t v11 = 0;
    long long v9 = 0u;
    long long v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v9 + 16))(&v9, "Illegal tag offset or length value supplied in the JP2 embedded icc profile.");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  unsigned int v8 = 0;
  j2_icc_profile::read(this, &v8, a2);
  if (a3 < 12 || v8 != 1668641398)
  {
    uint64_t v11 = 0;
    long long v9 = 0u;
    long long v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  j2_icc_profile::read(this, &v8, a2 + 4);
  uint64_t v6 = (a2 + 8);
  j2_icc_profile::read(this, &v8, v6);
  if ((int)(2 * v8 + 12) > a3)
  {
    uint64_t v11 = 0;
    long long v9 = 0u;
    long long v10 = 0u;
    kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v9);
  }
  return v6;
}

void sub_188680EB4(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188680EC0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

uint64_t j2_icc_profile::get_xyz_data_offset(j2_icc_profile *this, int a2, int a3)
{
  if (a3 + a2 > *((_DWORD *)this + 2))
  {
    uint64_t v9 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v7 + 16))(&v7, "Illegal tag offset or length value supplied in JP2 embedded icc profile.");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  unsigned int v6 = 0;
  j2_icc_profile::read(this, &v6, a2);
  if (a3 < 20 || v6 != 1482250784)
  {
    uint64_t v9 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  return (a2 + 8);
}

void sub_188681018(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188681024(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

void j2_colour::j2_colour(j2_colour *this)
{
  uint64_t v1 = 0;
  *((void *)this + 13) = 0;
  *((_DWORD *)this + 24) = 0;
  *((unsigned char *)this + 100) = 0;
  *(unsigned char *)this = 0;
  *((_DWORD *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((_DWORD *)this + 12) = 0;
  *((void *)this + 7) = 0;
  *((_DWORD *)this + 22) = 0;
  *(void *)((char *)this + 12) = -1;
  *((_DWORD *)this + 5) = -1;
  *((_WORD *)this + 46) = 0;
  do
  {
    uint64_t v2 = (char *)this + v1;
    *((_DWORD *)v2 + 16) = -1;
    *((_DWORD *)v2 + 19) = 0;
    v1 += 4;
  }
  while (v1 != 12);
}

void j2_colour::~j2_colour(j2_colour *this)
{
  uint64_t v2 = *((void *)this + 7);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C8077774924);
  }
  int v3 = (void *)*((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v3) {
    std::default_delete<j2_icc_profile>::operator()[abi:ne180100]((uint64_t)this + 24, v3);
  }
}

uint64_t j2_colour::copy(j2_colour *this, j2_colour *a2)
{
  uint64_t result = *((void *)this + 7);
  if (result)
  {
    uint64_t result = MEMORY[0x18C11C0C0](result, 0x1000C8077774924);
    *((void *)this + 7) = 0;
    *((_DWORD *)this + 12) = 0;
  }
  *((_DWORD *)this + 24) = *((_DWORD *)a2 + 24);
  *((unsigned char *)this + 100) = *((unsigned char *)a2 + 100);
  *(unsigned char *)this = *(unsigned char *)a2;
  *(void *)((char *)this + 4) = *(void *)((char *)a2 + 4);
  if (*((void *)a2 + 3)) {
    operator new();
  }
  if (*((void *)a2 + 7))
  {
    for (uint64_t i = 0; i != 16; ++i)
      *((unsigned char *)this + i + 32) = *((unsigned char *)a2 + i + 32);
    *((_DWORD *)this + 12) = *((_DWORD *)a2 + 12);
    operator new[]();
  }
  uint64_t v6 = 0;
  long long v7 = (char *)a2 + 64;
  do
  {
    long long v8 = (_DWORD *)((char *)this + v6 + 64);
    *(v8 - 13) = *(_DWORD *)&v7[v6 - 52];
    *long long v8 = *(_DWORD *)&v7[v6];
    _OWORD v8[3] = *(_DWORD *)&v7[v6 + 12];
    v6 += 4;
  }
  while (v6 != 12);
  *((_DWORD *)this + 22) = *((_DWORD *)a2 + 22);
  *((_WORD *)this + 46) = *((_WORD *)a2 + 46);
  return result;
}

uint64_t j2_colour::init(j2_colour *this, jp2_input_box *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)a2 + 12) != 1668246642) {
    j2_colour::init();
  }
  if (*(unsigned char *)this || *((void *)this + 3)) {
    j2_colour::init();
  }
  __int16 v26 = 0;
  unsigned __int8 v25 = 0;
  if ((*(unsigned int (**)(jp2_input_box *, char *, uint64_t))(*(void *)a2 + 32))(a2, (char *)&v26 + 1, 1) != 1|| (*(unsigned int (**)(jp2_input_box *, __int16 *, uint64_t))(*(void *)a2 + 32))(a2, &v26, 1) != 1|| ((*(unsigned int (**)(jp2_input_box *, unsigned __int8 *, uint64_t))(*(void *)a2 + 32))(a2, &v25, 1) == 1? (v4 = v25 > 4u): (v4 = 1), !v4 ? (v5 = HIBYTE(v26) == 0) : (v5 = 1), !v5 ? (BOOL v6 = HIBYTE(v26) >= 5u) : (BOOL v6 = 1), v6))
  {
    uint64_t v24 = 0;
    long long v22 = 0u;
    long long v23 = 0u;
    kdu_error::kdu_error((kdu_error *)&v22, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v22);
  }
  unsigned int v7 = v26;
  if ((v26 & 0x80u) != 0) {
    unsigned int v7 = v26 | 0xFFFFFF00;
  }
  *((_DWORD *)this + 24) = v7;
  *(void *)((char *)this + 12) = -1;
  *((_DWORD *)this + 5) = -1;
  *((void *)this + 8) = -1;
  *((_DWORD *)this + 18) = -1;
  for (uint64_t i = 76; i != 88; i += 4)
    *(_DWORD *)((char *)this + i) = -1;
  *((_DWORD *)this + 22) = 0;
  *((_WORD *)this + 46) = 0;
  if (HIBYTE(v26) != 1)
  {
    if ((HIBYTE(v26) & 0xFE) == 2)
    {
      if (!*((unsigned char *)a2 + 125)
        && ((*((_DWORD *)a2 + 22) - *((_DWORD *)a2 + 34) + *((_DWORD *)a2 + 44)) & 0x80000000) == 0)
      {
        operator new[]();
      }
      uint64_t v24 = 0;
      long long v22 = 0u;
      long long v23 = 0u;
      kdu_error::kdu_error((kdu_error *)&v22, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v22 + 16))(&v22, "Malformed JP2 colour description (colr) box found in JP2-family data source.");
      kdu_error::~kdu_error((kdu_error *)&v22);
    }
    if (HIBYTE(v26) == 4)
    {
      *(void *)((char *)this + 4) = 200;
      if ((*(unsigned int (**)(jp2_input_box *, char *, uint64_t))(*(void *)a2 + 32))(a2, (char *)this + 32, 16) != 16)
      {
        uint64_t v24 = 0;
        long long v22 = 0u;
        long long v23 = 0u;
        kdu_error::kdu_error((kdu_error *)&v22, "Error in Kakadu File Format Support:\n");
        (*(void (**)(long long *, const char *))(v22 + 16))(&v22, "JP2-family data source terminated unexpectedly inside the colour specification (colr) box.");
        kdu_error::~kdu_error((kdu_error *)&v22);
      }
      if (*((unsigned char *)a2 + 125))
      {
        *((_DWORD *)this + 12) = -1;
      }
      else
      {
        int v12 = *((_DWORD *)a2 + 44) + *((_DWORD *)a2 + 22) - *((_DWORD *)a2 + 34);
        *((_DWORD *)this + 12) = v12;
        if (v12 >= 0)
        {
          uint64_t v13 = *((void *)this + 7);
          if (v13) {
            MEMORY[0x18C11C0C0](v13, 0x1000C8077774924);
          }
          operator new[]();
        }
      }
      uint64_t v24 = 0;
      long long v22 = 0u;
      long long v23 = 0u;
      kdu_error::kdu_error((kdu_error *)&v22, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v22 + 16))(&v22, "Malformed JP2 colour description (colr) box found in JP2-family data source.");
      kdu_error::~kdu_error((kdu_error *)&v22);
    }
    j2_colour::init();
  }
  v27[0] = 0;
  if (!jp2_input_box::read(a2, v27))
  {
    uint64_t v24 = 0;
    long long v22 = 0u;
    long long v23 = 0u;
    kdu_error::kdu_error((kdu_error *)&v22, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v22 + 16))(&v22, "Malformed colour description (colr) box found in JP2-family data source.  Box appears to terminate prematurely.");
    kdu_error::~kdu_error((kdu_error *)&v22);
  }
  unsigned int v9 = v27[0];
  if (v27[0] >= 0x19 || ((0x1FFFA1Bu >> SLOBYTE(v27[0])) & 1) == 0) {
    return (*(uint64_t (**)(jp2_input_box *))(*(void *)a2 + 16))(a2);
  }
  int v11 = dword_18898D4DC[v27[0]];
  *((_DWORD *)this + 1) = v27[0];
  *((_DWORD *)this + 2) = v11;
  if (v9 == 19 || v9 == 14)
  {
    unint64_t v14 = 0;
    *(void *)uint64_t v27 = 0;
    uint64_t v28 = 0;
    int v30 = 0;
    uint64_t v29 = 0;
    if (v9 == 14) {
      uint64_t v15 = 28;
    }
    else {
      uint64_t v15 = 24;
    }
    do
    {
      if (!jp2_input_box::read(a2, &v27[v14 / 4]))
      {
        if (v14)
        {
          uint64_t v24 = 0;
          long long v22 = 0u;
          long long v23 = 0u;
          kdu_error::kdu_error((kdu_error *)&v22, "Error in Kakadu File Format Support:\n");
          (*(void (**)(long long *, const char *))(v22 + 16))(&v22, "JP2-family data source terminated unexpectedly; unable to read all EP parameter fields for CIELab or CIEJab "
            "enumerated colour space.");
          kdu_error::~kdu_error((kdu_error *)&v22);
        }
        goto LABEL_66;
      }
      v14 += 4;
    }
    while (v15 != v14);
    uint64_t v16 = 0;
    long long v17 = &v27[1];
    do
    {
      long long v18 = (unsigned int *)((char *)this + v16 + 76);
      *(v18 - 3) = *(v17 - 1);
      unsigned int v19 = *v17;
      v17 += 2;
      *long long v18 = v19;
      v16 += 4;
    }
    while (v16 != 12);
    if (*((_DWORD *)this + 1) == 14)
    {
      int v20 = v30;
      *((_DWORD *)this + 22) = v30;
      if ((~v20 & 0x43540000) == 0)
      {
        *((_WORD *)this + 46) = v20;
        *((_DWORD *)this + 22) = 1129578496;
        goto LABEL_66;
      }
      switch(v20)
      {
        case 4470581:
          __int16 v21 = 7500;
          goto LABEL_64;
        case 4470325:
          __int16 v21 = 6500;
          goto LABEL_64;
        case 4470064:
          __int16 v21 = 5000;
LABEL_64:
          *((_WORD *)this + 46) = v21;
          goto LABEL_66;
      }
      *((_WORD *)this + 46) = 0;
    }
  }
LABEL_66:
  *(unsigned char *)this = 1;
  uint64_t result = (*(uint64_t (**)(jp2_input_box *))(*(void *)a2 + 16))(a2);
  if ((result & 1) == 0)
  {
    uint64_t v24 = 0;
    long long v22 = 0u;
    long long v23 = 0u;
    kdu_error::kdu_error((kdu_error *)&v22, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v22 + 16))(&v22, "Malformed JP2 colour description (colr) box found in JP2-family data source.  The box appears to be too large.");
    kdu_error::~kdu_error((kdu_error *)&v22);
  }
  return result;
}

void sub_188681AE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188681AF4()
{
  _Unwind_Resume(v0);
}

int32x2_t j2_colour::finalize(j2_colour *this, j2_channels *a2)
{
  if (*(unsigned char *)this)
  {
    BOOL v5 = (int *)((char *)this + 8);
    int v4 = *((_DWORD *)this + 2);
    if (!v4)
    {
      if (!a2) {
        jp2_channels::get_num_colours();
      }
      int v4 = *((_DWORD *)a2 + 1);
      int *v5 = v4;
    }
  }
  else
  {
    *(unsigned char *)this = 1;
    BOOL v5 = (int *)((char *)this + 8);
    int32x2_t result = (int32x2_t)0x40000000CLL;
    *(void *)((char *)this + 4) = 0x40000000CLL;
    int v4 = 4;
  }
  int v7 = *((_DWORD *)this + 1);
  if ((v7 == 19 || v7 == 14) && v4 >= 1)
  {
    uint64_t v10 = 0;
    int v11 = (char *)this + 12;
    do
    {
      int bit_depth = j2_channels::get_bit_depth(a2, v10);
      int v13 = *(_DWORD *)&v11[4 * v10];
      if (v13 < 0)
      {
        *(_DWORD *)&v11[4 * v10] = bit_depth;
      }
      else if (v13 != bit_depth)
      {
        int v14 = *((_DWORD *)this + 1);
        if (v14 != 14 && v14 != 19) {
          j2_colour::finalize();
        }
        uint64_t v18 = 0;
        memset(v17, 0, sizeof(v17));
        kdu_error::kdu_error((kdu_error *)v17, "Error in Kakadu File Format Support:\n");
        kdu_error::~kdu_error((kdu_error *)v17);
      }
      ++v10;
    }
    while (v10 < *v5);
    int v7 = *((_DWORD *)this + 1);
  }
  if (v7 == 19)
  {
    if (*((int *)this + 16) <= 0)
    {
      *((_OWORD *)this + 4) = xmmword_18898D170;
      int32x2_t result = vshr_n_s32((int32x2_t)vshl_u32((uint32x2_t)0x100000001, *(uint32x2_t *)((char *)this + 16)), 1uLL);
      *((int32x2_t *)this + 10) = result;
    }
  }
  else if (v7 == 14)
  {
    if (*((int *)this + 16) <= 0)
    {
      int32x2_t result = (int32x2_t)0xAA00000064;
      *((_OWORD *)this + 4) = xmmword_18898D180;
      int v16 = (1 << *((_DWORD *)this + 5) >> 2) + (1 << *((_DWORD *)this + 5) >> 3);
      *((_DWORD *)this + 20) = 1 << *((_DWORD *)this + 4) >> 1;
      *((_DWORD *)this + 21) = v16;
    }
    if (!*((_DWORD *)this + 22) && !*((_WORD *)this + 46)) {
      *((_DWORD *)this + 22) = 4470064;
    }
  }
  return result;
}

void sub_188681D68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188681D74()
{
  _Unwind_Resume(v0);
}

uint64_t j2_channels::get_bit_depth(j2_channels *this, unsigned int a2)
{
  if (*((_DWORD *)this + 1) <= a2)
  {
    exception = __cxa_allocate_exception(4uLL);
    _DWORD *exception = -50;
    __cxa_throw(exception, MEMORY[0x1E4FBA3A8], 0);
  }
  return *(unsigned int *)(*((void *)this + 1) + ((uint64_t)(int)a2 << 6) + 56);
}

uint64_t j2_colour::save_box(j2_colour *this, jp2_output_box *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)this) {
    j2_colour::save_box();
  }
  long long v14 = 0uLL;
  uint64_t v18 = 0;
  int v13 = (void (**)(void **, void *, uint64_t))&unk_1ED4E3098;
  long long v15 = 0uLL;
  long long v16 = 0uLL;
  long long v17 = 0xFFFFFFFFFFFFFFFFLL;
  jp2_output_box::open((uint64_t)&v13, a2, 1668246642, 0);
  int v3 = *((_DWORD *)this + 1);
  if ((v3 - 100) < 2)
  {
    LOBYTE(v20[0]) = 2;
    v13[5]((void **)&v13, v20, 1);
    LOBYTE(v20[0]) = *((_DWORD *)this + 24);
    v13[5]((void **)&v13, v20, 1);
    LOBYTE(v20[0]) = *((unsigned char *)this + 100);
    v13[5]((void **)&v13, v20, 1);
    jp2_output_box::write((jp2_output_box *)&v13, **((const unsigned __int8 ***)this + 3), *(unsigned int *)(*((void *)this + 3) + 8));
  }
  else if (v3 == 102)
  {
    LOBYTE(v20[0]) = 3;
    v13[5]((void **)&v13, v20, 1);
    LOBYTE(v20[0]) = *((_DWORD *)this + 24);
    v13[5]((void **)&v13, v20, 1);
    LOBYTE(v20[0]) = *((unsigned char *)this + 100);
    v13[5]((void **)&v13, v20, 1);
    jp2_output_box::write((jp2_output_box *)&v13, **((const unsigned __int8 ***)this + 3), *(unsigned int *)(*((void *)this + 3) + 8));
  }
  else if (v3 == 200)
  {
    LOBYTE(v20[0]) = 4;
    v13[5]((void **)&v13, v20, 1);
    LOBYTE(v20[0]) = *((_DWORD *)this + 24);
    v13[5]((void **)&v13, v20, 1);
    LOBYTE(v20[0]) = *((unsigned char *)this + 100);
    v13[5]((void **)&v13, v20, 1);
    jp2_output_box::write((jp2_output_box *)&v13, (const unsigned __int8 *)this + 32, 0x10uLL);
    jp2_output_box::write((jp2_output_box *)&v13, *((const unsigned __int8 **)this + 7), *((unsigned int *)this + 12));
  }
  else
  {
    LOBYTE(v20[0]) = 1;
    v13[5]((void **)&v13, v20, 1);
    LOBYTE(v20[0]) = *((_DWORD *)this + 24);
    v13[5]((void **)&v13, v20, 1);
    LOBYTE(v20[0]) = *((unsigned char *)this + 100);
    v13[5]((void **)&v13, v20, 1);
    LODWORD(v20[0]) = bswap32(*((_DWORD *)this + 1));
    v13[5]((void **)&v13, v20, 4);
    int v4 = *((_DWORD *)this + 1);
    if (v4 == 19 || v4 == 14)
    {
      uint64_t v5 = 0;
      memset(v20, 0, sizeof(v20));
      int v21 = 0;
      BOOL v6 = (_DWORD *)((char *)this + 64);
      do
      {
        if ((*(v6 - 13) & 0x80000000) != 0 || (int v7 = v6[3], v7 < 0) || (*v6 & 0x80000000) != 0) {
          __assert_rtn("save_box", "jp2.cpp", 4869, "(precision[c]>=0) && (offset[c]>=0) && (range[c]>=0)");
        }
        long long v8 = &v20[v5];
        *long long v8 = *v6;
        v8[1] = v7;
        ++v5;
        ++v6;
      }
      while (v5 != 3);
      if (v4 == 14)
      {
        int v21 = *((_DWORD *)this + 22);
        if (v21 == 1129578496) {
          int v21 = *((unsigned __int16 *)this + 46) | 0x43540000;
        }
        uint64_t v9 = 7;
      }
      else
      {
        uint64_t v9 = 6;
      }
      uint64_t v10 = 0;
      uint64_t v11 = 4 * v9;
      do
      {
        unsigned int v19 = bswap32(*(_DWORD *)((char *)v20 + v10));
        ((void (**)(void **, unsigned int *, uint64_t))v13)[5]((void **)&v13, &v19, 4);
        v10 += 4;
      }
      while (v11 != v10);
    }
  }
  jp2_output_box::close((jp2_output_box *)&v13);
  int v13 = (void (**)(void **, void *, uint64_t))&unk_1ED4E3098;
  uint64_t result = *((void *)&v17 + 1);
  if (*((void *)&v17 + 1)) {
    return MEMORY[0x18C11C0C0](*((void *)&v17 + 1), 0x1000C8077774924);
  }
  return result;
}

void sub_18868234C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL j2_colour::is_jp2_compatible(j2_colour *this)
{
  if (!*(unsigned char *)this) {
    return 0;
  }
  int v1 = *((_DWORD *)this + 1);
  unsigned int v2 = v1 - 16;
  BOOL v3 = (v1 - 100) < 2;
  return v2 < 3 || v3;
}

uint64_t *jp2_colour::init(uint64_t *result, int a2)
{
  uint64_t v2 = *result;
  if (!*result) {
    jp2_colour::init();
  }
  if (*(unsigned char *)v2)
  {
    uint64_t v7 = 0;
    long long v5 = 0u;
    long long v6 = 0u;
    kdu_error::kdu_error((kdu_error *)&v5, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v5);
  }
  *(void *)(v2 + 64) = -1;
  *(_DWORD *)(v2 + 72) = -1;
  for (uint64_t i = 76; i != 88; i += 4)
    *(_DWORD *)(v2 + i) = -1;
  *(_DWORD *)(v2 + 88) = 0;
  *(_WORD *)(v2 + 92) = 0;
  *(_DWORD *)(v2 + 4) = a2;
  switch(a2)
  {
    case 0:
    case 15:
    case 17:
      int v4 = 1;
      break;
    case 1:
    case 3:
    case 4:
    case 9:
    case 11:
    case 14:
    case 16:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
      int v4 = 3;
      break;
    case 12:
    case 13:
      int v4 = 4;
      break;
    default:
      uint64_t v7 = 0;
      long long v5 = 0u;
      long long v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)&v5);
  }
  *(_DWORD *)(v2 + 8) = v4;
  *(unsigned char *)uint64_t v2 = 1;
  return result;
}

void sub_188682530(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18868253C()
{
  _Unwind_Resume(v0);
}

void jp2_colour::init(jp2_colour *this, unsigned __int8 *a2, unsigned int a3)
{
  if (*(void *)this)
  {
    if (**(unsigned char **)this)
    {
      *(void *)&long long v5 = 0;
      *(_OWORD *)BOOL v3 = 0u;
      long long v4 = 0u;
      kdu_error::kdu_error((kdu_error *)v3, "Error in Kakadu File Format Support:\n");
      kdu_error::~kdu_error((kdu_error *)v3);
    }
    uint64_t v6 = 0;
    long long v4 = 0u;
    long long v5 = 0u;
    *(_OWORD *)BOOL v3 = 0u;
    j2_icc_profile::init((uint64_t)v3, a2, a3, 0);
    operator new();
  }
  jp2_colour::init();
}

void sub_188682734(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188682740(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9)
{
  _Unwind_Resume(v9);
}

BOOL j2_icc_profile::is_restricted(j2_icc_profile *this)
{
  return *((unsigned char *)this + 20)
      && (*((_DWORD *)this + 3) | 2) == 3
      && (*((unsigned char *)this + 21) || *((unsigned char *)this + 22))
      && *((unsigned char *)this + 24) == 0;
}

double *find_monitor_matrix(double *result, double *a2, double *a3, const double *a4, double *a5)
{
  uint64_t v5 = 0;
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  double v28 = 0.0;
  double v29 = 0.0;
  double v26 = 0.0;
  double v27 = 0.0;
  double v24 = 0.0;
  double v25 = 0.0;
  char v6 = 1;
  do
  {
    double v7 = a3[v5];
    *(&v28 + v5) = result[v5] - v7;
    *(&v26 + v5) = a2[v5] - v7;
    char v8 = v6;
    *(&v24 + v5) = a4[v5] - v7;
    uint64_t v5 = 1;
    char v6 = 0;
  }
  while ((v8 & 1) != 0);
  uint64_t v9 = 0;
  double v10 = v28 * v27 - v26 * v29;
  double v11 = (v27 * v24 - v26 * v25) / v10;
  double v12 = (v28 * v25 - v29 * v24) / v10;
  double v13 = result[1];
  v23[0] = *result;
  v23[1] = v13;
  v23[2] = 1.0 - v23[0] - v13;
  double v14 = a2[1];
  v22[0] = *a2;
  v22[1] = v14;
  _OWORD v22[2] = 1.0 - v22[0] - v14;
  double v15 = a3[1];
  v21[0] = *a3;
  v21[1] = v15;
  _OWORD v21[2] = 1.0 - v21[0] - v15;
  long long v16 = a5 + 1;
  do
  {
    double v17 = v12 * v22[v9];
    double v18 = (1.0 - v11 - v12) * v21[v9];
    *(v16 - 1) = v11 * v23[v9];
    double *v16 = v17;
    v16[1] = v18;
    v16 += 3;
    ++v9;
  }
  while (v9 != 3);
  uint64_t v19 = 0;
  double v20 = 1.0 / a4[1];
  do
  {
    a5[v19] = v20 * a5[v19];
    ++v19;
  }
  while (v19 != 9);
  return result;
}

uint64_t find_matrix_inverse(double *a1, const double *a2, double *a3, double *a4)
{
  for (uint64_t i = 0; i != 9; ++i)
    a3[i] = a2[i];
  LODWORD(v5) = 0;
  for (int j = 0; j != 3; ++j)
  {
    int v7 = 0;
    uint64_t v5 = (int)v5;
    do
    {
      if (j == v7) {
        double v8 = 1.0;
      }
      else {
        double v8 = 0.0;
      }
      a1[v5] = v8;
      ++v7;
      ++v5;
    }
    while (v7 != 3);
  }
  unint64_t v9 = 0;
  double v10 = a3 + 3;
  double v11 = a1 + 3;
  uint64_t v12 = 1;
  double v13 = a1;
  double v14 = a3;
  double v15 = a3;
  do
  {
    double v16 = a3[4 * v9];
    if (v16 < 0.0) {
      double v16 = -v16;
    }
    double v17 = v15;
    unint64_t v18 = v9;
    int v19 = v9;
    do
    {
      double v20 = *v17;
      if (*v17 <= v16)
      {
        if (v20 < -v16)
        {
          double v16 = -v20;
          int v19 = v18;
        }
      }
      else
      {
        int v19 = v18;
        double v16 = *v17;
      }
      ++v18;
      v17 += 3;
    }
    while (v18 != 3);
    uint64_t v21 = 0;
    uint64_t v22 = 3 * v19;
    double v23 = 1.0 / a3[v9 + v22];
    double v24 = &a3[v22];
    do
    {
      double v25 = v14[v21];
      v14[v21] = v23 * v24[v21];
      v24[v21++] = v23 * v25;
    }
    while (v21 != 3);
    uint64_t v26 = 0;
    double v27 = &a1[v22];
    do
    {
      double v28 = v13[v26];
      v13[v26] = v23 * v27[v26];
      v27[v26++] = v23 * v28;
    }
    while (v26 != 3);
    if (v9 <= 1)
    {
      double v29 = v11;
      uint64_t v30 = v10;
      uint64_t v31 = v12;
      do
      {
        uint64_t v32 = 0;
        double v33 = -a3[3 * v31 + v9];
        do
        {
          v30[v32] = v30[v32] + v33 * v14[v32];
          ++v32;
        }
        while (v32 != 3);
        for (uint64_t k = 0; k != 3; ++k)
          v29[k] = v29[k] + v33 * v13[k];
        ++v31;
        v30 += 3;
        v29 += 3;
      }
      while (v31 != 3);
    }
    ++v9;
    ++v12;
    v15 += 4;
    v14 += 3;
    v13 += 3;
    v10 += 3;
    v11 += 3;
  }
  while (v9 != 3);
  uint64_t v35 = a3 + 3;
  char v36 = a3 + 6;
  char v37 = a1 + 3;
  BOOL v38 = a1 + 6;
  unint64_t v39 = 2;
  do
  {
    uint64_t v40 = v37;
    int v41 = v35;
    unint64_t v42 = v39;
    do
    {
      uint64_t v43 = 0;
      unint64_t v44 = v42--;
      uint64_t result = (3 * v42 + v39);
      double v46 = -a3[result];
      do
      {
        v41[v43] = v41[v43] + v46 * v36[v43];
        ++v43;
      }
      while (v43 != 3);
      for (uint64_t m = 0; m != 3; ++m)
        v40[m] = v40[m] + v46 * v38[m];
      v41 -= 3;
      v40 -= 3;
    }
    while (v44 >= 2);
    v35 -= 3;
    v36 -= 3;
    v37 -= 3;
    v38 -= 3;
  }
  while (v39-- > 1);
  return result;
}

uint64_t jp2_colour::get_num_colours(jp2_colour *this)
{
  if (!*(void *)this) {
    jp2_colour::get_num_colours();
  }
  return *(unsigned int *)(*(void *)this + 8);
}

uint64_t jp2_colour::get_space(jp2_colour *this)
{
  if (!*(void *)this) {
    jp2_colour::get_space();
  }
  return *(unsigned int *)(*(void *)this + 4);
}

uint64_t jp2_colour::is_opponent_space(jp2_colour *this)
{
  if (!*(void *)this) {
    jp2_colour::is_opponent_space();
  }
  return (*(_DWORD *)(*(void *)this + 4) < 0x19u) & (0x1CC621Au >> *(_DWORD *)(*(void *)this + 4));
}

uint64_t jp2_colour::get_precedence(jp2_colour *this)
{
  if (!*(void *)this) {
    jp2_colour::get_precedence();
  }
  return *(unsigned int *)(*(void *)this + 96);
}

uint64_t jp2_colour::get_icc_profile(jp2_colour *this, int *a2)
{
  if (!*(void *)this) {
    return 0;
  }
  uint64_t v2 = *(_DWORD **)(*(void *)this + 24);
  if (!v2) {
    return 0;
  }
  if (a2) {
    *a2 = v2[2];
  }
  return *(void *)v2;
}

void j2_colour_converter::j2_colour_converter(j2_colour_converter *this, j2_colour *a2, int a3, int a4)
{
  *(unsigned char *)this = a3;
  if (a3) {
    int v4 = 14;
  }
  else {
    int v4 = 13;
  }
  *((_DWORD *)this + 1) = v4;
  int v5 = *((_DWORD *)a2 + 2);
  if (v5 < 3) {
    int v6 = 1;
  }
  else {
    int v6 = 3;
  }
  *((_DWORD *)this + 2) = v6;
  *((void *)this + 16) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 15) = 0;
  *((unsigned char *)this + 12) = 0;
  *((unsigned char *)this + 15) = 0;
  *((void *)this + 28) = 0;
  *((void *)this + 29) = 0;
  if (v5 <= 0) {
    j2_colour_converter::j2_colour_converter();
  }
  *(_WORD *)((char *)this + 13) = 1;
  *((unsigned char *)this + 112) = 1;
  *((unsigned char *)this + 144) = 1;
  double v10 = (char *)this + 16;
  bzero((char *)this + 16, (4 * v6));
  int v13 = 0;
  for (int i = 0; i != v6; ++i)
  {
    int v15 = 0;
    double v16 = (float *)((char *)this + 4 * v13 + 148);
    v13 += v6;
    do
    {
      if (i == v15) {
        float v17 = 1.0;
      }
      else {
        float v17 = 0.0;
      }
      float *v16 = v17;
      *(v16 - 27) = v17;
      ++v15;
      ++v16;
    }
    while (v6 != v15);
  }
  int v18 = *((_DWORD *)a2 + 1);
  switch(v18)
  {
    case 0:
      *(unsigned char *)this = 0;
      *((_DWORD *)this + 1) = 13;
      operator new[]();
    case 1:
      *((void *)this + 2) = 0x800000003C200000;
      *((_DWORD *)this + 6) = 0x80000000;
      *(_OWORD *)((char *)this + 40) = xmmword_18898D1F0;
      *(_OWORD *)((char *)this + 56) = xmmword_18898D200;
      *((_DWORD *)this + 18) = -1085214827;
      *((unsigned char *)this + 13) = 0;
      if (!a4) {
        goto LABEL_28;
      }
      goto LABEL_26;
    case 2:
    case 5:
    case 6:
    case 7:
    case 8:
    case 10:
    case 19:
      goto LABEL_34;
    case 3:
      *((void *)this + 2) = 0x8000000000000000;
      *((_DWORD *)this + 6) = 0x80000000;
      *(_OWORD *)((char *)this + 40) = xmmword_18898D190;
      *(_OWORD *)((char *)this + 56) = xmmword_18898D1A0;
      *((_DWORD *)this + 18) = -1086926429;
      *(_WORD *)((char *)this + 13) = 256;
      if (a4) {
        goto LABEL_24;
      }
      goto LABEL_42;
    case 4:
      *((void *)this + 2) = 0x800000003C200000;
      *((_DWORD *)this + 6) = 0x80000000;
      *(_OWORD *)((char *)this + 40) = xmmword_18898D1F0;
      *(_OWORD *)((char *)this + 56) = xmmword_18898D200;
      *((_DWORD *)this + 18) = -1085214827;
      *((unsigned char *)this + 13) = 0;
      if (!a4)
      {
LABEL_42:
        int v19 = (double *)&xy_601_red;
        double v20 = (double *)&xy_601_green;
        uint64_t v21 = (double *)&xy_601_blue;
LABEL_43:
        j2_colour_converter::configure_d65_primary_transform(this, v19, v20, v21, 2.22222222, 0.099);
      }
LABEL_26:
      *((unsigned char *)this + 12) = 1;
      *((unsigned char *)this + 14) = 1;
LABEL_44:
      if (*((_DWORD *)this + 2) == 3)
      {
        for (uint64_t j = 0; j != 12; j += 4)
          *(_DWORD *)((char *)this + j + 28) = vcvtmd_s64_f64((float)(*(float *)((char *)this + j + 16) * 8192.0) + 0.5);
        for (uint64_t k = 0; k != 36; k += 4)
          *(_DWORD *)((char *)this + k + 76) = vcvtmd_s64_f64((float)(*(float *)((char *)this + k + 40) * 4096.0) + 0.5);
        for (uint64_t m = 0; m != 36; m += 4)
          *(_DWORD *)((char *)this + m + 184) = vcvtmd_s64_f64((float)(*(float *)((char *)this + m + 148) * 4096.0) + 0.5);
      }
      return;
    case 9:
      *((void *)this + 2) = 0xBDE00D1B3E12CA58;
      *((_DWORD *)this + 6) = -1123013152;
      *(_OWORD *)((char *)this + 40) = xmmword_18898D1D0;
      *(_OWORD *)((char *)this + 56) = xmmword_18898D1E0;
      *((_DWORD *)this + 18) = -1082777844;
      *((unsigned char *)this + 13) = 0;
LABEL_28:
      int v19 = xy_709_red;
      double v20 = xy_709_green;
      uint64_t v21 = xy_709_blue;
      goto LABEL_43;
    case 11:
      *((_DWORD *)this + 10) = -1082130432;
      *((_DWORD *)this + 14) = -1082130432;
      *((_DWORD *)this + 18) = -1082130432;
      goto LABEL_32;
    case 12:
      *((unsigned char *)this + 15) = 1;
      goto LABEL_44;
    case 13:
      *((void *)this + 2) = 0x8000000000000000;
      *((_DWORD *)this + 6) = 0x80000000;
      *(_OWORD *)((char *)this + 40) = xmmword_18898D190;
      *(_OWORD *)((char *)this + 56) = xmmword_18898D1A0;
      *((_DWORD *)this + 18) = -1086926429;
      *((unsigned char *)this + 14) = 1;
LABEL_32:
      *((_WORD *)this + 6) = 1;
      goto LABEL_44;
    case 14:
      if ((j2_colour_converter::configure_lab_transform(this, a2, v11, v12) & 1) == 0) {
        goto LABEL_34;
      }
      goto LABEL_44;
    case 15:
      *(unsigned char *)this = 0;
      *((_DWORD *)this + 1) = 13;
      operator new[]();
    case 16:
    case 17:
      goto LABEL_44;
    case 18:
      *((void *)this + 2) = 0x8000000000000000;
      *((_DWORD *)this + 6) = 0x80000000;
      *(_OWORD *)((char *)this + 40) = xmmword_18898D190;
      *(_OWORD *)((char *)this + 56) = xmmword_18898D1A0;
      *((_DWORD *)this + 18) = -1086926429;
      *(_WORD *)((char *)this + 13) = 256;
      goto LABEL_44;
    case 20:
      memset_pattern16(v10, &unk_18898D270, 0xCuLL);
      *((_DWORD *)this + 10) = 0x40000000;
      *((_DWORD *)this + 14) = 0x40000000;
      *((_DWORD *)this + 18) = 0x40000000;
      *((unsigned char *)this + 13) = 0;
      goto LABEL_44;
    case 21:
      j2_colour_converter::configure_d65_primary_transform(this, dbl_18898D240, dbl_18898D250, dbl_18898D260, 1.8, 0.0);
    case 22:
    case 23:
      *((void *)this + 2) = 0x800000003C200000;
      *((_DWORD *)this + 6) = 0x80000000;
      *(_OWORD *)((char *)this + 40) = xmmword_18898D1B0;
      *(_OWORD *)((char *)this + 56) = xmmword_18898D1C0;
      *((_DWORD *)this + 18) = -1089766529;
      *((unsigned char *)this + 13) = 0;
      if (a4)
      {
LABEL_24:
        *((unsigned char *)this + 12) = 1;
        goto LABEL_44;
      }
      int v19 = (double *)&xy_240m_red;
      double v20 = (double *)&xy_240m_green;
      uint64_t v21 = (double *)&xy_240m_blue;
      goto LABEL_43;
    case 24:
      uint64_t v22 = 0;
      *((void *)this + 2) = 0x8000000000000000;
      *((_DWORD *)this + 6) = 0x80000000;
      *(_OWORD *)((char *)this + 40) = xmmword_18898D190;
      *(_OWORD *)((char *)this + 56) = xmmword_18898D1A0;
      *((_DWORD *)this + 18) = -1086926429;
      *((unsigned char *)this + 13) = 0;
      do
      {
        *(float32x2_t *)((char *)this + v22 + 44) = vadd_f32(*(float32x2_t *)((char *)this + v22 + 44), *(float32x2_t *)((char *)this + v22 + 44));
        v22 += 12;
      }
      while (v22 != 36);
      goto LABEL_44;
    default:
      if ((v18 - 100) < 3) {
        goto LABEL_44;
      }
LABEL_34:
      *((_DWORD *)this + 2) = 0;
      return;
  }
}

void j2_colour_converter::configure_d65_primary_transform(j2_colour_converter *this, double *a2, double *a3, double *a4, double a5, double a6)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t v36 = 0;
  memset(v35, 0, sizeof(v35));
  uint64_t v34 = 0;
  memset(v33, 0, sizeof(v33));
  uint64_t v32 = 0;
  memset(v31, 0, sizeof(v31));
  uint64_t v30 = 0;
  memset(v29, 0, sizeof(v29));
  find_monitor_matrix(xy_709_red, xy_709_green, xy_709_blue, xy_D65_white, (double *)v35);
  find_monitor_matrix(a2, a3, a4, xy_D65_white, (double *)v33);
  double v10 = v31;
  find_matrix_inverse((double *)v31, (const double *)v35, (double *)v29, v11);
  for (uint64_t i = 0; i != 3; ++i)
  {
    uint64_t v13 = 0;
    double v14 = v33;
    do
    {
      uint64_t v15 = 0;
      double v16 = 0.0;
      float v17 = (double *)v14;
      do
      {
        double v18 = *v17;
        v17 += 3;
        double v16 = v16 + *(double *)((char *)v10 + v15) * v18;
        v15 += 8;
      }
      while (v15 != 24);
      *((double *)v29 + 3 * i + v13++) = v16;
      double v14 = (_OWORD *)((char *)v14 + 8);
    }
    while (v13 != 3);
    double v10 = (_OWORD *)((char *)v10 + 24);
  }
  int v19 = 0;
  int v20 = 0;
  *((unsigned char *)this + 144) = 1;
  while (1)
  {
    uint64_t v21 = 0;
    int v22 = v20;
    double v23 = (char *)v29 + 8 * v20;
    double v24 = (char *)this + 4 * v20 + 148;
    do
    {
      double v25 = *(double *)&v23[8 * v21];
      float v26 = v25;
      *(float *)&v24[4 * v21] = v26;
      if (v19 == v21) {
        double v27 = 1.0;
      }
      else {
        double v27 = 0.0;
      }
      double v28 = v27 - v25;
      if (v28 < -0.01 || v28 > 0.01) {
        *((unsigned char *)this + 144) = 0;
      }
      ++v21;
    }
    while (v21 != 3);
    ++v19;
    int v20 = v22 + 3;
    if (v19 == 3)
    {
      if (!*((void *)this + 28) && !*((void *)this + 15) && !*((void *)this + 16) && !*((void *)this + 17)) {
        operator new[]();
      }
      j2_colour_converter::configure_d65_primary_transform();
    }
  }
}

uint64_t j2_colour_converter::configure_lab_transform(j2_colour_converter *this, j2_colour *a2, uint64_t a3, double *a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)a2 + 1) == 14)
  {
    int v5 = *((_DWORD *)a2 + 22);
    if (v5 != 4470064)
    {
      if (v5 == 1129578496)
      {
        int v6 = *((unsigned __int16 *)a2 + 46);
        if (v6 != 6500 && v6 != 5000) {
          return 0;
        }
      }
      else if (v5 != 4470325)
      {
        return 0;
      }
    }
    int v7 = *((_DWORD *)a2 + 16);
    if (v7 >= 1)
    {
      int v8 = *((_DWORD *)a2 + 17);
      if (v8 >= 1)
      {
        int v9 = *((_DWORD *)a2 + 18);
        if (v9 >= 1 && *((int *)a2 + 3) >= 1 && *((int *)a2 + 4) >= 1 && *((int *)a2 + 5) >= 1)
        {
          uint64_t v10 = 0;
          *((unsigned char *)this + 144) = 0;
          *((unsigned char *)this + 112) = 0;
          *((unsigned char *)this + 13) = 0;
          do
          {
            *(float *)((char *)this + v10 + 16) = 0.5
                                                - (float)((float)*(int *)((char *)a2 + v10 + 76)
                                                        / (float)~(-1 << *(_DWORD *)((char *)a2 + v10 + 12)));
            v10 += 4;
          }
          while (v10 != 12);
          uint64_t v11 = 0;
          v21[0] = 0.0;
          v21[1] = 100.0 / (double)v7;
          float64x2_t v22 = vdivq_f64((float64x2_t)xmmword_18898D210, (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v8), 0));
          uint64_t v23 = 0;
          uint64_t v24 = 0;
          _OWORD v21[2] = 0.0;
          float64x2_t v25 = vdivq_f64((float64x2_t)xmmword_18898D220, (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)v9), 0));
          uint64_t v12 = (float *)((char *)this + 16);
          do
          {
            float v13 = v21[v11] + v21[v11 + 1] + v21[v11 + 2];
            float *v12 = *v12 + (float)(v13 * -0.5);
            ++v12;
            v11 += 3;
          }
          while (v11 != 9);
          uint64_t v20 = 0;
          memset(v19, 0, sizeof(v19));
          uint64_t v18 = 0;
          memset(v17, 0, sizeof(v17));
          find_matrix_inverse((double *)v17, v21, (double *)v19, a4);
          for (uint64_t i = 0; i != 9; ++i)
          {
            float v15 = *((double *)v17 + i);
            *((float *)this + i + 10) = v15;
          }
          if (!*((void *)this + 15)) {
            operator new[]();
          }
          j2_colour_converter::configure_lab_transform();
        }
      }
    }
  }
  return 0;
}

void j2_colour_converter::~j2_colour_converter(j2_colour_converter *this)
{
  for (uint64_t i = 120; i != 144; i += 8)
  {
    uint64_t v3 = *(void *)((char *)this + i);
    if (v3)
    {
      MEMORY[0x18C11C0C0](v3, 0x1000C80BDFB0063);
      *(void *)((char *)this + i) = 0;
    }
  }
  uint64_t v4 = *((void *)this + 28);
  if (v4)
  {
    MEMORY[0x18C11C0C0](v4, 0x1000C80BDFB0063);
    *((void *)this + 28) = 0;
  }
  uint64_t v5 = *((void *)this + 29);
  if (v5)
  {
    MEMORY[0x18C11C0C0](v5, 0x1000C80BDFB0063);
    *((void *)this + 29) = 0;
  }
}

j2_colour_converter *jp2_colour_converter::clear(j2_colour_converter **this)
{
  uint64_t result = *this;
  if (result)
  {
    j2_colour_converter::~j2_colour_converter(result);
    uint64_t result = (j2_colour_converter *)MEMORY[0x18C11C0E0]();
  }
  *this = 0;
  return result;
}

void jp2_colour_converter::init(j2_colour_converter **a1)
{
  if (*a1) {
    jp2_colour_converter::clear(a1);
  }
  operator new();
}

void sub_18868402C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1010C404873F55BLL);
  _Unwind_Resume(a1);
}

BOOL jp2_colour_converter::is_non_trivial(jp2_colour_converter *this)
{
  uint64_t v1 = *(void *)this;
  if (!*(void *)this) {
    return 0;
  }
  if (*(unsigned char *)(v1 + 13) && *(unsigned char *)(v1 + 112)) {
    return *(void *)(v1 + 232) != 0;
  }
  return 1;
}

uint64_t jp2_colour_converter::convert_lum(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v3 = *a1;
  if (!*a1 || *(_DWORD *)(v3 + 8) != 1) {
    return 0;
  }
  uint64_t v4 = *(void *)(v3 + 232);
  if (v4)
  {
    if (a3 >= 0) {
      int v5 = a3;
    }
    else {
      int v5 = *(_DWORD *)a2;
    }
    if (v5 > *(_DWORD *)a2) {
      jp2_colour_converter::convert_lum();
    }
    if ((*(unsigned char *)(a2 + 6) & 2) == 0 || (*(unsigned char *)(a2 + 6) & 1) != 0 || (int v6 = *(__int16 **)(a2 + 8)) == 0) {
      jp2_colour_converter::convert_lum();
    }
    if (v5 >= 1)
    {
      int v7 = -65536 << *(_DWORD *)(v3 + 4) >> 16;
      int v8 = v5 + 1;
      do
      {
        int v9 = *v6;
        if (v9 > -4097)
        {
          int v12 = v9 + 4096;
          if ((v12 & v7) != 0) {
            int v12 = ~v7;
          }
          __int16 v11 = *(_WORD *)(v4 + 2 * v12);
        }
        else
        {
          int v10 = -4096 - v9;
          if ((v10 & v7) != 0) {
            int v10 = ~v7;
          }
          __int16 v11 = -8192 - *(_WORD *)(v4 + 2 * v10);
        }
        *v6++ = v11;
        --v8;
      }
      while (v8 > 1);
    }
  }
  return 1;
}

uint64_t jp2_colour_converter::convert_rgb(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5 = *a1;
  if (!*a1 || *(_DWORD *)(v5 + 8) != 3) {
    return 0;
  }
  if (a5 >= 0) {
    int v9 = a5;
  }
  else {
    int v9 = *(_DWORD *)a2;
  }
  if (v9 > *(_DWORD *)a2 || v9 > *(_DWORD *)a3 || v9 > *(_DWORD *)a4) {
    jp2_colour_converter::convert_rgb();
  }
  if (*(unsigned char *)(v5 + 14))
  {
    kdu_convert_ycc_to_rgb(a2, a3, a4, v9);
  }
  else if (!*(unsigned char *)(v5 + 13) && v9 >= 1)
  {
    int v14 = *(_DWORD *)(v5 + 28);
    int v15 = *(_DWORD *)(v5 + 32);
    int v16 = *(_DWORD *)(v5 + 36);
    if ((*(unsigned char *)(a4 + 6) & 2) != 0) {
      float v17 = *(__int16 **)(a4 + 8);
    }
    else {
      float v17 = 0;
    }
    if ((*(unsigned char *)(a3 + 6) & 2) != 0) {
      uint64_t v18 = *(__int16 **)(a3 + 8);
    }
    else {
      uint64_t v18 = 0;
    }
    if ((*(unsigned char *)(a2 + 6) & 2) != 0) {
      int v19 = *(__int16 **)(a2 + 8);
    }
    else {
      int v19 = 0;
    }
    unsigned int v20 = v9 + 1;
    do
    {
      int v21 = v14 + *v19;
      int v22 = v15 + *v18;
      int v23 = v16 + *v17;
      *v19++ = (*(_DWORD *)(v5 + 80) * v22 + *(_DWORD *)(v5 + 76) * v21 + *(_DWORD *)(v5 + 84) * v23 + 2048) >> 12;
      *v18++ = (*(_DWORD *)(v5 + 92) * v22 + *(_DWORD *)(v5 + 88) * v21 + *(_DWORD *)(v5 + 96) * v23 + 2048) >> 12;
      *v17++ = (*(_DWORD *)(v5 + 104) * v22
                            + *(_DWORD *)(v5 + 100) * v21
                            + *(_DWORD *)(v5 + 108) * v23
                            + 2048) >> 12;
      --v20;
    }
    while (v20 > 1);
  }
  uint64_t v24 = *a1;
  if (*(unsigned char *)(*a1 + 112)) {
    return 1;
  }
  uint64_t v25 = *(void *)(v24 + 120);
  if (!v25) {
    jp2_colour_converter::convert_rgb();
  }
  int v26 = -1 << *(_DWORD *)(v24 + 4);
  uint64_t v27 = *(void *)(v24 + 128);
  uint64_t v28 = *(void *)(v24 + 136);
  if (!v27) {
    uint64_t v27 = *(void *)(v24 + 120);
  }
  if (!v28) {
    uint64_t v28 = *(void *)(v24 + 120);
  }
  if ((*(unsigned char *)(a2 + 6) & 2) != 0) {
    double v29 = *(__int16 **)(a2 + 8);
  }
  else {
    double v29 = 0;
  }
  if ((*(unsigned char *)(a3 + 6) & 2) != 0) {
    uint64_t v30 = *(__int16 **)(a3 + 8);
  }
  else {
    uint64_t v30 = 0;
  }
  if ((*(unsigned char *)(a4 + 6) & 2) != 0) {
    uint64_t v31 = *(__int16 **)(a4 + 8);
  }
  else {
    uint64_t v31 = 0;
  }
  if (*(unsigned char *)(v24 + 144))
  {
    if (v9 >= 1)
    {
      int v32 = v9 + 1;
      do
      {
        int v33 = *v29;
        if (v33 > -4097)
        {
          int v36 = v33 + 4096;
          if ((v36 & v26) != 0) {
            int v36 = ~v26;
          }
          __int16 v35 = *(_WORD *)(v25 + 2 * v36);
        }
        else
        {
          int v34 = -4096 - v33;
          if ((v34 & v26) != 0) {
            int v34 = ~v26;
          }
          __int16 v35 = -8192 - *(_WORD *)(v25 + 2 * v34);
        }
        __int16 *v29 = v35;
        int v37 = *v30;
        if (v37 > -4097)
        {
          int v40 = v37 + 4096;
          if ((v40 & v26) != 0) {
            int v40 = ~v26;
          }
          __int16 v39 = *(_WORD *)(v27 + 2 * v40);
        }
        else
        {
          int v38 = -4096 - v37;
          if ((v38 & v26) != 0) {
            int v38 = ~v26;
          }
          __int16 v39 = -8192 - *(_WORD *)(v27 + 2 * v38);
        }
        *uint64_t v30 = v39;
        int v41 = *v31;
        if (v41 > -4097)
        {
          int v44 = v41 + 4096;
          if ((v44 & v26) != 0) {
            int v44 = ~v26;
          }
          __int16 v43 = *(_WORD *)(v28 + 2 * v44);
        }
        else
        {
          int v42 = -4096 - v41;
          if ((v42 & v26) != 0) {
            int v42 = ~v26;
          }
          __int16 v43 = -8192 - *(_WORD *)(v28 + 2 * v42);
        }
        *v31++ = v43;
        ++v29;
        ++v30;
        --v32;
      }
      while (v32 > 1);
    }
    return 1;
  }
  if (v9 < 1) {
    return 1;
  }
  uint64_t v45 = *(void *)(v24 + 224);
  int v46 = v9 + 1;
  do
  {
    int v47 = *v29;
    if (v47 > -4097)
    {
      int v50 = v47 + 4096;
      if ((v50 & v26) != 0) {
        int v50 = ~v26;
      }
      int v49 = *(__int16 *)(v25 + 2 * v50);
    }
    else
    {
      int v48 = -4096 - v47;
      if ((v48 & v26) != 0) {
        int v48 = ~v26;
      }
      int v49 = -*(__int16 *)(v25 + 2 * v48);
    }
    int v51 = *v30;
    if (v51 > -4097)
    {
      int v54 = v51 + 4096;
      if ((v54 & v26) != 0) {
        int v54 = ~v26;
      }
      int v53 = *(__int16 *)(v27 + 2 * v54);
    }
    else
    {
      int v52 = -4096 - v51;
      if ((v52 & v26) != 0) {
        int v52 = ~v26;
      }
      int v53 = -*(__int16 *)(v27 + 2 * v52);
    }
    int v55 = *v31;
    if (v55 > -4097)
    {
      int v58 = v55 + 4096;
      if ((v58 & v26) != 0) {
        int v58 = ~v26;
      }
      int v57 = *(__int16 *)(v28 + 2 * v58);
    }
    else
    {
      int v56 = -4096 - v55;
      if ((v56 & v26) != 0) {
        int v56 = ~v26;
      }
      int v57 = -*(__int16 *)(v28 + 2 * v56);
    }
    int v59 = *(_DWORD *)(v24 + 184) * v49 + *(_DWORD *)(v24 + 188) * v53 + *(_DWORD *)(v24 + 192) * v57;
    int v60 = (v59 + 2048) >> 12;
    if (v59 > -2049)
    {
      if ((v60 & v26) != 0) {
        int v60 = ~v26;
      }
      __int16 v62 = *(_WORD *)(v45 + 2 * v60);
    }
    else
    {
      if ((v26 & -v60) != 0) {
        int v61 = ~v26;
      }
      else {
        int v61 = -v60;
      }
      __int16 v62 = -8192 - *(_WORD *)(v45 + 2 * v61);
    }
    __int16 *v29 = v62;
    int v63 = *(_DWORD *)(v24 + 196) * v49 + *(_DWORD *)(v24 + 200) * v53 + *(_DWORD *)(v24 + 204) * v57;
    int v64 = (v63 + 2048) >> 12;
    if (v63 > -2049)
    {
      if ((v64 & v26) != 0) {
        int v64 = ~v26;
      }
      __int16 v66 = *(_WORD *)(v45 + 2 * v64);
    }
    else
    {
      if ((v26 & -v64) != 0) {
        int v65 = ~v26;
      }
      else {
        int v65 = -v64;
      }
      __int16 v66 = -8192 - *(_WORD *)(v45 + 2 * v65);
    }
    *uint64_t v30 = v66;
    int v67 = *(_DWORD *)(v24 + 208) * v49 + *(_DWORD *)(v24 + 212) * v53 + *(_DWORD *)(v24 + 216) * v57;
    int v68 = (v67 + 2048) >> 12;
    if (v67 > -2049)
    {
      if ((v68 & v26) != 0) {
        int v68 = ~v26;
      }
      __int16 v70 = *(_WORD *)(v45 + 2 * v68);
    }
    else
    {
      if ((v26 & -v68) != 0) {
        int v69 = ~v26;
      }
      else {
        int v69 = -v68;
      }
      __int16 v70 = -8192 - *(_WORD *)(v45 + 2 * v69);
    }
    *v31++ = v70;
    ++v29;
    ++v30;
    --v46;
    uint64_t result = 1;
  }
  while (v46 > 1);
  return result;
}

uint64_t jp2_colour_converter::convert_rgb4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t result = jp2_colour_converter::convert_rgb(a1, a2, a3, a4, a6);
  if (result && *(unsigned char *)(*a1 + 15))
  {
    LODWORD(v13) = *(_DWORD *)a5;
    if (a6 >= 0) {
      uint64_t v13 = a6;
    }
    else {
      uint64_t v13 = v13;
    }
    if ((int)v13 > *(_DWORD *)a2 || (int)v13 > *(_DWORD *)a3 || (int)v13 > *(_DWORD *)a4) {
      jp2_colour_converter::convert_rgb4();
    }
    if ((*(unsigned char *)(a2 + 6) & 2) != 0) {
      int v16 = *(__int16 **)(a2 + 8);
    }
    else {
      int v16 = 0;
    }
    if ((*(unsigned char *)(a3 + 6) & 2) != 0) {
      float v17 = *(__int16 **)(a3 + 8);
    }
    else {
      float v17 = 0;
    }
    if ((*(unsigned char *)(a4 + 6) & 2) != 0) {
      uint64_t v18 = *(__int16 **)(a4 + 8);
    }
    else {
      uint64_t v18 = 0;
    }
    if ((*(unsigned char *)(a5 + 6) & 2) != 0) {
      int v19 = *(__int16 **)(a5 + 8);
    }
    else {
      int v19 = 0;
    }
    if ((int)v13 >= 1)
    {
      do
      {
        int v20 = *v19++;
        int v21 = -16777216 - (v20 << 12);
        __int16 *v16 = (v21 + (4095 - v20) * *v16) >> 13;
        ++v16;
        __int16 *v17 = (v21 + (4095 - v20) * *v17) >> 13;
        ++v17;
        *uint64_t v18 = (v21 + (4095 - v20) * *v18) >> 13;
        ++v18;
        --v13;
      }
      while (v13);
    }
  }
  return result;
}

void jp2_header::jp2_header(jp2_header *this)
{
}

void jp2_header::~jp2_header(jp2_header *this)
{
  uint64_t v1 = *(void **)this;
  if (*(void *)this)
  {
    j2_channels::~j2_channels((j2_channels *)(v1 + 52));
    uint64_t v2 = v1[51];
    if (v2) {
      MEMORY[0x18C11C0C0](v2, 0x1000C808B6DE1C6);
    }
    j2_palette::~j2_palette((j2_palette *)(v1 + 43));
    j2_colour::~j2_colour((j2_colour *)(v1 + 29));
    uint64_t v3 = v1[28];
    if (v3) {
      MEMORY[0x18C11C0C0](v3, 0x1000C8052888210);
    }
    jp2_input_box::~jp2_input_box((jp2_input_box *)v1);
    MEMORY[0x18C11C0E0]();
  }
}

float *jp2_header::write(float **this, jp2_output_box *a2)
{
  j2_dimensions::finalize((uint64_t)(*this + 48));
  j2_palette::finalize((uint64_t)(*this + 86));
  uint64_t v4 = *this;
  if ((*this)[114] <= 0.0) {
    v4[114] = 1.0;
  }
  if (v4[115] <= 0.0) {
    v4[115] = 1.0;
  }
  j2_component_map::finalize((uint64_t)(v4 + 94), (j2_dimensions *)(v4 + 48), (j2_palette *)(v4 + 86));
  j2_channels::finalize((unsigned int *)*this + 104, *((_DWORD *)*this + 60), 1);
  j2_channels::add_cmap_channels((unsigned int *)*this + 104, (j2_component_map *)(*this + 94), 0);
  j2_colour::finalize((j2_colour *)(*this + 58), (j2_channels *)(*this + 104));
  uint64_t v5 = *this;
  if (*((unsigned char *)*this + 432))
  {
    uint64_t v9 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  if (!j2_colour::is_jp2_compatible((j2_colour *)(v5 + 58)))
  {
    uint64_t v9 = 0;
    long long v7 = 0u;
    long long v8 = 0u;
    kdu_error::kdu_error((kdu_error *)&v7, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v7);
  }
  j2_dimensions::save_boxes((j2_dimensions *)(v5 + 48), a2);
  j2_colour::save_box((j2_colour *)(*this + 58), a2);
  j2_palette::save_box((uint64_t)(*this + 86), a2);
  j2_component_map::save_box((unsigned char *)*this + 376, a2, 0);
  j2_channels::save_box((uint64_t)(*this + 104), a2, 1);
  return j2_resolution::save_box(*this + 114, a2);
}

void sub_188684A84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188684A90()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_header::access_dimensions(jp2_header *this)
{
  return *(void *)this + 192;
}

uint64_t jp2_header::access_colour(jp2_header *this)
{
  return *(void *)this + 232;
}

uint64_t jp2_header::access_palette(jp2_header *this)
{
  return *(void *)this + 344;
}

uint64_t jp2_header::access_channels(jp2_header *this)
{
  return *(void *)this + 416;
}

void jp2_target::jp2_target(jp2_target *this)
{
  *((_DWORD *)this + 2) = 0;
  *((unsigned char *)this + 72) = 0;
  *((unsigned char *)this + 12) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 6) = 0;
  *((_DWORD *)this + 8) = 0;
  *((void *)this + 7) = -1;
  *((void *)this + 8) = 0;
  *(void *)this = &unk_1ED4DE808;
  *((void *)this + 11) = 0;
  *((void *)this + 10) = 0;
  std::unique_ptr<jp2_header>::reset[abi:ne180100]((jp2_header **)this + 10, 0);
  *((unsigned char *)this + 96) = 0;
}

void jp2_target::~jp2_target(jp2_header **this)
{
  *this = (jp2_header *)&unk_1ED4DE808;
  std::unique_ptr<jp2_header>::reset[abi:ne180100](this + 10, 0);
  *this = (jp2_header *)&unk_1ED4E3098;
  uint64_t v2 = this[8];
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C8077774924);
  }
  *this = (jp2_header *)&unk_1ED4E5410;
}

{
  uint64_t vars8;

  jp2_target::~jp2_target(this);

  JUMPOUT(0x18C11C0E0);
}

void jp2_target::open(jp2_target *this, jp2_family_tgt *a2)
{
  *((void *)this + 11) = a2;
  if (*((void *)a2 + 3))
  {
    uint64_t v3 = 0;
    memset(v2, 0, sizeof(v2));
    kdu_error::kdu_error((kdu_error *)v2, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v2);
  }
  operator new();
}

void sub_188684CE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188684CF0()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_target::write_header(jp2_target *this)
{
  uint64_t v2 = *((void *)this + 11);
  if (!v2)
  {
    uint64_t v8 = 0;
    long long v6 = 0u;
    long long v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  if (*(void *)(v2 + 24))
  {
    uint64_t v8 = 0;
    long long v6 = 0u;
    long long v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  uint64_t v3 = **((void **)this + 10);
  if (*(_DWORD *)(v3 + 200) != 7 || (int v4 = *(_DWORD *)(v3 + 204), v4 < 0) || v4 >= 3)
  {
    uint64_t v8 = 0;
    long long v6 = 0u;
    long long v7 = 0u;
    kdu_error::kdu_error((kdu_error *)&v6, "Error in Kakadu File Format Support:\n");
    (*(void (**)(long long *, const char *))(v6 + 16))(&v6, "Attempting to embed a codestream which does not conform to Part-1 of the JPEG2000 standard within a plain JP2 file.  For this, you must either write a raw codestream, or embed the codestream within the more advanced JPX file format.");
    kdu_error::~kdu_error((kdu_error *)&v6);
  }
  if (*((unsigned char *)this + 96)) {
    jp2_target::write_header();
  }
  if (!*((void *)this + 10)) {
    jp2_target::write_header();
  }
  *((unsigned char *)this + 96) = 1;
  jp2_output_box::open((uint64_t)this, *((jp2_family_tgt **)this + 11), 1783636000, 0);
  LODWORD(v6) = 176622093;
  (*(void (**)(jp2_target *, long long *, uint64_t))(*(void *)this + 40))(this, &v6, 4);
  (*(void (**)(jp2_target *))(*(void *)this + 16))(this);
  (*(void (**)(jp2_target *, uint64_t, void))(*(void *)this + 80))(this, 1718909296, 0);
  LODWORD(v6) = 540176490;
  (*(void (**)(jp2_target *, long long *, uint64_t))(*(void *)this + 40))(this, &v6, 4);
  LODWORD(v6) = 0;
  (*(void (**)(jp2_target *, long long *, uint64_t))(*(void *)this + 40))(this, &v6, 4);
  LODWORD(v6) = 540176490;
  (*(void (**)(jp2_target *, long long *, uint64_t))(*(void *)this + 40))(this, &v6, 4);
  (*(void (**)(jp2_target *))(*(void *)this + 16))(this);
  (*(void (**)(jp2_target *, uint64_t, void))(*(void *)this + 80))(this, 1785737832, 0);
  jp2_header::write(*((float ***)this + 10), this);
  return (*(uint64_t (**)(jp2_target *))(*(void *)this + 16))(this);
}

void sub_188685090(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18868509C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

uint64_t jp2_target::open_codestream(jp2_target *this, uint64_t a2)
{
  if (!*((void *)this + 11) || !*((unsigned char *)this + 96))
  {
    uint64_t v4 = 0;
    memset(v3, 0, sizeof(v3));
    kdu_error::kdu_error((kdu_error *)v3, "Error in Kakadu File Format Support:\n");
    kdu_error::~kdu_error((kdu_error *)v3);
  }
  return (*(uint64_t (**)(jp2_target *, uint64_t, uint64_t))(*(void *)this + 80))(this, 1785737827, a2);
}

void sub_188685198(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886851A4()
{
  _Unwind_Resume(v0);
}

uint64_t jp2_target::access_dimensions(jp2_target *this)
{
  uint64_t v1 = (void *)*((void *)this + 10);
  if (!v1) {
    jp2_target::access_dimensions();
  }
  return *v1 + 192;
}

uint64_t jp2_target::access_colour(jp2_target *this)
{
  uint64_t v1 = (void *)*((void *)this + 10);
  if (!v1) {
    jp2_target::access_colour();
  }
  return *v1 + 232;
}

uint64_t jp2_target::access_channels(jp2_target *this)
{
  uint64_t v1 = (void *)*((void *)this + 10);
  if (!v1) {
    jp2_target::access_channels();
  }
  return *v1 + 416;
}

uint64_t jp2_target::access_resolution(jp2_target *this)
{
  uint64_t v1 = (void *)*((void *)this + 10);
  if (!v1) {
    jp2_target::access_resolution();
  }
  return *v1 + 456;
}

void j2_data_references::init(j2_data_references *this, jp2_input_box *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)a2 + 12) == 1685348972)
  {
    unsigned __int16 v13 = 0;
    if (!jp2_input_box::read(a2, &v13))
    {
      uint64_t v15 = 0;
      memset(v14, 0, sizeof(v14));
      kdu_error::kdu_error((kdu_error *)v14, "Error in Kakadu File Format Support:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v14[0] + 16))(v14, "Malformed data reference box (dtbl) found in JPX data source.  Not all fields were present.");
      kdu_error::~kdu_error((kdu_error *)v14);
    }
    int v4 = v13;
    *(_DWORD *)this = v13;
    if (*((_DWORD *)this + 1) < v4)
    {
      *((_DWORD *)this + 1) = v4;
      operator new[]();
    }
    bzero(*((void **)this + 1), 8 * v4);
    *((void *)&v14[1] + 1) = 0;
    long long v23 = 0u;
    long long v27 = 0u;
    long long v26 = 0u;
    uint64_t v24 = 0;
    *(void *)&v14[0] = &unk_1ED4E0DA8;
    *(_OWORD *)((char *)v14 + 8) = xmmword_18898D150;
    uint64_t v15 = 0;
    long long v16 = 0uLL;
    long long v17 = 0uLL;
    long long v18 = 0uLL;
    uint64_t v19 = 0;
    uint64_t v20 = -1;
    uint64_t v21 = -1;
    uint64_t v22 = -1;
    LODWORD(v23) = -1;
    DWORD2(v23) = 0;
    *(_DWORD *)((char *)&v23 + 5) = 0;
    uint64_t v25 = -1;
    unsigned int v12 = 0;
    if (*(int *)this >= 1)
    {
      int v6 = jp2_input_box::open((jp2_input_box *)v14, a2);
      if (DWORD2(v16) == 1970433056) {
        int v7 = v6;
      }
      else {
        int v7 = 0;
      }
      if (v7 == 1 && jp2_input_box::read((jp2_input_box *)v14, &v12) && !BYTE5(v23))
      {
        int v8 = DWORD2(v27) + v19 - v24;
        if (v8 >= 0)
        {
          if (v8 == 0x7FFFFFFF)
          {
            uint64_t v11 = 0;
            long long v9 = 0u;
            long long v10 = 0u;
            kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
            (*(void (**)(long long *, const char *))(v9 + 16))(&v9, "Malformed data reference box (dtbl).  Unable to read sufficient correctly formatted data entry URL boxes.");
            kdu_error::~kdu_error((kdu_error *)&v9);
          }
          operator new[]();
        }
      }
      uint64_t v11 = 0;
      long long v9 = 0u;
      long long v10 = 0u;
      kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v9 + 16))(&v9, "Malformed data reference box (dtbl).  Unable to read sufficient correctly formatted data entry URL boxes.");
      kdu_error::~kdu_error((kdu_error *)&v9);
    }
    if (!*((unsigned char *)a2 + 125) && *((void *)a2 + 11) - *((void *)a2 + 17) + *((int *)a2 + 44) >= 1)
    {
      uint64_t v11 = 0;
      long long v9 = 0u;
      long long v10 = 0u;
      kdu_error::kdu_error((kdu_error *)&v9, "Error in Kakadu File Format Support:\n");
      (*(void (**)(long long *, const char *))(v9 + 16))(&v9, "Malformed data reference box (dtbl).  Box appears to contain additional content beyond the declared number of data entry URL boxes.");
      kdu_error::~kdu_error((kdu_error *)&v9);
    }
    (*(void (**)(jp2_input_box *))(*(void *)a2 + 16))(a2);
    jp2_input_box::~jp2_input_box((jp2_input_box *)v14);
  }
  else
  {
    uint64_t v5 = *(void (**)(jp2_input_box *))(*(void *)a2 + 16);
    v5(a2);
  }
}

void sub_188685728(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188685734(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  jp2_input_box::~jp2_input_box((jp2_input_box *)va);
  _Unwind_Resume(v6);
}

const char *jp2_data_references::get_url(jp2_data_references *this, int a2)
{
  uint64_t result = 0;
  if ((a2 & 0x80000000) == 0)
  {
    uint64_t v4 = *(void *)this;
    if (v4)
    {
      if (*(_DWORD *)v4 >= a2)
      {
        if (a2) {
          return *(const char **)(*(void *)(v4 + 8) + 8 * (a2 - 1));
        }
        else {
          return "";
        }
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t jp2_input_box::get_capabilities(jp2_input_box *this)
{
  return *((unsigned int *)this + 32);
}

uint64_t jp2_input_box::get_pos(jp2_input_box *this)
{
  return *((void *)this + 17) - (*((void *)this + 10) + *((int *)this + 44));
}

uint64_t jp2_output_box::open(jp2_output_box *this, uint64_t a2)
{
  return (*(uint64_t (**)(jp2_output_box *, void, uint64_t, void))(*(void *)this + 56))(this, 0, a2, 0);
}

uint64_t kdu_compressed_target::close(kdu_compressed_target *this)
{
  return 1;
}

uint64_t kdu_compressed_target::start_rewrite(kdu_compressed_target *this)
{
  return 0;
}

uint64_t kdu_compressed_target::end_rewrite(kdu_compressed_target *this)
{
  return 0;
}

uint64_t j2_component_map::verify_channel_query_idx(uint64_t this, int a2)
{
  if (a2 < 0 || *(_DWORD *)(this + 28) <= a2)
  {
    uint64_t v3 = 0;
    memset(v2, 0, sizeof(v2));
    kdu_error::kdu_error((kdu_error *)v2, "Error in Kakadu File Format Support:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v2[0] + 16))(v2, "Attempting to associate a reproduction function (e.g., colour intensity, opacity, etc.) with a non-existent image channel in a JP2-family file.  The problem may be a missing or invalid Component Mapping (cmap) box, or a corrupt or illegal Channel Definitions (cdef) box.");
    kdu_error::~kdu_error((kdu_error *)v2);
  }
  if (!*(void *)(this + 8)) {
    j2_component_map::verify_channel_query_idx();
  }
  return this;
}

void sub_1886858F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188685904()
{
  _Unwind_Resume(v0);
}

void j2_channels::~j2_channels(j2_channels *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C80A987AF97);
  }
  uint64_t v3 = *((void *)this + 4);
  if (v3) {
    MEMORY[0x18C11C0C0](v3, 0x1000C8077774924);
  }
}

void j2_palette::~j2_palette(j2_palette *this)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2) {
    MEMORY[0x18C11C0C0](v2, 0x1000C8052888210);
  }
  if (*((void *)this + 3))
  {
    int v3 = *((_DWORD *)this + 1);
    if (v3 < 1) {
      goto LABEL_10;
    }
    for (uint64_t i = 0; i < v3; ++i)
    {
      uint64_t v5 = *(void *)(*((void *)this + 3) + 8 * i);
      if (v5)
      {
        MEMORY[0x18C11C0C0](v5, 0x1000C8052888210);
        int v3 = *((_DWORD *)this + 1);
      }
    }
    if (*((void *)this + 3)) {
LABEL_10:
    }
      MEMORY[0x18C11C0C0]();
  }
}

void std::default_delete<j2_icc_profile>::operator()[abi:ne180100](uint64_t a1, void *a2)
{
  if (a2)
  {
    if (*a2) {
      MEMORY[0x18C11C0C0](*a2, 0x1000C8077774924);
    }
    JUMPOUT(0x18C11C0E0);
  }
}

jp2_header *std::unique_ptr<jp2_header>::reset[abi:ne180100](jp2_header **a1, jp2_header *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    jp2_header::~jp2_header(result);
    JUMPOUT(0x18C11C0E0);
  }
  return result;
}

void kd_attribute::kd_attribute(kd_attribute *this, const char *a2, const char *a3, int a4, const char *a5)
{
  uint64_t v6 = 0;
  int v7 = 0;
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((_DWORD *)this + 4) = a4;
  *((void *)this + 3) = a5;
  for (uint64_t i = a5; ; ++i)
  {
    *((_DWORD *)this + 8) = v7;
    int v9 = *(unsigned __int8 *)i;
    uint64_t v10 = (v9 - 40);
    if (v10 > 0x33) {
      break;
    }
    if (((1 << (v9 - 40)) & 0x24C000000) != 0) {
      goto LABEL_16;
    }
    if (v9 == 40)
    {
      int v11 = 41;
    }
    else
    {
      if (v10 != 51) {
        break;
      }
      int v11 = 93;
    }
    do
    {
LABEL_10:
      int v13 = *++i;
      int v12 = v13;
      if (v13) {
        BOOL v14 = v11 == v12;
      }
      else {
        BOOL v14 = 1;
      }
    }
    while (!v14);
    if (!(_BYTE)v12)
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = a5;
      __cxa_throw(exception, MEMORY[0x1E4FBA308], 0);
    }
LABEL_16:
    ++v7;
    v6 += 24;
  }
  if (!*i)
  {
    *((_DWORD *)this + 9) = 0;
    *((_DWORD *)this + 16) = 1;
    operator new[]();
  }
  int v11 = 0;
  goto LABEL_10;
}

uint64_t kd_attribute::augment_records(uint64_t this, int a2)
{
  if (*(_DWORD *)(this + 36) < a2)
  {
    uint64_t v2 = (void *)this;
    int v3 = *(_DWORD *)(this + 64);
    if (v3 < a2)
    {
      if ((*(unsigned char *)(this + 16) & 1) == 0)
      {
        uint64_t v5 = 0;
        memset(v4, 0, sizeof(v4));
        kdu_error::kdu_error((kdu_error *)v4, "Kakadu Core Error:\n");
        (*(void (**)(_OWORD *, const char *))(*(void *)&v4[0] + 16))(v4, "Attempting to write multiple records to a code-stream attribute");
        (*(void (**)(_OWORD *, const char *))(*(void *)&v4[0] + 16))(v4, ", \"");
        (*(void (**)(_OWORD *, void))(*(void *)&v4[0] + 16))(v4, *v2);
        (*(void (**)(_OWORD *, const char *))(*(void *)&v4[0] + 16))(v4, "\", which can accept only single attributes!");
        kdu_error::~kdu_error((kdu_error *)v4);
      }
      is_mul_ok(*(int *)(this + 32) * (uint64_t)(v3 + a2), 0x18uLL);
      operator new[]();
    }
    *(_DWORD *)(this + 36) = a2;
  }
  return this;
}

void sub_188685F08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188685F14()
{
  _Unwind_Resume(v0);
}

uint64_t kd_attribute::describe(kd_attribute *this, kdu_message *a2, int a3, int a4, int a5, char a6)
{
  unsigned int v8 = 0;
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  int v19 = 0;
  if (a3)
  {
    LOBYTE(v19) = 84;
    unsigned int v8 = 1;
  }
  if (a4 && (*((unsigned char *)this + 16) & 4) == 0)
  {
    uint64_t v9 = v8++;
    *(unsigned char *)((unint64_t)&v19 | v9) = 67;
  }
  if (a5)
  {
    *(_WORD *)((unint64_t)&v19 | v8) = 73;
LABEL_9:
    (*(void (**)(kdu_message *, void))(*(void *)a2 + 16))(a2, *(void *)this);
    (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "[:<");
    (*(void (**)(kdu_message *, int *))(*(void *)a2 + 16))(a2, &v19);
    (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, ">]={");
    goto LABEL_10;
  }
  *(unsigned char *)((unint64_t)&v19 | v8) = 0;
  if (v8) {
    goto LABEL_9;
  }
  (*(void (**)(kdu_message *, void))(*(void *)a2 + 16))(a2, *(void *)this);
  (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "={");
LABEL_10:
  if (*((int *)this + 8) >= 1)
  {
    uint64_t v10 = 0;
    while (1)
    {
      if (v10) {
        (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, ",");
      }
      int v11 = *(char **)(*((void *)this + 5) + 24 * v10 + 8);
      if (!v11) {
        kd_attribute::describe();
      }
      int v12 = *v11;
      switch(*v11)
      {
        case 'B':
          (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "<yes/no>");
          goto LABEL_30;
        case 'C':
          (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "<custom int>");
          goto LABEL_30;
        case 'D':
        case 'E':
        case 'G':
        case 'H':
          goto LABEL_30;
        case 'F':
          (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "<float>");
          goto LABEL_30;
        case 'I':
          (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "<int>");
          goto LABEL_30;
        default:
          if (v12 == 40)
          {
            long long v24 = 0u;
            long long v25 = 0u;
            long long v22 = 0u;
            long long v23 = 0u;
            *(_OWORD *)uint64_t v21 = 0u;
            int v18 = 0;
            (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "ENUM<");
            do
            {
              int v11 = parse_translator_entry(v11 + 1, 0x2Cu, v21, &v18, v14);
              (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v21);
              if (*v11 != 44) {
                break;
              }
              __int16 v20 = 44;
              (*(void (**)(kdu_message *, __int16 *))(*(void *)a2 + 16))(a2, &v20);
            }
            while (*v11 == 44);
            goto LABEL_29;
          }
          if (v12 == 91)
          {
            long long v24 = 0u;
            long long v25 = 0u;
            long long v22 = 0u;
            long long v23 = 0u;
            *(_OWORD *)uint64_t v21 = 0u;
            int v18 = 0;
            (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "FLAGS<");
            do
            {
              int v11 = parse_translator_entry(v11 + 1, 0x7Cu, v21, &v18, v13);
              (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v21);
              if (*v11 != 124) {
                break;
              }
              __int16 v20 = 124;
              (*(void (**)(kdu_message *, __int16 *))(*(void *)a2 + 16))(a2, &v20);
            }
            while (*v11 == 124);
LABEL_29:
            (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, ">");
          }
LABEL_30:
          if (++v10 >= *((int *)this + 8)) {
            goto LABEL_31;
          }
          break;
      }
    }
  }
LABEL_31:
  (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "}");
  if (*((_DWORD *)this + 4)) {
    uint64_t v15 = ",...\n";
  }
  else {
    uint64_t v15 = "\n";
  }
  uint64_t result = (*(uint64_t (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, v15);
  if (a6)
  {
    (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "\t");
    (*(void (**)(kdu_message *, void))(*(void *)a2 + 16))(a2, *((void *)this + 1));
    return (*(uint64_t (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "\n");
  }
  return result;
}

char *parse_translator_entry(const char *a1, unsigned __int8 a2, char *a3, _DWORD *a4, int *a5)
{
  uint64_t v7 = 0;
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  int v8 = a2;
  while (1)
  {
    char v9 = a1[v7];
    if (a2 == v9)
    {
LABEL_3:
      *(void *)&long long v20 = 0;
      *(_OWORD *)int v18 = 0u;
      long long v19 = 0u;
      kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "String translators in code-stream attribute specifications must contain an '=' sign! Problem encountered at");
      (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, ": \"");
      (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, a1);
      (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "\".");
      kdu_error::~kdu_error((kdu_error *)v18);
    }
    unsigned int v10 = a1[v7];
    if (v10 > 0x3C) {
      break;
    }
    if (!a1[v7] || v10 == 41) {
      goto LABEL_3;
    }
LABEL_4:
    a3[v7++] = v9;
    if (v7 == 80)
    {
      uint64_t v17 = 0;
      *(_OWORD *)__endptr = 0u;
      long long v16 = 0u;
      kdu_error::kdu_error((kdu_error *)__endptr, "Kakadu Core Error:\n");
      (*((void (**)(char **, const char *))__endptr[0] + 2))(__endptr, "String translators in code-stream attribute specifications may not exceed ");
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      *(_OWORD *)int v18 = 0u;
      if (LOBYTE(__endptr[1])) {
        sprintf(v18, "%x");
      }
      else {
        sprintf(v18, "%d");
      }
      (*((void (**)(char **, char *))__endptr[0] + 2))(__endptr, v18);
      (*((void (**)(char **, const char *))__endptr[0] + 2))(__endptr, " characters in length! Problem encountered at");
      (*((void (**)(char **, const char *))__endptr[0] + 2))(__endptr, ": \"");
      (*((void (**)(char **, const char *))__endptr[0] + 2))(__endptr, a1);
      (*((void (**)(char **, const char *))__endptr[0] + 2))(__endptr, "\".");
      kdu_error::~kdu_error((kdu_error *)__endptr);
    }
  }
  if (v10 == 93) {
    goto LABEL_3;
  }
  if (v10 != 61) {
    goto LABEL_4;
  }
  a3[v7] = 0;
  int v11 = &a1[(v7 + 1)];
  __endptr[0] = 0;
  int v12 = strtol(v11, __endptr, 10);
  *a4 = v12;
  if (__endptr[0] == v11 || v8 != *__endptr[0] && (int v13 = *__endptr[0], v13 != 41) && v13 != 93)
  {
    *(void *)&long long v20 = 0;
    *(_OWORD *)int v18 = 0u;
    long long v19 = 0u;
    kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "String translators in code-stream attribute specifications must be identified with integers and correctly delimited! Problem encountered at");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, ": \"");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, v11);
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "\".");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  return __endptr[0];
}

void sub_188686A04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188686A10(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(v17);
}

void kdu_params::~kdu_params(kdu_params *this)
{
  *(void *)this = &unk_1ED4DE990;
  for (uint64_t i = *((void *)this + 12); i; uint64_t i = *((void *)this + 12))
  {
    *((void *)this + 12) = *(void *)(i + 56);
    uint64_t v3 = *(void *)(i + 40);
    if (v3) {
      MEMORY[0x18C11C0C0](v3, 0x1050C80E1FAFEFCLL);
    }
    MEMORY[0x18C11C0E0](i, 0x1070C40C5D0BD27);
  }
  uint64_t v4 = (kdu_params *)*((void *)this + 10);
  if (!v4) {
    return;
  }
  if (v4 != this)
  {
    do
    {
      uint64_t v5 = v4;
      uint64_t v4 = (kdu_params *)*((void *)v4 + 11);
    }
    while (v4 != this);
    uint64_t v6 = (void *)((char *)v5 + 88);
    uint64_t v7 = (char *)this + 88;
    goto LABEL_9;
  }
  int v8 = (void *)*((void *)this + 11);
  if (v8)
  {
    do
    {
      *((void *)this + 11) = v8[11];
      v8[10] = 0;
      (*(void (**)(void *))(*v8 + 16))(v8);
      int v8 = (void *)*((void *)this + 11);
    }
    while (v8);
    if (*((kdu_params **)this + 10) != this)
    {
      uint64_t v17 = "this == first_inst";
      int v29 = 797;
LABEL_53:
      __assert_rtn("~kdu_params", "params.cpp", v29, v17);
    }
  }
  uint64_t v9 = *((void *)this + 8);
  if (!v9
    || (int v10 = *((_DWORD *)this + 8),
        int v11 = *((_DWORD *)this + 4),
        int v12 = *((_DWORD *)this + 5),
        int v13 = v10 + 1,
        int v14 = v12 + v13 + v13 * v11 + 1,
        *(kdu_params **)(v9 + 8 * v14) != this))
  {
    uint64_t v17 = "(refs != NULL) && (refs[ref_idx] == this)";
    int v29 = 800;
    goto LABEL_53;
  }
  uint64_t v15 = v14;
  *(void *)(v9 + 8 * v14) = 0;
  if (v12 < 0 && v10 >= 1)
  {
    long long v16 = (kdu_params **)(*((void *)this + 8) + 8 * v14 + 8);
    uint64_t v17 = "(*sref)->tile_idx == this->tile_idx";
    while (1)
    {
      int v18 = *v16;
      if (*v16 == this)
      {
        __int16 *v16 = 0;
      }
      else if (v18)
      {
        if (*((_DWORD *)v18 + 4) != *((_DWORD *)this + 4))
        {
          int v29 = 813;
          goto LABEL_53;
        }
        (*(void (**)(kdu_params *))(*(void *)v18 + 16))(v18);
        if (*v16)
        {
          int v29 = 816;
          uint64_t v17 = "*sref == NULL";
          goto LABEL_53;
        }
      }
      --v13;
      ++v16;
      if (v13 <= 1)
      {
        int v11 = *((_DWORD *)this + 4);
        break;
      }
    }
  }
  if ((v11 & 0x80000000) == 0) {
    return;
  }
  int v19 = *((_DWORD *)this + 7);
  if (v19 < 1)
  {
LABEL_38:
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0) {
      return;
    }
    long long v25 = (kdu_params *)*((void *)this + 8);
    if (v25 != (kdu_params *)((char *)this + 72) && v25) {
      MEMORY[0x18C11C0C0](v25, 0x20C8093837F09);
    }
    uint64_t v26 = (kdu_params *)*((void *)this + 6);
    if (!v26) {
      return;
    }
    if (v26 == this)
    {
      while (1)
      {
        uint64_t v28 = (void *)*((void *)this + 7);
        if (!v28) {
          break;
        }
        *((void *)this + 7) = v28[7];
        v28[6] = 0;
        (*(void (**)(void *))(*v28 + 16))(v28);
      }
      return;
    }
    do
    {
      long long v27 = v26;
      uint64_t v26 = (kdu_params *)*((void *)v26 + 7);
    }
    while (v26 != this);
    uint64_t v6 = (void *)((char *)v27 + 56);
    uint64_t v7 = (char *)this + 56;
LABEL_9:
    *uint64_t v6 = *(void *)v7;
    return;
  }
  long long v20 = (void *)(*((void *)this + 8) + 8 * v15);
  int v21 = v19 + 1;
  uint64_t v17 = "(*sref)->comp_idx == this->comp_idx";
  do
  {
    long long v22 = &v20[*((int *)this + 8)];
    long long v24 = (kdu_params *)v22[1];
    long long v20 = v22 + 1;
    uint64_t v23 = v24;
    if (v24 == this)
    {
      *long long v20 = 0;
    }
    else
    {
      if (!v23) {
        goto LABEL_36;
      }
      if (*((_DWORD *)v23 + 5) != *((_DWORD *)this + 5))
      {
        int v29 = 831;
        goto LABEL_53;
      }
      (*(void (**)(kdu_params *))(*(void *)v23 + 16))(v23);
      if (*v20)
      {
        int v29 = 834;
        uint64_t v17 = "*sref == NULL";
        goto LABEL_53;
      }
    }
LABEL_36:
    --v21;
  }
  while (v21 > 1);
  if ((*((_DWORD *)this + 4) & 0x80000000) != 0) {
    goto LABEL_38;
  }
}

kdu_params *kdu_params::link(kdu_params *this, kdu_params *a2, int a3, int a4, int a5, int a6)
{
  if (*((_DWORD *)this + 4) != -1
    || *((_DWORD *)this + 5) != -1
    || *((_DWORD *)this + 6)
    || a3 >= a5
    || (uint64_t v9 = (kdu_params *)*((void *)this + 8), v9 != (kdu_params *)((char *)this + 72))
    || a4 < -1
    || a3 < -1
    || a4 >= a6)
  {
    kdu_params::link();
  }
  *((_DWORD *)this + 4) = a3;
  *((_DWORD *)this + 5) = a4;
  *((_DWORD *)this + 7) = a5;
  *((_DWORD *)this + 8) = a6;
  *((void *)this + 6) = 0;
  if (a5 >= 1 && !*((unsigned char *)this + 38) || a6 >= 1 && !*((unsigned char *)this + 39))
  {
    uint64_t v24 = 0;
    long long v22 = 0u;
    long long v23 = 0u;
    kdu_error::kdu_error((kdu_error *)&v22, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v22);
  }
  uint64_t v12 = *(void *)(*((void *)a2 + 10) + 48);
  if (!v12)
  {
    uint64_t v15 = this;
    if ((a4 & a3) == 0xFFFFFFFF)
    {
LABEL_21:
      *((void *)this + 6) = v15;
      *((void *)this + 7) = 0;
      if (!is_mul_ok(a5 + 1, a6 + 1))
      {
        uint64_t v24 = 0;
        long long v22 = 0u;
        long long v23 = 0u;
        kdu_error::kdu_error((kdu_error *)&v22, "Kakadu Core Error:\n");
        kdu_error::~kdu_error((kdu_error *)&v22);
      }
      operator new[]();
    }
LABEL_41:
    kdu_params::link();
  }
  int v13 = (const char *)*((void *)this + 1);
  while (1)
  {
    uint64_t v14 = v12;
    if (!strcmp(*(const char **)(v12 + 8), v13)) {
      break;
    }
    uint64_t v12 = *(void *)(v14 + 56);
    if (!v12)
    {
      if ((a4 & a3) == 0xFFFFFFFF)
      {
        uint64_t v15 = *(kdu_params **)(v14 + 48);
        *(void *)(v14 + 56) = this;
        goto LABEL_21;
      }
      goto LABEL_41;
    }
  }
  if (*(_DWORD *)(v14 + 32) != a6 || *(_DWORD *)(v14 + 28) != a5)
  {
    uint64_t v24 = 0;
    long long v22 = 0u;
    long long v23 = 0u;
    kdu_error::kdu_error((kdu_error *)&v22, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v22);
  }
  long long v16 = *(kdu_params **)(v14 + 64);
  *((void *)this + 8) = v16;
  if (v16 == v9) {
    kdu_params::link();
  }
  int v17 = a4 + a3 + 1 + (a3 + 1) * a6 + 1;
  int v18 = (kdu_params *)*((void *)v16 + v17);
  if (v18) {
    BOOL v19 = v18 == this;
  }
  else {
    BOOL v19 = 1;
  }
  if (!v19 && *((_DWORD *)v18 + 5) == a4 && *((_DWORD *)v18 + 4) == a3)
  {
    if (!*((unsigned char *)this + 40))
    {
      uint64_t v24 = 0;
      long long v22 = 0u;
      long long v23 = 0u;
      kdu_error::kdu_error((kdu_error *)&v22, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v22);
    }
    do
    {
      long long v20 = v18;
      int v18 = (kdu_params *)*((void *)v18 + 11);
    }
    while (v18);
    *((void *)this + 10) = *((void *)v20 + 10);
    *((void *)v20 + 11) = this;
    *((_DWORD *)this + 6) = *((_DWORD *)v20 + 6) + 1;
  }
  else
  {
    *((void *)v16 + v17) = this;
  }
  return this;
}

void sub_188687168(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188687174()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_params::add_dependency(uint64_t this, const char *a2)
{
  uint64_t v2 = 0;
  while (1)
  {
    uint64_t v3 = *(const char **)(this + v2 + 112);
    if (v3 == a2) {
      break;
    }
    if (!v3)
    {
      uint64_t v4 = this + v2;
      *(void *)(v4 + 112) = a2;
      *(void *)(v4 + 120) = 0;
      return this;
    }
    v2 += 8;
    if (v2 == 32) {
      kdu_params::add_dependency();
    }
  }
  return this;
}

uint64_t kdu_params::new_instance(kdu_params *this)
{
  if (!*((unsigned char *)this + 40)) {
    return 0;
  }
  uint64_t v1 = this;
  if ((*((_DWORD *)this + 5) & 0x80000000) != 0 && *((int *)this + 8) > 0) {
    return 0;
  }
  if ((*((_DWORD *)this + 4) & 0x80000000) != 0 && *((int *)this + 7) >= 1 && !*((unsigned char *)this + 42)) {
    return 0;
  }
  uint64_t result = (**(uint64_t (***)(kdu_params *))this)(this);
  *(void *)(result + 64) = *((void *)v1 + 8);
  *(void *)(result + 16) = *((void *)v1 + 2);
  *(void *)(result + 28) = *(void *)((char *)v1 + 28);
  *(void *)(result + 48) = 0;
  do
  {
    uint64_t v3 = v1;
    uint64_t v1 = (kdu_params *)*((void *)v1 + 11);
  }
  while (v1);
  *((void *)v3 + 11) = result;
  *(void *)(result + 80) = *((void *)v3 + 10);
  *(_DWORD *)(result + 24) = *((_DWORD *)v3 + 6) + 1;
  for (uint64_t i = 112; i != 152; i += 8)
    *(void *)(result + i) = *(void *)((char *)v3 + i);
  return result;
}

uint64_t kdu_params::copy_from(uint64_t this, kdu_params *a2, int a3, int a4, int a5, uint64_t a6, unsigned int a7, BOOL a8, BOOL a9, BOOL a10)
{
  int v12 = a4;
  if (*((void *)a2 + 1) != *(void *)(this + 8))
  {
    uint64_t v46 = 0;
    long long v44 = 0u;
    long long v45 = 0u;
    kdu_error::kdu_error((kdu_error *)&v44, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v44);
  }
  if ((*((_DWORD *)a2 + 4) & 0x80000000) == 0
    || (*((_DWORD *)a2 + 5) & 0x80000000) == 0
    || (*(_DWORD *)(this + 16) & 0x80000000) == 0
    || (*(_DWORD *)(this + 20) & 0x80000000) == 0)
  {
    uint64_t v46 = 0;
    long long v44 = 0u;
    long long v45 = 0u;
    kdu_error::kdu_error((kdu_error *)&v44, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v44);
  }
  if (*((_DWORD *)a2 + 7) <= a3) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = *(void *)(*((void *)a2 + 8) + 8 * (a3 + 1 + (a3 + 1) * *((_DWORD *)a2 + 8)));
  }
  uint64_t v40 = this;
  if (*(_DWORD *)(this + 28) > a4)
  {
    int v15 = a4 + 1;
    uint64_t v16 = *(void *)(*(void *)(this + 64) + 8 * (v15 + v15 * *(_DWORD *)(this + 32)));
    if (v16)
    {
      if ((a4 & 0x80000000) == 0 && *(_DWORD *)(v16 + 16) == -1)
      {
        if (!v14 || (*(_DWORD *)(v14 + 16) & 0x80000000) != 0) {
          goto LABEL_61;
        }
        this = kdu_params::access_relation((kdu_params *)v16, a4, -1, 0, 0);
        uint64_t v16 = this;
        if (*(_DWORD *)(this + 16) != v12) {
          kdu_params::copy_from();
        }
      }
      if (v14)
      {
        int v17 = 0;
        int v18 = a6;
        int v38 = v15;
        int v39 = v12;
LABEL_20:
        uint64_t v19 = a6;
        uint64_t v20 = v16;
        uint64_t v21 = v14;
        do
        {
          int v22 = *(_DWORD *)(v21 + 24);
          if (a5 < 0 || v22 == a5)
          {
            if (*(unsigned char *)(v20 + 42))
            {
              this = kdu_params::access_relation((kdu_params *)v16, *(_DWORD *)(v20 + 16), *(_DWORD *)(v20 + 20), v22, 0);
              uint64_t v20 = this;
              uint64_t v24 = v19;
              if (!this) {
                kdu_params::copy_from();
              }
            }
            else
            {
              uint64_t v24 = v19;
            }
            if (*(unsigned char *)(v20 + 37))
            {
              uint64_t v46 = 0;
              long long v44 = 0u;
              long long v45 = 0u;
              kdu_error::kdu_error((kdu_error *)&v44, "Kakadu Core Error:\n");
              kdu_error::~kdu_error((kdu_error *)&v44);
            }
            if (*(unsigned char *)(v20 + 36)) {
              this = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, BOOL, BOOL, BOOL))(*(void *)v20 + 24))(v20, v21, v24, a7, a8, a9, a10);
            }
            BOOL v23 = a5 >= 0;
          }
          else
          {
            BOOL v23 = 0;
          }
          if (!*(unsigned char *)(v20 + 40)) {
            break;
          }
          uint64_t v21 = *(void *)(v21 + 88);
          if (*(unsigned char *)(v20 + 42))
          {
            uint64_t v25 = v20;
          }
          else
          {
            uint64_t v25 = *(void *)(v20 + 88);
            if (!v25)
            {
              this = kdu_params::new_instance((kdu_params *)v20);
              uint64_t v25 = *(void *)(v20 + 88);
            }
          }
          BOOL v26 = !v21 || v25 == 0;
          int v27 = v26 || v23;
          uint64_t v20 = v25;
        }
        while (v27 != 1);
        int v28 = v18 + 1;
        int v29 = v17 + 1;
        a6 = v19;
        int v12 = v39;
        while (1)
        {
          int v18 = v28;
          int v17 = v29;
          int v30 = v28 - 1;
          int v31 = *(_DWORD *)(v14 + 32);
          uint64_t v14 = v30 >= v31 ? 0 : *(void *)(*(void *)(v14 + 64) + 8 * (v18 + a3 + 1 + (a3 + 1) * v31));
          int v32 = *(_DWORD *)(v16 + 32);
          if (v17 - 1 >= v32) {
            break;
          }
          uint64_t v16 = *(void *)(*(void *)(v16 + 64) + 8 * (v17 + v38 + v38 * v32));
          if (!v16) {
            break;
          }
          int v33 = *(_DWORD *)(v16 + 20);
          if (v33 != -1 || v14 == 0)
          {
            if (v33 == -1)
            {
LABEL_58:
              this = kdu_params::access_relation((kdu_params *)v16, v39, v17 - 1, 0, 0);
              uint64_t v16 = this;
            }
            if (v14 && v16) {
              goto LABEL_20;
            }
            break;
          }
          int v28 = v18 + 1;
          int v29 = v17 + 1;
          if (*(_DWORD *)(v14 + 20) != -1) {
            goto LABEL_58;
          }
        }
      }
    }
  }
LABEL_61:
  if (*((kdu_params **)a2 + 6) == a2 && *(void *)(v40 + 48) == v40)
  {
    __int16 v35 = (kdu_params *)*((void *)a2 + 7);
    if (v35)
    {
      int v36 = *(kdu_params **)(v40 + 56);
      if (v36)
      {
        do
        {
          this = kdu_params::copy_from(v36, v35, a3, v12, a5, a6, a7, a8, a9, a10);
          int v36 = (kdu_params *)*((void *)v36 + 7);
          __int16 v35 = (kdu_params *)*((void *)v35 + 7);
          if (v35) {
            BOOL v37 = v36 == 0;
          }
          else {
            BOOL v37 = 1;
          }
        }
        while (!v37);
      }
    }
  }
  return this;
}

void sub_188687760(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18868776C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(v15);
}

uint64_t kdu_params::access_relation(kdu_params *this, int a2, int a3, int a4, int a5)
{
  if (*((_DWORD *)this + 7) <= a2) {
    return 0;
  }
  int v7 = *((_DWORD *)this + 8);
  if (v7 <= a3) {
    return 0;
  }
  int v9 = a2 + 1 + (a2 + 1) * v7;
  int v10 = a3 + v9 + 1;
  uint64_t v11 = *(void *)(*((void *)this + 8) + 8 * v10);
  if (!v11) {
    return v11;
  }
  if ((a5 & 1) == 0 && (*(_DWORD *)(v11 + 16) != a2 || *(_DWORD *)(v11 + 20) != a3))
  {
    if (!a4 || *((unsigned char *)this + 42))
    {
      uint64_t v11 = (**(uint64_t (***)(kdu_params *))this)(this);
      *(void *)(v11 + 64) = *((void *)this + 8);
      *(_DWORD *)(v11 + 16) = a2;
      *(_DWORD *)(v11 + 20) = a3;
      *(void *)(v11 + 28) = *(void *)((char *)this + 28);
      *(void *)(v11 + 48) = 0;
      *(void *)(*((void *)this + 8) + 8 * v10) = v11;
      if (a3 < 0)
      {
        if (a2 < 0) {
          kdu_params::access_relation();
        }
        int v14 = *((_DWORD *)this + 8);
        if (v14 >= 1)
        {
          uint64_t v15 = 0;
          uint64_t v16 = 8 * v10 + 8;
          do
          {
            int v17 = (void *)*((void *)this + 8);
            uint64_t v18 = *(void *)((char *)&v17[v15] + v16);
            if (v18 == *v17)
            {
              *(void *)((char *)&v17[v15] + v16) = v11;
            }
            else if ((*(_DWORD *)(v18 + 16) & 0x80000000) != 0)
            {
              kdu_params::access_relation(this, a2, v15, 0, 0);
              int v14 = *((_DWORD *)this + 8);
            }
            ++v15;
          }
          while ((int)v15 < v14);
        }
      }
      else if (a2 < 0)
      {
        int v19 = *((_DWORD *)this + 7);
        if (v19 >= 1)
        {
          for (int i = 0; i < v19; ++i)
          {
            v10 += *((_DWORD *)this + 8) + 1;
            uint64_t v21 = (void *)*((void *)this + 8);
            uint64_t v22 = v21[v10];
            if (v22 == *v21)
            {
              v21[v10] = v11;
            }
            else if ((*(_DWORD *)(v22 + 20) & 0x80000000) != 0)
            {
              kdu_params::access_relation(this, i, a3, 0, 0);
              int v19 = *((_DWORD *)this + 7);
            }
          }
        }
      }
      else if (*(void *)(*((void *)this + 8) + 8 * v9) == **((void **)this + 8))
      {
        kdu_params::access_relation(this, a2, -1, 0, 0);
      }
      for (uint64_t j = *(void *)(**((void **)this + 8) + 48); j; uint64_t j = *(void *)(j + 56))
      {
        for (uint64_t k = 112; k != 144; k += 8)
        {
          uint64_t v25 = *(const char **)(j + k);
          if (!v25) {
            break;
          }
          if (!strcmp(v25, *((const char **)this + 1)))
          {
            kdu_params::access_relation((kdu_params *)j, a2, a3, 0, 0);
            if ((a2 & 0x80000000) == 0 && *(unsigned char *)(j + 39) && !*((unsigned char *)this + 39) && *(int *)(j + 32) >= 1)
            {
              int v26 = 0;
              do
                kdu_params::access_relation((kdu_params *)j, a2, v26++, 0, 0);
              while (v26 < *(_DWORD *)(j + 32));
            }
            break;
          }
        }
      }
      if (v11) {
        goto LABEL_43;
      }
      return v11;
    }
    return 0;
  }
  do
  {
LABEL_43:
    if (*(_DWORD *)(v11 + 24) == a4) {
      break;
    }
    int v28 = (uint64_t *)(v11 + 88);
    uint64_t v27 = *(void *)(v11 + 88);
    if (!v27 || *(_DWORD *)(v27 + 24) > a4)
    {
      if (!*(unsigned char *)(v11 + 42)) {
        return 0;
      }
      if (a5)
      {
        if ((*(_DWORD *)(v11 + 16) & 0x80000000) != 0) {
          return 0;
        }
        if (*(_DWORD *)(v11 + 32)) {
          kdu_params::access_relation();
        }
        int v28 = (uint64_t *)*((void *)this + 8);
      }
      else
      {
        uint64_t v29 = (**(uint64_t (***)(kdu_params *))this)(this);
        *(void *)(v29 + 64) = *((void *)this + 8);
        *(_DWORD *)(v29 + 16) = a2;
        *(_DWORD *)(v29 + 20) = a3;
        *(void *)(v29 + 28) = *(void *)((char *)this + 28);
        *(void *)(v29 + 48) = 0;
        *(_OWORD *)(v29 + 80) = *(_OWORD *)(v11 + 80);
        *(void *)(v11 + 88) = v29;
        *(_DWORD *)(v29 + 24) = a4;
      }
    }
    uint64_t v11 = *v28;
  }
  while (*v28);
  return v11;
}

uint64_t kdu_params::access_cluster(kdu_params *this, const char *__s2)
{
  uint64_t v2 = *(void *)(**((void **)this + 8) + 48);
  if (__s2 && v2)
  {
    do
    {
      if (!strcmp(*(const char **)(v2 + 8), __s2)) {
        break;
      }
      uint64_t v2 = *(void *)(v2 + 56);
    }
    while (v2);
  }
  return v2;
}

uint64_t kdu_params::access_cluster(kdu_params *this, int a2)
{
  uint64_t result = *(void *)(**((void **)this + 8) + 48);
  if (result) {
    BOOL v3 = a2 < 1;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    do
    {
      uint64_t result = *(void *)(result + 56);
      if (result) {
        BOOL v4 = a2 > 1;
      }
      else {
        BOOL v4 = 0;
      }
      --a2;
    }
    while (v4);
  }
  return result;
}

uint64_t kdu_params::access_unique(kdu_params *this, int a2, int a3, int a4)
{
  if (*((_DWORD *)this + 7) <= a2) {
    return 0;
  }
  int v4 = *((_DWORD *)this + 8);
  if (v4 <= a3) {
    return 0;
  }
  uint64_t v5 = *(void *)(*((void *)this + 8) + 8 * (a3 + a2 + 1 + (a2 + 1) * v4 + 1));
  if (!v5 || *(_DWORD *)(v5 + 16) != a2 || *(_DWORD *)(v5 + 20) != a3) {
    return 0;
  }
  while (*(_DWORD *)(v5 + 24) != a4)
  {
    uint64_t result = 0;
    uint64_t v5 = *(void *)(v5 + 88);
    if (!v5) {
      return result;
    }
  }
  return v5;
}

uint64_t kdu_params::clear_marks(uint64_t this)
{
  for (uint64_t i = *(void *)(**(void **)(this + 64) + 48); i; uint64_t i = *(void *)(i + 56))
  {
    int v2 = *(_DWORD *)(i + 28);
    if ((v2 & 0x80000000) == 0)
    {
      BOOL v3 = *(uint64_t **)(i + 64);
      int v4 = *(_DWORD *)(i + 32);
      int v5 = -1;
      do
      {
        if ((v4 & 0x80000000) == 0)
        {
          int v6 = -1;
          do
          {
            uint64_t v7 = *v3;
            if (*v3 && *(_DWORD *)(v7 + 16) == v5 && *(_DWORD *)(v7 + 20) == v6)
            {
              do
              {
                *(unsigned char *)(v7 + 37) = 0;
                *(unsigned char *)(v7 + 104) = 0;
                uint64_t v7 = *(void *)(v7 + 88);
              }
              while (v7);
            }
            ++v6;
            ++v3;
          }
          while (v6 != v4);
        }
        ++v5;
      }
      while (v5 != v2);
    }
  }
  return this;
}

uint64_t kdu_params::any_changes(kdu_params *this)
{
  return *(unsigned __int8 *)(*(void *)(**((void **)this + 8) + 48) + 104);
}

uint64_t kdu_params::check_typical_tile(kdu_params *this, int a2)
{
  uint64_t v2 = *(void *)(**((void **)this + 8) + 48);
  if (!v2) {
    return 1;
  }
  while (1)
  {
    int v3 = *(_DWORD *)(v2 + 28);
    if (v3 >= 1)
    {
      if (a2 < 0 || v3 <= a2)
      {
        uint64_t v9 = 0;
        memset(v8, 0, sizeof(v8));
        kdu_error::kdu_error((kdu_error *)v8, "Kakadu Core Error:\n");
        kdu_error::~kdu_error((kdu_error *)v8);
      }
      int v4 = *(_DWORD *)(v2 + 32);
      if ((v4 & 0x80000000) == 0) {
        break;
      }
    }
LABEL_11:
    uint64_t v2 = *(void *)(v2 + 56);
    if (!v2) {
      return 1;
    }
  }
  int v5 = v4 + 1;
  uint64_t v6 = *(void *)(v2 + 64) + 8 * v5 * (a2 + 1);
  while (!*(void *)v6 || (*(_DWORD *)(*(void *)v6 + 16) & 0x80000000) != 0)
  {
    v6 += 8;
    if (!--v5) {
      goto LABEL_11;
    }
  }
  return 0;
}

void sub_188687DA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188687DAC()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_params::get(kdu_params *this, const char *a2, int a3, int a4, int *a5, int a6, BOOL a7, BOOL a8)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if ((a4 | a3) < 0) {
    kdu_params::get();
  }
  int v12 = a3;
  uint64_t v15 = *((void *)this + 12);
  if (!v15)
  {
LABEL_10:
    *(void *)&long long v31 = 0;
    *(_OWORD *)uint64_t v29 = 0u;
    long long v30 = 0u;
    kdu_error::kdu_error((kdu_error *)v29, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v29 + 16))(v29, "Attempt to access a code-stream attribute using the invalid name");
    (*(void (**)(char *, const char *))(*(void *)v29 + 16))(v29, ", \"");
    (*(void (**)(char *, const char *))(*(void *)v29 + 16))(v29, a2);
    (*(void (**)(char *, const char *))(*(void *)v29 + 16))(v29, "\"!");
    kdu_error::~kdu_error((kdu_error *)v29);
  }
  uint64_t v16 = *((void *)this + 12);
  while (*(const char **)v16 != a2)
  {
    uint64_t v16 = *(void *)(v16 + 56);
    if (!v16)
    {
      while (strcmp(*(const char **)v15, a2))
      {
        uint64_t v15 = *(void *)(v15 + 56);
        if (!v15) {
          goto LABEL_10;
        }
      }
      uint64_t v16 = v15;
      break;
    }
  }
  if (*(_DWORD *)(v16 + 32) <= a4)
  {
    uint64_t v28 = 0;
    memset(v27, 0, sizeof(v27));
    kdu_error::kdu_error((kdu_error *)v27, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v27[0] + 16))(v27, "Attempt to access a code-stream attribute, with an invalid field index!\nThe attribute name is");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v27[0] + 16))(v27, " \"");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v27[0] + 16))(v27, a2);
    (*(void (**)(_OWORD *, const char *))(*(void *)&v27[0] + 16))(v27, "\".\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v27[0] + 16))(v27, "The field index is ");
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    *(_OWORD *)uint64_t v29 = 0u;
    if (BYTE8(v27[0])) {
      sprintf(v29, "%x");
    }
    else {
      sprintf(v29, "%d");
    }
    (*(void (**)(_OWORD *, char *))(*(void *)&v27[0] + 16))(v27, v29);
    (*(void (**)(_OWORD *, const char *))(*(void *)&v27[0] + 16))(v27, ".");
    kdu_error::~kdu_error((kdu_error *)v27);
  }
  uint64_t v17 = *(void *)(v16 + 40);
  if (v17)
  {
    uint64_t v18 = *(unsigned char **)(v17 + 24 * a4 + 8);
    if (v18)
    {
      if (*v18 == 70)
      {
        *(void *)&long long v31 = 0;
        *(_OWORD *)uint64_t v29 = 0u;
        long long v30 = 0u;
        kdu_error::kdu_error((kdu_error *)v29, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v29 + 16))(v29, "Attempting to access a floating point code-stream attribute field with the integer access method!\nThe attribute name is");
        (*(void (**)(char *, const char *))(*(void *)v29 + 16))(v29, " \"");
        (*(void (**)(char *, const char *))(*(void *)v29 + 16))(v29, a2);
        (*(void (**)(char *, const char *))(*(void *)v29 + 16))(v29, "\".");
        kdu_error::~kdu_error((kdu_error *)v29);
      }
    }
  }
  if (*(unsigned char *)(v16 + 48)) {
    int v19 = a8;
  }
  else {
    int v19 = 1;
  }
  if (*(int *)(v16 + 36) > 0) {
    int v20 = v19;
  }
  else {
    int v20 = 0;
  }
  if ((v20 & 1) == 0 && a6 && (!*((_DWORD *)this + 6) || *((unsigned char *)this + 42)))
  {
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0)
    {
      uint64_t v21 = (kdu_params *)kdu_params::access_relation(this, *((_DWORD *)this + 4), -1, 0, 1);
      if (v21)
      {
        if (*((_DWORD *)v21 + 4) == *((_DWORD *)this + 4)
          && (kdu_params::get(v21, a2, v12, a4, a5, 0, a7, a8) & 1) != 0)
        {
          return 1;
        }
      }
    }
    if ((*((_DWORD *)this + 4) & 0x80000000) == 0)
    {
      uint64_t v22 = (kdu_params *)kdu_params::access_relation(this, -1, *((_DWORD *)this + 5), *((_DWORD *)this + 6), 1);
      if (v22) {
        return kdu_params::get(v22, a2, v12, a4, a5, 1, a7, a8);
      }
    }
  }
  if (!v20) {
    return 0;
  }
  int v24 = *(_DWORD *)(v16 + 36);
  if (v24 <= v12 && a7 && (*(unsigned char *)(v16 + 16) & 2) != 0) {
    int v12 = v24 - 1;
  }
  uint64_t result = 0;
  if ((v12 & 0x80000000) == 0 && v12 < v24)
  {
    uint64_t v25 = v17 + 24 * a4;
    if (*(unsigned char *)(v25 + 24 * *(_DWORD *)(v16 + 32) * v12 + 16))
    {
      *a5 = *(_DWORD *)(v25 + 24 * *(_DWORD *)(v16 + 32) * v12);
      return 1;
    }
    return 0;
  }
  return result;
}

void sub_1886883A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886883B4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(v17);
}

uint64_t kdu_params::get(kdu_params *this, const char *a2, int a3, int a4, BOOL *a5, int a6, BOOL a7, BOOL a8)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if ((a4 | a3) < 0) {
    kdu_params::get();
  }
  int v12 = a3;
  uint64_t v15 = *((void *)this + 12);
  if (!v15)
  {
LABEL_10:
    *(void *)&long long v29 = 0;
    *(_OWORD *)uint64_t v27 = 0u;
    long long v28 = 0u;
    kdu_error::kdu_error((kdu_error *)v27, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, "Attempt to access a code-stream attribute using the invalid name");
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, ", \"");
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, a2);
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, "\"!");
    kdu_error::~kdu_error((kdu_error *)v27);
  }
  uint64_t v16 = *((void *)this + 12);
  while (*(const char **)v16 != a2)
  {
    uint64_t v16 = *(void *)(v16 + 56);
    if (!v16)
    {
      while (strcmp(*(const char **)v15, a2))
      {
        uint64_t v15 = *(void *)(v15 + 56);
        if (!v15) {
          goto LABEL_10;
        }
      }
      uint64_t v16 = v15;
      break;
    }
  }
  if (*(_DWORD *)(v16 + 32) <= a4)
  {
    uint64_t v26 = 0;
    memset(v25, 0, sizeof(v25));
    kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v25[0] + 16))(v25, "Attempt to access a code-stream attribute, with an invalid field index!\nThe attribute name is");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v25[0] + 16))(v25, " \"");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v25[0] + 16))(v25, a2);
    (*(void (**)(_OWORD *, const char *))(*(void *)&v25[0] + 16))(v25, "\".\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v25[0] + 16))(v25, "The field index is ");
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    *(_OWORD *)uint64_t v27 = 0u;
    if (BYTE8(v25[0])) {
      sprintf(v27, "%x");
    }
    else {
      sprintf(v27, "%d");
    }
    (*(void (**)(_OWORD *, char *))(*(void *)&v25[0] + 16))(v25, v27);
    (*(void (**)(_OWORD *, const char *))(*(void *)&v25[0] + 16))(v25, ".");
    kdu_error::~kdu_error((kdu_error *)v25);
  }
  uint64_t v17 = *(void *)(v16 + 40) + 24 * a4;
  if (**(unsigned char **)(v17 + 8) != 66)
  {
    *(void *)&long long v29 = 0;
    *(_OWORD *)uint64_t v27 = 0u;
    long long v28 = 0u;
    kdu_error::kdu_error((kdu_error *)v27, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, "Attempting to access a non-BOOLean code-stream attribute field with the BOOLean access method!\nThe attribute name is");
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, " \"");
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, a2);
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, "\".");
    kdu_error::~kdu_error((kdu_error *)v27);
  }
  if (*(unsigned char *)(v16 + 48)) {
    int v18 = a8;
  }
  else {
    int v18 = 1;
  }
  if (*(int *)(v16 + 36) > 0) {
    int v19 = v18;
  }
  else {
    int v19 = 0;
  }
  if ((v19 & 1) == 0 && a6 && (!*((_DWORD *)this + 6) || *((unsigned char *)this + 42)))
  {
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0)
    {
      int v20 = (kdu_params *)kdu_params::access_relation(this, *((_DWORD *)this + 4), -1, 0, 1);
      if (v20)
      {
        if (*((_DWORD *)v20 + 4) == *((_DWORD *)this + 4)
          && (kdu_params::get(v20, a2, v12, a4, a5, 0, a7, a8) & 1) != 0)
        {
          return 1;
        }
      }
    }
    if ((*((_DWORD *)this + 4) & 0x80000000) == 0)
    {
      uint64_t v21 = (kdu_params *)kdu_params::access_relation(this, -1, *((_DWORD *)this + 5), *((_DWORD *)this + 6), 1);
      if (v21) {
        return kdu_params::get(v21, a2, v12, a4, a5, 1, a7, a8);
      }
    }
  }
  if (!v19) {
    return 0;
  }
  int v23 = *(_DWORD *)(v16 + 36);
  if (v23 <= v12 && a7 && (*(unsigned char *)(v16 + 16) & 2) != 0) {
    int v12 = v23 - 1;
  }
  uint64_t result = 0;
  if ((v12 & 0x80000000) == 0 && v12 < v23)
  {
    if (*(unsigned char *)(v17 + 24 * *(_DWORD *)(v16 + 32) * v12 + 16))
    {
      *a5 = *(_DWORD *)(v17 + 24 * *(_DWORD *)(v16 + 32) * v12) != 0;
      return 1;
    }
    return 0;
  }
  return result;
}

void sub_1886889D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886889E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(v17);
}

uint64_t kdu_params::get(kdu_params *this, const char *a2, int a3, int a4, float *a5, int a6, BOOL a7, BOOL a8)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if ((a4 | a3) < 0) {
    kdu_params::get();
  }
  int v12 = a3;
  uint64_t v15 = *((void *)this + 12);
  if (!v15)
  {
LABEL_10:
    *(void *)&long long v29 = 0;
    *(_OWORD *)uint64_t v27 = 0u;
    long long v28 = 0u;
    kdu_error::kdu_error((kdu_error *)v27, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, "Attempt to access a code-stream attribute using the invalid name");
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, ", \"");
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, a2);
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, "\"!");
    kdu_error::~kdu_error((kdu_error *)v27);
  }
  uint64_t v16 = *((void *)this + 12);
  while (*(const char **)v16 != a2)
  {
    uint64_t v16 = *(void *)(v16 + 56);
    if (!v16)
    {
      while (strcmp(*(const char **)v15, a2))
      {
        uint64_t v15 = *(void *)(v15 + 56);
        if (!v15) {
          goto LABEL_10;
        }
      }
      uint64_t v16 = v15;
      break;
    }
  }
  if (*(_DWORD *)(v16 + 32) <= a4)
  {
    uint64_t v26 = 0;
    memset(v25, 0, sizeof(v25));
    kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v25[0] + 16))(v25, "Attempt to access a code-stream attribute, with an invalid field index!\nThe attribute name is");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v25[0] + 16))(v25, " \"");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v25[0] + 16))(v25, a2);
    (*(void (**)(_OWORD *, const char *))(*(void *)&v25[0] + 16))(v25, "\".\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v25[0] + 16))(v25, "The field index is ");
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    *(_OWORD *)uint64_t v27 = 0u;
    if (BYTE8(v25[0])) {
      sprintf(v27, "%x");
    }
    else {
      sprintf(v27, "%d");
    }
    (*(void (**)(_OWORD *, char *))(*(void *)&v25[0] + 16))(v25, v27);
    (*(void (**)(_OWORD *, const char *))(*(void *)&v25[0] + 16))(v25, ".");
    kdu_error::~kdu_error((kdu_error *)v25);
  }
  uint64_t v17 = *(void *)(v16 + 40) + 24 * a4;
  if (**(unsigned char **)(v17 + 8) != 70)
  {
    *(void *)&long long v29 = 0;
    *(_OWORD *)uint64_t v27 = 0u;
    long long v28 = 0u;
    kdu_error::kdu_error((kdu_error *)v27, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, "Attempting to access an integer code-stream parameter attribute field with the floating point access method!\nThe attribute name is");
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, " \"");
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, a2);
    (*(void (**)(char *, const char *))(*(void *)v27 + 16))(v27, "\".");
    kdu_error::~kdu_error((kdu_error *)v27);
  }
  if (*(unsigned char *)(v16 + 48)) {
    int v18 = a8;
  }
  else {
    int v18 = 1;
  }
  if (*(int *)(v16 + 36) > 0) {
    int v19 = v18;
  }
  else {
    int v19 = 0;
  }
  if ((v19 & 1) == 0 && a6 && (!*((_DWORD *)this + 6) || *((unsigned char *)this + 42)))
  {
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0)
    {
      int v20 = (kdu_params *)kdu_params::access_relation(this, *((_DWORD *)this + 4), -1, 0, 1);
      if (v20)
      {
        if (*((_DWORD *)v20 + 4) == *((_DWORD *)this + 4)
          && (kdu_params::get(v20, a2, v12, a4, a5, 0, a7, a8) & 1) != 0)
        {
          return 1;
        }
      }
    }
    if ((*((_DWORD *)this + 4) & 0x80000000) == 0)
    {
      uint64_t v21 = (kdu_params *)kdu_params::access_relation(this, -1, *((_DWORD *)this + 5), *((_DWORD *)this + 6), 1);
      if (v21) {
        return kdu_params::get(v21, a2, v12, a4, a5, 1, a7, a8);
      }
    }
  }
  if (!v19) {
    return 0;
  }
  int v23 = *(_DWORD *)(v16 + 36);
  if (v23 <= v12 && a7 && (*(unsigned char *)(v16 + 16) & 2) != 0) {
    int v12 = v23 - 1;
  }
  uint64_t result = 0;
  if ((v12 & 0x80000000) == 0 && v12 < v23)
  {
    if (*(unsigned char *)(v17 + 24 * *(_DWORD *)(v16 + 32) * v12 + 16))
    {
      *a5 = *(float *)(v17 + 24 * *(_DWORD *)(v16 + 32) * v12);
      return 1;
    }
    return 0;
  }
  return result;
}

void sub_188688FF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188689004(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(v17);
}

const char *kdu_params::set(kdu_params *this, const char *__s2, int a3, int a4, int *a5)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if ((a4 | a3) < 0) {
    kdu_params::set();
  }
  uint64_t v7 = *((void *)this + 12);
  if (!v7)
  {
LABEL_50:
    *(void *)&long long v27 = 0;
    *(_OWORD *)uint64_t v25 = 0u;
    long long v26 = 0u;
    kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, "Attempt to set a code-stream attribute using the invalid name");
    (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, ", \"");
    (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, __s2);
    (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, "\"!");
    kdu_error::~kdu_error((kdu_error *)v25);
  }
  unsigned int v8 = a5;
  uint64_t v11 = *((void *)this + 12);
  while (*(const char **)v11 != __s2)
  {
    uint64_t v11 = *(void *)(v11 + 56);
    if (!v11)
    {
      while (strcmp(*(const char **)v7, __s2))
      {
        uint64_t v7 = *(void *)(v7 + 56);
        if (!v7) {
          goto LABEL_50;
        }
      }
      uint64_t v11 = v7;
      break;
    }
  }
  if ((*(unsigned char *)(v11 + 16) & 4) != 0 && *((_DWORD *)this + 5) != -1)
  {
    *(void *)&long long v27 = 0;
    *(_OWORD *)uint64_t v25 = 0u;
    long long v26 = 0u;
    kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, "Attempt to set a non-tile-specific code-stream attribute in a specific component!\nThe attribute name is");
    (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, " \"");
    (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, __s2);
    (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, "\".");
    kdu_error::~kdu_error((kdu_error *)v25);
  }
  if (*(_DWORD *)(v11 + 32) <= a4)
  {
    uint64_t v24 = 0;
    long long v22 = 0u;
    long long v23 = 0u;
    kdu_error::kdu_error((kdu_error *)&v22, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v22 + 16))(&v22, "Attempt to set a code-stream attribute, with an invalid field index!\nThe attribute name is");
    (*(void (**)(long long *, const char *))(v22 + 16))(&v22, " \"");
    (*(void (**)(long long *, const char *))(v22 + 16))(&v22, __s2);
    (*(void (**)(long long *, const char *))(v22 + 16))(&v22, "\".\n");
    (*(void (**)(long long *, const char *))(v22 + 16))(&v22, "The field index is ");
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    *(_OWORD *)uint64_t v25 = 0u;
    if (BYTE8(v22)) {
      sprintf(v25, "%x");
    }
    else {
      sprintf(v25, "%d");
    }
    (*(void (**)(long long *, char *))(v22 + 16))(&v22, v25);
    (*(void (**)(long long *, const char *))(v22 + 16))(&v22, ".");
    kdu_error::~kdu_error((kdu_error *)&v22);
  }
  uint64_t result = *(const char **)(*(void *)(v11 + 40) + 24 * a4 + 8);
  int v13 = *(unsigned __int8 *)result;
  switch(*result)
  {
    case 'B':
      if (v8 >= 2)
      {
        *(void *)&long long v27 = 0;
        *(_OWORD *)uint64_t v25 = 0u;
        long long v26 = 0u;
        kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, "Attempting to set a BOOLean code-stream parameter attribute field with an integer not equal to 0 or 1!\nThe attribute name is");
        (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, " \"");
        (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, __s2);
        (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, "\".");
        kdu_error::~kdu_error((kdu_error *)v25);
      }
      goto LABEL_38;
    case 'C':
    case 'I':
      goto LABEL_38;
    case 'D':
    case 'E':
    case 'G':
    case 'H':
      goto LABEL_51;
    case 'F':
      *(void *)&long long v27 = 0;
      *(_OWORD *)uint64_t v25 = 0u;
      long long v26 = 0u;
      kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, "Attempting to set a floating point code-stream parameter attribute field with the integer access method!\nThe attribute name is");
      (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, " \"");
      (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, __s2);
      (*(void (**)(char *, const char *))(*(void *)v25 + 16))(v25, "\".");
      kdu_error::~kdu_error((kdu_error *)v25);
    default:
      if (v13 == 40)
      {
        long long v28 = 0u;
        long long v29 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        *(_OWORD *)uint64_t v25 = 0u;
        int v21 = 0;
        do
          uint64_t result = parse_translator_entry(result + 1, 0x2Cu, v25, &v21, a5);
        while (*result == 44 && v21 != v8);
        if (v21 != v8)
        {
          uint64_t v24 = 0;
          long long v22 = 0u;
          long long v23 = 0u;
          kdu_error::kdu_error((kdu_error *)&v22, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v22 + 16))(&v22, "Attempting to set a code-stream attribute field using an integer value which does not match any of the defined translation values for the field!\nThe attribute name is");
          (*(void (**)(long long *, const char *))(v22 + 16))(&v22, " \"");
          (*(void (**)(long long *, const char *))(v22 + 16))(&v22, __s2);
          (*(void (**)(long long *, const char *))(v22 + 16))(&v22, "\".");
          kdu_error::~kdu_error((kdu_error *)&v22);
        }
      }
      else
      {
        if (v13 != 91) {
LABEL_51:
        }
          kdu_params::set();
        int v14 = 0;
        long long v28 = 0u;
        long long v29 = 0u;
        long long v26 = 0u;
        long long v27 = 0u;
        *(_OWORD *)uint64_t v25 = 0u;
        int v21 = 0;
        do
        {
          uint64_t result = parse_translator_entry(result + 1, 0x7Cu, v25, &v21, a5);
          int v15 = v21;
          if ((v21 & ~v8) != 0) {
            int v15 = 0;
          }
          v14 |= v15;
        }
        while (*result == 124);
        if (v14 != v8)
        {
          uint64_t v24 = 0;
          long long v22 = 0u;
          long long v23 = 0u;
          kdu_error::kdu_error((kdu_error *)&v22, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v22 + 16))(&v22, "Attempting to set a code-stream attribute field using an integer value which is incompatible with the flags defined for the field!\nThe attribute name is");
          (*(void (**)(long long *, const char *))(v22 + 16))(&v22, " \"");
          (*(void (**)(long long *, const char *))(v22 + 16))(&v22, __s2);
          (*(void (**)(long long *, const char *))(v22 + 16))(&v22, "\".");
          kdu_error::~kdu_error((kdu_error *)&v22);
        }
      }
LABEL_38:
      int v17 = *(_DWORD *)(v11 + 36);
      if (v17 <= a3) {
        uint64_t result = (const char *)kd_attribute::augment_records(v11, a3 + 1);
      }
      if (a3 < 0 || *(_DWORD *)(v11 + 36) <= a3) {
        kdu_params::set();
      }
      uint64_t v18 = *(void *)(v11 + 40) + 24 * a4 + 24 * *(_DWORD *)(v11 + 32) * a3;
      if ((!*(unsigned char *)(v18 + 16) || v17 <= a3 || *(_DWORD *)v18 != v8) && !*((unsigned char *)this + 104))
      {
        *((unsigned char *)this + 104) = 1;
        uint64_t v19 = *((void *)this + 10);
        *(unsigned char *)(v19 + 104) = 1;
        uint64_t v20 = **(void **)(v19 + 64);
        *(unsigned char *)(v20 + 104) = 1;
        *(unsigned char *)(*(void *)(v20 + 48) + 104) = 1;
      }
      *(unsigned char *)(v18 + 16) = 1;
      *(_DWORD *)uint64_t v18 = v8;
      *((unsigned char *)this + 36) = 0;
      return result;
  }
}

void sub_188689A18(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188689A24(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(v17);
}

uint64_t kdu_params::set(uint64_t this, const char *__s2, int a3, int a4, int a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if ((a4 | a3) < 0) {
    kdu_params::set();
  }
  uint64_t v6 = this;
  uint64_t v7 = *(void *)(this + 96);
  if (!v7)
  {
LABEL_32:
    *(void *)&long long v20 = 0;
    *(_OWORD *)uint64_t v18 = 0u;
    long long v19 = 0u;
    kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "Attempt to set a code-stream attribute using the invalid name");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, ", \"");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, __s2);
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "\"!");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  uint64_t v11 = *(void *)(this + 96);
  while (*(const char **)v11 != __s2)
  {
    uint64_t v11 = *(void *)(v11 + 56);
    if (!v11)
    {
      while (1)
      {
        this = strcmp(*(const char **)v7, __s2);
        if (!this) {
          break;
        }
        uint64_t v7 = *(void *)(v7 + 56);
        if (!v7) {
          goto LABEL_32;
        }
      }
      uint64_t v11 = v7;
      break;
    }
  }
  if ((*(unsigned char *)(v11 + 16) & 4) != 0 && *(_DWORD *)(v6 + 20) != -1)
  {
    *(void *)&long long v20 = 0;
    *(_OWORD *)uint64_t v18 = 0u;
    long long v19 = 0u;
    kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "Attempt to set a non-tile-specific code-stream attribute in a specific component!\nThe attribute name is");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, " \"");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, __s2);
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "\".");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  if (*(_DWORD *)(v11 + 32) <= a4)
  {
    uint64_t v17 = 0;
    memset(v16, 0, sizeof(v16));
    kdu_error::kdu_error((kdu_error *)v16, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v16[0] + 16))(v16, "Attempt to set a code-stream attribute, with an invalid field index!\nThe attribute name is");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v16[0] + 16))(v16, " \"");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v16[0] + 16))(v16, __s2);
    (*(void (**)(_OWORD *, const char *))(*(void *)&v16[0] + 16))(v16, "\".\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v16[0] + 16))(v16, "The field index is ");
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    *(_OWORD *)uint64_t v18 = 0u;
    if (BYTE8(v16[0])) {
      sprintf(v18, "%x");
    }
    else {
      sprintf(v18, "%d");
    }
    (*(void (**)(_OWORD *, char *))(*(void *)&v16[0] + 16))(v16, v18);
    (*(void (**)(_OWORD *, const char *))(*(void *)&v16[0] + 16))(v16, ".");
    kdu_error::~kdu_error((kdu_error *)v16);
  }
  if (**(unsigned char **)(*(void *)(v11 + 40) + 24 * a4 + 8) != 66)
  {
    *(void *)&long long v20 = 0;
    *(_OWORD *)uint64_t v18 = 0u;
    long long v19 = 0u;
    kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "Attempting to set a non-BOOLean code-stream parameter attribute field with the BOOLean access method!\nThe attribute name is");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, " \"");
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, __s2);
    (*(void (**)(char *, const char *))(*(void *)v18 + 16))(v18, "\".");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  int v12 = *(_DWORD *)(v11 + 36);
  if (v12 <= a3) {
    this = kd_attribute::augment_records(v11, a3 + 1);
  }
  if (a3 < 0 || *(_DWORD *)(v11 + 36) <= a3) {
    kdu_params::set();
  }
  uint64_t v13 = *(void *)(v11 + 40) + 24 * a4 + 24 * *(_DWORD *)(v11 + 32) * a3;
  if ((!*(unsigned char *)(v13 + 16) || v12 <= a3 || *(_DWORD *)v13 != a5) && !*(unsigned char *)(v6 + 104))
  {
    *(unsigned char *)(v6 + 104) = 1;
    uint64_t v14 = *(void *)(v6 + 80);
    *(unsigned char *)(v14 + 104) = 1;
    uint64_t v15 = **(void **)(v14 + 64);
    *(unsigned char *)(v15 + 104) = 1;
    *(unsigned char *)(*(void *)(v15 + 48) + 104) = 1;
  }
  *(unsigned char *)(v13 + 16) = 1;
  *(_DWORD *)uint64_t v13 = a5;
  *(unsigned char *)(v6 + 36) = 0;
  return this;
}

void sub_18868A0F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18868A0FC(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(v17);
}

uint64_t kdu_params::set(uint64_t this, const char *__s2, int a3, int a4, double a5)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if ((a4 | a3) < 0) {
    kdu_params::set();
  }
  uint64_t v6 = this;
  uint64_t v7 = *(void *)(this + 96);
  if (!v7)
  {
LABEL_32:
    *(void *)&long long v22 = 0;
    *(_OWORD *)long long v20 = 0u;
    long long v21 = 0u;
    kdu_error::kdu_error((kdu_error *)v20, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v20 + 16))(v20, "Attempt to set a code-stream attribute using the invalid name");
    (*(void (**)(char *, const char *))(*(void *)v20 + 16))(v20, ", \"");
    (*(void (**)(char *, const char *))(*(void *)v20 + 16))(v20, __s2);
    (*(void (**)(char *, const char *))(*(void *)v20 + 16))(v20, "\"!");
    kdu_error::~kdu_error((kdu_error *)v20);
  }
  uint64_t v11 = *(void *)(this + 96);
  while (*(const char **)v11 != __s2)
  {
    uint64_t v11 = *(void *)(v11 + 56);
    if (!v11)
    {
      while (1)
      {
        this = strcmp(*(const char **)v7, __s2);
        if (!this) {
          break;
        }
        uint64_t v7 = *(void *)(v7 + 56);
        if (!v7) {
          goto LABEL_32;
        }
      }
      uint64_t v11 = v7;
      break;
    }
  }
  if ((*(unsigned char *)(v11 + 16) & 4) != 0 && *(_DWORD *)(v6 + 20) != -1)
  {
    *(void *)&long long v22 = 0;
    *(_OWORD *)long long v20 = 0u;
    long long v21 = 0u;
    kdu_error::kdu_error((kdu_error *)v20, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v20 + 16))(v20, "Attempt to set a non-tile-specific code-stream attribute in a specific component!\nThe attribute name is");
    (*(void (**)(char *, const char *))(*(void *)v20 + 16))(v20, " \"");
    (*(void (**)(char *, const char *))(*(void *)v20 + 16))(v20, __s2);
    (*(void (**)(char *, const char *))(*(void *)v20 + 16))(v20, "\".");
    kdu_error::~kdu_error((kdu_error *)v20);
  }
  if (*(_DWORD *)(v11 + 32) <= a4)
  {
    uint64_t v19 = 0;
    memset(v18, 0, sizeof(v18));
    kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v18[0] + 16))(v18, "Attempt to set a code-stream attribute, with an invalid field index!\nThe attribute name is");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v18[0] + 16))(v18, " \"");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v18[0] + 16))(v18, __s2);
    (*(void (**)(_OWORD *, const char *))(*(void *)&v18[0] + 16))(v18, "\".\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v18[0] + 16))(v18, "The field index is ");
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    *(_OWORD *)long long v20 = 0u;
    if (BYTE8(v18[0])) {
      sprintf(v20, "%x");
    }
    else {
      sprintf(v20, "%d");
    }
    (*(void (**)(_OWORD *, char *))(*(void *)&v18[0] + 16))(v18, v20);
    (*(void (**)(_OWORD *, const char *))(*(void *)&v18[0] + 16))(v18, ".");
    kdu_error::~kdu_error((kdu_error *)v18);
  }
  if (**(unsigned char **)(*(void *)(v11 + 40) + 24 * a4 + 8) != 70)
  {
    *(void *)&long long v22 = 0;
    *(_OWORD *)long long v20 = 0u;
    long long v21 = 0u;
    kdu_error::kdu_error((kdu_error *)v20, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v20 + 16))(v20, "Attempting to set an integer code-stream parameter attribute field with the floating point access method!\nThe attribute name is");
    (*(void (**)(char *, const char *))(*(void *)v20 + 16))(v20, " \"");
    (*(void (**)(char *, const char *))(*(void *)v20 + 16))(v20, __s2);
    (*(void (**)(char *, const char *))(*(void *)v20 + 16))(v20, "\".");
    kdu_error::~kdu_error((kdu_error *)v20);
  }
  int v12 = *(_DWORD *)(v11 + 36);
  if (v12 <= a3) {
    this = kd_attribute::augment_records(v11, a3 + 1);
  }
  if (a3 < 0 || *(_DWORD *)(v11 + 36) <= a3) {
    kdu_params::set();
  }
  uint64_t v13 = *(void *)(v11 + 40) + 24 * a4 + 24 * *(_DWORD *)(v11 + 32) * a3;
  if (!*(unsigned char *)(v13 + 16) || v12 <= a3 || (float v14 = a5, *(float *)v13 != v14))
  {
    if (!*(unsigned char *)(v6 + 104))
    {
      *(unsigned char *)(v6 + 104) = 1;
      uint64_t v15 = *(void *)(v6 + 80);
      *(unsigned char *)(v15 + 104) = 1;
      uint64_t v16 = **(void **)(v15 + 64);
      *(unsigned char *)(v16 + 104) = 1;
      *(unsigned char *)(*(void *)(v16 + 48) + 104) = 1;
    }
  }
  *(unsigned char *)(v13 + 16) = 1;
  float v17 = a5;
  *(float *)uint64_t v13 = v17;
  *(unsigned char *)(v6 + 36) = 0;
  return this;
}

void sub_18868A780(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18868A78C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(v17);
}

uint64_t kdu_params::set_derived(uint64_t this, const char *__s2)
{
  uint64_t v3 = *(void *)(this + 96);
  if (!v3)
  {
LABEL_10:
    uint64_t v6 = 0;
    memset(v5, 0, sizeof(v5));
    kdu_error::kdu_error((kdu_error *)v5, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, "Invalid attribute name");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, ", \"");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, __s2);
    (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, "\", ");
    kdu_error::~kdu_error((kdu_error *)v5);
  }
  uint64_t v4 = *(void *)(this + 96);
  while (*(const char **)v4 != __s2)
  {
    uint64_t v4 = *(void *)(v4 + 56);
    if (!v4)
    {
      while (1)
      {
        this = strcmp(*(const char **)v3, __s2);
        if (!this) {
          break;
        }
        uint64_t v3 = *(void *)(v3 + 56);
        if (!v3) {
          goto LABEL_10;
        }
      }
      uint64_t v4 = v3;
      break;
    }
  }
  *(unsigned char *)(v4 + 48) = 1;
  return this;
}

void sub_18868A96C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18868A978()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_params::parse_string(kdu_params *this, char *a2)
{
  uint64_t v2 = a2;
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  while (1)
  {
    __endptr = v2;
    unsigned int v3 = *v2;
    if (v3 <= 0x3D)
    {
      if (((1 << v3) & 0x100000600) != 0)
      {
        *(void *)&long long v68 = 0;
        *(_OWORD *)__int16 v66 = 0u;
        long long v67 = 0u;
        kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Malformed attribute string");
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
        (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\"!\n");
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "White space characters are illegal!");
        kdu_error::~kdu_error((kdu_error *)v66);
      }
      if (((1 << v3) & 0x2400000000000001) != 0) {
        break;
      }
    }
    ++v2;
  }
  uint64_t v4 = this;
  int v5 = (const char **)*((void *)this + 12);
  if (!v5)
  {
LABEL_12:
    if (*((kdu_params **)this + 6) != this) {
      return 0;
    }
    do
    {
      uint64_t v4 = (kdu_params *)*((void *)v4 + 7);
      BOOL v8 = v4 != 0;
    }
    while (v4 && (kdu_params::parse_string(v4, a2) & 1) == 0);
    return v8;
  }
  size_t v6 = v2 - a2;
  while (1)
  {
    uint64_t v7 = *v5;
    if (!strncmp(*v5, a2, v6) && strlen(v7) == v6) {
      break;
    }
    int v5 = (const char **)v5[7];
    if (!v5) {
      goto LABEL_12;
    }
  }
  if (!v3)
  {
    *(void *)&long long v68 = 0;
    *(_OWORD *)__int16 v66 = 0u;
    long long v67 = 0u;
    kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Attribute");
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, " \"");
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, *v5);
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\" ");
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "is missing parameters:\n\n\t");
    kd_attribute::describe((kd_attribute *)v5, (kdu_message *)v66, *((unsigned __int8 *)this + 38), *((unsigned __int8 *)this + 39), *((unsigned __int8 *)this + 42), 1);
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\nParameter values must be separated from the attribute name and optional location specifiers by an '=' sign!\n");
    kdu_error::~kdu_error((kdu_error *)v66);
  }
  if (v3 == 58)
  {
    uint64_t v9 = v2 + 1;
    int v10 = -1;
    __endptr = v2 + 1;
    int v11 = -2;
    int v12 = -2;
    while (1)
    {
      int v13 = *v9;
      if (!*v9 || v13 == 61) {
        break;
      }
      if (v13 == 84 && v11 <= -2)
      {
        int v11 = strtol(v9 + 1, &__endptr, 10);
      }
      else if (v13 == 67 && v12 <= -2)
      {
        int v12 = strtol(v9 + 1, &__endptr, 10);
      }
      else
      {
        if (v13 != 73 || (v10 & 0x80000000) == 0)
        {
          *(void *)&long long v68 = 0;
          *(_OWORD *)__int16 v66 = 0u;
          long long v67 = 0u;
          kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Malformed location specifier encountered in attribute string");
          (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
          (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
          (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\"!\n");
          (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Tile specifiers following the the colon must have the form \"T<num>\", while component specifiers must have the form \"C<num>\" and index specifiers must have the form \"I<num>\". There may be at most one of each!");
          kdu_error::~kdu_error((kdu_error *)v66);
        }
        int v10 = strtol(v9 + 1, &__endptr, 10);
      }
      uint64_t v9 = __endptr;
    }
    uint64_t v4 = this;
    if (v11 > -2) {
      goto LABEL_41;
    }
  }
  else
  {
    int v12 = -2;
    int v10 = -1;
  }
  int v11 = *((_DWORD *)v4 + 4);
LABEL_41:
  if (v12 <= -2) {
    int v12 = *((_DWORD *)v4 + 5);
  }
  if (v10 < 0)
  {
    if (v11 == *((_DWORD *)v4 + 4) && v12 == *((_DWORD *)v4 + 5))
    {
      int v10 = *((_DWORD *)v4 + 6);
    }
    else
    {
      if (*((unsigned char *)v4 + 42))
      {
        *(void *)&long long v68 = 0;
        *(_OWORD *)__int16 v66 = 0u;
        long long v67 = 0u;
        kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Malformed location specifier encountered in attribute string");
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
        (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\"!\n");
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "You must supply an index specifier of the form \"I<num>\" for this type of parameter.");
        kdu_error::~kdu_error((kdu_error *)v66);
      }
      int v10 = 0;
    }
  }
  else if (!*((unsigned char *)v4 + 42))
  {
    *(void *)&long long v68 = 0;
    *(_OWORD *)__int16 v66 = 0u;
    long long v67 = 0u;
    kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Malformed location specifier encountered in attribute string");
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
    (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\"!\n");
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "This type of parameter cannot be used with an index specifier (i.e., a specifier of the form \"I<num>\").");
    kdu_error::~kdu_error((kdu_error *)v66);
  }
  if (*((_DWORD *)v4 + 4) != v11 || *((_DWORD *)v4 + 5) != v12 || *((_DWORD *)v4 + 6) != v10)
  {
    uint64_t v16 = (kdu_params *)kdu_params::access_relation(v4, v11, v12, v10, 0);
    if (!v16)
    {
      *(void *)&long long v68 = 0;
      *(_OWORD *)__int16 v66 = 0u;
      long long v67 = 0u;
      kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Attribute string");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
      (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\", ");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "refers to a non-existent tile-component!");
      kdu_error::~kdu_error((kdu_error *)v66);
    }
    return kdu_params::parse_string(v16, a2);
  }
  if (*((unsigned char *)v4 + 37))
  {
    *(void *)&long long v68 = 0;
    *(_OWORD *)__int16 v66 = 0u;
    long long v67 = 0u;
    kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)v66);
  }
  if (((_BYTE)v5[2] & 4) != 0 && *((_DWORD *)v4 + 5) != -1)
  {
    *(void *)&long long v68 = 0;
    *(_OWORD *)__int16 v66 = 0u;
    long long v67 = 0u;
    kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Attempt to set a non-tile-specific code-stream attribute in a specific component!\nProblem occurred while parsing the attribute string");
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
    (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\".");
    kdu_error::~kdu_error((kdu_error *)v66);
  }
  if (*__endptr != 61)
  {
    *(void *)&long long v68 = 0;
    *(_OWORD *)__int16 v66 = 0u;
    long long v67 = 0u;
    kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Malformed attribute string");
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
    (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\"!\n");
    (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Parameter values must be separated from the attribute name and optional location specifiers by an '=' sign!");
    kdu_error::~kdu_error((kdu_error *)v66);
  }
  if (*((int *)v5 + 9) >= 1 && *((unsigned char *)v5 + 49))
  {
    if (!*((unsigned char *)v4 + 40)
      || *((unsigned char *)v4 + 42)
      || !*((void *)v4 + 11) && (v54 = kdu_params::new_instance(v4), uint64_t v4 = this, !v54))
    {
      *(void *)&long long v68 = 0;
      *(_OWORD *)__int16 v66 = 0u;
      long long v67 = 0u;
      kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "The supplied attribute string");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
      (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\", ");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "refers to code-stream parameters which have already been parsed out of some string.  Moreover, multiple instances of this attribute are not permitted here!");
      kdu_error::~kdu_error((kdu_error *)v66);
    }
    uint64_t v16 = (kdu_params *)*((void *)v4 + 11);
    if (!v16) {
      kdu_params::parse_string();
    }
    return kdu_params::parse_string(v16, a2);
  }
  kdu_params::delete_unparsed_attribute((uint64_t)v4, *v5);
  *((unsigned char *)v5 + 49) = 1;
  uint64_t v18 = __endptr;
  int v55 = setlocale(4, 0);
  setlocale(4, "C");
  long long v20 = v18 + 1;
  int v21 = v18[1];
  if (!v18[1]) {
    goto LABEL_173;
  }
  int v22 = 0;
  char v59 = 0;
  do
  {
    if (v22)
    {
      if (v21 != 44)
      {
        *(void *)&long long v68 = 0;
        *(_OWORD *)__int16 v66 = 0u;
        long long v67 = 0u;
        kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Malformed attribute string");
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
        (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\"!\n");
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Problem encountered at");
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, " \"");
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, v20);
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\".\n");
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Records must be separated by commas.");
        kdu_error::~kdu_error((kdu_error *)v66);
      }
      if (((_BYTE)v5[2] & 1) == 0)
      {
        *(void *)&long long v68 = 0;
        *(_OWORD *)__int16 v66 = 0u;
        long long v67 = 0u;
        kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Malformed attribute string");
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
        (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\"!\n");
        (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Attribute does not support multiple parameter records!");
        kdu_error::~kdu_error((kdu_error *)v66);
      }
      int v23 = *(unsigned __int8 *)++v20;
      int v21 = v23;
    }
    if (v21 == 123)
    {
      ++v20;
    }
    else if (*((int *)v5 + 8) >= 2)
    {
      *(void *)&long long v68 = 0;
      *(_OWORD *)__int16 v66 = 0u;
      long long v67 = 0u;
      kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Malformed attribute string");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
      (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\"!\n");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Problem encountered at");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, " \"");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, v20);
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\".\n");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Records must be enclosed by curly braces, i.e., '{' and '}'.");
      kdu_error::~kdu_error((kdu_error *)v66);
    }
    int v56 = v21;
    if (*((_DWORD *)v5 + 9) <= v22)
    {
      kd_attribute::augment_records((uint64_t)v5, v22 + 1);
      char v59 = 1;
    }
    LODWORD(v24) = *((_DWORD *)v5 + 8);
    if ((int)v24 < 1)
    {
      __int16 v43 = (char *)v20;
      goto LABEL_165;
    }
    uint64_t v25 = 0;
    do
    {
      if (v25)
      {
        if (*v20 != 44)
        {
          *(void *)&long long v68 = 0;
          *(_OWORD *)__int16 v66 = 0u;
          long long v67 = 0u;
          kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Malformed attribute string");
          (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
          (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
          (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\"!\n");
          (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Problem encountered at");
          (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, " \"");
          (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, v20);
          (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\".\n");
          (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Fields must be separated by commas.");
          kdu_error::~kdu_error((kdu_error *)v66);
        }
        ++v20;
      }
      uint64_t v26 = (uint64_t)&v5[5][24 * (int)v24 * v22];
      uint64_t v27 = v26 + 24 * v25;
      long long v29 = (char **)(v27 + 8);
      long long v28 = *(char **)(v27 + 8);
      int v30 = *v28;
      switch(*v28)
      {
        case 'B':
          float v31 = *(float *)v27;
          if (!strncmp(v20, "yes", 3uLL))
          {
            *(_DWORD *)uint64_t v27 = 1;
            __int16 v43 = (char *)(v20 + 3);
          }
          else
          {
            if (strncmp(v20, "no", 2uLL))
            {
              *(void *)&long long v68 = 0;
              *(_OWORD *)__int16 v66 = 0u;
              long long v67 = 0u;
              kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
              (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Malformed attribute string");
              (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
              (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
              (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\"!\n");
              (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Problem encountered at");
              (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, " \"");
              (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, v20);
              (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\".\n");
              (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Expected a BOOLean field identifier, i.e., one of \"yes\" or \"no\".");
              kdu_error::~kdu_error((kdu_error *)v66);
            }
            *(_DWORD *)uint64_t v27 = 0;
            __int16 v43 = (char *)(v20 + 2);
          }
          if (!*(unsigned char *)(v26 + 24 * v25 + 16) || LODWORD(v31) != *(_DWORD *)v27) {
            char v59 = 1;
          }
          goto LABEL_162;
        case 'C':
          LODWORD(v61) = 0;
          int v44 = (*(uint64_t (**)(kdu_params *, const char *, const char *, uint64_t, long long *))(*(void *)this + 56))(this, v20, *v5, v25, &v61);
          if (!*(unsigned char *)(v26 + 24 * v25 + 16) || *(_DWORD *)v27 != v61) {
            char v59 = 1;
          }
          *(_DWORD *)uint64_t v27 = v61;
          if (v44 <= 0)
          {
            *(void *)&long long v68 = 0;
            *(_OWORD *)__int16 v66 = 0u;
            long long v67 = 0u;
            kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Malformed attribute string");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
            (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\"!\n");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Problem encountered at");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, " \"");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, v20);
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\".\n");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Attempt to parse custom string representation failed.  Read usage information carefully.");
            kdu_error::~kdu_error((kdu_error *)v66);
          }
          __int16 v43 = (char *)&v20[v44];
          goto LABEL_162;
        case 'D':
        case 'E':
        case 'G':
        case 'H':
          goto LABEL_178;
        case 'F':
          float v45 = strtod(v20, &__endptr);
          if (!*(unsigned char *)(v26 + 24 * v25 + 16) || *(float *)v27 != v45) {
            char v59 = 1;
          }
          *(float *)uint64_t v27 = v45;
          __int16 v43 = __endptr;
          if (__endptr == v20)
          {
            *(void *)&long long v68 = 0;
            *(_OWORD *)__int16 v66 = 0u;
            long long v67 = 0u;
            kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Malformed attribute string");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
            (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\"!\n");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Problem encountered at");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, " \"");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, v20);
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\".\n");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Expected a floating point field.");
            kdu_error::~kdu_error((kdu_error *)v66);
          }
          goto LABEL_162;
        case 'I':
          int v46 = strtol(v20, &__endptr, 10);
          if (!*(unsigned char *)(v26 + 24 * v25 + 16) || *(_DWORD *)v27 != v46) {
            char v59 = 1;
          }
          *(_DWORD *)uint64_t v27 = v46;
          __int16 v43 = __endptr;
          if (__endptr == v20)
          {
            *(void *)&long long v68 = 0;
            *(_OWORD *)__int16 v66 = 0u;
            long long v67 = 0u;
            kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Malformed attribute string");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
            (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\"!\n");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Problem encountered at");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, " \"");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, v20);
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\".\n");
            (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Expected an integer field.");
            kdu_error::~kdu_error((kdu_error *)v66);
          }
          goto LABEL_162;
        default:
          if (v30 != 40)
          {
            if (v30 != 91) {
LABEL_178:
            }
              kdu_params::parse_string();
            float v57 = *(float *)v27;
            *(_DWORD *)uint64_t v27 = 0;
            while (1)
            {
              long long v69 = 0u;
              long long v70 = 0u;
              long long v67 = 0u;
              long long v68 = 0u;
              *(_OWORD *)__int16 v66 = 0u;
              int v64 = 0;
              uint64_t v32 = *v29;
              if (*v20 == 124) {
                long long v33 = (char *)(v20 + 1);
              }
              else {
                long long v33 = (char *)v20;
              }
              do
              {
                uint64_t v32 = parse_translator_entry(v32 + 1, 0x7Cu, v66, &v64, v19);
                int v34 = v66[0];
                long long v20 = v33;
                if (v66[0])
                {
                  __int16 v35 = &v66[1];
                  long long v20 = v33;
                  while (v34 == *(unsigned __int8 *)v20)
                  {
                    ++v20;
                    int v36 = *v35++;
                    int v34 = v36;
                    if (!v36) {
                      goto LABEL_107;
                    }
                  }
                }
                else
                {
LABEL_107:
                  int v37 = *(unsigned __int8 *)v20;
                  BOOL v38 = (v37 - 124) < 2 || v37 == 0;
                  if (v38 || v37 == 44) {
                    goto LABEL_119;
                  }
                }
              }
              while (*v32 == 124);
              if (*v33 != 48 || (int v39 = v33[1], (v39 - 124) >= 2) && v39 != 44 && v33[1])
              {
                uint64_t v63 = 0;
                long long v61 = 0u;
                long long v62 = 0u;
                kdu_error::kdu_error((kdu_error *)&v61, "Kakadu Core Error:\n");
                (*(void (**)(long long *, const char *))(v61 + 16))(&v61, "Malformed attribute string");
                (*(void (**)(long long *, const char *))(v61 + 16))(&v61, ", \"");
                (*(void (**)(long long *, char *))(v61 + 16))(&v61, a2);
                (*(void (**)(long long *, const char *))(v61 + 16))(&v61, "\"!\n");
                (*(void (**)(long long *, const char *))(v61 + 16))(&v61, "Problem encountered at");
                (*(void (**)(long long *, const char *))(v61 + 16))(&v61, " \"");
                (*(void (**)(long long *, char *))(v61 + 16))(&v61, v33);
                (*(void (**)(long long *, const char *))(v61 + 16))(&v61, "\".\n");
                display_options(*v29, (kdu_message *)&v61);
                kdu_error::~kdu_error((kdu_error *)&v61);
              }
              int v64 = 0;
              long long v20 = v33 + 1;
LABEL_119:
              int v40 = *(_DWORD *)v27 | v64;
              *(_DWORD *)uint64_t v27 = v40;
              if (*v20 != 124)
              {
                if (*(unsigned char *)(v26 + 24 * v25 + 16)) {
                  BOOL v41 = LODWORD(v57) == v40;
                }
                else {
                  BOOL v41 = 0;
                }
                char v42 = !v41;
                v59 |= v42;
                __int16 v43 = (char *)v20;
                goto LABEL_162;
              }
            }
          }
          long long v69 = 0u;
          long long v70 = 0u;
          long long v67 = 0u;
          long long v68 = 0u;
          *(_OWORD *)__int16 v66 = 0u;
          int v64 = 0;
          break;
      }
      while (1)
      {
        long long v28 = parse_translator_entry(v28 + 1, 0x2Cu, v66, &v64, v19);
        int v47 = v66[0];
        __int16 v43 = (char *)v20;
        if (!v66[0]) {
          break;
        }
        int v48 = &v66[1];
        __int16 v43 = (char *)v20;
        while (v47 == *v43)
        {
          ++v43;
          int v49 = *v48++;
          int v47 = v49;
          if (!v49) {
            goto LABEL_148;
          }
        }
LABEL_151:
        if (*v28 != 44)
        {
          uint64_t v63 = 0;
          long long v61 = 0u;
          long long v62 = 0u;
          kdu_error::kdu_error((kdu_error *)&v61, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v61 + 16))(&v61, "Malformed attribute string");
          (*(void (**)(long long *, const char *))(v61 + 16))(&v61, ", \"");
          (*(void (**)(long long *, char *))(v61 + 16))(&v61, a2);
          (*(void (**)(long long *, const char *))(v61 + 16))(&v61, "\"!\n");
          (*(void (**)(long long *, const char *))(v61 + 16))(&v61, "Problem encountered at");
          (*(void (**)(long long *, const char *))(v61 + 16))(&v61, " \"");
          (*(void (**)(long long *, const char *))(v61 + 16))(&v61, v20);
          (*(void (**)(long long *, const char *))(v61 + 16))(&v61, "\".\n");
          display_options(*v29, (kdu_message *)&v61);
          kdu_error::~kdu_error((kdu_error *)&v61);
        }
      }
LABEL_148:
      int v50 = *v43;
      if (*v43 && v50 != 44 && v50 != 125) {
        goto LABEL_151;
      }
      if (!*(unsigned char *)(v26 + 24 * v25 + 16) || *(_DWORD *)v27 != v64) {
        char v59 = 1;
      }
      *(_DWORD *)uint64_t v27 = v64;
LABEL_162:
      *(unsigned char *)(v26 + 24 * v25++ + 16) = 1;
      uint64_t v24 = *((int *)v5 + 8);
      long long v20 = v43;
    }
    while (v25 < v24);
LABEL_165:
    int v51 = *v43;
    if (v51 == 125)
    {
      int v51 = *++v43;
    }
    else if (v56 == 123)
    {
      *(void *)&long long v68 = 0;
      *(_OWORD *)__int16 v66 = 0u;
      long long v67 = 0u;
      kdu_error::kdu_error((kdu_error *)v66, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Malformed attribute string");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, ", \"");
      (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, a2);
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\"!\n");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Problem encountered at");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, " \"");
      (*(void (**)(char *, char *))(*(void *)v66 + 16))(v66, v43);
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "\".\n");
      (*(void (**)(char *, const char *))(*(void *)v66 + 16))(v66, "Opening brace for record is not matched by a closing brace.");
      kdu_error::~kdu_error((kdu_error *)v66);
    }
    ++v22;
    int v21 = v51;
    long long v20 = v43;
  }
  while (v51);
  if ((v59 & 1) != 0 && !*((unsigned char *)this + 104))
  {
    *((unsigned char *)this + 104) = 1;
    uint64_t v52 = *((void *)this + 10);
    *(unsigned char *)(v52 + 104) = 1;
    uint64_t v53 = **(void **)(v52 + 64);
    *(unsigned char *)(v53 + 104) = 1;
    *(unsigned char *)(*(void *)(v53 + 48) + 104) = 1;
  }
LABEL_173:
  *((unsigned char *)this + 36) = 0;
  setlocale(4, v55);
  return 1;
}

void sub_18868CF88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18868CF94(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  _Unwind_Resume(v23);
}

uint64_t kdu_params::delete_unparsed_attribute(uint64_t this, const char *a2)
{
  uint64_t v2 = *(void *)(this + 96);
  if (!v2)
  {
LABEL_40:
    uint64_t v22 = 0;
    memset(v21, 0, sizeof(v21));
    kdu_error::kdu_error((kdu_error *)v21, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v21[0] + 16))(v21, "Attempting to delete a non-existent attribute with \"kdu_params::delete_unparsed_attribute\".");
    kdu_error::~kdu_error((kdu_error *)v21);
  }
  uint64_t v4 = this;
  uint64_t v5 = *(void *)(this + 96);
  while (*(const char **)v5 != a2)
  {
    uint64_t v5 = *(void *)(v5 + 56);
    if (!v5)
    {
      while (1)
      {
        this = strcmp(*(const char **)v2, a2);
        if (!this) {
          break;
        }
        uint64_t v2 = *(void *)(v2 + 56);
        if (!v2) {
          goto LABEL_40;
        }
      }
      uint64_t v5 = v2;
      break;
    }
  }
  if (!*(unsigned char *)(v5 + 49))
  {
    uint64_t v6 = (*(_DWORD *)(v5 + 32) * *(_DWORD *)(v5 + 36));
    if (v6)
    {
      if (!*(unsigned char *)(v4 + 104))
      {
        *(unsigned char *)(v4 + 104) = 1;
        uint64_t v7 = *(void *)(v4 + 80);
        *(unsigned char *)(v7 + 104) = 1;
        uint64_t v8 = **(void **)(v7 + 64);
        *(unsigned char *)(v8 + 104) = 1;
        *(unsigned char *)(*(void *)(v8 + 48) + 104) = 1;
      }
      if ((int)v6 >= 1)
      {
        uint64_t v9 = (unsigned char *)(*(void *)(v5 + 40) + 16);
        do
        {
          unsigned char *v9 = 0;
          v9 += 24;
          --v6;
        }
        while (v6);
      }
    }
    *(_DWORD *)(v5 + 36) = 0;
  }
  if (*(void *)(v4 + 80) == v4)
  {
    for (uint64_t i = *(kdu_params **)(v4 + 88); i; uint64_t i = (kdu_params *)*((void *)i + 11))
      this = kdu_params::delete_unparsed_attribute(i, a2);
    if ((*(_DWORD *)(v4 + 20) & 0x80000000) != 0)
    {
      int v11 = *(_DWORD *)(v4 + 16);
      int v12 = *(_DWORD *)(v4 + 32);
      if (v12 >= 1)
      {
        int v13 = v12 + 1;
        float v14 = (uint64_t *)(*(void *)(v4 + 64) + 8 * (v13 + v13 * v11) + 8);
        do
        {
          this = *v14;
          if (*v14) {
            BOOL v15 = this == v4;
          }
          else {
            BOOL v15 = 1;
          }
          if (!v15) {
            this = kdu_params::delete_unparsed_attribute((kdu_params *)this, a2);
          }
          ++v14;
          --v13;
        }
        while (v13 > 1);
        int v11 = *(_DWORD *)(v4 + 16);
      }
      if (v11 < 0)
      {
        int v16 = *(_DWORD *)(v4 + 28);
        if (v16 >= 1)
        {
          int v17 = *(_DWORD *)(v4 + 32);
          uint64_t v18 = (uint64_t *)(*(void *)(v4 + 64) + 8 * (v17 + 1));
          int v19 = v16 + 1;
          do
          {
            this = *v18;
            if (*v18) {
              BOOL v20 = this == v4;
            }
            else {
              BOOL v20 = 1;
            }
            if (!v20)
            {
              this = kdu_params::delete_unparsed_attribute((kdu_params *)this, a2);
              int v17 = *(_DWORD *)(v4 + 32);
            }
            v18 += v17 + 1;
            --v19;
          }
          while (v19 > 1);
        }
      }
    }
  }
  return this;
}

void sub_18868D318(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18868D324()
{
  _Unwind_Resume(v0);
}

uint64_t display_options(char *a1, kdu_message *a2)
{
  unsigned int v3 = a1;
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  *(_OWORD *)uint64_t v22 = 0u;
  memset(v21, 0, sizeof(v21));
  int v20 = 0;
  int v4 = *a1;
  if (v4 != 91)
  {
    if (v4 != 40) {
      display_options();
    }
    (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "Expected one of the identifiers, ");
    uint64_t v6 = 0;
    char v7 = 0;
    uint64_t v8 = (char *)v21;
    uint64_t v9 = v22;
    do
    {
      int v10 = v9;
      unsigned int v3 = parse_translator_entry(v3 + 1, 0x2Cu, v9, &v20, v5);
      if (v7) {
        (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, ", ");
      }
      if (v6)
      {
        (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "\"");
        (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v6);
        (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "\"");
        char v7 = 1;
      }
      int v11 = *v3;
      uint64_t v9 = v8;
      uint64_t v8 = v10;
      uint64_t v6 = v10;
    }
    while (v11 == 44);
    if (v11 != 41) {
      display_options();
    }
    int v12 = "\".";
    if ((v7 & 1) == 0) {
      goto LABEL_21;
    }
LABEL_20:
    (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, " or ");
    goto LABEL_21;
  }
  (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "Expected one or more of the identifiers, ");
  float v14 = 0;
  char v15 = 0;
  int v16 = (char *)v21;
  int v17 = v22;
  do
  {
    int v10 = v17;
    unsigned int v3 = parse_translator_entry(v3 + 1, 0x7Cu, v17, &v20, v13);
    if (v15) {
      (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, ", ");
    }
    if (v14)
    {
      (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "\"");
      (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v14);
      (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "\"");
      char v15 = 1;
    }
    int v18 = *v3;
    int v17 = v16;
    int v16 = v10;
    float v14 = v10;
  }
  while (v18 == 124);
  if (v18 != 93) {
    display_options();
  }
  if (v15) {
    goto LABEL_20;
  }
LABEL_21:
  (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "\"");
  (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v10);
  return (*(uint64_t (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, v12);
}

uint64_t kdu_params::textualize_attributes(uint64_t this, kdu_message *a2, char a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v21 = this;
  for (uint64_t i = *(void **)(this + 96); i; uint64_t i = (void *)i[7])
  {
    if (*((_DWORD *)i + 9) && (!*((unsigned char *)i + 48) || (a3 & 1) == 0))
    {
      (*(void (**)(kdu_message *, void))(*(void *)a2 + 16))(a2, *i);
      if ((*(_DWORD *)(v21 + 20) & 0x80000000) == 0
        || (*(_DWORD *)(v21 + 16) & 0x80000000) == 0
        || *(unsigned char *)(v21 + 42))
      {
        strcpy(v28, ":");
        (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v28);
        if ((*(_DWORD *)(v21 + 16) & 0x80000000) == 0)
        {
          (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "T");
          long long v31 = 0u;
          long long v32 = 0u;
          long long v29 = 0u;
          long long v30 = 0u;
          *(_OWORD *)long long v28 = 0u;
          if (*((unsigned char *)a2 + 8)) {
            sprintf(v28, "%x");
          }
          else {
            sprintf(v28, "%d");
          }
          (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v28);
        }
        if ((*(_DWORD *)(v21 + 20) & 0x80000000) == 0)
        {
          (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "C");
          long long v31 = 0u;
          long long v32 = 0u;
          long long v29 = 0u;
          long long v30 = 0u;
          *(_OWORD *)long long v28 = 0u;
          if (*((unsigned char *)a2 + 8)) {
            sprintf(v28, "%x");
          }
          else {
            sprintf(v28, "%d");
          }
          (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v28);
        }
        if (*(unsigned char *)(v21 + 42))
        {
          (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, "I");
          long long v31 = 0u;
          long long v32 = 0u;
          long long v29 = 0u;
          long long v30 = 0u;
          *(_OWORD *)long long v28 = 0u;
          if (*((unsigned char *)a2 + 8)) {
            sprintf(v28, "%x");
          }
          else {
            sprintf(v28, "%d");
          }
          (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v28);
        }
      }
      strcpy(v28, "=");
      (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v28);
      if (*((int *)i + 9) >= 1)
      {
        int v6 = 0;
        do
        {
          if (v6)
          {
            strcpy(v28, ",");
            (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v28);
          }
          LODWORD(v7) = *((_DWORD *)i + 8);
          if ((int)v7 > 1)
          {
            strcpy(v28, "{");
            (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v28);
            LODWORD(v7) = *((_DWORD *)i + 8);
          }
          if ((int)v7 >= 1)
          {
            uint64_t v8 = 0;
            while (2)
            {
              uint64_t v9 = i[5];
              if (v8)
              {
                strcpy(v28, ",");
                (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v28);
              }
              uint64_t v10 = v9 + 24 * (int)v7 * v6;
              if (!*(unsigned char *)(v10 + 24 * v8 + 16))
              {
                *(void *)&long long v25 = 0;
                *(_OWORD *)long long v23 = 0u;
                long long v24 = 0u;
                kdu_error::kdu_error((kdu_error *)v23, "Kakadu Core Error:\n");
                (*(void (**)(char *, const char *))(*(void *)v23 + 16))(v23, "Attempting to textualize a code-stream parameter attribute, which has only partially been set!\nError occurred in attribute");
                (*(void (**)(char *, const char *))(*(void *)v23 + 16))(v23, " \"");
                (*(void (**)(char *, void))(*(void *)v23 + 16))(v23, *i);
                (*(void (**)(char *, const char *))(*(void *)v23 + 16))(v23, "\" ");
                (*(void (**)(char *, const char *))(*(void *)v23 + 16))(v23, "in field ");
                long long v31 = 0u;
                long long v32 = 0u;
                long long v29 = 0u;
                long long v30 = 0u;
                *(_OWORD *)long long v28 = 0u;
                if (v23[8]) {
                  sprintf(v28, "%x");
                }
                else {
                  sprintf(v28, "%d");
                }
                (*(void (**)(char *, char *))(*(void *)v23 + 16))(v23, v28);
                (*(void (**)(char *, const char *))(*(void *)v23 + 16))(v23, " of record ");
                long long v31 = 0u;
                long long v32 = 0u;
                long long v29 = 0u;
                long long v30 = 0u;
                *(_OWORD *)long long v28 = 0u;
                if (v23[8]) {
                  sprintf(v28, "%x");
                }
                else {
                  sprintf(v28, "%d");
                }
                (*(void (**)(char *, char *))(*(void *)v23 + 16))(v23, v28);
                (*(void (**)(char *, const char *))(*(void *)v23 + 16))(v23, ".");
                kdu_error::~kdu_error((kdu_error *)v23);
              }
              int v11 = (unsigned int *)(v10 + 24 * v8);
              int v12 = (char *)*((void *)v11 + 1);
              int v13 = *v12;
              switch(*v12)
              {
                case 'B':
                  if (*v11) {
                    float v14 = "yes";
                  }
                  else {
                    float v14 = "no";
                  }
                  (*(void (**)(kdu_message *, const char *))(*(void *)a2 + 16))(a2, v14);
                  goto LABEL_73;
                case 'C':
                  (*(void (**)(uint64_t, kdu_message *, void, uint64_t, void))(*(void *)v21 + 64))(v21, a2, *i, v8, *v11);
                  goto LABEL_73;
                case 'D':
                case 'E':
                case 'G':
                case 'H':
                  goto LABEL_80;
                case 'F':
                  float v18 = *(float *)v11;
                  long long v31 = 0u;
                  long long v32 = 0u;
                  long long v29 = 0u;
                  long long v30 = 0u;
                  *(_OWORD *)long long v28 = 0u;
                  sprintf(v28, "%f", v18);
                  (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v28);
                  goto LABEL_73;
                case 'I':
                  long long v31 = 0u;
                  long long v32 = 0u;
                  long long v29 = 0u;
                  long long v30 = 0u;
                  *(_OWORD *)long long v28 = 0u;
                  if (*((unsigned char *)a2 + 8)) {
                    sprintf(v28, "%x");
                  }
                  else {
                    sprintf(v28, "%d");
                  }
                  goto LABEL_72;
                default:
                  if (v13 == 40)
                  {
                    long long v31 = 0u;
                    long long v32 = 0u;
                    long long v29 = 0u;
                    long long v30 = 0u;
                    *(_OWORD *)long long v28 = 0u;
                    *(_DWORD *)long long v23 = 0;
                    while (1)
                    {
                      int v19 = parse_translator_entry(v12 + 1, 0x2Cu, v28, v23, v5);
                      if (*(_DWORD *)v23 == *v11) {
                        break;
                      }
                      int v12 = v19;
                      if (*v19 != 44) {
                        kdu_params::textualize_attributes();
                      }
                    }
LABEL_72:
                    (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v28);
                  }
                  else
                  {
                    if (v13 != 91) {
LABEL_80:
                    }
                      kdu_params::textualize_attributes();
                    long long v26 = 0u;
                    long long v27 = 0u;
                    long long v24 = 0u;
                    long long v25 = 0u;
                    *(_OWORD *)long long v23 = 0u;
                    int v22 = 0;
                    if (!*v11)
                    {
                      long long v31 = 0uLL;
                      long long v32 = 0uLL;
                      long long v29 = 0uLL;
                      long long v30 = 0uLL;
                      *(_OWORD *)long long v28 = 0uLL;
                      if (*((unsigned char *)a2 + 8)) {
                        sprintf(v28, "%x");
                      }
                      else {
                        sprintf(v28, "%d");
                      }
                      (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v28);
                    }
                    int v15 = 0;
                    do
                    {
                      int v12 = parse_translator_entry(v12 + 1, 0x7Cu, v23, &v22, v5);
                      int v16 = v22 | v15;
                      if ((v22 & ~*v11) == 0 && v16 > v15)
                      {
                        (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v23);
                        if (v16 == *v11) {
                          goto LABEL_73;
                        }
                        strcpy(v28, ",");
                        (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v28);
                        int v15 = v16;
                      }
                    }
                    while (*v12 == 124);
                    if (v15 != *v11) {
                      kdu_params::textualize_attributes();
                    }
                  }
LABEL_73:
                  ++v8;
                  uint64_t v7 = *((int *)i + 8);
                  if (v8 < v7) {
                    continue;
                  }
                  if ((int)v7 >= 2)
                  {
                    strcpy(v28, "}");
                    (*(void (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v28);
                  }
                  break;
              }
              break;
            }
          }
          ++v6;
        }
        while (v6 < *((_DWORD *)i + 9));
      }
      strcpy(v28, "\n");
      this = (*(uint64_t (**)(kdu_message *, char *))(*(void *)a2 + 16))(a2, v28);
    }
  }
  return this;
}

void sub_18868E1D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18868E1E0()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_params::textualize_attributes(uint64_t this, kdu_message *a2, int a3, int a4, char a5)
{
  uint64_t v7 = this;
  if (a3 < 0) {
    int v8 = -1;
  }
  else {
    int v8 = a3;
  }
  int v9 = *(_DWORD *)(this + 28);
  if (v9 <= a4) {
    int v10 = v9 - 1;
  }
  else {
    int v10 = a4;
  }
  int v11 = *(_DWORD *)(this + 16);
  if (v11 < 0)
  {
    int v11 = v8;
  }
  else
  {
    BOOL v12 = v11 >= v8 && v11 <= v10;
    int v10 = *(_DWORD *)(this + 16);
    if (!v12) {
      return this;
    }
  }
  if (*(_DWORD *)(this + 24))
  {
    return kdu_params::textualize_attributes(this, a2, a5);
  }
  else
  {
    int v13 = *(_DWORD *)(this + 20);
    if (v13 < 0) {
      uint64_t v14 = 0xFFFFFFFFLL;
    }
    else {
      uint64_t v14 = v13;
    }
    if (v11 <= v10)
    {
      int v15 = *(_DWORD *)(this + 32);
      if (v13 >= 0) {
        int v16 = *(_DWORD *)(this + 20);
      }
      else {
        int v16 = v15 - 1;
      }
      uint64_t v17 = *(void *)(this + 64) + 8 * (v11 + 1 + (v11 + 1) * v15) + 8 * (v14 + 1);
      int v25 = v10;
      do
      {
        if ((int)v14 <= v16)
        {
          float v18 = (uint64_t *)v17;
          uint64_t v19 = v14;
          do
          {
            uint64_t v20 = *v18;
            if (*(_DWORD *)(*v18 + 20) == v14 && *(_DWORD *)(v20 + 16) == v11)
            {
              do
              {
                this = kdu_params::textualize_attributes(v20, a2, a5);
                uint64_t v20 = *(void *)(v20 + 88);
              }
              while (v20);
            }
            ++v18;
            BOOL v21 = v14 == v16;
            LODWORD(v14) = v14 + 1;
          }
          while (!v21);
          int v15 = *(_DWORD *)(v7 + 32);
          int v10 = v25;
          uint64_t v14 = v19;
        }
        v17 += 8 * (v15 + 1);
        BOOL v21 = v11++ == v10;
      }
      while (!v21);
    }
    if (*(void *)(v7 + 48) == v7)
    {
      for (uint64_t i = *(kdu_params **)(v7 + 56); i; uint64_t i = (kdu_params *)*((void *)i + 7))
        this = kdu_params::textualize_attributes(i, a2, a3, a4, a5);
    }
  }
  return this;
}

uint64_t kdu_params::translate_marker_segment(kdu_params *this, uint64_t a2, uint64_t a3, unsigned __int8 *a4, int a5, uint64_t a6)
{
  int v16 = -1;
  int v6 = *(kdu_params **)(**((void **)this + 8) + 48);
  if (!v6) {
    return 0;
  }
  while (*((_DWORD *)v6 + 7) <= a5
       || ((*(uint64_t (**)(kdu_params *, uint64_t, uint64_t, unsigned __int8 *, int *))(*(void *)v6 + 40))(v6, a2, a3, a4, &v16) & 1) == 0)
  {
    int v6 = (kdu_params *)*((void *)v6 + 7);
    if (!v6) {
      return 0;
    }
  }
  int v13 = v16;
  if (*((unsigned char *)v6 + 42))
  {
    int v14 = -1;
    int v16 = -1;
  }
  else
  {
    int v14 = v16;
    int v13 = 0;
  }
  uint64_t result = kdu_params::access_relation(v6, a5, v14, v13, 0);
  if (result)
  {
    int v15 = (unsigned char *)result;
    if (*(unsigned char *)(result + 40) && !*(unsigned char *)(result + 42))
    {
      uint64_t result = 0;
      while (v15[37])
      {
        int v15 = (unsigned char *)*((void *)v15 + 11);
        if (!v15) {
          return result;
        }
      }
    }
    uint64_t result = (*(uint64_t (**)(unsigned char *, uint64_t, uint64_t, unsigned __int8 *, uint64_t))(*(void *)v15 + 48))(v15, a2, a3, a4, a6);
    if (result)
    {
      v15[37] = 1;
      if (v15[40])
      {
        if (!v15[42]) {
          kdu_params::new_instance((kdu_params *)v15);
        }
      }
      v15[36] = 0;
      return 1;
    }
  }
  return result;
}

uint64_t kdu_params::generate_marker_segments(kdu_params *this, kdu_output *a2, int a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(**((void **)this + 8) + 48);
  if (v4)
  {
    uint64_t v8 = 0;
    int v23 = a3 + 1;
    while (1)
    {
      if (*(_DWORD *)(v4 + 28) > a3)
      {
        int v9 = *(_DWORD *)(v4 + 32);
        if ((v9 & 0x80000000) == 0) {
          break;
        }
      }
LABEL_43:
      uint64_t v4 = *(void *)(v4 + 56);
      if (!v4) {
        return v8;
      }
    }
    uint64_t v10 = v23 + v23 * v9;
    uint64_t v11 = *(void *)(*(void *)(v4 + 64) + 8 * v10);
    uint64_t v12 = -1;
    while (1)
    {
      uint64_t v13 = *(void *)(v4 + 64);
      uint64_t v14 = *(void *)(v13 + 8 * v10);
      if (*(_DWORD *)(v14 + 16) == a3 || *(_DWORD *)(v11 + 16) == a3 && *(unsigned char *)(v11 + 37))
      {
        int v15 = *(_DWORD *)(v14 + 20);
        if (v15 == v12)
        {
          if ((v12 & 0x8000000000000000) == 0) {
            goto LABEL_17;
          }
          goto LABEL_19;
        }
        if (*(unsigned char *)(v14 + 41))
        {
          if (v12 < 0 || v15 != -1) {
            kdu_params::generate_marker_segments();
          }
          uint64_t v16 = kdu_params::access_relation((kdu_params *)v14, a3, v12, 0, 0);
          uint64_t v13 = *(void *)(v4 + 64);
          if (v16 != *(void *)(v13 + 8 * v10) || (uint64_t v14 = v16, *(_DWORD *)(v16 + 20) != v12)) {
            kdu_params::generate_marker_segments();
          }
LABEL_17:
          if (*(_DWORD *)(v11 + 16) != a3 || (uint64_t v17 = v11, !*(unsigned char *)(v11 + 37)))
          {
LABEL_19:
            uint64_t v17 = *(void *)(v13 + 8 * v12 + 8);
            if (!*(unsigned char *)(v17 + 37))
            {
              if (*(unsigned char *)(v4 + 37)) {
                uint64_t v17 = v4;
              }
              else {
                uint64_t v17 = 0;
              }
            }
          }
          if (v17 == v14) {
            uint64_t v18 = 0;
          }
          else {
            uint64_t v18 = v17;
          }
          do
          {
            if (*(unsigned char *)(v14 + 42))
            {
              if ((*(_DWORD *)(v14 + 16) & 0x80000000) != 0) {
                goto LABEL_34;
              }
              int v19 = *(_DWORD *)(v14 + 24);
              uint64_t v18 = v4;
              while (1)
              {
                int v20 = *(_DWORD *)(v18 + 24);
                if (v20 >= v19) {
                  break;
                }
                uint64_t v18 = *(void *)(v18 + 88);
                if (!v18) {
                  goto LABEL_34;
                }
              }
              if (v20 != v19 || !*(unsigned char *)(v18 + 37)) {
LABEL_34:
              }
                uint64_t v18 = 0;
            }
            int v21 = (*(uint64_t (**)(uint64_t, kdu_output *, uint64_t, uint64_t))(*(void *)v14 + 32))(v14, a2, v18, a4);
            if (v21 < 1)
            {
              if (*(unsigned char *)(v14 + 37)) {
                uint64_t v18 = v14;
              }
              else {
                uint64_t v18 = 0;
              }
            }
            else
            {
              if (v21 <= 3) {
                kdu_params::generate_marker_segments();
              }
              uint64_t v8 = (v21 + v8);
              *(unsigned char *)(v14 + 37) = 1;
              uint64_t v18 = v14;
            }
            uint64_t v14 = *(void *)(v14 + 88);
          }
          while (v14);
        }
      }
      ++v12;
      ++v10;
      if (v12 >= *(int *)(v4 + 32)) {
        goto LABEL_43;
      }
    }
  }
  return 0;
}

kdu_params *kdu_params::finalize_all(kdu_params *this, BOOL a2)
{
  unsigned int v3 = this;
  uint64_t result = (kdu_params *)(*(uint64_t (**)(kdu_params *))(*(void *)this + 72))(this);
  if (*((kdu_params **)v3 + 10) == v3)
  {
    for (uint64_t i = (void *)*((void *)v3 + 11); i; uint64_t i = (void *)i[11])
      uint64_t result = (kdu_params *)(*(uint64_t (**)(void *, BOOL))(*i + 72))(i, a2);
  }
  if ((*((_DWORD *)v3 + 5) & 0x80000000) != 0)
  {
    int v6 = *((_DWORD *)v3 + 8);
    if (v6 >= 1)
    {
      int v7 = 0;
      do
      {
        int v8 = v7;
        int v9 = *((_DWORD *)v3 + 4);
        uint64_t result = *(kdu_params **)(*((void *)v3 + 8) + 8 * (++v7 + v6 + 1 + (v6 + 1) * v9));
        if (v8 == *((_DWORD *)result + 5) && *((_DWORD *)result + 4) == v9)
        {
          uint64_t result = (kdu_params *)kdu_params::finalize_all(result, a2);
          int v6 = *((_DWORD *)v3 + 8);
        }
      }
      while (v7 < v6);
    }
    if ((*((_DWORD *)v3 + 4) & 0x80000000) != 0)
    {
      int v10 = *((_DWORD *)v3 + 7);
      if (v10 >= 1)
      {
        int v11 = 0;
        do
        {
          int v12 = v11 + 1;
          uint64_t result = *(kdu_params **)(*((void *)v3 + 8) + 8 * (v12 + v12 * *((_DWORD *)v3 + 8)));
          if (v11 == *((_DWORD *)result + 4))
          {
            uint64_t result = (kdu_params *)kdu_params::finalize_all(result, a2);
            int v10 = *((_DWORD *)v3 + 7);
          }
          int v11 = v12;
        }
        while (v12 < v10);
      }
    }
    if (*((kdu_params **)v3 + 6) == v3)
    {
      while (1)
      {
        unsigned int v3 = (kdu_params *)*((void *)v3 + 7);
        if (!v3) {
          break;
        }
        uint64_t result = (kdu_params *)kdu_params::finalize_all(v3, a2);
      }
    }
  }
  return result;
}

kdu_params *kdu_params::finalize_all(kdu_params *this, int a2, BOOL a3)
{
  uint64_t v5 = this;
  int v6 = *((_DWORD *)this + 4);
  if (v6 == a2)
  {
    this = (kdu_params *)(*(uint64_t (**)(kdu_params *, BOOL))(*(void *)this + 72))(this, a3);
    if (*((kdu_params **)v5 + 10) == v5)
    {
      for (uint64_t i = (void *)*((void *)v5 + 11); i; uint64_t i = (void *)i[11])
        this = (kdu_params *)(*(uint64_t (**)(void *, BOOL))(*i + 72))(i, a3);
    }
    if ((*((_DWORD *)v5 + 5) & 0x80000000) != 0)
    {
      int v8 = *((_DWORD *)v5 + 8);
      if (v8 >= 1)
      {
        int v9 = 0;
        do
        {
          int v10 = v9;
          int v11 = *((_DWORD *)v5 + 4);
          this = *(kdu_params **)(*((void *)v5 + 8) + 8 * (++v9 + v8 + 1 + (v8 + 1) * v11));
          if (v10 == *((_DWORD *)this + 5) && *((_DWORD *)this + 4) == v11)
          {
            this = kdu_params::finalize_all(this, a3);
            int v8 = *((_DWORD *)v5 + 8);
          }
        }
        while (v9 < v8);
      }
    }
  }
  else if (v6 < 0 && (*((_DWORD *)this + 5) & 0x80000000) != 0 && *((_DWORD *)this + 7) > a2)
  {
    this = *(kdu_params **)(*((void *)this + 8) + 8 * (a2 + 1 + (a2 + 1) * *((_DWORD *)this + 8)));
    if (this)
    {
      if (*((_DWORD *)this + 4) == a2) {
        this = kdu_params::finalize_all(this, a3);
      }
    }
  }
  if (*((kdu_params **)v5 + 6) == v5)
  {
    while (1)
    {
      uint64_t v5 = (kdu_params *)*((void *)v5 + 7);
      if (!v5) {
        break;
      }
      this = (kdu_params *)kdu_params::finalize_all(v5, a2, a3);
    }
  }
  return this;
}

void kdu_params::define_attribute(kdu_params *this, const char *a2, const char *a3, const char *a4)
{
}

void sub_18868EB18(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x1070C40C5D0BD27);
  _Unwind_Resume(a1);
}

void siz_params::siz_params(siz_params *this)
{
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18898D540;
  *(_DWORD *)((char *)this + 38) = 0;
  *((unsigned char *)this + 42) = 0;
  *((void *)this + 6) = this;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 9) = this;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = this;
  *((_WORD *)this + 18) = 1;
  *((unsigned char *)this + 104) = 0;
  *((void *)this + 14) = 0;
  *(void *)this = &unk_1ED4DECB8;
  *((void *)this + 1) = "SIZ";
    "dded later via an ammendment to Part 1.  They are in fact highly restrictive subsets of the Part 1 standard, taylore"
    "d for the needs of digital cinema projection equipment.  These profiles are not currently checked for conformance, a"
    "lthough that may well change in a future release.  If you don't know what you are doing, therefore, you should not l"
    "abel a codestream which you compress yourself as having either of these profiles.\n"
    "\t\t[Defaults to Profile-2.]",
    "(PROFILE0=0,PROFILE1=1,PROFILE2=2,PART2=3,CINEMA2K=4,CINEMA4K=5)");
}

void sub_18868EDD8(_Unwind_Exception *a1)
{
  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t siz_params::copy_with_xforms(siz_params *this, kdu_params *a2, int a3, int a4, uint64_t a5, int a6, int a7)
{
  BOOL v90 = 0;
  *(void *)uint64_t v89 = 0;
  *(void *)int v88 = 0;
  *(void *)unint64_t v87 = 0;
  int v86 = 0;
  *(void *)unint64_t v85 = 0;
  int v84 = 0;
  if (!kdu_params::get(a2, "Sprofile", 0, 0, &v89[1], 1, 1, 1)
    || !kdu_params::get(a2, "Scap", 0, 0, &v90, 1, 1, 1)
    || !kdu_params::get(a2, "Sextensions", 0, 0, v89, 1, 1, 1)
    || !kdu_params::get(a2, "Ssize", 0, a5, v88, 1, 1, 1)
    || !kdu_params::get(a2, "Ssize", 0, a5 ^ 1, &v88[1], 1, 1, 1)
    || !kdu_params::get(a2, "Sorigin", 0, a5, v87, 1, 1, 1)
    || !kdu_params::get(a2, "Sorigin", 0, a5 ^ 1, &v87[1], 1, 1, 1)
    || !kdu_params::get(a2, "Stiles", 0, a5, &v86, 1, 1, 1)
    || !kdu_params::get(a2, "Stiles", 0, a5 ^ 1, &v85[1], 1, 1, 1)
    || !kdu_params::get(a2, "Stile_origin", 0, a5, v85, 1, 1, 1)
    || (kdu_params::get(a2, "Stile_origin", 0, a5 ^ 1, &v84, 1, 1, 1) & 1) == 0)
  {
    uint64_t v83 = 0;
    long long v81 = 0u;
    long long v82 = 0u;
    kdu_error::kdu_error((kdu_error *)&v81, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v81);
  }
  if (a6 & 1) != 0 || (a7)
  {
    uint64_t v14 = 3;
    v89[1] = 3;
  }
  else
  {
    uint64_t v14 = v89[1];
  }
  kdu_params::set(this, "Sprofile", 0, 0, (int *)v14);
  kdu_params::set((uint64_t)this, "Scap", 0, 0, v90);
  kdu_params::set(this, "Sextensions", 0, 0, (int *)v89[0]);
  int v80 = 0;
  if (kdu_params::get(a2, "Scomponents", 0, 0, &v80, 1, 1, 1))
  {
    if (v80 <= a3)
    {
      uint64_t v83 = 0;
      long long v81 = 0u;
      long long v82 = 0u;
      kdu_error::kdu_error((kdu_error *)&v81, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v81 + 16))(&v81, "Attempting to discard all of the components from an existing code-stream!");
      kdu_error::~kdu_error((kdu_error *)&v81);
    }
    kdu_params::set(this, "Scomponents", 0, 0, (int *)(v80 - a3));
  }
  int v79 = 0;
  if (kdu_params::get(a2, "Mcomponents", 0, 0, &v79, 1, 1, 1)) {
    kdu_params::set(this, "Mcomponents", 0, 0, (int *)v79);
  }
  int v78 = 0;
  int v72 = a3;
  float32x4_t v73 = this;
  if (a4 <= 0)
  {
    uint64_t v27 = 0;
    int v26 = 0;
    float32x4_t v74 = 0;
    int v29 = v88[0];
    int v28 = v88[1];
    int v31 = v87[0];
    int v30 = v87[1];
    int v32 = v85[1];
    int v33 = v86;
    int v34 = v84;
    int v35 = v85[0];
    goto LABEL_61;
  }
  if ((v89[0] & 0x20) != 0 && (float32x4_t v74 = (kdu_params *)kdu_params::access_cluster(a2, "COD")) != 0)
  {
    if (v80 > a3)
    {
      int v68 = a7;
      int v15 = a3;
      int v16 = a4;
      int v70 = a4;
      do
      {
        uint64_t v17 = (kdu_params *)kdu_params::access_relation(v74, -1, v15, 0, 0);
        if (v17)
        {
          uint64_t v18 = v17;
          if (kdu_params::get(v17, "Cdecomp", 0, 0, &v78, 1, 1, 1))
          {
            uint64_t v19 = a5;
            int v20 = 0;
            int v21 = 0;
            int v22 = 0;
            do
            {
              kdu_params::get(v18, "Cdecomp", v20, 0, &v78, 1, 1, 1);
              v22 += v78 & 1;
              v21 += (v78 >> 1) & 1;
              ++v20;
            }
            while (a4 != v20);
            int v23 = v70;
            if (v22 < v70) {
              int v23 = v22;
            }
            int v70 = v23;
            if (v21 < v16) {
              int v16 = v21;
            }
            a5 = v19;
          }
        }
        ++v15;
      }
      while (v15 < v80);
      a7 = v68;
      unsigned int v24 = v70;
      goto LABEL_41;
    }
  }
  else
  {
    float32x4_t v74 = 0;
  }
  unsigned int v24 = a4;
  int v16 = a4;
LABEL_41:
  if (a5) {
    uint64_t v25 = v16;
  }
  else {
    uint64_t v25 = v24;
  }
  if (a5) {
    int v26 = v24;
  }
  else {
    int v26 = v16;
  }
  uint64_t v27 = v25;
  int v29 = v88[0];
  int v28 = v88[1];
  int v31 = v87[0];
  int v30 = v87[1];
  int v32 = v85[1];
  int v33 = v86;
  int v34 = v84;
  int v35 = v85[0];
  if ((int)v27 < 1)
  {
    this = v73;
    a3 = v72;
  }
  else
  {
    uint64_t v36 = 0;
    int v37 = v87[1] | v88[1] | v85[1] | v84;
    this = v73;
    a3 = v72;
    while ((v37 & 1) == 0)
    {
      uint64_t v36 = (v36 + 1);
      v37 >>= 1;
      if (v27 == v36) {
        goto LABEL_55;
      }
    }
    uint64_t v27 = v36;
  }
LABEL_55:
  if (v26 >= 1)
  {
    int v38 = 0;
    int v39 = v87[0] | v88[0] | v86 | v85[0];
    while ((v39 & 1) == 0)
    {
      ++v38;
      v39 >>= 1;
      if (v26 == v38) {
        goto LABEL_61;
      }
    }
    int v26 = v38;
  }
LABEL_61:
  int v40 = v28 >> v27;
  unint64_t v41 = (v29 >> v26);
  v88[0] = v29 >> v26;
  v88[1] = v28 >> v27;
  int v42 = v30 >> v27;
  int v43 = v31 >> v26;
  v87[0] = v31 >> v26;
  v87[1] = v42;
  int v44 = v32 >> v27;
  int v45 = v33 >> v26;
  v85[1] = v32 >> v27;
  int v86 = v33 >> v26;
  int v84 = v34 >> v27;
  v85[0] = v35 >> v26;
  if (a7)
  {
    v88[1] = 1 - v42;
    v87[1] = 1 - v40;
    int v46 = v44 - (v34 >> v27) + 1;
    do
      v46 -= v44;
    while (v46 > 1 - v40);
    int v84 = v46;
  }
  if (a6)
  {
    int v47 = 1 - v41;
    unint64_t v41 = (1 - v43);
    v88[0] = 1 - v43;
    v87[0] = v47;
    int v48 = v45 - (v35 >> v26) + 1;
    do
      v48 -= v45;
    while (v48 > v47);
    v85[0] = v48;
  }
  int v71 = v26;
  kdu_params::set(this, "Ssize", 0, 0, (int *)v41);
  kdu_params::set(this, "Ssize", 0, 1, (int *)v88[1]);
  kdu_params::set(this, "Sorigin", 0, 0, (int *)v87[0]);
  kdu_params::set(this, "Sorigin", 0, 1, (int *)v87[1]);
  kdu_params::set(this, "Stiles", 0, 0, (int *)v86);
  kdu_params::set(this, "Stiles", 0, 1, (int *)v85[1]);
  kdu_params::set(this, "Stile_origin", 0, 0, (int *)v85[0]);
  uint64_t result = (uint64_t)kdu_params::set(this, "Stile_origin", 0, 1, (int *)v84);
  BOOL v77 = 0;
  *(void *)int v76 = 0;
  int v75 = 0;
  if (v80 > a3)
  {
    int v50 = a5 ^ 1;
    int v51 = a3;
    int v69 = a5 ^ 1;
    do
    {
      if (kdu_params::get(a2, "Sprecision", v51, 0, &v76[1], 1, 1, 1)) {
        kdu_params::set(this, "Sprecision", v51 - a3, 0, (int *)v76[1]);
      }
      if (kdu_params::get(a2, "Ssigned", v51, 0, &v77, 1, 1, 1)) {
        kdu_params::set((uint64_t)this, "Ssigned", v51 - a3, 0, v77);
      }
      uint64_t result = kdu_params::get(a2, "Ssampling", v51, a5, &v75, 1, 1, 1);
      if (result)
      {
        uint64_t result = kdu_params::get(a2, "Ssampling", v51, v50, v76, 1, 1, 1);
        if (result)
        {
          uint64_t v52 = v27;
          uint64_t v53 = a5;
          int v54 = a4;
          int v55 = a4;
          if (v74)
          {
            int v56 = (kdu_params *)kdu_params::access_relation(v74, -1, v51, 0, 0);
            int v54 = a4;
            int v55 = a4;
            if (v56)
            {
              float v57 = v56;
              int v58 = kdu_params::get(v56, "Cdecomp", 0, 0, &v78, 1, 1, 1);
              int v54 = v58 ? 0 : a4;
              int v55 = v54;
              if (a4 >= 1)
              {
                if (v58)
                {
                  int v59 = 0;
                  int v55 = 0;
                  int v54 = 0;
                  do
                  {
                    kdu_params::get(v57, "Cdecomp", v59, 0, &v78, 1, 1, 1);
                    v54 += v78 & 1;
                    v55 += (v78 >> 1) & 1;
                    ++v59;
                  }
                  while (a4 != v59);
                }
              }
            }
          }
          if (v53) {
            int v60 = v55;
          }
          else {
            int v60 = v54;
          }
          if (v53) {
            int v61 = v54;
          }
          else {
            int v61 = v55;
          }
          int v62 = v60 - v52;
          if (v62 < 0 || (int v63 = v61 - v71, v63 < 0)) {
            siz_params::copy_with_xforms();
          }
          a5 = v53;
          uint64_t v27 = v52;
          int v64 = (int *)(v75 << v63);
          v75 <<= v63;
          v76[0] <<= v62;
          this = v73;
          a3 = v72;
          if (v76[0] > 255 || (int)v64 >= 256)
          {
            uint64_t v83 = 0;
            long long v81 = 0u;
            long long v82 = 0u;
            kdu_error::kdu_error((kdu_error *)&v81, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v81 + 16))(&v81, "Cannot apply requested resolution reduction without creating a SIZ marker segment with illegal component sub-sampling factors.  For the current code-stream, sub-sampling factors would be required which exceed the legal range of 1 to 255.");
            kdu_error::~kdu_error((kdu_error *)&v81);
          }
          kdu_params::set(v73, "Ssampling", v51 - v72, 0, v64);
          uint64_t result = (uint64_t)kdu_params::set(v73, "Ssampling", v51 - v72, 1, (int *)v76[0]);
          int v50 = v69;
        }
      }
      ++v51;
    }
    while (v51 < v80);
  }
  if (v79 >= 1)
  {
    int v65 = 0;
    while (1)
    {
      uint64_t result = kdu_params::get(a2, "Mprecision", v65, 0, &v76[1], 0, 0, 1);
      if ((result & 1) == 0) {
        break;
      }
      uint64_t result = (uint64_t)kdu_params::set(this, "Mprecision", v65++, 0, (int *)v76[1]);
      int v66 = v79;
      if (v65 >= v79) {
        goto LABEL_105;
      }
    }
    int v66 = v79;
LABEL_105:
    if (v66 >= 1)
    {
      int v67 = 0;
      do
      {
        uint64_t result = kdu_params::get(a2, "Msigned", v67, 0, &v77, 0, 0, 1);
        if (!result) {
          break;
        }
        uint64_t result = kdu_params::set((uint64_t)this, "Msigned", v67++, 0, v77);
      }
      while (v67 < v79);
    }
  }
  return result;
}

void sub_18868F934(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18868F940(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(v17);
}

uint64_t siz_params::write_marker_segment(siz_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  if (a3) {
    siz_params::write_marker_segment();
  }
  if (a4)
  {
    LODWORD(v61) = 0;
  }
  else
  {
    BOOL v79 = 0;
    int v78 = 0;
    *(void *)int v76 = 0;
    *(void *)BOOL v77 = 0;
    *(void *)float32x4_t v74 = 0;
    *(void *)int v75 = 0;
    *(void *)float32x4_t v73 = 0;
    if (!kdu_params::get(this, "Sprofile", 0, 0, &v78, 1, 1, 1)
      || !kdu_params::get(this, "Scap", 0, 0, &v79, 1, 1, 1)
      || !kdu_params::get(this, "Sextensions", 0, 0, (int *)&v77[1], 1, 1, 1)
      || !kdu_params::get(this, "Ssize", 0, 0, (int *)&v76[1], 1, 1, 1)
      || !kdu_params::get(this, "Ssize", 0, 1, (int *)v77, 1, 1, 1)
      || !kdu_params::get(this, "Sorigin", 0, 0, (int *)&v75[1], 1, 1, 1)
      || !kdu_params::get(this, "Sorigin", 0, 1, (int *)v76, 1, 1, 1)
      || !kdu_params::get(this, "Stiles", 0, 0, (int *)&v74[1], 1, 1, 1)
      || !kdu_params::get(this, "Stiles", 0, 1, (int *)v75, 1, 1, 1)
      || !kdu_params::get(this, "Stile_origin", 0, 0, (int *)&v73[1], 1, 1, 1)
      || !kdu_params::get(this, "Stile_origin", 0, 1, (int *)v74, 1, 1, 1)
      || (kdu_params::get(this, "Scomponents", 0, 0, (int *)v73, 1, 1, 1) & 1) == 0)
    {
      *(void *)&long long v82 = 0;
      *(_OWORD *)int v80 = 0u;
      long long v81 = 0u;
      kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v80 + 16))(v80, "Unable to write SIZ marker segment yet!");
      kdu_error::~kdu_error((kdu_error *)v80);
    }
    unsigned int v5 = v73[0];
    if (v73[0] - 16385 <= 0xFFFFBFFF)
    {
      *(void *)&long long v82 = 0;
      *(_OWORD *)int v80 = 0u;
      long long v81 = 0u;
      kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v80 + 16))(v80, "Illegal number of image components! Must be in the range 1 to 16384.");
      kdu_error::~kdu_error((kdu_error *)v80);
    }
    int v72 = 0;
    int v6 = kdu_params::get(this, "Mcomponents", 0, 0, &v72, 1, 1, 1);
    if (v72) {
      int v7 = v6;
    }
    else {
      int v7 = 0;
    }
    if (v7 == 1)
    {
      if ((v72 - 16385) <= 0xFFFFBFFF)
      {
        *(void *)&long long v82 = 0;
        *(_OWORD *)int v80 = 0u;
        long long v81 = 0u;
        kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
        kdu_error::~kdu_error((kdu_error *)v80);
      }
      int v59 = v72 + 6;
    }
    else
    {
      int v59 = 0;
    }
    __int16 v58 = 3 * v5;
    if (a2)
    {
      LODWORD(v61) = 3 * v5 + 40;
      int v8 = v73[1];
      int v9 = v74[0];
      if ((v74[0] & 0x80000000) != 0 || (v73[1] & 0x80000000) != 0)
      {
        int v11 = v74[1];
        int v12 = v75[0];
        unsigned int v13 = v77[0];
        lcuint64_t m = v75[0];
        if ((signed int)(v75[0] + v74[0]) >= (int)v77[0])
        {
          int v9 = v76[0];
          v74[0] = v76[0];
          lcuint64_t m = 1;
        }
        unsigned int v15 = v76[1];
        int v16 = v74[1];
        if ((signed int)(v74[1] + v73[1]) >= (int)v76[1])
        {
          v73[1] = v75[1];
          int v16 = 1;
        }
        uint64_t v17 = (kdu_params *)kdu_params::access_cluster(this, "COD");
        int v18 = v13 - v76[0];
        if (v12 <= 1) {
          unsigned int v19 = 1;
        }
        else {
          unsigned int v19 = v12;
        }
        if (v18 <= 0) {
          unsigned int v20 = -(int)((v76[0] - v13) / v19);
        }
        else {
          unsigned int v20 = (v18 - 1) / v19 + 1;
        }
        signed int v21 = v15 - v75[1];
        if (v11 <= 1) {
          unsigned int v22 = 1;
        }
        else {
          unsigned int v22 = v11;
        }
        BOOL v34 = v21 <= 0;
        unsigned int v23 = (v21 - 1) / v22;
        if (v34) {
          int v24 = -(int)((v75[1] - v15) / v22);
        }
        else {
          int v24 = v23 + 1;
        }
        int v60 = v24 * v20;
        if (((v24 * v20) & 0x80000000) == 0)
        {
          int v63 = -1;
          int v25 = v73[0];
          do
          {
            if (v25 >= 1)
            {
              int v26 = 0;
              do
              {
                v65[0] = 1;
                int v71 = 1;
                kdu_params::get(this, "Ssampling", v26, 0, &v71, 1, 1, 1);
                kdu_params::get(this, "Ssampling", v26, 1, v65, 1, 1, 1);
                int v70 = 0;
                BOOL v69 = 0;
                if (!v17
                  || (v27 = (kdu_params *)kdu_params::access_relation(v17, v63, v26, 0, 1), (uint64_t v17 = v27) == 0)
                  || !kdu_params::get(v27, "Clevels", 0, 0, &v70, 1, 1, 1)
                  || (kdu_params::get(v17, "Cuse_precincts", 0, 0, &v69, 1, 1, 1) & 1) == 0)
                {
                  *(void *)&long long v82 = 0;
                  *(_OWORD *)int v80 = 0u;
                  long long v81 = 0u;
                  kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
                  (*(void (**)(char *, const char *))(*(void *)v80 + 16))(v80, "Attempting to write geometrically transformed SIZ marker information without attaching and finalizing all tile-component COD marker information.  This is essential to establish canvas coordinate equivalence relationships.");
                  kdu_error::~kdu_error((kdu_error *)v80);
                }
                int v28 = v70;
                if ((v70 & 0x80000000) == 0)
                {
                  int v29 = -v70;
                  do
                  {
                    unsigned __int8 v30 = 15;
                    *(_DWORD *)int v68 = 15;
                    *(_DWORD *)&v68[4] = 15;
                    if (v69)
                    {
                      kdu_params::get(v17, "Cprecincts", v29 + v70, 0, (int *)v68, 1, 1, 1);
                      kdu_params::get(v17, "Cprecincts", v29 + v70, 1, (int *)&v68[4], 1, 1, 1);
                      unsigned __int8 v30 = v68[0];
                      unsigned __int8 v31 = v68[4];
                    }
                    else
                    {
                      unsigned __int8 v31 = 15;
                    }
                    uint64_t v32 = (v65[0] << (v31 + v28));
                    uint64_t v33 = (v71 << (v30 + v28));
                    BOOL v34 = (int)v32 < 1 || (int)v33 <= 0;
                    if (v34)
                    {
                      *(void *)&long long v82 = 0;
                      *(_OWORD *)int v80 = 0u;
                      long long v81 = 0u;
                      kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
                      (*(void (**)(char *, const char *))(*(void *)v80 + 16))(v80, "Error attempting to convert geometrically transformed canvas coordinates to legal marker ranges.  Try using a smaller precinct size (you can use the transcoding utility to achieve this at the same time as geometric transformations.");
                      kdu_error::~kdu_error((kdu_error *)v80);
                    }
                    lcuint64_t m = find_lcm(lcm, v32);
                    int v35 = find_lcm(v16, v33);
                    int v16 = v35;
                    ++v29;
                    BOOL v34 = v28-- <= 0;
                  }
                  while (!v34);
                }
                ++v26;
                int v25 = v73[0];
              }
              while (v26 < (int)v73[0]);
            }
            ++v63;
          }
          while (v63 != v60);
          int v9 = v74[0];
        }
        if (v9 < 0)
        {
          if (lcm <= 1) {
            unsigned int v37 = 1;
          }
          else {
            unsigned int v37 = lcm;
          }
          unsigned int v36 = lcm + lcm * (~v9 / v37);
        }
        else
        {
          unsigned int v36 = 0;
        }
        if ((v73[1] & 0x80000000) != 0)
        {
          if (v16 <= 1) {
            unsigned int v39 = 1;
          }
          else {
            unsigned int v39 = v16;
          }
          unsigned int v38 = v16 + v16 * (~v73[1] / v39);
        }
        else
        {
          unsigned int v38 = 0;
        }
        v77[0] += v36;
        v76[1] += v38;
        v75[1] += v38;
        int v10 = v76[0] + v36;
        v76[0] += v36;
        int v8 = v38 + v73[1];
        v9 += v36;
        v73[1] += v38;
        v74[0] = v9;
        if (v9 < 0 || v8 < 0) {
          siz_params::write_marker_segment();
        }
      }
      else
      {
        int v10 = v76[0];
      }
      if (v10 < v9
        || (int)v75[1] < v8
        || v10 >= (signed int)(v75[0] + v9)
        || (int)v75[1] >= (signed int)(v74[1] + v8)
        || (int)v77[0] <= v10
        || (int)v76[1] <= (int)v75[1])
      {
        *(void *)&long long v82 = 0;
        *(_OWORD *)int v80 = 0u;
        long long v81 = 0u;
        kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v80 + 16))(v80, "Cannot write SIZ marker with illegal canvas coordinates.  The first tile is required to have a non-empty intersection with the image region on the canvas.");
        kdu_error::~kdu_error((kdu_error *)v80);
      }
      kdu_output::put(a2, 255);
      kdu_output::put(a2, 81);
      kdu_output::put(a2, (unsigned __int16)(v58 + 38) >> 8);
      kdu_output::put(a2, v58 + 38);
      if (v78 == 3)
      {
        __int16 v40 = LOWORD(v77[1]) | 0x8000;
      }
      else
      {
        if (v78 > 5 || v77[1])
        {
          *(void *)&long long v82 = 0;
          *(_OWORD *)int v80 = 0u;
          long long v81 = 0u;
          kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(void *)v80 + 16))(v80, "Illegal profile index.  \"Sprofile\" must be set in the range 0 to 5; 3 is required if Part 2 features are to be used.");
          kdu_error::~kdu_error((kdu_error *)v80);
        }
        if (v78 == 2)
        {
          __int16 v40 = 0;
        }
        else if (v78 < 4)
        {
          __int16 v40 = v78 + 1;
        }
        else
        {
          __int16 v40 = v78 - 1;
        }
      }
      if (v79) {
        __int16 v41 = v40 | 0x4000;
      }
      else {
        __int16 v41 = v40;
      }
      kdu_output::put(a2, SHIBYTE(v41));
      kdu_output::put(a2, v41);
      int v42 = kdu_output::put(a2, v77[0]);
      int v43 = kdu_output::put(a2, v76[1]);
      int v44 = kdu_output::put(a2, v76[0]);
      int v45 = kdu_output::put(a2, v75[1]);
      int v46 = kdu_output::put(a2, v75[0]);
      int v47 = kdu_output::put(a2, v74[1]);
      int v48 = kdu_output::put(a2, v74[0]);
      int v49 = kdu_output::put(a2, v73[1]);
      char v50 = v73[0];
      kdu_output::put(a2, SBYTE1(v73[0]));
      kdu_output::put(a2, v50);
      int v51 = v42 + v43 + v44 + v45 + v46 + v47 + v48 + v49 + 8;
      int v70 = 0;
      int v71 = 0;
      *(void *)int v68 = 0;
      if ((int)v73[0] >= 1)
      {
        int v52 = 0;
        do
        {
          if (!kdu_params::get(this, "Ssigned", v52, 0, &v71, 1, 1, 1)
            || !kdu_params::get(this, "Sprecision", v52, 0, &v70, 1, 1, 1)
            || !kdu_params::get(this, "Ssampling", v52, 0, (int *)v68, 1, 1, 1)
            || (kdu_params::get(this, "Ssampling", v52, 1, (int *)&v68[4], 1, 1, 1) & 1) == 0)
          {
            *(void *)&long long v82 = 0;
            *(_OWORD *)int v80 = 0u;
            long long v81 = 0u;
            kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(void *)v80 + 16))(v80, "Unable to write SIZ marker segment! Precision or sub-sampling information missing for at least one component.");
            kdu_error::~kdu_error((kdu_error *)v80);
          }
          if ((v70 - 39) <= 0xFFFFFFD9)
          {
            uint64_t v67 = 0;
            *(_OWORD *)int v65 = 0u;
            long long v66 = 0u;
            kdu_error::kdu_error((kdu_error *)v65, "Kakadu Core Error:\n");
            (*(void (**)(int *, const char *))(*(void *)v65 + 16))(v65, "Illegal image sample bit-depth, ");
            long long v83 = 0u;
            long long v84 = 0u;
            long long v81 = 0u;
            long long v82 = 0u;
            *(_OWORD *)int v80 = 0u;
            if (LOBYTE(v65[2])) {
              sprintf(v80, "%x");
            }
            else {
              sprintf(v80, "%d");
            }
            (*(void (**)(int *, char *))(*(void *)v65 + 16))(v65, v80);
            (*(void (**)(int *, const char *))(*(void *)v65 + 16))(v65, ". Legal range is from 1 to 38 bits per sample.");
            kdu_error::~kdu_error((kdu_error *)v65);
          }
          if ((*(_DWORD *)&v68[4] - 256) < 0xFFFFFF01 || *(int *)v68 < 1 || *(int *)v68 >= 256)
          {
            uint64_t v67 = 0;
            *(_OWORD *)int v65 = 0u;
            long long v66 = 0u;
            kdu_error::kdu_error((kdu_error *)v65, "Kakadu Core Error:\n");
            (*(void (**)(int *, const char *))(*(void *)v65 + 16))(v65, "Illegal component sub-sampling factors, {");
            long long v83 = 0u;
            long long v84 = 0u;
            long long v81 = 0u;
            long long v82 = 0u;
            *(_OWORD *)int v80 = 0u;
            if (LOBYTE(v65[2])) {
              sprintf(v80, "%x");
            }
            else {
              sprintf(v80, "%d");
            }
            (*(void (**)(int *, char *))(*(void *)v65 + 16))(v65, v80);
            (*(void (**)(int *, const char *))(*(void *)v65 + 16))(v65, ",");
            long long v83 = 0u;
            long long v84 = 0u;
            long long v81 = 0u;
            long long v82 = 0u;
            *(_OWORD *)int v80 = 0u;
            if (LOBYTE(v65[2])) {
              sprintf(v80, "%x");
            }
            else {
              sprintf(v80, "%d");
            }
            (*(void (**)(int *, char *))(*(void *)v65 + 16))(v65, v80);
            (*(void (**)(int *, const char *))(*(void *)v65 + 16))(v65, "}. Legal range is from 1 to 255.");
            kdu_error::~kdu_error((kdu_error *)v65);
          }
          int v53 = kdu_output::put(a2, v70 + ((_BYTE)v71 << 7) - 1);
          int v54 = kdu_output::put(a2, v68[4]);
          v51 += v53 + v54 + kdu_output::put(a2, v68[0]);
          ++v52;
        }
        while (v52 < (int)v73[0]);
      }
      if (v51 != v61) {
        siz_params::write_marker_segment();
      }
      if (v59)
      {
        kdu_output::put(a2, 255);
        kdu_output::put(a2, 120);
        kdu_output::put(a2, (unsigned __int16)(v59 - 2) >> 8);
        kdu_output::put(a2, v59 - 2);
        char v55 = v72;
        kdu_output::put(a2, SBYTE1(v72));
        kdu_output::put(a2, v55);
        if (v72 < 1)
        {
          int v57 = 6;
        }
        else
        {
          int v56 = 0;
          int v57 = 6;
          do
          {
            if (!kdu_params::get(this, "Msigned", v56, 0, &v71, 1, 1, 1)
              || (kdu_params::get(this, "Mprecision", v56, 0, &v70, 1, 1, 1) & 1) == 0)
            {
              *(void *)&long long v82 = 0;
              *(_OWORD *)int v80 = 0u;
              long long v81 = 0u;
              kdu_error::kdu_error((kdu_error *)v80, "Kakadu Core Error:\n");
              (*(void (**)(char *, const char *))(*(void *)v80 + 16))(v80, "Unable to write CBD marker segment! Precision or signed/unsigned information missing for at least one MCT output component.");
              kdu_error::~kdu_error((kdu_error *)v80);
            }
            if ((v70 - 39) <= 0xFFFFFFD9)
            {
              uint64_t v67 = 0;
              *(_OWORD *)int v65 = 0u;
              long long v66 = 0u;
              kdu_error::kdu_error((kdu_error *)v65, "Kakadu Core Error:\n");
              (*(void (**)(int *, const char *))(*(void *)v65 + 16))(v65, "Illegal precision for MCT output component, ");
              long long v83 = 0u;
              long long v84 = 0u;
              long long v81 = 0u;
              long long v82 = 0u;
              *(_OWORD *)int v80 = 0u;
              if (LOBYTE(v65[2])) {
                sprintf(v80, "%x");
              }
              else {
                sprintf(v80, "%d");
              }
              (*(void (**)(int *, char *))(*(void *)v65 + 16))(v65, v80);
              (*(void (**)(int *, const char *))(*(void *)v65 + 16))(v65, ". Legal range is from 1 to 38 bits per sample.");
              kdu_error::~kdu_error((kdu_error *)v65);
            }
            v57 += kdu_output::put(a2, v70 + ((_BYTE)v71 << 7) - 1);
            ++v56;
          }
          while (v56 < v72);
        }
        if (v57 != v59) {
          siz_params::write_marker_segment();
        }
        LODWORD(v61) = v59 + v61;
      }
    }
    else
    {
      return v59 + 3 * v5 + 40;
    }
  }
  return v61;
}

void sub_188690AC4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void sub_188690AD0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Unwind_Resume(v29);
}

uint64_t find_lcm(int a1, uint64_t a2)
{
  if (a1 < 1 || (int)a2 < 1) {
    find_lcm();
  }
  int v2 = 1;
  if (a1 >= 2 && a2 >= 2)
  {
    int v3 = 2;
    do
    {
      if (!(a1 % v3))
      {
        uint64_t v4 = a2;
        while (1)
        {
          a2 = ((int)v4 / v3);
          if ((int)v4 % v3) {
            break;
          }
          v2 *= v3;
          a1 /= v3;
          uint64_t v4 = ((int)v4 / v3);
          if (a1 % v3) {
            goto LABEL_12;
          }
        }
        a2 = v4;
      }
LABEL_12:
      if (v3 >= a1) {
        break;
      }
    }
    while (v3++ < (int)a2);
  }
  return (a2 * a1 * v2);
}

uint64_t siz_params::check_marker_segment(siz_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  *a5 = -1;
  if (a2 == 65361) {
    return 1;
  }
  if (a2 == 65400)
  {
    int v7 = 0;
    if ((kdu_params::get(this, "Mcomponents", 0, 0, &v7, 1, 1, 1) & 1) == 0) {
      *((unsigned char *)this + 37) = 0;
    }
    return 1;
  }
  return 0;
}

uint64_t siz_params::read_marker_segment(siz_params *this, int a2, unsigned int a3, unsigned __int8 *a4, int a5)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (a5) {
    return 0;
  }
  int v9 = &a4[a3];
  if (a2 == 65400)
  {
    if ((int)a3 <= 1)
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = a4;
      __cxa_throw(exception, MEMORY[0x1E4FBA318], 0);
    }
    int v13 = (char)*a4;
    unsigned int v14 = a4[1] | ((v13 & 0x7F) << 8);
    kdu_params::set(this, "Mcomponents", 0, 0, (int *)v14);
    unsigned int v15 = a4 + 2;
    if (v14)
    {
      unsigned int v16 = 0;
      for (int i = 0; i != v14; ++i)
      {
        if ((v13 & 0x80000000) == 0 || !v16)
        {
          if (v9 - v15 <= 0)
          {
            uint64_t v32 = __cxa_allocate_exception(8uLL);
            *uint64_t v32 = v15;
            __cxa_throw(v32, MEMORY[0x1E4FBA318], 0);
          }
          unsigned int v16 = *v15;
          kdu_params::set(this, "Msigned", i, 0, (int *)(v16 >> 7));
          kdu_params::set(this, "Mprecision", i, 0, (int *)((v16 & 0x7F) + 1));
          ++v15;
        }
      }
    }
    if (v15 != v9)
    {
      uint64_t v39 = 0;
      long long v37 = 0u;
      long long v38 = 0u;
      kdu_error::kdu_error((kdu_error *)&v37, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v37 + 16))(&v37, "Malformed CBD marker segment encountered. The final ");
      long long v43 = 0u;
      long long v44 = 0u;
      long long v41 = 0u;
      long long v42 = 0u;
      *(_OWORD *)__int16 v40 = 0u;
      if (BYTE8(v37)) {
        sprintf(v40, "%x");
      }
      else {
        sprintf(v40, "%d");
      }
      (*(void (**)(long long *, char *))(v37 + 16))(&v37, v40);
      (*(void (**)(long long *, const char *))(v37 + 16))(&v37, " bytes were not consumed!");
      kdu_error::~kdu_error((kdu_error *)&v37);
    }
    return 1;
  }
  if (a2 != 65361) {
    return 0;
  }
  if ((int)a3 <= 1)
  {
    uint64_t v33 = __cxa_allocate_exception(8uLL);
    *uint64_t v33 = a4;
    __cxa_throw(v33, MEMORY[0x1E4FBA318], 0);
  }
  int v10 = (char)*a4;
  unsigned __int16 v11 = _byteswap_ushort(*(_WORD *)a4);
  if (v10 < 0)
  {
    int v18 = (int *)(v11 & 0x3FFF);
    uint64_t v19 = 3;
  }
  else
  {
    unsigned int v12 = a4[1] | (*a4 << 8) & 0xBFFF;
    if (v12 >= 5)
    {
      *(void *)&long long v42 = 0;
      *(_OWORD *)__int16 v40 = 0u;
      long long v41 = 0u;
      kdu_error::kdu_error((kdu_error *)v40, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v40 + 16))(v40, "Invalid SIZ marker segment encountered!");
      kdu_error::~kdu_error((kdu_error *)v40);
    }
    if (v12)
    {
      int v18 = 0;
      if (v12 < 3) {
        uint64_t v19 = v12 - 1;
      }
      else {
        uint64_t v19 = v12 + 1;
      }
    }
    else
    {
      int v18 = 0;
      uint64_t v19 = 2;
    }
  }
  kdu_params::set(this, "Sprofile", 0, 0, (int *)v19);
  kdu_params::set(this, "Sextensions", 0, 0, v18);
  kdu_params::set((uint64_t)this, "Scap", 0, 0, (v10 >> 6) & 1);
  if (a3 <= 5)
  {
    int v35 = a4 + 2;
LABEL_74:
    unsigned __int8 v30 = __cxa_allocate_exception(8uLL);
    *unsigned __int8 v30 = v35;
LABEL_61:
    __cxa_throw(v30, MEMORY[0x1E4FBA318], 0);
  }
  unsigned int v20 = (int *)bswap32(*(_DWORD *)(a4 + 2));
  kdu_params::set(this, "Ssize", 0, 1, v20);
  if (a3 <= 9)
  {
    int v35 = a4 + 6;
    goto LABEL_74;
  }
  signed int v21 = (int *)bswap32(*(_DWORD *)(a4 + 6));
  kdu_params::set(this, "Ssize", 0, 0, v21);
  if (a3 <= 0xD)
  {
    int v35 = a4 + 10;
    goto LABEL_74;
  }
  kdu_params::set(this, "Sorigin", 0, 1, (int *)bswap32(*(_DWORD *)(a4 + 10)));
  if (a3 <= 0x11)
  {
    int v35 = a4 + 14;
    goto LABEL_74;
  }
  kdu_params::set(this, "Sorigin", 0, 0, (int *)bswap32(*(_DWORD *)(a4 + 14)));
  if (a3 <= 0x15)
  {
    int v35 = a4 + 18;
    goto LABEL_74;
  }
  unsigned int v22 = (int *)bswap32(*(_DWORD *)(a4 + 18));
  kdu_params::set(this, "Stiles", 0, 1, v22);
  if (a3 <= 0x19)
  {
    int v35 = a4 + 22;
    goto LABEL_74;
  }
  unsigned int v23 = (int *)bswap32(*(_DWORD *)(a4 + 22));
  kdu_params::set(this, "Stiles", 0, 0, v23);
  if (a3 <= 0x1D)
  {
    int v35 = a4 + 26;
    goto LABEL_74;
  }
  kdu_params::set(this, "Stile_origin", 0, 1, (int *)bswap32(*(_DWORD *)(a4 + 26)));
  if (a3 <= 0x21)
  {
    int v35 = a4 + 30;
    goto LABEL_74;
  }
  kdu_params::set(this, "Stile_origin", 0, 0, (int *)bswap32(*(_DWORD *)(a4 + 30)));
  if ((v20 & 0x80000000) == 0 && (v22 & 0x80000000) != 0) {
    kdu_params::set(this, "Stiles", 0, 1, v20);
  }
  if ((v21 & 0x80000000) == 0 && (v23 & 0x80000000) != 0) {
    kdu_params::set(this, "Stiles", 0, 0, v21);
  }
  if (a3 <= 0x23)
  {
    int v35 = a4 + 34;
    goto LABEL_74;
  }
  int v24 = (int *)__rev16(*((unsigned __int16 *)a4 + 17));
  kdu_params::set(this, "Scomponents", 0, 0, v24);
  if (!v24)
  {
    int v29 = a4 + 36;
    goto LABEL_51;
  }
  unsigned int v36 = v9;
  uint64_t v25 = 0;
  int v26 = 0;
  uint64_t v27 = 36;
  do
  {
    if ((int)a3 + v25 - 36 <= 0)
    {
      unsigned __int8 v30 = __cxa_allocate_exception(8uLL);
      unsigned __int8 v31 = &a4[-v25 + 36];
      goto LABEL_60;
    }
    unsigned int v28 = a4[v27];
    kdu_params::set(this, "Ssigned", v26, 0, (int *)(v28 >> 7));
    kdu_params::set(this, "Sprecision", v26, 0, (int *)((v28 & 0x7F) + 1));
    if ((int)a3 + v25 - 37 <= 0)
    {
      unsigned __int8 v30 = __cxa_allocate_exception(8uLL);
      unsigned __int8 v31 = &a4[-v25 + 37];
      goto LABEL_60;
    }
    kdu_params::set(this, "Ssampling", v26, 1, (int *)a4[v27 + 1]);
    if ((int)a3 + v25 - 38 <= 0)
    {
      unsigned __int8 v30 = __cxa_allocate_exception(8uLL);
      unsigned __int8 v31 = &a4[-v25 + 38];
LABEL_60:
      *unsigned __int8 v30 = v31;
      goto LABEL_61;
    }
    kdu_params::set(this, "Ssampling", v26++, 0, (int *)a4[v27 + 2]);
    v25 -= 3;
    v27 += 3;
  }
  while (v24 != v26);
  int v29 = &a4[-v25 + 36];
  int v9 = v36;
LABEL_51:
  if (v29 != v9)
  {
    uint64_t v39 = 0;
    long long v37 = 0u;
    long long v38 = 0u;
    kdu_error::kdu_error((kdu_error *)&v37, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v37 + 16))(&v37, "Malformed SIZ marker segment encountered. The final ");
    long long v43 = 0u;
    long long v44 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    *(_OWORD *)__int16 v40 = 0u;
    if (BYTE8(v37)) {
      sprintf(v40, "%x");
    }
    else {
      sprintf(v40, "%d");
    }
    (*(void (**)(long long *, char *))(v37 + 16))(&v37, v40);
    (*(void (**)(long long *, const char *))(v37 + 16))(&v37, " bytes were not consumed!");
    kdu_error::~kdu_error((kdu_error *)&v37);
  }
  return 1;
}

void sub_1886914D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886914E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11, long long a12, uint64_t a13)
{
  if (v14 == 1)
  {
    __cxa_begin_catch(v13);
    a13 = 0;
    a11 = 0u;
    a12 = 0u;
    kdu_error::kdu_error((kdu_error *)&a11, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(a11 + 16))(&a11, "Malformed SIZ marker segment encountered. Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a11);
  }
  _Unwind_Resume(v13);
}

uint64_t kdu_read(unsigned __int8 **a1, unsigned __int8 *a2, int a3)
{
  if (a3 >= 5) {
    kdu_read();
  }
  int v3 = *a1;
  if (a2 - *a1 < a3)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = *a1;
    __cxa_throw(exception, MEMORY[0x1E4FBA318], 0);
  }
  *a1 = v3 + 1;
  uint64_t v4 = *v3;
  if (a3 >= 2)
  {
    *a1 = v3 + 2;
    uint64_t v4 = v3[1] | (v4 << 8);
    if (a3 != 2)
    {
      *a1 = v3 + 3;
      uint64_t v4 = v3[2] | (v4 << 8);
      if (a3 >= 4)
      {
        *a1 = v3 + 4;
        return v3[3] | (v4 << 8);
      }
    }
  }
  return v4;
}

void siz_params::finalize(siz_params *this)
{
  *(void *)int v10 = 0;
  *(void *)unsigned __int16 v11 = 0;
  int v9 = 0;
  int v8 = 0;
  int v2 = kdu_params::get(this, "Scomponents", 0, 0, &v11[1], 1, 1, 1);
  int v3 = kdu_params::get(this, "Ssampling", 0, 0, v11, 1, 1, 1);
  int v4 = kdu_params::get(this, "Sdims", 0, 0, v11, 1, 1, 1);
  if (kdu_params::get(this, "Ssize", 0, 0, v10, 1, 1, 1)) {
    kdu_params::get(this, "Ssize", 0, 1, &v10[1], 1, 1, 1);
  }
  if (!kdu_params::get(this, "Sorigin", 0, 0, &v8, 1, 1, 1)
    || (kdu_params::get(this, "Sorigin", 0, 1, &v9, 1, 1, 1) & 1) == 0)
  {
    int v8 = 0;
    kdu_params::set(this, "Sorigin", 0, 0, 0);
    int v9 = 0;
    kdu_params::set(this, "Sorigin", 0, 1, 0);
  }
  if ((v3 ^ 1 | v2))
  {
    if ((v4 ^ 1 | v2))
    {
      if ((v2 & 1) == 0)
      {
        uint64_t v7 = 0;
        *(_OWORD *)unsigned int v5 = 0u;
        long long v6 = 0u;
        kdu_error::kdu_error((kdu_error *)v5, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(void *)v5 + 16))(v5, "Problem trying to finalize SIZ information. Insufficient data supplied to determine the number of image components! Available information is as follows:\n\n");
        kdu_params::textualize_attributes((uint64_t)this, (kdu_message *)v5, 1);
        (*(void (**)(int *, const char *))(*(void *)v5 + 16))(v5, "\n");
        kdu_error::~kdu_error((kdu_error *)v5);
      }
    }
    else
    {
      v11[1] = 1;
      if (kdu_params::get(this, "Sdims", 1, 0, v11, 0, 0, 1))
      {
        do
          ++v11[1];
        while ((kdu_params::get(this, "Sdims", v11[1], 0, v11, 0, 0, 1) & 1) != 0);
      }
    }
  }
  else
  {
    v11[1] = 1;
    if (kdu_params::get(this, "Ssampling", 1, 0, v11, 0, 0, 1))
    {
      do
        ++v11[1];
      while ((kdu_params::get(this, "Ssampling", v11[1], 0, v11, 0, 0, 1) & 1) != 0);
    }
  }
  operator new[]();
}

void sub_1886933D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886933E4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  _Unwind_Resume(v17);
}

BOOL synthesize_canvas_size(int a1, int *a2, int a3, int *a4)
{
  int v4 = *a2;
  if (a1 >= 2)
  {
    unsigned int v5 = a2 + 1;
    uint64_t v6 = a1 - 1;
    do
    {
      int v8 = *v5++;
      int v7 = v8;
      if (v8 > v4) {
        int v4 = v7;
      }
      --v6;
    }
    while (v6);
  }
  unsigned int v9 = a3 - 1;
  unsigned int v10 = -a3;
  BOOL v11 = 1;
  unsigned int v12 = 1;
  while (1)
  {
    int v13 = -(int)(v10 / v12);
    if (a3 > 0) {
      int v13 = v9 / v12 + 1;
    }
    int v14 = (v13 + v4) * v12;
    int v15 = v14 - v12 + 1;
    if (a1 < 1)
    {
      LODWORD(v16) = 0;
    }
    else
    {
      uint64_t v16 = 0;
      while (1)
      {
        int v17 = a2[v16];
        int v18 = (v15 - a3) / v17;
        if (v18 <= 1) {
          int v18 = 1;
        }
        if (v18 < 2)
        {
LABEL_19:
          int v18 = 1;
        }
        else
        {
          while (1)
          {
            int v19 = -(int)(v10 / v18);
            if (a3 > 0) {
              int v19 = v9 / v18 + 1;
            }
            if ((v19 + v17) * v18 <= v15) {
              break;
            }
            if (v18-- <= 2) {
              goto LABEL_19;
            }
          }
        }
        int v21 = v18 - 1;
        int v22 = v18 + 1;
        int v23 = ~v18;
        do
        {
          int v24 = v22;
          int v25 = v23;
          if (v18 <= 1) {
            unsigned int v26 = 1;
          }
          else {
            unsigned int v26 = v18;
          }
          int v27 = -(int)(v10 / v26);
          int v28 = v9 / v26;
          if (a3 > 0) {
            int v29 = v28 + 1;
          }
          else {
            int v29 = v27;
          }
          int v30 = (v29 + v17) * v18++;
          ++v21;
          int v22 = v24 + 1;
          --v23;
        }
        while (v30 < v15);
        int v31 = v21 * (v17 + v29) - v18;
        int v32 = v31 + 1;
        int v33 = v31 + 2;
        if (v32 >= v15) {
          int v15 = v33;
        }
        if (v15 > v14) {
          break;
        }
        if (v18 != 256)
        {
          do
          {
            if (v24 <= 1) {
              unsigned int v34 = 1;
            }
            else {
              unsigned int v34 = v24;
            }
            int v35 = v9 / v34;
            int v36 = -(int)(v10 / v34);
            if (a3 > 0) {
              int v36 = v35 + 1;
            }
            int v37 = (v36 + v17) * v24;
            if (v25 + v37 >= v14) {
              break;
            }
            ++v24;
            --v25;
            int v30 = v37;
          }
          while (v24 != 256);
        }
        if (v30 < v14) {
          int v14 = v30;
        }
        if (v15 > v14) {
          break;
        }
        if (++v16 == a1) {
          goto LABEL_48;
        }
      }
    }
    if (v16 == a1) {
      break;
    }
    BOOL v11 = v12++ < 0xFF;
    if (v12 == 256) {
      return 0;
    }
  }
LABEL_48:
  *a4 = v15;
  return v11;
}

void mct_params::mct_params(mct_params *this)
{
  *((void *)this + 1) = "MCT";
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18898D540;
  *((_WORD *)this + 20) = 1;
  *((unsigned char *)this + 42) = 1;
  *((void *)this + 6) = this;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 9) = this;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = this;
  *((unsigned char *)this + 104) = 0;
  *((_DWORD *)this + 9) = 65537;
  *((void *)this + 14) = 0;
  *(void *)this = &unk_1ED4DEAD8;
}

void sub_188693818(_Unwind_Exception *a1)
{
  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t mct_params::copy_with_xforms(mct_params *this, kdu_params *a2)
{
  uint64_t v9 = 0;
  if (kdu_params::get(a2, "Mmatrix_size", 0, 0, (int *)&v9, 0, 1, 1)) {
    BOOL v4 = (int)v9 < 1;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    kdu_params::set(this, "Mmatrix_size", 0, 0, (int *)v9);
    if ((int)v9 >= 1)
    {
      int v5 = 0;
      do
      {
        if (!kdu_params::get(a2, "Mmatrix_coeffs", v5, 0, (float *)&v9 + 1, 1, 1, 1)) {
          break;
        }
        kdu_params::set((uint64_t)this, "Mmatrix_coeffs", v5++, 0, *((float *)&v9 + 1));
      }
      while (v5 < (int)v9);
    }
  }
  if (kdu_params::get(a2, "Mvector_size", 0, 0, (int *)&v9, 0, 1, 1))
  {
    if ((int)v9 >= 1)
    {
      kdu_params::set(this, "Mvector_size", 0, 0, (int *)v9);
      if ((int)v9 >= 1)
      {
        int v6 = 0;
        do
        {
          if (!kdu_params::get(a2, "Mvector_coeffs", v6, 0, (float *)&v9 + 1, 1, 1, 1)) {
            break;
          }
          kdu_params::set((uint64_t)this, "Mvector_coeffs", v6++, 0, *((float *)&v9 + 1));
        }
        while (v6 < (int)v9);
      }
    }
  }
  uint64_t result = kdu_params::get(a2, "Mtriang_size", 0, 0, (int *)&v9, 0, 1, 1);
  if (result)
  {
    if ((int)v9 >= 1)
    {
      uint64_t result = (uint64_t)kdu_params::set(this, "Mtriang_size", 0, 0, (int *)v9);
      if ((int)v9 >= 1)
      {
        int v8 = 0;
        do
        {
          uint64_t result = kdu_params::get(a2, "Mtriang_coeffs", v8, 0, (float *)&v9 + 1, 1, 1, 1);
          if (!result) {
            break;
          }
          uint64_t result = kdu_params::set((uint64_t)this, "Mtriang_coeffs", v8++, 0, *((float *)&v9 + 1));
        }
        while (v8 < (int)v9);
      }
    }
  }
  return result;
}

uint64_t mct_params::finalize(uint64_t this, int a2)
{
  int v2 = (kdu_params *)this;
  if (a2)
  {
    if (*(_DWORD *)(this + 152) <= *(_DWORD *)(this + 156)
      || *(_DWORD *)(this + 160) <= *(_DWORD *)(this + 164)
      || *(_DWORD *)(this + 168) <= *(_DWORD *)(this + 172))
    {
      uint64_t v7 = 0;
      long long v5 = 0u;
      long long v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      goto LABEL_23;
    }
  }
  else
  {
    *(void *)int v3 = 0;
    *(void *)BOOL v4 = 0;
    if (kdu_params::get((kdu_params *)this, "Mmatrix_size", 0, 0, &v4[1], 0, 1, 1) && v4[1] < 1
      || kdu_params::get(v2, "Mvector_size", 0, 0, v4, 0, 1, 1) && v4[0] < 1
      || (this = kdu_params::get(v2, "Mtriang_size", 0, 0, &v3[1], 0, 1, 1), this) && v3[1] <= 0)
    {
      uint64_t v7 = 0;
      long long v5 = 0u;
      long long v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
    if (!*((_DWORD *)v2 + 6) && v4[0] | v3[1] | v4[1])
    {
      uint64_t v7 = 0;
      long long v5 = 0u;
      long long v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
    if (v4[1] >= 1 && (this = kdu_params::get(v2, "Mmatrix_coeffs", v4[1] - 1, 0, (float *)v3, 1, 1, 1), !this)
      || v4[0] >= 1 && (this = kdu_params::get(v2, "Mvector_coeffs", v4[0] - 1, 0, (float *)v3, 1, 1, 1), !this)
      || v3[1] >= 1
      && (this = kdu_params::get(v2, "Mtriang_coeffs", v3[1] - 1, 0, (float *)v3, 1, 1, 1), (this & 1) == 0))
    {
      uint64_t v7 = 0;
      long long v5 = 0u;
      long long v6 = 0u;
      kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
LABEL_23:
      kdu_error::~kdu_error((kdu_error *)&v5);
    }
  }
  return this;
}

void sub_188693DAC(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188693DB8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

BOOL mct_params::check_marker_segment(mct_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  if (a2 != 65396 || a3 < 4) {
    return 0;
  }
  int v7 = a4[2];
  int v8 = a4[3];
  *a5 = v8;
  return (~v7 & 3) != 0 && v8 != 0;
}

uint64_t mct_params::read_marker_segment(mct_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (a5) {
    return 0;
  }
  uint64_t result = 0;
  if (a2 == 65396 && a3 >= 4)
  {
    int v7 = *((_DWORD *)this + 6);
    if (!v7) {
      return 0;
    }
    uint64_t result = 0;
    if (v7 == a4[3])
    {
      unint64_t v8 = a4[2];
      int v9 = v8 & 3;
      if (v9 != 3)
      {
        unsigned int v10 = &a4[a3];
        signed int v11 = __rev16(*(unsigned __int16 *)a4);
        unsigned int v12 = a4 + 4;
        if (v11)
        {
          signed int v13 = 0;
          if ((v8 & 3) != 0) {
            goto LABEL_11;
          }
        }
        else
        {
          if (a3 <= 5)
          {
            exception = __cxa_allocate_exception(8uLL);
            void *exception = v12;
            __cxa_throw(exception, MEMORY[0x1E4FBA318], 0);
          }
          unsigned int v12 = a4 + 6;
          signed int v13 = __rev16(*((unsigned __int16 *)a4 + 2));
          if ((v8 & 3) != 0)
          {
LABEL_11:
            if (v9 == 1)
            {
              if (v11) {
                signed int v13 = *((_DWORD *)this + 39);
              }
              else {
                *((_DWORD *)this + 39) = v13;
              }
              int v17 = (char *)this + 152;
              int v15 = "Mmatrix_coeffs";
              int v14 = "Mmatrix_size";
            }
            else
            {
              if (v9 != 2)
              {
                int v14 = 0;
                int v15 = 0;
                int v16 = 0;
                signed int v13 = 0;
                goto LABEL_29;
              }
              if (v11) {
                signed int v13 = *((_DWORD *)this + 41);
              }
              else {
                *((_DWORD *)this + 41) = v13;
              }
              int v17 = (char *)this + 160;
              int v15 = "Mvector_coeffs";
              int v14 = "Mvector_size";
            }
LABEL_28:
            int v16 = (*(_DWORD *)v17)++;
LABEL_29:
            if (v11 > v13 || v11 < v16)
            {
              *(void *)&long long v39 = 0;
              *(_OWORD *)int v37 = 0u;
              long long v38 = 0u;
              kdu_error::kdu_error((kdu_error *)v37, "Kakadu Core Error:\n");
              kdu_error::~kdu_error((kdu_error *)v37);
            }
            if (v11 != v16)
            {
              *(void *)&long long v39 = 0;
              *(_OWORD *)int v37 = 0u;
              long long v38 = 0u;
              kdu_error::kdu_error((kdu_error *)v37, "Kakadu Core Error:\n");
              kdu_error::~kdu_error((kdu_error *)v37);
            }
            uint64_t v18 = (v8 >> 2) & 3;
            int v19 = dword_18898D550[v18];
            v34[0] = 0;
            if (v16 < 1)
            {
              int v20 = 0;
            }
            else
            {
              kdu_params::get(this, v14, 0, 0, v34, 1, 1, 1);
              int v20 = v34[0];
            }
            int v21 = ((int)v10 - (int)v12) / v19;
            kdu_params::set(this, v14, 0, 0, (int *)(v20 + v21));
            if (v21 >= 1)
            {
              for (int i = 0; i != v21; ++i)
              {
                switch((int)v18)
                {
                  case 1:
                    if (v10 - v12 < 4) {
                      goto LABEL_60;
                    }
                    unsigned int v31 = *(_DWORD *)v12;
                    v12 += 4;
                    int v25 = bswap32(v31);
                    goto LABEL_52;
                  case 2:
                    if (v10 - v12 < 4) {
                      goto LABEL_60;
                    }
                    *(_DWORD *)int v37 = 0;
                    for (uint64_t j = 3; j != -1; --j)
                    {
                      char v27 = *v12++;
                      v37[j] = v27;
                    }
                    float v28 = *(float *)v37;
                    break;
                  case 3:
                    if (v10 - v12 < 8) {
                      goto LABEL_60;
                    }
                    *(void *)int v37 = 0;
                    for (uint64_t k = 7; k != -1; --k)
                    {
                      char v30 = *v12++;
                      v37[k] = v30;
                    }
                    float v28 = *(double *)v37;
                    break;
                  default:
                    if (v10 - v12 <= 1)
                    {
LABEL_60:
                      int v32 = __cxa_allocate_exception(8uLL);
                      *int v32 = v12;
                      __cxa_throw(v32, MEMORY[0x1E4FBA318], 0);
                    }
                    int v23 = *v12;
                    int v24 = v12[1];
                    v12 += 2;
                    int v25 = (v24 | (v23 << 8)) - ((v23 << 9) & 0x10000);
LABEL_52:
                    float v28 = (float)v25;
                    break;
                }
                kdu_params::set((uint64_t)this, v15, v34[0] + i, 0, v28);
              }
            }
            if (v12 != v10)
            {
              uint64_t v36 = 0;
              *(_OWORD *)unsigned int v34 = 0u;
              long long v35 = 0u;
              kdu_error::kdu_error((kdu_error *)v34, "Kakadu Core Error:\n");
              (*(void (**)(int *, const char *))(*(void *)v34 + 16))(v34, "Malformed MCT marker segment encountered. The final ");
              long long v40 = 0u;
              long long v41 = 0u;
              long long v38 = 0u;
              long long v39 = 0u;
              *(_OWORD *)int v37 = 0u;
              if (LOBYTE(v34[2])) {
                sprintf(v37, "%x");
              }
              else {
                sprintf(v37, "%d");
              }
              (*(void (**)(int *, char *))(*(void *)v34 + 16))(v34, v37);
              (*(void (**)(int *, const char *))(*(void *)v34 + 16))(v34, " bytes were not consumed!");
              kdu_error::~kdu_error((kdu_error *)v34);
            }
            return 1;
          }
        }
        if (v11) {
          signed int v13 = *((_DWORD *)this + 43);
        }
        else {
          *((_DWORD *)this + 43) = v13;
        }
        int v17 = (char *)this + 168;
        int v15 = "Mtriang_coeffs";
        int v14 = "Mtriang_size";
        goto LABEL_28;
      }
    }
  }
  return result;
}

void sub_188694340(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, long long a17, long long a18, uint64_t a19)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    a19 = 0;
    a17 = 0u;
    a18 = 0u;
    kdu_error::kdu_error((kdu_error *)&a17, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(a17 + 16))(&a17, "Malformed MCT marker segment encountered.  Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mct_params::write_marker_segment(mct_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  int v4 = *((_DWORD *)this + 6);
  if (v4 < 1) {
    return 0;
  }
  uint64_t result = 0;
  if (!a4 && v4 <= 0xFF)
  {
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0) {
      return 0;
    }
    int v37 = 0;
    *(void *)uint64_t v36 = 0;
    kdu_params::get(this, "Mtriang_size", 0, 0, v36, 0, 1, 1);
    kdu_params::get(this, "Mmatrix_size", 0, 0, &v36[1], 0, 1, 1);
    kdu_params::get(this, "Mvector_size", 0, 0, &v37, 0, 1, 1);
    uint64_t v8 = 0;
    uint64_t result = 0;
    do
    {
      int v9 = v36[v8];
      if (v9) {
        uint64_t result = (result + 4 * v9 + 8 * ((v9 - 1) / 4092) + 10);
      }
      ++v8;
    }
    while (v8 != 3);
    if (a2 && result)
    {
      unsigned int v31 = result;
      uint64_t v10 = 0;
      int v11 = 0;
      do
      {
        int v12 = v36[v10];
        if (v12)
        {
          *(float *)&unsigned int v35 = 0.0;
          if (v12 < 1)
          {
            BOOL v17 = 0;
          }
          else
          {
            signed int v13 = off_1E53C0A58[v10];
            int v14 = 1;
            do
            {
              kdu_params::get(this, v13, v14 - 1, 0, (float *)&v35, 1, 1, 1);
              float v15 = floor(*(float *)&v35 + 0.5);
              float v16 = *(float *)&v35 - v15;
              *(float *)&unsigned int v35 = v16;
              BOOL v17 = v16 > 0.0001 || v16 < 0.0001;
              int v12 = v36[v10];
              if (v16 < 0.0001) {
                break;
              }
              if (v16 > 0.0001) {
                break;
              }
            }
            while (v14++ < v12);
          }
          if (v12 >= -4090)
          {
            int v19 = 0;
            int v20 = 0;
            int v34 = (v12 - 1) / 4092;
            if (v17) {
              __int16 v21 = 2048;
            }
            else {
              __int16 v21 = 1024;
            }
            __int16 v32 = v21 | ((_WORD)v10 << 8);
            uint64_t v33 = v10;
            do
            {
              int v22 = v36[v10] - v19;
              if (v22 >= 4092) {
                int v23 = 4092;
              }
              else {
                int v23 = v36[v10] - v19;
              }
              kdu_output::put(a2, 255);
              kdu_output::put(a2, 116);
              __int16 v24 = ((2 * (v20 == 0)) | (4 * v23)) + 6;
              kdu_output::put(a2, SHIBYTE(v24));
              kdu_output::put(a2, v24 & 0xFE);
              kdu_output::put(a2, SBYTE1(v20));
              kdu_output::put(a2, v20);
              int v25 = *((_DWORD *)this + 6);
              kdu_output::put(a2, (unsigned __int16)(v32 + v25) >> 8);
              kdu_output::put(a2, v25);
              if (v20)
              {
                v11 += 8;
              }
              else
              {
                kdu_output::put(a2, SBYTE1(v34));
                kdu_output::put(a2, v34);
                v11 += 10;
              }
              if (v22 >= 1)
              {
                unsigned int v26 = off_1E53C0A58[v10];
                if (v23 <= 1) {
                  int v27 = 1;
                }
                else {
                  int v27 = v23;
                }
                int v28 = v19;
                do
                {
                  kdu_params::get(this, v26, v28, 0, (float *)&v35, 1, 1, 1);
                  if (v17)
                  {
                    kdu_output::put(a2, v35);
                    int v29 = 4;
                  }
                  else
                  {
                    int v29 = kdu_output::put(a2, vcvtmd_s64_f64(*(float *)&v35 + 0.5));
                  }
                  v11 += v29;
                  ++v28;
                  --v27;
                }
                while (v27);
              }
              v19 += v23;
              BOOL v30 = v20++ == v34;
              uint64_t v10 = v33;
            }
            while (!v30);
          }
        }
        ++v10;
      }
      while (v10 != 3);
      uint64_t result = v31;
      if (v31 != v11) {
        mct_params::write_marker_segment();
      }
    }
  }
  return result;
}

void mcc_params::mcc_params(mcc_params *this)
{
  *((void *)this + 1) = "MCC";
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18898D540;
  *((_WORD *)this + 20) = 1;
  *((unsigned char *)this + 42) = 1;
  *((void *)this + 6) = this;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 9) = this;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = this;
  *((unsigned char *)this + 104) = 0;
  *((_DWORD *)this + 9) = 65537;
  *((void *)this + 14) = 0;
  *(void *)this = &unk_1ED4DEA18;
    "ansform block operates on the next N2 components in this list; and so forth.",
    "II");
}

void sub_188694968(_Unwind_Exception *a1)
{
  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t mcc_params::finalize(uint64_t this, char a2)
{
  if ((a2 & 1) == 0)
  {
    int v2 = (kdu_params *)this;
    *(void *)int v19 = 0;
    int v3 = 0;
    if (kdu_params::get((kdu_params *)this, "Mstage_inputs", 0, 0, &v19[1], 0, 0, 1))
    {
      int v3 = 0;
      int v4 = 0;
      do
      {
        if (!kdu_params::get(v2, "Mstage_inputs", v4, 1, v19, 0, 0, 1)) {
          break;
        }
        if (v19[0] >= 0x4000 || v19[1] < 0 || v19[1] > v19[0])
        {
          uint64_t v18 = 0;
          long long v16 = 0u;
          long long v17 = 0u;
          kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v16);
        }
        int v3 = v3 + v19[0] - v19[1] + 1;
        ++v4;
      }
      while ((kdu_params::get(v2, "Mstage_inputs", v4, 0, &v19[1], 0, 0, 1) & 1) != 0);
    }
    int v5 = 0;
    if (kdu_params::get(v2, "Mstage_outputs", 0, 0, &v19[1], 0, 0, 1))
    {
      int v5 = 0;
      int v6 = 0;
      do
      {
        if (!kdu_params::get(v2, "Mstage_outputs", v6, 1, v19, 0, 0, 1)) {
          break;
        }
        if (v19[0] >= 0x4000 || v19[1] < 0 || v19[1] > v19[0])
        {
          uint64_t v18 = 0;
          long long v16 = 0u;
          long long v17 = 0u;
          kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v16);
        }
        int v5 = v5 + v19[0] - v19[1] + 1;
        ++v6;
      }
      while ((kdu_params::get(v2, "Mstage_outputs", v6, 0, &v19[1], 0, 0, 1) & 1) != 0);
    }
    *(void *)float v15 = 0;
    int v7 = 0;
    if (kdu_params::get(v2, "Mstage_collections", 0, 0, &v15[1], 0, 0, 1))
    {
      do
      {
        if (!kdu_params::get(v2, "Mstage_collections", v7, 1, v15, 0, 0, 1)) {
          break;
        }
        if (v15[1] < 1 || v15[0] <= 0)
        {
          uint64_t v18 = 0;
          long long v16 = 0u;
          long long v17 = 0u;
          kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v16);
        }
        ++v7;
        v3 -= v15[1];
        v5 -= v15[0];
        char v9 = kdu_params::get(v2, "Mstage_collections", v7, 0, &v15[1], 0, 0, 1);
      }
      while ((v9 & 1) != 0);
    }
    if (v3 | v5)
    {
      uint64_t v18 = 0;
      long long v16 = 0u;
      long long v17 = 0u;
      kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v16);
    }
    int v14 = 0;
    this = kdu_params::get(v2, "Mstage_xforms", 0, 0, &v14, 0, 0, 1);
    int v10 = 0;
    if (this)
    {
      int v10 = 0;
      do
      {
        int v13 = 0;
        *(void *)int v12 = 0;
        int v11 = 0;
        if (!kdu_params::get(v2, "Mstage_xforms", v10, 1, &v13, 0, 0, 1)
          || !kdu_params::get(v2, "Mstage_xforms", v10, 2, &v12[1], 0, 0, 1)
          || !kdu_params::get(v2, "Mstage_xforms", v10, 3, v12, 0, 0, 1)
          || !kdu_params::get(v2, "Mstage_xforms", v10, 4, &v11, 0, 0, 1)
          || v13 < 0
          || v13 > 255
          || v12[1] < 0
          || v12[1] >= 256)
        {
          uint64_t v18 = 0;
          long long v16 = 0u;
          long long v17 = 0u;
          kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v16);
        }
        if (v14 == 3 && v12[0] >= 0x21u)
        {
          uint64_t v18 = 0;
          long long v16 = 0u;
          long long v17 = 0u;
          kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v16);
        }
        if (v14 != 3 && (v12[0] > 1u || v11))
        {
          uint64_t v18 = 0;
          long long v16 = 0u;
          long long v17 = 0u;
          kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v16);
        }
        this = kdu_params::get(v2, "Mstage_xforms", ++v10, 0, &v14, 0, 0, 1);
      }
      while ((this & 1) != 0);
    }
    if (v7 != v10)
    {
      uint64_t v18 = 0;
      long long v16 = 0u;
      long long v17 = 0u;
      kdu_error::kdu_error((kdu_error *)&v16, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v16);
    }
  }
  return this;
}

void sub_18869504C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188695058(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  _Unwind_Resume(v13);
}

uint64_t mcc_params::copy_with_xforms(mcc_params *this, kdu_params *a2)
{
  int v14 = 0;
  int v13 = 0;
  if (kdu_params::get(a2, "Mstage_inputs", 0, 0, &v14, 0, 0, 1))
  {
    int v4 = 0;
    do
    {
      if (!kdu_params::get(a2, "Mstage_inputs", v4, 1, &v13, 0, 0, 1)) {
        break;
      }
      kdu_params::set(this, "Mstage_inputs", v4, 0, (int *)v14);
      kdu_params::set(this, "Mstage_inputs", v4++, 1, (int *)v13);
    }
    while ((kdu_params::get(a2, "Mstage_inputs", v4, 0, &v14, 0, 0, 1) & 1) != 0);
  }
  if (kdu_params::get(a2, "Mstage_outputs", 0, 0, &v14, 0, 0, 1))
  {
    int v5 = 0;
    do
    {
      if (!kdu_params::get(a2, "Mstage_outputs", v5, 1, &v13, 0, 0, 1)) {
        break;
      }
      kdu_params::set(this, "Mstage_outputs", v5, 0, (int *)v14);
      kdu_params::set(this, "Mstage_outputs", v5++, 1, (int *)v13);
    }
    while ((kdu_params::get(a2, "Mstage_outputs", v5, 0, &v14, 0, 0, 1) & 1) != 0);
  }
  *(void *)int v12 = 0;
  if (kdu_params::get(a2, "Mstage_collections", 0, 0, &v12[1], 0, 0, 1))
  {
    int v6 = 0;
    do
    {
      if (!kdu_params::get(a2, "Mstage_collections", v6, 1, v12, 0, 0, 1)) {
        break;
      }
      kdu_params::set(this, "Mstage_collections", v6, 0, (int *)v12[1]);
      kdu_params::set(this, "Mstage_collections", v6++, 1, (int *)v12[0]);
    }
    while ((kdu_params::get(a2, "Mstage_collections", v6, 0, &v12[1], 0, 0, 1) & 1) != 0);
  }
  *(void *)int v10 = 0;
  *(void *)int v11 = 0;
  int v9 = 0;
  uint64_t result = kdu_params::get(a2, "Mstage_xforms", 0, 0, &v11[1], 0, 0, 1);
  if (result)
  {
    int v8 = 0;
    do
    {
      uint64_t result = kdu_params::get(a2, "Mstage_xforms", v8, 1, v11, 0, 0, 1);
      if (!result) {
        break;
      }
      uint64_t result = kdu_params::get(a2, "Mstage_xforms", v8, 2, &v10[1], 0, 0, 1);
      if (!result) {
        break;
      }
      uint64_t result = kdu_params::get(a2, "Mstage_xforms", v8, 3, v10, 0, 0, 1);
      if (!result) {
        break;
      }
      uint64_t result = kdu_params::get(a2, "Mstage_xforms", v8, 4, &v9, 0, 0, 1);
      if (!result) {
        break;
      }
      kdu_params::set(this, "Mstage_xforms", v8, 0, (int *)v11[1]);
      kdu_params::set(this, "Mstage_xforms", v8, 1, (int *)v11[0]);
      kdu_params::set(this, "Mstage_xforms", v8, 2, (int *)v10[1]);
      kdu_params::set(this, "Mstage_xforms", v8, 3, (int *)v10[0]);
      kdu_params::set(this, "Mstage_xforms", v8++, 4, (int *)v9);
      uint64_t result = kdu_params::get(a2, "Mstage_xforms", v8, 0, &v11[1], 0, 0, 1);
    }
    while ((result & 1) != 0);
  }
  return result;
}

BOOL mcc_params::check_marker_segment(mcc_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  BOOL result = a2 == 65397 && a3 > 2;
  if (result) {
    *a5 = a4[2];
  }
  return result;
}

uint64_t mcc_params::read_marker_segment(mcc_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  if (a5) {
    return 0;
  }
  uint64_t result = 0;
  if (a2 == 65397 && a3 >= 3)
  {
    if (*((_DWORD *)this + 6) != a4[2]) {
      return 0;
    }
    if (__rev16(*(unsigned __int16 *)a4)) {
      goto LABEL_10;
    }
    if (a3 <= 4)
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = a4 + 3;
      __cxa_throw(exception, MEMORY[0x1E4FBA318], 0);
    }
    int v8 = a4 + 5;
    if (__rev16(*(unsigned __int16 *)(a4 + 3)))
    {
LABEL_10:
      *(void *)&long long v58 = 0;
      *(_OWORD *)int v56 = 0u;
      long long v57 = 0u;
      kdu_error::kdu_error((kdu_error *)v56, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v56 + 16))(v56, "Encountered MCC (Multi-component transform Component Collection) information which has been split across multiple marker segments.  While this is not illegal, Kakadu does not currently support such massive multi-component transform descriptions.  It is a rare application indeed that would need multiple marker segments.");
      kdu_error::~kdu_error((kdu_error *)v56);
    }
    int v53 = &a4[a3];
    if (v53 - v8 <= 1)
    {
      int v46 = __cxa_allocate_exception(8uLL);
      void *v46 = v8;
      __cxa_throw(v46, MEMORY[0x1E4FBA318], 0);
    }
    unsigned int v10 = *(unsigned __int16 *)v8;
    int v9 = a4 + 7;
    unsigned int v48 = __rev16(v10);
    if (v48)
    {
      int v11 = 0;
      int v12 = 0;
      int v13 = 0;
      while (1)
      {
        if (v53 - v9 < 1)
        {
          uint64_t v42 = __cxa_allocate_exception(8uLL);
          *uint64_t v42 = v9;
          __cxa_throw(v42, MEMORY[0x1E4FBA318], 0);
        }
        unsigned int v52 = *v9;
        if (v53 - (v9 + 1) <= 1)
        {
          long long v41 = __cxa_allocate_exception(8uLL);
          *long long v41 = v9 + 1;
          __cxa_throw(v41, MEMORY[0x1E4FBA318], 0);
        }
        unint64_t v14 = v9[1];
        float v15 = v9 + 3;
        int v49 = v11;
        unsigned int v51 = v9[2] | ((v14 & 0x7F) << 8);
        if (v51)
        {
          int v16 = v9[2] | ((v14 & 0x7F) << 8);
          int v17 = (char)v14;
          uint64_t v18 = (v14 >> 7) + 1;
          uint64_t v19 = 0xFFFFFFFFLL;
          uint64_t v20 = 0xFFFFFFFFLL;
          while (1)
          {
            if (v53 - v15 < v18)
            {
              long long v39 = __cxa_allocate_exception(8uLL);
              void *v39 = v15;
              __cxa_throw(v39, MEMORY[0x1E4FBA318], 0);
            }
            __int16 v21 = (int *)v19;
            uint64_t v19 = *v15;
            if (v17 < 0)
            {
              uint64_t v19 = v15[1] | (v19 << 8);
              if (v18 == 2)
              {
                v15 += 2;
                if ((v21 & 0x80000000) != 0) {
                  goto LABEL_28;
                }
              }
              else
              {
                unsigned int v22 = v15[2];
                v15 += 3;
                uint64_t v19 = v22 | (v19 << 8);
                if ((v21 & 0x80000000) != 0) {
                  goto LABEL_28;
                }
              }
            }
            else
            {
              ++v15;
              if ((v21 & 0x80000000) != 0) {
                goto LABEL_28;
              }
            }
            if (v19 != v21 + 1)
            {
              kdu_params::set(this, "Mstage_inputs", v13, 0, (int *)v20);
              kdu_params::set(this, "Mstage_inputs", v13++, 1, v21);
LABEL_28:
              uint64_t v20 = v19;
            }
            if (!--v16)
            {
              kdu_params::set(this, "Mstage_inputs", v13, 0, (int *)v20);
              kdu_params::set(this, "Mstage_inputs", v13++, 1, (int *)v19);
              int v11 = v49;
              break;
            }
          }
        }
        if (v53 - v15 <= 1)
        {
          long long v43 = __cxa_allocate_exception(8uLL);
          void *v43 = v15;
          __cxa_throw(v43, MEMORY[0x1E4FBA318], 0);
        }
        unint64_t v23 = *v15;
        __int16 v24 = v15 + 2;
        unsigned int v25 = v15[1] | ((v23 & 0x7F) << 8);
        unsigned int v50 = v25;
        if (v25) {
          break;
        }
LABEL_47:
        kdu_params::set(this, "Mstage_collections", v11, 0, (int *)v51);
        kdu_params::set(this, "Mstage_collections", v11, 1, (int *)v50);
        if (v53 - v24 <= 2)
        {
          long long v44 = __cxa_allocate_exception(8uLL);
          *long long v44 = v24;
          __cxa_throw(v44, MEMORY[0x1E4FBA318], 0);
        }
        unsigned int v32 = *v24;
        uint64_t v33 = (int *)v24[1];
        int v9 = v24 + 3;
        int v34 = (int *)v24[2];
        if (v52 == 3)
        {
          if (v53 - v9 <= 3)
          {
            uint64_t v45 = __cxa_allocate_exception(8uLL);
            *uint64_t v45 = v9;
            __cxa_throw(v45, MEMORY[0x1E4FBA318], 0);
          }
          int v9 = v24 + 7;
          unsigned int v35 = (int *)bswap32(*(_DWORD *)(v24 + 3));
          int v36 = 63;
        }
        else
        {
          unsigned int v35 = 0;
          int v36 = 1;
        }
        int v37 = (int *)(v36 & v32);
        if (!v51
          || !v50
          || (v52 != 3 ? (BOOL v38 = v52 > 1) : (BOOL v38 = 0), v38 || v37 > 0x20 || v51 != v50 && v52 != 1))
        {
          *(void *)&long long v58 = 0;
          *(_OWORD *)int v56 = 0u;
          long long v57 = 0u;
          kdu_error::kdu_error((kdu_error *)v56, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(void *)v56 + 16))(v56, "Malformed MCC marker segment encountered.  Invalid component collection dimensions, transform type or number of DWT levels.");
          kdu_error::~kdu_error((kdu_error *)v56);
        }
        kdu_params::set(this, "Mstage_xforms", v11, 0, (int *)v52);
        kdu_params::set(this, "Mstage_xforms", v11, 1, v34);
        kdu_params::set(this, "Mstage_xforms", v11, 2, v33);
        kdu_params::set(this, "Mstage_xforms", v11, 3, v37);
        kdu_params::set(this, "Mstage_xforms", v11++, 4, v35);
        if (v11 == v48) {
          goto LABEL_63;
        }
      }
      int v26 = (char)v23;
      uint64_t v27 = (v23 >> 7) + 1;
      uint64_t v28 = 0xFFFFFFFFLL;
      uint64_t v29 = 0xFFFFFFFFLL;
      while (1)
      {
        if (v53 - v24 < v27)
        {
          long long v40 = __cxa_allocate_exception(8uLL);
          void *v40 = v24;
          __cxa_throw(v40, MEMORY[0x1E4FBA318], 0);
        }
        BOOL v30 = (int *)v28;
        uint64_t v28 = *v24;
        if (v26 < 0)
        {
          uint64_t v28 = v24[1] | (v28 << 8);
          if (v27 == 2)
          {
            v24 += 2;
            if ((v30 & 0x80000000) != 0) {
              goto LABEL_44;
            }
          }
          else
          {
            unsigned int v31 = v24[2];
            v24 += 3;
            uint64_t v28 = v31 | (v28 << 8);
            if ((v30 & 0x80000000) != 0) {
              goto LABEL_44;
            }
          }
        }
        else
        {
          ++v24;
          if ((v30 & 0x80000000) != 0) {
            goto LABEL_44;
          }
        }
        if (v28 != v30 + 1)
        {
          kdu_params::set(this, "Mstage_outputs", v12, 0, (int *)v29);
          kdu_params::set(this, "Mstage_outputs", v12++, 1, v30);
LABEL_44:
          uint64_t v29 = v28;
        }
        if (!--v25)
        {
          kdu_params::set(this, "Mstage_outputs", v12, 0, (int *)v29);
          int v11 = v49;
          kdu_params::set(this, "Mstage_outputs", v12++, 1, (int *)v28);
          goto LABEL_47;
        }
      }
    }
LABEL_63:
    if (v9 != v53)
    {
      uint64_t v55 = 0;
      memset(v54, 0, sizeof(v54));
      kdu_error::kdu_error((kdu_error *)v54, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v54[0] + 16))(v54, "Malformed MCC marker segment encountered. The final ");
      long long v59 = 0u;
      long long v60 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      *(_OWORD *)int v56 = 0u;
      if (BYTE8(v54[0])) {
        sprintf(v56, "%x");
      }
      else {
        sprintf(v56, "%d");
      }
      (*(void (**)(_OWORD *, char *))(*(void *)&v54[0] + 16))(v54, v56);
      (*(void (**)(_OWORD *, const char *))(*(void *)&v54[0] + 16))(v54, " bytes were not consumed!");
      kdu_error::~kdu_error((kdu_error *)v54);
    }
    return 1;
  }
  return result;
}

void sub_188695C9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188695CA8(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,long long a21,long long a22,uint64_t a23)
{
  _Unwind_Resume(v23);
}

void sub_188695CD0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188695CF0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,long long a21,long long a22,uint64_t a23)
{
  sub_188695D3C(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
    a20,
    a21,
    a22,
    a23);
}

void sub_188695D0C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,long long a21,long long a22,uint64_t a23)
{
  sub_188695D3C((int)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
    a20,
    a21,
    a22,
    a23);
}

void sub_188695D20(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,long long a21,long long a22,uint64_t a23)
{
  sub_188695D3C(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
    a20,
    a21,
    a22,
    a23);
}

void sub_188695D30(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,long long a21,long long a22,uint64_t a23)
{
  sub_188695D3C(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
    a20,
    a21,
    a22,
    a23);
}

void sub_188695D3C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,long long a21,long long a22,uint64_t a23)
{
  if (v24 == 1)
  {
    __cxa_begin_catch(v23);
    a23 = 0;
    a21 = 0u;
    a22 = 0u;
    kdu_error::kdu_error((kdu_error *)&a21, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(a21 + 16))(&a21, "Malformed MCC marker segment encountered.  Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a21);
  }
  JUMPOUT(0x188695CC4);
}

void sub_188695DA4()
{
}

void sub_188695DAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188695DB8()
{
}

void sub_188695DC8(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x188695CC4);
}

uint64_t mcc_params::write_marker_segment(mcc_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  uint64_t v4 = 0;
  if (!a4 && *((int *)this + 6) <= 255)
  {
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0) {
      return 0;
    }
    *(void *)unsigned int v51 = 0;
    int v8 = 1;
    if (kdu_params::get(this, "Mstage_inputs", 0, 0, &v51[1], 0, 0, 1))
    {
      int v9 = 0;
      int v10 = 0;
      do
      {
        if (!kdu_params::get(this, "Mstage_inputs", v9, 1, v51, 0, 0, 1)) {
          break;
        }
        int v10 = v10 + v51[0] - v51[1] + 1;
        if (v51[0] > 255 || v51[1] > 255) {
          int v8 = 2;
        }
        ++v9;
      }
      while ((kdu_params::get(this, "Mstage_inputs", v9, 0, &v51[1], 0, 0, 1) & 1) != 0);
    }
    else
    {
      int v10 = 0;
    }
    if (kdu_params::get(this, "Mstage_outputs", 0, 0, &v51[1], 0, 0, 1))
    {
      int v12 = 0;
      int v13 = 0;
      do
      {
        if (!kdu_params::get(this, "Mstage_outputs", v12, 1, v51, 0, 0, 1)) {
          break;
        }
        int v13 = v13 + v51[0] - v51[1] + 1;
        if (v51[0] > 255 || v51[1] > 255) {
          int v8 = 2;
        }
        ++v12;
      }
      while ((kdu_params::get(this, "Mstage_outputs", v12, 0, &v51[1], 0, 0, 1) & 1) != 0);
    }
    else
    {
      int v13 = 0;
    }
    uint64_t v4 = (v8 * (v13 + v10) + 11);
    int v50 = 0;
    int v15 = 0;
    if (kdu_params::get(this, "Mstage_xforms", 0, 0, &v50, 0, 0, 1))
    {
      do
      {
        if (v50 == 3) {
          int v16 = 12;
        }
        else {
          int v16 = 8;
        }
        uint64_t v4 = (v16 + v4);
        ++v15;
      }
      while ((kdu_params::get(this, "Mstage_xforms", v15, 0, &v50, 0, 0, 1) & 1) != 0);
    }
    if ((int)v4 >= 65538)
    {
      uint64_t v49 = 0;
      *(_OWORD *)int v47 = 0u;
      long long v48 = 0u;
      kdu_error::kdu_error((kdu_error *)v47, "Kakadu Core Error:\n");
      (*(void (**)(int *, const char *))(*(void *)v47 + 16))(v47, "Unable to write MCC (Multi-component transform Component Collection) marker segment, since the amount of information is too large to fit within a single marker segment.  The codestream syntax for this Part-2 marker segment allows the information to be split across multiple marker segments, but this feature is not yet implemented in Kakadu -- it is a rare application indeed that should need this.");
      kdu_error::~kdu_error((kdu_error *)v47);
    }
    if (v15)
    {
      if (a2)
      {
        kdu_output::put(a2, 255);
        kdu_output::put(a2, 117);
        unsigned int v37 = v4;
        kdu_output::put(a2, (unsigned __int16)(v4 - 2) >> 8);
        kdu_output::put(a2, v4 - 2);
        kdu_output::put(a2, 0);
        kdu_output::put(a2, 0);
        int v17 = kdu_output::put(a2, *((unsigned char *)this + 24));
        kdu_output::put(a2, 0);
        kdu_output::put(a2, 0);
        kdu_output::put(a2, SBYTE1(v15));
        kdu_output::put(a2, v15);
        int v18 = 0;
        int v19 = 0;
        int v20 = 0;
        int v46 = -1;
        v47[0] = 0;
        int v21 = v17 + 10;
        int v44 = -1;
        int v45 = 0;
        int v43 = 0;
        __int16 v39 = ((_WORD)v8 << 15) + 0x8000;
        unsigned int v40 = 0;
        *(void *)long long v41 = 0;
        *(void *)uint64_t v42 = 0;
        int v38 = v15;
        do
        {
          kdu_params::get(this, "Mstage_collections", v20, 0, &v43, 1, 1, 1);
          kdu_params::get(this, "Mstage_collections", v20, 1, (int *)&v42[4], 1, 1, 1);
          kdu_params::get(this, "Mstage_xforms", v20, 0, &v50, 1, 1, 1);
          kdu_params::get(this, "Mstage_xforms", v20, 1, (int *)v42, 1, 1, 1);
          kdu_params::get(this, "Mstage_xforms", v20, 2, (int *)&v41[4], 1, 1, 1);
          kdu_params::get(this, "Mstage_xforms", v20, 3, (int *)v41, 1, 1, 1);
          kdu_params::get(this, "Mstage_xforms", v20, 4, (int *)&v40, 1, 1, 1);
          int v22 = kdu_output::put(a2, v50);
          char v23 = v43;
          kdu_output::put(a2, (unsigned __int16)(v43 + v39) >> 8);
          kdu_output::put(a2, v23);
          int v24 = v21 + v22 + 2;
          if (v43 >= 1)
          {
            int v25 = 0;
            int v26 = v47[0];
            do
            {
              if (v26 > v46)
              {
                kdu_params::get(this, "Mstage_inputs", v19, 0, v47, 1, 1, 1);
                kdu_params::get(this, "Mstage_inputs", v19++, 1, &v46, 1, 1, 1);
              }
              char v27 = v47[0];
              if (v8 == 1)
              {
                int v28 = kdu_output::put(a2, v47[0]);
              }
              else
              {
                kdu_output::put(a2, SBYTE1(v47[0]));
                kdu_output::put(a2, v27);
                int v28 = 2;
              }
              v24 += v28;
              int v26 = ++v47[0];
              ++v25;
            }
            while (v25 < v43);
          }
          char v29 = v42[4];
          kdu_output::put(a2, (unsigned __int16)(*(_WORD *)&v42[4] + v39) >> 8);
          kdu_output::put(a2, v29);
          int v30 = v24 + 2;
          if (*(int *)&v42[4] >= 1)
          {
            int v31 = 0;
            int v32 = v45;
            do
            {
              if (v32 > v44)
              {
                kdu_params::get(this, "Mstage_outputs", v18, 0, &v45, 1, 1, 1);
                kdu_params::get(this, "Mstage_outputs", v18++, 1, &v44, 1, 1, 1);
              }
              char v33 = v45;
              if (v8 == 1)
              {
                int v34 = kdu_output::put(a2, v45);
              }
              else
              {
                kdu_output::put(a2, SBYTE1(v45));
                kdu_output::put(a2, v33);
                int v34 = 2;
              }
              v30 += v34;
              int v32 = ++v45;
              ++v31;
            }
            while (v31 < *(int *)&v42[4]);
          }
          int v35 = kdu_output::put(a2, v41[0]) + v30;
          int v36 = kdu_output::put(a2, v41[4]);
          int v21 = v35 + v36 + kdu_output::put(a2, v42[0]);
          if (v50 == 3) {
            v21 += kdu_output::put(a2, v40);
          }
          ++v20;
        }
        while (v20 != v38);
        uint64_t v4 = v37;
        if (v37 != v21) {
          mcc_params::write_marker_segment();
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return v4;
}

void sub_188696500(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18869650C()
{
  _Unwind_Resume(v0);
}

void mco_params::mco_params(mco_params *this)
{
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18898D540;
  *((unsigned char *)this + 38) = 1;
  *(_DWORD *)((char *)this + 39) = 0;
  *((void *)this + 6) = this;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 9) = this;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = this;
  *((_WORD *)this + 18) = 1;
  *((unsigned char *)this + 104) = 0;
  *((void *)this + 14) = 0;
  *(void *)this = &unk_1ED4DEA78;
  *((void *)this + 1) = "MCO";
}

void sub_1886965E0(_Unwind_Exception *a1)
{
  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t mco_params::copy_with_xforms(mco_params *this, kdu_params *a2, int *a3)
{
  int v23 = 0;
  int v22 = 0;
  uint64_t result = kdu_params::get(a2, "Mnum_stages", 0, 0, &v23, 1, 1, 1);
  if (result)
  {
    int v20 = 1;
    int v21 = 1;
    int v7 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
    int v8 = (kdu_params *)kdu_params::access_cluster(a2, "SIZ");
    if (v7) {
      kdu_params::get(v7, "Scomponents", 0, 0, &v20, 1, 1, 1);
    }
    if (v8) {
      kdu_params::get(v8, "Scomponents", 0, 0, &v21, 1, 1, 1);
    }
    if ((int)a3 <= 0 && v20 == v21)
    {
      int v9 = 0;
    }
    else
    {
      uint64_t v10 = kdu_params::access_relation(this, *((_DWORD *)this + 4), -1, 0, 0);
      if (!v10) {
        mco_params::copy_with_xforms();
      }
      int v11 = (kdu_params *)v10;
      for (uint64_t i = 1; ; uint64_t i = (i + 1))
      {
        v18[0] = 0;
        int v13 = v11;
        while (*((_DWORD *)v13 + 6) != i)
        {
          int v13 = (kdu_params *)*((void *)v13 + 11);
          if (!v13) {
            goto LABEL_17;
          }
        }
        if (!kdu_params::get(v13, "Mstage_inputs", 0, 0, v18, 1, 1, 1)) {
          break;
        }
      }
LABEL_17:
      if (i >= 0x100)
      {
        uint64_t v19 = 0;
        memset(v18, 0, sizeof(v18));
        kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(void *)v18 + 16))(v18, "Unable to modify the existing multi-component transform to work with a reduced number of codestream image components during transcoding.  Cannot create a taylored null transform to interface the components, since all allowed MCC marker segment instance indices have been used up already.");
        kdu_error::~kdu_error((kdu_error *)v18);
      }
      kdu_params::set(this, "Mstages", 0, 0, (int *)i);
      unint64_t v14 = (kdu_params *)kdu_params::access_relation(v11, *((_DWORD *)this + 4), -1, i, 0);
      kdu_params::set(v14, "Mstage_inputs", 0, 0, 0);
      kdu_params::set(v14, "Mstage_inputs", 0, 1, (int *)(v20 - 1));
      kdu_params::set(v14, "Mstage_outputs", 0, 0, a3);
      kdu_params::set(v14, "Mstage_outputs", 0, 1, (int *)(a3 - 1 + v20));
      if ((int)a3 >= 1)
      {
        kdu_params::set(v14, "Mstage_outputs", 1, 0, 0);
        kdu_params::set(v14, "Mstage_outputs", 1, 1, (int *)(a3 - 1));
      }
      int v15 = (int *)v20;
      int v16 = (int *)(v20 + a3);
      if ((int)v16 < v21)
      {
        kdu_params::set(v14, "Mstage_outputs", 2, 0, v16);
        kdu_params::set(v14, "Mstage_outputs", 2, 1, (int *)(v21 - 1));
        int v15 = (int *)v20;
      }
      kdu_params::set(v14, "Mstage_collections", 0, 0, v15);
      int v9 = 1;
      kdu_params::set(v14, "Mstage_collections", 0, 1, (int *)v21);
      kdu_params::set(v14, "Mstage_xforms", 0, 0, (int *)1);
      kdu_params::set(v14, "Mstage_xforms", 0, 1, 0);
      kdu_params::set(v14, "Mstage_xforms", 0, 2, 0);
      kdu_params::set(v14, "Mstage_xforms", 0, 3, 0);
      kdu_params::set(v14, "Mstage_xforms", 0, 4, 0);
    }
    uint64_t result = (uint64_t)kdu_params::set(this, "Mnum_stages", 0, 0, (int *)(v23 + v9));
    if (v23 >= 1)
    {
      for (int j = 0; j < v23; ++j)
      {
        uint64_t result = kdu_params::get(a2, "Mstages", j, 0, &v22, 1, 1, 1);
        if (!result) {
          break;
        }
        uint64_t result = (uint64_t)kdu_params::set(this, "Mstages", v9 + j, 0, (int *)v22);
      }
    }
  }
  return result;
}

void sub_188696A6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188696A78()
{
  _Unwind_Resume(v0);
}

BOOL mco_params::check_marker_segment(mco_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  *a5 = -1;
  return a2 == 65399;
}

uint64_t mco_params::finalize(uint64_t this, char a2)
{
  if ((a2 & 1) == 0)
  {
    int v2 = (kdu_params *)this;
    int v9 = 0;
    int v3 = (kdu_params *)kdu_params::access_cluster((kdu_params *)this, "SIZ");
    if (v3) {
      kdu_params::get(v3, "Mcomponents", 0, 0, &v9, 1, 1, 1);
    }
    int v8 = 0;
    this = kdu_params::get(v2, "Mnum_stages", 0, 0, &v8, 1, 1, 1);
    if (this)
    {
      if (!v9)
      {
        uint64_t v7 = 0;
        long long v5 = 0u;
        long long v6 = 0u;
        kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
        kdu_error::~kdu_error((kdu_error *)&v5);
      }
    }
    else if (v9 >= 1)
    {
      int v8 = 0;
      this = (uint64_t)kdu_params::set(v2, "Mnum_stages", 0, 0, 0);
    }
    int v4 = 0;
    if (v8 >= 1)
    {
      this = kdu_params::get(v2, "Mstages", v8 - 1, 0, &v4, 1, 1, 1);
      if ((this & 1) == 0)
      {
        uint64_t v7 = 0;
        long long v5 = 0u;
        long long v6 = 0u;
        kdu_error::kdu_error((kdu_error *)&v5, "Kakadu Core Error:\n");
        kdu_error::~kdu_error((kdu_error *)&v5);
      }
    }
  }
  return this;
}

void sub_188696C4C(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188696C58(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

BOOL mco_params::read_marker_segment(mco_params *this, unsigned __int16 a2, int a3, unsigned __int8 *a4, int a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!a5)
  {
    if (a3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = a4;
      __cxa_throw(exception, MEMORY[0x1E4FBA318], 0);
    }
    int v9 = *a4;
    kdu_params::set(this, "Mnum_stages", 0, 0, (int *)*a4);
    uint64_t v10 = a4 + 1;
    if (v9)
    {
      uint64_t v11 = 0;
      uint64_t v12 = a3 - 1;
      do
      {
        if (v12 <= 0)
        {
          unint64_t v14 = __cxa_allocate_exception(8uLL);
          void *v14 = &v10[v11];
          __cxa_throw(v14, MEMORY[0x1E4FBA318], 0);
        }
        kdu_params::set(this, "Mstages", v11, 0, (int *)v10[v11]);
        ++v11;
        --v12;
      }
      while (v9 != v11);
      v10 += v11;
    }
    if (v10 != &a4[a3])
    {
      uint64_t v17 = 0;
      memset(v16, 0, sizeof(v16));
      kdu_error::kdu_error((kdu_error *)v16, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v16[0] + 16))(v16, "Malformed MCO marker segment encountered. The final ");
      long long v21 = 0u;
      long long v22 = 0u;
      long long v19 = 0u;
      long long v20 = 0u;
      *(_OWORD *)int v18 = 0u;
      if (BYTE8(v16[0])) {
        sprintf(v18, "%x");
      }
      else {
        sprintf(v18, "%d");
      }
      (*(void (**)(_OWORD *, char *))(*(void *)&v16[0] + 16))(v16, v18);
      (*(void (**)(_OWORD *, const char *))(*(void *)&v16[0] + 16))(v16, " bytes were not consumed!");
      kdu_error::~kdu_error((kdu_error *)v16);
    }
  }
  return a5 == 0;
}

void sub_188696EB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11, long long a12, uint64_t a13)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    a13 = 0;
    a11 = 0u;
    a12 = 0u;
    kdu_error::kdu_error((kdu_error *)&a11, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(a11 + 16))(&a11, "Malformed MCO marker segment encountered. Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mco_params::write_marker_segment(mco_params *this, kdu_output *a2, kdu_params *a3)
{
  if (*((_DWORD *)this + 6) || (*((_DWORD *)this + 5) & 0x80000000) == 0) {
    return 0;
  }
  *(void *)int v18 = 0;
  uint64_t v4 = 0;
  if (!kdu_params::get(this, "Mnum_stages", 0, 0, (int *)v18, 0, 1, 1)) {
    return v4;
  }
  int v8 = *(_DWORD *)v18;
  if (*(int *)v18 >= 256)
  {
    uint64_t v17 = 0;
    memset(v16, 0, sizeof(v16));
    kdu_error::kdu_error((kdu_error *)v16, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)v16);
  }
  if (a3)
  {
    v16[0] = 0;
    int v9 = kdu_params::get(a3, "Mnum_stages", 0, 0, v16, 1, 1, 1);
    int v10 = *(_DWORD *)v18;
    if (v9 && v16[0] == v8)
    {
      if (*(int *)v18 < 1)
      {
        int v11 = 0;
      }
      else
      {
        int v11 = 0;
        do
        {
          if ((kdu_params::get(this, "Mstages", v11, 0, (int *)&v18[4], 1, 1, 1) & 1) == 0) {
            mco_params::write_marker_segment();
          }
          int v12 = *(_DWORD *)&v18[4];
          v16[0] = 0;
          int v13 = kdu_params::get(a3, "Mstages", v11, 0, v16, 1, 1, 1);
          int v10 = *(_DWORD *)v18;
          if (!v13) {
            break;
          }
          if (v16[0] != v12) {
            break;
          }
          ++v11;
        }
        while (v11 < *(int *)v18);
      }
      int v8 = v10;
      if (v11 == v10) {
        return 0;
      }
    }
    else
    {
      int v8 = *(_DWORD *)v18;
    }
  }
  uint64_t v4 = (v8 + 5);
  if (a2)
  {
    kdu_output::put(a2, 255);
    kdu_output::put(a2, 119);
    kdu_output::put(a2, (unsigned __int16)(v8 + 3) >> 8);
    kdu_output::put(a2, v8 + 3);
    int v14 = kdu_output::put(a2, v18[0]) + 4;
    if (*(int *)v18 >= 1)
    {
      int v15 = 0;
      do
      {
        kdu_params::get(this, "Mstages", v15, 0, (int *)&v18[4], 1, 1, 1);
        v14 += kdu_output::put(a2, v18[4]);
        ++v15;
      }
      while (v15 < *(int *)v18);
    }
    if (v4 != v14) {
      mco_params::write_marker_segment();
    }
  }
  return v4;
}

void sub_188697214(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_188697220()
{
  _Unwind_Resume(v0);
}

void atk_params::atk_params(atk_params *this)
{
  *((void *)this + 1) = "ATK";
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18898D540;
  *((_WORD *)this + 20) = 1;
  *((unsigned char *)this + 42) = 1;
  *((void *)this + 6) = this;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 9) = this;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = this;
  *((unsigned char *)this + 104) = 0;
  *((_DWORD *)this + 9) = 65537;
  *((void *)this + 14) = 0;
  *(void *)this = &unk_1ED4DE688;
}

void sub_188697368(_Unwind_Exception *a1)
{
  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t atk_params::copy_with_xforms(atk_params *this, kdu_params *a2, int a3, int a4, BOOL a5, int a6, int a7)
{
  *(_WORD *)int v24 = 0;
  uint64_t result = kdu_params::get(a2, "Kreversible", 0, 0, &v24[1], 1, 1, 1);
  if (result)
  {
    if ((kdu_params::get(a2, "Ksymmetric", 0, 0, v24, 1, 1, 1) & 1) != 0
      || ((*(void (**)(kdu_params *, void))(*(void *)a2 + 72))(a2, 0),
          uint64_t result = kdu_params::get(a2, "Ksymmetric", 0, 0, v24, 1, 1, 1),
          result))
    {
      kdu_params::set((uint64_t)this, "Kreversible", 0, 0, v24[1]);
      kdu_params::set((uint64_t)this, "Ksymmetric", 0, 0, v24[0]);
      int v23 = 0;
      if (kdu_params::get(a2, "Kextension", 0, 0, &v23, 1, 1, 1)) {
        kdu_params::set(this, "Kextension", 0, 0, (int *)v23);
      }
      if (v24[0]) {
        int v12 = 0;
      }
      else {
        int v12 = a6 | a7;
      }
      if (a6 != a7 && v12)
      {
        uint64_t v22 = 0;
        memset(v21, 0, sizeof(v21));
        kdu_error::kdu_error((kdu_error *)v21, "Kakadu Core Error:\n");
        (*(void (**)(_OWORD *, const char *))(*(void *)&v21[0] + 16))(v21, "Cannot transpose ATK marker segment information to a new codestream which has flippped geometry unless the transform filters are whole-sample symmetric, or flipping is to be applied in both the vertical and horizontal directions.  The reason for this is that the same transform kernels must be used in both directions, only one of which requires reversal of the lifting coefficients.");
        kdu_error::~kdu_error((kdu_error *)v21);
      }
      LODWORD(v21[0]) = 0;
      *(void *)long long v19 = 0;
      *(void *)long long v20 = 0;
      uint64_t result = kdu_params::get(a2, "Ksteps", 0, 0, &v20[1], 0, 0, 1);
      if (result)
      {
        int v13 = 0;
        int v14 = 0;
        do
        {
          uint64_t result = kdu_params::get(a2, "Ksteps", v14, 1, v20, 0, 0, 1);
          if (!result) {
            break;
          }
          uint64_t result = kdu_params::get(a2, "Ksteps", v14, 2, &v19[1], 0, 0, 1);
          if (!result) {
            break;
          }
          uint64_t result = kdu_params::get(a2, "Ksteps", v14, 3, v19, 0, 0, 1);
          if (!result) {
            break;
          }
          if (v12) {
            v20[0] = (~(2 * v14) & 2) - (v20[0] + v20[1]);
          }
          kdu_params::set(this, "Ksteps", v14, 0, (int *)v20[1]);
          kdu_params::set(this, "Ksteps", v14, 1, (int *)v20[0]);
          kdu_params::set(this, "Ksteps", v14, 2, (int *)v19[1]);
          kdu_params::set(this, "Ksteps", v14, 3, (int *)v19[0]);
          int v15 = v20[1];
          if (v20[1] >= 1)
          {
            int v16 = 0;
            int v17 = -1;
            do
            {
              kdu_params::get(a2, "Kcoeffs", v13 + v16, 0, (float *)v21, 1, 1, 1);
              if (v12) {
                int v18 = v13 + v17 + v20[1];
              }
              else {
                int v18 = v13 + v16;
              }
              kdu_params::set((uint64_t)this, "Kcoeffs", v18, 0, *(float *)v21);
              ++v16;
              int v15 = v20[1];
              --v17;
            }
            while (v16 < v20[1]);
          }
          ++v14;
          v13 += v15;
          uint64_t result = kdu_params::get(a2, "Ksteps", v14, 0, &v20[1], 0, 0, 1);
        }
        while ((result & 1) != 0);
      }
    }
  }
  return result;
}

void sub_18869776C(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188697778()
{
  _Unwind_Resume(v0);
}

uint64_t atk_params::finalize(atk_params *this)
{
  *(void *)int v25 = 0;
  *(void *)int v26 = 0;
  float v24 = 0.0;
  BOOL v23 = 0;
  if (kdu_params::get(this, "Kreversible", 0, 0, &v23, 1, 1, 1))
  {
    BOOL v3 = 1;
    if (kdu_params::get(this, "Ksteps", 0, 0, &v26[1], 1, 1, 1))
    {
      int v4 = 0;
      int v5 = 0;
      double v6 = 1.0;
      double v7 = 1.0;
      do
      {
        double v8 = v7;
        if (!kdu_params::get(this, "Ksteps", v5, 1, v26, 1, 1, 1)
          || !kdu_params::get(this, "Ksteps", v5, 2, &v25[1], 1, 1, 1)
          || (kdu_params::get(this, "Ksteps", v5, 3, v25, 1, 1, 1) & 1) == 0)
        {
          uint64_t v22 = 0;
          long long v20 = 0u;
          long long v21 = 0u;
          kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v20);
        }
        if (v25[1] >= 0x19u)
        {
          uint64_t v22 = 0;
          long long v20 = 0u;
          long long v21 = 0u;
          kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v20);
        }
        if (!v23 && (v25[1] > 0 || v25[0] >= 1))
        {
          uint64_t v22 = 0;
          long long v20 = 0u;
          long long v21 = 0u;
          kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v20);
        }
        int v9 = v26[1];
        if ((v26[1] & 1) != 0 || v26[0] + (((v5 & 1) + v26[1] - 1) >> 1)) {
          BOOL v3 = 0;
        }
        if (v26[1] < 1)
        {
          double v11 = 0.0;
        }
        else
        {
          int v10 = 0;
          double v11 = 0.0;
          int v12 = -1;
          do
          {
            if ((kdu_params::get(this, "Kcoeffs", v4 + v10, 0, &v24, 1, 1, 1) & 1) == 0)
            {
              uint64_t v22 = 0;
              long long v20 = 0u;
              long long v21 = 0u;
              kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
              kdu_error::~kdu_error((kdu_error *)&v20);
            }
            float v13 = v24;
            int v9 = v26[1];
            if (v3)
            {
              if (v10 >= v26[1] >> 1)
              {
                BOOL v3 = 1;
              }
              else
              {
                LODWORD(v20) = 0;
                BOOL v3 = kdu_params::get(this, "Kcoeffs", v4 + v12 + v26[1], 0, (float *)&v20, 1, 1, 1)
                  && v24 == *(float *)&v20;
                int v9 = v26[1];
              }
            }
            else
            {
              BOOL v3 = 0;
            }
            double v11 = v11 + v13;
            ++v10;
            --v12;
          }
          while (v10 < v9);
        }
        double v7 = v6 + v11 * v8;
        ++v5;
        v4 += v9;
        double v6 = v8;
      }
      while ((kdu_params::get(this, "Ksteps", v5, 0, &v26[1], 1, 1, 1) & 1) != 0);
      int v14 = v5 & 1;
    }
    else
    {
      int v14 = 0;
      int v4 = 0;
      double v7 = 1.0;
      double v8 = 1.0;
    }
    if (kdu_params::get(this, "Kcoeffs", v4, 0, &v24, 1, 1, 1))
    {
      uint64_t v22 = 0;
      long long v20 = 0u;
      long long v21 = 0u;
      kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v20);
    }
    if (v23)
    {
      double v15 = v14 ? v8 : v7;
      if (v15 > 1.001 || v15 < 0.999)
      {
        uint64_t v22 = 0;
        long long v20 = 0u;
        long long v21 = 0u;
        kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
        kdu_error::~kdu_error((kdu_error *)&v20);
      }
    }
    int v19 = 0;
    if ((kdu_params::get(this, "Kextension", 0, 0, &v19, 1, 1, 1) & 1) == 0)
    {
      int v19 = v3;
      kdu_params::set(this, "Kextension", 0, 0, (int *)v3);
    }
    int v16 = v19 == 1 && v3;
    BOOL v18 = 0;
    uint64_t result = kdu_params::get(this, "Ksymmetric", 0, 0, &v18, 0, 1, 1);
    if (result)
    {
      if (v18) {
        char v17 = v16;
      }
      else {
        char v17 = 1;
      }
      if ((v17 & 1) == 0)
      {
        uint64_t v22 = 0;
        long long v20 = 0u;
        long long v21 = 0u;
        kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
        kdu_error::~kdu_error((kdu_error *)&v20);
      }
    }
    else
    {
      return kdu_params::set((uint64_t)this, "Ksymmetric", 0, 0, v16);
    }
  }
  else if ((kdu_params::get(this, "Ksteps", 0, 0, &v26[1], 1, 1, 1) & 1) != 0 {
         || (uint64_t result = kdu_params::get(this, "Kcoeffs", 0, 0, &v24, 1, 1, 1), result))
  }
  {
    uint64_t v22 = 0;
    long long v20 = 0u;
    long long v21 = 0u;
    kdu_error::kdu_error((kdu_error *)&v20, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)&v20);
  }
  return result;
}

void sub_188697E78(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188697E84(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

BOOL atk_params::check_marker_segment(atk_params *this, int a2, int a3, unsigned __int8 *a4, unsigned int *a5)
{
  if (a2 != 65401 || a3 < 2) {
    return 0;
  }
  unsigned int v6 = a4[1];
  BOOL result = v6 > 1;
  *a5 = v6;
  return result;
}

uint64_t atk_params::read_marker_segment(atk_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  if (a5) {
    return 0;
  }
  uint64_t result = 0;
  if (a2 == 65401 && a3 >= 2)
  {
    if (*((_DWORD *)this + 6) != a4[1]) {
      return 0;
    }
    unsigned int v9 = *a4;
    if ((v9 & 8) != 0 && ((v9 >> 6) & 1) == 0)
    {
      *(void *)&long long v67 = 0;
      long long v65 = 0u;
      long long v66 = 0u;
      kdu_error::kdu_error((kdu_error *)&v65, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v65 + 16))(&v65, "Malformed ATK marker segment encountered.  Transform kernels identified as whole-sample symmetric must also use the symmetric boundary extension method.");
      kdu_error::~kdu_error((kdu_error *)&v65);
    }
    unsigned int v10 = v9 & 3;
    if ((v9 & 0x10) != 0 && v10 >= 2)
    {
      *(void *)&long long v67 = 0;
      long long v65 = 0u;
      long long v66 = 0u;
      kdu_error::kdu_error((kdu_error *)&v65, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v65 + 16))(&v65, "Cannot process ATK marker segment describing a reversible transform kernel with floating-point coefficient values.");
      kdu_error::~kdu_error((kdu_error *)&v65);
    }
    kdu_params::set((uint64_t)this, "Kreversible", 0, 0, (v9 >> 4) & 1);
    kdu_params::set((uint64_t)this, "Ksymmetric", 0, 0, (v9 & 8) != 0);
    kdu_params::set(this, "Kextension", 0, 0, (int *)((v9 >> 6) & 1));
    uint64_t v11 = 1 << v10;
    if ((v9 >> 4)) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = v11;
    }
    float v13 = &a4[v12 + 2];
    int v62 = &a4[a3];
    if (a3 - (v12 + 2) <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = v13;
      __cxa_throw(exception, MEMORY[0x1E4FBA318], 0);
    }
    int v16 = *v13;
    double v15 = v13 + 1;
    int v14 = v16;
    int v17 = v16 - 1;
    BOOL v18 = ((v9 >> 5) & 1) == 0;
    int v19 = ((v16 - 1) & 1) != v18;
    if (((v16 - 1) & 1) == v18) {
      int v14 = v17;
    }
    int v56 = v19;
    if (v14 >= v19)
    {
      int v55 = v9 & 3;
      int v61 = 0;
      uint64_t v60 = (v9 & 8) >> 3;
      int v20 = v14;
      long long v21 = v15;
      do
      {
        if ((v9 & 8) == 0)
        {
          if (v62 - v21 <= 0)
          {
            unsigned int v51 = __cxa_allocate_exception(8uLL);
            void *v51 = v21;
            __cxa_throw(v51, MEMORY[0x1E4FBA318], 0);
          }
          int v22 = *v21++;
          HIDWORD(v60) = v22 - ((2 * v22) & 0x100);
        }
        if ((v9 & 0x10) != 0)
        {
          if (v62 - v21 <= 0)
          {
            unsigned int v52 = __cxa_allocate_exception(8uLL);
            void *v52 = v21;
            __cxa_throw(v52, MEMORY[0x1E4FBA318], 0);
          }
          BOOL v23 = v21 + 1;
          float v24 = (int *)*v21;
          if (v55 == 3) {
            __assert_rtn("kdu_read", "kdu_utils.h", 74, "nbytes <= 4");
          }
          if (v62 - v23 < v11)
          {
            int v53 = __cxa_allocate_exception(8uLL);
            *int v53 = v23;
            __cxa_throw(v53, MEMORY[0x1E4FBA318], 0);
          }
          int v25 = v21[1];
          if ((v9 & 3) != 0)
          {
            int v26 = v21[2] | (v25 << 8);
            if (v55 == 1)
            {
              v21 += 3;
              int v27 = v26 - ((v25 << 9) & 0x10000);
            }
            else
            {
              int v28 = (v21[3] << 8) | (v26 << 16);
              int v29 = v21[4];
              v21 += 5;
              int v27 = v28 | v29;
            }
            unsigned int v57 = v27;
          }
          else
          {
            v21 += 2;
            unsigned int v57 = v25 - ((2 * v25) & 0x100);
          }
        }
        else
        {
          float v24 = 0;
          unsigned int v57 = 0;
        }
        if (v62 - v21 <= 0)
        {
          int v50 = __cxa_allocate_exception(8uLL);
          void *v50 = v21;
          __cxa_throw(v50, MEMORY[0x1E4FBA318], 0);
        }
        int v30 = v21 + 1;
        unint64_t v31 = *v21;
        long long v59 = v30;
        if ((v9 & 8) != 0)
        {
          unint64_t v31 = (2 * v31);
          HIDWORD(v60) = -((int)((v31 & 0xFFFFFFFE | v20 & 1) - 1) >> 1);
        }
        kdu_params::set(this, "Ksteps", v20, 0, (int *)v31);
        kdu_params::set(this, "Ksteps", v20, 1, (int *)HIDWORD(v60));
        kdu_params::set(this, "Ksteps", v20, 2, v24);
        kdu_params::set(this, "Ksteps", v20, 3, (int *)v57);
        int v58 = v20;
        unsigned int v32 = v31 >> v60;
        if (v32)
        {
          int v33 = 0;
          float v34 = (float)(1 << (char)v24);
          unsigned int v35 = v32 + v61;
          double v15 = v59;
          do
          {
            switch((int)v11)
            {
              case 1:
                if (v62 - v15 <= 0) {
                  goto LABEL_78;
                }
                int v36 = *v15++;
                int v37 = v36 - ((2 * v36) & 0x100);
                goto LABEL_56;
              case 2:
                if (v62 - v15 < 2) {
                  goto LABEL_78;
                }
                int v43 = *v15;
                int v44 = v15[1];
                v15 += 2;
                int v37 = (v44 | (v43 << 8)) - ((v43 << 9) & 0x10000);
LABEL_56:
                float v40 = (float)v37;
                if ((v9 & 0x10) != 0) {
                  float v40 = v40 / v34;
                }
                break;
              case 4:
                if (v62 - v15 < 4) {
                  goto LABEL_78;
                }
                LODWORD(v65) = 0;
                for (uint64_t i = 3; i != -1; --i)
                {
                  char v39 = *v15++;
                  *((unsigned char *)&v65 + i) = v39;
                }
                if ((v9 & 0x10) != 0) {
                  __assert_rtn("read_marker_segment", "params.cpp", 5552, "!reversible");
                }
                float v40 = *(float *)&v65;
                break;
              case 8:
                if (v62 - v15 < 8)
                {
LABEL_78:
                  uint64_t v49 = __cxa_allocate_exception(8uLL);
                  *uint64_t v49 = v15;
                  __cxa_throw(v49, MEMORY[0x1E4FBA318], 0);
                }
                *(void *)&long long v65 = 0;
                for (uint64_t j = 7; j != -1; --j)
                {
                  char v42 = *v15++;
                  *((unsigned char *)&v65 + j) = v42;
                }
                if ((v9 & 0x10) != 0) {
                  __assert_rtn("read_marker_segment", "params.cpp", 5556, "!reversible");
                }
                float v40 = *(double *)&v65;
                break;
              default:
                __assert_rtn("read_marker_segment", "params.cpp", 5558, "0");
            }
            double v45 = v40;
            kdu_params::set((uint64_t)this, "Kcoeffs", v35 + ~v33, 0, v40);
            if ((v9 & 8) != 0) {
              kdu_params::set((uint64_t)this, "Kcoeffs", v33 + v35, 0, v45);
            }
            ++v33;
          }
          while (v33 != v32);
        }
        else
        {
          double v15 = v59;
        }
        v61 += v32 << ((v9 & 8) >> 3);
        int v14 = v58 - 1;
        long long v21 = v15;
        int v20 = v58 - 1;
      }
      while (v58 > v56);
    }
    else
    {
      int v61 = 0;
    }
    if (!v14)
    {
      kdu_params::set(this, "Ksteps", 0, 0, 0);
      kdu_params::set(this, "Ksteps", 0, 1, 0);
      kdu_params::set(this, "Ksteps", 0, 2, 0);
      kdu_params::set(this, "Ksteps", 0, 3, 0);
    }
    if (v15 != v62)
    {
      uint64_t v64 = 0;
      memset(v63, 0, sizeof(v63));
      kdu_error::kdu_error((kdu_error *)v63, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v63[0] + 16))(v63, "Malformed ATK marker segment encountered. The final ");
      long long v68 = 0u;
      long long v69 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      long long v65 = 0u;
      if (BYTE8(v63[0])) {
        sprintf((char *)&v65, "%x");
      }
      else {
        sprintf((char *)&v65, "%d");
      }
      (*(void (**)(_OWORD *, long long *))(*(void *)&v63[0] + 16))(v63, &v65);
      (*(void (**)(_OWORD *, const char *))(*(void *)&v63[0] + 16))(v63, " bytes were not consumed!");
      kdu_error::~kdu_error((kdu_error *)v63);
    }
    if (v61 >= 2)
    {
      int v46 = v61 - 1;
      int v47 = 1;
      do
      {
        LODWORD(v65) = 0;
        LODWORD(v63[0]) = 0;
        kdu_params::get(this, "Kcoeffs", v47 - 1, 0, (float *)&v65, 1, 1, 1);
        kdu_params::get(this, "Kcoeffs", v46, 0, (float *)v63, 1, 1, 1);
        kdu_params::set((uint64_t)this, "Kcoeffs", v47 - 1, 0, *(float *)v63);
        kdu_params::set((uint64_t)this, "Kcoeffs", v46--, 0, *(float *)&v65);
      }
      while (v47++ < v46);
    }
    return 1;
  }
  return result;
}

void sub_188698888(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188698894(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, int a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,long long a24,long long a25,uint64_t a26)
{
  _Unwind_Resume(v26);
}

void sub_1886988DC()
{
}

void sub_188698964()
{
}

void sub_188698970(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18869897C()
{
}

void sub_18869898C(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x1886988D4);
}

uint64_t atk_params::write_marker_segment(atk_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  int v4 = *((_DWORD *)this + 6);
  if (v4 < 2) {
    return 0;
  }
  uint64_t v5 = 0;
  if (!a4 && v4 <= 0xFF)
  {
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0) {
      return 0;
    }
    *(_WORD *)int v63 = 0;
    int v62 = 0;
    if (!kdu_params::get(this, "Kreversible", 0, 0, &v63[1], 1, 1, 1)
      || !kdu_params::get(this, "Ksymmetric", 0, 0, v63, 1, 1, 1)
      || (kdu_params::get(this, "Kextension", 0, 0, &v62, 1, 1, 1) & 1) == 0)
    {
      memset(v61, 0, sizeof(v61));
      kdu_error::kdu_error((kdu_error *)v61, "Kakadu Core Error:\n");
      (*(void (**)(void *, const char *))(v61[0] + 16))(v61, "Unable to write ATK marker segment yet! Some info missing.");
      kdu_error::~kdu_error((kdu_error *)v61);
    }
    *(void *)long long v59 = 0;
    *(void *)uint64_t v60 = 0;
    *(float *)&unsigned int v58 = 0.0;
    if (a3)
    {
      int v10 = v63[1];
      LOBYTE(v61[0]) = 0;
      if (kdu_params::get(a3, "Kreversible", 0, 0, (BOOL *)v61, 1, 1, 1))
      {
        if (LOBYTE(v61[0]) == v10)
        {
          int v11 = v63[0];
          LOBYTE(v61[0]) = 0;
          if (kdu_params::get(a3, "Ksymmetric", 0, 0, (BOOL *)v61, 1, 1, 1))
          {
            if (LOBYTE(v61[0]) == v11)
            {
              int v12 = v62;
              LODWORD(v61[0]) = 0;
              if (kdu_params::get(a3, "Kextension", 0, 0, (int *)v61, 1, 1, 1))
              {
                if (LODWORD(v61[0]) == v12)
                {
                  uint64_t v5 = 0;
                  if (!kdu_params::get(this, "Ksteps", 0, 0, (int *)&v60[4], 1, 1, 1)) {
                    return v5;
                  }
                  int v13 = 0;
                  int v14 = 0;
                  while (kdu_params::get(this, "Ksteps", v13, 1, (int *)v60, 1, 1, 1)
                       && kdu_params::get(this, "Ksteps", v13, 2, (int *)&v59[4], 1, 1, 1)
                       && kdu_params::get(this, "Ksteps", v13, 3, (int *)v59, 1, 1, 1))
                  {
                    int v15 = *(_DWORD *)&v60[4];
                    LODWORD(v61[0]) = 0;
                    if (!kdu_params::get(a3, "Ksteps", v13, 0, (int *)v61, 1, 1, 1)) {
                      goto LABEL_44;
                    }
                    if (LODWORD(v61[0]) != v15) {
                      goto LABEL_44;
                    }
                    int v16 = *(_DWORD *)v60;
                    LODWORD(v61[0]) = 0;
                    if (!kdu_params::get(a3, "Ksteps", v13, 1, (int *)v61, 1, 1, 1)) {
                      goto LABEL_44;
                    }
                    if (LODWORD(v61[0]) != v16) {
                      goto LABEL_44;
                    }
                    int v17 = *(_DWORD *)&v59[4];
                    LODWORD(v61[0]) = 0;
                    if (!kdu_params::get(a3, "Ksteps", v13, 2, (int *)v61, 1, 1, 1)) {
                      goto LABEL_44;
                    }
                    if (LODWORD(v61[0]) != v17) {
                      goto LABEL_44;
                    }
                    int v18 = *(_DWORD *)v59;
                    LODWORD(v61[0]) = 0;
                    if (!kdu_params::get(a3, "Ksteps", v13, 3, (int *)v61, 1, 1, 1)
                      || LODWORD(v61[0]) != v18)
                    {
                      goto LABEL_44;
                    }
                    int v19 = *(_DWORD *)&v60[4];
                    if (*(int *)&v60[4] < 1)
                    {
                      int v20 = 0;
                    }
                    else
                    {
                      int v20 = 0;
                      do
                      {
                        kdu_params::get(this, "Kcoeffs", v14 + v20, 0, (float *)&v58, 1, 1, 1);
                        float v21 = *(float *)&v58;
                        LODWORD(v61[0]) = 0;
                        int v22 = kdu_params::get(a3, "Kcoeffs", v14 + v20, 0, (float *)v61, 1, 1, 1);
                        int v19 = *(_DWORD *)&v60[4];
                        if (v22) {
                          BOOL v23 = *(float *)v61 == v21;
                        }
                        else {
                          BOOL v23 = 0;
                        }
                        if (!v23) {
                          break;
                        }
                        ++v20;
                      }
                      while (v20 < *(int *)&v60[4]);
                    }
                    if (v20 != v19) {
                      goto LABEL_44;
                    }
                    ++v13;
                    v14 += v19;
                    uint64_t v5 = 0;
                    if (!kdu_params::get(this, "Ksteps", v13, 0, (int *)&v60[4], 1, 1, 1)) {
                      return v5;
                    }
                  }
                  return 0;
                }
              }
            }
          }
        }
      }
    }
LABEL_44:
    int v24 = 0;
    int v25 = 0;
    if (kdu_params::get(this, "Ksteps", 0, 0, (int *)&v60[4], 1, 1, 1))
    {
      int v25 = 0;
      int v24 = 0;
      do
      {
        if (!kdu_params::get(this, "Ksteps", v24, 1, (int *)v60, 1, 1, 1)) {
          break;
        }
        if (!kdu_params::get(this, "Ksteps", v24, 2, (int *)&v59[4], 1, 1, 1)) {
          break;
        }
        if (!kdu_params::get(this, "Ksteps", v24, 3, (int *)v59, 1, 1, 1)) {
          break;
        }
        ++v24;
        v25 += *(_DWORD *)&v60[4];
      }
      while ((kdu_params::get(this, "Ksteps", v24, 0, (int *)&v60[4], 1, 1, 1) & 1) != 0);
    }
    if (v63[1]) {
      int v26 = 7;
    }
    else {
      int v26 = 11;
    }
    int v27 = 2 * v24;
    if (v63[1]) {
      char v28 = 1;
    }
    else {
      char v28 = 2;
    }
    if (v63[1]) {
      int v27 = 5 * v24;
    }
    int v29 = (v25 >> v63[0] << v28) + v27;
    if (v63[0]) {
      int v30 = v24;
    }
    else {
      int v30 = 0;
    }
    uint64_t v5 = (v26 - v30 + v29);
    if (a2)
    {
      if (v63[0]) {
        int v31 = *((_DWORD *)this + 6) + 2048;
      }
      else {
        int v31 = *((_DWORD *)this + 6);
      }
      if (v63[1])
      {
        LOWORD(v31) = v31 + 4096;
        __int16 v32 = 256;
      }
      else
      {
        __int16 v32 = 512;
      }
      if (v24) {
        LOWORD(v31) = v31 + 0x2000;
      }
      if (v62 == 1) {
        __int16 v33 = v31 + 0x4000;
      }
      else {
        __int16 v33 = v31;
      }
      __int16 v34 = v33 + v32;
      kdu_output::put(a2, 255);
      kdu_output::put(a2, 121);
      kdu_output::put(a2, (unsigned __int16)(v5 - 2) >> 8);
      kdu_output::put(a2, v5 - 2);
      kdu_output::put(a2, SHIBYTE(v34));
      kdu_output::put(a2, v33);
      unsigned int v57 = v5;
      if (v63[1])
      {
        int v35 = 6;
      }
      else
      {
        if (kdu_params::get(this, "Ksteps", 0, 0, (int *)&v60[4], 1, 1, 1))
        {
          int v36 = 0;
          int v37 = 0;
          double v38 = 1.0;
          double v39 = 1.0;
          do
          {
            double v40 = v39;
            int v41 = *(_DWORD *)&v60[4];
            if (*(int *)&v60[4] < 1)
            {
              double v43 = 0.0;
            }
            else
            {
              int v42 = 0;
              double v43 = 0.0;
              do
              {
                kdu_params::get(this, "Kcoeffs", v36 + v42, 0, (float *)&v58, 1, 1, 1);
                double v43 = v43 + *(float *)&v58;
                ++v42;
                int v41 = *(_DWORD *)&v60[4];
              }
              while (v42 < *(int *)&v60[4]);
            }
            double v39 = v38 + v43 * v40;
            ++v37;
            v36 += v41;
            double v38 = v40;
          }
          while ((kdu_params::get(this, "Ksteps", v37, 0, (int *)&v60[4], 1, 1, 1) & 1) != 0);
          if (v37) {
            double v44 = v40;
          }
          else {
            double v44 = v39;
          }
          *(float *)&int v45 = v44;
          int v46 = v45;
        }
        else
        {
          int v46 = 1065353216;
        }
        kdu_output::put(a2, v46);
        int v35 = 10;
      }
      int v47 = kdu_output::put(a2, v24) + v35;
      if (v24 >= 1)
      {
        do
        {
          kdu_params::get(this, "Ksteps", v24 - 1, 0, (int *)&v60[4], 1, 1, 1);
          kdu_params::get(this, "Ksteps", v24 - 1, 1, (int *)v60, 1, 1, 1);
          kdu_params::get(this, "Ksteps", v24 - 1, 2, (int *)&v59[4], 1, 1, 1);
          kdu_params::get(this, "Ksteps", v24 - 1, 3, (int *)v59, 1, 1, 1);
          if (!v63[0]) {
            v47 += kdu_output::put(a2, v60[0]);
          }
          if (v63[1])
          {
            int v48 = kdu_output::put(a2, v59[4]);
            char v49 = v59[0];
            kdu_output::put(a2, v59[1]);
            kdu_output::put(a2, v49);
            v47 += v48 + 2;
          }
          int v50 = *(_DWORD *)&v60[4];
          if (v63[0])
          {
            int v50 = *(int *)&v60[4] >> 1;
            *(int *)&v60[4] >>= 1;
          }
          int v51 = v25 - v50;
          v47 += kdu_output::put(a2, v50);
          int v52 = *(_DWORD *)&v60[4];
          if (*(int *)&v60[4] >= 1)
          {
            int v53 = 0;
            do
            {
              kdu_params::get(this, "Kcoeffs", v51 + v53, 0, (float *)&v58, 1, 1, 1);
              if (v63[1])
              {
                __int16 v54 = vcvtms_s32_f32((float)(*(float *)&v58 * (float)(1 << v59[4])) + 0.5);
                kdu_output::put(a2, SHIBYTE(v54));
                kdu_output::put(a2, v54);
                int v55 = 2;
              }
              else
              {
                kdu_output::put(a2, v58);
                int v55 = 4;
              }
              v47 += v55;
              ++v53;
              int v52 = *(_DWORD *)&v60[4];
            }
            while (v53 < *(int *)&v60[4]);
          }
          if (!v63[0]) {
            int v52 = 0;
          }
          int v25 = v51 - v52;
        }
        while (v24-- > 1);
      }
      BOOL v23 = v57 == v47;
      uint64_t v5 = v57;
      if (!v23) {
        atk_params::write_marker_segment();
      }
    }
  }
  return v5;
}

void sub_188699368(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_188699374()
{
  _Unwind_Resume(v0);
}

uint64_t kdu_params::compare(kdu_params *this, const char *a2, int a3, int a4, int a5)
{
  BOOL v7 = 0;
  LODWORD(result) = kdu_params::get(this, a2, a3, a4, &v7, 1, 1, 1);
  if (v7 == a5) {
    return result;
  }
  else {
    return 0;
  }
}

void cod_params::cod_params(cod_params *this)
{
  *((void *)this + 1) = "COD";
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18898D540;
  *((_WORD *)this + 20) = 0;
  *((unsigned char *)this + 42) = 0;
  *((void *)this + 6) = this;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 9) = this;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = this;
  *((unsigned char *)this + 104) = 0;
  *((_DWORD *)this + 9) = 16842753;
  *((void *)this + 14) = 0;
  *(void *)this = &unk_1ED4DE6E8;
  kdu_params::add_dependency((uint64_t)this, "QCD");
}

void sub_188699734(_Unwind_Exception *a1)
{
  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t cod_params::copy_with_xforms(cod_params *this, kdu_params *a2, int a3, int a4, int a5, int a6, int a7)
{
  if ((*((_DWORD *)this + 5) & 0x80000000) != 0)
  {
    v36[0] = 0;
    LODWORD(v27[0]) = 0;
    v34[0] = 0;
    v33[0] = 0;
    *(_DWORD *)&v36[4] = 0;
    _OWORD v31[4] = 0;
    v31[0] = 0;
    if (kdu_params::get(a2, "Cycc", 0, 0, v36, 0, 1, 1))
    {
      if (a3)
      {
        BOOL v14 = 0;
        v36[0] = 0;
      }
      else
      {
        BOOL v14 = v36[0];
      }
      kdu_params::set((uint64_t)this, "Cycc", 0, 0, v14);
    }
    if (kdu_params::get(a2, "Clayers", 0, 0, (int *)v27, 0, 1, 1)) {
      kdu_params::set(this, "Clayers", 0, 0, (int *)LODWORD(v27[0]));
    }
    if (kdu_params::get(a2, "Cuse_sop", 0, 0, v34, 0, 1, 1)) {
      kdu_params::set((uint64_t)this, "Cuse_sop", 0, 0, v34[0]);
    }
    if (kdu_params::get(a2, "Cuse_eph", 0, 0, v33, 0, 1, 1)) {
      kdu_params::set((uint64_t)this, "Cuse_eph", 0, 0, v33[0]);
    }
    if (kdu_params::get(a2, "Corder", 0, 0, (int *)&v36[4], 0, 1, 1)) {
      kdu_params::set(this, "Corder", 0, 0, (int *)*(unsigned int *)&v36[4]);
    }
    if (kdu_params::get(a2, "Calign_blk_last", 0, a5, v31, 0, 1, 1)
      && kdu_params::get(a2, "Calign_blk_last", 0, a5 ^ 1u, &v31[4], 0, 1, 1))
    {
      if (a7) {
        v31[4] ^= 1u;
      }
      BOOL v15 = v31[0];
      if (a6)
      {
        BOOL v15 = !v31[0];
        v31[0] ^= 1u;
      }
      kdu_params::set((uint64_t)this, "Calign_blk_last", 0, 0, v15);
      kdu_params::set((uint64_t)this, "Calign_blk_last", 0, 1, v31[4]);
    }
  }
  *(void *)int v36 = 0;
  BOOL v35 = 0;
  *(_DWORD *)__int16 v33 = 0;
  *(_DWORD *)__int16 v34 = 0;
  BOOL v32 = 0;
  *(void *)int v31 = 0;
  int v30 = 0;
  if (kdu_params::get(a2, "Clevels", 0, 0, (int *)&v36[4], 0, 1, 1))
  {
    int v16 = *(_DWORD *)&v36[4];
    int v17 = (int *)(*(_DWORD *)&v36[4] - a4);
    *(_DWORD *)&v36[4] -= a4;
    if (v16 - a4 < 0)
    {
      uint64_t v29 = 0;
      *(_OWORD *)int v27 = 0u;
      long long v28 = 0u;
      kdu_error::kdu_error((kdu_error *)v27, "Kakadu Core Error:\n");
      (*((void (**)(cod_params **, const char *))v27[0] + 2))(v27, "Attempting to discard too many resolution levels!  Cannot discard more resolution levels than there are DWT levels.");
      kdu_error::~kdu_error((kdu_error *)v27);
    }
    kdu_params::set(this, "Clevels", 0, 0, v17);
  }
  if (kdu_params::get(a2, "Cdfs", 0, 0, (int *)v36, 0, 1, 1)) {
    kdu_params::set(this, "Cdfs", 0, 0, (int *)*(unsigned int *)v36);
  }
  LODWORD(v27[0]) = 0;
  if (kdu_params::get(a2, "Cdecomp", 0, 0, (int *)v27, 0, 0, 1))
  {
    int v18 = 0;
    do
    {
      int v19 = v18;
      if (a5) {
        LODWORD(v27[0]) = cod_params::transpose_decomp((cod_params *)LODWORD(v27[0]));
      }
      if (v18 >= a4) {
        kdu_params::set(this, "Cdecomp", v18 - a4, 0, (int *)LODWORD(v27[0]));
      }
      ++v18;
    }
    while ((kdu_params::get(a2, "Cdecomp", v19 + 1, 0, (int *)v27, 0, 0, 1) & 1) != 0);
    if (v19 < a4) {
      kdu_params::set(this, "Cdecomp", 0, 0, (int *)LODWORD(v27[0]));
    }
  }
  if (kdu_params::get(a2, "Creversible", 0, 0, &v35, 0, 1, 1)) {
    kdu_params::set((uint64_t)this, "Creversible", 0, 0, v35);
  }
  if (kdu_params::get(a2, "Ckernels", 0, 0, (int *)v34, 0, 1, 1)) {
    kdu_params::set(this, "Ckernels", 0, 0, (int *)*(unsigned int *)v34);
  }
  if (kdu_params::get(a2, "Catk", 0, 0, (int *)v33, 0, 1, 1)) {
    kdu_params::set(this, "Catk", 0, 0, (int *)*(unsigned int *)v33);
  }
  if (kdu_params::get(a2, "Cuse_precincts", 0, 0, &v32, 0, 1, 1)) {
    kdu_params::set((uint64_t)this, "Cuse_precincts", 0, 0, v32);
  }
  if (kdu_params::get(a2, "Cblk", 0, a5, (int *)v31, 0, 1, 1)
    && kdu_params::get(a2, "Cblk", 0, a5 ^ 1u, (int *)&v31[4], 0, 1, 1))
  {
    kdu_params::set(this, "Cblk", 0, 0, (int *)*(unsigned int *)v31);
    kdu_params::set(this, "Cblk", 0, 1, (int *)*(unsigned int *)&v31[4]);
  }
  if (kdu_params::get(a2, "Cmodes", 0, 0, &v30, 0, 1, 1)) {
    kdu_params::set(this, "Cmodes", 0, 0, (int *)v30);
  }
  *(void *)int v26 = 0;
  if (kdu_params::get(a2, "Cprecincts", a4, a5, v26, 0, 1, 1))
  {
    if (kdu_params::get(a2, "Cprecincts", a4, a5 ^ 1u, &v26[1], 0, 1, 1))
    {
      kdu_params::set(this, "Cprecincts", 0, 0, (int *)v26[0]);
      kdu_params::set(this, "Cprecincts", 0, 1, (int *)v26[1]);
      if (kdu_params::get(a2, "Cprecincts", a4 + 1, a5, v26, 0, 0, 1))
      {
        int v20 = 0;
        do
        {
          if (!kdu_params::get(a2, "Cprecincts", v20 + 1 + a4, a5 ^ 1u, &v26[1], 0, 0, 1)) {
            break;
          }
          kdu_params::set(this, "Cprecincts", v20 + 1, 0, (int *)v26[0]);
          kdu_params::set(this, "Cprecincts", v20 + 1, 1, (int *)v26[1]);
          char v21 = kdu_params::get(a2, "Cprecincts", a4 + v20++ + 2, a5, v26, 0, 0, 1);
        }
        while ((v21 & 1) != 0);
      }
    }
  }
  float v25 = 0.0;
  if (kdu_params::get(a2, "Cweight", 0, 0, &v25, 0, 1, 1)) {
    kdu_params::set((uint64_t)this, "Cweight", 0, 0, v25);
  }
  if (kdu_params::get(a2, "Clev_weights", 0, 0, &v25, 0, 0, 1))
  {
    int v22 = 0;
    do
      kdu_params::set((uint64_t)this, "Clev_weights", v22++, 0, v25);
    while ((kdu_params::get(a2, "Clev_weights", v22, 0, &v25, 0, 0, 1) & 1) != 0);
  }
  uint64_t result = kdu_params::get(a2, "Cband_weights", 0, 0, &v25, 0, 0, 1);
  if (result)
  {
    int v24 = 0;
    do
    {
      kdu_params::set((uint64_t)this, "Cband_weights", v24++, 0, v25);
      uint64_t result = kdu_params::get(a2, "Cband_weights", v24, 0, &v25, 0, 0, 1);
    }
    while ((result & 1) != 0);
  }
  return result;
}

void sub_18869A068(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18869A074()
{
  _Unwind_Resume(v0);
}

uint64_t cod_params::transpose_decomp(cod_params *this)
{
  unsigned int v1 = this & 0xFFC00003 | (((this >> 2) & 0x3FF) << 12) | (this >> 10) & 0xFFC;
  if ((~this & 3) != 0) {
    unsigned int v1 = this;
  }
  if ((~v1 & 0xC) == 0) {
    unsigned int v1 = v1 & 0xFFFFFC3F | (v1 >> 6 << 8) | (v1 >> 2) & 0xC0;
  }
  if ((~v1 & 0x3000) == 0) {
    unsigned int v1 = v1 & 0xFFF0FFFF | ((HIWORD(v1) & 3) << 18) | (v1 >> 2) & 0x30000;
  }
  if ((~v1 & 0xC00000) == 0) {
    unsigned int v1 = v1 & 0xC3FFFFFF | (((v1 >> 26) & 3) << 28) | (v1 >> 2) & 0xC000000;
  }
  return (2 * v1) & 0xAAAAAAAA | (v1 >> 1) & 0x55555555;
}

uint64_t cod_params::write_marker_segment(cod_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  uint64_t v138 = *MEMORY[0x1E4F143B8];
  if (a4) {
    return 0;
  }
  *(_WORD *)uint64_t v129 = 0;
  *(_WORD *)char v128 = 0;
  BOOL v127 = 0;
  *(void *)uint64_t v126 = 0;
  *(_WORD *)uint64_t v125 = 0;
  int v124 = 0;
  *(void *)int v122 = 0;
  *(void *)uint64_t v123 = 0;
  *(void *)int v120 = 0;
  *(void *)int v121 = 0;
  int v119 = 0;
  if (!kdu_params::get(this, "Cycc", 0, 0, &v129[1], 1, 1, 1)
    || !kdu_params::get(this, "Clayers", 0, 0, (int *)&v126[4], 1, 1, 1)
    || !kdu_params::get(this, "Cuse_sop", 0, 0, v129, 1, 1, 1)
    || !kdu_params::get(this, "Cuse_eph", 0, 0, &v128[1], 1, 1, 1)
    || !kdu_params::get(this, "Corder", 0, 0, (int *)v126, 1, 1, 1)
    || !kdu_params::get(this, "Calign_blk_last", 0, 0, &v127, 1, 1, 1)
    || !kdu_params::get(this, "Calign_blk_last", 0, 1, v128, 1, 1, 1)
    || !kdu_params::get(this, "Clevels", 0, 0, &v124, 1, 1, 1)
    || !kdu_params::get(this, "Cdfs", 0, 0, v123, 1, 1, 1)
    || !kdu_params::get(this, "Cads", 0, 0, &v123[1], 1, 1, 1)
    || !kdu_params::get(this, "Creversible", 0, 0, &v125[1], 1, 1, 1)
    || !kdu_params::get(this, "Ckernels", 0, 0, &v122[1], 1, 1, 1)
    || !kdu_params::get(this, "Catk", 0, 0, v122, 1, 1, 1)
    || !kdu_params::get(this, "Cblk", 0, 0, &v121[1], 1, 1, 1)
    || !kdu_params::get(this, "Cblk", 0, 1, v121, 1, 1, 1)
    || !kdu_params::get(this, "Cmodes", 0, 0, (int *)&v120[4], 1, 1, 1)
    || (kdu_params::get(this, "Cuse_precincts", 0, 0, v125, 1, 1, 1) & 1) == 0)
  {
    *(void *)&long long v135 = 0;
    long long v134 = 0u;
    *(_OWORD *)int v133 = 0u;
    kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)v133);
  }
  if (a3)
  {
    BOOL v7 = v129[1];
    v133[0] = 0;
    int v8 = kdu_params::get(a3, "Cycc", 0, 0, v133, 1, 1, 1);
    int v9 = v133[0] == v7 ? v8 : 0;
    if (v9 == 1)
    {
      int v10 = *(_DWORD *)&v126[4];
      *(_DWORD *)int v133 = 0;
      int v11 = kdu_params::get(a3, "Clayers", 0, 0, (int *)v133, 1, 1, 1);
      int v12 = *(_DWORD *)v133 == v10 ? v11 : 0;
      if (v12 == 1)
      {
        BOOL v13 = v129[0];
        v133[0] = 0;
        int v14 = kdu_params::get(a3, "Cuse_sop", 0, 0, v133, 1, 1, 1);
        int v15 = v133[0] == v13 ? v14 : 0;
        if (v15 == 1)
        {
          BOOL v16 = v128[1];
          v133[0] = 0;
          int v17 = kdu_params::get(a3, "Cuse_eph", 0, 0, v133, 1, 1, 1);
          int v18 = v133[0] == v16 ? v17 : 0;
          if (v18 == 1)
          {
            int v19 = *(_DWORD *)v126;
            *(_DWORD *)int v133 = 0;
            int v20 = kdu_params::get(a3, "Corder", 0, 0, (int *)v133, 1, 1, 1);
            int v21 = *(_DWORD *)v133 == v19 ? v20 : 0;
            if (v21 == 1
              && kdu_params::compare(a3, "Calign_blk_last", 0, 0, v127)
              && kdu_params::compare(a3, "Calign_blk_last", 0, 1, v128[0]))
            {
              int v22 = v124;
              *(_DWORD *)int v133 = 0;
              int v23 = kdu_params::get(a3, "Clevels", 0, 0, (int *)v133, 1, 1, 1);
              int v24 = *(_DWORD *)v133 == v22 ? v23 : 0;
              if (v24 == 1)
              {
                int v25 = v123[1];
                *(_DWORD *)int v133 = 0;
                int v26 = kdu_params::get(a3, "Cads", 0, 0, (int *)v133, 1, 1, 1);
                int v27 = *(_DWORD *)v133 == v25 ? v26 : 0;
                if (v27 == 1)
                {
                  int v28 = v123[0];
                  *(_DWORD *)int v133 = 0;
                  int v29 = kdu_params::get(a3, "Cdfs", 0, 0, (int *)v133, 1, 1, 1);
                  int v30 = *(_DWORD *)v133 == v28 ? v29 : 0;
                  if (v30 == 1
                    && (!v123[1] || (*((_DWORD *)a3 + 4) & 0x80000000) == 0)
                    && (!v123[0] || (*((_DWORD *)this + 4) & 0x80000000) == 0))
                  {
                    if (kdu_params::compare(a3, "Creversible", 0, 0, v125[1]))
                    {
                      int v31 = v122[1];
                      *(_DWORD *)int v133 = 0;
                      int v32 = kdu_params::get(a3, "Ckernels", 0, 0, (int *)v133, 1, 1, 1);
                      int v33 = *(_DWORD *)v133 == v31 ? v32 : 0;
                      if (v33 == 1)
                      {
                        int v34 = v122[0];
                        *(_DWORD *)int v133 = 0;
                        int v35 = kdu_params::get(a3, "Catk", 0, 0, (int *)v133, 1, 1, 1);
                        int v36 = *(_DWORD *)v133 == v34 ? v35 : 0;
                        if (v36 == 1)
                        {
                          int v37 = v121[1];
                          *(_DWORD *)int v133 = 0;
                          int v38 = kdu_params::get(a3, "Cblk", 0, 0, (int *)v133, 1, 1, 1);
                          int v39 = *(_DWORD *)v133 == v37 ? v38 : 0;
                          if (v39 == 1)
                          {
                            int v40 = v121[0];
                            *(_DWORD *)int v133 = 0;
                            int v41 = kdu_params::get(a3, "Cblk", 0, 1, (int *)v133, 1, 1, 1);
                            int v42 = *(_DWORD *)v133 == v40 ? v41 : 0;
                            if (v42 == 1)
                            {
                              int v43 = *(_DWORD *)&v120[4];
                              *(_DWORD *)int v133 = 0;
                              int v44 = kdu_params::get(a3, "Cmodes", 0, 0, (int *)v133, 1, 1, 1);
                              int v45 = *(_DWORD *)v133 == v43 ? v44 : 0;
                              if (v45 == 1 && kdu_params::compare(a3, "Cuse_precincts", 0, 0, v125[0]))
                              {
                                if (!v125[0]) {
                                  return 0;
                                }
                                int v46 = v124;
                                if (v124 < 0)
                                {
                                  int v54 = 0;
                                }
                                else
                                {
                                  int v47 = 0;
                                  while (kdu_params::get(this, "Cprecincts", v47, 0, &v119, 1, 1, 1)
                                       && kdu_params::get(this, "Cprecincts", v47, 1, (int *)v120, 1, 1, 1))
                                  {
                                    int v48 = v119;
                                    *(_DWORD *)int v133 = 0;
                                    int v49 = kdu_params::get(a3, "Cprecincts", v47, 0, (int *)v133, 1, 1, 1);
                                    int v50 = *(_DWORD *)v133 == v48 ? v49 : 0;
                                    if (v50 != 1) {
                                      break;
                                    }
                                    int v51 = *(_DWORD *)v120;
                                    *(_DWORD *)int v133 = 0;
                                    int v52 = kdu_params::get(a3, "Cprecincts", v47, 1, (int *)v133, 1, 1, 1);
                                    int v53 = *(_DWORD *)v133 == v51 ? v52 : 0;
                                    if (v53 != 1) {
                                      break;
                                    }
                                    int v54 = v47 + 1;
                                    BOOL v55 = v47++ < v124;
                                    if (!v55) {
                                      goto LABEL_98;
                                    }
                                  }
                                  int v54 = v47;
LABEL_98:
                                  int v46 = v124;
                                }
                                if (v54 > v46) {
                                  return 0;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (v123[1] && (*((_DWORD *)this + 4) & 0x80000000) == 0)
  {
    if (!a3
      || ((int v56 = v124,
           *(_DWORD *)int v133 = 0,
           char v57 = kdu_params::get(a3, "Clevels", 0, 0, (int *)v133, 1, 1, 1),
           *(_DWORD *)v133 == v56)
        ? (char v58 = v57)
        : (char v58 = 0),
          (v58 & 1) == 0))
    {
      *(void *)&long long v135 = 0;
      long long v134 = 0u;
      *(_OWORD *)int v133 = 0u;
      kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)v133);
    }
  }
  if (v123[0] && (*((_DWORD *)this + 4) & 0x80000000) != 0 && (*((_DWORD *)this + 5) & 0x80000000) == 0)
  {
    if (!a3
      || ((int v59 = v124,
           *(_DWORD *)int v133 = 0,
           char v60 = kdu_params::get(a3, "Clevels", 0, 0, (int *)v133, 1, 1, 1),
           *(_DWORD *)v133 == v59)
        ? (char v61 = v60)
        : (char v61 = 0),
          (v61 & 1) == 0))
    {
      *(void *)&long long v135 = 0;
      long long v134 = 0u;
      *(_OWORD *)int v133 = 0u;
      kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)v133);
    }
  }
  uint64_t v62 = kdu_params::access_cluster(this, "SIZ");
  if (!v62) {
    cod_params::write_marker_segment();
  }
  int v63 = (kdu_params *)v62;
  if (*(_DWORD *)&v126[4] >= 0x10000u)
  {
    uint64_t v132 = 0;
    *(_OWORD *)uint64_t v130 = 0u;
    long long v131 = 0u;
    kdu_error::kdu_error((kdu_error *)v130, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(void *)v130 + 16))(v130, "Illegal number of quality layers, ");
    long long v136 = 0u;
    long long v137 = 0u;
    long long v134 = 0u;
    long long v135 = 0u;
    *(_OWORD *)int v133 = 0u;
    if (LOBYTE(v130[2])) {
      sprintf((char *)v133, "%x");
    }
    else {
      sprintf((char *)v133, "%d");
    }
    (*(void (**)(int *, BOOL *))(*(void *)v130 + 16))(v130, v133);
    (*(void (**)(int *, const char *))(*(void *)v130 + 16))(v130, ".");
    kdu_error::~kdu_error((kdu_error *)v130);
  }
  if (v124 >= 0x21)
  {
    uint64_t v132 = 0;
    *(_OWORD *)uint64_t v130 = 0u;
    long long v131 = 0u;
    kdu_error::kdu_error((kdu_error *)v130, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(void *)v130 + 16))(v130, "Illegal number of DWT levels, ");
    long long v136 = 0u;
    long long v137 = 0u;
    long long v134 = 0u;
    long long v135 = 0u;
    *(_OWORD *)int v133 = 0u;
    if (LOBYTE(v130[2])) {
      sprintf((char *)v133, "%x");
    }
    else {
      sprintf((char *)v133, "%d");
    }
    (*(void (**)(int *, BOOL *))(*(void *)v130 + 16))(v130, v133);
    (*(void (**)(int *, const char *))(*(void *)v130 + 16))(v130, ". Legal range is 0 to 32!");
    kdu_error::~kdu_error((kdu_error *)v130);
  }
  int v114 = *((_DWORD *)this + 8);
  if ((*((_DWORD *)this + 5) & 0x80000000) != 0)
  {
    if (v129[1])
    {
      long long v65 = (kdu_params *)kdu_params::access_relation(this, *((_DWORD *)this + 4), 0, 0, 1);
      *(void *)uint64_t v130 = v65;
      *(void *)&v130[2] = kdu_params::access_relation(this, *((_DWORD *)this + 4), 1, 0, 1);
      *(void *)&long long v131 = kdu_params::access_relation(this, *((_DWORD *)this + 4), 2, 0, 1);
      BOOL v118 = 0;
      kdu_params::get(v65, "Creversible", 0, 0, &v118, 1, 1, 1);
      int v117 = 0;
      kdu_params::get(v63, "Sprecision", 0, 0, &v117, 1, 1, 1);
      uint64_t v66 = 1;
      do
      {
        long long v67 = *(kdu_params **)&v130[2 * v66];
        if (!v67) {
          break;
        }
        BOOL v68 = v118;
        v133[0] = 0;
        int v69 = kdu_params::get(v67, "Creversible", 0, 0, v133, 1, 1, 1);
        if (v133[0] == v68) {
          int v70 = v69;
        }
        else {
          int v70 = 0;
        }
        if (v70 == 1)
        {
          int v71 = v117;
          *(_DWORD *)int v133 = 0;
          char v72 = kdu_params::get(v63, "Sprecision", v66, 0, (int *)v133, 1, 1, 1);
          char v73 = *(_DWORD *)v133 == v71 ? v72 : 0;
          if (v73) {
            continue;
          }
        }
        *(void *)&long long v135 = 0;
        long long v134 = 0u;
        *(_OWORD *)int v133 = 0u;
        kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
        (*(void (**)(BOOL *, const char *))(*(void *)v133 + 16))(v133, "You cannot use a colour transform unless the first 3 image components have identical bit-depths and are either all reversible or all irreversible.");
        kdu_error::~kdu_error((kdu_error *)v133);
        ++v66;
      }
      while (v66 != 3);
    }
    int v64 = 9;
  }
  else if (*((int *)this + 8) < 257)
  {
    int v64 = 6;
  }
  else
  {
    int v64 = 7;
  }
  unsigned int v115 = v64 + v125[0] + v125[0] * v124 + 5;
  if (!a2) {
    return v115;
  }
  if ((*((_DWORD *)this + 4) & 0x80000000) == 0)
  {
    int v117 = 2;
    kdu_params::get(v63, "Sprofile", 0, 0, &v117, 1, 1, 1);
    if (!v117)
    {
      uint64_t v132 = 0;
      *(_OWORD *)uint64_t v130 = 0u;
      long long v131 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)v130, "Kakadu Core Warning:\n");
      (*(void (**)(int *, const char *))(*(void *)v130 + 16))(v130, "Profile violation detected (code-stream is technically illegal).  COD/COC marker segments may only appear in the main header of a Profile-0 code-stream.  You should set \"Sprofile\" to 1 or 2.  Problem detected in tile ");
      long long v136 = 0u;
      long long v137 = 0u;
      long long v134 = 0u;
      long long v135 = 0u;
      *(_OWORD *)int v133 = 0u;
      if (LOBYTE(v130[2])) {
        sprintf((char *)v133, "%x");
      }
      else {
        sprintf((char *)v133, "%d");
      }
      (*(void (**)(int *, BOOL *))(*(void *)v130 + 16))(v130, v133);
      (*(void (**)(int *, const char *))(*(void *)v130 + 16))(v130, ".");
      kdu_warning::~kdu_warning((kdu_warning *)v130);
    }
  }
  if (v122[0])
  {
    if ((v122[0] - 256) <= 0xFFFFFF01)
    {
      *(void *)&long long v135 = 0;
      long long v134 = 0u;
      *(_OWORD *)int v133 = 0u;
      kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
      (*(void (**)(BOOL *, const char *))(*(void *)v133 + 16))(v133, "Illegal ATK instance index found when preparing to generate COD/COC marker segment.  Legal values are in the range 2 to 255.");
      kdu_error::~kdu_error((kdu_error *)v133);
    }
  }
  else if (v122[1] != v125[1])
  {
    *(void *)&long long v135 = 0;
    long long v134 = 0u;
    *(_OWORD *)int v133 = 0u;
    kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)v133);
  }
  char v74 = v125[0];
  if ((*((_DWORD *)this + 5) & 0x80000000) != 0)
  {
    BOOL v77 = v129[0];
    BOOL v78 = v128[1];
    BOOL v79 = v128[0];
    BOOL v80 = v127;
    kdu_output::put(a2, 255);
    kdu_output::put(a2, 82);
    kdu_output::put(a2, (unsigned __int16)(v115 - 2) >> 8);
    kdu_output::put(a2, v115 - 2);
    int v81 = kdu_output::put(a2, ((2 * v77) | (4 * v78) | (8 * v79) | (16 * v80)) | v74);
    int v82 = kdu_output::put(a2, v126[0]);
    char v83 = v126[4];
    kdu_output::put(a2, v126[5]);
    kdu_output::put(a2, v83);
    int v84 = v81 + v82 + kdu_output::put(a2, v129[1]) + 6;
  }
  else
  {
    kdu_output::put(a2, 255);
    kdu_output::put(a2, 83);
    kdu_output::put(a2, (unsigned __int16)(v115 - 2) >> 8);
    kdu_output::put(a2, v115 - 2);
    int v75 = *((_DWORD *)this + 5);
    if (v114 >= 257)
    {
      kdu_output::put(a2, SBYTE1(v75));
      kdu_output::put(a2, v75);
      int v76 = 2;
    }
    else
    {
      int v76 = kdu_output::put(a2, v75);
    }
    int v84 = v76 + 4 + kdu_output::put(a2, v74);
  }
  int v85 = -1;
  do
  {
    unsigned int v86 = v85 + 1;
    int v87 = 1 << (v85 + 1);
    if (v85 == 30) {
      break;
    }
    ++v85;
  }
  while (v87 < v121[0]);
  int v88 = -1;
  do
  {
    unsigned int v89 = v88 + 1;
    int v90 = 1 << (v88 + 1);
    if (v88 == 30) {
      break;
    }
    ++v88;
  }
  while (v90 < v121[1]);
  if (v87 == v121[0]) {
    unsigned int v91 = v86;
  }
  else {
    unsigned int v91 = 0;
  }
  if (v90 == v121[1]) {
    unsigned int v92 = v89;
  }
  else {
    unsigned int v92 = 0;
  }
  char v93 = v91 - 2;
  if (v91 < 2 || ((unsigned int v94 = v92 + v91, v92 >= 2) ? (v95 = v94 >= 0xD) : (v95 = 1), v95))
  {
    *(void *)&long long v135 = 0;
    long long v134 = 0u;
    *(_OWORD *)int v133 = 0u;
    kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
    (*(void (**)(BOOL *, const char *))(*(void *)v133 + 16))(v133, "Maximum code-block dimensions must be no less than 4 and the maximum code-block area must not exceed 4096 samples!");
    kdu_error::~kdu_error((kdu_error *)v133);
  }
  if ((*((_DWORD *)this + 4) & 0x80000000) != 0)
  {
    char v96 = v123[0];
    if (!v123[0] || (*((_DWORD *)this + 5) & 0x80000000) != 0) {
      goto LABEL_191;
    }
  }
  else
  {
    char v96 = v123[1];
    if (!v123[1])
    {
LABEL_191:
      char v97 = v124;
      goto LABEL_192;
    }
  }
  char v97 = v96 | 0x80;
LABEL_192:
  int v98 = kdu_output::put(a2, v97);
  int v99 = kdu_output::put(a2, v93);
  int v100 = kdu_output::put(a2, v92 - 2);
  int v101 = kdu_output::put(a2, v120[4]);
  char v102 = v122[0];
  if (!v122[0]) {
    char v102 = v122[1];
  }
  int v103 = v98 + v84 + v99 + v100 + v101 + kdu_output::put(a2, v102);
  if (v125[0])
  {
    int v104 = v124;
    if ((v124 & 0x80000000) == 0)
    {
      int v105 = 0;
      do
      {
        v130[0] = 0;
        int v117 = 0;
        if (!kdu_params::get(this, "Cprecincts", v104 - v105, 0, &v117, 1, 1, 1)
          || (kdu_params::get(this, "Cprecincts", v124 - v105, 1, v130, 1, 1, 1) & 1) == 0)
        {
          *(void *)&long long v135 = 0;
          long long v134 = 0u;
          *(_OWORD *)int v133 = 0u;
          kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
          (*(void (**)(BOOL *, const char *))(*(void *)v133 + 16))(v133, "No precinct dimensions supplied for COD/COC!");
          kdu_error::~kdu_error((kdu_error *)v133);
        }
        int v106 = -1;
        do
        {
          unsigned int v107 = v106 + 1;
          int v108 = 1 << (v106 + 1);
          if (v106 == 30) {
            break;
          }
          ++v106;
        }
        while (v108 < v130[0]);
        if (v108 == v130[0]) {
          unsigned int v109 = v107;
        }
        else {
          unsigned int v109 = 0;
        }
        v130[0] = v109;
        int v110 = -1;
        do
        {
          unsigned int v111 = v110 + 1;
          int v112 = 1 << (v110 + 1);
          if (v110 == 30) {
            break;
          }
          ++v110;
        }
        while (v112 < v117);
        if (v112 == v117) {
          unsigned int v113 = v111;
        }
        else {
          unsigned int v113 = 0;
        }
        int v117 = v113;
        if (v109 > 0xF || v113 >= 0x10)
        {
          *(void *)&long long v135 = 0;
          long long v134 = 0u;
          *(_OWORD *)int v133 = 0u;
          kdu_error::kdu_error((kdu_error *)v133, "Kakadu Core Error:\n");
          (*(void (**)(BOOL *, const char *))(*(void *)v133 + 16))(v133, "Precinct dimensions may not exceed 2^15!");
          kdu_error::~kdu_error((kdu_error *)v133);
        }
        v103 += kdu_output::put(a2, v109 + 16 * v113);
        int v104 = v124;
        BOOL v55 = v105++ < v124;
      }
      while (v55);
    }
  }
  uint64_t result = v115;
  if (v115 != v103) {
    cod_params::write_marker_segment();
  }
  return result;
}

void sub_18869B6D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_18869B6E0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Unwind_Resume(v27);
}

uint64_t cod_params::check_marker_segment(cod_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  if (a2 == 65362)
  {
    int v5 = -1;
    goto LABEL_7;
  }
  uint64_t result = 0;
  if (a2 == 65363 && a3 >= 2)
  {
    int v8 = *a4;
    *a5 = v8;
    if (*((int *)this + 8) < 257) {
      return 1;
    }
    int v5 = a4[1] | (v8 << 8);
LABEL_7:
    *a5 = v5;
    return 1;
  }
  return result;
}

uint64_t cod_params::read_marker_segment(cod_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (a5) {
    return 0;
  }
  int v9 = &a4[a3];
  int v10 = *((_DWORD *)this + 5);
  if (v10 < 0)
  {
    if (a2 != 65362) {
      return 0;
    }
    if (a3 <= 0)
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = a4;
      __cxa_throw(exception, MEMORY[0x1E4FBA318], 0);
    }
    unsigned int v17 = *a4;
    if (v17 >= 0x20)
    {
      *(void *)&long long v46 = 0;
      *(_OWORD *)int v44 = 0u;
      long long v45 = 0u;
      kdu_error::kdu_error((kdu_error *)v44, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v44 + 16))(v44, "Malformed COD marker segment encountered. Invalid \"Scod\" value!");
      kdu_error::~kdu_error((kdu_error *)v44);
    }
    int v16 = v17 & 1;
    kdu_params::set((uint64_t)this, "Cuse_precincts", 0, 0, v16);
    kdu_params::set((uint64_t)this, "Cuse_sop", 0, 0, (v17 >> 1) & 1);
    kdu_params::set((uint64_t)this, "Cuse_eph", 0, 0, (v17 >> 2) & 1);
    kdu_params::set((uint64_t)this, "Calign_blk_last", 0, 1, (v17 >> 3) & 1);
    kdu_params::set((uint64_t)this, "Calign_blk_last", 0, 0, (v17 >> 4) & 1);
    if (a3 <= 1)
    {
      int v36 = __cxa_allocate_exception(8uLL);
      *int v36 = a4 + 1;
      __cxa_throw(v36, MEMORY[0x1E4FBA318], 0);
    }
    kdu_params::set(this, "Corder", 0, 0, (int *)a4[1]);
    if (a3 <= 3)
    {
      int v37 = __cxa_allocate_exception(8uLL);
      *int v37 = a4 + 2;
      __cxa_throw(v37, MEMORY[0x1E4FBA318], 0);
    }
    kdu_params::set(this, "Clayers", 0, 0, (int *)__rev16(*((unsigned __int16 *)a4 + 1)));
    if (a3 <= 4)
    {
      int v38 = __cxa_allocate_exception(8uLL);
      *int v38 = a4 + 4;
      __cxa_throw(v38, MEMORY[0x1E4FBA318], 0);
    }
    int v14 = a4 + 5;
    kdu_params::set(this, "Cycc", 0, 0, (int *)a4[4]);
  }
  else
  {
    if (a2 != 65363) {
      return 0;
    }
    int v12 = a4 + 1;
    int v11 = *a4;
    if (*((int *)this + 8) >= 257)
    {
      int v12 = a4 + 2;
      int v11 = a4[1] | (v11 << 8);
    }
    if (v11 != v10) {
      return 0;
    }
    if (v9 - v12 <= 0)
    {
      int v39 = __cxa_allocate_exception(8uLL);
      void *v39 = v12;
      __cxa_throw(v39, MEMORY[0x1E4FBA318], 0);
    }
    unsigned int v15 = *v12;
    int v14 = v12 + 1;
    char v13 = v15;
    if (v15 >= 2)
    {
      *(void *)&long long v46 = 0;
      *(_OWORD *)int v44 = 0u;
      long long v45 = 0u;
      kdu_error::kdu_error((kdu_error *)v44, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v44 + 16))(v44, "Malformed COC marker segment. Invalid \"Scoc\" value!");
      kdu_error::~kdu_error((kdu_error *)v44);
    }
    int v16 = v13 & 1;
    kdu_params::set((uint64_t)this, "Cuse_precincts", 0, 0, v16);
  }
  if ((*((_DWORD *)this + 4) & 0x80000000) == 0)
  {
    int v18 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
    if (!v18) {
      cod_params::read_marker_segment();
    }
    int v43 = 2;
    kdu_params::get(v18, "Sprofile", 0, 0, &v43, 1, 1, 1);
    if (!v43)
    {
      uint64_t v42 = 0;
      long long v40 = 0u;
      long long v41 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v40, "Kakadu Core Warning:\n");
      (*(void (**)(long long *, const char *))(v40 + 16))(&v40, "Profile violation detected (code-stream is technically illegal).  COD/COC marker segments may only appear in the main header of a Profile-0 code-stream.  You should set \"Sprofile\" to 1 or 2.  Problem detected in tile ");
      long long v47 = 0u;
      long long v48 = 0u;
      long long v45 = 0u;
      long long v46 = 0u;
      *(_OWORD *)int v44 = 0u;
      if (BYTE8(v40)) {
        sprintf(v44, "%x");
      }
      else {
        sprintf(v44, "%d");
      }
      (*(void (**)(long long *, char *))(v40 + 16))(&v40, v44);
      (*(void (**)(long long *, const char *))(v40 + 16))(&v40, ".");
      kdu_warning::~kdu_warning((kdu_warning *)&v40);
    }
  }
  int v43 = 0;
  if (v9 - v14 <= 0)
  {
    int v33 = __cxa_allocate_exception(8uLL);
    *int v33 = v14;
LABEL_61:
    __cxa_throw(v33, MEMORY[0x1E4FBA318], 0);
  }
  int v20 = v14 + 1;
  int v19 = (char)*v14;
  unsigned __int8 v21 = *v14;
  int v43 = *v14;
  if (v19 < 0)
  {
    int v22 = (int *)(v21 & 0x7F);
    if ((*((_DWORD *)this + 4) & 0x80000000) != 0)
    {
      kdu_params::set(this, "Cdfs", 0, 0, v22);
      int v22 = 0;
    }
    kdu_params::set(this, "Cads", 0, 0, v22);
    if ((kdu_params::get(this, "Clevels", 0, 0, &v43, 1, 1, 1) & 1) == 0)
    {
      *(void *)&long long v46 = 0;
      *(_OWORD *)int v44 = 0u;
      long long v45 = 0u;
      kdu_error::kdu_error((kdu_error *)v44, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v44 + 16))(v44, "Corrupt JP2 file: no levels ");
      kdu_error::~kdu_error((kdu_error *)v44);
    }
  }
  else
  {
    kdu_params::set(this, "Cads", 0, 0, 0);
    if ((*((_DWORD *)this + 4) & 0x80000000) != 0) {
      kdu_params::set(this, "Cdfs", 0, 0, 0);
    }
    kdu_params::set(this, "Clevels", 0, 0, (int *)v43);
  }
  if (v9 - v20 <= 0
    || (kdu_params::set(this, "Cblk", 0, 1, (int *)(4 << v14[1])), int v20 = v14 + 2, v9 - (v14 + 2) <= 0)
    || (kdu_params::set(this, "Cblk", 0, 0, (int *)(4 << v14[2])), int v20 = v14 + 3, v9 - (v14 + 3) <= 0))
  {
    int v33 = __cxa_allocate_exception(8uLL);
    *int v33 = v20;
    goto LABEL_61;
  }
  kdu_params::set(this, "Cmodes", 0, 0, (int *)v14[3]);
  if (v9 - (v14 + 4) <= 0)
  {
    int v34 = __cxa_allocate_exception(8uLL);
    *int v34 = v14 + 4;
    __cxa_throw(v34, MEMORY[0x1E4FBA318], 0);
  }
  unsigned int v23 = v14[4];
  if (v23 < 2)
  {
    kdu_params::set(this, "Catk", 0, 0, 0);
    kdu_params::set((uint64_t)this, "Creversible", 0, 0, v23 == 1);
    uint64_t v24 = v23 == 1;
  }
  else
  {
    kdu_params::set(this, "Catk", 0, 0, (int *)v14[4]);
    uint64_t v24 = 0xFFFFFFFFLL;
  }
  kdu_params::set(this, "Ckernels", 0, 0, (int *)v24);
  int v25 = v14 + 5;
  int v26 = v43;
  if (v43 >= 0) {
    int v27 = v16;
  }
  else {
    int v27 = 0;
  }
  if (v27 == 1)
  {
    int v28 = 0;
    int v29 = (unsigned __int8 *)(&a4[a3] - v14 - 5);
    int v30 = -1;
    do
    {
      if ((uint64_t)v29 <= 0)
      {
        int v32 = __cxa_allocate_exception(8uLL);
        *int v32 = v25;
        __cxa_throw(v32, MEMORY[0x1E4FBA318], 0);
      }
      unsigned int v31 = *v25++;
      kdu_params::set(this, "Cprecincts", v26 + v28, 0, (int *)(1 << (v31 >> 4)));
      kdu_params::set(this, "Cprecincts", v28 + v43, 1, (int *)(1 << (v31 & 0xF)));
      int v26 = v43;
      ++v30;
      --v28;
      --v29;
    }
    while (v30 < v43);
  }
  if (v25 != v9)
  {
    uint64_t v42 = 0;
    long long v40 = 0u;
    long long v41 = 0u;
    kdu_error::kdu_error((kdu_error *)&v40, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v40 + 16))(&v40, "Malformed COD/COC marker segment encountered. The final ");
    long long v47 = 0u;
    long long v48 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    *(_OWORD *)int v44 = 0u;
    if (BYTE8(v40)) {
      sprintf(v44, "%x");
    }
    else {
      sprintf(v44, "%d");
    }
    (*(void (**)(long long *, char *))(v40 + 16))(&v40, v44);
    (*(void (**)(long long *, const char *))(v40 + 16))(&v40, " bytes were not consumed!");
    kdu_error::~kdu_error((kdu_error *)&v40);
  }
  return 1;
}

void sub_18869C164(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18869C174(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11, long long a12, uint64_t a13, uint64_t a14, long long a15, long long a16, uint64_t a17)
{
  if (v17 == 1)
  {
    __cxa_begin_catch(v18);
    a13 = 0;
    a11 = 0u;
    a12 = 0u;
    kdu_error::kdu_error((kdu_error *)&a11, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(a11 + 16))(&a11, "Malformed COD/COC marker segment encountered. Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a11);
  }
  _Unwind_Resume(v18);
}

uint64_t cod_params::finalize(cod_params *this, int a2)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  *(void *)uint64_t v62 = 0;
  *(void *)int v63 = 0;
  BOOL v61 = 0;
  if ((a2 & 1) == 0)
  {
    if (kdu_params::get(this, "Clayers", 0, 0, &v63[1], 1, 1, 1))
    {
      if (v63[1] > 0x4000)
      {
        uint64_t v60 = 0;
        *(_OWORD *)char v58 = 0u;
        long long v59 = 0u;
        kdu_error::kdu_error((kdu_error *)v58, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(void *)v58 + 16))(v58, "Illegal number of quality layers, ");
        long long v67 = 0u;
        long long v68 = 0u;
        long long v65 = 0u;
        long long v66 = 0u;
        *(_OWORD *)int v64 = 0u;
        if (LOBYTE(v58[2])) {
          sprintf(v64, "%x");
        }
        else {
          sprintf(v64, "%d");
        }
        (*(void (**)(int *, char *))(*(void *)v58 + 16))(v58, v64);
        (*(void (**)(int *, const char *))(*(void *)v58 + 16))(v58, ", detected by coding parameter sub-system; legal code-streams may have no more than 16384 quality layers.");
        kdu_error::~kdu_error((kdu_error *)v58);
      }
    }
    else
    {
      kdu_params::set(this, "Clayers", 0, 0, (int *)1);
    }
    if ((kdu_params::get(this, "Cuse_sop", 0, 0, &v63[1], 1, 1, 1) & 1) == 0) {
      kdu_params::set(this, "Cuse_sop", 0, 0, 0);
    }
    if ((kdu_params::get(this, "Cuse_eph", 0, 0, &v63[1], 1, 1, 1) & 1) == 0) {
      kdu_params::set(this, "Cuse_eph", 0, 0, 0);
    }
    if ((kdu_params::get(this, "Corder", 0, 0, &v63[1], 1, 1, 1) & 1) == 0) {
      kdu_params::set(this, "Corder", 0, 0, 0);
    }
    if ((kdu_params::get(this, "Calign_blk_last", 0, 0, &v63[1], 1, 1, 1) & 1) == 0)
    {
      if (kdu_params::get(this, "Calign_blk_last", 0, 1, &v63[1], 1, 1, 1)) {
        cod_params::finalize();
      }
      kdu_params::set(this, "Calign_blk_last", 0, 0, 0);
      kdu_params::set(this, "Calign_blk_last", 0, 1, 0);
    }
    if (kdu_params::get(this, "Clevels", 0, 0, &v63[1], 1, 1, 1))
    {
      if (v63[1] >= 33)
      {
        uint64_t v60 = 0;
        *(_OWORD *)char v58 = 0u;
        long long v59 = 0u;
        kdu_error::kdu_error((kdu_error *)v58, "Kakadu Core Error:\n");
        (*(void (**)(int *, const char *))(*(void *)v58 + 16))(v58, "Illegal number of DWT levels, ");
        long long v67 = 0u;
        long long v68 = 0u;
        long long v65 = 0u;
        long long v66 = 0u;
        *(_OWORD *)int v64 = 0u;
        if (LOBYTE(v58[2])) {
          sprintf(v64, "%x");
        }
        else {
          sprintf(v64, "%d");
        }
        (*(void (**)(int *, char *))(*(void *)v58 + 16))(v58, v64);
        (*(void (**)(int *, const char *))(*(void *)v58 + 16))(v58, ", detected by coding parameter sub-system; legal code-streams may have no more than 32 DWT levels in any given"
          " tile-component.");
        kdu_error::~kdu_error((kdu_error *)v58);
      }
    }
    else
    {
      kdu_params::set(this, "Clevels", 0, 0, (int *)5);
    }
    if (kdu_params::get(this, "Cdecomp", 0, 0, v62, 0, 0, 1))
    {
      char v4 = 0;
      char v5 = 0;
      int v6 = 1;
      do
      {
        BOOL v7 = (~v62[0] & 3) != 0;
        BOOL v8 = v62[0] > 3u;
        char v9 = kdu_params::get(this, "Cdecomp", v6, 0, v62, 0, 0, 1);
        v5 |= v7;
        v4 |= v8;
        ++v6;
      }
      while ((v9 & 1) != 0);
      if (v5)
      {
        if ((kdu_params::get(this, "Cdfs", 0, 0, &v62[1], 0, 1, 1) & 1) == 0)
        {
          suitable_dfs_idx = (int *)cod_params::find_suitable_dfs_idx(this);
          v62[1] = (int)suitable_dfs_idx;
          kdu_params::set(this, "Cdfs", 0, 0, suitable_dfs_idx);
          if ((v4 & 1) == 0)
          {
LABEL_31:
            suitable_ads_idx = 0;
LABEL_36:
            v63[0] = (int)suitable_ads_idx;
            kdu_params::set(this, "Cads", 0, 0, suitable_ads_idx);
            goto LABEL_37;
          }
LABEL_34:
          if (kdu_params::get(this, "Cads", 0, 0, v63, 0, 1, 1)) {
            goto LABEL_37;
          }
          suitable_ads_idx = (int *)cod_params::find_suitable_ads_idx(this);
          goto LABEL_36;
        }
      }
      else
      {
        v62[1] = 0;
        kdu_params::set(this, "Cdfs", 0, 0, 0);
      }
      if ((v4 & 1) == 0) {
        goto LABEL_31;
      }
      goto LABEL_34;
    }
  }
LABEL_37:
  if ((kdu_params::get(this, "Cads", 0, 0, v63, 1, 1, 1) & 1) == 0) {
    v63[0] = 0;
  }
  if (kdu_params::get(this, "Cdfs", 0, 0, &v62[1], 1, 1, 1))
  {
    int v12 = v62[1];
  }
  else
  {
    int v12 = 0;
    v62[1] = 0;
  }
  int v13 = v63[0];
  if (v63[0] | v12 && a2)
  {
    if (v63[0] < 1)
    {
      uint64_t v15 = 0;
    }
    else
    {
      int v14 = (kdu_params *)kdu_params::access_cluster(this, "ADS");
      if (!v14 || (uint64_t v15 = kdu_params::access_relation(v14, *((_DWORD *)this + 4), -1, v13, 1)) == 0)
      {
        *(void *)&long long v66 = 0;
        *(_OWORD *)int v64 = 0u;
        long long v65 = 0u;
        kdu_error::kdu_error((kdu_error *)v64, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v64 + 16))(v64, "ADS table index encountered while finalizing COD/COD marker segment information does not refer to accessible ADS (Arbitrary Decomposition Styles) information.");
        kdu_error::~kdu_error((kdu_error *)v64);
      }
    }
    int v16 = v62[1];
    if (v62[1] < 1)
    {
      uint64_t v18 = 0;
    }
    else
    {
      int v17 = (kdu_params *)kdu_params::access_cluster(this, "DFS");
      if (!v17 || (uint64_t v18 = kdu_params::access_relation(v17, -1, -1, v16, 1)) == 0)
      {
        *(void *)&long long v66 = 0;
        *(_OWORD *)int v64 = 0u;
        long long v65 = 0u;
        kdu_error::kdu_error((kdu_error *)v64, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v64 + 16))(v64, "DFS table index encountered while finalizing COD/COD marker segment information does not refer to accessible DFS (Downsampling Factor Styles) information.");
        kdu_error::~kdu_error((kdu_error *)v64);
      }
    }
    if ((*((_DWORD *)this + 5) & 0x80000000) != 0)
    {
      if (v15)
      {
        int v33 = *((_DWORD *)this + 4);
        if ((v33 & 0x80000000) == 0)
        {
          int v34 = *((_DWORD *)this + 8);
          if (v34 < 1)
          {
            int v35 = 0;
          }
          else
          {
            int v35 = 0;
            while (kdu_params::access_unique(this, v33, v35, 0))
            {
              if (v34 == ++v35) {
                goto LABEL_185;
              }
            }
          }
          if (v35 == v34)
          {
LABEL_185:
            uint64_t v15 = 0;
            uint64_t v18 = 0;
            v62[1] = 0;
            v63[0] = 0;
          }
        }
      }
    }
    if (v15 | v18) {
      cod_params::derive_decomposition_structure(this, (kdu_params *)v18, (kdu_params *)v15);
    }
  }
  if ((kdu_params::get(this, "Cdecomp", 0, 0, v62, 1, 1, 1) & 1) == 0)
  {
    v62[0] = 3;
    kdu_params::set(this, "Cdecomp", 0, 0, (int *)3);
  }
  if ((a2 & 1) == 0)
  {
    if ((kdu_params::get(this, "Cads", 0, 0, v63, 1, 1, 1) & 1) == 0)
    {
      v63[0] = 0;
      kdu_params::set(this, "Cads", 0, 0, 0);
    }
    if ((kdu_params::get(this, "Cdfs", 0, 0, &v62[1], 1, 1, 1) & 1) == 0)
    {
      v62[1] = 0;
      kdu_params::set(this, "Cdfs", 0, 0, 0);
    }
  }
  if (v62[1] >= 1) {
    cod_params::validate_dfs_data((uint64_t)this, v62[1]);
  }
  if ((*((_DWORD *)this + 4) & 0x80000000) == 0 && v63[0] >= 1) {
    cod_params::validate_ads_data((uint64_t)this, v63[0]);
  }
  if ((a2 & 1) == 0)
  {
    int v19 = *((_DWORD *)this + 4);
    if ((*((_DWORD *)this + 5) & 0x80000000) != 0 && v19 < 0 && v62[1] >= 1 && *((int *)this + 8) >= 1)
    {
      int v36 = 0;
      do
        kdu_params::access_relation(this, -1, v36++, 0, 0);
      while (v36 < *((_DWORD *)this + 8));
      int v19 = *((_DWORD *)this + 4);
    }
    if (v19 < 0 && v63[0] >= 1 && *((int *)this + 7) >= 1)
    {
      int v20 = 0;
      do
        kdu_params::access_relation(this, v20++, *((_DWORD *)this + 5), 0, 0);
      while (v20 < *((_DWORD *)this + 7));
    }
  }
  BOOL v57 = 1;
  int v55 = 0;
  int v56 = 0;
  if ((kdu_params::get(this, "Catk", 0, 0, &v55, 1, 1, 1) & 1) == 0)
  {
    int v55 = 0;
    kdu_params::set(this, "Catk", 0, 0, 0);
  }
  int v21 = kdu_params::get(this, "Catk", 0, 0, &v55, 0, 1, 1);
  if (v55) {
    int v22 = v21;
  }
  else {
    int v22 = 0;
  }
  int v23 = kdu_params::get(this, "Ckernels", 0, 0, &v56, 0, 1, 1);
  if (v22)
  {
    if (v56 == -1) {
      char v24 = v23;
    }
    else {
      char v24 = 0;
    }
    if ((v24 & 1) == 0)
    {
      int v56 = -1;
      kdu_params::set(this, "Ckernels", 0, 0, (int *)0xFFFFFFFFLL);
    }
    goto LABEL_129;
  }
  if (v56 == -1) {
    int v25 = 0;
  }
  else {
    int v25 = v23;
  }
  if (v25 == 1)
  {
    char v26 = kdu_params::get(this, "Catk", 0, 0, &v55, 0, 1, 1);
    if (v55) {
      char v27 = 0;
    }
    else {
      char v27 = v26;
    }
    if ((v27 & 1) == 0)
    {
      int v55 = 0;
      kdu_params::set(this, "Catk", 0, 0, 0);
    }
    if (v56)
    {
      if (v56 != 1) {
        cod_params::finalize();
      }
      char v28 = kdu_params::get(this, "Creversible", 0, 0, &v57, 0, 1, 1);
      if (v57) {
        char v29 = v28;
      }
      else {
        char v29 = 0;
      }
      if ((v29 & 1) == 0)
      {
        BOOL v57 = 1;
        kdu_params::set((uint64_t)this, "Creversible", 0, 0, 1);
      }
    }
    else
    {
      char v37 = kdu_params::get(this, "Creversible", 0, 0, &v57, 0, 1, 1);
      if (v57) {
        char v38 = 0;
      }
      else {
        char v38 = v37;
      }
      if ((v38 & 1) == 0)
      {
        BOOL v57 = 0;
        kdu_params::set((uint64_t)this, "Creversible", 0, 0, 0);
      }
    }
    goto LABEL_129;
  }
  if (!kdu_params::get(this, "Creversible", 0, 0, &v57, 0, 1, 1)) {
    goto LABEL_129;
  }
  char v30 = kdu_params::get(this, "Catk", 0, 0, &v55, 1, 1, 1);
  int v31 = v55;
  if (v55) {
    char v32 = v30;
  }
  else {
    char v32 = 0;
  }
  if ((v32 & 1) == 0)
  {
    if ((kdu_params::get(this, "Ckernels", 0, 0, &v56, 1, 1, 1) & 1) == 0 || v56 != v57)
    {
      int v56 = v57;
      kdu_params::set(this, "Ckernels", 0, 0, (int *)v57);
    }
LABEL_129:
    int v31 = v55;
    if (!v55) {
      goto LABEL_142;
    }
  }
  v52[4] = 0;
  int v39 = (kdu_params *)kdu_params::access_cluster(this, "ATK");
  if (!v39
    || (long long v40 = (kdu_params *)kdu_params::access_relation(v39, *((_DWORD *)this + 4), -1, v31, 1)) == 0
    || (kdu_params::get(v40, "Kreversible", 0, 0, &v52[4], 1, 1, 1) & 1) == 0)
  {
    uint64_t v60 = 0;
    *(_OWORD *)char v58 = 0u;
    long long v59 = 0u;
    kdu_error::kdu_error((kdu_error *)v58, "Kakadu Core Error:\n");
    (*(void (**)(int *, const char *))(*(void *)v58 + 16))(v58, " ");
    long long v67 = 0u;
    long long v68 = 0u;
    long long v65 = 0u;
    long long v66 = 0u;
    *(_OWORD *)int v64 = 0u;
    if (LOBYTE(v58[2])) {
      sprintf(v64, "%x");
    }
    else {
      sprintf(v64, "%d");
    }
    (*(void (**)(int *, char *))(*(void *)v58 + 16))(v58, v64);
    kdu_error::~kdu_error((kdu_error *)v58);
  }
  char v41 = kdu_params::get(this, "Creversible", 0, 0, &v57, 0, 1, 1);
  if (v57 == v52[4]) {
    char v42 = v41;
  }
  else {
    char v42 = 0;
  }
  if ((v42 & 1) == 0)
  {
    BOOL v57 = v52[4];
    kdu_params::set((uint64_t)this, "Creversible", 0, 0, v52[4]);
  }
LABEL_142:
  if (((kdu_params::get(this, "Creversible", 0, 0, &v57, 1, 1, 1) | a2) & 1) == 0)
  {
    BOOL v57 = 0;
    kdu_params::set((uint64_t)this, "Creversible", 0, 0, 0);
  }
  uint64_t result = kdu_params::get(this, "Ckernels", 0, 0, &v56, 1, 1, 1);
  if (((result | a2) & 1) == 0)
  {
    int v56 = 0;
    uint64_t result = (uint64_t)kdu_params::set(this, "Ckernels", 0, 0, 0);
  }
  if (v55)
  {
    if ((v55 - 256) <= 0xFFFFFF01)
    {
      *(void *)&long long v66 = 0;
      *(_OWORD *)int v64 = 0u;
      long long v65 = 0u;
      kdu_error::kdu_error((kdu_error *)v64, "Kakadu Core Error:\n");
      (*(void (**)(char *, const char *))(*(void *)v64 + 16))(v64, "Illegal ATK instance index found when finalizing a COD/COC marker segment.  Legal values are in the range 2 to 255.");
      kdu_error::~kdu_error((kdu_error *)v64);
    }
  }
  else if (v56 != v57)
  {
    *(void *)&long long v66 = 0;
    *(_OWORD *)int v64 = 0u;
    long long v65 = 0u;
    kdu_error::kdu_error((kdu_error *)v64, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)v64);
  }
  if ((a2 & 1) == 0)
  {
    if ((kdu_params::get(this, "Cblk", 0, 0, &v63[1], 1, 1, 1) & 1) == 0)
    {
      if (kdu_params::get(this, "Cblk", 0, 1, &v63[1], 1, 1, 1)) {
        cod_params::finalize();
      }
      kdu_params::set(this, "Cblk", 0, 0, (int *)0x40);
      kdu_params::set(this, "Cblk", 0, 1, (int *)0x40);
    }
    if ((kdu_params::get(this, "Cmodes", 0, 0, &v63[1], 1, 1, 1) & 1) == 0) {
      kdu_params::set(this, "Cmodes", 0, 0, 0);
    }
    BOOL v54 = 0;
    if ((kdu_params::get(this, "Cycc", 0, 0, &v54, 1, 1, 1) & 1) == 0)
    {
      if ((*((_DWORD *)this + 5) & 0x80000000) == 0) {
        cod_params::finalize();
      }
      int v44 = *((_DWORD *)this + 8);
      BOOL v54 = 0;
      long long v45 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
      *(_DWORD *)int v64 = 0;
      kdu_params::get(v45, "Mcomponents", 0, 0, (int *)v64, 1, 1, 1);
      if (v44 >= 3 && !*(_DWORD *)v64)
      {
        v58[0] = 0;
        BOOL v53 = 0;
        *(void *)int v52 = 0;
        if (!v45) {
          cod_params::finalize();
        }
        int v46 = 0;
        int v47 = 0;
        int v48 = 0;
        BOOL v49 = 0;
        int v50 = 0;
        while (1)
        {
          int v51 = (kdu_params *)kdu_params::access_relation(this, *((_DWORD *)this + 4), v46, 0, 1);
          if (!kdu_params::get(v51, "Creversible", 0, 0, &v53, 1, 1, 1)
            || !kdu_params::get(v45, "Sprecision", v46, 0, v58, 1, 1, 1)
            || !kdu_params::get(v45, "Ssampling", v46, 0, (int *)v52, 1, 1, 1)
            || (kdu_params::get(v45, "Ssampling", v46, 1, (int *)&v52[4], 1, 1, 1) & 1) == 0)
          {
            cod_params::finalize();
          }
          if (v46 && (v49 != v53 || v58[0] != v50 || *(_DWORD *)&v52[4] != v48 || *(_DWORD *)v52 != v47)) {
            break;
          }
          ++v46;
          int v47 = *(_DWORD *)v52;
          int v48 = *(_DWORD *)&v52[4];
          BOOL v49 = v53;
          int v50 = v58[0];
          if (v46 == 3)
          {
            BOOL v54 = 1;
            break;
          }
        }
      }
      kdu_params::set((uint64_t)this, "Cycc", 0, 0, v54);
    }
    if (v54 && *((int *)this + 8) <= 2) {
      kdu_params::set((uint64_t)this, "Cycc", 0, 0, 0);
    }
    if (kdu_params::get(this, "Cprecincts", 0, 0, &v63[1], 0, 0, 1)) {
      kdu_params::set((uint64_t)this, "Cuse_precincts", 0, 0, 1);
    }
    uint64_t result = kdu_params::get(this, "Cuse_precincts", 0, 0, &v61, 1, 1, 1);
    if ((result & 1) == 0) {
      return kdu_params::set((uint64_t)this, "Cuse_precincts", 0, 0, 0);
    }
  }
  return result;
}

void sub_18869D760(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18869D76C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  _Unwind_Resume(v21);
}

uint64_t cod_params::find_suitable_dfs_idx(cod_params *this)
{
  int v19 = 0;
  int v2 = *((_DWORD *)this + 5);
  if ((*((_DWORD *)this + 4) & 0x80000000) != 0)
  {
    int v5 = 0;
    if (v2 < 0)
    {
LABEL_14:
      uint64_t v4 = (v5 + 1);
      int v19 = v5 + 1;
      int v13 = (kdu_params *)kdu_params::access_cluster(this, "DFS");
      if (!v13) {
        return v4;
      }
      kdu_params::access_relation(v13, -1, -1, v5 + 1, 0);
    }
    else
    {
      int v6 = -1;
      while (1)
      {
        BOOL v7 = (kdu_params *)kdu_params::access_unique(this, -1, v6, 0);
        if (v7)
        {
          BOOL v8 = v7;
          if (kdu_params::get(v7, "Cdfs", 0, 0, &v19, 1, 1, 1))
          {
            int v9 = v19;
            if (v19)
            {
              int v10 = 0;
              int v15 = 3;
              v16[0] = 3;
              do
              {
                int v11 = kdu_params::get(this, "Cdecomp", v10, 0, v16, 0, 0, 1);
                int v12 = kdu_params::get(v8, "Cdecomp", v10, 0, &v15, 0, 0, 1);
                if (((v15 ^ LOBYTE(v16[0])) & 3) != 0) {
                  break;
                }
                ++v10;
              }
              while (((v11 | v12) & 1) != 0);
              int v5 = v9;
              if (((v15 ^ LOBYTE(v16[0])) & 3) == 0) {
                break;
              }
            }
          }
        }
        if (++v6 >= *((_DWORD *)this + 5)) {
          goto LABEL_14;
        }
      }
    }
    return v19;
  }
  BOOL v3 = (kdu_params *)kdu_params::access_relation(this, -1, v2, 0, 0);
  kdu_params::get(v3, "Cdfs", 0, 0, &v19, 1, 1, 1);
  uint64_t v4 = v19;
  if (!v19)
  {
    uint64_t v18 = 0;
    *(_OWORD *)int v16 = 0u;
    long long v17 = 0u;
    kdu_error::kdu_error((kdu_error *)v16, "Kakadu Core Error:\n");
    kdu_error::~kdu_error((kdu_error *)v16);
  }
  return v4;
}

void sub_18869DA04(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18869DA10()
{
  _Unwind_Resume(v0);
}

uint64_t cod_params::find_suitable_ads_idx(cod_params *this)
{
  int v2 = (kdu_params *)kdu_params::access_cluster(this, "ADS");
  int v17 = 0;
  int v3 = *((_DWORD *)this + 4);
  uint64_t v4 = kdu_params::access_unique(v2, v3, -1, 0);
  char v5 = v4 != 0;
  LODWORD(v6) = 0;
  if (v4) {
    uint64_t v7 = v4;
  }
  else {
    uint64_t v7 = (uint64_t)v2;
  }
  if (v7)
  {
    while (1)
    {
      uint64_t v8 = *(unsigned int *)(v7 + 24);
      if (((kdu_params::get((kdu_params *)v7, "Ddecomp", 0, 0, &v17, 1, 1, 1) & 1) != 0
         || (kdu_params::get((kdu_params *)v7, "DOads", 0, 0, &v17, 1, 1, 1) & 1) != 0
         || kdu_params::get((kdu_params *)v7, "DSads", 0, 0, &v17, 1, 1, 1))
        && (int)v8 > (int)v6)
      {
        int v9 = 0;
        uint64_t v6 = v8;
        int v15 = 3;
        int v16 = 3;
        do
        {
          int v10 = kdu_params::get(this, "Cdecomp", v9, 0, &v16, 0, 0, 1);
          int v11 = kdu_params::get((kdu_params *)v7, "Ddecomp", v9, 0, &v15, 0, 0, 1);
          if (v16 != v15) {
            break;
          }
          ++v9;
        }
        while (((v10 | v11) & 1) != 0);
        if (v16 == v15) {
          break;
        }
      }
      uint64_t v12 = *(void *)(v7 + 88);
      if (v5) {
        int v13 = v2;
      }
      else {
        int v13 = 0;
      }
      if (v12) {
        uint64_t v7 = *(void *)(v7 + 88);
      }
      else {
        uint64_t v7 = (uint64_t)v13;
      }
      v5 &= v12 != 0;
      if (!v7)
      {
        int v3 = *((_DWORD *)this + 4);
        goto LABEL_21;
      }
    }
  }
  else
  {
LABEL_21:
    uint64_t v6 = (v6 + 1);
    kdu_params::access_relation(v2, v3, -1, v6, 0);
  }
  return v6;
}

uint64_t cod_params::derive_decomposition_structure(cod_params *this, kdu_params *a2, kdu_params *a3)
{
  int v32 = 0;
  if (a3)
  {
    LOBYTE(v6) = 1;
    int v30 = 3;
    int v31 = 1;
    int v29 = 0;
    int v7 = kdu_params::get(a3, "DOads", 0, 0, &v31, 1, 0, 1) ^ 1;
    int v8 = kdu_params::get(a3, "DSads", 0, 0, &v29, 1, 0, 1) ^ 1;
    char v24 = a2;
    if (a2) {
      int v6 = kdu_params::get(a2, "DSdfs", 0, 0, &v30, 1, 0, 1) ^ 1;
    }
    int v9 = 0;
    int v10 = 1;
    int v25 = this;
    while (1)
    {
      int v11 = (int *)(v30 & 3);
      char v27 = v7;
      char v28 = v6;
      int v26 = v9;
      if ((v11 - 1) < 2) {
        break;
      }
      if ((v30 & 3) != 0)
      {
        int v12 = 2;
LABEL_9:
        int v13 = 10 * v12 + 2;
        do
        {
          int v14 = v31;
          if (v31 != 1)
          {
            int v15 = v29;
            if (v8)
            {
              LOBYTE(v8) = 1;
            }
            else
            {
              int v8 = kdu_params::get(a3, "DSads", v10, 0, &v29, 1, 0, 1) ^ 1;
              int v14 = v31;
              ++v10;
            }
            int v11 = (int *)(v11 | (v15 << (10 * v12 + 2)));
            if (v15)
            {
              if (v14 != 2)
              {
                if (v15 == 3) {
                  int v16 = 4;
                }
                else {
                  int v16 = 2;
                }
                int v17 = v16 | 1;
                int v18 = v13 + 2 * v16;
                do
                {
                  int v19 = v29;
                  if (v8) {
                    LOBYTE(v8) = 1;
                  }
                  else {
                    int v8 = kdu_params::get(a3, "DSads", v10++, 0, &v29, 1, 0, 1) ^ 1;
                  }
                  int v11 = (int *)(v11 | (v19 << v18));
                  --v17;
                  v18 -= 2;
                }
                while (v17 > 1);
              }
            }
          }
          v13 -= 10;
        }
        while (v12-- > 0);
      }
      kdu_params::set(v25, "Cdecomp", v26, 0, v11);
      int v9 = v26 + 1;
      if (v28) {
        int v6 = 1;
      }
      else {
        int v6 = kdu_params::get(v24, "DSdfs", v9, 0, &v30, 1, 0, 1) ^ 1;
      }
      if (v27) {
        int v7 = 1;
      }
      else {
        int v7 = kdu_params::get(a3, "DOads", v9, 0, &v31, 1, 0, 1) ^ 1;
      }
      if (v31 < 2) {
        char v21 = v7;
      }
      else {
        char v21 = 0;
      }
      LOBYTE(v8) = v21 | v8;
      if (v6 & v7) == 1 && (v8)
      {
        uint64_t result = cod_params::is_valid_decomp_terminator((cod_params *)v11);
        if (result) {
          return result;
        }
      }
    }
    int v12 = 0;
    goto LABEL_9;
  }
  if (!a2) {
    cod_params::derive_decomposition_structure();
  }
  uint64_t result = kdu_params::get(a2, "DSdfs", 0, 0, &v32, 1, 0, 1);
  if (result)
  {
    int v23 = 0;
    do
    {
      kdu_params::set(this, "Cdecomp", v23++, 0, (int *)v32);
      uint64_t result = kdu_params::get(a2, "DSdfs", v23, 0, &v32, 1, 0, 1);
    }
    while ((result & 1) != 0);
  }
  return result;
}

uint64_t cod_params::validate_dfs_data(uint64_t this, int a2)
{
  if (a2)
  {
    int v3 = (kdu_params *)this;
    uint64_t v4 = (kdu_params *)kdu_params::access_cluster((kdu_params *)this, "DFS");
    if (!v4 || (char v5 = (kdu_params *)kdu_params::access_relation(v4, -1, -1, a2, 1)) == 0) {
      cod_params::validate_dfs_data();
    }
    int v6 = v5;
    int v13 = 0;
    char v7 = kdu_params::get(v5, "DSdfs", 0, 0, &v13, 1, 1, 1);
    this = kdu_params::get(v3, "Cdecomp", 0, 0, &v13, 1, 0, 1);
    if (this)
    {
      int v8 = 1;
      do
      {
        int v9 = v8 - 1;
        int v10 = v13 & 3;
        if (v7)
        {
          v11[0] = 0;
          if (!kdu_params::get(v6, "DSdfs", v9, 0, v11, 1, 1, 1) || v11[0] != v10)
          {
            uint64_t v12 = 0;
            memset(v11, 0, sizeof(v11));
            kdu_error::kdu_error((kdu_error *)v11, "Kakadu Core Error:\n");
            kdu_error::~kdu_error((kdu_error *)v11);
          }
        }
        else
        {
          kdu_params::set(v6, "DSdfs", v9, 0, (int *)(v13 & 3));
        }
        this = kdu_params::get(v3, "Cdecomp", v8++, 0, &v13, 1, 0, 1);
      }
      while ((this & 1) != 0);
    }
  }
  return this;
}

void sub_18869E164(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18869E170()
{
  _Unwind_Resume(v0);
}

uint64_t cod_params::validate_ads_data(uint64_t this, int a2)
{
  int v19[2] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    int v3 = (int *)this;
    uint64_t v4 = (kdu_params *)kdu_params::access_cluster((kdu_params *)this, "ADS");
    if (!v4 || (char v5 = (kdu_params *)kdu_params::access_relation(v4, v3[4], -1, a2, 1)) == 0) {
      cod_params::validate_ads_data();
    }
    int v6 = v5;
    v18[0] = 0;
    char v7 = kdu_params::get(v5, "Ddecomp", 0, 0, v18, 1, 1, 1);
    this = kdu_params::get((kdu_params *)v3, "Cdecomp", 0, 0, v18, 1, 0, 1);
    int v8 = this;
    if (this)
    {
      int v9 = 1;
      do
      {
        int v10 = v9 - 1;
        int v11 = v18[0];
        if (v7)
        {
          LODWORD(v15) = 0;
          char v12 = kdu_params::get(v6, "Ddecomp", v10, 0, (int *)&v15, 1, 1, 1);
          if (v15 == v11) {
            char v13 = v12;
          }
          else {
            char v13 = 0;
          }
          if ((v13 & 1) == 0)
          {
            uint64_t v17 = 0;
            long long v15 = 0u;
            long long v16 = 0u;
            kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v15 + 16))(&v15, "Unacceptable interaction between ADS (Arbitrary Decomposition Style) and DFS (Downsampling Factor Styles) information in Part-2 codestream.  It makes no sense to use the same ADS table for two tile-components which have different downsampling factor styles, since downsampling styles have a strong effect on the interpretation of information recorded in the ADS marker segment.");
            kdu_error::~kdu_error((kdu_error *)&v15);
          }
        }
        else
        {
          kdu_params::set(v6, "Ddecomp", v10, 0, (int *)v18[0]);
        }
        this = kdu_params::get((kdu_params *)v3, "Cdecomp", v9++, 0, v18, 1, 0, 1);
      }
      while ((this & 1) != 0);
      if (v8)
      {
        int v14 = (char *)v18[0];
        this = cod_params::is_valid_decomp_terminator((cod_params *)v18[0]);
        if ((this & 1) == 0)
        {
          *(void *)&v18[1] = 0;
          v19[0] = 0;
          *(void *)((char *)v19 + 5) = 0;
          cod_params::textualize_decomp((char *)&v18[1], v14);
          uint64_t v17 = 0;
          long long v15 = 0u;
          long long v16 = 0u;
          kdu_error::kdu_error((kdu_error *)&v15, "Kakadu Core Error:\n");
          (*(void (**)(long long *, const char *))(v15 + 16))(&v15, ", \"");
          (*(void (**)(long long *, int *))(v15 + 16))(&v15, &v18[1]);
          (*(void (**)(long long *, const char *))(v15 + 16))(&v15, "\".  ");
          kdu_error::~kdu_error((kdu_error *)&v15);
        }
      }
    }
  }
  return this;
}

void sub_18869E4C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18869E4D0()
{
  _Unwind_Resume(v0);
}

BOOL cod_params::is_valid_decomp_terminator(cod_params *this)
{
  if ((~this & 3) != 0
    || (v1 = 0, unsigned int v2 = (this >> 2) & 0x3FF, v2 == ((this >> 12) & 0x3FF))
    && v2 == this >> 22)
  {
    if (!(this >> 4)) {
      return 1;
    }
    unsigned int v3 = (this >> 2) & 3;
    if (v3 == 3)
    {
      if ((this >> 4) == 255) {
        return 1;
      }
    }
    else
    {
      if (v3 != 2) {
        return v3 != 1 || (this & 0xF0) == 0x50;
      }
      if ((this & 0xF0) == 0xC0) {
        return 1;
      }
    }
    return 0;
  }
  return v1;
}

char *cod_params::textualize_decomp(char *this, char *a2)
{
  int v2 = a2 & 3;
  char v3 = 72;
  switch(a2 & 3)
  {
    case 1:
      goto LABEL_5;
    case 2:
      int v2 = 1;
      char v3 = 86;
      goto LABEL_5;
    case 3:
      int v2 = 3;
      char v3 = 66;
LABEL_5:
      int v5 = 0;
      *this = v3;
      uint64_t v4 = this + 2;
      int v6 = (int)a2 >> 2;
      this[1] = 40;
      do
      {
        if (v5) {
          *v4++ = 58;
        }
        if ((v6 & 3) != 0) {
          int v7 = 3;
        }
        else {
          int v7 = 1;
        }
        if ((v6 & 3) == 3) {
          int v8 = 5;
        }
        else {
          int v8 = v7;
        }
        int v9 = v8 + 1;
        int v10 = v6;
        do
        {
          *v4++ = 0x4256482Du >> (8 * (v10 & 3));
          v10 >>= 2;
          --v9;
        }
        while (v9 > 1);
        ++v5;
        v6 >>= 10;
      }
      while (v5 != v2);
      break;
    default:
      *(_WORD *)this = 10285;
      uint64_t v4 = this + 2;
      break;
  }
  *(_WORD *)uint64_t v4 = 41;
  if (v4 - this + 1 >= 21) {
    cod_params::textualize_decomp();
  }
  return this;
}

uint64_t cod_params::custom_textualize_field(cod_params *this, kdu_message *a2, const char *__s1, int a4, char *a5)
{
  int v10[2] = *MEMORY[0x1E4F143B8];
  uint64_t result = strcmp(__s1, "Cdecomp");
  if (!(result | a4))
  {
    uint64_t v9 = 0;
    v10[0] = 0;
    *(void *)((char *)v10 + 5) = 0;
    cod_params::textualize_decomp((char *)&v9, a5);
    return (*(uint64_t (**)(kdu_message *, uint64_t *))(*(void *)a2 + 16))(a2, &v9);
  }
  return result;
}

uint64_t cod_params::custom_parse_field(cod_params *this, const char *a2, const char *__s1, int a4, int *a5)
{
  if (strcmp(__s1, "Cdecomp") | a4) {
    goto LABEL_2;
  }
  int v8 = *a2;
  if (v8 <= 71)
  {
    if (v8 == 45)
    {
      *a5 = 0;
      if (a2[1] == 40)
      {
        int v11 = a2 + 2;
        goto LABEL_39;
      }
      goto LABEL_2;
    }
    if (v8 == 66)
    {
      int v9 = 3;
      int v10 = 3;
      goto LABEL_13;
    }
LABEL_2:
    uint64_t result = 0;
    *a5 = 0;
    return result;
  }
  if (v8 == 72)
  {
    int v9 = 1;
    int v10 = 1;
  }
  else
  {
    if (v8 != 86) {
      goto LABEL_2;
    }
    int v10 = 1;
    int v9 = 2;
  }
LABEL_13:
  *a5 = v9;
  if (a2[1] != 40) {
    goto LABEL_2;
  }
  int v12 = 0;
  int v11 = a2 + 2;
  do
  {
    if (v12)
    {
      int v13 = *(unsigned __int8 *)v11;
      if (v13 != 44 && v13 != 58) {
        goto LABEL_2;
      }
      ++v11;
    }
    int v14 = 0;
    uint64_t v15 = 0;
    int v16 = 0;
    int v17 = 1;
    do
    {
      int v18 = v11[v15];
      switch(v18)
      {
        case '-':
          int v19 = 0;
          int v20 = 0;
          if (v15) {
            goto LABEL_37;
          }
LABEL_31:
          unsigned int v21 = v11[v15 + 1];
          BOOL v22 = v21 > 0x3A;
          uint64_t v23 = (1 << v21) & 0x400120000000000;
          if (v22 || v23 == 0) {
            v17 += 2 * (v18 != 45) + v19;
          }
          goto LABEL_37;
        case 'B':
          int v20 = 3;
          int v19 = 2;
          if (v15) {
            goto LABEL_37;
          }
          goto LABEL_31;
        case 'H':
          int v19 = 0;
          int v20 = 1;
          if (v15) {
            goto LABEL_37;
          }
          goto LABEL_31;
      }
      if (v18 != 86) {
        goto LABEL_2;
      }
      int v19 = 0;
      int v20 = 2;
      if (!v15) {
        goto LABEL_31;
      }
LABEL_37:
      v16 += v20 << v14;
      ++v15;
      v14 += 2;
    }
    while ((int)v15 < v17);
    v9 |= v16 << (10 * v12 + 2);
    *a5 = v9;
    ++v12;
    v11 += v15;
  }
  while (v12 != v10);
LABEL_39:
  if (*v11 != 41) {
    goto LABEL_2;
  }
  return (v11 - a2 + 1);
}

uint64_t cod_params::expand_decomp_bands(uint64_t this, uint64_t a2, __int16 *a3)
{
  int v3 = this;
  int v4 = 0;
  LODWORD(this) = 0;
  int v5 = v3 & 1;
  int v6 = (v3 >> 1) & 1;
  uint64_t v7 = (v3 >> 2);
  while (2)
  {
    int v8 = 0;
    do
    {
      if (!(v8 | v4))
      {
        __int16 v23 = v3 & 1 | ((_WORD)v6 << 8);
        uint64_t v9 = v7;
LABEL_22:
        *(_WORD *)(a2 + 2 * (int)this) = v23;
        this = (this + 1);
        goto LABEL_23;
      }
      uint64_t v9 = ((int)v7 >> 10);
      if ((v7 & 3) == 0)
      {
        __int16 v23 = (((_WORD)v6 << 8) | ((_WORD)v4 << 10) | v5) + 4 * v8;
        goto LABEL_22;
      }
      int v10 = 0;
      int v11 = v7 & 1;
      unsigned int v12 = (v7 >> 1) & 1;
      __int16 v13 = (v7 & 1) + v5;
      do
      {
        int v14 = 0;
        int v15 = (v10 << v6) | v4;
        int v16 = v7;
        do
        {
          int v17 = (v14 << v5) | v8;
          LODWORD(v7) = v16 >> 2;
          if ((v16 & 0xC) != 0)
          {
            int v18 = 0;
            int v19 = (v16 >> 3) & 1;
            do
            {
              uint64_t v20 = 0;
              int v21 = this;
              do
              {
                *(_WORD *)(a2 + 2 * (int)this + 2 * v20) = (((v7 & 1) + v13) | (((_WORD)v19
                                                                                 + (_WORD)v12
                                                                                 + ((v3 >> 1) & 1)) << 8))
                                                           + (((unsigned __int16)((_WORD)v18 << (v12 + ((v3 & 2) != 0))) | (unsigned __int16)v15) << 10)
                                                           + 4 * (((_WORD)v20 << v13) | v17);
                ++v20;
              }
              while ((v7 & 1) + 1 != v20);
              LODWORD(this) = this + v20;
              BOOL v22 = v18++ == v19;
            }
            while (!v22);
            this = (v21 + v20);
          }
          else
          {
            *(_WORD *)(a2 + 2 * (int)this) = ((((_WORD)v12 + (_WORD)v6) << 8) | ((_WORD)v15 << 10) | v13) + 4 * v17;
            this = (this + 1);
          }
          int v16 = v7;
          BOOL v22 = v14++ == v11;
        }
        while (!v22);
        BOOL v22 = v10++ == v12;
      }
      while (!v22);
LABEL_23:
      uint64_t v7 = v9;
      BOOL v22 = v8++ == v5;
    }
    while (!v22);
    BOOL v22 = v4++ == v6;
    if (!v22) {
      continue;
    }
    break;
  }
  if ((int)this >= 50) {
    cod_params::expand_decomp_bands();
  }
  return this;
}

void ads_params::ads_params(ads_params *this)
{
  *((void *)this + 1) = "ADS";
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18898D540;
  *((_WORD *)this + 20) = 1;
  *((unsigned char *)this + 42) = 1;
  *((void *)this + 6) = this;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 9) = this;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = this;
  *((unsigned char *)this + 104) = 0;
  *((_DWORD *)this + 9) = 65537;
  *((void *)this + 14) = 0;
  *(void *)this = &unk_1ED4DE628;
}

void sub_18869EBDC(_Unwind_Exception *a1)
{
  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t ads_params::finalize(uint64_t this, char a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (a2) {
    return this;
  }
  int v2 = (kdu_params *)this;
  v23[0] = 0;
  this = kdu_params::get((kdu_params *)this, "Ddecomp", 0, 0, v23, 0, 0, 0);
  int v20 = this;
  if (!this) {
    return this;
  }
  int v3 = 0;
  int v4 = 0;
  do
  {
    if ((*((_DWORD *)v2 + 6) - 128) <= 0xFFFFFF80)
    {
      *(void *)&long long v25 = 0;
      *(_OWORD *)&v23[1] = 0u;
      long long v24 = 0u;
      kdu_error::kdu_error((kdu_error *)&v23[1], "Kakadu Core Error:\n");
      kdu_error::~kdu_error((kdu_error *)&v23[1]);
    }
    if ((v23[0] & 3u) - 1 >= 2)
    {
      if ((v23[0] & 3) != 3)
      {
        int v7 = 0;
        char v6 = v23[0] == 0;
        int v5 = -1;
        goto LABEL_12;
      }
      int v5 = 2;
      char v6 = 1;
    }
    else
    {
      int v5 = 0;
      char v6 = v23[0] < 0x1000u;
    }
    int v7 = 1;
LABEL_12:
    for (int i = 8; i != 38; i += 10)
    {
      int v9 = (v23[0] >> (i - 6)) & 3;
      char v10 = (((v23[0] >> i) & 0xF) == 0) & v6;
      if (!v9) {
        v6 &= (v23[0] >> (i - 4)) == 0;
      }
      if ((v9 - 1) < 2) {
        char v6 = v10;
      }
    }
    if ((v6 & 1) == 0)
    {
      uint64_t v22 = 0;
      memset(v21, 0, sizeof(v21));
      kdu_error::kdu_error((kdu_error *)v21, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v21[0] + 16))(v21, ", 0x");
      BYTE8(v21[0]) = 1;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v24 = 0u;
      long long v25 = 0u;
      *(_OWORD *)&v23[1] = 0u;
      sprintf((char *)&v23[1], "%x", v23[0]);
      (*(void (**)(_OWORD *, int *))(*(void *)&v21[0] + 16))(v21, &v23[1]);
      BYTE8(v21[0]) = 0;
      (*(void (**)(_OWORD *, const char *))(*(void *)&v21[0] + 16))(v21, ".");
      kdu_error::~kdu_error((kdu_error *)v21);
    }
    if (!v4)
    {
      kdu_params::delete_unparsed_attribute((uint64_t)v2, "DOads");
      kdu_params::delete_unparsed_attribute((uint64_t)v2, "DSads");
    }
    unsigned int v11 = ((unsigned __int16)(v23[0] >> 2) | (unsigned __int16)(v23[0] >> 12)) & 0x3FF | (v23[0] >> 22);
    if (v11)
    {
      if (v11 < 4) {
        uint64_t v12 = 2;
      }
      else {
        uint64_t v12 = 3;
      }
      kdu_params::set(v2, "DOads", v4, 0, (int *)v12);
      if (v7)
      {
        int v13 = v3;
        do
        {
          int v14 = v23[0] >> (10 * v5 + 2);
          kdu_params::set(v2, "DSads", v13, 0, (int *)(v14 & 3));
          int v3 = v13 + 1;
          if ((v14 & 3) != 0 && v11 >= 4)
          {
            if ((v14 & 3) == 3) {
              int v16 = 4;
            }
            else {
              int v16 = 2;
            }
            int v17 = v16 + v13 + 1;
            int v18 = 2 * v16;
            do
            {
              kdu_params::set(v2, "DSads", v3++, 0, (int *)(((unsigned __int16)(v14 & 0x3FF) >> v18) & 3));
              v18 -= 2;
            }
            while (v18);
            int v3 = v17;
          }
          int v13 = v3;
        }
        while (v5-- > 0);
      }
    }
    else
    {
      kdu_params::set(v2, "DOads", v4, 0, (int *)1);
    }
    this = kdu_params::get(v2, "Ddecomp", ++v4, 0, v23, 0, 0, 0);
  }
  while ((this & 1) != 0);
  if (v20)
  {
    this = cod_params::is_valid_decomp_terminator((cod_params *)v23[0]);
    if ((this & 1) == 0) {
      ads_params::finalize();
    }
  }
  return this;
}

void sub_18869F04C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_18869F058(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

uint64_t ads_params::write_marker_segment(ads_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  int v4 = *((_DWORD *)this + 6);
  if (v4 < 1) {
    return 0;
  }
  uint64_t v5 = 0;
  if (a4 || v4 > 0x7F) {
    return v5;
  }
  if ((*((_DWORD *)this + 5) & 0x80000000) == 0) {
    return 0;
  }
  int v30 = 0;
  if (a3)
  {
    if ((*((_DWORD *)a3 + 4) & 0x80000000) == 0 || *((_DWORD *)a3 + 6) != v4) {
      ads_params::write_marker_segment();
    }
    int v10 = 0;
    while ((kdu_params::get(this, "DOads", v10, 0, &v30, 0, 0, 1) & 1) != 0)
    {
      int v11 = v30;
      int v31 = 0;
      if (kdu_params::get(a3, "DOads", v10, 0, &v31, 1, 1, 1))
      {
        ++v10;
        if (v31 == v11) {
          continue;
        }
      }
      goto LABEL_27;
    }
    while ((kdu_params::get(a3, "DOads", v10, 0, &v30, 0, 0, 1) & 1) != 0)
    {
      int v12 = v30;
      int v31 = 0;
      if (kdu_params::get(this, "DOads", v10, 0, &v31, 1, 1, 1))
      {
        ++v10;
        if (v31 == v12) {
          continue;
        }
      }
      goto LABEL_27;
    }
    int v13 = 0;
    while ((kdu_params::get(this, "DSads", v13, 0, &v30, 0, 0, 1) & 1) != 0)
    {
      int v14 = v30;
      int v31 = 0;
      if (kdu_params::get(a3, "DSads", v13, 0, &v31, 1, 1, 1))
      {
        ++v13;
        if (v31 == v14) {
          continue;
        }
      }
      goto LABEL_27;
    }
    while (kdu_params::get(a3, "DSads", v13, 0, &v30, 0, 0, 1))
    {
      int v15 = v30;
      int v31 = 0;
      if (kdu_params::get(this, "DSads", v13, 0, &v31, 1, 1, 1))
      {
        ++v13;
        if (v31 == v15) {
          continue;
        }
      }
      goto LABEL_27;
    }
    return 0;
  }
LABEL_27:
  int v16 = -1;
  do
    ++v16;
  while ((kdu_params::get(this, "DOads", v16, 0, &v30, 0, 0, 1) & 1) != 0);
  int v17 = -1;
  do
    ++v17;
  while ((kdu_params::get(this, "DSads", v17, 0, &v30, 0, 0, 1) & 1) != 0);
  if (!(v17 | v16)) {
    return 0;
  }
  uint64_t v5 = ((v16 + 3) >> 2) + ((v17 + 3) >> 2) + 7;
  if (a2)
  {
    kdu_output::put(a2, 255);
    kdu_output::put(a2, 115);
    kdu_output::put(a2, (unsigned __int16)(((v16 + 3) >> 2) + ((v17 + 3) >> 2) + 5) >> 8);
    kdu_output::put(a2, ((v16 + 3) >> 2) + ((v17 + 3) >> 2) + 5);
    int v18 = kdu_output::put(a2, *((unsigned char *)this + 24));
    int v19 = v18 + kdu_output::put(a2, v16) + 4;
    if (v16)
    {
      int v20 = 0;
      int v21 = 0;
      unsigned __int8 v22 = 8;
      do
      {
        kdu_params::get(this, "DOads", v21, 0, &v30, 1, 1, 1);
        v22 -= 2;
        v20 |= v30 << v22;
        if (!v22)
        {
          int v23 = kdu_output::put(a2, v20);
          int v20 = 0;
          v19 += v23;
          unsigned __int8 v22 = 8;
        }
        ++v21;
      }
      while (v16 != v21);
      if (v22 <= 7u) {
        v19 += kdu_output::put(a2, v20);
      }
    }
    int v24 = kdu_output::put(a2, v17) + v19;
    if (v17)
    {
      int v25 = 0;
      int v26 = 0;
      unsigned __int8 v27 = 8;
      do
      {
        kdu_params::get(this, "DSads", v26, 0, &v30, 1, 1, 1);
        int v28 = v30;
        if (v30 >= 1)
        {
          if (v30 == 3) {
            int v28 = 1;
          }
          else {
            int v28 = v30 + 1;
          }
          int v30 = v28;
        }
        v27 -= 2;
        v25 |= v28 << v27;
        if (!v27)
        {
          int v29 = kdu_output::put(a2, v25);
          int v25 = 0;
          v24 += v29;
          unsigned __int8 v27 = 8;
        }
        ++v26;
      }
      while (v17 != v26);
      if (v27 <= 7u) {
        v24 += kdu_output::put(a2, v25);
      }
    }
    if (v5 != v24) {
      ads_params::write_marker_segment();
    }
  }
  return v5;
}

BOOL ads_params::check_marker_segment(ads_params *this, int a2, int a3, char *a4, int *a5)
{
  if (a2 != 65395 || a3 < 1) {
    return 0;
  }
  int v6 = *a4;
  *a5 = *a4;
  return v6 > 0;
}

uint64_t ads_params::read_marker_segment(ads_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (a5) {
    return 0;
  }
  uint64_t result = 0;
  if (a2 == 65395 && a3 >= 2)
  {
    if (*((_DWORD *)this + 6) != *a4) {
      return 0;
    }
    int v7 = &a4[a3];
    int v8 = a4 + 2;
    int v9 = a4[1];
    if (a4[1])
    {
      int v10 = 0;
      unsigned int v11 = 0;
      int v12 = 0;
      do
      {
        if (!v10)
        {
          if (v7 - v8 <= 0)
          {
            exception = __cxa_allocate_exception(8uLL);
            void *exception = v8;
            __cxa_throw(exception, MEMORY[0x1E4FBA318], 0);
          }
          unsigned int v13 = *v8++;
          unsigned int v11 = v13;
          int v10 = 8;
        }
        v10 -= 2;
        kdu_params::set(this, "DOads", v12++, 0, (int *)((v11 >> v10) & 3));
      }
      while (v9 != v12);
    }
    else
    {
      unsigned int v11 = 0;
    }
    if (v7 - v8 <= 0)
    {
      int v24 = __cxa_allocate_exception(8uLL);
      *int v24 = v8;
      __cxa_throw(v24, MEMORY[0x1E4FBA318], 0);
    }
    int v16 = *v8;
    int v14 = v8 + 1;
    int v15 = v16;
    if (v16)
    {
      int v17 = 0;
      int v18 = 0;
      do
      {
        if (!v17)
        {
          if (v7 - v14 <= 0)
          {
            int v23 = __cxa_allocate_exception(8uLL);
            void *v23 = v14;
            __cxa_throw(v23, MEMORY[0x1E4FBA318], 0);
          }
          unsigned int v19 = *v14++;
          unsigned int v11 = v19;
          int v17 = 8;
        }
        v17 -= 2;
        unsigned int v20 = ((v11 >> v17) & 3) - 1;
        if (((v11 >> v17) & 3) == 1) {
          unsigned int v20 = 3;
        }
        if (((v11 >> v17) & 3) != 0) {
          int v21 = (int *)v20;
        }
        else {
          int v21 = 0;
        }
        kdu_params::set(this, "DSads", v18++, 0, v21);
      }
      while (v15 != v18);
    }
    if (v14 != v7)
    {
      uint64_t v26 = 0;
      memset(v25, 0, sizeof(v25));
      kdu_error::kdu_error((kdu_error *)v25, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v25[0] + 16))(v25, "Malformed ADS marker segment encountered. The final ");
      long long v30 = 0u;
      long long v31 = 0u;
      long long v28 = 0u;
      long long v29 = 0u;
      *(_OWORD *)unsigned __int8 v27 = 0u;
      if (BYTE8(v25[0])) {
        sprintf(v27, "%x");
      }
      else {
        sprintf(v27, "%d");
      }
      (*(void (**)(_OWORD *, char *))(*(void *)&v25[0] + 16))(v25, v27);
      (*(void (**)(_OWORD *, const char *))(*(void *)&v25[0] + 16))(v25, " bytes were not consumed!");
      kdu_error::~kdu_error((kdu_error *)v25);
    }
    return 1;
  }
  return result;
}

void sub_18869F860(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, long long a17, long long a18, uint64_t a19)
{
}

uint64_t ads_params::custom_textualize_field(ads_params *this, kdu_message *a2, const char *__s1, int a4, char *a5)
{
  int v10[2] = *MEMORY[0x1E4F143B8];
  uint64_t result = strcmp(__s1, "Ddecomp");
  if (!(result | a4))
  {
    uint64_t v9 = 0;
    v10[0] = 0;
    *(void *)((char *)v10 + 5) = 0;
    cod_params::textualize_decomp((char *)&v9, a5);
    return (*(uint64_t (**)(kdu_message *, uint64_t *))(*(void *)a2 + 16))(a2, &v9);
  }
  return result;
}

void dfs_params::dfs_params(dfs_params *this)
{
  *((void *)this + 1) = "DFS";
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18898D540;
  *((_WORD *)this + 20) = 1;
  *((unsigned char *)this + 42) = 1;
  *((void *)this + 6) = this;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 9) = this;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = this;
  *((unsigned char *)this + 104) = 0;
  *((_DWORD *)this + 9) = 1;
  *((void *)this + 14) = 0;
  *(void *)this = &unk_1ED4DE7A8;
}

void sub_18869FA94(_Unwind_Exception *a1)
{
  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t dfs_params::finalize(uint64_t this, char a2)
{
  if ((a2 & 1) == 0)
  {
    int v2 = (kdu_params *)this;
    int v7 = 0;
    this = kdu_params::get((kdu_params *)this, "DSdfs", 0, 0, &v7, 0, 0, 0);
    if (this)
    {
      int v3 = 1;
      do
      {
        if ((*((_DWORD *)v2 + 6) - 128) <= 0xFFFFFF80)
        {
          uint64_t v6 = 0;
          long long v4 = 0u;
          long long v5 = 0u;
          kdu_error::kdu_error((kdu_error *)&v4, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v4);
        }
        if (v7 >= 4)
        {
          uint64_t v6 = 0;
          long long v4 = 0u;
          long long v5 = 0u;
          kdu_error::kdu_error((kdu_error *)&v4, "Kakadu Core Error:\n");
          kdu_error::~kdu_error((kdu_error *)&v4);
        }
        this = kdu_params::get(v2, "DSdfs", v3++, 0, &v7, 0, 0, 0);
      }
      while ((this & 1) != 0);
    }
  }
  return this;
}

void sub_18869FC24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18869FC30()
{
  _Unwind_Resume(v0);
}

BOOL dfs_params::check_marker_segment(dfs_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  if (a2 != 65394 || a3 < 2) {
    return 0;
  }
  int v6 = (char)a4[1];
  *a5 = a4[1];
  return v6 > 0;
}

uint64_t dfs_params::read_marker_segment(dfs_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  if (a5 || (*((_DWORD *)this + 4) & 0x80000000) == 0 || (*((_DWORD *)this + 5) & 0x80000000) == 0) {
    return 0;
  }
  uint64_t result = 0;
  if (a2 == 65394 && a3 >= 2)
  {
    unsigned int v20 = a4 + 2;
    if (*((_DWORD *)this + 6) != a4[1]) {
      return 0;
    }
    int v7 = &a4[a3];
    int v8 = kdu_read(&v20, v7, 1);
    uint64_t v9 = v20;
    if (v8 >= 1)
    {
      int v10 = 0;
      unsigned int v11 = 0;
      for (int i = 0; i != v8; ++i)
      {
        if (!v10)
        {
          if (v7 - v9 <= 0)
          {
            unsigned int v20 = v9;
            exception = __cxa_allocate_exception(8uLL);
            void *exception = v9;
            __cxa_throw(exception, MEMORY[0x1E4FBA318], 0);
          }
          unsigned int v13 = *v9++;
          unsigned int v11 = v13;
          int v10 = 8;
        }
        v10 -= 2;
        unsigned int v14 = ((v11 >> v10) & 3) - 1;
        if (((v11 >> v10) & 3) == 1) {
          unsigned int v14 = 3;
        }
        if (((v11 >> v10) & 3) != 0) {
          int v15 = (int *)v14;
        }
        else {
          int v15 = 0;
        }
        kdu_params::set(this, "DSdfs", i, 0, v15);
      }
    }
    unsigned int v20 = v9;
    if (v9 != v7)
    {
      uint64_t v19 = 0;
      memset(v18, 0, sizeof(v18));
      kdu_error::kdu_error((kdu_error *)v18, "Kakadu Core Error:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v18[0] + 16))(v18, "Malformed DFS marker segment encountered. The final ");
      int v16 = kdu_message::operator<<(v18);
      (*(void (**)(unsigned char *, const char *))(*(void *)v16 + 16))(v16, " bytes were not consumed!");
      kdu_error::~kdu_error((kdu_error *)v18);
    }
    return 1;
  }
  return result;
}

void sub_18869FE64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18869FE70()
{
  _Unwind_Resume(v0);
}

void sub_18869FE78(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9, long long a10, uint64_t a11, uint64_t a12)
{
  if (a2 != 1) {
    sub_18869FE70();
  }
  __cxa_begin_catch(a1);
  a11 = 0;
  a9 = 0u;
  a10 = 0u;
  kdu_error::kdu_error((kdu_error *)&a9, "Kakadu Core Error:\n");
  (*(void (**)(long long *, const char *))(a9 + 16))(&a9, "Malformed DFS marker segment encountered. Marker segment is too small.");
  kdu_error::~kdu_error((kdu_error *)&a9);
}

void sub_18869FEF0()
{
}

void sub_18869FEFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_18869FF08()
{
}

uint64_t dfs_params::write_marker_segment(dfs_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  int v4 = *((_DWORD *)this + 6);
  if (v4 < 1) {
    return 0;
  }
  uint64_t v5 = 0;
  if (!a4 && v4 <= 0x7F)
  {
    if ((*((_DWORD *)this + 5) & 0x80000000) == 0 || (*((_DWORD *)this + 4) & 0x80000000) == 0) {
      return 0;
    }
    int v19 = 0;
    int v9 = -1;
    do
      ++v9;
    while ((kdu_params::get(this, "DSdfs", v9, 0, &v19, 0, 0, 1) & 1) != 0);
    unsigned int v10 = (v9 + 3) >> 2;
    uint64_t v5 = v10 + 7;
    if (a2)
    {
      kdu_output::put(a2, 255);
      kdu_output::put(a2, 114);
      __int16 v11 = v10 + 5;
      kdu_output::put(a2, SHIBYTE(v11));
      kdu_output::put(a2, v11);
      int v12 = *((_DWORD *)this + 6);
      kdu_output::put(a2, SBYTE1(v12));
      kdu_output::put(a2, v12);
      int v13 = kdu_output::put(a2, v9) + 6;
      if (v9)
      {
        int v14 = 0;
        int v15 = 0;
        unsigned __int8 v16 = 8;
        do
        {
          kdu_params::get(this, "DSdfs", v15, 0, &v19, 1, 1, 1);
          int v17 = v19;
          if (v19 >= 1)
          {
            if (v19 == 3) {
              int v17 = 1;
            }
            else {
              int v17 = v19 + 1;
            }
            int v19 = v17;
          }
          v16 -= 2;
          v14 |= v17 << v16;
          if (!v16)
          {
            int v18 = kdu_output::put(a2, v14);
            int v14 = 0;
            v13 += v18;
            unsigned __int8 v16 = 8;
          }
          ++v15;
        }
        while (v9 != v15);
        if (v16 <= 7u) {
          v13 += kdu_output::put(a2, v14);
        }
      }
      if (v5 != v13) {
        dfs_params::write_marker_segment();
      }
    }
  }
  return v5;
}

void qcd_params::qcd_params(qcd_params *this)
{
  *((void *)this + 1) = "QCD";
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18898D540;
  *((_WORD *)this + 20) = 0;
  *((unsigned char *)this + 42) = 0;
  *((void *)this + 6) = this;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 9) = this;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = this;
  *((unsigned char *)this + 104) = 0;
  *((_DWORD *)this + 9) = 16842753;
  *((void *)this + 14) = 0;
  *(void *)this = &unk_1ED4DEBF8;
  kdu_params::add_dependency((uint64_t)this, "COD");
  kdu_params::add_dependency((uint64_t)this, "ADS");
  kdu_params::define_attribute(this, "Qguard", "Number of guard bits to prevent overflow in the magnitude bit-plane representation. Typical values are 1 or 2.\n\t\t[Default is 1]", "I");
}

void sub_1886A025C(_Unwind_Exception *a1)
{
  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t qcd_params::copy_with_xforms(qcd_params *this, kdu_params *a2, int a3, int a4, int a5)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  int v29 = 0;
  BOOL v28 = 0;
  if (kdu_params::get(a2, "Qguard", 0, 0, &v29, 0, 1, 1)) {
    kdu_params::set(this, "Qguard", 0, 0, (int *)v29);
  }
  if (kdu_params::get(a2, "Qderived", 0, 0, &v28, 0, 1, 1)) {
    kdu_params::set((uint64_t)this, "Qderived", 0, 0, v28);
  }
  int v7 = (kdu_params *)kdu_params::access_cluster(a2, "COD");
  if (!v7
    || (int v8 = (kdu_params *)kdu_params::access_relation(v7, *((_DWORD *)a2 + 4), *((_DWORD *)a2 + 5), 0, 1)) == 0)
  {
    qcd_params::copy_with_xforms();
  }
  int v9 = v8;
  int v27 = 0;
  BOOL v26 = 0;
  kdu_params::get(v8, "Clevels", 0, 0, &v27, 1, 1, 1);
  uint64_t result = kdu_params::get(v9, "Creversible", 0, 0, &v26, 1, 1, 1);
  long long v38 = 0u;
  long long v37 = 0u;
  long long v36 = 0u;
  long long v35 = 0u;
  long long v34 = 0u;
  long long v33 = 0u;
  __int16 v31 = 0;
  memset(v30, 0, sizeof(v30));
  __int16 v32 = 0;
  int v11 = v27;
  if (v27 >= a4)
  {
    int v12 = 0;
    int v13 = 0;
    int v14 = 1;
    do
    {
      if (v13)
      {
        float v25 = 0.0;
        if ((kdu_params::get(v9, "Cdecomp", v11 - v13, 0, (int *)&v25, 1, 1, 1) & 1) == 0) {
          qcd_params::copy_with_xforms();
        }
        uint64_t result = cod_params::expand_decomp_bands(LODWORD(v25), (uint64_t)&v32, v15);
        int v14 = result;
        if (a5)
        {
          uint64_t v16 = cod_params::transpose_decomp((cod_params *)LODWORD(v25));
          uint64_t result = cod_params::expand_decomp_bands(v16, (uint64_t)v30, v17);
        }
      }
      int v23 = v13;
      if (v14 > (v13 != 0))
      {
        uint64_t v18 = v13 != 0;
        do
        {
          LODWORD(v19) = v18;
          if (a5)
          {
            if (v14 < 1) {
LABEL_27:
            }
              qcd_params::copy_with_xforms();
            uint64_t v19 = 0;
            unsigned int v20 = bswap32(*((unsigned __int16 *)v30 + v18)) >> 16;
            while ((unsigned __int16)*(&v32 + v19) != v20)
            {
              if (v14 == ++v19) {
                goto LABEL_27;
              }
            }
          }
          int v21 = v19 + v12;
          float v25 = 0.0;
          if (v26)
          {
            kdu_params::get(a2, "Qabs_ranges", v21, 0, (int *)&v25, 1, 1, 1);
            uint64_t result = (uint64_t)kdu_params::set(this, "Qabs_ranges", v12 + (int)v18, 0, (int *)LODWORD(v25));
          }
          else
          {
            kdu_params::get(a2, "Qabs_steps", v21, 0, &v25, 1, 1, 1);
            uint64_t result = kdu_params::set((uint64_t)this, "Qabs_steps", v12 + (int)v18, 0, v25);
          }
          ++v18;
        }
        while (v18 != v14);
      }
      int v12 = v12 + v14 - 1;
      ++v13;
      int v11 = v27;
    }
    while (v23 < v27 - a4);
  }
  return result;
}

uint64_t qcd_params::write_marker_segment(qcd_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  if (a4) {
    return 0;
  }
  int v8 = (kdu_params *)kdu_params::access_cluster(this, "COD");
  if (!v8) {
    qcd_params::write_marker_segment();
  }
  *(void *)BOOL v49 = 0;
  *(_WORD *)int v48 = 0;
  int v9 = (kdu_params *)kdu_params::access_relation(v8, *((_DWORD *)this + 4), *((_DWORD *)this + 5), 0, 1);
  unsigned int v10 = v9;
  if (!v9
    || !kdu_params::get(v9, "Clevels", 0, 0, v49, 1, 1, 1)
    || (kdu_params::get(v10, "Creversible", 0, 0, &v48[1], 1, 1, 1) & 1) == 0)
  {
    *(void *)&long long v52 = 0;
    long long v50 = 0u;
    long long v51 = 0u;
    kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v50 + 16))(&v50, "Cannot write QCD/QCC marker segment without first completing relevant COD/COC information!");
    kdu_error::~kdu_error((kdu_error *)&v50);
  }
  if ((kdu_params::get(this, "Qguard", 0, 0, &v49[1], 1, 1, 1) & 1) == 0)
  {
    *(void *)&long long v52 = 0;
    long long v50 = 0u;
    long long v51 = 0u;
    kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v50 + 16))(&v50, "Cannot write QCD/QCC marker segment yet! No info on guard bits.");
    kdu_error::~kdu_error((kdu_error *)&v50);
  }
  if (v48[1])
  {
    v48[0] = 0;
    __int16 v56 = 0;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
  }
  else
  {
    if ((kdu_params::get(this, "Qderived", 0, 0, v48, 1, 1, 1) & 1) == 0)
    {
      *(void *)&long long v52 = 0;
      long long v50 = 0u;
      long long v51 = 0u;
      kdu_error::kdu_error((kdu_error *)&v50, "Kakadu Core Error:\n");
      (*(void (**)(long long *, const char *))(v50 + 16))(&v50, "Cannot write QCD/QCC marker segment yet!  Not clear whether quant steps are derived from the LL band step size.");
      kdu_error::~kdu_error((kdu_error *)&v50);
    }
    __int16 v56 = 0;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    if (v48[0])
    {
LABEL_20:
      int v12 = 1;
      if (!a3) {
        goto LABEL_53;
      }
      goto LABEL_21;
    }
  }
  LODWORD(v57) = 0;
  if (v49[0] < 1) {
    goto LABEL_20;
  }
  int v11 = 0;
  int v12 = 1;
  do
  {
    kdu_params::get(v10, "Cdecomp", v11, 0, (int *)&v57, 1, 1, 1);
    int v12 = v12 + cod_params::expand_decomp_bands(v57, (uint64_t)&v50, v13) - 1;
    ++v11;
  }
  while (v11 < v49[0]);
  if (!a3) {
    goto LABEL_53;
  }
LABEL_21:
  LODWORD(v44) = 0;
  v43[0] = 0;
  int v14 = (kdu_params *)kdu_params::access_relation(v10, *((_DWORD *)a3 + 4), *((_DWORD *)a3 + 5), 0, 1);
  int v15 = v14;
  if (!v14) {
    qcd_params::write_marker_segment();
  }
  if (!kdu_params::get(v14, "Clevels", 0, 0, (int *)&v44, 1, 1, 1)
    || (kdu_params::get(v15, "Creversible", 0, 0, v43, 1, 1, 1) & 1) == 0)
  {
    *(void *)&long long v59 = 0;
    long long v57 = 0u;
    long long v58 = 0u;
    kdu_error::kdu_error((kdu_error *)&v57, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v57 + 16))(&v57, "Cannot write QCD/QCC marker segment without first completing all relevant COD/COC information!");
    kdu_error::~kdu_error((kdu_error *)&v57);
  }
  if (v43[0] == v48[1] && v44 == v49[0])
  {
    int v16 = v49[1];
    LODWORD(v57) = 0;
    int v17 = kdu_params::get(a3, "Qguard", 0, 0, (int *)&v57, 1, 1, 1);
    int v18 = v57 == v16 ? v17 : 0;
    if (v18 == 1 && (v48[1] || kdu_params::compare(a3, "Qderived", 0, 0, v48[0])))
    {
      if (v12 >= 1)
      {
        int v19 = 0;
        while (1)
        {
          if (v48[1])
          {
            int v47 = 0.0;
            if ((kdu_params::get(this, "Qabs_ranges", v19, 0, (int *)&v47, 1, 1, 1) & 1) == 0)
            {
              *(void *)&long long v59 = 0;
              long long v57 = 0u;
              long long v58 = 0u;
              kdu_error::kdu_error((kdu_error *)&v57, "Kakadu Core Error:\n");
              (*(void (**)(long long *, const char *))(v57 + 16))(&v57, "Cannot write QCD/QCC marker segment yet!  Absolute reversible ranging information not available.");
              kdu_error::~kdu_error((kdu_error *)&v57);
            }
            int v20 = LODWORD(v47);
            LODWORD(v57) = 0;
            char v21 = kdu_params::get(a3, "Qabs_ranges", v19, 0, (int *)&v57, 1, 1, 1);
            if (v57 == v20) {
              char v22 = v21;
            }
            else {
              char v22 = 0;
            }
            if ((v22 & 1) == 0) {
              goto LABEL_52;
            }
          }
          else
          {
            int v47 = 0.0;
            if ((kdu_params::get(this, "Qabs_steps", v19, 0, &v47, 1, 1, 1) & 1) == 0)
            {
              *(void *)&long long v59 = 0;
              long long v57 = 0u;
              long long v58 = 0u;
              kdu_error::kdu_error((kdu_error *)&v57, "Kakadu Core Error:\n");
              (*(void (**)(long long *, const char *))(v57 + 16))(&v57, "Cannot write QCD/QCC marker segment yet!  Absolute step size information not available.");
              kdu_error::~kdu_error((kdu_error *)&v57);
            }
            *(float *)&int v23 = v47;
            LODWORD(v57) = 0;
            int v24 = kdu_params::get(a3, "Qabs_steps", v19, 0, (float *)&v57, 1, 1, 1);
            if (*(float *)&v57 == *(float *)&v23) {
              int v25 = v24;
            }
            else {
              int v25 = 0;
            }
            if (v25 != 1) {
              goto LABEL_52;
            }
          }
          if (v12 == ++v19) {
            return 0;
          }
        }
      }
      int v19 = 0;
LABEL_52:
      if (v19 == v12) {
        return 0;
      }
    }
  }
LABEL_53:
  if (v49[1] >= 8u)
  {
    uint64_t v46 = 0;
    long long v44 = 0u;
    long long v45 = 0u;
    kdu_error::kdu_error((kdu_error *)&v44, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v44 + 16))(&v44, "Illegal number of guard bits, ");
    long long v60 = 0u;
    long long v61 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v57 = 0u;
    if (BYTE8(v44)) {
      sprintf((char *)&v57, "%x");
    }
    else {
      sprintf((char *)&v57, "%d");
    }
    (*(void (**)(long long *, long long *))(v44 + 16))(&v44, &v57);
    (*(void (**)(long long *, const char *))(v44 + 16))(&v44, ". Legal range is from 0 to 7.");
    kdu_error::~kdu_error((kdu_error *)&v44);
  }
  int v26 = *((_DWORD *)this + 8);
  int v27 = *((_DWORD *)this + 5);
  if (v26 < 257) {
    int v28 = 6;
  }
  else {
    int v28 = 7;
  }
  if (v27 >= 0) {
    int v29 = v28;
  }
  else {
    int v29 = 5;
  }
  BOOL v30 = v48[1];
  uint64_t result = v29 + v12 * (2 - v48[1]);
  if (a2)
  {
    unsigned int v42 = v29 + v12 * (2 - v48[1]);
    if ((*((_DWORD *)this + 4) & 0x80000000) == 0)
    {
      __int16 v31 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
      if (!v31) {
        qcd_params::write_marker_segment();
      }
      LODWORD(v47) = 2;
      kdu_params::get(v31, "Sprofile", 0, 0, (int *)&v47, 1, 1, 1);
      if (!LODWORD(v47))
      {
        uint64_t v46 = 0;
        long long v44 = 0u;
        long long v45 = 0u;
        kdu_warning::kdu_warning((kdu_warning *)&v44, "Kakadu Core Warning:\n");
        (*(void (**)(long long *, const char *))(v44 + 16))(&v44, "Profile violation detected (code-stream is technically illegal).  QCD/QCC marker segments may only appear in the main header of a Profile-0 code-stream.  You should set \"Sprofile\" to 1 or 2.  Problem detected in tile ");
        long long v60 = 0u;
        long long v61 = 0u;
        long long v58 = 0u;
        long long v59 = 0u;
        long long v57 = 0u;
        if (BYTE8(v44)) {
          sprintf((char *)&v57, "%x");
        }
        else {
          sprintf((char *)&v57, "%d");
        }
        (*(void (**)(long long *, long long *))(v44 + 16))(&v44, &v57);
        (*(void (**)(long long *, const char *))(v44 + 16))(&v44, ".");
        kdu_warning::~kdu_warning((kdu_warning *)&v44);
      }
      BOOL v30 = v48[1];
      int v27 = *((_DWORD *)this + 5);
    }
    char v32 = v49[1];
    if (v30) {
      char v33 = 0;
    }
    else {
      char v33 = 2 - v48[0];
    }
    kdu_output::put(a2, 255);
    unsigned int v34 = v27 >> 31;
    __int16 v35 = v42 - 2;
    if (v34)
    {
      kdu_output::put(a2, 92);
      kdu_output::put(a2, SHIBYTE(v35));
      kdu_output::put(a2, v35);
      int v37 = 4;
    }
    else
    {
      kdu_output::put(a2, 93);
      kdu_output::put(a2, SHIBYTE(v35));
      kdu_output::put(a2, v35);
      int v36 = *((_DWORD *)this + 5);
      if (v26 >= 257)
      {
        kdu_output::put(a2, SBYTE1(v36));
        kdu_output::put(a2, v36);
        int v37 = 6;
      }
      else
      {
        int v37 = kdu_output::put(a2, v36) + 4;
      }
    }
    int v38 = kdu_output::put(a2, v33 | (32 * v32)) + v37;
    if (v12 >= 1)
    {
      for (int i = 0; i != v12; ++i)
      {
        if (v48[1])
        {
          LODWORD(v44) = 0;
          if ((kdu_params::get(this, "Qabs_ranges", i, 0, (int *)&v44, 1, 1, 1) & 1) == 0)
          {
            *(void *)&long long v59 = 0;
            long long v57 = 0u;
            long long v58 = 0u;
            kdu_error::kdu_error((kdu_error *)&v57, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v57 + 16))(&v57, "Insufficient absolute ranging parameters available for writing QCD/QCC marker segment");
            kdu_error::~kdu_error((kdu_error *)&v57);
          }
          if (v44 >= 0x20)
          {
            *(void *)&long long v59 = 0;
            long long v57 = 0u;
            long long v58 = 0u;
            kdu_error::kdu_error((kdu_error *)&v57, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v57 + 16))(&v57, "Absolute ranging parameters for reversibly compressed subbands must be non-negative, no larger than 31!");
            kdu_error::~kdu_error((kdu_error *)&v57);
          }
          int v40 = kdu_output::put(a2, 8 * (v44 & 0x1Fu));
        }
        else
        {
          *(_DWORD *)int v43 = 0;
          LODWORD(v44) = 0;
          int v47 = 0.0;
          if ((kdu_params::get(this, "Qabs_steps", i, 0, (float *)&v44, 1, 1, 1) & 1) == 0)
          {
            *(void *)&long long v59 = 0;
            long long v57 = 0u;
            long long v58 = 0u;
            kdu_error::kdu_error((kdu_error *)&v57, "Kakadu Core Error:\n");
            (*(void (**)(long long *, const char *))(v57 + 16))(&v57, "Insufficient absolute quantization step size parameters available for writing QCD/QCC marker segment.");
            kdu_error::~kdu_error((kdu_error *)&v57);
          }
          step_to_eps_mu(*(float *)&v44, (int *)&v47, (int *)v43);
          char v41 = v43[0];
          kdu_output::put(a2, (unsigned __int16)(*(_WORD *)v43 + (LOWORD(v47) << 11)) >> 8);
          kdu_output::put(a2, v41);
          int v40 = 2;
        }
        v38 += v40;
      }
    }
    uint64_t result = v42;
    if (v42 != v38) {
      qcd_params::write_marker_segment();
    }
  }
  return result;
}

void sub_1886A11B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void sub_1886A11C4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Unwind_Resume(v33);
}

int *step_to_eps_mu(float a1, int *result, int *a3)
{
  float v3 = a1;
  if (a1 <= 0.0)
  {
    uint64_t v8 = 0;
    memset(v7, 0, sizeof(v7));
    kdu_error::kdu_error((kdu_error *)v7, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v7[0] + 16))(v7, "Absolute quantization step sizes must be strictly positive.");
    kdu_error::~kdu_error((kdu_error *)v7);
  }
  int v4 = 0;
  while (v3 < 1.0)
  {
    float v3 = v3 + v3;
    ++v4;
  }
  *uint64_t result = v4;
  int v5 = vcvtms_s32_f32((float)((float)(v3 + -1.0) * 2048.0) + 0.5);
  *a3 = v5;
  if (v5 < 2048)
  {
    int v6 = *result;
  }
  else
  {
    *a3 = 0;
    int v6 = *result - 1;
    *uint64_t result = v6;
  }
  if (v6 >= 32)
  {
    *uint64_t result = 31;
    *a3 = 0;
    int v6 = *result;
  }
  if (v6 < 0)
  {
    *uint64_t result = 0;
    *a3 = 2047;
  }
  return result;
}

void sub_1886A13A8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1886A13B4()
{
  _Unwind_Resume(v0);
}

uint64_t qcd_params::check_marker_segment(qcd_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  if (a2 == 65372)
  {
    int v5 = -1;
    goto LABEL_7;
  }
  uint64_t result = 0;
  if (a2 == 65373 && a3 >= 2)
  {
    int v8 = *a4;
    *a5 = v8;
    if (*((int *)this + 8) < 257) {
      return 1;
    }
    int v5 = a4[1] | (v8 << 8);
LABEL_7:
    *a5 = v5;
    return 1;
  }
  return result;
}

uint64_t qcd_params::read_marker_segment(qcd_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (a5) {
    return 0;
  }
  int v9 = *((_DWORD *)this + 5);
  if (v9 < 0)
  {
    unint64_t v11 = (unint64_t)a4;
    if (a2 != 65372) {
      return 0;
    }
  }
  else
  {
    if (a2 != 65373) {
      return 0;
    }
    unint64_t v11 = (unint64_t)(a4 + 1);
    int v10 = *a4;
    if (*((int *)this + 8) >= 257)
    {
      unint64_t v11 = (unint64_t)(a4 + 2);
      int v10 = a4[1] | (v10 << 8);
    }
    if (v10 != v9) {
      return 0;
    }
  }
  if ((*((_DWORD *)this + 4) & 0x80000000) == 0)
  {
    int v12 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
    if (!v12) {
      qcd_params::read_marker_segment();
    }
    int v32 = 2;
    kdu_params::get(v12, "Sprofile", 0, 0, &v32, 1, 1, 1);
    if (!v32)
    {
      uint64_t v31 = 0;
      long long v29 = 0u;
      long long v30 = 0u;
      kdu_warning::kdu_warning((kdu_warning *)&v29, "Kakadu Core Warning:\n");
      (*(void (**)(long long *, const char *))(v29 + 16))(&v29, "Profile violation detected (code-stream is technically illegal).  QCD/QCC marker segments may only appear in the main header of a Profile-0 code-stream.  You should set \"Sprofile\" to 1 or 2.  Problem detected in tile ");
      long long v36 = 0u;
      long long v37 = 0u;
      long long v34 = 0u;
      long long v35 = 0u;
      *(_OWORD *)char v33 = 0u;
      if (BYTE8(v29)) {
        sprintf(v33, "%x");
      }
      else {
        sprintf(v33, "%d");
      }
      (*(void (**)(long long *, char *))(v29 + 16))(&v29, v33);
      (*(void (**)(long long *, const char *))(v29 + 16))(&v29, ".");
      kdu_warning::~kdu_warning((kdu_warning *)&v29);
    }
  }
  int v13 = &a4[a3];
  if ((uint64_t)&v13[-v11] <= 0)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = v11;
    __cxa_throw(exception, MEMORY[0x1E4FBA318], 0);
  }
  int v14 = (unsigned __int8 *)(v11 + 1);
  unsigned int v15 = *(unsigned __int8 *)v11;
  kdu_params::set(this, "Qguard", 0, 0, (int *)(v15 >> 5));
  uint64_t v16 = a3;
  if ((v15 & 0x1F) == 2)
  {
    int v22 = 0;
LABEL_29:
    kdu_params::set((uint64_t)this, "Qderived", 0, 0, v22);
    if (v14 < v13 - 1)
    {
      int v23 = 0;
      uint64_t v24 = (uint64_t)&a4[v16 + ~v11];
      do
      {
        if (v24 <= 1)
        {
          int v25 = __cxa_allocate_exception(8uLL);
          *int v25 = v14;
          __cxa_throw(v25, MEMORY[0x1E4FBA318], 0);
        }
        kdu_params::set((uint64_t)this, "Qabs_steps", v23++, 0, (float)((float)((float)((float)(v14[1] | ((*v14 & 7) << 8)) * 0.00048828) + 1.0)/ (float)(1 << (*v14 >> 3))));
        v24 -= 2;
        v14 += 2;
        int v18 = v14;
      }
      while (v14 < v13 - 1);
      goto LABEL_33;
    }
LABEL_43:
    int v28 = __cxa_allocate_exception(8uLL);
    void *v28 = v14;
    __cxa_throw(v28, MEMORY[0x1E4FBA318], 0);
  }
  if ((v15 & 0x1F) == 1)
  {
    int v22 = 1;
    goto LABEL_29;
  }
  if ((v15 & 0x1F) != 0)
  {
    *(void *)&long long v35 = 0;
    *(_OWORD *)char v33 = 0u;
    long long v34 = 0u;
    kdu_error::kdu_error((kdu_error *)v33, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v33 + 16))(v33, "Undefined style byte found in QCD/QCC marker segment!");
    kdu_error::~kdu_error((kdu_error *)v33);
  }
  if (v14 >= v13) {
    goto LABEL_43;
  }
  int v17 = 0;
  int v18 = v13;
  int v19 = &a4[v16 + ~v11];
  uint64_t v20 = (uint64_t)v19;
  do
  {
    char v21 = &v17[v11];
    if (v20 <= 0)
    {
      int v26 = __cxa_allocate_exception(8uLL);
      void *v26 = v21 + 1;
      __cxa_throw(v26, MEMORY[0x1E4FBA318], 0);
    }
    kdu_params::set(this, "Qabs_ranges", (int)v17++, 0, (int *)(v21[1] >> 3));
    --v20;
  }
  while (v19 != v17);
LABEL_33:
  if (v18 != v13)
  {
    uint64_t v31 = 0;
    long long v29 = 0u;
    long long v30 = 0u;
    kdu_error::kdu_error((kdu_error *)&v29, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(v29 + 16))(&v29, "Malformed QCD/QCC marker segment encountered. The final ");
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    *(_OWORD *)char v33 = 0u;
    if (BYTE8(v29)) {
      sprintf(v33, "%x");
    }
    else {
      sprintf(v33, "%d");
    }
    (*(void (**)(long long *, char *))(v29 + 16))(&v29, v33);
    (*(void (**)(long long *, const char *))(v29 + 16))(&v29, " bytes were not consumed!");
    kdu_error::~kdu_error((kdu_error *)&v29);
  }
  return 1;
}

void sub_1886A1988(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886A1998(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, long long a17, long long a18, uint64_t a19)
{
  if (v20 == 1)
  {
    __cxa_begin_catch(v19);
    a19 = 0;
    a17 = 0u;
    a18 = 0u;
    kdu_error::kdu_error((kdu_error *)&a17, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(a17 + 16))(&a17, "Malformed QCD/QCC marker segment encountered. Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a17);
  }
  _Unwind_Resume(v19);
}

kdu_params *qcd_params::finalize(kdu_params *this, char a2)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if ((a2 & 1) == 0)
  {
    unsigned int v38 = 0;
    *(void *)long long v37 = 0;
    float v36 = 0.0;
    uint64_t v31 = (int *)this;
    if ((kdu_params::get(this, "Qguard", 0, 0, v37, 1, 1, 1) & 1) == 0)
    {
      v37[0] = 1;
      kdu_params::set((kdu_params *)v31, "Qguard", 0, 0, (int *)1);
    }
    int v2 = (kdu_params *)kdu_params::access_cluster((kdu_params *)v31, "COD");
    if (!v2) {
      qcd_params::finalize();
    }
    float v3 = (kdu_params *)kdu_params::access_relation(v2, v31[4], v31[5], 0, 1);
    int v4 = v3;
    if (!v3) {
      qcd_params::finalize();
    }
    int v35 = 0;
    *(void *)long long v34 = 0;
    if (!kdu_params::get(v3, "Creversible", 0, 0, &v35, 1, 1, 1)
      || !kdu_params::get(v4, "Clevels", 0, 0, &v34[1], 1, 1, 1)
      || (kdu_params::get(v4, "Ckernels", 0, 0, v34, 1, 1, 1) & 1) == 0)
    {
      qcd_params::finalize();
    }
    if (v34[0] == -1)
    {
      v40[0] = 0;
      if ((kdu_params::get(v4, "Catk", 0, 0, v40, 1, 1, 1) & 1) == 0) {
        qcd_params::finalize();
      }
      int v6 = (kdu_params *)kdu_params::access_cluster((kdu_params *)v31, "ATK");
      if (!v6 || (int v5 = (kdu_params *)kdu_params::access_relation(v6, v31[4], -1, v40[0], 1)) == 0) {
        qcd_params::finalize();
      }
    }
    else
    {
      int v5 = 0;
    }
    __int16 v48 = 0;
    memset(v47, 0, sizeof(v47));
    if (v34[1] < 1)
    {
      int v8 = 1;
    }
    else
    {
      int v7 = 0;
      int v8 = 1;
      do
      {
        kdu_params::get(v4, "Cdecomp", v7, 0, (int *)&v38, 1, 1, 1);
        int v8 = v8 + cod_params::expand_decomp_bands(v38, (uint64_t)v47, v9) - 1;
        ++v7;
      }
      while (v7 < v34[1]);
    }
    int v10 = 0;
    do
      char v11 = kdu_params::get((kdu_params *)v31, "Qabs_steps", v10++, 0, &v36, 1, 1, 0);
    while ((v11 & 1) != 0);
    int v12 = 0;
    do
      char v13 = kdu_params::get((kdu_params *)v31, "Qabs_ranges", v12++, 0, &v37[1], 1, 1, 0);
    while ((v13 & 1) != 0);
    BOOL v33 = 0;
    if (v35)
    {
      this = (kdu_params *)kdu_params::get((kdu_params *)v31, "Qderived", 0, 0, &v33, 1, 1, 1);
      if (v33) {
        char v14 = 0;
      }
      else {
        char v14 = (char)this;
      }
      if ((v14 & 1) == 0)
      {
        BOOL v33 = 0;
        this = (kdu_params *)kdu_params::set((uint64_t)v31, "Qderived", 0, 0, 0);
      }
      if (v8 + 1 != v12)
      {
        int v32 = 0;
        unsigned int v15 = (kdu_params *)kdu_params::access_cluster((kdu_params *)v31, "SIZ");
        if ((kdu_params::get(v15, "Sprecision", v31[5] & ~(v31[5] >> 31), 0, &v32, 1, 1, 1) & 1) == 0)
        {
          uint64_t v42 = 0;
          *(_OWORD *)int v40 = 0u;
          long long v41 = 0u;
          kdu_error::kdu_error((kdu_error *)v40, "Kakadu Core Error:\n");
          (*(void (**)(int *, const char *))(*(void *)v40 + 16))(v40, "Trying to finalize quantization parameter attributes without first providing any information about the image component bit-depths (i.e. \"Sprecision\").");
          kdu_error::~kdu_error((kdu_error *)v40);
        }
        int v16 = v31[8];
        if (v31[5] < 0)
        {
          if (v16 < 1) {
            goto LABEL_56;
          }
          for (int i = 0; i < v16; ++i)
          {
            int v18 = v32;
            v40[0] = 0;
            char v19 = kdu_params::get(v15, "Sprecision", i, 0, v40, 1, 1, 1);
            if (v40[0] == v18) {
              char v20 = v19;
            }
            else {
              char v20 = 0;
            }
            if ((v20 & 1) == 0) {
              kdu_params::access_relation((kdu_params *)v31, v31[4], i, 0, 0);
            }
            int v16 = v31[8];
          }
        }
        if (v16 >= 3)
        {
          int v21 = ++v32;
          goto LABEL_57;
        }
LABEL_56:
        int v21 = v32;
LABEL_57:
        if (v21 <= 4) {
          int v32 = v21 + 1;
        }
        __int16 v50 = 0;
        memset(v49, 0, sizeof(v49));
        char v46 = 0;
        *(_WORD *)long long v45 = 0;
        char v44 = 0;
        *(_WORD *)int v43 = 0;
        bzero(v40, 0x288uLL);
        kdu_kernels::clear((uint64_t)v40);
        if (v5)
        {
          uint64_t v24 = 0;
          int v25 = 0;
          int v26 = 0;
          int v39 = 0;
          while (kdu_params::get(v5, "Ksteps", v25, 0, &v39, 1, 1, 1))
          {
            v26 += v39;
            ++v25;
            v24 += 16;
          }
          operator new[]();
        }
        int v39 = 0;
        kdu_params::get(v4, "Ckernels", 0, 0, &v39, 1, 1, 1);
        kdu_kernels::init((kdu_kernels *)v40, v39, 1);
      }
    }
    else
    {
      v49[0] = 0.0;
      if (kdu_params::get((kdu_params *)v31, "Qstep", 0, 0, v49, 1, 1, 1))
      {
        if (kdu_params::get((kdu_params *)v31, "Qabs_steps", 0, 0, &v36, 0, 0, 0))
        {
          uint64_t v42 = 0;
          *(_OWORD *)int v40 = 0u;
          long long v41 = 0u;
          kdu_warning::kdu_warning((kdu_warning *)v40, "Kakadu Core Warning:\n");
          kdu_warning::~kdu_warning((kdu_warning *)v40);
        }
        if ((kdu_params::get((kdu_params *)v31, "Qderived", 0, 0, &v33, 1, 1, 1) & 1) == 0)
        {
          BOOL v33 = 0;
          kdu_params::set((uint64_t)v31, "Qderived", 0, 0, 0);
        }
        derive_absolute_steps((qcd_params *)v31, v4, v5, v49[0]);
      }
      if (v10 - 1 >= v8)
      {
        char v27 = kdu_params::get((kdu_params *)v31, "Qderived", 0, 0, &v33, 1, 1, 1);
        if (v33) {
          char v28 = 0;
        }
        else {
          char v28 = v27;
        }
        if ((v28 & 1) == 0)
        {
          BOOL v33 = 0;
          kdu_params::set((uint64_t)v31, "Qderived", 0, 0, 0);
        }
      }
      else
      {
        char v22 = kdu_params::get((kdu_params *)v31, "Qderived", 0, 0, &v33, 1, 1, 1);
        if (v10 != 2)
        {
          if ((v22 & 1) == 0)
          {
            BOOL v33 = 0;
            kdu_params::set((uint64_t)v31, "Qderived", 0, 0, 0);
          }
          v49[0] = 0.0039062;
          kdu_params::set((uint64_t)v31, "Qstep", 0, 0, 0.00390625);
          derive_absolute_steps((qcd_params *)v31, v4, v5, v49[0]);
        }
        if (v33) {
          char v23 = v22;
        }
        else {
          char v23 = 0;
        }
        if ((v23 & 1) == 0)
        {
          BOOL v33 = 1;
          kdu_params::set((uint64_t)v31, "Qderived", 0, 0, 1);
        }
      }
      if (v33) {
        int v29 = 1;
      }
      else {
        int v29 = v8;
      }
      this = (kdu_params *)kdu_params::get((kdu_params *)v31, "Qabs_steps", 0, 0, &v36, 0, 0, 1);
      if (!this)
      {
        int v39 = 0;
        v40[0] = 0;
        operator new[]();
      }
      int v39 = 0;
      v40[0] = 0;
      if (v29 >= 1)
      {
        for (int j = 0; j != v29; ++j)
        {
          if ((kdu_params::get((kdu_params *)v31, "Qabs_steps", j, 0, &v36, 1, 1, 1) & 1) == 0) {
            qcd_params::finalize();
          }
          step_to_eps_mu(v36, v40, &v39);
          this = (kdu_params *)kdu_params::set((uint64_t)v31, "Qabs_steps", j, 0, (float)((float)((float)((float)v39 * 0.00048828) + 1.0)/ (float)(1 << SLOBYTE(v40[0]))));
        }
      }
    }
  }
  return this;
}

void sub_1886A296C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

void derive_absolute_steps(qcd_params *a1, kdu_params *a2, kdu_params *a3, float a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  __int16 v21 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  char v14 = 0;
  *(_WORD *)char v13 = 0;
  char v12 = 0;
  *(_WORD *)char v11 = 0;
  bzero(v10, 0x288uLL);
  kdu_kernels::clear((uint64_t)v10);
  if (a3)
  {
    uint64_t v5 = 0;
    int v6 = 0;
    int v7 = 0;
    int v9 = 0;
    while (kdu_params::get(a3, "Ksteps", v6, 0, &v9, 1, 1, 1))
    {
      v7 += v9;
      ++v6;
      v5 += 16;
    }
    operator new[]();
  }
  int v9 = 0;
  kdu_params::get(a2, "Ckernels", 0, 0, &v9, 1, 1, 1);
  kdu_kernels::init((kdu_kernels *)v10, v9, 0);
}

void sub_1886A2F54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  kdu_kernels::reset((kdu_kernels *)va);
  _Unwind_Resume(a1);
}

void rgn_params::rgn_params(rgn_params *this)
{
  *((void *)this + 1) = "RGN";
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18898D540;
  *((_WORD *)this + 20) = 256;
  *((unsigned char *)this + 42) = 0;
  *((void *)this + 6) = this;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 9) = this;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = this;
  *((unsigned char *)this + 104) = 0;
  *((_DWORD *)this + 9) = 16842753;
  *((void *)this + 14) = 0;
  *(void *)this = &unk_1ED4DEC58;
  kdu_params::define_attribute(this, "Rshift", "Region of interest up-shift value.  All subband samples which are involved in the synthesis of any image sample which belongs to the foreground region of an ROI mask will be effectively shifted up (scaled by two the power of this shift value) prior to quantization.  The region geometry is specified independently and is not explicitly signalled through the code-stream; instead, this shift must be sufficiently large to enable the decoder to separate the foregrou"
    "nd and background on the basis of the shifted sample amplitudes alone.  You will receive an appropriate error messag"
    "e if the shift value is too small.\n"
    "\t\t[Default is 0]",
    "I");
}

void sub_1886A30A8(_Unwind_Exception *a1)
{
  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

const char *rgn_params::copy_with_xforms(rgn_params *this, kdu_params *a2)
{
  int v4 = 0;
  uint64_t result = (const char *)kdu_params::get(a2, "Rshift", 0, 0, &v4, 0, 1, 1);
  if (result) {
    return kdu_params::set(this, "Rshift", 0, 0, (int *)v4);
  }
  return result;
}

uint64_t rgn_params::write_marker_segment(rgn_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (a4 || (*((_DWORD *)this + 5) & 0x80000000) != 0) {
    return 0;
  }
  *(_DWORD *)long long v19 = 0;
  if ((kdu_params::get(this, "Rshift", 0, 0, (int *)v19, 1, 1, 1) & 1) == 0) {
    *(_DWORD *)long long v19 = 0;
  }
  if (a3)
  {
    *(_DWORD *)long long v20 = 0;
    int v9 = kdu_params::get(a3, "Rshift", 0, 0, (int *)v20, 1, 1, 1);
    uint64_t v4 = 0;
    if (v9) {
      int v10 = *(_DWORD *)v20;
    }
    else {
      int v10 = 0;
    }
    unsigned int v11 = *(_DWORD *)v19;
    if (*(_DWORD *)v19 == v10) {
      return v4;
    }
    goto LABEL_14;
  }
  unsigned int v11 = *(_DWORD *)v19;
  if (!*(_DWORD *)v19) {
    return 0;
  }
LABEL_14:
  if (v11 >= 0x100)
  {
    uint64_t v18 = 0;
    memset(v17, 0, sizeof(v17));
    kdu_error::kdu_error((kdu_error *)v17, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v17[0] + 16))(v17, "Illegal ROI up-shift, ");
    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    *(_OWORD *)long long v20 = 0u;
    if (BYTE8(v17[0])) {
      sprintf(v20, "%x");
    }
    else {
      sprintf(v20, "%d");
    }
    (*(void (**)(_OWORD *, char *))(*(void *)&v17[0] + 16))(v17, v20);
    (*(void (**)(_OWORD *, const char *))(*(void *)&v17[0] + 16))(v17, ". Legal range is from 0 to 255!");
    kdu_error::~kdu_error((kdu_error *)v17);
  }
  int v12 = *((_DWORD *)this + 8);
  if (v12 < 257) {
    uint64_t v4 = 7;
  }
  else {
    uint64_t v4 = 8;
  }
  if (a2)
  {
    BOOL v13 = v12 < 257;
    kdu_output::put(a2, 255);
    kdu_output::put(a2, 94);
    kdu_output::put(a2, 0);
    kdu_output::put(a2, v4 - 2);
    int v14 = *((_DWORD *)this + 5);
    if (v13)
    {
      int v15 = kdu_output::put(a2, v14) + 4;
    }
    else
    {
      kdu_output::put(a2, SBYTE1(v14));
      kdu_output::put(a2, v14);
      int v15 = 6;
    }
    int v16 = kdu_output::put(a2, 0);
    if (v4 != v16 + v15 + kdu_output::put(a2, v19[0])) {
      rgn_params::write_marker_segment();
    }
  }
  return v4;
}

void sub_1886A33F4(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886A3400()
{
  _Unwind_Resume(v0);
}

BOOL rgn_params::check_marker_segment(rgn_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  BOOL result = a2 == 65374 && a3 > 1;
  if (result)
  {
    int v8 = *a4;
    *a5 = v8;
    if (*((int *)this + 8) >= 257) {
      *a5 = a4[1] | (v8 << 8);
    }
  }
  return result;
}

uint64_t rgn_params::read_marker_segment(rgn_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (a2 != 65374 || a5 != 0) {
    return 0;
  }
  int v6 = *((_DWORD *)this + 5);
  if (v6 < 0) {
    return 0;
  }
  int v8 = *((_DWORD *)this + 8);
  if (v8 <= 256) {
    int v9 = 1;
  }
  else {
    int v9 = 2;
  }
  if (v9 > a3)
  {
    exception = __cxa_allocate_exception(8uLL);
    void *exception = a4;
    __cxa_throw(exception, MEMORY[0x1E4FBA318], 0);
  }
  unsigned int v11 = a4 + 1;
  int v10 = *a4;
  if (v8 >= 257)
  {
    unsigned int v11 = a4 + 2;
    int v10 = a4[1] | (v10 << 8);
  }
  if (v10 != v6) {
    return 0;
  }
  int v12 = &a4[a3];
  if (v12 - v11 <= 0)
  {
    int v16 = __cxa_allocate_exception(8uLL);
    void *v16 = v11;
    goto LABEL_29;
  }
  BOOL v13 = v11 + 1;
  if (*v11)
  {
    *(void *)&long long v21 = 0;
    *(_OWORD *)long long v19 = 0u;
    long long v20 = 0u;
    kdu_error::kdu_error((kdu_error *)v19, "Kakadu Core Error:\n");
    (*(void (**)(char *, const char *))(*(void *)v19 + 16))(v19, "Encountered non-Part1 RGN marker segment!");
    kdu_error::~kdu_error((kdu_error *)v19);
  }
  if (v12 - v13 <= 0)
  {
    int v16 = __cxa_allocate_exception(8uLL);
    void *v16 = v13;
LABEL_29:
    __cxa_throw(v16, MEMORY[0x1E4FBA318], 0);
  }
  kdu_params::set(this, "Rshift", 0, 0, (int *)v11[1]);
  if (v11 + 2 != v12)
  {
    uint64_t v18 = 0;
    memset(v17, 0, sizeof(v17));
    kdu_error::kdu_error((kdu_error *)v17, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v17[0] + 16))(v17, "Malformed RGN marker segment encountered. The final ");
    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    *(_OWORD *)long long v19 = 0u;
    if (BYTE8(v17[0])) {
      sprintf(v19, "%x");
    }
    else {
      sprintf(v19, "%d");
    }
    (*(void (**)(_OWORD *, char *))(*(void *)&v17[0] + 16))(v17, v19);
    (*(void (**)(_OWORD *, const char *))(*(void *)&v17[0] + 16))(v17, " bytes were not consumed!");
    kdu_error::~kdu_error((kdu_error *)v17);
  }
  return 1;
}

void sub_1886A3714(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886A3724(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11, long long a12, uint64_t a13)
{
  if (v14 == 1)
  {
    __cxa_begin_catch(v13);
    a13 = 0;
    a11 = 0u;
    a12 = 0u;
    kdu_error::kdu_error((kdu_error *)&a11, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(a11 + 16))(&a11, "Malformed RGN marker segment encountered. Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a11);
  }
  _Unwind_Resume(v13);
}

void rgn_params::finalize(rgn_params *this, char a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if ((a2 & 1) == 0)
  {
    int v7 = 0;
    if ((kdu_params::get(this, "Rlevels", 0, 0, &v7, 1, 1, 1) & 1) == 0) {
      kdu_params::set(this, "Rlevels", 0, 0, (int *)4);
    }
    int v3 = kdu_params::get(this, "Rshift", 0, 0, &v7, 1, 1, 1);
    if (v7 > 37) {
      int v4 = v3;
    }
    else {
      int v4 = 0;
    }
    if (v4 == 1)
    {
      uint64_t v6 = 0;
      memset(v5, 0, sizeof(v5));
      kdu_warning::kdu_warning((kdu_warning *)v5, "Kakadu Core Warning:\n");
      (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, "Up-shift values in the RGN marker segment should not need to exceed 37 under any circumstances.  The use of a larger value, ");
      long long v11 = 0u;
      long long v12 = 0u;
      long long v9 = 0u;
      long long v10 = 0u;
      *(_OWORD *)int v8 = 0u;
      if (BYTE8(v5[0])) {
        sprintf(v8, "%x");
      }
      else {
        sprintf(v8, "%d");
      }
      (*(void (**)(_OWORD *, char *))(*(void *)&v5[0] + 16))(v5, v8);
      (*(void (**)(_OWORD *, const char *))(*(void *)&v5[0] + 16))(v5, " in this case, may cause problems.");
      kdu_warning::~kdu_warning((kdu_warning *)v5);
    }
  }
}

void sub_1886A39C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  kdu_warning::~kdu_warning((kdu_warning *)va);
  _Unwind_Resume(a1);
}

void poc_params::poc_params(poc_params *this)
{
  *((void *)this + 1) = "POC";
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18898D540;
  *((_WORD *)this + 20) = 1;
  *((unsigned char *)this + 42) = 0;
  *((void *)this + 6) = this;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 9) = this;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = this;
  *((unsigned char *)this + 104) = 0;
  *((_DWORD *)this + 9) = 65537;
  *((void *)this + 14) = 0;
  *(void *)this = &unk_1ED4DEB98;
}

void sub_1886A3A98(_Unwind_Exception *a1)
{
  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t poc_params::copy_with_xforms(poc_params *this, kdu_params *a2, int a3)
{
  *(void *)long long v10 = 0;
  *(void *)long long v11 = 0;
  *(void *)long long v9 = 0;
  uint64_t result = kdu_params::get(a2, "Porder", 0, 0, &v11[1], 0, 1, 1);
  if (result)
  {
    uint64_t result = kdu_params::get(a2, "Porder", 0, 0, &v11[1], 0, 0, 1);
    if (result)
    {
      int v7 = 0;
      do
      {
        uint64_t result = kdu_params::get(a2, "Porder", v7, 1, v11, 0, 0, 1);
        if (!result) {
          break;
        }
        uint64_t result = kdu_params::get(a2, "Porder", v7, 2, &v10[1], 0, 0, 1);
        if (!result) {
          break;
        }
        uint64_t result = kdu_params::get(a2, "Porder", v7, 3, v10, 0, 0, 1);
        if (!result) {
          break;
        }
        uint64_t result = kdu_params::get(a2, "Porder", v7, 4, &v9[1], 0, 0, 1);
        if (!result) {
          break;
        }
        uint64_t result = kdu_params::get(a2, "Porder", v7, 5, v9, 0, 0, 1);
        if (!result) {
          break;
        }
        v11[0] = (v11[0] - a3) & ~((v11[0] - a3) >> 31);
        BOOL v8 = v9[1] <= a3;
        v9[1] -= a3;
        if (v8)
        {
          v9[1] = 1;
          v10[1] = 0;
        }
        kdu_params::set(this, "Porder", v7, 0, (int *)v11[1]);
        kdu_params::set(this, "Porder", v7, 1, (int *)v11[0]);
        kdu_params::set(this, "Porder", v7, 2, (int *)v10[1]);
        kdu_params::set(this, "Porder", v7, 3, (int *)v10[0]);
        kdu_params::set(this, "Porder", v7, 4, (int *)v9[1]);
        kdu_params::set(this, "Porder", v7++, 5, (int *)v9[0]);
        uint64_t result = kdu_params::get(a2, "Porder", v7, 0, &v11[1], 0, 0, 1);
      }
      while ((result & 1) != 0);
    }
  }
  return result;
}

uint64_t poc_params::write_marker_segment(poc_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  if (*((_DWORD *)this + 6) != a4) {
    return 0;
  }
  *(void *)long long v54 = 0;
  *(void *)long long v55 = 0;
  *(void *)long long v53 = 0;
  unsigned int v7 = -1;
  do
    ++v7;
  while ((kdu_params::get(this, "Porder", v7, 0, (int *)&v55[4], 0, 1, 1) & 1) != 0);
  if (!v7) {
    return 0;
  }
  if (a3)
  {
    int v8 = *((_DWORD *)a3 + 4);
    int v9 = *((_DWORD *)this + 4);
    if (v8 != v9)
    {
      if ((v8 & 0x80000000) == 0 || *((_DWORD *)this + 6)) {
        poc_params::write_marker_segment();
      }
      long long v10 = (kdu_params *)kdu_params::access_relation(this, v9, *((_DWORD *)this + 5), 1, 1);
      if (!v10 || (kdu_params::get(v10, "Porder", 0, 0, (int *)&v55[4], 1, 1, 1) & 1) == 0)
      {
        int v11 = 0;
        do
        {
          if (!kdu_params::get(this, "Porder", v11, 0, (int *)&v55[4], 1, 1, 1)
            || !kdu_params::get(this, "Porder", v11, 1, (int *)v55, 1, 1, 1)
            || !kdu_params::get(this, "Porder", v11, 2, (int *)&v54[4], 1, 1, 1)
            || !kdu_params::get(this, "Porder", v11, 3, (int *)v54, 1, 1, 1)
            || !kdu_params::get(this, "Porder", v11, 4, (int *)&v53[4], 1, 1, 1)
            || (kdu_params::get(this, "Porder", v11, 5, (int *)v53, 1, 1, 1) & 1) == 0)
          {
            *(void *)&long long v58 = 0;
            *(_OWORD *)__int16 v56 = 0u;
            long long v57 = 0u;
            kdu_error::kdu_error((kdu_error *)v56, "Kakadu Core Error:\n");
            (*(void (**)(char *, const char *))(*(void *)v56 + 16))(v56, "Information required to write POC marker segment is not currently complete!");
            kdu_error::~kdu_error((kdu_error *)v56);
          }
          int v12 = *(_DWORD *)&v55[4];
          *(_DWORD *)__int16 v56 = 0;
          int v13 = kdu_params::get(a3, "Porder", v11, 0, (int *)v56, 1, 1, 1);
          int v14 = *(_DWORD *)v56 == v12 ? v13 : 0;
          if (v14 != 1) {
            return 0;
          }
          int v15 = *(_DWORD *)v55;
          *(_DWORD *)__int16 v56 = 0;
          int v16 = kdu_params::get(a3, "Porder", v11, 1, (int *)v56, 1, 1, 1);
          int v17 = *(_DWORD *)v56 == v15 ? v16 : 0;
          if (v17 != 1) {
            return 0;
          }
          int v18 = *(_DWORD *)&v54[4];
          *(_DWORD *)__int16 v56 = 0;
          int v19 = kdu_params::get(a3, "Porder", v11, 2, (int *)v56, 1, 1, 1);
          int v20 = *(_DWORD *)v56 == v18 ? v19 : 0;
          if (v20 != 1) {
            return 0;
          }
          int v21 = *(_DWORD *)v54;
          *(_DWORD *)__int16 v56 = 0;
          int v22 = kdu_params::get(a3, "Porder", v11, 3, (int *)v56, 1, 1, 1);
          int v23 = *(_DWORD *)v56 == v21 ? v22 : 0;
          if (v23 != 1) {
            return 0;
          }
          int v24 = *(_DWORD *)&v53[4];
          *(_DWORD *)__int16 v56 = 0;
          int v25 = kdu_params::get(a3, "Porder", v11, 4, (int *)v56, 1, 1, 1);
          int v26 = *(_DWORD *)v56 == v24 ? v25 : 0;
          if (v26 != 1) {
            return 0;
          }
          int v27 = *(_DWORD *)v53;
          *(_DWORD *)__int16 v56 = 0;
          char v28 = kdu_params::get(a3, "Porder", v11, 5, (int *)v56, 1, 1, 1);
          char v29 = *(_DWORD *)v56 == v27 ? v28 : 0;
          if ((v29 & 1) == 0) {
            return 0;
          }
        }
        while (v7 != ++v11);
      }
    }
  }
  int v52 = 0;
  long long v30 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
  if (!v30 || (kdu_params::get(v30, "Scomponents", 0, 0, &v52, 1, 1, 1) & 1) == 0) {
    poc_params::write_marker_segment();
  }
  int v48 = v52;
  if (v52 >= 257) {
    int v31 = 0x4000;
  }
  else {
    int v31 = 256;
  }
  if (v52 >= 257) {
    int v32 = 9;
  }
  else {
    int v32 = 7;
  }
  __int16 v33 = v32 * v7;
  uint64_t result = v32 * v7 + 4;
  if (a2)
  {
    unsigned int v46 = v32 * v7 + 4;
    kdu_output::put(a2, 255);
    kdu_output::put(a2, 95);
    __int16 v35 = v33 + 2;
    kdu_output::put(a2, SHIBYTE(v35));
    kdu_output::put(a2, v35);
    int v36 = 0;
    if (v7 <= 1) {
      int v37 = 1;
    }
    else {
      int v37 = v7;
    }
    int v47 = v37;
    int v38 = 4;
    while (1)
    {
      if (!kdu_params::get(this, "Porder", v36, 0, (int *)&v55[4], 1, 1, 1)
        || !kdu_params::get(this, "Porder", v36, 1, (int *)v55, 1, 1, 1)
        || !kdu_params::get(this, "Porder", v36, 2, (int *)&v54[4], 1, 1, 1)
        || !kdu_params::get(this, "Porder", v36, 3, (int *)v54, 1, 1, 1)
        || !kdu_params::get(this, "Porder", v36, 4, (int *)&v53[4], 1, 1, 1)
        || (kdu_params::get(this, "Porder", v36, 5, (int *)v53, 1, 1, 1) & 1) == 0)
      {
        *(void *)&long long v58 = 0;
        *(_OWORD *)__int16 v56 = 0u;
        long long v57 = 0u;
        kdu_error::kdu_error((kdu_error *)v56, "Kakadu Core Error:\n");
        (*(void (**)(char *, const char *))(*(void *)v56 + 16))(v56, "Information required to write POC marker segment is not currently complete!");
        kdu_error::~kdu_error((kdu_error *)v56);
      }
      if (*(_DWORD *)&v55[4] >= 0x21u)
      {
        uint64_t v51 = 0;
        long long v49 = 0u;
        long long v50 = 0u;
        kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Illegal lower bound, ");
        long long v59 = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        *(_OWORD *)__int16 v56 = 0u;
        if (BYTE8(v49)) {
          sprintf(v56, "%x");
        }
        else {
          sprintf(v56, "%d");
        }
        (*(void (**)(long long *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(long long *, const char *))(v49 + 16))(&v49, ", for resolution level indices in progression order change attribute.  Legal range is from 0 to 32.");
        kdu_error::~kdu_error((kdu_error *)&v49);
      }
      if (*(int *)v54 > 33 || *(int *)v54 <= *(int *)&v55[4])
      {
        uint64_t v51 = 0;
        long long v49 = 0u;
        long long v50 = 0u;
        kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Illegal upper bound (exclusive), ");
        long long v59 = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        *(_OWORD *)__int16 v56 = 0u;
        if (BYTE8(v49)) {
          sprintf(v56, "%x");
        }
        else {
          sprintf(v56, "%d");
        }
        (*(void (**)(long long *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(long long *, const char *))(v49 + 16))(&v49, ", for resolution level indices in progression order change attribute.  Legal range is from the lower bound + 1 to 33.");
        kdu_error::~kdu_error((kdu_error *)&v49);
      }
      if ((*(_DWORD *)v55 & 0x80000000) != 0 || *(int *)v55 >= v31)
      {
        uint64_t v51 = 0;
        long long v49 = 0u;
        long long v50 = 0u;
        kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Illegal lower bound, ");
        long long v59 = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        *(_OWORD *)__int16 v56 = 0u;
        if (BYTE8(v49)) {
          sprintf(v56, "%x");
        }
        else {
          sprintf(v56, "%d");
        }
        (*(void (**)(long long *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(long long *, const char *))(v49 + 16))(&v49, ", for component indices in progression order change attribute.  Legal range is from 0 to ");
        long long v59 = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        *(_OWORD *)__int16 v56 = 0u;
        if (BYTE8(v49)) {
          sprintf(v56, "%x");
        }
        else {
          sprintf(v56, "%d");
        }
        (*(void (**)(long long *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(long long *, const char *))(v49 + 16))(&v49, ".");
        kdu_error::~kdu_error((kdu_error *)&v49);
      }
      if (*(int *)&v53[4] <= *(int *)v55 || *(int *)&v53[4] > v31)
      {
        uint64_t v51 = 0;
        long long v49 = 0u;
        long long v50 = 0u;
        kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Illegal upper bound (exclusive), ");
        long long v59 = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        *(_OWORD *)__int16 v56 = 0u;
        if (BYTE8(v49)) {
          sprintf(v56, "%x");
        }
        else {
          sprintf(v56, "%d");
        }
        (*(void (**)(long long *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(long long *, const char *))(v49 + 16))(&v49, ", for component indices in progression order change attribute.  Legal range is from the lower bound + 1 to ");
        long long v59 = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        *(_OWORD *)__int16 v56 = 0u;
        if (BYTE8(v49)) {
          sprintf(v56, "%x");
        }
        else {
          sprintf(v56, "%d");
        }
        (*(void (**)(long long *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(long long *, const char *))(v49 + 16))(&v49, ".");
        kdu_error::~kdu_error((kdu_error *)&v49);
      }
      if (*(_DWORD *)&v54[4] >= 0x10000u)
      {
        uint64_t v51 = 0;
        long long v49 = 0u;
        long long v50 = 0u;
        kdu_error::kdu_error((kdu_error *)&v49, "Kakadu Core Error:\n");
        (*(void (**)(long long *, const char *))(v49 + 16))(&v49, "Illegal upper bound (exclusive), ");
        long long v59 = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        *(_OWORD *)__int16 v56 = 0u;
        if (BYTE8(v49)) {
          sprintf(v56, "%x");
        }
        else {
          sprintf(v56, "%d");
        }
        (*(void (**)(long long *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(long long *, const char *))(v49 + 16))(&v49, ", for layer indices in progression order change attribute.  Legal range is from 0 to ");
        long long v59 = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        *(_OWORD *)__int16 v56 = 0u;
        if (BYTE8(v49)) {
          sprintf(v56, "%x");
        }
        else {
          sprintf(v56, "%d");
        }
        (*(void (**)(long long *, char *))(v49 + 16))(&v49, v56);
        (*(void (**)(long long *, const char *))(v49 + 16))(&v49, ".");
        kdu_error::~kdu_error((kdu_error *)&v49);
      }
      if (v48 > 256 || *(int *)&v53[4] < v31)
      {
        int v39 = kdu_output::put(a2, v55[4]) + v38;
        if (v48 >= 257)
        {
          char v41 = v55[0];
          kdu_output::put(a2, v55[1]);
          kdu_output::put(a2, v41);
          int v40 = 2;
          goto LABEL_107;
        }
      }
      else
      {
        *(_DWORD *)&v53[4] = 0;
        int v39 = kdu_output::put(a2, v55[4]) + v38;
      }
      int v40 = kdu_output::put(a2, v55[0]);
LABEL_107:
      char v42 = v54[4];
      kdu_output::put(a2, v54[5]);
      kdu_output::put(a2, v42);
      int v43 = kdu_output::put(a2, v54[0]);
      char v44 = v53[4];
      if (v48 >= 257)
      {
        kdu_output::put(a2, v53[5]);
        kdu_output::put(a2, v44);
        int v45 = 2;
      }
      else
      {
        int v45 = kdu_output::put(a2, v53[4]);
      }
      int v38 = v39 + v40 + v43 + v45 + kdu_output::put(a2, v53[0]) + 2;
      if (v47 == ++v36)
      {
        uint64_t result = v46;
        if (v46 != v38) {
          poc_params::write_marker_segment();
        }
        return result;
      }
    }
  }
  return result;
}

void sub_1886A4B48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886A4B54(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  _Unwind_Resume(v23);
}

BOOL poc_params::check_marker_segment(poc_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  *a5 = -1;
  return a2 == 65375;
}

BOOL poc_params::read_marker_segment(poc_params *this, int a2, int a3, unsigned __int8 *a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (a2 != 65375) {
    return a2 == 65375;
  }
  int v25 = 0;
  int v8 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
  if (!v8 || (kdu_params::get(v8, "Scomponents", 0, 0, &v25, 1, 1, 1) & 1) == 0) {
    poc_params::read_marker_segment();
  }
  int v9 = v25;
  if (v25 < 257) {
    uint64_t v10 = 1;
  }
  else {
    uint64_t v10 = 2;
  }
  int v11 = a3 / (2 * (int)v10 + 5);
  if (v11 < 1)
  {
LABEL_34:
    exception = __cxa_allocate_exception(8uLL);
    void *exception = a4;
    goto LABEL_36;
  }
  int v12 = 0;
  int v13 = &a4[a3];
  do
  {
    if (v13 - a4 <= 0) {
      goto LABEL_34;
    }
    int v14 = a4 + 1;
    kdu_params::set(this, "Porder", v12, 0, (int *)*a4);
    if (v13 - (a4 + 1) < v10
      || ((int v15 = (int *)a4[1], v9 >= 257)
        ? (int v14 = a4 + 3, v15 = (int *)(a4[2] | (v15 << 8)))
        : (int *)(int v14 = a4 + 2),
          kdu_params::set(this, "Porder", v12, 1, v15),
          v13 - v14 <= 1))
    {
      exception = __cxa_allocate_exception(8uLL);
      void *exception = v14;
LABEL_36:
      __cxa_throw(exception, MEMORY[0x1E4FBA318], 0);
    }
    a4 = v14 + 2;
    kdu_params::set(this, "Porder", v12, 2, (int *)__rev16(*(unsigned __int16 *)v14));
    if (v13 - (v14 + 2) <= 0) {
      goto LABEL_34;
    }
    kdu_params::set(this, "Porder", v12, 3, (int *)v14[2]);
    int v16 = v14 + 3;
    if (v13 - (v14 + 3) < v10
      || ((unsigned int v17 = v14[3], v9 >= 257) ? (unsigned __int8 *)(v16 = v14 + 5, unsigned int v17 = v14[4] | (v17 << 8)) : (v16 = v14 + 4),
          !v17 ? (BOOL v18 = v9 < 257) : (BOOL v18 = 0),
          !v18 ? (uint64_t v19 = v17) : (uint64_t v19 = 256),
          kdu_params::set(this, "Porder", v12, 4, (int *)v19),
          v13 - v16 <= 0))
    {
      int v22 = __cxa_allocate_exception(8uLL);
      void *v22 = v16;
      __cxa_throw(v22, MEMORY[0x1E4FBA318], 0);
    }
    kdu_params::set(this, "Porder", v12, 5, (int *)*v16);
    a4 = v16 + 1;
    ++v12;
  }
  while (v11 != v12);
  if (a4 != v13)
  {
    uint64_t v24 = 0;
    memset(v23, 0, sizeof(v23));
    kdu_error::kdu_error((kdu_error *)v23, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v23[0] + 16))(v23, "Malformed POC marker segment encountered. The final ");
    long long v29 = 0u;
    long long v30 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    *(_OWORD *)int v26 = 0u;
    if (BYTE8(v23[0])) {
      sprintf(v26, "%x");
    }
    else {
      sprintf(v26, "%d");
    }
    (*(void (**)(_OWORD *, char *))(*(void *)&v23[0] + 16))(v23, v26);
    (*(void (**)(_OWORD *, const char *))(*(void *)&v23[0] + 16))(v23, " bytes were not consumed!");
    kdu_error::~kdu_error((kdu_error *)v23);
  }
  return a2 == 65375;
}

void sub_1886A4F94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11, long long a12, uint64_t a13)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    a13 = 0;
    a11 = 0u;
    a12 = 0u;
    kdu_error::kdu_error((kdu_error *)&a11, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(a11 + 16))(&a11, "Malformed POC marker segment encountered. Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a11);
  }
  _Unwind_Resume(a1);
}

void sub_1886A5034()
{
}

void sub_1886A503C(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886A5048()
{
}

void crg_params::crg_params(crg_params *this)
{
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18898D540;
  *(_DWORD *)((char *)this + 38) = 0;
  *((unsigned char *)this + 42) = 0;
  *((void *)this + 6) = this;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 9) = this;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = this;
  *((_WORD *)this + 18) = 1;
  *((unsigned char *)this + 104) = 0;
  *((void *)this + 14) = 0;
  *(void *)this = &unk_1ED4DE748;
  *((void *)this + 1) = "CRG";
}

void sub_1886A510C(_Unwind_Exception *a1)
{
  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t crg_params::copy_with_xforms(crg_params *this, kdu_params *a2, int a3, int a4, int a5, char a6, int a7)
{
  if ((a6 & 1) != 0 || a7)
  {
    return kdu_params::delete_unparsed_attribute((uint64_t)this, "CRGoffset");
  }
  else
  {
    int v11 = (kdu_params *)kdu_params::access_cluster(a2, "SIZ");
    uint64_t v12 = kdu_params::access_cluster(this, "SIZ");
    if (!v11 || (int v13 = (kdu_params *)v12) == 0) {
      crg_params::copy_with_xforms();
    }
    *(void *)long long v28 = 0;
    *(void *)long long v29 = 0;
    *(void *)int v26 = 0;
    *(void *)long long v27 = 0;
    if (!kdu_params::get(v11, "Ssize", 0, 0, v29, 1, 1, 1)
      || !kdu_params::get(v11, "Ssize", 0, 1, &v29[1], 1, 1, 1)
      || !kdu_params::get(v11, "Sorigin", 0, 0, v28, 1, 1, 1)
      || !kdu_params::get(v11, "Sorigin", 0, 1, &v28[1], 1, 1, 1)
      || !kdu_params::get(v13, "Ssize", 0, 0, v27, 1, 1, 1)
      || !kdu_params::get(v13, "Ssize", 0, 1, &v27[1], 1, 1, 1)
      || !kdu_params::get(v13, "Sorigin", 0, 0, v26, 1, 1, 1)
      || (kdu_params::get(v13, "Sorigin", 0, 1, &v26[1], 1, 1, 1) & 1) == 0)
    {
      crg_params::copy_with_xforms();
    }
    int32x2_t v14 = vsub_s32(*(int32x2_t *)v29, *(int32x2_t *)v28);
    *(int32x2_t *)long long v29 = v14;
    int32x2_t v15 = vsub_s32(*(int32x2_t *)v27, *(int32x2_t *)v26);
    *(int32x2_t *)long long v27 = v15;
    __int32 v16 = v14.i32[0];
    if (a5)
    {
      v29[0] = v14.i32[1];
      v29[1] = v14.i32[0];
      __int32 v17 = v14.i32[1];
    }
    else
    {
      __int32 v17 = v14.i32[0];
      __int32 v16 = v14.i32[1];
    }
    int v19 = v16 / v15.i32[1];
    int v20 = v17 / v15.i32[0];
    if (v16 / v15.i32[1] < 1 || v20 <= 0) {
      crg_params::copy_with_xforms();
    }
    uint64_t v25 = 0;
    uint64_t result = kdu_params::get(a2, "CRGoffset", 0, a5, (float *)&v25 + 1, 0, 0, 1);
    if (result)
    {
      int v22 = 0;
      float v23 = (float)v20;
      do
      {
        uint64_t result = kdu_params::get(a2, "CRGoffset", v22, a5 ^ 1u, (float *)&v25, 0, 0, 1);
        if (!result) {
          break;
        }
        float v24 = *((float *)&v25 + 1) / v23;
        *(float *)&uint64_t v25 = *(float *)&v25 / (float)v19;
        *((float *)&v25 + 1) = *((float *)&v25 + 1) / v23;
        if (v22 >= a3)
        {
          kdu_params::set((uint64_t)this, "CRGoffset", v22 - a3, 0, v24);
          kdu_params::set((uint64_t)this, "CRGoffset", v22 - a3, 1, *(float *)&v25);
        }
        uint64_t result = kdu_params::get(a2, "CRGoffset", ++v22, a5, (float *)&v25 + 1, 0, 0, 1);
      }
      while ((result & 1) != 0);
      if (v22)
      {
        if (v22 <= a3)
        {
          kdu_params::set((uint64_t)this, "CRGoffset", 0, 0, *((float *)&v25 + 1));
          return kdu_params::set((uint64_t)this, "CRGoffset", 0, 1, *(float *)&v25);
        }
      }
    }
  }
  return result;
}

uint64_t crg_params::write_marker_segment(crg_params *this, kdu_output *a2, kdu_params *a3, int a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (a4) {
    return 0;
  }
  if ((*((_DWORD *)this + 5) & 0x80000000) == 0) {
    return 0;
  }
  uint64_t v22 = 0;
  if (!kdu_params::get(this, "CRGoffset", 0, 0, (float *)&v22, 1, 1, 1)) {
    return 0;
  }
  if (a3) {
    crg_params::write_marker_segment();
  }
  int v21 = 0;
  unsigned int v7 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
  if (!v7 || (kdu_params::get(v7, "Scomponents", 0, 0, &v21, 1, 1, 1) & 1) == 0) {
    crg_params::write_marker_segment();
  }
  __int16 v8 = 4 * v21;
  uint64_t v9 = (4 * v21 + 4);
  if (a2)
  {
    kdu_output::put(a2, 255);
    kdu_output::put(a2, 99);
    kdu_output::put(a2, SHIBYTE(v8));
    kdu_output::put(a2, v8 | 2);
    if (v21 < 1)
    {
      int v11 = 4;
    }
    else
    {
      int v10 = 0;
      int v11 = 4;
      do
      {
        if (!kdu_params::get(this, "CRGoffset", v10, 0, (float *)&v22, 1, 1, 1)
          || (kdu_params::get(this, "CRGoffset", v10, 1, (float *)&v22 + 1, 1, 1, 1) & 1) == 0)
        {
          *(void *)&long long v25 = 0;
          *(_OWORD *)float v23 = 0u;
          long long v24 = 0u;
          kdu_error::kdu_error((kdu_error *)v23, "Kakadu Core Error:\n");
          (*(void (**)(char *, const char *))(*(void *)v23 + 16))(v23, "Component registration information incomplete!");
          kdu_error::~kdu_error((kdu_error *)v23);
        }
        BOOL v12 = *((float *)&v22 + 1) >= 0.0 && *((float *)&v22 + 1) < 1.0;
        if (!v12 || (*(float *)&v22 >= 0.0 ? (BOOL v13 = *(float *)&v22 < 1.0) : (BOOL v13 = 0), !v13))
        {
          uint64_t v20 = 0;
          memset(v19, 0, sizeof(v19));
          kdu_error::kdu_error((kdu_error *)v19, "Kakadu Core Error:\n");
          (*(void (**)(_OWORD *, const char *))(*(void *)&v19[0] + 16))(v19, "Illegal component registration offsets, {");
          long long v26 = 0u;
          long long v27 = 0u;
          long long v24 = 0u;
          long long v25 = 0u;
          *(_OWORD *)float v23 = 0u;
          sprintf(v23, "%f", *(float *)&v22);
          (*(void (**)(_OWORD *, char *))(*(void *)&v19[0] + 16))(v19, v23);
          (*(void (**)(_OWORD *, const char *))(*(void *)&v19[0] + 16))(v19, ",");
          long long v26 = 0u;
          long long v27 = 0u;
          long long v24 = 0u;
          long long v25 = 0u;
          *(_OWORD *)float v23 = 0u;
          sprintf(v23, "%f", *((float *)&v22 + 1));
          (*(void (**)(_OWORD *, char *))(*(void *)&v19[0] + 16))(v19, v23);
          (*(void (**)(_OWORD *, const char *))(*(void *)&v19[0] + 16))(v19, "}.  Legal range is from 0.0 to 1.0 (exclusive).");
          kdu_error::~kdu_error((kdu_error *)v19);
        }
        int v14 = vcvtms_s32_f32((float)(*((float *)&v22 + 1) * 65536.0) + 0.5);
        if (v14 >= 0xFFFF) {
          __int16 v15 = -1;
        }
        else {
          __int16 v15 = v14;
        }
        int v16 = vcvtms_s32_f32((float)(*(float *)&v22 * 65536.0) + 0.5);
        if (v16 >= 0xFFFF) {
          __int16 v17 = -1;
        }
        else {
          __int16 v17 = v16;
        }
        kdu_output::put(a2, SHIBYTE(v15));
        kdu_output::put(a2, v15);
        kdu_output::put(a2, SHIBYTE(v17));
        kdu_output::put(a2, v17);
        v11 += 4;
        ++v10;
      }
      while (v10 < v21);
    }
    if (v9 != v11) {
      crg_params::write_marker_segment();
    }
  }
  return v9;
}

void sub_1886A594C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886A5958(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(v11);
}

BOOL crg_params::check_marker_segment(crg_params *this, int a2, int a3, unsigned __int8 *a4, int *a5)
{
  *a5 = -1;
  return a2 == 65379;
}

uint64_t crg_params::read_marker_segment(crg_params *this, int a2, int a3, unsigned __int8 *a4, int a5)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  BOOL v5 = a2 == 65379 && a5 == 0;
  if (!v5 || (*((_DWORD *)this + 5) & 0x80000000) == 0) {
    return 0;
  }
  int v17 = 0;
  int v10 = (kdu_params *)kdu_params::access_cluster(this, "SIZ");
  if (!v10 || !kdu_params::get(v10, "Scomponents", 0, 0, &v17, 1, 1, 1)) {
    crg_params::read_marker_segment();
  }
  int v11 = a4;
  if (v17 >= 1)
  {
    int v12 = 0;
    uint64_t v13 = a3;
    int v11 = a4;
    while (v13 > 1)
    {
      kdu_params::set((uint64_t)this, "CRGoffset", v12, 1, (float)((float)(int)__rev16(*(unsigned __int16 *)v11) * 0.000015259));
      if (v13 - 2 <= 1)
      {
        exception = __cxa_allocate_exception(8uLL);
        void *exception = v11 + 2;
LABEL_24:
        __cxa_throw(exception, MEMORY[0x1E4FBA318], 0);
      }
      kdu_params::set((uint64_t)this, "CRGoffset", v12, 0, (float)((float)(int)__rev16(*((unsigned __int16 *)v11 + 1)) * 0.000015259));
      v11 += 4;
      ++v12;
      v13 -= 4;
      if (v12 >= v17) {
        goto LABEL_16;
      }
    }
    exception = __cxa_allocate_exception(8uLL);
    void *exception = v11;
    goto LABEL_24;
  }
LABEL_16:
  if (v11 != &a4[a3])
  {
    uint64_t v16 = 0;
    memset(v15, 0, sizeof(v15));
    kdu_error::kdu_error((kdu_error *)v15, "Kakadu Core Error:\n");
    (*(void (**)(_OWORD *, const char *))(*(void *)&v15[0] + 16))(v15, "Malformed CRG marker segment encountered. The final ");
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    *(_OWORD *)BOOL v18 = 0u;
    if (BYTE8(v15[0])) {
      sprintf(v18, "%x");
    }
    else {
      sprintf(v18, "%d");
    }
    (*(void (**)(_OWORD *, char *))(*(void *)&v15[0] + 16))(v15, v18);
    (*(void (**)(_OWORD *, const char *))(*(void *)&v15[0] + 16))(v15, " bytes were not consumed!");
    kdu_error::~kdu_error((kdu_error *)v15);
  }
  return 1;
}

void sub_1886A5C60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, long long a11, long long a12, uint64_t a13)
{
  if (a2 == 1)
  {
    __cxa_begin_catch(a1);
    a13 = 0;
    a11 = 0u;
    a12 = 0u;
    kdu_error::kdu_error((kdu_error *)&a11, "Kakadu Core Error:\n");
    (*(void (**)(long long *, const char *))(a11 + 16))(&a11, "Malformed CRG marker segment encountered. Marker segment is too small.");
    kdu_error::~kdu_error((kdu_error *)&a11);
  }
  _Unwind_Resume(a1);
}

void sub_1886A5CF8()
{
}

void sub_1886A5D00(uint64_t a1, uint64_t a2, ...)
{
  va_start(va, a2);
  kdu_error::~kdu_error((kdu_error *)va);
}

void sub_1886A5D0C()
{
}

void org_params::org_params(org_params *this)
{
  *((void *)this + 1) = "ORG";
  *((_DWORD *)this + 8) = 0;
  *((_OWORD *)this + 1) = xmmword_18898D540;
  *((_WORD *)this + 20) = 1;
  *((unsigned char *)this + 42) = 0;
  *((void *)this + 6) = this;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = (char *)this + 72;
  *((void *)this + 9) = this;
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  *((void *)this + 10) = this;
  *((unsigned char *)this + 104) = 0;
  *((_DWORD *)this + 9) = 65537;
  *((void *)this + 14) = 0;
  *(void *)this = &unk_1ED4DEB38;
}

void sub_1886A5E20(_Unwind_Exception *a1)
{
  kdu_params::~kdu_params(v1);
  _Unwind_Resume(a1);
}

uint64_t org_params::copy_with_xforms(org_params *this, kdu_params *a2)
{
  int v6 = 0;
  BOOL v5 = 0;
  if (kdu_params::get(a2, "ORGtparts", 0, 0, &v6, 0, 1, 1)) {
    kdu_params::set(this, "ORGtparts", 0, 0, (int *)v6);
  }
  uint64_t result = kdu_params::get(a2, "ORGgen_plt", 0, 0, &v5, 0, 1, 1);
  if (result) {
    return kdu_params::set((uint64_t)this, "ORGgen_plt", 0, 0, v5);
  }
  return result;
}

uint64_t kdu_params::write_marker_segment(kdu_params *this, kdu_output *a2, kdu_params *a3)
{
  return 0;
}

uint64_t kdu_params::custom_parse_field(kdu_params *this, const char *a2, const char *a3, int a4, int *a5)
{
  return 0;
}

uint64_t siz_params::new_object(siz_params *this)
{
  return 0;
}

void siz_params::~siz_params(siz_params *this)
{
  kdu_params::~kdu_params(this);

  JUMPOUT(0x18C11C0E0);
}

void mct_params::new_object(mct_params *this)
{
}

void sub_1886A5F98(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C40E369BBFALL);
  _Unwind_Resume(a1);
}

void mct_params::~mct_params(mct_params *this)
{
  kdu_params::~kdu_params(this);

  JUMPOUT(0x18C11C0E0);
}

void mcc_params::new_object(mcc_params *this)
{
}

void sub_1886A6038(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void mcc_params::~mcc_params(mcc_params *this)
{
  kdu_params::~kdu_params(this);

  JUMPOUT(0x18C11C0E0);
}

void mco_params::new_object(mco_params *this)
{
}

void sub_1886A60D8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void mco_params::~mco_params(mco_params *this)
{
  kdu_params::~kdu_params(this);

  JUMPOUT(0x18C11C0E0);
}

void atk_params::new_object(atk_params *this)
{
}

void sub_1886A6178(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void atk_params::~atk_params(atk_params *this)
{
  kdu_params::~kdu_params(this);

  JUMPOUT(0x18C11C0E0);
}

void cod_params::new_object(cod_params *this)
{
}

void sub_1886A6218(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void cod_params::~cod_params(cod_params *this)
{
  kdu_params::~kdu_params(this);

  JUMPOUT(0x18C11C0E0);
}

void ads_params::new_object(ads_params *this)
{
}

void sub_1886A62B8(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void ads_params::~ads_params(ads_params *this)
{
  kdu_params::~kdu_params(this);

  JUMPOUT(0x18C11C0E0);
}

void dfs_params::new_object(dfs_params *this)
{
}

void sub_1886A635C(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void dfs_params::~dfs_params(dfs_params *this)
{
  kdu_params::~kdu_params(this);

  JUMPOUT(0x18C11C0E0);
}

void qcd_params::new_object(qcd_params *this)
{
}

void sub_1886A6400(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void qcd_params::~qcd_params(qcd_params *this)
{
  kdu_params::~kdu_params(this);

  JUMPOUT(0x18C11C0E0);
}

void rgn_params::new_object(rgn_params *this)
{
}

void sub_1886A64A0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void rgn_params::~rgn_params(rgn_params *this)
{
  kdu_params::~kdu_params(this);

  JUMPOUT(0x18C11C0E0);
}

void poc_params::new_object(poc_params *this)
{
}

void sub_1886A6540(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void poc_params::~poc_params(poc_params *this)
{
  kdu_params::~kdu_params(this);

  JUMPOUT(0x18C11C0E0);
}

void crg_params::new_object(crg_params *this)
{
}

void sub_1886A65E0(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void crg_params::~crg_params(crg_params *this)
{
  kdu_params::~kdu_params(this);

  JUMPOUT(0x18C11C0E0);
}

void org_params::new_object(org_params *this)
{
}

void sub_1886A6680(_Unwind_Exception *a1)
{
  MEMORY[0x18C11C0E0](v1, 0x10F1C40EB7485B5);
  _Unwind_Resume(a1);
}

void org_params::~org_params(org_params *this)
{
  kdu_params::~kdu_params(this);

  JUMPOUT(0x18C11C0E0);
}

uint64_t org_params::check_marker_segment(org_params *this, unsigned __int16 a2, int a3, unsigned __int8 *a4, int *a5)
{
  return 0;
}

uint64_t org_params::read_marker_segment(org_params *this, unsigned __int16 a2, int a3, unsigned __int8 *a4)
{
  return 0;
}

double _cg_jinit_huff_decoder(uint64_t a1)
{
  uint64_t v2 = (**(uint64_t (***)(void))(a1 + 8))();
  uint64_t v3 = v2;
  *(void *)(a1 + 624) = v2;
  *(void *)uint64_t v2 = start_pass_huff_decoder;
  *(void *)(v2 + 16) = finish_pass_huff_0;
  if (*(_DWORD *)(a1 + 316))
  {
    int v4 = (_OWORD *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, (uint64_t)*(int *)(a1 + 56) << 8);
    *(void *)(a1 + 192) = v4;
    if (*(int *)(a1 + 56) >= 1)
    {
      int v5 = 0;
      *(void *)&long long v6 = -1;
      *((void *)&v6 + 1) = -1;
      do
      {
        v4[14] = v6;
        v4[15] = v6;
        v4[12] = v6;
        v4[13] = v6;
        v4[10] = v6;
        v4[11] = v6;
        v4[8] = v6;
        v4[9] = v6;
        v4[6] = v6;
        v4[7] = v6;
        v4[4] = v6;
        void v4[5] = v6;
        int v4[2] = v6;
        v4[3] = v6;
        _OWORD *v4 = v6;
        v4[1] = v6;
        v4 += 16;
        ++v5;
      }
      while (v5 < *(_DWORD *)(a1 + 56));
    }
    double result = 0.0;
    *(_OWORD *)(v3 + 88) = 0u;
    *(_OWORD *)(v3 + 72) = 0u;
  }
  else
  {
    double result = 0.0;
    *(_OWORD *)(v2 + 112) = 0u;
    *(_OWORD *)(v2 + 128) = 0u;
    *(_OWORD *)(v2 + 144) = 0u;
    *(_OWORD *)(v2 + 160) = 0u;
  }
  return result;
}

void start_pass_huff_decoder(_DWORD *a1)
{
  uint64_t v2 = *((void *)a1 + 78);
  int v3 = a1[135];
  if (a1[79])
  {
    int v4 = a1[136];
    if (v3)
    {
      if (v4 < v3 || v4 > a1[142] || a1[112] != 1) {
        goto LABEL_79;
      }
    }
    else if (v4)
    {
      goto LABEL_79;
    }
    int v42 = a1[137];
    if (v42)
    {
      int v43 = v42 - 1;
      if (v43 != a1[138]) {
        goto LABEL_79;
      }
    }
    else
    {
      int v43 = a1[138];
    }
    if (v43 < 14)
    {
LABEL_80:
      LODWORD(v45) = a1[112];
      if ((int)v45 >= 1)
      {
        uint64_t v46 = 0;
        do
        {
          uint64_t v47 = *(int *)(*(void *)&a1[2 * v46 + 114] + 4);
          int v48 = (_DWORD *)(*((void *)a1 + 24) + (v47 << 8));
          int v49 = a1[135];
          if (v49 && (*v48 & 0x80000000) != 0)
          {
            uint64_t v50 = *(void *)a1;
            *(_DWORD *)(v50 + 40) = 118;
            *(_DWORD *)(v50 + 48) = v47;
            *(_DWORD *)(*(void *)a1 + 52) = 0;
            (*(void (**)(_DWORD *, uint64_t))(*(void *)a1 + 8))(a1, 0xFFFFFFFFLL);
            int v49 = a1[135];
          }
          if (v49 <= a1[136])
          {
            uint64_t v51 = v49;
            do
            {
              if (a1[137] != (v48[v51] & ~((int)v48[v51] >> 31)))
              {
                uint64_t v52 = *(void *)a1;
                *(_DWORD *)(v52 + 40) = 118;
                *(_DWORD *)(v52 + 48) = v47;
                *(_DWORD *)(*(void *)a1 + 52) = v51;
                (*(void (**)(_DWORD *, uint64_t))(*(void *)a1 + 8))(a1, 0xFFFFFFFFLL);
              }
              v48[v51] = a1[138];
            }
            while (v51++ < (int)a1[136]);
          }
          ++v46;
          uint64_t v45 = (int)a1[112];
        }
        while (v46 < v45);
      }
      int v54 = a1[135];
      BOOL v55 = v54 == 0;
      if (v54) {
        __int16 v56 = decode_mcu_AC_first;
      }
      else {
        __int16 v56 = decode_mcu_DC_first;
      }
      long long v57 = decode_mcu_AC_refine;
      if (v55) {
        long long v57 = decode_mcu_DC_refine;
      }
      if (!a1[137]) {
        long long v57 = v56;
      }
      *(void *)(v2 + 8) = v57;
      if ((int)v45 >= 1)
      {
        uint64_t v58 = 0;
        do
        {
          uint64_t v59 = *(void *)&a1[2 * v58 + 114];
          if (a1[135])
          {
            uint64_t v60 = *(int *)(v59 + 24);
            uint64_t v61 = v2 + 8 * v60;
            jpeg_make_d_derived_tbl((uint64_t)a1, 0, v60, (void *)(v61 + 72));
            *(void *)(v2 + 104) = *(void *)(v61 + 72);
          }
          else if (!a1[137])
          {
            jpeg_make_d_derived_tbl((uint64_t)a1, 1, *(_DWORD *)(v59 + 20), (void *)(v2 + 8 * *(int *)(v59 + 20) + 72));
          }
          *(_DWORD *)(v2 + 44 + 4 * v58++) = 0;
        }
        while (v58 < (int)a1[112]);
      }
      *(_DWORD *)(v2 + 40) = 0;
      goto LABEL_106;
    }
LABEL_79:
    uint64_t v44 = *(void *)a1;
    *(_DWORD *)(v44 + 40) = 17;
    *(_DWORD *)(v44 + 48) = v3;
    *(_DWORD *)(*(void *)a1 + 52) = a1[136];
    *(_DWORD *)(*(void *)a1 + 56) = a1[137];
    *(_DWORD *)(*(void *)a1 + 60) = a1[138];
    (**(void (***)(_DWORD *))a1)(a1);
    goto LABEL_80;
  }
  if (v3 || a1[137] || a1[138] || ((int v63 = a1[136], a1[78]) || v63 <= 63) && v63 != a1[142])
  {
    uint64_t v5 = *(void *)a1;
    *(_DWORD *)(v5 + 40) = 125;
    (*(void (**)(_DWORD *, uint64_t))(v5 + 8))(a1, 0xFFFFFFFFLL);
  }
  long long v6 = decode_mcu_sub;
  if (a1[142] == 63) {
    long long v6 = decode_mcu;
  }
  *(void *)(v2 + 8) = v6;
  if ((int)a1[112] >= 1)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = *(void *)&a1[2 * v7 + 114];
      jpeg_make_d_derived_tbl((uint64_t)a1, 1, *(_DWORD *)(v8 + 20), (void *)(v2 + 8 * *(int *)(v8 + 20) + 112));
      if (a1[142]) {
        jpeg_make_d_derived_tbl((uint64_t)a1, 0, *(_DWORD *)(v8 + 24), (void *)(v2 + 8 * *(int *)(v8 + 24) + 144));
      }
      *(_DWORD *)(v2 + 44 + 4 * v7++) = 0;
    }
    while (v7 < (int)a1[112]);
  }
  if ((int)a1[124] >= 1)
  {
    uint64_t v9 = 0;
    uint64_t v10 = v2 + 336;
    do
    {
      int v11 = *(int **)&a1[2 * a1[v9 + 125] + 114];
      uint64_t v12 = v10 + 8 * v9;
      *(void *)(v12 - 160) = *(void *)(v2 + 8 * v11[5] + 112);
      int v13 = a1[142];
      if (v13) {
        uint64_t v14 = *(void *)(v2 + 8 * v11[6] + 144);
      }
      else {
        uint64_t v14 = 0;
      }
      *(void *)(v12 - 80) = v14;
      if (v11[13])
      {
        int v17 = v11 + 9;
        int v15 = v11[9];
        int v16 = v17[1];
        if (v13 > 14)
        {
          if (v13 > 34)
          {
            if (v13 == 35)
            {
              unsigned int v36 = v16 - 7;
              int v37 = v16 - 1;
              unsigned int v38 = v15 - 7;
              int v21 = v15 - 1;
              if (v36 < 0xFFFFFFFA) {
                int v37 = 5;
              }
              if (v38 < 0xFFFFFFFA) {
                int v21 = 5;
              }
              long long v22 = (char *)&jpeg_zigzag_order6 + 24 * v37;
            }
            else
            {
              if (v13 != 48) {
                goto LABEL_65;
              }
              unsigned int v27 = v16 - 8;
              int v28 = v16 - 1;
              unsigned int v29 = v15 - 8;
              int v21 = v15 - 1;
              if (v27 < 0xFFFFFFF9) {
                int v28 = 6;
              }
              if (v29 < 0xFFFFFFF9) {
                int v21 = 6;
              }
              long long v22 = (char *)&jpeg_zigzag_order7 + 28 * v28;
            }
          }
          else if (v13 == 15)
          {
            unsigned int v30 = v16 - 5;
            int v31 = v16 - 1;
            unsigned int v32 = v15 - 5;
            int v21 = v15 - 1;
            if (v30 < 0xFFFFFFFC) {
              int v31 = 3;
            }
            if (v32 < 0xFFFFFFFC) {
              int v21 = 3;
            }
            long long v22 = (char *)&jpeg_zigzag_order4 + 16 * v31;
          }
          else
          {
            if (v13 != 24) {
              goto LABEL_65;
            }
            unsigned int v18 = v16 - 6;
            int v19 = v16 - 1;
            unsigned int v20 = v15 - 6;
            int v21 = v15 - 1;
            if (v18 < 0xFFFFFFFB) {
              int v19 = 4;
            }
            if (v20 < 0xFFFFFFFB) {
              int v21 = 4;
            }
            long long v22 = (char *)&jpeg_zigzag_order5 + 20 * v19;
          }
          goto LABEL_70;
        }
        if (v13)
        {
          if (v13 == 3)
          {
            unsigned int v33 = v16 - 3;
            int v34 = v16 - 1;
            unsigned int v35 = v15 - 3;
            int v21 = v15 - 1;
            if (v33 < 0xFFFFFFFE) {
              int v34 = 1;
            }
            if (v35 < 0xFFFFFFFE) {
              int v21 = 1;
            }
            long long v22 = (char *)&jpeg_zigzag_order2 + 8 * v34;
            goto LABEL_70;
          }
          if (v13 == 8)
          {
            unsigned int v24 = v16 - 4;
            int v25 = v16 - 1;
            unsigned int v26 = v15 - 4;
            int v21 = v15 - 1;
            if (v24 < 0xFFFFFFFD) {
              int v25 = 2;
            }
            if (v26 < 0xFFFFFFFD) {
              int v21 = 2;
            }
            long long v22 = (char *)&jpeg_zigzag_order3 + 12 * v25;
            goto LABEL_70;
          }
LABEL_65:
          unsigned int v39 = v16 - 9;
          int v40 = v16 - 1;
          unsigned int v41 = v15 - 9;
          int v21 = v15 - 1;
          if (v39 < 0xFFFFFFF8) {
            int v40 = 7;
          }
          if (v41 < 0xFFFFFFF8) {
            int v21 = 7;
          }
          long long v22 = (char *)&jpeg_zigzag_order + 32 * v40;
LABEL_70:
          int v23 = *(_DWORD *)&v22[4 * v21] + 1;
          goto LABEL_71;
        }
        int v23 = 1;
      }
      else
      {
        int v23 = 0;
      }
LABEL_71:
      *(_DWORD *)(v10 + 4 * v9++) = v23;
    }
    while (v9 < (int)a1[124]);
  }
LABEL_106:
  *(_DWORD *)(v2 + 32) = 0;
  *(void *)(v2 + 24) = 0;
  int v62 = a1[93];
  *(_DWORD *)(v2 + 60) = 0;
  *(_DWORD *)(v2 + 64) = v62;
}

uint64_t finish_pass_huff_0(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 624);
  *(_DWORD *)(*(void *)(result + 616) + 36) += *(_DWORD *)(v1 + 32) / 8;
  *(_DWORD *)(v1 + 32) = 0;
  return result;
}

uint64_t decode_mcu_DC_first(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 624);
  int v5 = *(_DWORD *)(a1 + 552);
  if (!*(_DWORD *)(a1 + 372) || *(_DWORD *)(v4 + 64) || (uint64_t result = process_restart(a1), result))
  {
    if (!*(_DWORD *)(v4 + 60))
    {
      uint64_t v33 = a1;
      uint64_t v7 = *(unsigned __int8 ***)(a1 + 40);
      uint64_t v8 = *v7;
      uint64_t v9 = v7[1];
      unsigned int v29 = *v7;
      unsigned int v30 = v9;
      uint64_t v10 = *(void *)(v4 + 24);
      int v11 = *(_DWORD *)(v4 + 32);
      long long v27 = *(_OWORD *)(v4 + 40);
      int v28 = *(_DWORD *)(v4 + 56);
      if (*(int *)(a1 + 496) >= 1)
      {
        uint64_t v12 = 0;
        uint64_t v31 = 0;
        uint64_t v32 = 0;
        while (1)
        {
          int v13 = *(_WORD **)(a2 + 8 * v12);
          uint64_t v14 = *(int *)(a1 + 500 + 4 * v12);
          uint64_t v15 = *(void *)(v4 + 8 * *(int *)(*(void *)(a1 + 8 * v14 + 456) + 20) + 72);
          if (v11 > 7) {
            goto LABEL_11;
          }
          uint64_t result = jpeg_fill_bit_buffer(&v29, v10, v11, 0);
          if (!result) {
            return result;
          }
          uint64_t v10 = v31;
          int v11 = v32;
          if ((int)v32 >= 8)
          {
LABEL_11:
            uint64_t v17 = v10 >> (v11 - 8);
            int v18 = *(_DWORD *)(v15 + 4 * v17 + 288);
            if (v18)
            {
              v11 -= v18;
              uint64_t v19 = v15 + v17;
              int v20 = *(unsigned __int8 *)(v19 + 1312);
              if (*(unsigned char *)(v19 + 1312)) {
                goto LABEL_17;
              }
              goto LABEL_13;
            }
            int v16 = 9;
          }
          else
          {
            int v16 = 1;
          }
          int v22 = jpeg_huff_decode((uint64_t)&v29, v10, v11, v15, v16);
          if (v22 < 0) {
            return 0;
          }
          int v20 = v22;
          uint64_t v10 = v31;
          int v11 = v32;
          if (v22)
          {
LABEL_17:
            if (v11 < v20)
            {
              uint64_t result = jpeg_fill_bit_buffer(&v29, v10, v11, v20);
              if (!result) {
                return result;
              }
              uint64_t v10 = v31;
              int v11 = v32;
            }
            v11 -= v20;
            int v23 = bmask[v20];
            int v24 = v23 & (v10 >> v11);
            if (v24 > bmask[v20 - 1]) {
              int v23 = 0;
            }
            int v21 = v24 - v23;
            goto LABEL_23;
          }
LABEL_13:
          int v21 = 0;
LABEL_23:
          int v25 = (char *)&v27 + 4 * v14;
          int v26 = *((_DWORD *)v25 + 1) + v21;
          *((_DWORD *)v25 + 1) = v26;
          _WORD *v13 = v26 << v5;
          if (++v12 >= *(int *)(a1 + 496))
          {
            uint64_t v7 = *(unsigned __int8 ***)(a1 + 40);
            uint64_t v8 = v29;
            uint64_t v9 = v30;
            break;
          }
        }
      }
      kdu_params *v7 = v8;
      v7[1] = v9;
      *(void *)(v4 + 24) = v10;
      *(_DWORD *)(v4 + 32) = v11;
      *(_OWORD *)(v4 + 40) = v27;
      *(_DWORD *)(v4 + 56) = v28;
    }
    if (*(_DWORD *)(a1 + 372)) {
      --*(_DWORD *)(v4 + 64);
    }
    return 1;
  }
  return result;
}

uint64_t decode_mcu_AC_first(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *(void *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    if (!*(_DWORD *)(v4 + 64))
    {
      uint64_t result = process_restart(a1);
      if (!result) {
        return result;
      }
    }
  }
  if (*(_DWORD *)(v4 + 60)) {
    goto LABEL_31;
  }
  int v6 = *(_DWORD *)(v4 + 40);
  if (v6)
  {
    int v7 = v6 - 1;
    goto LABEL_30;
  }
  uint64_t v34 = a1;
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v10 = *(unsigned __int8 **)v8;
  uint64_t v9 = *(void *)(v8 + 8);
  unsigned int v30 = v10;
  uint64_t v31 = v9;
  uint64_t v11 = *(void *)(v4 + 24);
  int v12 = *(_DWORD *)(v4 + 32);
  int v13 = *(_DWORD *)(a1 + 544);
  int v14 = *(_DWORD *)(a1 + 540);
  if (v14 > v13)
  {
LABEL_28:
    int v7 = 0;
    goto LABEL_29;
  }
  int v15 = *(_DWORD *)(a1 + 552);
  uint64_t v16 = *(void *)(a1 + 560);
  uint64_t v17 = *a2;
  uint64_t v18 = *(void *)(v4 + 104);
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  while (1)
  {
    if (v12 > 7) {
      goto LABEL_13;
    }
    uint64_t result = jpeg_fill_bit_buffer(&v30, v11, v12, 0);
    if (!result) {
      return result;
    }
    uint64_t v11 = v32;
    int v12 = v33;
    if ((int)v33 >= 8)
    {
LABEL_13:
      uint64_t v20 = v11 >> (v12 - 8);
      int v21 = *(_DWORD *)(v18 + 4 * v20 + 288);
      if (v21)
      {
        v12 -= v21;
        unsigned int v22 = *(unsigned __int8 *)(v18 + v20 + 1312);
        goto LABEL_18;
      }
      int v19 = 9;
    }
    else
    {
      int v19 = 1;
    }
    unsigned int v22 = jpeg_huff_decode((uint64_t)&v30, v11, v12, v18, v19);
    if ((v22 & 0x80000000) != 0) {
      return 0;
    }
    uint64_t v11 = v32;
    int v12 = v33;
LABEL_18:
    int v23 = v22 >> 4;
    int v24 = v22 & 0xF;
    if ((v22 & 0xF) != 0)
    {
      if (v12 < v24)
      {
        uint64_t result = jpeg_fill_bit_buffer(&v30, v11, v12, v24);
        if (!result) {
          return result;
        }
        uint64_t v11 = v32;
        int v12 = v33;
      }
      int v25 = v23 + v14;
      v12 -= v24;
      int v26 = bmask[v24];
      int v27 = v26 & (v11 >> v12);
      if (v27 > bmask[v24 - 1]) {
        int v26 = 0;
      }
      *(_WORD *)(v17 + 2 * *(int *)(v16 + 4 * v25)) = (v27 - v26) << v15;
      goto LABEL_27;
    }
    if (v23 != 15) {
      break;
    }
    int v25 = v14 + 15;
LABEL_27:
    int v14 = v25 + 1;
    if (v25 >= v13) {
      goto LABEL_28;
    }
  }
  if (v22 < 0x10) {
    goto LABEL_28;
  }
  if (v12 >= v23) {
    goto LABEL_40;
  }
  uint64_t result = jpeg_fill_bit_buffer(&v30, v11, v12, v23);
  if (result)
  {
    uint64_t v11 = v32;
    int v12 = v33;
LABEL_40:
    v12 -= v23;
    int v7 = (bmask[v23] & (v11 >> v12)) + ~(-1 << v23);
LABEL_29:
    int v28 = *(void **)(a1 + 40);
    uint64_t v29 = v31;
    void *v28 = v30;
    v28[1] = v29;
    *(void *)(v4 + 24) = v11;
    *(_DWORD *)(v4 + 32) = v12;
LABEL_30:
    *(_DWORD *)(v4 + 40) = v7;
LABEL_31:
    if (*(_DWORD *)(a1 + 372)) {
      --*(_DWORD *)(v4 + 64);
    }
    return 1;
  }
  return result;
}

uint64_t decode_mcu_DC_refine(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 624);
  if (!*(_DWORD *)(a1 + 372) || *(_DWORD *)(v4 + 64) || (uint64_t result = process_restart(a1), result))
  {
    uint64_t v17 = a1;
    int v6 = *(unsigned __int8 ***)(a1 + 40);
    int v7 = *v6;
    uint64_t v8 = v6[1];
    int v13 = *v6;
    int v14 = v8;
    unint64_t v9 = *(void *)(v4 + 24);
    int v10 = *(_DWORD *)(v4 + 32);
    if (*(int *)(a1 + 496) >= 1)
    {
      uint64_t v11 = 0;
      unint64_t v15 = 0;
      uint64_t v16 = 0;
      int v12 = 1 << *(_DWORD *)(a1 + 552);
      do
      {
        if (v10 <= 0)
        {
          uint64_t result = jpeg_fill_bit_buffer(&v13, v9, v10, 1);
          if (!result) {
            return result;
          }
          unint64_t v9 = v15;
          int v10 = v16;
        }
        if ((v9 >> --v10)) {
          **(_WORD **)(a2 + 8 * v11) |= v12;
        }
        ++v11;
      }
      while (v11 < *(int *)(a1 + 496));
      int v6 = *(unsigned __int8 ***)(a1 + 40);
      int v7 = v13;
      uint64_t v8 = v14;
    }
    *int v6 = v7;
    v6[1] = v8;
    *(void *)(v4 + 24) = v9;
    *(_DWORD *)(v4 + 32) = v10;
    if (*(_DWORD *)(a1 + 372)) {
      --*(_DWORD *)(v4 + 64);
    }
    return 1;
  }
  return result;
}

uint64_t decode_mcu_AC_refine(uint64_t a1, uint64_t *a2)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    if (!*(_DWORD *)(v4 + 64))
    {
      uint64_t result = process_restart(a1);
      if (!result) {
        return result;
      }
    }
  }
  if (*(_DWORD *)(v4 + 60)) {
    goto LABEL_23;
  }
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  memset(v62, 0, sizeof(v62));
  int v6 = *(_DWORD *)(a1 + 544);
  int v7 = 0x10000 << *(_DWORD *)(a1 + 552);
  int v8 = v7 >> 16;
  uint64_t v53 = *(void *)(a1 + 560);
  uint64_t v61 = a1;
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v11 = *(unsigned __int8 **)v9;
  uint64_t v10 = *(void *)(v9 + 8);
  long long v57 = v11;
  uint64_t v58 = v10;
  uint64_t v12 = *(void *)(v4 + 24);
  int v13 = *(_DWORD *)(v4 + 32);
  uint64_t v14 = *a2;
  unsigned int v56 = HIWORD(v7);
  int v15 = *(_DWORD *)(a1 + 540);
  if (*(_DWORD *)(v4 + 40))
  {
    int v54 = *(_DWORD *)(v4 + 40);
    int v52 = 0;
    goto LABEL_7;
  }
  int v52 = 0;
  uint64_t v26 = *(void *)(v4 + 104);
  int v46 = -v7 >> 16;
  int v55 = -HIWORD(v7);
  __int16 v48 = HIWORD(v7);
  int v49 = v6;
  uint64_t v47 = v26;
  while (1)
  {
    if (v13 > 7) {
      goto LABEL_32;
    }
    if (!jpeg_fill_bit_buffer(&v57, v12, v13, 0)) {
      goto LABEL_75;
    }
    uint64_t v12 = v59;
    int v13 = v60;
    if ((int)v60 >= 8)
    {
LABEL_32:
      int v28 = *(_DWORD *)(v26 + 4 * (v12 >> (v13 - 8)) + 288);
      if (v28)
      {
        int v29 = v13 - v28;
        unsigned int v30 = *(unsigned __int8 *)(v26 + (v12 >> (v13 - 8)) + 1312);
        goto LABEL_37;
      }
      int v27 = 9;
    }
    else
    {
      int v27 = 1;
    }
    unsigned int v30 = jpeg_huff_decode((uint64_t)&v57, v12, v13, v26, v27);
    if ((v30 & 0x80000000) != 0) {
      goto LABEL_75;
    }
    uint64_t v12 = v59;
    int v29 = v60;
LABEL_37:
    int v31 = v30 >> 4;
    if ((v30 & 0xF) != 0)
    {
      if ((v30 & 0xF) != 1)
      {
        uint64_t v32 = *(void *)a1;
        *(_DWORD *)(v32 + 40) = 121;
        (*(void (**)(uint64_t, uint64_t))(v32 + 8))(a1, 0xFFFFFFFFLL);
      }
      if (v29 <= 0)
      {
        if (!jpeg_fill_bit_buffer(&v57, v12, v29, 1)) {
          goto LABEL_75;
        }
        uint64_t v12 = v59;
        int v29 = v60;
      }
      --v29;
      int v33 = v46;
      if (((unint64_t)v12 >> v29)) {
        int v33 = v8;
      }
      int v51 = v33;
      goto LABEL_48;
    }
    if (v31 != 15) {
      break;
    }
    int v51 = 0;
LABEL_48:
    if (v15 <= v6) {
      int v34 = v6;
    }
    else {
      int v34 = v15;
    }
    int v50 = v34 + 1;
    uint64_t v35 = v34 - (uint64_t)v15 + 1;
    unsigned int v36 = (int *)(v53 + 4 * v15);
    int v13 = v29;
    do
    {
      uint64_t v38 = *v36++;
      uint64_t v37 = v38;
      if (*(_WORD *)(v14 + 2 * v38))
      {
        if (v13 <= 0)
        {
          if (!jpeg_fill_bit_buffer(&v57, v12, v13, 1)) {
            goto LABEL_75;
          }
          uint64_t v12 = v59;
          int v13 = v60;
        }
        if (((unint64_t)v12 >> --v13))
        {
          int v39 = *(__int16 *)(v14 + 2 * v37);
          if ((v8 & v39) == 0)
          {
            __int16 v40 = v56;
            if (v39 < 0) {
              __int16 v40 = v55;
            }
            *(_WORD *)(v14 + 2 * v37) = v39 + v40;
          }
        }
      }
      else
      {
        BOOL v41 = __OFSUB__(v31--, 1);
        if (v31 < 0 != v41) {
          goto LABEL_64;
        }
      }
      ++v15;
      --v35;
    }
    while (v35);
    int v15 = v50;
LABEL_64:
    HIWORD(v7) = v48;
    int v6 = v49;
    uint64_t v26 = v47;
    if (v51)
    {
      uint64_t v42 = *(int *)(v53 + 4 * v15);
      *(_WORD *)(v14 + 2 * v42) = v51;
      *((_DWORD *)v62 + v52++) = v42;
    }
    if (v15++ >= v49) {
      goto LABEL_67;
    }
  }
  int v54 = 1 << v31;
  if (v30 < 0x10)
  {
    int v13 = v29;
    goto LABEL_7;
  }
  if (v29 >= v31)
  {
LABEL_73:
    int v13 = v29 - v31;
    if (!((bmask[v31] & (v12 >> (v29 - v31))) + v54))
    {
LABEL_67:
      int v23 = 0;
      goto LABEL_22;
    }
    v54 += bmask[v31] & (v12 >> (v29 - v31));
LABEL_7:
    if (v15 <= v6) {
      int v16 = v6;
    }
    else {
      int v16 = v15;
    }
    uint64_t v17 = (int *)(v53 + 4 * v15);
    int v18 = v16 - v15 + 1;
    do
    {
      uint64_t v20 = *v17++;
      uint64_t v19 = v20;
      if (*(_WORD *)(v14 + 2 * v20))
      {
        if (v13 <= 0)
        {
          if (!jpeg_fill_bit_buffer(&v57, v12, v13, 1)) {
            goto LABEL_75;
          }
          uint64_t v12 = v59;
          int v13 = v60;
        }
        if (((unint64_t)v12 >> --v13))
        {
          int v21 = *(__int16 *)(v14 + 2 * v19);
          if ((v8 & v21) == 0)
          {
            __int16 v22 = v56;
            if (v21 < 0) {
              __int16 v22 = -HIWORD(v7);
            }
            *(_WORD *)(v14 + 2 * v19) = v21 + v22;
          }
        }
      }
      --v18;
    }
    while (v18);
    int v23 = v54 - 1;
LABEL_22:
    int v24 = *(void **)(a1 + 40);
    uint64_t v25 = v58;
    *int v24 = v57;
    v24[1] = v25;
    *(void *)(v4 + 24) = v12;
    *(_DWORD *)(v4 + 32) = v13;
    *(_DWORD *)(v4 + 40) = v23;
LABEL_23:
    if (*(_DWORD *)(a1 + 372)) {
      --*(_DWORD *)(v4 + 64);
    }
    return 1;
  }
  if (jpeg_fill_bit_buffer(&v57, v12, v29, v31))
  {
    uint64_t v12 = v59;
    int v29 = v60;
    goto LABEL_73;
  }
LABEL_75:
  if (v52)
  {
    uint64_t v44 = v52 - 1;
    do
      *(_WORD *)(v14 + 2 * *((int *)v62 + v44)) = 0;
    while (v44--);
  }
  return 0;
}

void jpeg_make_d_derived_tbl(uint64_t a1, int a2, unsigned int a3, void *a4)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  memset(v44, 0, 257);
  if (a3 >= 4)
  {
    int v8 = *(void (***)(uint64_t))a1;
    *((_DWORD *)v8 + 10) = 52;
    *((_DWORD *)v8 + 12) = a3;
    (**(void (***)(uint64_t))a1)(a1);
  }
  uint64_t v9 = a1 + 8 * (int)a3;
  uint64_t v10 = (uint64_t *)(v9 + 232);
  uint64_t v11 = (uint64_t *)(v9 + 264);
  if (a2) {
    uint64_t v11 = v10;
  }
  uint64_t v12 = *v11;
  if (!*v11) {
    uint64_t v12 = _cg_jpeg_std_huff_table(a1, a2, a3);
  }
  int v42 = a2;
  int v13 = (void *)*a4;
  if (!*a4)
  {
    int v13 = (void *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1568);
    *a4 = v13;
  }
  int v14 = 0;
  v13[35] = v12;
  for (uint64_t i = 1; i != 17; ++i)
  {
    size_t v16 = *(unsigned __int8 *)(v12 + i);
    if (v14 + (int)v16 >= 257)
    {
      uint64_t v17 = *(void (***)(uint64_t))a1;
      *((_DWORD *)v17 + 10) = 9;
      (*v17)(a1);
    }
    if (v16)
    {
      memset(&v44[v14], i, v16);
      v14 += v16;
    }
  }
  bzero(v43, 0x404uLL);
  v44[v14] = 0;
  int v18 = v44[0];
  if (v44[0])
  {
    unsigned int v19 = 0;
    int v20 = 0;
    char v21 = v44[0];
    do
    {
      if (v18 == v21)
      {
        __int16 v22 = &v43[v20];
        int v23 = &v44[v20 + 1];
        do
        {
          *v22++ = v19++;
          int v24 = *v23++;
          ++v20;
        }
        while (v18 == v24);
      }
      if (1 << v18 <= v19)
      {
        uint64_t v25 = *(void (***)(uint64_t))a1;
        *((_DWORD *)v25 + 10) = 9;
        (*v25)(a1);
      }
      v19 *= 2;
      ++v18;
      char v21 = v44[v20];
    }
    while (v21);
  }
  uint64_t v26 = 0;
  LODWORD(v27) = 0;
  uint64_t v28 = v12 + 1;
  int v29 = v42;
  do
  {
    if (*(unsigned char *)(v28 + v26))
    {
      v13[v26 + 19] = (int)v27 - (unint64_t)v43[(int)v27];
      uint64_t v27 = *(unsigned __int8 *)(v28 + v26) + (uint64_t)(int)v27;
      uint64_t v30 = v43[v27 - 1];
    }
    else
    {
      uint64_t v30 = -1;
    }
    v13[++v26] = v30;
  }
  while (v26 != 16);
  v13[17] = 0xFFFFFLL;
  bzero(v13 + 36, 0x400uLL);
  LODWORD(v31) = 0;
  uint64_t v32 = v13 + 164;
  for (uint64_t j = 1; j != 9; ++j)
  {
    if (*(unsigned char *)(v12 + j))
    {
      unsigned int v34 = 1;
      uint64_t v31 = (int)v31;
      do
      {
        uint64_t v35 = (int)(v43[v31] << (8 - j));
        int v36 = (1 << (8 - j)) + 1;
        do
        {
          *((_DWORD *)v32 + v35 - 256) = j;
          *((unsigned char *)v32 + v35++) = *(unsigned char *)(v12 + v31 + 17);
          --v36;
        }
        while (v36 > 1);
        ++v31;
      }
      while (v34++ < *(unsigned __int8 *)(v12 + j));
    }
  }
  if (v29 && v14 >= 1)
  {
    uint64_t v38 = v14;
    int v39 = (unsigned __int8 *)(v12 + 17);
    do
    {
      unsigned int v40 = *v39++;
      if (v40 >= 0x10)
      {
        BOOL v41 = *(void (***)(uint64_t))a1;
        *((_DWORD *)v41 + 10) = 9;
        (*v41)(a1);
      }
      --v38;
    }
    while (v38);
  }
}

uint64_t decode_mcu_sub(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    if (!*(_DWORD *)(v4 + 64))
    {
      uint64_t result = process_restart(a1);
      if (!result) {
        return result;
      }
    }
  }
  if (!*(_DWORD *)(v4 + 60))
  {
    uint64_t v44 = *(void *)(a1 + 560);
    int v6 = *(_DWORD *)(a1 + 568);
    uint64_t v51 = a1;
    int v7 = *(unsigned __int8 ***)(a1 + 40);
    int v8 = *v7;
    uint64_t v9 = v7[1];
    uint64_t v47 = *v7;
    __int16 v48 = v9;
    uint64_t v10 = *(void *)(v4 + 24);
    int v11 = *(_DWORD *)(v4 + 32);
    long long v45 = *(_OWORD *)(v4 + 40);
    int v46 = *(_DWORD *)(v4 + 56);
    if (*(int *)(a1 + 496) < 1)
    {
LABEL_76:
      unsigned __int8 *v7 = v8;
      v7[1] = v9;
      *(void *)(v4 + 24) = v10;
      *(_DWORD *)(v4 + 32) = v11;
      *(_OWORD *)(v4 + 40) = v45;
      *(_DWORD *)(v4 + 56) = v46;
      goto LABEL_5;
    }
    uint64_t v12 = 0;
    uint64_t v49 = 0;
    uint64_t v50 = 0;
    uint64_t v43 = a2;
LABEL_11:
    int v13 = *(_WORD **)(a2 + 8 * v12);
    uint64_t v14 = *(void *)(v4 + 8 * v12 + 176);
    if (v11 > 7) {
      goto LABEL_15;
    }
    uint64_t result = jpeg_fill_bit_buffer(&v47, v10, v11, 0);
    if (!result) {
      return result;
    }
    uint64_t v10 = v49;
    int v11 = v50;
    if ((int)v50 >= 8)
    {
LABEL_15:
      uint64_t v16 = v10 >> (v11 - 8);
      int v17 = *(_DWORD *)(v14 + 4 * v16 + 288);
      if (v17)
      {
        v11 -= v17;
        int v18 = *(unsigned __int8 *)(v14 + v16 + 1312);
        goto LABEL_20;
      }
      int v15 = 9;
    }
    else
    {
      int v15 = 1;
    }
    int v19 = jpeg_huff_decode((uint64_t)&v47, v10, v11, v14, v15);
    if (v19 < 0) {
      return 0;
    }
    int v18 = v19;
    uint64_t v10 = v49;
    int v11 = v50;
LABEL_20:
    uint64_t v20 = *(void *)(v4 + 8 * v12 + 256);
    int v21 = *(_DWORD *)(v4 + 4 * v12 + 336);
    if (v21)
    {
      if (v18)
      {
        if (v11 < v18)
        {
          uint64_t result = jpeg_fill_bit_buffer(&v47, v10, v11, v18);
          if (!result) {
            return result;
          }
          uint64_t v10 = v49;
          int v11 = v50;
        }
        v11 -= v18;
        int v22 = bmask[v18];
        int v23 = v22 & (v10 >> v11);
        if (v23 > bmask[v18 - 1]) {
          int v22 = 0;
        }
        int v24 = v23 - v22;
      }
      else
      {
        int v24 = 0;
      }
      uint64_t v25 = (char *)&v45 + 4 * *(int *)(a1 + 4 * v12 + 500);
      int v26 = *((_DWORD *)v25 + 1) + v24;
      *((_DWORD *)v25 + 1) = v26;
      _WORD *v13 = v26;
      if (v21 >= 2)
      {
        int v27 = 1;
        while (1)
        {
          if (v11 > 7) {
            goto LABEL_40;
          }
          uint64_t result = jpeg_fill_bit_buffer(&v47, v10, v11, 0);
          if (!result) {
            return result;
          }
          uint64_t v10 = v49;
          int v11 = v50;
          if ((int)v50 >= 8)
          {
LABEL_40:
            uint64_t v29 = v10 >> (v11 - 8);
            int v30 = *(_DWORD *)(v20 + 4 * v29 + 288);
            if (v30)
            {
              v11 -= v30;
              unsigned int v31 = *(unsigned __int8 *)(v20 + v29 + 1312);
              goto LABEL_45;
            }
            int v28 = 9;
          }
          else
          {
            int v28 = 1;
          }
          unsigned int v31 = jpeg_huff_decode((uint64_t)&v47, v10, v11, v20, v28);
          if ((v31 & 0x80000000) != 0) {
            return 0;
          }
          uint64_t v10 = v49;
          int v11 = v50;
LABEL_45:
          unsigned int v32 = v31 >> 4;
          int v33 = v31 & 0xF;
          if ((v31 & 0xF) != 0)
          {
            if (v11 < v33)
            {
              uint64_t result = jpeg_fill_bit_buffer(&v47, v10, v11, v33);
              if (!result) {
                return result;
              }
              uint64_t v10 = v49;
              int v11 = v50;
            }
            int v34 = v32 + v27;
            v11 -= v33;
            int v35 = bmask[v33];
            int v36 = v35 & (v10 >> v11);
            if (v36 > bmask[v33 - 1]) {
              LOWORD(v35) = 0;
            }
            v13[*(int *)(v44 + 4 * v34)] = v36 - v35;
          }
          else
          {
            if (v32 != 15)
            {
LABEL_74:
              ++v12;
              a2 = v43;
              if (v12 >= *(int *)(a1 + 496))
              {
                int v7 = *(unsigned __int8 ***)(a1 + 40);
                int v8 = v47;
                uint64_t v9 = v48;
                goto LABEL_76;
              }
              goto LABEL_11;
            }
            int v34 = v27 + 15;
          }
          int v27 = v34 + 1;
          if (v34 + 1 >= v21)
          {
            while (1)
            {
LABEL_57:
              if (v27 > v6) {
                goto LABEL_74;
              }
              if (v11 > 7) {
                goto LABEL_62;
              }
              uint64_t result = jpeg_fill_bit_buffer(&v47, v10, v11, 0);
              if (!result) {
                return result;
              }
              uint64_t v10 = v49;
              int v11 = v50;
              if ((int)v50 >= 8)
              {
LABEL_62:
                uint64_t v38 = v10 >> (v11 - 8);
                int v39 = *(_DWORD *)(v20 + 4 * v38 + 288);
                if (v39)
                {
                  v11 -= v39;
                  unsigned int v40 = *(unsigned __int8 *)(v20 + v38 + 1312);
                  goto LABEL_67;
                }
                int v37 = 9;
              }
              else
              {
                int v37 = 1;
              }
              unsigned int v40 = jpeg_huff_decode((uint64_t)&v47, v10, v11, v20, v37);
              if ((v40 & 0x80000000) != 0) {
                return 0;
              }
              uint64_t v10 = v49;
              int v11 = v50;
LABEL_67:
              unsigned int v41 = v40 >> 4;
              int v42 = v40 & 0xF;
              if ((v40 & 0xF) != 0)
              {
                if (v11 < v42)
                {
                  uint64_t result = jpeg_fill_bit_buffer(&v47, v10, v11, v42);
                  if (!result) {
                    return result;
                  }
                  uint64_t v10 = v49;
                  int v11 = v50;
                }
                v11 -= v42;
              }
              else if (v41 != 15)
              {
                goto LABEL_74;
              }
              v27 += v41 + 1;
            }
          }
        }
      }
    }
    else if (v18)
    {
      if (v11 < v18)
      {
        uint64_t result = jpeg_fill_bit_buffer(&v47, v10, v11, v18);
        if (!result) {
          return result;
        }
        uint64_t v10 = v49;
        int v11 = v50;
      }
      v11 -= v18;
    }
    int v27 = 1;
    goto LABEL_57;
  }
LABEL_5:
  if (*(_DWORD *)(a1 + 372)) {
    --*(_DWORD *)(v4 + 64);
  }
  return 1;
}

uint64_t decode_mcu(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 624);
  if (*(_DWORD *)(a1 + 372))
  {
    if (!*(_DWORD *)(v4 + 64))
    {
      uint64_t result = process_restart(a1);
      if (!result) {
        return result;
      }
    }
  }
  if (*(_DWORD *)(v4 + 60)) {
    goto LABEL_5;
  }
  uint64_t v48 = a1;
  int v6 = *(unsigned __int8 ***)(a1 + 40);
  int v7 = *v6;
  int v8 = v6[1];
  uint64_t v44 = *v6;
  long long v45 = v8;
  uint64_t v9 = *(void *)(v4 + 24);
  int v10 = *(_DWORD *)(v4 + 32);
  long long v42 = *(_OWORD *)(v4 + 40);
  int v43 = *(_DWORD *)(v4 + 56);
  if (*(int *)(a1 + 496) < 1) {
    goto LABEL_76;
  }
  uint64_t v11 = 0;
  uint64_t v46 = 0;
  uint64_t v47 = 0;
  do
  {
    uint64_t v12 = *(_WORD **)(a2 + 8 * v11);
    uint64_t v13 = *(void *)(v4 + 8 * v11 + 176);
    if (v10 > 7) {
      goto LABEL_15;
    }
    uint64_t result = jpeg_fill_bit_buffer(&v44, v9, v10, 0);
    if (!result) {
      return result;
    }
    uint64_t v9 = v46;
    int v10 = v47;
    if ((int)v47 >= 8)
    {
LABEL_15:
      uint64_t v15 = v9 >> (v10 - 8);
      int v16 = *(_DWORD *)(v13 + 4 * v15 + 288);
      if (v16)
      {
        v10 -= v16;
        int v17 = *(unsigned __int8 *)(v13 + v15 + 1312);
        goto LABEL_20;
      }
      int v14 = 9;
    }
    else
    {
      int v14 = 1;
    }
    int v18 = jpeg_huff_decode((uint64_t)&v44, v9, v10, v13, v14);
    if (v18 < 0) {
      return 0;
    }
    int v17 = v18;
    uint64_t v9 = v46;
    int v10 = v47;
LABEL_20:
    uint64_t v19 = *(void *)(v4 + 8 * v11 + 256);
    int v20 = *(_DWORD *)(v4 + 4 * v11 + 336);
    if (!v20)
    {
      if (v17)
      {
        if (v10 < v17)
        {
          uint64_t result = jpeg_fill_bit_buffer(&v44, v9, v10, v17);
          if (!result) {
            return result;
          }
          uint64_t v9 = v46;
          int v10 = v47;
        }
        v10 -= v17;
      }
LABEL_57:
      int v26 = 1;
      while (1)
      {
LABEL_58:
        if (v10 > 7) {
          goto LABEL_62;
        }
        uint64_t result = jpeg_fill_bit_buffer(&v44, v9, v10, 0);
        if (!result) {
          return result;
        }
        uint64_t v9 = v46;
        int v10 = v47;
        if ((int)v47 >= 8)
        {
LABEL_62:
          uint64_t v37 = v9 >> (v10 - 8);
          int v38 = *(_DWORD *)(v19 + 4 * v37 + 288);
          if (v38)
          {
            v10 -= v38;
            unsigned int v39 = *(unsigned __int8 *)(v19 + v37 + 1312);
            goto LABEL_67;
          }
          int v36 = 9;
        }
        else
        {
          int v36 = 1;
        }
        unsigned int v39 = jpeg_huff_decode((uint64_t)&v44, v9, v10, v19, v36);
        if ((v39 & 0x80000000) != 0) {
          return 0;
        }
        uint64_t v9 = v46;
        int v10 = v47;
LABEL_67:
        unsigned int v40 = v39 >> 4;
        int v41 = v39 & 0xF;
        if ((v39 & 0xF) != 0)
        {
          if (v10 < v41)
          {
            uint64_t result = jpeg_fill_bit_buffer(&v44, v9, v10, v41);
            if (!result) {
              return result;
            }
            uint64_t v9 = v46;
            int v10 = v47;
          }
          v10 -= v41;
        }
        else if (v40 != 15)
        {
          goto LABEL_74;
        }
        v26 += v40 + 1;
        if (v26 >= 64) {
          goto LABEL_74;
        }
      }
    }
    if (v17)
    {
      if (v10 < v17)
      {
        uint64_t result = jpeg_fill_bit_buffer(&v44, v9, v10, v17);
        if (!result) {
          return result;
        }
        uint64_t v9 = v46;
        int v10 = v47;
      }
      v10 -= v17;
      int v21 = bmask[v17];
      int v22 = v21 & (v9 >> v10);
      if (v22 > bmask[v17 - 1]) {
        int v21 = 0;
      }
      int v23 = v22 - v21;
    }
    else
    {
      int v23 = 0;
    }
    int v24 = (char *)&v42 + 4 * *(int *)(a1 + 4 * v11 + 500);
    int v25 = *((_DWORD *)v24 + 1) + v23;
    *((_DWORD *)v24 + 1) = v25;
    _WORD *v12 = v25;
    if (v20 < 2) {
      goto LABEL_57;
    }
    int v26 = 1;
    do
    {
      if (v10 > 7) {
        goto LABEL_40;
      }
      uint64_t result = jpeg_fill_bit_buffer(&v44, v9, v10, 0);
      if (!result) {
        return result;
      }
      uint64_t v9 = v46;
      int v10 = v47;
      if ((int)v47 >= 8)
      {
LABEL_40:
        uint64_t v28 = v9 >> (v10 - 8);
        int v29 = *(_DWORD *)(v19 + 4 * v28 + 288);
        if (v29)
        {
          v10 -= v29;
          unsigned int v30 = *(unsigned __int8 *)(v19 + v28 + 1312);
          goto LABEL_45;
        }
        int v27 = 9;
      }
      else
      {
        int v27 = 1;
      }
      unsigned int v30 = jpeg_huff_decode((uint64_t)&v44, v9, v10, v19, v27);
      if ((v30 & 0x80000000) != 0) {
        return 0;
      }
      uint64_t v9 = v46;
      int v10 = v47;
LABEL_45:
      unsigned int v31 = v30 >> 4;
      int v32 = v30 & 0xF;
      if ((v30 & 0xF) != 0)
      {
        if (v10 < v32)
        {
          uint64_t result = jpeg_fill_bit_buffer(&v44, v9, v10, v32);
          if (!result) {
            return result;
          }
          uint64_t v9 = v46;
          int v10 = v47;
        }
        int v33 = v31 + v26;
        v10 -= v32;
        int v34 = bmask[v32];
        int v35 = v34 & (v9 >> v10);
        if (v35 > bmask[v32 - 1]) {
          LOWORD(v34) = 0;
        }
        v12[_cg_jpeg_natural_order[v33]] = v35 - v34;
      }
      else
      {
        if (v31 != 15) {
          goto LABEL_74;
        }
        int v33 = v26 + 15;
      }
      int v26 = v33 + 1;
    }
    while (v33 + 1 < v20);
    if (v33 <= 62) {
      goto LABEL_58;
    }
LABEL_74:
    ++v11;
  }
  while (v11 < *(int *)(a1 + 496));
  int v6 = *(unsigned __int8 ***)(a1 + 40);
  int v7 = v44;
  int v8 = v45;
LABEL_76:
  *int v6 = v7;
  v6[1] = v8;
  *(void *)(v4 + 24) = v9;
  *(_DWORD *)(v4 + 32) = v10;
  *(_OWORD *)(v4 + 40) = v42;
  *(_DWORD *)(v4 + 56) = v43;
LABEL_5:
  if (*(_DWORD *)(a1 + 372)) {
    --*(_DWORD *)(v4 + 64);
  }
  return 1;
}

uint64_t process_restart(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 624);
  uint64_t v3 = *(void *)(a1 + 616);
  *(_DWORD *)(v3 + 36) += v2[8] / 8;
  v2[8] = 0;
  uint64_t result = (*(uint64_t (**)(void))(v3 + 16))();
  if (result)
  {
    if (*(int *)(a1 + 448) >= 1)
    {
      uint64_t v5 = 0;
      do
        v2[v5++ + 11] = 0;
      while (v5 < *(int *)(a1 + 448));
    }
    v2[10] = 0;
    v2[16] = *(_DWORD *)(a1 + 372);
    if (!*(_DWORD *)(a1 + 572)) {
      v2[15] = 0;
    }
    return 1;
  }
  return result;
}

uint64_t jpeg_fill_bit_buffer(unsigned __int8 **a1, uint64_t a2, int a3, int a4)
{
  int v5 = a3;
  int v8 = *a1;
  uint64_t v9 = a1[1];
  int v10 = a1[4];
  if (*((_DWORD *)v10 + 143))
  {
LABEL_2:
    if (v5 < a4)
    {
      if (!*(_DWORD *)(*((void *)v10 + 78) + 60))
      {
        uint64_t v11 = *(void *)v10;
        *(_DWORD *)(v11 + 40) = 120;
        (*(void (**)(unsigned __int8 *, uint64_t))(v11 + 8))(v10, 0xFFFFFFFFLL);
        *(_DWORD *)(*((void *)v10 + 78) + 60) = 1;
      }
      int v12 = 25;
      a2 <<= 25 - v5;
      goto LABEL_20;
    }
  }
  else if (a3 <= 24)
  {
    while (1)
    {
      if (!v9)
      {
        uint64_t result = (*(uint64_t (**)(unsigned __int8 *))(*((void *)v10 + 5) + 24))(v10);
        if (!result) {
          return result;
        }
        int v14 = (unsigned __int8 **)*((void *)v10 + 5);
        int v8 = *v14;
        uint64_t v9 = v14[1];
      }
      --v9;
      unsigned int v16 = *v8++;
      uint64_t v15 = v16;
      if (v16 == 255)
      {
        do
        {
          if (!v9)
          {
            uint64_t result = (*(uint64_t (**)(unsigned __int8 *))(*((void *)v10 + 5) + 24))(v10);
            if (!result) {
              return result;
            }
            int v17 = (unsigned __int8 **)*((void *)v10 + 5);
            int v8 = *v17;
            uint64_t v9 = v17[1];
          }
          --v9;
          int v19 = *v8++;
          int v18 = v19;
        }
        while (v19 == 255);
        if (v18)
        {
          *((_DWORD *)v10 + 143) = v18;
          goto LABEL_2;
        }
        uint64_t v15 = 255;
      }
      a2 = v15 | (a2 << 8);
      int v12 = v5 + 8;
      BOOL v20 = v5 < 17;
      v5 += 8;
      if (!v20) {
        goto LABEL_20;
      }
    }
  }
  int v12 = v5;
LABEL_20:
  *a1 = v8;
  a1[1] = v9;
  a1[2] = (unsigned __int8 *)a2;
  uint64_t result = 1;
  *((_DWORD *)a1 + 6) = v12;
  return result;
}

uint64_t jpeg_huff_decode(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  int v5 = a5;
  if (a3 < a5)
  {
    if (!jpeg_fill_bit_buffer((unsigned __int8 **)a1, a2, a3, a5)) {
      return 0xFFFFFFFFLL;
    }
    a2 = *(void *)(a1 + 16);
    a3 = *(_DWORD *)(a1 + 24);
  }
  int v8 = a3 - v5;
  uint64_t v9 = (int)(bmask[v5] & (a2 >> v8));
  uint64_t v10 = v5;
  if (*(void *)(a4 + 8 * v5) >= v9)
  {
    uint64_t v11 = v5;
  }
  else
  {
    do
    {
      if (v8 <= 0)
      {
        if (!jpeg_fill_bit_buffer((unsigned __int8 **)a1, a2, v8, 1)) {
          return 0xFFFFFFFFLL;
        }
        a2 = *(void *)(a1 + 16);
        int v8 = *(_DWORD *)(a1 + 24);
      }
      uint64_t v9 = ((unint64_t)a2 >> --v8) & 1 | (2 * v9);
      uint64_t v11 = v10 + 1;
      uint64_t v12 = *(void *)(a4 + 8 + 8 * v10++);
    }
    while (v9 > v12);
    int v5 = v11;
  }
  *(void *)(a1 + 16) = a2;
  *(_DWORD *)(a1 + 24) = v8;
  if (v5 < 17) {
    return *(unsigned __int8 *)(*(void *)(a4 + 280) + *(_DWORD *)(a4 + 8 * v11 + 144) + (int)v9 + 17);
  }
  uint64_t v13 = *(uint64_t **)(a1 + 32);
  uint64_t v14 = *v13;
  *(_DWORD *)(v14 + 40) = 121;
  (*(void (**)(uint64_t *, uint64_t))(v14 + 8))(v13, 0xFFFFFFFFLL);
  return 0;
}

uint64_t (**_cg_jinit_c_coef_controller(uint64_t a1, int a2))(uint64_t *a1, int a2)
{
  uint64_t result = (uint64_t (**)(uint64_t *, int))(**(uint64_t (***)(void))(a1 + 8))();
  int v5 = result;
  *(void *)(a1 + 520) = result;
  *uint64_t result = start_pass_coef;
  if (a2)
  {
    if (*(int *)(a1 + 92) >= 1)
    {
      uint64_t v6 = 0;
      int v7 = result + 14;
      int v8 = (unsigned int *)(*(void *)(a1 + 104) + 28);
      do
      {
        uint64_t v9 = *(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, void))(*(void *)(a1 + 8) + 40);
        uint64_t v10 = _cg_jround_up(*v8, (int)*(v8 - 5));
        uint64_t v11 = _cg_jround_up(v8[1], (int)*(v8 - 4));
        uint64_t result = (uint64_t (**)(uint64_t *, int))v9(a1, 1, 0, v10, v11, *(v8 - 4));
        v7[v6++] = result;
        v8 += 24;
      }
      while (v6 < *(int *)(a1 + 92));
    }
  }
  else
  {
    uint64_t result = (uint64_t (**)(uint64_t *, int))(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 8) + 8))(a1, 1, 1280);
    int64x2_t v12 = (int64x2_t)xmmword_18898C840;
    uint64_t v13 = 4;
    int64x2_t v14 = vdupq_n_s64((unint64_t)result);
    int64x2_t v15 = vdupq_n_s64(2uLL);
    do
    {
      *(int64x2_t *)&v5[v13] = vaddq_s64(v14, vshlq_n_s64(v12, 7uLL));
      int64x2_t v12 = vaddq_s64(v12, v15);
      v13 += 2;
    }
    while (v13 != 14);
    v5[14] = 0;
  }
  return result;
}

uint64_t start_pass_coef(uint64_t *a1, int a2)
{
  uint64_t v4 = a1[65];
  *(_DWORD *)(v4 + 16) = 0;
  uint64_t result = start_iMCU_row_0((uint64_t)a1);
  switch(a2)
  {
    case 3:
      if (!*(void *)(v4 + 112))
      {
        uint64_t v8 = *a1;
        *(_DWORD *)(v8 + 40) = 3;
        uint64_t result = (*(uint64_t (**)(uint64_t *))v8)(a1);
      }
      int v7 = compress_first_pass;
      goto LABEL_13;
    case 2:
      if (!*(void *)(v4 + 112))
      {
        uint64_t v9 = *a1;
        *(_DWORD *)(v9 + 40) = 3;
        uint64_t result = (*(uint64_t (**)(uint64_t *))v9)(a1);
      }
      int v7 = compress_output;
      goto LABEL_13;
    case 0:
      if (*(void *)(v4 + 112))
      {
        uint64_t v6 = *a1;
        *(_DWORD *)(v6 + 40) = 3;
        uint64_t result = (*(uint64_t (**)(uint64_t *))v6)(a1);
      }
      int v7 = compress_data;
LABEL_13:
      *(void *)(v4 + 8) = v7;
      return result;
  }
  uint64_t v10 = *a1;
  *(_DWORD *)(v10 + 40) = 3;
  uint64_t v11 = *(uint64_t (**)(uint64_t *))v10;

  return v11(a1);
}

uint64_t start_iMCU_row_0(uint64_t result)
{
  uint64_t v1 = *(_DWORD **)(result + 520);
  if (*(int *)(result + 372) < 2)
  {
    uint64_t v3 = *(void *)(result + 376);
    if (v1[4] >= (*(_DWORD *)(result + 368) - 1)) {
      int v2 = *(_DWORD *)(v3 + 76);
    }
    else {
      int v2 = *(_DWORD *)(v3 + 12);
    }
  }
  else
  {
    int v2 = 1;
  }
  v1[6] = 0;
  v1[7] = v2;
  v1[5] = 0;
  return result;
}

uint64_t compress_data(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(_DWORD **)(a1 + 520);
  int v4 = v3[7];
  int v29 = v3[6];
  if (v29 >= v4)
  {
LABEL_27:
    ++v3[4];
    start_iMCU_row_0(a1);
    return 1;
  }
  else
  {
    unsigned int v26 = *(_DWORD *)(a1 + 408) - 1;
    unsigned int v5 = *(_DWORD *)(a1 + 368) - 1;
    uint64_t v28 = v3 + 8;
    unsigned int v6 = v3[5];
    while (v6 > v26)
    {
LABEL_26:
      unsigned int v6 = 0;
      v3[5] = 0;
      if (++v29 >= v4) {
        goto LABEL_27;
      }
    }
    while (1)
    {
      int v7 = *(_DWORD *)(a1 + 372);
      if (v7 >= 1)
      {
        uint64_t v8 = 0;
        int v9 = 0;
        unsigned int v25 = v6;
        do
        {
          uint64_t v10 = *(int **)(a1 + 8 * v8 + 376);
          uint64_t v11 = 18;
          if (v6 < v26) {
            uint64_t v11 = 14;
          }
          if (v10[15] >= 1)
          {
            int v12 = 0;
            uint64_t v13 = v10[v11];
            int64x2_t v14 = *(void (**)(uint64_t, int *, void, void, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 552) + 8 * v10[1] + 8);
            uint64_t v15 = v10[17] * v6;
            uint64_t v16 = (v10[10] * v29);
            uint64_t v27 = v8;
            do
            {
              if (v3[4] >= v5 && v12 + v29 >= v10[19])
              {
                bzero(*(void **)&v3[2 * v9 + 8], (uint64_t)v10[14] << 7);
                int v17 = v10[14];
                if (v17 >= 1)
                {
                  BOOL v20 = *(_WORD **)&v3[2 * v9 + 6];
                  int v21 = (_WORD **)&v28[2 * v9];
                  uint64_t v22 = v10[14];
                  do
                  {
                    int v23 = *v21++;
                    _WORD *v23 = *v20;
                    --v22;
                  }
                  while (v22);
                }
              }
              else
              {
                v14(a1, v10, *(void *)(a2 + 8 * v10[1]), *(void *)&v3[2 * v9 + 8], v16, v15, v13);
                int v17 = v10[14];
                if (v17 > (int)v13)
                {
                  bzero(*(void **)&v3[2 * v9 + 8 + 2 * (int)v13], (uint64_t)(v17 - (int)v13) << 7);
                  int v17 = v10[14];
                  if ((int)v13 < v17)
                  {
                    int v18 = (_WORD **)&v28[2 * v13 + 2 * v9];
                    uint64_t v19 = v17 - v13;
                    do
                    {
                      **int v18 = **(v18 - 1);
                      ++v18;
                      --v19;
                    }
                    while (v19);
                  }
                }
              }
              v9 += v17;
              uint64_t v16 = (v10[10] + v16);
              ++v12;
            }
            while (v12 < v10[15]);
            int v7 = *(_DWORD *)(a1 + 372);
            unsigned int v6 = v25;
            uint64_t v8 = v27;
          }
          ++v8;
        }
        while (v8 < v7);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, _DWORD *))(*(void *)(a1 + 560) + 8))(a1, v28);
      if (!result) {
        break;
      }
      if (++v6 > v26)
      {
        int v4 = v3[7];
        goto LABEL_26;
      }
    }
    v3[5] = v6;
    v3[6] = v29;
  }
  return result;
}

uint64_t compress_first_pass(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  if (*(int *)(a1 + 92) >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v28 = *(void *)(a1 + 520);
    unsigned int v29 = *(_DWORD *)(a1 + 368) - 1;
    int v4 = *(_DWORD **)(a1 + 104);
    do
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t, void, void, void, uint64_t))(*(void *)(v2 + 8) + 64))(v2, *(void *)(v28 + 8 * v3 + 112), (v4[3] * *(_DWORD *)(v28 + 16)), v4[3], 1);
      unsigned int v6 = *(_DWORD *)(v28 + 16);
      if (v6 >= v29)
      {
        unsigned int v8 = v4[3];
        if (v4[8] % v8) {
          int v7 = v4[8] % v8;
        }
        else {
          int v7 = v4[3];
        }
      }
      else
      {
        int v7 = v4[3];
      }
      uint64_t v9 = v4[7];
      uint64_t v10 = (int)v4[2];
      if ((int)(v9 % v10) <= 0) {
        uint64_t v11 = v9 % v10;
      }
      else {
        uint64_t v11 = v10 - v9 % v10;
      }
      uint64_t v35 = v3;
      if (v7 >= 1)
      {
        uint64_t v12 = 0;
        uint64_t v13 = *(void (**)(uint64_t, _DWORD *, void, uint64_t, void, void, uint64_t))(*(void *)(v2 + 552)
                                                                                                 + 8 * v3
                                                                                                 + 8);
        int v31 = v7;
        uint64_t v14 = v7;
        do
        {
          uint64_t v15 = *(void *)(v5 + 8 * v12);
          v13(a1, v4, *(void *)(a2 + 8 * v3), v15, (v4[10] * v12), 0, v9);
          if ((int)v11 >= 1)
          {
            uint64_t v16 = (_WORD *)(v15 + (v9 << 7));
            bzero(v16, (unint64_t)v11 << 7);
            __int16 v17 = *(v16 - 64);
            uint64_t v18 = v11;
            do
            {
              _WORD *v16 = v17;
              v16 += 64;
              --v18;
            }
            while (v18);
          }
          ++v12;
        }
        while (v12 != v14);
        unsigned int v6 = *(_DWORD *)(v28 + 16);
        int v7 = v31;
      }
      if (v6 == v29 && v7 < v4[3])
      {
        unsigned int v32 = v11 + v9;
        unint64_t v30 = (unint64_t)(v11 + v9) << 7;
        uint64_t v19 = v7;
        if (((int)v11 + (int)v9) / v10 <= 1) {
          unsigned int v20 = 1;
        }
        else {
          unsigned int v20 = ((int)v11 + (int)v9) / v10;
        }
        do
        {
          int v21 = (void **)(v5 + 8 * v19);
          uint64_t v23 = (uint64_t)*(v21 - 1);
          uint64_t v22 = (char *)*v21;
          bzero(*v21, v30);
          if (v10 <= v32)
          {
            int v24 = 0;
            do
            {
              if ((int)v10 >= 1)
              {
                uint64_t v25 = 0;
                __int16 v26 = *(_WORD *)(v23 + ((v10 - 1) << 7));
                do
                {
                  *(_WORD *)&v22[v25] = v26;
                  v25 += 128;
                }
                while ((unint64_t)v10 << 7 != v25);
              }
              v23 += v10 << 7;
              ++v24;
              v22 += 128 * v10;
            }
            while (v24 != v20);
          }
          ++v19;
        }
        while (v19 < (int)v4[3]);
      }
      uint64_t v2 = a1;
      uint64_t v3 = v35 + 1;
      v4 += 24;
    }
    while (v35 + 1 < *(int *)(a1 + 92));
  }

  return compress_output(v2);
}

uint64_t compress_output(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(_DWORD **)(a1 + 520);
  memset(v20, 0, sizeof(v20));
  if (*(int *)(a1 + 372) >= 1)
  {
    uint64_t v3 = 0;
    do
    {
      *((void *)v20 + v3) = (*(uint64_t (**)(uint64_t, void, void, void, void))(*(void *)(a1 + 8)
                                                                                                 + 64))(a1, *(void *)&v2[2 * *(int *)(*(void *)(a1 + 8 * v3 + 376) + 4) + 28], (*(_DWORD *)(*(void *)(a1 + 8 * v3 + 376) + 12) * v2[4]), *(unsigned int *)(*(void *)(a1 + 8 * v3 + 376) + 12), 0);
      ++v3;
    }
    while (v3 < *(int *)(a1 + 372));
  }
  int v4 = v2[7];
  uint64_t v5 = (int)v2[6];
  if ((int)v5 >= v4)
  {
LABEL_20:
    ++v2[4];
    start_iMCU_row_0(a1);
    return 1;
  }
  else
  {
    unsigned int v6 = v2[5];
    unsigned int v7 = *(_DWORD *)(a1 + 408);
    while (v6 >= v7)
    {
LABEL_19:
      unsigned int v6 = 0;
      v2[5] = 0;
      if (++v5 >= v4) {
        goto LABEL_20;
      }
    }
    while (1)
    {
      uint64_t v8 = *(unsigned int *)(a1 + 372);
      if ((int)v8 >= 1)
      {
        uint64_t v9 = 0;
        int v10 = 0;
        do
        {
          uint64_t v11 = *(void *)(a1 + 8 * v9 + 376);
          uint64_t v12 = *(unsigned int *)(v11 + 60);
          if ((int)v12 >= 1)
          {
            uint64_t v13 = 0;
            int v14 = *(_DWORD *)(v11 + 56);
            uint64_t v15 = *((void *)v20 + v9);
            do
            {
              if (v14 >= 1)
              {
                unint64_t v16 = *(void *)(v15 + 8 * (v13 + v5)) + ((unint64_t)(v14 * v6) << 7);
                __int16 v17 = (unint64_t *)&v2[2 * v10 + 8];
                v10 += v14;
                int v18 = v14;
                do
                {
                  *v17++ = v16;
                  v16 += 128;
                  --v18;
                }
                while (v18);
              }
              ++v13;
            }
            while (v13 != v12);
          }
          ++v9;
        }
        while (v9 != v8);
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, _DWORD *))(*(void *)(a1 + 560) + 8))(a1, v2 + 8);
      if (!result) {
        break;
      }
      ++v6;
      unsigned int v7 = *(_DWORD *)(a1 + 408);
      if (v6 >= v7)
      {
        int v4 = v2[7];
        goto LABEL_19;
      }
    }
    v2[5] = v6;
    v2[6] = v5;
  }
  return result;
}

uint64_t _cg_jinit_merged_upsampler(uint64_t a1)
{
  uint64_t v2 = (**(uint64_t (***)(void))(a1 + 8))();
  uint64_t v3 = (void *)v2;
  *(void *)(a1 + 640) = v2;
  *(void *)uint64_t v2 = start_pass_merged_upsample;
  *(_DWORD *)(v2 + 16) = 0;
  *(_DWORD *)(v2 + 76) = *(_DWORD *)(a1 + 144) * *(_DWORD *)(a1 + 136);
  if (*(_DWORD *)(a1 + 420) == 2)
  {
    *(void *)(v2 + 8) = merged_2v_upsample;
    *(void *)(v2 + 24) = h2v2_merged_upsample;
    uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 8) + 8))(a1, 1);
  }
  else
  {
    uint64_t v4 = 0;
    v3[1] = merged_1v_upsample;
    v3[3] = h2v1_merged_upsample;
  }
  v3[8] = v4;
  int v5 = *(_DWORD *)(a1 + 60);
  unsigned int v6 = *(void **)(a1 + 640);
  v6[4] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1024);
  v6[5] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 1024);
  v6[6] = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2048);
  uint64_t result = (**(uint64_t (***)(uint64_t, uint64_t, uint64_t))(a1 + 8))(a1, 1, 2048);
  v6[7] = result;
  uint64_t v8 = v6[4];
  uint64_t v9 = v6[5];
  uint64_t v10 = v6[6];
  if (v5 == 7)
  {
    uint64_t v11 = 0;
    unint64_t v12 = -29696512;
    unint64_t v13 = -23488896;
    uint64_t v14 = 5806464;
    uint64_t v15 = 11981184;
    do
    {
      *(_DWORD *)(v8 + 4 * v11) = v13 >> 16;
      *(_DWORD *)(v9 + 4 * v11) = v12 >> 16;
      *(void *)(v10 + 8 * v11) = v15;
      *(void *)(result + 8 * v11++) = v14;
      v14 -= 45107;
      v15 -= 93603;
      v12 += 232260;
      v13 += 183763;
    }
    while (v11 != 256);
  }
  else
  {
    uint64_t v16 = 0;
    unint64_t v17 = -14831872;
    unint64_t v18 = -11728000;
    uint64_t v19 = 2919552;
    uint64_t v20 = 5990656;
    do
    {
      *(_DWORD *)(v8 + 4 * v16) = v18 >> 16;
      *(_DWORD *)(v9 + 4 * v16) = v17 >> 16;
      *(void *)(v10 + 8 * v16) = v20;
      *(void *)(result + 8 * v16++) = v19;
      v19 -= 22553;
      v20 -= 46802;
      v17 += 116130;
      v18 += 91881;
    }
    while (v16 != 256);
  }
  return result;
}

uint64_t start_pass_merged_upsample(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 640);
  *(_DWORD *)(v1 + 72) = 0;
  *(_DWORD *)(v1 + 80) = *(_DWORD *)(result + 140);
  return result;
}

char *merged_2v_upsample(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, _DWORD *a6, int a7)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = *(void *)(a1 + 640);
  if (*(_DWORD *)(v9 + 72))
  {
    unsigned int v10 = 1;
    uint64_t result = _cg_jcopy_sample_rows((char *)(v9 + 64), 0, a5 + 8 * *a6, 0, 1, *(unsigned int *)(v9 + 76));
    *(_DWORD *)(v9 + 72) = 0;
  }
  else
  {
    unsigned int v12 = *(_DWORD *)(v9 + 80);
    uint64_t v13 = *a6;
    if (v12 >= a7 - (int)v13) {
      unsigned int v12 = a7 - v13;
    }
    if (v12 >= 2) {
      unsigned int v10 = 2;
    }
    else {
      unsigned int v10 = v12;
    }
    uint64_t v15 = *(void *)(a5 + 8 * v13);
    if (v10 < 2)
    {
      uint64_t v14 = *(void *)(v9 + 64);
      *(_DWORD *)(v9 + 72) = 1;
    }
    else
    {
      uint64_t v14 = *(void *)(a5 + 8 * (v13 + 1));
    }
    uint64_t v16 = v14;
    uint64_t result = (char *)(*(uint64_t (**)(void))(v9 + 24))();
  }
  *a6 += v10;
  *(_DWORD *)(v9 + 80) -= v10;
  if (!*(_DWORD *)(v9 + 72)) {
    ++*a3;
  }
  return result;
}

uint64_t h2v2_merged_upsample(uint64_t result, void *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = *(void **)(result + 640);
  uint64_t v5 = *(void *)(result + 440);
  uint64_t v7 = v4[4];
  uint64_t v6 = v4[5];
  uint64_t v8 = v4[6];
  uint64_t v9 = v4[7];
  unsigned int v10 = *(unsigned __int8 **)(*a2 + 16 * a3);
  uint64_t v11 = *(unsigned __int8 **)(*a2 + 8 * ((2 * a3) | 1));
  unsigned int v12 = *(unsigned __int8 **)(a2[1] + 8 * a3);
  uint64_t v13 = *(unsigned __int8 **)(a2[2] + 8 * a3);
  uint64_t v15 = *(unsigned char **)a4;
  uint64_t v14 = *(unsigned char **)(a4 + 8);
  unint64_t v16 = *(unsigned int *)(result + 136);
  if (v16 >= 2)
  {
    uint64_t v17 = 0;
    unint64_t v18 = v16 >> 1;
    do
    {
      uint64_t v19 = v12[v17];
      uint64_t v20 = v13[v17];
      uint64_t v21 = *(int *)(v7 + 4 * v20);
      uint64_t v22 = *v10;
      uint64_t v23 = *(int *)(v6 + 4 * v19);
      uint64_t v24 = (*(void *)(v8 + 8 * v20) + *(void *)(v9 + 8 * v19)) >> 16;
      unsigned char *v15 = *(unsigned char *)(v5 + v21 + v22);
      v15[1] = *(unsigned char *)(v5 + v22 + (int)v24);
      _OWORD v15[2] = *(unsigned char *)(v5 + v23 + v22);
      uint64_t v25 = v10[1];
      v15[3] = *(unsigned char *)(v5 + v21 + v25);
      v15[4] = *(unsigned char *)(v5 + v25 + (int)v24);
      v15[5] = *(unsigned char *)(v5 + v23 + v25);
      uint64_t v26 = *v11;
      unsigned char *v14 = *(unsigned char *)(v5 + v21 + v26);
      v14[1] = *(unsigned char *)(v5 + v26 + (int)v24);
      _OWORD v14[2] = *(unsigned char *)(v5 + v23 + v26);
      uint64_t v27 = v11[1];
      v14[3] = *(unsigned char *)(v5 + v21 + v27);
      LOBYTE(v21) = *(unsigned char *)(v5 + v27 + (int)v24);
      uint64_t v28 = v10 + 2;
      unsigned int v29 = v11 + 2;
      v14[4] = v21;
      v15 += 6;
      v14[5] = *(unsigned char *)(v5 + v23 + v27);
      v14 += 6;
      ++v17;
      v11 += 2;
      v10 += 2;
    }
    while (v18 != v17);
    LODWORD(v16) = *(_DWORD *)(result + 136);
    v13 += v17;
    v12 += v17;
    unsigned int v10 = v28;
    uint64_t v11 = v29;
  }
  if (v16)
  {
    uint64_t v30 = *v13;
    uint64_t v31 = *(int *)(v7 + 4 * v30);
    uint64_t v32 = *v12;
    unint64_t v33 = *(void *)(v8 + 8 * v30) + *(void *)(v9 + 8 * v32);
    uint64_t v34 = *(int *)(v6 + 4 * v32);
    uint64_t v35 = *v10;
    v33 >>= 16;
    unsigned char *v15 = *(unsigned char *)(v5 + v31 + v35);
    v15[1] = *(unsigned char *)(v5 + v35 + (int)v33);
    _OWORD v15[2] = *(unsigned char *)(v5 + v34 + v35);
    uint64_t v36 = *v11;
    unsigned char *v14 = *(unsigned char *)(v5 + v31 + v36);
    v14[1] = *(unsigned char *)(v5 + v36 + (int)v33);
    _OWORD v14[2] = *(unsigned char *)(v5 + v34 + v36);
  }
  return result;
}